Artiﬁcial Intelligence 170 2006 739778 wwwelseviercomlocateartint Solving logic program conﬂict strong weak forgettings Yan Zhang Norman Y Foo b Intelligent Systems Laboratory School Computing Mathematics University Western Sydney Penrith South DC NSW 1797 Australia b School Computer Science Engineering University New South Wales Sydney NSW 2052 Australia Received 6 September 2005 received revised form 23 February 2006 accepted 23 February 2006 Available online 29 March 2006 Abstract We consider forget set atoms logic program Intuitively set atoms forgotten logic program atoms set eliminated program way atoms related program affected We deﬁne notions strong weak forgettings logic programs capture intuition reveal close connections notion forgetting classical propositional theories provide precise semantic characterization Based notions develop general framework conﬂict solving logic programs We investigate semantic properties features relation strong weak forgettings conﬂict solving proposed framework We argue important conﬂict solving problems represented framework In particular major logic program update approaches transformed framework approach speciﬁc conﬂict solving case certain constraints We study essential computational properties strong weak forgettings conﬂict solving framework 2006 Elsevier BV All rights reserved Keywords Conﬂict solving Knowledge representation Answer set semantics Logic program update Computational complexity 1 Introduction 11 Motivation One promising approach research reasoning knowledge dynamics represent agents knowledge bases logic programs necessary updatesrevisions conducted way modeling agents knowledge evolution A key issue study solve conﬂicts inconsistencies logic programs 15 We observe typical conﬂict solving problems applications essential reasoning agents knowledge change properly handled traditional logic program updates Let consider Some results presented paper published IJCAI2005 AAAI2005 Y Zhang NY Foo K Wang Solving logic program conﬂict strong weak forgettings Proceedings 19th International Joint Conference Artiﬁcial Intelligence IJCAI05 2005 pp 627632 Y Zhang NY Foo A uniﬁed framework representing logic program updates Proceedings 20th National Conference Artiﬁcial Intelligence AAAI05 2005 pp 707712 Corresponding author Email addresses yancituwseduau Y Zhang normancseunsweduau NY Foo 00043702 matter 2006 Elsevier BV All rights reserved doi101016jartint200602002 740 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 scenario John wants Sue help complete assignment He knows Sue help busy Tom good friend John wants John let copy Johns assignment Then John learns Sue hates Tom help lets Tom copy assignment completed Sues help While John care Sue hates Tom consider Sues condition offer help What John going We formalize scenario logic programming setting We represent Johns knowledge base ΠJ r1 completeJohn Assignment helpSue John r2 helpSue John BusySue r3 goodFriendJohn Tom r4 copyTom Assignment goodFriendJohn Tom completeJohn Assignment Sues knowledge base ΠS r5 hateSue Tom r6 helpSue John copyTom Assignment In order Sues knowledge base account John update knowledge base ΠJ terms Sues ΠS In way John obtains solution Π ﬁnal r1 r2 r3 r5 r6 stable model know Sue help John complete assignment John let Tom copy assignment Although conﬂict ΠJ ΠS solved updating result satisfactory For instance John wants Sue help intention contain information Sue hates Tom new knowledge base J As alternative John weaken knowledge base forgetting atom copyTom Assignment ΠJ order accommodate Sues constraint help Then John new program Π ﬁnalcid4 r1 r2 r3 John remains maximal knowledge subset consistent Sues condition involved Sues personal feeling Tom J The formal notion forgetting propositional theories initially considered Lin Reiter cognitive robotics perspective 18 recently received great attention KR community It shown theory forgetting important applications solving knowledge base inconsistencies belief update merging abductive reasoning causal theories actions reasoning knowledge propositional modal logic frameworks 13141924 Then natural question develop analogous theory forgetting logic programs apply foundational basis conﬂict solving logic programs This paper provides answer question 12 Summary contributions paper The main contributions paper summarized follows 1 We deﬁne notions strong weak forgettings logic programs answer set programming semantics We reveal close connections notion forgetting classical propositional theories provide precise semantic characterization 2 Based notions develop general framework conﬂict solving called logic program contexts Under framework conﬂicts solved strongly orand weakly forgetting certain sets atoms corresponding programs We framework general represent important conﬂict solving problems In particular ﬁrst time demonstrate major logic program update approaches transformed framework 3 We investigate essential computational properties relation strong weak forgettings conﬂict solving proposed framework Speciﬁcally answer set programming disjunction head associated inference problem strong weak forgettings coNPcomplete irrele vance problem related strong weak forgettings conﬂict solving coDPcomplete We study computational problems related computation strong weak forgetting conﬂict solving Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 741 13 Structure paper The rest paper organized follows We ﬁrst present preliminary deﬁnitions concepts Section 2 In Section 3 formal deﬁnitions strong weak forgettings logic programs present essential properties Based notions strong weak forgettings Section 4 propose framework called logic program contexts general conﬂict solving logic programs In Section 5 investigate semantic properties features relation strong weak forgettings conﬂict solving proposed framework In Section 6 conﬂict solving framework general represent major logic program update approaches In Section 7 study essential computational properties strong weaking forgettings conﬂict solving Finally Section 8 conclude paper discussions 2 Preliminaries We consider ﬁnite propositional normal logic programs rule form b1 bm c1 cn 1 propositional atom b1 bm c1 cn propositional atoms presents negation failure From 1 know normal logic program contain classical negation disjunction head When rule 1 called constraint Given rule r form 1 denote headr posr b1 bm negr c1 cn bodyr posr negr Therefore rule 1 simply represented form headr posr negr 2 denote negr c1 cn We use atomr denote set atoms occurring rule r For program Π deﬁne notions headΠ rΠ negr bodyΠ rΠ atomr Given sets atoms P Q use notion rΠ bodyr atomΠ rΠ headr posΠ rΠ posr negΠ cid2 cid2 cid2 cid2 cid2 cid4 r headr cid3 posr P cid4 cid4 cid3 negr Q denote rule r cid4 obtained r removing atoms occurring P Q positive negation failure parts respectively The stable model program Π deﬁned follows Firstly consider Π program rule contain negation failure A ﬁnite set S propositional atoms called stable model Π S smallest set rule b1 bm Π b1 bm S S Now let Π arbitrary normal logic program For set S atoms program Π S obtained Π deleting 1 rule Π contains c body c S 2 subformulas c bodies remaining rules Then S stable model Π S stable model Π S 7 We Π S result GelfondLifschitz transformation Π S It easy program stable models A program called consistent stable model We atom entailed program Π denoted Π stable model Π Two programs Π1 Π2 equivalent Π1 Π2 stable models Π1 Π2 called strongly equivalent program Π Π1 Π Π2 Π equivalent 17 The concept strong equivalence simplify program For example programs strongly equivalent program contained particular program replaced program safely The following observation gives instances case useful later formalization Observation 1 Let Π logic program Π Then Π strongly equivalent set iff rule r Π following forms 1 headr cid7 headr posr 2 posr negr cid7 1 1 This result viewed special case general results proved 9 20 respectively 742 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 For convenience later reference paper types rules mentioned valid rules Let Π logic program We use ΠC denote conjunctive normal form obtained Π translating rule form 1 Π clause b1 bm c1 cm Note translation classical sense replace negation failure classical negation For instance Π b c ΠC b c In general write ΠC C1 Cn Ci conjunct ΠC If C clause subformula C subclause C Now introduce notion forgetting classical propositional theory 1819 Let T propositional theory We use T ptrue T pfalse resp denote theory obtained T substituting occurrences propositional atom p true false resp For instance T p q q r s T qtrue r s T qfalse p2 Then deﬁne notion forgetting terms propositional theory For given propositional theory T set propositional atoms P result forgetting P T denoted ForgetT P deﬁned inductively follows ForgetT T Forget Forget T ptrue T pfalse cid3 ForgetT p P cid3 T p cid3 T P p Forget cid4 cid4 cid4 It easy ordering atoms P considered affect ﬁnal result forget ting P T Consider T p q q r s From deﬁnition ForgetT q r s p 3 Strong weak forgettings logic programs 31 Deﬁnitions Let consider forget set atoms logic program Intuitively expect forgetting set atoms occurrences atoms underlying program eliminated way Those atoms having certain connections forgotten atoms rules program affected depending situation atoms affected We observe forgetting deﬁnition propositional theories directly logic programs logic programs disjuncted Further different ways handling negation failure forgetting lead different resulting programs For example suppose program Π containing rules b b c Now want forget atom b simply remove second rule replace ﬁrst rule c In case forgetting b remove b rule replacement However things simple change program b b c want forget atom b In case method replacement mentioned working replacing ﬁrst rule c change entire semantics program One way completely remove second rule b forgotten ﬁrst rule reduced completely removed depending assume b true false These examples actually reﬂect intuition deﬁning forgetting notions logic programs To formalize idea forgetting logic programs ﬁrst introduce program transformation called reduction The intuition reduction easily illustrated follows Given program Π p q pcid4 p qcid4 performing reduction Π respect atom p result new program Π cid4 pcid4 q qcid4 The formal deﬁnition presented follows 2 For convenience consider ﬁnite set formulas single conjunction elements set Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 743 Deﬁnition 1 Program reduction Let Π program p atom We deﬁne reduction Π respect p denoted ReductΠ p program obtained Π 1 rule r headr p rule r cid4 p posr cid4 replacing r cid4 new rule r cid4cid4 headr cid4 posr cid4 p posr negr negr cid4 2 rule r cid4 Π replaced r cid4cid4 1 removing rule r remaining program Let P set propositional atoms Then reduction Π respect P inductively deﬁned follows ReductΠ Π cid4 cid3 Π P p Reduct Reduct cid3 Reduct cid3 Π p cid4 P cid4 Note program reduction deﬁnition Step 1 Sakama Sekis 23 Brass Dixs 4 unfolding logic programs While unfolding eliminate positive middle occurrences atom logic program reduction hand remove rules heads atom Now let consider program Π b b d e Then cid3 cid4 b Π cid4 cid3 Π b b b d e d e cid3 Reduct cid3 Reduct Reduct Reduct cid4 cid4 A brief glimpse example indicate program reduction deﬁned programs look different However easy strongly equivalent simpliﬁed d e The following proposition actually shows program reduction deﬁned strong equivalence Proposition 1 Let Π logic program p q propositional atoms Then ReductReductΠ p q strongly equivalent ReductReductΠ q p Proof To prove result need consider general case iterated reductions captures possible features For purpose sufﬁcient deal program Π Π1 Π2 possible reductions related atoms p q happened Π1 That assume Π1 consists parts Π11 Π12 Π13 Π14 Π15 Π16 Π11 r1 p posr1 negr1 rh p posrh negrh Π12 rh1 p q posrh1 negrh1 rk p q posrk negrk Π13 rk1 q posrk1 negrk1 rl q posrl negrl Π14 rl1 q p posrl1 negrl1 rm q p posrm negrm 744 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 Π15 rm1 am1 p posrm1 negrm1 rn p posrn negrn Π16 rn1 bn1 q posrn1 negrn1 rs bs q posrs negrs ai cid7 p ai cid7 q bj cid7 p bj cid7 q ai bj p q occur posri 1 s We assume p q headΠ2 posΠ2 reduction related p q occur Π2 It hard Π covers possible cases reductions Π respect atoms p q In order avoid tedious proof loss generality consider simpliﬁed version program Π follows Π Π1 Π2 Π1 contains following rules r1 p posr1 negr1 cid4 cid4 cid4 1 p q posr 1 negr 1 r r2 q posr2 negr2 cid4 cid4 cid4 2 q p posr 2 negr 2 r r3 p posr3 negr3 r4 b q posr4 negr4 We assume p q occur posr1 posr cid4 2 Also rules Π2 contain p q heads positive bodies We mention following proof extended general case Π constructed earlier 1 posr2 posr cid4 Firstly ReductΠ p Π cid4 1 Π2 consists following rules cid3 cid4 cid4 negr1 negr 2 cid4 cid3 cid4 cid4 1 negr negr 2 cid4 cid3 negr1 negr3 cid4 cid4 1 negr3 cid3 negr cid3 posr r2 q posr2 negr2 cid3 cid4 cid4 cid4 posr1 posr 2 q 2 r cid4 cid4 cid4 cid4cid4 1 posr 2 q q 2 r cid4 cid3 cid4 3 posr1 posr3 r cid4 cid3 cid4 cid4cid4 1 posr3 3 q posr r r4 b q posr4 negr4 From Observation 1 know r cid4cid4 2 Then reduction Π cid4 1 Π cid4cid4 1 Π2 Π cid4cid4 3 r4 Π2 respect q following result ReductReductΠ p q strongly equivalent set So Π cid4 1 r2 r cid4 3 r cid4cid4 2 r cid4 1 contains following rules cid4 cid3 cid4 cid3 cid4 3 negr1 negr3 posr1 posr3 r cid4 cid3 cid4 cid3 cid4 cid4 1 negr2 negr3 posr2 posr3 negr posr1 r cid3 cid4 cid3 cid4 cid4 cid4 cid4 posr posr1 posr1 1 negr negr1 negr 2 posr3 r cid4 cid3 cid4 cid3 cid4 negr2 negr4 posr2 posr4 4 b r cid4 cid3 cid4 cid3 cid4 cid4cid4 negr1 negr2 negr4 2 posr4 posr1 posr 4 b r cid4 cid4 2 negr3 It easy programs r cid4 Therefore rule r cid4 negr cid4 3 removed So ﬁnally Π cid4cid4 1 r cid4 3 r r cid4 4 r cid4cid4 4 strongly equivalent posr cid4 3 posr cid4 negr cid4 3 3 r cid4 r cid4 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 745 Now consider ReductΠ q It easy ReductΠ q Π Π2 Π consists following rules cid3 negr cid3 negr cid4 cid4 1 negr2 cid4 cid4 cid4 1 negr 2 r1 p posr1 negr1 cid3 cid4 cid4 cid4cid4 1 posr2 1 p posr r cid4 cid3 cid4cid4cid4 cid4 cid4 1 posr 1 p p posr r 2 r3 p posr3 negr3 cid4 cid3 cid4 posr2 posr4 4 b r cid4 cid4 cid4cid4 2 posr4 4 b p r 1 removed Π So Π r1 r cid4cid4 cid4 cid3 negr2 negr4 cid4 cid4 2 negr4 cid3 negr cid3 posr Also rule r cid4cid4cid4 Π Π2 Π consists following rules 1 r3 r cid4 4 r cid4cid4 4 Then ReductReductΠ q p cid4 cid3 posr1 posr3 cid4 cid3 negr1 negr3 cid3 negr cid4 cid4 1 posr2 posr3 cid4 3 r cid3 posr r cid4 cid3 cid4 posr2 posr4 4 b r cid4 cid3 cid4 cid4cid4 posr1 posr 2 posr4 4 b r cid4 cid3 cid4 r b 2 posr4 posr1 posr2 posr 4 posr know programs r cid4cid4 4 r cid4cid4 cid4 cid3 negr2 negr4 cid3 negr1 negr 3 r r cid4 Π cid4cid4 4 Since posr cid4cid4 Π Therefore Π r cid4 1 This proves result cid2 cid4 cid4 1 negr2 negr3 cid4 cid4 2 negr4 cid3 negr1 negr2 negr cid4 cid4 2 negr4 4 r r strongly equivalent So r removed Example 1 Let Π1 b d c e Π2 c b c d Π2 b b d c e Then ReductΠ1 c b e c d e ReductΠ2 Π2 ReductΠ3 b c d e Deﬁnition 2 Strong forgetting Let Π logic program p propositional atom We deﬁne program result strongly forgetting p Π denoted SForgetLPΠ p obtained following transformation 1 Π cid4 ReductΠ p 2 Π cid4 Π cid4 r r valid rule 3 Π cid4 Π cid4 r headr p 4 Π cid4 Π cid4 r p posr 5 Π cid4 Π cid4 r p negr 6 SForgetLPΠ p Π cid4 Let closer look Deﬁnition 2 Step 1 perform reduction Π respect atom p This replace positive middle occurrences p rules rules having p head Step 2 remove valid rules introduced reduction Π respect p From Observation 1 know change program Steps 3 4 remove rules p head positive body Note reduction exist pair rules r r cid4 headr p p posr cid4 The intuitive meaning steps forgetting p atoms information rules having p heads positive bodies lost relevant p atoms serve support p p supports atoms On hand Step 5 states rule containing p negation failure removed The consideration step follows If think negr support headr p negr forgotten headrs entire support lost Clearly treatment negation failure forgetting strong sense atoms lost p Therefore kind forgetting strong forgetting Deﬁnition 2 easily extended case strongly forgetting set atoms 746 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 SForgetLPΠ Π cid4 cid3 Π P p SForgetLP cid3 cid3 Π p SForgetLP SForgetLP cid4 P cid4 With different way dealing negation failure weak version forgetting deﬁned Deﬁnition 3 Weak forgetting Let Π logic program p propositional atom We deﬁne program result weakly forgetting p Π denoted WForgetLPΠ p obtained following transformation 1 Π cid4 ReductΠ p 2 Π cid4 Π cid4 r r valid rule 3 Π cid4 Π cid4 r headr p 4 Π cid4 Π cid4 r p posr 5 Π cid4 Π cid4 Π Π Π r p negr Π r cid4 r cid4 headr posr notnegr p r Π 6 WForgetLPΠ p Π cid4 WForgetLPΠ p deﬁned way SForgetLPΠ p Step 5 Suppose rule like r b posr negr p negr Instead viewing negr support headr treat default evidence headr condition posr atoms negr presented headr derived Therefore forgetting p result absence p case So r replaced r cid4 b posr notnegr p The notion weakly forgetting set atoms denoted WForgetLPΠ P deﬁned accordingly WForgetLPΠ Π cid4 cid3 Π P p WForgetLP cid3 cid3 Π p WForgetLP WForgetLP cid4 P cid4 The following proposition ensures strong weak forgettings logic programs deﬁned strong equivalence Proposition 2 Let Π logic program p q propositional atoms Then 1 SForgetLPSForgetLPΠ p q strongly equivalent SForgetLPSForgetLPΠ q p 2 WForgetLPWForgetLPΠ p q strongly equivalent WForgetLPWForgetLPΠ q p Proof We prove Result 1 Result 2 proved similar way Similar proof Proposition 1 loss generality consider program Π Π1 Π2 Π1 contains following rules r1 p posr1 negr1 cid4 cid4 cid4 1 p q posr 1 negr r 1 r2 q posr2 negr2 cid4 cid4 cid4 2 q p posr 2 negr r 2 r3 p posr3 negr3 r4 b q posr4 negr4 We assume p q occur posr1 posr cid4 heads positive bodies contain p q 1 posr2 posr cid4 2 Also rules Π2 contain p q Then ReductΠ p ReductΠ1 p Π2 according proof Proposition 1 ReductΠ1 p consists following rules r2 q posr2 negr2 cid4 cid4 cid4 2 q r 2 cid3 posr1 posr cid3 negr1 negr cid4 cid4 2 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 747 cid3 posr cid3 negr cid4 cid4 cid4 cid4 cid4 cid4 cid4cid4 1 negr 1 posr 2 q q 2 2 r cid4 cid3 cid4 cid3 cid4 negr1 negr3 posr1 posr3 3 r cid4 cid4 cid3 cid4 cid4 cid4cid4 1 negr3 1 posr3 3 q posr r r4 b q posr4 negr4 cid3 negr Then Step 2 removing valid rules rule r cid4cid4 Π cid4 3 r4 Π cid4 1 removed contain p according Step 5 transformation Π cid4 Π2 rules containing p removed Note rules Π cid4 2 removed So write SForgetLPΠ p Π cid4 r2 r cid4 3 r cid4cid4 2 r cid4 1 2 2 1 2 contain rule having q head positive 2 By ignoring details ﬁnal resulting program 1 2 q Since Π cid4 1 qΠ cid4 Now consider SForgetLPΠ cid4 1 Π cid4 Π cid4 2 q ReductΠ cid4 2 q Π cid4cid4 1 consists following rules body ReductΠ cid4 1 Π cid4cid4 Π cid4 SForgetLPΠ cid4 1 cid4 cid3 posr1 posr3 cid3 cid4 cid4 1 posr2 posr3 posr cid4 cid3 posr2 posr4 cid4 cid3 cid4 2 posr4 posr1 posr 2 Π cid4cid4 cid4 cid3 negr1 negr3 cid4 cid3 cid4 1 negr2 negr3 negr cid4 cid3 negr2 negr4 cid4 cid3 negr1 negr2 negr4 cid4 3 r r cid4 4 b r cid4cid4 4 b r Π cid4cid4 2 rules containing q removed Again rules r cid4 Π cid4 2 contain q Let denote resulting program elimination Π cid4 Π cid4cid4 1 containing p q removed Π cid4 1 Let examine result SForgetLPSForgetLPΠ q p Firstly ReductΠ q ReductΠ1 q Π2 ReductΠ1 q consists following rules 3 r r cid4 1 Π cid4 1 4 r cid4cid4 removed 1 rule 4 Π cid4cid4 Now consider SForgetLPΠ 1 Π 2 p ReductΠ 2 p Since Π 1 p Π 2 contain rule having p head posi 2 Then ReductΠ 1 1 p Π cid4 2 Π 1 r3 r cid4 Π 4 1 1 removed contain r1 r cid4cid4 cid3 negr cid3 negr cid4 cid4 1 negr2 cid4 cid4 cid4 1 negr 2 r1 p posr1 negr1 cid4 cid3 cid4 cid4cid4 1 posr2 1 p posr r cid4 cid3 cid4 cid4cid4cid4 cid4 1 posr 1 p p posr r 2 r3 p posr3 negr3 cid4 cid3 cid4 cid3 cid4 negr2 negr4 posr2 posr4 4 b r cid4 cid4 cid4 cid4 cid4cid4 2 negr4 2 posr4 4 b p r 1 removed So write SForgetLPΠ q Π Again Step 2 rule r cid4cid4cid4 r cid4cid4 4 q Π2 rules containing q removed Also rules Π Π 2 cid3 negr cid3 posr 1 Π tive body ReductΠ 1 following rules cid4 cid3 posr1 posr3 cid4 cid3 negr1 negr3 cid3 negr cid4 cid4 1 posr2 posr3 cid4 3 r cid3 posr r cid4 cid3 cid4 posr2 posr4 4 b r cid4 cid3 cid4 cid4cid4 2 posr4 posr1 posr 4 b r This program Π cid4cid4 p according Step 5 Then clearly resulting program Π cid4 Π So performing Steps 25 ﬁnally SForgetLPΠ 1 1 shown Also note rules r cid4 cid4 cid3 negr2 negr4 cid3 negr1 negr cid4 cid4 1 negr2 negr3 cid4 cid4 2 negr4 rules containing p removed Obviously Π cid4 2 Π cid4cid4 4 r cid4cid4 3 r r cid4 1 mentioned Π cid4 2 p Π cid4 1 2 This proves result cid2 4 removed contain 2 Π cid4 2 Π 2 748 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 Example 2 Let Π1 b b Π2 b c e d e e Then cid4 cid3 Π1 SForgetLP cid3 Π1 b SForgetLP cid4 cid3 Π1 WForgetLP cid3 Π1 b WForgetLP cid3 Π2 SForgetLP cid3 Π2 WForgetLP cid4 cid4 b cid4 d b e c cid4 d b e c e 32 Relationship forgetting propositional theories As argued earlier notion forgetting propositional theories applicable logic programs generally However close connections forgetting propositional theories strong weak forgettings logic programs Let ﬁrst consider following example Example 3 Let Π b c d e f Then cid4 cid3 Π SForgetLP cid3 Π WForgetLP e f cid4 d e f Now consider ForgetΠC logically equivalent formula b c d f e Then clear cid4 cid3 ΠC Forget cid3 cid5 Π WForgetLP cid4cid6 cid4cid6 cid3 cid5 C Π SForgetLP cid4 cid3 C Forget ΠC The example motivates examine deeper connections strong weak forgettings logic programs forgetting propositional theories To begin introduce useful notion Let Π program L clause L l1 lk li propositional literal We L Π coherent exists subset Π cid4 Π set atoms P atomΠ P ReductΠ cid4 P C single clause L subclause ReductΠ cid4 P C Intuitively coherence notion tries specify clauses parts clauses generated program Π reduction Consider program Π b d c e d Clause d b Π coherent clause d e Obviously rule r Π rC Π coherent The following proposition provides semantic account Π coherent clauses Proposition 3 Let Π program L Π coherent clause Then ΠC L L Φ clause Φ ΠC Φ Proof Note L Π coherent ﬁnd subset Π cid4 Π set atoms P atomΠ ReductΠ cid4 P contains rule r L subclause rC Recall reduction ReductΠ cid4 P eliminate positive middle occurrences P rules Π cid4 remove rules heads P positive mid dle occurrences exist Π cid4 Then easy observe ΠC ReductΠ cid4 P C If L ReductΠ cid4 P C ΠC L If L proper subclause ReductΠ cid4 P C L ReductΠ cid4 P C This proves result cid2 Deﬁnition 4 Let Π logic program ϕ ϕ1 ϕ2 propositional formulas ϕ1 ϕ2 conjunctive normal forms 1 ϕ1 called consequence ϕ respect Π ϕ ϕ1 conjunct ϕ1 Π coherent ϕ1 strongest consequence ϕ respect Π ϕ1 consequence ϕ respect Π exist consequence ϕcid4 cid7 ϕ1 respect Π ϕcid4 1 1 ϕ ϕcid4 ϕ1 1 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 749 2 ϕ2 called premiss ϕ respect Π ϕ2 ϕ conjunct ϕ2 Π coherent ϕ2 weakest premiss ϕ respect Π ϕ2 premiss ϕ respect Π exist premiss ϕcid4 2 ϕ ϕcid4 2 cid7 ϕ2 respect Π ϕ2 ϕcid4 2 Example 4 Example 3 continued It easy verify SForgetLPΠ aC strongest consequence ForgetΠC WForgetLPΠ aC weakest premiss ForgetΠC In fact following theo rem conﬁrms true Theorem 1 Let Π logic program P set atoms Then SForgetLPΠ P C strongest consequence ForgetΠC P respect Π WForgetLPΠ P C weakest premiss ForgetΠC P respect Π Proof We prove ﬁrst result second proved similar way To simplify proof consider set P singleton P p The general case proved induction size P Without loss generality assume program Π following form Π Π1 Π2 Π3 Π1 contains rules related process reduction Π respect p Π2 contain rules containing p heads positive bodies Π2 irrelevant reduction process contains rules having p negative bodies Π3 contain rules having p heads positive negative bodies Obviously Π3 irrelevant process strongly forgetting p Π In particular assume Π1 Π2 following forms Π1 r1 p posr1 negr1 rk p posrk negrk rk1 qk1 p posrk1 negrk1 rm qm p posrm negrm Π2 rm1 qm1 posrm1 p negrm1 rn qn posrn p negrn In Π1 assume p posri 1 m rules having p heads omitted Π1 according Observation 1 For Π2 hand p posrj j m 1 n Then according Deﬁnition 1 ReductΠ p Π cid4 1 Π2 Π3 Π cid4 1 follows r1k1 qk1 posr1 posrk1 negr1 negrk1 r1m qm posr1 posrm negr1 negrm rkk1 qk1 posrk posrk1 negrk negrk1 rkm qm posrk posrm negrk negrm Note p occur negative bodies rules Π cid4 p occurs negative bodies rules Π cid4 case Π2 1 However simplify proof consider 1 ps occurrences negative bodies presented 750 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 Now consider SForgetLPΠ p Clearly SForgetLPΠ p Π cid4 1 Π3 Π2 removed Step 5 Deﬁnition 2 Then conclude cid3 Π p SForgetLP C Π cid4cid6 cid5 C Π3C C consists following clauses cid4 1 Π cid4 1 cid7 qk1 posr1 posrk1 cid7 qm posrk posrm cid8 cid8 negr1 cid8 cid9 negrk1 3 negrk cid8 cid9 negrm Obviously clause SForgetLPΠ p Π coherent Now consider ForgetΠC p Firstly observe cid3 ΠC p cid4 Forget Φ Π3C Φ formula Π1Cptrue Π2Cptrue Π1Cpfalse Π2Cpfalse Π1Cptrue Π2Cptrue consists following clauses cid8 qk1 posrk1 qm posrm cid8 negrk1 negrm Π1Cpfalse Π2Cpfalse contains following clauses cid8 posr1 posrk negr1 cid8 negrk cid8 negrm1 qm1 posrm1 qn posrn cid8 negrn Then translating Φ CNF ConΦ easy clauses Π cid4 1 So SForgetLPΠ pC consequence ForgetΠC p respect Π C contained ConΦ Observing ConΦs structure know ConΦ contains following clauses qk1 posrk1 qk1 posrk1 qm posrm cid8 cid8 cid8 negrk1 qm1 posrm1 negrm1 cid8 negrk1 qn posrn cid8 negrn negrm qn posrn cid8 negrn According structure Π clauses Π coherent Therefore exist conse quence ϕcid4 ForgetΠC p respect Π ϕcid4 SForgetLPΠ pC This proves result cid2 Theorem 1 actually states certain set propositional atoms P conjunctive normal form strong forgetting P program Π strongest formula implied forgetting P corre sponding propositional theory conjunctive normal form weak forgetting P Π weakest 3 Here posr presents disjunction negative atoms atoms occur posr negr cid10 negr presents disjunction atoms Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 751 formula implies So semantically notions strong weak forgettings logic programs strongest necessary weakest sufﬁcient conditions respectively forgetting corresponding propositional theory 33 A semantic characterization From previous presentation strong weak forgettings deﬁned syntactic way This major differences comparing forgetting notion propositional theories equivalent model theoretic semantics provided resulting theory forgetting atoms 19 Although corresponding model theoretic deﬁnitions strong weak forgettings following property precisely characterizes stable models strong weak forgettings Firstly observe consistency program Π necessarily imply consistent SForgetLPΠ P WForgetLPΠ P set atoms P vice versa For example consider program Π b b weakly forgetting Π result inconsistent program b b Similarly strongly forgetting inconsistent program Π b c b c consistent program c b c Theorem 2 explains happens Given program Π set atoms P specify programs X Y Program X subset Π containing types rules Π 1 p P p headΠ rule r Π p posr X 2 p P p posΠ rule r Π headr p X 3 rule r Π negr P cid7 types 1 2 X Clearly X contains rules Π satisfying atomr P cid7 affected ReductΠ P On hand program Y obtained follows rule r X type 3 replacement r form r cid4 headr posr notnegr P Y It noted X Y obtained linear time terms sizes Π P Then following result Theorem 2 Let Π program P set atoms A set atoms S stable model SForgetLPΠ P WForgetLPΠ P resp iff program Π X Π X Y resp stable model Scid4 S Scid4 P Proof From deﬁnition X X contains exactly rules Π affected ReductΠ P removed SForgetLPΠ P So SForgetLPΠ P ReductΠ P X ReductΠ X P suppose valid rule presented inﬂuence result So easy SForgetLPΠ P stable model S iff Π X stable model Scid4 S Scid4 P Similarly observe WForgetLPΠ P ReductΠ X Y P cid2 It interesting note given program Π set atoms P computing SForgetLPΠ P WForgetLPΠ P need exponential time Section 7 stable models computed program obtained Π linear time 4 Logic program contextsA framework conﬂict solving In section deﬁne general framework called logic program contexts represent knowledge consists multiple agents knowledge bases We consider issue conﬂicts occurring reasoning underlying logic program context As shown notions strong weak forgettings proposed earlier provide basis solving conﬂicts Deﬁnition 5 Logic program context A logic program context nary tuple Σ Φ1 Φn Φi triplet Πi Ci Fi Πi Ci logic programs Fi atomΠi set atoms We Φi ith component Σ A logic program context Σ consistent Πi Ci consistent Σ conﬂictfree j Πi Cj consistent In Deﬁnition 5 component Φi Σ represents agent local situation Πi agent knowledge base Ci set constraints agent comply change case Fi set atoms agent forget necessary Now problem conﬂict solving setting stated follows given logic program context Σ Φ1 Φn consistent conﬂictfree ﬁnd 752 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 alternative logic program context Σ cid4 Φcid4 sense 1 Φcid4 n Σ cid4 conﬂictfree closest original Σ We ﬁrst present formal deﬁnitions solution solves conﬂicts logic program context Deﬁnition 6 Solution Given logic program context Σ Φ1 Φn Φi Πi Ci Fi We logic program context Σ cid4 solution solves conﬂicts Σ Σ cid4 satisﬁes following conditions 1 Σ cid4 conﬂictfree 2 For Φcid4 Pi Fi Σ cid4 Φcid4 Π cid4 Ci Fi Π cid4 SForgetLPΠi Pi Π cid4 WForgetLPΠi Pi We denote set solutions solving conﬂicts Σ SolutionΣ Deﬁnition 7 Ordering solutions Given logic program contexts Σ Σ cid4 Σ cid4cid4 Σ cid4 Σ cid4cid4 SolutionΣ We Σ cid4 closer close Σ Σ cid4cid4 denoted Σ cid4 cid15Σ Σ cid4cid4 Φcid4 Ci Fi Σ cid4 Φcid4cid4 WForgetLPΠi Pi Pi Fi Π cid4cid4 WForgetLPΠi Qi Qi Fi respectively Pi Qi Fi We denote Σ cid4 Σ Σ cid4cid4 Σ cid4 cid15Σ Σ cid4cid4 Σ cid4cid4 cid7cid15Σ Σ cid4 SForgetLPΠi Qi Π cid4cid4 SForgetLPΠi Pi Π cid4 Ci Fi Σ cid4cid4 Π cid4 Π cid4cid4 Π cid4 Proposition 4 cid15Σ partial ordering Proof From deﬁnition cid15Σ easy cid15Σ reﬂexive antisymmetric So need cid15Σ transitive obvious according Deﬁnition 7 cid2 Deﬁnition 8 Preferred solution Given logic program contexts Σ Σ cid4 We Σ cid4 preferred lution solves conﬂicts Σ Σ cid4 SolutionΣ exist Σ cid4cid4 SolutionΣ Σ cid4cid4 Σ Σ cid4 It noted order achieve preferred solution strong weak forgettings apply alternatively Consider following simple example Example 5 Let Σ Φ1 Φ2 Φ1 Φ2 Π1 b c d e f d C1 d f f d F1 b c Π2 c d e e f d C2 b c F2 b c d e f Φ It easy Σ consistent conﬂictfree Π1 C2 Π2 C1 consistent Now consider logic program contexts Σ1 Φcid4 2 Σ2 Φcid4cid4 cid3 cid3 Π1 c SForgetLP cid3 cid3 Φ2 e WForgetLP cid3 cid3 Π1 b c WForgetLP cid4 cid3 cid3 C2 F2 Φ2 e WForgetLP cid4 cid4 C1 F1 cid4 cid4 C2 F2 cid4 C1 F1 cid4 2 1 Φcid4cid4 1 Φcid4 cid4 Φ Φ Φ cid4 1 cid4 2 cid4cid4 1 cid4cid4 2 It veriﬁed Σ1 Σ2 solutions solve conﬂict Σ Σ1 preferred solution Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 753 From example solve conﬂicts logic program context agent apply strong forgettings weak forgettings obtain preferred solution In sense agent freedom choose ways conﬂict solving speciﬁc constraint taken account It noted solving conﬂict strong forgetting loose atoms weak forgetting vice versa Therefore order minimally forget atoms logic program agent apply strong weak forgettings alternatively different components However practice desirable agent use uniﬁed approach conﬂict solving Our approach provided certainly accommodate requirement simply redeﬁning solution logic program context applying strong weak forgetting Example 6 We consider conﬂict solving scenario A couple John Mary discussing family investment plan They consider invest types different shares shareA shareB shareC shareD shareA shareB high risk high returns shareC shareD property investment shares lower risk suitable long term investment John interested shareA wants buy deﬁnitely He tends invest shareB invest shareC shareD However invest shareB John consider invest shareC shareD house price growing John actually sure But John consider invest On hand Mary conservative She prefers invest shareC shareD believes house price continue growing conﬁdent government plan increase Reserve Bank Mary deﬁnitely consider invest shareA shareB At consider buy shareB invest shareA shareC But Mary insists invest shareC shareD case Now John Mary negotiate achieve common agreement We ﬁrst represent John Marys investment preferences following programs respectively ΠJ r1 shareA r2 shareB shareC shareD r3 shareC houseIncrease shareB shareD r4 shareD houseIncrease shareB shareC ΠM r5 shareC houseIncrease r6 shareD houseIncrease r7 shareB shareA shareC r8 houseIncrease interestUp To negotiate John Mary set conditions respectively want compro mise CJ CM shareA shareC shareD shareA shareB shareC shareD John Mary specify logic program context solve conﬂict family investment plan ΣJM ΠJ CJ FJ ΠM CM FM FJ shareB shareC shareD note shareA forgettable atom John deﬁnitely wants buy FM shareA shareB shareC shareD Unfortunately easy check ΣJM preferred solution That means impossible John Mary solve conﬂict weakening belief sets So John Mary realize 754 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 compromise weaken belief sets beliefs account However strategy beliefs little possible To end John Mary specify new logic program context follows Σ New JM J ΠM ΔJ CM Fcid4 ΠJ ΔM CJ Fcid4 M 5 5 5 hr cid4 ΔM cid4 5 shareC houseIncrease lr cid4 r cid4 r 51 lr cid4 cid4 6 shareD houseIncrease lr cid4 r cid4 r 61 lr cid4 cid4 7 shareB shareA shareC lr cid4 r cid4 r 71 lr cid4 cid4 8 houseIncrease interestUp r cid4 r 81 lr cid4 hr cid4 hr cid4 hr cid4 7 7 6 6 6 8 8 7 lr cid4 8 1 1 1 2 hr cid4 hr cid4 ΔJ cid4 1 shareA lr cid4 r cid4 11 lr cid4 r cid4 2 shareB shareC shareD lr cid4 r cid4 21 lr cid4 r cid4 3 shareC houseIncrease shareB shareD lr cid4 r cid4 r 31 lr cid4 cid4 4 shareD houseIncrease shareB shareC hr cid4 r cid4 41 lr cid4 r FJ hr cid4 5 8 F cid4 M FM hr cid4 hr cid4 hr cid4 3 3 2 4 4 3 2 lr cid4 lr cid4 4 F cid4 J duced atoms 1 4 hr cid4 1 8 newly intro lr cid4 j lr cid4 Σ New Let closer look ΔM During conﬂict solving hr cid4 5 8 strongly weakly forgotten rules r cid4 5 8 ΔM equipped corresponding rules ΠM defeated In case John need Marys beliefs consideration On hand weakly forgotten rules r cid4 j 5 cid2 j cid2 8 hr cid4 j ΔM initiated 5 8 affect Johns decision conﬂict solving As minimal number hr cid4 lr cid4 strongly forgotten weakly forgotten resp conﬂict solving John takes minimal number Marys rules consideration The explanation applies ΔJ strongly forgotten lr cid4 j JM unique preferred solution Π cid4 cid3 ΠJ ΔM shareB lr cid4 WForgetLP cid3 ΠM ΔJ shareC lr cid4 WForgetLP J CJ F cid4 cid4 cid4 J stable models include shareA shareC shareA shareD respectively Π cid4 Π cid4 M stable model including shareA shareD Therefore John options invest shareA shareC invest shareA shareD Mary consider invest shareA shareD Finally John Mary reach agreement invest shareA shareD M CM F cid4 M J Π cid4 cid4 J cid4 M Π Π 1 8 Example 6 presents application approach solve complex logic program conﬂicts involving negotiation belief merging current methods difﬁculties deal Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 755 5 Semantic properties In section study important semantic properties relation strong weak forgettings logic program contexts 51 Irrelevance Irrelevance important issue related forgetting 18 Basically able answer query q logic program Π Π q interested knowing answer query resulting program strongly weakly forgetting set atoms Π enable signiﬁcantly simplify inference problem resulting logic program We ﬁrst formal deﬁnition irrelevance relation strong weak forgetting Deﬁnition 9 Irrelevance Let Π logic program P set atoms We atom irrelevant strong forgetting weak forgetting P Π simply sirrelevant wirrelevant resp P Π Π iff SForgetLPΠ P WForgetLPΠ P resp We irrelevant P Π sirrelevant wirrelevant P Π Trivially Π inconsistent sirrelevant wirrelevant P Π iff SForgetLPΠ P WForgetLPΠ P resp Also P atomΠ SForgetLPΠ P WForgetLPΠ P inconsistent sirrelevant wirrelevant resp P Π iff Π To provide general characterization result irrelevance need notion support Deﬁnition 10 Let Π program atom We deﬁne support respect Π set atoms Supporta speciﬁed follows S0 Si1 Si cid11 p p bodyr r Π headr cid12 cid11 p p bodyr r Π headr Si cid13 cid12 Supporta Si i0 An atom p Supporta called positive negative support p posr negr resp rule r occurring deﬁning Supporta4 Basically Supporta contains atoms occur rules related derivation program Π Therefore changing removing rules contain atoms Supporta affect atom It turns notion support plays important role deciding irrelevance Theorem 3 Let Π logic program P set atoms atom Suppose Π SForgetLPΠ P WForgetLPΠ P consistent Then following results hold 1 If headΠ irrelevant P Π 2 If P irrelevant P Π iff Π cid7 3 If P P Supporta irrelevant P Π Proof Proofs Results 1 2 trivial Here prove Result 3 To prove result need result program splitting 26 Before present program splitting result introduce notion Given program Π set atoms S use eΠ S denote program obtained Π deleting 1 rule Π having form body S 2 atoms bodies remaining rules S Intuitively 4 Note atom Supporta positive negative supports 756 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 eΠ S viewed simpliﬁed form Π given atoms S true Then restate Theorem 5 26 normal logic program setting A set atoms S stable model program Π Π Π1 Π2 bodyΠ1 headΠ2 S S1 S2 S1 stable model Π1 S2 stable model program eΠ2 S1 From deﬁnition Supporta Π expressed Π Π1 Π2 Π1 subset Π containing rules mentioned Supporta So Π1 Π2 Also observed bodyΠ1 headΠ2 Because true rule r Π2 bodyr bodyΠ1 cid7 According Π1s construction leads r Π1 That Π1 Π2 cid7 This contradiction Since P Supporta clear rules containing atoms P Π2 We use ΠP denote set rules Π From bodyΠ1 headΠ2 know stable model S Π expressed S S1 S2 S2 stable model program eΠ2 S1 Also rule r Π1 implies Π iff Π1 Now deﬁnitions strong weak forgettings condition ΠP Π2 know strong weak forgettings inﬂuence rules Π2 So SForgetLPΠ P Π1 Π WForgetLPΠ P Π1 Π headΠ headΠ2 headΠ headΠ2 This follows Π1 Π bodyΠ1 headΠ Π1 Π bodyΠ1 headΠ By result stated stable model Ss SForgetLPΠ P expressed Ss S1 S stable model Sw WForgetLPΠ P expressed Sw S1 S S1 stable model Π1 S S stable models Π Π respectively Finally observation Π iff Π1 Π iff SForgetLPΠ P Π iff WForgetLPΠ P This proves result cid2 Theorem 3 provides common conditions atom sirrelevant wirrelevant P Π However note general atoms sirrelevance imply wirrelevance vice versa Usually need deal types irrelevances separately The following theorem illustrates different sufﬁcient conditions ensure irrelevances respectively Theorem 4 Let Π logic program P set atoms atom P Suppose Π SForgetLPΠ P WForgetLPΠ P consistent Then following results hold 1 If p P Supporta p negative support Π cid7 p wirrelevant P Π 2 If p P Supporta p negative support Π p sirrelevant P Π Proof We prove Result 1 Result 2 proved similar way From proof Theorem 3 given Supporta program Π expressed Π Π1 Π2 Π1 Π2 Π1 contains rules comput ing Supporta Π iff Π1 Now let consider WForgetLPΠ P We WForgetLPΠ P expressed WForgetLPΠ P Π cid4 iff Π1 1 To simplify presentation assume P p proof general case easily extended special case Without loss generality consider Π Π1 Π2 Π1 includes following rules relation P note Π1 contain rules 2 bodyΠ cid4 headΠ cid4 2 Π cid4 Π cid4 1 r1 headr1 posr1 p negr1 r2 p posr2 negr2 r3 headr3 p posr3 negr3 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 757 Π2 includes following rules related P Π2 contain rules r4 headr4 p posr4 negr4 r5 headr5 posr5 p negr5 indicate Π2 contain rule head p rule contained Π1 rule computing Supporta Clearly weakly forgetting p Π rules r1r5 affected rules remain unchanged 1 following 2 difference Π1 Π cid4 Π cid4 Therefore WForgetLPΠ p Π cid4 1 rules Π cid4 1 cid4 1 headr1 posr1 negr1 r cid4 cid3 cid4 posr2 posr3 3 headr3 r difference Π2 Π cid4 cid4 cid3 posr2 posr4 cid4 4 headr4 r cid4 5 headr5 posr5 negr5 r 1 headΠ cid4 cid4 cid3 negr2 negr3 2 following rules Π cid4 2 cid4 cid3 negr2 negr4 This concludes bodyΠ cid4 1 weakly forgetting p actually affect derivation headr3 headr1s derivation affected p removed r cid4 1 However note Π cid7 original rule r1 Π1 formula p play role So removing p effect derivation This follows Π cid4 iff Π1 So 1 wirrelevant p Π cid2 iff Π1 Observing Π cid4 2 Now Π cid4 1 Example 7 Consider following program Π b c d e c b c It easy wirrelevant c Π This Π cid7 WForgetLPΠ c b e d b cid7 Indeed Supporta b c c negative support Π cid7 c condition Result 1 Theorem 4 holds We verify sirrelevant c Π Now suppose add extra rule Π Π cid4 Π d Here Supporta b c c negative support However Π cid4 c according Result 2 Theorem 4 sirrelevant c Π cid4 It observed wirrelevant c Π cid4 We generalize notion irrelevance logic program context Formally let Σ logic program context atom derivable Σs ith component denoted Σ Φi Πi Ci Fi Σ Πi Deﬁnition 11 Irrelevance wrt logic program contexts Let Σ Σ cid4 logic program contexts Σ cid4 SolutionΣ atom We irrelevant respect Σ Σ cid4 ith components simply Σ Σ cid4i irrelevant Σ iff Σ cid4 Given logic program context Σ atom like know preferred solution Σ cid4 Σ Σ Σ cid4i irrelevant To answer question need consider preservation irrelevance preferred ordering cid15Σ solutions Σ That Σ cid4 Σ cid4cid4 SolutionΣ Σ cid4 cid15Σ Σ cid4cid4 Σ Σ cid4cid4i irrelevant conditions Σ Σ cid4i irrelevant If preferred solutions irrelevance preserved eventually obtain irrelevance respect Σ preferred solution 758 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 We formalize idea follows Let Σ Σ cid4 Σ cid4cid4 logic program contexts Σ cid4 Σ cid4cid4 SolutionΣ We Σ Σ cid4cid4 Σ cid4 Σ cid4cid4 forgettingcongruent ith components respect Σ denoted Σ cid4 Φi Πi Ci Fi Σ Φ Φ cid4 cid4cid4 Φ Φ cid4 cid4cid4 cid3 SForgetLPΠi P cid3 SForgetLPΠi P cid4 cid4 Ci Fi cid4cid4 Ci Fi cid4 Σ cid4 cid4cid4 Σ cid3 WForgetLPΠi P cid3 WForgetLPΠi P cid4 cid4 Ci Fi cid4cid4 Ci Fi cid4 Σ cid4 cid4cid4 Σ P cid4 P cid4cid4 Fi In words solutions Σ forgettingcongruent ith components means ith components obtained performing strong forgettings weaking forgettings sets atoms Σs ith component We solutions Σ cid4 Σ cid4cid4 Σ forgettingcongruent denoted Σ cid4 Σ Σ cid4cid4 Σ cid4 Σ Σ cid4cid4 The following theorem shows forgettingcongruence sufﬁcient condition preserving irrelevance terms preferred ordering solutions Theorem 5 Let Σ Σ cid4 Σ cid4cid4 logic program contexts Σ cid4 Σ cid4cid4 SolutionΣ atom Suppose Σ cid4 cid15Σ Σ cid4cid4 Σ Σ cid4cid4i irrelevant Then Σ Σ cid4i irrelevant Σ cid4 Σ Σ cid4cid4 Π cid4cid4 Proof To prove theorem need Σ cid4 Σ cid4cid4 SolutionΣ Φcid4 Π cid4 Fi Φcid4cid4 WForgetLPΠi P cid4cid4 Ci Fi Πi Φi Σ Φcid4 Π cid4cid4 assume Πi Π cid4 Π cid4 SForgetLPΠi P cid4 Ci WForgetLPΠi P cid4 Ci Fi Φcid4cid4 Σ cid4 Φcid4cid4 Σ cid4cid4 P cid4 P cid4cid4 Fi Πi iff Recall consider invalid strong weak forgettings consistent programs Πi iff Π cid4 Π cid4cid4 SForgetLPΠi P cid4cid4 Ci Fi Φcid4 In order avoid unnecessary tediousness proof consider simpliﬁed case proof P cid4 p P cid4cid4 p q Note proof general case P cid4 P cid4cid4 obtained similar way proof Under assumption P cid4 p P cid4cid4 p q program Πi simpliﬁed form Πi Πi1 Πi2 Πi3 Πi1 contains following rules Π cid4cid4 r1 p posr1 negr1 cid4 cid4 cid4 1 p q posr 1 negr 1 r r2 q posr2 negr2 cid4 cid4 2 q p posr 2 negr r r3 headr3 p posr3 negr3 r4 headr4 q posr4 negr4 cid4 2 We assume p q occur Πi1 Πi2 contains rules having p q heads positive bodies having p q negative bodies r5 headr5 posr5 p q r6 headr6 posr6 p r7 headr7 posr7 q Finally Πi3 consists rules containing p q Case 1 Suppose Π cid4 SForgetLPΠi p Π cid4cid4 SForgetLPΠi p q In case Π cid4 Π cid4cid4 follows Π cid4 r2 q posr2 negr2 cid4 cid4 cid4 21 q 2 r cid3 posr1 posr cid3 negr1 negr cid4 cid4 2 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 759 Π cid4 cid3 negr1 negr3 cid4 cid3 cid4 1 negr3 negr cid4 cid3 r31 headr3 posr1 posr3 cid4 cid3 cid4 cid4 1 posr3 31 headr3 q posr r r4 headr4 q posr4 negr4 r7 headr7 posr7 q Πi3 cid4cid4 r31 headr3 r32 headr3 cid4 32 headr3 r r33 headr4 cid4 33 headr4 r Πi3 cid4 cid3 cid4 cid3 posr1 posr3 negr1 negr3 cid4 cid3 cid3 cid4 1 posr3 posr2 posr negr2 negr cid4 cid3 cid4 cid4 1 posr3 2 posr posr1 posr cid4 cid3 cid4 cid3 negr2 negr4 posr2 posr4 cid3 cid4 cid3 cid4 negr1 negr 2 posr4 posr1 posr cid4 cid4 1 negr3 cid3 cid4 2 negr negr1 negr cid4 cid4 1 negr3 cid4 cid4 2 negr4 Now assume atom Πi iff Π cid4cid4 r r Πi occurs deﬁnition Supporta Let Π Π iff Π deﬁnition Supporta Π Π cid4cid4 Π cid4cid4 Π Comparing structures programs Πi Π cid4cid4 iff Π cid4cid4 cid4cid4 r r Π cid4cid4 Then Π From proof Theorem 3 know Πi occurs occurs deﬁnition Supporta From Πi iff follow Πi iff r r Π cid4 iff Π cid4 cid4 cid4 Π rules removed Π cid4cid4 Π deriving Π cid4 On hand rules Π cid4cid4 corresponding rules reduction q Then fact Π replaced Π atoms q Now consider q Π cid4cid4 cid4cid4 Then conclude Π r1 r2 r cid4 holds clear rules r5 r6 r7 play role deriving Consequently rule r7 play role cid4 b cid7 q q Σ Σ cid4cid4i irrelevant Πi cid7 q cid7 q case Πi q observing rules cid7 q So result 2 derive q replaced r2 r cid4 Π cid4cid4 contradicts Π cid4cid4 cid4cid4 b iff Π 21 Π cid4cid4 cid4 cid4 Case 2 Suppose Π cid4 WForgetLPΠi p Π cid4cid4 WForgetLPΠi p q In case Π Π cid4 r2 q posr2 negr2 cid3 cid4 cid3 cid4 cid4 cid4 cid4 negr1 negr posr1 posr 21 q r 2 2 cid4 cid3 cid4 cid3 r31 headr3 negr1 negr3 posr1 posr3 cid4 cid3 cid4 cid3 cid4 cid4 cid4 1 negr3 1 posr3 31 headr3 q negr posr r r4 headr4 q posr4 negr4 cid4 5 headr5 posr5 q r cid4 6 headr5 posr5 r r7 headr7 posr7 q Πi3 cid4cid4 r31 headr3 r32 headr3 cid4 32 headr3 r r33 headr4 cid4 cid3 cid4 cid3 posr1 posr3 negr1 negr3 cid4 cid3 cid3 cid4 1 posr3 posr2 posr negr2 negr cid4 cid3 cid4 cid4 1 posr3 2 posr posr1 posr cid4 cid3 cid4 cid3 negr2 negr4 posr2 posr4 cid4 cid4 1 negr3 cid4 2 negr cid3 negr1 negr cid4 cid4 1 negr3 760 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 cid3 posr1 posr cid4 cid4 2 posr4 cid3 negr1 negr cid4 cid4 2 negr4 cid4 33 headr4 r cid4cid4 5 headr5 posr5 r cid4cid4 6 headr6 posr6 r cid4cid4 7 headr7 posr7 r Πi3 In similar way described Π cid4cid4 iff Π cid4 cid2 Corollary 1 Let Σ cid4 Σ cid4cid4 SolutionΣ Σ cid4cid4 preferred solution Σ atom Then Σ Σ cid4cid4i irrelevant Σ Σ cid4i irrelevant Σ cid4 Σ Σ cid4cid4 Example 8 Let consider logic program context Σ Φ1 Φ2 Φ3 Φ1 Φ2 Φ3 Π1 b c d e C1 F1 b c d e Π2 d b c C2 d e c F2 b c d Π3 b c d c C3 c d F3 b c d It easy conﬂicts occur Σ That Π1 C2 Π1 C3 Π3 C2 inconsistent By performing strong weak forgettings obtain solution Σ Σ cid4 Φcid4 Π cid4 3 C3 F3 Π cid4 SForgetLPΠ3 d c We verify atom 1 Σ Σ cid4i irrelevant 1 2 3 WForgetLPΠ1 c e d Π cid4 3 1 C1 F1 Φcid4 3 Φcid4 On hand weakly forgetting c e Π1 obtain preferred solution Σ Σ cid4cid4 Φcid4cid4 1 Φ2 Φcid4 WForgetLPΠ1 c e b d In fact Σ cid4cid4 preferred solution Σ Since Σ cid4 Σ Σ cid4cid4 according Corollary 1 know Σ Σ cid4cid4i irrelevant 1 2 3 1 C1 F1 Π cid4cid4 3 Φcid4cid4 1 Φ2 Φcid4 Π cid4cid4 Π cid4 3 1 1 1 52 Characterizing solutions conﬂict solving In subsection focus study semantic characterization conﬂict solving solutions characterizations useful optimize procedure conﬂict solving logic program contexts To begin general result existence preferred solutions arbitrary logic program context Theorem 6 Let Σ logic program context Σ preferred solution iff SolutionΣ cid7 Proof Obviously Σ preferred solution SolutionΣ cid7 Now assume SolutionΣ cid7 In case need Σ cid4 SolutionΣ new solution Σ cid4cid4 generated Σ cid4 Σ cid4cid4 cid15Σ Σ cid4 If solution generated Σ cid4 Σ cid4 preferred solution We present following algorithm purpose Algorithm SolutionGeneration Input Σ Φ1 Φn Σ cid4 Φcid4 1 Φcid4 n Π cid4 Ci Fi Φi Πi Ci Fi Φcid4 1 Φcid4cid4 n Output Σ cid4cid4 Φcid4cid4 1 n let Φcid4 Π cid4 Π cid4 Ci Fi Σ cid4 SForgetLPΠ P Π cid4 WForgetLPΠ P P Fi Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 761 Q P testing consistency SForgetLPΠ Q Cj j 1 n consistency holds Π cid4cid4 consistency hold SForgetLPΠ Q testing consistency WForgetLPΠ Q Cj j 1 n consistency holds Π cid4cid4 WForgetLPΠ Q Π cid4cid4 Π cid4 return Σ cid4cid4 Π cid4cid4 1 C1 F1 Π cid4cid4 n Cn Fn It easy algorithm SolutionGeneration terminates procedures computing SForgetLPΠi Q WForgetLPΠi Q consistency testing program ﬁnish ﬁnite steps respectively Further output Σ cid4cid4 Σ cid4 Σ cid4cid4 cid15Σ Σ cid4 This proves result cid2 The proof Theorem 5 actually provides method generate preferred solution logic program context That initial solution logic program context generate preferred solution current We continue process preferred solution ﬁnally achieved However logic program solution For instance logic program context Σ Φ1 Φ2 b b solution Proposition 5 Let Σ Φ1 Φn logic program context If Φi Πi Ci Fi Πi tain constraint rule rule head Ci consistent r Πi atomr Fi cid7 SolutionΣ cid7 Proof We Σ cid4 Φcid4 Ci Fi 1 cid2 cid2 n solution Σ Since Fi atomr cid7 r Πi Π cid4 SForgetLPΠi Fi note assumed Πi contain rules heads Instead type rule contained Ci This follows Π cid4 Cj Cj j 1 n consistent So C1 F1 Cn Fn solution Σ cid2 n Φcid4 1 Φcid4 We indicate conﬂict solving scenarios represented type logic program context Proposition 5 For example negotiation scenario discussed Example 6 logic program update ap proaches Section 6 speciﬁed logic program contexts form Therefore solving conﬂicts particular type logic program context special applications This motivates study detailed properties related solution type logic program contexts We ﬁrst introduce useful concepts A logic program Π s dependency graph 1 denoted GΠ directed graph atomΠ E atomΠ set vertices E set edges An edge b E iff rule r Π posr negr b headr Edge b labelled positive posr negative negr Then logic program called callconsistent 12 contain constraint rule head dependency graph simple cycles odd number negative edges5 Lemma 1 Let Π1 Π2 logic programs Π1 consistent Then program Π1 Π2 consistent bodyΠ1 headΠ2 Π2 callconsistent Proof Similar proof Theorem 3 To prove lemma need result program splitting 26 To remain completeness proof present result Before present program splitting result introduce notion Given program Π set atoms S use eΠ S denote program obtained Π deleting 1 rule Π having form body S 2 atoms bodies remaining rules S Intuitively eΠ S viewed simplicity Π giving atoms S true Then restate Theorem 5 26 normal logic program setting 5 A simple cycle contain cycles 762 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 A set atoms S stable model program Π Π Π1 Π2 bodyΠ1 headΠ2 S S1 S2 S1 stable model Π1 S2 stable model program eΠ2 S1 From result condition Π1 consistent Π1 Π2 consistent bodyΠ1 headΠ2 stable model S1 Π1 eΠ2 S1 consistent Since callconsistent program consistent 25 prove result prove Π2 callconsistent eΠ2 S1 callconsistent set atoms S1 From deﬁnition callconsistency clear Π2 callconsistent dependency graph contain simple cycle odd number negative edges Observing set atoms S1 program eΠ2 S1s dependency graph GeΠ2 S1 obtained GΠ2 removing edges nodes GΠ2 That GeΠ2 S1 subgraph GΠ2 This concludes GeΠ2 S1 contain simple cycle odd number negative edges So eΠ2 S1 callconsistent cid2 We need mention Lemma 1 callconsistency condition program Π2 important It easy Π2s consistency imply consistency Π1 Π2 conditions Lemma 1 remain For example consider programs Π1 b Π2 b Both Π1 Π2 consistent bodyΠ1 headΠ2 But Π1 Π2 stable model The following theorem states procedure generating preferred solution simpliﬁed certain conditions Theorem 7 Let Σ Π1 C1 F1 Πn Cn Fn logic program context satisfying conditions stated Proposition 5 Suppose Σ cid4 Π cid4 form SForgetLPΠi Pi WForgetLPΠi Pi Pi Fi 6 Then logic program context Σ cid4cid4 Π cid4cid4 1 C1 F1 Π cid4cid4 form Π cid4cid4 Π cid4cid4 n Cn Fn solution Σ Σ cid4cid4 cid15Σ Σ cid4 Π cid4cid4 n Cn Fn solution Σ Π cid4 WForgetLPΠi Qi Qi Pi body SForgetLPΠi Qi Π cid4cid4 callconsistent Π cid4 Π cid4cid4 cid2 n i1 1 C1 F1 Π cid4 Ci headΠ cid4cid4 Proof From Lemma 1 follows body programs Π cid4cid4 Qi Pi concludes Σ cid4cid4 cid15Σ Σ cid4 cid2 cid2 C1 Π cid4cid4 callconsistent Cn consistent So Σ cid4cid4 solution Σ On hand Ci headΠ cid4cid4 Π cid4cid4 n i1 cid2 In Theorem 7 condition body Ci headΠ cid4 callconsistent ensures Σ cid4 solution Σ minimal subset Pi atomΠi implies Σ cid4 preferred solution The following Example 9 illustrates preferred solution obtained condition Theorem 7 Π cid4 n i1 Example 9 Consider logic program context Σ Φ1 Φ2 Φ3 Φ2 Φ3 Φ1 Π1 b c d C1 e d F1 b c d Π2 d f b e d C2 c F2 b d e f Π3 b c b C3 f d F3 b c Clearly Σ conﬂict free Π1 C2 Π2 C1 Π2 C3 Π3 C2 consistent We verify 1 Φcid4 logic program context Σ1 Φcid4 2 Φcid4 3 solution Σ cid4 cid4 cid3 cid3 C1 F1 Π1 c SForgetLP cid4 cid3 cid3 C2 F2 Π2 d e f SForgetLP cid4 cid3 cid3 Π3 WForgetLP cid4 C3 F3 cid4 Φ Φ Φ cid4 1 cid4 2 cid4 3 6 Note Proposition 5 solution Σ exists In initial case Π cid4 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 763 Now consider program WForgetLPΠ2 d f b e Since e f bodyC1 C2 C3 WForgetLPΠ2 d callconsistent according Theorem 7 know Σ cid4cid4 WForgetLPΠ2 d C2 F2 solution Σ Σ cid4cid4 cid15Σ Σ cid4 In fact 1 Σ cid4cid4 1 Φcid4cid4 1 preferred solution Σ 3 Φcid4 2 Φcid4 Φcid4 2 6 Representing logic program updates Logic program updates considerably studied recent years While similarities differences different approaches addressed researchers believed comparing different types update approaches formal level generally difﬁcult discussions topic referred 561528 In section major logic program update approaches transformed framework logic program contexts update approaches special cases conﬂict solving problems different types constraints 61 Representing causal rejection based approach Eiter et als update approach based principle called causal rejection sequence logic program updates allowed 5 Let P Π1 Πn Π1 Π1 extended logic programs extended logic program update sequence A set atoms We P A iff A represents set atoms occurring rules Π1 Πn We use LitA denote set literals corresponding atoms A We assume set A atoms extending A new pairwise distinct atoms rejr ai rule r occurring Π1 Πn atom A Then Eiter et als update process deﬁned following deﬁnitions consider ground extended logic programs investigation Deﬁnition 12 5 Given update sequence P Π1 Πn set atoms A update program Pcid20 Π1 cid20 cid20 Πn A consisting following items 1 constraints Π1 Πn recall constraint rule head 2 r Πi 1 cid2 cid2 n li bodyr rejr 3 r Πi1 2 cid2 cid2 n headr l rejr bodyr li headr l 4 literal l occurring Π1 Πn li1 li 1 cid2 n l l1 A set S LitA update answer set P iff S Scid4 LitA answer set Scid4 Pcid20 As example consider update sequence P Π1 Π2 Π3 Π1 Π2 Π3 consist following rules respectively 5 Π1 r1 sleep tv_on r2 night r3 tv_on r4 watch_tv tv_on 764 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 Π2 r5 tv_on power_ failure r6 power_ failure Π3 r7 power_ failure According Deﬁnition 12 power_ failure tv_on watch_tv night consistent intuition easy P Π1 Π2 Π3 unique update answer set S In order transform update approach framework logic program context ﬁrst reformulate approach normal logic program setting In particular given update sequence P Π1 Πn A extend set A A adding atom A A Then replacing negative atom occurring Πi adding constraint A obtain translated normal logic program update sequence P Π 1 Π n A We extend set A A including new atoms rejr ai ai rule r Π 1 Π n pair atoms A Then following Deﬁnition 12 obtain corresponding update program Pcid20 normal logic program We stable model Pcid20 update stable model P Proposition 6 Let P Π1 Πn update sequence Pcid20 update program P P Pcid20 corre sponding translations P Pcid20 respectively described S LitA update answer set P iff update stable model S P S S A S7 Having Proposition 6 need consider transformation normal logic program update sequence P Π 1 Π n P translated extended logic program update sequence P described conﬂict solving problem framework logic program contexts Deﬁnition 13 Let P Π 1 Π n n 1 normal logic program update sequence A We specify sequence logic program contexts ΩCR Σ1 Σn18 set atoms B A lai lai ai ai A 1 n lai lai newly introduced atoms 1 Σ1 Π Π 1 F1 C1 1 consists following rules constraints Π 1 Π n ii r Π bodyr bodyr 1 n ai bodyr lai ai bodyr lai respectively iii A ai1 ai ai1 ai a1 a1 1 n b F1 lan1 lan1 c C1 an1 an1 A A 2 Σi Π Π Σ cid4 i1 Fi Ci 1 n Π i1 Π i1 preferred solution Σi1 Π i1 Fi1 Ci1 b Fi lani lani A c Ci ani ani1 ani ani1 A 7 Note S reduced LitA S A 8 Note n 1 transformation trivial simply specify ΩCR consist single logic program context Σ Π 1 In case Σ preferred solution iff Π 1 consistent So rest paper consider case n 1 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 765 A subset S B called model ΩCR S stable model Π Σn1 Σ cid4 n1 Fn1 Cn1 Π n1 n1 Π n1 preferred solution Let closer look Deﬁnition 13 Given update sequence P Π 1 Π n Deﬁnition 13 speciﬁes sequence logic program contexts ΩCR Σ1 Σn1 Σi solves certain conﬂicts embedded P Σ1 represents ﬁrst level conﬂict solving Π 1 similar Pcid20 possible conﬂict an1 an1 reformulated constraint an1 an1 resp C1 Note rules speciﬁed ii Deﬁnition 13 ai bodyr lai ai bodyr lai formulas lan1 lan1 n 1 introduced solve conﬂict an1 an1 resp Observe Σ1 solves conﬂicts atoms level n 1 For example an1 derived 1 rule an1 bodyr lan1 eliminated Π1 strongly forgetting atom lan1 Π constraint an1 C1 In sequence ΩCR Σ1 Σn1 conﬂicts solved downwards manner respect update sequence P Π 1 Π n Σi 1 speciﬁed purpose solving conﬂicts atoms ani ani1 ani ani1 Example 10 Consider TV example mentioned earlier P Π1 Π2 Π3 update sequence It easy translate P corresponding normal logic program update sequence P Π 1 Π 2 Π 3 tv_on power_ failure replaced atoms tv_on power_ failure respectively According Deﬁnition 13 specify sequence logic program contexts ΩCR Σ1 Σ2 solve conﬂict occurring P Σ1 Π 1 consists following rules9 1 F1 C1 Π tv_on lsleep1 sleep1 lnight1 night1 tv_on1 ltv_on1 watch_tv1 tv_on lwatch_tv1 tv_on2 power_ failure ltv_on2 lpower_ failure2 power_ failure2 power_ failure3 lpower_ failure3 night night1 tv_on tv_on1 watch_tv watch_tv1 tv_on1 tv_on2 tv_on tv_on1 power_ failure2 power_ failure3 power_ failure1 power_ failure2 power_ failure power_ failure1 power_ failure2 power_ failure1 power_ failure power_ failure1 F1 lpower_ failure2 lpower_ failure2 C1 power_ failure2 power_ failure3 9 To avoid unnecessarily tedious details omit irrelevant rules atoms Π 1 F1 C1 The Σ2 766 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 It easy Σ1 conﬂict free Π 1 C1 consistent stable model To specify Σ2 ﬁrst need obtain preferred solution Σ1 In fact Σ1 unique preferred solution Σ cid4 1 Π Π 1 1 F1 C1 cid3 SForgetLP Π 1 lpower_ failure2 cid4 Π 1 cid11 power_ failure2 lpower_ failure2 cid12 Now specify Σ2 Π C2 tv_on1 tv_on2 Note Σ2 conﬂict free So ignoring atoms subscripts ΩCR unique model power_ failure tv_on watch_tv night update stable model update sequence P 1 F2 C2 F2 ltv_on1 ltv_on1 Theorem 8 Let P Π 1 Π n n 1 normal logic program update sequence set atoms A A subset S A update stable model P iff sequence logic program contexts ΩCR Σ1 Σn1 constructed P speciﬁed Deﬁnition 13 ΩCR model S satisfying S S A Proof We prove result induction length n normal logic program update sequence P Π 1 Π n P Π 1 Π 2 In case ΩCR Σ1 Σ1 Case 1 We ﬁrst consider case n 2 1 F1 C1 formed follows Π Π 1 consists following rules constraints Π 1 Π 2 ii r Π bodyr bodyr 1 2 ai bodyr lai ai bodyr lai respectively iii A Π n a1 a2 a1 a2 a1 a1 b F1 la1 la1 c C1 a1 a2 a1 a2 A A Note ii rule r Π 2 a2 bodyr la2 a2 bodyr la2 simpliﬁed a2 bodyr a2 bodyr respectively atom la2 la2 forgettable Now consider update program Pcid20 built P Deﬁnition 12 consists following rules 1 constraints Π 1 Π 2 2 a1 bodyr rejr a1 bodyr rejr r Π 1 a2 bodyr a2 bodyr r Π 2 3 rejr bodyr a2 headr a1 rejr bodyr a2 headr a1 r Π 1 4 A a1 a2 a1 a2 a1 a1 Now suppose S update stable model P Then extend S S set A S stable model program Pcid20 contains atoms rejr r Π 1 Note rules item 2 rejr S actually play roles viewed removed P Then specify set P F1 includes la1 la1 corresponding rules r Π 1 ii removed P indicated Then veriﬁed S S S A stable model program SForgetLPΠ 1 P P minimal set SForgetLPΠ 1 P consistent That S model ΩCR On hand consider stable model S SForgetLPΠ 1 P preferred solution Σ1 Let S S A Similarly la1 la1 P extend S S contain atoms rejr S Note rejr r Π 1 corresponds a1 bodyr la1 a1 bodyr la1 ii speciﬁed Now GelfondLifschitz transformation program P cid20 terms set S P S cid20 By avoiding tedious checkings S stable model P S cid20 1 P SForgetLPΠ Case 2 Suppose n k S update stable model P Π 1 Π n iff ΩCR Σ1 Σn1 ΩCR model S satisfying S S A Now consider case n k Let S update stable model P Π 1 Π k We generate sequence logic program contexts ΩCR length k 1 ΩCR model S satisfying S S A Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 767 k1 Π We ﬁrst specify new normal logic program update sequence length k 1 Pcid4 Π 1 Π cid4 k1 Π cid4 Π k Π update stable model Pcid4 Now suppose Ω cid4 CR Pcid4 according Deﬁnition 13 From induction assumption know Ω cid4 S S A k1 Π k1 r rejr S10 Then Deﬁnition 12 S Σ1 Σk2 sequence logic program contexts constructed CR model S satisfying k1 Now Ω cid4 Σ1 Σk2 actually extended ΩCR Σ cid4 CR 1 Σ1 Σk2 length k 1 eventually constructed P Π 1 Π k Observe Π cid4 k1 Pcid4 ak1 ak1 derived ak ak presented S k1 So ﬁrst logic program context Σ1 That conﬂict ak1 ak ak1 ak exists Π cid4 Ω cid4 CR speciﬁed Σ1 Π 1 F1 C1 1 Π 1 consists following rules constraints Π 1 Π cid4 b r bodyr bodyr Π 1 k 2 Π cid4 k1 ai bodyr lai respectively c A ai1 ai ai1 ai 1 n a1 a1 2 F1 lak2 lak2 3 Ccid4 1 A ak2 ak1 ak2 ak1 A k1 ai bodyr lai Thus view Σ1 Ω cid4 CR represents preferred solution logic program context Σ cid4 1 Π cid4 1 F cid4 1 Ccid4 1 11 1 Π cid4 1 consists following rules constraints Π 1 Π k b r Π bodyr bodyr 1 k ai bodyr lai ai bodyr lai respectively c A ai1 ai ai1 ai 1 n a1 a1 lak1 lak1 A ak1 ak ak1 ak A 2 F cid4 1 3 Ccid4 1 Now form new ΩCR Σ cid4 CR On hand According Deﬁnition 13 turns ΩCR viewed sequence logic program contexts formed P Π 1 Π k 1 Σ1 Σk2 Obviously S model ΩCR iff S model Ω cid4 Given P Π 1 Π k ΩCR Σ1 Σk1 speciﬁed Deﬁnition 13 Suppose S model ΩCR We S A update stable model P Now consider subsequence Ω cid4 2 F2 C2 preferred solution Σ1 ΩCR So represent Π 2 SForgetLPΠ A Π 1 Σ1 Now deﬁne program based Pcid20 Σ2 Σk1 Σ2 Π 1 P P F1 lak1 lak1 CR cid4 cid20 Pcid20 P cid3cid11 r ak1 bodyr rejr lak1 cid12 P cid11 r ak1 bodyr rejr lak1 k1 Π k1 cid12cid4 P Equivalently view Pcid4 Π k Π cid4 k1 cid20 update program new sequence Pcid4 Π 1 Π Π k1 r corresponding rules removed Pcid4 cid20 Also easy verify Ω cid4 Π cid4 k1 CR 10 Here denote S 11 Note difference Π 1 Π cid4 1 extension S containing atoms A 768 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 generated Π cid4 update stable model Pcid4 k1 following Deﬁnition 13 According induction assumption know S A On hand S S A update stable model Pcid4 extend S A containing atoms A Therefore rule r ak1 bodyr rejr r ak1 bodyr rejr removed Pcid20 cid20 atom rejr A Otherwise violate induction assumption This deﬁnition Pcid4 follows S update model P This completes proof cid2 62 Representing dynamic logic program approach Logic program update based dynamic logic programs DLP simply called DLP update approach proposed Alferes Leite Pereira et al 2 extended purposes 15 DLP deals generalized logic programs negation failure allowed occur head rule classical negation excluded entire program Let P Π1 Πn sequence generalized logic programs set atoms A extend A AD adding pairwise distinct atoms ai ai aPi aPi A Deﬁnition 14 15 Given update sequence P Π1 Πn A Πi generalized logic program corresponding dynamic update program P Π1 Πn AD generalized logic program consisting following rules 1 r Πi headr posr negr aPi aPi posr negr headr posr negr headr 2 occurring P 1 n ai aPi aPi 3 occurring P 1 n ai ai1 aPi ai ai1 aPi 4 occurring P a0 The semantics DLP deﬁned terms dynamic stable model semantics 15 However easy characterize original stable model semantics Proposition 7 Given dynamic update program P Π1 Πn deﬁne P Then S dynamic stable model P iff S Scid4 Scid4 Scid4 stable model P P A12 Now represent transformation P sequence logic program contexts captures dynamic logic programming update approach Deﬁnition 15 Given dynamic update program P Π1 Πn AD Deﬁnition 14 let P P n atoms A D A We specify sequence logic program contexts ΩDLP Σ1 Σn set ai ai AD 0 n hai hai lai lai newly introduced atoms AD hai hai lai lai 1 Σ1 Π Π 1 F1 C1 1 consists following rules rules P following rules 1 n ai ai1 api ai ai1 api ii pair rules P ai ai1 api 1 n 12 Clearly P normal logic program Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 769 ai ai1 api replace following rules Π 1 ai ai1 lai ai ai1 lai lai hai b F1 ha1 ha1 c C1 a1 aP1 a1 aP1 hai lai aPi hai aPi A hai A 2 Σi Π Π Σ cid4 Fi Ci Π i1 Π i1 preferred solution Σi1 i1 Fi1 Ci1 Π i1 b Fi hai hai A c Ci ai aPi ai aPi A A subset S A Σn Σ cid4 Π n D called model ΩDLP S stable model Π n Fn Cn n Π n preferred solution ai ai derived Π In Deﬁnition 15 sequence logic program contexts ΩDLP Σ1 Σn represents way solving ﬂicts atoms upwards manner Starting 1 Σi solves conﬂicts atoms ai aPi ai aPi resp weakly forgetting hai hai For instance ai1 aPi derived Π Therefore conﬂict occur Σi solves conﬂict weakly forgetting hai In particular weakly forgetting hai rule hai removed atom lai hai Consequently rule ai ai1 lai derived lai defeated atom ai derived ai1 corresponding inertia rule This process continuous conﬂicts atoms level 1 level n solved note formula hai deleted rule lai aPi Π Theorem 9 Let P sequence logic program contexts ΩDLP Σ1 Σn constructed P ΩDLP model S satisfying S S AD speciﬁed set atoms AD A subset S AD stable model P iff speciﬁed Deﬁnition 15 Since proof theorem tedious similar proof Theorem 8 skip 63 Representing syntax based approach Sakama Inoues update approach viewed typical syntax based logic program update approach 22 solves conﬂicts programs basis syntactic coherence To simplify discussion restrict Sakama Inoues approach extended logic program setting normal logic program setting Note restriction affect result presented subsection In fact use method described subsection translate extended logic program update normal logic program update introducing new atoms underlying language Deﬁnition 16 22 Let Π1 Π2 consistent logic programs Program Π cid4 SIresult theory update Π1 Π2 1 Π cid4 consistent 2 Π2 Π cid4 Π1 Π2 3 consistent program Π cid4cid4 Π cid4 Π cid4cid4 Π1 Π2 Now transform Sakama Inoues theory update logic program context First rule r Π1 1 r Π1 1 That r Π1 simply extend negative body 1 removable strongly forgetting atom lr inﬂuencing 1 lr r Π1 Φ2 Π2 introduce new atom lr occur atomΠ1 Π2 Then deﬁne program Π cid4 rule r cid4 headr posr negr lr Π cid4 unique atom lr This r cid4 Π cid4 rules Finally specify ΣSI Φ1 Φ2 Φ1 Π cid4 For convenience use Π notP denote program obtained Π removing occurrences atoms P negative bodies rules Π For instance Π b c d Π notc b d Now following characterization result 770 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 Theorem 10 Let Π1 Π2 consistent programs ΣSI speciﬁed Π cid4 SIresult updating Π1 Π2 iff Π cid4 Π notlr rΠ1 Π2 Σ cid4 Π lr r Π1 Π2 preferred solution ΣSI Proof From speciﬁcations ΣSI Σ cid4 know Π SForgetLPΠ cid4 P P minimal subset lr r Π1 Π Π2 consistent Note rule r Π form headr posr notnegr lr actually simplied headr posr negr atom lr play role program evaluation That Π cid4 Π2 equivalent Π notlr rΠ1 Π2 SIresult update Π1 Π2 cid2 64 Representing integrated update approach Different model based syntax based approaches Zhang Foos update approach integrated desirable semantic syntactic features extended logic program updates 27 Their approach solves default conﬂicts caused negation failure logic programs prioritized logic programming language Conse quently Zhang Foos update approach generate explicit resulting program logic program update avoid undesirable solutions embedded SakamaInoues approach 28 Since consider default conﬂict solving paper focus transformation ﬁrst ZhangFoos update approach conﬂict contradiction elimination logic program context Let Π1 Π2 extended logic programs Updating Π1 Π2 consists stages Step 1 Simple fact updateupdating answer set S Π1 program Π2 The result update collection sets literals denoted UpdateS Π2 Step 2 Select Scid4 UpdateS Π2 extract maximal subset Π Π1 program Π l l Scid4 simply represented Π Scid4 consistent Then Π Π2 called resulting program updating Π1 Π2 Note Step 1 simple fact update achieved prioritized logic programming 27 Recently Zhang proved equivalence relationship simple fact update Sakama Inoues program date 28 UpdateS Π2 cid13 S cid3 cid3 SIUpdate ΠS Π2 cid2 cid4cid4 ΠS l l S updating ΠS Π2 SakamaInoues approach SSIUpdateΠS Π2 class answer sets resulting programs Example 11 Consider extended logic programs Π1 Π2 follows Π1 Π2 c b d e b c b Π1 unique answer set d Then Step 1 ZhangFoos simple fact update d Π2 Updatea d Π2 equivalently update d Π2 SakamaInoues approach contain single set b c d Applying Step 2 obtain ﬁnal update result d e Π2 As provided transformation SakamaInoues approach logic program context ZhangFoos update approach represented framework sufﬁcient transform Step 2 conﬂict solving problem certain logic program context As given extended logic programs Π1 Π2 set atoms A extend A A new atom A Then replacing Scid4 Π2 obtain corresponding normal logic programs Π 1 Π 2 respectively Suppose UpdateS Π 2 result simple fact update S stable model Π 1 Deﬁnition 17 Let Π 1 Π 2 UpdateS Π 2 deﬁned Scid4 UpdateS Π 2 We specify logic program context ΣZF Π cid4 1 F C set atoms A lr r Π 1 lr newly introduced atoms Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 771 1 Π cid4 Π cid4 1 consists rules rule r headr posr negr Π 1 headr bodyr lr 1 b Scid4 Π cid4 1 2 F lr r Π 1 3 C A The following theorem shows Step 2 ZhangFoos approach precisely characterized logic program context speciﬁed Deﬁnition 17 Theorem 11 Let Π 1 Π 2 ΣZF UpdateS Π 2 deﬁned Scid4 UpdateS Π 2 Π maximal subset Π 1 Π cid4 Π Scid4 consistent iff Π cid4cid4 preferred solution ΣZF Σ cid4 ZF Π cid4cid4 F C Π cid4cid4 r headr posr negr lr r Π The proof Theorem 11 similar Theorem 10 65 Further discussions Updates constraints expressiveness From previous descriptions observe key step transform update approach sequence logic program contexts logic program context like case SI approach construct underlying constraints conﬂict solving In Eiter et als causal rejection DLP approaches constraints speciﬁed based atoms ani ani1 ΩCR ai aP ΩDLP For SI approach hand underlying constraints speciﬁed entire update program For instance consider update Π1 Π2 SI approach corresponding logic program context update form Σ Π F Π2 program Π2 serves constraints conﬂict solving Finally Zhang Foos integrated update approach combined model syntax based approaches transformation approach logic program context framework consists steps equivalent SI transformation program based constraints followed transformation atoms based constraints Deﬁnition 17 From observation main difference model based syntax based update approaches solve conﬂicts different types constraints atoms based program based constraints respectively While shown conﬂict solving approach provides uniﬁed framework represent different kinds logic program updates indicate approach speciﬁc computational advantages logic program update approaches As Section 7 conﬂict solving framework generally intractable From previous deﬁnitions observe transforming model based logic program updates sequence logic program contexts need exponential time involves computation solutions logic program contexts transforming syntax based logic program updates polynomial time Nevertheless signiﬁcant feature logic program contexts represent logic program updates provide expressive framework uniﬁes different logic program update approaches Under uni ﬁed framework possible analyze compare syntactic semantic properties different approaches 7 Computational issues In section study related computational issues In particular consider major computational problems concerning 1 irrelevance reasoning respect strong weak forgettings conﬂict solving 2 general decision problems conﬂict solving framework logic program contexts We ﬁrst introduce basic notions complexity theory refer 21 details Two important com plexity classes P NP The class P includes languages recognizable polynomialtime deterministic Turing machine The class NP hand consists languages recognizable polynomialtime nondeterministic Turing machine The class coNP complements class NP The class DP contains languages L L L1 L2 L1 NP L2 coNP The class coDP complement 772 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 class DP The class Σ P 2 machine NP oracle class Π P P NP DP Σ P NPNP includes languages recognizable polynomial time nondeterministic Turing 2 It known 2 complement Σ P 2 Π P 2 coΣ P 2 inclusions generally believed proper 71 Complexity results irrelevance By deﬁnitions main computation strong weak forgettings relies procedure reduction inherits computation conventional program unfolding Hence easy observe worst case size resulting program strong weak forgetting exponentially larger original program This means general computing strong weak forgettings logic programs hard However following result shows actually increase complexity associated inference problem Theorem 12 Let Π logic program P set atoms atom Deciding SForgetLPΠ P WForgetLPΠ P coNPcomplete Proof The hardness obvious P To prove membership ﬁrst specify transformations Π respect P The program STransΠ P obtained Π removing rules Π 1 p P p headΠ removing rules r Π p posr 2 p posΠ removing rules r Π headr p 3 removing rules r Π p negr The program WTransΠ P hand obtained Π way program STransΠ P 3 rules r Π having p negr change form r cid4 headr posr notnegr p Now prove following results Result 1 SForgetLPΠ P consistent program STransΠ P consistent SForgetLPΠ P s stable models Scid4 expressed Scid4 S P S stable model STransΠ P Result 2 WForgetLPΠ P consistent program WTransΠ P consistent WForgetLPΠ P s stable models Scid4 expressed Scid4 S P S stable model WTransΠ P Here proof Result 1 Result 2 proved similar way Firstly assume SForgetLPΠ P consistent Scid4 stable model SForgetLPΠ P Then STransΠ P stable model S Scid4 S P Observing construction structure STransΠ P p P occurring STransΠ P rules r1 r2 STransΠ P forms r1 p posr1 negr1 r2 headr2 p posr2 negr2 furthermore P negSTransΠ P Now present algorithm construct set S atoms follows Algorithm Generating S Input STransΠ P Scid4 Scid4 stable model SForgetLPΠ P Output set S atoms let S Scid4 selecting rule r STransΠ P form r p posr negr p P posr P rule exists StransΠ P return S posr Scid4 b negr Scid4 S S p repeat following steps S longer changes selecting rule r cid4 STransΠ P form Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 773 r cid4 p posr cid4 negr cid4 p P posr cid4 S b negr cid4 S S S p return S We need S generated algorithm stable model STransΠ P We perform GelfondLifschitz transformation STransΠ P S obtain program STransΠ P S First prove rule r headr posr STransΠ P S posr S headr S Case 1 If posr Scid4 headr S according algorithm Case 2 Suppose r form r headr p posr p P p posr S posr Scid4 In case headr S This true headr P according algorithm Now sup pose headr cid7 P Consider rs original form STransΠ P r cid4 headr pcid4 posr negr cid4 negr cid4 removed STransΠ P S Recall structure STransΠ P exists rule r cid4cid4 p posr cid4cid4 negr cid4cid4 By performing proper reduction eventually replace r cid4cid4 new rule r p posr negr P posr note reach form rule r instance P posr cid7 p S according algorithm As p S posr S posr Scid4 On hand hard observe rule form SForgetLPΠ P Scid4 headr posr posr Since know posr posr Scid4 Scid4 stable model SForgetLPΠ P follows headr Scid4 headr S Scid4 S On hand easy Scid4 generated algorithm smallest set property program STransΠ P This proves S stable model STransΠ P Now assume STransΠ P consistent S stable model STransΠ P In case simply prove Scid4 S P stable model SForgetLPΠ P We omit proof easy verify Having results membership proved follows For case strong forgetting consider complement problem Clearly easy STransΠ P obtained Π polynomial time Guessing S stable model STransΠ P verifying checking S P polynomial time So complement problem NP Consequently problem coNP Proof case weak forgetting cid2 From result complexity irrelevance relation strong weak forgettings Theorem 13 Let Π logic program P set atoms atom Deciding irrelevant P Π coDPcomplete Proof To prove theorem need deciding Π iff SForgetLPΠ P sirrelevant coDPcomplete deciding Π iff WForgetLPΠ P wirrelevant coDPcomplete Here proof ﬁrst statement second proved similar way Membership To decide Π iff SForgetLPΠ P need Π SForgetLPΠ P Π cid7 SForgetLPΠ P cid7 Clearly given Π P deciding Π SForgetLPΠ P coNP deciding Π cid7 SForgetLPΠ P cid7 NP Theorem 12 So problem coDP Hardness We consider pair Φ1 Φ2 CNFs polynomially construct program Π set atoms P atom prove Φ1 satisﬁable Φ2 unsatisﬁable iff Π SForgetLPΠ P Π cid7 SForgetLPΠ P cid7 Let Φ1 C1 Cm Φ2 Ccid4 j 1 cid2 cid2 n 1 cid2 j cid2 n sets proposi tional literals respectively We assume Φ1 Φ2 share propositional atoms Now construct program Π based propositional atoms atomΦ1 atomΦ2 ˆX ˆY l1 ln p satΦ1 unsatΦ1 unsatΦ2 sets atoms disjoint ˆX atomΦ1 ˆY atomΦ2 Program Π consists groups rules Ci Ccid4 1 Ccid4 n Π1 x atomΦ1 774 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 x ˆx ˆx x y atomΦ2 y ˆy ˆy y Π2 unsatΦ1 C1 unsatΦ1 Cm unsatΦ2 Ccid4 1 unsatΦ2 Ccid4 n clause Ci Ccid4 b Ci Ccid4 j resp j b Ci Ccid4 j resp b Ci Ccid4 j resp b Ci Ccid4 j resp Π3 l1 unsatΦ2 l2 ln ln unsatΦ2 l1 ln1 posCcid4 j lj 1 cid2 j cid2 n j lj represents group rules atoms b Ccid4 posCcid4 needed j b lj note b Ccid4 j rule Π4 satΦ1 unsatΦ1 satΦ1 unsatΦ2 p Let look intuition program Clearly Π1 generates truth assignments Φ1 Φ2 recall atomΦ1 atomΦ2 This ensures correspondence stable models Π truth assignments Φ1 Φ2 Π2 indicates Φ1 Φ2 unsatisﬁable atom unsatΦ1 unsatΦ2 resp derived Rules Π3 force Φ2 unsatisﬁable That atom unsatΦ2 derived rule unsatΦ2 Π4 corresponding truth assignment Φ2 stable model Π Ccid4 j true Now prove Φ1 satisﬁable Φ2 unsatisﬁable Π SForgetLPΠ p Π cid7 SForgetLPΠ p cid7 We observe SForgetLPΠ p Π p implies Π SForgetLPΠ p Π cid7 SForgetLPΠ p cid7 Suppose Φ1 satisﬁable Φ2 unsatisﬁable We consider following cases 1 If Φ1 satisﬁable easy rules Π2 head unsatΦ1 applicable atoms satΦ1 derived Π In case matter Φ2 satisﬁable unsatisﬁable Π SForgetLPΠ p 2 If Φ2 unsatisﬁable In case rules Π2 having unsatΦ2 heads applicable atom unsatΦ2 derivable Π In case Φ1 satisﬁable derived Π Otherwise derivable Π The SForgetLPΠ p So statement Φ1 satisﬁable Φ2 unsatisﬁable Π SForgetLPΠ p Π cid7 SForgetLPΠ p cid7 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 775 Suppose Π SForgetLPΠ p Π cid7 SForgetLPΠ p cid7 1 If Π SForgetLPΠ p From construction Π know way derive Π rule satΦ1 Π4 applicable This implies rules Π2 having unsatΦ1 heads applicable Consequently truth assignments generated Π1 Φ1 satisfy Φ1 So Φ1 satisﬁable 2 If Π cid7 SForgetLPΠ p cid7 In case sat unsatΦ2 derived rule unsatΦ2 Then rule Π3 know stable model Π corresponding truth assignment Φ2 satisfy Φ2 Since truth assignments Φ2 represented Π s stable models concludes Φ2 unsatisﬁable This proves result cid2 The following complexity result irrelevance respect logic program contexts inherited Theorem 13 Theorem 14 Let Σ Σ cid4 logic program contexts Σ cid4 SolutionΣ atom Deciding Σ Σ cid4i irrelevant coDPcomplete 72 Complexity results conﬂict solving Proposition 8 Let Σ logic program context Deciding Σ preferred solution NPhard Proof We consider special form logic program context Σ Π1 Πn Clearly Σ solu tion iff Πi stable model know checking program stable NPhard On hand Theorem 6 know Σ preferred solution iff SolutionΣ cid7 Then result directly follows cid2 We observe computing solution logic program context consists major stages 1 computing strong weak forgettings 2 consistency testing Πi Cj resulting logic program context Deﬁnition 6 While existing results efﬁcient consistency testing logic program Section 52 Chapter 3 3 important investigate possible optimizations computing strong weak forgettings logic programs For purpose ﬁrst introduce useful notion Let Π logic program atom atomΠ GΠ dependency graph Π In GΠ positive path13 cycles starting inference chain starting We deﬁne inference depth denoted ideptha length longest inference chain starting GΠ Intuitively ideptha represents maximal number rules derive atoms starting program Π We denote inference depth Π idepthΠ Max cid4 cid3 ideptha atomΠ It turns inference depth plays key role characterizing computation strong weak forgettings logic programs Theorem 15 Let Π logic program If Π bounded inference depth idepthΠ cid2 c constant c set atoms P atomΠ SForgetLPΠ P WForgetLPΠ P computed polynomial time Proof To prove theorem need condition bounded inference depth ReductΠ P polynomially achievable P atomΠ Without loss generality P p1 pk assume Π consists components Π1 r11 p1 posr11 negr11 rll1 p1 posr1l1 negr1l1 13 That path contain negative edges 776 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 r21 p2 posr21 negr21 r2l2 p2 posr2l2 negr2l2 rk1 pk posrk1 negrk1 rklk pk posrklk negrklk Π 14 2 r1 headr1 p1 posr1 negr1 r2 headr2 p2 posr2 negr2 rk headrk pk posrk negrk Π3 reduction occurs rules Π1 Π2 Π3 contains rules irrelevant reduction process Now idepthΠ cid2 c constant c size ReductΠ P polynomial times size Π Indeed idepthΠ cid2 c follows pi P idepthpi cid2 c program Π1 This implies reduction pi s occurrence rules positive body h1 hc1 h1 hc1 l1 lk new rules introduced inference chain Π1 starting This number rules bounded Πc1 If pi occurs rules positive bodies Π1 total number new rules possibly introduced reduction pi bounded P Πc1 Therefore number new rules introduced entire reduction P bounded OP 2 Πc1 In words perform ReductΠ P number operations rule substitutions replacements bounded OP 2 Πc1 cid2 Theorem 16 Let Σ Φ1 Φn Σ cid4 Φcid4 Πi Ci Fi Σ 1 cid2 cid2 n Φcid4 WForgetLPΠi Pi Pi Fi Then following results hold Σ cid4 form Φcid4 1 Φcid4 n logic program contexts Φi Π cid4 SForgetLPΠi Pi Π cid4 Ci Fi Π cid4 1 Deciding Σ cid4 solution Σ NPcomplete 2 Deciding Σ cid4 preferred solution Σ Π P computed polynomial time15 2 provided strong weak forgettings Σ 3 For given atom deciding Σ cid4cid4 SolutionΣ Σ cid4cid4 Π P 2 provided strong weak forgettings Σ computed polynomial time Proof Result 1 easy prove To check Σ cid4 solution Σ need check Π cid4 Cj consistent j altogether need n2 consistency checkings On hand know checking consistency Π cid4 Cj NP So problem NP For hardness consider special case n 1 Σ cid4 solution Σ iff Π cid4 1 C1 consistent NPhard To prove Result 2 consider complement problem If Σ cid4 preferred solution Σ n 1 P cid4cid4 n polynomial time Then exist Σ cid4cid4 Σ cid4cid4 SolutionΣ Σ cid4cid4 Σ Σ cid4 This equals P cid4cid4 P cid4cid4 form SForgetLPΠi P cid4cid4 computing SForgetLPΠi P cid4cid4 1 P cid4cid4 n Cn Fn Π cid4cid4 n C1 F1 Π cid4cid4 2 Σ cid4cid4 SolutionΣ Clearly guessing P cid4cid4 Pi k P cid4cid4 k Pk 1 Σ cid4cid4 Π cid4cid4 WForgetLPΠi P cid4cid4 WForgetLPΠi P cid4cid4 14 In Π2 rules having pi positive bodies But simpliﬁed case affect proof 15 Computing strong weak forgettings Σ mean Φi Πi Ci Fi Σ P Fi compute SForgetLPΠi P WForgetLPΠi P Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 777 SForgetLPΠi P cid4cid4 construct Σ cid4cid4 polynomial time Σ cid4cid4 form Σ cid4cid4 Π cid4cid4 Π cid4cid4 Σ achieved number n2 calls NP oracle So problem Σ P problem Π P 2 WForgetLPΠi P cid4cid4 n Cn Fn Then checking Σ cid4cid4 solution 2 Consequently original We prove Result 3 follows We guess set atoms Si n sets atoms P1 Pn Pi Fi 1 cid2 cid2 n Then similarly proof Result 2 construct logic program context Σ polynomial time Checking Σ cid4 SolutionΣ achieved NP oracle Then checking Si stable model particular Π cid4 Σ cid4 Φcid4 Π cid4 Ci Fi Si polynomial time So complement problem Σ P 1 Ci F1 Π cid4cid4 2 original problem Π P Φcid4 2 cid2 8 Conclusions In paper deﬁned notions strong weak forgettings logic programs viewed analogy forgetting propositional theories Based notions developed framework logic program contexts We studied irrelevance property related strong weak forgettings conﬂict solving provided solution characterizations logic program contexts We showed approach presented paper general uniﬁed major logic program update approaches We analyzed computational complexity strong weak forgettings logic programs conﬂict solving logic programs contexts We noted methods solving inconsistency logic programs literature especially work involving abductive reasoning logic programs For instance Inoues method deletion addition names rules 8 certain atoms blocked derivation removingadding rules program In case atoms presented program As shown Section 63 introducing new atom lr language approach simply model method solve program inconsistency The main difference approach presented general framework based strong weak forgettings framework handle different types conﬂict solving scenarios including logic program updates negotiation belief merging difﬁcult single method literature Example 6 Section 4 Our work presented paper extended One interesting issue integrate dynamic preference orderings forgettable atoms current framework logic program contexts extended framework represent domaindependent conﬂict solving cases This particularly important use approach represent complex belief merging 101116 negotiations setting logic programming agent usually different preferences atoms forget ﬁnal agreement Acknowledgements The authors thank Fangzhen Lin useful discussions topic valuable comments early draft paper The research ﬁrst author supported Australian Research Council grant DP0666540 The authors thank anonymous reviewers insightful comments criticisms helpful revising improving paper References 1 KR Apt HA Blair A Walker Towards theory declarative knowledge J Minker Ed Foundations Deductive Database Logic Programming Morgan Kaufmann 1988 pp 293322 2 JJ Alferes JA Leite LM Pereira et al Dynamic logic programming Proceedings KR98 1998 pp 98111 3 C Baral Knowledge Representation Reasoning Declarative Problem Solving Cambridge University 2002 4 S Brass J Dix A general framework semantics disjunctive logic programs based partial evaluation Journal Logic Program ming 38 3 1998 167213 5 T Eiter M Fink G Sabbatini H Tompits On properties update sequences based causal rejection Theory Practice Logic Programming 2 2002 711767 6 T Eiter M Fink G Sabbatini H Tompits Reasoning evolving nonmonotonic knowledge base ACM Transaction Computational Logic 6 2005 389440 7 M Gelfond V Lifschitz The stable model semantics logic programming Proceedings International Conference Logic Programming The MIT Press 1988 pp 10701080 778 Y Zhang NY Foo Artiﬁcial Intelligence 170 2006 739778 8 K Inoue A simple characterization extended abduction Proceedings First International Conference Computational Logic CL2000 2000 pp 718732 9 K Inoue C Sakama Update equivalence logic programs Proceedings JELIA 2004 2004 10 S Konieczny R Pino Pérez On logic merging Proceedings 6th International Conference Knowledge Representation Reasoning KR98 1998 pp 488498 11 S Konieczny R Pino Pérez Propositional belief base merging merge beliefsgoal coming sources links social choice theory European Journal Operational Research 160 3 2005 785802 12 K Kunen Signed data dependencies logic programs Journal Logic Programming 7 3 1989 231245 13 J Lang P Marquis Resolving inconsistencies variable forgetting Proceedings 8th International Conference Principles Knowledge Representation Reasoning KR2002 Morgan Kaufmann Publishers 2002 pp 239250 14 J Lang P Liberatore P Marquis Propositional independenceFormulavariable independence forgetting Journal Artiﬁcial Intelli gence Research 18 2003 391443 15 JA Leite Evolving Knowledge Bases Speciﬁcation Semantics IOS Press 2003 16 P Liberatore M Schaerf A integration knowledge bases Proceedings 7th International Conference Knowledge Representation Reasoning KR2000 Morgan Kaufmann Publishers 2000 pp 145152 17 V Lifschitz D Pearce A Valverde Strongly equivalent logic programs ACM Transactions Computational Logic 2 4 2001 426541 18 F Lin R Reiter Forget Working Notes AAAI Fall Symposium Relevance 1994 pp 154159 19 F Lin On strongest necessary weakest sufﬁcient conditions Artiﬁcial Intelligence 128 2001 143159 20 F Lin Y Chen Discovering classes strongly equivalent logic programs Proceedings IJCAI2005 2005 21 CH Papadimitriou Computational Complexity Addison Wesley 1995 22 C Sakama K Inoue Updating extended logic programs abduction Proceedings LPNMR99 1999 pp 217 23 C Sakama H Seki Partial deduction disjunctive logic programming Journal Logic Programming 32 3 1997 229245 24 K Su G Lv Y Zhang Reasoning knowledge variable forgetting Proceedings 9th International Conference Principles Knowledge Representation Reasoning KR2004 Morgan Kaufmann Publishers 2004 pp 576586 25 JH You L Yuan A threevalued semantics deductive databases logic programs Journal Computer System Sciences 49 2 1994 334361 26 Y Zhang Two results prioritized logic programming Theory Practice Logic Programming 3 2 2003 223242 27 Y Zhang N Foo Updating logic programs Proceedings ECAI1998 1998 pp 403407 28 Y Zhang Logic program based updates ACM Transaction Computational Logic submitted publication httpwwwacmorgpubstocl acceptedhtml 2006