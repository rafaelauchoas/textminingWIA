Artiﬁcial Intelligence 172 2008 19732000 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Generalised arc consistency AllDifferent constraint An empirical survey Ian P Gent Ian Miguel Peter Nightingale School Computer Science University St Andrews St Andrews Fife KY16 9SX UK r t c l e n f o b s t r c t Article history Available online 17 October 2008 Keywords Constraint programming Constraint satisfaction problems Global constraints AllDifferent The AllDifferent constraint crucial component constraint toolkit language solver widely variety constraint models The literature contains inference different versions constraint trade strength computational cost In paper focus highest strength inference enforcing property known generalised arc consistency GAC This work analytical survey optimizations main algorithm GAC AllDifferent constraint We evaluate empirically number key techniques literature We report important implementation details techniques described published papers We pay particular attention improving incrementality exploiting stronglyconnected components discovered standard propagation process detailed Our empirical work represents far extensive set experiments variants GAC algorithms AllDifferent Overall best combination optimizations gives mean speedup 168 times implementation optimizations 2008 Elsevier BV All rights reserved 1 Introduction Constraints powerful natural means knowledge representation inference areas industry academia Consider example production university timetable This problems constraints include maths lecture theatre capacity 100 students art history lectures require venue slide projector student attend lectures simultaneously Constraint solving combinatorial problem proceeds phases First problem modelled set decision variables set constraints variables solution satisfy A decision variable represents choice order solve problem The domain potential values associated decision variable corresponds options choice In example decision variables lecture representing time venue For class students time variables lectures attend AllDifferent constraint ensure class timetabled places The second phase consists constraint solver search solutions assignments values decision variables satisfying constraints The simplicity generality approach fundamental successful application constraint solving wide variety disciplines scheduling industrial design combinatorial mathematics 29 The AllDifferent constraint expresses vector variables distinct values It crucial component constraint widely variety constraint models diverse problems quasigroup construction completion sports scheduling timetabling golomb ruler construction The literature contains Corresponding author Email addresses ipgcsstandrewsacuk IP Gent ianmcsstandrewsacuk I Miguel pncsstandrewsacuk P Nightingale 00043702 matter 2008 Elsevier BV All rights reserved doi101016jartint200810006 1974 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 different versions constraint trade strength inference computational cost Indeed choosing appropriate level consistency vital solving CSP eﬃciently 26 Van Hoeve surveys strengths inference 28 including weak fast pairwise decomposition described Section 612 bound range consistency generalised arc consistency GAC The classic GAC algorithm AllDifferent constraint given Régin 21 In paper focus highest strength inference enforcing GAC Limiting GAC allows study optimizations great depth mean scope paper include optimizations bounds range consistency algorithms This work analytical survey optimizations main algorithm generalised arc consistency GAC AllDifferent constraint While based survey published optimizations extend literature ways First provide extensive implementation details optimizations cover Such details omitted initial publica tions example reasons space Providing details save future workers having reinvent wheel Second provide extensive empirical analyses value techniques survey Importantly able evaluate optimizations combination Third particular techniques described literature new techniques introduce In cate gory explore incrementality strongly connected components search In category introduce methods reducing number necessary propagations dynamic triggers optimization case variables assigned In Section 2 paper review key background material present Régins algorithm high level survey optimizations proposed literature We discuss incremental matching domain counting use priority queue staged propagation processing strongly connected components independently important edges advisors ﬁxpoint reasoning In Section 3 implementation details algorithm The detailed survey key implementation issues contributions paper In Section 4 extensive details exploit strongly connected components SCCs improve eﬃciency AllDifferent propagation In Régins algorithm ﬁnd set SCCs graph formed allowed values matching variables values Edges distinct SCCs represent impossible values As branch search tree SCC remain split new SCCs Thus remove variablevalue pair need study individual SCC contained deleted variablevalue pair Since contain small fraction variables original constraint greatly reduce work incremental propagation requires This paper presents technique ﬁrst time previously folklore literature We empirically valuable optimization Section 6 We minor optimization computation SCCs common case assigned variable value In Section 5 exploit dynamic triggers GAC AllDifferent In standard algorithm work value deleted Katriel proved small set variablevalue pairs propagation possible value deleted 16 gave probabilistic algorithm exploit idea We extend idea technique maintains GAC deterministically reducing number times propagator called This implemented Minion dynamic triggers 10 We fact marginally better performance version implement dynamic triggers internally AllDifferent propagator This added advantage portable solvers dynamic trigger infrastructure We details Section 5 experimental results Section 64 We conclude technique beneﬁt mainly GAC AllDifferent performs badly generally useful Our empirical work Section 6 represents far extensive set experiments variants GAC algorithms AllDifferent We implement optimizations surveyed Implementations based stateoftheart Minion constraint solver 9 Our comparisons strawman implementation techniques use implementation addition optimizations replacement technique Our results number points In cases conﬁrm standard advice literature implement GAC AllDifferent We Section 63 incremental matching reduce runtime expensive constraint AllDifferent constraint propagated separate queue cheaper constraints Also worthwhile combine GAC AllDifferent algorithm cheaper algorithm hybrid staged propagator Against existing advice literature simpler matching algorithm effective complex And reported literature exploiting strongly connected components particularly beneﬁcial average speedup 3 times We summarise advice future implementers Section 7 Compared vanilla implementation Régins algorithm best combination techniques better speedup search thousands times We mean speedup 168 times vanilla implementation We hope survey help implementers obtain speedups systems stimulate researchers invent effective optimizations IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1975 Fig 21 Examples graphs 2 Background 21 Preliminaries A CSP P cid3X D Ccid4 deﬁned set n variables X cid3x1 xncid4 set domains D cid3D1 Dncid4 D cid2 Z D ﬁnite set potential values xi conjunction C C1 C2 Ce constraints Within CSP P cid3X D Ccid4 constraint Ck C consists sequence r 0 variables Xk cid3xk1 xkr cid4 respective cid4 st Xk subsequence1 X Dk subsequence D variable xki domain Dkr tuples specify P Ck associated set C S k domains Dk cid3Dk1 Dkr Dki matches variable x j domain D j allowed combinations values variables Xk Dk1 Although deﬁne constraint Ck scope cid3xk1 xkr cid4 discussing particular constraint frequently omit k subscript refer variables cid3x1 xrcid4 domains cid3D1 Drcid4 An AllDifferent constraint constraint Ck arity C S k contains tuples values distinct Throughout use r arity AllDifferent constraint question We use d represent number domain values involved constraint d D1 Dr A literal deﬁned variablevalue pair xi cid10 j xi X j Z To prune literal remove value k j domain D In context constraint Ck refer tuple τ values acceptable iff τ C S valid iff τ r j τ j Dk j value tuple respective domain Graph theory Régins AllDifferent algorithm 21 makes use results graph theory particular maximum bipartite matching 3 strongly connected components 27 We consider bipartite graphs digraphs A bipartite graph G cid3V Ecid4 deﬁned set vertices V set edges E V V edges interpreted having direction duplicate edges vertices partitioned sets V 1 V 2 elements set adjacent Fig 21a shows example bipartite graph V 1 1 2 3 V 2 4 5 6 A matching bipartite graph set edges M E edges connect vertex Fig 21b shows example matching cardinality bold dotted edges matching A maximum matching called maximum cardinality matching matching maximum cardinality Fig 21c shows maximum matching example bipartite graph In case maximum matching unique There algorithms compute maximum matching bipartite graph example HopcroftKarp 14 FordFulkerson 6 A digraph pair G cid3V Ecid4 set vertices V set edges E V V Edges interpreted having direction Fig 21d shows example digraph A strongly connected component SCC maximal set vertices digraph property path vertex set It follows cycles 1 We use subsequence sense cid31 3cid4 subsequence cid31 2 3 4cid4 1976 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 SCCs cycles edges SCCs The set SCCs forms partition vertices digraph Tarjans algorithm eﬃciently compute SCCs digraph linear time 27 For Fig 21d SCCs 1 2 4 5 3 6 shown Fig 21e 22 Régin Costas algorithm As pointed Knuth Raghunathan 18 known problem ﬁnding distinct representatives equivalent bipartite matching In context constraint solving Régin 21 exploited equivalence construct classic GAC algorithm AllDifferent constraint A similar algorithm published Costa 7 simultaneously Régins algorithm better time bound From consider Régins algorithm The algorithm uses results graph theory particular theorem Berge 3 Ch 7 page 125 algorithm major stages ﬁnding maximal matching variables distinct values ﬁnding strongly connected components digraph The algorithm usually incremental simplicity summarise nonincremental form 1 Find maximum valid matching M variables distinct values The HopcroftKarp 14 FordFulkerson 6 algorithms 2 If M r constraint unsatisﬁable 3 Construct residual graph R M variable domains This digraph property edges stronglyconnected components R correspond literals pruned R deﬁned Deﬁnition 22 4 Compute strongly connected components SCCs R Tarjans algorithm 27 5 Prune variablevalue pairs corresponding edge traverses SCCs G pair contained M2 221 Informal description algorithm Consider following example x1 x2 1 2 x3 x4 2 6 AllDifferent cid2 x1 x4 cid3 Computing matching The bipartite variablevalue graph shown Fig 22a Each variable represented vertex value repre sented vertex variable xi value j connected edge iff j domain xi This graph denoted B The ﬁrst stage algorithm construct maximum matching graph We consider bipartite maximum matching problem maximum ﬂow problem digraph Maximum ﬂow problem ﬁnding maximum rate material shipped source vertex sink edges digraph violating capacity constraints edges The digraph constructed B adding source vertex s sink t The set edges follows s variables x1 x4 value 1 6 sink t edge B translated directed edge variable vertex value This yields graph Fig 22b refer ﬂow graph For purpose ﬁnding maximum ﬂow edge capacity 1 The FordFulkerson method 6 Chapter 27 ﬁnd maximum ﬂow ﬂow graph s t The algorithm ﬁnds augmenting path path increase ﬂow For example s x1 1 t augmenting path Fig 22b The algorithm applies augmenting path increase ﬂow computes second ﬂow graph A second augmenting path sought second ﬂow graph way FordFulkerson iteratively ﬁnds applies augmenting paths path exists Hence sequence ﬂow graphs culminating ﬁnal ﬂow graph represents maximum ﬂow s t Each edge ﬂow graph ﬂow s t unused An unused edge carry new ﬂow size direction edge ﬁrst ﬂow graph Conversely edge carry new ﬂow opposite direction unused Therefore ﬂow graphs direction edges reversed relative direction ﬁrst ﬂow graph When augmenting path applied edge path unused vice versa This effect reversing direction edges path create ﬂow graph sequence One possible ﬁnal ﬂow graph shown Fig 23a representing matching xi 1 r The ﬁnal ﬂow graph represents maximum matching stage AllDifferent algorithm At point algorithm test maximum matching covers variables If constraint satisﬁed variable assigned value line 2 algorithm Computing SCCs Consider Fig 23a If cycle graph reverse direction edges ﬂow graph represents different maximal matching For example cycle t 4 x4 5 t 2 In cases edge contained matching traverse SCCs This occurs edge vital 21 For example variable assigned variable value contained singleton SCC assignment contained M IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1977 Fig 22 Graph maximum ﬂow algorithm Fig 23 Two possible ﬁnal ﬂow graphs reversed change assignment x4 5 matching Reversing cycle 3 x3 4 x4 3 corresponds swapping values 3 4 matching This similar iteration FordFulkerson algorithm difference ﬂow s t remains constant path starts ends vertex For cycle 3 x3 4 x4 3 result reversing cycle shown Fig 23b It possible generate maximum matchings ﬁnding cycles ﬁnal ﬂow graph reversing edges cycle 3 Ch 7 pages 124125 In language Berge cycles include t correspond alternating elementary chains starting unsaturated vertex Cycles include t correspond alternating elementary cycles In Fig 23a sets s1 x1 x2 1 2 s2 x3 x4 3 4 5 6 t distinct cycle containing vertices sets In words variables s1 values s2 vice versa In fact s1 s2 SCCs deﬁned Section 21 Two edges x3 2 x4 2 cross SCC The ﬁnal ﬂow graph partitioned SCCs For Fig 23 SCCs s1 x1 x2 1 2 s2 x3 x4 3 4 5 6 t s3 s For edge crosses SCC contained matching corresponding domain value removed This suﬃcient enforce GAC 21 In example 2 removed domain x3 x4 edges x3 2 x4 2 222 The AllDifferent algorithm To construct sound complete GAC algorithm 21 Régin exploited result Berge applied B edge free belonging maximum matchings iff edge belongs path containing number edges alternating path alternates edges matching beginning 1978 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 unmatched vertex alternating cycle 3 Ch 7 page 125 Edges free matching maximum matching correspond variablevalue pair pruned We Régins algorithm In informal description FordFulkerson algorithm compute matching ﬁnal residual graph second stage algorithm FordFulkerson eﬃcient matching algorithm section separate matching SCC computation The size union domains D1 Dr d For simplicity domain elements assumed 1 d Deﬁnition 21 The bipartite variablevalue graph deﬁned B cid3V Ecid4 V x1 xr 1 d E xi j j D A bipartite matching algorithm applied B returning maximumcardinality matching M x1 xr 1 d If M r AllDifferent constraint satisﬁable algorithm returns false Next construct residual digraph function M D1 Dr This similar ﬁnal ﬂow graph omit source vertex s singleton SCC direction edge opposite eﬃciency reasons affect SCCs cid14 x1 xr 1 d t types cid14cid4 V Deﬁnition 22 The residual digraph deﬁned R cid3V cid14 M E2 E3 E4 The matching edges M connect variables values Residual edges connect values variables edges E value matching E2 j cid10 xi j D xi cid10 j M A set edges connect t E 3 j cid10 t xi cid10 j M fourth set connect t unmatched values E4 t cid10 j cid3i xi cid10 j M j D cid14 E An SCC algorithm applied R returning partition S s1 sk V If k 1 algorithm ﬁnished Otherwise edge B contained M connects vertices SCCs S edge corresponds variablevalue pair pruned cid14 23 Optimizations basic algorithm A number optimizations basic algorithm proposed authors We survey 231 Incremental matching The matching M maintained incrementally search 21 Régin suggested representation variablevalue graph set edges involved matching stored calls Deleted edges restored backtracking decision caused removal Edges corresponding pruned values removed incrementally In order remove appropriate edges Régins algorithm requires set removed values passed propagator If HopcroftKarp repair matching Régin reports time complexity HopcroftKarp krd k number matching edges AllDifferent algorithm improved O r15d O lost 213 232 Domain counting Quimper Walsh 20 proposed variants AllDifferent Global Cardinality constraints set multiset tuple variables These variable types extremely large domains They observe domain variable xi larger threshold constraint need triggered pruning xi The threshold value equal r Quimper Walsh algorithm calculates size domains constructing set variables domains smaller threshold value While idea conceived context set multiset tuple variables apply small ﬁnite domains We suspect counting domains expensive In experiments follow simpler approach Lagerkvist Schulte 19 uses r threshold value When variable event triggers constraint domain D variable counted If D cid2 r propagator called queued called We observe threshold reduced r 1 The original lemma 20 based Hall sets Hall set set H variables variable domain subset set values D H D H H If Hall set exists values D H pruned variables H If Hall sets corresponding pruning performed GAC established A Hall set size r use variables outside Hall set pruned The largest Hall set useful size r 1 domains size r 1 Therefore experiments domain counting propagator called queued called D changed D r 3 In recent presentation httpwwwsopinriafrcoprincpaior04ﬁlesgraphandcpppt slide 70 Régin revises bound O krd IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1979 As example Hall set consider following AllDifferent constraint x1 x3 1 3 x4 x6 3 6 AllDifferentx1 x6 The variables x1 x3 form Hall set values 1 3 Therefore value 3 removed domains variables x4 x6 This type reasoning informally solve Sudoku puzzles 233 Priority queue Many constraint solvers priority queue constraints 11523 priorities determine order constraint propagators executed It standard practice AllDifferent constraint low priority Schulte Stuckey demonstrate importance priority queueing 22 evaluate experiments 234 Staged propagation Schulte Stuckey propose multiple staged propagation 22 cheap propagator high priority combined expensive low priority propagator For instances containing AllDifferent approach shows promise evaluate staged propagator experiments 235 Decomposition AllDifferent Suppose example AllDifferentx1 x6 x1 x3 1 3 x4 x6 4 6 This decompose independent constraints AllDifferentx1 x3 AllDifferentx4 x6 This decomposition saves time ef ﬁciently ﬁnd manage decompositions Unfortunately optimization folklore community literature4 One cheap method decomposing constraint use strongly connected components GAC AllDifferent algorithm As report Section 4 method complete ﬁnd possible decompositions works practice How manage decompositions eﬃciently obvious One contributions paper Section 4 implement optimization eﬃciently including algorithms data structures 236 Important edges Katriel observed value removals affecting AllDifferent result value removals work processing wasted 16 In general context constraints based network ﬂows introduces concept important edge An important edge removal causes removal variablevalue pair She gives upper bound number important edge AllDifferent generalised cardinality constraints If graph dense allowed values variable shows expected cost propagation reduced propagating intermittently She suggests ﬁring propagation simple count value removals affecting constraints hits number indicating probabilistically value likely deleted Note algorithm actually enforce GAC miss propagations count low catching deeper node search tree Katriel report implementation observes risks failing propagate outweigh reduced cost propagation While implementation Katriels algorithm interesting fact maintain GAC puts outside scope paper In paper adapt notion important edges reduce number times AllDifferent propagator called guaranteeing GAC enforced correctly We dynamic triggers 10 report Section 5 We cheap technique ﬁnding 2r d edges edge set guaranteed important edge 237 Other proposals literature Lagerkvist Schulte develop advisors context Gecode solver 19 An advisor procedure executed immediately variable event occurs They use advisors AllDifferent implement domain counting eagerly maintain matching violated Unfortunately AllDifferent variants problem instances experimented cost advisors outweighed beneﬁts 19 We experiment advisors Schulte Stuckey propose ﬁxpoint reasoning 22 observe slight 01 improvement runtime instance golomb10d GAC AllDifferent constraint Fixpoint reasoning reduce number calls propagator eliminating useless calls However observe useless execution AllDifferent algorithm cheap incrementality We experiment ﬁxpoint reasoning 3 Implementation AllDifferent algorithm In section report number implementation details GAC AllDifferent propagator use empirical evaluation optimizations This gives survey major minor issues facing implementer With exception matching algorithms design decisions based literature based reasonable purpose subjecting choices rigorous empirical evaluation In section 4 To idea known slide 61 4 example taken 1980 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 propagate returns Boolean 1 1 r matchingi initialize matching 2 hasMatchingFindMaximumMatchingmatching x1 xr repair matching return False 3 hasMatching 4 5 FindSCCsRemoveValuesmatching x1 xr 6 return True Algorithm 1 AllDifferent basic variant select bipartite maximum matching algorithms later empirical comparison selecting good time bound known work practice Algorithm 1 shows basic variant AllDifferent propagator This variant incremental way It simply calls FindMaximumMatching FindSCCsRemoveValues To support incremental matching line 1 removed The matching algorithms consider perform iterative repair changes need support incremental matching This variant AllDifferent item state stored matching function This backtracked valid matching backtrack stable As values restored backtracking valid matching remains valid values removed Both variants AllDifferent FindMaximumMatching FindSCCsRemoveValues These functions described Sections 31 32 Régin claims space complexity AllDifferent O rd variablevalue graph stored explicitly 21 In Régins approach variablevalue graph maintained values removed domains backtracked search backtracks This justiﬁed context querying domains expensive However experimental context querying domains cheap Therefore implementation store variable value graph residual graph explicitly reducing space complexity O d The graphs discovered traversed Since edges correspond variablevalue pair checking edge present implemented testing domain contains particular value When discovering edges variable vertex necessary iterate domain Ideally solver provide domain iterator ﬁnd ﬁrst domain elements constant time In experiments solver provides minimum maximum values domain use bound iteration To ﬁnd edges value vertex variable necessary iterate variables store backtrack graph explicitly 31 Maximum bipartite matching The ﬁrst algorithm considered HopcroftKarp algorithm 14 The HopcroftKarp algorithm runs time rm m number edges variablevalue graph m cid2 rd However incremental matching O algorithm computes matching scratch root node search subsequently repairs matching k edges lost With HopcroftKarp cost reported O 21 Our implementation C follows Eppstein 8 The second algorithm implemented FordFulkerson 6 simple breadthﬁrst search FFBFS augment ing paths It begins unmatched variable vertex searches augmenting path The augmenting path applied increase cardinality matching This iterated unmatched variable vertices BFS ﬁnd augmenting path FFBFS advantage good average behaviour wide range bipartite graphs 25 algorithm runs time O rm To repair matching k edges lost cost O Régin 21 Alt Blum Mehlhorn Paul 2 ABMP algorithm variant HopcroftKarp time m log r In terms upper bound HopcroftKarp better sparse graphs ABMP better bound O r15 dense graphs We know density variablevalue graph advance cid4 Compared applications matching algorithms graphs relatively small In experiments problem class largest AllDifferent constraint contrived problem r 500 The second largest social golfers r 480 sports scheduling r 120 This instances easy hours solve Setubal empirically compared ABMP FFBFS FFDFS FordFulkerson depthﬁrst search Goldbergs algorithm 25 He generated bipartite graphs 2p vertices partition p 8 17 If estimate graphs 29 vertices partition examination Setubals results taking size closest 29 class graphs considering sequential computers shows FFBFS competitive classes eﬃcient equal 811 classes Taking results earlier work Setubal 24 expect FFBFS perform better HopcroftKarp experiments This case shown Section 63 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1981 FindSCCsRemoveValuesmatching varSet returns 1 visited TStack maxDFS 1 hasSCCSplitFalse 2 xi varSet 3 4 TarjanRemoveValuesxi start search xi xi visited TarjanRemoveValuescurnode returns newnodeTStack newnodevisited lowLinkcurnodeminlowLinkcurnode DFSNumnewnode 1 TStackpushcurnode 2 DFSNumcurnodemaxDFS 3 lowLinkcurnodemaxDFS 4 maxDFS maxDFS 1 5 visitedinsertcurnode 6 newnodeneighbourhoodcurnode 7 8 9 10 11 12 13 lowLinkcurnodeDFSNumcurnode curnode root SCC 14 lowLinkcurnode1 DFS traverse variables 15 16 17 18 19 20 21 22 23 TarjanRemoveValuesnewnode lowLinkcurnodeminlowLinknewnode lowLinkcurnode xi varSet xi SCC removeFromDomainxi e SCC stacknodenull stacknodecid19curnode e SCC e 1 d e domain value stacknodeTStackpop SCCinsertstacknode hasSCCSplitTrue hasSCCSplit 32 Finding SCCs removing domain values Algorithm 2 FindSCCsRemoveValues To compute SCCs use Tarjans algorithm 27 simple eﬃcient time bound O V E O rd It suitable optimization Section 5 information collected algorithm runs Algorithm 1 calls FindSCCsRemoveValues Algorithm 2 ﬁnds SCCs removes appropriate values achieve GAC To avoid storing SCCs explicitly tasks implemented FindSCCsRemoveValues simple wrapper initializes data structures calls TarjanRemoveValues possibly needed All variables shared FindSCCsRemoveValues TarjanRemoveValues TarjanRemoveValues performs Tarjans algorithm 27 recursively lines 112 removes values domains SCCs lines 1323 Tarjans algorithm performs depthﬁrst search DFS If implemented recursively SCCs constructed recursion unwinds The crux Tarjans algorithm root property vertex identiﬁed root SCC The root property tested line 13 When root identiﬁed SCC constructed TStack data structure The residual graph Deﬁnition 22 given neighbourhood function line 6 neighbourhoodv returns set vertices v 1 v 2 connected v directed edge v cid10 v j The data structures Tarjans algorithm described maxDFS simple counter starting 1 incremented time new vertex discovered line 4 DFSNum record order vertices discovered numbering vertices 1 DFSNum set maxDFS line 2 visited set vertices visited It updated line 5 TStack stack vertices starts Whenever new vertex discovered pushed TStack line 1 When algorithm detects curnode current node DFS root SCC constructs SCC popping values TStack including curnode lines 1720 lowLink key data structure property lowLinkc minimum DFSNum vertices reachable following edges DFS followed edge R For vertex c lowLinkc equals DFSNumc iff c root strongly connected component lowLinkc initialized DFSNumc The value lowLinkc updated neighbouring vertices lines 9 12 When lowLinkc line 13 reached ﬁnal value The neighbourhood function appear program code avoid overhead function Instead lines 612 repeated times following cases curnode t curnode x1 xr curnode 1 d 1982 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 For case curnode t neighbour set computed ahead time If set t omitted residual graph singleton SCC When curnode x1 xr 1 d neighbour set iterated explicitly constructed When algorithm ﬁnds root SCC line 13 simple test determine residual graph partitioned lines 1415 If DFS traversed variable vertices unreachable recursion unwind fully residual graph partition SCC If residual graph partition algorithm computes current SCC lines 1720 This SCC contains variables values maximum matchings values assigned variables SCC Therefore values assigned variable varSet SCC Accordingly values removed variables removeFromDomain 33 Minor implementation details The graph algorithms manipulate small sets integers performing operations inserting removing integers clearing set testing presence particular integer iterating set One example set visited vertices Tarjans algorithm In implementation vertex mapped distinct integer In cases know range integers 0 r d We designed following data structure represent subset 0 n We integer array v0 n indexed set element integer c called certiﬁcate v initialized 0 certiﬁcate 1 An element e present set iff ve c To insert element e ve c delete e ve 0 To clear set c c 1 In way clear set small constant time When require set iterable maintain array values stored contiguously integer representing size set The clear operation implemented constant time setting size 0 incrementing certiﬁcate For type set remove operation linear time rarely called place It called application assignment optimization described Section 42 The matching M primarily represented array domain values indexed variable number When HopcroftKarp represented array variable numbers indexed value Both HopcroftKarp FFBFS maintain set values matching HopcroftKarp maintains set variables 4 Exploiting strongly connected components In section focus optimizations exploit strongly connected components SCCs search process The main focus ﬁrst detailed description literature exploit independence strongly connected components described brieﬂy Section 235 Here data structures algorithms indepen dent processing SCCs We introduce believe new minor optimization process SCCs faster variable assigned x1 x3 1 3 x4 x6 3 6 AllDifferentx1 x6 41 To identify disjoint SCCs consider 41 Assume matching xi cid10 The residual graph shown Fig 41 Running Tarjans algorithm graph computes SCCs containing variables x1 x3 x4 x6 respectively After partitioning graph GAC algorithm prune value 3 variables x4 x6 At point SCCs completely disconnected residual graph variablevalue graph remain values restored backtracking In future calls propagator SCCs considered independently This allows speed maximum matching algorithm Tarjans algorithm The algorithms run subgraph variablevalue graph maximum matching algorithm subgraph residual graph Tarjans Furthermore variable xi changed changes trigger AllDifferent constraint SCC containing xi needs considered These changes result considerable eﬃciency gains shown Section 65 Fig 41 Residual graph example IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1983 This method perform possible decompositions AllDifferent constraint Suppose example AllDifferentx1 x6 x1 x3 1 4 x4 x6 5 8 This decompose independent constraints AllDifferentx1 x3 AllDifferentx4 x6 Our method perform decomposition Both parts straint variables values spare values cause x1 x3 x4 x6 connected sink t variables contained SCC Despite incompleteness decomposing according SCCs works practice 41 Representing set partition In order store SCCs calls AllDifferent algorithm backtrackable representation set partition needed It suﬃcient store partition set variables represented integers 1 r values quickly discovered variables It important set partition eﬃciently iterable matching algorithm Tarjans algorithm need iterate set variables The order iteration important It necessary O 1 set membership test When AllDifferent algorithm executes subdivide SCCs merges SCCs changes way Therefore subdivision required sets restored backtracking For set integers S 1 r partition representation consists arrays integers array backtracking Booleans setElements1 r Contains permutation elements S setElementIndex1 r For element S setElementssetElementIndexa splitPoint1 r 1 If splitPointb False elements setElementsb setElementsb 1 subset Oth erwise elements setElementsb setElementsb 1 belong different subsets partition The operation subdividing partition involves permuting elements setElements updating setElementIndex accordingly changing Booleans splitPoint false true When change backtracked necessary restore splitPoint array This illustrated Fig 42 simple example To subdivide subset size n takes O n time n elements need written setElements array n indices updated setElementIndex array Up n 1 elements splitPoint changed operation To undo operation backtracking n 1 values splitPoint restored The setElements setElementIndex arrays simple arrays integers The splitPoint array maintained trailing Changing value splitPoint array O 1 cost overall It involves operations O 1 time changing value memory adding record trail stack reading record restoring value backtracking Therefore cost maintaining splitPoint affect overall O n time subdivide partition Fig 42 Illustration set partition data structure 1984 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 Fig 43 Illustration partitioning element 4 set 1 2 3 4 5 6 42 Assignment optimization Assignment variable search procedure propagation likely common case optimizing pay When variable xi assigned computation SCCs simpliﬁed somewhat In residual graph xi outward edge inward edges xi singleton SCC Where xi cid10 value removed domain variables To optimize case SCC s containing xi partitioned First xi swapped ﬁrst element SCC setElements Then splitPointsetElementIndexi set True subdivide s s1 xi s2 s xi This process illustrated Fig 43 The value removed domain variables s2 s2 queued processed Tarjans algorithm subdivide This takes O r time decrease number calls Tarjans algorithm However reduce size graph Tarjans operates The effectiveness optimization tested Section 65 43 Implementing independent SCCs To implement proposals replace simple propagate function Algorithm 1 propagateSCC Algorithm 3 This function requires set variables named triggeringVars parameter These variables triggered constraint simplest case variables domain changed propagateSCC When dynamic triggers described Section 5 triggeringVars set variables lost trigger values When domain counting triggeringVars set changed variables domain size r For variable xi large domain possible matching value Mi removed D xi triggeringVars invalidating matching triggering constraint To cover case lines 1517 check matching SCC s If value matching removed FindMaximumMatching called This required domain counting introduce ﬂag DomainCounting True iff domain counting PropagateSCC iterates set triggering variables ﬁnding SCC variable belongs named s line 3 checking matching invalidated line 4 If FindMaximumMatching called repair matching lines 56 Lines 711 Algorithm 3 implement assignment optimization If xi assigned lines 811 executed It possible s added changedSCCs partitioned removed changedSCCs This line 8 s partitioned singleton SCC xi remainder s s xi line 9 Line 10 performs removal assigned value variables s2 s2 queued changedSCCs necessary line 11 If xi assigned possible s subdivide s 1 s added changedSCCs line 13 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1985 propagateSCCtriggeringVars returns Boolean s ﬁndSCCxi SCCs ﬁnd SCC including xi inDomainxi matchingi hasMatchingFindMaximumMatchingmatching s repair matching hasMatching return False isAssignedxi 1 changedSCCs 2 xi triggeringVars 3 4 5 6 7 8 9 10 11 12 13 14 s changedSCCs 15 16 17 18 19 return True changedSCCschangedSCCss Partition s s1 xi s2 s xi SCCs x j s2 removeFromDomainx j getMinxi s2 1 changedSCCschangedSCCss2 s 1 changedSCCschangedSCCss DomainCounting xi s inDomainxi matchingi hasMatchingFindMaximumMatchingmatching s hasMatching return False FindSCCsRemoveValuesmatching s Algorithm 3 AllDifferent SCCs processed independently If assignment optimization required lines 713 replaced single line inserts s changed SCCs 5 Dynamic triggers AllDifferent constraint By default AllDifferent constraint triggered change variable domain However possible identify cases SCCs remain strongly connected pruning For example domain counting described Section 232 yields approach As described Section 236 Katriel took different approach deﬁning important edges ﬂow graph deletion causes deletions showing number important edges small 16 Katriel extend observation method enforce GAC correctly possibly reducing work We section cheap method ﬁnding set edges includes important edges implemented constraint solver dynamic movable triggers 51 Background Gent et al proposed watched literals 10 inspired SAT Used triggers ﬁre constraint propagations watched literals features different triggers normally Watched literals cause propagation given variablevalue pair deleted triggering conditions changed dynamically search remain stable backtracking use memory restoration Watched literals shown effective element table Boolean sum constraints Gent et al 1011 Watched literal propagation algorithms typically revolve concept support A support literal object evidence literal consistent removed propagation algorithm An example support valid acceptable tuple table constraint5 In case tuple act support literals contains While support intact work needs constraint triggered support invalidated A second example support pair unassigned variables CNF clause SAT shows unit propagation Therefore support literals clause The variables certain events occur domain changed These include lowering upper bound raising lower bound assigning variable single value removing speciﬁc value domain We refer placing watched literal meaning attach variable event clearing removes event When variable event occurs solver iterates watched literals attached event calling relevant constraint propagator A ﬁxed number watched literals allocated constraint search begins The concept watched literals completely suitable AllDifferent constraint watched literals correct moved backtracking property called backtrackstability The object use support backtrackstable demonstrate section triggers restored backtracking Gent et al refer backtracked watched literals dynamic triggers 10 5 Each element valid tuple relevant domain acceptable tuple satisﬁes constraint deﬁned Section 21 1986 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 52 Adapting AllDifferent dynamic triggers When adapting AllDifferent algorithm use dynamic triggers important structure set SCCs SCC remains strongly connected propagation necessary trigger constraint Therefore focus Tarjans algorithm identify edges residual graph present Tarjans algorithm follow trajectory return result executed All important edges Katriels sense 16 set Katriel explicit algorithm ﬁnding set containing important edges extracted proof The construction proof based depth ﬁrst search SCC We follow similar approach present context Tarjans algorithm This method simple eﬃcient requiring information gathered Tarjans algorithm runs We collect set T edges follows As described Section 32 Tarjans algorithm performs depthﬁrst search DFS residual graph R cid3V traversed DFS included T The lowlink value vertex updated edges graph criterion identifying SCC based lowlink value For vertex lowlink value changed times ﬁnal value identifying SCCs edge obtain ﬁnal value included T All edges E cid14cid4 The edges E included T cid14 E cid14 cid14 We claim removal edge E T affect set SCCs We consider edges effect removing edges set SCCs monotonic Removing edge cause change cause SCC subdivide SCCs Therefore number SCCs monotonically increases To demonstrate claim prove digraph ˆR cid3V cid14 T cid4 SCCs R The execution Tarjans algorithm digraph D denoted T D cid14 Theorem 51 The digraphs R cid3V cid14 E cid14cid4 ˆR cid3V cid14 T cid4 SCCs Proof The proof showing Tarjans algorithm returns SCCs R ˆR Tarjans algorithm correct 27 Thm 14 The order vertex exploration DFS Tarjans algorithm irrelevant result It possible T ˆR perform exact DFS T R set vertices edges required DFS T deﬁnition Hence loss generality assume T ˆR perform DFS T R Therefore DFSNum vertex identical At vertex v DFS tree lowLinkv computed taking minimum set S v values S v corresponds lowLink DFSNum neighbours v For neighbour inclusion corresponding value S v depends DFS order invariant Therefore required edge corresponding smallest value S v present T This case deﬁnition The ﬁnal T R constructs SCCs recursion unwinds The computed SCCs depend ﬁnal values lowLink order DFS Therefore T ˆR constructs set SCCs cid2 Some edges T directly represent literal edge form xi cid10 j j cid10 xi We place dynamic triggers corresponding literals It safe ignore edges T correspond domain value Fig 51a illustrates process residual graph representing variables x1 x2 x3 ﬁve values 1 2 3 4 5 The DFS performed following order x1 1 x2 2 x3 3 t 4 5 The edges traversed DFS represented wide dotted lines ﬁgure Three edges ﬁnally change lowlink value 2 cid10 x1 4 cid10 x2 5 cid10 x3 represented solid black ﬁgure Edges t ignored purpose placing triggers For Fig 51a set triggers x1 cid10 1 x1 cid10 2 x2 cid10 1 x2 cid10 2 x2 cid10 4 x3 cid10 2 x3 cid10 3 x3 cid10 5 Fig 51b shows different execution algorithm graph In case DFS performed order x1 1 t 4 x2 2 x3 3 5 This gives smaller set triggers x2 cid10 1 included case All triggers Fig 51a This method yields 3 triggers variable plus trigger spare value 3r d r 2r d triggers triggers ﬁnd necessary For example Fig 51a triggers 4 cid10 x2 5 cid10 x3 necessary The triggers suﬃcient prove vertices x1 x2 x3 SCC The triggers backtrackstable Consider case SCC s1 divides s2 s3 edges lost triggers computed s2 s3 clearly cover edges necessary prove connectedness s1 edges connecting components Therefore s1 restored backtracking triggers backtracked We conjecture approach work domains large values removed domains search node 53 Implementing collection dynamic triggers This approach cheap implement requires information collected execution Tarjans algorithm No additional computation required IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1987 Fig 51 Example identifying triggers different DFS orderings Two sets changes needed Algorithm 2 Firstly algorithm FindSCCsRemoveValues dynamic triggers variables s cleared Then dynamic trigger placed value matching current SCC s This values DFS In addition watched literal placed value matching This required matching backtracked dynamic triggers diverge search backtracks Placing watched literals guarantees AllDifferent triggered matching violated In cases cause constraint triggered twice variablevalue pair However combining dynamic triggers priority queue Section 233 constraint triggered merely adds triggering variable set processed later returns Therefore cost additional watched literals minimal The second set changes algorithm TarjanRemoveValues When curnode 1 d dynamic triggers added corresponding edges DFS line 11 ﬁnal change lowLinkcurnode lines 9 12 If ﬁnal change lowLinkcurnode occurred line 12 edge DFS updating lowLink It necessary place dynamic triggers corresponding edge Only dynamic trigger placed case 54 Internal dynamic triggers It possible simulate dynamic triggers entirely AllDifferent constraint To propagator stores dynamic trigger values backtracking array The constraint sets static triggers trigger domain change When triggered variable xi propagator checks domain triggering variable important values lost If immediately returns For variable values stored contiguously array length counter In experiments arrays backtracked block copying We refer method internal dynamic triggers There reasons useful simulate dynamic triggers way Firstly eﬃcient The cost writing trigger value array low clearing array setting size 0 cheap By contrast placing real dynamic trigger implemented doublylinked lists described Gent et al 10 requires assignments pointers Clearing set dynamic triggers requires assignments literal In addition changes recorded trail stack reversed backtracking Secondly solver provide dynamic triggers Indeed solvers provide facility Therefore internal dynamic triggers important general applicability dynamic triggers AllDifferent 6 Experimental evaluation In section context experimental evaluation Then present groups experiments First evaluate standard approaches incremental matching priority queueing Section 63 Secondly Section 64 evaluate dynamic triggers domain counting approaches intended reduce number calls propagator Thirdly Section 65 evaluate processing SCCs independently Finally compare best GAC AllDifferent constraint propagator establishes weaker consistency 61 Experimental context For experiments use solver Minion 910 We adapted Minion 041 following ways Monotonic set We monotonic set available constraints new interface By monotonic mean element set removed given node element remains set descendant nodes 1988 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 Monotonicity allows eﬃcient implementation trailing We represent element value true false values true false need store element changed value restore This implement set partition data structure described Section 41 In particular splitPoint array The cost removing element set combined subsequent restoration backtracking O 1 Dynamic triggers We took watched literals 10 added trailing mechanism restore search backtracks This facility coexists standard watched literals In Minion watched literal placed variablevalue pair upper lower bound variable triggering domain change triggering assignment A watched literal unused AllDifferent makes use watched literals dynamic triggers variable value pairs Minion provides facilities need When constraint triggered easy identify triggering variable The inDomain getMin getMax methods allow query variable domains The method removeFromDo main remove values variable domains Domain lookups designed fast Minion common operation This important running graph algorithms query domains order discover graph traverse Domain iteration important AllDifferent algorithm Unfortunately Minion support domain iteration maintain upper lower bounds bound iteration All experiments run Apple iMac computers 2 GHz Core Duo processors 2 GB RAM OS X Tiger 10411 The branch Minion available httpminionsourceforgenetﬁles including build instruc tions We conducted extensive testing code passed As continual detailed testing development checked number search nodes explored variant algorithm instance excepting instances exceeding time node limits In experiments comparing variants GAC AllDifferent limited search nodes 500000 time 1200 s Because possibility timeout main metric speed nodes searched second instead raw runtime For Social Golfers Golomb instances Minion stop time limit minor ﬂaw time limit implementation Finally runtimes report total time nodes solve timeout given instance including initialisation search time including time outside AllDifferent propagator This automatically means incidental features optimization accounted example additional reduced memory usage effect practical runtime It mean results report typically dramatic obtained measured runtime inside AllDifferent propagator Despite orders magnitude improvement runtime 611 Minion queue mechanisms triggers Minion variablecentric solver additional constraintcentric queue Conceptually queues described The solver queues eﬃciency reasons variable queue fast adding variable event queue O 1 operation However variable queue allow constraints given low priority Having additional constraint queue overcomes limitation The variable queue The variable queue contains variable events different types Value removed D Upperlower bound xi changed xi set The variable queue contain duplicates bound events The events duplicated queue simply happen twice single search node Each variable event lists associated list static triggers ﬁxed search begins doublylinked list dynamic triggers To propagate variable event solver iterates lists calling propagators associated triggers Each trigger contains integer passed propagator In way propagator identify trigger variable event triggered The constraint queue The constraint queue contains pointers constraints Constraints responsible setting triggers adding constraint queue necessary In way constraint triggered variable queue perform test determine record added constraint queue This allows implement domain counting described Section 232 internal dynamic triggers described Section 54 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1989 Indeed constraint fail update internal data structures perform propagation triggered variable queue mechanism general Lagerkvist Schultes advisors Section 237 permitted perform propagation The constraint queue allows duplication AllDifferent constraint keeps record present constraint queue avoids duplication The constraint queue priority queue However constraint queue lower priority variable queue variable queue emptied item processed constraint queue In experiments presented constraint use constraint queue AllDifferent constraint lower priority constraint The overall algorithm process queues shown queue variable queue process entire variable queue constraint queue process item constraint queue 612 Pairwise AllDifferent Minion provides simple AllDifferent propagator triggered variable assigned removes assigned value domains variables This clearly simple fast algorithm It performs propagation AC clique binary notequal constraints achieve GAC We Pairwise propagator 613 Staged AllDifferent As described Section 234 Schulte Stuckey propose combine cheap propagator similar pairwise propagator described GAC AllDifferent 22 They suggest ways simply posting constraints building staged propagator propagators They showed staged propagation eﬃcient Gecode instances 22 The proposed staged propagator makes use multiple constraint queues Gecode impossible implement exactly Minion We implement close analogue Whenever staged propagator called variable queue checks triggering variable assigned If assigned value removed domain variables Apart additional check staged propagator identical conventional This simple change yields good experimental results shown Section 63 62 Benchmark set We generated large number benchmark instances available httpminionsourceforgenet They described brieﬂy Langfords number problem prob024 CSPLib 13 k 2 occurrences number n 10 11 12 25 This modelled vector v length 2n different elements vi vi n represent positions colour problem The model Gent Miguel Rendl 12 The variable order follows indices vector v value order ascending The Golomb ruler problem prob006 CSPLib construct set n integers different intervals pairs different The lowest integer assumed 0 highest integer minimized branch bound This modelled vector nn 12 differences pairs integers single AllDifferent constraint vector The variable order follows indices vector value order ascending Balanced quasigroup holes QWH 17 problem completing partial latin square particular struc ture The instances generated random complete latin squares order n 20 25 30 35 Ten latin squares generated size cid2017 n155cid21 holes punched create balanced partial latin squares The number holes yields instances near diﬃculty peak The problem modelled n n matrix variables domain 1 n AllDifferent constraint row column The variable order left right rows The rows searched sequence matrix The value order ascending Quasigroup existence prob003 CSPLib problem determining quasigroup exists certain properties example idempotence elements We types QG3 QG4 idempotent nonidempotent orders n 7 8 9 10 making 16 instances total The problem modelled n n matrix variables domain 1 n AllDifferent constraint row column AllDifferent primary diagonal constraints representing properties quasigroup type Various implied constraints included The model Colton Miguel 5 The variable value ordering QWH Social golfers prob010 CSPLib problem assigning gs golfers s sets size g w weeks golfers play It modelled w vectors variables domain 1 g s 1990 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 representing weeks For week vector partitioned s sets To break symmetries sets lex ordered week golfers ordered sets weeks lexordered Each week vector AllDifferent constraint A second vector variables domain 1 gsgs 12 represents pairs play For week pair variables set variables mapped single variable pairs vector table constraint The pairs vector AllDifferent constraint We generated social golfers instances g 4 following parameters cid3w scid4 cid35 4 8cid4cid36 4 8cid4 cid37 5 8cid4 cid38 6 8cid4 cid39 7 8cid4 cid310 8cid4 making 20 instances The variable order search week turn week follow indices w vector The value order ascending Sports scheduling similar social golfers g 2 ﬁxtures involve teams n teams play n2 pitches n 1 weeks Each team plays pitch twice It modelled n 1 vectors variables domain 1 n representing weeks The vector partitioned pairs To break symmetries pair ordered weeks lexordered Also pitches interchangeable vectors games pitch lexordered Sports scheduling pairs vector AllDifferent table constraints representations In way guaranteed team plays team exactly The variable value order social golfers The contrived problem contrived beneﬁt dynamic triggers domain counting It patho logical GAC AllDifferent constraint performs pruning despite signiﬁcant computation It consists vectors v w v length 5 variables domain 1 50 An AllDifferent constraint pairwise propagator placed v v4 v5 Therefore solutions The pairwise AllDifferent present problem unsatisﬁable causing Minion search extensively binary search tree 50 49 48 47 5527200 left branches w vector length l cid3 4 containing variables domain 1 d A GAC AllDifferent constraint placed w vectors v w linked v1 cid19 w1 v2 cid19 w2 v3 cid19 w3 v4 cid19 w4 Hence variable v assigned value removed variable w propagation The variable order follows indices v value order ascending We generated instances l 100 200 300 400 500 types d l d l 1 Both types work dynamic triggers value removed left branch unlikely trigger GAC AllDifferent When domain counting d l constraint triggered removal single value However d l 1 constraint triggered propagator executed root node In case domain counting outperform dynamic triggers 63 Experiment variants proposed literature Prioritized queueing incremental matching standard techniques In experiment test merit We consider alternative matching algorithm staged propagation Simple The simplest variant AllDifferent shown Algorithm 1 It use constraint queue called variable event Simple process SCCs independently use dynamic triggers domain counting The HopcroftKarp algorithm compute matching PriorityQ The Simple algorithm called constraint queue It added constraint queue variable event present Therefore duplicates removed constraint propagated PriorityQIncMatch PriorityQ incremental matching Algorithm 1 line 1 removed matching tained PriorityQIncMatchBFS This PriorityQIncMatch FFBFS matching algorithm HopcroftKarp PriorityQIncMatchBFSStaged This PriorityQIncMatchBFS staged propagation described Section 613 Firstly Simple PriorityQ compared benchmark set We expected PriorityQ perform better instances Fig 61 shows case instances beneﬁt constraint queue performing 100 times better This mainly agrees results Schulte Stuckey 22 priority queueing results dramatic The instances Simple solves faster PriorityQ QWH instances These contain AllDifferent constraints reducing priority constraint effect Given theoretical advantage incremental matching expect PriorityQIncMatch perform better PriorityQ This case instances shown Fig 62 gain 40 We compared PriorityQIncMatchBFS PriorityQIncMatch compare matching algorithms As shown Fig 63 AllDifferent FFBFS 30 faster slower HopcroftKarp Finally compare staged propagator PriorityQIncMatchBFSStaged PriorityQIncMatchBFS As shown Fig 64 staged propagation useful set benchmarks times improvement IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1991 Fig 61 Speedup PriorityQ Simple The graph scatterplot point comparing results single instance The xaxis represents run time Simple solve instance The yaxis gives speedup obtained PriorityQ instead Simple A ratio 1 indicates methods run speed ratios higher 1 indicating PriorityQ faster ratios 1 indicating Simple faster The ratio calculated dividing number search nodes explored second PriorityQ Simple In graph performance ranges slight slowdown PriorityQ QWH instances speedups hundreds times social golfers instances All subsequent graphs labelled Speedup X Y follow conventions case X PriorityQ Y Simple Fig 62 Speedup PriorityQIncMatch PriorityQ For experiments use constraint queue incremental matching standard tech niques veriﬁed useful context We use FFBFS algorithm experiments faster slower HopcroftKarp We use staged propagation considerably faster average Com paring PriorityQIncMatchBFSStaged Simple observe speedup 214 863 times mean average speedup 808 excluding contrived instance family 1992 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 Fig 63 Speedup PriorityQIncMatchBFS PriorityQIncMatch Fig 64 Speedup PriorityQIncMatchBFSStaged PriorityQIncMatchBFS 64 Experiment Dynamic triggers domain counting For purpose experiment variants use constraint queue incremental matching The aim compare waking domain events dynamic triggers domain counting Baseline The PriorityQIncMatchBFSStaged previous section DynamicTrigger Baseline addition dynamic triggers described Section 5 DynamicTriggerInternal Baseline addition internal dynamic triggers Section 54 DomainCount When constraint triggered variable queue present constraint queue domain D triggering variable counted The number values maintained default Minion If D r constraint added constraint queue Fig 65 shows ratio search nodes second DynamicTrigger Baseline Instances scattered 1 suggesting advantage DynamicTrigger negated overheads cases All contrived IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1993 Fig 65 Speedup DynamicTrigger Baseline Fig 66 Speedup DynamicTriggerInternal Baseline instances considerably faster DynamicTrigger expected Fig 66 shows plot DynamicTrig gerInternal Baseline DynamicTriggerInternal performs slightly better Baseline instances exploring 13 times nodes second average 6 improvement excluding contrived Surprisingly contrived instances exception slower DynamicTriggerInternal Baseline In DynamicTriggerInternal cost placing dynamic triggers lower written array However arrays backtracked block copying contrived instances arrays large Finally compare DomainCount Baseline The ratio search nodes second shown Fig 67 Domain counting cheap instances substantially slower substantially wins This sur prising domain counting originally intended set tuple variables large domains 20 The contrived instances behave expected instances d r 1 showing huge advantage domain counting instances d r showing advantage Our conclusions experiment internal dynamic triggers worthwhile average dynamic triggers great overhead domain counting work benchmark set 1994 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 65 Experiment Processing SCCs independently Fig 67 Speedup DomainCount Baseline The SCC optimization described Section 4 aims decrease time spent running graph algorithms It inde pendent domain counting However dependence dynamic triggers SCC optimization running Tarjans algorithm smaller graph potentially cause fewer triggers moved potentially ducing overhead dynamic triggers For experiments ignore domain counting consider dynamic triggers In addition Baseline SCCs processed independently described Section 4 Baseline The PriorityQIncMatchBFSStaged experiment SCC SCCAssignOpt SCCAssignOptDynamicTrigger SCCAssignOptDynamicTriggerInternal In addition SCCAssignOpt dynamic triggers In addition SCC assignment optimization described Section 42 In addition SCCAssignOpt internal dynamic triggers Fig 68 shows results comparing SCC Baseline The SCC variant able explore times search nodes second benchmarks SCC slower Baseline This expected additional cost SCC potential savings running graph algorithms smaller graphs large Comparing SCCAssignOpt SCC Fig 69 shows AssignOpt worthwhile mean improvement nodessecond 3 excluding contrived instances Social golfers sports scheduling problems solve slower AssignOpt These problems similar structure large AllDifferent constraint pairs vector This indicate AssignOpt scale large constraints In staged constraint work assignment optimization removing assigned value variables SCC redundant removed This improve AssignOpt little Fig 610 shows results comparing SCCAssignOptDynamicTrigger SCCAssignOpt Apart Social Golfers instances results promising dynamic triggers Many instances solve considerably slower dynamic triggers Internal dynamic triggers Fig 611 fare better cost moving triggers lower The sports scheduling instances solve faster internal dynamic triggers However average excluding contrived problem internal dynamic triggers lose 5 This contrast experiment SCC AssignOpt internal dynamic triggers gained 6 Exploiting SCCs assignment optimization reduced cost applying graph algorithms worthwhile apply internal dynamic triggers Since dynamic triggers context regard SCCAssignOpt strongest variant overall 66 Experiment Comparing pairwise propagator We compare pairwise propagator described Section 612 eﬃcient variant GAC AllDifferent Since propagators provide level consistency comparing node rates limited use IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1995 Fig 68 Speedup SCC Baseline Fig 69 Speedup SCCAssignOpt SCC overhead maintaining GAC showing beneﬁt Therefore compare solution times longer 7200 second time limit node limit The variant GAC AllDifferent use SCCAssignOpt experiment We refer Best pairwise propagator Pairwise Fig 612 shows plot solution times Pairwise xaxis ratio Pairwise Best yaxis Points line x 7200 represent instances timed Pairwise Two instances timed GAC Pairwise area x 1000 y 1 Clearly GAC reasoning AllDifferent constraint important instances In particular QWH diﬃcult Social Golfers instances solve faster GAC In cases solve 1000 times faster Pairwise Many authors example Stergiou Walsh 26 GAC AllDifferent important There large number instances caused GAC Pairwise time There instances GAC timed Pairwise completed Golomb ruler n 13 Langfords n 14 22 instances Pairwise timed GAC completed QWH class For instances GAC perform Pairwise However ignoring contrived instances Pairwise 234 times faster 1996 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 Fig 610 Speedup SCCAssignOptDynamicTrigger SCCAssignOpt Fig 611 Speedup SCCAssignOptDynamicTriggerInternal SCCAssignOpt GAC Interestingly holds easy diﬃcult instances increasing divergence instances diﬃcult Overall experiment shows adding GAC AllDifferent propagator substantially extends reach Minion solve challenging problem instances 67 Experimental conclusions We individually evaluated different eﬃciency measures GAC AllDifferent algorithm In section consider effect Fig 613 compares Best Simple Including contrived instances speedup 269 times 1813 times average 168 times Clearly Best huge improvement Simple shows importance taking care implement AllDifferent Simple include standard optimizations prioritized queueing incremental matching staging uses HopcroftKarp eﬃcient FFBFS perform matching Therefore Fig 614 compare Best Baseline The differences algorithms optimizations described Section 4 exploiting IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1997 Fig 612 Comparing Best Pairwise runtime In plot xaxis represents runtime Pairwise yaxis ratio Pairwise Best runtime The time limit set 7200 s node limit Fig 613 Speedup Best Simple SCCs All pathological contrived instances lie 096 706 times faster mean improvement 298 times6 Since ﬁgures solving instance improvement AllDifferent constraint greater Finally Fig 615 plot nodes explored second Best This idea speed algorithm different classes instances The Langfords instances fast exceeding 20000 nodes second cases remarkable maintaining GAC Social Golfers QWH slowest classes Social Golfers large AllDifferent constraints r 480 d 496 largest instance QWH large number instance 70 constraints r d 35 largest instances 6 Note mean ratios multiplicative BestSimple 168 BestBaseline 298 BaselineSimple 81 Geometric means retain multiplicative properties mean The geometric means BestSimple 3198 BestBaseline 244 BaselineSimple 1311 1998 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 Fig 614 Speedup Best Baseline Fig 615 Plot Best nodes second The xaxis represents Best runtime yaxis number nodes searched second 7 Implementation advice In section abstract details experimental results brief advice following implementing GAC AllDifferent researching optimizations Our results huge beneﬁt following optimizations order importance propagating AllDifferent separate queue constraints incremental exploitation strongly connected components combining GAC pairwise propagators staging There lesser important improvement 2030 incremental matching Our results optimizations signiﬁcant unlikely reversed different implementation choices study different instances optimizations remain effective combined We ﬁnd assignment optimization worthwhile effect small 3 omitted save programmer time undue penalty enduser Some results depend context GAC AllDifferent We ﬁnd dynamic triggers type worthwhile In experiments dynamic triggers slightly better implemented internally AllDifferent constraint approach portable We ﬁnd Lagerkvist Schultes variant IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 1999 Quimper Walshs domain counting beneﬁcial slight improvement All conclusions apply ignore family contrived instances maintaining GAC adds costs beneﬁt On instances dynamic triggers domain counting come internal dynamic triggers effective built Minion Therefore dynamic triggers domain counting considered GAC AllDifferent propagator ineffective ameliorate overheads case One question able come deﬁnite conclusion best matching algorithm GAC AllDifferent propagator We experimented simpler BFS algorithm complex HopcroftKarp algorithm We BFS signiﬁcantly better recommend HopcroftKarp However matching algorithms possible choice outperform algorithms tested As noted introduction tested propagators maintain bounds range consistency AllDifferent Therefore advise relative merits techniques compared maintaining GAC We delighted study evaluating optimizations algorithms similar lines paper enable fairest comparison optimized GAC implementation 8 Conclusions We presented extensive survey propagation methods establish generalised arc consistency GAC AllDifferent constraint Régins algorithm We surveyed optimizations proposed literature methods previously reported For methods reported implementation given empirical analysis behaviour We paid particular attention evaluating optimizations combination naturally usually feature papers propose optimizations Our experiments easily deepest experimental analysis GAC algorithms AllDifferent Based provided advice optimizations key generally useful We draw particular attention results processing strongly connected components search process We showed signiﬁcant improvements observation individual strongly connected components treated independently This paper gives ﬁrst detailed report empirical evaluation technique We showed lesser improvement maintaining strongly connected components treating assignment variable special case believe new optimization These techniques speed search instances containing AllDifferent average 3 times For best combination optimizations mean improvement 160 times runtime careful unoptimized implementation Régins algorithm Our results conﬁrm optimizations optional extras vital implementation GAC AllDifferent Our results GAC propagation widely Apart pathological examples GAC propagation AllDifferent slows search factor 234 compared highly optimized implementation pairwise AllDifferent propagator The combination optimizations studied careful implementation brings GAC propagation AllDifferent point practical instances beneﬁcial large number Acknowledgements We like thank Chris Jefferson technical help development Minion 9 helpful discussion Andrea Rendl use Tailor 12 Max Neunhöffer useful discussion data structures We thank reviewers Artiﬁcial Intelligence helpful comments Our work supported EPSRC EPE0303941 Ian Miguel supported UK Royal Academy EngineeringEPSRC Research Fellowship References 1 Abderrahamane Aggoun David Chan Pierre Dufresne Eamon Falvey Hugh Grant Warwick Harvey Alexander Herold Geoffrey Macartney Micha Meier David Miller Shyam Mudambi Stefano Novello Bruno Perez Emmanuel van Rossum Joachim Schimpf Kish Shen Periklis Andreas Tsahageas Dominique Henry Villeneuve Eclipse user manual release 510 2006 httpeclipseclporg cid4 2 H Alt N Blum K Mehlhorn M Paul Computing maximum cardinality matching bipartite graph time O n15 ing Letters 37 4 1991 237240 m log n Information Process 3 Claude Berge Graphs Hypergraphs NorthHolland Publishing Company 1973 4 Mats Carlsson Christian Schulte Finite domain constraint programming systems 2002 Available ftpftpsicssepubislpapersFD20Systemspdf 5 Simon Colton Ian Miguel Constraint generation automated theory formation Proceedings Seventh International Conference Principles Practice Constraint Programming 2001 pp 575579 6 Thomas H Cormen Charles E Leiserson Ronald L Rivest Introduction Algorithms MIT Press 1990 7 MarieChristine Costa Persistency maximum cardinality bipartite matchings Operations Research Letters 15 3 1994 143149 8 David Eppstein Implementation HopcroftKarp algorithm Python 2002 httpwwwicsuciedueppstein 9 Ian P Gent Chris Jefferson Ian Miguel Minion A fast scalable constraint solver Proceedings 17th European Conference Artiﬁcial Intelligence ECAI 2006 2006 pp 98102 10 Ian P Gent Chris Jefferson Ian Miguel Watched literals constraint propagation minion Proceedings 12th International Conference Principles Practice Constraint Programming CP 2006 2006 11 Ian P Gent Christopher Jefferson Ian Miguel Peter Nightingale Data structures generalised arc consistency extensional constraints Pro ceedings Twenty Second Conference Artiﬁcial Intelligence AAAI07 2007 pp 191197 2000 IP Gent et al Artiﬁcial Intelligence 172 2008 19732000 12 Ian P Gent Ian Miguel Andrea Rendl Tailoring solverindependent constraint models A case study essence minion Proceedings SARA 2007 pp 184199 13 Brahim Hnich Ian Miguel Ian P Gent Toby Walsh CSPLib A problem library constraints httpcspliborg 14 JE Hopcroft RM Karp An n25 algorithm maximum matchings bipartite graphs SIAM Journal Computing 2 4 1973 225231 15 ILOG Solver 60 User Manual ILOG SA 2003 16 Irit Katriel Expectedcase analysis delayed ﬁltering J Christopher Beck Barbara M Smith Eds CPAIOR Lecture Notes Computer Science vol 3990 Springer 2006 pp 119125 17 Henry A Kautz Yongshao Ruan Dimitris Achlioptas Carla P Gomes Bart Selman Mark E Stickel Balance ﬁltering structured satisﬁable prob lems Proceedings IJCAI2001 2001 pp 351358 18 DE Knuth A Raghunathan The problem compatible representatives SIAM Journal Discrete Mathematics 5 3 1992 422427 19 Mikael Z Lagerkvist Christian Schulte Advisors incremental propagation Proceedings 13th Principles Practice Constraint Programming CP 2007 2007 pp 409422 20 ClaudeGuy Quimper Toby Walsh The different global cardinality constraints set multiset tuple variables Recent Advances Constraints LNAI vol 3419 2006 21 JeanCharles Régin A ﬁltering algorithm constraints difference CSPs Proceedings 12th National Conference Artiﬁcial Intelligence AAAI 94 1994 pp 362367 22 Christian Schulte Peter J Stuckey Speeding constraint propagation Mark Wallace Ed Tenth International Conference Principles Practice Constraint Programming Toronto Canada Lecture Notes Computer Science vol 3258 SpringerVerlag September 2004 pp 619633 23 Christian Schulte Guido Tack Views iterators generic constraint implementations Recent Advances Constraints 2005 Lecture Notes Artiﬁcial Intelligence vol 3978 SpringerVerlag 2006 pp 118132 24 João C Setubal New experimental results bipartite matching Proceedings netﬂow93 Technical Report TR2193 Dipartamento Informatica Università di Pisa 1993 pp 211216 25 João C Setubal Sequential parallel experimental results bipartite matching algorithms Technical Report EC9609 Institute Computing University Campinas Brasil 1996 26 Kostas Stergiou Toby Walsh The difference alldifference makes Proceedings IJCAI99 1999 27 Robert Tarjan Depthﬁrst search linear graph algorithms SIAM Journal Computing 1 2 1972 146160 28 WillemJan van Hoeve The alldifferent constraint A survey Proceedings Sixth Annual Workshop ERCIM Working Group Constraints 2001 29 Mark Wallace Practical applications constraint programming Constraints 1 12 1996 139168