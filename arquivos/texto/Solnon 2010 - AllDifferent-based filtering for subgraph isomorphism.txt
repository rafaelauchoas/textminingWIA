Artiﬁcial Intelligence 174 2010 850864 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint AllDifferentbased ﬁltering subgraph isomorphism Christine Solnon Université Lyon Université Lyon 1 LIRIS UMR5205 CNRS F69622 France r t c l e n f o b s t r c t The subgraph isomorphism problem involves deciding exists copy pattern graph target graph This problem solved complete tree search combined ﬁltering techniques aim pruning branches contain solutions We introduce new ﬁltering algorithm based local different constraints We ﬁltering stronger existing ﬁlterings prunes branches eﬃcient allows solve instances quicker 2010 Elsevier BV All rights reserved Article history Received 24 December 2009 Received revised form 3 May 2010 Accepted 3 May 2010 Available online 6 May 2010 Keywords Subgraph isomorphism Constraint programming All different constraint 1 Introduction Graphs widely reallife applications represent structured objects example molecules images biological networks In applications looks copy pattern graph target graph 4 This problem known subgraph isomorphism NPcomplete general case 6 Subgraph isomorphism problems solved systematic exploration search space composed possible injective matchings set pattern nodes set target nodes starting matching incre mentally extends partial matching matching nonmatched pattern node nonmatched target node edges matched current matching search backtrack previous choice point extension pattern nodes matched solution To reduce search space exhaustive exploration combined ﬁltering techniques aim removing candidate couples nonmatched patterntarget nodes Different levels ﬁltering considered stronger remove nodes higher time complexities In paper compare existing ﬁltering algorithms subgraph isomorphism problem introduce new ﬁltering algorithm stronger We experimentally evaluate new ﬁltering algorithm wide benchmark instances eﬃcient instances 2 Deﬁnitions notations A graph G N E consists node set N edge set E N N edge u u The set neighbors node u denoted adju deﬁned adju u consider nondirected graphs u u Section 5 cid3 E u cid3 couple nodes cid3 E In paper implicitly cid3 u E The extension work directed graphs discussed cid3 u u A subgraph isomorphism problem pattern graph G p N p E p target graph Gt Nt Et consists deciding G p isomorphic subgraph Gt More precisely ﬁnd injective matching f N p Nt associates different target node pattern node preserves pattern edges Email address christinesolnonliriscnrsfr 00043702 matter 2010 Elsevier BV All rights reserved doi101016jartint201005002 C Solnon Artiﬁcial Intelligence 174 2010 850864 851 cid2 u u cid3 cid3 E p cid2 f u f cid3cid3 cid2 cid3 u Et The function f called subisomorphism function Note subgraph necessarily induced pattern nodes linked edge matched target nodes linked edge This problem called subgraph monomorphism subgraph matching literature In following assume G p N p E p Gt Nt Et underlying instance subgraph isomorphism nodes G p problem assume loss generality N p Nt We usually denote u u resp Gt resp v v We denote S cardinality set S We deﬁne N N p Nt E E p Et np N p nt Nt e p E p cid3 cid3 et Et dp dt maximal degrees graphs G p Gt 3 Filtering subgraph isomorphism Subgraph isomorphism problems modeled constraint satisfaction problems straightforward way In section ﬁrst model solve subgraph isomorphism problems constraint satisfaction framework Then different ﬁltering algorithms subgraph isomorphism Sections 33 36 compare Section 37 31 Modeling solving subgraph isomorphism means constraints A constraint satisfaction problem CSP deﬁned set variables variable associated domain set values assigned set constraints relations restrict set values assigned variables simultaneously Solving CSP involves ﬁnding assignment values variables constraints satisﬁed A subgraph isomorphism problem modeled CSP associating variable denoted xu pattern node u The domain variable xu denoted D u contains set target nodes matched u Intuitively assigning variable xu value v corresponds matching pattern node u target node v The domain D u usually reduced set target nodes degree higher equal degree u node u matched node v adju cid2 adjv Constraints ensure assignment variables values corresponds subisomorphism function There kinds constraints edge constraints ensure pattern edges preserved cid2 u u cid3 cid3 E p xu xucid3 Et difference constraints ensure assignment corresponds injective function cid2 u u cid3 cid3 N 2 p u cid11 u cid3 xu cid11 xucid3 Within framework solving subgraph isomorphism problem involves ﬁnding assignment variables sat isﬁes constraints We shall consider variable assigned domain reduced singleton D u v xu v Subgraph isomorphism problems modeled CSPs solved building search tree explores possible variable assignments ﬁnding solution The size search tree reduced ﬁltering techniques propagate constraints remove values domains We brieﬂy recall basic principles constraint propagation Section 32 Then different ﬁltering techniques solve subgraph isomorphism problems Sections 33 36 Note ﬁlterings FCDiff GACAllDiff FCEdges ACEdges generic constraint propagation techniques solve CSP LV2002 ILFk dedicated subgraph isomorphism problem 32 Recalls constraint propagation Constraint propagation aims ﬁltering variable domains removing inconsistent values values belong solution This constraint propagation step choice point search If removes values domain variable search backtrack previous choice A pioneering work constraint propagation 1972 Waltz scene drawing application 19 Since different constraint propagation algorithms proposed These algorithms achieve different partial consistencies different time space complexities In section aim describing existing propagation algorithms We brieﬂy basic wellknown generic techniques forwardchecking maintaining arcconsistency The reader refer 1710 information 852 C Solnon Artiﬁcial Intelligence 174 2010 850864 Forwardchecking The basic idea forwardchecking propagate constraints involving variable signment order remove domains nonassigned variables value consistent assignment More precisely assignment xi v propagates binary constraints xi non assigned variable x j removing domain x j value v j assignment xi v x j v j violates constraint holding xi x j When constraints arities greater propagate constraints variables assigned Maintaining arcconsistency A stronger ﬁltering expensive obtained maintaining arcconsistency called 2consistency Roughly speaking binary CSP arcconsistent value v domain variable xi support domain variable ensuring xi assigned v variable consistent value domain More precisely given variable xi X value v Dxi support xi v variable x j value v j Dx j partial assignment xi v x j v j consistent A binary CSP X D C arcconsistent value domain support domain variable To maintain arcconsistency constructing partial assignment A ﬁlter variable domains variable assignment removing nonsupported values Such ﬁltering repeated domain reduced soon value removed check value support values There exist different algorithms ensuring arcconsistency exhibit different time space complexities For instance widely algorithm achieving arc consistency set binary constraints AC4 14 time space complexities Ock2 c number constraints k maximum domain size Although AC4 worstcase optimal time reaches worst case expensive initialisation phase improvements proposed AC4 leading example AC6 AC7 AC2001 17 details Arc consistency generalized nonbinary CSPs In case called generalized arc consistency 33 Propagation difference constraints FCDiff GACAllDiff Difference constraints propagated forwardchecking denoted FCDiff time pattern node u matched target node v FCDiff removes v domains nonmatched nodes This Onp FCDiff propagates binary difference constraint separately A stronger ﬁltering obtained propagating set difference constraints order ensure pattern nodes assigned different target nodes More precisely achieving generalized arc consistency global AllDifferent constraint denoted GACAllDiff removes domain pattern node u target node v u matched v pattern nodes matched different target nodes In 16 Régin shown use matching algorithm Hopcroft Karp achieving GACallDiff The time complexity algorithm On2 p n2 t Example 1 Let consider variables x1 x2 x3 x4 D1 D2 D3 b c D4 b c d FCDiff removes domains x2 x3 x4 GACAllDiff removes domains x2 x3 x4 It removes b c domain x4 x4 assigned b c x2 assigned value different x3 x4 34 Propagation edge constraints FCEdges ACEdges Edge constraints propagated forward checking denoted FCEdges time pattern node u matched target node v FCEdges removes domain node adjacent u target node adjacent v This Odp nt One step maintain arc consistency edges constraints denoted ACEdges cid2 u u cid3 cid3 E p v D u v cid3 D ucid3 cid2 v v cid3 cid3 Et As CSP modeling subgraph isomorphism problem e p edge constraints maximum domain size nt time complexity ACEdges Oe p n2 t AC4 Example 2 Let consider subgraph isomorphism problem displayed Fig 1 Note instance solution G p mapped subgraph Gt Let suppose node 3 matched node E D3 E E removed domains pattern nodes FCDiff GACAllDiff FCEdges removes B C F domains nodes 1 2 4 B C F adjacent E 1 2 4 adjacent 3 Like FCEdges ACEdges removes B C F domains nodes 1 2 4 It able remove G domain 1 matching 1 G support edge 1 4 Indeed adjacent nodes G B F E belongs domain 4 For reasons ACEdges removes G domains 2 4 C Solnon Artiﬁcial Intelligence 174 2010 850864 853 35 Propagation set edge constraints LV2002 Fig 1 Instance subgraph isomorphism problem Both FCEdges ACEdges propagate edge constraint separately A stronger ﬁltering obtained propagating edge constraints global way propagating fact set nodes adjacent given node Indeed pattern node u matched target node v number nodes adjacent u smaller equal number target nodes adjacent v belong domains nodes adjacent u nodes adjacent u matched nodes adjacent v Hence Larrosa Valiente proposed 12 ﬁltering algorithm denoted LV2002 propagates constraint More precisely deﬁne set Fu v cid4 cid2 cid3 D ucid3 adjv ucid3adju F u v superset set nodes matched nodes adjacent u u matched v Therefore remove v D u F u v adju One remove v D u cid3 adju D ucid3 adjv enforcing arc consistency edge constraints The LV2002 exists pattern node u ﬁltering algorithm time complexity On2 p n2 t Example 3 Let consider subgraph isomorphism problem displayed Fig 1 Let suppose node 3 matched node E D3 E E removed domains pattern nodes FCDiff GACAllDiff Like ACEdges LV2002 removes nodes B C F G domains nodes 1 2 4 It able remove values A D domain 1 Indeed F1 A D2 D3 D4 adj A D E F1 D D2 D3 D4 adjD A E As F 1 A adj1 F 1 D adj1 A D removed D1 domain 1 inconsistency detected 36 Iterated labeling ﬁltering ILFk Zampelli et al proposed 20 ﬁltering algorithm called ILFk exploits graph structure global way compute labels associated nodes ﬁlter domains More precisely compatibility relationship deﬁned set node labels This compatibility relationship remove domain pattern node u target node v label u compatible label v ILFk iterative procedure starts initial labeling This initial labeling deﬁned node degrees In case compatibility relationship classical cid2 order This labeling remove domain pattern node u target node v adju cid2 adjv u matched v u adjacent nodes v This initial labeling extended ﬁlter values Given labeling l compatibility relationship cid3 cid3u node u multiset contains labels cid3v occurrence x label cid3v x cid3 y The key point relies computation dt thanks matching algorithm Hopcroft labels l deﬁnes new labeling l nodes adjacent u The compatibility relationship cid3cid3 cid3u exists different occurrence y label l l new compatibility relationship cid3cid3 Karp 20 details cid3u cid3cid3 l Onp nt dp dt new label l l cid3 Such labeling extensions iterated A parameter k introduced determines number labeling extensions Note iterated labeling extensions stopped reaching bound k domain reduced 854 C Solnon Artiﬁcial Intelligence 174 2010 850864 set ﬁxpoint reached value ﬁltered The ILFk procedure time complexity Omink np nt np nt dp dt dt 20 introduces weaker ﬁltering called ILFk The idea approximate iteration label compati bility relationship total order compatibility relation computed sorting multisets sequentially comparing The time complexity weaker ﬁltering Omink np nt np nt dt Example 4 Let consider subgraph isomorphism problem displayed Fig 1 The initial degreebased labeling labeling l l5 l6 2 l1 l3 lC lE lF lG 3 l2 l4 l A lB lD 4 order set labels 2 compatible 2 3 4 3 compatible 3 4 4 compatible 4 Hence remove target nodes C E F G domains pattern nodes 2 4 cid3 The extension initial degreebased labeling labeling l l l l l l l l cid3F 3 4 4 cid3E l cid33 l cid34 2 2 3 3 cid36 4 4 cid31 l cid32 l cid35 l cid3 A 3 3 4 4 cid3B l cid3C 4 4 4 cid3G 3 3 4 cid3D 3 3 3 4 order set labels 3 4 4 compatible 3 3 4 4 3 4 4 2 2 3 3 compatible 3 3 4 4 3 3 3 4 4 4 compatible 3 3 4 4 4 4 4 3 4 4 cid3B B removed D1 For reasons B D G removed extended removing values ﬁnally proving inconsistency cid31 compatible l As l domains nodes 1 3 5 6 cid3 This new labeling l instance 37 Discussion Most algorithms proposed solving subgraph isomorphism problem described means ﬁltering algorithms described Sections 33 36 In particular McGregor 13 combines FCDiff FCEdges Ullmann 18 combines FCDiff ACEdges Régin 15 combines GACAllDiff ACEdges Larrosa Valiente 12 combine GACAllDiff LV2002 Zampelli et al combine GACAllDiff ACEdges ILFk These different ﬁlterings achieve different consistencies Some stronger In particular GACAllDiff stronger FCDiff LV2002 stronger ACEdges stronger FCEdges However GACAllDiff FCDiff comparable FCEdges ACEdges LV2002 ILFk propagate constraints The relations ILFk ﬁlterings propagate edge constraints LV2002 ACEdges FCEdges depend initial domains initial domain variable contains target nodes ILFk stronger C Solnon Artiﬁcial Intelligence 174 2010 850864 855 LV2002 provided number labeling extensions k greater equal 21 However domains reduced usually case ﬁltering node root search tree ILFk comparable LV2002 ACEdges Indeed ILFk exploit domains ﬁlter values labelings compatibility relationships iteratively computed depend domains To allow ILFk propagate domain reductions iterative labeling extension process combined labeling extension following steps Reduction target graph respect domains target node v belong domain node incident edges discarded target graph Strengthening labeling respect singleton domains domain D u reduced singleton v nodes u v labeled new label compatible label preventing pattern nodes matched v When adding steps ILFk stronger FCEdges However comparable LV2002 ACEdges To propagate domain reductions start iterative labeling extension process initial labeling fully integrates domain reductions compatibility relation target node v belong domain pattern node u label associated v compatible label associated u More formally Zampelli et al deﬁned 20 initial labeling denoted ldom follows different unique label lx associated different pattern target node x N p Nt u v N p Nt lu compatible lv iff v D u adju cid2 adjv They shown case ILFk stronger LV2002 provided k cid4 2 However ﬁltering stronger expensive achieve complexity ILFk highly depends number different labels Indeed theoretical complexity iteration ILFk Onp nt dp dt dt corresponds worst case nodes different labels If number different pattern target labels respectively l p lt complexity iteration ILFk Oe p l p lt dp dt dt 4 Global neighborhood constraints LADﬁltering We introduce global neighborhood constraint Section 41 propagation algorithm achieves generalized arc consistency constraint Section 42 We compare consistency partial consistencies Section 43 41 Global neighborhood constraints For subisomorphism function f N p Nt pattern node u N p 1 u 2 u cid3 adju f u cid3 u cid3 adj f u cid3cid3 adju adju u cid3 cid11 u cid3cid3 f u cid3 cid11 f u cid3cid3 The ﬁrst property direct consequence fact edges preserved subisomorphism functions second property direct consequence fact subisomorphism functions injections When considering CSP associated subgraph isomorphism problem properties expressed following constraint neighborhood u xu v u cid3 adju cid2cid5 allDiff xucid3 xucid3 adjv cid6 cid7cid3 cid6 u cid3 adju Note ﬁltering algorithm LV2002 introduced Larrosa Valiente 12 actually propagates neighborhood constraint explicitly introduced 12 However LV2002 ensures partial consistency basically ensures number nodes adjacent u smaller equal number target nodes adjacent v belong domains nodes adjacent u In Section 42 ﬁltering algorithm ensures generalized arc consistency neighborhood constraints 1 k greater equal 2 initial labeling iterative labeling extension process started labeling associates label nodes If initial labeling deﬁned node degrees iteration obtain stronger consistency 20 details 856 C Solnon Artiﬁcial Intelligence 174 2010 850864 Fig 2 Bipartite graphs associated 1 G 3 E Example 5 Let consider subgraph isomorphism problem displayed Fig 1 let deﬁne initial domains respect node degrees D1 D3 D5 D6 A B C D E F G D2 D4 A B D The neighborhood constraint couple nodes 1 G x1 G x2 B F E x3 B F E x4 B F E x2 x3 x4 allDiff cid2 cid3 Achieving generalized arc consistency constraint allows remove G D1 x1 G x2 x4 belong singleton B corresponding intersection domains B F E x2 x4 assigned different values Note example ﬁltering LV2002 remove G D1 F 1 G D2 D3 D4 adjG B E F F 1 G cid4 adj1 Note simple allDiff constraint set variables x2 x3 x4 remove G D1 combine allDiff constraint fact 1 matched G 2 3 4 matched nodes adjacent G 42 A ﬁltering algorithm propagating global neighborhood constraints The generalized arc consistency neighborhood constraint ensured looking covering matching bipartite graph proposed Régin 16 AllDifferent global constraint Let recall matching graph G N E subset edges m E edges m share endpoint A matching m E covers set nodes Ni node Ni endpoint edge m In case shall m Ni covering matching G For couple nodes u v v D u deﬁne bipartite graph associates node node cid3 v adjacent u v edge couple u cid3 v cid3 D ucid3 Deﬁnition 1 Given nodes u v N p Nt v D u deﬁne bipartite graph Guv Nuv Euv Nuv adju adjv Euv u cid3 v cid3 adju adjv v cid3 D ucid3 If exist matching bipartite graph Guv covers adju nodes adjacent u matched different nodes v removed D u This ﬁltering iterated Indeed v removed D u edge u v removed bipartite graphs bipartite graphs longer covering matchings A key point incremental implementa cid3 adju tion ﬁltering lies fact edge u v belongs bipartite graphs Gucid3vcid3 u cid3 Filtering iterated domain detecting inconsistency reach cid3 adjv Du v ing ﬁxpoint generalized arc consistency enforced couple u v exists adjucovering matching Guv Example 6 The bipartite graph G1G propagate neighborhood constraint Example 5 displayed left Fig 2 There exist matching graph covers adj1 2 4 matched B As consequence remove G D1 The bipartite graph G3E propagate neighborhood constraint associated couple 3 E displayed right Fig 2 There exists matching graph covers adj3 m 1 G 2 A 4 D E C Solnon Artiﬁcial Intelligence 174 2010 850864 857 Algorithm 1 LADﬁltering Input A set S couples patterntarget nodes ﬁltered Output failure inconsistency detected success In case success domains ﬁltered u N p v D u exists matching Guv covers adju begin S cid11 Remove couple patterntarget nodes u v S exist matching Guv covers adju Remove v D u D u return failure cid3 adju v cid3 v S S u cid3 u cid3 adjv D ucid3 end end return success end removed D3 However G removed D1 edge 1 G removed G3E longer exists matching covers adj3 1 2 3 matched A D Hence E removed D3 Algorithm 1 describes resulting ﬁltering procedure called LAD Local All Different ﬁltering This procedure takes input set S couples patterntarget nodes ﬁltered At root search tree set contain couples patterntarget nodes S u v u N p v D u Then choice point search tree S initialized set couples u v v D u node adjacent v removed domain node adjacent u LADﬁltering cid3 For couple nodes u v belongs set S LADﬁltering checks exists matching Guv adjacent u covers adju If case v removed D u couples u v adjacent v belongs D ucid3 added S The key point eﬃciently implement procedure checks exists covering matching Guv Régin shown 16 use algorithm Hopcroft Karp 7 ﬁnd matching The time complexity algorithm Oa b b respectively number edges nodes bipartite graph As bipartite graph Guv adju adjv nodes worst case domain reduced adju adjv edges dt cid4 dp subgraph isomorphism problem instance trivially inconsistent complexity checking exists covering matching Guv Odp dt cid3 u dt cid3 v cid3 cid8 This complexity improved exploiting fact algorithm Hopcroft Karp incremental starting matching iteratively computes new matchings contain edges previous matching matching maximal Each iteration basically consists breadth ﬁrst search Od p dt number iterations bounded 2 dt dp However starts algorithm matching contains k edges maximal matching l edges number iterations bounded l k size matching increases iteration We use property improve time complexity LADﬁltering More precisely pattern node u N p target node v D u memorize computed matching Guv The space complexity memorizing covering matchings bipartite graphs Onp nt dp np nt bipartite graphs covering matching Guv composed adju edges As expensive time memory create copy covering matchings choice point simply update covering matchings necessary More precisely time need check exists covering matching bipartite graph Guv proceed follows 1 scan recorded matching adju remove couple u 2 couples removed Hopcroft Karp complete 3 Hopcroft Karp actually succeeds completing record computed complete matching cid3 v cid3 v cid3 longer belongs Du cid3 Theorem 1 The time complexity LADﬁltering Onp nt d2 p d2 t Proof The complexity computing ﬁrst covering matching bipartite graphs Onp nt dp dt dt step performed beginning search process Each time value v removed domain D u update matchings bipartite graphs Gucid3vcid3 cid3 D ucid3 adjv dp dt bipartite graphs worst case update In worst case value removed updating covering matchings neighbors cid3 adju v u incrementally Odp dt np nt values remove cid2 858 C Solnon Artiﬁcial Intelligence 174 2010 850864 43 Comparison LADﬁltering ﬁlterings In section compare consistency ensured LADﬁltering partial consistencies Theorem 2 LADﬁltering Algorithm 1 S initialized couples u v u N p v D u ensures Generalized Arc Consistency neighborhood constraints denoted GACNeighborhood Proof If exists pattern node u N p target node v D u possible assign cid3 adju different target node adjacent v belongs D ucid3 LADﬁltering different pattern node u removes value v D u bipartite graph Guv adjucovering matching returns failure Otherwise returns success ﬁlters domains pattern node u N p target node v D u cid3 adju assigned different target node adjacent v belongs different pattern node u D ucid3 bipartite graph Guv adjucovering matching cid2 Theorem 3 GACNeighborhood stronger LV2002 Proof GACNeighborhood strong LV2002 pattern node u N p target node v D u exists adjucovering matching Guv target nodes covering matching belong set F u v F u v cid4 adju It actually strictly stronger example able detect inconsistency instance displayed Fig 1 LV2002 able reduce domains variables associated nodes 2 4 A B D domains variables reduced cid2 Theorem 4 GACNeighborhood strong ILFk labeling extensions started initial labeling ldom iterated reaching ﬁxpoint k Proof The initial labeling ldom associates unique different label node label pattern node u com patible label target node v iff adju cid2 adjv v D u With initial compatibility relationship multiset mu contains labels nodes adjacent u compatible multiset mv contains labels nodes adjacent v iff exists covering matching Guv label mu compatible label mv iff edge corresponding nodes Guv When node v removed domain D u ILF LAD check couple u matched different node adjacent v In cases iterative process ﬁxpoint reached The difference ILF LAD ILF recomputes matchings possible patterntarget couples iteration LAD updates matchings actually impacted domain reductions Hence LAD lower time complexity cid2 cid3 adju adjv D ucid3 node adjacent u cid3 v cid3 cid3 Actually ILFk performs poorly started initial labeling ldom It performs better started initial labeling deﬁned respect node degrees initial labeling number different labels usually strongly reduced number compatibility relationships compute strongly reduced Theorem 5 GACNeighborhood weaker Singleton Arc Consistency Edge AllDifferent constraints denoted SACEdges AllDiff Proof Let ﬁrst recall singleton arc consistency ensures enforce arc consistency failure assignment value variable 1 Hence SACEdges AllDiff ensures u N p v D u D u reduced singleton v ACEdges combined GACAllDiff detect inconsistency SACEdges AllDiff strong GACNeighborhood reducing domain D u singleton v ACEdges combined GACAllDiff detect inconsistency exists adjucovering matching bipartite graph Guv Indeed ACEdges reduce domains nodes adjacent u nodes adjacent v GACAllDiff ensure nodes adjacent u assigned different values SACEdges AllDiff actually stronger GACNeighborhood able detect inconsistency subgraph isomorphism problem instance displayed Fig 3 GACNeighborhood reduce domain cid2 However optimal worstcase time complexity enforcing singleton arc consistency binary CSP Ond3e e number constraints n number variables d domain size 1 For subgraph isomorphism CSP consider binary edge constraints n np d nt e e p enforcing SACEdges Onp n3 e p Let consider case ﬁxeddegree graphs e p np dp2 In case time t C Solnon Artiﬁcial Intelligence 174 2010 850864 859 Fig 3 Instance subgraph isomorphism problem Let suppose initial domains D1 D 2 D 3 A B C D GACNeighborhood reduce domain bipartite graph Guv adjucovering matching bipartite graph G1a displayed right ﬁgure However SACEdges AllDiff detects inconsistency D1 reduced A ACEdges reduces D2 D 3 nodes adjacent A C B edge 3 2 longer supported Gt edge C B ACEdges detects inconsistency Algorithm 2 LADﬁltering directed graphs Input A set S triples u v x x pred succ Output failure inconsistency detected success In case success domains ﬁltered u N p v D u exist matching G pred covers succu uv covers predu matching G succ uv begin S cid11 Remove triple u v x S exist matching G x Remove v D u D u return failure cid3 v S S u cid3 succ u uv covers xu cid3 succu v cid3 succv D ucid3 u cid3 v cid3 pred u cid3 predu v cid3 predv D ucid3 end end return success end complexity enforcing SACEdges On2 dp compared time complexity LADﬁltering p Onp nt d2 t In worst case G p Gt complete graphs dp np 1 dt nt 1 enforcing p SACEdges LADﬁltering time complexity However sparser graphs LADﬁltering lower time complexity n3 t d2 5 Extension directed graphs LADﬁltering extended directed graphs straightforward way In directed graphs edges ordered couples nodes node u distinguishes set successor nodes succu reached cid3 E set predecessor nodes predu reached outgoing edge succu u ingoing edge predu u cid3 N u u cid3 N u cid3 u E To extend LADﬁltering directed graphs associate bipartite graphs couple u v u N p v D u bipartite graph check successor u matched different successor v G succ uv u bipartite graph check predecessor u matched different predecessor v succu succv E succ uv uv N succ uv cid3 succu succv v uv E succ cid3 D ucid3 N succ cid3 v G pred uv N pred uv E pred uv N pred uv predu predv E pred uv u cid3 v cid3 predu predv v cid3 D ucid3 Algorithm 2 extends Algorithm 1 directed graphs The main difference maintains set triples u v x x pred succ instead set couples u v At iteration triple u v x removed set graph G x uv covering matching v removed D u S updated adding triples cid3 x cid3 edge removed bipartite graph G x cid3 v u cid3 ucid3vcid3 6 Experimental results 61 Test suite We consider 1993 subgraph isomorphism instances come different databases Scalefree database classes sfdDn sidDn This database 20 evaluate ILFk Graphs instances scalefree networks randomly generated power law distribution degrees P d k λ λ 25 20 details There 5 classes Each ﬁrst classes denoted sfdDn contains k 20 feasible instances target graph n nodes degrees bounded d D pattern graph extracted target graph randomly selecting 90 nodes edges target graph 860 C Solnon Artiﬁcial Intelligence 174 2010 850864 way pattern graph connected The ﬁfth class denoted sidDn contains 20 nonfeasible instances generated like instances ﬁrst classes excepted 10 new edges added pattern graphs order obtain infeasible instances GraphBase database class LV This database 12 evaluate LV2002 It contains 113 undirected graphs different properties simple acyclic connected biconnected triconnected bipartite planar We considered 50 ﬁrst graphs This set contains graphs ranging 10 128 nodes Using graphs generated 793 instances subgraph isomorphism problem considering couples graphs G p Gt trivially solved e p 0 np cid2 nt dp cid2 dt Vﬂib database classes bvgn bvgmn m4Dn m4Drn rdn This database 2 evaluate Vﬂib program dedicated graph subgraph isomorphism problems It contains 63 classes instances class contains instances target graph 20 1000 nodes For class considered 4 sizes size considered ﬁrst 10 instances We grouped classes follows 5 details original classes bvgn n 100 200 400 800 corresponds number nodes target graphs These classes contain ﬁxedvalence graphs composed ﬁrst 10 instances original classes sixb y n x 2 4 6 corresponds size pattern graph respect target graph 20 40 60 y 3 6 9 corresponds valence Hence class bvgn contains 90 instances bvgmn n 100 200 400 800 corresponds number nodes target graphs These classes contain modiﬁed boundedvalence graphs composed ﬁrst 10 instances original classes sixb y mn x 2 4 6 corresponds size pattern graph respect target graph 20 40 60 y 3 6 9 corresponds valence Hence class bvgmn contains 90 instances m4Dn n 81 256 526 1296 corresponds number nodes target graphs These classes contain graphs correspond 4D regular meshes composed ﬁrst 10 instances original classes sixm4Dn x 2 4 6 corresponds size pattern graph respect target graph 20 40 60 Hence class m4Dn contains 30 instances m4Drn n 81 256 526 1296 corresponds number nodes target graphs These classes contain graphs correspond 4D irregular meshes composed ﬁrst 10 instances original classes sixm4Drr n x 2 4 6 corresponds size pattern graph respect target graph 20 40 60 r 2 4 6 corresponds degree irregularity Hence class m4Drn contains 90 instances rpn n 100 200 400 600 corresponds number nodes p 001 005 01 corresponds probability adding edge nodes These classes contain graphs randomly generated composed ﬁrst 10 instances original classes sixrandrp n x 2 4 6 corresponds size pattern graph respect target graph 20 40 60 Hence class rpn contains 30 instances 62 Considered solvers LAD LADﬁltering implemented C integrated complete tree search At node search tree pattern node assigned chosen respect minDom heuristic choose nonassigned pattern node smallest number target nodes domain A choice point created target node belongs domain variable assigned different choice points explored increasing order values At node search tree LADﬁltering combined GACAllDiff This search procedure called LAD LAD compared ILFk k 1 2 4 AbsconGAC AbsconFC Vﬂib ILFk The original implementation ILFk Gecode We consider new implementation C uses data structures ordering heuristics LAD combined GACAllDiff This new implementation eﬃcient original For example instances class sf581000 solved 019 seconds new implementation ILF1 solved 112 seconds old implementation We compare results obtained different numbers labeling extension iterations k 1 2 4 We report results k 4 improves solution process Abscon Abscon generic CSP solver written Java Lecoutre Tabary 11 details The fact Abscon implemented Java approaches implemented C C taken account Java programs running times time larger CC counterparts We consider variants solver AbsconFC performs forward checking propagation constraints FCEdges FCDiff C Solnon Artiﬁcial Intelligence 174 2010 850864 861 Table 1 Finding solutions class ﬁrst line gives number solved instances hour 226 GHz Intel Xeon E5520 second line gives CPU time average completed runs Class Vﬂib sf58200 sf58600 sf581000 sf20300300 si20300300 bvg100 bvgm100 m4D81 m4Dr81 r001100 r005100 r01100 All instances 16 7245 0 0 0 0 90 002 89 655 30 009 90 165 21 8360 2 51301 0 338 1383 Abscon FC 20 204 20 13810 20 165111 16 38687 6 82320 90 199 89 1106 30 108 90 370 23 12198 22 2860 25 6491 451 11872 AC 20 175 20 13501 20 163188 16 47411 5 104691 90 278 90 1657 30 104 90 240 28 32267 23 5678 28 21838 460 14486 ILF k 1 20 000 20 007 20 019 20 035 20 13233 90 004 90 048 30 003 90 018 29 15835 23 13581 28 21717 480 3441 k 2 k 4 20 002 20 015 20 055 20 595 19 3042 90 007 90 049 30 005 90 019 29 17063 22 10718 28 24200 478 3109 20 003 20 015 20 059 20 824 19 4875 90 013 90 048 30 005 90 020 29 17053 22 10899 28 24312 478 3207 LAD 20 002 20 029 20 083 20 256 20 2777 90 075 90 053 30 002 90 018 29 18024 23 1973 29 14838 481 2234 AbsconAC maintains Arc Consistency edge constraints For difference constraints maintains consistency stronger ACDiff weaker GACAllDiff It uses symmetry breaking techniques Both variants consider minDom ordering heuristic choosing variable assign Vﬂib Vﬂib 23 solver dedicated graph subgraph isomorphism problems considered stateofthe art subgraph isomorphism It basically performs forward checking propagation edge difference constraints propagation limited nodes adjacent matched nodes difference constraints It uses speciﬁc variable value ordering heuristics variable values chosen subgraph induced matched nodes connected pattern target graphs composed different connected components 63 Experimental comparison problem ﬁnding solutions Let ﬁrst consider problem ﬁnding solutions instance allowing comparison dependent value ordering heuristics For ﬁrst experiment discarded instances solutions Hence considered classes scalefree database smallest classes vﬂib database target graph 100 81 nodes Table 1 displays class considered approach number instances solutions hour 226 GHz Intel Xeon E5520 average corresponding CPU time On classes LAD solved 1 resp 3 3 23 29 143 instances ILF1 resp ILF2 ILF4 AbsconAC AbsconFC Vﬂib When comparing CPU times note LAD slower variants ILF classes sf58 bvg instances easy ones LAD solves second However harder classes si20300300 r005100 r01100 LAD signiﬁcantly quicker ILF On classes LAD ILF order quicker Abscon Vﬂib competitive classes bvg100 m4D81 m4Dr81 competitive classes Table 2 displays average number fail nodes number times inconsistency detected class approach Vﬂib information available Vﬂib On classes sf58 LAD ILF comparable numbers failed nodes corresponds classes quickly solved ILF LAD However instances r100 LAD explores fewer nodes ILF The number fail 862 C Solnon Artiﬁcial Intelligence 174 2010 850864 Table 2 Number fail nodes average completed runs numbers brackets class names average number solutions instances class Class solutions sf58200 110 sf58600 100 sf581000 105 sf20300300 445 si20300300 000 bvg100 218 bvgm100 145855 m4D81 1253 m4Dr81 30642 r001100 57291325 r005100 6062230 r01100 30501838 Abscon FC 3076 418 557 397844 913730 10037 8977 1904 22920 38853 233044 819714 AC 108 418 557 29338 61191 2862 95618 327 23592 6749220 615882 1985225 ILF k 1 5 4 7 38 15342 461 641 701 1356 10621 2857279 2227792 k 2 0 0 0 13 62 391 379 669 1304 6717 539522 2224579 k 4 0 0 0 7 22 391 222 652 1300 6175 539167 2224408 LAD 0 0 0 0 27 0 1 23 12 60 5243 320067 Table 3 Finding ﬁrst solution instances LV class solved number solved instances hour 226 GHz Intel Xeon E5520 Time fail respectively CPU time number fail nodes average completed runs Vﬂib 468 7372 Abscon FC 647 7251 1202372 AC 662 5425 324075 ILF k 1 698 3085 297107 solved Time fail k 2 699 3112 182588 k 4 699 3077 159493 LAD 728 1457 13560 nodes ILF LAD order smaller Abscon On classes AbsconAC fail nodes AbsconFC corresponds fact AbsconAC solves instances AbsconFC harder instances number fail nodes signiﬁcantly higher instances solved approaches 64 Experimental comparison problem ﬁnding ﬁrst solution To illustrate scaleup properties different approaches compare larger set instances consider problem ﬁnding ﬁrst solution proving inconsistency For comparison consider instances LV class larger classes vﬂib database target graph 100 nodes Table 3 displays number solved instances LV class contains 793 instances different features graphs different properties sizes instances feasible solutions inconsistent For class LAD solved 29 resp 29 30 66 81 260 instances ILF4 resp ILF2 ILF1 AbsconAC AbsconFC Vﬂib This table shows AbsconAC ILF1 comparable number fail nodes nearly times AbsconFC ILF2 ILF4 smaller number fail nodes reduction search space allow ILF2 ILF4 competitive The number fail nodes LAD smaller 20 times small AbsconAC ILF1 Tables 4 5 allow compare scaleup properties different considered approaches Table 4 displays results easy classes Vﬂib database LAD able solve 900 instances classes 15 seconds average nearly 4 times fast ILFk It signiﬁcantly faster Abscon Interestingly Vﬂib eﬃcient exhibits good scaleup properties classes bvg bvgm m4Dr Actually Vﬂib uses variable value ordering heuristics approaches iteration chooses couple u v nodes match u v adjacent nodes matched possible These ordering heuristics explain good behavior Vﬂib instances goal ﬁnd solution It explain fact able solve 29 instances m4D256 class 001 second able solve instance class hour However Table 5 shows different approaches exhibit different scaleup properties random classes rpn Indeed probability p adding edge 001 LAD better Abscon better ILF probability increases Abscon better ILF better LAD Actually denser larger graphs worse LAD This come fact complexity LADﬁltering Onp nt d2 t degree p 10 times bigger average graphs classes r01 classes r001 Therefore graphs sparse worth ﬁltering LAD graphs denser better consider simpler ﬁltering procedure ACEdges d2 C Solnon Artiﬁcial Intelligence 174 2010 850864 863 Table 4 Finding ﬁrst solution easy instances vﬂib base class ﬁrst line displays number solved instances hour 226 GHz Intel Xeon E5520 second line CPU time average completed runs Class bvg200 bvg400 bvg800 bvgm200 bvgm400 bvgm800 m4D256 m4D526 m4D1296 m4Dr256 m4Dr526 m4Dr1296 All instances Vﬂib 90 000 90 000 90 002 90 000 90 001 90 003 29 000 23 411 20 005 90 000 90 001 90 006 882 012 Abscon FC 90 068 90 285 90 5413 90 095 89 320 90 1202 30 288 30 15976 23 25273 90 791 89 2347 89 19327 890 4195 AC 90 078 90 299 90 5486 90 073 89 166 90 1207 30 173 30 16490 23 24247 90 144 89 2335 89 18844 890 4060 ILF k 1 90 000 90 001 90 003 90 000 90 155 90 006 30 001 29 961 29 5293 90 023 89 1402 90 641 897 425 k 2 k 4 90 000 90 001 90 004 90 000 90 001 90 004 30 001 30 3293 29 6121 90 105 89 1831 90 546 898 555 90 000 90 001 90 005 90 000 90 001 90 003 30 001 29 3072 29 7333 90 224 89 1908 90 543 897 604 LAD 90 014 90 106 90 841 90 001 90 004 90 019 30 004 30 171 30 567 90 006 90 033 90 163 900 143 Table 5 Finding ﬁrst solution hard instances Vﬂib base class ﬁrst line displays number solved instances hour 226 GHz Intel Xeon E5520 second line CPU time average completed runs Class Vﬂib r001200 r001400 r001600 r005200 r005400 r005600 r01200 r01400 r01600 3 173593 0 0 0 0 0 0 0 0 All instances 3 173593 Abscon FC 28 19214 20 3314 23 22638 25 26677 22 63284 14 191565 27 14336 6 176463 0 165 44314 AC 30 099 29 6968 23 23614 28 14280 24 64748 14 193698 29 30954 6 197218 0 183 40955 ILF k 1 28 2748 14 17583 12 42814 28 12557 25 51904 13 150551 26 32052 5 195067 0 151 41403 k 2 28 4409 14 22878 9 106996 28 19868 25 50054 5 231968 26 35770 5 191768 0 140 44736 k 4 28 4649 14 21485 7 80696 28 19866 25 49412 5 230485 26 35110 5 207081 0 138 42667 LAD 30 004 30 4558 29 11351 30 3828 17 119088 1 210061 21 64631 1 96135 0 159 26848 864 C Solnon Artiﬁcial Intelligence 174 2010 850864 7 Conclusion We introduced new ﬁltering algorithm subgraph isomorphism basically ensures nodes adjacent pattern node matched nodes different adjacent target node This ﬁltering stronger LV2002 Actually achieves consistency strongest variant ILFk initial labeling fully integrates domain reductions labeling extensions iterated reaching ﬁxpoint However consistency achieved lower cost updating matchings incrementally instead recomputing scratch iteration updating matchings impacted domain reduction instead recomputing matchings We experimentally shown wide benchmark 2000 instances new ﬁltering able solve instances quicker drastically reduces search space instances solved backtracking However ﬁltering outperformed arc consistency densest random graphs edge density greater equal 10 This ﬁltering procedure easily integrated constraint programming language In particular plan integrate constraintbased graph matching 9 built Comet 8 We plan improve LADﬁltering studying different strategies choosing iteration couple u v removed S In results reported paper considered basic ﬁrst strategy S implemented stack However use priority queue orders couples respect number edges removed corresponding bipartite graph Further work concern extension ﬁltering procedure maximum common subgraph problem involves ﬁnding largest graph subisomorphic given graphs Indeed algorithm Hopcroft Karp compute maximal matching bipartite graphs Guv giving bound largest number edges matched u matched v Acknowledgements Many thanks Yves Deville enriching discussions JeanChristophe Luquet having implemented ﬁrst version ILF Christophe Lecoutre guiding use Abscon anonymous reviewers valuable remarks helped improving paper This work context project Sattic Anr grant Blanc071_184534 References 1 Christian Bessiere Romuald Debruyne Theoretical analysis singleton arc consistency extensions Artif Intell 172 1 2008 2941 2 LP Cordella P Foggia C Sansone M Vento Performance evaluation vf graph matching algorithm ICIAP 99 Proceedings 10th International Conference Image Analysis Processing IEEE Computer Society Washington DC USA 1999 p 1172 3 Luigi Pietro Cordella Pasquale Foggia Carlo Sansone Mario Vento An improved algorithm matching large graphs 3rd IAPRTC15 Workshop Graphbased Representations Pattern Recognition 2001 pp 149159 4 Donatello Conte Pasquale Foggia Carlo Sansone Mario Vento Thirty years graph matching pattern recognition IJPRAI 18 3 2004 265298 5 Pasquale Foggia Carlo Sansone Mario Vento A database graphs isomorphism subgraph isomorphism benchmarking 3rd IAPRTC15 Workshop Graphbased Representations Pattern Recognition 2001 6 M Garey D Johnson Computers Intractability Freeman Co New York 1979 7 John E Hopcroft Richard M Karp An n52 algorithm maximum matchings bipartite graphs SIAM J Comput 2 4 1973 225231 8 P Van Hentenryck L Michel ConstraintBased Local Search The MIT Press 2005 9 V le Clément Y Deville C Solnon Constraintbased graph matching 15th Conference Principles Practice Constraint Programming CP LNCS vol 5732 Springer 2009 pp 274288 10 C Lecoutre Constraint Networks Techniques Algorithms ISTEWiley 2009 11 C Lecoutre S Tabary Abscon 112 robustness 3rd International Constraint Solver Competition CSC08 2008 pp 4148 12 Javier Larrosa Gabriel Valiente Constraint satisfaction algorithms graph pattern matching Mathematical Structures Comp Sci 12 4 2002 403422 13 JJ McGregor Relational consistency algorithms application ﬁnding subgraph graph isomorphisms Inf Sci 19 3 1979 229250 14 R Mohr TC Henderson Arc path consistency revisited Artif Intell 28 1986 225233 15 JeanCharles Régin Développement doutils algorithmiques pour lintelligence artiﬁcielle Application à la chimie organique PhD thesis 1995 16 JC Régin A ﬁltering algorithm constraints difference CSPs Proc 12th Conf American Assoc Artiﬁcial Intelligence vol 1 Amer Assoc Artiﬁcial Intelligence 1994 pp 362367 17 F Rossi P van Beek T Walsh Handbook Constraint Programming Foundations Artiﬁcial Intelligence Elsevier Science Inc New York NY USA 2006 18 JR Ullmann An algorithm subgraph isomorphism J ACM 23 1 January 1976 3142 19 David L Waltz Generating semantic descriptions drawings scenes shadows Technical Report AITR271 MIT Artiﬁcial Intelligence Labo ratory 1972 20 S Zampelli Y Deville C Solnon Solving subgraph isomorphism problems constraint programming Constraints 2010 press doi101007 s1060100990743