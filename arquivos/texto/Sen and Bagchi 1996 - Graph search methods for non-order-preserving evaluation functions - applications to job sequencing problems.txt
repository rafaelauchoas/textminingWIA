Artificial Intelligence 86 1996 4373 Artificial Intelligence Graph search methods nonorderpreserving evaluation functions applications problems job sequencing Anup K Sen Amitava Bagchi Indian Institute Management Calcutta Joka D H Road PO Box No 16757 Calcutta 700 027 India Received March 1994 revised April 1995 Abstract Graph search A frequently faster tree search But A graph search In nonorder function orderpreserving operates correctly evaluation preserving case paths discarded entire explicit graph stored memory Such situations arise onemachine minimum penalty job sequencing problems setup times sequence dependent GREC memoryconstrained A able optimal solutions efficient A solving graph search problems orderpreserving functions Experimental indicate faster bestfirst depthfirst larger size bestfirst nonorderpreserving tree search solve problem search algorithm authors called MREC clear advantage problems At time unlimited memory version instances case GREC tree search evaluation results 1 Introduction Many attempts recent years widen range problem areas algorithm A 8 usefully applied As effort A areas project employed stock cutting 29 In cases search scheduling running A running graph job standard little distinction bestfirst branchandbound solve optimization 3 rectangular tree job sequencing procedure problems In A major work Institute reported Technology School Industrial Management completed Newark NJ 07102 USA authors visitors New Jersey Corresponding Email bagchiiimcalernetin author Email seniimcalernetin 00043702961500 0 1996 Elsevier Science BV All rights reserved SSDI 000437029500094l far higher execution speeds graph instead tree jobs machine branchandbound penalty functions algorithm It 28 quadratic achieved 15222425 minimum runs 25 40 implemented graph search methods Abased likely graph search greater use scheme search procedure stock cutting related optimization existence problems Some recent years view search space 21 graph search tree deepening use stack But fed nodes It constrained recursive 1727 MREC tree search implicit tells additional memory memory iterative available stores possible explicit graph When generalization lo Unlike A MREC sufficient memory faster classic suggest howcvcr sequencing scheduling represented optimal search graph 16 jobs graph proposed Y try avoid duplication methods sequencing sequencing bestfirst jobs scheduling Consider Townsends penalty times Such examples future A methods graph earliest algorithm search OPEN run time parameter M In memory use M small increases MREC makes node expansion graph explicit comparable scheme list All needs viewed approximates IDA time expand A called GREC IDA expands node times As M fewer fewer node expansions significant When M large MREC node advantage stores entire But case function solutions functions path functions evaluation MRECM efficient problems possible paper It able currently orderpreserving nonorderpreserving lOO1031 respect solving graph involving normorderpreserving evaluation clear advantage path 14 pp evaluation performance x search problems orderpreserving optimal A We Pearl recall root node discarded path lower cost A based principle path later stages search process Such situations jobs allowed machine completed time processed setup search methods dent unsuitable advantages size sequence dependent When graph depen A retain discarded promising job sequencing taken job job begin The setup tree search entire explicit graph stored yield optimal evaluation search search setup ready I sequence solutions When function graph time job time previous small medium like GREC processing current matter times ignored assumed place A 23 graph job J times sequence nonorderpreserving times The setup algorithm tree To sequence implemented processing processing problems independent independent immediately unpromising job Abased setup prior arise job Job sequencing job scheduling solutions problems areas NPcomplete difficult exact 191 result approximation AK Sen A Bagchi Artificial Intelligence 86 1996 4373 45 recent years Promising flow shop scheduling best classical heuristics sequencing scheduling methods extensively approaches employ artificial neural networks tabu search 16 It demonstrated tabu search obtains solutions uniformly example 26 A list applications tabu better given 16 Table 31 p 1281 Similar search approaches prove useful approximate practice problem Our exact methods sizes tend large exact methods primarily infeasible scope use job sequencing discuss approximation methods paper solutions desired minimum penalty job sequencing situations arise It true extend This paper organized follows In Section 2 review algorithm GREC principle operation help example We formally state prove important properties explain cases life problems solves onemachine GREC nonorderpreserving times As step direction try particular setup times Section 4 explains graph search GREC b We problems dependent problems described class real functions duplication nodes execution multiple provide answers onemachine minimum penalty dependent bound methods employed 413 We problem GREC bestfirst depthfirst bestfirst section summarizes compares GREC similar search schemes job sequencing involve sequence job sequencing Section 3 existence interesting evaluation demonstrated Tree search solve problems owing slow nodes expanded problems The quadratic penalty version job sequencing problem sequence Depthfirst branchand past solve similar problems instances small medium size preferred methods runs faster tree search solves problems larger size paper setup times great practical tree search The 2 Algorithm GREC GREC GREC solutions heuristic identical MREC 21 memory parameter M set infinity It outputs optimal admissible expanding node We explain principle operation recursive procedure EXPLORE explicit iteration explores graph contains root node EXPLORE moves path explicit tip node node successors graph encounters tip node adds new nodes edges explicit graph It expands explicit graph root node s Initially based estimates 46 A K Sm A Bagchi I Artificial Intelligence 86 1996 4373 explicit graph As IDA cutoff value movement terminates GREC encounters Each node n explicit graph bvalue monitoring goal node bn stores downward current estimate node bn equals heuristic estimate hn cost path cost II goal node When n tip program GREC var terminate begin initially explicit graph contains root node s terminate initialize repeat false s I bs hs EXPLOREs terminate output output bs solution outpath solution cost path end procedure EXPLOREnnode begin n goal node begin terminate true return end n tip node UPDATEn updation EXPANDn takes place n tip node nontip node end procedure EXPANJlnnode begin y1 successors bn hn x EXPLORE EXPAND called II successor n n II present begin explicit graph initialize add n n bn hn n n edge explicit graph end add end edge n n explicit graph procedure UPDATE var cutoff begin integer nnode AK Stn A Bagchi I Artijcial Intelligence 86 1996 4373 47 cutoff 00 large value successor IZ 12 begin bn 3 bn cn n begin bn cn n bq EXPLOREq exploration continues greater depths bound exceeded terminate begin add ni outpath return end end point bn cn ni bn bni cn ni cutoff cutoff bn cn n end bn cutoff end The downward movement path determined bvalues cost arc nodes path costs arcs Let CIZ ni denote IZ IZ n ni When GREC reaching node II finds successor bni gets bn 2 bni clt n reset ni If bn bn 12 n successor IZ IZ successors case bn gets reset minimum bn values If IZ explored explored subsequent IZ successor n explicit graph bn 3 bn c IZ IZ n explored explores ni If bn bni cn n larger value allows deeper exploration iteration explores EXPLORE calls procedures EXPAND UPDATE EXPAND expands explicit graph tip node adds newly generated nodes edges bvalues nodes UPDATE carries makes GREC recursive The output solution path stored outpath The explicit search graph associated parameters graph node updates calling EXPLORE exploration assumed accessible procedures superficial spite certain description clear From resemblances GREC differs radically IDA major respects GREC stores entire explicit graph memory This amounts storing nodes successor lists IDA contrast store explicit graph available GREC node needs expanded Note unlike GREC A store entire explicit graph memory currently stores spanning known minimum cost path node tree explicit graph contains entire explicit graph memory Because ii IDA tree search algorithm When searches graph tree graph tree course search GREC implicitly converts 4x A K Sen A Bagchl I Artificial Intelligence 86 1996 4373 Iig I Search graph tor Example I genuine convert graph search method tree graph views graph graph search graph instant correspond 1 Consider cost path Example minimum expansions GREC A Let instant estimates bs gets updated minimum cs n bn At instant 2 n gets expanded EXPLOREs termination called GREC bvalues 6 shown Fig 1 We want start node s goal node The sequence snpm differs fresh sequence EXPLOREs node snpmp ith 3 instant ith shown nodes encircled At instant Fig 2 time The explicit graphs In figures 1 s gets expanded heuristic values cs m bm Since bn 3 cn p bp Fig 2 Explicit graphs execution GREC AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 49 3 p gets expanded bvalues p n s revised 10 13 11 respectively At instant 3 m gets expanded bs revised 12 At instant 4 GREC terminates smpr minimum cost solution path An experimental given comparison GREC A IDA variety fast 21 The data GREC runs indicates problems general examples given 9 ii 1v fast 15puzzle problem problem Manhattan heuristic runs short memory able solve problem On 8pe IDA On corresponding like A But MREC limited memory fast IDA On travelling salesman problem evaluation function Little et al 12 graph formulation problem suggested Pearl 14 fast A On rectangular cutting stock problem On general uniform dary single goal node randomly generated admissible heuristic estimates faster A IDA arcs unit cost 29 fast A tree bidirectional The power GREC comes use bvalue estimates cost best path node goal bvalue helps determine exploration node worth pursuing extremely useful feature Comparing 9 characteristics GREC A IDA function able solve problem admissible orderpreserving When evaluation like IDA algorithms optimal solutions A tree search method finds optimal solutions evaluation nonorder preserving Abased graph search methods fail GREC GREC solution paths differ But GREC IDA output solution path Unlike A IDA GREC expands node The worstcase running time GREC exponential number nodes search graph like A IDA A expand nodes different function order ii ii IV Some issues example iv discussed greater Section 211 21 Properties GREC theoretical formulation 211 Constant arc costs We state derive important initially assume arc costs constant later extend arc costs The notation terminology dependent results given Appendix A important theoretical properties GREC We results path adapted l Proofs A search graph G directed graph special node s called root node 50 A K Sm A Hugchi Artificiul lntellqpcc X6 19 J3 71 directed root node path minimum G strictly goal nodes arc m n finite arcs solution goal node The cost cP path P path nonnegative set goul nodes Let r r r G Each directed nodes arc cost cm n A path finite sequence nonempty m n positive path path sum costs arcs path Our objective solution systematically heuristic estimate hm values The search graph G called algorithm What When instants nodes expanded searching G Each node m G associated explicit graph explicit graph consists root node S added explicit graph At subsequent explicit graph given G Initially successors estimate supplied fresh nodes arcs included subgraph s expanded implicit graph set rules heuristic G GREC generating guided like A search tries cost The ensure following search conditions G exactly defined root node frequently imposed search graph G terminates successfully goal node solution G finitely directed loops cycles path G infinitely nodes arcs node immediate successors It permissible G ii There real number 7 0 T Since crn n 0 condition nodes true ical studies G infinitely nodes arcs imposed arc m n G cm n 3 G finitely theoret ensure algorithm arc costs holds practical lower bound But order search nonzero terminates situations iii For nongoal node m G heuristic estimate path infinite successors G m goal node Otherwise particular hm infinite m nongoal If r goal node hr 0 hm finite hm finite node Definition 2 Let instant correspond fresh invocation EXPLOREs moment instant time explicit graph n explored instant EXPLOREs If EXPLOREn invoked instant called j node graph j root s instant II ith ith explicit ii Let G subgraph ately prior graph moment jth G m root Consider moment invocation EXPLOREs j Gm time immedi look explicit iii By bjm mean bvalue node m instant mean Let b denote G cost solution j bj cost path minimum iv The explicit graph G instant j consistent tip node n G nontip path P s node m lying P bjm AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 51 solution path S At initial instant finite equals cP m n hn cP m n cost path P m n The path m y1 P called potential solution path psp m instant j psp qualification refers explicit graph potential G contains bs hs psp consisting node S When G consistent tip node n psp II goal node gets explored instant j G consistent tip node expanded instant j Let Pi Pi PL paths GI node m tip nodes Define viewed consistent node S Gi 4 indicates cost path Pi m m cP m Here cP m taken zero Qm equals hm m tip node By Q mean QS Note Qi hs LetP PkS paths G m goal nodes Define P2 vi Qm z z cPi m hmI 7 vii indicates cP m cost path Pi m m If m goal node Qm 0 If solution paths passing m Qm M By Q mean Qs Note Q finite The heuristic estimate function G hm exceeds goal node admissible Q b admissible nongoal node m cost minimum cost path m inadmissible When heuristic heuristic termination GREC property cost output solution path bounded Q When heuristic estimate function path minimum cost solution path search graph The results stated Theorems 10 12 In order establish theorems node m explicit graph Qm bounded Qm As execution GREC proceeds Q approximates Q closely finally equals Q admissible Lemma 3 Let m node immediate successors m m Then mk Gi Qm pIa2k hm mincm mi Qjmil Lemma 4 Let j j instants execution GREC j j Then node m G Qm s Qm S Qm Lemmas 3 4 follow immediately definitions Qm Qm 52 A K Sen A Bugchi Artificial Intelligence 86 lYY6 4371 Corollary jj Then 5 Let j j instants execution GREC Q s Q c Q How bvalue Q instant root node lemma shows related Qvalue It bounded Lemma 6 Let j instant execution GREC Then node m G bjm c Qm ii b I Q c Q Corollary 7 If explicit graph consistent instant j node m P P psp instant j bm Qm Remark 8 Qm See proof Lemma 6 Appendix A termination root node bvalue ii instant j bm Qm inadmissible If heuristic m output path m greater If search graph node m G search graph consistent tree For example tree iii When graph Fig 1 cm p 6 hp 6 keeping Then 13 16 instant taken bs successive 5 explicit graph instants values suppose explicit search graph 0 6 11 12 values instants consistent Lemma 9 Let j positive integer If GREC terminated instant j instant j 2 j prior termination G consistent Theorem outputs solution path 10 Algorithm GREC terminates successfully finds goal node Definition 11 Let b bvalue root s GREC terminates Theorem 12 b ciKE Q ii b iREC b heuristic estimate function admissible Which nodes search graph expanded set V defined contained GREC These nodes Definition 13 We construct finite set nodes V follows s V AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 53 ii A node m G V path P s cP hm s Q immediate predecessor m P m V Theorem 14 All nodes expanded GREC belong set V immediate running time GREC procedure EXPLORE appropriate called To form idea number times terminates When EXPLOREm count called time node m algorithm goal node minimum values bm gets expanded successors m When m explored cm m subsequently expanded minimum recomputed Thus number computations serve good measure running time GREC number revolutions loop depends costs arcs arc costs Do exist forming search graphs force GREC number calls existence search EXPLORE The following example demonstrates graph This makes sense G loop free loops loop increased reducing exponential Example 15 Consider features search graph G shown Fig 3 G following Total number nodes U 2k 1 ii All heuristic estimates zero iii The arc costs follows ml m2 sno n 4 G n k1 Fig 3 Search graph Example 15 53 A K Sen A Hugchi Artijicial Intelligencr 86 1996 W 73 expands nodes When k 4 GREC m gets expanded II m gets expanded m m m ml m given order The exponential total number inconsistency inconsistencies U networks bounded type order nmnmn2mnm When n1 m resolved When nodes m m resolved total number inconsistencies calls EXPLORE resolved 212 Path dependent arc costs We extend results path dependent arc costs Here heuristic node m estimate path m reached Section 211 notation meaning costs arcs emanating root We redefine m depend notation specifically redefined continues earlier Definition 16 Let P path estimate estimate node m calculated reference root s node m search graph G Let cP m n cost path P node m node n Let hm P path P The heuristic heuristic cost path P m computed goal node In definitions cP m m function reference node m G P minimum rn hm P consistent explicit admissible root node psp cost path cm m exceeds replace graph ii iii Let PI PJ P paths Gm m tip nodes let P path s m Gm Define 4 Qm P min I I mz cP C m hm P 1 Here cP P m path P cP P m hn P node m mean Qs_ taken cost path P m m defined let Qn P zero Also m tip If paths Qlm P x By Q tip node r7 tip node b Qm maxQm P maximum explicit graph GI taken paths P s m iv Let P P2 nodes P paths search graph G m goal let P path s m G Define 4 Qm P IJEI cP P m W PI 1 cP P m indicates cost path P m m AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 55 let Qn P 0 If defined P If n goal node solution paths passing m let Qm P 00 Thus Qm P finite node m G lies solution path By Q mean Qb_ I Qm maxQm PIIT maximum taken paths P s m G With redefinitions Lemma 3 remains true appropriate changes notation It restated follows Lemma 3 Let m node immediate successors m m2 mk GIf let P path G s m Then Qlm P F Mm P mincP m mi Qm fl __ lower bound arc costs GREC Lemmas 4 6 remain We impose Section 211 terminates successfully nonzero arc costs heuristic Lemma 9 Theorem 10 remain valid When bvalue node decrease time estimates path dependent occur arc costs heuristic estimates constant But bs decrease time path dependent case finally achieve value Q Thus GREC path dependent arc costs outputs optimal heuristic estimates admissible path P search graph solutions 3 Onemachine job sequencing problems 31 Problem description A onemachine minimum penalty form Jobs Ji processing job sequencing problem following times 0 1 s s N submitted general job shop time t 0 The jobs processed given onemachine machine time Let processing job Ji completed ti Penalty functions Gi 11 s N supplied penalty associated completing Giti pit pi given constants proportional sequenced machine penalty associated job time job The jobs job Ji time ti Giti An example penalty way total penalty square completion function time minimized The penalty functions nondecreasing Problems type obvious relevance hard solve In general setting jobs setup times The setup industry known general nonlinear 56 A K Sm A Bugchi Artificiul Intelligence 86 1996 4373 terms time processing current s The processing machine sequence methods functions setup preserving solutions applicable situation job time previous job begin setup sequence time job s After need brought independent taken ready machine job completed If J job job I sequence immediately sequence specific state Setup follows processing processing setup job completed time times said sum job J approaches J tend separable additive s expressed job 1 times sequence dependent Existing depends setup assumption work setup absence times order preserving setup remain times sequence Abased setup But dependent graph Tree search procedures tend inefficient times sequence independent times frequently 13 Solution extended sequence evaluation independent functions search method fail branchandbound duplicate evaluation assumption realistic nonorder optimal output method remain nodes generated 32 Classification minimum penalty job sequencing problems Onemachine following Setup minimum seven different times nonexistent penalty job sequencing problems classified types sequence independent evaluation functions consequence orderpreserving Type A Penalty functions linear job finish times Problems type simple Ordering jobs nondecreasing order avalues ing necessary gives minimum penalty sequence 6 search ii Type B Penalty functions quadratic job finish times Townsend 28 branchandbound function quadratic formulation proposed use turned novel evaluation subsequently schemes implemented uses Townsends modifications achieved employ selective Bagga Kalra improvements tree far search Sen Bagchi efficient Abased penalty 2 Gupta case Sen 7 Townsends method All recently 2224 suggested GREC scheme search graph evaluation function Bagga Kalras A similar implementation See Section 33 iii Type C Penalty functions general polynomials complex exponentials job finish times functions Both penalty tree graph types Unfortunately Schild functions search methods applicable problems good heuristic Fredman 20 estimate functions examples general AK Sen A Bagchi I Artijicial Intelligence 86 1996 4373 57 b Setup times sequence dependent evaluation functions consequence nonorderpreserving Type D P enalty functions linear job finish times function formulated In case evaluation usual nonorder preserving The problem solved natural evaluation A graph search remains 23 An alternative way redefine order preserving manner way GREC function applicable 1524 See Sections 34 41 ii Type E Penalty functions quadratic job finish times In case penalty function nonlinear modify possible orderpreserving GREC solves problem way 23 See Sections 34 42 nonorderpreserving evaluation appear function natural iii Type F P enalty functions general polynomials job finish times The approach Section 42 extended polynomials job finish times Good evaluation penalty functions functions iv Type G Penalty functions complex functions exponen tials noninteger powers job finish times apply method Section 42 necessary In order approximate type F problems good heuristic estimate reported penalty function finite polynomial However functions 33 Tree search graph search Suppose jobs setup branchandbound times Consider quadratic penalty tree search procedure Townsend job sequencing prob lem A node tree corresponds ordered partial sequence jobs The node ni represents ordered twojob sequence null sequence All nodes partial sequence k jobs gets expanded N k sons generated son partial obtained appending remaining N k jobs sequence k jobs An edge signifies job processed cost edge penalty associated job A problem solved complete ordered single job J node nij represents root node corresponds JJj distinct When node corresponding sequence N jobs gets selected OPEN The In corresponding graph formulation nodes correspond jobs root node set When node corresponding k jobs gets selected OPEN expanded subset k 1 jobs As associated corresponding set N jobs gets selected corresponding k node k incoming paths root unordered subsets subset generated N k sons son penalty job A problem gets solved complete level 0 node subset k jobs level k There CN k nodes level In contrast tree OPEN The root cost edge level k node incoming point level k factor expanded nodes The I N CN 2 path Thus k This nodes tree nodes CN k nodes level k tree nodes total number memory number truer estimate computing implementation reduction function evaluation A GREC depthfirst bestfirst 22 Graph tree search ran upto 16 jobs For 16 jobs graph search search Depthfirst slower search nodes actually number given overestimate k nodes reduction factor account NN reduction taken generated search need kCN k k s N2 factor k I This viewed factor The use Townsends yields fast memory In graph search WC need including time track expanded k equals levels 0 graph instant method efficient graph search How better graph compared experimentally tree search setup times faster search bestfirst example sequence available memory exhausted tree 40 times run large number search This checked run upto 30 jobs bestfirst point principle graph When essentially representation modified Nodes longer correspond job pair ordered component search graph form job processed search graph number 0 k N Again graph evaluation subset nodes tree nonorderpreserving component search jobs function true job processed remembered jobs ran 20 jobs markedly 175 times slower dependent tree search method remains nodes subsets jobs processed job S J S subset jobs S Thus number subset graph search needs A node corresponds second So node n I nodes level k k 2 case In 1 k 1 N kCN k 0 k N The reduction factor k l reduction representation factor store generated smaller nodes memory explained 34 Nonorderpreserving wuluation functions set S Let t time sequence times Y node n The sequence processing path P When setup t equals Let suppose setup I completes root node S processed paths belong jobs time sequence sequence dependent paths cost associated P time completion depends independent t equal determined identical I completes dependent jobs processed Let P P paths let r times ignored assumed path P jobs processing processed determined It happen t times sequence t But setup times jobs setup cost associated P job node penalty arc costs arcs emanating corresponding t t Since A K Sen A Bagchi I Artificial Intelligence 86 1996 4373 59 Table 1 Job setuu orocessine times Job Setup times 1 2 3 4 1 1 CC 00 2 1 _ m CC 3 1 3 P 4 m 00 10 _ Processing times 1 4 3 10 heuristic estimate node n depend general path yt reached root arc costs heuristic estimate l It possible complete sequence N jobs path dependent extension subsequence determined P2 lower total cost sequence N jobs extension P But graph implementation A discard path P2 node IZ cost higher P job P2 sequences In linear penalty case subsequently possible skirt difficulty reformulating A function strategy work penalties nonlinear case algorithm extensions sequence determined considered algorithm like GREC evaluation Example 17 Consider linear penalty problem 4 job penalty coefficients unity jobs Then penalty job J equals fi ti finish time job total penalties sum individual job penalties Table 1 gives setup times processing times Setup time sij entry ith row jth column table The initial setup times soj zero The cost arc m r node m 123 3 assumed 4 depends path reach m goal node r 1234 root If process J J2 cost path P root m 19 cm r 32 If process J2 J cost path P2 root m 20 cm r 30 If m favor P discard P2 end giving preference inferior solution paths The minimum penalty case happens J2J1J3J4 job sequence 4 Running GREC nonorderpreserving evaluation functions 41 Linear penalties When penalties linear setup times sequence dependent function defined normal way nonorderpreserving evaluation possible Appendix B GREC solve problem following natural formulation require modification order preserving adjusting way evaluation function It 60 A K Sen A Bagchi Artificial Intelligence X6 19 4 73 function When node n S J enters evaluation result expansion saved parameter n subsequent different n reached linear path t T bn expressed time parent node T associated n There paths EXPLORE completion instant time procedure time job J t completion reset t The value bn depends depends T When penalties root explicit graph t ns job J root reach n general path bn aT t 5 LY 3 parameters node n In fact depend node H path taken Q set jobs remaining processed IZ Y c pk 1 J Q p bvalue node n taking node IZ root equivalently taking T 0 yielding search parameter yielding T grouped time c expressed T tk T Y job Jk Q finish terms combined p changes Note coefficients remaining When T changes value t ta d oes depend p Thus node II reached time based path P GREC At later bn accordingly Y stores bn different sets bn hn P p The value Y remains jobs constant Q sequenced estimate Y T node instant n reached path bn path P GREC t bn changes heuristic computes difference LY Tvalues computed change modified value t penalty problem job sequencing Example estimates nodes sequence zero heuristic Jz J J3J4 cost equal 17 Let assume Example 18 Consider outputs simplicity expanding minimum 1 When node root node m 123 J J2J3 values T 12 bm 32 Y 1 stored node m When m reached 10 12 Y 2 JzJ J3 T 10 change GREC The algorithm 3 path P path P2 job sequence m computed explores m bm 30 outputs explained root subsequent sequence operates reached job processing 30 optimal Example bvalue solution GREC instant instant path time 411 Experiments In experiments heuristic estimate follows 1151 Let n S J tip node jobs processed n For job Jk Q hn tip node n computed explicit graph Let Q set time sk effective setup AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 61 effective job processing minsj minimum taken jobs Ji Q Q U Ji Let times Order jobs Jk Q sk avalues finish times t nondecreasing jobs let heuristic estimate C pktk Appendix B proof Our jobs Q This yields consistent heuristic experimental selective results Table 2 Fig 4 heuristic estimate order sk apvalues summation compute time generated integers chosen randomly total number nodes generated A tree search GREC depthfirst branch bound DFBB coded times jobs C run UNIXbased DEC 5900 The processing range 1 99 uniform distribution Penalty coefficients setup times integers ranges 1 9 way The initial setup 0 9 respectively times soj assumed zero simplicity For given number jobs execution total number nodes expanded averaged 100 runs Every effort ensure implementations efficient possible The OPEN set A maintained priority queue In GREC nodes stored node table expanded node A hashing scheme successor checking newly generated successor present explicit graph As DFBB non time Since job sequencing problems decreasing order effective welldefined depth bounds like IDA variants ll run slower depthfirst search report running times IDA successors node generated lists maintained iterative deepening job processing schemes The results experiments speedup ratios node reduction jobs The ratios computed respect A DFBB plots labelled B We summarize experimental shown Table 2 In Fig 4 plot ratios algorithm GREC number A tree search plots labelled observations The number nodes generated expanded increased rapidly number jobs algorithms With 22 jobs A tree search Table 2 Linear penalty functions Number jobs 12 14 16 18 20 22 24 26 GREC Time sets 002 006 014 035 087 255 665 1846 A tree Depthfirst Nodes generated Nodes expanded Time sets Nodes generated Nodes expanded Time sets Nodes generated Nodes expanded 363 699 1471 2912 6082 12 172 21823 40 633 70 126 252 473 954 1901 3214 6027 004 012 044 144 459 793 2OOil 5617 1s 133 41 154 103 220 541 1272 3134 006 021 078 266 966 1297 3770 11427 31567 96911 223 537 1388 3237 8990 62 A K Sen A Bagchi I Artificial Intelligence 86 1996 4373 Speedup Node Reduction 17 16 15 14 13 12 II 10 9 8 7 6 5 4 3 2 1 12 14 16 18 20 0 Speedup NodqenA 0 v NodeexpA A Speedup X NodegenB NodeexpB Number Jobs Fig 1 Linear penalty functions ii iii iv v vi instances instances larger size A tree ran short memory generating million nodes certain problem GREC able solve problem search We include results GREC upto 26 jobs A variant GREC implemented nodes explicit graph stored successor lists maintained This variant ran slower GREC time generate successors order high job sequencing problems A graph search plemented A graph search close corresponding GREC running time comparable DFBB low memory needs 30 Thus DFBB solve problem larger size GREC We ran upto 20 jobs compare performance GREC A tree search For 20 jobs GREC A tree search 11 times faster DFBB The speedup ratios node reduction ratios im It numbers nodes generated expanded figures GREC instances larger size instances rapidly number jobs The speedup capable solving problem ran 5 times faster modified evaluation function ratio increased AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 63 smaller node generation expansion reduction following factors level graph overhead algorithm reduction ratio higher node ratio This result combined effect dependence branching factor node consistency heuristic estimate vii DFBB needs little memory overhead low But nondecreasing order effective processing times generated nodes successors generated ran slowly 42 Quadratic penalties function evaluation With quadratic penalty functions setup times evaluation orderpreserving efficient A graph implementation computing performance possible generalize times The GREC handle 41 additional computations Existing graph search algorithms directly applicable An realized Townsends method function The problem solved GREC appear setup Section needed step explained hand readily extended similar described similar A Unfortunately A graph implementation case The method solution sequence dependent penalty function implementation nonlinear The bvalue node IZ UPDATE procedure computed way linear case The bvalue node II form Y 3 y parameters set jobs remaining processed We depend node II T Let Q o c pk 1 Jk Q P 2 c pktk 1 Jk Q y bvalue node n IZ viewed origin T taken zero coefficients T2 grouped coefficients T yield parameter p remaining As linear case job Jk Q finish time t expressed T tk T terms parameter combine I y Y p T stored change jobs Q sequenced node reset UPDATE This increases explains GREC linear penalties y The value CY remains constant search runs slower quadratic computation penalties yielding 64 A K Sen A Bagchi Artificial Irttelligence 86 1996 43 73 This method extended job finish times For example penalty functions cubic case bn written higher powers bn CYT 3T2 yT 6 parameters defined Extension functions penalty immediate Since good heuristic performed penalty functions manner similar shown polynomials functions known experiments job finish times 421 Experiments At tip node n effective processing heuristic estimate hn Townsends method Townsend derived sufficient conditions jobs minimum cost He showed sequence pair adjacent satisfied time sL uk job Jk Q computed modification sequence N minimum cost jobs J J J precedes J following conditions pla apiia ii p P The conditions satisfied simultaneously adjacent pair jobs Hence search method needed To determine lower bound node IZ branchandbound m jobs Q follows search order Pi apZlarZ 2 Picrnjait The penalty F subsequence jobs Tx aA Jk S penalty F p pkaa The lower bound obtained considering pairs jobs Jk J ordered sequence Jk precedes J pk p pair In presence setup times effective reducing times The resulting processing Appendix B proof The function heuristic experimental data indicated case absence setup times times place actual processing consistent heuristic estimate selective estimate In experiments DEC 5900 Processing chosen randomly coefficients integers programs written C run UNIXbased times jobs integers Penalty ranges 1 9 generated range 1 99 uniform distribution AK Sen A Bagchi Artificial Intelligence 86 1996 4373 65 Table 3 Quadratic oenaltv functionsSet I Number jobs 12 14 16 18 20 GREC Time sets 009 028 083 325 1325 A tree Depthfirst Nodes generated Nodes expanded Time sets Nodes generated Nodes expanded Time sets Nodes generated Nodes expanded 920 2287 5544 14 526 36646 232 539 1277 3322 8193 015 069 339 3685 12 961 50 776 488 1446 5003 020 090 415 5216 18 853 80 575 789 2342 8662 way For sets initial setup times soj assumed zero simplicity Two sets setup times considered Set I consisted setup times times range 1 5 The range 0 9 Set II consisted setup heuristic estimate Set I selective increased running time GREC run larger number jobs given time Set II time total number nodes For given number jobs execution generated total number nodes expanded averaged 100 runs In implementing depthfirst search successors node generated Speedup Node reduction 16 15 14 13 12 11 10 9 S 7 6 5 4 3 2 0 Speedup NodegenA 0 NodeexpA A Speedup X NodeeenB Number jobs V NodeexpB Fig 5 Quadratic penalty functions Set I 66 AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 Table 4 Quadratic Number jobs penalty functionsSet II GREC A tree Depthfirst Time Nodes Nodcs Time Nodea Nodes Time Nodes Nodes sets generated expanded sets generated expanded sets generated cxpandcd 12 14 16 IX 20 22 24 005 016 055 I hO 4Y2 3064 Y I 09 649 1482 3420 7517 IX 158 40 555 x1 714 I63 34s XI4 16X7 4052 Y7 I9 I7 65 0 I2 0 56 323 2YOh IO 344 47 120 388 116 4750 015 069 391 3937 1449 66 756 16 Y2 233 250 x503 979 937 s94 IX05 7214 I 6X9 82 548 nondecreasing job J order p refers effective processing time Experimental results Set I shown run larger number Table 4 Fig 6 The results similar GREC A tree search nodes million 16 jobs For 18 jobs instances Since trend jobs Table 3 Fig 5 Set II linear case faster sharp tree search generated times estimate heuristic Speedup Node reduction 12 14 I 16 1 18 I I 20 3 Speedup NodegenA 0 NodeexpA A Speedup X NodegenB Number Jobs v NodeexpB Fig 6 Quadratic penalty functions Set 11 AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 67 linear case running graphs Figs 5 6 showed increase speedup node reduction number jobs DFBB ran times slower GREC jobs DFBB GREC times Tables 3 4 larger Table 2 The ratios 16 capable solving problems larger size 5 Conclusion practice Although A capable graph search tree search generally tree search procedure It recently application areas onemachine job sequencing graph search tree search problems A faster bestfirst depthfirst small medium size However A suitable searching graphs In cases graph search evaluation algorithm GREC place A Experimental times sequence dependent setup consequence GREC nonorderpreserving job sequencing problems penalty solves linear penalty quadratic faster tree search schemes nonorderpreserving evaluation results indicate function function The detection elimination duplicate nodes pressing issue tree pruning duplicate search algorithms Taylor Korf 1271 suggest technique depthfirst search Their method requires preprocessing search nodes breadthfirst graph means exploratory sequence operators needed shortest helps detecting eliminating duplicate nodes actual search phase Preprocessing needed type problem knowledge acquired later depthfirst search instances The implicit assumption cost arc problem problem pair nodes independent like 15puzzle 24puzzle Rubiks cube instance This true problems But apply techniques effectively arc costs different problem search This determines job sequencing problems possible node instances Very recently Reinefeld Marsland 17 reported enhancements IDA search They shown search efficiency iterative deepening greatly improved storing table memory nodes course search Their search algorithm TRANS appears encountered perform better solution method suggested Pearl 14 travelling salesman graphbased conceptually close GREC pseudocode given problem TRANS 17 Fig 7 p 7091 shows The hash table TRANS store generated nodes similar table GREC However TRANS hash existing entries overwritten promising new table TRANS entries Another difference algorithms lists This stores nodes explicit graph successor advantage like Wpuzzle node generation 15puzzle problems problem time But significant generate nodes achieved problems node numbers generation useful purpose number time job sequencing disadvantage successor like rectangular lists maintained node explored memory 2129 nodes repeatedly stock problem cutting successors time takes times higher Even helpful explored hashing speeds tree search know node serves high In fact cases node case separate distinct store expanded node sons sons assigned array successors node number successive needed son node numbers time generation In ending point GREC explicit graph memory difficulty At time know scheme solve Since limitation large problems stores Is In job available memory M answer inadvisable depth schemes bound For deepening welldefined deepening use iterative known iterative formulated unsuitable jobs runs faster currently SMA run memory 18 MA constraint S arc based A A graph maintains difficulties algorithm graph search An entire appears memory graph memory management problems successor technique modified sequencing need hour features efficiently MREC storing entire lists incorporated TRANS runs efficiently sequencing capable explicit Is possible number problems search entire way sequencing total depthfirst reason MREC small Algorithms implementations efficient explicit improve solving graph Alternatively memory management problems graphbased larger size Appendix A Properties GREC proofs claims Section 21 Lemma 6 Let j irzstunt execution GREC Then bm G Qm ii hGQ fur uny node m G For nontip node prove lemma fails The j This takes place instant place instant instant m nontip m nontip true definition Let j earliest Proof For tip node result contradiction lemma fail node recalculation j Q_m know Lemma Qm moment immediate In course recalculation fails Let n n lemma recalculation node recalculation node successors Some instant instant j 1 assumption 4 Q_m 9 Qm rzk immediate j let n node successors h m S bm b_m S time n At bvalues takes place H lemma holds successors AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 69 updated instant change bvalues case n lies loop immediate successor IZ bvalue II updated lick IZ However recalculation bni hn Qinl II tip node bn c Qlni n nontip node bjn y bn mink n bq Q n Lemmas 3 4 This contradiction function admissible bvalue m When heuristic estimate set value exceeding exceed Qm termination Qm If heuristic inadmissible termination node m output path m root bvalue greater Qm set large value If GREC terminate bvalue Qvalue m revised upwards instant j bjm s Q m The bvalue heuristic admissible inadmissible b s Q execution GREC similar inequality hold termination root set instant j 0 Lemma 9 Let j positive integer Zf GREC terminated instant j instant j 2 j prior termination G consistent lemma Proof Suppose false Then running explicit graph G consistent Since tip node gets explored nodes expanded G remains unchanged bvalues nontip nodes explored increase 7 Thus instant j j bj8 increases T Since G remains Q Q instant j j So Q finite time come b Ql contradicts Lemma 6 instant j j GREC cid144i Theorem 10 Algorithm GREC outputs solution path terminates successfully finds goal node Proof By Lemma 9 GREC running indefinitely expanding tip node If j j instants tip nodes expanded psps instants distinct If search graph finite loop 70 AK Sen A Bagchi Arrificial Intelligence 86 19Y6 4373 free GREC obviously terminates If recall cost arc T 0 node finitely immediate successors bs exceed Q follows GREC terminate case 0 Definition 11 Let bc hvalue root s GREC terminates Theorem 12 bc ii b GRE b heuristic estimate function Q admissible By Lemma 6ii b s Q But solution path Proof termination b 2 Q ii If heuristic admissible 2 b 0 Theorem 14 All nodes expanded GREC belong set V Proof Immediate Lemma 6ii n Appendix B B 1 Linear penalties making evaluation function orderpreserving Let node m S Ji immediate predecessor node n S U Jk Jk explicit graph Then standard A formulation known best path root cost currently gn mingm PIT Lya ak T completion time ms job 1 determined currently known best path m minimum taken immediate predecessors m n explicit graph This cost function arc cost cm n pkT s ak depends path m reached following way Let P solution root We problem JN P Then cost path let jobs sequenced P nonorderpreserving order J Jz pa p2a s pa s t ap pz Pv sz aP2 PN s N avph Taking cue expression define new gvalues deferral gvalues follows gnmingmsC minimum taken predecessors m n AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 71 evaluation jobs remaining summation longer path dependent based graph search employed estimates processed account contribution total contribution expression function processed II The gvalues A 1524 The heuristic estimate node taken total penalty jobs remaining jobs processed orderpreserving gvalue B2 Linear penalties consistency heuristic estimate h consistent We heuristic estimate hn P linear penalty case Section heuristic path P shown parameter 411 estimate depends finish time job node n Let node m parent node n We hm P s cP m n hn P cP m n cost arc m n path P cP m n depends actual time taken process job Ji node processed node m belong path s IZ The jobs remaining time J m Q U Ji Let J job J Ji Then effective processing larger time cP m n smaller effective taken processing time node m Thus lefthand expression righthand larger process Ji determines effective processing time II Moreover actual B3 Quadratic penalties consistency heuristic estimate h The method computation Section 421 The method ensures admissible We argue consistent Let node n son node m let P path s m We want heuristic estimate heuristic estimate function described hm P s cP m n hn P processed sequenced Let edge m n correspond jobs remaining values Job J occurs penalty sequence sponding righthand job J When heuristic computed m order ailpi nondecreasing sequence To derive heuristic hm P terms corre correction computed certain pairs jobs deducted Thus left sides inequality differ following respects In righthand J occurs job lefthand necessarily job ii In righthand correction penalty job pair J member corrections lefthand terms deducted Consider optimal path P m goal If J job P heuristic inequality hold computation procedure 72 AK Sen A Bagchi Artificial Intelligence 86 1996 4373 ensures contribution J hm P lower bound final contribution J total penalty If J job P forcing J making corrections J increase value righthand References l A Bagchi study A Mahanti J ACM 30 1983 Search algorithms different kinds heuristics comparative l21 2 PC Bagga KR Kalra A node elimination function single machine quadratic penalty 633636 procedure scheduling Townsends solving problem Manage Sci 26 1980 algorithm 3 CE Bell K Park Solving resourceconstrained project scheduling problems A search Nav Res Logist 37 1990 6184 4 L Bianco S Ricciardelli G Rinaldi A Sassano Scheduling tasks sequence dependent processing times Nav Res Logist 35 1988 177184 S PP Chakrabarti memory Artif S Chose A Acharya SC De Sarkar Heuristic search restricted Intel 41 1989 197221 6 S French Sequencing Scheduling An Introduction Mathematics JobShop Ellis Chichester 1982 Horwood 7 SK Gupta function 644647 T Sen On times completion single machine improved branching scheduling problem quadratic penalty procedure Manage Sci 30 1984 18 PE Hart NJ Nilsson minimumcost paths B Raphael A formal IEEE Trans Syst Sci Cybern 4 2 1968 100107 heuristic basis determination 9 H Kaindl A Khorsand Memorybounded bidirectional search Proceedings AAAI94 Seattle WA 1994 13591364 iterative lo RE Korf Depthfirst 97109 deepening optimal admissible search Artif Intell 27 1985 ll RE Korf Linearspace bestfirst search summary results Proceedings AAAI92 San Jose CA 1992 12 JDC Little KG Murty DW Sweeny G Karel An algorithm travelling salesman problem Oper Res 11 1963 972989 13 AJ Mason EJ Anderson Minimizing How time single machine job classes setup times Nav Res Logist 38 1991 333350 141 J Pearl Heuristics Intelligent Search Strategies Computer Problem Solving AddisonWesley Reading MA 1984 15 R Ramaswamy AK pathdependent 16 CR Reeves Publications 171 A Reinefeld arc costs Sen Single machine scheduling Proceedings ECAI92 Vienna graph 1992 1115 search problem ed Modern Heuristic Techniques Combinatorial Problems Blackwell Oxford T Marsland iterativedeepening Enhanced search 1993 IEEE Trans Pattern Anal Scientific Mach Intell 16 1994 701709 181 S Russell Efficient memorybounded 15 search methods Proceedings ECAI92 Vienna 1992 19 S Sahni T Gonzalez 20 A Schild IJ Fredman Manage Sci 9 1963 7381 pcomplete approximation problems tasks deadlines J ACM 23 1976 555565 nonlinear functions loss Scheduling 21 AK Sen A Bagchi Fast Proceedings use memory recursive IJCAI89 Detroit MI 1989 297302 bestfirst formulations search allow controlled AK Sen A Bagchi I Artificial Intelligence 86 1996 4373 13 22 AK Sen A Bagchi Job sequencing quadratic penalties Abased graph search IEEE Conference Artificial Intelligence Applications Orlando Proceedings approach FL 1993 190196 23 AK Sen A Bagchi Nonorderpreserving evaluation methods job sequencing problems Proceedings functions recursive graphsearch IJCAI93 Chambery 1993 14231429 job 24 AK Sen A Bagchi R Ramaswamy Searching graphs A applications IEEE Trans Syst Man Cybern Part A Syst Humans 26 1996 168173 sequencing 25 AK Sen A Bagchi BK Sinha Admissible minimum penalty sequencing jobs setup times machines Proceedings ZJCAZ91 Sydney NSW 1991 178183 search methods 26 E Taillard Some efficient heuristic methods flow shop sequencing problem Eur J Oper Res 47 1990 6574 271 A Taylor RE Korf Pruning duplicate nodes depthfirst search Proceedings AAAI93 Washington DC 1993 28 W Townsend The single machine problem quadratic penalty function completion times branch bound solution Manage Sci 24 1978 530534 A Bagchi Bestfirst search methods 29 KV Viswanathan cutting stock problems Oper Res 41 1993 768776 constrained twodimensional 30 W Zhang RE Korf Depthfirst vs bestfirst search new results Proceedings AAAI93 Washington DC 1993