Artiﬁcial Intelligence 255 2018 4370 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Fixpoint semantics active integrity constraints Bart Bogaerts Luís CruzFilipe b KU Leuven Department Computer Science Celestijnenlaan 200A Leuven Belgium b University Southern Denmark Department Mathematics Computer Science Campusvej 55 Odense Denmark r t c l e n f o b s t r c t Article history Received 4 July 2017 Received revised form 2 October 2017 Accepted 18 November 2017 Available online 23 November 2017 Keywords Active integrity constraints Approximation ﬁxpoint theory Active integrity constraints AICs constitute formalism associate database constraints adhere ﬁx database case constraints violated The intuitions repairs good given description closely related intuitions live areas non monotonic reasoning logic programming autoepistemic logic In paper apply approximation ﬁxpoint theory abstract algebraic framework designed unify semantics nonmonotonic logics ﬁeld AICs This results new family semantics AICs We study properties new semantics relationships existing semantics In particular argue newly deﬁned semantics stand Grounded repairs simple deﬁnition purely based semantic principles semantics AICs adhere And coincide intended interpretation AICs examples The second semantics AFTwellfounded semantics computationally cheap semantics provides upper lower bounds classes repairs 2017 Elsevier BV All rights reserved 1 Introduction One key components modernday databases integrity constraints logical formulas specify semantic relationships data modeled satisﬁed times When database changed typically updating necessary check integrity constraints hold negative case database repaired The problem database repair important topic research thirty years 1 There major problems deciding repair inconsistent database ﬁnding possible repairs choosing apply Indeed typically ways ﬁx inconsistent database criteria choose best proposed years Among widely accepted criteria minimality change 4525 change little possible commonsense law inertia discussed 33 change reason change A typical implementation integrity constraints database systems means eventconditionaction ECA rules 3844 specify update actions performed particular event trigger occurs speciﬁc ditions hold ECA rules widely practice simple implement individual semantics easy Corresponding author Email addresses bartbogaertscskuleuvenbe B Bogaerts lcﬁlipegmailcom L CruzFilipe httpsdoiorg101016jartint201711003 00043702 2017 Elsevier BV All rights reserved 44 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 understand However lack declarative semantics ECA rules makes interaction complex analyze joint behavior hard understand The formalism active integrity constraints AICs 27 inspired similar idea AICs express database dependen cies logic programmingstyle rules include update actions heads They come set declarative semantics identiﬁes progressively restricted classes repairs criteria select preferred repair 13 These repairs computed directly means tree algorithms 17 imple mented prototype 16 Example 11 We motivate use AICs practice means simple example Consider companys database including tables employee dept relating employees department work In particular employee assigned unique department employee listed working different departments database inconsistent inconsistency ﬁxed removing entries We write requirement following AIC x y z employeex deptx y deptx z y cid4 z deptx y The intended meaning rule literals lefthandside body rule true state database particular values x y z database inconsistent inconsistency solved performing action right Suppose database DB employeejohn deptjohn ﬁnance deptjohn hr This database inconsistent applying AIC x john y ﬁnance z hr gives possible ﬁx consisting action remove deptjohn ﬁnance Observe instantiation x john y hr z ﬁnance detects inconsistency proposes instead ﬁx remove deptjohn hr general different ways repair inconsistencies AICs interact Suppose add constraint x y z supervisorx y deptx z dept y z dept y z 1 stating employees supervise people department constraint violated department supervisee needs updated supervisor table department supervisor deemed correct If database DB employeejohn employeeann deptjohn ﬁnance deptann hr supervisorann john AIC detects inconsistency suggests ﬁxed adding entry deptjohn hr The database inconsistent entries John dept table restoring inconsistency require removing entry deptjohn ﬁnance An alternative repair integrity constraint supervisee supervisor belong department change department information associated ann By active integrity constraints discard solution rule 1 allows insert new department supervisee If additionally want allow changing anns department need extra constraint cid2 It striking intuitions good repairs minimality change similar intuitions surfaced domains nonmonotonic reasoning logic programming 39 default logic 34 Still hard ﬁnd satisfying semantics AICs As shown CruzFilipe et al 17 semantics socalled founded repairs 12 unexpectedly fails respect commonsense law inertia restricted semantics justiﬁed repairs 13 forbids natural repairs cases That work proposed operational semantics wellfounded repairs modular 14 severely restricted practical applicability In work begin deﬁning new semantics AICs avoids problems grounded repairs Grounded repairs natural counterparts existing semantics nonmonotonic reasoning domains logic program ming discuss relate semantics AICs We argue grounded repairs match intuitions AICs broad set examples We abstract characterization different semantics AICs associating set AICs η semantic operator Tη This operator immediately induces semantics weak repairs ﬁxpoints Tη ii repairs minimal ﬁxpoints Tη iii grounded repairs grounded ﬁxpoints 7 Tη The ﬁrst semantics preexisting semantics AICs recover operatorbased fashion B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 45 Next deﬁne threevalued variant Tη In terminology approximation ﬁxpoint theory AFT 19 valued operator approximator original semantic operator Given approximator Tη AFT induces semantics iv KripkeKleene repair KripkeKleene ﬁxpoint Tη v AFTwellfounded repair wellfounded ﬁxpoint Tη vi partial stable repairs partial stable ﬁxpoints Tη vii partial grounded repairs partial grounded ﬁxpoints Tη We study properties new semantics study compare existing semantics Furthermore argue practical point view AFTstyle wellfounded semantics valuable Indeed AFTwellfounded repair computed polynomial time broad set practical examples corresponds intuitions underlying database repairs providing natural upper lower bounds set acceptable repairs formally AFTstyle wellfounded model approximates justiﬁed stable grounded repairs All semantics deﬁned framework approximation ﬁxpoint theory general algebraic framework studying logics ﬁxpoint semantics This framework initially developed Denecker Marek Truszczy nski henceforth referred DMT 20 identifying analogies semantics logic programming 39 autoepistemic logic AEL 32 default logic abbreviated DL 34 The theory deﬁnes different types ﬁxpoints called approximating operators approximators In context logic programming DMT 20 showed Fittings fourvalued immediate consequence operator approximator usual twovalued immediate consequence operator major semantics logic programs coincide equally named different types ﬁxpoints approximator They identiﬁed approximators default autoepistemic logic showing AFT induces main semantics ﬁelds new ones 21 unifying DL AEL deep sense More recently Strass 36 showed AFT characterize major semantics Dungs argumentation frameworks 24 abstract dialectical frameworks 11 Other recent applications AFT include deﬁning extensions logic programming 2 deﬁning new logics 10 integrating different formalisms 3 studying complexity 37 studying modularity predicate introduction uniform way 4143 As contribution work goes deﬁnition new semantics AICs By integrating active integrity constraints AFT provide solid foundations applying rich algebraic theory AICs For instance directly apply existing results AFT modularity results predicate introduction results AICs It remains researched related instance existing modularity results AICs 1415 Furthermore work paves way applying AFT revision programming following results Caroprese Truszczy nski 13 AICs outside database world generalized CruzFilipe et al 18 The rest paper structured follows In Section 2 provide preliminaries related active integrity straints In Section 3 discuss semantics grounded repairs While deﬁnitions motivated approximation ﬁxpoint theory semantics given machinery start direct deﬁnition Next Section 4 background approximation ﬁxpoint theory In Section 5 deﬁne semantic operator AICs grounded ﬁxpoints correspond grounded repairs deﬁned Section 3 Next deﬁne approx imator operator Section 6 use derive AFTstyle semantics AICs study semantics relate existing semantics Afterwards Section 7 discuss relationship newly deﬁned semantics equallynamed semantics logic programming In Section 8 study complexity tasks related newly deﬁned semantics We conclude Section 9 Publication history The semantic operator grounded AICs resulting semantics grounded repairs origi nally proposed CruzFilipe 15 The approximator operator properties introduced Bogaerts CruzFilipe 6 Our current work combines results conference papers extends proofs examples detailed analysis connection approximation semantics AICs logic programming 2 Preliminaries active integrity constraints In section summarize previous work active integrity constraints AICs including results developed Flesca et al 27 Caroprese et al 12 Caroprese Truszczy nski 13 CruzFilipe et al 17 We assume ﬁxed set At atoms An interpretation database subset At In current paper following CruzFilipe et al 17 assume At ﬁnite set This restriction essential deﬁning semantics theorems prove exception complexity results comparison existing semantics deﬁned ﬁnite case A literal atom negation We dual literal vice versa denote dual literal l lD Propositional formulas deﬁned usual atoms formulas negation formula formula conjunction formulas formula The satisfaction relation databases DB formulas deﬁned usual DB DB 46 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 DB ϕ DB cid4 ϕ DB ϕ ψ DB ϕ DB ψ atoms formulas ϕ ψ An update action α form At We dual actions use α D denote dual action α Intuitively update actions represent changes database adds removes Formally transforms DB DB transforms DB DB A set update actions U consistent contain action dual A consistent set update actions U acts database DB executing actions simultaneously denote result operation U DB If α update action simply write αDB result applying α DB αDB Literals update actions related mappings lit ua lita lita ua inverse lit These mappings naturally extend sets literalsactions Deﬁnition 21 An active integrity constraint AIC rule r form l1 ln α1 αk 1 l1 ln We l1 ln body r denoted bodyr α1 αk head r litα D denoted headr The informal reading rule If li holds DB DB inconsistent It allowed repair inconsistency executing αi The body AIC represents constraint database adhere head represents set atoms allowed changed order ﬁx constraint case violated Intuitively atoms changed rule allows Furthermore actions able repair inconsistency detected body AIC corresponding duals literals 12 restrict actions allowed head Contrary seminal work AICs 27 consider propositional AICs allow ﬁrstorder variables note use Example 11 However restrictions work precisely range restrictedness ensure reduce propositional case means grounding An AIC called normal k 1 The normalization AIC form 1 set AICs l1 ln αi 1 k It follows informal explanation expect normalization preserve semantics Indeed case semantics AICs notorious exception semantics justiﬁed repairs 13 poses problems 17 In current paper assume explicitly mentioned AICs normal Extensions semantics deﬁne nonnormal AICs obtained normalization needed Deﬁnition 22 A set update actions U weak repair DB set η AICs shortly cid10D B ηcid11 action U changes DB U DB cid4 bodyr r η A minimal weak repair called repair Weak repairs head AICs account allow arbitrary changes database Example 23 Consider restriction b hold c d hold In propositional logic restriction expressed following formula b c d equivalently formulas b c b d Now AIC formalism provides ability express constraints control happen violated Assuming case wish modify b corresponding AICs b c b b d b B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 47 ﬁrst expresses b hold c constraint violated remove literals b second constraint similar d Despite inclusion explicit repair actions heads rules notions weak repair repair account Suppose given database DB b In case b c d repairs furthermore sets b b c weak repairs cases actions change DB result negates literal body rules Sets c c d solve inconsistency include actions change database considered weak repairs Sets inconsistent clear state update DB include Applying normalization yields following set AICs b c b d b c b b d b It immediate check discussed respect original set AICs applies normal ized counterpart intuitively constraints represent knowledge sets repairs weak repairs remain unchanged cid2 We review semantics AICs deﬁned intention allow changes explicitly allowed AICs founded weak repairs 12 justiﬁed weak repairs 13 wellfounded weak repairs 17 Deﬁnition 24 12 A set update actions U founded respect cid10D B ηcid11 α U rule r η α headr U cid14DB bodyr U cid14 U α A founded weak repair weak repair founded The intuition deﬁnition element good repair reason element removed constraint violated removed element allowed ﬁx Example 25 Consider database DB b set η normalized AICs previous example r1 r2 r3 b c b d b c b b d b r4 The set founded respect cid10D B ηcid11 action removed rule r1 applicable occurs headr1 Likewise set b founded repair cid10D B ηcid11 On hand U c d founded If remove c U obtaining U cid14 d U cid14DB b d U cid14DB bodyr1 c headr1 likewise r3 U cid14DB cid4 bodyr2 U cid14DB cid4 bodyr4 support c U In case support d Caroprese Truszczy nski 13 discovered founded repairs exhibiting circularity support The fol lowing example CruzFilipe et al 17 Example 26 Consider following set AICs η expressing b equivalent case false c true b true b b b c c b c c r5 r6 r7 r8 48 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 Suppose database DB b There repairs cid10D B ηcid11 U1 b U2 c Intuitively rules suggest U2 preferred repair includes action suggested AIC satisﬁed U2 founded removing element yields observed r7 r8 provide support c given state DB However U1 founded repair If remove U1 obtain U cid14 applicable headr5 Dually remove b obtain U cid14cid14 b headr6 Thus actions U1 founded founded repair U cid14cid14 1 1 b U cid14 1DB r5 1 DB b r6 applicable The problem example property founded repair excludes individual actions supported remaining ones sets actions characteristic In order avoid unwanted characteristic Caroprese Truszczy nski 13 proposed considering justiﬁed repairs deﬁne1 Deﬁnition 27 13 Let U set update actions cid10D B ηcid11 database The noeffect actions respect DB U neffDBU actions change DB U DB neffDBU DB UDB DB UDB α αDB DB αUDB UDB The set nonupdatable literals AIC r nupr contains body literals r occur head r nupr bodyr lit headrD cid2 cid3 U closed η r η uanupr U implies headr U cid4 U justiﬁed action set minimal superset neffDBU closed η U justiﬁed weak repair weak repair U neffDBU justiﬁed action set Although notion closed set actions database account role deﬁnition justiﬁed weak repairs deﬁnition justiﬁed action set actions change database included In normalized case considered justiﬁed weak repairs minimal respect set inclusion justiﬁed repairs Example 28 In setting Example 26 sets nonupdateable literals follows nupr5 b nupr6 nupr7 nupr8 b The founded repair U1 justiﬁed First observe neffU1 c assuming b c atoms language Consider U cid14 U1 U cid14 neffU1 c uanupr cid2 U cid14 neffU1 r η U cid14 neffU1 subset U1 neffU1 containing neffU1 trivially closed η In contrast repair U2 justiﬁed In case neffU2 b proper subset U2 U cid14 Then r7 r8 satisfy uanupr U cid14 neffU2 b cases headr c Since headr b conclude U cid14 neffU2 closed η cid2 The relation founded justiﬁed weak repairs established Caroprese Truszczy nski 13 Lemma 29 Let DB database η set AICs DB U set update actions DB If U justiﬁed weak repair cid10D B ηcid11 U founded weak repair cid10D B ηcid11 One main issues notion justiﬁed repair restrictive Interestingly seen example originally given Caroprese Truszczy nski 13 reproduce 1 Caroprese Truszczy nski 13 formally deﬁne circularity support discuss justiﬁed repairs avoid We informal argument sustain claim discussion Proposition 37 49 r9 r10 r12 r13 Example 210 Consider following set AICs η B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 b b b b r11 Consider database DB b This database inconsistent satisfy r9 possible repair U b Furthermore repair intuitively compatible η rule r9 requires remove DB triggers r11 forces remove b The repair U founded different reason remove U r10 applicable head includes removing b U makes r11 applicable head includes b Caroprese Truszczy nski 13 considered instance circularity support 17 discussion The repair U justiﬁed neffU taking U cid14 U cid14 neffU trivially closed η rule nonupdateable literals body cid2 A different attempt resolve problems circularity posed founded repairs avoiding restrictiveness justiﬁed repairs introduction wellfounded repairs CruzFilipe et al 17 kind repairs motivated operational approach directly inspired syntax AICs Deﬁnition 211 17 A weak repair U cid10D B ηcid11 wellfounded exists sequence actions α1 αn U α1 αn 1 n rule ri U i1DB bodyri αi headri U i1 α1 αi1 Example 212 In setting Example 26 wellfounded repair cid10D B ηcid11 c r7 r8 rules applicable DB Likewise repair U Example 210 wellfounded constructed applying ﬁrst r9 introducing r11 cid2 However wellfounded repairs behave unexpectedly Example 213 Let η set AICs containing b b b c c r14 consider DB There wellfounded repairs cid10D B ηcid11 U1 b obtained applying ﬁrst r13 r12 U2 c obtained applying ﬁrst r12 r14 It arguable U2 preferable reasonable apply r13 r12 applicable action solves inconsistency detected r12 repairs r13 conversely However wellfounded semantics AICs infer restriction cid2 In example interesting note U2 founded repair Indeed r12 supports support inde pendent b c furthermore r14 supports c present However U1 founded action b supported r13 applicable added DB The examples exist founded weak repairs wellfounded wellfounded weak repairs founded These relations established CruzFilipe et al 17 connection justiﬁed weak repairs Lemma 214 Let DB database η set AICs DB U set update actions DB If U justiﬁed weak repair cid10D B ηcid11 U wellfounded weak repair cid10D B ηcid11 We interested shifting property Originally deﬁned Marek Truszczynski 31 context revision programming property later transferred active integrity constraints 13 Intuitively semantics AICs possesses shifting property uniformly replacing literals duals preserves semantics hand semantics treats truth falsity elements database symmetrically Deﬁnition 215 Let S At set atoms l literal The shift l respect S deﬁned shiftS l cid4 l S l lD The shift function extended sets literals update actions AICs straightforward manner 50 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 Deﬁnition 216 We semantics AICs shifting property cid10D B ηcid11 S At U repair cid10D B ηcid11 accepted semantics shiftS U repair cid10shiftS DB shiftS ηcid11 accepted semantics If semantics shifting property reduce situation case DB taking S DB All semantics discussed section shifting property 3 Grounded repairs Founded wellfounded justiﬁed repairs introduced purpose characterizing class repairs actions supported reason having set selfsupporting Ie try avoid certain forms circularity support Sometimes requires repairs constructible ground motivation deﬁning wellfounded repairs However notions exhibit unsatisfactory examples exist founded repairs circular support Example 26 repairs circular support justiﬁed 17 In section introduce new semantics grounded repairs aimed directly tackling issue Grounded repairs motivated Example 26 noticed deﬁnition founded repairs manage capture groups selfsupporting arguments Indeed repair U1 founded It consists actions b removed U1 AIC body violated head action question However remove simultaneously notice rule longer applies As conclude actions selfsupporting reason actions repair choice action Our deﬁnition grounded weak repair aimed directly avoiding kind situations Deﬁnition 31 A set update actions U grounded respect cid10D B ηcid11 V cid3 U rule r η VDB bodyr headr U V A grounded weak repair weak repair grounded As seen deﬁnition groundedness slight variant notion foundedness instead consid ering happens action dropped proposed set update actions consider arbitrary removals A ﬁrst observation respect groundedness grounded weak repairs minimal grounded weak repair repair Proposition 32 All grounded weak repairs cid10D B ηcid11 minimal repairs Proof Suppose U grounded weak repair U minimal exists V cid3 U weak repair Since U grounded exist AIC body satisﬁed VDB contradicting fact V weak repair cid2 Thus notion groundedness intrinsically embodies principle minimality change unlike kinds weak repairs previously deﬁned Proposition 33 Let DB database η set AICs DB U grounded repair cid10D B ηcid11 Then U founded wellfounded Proof Assume U grounded repair cid10D B ηcid11 The fact U founded follows immediately deﬁnition grounded repair action α V U α strict subset U Hence groundedness U rule r headr U V α body satisﬁed VDB We ﬁnd U founded Now construct sequence subsets U illustrates U wellfounded For sequence start U0 construct Ui Ui1 ui picking rule r cid10D B ηcid11 headr ui U Ui1DB bodyr Since U grounded Ui1 cid3 U rule exists construction Ui U But U ﬁnite sequence converges U U wellfounded repair cid2 However notion grounded repair strictly stronger Example 26 presented earlier shows forms circular justiﬁcations avoided grounded repairs Example 34 Example 26 continued The repair U1 b founded repair grounded taking V notice AIC head body satisﬁed VDB The natural repair U2 c founded immediate verify grounded cid2 Likewise wellfounded repairs grounded B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 51 Example 35 Example 213 continued Consider η Example 213 DB As shown earlier founded repairs cid10D B ηcid11 U1 b U2 c We observed U1 founded grounded V set update actions rule r headr U V body satisﬁed VDB We grounded repairs founded wellfounded example shows correspond intersection classes Example 36 Consider following set AICs η r15 r16 r17 r18 r19 b b b b b b c c b c b b c r20 Let DB Then U b c repair cid10D B ηcid11 ﬁrst constraints require b included database They straightforward manner Starting database b holds rule r17 ﬁrst enforces removal b Next rule r15 adds subsequently rule r16 adds b While combination constraints unnatural use enforce inclusion b database possible type constraints written different developers maintaining database having different concerns The rules state 2element subset U repair Given rule r16 rule r19 redundant However argument holds database In example U founded rules ensure wellfounded starting forced apply rules r15 r16 r18 order However U grounded V b V cid3 U rule r headr c body satisﬁed VDB cid2 In situation U reasonable observe support actions circular rules U founded applicable DB Also note VDB b database given set η behaves awkwardly applicable AIC tells remove b repair VDB actually c We feel example weakens case studying grounded repairs consensual approach different notions repair express preferences In case cid10D B ηcid11 admits grounded repair sensible allow repair larger class repair founded wellfounded good candidate The discussion Caroprese Truszczy nski 13 Section 8 proposes methodology choose repair restrictive category justiﬁed founded We advocate similar approach including grounded repairs possible choices We investigate relation grounded justiﬁed repairs ﬁnd justiﬁed repairs grounded conversely line earlier claim notion justiﬁed repair strong Proposition 37 Let DB database let η set normal AICs DB If U justiﬁed repair cid10D B ηcid11 U grounded Proof Let U justiﬁed repair cid10D B ηcid11 V cid3 U Then V neffU closed η rule r η uanupr V neffU headr V neffU Since V U uanupr U neffU headr U neffU U closed η But headr V neffU headr U V We need V bodyr On hand uanupr V neffU implies VDB nupr neffU neffV hand headr U know litheadrD DB actions U change DB VDB litheadrD headr V As r normal literals bodyr VDB bodyr Hence rule r V bodyr headr U V showing U grounded cid2 This proof use hypothesis U repair This fact mentioned earlier consider normal AICs paper By Theorem 4 13 justiﬁed weak repairs minimal η consists normal AICs Recall Example 210 CruzFilipe et al 17 point justiﬁed repairs eliminate natural repairs This example shows notion justiﬁed repair stricter grounded repair 52 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 Fig 1 Relative inclusions sets founded F wellfounded WF grounded G justiﬁed J repairs All inclusions strict Example 38 Example 210 continued Although repair U b cid10D B ηcid11 justiﬁed grounded V cid3 U rule derives b rule derives cid2 As discussed earlier case ﬁrst rule clearly motivates action rule requires b This contrast Example 26 clear reason include b repair Hence grounded repairs avoid type unreasonable circularities restrictive justiﬁed repairs We summarize relations different types repairs Fig 1 4 Preliminaries lattices operators approximation ﬁxpoint theory 41 Lattices operators ﬁxpoints In section summarize ideas deﬁnitions main results approximation ﬁxpoint theory AFT use remainder paper A partially ordered set poset cid10L cid11 set L equipped partial order reﬂexive antisymmetric transitive relation As usual write x y abbreviation x y x cid4 y If S subset L x upper bound lower bound S s S holds s x x s respectively An element x upper bound greatest lower bound S upper bound smaller upper bound lower bound greater lower bound respectively If S upper bound greatest lower bound denote lubS glbS respectively As custom greatest lower bound meet upper bound join use S lubS x y lubx y We cid10L cid11 complete lattice related notations subset L upper bound greatest lower bound A complete lattice element L greatest element cid19 S glbS x y glbx y A lattice L distributive distribute x y z x y x z x y z x y x z x y z L A bounded lattice L complemented element x L complement element x L satisfying x x x x cid19 A Boolean lattice distributive complemented lattice cid6 cid6 cid5 cid5 L Since apply results ﬁnite databases sake simplicity assume L ﬁnite text All presented results easily generalize inﬁnite setting An operator O L L monotone x y implies O x O y An element x L ﬁxpoint O O x x Every monotone operator O complete lattice ﬁxpoint denoted lfpO limit upper bound increasing sequence xiiN deﬁned x0 xi1 O xi Bogaerts et al 7 called point x L grounded O v L O v x v holds x v They called point x L strictly grounded exist y y x O y x y They explained intuition underlying concepts assumption elements L sets facts kind relation subset relation sets case point x grounded contains facts sanctioned operator O sense remove x operator add Bogaerts 5 showed Boolean lattices notions groundedness strict groundedness coincide In paper lattices application Boolean use notions interchangeably 42 Approximation ﬁxpoint theory Given lattice L approximation ﬁxpoint theory AFT 20 uses bilattice L2 We deﬁne projection functions pairs usual x y1 x x y2 y Pairs x y L2 approximate elements interval x y z x z z y We x y L2 consistent x y x y nonempty use Lc denote set consistent elements Elements x x Lc called exact constitute embedding L L2 We abuse notation use tuple x y interval x y interchangeably The precision ordering L2 deﬁned x y p u v x u v y In case u v consistent means x y approximates elements approximated u v words u v x y If L complete lattice cid10L2 pcid11 complete lattice AFT studies ﬁxpoints lattice operators O L L operators approximating O An operator A L2 L2 approximator O p monotone property Ax x O x O x x Approximators internal Lc map Lc Lc As usual restrict attention symmetric approximators approximators B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 53 A x y Ax y1 A y x2 Denecker et al 22 showed consistent ﬁxpoints supported stable wellfounded uniquely determined approximators restriction Lc deﬁne approximators Lc AFT studies ﬁxpoints O ﬁxpoints A The AKripkeKleene ﬁxpoint p ﬁxpoint A approximates ﬁxpoints O A partial Astable ﬁxpoint pair x y x lfp A y1 y lfp Ax 2 A y1 denotes operator L L z cid21 Az y1 analogously Ax 2 The Awellfounded ﬁxpoint precise p minimal partial Astable ﬁxpoint An Astable ﬁxpoint O ﬁxpoint x O x x partial Astable ﬁxpoint This equivalent A partial Agrounded ﬁxpoint consistent pair x y v L Ax v y v2 v condition x lfp A x1 y v All partial Astable ﬁxpoints partial Agrounded ﬁxpoints Awellfounded ﬁxpoint precise partial Agrounded ﬁxpoint 8 The AKripkeKleene ﬁxpoint O constructed limit monotone induc tion A For Awellfounded ﬁxpoint similar constructive characterization worked Denecker Vennekens 23 Deﬁnition 41 An Areﬁnement x y pair x cid14 y cid14 L2 satisfying following conditions x y p x ii x cid14 x Ax y cid14 p Ax y cid14 y cid142 y cid14 y An Areﬁnement strict x y cid4 x cid14 y cid14 We ﬁrst type reﬁnements application reﬁnements second type ii unfoundedness reﬁnements cid14 y cid14 Areﬁnement x y A clear context write x y x cid14 y cid14 If x Deﬁnition 42 A wellfounded induction A sequence xi yiin n N x0 y0 cid19 xi1 yi1 Areﬁnement xi yi n A wellfounded induction terminal limit xn yn strict Areﬁnements A wellfounded induction algebraical generalization wellfounded model construction deﬁned Van Gelder et al 40 The ﬁrst type reﬁnement corresponds making partial structure precise applying Fittings immedi ate consequence operator second type reﬁnement corresponds making structure precise eliminating unfounded set For given approximator A different terminal wellfounded inductions A Denecker Vennekens 23 showed limit equals Awellfounded ﬁxpoint O Furthermore A symmetric Awellfounded ﬁxpoint O fact tuple wellfounded induction A consistent 43 Logic programming AFT A normal2 logic program P set rules r form h l1 ln 2 h atom called head r denoted headr li literal l1 ln called body r denoted bodyr A rule form 2 called simple li equals h h logic program simple consists simple rules The set interpretations 2At forms lattice equipped order The truth value t f propositional formula ϕ structure I denoted ϕ I deﬁned usual With logic program P associate immediate consequence operator 39 T P maps structure I T P I p r P headr p bodyrI t Bogaerts et al 7 called grounded ﬁxpoints T P grounded models P 2 Sometimes logic programs deﬁned disjunctive rules In current paper consider normal logic programs logic programs head single atom In propositions explicate fact programs normal emphasize results longer guaranteed hold general case 54 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 A B A t f u B f f f f t t f u u u f u A f t u A t f u Fig 2 The Kleene truth tables conjunction negation 29 Example 43 Consider following logic program P cid4 cid7 p q p q Its immediate consequence operator T P represented following graph cid19 p q p q T P monotone operator ﬁxpoint p As p grounded ﬁxpoint To p q grounded notice taking v p T P v p q p v p q cid2 v cid2 2At fourvalued interpretations pairs In context logic programming elements approximation lattice cid14 I2 We identify cid14 I I1 I2 interpretations The pair I1 I2 approximates interpretations I interpretation I fourvalued interpretation I I We concerned consistent called partial threevalued interpretations tuples I I1 I2 I1 I2 For interpretation atoms I1 true t I atoms I2 I1 unknown u I atoms false f I If I threevalued interpretation ϕ formula write ϕI standard threevalued valuation based Kleene truth tables Fig 2 cid8 cid9 2 I1 I Several approximators deﬁned logic programs The common Fittings immediate consequence operator cid6P 26 direct generalization T P partial interpretations cid6P I1 cid7 bodyrI t rule r P headr cid6P I2 cid7 bodyrI cid4 f rule r P headr Denecker et al 20 showed cid6P approximator T P wellfounded ﬁxpoint cid6P wellfounded model P deﬁned Van Gelder et al cid6P stable ﬁxpoints exactly stable models P deﬁned Gelfond Lifschitz In case operator cid6P y1 coincides immediate consequence operator GelfondLifschitz reduct 28 P respect interpretation y Example 44 Consider following logic program P cid4 cid7 p q q p It stable models p q Its wellfounded model equals KripkeKleene model I p q partial interpretation p q unknown To I KripkeKleene model suﬃces cid9 2 element approximation lattice ﬁxpoint cid6P interpretation value bodies u To I wellfounded model notice unfoundedness reﬁnements I Indeed I At hold 2At cid8 cid6P I2 I q I p derived ﬁrst rule p I symmetric argument Hence I p q unfoundedness reﬁnement To p stable model suﬃces note cid6P p p p p lfp cid6P p1 cid2 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 55 5 A semantic operator AICs In section set normal AICs induces operator suitably deﬁned lattice Given ﬁxed database DB interested sets update actions U U consistent ii action U modiﬁes DB Note second condition implies ﬁrst possible modify DB For atom At deﬁne cid10 ch DB Let furthermore denote set update actions modify DB A With notation A ch At A Note ch A deﬁned solely based initial sets update actions interested elements 2 database DB dependent instance given repair Following principle minimality change 4525 typically prefer smaller sets updates larger sets A cid11 smaller elements correspond better repairs according Therefore interested lattice cid102 principle The intuitive reading AIC r naturally suggests operator lattice deﬁned U DB bodyr add However naive deﬁnition lead operator internal A headr U obtain new element 2 2 illustrated instance following example A Example 51 Consider η A Now taking U body rule η satisﬁed DB In case A 2 Naively adding head U results set element 2 We expect semantic operator map U rule η indicates problems U DB solved adding changing DB cid2 A This kind problems inherent fact AICs rules dual heads occur formalisms AFT applied logic programming3 Intuitively operator Tη wish deﬁne satisfy following properties inertia Only change input rule warrants change This requirement consists parts Do add U reason TηU U headr r η UDB bodyr Do remove U reason U headrD r η UDB bodyr TηU cancellation If action U canceled rule η action dual result DB remains unchanged respect action Formally α U α D headr r η U DB bodyr α TηU α D TηU completeness If applicable rule body satisﬁed head contradict U head derived Formally headr r η UDB bodyr headrD U TηU It turns properties uniquely deﬁne operator 2 operator introduce following concept A In order constructive characterization 3 Notice instance default logic rules complementary literals head allowed However literals treated indepen dent statements derived separately In current setting update action p undo effect previously derived action p 56 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 Deﬁnition 52 Let U1 U2 sets update actions set atoms At The set U1 cid24 U2 deﬁned U1 cid24 U2 DB U1 U2 α α α D U1 U2 This operation models sequential composition repairs following sense given database DB action U1 changes DB action U2 changes U1DB U1 cid24 U2DB U2U1DB Observe set AICs include rule head head rules simultaneously applicable conjunction bodies unsatisﬁable However case applying makes applicable undoing effect ﬁrst In case operation deﬁned guarantees database reﬂects actions executed We note U1 cid24 U2 consistent U1 U2 Deﬁnition 53 Let DB database η set AICs DB The operator T DB η η U U cid24 headr r η UDB bodyr T DB 2 A 2 A deﬁned follows In words T DB η U obtained updating U heads AICs bodies satisﬁed U DB To operator welldeﬁned result applying yields consistent set actions observe syntactic restrictions AICs guarantee set headr r η U DB bodyr consistent Indeed set rules r1 r2 bodyr1 bodyr2 U DB bodyri 1 2 impossible mean U DB U DB From follows TηU consistent As DB clear context simply write Tη T DB η Proposition 54 The operator Tη operator 2 A satisﬁes inertia cancellation completeness Proof It easy verify Tη satisﬁes inertia cancellation completeness Now assume O 2 satisﬁes properties Let α action A U A Let V denote headr r η U DB bodyr Since α A know α D U We α O U α TηU U cid24 V We distinguish 3 cases A 2 A If α V α D U completeness α O U In case α D U V α U V holds α U cid24 V TηU If α D V rule r η α D headr U DB bodyr Since U DB bodyr litα holds U DB Since α changes DB know litα hold DB case α U By cancellation ﬁnd α O DB Since α U α D V α U cid24 V TηU If α V α D V inertia hold α O U α U In case holds α TηU U cid24 V α U Hence proven cases α O U α TηU result follows cid2 Example 55 Example 23 continued Consider set AICs η Example 23 DB b Then Tη b Indeed bodies rules satisﬁed heads elements Tη cid2 Proposition 56 Let DB database η set normal AICs DB U set update actions Then U weak repair cid10D B ηcid11 U ﬁxpoint Tη A Proof If U weak repair cid10D B ηcid11 certainly U 2 Also U DB cid4 bodyr r η TηU U If U weak repair cid10D B ηcid11 U DB bodyr r η TηU differs U headr cid2 Example 57 In general Tη need ﬁxpoints database satisfying η A simple unre alistic example η consists rules TηDB cid4 DB database DB cid2 Proposition 58 Let DB database η set normal AICs DB U set update actions Then U repair cid10D B ηcid11 U minimal ﬁxpoint Tη Proof Follows directly Proposition 56 deﬁnition repair cid2 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 57 Proposition 59 Let DB database η set normal AICs DB U 2 α U case α TηU α A Then U founded respect cid10D B ηcid11 Proof It follows deﬁnition Tη action α U following equivalent rule r η U αDB bodyr ii α TηU α Now U founded holds actions α U equivalent condition proposition ii holds α U cid2 This result gives intuition founded repairs allow circular dependencies deﬁnition founded repair checks individual action supported remaining ones allows dependency cycles Proposition 510 Let DB database η set normal AICs DB U weak repair cid10D B ηcid11 Then U wellfounded ordering α1 αn elements U αi Tηα1 αi1 1 n Proof This direct consequence deﬁnitions Tη wellfounded repair By deﬁnition U wellfounded exists ordering α1 αn elements U rule ri η U i1DB bodyri αi headri U denotes α1 αi Now condition rule ri η U i1DB bodyri αi headri equivalent condition αi TηUi1 result follows cid2 Proposition 511 Let DB database η set AICs DB A set update actions U grounded repair cid10D B ηcid11 U grounded ﬁxpoint Tη Proof Recall grounded strictly grounded ﬁxpoints Tη coincide We U grounded repair cid10D B ηcid11 iff U strictly grounded ﬁxpoint Tη First suppose U strictly grounded ﬁxpoint Tη This means exists set V cid3 U TηV U V From deﬁnition Tη follows immediately r rule VDB bodyr headr U V U grounded repair cid10D B ηcid11 Conversely assume U strictly grounded ﬁxpoint Tη let V subset U rule r VDB bodyr headr U V From deﬁnition Tη follows TηV U V TηV U V Since U strictly grounded follows V U cid2 The previous proposition illustrates Proposition 37 coincidence Indeed Bogaerts et al 7 shown stable ﬁxpoints given approximator grounded Caroprese Truszczy nski 13 Theorem 6 showed justiﬁed repairs stable models given derived logic program In following sections explore relationship ﬁrst deﬁne approximator Tη obtain notion stable repair Next Section 7 study relationship logic programs AICs depth Since grounded repairs built ground result corroborates informal claim justiﬁed repairs avoid circularity support stated Caroprese Truszczy nski 13 6 An approximator AICs In section deﬁne approximator Tη obtain set AFTbased semantics AICs based intuitions similar underlying groundedness semantics nonmonotonic reasoning A partial action set tuple U Uc Up Uc 2 A partial action set approximation set update actions It provides information update actions certainly applied actions Uc actions possibly applied actions Up If Uc Up U consistent We concerned consistent partial action sets If α A value α U denoted Uα Up 2 A A true denoted t α Uc α Up false denoted f α Uc α Up unknown denoted u α Uc α Up inconsistent denoted α Uc α Up Note partial action set characterized completely mapping A t f u induces Uc α A Uα t Up α A Uα t u 58 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 We exploit correspondence explicating partial action set mapping allows compact notation elegant deﬁnitions It seen U consistent Uα t f u α The intended interpretation consistent partial action set Ua true iff certainly changed U false iff certainly changed U unknown U leaves open changed The set A2 We U consistent partial action sets denoted P As P exactly consistent bilattice 2 twovalued Uc Up Uα t f α case identify U action set Uc The truth order t truth values deﬁned f t u t t f t t t The inverse truth value f 1 f u 1 u 1 t t A consistent partial database mapping DB At t f u The intended reading DBa true 1 certainly database DBa false certainly database DBa unknown If U P consistent partial action set DB regular database deﬁne UDB partial database UDB cid21 Ua f DBa DBa1 Ua t u DBa t DB DBa f Deﬁnition 61 Given partial database DB set AICs η update action α deﬁne support α respect cid10DB ηcid11 suppDBηα max t nuprDB r η headr α nuprDB refers standard threevalued truth evaluation formula4 nupr partial interpretation DB based Kleenes truth tables 29 Fig 2 Intuitively means support action α highest truth value nonupdateable body rule η α head Example 62 Consider DB following set η b c d Consider U b c b c d Then UDB cid21 t b cid21 t c cid21 t d cid21 u In case suppUDBηa t suppUDBηa u cid2 Deﬁnition 63 Given DB η deﬁne operator Tcid10D Bηcid11 P P U P α A If Uα f Tcid10D Bηcid11Uα suppUDBηα If Uα t Tcid10D Bηcid11Uα suppUDBηα D 1 Otherwise Uα u suppUDBηα t suppUDBηα D f Tcid10D Bηcid11Uα t suppUDBηα D t suppUDBηα f Tcid10D Bηcid11Uα f Tcid10D Bηcid11Uα u When DB clear context write Tη Tcid10D Bηcid11 Deﬁnition 63 motivated follows Assume U partial update set containing information intended update In case TηU represents revised update AICs η In case Uα f α element partial update set hand The way add α update rule supports α captured suppUDBηα The case Uα t completely symmetrical case reason removing α update hand support dual In case Uα u information α shouldnt update In case derive α update support α sure support dual α D Similarly derive α update support α D certainly α In cases derive α update 4 Technically nupr set literals identify conjunction literals B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 59 Since suppUDBηα suppUDBηα D 1 consistent U consistent operator ﬁned P Tcid10D Bηcid11U consistent U Recall Denecker et al 22 showed suﬃces deﬁne approximator consistent bilattice Ac Tη candidate approximator Tη The proposition shows Using fact P 2 case Proposition 64 Tη approximator Tη Proof First Tη p monotone To ﬁrst note Kleenevaluation p monotone Hence α A functions map U suppUDBηα suppUDBηα D p monotone Now α A suppose Ucid14 p U Then suppUcid14DBηα p suppUDBηα suppUcid14DBηα D p suppUDBηα D We TηUcid14α p TηUα case analysis deﬁnition TηUα If Uα f Ucid14α f Ucid14 p U In case TηUcid14α suppUcid14DBηα p suppUDBηα TηUα The case Uα t similar Assume Uα u If suppUDBηα t suppUDBηα D f TηUα t suppUcid14DBηα t suppUcid14DBηα f Hence Ucid14α u trivially proven In case Ucid14α t TηUcid14α suppUcid14DBηα D 1 t case Ucid14α f TηUcid14a suppUcid14DBηα t Hence cases TηUα TηUcid14α claim follows The case suppUDBηα D t suppUDBηα f similar previous In cases TηUα u TηUcid14α p TηUα trivially satisﬁed Secondly twovalued update sets Tη Tη coincide U TηU TηU Take α A prove claim case analysis deﬁnition TηU α If U α f TηUα t rule r η U DB bodyr headr α Since bodyr nupr litα D conclude TηU α true suppU DBηα t TηU α t The case U α f similar The case U α u occur U twovalued cid2 Since Tη approximator deﬁnes family semantics AICs Deﬁnition 65 Let cid10D B ηcid11 database A partial stable repair cid10D B ηcid11 partial update set U U partial Tηstable ﬁxpoint A stable repair partial stable repair twovalued The AFTwellfounded repair cid10D B ηcid11 Tηwellfounded ﬁxpoint general partial update set The KripkeKleene repair cid10D B ηcid11 TηKripkeKleene ﬁxpoint general partial update set A partial grounded repair cid10D B ηcid11 partial update set U U partial Tηgrounded ﬁxpoint Bogaerts et al 8 A grounded repair partial grounded repair twovalued The terminology deﬁnition uses repairs certain classes ﬁxpoints semantic operator It follows easily twovalued update sets called repair deﬁnition repairs according AIC terminology This paper ﬁrst work studies partial nontwovalued repairs The wellfounded semantics induced AFT general differ existing wellfounded semantics AICs Example 612 To distinguish use term AFTwellfounded semantics It follows directly Bogaerts et al 8 Proposition 32 Proposition 511 grounded repairs deﬁned Deﬁnition 65 coincide Deﬁnition 31 All classes repairs new We illustrate semantics means examples Example 66 Consider following set η AICs b c c b b c b b 60 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 DB Now Tηwellfounded ﬁxpoint computed limit wellfounded induction It starts U0 maps cid21 u b cid21 u c cid21 u U0 is5 partial action b c Here suppU0DBηa t suppU0DBηb u suppU0DBηc u suppU0DBηa f suppU0DBηb u suppU0DBηc f Hence U1 TηU0 cid21 t b cid21 u c cid21 u reﬁnement U0 Now veriﬁed U1 ﬁxpoint Tη This KripkeKleene ﬁxpoint It partial repair set provides information added uncertain b c A wellfounded induction continues unfoundedness reﬁnement The partial update set U2 cid21 t b cid21 u c cid21 f unfoundedness reﬁnement U1 This follows easily fact U3 TηU2 cid21 t b cid21 t c cid21 f Furthermore U3 application reﬁnement U2 Since exact point Tηwellfounded ﬁxpoint Tη It clearly intended repair example Note example unfoundedness reﬁnements care minimizations repairs cid2 Example 67 Consider following set η AICs b b b b c c DB Intuitively expect c element good repairs following minimality change princi ple actions good repairs Now Tηwellfounded ﬁxpoint computed limit wellfounded induction It starts U0 cid21 u b cid21 u c cid21 u Here suppU0DBηa u suppU0DBηb u suppU0DBηc u suppU0DBηa f suppU0DBηb f suppU0DBηc f Hence TηU0 U0 U0 TηKripkeKleene ﬁxpoint A wellfounded induction continue unfoundedness reﬁnements Indeed consider U1 cid21 f b cid21 f c cid21 u Since TηU1 cid21 f b cid21 f c cid21 t holds U1 unfoundedness reﬁnement U0 Finally conclude U2 TηU1 Tηwellfounded ﬁxpoint This corresponds intended repair cid2 5 Recall simplicity characterize partial action sets induced truth function B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 61 As expected set AICs twovalued wellfounded repair That simply ask mean set AICs unambiguously identify single repair The following example illustrates case It illustrates speciﬁc example Tη stable repairs provide solution corresponds intuitions Example 68 Consider following set η AICs b b b c c DB Intuitively η good repairs The ﬁrst rules state b added order ﬁx violated constraint b Depending choice rule determines c repaired The intended repairs c b Let investigate different AFTstyle semantics case Consider U0 cid21 u b cid21 u c cid21 u Here holds suppU0DBηa u suppU0DBηb u suppU0DBηc u suppU0DBηa f suppU0DBηb f suppU0DBηc f Hence TηU0 U0 U0 TηKripkeKleene ﬁxpoint Furthermore claim unfoundedness reﬁnements U0 U0 Tηwellfounded ﬁxpoint To claim holds notice unfoundedness reﬁnement U0 consist making subset U b c false way α U TηU0U fα f Assume U In order TηU0U fa false b t U0U f body rule deﬁning unknown true That possible U From similar argument ﬁnd b U c U Trivially intended repairs precise wellfounded ﬁxpoint Now let check U c stable repair For need verify U lfpTη U1 Deﬁne U0 Then U0 U cid21 u b cid21 f c cid21 u Hence TηU0 U cid21 t b cid21 u c cid21 u U1 TηU0 U1 Similarly U1 U cid21 t b cid21 f c cid21 u Hence TηU1 U cid21 t b cid21 f c cid21 t U2 TηU1 U1 U Furthermore TηU2 U U2 U ﬁnd U Tηstable ﬁxpoint The case b similar It veriﬁed Tη stable ﬁxpoints Due minimality contain b subsets c But U stable repair minimal strict subset c stable repair cid2 Hence example Tηstable repairs capture intended semantics We omit examples grounded ﬁxpoints included Section 3 62 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 Properties AFTstyle semantics We AFTstyle semantics nicely invariant shifting Proposition 69 Tη Tη commutes shifting set S At shifts Tcid10D Bηcid11 Tcid10shiftS DBshiftS ηcid11 Proof The clue proving proposition fact action α suppUDBηα suppUshiftS DBshiftS ηshiftS α Then result easily follows fact Tη deﬁned entirely based supp function cid2 Corollary 610 All AFTstyle semantics AICs shifting property Proposition 611 If AFTwellfounded repair twovalued wellfounded deﬁned CruzFilipe et al 17 Proof Let Uiik wellfounded induction Tη For deﬁne Ui α A Uiα t We prove following claim induction length k wellfounded induction note restrict ﬁnite wellfounded inductions assume At ﬁnite Claim There exists sequence α1 αn Uk α1 αn 1 n rule ri α1 αi1DB bodyri αi headri From claim taking terminal wellfounded induction yields desired result We claim holds The claim trivial k 0 Assume claim holds k holds k 1 Thus assume α1 αn sequence Uk α1 αn satisfying condition If Uk1 unfoundedness reﬁnement Uk Uk1 Uk Hence assume Uk p Uk1 p TηUk In case Uk1 Uk β j 1 j m sequence elements β j TηUkβ j t For j let U cid14 j denote α1 αn β1 β j We claim sequence α1 αn β1 βm satisﬁes condition claim To note deﬁnition Tη follows j 1 m rule r j nuprUkDB t headr j β j Furthermore j holds U cid14 j1 t Since β j U j1 bodyr j j1 t Hence claim holds k 1 cid2 p Uk nupr j1 U cid14 U cid14 Example 612 The converse Proposition 611 hold illustrated Example 213 The intuitive repair U2 c AFTwellfounded repair cid10D B ηcid11 However wellfounded repair U1 b cid2 Proposition 613 All Tηstable repairs justiﬁed Proof We safely assume U repair DB Tηstable repair Before starting actual proof introduce couple auxiliary operators For set update actions V let extV denote V neffU DB Note extV consistent V U For set update actions V let closureV denote closureV V headr uanupr V Now deﬁne operator sets update actions O V cid21 closureextV neffU DB Below prove following claims Claim 1 U minimal preﬁxpoint O U justiﬁed repair cid10D B ηcid11 Claim 2 For literal l ual extDB lVU DB t Claim 3 For update action α α closureextV suppVU DBηα t Claim 4 For set update actions V U TηV U1 O V B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 63 Now assume U Tηstable repair It clear O monotone operator unique minimal preﬁxpoint ﬁxpoint Since U repair ﬁxpoint O need minimal Assume U cid14 U preﬁxpoint O This means O U cid14 U cid14 U1 O U cid14 TηU cid14 preﬁxpoint Tη U 1 Since U Tηstable repair U preﬁxpoint Tη U 1 U U cid14 U cid14 needed prove We conclude U justiﬁed repair U cid14 Hence U U cid14 Claim 1 Recall U repair The claim follows immediately deﬁnition justiﬁed repair Preﬁxpoints closure operator sets update actions closed η Hence U minimal preﬁxpoint O iff extU minimal set update actions contains neffU DB closed η Claim 2 Pick literal l First assume ual extV V neffU DB We lVU DB t We consider cases If ual neffU DB lDB t U change value l Thus lVU DB lDB t If ual neffU DB hold ual V U Since ual U action U changes DB hold lDB f Now ual V V U changes value l lVU DB lDB1 t case For direction assume lVU DB t We need ual extV V neffU DB Assume ual neffU DB ual V Since lVU DB t U p V U l U t Since l neffU DB means lDB f Now lVU DB t lDB1 Hence hold V U changes value l Since lDB f means ual V exactly needed prove Claim 3 Let α update action It holds suppVU DBηα t rule r headr α cid14 VU DB t From Claim 2 follows cid14 nupr l cid14 nupr element extV condition α nuprVU DB t This means literal l equivalent condition literal l closureextV Claim 4 Take α A set V update actions It holds α TηV U 1 following holds V U α t suppVU DBηα D f ii V U α f suppVU DBηα t iii V U α u suppVU DBηα t suppVU DBηα D f In ﬁrst case α V α extV α closureextV If suppVU DBηα t cases ii iii Claim 3 α closureextV Thus cases α closureextV Now U repair U U ﬁxpoint Tη Since V U p U U α TηV U 1 entails α TηU U 1 α U Thus α neffU DB ﬁnd α closureextV neffU DB O V needed prove cid2 Example 614 The converse Proposition 613 hold Consider following set η AICs b b b DB In case b justiﬁed repair cid10D B ηcid11 stable repair To stable repair suﬃces note Tη b b lfp Tη b1 cid4 b To justiﬁed repair note b set closed η While converse Proposition 613 hold general broad class active integrity constraints hold We ﬁrst deﬁne class prove case Deﬁnition 615 A set AICs η called unipolar rules r r cid14 η headr headr cid14D Unipolar AICs sense practice example tables removing data option 64 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 Proposition 616 If η unipolar justiﬁed repair cid10D B ηcid11 Tηstable Proof To prove theorem following strengthening Claim 4 proof Proposition 613 Claim 4 cid14 For set update actions V U TηV U1 O V cid14 It follows easily U minimal ﬁxpoint O iff U minimal ﬁxpoint Tη U 1 result follows Claim 1 proof Proposition 613 deﬁnition Tη stable ﬁxpoint Claim 4 One direction claim proven Claim 4 proof Proposition 613 inclusion holds Take α A set V U update actions α O V α TηV U 1 Since α O V holds α closureextV Claim 3 suppVU DBηα t This means cid14 α D holds rule r η headr α Since η unipolar rules r suppVU DBηaD f From deﬁnition Tη ﬁnd TηV U α t α TηV U 1 needed prove cid2 cid14 η headr From Proposition 37 states justiﬁed repairs grounded easily ﬁnd justiﬁed repairs AFTwellfounded repair relate Corollary 617 The AFTwellfounded repair KripkeKleene repair approximate justiﬁed repairs 7 Relationship logic programming Caroprese Truszczy nski 13 deﬁned translation logic programs AICs follows Deﬁnition 71 Let r normal logic programming rule l1 ln We deﬁne active integrity constraint aicr l1 ln Furthermore P normal logic program deﬁne cid15 aicP aicr r P Caroprese Truszczy nski 13 showed simple programs P interpretation I stable model P I viewed update set justiﬁed repair cid10aicP cid11 Since aicP unipolar earlier results Propositions 613 616 follows equivalent condition I TaicPstable repair The result corollary following stronger theorem Theorem 72 Let P simple normal logic program I partial interpretation It holds I partial stable model P I partial stable repair cid10aicP cid11 The proof theorem follows later makes use Theorem 76 Since wellfounded model logic program precise partial stable model analogous relationship holds setting AICs immediately ﬁnd following corollary Corollary 73 Let P normal logic program The wellfounded model P coincides AFTwellfounded repair cid10aicP cid11 While operation aic preserves partial stable wellfounded ﬁxpoints preserve grounded ﬁxpoints KripkeKleene ﬁxpoint following examples illustrate In cases intuition inertia present AICs logic programs responsible difference Example 74 Consider logic program cid4 cid7 p q q p Pg B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 65 Since TPg ﬁxpoints Pg grounded models In case cid7 cid4 aicPg p q p p q q Now cid10aicPg cid11 grounded repair p q cid2 Example 75 Consider logic program Pkk b The KripkeKleene model program maps b f The corresponding AIC aicPkk b b KripkeKleene repair maps b u unknown need changed cid2 It seen previous example AICs KripkeKleene semantics bad deriving thing need changed The wellfounded semantics stronger respect In certain sense intuition inertia underlying AICs lies foundation discrepancy Now logic program ming KripkeKleene semantics exhibits similar behavior Consider instance logic program P This program KripkeKleene model atom false expected However adding trivial rule p p simulates inertia results program KripkeKleene model p unknown Inertia responsible discrepancy Example 74 Intuitively aicPg example corresponds logic program p q p p q p q q P cid14 g Indeed aicPg states p q present database add p add inertia stays reason remove similarly q P cid14 Pg differ rules p p q q simulate inertia The discussion provides intuitions transformation preserves AFT semantics look like In following theorem formalized Theorem 76 Suppose DB update actions η form The mapping ua induces isomorphism lattices 2At 2 Ac Let lpη denote following logic program 2Atc 2 A lpη nupr r η headr At partial interpretation I TηuaI uacid6lpηI Hence AFT semantics cid10D B ηcid11 coincide case equallynamed semantics logic program lpη Proof By deﬁnition cid6lpηI1 At bodyrI t r lpη headr At nuprI t r η headr At litheadr r η nuprI t At litα suppIηα t At I t I t I t Now α A holds suppIηα D f rules α D head From deﬁnition Tη follows 66 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 TηuaI1 α suppIηα t αuaI t TηuaI1 uacid6lpηI1 Similarly ﬁnd TηuaI2 uacid6lpηI2 result follows cid2 Proof Theorem 72 For logic program P let trivP denote logic program trivP P p p p At It wellknown6 partial stable models P trivP Now result easily follows facts P simple lpaicP trivP aic adds literal body rule r headr lp removes literal P simple literal start additionally adds trivial rules triv adds ii triv lp preserve partial stable models cid2 Example 77 Theorem 76 hold general unipolar AICs Consider instance following sets AICs cid4 cid7 b b η1 η2 These equivalent AFT semantics For ﬁrst KKrepair cid21 f b cid21 f KKrepair cid21 u b cid21 u However translation logic programs rules positive actions head cid2 The reason equivalence hold previous example rules head ignored context AICs rules semantic difference Limitations related work In Section studied mappings sets active integrity constraints logic programs semantics formalisms relate We brieﬂy discuss restrictions approach In translation AICs logic programs Theorem 76 assume DB update actions occur heads rules positive form Since semantics satisfy shifting property correspondence semantics holds DB arbitrary actions rule heads change DB However condition actions heads rules change DB essential illustrated Example 77 The translation Rew introduced Caroprese et al 12 hand ﬁrst sight expressive applies AICs arbitrary actions head In order deal removal actions case database authors required consider logic program extended signature includes copies database atoms possible update action They prove precise correspondence stable models logic programs founded repairs AICs semantics developed point time However construction directly tailored founded repairs obvious adapted AFT semantics In order capture inertia authors duplicate database atoms model contains copy original database copy repaired database Additional rules ensure model repaired database corresponds exactly result applying update actions included model original database It easily seen mapping preserve AFT semantics AICs For instance technique maps founded repairs grounded stable models grounded certainly preserve grounded repairs By contrast correspondence stated Theorem 76 holds different semantics considered current work 6 For completeness argument Let I interpretation deﬁnition partial stable ﬁxpoint suﬃces lfpcid6P I1 lfpcid6trivP I1 lfpcid6P I 2 lfpcid6trivPI 2 Since working symmetric operators suﬃces prove ﬁrst equalities Now easy cid6trivP I1 inﬂationary operator cid6P I1 cid6trivP I1 J cid6P I1 J J Hence monotone operators preﬁxpoints preﬁxpoint equals preﬁxpoint B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 67 Another limitation results reverse translation preserve partial stable repairs AFTwellfounded repair cf Theorem 72 However discussion highlight difference comes intuition inertia That shown proof Theorem 72 simple normal logic program P semantics trivP aicP coincide Furthermore restrict attention normal programs Caroprese Truszczy nski 13 discuss translation requiring normality However mentioned nonnormal AICs syntactic sugar normalization need nonnormal logic programs The applies translation Rew Caroprese et al 12 The restriction programs simple technical requirement simpliﬁes proofs For semantics nonessential partial stable wellfounded semantics program easily translated equivalent simple program 8 Complexity analysis We begin section stating observation complexity computing Tη All complexity results terms size database cid10D B ηcid11 Proposition 81 Given partial action set U TηU computable polynomial time Proof The deﬁnition Tη requires evaluating Uα suppUDBηα suppUDBηα D α A In turn computations polynomial time require evaluating literal body rule η head α α D computing truth value database updated U cid2 Proposition 82 Let DB database η set normal AICs DB The problem deciding exists grounded repair cid10D B ηcid11 cid7P 2 complete Proof Inclusion We need decide problem nondeterministic Turing machine NP oracle Given set update actions U checking ﬁxpoint Tη polynomial time size DB η shown Proposition 81 NPoracle answer exists U cid14 cid3 U TηU cid14 U U cid14 establishing U grounded Hardness We hardness directly reducing cid7P 2 hard problem deciding particular database set AICs grounded repair Our proof straightforward adaptation Bogaerts et al 7 Theorem 57 turn inspired Denecker et al 22 Theorem 612 Given DNF formula ϕ propositional symbols x1 xm y1 yn interpretation I xi let ϕI denote formula obtained replacing occurrence xi t xi I f The problem decide exists interpretation I xi ϕI tautology cid7P 2 hard We reduce problem problem cid14 We consider database DB At xi x negation xi We write ϕcid14 deﬁned follows assume ϕcid14 ϕcid14 1 cid14 formula obtained uniformly replacing xi x k ϕcid14 conjunction literals ϕcid14 cid14 1 m p q y1 yn use x represent ϕ The set AICs ηϕ cid14 xi xi x ϕcid14 y j y j p q q cid14 cid14 xi x x ϕcid14 p p p q q The following properties hold ηϕ 1 m 1 k 1 j n r21 r22 r23 Each weak repair cid10ηϕ cid11 contains p rules r23 apply b No repair cid10ηϕ cid11 contains q minimality c In grounded repair cid10ηϕ cid11 ϕcid14 result set update actions p longer derivable contradicting groundedness satisﬁed removing p repair d Each grounded repair cid10ηϕ cid11 contains y j follows directly previous point cid14 e Each grounded repair cid10ηϕ cid11 contains exactly xi x contain cid14 rules r21 previous points guarantee rules r22 r23 satisﬁed regardless xi x grounded repair minimality implies contain actions Given interpretation I write ˇI denote set xi xi I x cid14 xi I From observations ae follows grounded ﬁxpoints cid10ηϕ cid11 form UI ˇI p y1 yn interpretation I xi We interpretation I UI grounded repair cid10ηϕ cid11 iff ϕI tautology 68 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 First assume UI grounded repair cid10ηϕ cid11 If J y1 yn falsifying assignment ϕI TηϕˇI yi yi J U ˇI yi yi J q U ˇI yi yi J contradicting fact U grounded repair cid10ηϕ cid11 Note ˇI yi yi J strict subset U contain p Therefore ϕI tautology Suppose hand ϕI tautology Let V U TηϕV U V If xi U V U V xi TηϕV rules r21 ˇI V But ϕI tautology yi V cid14 x corresponding rule r22 ensures yi TηϕV Likewise p V p TηϕV We conclude V U U grounded repair cid10ηϕ cid11 cid2 Proposition 83 The KripkeKleene repair cid10D B ηcid11 computable polynomial time Proof The KripkeKleene repair cid10D B ηcid11 computed iterating Tη ﬁxpoint reached Since Tη mono tonic maximum number iterations size At iteration computed polynomial time Proposition 81 ﬁxpoint cid2 Proposition 84 The ATFwellfounded repair cid10D B ηcid11 computable polynomial time The proof makes use following proposition Proposition 85 23 Let A approximator O x y L2 Let S x This operator monotone The smallest y x y cid14 cid14 unfoundedness reﬁnement x y given y A operator L maps y cid14 cid14 lfpS x Ax y A cid142 Proof Proposition 84 To compute Tηwellfounded ﬁxpoint construct wellfounded induction strict reﬁnements Since wellfounded p increasing consist A At steps Computing exists strict application reﬁnement given partial repair set U computing TηU Now Propo sition 85 shows precise unfoundedness reﬁnement computed ﬁxpoint derived operator 2 Such ﬁxpoint computed polynomial time Hence follows compute terminal wellfounded induction wellfounded ﬁxpoint polynomial time cid2 A Proposition 86 The task checking database cid10D B ηcid11 stable repair NPcomplete Proof Inclusion Given candidate repair U checking stable polynomial time amounts verifying repair twovalued ﬁxpoint operators Tη U 1 TηU 2 The polynomial time proof Proposition 83 Hardness For hardness use reduction simple logic programs AICs Caroprese Truszczy nski 13 given Deﬁnition 71 This operator preserves stable semantics Theorem 72 allows compute stable models simple logic programs ﬁrst translating linear time sets AICs Since checking logic program stable model NPcomplete 430 conclude checking database stable repair NPhard Note logic program transformed simple logic program removing offending rules changing stable semantics cid2 What notice section complexity inference tasks related semantics complexity counterpart normal logic programming This illustrates added expressivity essentially allowing AICs unipolar result added complexity Contrary original work introducing AICs 27 deﬁnitions include ﬁrstorder quantiﬁcations When allowing richer syntax results presented section reused constitute datacomplexity results 9 Conclusion In paper deﬁned approximator domain active integrity constraints The result family semantics AICs based existing intuitions domains nonmonotonic reasoning We studied properties induced semantics In particular AFTwellfounded semantics possesses desirable properties approximates repairs families stable justiﬁed grounded approximate skeptical queryanswering respect semantics Furthermore AFTwellfounded repair computed time polynomial size database Our study far ﬁnished In context approximation ﬁxpoint theory ultimate approximators studied Denecker et al 22 They showed twovalued operator associate canonical approximator The ultimate approximator induces family semantics AICs In domains logic programming semantics based ultimate approximators desirable properties general come cost higher B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 69 computational complexity standard variants It remains researched holds context AICs In paper showed class justiﬁed repairs situated classes stable grounded repairs It known AFT class ultimate stable ﬁxpoints falls classes stable ﬁxpoints approximator grounded ﬁxpoints Hence interesting research question verify justiﬁed repairs coincide ultimate stable ﬁxpoints domain relate Another topic potential interesting future work notion inconsistency Consider instance set AICs intuitively expect semantic operator derive inconsistency partial action set standard AFT possible However extensions AFT accommodate deﬁned 3 interesting AICs ﬁt general theory Another AFTbased topic study safe inductions 9 yield context AICs ﬁx problems wellfounded semantics One topic extensive research needed domain revision programming 31 Caroprese Truszczy nski 13 showed structural correspondences semantics AICs semantics revision programs Our paper paves way applying AFT revision programming Acknowledgements Bart Bogaerts postdoctoral fellow Research Foundation Flanders FWO Luís CruzFilipe partially sup ported Danish Council Independent Research Natural Sciences grants DFF132300247 DFF701400041 References 1 S Abiteboul Updates new frontier M Gyssens J Paredaens DV Gucht Eds Proceedings ICDT88 2nd International Conference Database Theory Bruges Belgium August 31September 2 1988 Lecture Notes Computer Science vol 326 Springer 1988 pp 118 2 C Antic T Eiter M Fink Hex semantics approximation ﬁxpoint theory P Cabalar TC Son Eds Proceedings Logic Programming Nonmono tonic Reasoning 12th International Conference LPNMR 2013 Corunna Spain September 1519 2013 LNCS vol 8148 Springer 2013 pp 102115 3 Y Bi J You Z Feng A generalization approximation ﬁxpoint theory application R Kontchakov M Mugnier Eds Proceedings Web Rea soning Rule Systems 8th International Conference RR 2014 Athens Greece September 1517 2014 Lecture Notes Computer Science vol 8741 Springer 2014 pp 4559 4 N Bidoit C Froidevaux Negation default unstratiﬁable logic programs Theor Comput Sci 78 1 1991 86112 httpsdoiorg101016 0304397551900047 5 B Bogaerts Groundedness Logics Fixpoint Semantics PhD thesis Department Computer Science KU Leuven Jun 2015 Marc Denecker supervisor Joost Vennekens Jan Van den Bussche cosupervisors httpsliriaskuleuvenbehandle123456789496543 6 B Bogaerts L CruzFilipe Semantics active integrity constraints approximation ﬁxpoint theory 35 pp 866872 httpsdoiorg 1024963ijcai2017120 7 B Bogaerts J Vennekens M Denecker Grounded ﬁxpoints applications knowledge representation Artif Intell 224 2015 5171 httpsdoiorg101016jartint201503006 8 B Bogaerts J Vennekens M Denecker Partial grounded ﬁxpoints Q Yang M Wooldridge Eds Proceedings TwentyFourth In ternational Joint Conference Artiﬁcial Intelligence IJCAI 2015 Buenos Aires Argentina July 2531 2015 AAAI Press 2015 pp 27842790 httpijcaiorgpapers15AbstractsIJCAI15394html 9 B Bogaerts J Vennekens M Denecker Safe inductions algebraic study 35 pp 859865 httpsdoiorg1024963ijcai2017119 10 B Bogaerts J Vennekens M Denecker J Van den Bussche FOC knowledge representation language causality Theory Pract Log Program 14 45OnlineSupplement 2014 6069 httpsliriaskuleuvenbehandle123456789459436 11 G Brewka S Woltran Abstract dialectical frameworks F Lin U Sattler M Truszczy nski Eds Principles Knowledge Representation Rea soning Proceedings Twelfth International Conference KR 2010 Toronto Ontario Canada May 913 2010 AAAI Press 2010 pp 102111 httpaaaiorgocsindexphpKRKR2010paperview1294 12 L Caroprese S Greco C Sirangelo E Zumpano Declarative semantics production rules integrity maintenance S Etalle M Truszczy nski Eds Proceedings Logic Programming 22nd International Conference ICLP 2006 Seattle WA USA August 1720 2006 LNCS vol 4079 Springer 2006 pp 2640 13 L Caroprese M Truszczy nski Active integrity constraints revision programming Theory Pract Log Program 11 6 2011 905952 https doiorg101017S1471068410000475 14 L CruzFilipe Optimizing computation repairs active integrity constraints C Beierle C Meghini Eds Proceedings Foundations Informa tion Knowledge Systems 8th International Symposium FoIKS 2014 Bordeaux France March 37 2014 Lecture Notes Computer Science vol 8367 Springer 2014 pp 361380 15 L CruzFilipe Grounded ﬁxpoints active integrity constraints M Carro A King M De Vos N Saeedloei Eds Technical Communications 32nd International Conference Logic Programming ICLP 2016 TCs October 1621 2016 New York City USA OASIcs vol 52 Schloss Dagstuhl Nov 2016 pp 114 chap 11 16 L CruzFilipe M Franz A Hakhverdyan M Ludovico I Nunes P SchneiderKamp repAIrC tool ensuring data consistency ALN Fred JLG Dietz D Aveiro K Liu J Filipe Eds KMIS 2015 Proceedings International Conference Knowledge Management Information Sharing Part 7th International Joint Conference Knowledge Discovery Knowledge Engineering Knowledge Management IC3K 2015 vol 3 Lisbon Portugal November 1214 2015 SciTePress 2015 pp 1726 17 L CruzFilipe G Gaspar P Engrácia I Nunes Computing repairs active integrity constraints Seventh International Symposium Theoretical Aspects Software Engineering TASE 2013 Birmingham UK 13 July 2013 IEEE Computer Society 2013 pp 183190 18 L CruzFilipe G Gaspar I Nunes P SchneiderKamp Active integrity constraints multicontext systems E Blomqvist P Ciancarini F Poggi F Vitali Eds Proceedings Knowledge Engineering Knowledge Management 20th International Conference EKAW 2016 Bologna Italy November 1923 2016 Lecture Notes Computer Science vol 10024 2016 pp 98112 19 M Denecker M Bruynooghe J Vennekens Approximation ﬁxpoint theory semantics logic answers set programs E Erdem J Lee Y Lierler D Pearce Eds Correct Reasoning LNCS vol 7265 Springer 2012 pp 178194 20 M Denecker V Marek M Truszczy nski Approximations stable operators wellfounded ﬁxpoints applications nonmonotonic reasoning J Minker Ed LogicBased Artiﬁcial Intelligence The Springer International Series Engineering Computer Science vol 597 Springer US 2000 pp 127144 70 B Bogaerts L CruzFilipe Artiﬁcial Intelligence 255 2018 4370 21 M Denecker V Marek M Truszczy nski Uniform semantic treatment default autoepistemic logics Artif Intell 143 1 2003 79122 httpsdoiorg101016S000437020200293X 22 M Denecker V Marek M Truszczy nski Ultimate approximation application nonmonotonic knowledge representation systems Inf Comput 192 1 Jul 2004 84121 httpsliriaskuleuvenbehandle123456789124562 23 M Denecker J Vennekens Wellfounded semantics algebraic theory nonmonotone inductive deﬁnitions C Baral G Brewka JS Schlipf Eds LPNMR Lecture Notes Computer Science vol 4483 Springer 2007 pp 8496 24 PM Dung On acceptability arguments fundamental role nonmonotonic reasoning logic programming nperson games Artif Intell 77 2 1995 321357 httpsdoiorg101016000437029400041X 25 T Eiter G Gottlob On complexity propositional knowledge base revision updates counterfactuals Artif Intell 57 23 1992 227270 httpsdoiorg101016000437029290018S 26 M Fitting Fixpoint semantics logic programming survey Theor Comput Sci 278 12 2002 2551 httpsdoiorg101016S0304 397500003303 27 S Flesca S Greco E Zumpano Active integrity constraints E Moggi DS Warren Eds Proceedings 6th International ACM SIGPLAN Conference Principles Practice Declarative Programming 2426 August 2004 Verona Italy ACM 2004 pp 98107 28 M Gelfond V Lifschitz The stable model semantics logic programming RA Kowalski KA Bowen Eds ICLPSLP MIT Press 1988 pp 10701080 httpciteseeristpsueduviewdocsummarydoi1011246050 29 SC Kleene On notation ordinal numbers J Symb Log 3 4 1938 150155 httpwwwjstororgstable2267778 30 V Marek M Truszczy nski Autoepistemic logic J ACM 38 3 1991 588619 httpsdoiorg101145116825116836 31 VW Marek M Truszczynski Revision programming Theor Comput Sci 190 2 1998 241277 httpsdoiorg101016S0304397597000923 32 RC Moore Semantical considerations nonmonotonic logic Artif Intell 25 1 1985 7594 httpsdoiorg1010160004370285900426 33 TC Przymusinski H Turner Update means inference rules J Log Program 30 2 1997 125143 httpsdoiorg101016S0743 10669600091X 34 R Reiter A logic default reasoning Artif Intell 13 12 1980 81132 httpsdoiorg1010160004370280900144 35 C Sierra Ed Proceedings TwentySixth International Joint Conference Artiﬁcial Intelligence IJCAI 2017 Melbourne Australia August 1925 2017 ijcaiorg 2017 httpwwwijcaiorgProceedings2017 36 H Strass Approximating operators semantics abstract dialectical frameworks Artif Intell 205 2013 3970 httpsdoiorg101016 jartint201309004 37 H Strass JP Wallner Analyzing computational complexity abstract dialectical frameworks approximation ﬁxpoint theory C Baral G De Giacomo T Eiter Eds Principles Knowledge Representation Reasoning Proceedings Fourteenth International Conference KR 2014 Vienna Austria July 2024 2014 AAAI Press 2014 pp 101110 httpwwwaaaiorgocsindexphpKRKR14paperview7917 38 E Teniente A Olivé Updating knowledge bases maintaining consistency VLDB J 4 2 1995 193241 httpwwwvldborg journalVLDBJ4P193pdf 39 MH van Emden RA Kowalski The semantics predicate logic programming language J ACM 23 4 1976 733742 httpsdoiorg101145 321978321991 40 A Van Gelder KA Ross JS Schlipf The wellfounded semantics general logic programs J ACM 38 3 1991 620650 httpsdoiorg101145 41 J Vennekens D Gilis M Denecker Splitting operator algebraic modularity results logics ﬁxpoint semantics ACM Trans Comput Log 7 4 116825116838 2006 765797 httpsdoiorg10114511826131189735 42 J Vennekens M Mariën J Wittocx M Denecker Predicate introduction logics ﬁxpoint semantics Part I logic programming Fundam Inform 79 12 September 2007 187208 httpsliriaskuleuvenbehandle123456789266021 43 J Vennekens M Mariën J Wittocx M Denecker Predicate introduction logics ﬁxpoint semantics Part II autoepistemic logic Fundam Inform 79 12 September 2007 209227 httpsliriaskuleuvenbehandle123456789146591 44 J Widom S Ceri Eds Active Database Systems Triggers Rules Advanced Database Processing Morgan Kaufmann 1996 45 M Winslett Updating Logical Databases Cambridge Tracts Theoretical Computer Science Cambridge University Press 1990