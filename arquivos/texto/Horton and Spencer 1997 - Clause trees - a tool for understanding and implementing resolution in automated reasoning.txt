ELSEVIER Artificial Intelligence 92 1997 2589 Artificial Intelligence Clause trees tool understanding implementing resolution automated reasoning JD Horton Bruce Spencer University New Brunswick Fredericron New Brunswick Cunada E3B 5A3 Received July 1995 revised November 1996 Abstract structure developed order automated A new methodologydata clause logic A clause tree tree T set S clauses reasoning 4tuple based resolution N E L M N set nodes divided clause nodes atom nodes E set edges joins clause node atom node L labeling N U E assigns clause node clause S atom node instance atom clause S edge The edge joining clause node atom node labeled sign corresponding atom literals The merge identical nodes different clause trees represent complementary atom nodes set M literals represented placing leaf head remains chosen merge paths The tail merge path closed open leaf resolved The clause clT set literals labels open leaves modified signs incident edges The corresponding fundamental S resolution literal clause A resolution clT derived represented unifying corresponding purpose clause tree T T represents path joining Lovelands model elimination ME selected literal procedure SL Shostaks graph trees The condition procedure GC explained construction required choosing merge path head leaf given This allows clause tree built way build ordering justified proof unified manner clause The ordered clause set restriction trees merge path clause ideas ME GC Spencers ordered clause set restriction tighter procedures foothold score restriction reversal A new procedure proof ordering explained called ALPOC OC form new developed shown sound operation combines procedure complete Corresponding author Email jdhunbca Email bspenceunbca 00043702971700 PII SOOO437029600046X 0 1997 Elsevier Science BV All rights reserved 26 JD Horton B SpencerArtificial Intelligence 92 1997 2589 clause tree Any nonminimal Another operation clause trees called surgery nonminima1 clause trees redundant A sound procedure MinALPOC clause showing produces minima1 clause trees given Mergeless clause trees shown equivalent input resolution unit resolution known results Many new proof procedures clause leaving open questions 0 1997 Elsevier Science BV define minima1 minima1 clause tree surgery giving short proofs trees discussed briefly relative Horn sets tree reduced defined Keywords Automated theorem proving Redundancy Minimality Proof procedures 1 Introduction reasoning disjunction wants binary resolution Starting set literals applies result usually This clause common method starts negating contradiction In paper clause represented This paper concerned automated clause set clauses resolution clause wants prove looking graph tree atom nodes connected labeling clause atom node atom node correspond terms An theory input clause represented labeled atom However positive negative clause node atom clause literal edge joining indicated shows d Such tree called clause tree clause node Fig la sign labeling tree representing 6 c literals clause b c resolution For example Clauses combined trees resolved different clauses shown d d e g b form new clause c identifying leaf nodes Fig lb The tree literals resulting clause But leaves union d atom nodes literal joined merge path Fig lc The literal resolve clause b e g Clause 4 represent complementary leaves resulting labeled d The merging literals sets occurs handled automatically correspond literal corresponding tail merge path clause clause trees Instead occurs considered longer b Fig 1 Example clause trees JD Horton B SpencerArtificial intelligence 92 1997 2589 27 la b cl la 4 dl la c 4 la dJ c dl 4 la 4 4 I Ia 4 Ib di b cl c d I Fig 2 Two different results resolutions clauses In ordinary resolution clauses represented sets order sequence resolutions significant impact result For example suppose clauses b c 6 d d Resolving clauses b produces c d resolving result clause produces c d See Fig 2a However begin resolving second clause producing b dj resolve clause b obtain inferior result c d See Fig 2b Fig 3 shows sequences resolutions Fig 2 clause trees instead sets represent clauses Leaves label merged soon connected path However tree Fig 3b improved choosing merge path open leaf labeled u internal node label Thus inferior result improved yield clause tree clause c d If clause trees matter order resolutions b b d A h c T t b c t b Fig 3 Clause trees Fig 2 28 JD Horton B SpencerArtijicinl Intelligence 92 1997 2589 resulting corresponds different clause tree Hence clause tree searches clause presented clause trees distinguish Fig 3 illustrates ordinary tree constructed order resolution proof proof ordering resolutions performed tree build ordering The final clause order build ordering Fig 3b justified proof ordering built Section 31 present way Fig 3a A general example procedure ME proof ordering looking weak model elimination required different procedure ancestor clauses required In manner similar These ancestor resolutions build MESON literal SL ordering These procedure 29 respectively Using clause trees easily seen GC restriction variant SL SL restriction ME In proof ordering resolutions usual justification 16 Shostaks graph construction GC procedure Sections 33 34 selected 21 ancestor merges correspond insertion merge paths replaced merges ideas extended build ordering proof ordering Section 4 develops new concepts visibility support relations nodes clause trees The results paper rest relations Section 5 shows merge paths nodes reversed essentially change relation visibility foothold score restriction It adapts ordered clause set restriction 32 clause 3031 trees proof procedures result general As shown A theorem prover advantage internal nodes clause basic ways It improve proof making internal merge path chosen resolutionbased tautologies avoided Since clause tree represents detect proofs contains tautology misses opportunity literals The operation clause tautologies tree subsumes surgery applied said minimal tree Fig 3 remove literal But Most merges possible distinct proofs merge internal tree unused merges cutting branches clause trees finds smaller clause Section 6 removes tree surgery defined original Clause require Section 7 introduces ALP AllPaths trees Using clause arises reordering instance procedures clause set restriction Moreover avoided As stronger ALPOC produces minimal trees theorem prover avoid building steps avoid resolution building procedures clause tree searching For Section 7 restricted ordered procedure Min tree contains redundant clause redundant tautology search clause example avoiding clause trees clause clause trees merge paths shows Section 8 investigates clauses admits mergeless refutation relative Horn set unsatisfiable Although concepts equivalent concept provide examples clause reasoning resolution set admits input admits unit refutation contains subset automated equivalent understand complete proofs trees investigate known tree refutation JD Horton B SpencerArtificial Intelligence 92 1997 2589 29 trees differ structures defined Eisinger S Our clause concepts closely related connection Clause trees closely trees clause related tableaux 17 Tableaux adding clause trees unrooted The operation tableau expansion tree tree clause node trees resolve clause trees clause node rooted corresponds Clause case tableaux Choosing merge paths rooted clause tree corresponds folding folding different operations left hooks In particular identify ancestor paths reduction operations factoring tableaux calculi defined addition folding Also connection trees built folding left paths creductions 17 clause 1314 clause tableaux reduction tableau 2 Definitions substitution universally order clausal We use standard definitions 0 C 8 C C A substitution quantified A substitution maps variables result applying logic 6 21 An atom atomic formula A literal atom negation wu atom The complement b literal b negation b b atom atom b clause A clause set literal possibly All variables terms An assumed instance literal clause variables A ground instance variables A clause C subsumes clause C 0 unifies literals b b substitution b 8 b 8 A general unifier 8 literals b b b U b 8p An unifier u b b interpretation set clauses consists nonempty nplace set S nplace instance C C clauses interpretation true I A model S SC satisfiable exists model interpretation S entails C written SF C model S model C In paper proof procedure takes input set S clauses input clause C deriued S written S I C A proof procedure C attempts sound S F C implies S F C A proof procedure exists clause D SF D D subsumes C symbol mapping mapping Cb S literal Ci mapped D D assignment I I satisfies S ground procedure determine satisfies S A set clauses complete S g C implies domain D assignment exists substitution true false Given D predicate function p symbol We use standard terms graph theory A graph G consists set nodes N set E unordered pairs nodes called edges written G N E An edge e v u incident joins endpoints u u u u adjacent incident e A node degree k incident exactly k edges A path graph alternating sequence nodes edges adjacent elements incident node appears twice elements nodes Thus P uO e u uk_ e v sequence 30 JD Horton B SpencerArtificial Intelligence 92 1997 2589 ilkui isin N eiui_uiisin tail edge ek called isapathifforall uO isin NThe node uO called tail path node uk called head path e called head edge path said join connect tail head The length number edges Note path determined uniquely set edges orientation direction runs A tree graph unique path joining given ordered pair nodes We write patht h path joins node t node h tree The nodes degree tree called leaves tree Eand A rooted tree tree specified node called root The nodes path called ancestors node The given node root excluding second node path called parent node node called child parent The children parent node totally ordered child order second child said left right comes earlier later second child A node n left right node m ancestor n left right root As ancestor m The level node length path joining shall additional trees structures constructed trees definition unrooted clause trees rooted trees steps First define mergeless clause We define clause trees clause trees merge paths Definition 1 Mergeless clause tree Given set S clauses mergeless clause tree T N E L 4 N set atom nodes clause nodes E S 4tuple set edges join atom node clause node L labeling maps atom node atom clause node clause S edge b The graph N E tree In addition T conforms 8 Elementary mergeless clause tree Given clause C S substitution variables CBa 1 N consists clause node n atom nodes L labels C mergeless clause tree T N E L 4 satisfies following representing atom nodes atoms labels clause node C clause node according 2 E consists n undirected edges joins atom nodes labeled L positively negatively b Resolving atom positive negative mergeless clause trees Let T N E L 4 clause common trees nodes T2 N2 E L 4 mergeless clause n atom node leaf T n2 atom node leaf T2 No variable occur label atom node T label atom node T2 Let L label n atom label edge n m negatively L label n2 atom a2 label edge n m2 positively Further let a2 unifiable substitution 8 Let N N U NT n Let mlUn2 m n m new edge Let L EE UEIn new new relation labeling edge n m labeled negatively label atom node Then T N E L 4 mergeless clause modifications 8 applied L U L results tree variables clause tree b Resoluing JD Horton B SpencerArtificial Intelligence 92 1997 2589 31 tree contains 2 Unifiable merge tautology paths Let T N E L 4 clause Definition mergeless distinct atom nodes n n2 atoms label nodes unifiable A unijiable parh P T unique directed path n n2 If tail head edges P sign P P unifiable merge path If signs tail head edges P different uniable tautology path If labels n n2 identical signs tail head edges identical unifiable path P called merge path respectively respectively tautology path opposite A clause tree merge paths need added set chosen merge paths fourth parameter clause tree tuple Those remove leaf set open leaves Note merge path fully determined atom nodes orientation simply head tail Definition NE L M set nodes edges b cc 3 Clause tree Given set S clauses clause free T S tuple defined labels chosen paths respectively Elementary clause tree Given clause C S substitution 0 representing Cf3 C mergeless clause tree T N E L 4 tw o clause leaf T n2 open trees Let T N E L M T2 N2 E2 L M clause trees common nodes n leaf T Let T N E L 4 open mergeless trees resolving N E L 4 N2 E L 4 nodes n n2 Definition lb Let M set merge paths results M U M replacing occurrence n path M n2 Then T N E L M clause mergeless tree resulting clause clause tree c Choosing merge path Let T N E L M let n n2 open leaves T P puthn n2 unifiable merge path N E L 4 0 n tail chosen merge path substitution head tail chosen merge path Let LB M n results applying 8 label atom node labeling clause tree P called chosen merge path T leaving L Then T N E LO M U P relation A path unijiable merge tautology path clause tree N E L M tree N E L 4 Note merge path tree unifiable merge tautology path mergeless clause clause directed Referring Fig 1 parts figure parts Definition N E underlying 3 respectively We occasionally tree T N E L M based undirected graph tree use T refer clause illustrate tree Definition instance clause 4 Instance clause tree A clause tree T N E L M tree T N E L M L L identical clause 32 JD Horron B SpencerArtificial Intelligence 92 1997 2589 nodes edges substitution 0 atom node IZ Ln LnO Where confusion arise use TB T LB L Definition 5 Open leai associated literal clause clause tree subsumption clause trees An open leaf atom node leaf tail chosen merge path Each edge associated literal formed atom label incident atom node modified negation edge labeled negatively The clause clause tree T written clT disjunction literals associated open leaves A clause tree T subsumes clause tree T2 clT subsumes clT One restriction chosen merge paths head tail The purpose merge path indicate proof complement literal tail merge path If restriction lifted paths based edge set oriented differently tail head Both ends closed proof Nor want different proofs indicated single tail One imagine definitions chosen merge paths removing condition n Definition 3c tail path allow head path tail avoid type circular situation However definitions merge connected path reversal Section 5 complicated We believe gain generality minimal needed development better procedures understanding present procedures Definition 6 Merge connected nodes In clause tree T atom nodes said merge connected connected chosen merge path direction tails chosen merge paths common head In addition node merge connected Clearly atom nodes merge connected labeled atom The relation merge connected equivalence relation set atom nodes clause tree In equivalence class single node head chosen merge paths The remainder nodes equivalence class closed leaves tails chosen merge paths head These tails break naturally possibly sets incident negative edge incident positive edge Definition 7 Merge sets The merge sets clause tree equivalence classes defined merge connected relation The head node merge set head path merge set singleton node set merge paths See Fig 4 example clause tree atom nodes 1 2 3 4 5 6 labeled merge connected Node 4 head node merge set JD Horton B SpencerArtificial Intelligence 92 1997 2589 33 Fig 4123456 merge set atom node We enclose circle label written node replaces figure Technically box clause node node node omitted times However occur multiple clauses clause trees Fig lb c sets open leaf literal clause In Fig lb open multiple open leaves soon rule open leaves lc Generally want literal chooses merge path open corresponds correspond deliberately disobey procedures tree Fig d corresponds allow elements useful literal leaf Fig usually leaves possible However later sections paper clause lc Fig 3 shows merge paths apparent heads merge paths open leaves However Fig 3a corresponds leaves easy leaf interior node At glance clause tree use definition clause tree recursively construct More formally Definition 8 Derivation P sequence T T clause result following clause free Given set P clauses derivation T trees q 1 _ _ n application Definition 3a member P application Definition 3b 7 Tk j k l application Definition 3c Tj j Theorem 9 Suppose N E L 4 mergeless clause tree Then N E L M clause tree derivation Proof By induction The definition q derivation mirrors definition clause tree 34 JD Horton B SpencerArtijiciul Intelligence 92 1997 2589 Theorem 10 Let S set clauses C clause S F C exists subsumes C clause tree Tfrom S clT Proof S F C sequence clauses C C C C subsumes C Ci S Ci result resolving C C j k This slightly generalized 26 Each member sequence Ci corresponds 3a application Definition 3b followed applications 3c required left labeled atom Conversely mirrors clT subsumes C application Definition Definition choosing merge paths open leaves open leaves clause tree clT F C definition clearly S t clT Further derivation cid1441 Robinsons main result definition restatement Definition 11 Closed clause leaves tree A clause tree said closed open Corollary 12 S unsatisfiable tree T S Corollary 13 Any proof procedure clause tree sound set clauses closed clause refutes set clauses building closed Definition 14 Isomorphic trees T N E L M trees Two clause T2 N2 E2 L M defined set clauses S said isomorphic bijection P N N2 clause u u E iff Pv udef Pv 9u b Lx L2Fx c path P u e u x N U E M iff PP E2 dfP Pe qu 4 3 Existing procedures restated terms clause trees Wellknown proof methodologies weak model elimination procedure translated ME selected manipulating literal procedure trees clause SL graph construction GO 31 Weak model elimination Consider following example proves literal q clauses Cl 4 b C2 b C3 b C4 Ib JD Horton B SpencerArtijicial Intelligence 92 1997 2589 35 Chain ME operation Clause tree Fig 5 b 4 Iqlah qlaf bla Iqla blkul Iqlabld Isla tsllalb Iqllallblu qllallbl q query extension q b b extension extension fb u reduction contraction extension b extension reduction contraction 2 X 3 X b Tl T2 T3 T4 T5 T6 Tl T8 Table I Step 1 2 3 4 5 6 I 8 9 10 21 implemented proof shown query clause The children node ordered proved apply PTTP 35 Table 1 The construction We start negation m q theorem weak ME clause procedure Fig 5 The tree rooted clause tree corresponds node corresponding left right order occur input clause algorithm reorder works right hand end In fact ME procedure works right left chain Each extension clause tree rightmost open leaf called current node The trees Tl T2 T3 T4 T6 T7 result additions Each reduction insertion merge path current node ancestor node tree Trees 10 ME steps steps Not T5 T8 corresponding steps correspond current node node higher result step construction clause tree Fig 5 The contraction addition input clause focus algorithm step corresponds step corresponds level node left clause Definition derivation construction T5 T8 leaves To clause steps proof Fig 6 Fig 6 read Each dashed circle surrounds clauses merge path introduced tree T8 derivation sequence binary ordering clause tree labeled clause tree The dashed lines connect resolved resolvents The bottommost 8 clause tree T8 changing resolution However tree Any ME proof equivalent rooted clause proof progresses Any input clause tree grows downward build ordering query appropriate extended clause chosen equivalence literal resolved rightmost open procedure backtracks extend clause previous tree appropriate ME procedure easily seen formally prove The justification steps derivation terms binary resolution tree We need use resolution ancestor clauses usually order proof ordering build ordering Ancestor ancestor node replaced resolution insertion contains leaf As ME node step leaf The steps steps line merge path open 36 JD Horton B SpencerArtificiul Intelligence 92 1997 2589 4 4 b u TI T2 T3 T4 T5 P _ 4 h T6 T7 T8 Fig 5 The build ordering clause tree 32 Build ordering concepts choosing merge paths Although definition clause tree allows choosing merge path nodes open leaves resolution step head merge path longer leaf Under conditions choosing merge path internal node allowed To choose merge path derivation constructed The sequence operations derivation sequence algorithm uses build T Thus orderings operations considered proof ordering satisfies Definition 3 build ordering include insertion merge path internal node An example given previous section JD Horton B SpencerArtijkial Intelligence 92 1997 2589 Fig 6 The proof ordering clause tree m conditions derivation general merge path insertions What necessary proof ordering ensure end proof ordering leaves clause different time created Since shown endpoints clearly upper Fig 7 exists First merge paths A B endpoints A B created And B exist endpoint A impossible tree endpoint exist An example derivation 38 JD Horton B SpencerArtificial Intelligence 92 1997 2589 Fig 7 Two impossible clause trees Moreover merge paths A B A ends B B ends C C ends A Again merge path A B B lower involving competing merge paths happens exists produce illustrated impossible situations situation merge path C chosen derivation reason C C A This Fig 7 Other conceivable avoided The following definitions capture derivation The subsequent notion merge path chosen shows paths result avoided paths chosen Definition 15 Precedes relation paths For paths A B tree T A B read A precedes B head A internal node head tail path B Definition 16 Legal paths A set M paths tree T legal relation tree M extended T N EL M partial order A path P legal T clause MUP legal Theorem 17 Let T N E L M clause tree let M set n unifiable merge paths tail path M different open leaf T tails head tail path M M U M Let 8 merge paths Then substitution makes uniable merge paths M T N E LO M clause tree M legal In particular unijable merge path P tail open leaf head chosen merge path chosen P legal T JD Horton B SpencerArtificial Intelligence 92 1997 2589 39 trees corresponding heads paths order placing nodes Create clause Proof Assume M legal partial order M Extend partial total order M total order atom order total order M Extend tail nodes N ordering head path placing atom nodes immediately path clause nodes la Perform resolution Definition 3b internal atom node Definition total choose merge path Definition 3c closed leaf node according order atom nodes The resolutions The merge paths chosen resolutions path head resolved Conversely later open leaf Then T clause T clause according path leaf path comes ordering Hence X subrelation partial order tree derivation Order merge paths M head M When path inserted total order order inserted relation tree 0 The paths tree T8 Fig 5 precede form trivial partial order Thus easy set merge paths legal Theorem 17 tree clause tree More generally ME chooses merge path open leaf ancestor leaf Definition 18 Ancestor path An ancestor path rooted tree path leaf ancestors Theorem 19 In rooted tree set ancestor paths legal Proof Order paths depth head tree deepest shallowest Two paths heads equal depth comparable This clearly partial order head path A falls internal node path B head A Then deeper head B case A precedes B order Thus partial order extends relation required precedes 0 The result theorem ME tree building procedure Section 31 builds clause trees Theorem 17 sound Corollary 13 33 SL resolution The selected 20 Reiter 25 It similar SL procedure independently developed Kowalski literal ME procedure 16 Loveland Kuehner current node ancestor SL addition ME reduction operation current node merges additional operation called basic factoring Section 31 Table 2 left sibling ancestor An SL derivation example The corresponding tree built right left Since merge paths tree proof built shown Fig 8 The clause merges clause 40 Table 2 Step 1 2 3 4 5 6 I 8 9 JD Horton B SpencerArtijicial Intelligence 92 1997 2589 Chain SL operation Clause tree Fig 8 b hid bb Iqldbl wa slalb ql albla 6qlalbl 0 query extension q b extension tb I basic factoring truncation extension h extension u b ancestor resolution truncation 3 X RI R2 R3 R4 R4 R5 R6 R7 R7 precedes form trivial partial order Theorem 17 tree R7 closed clause tree As ME procedure extension operation corresponds input clause added clause tree reduction operation corresponds insertion P q P _ 9 A Yb P 4 RI R2 R4 N 4 Y R7 P _ 4 b L b Fig 8 An SL build ordering clause trees JD Horton B SpencerArtijcial Intelligence 92 1997 2589 41 resolution merge path Ancestor open leaf ancestor path sibling ancestor sibling left ancestor We path left hook insertion merge path inserting merge ME Basic factoring corresponds leaf In case sibling corresponds open Theorem 20 In rooted clause tree set ancestor paths left hooks heads atom nodes forms legal set paths Proof Order paths locations heads inversely depth proof Theorem 19 secondarily level right left This order clearly partial order Let A path ends interior atom node path B There cases B ancestor path As proof Theorem 19 head A deeper head B A precedes B partial order needed ii B left hook Either head A deeper head B level If level head B left head A In subcase A precedes B partial order 0 Thus clause tree building procedure based SL sound Corollary 13 Theorems 17 20 Comparing ME SL sees trees identical Since SL finds merge paths clause corresponding ME uses use merge paths smallest clause small smallest clause tree ME Indeed required SL exceed better SL sense number left hooks tree SL number resolutions required ME propositional case But The truncation steps ME SL procedures truncate data structure remains safely later reduction information lost Procedures clause basic factoring define trees depend truncation later resolutions section use partial order nodes legal Some information procedure steps Hence useful contain operations 34 Left paths GC procedure Shostak 1291 developed graph construction Aliterals addition SL An example The clauses ancestors Bliterals paper 29 p 601 illustrate GC procedure It uses Cliterals open siblings ancestors ME GC procedure IN R T K Q Nj L Ml L Q L P R f N L T A GC derivation clause starting clause N T provided tree construc Shostak reproduced Fig 9 corresponding clause 42 JD Horton B SpencerArtificial Intelligence 92 1997 2589 0NT ITlNIMQ 2lNlQbWL 3 T LN Q IM3 14 2 extension extension extension extension 4 T N Q Mj t PI R N extension 5 I rqy4 1 lPI B reduction A literal 6 T NwJfl RI L extension 7 Wl u lF 8 T iN JW lL1 4 0 truncation Y X2 T L4 CL MI Q 9 T tN 4 CM Ql L extension 10 T r4 UmQl 11 T L4 cL C8 CM N I_T reduction C literal truncation x3 extension truncation x2 Fig 9 The clause tree construction corresponding GC procedure denote negation tion Note use Cliteral Except extension selected extensions consistent Shostak Selected steps placed new literals leftmost new denote framed Aliteral 0 denote tree order Shostak site literals underlined changes Shostaks example identical literals In GC allows merge path open leaf ancestor node creating merge path left tree Reduction Aliteral corresponds JD Horton B SpencerArtificial Intelligence 92 1997 2589 43 ancestor node called ancestor path Reduction Cliteral corresponds creating merge path node left leaf tree We paths left paths GC SL merges basic factoring merges left hooks allowed SL correspond Although Shostak says GC merging operation 29 p 601 allow open ancestor paths left paths What apparently corresponds right siblings ancestors left siblings left paths right hooks However time A left hook GC subtree GC albeit different finds subtree merges SLs basic factoring operation But GC finds left paths left hooks smallest GC proof small SL proof SL compared head path constructed constructed Thus GCs left path operation SL merging operation ME previous section Both ME SL prune search legal tautology path ME looks ancestor paths SL considers ancestor paths left hooks GC prune tautology path ancestor path left path mentioned Shostak 29 We clause tree version GC extension ALP procedure superior Section 7 Again ALP superior ME pruning SL discuss tautologies These procedures leave open question right hooks procedure We AllPaths left paths ancestor paths improves procedure Section 71 subject ongoing investigation 27 4 Visibility support Merge paths chosen open leaf internal node clause root tree Fig 9 rightmost child labeled M tree For example set path node M tree added legally merge paths The new path contention ancestor path N In fact literals legally merge path subtree N reached altered example children new rightmost child root However reached For example Fig 10 shows clause tree constructed GC set Shostaks example allows child 3 root clauses merged similar new internal node 9 Thus insert merge path leads definition 21 Visibility A node U tail merge path M Definition visible node u clause path T If u atom node head edge P labeled positively positive chosen merge path patht h positive u positive positive u said uisible U If t tail I visible h visible U We u sees u Otherwise u invisible u If label u P parh u u legal tree T N E L M negatively negative negative negative negative 44 JD Horton B SpencerArtijicial Intelligence 92 1997 2589 IN T S M Q Nl lL Ml lL Ql IL P Sl lR P NI IR Ll IT IS1 I 29 10 atom nodes visible 3 I 2 9 atom nodes visible atom 10 visible I 3 visible 9 Fig IO Alteration Shostaks example negative positive N visible merge set N2 head node N visible node N2 By convention node u visible visible literal A merge set head Note originally intended label wish apply pair nodes including cases This definition makes merge visibility relation The exception visible head For example nodes node 1 head visible connected visibility apply atom nodes clause nodes equivalent tail tail Fig 10 node 10 visible nodes The following theorem shows visibility property merge paths legally added clause tree This important build clause trees Section 7 decide algorithms Theorem 22 A merge path P path t h clause tree T chosen t open leaf 1 t head chosen merge path 2 3 h tail chosen merge path 4 h visible t t leaf Proof Assume P chosen By Definition head tail chosen merge path Also head h tail 3b tail JD Horton B SpencerArtificial Intelligence 92 1997 2589 45 chosen merge path By Theorem 13 P legal Conversely legal path T By Theorem 17 P chosen h tail merge path h visible 0 implies h visible t t P Lemma 23 A path P illegal clause tree N E L M path R M head R interior point P directions R P disagree common edges exist M U P legal set paths Then sequence Proof Assume paths M u P P P P P P C C P P We assume n small possible paths P M legal loss generality let P P Thus P C P head P Without direction P u R P u interior node P If P disagrees Otherwise P agrees direction P Consider tree separated u incident edges The tree falls splitting u nodes attached A contains components tail P head P P entirely A head P_ A B contains But head P P B Let Pi smallest head Pi A Then head Pi_ c P 4 Pi contradicts B Pi contain u But Pi C Pi legality M 0 legal Thus Lemma 23 implies path run head path path added set paths set paths opposite direction remains easy set ancestor paths legal paths point shown Theorem 19 Also set ancestor paths ancestor path left hook open leaf legal It follows left hooks easily legal sets merge paths However left path run head ancestor path legal ME SL construct relation The visibility proof useful tree T Suppose useful step Definition 3b Without atom node nodes Consider tree Theorem 22 The related concept support reveals new merge paths added chosen merge path n split nodes n n2 reverse n single chosen Fig 11 head tail labeled literal b n P oriented edge labeled n Then split T n clause reveals dependency interior atom node n closed clause includes n interior node Then degree T splits clause trees T T2 This operation resolution T clT Then n2 T clT However merge paths include n interior node Suppose merge path P shown interior atom node For sake argument edge n labeled precedes tail P T head T The P T discarded T2 discarded T clT b leaf Thus proof subtree T requires head P copied tail P This proof intuition use term subtree supports P tail P open loss generality assume proof But suppose 46 JD Horton B SpencerArtificial Intelligence 92 1997 2589 Fig 11 n3 support n support This subtree turn gives indirect support proof require support chosen merge path In development instead literals Rather algorithms work literals apply instead Thus sense node n given support head useful terminology applying nodes nodes P This discussion leads following definition Definition 24 Support In clause tree atom node u suPports atom node u u supporred u u SUPPOT U sequence chosen merge paths P P P x C P u head Pk u interior node P We u near support u path u u contains support u Also u fur support u support w u path u w contains U In rooted tree supports ancestors ancestor suppurrs left left supports right descendants The following theorem relates support visibility showing nodes near supports serve hide view nodes support Theorem 25 In clause tree T acorn node h thur tail merge path visible atom node t near support node h path P purh t h near support node h P Then Proof Suppose P Pofchosenmergepathssuchthat Pk P Then P 4 P x Pk C P Hence P illegal h visible sequence P andthehead P hison Pc t Conversely assume path P illegal sequence h visible T But h tail merge path P illegal Q r Then h tail merge T Thus Qj chosen merge paths P Q C Qj JD Horton B SpencerArtificial Intelligence 92 1997 2589 47 Fig 12 Merge paths form illegal set P Thus h occurs Q head Qj support node h occurs P Hence near support node h occurs P q Lemma 26 If v support u v visible u C Pk chosen merge paths u interior node P Proof Let P v head Pk Let P pathu u Suppose P legal Then sequence Q Q chosen merge paths P Q X C Q P Thus u interior node Q P C Q See Fig 12 Let h head Q Since union paths P Pm Q P h includes u v P subset union Hence h connected Pi Pi chosen merge paths Thus P legal v visible interior node P Since C Q Pi contradiction 0 u PkdQe C Lemma 27 If w ancestor support left support atom node u w ancestor u Proof Let u left support v let v ancestor support w If w ancestor u unique path P u u nearest common ancestor u v w v See Fig 13 Consider sequence chosen paths P _ P v P P X P w head P Fig 13 An impossible ancestor support left support 48 JD Horton B SpencerArtijcial Intelligence 92 1997 2589 Then Pc P Hence w ancestor u 0 C Pk impossible u visible u Lemma 26 5 Path reversal ordered clause sets foothold scores When merge path created matter fundamental sense direction path oriented We define operation reversing path A clause tree subtree attached head A removed reattached tail A Selected merge paths use parts path A redefined details hard This operation allows consider entire families clause trees equivalent It allows define restrictions clause trees including foothold score restriction ordered clause set restriction reversal Let T N E L M clause tree let Operation 28 Path A patht h chosen merge path M Let u node adjacent h A The operation reversing path A T illustrated Fig 14 modifies T obtain T N E L M following way 1 2 3 4 If edge v h E u occur A new set edges E E u h U u t L identical L new edge v t labeled L sign v h labeled L In case edge E E L L Define reversal A AR path h t B set chosen paths M contain edge u h For LB Bj pathti hi define path Bi pathti hi hi h pathti t Note edge set Bj symmetric difference edge sets B A edge v t replacing edge v h We denote B Bi fI3 A abusing notation slightly Letc Ci pathti h define Cj pathti n r C set chosen paths M head edge v h For t head edge replaced Fig 14 Before path reversal JD Horton B SpencerArrijicial Intelligence 92 1997 2589 49 5 Icr MMAUARB cg1 BuB BC Cu Lemma 29 Let T N E L M obtained path reversal chosen path A T N E L M Then following T clause tree clT clT b T obtained reversing AR T c Two atom nodes merge connected T merge connected T Thus set nodes merge set T merge set T statements true d If b atom nodes N b t h visible b T visible b T Moreover visible b The difference visibility relations T T h visible t T T t visibleffom h T T e The visibility relation merge sets unaffected path reversal Proof Let h t u v A Br Cj defined Operation 28 path reversal Consider order internal atom nodes T correspond derivation T proof Theorem 17 Order internal atom nodes T way position h t ordering T interchanged ordering chosen path T Consider P path x y M We internal node P occur x y ordering chosen path P corresponds M internal T internal P P Then internal T This argument works atom node set P symmetric atom nodes P If P h node atom nodes P occur occur x y ordering P C If P Bj x y ordering note t replacing h internal atom node set P internal atom node set A Since internal node A occurs h ordering T internal node t ordering T As h y occurs y A occurs ordering T t y occurs y ordering T Hence internal atom nodes P occur y Thus ordering T corresponds derivation T T clause difference tree Note clT clT open leaves T open leaves T h h leaf But case replaced t possibly associated literal b Let T N E L M obtained reversing AR T It easily seen E E L L M M c Assume c d merge connected atom nodes T T pathc d chosen merge path T There subcases If c d merge connected ii Assume c cho consider T If d h c t pathc t pathd r sen merge path pathh t chosen merge paths T Otherwise pathc d chosen merge path T In case c d merge connected If pathc d A patht h pathh t pathd T JD Horton B SpencrrArtijiciul Intelligence 92 1997 2589 iii Assume parhc w pd w chosen merge paths T If paths A loss generality let c I w h Then pathd r pafhd c chosen merge path T If w h c d t pathc t chosen merge paths T Otherwise puthc w puthd w chosen merge paths T t pd Conversely assume c d merge connected T Then T result reversing AR Z b By argument c d merge connected T d The proof visibility relation atom nodes essentially unchanged T T similar argument merge paths remaining legal omitted e We head node h merge set N head node h merge set N T head node h N head node hi N2 T By d difference visibility relation head tail path Since h h tail path visibility relation head nodes unchanged q The fundamental purpose clause tree T clT derived clauses corresponding clause nodes tree Lemma 29 shows derivations regardless direction chosen create merge path Thus procedure specify way merge path oriented affecting completeness procedure Definition obtained series path reversal operations equivalent Two clause trees reversal equivalent 30 Reversal Reversal equivalence equivalence relation Fig 15 shows reversal equiva c b b c In general lent clause trees clauses b n merge paths distinct heads clause tree 2 different reversal equivalent clause trees If multiple path reversals order path reversals important chosen paths head Theorem 31 Given clause tree T N E L M subset S M head Then ordering elements S paths S reversing paths S order results sume clause tree Proof Select orderings elements S consider edge sets result reversing paths orders Since reversal changes exactly edge reversals affect edge edge sets identical Each merge path connects tail head Since underlying edge sets trees path connecting pair nodes unique merge paths resulting trees identical 0 The situation set paths reversed includes paths head simple The important thing subtree attached head JD Horton B SpencerArtijicial Intelligence 92 1997 2589 51 Reverse path bs w Reverse path Reverse path Fig 15 Four reversal equivalent clause trees It ends tail paths ends attached end path reversals original head path reversed nodes merge connected But dependent order paths head reversed If paths share head reversal path followed reversal image second amounts reversal second See Fig 16 In fact looking roles paths diagram sees exchanged That image P reversing P reversing Pi path image P reversing P different operations 51 The ordered clause set restriction clause The ordered set OC search space needed restriction procedure These papers MEtype decrease specifically develop OC ME SLI 191 proof procedures applied SL GC In procedures merge paths ancestor paths If path reversed different proof arises But needs allow 30311 depends path reversal 52 JD Horton B SpencerArtificial Intelligence 92 1997 2589 s _ _ L Reverse P Reverse P 2 Reverse P 2 y h Fig 16 Reversing paths head proofs Initially input clauses assigned arbitrary total order The OC restriction chooses ancestor merge paths comparing clauses head tail The clause node adjacent head ancestor path required precede clause node adjacent tail clause case order clauses 36 For example Fig 17 ordered unsatisfiable set clauses presented closed clause trees shown In ordered clause set restriction obeyed clause head path earlier clause tail However second clause tree accepted Not OC condition reduce search space detected early procedure prevent redundant work It prevents multiple redundant proofs proof required This gives significant improvement ME procedure terms number inferences time required Although merge paths ancestor paths built SL ALP procedures ordered clause set restriction applied ancestor paths The right hooks SL oriented left right left paths ALP oriented right left reversal disrupt structure clause tree constructed procedures The procedures discussed paper Section 72 applied problems propositional logic use ordered clause set restriction strict inequality clauses head tail merge path algorithms causing tautology unchosen merge ancestor paths Lemma 47 But order logic case general complicated One wants able JD Horton B SpencerArtijicial Intelligence 92 1997 2589 53 2 b 1 p cl 2 Ip b 3 bl 4 cl 5 I Pl IP I obeys OC restriction disobeys OC resrrictron Fig 17 An illustration ordered clause set restriction paths simultaneously choose direction ancestor merge paths direction Paths arise clause acceptable instances clause Thus ancestor paths ordered node different ordered clause set restriction See Section 75 discussion The section offers way orient paths suffer problem 52 Foothold scores Spencer 32 different method orienting merge paths rene ment The idea ordered pair edges clause node score 1 0 1 The score path total scores pair edges path If path reversed score gets multiplied 1 If number clause nodes path nonzero score odd total positive negative total score proper paths By accepting paths positive class reversal equivalent gets representative trees Theorem 34 clause chosen equivalence foothold scores Let T N E L M clause tree let P Definition 32 Foothold chosen merge path T For clause node n N assume literals clause sign totally ordered Literals different signs compared Let ordering sign ordering n T sign ordered clause tree Define score n P sign ordered clause tree T 0 incoming l 1 incoming edge n P precedes l 1 outgoing edge n P precedes outgoing edge n P differ outgoing edge incoming edge 54 JD Horton B SpencerArtijicial Intelligence 92 1997 2589 P said pioper sum scores clause nodes positive P said improper T said representative clause tree chosen merge paths proper Any merge path starts ends edges sign number internal nodes sign changes The number internal nodes path odd odd number internal nodes sign change But sign changes atom nodes nodes sign change clause nodes odd number Since score 1 1 nodes 0 total score path odd positive negative Note sign score changes node path runs way Thus total score path gets multiplied 1 path reversed Hence path reversal proper Lemma 33 Consider ordered clause score n paths j k respectively Then I j k 1 1 c pathc sign paths Let tree clause node n common paths patha b pathb Proof If signs edges paths literals edges comparable sign ordering Without loss generality assume literal edge literal sign ordering Then l k edges sign differs Then j andkareOandthethirdvalueislorlHenceIijkll 18Ifthesignsonthe ljl lSeeFig lThus lijkl q Theorem representative clause tree sign ordering 34 Every sign ordered clause tree reversal equivalent unique Proof Let T N E L M sign ordered clause tree First T reversal equivalent representative clause tree Order chosen merge paths total order consistent relation Consider paths turn according ordering reverse path proper Since path reversal b Fig 18 Scores sign ordered clause node JD Horton B SpenccrArtijiciul Intelligence 92 1997 2589 55 Fig 19 If P Px proper P proper chosen merge path P patht h affects total score path includes h path precede P proper remain proper Paths include h internal node processed later matter time P processed proper The case left path P patht h head processed We P improper reversed P proper path corresponding P resulting clause tree P pafhr r proper See Fig 16 illustration P arises P This fact proved 32 proof Theorem 3 include proof completeness Let II node common P P P Let x total scores nodes common P P excluding n let y total score nodes PR P excluding n Let z total score nodes common P P Let j k scores n P reversal P P respectively Note X y z computed traversing away n See Fig 19 Then yix YiXl zjx 1 yzij2 yzka2ijk 21 1 P improper P R proper P proper add add ijk Lemma 33 Hence P proper Thus reversal change path processed proper Hence resulting clause tree representative The remainder theorem requires reversal equivalent representative clause trees sign ordering identical Suppose T T clause trees identical minimal number chosen merge paths T T mergeless reversal equivalent identical There ordering u2 uk atom nodes T extension ordering nodes T defined proof Theorem 17 There extension ordering atom nodes T 56 JD Horton B SpencerArtijicial Intelligence 92 1997 2589 I k ai u merge connected clause trees reversal equivalent Now consider head ai chosen merge path occurs ordering T Suppose ai ai different nodes Then u head corresponding path T Also chosen merge path T parhu chosen merge path T Since nodes paths occur ai ordering heads chosen merge paths tails chosen merge paths Hence paths reversal But paths proper contradiction assumptions Thus assume ai u The set chosen merge paths ui head T T Removing paths set merge paths leaves clause trees identical assumption Hence T T identical 0 The foothold score restriction applied clause tree In particular reject nonrepresentative clause tree contains improper path In procedure detects redundant clauses detected subsumption check 6 Tautology paths surgery minimal clause trees Most proof procedures based resolution allow twoliteral tautologies like produced subclause Such tautologies help production proof resolution This prevent procedure complete proof tautology proof tautology produced procedure instead Clause trees demonstrate If clause tree legal tautology path unchosen legal merge path parts clause tree removed adding open leaves In fact open leaves removed We operation clause tree surgery note clause trees surgery applied form important class clause trees Definition 35 Minimal legal tautology paths legal merge paths M clause tree A clause tree T N E L M minimal Conceptually minimality means reorder resolutions clause tree create smaller clause tree subsumes original clause That smaller proof result subset original resolution steps We start informal discussion types surgery clause trees formal unified presentation Operation 36 Let T N E L M clause tree tautology merge path P putht h legal T M We consider case P unifiable path later For sake following discussion assume path goes left right Thus h t divide T subtrees tail subtree A left t head JD Horton B SpencerArtificial Intelligence 92 1997 2589 51 Fig 20 Identifying areas tree surgery subtree C right h middle subtree B interior nodes P left h right t See Fig 20 includes If P merge path perform following steps called tail surgery P 1 2 3 4 5 Reverse chosen merge path t interior node head near support t subtree A Repeat chosen merge path t interior node head A Remove M chosen merge paths tails A Replace chosen merge path Q t head P CB Q defined subtree A clause Remove Add P set chosen paths M making Operation 28 resulting tree leaving t closed leaf t open leaf given Fig 21 An example If P tautology path tautology surgery P There t visible h In case sequence C P u head P By cases consider First assume support u t path P Let P P minimal chosen paths minimal sequence mean subsequence t P P property 1 Reverse 2 Perform merge paths P P tail surgery P path joining t h new clause tree The order paths reversed matter Theorem 3 1 reversals path paths head minimality Thus consider immediately replaced P f3 P Thus P merge path instead tautology path t P When Pk reversed P sign edge incident tail P changes order P P Each path reversal puts path reversal t The case considered T tautology path tail t visible head h We following operation internal surgery P 1 For node IZ B near support node h t h t select path Q pathu n u sees n t sees Lemma 261 reverse Q 2 Remove chosen merge paths tails middle subtree B 3 Not needed JD Horton B Spencer Artijkial Intelligence 92 1997 2589 u Skp 2 Fig 21 Tail surgery patldr h t 9u bnl I Fig 22 Tautology surgery I visible 11 t c IF JD Horton B SpencerArtificial Intelligence 92 1997 2589 59 c d 4 Remove 5 Identify middle subtree B T nodes t h If chosen path affected removal operation step 4 head contained subtree tail subtree P subgraph The parts path t h identified result surgery PR reversal P For example result surgery P c It worth pointing surgery merge path P generate different Fig 24 clause single definition The numbers steps Figs clause result surgery PR The different surgery operations given numbers steps Operation 36 correspond 2123 Operation 36 Clause tree surgery Let P parht h legal path clause tree t h tail T N E L M unifiable substitution t t chosen merge path Let V set nodes excluding complimentary sign head edge P h The operation surgery P T produces Tp Np Ep L Mp following sequence steps 0 Neither P _ _ _ z 3 K surgery P R s c 6 I c 3 Fig 24 Surgery P P JD Horron B SpencerArrijicial Intelligence 92 1997 2589 1 Let n atom node chosen merge path Consider t n Reverse step produces clause tree T N E L M V supports t supports h h V tail V head n comes path Repeat atom nodes V This 2 For chosen merge path M tail V remove M leave set chosen merge paths MMQIQin MandtailofQisinV These include paths reversed step 1 3 For chosen merge path Q paths t M replace Q paths h form M Q I Q M t head Q U path s h I path s t M 4 Remove E edges incident node V h obtain Ep let NNVh 5 Tail surgery If h V add P set chosen paths M M U P b Internal surgery If h V identify node h NP E delete nodes V path M h occur Let Mp resulting set merge paths t graph t 6 Define L L8 restricted NP U E It worth pointing tail chosen merge path seen tail unchosen path seen head path possible head Thus Operation 36 possible h V P unchosen We step 1 performed support node t h h V handled node IZ V way chosen merge path Q puth w n w V Note support nodes t V precisely near support nodes t nodes V Since 12 support node t paths Pi pathti hi 1 k t interior node P P C X P_ C P h If k 1 h_ P support node t P possible choice Q Otherwise h_ t V Therefore P possible h Hence choice Q t h But h V t visible t implies t invisible t invisible The operation surgery produce different outcomes depending step l different result clause selection paths However surgery application ends clause Thus operation surgery relation clause tree reversal equivalent Theorem 38 T trees reversal equivalent defined trees TA T characterized strictly speaking set paths selected welldefined alternate operation tree reversal equivalent In fact starts reversal equivalent application result original trees Theorem 39 classes clause isomorphism equivalence T isomorphic JD Horton B SpencerArtificial Intelligence 92 1997 2589 61 Theorem 37 The application surgery clause clause tree tree T path P results clear We tree This t visible negatively loss head edge P positive Then V set nodes t head tail path reversed step 11 Proof We use symbols given definition Operation 36 Assume generality t visible negatively Since assured Lemma 29d set nodes end step 1 V V N NP NP EP V E E Assume V Consider V Of course node V If h V h leaf clause node h u second node See Fig 23 example Let node u t u V Then path II h V n adjacent u t illegal path n t legal u V By Theorem 25 support node t pathu t The possible t n Thus n n u support node t chosen merge path head n tail outside step 1 See Fig 25 But reversal makes n closed leaf V gets reversed t possibly u nodes T outside V u exist T Hence adjacent nodes 7 adjacent t pathn t adjacent node nodes nodes V Consider node m T deleted step 4 Thus m NP The path joining m t T path goes U includes h includes P In case h V h t t path NP EP identified nodes P connected deleted Thus underlying If t h identified cycle created include nodes V step 5b Thus nodes NP connected graph NP Ep tree It difficult set associated NP Ep L mergeless clause tree Consider literals edges clause node c NP We V incident c instance clause Lc Lc For atom node clause nodes V deleted possibly h neighbouring In exceptional clause node u V When h identified t edge t v created The labels given L h t All identical elementary lb substitution LB ensures identically The NP Ep LO 4 built clause tree combined Definition case h V neighbouring atom nodes labeled incident u remain associated NP Ep tree literals Fig 25 In T showing u adjacent node V 62 JD Horton B SpencerArtificial Intelligence 92 1997 2589 We MP remaining chosen merge paths legal set merge paths Let Q MP Then tail Q V Nor head Q V imply head Q support t h But merge path T head Q sign reversed making node tail chosen merge path time head merge path This contradicts definition legal set merge paths Q nodes V starting outside V entering V leaving V Because possible entry points V h node V adjacent t Q included f h Thus Q included P subpath Then internal nodes P deleted step 41 breaking Q pieces step 51 t h identified Q single path Hence object M path head tail head tail merge path M Thus path merge path That MP legal set paths follows precedes relation M subrelation precedes relation 0 M extends partial order The following theorem points choice path perform surgery determines resulting clause tree path reversal Theorem 38 In applications clause tree surgery path P clause tree T resulting clause trees reversal equivalent Proof We use terminology Operation 36 Let n near support node t V The nondeterministic step clause tree surgery selection paths reverse step 1 Suppose applications surgery differ selection n The difference end step 1 Q pathr n Q parht path reversal Q Q patht t See Fig 26 Both 2 t outside V Reverse Q surgery 4 12 II L 121 Q l l t Reverse Q Fig 26 Different results different applications surgery JD Horton B SpencerArtificial Intelligence 92 1997 2589 63 pt t deleted step 2 Also t change t t deleted tails chosen merge paths V Hence step 4 tail chosen merge path step 2 surgery regardless Q Q2 t step head Q t t Thus head tail Q parht Reversing impact paths deleted reversed Thus edge change caused reversal patht difference effect surgery operations member Q M removed 2 It possible unchanged Q differ possible middle Therefore precisely paths Q patht edge sets end surgery operations Now consider trees differ path reversal patht effect reversing path reversals step 1 Hence corresponding final clause patht paths resulting t t pieces deleted t2 step l 0 resulting prove induction number near support nodes t nodes different paths selected trees reversal equivalent clause If surgery operations differ selection Theorem 39 Let T T reversal equivalent clause trees let P path t h unifiable path T surgery performed Let node t let node h head node head node merge set oft merge set h T Then result surgery P T result surgery isomorphism P T reversal equivalent T Similarly surgery surgery P loss generality head edge P positive Let Q pathx Proof First consider applying clause trees differ single path reversal Let T N E L M P patht h V Operation 36 Assume chosen merge path M Let T result reversing Q T Consider differences generality assume far possible paths reverse cases consider depending x y relative We start x y disjoint V use argument chosen path reversal equivalent y loss different surgeries choose We I h V h If x y Theorem 38 situation different step 1 By Lemma 29d set V surgery results surgeries t h P patht T surgery P step 1 Then T Without reversed step 2 surgery P If x y V Q removed head P edge T reversal QR Q removed nodes removed T T T respectively identical P T But T Q reversed V Then Q chosen 1 Thus QR reversed tree formed V removed Thus case resulting clause step 2 surgery P T T In step 4 surgeries edges edge head P trees step 2 surgery obtain QR head x V tail y outside reversed x support node t step clause form Q Hence end step 1 y V x If x V y V Q removed T T A similar argument works 64 JD Horton B SpencerArtificial Intelligence 92 1997 2589 We left case t h disjoint x y We know t h x x tail chosen merge path Let t y The case h y handled similarly working T T There subcases depending x V Let x V head edge Q positive Reversing Q interchanges role x y pathT h pafh x h In surgeries paths removed M location tails chosen merge paths affected path reversal Q Any chosen merge path pafhs t remains h step 3 In T pufhs step 2 surgery T replaced ps t puths y gets replaced ps X ps T turn gets replaced puths h step 3 surgery T Thus chosen merge paths end step 3 heads tails surgery operations The set nodes x visible negatively remains V nodes removed surgeries step 4 The edge head Q exists joins t y node u V This u removed surgery P T Similarly edge x u T replaces edge t u T removed surgery T Since node edge sets corresponding merge path head tail merge paths Thus resulting clause trees identical Let x V Q removed step 2 surgery T But T T x visible negatively V V U y x In step 4 Now nodes T different surgeries x y nodes removed interchange roles y kept x discarded surgery T x kept y discarded surgery T The edges removed step 2 u exists edge y U T replaced edge x U T Exactly paths removed step 2 cases The resulting clause trees isomorphic node x replacing node y mapping identity This case isomorphism required In cases path reversals needed If clause trees T T differ path reversals follows induction result surgery corresponding paths results clause trees 0 isomorphic reversal equivalent trees The importance surgery importance minimal clause trees come following theorem Theorem 40 Let T clause tree set S clauses If T minimal minimal clause tree T S clT c clT Proof Since T minimal legal tautology unchosen merge path P T Then tail surgery internal surgery performed P substitution variables Since surgery affect clause nodes completely removed resulting clause tree S The surgery remove open leaves insert corresponding clause smaller larger If resulting tree minimal surgery repeated 0 resulting clause tree minimal JD Horton B SpencerArtificial Intelligence 92 1997 2589 65 Fig 27 Supplanting path P head subtree T Thus nonminimal trees redundant minimal clause clause procedure desirable Hence search clause The surgery operations reversible construct clause trees able prune tree constructed nonminimal like path reversal One know inverse operation removed However reversed surgery tail surgery allow onesided trees Operation 41 Supplanting path Let P chosen merge path head h tail t clause tree T The path P supplanted head subtree following t place h 1 Make copy C head subtree P 2 Attach C T 3 Remove P set chosen merge paths 4 For chosen merge path tail subtree h add chosen merge path copy tail C copy head head subtree head subtree For example subtree Fig 27 copy C subtree T supplants path P tree tail surgery P inverts That result supplanting operation omitted path clause 7 Top procedures building clause trees AllPaths describing pseudocode In section develop building procedures ME SL ALP MinALP rooted clause trees explore properties We begin followed general setting intuitive descriptions procedures proofs completeness procedures Each procedure starts satisfiable clause C negation theorem set S input clauses axioms proved C added set input 66 JD Horton B SpencerArtificial Intelligence 92 1997 2589 clauses clauses propositional Each procedure assumes elementary clause trees clauses S C available The clause tree C clause One open atom node clause tree deterministically selected current node computation rule R Thus R determines search depth left right We usually select R depth left right right left Some procedures require R depth guarantees certain atom nodes visible having explicitly check All procedures contain nondeterministic steps selecting input clause resolve current atom node This causes search branch This nondeterminism implemented chronological tracking search parallel computation If failure results point current branch search terminated The procedure ultimately fails nondeterministic steps end failure 71 Visible lists ALP procedures Procedures ALP family use Ancestors paths Left Paths This family far consists ALP MinALP minimal ALP ALPOC MinALPOC The use ordered clause set restriction ancestor paths All procedures build trees left right At given step It sequence ancestors procedure open aI 2 a_ None nodes left open nodes right open leaves children ancestors See Fig 28 considered leaf Some overhead work required ALP procedures guarantee set chosen ancestor left merge paths legal In contrast set merge paths chosen ME SL procedures necessarily legal overhead required To maintained determine left path legal list called visible list Left Closed Subtrees Right Open Leaves Fig 28 Portions clause tree built JD Horton B SpencerArtificial Intelligence 92 1997 2589 61 Fig 29 Illustration support level tree visible literals visible support nodes Of course know level near ancestor support node n called current node A node n left consisting portion clause current node path current node pass near support node n The support nodes n support node appear path ancestor occurs path near support node occur Since tree rooted sufficient level support level n See Fig 29 When n calculated II excluding supports grandchildren A subtle point support n For grandchild level n levels ancestor consider level level n nearest ancestor support support support lists atom node grandchildren sufficient instance level n taking subtree beneath n closed levels grandchildren ancestor support support maximum inserted list maintained previously pair consisting level literal corresponding operations Recall subtree atom node 12 closed support The visible depth When calculated edge levels greater newly selected atom node removed This method Shostaks method keeping pointer keeping folding procedure 17 connection atom nodes selected level n ns upper list associated list When selected atom node entries track visible nodes Cliterals 29 It analogous enforced selected atom level visible analogous newly chain tableaux To implement ordered clause set restriction ancestor merge path clauses compared rejected detected deeper clause smaller number clause numbers neighboring ancestor node 33 adding Stickels PTTP list relatively The ALPOC algorithm implemented 34 These procedure operations inexpensive However visible selected overhead ALP PITP slows factor 2 4 inference agrees factor 3 mentioned The ALPOC frequently maintaining list adds expense list searched visible visible paths tautology 171 rise shorter proof number levels search decreased Because improves PTTP especially left paths left paths The 33 This node 68 JD Horton B SpencerArtificial Intelligence 92 1997 2589 iterative deepening search strategy forced look far number inferences decreased dramatically examples For instance TPTP 1381 problem GRPOO81 PTIP required 9061 115 inferences proof 12 levels search 12 extension steps 34 implementation ALPOC required 1260198 inferences proof 10 levels search 33 When compared version PITP compiles Prolog 35 modified version program build ALPOC proofs TPTP problem RNGOOl3 PITP required 13 1224 inferences 14284 seconds proof level 18 ALPOC required 6230 inferences 190 seconds proof level 14 For SYNOOl1005 PTIP compiles Prolog proof 26790196 inferences ALPOC proof 465 inferences 72 Finding minimal clause trees ALPOC tightest procedure mentioned generate proofs nonminimal redundant In fact example Fig 30 shows problem generates nonminimal clause tree All ancestor paths left paths handled ALP ALPOC But figure shows right paths All procedures ME SL GC construct clause tree left Fig 30 However legal unchosen merge path nodes labeled c If merge path nodes labeled reversed legal tautology path created nodes labeled c Thus adding ordered clause set restriction algorithms eliminate nonminimal proof We construct procedure MinALP avoids nonminimal proofs detecting missed paths Fig 30 Let t tail h head unchosen merge tautology path P clause tree produced ALP set propositional clauses If h ancestor t t current node ALP procedure path P discovered Hence possible T minimal corresponding MinALP tree Fig 30 A nonminimal ALP tree minimal tree surgery MinALP tree JD Horton B SpencerArtificial Intelligence 92 1997 2589 69 Similarly h descendant t ALP procedure discovered reverse P h current node Also h left r t current node P handled Thus assume h right t Therefore MinALP ALP additional step reject tree subtree h closed h seen node t left labeled atom h To check additional condition MinALP needs track information ALP Besides data structures required ALP list ancestors current node list nodes visible current node list ancestor supports current node MinALP needs maintain data structures invisible list nodes current node near left supports current node The operations data structures difficult implement A node added invisible list removed ALP visible list Once invisible list stays invisible list When calculating near left supports current node consider heads left paths current node occurs heads left paths heads occur ancestor supports left supports needed However Lemma 12 ancestor support left support ancestor maintained ALP ancestor support list The search path P parht h begin soon subtree h closed supports h known Consider candidates t nodes invisible list label h Eliminate set t ancestor list include near ancestor support h support h path I h makes P illegal Next left support d h eliminate t d ancestor list supports path f h P illegal If candidate remains clause _ A p d Fig 3 1 Candidate bad path P illegal P 70 JD Horton B SpencerArtijiciul Intelligence 92 1997 2589 tree far nonminimal Conversely procedure proceeds Thus MinALP builds minimal clause tree minimal trees candidate remains later construction subtree h complete In Fig 31 bad path P legal P In 12 asked MinALP complete know Even illegal left path P legal chosen chosen set P P P2 illegal MinALP stopped After choosing P MinALP One tree Fig 31 minimal candidate bad path P amend MinALP P legal left path chosen nearest ancestor support h stop P This nearest ancestor support h h open leaves right typically proof ancestors nearest ancestor nearly complete Unfortunately generate minimal clause trees left path candidate bad path illegal actually chosen rejects tree remaining illegal amended MinALP necessarily ways turn guaranteed support h It guaranteed proceeds illegal 73 Pseudocode clause tree procedures Procedure 42 corresponds 21 This Section 31 In section R selects procedure rightmost open atom node Such R depth However R need depth procedure Fig 5 described weak model Theorem 19 illustrated elimination procedure Procedure 42 Weak model elimination clause trees Initially T clause tree clause C 1 Start Let current atom node g RT rightmost open node 2 Tautology 3 Merge If tautology path ancestor g exists fail If merge path ancestor g exists choose path nondetermin If unifiable merge path ancestor g exists Continue istically Extension following label g label head path apply 0 label atom nodes path Continue 4 Extension common select T resolved T g nondeterministically clause tree T If exist fail Let 19 general unifier label g label selected atom T Resolve T T apply 19 label atom nodes Go Continue T choose If elementary clause tree S variables general unifier 13 5 Continue Now g closed node If open nodes exit success Otherwise Start Procedure 43 corresponds SL 16 described Section 33 An illustration given Fig 8 R procedure R selects rightmost open atom node need depth way ensure head left path right path sibling ancestor tail This condition guarantees JD Horton B SpencerArtificial Inrelligence 92 1997 2589 71 literal open paths legal Theorem 20 There ways maintains ancestors Stickel 37 notes factoring selecting waste time This inefficiency head hook soon hook chosen 28 42 shown 43 Procedure Changes Procedure set y potential factors goals common provable instance avoided Procedure 43 guarantee SLI siblings boldface This highlight section convention continued development procedures successive procedures Procedure 43 SL clause trees Initially T clause tree clause C 1 Start Let current atom node g RT rightmost open node 2 Tautology 3 Merge If tautology path ancestor g open leaf exists fail If merge path ancestor g open leaf exists choose path Continue If unifiable merge path ancestor g open general unifier 8 label g label following head path apply 8 label atom nodes T choose path Continue nondeterministically Extension leaf exists 4 Extension If elementary clause tree S variables common select T resolved T g nondeterministically clause tree T If exist fail Let 8 general unifier label g label selected atom T Resolve T T apply 0 label atom nodes Go Continue 5 Continue Now g closed node If open nodes exit success Otherwise Start paths tautology Procedure visible 44 GC described step 2 Section 34 An illustration R selects Fig 9 For Procedure 44 R depth Ancestor Merge step check ancestor path legal If R algorithm 48 Furthermore Letz et al 17 Proposi arbitrary selection corresponds leftmost open atom node given depth generate ALP proofs Definition tion 711 shown check needed complete functions internal nodes Procedure 44 ALP clause trees tree clause C Initially T clause 1 Start Let current atom node g RT leftmost open node 2 Tautology exists fail If tautology path ancestor g visible internal node 3 Merge If merge path ancestor g visible choose g visible Extension following path Continue internal node exists internal node exists If unifiable merge path ancestor nondeterministically general unifier 6 label g 72 JD Horton B SpencerArtificial Intelligence 92 1997 2589 label head path apply 8 label atom nodes T choose path Continue 4 xtensionl If elementary clause tree S variables common T resolved T g nondetetministically select clause tree T If exist fail Let 8 general unifier label g label selected atom T Resolve T T apply 8 label atom nodes Go Continue 5 Continue Now g closed node If open nodes exit success Otherwise Start Like Procedure 44 MinALP use depth selection function R In MinALP important check minimality step 5 assumes subtree h open nodes We use leftmost selection function R relaxed allow deepest open nodes selected Procedure 45 MinALP clause trees Initially T clause tree clause C 1 rurt Let current atom node g RT leftmost open node 2 Tuurology If tautology path ancestor g visible internal node exists fail 3 Merge If merge path ancestor g visible internal node exists choose path Continue If unifiable merge path ancestor g visible internal node exists nondeterministically Extension following general unifier 0 label g label head path apply 8 label atom nodes T choose path Continue 4 Extension If elementary clause tree S variables common T resolved T g nondeterministically select clause tree T If exist fail Let 13 general unifier label g label selected atom T Resolve T T apply 19 label atom nodes Go Continue 5 Continue Now g closed node For ancestor h g open descendants internal atom node f label h h fail endif end If open nodes exit success Otherwise Start The ordered clause set restriction implemented Procedure 42 Procedure 43 Procedure 44 Procedure 45 In Procedure 42 replace Merge step following Here refers total order set clauses In procedures ancestor merge step following merge steps unaffected JD Horton B SpencerArtificial Intelligence 92 1997 2589 73 Merge If merge path ancestor g exists head clause merge path G tail clause choose path Continue fail endif elseif unifiable merge path ancestor g exists head clause merge path Q tail clause Extension nondeterministically general unifier 0 label g label head path apply 8 label atom nodes path Continue following T choose Extension endif endif The procedures seen special cases generic procedure Procedure internal nodes merges tautologies 46 This procedure makes use visible puts restriction selection function Procedure 46 Generic procedure clause trees Initially T clause 1 Start Let current atom node g RT Let V nodes visible tree clause C g member Extension If unifiable merge path 2 Tautology If tautology path member V exists fail 3 Merge If merge path member V exists choose path Continue nondeterministically general unifier 8 label g head path apply 13 label atom nodes T choose If elementary common select T resolved T g nondeterministically clause tree T If exist fail Let 0 general unifier label g label selected atom T Resolve T T apply 19 label atom nodes Go Continue clause tree S variables V exists path Continue following 4 Extension 5 Continue Now g closed node If open nodes exit success Otherwise Start The AllPaths procedure Procedure 46 R depth left right selection trees paths function V visible nodes An AllPaths clause usual restrictions left paths right hooks ancestor paths In addition unchosen merge tautology paths ancestor paths right hooks legal left paths tautology paths unchosen merge paths A path node sibling ancestors right hook reversed left path This introduces 74 JD Horton B SpencerArtijicial Intelligence 92 1997 2589 definition add restriction redundancy left paths AllPaths trees reversed right hooks It recently shown l 11 closed AllPaths clause tree unsatisfiable set clauses exist Hence AllPaths procedure complete These clause trees closely related folding folding operations connection tableaux 17 We investigating procedures effectively building AllPaths clause trees All procedures improved somewhat checking tautology paths extension step new open leaves This expose tautology paths earlier prevent work For readability decided present searches tautology paths selected literal separate steps In propositional case tautology check extension step place selected node However order case tautology checks needed The check selected node tautology paths unifiable tautology paths check extension step By reasoning tautology paths unchosen merge paths arise point build ordering Detecting dealing subject ongoing research 15 disequality strategy See Section 91 74 Completeness results It known ME SL complete GC procedure equivalent ALP shown complete 117 Theorem 821 We provide alternative proof easily extended ALPOC procedure First structural definition ALP clause tree given characterizes type clause tree ALP procedure constructs Such tree exist S satisfiable S U C unsatisfiable We treat propositional case add ordered clause set restriction lift order logic All procedures section sound construct closed clause trees extension This guaranteed step construction elementary clause tree input clause merge path visible literal We start following lemma Lemma 47 For propositional logic Procedure 42 SL Procedure 43 ALP Procedure 45 ordered clause set restriction clause occur root closed clause tree produced ME 44 MinALP Procedure Proof Suppose clause C occurs proof node n Consider edge path root n Let literal associated edge Then C Hence associated edge incident n If occurs n tautology path exists atom node adjacent root But algorithms reject path construct clause tree Thus associated edge n But path joining atom nodes labeled adjacent n adjacent root JD Horron B SpencerArtificial Intelligence 92 1997 2589 merge path This path chosen algorithms extended clause tree contradiction 0 75 n Definition 48 ALP clause tree Given set S clauses ALP clause tree S closed rooted clause tree S meets following conditions 1 All chosen merge paths left paths ancestor paths 2 No ancestor paths tautology paths unchosen merge paths 3 No legal left paths tautology paths unchosen merge paths Theorem 49 Any ALP clause clause propositional tree constructed ALP procedure Procedure 44 Conversely logic ALP procedure constructs ALP clause trees S U C tree S U C clause C instance selection nodes depth procedure nondetemrinistically Proof Assume ALP clause tree Assume loss generality selects nodes left right As induction hypothesis assume left n constructed tree consisting procedure When n selected left tautology ancestor tail merge path procedure choose 3 Otherwise unifiable clause tree S U C Consider atom node n function R clause ALP tree rejected step 2 Procedure 44 tautology paths clause tree If atom node merge path step extend literal clause node immediately procedure looks left paths ancestor paths Any left path ancestor path considered tail current node If legal tautology path trees detected tautology paths Similarly left ancestor path tail resulting clause current node Since unifiable merge tautology path merge tautology path later construction clause detected chosen tree In particular resulting legal merge path tree unchosen merge tree rejected atoms propositional labeling Conversely choose clause containing current atom node choose complementary clause 0 The converse Theorem 49 necessarily hold case order logic 3 Definition The tree generated ALP satisfy condition 48 Suppose ancestor merge path P tree chosen ancestor merge step tail t P selected node head P identical labels t h identical algorithm check nondeterministic t Subsequent 2 condition substitutions applied 50 Completeness Theorem propositional exists ALP clause tree clause node labeled C root clauses C propositional propositional ALP Given S satisfiable clause S U C unsatisfiable set Proof We use induction number atoms set atoms S U C Let set singleton C In case ALP clause tree atom node labeled clause nodes degree set Then S C S 76 JD Horton B SpencerArtificiul Intelligence 92 1997 2589 Fig 32 The construction ALP tree T T Let distinct atoms S U C let leftmost Let S X 1 X E S GE X Suppose extending contradiction Therefore S unsatisfiable model maps true constructed literal C atom exists model S By model S U C Define S S n S S G S satisfiable Let S S C C Then S U C Ci unsatisfiable Let S S U C Ci_ I tree S U Cj clause Ci For exists ALP clause new atom node added clause node S smallest By induction clause node corresponding edge labeled Choose merge paths new open tree T See Fig 32 Cj tree attach new atom node leaves new root Name resulting new root Now clause nodes tree correspond Consider clauses labeled Consider clause clause tree singleton atom clause Let V set literals visible root tree Note V Let tree results T resolved elementary JD Horton B SpencerArtificial Intelligence 92 1997 2589 17 Then closed clause Suppose S unsatisfiable S labeled clause S attach atom nodes clause node V appropriate tree C c V Thus S b C S I V Construct resolve open leaves remain This tree ensures S unsatisfiable follows tree T S For labeled atoms restore clause S Then clause new tree V V T S V S U V unsatisfiable contradiction Therefore S satisfiable T choose merge paths necessary elementary clause Let C C V If C T resolved C literals T The result model S U C V false Thus model satisfies S S It satisfies C C C C Therefore S U C satisfied C merged left paths visible closed clause Extend clause contradiction Therefore S U C unsatisfiable tree Otherwise C Suppose maps literals model literals By induction exists ALP clause tree S clause C For clause node tree labeled clause S attach new atom nodes labeled atoms left hook merge paths atom node labeled Q atom node labeled clause Let T2 new clause V appropriate clause S U C Choose tree See Fig 32 restore tree It satisfies condition Now resolve T T2 atom node labeled choose left merge paths T2 visible nodes T close open leaves T2 The result 1 Definition 48 paths 2 atom T T 3 literals complementary merge paths T2 T necessary closed clause provided induction satisfied new ancestor merge paths merge occurs leaves T Also tautology ancestor paths introduced literal occur T occurrences satisfied T2 eliminates construction V tautology paths occur Furthermore chosen ancestor paths left paths Condition negative Condition 0 ALPOC Definition 51 C C An ALPOC clause ancestor chosen merge path satisfies clause Ci head clause clause S free Consider tree S ALP clause ordered clause set restriction That tail set clauses ordered tree C j Theorem 52 ALPOC complete propositional logic slight addition proof Theorem 50 The Proof The proof requires tree The extra induction works ALP clause set requirement ancestor restriction This accomplished ordered clause T clauses added S reverse order required clause set restriction Then literal u rest T chosen ancestor clauses clause head clause ordered clause set restriction As automatically tree replaced ALPOC clause chosen merge paths satisfy clauses clause precedes clause contains ordered clause vying way ordering satisfy 78 JD Horton B SpencerArtificial Intelligence 92 1997 2589 ancestor paths chosen recursively satisfied cid144I ordered clause set restriction In propositional case stronger version ordered clause set restriction ancestor path tail clause Ci head clause Cj j To justify suffices apply Theorem 50 clause tree T built induction The clause appear clause tree j This stronger restriction applied order logic case head tail clauses path identical instances clause The proof Theorem 50 suffices Theorem 53 ALP ALPOC complete order logic Proof Let S satisfiable set clauses let C clause S U C unsatisfiable We shall closed ALPOC tree S U C clause C There closed clause tree T S U C Construct onetoone mapping IJ distinct instances atoms T new distinct propositional atoms Apply II atom labels T resulting clause tree T based set propositional clauses S U C clause S derived clause S C clauses derived C manner 5 U C CC unsatisfiable cfT 4 Suppose S unsatisfiable Then closed clause tree S exists By applying inverse Ic finds closed clause tree S Thus S unsatisfiable contradicts hypothesis Therefore S satisfiable Select minimum 5 S U C Ci_ satisfiable S U Ci unsatisfiable By completeness ALPOC procedure tree T S U C Ci clause By applying inverse J T closed ALPOC clause tree S U C constructed C clause Since ALPOC tree ALP tree ALP complete 0 Note proof Theorem 53 allows unifiable merge paths remain unchosen There legal left ancestor unifiable merge path merge path T However instance C exist T identical clause Lemma 47 75 Three counterexamples For proof format important ask smallest proofs eliminated proof procedures use size proof important criterion guide search For example PTTP 34 SETHEO 18 use iterative deepening The following theorems ALP increase size proofs ALPOC increase Theorem 54 A smallest ALP clause clause tree tree set clauses smallest JD Horron B SpencerArrijcial Inielligence 92 1997 2589 79 Fig 33 A smallest proof smallest ALP proof Proof An example literals clause ordered left right given following clause clause I 4 9 Iq b Ib 4 7 fb q See Fig 33 q It known foothold size ME proofs set smallest MEOC proof size smallest ALP proof size smallest ALPOC restriction increase larger smallest ME proof Because proofs proof However left paths shrink case ordered restriction clause score Theorem 55 A smallest ALPOC clause tree larger smallest ALP clause tree 80 JD Horton B SpencerArtificial Intelligence 92 1997 2589 Proof An example given clauses clause clause 1 I41 2 4 3 4 Ca b 41 5 6 J ib ib See Fig 34 0 Section 51 points order logic ordered clause set restriction fails tail orient ancestor paths An ancestor path head clause ordered clause direction Here discuss generalization include clauses clause set restriction literals path Since merge path perfectly orient merge paths oriented scheme Unfortunately paths time scheme Fig 35 merge paths oriented general ordered clause set restriction We head paths paths choose leaves orient paths lexicographically In example given possible symmetric I P Fig 34 A smallest ALP proof smallest ALPOC proof JD Horton B SpencerArtificial Intelligence 92 1997 2589 81 Fig 35 This clause tree obey general ordered clause set restriction ancestor paths But matter incorrectly paths oriented leaf choose chosen 8 Mergeless clause trees The concepts unit resolution input resolution equivalent broad sense 521 This section resolution relative Horn set dedicated proving equivalent concept clauses known proving mergeless clause First recall equivalences trees following definitions 21 Let S set clauses A unit refutation S resolution proof S parent resolution unit clause consisting input refutation S resolution proof clause S parent resolution previous relative Horn set clauses substitution contains literal H result factor input clause S setting H closed literals occur clause S pair complementary set literals single literal An resolution linearity Theorem 56 Let S set clauses The following statements S equivalent S input refutation b S unit refutation c The set factors S contains relative Horn subset unsatisfiable d There exists mergeless closed clause tree S Proof The statements prove equivalent clause trees equivalent However statement examples easy work known implies d A ssume S input refutation Build clause steps refutation following modification Whenever proof merged literals open leaves identically merged literal attach clause node corresponding labeled corresponds literals instead choosing merge path tree leave labeled When input clause resolves open clause tree proof literal unified At step proof possibly copies leaves clause current clause tree 82 JD Horton B SpencerArtijicial Intelligence 92 1997 2589 literal The final clause tree closed final clause clause tree mergeless merge paths chosen d implies Assume S admits mergeless clause tree Order atom nodes tree search sequence long node adjacent node searched Depth breadth search acceptable Perform resolutions order Each step resolves input clause previous clause proof immediately input refutation b implies cd Assume S unit refutation Mirror refutation building clause trees resolutions Since unit clauses correspond clause trees single open leaf clause tree generated resolutions open leaves adjacent different clause nodes Thus merge performed unit refutation literals merged come input clause case merged resolution Thus instance input clause construction clause tree merge paths needed Thus resulting closed clause tree mergeless d implies b Let T closed mergeless clause tree based factors S Number atom nodes T 1 n number atom nodes starting atom node follow tree search algorithm proof ofd implies Consider resolution proof based corresponding resolutions reverse order When atom node processed resolutions atom node processed numbered higher tree search sequence Thus corresponds clause tree single open leaf Hence subtree corresponds unit clause The proof unit refutation resolution uses unit clause clause corresponds T c implies cd A ssume S unsatisfiable Horn set relative set H literals We assume ground literal complement H Since S unsatisfiable closed clause tree T based S Without loss generality assume T based ground clauses substituting constant variable At clause nodes T correspond clause literal H nodes T satisfied setting literals H true Root T node All edges adjacent root correspond literals H edges adjacent atom nodes correspond literals H But literals clauses H literals corresponding edges adjacent H Continuing way sees literal corresponding edge root atom node H literal corresponding edge away root atom node H Now consider chosen merge paths T None merge paths ancestor paths edge path closest root correspond literal H edge furthest root H Then literals unified Thus merge paths left paths right paths Order paths totally reverse order precedes relation added constraint paths comparable transitive closure precedes relation path head root come earlier order Thus JD Horton B SpencerArtificiul Intelligence 92 1997 2589 83 d implies processed tautology paths tree mergeless closed T closed mergeless clause tree S Without T unifiable path order head chosen merge path head path tree Supplant paths path path subtree head order When path supplanted path path After paths resulting clause processed loss c Assume generality assume surgery Root T clause node For tautology path removed internal n root If Pn passes atom node n consider atom node m unifiable II perform n It matter T longer mergeless For atom nodes tail atom node set merge paths place literal corresponding H H contain corresponding merge path left right path unifiable tautology path original clause tree Note clause node T contains precisely literal H root contain Thus set clauses corresponding clause nodes T set factors S form Horn set relative atom nodes ancestor path If path P joining turned H unsatisfiable tail surgery pcm complementary edge path Pn unifiable literals q Corollary 57 If T closed mergeless clause tree S unit refutation reversed input refutation S order refutations 9 Future work conclusions This paper contains references research These collected expanded contributions ongoing work raises questions future section summary 91 Open problems future work Open question 1 Completeness Let S satisfiable S U C unsatisfiable There sign ordered ALP clause tree S clause C ancestor paths proper ALP foothold let C clause score restriction set clauses ALPF If Open question 1 true ALPF orients ancestor paths ALPOC orient including improvement clause head tail ALPOC Open question 2 Is complete minimal clause reduced search space procedure trees reversal equivalent generate takes advantage 84 JD Horton B SpencerArticial Intelligence 92 1997 2589 We want exclude consideration procedures use generate test approach building minimal clause trees For instance propose ALP procedure followed test minimality constructed tree Such procedure require large additional searching constructed tree associated benefit reducing search construct Ideally small checking constructed tree required ensure minimal Open question 3 Is polynomial p complete procedure generate minimal clause trees reversal equivalent size pn II size smallest clause tree set input clauses Many implementations theorem provers clause tree empirical investiga build tions needed We developed compiler based PITP ALPOC clause trees We planned extensions use disequalities build AllPaths trees The experiments use TPTP problem library written automatically run large number jobs batch mode collect summarize results 33 It reported Section 74 ALP procedure set order clauses generate nonALP clause trees contain unchosen merge paths tautology paths The check paths tail path current node time path unifiable merge tautology path Since later substitutions convert unifiable paths merge tautology paths required check later want avoid unchosen merge tautology paths Hynes 15 implemented ALP metainterpreter Prolog creates list disequalities A pair nodes labeled identically head tail unifiable disequality tautology path unchosen unifiable merge path The procedure maintains list disequalities encountered far tree adds list new disequalities current node Whenever substitution applied list disequalities checked pair identical labels tree rejected The current implementation applies ALP uses iterative deepening search strategy chronological backtracking Preliminary experiments examples 95 inferences avoided number disequalities commensu rate size tree Work ongoing compare benefits overhead building checking disequality list These disequalities similar identical syntactic inequality constraints SETHEO 18 The AllPaths procedure builds clause trees ancestor left paths right hooks recently shown complete Any implementation include method preventing left path running head existing right hook An existing AllPaths prototype propositional logic 27 extended compiler Prolog PTTP style effectiveness measured ITTP ALPOC We flexible choice selection functions offered clause trees improve performance SL clause tree procedure Sharpe 28 implemented replaces usual depth selection function selects selection head left hook soon path chosen We headfirst JD Horton B SpencerArtificial Intelligence 92 1997 2589 85 chooses factoring function points compensating usable determines common provable decrease SL proof size head right hook open leaves Stickel search unified goals overinstantiated head left hook provable goal factored goals immediately space increases proof 34 By selecting instance Other future work compiler incorporate failure caches 23 Our intention code depending options selected restriction selection foothold score restriction right hooks lemmas including disequalities produce use lemmas caches generate different left paths ordered clause set right hooks AllPaths head defining canonical Minimal clause trees chosen merge paths restricted oriented form binary resolution proofs way progress In ALP family procedures nonancestor chosen merge paths forced left paths right ancestor chosen merge paths restricted ordered score clause effective clause complete procedure trees important question building minimal set restriction foothold restriction finding Thus clause clause However check trees redundant representative minimal procedures problem clause trees address nonrepresentative trees canoni representative cal form chosen merge paths oriented By retaining posed Wos 4O minimal 6 redundancy detect Nonminimal tree Other systems OTTER use type redundancy analysing subsumption check redundancy increases number retained clauses Thus cost producing set clause trees redundant grow slowly resolution Any resolution based procedure set clauses binary trees Once non turned produces minimal surgery clause tree The strategy procedure choose complete procedure preserve completeness The second preserve tree Other procedures minimal performing completeness The cost subsumption cost producing procedure procedure minimal tree representative clause simply produces 13141 clause clause reject The equality investigated relation plays special Paramodulation technique paths justify equality substitutions justify handling factoring Another open question extend clauses admit exponentially formulas problems solved exponential problems problems solved pigeonhole problem clause 9 The negation clause HOW substitutions substitutions polynomial solved polynomially role order logic Paramodulation inference implemented analogously trees way merge paths clause clause trees handle proofs use 24 Many propositional number resolution large closed clause trees However satisfiability steps 46 Hence allows replace dealt time 4739 One method allow single variable conjunctions conjunction clause performed open questions represented trees 86 JD Horton B SpencerArtijcial Intelligence 92 1997 2589 92 Summary conclusions Clause trees offer new insights implementing understanding binary resolution The distinction binary resolution clauses binary resolution clause trees small point view With clauses operations performed literals resolved removed duplicate literals merged In paper uncoupled merge delayed later new literal merged literal previously resolved complementary Despite subtle difference interesting advantages Often binary resolution clauses result sequence resolution steps gives result superior steps different order merge opportunities missed second sequence With clause trees sequences superior result merges necessary remove literals Thus clause tree represents multiple different sequences binary resolution steps dynamically choose best outcome The interaction merge paths clause tree provides information decide easily merge legal While merge paths unify concepts reduction inference steps different forms factorization prevent inference steps frameworks different kinds merge paths distinguished implementations In particu lar ancestor merge paths ancestor resolution merge paths hooks correspond SL factoring left paths perform Shostaks creductions Thus different types merge paths treated differently procedures Section 7 From viewpoint proof theory uniformity advantage arguments Section 8 simplified One important result precedes relation chosen merge paths extendible partial order From result follows quickly ME SL sound It leads new concepts visibility support With deeper understanding internal structure binary resolution developed ALP procedure soon realized closely related GC This paper introduces minimal property clause trees This strong property means intuitively exist tautology clause missing merge binary resolution derivations clause tree represents In words clause tree contains unnecessary steps tree redundant For nonminimal clause tree minimal clause tree subsumes The operation surgery clause trees removes unnecessary steps leaving result general original tree Clause tree surgery applied partial closed trees applied successively minimal tree remains We know inference technique rebuilding proof improve result proof surgery The procedures ME SL GC explained unified manner For procedures permissible reverse ancestor paths head replaced tail The ordered clause set restriction foothold score restriction advantage fact They force path oriented ways JD Horton B SpencerArtijicial Intelligence 92 1997 2589 87 cut space searched procedures This leads inter alia ALPOC procedure Two new ideas proof procedures presented The ability detect nonminimal clause trees lead development new restriction new procedures MinALP MinALPOC introduced Procedure 46 use selection function tighter advantage goals tree proved This generalizes SLI unrestricted selection function use Cliteral GC use depth selection function A variant Procedure 46 uses depth selection called AllPaths known complete proof included paper use A family proof procedures Unit resolution input resolution resolution relative Horn sets shown identical mergeless clause trees The arguments compact include number known results We evidence clause trees improve understanding resolution Two equivalent theorems 29 l Theorem 21 proved 1970s related Theorem 13 Instead merge paths graphs use simple cycles indicate merge Both theorems state graph represents sound proof certain type cycle exist Such cycle exists corresponding clause tree set merge paths contains circular set precedes relation That precedes relation extendible partial order The advantage working trees graphs trees simpler structures For example nodes tree connected unique path Using clause graphs Shostak developed GC procedure significant improvement SL implementation 1970s But 1994 professional appeared 17 Letz et al use connection tableaux rooted tree structure folding procedure Using rooted clause trees extended procedures tighter But require ancestor paths free duplicate atoms head tail chosen merge paths paths restricted Thus paths tree treated identically This effect making clause trees larger necessary Unrooted clause trees potential rooted trees paths treated way We believe strongly study clause trees provide opportunities development faster automated reasoning procedures Acknowledgments The authors gratefully acknowledge efforts anonymous reviewers members Automated Reasoning group UNB including Mike Boothroyd Kelsey Francis Rod Hynes Mike Lamoureux Charlie Obimbo David Sharpe Qinxin Yu NSERC funding 88 JD Horton B SpencerArtificial Intelligence 92 1997 2589 References l PB Andrews Refutations matings 2 OL Astrachan elimination Academic Publishers Dordmcht DW Loveland METEORS provers model RS Boyer ed Automuted Reasoning Essays Honor Woody Bledsoe Kluwer high performance IEEE Trans Cmpur 25 1976 801807 theorem 3 OL Astrachan 1991 M Stickel Caching lemmaizing model elimination theorem provers D Kapur ed Automared Deduction CADEII Saratoga Springs Lecture Notes Artificial 607 Springer Berlin 1992 224238 4 W Bibel Short proof pigeonhole formulas based connection method Intelligence J Aurom Reasoning 6 1990 287297 5 CL Chang RCT Lee Symbolic Logic Mechanical Theorem Prooing Academic Press New York 1973 6 V Chvatal E Szememdi Many hard examples 7 SA Cook RA Reckhow The relative efficiency propositional resolution J ACM 35 1988 759768 proof systems J Symbolic Logic 44 1979 3650 8 N Eisinger Completeness Confluence Reluted Properties Clause Graph Resolution Research Notes Artificial Intelligence Pittman LondonMorgan Kaufmann San Mateo CA 1991 9 A Haken The intractability resolution Theoret Comput Sci 39 1985 297308 lo F Harary Graph Theory AddisonWesley 111 JD Horton D Sharpe private communication l2 JD Horton B Spencer A DreschlerFischer Gesellschaft S Pribbenow tiir Informatik Bonn 1995 7980 Reading MA 1969 algorithm L eds KI95 Activities Workshops Posters Demos Bielefeld minimal clause trees 13 JD Horton B Spencer Reducing search minimal clause trees Tech Rept TR95099 Faculty Computer Science University New Brunswick Fredericton NB Canada 1995 14 JD Horton B Spencer Bottomup procedures minimal clause trees Tech Rept TR96101 Faculty Computer Science University New Brunswick Fredericton NB Canada 1996 15 R Hynes The disequality strategy Science University New Brunswick Fredericton NB Canada theorem proving undergraduate 1995 thesis Faculty Computer 16 R Kowalski D Kuehner Linear resolution selection 171 R Letz K Mayr C Goller Controlled Autom Reasoning 13 1994 297337 integration cut rule connection tableau calculi J function Arrif Intell 2 1971 227260 18 R Letz J Shumann S Bayer1 W Bibel SETHEO highperformance theorem prover J Autom Reasoning 8 1992 183212 19 J Lobo J Miner A Rajasekar Fundumenruls Disjuncture Logic Progrumming MIT Press Boston 1992 20 DW Loveland Mechanical 21 DW Loveland Automated Theorem Proving A Logicul Basis NorthHolland Amsterdam 22 WW McCune OlTER 20 users guide Tech Rept ANL909 Mathematics theorem proving model elimination J ACM 15 1968 236251 Computer Science 1978 Division ArgOMe National Laboratories Argonne IL 1990 23 J Minker G Zanon An extension linear resolution selection function Inform Process Serf 14 1982 191194 24 NV Murray E Rosenthal Dissolution making paths vanish 1251 R Reiter Two results ordering resolution merging ACM 40 1993 504535 linear format J ACM 18 1971 630646 26 JA Robinson A machineoriented 27 D Sharpe AllPaths New Brunswick Fredericton NB Canada theorem prover Undergraduate 1995 pessimistic factoring basic logic based resolution principle J ACM 12 1965 2341 thesis Faculty Computer Science University 28 D Sharpe Backwards ed Proceedings Ninth Florida Artificial intelligence Research Symposium Key West FL 1996 459462 analog basic J Stewman factoring 29 RE Shostak Refutation graphs Artif Intell 7 1976 5164 JD Horton B SpencerArtificial Intelligence 92 1997 2589 89 30 B Spencer Linear resolution ordered clauses J Lobo D Loveland A Rajasekar eds Proceedings ILPS Workshop 31 B Spencer The ordered clause Disjunctive Logic Programming restriction model elimination San Diego CA 1991 SLI resolution D Miller ed Proceedings International Symposium Logic Programming Vancouver BC 1993 678 32 B Spencer Avoiding duplicate proofs foothold refinement Ann Math Artif Intell 12 1994 117140 33 B Spencer TR95094 JD Horton K Francis Experiments theorem prover Tech Rept Faculty Computer Science University New Brunswick Fredericton NB Canada 1995 J implementation extended Prolog compiler theorem prover ALPOC technology 34 M Stickel A Prolog Autom Reasoning 1 1988 353380 35 M Stickel A Prolog technology theorem prover new exposition implementation Prolog Theor Comput Sci 104 1992 109 128 36 M Stickel personal communication 37 M Stickel Upsidedown metainterpretation model elimination theoremproving procedure deduction abduction J Autom Reasoning 13 1994 189210 38 G Sutcliffe C Suttner T Yemenis The TPTP problem DeductionCADE12 252266 Nancy Lecture Notes Artificial library Intelligence D Kapur ed Automated 814 Springer Berlin 1994 39 GS Tseitin On complexity derivations propositional calculus AO Stisenko ed Studies Muthemutics Mathemutical Logic Part II Consultants Bureau New York 1970 115125 40 L Wos Automuted Reasoning 33 Busic Research Problems PrenticeHall Englewood Cliffs NJ 1988