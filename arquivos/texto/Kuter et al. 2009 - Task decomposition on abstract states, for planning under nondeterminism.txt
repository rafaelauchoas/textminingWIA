Artiﬁcial Intelligence 173 2009 669695 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Task decomposition abstract states planning nondeterminism Ugur Kuter Department Computer Science Institute Systems Research Institute Advanced Computer Studies University Maryland College Park MD 20742 USA b Institute Scientiﬁc Technological Research IRST Fondazione Bruno Kessler Via Sommarive 18 Povo 38050 Trento Italy Dana Nau Marco Pistore b Paolo Traverso b r t c l e n f o b s t r c t Article history Received 1 October 2007 Received revised form 26 November 2008 Accepted 26 November 2008 Available online 6 December 2008 Keywords Planning nondeterministic domains Hierarchical tasknetwork HTN planning Binary decision diagrams Although approaches developed planning nondeterministic domains solving large planning problems diﬃcult In work present new planning algorithm called Yoyo solving planning problems fully observable nondeterministic domains Yoyo combines HTNbased mechanism constraining search Binary Decision Diagram BDD representation reasoning sets states state transitions We provide correctness theorems Yoyo experimental comparison MBP NDSHOP2 previouslybest algorithms planning nondeterministic domains In experiments Yoyo easily deal problem sizes MBP NDSHOP2 scale solve problems 100 1000 times faster MBP NDSHOP2 2009 Elsevier BV All rights reserved 1 Introduction Although highly eﬃcient algorithms built classical planning applicability algorithms limited restrictive assumptions classical planning Hence rapidly growing planning domains violate assumptionsfor example nondeterministic planning domains actions nondeterministic outcomes1 Although approaches developed planning nondeterministic domains problem hard solve practice simplifying assumption observability assumption state world completely observed runtime Indeed case nondeterministic domains planning algorithm reason possible different execution paths ﬁnd plan works despite nondeterminism dimension generated conditional plan grow exponentially Before development Yoyo algorithm described paper bestperforming algorithms planning nondeterministic domains MBP 12 NDSHOP2 3 MBP uses suite planning algorithms based Symbolic Model Checking represent states symbolically Ordered Binary Decision Diagrams BDDs 4 In experimental studies MBPs planning algorithms easily scaled largesized problems 2 This largely fact BDDs represent large sets states compact Corresponding author Email addresses ukutercsumdedu U Kuter naucsumdedu D Nau pistoreitcit M Pistore traversoitcit P Traverso 1 Unfortunately phrase nondeterministic outcomes meanings current literature researchers attach probabilities outcomes Markov Decision Process omit probabilities nondeterministic automaton Our usage 00043702 matter 2009 Elsevier BV All rights reserved doi101016jartint200811012 670 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 Fig 1 Average running times seconds MBP NDSHOP2 HunterPrey Domain function grid size prey NDSHOP2 able solve planning problems grids larger 10 10 memoryoverﬂow problems formulae refer salient properties states As example suppose blocks world formula f represents set states S want reason set states S block table This set states represented formula like f ontablea NDSHOP2 planner nondeterministic domains uses Hierarchical Task Network HTN decomposition technique like wellknown SHOP2 planner 5 deterministic domains NDSHOP2s HTNs pro vide domainspeciﬁc information constrain planners search Among actions applicable state NDSHOP2 consider actions obtain HTN decomposition prevent exploration large portions search space reasons believe portions unpromising For example blocks world objective stack blocks location want consider actions particular blocks blocks domain Under right conditions NDSHOP2 perform example 3 describes cases outperforms MBP NDSHOP2 MBP use different techniques reducing size search space MBP reasons large sets states aggregate entities NDSHOP2 focuses parts search space produced HTN decomposition As consequence situations algorithm substantially outperform As simple example consider wellknown HunterPrey domain 6 In HunterPrey domain world n n grid planner hunter trying catch prey The hunter ﬁve possible actions north south east west catch applicable hunter prey location The prey ﬁve actions movement actions plus staystill actionbut instead representing prey separate agent possible actions encoded nondeterministic outcomes hunters actions In domain solution policy set stateaction pairs telling hunter conditions guarantee prey eventually captured There sets HunterPrey problems NDSHOP2 exponentially faster MBP sets HunterPrey problems reverse true Fig 1 shows average running times required MBP NDSHOP2 hunterandprey problems prey function increasing grid sizes2 NDSHOP2 ran memory large problems solution policies domain contain huge number stateaction pairs NDSHOP2 represents stateaction pairs explicitly MBP hand uses compact propositional formulas represent sets states share salient common properties searches search space nodes formulas having separate node state This dramatically reduces size search space MBPs small running time Fig 2 shows average running times required MBP NDSHOP2 ﬁx grid size 4 4 increase number prey catch movements prey dependent assuming prey location prey In case NDSHOP2 outperforms MBP able use simple extremely effective pruning heuristic constrain search choose prey chase ignoring catch prey choose chase continue way prey caught 2 All experiments run AMD Duron 900 MHz laptop 256 MB memory running Linux Fedora Core 2 time limit 40 minutes problem Each data point average 20 randomlygenerated problems In experiments planning algorithm solve problem time limit required memory available experimental run problem size Each data point ﬁve failures omitted results shown ﬁgures Thus data worse performing algorithm NDSHOP2 Fig 1 MBP Fig 2 look better wasbut makes little difference disparity algorithms performance great U Kuter et al Artiﬁcial Intelligence 173 2009 669695 671 Fig 2 Average running times seconds MBP NDSHOP2 HunterPrey Domain function number prey ﬁxed 4 4 grid Fig 3 A visual characterization planning domains Yoyo best MBP hand consider applicable actions node search space produces larger branching factor larger search space This paper presents formalism novel algorithm called Yoyo combines power HTNbased search control strategies BDDbased state representation Yoyo implements HTNbased forwardchaining search NDSHOP2 built MBPs techniques representing manipulating BDDs This combination required complete rethinking NDSHOP2 algorithm order advantage sit uations BDD representation allow avoid enumerating states explicitly In backwardsearch planner MBP goal subgoal set states represented naturally BDD But forwardsearch algorithms like NDSHOP2 normally apply actions individual states BDDs effectively determine sets states usefully combined single BDD apply actions sets states One contributions paper way things Besides deﬁnition Yoyo planning algorithm provide theorems soundness completeness experimental results demonstrating performance Our experiments planning domains divided types corresponding parts Fig 3 1 Planning domains Yoyo NDSHOP2 better MBP In domains HTNs Yoyo NDSHOP2 provided good pruning search space MBPs BDDs provided special advantage The reason domains NDSHOP2 use dont care conditions particular type state abstraction enabled HTNs effects preconditions actions NDSHOP2 described searchspace compression Yoyos BDDs 2 Planning domains Yoyo MBP better NDSHOP2 These domains NDSHOP2s HTNs provide good pruning search space BDDs Yoyo MBP provide better compression search space NDSHOP2s dont care conditions 3 Planning domains Yoyo better MBP NDSHOP2 In domains HTNs BDDs useful reducing search space Yoyo signiﬁcant advantage NDSHOP2 MBP NDSHOP2s MBPs running times increased exponentially faster Yoyos Yoyo solve planning problems orders magnitude quickly MBP NDSHOP2 easily deal problem sizes MBP NDSHOP2 scale 672 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 This paper organized follows Section 2 presents formalism deﬁnitions notation paper Then Yoyo planning algorithm mechanisms uses generate solutions nondeterministic planning problems Sections 3 4 respectively Next Yoyo uses BDDs compact representations states Section 5 Section 6 gives theoretical analysis planning algorithm We experimental evaluation Yoyo results evaluation Section 7 We conclude paper discussion related work ﬁnal remarks 2 Basic deﬁnitions notation In section deﬁnitions notation formalism algorithms discuss later paper 21 Nondeterministic planning domains Most deﬁnitions usual ones nondeterministic planning domains planning problems 2 A nondeterministic planning domain modeled nondeterministic statetransition Σ S A γ S A ﬁnite sets possible states actions domain statetransition function S γ S A 2 An action applicable state s γ s cid5 The set states applicable cid2 cid3 s S γ s cid5 Sa Conversely set actions applicable state s cid3 cid2 A γ s cid5 As A state s live action applicable s s dead We consider policy partial function3 π S A let Sπ S π s domain π total The execution structure Σπ policy π labeled digraph includes states actions reachable function Sπ A π Formally Σπ V π Eπ V π S Eπ S S Sπ V π state s V π π s deﬁned action s π s Eπ s s cid9 cid9 γ s s cid9 V π cid9 Each edge execution structure Σπ labeled action π s For clarity discussions denote edge Σπ triple s π s s cid9 rest paper For states s s s path Σπ s s A terminal state π state s Sπ successors Σπ We let St π denote set terminal states Σπ An execution path π path Σπ begins initial state inﬁnite ends terminal state Σ descendant s cid9 Σπ Σ reachable s We deﬁne reachability respect policy π For states s s cid9 Σ path Σ s s cid9 s A planning problem nondeterministic planning domain Σ triple Σ S 0 G S0 S set initial states G S set goal states Solutions planning problems nondeterministic domains usually classiﬁed weak execution path reach goal strong execution paths reach goals strongcyclic fair execution paths reach goals 79 More precisely π descendant s s s π ancestor s s Σ ancestor s π reachable s s cid9 cid9 cid9 cid9 cid9 cid9 A strong solution policy guaranteed reach goal state despite nondeterminism domain That policy π strong solution cycles execution structure Σπ execution path Σπ ends goal state A weak solution provide possibility reaching goal state doesnt need guarantee goal state reached More speciﬁcally policy π weak solution s S 0 execution path Σπ ends goal state A strongcyclic solution policy π following properties ﬁnite execution path π ends goal state cycle Σπ contains Σπ ancestor goal state Such policy guaranteed reach 3 The reason making π partial function domain neednt contain states reach U Kuter et al Artiﬁcial Intelligence 173 2009 669695 673 goal state fair execution execution doesnt remain cycle forever theres possibility leaving cycle4 A nondeterministic planning problem weakly strongly strongcyclicly solvable weak strong strongcyclic solution respectively A policy π candidate weak strong strongcyclic solution satisﬁes conditions stated following change require execution path Σπ end goal state live terminal state Intuitively π candidate solution possible extend solution π candidate solution way π extended solution 22 Hierarchical task networks HTNs nondeterministic domains Our deﬁnitions primitive tasks nonprimitive tasks task networks methods abstracted versions ones Simple Task Network STN planning 10 Chapter 11 We assume existence set T tasks performed T includes actions A additional tasks called nonprimitive tasks5 An HTN pair T C T set tasks C set partial ordering constraints tasks The HTN pair T C T C A method describes possible way decomposing nonprimitive task set subtasks Rather getting syntactic details method represented deﬁne method abstractly partial function m S T H S T H sets possible states tasks HTNs If s t domain m ms t deﬁned m applicable task t state s ms t HTN produced applying m t s If ms t T C T t1 tk set tasks C set constraints m decomposes t T C state s As example informal description method use task chase_prey HunterPrey domain method north_chase task chase_prey applicability conditions prey caught prey north subtasks 1 move_north 2 chase_prey constraints subtask 1 subtask 2 This method applicable states prey caught currently north hunter speciﬁes hunter ﬁrst north continue chasing prey One deﬁne similar methods cases prey east south west hunter In constructing plan policy task HTN planner consider actions produced applicable methods For example north_chase applicable methods applicable action plan policy move_north regardless actions applicable s Let s current state χ T C HTN t0 T task predecessors T C contains constraints form t t0 Then t0 primitive case want use action accomplish nonprimitive case want decompose method We consider cases Case 1 t0 primitive task t0 action If action applicable s produce set cid9 C constraints C mention t0 cid9 T t0 C cid9 T cid9 C successor states γ s t0 task network T We task network τ χ s t0 Case 2 t0 nonprimitive task If method m applicable t0 s produce task network ms t0 cid9 T C place t0 Formally cid9 C cid9 We let δχ s m t0 task network produced inserting T cid9 C T δχ s m t0 T cid9cid9 cid9cid9 C cid5 cid4 cid9cid9 cid9cid9 C T C cid9 T t0 T cid9 cθt c C t T cid9 θt substitution replaces t0 t Given HTN T C set methods M policy π execution path p π current state s p path p accomplishes T C s following conditions true6 4 This equivalent saying action nonzero probabilities outcomes probability leave cycle zero 5 The authors 10 Chapter 11 speciﬁc syntactic representation tasks details representation irrelevant purposes paper 6 These conditions straightforward adaptation conditions π accomplish T deterministic planning domain Chapter 11 10 details 674 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 1 T Then π accomplishes T C state s terminal state path pie π accomplishes T C π s undeﬁned 2 There primitive task action t0 T predecessors T action t0 applicable s successor state s s path p s cid9 cid9 γ s t0 p accomplishes τ χ s t0 s cid9 3 There nonprimitive task t0 T predecessors T method m M applicable t0 execution path p accomplishes δχ s0 m t0 s δ deﬁned Given HTN T C set methods M policy π execution structure Σπ π strongly accomplishes T C execution paths π accomplish T C initial states We deﬁne Σ χ The deﬁnition weakly accomplishes similar requires initial state s0 S0 path starting s0 accomplishes T C Also deﬁnition strong cyclicly accomplishes similar requires fair execution paths π accomplish T C If execution structure Σπ policy π weakly strongly strongcyclicly accomplishes HTN χ T C state s policy π weakly strongly strongcyclicly accomplishes T C s deﬁnition HTN accomplishment Note weakly accomplishing HTN χ policy π Σ χ strong strongcyclic case Σ χ π execution structure contains execution paths Σπ considered satisfying π Σπ π Σπ We extend deﬁnition planning problems nondeterministic planning domains solutions planning problems refer HTNs follows We deﬁne nondeterministic HTN planning problem tuple P Σ S0 G χ M Σ nondeterministic planning domain S0 S set initial states G S set goal states χ HTN M set methods A policy π candidate solution P π candidate solution nondeterministic planning problem Σ S0 G HTNs A weak strong strongcyclic solution nondeterministic HTN planning problem policy π π weakly strongly strongcyclicly accomplishes χ S0 methods M π weakly strongly strongcyclicly solves nondeterministic planning problem Σ S 0 G execution path Σ χ π execution structure contains execution paths execution structure Σπ π necessary satisfy HTN accomplishment requirements given previously Section 22 π ends goal staterecall Σ χ 23 Notation involving sets states This section extends deﬁnitions Sections 2122 refer sets states Later Section 5 discuss sets states represented Symbolic ModelChecking primitives A setbased statetransition function γ deﬁned cid6cid2 cid3 γ S γ s s S S set states action γ statetransition function deﬁned Section 21 Intuitively γ S set successor states generated applying action state s S applicable state γ s cid5 A setbased policy mapping π disjoint sets states actions Formally π partial function partition S1 Sk S A Note π S1 Sk A setbased policy map π ordinary policy policy π follows cid2cid4 cid3 cid5 s π S Hence deﬁne π s execution structure policy π 1 cid2 cid2 k s S π S deﬁned Σ π Σpolicy π Let t task m method suppose set states S ms t ms cid9 S Then states S t mequivalent let mS t ms t s member S matter cid9 t s s Let S set states χ HTN Suppose t nonprimitive task If δχ s m t δχ s cid9 m t cid9 S let notation δχ S m t represent task network produced decomposing t m cid9 S states s s member S Similarly t primitive task action τ χ s t0 τ χ s τ χ S t0 represents task network produced applying t0 member S cid9 t0for states s s 3 Yoyo HTNs BDDs In section Yoyo new planning algorithm nondeterministic domains Yoyo HTN search algo rithm combines NDSHOP2s HTNbased search control MBPs symbolic modelchecking techniques reasoning sets states sets state transitions U Kuter et al Artiﬁcial Intelligence 173 2009 669695 675 cid9 pair S χ F S G χ HTN largest subset S st t applicable state S let S S cid9 t π returnFAILURE returnFAILURE t primitive task action cid9 t τ χ s t F state s S cid9 cid9 cid5 insert S insert γ S return π π candidate solution returnFAILURE F return π F S G S π χ S χ F S G S π cid5 pair S χ F χ HTN Procedure YoyoF G M π 1 2 3 4 5 6 7 8 arbitrarily select pair S χ F remove 9 nondeterministically choose task t predecessors χ 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 F F S χ 27 F S 28 29 30 return π endprocedure method m returnFAILURE cid9 m t S S insert S pairs S χi S j χ j F χi χ j nondeterministically choose method m M t largest subset S let S cid9 cid9 χ cid9 F S cid9 S π χ cid9 S F return π cid9 π YoyoF G M π π YoyoF G M π π FAILURE returnFAILURE m applicable t state S cid9 S π cid5 cid9 χ F cid9 δχ S cid9 cid9 remove S χi S j χ j F insert S S j χi F Fig 4 Pseudocode Yoyo Above G set goal states M set HTN methods In initial algorithm setbased policy π fringe set F S0 χ0 S 0 set initial states χ0 initial task network Fig 4 shows Yoyo planning procedure Yoyo takes nondeterministic HTN planning problem P Σ S 0 G χ0 M policy π form tuple F G M π F initial fringe set contains single pair set S0 initial states initial task network χ0 With input planning algorithm searches solution policy P To explain role F ﬁrst note Yoyo nondeterministic search space setbased policies The terminal states policy π analogous fringe nodes partial solution tree ANDOR search algorithm AO 11 sense Yoyo need solve states order ﬁnd solution planning problem But Yoyo solving state means HTN decomposition HTN state tasks need accomplished state Hence Yoyo needs reason pairs s χ s terminal state χ HTN s But pur poses eﬃciency Yoyo reason pair s χ separately Instead reasons equivalence classes states states equivalence class HTN Hence F collection pairs S1 χ1 Sk χk S repre sented Yoyo Binary Decision Diagram Section 5 compact explicit representation states set terminal states χi HTN states S Initially F contains member S0 χ0 In Lines 12 Yoyo checks pair S χ F set state s S goal state HTN χ HTN tasks left accomplish χ reach goal state In case Yoyo returns Failure current partial policy π weakly strongly strongcyclicly accomplish input HTN Then Line 3 Fig 4 Yoyo ﬁrst checks elements F cycles goal states pair S χ F Yoyo removes S state s appears π case action planned s G case action needs planned s If makes S Yoyo simply discards S χ needs In Lines 4 Yoyo checks pair S χ F set χ HTN case failure point HTN decomposition χ generate action s Thus Yoyo returns Failure case Next Line 6 Yoyo performs candidacy test π satisﬁes requirements candidate solution Intuitively test examines paths execution structure Σπ performing backward search terminal states π The details Yoyos candidacy test depends searching weak strong strong cyclic solutions discuss details Section 4 676 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 If π candidate solution Yoyo continues develop If F π solution Yoyo returns Otherwise Line 8 Yoyo selects pair S χ F note choice arbitrary selected eventually Recall χ HTN associated states S order select action perform S Yoyo consider applicable actions produced HTN decomposition In Line 9 Yoyo nondeterministically chooses task t predecessors HTN χ As SHOP2 NDSHOP2 ensures Yoyo decomposes accomplishes tasks order executed cid9 world If task t action Yoyo selects largest subset S Then Yoyo generates possible successors states S computing result applying t states This cid9 t Lines 1014 Then Yoyo generates resulting computation setbased statetransition function γ S cid9 t τ χ t s task network τ χ t s state S F set Finally Yoyo updates current policy adding pair S described previous section inserts pair γ S S t applicable state S cid9 t π cid9 cid9 cid9 cid9 If state s S action t applicable Yoyo immediately returns current preserving policy π The reason returning π enforce Yoyo select decompositions states S S candidate policy generated far nonempty subset S states S If task t instead nonprimitive task Yoyo nondeterministically chooses pair S cid9 m m M method t mequivalent In principle apply m t s S producing new task network χ cid9 δχ s m t insert s χ cid9 S s χ F But eﬃciency purposes Yoyo apply m state time instead applies m states S produce task network χ cid9 δχ s matter deﬁnition mS cid9 t Then Yoyo inserts S After Lines 821 happen pairs F task network For example pairs S χi S j χ j F χi χ j When happens eﬃcient combine pairs single pair S S j χi Yoyo Lines 22 23 cid9 m t state s cid9 χ F cid9 χ cid9 S S cid9 S cid9 cid9 cid9 cid9 Yoyo successively performs operations recursive invocations pairs left explore F At point algorithm returns π solution planning problem Σ S0 G χ0 M When recursive invocation returns Line 24 Yoyo checks returned value Failure failure cases described If Yoyo immediately returns Failure If π speciﬁes action state F Yoyo returns π Otherwise Yoyo ﬁrst inserts pair S χ selected removed F set previously cid9 cid9 χ S cid9 cid9 χ cid9 F replace S invocation updates pairs S state policy π deﬁned order remove states S π deﬁned Then planner calls recursively updated F current partial policy π order guarantee π eventually specify action state encountered search cid9 S π updates pair S S cid9 4 Weak strong strongcyclic planning Yoyo Fig 5 gives pseudocode candidacy test Line 6 Yoyo Intuitively test called IsCandidate examines paths execution structure Σπ searching backward π s terminal states initial states The deﬁnition Preimage GoodPolicy subroutines depend want ﬁnd weak strong strongcyclic solutions We discuss cases In weak planning candidate solution path initial state live terminal state The backward search starts terminal states π states G S F S F set states Yoyos F set The Preimage computation WeakPreimage operation deﬁned 2 WeakPreimageS cid2 cid3 s γ s S cid5 At ith iteration loop result successive WeakPreimage computations set S contains states policy π goal states states F reachable steps The search stops new states added S state π terminal state π reachable visited backward search At point function GoodPolicy cases consider Suppose S 0 contains state s S This means follow actions π starting initial states S 0 end state impossible reach goal state Therefore π candidate solution extended solution planning Thus GoodPolicy returns False Otherwise π candidate solution GoodPolicy returns True In strong planning π candidate solution execution path acyclic end live terminal state In case IsCandidates Preimage computation corresponds StrongPreimage operation deﬁned 2 StrongPreimageS cid2 cid3 s γ s S γ s cid5 At iteration loop removes stateaction pairs π veriﬁed StrongPreimage goal terminal states The GoodPolicy subroutine implements checks backward search stops The ﬁrst check described weak planning The second involves checking state action pair left policy If check succeeds means policy induces cycle execution structure extended strong solution input planning problem In case IsCandidate returns False Otherwise returns True U Kuter et al Artiﬁcial Intelligence 173 2009 669695 677 Procedure IsCandidate π S F G S 0 1 S 2 S 3 4 5 6 7 endprocedure cid9 S G S F cid9 cid5 S cid9 S S π cid9 π PreimageS S S states π cid9 π s π s S returnGoodPolicy π S 0 S Function GoodPolicy π S 0 S weak planning 1 2 endfunction If S 0 cid5 S return FALSE return TRUE Function GoodPolicy π S 0 S strong strongcyclic planning 1 2 endfunction If S 0 cid5 S π cid5 return FALSE return TRUE Fig 5 Pseudocode generic IsCandidate test Above S F set states F set current invocation Yoyo Fig 6 An illustration BDD representation propositional formula p1 p2 p3 The solid arrows represent case proposition pi True dotted arrows represents case pi False Finally strongcyclic case requirement π candidate solution state π execution path execution structure Σ π ends live terminal state In order verify requirement IsCandidate simply uses WeakPreimage computation weakplanning case order remove π states execution path reaches live terminal state GoodPolicy subroutine strong planning case order check π state execution path live terminal state This combination suﬃcient differentiate fair unfair executions π 5 Yoyos BBDbased implementation Binary Decision Diagrams BDDs 4 probably bestknown data structures encode propositional formulae compactly represent ﬁnite state automata case nondeterministic planning domains A BDD directed acyclic graph structure represents propositional logical formula canonical form Each proposition formula corresponds node BDD exactly outgoing edges edges represents case proposition true represents case false There terminal nodes BDD nodes represent logical truth values true false As example Fig 6 shows illustration BDD representation following propositional formula p1 p2 p3 pi proposition solid dotted edges outgoing pi represent cases pi true false respectively The truth value logical formula evaluated traversing BDD representation The traversal starts root node node incoming edges ﬁrst evaluates proposition represented node follows edge corresponds result evaluation determine proposition This traversal continues reaches terminal node speciﬁes truth value logical formula 678 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 Fig 7 An illustration Yoyo applies method task chaseprey set states Chart shows set current states abstract deﬁnition methods chaseprey Charts b c shows current states method applicable applicable respectively As example suppose state world p1 False p2 p3 True formula False The evaluation formula fact BDD Fig 6 follows We start p1 node Since p1 False follow dotted arrow node coming p3 node Since p3 True follow solid arrow p3 end False node Note correct p3 False entire formula False The example demonstrates BDDs combined compute negation conjunction disjunction propositional formulas Two BDDs combined taking union directed acyclic graph structure performing bookkeeping operations edges nodes combined BDD order achieve desired negation conjunction disjunction The combination BDDs b1 b2 performed quadratic time O b1 b2 bi size bi 4 Like MBP Yoyo uses BDDs compactly represent sets states sets transitions states This requires kinds symbols deﬁned propositional symbols state world propositional symbol action given planning domain A set S states represented BDD encodes logical formula state propositions true states S A set S1 S2 states represented BDD combines BDDs S1 S2 respectively order represent disjunction logical formulae correspond BDDs Similarly S 1 S2 represented BDD encodes conjunction logical formulae cid9 s A state transition s s cid9 γ s action encoded logical formula BDD conjunction subformulas formula state propositions hold state s proposition Similarly state transitions represents action formula state propositions hold state s setbased statetransition function γ S encoded BDD combination BDDs S D D BDD encodes possible state transition given planning domain cid9 Suppose particular iteration Yoyo selects S χ F set S set states encoded BDD χ HTN accomplished states S Let t task χ predecessors If t primitive task action Yoyo ﬁrst generates BDD represents conjunction preconditions t formula represents set S states Then Yoyo combines BDD applicability conditions t represents S combination BDDs represent conjunction logical formulae represent states t applied order generate BDD represents The combined BDD represents set S set possible successor states If t primitive task Yoyo ﬁrst nondeterministically chooses method m applicable t state s S To choice Yoyo ﬁrst generates BDD represents conditions held world m cid9 S Line 16 Fig 4 reduced combining BDD applied t Then computation subset S applicability conditions m represents S combination BDDs represent conjunction logical formulae represent cid9 Fig 7 shows illustration Yoyo uses BDDs apply method m task t given set S states In particular use method example Section 22 method north_chase task chase_prey applicability conditions hunter xy location prey caught prey north subtasks 1 move_north 2 chase_prey constraints subtask 1 subtask 2 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 679 Suppose set S states contains states shown Fig 7 hunter rightmost corner 3 3 grid The current task chaseprey Given hunter 2 0 location Line 16 Yoyo performed follows Yoyo nondeterministically selects method generates BDD represents following logical formula methods applicability conditions hunter_loc_x 2 hunter_loc_ y 0 preycaught cid7 0cid2icid22 1cid2 jcid22 prey_loc_x prey_loc_ y j Then Yoyo combines BDD formula represents set S states combined BDD represents conjunction BDDs order compute subset S S method m applicable t state s S In example states shown Fig 7b If paths combined BDD end true node means method applicable S Otherwise paths combined BDD end true node represent subset S method applicable cid9 cid9 Finally Yoyo computes BDD represents set difference S S method applied t states shown Fig 7c The set S S f f logical formulas represent sets S S f f cid9 cid9 cid9 cid9 denotes states S states correspond logical formula cid9 respectively The setbased operations Yoyo performed similar manner 6 Formal properties This section presents theorems showing soundness completeness Yoyo The proofs theorems given Appendix A Theorem 1 Yoyoalways terminates The soundness completeness Yoyo depends soundness completeness IsCandidate function Yoyo decides policy candidate solution based function eliminates policy function returns False Theorem 2 Let P Σ S0 G χ0 M nondeterministic HTN planning problem Let π setbased policy let T π set terminal states π If π candidate solution P IsCandidate π T π G S0 returns True Otherwise IsCandidate π T π G S0 returns False Theorem 3 Suppose P Σ S G χ M nondeterministic HTN planning problem 1 If YoyoF 0 G M π0 F 0 S χ π0 returns policy π P π weakly strongly strongcyclicly accomplishes χ S methods M 2 If solution policy P accomplishes χ S given M Yoyoreturns Failure The following theorem establishes soundness Yoyo planning procedure Theorem 4 Suppose Yoyoreturns policy π nondeterministic HTN planning problem P Σ S 0 G χ M Then π solution P Theorem 5 Suppose P Σ S G χ M solvable nondeterministic HTN planning problem Then Yoyo returns policy π P weakly strongly strongcyclicly solves P The theorem establishes completeness Yoyo nondeterministic choice point Yoyo algorithm Line 16 Fig 4 allow planner consider decomposition χ generate solution given methods M 7 Experimental evaluation The current implementation Yoyo built NDSHOP2 MBP planning systems The core planner implemented Common Lisp like NDSHOP2 However Yoyo includes CC components BDD based functionality represent manipulate sets states sets statetransitions policies Yoyo use planning algorithms implemented MBP implements bridge Common Lisp MBPs implementation accessing MBPs BDD manipulation machinery planning 680 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 Fig 8 Average running times seconds Yoyo NDSHOP2 MBP hunterprey domain function grid size prey We evaluated Yoyos performance planning domains HunterPrey domain mentioned Section 1 Robot Navigation domain 2 testbeds MBP Nondeterministic Blocks World domain 3 testbed NDSHOP2 The subsequent sections present discuss results experiments domains 71 Comparisons planners time performance 711 HunterPrey In HunterPrey domain world n n grid planner hunter trying catch prey The world fullyobservable sense hunter observe location prey The hunter ﬁve possible actions north south east west catch applicable hunter prey location The prey ﬁve actions movement actions plus staystill actionbut instead representing prey separate agent possible actions encoded nondeterministic outcomes hunters actions The hunter moves ﬁrst prey moves domain All experiments domain run AMD Duron 900 MHz laptop 256 MB memory running Linux Fedora Core 2 For NDSHOP2 Yoyo Allegro Common Lisp v62 Free Trial Edition experiments The time limit 40 minutes7 Experimental Set 1 ing grid sizes prey nondeterminism world kept minimum hunter In experiments compared Yoyo NDSHOP2 MBP hunterprey problems increas Fig 8 shows results experiments grid sizes n 5 6 13 For value n MBP NDSHOP2 Yoyo run 20 randomlygenerated problems This ﬁgure reports average running times required planners problems Each time NDSHOP2 MBP memory overﬂow solve problem time limit ran problem size Each data point ﬁve failures omitted ﬁgure data points happened 1 5 times included Thus data shown Fig 8 performance NDSHOP2 MBP look better wasbut makes little difference performed worse Yoyo For grids larger n 10 NDSHOP2 able solve planning problems memory overﬂows This NDSHOP2 reason sets states reason state explicitly However domain reasoning clusters states possible effective example grid position hunter prey north hunter hunter need northie hunter north action states Representing states cluster planning clusters main difference performances Yoyo NDSHOP2 domain 7 As 12 CPU times MBPs includes preprocessing search times Omitting preprocessing times signiﬁcantly affected results seconds usually second U Kuter et al Artiﬁcial Intelligence 173 2009 669695 681 Fig 9 Average running times seconds Yoyo MBP larger grid sizes hunterprey domain prey Note domain admits highlevel search strategies look prey Although strategy helps planner prune portion search space pruning compensate explosion size explicit representations search space problems On hand Yoyo MBP able solve problems experiments The difference performances Yoyo NDSHOP2 demonstrates impact use BDDbased representations clusters states state transitions mentioned Yoyo HTNbased pruning heuristic NDSHOP2 able scale good MBP able exploit BDDbased representations problems solutions In order Yoyo performs larger problems compared MBP experimented Yoyo MBP larger grids Fig 9 shows results experiments setup varied size grids planning problems n 5 10 15 45 50 These results Fig 9 grid size grows Yoyos running time increases slowly MBPs This happens following reasons 1 Even Yoyo forward search HTNbased searchcontrol mechanism provides ability analogous MBPs backward search HTNs good job eliminating actions arent relevant achieving goal 2 Yoyos forward search enables consider states reachable initial states planning problems In contrast MBPs backwardchaining algorithms explore states reachable initial states problems 3 Yoyos use BDDs enables compress state space like MBP The main difference MBP BDDs arise naturally backward searchs subgoal chaining Yoyos forward search necessary explicitly look sets states equivalent sense actions applicable formulate BDDs represent sets In order investigate effect BDDbased representations Yoyo variation Experimental Set 2 HunterPrey domain prey prey location neighbourhood prey 1 world In setting nondeterminism hunter increases combinatorially number prey domain Furthermore BDDbased representations underlying planning domain explode size assumptions movements prey dependent In adapted domain provided NDSHOP2 Yoyo searchcontrol strategy tells planners chase ﬁrst prey caught second prey prey caught Note searchcontrol strategy allows abstracting away huge state space hunter chasing prey need know locations prey need reason store information locations We varied number prey p 2 p 6 4 4 grid world compared running times MBP NDSHOP2 Yoyo Fig 10 shows results Each data point average running times planners 20 randomlygenerated problems experiment different number prey As time NDSHOP2 MBP memory overﬂow solve problem time limit ran problem size Each data point ﬁve failures omitted ﬁgure data points happened 1 5 times included The results Fig 10 demonstrate power combining HTNbased searchcontrol strategies BDDbased repre sentations states policies planning problems Yoyo able outperform NDSHOP2 MBP The running times required MBP grow exponentially faster required Yoyo increasing size prey 682 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 Fig 10 Average running times seconds NDSHOP2 Yoyo MBP problems HunterPrey domain function number prey 4 4 grid MBP able solve planning problems 5 6 prey 40 minutes Table 1 Average running times seconds MBP NDSHOP2 Yoyo HunterPrey problems increasing number prey increasing grid size Grid 3 3 4 4 5 5 6 6 Grid 3 3 4 4 5 5 6 6 Grid 3 3 4 4 5 5 6 6 Grid 3 3 4 4 5 5 6 6 Grid 3 3 4 4 5 5 6 6 2 prey MBP 0343 0388 1387 3172 3 prey MBP 11 11534 133185 368166 4 prey MBP 29554 492334 40 mins 40 mins 5 prey MBP 233028 40 mins 40 mins 40 mins 6 prey MBP 2158339 40 mins 40 mins 40 mins NDSHOP2 078 3847 18682 76306 NDSHOP2 172 12302 5875 250315 NDSHOP2 3256 31591 17649 547911 NDSHOP2 5483 56714 30403 memoryoverﬂow NDSHOP2 8346 73435 486112 memoryoverﬂow Yoyo 0142 0278 0441 0551 Yoyo 0329 0521 092 1404 Yoyo 0448 0759 1818 3295 Yoyo 0655 1275 3028 7059 Yoyo 0781 1786 5221 11826 MBP exploit HTNbased pruning heuristics Note NDSHOP2 performs better MBP experiments Experimental Set 3 Our ﬁnal set experiments HunterPrey domain designed investigate Yoyos performance compared NDSHOP2 MBP problems multiple prey increasing grid sizes In experiments number prey varied p 2 p 6 grid sizes varied n 3 n 6 Table 1 reports average running times required Yoyo MBP NDSHOP2 experiments Each data point average running times planners 20 randomlygenerated problems experiment different p n combinations These results provide proof conclusions previous experiments Search control strategies helped Yoyo NDSHOP2 outperformed MBP increasing number prey However increasing grid sizes NDSHOP2 ran memory problems explicit representations states U Kuter et al Artiﬁcial Intelligence 173 2009 669695 683 Fig 11 Average running times seconds NDSHOP2 Yoyo MBP problems Robot Navigation domain function number packages doors domain kid doors k 0 Fig 12 Average running times seconds NDSHOP2 Yoyo MBP problems Robot Navigation domain function number packages doors domain kid doors k 7 solutions problems Yoyo hand able cope increasing grid sizes number prey problems 712 Robot Navigation The Robot Navigation domain standard benchmark experimental evaluation MBP 212 13 This domain variant similar domain described 14 It consists building 8 rooms connected 7 doors In building robot number packages rooms The robot responsible delivering packages initial locations ﬁnal locations opening closing doors moving rooms picking putting packages The robot hold package time The domains source nondeterminism kid close open doors designated kiddoor We compared Yoyo NDSHOP2 MBP set experimental parameters 12 number packages n ranged 1 5 number kiddoors k ranged 0 7 For combination n k generated 20 random problems ran planners problems averaged CPU time planner8 All experiments domain run MacBook laptop 216 GHz Intel Core Duo processor running Fedora Core 6 Linux virtual machine 256 MB memory For NDSHOP2 Yoyo Allegro Common Lisp v80 Enterprise Edition experiments The time limit 1 hour Figs 11 12 experimental results varying number objects n 1 5 kiddoors k 0 doors kiddoors k 7 respectively In experiments NDSHOP2 Yoyo able outperform MBP Here reasons experimental results NDSHOP2 vs Yoyo In NDSHOP2 Yoyo HTNbased searchcontrol strategy tells planners select package load deliver destination ignoring packages Once package delivered select deliver continue process packages delivered This strategy induces substrategy HTNs search control encoded HTNs robot needs consider status door door robot robot needs order pick deliver currentlyselected package ignoring status 8 As 12 CPU times MBPs includes preprocessing search times Omitting preprocessing times signiﬁcantly affected results seconds usually second 684 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 doors case NDSHOP2 generates stateaction pairs state actually represents set states atoms designated dont care dont care door robot This compresses state representations search space manner similar BDD experiments NDSHOP2s performance similar Yoyos In fact NDSHOP2s performance slightly better Yoyo experiments NDSHOP2 overhead incurred Yoyos BBDbased manipulation functionality MBP vs NDSHOP2 Yoyo Unlike NDSHOP2 Yoyo MBP able exploit HTNbased searchcontrol strategies mentioned needed search larger search space Furthermore backward breadth ﬁrst search considered states reachable initial states experimental problems This hurt MBP performance signiﬁcantly despite use BDDs 713 Nondeterministic Blocks World The nondeterministic Blocks World domain contains state space set actions original Blocks World domain action version intended outcome outcome classical case drop block table case gripper slippery We compared Yoyo NDSHOP2 MBP following experimental setup We varied number blocks world b 3 10 For world b blocks randomly generated 20 planning problems ran planners problems measured average CPU times planners We experimental setup previous section In particular ran experiments MacBook laptop 216 GHz Intel Core Duo processor running Fedora Core 6 Linux virtual machine 256 MB memory For NDSHOP2 Yoyo Allegro Common Lisp v80 Enterprise Edition experiments The time limit 1 hour Fig 13 shows results experiments As NDSHOP2 Yoyo able outperform MBP The reason NDSHOP2 Yoyos outperforming results nondeterministic Blocks World HTN strategy planners says gripper drops block table pick immediately This strategy enabled NDSHOP2 Yoyo generate polynomialsized solutions MBP generated exponentialsized solutions use HTNbased strategies As BDDbased representations MBPs backward search algorithms help domain solution policies generally require different actions different states action large set states For example unstack block tower depend goal position block underneath moved goal position MBPs backward search algorithms use knowledge guide search NDSHOP2 Yoyos HTNs hand easily encode knowledge search control In Fig 13 diﬃcult compare Yoyos NDSHOP2s CPU times appear coincident x axis To comparison easier Fig 14 gives semilogarithmic plot data This ﬁgure shows planners running polynomial time domain curveﬁtting shows running times planners Θn5 n number blocks The reason NDSHOP2 runs faster twofold First Yoyos BDD manip ulation operations require substantial overhead Second blocks world BDD operations provide signiﬁcant compression search space On hand HTNs Yoyo NDSHOP2 worked planners performed better MBP Fig 13 Average running times seconds NDSHOP2 Yoyo MBP problems nondeterministic Blocks World function number blocks U Kuter et al Artiﬁcial Intelligence 173 2009 669695 685 Fig 14 A semilog plot data Fig 13 Fig 15 Average solution sizes Yoyo MBP HunterPrey problems prey varying grid size 72 Comparisons sizes planners solutions To best knowledge good measure solution quality devised nondeterministic planning problems One like measure like solutions averagecase worstcase execution length possible A solutions averagecase execution length undeﬁned probabilities actions outcomes If solution contains cycle inﬁnitely fair executions ﬁnite bound length Lacking better measure plan quality measured sizes solution policies produced planners As measure size number terms policy representations produced planners In NDSHOP2 sum stateaction pairs policy number atoms state plus additional term speciﬁes action In Yoyo MBP number propositions BDD representation policy dont need count actions separately theyre represented propositions BDD Fig 15 shows sizes solutions generated Yoyo MBP HunterPrey problems prey varying grid size NDSHOP2 appear ﬁgure reason didnt appear Fig 9 unable handle grid sizes big These results MBPs solutions smaller size produced Yoyo The reason MBP option boolean simpliﬁcation BDDs generates option experiments9 Yoyo based MBPs BDD implementations use boolean simpliﬁcation mechanisms10 Fig 16 shows sizes solutions generated planners HunterPrey problems varying number prey ﬁxed 4 4 grid Even boolean simpliﬁcation MBPs solutions large The reason MBP needed specify locations prey explicitly preys movements depended recall prey location prey Yoyos solutions smaller HTNs enabled generate policies focus prey time ignoring Similarly Robot Navigation nondeterministic Blocks World domains Yoyo generated smaller solution policies MBP NDSHOP2 shown Figs 17 18 9 We tried running MBP booleansimpliﬁcation option turned In case MBPs solutions 1 2 orders magnitude larger boolean simpliﬁcation 5 6 times larger solutions generated Yoyo 10 To use MBPs builtin boolean simpliﬁcation mechanisms purpose required tight integration Yoyo MBP hard Yoyo use HTNs way current design 686 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 Fig 16 Average solution sizes NDSHOP2 Yoyo MBP HunterPrey problems varying numbers prey 4 4 grid Fig 17 Average solution sizes NDSHOP2 Yoyo MBP problems Robot Navigation domain function number objects doors domain kid doors k 7 Fig 18 Average solution sizes NDSHOP2 Yoyo MBP problems nondeterministic Blocks World domain function number blocks 8 Related work Probably ﬁrst work similar vein described 15 breadthﬁrst search algorithm ANDOR tree generate conditional plans interleave planning execution nondeterministic domains Other early attempts extend classical planning nondeterministic domains include Cassandra planning 16 CNLP 17 Plinth 18 UCPOP 19 Mahinur 20 These algorithms perform mod ern planners MBP NDSHOP2 Furthermore conditional planning techniques usually generate solutions form directed acyclic graphs address problem inﬁnite paths generating trialanderror strategies QBFPlan generalization SATPlan 21 introduced 22 QBFPlan translates nondeterministic planning prob lem satisﬁability problem Quantiﬁed Boolean Formulas QBFs The QBF problem fed eﬃcient QBF solver described 23 QBFPlan generates conditional plans bounded length parameter speciﬁed input If solution current length algorithm extends bound starts As satisﬁability based predecessors QBFPlan scale large planning problems One earliest attempts use modelchecking techniques planning nondeterminism ﬁrst introduced 14 SimPlan planning described 14 developed generating plans reactive environment plans specify possible reactions world respect actions plan Note reactions modeled nondeterministic outcomes actions SimPlan models interactions environment execution plan statetransition speciﬁes possible evolutions environment U Kuter et al Artiﬁcial Intelligence 173 2009 669695 687 interactions Goals possible evolutions environment speciﬁed Linear Temporal Logics LTL classical TLPlan algorithm 24 fact takes roots SimPlan The SimPlan planner based model checking techniques work explicit representations states state space planner represents reasons explicitly state visited search Symbolic model checking techniques Binary Decision Diagrams BDDs planning nondeterministic domains assumptions fullyobservability classical reachability goals ﬁrst introduced 2526 BDDs enable planner represent class states share common properties planning transformations BDDbased representations states In cases approach provide exponential reduction size representations planning problems exponential reduction times required problems demonstrated paper previous works 213 The planning algorithms developed approach aim generate solutions nondeterministic planning domains classiﬁed weak execution trace reach goal strong execution traces reach goals strongcyclic fair execution traces reach goals 79 2 gives formal account extensive experimental evaluation planning kinds solutions Planning model checking extended deal partial observability 2728 In works belief states deﬁned sets states represent common observations compactly implemented BDDs Planning performing heuristic search ANDOR graph represents beliefstate space It demonstrated 28 approach outperformed planning algorithms developed nondeterministic domains partial observability GPT 29 BBSP 30 Planning temporally extended goals nondeterministic planning domains investigated works including 12132831 The MBP planner 1 benchmark experimental evaluations described paper capable handling complex goals partial observability Other planning algorithms based model checking techniques include UMOP planner described 32 34 symbolic modelchecking based planning framework novel algorithm strong strongcyclic planning performs heuristic search based BDDs nondeterministic domains 34 Heuristic search provides performance improvement unguided BDDbased planning techniques toy examples demonstrated 34 authors discuss approach scale realworld planning problems Planning based Markov Decision Processes MDPs 35 aims solve planning problems actions possible outcome approach models outcomes probabilities utility functions formulates planning problems optimization problems In MDPs policy usually total function states actions modelchecking approaches allow policy partial In problems solved MDPs model checkingbased planners empirically shown eﬃcient 29 Finally approaches developed planning nondeterminism focusing condi tional conformant planning These approaches extended classical planning techniques based planning graphs 36 satisﬁability 21 Satisﬁability based approaches ones described 3739 limited confor mant planning planner nondeterministic actions observability The planninggraph based techniques 4045 address conformant planning limited form partial observability In 3 authors present generalization technique transport eﬃciency improvements achieved forwardchaining planning deterministic domains nondeterministic case Under certain conditions showed nondeterminized algorithms time complexity polynomially bounded time complexity classical deterministic version NDSHOP2 HTN planner developed technique SHOP2 5 Yoyo HTN planner described work built NDSHOP2 MBP 9 Conclusions We described Yoyo planning algorithm combines NDSHOP2s HTNbased searchcontrol MBPs BDDbased symbolic modelchecking techniques We presented theoretical results Yoyos soundness completeness termination properties compared experimentally NDSHOP2 MBP In experiments Yoyo ran faster NDSHOP2 MBP usually ran faster It possible develop variants Yoyo use temporallogic control formulas TLPlan 24 TALplanner 46 HTN decomposition Appendix B discusses brief summary Consider searchcontrol works TLPlan In state s TLPlan computes actions applicable s γ s satisﬁes logical formula Progresss f f searchconstraint formula 24 Given set S states variant Yoyo TLPlans searchcontrol formulas split set S generating action 1 applicable states S 2 successor states satisfy formula Progresss f This require formula f disjunction smaller controlrule formulas disjunct addresses possible outcome action possible outcomes group actions In near future interested extending Yoyo work sets HTN methods incomplete sense solve planning problem An analogous approach recently developed classical planning Duet planner 47 combines SHOP2 HTN planner 5 LPG domainindependent planner 48 Experimental studies shown small HTNplanning 688 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 knowledgemuch SHOP2 need work effectively itselfcan enable Duet solve planning problems easily LPG great diﬃculty solving We believe similar kind approach combination Yoyo MBP work nondeterministic planning domains Acknowledgements This work supported DARPAs Transfer Learning Integrated Learning programs NSF grant IIS0412812 AFOSR grants FA95500510298 FA95500610405 FIRBMIUR project RBNE0195k5 Knowledge Level Automated Software Engineering The opinions paper authors necessarily reﬂect opinions funders Appendix A Proofs theorems This appendix presents theorems stated Section 6 proofs theorems Theorem 1 Yoyoalways terminates Proof The possible situation Yoyo terminate F set However happen state spaces planning problems ﬁnite beginning invocation Yoyo removes states visited states F set Therefore Yoyo visits state caught inﬁnite search traces planning Thus theorem follows cid2 The soundness completeness Yoyo depends soundness completeness IsCandidate function Yoyo decides policy candidate solution based function eliminates policy function returns False Theorem 2 Let P Σ S0 G χ0 M nondeterministic HTN planning problem Let π setbased policy let T π set terminal states π If π candidate solution P IsCandidate π T π G S0 returns True Otherwise IsCandidate π T π G S0 returns False Proof Note IsCandidate test shown Fig 5 involve checking HTN accomplishment test designed verifying candidate policy π satisﬁes requirements weak strong strongcyclic solution policy according deﬁnitions Section 2 Note IsCandidate test terminates traverses backwards states policy π π ﬁnite deﬁnition The proof theorem parts proof contradiction Weak planning Suppose π input setbased policy IsCandidate test weak planning The algorithm performs backward search successive WeakPreimage computations generates possible paths execution structure Σ π end terminal state At end traversal IsCandidate computes set S states state s S path reaches terminal state execution structure Σ π If initial state s0 S0 S means execution starting s0 ending terminal state Σ π In case IsCandidate returns False Otherwise returns True Note execution ends terminal state Σ π initial state s0 means policy π candidate weak solution planning problem P To IsCandidate return false positives false negatives suppose π candidate weak solution P By deﬁnition candidate weak solutions π speciﬁes execution paths initial state s0 S0 ends terminal state T π Assume invocation IsCandidate π St π G S0 returns False The case IsCandidate returns False traverses paths execution structure Σ π detects exists initial state s0 S0 s0 visited backward search However assumed π candidate weak solution contradiction deﬁnition candidate weak solutions Now suppose π candidate weak solution IsCandidate π St π G S0 function returns True IsCandidate returns True initial state s0 S0 exists path execution structure Σ π starts s0 ends goal nongoal terminal state However π candidate solution initial state hold contradiction Thus theorem follows weak planning Strong planning The IsCandidate computation strong planning similar weak planning generates execution paths execution structure Σπ induced π backward search terminal states U Kuter et al Artiﬁcial Intelligence 173 2009 669695 689 Σ π initial states S0 The difference IsCandidate computations strong planning weak planning case IsCandidate backward search performing successive StrongPreimage operations cid9 During backward search IsCandidate removes stateaction pairs visits policy π At end π ancestor s Thus cyclic path execution structure Σ π IsCandidate returns False search stateaction pair s left π means state s successor state s s correct deﬁnition strong solutions planning problems At end backward traversal IsCandidate generates set S states π state s S path reaches terminal state execution structure Σ π As case weak planning exists initial state s0 S0 s0 S IsCandidate returns False cid9 If checks hold IsCandidate returns True This correct checks fail input policy π deﬁnition π candidate strong solution To IsCandidate return false positives false negatives suppose π candidate strong solution P Assume invocation IsCandidate π St π G S0 returns False This means cases mentioned false given input policy π initial states S0 However deﬁnition candidate strong solution happen contradiction Now suppose π candidate strong solution IsCandidateπ St π G S0 function returns True If IsCandidate returns True checks satisﬁed π However π candidate solution contradiction Therefore theorem follows strong planning Strongcyclic planning The proof case strongplanning case IsCandidate function returns False cyclic paths possibility reach goals cid2 Theorem 3 Suppose P Σ S G χ M nondeterministic HTN planning problem 1 If YoyoF 0 G M π0 F 0 S χ π0 returns policy π P π weakly strongly strongcyclicly accomplishes χ S methods M 2 If solution policy P accomplishes χ S given M Yoyoreturns Failure Proof Let π setbased version policy π Before going proof remark time Yoyo generates pair S t ﬁrst updates partial policy input current invocation passes updated policy invocation equivalent pair S t update partial policy returned recursive invocation return updated policy11 Thus following establish proof view Yoyos updates mind Case 1 The proof case parts First suppose YoyoF 0 G M π0 returns policy Then deﬁnition Yoyo planning algorithm S G χ HTN The proof immediate correctness checks Lines 16 pseudocode Fig 4 sure initial state S goal state task network χ HTN Yoyo returns policy Line 7 Now suppose YoyoF 0 G M π0 returns nonempty policy The proof induction n number invocations required Yoyo order return π Base Case n 1 In case invocation YoyoF 0 G M π0 returns policy π This means initial state P actually goal state Then Yoyo return Failure point Line 2 χ HTN Thus Yoyo remove initial pair S χ F 0 Line 3 leaving F π π0 So return π Line 7 accomplishes HTN χ according HTN accomplishment deﬁnition Section 22 Induction step Let n 1 suppose theorem true k n Let π cid9 current policy let S χ pair Yoyo selected F invocation We possibilities One possibility Yoyo updates F set Line 13 goes iteration In case current task S t t χ primitive Yoyo updates F set γ S applicable recursively invokes Suppose recursive invocation returns policy π cid9cid9 state s appear pair fringe F input returned invocation state action pair s π cid9cid9 π cid9cid9 π cid9 S t accomplishes τ χ s t γ S t methods M Thus partial policy π cid9cid9 S t accomplishes current HTN χ action Then induction hypothesis know cid9 t τ χ s t largest subset S There cases Otherwise Yoyo calls recursively updated fringe F Line 27 states Then policy π removed pairs F Suppose recursive invocation returns policy π cid9cid9cid9 cid9 11 The reason Yoyo ﬁrst updates partial policy makes recursive invocation able check candidacy policy 690 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 know π cid9cid9cid9 π cid9cid9 S t accomplishes χ S S cid9 π cid9cid9cid9 π cid9 S t accomplishes τ χ s t γ S cid9 t methods M The possibility Yoyo updates F set Line 18 goes iteration In case current cid9 χ m M subset S applicabilityconditions m satisﬁed accomplishes task t primitive Yoyo updated F set pairs S method applicable t S states S δχ s m t S By induction hypothesis YoyoF G M π cid9 returns policy π cid9cid9 cid9 methods M cid9 δχ s m t S S χ S S π cid9cid9 cid9 cid9 cid9 Therefore Case 1 theorem follows Case 2 We deﬁne decomposition trace χ sequence primitive nonprimitive task decompositions necessary HTN planner generate π Here decomposition primitive task application task state planning process The proof contradiction Suppose solution policy π planning problem P accomplishes input HTN χ initial states S methods M First note π solution policy partial policy successive invocations Yoyo candidate policy Yoyo return Failure Line 6 Theorem 2 We Yoyo returns failure solution policy P accomplishes χ S given M Suppose Yoyo returns Failure This means nondeterministic trace invocation Yoyo returns Failure There cases Yoyo return Failure There pair S χ F state S goal state χ HTN This means χ accomplished S policy π specify action state S After Yoyo removes goal states states F pair S χ left F χ HTN However policy π specify action state s π solution P Thus π accomplish HTN χ deﬁnition accomplishing HTN given Section 22 Yoyo selected task t accomplish set states S t nonprimitive task In case Yoyo return Failure method m M applicable t S This means 1 method M t 2 applicabilityconditions methods M t satisﬁed states S 3 set methods t applicability conditions method describes subset S union subsets equal S Thus χ accomplished S deﬁnition accomplishing HTN A recursive invocation Yoyo returned Failure Line 26 This happen Yoyo returns Failure cases If policy π accomplishes input HTN χ means nondeterministic trace Yoyo cases happen Yoyo considers possible ways decomposing task planning given HTN χ set M methods Note nondeterministic trace include recursive invocations Yoyo Lines 25 29 Therefore Yoyo returns Failure nondeterministic trace given HTN methods M solution policy π accomplishes initial HTN χ initial states S given set HTN methods M cid2 The following theorem establishes soundness Yoyo planning procedure Theorem 4 Suppose Yoyoreturns policy π nondeterministic HTN planning problem P Σ S 0 G χ M Then π solution P Proof Let π setbased version π suppose nondeterministic traces Yoyo returns π P The proof induction n number invocations Yoyo given P initial HTN χ0 set methods M Base Case n 1 In case Yoyo perform recursive invocation return Lines 2 5 6 pseudocode shown Fig 4 return Failure Thus F π This means initial state P goal state initial pair S0 χ0 removed F Line 3 So deﬁnition solution nondeterministic planning problem π solution P Induction step Let n 1 suppose theorem true k n By Theorem 2 know partial policy previous invocation candidate solution IsCandidate tests fail Yoyo return Failure Then possibilities Let π cid9 current policy invocation One possibility Yoyo updates F set Line 13 goes invocation In case current task t cid9 t largest subset S t applicable This means Yoyo updated π cid9 cid9 t τ χ s t state s S cid9 primitive Suppose S F set γ S S cid9 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 691 The possibility Yoyo updates F set Line 18 goes iteration In case current cid9 χ m M task t primitive Yoyo updated F set pairs S method applicable t S cid9 δχ s m t S S cid9 subset S states S t mequivalent cid9 Suppose Yoyo generated policy π recursive invocation Line 25 For HTN χ appears F set let P χ Σ Sχ Gχ nondeterministic planning problem Σ current planning domain cid6 Sχ S S π Sχ F Gχ G S π In recall S π set states setbased policy π From induction hypothesis know policy πχ generated Yoyo nondeterministic planning problem P χ solution P χ That P χ nondeterministic trace Yoyo returns policy πχ πχ π π cid9 Yoyo return π P By construction S S π set pair S χ F policy π deﬁned states S S π Yoyo plan states order generate solution In Lines 2627 planner updates fringe set F follows S χ F S S π cid5 Yoyo replaces pair S χ S S π χ For HTN χ appears updated F set let P cid9cid9 χ Σ Sχ Gχ nondeterministic planning problem Σ current planning domain cid6 cid9cid9 χ S cid9cid9 S π S Scid9cid9χ F G cid9cid9 χ G S π And suppose Yoyo recursively called planning problems Line 29 returned policy π cid9cid9 By cid9cid9 χ χ Since current partial policy π candidate solution π cid9cid9 π solution union solution original input χ generated Yoyo nondeterministic planning problem P χ planning problems set terminal states π π cid9cid9 reasoning know policy π cid9cid9 solution P π cid9cid9 planning problem P cid2 cid9cid9 Finally following theorem establishes completeness Yoyo Theorem 5 Suppose P Σ S G χ0 M solvable nondeterministic HTN planning problem Then Yoyoreturns policy π P weakly strongly strongcyclicly solves P Proof Let π solution P We use π denote setbased version π rest proof Then deﬁnition π accomplishes HTN χ0 T C given set M methods We deﬁne decomposition graph π The decomposition graph π directed graph Rπ N E Each node N tuple S χ S cid9 χ cid9 Based set states χ HTN Each edge E describes decomposition node S χ S deﬁnition HTN accomplishment given earlier decomposition graph Rπ following properties 1 If χ0 HTN T Rπ single node S χ0 S G E set We node S χ0 leaf node Rπ S χ0 outgoing edges 2 There primitive task action t predecessors T Let S applicable Then edge node S χ0 node γ S γ S cid9 t τ χ0 S t labeled action t γ S cid9 largest subset S t cid9 t τ χ0 S t The edge S χ0 cid9 t τ χ0 S t child S χ0 Rπ 3 There nonprimitive task t predecessors T method m M applicable t largest subset S m applicable t Then edge cid9 m t child S χ Rπ The cid9 δχ S cid9 m t S cid9 δχ S cid9 states S Let S node S χ node S cid9 δχ S edge S cid9 m t S χ labeled pair t m Let Rπ decomposition graph π given Yoyo Since primitive tasks actions produce new states cid9 S follows candidate solution π consists set S t applicable 3 action t label outgoing edge S χ path π accomplish χ contradiction cid9 t pairs 1 S χ node Rπ 2 S The proof theorem follows Suppose decomposition graph Rπ contains single leaf node S χ χ HTN This means S G π Indeed initial iteration failure conditions Lines 1 4 692 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 cid9 6 hold Yoyo removes states F Line 3 leaves set F set Then return policy solution Line 7 cid9 disconnects graph Rπ outgoing edges nodes N Otherwise suppose Rπ contains leaf node Take subset N nodes Rπ removing nodes N forms minimal cutset Rπ There nondeterministic trace Yoyo following holds Let F fringe set invocations cid9 S If cid9 χ F node S χ N Yoyo Then S nondeterministic trace Theorem 3 means Rπ solution decomposition trace cid9 m nonprimitive task t Line 16 Yoyo algorithm ensures principle nondeterministic choice pair S planner search possible choice decomposition t eventually S cid9 cid9 Let S χ nodes fringe set F nondeterministic trace If S χ leaf node failure conditions Lines 1 4 Yoyo pseudocode hold Since Rπ solution decomposition graph π solution policy Yoyo return Failure Line 6 Theorem 2 Instead Yoyo remove node F Line 3 S G Suppose S χ nonleaf node The failure conditions Lines 1 4 6 hold reasons There cases If S χ outgoing edge labeled action t means primitive task t cid9 S Thus Yoyo choose task Line 9 update F predecessors χ t applicable S child t Line 13 If S χ outgoing edges labeled pair nonprimitive task method m cid9 set states appear child S χ cid9 m S task Line 16 Yoyo choose pair S edge t m Thus Yoyo return Failure Line 17 In cases suppose S S set This means current decomposition followed Yoyo generate policy states S S decomposition path Rπ However Yoyo cid9cid9 cid9 S ﬁnishes current decomposition path Rπ backtrack reaches node S consider decomposition paths node second recursive invocation Line 29 pseudocode Since Yoyo backtrack possible nodes possible states S S Rπ deﬁnes decomposition path states S π solution theorem follows cid2 cid9cid9 χ Rπ S S cid9 cid9 cid9 Appendix B On use control rules Yoyo In Yoyo focused combining HTNbased search control BDDbased representations However possible develop variants Yoyo designed work searchcontrol techniques HTNs In particular written pseudocode algorithms similar Yoyo search control HTN decompo sition instead temporallogic control formulas TLPlan 24 TALplanner 46 As example consider searchcontrol works TLPlan In state s TLPlan computes action applicable s logical formula Progresss f f searchconstraint formula evaluated false state γ s 24 Given set S states variant Yoyo TLPlans searchconstraint formulas split set S generating action 1 applicable states S 2 formula Progresss f false successor states In states S conditions hold current action formula f Yoyo choose action states proceed successors Both HTNbased controlrule based search control requires domain expert author control knowledge input Yoyo planner able use knowledge The effectiveness control knowledge improvement provides planner terms time performance pruning search space depends expertise domain expert properties solutions planning problems underlying domain Although planning domains takes substantial effort write effective search control domains process usually intuitive simple For example HunterPrey domain search control describes strategy focus prey ignore prey focus helped Yoyo generate solution policies eﬃciently Sometimes search control knowledge needs specify implied properties solution policies planning domain For example nondeterministic Blocks World control tells planner drop block table pick immediately important piece information implied fact planner pick block dropped search space going exponential number states explored It possible write searchcontrol strategy HTNs control rules As example Fig B1 shows HTN methods experiments nondeterministic Blocks World domain described Section 7 This method written moving block x block y block z The method applicable gripper block x clear block x x y current conﬁguration block z clear x z goal position x z z good tower If applicability conditions method holds state subtasks order x y z The ﬁrst subtask action unstacks x y The unstack operation nondeterministic possible effect unstack gripper holding block x possible outcome gripper dropped U Kuter et al Artiﬁcial Intelligence 173 2009 669695 693 method moving x y z task solve_ndbw applicabilityconditions gripper block x moved current position block y goal position block z z good tower subtasks 1 unstack x y 2 check outcome unstack proceed accordingly constraints subtask 1 subtask 2 Fig B1 An HTN method moving block block nondeterministic Blocks World domain Method 1 checking outcome unstack task check_unstack applicabilityconditions If gripper holding block subtasks 1 stack x z 2 check outcome stack proceed accordingly constraints subtask 1 subtask 2 Method 2 checking outcome unstack task check_unstack applicabilityconditions If gripper holding block instead table subtasks 1 pick x table 2 stack x z 3 check outcome stack proceed accordingly constraints subtask 1 subtask 2 subtask 2 subtask 3 Fig B2 Two HTN methods checking outcome nondeterministic unstack action block table The second subtask method checks outcome unstack occurred plan later executed determines action Fig B2 shows method checking outcome unstack action planning action accord ingly If gripper holding block x planner simply stacks goal position block x Otherwise gripper dropped block x method tells planner pick immediately action attempt stack later A possible control rule temporallogic formalism TLPlan corresponds set HTNs shown Figs B1 B2 written follows First consider searchcontrol formula described TLPlan 24 χ cid2x clearxgoodtowerx cid18clearx y y xgoodtower y badtowerx cid18 y y x onx table y GOALonx ygoodtower y cid18holdingx One write similar control rules checking possible nondeterministic outcomes action The following example control rules unstack stack χ unstack dropped cid2onx y clearx handempty z GOALonx z goodtowerz cid18ontablex cid18 cid18 holdingx χ stack dropped cid2holdingx z GOALonx z goodtowerz cid18ontablex cid18 cid18 holdingx The formula speciﬁes condition gripper drops block table result unstack action needs true world happens More speciﬁcally conclusions implication states nondeterministic unstack action drops block table gripper holding block state immediately following outcome state satisﬁed picking block table Theoretically doubt general translation exists HTNs control rules formalisms turingcomplete In principle translation developed performing reductions ones turing completeness proofs 49 But doubtful translation look particularly natural human eye far know work develop natural translation 694 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 There certainly nondeterministic planning domains hard write searchcontrol knowledge spec iﬁed HTNs control rules In domains sense planning algorithm capable searchcontrol knowledge knowledge available able continue planning Researchers argued controlrules planning algorithm advantage planners use controlrules fall systematic search rules available ﬂexible HTNs complex environments Although Yoyo NDSHOP2 continue planning HTNs completely speciﬁed easy HTN planner fall forwardchaining search following method template input action planning domain Method m task search control knowledge applicabilityconditions None subtasks 1 action 2 invoke method m recursively constraints subtask 1 subtask 2 For example class methods deﬁned template task searchcontrol knowledge speciﬁed input Yoyo simply perform forward search BDD representations sets states generates goals states Note template domain independent planning domain instantiate actions planning operators speciﬁed domain In summary interesting research topic investigate indepth analysis HTNs controlrules respect classical nondeterministic planning domains investigation scope paper leave future study References 1 P Bertoli A Cimatti M Pistore M Roveri P Traverso MBP A model based planner IJCAI2001 Workshop Planning Uncertainty Incomplete Information Seattle USA 2001 2 A Cimatti M Pistore M Roveri P Traverso Weak strong strong cyclic planning symbolic model checking Artiﬁcial Intelligence 147 12 2003 3584 3 U Kuter D Nau Forwardchaining planning nondeterministic domains AAAI2004 2004 4 RE Bryant Symbolic boolean manipulation ordered binarydecision diagrams ACM Computing Surveys 24 3 1992 293318 5 D Nau TC Au O Ilghami U Kuter W Murdock D Wu F Yaman SHOP2 An HTN planning JAIR 20 2003 379404 6 S Koenig RG Simmons Realtime search nondeterministic domains IJCAI1995 1995 7 A Cimatti M Roveri P Traverso Automatic OBDDbased generation universal plans nondeterministic domains AAAIIAAI Proceedings 1998 pp 875881 8 A Cimatti M Roveri P Traverso Strong planning nondeterministic domains model checking Proceedings International Conference AI Planning Systems AIPS AAAI Press 1998 pp 3643 9 M Daniele P Traverso M Vardi Strong cyclic planning revisited Proceedings European Conference Planning ECP 1999 pp 3548 10 M Ghallab D Nau P Traverso Automated Planning Theory Practice Morgan Kaufmann 2004 11 N Nilsson Principles Artiﬁcial Intelligence Morgan Kaufmann 1980 12 M Pistore P Traverso Planning model checking extended goals nondeterministic domains Proceedings International Joint Confer ence Artiﬁcial Intelligence IJCAI Seattle USA Morgan Kaufmann 2001 pp 479484 13 M Pistore R Bettin P Traverso Symbolic techniques planning extended goals nondeterministic domains Proceedings European Conference Planning ECP 2001 14 F Kabanza M Barbeau R StDenis Planning control rules reactive agents Artiﬁcial Intelligence 95 1 1997 67113 15 M Genesereth I Nourbakhsh Timesaving tips problem solving incomplete information Proceedings National Conference Artiﬁcial Intelligence AAAI 1993 16 L Pryor G Collins Planning contingency A decision based approach Journal Artiﬁcial Intelligence Research 4 1996 81120 17 M Peot D Smith Conditional nonlinear planning Proceedings International Conference AI Planning Systems AIPS 1992 pp 189197 18 RP Goldman MS Boddy Conditional linear planning Proceedings International Conference AI Planning Systems AIPS 1994 19 JS Penberthy D Weld UCPOP A sound complete partial order planner adl Proceedings International Conference Knowledge Representation Reasoning KR 1992 20 N Onder ME Pollack Conditional probabilistic planning A unifying algorithm effective search control mechanisms Proceedings National Conference Artiﬁcial Intelligence AAAI 1999 pp 577584 21 H Kautz B Selman Planning satisﬁability Proceedings European Conference Artiﬁcial Intelligence ECAI 1992 pp 359363 22 J Rintanen Constructing conditional plans theoremprover Journal Artiﬁcial Intelligence Research 10 1999 323352 23 J Rintanen Improvements evaluation quantiﬁed boolean formulae Proceedings International Joint Conference Artiﬁcial Intelli gence IJCAI Stockholm Sweden Morgan Kaufmann 1999 pp 11921197 24 F Bacchus F Kabanza Using temporal logics express search control knowledge planning Artiﬁcial Intelligence 116 12 2000 123191 25 A Cimatti E Giunchiglia F Giunchiglia P Traverso Planning model checking A decision procedure AR Proceedings European Conference Planning ECP Lecture Notes Artiﬁcial Intelligence LNAI vol 1348 Toulouse France SpringerVerlag 1997 pp 130142 26 F Giunchiglia P Traverso Planning model checking Proceedings European Conference Planning ECP 1999 pp 120 27 P Bertoli A Cimatti M Roveri P Traverso Planning nondeterministic domains partial observability symbolic model checking Pro ceedings International Joint Conference Artiﬁcial Intelligence IJCAI Seattle USA Morgan Kaufmann 2001 pp 473478 28 P Bertoli A Cimatti M Roveri P Traverso Strong planning partial observability Artiﬁcial Intelligence 170 2006 337384 29 B Bonet H Geffner GPT tool planning uncertainty partial information Proceedings International Joint Conference Artiﬁcial Intelligence IJCAI 2001 pp 8287 30 J Rintanen Conditional planning discrete belief space Proceedings International Joint Conference Artiﬁcial Intelligence IJCAI 2005 U Kuter et al Artiﬁcial Intelligence 173 2009 669695 695 31 U Dal Lago M Pistore P Traverso Planning language extended goals AAAIIAAI Proceedings Edmonton Canada AAAI PressThe MIT Press 2002 pp 447454 32 R Jensen MM Veloso OBDDbased universal planning synchronized agents nondeterministic domains JAIR 13 2000 189226 33 R Jensen MM Veloso MH Bowling OBDDbased optimistic strong cyclic adversarial planning Proceedings European Conference Planning ECP 2001 34 R Jensen MM Veloso R Bryant Guided symbolic universal planning Proceedings International Conference Automated Planning Scheduling ICAPS Trento AAAI Press 2003 35 C Boutilier TL Dean S Hanks Decisiontheoretic planning Structural assumptions computational leverage JAIR 11 1999 194 36 AL Blum ML Furst Fast planning planning graph analysis Artiﬁcial Intelligence 90 12 1997 281300 37 C Castellini E Giunchiglia A Tacchella Satbased planning complex domains Concurrency constraints nondeterminism Artiﬁcial Intelli gence 147 12 2003 85117 38 P Ferraris E Giunchiglia Planning satisﬁability nondeterministic domains AAAIIAAI Proceedings AAAI Press 2000 pp 748753 39 E Giunchiglia Planning satisﬁability expressive action languages Concurrency constraints nondeterminism Proceedings Inter national Conference Knowledge Representation Reasoning KR 2000 40 DE Smith DS Weld Conformant Graphplan AAAIIAAI Proceedings 1998 pp 889896 41 DS Weld CR Anderson DE Smith Extending Graphplan handle uncertainty sensing actions AAAIIAAI Proceedings Menlo Park AAAI Press 1998 pp 897904 42 D Bryce S Kambhampati Heuristic Guidance Measures Conformant Planning Proceedings International Conference Automated Planning Scheduling ICAPS 2004 43 R Brafman J Hoffmann Conformant planning heuristic forward search A new approach Proceedings 14th International Conference Automated Planning Scheduling ICAPS04 Whistler Canada Morgan Kaufmann 2004 44 J Hoffmann R Brafman Contingent planning heuristic forward search implicit belief states Proceedings International Conference Automated Planning Scheduling ICAPS 2005 45 D Bryce S Kambhampati DE Smith Planning graph heuristics belief space search Journal Artiﬁcial Intelligence Research 26 2006 3599 46 J Kvarnström P Doherty TALplanner A temporal logic based forward chaining planner Annals Mathematics Artiﬁcial Intelligence 30 2001 119169 47 A Gerevini U Kuter D Nau A Saetti N Waisbrot Combining domainindependent planning HTN planning The duet planner Proceedings European Conference Artiﬁcial Intelligence ECAI 2008 48 A Gerevini A Saetti I Serina Planning stochastic local search temporal action graphs Journal Artiﬁcial Intelligence Research 20 2003 239290 49 K Erol J Hendler DS Nau Complexity results hierarchical tasknetwork planning Annals Mathematics Artiﬁcial Intelligence 18 1996 6993