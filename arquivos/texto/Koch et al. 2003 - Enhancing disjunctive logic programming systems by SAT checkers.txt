Artiﬁcial Intelligence 151 2003 177212 wwwelseviercomlocateartint Enhancing disjunctive logic programming systems SAT checkers Christoph Koch Nicola Leone b Gerald Pfeifer Institut für Informationssysteme Technische Universität Wien A1040 Wien Austria b Department Mathematics University Calabria 87030 Rende CS Italy Received 1 May 2002 Abstract Disjunctive logic programming DLP stable model semantics powerful nonmonotonic formalism knowledge representation reasoning Reasoning DLP harder normal free logic programs stable model checkingdeciding given model stable model propositional DLP programis coNPcomplete polynomial normal logic programs This paper proposes new transformation ΓM P reduces stable model checking UNSATie deciding given CNF formula unsatisﬁable The stability model M program P veriﬁed calling Satisﬁability Checker CNF formula ΓM P The transformation parsimonious new symbol added efﬁciently computable runs logarithmic space polynomial time Moreover size generated CNF formula exceeds size input usually smaller We complement transformation modular evaluation results allow efﬁcient handling large realworld reasoning problems The proposed approach stable model checking implemented DLVa stateofthe art implementation DLP A number experiments benchmarks run SATZ Satisﬁability checker The results experiments positive conﬁrm usefulness techniques 2003 Elsevier BV All rights reserved A preliminary version paper presented IJCAI99 1 This work supported European Commission project INFOMIX project IST200133570 project ICONS project IST200132429 Corresponding author Email addresses kochdbaituwienacat C Koch leoneunicalit N Leone pfeiferdbaituwienacat G Pfeifer 00043702 matter 2003 Elsevier BV All rights reserved doi101016S000437020300078X 178 C Koch et al Artiﬁcial Intelligence 151 2003 177212 Keywords Disjunctive logic programming Nonmonotonic reasoning Headcyclefree programs Answer set programs Stable model checking 1 Introduction Disjunctive logic programming DLP stable model semantics powerful nonmonotonic formalism knowledge representation common sense reasoning 2 5 DLP high expressive power 6it allows express problems complexity class cid6P 2 NPNP It known important nonmonotonic reasoning AI problems cid6P 2 complete 712 nonmonotonic reasoning systems stable model semantics currently efﬁcient declarative systems deal problems Moreover complex problems represented simple easytounderstand fashion 1314 DLP stable model semantics Roughly DLP program set disjunctive rules clauses form a1 b1 bk bk1 bm possibly body m cid1 0 The intuitive reading rule If b1 bk true bk1 bm false1 atom a1 true Atoms a1 b1 bm contain variables function terms A clause head n 0 nonempty body called integrity constraint read At atom b1 bk false atom bk1 bm true body constraint false The intended models DLP program semantics program subsetminimal models grounded precise sense They called stable models answer sets 2 5 The DLP language allows fully declarative programming style called answer set programming ASP The idea answer set programming represent given computational problem DLP program stable models answer sets correspond solutions use DLP ﬁnd solution 15 Example 11 Consider 3Colorability wellknown NPcomplete problem graph theory closely relates problem coloring map minimal number colors neighboring countries assigned color Given graph problem decide exists assignment colors red green blue node adjacent nodes different colors 1 Throughout paper intuitively denotes negationasfailure classical negation C Koch et al Artiﬁcial Intelligence 151 2003 177212 179 Suppose graph represented set facts F unary predicate following DLP program nodeX binary predicate arcX Y Then combination F computes 3Colorings stable models graph colorX red colorX green colorX blue nodeX r1 r2 colorX1 C colorX2 C arcX1 X2 Rule r1 2 expresses node colored red green blue minimality stable models node assigned color The subsequent integrity constraint checks pair adjacent nodes connected arc assigned color Thus onetoone correspondence solutions 3Coloring problem stable models F r1 r2 The graph 3colorable F r1 r2 stable model Answer set programming recently number promising applications Several tasks information integration require complex reasoning capabilities explored INFOMIX project funded European Commission project IST2002 33570 Another ECfunded project ICONS IST200132429 employs DLP intelligent query engine knowledge management The Polish company Rodan Systems SA uses DLP tool detection price manipulations unauthorized uses conﬁdential information Polish securities exchange commission ASP solvers decision support Space Shuttle 16 product software conﬁguration tasks 1718 model checking applications 19 The high expressive powera key reason success disjunctive logic programmingis paid high computational complexity Indeed main nonmonotonic formalisms like Default Logic Circumscription reasoning DLP stable model semantics hard The high complexity DLP reasoning stems sources On hand exponential number possible models model candidates hand hardness stable model checking deciding given model stable model propositional DLP programwhich coNPcomplete The hardness problem discouraged implementation DLP engines Indeed time systemsnamely DLV 13 GnTSmodels 20 available fully support functionfree DLP stable model semantics In paper study stable model checking problem provide efﬁcient methods implementation We come new transformation reduces stable model checking Unsatisﬁability UNSATthat deciding given CNF formula unsatisﬁable This complement Satisﬁability SAT problem efﬁcient systems developed AI decade Besides providing elegant characterization stable models sheds new light intrinsic nature proposed transformation strong practical impact Indeed 2 Variable names start upper case letter constants start lower case letter 180 C Koch et al Artiﬁcial Intelligence 151 2003 177212 transformation huge work AI design implementation efﬁcient algorithms checking Satisﬁability proﬁtably implementation DLP engines supporting stable model semantics In sense transformation opens new frontiers implementation Disjunctive Logic Programming In addition derive new modularity properties stable models permit use modular evaluation techniques stable model checking Those prove extremely useful light coNPcompleteness results task We implemented proposed technique DLP DLV performed number experiments benchmarks In sum main contributions paper following We deﬁne new transformation stable model checking general DLP negation UNSAT propositional CNF formulas We prove correctness transformation The transformation parsimonious add new symbol efﬁciently computable runs LOGSPACE polynomial time Moreover size generated CNF formula exceeds size input usually smaller rules simpliﬁed removed We present new results based application modular evaluation techniques approach allow efﬁciency improvements splitting process stable model checking Instead checking stability model entire program model split components independently checked stability respective subprograms We realize approach DLP DLVa stateoftheart implementation disjunctive logic programmingby efﬁcient DavisPutnam procedure SATZ 21 Satisﬁability checker solve UNSAT We compare approach GnT original stablemodel checking method DLV We highlight main differences methods carry experimental activity number cid6P 2 complete problems The results experiments witness efﬁciency approach stable model checkingDLV new strategy outperforms competing systems It worth noting stable model checking DLP programs generalizes minimal model checking Horn CNF formulas results employed reasoning minimal models circumscription formulas The DLV implements results described paper downloaded httpwwwdlvsystemcom From Web page retrieve benchmark problems experiments The paper organized follows Section 2 ﬁrst provides deﬁnitions syntax semantics DLP stable model semantics After examples DLP couple knowledge representation problems In Section 3 outline previously known results stable model checking Section 4 presents main result transformation stable model checking UNSAT Section 5 applies modularity properties DLP programs context transformation Section 6 brieﬂy C Koch et al Artiﬁcial Intelligence 151 2003 177212 181 describes implementation compares approach stable model checking methods presents benchmark problems results obtained experiments Finally Section 7 addresses number related works draws conclusions 2 Disjunctive logic programming stable model semantics In section provide overview functionfree disjunctive logic programming stable model semantics 2142223 21 Syntax A variable constant term An atom form at1 tn predicate arity n cid1 0 t1 tn terms A literal positive literal p negative literal p p atom A disjunctive rule r clause form a1 b1 bk bk1 bm n cid1 1 m cid1 0 a1 b1 bm atoms r needs safe variable occurring r appear positive body literals b1 bk The disjunction a1 head r conjunction b1 bk bk1 bm body r We denote H r set a1 head atoms Br set b1 bk bk1 bm body literals Br respectively Br denotes set atoms occurring positively respectively negatively Br Br b1 bk Br bk1 bm Constraints special rules head n 0 written b1 bk bk1 bm m cid1 1 deﬁne syntactic sugaring equivalent rule b1 bk bk1 bm new nullary propositional atom A disjunctive program called DLP program set rules constraints A free respectively free program called positive respectively normal An atom literal rule constraint program respectively ground variables appear A ﬁnite ground program called propositional program 22 Stable model semantics Now let P program The Herbrand universe UP functionfree case P set constants appear program3 The Herbrand base BP P set possible ground atoms constructed predicates appearing rules P terms occurring UP Given rule r occurring P ground instance r rule obtained r replacing variable X r σ X σ 3 If constants appear program added arbitrarily 182 C Koch et al Artiﬁcial Intelligence 151 2003 177212 mapping variables occurring r terms UP We denote groundP set ground instances rules occurring P A total interpretation P set ground atoms interpretation subset I BP A ground positive literal A true respectively false respect I A I respectively A I A ground negative literal A true wrt I A false wrt I A false wrt I Let r rule groundP The head r true respect I H r I cid16 The body r true wrt I body literals r true wrt I Br I Br I false wrt I The rule r satisﬁed true wrt I head true wrt I body false wrt I A model P interpretation M P rule r groundP true body ground constraint false wrt M A model M P minimal model N P exists N proper subset M The set minimal models P denoted MMP The ﬁrst proposal assigning semantics disjunctive logic program appears 24 presents modeltheoretic semantics positive programs According 24 semantics program P described set MMP minimal models P Observe positive program P admits minimal model positive program P MMP cid16 holds Example 214 For positive program P1 b interpretations b minimal models MMP b For program P2 b b b b minimal model As far general programs programs negation appear bodies concerned number semantics proposed 232429 3031 comprehensive surveys A generally acknowledged semantics DLP programs extension stable model semantics 3233 account disjunction 23 Given program P interpretation I GelfondLifschitz GL transformation P wrt I denoted P I set positive rules deﬁned follows P I cid1 a1 b1 bk a1 b1 bk bk1 bm cid2 groundP bi I k 1 cid2 cid2 m Clearly P positive P I coincides groundP It turns positive programs minimal stable models coincide Deﬁnition 22 23 Let I interpretation program P I disjunctive stable model P I MMP I I minimal model positive program P I 4 For simplicity use propositional examples programs coincide ground instantiations paper However results algorithms apply equally general case functionfree disjunctive programs variables C Koch et al Artiﬁcial Intelligence 151 2003 177212 183 Example 23 Let P b c b c c b I b Then P I b c b It easy verify I minimal model P I Thus I stable model P 23 Knowledge representation DLP Next examples use DLP solving complicated reasoning problems notably Hamiltonian Path problem case Network Diagnosis Example 24 Hamiltonian Path classical NPcomplete problem area graph theory Given undirected graph G V E V set vertices G E set arcs node V graph exist path G starting passing node V exactly Suppose graph G speciﬁed predicates nodeX arcX Y 5 starting node speciﬁed unary predicate start contains single tuple Then following program Php solves Hamiltonian Path problem inPathX Y outPathX Y reachedX arcX Y nodeX reachedX reachedX startX reachedX inPathY X inPathX Y inPathX Y1 Y cid16 Y1 inPathX Y inPathX1 Y X cid16 X1 The ﬁrst rule guesses subset S E given arcs path rest program checks subset S constitutes Hamiltonian Path The ﬁrst constraint enforces nodes V graph reached starting node subgraph induced S ensures subgraph connected The rules constraint deﬁne reachability starting node respect set arcs S The ﬁnal constraints check set arcs S selected inPath meets following requirements Hamiltonian Path satisfy There arcs starting node arcs ending node If input graph starting node speciﬁed set F facts predicates node arc start onetoone correspondence solutions 5 Predicate arc symmetric undirected arcs bidirectional 184 C Koch et al Artiﬁcial Intelligence 151 2003 177212 Fig 1 A network Hamiltonian Path problem stable models F Php The graph Hamiltonian Path F Php stable model Example 25 Abduction Consider network depicted Fig 1 We observation sitting machine online reach machine e Which machines ofﬂine This easily modeled program Pnet cid21Hypnet Obsnet LPnetcid22 LPnet theory LPnet cid1 reachesX X nodeX ofﬂineX reachesX Z reachesX Y connectedY Z ofﬂineZ connecteda b connectedb c connectedb d connectedc e connectedd e nodea nodeb nodec noded nodee cid2 set hypotheses node ofﬂine encoded Hypnet cid1 cid2 ofﬂinex not_ofﬂinex x network node Observations encoded constraints Obsnet cid1 ofﬂinea ofﬂineb reachesa e cid2 positive observations x encoded constraints x The ﬁve stable models Pnet contain explanations cid2 cid1 ofﬂinec ofﬂined cid2 cid1 ofﬂinee cid1 ofﬂinec ofﬂinee cid1 ofﬂined ofﬂinee cid1 ofﬂinec ofﬂined ofﬂinee cid2 cid2 cid2 E1 E2 E3 E4 E5 subsets respectively The program shown example reﬁned subset minimal diagnosis resulting explanations E1 E2 slightly involved encoding minimal cardinality diagnosis single probable explanation E2 DLP weak constraints 34 C Koch et al Artiﬁcial Intelligence 151 2003 177212 185 3 Previous results stable model checking Next review known results stable model checking problem determining model M disjunctive logic program P stable We refer 23 detailed discussion issues 31 Stable models unfounded sets In section present characterization stable models disjunctive logic programs terms unfounded sets This characterization prove correctness reduction stable model checking UNSAT section The characterization obtained slight modiﬁcations results presented 23 In particular providing notion unfounded sets directly total 2valued interpretations obtain simpler characterization 23 unfounded sets deﬁned wrt partial 3valued interpretations Deﬁnition 31 Deﬁnition 31 23 Let I total interpretation program P A set X BP ground atoms unfounded set P wrt I rule r groundP X H r cid16 following conditions holds C1 Br cid16 I Br I cid16 body r false wrt I C2 Br X cid16 positive body literal belongs X C3 H r X I cid16 atom head r distinct elements X true wrt I Example 32 Let P b I b Due Condition 3 b unfounded sets I wrt P Deﬁnition 33 An interpretation I program P unfoundedfree iff nonempty subset I unfounded set P wrt I The unfoundedfree condition singles precisely stable models Proposition 34 Theorem 46 23 Let M model program P M stable model P iff M unfoundedfree Example 35 Let P b M1 stable model P non subset M1 unfounded set As shown Example 32 M2 b unfoundedfree stable model 32 A tractable class HCF programs In section discuss special case DLP programs having socalled head cyclefree property Informally property ensures recursion disjunction allowing efﬁcient stablemodel checking method 186 C Koch et al Artiﬁcial Intelligence 151 2003 177212 Fig 2 Graphs DGP1 b DGP2 With program P associate directed graph DGP N E called dependency graph P following properties Each predicate P node N ii There directed arc E node node b iff rule r P b predicates positive literal appearing Br H r respectively The graph DGP singles dependencies head predicates rule positive predicates body rule6 Example 36 Consider program P1 consisting following rules b c c b The dependency graph DGP1 P1 depicted Fig 2a Note sample programs propositional nodes sample graphs Fig 2 atoms atoms coincide predicates case Consider program P2 obtained adding P1 rules d e d e e d b The dependency graph DGP2 shown Fig 2b The dependency graphs allow single headcyclefree HCF programs 3536 A program P HCF iff clause r P predicates occurring head r cycle DGP Example 37 The dependency graphs given Fig 2 reveal program P1 Example 36 HCF program P2 HCF rule d e contains predicates head belong cycle DGP2 Deﬁnition 38 Let P program I interpretation Then deﬁne operator RPI follows RPI 2BP 2BP X cid24 cid1 X r groundP H r Br I X cid16 H r I denotes set ground literals l l I cid3 cid4 cid2 I cid16 6 Note negative literals cause arc DGP C Koch et al Artiﬁcial Intelligence 151 2003 177212 187 It easy operator RPI monotonic Moreover given set X BP obvious sequence R0 X Rn RPI Rn1 decreases monotonically converges ﬁnitely limit denote Rω PI X As shown 23 given program P model M fact result holds interpretations general P unfounded sets P wrt M contained M subsets Rω PM M Proposition 39 Let P program7 M model P Then Rω implies M unfoundedfree wrt P PM M In case program P headcyclefree model M P unfoundedfree Rω PM M Proposition 310 Theorem 69 23 Let P HCF program M total interpretation Then M unfoundedfree iff Rω PM M It shown headcyclefree programs Model Checking performed polynomial time Corollary 311 Corollary 610 23 Let P propositional HCF program M model P Recognizing M stable model polynomial Example 312 Given HCF program P containing ﬁrst ﬁve rules program P2 Example 36 b d e c d e c b model M c d We RPM M c d R2 d Rω PM M Thus M stable model P stated Proposition 310 PM M RPM c 33 Modularity properties In section summarize main modular evaluation result 23 related work 637 Given program P denote cid5DGP graph strongly connected components DGP graph obtained collapsing strongly connected components DGP The subprogram subpQ P corresponding component Q graph deﬁned set rules r P H r Q cid16 By I Q denote set atoms component Q true wrt interpretation I I Q Basically unfoundedfree property consequently stablemodel checking veriﬁed independently component subprograms program P model unfoundedfree iff unfoundedfree wrt individual subprograms 7 This program need HCF 188 C Koch et al Artiﬁcial Intelligence 151 2003 177212 Fig 3 Graph cid5DGP2 Proposition 313 Let P program I interpretation P I unfounded free iff exists node Q cid5DGP I Q contains nonempty unfounded set subpQ P wrt I Example 314 Consider program P2 Example 36 b d e c d e c b e d b The component dependency graph cid5DGP2 shown Fig 3 cid5DGP2 M sets b wrt M model M stable Interpretation M b c d e clearly model P2 For node Q b b subpQ P2 b Since subpQ P2 unfounded Q This property allows check unfoundedfreeness stability model M modular way described following section 34 A stable model checking algorithm The combination results previous subsections yields modular model checking algorithm shown Fig 4 This algorithm proposed 23 implemented DLV method referred Old Checker Section 6 Roughly ﬁrst compute component dependency graph cid5DGP program Then visit nodes cid5DGP components P sequence For node Q cid5DGP compute ﬁxpoint R operator nodes M Q nodes component true wrt model M subprogram Q If ﬁxpoint component certain unfoundedfree Otherwise check ﬁxpoint need check inside component Q contains nonempty unfounded set subpQ P respect M If case nodes component dependency graph cid5DGP nonempty unfounded set M stable unfoundedfree M stable As shown 23 algorithm Fig 4 correct Proposition 315 Let P DLP program M model P Then M stable model P iff unfoundedfreeP Mie algorithm Fig 4returns true This method main advantages C Koch et al Artiﬁcial Intelligence 151 2003 177212 189 Function unfoundedfreeP Program M SetOfAtoms Boolean var X Y Q SetOfAtoms begin compute cid5DGP node Q cid5DGP subpQPM M Q X Rω X cid16 subpQ P HCF return False Computation nonHCF components Y X Y cid16 Y unfounded set subpQ P wrt M return False end end end end return True end Fig 4 The old model checking algorithm DLV 1 Since subprograms evaluated oneatatime evaluation method selected according characteristics subprogram This way headcycle free subpro grams evaluated efﬁciently inefﬁcient computation limited nonHCF subprograms 2 In order check stability unfoundedfreeness component Q rules subprogram subpQ P considered All remaining rules P irrelevant purpose Consequently stability check applied small subprograms big evident advantages perspective complexity8 4 From stable model checking UNSAT In section present reduction stable model checking UNSAT complement Satisﬁability SAT SAT best researched problems AI efﬁcient algorithms systems developed solving SAT UNSAT Recall CNF formula set A atomic propositions conjunction form φ c1 cn c1 cn clauses A Without loss generality paper clause c a1 b1 br written 8 Recall stability check coNPhard requires time order 2 worst case If P consists nonHCF subprograms A B P A B modular evaluation A 2 technique requires time order 2 sensibly smaller 2 AB B P 190 C Koch et al Artiﬁcial Intelligence 151 2003 177212 DLP Program S Set Clauses Delete P rule body false wrt M Remove negative literals bodies remaining rules Remove false atoms wrt M heads resulting rules S Let P cid27 rule a1 b1 bm P cid27 Input A ground DLP program P model M P Output A propositional CNF formula ΓM P M var P cid27 begin 1 2 3 4 5 6 7 8 9 10 end S S b1 bm a1 end ΓM P output ΓM P program resulting steps 13 cS c xM x cid7 cid6 Fig 5 The transformation ΓM P a1 b1 br CNF formula φ conjunction implications The usual form writing CNFs immediately obtained transforming clause ci disjunction literals A formula φ A satisﬁable exists truth assignment propositions A makes φ true φ unsatisﬁable inconsistent UNSAT following decision problem Given CNF formula φ true φ unsatisﬁable Our reduction stable model checking UNSAT implemented algorithm shown Fig 5 In order clarify steps performed transformation use following running example Example 41 Let P program b c b c b c Consider model M1 b P In ﬁrst step algorithm shown Fig 5 rule c deleted In second step c removed body rule P step removes c head ﬁrst rule Thus step 3 program b b b Steps 48 switch bodies heads rules yielding set clauses S b b b Finally step 9 constructs conjunction clauses S plus clause b Therefore output algorithm ΓM1P b b b b Now consider model M2 c Here ﬁrst steps simplify P c c Steps 48 swap heads bodies rules resulting c c step 9 adds c So outcome M2 ΓM2P c c c C Koch et al Artiﬁcial Intelligence 151 2003 177212 191 Theorem 42 Given model M ground DLP program P let ΓM P CNF formula computed algorithm Fig 5 input P M Then M stable model P ΓM P unsatisﬁable In remainder section demonstrate Theorem 42 correctness ΓM P reduction We proceed incremental way dividing ΓM P transformation steps showing correctness As mentioned use Example 41 running example illustrate steps Deﬁnition 43 Let P DLP program M model P Deﬁne simpliﬁed version αM P P wrt M cid1 a1 b1 bn r groundP αM P a1 H r M b1 bn Br Br true wrt M cid2 It easy αM P coincides program P cid27 obtained steps 13 Fig 5 Observe rule αM P nonempty head Indeed interpretation M program P αM P contain rule r head M model P rule P corresponding r true body false head Moreover simpliﬁed program αM P positive free contains atoms true wrt M Next observe αM P equivalent P far stability M concerned Lemma 44 Let P DLP program M model P Then M stable model P stable model αM P cid6 C2 C3 Proof C1 C2 C3 refer unfoundedness conditions Deﬁnition 31 Therefore rewrite Deﬁnition 31 deﬁne unfounded sets X M sets satisfying rP H r X C1 C2 C3 wrt M We claim X M cid6 rPP cid27H r X C1 C2 C3 equals Now partition P sets P cid27 P P cid27 P cid27 r PBr false cid6 rP cid27H r X C1 C2 C3 rαM PH r X C1 Clearly rule r P cid27 C1 Br false wrt M true Therefore conjunction rules shown true eliminated The corresponding rules exist αM P For remaining rules P P cid27 exists onetoone relationship rules αM P derived Here pair r1 P P cid27 r2 αM P corresponding rules pair conditions disjunctions associated rules values It easy H r1 X H r2 X H r1 M H r2 X M We know P P cid27 αM P cid6 192 C Koch et al Artiﬁcial Intelligence 151 2003 177212 C1 false The value C2 equal pairs r1 r2 Br1 Br2 ﬁnally C3 H r1 M H r2 M But demonstrate X M unfounded set P unfounded set αM P Lemma 44 follows directly Deﬁnition 33 Proposition 34 Example 45 Consider P models M1 M2 Example 41 M1 stable model P M2 Indeed M1 stable model αM1 P b b b M2 stable model αM2 P c c Next simply swapping heads bodies rules simpliﬁed program αM P set clauses models correspond unfounded sets P wrt M Deﬁnition 46 Let P DLP program M model P Deﬁne βM P following set clauses M cid1 βM P b1 bm a1 a1 b1 bm αM P cid2 Observe βM P coincides set clauses S constructed steps 18 Fig 5 Lemma 47 Let P ground DLP program M model P X M Then X model βM P iff unfounded set P wrt M Proof We know X M unfounded set M wrt αM P rule αM P H r X conditions C1 C3 Deﬁnition 31 true Condition C1 false rules αM P rαM PH r X true bodies Therefore X unfounded set M iff Br X cid16 H r X M cid16 For rules αM P bodies positive atoms heads true wrt M Furthermore H r X subsumed H r X cid16 rules αM P H r cid16 Because rαM PBr X cid16 simplify requirements X unfounded set H r X cid16 equals hH r h X Therefore ﬁnding unfounded sets M wrt αM P equal computing models h bBr b X rαM P cid6 cid7 cid6 cid7 cid6 cid7 cid6 cid7 bBr b hH r rαM P Example 48 βM1P b b b The subset M1 model βM1P M1 unfoundedfree Indeed unfounded set M1 wrt P βM2 P equal c c M2 subsets c models βM2P Indeed precisely unfounded sets M2 wrt P We position demonstrate main theorem C Koch et al Artiﬁcial Intelligence 151 2003 177212 193 Proof Theorem 42 In following ΓM P unsatisﬁable iff M unfoundedfree The statement directly follow Proposition 34 It easy output ΓM P algorithm Fig 5 coincides conjunction clauses βM P clause xMx From Lemma 47 models βM P precisely unfounded sets P wrt M Therefore models ΓM P exactly nonempty unfounded sets P wrt M model ΓM P satisfy clause xMx states element M true model ΓM P Thus M contains nonempty unfounded set P unfoundedfree iff ΓM P model unsatisﬁable Example 49 M1 b stable model P Indeed ΓM1P b b b b unsatisﬁable M2 c hand stable P ΓM2P c c c satisﬁed model c The theorem shows ΓM P efﬁcient transformation Theorem 410 Given model M ground DLP program P let ΓM P CNF formula computed algorithm Fig 5 input P M Then following holds 1 ΓM P cid2 P M 2 ΓM P parsimonious transformation 3 ΓM P LOGSPACE computable P M Proof ΓMP conjunction clauses βM P plus disjunction propositions M The size βM P equal size αM P smaller equal size P Thus ΓMP cid2 P M ΓM P clearly parsimonious formula propositions M Finally easy ΓM P computed LOGSPACE Turing Machine Indeed ΓM P generated dealing rule P time storing intermediate data apart ﬁxed number indices The ΓM P transformation reducing stablemodel checking UNSAT suggests straightforward way implement stablemodel checker External Function SATΦ CNF Boolean Function unfoundedfreeP Program M SetOfAtoms Boolean begin SATΓM P return False return True end 194 C Koch et al Artiﬁcial Intelligence 151 2003 177212 Thus compute unfoundedfree property existing SAT solver checking program P model M transformation ΓM P unsatisﬁable Theorem 411 Given program P model M P abovestated function unfoundedfree returns true iff M stable model P Proof Immediate Theorem 42 5 Enhancing SATbased approach stable model checking modularity As seen task checking stability condition DLP transformed UNSAT problem fairly known sophisticated algorithms exist like stable model checking se coNPcomplete In section exploit important properties problem checking unfoundedfreeness property DLP programs On hand know important class headcyclefree HCF programs computation polynomial time On hand know form modular evaluation possible To end combine RPM operator modularity results described Section 3 transformation Apart new practical stable model checking algorithm present Section 52 improvement algorithm Fig 4 Section 3 provide minor equivalence results combinations basic building blocks simpliﬁcation Γ transformation RPM operator modularity Given additional degree freedom introduced Γ transformation Section 4 discussion clearly needed First introduce slightly generalized version transformation presented previous section 51 Parameterizing αM P ΓM P The transformation presented section separate parameter allowing use knowledge ground atoms occur unfounded sets atoms We later use context modular evaluation efﬁcient evaluation headcyclefree programs Deﬁnition 51 Let P program M model P let X set X M We deﬁne simpliﬁed version P M X αMXP cid1 a1 b1 bn r groundP a1 H r M b1 bn Br X Br true wrt M H r M X cid2 C Koch et al Artiﬁcial Intelligence 151 2003 177212 195 Analogously αMXP extend transformation ΓM P Fig 5 additional parameter ﬁlter atoms known unfounded sets Deﬁnition 52 Let P program M model P let X set X M The transformation ΓMXP deﬁned cid10 ΓMXP x cid8 cid9 xX cid1 b1 bm a1 a1 b1 bm αMXP cid2 Of course αM P ΓM P special cases αMXP ΓMXP respectively X M We generalize Lemma 44 Theorem 42 transformations αMXP ΓMXP Lemma 53 Given program P model M P set X M st known unfounded set U M wrt P U X9 1 M unfoundedfree P iff unfoundedfree αMXP 2 ΓM P satisﬁable Γ cid27 MXP satisﬁable Proof 1 Remember known equivalence unfounded sets αM P models βM P Since atom M X unfounded set αM P atom M X model βM P Thus remove atoms heads clauses βM P bodies rules αM P remove clauses βM P bodies contain atoms M X bodies false Translated perspective αM P results αMXP 2 Follows trivially 1 Theorem 42 Example 54 By Lemma 53 combine transformation αMXP Rω PM M course guaranteed subsume unfounded sets M wrt P Let P b b b c c M b c We αM P P Rω PM M b Here αMRω PM MP b b b ΓMRω PM MP b b b b unsatisﬁable ΓM P b b c b c b c 9 Trivially property holds X M 196 C Koch et al Artiﬁcial Intelligence 151 2003 177212 52 A dynamicallymodular stablemodel checker The modular evaluation result Proposition 313 allows reduce task computing unfoundedfreeness property programs computing smaller strongly connected components dependency graph By combining Proposition 313 Lemma 53 obtain model M unfoundedfree wrt program P iff components dependency graph cid5DGP Γ cid27 subpQ P unsatisﬁable It clear modularity result applies M M Q simpliﬁed versions programs In particular applies αM P PM MP instead P The components simpliﬁed programs αMRω fewer smaller components dependency graph non simpliﬁed program A program unfoundedfree iff transformed subprograms unsatisﬁable These ideas need combined Fig 6 shows algorithm model checking incorporates results Initially start computing ﬁxpoint Rω PM M The reason Rω PM M computed linear time eliminates need save time splitting program Also rules contained component subprograms keeping program save time Furthermore computing dependency graph simpliﬁed version P chance program split smaller components In simpliﬁcation rules removed contributed arcs dependency graph Function unfoundedfreeP Program M SetOfAtoms Boolean var P cid27 Program X Y Q SetOfAtoms begin X Rω PM M X return True P HCF return False P cid27 αMXP compute cid5DGP cid27 node Q cid5DGP cid27 subpQ P cid27 HCF Y Rω Y cid16 return False subpQP cid27M M Computation nonHCF components compute ΓMQsubpQ P cid27 SATΓMQsubpQ P cid27 return False end end return True end Fig 6 The new algorithm checking unfoundedfree property C Koch et al Artiﬁcial Intelligence 151 2003 177212 197 PM MP program P Example 56 Note component Fig 7 Graphs DGP b DGαMRω graph consists nodes b c d f g h e component graph b small component removed large pruned split b c d f g Next handle case P HCF immediately determine unfoundedfreeness property checking size Rω PM M Then compute PM MP check unfounded dependency graph simpliﬁed program αMRω freeness component subprograms independently similarly old algo rithm Fig 4 That program unfoundedfree subprograms unfoundedfree In HCFcase recompute ﬁxpoint R operator component check size 0 In nonHCF case refrain reapplying R operator proved efﬁcient directly run SAT solver practice Our algorithm computes unfoundedfree property ground program model Theorem 55 Let P ground DLP program M model P Then M stable wrt P iff function unfoundedfreeP M Fig 6 returns true Proof The correctness Theorem 55 follows immediately theoretical results Sections 3 4 Lemma 53 Example 56 Let P program e b d b c d c h f g h f g f h c b d f c M b c d f g h model P The dependency graph DGP shown Fig 7a Since atoms M nonHCF strongly connected component model checking algorithm Fig 4 use modularity results The situation different algorithm Fig 6 operates follows In PM M b c d f g Then simplify P ﬁrst step compute ﬁxpoint Rω obtain P cid27 αMRω PM MP c b g f b c d c f c b d f g 198 C Koch et al Artiﬁcial Intelligence 151 2003 177212 dependency graph shown Fig 7b DGP cid27 strongly connected components Q1 b c d Q2 f g Q1 HCF unfoundedfree Γ cid27 MQ1 b c b c c d b c d subpQ1 P cid27 d b unsatisﬁable Q2 headcyclefree unfoundedfree Rω Q2 subpQ2P cid27Q2 Thus M stable model P We conclude section remark stable model checking algorithm We use Proposition 310 provides efﬁcient method checking unfoundedfreeness headcyclefree programs checking Rω PM M set algorithm Fig 4 combined modularity results PM MP At ﬁrst glance component dependency graph αMRω contains headcyclefree component M stable model Unfortunately following counterexample shows true general b b Example 57 Let P program d c c M b c d model P We αM P P Rω PM M M One strongly connected components Q b headcyclefree subpQ P b b c Reapplying R operator Q results correct M unique stable model P c d c d Thus computing subcomponents program lead rules breaking apart permit simpliﬁcations RPM operator This shows HCF components reapply R operator algorithm Fig 6 6 Implementation comparisons benchmarks In order test usefulness proposal implemented method DLV DLV 1338 knowledge representation based disjunctive logic programming developed Technische Universität Wien Recent compar isons 133940 shown DLV nowadays stateoftheart implementation disjunctive logic programming The computational engine DLV implements theoretical results achieved 23 Roughly consists main modules Model Generator Model Checker MC The produces stablemodel candidates stability checked We replaced original Model Checker DLV new module implementing results previous sections performed benchmarks compared execution times C Koch et al Artiﬁcial Intelligence 151 2003 177212 199 In addition DLV evaluated GnT 20 extension Smodels 4142 best knowledge publicly available apart DLV supports functionfree disjunctive logic programming stable model semantics In remainder section compare disjunctive stablemodel checking methods considered differences report experiments carried 61 Comparative overview disjunctive stablemodel checking methods In section brieﬂy recall disjunctive stablemodel checking methods consider discuss main differences We tested following systems methods stable model checking labels benchmark ﬁgures Old Checker The DLV original Model Checker algorithm Fig 4 employs modularity results 23 Its strong points efﬁcient evaluation headcyclefree HCF programs 3536 use modular evaluation techniques Indeed HCF programs evaluated polynomial time program HCF inefﬁcient computation limited subprograms HCF polynomial time algorithm applied HCF subprograms Polynomial space single exponential time bounds guaranteed DLVnew This algorithm depicted Fig 6 described Section 52 Here summarize main ideas Given program P model M checked stability implementation transformation Fig 5 generates CNF formula ΓM P submitted satisﬁability checker If SAT checker returns true ΓMP satisﬁable M stable model P ΓMP unsatisﬁable M stable model P For checking satisﬁability ΓM P SATZ 21an efﬁcient implementation DavisPutnam procedure 43customized setting Furthermore stable model checking method enhanced modular evaluation techniques derived combination Lemma 44 modularity results 23 Roughly given P M P ﬁrst simpliﬁed steps 13 Fig 5 resulting program αM P The subprograms αM P evaluated other10 A polynomial time method applied HCF subprograms Old Checker transformation SAT applied nonHCF subprograms GnT The GnT 20 disjunctive extension Smodels 41 42 It included Smodels distribution 44 example4 Once stablemodel candidate M disjunctive program P generated 10 Note subprograms αM P smaller general subprograms P simpliﬁcation process break components 200 C Koch et al Artiﬁcial Intelligence 151 2003 177212 disjunctionfree logic program PM generated P M The stable models PM models P M strictly contained M11 Therefore M stable model P PM stable model The logic program PM evaluated self instance Smodels stable models generated M stable In benchmarks Smodels 226 current version time Recently Smodels 227 released ﬁxes unrelated bug packaging issues veriﬁed affect performance rerun benchmarks Comparing approach DLVnew stable model checking method GnT observe following main differences 1 The method implemented GnT seen dual method approach Indeed PM GnT tries generate directly model M cid27 P M strictly contained M disproving minimality M In contrast CNF formula ΓM P try build nonempty unfounded set X contained M witnesses nonminimality M building explicitly model contained M existence unfounded set X implies M X model P M 2 In GnT stable model check performed logic programming Smodels employ SAT checker ΓM P check stability 3 GnT uses model checking strategy input program Instead syntactic checks adopt specialized algorithms syntactically recognizable classes programs In particular model checker works polynomial time input program headcyclefree 4 To knowledge GnT checks stability model candidate M employ modular evaluation techniques important feature approach use dynamic modular evaluation techniques Section 5 limit inefﬁcient computation components headcyclefree simpliﬁcation applied program The DLVnew method enhances Old Checker following respects In DLVnew hard nonHCF subprograms evaluated calling SAT checker suitable CNF formula ΓMP enumeration possible unfounded sets performed Old Checker DLVnew implements advanced modularity techniques allow ﬁner splitting stability check subtasks general DLVnew deals smaller subprograms thanks dynamic modularity technique 11 Recall PM denotes GelfondLifschitz transformation P wrt M Section 2 C Koch et al Artiﬁcial Intelligence 151 2003 177212 201 62 Benchmark problems data In order generate coNPhard model checking instances evaluate differences model checking techniques needed perform benchmarks cid6P 2 hard problems Finding suitable set hard instances easy experimental works far cid6P 2 complete problems systematic studies single crossover points similar Satisﬁability missing We considered problems benchmarks Quantiﬁed Boolean Formulas 2QBF Strategic Companies STRATCOMP For 2QBF exploit previous works studying hard instances STRATCOMP study instances previously benchmarks appear easy solve pointed 20 single harder instances experimentally considered sidecontribution paper 621 2QBF Our ﬁrst benchmark problem residing second level polynomial hierarchy 2QBF known cid6P 2 complete 45 The problem decide quantiﬁed Boolean formula QBF Φ XY φ X Y disjoint sets propositional variables φ C1 Ck 3DNF formula X Y valid The transformation 2QBF disjunctive logic programming slightly altered form reduction 46 The propositional disjunctive logic program Pφ produced transformation requires 2 X Y 1 propositional predicates dedicated predicate w consists following rules 1 Rules form v v variable v X Y 2 Rules form y w y w variable y Y 3 Rules form w v1 vm vm1 vn conjunction v1 vm vm1 vn φ 4 The rule w The 2QBF formula Φ valid iff PΦ stable model 46 Example 61 The formula Φ xyx y y x translates PΦ x x y y y w y w w x y w y x w PΦ stable model QBF φ valid To check manually simpler verify Φ xy x y valid In disjunctive logic programming unlike SATbased programming programs kept separated data One designs program encoding problem hand 202 C Koch et al Artiﬁcial Intelligence 151 2003 177212 ﬁxed allows solve problem instances provided set facts In benchmarks adhere principle clearly separate encoding problem instance To end create following disjunctive logic program Pqbf T X F X ExistsX T X F X ForallX T X w ForallX F X w ForallX w ConjunctX Y Z Na Nb Nc T X T Y T Z F Na F Nb F Nc T true F false w A 2QBF instance Φ XY φ encoded following set FΦ facts Existsv existential variable v X Forallv universal variable v Y Conjunctx1 x2 x3 y1 y2 y3 conjunct l1 l2 l3 φ li positive atom li xi vi xi true ii li negated atom vi yi vi xi false The 2QBF instance Φ valid Pqbf FΦ stable model We generated different kinds data sets following works presented literature Each data set randomly generated In cases number variables equal number variables X Y conjunct contains universal variables12 In ﬁrst case number clauses equals overall number variables X Y second case suggested Gent Walsh X Y 2 In following refer instances 47 number clauses generated according ﬁrst schema simply QBF generated according second schema QBFGW 622 Strategic companies STRATCOMP This problem introduced 48 context Default Logic It cid6P 2 complete problem business domain The Strategic Companies Problem deﬁned follows A holding owns companies produces goods Moreover companies joint control company Now companies sold constraints All goods produced company sold controlled holding transaction A company strategic belongs strategic set minimal set companies satisfying constraints Using formalism sets expressed following natural program 12 In conjunction second variable ratio constitutes socalled Model A hardness experimentally evaluated 47 C Koch et al Artiﬁcial Intelligence 151 2003 177212 203 strategicC1 strategicC2 strategicC3 strategicC4 produced_byP C1 C2 C3 C4 strategicC controlled_byC C1 C2 C3 C4 strategicC1 strategicC2 strategicC3 strategicC4 Here atom strategicC means C strategic company atom produced_ byP C1 C2 C3 C4 product P produced companies C1 C2 C3 C4 controlled_byC C1 C2 C3 C4 company C jointly controlled companies C1 C2 C3 C4 We released constraints imposed 48 product produced companies company jointly controlled companies producers product controllers company principle numbers increased arbitrarily We experimentally determined releasing constraints allows generate harder instances average The problem determine given company c strategic fact strategicc true stable model program Note problem expressed ﬁxed normal free logic program uniformly collections facts predicates produced_by controlled_by NP cid6P 2 highly unlikely Thus Strategic Companies example relevant problem expressive power disjunctive logic programming needed We generated tests instances n companies 5 cid2 n cid2 170 3n products 10 uniform randomly chosen controlled_by relations company uniform randomly chosen produced_by relations To problem harder considering strategic sets containing ﬁxed companies 1 2 loss generality constraints strategic1 strategic2 623 Results discussion Our experiments run Athlon1200 512 MB main memory FreeBSD 44 GCC 2953 C compiler For problem size generated 50 random instances indicated respective descriptions instance allowed maximum running time 7200 seconds hours In graphs displaying benchmark results line stops problem instance solved maximum allowed time In framework ran series benchmarks In ﬁrst series compared new model checking strategy DLVnew old model checking strategy DLV Old Checker In second series compared DLVnew GnT 624 DLVnew vs Old Checker We Old Checker DLVnew compute ﬁrst stable model program determines solution decision problemsee summed 204 C Koch et al Artiﬁcial Intelligence 151 2003 177212 total time spent model checking13 Thus obtained precise comparison efﬁciency model checking strategies The results experiments comparing DLVnew vs Old Checker displayed Fig 8 The graphs left sides display average 50 instances size time spent model checking graphs right sides display maximum time spent model checking In particular graphs mid ﬁgure refer QBF QBFGW STRATCOMP instances Average Maximum Execution times expressed CPU seconds reported vertical axis horizontal axis displays probleminstance size number propositional variables QBF problems number companies STRATCOMP Note ﬁgures section vertical axis logarithmic scale cut respectively rounded values 001 s The graphs Fig 8 clearly strong impact new strategy efﬁciency model checker DLV DLVnew signiﬁcantly faster Old Checker experiments Both average model checking time maximum model checking time Old Checker higher respective times DLVnew The lines Old Checker stop earlier DLVnew evidencing instance small size solvable DLV original model checking strategy DLV new strategy performs better able solve instances signiﬁcantly larger sizes 625 DLVnew vs GnT In second series experiments compare DLVnew GnT Due completely different model generation strategies systems lead different number stable model candidates stable model checks solve decision problem stable model exists looking stable model consider total execution timesIn words check version DLV implementing model checking techniques proposed paper competitive GnT cid6P 2 complete problems The results displayed graphs Fig 9 way Fig 8 In general DLVnew outperforms GnT benchmark problems However results different experiments On STRATCOMP performance systems basically instance size 115 companies But instancesize 115 size GnT solve 50 instances DLVnew goes solving instances GnT performs relatively ﬁrst kind QBF instances Instead difference GnT DLVnew impressive QBFGW GnT stops size 25 DLVnew solves instances size 1200 employing 17 seconds average 13 Note computation 1 stable model requires m cid1 1 calls Model Checker m 1 number calls models stable C Koch et al Artiﬁcial Intelligence 151 2003 177212 205 Fig 8 DLVnew vs Old Checker Model checking times ﬁrst stable model 206 C Koch et al Artiﬁcial Intelligence 151 2003 177212 Fig 9 DLVnew vs GnT Total running times ﬁrst stable model C Koch et al Artiﬁcial Intelligence 151 2003 177212 207 7 Related work conclusion 71 Further related work There work literature efﬁcient methods stable model checking disjunctive logic programs The work closely related method probably BenEliyahuZohary Palopoli 36 focuses efﬁcient methods minimal model checking14 Based seminal work BenEliyahu Dechter 35 notion head cylcefreeness HCF introduced BenEliyahuZohary Palopoli 36 efﬁcient algorithm compute minimal models headcyclefree theories logic programs use algorithm compute arbitrary stable model stratiﬁed headcyclefree DLP program linear time Our Rω PM M operator extends non stratiﬁed input use Rω PM M possibly simplify problems HCF applying expensive techniques The dynamic modular evaluation techniques employed algorithm check stability condition Section 52 extends 35 36 allows apply efﬁcient model checking procedure programs headcyclefree ini tially simpliﬁed wrt model checked stability There works computational aspects DLP focus stable model checking brieﬂy mention completeness Fernández Minker 49 employ ﬁxpoint characterization evaluate stratiﬁed programs called modeltrees encode ﬁnite families interpretations Another algorithm computing stable models uses bottomup strategy presented Brass Dix 25 Their algorithm ﬁrst computes residual programa program positive literals appear rules bodieswhich equivalent original program stable model semantics Stable models computed simple extension Clarks completion residual program Also Dix Müller implemented semantics disjunctive logic programs based abstract properties 50 procedure applies stratiﬁed programs Stubers bottomup approach 51 ﬁnally works similar DLV GnT employs procedure analogous DavisPutnam 43 case analysis simpliﬁcation Like DLV GnT unlike approaches mentioned Stubers procedure requires polynomial space avoids generation duplicate stable models Instead performing model check model approach performs coNPhard checks backtracking model computation Stuber leaves concrete implementation checks open issue general algorithm require exponential time checking program HCF procedure checking stability polynomial programs Polynomial space complexity crucial requirement logic programming based deductive database systems cf 52 approaches able deal hard input DLV GnT Stubers meet property 14 Recall stable models coincide minimal models positive disjunctive logic programs general disjunctive programs minimal model checking hard task stable model checking 208 C Koch et al Artiﬁcial Intelligence 151 2003 177212 Several approaches implementation answer set programming systems like AS SAT 53 CCALC 54 cmodels 55 DCS 56 DeReS 57 DisLog 58 DisLoP 59 NoMoRe 60 QUIP 61 Smodels 41 XSB 62 including systems scribed evaluated previous section DLVOld Checker 131463 GnT 20 evidently connection paper 72 Summary As evidenced practical examples disjunctive logic programming DLP stable model semantics powerful knowledge representation nonmonotonic reasoning formalism Reasoning DLP harder disjunctionfree logic programs stable model checking deciding given model stable model propositional DLP program coNPcomplete The model checking component essential nonmonotonic reasoning systems following stable model semantics deal cid6P 2 complete problems In paper proposed new efﬁcient transformation ΓM P reduces stable model checking UNSAT The rationale UNSAT prototypical bestresearched coNPcomplete problem By step best specialpurpose algorithms systems UNSAT solve stable model checking problem Thus work allows substantial improvement model checking performance DLP systems This turn signiﬁcant repercussions efﬁciency frontier AI systems cid6P 2 complete problems overall The proposed approach stable model checking implemented DLVa stateoftheart implementation DLP publicly available large number platforms number experiments benchmarks run SATZone best SAT solvers currently availableas engine stable model checking The results experiments positive conﬁrm usefulness techniques As future work plan improve integration model checking reasoning modules DLV particular model generation add model checking heuristics instance want exploit unfounded sets evidenced models violating UNSAT check guide model generation process Many possible heuristics awaiting experimental evaluation aware existing work heuristics cid6P 2 problems Our experiments ﬁrst foray benchmarking cid6P 2 hard problems context DLP We strong need studies crossover points problems STRATCOMP QBF prototypical problem complexity class Although cid6P 2 practically important complexity class characterizes large number nonmonotonic reasoning problems known date In light experimental data provided paper valuable contribution Acknowledgements We thank Wolfgang Faber insightful discussions theoretical issues design implementation DLV We indebted remaining current C Koch et al Artiﬁcial Intelligence 151 2003 177212 209 members DLV team particular Francesco Calimeri Tina DellArmi Thomas Eiter Georg Gottlob Giovambattista Ianni Giuseppe Ielpa Cristinel Mateis Simona Perri Axel Polleres Francesco Scarcello Appendix A The RPM operator Deﬁnition 38 efﬁciently speciﬁcally linear time 36 evaluates stability condition HCF programs usually greatly reduces set possible unfounded sets need checked nonHCF programs In appendix discuss interesting properties operator We ﬁrst deﬁnition RPM simpliﬁed programs αM P simpler intuitive original Deﬁnition A1 Let αM P simpliﬁed version program P described Deﬁnition 43 We deﬁne RαM PM operator follows RαM PM 2BP 2BP X cid24 cid1 X cid16 r αM P cid3 H r cid4 cid3 Br X cid4cid2 Note use setbased notation H r trivial disjunctions type heads course represented single occurrence H r Further assume loss generality trivial disjunctions occur programs Proposition A2 Let P program M model P Then Rω PM M Rω αM PMM Example A3 P b c b M b c αM P b c b In ﬁrst iteration RαM PM b removed In second c deleted Rω PM M Thus M stable model P αM PMM Rω PM M cid16 Rω αM PMM Then expressions r groundP Proof Suppose Rω H r Br false wrt M Br X cid16 H r M cid16 cid16 r αM P Br X H r equivalent The ﬁrst expression rewritten cid16 r groundP H r Br true wrt M Br X H r M We know αM P rule body true wrt PM M M H r M Hence expressions equivalent Rω Rω αM PMM It easy RαM PM operator Deﬁnition A1 converse classical direct consequence operator TP Starting facts αM P TαM P computes atoms M Rω PM M certainly unfounded set αM P Finally note PM M T ω Rω abbreviate Rω αMX PX X Therefore obtain better smaller ﬁxpoint iteratively applying αMXP R operator αM P M Rω PM M X Rω PM M T ω 210 C Koch et al Artiﬁcial Intelligence 151 2003 177212 References 1 C Koch N Leone Stable model checking easy T Dean Ed Proceedings IJCAI99 Stockholm Sweden Morgan Kaufmann San Mateo CA 1999 pp 7075 2 M Gelfond V Lifschitz Classical negation logic programs disjunctive databases New Generation Comput 9 1991 365385 3 TC Przymusinski Stable semantics disjunctive programs New Generation Comput 9 1991 401424 4 C Baral M Gelfond Logic programming knowledge representation J Logic Programming 1920 1994 73148 5 C Baral Knowledge Representation Reasoning Declarative Problem Solving Cambridge University Press Cambridge 2003 6 T Eiter G Gottlob H Mannila Disjunctive datalog ACM Trans Database Syst 22 3 1997 364418 7 G Gottlob Complexity results nonmonotonic logics J Logic Comput 2 3 1992 397425 8 T Eiter G Gottlob The complexity logicbased abduction J ACM 42 1 1995 342 9 T Eiter G Gottlob On complexity propositional knowledge base revision updates counterfac tuals Artiﬁcial Intelligence 57 23 1992 227270 10 H Turner Polynomiallength planning spans polynomial hierarchy S Flesca S Greco G Ianni N Leone Eds Proceedings 8th European Conference Artiﬁcial Intelligence JELIA Lecture Notes Computer Science Vol 2424 Springer Berlin 2002 pp 111124 11 C Baral V Kreinovich R Trejo Computational complexity planning approximate planning presence incompleteness Artiﬁcial Intelligence 122 12 2000 241267 12 E Dantsin T Eiter G Gottlob A Voronkov Complexity expressive power logic programming ACM Comput Surv 33 3 2001 374425 13 T Eiter N Leone C Mateis G Pfeifer F Scarcello The KR dlv Progress report comparisons benchmarks AG Cohn L Schubert SC Shapiro Eds Proceedings Sixth International Conference Principles Knowledge Representation Reasoning KR98 Trento Italy Morgan Kaufmann San Mateo CA 1998 pp 406417 14 T Eiter W Faber N Leone G Pfeifer Declarative problemsolving DLV J Minker Ed LogicBased Artiﬁcial Intelligence Kluwer Academic Dordrecht 2000 pp 79103 15 V Lifschitz Answer set planning DD Schreye Ed Proceedings 16th International Conference Logic Programming ICLP99 Las Cruces NM MIT Press Cambridge MA 1999 pp 2337 16 M Nogueira M Balduccini M Gelfond R Watson M Barry An Aprolog decision support Space Shuttle G Gupta Ed Proceedings 1st International Workshop Practical Aspects Declarative Languages PADL99 Lecture Notes Computer Science Vol 1551 Springer Berlin 1999 pp 169183 17 T Soininen I Niemelä Developing declarative rule language applications product conﬁguration G Gupta Ed Proceedings 1st International Workshop Practical Aspects Declarative Languages PADL99 Lecture Notes Computer Science Vol 1551 Springer Berlin 1999 pp 305 319 18 T Syrjänen A rulebased formal model software conﬁguration Technical Report A55 Digital Systems Laboratory Department Computer Science Helsinki University Technology Espoo Finland 1999 19 K Heljanko I Niemelä Bounded LTL model checking stable models T Eiter W Faber M Truszczynski Eds Proceedings 6th International Conference Logic Programming Nonmonotonic Reasoning LPNMR01 Vienna Austria Lecture Notes Artiﬁcial Intelligence Vol 2173 Springer Berlin 2001 pp 200212 20 T Janhunen I Niemela P Simons JH You Partiality disjunctions stable model semantics AG Cohn F Giunchiglia B Selman Eds Proceedings Seventh International Conference Principles Knowledge Representation Reasoning KR2000 Breckenridge CO Morgan Kaufmann San Mateo CA 2000 pp 411419 21 CM Li Anbulagan Heuristics based unit propagation satisﬁability problems Proceedings IJCAI97 Nagoya Japan 1997 pp 366371 22 J Lobo J Minker A Rajasekar Foundations Disjunctive Logic Programming MIT Press Cambridge MA 1992 C Koch et al Artiﬁcial Intelligence 151 2003 177212 211 23 N Leone P Rullo F Scarcello Disjunctive stable models Unfounded sets ﬁxpoint semantics computation Inform Comput 135 2 1997 69112 24 J Minker On indeﬁnite data bases closed world assumption D Loveland Ed Proceedings 6th Conference Automated Deduction CADE82 Lecture Notes Computer Science Vol 138 Springer New York 1982 pp 292308 25 S Brass J Dix Disjunctive semantics based partial bottomup evaluation L Sterling Ed Proceedings 12th Internat Conf Logic Programming Tokyo MIT Press Cambridge MA 1995 pp 199213 26 T Przymusinski Stationary semantics disjunctive logic programs deductive databases Proceedings North American Conference Logic Programming Austin TX 1990 pp 4062 27 T Przymusinski Static semantics normal disjunctive logic programs Ann Math Artiﬁcial Intelligence 14 1995 323357 28 K Ross The wellfounded semantics disjunctive logic programs W Kim JM Nicolas S Nishio Eds Deductive ObjectOriented Databases Elsevier Science Amsterdam 1990 pp 385402 29 C Sakama Possible model semantics disjunctive databases Proceedings First Internat Conf Deductive ObjectOriented Databases DOOD89 Kyoto Japan NorthHolland Amsterdam 1989 pp 369383 30 K Apt N Bol Logic programming negation A survey J Logic Programming 1920 1994 971 31 J Dix Semantics logic programs Their intuitions formal properties An overview Logic Action Information Proceedings Konstanz Colloquium Logic Information LogIn92 DeGruyter Berlin 1995 pp 241329 32 M Gelfond V Lifschitz The Stable Model Semantics Logic Programming Logic Programming Proceedings Fifth Internat Conference Symposium Seattle WA MIT Press Cambridge MA 1988 pp 10701080 33 N Bidoit C Froidevaux Negation default unstratiﬁable logic programs Theoret Comput Sci 78 1991 85112 34 F Buccafurri N Leone P Rullo Enhancing disjunctive datalog constraints IEEE Trans Knowledge Data Engrg 12 5 2000 845860 35 R BenEliyahu R Dechter Propositional semantics disjunctive logic programs Ann Math Artiﬁcial Intelligence 12 1994 5387 36 R BenEliyahuZohary L Palopoli Reasoning minimal models Efﬁcient algorithms applications Artiﬁcial Intelligence 96 1997 421449 37 V Lifschitz H Turner Splitting logic program P Van Hentenryck Ed Proceedings 11th International Conference Logic Programming ICLP94 Santa Margherita Ligure Italy MIT Press Cambridge MA 1994 pp 2337 38 T Eiter N Leone C Mateis G Pfeifer F Scarcello A deductive nonmonotonic reasoning J Dix U Furbach A Nerode Eds Proceedings 4th International Conference Logic Programming Nonmonotonic Reasoning LPNMR97 Dagstuhl Germany Lecture Notes Artiﬁcial Intelligence Vol 1265 Springer Berlin 1997 pp 363374 39 E Erdem Applications logic programming planning Computational experiments unpublished draft httpwwwcsutexaseduusersesrapapershtml 1999 40 P Nicolas New generation systems nonmonotonic reasoning Presentation LPNMR01 Vienna Austria September 2001 41 I Niemelä P Simons T Syrjänen Smodels A answer set programming C Baral M Truszczynski Eds Proceedings 8th International Workshop Nonmonotonic Reasoning NMR2000 Breckenridge CO 2000 42 I Niemelä P Simons SmodelsAn implementation stable model wellfounded semantics normal logic programs J Dix U Furbach A Nerode Eds Proceedings 4th International Conference Logic Programming Nonmonotonic Reasoning LPNMR97 Dagstuhl Germany Lecture Notes Artiﬁcial Intelligence Vol 1265 Springer Berlin 1997 pp 420429 43 M Davis H Putnam A computing procedure quantiﬁcation theory J ACM 7 1960 201215 44 P Simons Smodels homepage httpwwwtcshutﬁSoftwaresmodels 1999 45 CH Papadimitriou Computational Complexity AddisonWesley Reading MA 1994 212 C Koch et al Artiﬁcial Intelligence 151 2003 177212 46 T Eiter G Gottlob On computational cost disjunctive logic programming Propositional case Ann Math Artiﬁcial Intelligence 15 34 1995 289323 47 I Gent T Walsh Beyond NP The QSAT phase transition Proceedings AAAI99 Orlando FL 1999 pp 648653 48 M Cadoli T Eiter G Gottlob Default logic query language IEEE Trans Knowledge Data Engrg 9 3 1997 448463 49 J Fernández J Minker Bottomup computation perfect models disjunctive theories J Logic Programming 25 1 1995 3351 50 J Dix M Müller Implementing semantics disjunctive logic programs fringes abstract properties LM Pereira A Nerode Eds Proceedings Second International Workshop Logic Programming Nonmonotonic Reasoning LPNMR93 Lisbon Portugal MIT Press Cambridge MA 1993 pp 4359 51 J Stuber Computing stable models program transformation P Van Hentenryck Ed Proceedings 11th Internat Conference Logic Programming Santa Margherita Ligure Italy MIT Press Cambridge MA 1994 pp 5873 52 I Niemelä P Simons Efﬁcient implementation wellfounded stable model semantics MJ Maher Ed Proceedings 1996 Joint International Conference Symposium Logic Programming ICLP96 Bonn Germany MIT Press Cambridge MA 1996 pp 289303 53 F Lin Y Zhao ASSAT Computing answer sets logic program SAT solvers Proceedings AAAI02 Edmonton AB AAAI PressMIT Press Cambridge MA 2002 p 112 54 N McCain H Turner Satisﬁability planning causal theories AG Cohn L Schubert SC Shapiro Eds Proceedings Sixth International Conference Principles Knowledge Representation Reasoning KR98 Trento Italy Morgan Kaufmann San Mateo CA 1998 pp 212223 55 Y Babovich Cmodels homepage httpwwwcsutexaseduuserstagcmodelshtml 2002 56 D East M Truszczynski dcs An implementation DATALOG constraints C Baral M Truszczynski Eds Proceedings 8th International Workshop NonMonotonic Reasoning NMR2000 Breckenridge CO 2000 57 P Cholewinski VW Marek M Truszczynski Default reasoning DeReS Proceedings International Conference Principles Knowledge Representation Reasoning KR96 Cambridge MA Morgan Kaufmann San Mateo CA 1996 pp 518528 58 D Seipel H Thöne DisLogA reasoning disjunctive deductive databases A Olivé Ed Proceedings International Workshop Deductive Approach Information Systems Databases DAISD94 Universitat Politecnica Catalunya UPC 1994 pp 325343 59 C Aravindan J Dix I Niemelä DisLoP A research project disjunctive logic programming AI CommunicationsThe European Journal Artiﬁcial Intelligence 10 34 1997 151165 60 C Anger K Konczak T Linke NoMoRe A nonmonotonic reasoning T Eiter W Faber M Truszczynski Eds Proceedings 6th International Conference Logic Programming Nonmonotonic Reasoning LPNMR01 Vienna Austria Lecture Notes Artiﬁcial Intelligence Vol 2173 Springer Berlin 2001 pp 406410 61 U Egly T Eiter H Tompits S Woltran Solving advanced reasoning tasks quantiﬁed Boolean formulas Proceedings AAAI00 Austin TX AAAI PressMIT Press Cambridge MA 2000 pp 417422 62 P Rao KF Sagonas T Swift DS Warren J Freire XSB A efﬁciently computing wellfounded semantics J Dix U Furbach A Nerode Eds Proceedings 4th International Conference Logic Programming NonMonotonic Reasoning LPNMR97 Dagstuhl Germany Lecture Notes Artiﬁcial Intelligence Vol 1265 Springer Berlin 1997 pp 217 63 N Leone C Pizzuti P Rullo Efﬁcient evaluation class ordered logic programs Data Knowledge Engineering 23 2 1997 185213