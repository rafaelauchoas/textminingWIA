Artiﬁcial Intelligence 250 2017 5879 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint A progression semantics ﬁrstorder logic programs Yi Zhou ab School Computing Engineering Mathematics Western Sydney University Sydney Australia b School Computer Science Technology TianJin University TianJin China c School Computer Science Technology Huazhong University Science Technology Wuhan China Yan Zhang ac r t c l e n f o b s t r c t Article history Received 21 August 2015 Received revised form 19 May 2017 Accepted 6 June 2017 Available online 9 June 2017 Keywords Logic programming Stable model Progression Firstorder 1 Introduction In paper propose progression semantics ﬁrstorder normal logic programs equivalent wellknown stable model answer set semantics The progressional deﬁnition sheds new insights Answer Set Programming ASP instance relationships Datalog FirstOrder Logic FOL Satisﬁability Modulo Theories SMT As example extend notion boundedness Datalog ASP coincides notions recursionfreeness loopfreeness program equivalence In addition prove boundedness precisely captures ﬁrstorder deﬁnability normal logic programs arbitrary structures Finally progressional deﬁnition suggests alternative translation ASP SMT yields new way implementing ﬁrstorder ASP 2017 Elsevier BV All rights reserved Answer Set Programming ASP emerged predominant approach nonmonotonic reasoning area knowledge representation reasoning simplicity expressive power computational advantage 6203334 At beginning stable model answer set semantics ﬁrstorder logic programs deﬁned Herbrand Struc tures grounding propositional programs 2122 In recent years number approaches developed release restriction directly deﬁning stable model semantics arbitrary structures 4571015182426283136 384042 A typical approach research line use translation host language secondorder language 18 circumscription 31 For purpose secondorder inevitable class stable models logic programs transitive closure captured ﬁrstorder logic 16 Under backdrop ﬁrstorder logic pro gram cid2 transformed corresponding secondorder sentence S Mcid2 stable models cid2 deﬁned models S Mcid2 18 While deﬁnition provides precise mathematical representation generalizes tradi tional propositional ASP reveal information expressiveness ﬁrstorder answer set programming For instance unclear provide complete characterization ﬁrstorder deﬁnability ﬁrstorder ASP In paper propose progressional deﬁnition ﬁrstorder normal logic programs Intuitively deﬁnition viewed generalization GelfondLifschitz transformation 6 ﬁrstorder case generalization progression semantics Datalog 132 Also shares fundamental ideas Reiters semantics default Corresponding author Email address yzhouscmuwseduau Y Zhou httpdxdoiorg101016jartint201706001 00043702 2017 Elsevier BV All rights reserved Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 59 logic 37 Simply progressional deﬁnition ﬁrstorder structure M stable model ﬁrstorder normal logic program cid2 ﬁxed point progression cid2 respect M More precisely M coincides structure obtained recursively applying rules cid2 negative parts ﬁxed M We normal logic programs progressional deﬁnition equivalent general stable model semantics deﬁned S Mcid2 The progressional deﬁnition sheds new insights Answer Set Programming ASP instance relationships Datalog FirstOrder Logic FOL Satisﬁability Modulo Theories SMT It evident progressional deﬁnition Datalog exactly monotonic counterpart ASP important Datalog techniques ap plied ASP Based proposed progressional deﬁnition able deﬁne notion boundedness ﬁrstorder answer set programs critical understanding relationship ﬁrstorder ASP classical ﬁrstorder logic With features iterative nonmonotonic reasoning ASP representative rulebased formalism signiﬁ cantly different classical logics Nevertheless ASP classical logics closely related Hence relationships attracted lot attention literature 45121417252639 Among central topic ﬁrstorder deﬁnability kind answer set programs captured classical ﬁrstorder logic sense answer setsstable models exactly classical models ﬁrstorder sentence Our notion boundedness provides complete answer We prove answer set program ﬁrstorder deﬁnable bounded Moreover notion boundednessﬁrstorder deﬁnability equivalent important syntactic notions recursionfreeness loopfreeness tightness program equivalence We believe results aspect establish foundation study expressiveness related properties ﬁrstorder ASP The progressional deﬁnition theoretical practical relevance directly yields new translation ﬁrstorder ASP Satisﬁability Modulo Theories SMT Comparing translation obtained ordered completion 45 logically stronger models This paper organized follows Section 2 introduces necessary backgrounds Section 3 proposes progressional deﬁnition shows equivalent translational deﬁnition Then Section 4 extends notion boundedness Datalog ASP shows equivalent notions recursionfreeness loopfreeness program equivalence Section 5 shows boundedness exactly captures ﬁrstorder deﬁnability ASP Section 6 reports natural translation ﬁrstorder ASP SMT based progressional deﬁnition Finally Section 7 discusses related ongoing works Section 8 concludes paper respectively 2 Preliminaries A We start necessary logical notions notations We consider secondorder language function symbols equality A vocabulary τ set consists relation symbols predicates including equality symbol constant symbols constants Each predicate associated natural number called arity Given vocabulary term atom substitution ﬁrstorder secondorder formula ﬁrstorder secondorder sentence deﬁned usual In particular atom called equality atom form t1 t2 t1 t2 terms Otherwise called proper atom A structure A vocabulary τ τ structure tuple A A c called domain A c A kary predicate P j τ P ﬁnite set In paper consider ﬁnite inﬁnite structures A A 1 P n A nonempty set A 1 j n kary relation 1 m element A constant ci τ P j called interpretation P j A A structure ﬁnite domain A 1 c A m P x atom η assignment structure A For convenience write P Let A structure τ An assignment A function η set variables A An assignment c arbitrary constant x η A fact The satisfaction relation structure A formula φ associated assignment η denoted x set free variables occurring formula φ Then satisfaction relation convenience tuple elements A In particular φ sentence satisfaction relation independent P predicate denote extended corresponding function set terms A mapping ηc c Let P x P η A φη deﬁned usual Let independent assignment variables assignment In case simply write A φ short A ground atom A form P tuple elements matches arity P For convenience use P P x In case write A φ A A P x A j A A A Given structure A τ Q predicate τ ground atoms Q a1 denote new structure τ obtained A expanding interpretation predicate Q A Q Q A Let A1 A2 structures τ sharing domain constant c τ c A2 By A1 A2 A2 By A1 A2 mean A1 A2 A2 A1 We simply mean predicate P τ P write A1 A2 denote structure τ domain A1 A2 A1 A2s domain constant c interpreted way A1 A2 predicate P τ P A1A2 P A1 P A1 P A1 c A2 a1 Q n use A Q a1 Q A 60 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 21 Firstorder normal logic program A rule r following form α β1 βm γ1 γl 1 α proper atom βi 0 m γ j 0 j l atoms We α head r denoted Headr β1 βm positive body r denoted P osr γ1 γl negative body r denoted Negr In addition use Bodyr denote P osr Negr A normal logic program program short ﬁnite set rules Given program cid2 predicates occur heads rules cid2 said intensional predicates said extensional1 For given program cid2 use τ cid2 denote vocabulary cid2 τextcid2 denote extensional predicates cid2 constants cid2 τintcid2 denote intensional predicates cid2 Clearly τ cid2 τextcid2 τintcid2 In addition τint cid2 contains constant We use cid9cid2 denote set intensional predicates cid2 Although cid9cid2 τintcid2 use notations difference denotes set predicates whilst presents vocabulary Let M structure r rule form 1 η assignment We M satisﬁes positive body r t η M satisﬁes negative η P osr written M P osrη atoms P t η M satisﬁes body r η Negr written M Negrη atoms P body r η Bodyr written M Bodyrη M P osrη M Negrη ﬁnally M satisﬁes rule r η written M rη M Headrη M Bodyrη t Negr M cid10 P t P osr M P 22 The translational stable model deﬁnition Let cid2 program cid9cid2 set intensional predicates cid2 We introduce cid9 cid2 new set cid2 arity predicate Q cid9cid2 Let r rule cid2 Q 1 Q n cid9 predicates corresponding cid9cid2 Q form α β1 βm γ1 γl cid2r denote universal closure following formula cid2Bodyr α cid2Bodyr conjunction elements Bodyr replacing occurrence By r cid2Bodyr β1 βm γ1 γl denote universal closure following formula γ1 γl α x β m x α Q 1 α Q β β 1 m cid3 Q βi j t j βi Q j t j Q j cid9cid2 By cid2cid2 denote ﬁrstorder sentence logic program By S Mcid2 denote following secondorder sentence ˆr cid2 rcid2 denote ﬁrstorder sentence cid4 cid4 rcid2 r Let cid2 normal cid2cid2 cid9 cid2 cid9cid2 cid2 cid2cid9 cid9 cid2 cid9cid2 abbreviation formula cid5 x Q x Q x x Q cid5 x Q x 1in 1in Deﬁnition 1 Translational stable model Let cid2 program A τ cid2structure We A stable model answer set cid2 A model S Mcid2 1 Here follow notions Datalog distinguish intensional extensional predicates According deﬁnition predicates deﬁned sets facts program considered intensional Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 61 We refer deﬁnition translational deﬁnition For convenience use A Scid2 denote collection stable models cid2 Two programs said equivalent set stable models This deﬁnition originated Lin Shohams work translate normal logic programs answer setstable model semantics circumscription second order sentence 29 Later number approaches proposed generalize work translating richer forms logic programs fragments secondorder logic 81828313642 Restricted normal logic programs translations essentially equivalent 23 Clarks completion ordered completion Answer Set Programming rulebased formalism dealing iterative reasoning recursion nonmonotonic reasoning signiﬁcantly different classical ﬁrstorder logic However types formalisms closely related The relationships answer set programming classical logics central topics area origin attracted attention literature 45121417252639 Among inﬂuential work completion approaches 14 intend use ﬁrstorder sentences directly capture stable model answer set semantics logic programs Deﬁnition 2 Clarks completion Let cid2 program Clarks Completion completion short clear context cid2 denoted Compcid2 following ﬁrstorder sentence cid5 x P x P τint cid2 cid6 1ik yi cid2Bodyi 2 x Body1 P tuple body variables P P yi cid2Bodyi conjunction elements Bodyi simultaneously replacing occurrences x Bodyk rules heads mention predicate P x Bodyi It shown stable model program cid2 classical model completion Compcid2 However converse hold general In sense Clarks completion fails capture stable model semantics The gap bridged recently The loop formula approach 122630 showed socalled loop formulas Clarks completion exactly capture stable model semantics That ﬁnite structure stable model program classical model programs Clarks completion loop formulas Nevertheless ﬁrstorder case inﬁnite number loop formulas In contrast ordered completion approach 45 introduces extra comparison predicates track derivation order stable models exactly captured ordered completion modiﬁed version Clarks completion Deﬁnition 3 Ordered completion Let cid2 program Ordered completion cid2 denoted O Ccid2 set following sentences For intensional predicate P following sentences cid6 x yi cid2Bodyi P x 1ik x x P cid6 yi cid2Bodyi cid5 1ik Q P z P osi Q cid9cid2 Q z x P Q x z 3 4 basic notations borrowed Deﬁnition 2 P o si positive Bodyi Q Q P P Q new predicate Q P equal P x z ranges intensional atoms positive Bodyi z x intuitively means evaluation time Q z triple intensional predicates P Q R following sentence cid5 x P Q Rcid9cid2 y z P Q x y Q R y z P R x z 5 62 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 The following theorem states stable models normal program correspond classical models ordered completion ﬁnite structures Proposition 1 Theorem 1 4 Let cid2 program Then ﬁnite τ cid2structure stable model cid2 expanded model O Ccid2 One eliminate transitive formulas formula 5 Satisﬁability Modulo Theories SMT precisely ﬁrstorder logic augmented background theory comparison operator integers For predicate P introduce integer predicate n P arity Then SMT version ordered completion cid15cid2 conjunction formula 3 formula 4 second line formula 4 written O C cid5 Q P z P osiQ cid9cid2 Q z x P Q x z replaced cid5 z n P x n Q z P osiQ cid9cid2 Q In SMT version ordered completion need formula 5 implied nature builtin comparison operator 24 The progression semantics Datalog A program called Datalog program predicate occurred negative rule program extensional That negative parts rules program mention intensional predicate values ﬁxed The semantics Datalog programs usually deﬁned progressional style follows Deﬁnition 4 Datalog evaluation stage Let cid2 Datalog program D structure τextcid2 called extensional database Let cid9cid2 Q 1 Q n set intensional predicates cid2 The tth simultaneous evaluation stage cid2 denoted Q t deﬁned inductively follows 1 Q t n 1 n Q 0 1 n Q k1 Q k cid3Bodyη D Q k 1 Q k n Headrη exists rule r Q x Body cid2 assignment η The underlying intuition Deﬁnition 4 clear The evaluation stage Datalog program deﬁned step bystep At beginning interpretations intensional predicates set At stage k value intensional predicate Q Q k1 values computed stage Datalog program cid2 More precisely Q k1 heads applicable rules associated Q stage k rule cid2 associated Q head mentions Q applicable stage k body satisﬁed current evaluation D Q k 1 Clearly Q sequence Q 0 Q 1 expanded previous Q k expanded Q k monotonic sense Q k Q k n k Hence Q k Q k1 convergence exists ﬁnite structures Deﬁnition 5 Intended value Let cid2 Datalog program D structure τext cid2 Let Q cid9cid2 intensional predicate The intended value Q D cid2 denoted Q cid2 D cid7 Q j 0 j Notice Deﬁnition 5 extended structures D arbitrary cardinality transﬁnite iteration For arbitrary cardinal number cid10 deﬁne cid8 Q cid10 Q ξ n ξ ξ cid10 Q cid3Bodyη Headrη exists rule r Q x Body cid2 assignment η D Q ξ 1 Again ﬁxed point exists called intended value Nevertheless simplicity clarity mainly use notion evaluation stage proposed Deﬁnition 5 stated This affect major conclusions drawn paper Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 63 3 A progression deﬁnition normal logic programs In section propose progressional deﬁnition ﬁrstorder normal logic programs equivalent translational stable model deﬁnition 31 The progressional deﬁnition First deﬁne evaluation stage normal logic programs respect structure Deﬁnition 6 Evaluation stage Let cid2 normal program cid9cid2 Q 1 Q n set intensional predicates cid2 Consider structure M τ cid2 The tth simultaneous evaluation stage cid2 respect M denoted Mtcid2 structure τ cid2 deﬁned inductively follows M0cid2 Mτextcid2 Eτint cid2 Mτextcid2 restriction2 M τextcid2 Eτint cid2 structure deﬁned x β1 βm γ1 γl cid2 assignment η Mk1cid2 Mkcid2 Headrη exists r Q τintcid2 interpretations predicates 1 m βiη Mkcid2 j 1 j l γ jη M Although Deﬁnition 6 looks little complicated underlying idea simple At step expand struc ture adding heads rules applicable Here rule r applicable step k P osr satisﬁed Mkcid2 Negr satisﬁed M Let closer look Deﬁnition 6 Clearly M0cid2 takes extensional relations initial input relations corresponding intensional predicates τint cid2 set Then Mt1cid2 obtained Mt cid2 adding derivable intensional values Mt cid2 ﬁxing M Here intensional value derivable Mt cid2 ﬁxing M exists rule applying assignment head exactly intensional value positive body derived Mt cid2 negative body consistent M It important emphasize Deﬁnition 6 negative ﬁxed M original structure Mt cid2 tth evaluation stage For intensional predicate Q cid9cid2 use Q icid2 M denote Q Mi cid2 simplicity Then easy sequence Q 0cid2 M Q 1cid2 M Q 2cid2 M increases Q jcid2 M Q icid2 M j cid2 M So convergence sequence Q 0cid2 M Q 1cid2 M Q 2cid2 M exists We Q cid8 1 j Q jcid2 M intended value Q M cid2 Consequently convergence sequence M0cid2 M1cid2 M2cid2 exists cid7 M cid2 M jcid2 0 j If Q a1 Mcid2 Q a1 link M respect cid2 In addition evaluation time Q a1 M respect cid2 number t Q a1 Mtcid2 In particular Q a1 link M treat evaluation time Q a1 Similarly Datalog Deﬁnition 6 extended structures arbitrary cardinality transﬁnite iteration For simplicity clarity mainly use notion notations Deﬁnition 6 Again affect major conclusions drawn paper Based deﬁnition evaluation stage able characterize stable model semantics ﬁrstorder normal logic programs progressional deﬁnition similar Datalog Deﬁnition 7 Progressional stable model Let cid2 normal program M structure τ cid2 M called progressional stable model cid2 iff Mcid2 M We deﬁnition progressional deﬁnition Intuitively structure M progressional stable model program cid2 iff ﬁxed point progression cid2 respect M More precisely M coincides structure obtained recursively applying rules cid2 negative parts ﬁxed M Example 1 Consider following program cid2G Go Shoppingx y F riendsx y Go Shoppingx y Go Shoppingx z Likesz y Hatex y 2 Let σ σ1 signatures σ σ1 M structure σ1 The restriction M σ denoted Mσ σ structure constant c σ predicate P σ c Mσ P Mσ c P M M 64 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 Note Go Shopping intensional predicate program cid2G We consider ﬁnite structure M DomM alice carol jane sue F riends M alice carol jane sue Likes Hate M carol sue M alice jane jane alice Go Shopping M alice carol jane sue alice sue Then Deﬁnition 6 obtain following sequence Go Shopping0cid2G M Go Shopping1cid2G M alice carol jane sue Go Shopping2cid2G M alice carol jane sue alice sue Go Shopping3cid2G M Go Shopping2cid2G M So Go Shopping stable model cid2G cid2 cid2G M alice carol jane sue alice sue From Deﬁnition 7 M progressional The progressional deﬁnition answer set programs viewed generalization GelfondLifschitz trans formation 2122 ﬁrstorder case First guess ﬁrstorder structure M Then evaluate intended values intensional predicates respect candidate structure Finally intended values ones speciﬁed candidate structure M M progressional stable model answer set underlying program On hand progressional deﬁnition normal programs viewed extension progressional deﬁnition Datalog 1 From syntactic point view Datalog program special case normal program negative bodies mention intensional predicate To address difference semantically needs handle oc currences intensional predicates negative bodies For purpose use techniques First guess candidate structure signature program instead structure extensional signature extensional database start progression Second ﬁx negative parts program guessed struc ture In sense evaluation process progression follows similarly Datalog Finally guessed structure considered progressional stable model coincides structure obtained progression Our progressional deﬁnition shares fundamental ideas Reiters semantics default logic 37 Recall Reiters deﬁnition extensions First candidate theory T guessed iterative process applied compute result cid13T applying default rules respect guessed theory T negative parts default rules ﬁxed T ﬁnally T extension coincides cid13T Nevertheless differences First Reiters default logic guess theory progress deﬁnition guess ﬁrstorder structure Also Reiters semantics essentially propositional applied closed ﬁrstorder logic requires closure property 32 Progressional stable models translational stable models We progressional deﬁnition Deﬁnition 7 equivalent translational deﬁnition Deﬁnition 1 Theorem 1 Let cid2 program M structure τ cid2 Then M model S Mcid2 iff Mcid2 M Proof In order prove theorem introduce alternative equivalent deﬁnition equivalent progressional deﬁnition translational deﬁnition described Let cid2 program M structure τ cid2 We M justiﬁed stable model cid2 iff 1 assignment η rule r form 1 cid2 1 m βiη M j 1 j l γ jη M αη M 2 exist structure Mcid15 τ cid2 DomMcid15 DomM b constant c τ cid2 c Mcid15 P c P τextcid2 P Mcid15 Q d Q τintcid2 Q e assignment η rule r form 1 cid2 1 m βiη Mcid15 Mcid15 c M Q τintcid2 Q Mcid15 Q M M M γ jη M αη Mcid15 j 1 j l Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 65 n M M cid9 cid9 cid2cid9 Mcid15 c M Q Mcid15 Q 3 P τextcid2 P Then diﬃcult observe Mcid15 s corresponding predicate cid9cid2 Hence M cid9 cid2 cid9cid2 cid2 We construct Mcid15 We ﬁrst deﬁnition equivalent translational deﬁnition It diﬃcult verify Condition 1 cid2 cid9cid2 cid2 Suppose exists Q corresponding cid9cid2 Q 1 Q n Therefore M cid9 cid9 according Condition 2d speciﬁed cid2 Q Q cid2 cid9cid2 cid2 On hand suppose way 1 DomMcid15 DomM 2 4 Q cid9cid2 corresponding holds iff M cid2cid2 Now prove Condition 2 hold iff M cid9 cid2cid9 construct n new relations M predicates cid9 Mcid15 1 Q cid2 Mcid15 cid2 corresponding Q cid9cid2 Q Q In addition Condition 2e easy M satisﬁes cid2 Q Q M cid9 cid2cid9 constant c τ cid2 c cid2 Q Q cid9 Now deﬁnition equivalent progressional deﬁnition Suppose Mcid2 M Then Condition 1 holds Otherwise exists assignment η rule r 1 m βiη M j 1 j l γ jη M αη M Since βiη Mcid2 exists bound k 1 m βiη Mkcid2 Then αη Mk1cid2 deﬁnition This means αη Mcid2 Therefore αη M contradiction In addition Condition 2 hold Otherwise let assume exists Mcid15 By induction evaluation stage t shown t Mt cid2 Mcid15 Hence Mcid2 Mcid15 M contradiction On hand suppose structure M satisﬁes Conditions 1 2 Then shown Mt cid2 M induction evaluation stage t Condition 1 Hence Mcid2 M Now M τ cid2 following way DomMcid15 DomM Mcid2 Otherwise Mcid2 M We construct structure Mcid15 Mcid15 c M M constant c τ cid2 c intensional Mcid2 So Mcid15 Mcid15 Q satisﬁes Conditions 2ae contradiction Hence Mcid2 M cid2 predicate Q cid9cid2 Q extensional predicate P τextcid2 P Therefore Mcid2 Mcid15 satisﬁes Conditions 2ce Mcid15 P M Q Mcid15 P Mcid15 M 4 Boundedness recursionfreeness loopfreeness The progressional deﬁnition normal logic programs natural extension Datalog programs As discussed previous section important understanding deep long neglected connections ASP Datalog More interestingly deﬁnition able consider important notions techniques originated Datalog ﬁrstorder answer set programming Among fundamental notion boundedness Roughly speaking Datalog program bounded exists natural number k evaluation stage program ended k steps Boundedness key notions Datalog study expressive power Datalog classical ﬁrstorder logic 2 With progressional deﬁnition able deﬁne boundedness notion ﬁrstorder ASP Certainly basic idea similar require evaluation normal program bounded ﬁxed number However shall section deﬁnition straightforward progression normal program relative candidate structure Boundedness plays important role ﬁrstorder ASP In section shall actually equivalent syntactic notions recursionfreeness loopfreeness program equivalence Roughly speaking recursion free programs programs recursions positive bodies rules program contain intensional predicate loopfree programs called tight program literature 17 programs loops 1230 In section use boundedness key tool study expressive power ﬁrstorder ASP particular relationships classical ﬁrstorder logic 41 Boundedness normal logic programs We ﬁrst review notion boundedness Datalog attracted attention area deductive databases 132 Deﬁnition 8 Datalog boundedness A Datalog program cid2 bounded exists natural number k Q k intensional extensional database D evaluation stage cid2 D bounded k steps Q predicates Q cid2 The boundedness notion extended ﬁrstorder answer set programming based progressional deﬁnition normal logic programs Deﬁnition 7 Deﬁnition 9 Boundedness A program cid2 bounded exists natural number k intensional pred cid2 M Q kcid2 M equivalently Mcid2 Mkcid2 In case icates Q cid2 stable models M cid2 Q k called bound cid2 cid2 called kbounded program Deﬁnition 9 saying stable models M exists natural number k Mcid2 Mkcid2 It important note similar boundedness notion Datalog Deﬁnition 8 66 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 ﬁxed constant k applies stable models k independent speciﬁc structures stable models How difference boundedness ASP Datalog takes stable models τ cid2structures account Hence kbounded program cid2 exist τ cid2structure M Mcid2 cid10 Mkcid2 M stable model cid2 Boundedness semantic notion sense deﬁnition depending progressional deﬁnition It intends capture certain subclass programs progressions restricted Example 2 Consider following program cid2V V isitsx y Interestedx y Busyx V isitsx y V isitsz y Attraction y Busyx 6 In program cid2V V isits intensional predicate According Deﬁnition 6 easy verify stable model M cid2V evaluation time intended values V isits 2 In words program cid2V 2bounded program cid2 Nevertheless let cid2V cid15 program obtained cid2V replacing rule 6 following V isitsx y V isitsz y Interestedx z Busyx Then cid2V cid15 Interested exist number k Mcid2V cid15 Mkcid2V cid15 M ai ai1 0 V isits unbounded One construct structure M inﬁnite domain a0 a1 Busy M M ai j j It veriﬁed M stable model cid2V cid15 Clearly boundedness notion normal programs extension Datalog programs Proposition 2 Let cid2 Datalog program Then cid2 bounded Deﬁnition 9 iff bounded Deﬁnition 8 As consequence results Datalog literature directly applied context ASP Corollary 3 Checking boundedness normal logic programs undecidable Proof This assertion follows directly Proposition 2 result checking boundedness Datalog programs undecidable Theorem 25 19 cid2 42 Recursionfreeness loopfreeness Now introduce syntactic notions ﬁrstorder normal programs recursionfreeness loopfreeness characterize expressiveness ﬁrstorder answer set programs syntactic point view Recursionfreeness important notion Datalog wellstudied Datalog community 1232 It lifted ﬁrstorder normal programs follows Deﬁnition 10 Recursionfreeness A program said recursionfree intensional predicate occurs positive body rule program Note possible intensional predicates occur negatively recursionfree program Example 3 Consider following program cid2V P V isitsx y Interestedx y PossVisitx y Attraction y V isitsx y There intensional predicates V isits PossVisit program cid2V P Since positively occurs bodies rules cid2V P recursionfree program cid2 It generally considered recursion important features Datalog normal logic programs Hence recursionfree programs considered trivial programs extent According deﬁnitions easy following result holds Proposition 4 If cid2 recursionfree program Mcid2 M1cid2 structure M τ cid2 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 67 Proposition 4 states recursionfree programs stable models program veriﬁed step It immediately follows recursionfree programs bounded Corollary 5 Recursionfree programs bounded A closely related notion loopfreeness3 For purpose ﬁrst review concepts loops ﬁrstorder normal programs 12 Let cid2 program The positive dependency graph cid2 denoted Gcid2 graph maybe inﬁnite V E V set atoms τint cid2 α β edge E exists rule r cid2 αcid15 r αcid15 positive atoms intensional predicate body r b exists substitution θ αcid15θ α βcid15θ β A ﬁnite nonempty subset L V said loop cid2 exists cycle Gcid2 goes nodes L head r βcid15 βcid15 Loops corresponding loop formulas critical concepts answer set programming As shown 12 stable model semantics logic program captured completion loop formulas ﬁnite structures Also initiates alternative way compute stable models program transforming propositional formulas 30 Deﬁnition 11 Loopfreeness A program said loopfree loop The stable models loopfree program exactly captured Clarks completion 1217 Proposition 6 12 Let cid2 loopfree program Then τ cid2structure M stable model cid2 iff model Compcid2 Example 4 Consider programs cid2V cid2V P Examples 2 3 respectively It easy cid2V loop L V isitsx y V isitsz y So cid2V loopfree On hand program cid2V P Example 3 loopfree obviously cid2 Clearly recursionfree programs loopfree positive dependency graphs edge Proposition 7 A recursionfree program loopfree However converse Proposition 7 hold general For example following program V isitsx y F riendsx y F riendsx y Likesx y Hatex y loopfree recursionfree 43 On relationships boundedness recursionfreeness loopfreeness In subsection shall syntactic notions recursionfreeness loopfreeness closely related semantic notion boundedness More precisely notions coincide program equivalence program bounded equivalent recursionfree program equivalent loopfree program Some straightforward observations presented earlier Corollary 5 Proposition 7 Corollary 5 states recursionfree programs bounded We extend following result Proposition 8 A loopfree program bounded We leave proof Appendix Proposition 8 extension Corollary 5 recursionfree programs loopfree Proposition 7 Now consider way bounded program converted recursion freeloopfree program First following example shows exists bounded program recursionfree loopfree 3 Loopfree called tight literature 17 particularly propositional case We loopfree order compare notion recursionfree 68 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 Example 5 Let cid2 f lag following program Reacha Reachx Reach y Edgex y f lag Reachx Reachx f lag f lag 7 Clearly cid2 f lag recursionfree program positive body rule 7 mentions intensional predicate Reach It loopfree program rule 7 forms loops However cid2 f lag bounded program The reason recursion rule rule 7 guarded 0ary intensional predicate f lag As f lag generated progression rule triggered Thus syntactic recursion rule 7 actually blocked semantically It easy program cid2 f lag equivalently transformed recursionfree simply deleting rule 7 rule f lag f lag In sense cid2 f lag semantically recursionfree extent The following proposition conﬁrms kind semantical recursionfreeness implied boundedness Proposition 9 If program bounded equivalent recursionfree program As proof Proposition 9 little tedious similar result Datalog programs holds straightforwardly We leave appendix It immediately follows Proposition 9 Proposition 7 bounded program equivalently transformed loopfree program Corollary 10 If program bounded equivalent loopfree program From Corollary 5 Proposition 7 Proposition 8 Proposition 9 Corollary 10 notions bounded ness recursionfreeness loopfreeness highly connected However results justify claim beginning subsection boundedness recursionfreeness loopfreeness coincide program equivalence The missing assertion program equivalent recursionfree loopfree program necessar ily recursionfree loopfree bounded The answer yes shall prove Section 5 Nevertheless purpose tools techniques needed Notice proofs provided section independent cardinality particular structure Hence main results proved section hold arbitrary structures ﬁnite structures 5 Firstorder deﬁnability answer set programs boundedness The relationship ﬁrstorder ASP FOL important topics area wellstudied literature 45121417252639 Researches direction mainly focused translating subclasses ﬁrstorder ASP classical FOL This FOL wellestablished formalism translations ASP FOL helpful understand essential properties Also normal logic programming fragment ﬁrstorder logic programming For instance lacks support disjunctive heads existential quantiﬁers Hence makes little sense translate version classical logic fragment logic programming Interestingly recent works proposed translate fragments FOL description logics fragments ASP normal logic programs enhanced existential quantiﬁers heads largely driven need rulebased reasoning defeasible reasoning ontology engineering 23 For problem translating ﬁrstorder normal logic programs stable model semantics classical ﬁrst order logic complete answer provided Asuncion et al 4 based previous results literature Table 2 4 Interestingly surprisingly answer depending factors considering arbitrary structures ﬁnite structures introducing auxiliary predicates allowing results inﬁnite To conclude translation normal ASP FOL considering arbitrary structures For ﬁnite structures new pred icates introduced results restricted ﬁnite translation exist However exist translations normal ASP FOL relaxing conditions Loop formulas provide translation normal ASP FOL ﬁnite structures introducing new predicates translated results ﬁnite 12 Ordered completion alternative translation guarantees result ﬁnite polynomial number extra predicates needed 4 Although normal ASP translated FOL arbitrary structures general sub classes A known subclass class loopfree programs called tight programs 17 It shown stable models loopfree program captured Clarks completion ﬁrstorder sentence This result extended socalled loopseparable programs 13 In fact work direction theoretically important Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 69 practically relevant For instance modern ASP solvers built based loopformula approaches ASSAT 30 CMODELS 27 However remains open problem exact characterization ﬁrstorder deﬁnability ﬁrstorder normal answer set programs exactly capture kind normal programs ﬁrstorder deﬁnable In paper bridge gap concept boundedness exactly captures ﬁrstorder deﬁnability ﬁrstorder normal programs arbitrary structures That program ﬁrstorder deﬁnable bounded Moreover notions coincide syntactic notions recursionfreeness loopfreeness program equivalence 51 Firstorder deﬁnability answer set programs We start discussions formal deﬁnition ﬁrstorder deﬁnability normal logic programs Deﬁnition 12 Firstorder deﬁnability Let cid2 program φ ﬁrstorder sentence signature τ cid2 Let C class ﬁrstorder structures We φ deﬁnes cid2 C models φ C exactly stable models cid2 C A program cid2 said ﬁrstorder deﬁnable C exists ﬁrstorder sentence deﬁnes cid2 In paper normally consider C class structures class ﬁnite structures Example 6 Let consider cid2V Example 2 It veriﬁed cid2V deﬁned following sentence xyV isitsx y Interestedx y Busyx zz cid10 x V isitsz y Attraction y Busyx cid2 It shown literature stable models loopfree program exactly captured Clarks completion Proposition 11 13 If cid2 loopfree program Compcid2 deﬁnes cid2 arbitrary structures ﬁnite structures Consequently Proposition 7 recursionfree program deﬁned Clarks completion 52 Boundedness ﬁrstorder deﬁnability Now prove semantic notion ﬁrstorder deﬁnability exactly captured semantic notion boundedness presented Section 4 arbitrary structures corresponds syntactic notions recursion freeness loopfreeness program equivalence Theorem 2 Let cid2 program The following statements equivalent arbitrary structures 1 cid2 bounded 2 cid2 equivalent recursionfree program 3 cid2 equivalent loopfree program 4 cid2 ﬁrstorder deﬁnable Notice 1 2 Proposition 9 2 3 follows straightforwardly Proposition 7 3 4 follows straightfor wardly Proposition 11 We need prove 4 1 Theorem 2 Nevertheless proof technical tedious Hence leave appendix Corollary 12 Boundedness closed program equivalence That programs cid21 cid22 equivalent cid21 bounded iff cid22 bounded Proof Since cid21 bounded ﬁrstorder deﬁnable Therefore cid22 ﬁrstorder deﬁnable sentence cid22 equivalent cid21 It follows cid22 bounded cid2 6 Yet translation ASP SMT The progressional deﬁnition sheds new insights ﬁrstorder ASP theoretical point view For instance Theo rem 2 states ﬁrstorder deﬁnability normal programs exactly captured notion boundedness deﬁned based progressional deﬁnition In section progressional deﬁnition sheds new insights ﬁrstorder ASP practical point view More precisely progressional deﬁnition suggests natural way en code ﬁrstorder normal ASP Satisﬁability Modulo Theories SMT 35 classical ﬁrstorder theories enhanced 70 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 modular theories represent components easily handled logical setting instance arithmetical formulas 2x y 10 This work follows ordered completion approach translates normal program ﬁrstorder SMT sentence The ordered completion approach initiates new way computing stable models grounding ordered completion ﬁrstorder sentence programs instead ﬁrstorder program modern ASP solvers Inspired progressional deﬁnition Deﬁnition 7 deﬁne alternative translation normal ASP ﬁrstorder logicﬁrstorder SMT In fact progressional deﬁnition directly speciﬁes derivation order Let closer look Deﬁnition 7 At kth stage progression accumulating structure Mkcid2 extended ground atoms heads rules applicable kth stage Notice intensional initial structure M0cid2 ﬁnal structure Mcid2 coincides M M stable model program This means ground atom α true stable model M generated particular stage t progression exists rule r program generates atom α stage t progression This equivalent negative body r satisﬁed intended structure M positive body r satisﬁed tth evaluation stage Mt cid2 positive body r satisﬁed t 1th evaluation stage Mt1cid2 rule r applied equivalent Mkcid2 monotonic negative body r satisﬁed intended structure M positive body r satisﬁed intended structure M exists ground atom positive body r generated t 1th stage ground atoms positive body r generated earlier Having explained intuitions able deﬁne new translation normal ASP SMT Again intensional predicate P introduce integer function n P arity Deﬁnition 13 Progression based completion Let cid2 program The progression based completion cid2 written P Ccid2 following sentence x P x succmaxn Q cid2Bodyi n P z x cid2cid2 yi cid5 cid6 8 P τint cid2 1ik notations including yi Bodyi cid2Bodyi borrowed Deﬁnitions 2 3 Once Q z ranges intensional atoms positive Bodyi succ max stand successor function maximum function arithmetic respectively Similar Clarks completion ordered completion progression based completion satisfy program cid2cid2 The main difference justiﬁcation states ground atom stable model justiﬁed There different understandings justiﬁcation In Clarks completion simply states rule program support ground atom head ground atom body satisﬁed structure It turns kind justiﬁcation powerful capture stable model semantics In ordered completion justiﬁcation bit stronger sense exists rule support ground atom ground atoms rule justiﬁed earlier As shown Asunction et al 4 capture stable model semantics In progression based completion justiﬁcation stronger enforces particular derivation order actually coincides derivation order obtained progression Intuitively exactly represents evaluation time progression cid2 respect M Here n P ground atom P x succmaxn Q x exactly maximal arithmetical formula n P stage positive body atoms plus 1 That rule exactly triggered stage maxn Q z th evaluation stage z means stage head atom P Example 7 Let cid2R following program check reachability graph edges represented extensional predicate Edge Reacha Reachx Reach y Edgex y Reachx Reachx Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 71 Then O C cid15cid2 cid9cid2R xRx x yR y E y x nR x nR y P Ccid2 cid9cid2R xRx x yR y E y x nR x succnR y Progression based completion ordered completion share common Both modify justiﬁcation Clarks completion logically stronger formula adding extra statements derivation order ground atoms Nevertheless ordered completion requires ground atoms justiﬁed order bodies justiﬁed earlier heads progression based completion strictly enforces particular derivation order ground atoms coincides obtained progressional deﬁnition Thus progression based completion yields stronger version Proposition 13 Let cid2 program Then P Ccid2 O C cid15cid2 Proof This follows deﬁnitions n P x succmaxn Q z n Q z n Q z n P x cid2 Another difference translations host SMT language Ordered completion needs use built comparison operators progression based completion needs use builtin functions maximum function successor function Note linear programs bodies rules contain inten sional predicate reachability maximum function needed progression based completion We end section showing ﬁnite structures progression based completion P Ccid2 exactly captures stable model semantics Theorem 3 Let cid2 extended program Then ﬁnite τ cid2structure stable model cid2 expanded model P Ccid2 deﬁne n P model cid2cid2 M model cid2cid2 For ground atom P evaluation time progression Now M Proof The follows Proposition 1 Proposition 13 We Let M stable model cid2 For ground atom P structure obtained M expanding interpretations integer predicates n P mentioned model P Ccid2 First M M justiﬁed rule r assignment η step n P b cid2 In addition positive body rη Q exists Q b P osrη Q cid9cid2 This shows M justiﬁed earlier progression Hence n P model P Ccid2 cid2 b justiﬁed progression Q b positive body rη evaluation time exactly n P progression Then intensional ground atom Q b Mn P 1 Otherwise P succmaxQ b Q 7 Ongoing related work In paper restricted discussions ﬁrstorder normal logic programs rules form 1 important fundamental fragment ﬁrstorder answer set programming Driven needs normal logic pro grams extended useful building blocks including disjunctive heads constraints choice rules existentially quantiﬁed heads functions nested expressions A problem arises extending progressional deﬁnition programs building blocks Unfortunately challenging task underlying principles building blocks essentially different nature progressional deﬁnition In progressional deﬁnition intensional ground atoms stable model program justiﬁed step evaluation stage Starting intensional database step justiﬁes set ground atoms heads rules applicable current stage Here ground rule applicable positive body satisﬁed current progression stage negative body satisﬁed candidate structure Disjunctive logic programming natural extension normal logic programming 22 The head disjunctive rule disjunction atoms represents nondeterministic choice body satisﬁed The key point extending progressional deﬁnition disjunctive programs add ground atoms ground rule satisﬁed progression stage There existing solutions The ﬁrst select minimal hitting set heads applicable rules collection sets ground atoms justiﬁed ground atoms stage 42 In sense different progression sequences respect given disjunctive program candidate structure The second approach collect disjunctions atoms clauses derivable current stage ﬁnally compute minimal model collected clauses 39 Both extensions equivalent translational stable models deﬁnition Again 72 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 interesting consequences follow progressional deﬁnition disjunctive programs translation SMT 42 characterization ﬁrstorder deﬁnability boundedness 39 Constraints choice rules aggregates essential building blocks answer set programming extensively benchmark programs Again extending progressional deﬁnition easy underlying principles progressional deﬁnition building blocks incompatible For instance progressional deﬁnition justiﬁes stable models stepbystep aggregate atoms interpreted globally It remains open problem extend progressional deﬁnition incorporating building blocks instance functions existentially quantiﬁed heads nested expressions We expect progression deﬁnition deﬁned equivalent stale model semantics richer formalisms 5182438 Nevertheless challenging task progression deﬁnition needs deﬁned stepbystep Work direction worth pursuing progressional deﬁnition important theoretical practical consequences Incorporating extensional functions progressional deﬁnition straightforward interpretations ﬁxed extensional database However task easy intensional functions 8928 Existentially quantiﬁed heads special interests Datalog ASP enhanced existentially quantiﬁed heads able capture interesting fragments description logics 23 For incorporating existentially quantiﬁed heads progressional deﬁnition key point add ground atoms ground rule satisﬁed progression stage We leave future investigations Naive extensions richer syntactic classes work New notions techniques developed For instance boundedness difference ﬁrstorder disjunctive logic programs classical ﬁrstorder logic Recently coined new term called choiceboundedness purpose 41 Also progression deﬁnition work certain aggregates convex aggregates 3 We consider important future directions progression deﬁnition help understanding ﬁrstorder answer set programming deeply theoretical practical point view The notion boundedness Deﬁnition 9 presents exact characterization ﬁrstorder deﬁnability normal logic programs arbitrary structures Theorem 2 Hence covers notion loop separability 13 suﬃcient condition ﬁrstorder deﬁnability based loop formulas Roughly speaking ﬁrstorder program loopseparable iff loop patterns separated sense loop formulas ﬁnitely characterized As consequence stable models loop separable program deﬁned classical models Clarks completion ﬁnite set loop formulas Since boundedness equivalent condition ﬁrstorder deﬁnability loopseparable programs bounded In fact observed proof Section 5 13 essentially shows program loopseparable need loops bounded size account However converse hold That exists bounded program loop separable program cid2 f lag Example 5 Nevertheless loop separability syntactic condition boundedness semantic In addition decidable check program loop separable Theorem 3 13 checking boundedness undecidable Nevertheless given ﬁxed number k checking kboundedness decidable This help rewrite logic programs loopfree ones solved easily Another important future direction apply theoretical results practices instance develop new ASP solver based translation SMT proposed Section 6 Alternatively utilize notions techniques developed paper boundedness kboundedness solving certain subclasses answer set programs easily 8 Conclusions The main contributions paper summarized follows We extended progression semantics Datalog progression deﬁnition ﬁrstorder normal logic program ming showed equivalent wellknown stable model semantics As consequence important useful notions techniques Datalog lifted ﬁrstorder ASP We introduced notion boundedness ﬁrstorder ASP showed coincides notions recursion freeness loopfreeness program equivalence More interestingly showed notions exactly capture ﬁrstorder deﬁnability ASP normal logic programs This clearly clariﬁes expressive power intersection ﬁrstorder ASP classical FirstOrder Logic FOL syntactic semantic point view Syntac tically known recursionfree loopfree logic programs ﬁrstorder deﬁnable 121730 Our result proved long standing conjecture assertion holds way That ﬁrstorder deﬁnable logic program essentially equivalent recursionfree loopfree Semantically result showed boundedness draws clear boundary ﬁrstorder deﬁnable indeﬁnable normal logic programs The progression semantics naturally suggests new translation ﬁrstorder ASP Satisﬁability Modulo Theories SMT introducing new predicates This translation practical relevance models socalled ordered completion 4 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 73 To conclude progression deﬁnition sheds new insights ﬁrstorder Answer Set Programming ASP including deep connections relationships Datalog FOL SMT Acknowledgements We specially thank Fangzhen Lin initial inspiration work Our results presented paper provides complete answer conjecture equivalence loopfreeness ﬁrstorder deﬁnability stable model semantics We thank Heng Zhang pointing original proof Proposition 9 conference paper incomplete We grateful anonymous reviewers valuable comments Appendix Proofs Proposition 9 Theorem 2 Without loss generality assume rules presented normalized form That intensional predicate Q associated tuple distinguishable variables xQ For instance rule intensional predicate Q head constant c occurring Q Q x1 xi1 c xi1 xn simply introduce new variable xi replace c Q x1 xi1 xi xi1 xn add atom xi c body rule We variable x local variable rule r occur head r For convenience proofs assume sets local variables rules pairwise disjoint xQ head rule form Q Proposition 8 A loopfree program bounded Proof We prove assertion contradiction Assume cid2 bounded Then arbitrary k exists stable model M cid2 intensional predicate Q cid9cid2 Q Mkcid2 Then Deﬁnition 6 exist rule r cid2 Mk1cid2 Q x β1 βm γ1 γl Q 9 Q x η 2 1 m βiη Mkcid2 j 1 j l assignment η 1 Q γ jη M Based observation given stable model M cid2 deﬁne intensional dependency tree T Q Q follows M M Q root T Q b 9 βi 1 m βi intensional atom βiη child Q c child βiη Q subtree built build subtree T βiη M b repeat process It clear T Q tree T Q x atom Q x follows M depth k 1 Now T Q M construct atom based intensional dependency let θ0 ii let θ1 b x substitution replace Q y b tuple elements occurring β1η βlη occurring Q T Q M Q θ Q x root T Q x y M replace βiη βiηθ0θ1 accordingly tuple variables occurring θ0 child βiη T Q iii process continues ground atoms T Q M replaced corresponding atoms Then T Q x tree depth k 1 variables occur atom node x Q j x observe parentchild pair Q From construction T Q corresponding edge Q x Q j y cid2s positive dependency graph Gcid2 On hand cid2 bounded arbitrary k exists stable model M Q M construct tree T Q x depth k 1 Let N number intensional predicates cid2 choose M N Then clear intensional predicate Q construct tree T Q x depth M 1 N Consequently exist path root leaf intensional predicate Q occurs cid15 times atoms Q y path Therefore loop exist corresponding positive dependency graph Gcid2 This concludes cid2 loopfree cid2 cid15 x Q cid15 y tree T Q x Proposition 9 If program bounded equivalent recursionfree program We prove constructions decompose constructions steps First kbounded program equivalent 1bounded program Then 1bounded program equivalently transformed recursionfree program 74 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 Let cid2 normalized program t number We deﬁne program cid2t inductively follows Firstly set cid21 cid2 We specify cid2t1 giving cid2t expanded cid2t adding new rules Suppose exists rule r cid2 form α β1 βm γ1 γl t intensional atomic formula exists rule ri xQ t We add new rule r cid2t1 cid2t 1 m βi Q Headriθi βi θi substitution Headr P osrβi1 βin P osrnθn Headr P osr P osr1θ1 Negr Negr1θ1 Negrnθn Negr βi1 βin set intensional atomic formulas β1 βm r1 rn corresponding rules cid2t discussed θi deﬁned accordingly In addition apply necessary substitutions sets local variables rules cid2t1 pairwise disjoint It easy cid2t1 normalized program Such process similar unfolding propositional logic programs Clearly cid2t normalized cid2 normalized Lemma 1 Let cid2 program k integer Then Mkcid2 M1cid2k structure M τ cid2 Proof We prove assertion induction k Clearly assertion holds k 1 Suppose k t assertion holds Now prove holds k t We ﬁrst prove Mt cid2 M1cid2t Let a1 Q tM Q intensional predicate cid2 If evaluation time Q a1 t Q a1 M1cid2t induction assumption If evaluation time Q a1 exactly t according deﬁnition exists rule r cid2 form 1 assignment η xQ η a1 b 1 m βiη Mt1cid2 c j 1 j l γ jη M By induction assumption 1 m βiη M1cid2t1 If βi form Q t Q intensional predicate according Deﬁnition 6 exists rule ri cid2t1 βiη computed ri step assuming M Therefore αη computed following rule r step note cid2k normalized k Headr P osr Headr P osrβi1 βin P osrnθn P osr1θ1 Negr Negr Negr1θ1 Negrnθn βi1 βin atoms discussed ri θi deﬁned accordingly This shows Q a1 M1 t cid2t We prove M1cid2t Mtcid2 Suppose Q a1 computed cid2t step assum cid2t assignment η ing M Q intensional predicate cid2 Then exists rule r Headr η Q a1 Suppose r form Headr P osr Headr P osrβi1 βin P osrnθn P osr1θ1 Negr Negr Negr1θ1 Negrnθn r cid2 ri cid2t1 deﬁned accordingly Then βi j η computed ri step assuming M So βi j η Mt1cid2 induction assumption Consequently αη Mtcid2 computed rule r cid2 Now kbounded program cid2 equivalent 1bounded program precisely cid2k Lemma 2 If cid2 kbounded program cid2 equivalent cid2k 1bounded program Proof We ﬁrst cid2 equivalent cid2k proving structure M Mcid2 Mcid2k Clearly Mcid2 Mcid2k cid2 cid2k It suﬃces Mcid2k Mcid2 We prove induction natural number t Mt cid2k Mcid2 The induction basis follows Lemma 1 Suppose holds natural numbers t prove case t Let Q a1 ground atom Mt cid2k Mt1cid2k If obtained rule cid2 assignment inductive step holds obviously Otherwise η Q a1 body applied current exists rule r evaluation stage Suppose r cid2k assignment η Headr form Headr P osr Headr P osrβi1 βin P osrnθn Negr Negr Negr1θ1 Negrnθn Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 75 P osr1θ1 r cid2 ri cid2t1 deﬁned accordingly Notice negative parts irrelevant ﬁxed M Considering positive parts 1 n P osriθi Mt1cid2k By induction hypothesis P osriθi Mcid2 This shows 1 n βiη Mcid2 It follows rule rη P osrη Mcid2 Therefore Headrη Mcid2 Hence Q a1 Mcid2 We cid2k 1bounded program If M stable model cid2k M stable model cid2 In addition Mcid2k M Mcid2 Mkcid2 M1cid2k Lemma 1 This shows cid2k 1bounded cid2 We 1bounded program equivalent recursionfree program For purpose decompose task steps We ﬁrst 1bounded program equivalent program nonrecursive rules constraints constraints eliminated nonrecursive rules Constraints normal rules form 1 head instead atom More precisely constraint form β1 βm γ1 γl Let r constraint form 10 By cid2r denote ﬁrstorder formula β1 βm γ1 γl 10 Let cid2 program C set constraints A ﬁrstorder structure M stable model cid2 C stable model cid2 c C M cid2c Here use constraints help prove 1bounded program equivalently transformed recursionfree program First 1bounded program equivalently transformed recursionfree program constraints Let r rule form 1 rC denote constraint β1 βm γ1 γl α Let cid2 program By cid2C denote program obtained cid2 replacing recursive rule r rC Lemma 3 If cid2 1bounded program cid2 equivalent cid2C Proof First split program cid2C parts cid2N R contains nonrecursive rules cid2 cid2RC contains constraints obtained recursive rules cid2 Then stable model cid2C stable model cid2N R satisﬁes constraints cid2RC stable model cid2N R satisﬁes cid2cid2 In addition structure M stable model cid2N R iff Q ground atoms Q M exist nonrecursive rule r cid2 assignment η Headrη M Bodyrη M exist nonrecursive rule r cid2 assignment η M Bodyrη ground atoms Q Headrη Q On suppose M stable model cid2 Since cid2 1bounded M M1cid2 Hence M stable model cid2N R M1cid2 satisﬁes conditions mentioned according deﬁnition evaluation stage In addition M cid2cid2 M stable model cid2 Hence M stable model cid2C On suppose M stable model cid2C Since M stable model cid2C cid2N R M1cid2 M Mcid2 Now assume M stable model cid2 Then M Mcid2 There exists ground atom Q M2cid2 M1cid2 M Otherwise M In fact exists Q M2cid2 M1cid2 M M1cid2 M2cid2 M3cid2 Mcid2 contradiction Now suppose Q Headrη Then derived rule r assignment η second step evaluation stage Q M Negrη M1cid2 P osrη Therefore M Bodyrη M M1cid2 It follows M Headrη This shows Q M contradiction cid2 Next recursionfree programs constraints equivalently transformed recursionfree programs Let cid2 recursionfree program c constraint form 10 Suppose rules cid2 head βi 1 m βi Bodyi1 βi Bodyibi 76 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 rules cid2 head γ j 1 j l γ j Body j1 γ j Body jc j Here Bodyik 1 k bi Body jl 1 l c j body positive intensional atoms cid2 recursionfree program By cid2 c denote program obtained cid2 replacing βi Bodyk i1 k ibi following set rules βi β1 Bodyk βi βm Bodyk βi Body11 Bodyk βi Body1c1 Bodyk βi Body21 Bodyk βi Body2c2 Bodyk βi Bodyl1 Bodyk βi Bodylcl Bodyk Lemma 4 If cid2 recursionfree program c constraint positive atom cid2 c equivalent cid2 c Proof Suppose M stable model cid2 c Then M stable model cid2 M cid2c Then assignment η cases Case 1 Case 2 There exists βi 1 m M cid10 βiη In case consider β jη 1 j cid10 m Clearly β jη M β jη M1cid2 c according construction rule set On β jη M exists rule cid2 form β j Body jk 1 jk jb j M Body jkη Then M Body jk βiη Then β jη M1cid2 c justiﬁed rule β j βi Body jk rule set There exists γ j 1 j l M γ jη In case exists rule form γ j Body jk 1 k c j M Body jkη Similarly consider βiη 1 m Again βiη M βiη M1cid2 c If βiη M exists rule cid2 form βi Bodyis 1 ibi M Bodyisη Then βiη M1cid2 c justiﬁed rule βi Body jk Bodyis rule set In addition atoms α positive body c cid2 cid2 c set rules head α This shows ground atoms M iff M1cid2 c It follows M stable model cid2 c cid2 c recursionfree program Suppose M stable model cid2 satisfy c Then exists assignment η βi 1 m βiη M γ j 1 j l γ jη M We use contradiction prove M stable model cid2 c Otherwise β1η M1cid2 c exists rule justiﬁes β1η 1 It form β1 β j Bodyk β jη M Suppose form β1 Bodyi j Bodyk Then M Bodyi jη It follows M γiη rule γi Bodyi j cid2 contradiction This shows M stable model cid2 c Finally suppose M stable model cid2 Then cases Case 1 Case 2 There exists ground atom M M1cid2 In case ground atom M1cid2 c according construction rule set There exists ground atom M1cid2 M If atom positive body c M1cid2 c Hence M stable model cid2 c Suppose form βiη 1 m Since M1cid2 exists rule form βi Bodyk M Bodykη Hence M Bodyk βiη Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 77 βiη M Therefore βiη M1cid2 c justiﬁed rule βi βi Bodyk It follows M stable model cid2 c No matter case M stable model cid2 c This shows cid2 c equivalent cid2 c cid2 Corollary 10 If cid2 recursionfree program C set constraints cid2 C equivalent recursionfree program Proof Note eliminating constraints γ1 γl positive body needs convert nonrecursive rule γ1 γ1 γl The assertion follows Lemma 4 fact constraints eliminated onebyone That constraint c set constraints C M stable model cid2 C c iff M stable model cid2 c M satisﬁes C iff M stable model cid2 c M satisﬁes C cid2 Finally able prove Proposition 9 Proof Proposition 9 Proposition 9 follows Lemmas 2 3 Corollary 10 cid2 Theorem 2 Let cid2 program The following statements equivalent arbitrary structures 1 cid2 bounded 2 cid2 equivalent recursionfree program 3 cid2 equivalent loopfree program 4 cid2 ﬁrstorder deﬁnable Here prove 4 1 Theorem 2 For purpose need introduce background knowledge results ﬁxedpoint logic Let τ vocabulary P new predicate τ arity n Let φ x tuple free variables φ length n P occurs positively φ occurrence P φ scope numbers negations4 Given structure A τ formula φ x P deﬁnes operator cid15T nary relation nary relation DomA x P ﬁrstorder formula cid15T DomAn A φ x T Starting set cid15 gives rise sequence nary relations follows x P x P cid15 cid150 cid15t cid7 x P cid15r rt x P cid15t Since P occurs positively φ sequence cid151 ordinal k cid15k ﬁxedpoint T 0 sense cid15T 0 T 0 T cid15T T T 0 T We use cid15 ﬁxed point cid15 x P sense x P φ x P increases Thus exists x P t k Since P occurs positively φ operator cid15 x P denote P iff short denote ﬁxedpoint DomAn A φt This deﬁnes corresponding iterative formula φt x x P x P A φ cid15t formula obtained φ x P We write φ x P cid15t x P cid15 P iff φ x A ﬁxedpoint query formula ﬁxedpoint logic deﬁnes global relation More precisely let φx1 xn formula ﬁxedpoint logic vocabulary τ x1 xn free variables φ We φx1 xn expresses nary global relation τ structure A τ φx1 xn yields following nary relation DomA a1 A φa1 The notion deﬁnability boundedness deﬁned ﬁxedpoint logic Let K class y tuple free variables ψ length n τ deﬁnes y τ structures We formula ψ ﬁxedpoint φ x P K iff A K P iff A ψ x A φ y DomAn 4 Here assume φ constructed connectives deﬁned terms 78 Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 We leastﬁxed point formula φ DomAn A φ A K x P bounded K exists ﬁxed natural number k x P iff A φk P x Barwise Moschovakis 11 revealed important correspondence deﬁnability boundedness arbitrary structures ﬁxedpoint logic Lemma 5 11 Let K class τ structures ﬁrstorder ﬁnitely axiomatizable5 A ﬁxedpoint formula bounded K iff deﬁned ﬁrstorder formula K We shall prove 4 1 based Lemma 5 The basic ideas divided steps First program construct program single intensional predicate simulate original program Then program single intensional predicate translated equivalent ﬁxedpoint formula Let cid2 program Let P 1 P n set intensional predicates cid2 Suppose k maximal arity P 1 n Let 0 1 n n 1 distinguishable new constants Construct new predicate P arity k 1 Let cid2S program obtained cid2 simultaneously replacing atom P ti 0 0 ti We cid2S simulates cid2 number occurrences 0 equal k ti cid2 P Lemma 6 Let cid2 program cid2S program constructed Let M structure τ cid2 We construct structure MS τextcid2 P domain MS M 0 1 n extensional predicates Q cid2 Q M constants c cid2 c intensional predicates P P MS c MS Q M M iff P 0 0 MS Then integer k P matches arity P P Mkcid2 iff P 0 0 MS kcid2S Proof This assertion follows constructions deﬁnitions induction k cid2 Lemma 6 shows cid2S simulate cid2 sense intensional atom P intensional atom P ti 0 0 cid2S Now program single intensional predicate equivalently transferred ﬁxedpoint formula class axiomatizable structures Let cid2 program contains single intensional predicate P new predicate Then heads rules cid2 form P steps 1 construct program arity P Let ψcid2 P cid2 t 2 let ψcid2 P ﬁrstorder formula formula vocabulary τ cid2 P x cid2 normalized Let P ﬁrstorder formula obtained cid2 P y set local variables rule r Clearly ψcid2 P x free variables t negative bodies rules cid2 P P occurs positively replacing occurrence P y cid2Bodyr rcid2 cid10 Let M τ cid2structure By M denote structure vocabulary τ cid2 P ti cid2 associated DomM DomM M P interpretations constants predicates M M iff P Proof If cid2 deﬁned ﬁrstorder sentence φ K axiomatized ﬁrstorder sentence φ P x cid2 x P x The ﬁxedpoint formula ψcid2 P following lemma holds x P simulates program cid2 stable models cid2 By induction k Lemma 7 Let cid2 program single intensional predicate P M stable model τ cid2 Suppose ψcid2 P M P constructed Then integer k Mkcid2 iff ψcid2 P x P k Lemma 7 shows cid2 simulate cid2 class structures K Consequently answer set program cid2 simulated ﬁxedpoint formula cid9cid2 K Together Lemma 5 ﬁnally prove Theorem 2 paper We ﬁnish proof Theorem 2 follows 5 That exists ﬁrstorder sentence φ τ models exactly captured K Y Zhou Y Zhang Artiﬁcial Intelligence 250 2017 5879 79 Proof Theorem 2 We need prove 4 1 From Lemma 6 suﬃces prove case program contains single intensional predicate Let cid2 program single intensional predicate P deﬁned ﬁrstorder sentence φ Let K M M A Scid2 Then K ﬁrstorder axiomatized φ x P x By x P x φ obtained Lemma 7 ﬁxedpoint formula ψcid2 P φ simultaneously replacing occurrence P x P bounded K Again Lemma 7 cid2 bounded cid2 x P K deﬁned formula φ P t Then Lemma 5 ψcid2 P t P References 1 Serge Abiteboul Richard Hull Victor Vianu Foundations Databases AddisonWesley 1995 2 Miklós Ajtai Yuri Gurevich Datalog vs ﬁrstorder logic J Comput Syst Sci 49 3 1994 562588 3 Vernon Asuncion Yin Chen Yan Zhang Yi Zhou Ordered completion logic programs aggregates Artif Intell 224 2015 72102 4 Vernon Asuncion Fangzhen Lin Yan Zhang Yi Zhou Ordered completion ﬁrstorder logic programs ﬁnite structures Artif Intell 177179 2012 124 5 Vernon Asuncion Yan Zhang Yi Zhou Ordered completion logic programs aggregates AAAI2012 2012 pp 691697 6 Chitta Baral Knowledge Representation Reasoning Declarative Problem Solving Cambridge University Press 2003 7 Michael Bartholomew Joohyung Lee Functional stable model semantics answer set programming modulo theories IJCAI 2013 2013 8 Michael Bartholomew Joohyung Lee On stable model semantics intensional functions Theory Pract Log Program 13 45 2013 863876 9 Michael Bartholomew Joohyung Lee Stable models multivalued formulas partial versus total functions Principles Knowledge Representation Reasoning Proceedings Fourteenth International Conference KR 2014 Vienna Austria July 2024 2014 2014 10 Michael Bartholomew Joohyung Lee Yunsong Meng Firstorder extension FLP stable model semantics modiﬁed circumscription IJCAI 2011 2011 pp 724730 11 J Barwise Y Moschovakis Global inductive deﬁnability J Symb Log 43 1978 521534 12 Yin Chen Fangzhen Lin Yisong Wang Mingyi Zhang Firstorder loop formulas normal logic programs Proceedings Tenth International Confer ence Principles Knowledge Representation Reasoning Lake District United Kingdom June 25 2006 2006 pp 298307 13 Yin Chen Fangzhen Lin Yan Zhang Yi Zhou Loopseparable programs ﬁrstorder deﬁnability Artif Intell 175 34 2011 890913 14 Keith L Clark Negation failure Logics Databases 1978 pp 293322 15 Marc Denecker Yuliya Lierler Miroslaw Truszczynski Joost Vennekens A Tarskian informal semantics answer set programming ICLP 2012 2012 pp 277289 1993 683713 16 HeinzDieter Ebbinghaus Jörg Flum Finite Model Theory Perspectives Mathematical Logic Springer 1995 17 François Fages Consistency Clarks completion existence stable models Meth Logic CS 1 1 1994 5160 18 Paolo Ferraris Joohyung Lee Vladimir Lifschitz Stable models circumscription Artif Intell 175 1 2011 236263 19 Haim Gaifman Harry G Mairson Yehoshua Sagiv Moshe Y Vardi Undecidable optimization problems database logic programs J ACM 40 3 20 Martin Gebser Roland Kaminski Benjamin Kaufmann Torsten Schaub Answer Set Solving Practice Synthesis Lectures Artiﬁcial Intelligence Machine Learning Morgan Claypool Publishers 2012 Symposium MIT Press 1988 pp 10701080 21 Michael Gelfond Vladimir Lifschitz The stable model semantics logic programming Proceedings International Logic Programming Conference 22 Michael Gelfond Vladimir Lifschitz Classical negation logic programs disjunctive databases New Gener Comput 9 34 1991 365386 23 Georg Gottlob André Hernich Clemens Kupke Thomas Lukasiewicz Stable model semantics guarded existential rules description logics Principles Knowledge Representation Reasoning Proceedings Fourteenth International Conference KR 2014 Vienna Austria July 2024 2014 2014 24 Amelia Harrison Vladimir Lifschitz David Pearce Agustín Valverde Inﬁnitary equilibrium logic strongly equivalent logic programs Artif Intell 25 Tomi Janhunen Ilkka Niemela Compact translations nondisjunctive answer set programs propositional clauses Logic Programming Knowl edge Representation Nonmonotonic Reasoning Essays Dedicated Michael Gelfond Occasion His 65th Birthday 2011 pp 111130 26 Joohyung Lee Yunsong Meng Firstorder stable model semantics ﬁrstorder loop formulas J Artif Intell Res 42 2011 125180 27 Yuliya Lierler cmodels SATbased disjunctive answer set solver Logic Programming Nonmonotonic Reasoning 8th International Conference LPNMR 2005 Diamante Italy September 58 2005 Proceedings 2005 pp 447451 28 Vladimir Lifschitz Logic programs intensional functions Principles Knowledge Representation Reasoning Proceedings Thirteenth International Conference KR 2012 Rome Italy June 1014 2012 Springer 2012 29 Fangzhen Lin Yoav Shoham A logic knowledge justiﬁed assumptions Artif Intell 57 23 1992 271289 30 Fangzhen Lin Yuting Zhao ASSAT computing answer sets logic program SAT solvers Artif Intell 157 12 2004 115137 31 Fangzhen Lin Yi Zhou From answer set logic programming circumscription logic GK Artif Intell 175 1 2011 264277 32 David Maier Jeffrey D Ullman Moshe Y Vardi On foundations universal relation model ACM Trans Database Syst 9 2 1984 283308 33 Victor W Marek Miroslaw Truszczynski Stable models alternative logic programming paradigm The Logic Programming Paradigm A 25Year Perspective SpringerVerlag 1999 pp 375398 34 Ilkka Niemelä Logic programs stable model semantics constraint programming paradigm Ann Math Artif Intell 25 34 1999 241273 35 Robert Nieuwenhuis Albert Oliveras Cesare Tinelli Solving SAT SAT modulo theories abstract DavisPutnamLogemannLoveland proce dure DPLLt J ACM 53 6 1999 937977 36 David Pearce Agustín Valverde Towards ﬁrst order equilibrium logic nonmonotonic reasoning JELIA2004 2004 pp 147160 37 Raymond Reiter A logic default reasoning Artif Intell 13 12 1980 81132 38 YiDong Shen Kewen Wang Thomas Eiter Michael Fink Christoph Redl Thomas Krennwallner Jun Deng FLP answer set semantics circular justiﬁcations general logic programs Artif Intell 213 2014 141 39 Heng Zhang Yan Zhang Firstorder expressibility boundedness disjunctive logic programs IJCAI 2013 2013 40 Yan Zhang Yi Zhou On progression semantics boundedness answer set programs KR 2010 2010 41 Yi Zhou Firstorder disjunctive logic programming vs normal logic programming Proceedings TwentyFourth International Joint Conference Artiﬁcial Intelligence IJCAI 2015 Buenos Aires Argentina July 2531 2015 2015 pp 32923298 42 Yi Zhou Yan Zhang Progression semantics disjunctive logic programs AAAI 2011 2011 246 2017 2233