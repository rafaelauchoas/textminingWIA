Artificial Intelligence 96 1997 42 l449 Artificial Intelligence Reasoning minimal models efficient algorithms applications 1 Rachel BenEliyahuZohary Luigi Palopoli b2 Mathematics Computer Science Department BenGurion University Negev BeerSheva 84105 Israel b DEIS Universitd della Calabria 87030 Rende CS Italy Received September 1996 Abstract Reasoning minimal models heart knowledgerepresentation systems Yet turns task formidable simple theories considered In paper introduce elimination algorithm performs linear time minimal model finding minimal model checking significant subclass positive CNF theories positive headcyclefree HCF theories We prove task minimal entailment easier positive HCF theories class positive CNF theories Finally variations elimination algorithm applied allow queries posed disjunctive deductive databases disjunctive default theories answered efficient way 1997 Published Elsevier Science BV Keywords Minimal models Disjunctive databases Disjunctive default logic Disjunctive logic programs Stable model semantics Linear time algorithms 1 Introduction Computing minimal models essential ficial intelligence including circumscription 293 11 default logic task reasoning systems arti 391 minimal Corresponding author Email rachelcsbguacil Part work author visiting Cognitive Systems Laboratory Computer Science Department University California Los Angeles CA USA second author visiting scholar Computer Science Department University California Los Angeles CA USA This Principles extended revised version paper presented Fourth Reasoning Bonn Germany 1994 Knowledge Representation International Conference Email luigisideisunicalit 00043702971700 PIISOOO437029700060X 1997 Published Elsevier Science BV All rights reserved 422 R BenEliyahuZohary L PalopoWArtficial Intelligence 96 1997 421449 diagnosis semantics sumption plausible gorithms systems 121 answering queries posed logic programs 421 32 deductive databases systems generalized goal produce plausible In reasoning stable model closedworld inferences explanations compute minimal models Nonetheless computing minimal models substantially speed inference efficient al Surprisingly inherent difficulty reasoning minimal models Given propositional tasks consid 69l 1182634 received formal analysis recently CNF theory T literal L T following ered 3 minimal model T l Model finding Find minimal model l Model checking Check given interpretation l Minimal entailment l Minimal membership Unfortunately T results formal work complexities Is L true minimal models T Is L true minimal model T minimal models discouraging theory clause hard answer model finding minimal model 4 model checking minimal membership entailment IIcomplete P NPolohard positive lo coNPcomplete Xcomplete 181 It turns theory positive literals negative reasoning questions theories 9 minimal positive turns characterize In paper exploit basic property headcyclefreeness negative subclass CNF theories related problems solved efficiently The 71 The idea simple A clause 5 viewed having property directionfrom explicit way clauses represented logic programs We associate dependency graph arc directed arc directed positive dependency appear positive size theory S A appears time linear graph directed cycle goes 6 A CNF theory called headcyclefree clause S atom A atom A clause 6 clause Headcyclefreeness theory atom clause A appears negative different atoms checked graph direction literalsand node HCF We positive HCF theories problems manageable time size theory minimal general case model linear minimal membership summarized paper NPcomplete The complexity Fig 1 Entries reference number entailment coNPcomplete results propositional indicate 20 theories results presented finding model checking 3 See section formal definitions minimal model interpretation IiteraZ 4 We recall PNPolas nl class decision problems solved polynomialtime deterministic Turing machines making logarithmic number calls oracle characterization model finding given terms complexity complexity bounded NR For precise classes functions ill 5 In section clause disjunction literals In following sections use different syntax R BenEliyahuZohary L PalopoliArcial Intelligence 96 1997 421449 423 Language CNF Model checking coNP complete Model finding NPMVllOptPOlogn complete 111 91 Minimal entailment Minimal membership complete 181 8complete 181 positive HCF On On coNPcomplete 201 NPcomplete Fig 1 Complexity computational tasks minimal models Our algorithms generalized allow efficient computation minimal Herbrand significant subclass positive models apply results CNF theories disjunctive 441 computes stable model stratified HCF disjunctive deductive database 6 This algorithm answer queries posed disjunctive default seemingly In addition use algorithm rules Specifically provide polynomialtime answering queries deductive databases firstorder CNF theories data complexity form relevant knowledge fragment CNF theories world 161927 HCF theories represent meaningful theories formally confirmed 271 expressive power precisely The rest paper organized follows In Section 2 present theories The relevance HCF stated elimina positive HCF finding propositional tion algorithm performs minimal model theories consider entailment minirnal rithm class functionfree demonstrate systems Related work discussed tion 6 applications elimination tasks minimal model checking minimal membership class In Section 3 generalize firstorder positive HCF theories algorithm Section 5 conclusions knowledgerepresentation presented Sec elimination algo In Section 4 2 The elimination algorithm positive HCF theories In section introduce elimination algorithm perform minimal model We establish minimal membership finding propositional positive HCF theory complexity minimal model checking minimal EA time entailment linear propositional positive HCF theories We defilne theory T set clauses form 1 body clause IZ m 0 As Cs atoms 7 The expression called head clause We assume positive state left right f called Cs distinct A theory T called theories clause n 0 In section deal positive expression 6 Stable models srraied disjunctive deductive databases defined following equivalent notation Note syntax 1 clause usually bit unusual sections Al V A2 V V A I Cl V C2 V V C 424 R BenEliyahuZohary L PalopoliArtijicial Intelligence 96 1997 421449 A set atoms satisfies body clause atoms body set A set atoms violates clause set clause belong body clause atoms head clause belongs satisfies set A set atoms X model theory T clauses violated X A model X theory T minimal Y c X model T T An interpretation theory T assignment Interpretations value true A literal atom positive models represented set atoms assigned literal negated atom negative truth values atoms literal With theory T associate directed graph Gr called dependency graph T atom A clause 6 T node b arc A S A body 6 arc S A A head 6 As mentioned model finding coNPcomplete model entailment positive theories IIcomplete PNPtolosnlhard model minimal membership checking Zcomplete problems directed cycle involving Ci Cj So example HCF theory A B B A A V C HCF From work 71 results presented follows easier class positive HCF theories A theory T HCF theory A B B 4 A A V B T Ci Cj j GT contains clause Proposition 1 Headcyclefreeness propositional theory T size n checked time On 9 Proof The algorithm checking headcyclefreeness consists steps strongly connected components This time linear 1 Construct Gr dependency 2 Identify size Gr 43 3 For clause check graph theory component This assigning component head Since step 0 time checking linear time atoms head belong atom number number appears twice algorithm linear 21 Model finding Clearly model positive set atoms theory What difficult example theory Roughly speaking idea pick model theory eliminate model atoms finding minimal model EA shown Fig 2 follows theory easilytake 8 In 71 different definition dependency graph given hut definitions equivalent defining HCF theories The dependency graph defined advantage constructed linear time 9 Throughout paper size theory number symbols characters contains R BenEliyahuZohary L PalopoliArtiial Intelligence 96 1997 421449 425 EMT Input A positive HCF theory T Output A minimal model T 1 M model T M 0 2 Let A set clauses 6 T violated M 1 head 8 M 1 1 If A 8 Step 3 Else let X n repeat Step 2 headMMMnXMMX 3 Let A set clauses 6 T violated M 6 E A Ihead8 MI 2 If A 0 return M Else let H I headS M let X source H let M M X Step 2 Fig 2 The elimination algorithm positive HCF theories know minimal models algorithm subsets model component X Intuitively b nodes G set X nodes Given directed graph G set Y nodes G X called source Y X fl Y G lo c node A Y X strongly connected directed path G A nodes X source Y dependency graph theory atoms Y X derive atoms X At generic step execution EA current theory Then eliminate model M input turn subsets atoms M way prevents elimination minimal model To end S set atoms candidates elimination delete source S At Step 3 EA delete source heads clauses violated M Since clause set atoms case atoms head theory HCF belong clause strongly graph theory Therefore connected components nonempty set head atoms dependency different nonminimal atoms source Given set X 1x1 denotes X The EA uses function head defined follows given clause 6 set atoms M M head 6 set atoms M belong The proof following appears involved theorem Appendix Theorem 2 The EA correct generates minimal model T Given positive HCF theory T input EA The choice model start Step 1 looked nondeterministic step Indeed different initial models EA output different minimal models lo A strongly connected component C directed graph G maximal subgraph G pair nodes 1 v2 C C contains directed path 01 2 directed path 2 q Step 3 EA cardinality 426 R BenEliyahuZohary L PalopoliArticial Intelligence 96 1997 421449 In fact EA able generate minimal models input theory Before proving state following useful result lemma Lemma 3 input positive HCF theory T EA output minimal model In execution EA M initialized minimal model M proof respect j By Proof Suppose begin execung EAT M set minimg model T M Let k Theorem A 1 atom proof atom G It maximum number clauses minimallength EAT run follows Step 2 executed k easy verify M atoms having proof 1engtJh times ith iteration M returned Step 3 Hence M M generated EA row adding 0 Proposition 4 Nondeterministic HCF theory T execution EA outputs M completeness If M minimal model positive Proof Suppose M minimal model T There execution EAT picks model M Step 1 By Lemma 3 EA starts minimal model M output model Hence result follows 0 The following example demonstrates EA works Example 5 Suppose theory 1 aVb 2 ba 3 aVc suppose start EA M b c At Step 1 EA M 8 At clauses violated M Step 2 A 8 M Since A Step 3 clauses atoms heads belong Step 3 A V b V c Since b source b c note c source shortly happens choose c delete b M left M Step 2 In Step 2 A V b add M delete M leaves M M c We repeat Step 2 time A 0 violated M Step 3 In Step 3 clauses A 0 EA case returns Indeed minimal model theory Let follow option choosing c instead b source b c time Step 3 executed We delete c M left M b Step 2 In Step 2 A aV c add M delete leaves M M b We repeat Step 2 M violated M time A 0 clauses R BenEliyahuZohary L PalopoWArtijcial Intelligence 96 1997 421449 427 Step 3 In Step 3 d 0 EA case returns u Indeed u minimal model theory The theory Example 5 minimal model In example theory Example 6 Suppose theory 1 aVb 3 aVc suppose start EA M b c At Step 1 EA M 8 At Step 2 thiat d 0 clauses violated M atoms heads belong M Since A Step 3 Step 3 A clauses Since b c source b c delete M Suppose delete b We left M c Step 2 In Step 2 A V b b V c add c M delete c M leaves M c M 8 We repeat Step 2 time A 8 Step 3 In Step 3 A 8 EA case returns c Indeed c minimal model theory It easy EA return b b c selected respectively c source We prove EAs time complexity linear Theorem 7 Complexity n size input theory For positive HCF theories EA runs time On Proof We briefly EA implemented 331 assume data structure constant access time storing variable propositional variable linear time Following assigned unique number data related We use following data structures l SCC array An array indexed strongly connected components entry array consists set atoms belongs entry SCCs Each SCC represented l AtomH array An array stores atom list clauses atom appears head l AtomB array An array stores atom list clauses atom appears body l Rules array An array stores clause linked 1 clause head body atom want delete list deletions atoms clauses time pointer constant 428 R BenEliyahuZohary L PalopoliArtifcial Intelligence 96 1997 421449 2 counters Headnumber Bodynumber atoms atoms body head l Unsat2clauses The set clauses having body head size 2 l Unsatlclauses l MinSCC The lowest SCC visited All data structures initialized At end Step 2 EA set Unsatlclauses The set clauses having body head size 1 8 Then atom A linear time X X Step 2 following array AtomB delete A body clause Using A ap pears update counter Body clause Body Body 1 If Body 0 add clause Unsat2clauses Unsatlclauses depending number atoms head Step 3 follows appears atom atom A belongs MinSCC following In MinSCC minimum SCC head clause Unsat2cZauses For Delete A head clause Move clauses Unsat2clauses Unsatlclauses appropriate pointer necessary AtomH At end Step 3 increase added Unsat2clauses SCC lower MinSCC removed heads Also clause added Unsat2clauses Unsatlclauses originally atom head belongs dependency counter MinSCC Note clause future atom head belongs atoms later step current MinSCC graph built In way clause visited k times k number atoms visited spend time clause Each time clause constant Hence algorithm linear 0 22 Other computational tasks We consider computational tasks needed reasoning minimal models Model checking positive HCF theory time linear size theory This fact start executing minimal model model outputs Hence EA M initialized Theorem 8 Model checking HCF theories time On n size theory The EA solves model checking class positive Proof By Lemma 3 Step 1 EA M initialized model T EA output M Therefore given interpretation step checks 6 minimal checking algorithm minimal model theory T consists steps The time The second step model T linear R BenEliyahuZohary L PalopolVArtijcial Intelligence 96 1997 421449 429 runs EAT M initialized size T Hence result follows 0 By Theorem 7 second step takes linear time Likewise minimal entailment minimal membership easier positive HCF theories general Theorem 9 Minimal class positive HCF theories coPIPcomplete Minimal membership class positive HCF theories PIPcomplete entailment minimal membership Minimal entailment entailment Proof That minimal sults NEhardness minimal membership problem POSITIVEONEINTHREE CONE minimal membership showing reduction 3SAT known NP 71 We begin showing 411 HPcomplete implied work BenEliyahu Dechter Instance Sets St Sk having Question Return YES set elements elements Xi Xi X 1 Q 6 k contains exactly element set Consider positive HCF theory T set Si set clauses clause YES V NO YES minimal model T set Hence minimal membership exactly element set elements contains HPhard To shaw coNEhardness minimal model theory T contains YES contain NO Thus minimal entailment note coHEhard minimal entailment 0 Before closing section like address important issue raised theory set clauses form 1 Dechter represented 141 Instead representing theory set clauses form AAZ A A A XI A X2 A A X__ c 2 way parallel As Cs atoms We identify theories programs defined model called time 33 Therefore l1 It known logic program class stratijied way stratified deductive databases logic intended perfect model minimal models linear theories minimal model stratified research explored immediate relating CNF time Recent stratified linear theories I For formal definition stratification section 430 R BenEliyahuZohary L PalopoliArtcial Intelligence 96 1997 421449 shifting negationfree logic programs obtained set stratified based considering theory T causaE theory disjunctive shifting deductive databases normal analogously obtainable disjunctive unstratified applying CNF obtained set causal models T set perfect models stratified shifting But obtainable theories causal obvious HCF following theories logic programs In particular Schaerf 421 advocates semantics stratified given database possible ways Following Dix et al 161 define CNF theory T define theories relation positive HCF HCF theories shifting atoms head body vice versa theories theories stratified exists stratified T shifting Then theories stratified theories We note T apparently transformation stratified illustrates example theories theory Example 10 On hand consider positive HCF theory T V b c bvc Theory T obtained shifting atoms head clause body Tba atc c b Theory T stratified On hand consider stratified theory T b b TaATbc Theory T obtained shifting negative body literals heads clauses b b aVbVc Theory T positive HCF However easy simple variant EA positive HCF theory T stratified theory T obtained shifting atoms head body perfect mode1 T clear minimal model T Thus positive HCF theory causal Moreover set causal models T strictly contained set minimal models T That containment strict shown example Example 11 Consider positive HCF theory T V c bAca This theory minimal models u c The stratified obtainable T shifting operations theory 7c bAca perfect model u Thus minimal model c causal model T R BenEliyahuZohary L PalopoWArtijicial Intelligence 96 1997 421449 431 By similar line reasoning clearly possible stratified compute minimal model theory computing linear complete EA complete positive HCF theory transforming perfect model disadvantages minimal efficient EA For example discover stratified theory computing fact early stage time When compared Proposition generate models EA procedure 4 cases EA theory theory model procedure transforms model We like note class Horn theories unique minimal model linear time 17251 intersects class HCF theories classes distinct Consider T3 u V b Tl Horn positive HCF T2 Horn positive HCF Ts positive HCF Horn theories Ti T2 la example 3 The elimination algorithm nonground positive HCF theories In section generalize EA efficiently perform Herbrand model finding nonground positive HCF theory EA algorithm distinct propositional problem computing ground distinct ground We approach theory applying handled cases computing Therefore input variant algorithm advantage arbitrary model finding minimal input instances atoms input theory expensive order compute minimal models This require construct section present variation EA require letters This method convenient grounded instantiation instantiation ground theory We refer nonground theory set clauses form vx1 XAl AAAAACVCVVC 3 As Cs atoms arstorder Xl simply X variables language function symbols appear clause We write 3 A1 A2 A A A Cl v C2 v v C 4 nonground universally quantified The definitions variables theories theories Throughout theories In X p called predicate The set constants given theory T called Herbrand universe T If constants occur Herbrand universe keeping mind head body positive propositional expression p Xi appearing T arbitrary constant The set atoms constructed predicate names Herbrantl universe T formed consistently Herbrund base T A ground instance clause 6 Herbrand universe T theories positive section assume T constants contained assumed substituting constants called 432 R BenEliyahuZohary L PalopoWArtijicial Intelligence 96 1997 421449 Input A nonground positive HCF theory T Output A minimal Herbrand model T 1 M fi M 8 2 Let A set ground instances 6 rules T violated M IatomheadoutSMI 1 If A 0 Step 3 Else let X n atomheadout 6 S M M M n X repeat Step 2 3 Let A set ground instances 6 rules T violated M atomheadout SM 2 2 If A 0 return M Else let H n predicate names H GT let M M fl N Step 2 nameheadout8 S M let N source Fig 3 The elimination algorithm nonground positive HCF theories S The grounded version T denoted grT variables set ground instances clauses T A Herbrand model T subset Herbrand base satisfies grT A Herbrand model M T minimal properly contain Herbrand model T As propositional case theory T associate directed graph GT called predicatename dependency graph T predicate node p clause clause 6 arc directed 6 p p predicate head S body 6 p predicate T node b arc directed A theory T HCF clause form 3 Ci Cj j GT contains directed cycle involving Ci predicate Cj Specifically HCF theories predicate head clause T predicate atoms Proposition 12 The headcyclefreeness nonground theory T size n checked time On Proof The algorithm propositional theory checking headcyclefreeness similar Proposition 1 cid144 In Fig 3 present variation EA called EAF 3 firstorder com putes minimal Herbrand model positive nonground HCF theory The EAF uses functions atomheadout nameheadout Given rule S set predicate names S atomheadout 6 S S return predicate names belong set predicate names appear head S belong ample aX V bX S nameheadout 8 SS b The algorithm set atoms appear head S S nameheadout 6 S S return S Thus ex atomheado SS bX employs set M predicate S cX R BenEliyahuZohwy L PalopoWArtificial Intelligence 96 1997 421449 433 names After predicate added M ground atom predicate added output minimal model The proof following theorem appears Appendix Theorem 13 The EAF input theory correct The EAF generates minimal Herbrand model The following example shows EAF works Example 14 Suppose theory 1 V bs 2 bY aY 3 V cs 4 aY dY At Step 1 EA3 M 0 M 8 At Step 2 A 8 clauses 1 3 violated M predicate names head belong M Since A Step 3 Step 3 A ax V bs V cs As M H b c Since b c source set M equal b sourIce b c note Step In Step 2 A V bs Therefore X consequently Step 2 repeated Since M M set equal clause violated M SMl 1 ds instantiating Y s clause 4 So add ds M asds algorithm stops returns M Indeed theory M instances clauses violated M minimal Herbrand model ds atomheadoutS Since The complexity theories analyzed principles data complexity query language relational positive HCF nonground EA3 database fixed semantics defined 441 reasoning Any nonground component theory divided represents component represents extensional intentional set extensional theory For purposes HCF theory T denoted TE set clauses grounded T TE For extensional component analyze complexity following disjoint sets 381 One set comprises theory collection facts positive body T denoted TI simply 14 clauses 1 3 form clauses 2 4 form intentional If component EA3 changes fix TI vary TE discover head intentional theory presented atoms instance given nonground Example component Theorem 15 Using algorithm EA3 minimal model nonground positive HCF theory 71 n TE time polynomial size TE 434 R BenEliyahuZohary L PalopoliArticial Intelligence 96 1997 421449 Proof Let n size TE m number distinct predicate names occurring T k maximum fixed immediate T 0 nkm Note T Since assumption T running EAF size M Om We size model resulting arity predicate maximum maximum 1 Step 1 EA3 2 Step 2 construction 3 Step 3 construction takes 0 1 time A X update M takes 0 nm A N update M takes 0 nkm The statement follows 1 Each time Step 2 executed EA3 adds new atom M jumps 2 Each Step 3 time Step 3 executed EA 3 adds new predicate M stops returns M 3 The size m On EA3 presents theory construction grounding input As pointed EA3 theory However complete instead EA advantages EA3 requires starting model preliminary nondeter input generated ministically algorithm Consider theory T u V c b A c Example 11 Clearly u c minimal models T c source ministic completeness algorithm G r model c generated EA3 Nondeter EA minimal models achieved grounding theory instance drawback 4 Applications elimination algorithm 4 I Disjunctive deductive databases A variation EA construct stable model disjunctive deductive database We define disjunctive deductive database rules form DDB finite set C 1 C2 1 1 CAl AnotB notBk 5 loss generality assume symbols Without symbol I instead classical symbol V mean emphasize As Bs Cs atoms firstorder function By disjunction Bs negative predicates DB denoted Gas headcyclefree DDBs HDDB language Cs distinct logic We As positive predicates A DDB positive DDB dependency graph DDB Bis form 5 A rule k 0 The predicatename slightly different manner defined theories simply classical HCF theories defined analogy ignoring Proposition 16 The headcyclefreeness On DDB size n checked time R BenEliyahuZohary L PalopoWArtijcial Intelligence 96 1997 421449 435 Proof The algorithm propositional theory checking headcyclefreeness similar Proposition 1 0 361 define stratified DDB SDDB Following partition rule S form 5 set S predicate names DDB possible subsets So S called strata 1 predicate names Cs appear head 8 2 3 index c stratum thme strata indexes associated predicate names As smaller equal c strata indexes smaller associated predicate names Bs strictly c So SDDB DB associated partition predicate names strata For stratification r 1 subsets DBI DB DBi partition stratum Si We contains assume head rule So ST DBs predicate names rules DB corresponding heads predicates predicates appearing loss generality So contains lthe rules Several different semantics proposed semantics use set minimal models positive DDB define intended meaning DDB The holds SDDBs semantics SDDBs agree identifying SDDI Notably handle stable models SDDB intended meaning DDBs 315213637 Definition 17 Stable model occurrence models 2 1 Suppose DB variablefree DDB If DB set stable models set minimal If occurs DB stable models defined follows For subset S atoms DB define DB DDB obtained DB deleting 1 formulas form B B 4 S body rule 2 eafch rule body formula zotB B E S If S minimal models DB DB got stable model DB To apply replace rule grounded definition instances S DDB variables A DDB stable models We claim 12340 DDB Two examples follow problem solved computing arbitrary stable model Example 18 Consider This problem applications including diagnosis follows given bipartite digraph G VI V2 E solution covering problem exists node s E S edge s x E Consider includes wellknown graphtheoretic problem minimal set covering 351 The problem set minimal subset S VI node x E V2 HDDB DB node x E V2 rules G minimal domains 436 R BenEliyahuZohmy L PalopoliArtificial Intelligence 96 1997 421449 EAsDB Input A propositional SHDDB DB Output A stable model DB 1 Partition DB strata DB1 2 M 0 3 For il I DB Eliminate DBi clause having body negative literal notD D E M b Eliminate a11 negative literals remaining clauses DBi c M EADBi U P I P E M Fig 4 The elimination algorithm SHDDBs S ssnx X s nodes belonging VI E Each stable model DB encodes solution st x sn x st edges set covering minimal problem Therefore pick arbitrary stable model DB set covering graph G Example 19 Assume pictorial database want tool given type object scene tree river suggests default coloring scene object distinguishable following HDDB different colors Consider objects close constraint construct blueX 1 greenX 1 softsreen X treeX greenX 1 brownX c mountuin X blueX t riverX greenX 1 sofgreen X t treeX riverY pcZase x Y softgreen X treeX mounruin Y greenYpcZoseXY classification Assume encoding particular b painted close HDDB encodes feasible coloring objects objects scene facts like pclose b meaning stored painted database objects scene Each stable model scene In Fig 4 algorithm EAs variation EA computes arbitrary stratified headcyclefree DDB SHDDB _ The basic idea EA stable model propositional partition subset SHDDB according order implied stratification stratification R BenEliyahuZohary L PalopoliArtial Intelligence 96 1997 421449 431 Note algorithm run DDB variables grounded version DDB Proofs following theorems given Appendix Theorem 20 The EAs SHDDB correct The EAs generates stable model input Theorem 21 DB execution EAs outputs M If M stable model SHDDB The EAs computing unique stable model stratified nondisjunctive deductive database Corollary 22 Let DB stratied EAs Dtl coincides unique stable model DB nondisjunctive deductive database Then Theorem 23 Complexity size grounded version input DDB The E SHDDBs runs time On n Proof Assume runs time OCL linear time complexity 0 input DDB k strata It follows Theorem 7 EAs size ith stratum Since C ni n ni ni denotes We illustrate EAs works example Example 24 Suppose following SHDDB DB 1 albt 2 ccnota 3 dietc adopt stratification So 8 Note DDB So 8 Assume Si b S2 c d e At Step 1 E compute rules In case DBI consists rule DB consists rules After setting M 8 Step 2 start loop Step 3 Steps 3a 3b modify EADBt b stratum DB2 M consider Step 3a modify DB2 At Step 3b literal eliminated body DDB rule number 2 Therefore Step 3c EA applied rule DB1 So apply EA DBl If assume value assigned stratification b 2 c 3 4 dlec bc application yield This M returned b c d stable model DB result EAsDB instance set b c d It easily seen assigned set returned 438 R BenEliyahuZohmy L PalopoliArcial Intelligence 96 1997 421449 42 Disjunctive default logic Disjunctive default logic generalization Gelfond et al 22 logic dealing disjunctive propositional disjunctive default A set disjunctive defaults A disjunctive default expression form logic introduced Reiters default In section focus logic Gelfond et al define disjunctive default theory Reiters default difficulties order overcome information ff PlPn YIIIY 6 3 1 y formulas language Gel PI fond et al define extension disjunctive default theory A minimal disjunctive deductively default A cy E E 1 E 1 6 m yi E E closed set sentences E satisfying propositional condition Let consider subset disjunctive default theories disjunctive default programs DDPs A DDP set defaults form A1 AAA l CllIG 7 As Bs Cs atom n 0 Each DDP A associated DDB DBd replacing default form 7 rule ClICtAl AnotBl notBk The following theorem implies techniques complexity results established respect DDBs apply DDPs Theorem 25 Gelfond et al 221 extension A E stable model DBd Let A DDR The logical closure E So particular conclude class DDPs computing PNPolosnhard checking set atoms extension deciding atom belongs extension Let DDP completely ordered corresponding DDB stratified subclasses sections identify coNPhard previous results 8hard HCF Then DDPs manageable class DDPs general extension Theorem 26 Let A completely ordered DDP let n size I3 An extension A time On Proof Follows Theorems 25 23 0 Note appearance I3 We measure E condition size DDP number symbols contains R BenEliyahuZohary L PalopoliArcial Intelligence 96 1997 421449 439 These results extended deal firstorder disjunctive default theories EA propositional HCF principles generalize theories firstorder HCF theories 5 Related work The class HDDBs introduced BenEliyahu Dechter 78 They satisfiability theories classes logic Cadoli classical model 910 described partitioning tractable NEhard His partition shown queries propositional HDDBs answered solving problem model checking propositional set logical tractable classes relations 61 developed efficient identified effectively BenEliyahu algorithms finding minimal models propositional CNF theories Their algorithms efficient theory Horn nonHorn clauses set positive theory represented finding considering theory clear Dechter acyclic network loway nonHorn corresponds small set relations invlolves literals clause Tasks related minimal model computation 12131 recently logic programming 12131 highly complex studied diagnosis 45 Many literature worst implicates The task literature diagnosis prime implicates systems compute cover prime NEhard Therefore completeness heuristic approaches The work literature focused efficient optimization computing minimal models address issue worstcase techniques 4 One limitation averagecase minimal literature algorithms diagnosis diagnosis case To minimal theory exponential researchers compromise logic programming linear programming approach complexities second databases In particular 191 studied Eiter Leone Sac expressive power subsets disjunctive SHDDBs able express shown queries NP brave semantics coNP cautious semantics To semantics check compute reported minimal membership 191 confirm queries brave semantics relevance HCF theories respectively Hence cautious minimal results entailment answers 6 Conclusion The task computing minimal models logic programming Whether looking circumscription researchers default general computing minimal models artificial reasoning telligence logic diagnosis commonsense crucial speeding reasoning process In paper introduced algorithm EA performs minimal rnodel finding minimal model checking significant linear time subclass CNF 440 R BenEliyahuZohary L PalopoliArtiJicial Intelligence 96 1997 421449 theories positive HCF theories We shown minimal entailment easier class positive HCF theories general case Our complexity results included Fig 1 deductive databases disjunctive default EA modified answer We demonstrated queries posed disjunctive algorithm EAs computes stable model efficient way We presented linear time identified class disjunctive default theories propositional SHDDB class SHDDBs extensions deductive databases strict superclass class stratified nondisjunctive This observation coupled results Eiter Leone Saci 191 claim algorithms deal expressive subclasses Section 5 supports time Note linear theories rapidly Levesque deductions form theory vivid performed stored way enables 28 argued form knowledge vivid data structure information 341 common queries Thus Halpern Vardi 24 1 Papadimitriou fielded appealing idea vivid form theory need model theory In case deduction easier number models models closest real world selected One approach example minimal models theory vivid form We argue arbitrary minimal model theory The work presented step efficient implementation task Since theory exponential replaced model checking select 12340 models adopted fast query answering theory circumscription ideas fast answers best represent Appendix A Proofs A1 Useful theorems dejnitions Theorems A 1 A2 taken 71 These theorems prove correctness EA Following 71 define proof atom sequence clauses atom theory Formally atom A proof set atoms M theory T sequence clauses derive respect 61 8 T 1 clause Si atoms appear head belongs M atom denoted hu 2 A hd 3 4 Si body 1 atom body Si equal body Si satisfied M hM Sj 1 j Theorem A1 BenEliyahu HCF theory T Dechter 71 A set atoms M minimal model R BenEliyahuZohary L PalopolUArtifcial Intelligence 96 1997 421449 441 1 MI saties clause T 2 atom A M proof A respect T M The results positive HCF theories hold propositional DDB Say set atoms M DDB DB atom A proof respect al sequence rules 61 S DB 1 clause Si atoms appear head belongs M atom denoted hw Si 2 A han 3 4 61 body 1 atom body Si equal thLe body Si satisfied M hM6j 1 j Theorem A2 BenEliyahu HDDB DB Dechter 71 A set atoms M stable model 1 M satisjes rule DB 2 fx atom A M proof A respect DB M The following lemma probably known We include proof sake com pleteness Lemma A3 Let DB propositional SHDDB let S1 S partition atoms strata The following hold 1 u M stable model DB n r M restriction M atoms belonging Sl U US M stable model DB1 U UDB 2 If M stable model DB1 U U DB n r stable model DBl U U DB U P I P E M stable model DB 1 By Theorem A2 atom M proof respect Proof rule DB satisfied M Because DB stratified atom M proof respect rule DB U U DB satisfied M Hence M DB follows DB1 U U DB M lemma follows immediately 2 The proof induction r n Case r n 0 trivial Case rn 0 By induction hypothesis M stable model DB1 U UDB stable model DBl U U DB_ U P cl P E M stable model DB U U DB_l Let DB DBl U U DB_I U P t P E M let DB U DB_l Let M stable model DB U DB Using Theorem A2 DBI IJ M stable model DB U DB Let 6 rule DB U DB 6 DB Let M If S DB clearly restrictian DB By 1 lemma M stable model DB M satisfies 8 It case body rule belongs true S satisfied M Next higher strata M DB U DB If atom A belongs atom M proof respect satisfied M Suppose satisfied making atoms lower strata M atoms appear belong 442 R BenEliyahuZohary L PalopoliArtQicial Intelligence 96 1997 421449 LongEA T Input A positive HCF theory T Output A minimal model T begin 1 M model T M 8 0 j 0 2 Deletedi 0 iteration j Let A set clauses 6 T violated M 6 E d Iheadd M 1 1 If d 0 Step 3 Else let X n head 6 M MMflX M M X For A E X stageA jjl repeat Step 2 j T violated M 6 E A Ihead8 MI 2 3 Let d set clauses If A 0 return M Else let H n let M M X Deletedi Let A set clauses 6 T body 6 satisfied M Ihead 8 MI 1 If A 0 repeat Step 3 Else j 0 1 Step 2 head 8 M let X source H Deletedi n X end Fig Al The elimination algorithm Proof version M DB U DB Suppose M proof A respect respect A proof respect respect DB U DB M LY composed rules DB We shown proof respect respect M DB proof A strata I We M DB U DB We proof Y A M M M DB U DB Hence construct proof A proofs atoms belong M DB U DB A belongs belong atoms 0 A2 Proofs theorems Theorem 2 The EA generates minimal model T correct Given positive HCF theory T input EA The proof algorithm LongEA EA uses indexes Fig Al LongEA exactly employed proof Lemma A4 stageA c Let T theory let EA T M For atom A M 1 There atom B M stageB 0 path B A GT 2 For atom B stageB 0 atom C C E DeZeted j 0 j path B C R BenEliyahuZohary L PalopoliArtial Intelligence 96 1997 421449 443 Proof By induction stuge A assuming lexicographic order Case smge A 0 c Condition 2 holds trivially Condition 1 proved induc tion c 1 clearly holds B A Case sruge A 0O Condition Case sluge A 0 k k 0 Consider j k j Step 2 EA execution Step 2 time It case clause S A such1 6 M A atom D body 6 stuge D 0 k 1 A belong lower stage By induction hypothesis Condition 1 holds Case stageA n c fir n 0 Condition 2 holds Assume contradiction hold In case atom B stageB n O m atom C E Deletedj 0 j n path GT B C Note stuge B n 0 case B head clause 6 form A A A A B v B1 V v B At 1 t I stugeA u u u n Let w z A assume D Al A having stage highest stage Al w z Since stuge B n 0 w n case k 2 z body 6 satisfied M Step 3 iteration w k Since path B C GT X chosen Step 3 source H Deletedw DeZeted w 1 DeZeted n 1 case C belongs Suppose Condition path B D So path B C But C Deletedt contradiction Condition Case skzge A n 0 Condition Case stageA n k k 0 In case clause 0 t w By induction hypothesis 1 atom B A4 stuge B w 0 induction hypothesis Condition 2 1 proved induction c 1 clearly holds B A Deletedt C belongs program A A A A A V B1 V V B 1 j 6 r stuge Aj n k 1 Using 1 holds observe Condition cl induction hypothesis Corollary AS For atom D stageD j j 0 t path D atom C C E Deletedt c Proof Suppose stuge D j By Condition M KAT By Condition 0 B C D q 1 Lemma A4 atom B stuge B 0 path B D GT path B C So path D C 2 Lemma A4 atom C C E Deletedt t 444 R BenEliyahuZohary L PalopoliArtijicial Intelligence 96 1997 421449 Lemma A6 The following invariants hold execution EA 1 Every atom M proof respect M T 2 For clause violated Mt atom head belongs M observe claim holds We start algorithm Proof It easy M 8 add atom A M case clause 6 M A atom T atoms body S belong head S belongs T M Therefore conclude Mt M n Mt Atoms added M belong atom M proof respect commands add atoms The second claim holds finish Step 1 algorithm M false M The algorithm initial M model T Hypothetically executing contains 3 We claim holds execute holds execute belong holds commands MI M fl X Step 2 M M x Steps 2 In Step 3 delete M atoms claim source atoms heads violated clauses claim M delete atoms holds commands commands command It left second claim holds execute consecutive commands commands iteration commands Further assume contradiction A E X stageA j Suppose Ml M I X M M X Step 2 holds execute commands set j commands Suppose execute j Note claim valid executing executing violated M M It case atom clauses head belongs claim hold X atom A body S belongs iteration j atoms executing M M n X M M X Since t deleted far M M belong By Corollary AS atoms head 6 deleted M far Hence 0 contradiction head S belongs clause 6 T atom initial Deletedt M Proof Theorem 2 It easy EA propositional theory T Clearly M satisfies clause respect terminates input theory Let M model returned EA given input T By Lemma A6 atom proof T Mt By Theorem Al M minimal model T 0 Theorem 13 The EA3 input theory correct The EA3 generates minimal Herbrand model Before proving Theorem 13 prove following lemma Lemma A7 The following EA3 invariants hold execution algorithm 1 Every atom M proof respect M gr T R BenEliyahuZohqx L PalopoliArtcial Intelligence 96 1997 421449 445 2 For ground instance rule violated M atom head predicate belong M Proof First claim holds We start algorithm M 0 add atom A M case instance 6 rule M A ground T ground atoms body S belong atom head S predicate belong M Ground atoms M Since predicate added M predicate names belong M deleted Consequently conclude grT M ground atom head 6 added M proof respect atom M The second claim holds trivially finish Step 1 algorithm M add atoms M The claim predicate names M M f X Step 2 M M f N Step 3 We claim holds execute command M M rl X Step 2 command MI M II N Step 3 holds execute false executing commands M EA3 contains commands commands Suppose execute command M M n X Step 2 let d set rules instances Assume contradiction predicate names added M body 8 It follows T By induction M assumption instance 6 E d contains T violated execution command head atoms M Let p predicate atom head S Step 3 let q predicate atom X graph path q p dependency number times Step 2 executed p added path q p contradiction Basis 0 We execute Step 2 immediately adding p M Step 3 Let A set rules violated M executing Step 2 Clearly q head rule A q added M Step 3 q E X q belong time executed Step 3 p belong Step 3 This means path q p dependency graph T definition source Step 3 However p added M tcl source source Induction step Assume Step 2 executed k 0 times added p M Step 3 Let Y set predicate names atoms added M executing M Step 2 k 1 time added p M Step 3 Y added executing Step 2 k 1 time atom predicate q added exist atom C M executing Step 2 k time Therefore atom predicate q head predicate Y rule containing path predicate atom C body This means C q By induction hypothesis path predicate C path q p reach p p Hence predicate C q Suppolse execute command command M M fl N Step 3 Note A set case heads instances executing 446 R BenEliyahuZohary L PalopoliArtcial Intelligence 96 1997 421449 instances violated M contain ground atoms predicate names M Now case ground atoms belong head instance predicate names belong N T HCF predicate names atoms N strongly connected graph T Thus case executing component command M M n N Step 3 second claim holds dependency 0 terminates Suppose positive HCF theory T Let FI denote Proof Theorem 13 First EA7 nonground end Step 2 atom IFI added M jump Step 3 EAF adds predicate M stops Since M C 31 stops predicate FI finite M finite algorithm It left algorithm T M EA7 terminate terminates M minimal model T Note M minimal model T EA3 input Herbrand base T At Step 3 At minimal model gr T By Theorem Al terminates 1 M model gr T 2 atom M proof respect M gr T We proved 1 holds Hence M minimal model T Cl Lemma A7 2 holds Using Condition 2 Lemma A7 Theorem 20 The EAs SHDDB correct The EAs generates stable model input Proof First note input SHDDB correctness EAs EA terminates EAs Step 3c EAs generates stable model input SHDDB finite definition EA number r strata terminates By 2 Lemma A3 easy 0 Theorem 21 If M stable model SHDDB DB execution EAs outputs M So S stratification let Proof Let partition DBs rules r 3 1 Let M stable DB model DB We want M generated EAs We proceed induction r DB corresponding predicate DB symbols Basis r 1 In case sufficient M minimal model DBO Indeed definition M stable DB model DB M minimal model DB Because r 1 predicate negative SO Therefore DBM DB The claim literal appearing follows Theorem 4 M stable model rule DB belongs Induction assume algorithm complete r strata Consider SHDDB DB r 1 strata Let M restriction M predicate names belonging s u U S By 1 Lemma A3 M stable model DB1 U U DB By induction exists execution EAs input DB1 U U DB R BenEliyahuZohary L PalopoliArttficial Intelligence 96 1997 421449 447 generates M It immediate DB generates M result associated sufficient model G DBI U A I A E M Note M M C7 M M M minimal model DB2 Hence M minimal model exists execution EAs input r strata DB By Theorem 4 M stable model DB M minimal M stable model DB stable model DB Since DB positive 0 Acknowkdgments We thank Victoria Zemlyanker Section 3 paper We gratefully EAF anonymous thank Marco Cadoli Rina Dechter Thomas Eiter Georg useful Bonnice editing parts paper allowing include version algorithm raised quality paper We Michelle remarks helped improve email Thanks Giorgio Gottlob discussions acknowledge suggestions referees points The work author supported AFOSR 900136 infrastructure Israeli Ministry Science The second author supported EUUS project DEUS EX MACHINA Nondeterminism MURST grant 40 share basi di dati evolute project Sistemi grants NSF IRI8821444 technology grant datamining ECC deductive databases formali e strumenti References I S Abiteboul E Simon V Vianu Nondeterministic express deterministic transformations Proceedings Ninth ACM Symposium Principles Database Systems Nashville TN 1990 218229 languages 2 KR Apt HA Blair A Walker Towards theory declarative knowledge J Minker ed Foundations Deductive Databases Logic Programming Morgan Kaufmann Los Altos CA 19881 89148 31 C Baral J Lobo J Minker WP3 semantics negation normal disjunctive logic programs ZW Ras M Zemankova eds Methodologiesfor Intelligent Systems Proceedings 6th International Symposium ISMIS91 1991 459468 4 C Bell A Nerode RT Ng VS Subrahmanian Mixed integer programming methods computing nonmonotonic deductive databases J ACM 41 6 1994 11781215 5 R BenEliyahu A hierarchy tractable subsets computing stable models J Art Intell Res 5 1996 2752 6 R BenEliyahu R Dechter On computing minimal models Ann Math Artif Intell 18 1 1996 327 short version Proceedings AAAI93 Washington DC 1993 28 7 R BenEliyahu R Dechter Propositional semantics disjunctive logic programs Ann Math Artif Intell 12 1994 5387 short version Proceedings 1992 Joint International Conference Symposium Logic Programming JICSLP92 Washington DC 1992 81 R BenEliyahu R Dechter Default reasoning classical logic Artificial Intelligence 84 l2 1996 113150 9 M Cadoli The complexity model checking circumscriptive formulae Inform Process Lett 44 3 1992 113118 R BenEliyahuZohary L PalopoWArtijicial Intelligence 96 1997 421449 448 lOI 1111 I21 A Marchetti M Cadoli On complexity model finding nonmonotonic Spaccamela P Mentrasti M Venturini Zilli eds Proceedings 4th Italian Conference Theoretical Computer Science 1992 125139 Z Chen S Toda The complexity 1995 313325 J Kleer AK Mackwotth solutions btform Comput 119 2 diagnoses systems Artijicial Intelligence R Reiter Characterizing selecting maximal propositional logics I31 I41 I151 1161 I71 1181 1191 r201 211 1221 23 24 1 56 231992 J Kleer BC Williams Diagnosing multiple R Dechter Personal communication 197222 October 1993 faults ArttJiciul Intelligence 32 1 1987 97130 Proceedings 1992 Joint International logic programs 1996 87100 nondisjunctive semantics disjunctive J Dix Classifying Conference Symposium Logic Programming JXSLP92 Washington DC 1992 798812 J Dix G Gottlob V Marek Reducing disjunctive Fund Inform 28 l2 WP Dowling JH Gallier Lineartime algorithms formulae J Logic Programming 1 3 T Eiter G Gottlob Propositional complete Theoret Comput Sci 114 2 T Eiter N Leone D Sac The expressive power partial models databases T Eiter Personal communication M Gelfond October 1993 V Lifschitz Classical negation Proceedings LID96 San Miniato 1984 267284 circumscription extended closedworld Theoret Comput Sci appear semantics shiftoperations logic programs 1993 231245 disjunctive disjunctive Italy 1996 satisfiability propositional Horn databases New testing deductive reasoning Hz 1991 365385 Generation Comput 9 34 M Gelfond H Przymusinska V Lifschitz M Truszczyriski Disjunctive defaults Proceedings 2nd International Conference Principles Knowledge Representation Reasoning KR91 Cambridge MA 1991 230237 E Giannotti D Pedreschi D Sacca C Zaniolo Nondeterminism Proceedings 2nd International Conference Deductive Object Oriented Databases 1991 J Halpem M Vardi Model checking vs theorem proving A manifesto Proceedingsbtternational Conference Principles Knowledge Representation Reasoning KR91 Cambridge MA 1991 325334 deductive databases 25 A Itai JA Makowsky Unification complexity measure logic programming J Logic Programming 4 2 1987 105117 26 PG Kolaitis CH Papadimitriou Some computational aspects circumscription J ACM 37 1 1990 l14 27 N Leone computation f Rullo E Scarcello Disjunctive btform Comput 135 2 1997 69l 12 stable models unfounded sets fixpoint semantics 28 H Levesque Making believers computers Artijcial Intelligence 30 1 1986 81108 29 V Lifschitz Computing 30 J McCarthy Circumscriptiona Proceedings IJCAI85 Las Angeles CA 1985 121127 reasoning Arttficiaf Intelligence 13 l2 form nonmonotonic circumscription 1980 2739 13 1 J McCarthy Applications Intelligence 28 1 19860 89116 circumscription formalizing commonsense knowledge Artijicial 321 J Minker On indefinite databases closedworld assumption Proceedings 6th Conference Automated Deduction Lecture Notes Computer Science Vol 138 Springer Berlin 1982 292308 reasoning 331 I Niemela J Rintanen On impact stratification complexity nonmonotonic J Appl NonClassical Logics 2 1994 141179 34 CH Papadimitriou On selecting satisfying truth assignment Proceedings 32nd Annual ACM Symposium Foundations Computer Science 1991 163169 35 Y Peng J Reggia Plausibility diagnostic hypothesis The nature simplicity IEEE Trans Systems Man Cybernet 17 1987 146162 361 T Przymusinski On declarative J Minker ed Foundations Deductive Databases Logic Programming Morgan Kaufmann Los Altos CA 1988 193216 semantics deductive databases logic programs R BenEliyahuZohary L PalopoWArttficial Intelligence 96 1997 421449 449 37 TC Przymusinski Stable semantics disjunctive programs New Generation Comput 9 1991 401 424 381 R Reiter On closedworld databases H Gallaire J Minker eds Logic Data Bases Plenum Press New York 1978 5576 39 R Reiter A logic default reasoning Arttjicial Intelligence 13 l2 40 D Sad C Zaniolo Stable models nondeterminism logic programs negation 1980 81132 Proceedings Ninth ACM Symposium Principles Database Systems Nashville TN 1990 41 TJ Schaefer The complexity satisfiability problems Proceedings IOrh Annual ACM Symposium Theory Computing 1978 216226 42 M Schaerf Negation minimality disjunctive databases J Logic Programming 23 1 1995 6386 43 R Tarjan Depthfirst search linear graph algorithms SIAM J Comput 1 2 1972 146160 44 MY Vardi The complexity relational query languages Proceedings 14rh Annual ACM Symposium Theory Computing STOC82 1982 137145