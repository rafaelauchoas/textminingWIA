Artiﬁcial Intelligence 207 2014 122 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Relating constraint answer set programming languages algorithms Yuliya Lierler Department Computer Science The University Nebraska Omaha 6001 Dodge Street Omaha NE 68182 United States r t c l e n f o b s t r c t Article history Received 9 October 2012 Received revised form 28 October 2013 Accepted 29 October 2013 Available online 11 November 2013 Keywords Constraint answer set programming Constraint satisfaction processing Satisﬁability modulo theories Recently logic programming language AC proposed Mellarkod et al 1 integrate answer set programming constraint logic programming Soon clingcon language integrating answer set programming ﬁnite domain constraints ezcsp language integrating answer set programming constraint logic pro gramming introduced The development languages systems constitutes appearance new AI subarea called constraint answer set programming All languages common In particular aim developing new eﬃcient inference algorithms combine traditional answer set programming procedures methods constraint programming Yet exact relation constraint answer set programming languages underlying systems understood In paper address issue formally stating precise relation sev eral constraint answer set programming languages AC clingcon ezcsp underlying systems 2013 Published Elsevier BV 1 Introduction Constraint answer set programming CASP novel promising direction research roots traced propositional satisﬁability SAT SAT solvers eﬃcient tools solving Boolean constraint satisfaction problems arise different areas science including software hardware veriﬁcation Answer set programming ASP extends computational methods SAT ideas knowledge representation logic programming nonmonotonic reasoning As declarative programming paradigm provides rich simple modeling language features incorporates recursive deﬁnitions Satisﬁability modulo theories SMT extends computational methods SAT integrating nonBoolean symbols deﬁned background theory formalisms ﬁrst order theory constraint processing language The key ideas integration constraints naturally expressed nonBoolean constructs b computational methods developed areas automated reasoning SAT complement technology effective manner processing constraints Constraint answer set programming draws extensions SAT technology integrates answer set pro gramming constraint processing This new area demonstrated promising results including development CASP solvers acsolver 1 Texas Tech University clingcon1 23 Potsdam University Germany ezcsp2 4 KO DAK idp3 5 KU Leuven These systems provide new horizons knowledge representation ﬁeld broadening applicability computational tools CASP provides new modeling features answer set programming 1 httpwwwcsunipotsdamdeclingcon 2 httpmarcycjbnetezcspindexhtml 3 httpdtaicskuleuvenbekrrsoftwareidp 00043702 matter 2013 Published Elsevier BV httpdxdoiorg101016jartint201310004 2 Y Lierler Artiﬁcial Intelligence 207 2014 122 improves grounding solving performance delegating processing constraints large possibly inﬁnite domains specialized systems The origins work 67 Drescher Walsh 89 inca NICTA Australia Liu et al 10 mingo Aalto University Finland took alternative approach tackling CASP languages translational approach In case CASP programs translated ASP programs Drescher Walsh proposed number translations In program translated integer linear programming formalism The empirical results demonstrate viable approach tackling CASP programs The general CASP paradigms illustrates importance developing synergistic approaches au tomated reasoning community To effectively requires clear understanding important features CASPlike languages underlying systems Current CASP languages based principal ideas relating straightforward task One diﬃculty lies fact languages introduced spe ciﬁc architecture mind rely answer set programming constraint satisfaction processing constraint logic programming integer linear programming technologies The syntactic differences stand way clear derstanding key features languages For example CASP language compared earlier sibling language ezcsp Balduccini 4 formally stated ezcsp language special case AC Relating CASP systems formally complex task The variations underlying technologies complicate clear articulation similarities differences For instance main building blocks CASP solver acsolver 1 ASP sys tem smodels 11 sicstus Prolog4 The technology clingcon 23 developed ASP solver clasp 12 constraint solver gecode 13 In addition CASP solvers adopt different communication schemes heterogeneous solving components For instance ezcsp relies blackbox integration ASP CSP tools order process ezcsp language 4 Systems acsolver clingcon promote tighter integration multiple automated reasoning methods The broad attention CASP suggests need principled general study methods develop unifying ter minology formalisms suitable capture variants languages solvers This work seen step direction First presents formal account illustrates precise relationship languages acsolver clingcon ezcsp Second formally relates systems hybrid approach solving CASP In particular accounts systems acsolver clingcon ezcsp Usually backtrack search procedures DavisPutnamLogemannLoveland DPLLlike procedures 14 backbone CASP computational methods described terms pseudocode In 15 authors proposed alternative approach describing DPLLlike algorithms They introduced abstract graphbased framework captures states computation transitions states allowed This approach allows model DPLLlike algorithm mathematically simple elegant object graph collection pseudocode statements We develop similar abstract framework performing precise formal analysis relating constraint answer set solvers acsolver clingcon ezcsp Furthermore framework allows alternative proof correctness systems This work clariﬁes extends stateoftheart developments area constraint answer set programming believe promote progress area More related work Another direction work related developments CASP research HEXprograms 16 These programs integrate logic programs answer set semantics external computation sources external atoms They motivated need interface ASP external computation sources example allow synergy ASP description logic computations context semantic web CASP lot common HEX programs System dlvhex5 17 computes models programs It allows deﬁning plugins inference external atoms general framework developing CASP solvers provide speciﬁc computational mechanism default Heterogeneous nonmonotonic multicontext systems 18 formalism related CASP HEXprograms CASP HEXprograms seen possible incarnations special case multicontext systems Multi context systems provide general formalism contexts written different logics relate bridge rules Intuitively CASP provides contexts language answer set programming language constraint programming Yet bridge rules extremely simplistic nature CASP particular relate atoms logic program constraints constraint processing Paper structure We start reviewing AC programs introduced Mellarkod et al 1 notion answer set programs In subsequent section introduce clingcon language formally state relation AC language We deﬁne new class weaklysimple programs demonstrate acsolver algorithm applicable programs We review transition introduced Lierler 1920 model smodels We extend transition model acsolver algorithm newly deﬁned graph characterize computation acsolver We deﬁne graph suitable modeling clingcon state formal result 4 httpwwwsicsseislsicstuswwwsiteindexhtml 5 httpwwwkrtuwienacatresearchsystemsdlvhex Y Lierler Artiﬁcial Intelligence 207 2014 122 3 relation acsolver clingcon algorithms At illustrate graph model ezcsp The ﬁnal section presents proofs formal results stated paper A report results paper presented 21 22 This work extends earlier efforts troducing transition captures advanced CASP solvers clingcon ezcsp featuring learning backjumping This paper provides complete account proofs formal results 2 Review AC programs A sort type nonempty countable collection strings ﬁxed alphabet A signature Σ collection sorts properly typed predicate symbols constants variables Sorts Σ divided regular constraint sorts All variables Σ constraint sort Each variable takes values unique constraint sort For example let signature Σ1 contain regular sorts step 01 action ﬂuent f constraint sorts time 0200 12 variable T T constraint sort time predicates cid2 atstep time occursaction step nextstep step holdsﬂuent step okTimetime okCompcomputer time A term Σ constant variable An atom form pt1 tn p nary predicate symbol t1 tn terms proper sorts A literal atom negation A constraint sort large numerical set primitive constraint relations examples include arithmetic constraint relations like cid2 The partitioning sorts induces partition predicates AC language Regular predicates denote relations constants regular sorts Constraint predicates denote primitive constraint relations constraint sorts Deﬁned predicates denote relations constants belong regular sort constants belong constraint sorts predicates deﬁned terms constraint regular deﬁned predicates Mixed predicates denote relations constants belong regular sort constants belong constraint sorts Mixed predicates deﬁned rules program similar abducible relations abductive logic programming 23 For example signature Σ1 deﬁne atstep time mixed predicate occursaction step nextstep step holdsﬂuent step regular predicates okTimetime okCompcomputer time deﬁned predicates An atom formed regular predicate called regular Similarly constraint deﬁned mixed atoms We atom nonmixed atom regular constraint deﬁned For signature Σ1 atoms at0 T occursa 1 sample mixed regular atoms respectively A nested program ﬁnite set rules form a0 a1 al al1 am1 1 a0 ground nonconstraint atom ai 1 cid2 cid2 n ground nonconstraint atom symbols cid5 If a0 omit notation This special case programs nested expressions 24 The expression a0 head rule 1 If B denotes body 1 right hand arrow write B pos elements occurring positive body B pos a1 al Bneg elements occurring single negation failure Bneg al1 Bneg2 elements occurring double negation failure Bneg2 am1 We frequently identify body 1 conjunction elements replaced classical negation connective a1 al al1 am1 Similarly interpret rule 1 clause 2 a0 a1 al al1 am1 3 case a0 1 a0 absent 3 Given program Π write Π cl set clauses 3 correspond ing rules Π We restate deﬁnition answer set Lifschitz et al 24 nested programs form convenient purposes The reduct Π X nested program Π respect set X atoms obtained Π deleting rule 1 X satisfy body recall identify body 2 replacing remaining rule 1 a0 Bpos B stands body 1 A set X atoms answer set nested program Π minimal sets atoms satisfying Π X cl According 25 ach oice rule construct 11 4 Y Lierler Artiﬁcial Intelligence 207 2014 122 lparse6 language seen abbreviation rule We adopt abbreviation rest paper For program consists rule form answer sets The rules programs called regular bodies rules contain symbols cid5 An AC program ﬁnite set rules form 1 a0 regular deﬁned atom ai 1 cid2 cid2 l nonmixed atom a0 deﬁned atom ai l 1 cid2 cid2 n nonmixed atom We assume mixed atom occurring AC program restricted form mcid9r V cid9r sequence regular constants V variable This assumption impact applicability language ease presentation For instance sample AC program signature Σ1 follows okComp1 T T cid2 5 okComp2 106 okTimeT T cid2 10 okComp1 T okTimeT T cid3 100 okComp2 T occursa 0 at0 T T cid10 1 okTimeT occursa 0 at0 T T cid3 110 cid2 cid3 110 occursa 1 at1 T holds f 1 occursa 0 next1 0 next1 0 occursa 0 T cid2 4 The implementation language requires declaration signature Σ1 In syntax proposed Mellarkod et al 1 encode declaration Σ1 follows time0200 computer12 step01 actiona ﬂuent f csorttime csortcomputer mixed atstep time regular occursaction step regular deﬁned okTimetime deﬁned okCompcomputer time This sample program inspired Example 1 1 encodes small planning domain It known answer set programming provides convenient language encoding planning problems Yet problem actions mapped real time represented large integer domain grounding bottleneck answer set programming Mellarkod et al illustrated AC language allows overcome limitation Example 1 Mellarkod et al 1 considered programs different syntax discussed For instance 1 classical negation precede atoms rules Also signature Σ contain variables regular sort Nevertheless AC language discussed suﬃcient capture class programs covered acsolver algorithm 21 Semantics AC language We deﬁne semantics AC programs transforming program nested program grounding For AC program Π signature Σ set groundΠ denote set ground instances rules Π The Π obtained groundΠ replacing constraint atom cid5 true false respectively set ground 6 httpwwwtcshutﬁSoftwaresmodels Y Lierler Artiﬁcial Intelligence 207 2014 122 5 A ground constraint atom evaluates true false standard interpretations symbols For example constraint atom 1 1 evaluates true constraint atom 1 cid10 1 evaluates false It easy ground Π nested program For instance let groundΠ consist rules okTime100 100 100 okComp2 100 okTime101 101 100 okComp2 101 occursa 0 at0 101 101 cid10 1 okTime101 ground Π okTime101 okComp2 100 okTime101 cid5 okComp2 101 occursa 0 at0 101 cid5 okTime101 If deﬁne semantics AC program semantics corresponding nested program ground Π mixed atoms answer sets mixed atoms occur heads rules This different intended meaning atoms suppose connect values regular constants constraint counterpart We introduce notion functional set composed mixed atoms crucial deﬁning answer sets AC programs We sequence regular constants cid9r speciﬁed mixed predicate m cid9r follows sorts regular arguments m For instance program 4 sequence 0 constants type step sequence speciﬁed mixed predicate For set X atoms sequence cid9r regular constants bound X constraint constant c wrt predicate m atom mcid9r c X A set M ground mixed atoms functional underlying signature mixed predicate m sequence regular constants speciﬁed m bound M unique constraint constant wrt m For instance signature program 4 sets at0 1 at1 1 at0 2 at1 1 functional at0 1 at0 1 at0 2 functional sets Deﬁnition 1 For AC program Π set X atoms called answer set Π functional set M ground mixed atoms Σ X answer set ground Π M For example sets atoms cid2 cid3 at0 1 at1 1 occursa 0 next1 0 holds f 1 cid2 at0 0 occursa 0 at1 1 next1 0 holds f 1 okComp1 0 okComp1 5 okComp2 106 cid3 okTime0 okTime5 okTime106 5 answer sets 4 The deﬁnition answer set AC programs presented different original deﬁnition 1 restrict attention programs doubly negated atoms close relation Proposition 1 For AC program Π signature Σ Π contains doubly negated atoms set S true ground constraint literals Σ X answer set Π X S answer set sense 1 Π 3 The CLINGCON language Consider subset AC language denoted AC AC program deﬁned atoms AC The language constraint answer set solver clingcon deﬁned 237 seen syntactic variant AC language We review clingcon programs map AC programs For signature Σ aclingcon variable expression form pcid9r p mixed predicate cid9r sequence regular constants For clingcon variable pcid9r pcid9r 0 denote predicate symbol p pcid9r s denote sequence regular constants cid9r program 7 The clingcon accepts programs general syntax discussed 2 instance aggregates count allowed clingcon 6 Y Lierler Artiﬁcial Intelligence 207 2014 122 We atom clingcon atom Σ following form v 1 vk c1 cm cid14 vk1 vl cm1 cn 6 v clingcon variable ci constraint constant primitive constraint operations note denotes occurrence operation different operation occurrence cid14 primitive constraint relation A clingcon program ﬁnite set rules form 1 a0 regular atom ii ai 1 cid2 cid2 n regular clingcon atom The clingcon accepts rules a0 clingcon atom seen abbreviation rule head a0 occurring body Any clingcon program Π rewritten AC function ν maps set clingcon variables occurring Π set distinct variables Σ For clingcon variable v vν denotes variable assigned v ν For occurrence clingcon atom 6 rule r Π add set mixed atoms v 0 v s vν 1 cid2 cid2 l body r ii replace 6 r constraint atom vν 1 vν k c1 cm cid14 vν k1 vν l cm1 cn We denote resulting AC program acΠ For instance let clingcon program Π Σ1 deﬁned predicates consist single rule occursa 0 at0 cid3 110 Given ν maps at0 T cid2 occursa 0 cid4 0 T acΠ form cid2 cid3 110 T cid5 cid2 7 8 The following proposition makes relation clingcon program AC counterpart precise Proposition 2 For clingcon program Π signature Σ set X constraint answer set Π according deﬁnition 23 iff functional set M ground mixed atoms Σ X M answer set acΠ We demonstrated clingcon program seen program language AC There important class AC programs called safe In fact Mellarkod et al 1 considered programs devising algorithm program syntactically transform processing AC programs We illustrate given safe AC clingcon solving procedures program clingcon Thus languages AC proposed truly syntactic variants We deﬁne step transformation ﬁrst transforms safe AC program supersafe program corresponding clingcon program Rule 1 called deﬁned rule a0 deﬁned atom We AC program Π safe 1 variable occurring nondeﬁned rule Π occurs mixed atom rule In words constraint variable occurring nondeﬁned rule mapped sequence regular constants cid9r speciﬁed mixed predicate Consider safe sort time maps regular constant 0 sort step speciﬁed mixed predicate program 8 A constraint variable T cid2 An AC program Π supersafe Π safe 1 mixed atom mcid9c X occurs Π mixed atom mcid9c X cid2 occur Π X X cid2 distinct 2 mixed atom mcid9c X occurs Π mixed atom m cid2cid9c cid2 X cid9c cid10 cid9c cid2 mixed atom m cid2cid9c X variable names m cid10 m cid2 occurs Π For example program 4 supersafe On hand replace sixth rule 4 semantically rule 8 program supersafe safe conditions 1 2 violated Intuitively supersafeness ensures constraint variable maps uniquely sequence regular constants cid9r speciﬁed speciﬁc mixed predicate m way For instance program 4 constraint variable T sort time corresponds regular constant sort time corresponds constant 1 sort 0 sort step speciﬁed mixed predicate constraint variable T step speciﬁed cid2 We note safe AC program Π converted supersafe program resulting program answer sets Proposition 3 For safe AC program Π transformation Π produces supersafe AC program answer sets Π Appendix A presents transformation For supersafe AC program Π conΠ denote clingcon program constructed follows mixed atoms Π dropped ii constraint variable X replaced expression mcid9c mcid9c X mixed atom Π Y Lierler Artiﬁcial Intelligence 207 2014 122 7 X occurs given conditions supersafeness guaranteed unique mixed atom form mcid9c X constraint variable X Π program Π Σ1 deﬁned predicates consist single rule 8 This program clearly For instance let AC supersafe The corresponding clingcon program conΠ 7 The following proposition makes relation supersafe AC program clingcon counterpart precise Proposition 4 For supersafe program Π signature Σ functional set M ground mixed atoms Σ X M answer set Π iff set X constraint answer set conΠ according deﬁnition 23 In words Proposition 4 suggests languages AC clingcon syntactic variants 4 Weaklysimple AC programs To best knowledge acsolver ﬁrst CASP solver implemented The correctness acsolver algorithm shown simple AC programs8 We start section reviewing simple programs We deﬁne general class programs called weaklysimple In Section 6 present generalization acsolver algorithm state correctness programs A AC program Π consists deﬁned rules called deﬁned denoted ΠD By ΠR denote nondeﬁned Π Π ΠD For program 4 rules okComp1 T T cid2 5 okComp2 106 okTimeT T cid2 10 okComp1 T okTimeT T cid3 100 okComp2 T form deﬁned rules form ΠR We AC program Π simple supersafe deﬁned contains regular atoms unique answer set In weaklysimple programs deﬁne ﬁrst lift restriction deﬁned program unique answer set Second weaklysimple programs allow regular atoms deﬁned rules syntactic conditions deﬁne means predicate dependency graph For AC program Π predicate dependency graph9 Π directed graph predicates occurring Π vertices rule 1 Π edge a0 0 a0 1 cid2 cid2 l Deﬁnition 2 We AC program Π weaklysimple supersafe strongly connected component predicate dependency graph Π subset regular predicates Π deﬁned predicates It easy simple program weaklysimple program way For example program 4 weaklysimple simple deﬁned contains regular atom 5 Abstract SMODELS Most stateoftheart answer set solvers based algorithms closely related dpll procedure 14 Nieuwen huis et al described dpll means transition viewed abstract framework underlying dpll computation 15 Lierler 1920 proposed similar framework smΠ specifying answer set solver smodels following lines pseudocode description 27 Our goal design framework describing algorithm acsolver As step direction review graph smΠ underlines algorithm smodels main building blocks acsolver The presentation follows 19 For set σ atoms record relative σ list M literals σ possibly annotated cid6 marks decision literals A state relative σ record relative σ possibly preceding symbol For instance states relative singleton set atoms 8 The acsolver algorithm proved correct class safe canonical programs special case simple programs Any simple program converted canonical program means syntactic transformations discussed 1 9 A similar deﬁnition predicate dependency graph given 26 programs general syntax 8 Y Lierler Artiﬁcial Intelligence 207 2014 122 Unit Propagate M cid15 M l C l Π cl C M Decide M cid15 M lcid6 l unassigned M Fail cid6 M cid15 M inconsistent different M contains decision literals Backtrack cid6 P lcid6 Q cid15 P l All Rules Cancelled P lcid6 Q inconsistent Q contains decision literals M cid15 M B M cid10 B BodiesΠ Backchain True cid6 M cid15 M l Unfounded B Π M l B Bcid2 M cid10 B cid2 BodiesΠ B M cid15 Ma U set U unfounded M wrt Π Fig 1 The transition rules graph smΠ acid6 acid6 We state inconsistent complementary literals occur For example states aa inconsistent Frequently identify state M set literals occurring possibly symbol ignoring annotations order elements In cases identify set literals conjunction members write M cid15 φ M state cid15 understood satisﬁability relation If literal l complement l occur M l unassigned M For set M literals M denote set atoms stemming positive negative literals M respectively For instance b M b b If C disjunction conjunction literals C understand conjunction disjunction complements literals occurring C In situations identify disjunctions conjunctions literals sets literals By BodiesΠ denote set bodies rules regular program Π head We recall set U atoms occurring regular program Π unfounded 2829 consistent set M literals respect Π U B BodiesΠ M cid15 B B identiﬁed conjunction elements U B pos cid10 Each regular program Π determines Smodels graph smΠ The set nodes smΠ consists states relative set atoms occurring Π The edges graph smΠ speciﬁed transition rules presented Fig 1 A node terminal graph edge leaves node The graph smΠ deciding regular program Π answer set constructing path terminal node Following proposition serves proof correctness termination procedure captured graph smΠ Proposition 5 For regular10 program Π graph smΠ ﬁnite acyclic b terminal state M smΠ M c state reachable smΠ Π answer sets answer set Π 6 Abstract ACSOLVER 61 Query extensions consequences In order present transition suitable capturing acsolver introduce concepts Given AC program Π set p predicate symbols set X atoms pinput answer set input answer set wrt p Π X answer set Π Xp Xp denote set atoms X predicate symbols different ones occurring p For instance let X set a1 b1 atoms let p set predicates Xp b1 The set X pinput answer set program a1 b1 On hand input answer set program respect set b predicate symbols Intuitively set p denotes set intentional predicates 30 The concept pinput answer sets closely related pstable models 30 10 In 19 programs doubly negated atoms considered Extension results regular programs straightforward Y Lierler Artiﬁcial Intelligence 207 2014 122 9 Proposition 6 For nested program Π complete set X literals set p predicate symbols predicate symbols pinput answer set Π iff X model SMpΠ pstable model Π occurring heads Π form subset p X For set S literals S R S D S C denote set regular deﬁned constraint literals occurring S respectively By S RD S DC denote unions S R S D S D S C respectively By AtΠ denote set atoms occurring program Π Recall substitution Θ ﬁnite set form v 1t1 vntn v 1 vn distinct variables ti term v Given substitution Θ set X literals write XΘ result substitution For AC program Π complete query Q complete consistent set literals AtΠD R AtΠR DC For query Q Π complete query E satisfying extension Q wrt Π Q E sort respecting substitution γ variables E ground terms result substitution Eγ satisﬁes conditions 1 constraint literal l Eγ l true intended interpretation symbols 2 input answer set A ΠD wrt deﬁned predicates Π Eγ RD A Eγ RD A We literal l consequence Π Q satisfying extension E Q wrt Π l E By ConsΠ Q denote set consequences Π Q If satisfying extensions Q wrt Π identify ConsΠ Q singleton Let Π 4 Q okTimeT T cid10 1 A set cid2 okTimeT T cid10 1 cid3 forms satisfying extension Q wrt Π Indeed consider substitutions T 106 This satisfying extension Q wrt Π Consequently forms ConsΠ Q On hand satisfying extensions query okTimeT corresponds ConsΠ Q 62 The graph ACΠ For constraint deﬁned atom A signature Σ select new symbol Aξ called A By Σ ξ denote signature obtained Σ adding names Aξ additional regular predicate symbols Aξ regular atom For AC program Π Π ξ denote set rules consisting choice rules aξ constraint deﬁned atom occurring ΠR ii ΠR mixed atoms dropped constraint deﬁned atoms replaced names Note Π ξ regular program For instance let Π 4 Π ξ consists rules cid2 cid3 okTimeT ξ cid2 cid3 cid2 cid3 cid2 T cid2 cid3 110 T cid10 1ξ T cid3 110ξ occursa 0 T cid10 1ξ okTimeT ξ occursa 0 T cid3 110ξ cid2 cid3 110ξ occursa 1 T occursa 0 holds f 1 occursa 0 next1 0 next1 0 occursa 0 cid3 9 For set M atoms Σ ξ Mξ denote set atoms Σ replacing Aξ occurring M corresponding atom A For instance okTimeT ξ T cid10 1ξ ξ okTimeT T cid10 1 Let Π AC program The nodes graph ACΠ states relative set AtΠ ξ AtΠD R atoms For state M ACΠ queryM denote largest subset Mξ AtΠD R AtΠR DC For example program 4 state M occursa 0 oncid6 okTimeT ξ cid6 queryM okTimeT The edges graph ACΠ described transition rules sm Propagate presented Fig 2 We abuse notation identify ξ Π ξ additional transition rule Query The graph ACΠ deciding weaklysimple AC program Π answer set constructing path terminal node 10 Y Lierler Artiﬁcial Intelligence 207 2014 122 Query Propagate M cid15 M lξ l ConsΠ queryM Fig 2 The transition rule Query Propagate Proposition 7 For weaklysimple AC program Π graph ACΠ ﬁnite acyclic b terminal state M ACΠ Mξ R set regular atoms answer set Π c state reachable ACΠ Π answer sets Proposition 7 shows algorithms ﬁnd path graph ACΠ terminal node regarded AC solvers weaklysimple programs Let Π AC program 4 Here path ACΠ edge annotated transition rule justiﬁes presence edge graph cid15 occursa 0 Decidecid15 occursa 0 oncid6 Decidecid15 Unit Propagate occursa 0 oncid6 okTimeT ξ cid6 Query Propagate cid15 occursa 0 oncid6 okTimeT ξ cid6 Backtrackcid15 occursa 0 oncid6 okTimeT ξ Unit Propagate occursa 0 oncid6 okTimeT ξ T cid10 1ξ Unit Propagate occursa 0 oncid6 okTimeT ξ T cid10 1ξ next1 0 occursa 0 oncid6 okTimeT ξ T cid10 1ξ next1 0 holds f 1 Unit Propagate cid15 cid15 cid15 10 Since state path terminal Proposition 7 asserts cid2 cid3 occursa 0 next1 0 holds f 1 forms set regular atoms answer set Π Indeed recall answer set 5 63 acsolver algorithm We view path graph ACΠ description process search set regular atoms answer set Π applying graphs transition rules Therefore characterize algorithm solver utilizes transition rules ACΠ describing strategy choosing path graph A strategy based particular assigning priorities transition rules ACΠ solver follows transition rule state rule higher priority applicable A strategy include restrictions rules applications We use approach acsolver algorithm 1 Fig 1 The acsolver selects edges according priorities transition rules graph ACΠ follows Backtrack Fail cid20 Unit Propagate All Rules Cancelled Backchain True cid20 Unfounded cid20 Query Propagate cid20 Decide Query Propagate denote transition rule Query Propagate satisfying extensions quer yM wrt ΠD ConsΠ queryM It easy Proposition 7 holds subgraphs ACΠ constructed dropping edges Query Propagate Query Propagate Let Π AC program 4 Path 10 ACΠ comply priorities acsolver algorithm On hand path Unit Propagate cid15 Unit Propagate cid15 occursa 0 cid15 occursa 0 next1 0 Unit Propagate occursa 0 next1 0 holds f 1 Decidecid15 occursa 0 next1 0 holds f 1 oncid6 Decidecid15 occursa 0 next1 0 holds f 1 oncid6 okTimeT ξ cid6 Query Propagate cid15 occursa 0 next1 0 holds f 1 oncid6 okTimeT ξ cid6 Backtrackcid15 occursa 0 next1 0 holds f 1 oncid6 okTimeT ξ Unit Propagate cid15 occursa 0 next1 0 holds f 1 oncid6 okTimeT ξ T cid10 1ξ 11 valid path acsolver Indeed path respects fact transition rule Unit Propagate higher priority Decide Y Lierler Artiﬁcial Intelligence 207 2014 122 11 Unfounded cid2 cid6 M cid15 Ma U set U unfounded M wrt Π AtF Π HeadΠ Fig 3 The transition rule Unfounded Mellarkod et al 1 demonstrated correctness acsolver algorithm class safe canonical programs analyzing properties pseudocode Proposition 7 provides alternative proof correctness algorithm general class weaklysimple programs relies transition ACΠ Furthermore Proposition 7 encapsulates proof correctness class algorithms described ACΠ For instance immediately follows acsolver algorithm modiﬁed follow different priorities transition rules correct Note clingcon program Π acΠ weaklysimple program fact simple program It follows class algorithms captured graph AC Π applicable clingcon programs minor syntactic transformations Nevertheless graph ACΠ suitable describing clingcon In section present graph purpose 7 Abstract CLINGCON The clingcon based tight coupling answer set solver clasp constraint solver gecode The clasp starts computation building propositional formula called completion 31 given program propagation relies program completion Furthermore implements backtracking search techniques backjumping learning forgetting restarts Lierler Truszczynski 32 introduced transition smlaspF Π demonstrated captures clasp algorithm It turns smlaspF Π augmented transition rule Query Propagate appropriate describing clingcon The graph smlaspF Π extends simpler graph smaspF Π 32 These extensions essential capturing advanced features clasp clingcon conﬂict driven backjumping learning In section start reviewing graph smaspF Π showing augmenting rule Query Propagate captures basic clingcon algorithm implementing simple backtrack strategy place conﬂictdriven backjumping learning We new graph conF Π This abstract view basic clingcon allows compare acsolver formal terms To capture clingcon algorithm extend conF Π rules Backjump Learn similar manner graph smaspF Π extended graph smlaspF Π 32 We write HeadΠ set nonempty heads rules program Π For clause C a1 al al1 write C r denote rule a1 al al1 For set F clauses deﬁne F r C r C F For set A atoms Π A denote program Π extended rules atom A The transition graph smaspF Π set F clauses regular program Π deﬁned follows The set nodes smaspF Π consists states relative AtF Π There ﬁve transition rules characterize edges smaspF Π The transition rules Unit Propagate Decide Fail Backtrack graph smF r Π transition rule Unfounded presented Fig 3 Lierler Truszczynski 11 demonstrated smaspEDCompΠΠ models basic clasp conﬂictdriven jumping learning EDCompΠ denotes classiﬁed completion use auxiliary atoms Formula EDCompΠ exhibits important property Lierler Truszczynski Π safe We extend notion AC programs For AC program Π set F clauses Π safe 1 AtΠ ξ AtΠD R AtF 2 F cid15 AtΠ ξ HeadΠ ξ 3 answer set X Π ξ model M F X M HeadΠ ξ We note set F clauses Π safe Π ξ safe according safeness deﬁnition given 32 If regular atoms Π occur regular formula Π ξ cl straightforward example Π safe formula Under restriction formulas CompΠ ξ EDCompΠ ξ Π safe stands completion Π ξ formulas classiﬁed straightforward way applying distributivity We refer reader 32 precise deﬁnitions CompΠ EDCompΠ constructed Clarks completion Π 31 We AC programs satisfy restriction regular atoms Π occur regular friendly This restriction inessential atoms adding simple constraints turn nonfriendly program friendly We deﬁne graph conF Π AC programs extends smaspF Π similar way ACΠ extends smΠ For AC program Π set F clauses nodes conF Π states relative set AtF Π ξ AtΠD R The edges conF Π described transition rules smaspF Π ξ transition rule Query Propagate ACΠ 12 Y Lierler Artiﬁcial Intelligence 207 2014 122 Proposition 8 For weaklysimple AC program Π Π safe set F clauses graph conF Π ﬁnite acyclic b terminal state M conF Π Mξ R c state reachable conF Π Π answer sets AtΠ set regular atoms answer set Π For friendly programs algorithm basic clingcon modeled means graph EDCompΠ ξ Π following priorities Backtrack Fail cid20 Unit Propagate cid20 Unfounded Query Propagate cid20 Decide cid2 cid20 Proposition 8 demonstrates basic clingcon algorithm applicable clingcon programs broader class weaklysimple AC programs 71 On relation acsolver basic clingcon Following concept helps formulate relation ACΠ conF Π precisely An edge M cid15 M graph ACΠ conF Π singular cid2 transition rule justifying edge Unfounded edge M cid15 M cid2cid2 justiﬁed transition rule Unfounded Decide It easy priorities acsolver clingcon singular edges inessential Indeed given Unfounded assigned lowest priority singular edges followed transitions Unit Propagate available second condition deﬁnition singular edge We deﬁne AC Π F Π graph obtained removing singular edges ACΠ conF Π Proposition 9 For friendly AC program Π graphs AC Π CompΠ ξ Π equal It follows graph provides abstract model acsolver Hence difference abstract acsolver basic clingcon algorithms stated terms difference Π safe formulas CompΠ ξ EDCompΠ ξ applied CompΠ ξ Π 72 The conlF Π graph The clingcon algorithm incorporates backjumping learning modern techniques dplllike procedures Nieuwen huis et al 15 provide comprehensive description techniques We start brieﬂy describing main ideas We proceed deﬁning graph conlF Π allow model clingcon algorithm featuring jumping learning Consider state 12 1 lcid6 n Mn M0lcid6 1 lcid6 lcid6 n decision literals We literals li Mi belong decision level Consider state form 12 transition rule Backtrack applicable It easy rule Backtrack effect backtracking decision level n level n 1 At times safe backtrack decision level prior n 1 This process called backjumping Learning technique responsible augmenting database given clauses logic rules hope newly acquired information instrumental future search This technique proved extreme importance success modern SAT ASP technology We deﬁne graph conlF Π To accommodate fact graph capture learning introduce notion augmented state includes currently assigned literals learned information Such learned information corresponds newly derived constraints available future propagations In case clingcon constraints represented clauses We regular program Π entails clause C answer set Π M cid15 C For instance regular program consistent complete set M literals M entails rule understood clause occurring For AC program Π set F clauses augmented state relative F Π distinguished state pair MΓ M record relative set AtF Π ξ AtΠD R Γ set clauses AtF Π ξ AtΠD R F cid15 Γ Π ξ cid15 Γ For AC program Π set F clauses nodes conlF Π augmented state relative F Π The rules cid2Γ MΓ cid15 respectively Decide Unfounded Fail smaspF Π extended conlF Π follows MΓ cid15 M Y Lierler Artiﬁcial Intelligence 207 2014 122 13 Unit Propagate Learn cid7 MΓ cid15 M lΓ Backjump P lcid6 Q Γ cid15 Pl cid2Γ C l F Π ξ cl Γ C M cid6 P lcid6 Q inconsistent cid2 P cid2 P Π ξ cid15 l F cid15 l Learn MΓ cid15 MC Γ atom C occurs F Π ξ F cid15 C Π ξ cid15 C C Γ Fig 4 The additional transition rules graph conlF Π M cid15 edge edge conlF Π justiﬁed Decide Unfounded Fail respectively M cid15 M smaspF Π justiﬁed Decide Unfounded Fail respectively The transition rules conlF Π presented Fig 4 The transition rule Backjump describes essence backjumping procedure replaces backtracking The rule Learn captures essence learning terms hybrid constraint answer set solvers exempliﬁed clingcon The rule Unit Propagate Learn modiﬁcation transition rule Unit Propagate conF Π This modiﬁcation addresses effect learning Indeed unit propagate derives atoms given F Π identical sets states conlF Π set learnt clauses Γ depends particular state conlF Π We refer transition Backjump Decide Fail graph smlasp rules Unit Propagate Learn Unfounded F Π basic We node graph semiterminal rule Learn applicable We omit word augmented state clear context cid2 cid2 The graph conlF Π deciding weaklysimple AC program Π model following sense Proposition 10 For weaklysimple AC program Π Π safe set F clauses path conlF Π contains ﬁnitely edges justiﬁed basic transition rules b semiterminal state MΓ conlF Π reachable Mξ R AtΠ set regular atoms answer set Π c state reachable conlF Π Π answer sets On hand Proposition 10a asserts construct path basic transition rules periodically appear semiterminal state eventually reached On hand parts b c Proposition 10 assert soon semiterminal state reached problem deciding Π answer set solved In words Proposition 10 shows graph conlF Π gives rise class correct algorithms computing answer sets weaklysimple AC programs It gives proof correctness CASP solver class proof termination assumption basic transition rules periodically appear path constructed Nieuwenhuis et al 15 proposed transition rules model techniques forgetting restarts The graph conlF Π easily extended rules 73 clingcon algorithm The algorithm clingcon modeled means graph conlEDCompΠ ξ Π following priorities BackjumpLearn Fail cid20 Unit Propagate Learn cid20 Unfounded Query Propagate cid20 Decide cid2 cid20 By BackjumpLearn denote fact learning occurs clingcon time backjump occurs Proposition 10 demon strates clingcon algorithm applicable clingcon programs broader class weaklysimple AC programs 8 The EZCSP language algorithm language ezcsp restricts AC Balduccini 4 demonstrated ezcsp language seen subset AC language In fact subset AC requiring constraint atoms occur rules head symbol Theezcsp based loose coupling answer set solvers smodels clasp constraint logic programming systems sicstus Prolog The ezcsp treats given program regular program slight modiﬁcations accounting special treatment constraint atoms allows answer set solver ﬁnd answer set This answer set form query processed constraint logic programming This process repeated To ideas precise model ezcsp couples answer set solver smodels 14 Y Lierler Artiﬁcial Intelligence 207 2014 122 sicstus Prolog graph ACΠ The ezcsp algorithm selects edges according priorities transition rules AC Π follows Backtrack Fail cid20 Unit Propagate All Rules Cancelled Backchain True cid20 Unfounded cid20 Decide cid20 Query Propagate Note set priorities highlights difference acsolver ezcsp based smodels difference priorities transitions systems follow Indeed ezcsp follows transition Decide prior exploring transition Query Propagate Similarly use graph conlF Π capture ezcsp algorithm based answer set solver clasp It demonstrate difference clingcon ezcsp based clasp roots place difference tween acsolver ezcsp Theezcsp selects edges according priorities transition rules conlEDCompΠ ξ Π follows BackjumpLearn Fail cid20 Unit Propagate Learn cid20 Unfounded cid2 cid20 Decide cid20 Query Propagate ezcsp follows transition Decide prior exploring transition Query Propagate Furthermore unlike clingcon allows Query Propagate propagate new atoms ezcsp uses limited version transition rule particular Query Propagate In words ezcsp conclude constraint atoms program conﬂicting able derive inferences 9 Conclusions discussions future work We started paper listing number CASP languages systems acsolver clingcon ezcsp idp inca mingo recently come use attempt broaden applicability automated reasoning methods Distinguishing feature CASP solvers acsolver clingcon ezcsp combining inferences stemming traditionally different research ﬁelds This general hybrid solving illustrates importance developing synergistic approaches automated reasoning community A clear picture distinguishing features CASPlike languages underlying systems importance order facilitate developments ﬁeld This prime focus work formally states relation CASP languages acsolver clingcon ezcsp b provides systematic account algorithmic differences underlying solvers For example home lesson languages clingcon ezcsp syntactic variants AC Another lesson despite technological differences newly developed solvers acsolver clingcon ezcsp lot common This alludes possibility creating generalpurpose platform assist creation new architectures CASPlike technology To summarize technical contributions paper demonstrated formal relation AC clingcon languages algorithms acsolver clingcon We designed transition systems ACΠ conlF Π describ ing algorithms computing subsets answer sets weaklysimple AC programs We graphs specify acsolver clingcon ezcsp algorithms Compared traditional pseudocode descriptions algorithms transition sys tems use uniform graphbased language offer modular proofs The graphs ACΠ conF Π offer convenient tool compare analyze prove correctness class algorithms In fact formally relation subgraphs ACΠ conF Π graphs AC CompΠΠ equal Further transition systems acsolver clingcon result new algorithms solving larger class AC programs weaklysimple programs introduced paper Neither acsolver clingcon systems respectively deal programs In future consider ways use current ASPCLP technologies design solver weaklysimple programs Work Balduccini et al 33 step direction Π In future like uncover precise relationship idp translational solvers introduced 810 The idp language builds formalism called PCID 34 strongly related logic programs answer set semantics 32 As point formal account describing insides idp support ing CASP language The translational solvers developed 89 rely transformations CASP language ASP formalism A graph underlying ASP solver instance smlasp F Π case clasp 32 applied transfor mation devised 89 characterize solver Even introduced similar graphs ac conl capturing hybrid solvers graphs appropriate formally compare translational hybrid solvers The transition rule Query Propagate AC conl crude capture details solving occurs specialized solvers gecode sicstus Prolog To point exact differences translational solver hybrid counterpart computation specialized solver unfolded The mingo solver 10 implements CASP translating programs integer linear programs It interesting direction research study technology integer linear programming compares technology ASP CASP Y Lierler Artiﬁcial Intelligence 207 2014 122 15 Acknowledgements We grateful Yuanlin Zhang Daniel Bailey Marcello Balduccini Broes Cat Michael Gelfond Vladimir Lifschitz Max Ostrowski Peter Schueller Miroslaw Truszczynski useful discussions related topic work comments earlier drafts paper We debt reviewers paper valuable feedback allowed improve presentation Appendix A Proofs formal results We start introducing necessary terminology 1 A consistent set S ground atoms signature Σ called partial interpretation AC program Π satisﬁes following conditions 1 A constraint atom l S iff l true intended interpretation 2 The mixed atoms S form functional set wrt signature Π The deﬁnition semantics AC program follows 1 By replacing nested program ground AC program deﬁnition reduct Section 2 trivially extended ground AC programs A partial interpretation S Σ accanswer set AC program Π S minimal sense settheoretic inclusion partial interpretations Σ satisfying rules groundΠ MS M set mixed atoms occurring S We note generalization answer set deﬁnition presented 1 case programs doubly negated atoms Proposition 1 For AC program Π signature Σ set T true ground constraint literals Σ X answer set Π X T answer set sense 1 Π Proof Lefttoright Let X answer set Π By deﬁnition functional set M ground mixed atoms Π M minimal sets atoms satisfying X answer set ground cid4cid4 ground Π M cid5 X cid5 cl 13 Obviously M forms set mixed atoms occurring X Let set Y atoms model 13 It easy Y T partial interpretation ii Y T satisﬁes cid4cid4 groundΠ M cid5 XT cid5 cl 14 Indeed construction 13 14 immediately follows obtain 13 14 replacing atom T cid5 Thus Y T satisﬁes 14 iff Y satisﬁes 13 It follows X T minimal partial interpretation satisfying 14 X minimal sets atoms satisfying 13 accanswer set Π Righttoleft Let X T accanswer set Π By M denote set mixed atoms occurring X Let Y T partial interpretation satisfying 14 Using argument lefttoright direction derive Y model satisfying 13 From fact X T minimal partial interpretation satisfying 14 accanswer set Π follows X minimal model satisfying 13 cid2 A splitting set 35 nested program Π set U atoms rule r Π Headr U Atr U The set rules r Π Atr U called Π relative splitting set U denoted bU Π The set Π bU Π Π relative U By eU Π X denote program consisting rules obtained Π replacing atom U X cid5 Proposition 11 Splitting set theorem See 35 Let U splitting set nested program Π A set A atoms answer set Π iff A X Y X answer set bU Π Y answer set eU Π bU Π X For set M ground mixed atoms Σ M denote following set atoms m m ground mixed atom Σ m M set consisting ground mixed atoms Σ M Observation 1 A set atoms answer set nested program Π answer set regular program constructed Π 16 Y Lierler Artiﬁcial Intelligence 207 2014 122 dropping rules occurs Bpos Bneg2 cid5 occurs Bneg dropping cid5 cid5 rest rules This observation equivalent transformations programs nested expressions 24 Proposition 2 For clingcon program Π signature Σ set X constraint answer set Π according deﬁnition 23 iff functional set M ground mixed atoms Σ X M answer set acΠ Proof It easy acΠ supersafe program construction function V deﬁnition Lefttoright Let X constraint answer set Π according deﬁnition 2 Then assignment A V Π DΠ X answer set Π A deﬁned 2 V Π denotes set clingcon variables occurring Π DΠ set constraint constants For clingcon variable c Π Ac denote constraint constant assigned A c Let construct substitution γ A follows clingcon variable c Π add c V Ac γ For clingcon variable pcid9r pcid9rM denote mixed atom pcid9r pcid9rV We mixed atom matching pcid9r Let S denote set matching mixed atoms constructed clingcon variables occurring Π It easy Sγ functional set ground mixed atoms Let M Sγ We X M answer set acΠ By deﬁnition X M answer set acΠ X M answer set cid4 cid5 acΠ M ground By Proposition 11 X M answer set 15 iff X answer set cid4 cid5 acΠ ground 15 16 The transformation described Observation 1 applied 16 result Π A We given X answer set Π A Consequently answer set 16 Righttoleft Let M functional set ground atoms Σ X set ground atoms X M answer set acΠ Let V Π denote set clingcon variables occurring Π From fact M functional set follows variable pcid9r V Π atom form pcid9r c M We construct assignment A V Π follows variable pcid9r V Π Apcid9r c pcid9r c M By deﬁnition answer set AC program X M answer set 15 Furthermore Proposition 11 X answer set 16 From Π A construction follows transformation described Observation 1 applied 16 result Π A We given X answer set Π A Consequently X answer set Π A constraint answer set Π cid2 Proposition 3 For safe AC program Π transformation Π produces supersafe AC program answer sets Π Proof In proof cid9c denotes sequence regular constants m denotes mixed predicate Let T denote following transformation For sequence constants cid9c m cid9c speciﬁed m Associate unique new variable cid22m cid9ccid23 denoted Y cid22mcid9ccid23 For rule r Π cid2 Let r r For variable X r Let m1cid9c1 X mkcid9ck X mixed atoms r Replace mi cid9ci X r mi cid9ci Y cid22mi cid9ci cid23 1k Add Y cid22m1 cid9c1cid23 Y cid22mi cid9ci cid23 r Replace occurrence X r cid2 cid2 cid2 Y cid22m1 cid9c1cid23 Let Π cid2 new program produced transformation T It easy Π cid2 unique new variable associated pair cid22m cid9ccid23 Π cid2 supersafe program supersafe program constructed Π preserve requirements To prove Π Π cid2 set ground Proposition 11 follows set X atoms answer set ground answer sets let M functional set It easy M splitting Π cid2 M programs formed set rules By Π M Π iff X answer set Π M ground cid4 e M ground Π M X cid5 17 Similarly X answer set ground cid4 cid4 cid5 cid5 cid2 e M ground Π M X Y Lierler Artiﬁcial Intelligence 207 2014 122 Π cid2 M Π cid2 iff answer set 17 18 It easy transformation described Observation 1 applied 17 18 results program Thus set X atoms answer set Π iff answer set Π cid2 cid2 Proposition 4 proved spirit Proposition 2 We refer reader 30 review operator S M state formal results 30 26 form convenient presentation Proposition 12 Special case Theorem 1 See 30 For nested program Π complete set X literals AtΠ following conditions equivalent answer set Π X X pstable model 30 p list predicate symbols Π X model SMpΠ Proposition 13 Special case Symmetric Splitting Theorem See 26 Let Π Π cid2 tuples distinct predicate symbols If nested programs let p q disjoint strongly connected component predicate dependency graph Π Π cid2 atom predicate symbols q occurs head Π atom predicate symbols p occurs head Π cid2 subset p subset q SMpqΠ Π cid2 equivalent SMpΠ SMqΠ cid2 For set A atoms pred A denote set predicate symbols atoms A We abuse notation use predΠ denote set predicate symbols occurring program Π Proposition 6 For nested program Π complete set X literals set p predicate symbols predicate symbols occurring heads Π form subset p predHeadsΠ p X pinput answer set Π iff X model S MpΠ pstable model Π Proof By deﬁnition X answer set Π X p iff X model pinput answer set Π iff X SMpredΠ pred X p cid11 Π X cid12 p From fact predHeadsΠ p follows X p HeadsΠ answer set Π X p By Proposition 12 X 19 atoms predicate symbols different p occur heads facts X Proposition 13 19 equivalent p Consequently SMpredΠ Π SMpred X p cid11 cid12 p X 20 Obviously set X model second conjunct 20 We derive X model 20 iff X model SMpredΠΠ Recall predHeadsΠ p By Proposition 13 following expressions equivalent SMpredΠΠ SMpredHeadsΠΠ SMpΠ cid2 Weaklysimple AC programs satisfy important syntactic properties allow characterize answer sets means queries based The proof Proposition 7 relies alternative characterization precise Lemma 1 To state lemma introduce concepts rely proof For AC program Π query Q based Π complete consistent set literals AtΠD R AtΠR DC If Q satisfying extension substitution γ variables Q ground terms result Q γ satisﬁes conditions 1 2 deﬁnition satisfying extension We Q γ interpretation Q We queries satisﬁable queries satisfying extensions 18 Y Lierler Artiﬁcial Intelligence 207 2014 122 For AC program Π query Q based Π ΠQ denote program constructed Π 1 eliminating ΠD 2 dropping removing occurrence mixed atom 3 replacing atom cid5 Q DC 4 replacing atom Q DC 5 regular literal l Q R adding rule l l atom l literal It easy query Q based AC program Π ΠQ nested program For instance let Π program 4 A query Q consisting literals cid2 okTimeT T cid10 1 cid3 based Π Program ΠQ follows occursa 0 cid5 cid5 occursa 0 Let Q 1 query based Π consisting literals cid2 okTimeT T cid10 1 cid3 Program ΠQ follows occursa 0 cid5 occursa 0 An expression term atom rule Given substitution Θ expression e write eΘ result replacing v e ti cid2 n Recall set S literals S R S D S C denote set regular deﬁned constraint literals occurring S respectively By SMix denote set mixed literals occurring S We rule 1 a0 constraint Lemma 1 For weaklysimple AC program Π Π answer set iff query Q based Π Q satisﬁable wrt Π ΠQ answer set Furthermore I query interpretation Q wrt Π X answer set ΠQ X I D subset answer set Π X set regular atoms Proof Lefttoright Assume Π answer set Let S complete consistent set ground11 literals Σ answer set Π By deﬁnition answer set exists functional set M ground mixed S atoms Σ S answer set nested program ground Π M It suﬃcient construct satisﬁable query based Π ΠQ answer set We start constructing query Q based Π S Then demonstrate Q satisﬁable wrt Π ii ΠQ answer set Let ΠMix subset ΠR consists rules ΠR bodies contain mixed deﬁned constraint literals Since Π weaklysimple program weaklysimple program safe follows rule ΠMix contains mixed atom From fact M functional set mixed atoms Π weaklysimple program supersafe conditions 1 2 follows rule r ΠMix substitution Θ rΘ groundΠ mixed atom m occurring rΘ occurs M furthermore substitution Θ cid2 different Θ mixed atom m occurring rΘ cid2 occurs M Let denote rule rΘ corresponds r groundΠ rgroundΠ M 11 We omit word ground clear context We construct query Q follows Y Lierler Artiﬁcial Intelligence 207 2014 122 19 1 Let Q contain regular literal S R atom occurs ΠD 2 For rule r ΠMix Ξ denote substitution rΞ rgroundΠ M let Q contain deﬁned atom d d occurs r dΞ S b deﬁned literal d atom d occurs r dΞ S c constraint atom c c occurs r cΞ true intended interpretation symbols d constraint literal c c occurs r cΞ false intended interpretation symbols D D From query Q construction fact ΠMix consists rules ΠR bodies contain mixed deﬁned constraint literals immediately follows Q based Π Let γ union Ξ rule r ΠMix Ξ substitution rΞ rgroundΠ M From fact Π weaklysimple program supersafe choice Ξ relies functional set M mixed atoms follows γ substitution In order demonstrate ii introduce following notation state additional observations By RΠ DΠ MixΠ denote set regular deﬁned mixed predicates Π respectively From Propositions 12 13 fact Π weaklysimple program follows S answer set Π iff S model SMRΠ MixΠ cid11 ground ΠR M cid12 SMDΠ cid11 ground cid12 ΠD 21 Consequently S model cid11 cid12 ΠD SMDΠ ground By Proposition 6 S DΠ This constitutes observation input answer set ground ΠD wrt DΠ Hence S input answer set ΠD wrt Similarly S model SMRΠ MixΠ cid11 ground ΠR M cid12 22 Furthermore Proposition 13 22 fact mixed atoms appear heads facts M follows S model cid11 SMRΠ ground cid12 ΠR By Proposition 6 S input answer set ground ΠR wrt RΠ This constitutes observation b We Q γ query interpretation query Q wrt Π From Q construction conditions 2c 2d follows constraint literal l Q γ l true intended interpretation symbols It left input answer set A ΠD wrt deﬁned predicates Π Q γ A RD Let A S recall observation construction Q conditions 2a 2b A Q γ RD ii We ΠQ answer set Recall observation b By deﬁnition input answer set S answer set ground ΠR S RΠ Recall set X atoms Xp denote set atoms X predicate symbols different ones occurring p It easy S Mix In words ground RΠ equal ΠR S RΠ S S D ground ΠR S D D S S Mix Mix S It easy S program constructed 23 Mix splitting set 23 By Proposition 11 S S D S Mix answer set 23 D S eliminating facts S replacing atom cid5 S replacing atom S S Mix D D D S S Mix Mix It easy transformation described Observation 1 applied program ΠQ constraints introduced step 5 ΠQ construction results program It easy constraints Mix answer set satisﬁed S D ΠQ Consequently answer set ΠQ Mix By Theorem Constraints 24 follows S S S S S D Righttoleft Assume query Q based Π Q satisﬁable wrt Π ΠQ answer set We Π answer set From fact Q satisﬁable follows interpretation I Q wrt Π By deﬁnition interpretation substitution γ Q γ I 20 Y Lierler Artiﬁcial Intelligence 207 2014 122 By safety condition weaklysimple programs variable X occurs rule Π occurs mixed atom rule Let deﬁne substitution γ cid2 follows extends substitution γ Xv X variable X rule X occurs occurs v X arbitrary constant sort X recall sorts nonempty By γ cid2 Let M ground set mixed atoms AtΠMixγ cid2 mγ cid2 M From fact Π supersafe program follows M functional set Σ construction variable AtΠMix occurs γ cid2 atom m AtΠMixγ cid2 By deﬁnition answer set AC program demonstrate Π answer set suﬃcient Π M ground 24 answer set It obvious M M splitting set 24 By Proposition 11 24 answer set iff program constructed 24 dropping facts M dropping rules contain mixed atoms M removing atoms M remaining rules We denote ground program Π M By Proposition 12 Π M answer set iff model SMDΠ RΠ cid11 cid12 Π M Indeed DΠ RΠ form set predicate symbols program By Proposition 13 25 equivalent cid11 Π MR cid12 SMDΠ cid11 Π MD cid12 SMRΠ That equivalently rewritten cid11 ground SMDΠ Π MR SMRΠ cid12 cid11 cid12 ΠD 25 26 Consider complete consistent set Y ground regular literals Y answer set ΠQ By assumption Y exists By condition 5 ΠQ construction follows I R Y By Theorem Constraints 24 constructed ΠQ dropping constraints ΠQ follows Y derived condition 5 We note transformation described Observation 1 applied ΠQ cid2 results program identical Π MR We derive Y answer set program ΠQ cid2 answer set Π MR R From fact I A Q query interpretation follows input answer set A ΠD wrt DΠ A Furthermore Proposition 11 Q R input answer set deﬁnition fact I R Y follows complete consistent set Z ground nonconstraint literals Σ Y Z I D Z Z input answer set ΠD wrt DΠ By Proposition 6 Z model cid11 A note Q R I R ii I A I D D answer set Π MR Proposition 12 follows Y model cid12 ΠD SMDΠ ground From fact Y cid11 cid12 SMRΠ Π MR Since Y Z Z model 28 27 28 From 27 28 derive Z model 26 Consequently Π answer set cid2 We establish relation answer sets Π ξ ΠQ For set M atoms Σ Mξ denote set atoms Σ ξ replacing constraint deﬁned literal A occurring M corresponding Aξ For instance T cid10 1 acceptTimeT ξ cid2 T cid10 1ξ acceptTimeT ξ cid3 Lemma 2 For weaklysimple AC program Π query Q based Π set X atoms AtΠR Q answer set ΠQ iff X Q DC ξ answer set Π ξ R X X Proof By ΠQ cid2 DC ξ Q condition 5 It easy set Q splitting set consists choice rules atom occurring Q DC ξ It follows Q Let U denote Q denote program constructed ΠQ dropping constraints ΠQ derived DC ξ splitting set Π ξ The Π ξ relevant DC ξ answer set DC ξ coincides ΠQ cid2 DC ξ Q Lefttoright Let X answer set ΠQ By Theorem Constraints 24 follows X answer DC ξ Note eU Π ξ bU Π ξ Q DC ξ answer set Π ξ By Proposition 11 X Q DC ξ answer set Π ξ By Proposition 11 follows X answer set ΠQ cid2 set program ΠQ cid2 Righttoleft Let X Q X Theorem Constraints 24 follows X answer set ΠQ cid2 From fact Q R Y Lierler Artiﬁcial Intelligence 207 2014 122 21 Proposition 7 For weaklysimple AC program Π graph ACΠ ﬁnite acyclic b terminal state M ACΠ Mξ R set regular atoms answer set Π c state reachable ACΠ Π answer sets Proof Part proved proof Proposition 1 19 b Let M terminal state Recall sm set Π ξ It obvious queryM forms query based Π queryM Mξ R answer set ΠqueryM Furthermore Query Propagate applicable conclude Π ξ subgraph ACΠ From Proposition 5 follows M answer Mξ R By Lemma 2 follows R cid4 cid5 ΠD queryM Cons Mξ different Consequently queryM satisﬁable query By Lemma 1 Mξ R set regular atoms answer set Π c Lefttoright Since reachable inconsistent state M decision literals exists path M M form Case 1 M form l1 ln From Lemma 5 19 follows answer set Π ξ satisﬁes l1 ln On hand appears M application transition rule Query Propagate ConsΠD queryl1 ln In words exists satisfying extension queryl1 ln wrt ΠD From Lemmas 2 1 follows Π answer sets Case 2 M form l1 ln li atom From Lemma 5 19 follows answer set Π ξ satisﬁes l1 ln Since l1 ln inconsistent conclude Π ξ answer sets From Lemmas 2 1 follows Π answer sets Righttoleft From follows path terminal state By b state different Π answer sets cid2 Proposition 14 See 32 Proposition 5 Let Π regular program For Π safe 32 set F clauses set X atoms answer set Π X M AtΠ model M F Π Proposition 15 See 32 Proposition 7 For SMASP theory F Π graph smaspF Π ﬁnite acyclic b terminal state M smaspF Π M model F Π c state reachable smaspF Π F Π models Proposition 8 For weaklysimple AC program Π Π safe set F clauses graph conF Π ﬁnite acyclic b terminal state M conF Π Mξ R c state reachable conF Π Π answer sets AtΠ set regular atoms answer set Π Proof The proof proposition follows lines proof Proposition 7 relying Propositions 14 15 cid2 Proposition 9 For friendly AC program Π graphs AC Π CompΠ ξ Π equal Proof The proof proposition immediately follows Proposition 8 32 fact graphs AC Π CompΠ Π differ sm Π smasp CompΠ Π graphs respectively transition rule Query Propagate cid2 Proof Proposition 10 follows lines proof Proposition 7 Proposition 14 Proposition 9 32 22 References Y Lierler Artiﬁcial Intelligence 207 2014 122 1 VS Mellarkod M Gelfond Y Zhang Integrating answer set programming constraint logic programming Ann Math Artif Intell 53 2008 251287 2 M Gebser M Ostrowski T Schaub Constraint answer set solving Proceedings 25th International Conference Logic Programming ICLP Springer 2009 pp 235249 3 M Ostrowski T Schaub Asp modulo csp The clingcon Theory Practice Logic programming Theory Pract Log Program 12 2012 485503 4 M Balduccini Representing constraint satisfaction problems answer set programming Proceedings ICLP Workshop Answer Set Program ming Other Computing Paradigms ASPOCP 2009 httpswwwmatunicalitASPOCP09 5 J Wittocx M Mariën M Denecker The idp model expansion extension classical Proceedings Workshop Logic Search Computation Structures Declarative Descriptions LaSh 2008 pp 153165 electronic available httpsliriaskuleuvenbebitstream1234567892298141lash08pdf logic 6 I Elkabani E Pontelli TC Son Smodels clp applications A simple effective approach aggregates asp B Demoen V Lifschitz Eds ICLP Lect Notes Comput Sci vol 3132 Springer 2004 pp 7389 7 S Baselice PA Bonatti M Gelfond Towards integration answer set constraint solving M Gabbrielli G Gupta Eds ICLP Lect Notes Comput Sci vol 3668 Springer 2005 pp 5266 8 C Drescher T Walsh Translationbased constraint answer set solving Proceedings 22nd International Joint Conference Artiﬁcial Intelli gence IJCAI AAAI Press 2011 pp 25962601 9 C Drescher T Walsh A translational approach constraint answer set solving Theory Practice Logic programming Theory Pract Log Program 10 2011 465480 10 G Liu T Janhunen I Niemelä Answer set programming mixed integer programming Principles Knowledge Representation Reasoning Proceedings 13th International Conference AAAI Press 2012 pp 3242 11 I Niemelä P Simons Extending Smodels cardinality weight constraints J Minker Ed LogicBased Artiﬁcial Intelligence Kluwer 2000 pp 491521 12 M Gebser B Kaufmann A Neumann T Schaub Conﬂictdriven answer set solving Proceedings 20th International Joint Conference Artiﬁcial Intelligence IJCAI07 MIT Press 2007 pp 386392 13 C Schulte PJ Stuckey Eﬃcient constraint propagation engines Trans Program Lang Syst 2008 14 M Davis G Logemann D Loveland A machine program theorem proving Commun ACM 5 7 1962 394397 15 R Nieuwenhuis A Oliveras C Tinelli Solving SAT SAT modulo theories From abstract DavisPutnamLogemannLoveland procedure DPLLT J ACM 53 6 2006 937977 16 T Eiter G Brewka M DaoTran M Fink G Ianni T Krennwallner Combining nonmonotonic knowledge bases external sources S Ghilardi R Sebastiani Eds 7th International Symposium Frontiers Combining Systems FroCos 2009 Lecture Notes Artiﬁcial Intelligence vol 5749 Springer 2009 pp 1842 17 T Eiter G Ianni R Schindlauer H Tompits A uniform integration higherorder reasoning external evaluations answer set programming Proceedings International Joint Conference Artiﬁcial Intelligence IJCAI Professional Book Center 2005 pp 9096 18 G Brewka T Eiter Equilibria heterogeneous nonmonotonic multicontext systems Proceedings National Conference Artiﬁcial Intelligence AAAI AAAI Press 2007 pp 385390 19 Y Lierler Abstract answer set solvers Proceedings International Conference Logic Programming ICLP Springer 2008 pp 377391 20 Y Lierler Abstract answer set solvers backjumping learning Theory Pract Log Program 11 2011 135169 21 Y Lierler Y Zhang A transition AC language algorithms Proceedings ICLP Workshop Answer Set Programming Other Com puting Paradigms ASPOCP 2011 httpwwwdbaituwienacatprojaspocp11acceptedhtml 22 Y Lierler On relation constraint answer set programming languages algorithms Proceedings AAAI Conference Artiﬁcial Intelligence MIT Press 2012 23 A Kakas R Kowalski F Toni Abductive logic programming J Log Comput 2 1992 719770 24 V Lifschitz LR Tang H Turner Nested expressions logic programs Ann Math Artif Intell 25 1999 369389 25 P Ferraris V Lifschitz Weight constraints nested expressions Theory Pract Log Program 5 2005 4574 26 P Ferraris J Lee V Lifschitz R Palla Symmetric splitting general theory stable models Proceedings International Joint Conference Artiﬁcial Intelligence IJCAI IJCAI Press 2009 pp 797803 27 P Simons Extending stable model semantics expressive rules Logic Programming Nonmonotonic Reasoning Proceedings Fifth Intl Conf Lecture Notes Artiﬁcial Intelligence vol 1730 Springer 1999 pp 305316 28 A Van Gelder K Ross J Schlipf The wellfounded semantics general logic programs J ACM 38 1991 620650 29 J Lee A modeltheoretic counterpart loop formulas Proceedings International Joint Conference Artiﬁcial Intelligence IJCAI Professional Book Center 2005 pp 503508 30 P Ferraris J Lee V Lifschitz Stable models circumscription Artif Intell 175 2011 236263 31 K Clark Negation failure H Gallaire J Minker Eds Logic Data Bases Plenum Press New York 1978 pp 293322 32 Y Lierler M Truszczynski Transition systems model generators unifying approach 27th Intl Conference Logic Programming ICLP11 Theory Pract Log Program Special Issue 11 2011 629646 33 M Balduccini Y Lierler P Schueller Prolog ASP inference roof Proceedings 12th International Conference Logic Programming Nonmonotonic Reasoning Springer 2013 pp 148160 34 M Mariën J Wittocx M Denecker M Bruynooghe SATID Satisﬁability propositional logic extended inductive deﬁnitions Theory Applications Satisﬁability Testing 11th International Conference SAT Springer 2008 pp 211224 35 ST Erdogan V Lifschitz Deﬁnitions answer set programming V Lifschitz I Niemelä Eds Proceedings International Conference Logic Programming Nonmonotonic Reasoning LPNMR Springer 2004 pp 114126