Artiﬁcial Intelligence 175 2011 79119 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Approximation action theories application conformant planning Phan Huy Tu Tran Cao Son b Michael Gelfond c A Ricardo Morales c Microsoft Corporation 1 Microsoft Way Redmond WA 98052 USA b Computer Science Department New Mexico State University Las Cruces NM 88003 USA c Computer Science Department Texas Tech University Lubbock TX 79409 USA r t c l e n f o b s t r c t Article history Available online 3 April 2010 Keywords Reasoning action change Knowledge representation Planning Incomplete information Answer set programming This paper describes methodology building conformant planners based recent advances theory action change answer set programming The development planner given dynamic domain starts encoding knowledge ﬂuents actions domain action theory D action language Our choice paper AL action language dynamic static causal laws executability conditions An action theory D AL deﬁnes transition diagram T D cid4cid5 belongs T D containing possible trajectories domain A transition cid3s s cid4 iff execution action state s domain state s The second step planner development consists ﬁnding deterministic transition diagram T lpD nodes T lpD partial states D arcs labeled actions path T lpD initial partial state δ0 partial state satisfying T D The transition diagram goal δ f corresponds conformant plan δ0 δ f T lpD called approximation T D We claim concise description approximation T D given logic program π D answer sets semantics Moreover complex initial situations constraints plans expressed logic programming rules included π D If possible problem ﬁnding parallel sequential conformant plan reduced computing answer sets π D This general purpose answer set solvers If plans sequential long method time consuming In case π D speciﬁcation procedural graph searching conformant planning algorithm The paper illustrates methodology building conformant planners work domains complex relationship ﬂuents The eﬃciency planners experimentally evaluated number new old benchmarks In addition subclass action theories AL planners complete T lpD δ0 state satisfying goal δ f conformant plan δ0 δ f T D 2010 Elsevier BV All rights reserved 1 Introduction A conformant planner program generates sequence actions achieves goal possible initial state world given information initial state possible effects actions Such sequences normally referred conformant plans In paper methodology design implementation Corresponding author Email addresses tuphanmicrosoftcom PH Tu tsoncsnmsuedu TC Son mgelfondcsttuedu M Gelfond ricardocsttuedu AR Morales 00043702 matter 2010 Elsevier BV All rights reserved doi101016jartint201004007 80 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 conformant planners The methodology rooted ideas declarative programming 42 utilizes recent advances answer set programming theory action change This allows designer guarantee substantially higher degree trust planners correctness greater degree elaboration tolerance 43 The design declarative solution problem P normally involves selection logical language capable representing knowledge relevant P We base methodology representing knowledge action languages formal models parts natural language reasoning actions effects A theory action language called action description succinctly collection possible trajectories given dynamic domain Usually deﬁning transition diagram T D action description D The states T D correspond possible physical states domain represented D Arcs T D labeled actions A transition cid3s s In action languages actions elementary atomic In action viewed ﬁnite nonempty collection elementary actions Intuitively execution action e1 en ei s elementary actions corresponds simultaneous execution ei cid4cid5 T D execution action state s domain state s cid4 There large number action languages instance 82425324167 capturing different aspects dynamic domains Our choice paper AL 8 action language dynamic causal laws describing direct effects actions impossibility conditions stating conditions action executed static causal laws aka state constraints describing static relations ﬂuents For example statement putting block A block B causes A B viewed dynamic causal law describing direct effect action A B The statement block A B block located A B represents impossibility condition The statement block A block C A C B B C example recursive static causal law Note static causal laws cause actions indirect effects Consider instance effects executing action A B state A B clear B located block C The direct effects action described dynamic causal law A B An indirect effect A C obtained static causal law The problem determining indirect effects known ramiﬁcation problem remained open comparatively long time In decade solutions problem proposed example 53828 374153544664 One solutions 41 incorporated semantics AL The ability represent causal laws makes AL powerful modeling language It successfully instance model reactive control space shuttle 4 The consists fuel oxidizer tanks valves plumbing needed provide propellant maneuvering jets shuttle It includes electronic circuitry control valves fuel lines prepare jets receive ﬁring commands Overall complex includes 12 tanks 44 jets 66 valves 33 switches 160 commands computergenerated signals The use static causal laws including recursive ones crucial modeling development industrial size planning diagnostic applications While static causal laws intensively studied researchers interested knowledge representation rarely considered mainstream planning community Although original speciﬁcation Planning Domain Description Language PDDL language frequently speciﬁcation planning problems planning com munity includes axioms1 correspond nonrecursive static causal laws terminology 27 planning domains investigated community including planning competitions 11740 include axioms This partly fact semantics PDDL axioms clearly speciﬁed partly somewhat mistaken apparently widespread belief static causal laws replaced dynamic causal laws There fortunately opposing view For instance 63 authors argue use axioms increases expressiveness elegance problem representation improves performance planners It known complexity conformant planning problem higher classical planning deterministic domains Σ P 2 vs NPcomplete 668 question eﬃciency important An action description D AL describing corresponding dynamic domain multiple purposes cluding classical planning diagnostics instance 34735 One way attack problem replace transition diagram T D deterministic transition diagram T lpD nodes T lpD partial states D arcs labeled actions path T lpD initial partial state δ0 partial state satisfying δ f corresponds conformant plan δ0 δ f T D The transition diagram T lpD called approximation T D Even T lpD normally states T D validating given sequence actions conformant plan T lpD easier As pointed 6 use approximation substantially help reduce complexity planning problem Indeed approximation domains incomplete information static causal laws developed applied successfully context conditional conformant planning 66 Of course drawback approach possible incompleteness approximation based planners existence solvable planning problems planner ﬁnd solution According methodology second step development conformant planner consists ﬁnding suitable approximation T D We claim concise description approximation T D given logic program π D answer sets semantics 2662 Moreover complex initial situations constraints plans 1 In view static causal laws represent relationships ﬂuents considered axioms PDDL PH Tu et al Artiﬁcial Intelligence 175 2011 79119 81 expressed logic programming rules included π D If possible problem ﬁnding parallel sequential conformant plan reduced computing answer sets π D This general purpose answer set solvers 193355 If plans sequential long method time consuming In case designer use π D speciﬁcation procedural graph searching conformant planning algorithm This paper illustrates proposed methodology building conformant planners input action description AL incomplete description initial situation description goal In summary main contributions paper A new approach deﬁning computing approximation transition graph action theories incomplete initial situation static causal laws parallel actions A suﬃcient condition completeness reasoning andor planning tasks employ approximated transition diagram instead possible world semantics Different approximationbased planners generate sequential andor parallel conformant plans These include planner CPasp CpA The logic programming based planner generate minimal parallel conformant plans heuristic forward search planner implemented C generate sequential plans The introduction fairly simple planning problems static causal laws appear challenging contemporary planners In addition discuss complex initial situations andor constraints planning problem easily incorporated logic programming based planner The paper organized follows In section review basics language AL including syntax semantics logic programming representation transition diagrams speciﬁed AL action theories problem conformant planning In Section 3 introduce notion approximation AL action theories deﬁne deterministic approximation action theory D means logic program π D In Section 4 imple mentation answer set programming paradigm conformant planner based approximation investigate completeness Section 5 Section 6 extends results previous section planning problems disjunc tive initial states In Section 7 heuristic based sequential planner basic component module computing approximation We provide comparative study performance planners stateoftheart conformant planners Section 8 We discuss advantages use logic programming conformant planning Section 9 conclude Section 10 2 Background We begin short review syntax semantics language AL domains static causal laws 867 notion planning problem solutions 21 Syntax The signature Σ action theory AL consists disjoint nonempty sets symbols set F ﬂuents set A elementary actions By action mean nonempty set elementary actions Informally execution action interpreted simultaneous execution components For simplicity identify elementary action e action e A ﬂuent literal literal short l ﬂuent negation By l denote ﬂuent literal complementary l f f f f An AL action theory set statements following forms e causes l ψ l ψ impossible ψ 1 2 3 e elementary action action l ﬂuent literal ψ set ﬂuent literals signature Σ The set ﬂuent literals ψ referred precondition corresponding statement When precondition ψ statement omitted Statement 1 called dynamic causal law says e executed state satisfying ψ l hold resulting state Statement 2 called static causal law says state satisfying ψ satisfy l Statement 3 called impossibility condition says action executed state satisfying ψ To illustrate syntax AL let consider instance variant Bomb toilet domain 45 Example 1 There packages p1 p2 toilets t1 t2 Each packages contain bomb disarmed dunking package toilet Dunking package toilet clogs toilet Flushing toilet unclogs We safe packages disarmed 82 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Meta variables pi s stand packages 1 2 p1 cid7 p2 t j s stand toilets j 1 2 t1 cid7 t2 Fluents armedpi package pi contains bomb cloggedt j toilet t j clogged safe bombs disarmed Actions dunkpi t j dunk package pi toilet t j ﬂusht j ﬂush toilet t j Action theory impossible dunkpi t j ﬂusht j impossible dunkp1 t j dunkp2 t j impossible dunkpi t1 dunkpi t2 impossible dunkpi t j cloggedt j dunkpi t j causes armedpi dunkpi t j causes cloggedt j ﬂusht j causes cloggedt j safe armed1 armed2 safe armed1 safe armed2 Fig 1 Dbomb bomb toilet theory Fig 1 shows action theory AL denoted Dbomb describes domain2 There impossibility state ments action theory The ﬁrst says impossible dunk package toilet ﬂushed The second states impossible dunk different packages toilet time The says impossible dunk package different toilets time Unlike ﬁrst statements specify physical impossibilities concurrent actions speciﬁes physical impossibility elementary action It says impossible dunk package clogged toilet In addition impossibility statements action theory includes statements effects actions dunk ﬂush relationship ﬂuents safe armed 22 Semantics Intuitively AL action theory describes transition diagram containing possible trajectories corresponding domain Before providing precise deﬁnition transition diagram let introduce terminology notation Given action theory D set σ ﬂuent literals consistent contain complementary ﬂuent literals We σ complete ﬂuent f f f belongs σ A ﬂuent literal l holds σ l belongs σ l possibly holds σ l belong σ A set γ ﬂuent literals holds resp possibly holds σ ﬂuent literal γ holds resp possibly holds σ A set ﬂuent literals σ closed static causal law 2 l holds σ ψ holds σ By ClDσ denote smallest set ﬂuent literals contains σ closed static causal laws D A state s complete consistent set ﬂuent literals closed static causal laws D An action b said prohibited s D contains impossibility condition 3 ψ holds s b b said executable s An action executable set states S executable state s S Given state s action executable s ﬂuent literal l called direct effect s exists dynamic causal law 1 e ψ holds s By dea s denote set direct effects s The action theory D describes transition diagram T D nodes correspond possible physical states domain arcs labeled actions The transitions diagram deﬁned follows Deﬁnition 1 For action states s s ClDdea s s s cid4 cid4 transition cid3s s cid4cid5 T D iff executable s s cid4 cid4 Intuitively cid3s s state s Such state s context simply s concurrent actions equation Deﬁnition 1 equivalent proposed 41 cid4cid5 T D indicates state s execution called possible successor state s result execution If action clear possible successor state s It worth note action theories cid4 cid4 Example 2 Consider action theory Dbomb Example 1 Let 2 Note description action theory use typed variables A statement variables understood shorthand collection ground instances PH Tu et al Artiﬁcial Intelligence 175 2011 79119 83 cid2 s0 armed1 armed2 clogged1 clogged2 safe cid3 Then cid2 cid3 dunk1 1 dunk2 2 cid2 s1 armed1 armed2 clogged1 clogged2 safe cid3 unique successor state s0 cid3s0 s1cid5 T Dbomb cid5 dea s0 s0 s1 cid3 armed1 armed2 clogged1 clogged2 cid4cid2 cid4 ClDbomb cid5 ClDbomb cid2 armed1 armed2 clogged1 clogged2 safe cid3 s1 Note safe belongs closure σ armed1 armed2 clogged1 clogged2 Dbomb contains static causal law safe armed1 armed2 armed1 armed2 hold σ Now let cid2 b cid3 dunk1 1 ﬂush2 Then cid2 s2 armed1 armed2 clogged1 clogged2 safe cid3 unique successor state s0 cid3s0 b s2cid5 T Dbomb We deﬁne notion consistent action theory Deﬁnition 2 Consistent action theory An action theory D consistent state s action executable s exists state s cid3s s cid4cid5 T D cid4 Observe action ALtheories nondeterministic determining given action theory consistent simple task Indeed prove following complexity result Theorem 1 Deciding given action theory consistent NPcomplete problem The proof theorem straightforward reformulation similar result 68 presented It worth mentioning problem Pproblem action theories static causal laws Example 3 Consistent inconsistent action theories Consider following action theory cid6 D0 e causes f g e causes f h cid4 We e executable s f g h If s s deﬁnition implies D0 inconsistent This contradiction s cid4 cid4 However add D0 following impossibility condition successor state s easy f f belong consistent Hence exists successor state s According impossible e g h action theory consistent e executed state g h holds Hence dynamic causal laws takes effect guarantees consistency theory The consistency action theory ensures execution legal action state yields possible successor state In paper interested consistent action theories We deﬁne notion deterministic action theory 84 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Deﬁnition 3 Deterministic action theory An action theory D deterministic state s action exists state s cid3s s cid4cid5 T D cid4 It easy action theory D contain static causal laws deterministic In presence static causal laws action theory nondeterministic3 The following example shows action theory Example 4 Nondeterministic action theory Consider following action theory cid7 D1 e causes f g f h h f g Let s0 f g h We verify cid3s0 e s1cid5 T D1 cid3s0 e s2cid5 T D1 s1 f h g s2 f g h Hence deﬁnition D1 nondeterministic For later discussion following deﬁnition useful Deﬁnition 4 Entailment Let D action theory M path T D M alternate sequence states actions cid3s0 a0 s1 an1 sncid5 cid3si ai si1cid5 T D 0 cid2 n We M entails set ﬂuent literals σ written M cid12 σ σ holds sn For path M cid3s0 a0 s1 an1 sncid5 T D s0 sn referred initial state ﬁnal state respectively M The sequence actions α cid3a0 an1cid5 referred chain events We M model α write cid3s0 α sncid5 T D denote exists model α initial state ﬁnal state s0 sn respectively A chain events α cid3a0 a1 an1cid5 executable state s n 0 α chain events cid4cid5 T D A chain events ii a0 executable s cid3a1 an1cid5 executable s executable set states S executable state s S cid3s s cid4 23 A logic programming representation T D We logic program called lpD compute transitions T D lpD sists rules reasoning effects actions Among rules inertial rule encodes solution frame problem ﬁrst discussed John McCarthy Pat Hayes landmark paper reasoning actions changes 44 The signature lpD includes terms corresponding ﬂuent literals actions D nonnegative integers represent time steps We write lpD n denote restriction program lpD time steps 0 n Atoms lpD formed following sorted predicate symbols ﬂuentF true F ﬂuent literalL true L ﬂuent literal hL T true ﬂuent literal L holds timestep T oE T true elementary action E occurs timestep T In representation letters T F L A E possibly indexed resp t f l e represent variables resp constants sorts time step ﬂuent ﬂuent literal action elementary action correspondingly Moreover use shorthands action oa T oe T e For set ﬂuent literals γ hγ T hl T l γ nothγ T nothl T l γ γ l l γ litψ literall l ψ The set rules lpD divided following ﬁve subsets4 1 Dynamic causal laws statement form 1 D rule hl T oe T 1 hψ T 1 T 0 4 belongs lpD This rule states elementary action e occurs time step T 1 precondition ψ holds time step l holds afterward 3 This shows exist AL action theories deterministic actions represented PDDL deterministic actions non recursive axioms 4 For simplicity omit atoms form litl litψ stepT body rules 2 Static causal laws statement form 2 D lpD contains rule PH Tu et al Artiﬁcial Intelligence 175 2011 79119 hl T hψ T This rule states ψ holds T l 3 Impossibility conditions statement form 3 D lpD contains following rule oa T hψ T 85 5 6 This rule states precondition ψ possibly holds time step T action occur time step 4 Inertia lpD contains following rule solves frame problem 44 hL T hL T 1 hL T T 0 7 This rule says ﬂuent literal L holds time step T holds previous time step negation hold T 5 Auxiliary rules lpD contains following rules hF T hF T literalF ﬂuentF literalF ﬂuentF 8 9 10 The ﬁrst constraint impedes complementary ﬂuent literals holding time The rules deﬁne ﬂuent literals For action state s let Φa s lpD 1 hs 0 oa 0 11 The theorem states program lpD correctly implements T D 5867 Theorem 2 See 5867 Let s state action Then cid3s s s cid4 l hl 1 A cid4cid5 T D iff exists answer set A Φa s 24 Conformant planning The conformant planning problem investigated paper discussed 121518215256 papers 6062 Given action theory D set ﬂuent literals δ partial state subset state s closed static causal laws Intuitively partial state represents knowledge agent associated D current state world For example partial state action theory Dbomb closed set static causal laws Dbomb subset state s0 Example 2 Likewise armed1 armed2 safe partial state Dbomb However armed1 armed2 partial state Dbomb closed laws Dbomb From use symbols σ s δ possibly indexed denote set ﬂuent literals state partial state respectively For partial state δ completion δ denoted compδ set states s δ s A conformant planning problem deﬁned follows Deﬁnition 5 A planning problem P tuple cid3D δ0 δ f cid5 D action theory δ0 δ f partial states D Observe section consider planning problems initial state description set literals More general description considered Sections 6 9 The solutions planning problem deﬁned follows Deﬁnition 6 Let P cid3D δ0 δ f cid5 planning problem A chain events α cid3a0 an1cid5 solution P α executable compδ0 model M α initial state compδ0 M cid12 δ f We refer α plan δ f If δ0 state action theory D deterministic α called classical plan conformant plan Furthermore ai α elementary action α called sequential plan called parallel plan We illustrate deﬁnitions bombinthetoilet example 86 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Example 5 Consider action theory Dbomb let δ0 δ f safe Then Pbomb cid3D δ0 δ f cid5 planning problem We check cid9 cid8 ﬂush1 dunk1 1 ﬂush1 dunk2 1 α1 cid8cid2 cid3 ﬂush1 ﬂush2 cid2 α2 dunk1 1 dunk2 2 cid3cid9 solutions Pbomb The ﬁrst sequential plan second parallel plan 3 Approximations AL action theories Let D action theory In section ﬁrst deﬁne mean approximation transition diagram T D discuss approximations ﬁnd solution planning problem Then introduce logic program deﬁning approximation Let begin deﬁnition approximation Deﬁnition 7 Approximation A transition diagram T cid4D approximation T D 1 nodes T 2 cid3δ δcid4cid5 T cid4D partial states D arcs T cid4D s compδ cid4D labeled actions executable s b δcid4 s s cid4 cid4 cid3s s cid4cid5 T D Intuitively ﬁrst condition describes approximation T cid4D transition diagram partial states cid4D sound respect T D second condition requires T Given approximation T T cid4D write cid3δ α δcid4cid5 T cid4D denote exists path corresponding α cid4D deterministic δ δcid4 partial state δ action exists δcid4 cid4D Even approximations nondeterministic paper interested deterministic approximations The observation shows soundness approximation extends transitions paths cid4D partial state δ We T cid4D convention cid3δ cid3cid5 δcid5 T cid3δ δcid4cid5 T Observation 31 Let T s compδ cid4D approximation T D Then chain events α cid3δ α δcid4cid5 T cid4D 1 α executable s 2 δcid4 s s cid4 cid4 cid3s α s cid4cid5 T D Observation 31 shows given approximation T planning problem cid3D δ δ f cid5 δ f δcid4 This gives rise following questions cid4D path δ δcid4 corresponds solution 1 How ﬁnd approximation T D 2 How approximation solve conformant planning problems In rest section deﬁne approximation T D called T lp In section use T lp construct conformant planner In approach transitions T lpD deﬁned logic program π D called cautious encoding D Following lpfunction theory 22 π D obtained lpD Section 23 adding new rules modifying inertial rule 7 allow π D deal partial states Let b action δ partial state We b safe δ exists impossibility condition 3 b ψ possibly holds δ A ﬂuent literal l direct effect resp possible direct effect b δ exists dynamic causal law 1 e b ψ holds resp possibly holds δ Recall partial state set ﬂuent literals concepts holds possibly holds deﬁned Section 22 Observe b safe δ b executable state s δ Furthermore direct effects b δ direct effects b s turn possible direct effects b δ The program π D The signature π D signature lpD As write π D n denote restriction π D time steps 0 n Atoms π D atoms lpD formed following sorted predicate symbols del T true ﬂuent literal l direct effect action occurs previous time step PH Tu et al Artiﬁcial Intelligence 175 2011 79119 87 phl T true ﬂuent literal l possibly holds time step T We use letters T F L E A possibly indexed represent variables sorts time step ﬂuent ﬂuent literal elementary action action correspondingly π D includes 1 rules 46 810 program lpD 2 additional rules deﬁned follows For dynamic causal law 1 D π D contains rule del T oe T 1 hψ T 1 T 0 12 This rule encodes direct effect elementary action e time step T It says e occurs time step T 1 precondition ψ holds ﬂuent literal l direct effect e Since agents knowledge state world time step incomplete add π D rule deﬁne possibly holds execution action e time step T 1 phl T oe T 1 hψ T 1 del T T 0 13 This rule says ﬂuent literal l possibly holds execution elementary action e e occurs previous time step ii exists dynamic causal law 1 e precondition ψ possibly holds previous step iii l direct effect action occurring previous time step b For static causal law 2 D π D contains rule phl T phψ T This rule states ψ possibly holds T l c In addition π D contains following rule phL T hL T 1 deL T T 0 14 15 This rule completes deﬁnition predicate ph It deﬁnes possibly holds inertia ﬂuent literal possibly holds possibly holds previous time step ii negation direct effect action occurring previous time step d Finally inertial law encoded π D follows hL T phL T T 0 says L holds time moment T 0 negation possibly hold T For action partial state δ let Πa δ π D 1 hδ 0 oa 0 Then program Πa δ following property 16 17 Proposition 1 Let δ partial state action If Πa δ consistent unique answer set B δcid4 l hl 1 B partial state Proof See Appendix A1 cid2 We deﬁne transition diagram called T lpD based program π D follows Deﬁnition 8 Let T lpD transition diagram 1 nodes T lpD partial states D arcs T lpD labeled actions D 2 cid3δ δcid4cid5 T lpD iff Πa δ consistent δcid4 l hl 1 B B answer set Πa δ The theorem states T lpD approximation T D furthermore deterministic Theorem 3 T lpD deterministic approximation T D 88 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Proof See Appendix A2 cid2 At point instructive mention approximation action theories static causal laws introduced 66 This approximation extension 0approximation 57 The approximation deﬁned paper extension 0approximation 57 Indeed following result holds similar Theorem 46 65 Observation 32 Let D action theory static causal laws δ partial state action executable δ Then cid3δ δcid4cid5 T lpD δcid4 Φ0a δ Φ0 denotes 0approximation 57 While approximations 576266 proposed context given action language approximation proposed paper ﬁrst published 61 applicable action languages semantics speciﬁed transition diagram We note approximation proposed paper 66 deal action theo ries static causal laws 57 Furthermore approximation proposed paper applicable transition diagrams allow parallel actions The approximation 66 based idea computing possibly change action executed A ﬂuent literal l possibly changes value execution action e direct effect e b exists dynamic law e causes l ψ ψ possibly changes exists static causal law l ψ ψ possibly changes Furthermore approximation 66 consider action theories parallel actions As instead computing possibly holds rules 13 14 15 employing result inertial law rule 16 planner 66 implements rules computing possible changes follows5 pcl T oe T 1 hψ T pcl T hl T 1 pcl hl T hl T 1 pcl T cid4 T deψ T The ﬁrst rule dynamic causal law form e causes l ψ second rule static causal law cid4 ψ The rule encodes inertial law It worth mentioning rule encoding form l ψ l inertial law 16 include atom hl T 1 applicable ﬂuents value unknown wrt approximation execution action For reason favor approximation developed 66 Observe T lpD approximation 66 incomparable sense T lpD entails conclusions derived approximation 66 vice versa For instance theory D2 causes h f g cid3 f hcid5 T lpD h partial state resulting execution f according approximation T lp f h partial state resulting execution f according 66 On hand theory cid6 cid10 D3 causes f g f h causes g k k f g f h p g q cid3 f g p q f p q kcid5 T lpD3 f k q partial state resulting execution f g p q according 66 4 An approximation based conformant planner Let P cid3D δ0 δ f cid5 planning problem Observation 31 implies deterministic approximation T cid4D α solution P Because T lpD T D α chain events cid3δ0 α δcid4cid5 T deterministic approximation T D consider following decision problem cid4D δ f δcid4 Conformant planning respect T lpD Given planning problem P cid3D δ0 δ f cid5 determine P solu tion respect T lpD The following complexity result similar Theorem 1 66 Theorem 4 The conformant planning problem respect T lpD NPcomplete 5 We adapt encoding style paper encoding approximation 66 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 89 The fact T lpD deterministic allows use program π D compute solutions P In section construct logic program π D purpose This logic program denoted π P n input parameters planning problem P integer n The answer sets π P n contain solutions length n P Like π D signature π P n includes terms corresponding ﬂuent literals actions D Rules π P n include rules π D n following rules 1 Initial partial state encoding add π P n following facts initial partial state cid5 cid4 δ0 0 h Note shorthand set facts hl 0 l δ0 2 Goal encoding l δ f π P n contains constraint hl n This set constraints makes sure ﬂuent literal δ f holds ﬁnal state 3 Action generation rule π P n contains following rules generating action occurrences oE T oE T T n oA T T n 18 19 20 21 Recall A set actions These rules state time step T n action occurs6 The following theorem shows use π P n ﬁnd solutions P Theorem 5 Let C answer set π P n let ai e oe C 0 cid2 n Then α cid3a0 an1cid5 solution P Proof See Appendix B cid2 It worth noticing program π P n similar presented 58 answer sets corresponds solution planning problem P Nevertheless important differences π P n program 58 π P n deal incomplete initial situation considers parallel actions None aspects considered 58 The program π P n strongly related planner 66 They differ implement different approximations π P n deal parallel actions 66 Theorem 5 implies answer set π P n corresponds solution length n P To ﬁnd minimal solutions run program π P n n 0 1 sequentially returns answer set ﬁrst n π P n consistent The chain events corresponding answer set minimal solution P This framework referred planner CPasp7 As seen Section 8 CPasp solve wide range planning problems However incomplete planning problems solution exists CPasp A precise deﬁnition completeness CPasp given Deﬁnition 9 Completeness incompleteness CPasp Let P planning problem We CPasp complete respect P P solution ii P solution exists integer n π P n consistent Otherwise CPasp incomplete respect P Observe Theorem 5 shows P solution π P n inconsistent n One main reasons incompleteness CPasp inability program π P n reasoning cases The following example demonstrates issue 6 An alternative set rules choice rule cid2 oE T actionE cid3 1 T n introduced 55 7 CPasp stands Conformant Planning Answer Set Programming 90 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Example 6 Consider action theory D4 dynamic causal laws e causes f g e causes f g Let P4 cid3D4 f cid5 Clearly cid3ecid5 solution P4 g g true state belonging comp dynamic causal laws effect e performed Yet easy verify solution generated CPasp fact n π P4 n answer set Constraint 19 satisﬁed The example shows conditional effects static causal laws cause CPasp incomplete Example 7 Consider action theory D5 e causes f g f h g f h We check cid3ecid5 solution planning problem P5 cid3D5 f g gcid5 e causes f true static causal laws g true f true Now suppose program π P5 1 answer set C corresponds plan cid3ecid5 This implies oe 0 C Then rule 12 f 1 C Furthermore atom form belongs C head ground instance rule 12 Thus atom form C f 1 C By rule 13 implies ph f 1 C By rule 15 phg 1 phh 1 phh 1 belong C By rule 16 phg 1 C hg 1 belong C As result constraint 19 satisﬁed This contradiction C satisﬁes constraints π P5 1 Hence π P5 1 answer set In fact verify integer n π P5 n answer set This implies CPasp ﬁnd solution P5 The examples raise question applicability CPasp kind planning problems CPasp solve Observe action theories presented Examples 6 7 artiﬁcial likely come speciﬁcation realworld domains In fact theories Examples 6 7 simpliﬁed Dcid4 e causes f 4 Dcid4 e causes f g h respectively It easy CPasp complete respect simpliﬁed domains In 5 59 developed transformation removes artiﬁcial situations It worth mention CPasp solve benchmark problems nondisjunctive initial state encountered far 5 A suﬃcient condition completeness CPASP In section present initial study completeness CPasp Speciﬁcally introduce class planning problems called simple planning problems Deﬁnition 14 respect CPasp complete For convenience given action theory D set S states action Resa S denote set possible successor states states S execution Resa S cid2 cid4 s cid11 cid11 s S cid8 cid9 cid4 cid3 T D s s For chain events α Resα S denote set possible states reachable state S execution α Resα S cid2 cid4 s cid11 cid11 s S cid8 cid9 cid4 cid3 T D s α s Deﬁnition 10 Simple action theories A static causal law simple precondition contains ﬂuent literal An action theory D simple static causal laws simple By deﬁnition action theories static causal laws simple8 Furthermore observe real world static causal laws simple nature For example represent unique location robot time use following collection static causal laws 8 This implies benchmarks international planning competitions involve simple action theories static causal laws representation cid2 atX atY cid11 cid11 X cid7 Y cid3 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 91 Likewise represent unique value multivalued object obj use cid2 valueobj X valueobj Y cid11 cid11 X cid7 Y cid3 Observe simple action theories translated action theories static causal laws computing Sl h exists sequence l0 l ln h li li1 1 cid2 cid2 n ﬂuent literal l replacing dynamic law causes l ϕ set dynamic laws cid2 causes h ϕ cid11 cid3 cid11 h Sl A main disadvantage approach lies number dynamic laws increase quadratically number static laws To characterize situations Examples 67 deﬁne notion dependency ﬂuent literals Deﬁnition 11 Dependencies literals A ﬂuent literal l depends ﬂuent literal g written l cid16 g following conditions holds 1 l g 2 There exists dynamic static causal law D l head g belongs precondition law 3 There exists ﬂuent literal h l cid16 h h cid16 g 4 The complementary l depends complementary g l cid16 g Note dependency relationship ﬂuent literals reﬂexive transitive symmetric The deﬁni tion dependence actions ﬂuent literals Deﬁnition 12 Dependencies actions ﬂuent literals An action b depends ﬂuent literal l written b cid16 l 1 exists impossibility condition 3 b l ψ 2 exists ﬂuent literal g b cid16 g g cid16 l For set ﬂuent literals σ ﬂuent literal l write l cid16 σ denote l cid16 g g σ l cid2 σ denote exists g σ l cid16 g The deﬁnition characterizes set states S representing possible states world reduced single partial state δ Deﬁnition 13 Reducibility Let S set states δ partial state σ set ﬂuent literals We S reducible δ respect σ denoted S cid17σ δ 1 δ subset state s S 2 ﬂuent literal l σ exists state s S l cid2 s δ 3 action exists state s S cid2 s δ There interesting properties reducibility set states First S cid17σ δ S represents set possible states world reason formulae composed σ suﬃces know δ Proposition 2 Let D simple action theory S set states δ partial state σ set ﬂuent literals S cid17σ δ Then cid12 s σ δ σ sS Proof See Appendix C1 cid2 The reducibility set states preserved course execution actions Proposition 3 Let D simple action theory S set states δ partial state σ set ﬂuent literals S cid17σ δ For action executable S 92 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 1 safe δ 2 Resa S cid17σ δcid4 cid3δ δcid4cid5 T lpD Proof See Appendix C2 cid2 The second property extended chain events α follows Proposition 4 Let D simple action theory S set states δ partial state σ set ﬂuent literals S cid17σ δ For chain events α α safe S 1 α safe δ 2 Resa S cid17σ δcid4 cid3δ δcid4cid5 T lpD Proof See Appendix C3 cid2 We deﬁne class planning problems called simple planning problems follows Deﬁnition 14 Simple planning problems A planning problem cid3D δ0 δ f cid5 simple 1 D simple 2 compδ0 cid17 δ f δ0 The following theorem states class simple planning problems planner CPasp complete Theorem 6 Let P cid3D δ0 δ f cid5 planning problem If P simple CPasp complete respect P Proof See Appendix C4 cid2 We like conclude section relating completeness condition approximation based reasoning action theories incomplete initial state works The proposed condition strongly related result 60 completeness condition developed action theories static causal laws9 Observe proofs result 60 use different techniques proofs completeness result paper relies techniques developed logic programming community In 49 Palacios Geffner presented translations convert planning problem P cid3D δ0 δ f cid5 clas sical planning problem P cid4 cid3Dcid4 γ 0 γ f cid5 γ 0 complete solutions computed classical planners FF A translation introduce new ﬂuents actions Roughly completeness translation depends set new ﬂuents actions The authors 49 identiﬁed class complete translations They characterized width problem depends relevance relation literals This relation similar dependency relation literals Deﬁnition 11 Similar 60 approach 49 deal action theories static causal laws Nor consider parallel actions The determinicity T lpD fact computing result execution action given partial state polynomial time size theory imply computing result execution action sequence given state polynomial time In words temporal projection problem 30 class simple action theories tractable This result similar result developed Liu Levesque 39 As works work 39 deal static causal laws parallel actions 6 A logic programming based planner disjunctive initial state Besides incomplete weakness CPasp consider planning problems disjunctive information initial state We problems disjunctive planning problems formally deﬁne follows Deﬁnition 15 Disjunctive planning problems A disjunctive planning problem P tuple cid3D Δ0 δ f cid5 D action theory Δ0 nonempty set partial states δ f partial state 9 This result similar Theorem 4 60 Theorem 3 60 incorrect invalidate Theorem 4 A corrected version Theorem 3 65 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 93 It easy planning problem Deﬁnition 5 special case disjunctive planning problem Δ0 singleton set Solutions disjunctive planning problem deﬁned follows Deﬁnition 16 A chain events α cid3a0 an1cid5 solution disjunctive planning problem P cid3D Δ0 δ f cid5 δ0 Δ0 α solution planning problem cid3D δ0 δ f cid5 Example 8 Consider domain cid6 D6 e causes f g e causes f h let Δ0 g h δ f f Then P6 cid3D6 Δ0 δ f cid5 disjunctive planning problem By Deﬁnition 16 easy α cid3ecid5 solution P6 It turns framework previous section naturally extended ﬁnd solutions disjunctive planning problem P First extend program π D deal explicit disjunctive information initial state newly extended program referred Γ D Then construct program Γ P n Γ D answer set Γ P n exists represents solution P The basic idea development Γ D based approach 66 We add second constant Γ D called worlds denote number initial partial states Δ0 worlds Δ0 With exception predicate o A T auxiliary predicates literalL ﬂuentF predicate π D modiﬁed accept parameter W indicate possible world reasoner execution plan following way hl T W true ﬂuent literal l holds timestep T world W del T W true ﬂuent literal l direct effect action occurs previous time step world W phl T W true ﬂuent literal l possibly holds time step T world W The rules Γ D obtained rules π D replacing predicates hl T del T phl T new predicates hl T W del T W phl T W respectively For example rule 4 hl T 1 W oe T hψ T W Similarly rule 13 phl T 1 W oe T hψ T W del T 1 W As use notation Γ D n denote restriction Γ D time step value 0 n Suppose Δ0 δ0 δk1 The program Γ P n constructed follows 1 The value constant worlds k 2 The set rules Γ P n includes rules Γ D n b δi Δ0 rule hδi 0 c l δ f 1 k rule hl n The following proposition establishes relationship Γ P ΠP Proposition 5 Let P cid3D δ0 δ f cid5 P cid4 cid3D δ0 δ f cid5 A set atoms A answer set Γ P n iff exists answer set B π P cid4 n 1 ﬂuent literal l hl 0 A iff hl B 2 elementary action e oe 0 A iff oe B Theorem 7 Let P cid3D Δ0 δ f cid5 disjunctive planning problem If A answer set Γ P n α cid3a0 an1cid5 ai e oe A solution P 94 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 ResDaδ Input An action theory D action partial state δ Output successor partial state δ 1 Begin pde 2 3 dynamic causal law 1 D ψ holds δ l 4 ψ possibly holds δ pde pde l 5 6 ph ClosureD pde lit δ 7 return ClosureD lit ph 8 End lit F F Fig 2 An algorithm computing transition function T lp ClosureDσ Input An action theory D set ﬂuent literal σ Output ClDσ 1 Begin 2 σ1 σ2 σ 3 repeat 4 5 6 7 8 9 ﬁxpoint 10 return σ1 11 End ﬁxpoint true static causal law 2 D ψ holds σ1 l σ2 ﬁxpoint false σ2 σ2 l σ1 σ2 Fig 3 Computing closure set ﬂuent literals Proposition 5 intuitive diﬃcult prove correctness The proof Theorem 7 similar proof Theorem 5 Appendix B Hence omit proofs brevity 7 Heuristic search T lp In previous sections demonstrated usefulness approximations planning logic programming paradigm The experiments Section 8 CPasp good planning parallel actions domains rich static causal laws However perform domains large grounded representation One main reasons problem current answer set solvers scale programs require large grounded representation Various approaches proposed attack issue different perspectives 920 To investigate usefulness approximations implemented C sequential planner called CpA based transition diagram induced T lp CpA employs best ﬁrst search strategy repeated state avoidance num ber fulﬁlled subgoals heuristic function The initial state described CNF formula CpA allows disjunctive information One main functions inside CpA compute transition function speciﬁed T lp The algorithm function presented Fig 2 It takes input action theory D action partial state δ returns output successor partial state δ Note T lp deterministic successor partial state exists unique provided safe δ In algorithm variables pde denote set direct effects set possible direct effects respectively ph set ﬂuent literals possibly holds successor partial state lit set ﬂuent literals The loop compute sets direct effects possible direct effects The algorithm makes calls Closure function depicted Fig 3 The Closure function takes input action theory D set ﬂuent literals σ returns output ClDσ This process performed following steps First closure set σ Then function loops static causal laws adding closure head static causal laws bodies hold previous iteration The loop terminates ﬂuent literals added closure The correctness algorithm stated following theorem Theorem 8 Let D action theory action δ partial state If safe δ ResD δ δcid4 T lpD iff cid3δ δcid4cid5 Proof See Appendix D cid2 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 95 We like note CpA deals disjunctive information initial state CpA employs explicit DNF representation initial state Given CNF representation initial state10 CpA converts internal DNF representation Naturally time consuming affect planners performance Finding implementation CpA require DNF representation initial state interesting topic scope paper considered goals future 8 Experiments In section present experimental evaluation performance CPasp CpA The platform testing CPasp 24 GHz CPU 768 MB RAM machine running Slackware 100 operating Experiments CpA sequential planners conducted 32 GHz CPU 2 GB RAM running Suse Linux 90 operating Every experiment time limit 30 minutes 81 Evaluation CPasp 811 Planning systems We compared CPasp conformant planners CMBP 15 DLVK 18 CPlan 14 We selected planners designed spirit similar CPasp planning problem translated equivalent problem general setting solved offtheshelf software directly deal static causal laws The main difference planners CPasp lies use different types reasoning searching plans CMBP DLVK CPlan use possible world semantics CPasp uses approximation A brief overview planners given CMBP Conformant Model Based Planner CMBP conformant planner developed Cimatti Roveri 15 CMBP employs BDD Binary Decision Diagram techniques represent planning domains search solutions CMBP allows nondeterministic domains uncertainty initial state action effects However capability generating concurrent plans The input language action language AR 28 The version testing downloaded httpwwwcswashingtoneduresearchjaircontentsv13html DLVK DLVK declarative logicprogrammingbased planning built DLV http wwwdbaituwienacatprojdlv Its input language K logicbased planning language described 18 The ver sion testing downloaded httpwwwdbaituwienacatprojdlvK DLVK capable generating concurrent conformant plans CPlan CPlan SATbased conformant planner CPlan works generateandtest method The input language action language C 2129 CPlan primarily designed generating concurrent plans 812 Benchmarks We prepared test suites The ﬁrst test suite contains sequential conformant planning benchmarks second contains concurrent conformant planning benchmarks Many benchmarks taken literature 121418 developed international planning competition 17 To test performance systems domains static causal laws developed simple domains rich static causal laws Sequential benchmarks The sequential benchmark test suite includes following domains BTm n This domain variant wellknown BombIntheToilet domain In domain m packages n toilets One packages contains bomb The bomb disarmed dunking package contains toilet The goal disarm bomb BTCm n This domain similar BT However assume dunking package toilet clog toilet ﬂushing toilet unclogged RINGn The encoded version problem follows encoding distribution CFF In domain agent forward backward building nrooms arranged ring cyclic fashion Each room window closed open Closed windows locked Initially location agent states openlocked windows known The goal windows locked A possible conformant plan consists performing actions forward close lock repeatedly Notice initial location agent needs represented disjunction Observe location agent satisﬁes wellknown static causal law stating agent places time We created domain called RINGCn introducing static causal law We remark domain different ways experiments In testing CPasp assume location agent known initial state This CPasp deal disjunctive information On hand assume location agent unknown initial state testing CpA 10 In PDDL speciﬁed oneof orclauses 96 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Dominon We n dominoes standing line way falls domino right falls There ball hanging close leftmost Touching ball causes ﬁrst domino fall Initially states dominoes unknown The goal rightmost domino fall Gaspipen The objective domain start ﬂame burner connected gas tank pipe line The gas tank leftmost end pipe line burner rightmost end The pipe line sections connected valves The pipe sections pressured tank unpressured Opening valve causes section right pressured section left pressured Moreover safety reasons valve opened valve line closed Closing valve causes pipe section right unpressured Static causal laws useful representation domain One law valve open section left pressured section right pressured Otherwise valve closed section left unpressured pipe right unpressured The burner start ﬂame pipe connecting pressured The gas tank pressured The uncertainty initial situation states valves unknown A possible conformant plan close valves ﬁrst directly connects gas tank right left opening left right Cleanern p This domain modiﬁed version Ring domain instead locking windows goal agent clean multiple objects located room p objects room To contrast Ring domain assume initially agent ﬁrst room know objects cleaned Concurrent benchmarks There domains test suite BTp BTCp Gaspipep Cleanerp The BTp BTCp domains modiﬁcations BT BTC domains respectively allow dunk different packages different toilets time The Gaspipep domain modiﬁcation Gaspipe domain allows close multiple valves time In addition possible open valve closing valves However allowed open close valve open different valves time The ﬁnal domain test suite Cleanerp modiﬁed version Cleaner domain allow robot concurrently clean multiple objects room Modiﬁcations Ring Domino domain considered problems sequential solutions 813 Experimental results We ran CPasp answer set solvers smodels 55 cmodels 33 observed cmodels yielded better performance general The running times CPasp reported obtained cmodels The timing results sequential benchmarks shown Tables 1 2 results concurrent benchmarks shown Table 3 We test CPlan sequential planning benchmarks developed concurrent planning In tables times shown seconds The PL column shows length plan planner denotes planner return solution time limit reasons time memory NA denotes problem run planner Since DLVK CPasp require input parameter length plan search ran inside loop incrementally increase plan length search starting 111 plan Notice way CPasp ﬁnding conformant plans minimal conformant plans respect deﬁned approximation For example CPlan CPasp took 074 second 272 second respectively ﬁnd solution BTC62 problem Nevertheless CPasps solution shorter As seen Table 1 BT BTC domains CMBP outperforms DLVK CPasp problem instances In general CPasp better performance DLVK domains As example DLVK took minutes solve BT62 took 077 seconds CPasp solve problem In addition time limit CPasp able solve problems DLVK In Ring domain outperformed CMBP DLVK small instances CPasp planner able solve Ring8 CPasp works domains rich static causal laws Domino Gaspipe In Domino domain CPasp outper forms planners instances It took 241 seconds solve Domino2000 DLVK CMBP took minute In fact CPasp scale larger instances Domino10000 In Gaspipe domain CPasp outperforms DLVK able solve problem instances DLVK able solve ﬁrst problem instances12 The Cleaner domain turns hard planners solve small instances In domain CPasp outperformed CMBP To solve Cleaner6 2 CMBP took 41 seconds CPasp took 3 minutes However CPasp performs better DLVK general DLVK reported timeout problem Cleaner6 2 We seen CPasp competitive CMBP DLVK sequential benchmarks Let attention concurrent benchmarks As seen Table 3 CPasp outperforms DLVK CPlan instances BTp BTCp Gaspipep domains Furthermore CPasp planner able solve 11 We start 0 benchmarks plan length 0 12 We tried test domain CMBP problem encoding We contacted author CMBP waiting response PH Tu et al Artiﬁcial Intelligence 175 2011 79119 97 Table 1 Sequential benchmarks Bomb Ring domains Problem CMBP BT2 2 BT4 2 BT6 2 BT8 4 BT10 4 BTC2 2 BTC4 2 BTC6 2 BTC8 4 BTC10 4 Ring2 Ring4 Ring6 Ring8 Ring10 PL 2 4 6 8 10 2 6 10 5 11 17 Time 003 017 021 063 15 016 026 074 006 010 048 Table 2 Sequential benchmarks Domino Gaspipe Cleaner domains Problem Domino100 Domino200 Domino500 Domino1000 Domino2000 Domino5000 Domino10000 Gaspipe3 Gaspipe5 Gaspipe7 Gaspipe9 Gaspipe11 Cleaner2 2 Cleaner2 5 Cleaner2 10 Cleaner4 2 Cleaner4 5 Cleaner4 10 Cleaner6 2 Cleaner6 5 Cleaner6 10 CMBP PL 1 1 1 1 1 1 5 11 11 17 Time 026 179 792 1320 6660 55946 NA NA NA NA NA 01 061 013 41 DLVK PL 2 4 6 2 6 5 11 DLVK PL 1 1 1 1 1 5 9 13 5 11 11 Time 004 055 21655 012 7244 010 214 Time 01 035 240 1310 6242 013 042 4262 0104 21469 1482 CPasp PL 2 4 6 8 10 2 6 8 5 11 17 23 CPasp PL 1 1 1 1 1 1 1 5 9 13 17 21 5 11 11 17 Time 020 041 077 673 89006 022 071 272 052 298 4443 142407 Time 021 028 074 123 241 607 12584 134 222 618 3932 86810 049 388 209 22439 instances test suite In Cleaner domain CPlan best To solve Cleanerp 6 10 problem CPlan took 035 seconds DLVK reported timeout CPasp needed 373 seconds As CMBP produce concurrent plans included table 82 Evaluation CpA 821 Planning systems We compared CpA conformant planners CFF 12 KACMBP 16 t0 49 POND 13 These planners time experiments known fastest conformant planners conformant planning benchmarks literature13 CFF 12 superior stateoftheart conformant planners like GPT 11 MBP 15 KACMBP reported 16 outperform DLVK CPlan domains literature t0 49 known better CFF domains We compare planners PKS 50 improved 51 employs richer representation language knowledgebased approach reason effects actions presence incomplete 13 In recent planning competition improved version CpA won ﬁrst prize t0 httpippc2008loriafrwikiindexphpResults The version CpA paper version time original submission paper 98 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Table 3 Concurrent benchmarks Bomb Gaspipe Cleaner domains Problem BTp 2 2 BTp 4 2 BTp 6 2 BTp 8 4 BTp 10 4 BTCp 2 2 BTCp 4 2 BTCp 6 2 BTCp 8 4 BTCp 10 4 Gaspipep 3 Gaspipep 5 Gaspipep 7 Gaspipep 9 Gaspipep 11 Cleanerp 2 2 Cleanerp 2 5 Cleanerp 2 10 Cleanerp 4 2 Cleanerp 4 5 Cleanerp 4 10 Cleanerp 6 2 Cleanerp 6 5 Cleanerp 6 10 CPlan PL 1 2 3 2 1 3 5 3 3 3 7 7 7 11 11 11 Time 007 005 181 432 005 007 751 005 012 006 006 009 013 011 019 035 DLVK PL 1 2 3 2 1 3 5 4 6 8 10 3 3 3 7 7 7 11 11 Time 007 009 306 1052 005 090 33327 008 017 044 1744 007 006 007 019 080 23763 447 98673 CPasp PL 1 2 3 2 3 1 3 5 3 5 4 6 8 10 12 3 3 3 7 7 7 11 11 11 Time 011 026 034 024 191 013 030 067 050 119245 040 075 122 317 883 026 030 030 077 093 116 198 294 373 information planners comparison domainindependent planners A brief overview planners given KACMBP KACMBP extension CMBP Similarly CMBP KACMBP uses techniques symbolic model checking search belief space However KACMBP search guided heuristic function derived based knowledge associated belief state KACMBP designed sequential concurrent settings The input language KACMBP SMV The experiments downloaded httpsraitcittoolsmbp AIJ04 ConformantFF CFF CFF14 extends classical FF planner 31 deal uncertainty initial state The basic idea represent belief state s initial belief state described CNF formula action sequence leads s In addition reasoning checking satisﬁability CNF formulae The input language CFF subset PDDL language minor change allows users specify initial state CNF formula CFF supports sequential conformant planning However support concurrent conditional planning POND POND extends planning graph algorithm 10 deal sensing actions Conformant planning supported feature POND The input language subset PDDL The version testing obtained email communication Daniel Bryce author POND This version 111 POND t0 winner 2006 International Planning Competition Conformant Planning category t0 solves planning problem P translating classical planning problem P cid4 The earlier version t0 called cf2csff 48 incomplete t0 49 complete As planners CFF POND t0 deal static causal laws 822 Benchmarks We evaluated performance planning systems domains tested CPasp Ring Domino Cleaner BTC In addition use domains CubeCenter CubeC Logistic Log Sortnet UTS The Ring Domino BTC Cleaner domains described previous section We remark initial location agent unknown Ring domain experiments conducted section The CubeCenter2k 1 domain described 16 In domain agent left right threedimension grid size 2k 1 A results agent corresponding cell moving changes ycoordinate agent cell moving y coordinate 2k 1 result change The goal agent center Cube Initially agent know location 14 We like thank Jörg Hoffmann providing executable version testing PH Tu et al Artiﬁcial Intelligence 175 2011 79119 99 Table 4 Classical domains Ring CubeCenter BTC Logistics Prob size Ringn 2 3 4 5 CubeCentern 3 5 7 9 11 BTCp t 10 1 20 1 50 1 100 1 10 5 20 5 50 5 100 5 10 10 20 10 50 10 100 10 Logisticsl c p 2 2 2 2 3 3 3 2 2 3 3 3 4 3 3 KACMBP PL Time 8 15 22 35 14 25 35 45 55 19 39 99 199 15 35 95 195 10 30 90 190 14 34 14 40 000 001 002 003 004 016 016 032 036 001 004 035 252 006 018 096 394 017 055 296 1742 013 16113 012 019 CFF PL 7 15 26 45 6 33 40 19 39 99 199 15 35 95 195 10 30 90 190 16 24 20 34 37 Time 001 012 213 4077 000 028 2262 001 006 218 5777 001 002 182 5349 000 003 152 4785 000 000 002 003 004 POND PL 6 13 16 20 6 15 24 19 39 99 199 15 97 195 10 30 94 194 16 30 22 38 37 Time 000 010 434 24745 055 1000 16285 000 002 019 205 001 AB 063 180 002 013 145 1797 007 149 045 2407 3432 t0 PL 5 8 13 17 6 15 28 45 48 19 39 99 199 15 35 95 195 10 30 90 190 16 24 20 34 36 CpA PL 5 8 11 14 6 24 42 73 81 19 39 99 199 15 35 95 195 10 30 90 190 10 48 44 350 Time 004 005 006 005 008 012 014 032 023 006 006 010 024 003 006 012 042 005 008 016 042 005 008 008 011 015 Time 000 005 040 205 010 982 11757 79784 140524 000 005 064 498 003 012 148 985 005 031 288 1684 011 743 333 34009 The Logisticl c p domain described 12 distributed CFF In domain need transport p packages locations c cities city p locations trucks airplanes The uncertainty initial state exact locations packages unknown beginning The Sortnetn UTSn domains 2006 International Planning Competition downloaded http wwwldcusbvebonet The Sortnetn domain synthesis sorting networks disjunctive goals large number possible initial states The UTSn domain computation universal transversal sequence graphs In domain goal visited nodes To agent start traveling Afterwards heshe visit neighbor nodes The uncertainty lies initial location agent 823 Experimental results The experimental results shown Tables 47 Times shown seconds indicates planner return solution time limit NA indicates problem applicable AB denotes program encountered error halted abnormally As seen Table 4 Ring domain KACMBP performs best t0 good KACMBP CFF POND contrary perform domain As explained 12 CFF perform domain lack informativity heuristic function presence nonunary effect conditions problem checking repeated states Although CpA able solve instances performance good KACMBP t0 solve Ring5 CpA needed seconds KACBMP t0 needed 005 seconds A similar performance trend observed CubeCenter domain t0 KACMBP dominate domain t0 yields better performance shorter plans KACMBP large instances CpA outperforms POND slower CFF instances solvable CFF Again CpA able solve instances domain solutions usually longer solutions returned planners In BTC domain t0 better general POND KACMBP comparable CpA competitive instances It outperforms CFF POND KACMBP BTC100 10 takes twice time comparing POND KACMBP solving BTC100 1 instance It interesting observe CFF t0 problem number toilets increases signiﬁcant increase time needed ﬁnd solution KACMBP POND CpA This increase substantial CpA KACMBPor POND For example 100 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Table 5 Domains static causal laws high degree uncertainty RingC Domino Cleaner CFF PL 10 50 21 41 101 201 54 104 254 Prob size Dominon 10 50 100 200 500 1000 2000 5000 Cleanerr o 2 10 2 20 2 50 2 100 5 10 5 20 5 50 5 100 KACMBP PL 23 163 376 852 21 41 101 201 56 106 256 Time 004 013 145 1642 004 036 789 11399 057 475 14340 Ring static causal laws RingCn 10 15 20 25 85 231 270 049 903 50399 Time 000 000 NA NA NA NA NA NA 000 002 029 348 003 027 746 NA POND PL 10 50 100 200 500 1000 Time 000 035 451 12826 37844 125817 21 1930 t0 PL 10 50 100 200 500 1000 21 41 101 201 54 104 254 504 30 45 60 75 Time 005 007 021 193 5834 74595 005 008 010 023 006 010 023 079 101 676 2744 7958 CpA PL 1 1 1 1 1 1 1 1 21 41 101 201 54 104 254 504 30 45 60 75 Time 000 001 002 002 005 016 052 312 003 019 276 2271 026 178 2666 21427 083 557 2220 6532 number packages ﬁxed 100 number toilets increases 5 10 time needed CFF decreases time needed KACMBP increases 5 times CpAs time doubles PONDs time increases 10 times t0s remains In Logistic domain KACMBP CpA diﬃculty ﬁnding plans Although KACMBP performs better CpA performance far CFF t0 solved problem instance second POND solve problems time increases fast We believe poor performance CpA domain lies notsogood heuristic function This reﬂected lengths plans CpA Table 5 contains experimental results performance planners domains different domains described Table 4 following way domains rich static causal laws high degree uncertainty initial state The domains encoded CpA use static causal laws These static causal laws compiled away encodings planners following procedure suggested 63 In Domino domain exception CpA planners performed The reason domain rich static causal laws feature directly supported KACMBP CFF t0 POND Thus compile away encoding domain planners requires introduction extra actions ﬂuents As result performance planners hit extra overhead CpA affected It worth mentioning NA CFFs column predeﬁned constants maximal plan length set 500 In Cleaner domain CpA obtained good performance planner solve instances KACMBP behaves small problems scale CFF CpA CFF good instances domain Cleaner5 100 reported error message maximum length plans exceeded We believe easily ﬁxed increasing constant maximum length plans allowed POND solve instance set problems In domain high degree uncertainty initial state increases number objects It interesting observe static causal laws affect performance CpA different reasoning method useful planners As mentioned difference RingC domain Ring domain add encoding static causal laws agent different locations time problem speciﬁcation In encoding run CpA expressed static causal law This information expressed encoding planners adding additional negative effects wardbackward domain For example rooms 1 2 3 encoding CpA include action forward causes ini1 ini 1 2 3 in4 in1 static causal law j ini cid7 j encoding action planners conditional effects form whenin3in1 in2 in3 CpA yields best result domain Only CpA t0 able solve instances problem Neither CFF POND returned solution smallest instance domain RingC10 The difference t0 CFF indicates domain method employed t0 better CFF It likely translation t0 introduces actions ﬂuents problem ultimately results better performance PH Tu et al Artiﬁcial Intelligence 175 2011 79119 101 Table 6 Sortnet domains Problem KACMBP PL 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 Time 000 000 002 005 019 020 042 076 124 218 322 555 824 2062 2854 Sortnet1 Sortnet2 Sortnet3 Sortnet4 Sortnet5 Sortnet6 Sortnet7 Sortnet8 Sortnet9 Sortnet10 Sortnet11 Sortnet12 Sortnet13 Sortnet14 Sortnet15 Table 7 UTS domains CFF PL Time NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA POND PL 1 3 5 9 12 16 19 26 31 38 43 50 55 61 65 Problem KACMBP CFF POND k01 k02 k03 k04 k05 k06 k07 k08 k09 k10 l01 l02 l03 l04 l05 l06 l07 l08 l09 l10 r03 r04 r05 r06 r07 r08 r09 r10 PL 4 11 25 Time 001 020 1211 PL 4 10 16 22 28 34 40 46 52 58 4 11 17 23 29 35 41 47 52 58 17 25 33 38 47 48 62 66 Time 000 000 003 008 033 104 257 598 1209 2364 001 000 001 001 033 008 021 045 086 160 002 004 147 965 160 476 382 1163 PL 4 12 19 26 33 40 47 54 61 68 4 14 23 33 46 64 70 82 88 17 24 32 41 53 54 64 68 Time 000 000 000 000 001 000 001 001 005 006 011 013 020 022 Time 000 001 006 024 067 165 355 720 1402 2476 000 002 008 032 111 AB 740 1699 3953 10000 008 023 065 173 414 895 1744 3659 t0 PL Time NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA Time 004 006 AB 015 025 042 073 120 191 294 005 004 007 008 014 022 035 070 230 412 007 010 020 030 059 103 146 212 t0 PL 4 11 23 29 35 41 47 53 59 4 13 23 30 47 62 67 64 90 85 19 26 34 40 44 49 57 67 CpA PL 1 3 5 9 15 21 27 35 44 55 CpA PL 4 12 20 28 40 47 57 82 81 90 4 14 30 60 53 89 141 213 194 18 31 50 60 105 107 146 128 Time 000 000 005 040 066 976 3551 11741 37158 101010 Time 000 003 028 162 769 1881 5152 12222 21795 40079 000 002 036 224 932 2475 10637 45624 114751 023 181 994 2415 9841 23063 48028 69811 We seen CpA performed reasonably domains Let focus performance domains Sortnet Table 6 UTS Table 7 As mentioned earlier Sortnet domain disjunctive goals The systems CFF t0 consider problems disjunctive goals CpA consider disjunctive goals directly introduce additional ﬂuents static causal laws encode goal For example replace goal form f g ﬂuents f g add problem set static causal laws f g f f g g f g f g We observe encoding applicable CFF t0 systems In domain POND best It solve instance half second exception instance Sortnet9 halts abnormally KACMBP solve instances slower POND CpA hand solve instances 1 10 n 11 number partial states initial state 211 This domain indicates explicit representation set partial states CpA needs compensated ways planner scale Finally Table 7 indicates UTS domain challenging problem CpA KACMBP In domain number initial states linear size problem We believe heuristic CpA providing good 102 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 guidance search domain Even CpA solve problems exception l09 problem requires time planners large instances returns signiﬁcant longer plans For example k10problem CpA needs 401 seconds CFF POND require 24 seconds t0 needs 3 second CpAs plan contains 20 30 actions POND CFF t0 On hand CpA solve problems KACMBP solve smaller problems Observe CpA relies approximation deﬁned T lpD search solution Therefore theoretically sound incomplete planner T lpD deterministic D nondeterministic discussed Section 22 To sure approach cover broader spectrum planning problems tested CpA classical planning problems The ﬁrst domain considered Blocks World performed tests ﬁve problem instances described 18 We tested problems Rovers domain15 We experimented ﬁve problem instances different numbers way points rovers cameras rock soil samples objectives It turns CpA solve problems 9 Conformant planning logic programming vs heuristic search approximation The experimental results previous section indicate C planner CpA yields better performance logic programming based planner CPasp sequential benchmarks However CPasp competitive plan ning problems short solutions Our experimental results problems complex static causal laws CPasp better CpA stateoftheart planners large problems One main reasons weakness CPasp reliance general answer set solver computing solution On hand use logic programming brings number advantages We discuss advantages 1 Generating Parallel Plans Logic programming based planners CPasp DLVK generate parallel plans In CPasp achieved rules 20 21 On hand stateoftheart planners compute parallel plans 2 Incorporation Control Knowledge andor Preferences Logic programming provides ideal environment adding trol knowledge andor preferences searching plans satisfying qualitative criteria For example bomb toilet domain package ﬂushing toilet followed dunking package f lush dunk plan achieving goal having package disarmed know toilet unclogged initial sit uation Although valid solution plan hardly preferable The problem action theory include knowledge stipulating planner consider plan plan single action dunk suﬃcient This type knowledge represented impossibility condition ﬂush As planners relying ﬁxed representation language PDDL incorporation knowledge planning requires lot work TPlan 2 develops separate modules deal temporal knowledge In logic programming easily express knowledge constraint cid4 occ cid5 cid4 ﬂusht T h cloggedt T cid5 disallows answer sets action ﬂush occurs toilet unclogged The paper 58 discusses different types control knowledge easily incorporated answer set planning 3 Dealing Complex Initial Situations Section 6 discusses CPasp easily adapted handle disjunctive infor mation initial situations This type knowledge generates multiple branches search tree dealt fairly eﬃciently stateoftheart sequential planners Yet speciﬁcation initial situation CPasp extension described Section 6 remains simple sense initial state expressed set facts While adequate benchmarks literature following example discussed 26 shows allowing speciﬁcation complex initial situations necessary useful Example 9 Complex initial situation Assume packages bomb toilet domain coming differ ent sources belonging hierarchically structured organizations called b bad g good The hierarchies described usual way relation linkD1 D2 indicates department D1 subdivision department D2 Organization g instance represented collection atoms linkd1 g linkd2 g linkd3 d1 linkd4 d1 15 httpplanningcisstrathacukcompetition PH Tu et al Artiﬁcial Intelligence 175 2011 79119 103 These atoms represent fact di 1 2 3 4 departments good company It known packages coming organization g safe bomb sent working b There packages labeled department sender works recorded atom fromP D package P came department D There unlabeled packages The initial situation modiﬁed bomb toilet problem described program H consisting atoms following rules deﬁne organization package came trust good guys g fromP D2 fromP D1 linkD1 D2 cid4 armedP 0 fromP g h cid5 As usual P ranges packages Ds range departments It easy program unique answer set specify initial situation It easy π D Γ D work planning problems type initial situation need replace rule 18 program 10 Conclusion future work We deﬁne notion approximation action theories static causal laws concurrent actions incomplete information The proposed approximation deterministic computed eﬃciently logic programs imperative language C We develop conformant planners proposed approximation logic programming based planner called CPasp heuristic search based planner CpA CPasp generate parallel plans CpA sequential planner Both handle disjunctive information initial state Unlike stateoftheart conformant planners planners deal directly static causal laws Their performance comparable stateoftheart conformant planners benchmark domains newly invented domains Due simple heuristic implementation CpA believe good performance CpA lies use approximation In recent development authors worked improve aspect CpA entered improved version CpA International Planning Competition The improved version CpA won best prize conformant planning category16 This result development planners demonstrates careful study approximated reasoning pay development practical planners We provide suﬃcient condition completeness approximation The condition applicable simple action theories static causal laws special form We believe condition extended cover broader class action theories We leave primary tasks near future Furthermore like investigate use informative heuristics improving performance CpA Acknowledgements We gratefully acknowledge debt pioneering work inﬂuence John McCarthy The important ideas investigated paper including declarative programming nonmonotonic logic reasoning actions effects ﬁnding solutions frame ramiﬁcation problems elaboration tolerance originated John Mc Carthys research 34 This paper viewed attempt apply ideas narrow hopefully suﬃciently important topic conformant planning17 The ﬁrst authors like acknowledge partial support NSF grants CNS0220590 HRD 0420407 IIS0812267 The author like acknowledge partial support NASA contract NASA NEG05GP48G Appendix A Proofs Proposition 1 Theorems 3 5 Suppose action theory D given Let s state δ partial state action From Theorem 2 following result Lemma 1 Let A answer set Φa s let s cid4 l hl 1 A Then s cid4 state cid3s s cid4cid5 T D Since appendix mainly deals programs Φa s Πa δ deﬁned 17 simplify proofs remove programs atoms rules First let Φ0a s resp Π0a δ denote program obtained Φa s resp Πa δ removing constraints 16 httpippc2008loriafrwikiindexphpResults 17 Some results reported proceedings 20th National Conference Artiﬁcial Intelligence 62 8th International Conference Logic Programming Nonmonotonic Reasoning Conference 61 20th International Joint Conference Artiﬁcial Intelligence 47 104 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Lemma 2 Π0a δ stratiﬁed program Proof We need ﬁnd function λ maps atoms Π0a δ nonnegative integers r Π0a δ head y λ y cid3 λx atom x x appears body r λ y λx atom x x appears body r It easy check following function λ satisﬁes property λdel 1 1 λphl 1 2 λhl 1 3 λat 0 atom λhl 0 0 ﬂuent literal l cid2 Lemma 3 The program Π0a δ consistent unique answer set Proof It follows Lemma 2 23 cid2 Let X set atoms forms ﬂuentF literalL Clearly X splitting set 36 Φ0a s Π0a δ It easy parts Φ0a s Π0a δ respect X positive programs answer set cid2 U ﬂuentF literalF literal cid4 cid5 cid11 cid11 F F negF cid3 A1 Let Φ1a s Π1a δ denote evaluation parts Φ0a s Π0a δ respect U The rules programs listed condition rule follows rule Φ1a s contains following rules hl 1 oe 0 hψ 0 cid4 e causes l ψ D cid5 hl 0 hψ 0 cid4 l ψ D cid5 hl 1 hψ 1 cid4 cid5 l ψ D hL 1 hL 0 hL 1 hs 0 ha 0 Π1a δ contains following rules hl 1 oe 0 hψ 0 e causes l ψ D del 1 oe 0 hψ 0 cid4 cid4 cid5 cid5 e causes l ψ D phl 1 oe 0 hψ 0 del 1 e causes l ψ D cid4 cid5 phL 1 hL 0 deL 1 hl 0 hψ 0 cid4 cid5 l ψ D A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 cid5 hl 1 hψ 1 cid4 l ψ D phl 1 phψ 1 cid4 l ψ D hL 1 phL 1 hδ 0 ha 0 cid5 105 A13 A14 A15 A16 A17 Let Y set atoms form oe 0 hl 0 phl 0 Then easy Y splitting set Φ1a s Π1a δ Because s state Φ1a s respect Y unique answer set V oa 0 hs 0 Hence evaluation Φ1a s respect V following set rules hl 1 l direct effect s hl 1 hψ 1 cid4 l ψ D hL 1 hL 1 cid5 L holds s Let Φ2a s denote program Lemma 4 A answer set Φa s iff exists answer set A1 Φ2a s A U V A1 U V deﬁned A1 A18 Furthermore hl 1 A iff hl 1 A1 Proof By splitting set theorem 36 cid2 Similarly δ partial state Π1a δ unique answer set W oa 0 hδ 0 The evaluation Π1a δ respect W following set rules hl 1 l direct effect δ del 1 l direct effect δ phl 1 del 1 l possible direct effect δ phL 1 deL 1 L possibly holds δ hl 1 hψ 1 cid4 l ψ D cid5 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 106 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 phl 1 phψ 1 cid4 l ψ D hL 1 phL 1 cid5 Let denote program Π2a δ Lemma 5 B answer set Π0a δ iff exists answer set B0 Π2a δ B U W B0 U W deﬁned A1 A22 Furthermore hl 1 B iff hl 1 B0 Proof It follows splitting set theorem cid2 A28 A29 A30 A31 Let split program Π2a δ splitting set consisting atoms form del 1 The Π2a δ contains rules form A24 answer set cid2 del 1 cid11 cid11 l direct effect cid3 Hence evaluation Π2a δ respect answer set denoted Π3a δ contains following rules hl 1 l direct effect δ phl 1 l possible direct effect δ l direct effect phL 1 L possibly holds δ L direct effect hl 1 hψ 1 cid4 l ψ D phl 1 phψ 1 cid4 cid5 l ψ D hL 1 phL 1 cid5 Lemma 6 B answer set Π0a δ iff exists answer set B1 Π3a δ cid11 cid11 l direct effect δ B U W del 1 cid3 cid2 B1 Furthermore hl 1 B iff hl 1 B1 Proof It follows Lemma 5 splitting set theorem cid2 A32 A33 A34 A35 A36 A37 A38 A39 A40 For set atoms X let Φ X 2 s resp Π X 3 δ denote reduct Φ2a s resp Π3a δ respect X That Φ X 2 s following set rules hl 1 l direct effect s hl 1 hψ 1 cid4 l ψ D cid5 hL 1 cid4 L holds s hL 1 X cid5 A41 A42 A43 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 107 Π X 3 δ following set rules hl 1 l direct effect δ phl 1 l possible direct effect δ l direct effect phL 1 L possibly holds δ L direct effect hl 1 hψ 1 cid4 l ψ D phl 1 phψ 1 cid4 cid5 l ψ D cid5 hL 1 cid4 phL 1 X cid5 Let prove following lemma A44 A45 A46 A47 A48 A49 Lemma 7 Let A1 answer set Φ2a s B1 answer set Π3a δ If δ s ﬂuent literal l phl 1 B 1 implies hl 1 A1 Proof Suppose δ s Let P Φ A1 respectively 2 s Q Π B1 3 δ Because A1 B1 answer sets Φ2a s Π3a δ A1 B1 cid12 cid12 P T Q T A50 A51 A52 T P T Q immediate consequence operators programs P Q respectively First integer cid3 0 following result holds hl 1 T P phl 1 T Q Let prove induction 1 Base case 0 A52 holds T 0 P T 0 2 Inductive step suppose A52 holds k need holds k 1 Q Let l ﬂuent literal hl 1 T k1 hl 1 holds T k1 P rule A41 This means l direct effect s Observe direct effect s possible direct effect δ Furthermore D consistent l direct effect s Hence l direct effect δ As result rule A45 belongs Q implies phl 1 T k1 Q P P By deﬁnition T k1 cases b hl 1 holds T k1 P rule A42 This means exists static causal law 2 hψ 1 T k P By inductive hypothesis phψ 1 T k Q By rule A48 implies phl 1 T k1 Q c hl 1 holds T k1 P rule A43 This means l holds s hl 1 A1 Because l holds s l possibly holds δ On hand hl 1 A1 implies l direct effect s rule A41 Hence l direct effect δ Accordingly Q contains rule form A46 L l Thus follows phl 1 T k1 Q As result A52 holds The lemma directly follows A52 A50 A51 cid2 108 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Lemma 8 Let A answer set Φa s B answer set Π0a δ If δ s ﬂuent literal l hl 1 B implies hl 1 A Proof By Lemmas 4 6 programs Φ2a s Π3a s answer sets A1 B1 respectively A U V A1 B U W cid2 del 1 cid11 cid11 l direct effect δ cid3 B1 Let P Q programs deﬁned Lemma 7 First hl 1 T Q hl 1 A1 cid3 0 induction A53 1 Base case trivial exist ﬂuent literal l l T 2 Inductive step suppose A53 holds cid2 k Let l ﬂuent literal hl 1 T k1 hl 1 T k1 Q Q We need hl 1 A1 Consider following cases Q rule A44 This means l direct effect δ On hand direct effect δ direct effect s As result l direct effect s By rule A19 implies hl 1 A1 b hl 1 T k1 Q By inductive hypothesis hψ 1 Q rule A47 This implies hψ 1 T k A1 As result rule A20 follows hl 1 A1 c hl 1 T k1 Q rule A49 This implies phl 1 B 1 It follows Lemma 7 hl 1 A1 hl 1 A cid4 g hg 1 A From A54 l s cid4 cid4 Accordingly l s Let s l l belongs s From A53 A51 On hand Lemma 1 s state implies From follows hl 1 A hl 1 A1 cid4 cid4 A54 hl 1 B1 hl 1 A1 On hand Lemmas 4 6 hl 1 A1 iff hl 1 A hl 1 B1 iff hl 1 B Consequently conclude lemma holds cid2 Lemma 9 Πa δ consistent iff safe δ Proof Suppose Πa δ consistent Let B denote answer set Πa δ According deﬁnition answer set program constraints B answer set Π0a δ B violate constraints 6 8 This implies exists impossibility condition impossible b ψ D ob 0 B hψ 0 B Because oa 0 set atoms form oe 0 e elementary action contained B Lemma 5 exists impossibility condition impossible b ψ b ψ possibly holds δ By deﬁnition means safe δ Now suppose safe δ By Lemma 3 Π0a δ unique answer set B We B answer set Πa δ showing satisﬁes constraints 6 8 1 Constraint 6 Trivial safe δ 2 Constraint 8 Since δ partial state exists state s δ s As safe δ executable s By Theorem 3 follows program Φa s answer set A answer set satisﬁes constraint 8 By Lemma 8 follows B satisﬁes constraint 8 cid2 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 109 Lemma 10 If Πa δ consistent answer set Πa δ answer set Π0a δ Proof The lemma follows Lemma 3 fact Πa δ differs program Π0a δ constraints 6 8 cid2 A1 Proof Proposition 1 Suppose Πa δ consistent Lemma 10 implies answer set Πa δ answer set Π0a δ Let cid2 l cid11 cid11 hl 1 B cid3 cid4 δ To complete proof need δcid4 laws D constraint 5 So need exists state s partial state First observe δcid4 cid4 δcid4 s cid4 satisﬁes static causal Since δ partial state exists state s δ s Because Πa δ consistent Lemma 9 safe cid4cid5 T D By cid3s s cid4 l hl 1 A By Lemma 8 easy δ Thus executable s Since assume D consistent state s Theorem 2 implies program Φa s answer set A s δcid4 s cid4 cid4 A2 Proof Theorem 3 Let cid3δ δcid4cid5 transition T lpD It follows Deﬁnition 8 program Πa δ consistent answer set B δcid4 l hl 1 B Note Lemma 10 answer set B unique answer set Π0a δ First let T lpD approximation T D Clearly prove suﬃces s compδ 1 executable s 2 state s cid4 cid3s s cid4cid5 T D δcid4 s cid4 Consider state s compδ By Lemma 9 safe δ Because δ s executable s Now let s cid4cid5 T D By Theorem 2 implies exists answer set A Φa s s cid3s s Lemma 8 δcid4 l hl 1 B l hl 1 A s cid4 cid4 state cid4 l hl 1 A By We showed T lpD approximation T D The determinism T lpD follows directly fact B unique Appendix B Proof Theorem 5 This appendix contains proof Theorem 5 We assume planning problem P cid3δ0 D δ f cid5 given For sake simplicity proof similarly previous section begin simpliﬁcation program π P n Let π0P n program obtained π P n removing constraints 6 8 Let X set atoms forms ﬂuentF literalL Then X splitting set π0P n The π0P n positive program unique answer set U deﬁned A1 Let π1P n denote evaluation π0P n respect U Lemma 11 A set atoms C answer set π0P n iff C C1 U C1 answer set π1P n Proof Follows splitting set theorem cid2 For integer 0 cid2 cid2 n let Xi denote set atoms time parameters equal Then easy sequence cid3 Xicid5n i0 splitting sequence 36 π1P n Lemma 12 A set atoms C1 answer set π1P n iff sequence sets atoms cid3D icid5n conditions satisﬁed i0 following 1 D0 answer set μ0 b X0 cid4 cid5 π1P n 2 For 1 cid2 cid2 n D answer set cid4 cid13 cid4 μi e Xi b Xi cid5 π1P n b Xi1 cid5 π1P n cid12 cid14 D j 1cid2 jcid2i1 B1 B2 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 110 3 C1 ncid12 i0 D B3 b X P denote program P respect X e X Q V denote evaluation program Q relative V Proof Follows splitting sequence theorem 36 cid2 Now suppose C answer set π P n By deﬁnition C answer set π0P n C violate constraint π P n By Lemma 11 program π1P n answer set C1 C C1 U By Lemma 12 i0 satisﬁes B1B3 Let δi l hl D let follows exists sequence sets atoms cid3D icid5n ai l oe D It easy μ0 following set rules cid5 hl 0 hψ 0 cid4 l ψ D cid5 cid4 δ0 0 h oE 0 oE 0 cid3 1 μi following set rules hl l direct effect ai1 δi1 del l direct effect ai1 δi1 phl del l possible direct effect ai1 δi1 phL deL cid4 hL 1 D i1 cid5 hl hψ cid4 l ψ D cid5 cid5 phl phψ cid4 l ψ D hL phL oE 0 oE 0 B4 B5 B6 B7 B8 B9 B10 B11 B12 B13 B14 Lemma 13 If δi1 partial state cid3δi1 ai1 δicid5 T lpD Proof Suppose δi1 partial state To prove cid3δi1 ai1 δicid5 T lpD need Πai1 δi1 consistent answer set B satisﬁes cid2 l cid11 cid11 hl 1 B cid3 δi First observe C answer set π P n satisﬁes constraint 6 As result ai1 safe δi1 By Lemma 9 implies Πai1 δi1 consistent Proposition 1 unique answer set B By Lemma 5 program Π2ai1 δi1 rules A23A29 ai1 δ δi1 answer set B0 cid3 cid2 l cid11 cid11 hl 1 B cid11 cid11 hl 1 B0 Furthermore B0 unique Π2ai1 δi1 stratiﬁed cid2 l cid3 Observe program Π2ai1 δi1 μi time parameter predicates 1 Hence PH Tu et al Artiﬁcial Intelligence 175 2011 79119 111 cid2 l cid11 cid11 hl 1 B0 cid3 δi That lemma holds cid2 Let proof Theorem 5 It easy δ0 δ0 partial state By Lemma 13 easy 1 cid2 cid2 n cid3δi1 ai1 δicid5 T lpD Hence cid3δ0 α δncid5 T lpD On hand C satisﬁes constraint 19 δ f δn Accordingly α solution P Thus theorem proved Appendix C Proofs Propositions 24 Theorem 6 This appendix contains proofs Propositions 24 Theorem 6 We assume simple planning problem P given In addition simplicity assume body static causal law D exactly ﬂuent literal minor changes proofs appendix applied simple action theories arbitrary simple static causal laws including body To proofs easy follow let deﬁne notions Deﬁnition 17 Let action s state A ﬂuent literal l called effect s 1 l direct effect s 2 D contains static causal law l g g effect s Deﬁnition 18 Let action δ state A ﬂuent literal l called possible effect δ iff 1 l possible direct effect δ 2 l possibly holds inertia l possibly holds δ l direct effect δ 3 D contains static causal law l g g possible effect δ The proofs appendix use programs Φ2a s rules A19A21 Π3a δ rules A32A38 results Appendices A B Let s s partial states action cid3s s Theorems 2 3 Deﬁnition 8 programs Φa s Πa δ answer sets A B respectively cid4cid5 T D cid3δ δcid4cid5 T lpD By states δ δcid4 cid4 cid2 l cid11 cid11 hl 1 A cid3 cid4 s cid2 l cid11 cid11 hl 1 B cid3 cid4 δ C1 C2 By Lemmas 4 6 implies programs Φ2a δ Π3a δ answer sets A1 B1 respectively A U V A1 cid2 B U W del 1 cid11 cid11 l direct effect δ cid3 B1 U V W deﬁned A1 A18 A22 Furthermore hl 1 A iff hl 1 A1 hl 1 B iff hl 1 B1 C3 C4 C5 C6 Let P Q reducts Φ2a s Π3a δ respect A1 B1 respectively That P set rules A41A43 X A1 Q set rules A44A49 X B 1 Lemma 14 If g s hg 1 A1 g effect s 112 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Proof Let cid3 0 arbitrary integer Because A1 hg 1 T P g effect s We prove induction T P prove lemma suﬃces g s cid15 1 Base case 0 Trivial exists ﬂuent literal g hg 1 T 0 2 Inductive step Suppose lemma holds cid2 k We holds k 1 Let g ﬂuent literal P g s hg 1 T k1 P Because g hold s rule A43 L g belong P As result possibilities hg 1 T k1 g direct effect s By Deﬁnition 17 g effect s b D contains static causal law P g h hh 1 T k P It easy h s C7 C8 C9 g s note s state satisﬁes static causal law C7 From C8 C9 inductive hypothesis follows h effect s Hence Deﬁnition 17 g effect s cid2 Lemma 15 If phg 1 B1 g possible effect δ Proof Let cid3 0 arbitrary integer Clearly prove lemma suﬃces phg 1 T Q g possible effect δ Let prove C10 induction C10 1 Base case 0 Trivial phg 1 T 0 2 Inductive step Suppose C10 true cid2 k We true k 1 Q Let g ﬂuent literal phg 1 T k1 X B1 Hence possibilities phg 1 T k1 g possible direct effect δ g direct effect δ By deﬁnition g possible effect Q Recall Q set rules form A44A49 Q δ b g possibly holds δ g direct effect δ By deﬁnition case g possible effect δ c D contains static causal law g h phh 1 T k possible effect δ Q By inductive hypothesis h possible effect δ Hence Deﬁnition 18 g So C10 true The lemma follows directly result cid2 We need following proposition Proposition 6 Let D simple action theory Let cid3s s l s l cid16 s δ cid4 δcid4 cid4cid5 T D cid3δ δcid4cid5 T lpD If δ s ﬂuent literal Proof Suppose δ s l ﬂuent literal s l cid16 g cid4 δcid4 We need exists ﬂuent literal g s δ If l s δ proposition trivial deﬁnition l depends g l s δ l cid16 g Now consider case l s δ There possibilities PH Tu et al Artiﬁcial Intelligence 175 2011 79119 113 1 l s 2 l δ Let consider possibility turn 1 l s As l s cid4 δcid4 l s cid4 This implies hl 1 A1 According Lemma 14 l effect s It follows Deﬁnition 17 following cases occurs D contains dynamic causal law e causes l ψ e ψ holds s If ψ holds δ l direct effect δ By rule A44 hl 1 B 1 l δcid4 l s Because ψ holds s hold δ cid4 δcid4 This contradicts ψ s ψ cid3 δ As result exists ﬂuent literal g ψ g s δ By deﬁnition dependencies Deﬁnition 11 l cid16 g b D contains dynamic causal law e causes l0 ψ sequence static causal laws l1 l0 l2 l1 ln ln1 l ln e ψ holds s If ψ holds δ rule A44 l0 δcid4 laws D follows l δcid4 So ψ hold δ Similarly previous case implies exists ﬂuent literal g ψ g s δ Hence contradicts assumption l s hand δcid4 closed static causal cid4 δcid4 l cid16 ln cid16 ln1 cid16 cid16 l0 cid16 g 2 l δ First phl 1 B 1 Since l δcid4 According Lemma 15 phl 1 B 1 implies l possible effect δ By deﬁnition possible effect Deﬁnition 18 following cases l possible direct effect δ That D contains dynamic causal law hl 1 B1 By rule A49 follows phl 1 B 1 e causes l ψ e ψ possibly holds δ This implies ψ δ cid4 cid4 C11 As l s state l s direct effect s Hence ψ hold s s cid4 This means hl 1 A By rule A41 follows l ψ s cid7 C12 exists ﬂuent literal g ψ g s δ Because From C11 C12 e causes l ψ belongs D implies l cid16 g By deﬁnition dependencies follows l cid16 g follows b l hold δ l direct effect Because l δ case happens c D contains sequence static causal laws l1 l0 l2 l1 ln ln1 l ln l0 possible effect δ l0 possibly holds inertia l0 possible direct effect By deﬁnition means D contains dynamic causal law e causes l0 ψ e ψ possibly holds δ As ψ possibly holds δ ψ δ On hand easy ψ hold s l s contradicts assumption l s Therefore cid4 C13 cid4 114 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 ψ s cid7 C14 By C13 C14 exists ﬂuent literal g s δ g ψ It easy l cid16 ln cid16 ln1 cid16 cid16 l0 cid16 g Hence l cid16 g ii l0 possibly holds inertia This means l0 possibly holds δ l direct effect δ cid4 Because s state follows l0 s It easy l0 hold s l s l s As l0 possibly holds δ l0 s l0 s δ On hand deﬁnition dependencies l cid16 l0 Accordingly select g l0 s δ l cid16 g cid2 impossible cid4 C1 Proof Proposition 2 By deﬁnition cid17σ Deﬁnition 13 δ subset state s S Hence righthand equation proposition subset lefthand Therefore prove lemma suﬃcient cid13 cid16 cid14 sS s σ δ σ Suppose exists ﬂuent literal l l sS s σ l δ σ This implies l σ ii l s δ s S The implies l cid16 s δ s S By deﬁnition cid17 S cid7cid17σ δ This contradiction cid17 C2 Proof Proposition 3 1 Assume safe δ That means exists impossibility condition impossible b ψ b ψ possibly holds δ ψ δ C15 By deﬁnition cid17 S cid17σ δ implies exists state s S b cid2 s δ Because executable s ψ hold s ψ cid3 s Because s complete set ﬂuent literals follows ψ s cid7 C16 By C15 C16 exists ﬂuent literal l s δ l ψ By deﬁnition dependencies b cid16 l contradiction b cid2 s δ 2 Let S cid4 Resa S Consider arbitrary state s S Because executable S follows previous item safe δ By Lemma 9 Proposition 1 deﬁnition T lpD follows exists unique partial state δcid4 cid3δ δcid4cid5 T lpD We need S Suppose S Theorem 3 δcid4 s s exists ﬂuent literal l σ l cid3 s Then possible cases note δ s s S cid4 δcid4 s cid4 cid7cid17σ δcid4 cid4 S cid4 cid17σ δcid4 cid4 S cid4 cid4 Let l ﬂuent literal Consider arbitrary state s S let cid3s s let g s l cid16 g By Proposition 6 g s g cid16 h Because transitivity cid16 l cid16 h This implies cid4 δcid4 cid4 δcid4 cid4cid5 transition T D Furthermore ﬂuent literal h s δ l cid16 s δ C17 Because s arbitrary state S C17 implies S cid7cid17σ δ This contradiction cid4 δcid4 s b exists action b b cid16 s cid4 S cid4 Consider arbitrary state s S let cid3s b s literal b cid16 l By Proposition 6 l s deﬁnition dependencies follows b cid16 g s δ Hence cid4cid5 transition T D Furthermore let l s ﬂuent exists ﬂuent literal g s δ l cid16 g By cid4 δcid4 cid4 δcid4 b cid16 s δ C18 Because s arbitrary state S C18 implies S cid7cid17σ δ This contradiction PH Tu et al Artiﬁcial Intelligence 175 2011 79119 115 C3 Proof Proposition 4 Let α cid3a0 a1 an1cid5 For cid3 0 let αi denote chain initial events α αi cid3a0 a1 ai1cid5 We prove proposition induction length n α 1 Base case n 0 Item 1 trivial Item 2 true Resα S S cid17σ δ cid3δ cid3cid5 δcid5 T lpD T lpD deterministic 2 Inductive Step Suppose proposition true n cid2 k We need true n k 1 Let S Resαi S let δi partial state cid3δ αi δicid5 T lpD Clearly prove inductive step need ak safe δk b Sk1 cid17σ δk1 By inductive hypothesis Sk cid17σ δk By Proposition 3 follows ak safe δk Sk1 cid17σ δk1 C4 Proof Theorem 6 This theorem follows directly Proposition 4 deﬁnition simple planning problem Deﬁnition 14 If P solution trivial Suppose P solution α cid3a0 an1cid5 We π P n consistent Because α solution P exists sequence sets states cid3Scid5n i0 1 S0 compδ0 2 S Resai1 S i1 cid3 1 3 δ f s s Sn According Proposition 4 exists sequence partial states cid3δicid5n i0 δ0 δ0 Sn cid17 δ f δn By Proposi tion 2 δ f δn Let construct sequence sets atoms D follows cid5 cid4 δ0 0 D0 h 1 cid2 cid2 n 1 oa0 0 o A a0 0 cid2 D hl δi oai o A ai del cid11 cid3 cid11 l deai1 δi1 cid2 phl cid11 cid3 cid11 l phai1 δi1 cid2 hl n cid3 cid11 cid11 l δn cid2 Dn del n cid11 cid3 cid11 l dean1 δn1 cid2 phl n cid11 cid3 cid11 l phan1 δn1 It easy 0 cid2 cid2 n D answer set μi deﬁned previously Appendix B By Lemma 12 C1 answer set π1P n As result Lemma 11 C C1 U answer set π0P n We C answer set π P n Because π P n program π0P n additional straints 6 8 19 21 need C violate constraints For 6 8 trivial δi partial state andcid3δi1 ai1 δicid5 T lpD Constraint 19 satisﬁed C δ f δn Constraint 21 satisﬁed ai action nonempty set elementary actions Hence C answer set π P n This means program π P n consistent As result theorem holds cid15 n i0 D Appendix D Proof Theorem 8 We begin lemma operator ClD proof Given action theory D set ﬂuent literals σ let Λσ σ cid2 l cid11 cid11 l ψ D ψ σ cid3 D1 Let Λ0σ σ Λi1σ ΛΛiσ cid3 0 Since deﬁnition Λ set ﬂuent literals σ cid4 σ cid4 Λσ cid4 sequence cid3Λiσ cid5 bounded set ﬂuent literals Thus exists σ limit i0 monotonic respect set inclusion operation In addition cid3Λiσ cid5 i0 σ limit D cid12 Λiσ i0 Furthermore σ limit D unique satisﬁes static causal laws D D2 116 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 Lemma 16 For set ﬂuent literals σ σ limit D ClDσ Proof By induction easily Λiσ ClDσ cid3 0 Hence σ limit D ClDσ Furthermore construction Λiσ follows σ limit satisﬁes static causal laws D Because minimality property ClDσ ClDσ σ limit D Accordingly σ limit D ClDσ cid2 Lemma 17 For set ﬂuent literals σ ClosureDσ ClDσ Proof It easy function ClosureDσ straightforward computation σ limit Hence Lemma 16 ClosureDσ ClDσ cid2 D Eqs D2 D1 The following lemma shows code fragment correctly computes closure set ﬂuent literals Lemma 18 Let cid3 0 arbitrary integer x binary predicate symbol For set σ ﬂuent literals following program xl l σ xl xψ cid4 cid5 l ψ D unique answer set xl l ClDσ Proof By deﬁnition answer set positive program easy program unique answer set xl l σ limit xl l ClDσ Lemma 16 cid2 D Let action δ partial state Πa δ consistent By Proposition 1 Πa δ unique answer set B Let lit denote set ﬂuent literals lit F F We deﬁne dea δ l l direct effect δ pdea δ l l possible direct effect δ pha δ ClD cid5 pdea δ lit δ cid5 dea δ cid4cid4 D3 D4 D5 Then following lemma Lemma 19 For ﬂuent literal l hl 1 B iff l ClDdea δ lit pha δ Proof Because B answer set Πa δ answer set Π0a δ recall Π0a δ program obtained Πa δ removing constraints According Lemma 6 exists answer set B 1 program Π3a δ rules A32A38 A39 A40 hold It easy X phl 1 l lit splitting set Π3a δ The Π3a δ respect X following set rules phl 1 l possible direct effect δ l direct effect phL 1 L possibly holds δ L direct effect phl 1 phψ 1 cid4 l ψ D cid5 rewritten D3 D4 deﬁnition dea δ pdea δ PH Tu et al Artiﬁcial Intelligence 175 2011 79119 117 phl 1 cid4 l cid4 cid5 pdea δ dea δ cid4 cid4 lit cid5cid5cid5 δ dea δ phl 1 phψ 1 cid4 l ψ D cid5 By Lemma 17 program unique answer set D5 deﬁnition pha δ cid2 M phl 1 cid11 cid3 cid11 l pha δ Hence evaluation Π3a δ respect M following set rules hl 1 cid4 cid5 l dea δ hl 1 hψ 1 cid4 l ψ D cid5 hL 1 cid4 cid5 l pha δ Again Lemma 17 program unique answer set note l pha δ l lit pha δ cid5cid5cid3 cid4 cid2 hl 1 cid11 cid11 l ClD N dea δ cid4 lit pha δ By splitting set theorem B 1 M N Hence A40 cid4 hl 1 B cid5 cid4 l ClD cid4 dea δ cid4 lit pha δ cid5cid5cid5 Hence lemma holds cid2 We Theorem 8 holds By Lemma 18 easy ResD δ ClDdea δ lit pha δ By Lemma 19 follows Theorem 8 holds References 1 F Bacchus The AIPS00 planning competition AI Magazine 22 3 2001 httpwwwcstorontoeduaips2000 2 F Bacchus F Kabanza Using temporal logics express search control knowledge planning Artiﬁcial Intelligence 116 12 2000 123191 3 M Balduccini M Gelfond Diagnostic reasoning AProlog Theory Practice Logic Programming 3 45 2003 425461 4 M Balduccini M Gelfond M Nogueira Answer set based design knowledge systems Annals Mathematics Artiﬁcial Intelligence 2006 5 C Baral Reasoning actions Nondeterministic effects constraints qualiﬁcation Proceedings 14th International Joint Conference Artiﬁcial Intelligence Morgan Kaufmann Publishers San Francisco CA 1995 pp 20172023 6 C Baral V Kreinovich R Trejo Computational complexity planning approximate planning presence incompleteness Artiﬁcial Intelli gence 122 2000 241267 7 C Baral S McIlraith TC Son Formulating diagnostic problem solving action language narratives sensing Proceedings Seventh International Conference Principles Knowledge Representation Reasoning KR2000 2000 pp 311322 8 C Baral M Gelfond Reasoning agents dynamic domains J Minker Ed LogicBased Artiﬁcial Intelligence Kluwer Academic Publishers 2000 pp 257279 9 S Baselice PA Bonatti M Gelfond Towards integration answer set constraint solving Maurizio Gabbrielli Gopal Gupta Eds Logic Programming 21st International Conference ICLP 2005 Sitges Spain October 25 2005 Proceedings Lecture Notes Computer Science vol 3668 2005 pp 5266 10 A Blum M Furst Fast planning planning graph analysis Proceedings 14th International Joint Conference Artiﬁcial Intelligence Morgan Kaufmann Publishers San Francisco CA 1995 pp 16361642 11 B Bonet H Geffner GPT A tool planning uncertainty partial information A Cimatti H Geffner E Giunchiglia J Rintanen Eds Proceedings IJCAI01 Workshop Planning Uncertainty Partial Information Seattle WA 2001 pp 8287 12 R Brafman J Hoffmann Conformant planning heuristic forward search A new approach Sven Koenig Shlomo Zilberstein Jana Koehler Eds Proceedings 14th International Conference Automated Planning Scheduling ICAPS04 Morgan Kaufmann Whistler Canada 2004 pp 355364 13 D Bryce S Kambhampati D Smith Planning graph heuristics belief space search Journal Artiﬁcial Intelligence Research 26 2006 3599 14 C Castellini E Giunchiglia A Tacchella SATbased planning complex domains Concurrency constraints nondeterminism Artiﬁcial Intelli gence 147 July 2003 85117 15 A Cimatti M Roveri Conformant planning symbolic model checking Journal Artiﬁcial Intelligence Research 13 2000 305338 16 A Cimatti M Roveri P Bertoli Conformant planning symbolic model checking heuristic search Artiﬁcial Intelligence Journal 159 2004 127206 17 S Edelkamp J Hoffmann M Littman H Younes The IPC2004 Planning Competition httpls5wwwcsunidortmunddeedelkampipc4 2004 18 T Eiter W Faber N Leone G Pfeifer A Polleres A logic programming approach knowledge state planning II The DLV Artiﬁcial Intelli K gence 144 12 2003 157211 118 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 19 T Eiter N Leone C Mateis G Pfeifer F Scarcello The KR dlv Progress report comparisons benchmarks International Conference Principles Knowledge Representation Reasoning 1998 pp 406417 20 I Elkabani E Pontelli TC Son Smodels CLP applications A simple effective approach aggregates ASP Bart Demoen Vladimir Lifschitz Eds Logic Programming 20th International Conference ICLP 2004 SaintMalo France September 610 2004 Proceedings Lecture Notes Computer Science vol 3132 Springer 2004 pp 7389 21 P Ferraris E Giunchiglia Planning satisﬁability nondeterministic domains Proceedings Seventeenth National Conference Artiﬁcial Intelligence Twelfth Conference Innovative Applications Artiﬁcial Intelligence July 30August 3 2000 AAAI PressThe MIT Press Austin Texas USA 2000 pp 748753 22 M Gelfond A Gabaldon From functional speciﬁcations logic programs J Maluszynski Ed Proceedings International Symposium Logic Programming 1997 pp 355370 23 M Gelfond V Lifschitz The stable model semantics logic programming R Kowalski K Bowen Eds Logic Programming Proceedings Fifth International Conference Symposium 1988 pp 10701080 24 M Gelfond V Lifschitz Representing actions change logic programs Journal Logic Programming 17 234 1993 301323 25 M Gelfond V Lifschitz Action languages ETAI 3 6 1998 26 M Gelfond R Morales Encoding conformant planning aprolog Proceedings DRT04 Lecture Notes Computer Science Springer 2004 27 M Ghallab A Howe C Knoblock D McDermott A Ram M Veloso D Weld D Wilkins PDDL Planning Domain Deﬁnition Language Version 12 Technical Report CVC TR98003DCS TR1165 Yale Center Comp Vis Ctrl 1998 28 E Giunchiglia G Kartha V Lifschitz Representing action Indeterminacy ramiﬁcations Artiﬁcial Intelligence 95 1997 409443 29 E Giunchiglia V Lifschitz An action language based causal explanation preliminary report Proceedings AAAI 98 1998 pp 623630 30 S Hanks DV McDermott Default reasoning nonmonotonic logics frame problem Proceedings 5th National Conference Artiﬁcial Intelligence Morgan Kaufmann Philadelphia PA 1986 pp 328333 31 J Hoffmann B Nebel The FF planning Fast plan generation heuristic search Journal Artiﬁcial Intelligence Research 14 2001 253302 32 G Kartha V Lifschitz Actions indirect effects Preliminary report KR 94 1994 pp 341350 33 Y Lierler M Maratea Cmodels2 SATbased answer set solver enhanced nontight programs Vladimir Lifschitz Ilkka Niemelä Eds Proceedings 7th International Conference Logic Programming NonMonotonic Reasoning Conference LPNMR04 LNCS vol 2923 SpringerVerlag 2004 pp 346350 34 V Lifschitz Ed Formalizing Common Sense Papers John McCarthy Ablex Publishing Corporation 1989 35 V Lifschitz Answer set programming plan generation Artiﬁcial Intelligence 138 12 2002 3954 36 V Lifschitz H Turner Splitting logic program Pascal Van Hentenryck Ed Proceedings Eleventh International Conference Logic Programming 1994 pp 2338 37 V Lifschitz On logic causal explanation research note Artiﬁcial Intelligence 96 2 1997 451465 38 F Lin Embracing causality specifying indirect effects actions Proceedings 14th International Joint Conference Artiﬁcial Intelli gence Morgan Kaufmann Publishers San Mateo CA 1995 pp 19851993 39 Y Liu H Levesque Tractable reasoning incomplete ﬁrstorder knowledge dynamic systems contextdependent actions Proceedings 19th International Joint Conference Artiﬁcial Intelligence IJCAI Edinburgh Scotland 2005 40 D Long M Fox The 3rd international planning competition Results analysis Journal Artiﬁcial Intelligence Research JAIR 20 2003 159 httpplanningcisstrathacukcompetition 41 N McCain H Turner A causal theory ramiﬁcations qualiﬁcations Proceedings 14th International Joint Conference Artiﬁcial Intelligence Morgan Kaufmann Publishers San Mateo CA 1995 pp 19781984 42 J McCarthy Programs common sense Proceedings Teddington Conference Mechanization Thought Processes Her Majestys Stationery Oﬃce London 1959 pp 7591 43 J McCarthy Elaboration tolerance Proceedings 98s Common Sense Workshop 1998 httpwwwformalstanfordedujmcelaborationhtml 44 J McCarthy P Hayes Some philosophical problems standpoint artiﬁcial intelligence B Meltzer D Michie Eds Machine Intelligence vol 4 Edinburgh University Press Edinburgh 1969 pp 463502 45 D McDermott A critique pure reason Computational Intelligence 3 1987 151160 46 S McIlraith Integrating actions state constraints A closedform solution ramiﬁcation problem Artiﬁcial Intelligence 116 2000 87121 47 AR Morales PH Tu TC Son An extension conformant planning logic programming Manuela M Veloso Ed Proceedings 20th International Joint Conference Artiﬁcial Intelligence IJCAI 2007 Hyderabad India January 612 2007 pp 19911996 48 H Palacios H Geffner Compiling uncertainty away Solving conformant planning problems classical planner Proceedings TwentyFirst National Conference Artiﬁcial Intelligence 2006 49 H Palacios H Geffner From conformant classical planning Eﬃcient translations complete Proceedings 17th Interna tional Conference Planning Scheduling 2007 50 RPA Petrick F Bacchus A knowledgebased approach planning incomplete information sensing Proceedings Sixth International Conference Artiﬁcial Intelligence Planning Systems Toulouse France April 2327 2002 AAAI 2002 pp 212222 51 RPA Petrick F Bacchus Extending knowledgebased approach planning incomplete information sensing Proceedings Sixth International Conference Automated Planning Scheduling 2004 pp 211 52 J Rintanen Asymptotically optimal encodings conformant planning qbf Proceedings TwentySecond AAAI Conference Artiﬁcial Intelligence Vancouver British Columbia Canada July 2226 2007 AAAI Press 2007 pp 10451050 53 E Sandewall Assessments ramiﬁcation methods use static domain constraints LC Aiello J Doyle S Shapiro Eds Proceedings KRR Morgan Kaufmann 1996 pp 89110 54 M Shanahan The ramiﬁcation problem event calculus Proceedings Sixteenth International Joint Conference Artiﬁcial Intelligence IJCAI 99 Stockholm Sweden July 31August 6 1999 2 volumes 1450 pages 1999 pp 140146 55 P Simons N Niemelä T Soininen Extending implementing stable model semantics Artiﬁcial Intelligence 138 12 2002 181234 56 DE Smith DS Weld Conformant graphplan AAAI 1998 pp 889896 57 TC Son C Baral Formalizing sensing actions transition function based approach Artiﬁcial Intelligence 125 12 January 2001 1991 58 TC Son C Baral N Tran S McIlraith Domaindependent knowledge answer set planning ACM Transactions Computational Logic 7 4 2006 613657 59 TC Son E Pontelli Some results completeness approximation based reasoning Proceedings Tenth Paciﬁc Rim International Conference Artiﬁcial Intelligence 2008 pp 358369 60 TC Son PH Tu On completeness approximation based reasoning planning action theories incomplete information Proceedings 10th International Conference Principles Knowledge Representation Reasoning 2006 pp 481491 61 TC Son PH Tu M Gelfond R Morales An approximation action theories AL application conformant planning Proceedings 7th International Conference Logic Programming NonMonotonic Reasoning 2005 pp 172184 PH Tu et al Artiﬁcial Intelligence 175 2011 79119 119 62 TC Son PH Tu M Gelfond R Morales Conformant planning domains constraints new approach Proceedings Twentieth National Conference Artiﬁcial Intelligence 2005 pp 12111216 63 S Thiebaux J Hoffmann B Nebel In defense PDDL axioms Proceedings 18th International Joint Conference Artiﬁcial Intelligence IJCAI03 2003 64 M Thielscher Ramiﬁcation causality Artiﬁcial Intelligence 89 12 1997 317364 65 PH Tu Reasoning planning incomplete information presence static causal laws PhD thesis New Mexico State University 2007 66 PH Tu TC Son C Baral Reasoning planning sensing actions incomplete information static causal laws logic programming Theory Practice Logic Programming 7 2006 174 67 H Turner Representing actions logic programs default theories Journal Logic Programming 31 13 May 1997 245298 68 H Turner Polynomiallength planning spans polynomial hierarchy Proceedings Eighth European Conference Logics Artiﬁcial Intelligence JELIA02 2002 pp 111124