Artiﬁcial Intelligence 173 2009 10541078 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Range Roots Two common patterns specifying propagating counting occurrence constraints Christian Bessiere Emmanuel Hebrard b Brahim Hnich c Zeynep Kiziltan d Toby Walsh e LIRMM CNRS U Montpellier Montpellier France b 4C UCC Cork Ireland c Izmir University Economics Izmir Turkey d Department Computer Science Univ di Bologna Italy e NICTA UNSW Sydney Australia r t c l e n f o b s t r c t Article history Received 18 September 2007 Received revised form 26 February 2009 Accepted 3 March 2009 Available online 17 March 2009 Keywords Constraint programming Constraint satisfaction Global constraints Open global constraints Decompositions 1 Introduction We propose Range Roots common patterns useful specifying wide range counting occurrence constraints We design specialised propagation algorithms patterns Counting occurrence constraints speciﬁed patterns directly inherit propagation algorithm To illustrate capabilities Range Roots constraints specify number global constraints taken literature Preliminary experiments demonstrate propagating counting occurrence constraints patterns leads small loss performance compared specialised global constraints competitive alternative decompositions elementary constraints 2009 Elsevier BV All rights reserved Global constraints central success constraint programming 25 Global constraints allow users specify patterns occur problems exploit eﬃcient effective propagation algorithms pruning search space Two common types global constraints counting occurrence constraints Occurrence constraints place strictions occurrences particular values For instance wish ensure value set variables occurs second set Counting constraints hand restrict number values variables meeting condition For example want limit number distinct values assigned set variables Many dif ferent counting occurrences constraints proposed help model wide range problems especially involving resources example 2242335 In paper constraints speciﬁed means new global constraints Range Roots standard elementary constraints like subset set cardinality These new global straints capture familiar notions image domain function Understanding notions require strong This paper compilation extension C Bessiere E Hebrard B Hnich Z Kiziltan T Walsh The RANGE ROOTS constraints Specifying counting occurrence problems LP Kaelbling A Saﬃotti Eds IJCAI Professional Book Center 2005 pp 6065 C Bessiere E Hebrard B Hnich Z Kiziltan T Walsh The RANGE constraint Algorithms implementation JC Beck BM Smith Eds CPAIOR Lecture Notes Computer Science vol 3990 Springer 2006 pp 5973 C Bessiere E Hebrard B Hnich Z Kiziltan T Walsh The ROOTS constraint F Benhamou Ed CP Lecture Notes Computer Science vol 4204 Springer 2006 pp 7590 The ﬁrst author supported ANR project ANR06BLAN038302 Corresponding author Email addresses bessierelirmmfr C Bessiere ehebrard4cuccie E Hebrard brahimhnichieuedutr B Hnich zeynepcsuniboit Z Kiziltan twcseunsweduau T Walsh 00043702 matter 2009 Elsevier BV All rights reserved doi101016jartint200903001 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1055 background constraint programming A basic mathematical background suﬃcient understand constraints use specify global constraints We example Range Roots versatile allow speciﬁcation open global constraints recent kind global constraints set variables involved known advance Speciﬁcations Range Roots constraints executable We eﬃcient propagators signed Range Roots constraints We eﬃcient algorithm propagating Range constraint based ﬂow algorithm We prove intractable propagate Roots constraint completely We propose decomposition Roots constraint propagate partially linear time This decomposition destroy global nature Roots constraint situations met practice prunes possible values The proposed propagators easily incorporated constraint toolkit We specifying global constraint Range Roots provides reasonable method propagate counting occurrence constraints There possible situations In ﬁrst global nature Range Roots constraints capture global nature given counting occurrence constraint propagation hindered In second situation completely propagating counting occurrence constraint NPhard We accept loss propagation propagation tractable Using Range Roots means propagate counting occurrence constraint partially In situation global constraint propagated completely polynomial time Roots Range hinders propagation In case want achieve propagation need develop specialised propagation algorithm We decomposing occurrence constraints counting constraints Range Roots constraints performs practice Our experiments random CSPs real world problem CSPLib demonstrate propagating counting occurrence constraints Range Roots constraints leads small loss performance compared specialised global constraints competitive alternative decompositions elementary constraints The rest paper organised follows Section 2 gives formal background Section 3 deﬁnes Range Roots constraints gives couple examples illustrate global constraints decomposed constraints In Section 4 propose polynomial algorithm Range constraint In Section 5 complete theoretical analysis Roots constraint decomposition discuss implementation details Section 6 gives examples counting occurrence constraints speciﬁed Range Roots constraints Experimental results presented Section 7 Finally end conclusions Section 8 2 Formal background A constraint satisfaction problem consists set variables ﬁnite domain values set straints specifying allowed combinations values subsets variables We use capitals variables X Y S lower case values v w We write D X domain variable X A solution assignment values variables satisfying constraints A variable ground assigned value We consider integer set variables A set variable S represented lower bound lbS contains deﬁnite elements belong set upper bound ubS contains potential elements belong set Constraint solvers typically explore partial assignments enforcing local consistency property specialised general purpose propagation algorithms Given constraint C bound support C tuple assigns integer variable value minimum maximum set variable set lower upper bounds satisﬁes C A bound support integer variable assigned value domain called hybrid support If C involves integer variables hybrid support support A value resp set values integer variable resp set variable bound hybrid consistent C iff exists bound hybrid support assigning value resp set values variable A constraint C bound consistent BC iff integer variable Xi minimum maximum values belong bound support set variable S j values ubS j belong S j bound support values lbS j ubS j belong S j bound supports A constraint C hybrid consistent HC iff integer variable Xi value D Xi belongs hybrid support set variable S j values ubS j belong S j hybrid support values lbS j ubS j belong S j hybrid supports A constraint C involving integer variables generalised arc consistent GAC iff variable Xi value D Xi belongs support If variables C integer variables hybrid consistency reduces generalised arc consistency variables C set variables hybrid consistency reduces bound consistency To illustrate different concepts consider constraint C X1 X2 T holds iff set variable T assigned exactly values integer variables X1 X2 Let D X1 1 3 D X2 2 4 lbT 2 ubT 1 2 3 4 BC remove value domains bound consistent value 2 considered possible X1 BC deals bounds On hand HC removes 4 D X2 ubT exist tuple satisfying C X2 value 2 We compare local consistency properties applied sets logically equivalent constraints c1 c2 As 15 local consistency property Φ c1 strong Ψ c2 iff given domains Φ holds c1 Ψ holds c2 Φ c1 stronger Ψ c2 iff Φ c1 strong Ψ c2 vice versa Φ c1 equivalent Ψ c2 iff 1056 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 Φ c1 strong Ψ c2 vice versa Φ c1 incomparable Ψ c2 iff Φ c1 strong Ψ c2 vice versa A total function F source set S target set T denoted F S T The set elements S F whilst F 1 j Throughout view set integer variables X1 Xn image j T F 1 j F j The image set S S F F S domain set T T F F 1T jT D Xi That X value Xi function X 1 n iS cid2 cid2 cid2 i1 3 Two useful patterns Range Roots Many counting occurrence constraints speciﬁed simple nonglobal constraints integer variables like X cid2 m simple nonglobal constraints set variables like S 1 S2 S k available constraint solvers special global constraints acting sequences variables Range Roots Range captures notion image function Roots captures notion domain Speciﬁcation Range Roots executable It permits decompose global constraints primitive constraints Given function X representing set integer variables X1 Xn Range constraint holds iff set variable T image set variable S X cid3 X1 Xn S T Range cid4 iff T X S cid3 T Xi S cid4 The Roots constraint holds iff set variable S domain set variable T X cid3 X1 Xn S T Roots cid4 iff S X 1T cid3 S Xi T cid4 Range Roots exact inverses A Range constraint hold corresponding Roots constraint vice versa For instance Range1 1 1 1 holds Roots1 1 1 1 X 11 1 2 Roots1 1 1 1 2 3 1 2 holds Range1 1 1 1 2 3 1 2 Xi assigned 2 Before showing propagate Range Roots eﬃciently examples illustrate counting occurrence global constraints 2 speciﬁed Range Roots The NValue constraint counts number distinct values sequence variables 1987 NValue X1 Xn N holds iff N Xi 1 cid2 cid2 n A way implement constraint Range constraint cid3 X1 Xn N NValue cid3 X1 Xn 1 n T Range iff cid4 cid4 T N The AtMost constraint oldest global constraints 29 The AtMost constraint puts upper bound number variables particular value AtMost X1 Xn d N holds iff Xi d cid2 N It decomposed Roots constraint cid3 X1 Xn d N AtMost cid3 cid4 X1 Xn S d Roots cid4 iff S cid2 N These examples simple decompose global constraints Range Roots As later global constraints require use Range Roots decomposition The sections Range Roots propagated eﬃciently 4 Propagating Range constraint Enforcing hybrid consistency Range constraint polynomial This maximum network ﬂow problem In fact Range constraint decomposed global cardinality constraint Gcc propagators based ﬂow problems exist 2321 But Range constraint need power maximum network ﬂow problems HC enforced lower cost calling Gcc propagator In section propose eﬃcient way enforce HC Range To simplify presentation use ﬂow limited constraint performs work needed enforcing HC Range This constraint Occurs X1 Xn T ensures values set variable T integer variables X1 Xn cid3 X1 Xn T Occurs cid4 iff T X cid4 cid3 1n cid3 T Xi 1n cid4 We ﬁrst present algorithm achieving HC Occurs Section 41 use propagate Range constraint Section 42 41 Hybrid consistency Occurs We achieve HC Occurs X1 Xn T network ﬂow C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1057 Fig 1 Unit capacity network constraint C Occurs X1 X2 X3 T D X1 1 2 D X2 2 3 4 D X3 3 4 lbT 3 4 ubT 1 2 3 4 Arcs directed left right Fig 2 A maximum ﬂow network Fig 1 Bold arcs belong ﬂow Arcs directed left right 411 Building network ﬂow We use unit capacity network 1 capacities nodes 0 1 This represented directed graph arc node x node y means maximum ﬂow 1 allowed x y absence arc means maximum ﬂow allowed 0 The unit capacity network G C N E constraint C Occurs X1 Xn T built following way N s N1 N2 t s source node t sink node N1 v v cid3 s N1 D Xi xi 1n The set arcs E follows cid6 v zv v lbT D Xi N2 zv v cid7 cid6 cid7 v D Xi N2 t v xi E cid2 cid2 cid5 cid5 cid3 cid4 cid4 G C quadripartite E s N1 N1 N2 N2 t In Fig 1 depict network G C constraint C Occurs X1 X2 X3 T D X1 1 2 D X2 2 3 4 D X3 3 4 lbT 3 4 ubT 1 2 3 4 The intuition graph ﬂow uses arc node v node xi means Xi assigned v ﬂow uses arc v zv means v necessarily Xi s1 In Fig 1 nodes 3 4 linked nodes x2 x3 values 3 4 necessarily taken variables Xi 3 4 belong lbT On contrary nodes 1 2 linked nodes z1 z2 values 1 2 taken Xi lbT cid9 In particular case unit capacity networks ﬂow set E assigned 1 arcs assigned 0 A feasible ﬂow s t G C subset E f E n N s t number arcs E E cid9cid9 E f The value E f entering n equal number arcs E f going n n ﬂow E f s t denoted valE f s t valE f s t n s n E f A maximum ﬂow s t G C feasible ﬂow E M exist feasible ﬂow E f valE f s t valE M s t A maximum ﬂow network Fig 1 given Fig 2 By construction feasible ﬂow value greater N1 contain arcs entering node xi N2 Hence deﬁne function ϕ linking feasible ﬂows partial instantiations Xi s Given feasible ﬂow E f s t G C ϕE f Xi v v xi E f The maximum ﬂow Fig 2 corresponds instantiation X2 4 X3 3 The way G C built induces following theorem cid9 n E f n n cid9 E arc E cid9 1 Note presentation graph edges nodes representing values nodes representing variables This opposite direction presentation network ﬂows propagators AllDifferent Gcc constraints 2223 1058 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 Fig 3 Residual graph obtained network Fig 1 maximum ﬂow Fig 2 Theorem 1 Let G C N E capacity network constraint C Occurs X1 Xn T 1 A value v domain D Xi 1n HC iff exists ﬂow E f s t G C valE f s t N1 v xi E f 2 If Xi s HC T HC iff ubT cid2 D Xi Proof 1 Let I solution C Xi v I Build following ﬂow H Put v xi H w IT w cid11 v cid9 cid11 v variable X j X j w I know I solution w x j H w cid9 zwcid9 H Add H edges s N1 N2 t obtain feasible ﬂow By construction add w w N1 belong edge H So valH s t N1 H maximum ﬂow v xi H 1 Let E M ﬂow s t G C v xi E M valE M s t N1 By construction G C guaranteed nodes N1 belong arc E M N1 N2 value w lbT y w y E xi 1n Thus w lbT X j X j w ϕE M Hence extension ϕE M unassigned X j takes value D X j T lbT solution C Xi v cid9 IT w 2 If T HC values ubT appear solution tuple Since C ensures T cid2 Xi ubT contain value appearing D Xi cid2 cid2 2 Let ubT D Xi taken Xi cid9 cid9T IT v I solution tuple I Build tuple I solution C So ubT tight wrt HC In addition Xi s HC means solution tuple I v lbT exists I Xi v So lbT HC cid2 D Xi Since Xi s HC know value v cid9 Xi I Xi 1n I I cid9 Following Theorem 1 need way check edges belong maximum ﬂow Residual graphs useful task Given unit capacity network G C maximal ﬂow E M s t G C residual graph R G C E M N E R directed graph obtained G C reversing arcs belonging maximum ﬂow E M E R x y E E M y x x y E E M Given network G C Fig 1 maximum ﬂow E M Fig 2 R G C E M depicted Fig 3 Given maximum ﬂow E M s t G C given x y N1 N2 E E M exists maximum ﬂow containing x y iff x y belongs cycle R G C E M 26 Furthermore ﬁnding arcs x y belong cycle graph performed building strongly connected components graph We Fig 3 arcs 1 x1 2 x1 belong cycle So belong maximum ﬂow X1 1 X1 2 hybrid consistent 2 x2 belong cycle So X2 2 HC 412 Using network ﬂow achieving HC Occurs We tools achieving HC Occurs constraint We ﬁrst build G C We compute maximum ﬂow E M s t G C valE M s t N1 fail Otherwise compute R G C E M build strongly connected components R G C E M remove D Xi value v v xi belongs E M strongly connected component R G C E M Finally set ubT ubT D Xi Following Theorem 1 properties residual graphs algorithm enforces HC Occurs X1 Xn T cid2 Complexity Building G C O nd d maximum domain size We need ﬁnd maximum ﬂow E M G C This substeps First use arc v zv v lbT O D Xi Afterwards compute maximum ﬂow subgraph composed paths traversing nodes w w lbT k e arc w zw G C w The complexity ﬁnding maximum ﬂow unit capacity network O lbT lbT n second k number nodes e number edges This gives complexity O substep Building residual graph computing strongly connected components O nd Extracting HC domains Xi s direct There remains compute BC T takes O nd Therefore total complexity O nd n lbT 32 cid2 cid8 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1059 procedure PropagRange X1 Xn S T 1 Introduce set integer variables Y Y ubS DY D Xi dummy 2 Achieve hybrid consistency constraint OccursY T 3 Achieve hybrid consistency constraints S Y T Y Y 4 Achieve GAC constraints Y dummy Y Xi Y Y Algorithm 1 Hybrid consistency Range Incrementality In constraint solvers constraints usually maintained locally consistent state modiﬁcation restriction domains variables It interesting consider total complexity maintaining HC Occurs arbitrary number restrictions domains values removed D Xi ubT added lbT descend branch backtracking search tree Whereas constraints completely incremental total complexity number restrictions complexity propagation case constraints based ﬂow techniques like AllDifferent Gcc 2223 They potentially require computation new maximum ﬂow modiﬁcation Restoring maximum ﬂow lost p edges O p e If values removed nd possible times removal affects current maximum ﬂow overall complexity sequence restrictions Xi s S T O n2d2 42 Hybrid consistency Range Enforcing HC Range X1 Xn S T decomposing Occurs constraint new variables Y channelling constraints 14 linking T Y s S Xi s Interestingly need maintain HC decomposition need propagate constraints pass The algorithm PropagRange enforcing HC Range constraint presented Algorithm 1 In line 1 special encoding built Y introduced Xi index ubS The domain Y Xi plus dummy value The dummy value works ﬂag If Occurs prunes DY means Y necessary Occurs cover lbT Then Xi necessary cover lbT Range In line 2 HC Occurs removes value Y time contains values necessary cover lbT solution tuple HC removes values ubT covered Y solution Line 3 updates bounds S domain Y s Finally line 4 channelling constraints Y Xi propagate removals Xi belongs S solutions Theorem 2 The algorithm PropagRange correct algorithm enforcing HC Range runs O nd n lbT 32 time d maximal size Xi domains Proof Soundness A value v removed D Xi line 4 removed Y dummy lines 2 3 If value v removed Y line 2 means tuple variables Y covering lbT requires Y takes value DY v So ﬁnd solution Range Xi v lbT covered A value v removed DY line 3 lbS v ubT In case Range satisﬁed tuple Xi v If value v removed ubT line 2 tuples values variables Y covering lbT cover v Since variables Y duplicate variables Xi index ubS hope satisfy Range v T Note ubT modiﬁed line 3 Y contains variables Y ubS If value v added lbT line 3 exists lbS DY ubT v Hence v necessarily T solutions Range An index removed ubS line 3 This happens domain Y intersect ubT In case evident tuple S satisfy Range Xi value T Finally index added lbS line 3 DY included lbT means dummy value removed DY line 2 This means Y takes value lbT solutions Occurs Xi value lbT solutions Range Completeness Suppose value v pruned D Xi line 4 PropagRange If Y Y know line 2 instantiation I Y T solution Occurs IY v Y dummy thanks X1 Xn S T Xi takes value v X j channelling constraints line 4 We build tuple I j ubS IY j IT takes IY j remaining X j s value domain T set IT plus values taken X j s j lbS These values ubT thanks line 3 Finally S set lbS plus indices Y j s IY j IT These indices ubS js removed ubS line 3 cid9 Xi v We DY j ubT prevents IY j taking value IT Thus I proved Xi s hybrid consistent PropagRange solution Range I Suppose value ubS line 4 Thanks constraint line 3 know exists v DY ubT v D Xi ubT Now Xi hybrid consistent line 4 Thus Xi v belongs solution Range If modify solution putting S v T solution cid9 cid9 Completeness lbS lbT ubT proved similar way 1060 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 Complexity The important thing notice PropagRange constraints lines 24 propagated sequence Thus Occurs propagated complexity O nd n lbT 32 Lines 1 3 4 O nd Thus complexity PropagRange O nd n lbT 32 This reduces linear time complexity lbT Incrementality The overall complexity sequence restrictions Xi s S T O n2d2 See incrementality Occurs Section 41 cid2 Note Range constraint decomposed Gcc constraint However propagation decompo sition O n2d n266 time complexity 21 PropagRange signiﬁcantly cheaper 5 Propagating Roots constraint We thorough theoretical analysis Roots constraint In Section 51 provide proof enforcing HC Roots NPhard general Section 52 presents decomposition Roots constraint permits propagate Roots constraint partially linear time Section 53 shows cases decomposition destroy global nature Roots constraint enforcing HC decomposition achieves HC Roots constraint Section 54 shows obtain BC Roots constraint enforcing BC decomposition Finally provide implementation details Section 55 51 Complete propagation Unfortunately propagating Roots constraint completely intractable general Whilst claim 10 proof published For reason Theorem 3 Enforcing HC Roots constraint NPhard Proof We transform 3Sat problem existence solution Roots Finding hybrid support NP hard Hence enforcing HC Roots NPhard Let ϕ c1 cm 3CNF Boolean variables x1 xn We build constraint Roots X1 Xnm S T follows Each Boolean variable xi represented variable Xi domain D Xi Each clause c p xi x j xk represented variable Xnp domain D Xnp j k We build S T way impossible index Boolean variable xi complement lbS ubS n 1 n m An interpretation M belong T We set lbT ubT Boolean variables x1 xn model ϕ iff tuple τ τ Xi iff Mxi 0 extended solution Roots This extension puts T value iff Mxi 1 assigns Xnp value corresponding literal satisfying c p M cid2 cid2 n i1 We look lesser level consistency Roots particular cases HC polynomial We bound consistency tractable conditions met practice arguments Roots ground enforcing HC 52 A decomposition Roots To Roots propagated tractably straightforward decomposition ternary constraints propagated linear time This decomposition destroy global nature Roots constraint enforcing HC decomposition cases achieve HC original Roots constraint cases enforcing BC decomposition achieves BC original Roots constraint Given Roots X1 Xn S T decompose implications S Xi T Xi T S 1n We careful implement decomposition constraint solver First solvers achieve HC constraints Section 55 details Second need eﬃcient algorithm able propagate decomposition linear time As explain Section 55 constraint solver easily quadratic time incremental We ﬁrst decomposition prevents propagating Roots constraint completely However expected propagating Roots completely NPhard decomposition linear propagate In addition later circumstances met practice decomposition fact hinder propagation Theorem 4 HC Roots X1 Xn S T strictly stronger HC S Xi T Xi T S 1n C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1061 Proof Consider X1 1 2 X2 3 4 X3 1 3 X4 2 3 lbS ubS 3 4 lbT ubT 1 2 3 4 The decomposition HC However enforcing HC Roots prune 3 D X2 cid2 In fact enforcing HC decomposition achieves level consistency BC HC original Roots constraint Consider X1 1 2 3 X2 1 2 3 lbS ubS 1 2 lbT ubT 1 3 The Roots constraint BC However enforcing HC decomposition remove 2 domains X1 X2 In section identify exactly decomposition achieves HC Roots 53 Some special cases Many counting occurrence constraints use Roots constraint general form restrictions variables S T Xi s For example case T S ground We select important cases cover uses Roots enforcing HC Roots tractable C1 lbS D Xi lbT C2 ubS D Xi ubT C3 X1 Xn ground C4 T ground We cases achieve HC Roots simply propagating decomposition Theorem 5 If conditions C 1 C 4 holds enforcing HC S Xi T Xi T S 1n achieves HC Roots X1 Xn S T Proof Our proof exploit following properties guaranteed hold enforced HC decomposition P1 D Xi lbT lbS P2 D Xi ubT ubS P3 lbS D Xi ubT P4 ubS D Xi lbT P5 D Xi v lbS v lbT P6 D Xi v ubS v ubT P7 added lbS constraint Xi T S D Xi lbT P8 deleted ubS constraint S Xi T D Xi ubT Soundness Immediate Completeness We assume conditions C1C4 holds decomposition HC We ﬁrst prove Roots constraint satisﬁable Then prove Xi values D Xi belong solution Roots bounds S T tight possible We prove Roots constraint satisﬁable Suppose conditions C1C4 holds decom position HC Build following tuple τ values Xi S T Initialise τ S τ T lbS lbT respectively Now let consider conditions separately C1 For τ S choose value v D Xi τ Xi From assumption property P7 deduce v lbT τ T For assign Xi value D Xi lbT This set thanks property P1 τ obviously satisﬁes Roots C2 For τ S choose value D Xi τ Xi By construction value ubT thanks property P3 If necessary add τ Xi τ T For ubS assign Xi value D Xi τ T possible Otherwise assign Xi value D Xi add τ S For ubS assign Xi value domain By assumption property P8 know D Xi ubT Thus τ satisﬁes Roots C3 τ Xi assigned Xi For τ S property P5 tells τ Xi τ T lbS property P1 tells τ Xi outside lbT τ satisﬁes Roots C4 For τ S choose value v D Xi τ Xi Property P3 tells v ubT By assumption v τ T For outside ubS assign Xi value v D Xi v outside τ T assumption property P4 For assign Xi value D Xi update τ S necessary τ satisﬁes Roots We proved Roots constraint solution We prove value ubS ubT D Xi Xi transform arbitrary solution Roots solution contains value Similarly value lbS lbT transform arbitrary solution Roots solution contain value Let prove lbT tight Suppose tuple τ solution Roots constraint Let v lbT v τ T We exists solution v τ T Remark case irrelevant condition C4 We remove v 1062 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 cid9 cid9 cid9 τ add v τ T For lbS τ Xi v remove τ S With C1 sure lbS τ Xi v thanks property P7 fact v lbT With C3 sure lbS τ Xi v thanks property P5 fact v lbT There remains check C2 For lbS know cid9 D Xi ubT thanks properties P3 P5 We set Xi v cid9 cid11 v v τ T add k v cid9 τ S We sure k ubS v τ Xk v cid9 cid9 ubT plus condition C2 property P8 Completeness ubT lbS ubS Xi s shown similar proofs Let v ubT τ T Again C4 irrelevant We exists solution v τ T Add v τ T ubS τ Xi v τ S C2 solved thanks property P8 fact v ubT C3 solved thanks property P6 fact v ubT cid9 D Xi lbT thanks properties There remains check C1 For ubS τ Xi v know v cid9 removed τ S τ remove v P4 P6 We set Xi v possible condition C1 v cid9 cid11 v v τ T Each k τ Xk v cid9 lbT thanks property P7 Let v D Xi τ Xi v cid9 cid11 v C3 irrelevant Assign v Xi τ If v v cid9 τ T cid9 τ T alternatives satisfy Roots add There remain cases First v τ T v τ S remove v τ T If ubS add τ S If ubS know v lbT thanks property P4 So v removed τ T sure X j s updated consistently reason cid9 τ T alternatives satisfy Roots remove τ S proof lbT Second v τ T v add v τ T If lbS remove τ S If lbS know v ubT thanks property P3 So v added τ T sure X j s updated consistently reason proof ubT τ T Let lbS τ S We exists solution τ S We remove τ S Thanks property cid9 D Xi lbT With C4 sure cid9 τ T remove τ T sure X j s P1 know D Xi cid2 lbT So set Xi value v cid9 τ T With conditions C1 C2 C3 v v updated consistently reason proof lbT cid9 v Let ubS τ S We exists solution τ S We add τ S Thanks property P2 cid9 D Xi ubT With condition C4 cid9 τ T add τ T sure X j s updated know D Xi ubT cid11 So set Xi value v cid9 τ T With conditions C1 C2 C3 v sure v consistently reason proof ubT τ T cid2 54 Bound consistency In addition able enforce HC Roots special cases enforcing HC decomposition en forces level consistency strong BC In fact situation enforcing HC intractable enforcing BC decomposition enforces BC Roots constraint Theorem 6 Enforcing BC S Xi T Xi T S 1n achieves BC Roots X1 Xn S T Proof Soundness Immediate Completeness The proof follows structure Theorem 5 We relax properties P1P4 properties cid9 P4 cid9 P1 cid9 cid9 cid9 cid9 P1 P2 P3 P4 min Xi max Xi lbT lbS min Xi max Xi ubT ubS lbS bounds Xi included ubT ubS bounds Xi outside lbT cid2 Let prove lbT ubT tight Let o total ordering D D Xi ubT Build tuples σ τ follows For v lbT v σ T τ T For v ubT lbT following o v σ T cid9 τ T alternately For lbS P3 guarantees min Xi max Xi ubT By construction σ T τ T alternation values min Xi cid11 max Xi sure exists value σ T τ T min Xi max Xi In case D Xi 1 P5 guarantees value σ T τ T Thus assign Xi σ τ value σ T τ T For ubS assign Xi σ value min Xi max Xi σ T τ We know value exists reasoning lbS alternation values cid9 P6 We complete σ τ building σ S τ S consistently assignments Xi T The thanks P4 resulting tuples satisfy Roots From deduce lbT ubT BC values ubT lbT σ τ We Xi BC Take Xi lower bound min Xi If lbS know min Xi T cid9 construction σ τ We assign min Xi Xi relevant tuple This remains σ τ thanks P3 cid9 solution Roots If ubS know min Xi outside T σ τ thanks P4 construction σ τ We assign min Xi Xi relevant tuple This remains solution Roots If ubS lbS assign Xi min Xi σ If min Xi σ T remove σ S add σ S The tuple obtained solution Roots lower bound Xi By reasoning upper bound Xi BC Xi s BC C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1063 We prove lbS ubS BC similar proofs Let ubS BC Take Xi ubS σ S Since Xi assigned value min Xi max Xi σ built know cid9 min Xi max Xi ubT cid11 thanks P2 modify σ assigning Xi value ubT putting value T adding S The tuple obtained satisﬁes Roots So ubS BC cid9 There remains lbS BC Thanks P1 know values ubS lbS min Xi max Xi lbT cid11 Take v min Xi max Xi lbT Thus σ τ v T Take cor responding tuple assign Xi v remove S The modiﬁed tuple solution Roots lbS BC cid2 55 Implementation details This decomposition Roots constraint implemented solvers disjunctions membership negated membership constraints ormemberi S notmember Xi T ornotmemberi S member Xi T How requires little care Unfortunately existing solvers like Ilog Solver 16 achieve HC disjunctions primitives For instance negated membership constraint notmember Xi T activated Xi instantiated value T soon D Xi lbT We ensure solver wakes ensure achieve HC As explain complexity proof careful solver wake lose optimal O nd time complexity achieved Theorem 7 It possible enforce HC BC decomposition Roots X1 Xn S T O nd time d maxiD Xi ubT Proof The decomposition Roots composed 2n constraints To obtain overall complexity O nd total work spent propagating constraints O d time First necessary 2n constraints decomposition called propagation d times Since S modiﬁed n times n larger d important constraints called propagation change lbS ubS By implementing propagating events described 1727 ensure value added lbS removed ubS constraints j S X j T X j T j S j cid11 called propagation Second enforcing HC constraint S Xi T O d time Testing precondition belong lbS constant time If true removing D Xi values ubT O d time updating lbT D Xi 1 constant time Testing postcondition false D Xi disjoint ubT O d time If false updating ubS constant time Thus HC S Xi T O d time Enforcing HC Xi T S O d time testing precondition D Xi lbT O d time updating lbS constant time testing postcondition false ubS constant time removing D Xi values lbT O d time updating ubT D Xi 1 constant time When T modiﬁed constraints potentially concerned Since T modiﬁed d times d calls propagation O d time 2n constraints It important propagation 2n constraints incremental avoid O nd2 overall complexity An algorithm S Xi T incremental complexity calling propagation constraint S Xi T d times change T D Xi propagating constraint This achieved AC2001like algorithm stores value D Xi ubT witness postcondition true Similarly value D Xi lbT witness precondition constraint Xi T S false Finally time lbT resp ubT modiﬁed D Xi updated outside ubS resp inside lbS If propagation mechanism solver provides values added lbT removed ubT propagator 2n constraints described 30 updating given D Xi total complexity O d time d possible changes T The proof BC enforced linear time follows similar argument cid2 6 A catalog decompositions Range Roots We shown propagate Range Roots constraints Speciﬁcation counting occurrence constraints Range Roots executable Range Roots permit decompose counting occurrence global constraints primitive constraints having associated polynomial propagation algorithm In cases decomposition hinder propagation In cases enforcing local consistency global constraint intractable decomposition method obtain polynomial propagation algorithm 111312 In technical report 9 present catalog containing 70 global constraints 2 speciﬁed help Range Roots constraints Here present important constraints In subsequent ﬁve subsections list counting occurrence constraints speciﬁed Range constraints Roots constraints Range Roots constraints We Range Roots specify open global constraints new kind global constraints introduced recently We ﬁnally include problem domains counting occurrence illustrate wide range global constraints expressible terms Range Roots 1064 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 61 Applications Range constraint Range constraints useful specify constraints values sequence variables 611 All different The AllDifferent constraint forces sequence variables different values Such constraint useful wide range problems allocation activities different slots timetabling problem It propagated eﬃciently 22 It decomposed single Range constraint cid3 X1 Xn AllDifferent iff cid4 cid3 X1 Xn 1 n T Range cid4 T n A special important case constraint Permutation constraint This AllDifferent constraint additionally know R set values taken That sequence variables permutation values R R n This decomposed single Range constraint cid3 X1 Xn R Permutation cid3 X1 Xn 1 n R Range cid4 iff cid4 Such decomposition Permutation constraint obviously hinder propagation However decomposition AllDifferent Range constraint This example illustrates whilst global constraints expressed terms Range Roots global constraints like AllDifferent worth developing specialised propagation algorithms Nevertheless Range Roots provide means propagation constraints absence specialised algorithms They enhance existing propagators For instance HC Range decomposition incomparable AC decomposition AllDifferent uses clique binary inequality constraints Thus able obtain pruning decompositions Theorem 8 1 GAC Permutation equivalent HC decomposition Range 2 GAC AllDifferent stronger HC decomposition Range 3 AC decomposition AllDifferent binary inequalities incomparable HC decomposition Range Proof 1 Permutation encoded single Range Moreover R ﬁxed HC equivalent AC 2 Consider X1 X2 1 2 X3 1 2 3 4 1 2 T 1 2 3 4 Then Range X1 X2 X3 1 2 3 T T 3 HC AllDifferent X1 X2 X3 GAC 3 Consider X1 X2 1 2 X3 1 2 3 T 1 2 3 Then X1 cid11 X2 X1 cid11 X3 X2 cid11 X3 AC Range X1 X2 X3 1 2 3 T HC Consider X1 X2 1 2 3 4 X3 2 2 T 1 2 3 4 Then Range X1 X2 X3 1 2 3 T T 3 HC But X1 cid11 X3 X2 cid11 X3 AC cid2 612 Disjoint We require sequences variables disjoint value common For instance sequences tasks sharing resource required disjoint time The Disjoint X1 Xn Y 1 Ym constraint introduced 2 ensures Xi cid11 Y j j We prove expect enforce GAC constraint NPhard general Theorem 9 Enforcing GAC Disjoint NPhard Proof We reduce 3SAT problem deciding Disjoint constraint satisfying assignment Finding support NPhard Consider formula ϕ n variables m clauses For Boolean variable x let Xx x x Y j x y z jth clause ϕ x y z If ϕ model Disjoint constraint satisfying assignment Xx literals false model cid2 One way propagate Disjoint constraint decompose Range constraints cid4 cid3 X1 Xn Y 1 Ym Disjoint cid4 cid3 X1 Xn 1 n S Range cid4 cid3 Y 1 Ym 1 m T Range iff S T Enforcing HC decomposition polynomial Decomposition offers simple promising method propagate Disjoint constraint Not surprisingly decomposition hinders propagation polynomial algorithm NPhard problem C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1065 Theorem 10 GAC Disjoint stronger HC decomposition Proof Consider X1 Y 1 1 2 X2 Y 2 1 3 Y 3 2 3 S T 1 2 3 Then Range X1 X2 1 2 S RangeY 1 Y 2 Y 3 1 2 3 T HC S T BC However enforcing GAC Disjoint X1 X2 Y 1 Y 2 Y 3 prunes 3 X2 1 Y 1 Y 2 cid2 613 Number values The NValue constraint useful wide range problems involving resources counts number distinct values sequence variables 1987 As saw Section 3 NValue X1 Xn N holds iff N Xi 1 cid2 cid2 n The AllDifferent constraint special case NValue constraint N n Unfortunately NPhard general enforce GAC NValue constraint 11 However O n logn algorithm enforce level consistency similar BC 3 An alternative simpler way implement constraint Range constraint cid3 X1 Xn N NValue cid3 X1 Xn 1 n T Range iff cid4 cid4 T N HC decomposition incomparable BC NValue constraint Theorem 11 BC NValue incomparable HC decomposition Proof Consider X1 X2 1 2 X3 1 2 3 4 N 3 T 1 2 3 4 Then Range X1 X2 X3 1 2 3 T T N HC However enforcing BC NValue X1 X2 X3 N prunes 1 2 X3 Consider X1 X2 X3 1 3 N 3 Then NValue X1 X2 X3 N BC However enforcing HC Range X1 X2 X3 1 2 3 T makes T 1 3 cause T 3 fail cid2 614 Uses In 5 propagation algorithms achieving GAC BC proposed UsedBy constraint UsedBy X1 Xn Y 1 Ym holds iff multiset values assigned Y 1 Ym subset multiset values assigned X1 Xn We introduce variant UsedBy constraint called Uses constraint Uses X1 Xn Y 1 Ym holds iff set values assigned Y 1 Ym subset set values assigned X1 Xn That UsedBy takes account number times value Uses Unlike UsedBy constraint enforcing GAC Uses NPhard Theorem 12 Enforcing GAC Uses NPhard Proof We reduce 3SAT problem deciding Uses constraint solution Finding support NP hard Consider formula ϕ n Boolean variables m clauses For Boolean variable x introduce variable Xx x x For clause c j x y z introduce Y j x y z Then ϕ model iff Uses constraint satisfying assignment x true iff Xx x cid2 One way propagate Uses constraint decompose Range constraints cid4 Uses cid3 X1 Xn Y 1 Ym cid3 X1 Xn 1 n T Range cid3 Y 1 Ym 1 m T Range cid4 cid9 iff cid4 T cid9 T Enforcing HC decomposition polynomial Not surprisingly hinders propagation polynomial algorithm NPhard problem Theorem 13 GAC Uses stronger HC decomposition Proof Consider X1 1 2 3 4 X2 1 2 3 5 X3 X4 4 5 6 Y 1 1 2 Y 2 1 3 Y 3 2 3 The decomposi tion HC GAC Uses prunes 4 domain X1 5 domain X2 cid2 Thus decomposition simple method obtain polynomial propagation algorithm 62 Applications Roots constraint Range constraints useful specify constraints values sequence variables Roots constraint hand useful specify constraints variables taking particular values 1066 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 621 Global cardinality The global cardinality constraint introduced 23 constrains number times values We consider generalisation number occurrences value integer variable More precisely Gcc X1 Xn d1 dm O 1 O m holds iff Xi d j O j j Such Gcc constraint decomposed set Roots constraints cid3 X1 Xn d1 dm O 1 O m Gcc cid3 X1 Xn S di Roots iff S O cid4 cid4 Enforcing HC Roots constraints polynomial sets di ground Theorem 5 Enforcing GAC generalised Gcc constraint NPhard enforce GAC Xi BC O j polynomial time specialised algorithm 21 This achieved decomposition Theorem 14 GAC Xi BC O j Gcc constraint stronger HC decomposition Roots constraints Proof As sets represented bounds HC decomposition prune O j BC Gcc To strictness consider X1 X2 1 2 X3 1 2 3 di O 1 O 2 O 3 0 1 The decomposition HC S1 S2 1 2 3 S3 3 However enforcing GAC Xi BC O j Gcc constraint prune 1 2 X3 0 O 1 O 2 O 3 cid2 This illustrates global constraint worth developing specialised propagation algorithm 622 Among The Among constraint introduced CHIP help model resource allocation problems like car sequencing 4 It counts number variables values given set Among X1 Xn d1 dm N holds iff N Xi d1 dm An alternative way propagate Among constraint decompose Roots constraint cid3 X1 Xn d1 dm N Among cid4 cid3 X1 Xn S d1 dm Roots cid4 iff S N It polynomial enforce HC case Roots constraint target set ground This decomposition hinder propagation It potentially attractive method implement Among constraint Theorem 15 GAC Among equivalent HC decomposition Roots Proof Suppose decomposition Roots X1 Xn S d1 dm S N HC The variables Xi divide categories domain contains elements d1 dm minN variables domain contain elements n maxN vars domain contains elements set outside Consider value variable Xi ﬁrst category To construct support value assign remaining variables ﬁrst category values d1 dm If total number assigned values minN assign suﬃcient number variables second category values d1 dm bring count minN We assign remaining unassigned X j values outside d1 dm Finally assign minN N Support constructed variables categories similar way value N minN maxN cid2 623 At The AtMost AtLeast constraints closely related The AtMost constraint puts upper bound number variables particular value whilst AtLeast puts lower bound For instance AtMost X1 Xn d N holds iff Xi d cid2 N Both AtMost AtLeast decomposed Roots constraints For example cid3 X1 Xn d N AtMost cid4 cid3 X1 Xn S d Roots cid4 iff S cid2 N Again polynomial enforce HC cases Roots constraint decomposition hinder prop agation Decomposition potential method implement AtMost AtLeast constraints case constraints available constraint toolkit Theorem 16 GAC AtMost equivalent HC decomposition Roots X1 Xn S d S cid2 N GAC AtLeast equivalent HC decomposition Roots X1 Xn S d S cid3 N Proof The proof theorem easily adapted constraints cid2 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1067 63 Applications Range Roots constraints Some global constraints need Range Roots constraints speciﬁcations 631 Assign number values In bin packing knapsack problems wish assign value bin item place constraints values appearing bin For instance steel slab design problem prob038 CSPLib assign colours slabs orders limited number colours slab AssignNValues X1 Xn Y 1 Yn N holds iff Y Xi j cid2 N j 2 We expect enforce GAC constraint NPhard general Theorem 17 Enforcing GAC AssignNValues NPhard Proof Deciding constraint AtMostNValue solution NPcomplete AtMostNValueY 1 Yn N holds iff Y 1 cid2 cid2 n cid2 N 87 The problem existence solution constraint equivalent problem existence solution AssignNValues X1 Xn Y 1 Yn N D Xi 0 1n Deciding AssignNValues NPcomplete enforcing GAC NPhard cid2 AssignNValues decomposed set Range Roots constraints cid3 X1 Xn Y 1 Yn N AssignNValues cid4 cid3 X1 Xn S j j j Roots cid4 iff cid3 Y 1 Yn S j T j Range cid4 T j cid2 N However decomposition hinders propagation Theorem 18 GAC AssignNValues stronger HC decomposition Proof Consider N 1 X1 X2 0 Y 1 1 2 Y 2 2 3 HC decomposition enforces S0 1 2 T 0 1 2 3 pruning Xi Y j However enforcing GAC AssignNValues X1 X2 Y 1 Y 2 N prunes 1 Y 1 3 Y 2 cid2 632 Common A generalisation Among AllDifferent constraints introduced 2 Common constraint CommonN M X1 Xn Y 1 Ym ensures N j Xi Y j M j Xi Y j That N variables Xi values common Y j M variables Y j takes values common Xi We prove expect enforce GAC constraint NPhard general Theorem 19 Enforcing GAC Common NPhard Proof We use transformation 3SAT Consider formula ϕ n Boolean variables m clauses For Boolean variable introduce variable Xi For clause c j x y z introduce Y j x y z We let N 0 n M m ϕ model iff Common constraint solution Xi literals true model cid2 One way propagate Common constraint decompose Range Roots constraints cid4 iff cid3 Common N M X1 Xn Y 1 Ym cid4 cid3 Y 1 Ym 1 m T Range cid3 X1 Xn S T Roots cid3 X1 Xn 1 n V Range cid3 Y 1 Ym U V Roots cid4 cid4 S N cid4 U M Enforcing HC decomposition polynomial Decomposition offers simple method propagate Common constraint Not surprisingly decomposition hinders propagation Theorem 20 GAC Common stronger HC decomposition Proof Consider N M 0 X1 Y 1 1 2 X2 Y 2 1 3 Y 3 2 3 Hybrid consistency decomposition enforces T V 1 2 3 S U pruning Xi Y j However enforcing GAC CommonN M X1 X2 Y 1 Y 2 Y 3 prunes 2 X1 3 X2 1 Y 1 Y 2 cid2 1068 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 633 Symmetric different In certain domains need ﬁnd symmetric solutions For example sports scheduling problems team assigned play second team assigned play ﬁrst SymAllDiff X1 Xn ensures Xi j iff X j 24 It decomposed set Range Roots constraints cid3 X1 Xn cid4 SymAllDiff cid3 X1 Xn 1 n 1 n Range cid3 Roots X1 Xn S iff cid4 cid4 Xi S S 1 It polynomial enforce HC cases Roots constraint However AllDifferent constraint effective use specialised propagation algorithm like 24 Theorem 21 GAC SymAllDiff stronger HC decomposition Proof Consider X1 2 3 X2 1 3 X3 1 2 S1 2 3 S2 1 3 S3 1 2 Then decom position HC However enforcing GAC SymAllDiff X1 X2 X3 detect unsatisﬁability cid2 To knowledge constraint integrated constraint solver Thus decomposition provides means propagation SymAllDiff constraint 634 Uses In Section 614 decomposed constraint Uses Range constraints Another way propagate Uses constraint decompose Range Roots constraints cid4 Uses cid3 X1 Xn Y 1 Ym cid3 X1 Xn 1 n T Range cid3 Y 1 Ym 1 m T Roots cid4 cid4 iff Enforcing HC decomposition polynomial Again decomposition hinders propagation achieving GAC Uses constraint NPHard Interestingly decomposition Uses Range constraints presented Section 614 decomposition presented equivalent Theorem 22 HC decomposition Uses Range constraints equivalent HC decomposition Range Roots constraints Proof We need HC RootsY 1 Ym 1 m T equivalent HC RangeY 1 Ym 1 m cid9 T Since Range Roots constraints set variables Y 1 Ym set cid9 T T indices 1 m ﬁxed follows set variable T maintained Range subset T maintained Roots cid2 cid9 64 Open constraints Open global constraints recently introduced They new kind global constraints set variables involved ﬁxed Range Roots constraints particularly useful specify open global constraints The Gcc constraint extended OpenGcc Gcc constraint set variables involved known advance 31 Given variables X1 Xn set variable S S 1n OpenGcc X1 Xn S d1 dm O 1 O m holds iff S Xi d j O j j OpenGcc decomposed set Roots constraints way Gcc decomposed Section 621 S cid3 X1 Xn S d1 dm O 1 O m OpenGcc cid9 S i1m cid3 X1 Xn S di Roots S O cid4 cid4 iff Propagators open constraint included constraint solvers In 31 propagator proposed case O s ground intervals In decomposition O s variables ground intervals However O s ground intervals decomposition propagator presented 31 hinder propagation incomparable C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1069 Theorem 23 Even O s ground intervals 1 HC OpenGcc constraint stronger HC decomposition Roots constraints 2 propagator 31 HC decomposition Roots constraints incomparable Proof 1 Consider X1 X2 1 2 X3 1 2 3 di S 1 2 3 O 1 O 2 O 3 0 1 The decomposition HC S1 S2 1 2 3 S3 3 However enforcing HC OpenGcc constraint prune 1 2 X3 2 Consider example case 1 The propagator 31 prune 1 2 X3 decomposition HC Consider X1 1 2 X2 2 3 X3 3 4 di S 1 2 3 O 1 1 1 O 2 0 1 O 3 0 0 O 4 0 0 The propagator 31 prune value Xi variables HC value 2 X1 It prune bounds S However enforcing HC decomposition Roots constraints set S 1 1 prune value 2 X1 shrink S2 S2 2 set S3 S4 ﬁnally shrink S 1 S 1 2 cid2 As observed 31 deﬁnition OpenGcc subsumes deﬁnition open version AllDifferent constraint Given variables X1 Xn set variable S S 1n OpenAllDifferent X1 Xn S holds iff Xi cid11 X j j S Interestingly constraint decomposed Range way AllDifferent decomposed Section 611 cid3 X1 Xn S OpenAllDifferent cid4 iff cid3 X1 Xn S T Range cid4 S T Not surprisingly decomposition hinders propagation example Theorem 8 decom position AllDifferent Range hinders propagation Nevertheless case OpenGcc know polynomial algorithm achieving HC OpenAllDifferent 65 Applications counting occurrence constraints The Range Roots constraints useful specifying wide range counting occurrence constraints Never theless expressive power permits use specify constraints 651 Element The Element constraint introduced 28 indexes array variable More precisely ElementI X1 Xn J holds iff X I J For example use constraint look price component included conﬁguration problem The Element constraint decomposed Range constraint hindering propagation cid3 Element I X1 Xn J iff cid3 X1 Xn S T I S J T Range S T 1 cid4 cid4 Theorem 24 GAC Element equivalent HC decomposition Proof S values domain I upper bound Similarly T values domain J upper bound In addition S T forced single value Thus enforcing HC Range X1 Xn S T effect enforcing GAC ElementI X1 Xn J cid2 652 Global contiguity The Contiguity constraint ensures sequence 01 variables taking value 1 appear contiguously This discrete form convexity The constraint introduced 18 model hardware conﬁguration problem It decomposed Roots constraint cid3 X1 Xn Contiguity cid3 X1 Xn S 1 Roots iff cid4 cid4 X maxS Y minS S X Y 1 Again polynomial enforce HC case Roots constraint Unfortunately decomposition hinders propagation Whilst Range Roots specify concepts distant counting occurrences like convexity need algorithmic ideas propagate effectively Theorem 25 GAC Contiguity stronger HC decomposition Proof Consider X1 X3 0 1 X2 X4 1 Hybrid consistency decomposition enforce 2 4 S 1 2 3 4 X 4 Y 1 2 S 3 4 pruning happen However enforcing GAC Contiguity X1 Xn prune 0 X3 cid2 1070 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 7 Experimental results We experimentally assess value Range Roots constraints specifying global counting occurrence constraints For experiments performed Ilog Solver toolkit 16 implemented algo rithm achieving HC Range algorithm achieving HC decomposition Roots presented Section 52 Note algorithm decomposition Roots use Ilog Solver primitives membervalue set notmembervalue set Ilog Solver appear complete propagation combinations primi tives discussion Section 55 We implemented algorithms scratch 71 Pruning power Roots In Section 52 proposed decomposition Roots constraint simple implications The purpose sub section measure pruning power HC decomposition Roots respect HC original Roots constraint meet conditions HC decomposition equivalent HC original constraint Section 53 We bear mind enforcing HC Roots constraint NPhard general In order enforce HC Roots constraint simple table constraint constraint extension exponential time space complexity Consequently size instances able run ﬁltering method severely constrained An instance set integer variables X1 Xn set variables S T It described tuple cid19n m k rcid20 The parameter n stands number integer variables These n variables initialised domain 1 m The upper bound S initialised 1 n upper bound T initialised 1 m The parameter k corresponds number elements set variable S resp set variable T equal probability lower bound excluded upper bound S resp T Finally parameter r total number values removed uniform probabilities domains integer variables keeping value domain We generated 1000 random instances combination n m 4 6 k 1 minn m r 1nm 1 For instances generated propagated Roots X1 Xn S T table constraint enforcing HC decomposition enforcing HC special cases We observed 29 32 combinations parameters n m k decomposition achieves HC 1000 instances value r On remaining classes cid194 6 3 cid20 cid195 6 3 cid20 cid196 6 3 cid20 decomposition fails detect 0003 inconsistent values As second experiment instances expect ﬁx remove k values randomly T instances lbT ubT 1 m All settings remained equal By allowed random domains reach situations equivalent counter example given proof Theorem 4 With setting observed decomposition achieves HC 18 32 combinations parameters n m k 1000 instances value r On remaining classes percentage inconsistent values pruned decomposition increases 0039 Clearly experiment limited scope ﬁrst relatively small size instances second choices generating random domains However conclude examples inconsistent values detected decomposition appear rare 72 Pruning power eﬃciency Range Contrary Roots constraint complete HC propagator Range constraint Thus need assess pruning power propagator Nevertheless interesting compare pruning power eﬃciency decomposing global constraint Range decomposition simpler constraints The purpose subsection compare decomposition Uses Range constraints simple composition elementary constraints We chose Uses constraint NPhard achieve GAC Uses constraint Section 614 propagator available constraint literature Furthermore timetabling problems University Montpellier easily modelled CSP Uses constraints We ﬁrst compare decompositions Uses Range terms runtime pruning power random CSPs Then solve problem building set courses Master Computer Science University Montpellier decompositions 721 Random CSPs In order isolate effect Range constraint modelling issues following protocol randomly generated instances binary CSPs added Uses X1 Xn Y 1 Yn constraints In experiments encode Uses different ways range decomposing Uses Range described Section 614 decomp decomposing Uses constraint primitive constraints described Uses cid3 X1 Xn Y 1 Yn cid4 iff C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1071 S Xi T j T S Xi j cid9 j T S cid9 S cid9 Y j cid9 Y T cid9 T T The problem instances generated according model B 20 described following parameters number X Y variables nx ny Uses constraints total number variables nz domain size d number binary constraint m1 number forbidden tuples t binary constraint number Uses constraints m2 Note Uses constraints overlapping disjoint scopes variables We distinguish cases All reported results averages 1000 instances Our ﬁrst experiment studies effectiveness decomposing Uses Range propagation solving We compared number values removed propagation models obtained representing Uses constraints different ways Range range simple decomposition decomp To simulate happens inside backtrack search repeatedly randomly choose variable assign values propagate set random binary constraints After given number variables CSP consistent enforce HC decompositions Hence experiments constraints exposed wide range different variable domains We report ratio values removed propagation following classes problems class A class B cid19nx 5 ny 10 nz 35 d 20 m1 70 t 150 m2 3 overlapcid20 cid19nx 5 ny 10 nz 45 d 20 m1 90 t 150 m2 3 disjointcid20 number assigned variables varies 1 14 A failure detected propagation algorithm yields ratio 1 values removed We observe Figs 4 5 propagating Uses constraint Range constraint range model effective propagating decomposition elementary constraints decomp model In certain cases range model doubles values pruned For instance 7 random assignments decomp model prunes 288 values ﬁrst problem class Fig 4 44 second Fig 5 whilst Range algorithm respectively prunes 56 102 values As experiments difference pruning map considerable savings solving problem Our second experiment studies eﬃciency decomposing Uses Range solving problems Our solver smallestdomainﬁrst variable ordering heuristic lexicographical value ordering cutoff 600 sec onds We compared cost solving types models range decomp We report number fails cputime needed ﬁnd ﬁrst solution following classes problems class C class D cid19nx 5 ny 10 nz 25 d 10 m1 40 t m2 2cid20 cid19nx 5 ny 10 nz 30 d 10 m1 60 t m2 2cid20 t varies 30 80 We observe Figs 6 7 decomposition elementary constraints decomp model eﬃcient note log scale The instances solved classes C D smaller propaga tion classes A B Solving larger instances impractical This second experiment shows Range reasonably Fig 4 Propagating random binary constraint satisfaction problems overlapping Uses constraints class A 1072 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 Fig 5 Propagating random binary constraint satisfaction problems disjoint Uses constraints class B solve problems containing Uses constraints It shows clear beneﬁt algorithm preference decomposition elementary constraints underconstrained region As problems overconstrained binary constraints dominate pruning algorithm slight overhead runtime pruning decomposition elementary constraints 722 Problem courses master science To conﬁrm results obtained types random instances tackle problem deciding courses run Master Computer Science University Montpellier This problem usually solved hand help Excel program speciﬁed follows The second year Master Computer Science advertises set C possible courses There set L n lecturers skills teach subset courses 1 9 lecturer There set S m students bid courses like attend 6 10 bids student A course runs 5 students bid Every lecturer participates course lecturers assigned course There set P L professors charge course participate The goal run courses lecturers assigned course students attend courses bid The models variables Li representing course taught lecturer variables S j representing courses student j wants attend DLi contains courses lecturer teach received 5 bids DS j contains courses student j bid received 5 bids We constraint UsesL1 Ln S1 Sm constraint AllDifferentLi1 Li p Li1 Li p P Model range decomposes Uses Range model decomp decomposes Uses primitive constraints described Section 721 In instance obtain university year2008 50 lecturers 26 professors 53 courses 177 students We solved year2008 model decomp model range Both models ﬁnd solution milliseconds We modiﬁed models satisfaction students improved Instead trying satisfy choices try satisfy k choices The models modiﬁed following way We create k copies variable S j S 1 j containing values DS j We j Sk post constraints S 1 j different values Then instead having single Uses constraint k Uses constraints set S 2 S m vari ables UsesL1 Ln S 1 Model rangek decomposes Uses Range UsesL1 Ln Sk model decompk decomposes Uses primitive constraints described Section 721 j break symmetries guarantee S 1 j Sk j DS 1 S 1 1 Sk j Sk j S 2 j S 2 j S 2 1 S We solved instance year2008 k 2 3 4 5 When k 2 k 3 models ﬁnd solution milliseconds decompk slightly faster rangek range4 ﬁnds solution 4 fails 583 sec decomp4 stopped 24 hours ﬁnding solution range5 decomp5 stopped 24 hours ﬁnding solution proving exists This experiment shows effective solve realworld problem containing global constraint like Uses specifying Range instead decomposition elementary constraints m m 73 Solving problems Range Roots In Section 722 showed decomposing global constraint Range useful solve realworld prob lem In subsection study realworld problem involves greater variety global constraints C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1073 Fig 6 Solving random binary constraint satisfaction problems overlapping Uses constraints class C allowing decompositions Range Roots More importantly compare monolithic propagators existing wellknown global constraints decompositions Range Roots The purpose subsection solving realworld constraint problems Range Roots leads acceptable performance compared specialised global constraints propagators We model Mystery Shopper problem 14 Helmut Simonis appears CSPLib prob004 We problem instances 10 perform thorough extensive analysis We partition constraints problem groups Temporal geographical All visits week different shoppers Similarly particular area visited shopper Shopper Each shopper makes exactly required number visits Saleslady A saleslady visited shoppers 2 different groups shoppers partitioned groups The ﬁrst group constraints modelled AllDifferent constraints 22 second modelled Gcc 23 Among constraints 4 We experimented models Ilog Solver constraints implemented Ilog Solver primitives respectively IloAllDiff IloDistribute decomposition IloSum Boolean variables decompositions Range Roots The decomposition Among X1 Xn d1 dm N use presented 6 B 1 Xi d1 dm 1n cid10 B N Note decomposition Among constraint maintains GAC theory 6 This decomposition implemented solvers disjunctions membership constraints ornotmember Xi d1 dm B 1 ormember Xi d1 dm B 0 Unfortunately Ilog Solver appear achieve GAC disjunctions primitives negated membership constraint notmember Xi d1 dm activated Xi instantiated value d1 dm soon D Xi d1 dm 1074 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 Fig 7 Solving random binary constraint satisfaction problems disjoint Uses constraints class D We report results following representative models AlldGccSum uses Ilog Solver primitives AlldGccRoots Among encoded Roots AlldRootsSum Gcc encoded Roots RangeGccSum AllDifferent encoded Range AlldRootsRoots Among Gcc encoded Roots Note Among encoded Roots uses decomposition presented Section 622 Gcc uses decomposition presented Section 621 AllDifferent uses decomposition presented Section 611 We study following important questions How Roots decomposition Among constraint compare Sum decomposition terms pruning runtimes Does decomposition Gcc Roots lead reasonable acceptable loss performance Does decomposition AllDifferent Range lead reasonable acceptable loss performance Do gain performance branching set variables introduced Roots decomposition To answer ﬁrst question compare model AlldGccSum model AlldGccRoots To answer second question compare model AlldGccSum model AlldRootsSum To answer question compare model AlldGccSum model RangeGccSum To answer fourth question compare AlldGccSum model AlldRootsRoots branches set variables The instances use experiments generated follows For number salesladies s 10 15 20 25 30 35 generate cid21s 24 4cid22 shoppers 4 visits Furthermore determine partitioning outlets bound number salesladies outlet lower bound upper bound generate possible partitions C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1075 Table 1 The sum decomposition Among Mystery Shopper problem versus Roots decomposition lex branching strategy Size alldgccsumlex solved time sec 10 15 20 25 30 35 9 29 25 16 6 31 self 001 007 002 003 005 023 001 007 002 003 005 023 fails self 089 43155 1060 706 5000 41468 089 43155 1060 706 5000 41468 alldgccrootslex solved time sec self 9 29 25 16 6 31 001 007 002 004 007 024 001 007 002 004 007 024 Table 2 The Gcc constraints Mystery Shopper problem versus Roots decomposition lex branching strategy Size alldgccsumlex solved time sec 10 15 20 25 30 35 9 29 25 16 6 31 self 001 007 002 003 005 023 001 007 002 003 005 027 fails self 089 43155 1060 706 5000 41468 089 43155 1060 706 5000 50548 alldgccrootslex solved time sec self 9 29 25 16 6 23 001 043 010 023 043 389 001 043 010 023 043 389 fails self 089 28190 948 700 4967 26932 fails self 178 43438 1060 3831 7233 52174 089 28190 948 700 4967 26932 178 43438 1060 3831 7233 52174 bounds The number instances class follows 10 salesladies 10 instances 15 salesladies 52 instances 20 salesladies 35 instances 25 salesladies 20 instances 30 salesladies 10 instances 35 salesladies 56 instances We tested variable value ordering heuristics We branch variables minimum domain ﬁrst assign values lexicographically We refer dom We assign shopper saleslady ﬁrst second week This static variables value ordering heuristic We refer lex However lex consistently better dom report results lex All instances solved experiments use time limit 5 minutes For class instances report number instances solved solved average cputime seconds instances solved method self average cputime seconds instances solved methods average number failures instances solved method self average number failures instances solved methods 731 Among When branching integer variables lex Table 1 strategy AlldGccRoots model tends perform better AlldGccSum model terms pruning smaller number fails Note Sum decomposition misses pruning Ilog Solver propagators decomposition explained beginning Section 73 This explains discrepancy Both models solve number instances The results case Among constraint Roots decomposition eﬃcient decomposition elementary Sum constraints Minor runtime differences probably cheaper propagator Ilog Solver achieves pruning 732 Gcc The Gcc constraint eﬃcient effective global constraints available constraint toolkits The results comparing AlldGccSum model versus equivalent AlldRootsSum model instead Gcc constraints use decomposition Roots shown Table 2 We observe branching integer variables lex loss terms pruning decomposition low difference number fails 5 hardest instances This means decomposition scale size diﬃculty problems increases The difference runtimes larger order magnitude This explained propagation algorithms Range Roots implemented Ilog Solver They far optimised opposed highly specialised native Gcc propagator Overall loss appears acceptable Our results Gcc constraint decomposition Roots leads adequate performance prototyping Nevertheless providing eﬃcient propagators Roots interesting open issue 1076 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 Table 3 The AllDifferent constraints Mystery Shopper problem versus Range decomposition lex branching strategy Size alldgccsumlex solved time sec 10 15 20 25 30 35 9 29 25 16 6 31 self 001 007 002 003 005 023 001 007 002 003 005 023 fails self 089 43155 1060 706 5000 41468 089 43155 1060 706 5000 41468 alldgccrootslex solved time sec self 9 29 25 16 6 31 002 018 017 032 057 139 002 018 017 032 057 139 Table 4 Branching set variables Mystery Shoppers problem Size alldgccsumlex solved time sec self 001 007 002 003 005 023 001 007 002 003 005 023 10 15 20 25 30 35 9 29 25 16 6 31 733 Alldifferent fails self 089 43155 1060 706 5000 41468 alldgccrootslex solved time sec 089 43155 1060 706 5000 41224 10 52 35 20 10 51 self 005 012 130 508 1505 3388 005 005 125 512 365 3586 fails self 089 43155 1060 706 5000 41468 fails self 9820 10283 85214 221800 447640 611167 089 43155 1060 706 5000 41468 9133 2334 79420 217012 167533 641014 The AllDifferent constraint eﬃcient effective global constraints available constraint toolkits The results comparing AlldGccSum model versus equivalent RangeGccSum model instead AllDifferent constraints use decomposition Range shown Table 3 We observe branching integer variables lex methods achieve pruning case AllDifferent constraints Permutation constraints Section 611 This means decomposition Range theoretically hinders propagation practice achieve GAC Concerning runtime eﬃciency observe methods solve number instances This probably consequence good level pruning achieved decomposition AllDifferent Range But AlldGccSum model usually faster order magnitude extreme case Again explained basic implementation Range Roots propagators Ilog Solver opposed highly specialised native AllDifferent propagator 734 Exploiting set variables In previous subsections seen decomposing global constraints Range Roots constraints viable approach Such decompositions generally small loss terms pruning acceptable runtime performance However seen basic decomposition Roots slow compared highly specialised propagators Ilog Solver Gcc constraint In subsection optimising code improve runtime performance decomposition exploiting internal structure extra variables introduces The decomposition global constraints Range Roots introduces extra set variables We explore possibility branching set variables follows We branch set variables ﬁrst integer variables min domain set variables instantiated We refer set We compare best model uses available constraints Ilog Solver model AlldGccSum versus best model branches set variables model AlldRootsRoots Among Gcc constraints expressed Roots constraint Surprisingly solve signiﬁcantly instances branching set variables model AlldGccSum But AlldGccSum eﬃcient model manages solve instance These results primarily better branching strategy However strategy easily imple mentable Roots extra set variables We observe extra set variables introduced Roots decomposition provide new possibilities branching strategies beneﬁcial practice These results simply changing branching strategy exploits internal structure decompositions obtain signiﬁcant increase performance This gain compensates loss cputime caused preliminary nature implementation 8 Conclusion We proposed global constraints useful specifying counting occurrence constraints Range constraint computes range values set variables Roots constraint computes C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 1077 variables set mapping particular values These constraints capture notion image domain function making easy understand nonexpert constraint programming We shown constraints easily specify counting occurrence constraints For example open versions wellknown global constraints speciﬁed Range Roots Beyond counting occurrence constraints shown expressive power Range Roots allows specify constraints We proposed propagation algorithms constraints Hence global constraint speciﬁed Range Roots propagated In cases gives propagation algorithm achieves GAC original global constraint Permutation Among constraints In cases propagation algorithm original constraint GAC achieving GAC NPhard NValue Common constraints Decomposition method obtain polynomial algorithm In remaining cases propagation algorithm constraint GAC specialised propagation algorithms polynomial time SymAllDiff constraint Our method attractive case provides generic means propagation counting occurrence constraints specialised algorithms proposed available constraint toolkit We presented comprehensive study Range constraint We proposed algorithm enforcing hybrid sistency Range We presented comprehensive study Roots constraint We proved propagating completely Roots constraint intractable general We proposed decomposition propagate partially This decomposition achieves hybrid consistency Roots constraint simple conditions met prac tice In addition enforcing bound consistency decomposition achieves bound consistency Roots constraint conditions hold Our experiments beneﬁt obtain incorporating Range Roots constraints constraint toolkit First despite intractable Roots constraint propagated decomposition presented Even decomposition hinders propagation theory experiments seldom case practice Second absence specialised propagation algorithms Range Roots appear simple reasonable method propagating possibly intractable global constraints competitive decompositions elementary constraints Our experiments better decompositions terms pruning solution time like case decomposition Uses constraint In addition compared highly specialised propagation algorithms like AllDifferent Gcc constraints Ilog Solver loss performance Range Roots great Thus constraint toolkit lacks specialised propagation algorithm Range Roots offer quick easy acceptable way propagation Finally observed extra set variables introduced Range Roots decompositions exploited design new branching strategies These extra set variables provide modelling solving advantage user We hope presenting results developers different constraint toolkits encouraged include Range Roots constraints solvers Acknowledgements We thank Eric Bourreau having provided data problem master science university Montpellier We thank reviewers helpful comments improved paper References 1 RK Ahuja TL Magnanti JB Orlin Network Flows Prentice Hall Upper Saddle River NJ 1993 2 N Beldiceanu Global constraints graph properties structured network elementary constraints type Technical report Swedish Institute Computer Science 2000 SICS Technical Report T200001 3 N Beldiceanu Pruning minimum constraint family number distinct values constraint family T Walsh Ed CP Lecture Notes Computer Science vol 2239 Springer 2001 pp 211224 4 N Beldiceanu E Contejean Introducing global constraints CHIP Math Comput Modelling 20 12 1994 97123 5 N Beldiceanu I Katriel S Thiel Filtering algorithms usedby constraints MPI Technical Report MPII20041001 2004 6 C Bessiere E Hebrard B Hnich Z Kiziltan T Walsh Among common disjoint constraints B Hnich M Carlsson F Fages F Rossi Eds CSCLP Lecture Notes Computer Science vol 3978 Springer 2005 pp 2943 7 C Bessiere E Hebrard B Hnich Z Kiziltan T Walsh Filtering algorithms NVALUE constraint Constraints 11 4 2006 271293 8 C Bessiere E Hebrard B Hnich Z Kiziltan T Walsh Filtering algorithms NVALUE constraint R Bartak M Milano Eds CPAIOR Lecture Notes Computer Science vol 3524 Springer 2005 pp 7993 9 C Bessiere E Hebrard B Hnich Z Kiziltan T Walsh The RANGE ROOTS constraints applications Technical report COMIC2006003 2006 10 C Bessiere E Hebrard B Hnich Z Kiziltan T Walsh The RANGE ROOTS constraints Specifying counting occurrence problems LP Kaelbling A Saﬃotti Eds IJCAI Professional Book Center 2005 pp 6065 11 C Bessiere E Hebrard B Hnich T Walsh The complexity global constraints DL McGuinness G Ferguson Eds AAAI AAAI PressThe MIT Press 2004 pp 112117 12 C Bessiere E Hebrard B Hnich T Walsh The complexity reasoning global constraints Constraints 12 2 2007 239259 13 C Bessiere E Hebrard B Hnich T Walsh The tractability global constraints M Wallace Ed CP Lecture Notes Computer Science vol 3258 Springer 2004 pp 716720 14 BMW Cheng KMF Choi JHM Lee JCK Wu Increasing constraint propagation redundant modeling An experience report Constraints 4 2 1999 167192 15 R Debruyne C Bessiere Some practicable ﬁltering techniques constraint satisfaction problem IJCAI 1997 pp 412417 16 ILOG Reference User Manual ILOG Solver 53 ILOG SA 2002 17 F Laburthe Choco implementing CP kernel Proceedings TRICS Techniques foR Implementing Constraint programming Systems post conference workshop CP Singapore 2000 1078 C Bessiere et al Artiﬁcial Intelligence 173 2009 10541078 18 M Maher Analysis global contiguity constraint Proceedings Workshop Rule Based Constraint Reasoning Programming held alongside CP Ithaca NY 2002 19 F Pachet P Roy Automatic generation music programs J Jaffar Ed CP Lecture Notes Computer Science vol 1713 Springer 1999 pp 331345 20 P Prosser An empirical study phase transitions binary constraint satisfaction problems Artif Intell 81 12 1996 81109 21 CG Quimper A LópezOrtiz P van Beek A Golynski Improved algorithms global cardinality constraint M Wallace Ed CP Lecture Notes Computer Science vol 3258 Springer 2004 pp 542556 22 JC Régin A ﬁltering algorithm constraints difference csps AAAI 1994 pp 362367 23 JC Régin Generalized arc consistency global cardinality constraint AAAIIAAI vol 1 1996 pp 209215 24 JC Régin The symmetric alldiff constraint T Dean Ed IJCAI Morgan Kaufmann 1999 pp 420425 25 F Rossi P van Beek T Walsh Handbook Constraint Programming Elsevier 2006 26 A Schrijver Combinatorial Optimization Polyhedra Eﬃciency SpringerVerlag Berlin 2003 27 C Schulte PJ Stuckey Speeding constraint propagation M Wallace Ed CP Lecture Notes Computer Science vol 3258 Springer 2004 pp 619633 28 P Van Hentenryck JP Carillon Generality versus speciﬁcity An experience ai techniques AAAI 1988 pp 660664 29 P Van Hentenryck Y Deville The cardinality operator A new logical connective constraint logic programming ICLP 1991 pp 745759 30 P Van Hentenryck Y Deville CM Teng A generic arcconsistency algorithm specializations Artif Intell 57 23 1992 291321 31 WJ van Hoeve JC Régin Open constraints closed world JC Beck BM Smith Eds CPAIOR Lecture Notes Computer Science vol 3990 Springer 2006 pp 244257