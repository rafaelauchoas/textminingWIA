Artiﬁcial Intelligence 191192 2012 119 Contents lists available SciVerse ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Applicability conditions plans loops Computability results algorithms Siddharth Srivastava Neil Immerman Shlomo Zilberstein Department Computer Science University Massachusetts Amherst MA 01003 United States r t c l e n f o b s t r c t Article history Received 15 November 2010 Received revised form 18 July 2012 Accepted 20 July 2012 Available online 25 July 2012 Keywords Automated planning Plans loops Plan veriﬁcation Reachability abacus programs Generalized planning 1 Introduction The utility including loops plans long recognized planning community Loops plan help increase applicability compactness representation However progress ﬁnding plans limited largely lack methods reasoning correctness safety properties loops actions We present novel algorithms determining applicability progress general class loops actions These methods directing search plans loops greater applicability guaranteeing termination postprocessing computed plans precisely characterize applicability Experimental results demonstrate eﬃciency algorithms We discuss factors problem determining applicability conditions plans loops incomputable 2012 Elsevier BV All rights reserved The problem planning AI compute plan procedure executed agent achieve certain goal This paper presents methods computation compact plans resemble programs branches loops In classical formulation AI planning agents state assumed completely observable effects actions assumed determined entirely state Classical plans consist linear sequences actions lead goal state particular initial state Even restricted deterministic formulation planning problem PSPACEcomplete 2 input speciﬁed STRIPS framework 8 More general formulations allow agent possess partial information current state actions nondeterministic problem signiﬁcantly harder 18 Consequently numerous approaches proposed reusing sequences actions computed related problems 710 computing generalized plans solve large classes planning problems 19142624 Approaches generalized planning build extensively power including loops actions representing cyclic ﬂows control plans Not constructs necessary input problem instances bounded size allow signiﬁcant reductions plan sizes larger problemsparticularly contingent solutions required order deal partial observability 123 Plans loops present appeal ing advantages compact easier synthesize solve problem instances offering greater generality Corresponding author Email addresses siddharthcsumassedu S Srivastava immermancsumassedu N Immerman shlomocsumassedu S Zilberstein 00043702 matter 2012 Elsevier BV All rights reserved httpdxdoiorg101016jartint201207005 2 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 Loops plans inherently unsafe structures hard impossible general termine general conditions terminate achieve intended goals It crucial determine plan loops able solve given problem instance Unfortunately currently little understanding applicability conditions plans loops computed eﬃciently This limitation signiﬁcantly impacts development usability approaches ﬁnding generalized plans In paper present methods computing conditions plan particular class loops terminate desired state Our approach elaborates builds ideas presented 22 We develop ideas identify clearly factors problem determining termination plans loops diﬃcult We present new results determining termination broader class plans loops illustrate methods applied We ﬁrst formulate notion plans loops concept generalized planning problems introduced prior work 2124 Solutions problems expressed generalized plans Generalized plans rich control structures include loops parameterized lifted actions arguments instantiated execution These notions described Section 2 In spite expressiveness broad class generalized plans easily translated abacus programsformal models computation use primitive actions powerful Turing machines Abacus programs ﬁnite sets nonnegative registers actions increment conditionally decrement registers Section 24 Abacus programs shown close relationship numerical planning problems Helmert 11 showed abacus programs reduced class planning domains numerical variables goal conditions use numerical variables action preconditions include comparisons variables zero action effects increment decrement variables This leads negative result plan existence problem undecidable planning domains undecidability halting problem abacus programs In work present positive results capturing classes abacus programs halting problem decidable Our approach computing applicability conditions plans loops ﬁrst develop methods computing conditions given abacus program reach desired state This referred reachability problem abacus programs Undecidability halting problem abacus programs implies reachability problem abacus programs undecidable general However certain classes abacus programs categorized terms graphical structure represent control ﬂow solvable reachability problems We develop methods addressing reachability problem abacus programs classes These methods compute applicability conditions broad class generalized plans translating abacus programs Furthermore fact translation preserves structure control ﬂow makes methods applicable synthesis tractable generalized plans synthesis choose permit control structures generalized plans allow computation reachability conditions translation abacus programs Prior work describes possible instantiation process greater 25 The fundamental nature abacus programs makes methods generally applicable plans loops expressed generalized plans representation suitable translations abacus programs The following section develops formal framework rest paper describes connection generalized plans abacus programs We develop methods solving reachability problem abacus programs control ﬂow uses simple loops Section 3 We introduce class nested loops Section 4 develop methods addressing reachability problem deterministic nondeterministic abacus programs class nested loops Section 5 Finally conclude demonstration scope eﬃciency methods 2 Formal foundations In work consider loops actions iteration execution plan measurable progress goal We necessarily terminating loops progressive For example blocksworld loop actions iteration unstacks block clear table makes incremental progress goal having blocks table In contrast loop actions need repeated succeed For example order pick block slippery gripper need loop executes pickup action succeeds Plans loops considered strong cyclic planning 3 focus paper Our motivation considering progressive loops facilitate computation plans strong guarantees termination correctness situations number objects manipulated unknown To clarify notions begin formal description approach brief summary recently proposed framework generalized planning progressive loops turn useful This followed descrip tion representation generalized plans Section 22 The half section presents formal deﬁnition abacus programs Section 24 conditions view generalized plans abacus programs Section 23 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 3 21 Generalized planning problems Fig 1 A generalized plan transporting objects L1 L2 Intuitively generalized planning problem consists domain schema set initial states goal condition A domain schema includes predicate vocabulary set predicate symbols formulas constants represented special unary predicates set action operators integrity constraints We use ﬁrstorder logic represent domain schemas generalized planning problems This allows represent planning domains referring speciﬁc objects occur particular generalized planning problem Further generalized planning problem include uncertainty object quantities properties We refer reader prior work details 2124 present essentials Deﬁnition 1 Domain schema A domain schema tuple D cid3V A Kcid4 V vocabulary A set actions expressed ﬁrstorder logic transitive closure FOTC K integrity constraint expressed FOTC p Here cid2 Action representation For predicate p action a1 affects action operator a1 includes expression following form p x denotes predicate action application cid3 cid3 pax pax px cid2 px cid2 cid2 cid2 cid5 cid5 pa denotes conditions predicate p changed true application action cid2 pa denotes conditions changed false Intuitively Eq 1 states p true tuple iff false action changes true b true removed action This representation similar frame axioms situation calculus 15 To compute effect action given state affected predicate p evaluate truth RHS Eq 1 given state We deﬁne generalized planning problem follows Deﬁnition 2 Generalized planning problem A generalized planning problem tuple cid3α D γ cid4 α FOTC formula describing possible initial states D domain schema γ FOTC formula specifying goal states 22 Generalized plans We represent generalized plans graphs We provide brief illustration main features representation refer interested reader prior work details 24 Deﬁnition 3 Graphbased generalized plan A graphbased generalized plan Π cid3V E cid6 s T cid4 deﬁned tuple V E respectively vertices edges ﬁnite connected directed graph cid6 function mapping nodes actions edges conditions represented linear inequalities s start node T set terminal nodes The edge conditions graphbased generalized plans represented linear inequalities number objects satisfy certain properties unary predicates The interested reader referred 24 details Fig 1 shows simple generalized plan transport problem single truck incrementally loads object location L1 drives L2 unloads object The predicate vocabulary example consists unary predicates objx denoting x object transported atLix denoting x Li 1 2 inT x denoting x truck The start terminal nodes plan labeled dummy Start Stop actions Most edges default edge dition True The nonTrue edge conditions use number objects satisfy predicates obj atL1 denoted obj atL1 These edge conditions depend cardinality set objects L1 equal 0 4 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 The execution generalized plan begins start node continues edges conditions satisﬁed world state resulting actions application Fig 1 lists changes cardinalities certain predicate combinations These changes signiﬁcant translation plans abacus programs revisit section This example illustrates generalized plan use choice actions select arguments subsequent actions Choice actions select object satisﬁes given formula ﬁrstorder logic assign constant action update formulas Intuitively multiple objects satisfy formula choice action generalized plan considered solve problem iff executions plan choices qualifying objects solve problem 23 Cardinality changes generalized plans The generalized plan Fig 1 annotated changes cardinalities properties The class possible properties cardinalities kept track speciﬁc particular approach generating generalized plans We consider special case space possible properties powerset unary predicates domain More precisely deﬁne role element state set unary predicates satisﬁes obj atL1 The rolecount role obj atL1 state denotes cardinality role number elements satisfy role Thus Fig 1 cardinality changes indicate loadT c action decrements number objects L1 increments number objects L1 truck In following development utilize crucial aspects cardinality changes demonstrated Fig 1 1 Action branches plan nodes outdegree greater 1 distinguished inequalities constant zero cardinalities certain properties 2 The changes actions cardinalities deterministic Every possible execution particular action node plan leads change cardinality In fact aspects fundamental computationas section form cardinality changes express plan loops In prior work showed generalized plans computed cardinality changes wide class domains 24 This class includes PDDLlike domains use unary predicates vocabulary particular class domains binary predicates deﬁned extendedLL domains In work action branches depend comparisons rolecounts constant 1 use constant 0 paper The representations equivalent plans easily translated 20 Another direction study defer future work identify changes caused action node selected group cardinalities given arbitrary generalized plan The main insight paper effectively determine applicability generalized plan looking effect action cardinalities determine action branches Thus reduce generalized plan simpler structure actions increment decrement nonnegative integer valued variables action branches depend values variables Such structures known abacus programs described formally section Viewing generalized plans abacus programs allows study easily conditions particular sequence action branches taken execution This turn allows compute conditions execution generalized plan lead desired state plan In applications state reached world state satisﬁes goal condition recall generalized plans edges labeled conditions world states In conﬁgurations methods compute conditions generalized plan terminate ﬁnite number steps achieve goal A domain designed nonoccurrence undesirable property included goal formulain case goal reachability ensure unsafe situations occur 24 Abacus programs We introduce formal framework abacus programs 13 Abacus programs ﬁnite automata states labeled actions increment decrement ﬁxed set registers Deﬁnition 4 Abacus programs An abacus program cid3R S s0 sh cid6cid4 consists ﬁnite set nonnegative integervalued registers R ﬁnite set states S special initial halting states s0 sh S labeling function cid6 S sh cid10 Act The set actions Act consists actions form Incr s increment r R goto s S Decr s1 s2 r 0 goto s1 S decrement r goto s2 S S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 5 Fig 2 A simple abacus machine program r1 0 r1 r2 We represent abacus programs bipartite graphs edges nodes representing control states nodes repre senting actions viceversa In rest paper use term state connection abacus programs refer node represents control state term action refer node represents action Node general term situations type label node irrelevant property discussed States outgoing edge actions outgoing edges edges decrement action labeled 0 0 respectively Fig 2 Given initial valuation registers execution abacus program starts s0 At step action executed corresponding register updated new state reached An abacus program terminates iff execution reaches halt state The set ﬁnal register values case called output abacus program Abacus programs equivalent Minsky Machines 16 powerful Turing machines undecidable halting problem Fact 1 The problem determining abacus program reach halt state starting given set initial register values undecidable Nevertheless identify paper general class abacus programs halting problem decidable As discussed previous section approach determining utility applicability conditions plans loops view abacus programs However abacus program framework restrictive point view include nondeterministic actions In planning hand nondeterministic sensing actions common We need way effectively translate abacus framework changing loop structure For purpose extend abacus program framework adding following nondeterministic form action Deﬁnition 4 Deﬁnition 5 Nondeterministic abacus programs Nondeterministic abacus programs abacus programs set actions Act includes addition Inc Dec actions nondeterministic actions form NSets1 s2 nondeterministically s1 S s2 S S set states abacus program A nondeterministic action outgoing edges graph representation Either branches taken execution Although original formulation abacus programs suﬃcient capture computation actions allow conveniently translate plans loops nondeterministic domains abacus programs 3 Applicability conditions deterministic simpleloop abacus programs We simpleloop abacus program eﬃciently characterize exact set register values lead termination desired goal state deﬁned given set register values Theorem 1 We consider deterministic actions section case simple loops nondeterministic actions analogous handled special case methods presented Section 52 general class loops Recall nontrivial strongly connected component node We deﬁne simpleloop abacus programs follows Deﬁnition 6 Simpleloop abacus programs A simple loop graph strongly connected component consisting exactly cycle A simpleloop abacus program nontrivial strongly connected components simple loops 1 R0 Let S 1 a1 Sn S1 simple loop Fig 3 We denote register values states vectors For example R0 cid3R0 cid4 denotes initial values registers R1 Rm state S1 Let ai denote index register potentially changed action ai Since abacus actions branch ai determined value Rai greater equal 0 previous state 2 R0 m represented R0 We use subscripts vectors project corresponding registers initial count action ai s register ai Let cid2i denote vector changes register values R1 Rm action ai corresponding 6 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 Fig 3 A simple loop right left shortcuts branch loop For action change vector 0s dimensions possibly register index action affects change 1 1 0 corresponding 0 branch decrementing action Let linear segment abacus program distinct sequence states actions S 1 a1 S2 a2 an1 Sn S edge ai ai edge S i1 program Let cid21i cid21 cid22 cid2i denote registerchange vector sequence abacus actions a1 ai Given linear segment abacus program easily compute preconditions reaching particular register value state combination Proposition 1 Suppose S1 a1 S2 a2 Sn linear segment abacus program S states ai actions Let F vector register values constants andor variables A set necessary suﬃcient linear constraints initial register values R0 S1 computed Sn reached register values F Proof We know F R0 cid21n linear segment executed Sn However need determine conditions ﬂow control branch leading linear segment Since sequence actions known register values state S represented terms R0 More precisely register vector action ai S i1 R cid21i1 The condition taking 0 branch ai expressed R cid21i1ai 0 A conjunction expressions decrementing action given linear segment constitutes necessary suﬃcient conditions induction length linear segment This conjunction computed time linear length input segment cid2 Proposition 2 Suppose given simple loop S1 a1 Sn S1 abacus program Then O n time compute set linear constraints C R0 F cid6 satisﬁed initial ﬁnal register tuples R0 F natural number cid6 iff starting execution S 1 register values R0 result cid6 iterations loop S1 register values F Proof Consider action a4 left loop Fig 3 Suppose condition causes stay loop action a4 Ra4 0 Then loop branch taken ﬁrst iteration starting ﬂuentvector R0 R0 cid213a4 0 For execution loop starting R0 require 1 n cid4 R0 cid21i1 cid5 0 ai corresponding branch lies loop set inequalities simpliﬁed removing constraints subsumed Since variable term set inequalities R0 represent LoopIneq R0 Formally vector register values R given simple loop sl deﬁne LoopIneq follows LoopIneqsl R ncid6 cid7cid4 i1 R cid21i1 cid5 ai cid8 0 ith inequality inequality branch following action ai loop We omit subscript sl clear context Let Rcid6 R0 cid6 cid21n register vector cid6 complete iterations Thus executing loop completely cid6 times required condition LoopIneq R0 LoopIneq Rcid61 This conjunction ensures conditions execution intermediate loop iterations hold changes register values actions constant expression Rcid61 linear These conditions necessary suﬃcient way executing complete iteration loop undergoing register changes satisfying branch conditions Hence necessary suﬃcient conditions achieving given register value cid6 complete iterations F Rcid6 cid4 LoopIneq cid4 LoopIneq R0 F cid6 Rcid61 R0 C cid5 cid4 cid5 cid5 cid4 cid5 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 7 Fig 4 An abacus program integer division 2 The inequality action constant size concerns single register The total length inequalities O n described computed total O n time cid2 An exit ﬁrst iteration amounts linear segment actions handled Proposition 1 Instead nonnegative integers component F algebraic expression representing register values subsequent state abacus program reachable These expressions derived reachability computations subsequent segments abacus program More precisely precondition reaching goal executing segment Π j simple loop abacus program expressed terms register vector start Π j R j Representing precondition reaching F executing abacus program Π starting register vec tor R0 preΠ R F precondition reaching goal executing segment Π2 followed Π1 computed preΠ2 R2 R1 preΠ1 R1 F Here ﬁnal register vector preΠ2 R1 This process similar regression 17 applies plans loops actions acyclic plans The following example illustrates points vector variables Example 1 The abacus program shown Fig 4 divide value register 2 Suppose initial cid4 The total change vector iteration loop cid213 cid32 1cid4 LoopIneq R0 register vector R0 cid3r0 1 0 r0 loop r0 1 r0 1 0 LoopIneq Rcid61 r0 cid6 1 2 0 r0 1 cid6 1 2 1 0 1 1 2 To obtain conditions reaching S2 exit action a1 include condition value r1 cid6 1 2 0 In general condition computed treating zero application a1 r0 1 partial iteration loop required reach exit node action a1 case linear segment abacus program r0 Therefore reachability conditions S2 a1 iteration simple loop r0 1 0 r0 2cid6 1 cid6 represents number loop iterations The ﬁnal register vector S 2 F cid30 r0 0 r0 1 12cid4 The conditions reaching S2 a1 ﬁrst iteration r0 cid30 r0 2 necessary suﬃcient conditions reaching S 2 register vector F a1 Ra1 cid6 1cid4 r0 cid30 r0 1 2 In words r0 2 similarly capture case r0 The complete reachability conditions S2 Ra1 components ﬁnal register vector precondition computation segment 1 1 cid6 1cid4 2 cid4 Therefore 2cid6 1 F 0 1 r2 r12 S2 Reachability conditions S2 a2 computed cid4 2 0 F cid30 r0 cid6 0 r0 1 cid4 If include condition ﬁnal value r2 r0 2cid6 1 F cid30 r0 Ra2 If segment program led S1 variables r0 0 F cid30 r0 0 r0 1 odd Here Ra2 1 F cid30 r0 12 r0 cid6 0r0 1 cid6cid4r0 1 2 1 2 2 2 When combination Proposition 1 method described produces necessary suﬃcient ditions reaching state register value abacus program Theorem 1 Let Π A simpleloop abacus program Let S state program F vector register values We compute disjunction linear constraints initial register values necessary suﬃcient condition reaching S register values F Proof Since Π A acyclic simple loops decomposed set segments starting common startstate consisting linear paths simple loops One approach carrying process ﬁrst collapse simple loop graph abacus program super node All edges ending beginning node simple loop changed end begin respectively super node replaced simple loop The resulting graph acyclic compute linear paths leading start state desired state In path replace super nodes corresponding simple loops During process reattach edges neighbors super node original nodes attached By Propositions 1 2 necessary suﬃcient conditions segments computed The disjunctive union conditions gives 8 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 Fig 5 Many nested loops encountered programming viewed simple loops shortcuts distinguishing looporienting node loop entry node In example linear path a1 j k treated linear segment followed simple loop shortcuts desired necessary suﬃcient condition In worst case total size disjunction exponential number nodes graph cid2 4 Nested loops shortcuts Due undecidability halting problem abacus programs impossible ﬁnd preconditions abacus programs arbitrarily nested loops The previous section demonstrates structurally restricted classes abacus programs admit eﬃcient applicability tests In section methods developed previous section extended class graphs represent ing nested loops obtained adding unidirectional paths shortcuts simple loop We ﬁrst deﬁne general class nonsimple loops follows Deﬁnition 7 Complex loops Let A abacus program A complex loop A nontrivial strongly connected compo nent simple loop In particular interested special class complex loops obtained adding shortcuts simple loop Deﬁnition 8 Simple loop shortcuts Let A abacus program A simple loop shortcuts A strongly connected component C includes node n0 designated looporienting node removing n0 makes C acyclic We abacus program simple loops shortcuts strongly connected components simple loops shortcuts Note looporienting node labeled action state Intuitively simple loop shortcuts consists simple loop elements starting looporienting node increasing linear order For pair nodes loop preceding b shortcut b added different shortcuts overlap long create cycles state S2 designated looporienting node Fig 3 The looporienting node node ﬂow control enters simple loop shortcuts Indeed wish determine preconditions respect node looporienting node entry node given simple loop shortcuts ﬁrst ﬁnd preconditions respect looporienting node entry node propagate conditions acyclic paths connecting entry node looporienting node Theorem 1 applied acyclic segment abacus program Simple loops shortcuts form general class complex loops graph theoretically exactly class strongly connected components cycle rank 1 6 Many control ﬂows typically understood nested loops programming represented simple loops shortcuts choosing appropriate looporienting node Fig 5 shows example Further abacus programs Section 41 class graphs powerful express computation The advantage class loops decompose simple loops deﬁnition cycle repeated states start end states Deﬁnition 9 Loop decomposition Let A abacus program let C strongly connected component A form simple loop shortcuts looporienting node n0 The loop decomposition C deﬁned set cycles C beginning n0 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 9 Fig 6 Construction translating general abacus program simple loop shortcuts In worst case size decomposition exponential number shortcuts This construction proves useful simple loop shortcuts cycle contain looporienting node immediate Deﬁnition 8 Thus execution simple loop shortcuts abacus program viewed sequence complete executions simple loops decomposition For instance view loop shortcuts Fig 3 consisting 3 different simple loops The order execution loops given loop executed depend results actions a3 a5 We deﬁne special class simple loops shortcuts abacus programs In section present methods ﬁnding preconditions programs Deﬁnition 10 Monotone simple loops shortcuts Let net change register simple loop abacus program total change caused register execution loop A simple loop shortcuts abacus program monotone iff register sign positive negative net change register simple loop decomposition In section removing restriction signiﬁcantly increase power abacus programs abacus program represented program consisting simple loop possibly nonmonotone shortcuts 41 Relaxing monotonicity We consider problem computing preconditions abacus program simple loops shortcuts need monotone As noted earlier terms computational expressiveness class powerful We abacus program effectively represented program consisting simple loop shortcuts Theorem 2 Let Πg abacus program R g N g E g sets registers nodes edges respectively Then exists equivalent abacus program ΠS R S R g N S N g E S sets registers nodes edges respectively 1 ΠS consists simple loop shortcuts 2 Execution Πg initial register vector Rinit equivalent ΠS initial vector R reachable register vector R f Πg iff reachable ΠS register vector R R g cid5 init node n N g f matches R f registers cid5 Proof In order construct ΠS add new ﬂag register li ni N g The values ﬂag registers rise 1 stage execution ﬂag registers nonzero We use ﬂags translate edges Πg set case statements starting common new start state Let n0 a0 a0 n1 a0 n2 set edges corresponding single decrementing action a0 Construction ΠS Πg We translate sequence sequence beginning action decrementing l0 The 0 branch action represents case state n0 This branch lead node a0 branches a0 lead actions incrementing l1 l2 corresponding branches lead n1 n2 The construction illustrated Fig 6 The translation similar incrementing actions To ΠS perform construction edges corresponding action Πg manner attach resulting graph 0 branch ﬂag decrementing action shown Fig 6 The resulting abacus program ΠS consists simple loop shortcuts Computation R corresponding Πg s start state initialized 1 ﬂag registers initialized 0 init The initial values original registers R g Rinit ﬂag register cid5 By construction executing action register vector leads node ni Πg iff executing action extended register vector ﬂag variables zero note ﬂagtesting action decrements nonzero ﬂag 10 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 zero leads li subsequently ni ΠS By induction path lengths result node ni reachable Rinit Πg iff reachable R cid5 init ΠS cid2 Simple loops nonmonotone shortcuts suﬃcient capture power Turing machines Corollary 1 The class abacus programs strongly connected components simple loops shortcuts Turingcomplete Removing condition monotonicity makes problem computing preconditions abacus programs simple loops shortcuts unsolvable Currently intermediate characterizations simple loops shortcuts bridge gap monotone shortcuts paper demonstrates existence eﬃcient meth ods ﬁnding preconditions nonmonotone loops problem undecidable An important direction future work identify useful tractable generalizations notion monotonicity reachability conditions computed 5 Applicability conditions monotone simple loops shortcuts We consider problem computing applicability conditions monotone simple loops shortcuts We ﬁrst present speciﬁc case programs deterministic actions In following section present methods computing reachability conditions abacus programs nondeterministic actions 51 Deterministic monotone shortcuts We address problem determining program terminate given register vector designing algorithm takes input initial register vector provides yesno answer More precisely algorithm eﬃciently compute ﬁnal register vector given initial register vector Without loss generality consider problem setting single simple loop shortcuts start state program looporienting node loop Our approach relies following observations 1 Because monotonicity loop executed certain number iterations exited ﬂow control return loop 2 For given conﬁguration register values looporienting node reached sim ple loops given loops decomposition completely executable This multiple simple loops executed starting given register value conﬁguration action program possible control ﬂow outgoing edge However impossible action multiple outcomes decrementing action exactly branches conditions mutually inconsistent As consequence second observation given abacus program initial register vector compute ﬁrst loop executed number iterations executed precise method computing described remove loop consideration ﬁrst observation repeat process This continued loop executed completely When process terminates sequence loops number iterations executed exiting given simple loop shortcuts Taking initial register valuation input Algorithm 1 performs computations Let Π A abacus program form simple loop monotone shortcuts deterministic actions Algorithm 1 works identifying unique loop cid6 LoopIneqcid6 satisﬁed value R initialized R0 steps 58 calculating number iterations executed loop LoopIneqcid6 gets violated step 9 updating register values reﬂect effect iterations step 12 identifying loop executed loop step 4 The subroutine FindMaxIterations uses inequalities LoopIneqcid6 Proposition 2 construct vector equation R cid6maxcid2cid6 cid21i1ai 0 action loop cid6 This equations consists inequality following form corresponding decrementing action loop cid4 cid5 cid6max Rai cid21i1 ai cid2cid6 ai Since R known computation ﬂoor minimum RHS equations yield largest possible value cid6max Equality constraints drop net change registers value loop cid6 zero satisﬁed ﬁrst iteration set cid6max 1 net change registers value zero satisﬁed ﬁrst iteration Equality constraints satisﬁed FindMaxIterations called know LoopIneqcid6 satisﬁed Note loop decrease registers value terminate This reﬂected computation cid6max value step 11 Thus S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 11 Algorithm 1 Reachability deterministic monotone shortcuts Input Deterministic abacus program form simple loop monotone shortcuts looporienting node state Sstart initial register conﬁguration Output Sequence loop id iterations tuples ﬁnal value R Sstart R0 1 R R0 2 Iterations list 3 LoopList simple loops loop decomposition 4 LoopList cid16 5 cid6 LoopList satisﬁes LoopIneqcid6 R 6 7 8 9 10 11 12 Return Iterations end cid6 id loop LoopIneqcid6 R holds Remove cid6 LoopList cid6max FindMaxIterations R cid6 cid6max Return Nonterminating loop end Iterationsappendcid6 cid6max R R cid6maxcid2cid6 end 13 Return Iterations R Theorem 3 Given deterministic abacus program Π form simple loop monotone shortcuts looporienting node representing state S initial register vector R0 Algorithm 1 returns number times simple loop Π s decomposition executed register vector S iterations order execution simple loops loop decomposition Π Depending rest abacus program ﬁnal register vector output Algorithm 1 initial register vector determining reachability subsequent state desired register vector Let b maximum number branches loop decomposition given simple loop Complexity analysis shortcuts L total number simple loops decomposition The expensive operation algorithm step 5 R tested loops inequality loop inequalities need constructed Step 5 executed O Lb time step 9 O b time The entire loop executed L times resulting total execution time O L2b On hand program directly applied problem instance program terminates execution time program order largest input register value unbounded 52 Nondeterministic monotone shortcuts We consider problem computing applicability conditions abacus programs simple loops mono tone shortcuts nondeterministic actions We presented methods extending approach creating generalized plans cardinality changes summarized Section 2 setting prior work 23 We ﬁnd accuracy reachability conditions compute determined order independence Deﬁnition 11 extent execution different loops decomposition simple loop shortcuts rearranged signiﬁcantly affecting overall outcomes The methods discussed section applied settings deterministic actionsyet simple loops shortcuts situations demonstrate order dependence Therefore reachability conditions obtained manner tend subsumed computed methods Section 51 Suppose abacus program Π simple loop shortcuts decomposed m simple loops looporienting node representing state Sstart analysis case looporienting node labeled action analogous We consider case l complete iterations Π counted looporienting node k1 representing number times loops 1 m executed respectively The ﬁnal partial iteration loop exit simple loops handled linear program segment Then k1 l 1 Determining ﬁnal register values We denote ith loop decomposition given simple loop shortcuts loopi The ﬁnal register values l m i1 ki complete iterations provided iterations executed cid9 12 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 exiting simple loop shortcuts obtained adding changes simple loop cid2loopi denoting change vector loopi F R0 mcid10 i1 kicid2loopi 2 Let R R Cumulative branch conditions For computing suﬃcient conditions achievable register values k1 complete iterations given loops approach treat loop simple loop determine preconditions executing Note required condition loops complete iteration stems comparison registers value zero We consider case conditions required staying loop 0 discuss situation equality constraints following section Accuracy Computed Conditions Thus want determine lowest possible value register k1 iterations loops 1 m constrain value greater zero sets registers undergoing net nonnegative negative changes respectively loop The sequence actions iteration simple loop ﬁrst decrease register increase Through process net decrease register iteration simple loop smaller greatest decrease underwent initial segment loop We denote change initial segment wrt loop orienting node simple loop register partial change loop register Let δi j greatest partial negative change caused R j loopi Let min j arg minxδx j x 1 m For R j R lowest possible value R0 j δmin j j The required constraint R j R δmin j j refers register value decrement takes place R0 j value R j increase ﬁrst iteration cid2 0 require cid2 0 condition 0 edge We compute lower bound value R j achieved k1 iterations loops 1 m respectively Lemma 1 In execution k1 iterations loops 1 m value register R j fall R0 j ˆj j ˆj arg minxδx j x 1 m cid2loopx j loop ˆj j cid2 δ cid9 m i1 kicid2loopi j Proof Suppose loop executed loopx If δx j possible value R j execution j loopx given ﬁrst computing value R j execution iterations required loops subtracting effect complete iteration loopx adding δx j greatest partial negative change loopx cid16 cid2x R0 j mcid10 i1 kicid2loopi j cid2loopx j δx j To obtain lowest value expression possible choices loop need minimize expression wrt x In cases encountered planning effectively choosing loop minimizes δx j loop x method Srivastava et al 22 In paper use general approach selecting loop ˆj follows cid7 ˆj arg min x 1 m cid8 δx j cid2loopx j x cid9 This minimization requires number comparison operations minimization δx j Let Rlb j R0 j m i1 kicid2loopi δ cid2 ˆj j loop ˆj j Our claim expression lower bound possible values R j execution given loops iteration counts Suppose true Then strictly lower value R j achieved execution loop loopq loop executed This possible R j R successive loop iteration decrease value cid2 j Now compute minimum possible values registers state required constraints cid11 R j R R0 j mcid10 kicid2loopi j δ ˆj j cid2 loop ˆj j cid2 0 cid12 cid7 R0 j i0 δmin j j cid8 cid2 0 R j R 3 4 Together Eqs 12 inequalities provide suﬃcient conditions binding reachable register values number loop iterations initial register values However process deriving assumed j loop ˆj loopmin j executed We constraints accurate disjunctive S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 13 formulation selecting loop causing greatest negative change executed For register R j let 0 ˆj m ˆj ordering loops increasing order values δx We use ordering j writing constraints registers R j intended purpose writing constraints registers R In following constraints use kix 0 denote constraints ki 0 x ordering constraint We write disjunctions constraints corresponding ﬁrst loop orderings executed follows Similarly let 0 j mj ordering loops increasing values δx cid2loopx j cid13 cid14 kix 0 kx cid16 0 R0 j cid10 kicid2loopi j δx j cid2loopx j cid2 0 cid15 R j R R j R x0 ˆj m ˆj cid13 cid7 kix 0 kx cid16 0 R0 j xcid2icid2m ˆj cid8 cid2 0 δx j x0 jm j 3 4 Constraints 3 4 derived 3 4 replacing argmins ˆj min j variable x iterates loops order 0 ˆj m ˆj registers R order 0 j mj registers R Constraint 3 tighter 3 changing loop executes impact lowest loop register R j representing value register Otherwise δx cid2loopx situation lowest achievable value register R j independent loops execution occurs j The following example illustrates computation conditions 3 4 Example 2 Suppose decomposition abacus program form simple loop shortcuts consists loops A single iteration loop1 ﬁrst decrements R1 5 ﬁrst ﬁve actions starting looporienting node decrements increments 1 A single iteration loop2 ﬁrst decrements R1 3 increments 2 Effects register R2 follows A single iteration loop1 ﬁrst decrements R2 2 increments 3 loop2 ﬁrst decrements R2 1 increments 2 Conditions 1 2 easily computed We need compute condition 3 R1 undergoes net decrement In example greatest partial negative changes δx 4 1 x 1 2 respectively The expressions δx evaluate 1 2 x 1 2 respectively j ordering loops 1 2 increasing order value 2 1 Consequently lowest possible value R 1 occur loop2 executed Lemma 1 Thus ﬁrst write conditions loop2 executed k2 0 4k1 4 5 R0 1 R0 1 4k1 k2 1 3 R0 1 4k1 1 0 The disjunction corresponding condition 3 cid5 4k1 k2 2 cid2 0 If loop2 executed k2 0 k1 0 R0 1 5 3 x 1 2 respectively net changes cid2loopx cid2loopx j cid5 1 1 cid4 k2 cid16 0 R0 1 4k1 k2 2 cid2 0 cid4 k2 0 k1 cid16 0 R0 1 4k1 1 cid2 0 Condition 4 computed ordering loops increasing order δx respectively Thus desired condition 4 2 cid2 0 cid4 k1 0 k2 cid16 0 R0 2 cid4 k1 cid16 0 R0 2 1 cid2 0 cid5 cid5 2 takes values 2 1 x 1 2 We use conditions 3 4 compute conservative complete condition executing k1 k2 iterations loops 1 2 R0 1 4k1 k2 2 cid2 0 R0 2 2 cid2 0 These conditions use loop orderings miss small number initial register values allowed required iterations loops 521 Accuracy computed conditions In order discuss conditions 14 accurate ﬁrst deﬁne order independence Deﬁnition 11 Order independence A simple loop shortcuts order independent initial valuation registers Sstart set register values possible Sstart number iterations depend order iterations taken An equality constraint loop considered spurious loop created shortcuts changes register equality required During execution loop truth conditions change Consequently equality conditions introduce order dependence In practice conditions translated conditions register values prior entering loop A simple loop shortcuts order dependent following holds 1 lowest value achiev able register execution depends order shortcuts taken In case possible lowest values impose different constraints ordering 2 nonspurious equality condition satisﬁed stay 14 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 loop In case nondeterministic branch leading shortcut equality condition taken precise iteration equality satisﬁed In fact disjunction conditions necessary suﬃcient loop order dependent Proposition 3 A simple loop shortcuts order dependent iff 1 lowest value achievable register execution depends order shortcuts taken 2 nonspurious equality condition satisﬁed continue loop iteration Proof Suﬃciency condition discussed If loop order dependent register value reachable good subset possible orderings shortcuts Consider ordering number iterations shortcuts belonging subset During execution sequence ﬁrst step loop iteration completed good subset completed chosen ordering This inequality 0 satisﬁed decrement implies 1 holds R j 0 required continue iteration possible good loop orderings R j 0 hold implies case 2 holds cid2 A naive approach expressing necessary conditions order dependent loop exponential number shortcuts considering single iteration loop We computation ˆj handling speciﬁc kind order dependence lowest value register depends iteration executed Example 3 Consider loops l1 l2 decomposition simple loop monotone shortcuts abacus program l1 increases R1 5 R2 1 l2 ﬁrst decreases R1 4 increases 5 l1 l2 monotone shortcuts combination order dependent S start R1 1 l2 executed completely executing l1 Expressing precise preconditions reachable register values requires speciﬁcation order shortcuts taken Loops nonspurious equality constraints special cases order dependent loops Although encounter loops nonspurious equality constraints test problems considered conditions 14 extended include equality conditions ﬁrst iteration loop Because registers increase decrease monotonically 14 suﬃcient necessary conditions situations equality branches required stay loop Unfortunately worst case 14 unsatisﬁable We present results capturing accuracy conditions 14 Proposition 4 If Π order independent simple loop monotone shortcuts Eqs 14 provide necessary suﬃcient conditions initial achievable register values Proof By construction inequalities ensure register values drops zero register value satisﬁes inequalities reachable This proves conditions suﬃcient Suppose register value F reachable R0 k0 iterations loop0 loopm respectively Eq 2 violated changes caused loops ﬁxed Eq 1 satisﬁed trivially If R0 k0 dont satisfy Eqs 34 lowest value achieved loop iterations fall zero loop order independent Therefore 14 satisﬁed cid2 Proposition 5 If Π simple loop monotone shortcuts Eqs 14 constraints required equality branches ﬁrst iterations shortcuts containing suﬃcient conditions possible ﬁnal register values terms initial values Proof By construction conditions 14 equality constraints ensure branch required complete ki iterations loop satisﬁed cid2 In words dont order independence conditions 14 suﬃcient necessary In adver sarial formulations simple loop executed depends nondeterministic actions require exactly conditions 14 ensure stipulated iterations loops executed In Section 6 present examples scenario This leads main result section analogous Theorem 1 simple loops Theorem 4 Let Π abacus program strongly connected components simple loops monotone shortcuts Let S state program F vector register values We compute disjunction linear constraints initial S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 15 Table 1 Timing results computing preconditions Problem Time s Problem Times Accumulator CornerA Diagonal HallA PrizeA5 001 000 001 001 001 PrizeA7 Recycling Striped Tower Transport Transport conditional 002 002 002 001 006 Fig 7 Solution plan transport problem register values reaching S register values F If simple loops shortcuts Π order independent obtained precondition necessary suﬃcient Proof Similar proof decomposition Theorem 1 Propositions 4 5 cid2 Semantics computed conditions Since working setting nondeterministic actions allowed variable ki implicitly capture number times particular outcomes nondeterministic actions present loopi occur ki iterations This appear measuring inherently unpredictable property non determinism mitigate utility computed preconditions However Section 6 nondeterministic abacus actions stand sensing actions able predict outcome sensing action possible know times certain outcome possible need use conditions In addition ki s parameters conditions capture tolerable values desired register value achieved In section addressed problem determining program reach certain state given register vector deriving constraints initial ﬁnal register values given abacus program In order achieve results concept order independence summarily deal collection simple loops number times executed These methods applied deterministic programs methods proposed Section 51 accurate general This simple loops shortcuts created deterministic actions highly order dependent include nonspurious equality conditions order execution loops determined exactly initial register values 6 Example plans preconditions We implemented algorithm ﬁnding preconditions simple loops order independent nested loops shortcuts applied plans loops discussed literature references included descriptions Existing approaches solve different subsets problems uniformly termination guarantees 141 Our takes input abacus program generalized plan cardinality changes marked action For strongly connected component ﬁrst determines simple loop If determines component simple loop shortcuts In order searches looporienting node removal entire component acyclic If node exists shortcuts nonmonotone input handled methods failure reported Reachability conditions constructed simple loops simple loops monotone shortcuts described previous sections Table 1 shows timing results 10 different plans Plan representation Figs 7 8 9 solution plans test problems In order plans easy read actions The default ﬂow control continues line line semicolons linebreaks Edges shown action multiple outcomes labeled conditions hold prior action application edge taken abacus programs Only edges required continue executing 16 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 Fig 8 Solution plan conditional version transport Fig 9 Solution plan recycling problem plan drawn preconditions ensure edges taken For clarity cases label outcomes action assumed complement label Actions written ActionNameargsargumentformulaargs Any object satisfying actions argument formula chosen executing plan The desired halt nodes indicated action Stop Transport In transport problem 21 trucks deliver sets packages Yshaped roadmap Lo cations D1 D2 D3 present terminal points Y location L intersection prongs Initially unknown number servers monitors present D1 D2 respectively trucks T1 capacity 1 T2 capacity 2 D1 D2 respectively The goal deliver objects D3 pairs kind The problem modeled predicates server monitor atD inT atL T 1 T 2 As discussed previous sec tion rolecounts representation treated register values actions abacus actions roles The plan shown Fig 7 ﬁrst moves server D1 L T1 T2 picks monitor D2 moves L picks server left T1 transports D3 The ﬁrst action load uses arguments object s satisfying servers atD1s constant T1 representing truck T1 It decrements count role server atD1 consequently outcomes depending value Note second load action plan outcomes plan shown In order reach Stop state goal condition require ﬁnal values s1 server atD1 m2 monitor atD2 zero Let s3 server atD3 m3 monitor atD3 The changes caused iteration loop 1 m3 s3 1 s1 m1 Using method developed Proposition 2 necessary suﬃcient condition reaching goal l iterations loop equal numbers objects types initially m0 2 l s0 1 Transport conditional In conditional version transport problem 23 objects left L lost servers heavy case forkLift action instead load action Fig 8 shows solution plan merging plans encountered dealt different nondeterministic action outcomes 23 If server T2 reaches L plan proceeds moving T2 D1 loading server proceeding D3 Note shortcut server lost subbranch corresponding server heavy The plan decomposed S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 17 8 simple loops Of 4 use server lost branch use extra server loops 0 5 6 7 inequality Let rolecounts s2 m2 s3 m3 previous problem Then obtained applicability conditions s f 3 m f 3 7cid10 i0 ki m f 2 m0 2 7cid10 i0 ki 0 s f 1 s0 1 7cid10 i0 ki k0 k5 k6 k7 0 These conditions possible loop decrements rolecounts s m order objects D3 conditions require extra servers kept D1 amounting number times server lost Recycling In problem recycling agent inspect set bins bin collect paper glass objects respective containers The solution plan includes nested loops shortcuts Fig 9 start state PickObj senseType sensing action collect actions decrement available capacity container represented rolecount X X paper glass Let e f p p denote rolecounts nonempty bins glass container capacity paper container capacity paper objects glass objects respectively Let l1 denote number iterations topmost loop l2 paper loop l3 glass loop The applicability conditions f g e f e0 l1 0 f p f f p0 l2 cid2 0 p f p0 l2 f g f f g0 l3 cid2 0 g f g0 l3 Note nonnegativity constraints guarantee termination loops Accumulator The accumulator problem 14 consists accumulators actions incr_acci increments register test_acc tests given accumulators value matches input k Given goal acc2 2k 1 k input Kplanner computes following plan incr_acc1 repeat incr_acc1 incr_acc2 incr_acc2 test_acc1 incr_acc2 Although plan correct k cid2 1 Kplanner determine work userprovided range values This problem modeled directly registers accumulators asserting goal condition ﬁnal values l iterations loop decrement operations We acc1 l 1 acc2 2l 1 2k 1 This implies l k 1 cid2 0 iterations required reach goal Further test problems discussion We tested algorithms plans loops Table 1 shows summary timing results The runs conducted 25 GHz AMD dual core Problems HallA PrizeA5 Prize A7 1 concern grid world navigation tasks In HallA agent traverse quadrilateral arrangement corridors rooms prize problems require complete grid traversal 5 n 7 n grids respectively Note dimensions representation problems taken unknown unbounded Our implementation computed correct preconditions plans simple loops solving problems In HallA instance correctly determined numbers rooms corridor arbitrary independent corridors The Diagonal problem general version Corner problem 1 agent start unknown position rectangular grid reach northeast corner reach southwest corner repeatedly moving step west step south In case method correctly determines grid square plan succeed In Striped Tower 21 approach correctly determines equal number blocks color needed order create tower blocks alternating colors In problems termination loops guaranteed nonnegativity constraints 7 Related work Although approaches studied utility generation plans loops provide guarantees termination progress solutions Approaches cyclic strong cyclic planning 3 attempt generate plans loops achieving temporally extended goals handling actions fail Loops strong cyclic plans assumed static likelihood loop exit iteration The structure plans possiblein sense graph connectivityto exit loops reach goal termination guaranteed assumed occur eventually Among recent work Kplanner 14 attempts ﬁnd plans loops generalize single numeric planning parameter It guarantees obtained solutions work userspeciﬁed interval values parameter Distill 26 identiﬁes loops example traces address problem preconditions termination learned plans Bonet et al 1 derive plans problems ﬁxed sizes controller representation use seen work problem instances They address problem determining problem instances plans work terminate 18 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 Finding preconditions linear segments plans studied planning literature 7 Approaches regression 179 planning directly address problem computing preconditions acyclic plan segments However concerted effort ﬁnding preconditions plans loops Static analysis programs deals similar problems ﬁnding program preconditions 5 However methods typically work weaker notion partial correctness 12 program guaranteed provide correct results terminates Methods like Terminator 4 speciﬁcally attempt prove termination loops provide precise preconditions number iterations required termination 8 Conclusions future work In paper presented approach formulating studying problem determining certain loop actions guaranteed terminate b lead desired result We showed problem studied effectively problem reachability desired states context primitive actions increase decrease nondeterministically change value counters Although approach ﬁrst address problem comprehensively eﬃcient scalable commonly encountered loops actions planning In addition ﬁnding preconditions computed plans component synthesis plans safe loops We established tractability results reachability analysis classes plans programs actions For simple loops actions problem admits eﬃcient algorithms slight extensions class loops simple loops shortcuts general capture power Turing machines undecidable reachability problem Theorem 2 general On hand property monotonicity case permit development algorithms determining reachability accuracy depending notion order dependence Proposition 4 Order dependence restrictive nondeterministic situations adversarial point view exact sequence nondeterministic outcomes actions predicted need plan worst case These results contribute understanding factors problems diﬃcult order dependence overcome conservative approximations property monotonicity hold Although non monotone simple loops shortcuts undecidable reachability problem worst case cases problems reachability termination answered Further identiﬁcation tractable classes non monotone simple loops shortcuts left future work Computation expression order dependent preconditions important directions future work pushing theoretical limits solvability problems We showed approach interpreting planning actions abacus actions paper The underlying methods determining reachability abacus programs actions interpreted incrementing decrementing counters Development general reductions instance description logic construct roles planning problems important direction future work Acknowledgements We thank anonymous reviewers detailed helpful comments Support work provided National Science Foundation grants IIS0915071 CCF0830174 CCF1115448 References 1 B Bonet H Palacios H Geffner Automatic derivation memoryless policies ﬁnitestate controllers classical planners Proc 19th International Conference Automated Planning Scheduling 2009 pp 3441 2 T Bylander The computational complexity propositional STRIPS planning Artiﬁcial Intelligence 69 12 1994 165204 3 A Cimatti M Pistore M Roveri P Traverso Weak strong strong cyclic planning symbolic model checking Artiﬁcial Intelligence 147 12 2003 3584 4 B Cook A Podelski A Rybalchenko Termination proofs systems code Proc 2006 ACM SIGPLAN Conference Programming Language Design Implementation 2006 pp 415426 5 EW Dijkstra Guarded commands nondeterminacy formal derivation programs Communications ACM 18 1975 453457 6 LC Eggan Transition graphs starheight regular events Michigan Mathematical Journal 10 1963 385397 7 R Fikes P Hart N Nilsson Learning executing generalized robot plans Technical report AI Center SRI International 1972 8 RE Fikes NJ Nilsson STRIPS A new approach application theorem proving problem solving Technical report AI Center SRI International 1971 9 C Fritz SA McIlraith Monitoring plan optimality execution Proc Seventeenth International Conference Automated Planning Scheduling ICAPS 2007 pp 144151 10 KJ Hammond CHEF A model case based planning Proc 13th National Conference Artiﬁcial Intelligence 1986 pp 267271 11 M Helmert Decidability undecidability results planning numerical state variables Proc Sixth International Conference Artiﬁcial Intelligence Planning Scheduling 2002 pp 4453 12 CAR Hoare An axiomatic basis programming Communications ACM 12 1969 576580 13 J Lambek How program inﬁnite abacus Canadian Mathematical Bulletin 4 3 1961 295302 14 HJ Levesque Planning loops Proc 19th International Joint Conference Artiﬁcial Intelligence 2005 pp 509515 15 HJ Levesque F Pirri R Reiter Foundations situation calculus Electronic Transactions Artiﬁcial Intelligence 2 1998 159178 16 ML Minsky Computation Finite Inﬁnite Machines PrenticeHall Upper Saddle River NJ USA 1967 17 R Reiter Knowledge Action Logical Foundations Specifying Implementing Dynamical Systems The MIT Press Massachusetts MA 2001 S Srivastava et al Artiﬁcial Intelligence 191192 2012 119 19 18 J Rintanen Complexity planning partial observability Proc 14th International Conference Automated Planning Scheduling 2004 pp 345354 19 JW Shavlik Acquiring recursive iterative concepts explanationbased learning Machine Learning 5 1990 3970 20 S Srivastava Foundations Applications Generalized Planning PhD dissertation Department Computer Science University Massachusetts Amherst 2010 21 S Srivastava N Immerman S Zilberstein Learning generalized plans abstract counting Proc 23rd National Conference AI 2008 pp 991997 22 S Srivastava N Immerman S Zilberstein Computing applicability conditions plans loops Proc 20th International Conference Automated Planning Scheduling 2010 pp 161168 23 S Srivastava N Immerman S Zilberstein Merging example plans generalized plans nondeterministic environments Proc 9th International Conference Autonomous Agents Multiagent Systems 2010 pp 13411348 24 S Srivastava N Immerman S Zilberstein A new representation associated algorithms generalized planning Artiﬁcial Intelligence 175 2 2011 615647 25 S Srivastava N Immerman S Zilberstein T Zhang Directed search generalized plans classical planners Proc International Confer ence Automated Planning Scheduling Freiburg Germany 2011 pp 226233 26 E Winner M Veloso LoopDISTILL Learning domainspeciﬁc planners example plans Workshop AI Planning Learning conjunction ICAPS 2007