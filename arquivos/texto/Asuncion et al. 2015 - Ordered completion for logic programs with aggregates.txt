Artiﬁcial Intelligence 224 2015 72102 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Ordered completion logic programs aggregates Vernon Asuncion Yin Chen b Yan Zhang Yi Zhou Artiﬁcial Intelligence Research Group AIRG School Computing Engineering Mathematics University Western Sydney Australia b Department Computer Science South China Normal University Guangzhou China r t c l e n f o b s t r c t Article history Received 7 August 2013 Received revised form 16 March 2015 Accepted 21 March 2015 Available online 25 March 2015 Keywords Knowledge representation reasoning Answer Set Programming Aggregates Firstorder logic Logic programming We consider problem translating ﬁrstorder answer set programs aggregates ﬁrstorder sentences type aggregates In particular ﬁnite structures normal logic programs convex aggregates cover monotone antimonotone aggregates aggregates appearing benchmark programs captured ﬁrstorder logic type aggregates introducing auxiliary predicates More precisely prove ﬁnite stable model normal program convex aggregates corresponding classical model enhanced ordered completion This translation suggests alternative way computing stable models kind programs We report experimental results demonstrate solver GROCv2 comparable stateoftheart answer set solvers We convex aggregates form maximal class purpose That construct normal logic program given nonconvex aggregate context prove translated ﬁrstorder sentences type aggregates NP coNP 2015 Elsevier BV All rights reserved 1 Introduction In paper consider translate ﬁrstorder Answer Set Programming ASP predominant declarative program ming paradigm area knowledge representation logic programming 3202425 ﬁrstorder logic Work direction theoretical interests practical relevances suggests alternative way implement ASP Recently Asuncion et al 2 proposed notion ordered completion ﬁrstorder sentence extra predicates ﬁrstorder normal logic programs showed stable models normal program exactly corresponding classical models ordered completion ﬁnite structures Interestingly translation arbi trary structures prohibiting extra predicates Based translation developed new ASP solver ﬁrst translates program ordered completion grounds ﬁrstorder sentence ﬁnally calls SMT solver This signiﬁcantly different previous ASP solvers ground ﬁrstorder programs directly A ﬁrst implementation shows new solver promising performs relatively Hamiltonian Circuit program particularly big instances 2 However work handle aggregates important building block modern Answer Set Programming The reason aggregates crucial answer set solving twofold Firstly enhance expressive power ASP simplify representation task For applications write simpler elegant logic Corresponding author Email address yzhouuwseduau Y Zhou httpdxdoiorg101016jartint201503007 00043702 2015 Elsevier BV All rights reserved V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 73 program aggregates instance job scheduling program 28 Secondly importantly aggregates improve eﬃciency ASP solving 19 Normally program aggregates solved faster 12 In paper consider problem extending ordered completion programs aggregates This challeng ing task programs aggregates expressive capture disjunctive logic programming 16 captured ﬁrstorder logic type aggregates providing general assumptions computational complexity theory Proposition 6 2 Hence important task draw boundary normal programs aggregates captured ﬁrstorder logic type aggregates programs For purpose extend notion convex constraints proposed Liu Truszczy nski 23 ﬁrstorder convex aggregates We class convex aggregates exactly boundary need sense Firstorder normal logic programs convex aggregates captured ﬁrstorder logic type aggregates ﬁnite structures More precisely extend notion ordered completion ﬁrstorder normal logic programs convex aggregates stable model program corresponding classical model enhanced ordered completion Given nonconvex aggregate context exists normal program context translated ﬁrstorder sentences type aggregates NP coNP In fact class convex aggregates expressive capture monotone antimonotone aggregates 23 aggregates appearing benchmark programs 5 Therefore based theoretical results able develop alternative ASP solver ﬁrstorder normal programs convex aggregates Following idea implement new ASP solver GROCv2 Our experimental results demonstrate GROCv2 comparable stateoftheart ASP solvers The paper organized follows Section 2 reviews basic concepts notations need paper Section 3 presents ordered completion logic programs aggregates proves main theorems Sec tion 4 introduces implementation ASP solver GROCv2 reports experimental results Finally Sections 5 6 discuss related work draw conclusions respectively We leave long proofs theorems Appendix A ﬂuent reading 2 Preliminaries We consider secondorder language functions equality A signature contains ﬁnite set constants ﬁnite set predicates A term variable constant A standard atom expression P t P predicate t tuple terms matches arity P An equality atom expression t1 t2 t1 t2 terms multisets We denote M M A multiset called bag pair M Ms M f Ms set M f function called multiplicity function Ms N set positive integers 1 2 3 A multiset Ms M f ﬁnite Ms ﬁnite Let M M cid3 M For convenience multiset M Ms a1 M f ai ci 1 n denoted M M M The order elements irrelevant For example b c multiset M a1 a1 ai ai cid5 cid3cid4 cid2 cid5 cid5 cid2 c1 cid3 s elements Ms M f M cid3 f We write M M Ms M cid3cid4 cn cid3cid4 ci cid2 cid3 cid3 cid3 cid3 Ms b c M f 2 M f b M f c 1 21 The syntax aggregates Aggregate crucial auxiliary building block answer set programming 12131619222328 We ﬁrst deﬁne syntax aggregates ﬁrstorder case We assume set aggregate symbols AG ﬁxed set comparison operators numbers CO cid7 Deﬁnition 1 An aggregate atom δ expression form opcid9v wQ 1y1 Q sys R1z1 Rtztcid12 cid13 t1 op AG aggregate symbol Q iyi 1 s R jz j 1 j t standard atoms equality atoms In addition Q 1y1 Q sys R1z1 Rtzt called body δ denoted Bdδ 1 Here w In case 1 simply written opcid9v Bdδcid12 cid13 t 1 2 74 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 v w tuples variables mentioned 2 v w cid13 CO comparison operator numbers t term assume variables occurring t v w For convenience use P sδ N gδ denote sets Q 1y1 Q sys R1z1 Rt zt respectively Given aggregate atom δ form 1 variable δ free variable variable v w Example 1 Let sum card aggregate symbols AG The following aggregate atoms cardcid9x P xcid12 2 sumcid9x P xcid12 5 Intuitively equivalent weight constraints 2pX2 pX X5 smodels 29 aggregate atoms count X pX 2 sum X pX 5 DLV 14 ASPCore22 cid2 An atom equality atom standard atom aggregate atom A ﬁrstorder formula aggregates formula short built atoms logical connectives usual A formula aggregate atom called classical formula paper The free variable formula deﬁned usual We use freeφ denote set free variables formula φ 22 The semantics ﬁrstorder logic aggregates As aggregate extra building block need extend standard semantics classical ﬁrstorder logic incorporating aggregates aggregates considered predeﬁned function symbols Deﬁnition 2 An aggregate context AC tuple form ACag ACco ACnum opAC 1 opAC n ACag op1 opn subset AG ACco CO set comparison operators ACnum Z set numbers aggregate symbol opi AG 1 n partial function opAC ACnum ACnum set multisets tuples Example 2 Consider aggregate context AC1 AC1ag card sum min max cardinality sum minimum maximum respectively AC1co AC1num N given multiset M a1 ak ai 1 k tuple numbers cardM deﬁned cardinality M sumM deﬁned minM undeﬁned M minimum ai1 1 k M cid7 maxM undeﬁned M maximum ai1 1 k M cid7 i1 ai13 cid6 k Furthermore deﬁne following aggregate contexts Let AC2 aggregate context identical AC1 AC2co CO AC1co cid7 Let AC3 aggregate context identical AC2 AC3num Z cid2 2 ASPCore2 currently standard ASP input language available https wwwmat unical aspcomp2013 ﬁles ASPCORE2 03b pdf 3 Given tuple ai denotes ith component 1 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 75 The aggregate context AC1 Example 2 presents common aggregate functions current ASP solvers However following example shows possible deﬁne general aggregates setting theoretically Example 3 Consider aggregate context AC4 AC4ag sumall sat sumall sat aggregate symbols AG AC4co AC4num N given multiset M a1 ak ai 1 k tuple numbers sumallM deﬁned kcid7 ai cid7 i1 j1 ai j satM 1 ϕM satisﬁable propositional logic 0 ϕM formula cid9 cid10 kcid8 cid11 xa i1 aai x1 x2 set propositional atoms cid2 Deﬁnition 3 Given signature σ extended structure A σ tuple A fA c A 1 c A l P A 1 P A m 3 A domain A denoted DomA fA total function A Z A c P 1 l interpretation constant ci 1 j m interpretation predicate P j A j An extended structure ﬁnite domain ﬁnite Note difference extended structure deﬁned structure ﬁrstorder logic partial function fA maps domain elements numbers This enables freely use variables constants aggregate functions Since aggregate functions sum deﬁned numbers arbitrary domain elements use step approach interpret aggregate atom First standard ﬁrstorder semantics map terms constants variables domain elements Then use function fA map domain elements numbers aggregate atoms deﬁned We extend function fA tuple domain elements multiset By fAc denote tuple fAc1 fAcn c c1 cn tuple By fA A denote multiset fAa1 fAak A a1 ak multiset In following extended structure simply called structure clear context Let A structure An assignment expression form xa x tuple distinct variables DomAx tuple domain elements Assignments extended terms Let t tuple terms variables x We use txa denote tuple domain elements simultaneously replacing variables x assignment xa constant c c Under aggregate context AC satisfaction relation structure A formula ϕx aggregate A atoms assignment xa deﬁned recursively follows A If ϕ P t A cid17 ϕxa iff txa P If ϕ t1 t2 A cid17 ϕxa iff t1xa t2xa If ϕ ψ A cid17 ϕxa iff A cid7cid17 ψxa If ϕ ψ ξ A cid17 ϕxa iff A cid17 ψxa A cid17 ξ xa If ϕ yψ A cid17 ϕxa iff b DomA A cid17 ψx yab Finally ϕ aggregate atom δ form 1 aggregate context AC A cid17 ϕxa iff 1 op ACag cid13 ACco 2 txa domain fA 3 multiset M fAc c M cid3 fAc deﬁned 76 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 domain opAC M cid3 set c A cid17 Bdδxwvabc b DomA w c DomA v 4 opAC A cid13 fAtya Example 4 Consider aggregate context AC2 signature σ predicate P For structure A domain b fAa 2 fAb 3 A cid17 sumcid9x P xcid12 5 A cid17 sumcid9x P xcid12 cid7 2 P P b cid2 Let AC aggregate context An aggregate op ACag polynomial problem checking opACM cid13 n polynomial time respect M multiset M number n M length M deﬁned sum length tuples M 16 AC polynomial aggregates polynomial It veriﬁed aggregate contexts Example 2 polynomial AC4 Example 3 polynomial P N P 23 The stable model semantics normal logic programs aggregates We propose stable model semantics ﬁrstorder normal logic programs aggregates A normal program aggregates program short ﬁnite set rules form α β1 βl γ1 γm 4 α standard atom βi 1 l γ j 1 j m atoms A rule form 4 called constraint α By cid11 denote set constraints program cid11 Let r rule form 4 We α head r β1 βl γ1 γm body r A variable called local variable r occurs standard atom equality atom occurs freely aggregate atom body r occur head r For convenience use Headr Bodyr denote α β1 βl γ1 γm respectively We use Posr PosAggr denote set positive atoms set positive aggregate atoms body r respectively By cid12r denote universal closure formula β1 βl γ1 γm α By cid12cid11 denote formula cid13 cid12r rcid11 The signature program cid11 denoted τ cid11 consists constants predicate symbols occurring cid11 A pred icate program said intensional occurs head rule program extensional We use Pintcid11 denote set intensional predicates cid11 Example 5 Consider following program cid111 aggregate atom r1 P x R1x r2 P x P y R2 y x r3 P x sumcid9 y P y R3x ycid12 3 Here sum aggregate symbol P intensional R1 R2 R3 extensional cid2 5 6 7 The stable model semantics program deﬁned secondorder sentence We ﬁrst introduce notations Let P Q predicates predicate variables arity We use P Q denote formula xP x Q x xQ x P x cid3 1 Let P P 1 P k P cid3 arity We use P P P cid3 P P cid3 denote formula cid3 k tuples predicates predicate variables 1 k P kcid8 i1 xP ix P cid3 ix kcid8 i1 xP cid3 ix P ix Let cid11 program Pintcid11 P 1 P n Let U U 1 Un tuple new predicates U deﬁned 1 n matches arity P Given atom ρ ρ V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 77 ρ ρ equality atom atom form P x P extensional predicate U ix ρ atom form P ix P intensional predicate opcid9v wBdδcid12 cid13 t opcid9v wBdδcid12 cid13 t ρ aggregate atom δ form 1 Bdδ Q 1 y1 Q s ys R1z1 Rtzt Let r rule form 4 constraint We use Bodyr denote formula β β l 1 universal closure formula γ1 γm r Bodyr Headr Finally SMcid11 denote following secondorder sentence cid8 cid8 cid12r UU P rcid11 r rcid11cid11 8 Deﬁnition 4 Stable model Let cid11 program AC aggregate context A structure A τ cid11 said stable model cid11 A model SMcid11 For normal programs aggregates deﬁnition SMcid11 exactly presented 2 17 For stable model semantics propositional programs aggregates alternative deﬁnitions 48101316182730 The Ferraris semantics FLP semantics recently extended ﬁrstorder case 41822 Our deﬁnition SMcid11 considered ﬁrstorder extension Ferraris semantics 1618 Nevertheless aggregate atoms occur positive bodies rules bodies aggregates contain negative atoms actually case benchmark programs semantics coincide Example 6 Example 5 continued Consider aggregate context AC1 Example 2 structures M1 M2 M3 τ cid111 1 2 3 DomMi b c d fMi 1 fMi b 2 fMi c 3 fMi d 4 Mi aa ac db dc R 1 aa bc R b R Mi 2 Mi 3 M1 b c P M2 b c d P M3 b c d P M1 stable model cid111 model cid12r3 To note M1 cid17 sumcid9 y P y R3x yxd M1 cid7cid17 P xxd cid13 Both M2 M3 models order sentence 8 Indeed let U M3 cid7cid17 U U P rcid111 cid13 rcid111 cid3 b c d P r cid12r M3 stable model cid111 M3 model second cid3 M3 Then M3 cid17 U P U U cid3 M3 cid17 U U cid13 r rcid111 It veriﬁed M2 stable model cid111 Roughly speaking M2 obtained follows P b derived fact R1b rule r1 P c derived facts P b R2b c rule r3 P d derived rule r3 noticing M3 cid17 sumcid9 y P y R3x ycid12 3xd P derived r2 r3 assuming P cid2 3 Ordered completion normal logic programs aggregates Ordered completion introduced Asuncion et al 2 normal logic program aggregates modiﬁcation Clarks completion 7 adding auxiliary predicates capture derivation order programs evaluation It showed ﬁnite structures stable models normal logic program exactly corresponding classical models ordered completion From theoretical point view ordered completion makes important contribution understanding ﬁrstorder answer set programming Firstly shows stable model semantics captured Clarks completion plus derivation order Secondly clariﬁes relationship ﬁrstorder normal ASP ﬁrstorder logic More precisely 78 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 normal answer set program captured ﬁrstorder sentence new predicates ﬁnite structures Interestingly result hold arbitrary structures new predicate symbol 2 In addition ordered completion relevant practical point view It initiates new direction developing alternative ASP solver ﬁrst translating normal logic program ordered completion working ﬁnding model ﬁrstorder sentence A ﬁrst implementation shows new approach promising performs good Hamiltonian Circuit program 25 especially large instances However ordered completion hardly Hamiltonian Circuit program handle aggregates crucial building block widely applications ASP Extending ordered completion dealing aggregates easy task First aggregate atoms logic program highly interacted rest parts Hence naive extension ordered completion simply treating aggregate atoms extensional atoms work Another observation computational complexity point view In propositional case shown check ing existence stable models normal program aggregates cid14 P 2 complete Ferraris semantics FLP semantics 1116 lies higher complexity level task normal programs ag gregates Together known results ﬁnite model theory probably suggests general ﬁrstorder normal programs arbitrary aggregates captured ﬁrstorder logic type aggregates In paper shall case Nevertheless observed normal programs type aggregate atoms complexity normal programs aggregates 16 This means simply complexity point view possible capture class programs ﬁrstorder logic type aggregate atoms In fact important classes aggregate atoms discussed literature 413162731 monotone antimonotone aggregate atoms Deﬁnition 5 Let AC aggregate context op ACag aggregate symbol cid13 ACco comparison operator We op monotone respect cid13 multisets M1 M2 M1 M2 M1 domain opAC n ACnum opACM1 cid13 n opACM2 cid13 n M2 domain opAC The deﬁnition antimonotone similar M1 M2 replaced M2 M1 Consider aggregate symbols card sum aggregate context AC1 Example 2 They monotone antimonotone respect comparison symbols monotone antimonotone respect As shall paper normal logic programs types aggregates captured ﬁrstorder logic type aggregates However powerful capture For instance commonly aggregate form sumM n monotone antimonotone expressed conjunction monotone antimonotone aggregates sumM n 1 sumM n 1 Therefore normal logic programs aggregate type sumM n expressed ﬁrstorder logic aggregate Hence important task draw boundary That exist class aggregates ﬁrstorder normal programs type aggregates captured ﬁrstorder logic type aggregates normal programs aggregates class For purpose extend Liu Truszczy nskis notion convex constraints 23 ﬁrstorder convex aggregates exactly boundary need That ﬁrstorder normal logic programs convex aggregates captured ﬁrstorder logic type aggregates On contrary nonconvex aggregates construct normal program aggregate captured ﬁrstorder logic type aggregates providing general assumptions computational complexity theory Deﬁnition 6 Let AC aggregate context op ACag aggregate symbol cid13 ACco comparison operator Then op convex respect cid13 exist ﬁnite multisets tuples arities4 M1 M2 M3 n Z opACM1 cid13 n opACM3 cid13 n holds opACM2 cid13 n hold An aggregate context AC convex aggregate symbol op ACag comparison operator cid13 ACco op convex respect cid13 Example 7 Consider aggregate contexts Example 2 AC3 nonconvex sum nonconvex respect As example sumAC3 1 1 0 sumAC3 0 hold sumAC3 1 0 hold 4 That t1 t2 M1 M2 M3 t1 t2 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 79 If restrict nonnegative numbers sum convex respect AC2 nonconvex sum nonconvex respect cid7 As example sumAC2 1 2 cid7 1 sumAC2 cid7 1 hold sumAC2 1 cid7 1 hold It veriﬁed AC1 convex Note aggregates card sum convex respect monotone antimonotone cid2 In fact monotone antimonotone aggregates subclasses convex aggregates Proposition 1 Let AC aggregate context op ACag aggregate symbol cid13 ACco comparison operator If op antimonotone respect cid13 op convex respect cid13 Proof It suﬃces op nonconvex respect cid13 monotone antimonotone respect cid13 If op nonconvex respect cid13 exist multisets M1 M2 M3 n Z opACM1 cid13 n opACM3 cid13 n hold opACM2 cid13 n hold Since M1 M2 opACM1 cid13 n holds opACM2 cid13 n hold op antimonotone Similarly M2 M3 opACM3 cid13 n holds opACM1 cid13 n hold op monotone cid2 31 Ordered completion Now deﬁne ordered completion normal logic programs aggregates Let σ signature By σ denote signature σ set new predicates P Q P Q σ intensional predicates arity P Q sum arities P Q 5 The ordered completion program cid11 deﬁned formula signature τ cid11 Let cid11 program Then Transcid11 denote formula cid8 P Q RPintcid11 xyzP Q xy Q R yz PR xz Also given predicates P Q use cid2P x Q y denote formula P Q xy Q P yx Deﬁnition 7 Ordered completion aggregates Let cid11 program Then modiﬁed completion cid11 denoted MCompcid11 formula cid14 cid12cid11 cid8 x P Pintcid11 P x cid10 cid15 y rcid11cid11 HeadrP x Bodyr Pos cid2r P x PosAgg cid2r P x cid16cid17 9 cid13 cid12cid11 cid12r Pos cid2r P x formula rcid11 cid8 cid2Q y P x Q yPosrPosAggr Q Pintcid11 PosAgg cid2r P x formula cid8 opcid9v wBdδ P cid2sδ P xcid12 cid13 t δPosAggr 5 Note P Q predicate 80 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 Ps cid2δ P x shorthand cid8 Q cid2yi P x 1is Q Pintcid11 Finally ordered completion cid11 denoted OCcid11 formula MCompcid11 Transcid11 Let closer look Deﬁnition 7 First nonaggregate atoms Bodyr treat way original deﬁnition ordered completion 2 That positive nonaggregate atom Posr introduce comparison atoms formula Pos cid2r P x However negative nonaggregate atoms For aggregate atoms occurring Bodyr similar nonaggregate atoms distinguish negative positive occurrences For negative occurrences introduce comparison atoms aggregates How positive occurrences need introduce comparison assertions PosAgg cid2r P x PosAgg cid2r P x denotes formula cid8 opcid9v wBdδ P cid2sδ P xcid12 cid13 t δPosAggr simply introduces comparison atoms positive body Psδ aggregate atom PosAggr formulas form Ps cid2δ P x The reason introduce comparison atoms positive aggregates need track derivation order implied stable model semantics Example 8 Example 5 continued The ordered completion cid111 denoted OCcid111 conjunction Transcid111 following sentences xR1x P x x yP y R2 y x P x xsumcid9 y P y R3x ycid12 3 P x xP x R1x yP y R2 y x cid2P y P x sumcid9 y P y R3x ycid12 3 sumcid9 y P y R3x y cid2P y P xcid12 3 10 11 12 13 Now consider aggregate context AC1 Example 2 structures M1 M2 M3 Example 6 M1 model 12 So expanded model OCcid111 Both M2 M3 models 1012 Let Mcid3 2 structure expanded M2 additional interpretation P P Mcid3 2 P P bc bd cd It veriﬁed Mcid3 2 Mcid3 2 Mcid3 2 Mcid3 2 cid17 Transcid111 cid17 R1xxb cid17 P y R2 y x cid2P y P xxybc cid17 sumcid9 y P y R3x ycid12 3 sumcid9 y P y R3x y cid2P y P xcid12 3xd So Mcid3 Let Mcid3 2 model OCcid111 3 model Transcid111 expanded M3 Now Mcid3 3 model OCcid111 Indeed Mcid3 3 cid7cid17 cid2P y P xxyaa V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 81 Mcid3 3 Mcid3 3 cid7cid17 P y R2 y x cid2P y P xxyaa cid7cid17 sumcid9 y P y R3x y cid2P y P xcid12 3xa Therefore Mcid3 3 model 13 cid2 In general following theorem Theorem 1 Main theorem Let AC convex aggregate context cid11 program A ﬁnite structure τ cid11 Then A stable model cid11 AC A expanded model OCcid11 32 The proof Theorem 1 To prove Theorem 1 need use notion externally supported set 6 Roughly speaking set ground atoms externally supported exists ground atom set associated rule supports atom atom head ground rule positive body satisﬁed external ground atoms ground atoms set Then provide lemma showing structure stable model program model program subset ground atoms included structure externally supported Then based lemma ﬁnally proof main theorem Let cid11 program A structure signature σ τ cid11 σ Then ground atom expression denote form P P predicate tuple domain elements matching arity P By Pintcid11A set ground atoms P P A P Pintcid11 Deﬁnition 8 Externally supported set Let AC aggregate context cid11 program A structure σ τ cid11 σ A set ground atoms S Pintcid11A externally supported AC cid11 A exists ground atom P S rule r form P x Bodyr local variables yr assignment form xyrabr A cid17 Bodyrxyrabr Posr PosAggrxyrabr S For aggregate atoms δ PosAggr form 1 opAC fAcv A cid17 Bdδα Psδα S cid13 fAtxyrabr α assignment form xyr wvabr cw cv cw cv tuples domain elements Lemma 1 6 Let AC aggregate context cid11 program A structure τ cid11 Then A stable model cid11 A cid17 cid12cid11 S Pintcid11A externally supported Proof Suppose Pintcid11 P 1 P n Let U U 1 Un set new predicates 1 n U arity P Since A cid17 SMcid11 A cid17 cid12cid11 It suﬃces set S Pintcid11A externally supported We externally supported We construct prove contradiction Assume exists set S Pintcid11A structure U τ cid11 U follows DomU DomA fU fA identical constant c τ cid11 c P predicate P τ cid11 P ia S 1 n U U c A U P U P A A Clearly U cid17 U Pintcid11 Since A cid17 SMcid11 exists rule r form 4 assignment xyrabr xyrabr Then U cid17 Bodyrxyrabr U cid7cid17 Headrxyrabr It follows A cid17 Bodyrxyrabr U cid7cid17 r A cid17 Headrxyrabr So Headrxyrabr S As assume S externally supported Deﬁnition 8 1 exists atom β Posr PosAggr βxyrabr S 2 exists aggregate atom δ form 1 6 Note lemma holds assumption convex aggregate contexts 82 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 O P AC fAcv A cid17 Bdδxyrwvabr cw cv P sδxyr wvabr cw cv S w c v DomA c w DomA v cid13 fAtxyrabr hold In cases U cid7cid17 Bodyrxyrabr contradiction 1 We βxyrabr S U cid7cid17 βxyrabr It follows U cid7cid17 Bodyrxyrabr 2 By construction U cw DomAw cv DomAv U cid17 Bdδ xyr wvabrcw cv A cid17 Bdδxyr wvabr cw cv Psδxyr wvabr cw cv S Therefore fU cv U cid17 Bdδ cv DomA fAcv A cid17 Bdδxyr wvabr cw cv Psδxyr wvabr cw cv S xyr wvabr cw cv cw DomA w v cw DomA w cv DomA v By 14 opAC fU cv U cid17 Bdδ cw DomA xyr wvabr cw cv w cv DomA v cid13 fU txyrabr hold Therefore U cid7cid17 opcid9v wBdδ U cid7cid17 Bodyrxyrabr cid12 cid13 txyrabr 14 15 Since A cid17 cid12cid11 suﬃces A cid17 UU Pintcid11 cid8 r rcid11cid11 cid8 Again prove contradiction Otherwise let U structure τ cid11 U U expansion A U cid17 U Pintcid11 r 16 rcid11cid11 U Let S P P form 4 assignment xyrabr A U P Pintcid11 By 16 S Since S externally supported exist rule r Headrxyrabr S A cid17 Bodyrxyrabr Posr PosAggrxyrabr S For aggregate atoms δ PosAggr form 1 opAC fAcv A cid17 Bdδxyr wvabr cw cv P sδxyr wvabr cw cv S cv DomA v cid13 fAtxyrabr cw DomA w 17 By construction U U cid17 Bodyrxyrabr negative atoms U cid17 γ jxyrabr 1 j m positive nonaggregate atoms β Posr PosAggr U cid17 βxyrabr positive aggregate atoms δ PosAggr opAC fU cv U cid17 Bdδxyr wvabr cw cv cw DomA cv DomA w v cid13 fU txyr wvabr cw cv V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 83 opAC fU cv U cid17 Bdδ xyr wvabr cw cv cv DomA w cw DomA v cid13 fU txyrabr We U cid7cid17 Headrxyrabr This contradiction U cid17 r proof cid2 xyrabr 16 This completes Now ready prove main theorem Proof By Lemma 1 set S Pintcid11A lm set ground atoms Pintcid11A S externally supported We ﬁrst deﬁne level mapping denoted numbers Consider following procedure I Let 0 T Pintcid11A II If T quit Otherwise T externally supported exist ground atom P T rule r set atoms levels undeﬁned form P x Bodyr local variables yr assignment form xyr abr A cid17 Bodyrxyrabr Posr PosAggrxyrabr S For aggregate atoms δ PosAggr form 1 opAC fAcv A cid17 Bdδα Psδα T cid13 fAtxyrabr α assignment form xyr wvabr cw cv cw cv tuples domain elements III Let lmP 1 T T P IV Go II S ﬁnite procedure deﬁned terminates T Based ranking expand A Acid3 signature τ cid11 σ Acid3 P Q ab lmP lmQ b P Q Pintcid11 Now remains Acid3 cid17 OCcid11 By deﬁnition Acid3 suﬃces P Pintcid11A assignment form xyr abr P Headrxyrabr Acid3 cid17 cid12cid11 Transcid11 It exist rule r form P x Bodyr local variables yr Acid3 cid17 P x cid18 cid19 Bodyr Pos cid2r P x PosAgg cid2r P x xyrabr Actually rule r assignment xyr abr II procedure exactly need Since Acid3 cid17 OCcid11 Acid3 cid17 cid12cid11 Therefore reduct Acid3 comparison predicates It remains S Pintcid11Acid3 S Pintcid11Acid3 τ cid11 model cid12cid11 cid12cid11 mentions S externally supported Otherwise exists externally supported In following construct inﬁnite sequence ground atoms P 1a1 P iai P iai S 1 ii Acid3 cid17P i1 P ai1ai P P i1 aiai1 1 iii P iai cid7 P ja j cid7 j This contradiction S ﬁnite By Acid3 cid17 Transcid11 need consider ii iii conse quence ii We construct sequence induction Assume P 1a1 ground atom S If P 1a1 P iai ﬁnd P i1ai1 follows Since Acid3 cid17 P iai Acid3 model OCcid11 exists rule P ix Bodyr local variables yr assignment xyraibr Acid3 cid17 Bodyr Pos cid2r P x PosAgg cid2r P xxyraibr 18 By assumption S externally supported Consider rule r assignment xyraibr atom β Posr PosAggr βxyraibr S aggregate atom δ form 1 opACM1 cid13 fAtxyraibr holds 19 21 22 23 84 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 M1 fAcv A cid17 Bdδxyrwvaibr cw cv Psδxyrwvaibr cw cv S w cw DomA cv DomA v 20 For ﬁrst case let P i1ai1 βxyraibr Then holds trivially ii holds 18 For second case let M2 M3 multisets M2 fAcv A cid17 Bdδxyr wvaibr cw cv cw DomA cv DomA w v M3 fAcv A cid17 Bdδ P cid2sδ P xxyr wvaibr cw cv w cw DomA cv DomA v By 18 opACM2 cid13 fAtxyraibr opACM3 cid13 fAtxyraibr 24 By 20 21 22 M1 M2 M3 M2 Since AC convex aggregate context M3 cid3 M1 19 x P Q 23 24 So exists atom Q x cid3xyr wvaibr cw cv Let P i1xi1 Q x xx This completes proof cid2 cid3 Psδ Q x cid3xyr wvaibr cw cv It veriﬁed ii hold cid3xyr wvaibr cw cv S Acid3 cid17Q P x cid3 33 A negative result nonconvex aggregates Theorem 1 shows stable models normal program convex aggregates captured ordered completion However result hold nonconvex aggregates Consider following example Example 9 Let cid112 following program single rule r1 P x sumcid9 y P y R1x y zcid12 cid7 z R2x z Here P intensional predicate R1 R2 extensional predicates Now let M structure τ cid112 R DomM b c fMa 2 fMb 3 fMc 4 M 1 M 2 M b In addition let Mcid3 aab abb aac abc baa bba caa cca ab ac ba ca τ cid112 R P structure expanded M P P ba We nonconvex aggregate context AC2 Example 2 Mcid3 stable model cid112 On OCcid112 conjunction Transcid112 following sentences model OCcid112 M xzR2x z sumcid9 y P y R1x y zcid12 cid7 z P x xP x zR2x z sumcid9 y P y R1x y zcid12 cid7 z sumcid9 y P y R1x y z cid2P y P xcid12 cid7 z It obvious Mcid3 cid17 Transcid112 To Mcid3 model 25 suﬃces verify 25 26 Mcid3 cid17 sumcid9 y P y R1x y zcid12 cid7 zxzab Mcid3 cid17 sumcid9 y P y R1x y zcid12 cid7 zxzac Mcid3 cid17 sumcid9 y P y R1x y zcid12 cid7 zxzba Mcid3 cid17 sumcid9 y P y R1x y zcid12 cid7 zxzca V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 85 To Mcid3 model 26 suﬃces verify Mcid3 cid17 sumcid9 y P y R1x y zcid12 cid7 z sumcid9 y P y R1x y z cid2P y P xcid12 cid7 zxzba Mcid3 cid17 sumcid9 y P y R1x y zcid12 cid7 z sumcid9 y P y R1x y z cid2P y P xcid12 cid7 zxzac On M stable cid112 suﬃces M model 8 Indeed let cid3 P 1 cid3 Hence M cid7cid17 U U P r Then M cid17 U P U U cid3 M cid17 r 1 cid2 U U M U In fact convex aggregate maximal subclass task That given nonconvex aggregate context construct normal program aggregates captured ﬁrstorder logic type aggregates providing general assumptions complexity theory Actually prove stronger result normal programs given nonconvex aggregate context able capture expressive power disjunctive programs aggregates First introduce background A disjunctive program aggregates disjunctive program ﬁnite set disjunctive rules form cid10 α1 αk β1 βl γ1 γm 27 αi 1 k standard atoms βi 1 l γ j 1 j m atoms The stable models disjunctive program deﬁned models SMcid11 SMcid11 8 disjunctive rule r form 27 r universal closure formula Bodyr α 28 1ik Our negative result inspired Ferraris work 16 In order obtain complexity results propositional normal programs arbitrary aggregate atom Ferraris proved following facts Fact 1 Every propositional disjunctive rule form a1 ak b1 bl c1 cm equivalently transformed set rules implications bodies follows a1 a1 a1 ak a1 b1 bl c1 cm a2 a1 a2 ak a2 b1 bl c1 cm ak a1 ak ak ak b1 bl c1 cm Fact 2 An implication p q strongly equivalent following aggregate atom sumcid9p 1 q 1cid12 0 29 30 expressions said strongly equivalent Answer Set Programming replacing logic program change answer sets Therefore propositional disjunctive program aggregate atom equivalently transformed propo sitional normal program aggregates similar 30 As consequence complexity checking existence answer sets propositional normal program arbitrary aggregate atom cid14 P 2 complete higher normal program monotone antimonotone aggregate atom NPcomplete We extend Ferraris result essential way sense procedure applied nonconvex aggregate context That given nonconvex aggregate context use simulate implications simulate disjunctive rules The proof result ﬁrstorder case technical tedious We provide sketch proof leave long detailed proof Appendix A Lemma 2 Let AC polynomial nonconvex aggregate context Then ﬁnite structures disjunctive program cid15D aggregates polynomially translated normal program cid15N aggregates AC Proof Sketch First AC nonconvex aggregate context exist multisets M1 M2 M3 opM1 cid13 N opM3 cid13 N hold opM1 cid13 N hold op ACag aggregate symbol cid13 ACop comparison operator N ACnum number Let 86 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 M1 m1 mN1 M2 M1 mN11 mN2 M3 M2 mN21 mN3 N1 N2 N3 sizes M1 M2 M3 respectively 0 N1 N2 N3 Then introduce new predicates constants build program cid15N Let Q D1 Q D N3 N3 new predi cates The program cid15N contains rules constraints M stable model cid15N M cid17 Q D idi mi di 1 N3 tuple new constants In addition let Q M1 Q M2 Q M3 fMd new predicates With help Q D1 Q D N3 program cid15N built M stable model cid15N M M cid17 opcid9x Q M1xcid12 cid13 cn M cid7cid17 opcid9x Q M2xcid12 cid13 cn M cid17 opcid9x Q M3xcid12 cid13 cn cn new constant N Note M exist aggregate context convex Furthermore rule r form 27 atoms P ivi P jv j 1 j k Headr new predicate Q ri j introduced With carefully deﬁned rules constraints cid15N new predicates introduced aggregate opcid9x Q ri jx vi v jcid12 cid13 cn behaves exactly implication P jvi P ivi This similar Fact 2 Ferraris work 16 Now present main idea translation The normal program aggregates cid15N parts rules cid15N AGG DEF CST AGG set normal rules aggregates simulate disjunctive rules DEF CST sets rules deﬁne new predicates rule form 27 Then r translated k rules cid15N form Let r cid15D cid15D αi β1 βl γ1 γm opcid9x Q ri1x vi v1cid12 cid13 cn opcid9x Q rikx vi vkcid12 cid13 cn NotLitsNewVarr 31 1 k k number atoms head r P 1v1 P kvk atoms head r x tuple distinct new variables NotLitsNewVarr denotes set negative atoms form x c x variable r c new constant τ cid15D Intuitively rules deﬁned play roles ﬁrstorder case rules 29 propositional case This similar Fact 1 Ferraris work 16 Finally structure MD τ cid15D stable model cid15D structure MN τ cid15N MN stable model cid15N MD MN agree interpretations predicates constants τ cid15D cid2 Our negative result follows Lemma 2 disjunctive programs aggregates capture complexity class cid14 P 2 9 ﬁrstorder logic new predicates capture complexity class NP 15 Theorem 2 Let AC polynomial nonconvex aggregate context Then exists normal program aggregates cid11 translated ﬁrstorder sentences extra predicates ﬁnite structures aggregate context AC NP coNP Proof By Lemma 2 following program cid113uncolor translated normal program aggregates cid113uncolor D N disjunctive program aggregates 3uncolorability V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 87 Rx Gx Bx NC Ex y Rx R y NC Ex y Gx G y NC Ex y Bx B y Rx NC Gx NC Bx NC NC NC Assume NP cid7 coNP As 3uncolorability coNPcomplete problem Fagins theorem 15 captured existential secondorder logic ﬁnite structures Note adding polynomial aggregate atoms ﬁrstorder logic existential secondorder logic increase expressive power ﬁnite model theory So 3uncolorability captured existential secondorder logic polynomial aggregates Hence translated ﬁrstorder sentences extra predicates ﬁnite structures polynomial aggregate context AC cid2 4 Implementation experimental results Based Theorem 1 implemented new called GROCv2 GRounder Ordered Completion Version 2 computing answer sets ﬁrstorder normal logic programs convex aggregates This work extension prototype implementation GROC 2 handle normal programs aggregates Following basic ideas GROC GROCv2 computes answer sets normal program convex aggregates extensional database follows 1 First GROCv2 translates program enhanced ordered completion Deﬁnition 7 2 Then GROCv2 grounds ordered completion propositional theories modular theories dealing comparison predicates based extensional database 3 Finally GROCv2 calls SMT solver compute classical model propositional theories corresponding answer set original program extensional database according Theorem 1 Note signiﬁcantly different traditional ASP solvers ground logic programs directly propo sitional programs There potential beneﬁts First classical ﬁrstorder semantics simpler stable model semantics Therefore solving techniques heuristic methods simpliﬁcation techniques applied Secondly results grounding GROCv2 propositional theories normally solved easily propositional programs Thirdly Step 1 polynomial translation oﬄine Moreover traditional techniques simplify ﬁrstorder formula Finally Step 3 calls SMT solver black box Hence improved new advances SATSMT community The main disadvantage GROCv2 number new predicates comparison predicates intro duced potentially result bigger grounding theory In principle certainly case That ordered completion needs introduce n2 number new predicates n number intensional predicates pro gram However practice actual cost benchmark problems One reason need introduce comparison predicates predicates strongly connected component predicate pendency graph This signiﬁcantly reduce number new predicates introduced For instance traveling salesman problem need introduce 1 instead 9 comparison predicate Also note use SMT solvers Step 3 instead SAT solvers GROCv2 The reason SMT solvers eﬃcient dealing comparison atoms aggregates In principle use SAT solver instead The key GROCv2 Step 2 grounder transforms ordered completion extensional database propositional theories modular theories aggregates For purpose ﬁrst introduce background propositional SMT Satisﬁability Modulo Theories aggregates In general propositional SMT formulas classical propositional formulas enhanced modular theory express components easily handled propositional logic instance 3x y 10 However dealing comparison atoms mentioned paper need simple modular theory compare values numbers mapped propositional atoms Deﬁnition 9 Let D set propositional atoms A propositional SMT formula aggregates SMT formula short D deﬁned φ cid27 α α1 α2 opcid9c1 φ1 ck φkcid12 cid13 c φ1 φ2 φ1 32 α α1 α2 D op AG aggregate symbol cid13 CO comparison symbol c1 ck Z integer constants φ1 φk SMT formulas 88 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 The semantics SMT formulas similar propositional formulas Let I D set propositional atoms F function D Z Given aggregate context AC satisfaction relation pair I F SMT formula φ denoted I F cid17AC φ simply I F cid17 φ AC clear context deﬁned I F cid17AC cid27 I F cid17AC α α atom α I I F cid17AC α1 α2 F α1 F α2 I F cid17AC opcid9c1 φ1 ck φkcid12 cid13 c op ACag cid13 ACco M domain opAC opACM cid13 c M ci I F cid17AC φi 1 k I F cid17AC φ1 φ2 I F cid17AC φ1 I F cid17AC φ2 I F cid17AC φ1 case I F cid17AC φ1 A set propositional atoms I D model φ exists function F D Z I F cid17 φ Now able ground ﬁrstorder formula aggregates SMT formulas deﬁned given domain subset signatures contain constants set predicates σ cid3 Let σ σ cid3 σ Let A structure σ cid3 By DA denote set DA P P Pint DomAn n arity P Let cid16 ﬁrstorder formula aggregates σ xa respect A denoted GRAcid16 ya SMT formula deﬁned recursively follows ya assignment freecid16 y The grounding cid16 cid27 cid16 α equality atom standard atom form P t P predicate σ cid3 cid27 cid16 α equality atom standard atom form P t P predicate σ cid3 A cid17 αya A cid7cid17 αya P tya cid16 P t standard atom P predicate σ σ cid3 P t1ya Q t2ya cid16 P Q t1t2 P Q comparison predicate σ opcid9M cid12 cid13 fAtya cid16 δ aggregate atom form 1 fAc GRAwBdδ yvac c M cid3 M fAc deﬁned cid3 c A cid17 Bdδywvabc b DomA w M c DomA v GRAcid161 ya cid16 form cid161 GRAcid161 ya GRAcid162 ya cid16 form cid161 cid162 GRA aDomA cid161 ya ya cid16 form ycid161 cid13 33 If cid16 formula free variables grounding cid16 respect A simply written GRAcid16 The following theorem shows compute models ordered completions grounding Theorem 3 Let cid11 program Ae ﬁnite structure τextcid11 Let A structure τ cid11 A cid17 Transcid11 Then A cid17 OCcid11 iff IA cid17 GRAe OCcid11 expansion Ae IA P P Pintcid11 P A Proof Let P Q b Rc elements IA Since A cid17 Transcid11 A cid17P Q xy Q R yz PR xzxyzabc Therefore exists function FA IA Z FAP cid7 FAQ b P Q b different FAP FAQ b A cid17P Q xyxyab It suﬃces prove following result Let cid16 formula τ cid11 GRAe cid16 ya ya assignment freecid16 y Then A cid17 cid16ya IA FA cid17 We prove induction structure cid16 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 89 It straightforward A cid17 cid27 IA FA cid17 GRAe cid27 A cid17 P tya IA FA cid17 GRAe P t ya P τextcid11 For intensional predicate P τintcid11 A cid17 P tya IA cid17 GRAe P t ya noticing P IA P A tuple matches arity P For comparison atom P Q t1t2 A cid17P Q t1t2ya freet1t2 y F AP t1ya F AQ t2ya IA F A cid17 P t1ya Q t2ya IA F A cid17 GRAe cid16 If cid16 δ aggregate atom form 1 freecid16 y A cid17 δya IA FA cid17 GRAe δ ya Consider following set multiset cid3 c A cid17 Bdδywvabc b DomA M fAc GRAwBdδ yvac c M w v c DomA cid3 fAc deﬁned M M1 fAc c M M2 c c φ M We M1 M2 noticing cid3 fAc deﬁned I F cid17AC φ 34 35 36 37 A cid17 Bdδywvabc A cid17 wBdδyvac IA F A cid17 GRAwBdδ yvac Hence A cid17 δya IA FA cid17 GRAe δ ya If cid16 form cid161 cid161 cid162 xcid161 straightforward A cid17 cid16ya IA FA cid17 GRAe cid16 ya cid2 Based Theorem 3 implemented new solver GROCv2 Now report experimental results We use Z3 version 4327 GROCv2 underlying SMT solver We compare approach GROCv2 Z3 stateoftheart ASP solvers DLV version 4218 CLASP version 3009 CMODELS version 38510 We use GRINGO version 30511 grounder solvers CLASP CMODELS The reason choose CLASP DLV CMODELS ﬁrst representative ASP solvers based conﬂict analysis representative solver based loop formulas We mainly interested nontight programs tight programs ordered completion Clarks completion In paper consider benchmark programs boundedtraveling salesman problem Nurikabe puzzle weightbounded dominating set problem Tables 1 2 report results bounded traveling salesman program Here Table 1 contains results randomly generated instances Table 2 contains results taken ASPARAGUS benchmark suite12 For ran domly generated instances rand_x_ y_i represents random graph x number nodes y edges instance We set timeouts 100000 s denoted tables Note include grounding time CLASP CMODELS For clarity pick best solver instance highlighted bold fonts From Tables 1 2 observed GROCv2 Z3 GRINGO CLASP outperform DLV GRINGO CMODELS cases bounded traveling salesman program previous solvers comparable Interestingly randomly generated instances GROCv2 Z3 advantage GRINGO CLASP big problem instances 7 http z3 codeplex com 8 http wwwdlvsystem com 9 http potassco sourceforge net 10 http wwwcs utexas edu users tag cmodels html 11 http potassco sourceforge net 12 http asparagus cs unipotsdam instanceclass id 34 90 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 Table 1 Boundedtraveling salesman randomly generated GROCv2 Z3 Instances rand_50_300_1 rand_50_300_2 rand_50_300_3 rand_50_300_4 rand_50_300_5 rand_50_300_6 rand_50_300_7 rand_50_300_8 rand_50_300_9 rand_50_300_10 rand_60_350_1 rand_60_350_2 rand_60_350_3 rand_60_350_4 rand_60_350_5 rand_60_350_6 rand_60_350_7 rand_60_350_8 rand_60_350_9 rand_60_350_10 rand_70_400_1 rand_70_400_2 rand_70_400_3 rand_70_400_4 rand_70_400_5 rand_70_400_6 rand_70_400_7 rand_70_400_8 rand_70_400_9 rand_70_400_10 10923 SAT 28017 SAT 003 UNSAT 1281 SAT 3871 SAT 9623 SAT 003 UNSAT 048 SAT 8949 SAT 003 UNSAT 079 SAT 3235 SAT 10961 SAT 3439 SAT 088 SAT 48307 SAT 003 UNSAT 003 UNSAT 801 SAT 12384 SAT 65851 SAT 11339 SAT 28180 SAT 003 UNSAT 4330 SAT 1702 SAT 42407 SAT 8785 SAT Table 2 Boundedtraveling salesman ASPARAGUS website GROCv2 Z3 Instances dom_rand_70_300_x_3 rand_70_300_x_0 rand_70_300_x_3 rand_70_300_x_4 rand_70_300_x_5 rand_70_300_x_7 rand_70_300_x_8 rand_70_300_x_9 rand_70_300_x_11 rand_70_300_x_12 rand_70_300_x_14 rand_80_340_y_0 rand_80_340_y_4 rand_80_340_y_10 rand_80_340_y_11 rand_80_340_y_13 rand_80_340_y_15 rand_80_340_y_16 rand_80_340_y_17 rand_80_340_y_18 53323 UNSAT 43849 UNSAT 003 UNSAT 006 SAT 003 UNSAT 003 UNSAT 003 UNSAT 003 UNSAT 002 UNSAT 004 SAT 003 UNSAT 003 UNSAT 003 UNSAT 003 UNSAT 003 UNSAT 003 UNSAT 003 UNSAT 003 UNSAT CLASP 995 SAT 001 UNSAT 12542 SAT 13288 SAT 001 UNSAT 413 SAT 31593 SAT 001 UNSAT 1885 SAT 14003 SAT 23668 SAT 7691 SAT 7970 SAT 001 UNSAT 001 UNSAT 1017 SAT 10570 SAT 34013 SAT 957 SAT 001 UNSAT 361151 SAT CLASP 69024 UNSAT 63540 UNSAT 002 UNSAT 001 SAT 001 UNSAT 001 UNSAT 001 UNSAT 001 UNSAT 001 UNSAT 002 SAT 002 UNSAT 001 UNSAT 001 UNSAT 001 UNSAT 001 UNSAT 002 UNSAT 002 UNSAT 001 UNSAT DLV 004 UNSAT 005 UNSAT 63211 SAT 001 UNSAT 001 UNSAT 001 UNSAT 11968 SAT 001 UNSAT DLV 001 UNSAT 010 SAT 001 UNSAT 002 UNSAT 001 UNSAT 001 UNSAT 001 UNSAT 002 UNSAT 002 UNSAT 001 UNSAT 002 UNSAT 002 UNSAT 002 UNSAT 001 UNSAT 001 UNSAT CMODELS 001 UNSAT 001 UNSAT 3589 SAT 004 UNSAT 005 UNSAT 005 UNSAT 006 UNSAT CMODELS 001 UNSAT 8732 SAT 004 UNSAT 005 UNSAT 005 UNSAT 004 UNSAT 004 UNSAT 9242 SAT 005 UNSAT 006 UNSAT 006 UNSAT 006 UNSAT 006 UNSAT 005 UNSAT 004 UNSAT 004 UNSAT Table 3 reports experimental results Nurikabe puzzle Here omit results DLV return correct answers One obtain similar conclusion program That GROCv2 Z3 GRINGO CLASP slightly better GRINGO CMODELS previous comparable Again randomly generated instances bigger problem better GROCv2 Z3 performs comparison GRINGO CLASP Table 4 reports experiments weightbounded dominating set program instances ASPARAGUS benchmark suites13 On program GRINGO CLASP clear winner In addition GROCv2 Z3 performs slightly worse DLV comparable GRINGO CMODELS 13 http asparagus cs unipotsdam instanceclass id 33 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 91 Table 3 Nurikabe hand coded randomly generated Instances puzzle_10_10_1 puzzle_10_10_2 puzzle_10_10_3 puzzle_10_10_4 puzzle_10_10_5 puzzle_10_10_6 puzzle_10_10_7 puzzle_12_12_1 puzzle_12_12_2 puzzle_12_12_3 puzzle_12_12_4 rand_10_10_n5_1 rand_10_10_n5_2 rand_10_10_n5_3 rand_10_10_n5_4 rand_10_10_n5_5 rand_10_10_n5_6 rand_10_10_n5_7 rand_10_10_n5_8 rand_10_10_n5_9 rand_10_10_n5_10 rand_10_10_n6_1 rand_10_10_n6_2 rand_10_10_n6_3 rand_10_10_n6_4 rand_10_10_n6_5 rand_10_10_n6_6 rand_10_10_n6_7 rand_10_10_n6_8 rand_10_10_n6_9 rand_10_10_n6_10 rand_12_12_n7_1 rand_12_12_n7_2 rand_12_12_n7_3 rand_12_12_n7_4 rand_12_12_n7_5 rand_12_12_n7_6 rand_12_12_n7_7 rand_12_12_n7_8 rand_12_12_n7_9 rand_12_12_n7_10 GROCv2 Z3 2084 UNSAT 3591 SAT 2084 SAT 2508 SAT 1572 SAT 1162 SAT 1545 SAT 2070 SAT 2529 SAT 5881 SAT 009 UNSAT 9022 UNSAT 13127 UNSAT 5474 UNSAT 15376 UNSAT 1883 UNSAT 005 UNSAT 13501 UNSAT 9376 UNSAT 25549 UNSAT 12418 UNSAT 1218 UNSAT 15463 UNSAT 17478 UNSAT 19039 UNSAT 15891 UNSAT 31421 UNSAT 60740 UNSAT 006 UNSAT 39540 UNSAT 51152 UNSAT 27016 UNSAT 010 UNSAT 55498 UNSAT 010 UNSAT Table 4 Weightbounded connected dominating set ASPARAGUS instances Instances rand_100_400_1159666138_1 rand_100_400_1159666138_2 rand_100_400_1159666138_3 rand_100_400_1159666138_5 rand_100_400_1159666138_6 rand_100_400_1159666138_7 rand_100_400_1159666138_8 rand_100_400_1159666138_9 rand_100_400_1159666138_13 rand_100_400_1159666138_19 rand_150_600_1159731678_3 rand_100_400_1159666138_5 rand_100_400_1159666138_6 rand_100_400_1159666138_7 rand_100_400_1159666138_8 rand_100_400_1159666138_11 rand_100_400_1159666138_12 rand_100_400_1159666138_14 rand_100_400_1159666138_15 rand_100_400_1159666138_17 GROCv2 Z3 028 UNSAT 034 UNSAT 032 UNSAT 027 UNSAT 029 UNSAT 022 UNSAT 044 UNSAT 051 UNSAT 033 UNSAT 032 UNSAT 081 UNSAT 078 UNSAT 076 UNSAT 115 UNSAT 076 UNSAT 076 UNSAT 073 UNSAT 076 UNSAT 072 UNSAT 079 UNSAT CLASP 409 UNSAT 162 SAT 085 SAT 197 SAT 083 SAT 148 SAT 073 SAT 161 SAT 149 SAT 184 SAT 072 UNSAT 28725 UNSAT 1411 UNSAT 10472 UNSAT 28989 UNSAT 5221 UNSAT 031 UNSAT 27787 UNSAT 15711 UNSAT 38582 UNSAT 22653 UNSAT 2418 UNSAT 9938 UNSAT 19842 UNSAT 16876 UNSAT 10435 UNSAT 73965 UNSAT 023 UNSAT 54180 UNSAT 80727 UNSAT 23020 UNSAT 069 UNSAT 77146 UNSAT 071 UNSAT CLASP 004 UNSAT 005 UNSAT 004 UNSAT 005 UNSAT 006 UNSAT 004 UNSAT 007 UNSAT 005 UNSAT 004 UNSAT 006 UNSAT 012 UNSAT 008 UNSAT 009 UNSAT 010 UNSAT 009 UNSAT 008 UNSAT 022 UNSAT 008 UNSAT 008 UNSAT 009 UNSAT DLV NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA DLV 005 UNSAT 005 UNSAT 006 UNSAT 004 UNSAT 005 UNSAT 004 UNSAT 006 UNSAT 009 UNSAT 005 UNSAT 009 UNSAT 011 UNSAT 009 UNSAT 011 UNSAT 010 UNSAT 011 UNSAT 011 UNSAT 011 UNSAT 010 UNSAT 011 UNSAT 012 UNSAT CMODELS 6062 UNSAT 1214 SAT 462 SAT 1146 SAT 840 SAT 3540 SAT 433 SAT 1733 SAT 2481 SAT 385 SAT 028 UNSAT 51852 UNSAT 7291 UNSAT 10697 UNSAT 88190 UNSAT 7055 UNSAT 011 UNSAT 81898 UNSAT 51734 UNSAT 36199 UNSAT 6937 UNSAT 27544 UNSAT 45756 UNSAT 012 UNSAT 91031 UNSAT 030 UNSAT 029 UNSAT CMODELS 056 UNSAT 027 UNSAT 018 UNSAT 047 UNSAT 058 UNSAT 044 UNSAT 066 UNSAT 054 UNSAT 050 UNSAT 079 UNSAT 240 UNSAT 187 UNSAT 207 UNSAT 197 UNSAT 189 UNSAT 185 UNSAT 195 UNSAT 053 UNSAT 189 UNSAT 249 UNSAT 92 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 To sum solver GROCv2 Z3 comparable stateoftheart ASP solvers literature Since ﬁrst implementation simpliﬁed techniques ﬁrstorder simpliﬁcation ordered completion employed believe ordered completion provides new promising way implement answer set programming We experimental analysis benchmark programs including Nqueens boundedspanning tree projected hamiltonian cycle For details solver benchmark program instances following link http staff scm uws edu au yzhou page _id 212 Unfortunately current version GROCv2 support functions able handle benchmark programs We leave future investigations 5 Related work As crucial building block answer set programs aggregates extensively studied literature 4101316 2123 Although syntactic form aggregates usually presented ﬁrstorder language semantics normally deﬁned propositionally grounding Recently approaches proposed deﬁne genuine ﬁrstorder semantics aggregates An early attempt Lee Meng 22 restricted form choice counting aggregates appeared 21 In fact semantics ﬁrstorder aggregates essentially equivalent Lee Mengs deﬁnition restricted syntax aggregates form 1 slight difference Lee Mengs stable model semantics considers number constant symbols Z signature domains underlying structure assumed contain numbers Z On contrary notion consider numbers domain structure A Instead use partial function fA maps domain elements DomA integers This addressed Deﬁnition 3 notion extended structure The difference extended structures standard ﬁrstorder structures function fA maps elements DomA Z It noted notion extended structure generalizes notion Lee Meng 22 map domain elements number symbols numbers represent DomA contains number symbols 1 3 simply set fA1 1 fA3 3 fA partially ﬁxed number symbols Z structures A The reason notion abstract sense consider number symbols metalevel Furthermore allows consider ﬁnite domains Lee Mengs notion assumes numbers Z presented domain underlying structures An alternative deﬁnition aggregates FLP semantics 13 extended ﬁrstorder case recently 4 The FLP semantics inherently different stable model semantics aggregates For instance satisﬁes antichain property 13 However semantics coincide allow positive atoms aggregates Ngδ aggregate atoms form 1 In fact case ASP benchmark programs including benchmark programs tested Section 4 Another aggregate framework related work SP semantics 30 The SP semantics normal programs aggregates deﬁned ﬁxed point operator behaves identically threevalued immediate consequence operator cid16agg P independently proposed 26 Although semantics based ﬁxed point type characterization different translational approach framework related work sense aggregate syntax form 1 similar notion intensional multiset form x z1 zr P y1 ym x z1 zr y1 ym Deﬁnition 1 30 Aggregates deﬁned HEX programs 10 extension logic programs introducing higher order external atoms The semantics aggregates HEX programs deﬁned similar manner FLP semantics Interestingly shown external atoms HEX programs generalize notion aggregate atoms 10 Our deﬁnition convex aggregates lift Liu Truszczy nskis notion 23 ﬁrstorder case syntax presented differently In fact Liu Truszczy nski observed normal programs polynomial convex aggregates increase computational complexity For instance checking existence answer sets normal programs normal programs polynomial convex aggregates NP However negative result vex aggregate maximal subclass property considered In words discover normal programs nonconvex aggregates inevitably jump complexity level From Lemma 2 normal programs nonconvex aggregates capture disjunctive programs checking existence answer sets programs cid14 P 2 complete Our negative result Lemma 2 Theorem 2 inspired Ferraris work 16 Ferraris work considered monotone antimonotone aggregates generalized concept convex aggregates He showed propositional case exists aggregate context disjunctive programs converted normal logic programs aggregate atoms context We proved case nonconvex aggregate context propositional case ﬁrstorder case As consequence convex aggregates exactly draw boundary expressive power computational complexity aggregates normal logic programs That propositional case complexity checking answer set existence normal logic programs convex aggregate atoms NPcomplete normal logic program aggregates In contrast complexity checking answer set existence normal logic programs nonconvex aggregate context cid14 P 2 complete V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 93 higher complexity level In ﬁrstorder case result shows normal logic programs convex aggregate atoms converted ﬁrstorder logic type aggregates Theorem 1 normal logic programs nonconvex aggregate context providing general assumptions complexity theory Theorem 2 Interestingly Alviano Faber 1 recently obtained similar result FLP semantics propositional case That FLP semantics propositional programs convex aggregates increase complexity However adding simple nonconvex aggregates result complexity jump ﬁrst level polynomial hierarchy second level In paper mainly focused Ferraris semantics FLP semantics Nevertheless following proofs results hold FLP semantics The main difference consider ﬁrstorder case instead propositional case We convex aggregates draw boundary complexity expressiveness translatability classic ﬁrstorder logic aggregates Finally address relation work ﬁrstorder loop formulas approach Lee Meng 22 A main difference ﬁrstorder loop formulas work arbitrary aggregates enhanced ordered completion works convex aggregates This partially ﬁrstorder loop formulas inﬁnite theories general ordered completions produce ﬁnite theories From semantic viewpoint loop formulas encoding external support set atoms inﬁnite ﬁrstorder level ordered completion encoding derivation order imply stability model class normal program convex aggregates 6 Conclusion The main contributions paper follows Firstly extended notion ordered completion ﬁrstorder programs aggregates showed stable models program convex aggregates corresponding models ordered completion ﬁnite structures Theorem 1 This important extension ASP benchmark programs real world problems need use aggregates aggregates convex Secondly showed convex aggregate maximal subclass task More precisely given nonconvex aggregate context construct normal program aggregate context translated ﬁrstorder sentence type aggregates providing assumptions complexity theory Theorem 2 To best knowledge negative result ﬁrst results 1 convex aggregates exactly draw boundary expressive power computational complexity aggregate atoms answer set programming Finally showed ground program extensional database propositional SMT theory order compute answer sets Theorem 3 Based implement ASP solver compare modern ASP solvers The experiments new direction answer set solving promising particularly nontight programs large problem instances Acknowledgements We like thank anonymous reviewers valuable comments suggestions This work partially supported grant NSFC 61173010 Appendix A Proof Lemma 2 We present proof Lemma 2 section In following assume nonconvex aggregate context AC disjunctive program cid15D In Appendix A1 deﬁne translation cid15D normal program cid15N type aggregates Lemma 2 decomposed following lemmas Lemma 3 Let MN structure τ cid15N If MN stable model cid15N exists stable model MD cid15D MN MD agree interpretations constants predicates τ cid15D Lemma 4 Let MD structure τ cid15D If MD stable model cid15D exists stable model MN cid15N MD MN agree interpretations constants predicates τ cid15D Lemma 3 shown Appendix A2 Lemma 4 shown Appendix A3 We ﬁrst introduce notations Recall aggregate context AC nonconvex By Deﬁnition 6 exist multisets tuples M1 M2 M3 M1 M2 opM1 cid13 N opM3 cid13 N hold opM1 cid13 N hold op ACag aggregate symbol cid13 ACop comparison operator N ACnum number Let M1 m1 mN1 M2 M1 mN11 mN2 M3 M2 mN21 mN3 94 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 N1 N2 N3 size M1 M2 M3 respectively 0 N1 N2 N3 Without loss generality assume tuples M3 length K We introduce new constants Let Cnew set new constants Cnew cms ms M3 m ms 1 s N3 cn cc cn new constant N cc special new constant rule A12 Proposition 5 rest new constants tuples numbers M1 M2 M3 We use D denote following set tuples constants D d1 dN1 dN2 dN3 ds 1 s N3 tuple constants obtained ms M3 replacing m ms cms Notice di d j 1 cid7 j N3 different tuples constants We use NotLitNewx denote set negated atoms x c x x c Cnew cc x tuple variables Intuitively NotLitNewx means variables x constants Cnew cc mapped domain elements We introduce new predicates program Let Pnew set new predicates Pnew Q QD QM Q Q ri j r cid15 rule form 27 1 cid7 j k QD Q D 1 K QM Q Mi 1 2 3 Intuitively Q set predicates constructing aggregate atoms QD representing elements tuple QM encoding M1 M2 M3 Furthermore introduce new predicates tuples predicates secondorder formulas like 8 Let U set new predicates U U P P Pintcid15D Pnew U P P arity We use PD UD denote tuple predicates Pintcid15D tuple correspondence predicates U P P Pintcid15D respectively We use PN UN denote tuple predicates Pintcid15D Pnew tuple correspondence predicates U respectively A1 The translation disjunctive programs normal programs nonconvex aggregates In section deﬁne normal program aggregates denoted cid15N captures answer sets cid15D In general cid15N normal program aggregates built τ cid15D set new constants Cnew set new predicates Pnew It union sets rules cid15N AGG DEF CST AGG set normal rules aggregates simulates disjunctive rules DEF set rules new predicates Q CST set rules new predicates QD QM Now deﬁne sets rules AGG DEF CST Without loss generality assume constant heads rules cid15D Otherwise remove constants head rule equalities For example P x c Ex y rewritten P x z Ex y z c c constant rule form 27 Let v1 vk tuples variables occurring α1 αk head Let r cid15D cid15D r By r N denote rule αi β1 βl γ1 γm opcid9x Q ri1x vi v1cid12 cid13 cn opcid9x Q rikx vi vkcid12 cid13 cn NotLitsNewVarr A1 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 95 1 k k number atoms head r x tuple distinct new variables x K Varr tuple variables r We rules DEF CST normal rules r N Let AGG following set rules 1 r N k exactly capture disjunctive rule r cid15D r N r cid15D cid15D rule form 27 1 k A2 Then deﬁne rules DEF Let r rule form 27 assume αi P ivi α j P jv j For predicate Q ri j Q use DEFQ ri j denote set rules Q ri jds vi v j NotLitsNewviv j 1 s N1 Q ri jds vi v j P jv j NotLitsNewvi N1 s N2 Q ri jds vi v j P ivi P jv j N2 s N3 Q ri jx vi v j P jv j Q D1x Q D N1 x Q ri jx vi v j P ivi Q D1x Q D N2 x Q ri jx vi v j Q D1x Q D N3 x Let DEF following set rules cid20 DEFQ ri j Q ri j Q Finally let CST set following rules predicate P τ cid15D c Cnew cc 1 j P x1 xs xi c j arity P constant c1 τ cid15D c2 Cnew cc c1 c2 c Cnew cc c cc different constants c1 c2 Cnew cn cc c1 c2 opcid9x Q M1xcid12 cid13 cn opcid9x Q M2xcid12 cid13 cn opcid9x Q M3xcid12 cid13 cn 1 N1 Q M1di 1 N2 Q M2di 1 N3 Q M3di A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16 A17 A18 A19 96 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 Q M1x Q D1x Q D N1 x Q M2x Q D1x Q D N2 x Q M3x Q D1x Q D N3 x 1 N3 Q D idi 1 N3 1 j K Q D ix1 x j xK x j cmi j mi m1 m j mK tuple M3 A20 A21 A22 A23 A24 Given disjunctive program cid15D number rules cid15N polynomial length rule polynomial So cid15N built polynomial time respect length cid15D Next prove propositions illustrate deﬁne rules Proposition 2 shows properties sets new predicates QD QM Proposition 3 Proposition 4 implication simulated aggregate atoms aggregate context nonconvex Let M structure τ cid15N We use Dom1M Dom2M denote subsets DomM M c Cnew cc Dom2M c Dom1M DomM Dom2M We following proposition Proposition 2 Let M structure τ cid15N M cid17 DEF CST Then Dom1Ma 1 For predicate P τ cid15D P M M d 2 For predicate Q D 1 N3 Q D M M d 3 For predicate Q Mii 1 2 3 Q M 1 d M M Ni Proof M model rule A10 1 holds M model rules A23 A24 2 holds M model rules A17A19 A20A22 3 holds cid2 Proposition 3 Let M structure τ cid15N M cid17 DEF CST Then M cid17 P jv j P ivi opcid9x Q ri jx vi v jcid12 cid13 cnv1v jbc r cid15D rule form 27 αi P ivi α j P jv j 1 cid7 j k atoms head r b DomMb c DomMc Proof The proposition direct consequence following statements 1 M cid17 P jv j opcid9x Q ri jx vi v jcid12 cid13 cnviv jbc 2 M cid17 P ivi P jv j opcid9x Q ri jx vi v jcid12 cid4 cnviv jbc 3 M cid17 P ivi P jv j opcid9x Q ri jx vi v jcid12 cid13 cnviv jbc 1 Assume M cid17 P jv jv1v jbc Let DomMK tuple domain elements By rules A3 A6 abc M M ri j exists 1 s N1 M cid17 Q D sxxa Furthermore rules A17 A20 abc Q Q ri j Q M M 1 We M cid17 opcid9x Q ri jx vi v jcid12 cid13 cnviv jbc M cid17 opcid9x Q M1xcid12 cid13 cn So rule A25 rule A26 hold M model rule A14 A25 A26 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 97 2 Assume M cid17 P ivi P jv jv1v jbc Let DomMK tuple domain elements By rules A3 A4 M ri j exists 1 s N2 M cid17 Q D sxxa Furthermore rules A18 A7 abc Q M ri j Q M A21 abc Q M cid17 opcid9x Q ri jx vi v jcid12 cid13 cnviv jbc M 2 We A27 M cid17 opcid9x Q M2xcid12 cid13 cn A28 So rule A27 rule A28 holds M model rule A15 3 Assume M cid17 P ivi P jv jv1v jbc Let DomMK tuple domain elements By rules A3A5 M ri j exists 1 s N3 M cid17 Q D sxxa Furthermore rules A19 A8 abc Q M ri j Q M A22 abc Q M cid17 opcid9x Q ri jx vi v jcid12 cid13 cnviv jbc M 3 We A29 M cid17 opcid9x Q M3xcid12 cid13 cn So rule A29 rule A30 hold M model rule A16 cid2 A30 Let M structure τ cid15N U structure τ cid15N UN U called Qreserve extension M U extension M U U U P abc U U U P UN P QD QM M P U P following holds Q M1 Q M2 Q M3 U b Dom1M U U b U P c U bc Dom1M c U U P j U P j bc b A31 A32 A33 P predicate form Q ri j Q r cid15D rule form 27 αi P ivi α j P jv j atoms head r b c tuples domain elements K b c match arity P P j respectively Proposition 4 Let M structure τ cid15N M cid17 DEF CST If U Qreserve extension M U cid17 U P j v j U P vi opcid9x U Q ri j x vi v jcid12 cid13 cnv1v jbc r cid15D rule form 27 αi P ivi α j P jv j 1 cid7 j k atoms head r b DomMb c DomMc Proof The proof similar Proposition 3 We 1 U cid17 U P j v j opcid9x U Q ri j x vi v jcid12 cid13 cnviv jbc 2 U cid17 U P vi U P j v j opcid9x U Q ri j x vi v jcid12 cid4 cnviv jbc 3 U cid17 U P vi U P j v j opcid9x U Q ri j x vi v jcid12 cid13 cnviv jbc 1 Assume M cid17 U P j v jv1v jbc Let DomMK tuple domain elements By A31 abc Q Q M M 1 We U cid17 opcid9x U Q ri j x vi v jcid12 cid13 cnviv jbc U cid17 opcid9x U Q M1 xcid12 cid13 cn So rule A34 rule A35 hold U model rule A14 Q M U 1 U U Q M1 M ri j A34 A35 98 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 2 Assume U cid17 U P vi U P j v jv1v jbc Let DomMK tuple domain elements By A31 abc Q M ri j Q M M 2 We U cid17 opcid9x U Q ri j x vi v jcid12 cid13 cnviv jbc U cid17 opcid9x U Q M2 xcid12 cid13 cn A36 A37 So rule A36 rule A37 holds U model rule A15 Q M U 2 U U Q M2 3 Assume U cid17 U P vi U P j v jv1v jbc Let DomMK tuple domain elements By A33 abc Q Q M M 3 We M ri j U cid17 opcid9x U Q ri j x vi v jcid12 cid13 cnviv jbc U cid17 opcid9x U Q M3 xcid12 cid13 cn So rule A38 rule A39 hold U model rule A16 Q M U 3 U U Q M3 cid2 A2 The proof Lemma 3 A38 A39 In section MN stable model cid15N exists stable model MD cid15D MN MD agree interpretations constants predicates τ cid15D Let MN stable model cid15N By MD denote structure τ cid15D DomMD Dom1MN fMD c fMN c constant c DomMD c P MN constant c DomMD MD P MN DomMD MD c predicate P τ cid15D Proposition 5 shows MD deﬁned sense domain MD Proposition 6 shows MN MD agree interpretations constants predicates τ cid15D Proposition 5 DomMD contains domain elements Proof MN model rule A12 So cc interpreted domain element different constants Cnew Thus cc MN DomMD cid2 Proposition 6 Let P τ cid15D predicate DomMN P MD P MN tuple domain elements matches arity P Then Proof By Proposition 2 P P MN cid2 MN DomMD So construction MD P MD Now present proof Lemma 3 Proof We ﬁrst MD cid17 cid21cid15D Otherwise exist rule r form 27 substitution θ Varr MD cid7cid17cid12rθ So MD cid17 Bodyrθ MD cid7cid17 αiθ 1 k We MN cid7cid17 αiθ 1 k Proposition 6 Then cid3 cid15N form Proposition 3 MN cid17 opcid9x Q ri jx vi v jcid12 cid13 cnθ 1 cid7 j k When consider rule r cid3θ This contradiction fact MN stable model cid15N A1 MN cid17 Bodyr cid3θ MN cid7cid17 Headr It remains MD cid17 UD UD PD cid8 cid12r rcid15D cid15 D A40 We contradiction Otherwise exists structure UD τ cid15D UD UD cid17 UD PD UD cid17 cid13 cid12r rcid15D Let UN Qreserve extension MN U following UN P U UD P P intensional predicate cid15D In V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 UN cid17 UN PN cid8 cid12r rcid15N cid15 N contradiction fact MN stable model cid15N It suﬃces 99 A41 UN cid17 UN PN b UN cid17 r c UN cid17 r d UN cid17 r rule r CST rule r DEF rule r AGG Note bd need consider constraints Consider predicates P U P If P intensional predicate cid15D U If P QD QM U If P predicate form Q ri j Q r cid15D rule form 27 αi P ivi α j P jv j MN U So UN cid17 U P P We UD cid17 UD PD So UN cid17 UD PD atoms head r UD cid17 UD PD Notice Q M P 1 2 3 P Q M MN MN P U P P UN UN UN P UN j MN j UN P UD P So UN cid17 UN PN b Let r rule form A17 A18 A19 A23 UN cid17 r U UN P U MN P P QD QM UN s Q M c Let r rule form A3 Let vi v j bc assignment DomUN ds tuple D 1 s N1 UN 1 UN model rules A17 A20 If UN cid17 NotLitsNewviv jviv j bc bc We d DomMbc D By A31 UN cid17 U Q ri j ds vi v jviv j bc Thus UN cid17 r Let r rule form A4 Let vi v j bc assignment DomUN ds tuple D N1 s N2 UN UN 2 UN model rules A18 A21 If UN cid17 U P j v j NotLitsNewviv jviv j bc Q M We d s b DomMD b By A32 UN cid17 U Q ri j ds vi v jviv j bc Thus UN cid17 r Let r rule form A5 Let vi v j bc assignment DomUN ds N2 s N3 tuple D We UN P UN 3 UN model rules A19 A22 If UN cid17 U P vi U P j v jviv j bc b U c U UN P j UN s d c U Q M UN P j By A33 UN cid17 U Q ri j ds vi v jviv j bc Thus UN cid17 r d Let r rule form 27 r N rule A1 1 k We UN cid17 r N Assume exists assignment θ UN cid17 Bodyr N θ UN cid7cid17 α θ By UN cid17 Bodyr N contradiction UN cid17 opcid9x U Q ri j x vi v jcid12 cid13 cnθ cid7 j 1 j k So UN cid17 α α j Proposition 4 Since UN cid7cid17 α θ UN cid7cid17 α j θ 1 j k 1 j k This contradiction UD cid17 r A3 The proof Lemma 4 cid2 However UD UD UN agree predicate τ cid15D Therefore UD cid17 Bodyr θ UD cid7cid17 α j θ In section MD stable model cid15D exists stable model MN cid15N MD MN agree interpretations constants predicates τ cid15D Let MD structure τ cid15 By MN denote structure τ cid15N DomMN Dom1MN Dom2MN Dom1MN DomMD Dom2MN c MN c Cnew cc set new domain elements constants τ cid15D interpreted MD new constant c Cnew cc interpreted MN cc interpreted domain element Dom1MD new domain element c 100 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 fMN c fMD c m N c DomMD c domain element form c c domain element form cnMN MN ms MN P MN MN P Q M Q D abc Q MD P predicate τ cid15D MN MN d d Ni 1 MN Q D predicate QD 1 N3 d MN following holds ri j Q Mi predicate QM 1 2 3 Q M Q M Q M MN 1 MN 2 MN 3 bc bc Dom1MN b Dom1MN MN b P c P b c P MN j MN j A42 A43 A44 Q ri j Q r cid15D rule form 27 αi P ivi α j P jv j atoms head r b c tuples domain elements K b c match arity P P j respectively Now present proof Lemma 4 Proof First MN model cid15N It suﬃces cid15N model rules CST DEF AGG 1 Consider rules CST MN model rule A10 P MN model rules A11 A12 constant cc constants τ cid15D interpreted domain MD P predicate τ cid15D MN P elements Dom1MN constants Cnew interpreted domain elements Dom2MN MN model rule A13 constants Cnew cc interpreted new distinct domain elements Dom2MN MN model rule A14 MN 1 Q M fMN d d MN 1 opM1 cid13 N MN 1 d MN N1 MN N1 m1 mN1 d M1 Similarly rule A14 MN model rules A15 A16 MN model rules A17A24 Q M d MN d 1 MN MN Ni 1 2 3 Q D MN d MN 1 N3 2 Consider rules DEF Let r rule form A3 Let vi v jbc assignment DomMN ds tuple D 1 s N1 By A44 MN cid17 Q ri jds vi v jviv j bc So If MN cid17 NotLitsNewviv jviv j bc bc Dom1MD bc MN model r Similarly MN model rules form A4 A5 Let r rule form A6 Let xviv jabc assignment DomMN If MN cid17 Q ri jds vi v j Thus MN MN P jv jxviv jabc A42 holds A43 A44 hold So d 1 model rule A6 Similarly MN model rules form A7 A8 d MN N1 3 Consider rules AGG Let r rule form 27 r N rule A1 1 k We MN cid17 r N contradiction Assume exists assignment θ MN cid17 Bodyr N θ MN cid7cid17 αiθ We MN cid17 opcid9x Q ri jx vi v jcid12 cid13 cnθ cid7 j 1 j k By Proposition 3 MN cid17 α j αiθ Note shown MN cid17 DEF CST Together MN cid7cid17 αiθ MN cid7cid17 α jθ 1 j k In addition MD MN agree predicates τ cid15D So MD cid17 Bodyrθ MD cid7cid17 α jθ 1 j k This contradiction MD cid17 r V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 101 It remains MN cid17 UN UN PN cid8 cid12r rcid15N cid15 N A45 We contradiction Otherwise exists structure UN τ cid15N UD UN extension MN UN cid17 UN PN cid8 cid12r rcid15N cid15 N A46 UN constant c τ cid15D UN predicate P τ cid15D By construction UN MN UD agrees interpretations Let UD structure τ cid15D UN DomUD Dom1MD c P constants predicates τ cid15D In following UD P UD c UD cid17 UD PD cid12r A47 cid8 rcid15D cid15 D This contradiction fact MD stable model cid15D cid13 UN P UN UN UN Ni UN cid17 We ﬁrst UN Qreserve extension MN UN cid17 UD PD Since UN cid17 UN 1 d d d Furthermore impossible predicates P τ cid15D P cid12r This contradiction fact UN cid17 UN PN U 1 2 3 Q D 1 N3 So U predicate U P UN P QD QM UN P Otherwise Q UN Q ri j By construction UN UD UN agree interpretations predicates τ cid15D UD cid17 UD PD It remains UD cid17 cid12r r rule form 27 If rule r cid15D UD cid7cid17 r Then θ UD cid7cid17 α θ 1 k Note UD UN agree exists substitution θ UD cid17 Bodyr α interpretation predicates τ cid15D UN cid7cid17 α θ 1 cid7 j k By Proposition 4 UN cid17 opcid9x U Q ri j x vi v j cid13 cnθ 1 cid7 j k This contradiction fact UN cid17 cid26 r N θ UN cid7cid17 α θ 1 k UN cid17 α UN U MN P UN ri j rDEF rCST U cid12r Q M j UN cid13 θ 1 k This completes proof cid2 References 1 Mario Alviano Wolfgang Faber The complexity boundary answer set programming generalized atoms ﬂp semantics LPNMR 2 Vernon Asuncion Fangzhen Lin Yan Zhang Yi Zhou Ordered completion ﬁrstorder logic programs ﬁnite structures Artif Intell 177179 2012 3 Chitta Baral Knowledge Representation Reasoning Declarative Problem Solving Cambridge University Press 2003 4 Michael Bartholomew Joohyung Lee Yunsong Meng Firstorder extension FLP stable model semantics modiﬁed circumscription IJCAI 2013 pp 6772 124 2011 2011 pp 724730 5 Francesco Calimeri Giovambattista Ianni Francesco Ricca Mario Alviano Annamaria Bria Gelsomina Catalano Susanna Cozza Wolfgang Faber Onofrio Febbraro Nicola Leone Marco Manna Alessandra Martello Claudio Panetta Simona Perri Kristian Reale Maria Carmela Santoro Marco Sirianni Giorgio Terracina Pierfrancesco Veltri The answer set programming competition preliminary report competition track LPNMR 2011 pp 388403 6 Yin Chen Fangzhen Lin Yisong Wang Mingyi Zhang Firstorder loop formulas normal logic programs KR 2006 pp 298307 7 Keith L Clark Negation failure Logics Databases 1978 pp 293322 8 Minh DaoTran Thomas Eiter Michael Fink Thomas Krennwallner Modular nonmonotonic logic programming revisited ICLP 2009 pp 145159 9 Thomas Eiter Georg Gottlob Heikki Mannila Expressive power complexity disjunctive datalog stable model semantics ISKI 1994 pp 83103 278298 10 Thomas Eiter Giovambattista Ianni Roman Schindlauer Hans Tompits A uniform integration higherorder reasoning external evaluations answerset programming IJCAI 2005 pp 9096 11 Wolfgang Faber Nicola Leone On complexity answer set programming aggregates LPNMR 2007 pp 97109 12 Wolfgang Faber Nicola Leone Gerald Pfeifer Aggregate functions DLV Answer Set Programming Advances Theory Implementation 2003 pp 274288 13 Wolfgang Faber Gerald Pfeifer Nicola Leone Semantics complexity recursive aggregates answer set programming Artif Intell 175 1 2011 14 Wolfgang Faber Gerald Pfeifer Nicola Leone Tina DellArmi Giuseppe Ielpa Design implementation aggregate functions DLV Theory Pract Log Program 8 56 2008 545580 15 Ronal Fagin Generalized ﬁrstorder spectra polynomialtime recognizable sets Proceedings SIAMAMS vol 7 1974 pp 2741 16 Paolo Ferraris Logic programs propositional connectives aggregates ACM Trans Comput Log 12 4 2011 25 17 Paolo Ferraris Joohyung Lee Vladimir Lifschitz Stable models circumscription Artif Intell 175 1 2011 236263 18 Paolo Ferraris Vladimir Lifschitz On stable model semantics ﬁrstorder formulas aggregates Proceedings 2010 Workshop Nonmonotonic Reasoning 2010 19 Martin Gebser Roland Kaminski Benjamin Kaufmann Torsten Schaub On implementation weigh constraints conﬂictdriven ASP solvers Proceedings 25th International Conference Logic Programming ICLP2009 vol 5649 Springer Verlag 2009 pp 250264 102 V Asuncion et al Artiﬁcial Intelligence 224 2015 72102 20 Michael Gelfond Vladimir Lifschitz The stable model semantics logic programming Proceedings International Logic Programming Conference Symposium MIT Press 1988 pp 10701080 21 Joohyung Lee Vladimir Lifschitz Ravi Palla A reductive semantics counting choice answer set programming AAAI 2008 pp 472479 22 Joohyung Lee Yunsong Meng On reductive semantics aggregates answer set programming LPNMR 2009 pp 182195 23 Lengning Liu Miroslaw Truszczy nski Properties applications programs monotone convex constraints J Artif Intell Res 27 2006 299334 24 Victor W Marek Miroslaw Truszczy nski Stable models alternative logic programming paradigm The Logic Programming Paradigm A 25Year Perspective SpringerVerlag 1999 pp 375398 25 Ilkka Niemelä Logic programs stable model semantics constraint programming paradigm Ann Math Artif Intell 25 34 1999 241273 26 Nikolay Pelov Marc Denecker Maurice Bruynooghe Partial stable models logic programs aggregates LPNMR 2004 pp 207219 27 Nikolay Pelov Marc Denecker Maurice Bruynooghe Wellfounded stable semantics logic programs aggregates Theory Pract Log Program 28 Enrico Pontelli Cao Son Tran Islam Elkabani A treatment aggregates ASP description LPNMR2004 Springer 2004 pp 356360 29 Patrik Simons Ilkka Niemelä Timo Soininen Extending implementing stable model semantics Artif Intell 138 12 2002 181234 30 Tran Cao Son Enrico Pontelli A constructive semantic characterization aggregates answer set programming Theory Pract Log Program 7 3 31 Tran Cao Son Enrico Pontelli Phan Huy Tu Answer sets logic programs arbitrary abstract constraint atoms J Artif Intell Res 29 2007 7 3 2007 301353 2007 355375 353389