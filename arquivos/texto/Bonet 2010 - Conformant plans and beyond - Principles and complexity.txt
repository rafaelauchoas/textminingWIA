Artiﬁcial Intelligence 174 2010 245269 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Conformant plans Principles complexity Blai Bonet Departamento Computación Universidad Simón Bolívar Caracas 89000 Venezuela r t c l e n f o b s t r c t Article history Received 16 September 2008 Received revised form 29 October 2009 Accepted 29 October 2009 Available online 3 November 2009 Keywords Planning Complexity planning Partiallyobservable planning Nondeterministic planning Modal logic Conformant planning refer planning unobservable problems solutions like classical planning linear sequences operators called linear plans The term conformant automatically associated unobservable planning model linear plans mainly possible solutions unobservable problems linear plans In paper linear plans meaningful unobservable problems partiallyobservable problems In case execution linear plan generates observations environment collected agent execution plan end order determine goal achieved typical case problems diagnosis actions knowledgegathering actions Thus substantial differences linear plans case unobservable fullyobservable problems case partiallyobservable problems linear plans model conform properties state space linear plans partiallyobservable problems conform properties belief space This differences surface problems allowed express epistemic goals conditions modal logic place planexistence decision problem different complexity classes Linear plans extreme point discrete spectrum solution forms planning problems The extreme point contingent plans branch point possible observation time step number branch points bounded priori In middle spectrum plans bounded number branch points Thus linear plans plans zero branch points contingent plans plans unbounded number branch points In work lay foundations principles general treatment linear plans plans bounded branching provide exact complexity results novel decision problems We linear plans partiallyobservable problems theoretical challenging reallife problems dealt 2009 Elsevier BV All rights reserved 1 Introduction Consider game Mastermind twoperson codebreaking game played codemaker code breaker The game begins codemaker chooses secret code 4 pegs colored 6 available colors repetitions allowed task codebreaker discover code questioning codemaker assessing answers Each question called guess sequence 4 colored pegs answered codemaker tokens information ﬁrst number exact matches guess number pegs right color Email address bonetldcusbve 00043702 matter 2009 Elsevier BV All rights reserved doi101016jartint200911001 246 B Bonet Artiﬁcial Intelligence 174 2010 245269 Fig 1 Optimal contingent plan Mastermind 3 pegs 3 colors right position second number near matches guess number pegs right color wrong position The codebreaker wins discover secret code 10 guesses codemaker wins This popular game captivated attention millions people 60 including renowned mathematicians 14183738 The game proceeds guessandanswer stages guess depend information acquired previous stages A winning strategy Mastermind depicted tree nodes subsets possible secret codes given stage For example root node set 64 1296 possible secret codes beginning codebreaker information whatsoever Each internal node tree labeled guess case game reaches stage possible answer guess child node corresponds subset secret codes compatible answer The leaves tree nodes correspond singletons represent stages game codebreaker discovered secret code Fig 1 example depicts optimal strategy game Mastermind 3 pegs 3 colors Although labels edges tell possible answers guesses shown important thing note form solution tree structure The game Mastermind cast nondeterministic planning problem partial observability solutions obtained planners perform search belief space Indeed subsets possible states secret codes Mastermind called belief states solutions like Fig 1 called contingent plans belief space contingent plans partial observability In general b belief state solution graph o operator applicable b z1 zn possible observations obtainable application operator o b children b solution graph beliefs bz1 o denotes belief results applying o b observing zi o bzi o bzn There natural variations game ones result increasing number colors secret code number available colors choose However interesting variation known static Mastermind 1423 In variation codebreaker asked ahead linear sequence guesses secret code determined answers guesses For example game 3 pegs 3 colors sequence cid3 cid2 guess2 0 0 guess2 1 0 guess2 2 1 σ guaranteed succeed independently chosen secret code Moreover length minimum se quences corresponds optimal sequence Also observe length σ greater equal length branch optimal contingent plan Fig 1 coincidence sequence σ discover secret code independently value We sequence like σ linear conformant plan partiallyobservable problem Linear plans studied context unobservable planning conformant planning 1621243057 Unlike partiallyobservable problems like Mastermind unobservable problems admit linear plans solutions hypothesis null observability decision maker available input base decisions In unobserv able problems linear plan generates collection trajectories result uncertainty initial state nondeterminism actions problem A linear plan valid plan trajectory starts initial state ends goal state This reason conformant means trajectories generated plan conform goal problem B Bonet Artiﬁcial Intelligence 174 2010 245269 247 Until linear plans generally considered unobservable planning problems However ex ample Mastermind shows makes sense consider linear plans problems partial observability problems observability Hence think term conformant improperly refer different things class solutions linear plans class unobservable planning prob lems In fullyobservable domains linear plan use information available time step plan determines actions step independently contingencies Thus case essentially unobservable treat unobservable problems nondeterministic fullyobservable problems linear plans acceptable In partiallyobservable domains linear plan dictates actions time step deviating unique line execution important difference respect case decision maker collect observations generated application plan order achieve goal end plan There substantial differences cases linear plans fullyobservable partiallyobservable domains The ﬁrst important difference guarantees offered plan In case agent guaran tee state application plan goal state In case illustrated example Mastermind agent guarantee applying plan collecting observations generated information achieve goal computing secret code Mastermind Hence formance fullyobservable domains compliance set trajectories state space conformance partiallyobservable domains compliance set trajectories belief space The second important difference appears studying computational complexity decision problems notions conformance checking existence linear plan fullyobservable unobservable problem known EXPSPACEcomplete 27 checking existence linear plan partiallyobservable problem shown 2EXPSPACEcomplete This important difference complexity classes known different 2EXPSPACEcomplete problem reduced polynomial time EXPSPACEcomplete problem It linear plans considered far partiallyobservable problems standard rep resentation languages able express epistemic goals conditions Indeed problem like Mastermind expressed languages allow express goals know color pegs Thus order proper study linear plans extend standard propositional language planning simple modal operator express goals Linear plans extreme point discrete spectrum solution forms The extreme point contingent plans branch point possible observation received time step number branch point bounded priori In middle spectrum plans bounded number branch points plans 1 branch point plans 2 branch points Linear plans plans branch points contingent plans plans unbounded number branch points The idea having plans bounded number branches new Meuleau Smith 45 considered plans bounded branching Their work ﬁrst explicit general treatment subject area automated planning Although formulation correct fullyobservable case misses important aspects partially observable case Linear plans plans bounded branching practical Meuleau Smith list practical reasons plans NASA 1 plans simple humans easily display stand able modify 2 plans subject detailed analysis resource consumptions dissipation energy simple performing analyses 3 rovers voyagers limited communication bandwidth computational resources storage board simple plans preferred complex ones In areas related medicine example socalled diagnostictest sequences thought linear plans partiallyobservable domain A diagnostictest sequence predetermined set tests performed given procedure given sample results tests end For example performing blood tests medical doctors order socalled blood proﬁles consist suite tests performed single sample blood Diagnostictest sequences exist main reasons blood sample processed time frame tests wait results previous tests ethically accepted disturb patient multiple times taking blood sample test The situation dramatic invasive procedures required The design diagnostictest sequences relevant area medicine Problems involving rovers provide reallife vivid examples situations meaningful model partiallyobservable problems compute linear plans Indeed consider rover remote location goal performing scientiﬁc tests determine presence chemical compound Further assume vehicle limited capabilities performing tests analyzing communicating results tests In particular case robot computational resources update belief state results tests send observations base order receive new instructions time step In case interested computing linear plan property results tests collected transmitted base team experts provided time resources able detect presence absence compound Thus knowing advance robot able properly maintain belief state 248 B Bonet Artiﬁcial Intelligence 174 2010 245269 Table 1 Complexity results fullyobservable planning problems Each cell contains class corresponding problem complete reference result The problems deﬁned problems modal formulae indicated subscript PL Problem planfocont planfolinear planfobranchk planfobranch planfobranchlenPLk planfobranchlenPL Without modal formulae With modal formulae EXP 53 EXPSPACE 27 EXPSPACE new EXPSPACE new Σ P 2k2 new PSPACE new EXP new EXPSPACE new EXPSPACE new EXPSPACE new na na need model computational limitations robot Instead focus modeling essential parts task obtaining linear plan In paper study linear plans plans bounded branching fullyobservable partiallyobservable planning problems We extend standard propositional language planning modal operator permits speciﬁcation epistemic goals preconditions perform thorough complexity analysis novel decision problems related existence different forms solutions The paper organized follows First provide summary complexity results following subsection convenience reader Then propositional modal logic planning language deﬁnitions plans examples decision problems presented Section 2 Section 5 These sections written general audience knowledge representation languages automated planning The following sections Section 6 Section 10 technical contain proofs complexity results Section 6 contains inclusion results Section 7 describes regular expressions exponentiation nondeterministic ﬁnite automata counters main tool showing hardness results Section 8 shows counters double exponential capacity encoded belief states Sections 9 10 contain hardness results special cases plans polynomial length problems modal formulae Section 11 concludes brief discussion This paper contains extends results article appeared proceedings 16th International Conf Automated Planning Scheduling 2006 5 This revised extension includes improved proofs new decision problems ﬁxes errors 11 Summary complexity results We study computational complexity number decision problems planning partial observability modal formulae restrictions number branch points length solutions The decision problems depend type solution contingent linear solution bounded number branch points For example decision problem planfocont deals existence contingent plans fullyobservable planning problems planpobranchk deals existence plans k branch points partiallyobservable planning problems Some decision problems standard extensions standard ones considering modal formulae novel Table 1 depicts exact complexity results decision problems fullyobservable problems Each row table corre sponds type decision problem columns indicate problem allowed modal formulae For example cell ﬁrst row column corresponds problem checking existence contingent plan fullyobservable problems modal formulae Rintanen 53 showed problem EXPcomplete The second column ﬁrst row contains decision problem problems modal formulae case decision problem new complexity In table cont refers contingent branchk refers k branch points branch refers problems instances pairs cid2P kcid3 P planning problem k integer written binary bounds number branch points subscript PL refers class problems modal formulae deﬁned Section 10 Precise deﬁnitions decision problems given Sections 5 10 Complexity results partiallyobservable problems shown Table 2 As novel decision problems interesting complexity results Among completeness result 2EXPSPACE Table 2 shows computing linear plans partiallyobservable problems challenging It worth noticing result new unexpected given known results fullyobservable problems Indeed fullyobservable problems know checking existence contingent plan EXPcomplete EXPSPACEcomplete linear plan Thus checking existence contingent plan partiallyobservable problems 2EXPcomplete 53 surprising complexity rises 2EXPSPACE checking existence linear plan B Bonet Artiﬁcial Intelligence 174 2010 245269 249 Table 2 Complexity results partiallyobservable planning problems Each cell contains class corresponding problem complete reference result The problems deﬁned problems modal formulae indicated subscript PL Problem planpocont planpolinear planpobranchk planpobranch planpobranchlenPLk planpobranchlenPL Without modal formulae With modal formulae 2EXP 53 EXPSPACE new EXPSPACE new EXPSPACE new Σ P 2k2 new PSPACE new 2EXP new 2EXPSPACE new 2EXPSPACE new 2EXPSPACE new na na 2 Propositional modal logic We use simple propositional modal language extends propositional logic unary modal operator cid2 box Wellformed formulae wffs build recursively propositions propositional constant falsum following rules proposition p wff wff ϕ wff ϕ wff ϕ ψ wffs ϕ ψ wff ϕ wff cid2ϕ wff Conjunctions implications biimplications constant true cid6 refer standard abbreviations ϕ ψ ϕ ψ ϕ ψ ϕ ψ ϕ ψ ϕ ψ ψ ϕ cid6 We consider dual operator diamond operator cid2 deﬁned abbreviation ϕ cid2ϕ States interpretations propositional symbols We interchangeably denote states interpretations subsets propositions true Belief states refer collection states represented subsets subsets propositions As standard modal logic 434 theories reasoning knowledge 19 seman tics modal formulae given terms Kripke models frames In case interested interpreting formulae respect belief states provide semantics terms pairs b s b belief state s state structural induction follows b s cid4 p iff p s b s cid4 b s cid4 ϕ iff b s cid4 ϕ b s cid4 ϕ ψ iff b s cid4 ϕ b s cid4 ψ b s cid4 cid2ϕ iff b s cid11 cid4 ϕ s cid11 b A formula ϕ globally true belief state b written b cid4 ϕ satisﬁed states b s cid4 ϕ s b This notion interpretation specialization standard Kripke semantics modal logic set nodes frame belief state b accessibility relation frame universal relation nodes node related A frame type turn special case frames accessibility relation equivalence relation A sound complete axiomatization class frames S5 concerned able interpret formulae modeltheoretic level respect belief states The reader interested thorough treatment modal logic referred work Blackburn Rijke Venema 4 From computational perspective interested decide b cid4 ϕ given belief state b wff ϕ cost It turns purposes suﬃces know decision computed polynomial space size belief state ϕ Indeed simple recursive algorithm tests b s cid4 ϕ decomposing ϕ subformulae test b cid4 ϕ Such algorithm needs store stack depth O ϕ Modal logic expressive propositional logic permits example express preconditions actions goals form know ϕ holds states belief state agree interpretation ϕ possibly ϕ holds state belief state satisﬁes ϕ Indeed know ϕ deﬁned abbreviation cid2ϕ cid2ϕ possibly ϕ deﬁned abbreviation ϕ Example Goal game Mastermind Later provide complete formulation game Mastermind secret code represented propositions si j true state s ith peg color j In Mastermind goal reach belief state interpretations propositions denoting secret code known codebreaker Hence goal deﬁned formula 1cid2i jcid23cid2si j cid2si j game Mastermind 3 pegs 3 colors cid4 250 B Bonet Artiﬁcial Intelligence 174 2010 245269 3 Planning problems belief states plans We consider planning problems deﬁned tuples form P cid2D I G O Z cid3 D set propositional symbols ﬂuents I propositional formula modalities deﬁnes initial states G propositional formula deﬁnes goal states O set operators Z D subset observable ﬂuents Operators pairs cid2ϕ αcid3 ϕ called precondition propositional formula α effect deﬁned follows cid6 null effect p p atomic effects p D α1 αn effects α1 αn parallel effect α1 αn effects α1 αn nondeterministic effect ϕ formula α effect ϕ cid2 α conditional effect ϕ α called condition effect conditional effect Both preconditions conditions contain modal operators However important difference evaluated evaluated belief states states belief state This standard semantics planning conditional operators makes possible effect trigger states belief state As said states planning problem valuations propositions D belief states subsets beliefs states An operator o cid2ϕ αcid3 applicable belief states maximum number 2 state b iff b cid4 ϕ case states result application α state s b belief state states 22 D D Reso b def cid6 Appl cid5 sb Eff αb s s cid7 Eff αb s set atomic effects induced α given b s ApplE s set states result application atomic effects E state s If operator applicable result undeﬁned The set Eff αb s atomic effects deﬁned Eff cid6b s def Eff cid7b s def cid7 literal cid7 cid8 Eff α1 αnb s def i1 E E Eff αib s n Eff α1 αnb s def i1 Eff αib s Eff ϕ cid2 αb s def Eff αb s b s cid4 ϕ Eff ϕ cid2 αb s def cid8 n Observe effects calculated respect belief state In particular condition ϕ effect ϕ cid2 α evaluated respect pair b s instead belief b Thus possible conditional effect triggers state belief Finally application set E atomic effects state s deﬁned cid9 ApplE s def cid11 e s e E s cid11 s cid5 cid10 p p pprope prope set propositions mentioned effect e For example consider ﬂuents min m1 m0 formula ϕ min m0 min m0 effect α ϕ cid2 min belief b s1 m1 s2 min m0 s3 min Then b s1 cid2 ϕ min s1 Eff αb s1 b s2 cid4 ϕ min m0 s2 b s3 cid4 min m0 Eff αb s2 min b s3 cid2 ϕ m0 s3 Eff αb s3 Thus Rescid2cid6 αcid3 b Appl s1 Appl min s2 Appl s3 s1 m0 s3 Different classes models obtained controlling parameters problem P cid2D I G O Z cid3 If nondeterministic effects I determines unique state P ADL problem 50 STRIPS problem 20 conditional effects G preconditions conjunctions atoms If set observables equals D P fullyobservable nondeterministic planning problem thought nondeterministic Markov Decision Process MDP 352 case drop Z notation write P cid2D I G O cid3 If Z cid16 D P contingent planning problem thought nondeterministic Partially Observable MDP 635 The form valid plans varies nature problem For ADL unobservable problems plan linear sequence operators achieves goal matter initial state nondeterminism involved plans recovered search state space ADL problems 72831 search belief space linear plans B Bonet Artiﬁcial Intelligence 174 2010 245269 251 unobservable problems 610304754 Contingent plans functions map states operators MDPs belief states operators POMDPs In cases valid plan obtained different means dynamic programming state space belief space 3125258 ANDOR search state belief space 8926 techniques 293343 For fullyobservable partiallyobservable problems consider linear plans plans bounded number branch points deﬁned 31 Plans A goal belief state belief state satisﬁes goal formula b cid4 G If o applicable operator b let bo denote belief state Reso b results application o b The function Reso b extended sequences operators Rescid2cid3 b def b Rescid2o1 oncid3 b def Reson Rescid2o1 on1cid3 b proviso operator sequence applicable corresponding belief result undeﬁned Let P cid2D I G O cid3 fullyobservable problem bI initial belief state bI cid2o1 oncid3 operators said linear conformant plan P iff Resπ bI goal belief def s s cid4 I A sequence π A plan bounded branching P tree deﬁned respect initial belief We deﬁne plans bounded branching follows A 0plan belief b applicable sequence operators maps b goal belief 0plan bI linear plan bI In general kplan b labeled directed tree T cid2V E r cid7cid3 r V root node cid7 labeling function maps nodes n operator sequences cid7n edges e states cid7e height T equal k node n function cid7n onetoone cid7n n sequence operators cid7r applicable b subset states cid7r n r n E equal Rescid7r b edge r n subtree rooted n k 1plan singleton cid7r n cid11cid11 implies n cid11 cid7n n cid11 n cid11cid11 In words label root denotes sequence operators apply initial belief b results subset states Rescid7r b Then agent observes world determines current state s Rescid7r b By fourth condition child n r cid7r n s subtree rooted n k 1plan singleton belief state s In particular n leaf tree cid7n linear plan singleton s These conditions characterize valid plans k branch points fullyobservable problems plan k branch points kplan bI A plan bounds branching tree arbitrary height contingent plan plan bounds branching sequence cid7n operators contains operator At ﬁrst sight appear constraints number branch points translate constraints information agent needs store order execute plan This true plans constraints number branch points deal complete belief states information world lost Although close connection length plan information requirements dependency direct If agent keeps history actions taken observations received information requirement proportional length plan However agent maintains belief state D bits need store history update belief state time step requirement O D2 number bits needed store belief In summary number branch points plan length determines information requirements execution plan Plans constraint information usually form ﬁnitestate controllers information requirement ﬁnitestate controllers equal log number states controller Proposals consider ﬁnitestate controllers partially observable domains studied 125424451 Obviously kplans acyclic plans worstcase termination horizon In paper deal cyclic iterative plans constructed structured languages 3940 functions map states beliefs actions 2615 Cyclic plans challenging interpret clear role actions nondeterministic effects 55 Also completely clear deﬁne cyclic plans bounded branching specially partiallyobservable problems 311 Partiallyobservable domains In partiallyobservable domains application operator o accompanied observation z This observation feedback agent receives environment depends operator state results def s bo s cid4 z applying o The feedback z agent update current belief b new belief bz o If belief state b faithfully represents possible current state set observations def z TermsZ ss bo s cid4 z TermsZ denote obtained application o b set Z o b complete terms ﬂuents Z If possible observation agent consider possible belief state application operator branching belief space occurs 252 B Bonet Artiﬁcial Intelligence 174 2010 245269 Just like case fullyobservable problems execution linear plan π cid2o1 oncid3 generate different trajectories These trajectories states belief states forced consider collections def Resoi B 1 cid5 cid5 n belief states instead collections states Let B 1 collection belief states deﬁne B i1 cid11 Reso B def o b B z Z o bz undeﬁned b o applicable b B The sequence π said applicable B 1 B undeﬁned In case let Resπ B 1 def Bn1 If π Resπ B collection goal belief states π 0plan linear plan collection B A kplan collection B deﬁned similarly labeled directed tree T cid2V E r cid7cid3 r root node cid7 labeling function maps nodes n sequence operators cid7n edges e belief states cid7e height T equal k node n function cid7n onetoone sequence operators cid7r applicable B collection beliefs cid7r n r n E equal Rescid7r B edge r n subtree rooted n k 1plan singleton cid7r n That label root denotes sequence operators apply collection B results collection Rescid7r B Then application sequence agents calculate current belief information gathered application sequence feedback received agent This belief b member Rescid7r B By fourth condition tree contains child n r cid7r n b subtree rooted n k 1plan singleton collection b In particular n leaf tree sequence cid7n linear plan singleton b These conditions characterize valid plans k branch points partiallyobservable problems plan k branch points kplan collection bI A plan bounds branching partiallyobservable problem tree arbitrary height contingent plan plan bounds branching sequence cid7n operators contains operator 4 Examples We present examples partiallyobservable problems linear solutions interesting meaningful The ﬁrst problem game Mastermind second related rover perform number tests order determine presence chemical compound Martian surface 41 The game Mastermind We provide formalization game Mastermind 3 pegs 3 colors case pegs colors similar We use propositions si j 1 cid5 cid5 3 1 cid5 j cid5 3 denote secret code si j true iff peg color j For simplicity denote number exact near matches guess unary ﬂuents x1 x2 x3 n1 n2 n3 respectively The propositions si j hidden codebreaker know value propositions observable provide feedback guesses The initial situations correspond possible combinations secret codes Such combinations translate boolean assignments si j assign color peg forbid different colors assigned peg For observable propositions assume loss generality false initial situation Hence cid12 def I si1 si2 si3 cid12 si j sik 1cid2icid23 1cid2icid23 1cid2 jkcid23 cid12 1cid2icid23 xi ni The goal game reach state knowledge secret code known codebreaker In standard formulation game game ends codebreaker makes guess exactly matches secret code In formulation game ends codebreaker discovers secret code These formulations possible discover secret code making guess 3 exact matches In formulation goal cid12 def G 1cid2i jcid23 cid2si j cid2si j says truthvalue si j known codebreaker secret code known B Bonet Artiﬁcial Intelligence 174 2010 245269 253 In standard formulation goal deﬁned observing exact matches happens code breaker makes guess exactly matches secret code However goal formula works computing contingent plans Mastermind computing linear plans Some problems involving knowledge translated problems notion knowledge moved syntactic level removing need modal operator These translations implement operators manipulate knowledge syntactic level standard rules inference ones axiomatization S5 However approaches increase size translation exponential factor Recently Palacios Geffner 48 gave sound complete translations computing conformant plans unobservable problems classical planning problems worstcase exponential increase size We continue formulation Mastermind remains deﬁne operators Since secret code change game operators modify return information observable ﬂuents In order simplify coding let ﬂuents ni count number near plus exact matches guess For example code cid21 2 1cid3 guess cid22 1 1cid3 feedback x n 1 3 ﬁrst 1 2 guess near matches second 1 guess exact match This variation game equivalent original information returned action Mastermind guessc1 c2 c3 guess form cid2c1 c2 c3cid3 ci 1 2 3 The operators precondition following conditional effects cid15 cid13 sici cid2 x1 cid14 cid15 sici cid2 x1 cid13 cid14 cid15 cid13 sici s jc j cid2 x2 cid15 sici s jc j cid2 x2 cid14 1cid2i jcid23 cid13 cid14 1cid2icid23 cid13 cid14 1cid2i jcid23 1cid2icid23 cid13 cid12 cid15 cid13 sici cid2 x3 1cid2i jcid23 cid12 sici cid15 cid2 x3 cid15 sic j cid2 n1 cid13 cid13 1cid2icid23 cid13 cid14 1cid2icid23 cid15 cid13 cid14 sic j cid2 n1 cid14 cid15 sick s jcl cid2 n2 1cid2i jcid23 cid14 cid14 1cid2i jcid23 1cid2klcid23 cid15 cid13 cid12 sick s jcl cid2 n2 cid14 cid15 sic j cid2 n3 1cid2i jcid23 cid12 1cid2klcid23 cid14 sic j 1cid2icid23 1cid2 jcid23 cid15 cid2 n3 1cid2icid23 1cid2 jcid23 The ﬁrst conditional effects compute number exact matches unary compute number exact plus near matches unary 42 The Mars Rover We present abstract formulation autonomous rover perform set experiments order ascertain presence chemical compound Martian surface The rover capabilities perform indepth anal ysis samples Thus experiment consists collecting sample performing measurements sample transmitting Earth results measurements The state speciﬁed different sets ﬂuents First feature ﬂuents f 1 fn denote presence absence n features surface planet second power ﬂuents p1 pm denote remaining power batteries rover The power ﬂuents measure remaining power unary initially rover m power units experiment consumes unit For simplicity assume experiment returns bit information truthvalue depends current unknown state environment Thus assume experiment testi formula ϕi feature ﬂuents deﬁnes information bit The Mars Rover problem partiallyobservable planning problem P cid2D I G O Z cid3 D f 1 fn p1 pm bit I pi bit cid12 1cid2icid2m cid12 G 1cid2icid2n cid2 f cid2 f O test1 testcid7 Z bit 254 B Bonet Artiﬁcial Intelligence 174 2010 245269 goal certain presenceabsence feature f The initial states correspond 2n interpretations features The operators require consume unit energy set clear information bit depending formula ϕi true false 1 cid5 cid5 cid7 cid16 testi p1 pm ϕi cid2 bit ϕi cid2 bit cid17 p1 p j1 p j cid2 p j cid12 1cid2 jcid2m We consider classes solutions plans Mars Rover class translates assumptions capabilities rover Solutions ﬁrst class constraints number branch points contingent plans problem This class corresponds rover suﬃcient capabilities perform ﬁltering operation belief states able update belief state result test In setting plan contingent plan generates sequence tests able discover exact conﬁguration features Martian surface Solutions second class branch points linear sequences tests This class corresponds rover capabilities whatsoever perform belief ﬁltering Therefore task rover perform test sequence transmit results Earth The results analyzed team human experts determine unique ﬁxed sequence results exact conﬁguration features Martian surface In example details capabilities rover abstracted away representation prob lem details lost got translated requirements form solutions Thus rover able process results experiments look contingent plans robot unable look linear plans Examples like proposed language novel planning problems pure theoretical related relevant diﬃcult reallife problems 5 Complexity decision problems We consider Turing Machines TM semiinﬁnite tapes halt inputs We use DTM NTM ATM denote deterministic nondeterministic alternating TMs respectively We consider standard complexity classes P polynomial time PSPACE polynomial space EXP exponential time EXPSPACE exponential space 2EXP double exponential time 2EXPSPACE doubleexponential space nondeterministic variants The nondeterministic space classes equal deterministic ones 56 closed complementation NEXPSPACE EXPSPACE coEXPSPACE One deﬁne class languages recognized ATMs start existential state n 1 alterna tions operate polynomial time Such class denoted Σ P n initial state universal The union classes form PolynomialTime Hierarchy PH 59 deﬁned oracles 62 The following standard facts 174956 n Π P P Σ P n The following problem called satk complete Σ P PSPACE 0 cid5 n m hierarchy theorem Σ P m Π P m Π P n Q xkΦ Q k odd Is Ψ valid formula k Given quantiﬁed boolean formula QBF Ψ x1x2 The following problem called qbf complete PSPACE Given QBF Ψ x1x2 Q xkΨ Q k odd Is Ψ valid formula Observe k ﬁxed constant problem satk input qbf number quantiﬁers variable Thus problem qbf reduced unique satk problem PH collapses level 51 Decision problems The standard methodology cast decision problems planning languages For example problem deciding given STRIPS planning problem valid plan correspond language planstrips def cid18 cid19 cid2P cid3 P STRIPS problem plan cid2P cid3 suitable encoding P The length P deﬁned length encoding The following list contains main decision problems considered article abbreviate fullyobservable planning problem FOP partially observable planning problem POP planadl def cid2P cid3 P ADL planning problem FOP plan planfocont def cid2P cid3 P FOP plan planfolinear def cid2P cid3 P FOP linear plan planfobranchk def cid2P cid3 P FOP kplan B Bonet Artiﬁcial Intelligence 174 2010 245269 255 planfobranch def cid2P kcid3 P FOP kplan k written binary planpocont def cid2P cid3 P POP hat plan planpolinear def cid2P cid3 P POP linear plan planpobranchk def cid2P cid3 P POP kplan planpobranch def cid2P kcid3 P POP kplan k written binary Observe planfobranchk planpobranchk represent collections problems value k The problems planfobranch planpobranch represent languages pairs cid2P kcid3 P planning problem k integer written binary planfobranchk planfolinear reduced direct way planfobranch complexity complexity Similarly planpobranchk planpolinear planpobranch Tight complexity bounds planstrips planadl planfocont planfolinear planpocont known Indeed planstrips planadl PSPACEcomplete 11 planfocont EXPcomplete 531 planfolinear EXPSPACE complete 27 planpocont 2EXPcomplete 53 results problems modal formulae The problems planfobranchk planfobranch planpobranchk planpobranch planpolinear novel The ﬁrst problems shown EXPSPACEcomplete shown 2EXPSPACEcomplete As deﬁned planstrips planadl planfocont include problems modal formulae However problems state known time point modalities play role removed changing problems complexity results remain valid The results need revised planfolinear planpocont modalities As complexity results Haslum Jonsson 27 Rintanen 53 remain valid classes 6 Inclusion results We ﬁrst revise complexity planfolinear planpocont problems modal formulae provide inclusion results planfobranchk planfobranch planpobranchk planpobranch planpolinear Observe n propositional symbols 2n planning states set states repre sented exponential space n2n bits 2n states taking space n Also recall truth modal formula decided polynomial space size formula The cases planfolinear planpocont essentially modalities change necessary test validity modal formulae resources algorithm For planfolinear existence plan decided nondeterministic exponential space TM stores single belief state counter The machine starts initial belief state counter initialized zero Then machine enters loop nondeterministically chooses applicable operator applies cycles current belief goal belief reaching 22n operators checking validity modal formulae requires polynomial space TM correctly decides existence plan works exponential space Observe machine compute plan decides plan exists steps Since valid plan 22n Theorem 1 planfolinear EXPSPACE Since completeness holds restricted case problems modalities plan folinear EXPSPACEcomplete planpocont solved ATM exponential space accepting computation trees correspond contingent plans proof special case proof Theorem 3 given Since ATMs exponential space bounds simulated DTMs doubleexponential time bounds 13 Theorem 2 planpocont 2EXP Since completeness holds restricted case problems modalities planpocont 2EXPcomplete The inclusion planfobranch EXPSPACE shown ATM makes k alternations Note branch point plan corresponds fully observing current state planning Since different plan possible state branch simulated transition universal state A ﬁnal simulation ATM DTM shows inclusion EXPSPACE Theorem 3 planfobranch EXPSPACE Hence planfobranchk EXPSPACE 1 The complexity remains EXPcomplete testing existence plans reach goal probability cid3 t probabilistic problems observability 41 256 B Bonet Artiﬁcial Intelligence 174 2010 245269 Proof Consider input cid2P kcid3 P cid2D I G O cid3 fullyobservable planning problem k bound number branch points written binary Let D n The following ATM decides kplan P K 0 REJECT K K 1 branch s b b s goto 2 M input cid2P kcid3 1 K k b s I cid4 s steps 0 2 b cid4 G ACCEPT 3 branch choose APPLY BRANCH 4 BRANCH 5 6 7 8 9 APPLY steps 22n branch choose operator cid2ϕ αcid3 b cid4 ϕ b Resa b steps steps 1 goto 2 REJECT 10 11 12 13 14 15 end The ATM EXPSPACE 2n states subset states stored O n2n bits counters steps K require O 2n log K bits tests lines 2 11 polynomial space Use Borodins Theorem Appendix A conclude M transformed DTM exponential space bound cid3 The idea works inclusion planpobranch 2EXPSPACE time collections belief states stored instead belief states ATM requires O n2n22n bits Theorem 4 planpobranch 2EXPSPACE Hence planpobranchk planpolinear 2EXPSPACE Proof Consider input cid2P kcid3 P cid2D I G O Z cid3 partiallyobservable planning problem k bound number branch points written binary The following ATM decides kplan P K 0 REJECT K K 1 branch b B B b goto 2 M input cid2P kcid3 1 K k B s I cid4 s steps 0 2 b cid4 G b B ACCEPT 3 branch choose APPLY BRANCH 4 BRANCH 5 6 7 8 9 APPLY steps 222n branch choose operator cid2ϕ αcid3 b cid4 ϕ b B B Resa B steps steps 1 goto 2 REJECT 10 11 12 13 14 15 end Since 2n states 22n bits ATM doubleexponential space bound As Borodins Theorem implies M transformed DTM doubleexponential space bound cid3 subsets states collection B belief states stored n2n22n For hardness results follow work Haslum Jonsson 27 use regular expressions exponentiation corresponding nondeterministic ﬁnite automata counters Automata provide fruitful approach hardness results easy simulate behavior planning problems 7 Regular expressions automata Regular expressions exponentiation REE extend regular expressions operation exponentiation form α k α regular expression exponentiation k positive integer written binary The expression B Bonet Artiﬁcial Intelligence 174 2010 245269 257 Fig 2 Nondeterministic ﬁnite automaton counters α k α k denotes language α α α repeated k times A REE transformed regular expression exponentiation replacing subexpression α k concatenation k copies α This transformation increases length expression exponentially length α k 1 αcid21log kcid22 length α α kα As usual length α deﬁned number symbols Regular expressions exponentiation typically establish intractability results EXPSPACE The main tool utilized following classical result REEs refer version appears Sipsers book 56 consult Hopcroft Ullman 32 source 46 Theorem 5 Let α REE alphabet Σ Checking α Σ EXPSPACEhard Proof sketch Given language A EXPSPACE decided DTM exponentialspace bound sn 2nk polynomialtime reduction f input ω length n produces REE f ω α M accepts ω iff α Σ alphabet Σ depends M α polynomial n The idea let α denote invalid nonrejecting computation histories M ω A rejecting computation history M ω sequence conﬁgurations snapshots M ﬁrst conﬁguration initial conﬁguration M ω conﬁguration rejecting conﬁguration conﬁguration sequence follows preceding single step M The REE α deﬁned denote strings begin initial conﬁguration M ω contain rejecting conﬁguration conﬁguration follow preceding 56 pp 344347 The size α counting exponents O n log n counting exponents O nk exponents α set 1 n 1 2nk n 2 2nk 2 2nk By construction M accepts ω iff rejecting computation history M ω M deterministic iff α denotes strings alphabet cid3 The computational models correspond regular expressions deterministic nondeterministic ﬁnite au tomata In presence exponents automata need extended counters We deﬁne class non deterministic ﬁnite automata counters NFACs simple suﬃcient needs use general NFACs Haslum Jonsson cost getting complex proofs An NFAC nondeterministic ﬁnite automaton augmented set C counters bounded capacity Each counter c C corresponds subexpression form α k implemented ﬁve states entryc testc continuec exitc loopc capacity bound boundc These elements speciﬁc counter subscripted accordingly We states entryc testc continuec loopc exitc c C cstates denote set cstates The automaton counter c associated α k shown Fig 2 The operation automaton follows Initially counter set zero Upon visiting entryc counter initialized boundc cid13transition testc transition entryc In testc machine makes cid13transition continuec exitc depending c 0 transitions testc continuec exitc In continuec machine makes cid13transition initial state α cid13transition ﬁnal state α loopc Upon visiting loopc machine decrements counter c makes cid13transition testc transitions testc entryc loopc Formally NFAC M cid2Q Σ δ q0 F Ccid3 consists set Q states input alphabet Σ transition function δ Q Σ 2Q initial state q0 Q subset F Q accepting ﬁnal states set counters C Each counter ﬁve states associated described The language LM recognized M set words Σ induce path initial state q0 accepting state size M M def δ cid21log boundccid22 relation REEs NFACs following cC cid20 Theorem 6 For REE α NFAC Mα polynomial size α ω α iff ω LMα Conversely NFAC M REE αM polynomial size M ω LM iff ω αM Proof Direct Left reader cid3 258 B Bonet Artiﬁcial Intelligence 174 2010 245269 From assume complete automata An automaton M complete δq nonempty q Q Σ cid13 A noncomplete automaton easily transformed complete adding nonaccepting state qsink δq qsink q δq δqsink qsink Σ cid13 Furthermore assume loss generality exactly transition states exitc nonsink states labeled cid13 A conﬁguration snapshot M pair θ cid2q νcid3 q Q speciﬁes current state M ν C N spec iﬁes current value counter M A conﬁguration accepting state accepting The initial conﬁguration automaton pair θ0 cid2q0 ν0cid3 ν0c 0 c C The transition function δ extended function ˆδ maps conﬁgurations words Σ conﬁgurations θ cid11 ˆδθ ω iff conﬁguration θ cid11 including cid13transitions details Appendix B Thus LM def ω Σ tion subsets reached θ path labeled ω ˆδθ0 ω contains accepting conﬁgura 71 The proof Haslum Jonsson The EXPSPACEhardness conformant planning fullyobservable problems established reduction problem checking fullyobservable planning problem conformant plan problem checking α cid16 Σ fact EXPSPACE closed complementation Indeed let α REE alphabet Σ M cid2Q Σ δ q0 F Ccid3 NFAC recognizes α The idea construct planning problem P simulates extended transition function ˆδ The states planning problem represent conﬁgurations M denoted q ν conﬁguration cid2q νcid3 The initial belief P corresponds singleton q0 ν0 nondeterministic operators oa Σ cid13 The construction guarantees pair conﬁgurations cid2q νcid3 cid2q cid11 νcid11cid3 cid21 q cid11 νcid11 cid22 cid6 Res πpadoa1πpadoa2πpad πpadoan πpad q ν cid18 cid19cid7 cid2 q iff cid3 cid6 cid11 νcid11 ˆδ cid2q νcid3 a1 cid7 πpad ﬁxed sequence ocid13 operators If goal deﬁned nonaccepting conﬁguration P valid linear plan iff α cid16 Σ The key issue constructing P counter exponential capacity requires polynomial number bits represented polynomial number ﬂuents In case aim deciding existence linear plan partiallyobservable problems 2EXPSPACE hard direct simulation NFACs counters doubleexponential capacity work requires planning problem exponential number ﬂuents However compact encodings counters achieved collections belief states instead belief states considered 8 Compact representation counters Let c counter exponential size doubleexponential capacity bits ci 0 cid5 2n let P planning problem n propositional markers mck 0 cid5 k n simply denoted mk c clear context We encode value c collection subsets markers To illustrate idea observe value c represented collection positions 1bits binary expansion c set ci 1 For example value 72 01001000bin represented set 3 6 1bits binary expansion 72 sixth bit leastsigniﬁcant rightmost zeroth bit This representation directly exponential number positions However position represented binary markers value counter represented collection subsets markers In example value 72 represented collection m0 m1 m1 m2 3 20 21 6 21 22 In general value counter represented following collection subsets markers cid18cid18 bc mck kth bit ibin 1 ci 1 cid19 cid19 For example collection represents value c 1 00000001bin unique 1bit position 0 m0 m2 represents value c 18 00010010bin positions 1bits 1 4 written binary 001bin 100bin m0 m1 m2 represents value c 129 10000001bin positions 1bits 0 7 000bin 111bin In addition propositional markers use proposition Ac indicates subset markers active counter c given representation c clear context write A Nonactive subsets ignored performing operations c existence alleviates complexity operations Hence example value c 72 represented belief m0 m1 A m1 m2 A From use notation c b denote counter c represented belief state b 81 Arithmetic counters In order simulate NFACs planning problems need perform simple arithmetics counters com parisons decrement operations B Bonet Artiﬁcial Intelligence 174 2010 245269 259 Let c counter b belief state c b Then c 0 iff active state b c 0 iff active state These conditions written propositional modal logic Ac Ac abbreviated c 0 c 0 respectively Notice Ac test c 0 holds iff state b active As decrement operation render active states s b inactive The decrement operation subtract value counter For example change value 72 01001000bin represented b72 m0 m1 A m1 m2 A value 71 01000111bin represented b71 A m0 A m1 A m1 m2 A That subset m0 m1 A needs replaced subsets A m0 A m1 A The general principle involved replace subset leastsigniﬁcant 1bit ﬁrst 1 right left cs binary expansion subsets represent bits signiﬁcant value We need ﬁrst identify subset replace generate replacement subsets For ﬁrst task consider sequence effects progressively isolate active subsets represent signiﬁcant 1bit At beginning active subsets ﬂagged proposition minc effect Ac cid2 minc Then k n k 0 effects ﬁlter ﬂagged subsets dominated respect mk marker applied succession These effects form ﬂagc def Ac cid2 minc cid6 def minc mcn1 cid6 minc mcn1 cid7cid7 cid2 minc ﬁltercn1 ﬁlterc0 def cid6 minc mc0 cid6 minc mc0 cid7cid7 cid2 minc In example apply succession effects cid2ﬂag ﬁlter2 ﬁlter1 ﬁlter0 m1 m2 A subset replace ﬂagged min cid3 b72 obtain belief m0 m1 A min Once subset replace identiﬁed replacements generated processing marker parallel In example leastsigniﬁcant corresponds m0 m1 A The decrement operation clear bit turn 2nd 1st 0th bits 72 01001000bin converted 71 01000111bin Thus state replaced A m0 A m1 A The replacement effect processes marker mk nondeterministically k 0 k n The nondeterminism utilized implement parallel execution individual effects marker results joined The effects deﬁned clear ﬂagged status marker holds invalidate state mk holds clear mk nondeterministically ﬂip marker m j 0 cid5 j k In example state s m0 m1 A min needs replaced Since m2 hold s processing generates The processing m1 clears m1 ﬂips m0 generating A m0 A The processing m0 clears m0 ﬂips generating m1 A Therefore overall effect collection A m0 A m1 A Let illustrate decrement b71 A m0 A m1 A m1 m2 A After identiﬁcation effects belief transformed A min m0 A m1 A m1 m2 A subset replace A min corresponds leastsigniﬁcant 1bit Because state satisﬁes marker effect replacement invalidate state clearing ﬂuent A Hence belief transforms m0 A m1 A m1 m2 A represents 70 01000110bin subset nonactive The decrement operation implemented following sequence n 2 operators decrementc def cid2 cid2cid6 ﬂagc cid3 cid2cid6 ﬁltercn1 cid3 cid2cid6 ﬁlterc0 cid3 cid2cid6 replacec cid3 cid3 replacec effect cid23cid24 minc minc cid25 cid26 cid23cid24 mck cid2 Ac minc cid25cid26 mck cid2 n1cid14 k0 n1cid12 k0 cid23cid24 n1cid27 mck cid2 mck k1cid12 k0 j0 cid25cid26 mc j mc j The subsequence ﬁrst n 1 operators called identiﬁcation stage operator called replacement stage The correctness arithmetic operations summarized following result Theorem 7 Let c counter b belief state c b Then c 0 iff b cid4 Ac b c 1 iff b cid4 Ac Ac cid4 n k0 mck 260 B Bonet Artiﬁcial Intelligence 174 2010 245269 c c 1 iff b cid4 Ac d c 0 c Resdecrementc b e c 0 c 1 Resdecrementc b cid28 n k0 mck Proof Claims ac direct For d c 0 state ﬂagged active Therefore replacec effect b For e ﬁrst identiﬁcation stage correct That states remain ﬂagged identiﬁcation correspond leastsigniﬁcant 1bit c The correctness identiﬁcation direct consequence following facts After applying ﬂagc active states ﬂagged After applying ﬁlterck ﬂagged states agree interpretation markers mccid7 cid7 cid6 k This true k n 1 Assume true k 1 Then ﬁlterck applied resulting states satisfy mck resulting states satisfy mck At end ﬂagged states agree interpretation markers Direct previous fact At end ﬂagged state Since c 0 active state initially ﬂagged Suppose ﬂagged states end let k integer input belief b ﬁlterck ﬂagged cid11 b states output Then case ﬂagged s b ﬂagged s mck s mck s But ﬁlterck clear ﬂag s contradicting choice k cid11 cid11 There ﬂagged state corresponds leastsigniﬁcant 1bit Suppose true Then state s cid11 leastsigniﬁcant 1bit initially ﬂagged k ﬁlterck clears ﬂag s ﬂagged s mck s mck s Since states applying ﬁlterck agree interpretation markers mccid7 cid7 k s corresponds signiﬁcant 1bit s contradicting choice s cid11 cid11 We replacement stage correct Let b s1 sp s input belief replacec s cid11 ﬂagged state represents leastsigniﬁcant 1bit We replacec generates belief s1 sp s q cid11 states s represent bits lesser signiﬁcance s We consider cases s represents 0th bit bit In ﬁrst case s markers Then replacec clears active ﬂuent decrements counter unit cid11 1 s Suppose s contains markers mi1 micid7 0 cid5 i1 icid7 n The bits signiﬁcance s correspondence subsets mik1 micid7 C C cid6 m0 m1 mik1 cid7cid19 cid7cid5 cid18 k1 1 A denotes power set A We replacec generates subsets Since s satisﬁes Aa marker need consider second conditional effect Notice subset A effect ik1 ik1 j0 m j m j generates j0 m j m j generates m0 mik1 mik generates A Therefore mik1 mcid7 C C m0 mik1 applied s Finish observing second conditional effect cid4 translates ik1 j0 m j m j applied s cid3 cid29 cid7 k1 mik cid4 cid4 cid4 The problem identifying subset markers correspond leastsigniﬁcant bit related problem selecting preferred state belief state respect lexicographic preference order deﬁned markers mi state s preferred state s agree iff k s makes true mk s interpretation markers mcid7 cid7 k There modalityfree formula ϕ selects preferred state belief state s cid4 ϕ iff s preferred b know short polynomially long modal formula able This main reason performing identiﬁcation stage decrement operation counters s s cid11 cid11 cid11 We ﬁnish section noticing multiple counters simultaneously encoded crossproducts subsets markers Since markers active ﬂuents min ﬂuents tagged counters perform arithmetic operations different counters simultaneously The compact encoding counters arithmetic operations main tools needed lower bounds complexity decision problems 9 Hardness results The EXPSPACEhardness planfobranchk shown giving polynomialtime reductions planfobranchk planfobranchk 1 k cid6 0 Since planfobranch0 EXPSPACEhard 27 planfobranchk EXPSPACEhard k cid6 0 This result inclusion results establish exact complexity bounds planfobranchk B Bonet Artiﬁcial Intelligence 174 2010 245269 261 Theorem 8 For k cid6 0 planfobranchk polynomialtime reducible planfobranchk 1 Therefore planfobranchk planfobranch EXPSPACEcomplete Proof Let P cid2D I G O cid3 planning problem observability We need construct fullyobservable problem P cid11cid3 P kplan iff P k 1plan The problem P deﬁned follows cid11 cid2D cid11 O cid11 G cid11 I cid11 cid11 I cid11 D p q1 q2 r D cid11 I p q1 q2 r cid11 r G cid18 cid11 cid2p ϕ αcid3 cid2ϕ αcid3 O O cid19 cid18 o1 cid3 cid2 p G p q1 q2 cid19 o2 cid2p q1 rcid3 o3 cid2p q2 rcid3 p q1 q2 r new propositional symbols o1 o2 o3 new operators Clearly problem P constructed P polynomial time cid11 We claim P kplan iff P k 1plan Indeed let π kplan P That π makes k observations branch branch ﬁnishes state satisﬁes G If end branch apply operator o1 followed observation separate states satisfy q1 ones satisfy q2 ﬁnally apply o2 o3 depending q1 q2 satisﬁed k 1plan P o2 o3 Thus second operator o1 After o1 applied states satisfy q1 states satisfy q2 Therefore π cid11 branch observation application o1 order separate states Since precondition o1 includes goal G P branches π cid11 application o1 form kplan P cid3 The operator branch π cid11 k 1plan P Conversely let π cid11 cid11 cid11 cid11 We 2EXPSPACEhardness result partiallyobservable domains The proof idea similar Haslum Jonsson need deal counters doubleexponential capacity Let ﬁrst revise proof Theorem 5 cf 56 Given DTM M exponentialspace bound en 2pn pn nk size n let α αM ω REE polynomial length M n M accepts ω iff α Σ word ω Σ If space bound replaced doubleexponential space bound α remains exponents α change exponential doubleexponential Indeed space bound en exponents α 1 n 1 2nk n 2 2nk 2 2nk space bound form dn 22pn exponents 1 n 1 22nk Thus doubleexponential space bounds counters doubleexponential capacity n 2 22nk 2 22nk Theorem 9 planpolinear 2EXPSPACEhard Hence planpolinear planpobranch 2EXPSPACEcomplete Proof Let M DTM doubleexponential space bound dn 22pn pn nk polynomial n ω Σ input word M length n Consider REE α αM ω given proof Theorem 5 space bound dn The size α exponential sizes exponents accounted α polynomial M n Let Mα cid2Q Σ δ q0 F Ccid3 NFAC α δ polynomial M n cid21log boundccid22 exponential We going construct polynomial time planning problem P partial observability linear plans simulate NFAC The main idea encode conﬁgurations Mα belief states P described Section 8 The construction guarantee LMα cid16 Σ iff P valid linear plan Since 2EXPSPACE closed complementation planpolinear 2EXPSPACEhard iff P valid linear plan Therefore M rejects ω iff LMα cid16 Σ cC cid20 From NFAC Mα cid2Q Σ δ q0 F Ccid3 deﬁne planning problem P cid2D I G O Z cid3 follows The ﬂuents P collection symbols representing state machine q q Q representing value counters Ac minc mck c C 0 cid5 k cid5 pn execution mode normal initc decck ﬂagc ﬁlterccid7 replacec c C 0 cid5 k cid5 n 2 0 cid5 cid7 cid5 pn The observable symbols symbols state machine Z q q Q The reason belief states represent conﬁgurations machine belief state symbol true Making observable forces beliefs collection B satisfy property Each symbol precise role clear construction P The descriptions I G reﬂect initial nonaccepting conﬁgurations respectively cid12cid18 p p D q0 normal cid19 def q0 normal cid14 def normal I G q q F 262 B Bonet Artiﬁcial Intelligence 174 2010 245269 Formula I encodes initial conﬁguration Mα state q0 value counters set 0 active ﬂuents Formula G encodes nonaccepting conﬁgurations state Mα F The symbol normal express current belief states faithfully represent possible conﬁgurations Mα It turned transformation involving operator decreasing value counter applied restored transformation ﬁnishes The planning operators divided classes O oa Σ cid13 oinit oset odec Operators ﬁrst class implement transition function δ operators second class implement arithmetic operations counters Operators ﬁrst class execute normal mode format cid17 cid7 cid6 q cid2 αq normal cid12 cid16 oa qQ αq effect associated state q input Σ cid13 For states q Q cstates αq def cid29 cid6 cid29 qcid11δqaqq q qcid11δqaq q cid29 cid11 cid6 qcid11δqcid13q q cid11 cid11 cid16 cid13 q δq cid16 cid13 q δq cid13 cid6 null effect cases transition leave state automata unchanged As seen previous section arithmetic operations implemented sequences operators We enforce sequences change execution mode obtained deleting ﬂuent normal Arithmetic operations occur transitions cstates associated counters In states testc cid13transitions states continuec exitc depending counter greater equal zero In states continuec exitc cid13transitions unique states δcontinuec cid13 δexitc cid13 respectively And states loopc cid13transition state testc counter decremented Furthermore transitions cstates symbol Σ lead sink node These effects following cid21 cid22 testc c 0 cid2 continuec c 0 cid2 exitc αtestc cid13 def cid6 αcontinuec cid13 def cid6 αloopc cid13 def cid6 loopc αexitc cid13 def cid6 αq def q qsink cid21 cid22 cid21 continuec δcontinuec cid13 testc normal decc1 cid22 exitc δexitc cid13 q cstates Σ The effect loopc changes execution mode normal decc1 order decrement counter c unit sequence operators The mode decc1 instance general execution mode decck performs decrement counter c k units The operators effects implement decrement operations cid16 def odec true cid17 decck cid2 βdecc k cid12 ck βdecc k def decck rdecck1 ﬂagc βdecc 0 def decc0 normal cid12 cid16 def oﬂag true ﬂagc cid16 oﬁlter def true c cid12 ck ﬁlterck cid2 ﬂagc ﬁltercpn cid17 cid2 βﬁlterc k cid17 ﬂagc βﬁlterc k def ﬁlterck βﬁlterc 0 def ﬁlterc0 cid16 cid12 oreplace def true ﬁlterck1 replacec ﬁlterck ﬁlterc0 replacec rdecck cid2 replacec cid17 decck replacec ck We claim ﬂuent decck true belief state b way resume normal execution mode perform appropriate sequence odec oﬂag oﬁlter oreplace operators value counter c denoted b decremented k units Indeed decck true normal false odec operator effect Its B Bonet Artiﬁcial Intelligence 174 2010 245269 263 effect clear decck set ﬂuents rdecck1 ﬂagc ﬁrst force new application odec second initiates decrement operation counter c Once ﬂagc true operator effect oﬂag performs ﬂag effect cf Section 8 clears ﬂagc sets ﬁltercpn At stage operator oﬁlter applied pn 1 times performing sequence effects ﬁltercpn ﬁltercpn1 ﬁlterc0 n 1st application clears ﬁlterc0 sets replacec force application oreplace The operator oreplace applies effect replacec changes ﬂuent rdecck decck order force additional decrement operations At end operator odec changes ﬂuent decc0 normal normal execution mode resumes Observe normal true true belief states state automata normal ﬂuent deleted testc case αloopc cid13 There thing deﬁne cid13transitions states entryc initialize value counters c boundc change state testc In general set counter doubleexponential capacity arbitrary value operators polynomial size However exponents consider 1 n 1 22pn n 2 22pn 2 22pn values set operators polynomial size Indeed let begin effect cid13 αentryc cid13 def cid6 entryc testc normal initc Ac cid15 cid12 k mck sets active ﬂuent clears markers c changes execution mode normal initc sets state automata testc normal execution mode restored As initialization values involve operators reason change execution mode Once initc mode initialization operator cid12 cid16 def oinit true c cid17 initc cid2 βinitc The effect βinitc depends counter c Let partition counters exponential capacity denoted Ce doubleexponential capacity denoted Cd A counter c Ce polynomial number 1bits directly initialized effect βinitc def initc normal cid27cid11cid12cid18 cid6 kth bit ibit cid7 cid19 cid6 1 ith bit boundcbit cid7 1 mck creates state 1bit target value counter c sets markers appropriately For counters decremented 22pn boundc times polynomial number times c Cd value ﬁrst set 22pn reach target value boundc The value 22pn corresponds unique bit mcpn decrements forced setting execution mode appropriate decck βinitc def initc dec c22pn boundc mcpn For example set counter c value 22pn n 2 counter ﬁrst set value 22pn decremented n 2 times Doubleexponential counters initial values 22pn n 2 22pn 2 22pn number effects type βdecc k βﬁlterc k polynomial In case conﬁguration cid2q νcid3 Mα represented belief state denoted q ν The construction P faithful sense pair conﬁgurations cid2q νcid3 cid2q cid19cid7 cid19 cid18 cid18 q cid11 νcid11 cid6 Res cid11 νcid11cid3 Mα ˆδ νcid11 cid11 cid2 q iff cid3 cid6 πpadoa1πpadoa2πpad πpadoan πpad q ν ˆδ extended transition function NFAC Mα Appendix B The subsequence πpad long sequence operators ocid13 odec oﬂag oﬁlter oreplace oinit guarantees belief states updated respect NFAC Indeed suﬃces deﬁne πpad 2N N Q ΠcC 1 boundc repetitions cid2ocid13 oinit oﬂag πﬁlter oreplacecid3 πﬁlter sequence 1 pn repetitions oﬁlter Therefore P valid linear plan iff LMα cid16 Σ iff M rejects ω Since 2EXPSPACE closed complementation planpolinear 2EXPSPACEhard cid3 cid2q νcid3 a1 cid7 Finally combining simulation counters doubleexponential capacity reductions partiallyobservable problems Theorem 8 obtain Theorem 10 For k cid6 0 planpobranchk 2EXPSPACEhard Hence planpobranchk planpobranch 2EXPSPACEcomplete 10 Problems modal formulae polynomial plans Turner 61 studies complexity deciding existence plans polynomial length quantiﬁed boolean formulae QBFs He shows deciding existence linear plans polynomial length fullyobservable problems 264 B Bonet Artiﬁcial Intelligence 174 2010 245269 Σ P 3 deciding existence contingent plans polynomial length PSPACEcomplete problems partial observability However Turner uses different representation language based factored rela tions states With representation language applicability actions decided eﬃciently Turner results translate Σ P 2 completeness checking existence linear plans fullyobservable problems Following ideas Turner study complexity checking existence plans polynomial length problems modal formulae complexity checking existence linear plans arbitrary length problems modal formulae Partiallyobservable problems modal formulae currently predominant automated planning important consider special case 101 Plans polynomial length problems modal formulae Let begin formal deﬁnition decision problems considered Let qn polynomial A class P planning problems valid plans polynomial length modulo q iff problem P P valid plan length qP recall length branching plan height Since q ﬁxed consider decision problems respect q However remove dependency deﬁning following decision problems planfobranchlenPLk def cid2P 1N cid3 P FOPPL kplan length N def cid2P 1N 1kcid3 P FOPPL kplan length N planfobranchlenPL planpobranchlenPLk def cid2P 1N cid3 P POPPL kplan length N def cid2P 1N 1kcid3 P POPPL kplan length N planpobranchlenPL FOPPL POPPL denote class planning problem observability modal formulae partial observability modal formulae respectively Observe integers N k written unary Thus example need check problem P FOPPL valid kplan length qP check cid2P 1qP cid3 planfobranchlenPLk Therefore function input cid2P cid3 outputs cid2P 1qP cid3 polynomialtime reduction problem deciding existence kplan polynomial length modulo q planfobranchlenPLk We planfobranchlenPLk planpobranchlenPLk Σ P 2k2complete planfo branchlenPL planpobranchlenPL PSPACEcomplete Consider fullyobservable problem P cid2D I G O cid3 modal formulae ﬁxed planning horizon N integer k As usual SATbased approaches planning 36 encode problem P propositional theory proposi tions refer operators ﬂuents P tagged time indices We use propositions ft denote truth value ﬂuent f time t propositions ot denote application operators time t There eﬃcient translations use cid21log O cid22 propositions represent operators dive tedious details We use formula preo f 1 free variables ﬂuents f tagged time 1 denote precondition operator o formula dyno f 1 f 2 free variables ﬂuents tagged times 1 2 denote effects operator o For example o cid2p qcid3 preo p1 dyno f cid16q f 2 f 1 q2 These lowlevel formulae collected following formulae cid4 cid12 Ψpreo1 f 1 oO Ψdyno1 f 1 f 2 cid6 cid7 o1 o preco f 1 cid12 cid6 cid7 o1 o dyno f 1 f 2 oO free variables operators time 1 ﬂuents time 1 2 The notation Ψpreot ft Ψdynot ft ft1 refers substitution propositions o1 ft ft1 respectively Finally let It Gt refer formulae initial goal situations tagged time t f 1 f 2 ot We decision problem P encoded QBFs As example let begin formula tells linear plan length 1 P That action applied initial state generates goal state This formula o1 f 1 f 2 cid7 I1 Ψpreo1 f 1 I1 Ψdyno1 f 1 f 2 G 2 cid7cid22 cid21cid6 cid6 I1 Ψpreo1 f 1 valid o1 applicable initial state I1 Ψdyno1 f 1 f 2 G 2 valid state result application o1 goal state Likewise following formula tells plan makes observation ﬁrst segment operators second operator o1o2 f 1 f 2 f 3o3 f 4 cid7 I1 Ψpreo1 f 1 cid7 I1 Ψdyno1 f 1 f 2 Ψpreo2 f 2 cid21cid6 cid6 B Bonet Artiﬁcial Intelligence 174 2010 245269 265 cid6 cid6 cid7 I1 Ψdyno1 f 1 f 2 Ψdyno2 f 2 f 3 Ψpreo3 f 3 I1 Ψdyno1 f 1 f 2 Ψdyno2 f 2 f 3 Ψdyno3 f 3 f 4 G 4 cid7cid22 If assume existence noops formula determines existence 1plan ﬁrst segment length 2 second segment length 1 determines existence linear plan length 2 If want check existence linear plan length N use o1 oN f 1 f N1 cid7 I1 Ψpreo1 f 1 cid7 I1 Ψdyno1 f 1 f 2 Ψpreo2 f 2 cid21cid6 cid6 cid6 cid6 cid7 I1 Ψdyno1 f 1 f 2 ΨdynoN1 f N1 f N ΨpreoN f N I1 Ψdyno1 f 1 f 2 ΨdynoN f N f N1 G N1 cid7cid22 In general want check existence kplan length N use PlanFOk N o1 oN f 1 f N1 okN1 ok1N fkN2 fk1N1Ψ Φ formula Ψ o1 ok1N f 1 fk1N1 conjunction implications examples Φo1 ok1N veriﬁes number nonnoop operators equal N additional propositions order polynomial size k N Theorem 11 For k cid6 0 planfobranchlenPLk Σ P 2k2complete inclusion note PlanFOk N 2k 2 alternations Hence given instance Proof For planfobranchlenPLk k constant construct polynomial time formula PlanFOk N decision algorithm Σ P cid2P 1N cid3 It remains hardness We k 1 proof general k similar Consider formula Φ x1 y1x2 y2Ψ We need construct fullyobservable problem P size polynomial Φ P valid 1plan iff Φ valid Since Φ 4 quantiﬁers implies hardness Σ P 4 2k2 problems Without loss generality assume xi yi boolean variables x1 1x2 2Ψ The problem P propositions x x1 set proposition y j x 1 y2 2 y2 y1 y1 2x2 x1 2 1 1 x2 Φ j j s variable denote truth value j variable denotes truth value The initial cid4 Ψ respectively The operators y1 y2 goal states P deﬁned I def j y def j G x j s j j y cid4 cid6 cid6 cid6 cid6 set set set set x1 1 T x2 1 T x1 2 T x2 2 T cid7 cid7 cid7 cid7 def def def def cid2 s1 1 s1 1 cid3 x1 1 s2 1 s1 1 s2 1 x2 1 cid2 s1 2 s2 1 s1 2 cid3 x1 2 s2 2 s1 2 s2 2 x2 2 cid7 cid7 y j 1 y j 1 y j 2 y j 2 2cid12 cid6 j1 2cid12 cid6 j1 cid7 cid7 cid7 cid7 cid6 cid6 cid6 cid6 set set set set x1 1 F x2 1 F x1 2 F x2 2 F j j s cid2 def cid3 x1 1 1 s1 1 s1 def s2 1 s1 1 s2 1 x2 1 def def cid2 s1 2 s2 1 s1 2 cid3 x1 2 s2 2 s1 2 s2 2 x2 2 cid7 cid7 y j 1 y j 1 y j 2 y j 2 2cid12 cid6 j1 2cid12 cid6 j1 We claim Φ valid iff P valid 1plan The necessity direct For suﬃciency assume P valid 1plan By construction operators need applied order set values x1 2 Let consider 4 possible positions branch point observation 2 x2 1 x1 1 x2 Case 1 x1 ys Since plan valid means Φcid11 x1 1 set Since branch point value xs set observing values 2x2 2Ψ valid Clearly Φcid11 Φ y1 1 This case similar previous corresponds Φcid11 1 set x2 formula 1 y1 2 y2 1 y2 1x1 1x2 2 Case 2 x1 operators setx1 1 set values ys Case 3 x2 1 set x1 2 Since operators x2 1 nondeterministically set value y1s value x j 2 depend value previous variables Ψ valid Case 4 x1 2 set x2 2 depend values Since plan valid means Φcid11 x1 2 depend values y1s 2Ψ x2 2 1 y2 2 y2 y1 y1 1x1 1x2 2 This means value x1 1 2 value x2 valid Clearly Φcid11 Φ In cases Φ valid theorem holds cid3 266 B Bonet Artiﬁcial Intelligence 174 2010 245269 Theorem 12 planfobranchlenPL PSPACEcomplete Proof The problem deciding validity QBFs PSPACEcomplete Given input cid2P 1N 1kcid3 construct formula PlanFOk N polynomial time N k written unary feed QBF solver P kplan length N iff formula valid Therefore planfobranchlenPL reduced qbf inclusion For hardness let Φ QBF starting existential quantiﬁer 2k 2 alternations N existential variables Construct problem P proof Theorem 11 Then Φ valid iff cid2P 1N 1kcid3 planfobranchlenPL If Φ start existential quantiﬁer number alternations 2 add dummy variables quantiﬁers cid3 Let P cid2D I G O Z cid3 planning problem partial observability modal formulae The ﬂuent symbols observable unobservable partitioned observables Z unobservables D Z Let denote f Z ﬂuents time t The existence linear plan length N decided QBF form t f U t cid6 o1 oN f Z 1 f Z N1 f U 1 f U N1 Ψ cid7 Ψ tells sequence o1 oN valid plan Likewise existence 1plan length N decided cid6 cid7 o1 oN f Z 1 f Z N1 oN1 o2N f Z N1 f Z 2N1 f U 1 f U 2N1 Ψ Φ Ψ Φo1 o2N veriﬁes number nonnoop operators equal N In general existence kplan length N decided QBF PlanPOk N o1 oN f Z 1 f Z N1 okN1 ok1N f Z kN2 f U k1N1 Ψ Φ cid6 cid7 As case fullyobservable problems diﬃcult following results Theorem 13 For k cid6 0 planpobranchlenPLk Σ P 2k2complete planpobranchlenPL PSPACEcomplete Proof The inclusion shown For hardness note fullyobservable problems special instances partially observable problems cid3 102 Plans problems modal formulae Let B subset belief states deﬁned Section 3 o operator By deﬁnition o applicable B applicable b B Therefore o contains modalities o applicable B iff applicable states cid8 bB b Similarly B goal set b B goal beliefs modalities B goal set iff cid8 bB b goal belief In summary existence linear plan problems modalities established considering belief states instead subsets belief states similarly plans bounded branching2 Theorem 14 Deciding existence linear plan restrictions length planning problems modalities EXPSPACEcomplete Similarly deciding existence plan bounded branching restrictions length planning problem modalities EXPSPACEcomplete We think result main reason linear plans considered problems ob servability When modal formulae involved requirements conformance fullyobservable partiallyobservable cases collapse However modal formulae allowed requirements provable different space hierarchy theorems 56 EXPSPACE different 2EXPSPACE 11 Discussion The term conformant refer unobservable planning problems linear solutions In work shown linear plans meaningful partiallyobservable problems conformance thought property plans linearity property models Conformant contingent plans extreme points discrete spectrum solution forms contains plans bounded branching We derived exact complexity results checking existence linear plans plans bounded branching fullyobservable partiallyobservable domains We considered special classes problems 2 Interestingly De Giacomo Vardi 22 EXPSPACEcompleteness result deciding existence linear plans partiallyobservable problems actions deterministic goal speciﬁed Büchi automaton observation traces However class problems explicitly accomodate modal operators type studied work B Bonet Artiﬁcial Intelligence 174 2010 245269 267 plans problems modal formulae plans polynomial length Interestingly problems modal formulae complexity checking existence plans fullyobservable partiallyobservable problems coincide An issue remains open role cyclic plans makes sense talk bounded branching cases At ﬁrst sight simple plan cycles sequence actions linear plan However understanding cyclic plans nondeterministic tasks diﬃcult 55 ready talk cyclic linear plans cyclic plans bounded branching Another interesting technical question answered determine complexity deciding existence polynomial plans problems modal formulae In case direct reduction problem problem deciding validity bounded QBF exist The reason validity modal formulae tested multiple times problem test NPhard One interesting point raised reviewers real need consider modal operators planning language Currently established consensus issue Some researches think current languages modal operators languages extended explicit notions knowledge One strongest arguments inclusion modal operators current planning systems able model certain notions knowledge things encoded proper manner Although partially true I think plenty examples current languages simply expressive translation modalityfree language exponential size This interesting discussion I hope clariﬁed years come understanding knowledge dynamics increases On practical dealt problem computing plans eﬃciently Meuleau Smith 45 propose algorithm works computing plans bounded branching fullyobservable problems computing plans partiallyobservable problems We believe algorithms based heuristic search use methods compactly represent sets states BDDs work partiallyobservable problems Acknowledgements Thanks anonymous reviewers editor interesting challenging comments resulted im proved paper Also thanks Patrik Haslum Héctor Geffner interesting discussions early drafts Appendix A Borodins Theorem The following theorem attributed A Borodin seminal work Chandra Kozen Stockmeyer 13 It generalization ATMs Savitchs Theorem Theorem 15 If M snspace bounded analternation bounded ATM sn cid6 log n M DSPACEansn sn2 Appendix B Extension transition function NFACs cid7 cid6 δ def cid11 νcid3 q cid2q νcid3 cid11 δq Given NFAC M cid2Q Σ δ q0 F Ccid3 construct extended transition function ˆδ maps conﬁgu rations M words subsets conﬁgurations Recall snapshot M tuple cid2q νcid3 q state ν function maps counters values First let extend δ function receives pairs cid2θ acid3 θ snapshot Σ cid13 follows cid2q cid2testc νc boundccid3 cid2testc νc νc 1cid3 q entryc loopc cid16 cid13 q entryc cid13 q loopc cid13 function νc v like ν νc vc v Note numbers conﬁgurations bounded Q ΠcC 1 boundc This transition function extended function ˆδ deﬁned snapshots words Σ subsets snapshots Our goal ˆδcid2q νcid3 ω collection snapshots reached cid2q νcid3 path labeled ω including edges labeled cid13 Thus important compute subset snapshots reachable given cid13 transitions This subset denoted cid13CLOSUREcid2q νcid3 equivalent collection snapshots reached cid2q νcid3 cid13paths cid13path path cid13 transitions Furthermore naturally let cid13CLOSURES S set conﬁgurations θS cid13CLOSUREθ The function ˆδ deﬁned cid8 1 ˆδcid2q νcid3 cid13 def cid13CLOSUREcid2q νcid3 2 For ω Σ Σ ˆδθ ωa def cid13CLOSURES S θ cid11 θ cid11cid11 ˆδθ ω θ cid11 δθ cid11cid11 If θ0 cid2q0 0cid3 initial conﬁguration language LM ω Σ cid2q νcid3 ˆδθ0 ω q F 268 References B Bonet Artiﬁcial Intelligence 174 2010 245269 1 D Bernstein E Hansen S Zilberstein Bounded policy iteration decentralized POMDPs LP Kaelbling A Saﬃottiiba Eds Proc 19th Int Joint Conf Artiﬁcial Intelligence Edinburgh Scotland Professional Book Center 2005 pp 12871292 2 P Bertoli A Cimatti M Roveri P Traverso Strong planning partial observability Artiﬁcial Intelligence 170 45 2006 337384 3 D Bertsekas Dynamic Programming Optimal Control 2 vols Athena Scientiﬁc 1995 4 P Blackburn M Rijke Y Venema Modal Logic Cambridge University Press 2002 5 B Bonet Bounded branching modalities nondeterministic planning D Long S Smith D Borrajo L McCluskey Eds Proc 16th Int Conf Automated Planning Scheduling Ambleside UK AAAI Press 2006 pp 4251 6 B Bonet H Geffner Planning incomplete information heuristic search belief space S Chien S Kambhampati C Knoblock Eds Proc 6th Int Conf Artiﬁcial Intelligence Planning Scheduling Breckenridge CO AAAI Press 2000 pp 5261 7 B Bonet H Geffner Planning heuristic search Artiﬁcial Intelligence 129 12 2001 533 8 B Bonet H Geffner Faster heuristic search algorithms planning uncertainty feedback G Gottlob Ed Proc 18th Int Joint Conf Artiﬁcial Intelligence Acapulco Mexico Morgan Kaufmann 2003 pp 12331238 9 B Bonet H Geffner An algorithm better AO M Veloso S Kambhampati Eds Proc 20th National Conf Artiﬁcial Intelligence Pittsburgh PA AAAI PressMIT Press 2005 pp 13431348 10 D Bryce S Kambhampati DE Smith Planning graph heuristics belief space search J Artiﬁcial Intelligence Res 26 2006 3599 11 T Bylander The computational complexity propositional STRIPS planning Artiﬁcial Intelligence 69 1994 165204 12 AR Cassandra M Littman LP Kaelbling Acting optimally partially observable stochastic domains B HayesRoth R Korf Eds Proc 12th National Conf Artiﬁcial Intelligence Seattle WA AAAI PressMIT Press 1994 pp 10231028 13 A Chandra D Kozen LJ Stockmeyer Alternation J ACM 28 1 1981 114133 14 V Chvatal Mastermind Combinatorica 3 34 1983 325329 15 A Cimatti M Pistore M Roveri P Traverso Weak strong strong cyclic planning symbolic model checking Artiﬁcial Intelligence 147 2003 3584 16 A Cimatti M Roveri P Bertoli Conformant planning symbolic model checking heuristic search Artiﬁcial Intelligence 159 2004 127206 17 D Du K Ko Theory Computational Complexity WileyInterscience New York NY 2000 18 P Erdös C Ranyi On problems information theory Magyar Tud Akad Mat Kut Int Közl 8 1963 229242 19 R Fagin J Halpern Y Moses M Vardi Reasoning Knowledge MIT Press 1995 20 R Fikes N Nilsson STRIPS A new approach application theorem proving problem solving Artiﬁcial Intelligence 1 1971 27120 21 G De Giacomo Y Lespérance HJ Levesque S Sardiña On semantics deliberation indigolog From theory implementation Ann Math Artif Intell 41 12 2004 256299 22 G De Giacomo MY Vardi Automatatheoretic approach planning temporally extended goals S Biundo M Fox Eds Proc 5th European Conf Planning Durham UK Lecture Notes Comput Sci vol 1809 Springer 1999 pp 226238 23 W Goddard Static Mastermind J Combin Math Combin Comput 47 2003 225236 24 RP Goldman MS Boddy Expressive planning explicit knowledge B Drabble Ed Proc 3rd Int Conf Artiﬁcial Intelligence Planning Systems Edinburgh Scotland AAAI Press 1996 pp 110117 25 E Hansen Solving POMDPs searching policy space G Cooper S Moral Eds Proc 14th Conf Uncertainty Artiﬁcial Intelligence Madison WI Morgan Kaufmann 1998 pp 211219 26 E Hansen S Zilberstein LAO A heuristic search algorithm ﬁnds solutions loops Artiﬁcial Intelligence 129 2001 3562 27 P Haslum P Jonsson Some results complexity planning incomplete information S Biundo M Fox Eds Proc 5th European Conf Planning Durham UK Lecture Notes Comput Sci vol 1809 Springer 1999 pp 308318 28 M Helmert The fast downward planning J Artiﬁcial Intelligence Res 26 2006 191246 29 J Hoffmann R Brafman Contingent planning heuristic forward search implicit belief states S Biundo K Myers K Rajan Eds Proc 15th Int Conf Automated Planning Scheduling Monterey CA Morgan Kaufmann 2005 pp 7180 30 J Hoffmann R Brafman Conformant planning heuristic forward search A new approach Artiﬁcial Intelligence 170 2006 507541 31 J Hoffmann B Nebel The FF planning Fast plan generation heuristic search J Artiﬁcial Intelligence Res 14 2001 253302 32 J Hopcroft J Ullman Introduction Automata Theory Languages Computation AddisonWesley 1979 33 J Huang Combining knowledge compilation search conformant probabilistic planning D Long S Smith D Borrajo L McCluskey Eds Proc 16th Int Conf Automated Planning Scheduling Lake District UK AAAI Press 2006 pp 253262 34 GE Hughes MJ Cresswell A New Introduction Modal Logic Routledge 1996 35 LP Kaelbling M Littman AR Cassandra Planning acting partially observable stochastic domains Artiﬁcial Intelligence 101 1999 99134 36 H Kautz B Selman Pushing envelope Planning propositional logic stochastic search W Clanceyuiba D Weld Eds Proc 13th National Conf Artiﬁcial Intelligence Portland OR AAAI PressMIT Press 1996 pp 11941201 37 DE Knuth The Master Mind J Recreational Mathematics 9 19761977 16 38 M Koyama T Lai An optimal Mastermind strategy J Recreational Mathematics 25 1993 251256 39 HJ Levesque What planning presence sensing W Clancey D Weld Eds Proc 13th National Conf Artiﬁcial Intelligence Portland OR AAAI PressMIT Press 1996 pp 11391146 40 HJ Levesque Planning loops LP Kaelbling A Saﬃotti Eds Proc 19th Int Joint Conf Artiﬁcial Intelligence Edinburgh Scotland Profes sional Book Center 2005 pp 509515 41 M Littman Probabilistic propositional planning Representations complexity B Kuipers B Webber Eds Proc 14th National Conf Artiﬁcial Intelligence Providence RI AAAI PressMIT Press 1997 pp 748754 42 C Lusena T Li S Sittinger C Wells J Goldsmith My brain When memory helps K Laskey H Prade Eds Proc 15th Conf Uncertainty Artiﬁcial Intelligence Stockholm Sweden Morgan Kaufmann 1999 pp 374381 43 S Majercik M Littman Maxplan A new approach probabilistic planning R Simmons M Veloso S Smith Eds Proc 4th Int Conf Artiﬁcial Intelligence Planning Systems Pittsburgh PA AAAI Press 1998 pp 8693 44 N Meuleau L Peshkin K Kim LP Kaelbling Learning ﬁnitestate controllers partially observable environments K Laskey H Prade Eds Proc 15th Conf Uncertainty Artiﬁcial Intelligence Stockholm Sweden Morgan Kaufmann 1999 pp 427436 45 N Meuleau D Smith Optimal limited contingency planning C Meek U Kjaerulff Eds Proc 19th Conf Uncertainty Artiﬁcial Intelligence Acapulco Mexico Morgan Kaufmann 2003 pp 417426 46 AR Meyer LJ Stockmeyer The equivalence problem regular expressions squaring requires exponential space Proc 13th Annual IEEE Symposium Switching Automata Theory 1973 pp 125129 47 H Palacios B Bonet A Darwiche H Geffner Pruning conformant plans counting models compiled dDNNF representations S Biundo K Myers K Rajan Eds Proc 15th Int Conf Automated Planning Scheduling Monterey CA AAAI Press 2005 pp 141150 48 H Palacios H Geffner From conformant classical planning Eﬃcient translations eﬃcient M Boddy M Fox S Thiébaux Eds Proc 17th Int Conf Automated Planning Scheduling Providence RI AAAI Press 2007 B Bonet Artiﬁcial Intelligence 174 2010 245269 269 49 CH Papadimitriou Computational Complexity AddisonWesley 1993 50 E Pednault ADL Exploring middle ground strips situation calculus R Brachman HJ Levesque R Reiter Eds Proc 1st Int Conf Principles Knowledge Representation Reasoning Toronto Canada Morgan Kaufmann 1989 pp 324332 51 P Poupart C Boutilier Bounded ﬁnite state controllers Advances Neural Information Processing Systems 16 NIPS 2003 Vancouver Canada MIT Press 2003 52 M Puterman Markov Decision Processes Discrete Stochastic Dynamic Programming John Wiley Sons Inc 1994 53 J Rintanen Complexity planning partial observability S Zilberstein S Koenig J Koehler Eds Proc 14th Int Conf Automated Planning Scheduling Whistler Canada AAAI Press 2004 pp 345354 54 J Rintanen Distance estimates planning discrete belief space DL McGuinness G Ferguson Eds Proc 19th National Conf Artiﬁcial Intelligence San Jose CA AAAI PressMIT Press 2004 pp 525530 55 S Sardiña G De Giacomo Y Lespérance HJ Levesque On limits planning belief states strict uncertainty P Doherty J Mylopou los CA Welty Eds Proc 10th Int Conf Principles Knowledge Representation Reasoning Lake District UK AAAI Press 2006 pp 463471 56 M Sipser Introduction Theory Computation second ed Thomson Course Technology Boston MA 2005 57 D Smith D Weld Conformant graphplan J Mostow C Rich Eds Proc 15th National Conf Artiﬁcial Intelligence Madison WI AAAI PressMIT Press 1998 pp 889896 58 E Sondik The optimal control partially observable Markov decision processes inﬁnite horizon Discounted costs Oper Res 26 2 1978 59 LJ Stockmeyer The polynomial time hierarchy Theoret Comput Sci 3 1977 122 60 Time And Master Mind Time 106 22 December 1 1975 73 61 H Turner Polynomiallength planning spans polynomial hierarchy S Flesca I Giovambattista Eds Proc 8th European Conf Logics Artiﬁcial Intelligence Cosenza Italy Lecture Notes Comput Sci vol 2424 Springer 2002 pp 111124 62 ACC Yao Separating polynomialtime hierarchy oracles Proc 26th Annual Symp Foundations Computer Science Portland OR IEEE Press 1985 pp 110