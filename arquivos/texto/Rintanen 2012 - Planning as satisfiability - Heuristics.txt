Artiﬁcial Intelligence 193 2012 4586 Contents lists available SciVerse ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Planning satisﬁability Heuristics Jussi Rintanen Institute Integrated Intelligent Systems Griﬃth University Queensland Australia r t c l e n f o b s t r c t Article history Received 7 June 2011 Received revised form 2 May 2012 Accepted 9 August 2012 Available online 5 September 2012 Keywords Planning SAT Heuristics 1 Introduction Reduction SAT successful approach solving hard combinatorial problems Artiﬁcial Intelligence science general Most commonly problem instances reduced SAT solved generalpurpose SAT solver Although obvious possibility improving SAT solving process applicationspeciﬁc heuristics rarely successfully In work propose planningspeciﬁc variable selection strategy SAT solving The strategy based generic principles properties plans performance standard planning benchmarks substantially improves generic variable selection heuristics VSIDS lifts level search methods explicit statespace search heuristic search algorithms 2012 Elsevier BV All rights reserved Translation SAT satisﬁability problem classical propositional logic main approaches solving planning problem AI The basic idea ﬁrst presented Kautz Selman 1 consider boundedhorizon planning problem represent values state variables time point propositional variables represent relation consecutive states propositional formula synthesize propositional formula satisﬁable plan given bounded length This idea closely related simulation nondeterministic polynomialtime Turing machines Cooks proof NPhardness SAT 2 Kautz Selmans idea considered theoretical 1996 algorithms SAT developed far planning SAT practical competitive search methods 3 Later SAT extensions major statespace search method computeraided veriﬁcation 4 areas In work investigate SAT solving planning conﬂictdriven clause learning CDCL algorithm 56 currently leading framework SAT solving structured problems Instead standard generic CDCL heuristics VSIDS 7 propose planningspeciﬁc heuristics radically differ generic CDCL heuristics based simple property solutions planning problem satisfy The work motivated need better understand SAT solvers successful solving AI planning reachability problems need opportunity develop powerful problemspeciﬁc heuristics SAT Our heuristic chooses action variables contribute goals subgoals based current partial valuation CDCL algorithm representing tentative plan state sequence corresponding execution The principle extremely simple given subgoal choose action achieves subgoal taken earliest time subgoal remain true Intuitively principle expresses preference short simple plans After choosing action preconditions new subgoals supporting actions way The principle easy implement start goal subgoal backwards step step time point Email address jussicecsanueduau 00043702 matter 2012 Elsevier BV All rights reserved httpdxdoiorg101016jartint201208001 46 J Rintanen Artiﬁcial Intelligence 193 2012 4586 goal false choose actions turn false true time point If action existed plan perform procedure recursively preconditions action subgoals Interestingly turns heuristics based principle far effective ﬁnding plans sophisticated heuristics modern generalpurpose SAT solvers Furthermore naïve application principle leading depthﬁrst backward chaining planning algorithm inside CDCL framework lifts eﬃciency SATbased planning close level best earlier planners use search methods This signiﬁcant result currently best statespace search planners origins work Bonet Geffner 8 use far complex heuristics additional pruning techniques achieve comparable performance The simplicity effectiveness principle immediately suggests additional heuristics obtain eﬃciency improvements Instead ﬁnding motivation heuristics standard benchmarks look generic properties planning problems generic structural properties search trees generated principle We present heuristics ordering new subgoals choosing applicable actions propose scheme replaces pure depthﬁrst backward search directional form search For standard benchmark problems planning additional heuristics lift performance new variable selection scheme We view work step developing eﬃcient SATbased techniques planning related problems modelchecking 4 discreteevent systems diagnosis 9 More advanced heuristics applications likely incorporate features VSIDS including computation weights variables based occurrence recently learned clauses We believe success planner developed work standard planning benchmark problems indication simple structure benchmarks challenging problems need complex variable selection heuristics This observation supported earlier works illustrate scalability typical planners solving combinatorially hard problems 1011 The structure paper follows Section 2 describes background work planning SAT In Section 3 present variable selection scheme planning Section 4 propose additional heuristics Section 5 describes implementation planning based preceding sections earlier works 12 In Section 6 experimentally evaluate planning Section 7 discuss related work concluding paper Section 8 2 Planning satisﬁability 21 Background Reduction SAT problem proposed way solving planning problem 1992 paper Kautz Selman 1 At time algorithms solving SAT problem progressing rapidly 1996 Kautz Selman able planning scale better Graphplan 13 planning systems time 3 These results obtained SAT solvers WalkSat 1415 Tableau 16 The reduction SAT general solution method outlined Kautz Selman dominated SAT approach planning years basis scientiﬁcally commercially successful computeraided veriﬁcation methods form bounded modelchecking 4 In planning community focus shifted heuristic statespace search algorithms proposed Bonet Loerincs Geffner HSP planner starting 1997 178 The decreasing planning researchers SAT time traced factors impractically large size CNF formulas generated standard benchmark problems early encoding schemes high computational cost completing satisﬁability tests horizon lengths shorter shortest plan As proposed Kautz Selman planners sequentially went horizon lengths 0 1 2 reached horizon length formula satisﬁable yielding plan Essentially Kautz Selmans procedure corresponds breadthﬁrst search planners proved plan shortest possible horizon However guaranteeing plans shortest possible horizon unimportant horizon length commonly notions parallel plans coincide relevant plan quality measures sum action costs The notion parallelism correspond actual temporal concurrency possibility reordering parallel actions valid sequential plan 12 viewed way inducing smaller search space The unsatisﬁability proofs avoided parallelized search strategies 18 These speed planning orders magnitude At time compact linearsize encodings proposed Earlier encodings based planning graphs Graphplan 13 quadratic size encoding action mutexes straight forward way binary clauses The linearsize encodings largely eliminated problem excessive memory consumption yielded substantial performance improvements 1912 These developments bridged performance gap SATbased planning explicit statespace search substantially standard benchmarks reduced memory consumption obstacle eﬃcient planning Since mid1990s substantial improvements performance algorithm implementations SAT The SATZ solver Li Anbulagan 20 inﬂuential late 1990s implementation techniques basis eﬃcient planner specialized builtin SATstyle search algorithm 21 Practically eﬃcient SAT solvers 2000 based ideas popularized zChaff solver 7 replaced earlier J Rintanen Artiﬁcial Intelligence 193 2012 4586 47 exclusively DavisPutnamLogemannLoveland procedure 22 related conﬂictdriven clause learning algorithm 56 introduced effective VSIDS heuristic new data structures eﬃcient unit propagation These techniques applied SAT solver work 22 Formalization planning The classical planning problem involves ﬁnding action sequence given initial state goal state The actions deterministic means action current state determine successor state uniquely A state s X 0 1 valuation X ﬁnite set state variables In simplest formalization planning actions pairs cid3p ecid4 p e consistent sets propositional literals X respectively called precondition effects We deﬁne preccid3p ecid4 p Actions form known STRIPS actions historical reasons An action cid3p ecid4 executable cid6 execcid3pecid4s state s s cid5 p For given state s action cid3p ecid4 executable s unique successor state s cid6x sx x X x occur e This means effects true determined s successor state state variables affected action retain values Given initial state I plan reach goal G set literals sequence actions a1 execan execan1 execa2 execa1 I cid5 G cid6 cid5 e s 23 Reduction planning SAT Kautz Selman 1 proposed ﬁnding plans reduction SAT The reduction similar reduction NP Turing machines SAT Cooks proof NPhardness SAT 2 The reduction parameterized horizon length T cid2 0 The value state variable x X time point t 0 T represented propositional variable xt For action t 0 T 1 similarly propositional variable indicating action taken t A given set X state variables initial state I set A actions goals G horizon length T translated formula ΦT ΦT SAT plan horizon 0 T This formula expressed terms propositional variables x0 xT x X a0 aT 1 A For given t cid2 0 valuation x1t xnt X x1 xn represents state time t The valuation propositional variables represents state sequence difference consecutive states corresponds taking zero actions The conditions allowing multiple actions step deﬁned alternative ways 12 For purposes set E executed actions satisﬁes following properties suﬃcient change state s s cid6 execan execan1 execa2 execa1 s ordering 1 s cid5 p cid3p ecid4 E 2 s a1 E These conditions satisﬁed main encodings planning SAT 23 The encodings satisfy conditions 1 speciﬁcally relaxed step semantics encoding Wehrle Rintanen 24 encodings Ogata et al 25 allow precondition action supported parallel actions instead preceding state cid2 To represent planning SAT problem action cid3p ecid4 time point t 0 T 1 mapped formulas le lt 11 These formulas respectively correspond executability condition ﬁrst deﬁnition successor states The second state variables change encoded follows actions taken parallel For state variable x X time point t 0 T 1 cid6 cid5 e cid3p ecid4 E 3 s lp lt cid2 cid6 xt 1 cid3 xt ax 1t ax nt cid4 ax 1 ax n actions x effect explaining possible reasons truth xt 1 xt 1 cid3 xt x 1 t x m t cid4 x 1 x m actions x effect explaining possible reasons falsity xt 1 These formulas called frame axioms allow inferring state variable change actions changing taken Additional constraints usually needed rule solutions dont correspond plan parallel actions serialized For example actions cid3x ycid4 cid3 y xcid4 valid sequential plan taking action ﬁrst falsify precondition In planners use linearsize step semantics encoding Rintanen et al 12 requires additional constraints There component eﬃcient SAT encodings planning logically redundant usually critical eﬃciency invariants 2126 Invariants l l literals express binary dependencies state variables Many standard planning benchmarks represent manyvalued state variables terms Boolean ones typical invariant x1 x2 says manyvalued variable x values 1 2 given time cid6 1 For negative literals l x lt means xt positive literals l x means xt Similarly deﬁne valuation vlt negative literals l x vlt 1 vxt vxt deﬁned The complement l literal l deﬁned x x x x 48 J Rintanen Artiﬁcial Intelligence 193 2012 4586 Initialize v satisfy unit clauses C Extend v unit propagation C level 0 1 procedure CDCLC 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 variable assigned v 17 level 0 v cid10cid5 c c C return false Choose variable x vx undeﬁned Assign vx 1 vx 0 level level 1 Extend v unit propagation C v cid10cid5 c c C return true end Infer new clause c add C Undo assignments x c falsiﬁed decrease level accordingly Fig 1 Outline CDCL algorithm For given set X state variables initial state I set A actions goals G horizon length T compute linear time product T sum sizes X I A G formula ΦT ΦT SAT plan horizon 0 T ΦT includes formulas described unit clause x0 Ix 1 x0 Ix 0 x X lT l G These formulas CNF trivial rewriting A planner tests Φ0 SAT Φ1 SAT Φ2 SAT sequentially tests parallel interleave For later Algorithm B Rintanen et al 12 allocates CPU time different horizon lengths according decreasing geometric series horizon length t 1 gets γ times CPU horizon length t gets ﬁxed γ 0 1 In general parallelized strategies orders magnitudes faster sequential strategy need complete test Φt SAT ﬁnding Φt unsatisﬁable proceeding test Φt1 SAT Since unsatisﬁability tests tend far diﬃcult determining formula satisﬁable dont need completed far important eﬃciently determine satisﬁability unsatisﬁability 24 The CDCL algorithm In section brieﬂy standard conﬂictdriven clause learning CDCL algorithm 5 solving SAT problem This algorithm basis currently leading SAT solvers zChaff family 7 For detailed overview CDCL algorithm implementation standard references 2728 The main loop CDCL algorithm Fig 1 chooses unassigned variable assigns truthvalue performs unit propagation extend current valuation v forced variable assignments directly follow existing valuation unit resolution rule If clauses falsiﬁed new clause prevented considering current valuation derived added clause set This new clause logical consequence original clause set Then assignments undone assigninferlearn cycle repeated The procedure ends clause learned valuation satisfy clauses satisfying valuation The selection decision variable line 7 value line 8 arbitrary compromising cor rectness algorithm based heuristic The currently best generic SAT solvers use different variants successors VSIDS heuristic 7 The heuristic critical eﬃciency CDCL algorithm On lines 3 10 standard unit propagation algorithm run It infers forced assignment variable x clause x l1 ln x l1 ln v cid5 l1 ln The inference new clause line 13 key component CDCL The clause prevent generating unsatisfying assignment leading traversing different search space The search performed CDCL algorithm characterized numbers decisions conﬂicts The number decisions number assignments decision variables number executions lines 7 8 The number conﬂicts number executions line 13 This usually number new clauses learned CDCL implementations learn multiple clauses conﬂict 241 The VSIDS heuristic The VSIDS Variable State Independent Decaying Sum heuristic 7 choosing decision variable CDCL algorithm based weights propositional variables When SAT solving process started weight variable initialized number times occurs input clauses When CDCL algorithm learns new clause weight variable occurring clause increased To decrease importance clauses learned earlier weights variables divided constant regular time intervals The VSIDS heuristic chooses new decision variable unassigned variables maximal weight J Rintanen Artiﬁcial Intelligence 193 2012 4586 49 242 Restarts An important component performance CDCL restarts 729 Line 14 makes CDCL form backtracking long sequences earlier variable assignments remain untouched reduces possibilities ﬁnding satisfying assignment To prevent current SAT solvers perform restart regular intervals example 100 conﬂicts means terminating CDCL algorithm starting beginning retaining learned clauses current variable weights Since variable weights changed previous restart CDCL algorithm different sequence variable assignments moving search different search space For completeness CDCL restarts important assignments considered repeatedly Clause deletion avoid memory overﬂows slow CDCL 7 risks completeness CDCL theoretically guaranteed increasing time interval clause deletion performed This SAT solvers work 3 The heuristic The goal work present new way choosing decision variables lines 7 8 CDCL procedure Fig 1 speciﬁc planning Our proposal affects variable selection doesnt affect correctness completeness CDCL algorithm The main challenge deﬁning variable selection scheme integration CDCL algorithm productive way To achieve variable selection depends initial state goals actions represented input clauses current state execution CDCL algorithm The state execution characterized A current set learned clauses B current partial valuation reﬂecting decisions variable assignments inferences unit propagation restart We restricted variable selection use B SAT solver state current partial valuation The variable selection scheme based following observation goal literals true action precondition literals action true earlier actions alternatively literals true initial state Hence ﬁnd decision variable CDCL algorithm ﬁnd subgoal current state search supported true action initial state More concretely proceed follows The ﬁrst step selecting decision variable ﬁnding earliest time point cid6 t subgoal time t remain true This going backwards t time point t I action making l true taken II l false l true unassigned The possibility initial state time point 0 reached l true needs In case I plan action makes subgoal true case II choose action change l false true cid6 t cid6 1 use decision variable2 In case I recursively ﬁnd support literals precondition t The computation started scratch iteration CDCL procedure particular support subgoal example initial state irrelevant later decision different support needs When subgoals support current partial assignment represents plan The assignment total assigning unassigned action variables false unassigned fact variables value closest preceding time point value Notice scheme selecting decision variable ﬂavor heuristic restriction earliest time points subgoal true corresponding preference short simple plans To ﬁnd satisfying assignment SAT instance subgoal true core scheme focus shortest simplest action sequences achieving This works CDCL partial assignments maintained CDCL algorithm useful information possibilities achieving subgoals Often reaching subgoal l possible time t earlier meaning v cid5 lt 1 lt unassigned useful guess lt true point And possible CDCL algorithm detect quickly leads trying l true later time point instead Example 1 We illustrate search unsupported subgoal selection action problem instance goals b actions X cid3d acid4 Y cid3e dcid4 Z cid3c bcid4 variable b c d e 0 0 0 0 0 1 1 0 0 0 0 2 0 0 5 4 0 3 1 6 1 1 2 Such action necessarily exists l false t cid6 1 This frame axiom l 50 J Rintanen Artiﬁcial Intelligence 193 2012 4586 Empty priority queue l G insert lT queue according mark Z vat 1 procedure supportG A T v 2 Unmark literals 3 4 5 6 queue nonempty Pop lt queue 7 cid6 t 1 t 8 0 9 10 repeat 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 cid6 insert l 1 cid6 1 cid6 insert l 1 1 t end return Z unmarked l cid6 0 vlt cid6 0 cid6 t t t t cid6 cid6 cid6 1 A l effa cid6 preca queue according mark A l effa vat Z Z terminateZ unmarked l cid6 return cleanupZ cid6 preca cid6 cid6 queue according mark Take subgoal The subgoal supported cid6 cid10 0 Earliest time true Fig 2 Computation supports subgoals Consider goal time point 6 The latest time point false 4 true 5 remain true 6 Lets assume X4 unassigned true 5 We choose X4 support a5 use X5 decision literal CDCL algorithm After X5 assigned true need support precondition d time point 4 The new subgoal d change false true time points 2 3 action Y cause change After Y 2 decision literal need support precondition e2 determine actions needed e true initial state remain true time point 2 For second toplevel goal b assume Z 2 assigned true explains change b false true time points 2 3 Since Z s precondition c satisﬁed initial state action required We marked timed variables boldface change false true The procedure Fig 2 implements variable selection scheme described The subprocedure terminate X implements termination condition baseline case terminateZ iff Z 1 ﬁrst action decision variable The subprocedure cleanup X decides identifying action return set Z The baseline implementation returns Z cleanupZ Z In Section 4 consider alternative implementations subprocedures Given goal G actions A horizon length T partial valuation v propositional variables representing planning problem horizon length T procedure supportG A T v return set candidate decision variables The procedure starts inserting goal literals G priority queue The ordering literals queue determines order candidate actions generated In baseline version variable selection scheme deﬁne 0 relation queue acts stack ﬁrst Later consider informed orderings The priority queue stack computation action decision variable force CDCL algorithm form backward chaining depthﬁrst On line 7 subgoal literal lt taken queue The loop lines 10 24 identiﬁes action supports support lt It goes time point t 1 step step earlier time points ﬁnds action supports lt line 11 earliest time point t lt remain true 16 cid6 If action search continue ﬁnding support preconditions action For purpose preconditions inserted priority queue line 13 cid6 If earliest time t cid6 l supported action actions true chosen line 17 This action added set Z line 18 set returned termination lt condition met If termination condition met preconditions action inserted priority queue line 20 The choice line 17 Fig 2 arbitrary ﬁxed example choosing ﬁrst A satisﬁed conditions ﬁxed ordering Intuitively important avoid losing focus CDCL search Similarly ordering subgoal literals priority queue situations strictly order arbitrary similarly ﬁxed reason J Rintanen Artiﬁcial Intelligence 193 2012 4586 51 1 2 3 4 5 6 S supportG A T v S cid10 vat 1 chooseS Found action unassigned xt x X t 1 T vxt vxt 1 unassigned xt minimal t vat 0 A t 0 T 1 unassigned Fig 3 Variable selection planning CDCL algorithm return randomly chosen element S 1 procedure chooserandomS 2 3 4 procedure chooseweightedS 5 return element S highest VSIDS weight ties broken randomly 31 Integration CDCL algorithm Fig 4 Procedures selecting candidate actions The procedure Fig 2 main component variable selection scheme CDCL given Fig 3 action chosen decision variable CDCL algorithm available If available chosen randomly formalized procedure chooserandomS Fig 4 according weights calculated VSIDSstyle heuristics learning new clause formalized procedure chooseweightedS Fig 4 The weight parameter action occurrence increased occurrence learned clause weights divided regular intervals 32 conﬂicts If actions available goals subgoals supported The current valuation typically complete completed assigning unassigned fact variables value predecessor state line 5 assigning unassigned action variables value false line 6 The code Fig 3 replaces VSIDS variable selection heuristic CDCL algorithm Fig 1 This removing lines 7 8 replacing code Fig 3 Note actions inferred unit propagation line 10 CDCL algorithm actions later handled indistinguishably actions chosen heuristic 32 Complexity variable selection algorithm If n state variables horizon length T nT variables represent state variables different time points Since literal inserted priority queue algorithm outermost iteration line 6 goal subgoal nT times total The number iterations inner loop starting line 10 consequently bounded nT 2 The actual runtime algorithm usually lower upper bound A better approximation number iterations outer loop number goals number preconditions actions plan eventually In practice runtime CDCL algorithm heuristic strongly dominated unit propagation similarly CDCL VSIDS computing heuristic takes 5 30 cents total SAT solving time depending properties problem instance 4 Reﬁnements heuristic The variable selection scheme Section 3 heuristics leads powerful planner However experience SAT solvers application SAT solving planning speciﬁcally 21 suggests ﬁxed goal orderings strict backward chaining depthﬁrst search best possible way CDCL In section consider strategies effectively advantage strengths CDCL algorithm First present goalordering heuristic controlling priority queue The order algorithm Fig 2 encounters actions directly determines ordering variables assigned CDCL algorithm assuming ﬁrst action returned Second use heuristic choosing action use achieve subgoal instead choosing arbitrary action Third search strict backward chaining relaxed Backward chaining means selecting action effect x given goal x taking preconditions action new goals actions chosen The search backward chaining proceeds step step earlier time points form backtracking takes place With CDCL SAT algorithms search directional way actions directly supporting current subgoals chosen arbitrarily time points actions earlier The algorithm Fig 2 forced compute complete set candidate actions supporting goals subgoals preconditions randomly choosing action set useful need selective way Next consider possible areas improvement case propose modiﬁcation basic variable selection scheme Section 6 shown lead substantial performance improvements 52 J Rintanen Artiﬁcial Intelligence 193 2012 4586 return S S 1 return true return false 1 procedure terminate0S 2 3 4 5 procedure cleanup0S 6 7 8 procedure terminate1S 9 10 11 12 procedure cleanup1S 13 return Sat S cid2 10 t cid2bound return true return false 41 Goal ordering Fig 5 Different subprocedures selection scheme Using priority queue stack baseline implementation variable selection scheme Section 3 leads depthﬁrst search traversal order children node arbitrarily determined order inserted queue As alternative queue stack considered ordering v orders subgoals l1t1 v l2t2 cid6 cid10 1 mv l1t1 mv l2t2 mv lt deﬁned maximal t cid6 unassigned According ordering l gets higher priority includes case vlt true earlier subgoals The likely plan ﬁrst makes l true followed subgoals Intuitively measure indicator relative ordering actions establishing different preconditions given action cid6 t vlt cid6 cid10 1 Here vlt We tried similar simple orderings experimentally improve planner performance A key property mv measure goal subgoal lt new subgoals l1t 1 lnt 1 higher priority parent lt This lead depthﬁrst search ordering child nodes informed 42 Choice action On line 17 algorithm Fig 2 choice action left open For action calculate score cid6 t number time points following t action taken number time points t variable unassigned Then choose action occurrence minimal score Intuitively score measures constrained candidate actions More constrained actions likely lead inferences early detection contradiction current partial plan 43 Computation actions To plan search directional experimented computing set S ﬁxed number N actions randomly choosing S In framework algorithm Fig 2 means deﬁning terminateS return true S N The initial experiments promising solving diﬃcult problems faster However overall improvement relatively small surprisingly peaked N 2 What happened following For given toplevel goal l G ﬁrst actions chosen supported goals However needed support l included computation continued unsupported toplevel goal Consequently ﬁnal stages ﬁnding support toplevel goal cases selecting supporting actions toplevel goals distracts ﬁnding support l With N 2 distraction small outweigh beneﬁts considering action This analysis led second variant proved powerful We record timestamp t ﬁrst action Then continue ﬁnding N actions stop exit timestamp wouldbe candidate action cid2 t This means deﬁning terminateS true S N t bound bound initialized right line 17 Z bound t cleanupS Sat t bound S With variant obtained substantial overall improvement higher N In experiments N 40 44 Variants planner Later Section 6 refer different variants planner follows based different implementations terminateS cleanupS Fig 5 trivial ordering 0 priority queue leading stack behavior informed ordering v Section 41 The base planner uses uninformed selection sub goals backward chaining Backward chaining enforced computing action supports current subgoal The directed form search obtained computing actions choosing randomly J Rintanen Artiﬁcial Intelligence 193 2012 4586 53 Table 1 List features different planner conﬁgurations Feature Termination Goal ordering Action choice Search base g m w terminate0 cleanup0 terminate1 cleanup1 terminate1 cleanup1 0 v arbitrary informed backward chaining nondirectional chooserandomS nondirectional chooseweightedS chooserandomS according VSIDSstyle weights chooseweightedS Fig 4 The informed action selection based heuristic described Section 42 The different features planner conﬁgured listed Table 1 The feature denotes informed action selection Section 42 feature g ordering goals Section 41 features m w relaxed action selection set actions respectively random choice VSIDS weights The choices choices g choices m w induce 12 different conﬁgurations new heuristic Our planner agw conﬁguration called Mp planner conﬁgured use generic SAT heuristic VSIDS called M Essentially M eﬃcient implementation planner described work 2006 12 The 12 different conﬁgurations planner experimentally compared Section 661 45 Discussion The good performance ﬁxed uninformed variable selection focus particular action sequence Any diversion previously tried sequence consequence clauses learned CDCL This maximizes utility learned clauses leads possibility getting stuck search space void solutions A remedy problem current SAT solvers restarts 7 However deterministic search VSIDSstyle variable action weighting mechanism restarts difference assignment right restart necessarily generated right restart In SAT algorithms preceded VSIDS small randomization selection decision variable avoid generating assignments repeatedly 30 However large diversion previous action sequences makes impossible beneﬁt clauses learned CDCL Hence key problem ﬁnding balance focus recently traversed parts search space pursuing possibilities The ﬂexible depthﬁrst style search Section 43 provides balance focus variation The candidate actions contribute speciﬁc way supporting toplevel goals dont exactly correspond actual plan stages search varying order considered effective way probing mistakes contain 5 Implementation The implementation planner uses techniques introduced earlier works including compact linear size encoding step semantics 12 parallel evaluation strategy implemented Algorithm B 1812 Next different components planner 51 Encoding The step encoding use planners differs traditional encodings respect parallelism Traditional encodings called step encodings earlier works 12 allow set actions parallel imposing total ordering results executable action sequence A suﬃcient condition actions dont interfere action disables parallel action affects conditional effects The traditional way encode condition use action mutexes a1t a2t state interfering actions a1 a2 taken simultaneously In worst case number mutexes quadratic number actions main reason large size traditional encodings The step plans relax step plans requiring total ordering parallel actions There alternative ways implementing substantially relaxed condition 12 The simplest modiﬁcation traditional encodings change action mutexes Instead requiring disablesaffects relation restricted simultaneous actions required relation acyclic 12 There simple encoding linear size actions effects 12 based imposing ﬁxed total ordering actions requiring action disablesaffects later action Further standard planning competition benchmarks disablingaffects relation restricted sets actions mutually contradicting preconditions effects contain small cycles cycles shown computing strongly connected components SCC disabling graph 12 Any cycle contained 54 J Rintanen Artiﬁcial Intelligence 193 2012 4586 SCC SCCs size 1 involved cycle SCCs size 1 action mutexes needed Hence cycles eliminated sets actions mutually contradicting preconditions effects taken parallel Also general linearsize encoding scheme action mutexes improved restricted small SCCs action set For small SCCs auxiliary variables required general encoding easily eliminated Also planner choose general linearsize encoding trivial worstcase quadratic explicit encoding action mutexes require auxiliary variables 12 The better SCC small pairs actions mutually contradictory preconditions effects In summary beneﬁts step encodings traditional step encodings actions al lowed parallel reducing horizon lengths speeding search number complexity action mutexes reduced needed speeding search reducing memory requirements The computation disabling graphs timeconsuming parts frontend planner number actions tens hundreds thousands This number arcs graphs quadratic number actions nodes worst case For 80 cent planning competition instances experimented Section 66 graphs computed 2 seconds 16 instances took 60 seconds This computation highly optimized Naïve implementations slow planner considerably For example instead constructing disabling graph explicitly running Tarjans strongly connected components algorithm eﬃcient generate ﬂy arcs actually followed Tarjans algorithm Explicit generation graph unnecessarily spend substantial amounts time determining existence irrelevant arcs Also compact data structures increase locality memory references decrease number cache misses 52 Invariants An important eﬃcient SAT encodings planning invariants facts hold initial state continue hold number actions taken Computing invariants second planners frontend high overhead The identiﬁcation invariants important types planning problems represented languages like PDDL STRIPS support Boolean state variables What naturally manyvalued state variable higher level languages represented dependent Boolean variables PDDL STRIPS Recognizing explicitly representing dependencies nvalued state variable different values simultaneously critical eﬃciently solving standard benchmark problems SAT As works planning restrict 2literal invariants l l suﬃcient representing important variable dependencies We powerful simple ﬁxpoint algorithm computing invariants 31 Our implementation works grounded problem instance slows number ground actions increases tens hundreds thousands The computation invariants 90 cent planning competition instances Section 66 takes 2 seconds 42 instances takes 60 seconds For largest instances AIRPORTADL VISITALL takes minutes Similarly disabling graphs invariant computation highly optimized minimize cache misses cid6 Our planner simpliﬁes action sets based information given invariants Actions precondition contra dicts invariant valid plan eliminated If literal l invariant occurrences eliminated actions Pairs literals l l invariants equivalent l l value All occurrences literals replaced literal l lcid6 l l cid6 cid6 cid6 53 SAT solver Unlike experiments described earlier article 12 new planner uses SAT solver implementation data structures supporting interleaved solution SAT instances different horizon lengths problem instance inside process thread The solver goes instances roundrobin manner switching instance instance restart The solvers clause database shared SAT instances data structures shared including binary input clauses typically strongly dominate size clause sets represent planning problems As copy binary clauses representing actions invariants time point SAT solver represents clauses parameterized form time parameter 32 This decreases memory consumption substantially reduces number cache misses accessing clauses The CDCL implementation SAT solver conventional It includes VSIDS heuristic alternative heuristic phase selection heuristic RSAT enhance VSIDS 33 watched literal implementation unit propagation zChaff solver 7 We tried different clause learning schemes decided use Last UIP scheme equally good commonly First UIP scheme 28 We restart 60 learned clauses The computation new heuristic relatively expensive substantially VSIDS For small collection hard planning problems substantial search needed SAT solver spent 5976 cent time unit propagation 2254 cent time computing heuristic remaining 177 cent rest CDCL algorithm including learning clauses maintaining clause set These percentages measured gprof proﬁler code instrumented gcc compiler The code compiled function J Rintanen Artiﬁcial Intelligence 193 2012 4586 55 inlining enable measurement function distort relative percentages comparison fully optimized code The main difference SAT solver best generic SAT solvers dont use preprocessor logically simplify clause sets In experiments generic preprocessing techniques slow large clause sets obtained planning extent hamper eﬃcient planning Preprocessing reduce size search space exponentially kind large SAT problems experimented Section 66 relatively short runtimes 30 minutes exponential reductions dont materialize We comment relative eﬃciency SAT solver respect generic SAT solvers Section 64 54 Toplevel planning procedure The toplevel procedure planner solves SAT instances corresponding planning problem different plan lengths The planner implements number alternative strategies The traditional sequential strategy ﬁrst presented Kautz Selman 1 solves SAT problem horizon length 1 ﬁrst formula unsatisﬁable continues horizon lengths 2 3 This procedure corresponds breadthﬁrst search action sequences length n 1 considered proceeding sequences length n It ineffective hardness unsatisﬁable formulas corresponding horizon lengths shortest plan 18 In experiments reported later stated use effective strategy formalized algo rithm B Rintanen 18 γ 09 The algorithm interleaves solution horizon lengths important property satisﬁability test formula horizon length n started completed tests unsatisﬁable formulas lengths n completed This way planner stuck hard satisﬁable formulas Rintanens algorithm B allocates CPU formulas Φ0 Φ1 Φ2 representing different horizon lengths according geometric series formula Φn gets CPU proportional γ n γ constant satisfying 0 γ 1 The SAT problem shortest active horizon length gets 1 γ cent CPU γ 09 10 cent γ 05 50 cent Conceptually algorithm considers inﬁnite number horizon lengths algorithm practical planner solving given time SAT problems 20 horizon lengths As instances shown unsatisﬁable solver started longer horizon lengths Our planners consider horizon lengths 0 5 10 faster slower factor Rintanen 18 shown algorithm B comparison traditional sequential procedure arbitrarily 1 1γ Other toplevel algorithms exist including Rintanens algorithm A 1834 equally splits CPU ﬁxed number SAT solving processes Streeter Smiths algorithms 35 perform form binary search identify satisﬁable formula shortest horizon length Streeter Smiths algorithms require input upper bound horizon length generally available scheduling problems planning Rintanens algorithm A comparable algorithm B overall appears somewhat worse 55 Conjunctive conditional effects Our planner accepts general nontemporal PDDL language 36 The heuristics extended cover language conditional effects disjunctive conditions 37 In experiments reported later include problems conditional effects disjunction The extension heuristic required handle conditional effects simple extension cover disjunction complicated 37 A formula isconjunctive conjunction literals constants cid16 An action conjunctive precondition conjunctive conditional effect φ cid3 l condition φ conjunctive The effect l conditional effect true condition φ true taking action Instead considering literals achieved actions consider achieved conditional effects φ cid3 l actions cid16 cid3 l handling unconditional effects When translating planning problem propositional formula introduce propositional variable conditional effect effects φ cid3 l1 φ cid3 l2 action use propositional variable conditional effects place For example action cid3φ x cid3 y z cid3 wcid4 translated formula auxiliary variables u1 u2 conditional effects follows φt xt u1t u1t yt 1 u1t xt u1t 56 J Rintanen Artiﬁcial Intelligence 193 2012 4586 zt u2t u2t wt 1 u2t zt u2t With ui variables frame axioms cid3 cid4 yt yt 1 u1t trivially turned clauses The propositional variables conditional effects handled heuristic exactly like propositional variables actions 6 Evaluation In experimental work comparison traditional CDCL heuristics VSIDS new heuristics proposed work SATbased planners planners use search methods including explicit statespace search 8 stochastic search space plans 38 Our planner VSIDS decision heuristic corresponding earlier work 12 shown dramatically outperform planners BLACKBOX architecture 39 standard benchmark sets dont include planners comparison3 As goal work new heuristics competitive standard benchmarks planning competition main focus comparison planners SATbased planning generic heuristics best conﬁguration new heuristics agw determined Section 661 This planner Mp In Sections 651 652 653 compare Mp M variant planner uses standard VSIDS decision heuristic number problem classes standard SAT solvers known perform particularly In Section 66 shift focus planning competition benchmarks ﬁrst showing new variable selection heuristic outperformed VSIDS unsatisﬁable formulas Then heuristics behavior satisﬁable formulas far critical planners performance planning competition benchmarks extent new heuristic lifts eﬃciency SAT planning method level best earlier planners Section 66 61 Test material We use problem instances 3 different categories planning problems Next categories pointing limitations 1 We test 1600 problem instances biennial planning competitions 1998 2008 2011 competition 41 represent small large planning problems largest instances having thousands state variables hundreds thousands actions solved quickly planners A detailed list benchmark domains given Table 5 page 67 These problems works classical planning focus including ones evaluating comparing different planners The planning competition domains represent wide range simpliﬁed planning scenarios transportation autonomous systems control networked systems oil pipelines number scenarios stacking unstacking blocks mixing cocktails parking cars The instance sets available commonly planning community informative planner evaluation First domains planners solve instances quickly matter seconds Little information planners scalability asymptotic behavior obtained cases Second 2011 competition domains instances relatively hard planners solving instances domains instances roughly diﬃculty In cases obtain qualitative information planners equally strong somewhat stronger instances given diﬃculty level possible quantify difference asymptotically 2 Of combinatorially harder planning problems earlier best solved generic SAT solvers problems obtained translations hard combinatorial graph problems planning 10 We use problem sets available Bonet web page 3 Other classes small hard problems obtained sampling space planning problems sampling distribution experimentally determined produce hard problems These problems ﬁrst considered 3 None recent published works planning SAT experimental comparison search methods large performance gap BLACKBOX style planners recent statespace search planners LAMA 40 J Rintanen Artiﬁcial Intelligence 193 2012 4586 57 Bylander 42 We use elaborations Bylanders models Rintanen 11 newer model produces solvable instances 43 For ﬁrst class problems use sequence problem instances covers phase transition region easy hard easy instances ﬁxed number state variables varying number actions For second class problems sequence different problem sizes increasing number actions state variables linearly keeping parameters affecting relative diﬃculty constant We instances categories Sections 66 651 652 653 respectively The main point comparison search paradigms benchmarks planning competi tions SAT earlier competitive For combinatorially harder problems demonstrate tradeoff represented new heuristics new heuristic generally SATbased planning VSIDS implemented M planner planners dont use SAT M general strongest planner problems 62 Other planners evaluated In addition SATbased planning generalpurpose heuristics comparison planners dont use SAT The competitive planners ones HSP family planners 8 use explicit statespace search LPGtd planner 38 uses search algorithms search space partial plans explicit statespace search A distinction planners like LPGtd use portfolio algorithms use algorithm To depth evaluation look individual components earlier portfoliobased planners consider impact new planner portfolio Algorithm portfolios 4446 recognized important approach solving hard combinatorial problems different individual algorithms complementary strengths individual algorithms strong Portfolios different ways choosing algorithm based characteristics problem instance hand running algorithms parallel according schedule The planning community small portfolios typically consisting algorithms constituent algorithms selected trial error based performance standard benchmark sets The ﬁrst planner use portfolios BLACKBOX 39 It handcrafted schedules determined SAT solvers run order long Later FF LPGtd twoalgorithm portfolios second algorithm run ﬁrst algorithm terminated ﬁnding plan according termination criterion Lots portfolios possible obtained combining collection search algorithms Some discussed Section 67 In experimental study compare SATbased planners following planners 1 HSP original heuristic statespace search planner Bonet Geffner 178 It implements number search algorithms heuristics based delete relaxations HSP restricts STRIPS subset nontemporal PDDL disjunctive conditions conditional effects We HSP version 20 forward search explicit statespace search additive sum heuristic bestﬁrst search algorithm We w 50 option suggested Bonet Geffner search greedy 2 FF 47 planner uses 2algorithm portfolio adding incomplete local search phase HSPstyle complete search The ﬁrst phase hillclimbing search generation successor states restricted subset generated helpful actions minimize time spent evaluating heuristic value states exhaustive breadthﬁrst search escape plateaus local minima FFs ﬁrst phase uses goal agenda mechanism critical solving Blocks World instances Airport instances little impact The second phase essentially HSP heuristic similarly based delete relaxations different method counting actions required reach goals similar performance The second phase started ﬁrst phase escape local minimum FFs parser parse half instances 2008 TRUCK domain stack overﬂow caused recursive grammar rule instances FFs reach issue affect results experiments 3 LPGtd 38 2algorithm portfolio similarly FF Its ﬁrst stage stochastic local search space partial plans The second stage FFs HSPstyle bestﬁrst search Of algorithms test ﬁrst phase LPGtd uses SAT explicit statespace search heuristics radically different ones planners Similarly HSP LPGtd restricted STRIPS We ran LPGtd default settings preference low runtimes small plans When testing ﬁrst phase nobestfirst option changed restarts setting low default value 1000 use available 1800 seconds giving early The LGPtd binary available limited 10 000 actions allowing run planner number largest instances particular LOGISTICS planner probably solved quickly Similarly hard limit number goal literals binary prevented LGPtd solving number VISITALL instances solved quickly 58 J Rintanen Artiﬁcial Intelligence 193 2012 4586 LPGtd incorrectly claims unsolvability 5 instances PARCPRINTER domain solves easily 4 YAHSP 48 uses FFs heuristic bestﬁrst search algorithm preference actions helpful according FF deﬁnition YAHSP introduces shortcuts search space obtained preﬁxes relaxed plans computed heuristic Unlike FF LPGtd YAHSP consists phase Similarly HSP LPGtd YAHSP supports STRIPS We ran planner default settings Equality incorrectly implemented YAHSPs frontend requiring small modiﬁcations TPP SCANALYZER domain ﬁles See Section 66 details 5 LAMA 40 combines FFs heuristic heuristic landmarks scheme preferring successor states reached helpful actions differs YAHSPs Unlike planners LAMAs preprocessor constructs manyvalued representation Boolean PDDL representation compact higherlevel rep resentation work planners LAMA phase main difference YAHSP addition use aggregate heuristics lack shortcut mechanism The purpose LAMAs landmark heuristic improve quality plans little impact performance scalability 40 LAMA similarly M Mp FF supports PDDL language conditional effects ADL We ran variants LAMA 2008 competition version newer unpublished 2011 competition version respectively LAMA08 LAMA11 Both planners run default settings tuned ﬁnd plans faster ﬁnd good plans advised LAMAs authors Some issues frontend LAMA08 ﬁxed replacing frontend newer version Fast Downward following Malte Helmerts instructions LAMA08 incorrectly reports 6 AIRPORTADL instances unsolvable These planners winners nonoptimal classical planning tracks 2000 2002 2008 2011 compe titions FF LPGtd LAMA08 LAMA11 runnerup 2004 competition YAHSP We include winning planners 2004 2006 competitions LAMA08 successor 2004 winner FD implemented general framework The 2006 winner SGPlan uses specialized solution methods standard benchmark domains Overall planners use frequently experimental comparisons planning algorithms 63 Test equipment setting All experiments run workstations Intel Core i7 3930K CPUs running 42 GHz 32 GB main memory 12 MB L3 cache Linux Mint All planners run single core ﬁve cores busy access shared L3 cache exclusive runs We binaries YAHSP LPGtd 32bit x86 instruction set meant planners use 4 GB memory However planners terminated memory overﬂow cases We observed planners use 32bit 64bit versions 32bit version 20 cent faster likely smaller memory use use 4byte instead 8byte pointers We compiled M Mp HSP FF LAMA source ﬁles use amd64 instruction set allows addressing memory past 4 GB bound The memory limitations relevant planning competition benchmarks experimented Section 66 With LAMA 4 GB memory 61 instances including 20 8 GB LAMA solved 7 instances requiring 4 GB memory 6 ones requiring 8 GB For planners M Mp consideration long horizon lengths instances high numbers actions hundreds thousands meant allocating large amounts memory stopped considering longer horizons soon 10 GB memory allocated This affected dozen problem instances Of instances solved Mp 30 minutes 4 GB memory 71 8 GB 23 For experiments 1800 second time limit instance The 1800 second time limit chosen good understanding relative behavior planners relatively long time horizon allow experiments carried reasonable time As later planners solved instances 10 30 minute marks performance differences showed past 3 minute mark minor importance This suggests 30 minute time limit suﬃcient differentiate planners The reported runtimes include standard phases planner starting parsing PDDL description benchmark ending outputting plan We ran planner problem instance The randomization Section 43 affects runtimes planner different runs different complete runs instances solved instances depending runtimes slightly slightly time limit Of planners ran LPGtd random seed 12345 try seeds The rest planners dont use randomization use pseudorandom generators ﬁxed seed number 64 Conﬁrmation eﬃciency SAT solver implementation To quality implementation SAT solver VSIDS heuristic matches stateofthe art SAT solving compare SAT solver winners applicationindustrial track 2007 2011 J Rintanen Artiﬁcial Intelligence 193 2012 4586 59 Fig 6 Number instances solved different SAT solvers SAT competitions RSAT 334 Lingeling The runtimes solving planning competition problems Section 66 given Fig 6 We translated test problems DIMACS CNF horizon lengths 0 5 10 15 20 1305 solved 180 second time limit instance6 calculated corresponding Algorithm B runtimes γ 09 The Lingeling RSAT runtimes exclude construction CNF formulas planners frontend reason curves completely accurate The times exclude writing reading DIMACS CNF ﬁles With problem instances SAT solver VSIDS decision heuristic outperforms RSAT timeout limits 1800 seconds outperforms Lingeling timeout limits 500 seconds With timeout limits past 500 seconds Lingeling solves instances M A main factor runtime differences preprocessing large SAT instances planners solve instantaneously RSAT Lingeling spend considerable time preprocessing starting search phase Otherwise eﬃciency CDCL implementation level Lingeling RSAT terms number decisions conﬂicts second Because SAT solver preprocessing Lingeling strongly relies solvers behaviors substantially differ Lingelings runtimes higher Ms orders magnitude cases preprocessing pays Lingeling scales better solving instances A peculiarity SAT problems obtained translation standard planning benchmark problems planning competitions contrast SAT problems representing applications extremely large size fact problems solved quickly The largest SAT problems Lingeling solves time bounds explained earlier instance 41 AIRPORT 417 476 propositional variables 929 million clauses instance 26 TRUCKS 926 857 propositional variables 113 million clauses Our planner solves instance 49 AIRPORT 13 840 actions 14 770 state variables completed unsatisﬁability test horizon 65 112 million propositional variables 10823 million clauses plan horizon 85 146 million propositional variables 14154 million clauses The planner solves instance 33 SATELLITE 989 250 actions 5185 state variables plan horizon 20 1989 million propositional variables 6999 million clauses backtrackfree 1450 seconds excluding translation SAT including search effort shorter horizons These extreme cases More typical SAT instances 2 million propositional variables couple million clauses As Sections 652 653 existing planners diﬃculties solving smaller problems complex structure dozens actions state variables For problems SAT instances thousands clauses propositional variables 65 Comparison planners combinatorially hard problems Different approaches planning statespace search different strengths When state space easily completely enumerated number states millions blind explicit statespace search generally strongest approach The SAT approach sensitive length plans advantage small cardinality state space One strength SAT solving hard combinatorial planning problems 4 We RSAT 30 2008 SATeLite preprocessor 5 For blocks world problems horizon lengths 200 6 This suﬃcient determine planners runtimes 1800 seconds γ 09 60 J Rintanen Artiﬁcial Intelligence 193 2012 4586 Table 2 Number Porco et al 10 instances solved different planners 300 seconds Domain clique coloring Hamiltonian kcolorability matching SAT total Instances 600 280 200 480 160 200 1920 Mp 61 64 82 122 69 41 439 M 193 66 71 111 80 78 599 LAMA08 37 1 65 114 35 39 291 FF 42 4 52 54 0 1 153 HSP 23 5 38 54 0 20 140 YAHSP 61 18 54 113 33 0 279 state spaces reach explicit statespace search structure complex captured existing heuristics In section evaluate impact new heuristics solution planning problems We consider translations hard combinatorial search problems planning proposed Porco et al 10 hard instances generated according problem parameters empirically determined hard existing algorithms 11 651 Graph problems Some hardest planning problems include hard combinatorial problems subproblems Although hard combinatorial problems appear implicitly explicitly subproblems planning problems practical relevance interesting study problems isolation Porco et al 10 presented method generating translations NPcomplete problems planning demonstrated graph problems including Clique 3 Coloring Hamiltonian Circuit kColorability Matching SAT According Porco et al 10 planner M general purpose SAT solver search method strongest problems quantify statement We ran planners 300 second time limit summarize results Table 27 Unlike Porco et al experiments instances solved M 1800 seconds use known plan length lower upper bounds distinguish answers timeouts leading M solving half instances ones yes answer Similarly planning problems involve solving hard unsatisﬁable formulas Section 662 VSIDS stronger new heuristics For problems differences minor suspect major differences apparent instances negative answers testing unsatisﬁability suggested results Section 662 Both SATbased planners perform considerably better LAMA FF HSP YAHSP As half problems contained negative preconditions features handled HSP YAHSP eliminated unsupported features running HSP YAHSP We include data LPGtd instances solves second phase borrowed FF 652 Solubility phase transition The discovery relation computational diﬃculty phase transitions relatively abrupt transition solvable unsolvable problem instances parameter changed 4950 great advances understanding diﬃculty structure hard combinatorial problems SAT The hardest instances problem typically parameter range covers phase transition region instances outside region typically easy Essentially phase transition region divides problem instances easy underconstrained hard critically constrained easy overconstrained Phase transitions exist kinds constraintsatisfaction resourceallocation planning problems purest form investigated form models sampling space problem instances In planning phase transitions easyhardeasy patterns ﬁrst observed investigated Bylander 42 The underconstrained instances lots actions consequently lots alternative plans Bylander showed easily solvable simple hillclimbing search overconstrained actions plans Bylander showed plans simple syntactic test critically constrained small number plans diﬃcult ﬁnd The parameter values corresponding critically constrained problems understood terms graph density random graph models deﬁned ratio arcs nodes emergence giant component 51 density increased 11 The critically constrained instances Bylanders related models signiﬁcantly harder planning competition benchmarks Section 66 size instances 20 state variables hard 40 state variables hard 11 In experiments model A 11 generate 4500 instances covers easyhardeasy transition phase transition region The instances 40 state variables actions 3 preconditions 2 effects 7 We results LAMA08 performed substantially better LAMA11 J Rintanen Artiﬁcial Intelligence 193 2012 4586 61 Fig 7 Percentage instances solved phase transition region goal state We test different actionstovariables ratios 175 775 corresponding 70 310 actions step 15 actions For ratio generate 300 instances The results shown Fig 7 As problem instances diﬃcult dont know hardest instances plans Hence comparison concerns relative performance planners instances actionstovariables ratio planner solve median runtimes Most instances ratio 20 corresponding 80 actions trivially unsolvable actions reach goals detected simple syntactic analysis small search Practically instances ratio 40 corresponding 160 actions trivially solvable lots alternative plans search makes progress goals immediately reach The hardest instances ratios M performs solidly Mp LAMA HSP solve moderate percentage fewer instances M big difference percentages solved instances goes 100 number actions reaches 160 The visibly divergent behavior FF solve easy instances 5 minutes The reason hillclimbing search FFs ﬁrst phase pruning helpful actions eliminates actions able reach goals let HSPstyle second phase continue local minima large search exhaustively 12 YAHSP LAMA use helpful actions substantially better performance use helpful actions tiebreaking categorically eliminating nonhelpful consideration 653 Action sequencing Another class hard planning problems similar ﬂavor phase transition problems varies density state transition graph disconnecting initial node goal node 43 In problems solubility instance guaranteed construction ﬁrst generate execution state sequence ﬁxed number state variables changing consecutive states pair consecutive states generate action executable ﬁrst state modiﬁes obtain second state The selection preconditions determines diﬃculty instances terms density graph ﬂexibility actions ordered We experimented instances N state variables 2 state variables changing value consec utive states sample execution N 2 actions 3 effects 2 preconditions effects having effect sample execution N goal literals determine goal state uniquely parameter π 4 termining diﬃculty level We chose π close appears diﬃcult region instances given N 43 Fig 8 gives median runtimes N increased 10 400 95 cent conﬁdence intervals Fig 9 gives percentages solved instances The new heuristic fares worse VSIDS heuristic better LPGtd planners use explicit statespace search The curve depicting performance Mp slightly steep HSP LPGtd FF LAMA YAHSP performance difference 80 100 variables orders magnitude appears increasing The planners roughly performance Except smallest instances FF immediately switches local search algorithm systematic HSPstyle search Similarly additional techniques YAHSP LAMA employ dont substantially help problems performance close HSPs The gap M Mp ﬁrst similar gap Mp rest planners orders magnitude terms median runtimes grows quickly runtimes M grow signiﬁcantly slower 62 J Rintanen Artiﬁcial Intelligence 193 2012 4586 Fig 8 Scalability problems representing action sequencing Fig 9 Scalability problems representing action sequencing 66 Comparison planners competition benchmarks Much experimentation algorithms classical planning problem focused benchmark problems planning competitions Next present results problems We included domains competitions 1998 2011 experimental comparison instances The excluded domains handled exceptionally following If domain competition instances competition harder instances If instances different difference hardness newer instances The domains multiple competitions listed Table 3 We excluded 2000 SCHEDULE domain comparison grounding issues overall simple structure domain high number instances 500 First planners LAMA ground domain quickly Second grounding LAMAs frontend Mp LAMA solve 500 instances seconds spending minutes preprocessing The planner solved grounded instances seconds including preprocessing YAHSP Also LPGtds ﬁrst phase solved series quickly internal limit 10 000 ground actions Some planners slow ground 1998 LOGISTICS instances grounded FFs end running planners FF parse ﬁles 100 000 ground actions parser restriction LAMA slow compute invariants grounded representation Since planners ground instances quickly original ungrounded input Of STRIPS domains 2011 TIDYBOT contains negative preconditions supported HSP We ran HSP modiﬁed version TIDYBOT positive preconditions standard reduction introduces J Rintanen Artiﬁcial Intelligence 193 2012 4586 63 Table 3 Instances excluded comparison Excluded instances Covered 2000 LOGISTICS 2002 ROVERS 2002 FREECELL 2002 SATELLITE 2006 OPENSTACKS 2006 PIPESTANKAGE 2008 ELEVATOR 2008 OPENSTACKS 2008 PARC 2008 PEGSOL 2008 SCANALYZER 2008 SOKOBAN 2008 WOODWORKING 1998 LOGISTICS 2006 ROVERS 2000 FREECELL 2004 SATELLITE 2011 OPENSTACKS 2004 PIPESTANKAGE 2011 ELEVATOR 2011 OPENSTACKS 2011 PARC 2011 PEGSOL 2011 SCANALYZER 2011 SOKOBAN 2011 WOODWORKING Justiﬁcation harder includes old harder harder harder exactly harder harder equally hard equally hard equally hard harder harder Table 4 Impact different features planners performance g ag 1188 1201 13 1213 25 1225 37 m 1376 188 1385 197 1374 186 1404 216 w 1383 195 1399 211 1399 211 1416 228 state variable ˆx state variable x occurs negatively precondition forces ˆx x opposite truthvalues For 1998 MPRIME domain use corrected version adds missing equality test drink action 1998 ASSEMBLYADL uses syntactic feature schematic actions implemented planner frontends We grounded instances domain running planners The implementation equality YAHSP conform PDDL deﬁnition To run YAHSP correctly added equality keyword PDDL requirements list 2006 TPP 2011 SCANALYZER domain ﬁles This forced YAHSP instantiate schema variables object combinations including ones variable instantiated object 661 Comparison different conﬁgurations planner The impact heuristics Section 4 performance variable selection scheme illustrated Table 4 The baseline planner solves 1188 1646 planning competition instances Section 66 30 minutes For conﬁgurations described Table 1 improvement obtained difference number solved instances 1188 The goalordering heuristic Section 41 action choice heuristic Section 42 lead minor improvement ﬁxed goal ordering arbitrary selection actions The replacement strict backward chaining depthﬁrst search directional form search Section 43 substantial improvement performance slightly level VSIDS 662 Comparison VSIDS focus unsatisﬁable formulas We compare new heuristic VSIDS heuristic Almost currently strongest implementations CDCL algorithm use variant VSIDS related heuristic To compare heuristics terms satisﬁable unsatisﬁable formulas emphasis unsatisﬁable ones required proving minimality horizon length set planners use BLACKBOX sequential strategy goes horizon lengths 0 1 2 3 ﬁnds satisﬁable formula For problem classes including planning competition problems runtimes planners conﬁguration strongly dominated unsatisﬁable formulas The results problems summarized Fig 10 The plot shows number problem instances solved ﬁnding plan n seconds VSIDS new heuristic The solver VSIDS solves 10 cent instances 1800 seconds spent solving problem instance With sequential strategy usually computation effort spent solving unsatisﬁable formulas right ﬁrst satisﬁable However later VSIDS weaker new heuristic satisﬁable formulas far important ﬁnding plans 663 Comparison VSIDS terms plan sizes runtimes In Figs 11 12 compare solution times plan sizes VSIDS new heuristic implemented planners M Mp respectively parallel solution strategies dont require completing SAT solving unsatisﬁable formulas Each dot ﬁgures represents problem instance location dot Xaxis 64 J Rintanen Artiﬁcial Intelligence 193 2012 4586 Fig 10 Number instances solved given time sequential strategy Fig 11 Runtimes new heuristic Mp VSIDS M depicts runtime plan size planner VSIDS heuristic location Yaxis planner new heuristic Hence dot diagonal means planners perform equally dots right mean runtime plan size higher VSIDS new heuristic Fig 11 shows vast majority problem instances new heuristic outperforms VSIDS 1 2 orders magnitude VSIDS faster dozen cases factor 10 There overall high variation runtimes CDCL algorithm given instance arbitrariness branching decisions reason general weaker algorithm outperform overall stronger small number cases exactly observed Plans VSIDS average bit longer new heuristic indicated Fig 12 differences relatively small The longer plans redundant actions dont contribute goals preconditions plan eliminated simple postprocessing step 664 Comparison search algorithms We ﬁrst compare planners viewed baseline search algorithms different approaches including planners planner components use standard bestﬁrst search algorithm heuristic additional pruning shortcut preference mechanisms These HSP component algorithms FF LPGtd Then follow rest planners including FF LPGtd LAMA YAHSP enhance J Rintanen Artiﬁcial Intelligence 193 2012 4586 65 Fig 12 Plan sizes new heuristic Mp VSIDS M Fig 13 Number STRIPS instances solved different algorithms baseline HSPstyle search additional techniques Finally look impact planners big picture planning considering algorithm portfolios built individual planners The planners planner components compare based search algorithm heuristic HSP phases FF 47 ﬁrst phase LPGtd 38 The runtimes ﬁrst phase FF goal agenda mechanism mechanism orthogonal features planner equally planner The goal agenda increases number instances solved 1800 seconds 77 critical Blocks World having impact domains Fig 13 illustrates performance planners planner components All outperformed baseline SAT based planner M 2006 12 A remarkable fact M outstanding performance uses generic SAT heuristic completely unaware planning Explicit statespace search similarly heuristic perform extremely poorly problems far states exhaustively 665 Comparison planners Next comparison planners FF LPGtd consist components evaluated previous section LAMA08 LAMA11 YAHSP consist phase employ additional techniques basic heuristic search algorithm A diagram depicting performance M Mp LAMA FF 66 J Rintanen Artiﬁcial Intelligence 193 2012 4586 Fig 14 Number instances solved different planners Fig 15 Number STRIPS instances solved different planners instances given Fig 14 For subclass STRIPS instances including HSP YAHSP LPGtd support STRIPS diagram given Fig 15 The curves cases similar planners solve large fraction problem instances seconds number solved instances increases slowly time limit increased past couple minutes We calculate score sum percentages instances solved domain 30 minutes estimate statistical signiﬁcance scores calculating conﬁdence intervals The conﬁdence intervals calculated bootstrapping procedure hypothesizing planning competition domains instances randomly sampled larger pool similar domains For Mp 95 cent conﬁdence interval upper lower bounds planners calculate intervals difference Mp score obtained bootstrap calculation According calculation difference Mp M signiﬁcant difference FF signiﬁcant small margin Differences Mp LAMA08LAMA11 signiﬁcant according calculation drawing samples domains hypothetical domain pool Mp score higher LAMA11 LAMA11 higher score Mp Our new heuristic improvement VSIDS domains With easiest domains instances improvement modest room improve runtimes dominated preprocessing phase shared planners There domains new heuristic improvement VSIDS With instances OPTICALTELEGRAPH TRUCKS STRIPS ADL new heuristic effective VSIDS number instances VSIDS ﬁnds plan 30 minute time bound new heuristic With BLOCKSWORLD VSIDS heuristic scales clearly better ability quickly shift long horizon lengths completing unsatis ﬁability tests faster With CYBERSECURITY VSIDS 15 50 cent faster equally slower However planners solve instances CYBERSECURITY minute J Rintanen Artiﬁcial Intelligence 193 2012 4586 67 Table 5 Number problems solved 1800 seconds domain Mp M 1998GRID 1998GRIPPER 1998LOGISTICS 1998MOVIE 1998MPRIME 1998MYSTERY 2000BLOCKS 2000FREECELL 2002DEPOTS 2002DRIVERLOG 2002ZENO 2004AIRPORT 2004OPTICALTELEGRAPH 2004PHILOSOPHERS 2004PIPESWORLDTANKAGE 2004PIPESWORLDNOTANKAGE 2004PSRSMALL 2004SATELLITE 2006PATHWAYS 2006ROVERS 2006STORAGE 2006TPP 2006TRUCKS 2008CYBERSECURITY 2011BARMAN 2011ELEVATORS 2011FLOORTILE 2011NOMYSTERY 2011OPENSTACKS 2011PARCPRINTER 2011PARKING 2011PEGSOL 2011SCANALYZER 2011SOKOBAN 2011TIDYBOT 2011TRANSPORT 2011VISITALL 2011WOODWORKING 1998ASSEMBLYADL 2000ELEVATORSIMPLE 2000SCHEDULEADL 2002SATELLITEADL 2004AIRPORTADL 2004OPTICALTELEGRAPHADL 2004PHILOSOPHERSADL 2006TRUCKSADL 2008OPENSTACKSADL total weighted score conﬁdence interval low conﬁdence interval high 5 20 30 30 20 19 102 60 22 20 20 50 14 29 50 50 50 36 30 40 30 30 30 30 20 20 20 20 20 20 20 20 20 20 20 20 20 20 24 150 150 20 50 48 48 29 30 5 20 30 30 20 19 63 45 22 20 20 50 14 29 38 41 50 35 30 40 30 30 21 30 10 20 20 17 0 20 0 20 20 2 17 4 0 20 24 150 150 20 49 39 48 16 18 3 20 30 30 18 18 82 32 22 19 18 48 14 29 11 20 50 35 30 40 25 30 22 30 0 1 20 17 0 20 0 19 13 0 2 0 0 20 23 150 150 20 47 41 48 22 15 1646 47 1416 3906 3482 4279 1304 3436 786 198 2008 5 20 29 30 20 19 54 59 18 20 19 38 3 12 38 44 50 31 28 40 21 30 8 29 17 20 2 13 18 12 20 19 20 13 14 16 20 16 24 149 134 20 31 19 23 17 30 1332 LAMA 2011 5 20 30 30 20 14 95 59 22 20 20 38 14 14 41 44 50 36 28 40 20 30 15 29 20 20 6 18 20 20 20 20 20 19 16 19 7 20 23 150 138 20 45 1 14 14 30 1414 3797 609 414 4048 333 636 FF 5 20 30 30 19 16 80 60 22 16 20 39 13 14 22 36 43 36 20 40 18 28 11 4 0 20 5 4 20 20 8 20 20 17 15 9 4 4 24 150 134 20 30 17 14 11 30 1238 3411 969 012 Overall number cases VSIDS stronger smaller opposite holds domains new heuristic dramatically outperforms VSIDS rest runtimes clear im provement VSIDS As seen earlier number types planning problems ones planning competitions especially smaller combinatorially harder ones CDCL VSIDS continues strongest search method improvements VSIDS type problems planning competitions The new planner compares LAMA11 40 winner nonoptimal nontemporal track 2011 planning competition8 Fig 16 illustrates relative performance LAMA11 planner Mp problem instances terms runtime Fig 17 terms plan size Diagrams comparing runtimes plan sizes domain separately given Appendix A In dozens cases strengths LAMA Mp complementary planner outperforming orders magnitude runtime Also planners cases 8 Note evaluation criterion competition quality plans generated comparison counting number instances solved In 2011 competition problem instances selected participating planners solve 68 J Rintanen Artiﬁcial Intelligence 193 2012 4586 Fig 16 Runtimes Mp LAMA problem instance Fig 17 Plan sizes Mp LAMA problem instance produce longer plans planner Mp vast majority problem instances plan sizes close Of planning competition instances solved Mp LAMA11 average length plans Mp 8172 LAMA11 7293 Earlier strength SATbased planning perceived small combinatorially hard planning problems perception extent conﬁrmed experiments Sections 651 652 653 However newest planners concerning planning competition benchmarks clearly case Fig 18 depict ratio runtimes LAMA11 Mp planning competition instances solved planners plotted numbers actions plans LAMA11 Instances LAMA11 solves faster Mp line corresponding Xaxis 1 instances solves slower line The number instances line roughly equal number dots line Although domains LAMAs relative performance improves diﬃculty terms number action plans increases seen cloud dots area J Rintanen Artiﬁcial Intelligence 193 2012 4586 69 Fig 18 Relative performance LAMA11 Mp increasing plan size 10 1 50 01 trend generally clear domains Mps relative performance LAMA11 improves A plot number state variables number ground actions instance looks similar It fair newest planners strengths SATbased planners longer limited small hard instances cover problems large easy relative size For domains partial explanations performance differences LAMA11 The formalizations domains particularly unfavorable search directions forward search explicit statespace search A typical issue incrementing counter c 1 range l cid4 cid4 u This increment represented u l 1 STRIPS actions precondition c l cid4 u effect c 1 counter value represented separate state variable With forward search representation unproblematic old value counter known actions precondition matching current value c chosen But backward search SAT actions middle plan selecting action necessarily commits value counter The problem previous actions plan compatible values time selecting action generally known actions leading poor action choices essentially bad guesses values counter Domains type counter increments decrements 2000 FREECELL 2011 BARMAN 2011 TRANSPORT 2011 OPENSTACKS counters representing container vehicle capacities availability resources With BARMAN minor modiﬁcation action description involving conditional effects turns domain 10 solved 19 20 solved With TRANSPORT modiﬁcation increases number 4 13 A better representation increments modiﬁcations PDDL level possible SAT level leading substantially smaller SAT instances More generally problem domains low abstraction level offered PDDLSTRIPS forces representation decisions modeling time good search methods bad LPGtd use explicit statespace search forward search ﬁrst phase scales poorly domains OPENSTACKS LPGtd solves OPENSTACKS eﬃciently ability increase horizon length quickly Another domain planners perform poorly differs domains 2011 VISITALL The plans domain extremely long thousands actions possibility parallelize Our planners strategy consider horizon lengths 0 5 10 15 restriction 20 simultaneous horizon lengths diﬃculty prove nontrivial lower bounds horizon lengths mean planner proceeds couple plan steps ﬁnds plans If force planner consider horizon lengths 1000 2000 new heuristic VSIDS ﬁnds plans ﬁrst instances VISITALL quickly little search Very long horizons remain problematic SATbased planners high memory requirements follow need represent actions state variables time point There discrepancy performance differences FF M Table 5 earlier article 12 new results showing difference M FF small 2006 article suggest far bigger difference One factor difference improvements implementations SAT solvers 2006 In 2006 Siege SAT solver 52 dramatically outperformed newer solvers solver Second M considers ﬁfth horizon length 0 5 10 15 2006 paper considered horizon lengths 0 1 2 3 cases far discover easiest satisﬁable formulas 70 J Rintanen Artiﬁcial Intelligence 193 2012 4586 Table 6 Number instances solved 1800 seconds 2planner portfolios Mp M LAMA08 LAMA11 FF Mp 1416 1436 1538 1561 1507 M 1436 1293 1541 1556 1468 LAMA08 LAMA11 1538 1541 1332 1471 1461 1561 1556 1471 1414 1448 Table 7 Number STRIPS instances solved 1800 seconds 2algorithm portfolios Mp M HSP FF1 FF2 LPGTD1 Mp 902 920 966 942 954 941 M 920 781 878 872 894 831 HSP 966 878 665 788 724 812 FF1 942 872 788 503 752 739 Table 8 Number STRIPS instances solved 1800 seconds 2planner portfolios Mp M HSP FF1 FF2 LPGTD1 LAMA08 LAMA11 FF LPGTD YAHSP Mp 902 920 966 942 954 941 1010 1043 991 960 1023 M 920 781 878 872 894 831 1007 1031 944 878 1015 HSP 966 878 665 788 724 812 935 999 847 844 946 FF1 FF2 LPGtd1 LAMA08 LAMA11 942 872 788 503 752 739 907 979 807 829 912 954 894 724 752 648 819 921 977 807 820 912 941 831 812 739 819 612 960 1007 879 744 980 1010 1007 935 907 921 960 885 1003 973 985 982 1043 1031 999 979 977 1007 1003 979 988 1008 1037 FF2 954 894 724 752 648 819 FF 991 944 847 807 807 879 973 988 808 880 969 FF 1507 1468 1461 1448 1238 LPGtd1 941 831 812 739 819 612 LPGtd YAHSP 960 878 844 829 820 744 985 1008 880 766 988 1023 1015 946 912 912 980 982 1037 969 988 892 And ﬁnally data given 2006 paper include problems quickly solved planner giving overly negative impression performance 67 Impact new heuristic portfolios There obvious question performance planner component algorithm portfolio We consider portfolios consist planners run parallel planner getting 50 cent CPU plan returned soon planners ﬁnds Other ways combining planners possible including sequential composition ﬁxed time allocated planner An advantage parallel composition symmetric respect components components delivers solution quickly parallel portfolio We Tables 6 7 8 illustrating 2planner portfolios constructed parallel composition Table 6 lists portfolios planners support PDDL language conditional effects Table 7 lists portfolios baseline search algorithms approach SAT explicit statespace search LPGtd performance data restricted STRIPS instances Table 8 lists planners planner components data similarly restricted STRIPS instances For portfolio tables number problem instances solved 30 minutes The diagonal represents planner run getting 100 percent CPU 30 minutes For row highlight column highest number solved instances M Mp relatively stronger complement planners better considering set instances including ones general PDDL language conditional effects When restricted STRIPS instances LAMA11 generally best complement M Mp cases close LAMA11 The strongest portfolio Mp LAMA11 set instances STRIPS subset With STRIPS instances portfolios close including LAMA11M LAMA11YAHSP MpYAHSP MYAHSP LAMA11LPGtd Overall differences planners terms planning competition instances far smaller classes problems Sections 651 652 653 J Rintanen Artiﬁcial Intelligence 193 2012 4586 71 7 Related work 71 Planning SAT constraint satisfaction All earlier SATbased planners generic SAT solvers VSIDS similar heuristics breadthﬁrst style sequential solving SAT instances different horizon lengths All performance differences earlier planners came SAT solver differences encodings primarily size encodings use additional constraints prune search spaces The bestknown early planner SAT BLACKBOX Kautz Selman 39 Rintanen et al 12 demonstrate step semantics encoding substantially faster BLACKBOX encoding factor 20 Both encodings use deﬁnition parallel plans Results Sideris Dimopoulos 53 indicate newer planners BLACKBOX family implement encodings faster BLACKBOXs twice slow weaker unit propagations Robinson et al 54 propose factored encoding step plans demonstrate substantial speedups encodings BLACKBOX family Other recent works claim improvements Kautz Selman style encodings 5556 demonstrate moderate improvements comparison encodings Rintanen et al Robinson et al The relaxed notion parallel plans planner step semantics 1224 allows shorter horizons smaller formulas step plans leads substantial eﬃciency improvements This parallelized search strategies 57 mean orders magnitudes speedup SATbased planners 72 Planning partially ordered representations Graphplan LPG CPT The Graphplan algorithm 13 uses backward search constrained planning graph structure represents ap proximate upper bound reachability information The action selection GraphPlans search resemble action selection given subgoal l time t choice action reach l restricted actions planning graph level t 1 This constraint action selection shows extraction action sequences exact distance information example BDDbased planning 58 related modelchecking methods data structures repre senting distances planning graph BDDs heuristic work action choice achieving l restricted contents planning graph usually case Graphplan choose arbitrary action l effect Another major difference course heuristic leverages inferences learned clauses CDCL algorithm This main reason heuristic despite extreme simplicity effective substantially complex heuristics explicit statespace search The LPG planner 38 stochastic local search space incomplete plans parallel actions similar SATbased approach LPGs choice actions added current incomplete plan based impact action violations constraints describing solutions A main difference LPG SATbased planning LPG similarly localsearch algorithms SAT use general logical inference restricted form propagation values nonchanging facts time point predecessors successors Vidal Geffner 59 present CPT planner covers classical temporal planning It uses constraint based model viewed instance partialorder causal link POCL framework 60 CPTs partial plans partial valuations variables expressing times actions place As POCL framework planning proceeds identifying ﬂaws suggest possible violations constraints current partial plan posting additional constraints eliminate ﬂaw As LPG heuristics CPT evaluate different ways removing ﬂaws terms distances plan elements related ﬂaws question 73 Planning statespace search Systematic algorithms heuristic search 61 long leading approach problem solving AI use planning problem solving generic highlevel input language limited Bonet et al 17 8 demonstrated power algorithms automatically derived heuristics HSP planner Research quickly focused explicit statespace search guided heuristics derived declarative problem descriptions generic problemindependent manner The HSP family planners evaluate possible successor states order choose likely lead goal states In contrast work demonstrated CDCL framework current partial valuation gives reliable heuristic information actions add current partial plan evaluating action candidates separately simply reading action decision variable current partial valuation While heuristics simpler inferences learning CDCL framework complex explicit state space framework representing different tradeoff resource use Interestingly number states evaluated second planners like LAMA typically order magnitude number decisions action selections Mp generic VSIDSbased CDCL implementations Table 9 gives problem instances Mp LAMA similar relatively high search times numbers state expansions action selections second LAMAs numbers states generated evaluated second considerably higher Of course fundamentally different 72 J Rintanen Artiﬁcial Intelligence 193 2012 4586 Table 9 Rates state evaluations generations LAMA11 action selections decisions Mp Instance 2004 AIRPORT 46 2004 PIPES 36 2004 SATELLITE 36 2006 TRUCKS 12 2011 ELEVATOR 17 LAMA11 time 11730 8808 15056 16252 8302 eval 54 822 14049 17 313 1 669 395 24 254 sec 46737 15950 11499 10 27194 29215 generated sec 249 761 713299 35 689 168 37 026 952 2 101 104 212925 809831 23 704283 227 83016 25 30841 Mp time 11381 6151 1034 6331 6904 decs 40 312 39 963 16 752 139 027 84 347 sec 35220 64970 162012 219597 122171 problem representations Mp LAMA fact decision action selection CDCL context viewed lower level operation state evaluation explicit statespace search numbers directly comparable There resemblance variable selection scheme best supporters minimal paths Lipovetzky Geffner 62 cases directly going preference shortest possible action sequences Our variable selection scheme chooses earliest possible actions respect current partial valuation CDCL algo rithm given subgoal true minimal paths sequences actions constructed backward chaining action supporting preconditions later action best supporters sense value according hmax heuristic lowest Unlike work restriction best supporters pruning technique heuristic leads incompleteness Lipovetzky Geffners framework 62 74 Domainspeciﬁc heuristics SAT solving Not known problemspeciﬁc heuristics SAT solving workings SAT solvers solving planning problems Beame et al 27 demonstrate utility problemspeciﬁc variable selection heuristic clause learning algorithm solving combinatorial problem pebbling formulas leading improvements ﬁnding resolution refutations CDCL Our decision heuristic focuses action variables assigns fact variables stages complete assignment known represent plan Theoretical results indicate eﬃciency CDCL decreased variable assignments restricted subset variables variables suﬃcient determining satisﬁability unsatisﬁability 6364 However results known restrictions SAT solving eﬃciency given proof apply unsatisﬁability proofs limited importance ﬁnding plan having prove optimality plan 8 Conclusions future work The contribution paper simple powerful variable selection strategy clauselearning SAT solvers solve AI planning problems empirical demonstration strategy outperforms VSIDS benchmarks planning competitions With smaller combinatorially harder problems VSIDS continues strongest heuristic A main additional beneﬁt VSIDS variable selection strategy understandable terms planning problem This makes particularly promising features strong largely complementary important features VSIDS suggests ways combine This focus future work Our heuristics ignore aspects action selection traditionally considered important especially early works planning One issue interference different subgoals caused conﬂicts actions fulﬁlling With problems planner perform observed interference issues Handling action selection subgoal interactions informed fashion avenue effective heuristics The main ideas work general easily adapted applications SAT constraint satisfaction reachability example LTL modelchecking 4 diagnosis 9 forms planning example planning complex models time continuous state variables hybrid systems SAT modulo Theories SMT solvers 6568 planning nondeterministic actions partial observability quantiﬁed Boolean formulas 6970 stochastic satisﬁability 71 Acknowledgements We thank Hector Geffner Patrik Haslum comments suggestions early versions paper Blai Bonet providing updated versions HSP 20 planner We thank reviewers valuable comments suggestions helped increase breadth depth experimental evaluation J Rintanen Artiﬁcial Intelligence 193 2012 4586 73 Appendix A Comparisons planning competition domains The diagrams pages compare runtimes plan sizes planners instance instance domains planning competitions 1998 2011 Some diagrams fewer dots indicated Table 5 This instance having exactly runtimes planners typically runtimes close 0 seconds A1 Comparison Mp LAMA runtimes STRIPS benchmarks For runtime comparison included search times planner The relatively long preprocessing times LAMA11 Mp ignored spend lot time ﬁnding invariants radically different algorithms task LAMAs preprocessor generally slower scales somewhat better Mp large instances 74 J Rintanen Artiﬁcial Intelligence 193 2012 4586 J Rintanen Artiﬁcial Intelligence 193 2012 4586 75 76 J Rintanen Artiﬁcial Intelligence 193 2012 4586 A2 Comparison Mp LAMA runtimes ADL benchmarks A3 Comparison Mp LAMA plan sizes STRIPS benchmarks J Rintanen Artiﬁcial Intelligence 193 2012 4586 77 78 J Rintanen Artiﬁcial Intelligence 193 2012 4586 J Rintanen Artiﬁcial Intelligence 193 2012 4586 79 80 J Rintanen Artiﬁcial Intelligence 193 2012 4586 A4 Comparison Mp LAMA plan sizes ADL benchmarks A5 Comparison Mp M runtimes STRIPS benchmarks J Rintanen Artiﬁcial Intelligence 193 2012 4586 81 82 J Rintanen Artiﬁcial Intelligence 193 2012 4586 J Rintanen Artiﬁcial Intelligence 193 2012 4586 83 84 J Rintanen Artiﬁcial Intelligence 193 2012 4586 A6 Comparison Mp M runtimes ADL benchmarks J Rintanen Artiﬁcial Intelligence 193 2012 4586 85 References 1 H Kautz B Selman Planning satisﬁability B Neumann Ed Proceedings 10th European Conference Artiﬁcial Intelligence John Wiley Sons 1992 pp 359363 2 SA Cook The complexity theorem proving procedures Proceedings Third Annual ACM Symposium Theory Computing pp 151158 3 H Kautz B Selman Pushing envelope planning propositional logic stochastic search Proceedings 13th National Conference Artiﬁcial Intelligence 8th Innovative Applications Artiﬁcial Intelligence Conference AAAI Press 1996 pp 11941201 4 A Biere A Cimatti EM Clarke Y Zhu Symbolic model checking BDDs WR Cleaveland Ed Tools Algorithms Construction Analysis Systems Proceedings 5th International Conference TACAS99 Lecture Notes Computer Science vol 1579 SpringerVerlag 1999 pp 193207 5 JP MarquesSilva KA Sakallah GRASP search algorithm propositional satisﬁability IEEE Transactions Computers 48 1999 506521 6 RJ Bayardo Jr RC Schrag Using CSP lookback techniques solve realworld SAT instances Proceedings 14th National Conference Artiﬁcial Intelligence AAAI97 9th Innovative Applications Artiﬁcial Intelligence Conference IAAI97 pp 203208 7 MW Moskewicz CF Madigan Y Zhao L Zhang S Malik Chaff engineering eﬃcient SAT solver Proceedings 38th ACMIEEE Design Automation Conference DAC01 ACM Press 2001 pp 530535 8 B Bonet H Geffner Planning heuristic search Artiﬁcial Intelligence 129 2001 533 9 A Grastien Anbulagan J Rintanen E Kelareva Diagnosis discreteevent systems satisﬁability algorithms Proceedings 22nd AAAI Conference Artiﬁcial Intelligence AAAI07 AAAI Press 2007 pp 305310 10 A Porco A Machado B Bonet Automatic polytime reductions NP problems fragment STRIPS ICAPS 2011 Proceedings Twenty First International Conference Automated Planning Scheduling pp 178185 11 J Rintanen Phase transitions classical planning experimental study D Dubois CA Welty MA Williams Eds Principles Knowledge Representation Reasoning Proceedings Ninth International Conference KR 2004 AAAI Press 2004 pp 710719 12 J Rintanen K Heljanko I Niemelä Planning satisﬁability parallel plans algorithms plan search Artiﬁcial Intelligence 170 2006 10311080 13 AL Blum ML Furst Fast planning planning graph analysis Artiﬁcial Intelligence 90 1997 281300 14 B Selman HA Kautz B Cohen Noise strategies improving local search Proceedings 19th National Conference Artiﬁcial Intelligence AAAI2004 16th Conference Innovative Applications Artiﬁcial Intelligence IAAI2004 AAAI Press 1994 pp 337343 15 B Selman HA Kautz B Cohen Local search strategies satisﬁability testing DIMACS Series Discrete Mathematics Theoretical Computer Science vol 25 1996 pp 521531 16 JM Crawford LD Auton Experimental results crossover point random 3SAT Artiﬁcial Intelligence 81 1996 3157 17 B Bonet G Loerincs H Geffner A robust fast action selection mechanism planning Proceedings 14th National Conference Artiﬁcial Intelligence AAAI97 9th Innovative Applications Artiﬁcial Intelligence Conference IAAI97 AAAI Press 1997 pp 714719 18 J Rintanen Evaluation strategies planning satisﬁability R López Mántaras L Saitta Eds ECAI 2004 Proceedings 16th European Conference Artiﬁcial Intelligence IOS Press 2004 pp 682687 19 J Rintanen K Heljanko I Niemelä Parallel encodings classical planning satisﬁability JJ Alferes J Leite Eds Logics Artiﬁcial Intelligence 9th European Conference JELIA 2004 Proceedings Lisbon Portugal September 2730 2004 Lecture Notes Computer Science vol 3229 Springer Verlag 2004 pp 307319 20 CM Li Anbulagan Heuristics based unit propagation satisﬁability problems M Pollack Ed Proceedings 15th International Joint Conference Artiﬁcial Intelligence Morgan Kaufmann Publishers 1997 pp 366371 21 J Rintanen A planning algorithm based directional search AG Cohn LK Schubert SC Shapiro Eds Principles Knowledge Representa tion Reasoning Proceedings Sixth International Conference KR98 Morgan Kaufmann Publishers 1998 pp 617624 22 M Davis G Logemann D Loveland A machine program theorem proving Communications ACM 5 1962 394397 23 J Rintanen Heuristics planning SAT D Cohen Ed Principles Practice Constraint Programming CP 2010 16th International Conference CP 2010 Proceedings St Andrews Scotland September 2010 Lecture Notes Computer Science vol 6308 SpringerVerlag 2010 pp 414428 24 M Wehrle J Rintanen Planning satisﬁability relaxed step plans M Orgun J Thornton Eds PAI 2007 Advances Artiﬁcial Intelligence 20th Australian Joint Conference Artiﬁcial Intelligence Proceedings Surfers Paradise Gold Coast Australia December 26 2007 Lecture Notes Computer Science vol 4830 2007 pp 244253 25 S Ogata T Tsuchiya T Kikuno SATbased veriﬁcation safe Petri nets F Wang Ed Automated Technology Veriﬁcation Analysis Second International Conference ATVA 2004 Proceedings Taipei Taiwan ROC October 31November 3 2004 Lecture Notes Computer Science vol 3299 SpringerVerlag 2004 pp 7992 26 A Gerevini L Schubert Inferring state constraints domainindependent planning Proceedings 15th National Conference Artiﬁcial Intelligence AAAI98 10th Conference Innovative Applications Artiﬁcial Intelligence IAAI98 AAAI Press 1998 pp 905912 27 P Beame H Kautz A Sabharwal Towards understanding harnessing potential clause learning Journal Artiﬁcial Intelligence Research 22 2004 319351 28 DG Mitchell A SAT solver primer EATCS Bulletin 85 2005 112133 29 CP Gomes B Selman N Crato H Kautz Heavytailed phenomena satisﬁability constraint satisfaction problems Journal Automated Reason ing 24 2000 67100 30 CP Gomes B Selman H Kautz Boosting combinatorial search randomization Proceedings 14th National Conference Artiﬁcial Intelligence AAAI97 9th Innovative Applications Artiﬁcial Intelligence Conference IAAI97 AAAI Press 1998 pp 431437 31 J Rintanen Regression classical nondeterministic planning M Ghallab CD Spyropoulos N Fakotakis Eds ECAI 2008 Proceedings 18th European Conference Artiﬁcial Intelligence IOS Press 2008 pp 568571 32 J Rintanen Engineering eﬃcient planners SAT ECAI 2012 Proceedings 20th European Conference Artiﬁcial Intelligence IOS Press 2012 pp 684689 33 K Pipatsrisawat A Darwiche A lightweight component caching scheme satisﬁability solvers J MarquesSilva KA Sakallah Eds Proceedings 8th International Conference Theory Applications Satisﬁability Testing SAT2007 Lecture Notes Computer Science vol 4501 SpringerVerlag 2007 pp 294299 34 E Zarpas Simple eﬃcient improvements SAT based bounded model checking AJ Hu AK Martin Eds Formal Methods ComputerAided Design 5th International Conference FMCAD 2004 Proceedings Austin Texas USA November 1517 2004 Lecture Notes Computer Science vol 3312 SpringerVerlag 2004 pp 174185 35 M Streeter SF Smith Using decision procedures eﬃciently optimization M Boddy M Fox S Thiébaux Eds ICAPS 2007 Proceedings Seventeenth International Conference Automated Planning Scheduling pp 312319 36 D McDermott The planning domain deﬁnition language Technical Report CVC TR98003DCS TR1165 Yale Center Computational Vision Control Yale University 1998 37 J Rintanen Heuristics planning SAT expressive action deﬁnitions ICAPS 2011 Proceedings TwentyFirst International Conference Automated Planning Scheduling AAAI Press 2011 pp 210217 86 J Rintanen Artiﬁcial Intelligence 193 2012 4586 38 A Gerevini I Serina Planning propositional CSP Walksat local search techniques action graphs Constraints Journal 8 2003 389413 39 H Kautz B Selman Unifying SATbased graphbased planning T Dean Ed Proceedings 16th International Joint Conference Artiﬁcial Intelligence Morgan Kaufmann Publishers 1999 pp 318325 40 S Richter M Westphal The LAMA planner guiding costbased anytime planning landmarks Journal Artiﬁcial Intelligence Research 39 2010 127177 41 ICAPS httpwwwicapsconferenceorg 2010 42 T Bylander A probabilistic analysis propositional STRIPS planning Artiﬁcial Intelligence 81 1996 241271 43 J Rintanen Generation hard solvable planning problems Technical Report TRCS1203 Research School Computer Science The Australian Na tional University 2012 44 BA Huberman RM Lukose T Hogg An economics approach hard computational problems Science 275 1997 5154 45 CP Gomes B Selman Algorithm portfolio design theory vs practice Proceedings Thirteenth Conference Uncertainty Artiﬁcial Intelli gence UAI97 Morgan Kaufmann Publishers 1997 pp 190197 46 CP Gomes B Selman Algorithm portfolios Journal Artiﬁcial Intelligence Research 126 2001 4362 47 J Hoffmann B Nebel The FF planning fast plan generation heuristic search Journal Artiﬁcial Intelligence Research 14 2001 253302 48 V Vidal A lookahead strategy heuristic search planning S Zilberstein J Koehler S Koenig Eds ICAPS 2004 Proceedings Fourteenth International Conference Automated Planning Scheduling AAAI Press 2004 pp 150160 49 P Cheeseman B Kanefsky WM Taylor Where hard problems J Mylopoulos Ed Proceedings 12th International Joint Conference Artiﬁcial Intelligence Morgan Kaufmann Publishers 1991 pp 331337 50 D Mitchell B Selman H Levesque Hard easy distributions SAT problems W Swartout Ed Proceedings 10th National Conference Artiﬁcial Intelligence The MIT Press 1992 pp 459465 51 B Bollobás Random Graphs Academic Press 1985 52 L Ryan Eﬃcient algorithms clauselearning SAT solvers Masters thesis Simon Fraser University 2003 53 A Sideris Y Dimopoulos Constraint propagation propositional planning ICAPS 2010 Proceedings Twentieth International Conference Automated Planning Scheduling AAAI Press 2010 pp 153160 54 N Robinson C Gretton DN Pham A Sattar SATbased parallel planning split representation actions A Gerevini A Howe A Cesta I Refanidis Eds ICAPS 2009 Proceedings Nineteenth International Conference Automated Planning Scheduling AAAI Press 2009 pp 281288 55 K Ray ML Ginsberg The complexity optimal planning eﬃcient method ﬁnding solutions J Rintanen B Nebel JC Beck E Hansen Eds ICAPS 2008 Proceedings Eighteenth International Conference Automated Planning Scheduling pp 280287 56 R Huang Y Chen W Zhang A novel transition based encoding scheme planning satisﬁability Proceedings 24th AAAI Conference Artiﬁcial Intelligence AAAI10 pp 8994 57 J Rintanen Planning SAT A Biere MJH Heule H van Maaren T Walsh Eds Handbook Satisﬁability Frontiers Artiﬁcial Intelligence Applications vol 185 IOS Press 2009 pp 483504 58 A Cimatti E Giunchiglia F Giunchiglia P Traverso Planning model checking decision procedure AR S Steel R Alami Eds Recent Advances AI Planning Fourth European Conference Planning ECP97 Lecture Notes Computer Science vol 1348 SpringerVerlag 1997 pp 130142 59 V Vidal H Geffner Branching pruning optimal temporal POCL planner based constraint programming Artiﬁcial Intelligence 170 2006 298335 60 DA McAllester D Rosenblitt Systematic nonlinear planning Proceedings 9th National Conference Artiﬁcial Intelligence vol 2 AAAI PressThe MIT Press 1991 pp 634639 61 J Pearl Heuristics Intelligent Search Strategies Computer Problem Solving AddisonWesley Publishing Company 1984 62 N Lipovetzky H Geffner Inference decomposition planning causal consistent chains A Gerevini A Howe A Cesta I Refanidis Eds ICAPS 2009 Proceedings Nineteenth International Conference Automated Planning Scheduling pp 217224 63 A Haken The intractability resolution Theoretical Computer Science 39 1985 297308 64 M Järvisalo T Junttila Limitations restricted branching clause learning Constraints Journal 14 2009 325356 65 M Bozzano R Bruttomesso A Cimatti T Junttila P van Rossum S Schulz R Sebastiani The MathSAT 3 Automated Deduction CADE20 Lecture Notes Computer Science vol 3632 SpringerVerlag 2005 pp 315321 66 G Audemard A Cimatti A Kornilowicz R Sebastiani Bounded model checking timed systems Formal Techniques Networked Dis tributed Systems FORTE 2002 Lecture Notes Computer Science vol 2529 SpringerVerlag 2002 pp 243259 67 N Giorgetti GJ Pappas A Bemporad Bounded model checking hybrid dynamical systems Proceedings 44th IEEE Conference Decision Control European Control Conference 2005 IEEE 2005 pp 672677 68 G Audemard M Bozzano A Cimatti R Sebastiani Verifying industrial hybrid systems MathSAT Electronic Notes Theoretical Computer Sci ence 119 2005 1732 69 J Rintanen Constructing conditional plans theoremprover Journal Artiﬁcial Intelligence Research 10 1999 323352 70 J Rintanen Asymptotically optimal encodings conformant planning QBF Proceedings 22nd AAAI Conference Artiﬁcial Intelligence AAAI07 AAAI Press 2007 pp 10451050 71 SM Majercik ML Littman Contingent planning uncertainty stochastic satisﬁability Artiﬁcial Intelligence 147 2003 119162