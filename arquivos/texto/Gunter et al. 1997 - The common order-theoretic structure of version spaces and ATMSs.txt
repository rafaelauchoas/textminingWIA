Artificial Intelligence 95 1997 357407 Artificial Intelligence The cornrnon ordertheoretic structure version spaces ATMSs Carl A Gunter TeowHin Ngair b Devika Subramanianc Department Computer Science University Pennsylvania 200 South 33rd Street Philadelphia PA 191036389 USA h National University Singapore Singapore c Rice UniversiQ Houston TX USA Received August 1996 Abstract We demonstrate ordertheoretic abstractions useful identifying formalizing relationships representation perform computations seemingly dissimilar AI algorithms sets In particular ordertheoretic exploiting partiallyordered sets satisfy certain special provide efficient properties We use antichains representation version space learning algorithm assumptionbased truth maintenance optimizations ATMS Our analysis allows 1 extend known theory admissibility concept spaces incremental version space merging 2 develop new simpler labelupdate algorithms ATMSs DNF assumption formulas 1997 Published Elsevier Science BV identify analyze concept antichain basic operations Keywords Version spaces ATMS Concept learning Truth maintenance Label update algorithms Antichains Partial orders Admissibility 1 Introduction This paper shows ordertheoretic partial concept antichain provides useful representation abstraction isolation collection primitive operations antichains tion operations representation demonstra efficient key concern We set operations information The primary contribution circumstances information partial Corresponding author Email guntercisupennedu 00043702971700 PII SOOO4370297000337 1997 Published Elsevier Science BV All rights reserved 318 CA Gunter et al Artcial Intelligence 95 1997 357407 basic properties operations devoted paper antichain algebra The description Section 2 remainder algebra The discovery useful algebra expressions For example Codds practical semantically antichain algebra query antichains significant good representation algebra knowledge introduction languages clear database query languages While algebra relations aided development think representation Codds relational recognizing ambitious insights obtained given antichain technique powerful applications ATMSs information expressing representations truth maintenance The records dependencies learning based forming propositions maintaining algebra useful wellknown refining approaches version space concept descriptions manipulating VS algorithm examples This ATMS support parts Section 4 basic ATMS uses Horn clauses base facts Section 5 use extended ATM extends basic ATMS permitting Horn clauses Although cursory structures To antichain partial information examine partial inductive topic Section 3 The second assumptionbased algorithm sets proposition Our discussion studies studies facts disjunctive knowledge VS ATMS extended ATMS representations required ideas embody things common appropriate mathematical needed methods share notations code modules We antichain describing modules end paper Such modules provide ability based antichain facts supporting correctness proofs optimizations An appendix algebra achieves provided algebra obtain account commonality share software algorithms rigorous form addition antichain implementing broken interfaces algebra normal Each treatments partial information representation description techniques problem follows refinement In particular optimization techniques similar pattern First provide mathematical solved ordered structures notion information approach approach pseudocode correctness antichain generalizations results Hirsh provide generalization extended ATMS based ordertheoretic employ common algorithms based use operations antichains The essence given explore basic properties algebra For VS extended ATMS algorithms conclude In particular extend known correctness 3 7 Mellish 181 admissibility described antichain Kleers choose construct terms antichain criteria algorithms algebra rendered VS algorithm algorithms simplification interfaces Once optimization description issues 2 Representing sets antichains One way represent set maintain set elements optimized maintaining list elements Given ordering elements set structure CA Gunter et alArtcial Intelligence 95 1997 357407 359 like balanced predicate ability impossible primitive operations approaches closure properties tree In special circumstances tests set membership This advantage greater represent sets elements implement basic operations efficiently infinite representation sets represented set maintained indirectly flexibility general In section analyze compromise known certain ordertheoretic string To begin like taking balanced introduce represent like testing particular discussion illustrative example suppose maintain circumstances represent order represent large sets way We use predicates sets strings digits supporting operations set binary operations union intersection sets We order digit strings prefix order example 01 prefix 012 013 trees strings costly 001 represent logic capable expressing maintain sets properties strings efficiency use expensive approach depend kinds predicates expect test However like list infinite sets essential elements include elements set Suppose know special fact sets strings pre closed In words s E S sets S s prefix s s E S In case presence need maintain 01 E S 012 013 inferred S In particular represent S set strings S having S prefixes element S element strings sets S prefixes This provides compact infinite sets finitely distinct prefixes represented way To determine string s elements S prefix checking membership possible carry basic operations For example given sets S T represented prefixes S T represent set like S U T This testing membership test elements u E S U T S U T This optimized removing little element u E S U T U proper prefix U The situation complicated terms S T operation S n T calculated S simply checks representation useless For instance S T represent tree elements intersection problem representation S property Even 21 Upper sets lower sets Let turn identifying idea underlying set P binary X 5 y y 5 x implies x y transitive example A poset X 5 x antisymmetric y 3 z implies x 3 z A set S C P said downward closed lower y 5 x implies subset P contains S denoted relation 5 reflexive X 5 y x E S y E S Given set S C P smallest downwardclosed representation employed 360 CA Gunier et ul Artcial Intelligence 95 1997 357407 A lower set Fig 1 A lower subset rP P A B C Note x 5 y denotes x y An example S 1 S Dually S said upward closed upper Fig 1 It easy S downwardclosed pictured It save extra parentheses downward upward closure bind strongly For example 1s n LT ISn lT later assume unary operations settheoretic operations Notation 1 For set S collection collection finite subsets S denoted FinPwr S subsets S denoted Pwr S The propositional atoms distinguished finite consider specific I finite subset A C C collection subsets A elements I ordering taking x y poset question falsehood We focus distinguished Let begin assuming example Let L language representing assumptions Let E Pwrd called environments Environments x 5 y Environments arise later discuss intuition allow upwardclosed A B C D set environments atoms C D meaning sets environments form poset environment ATMS algorithms set assumptions truth derive given conclusion We interested operations sets For example atom A representing contain atom A S A B C D A B C A CD A B D A B AC A D A CD B C D We need smallest elements S S minimal elements test environment X E S Now set minimal elements S x S testing x superset S A C D CA Gunter et dArtificial Intelligence 95 1997 357407 361 Fig 2 Representing upper subset Pwr P lower boundary P A E C D A CD subset ordering boundary representation instance A 5 A B A picture given Fig 2 This represents S boundary set minimal sets represented maximal elements form upper boundary And case version spaces representing subset poset terms upper lower boundary indirectly S case lower boundary In cases working downwardclosed set elements Returning abstract development let element x E S C P maximal S y E S x 3 y implies y X It said minimal S y E S y 5 x implies y x Let denote max S min S respective elements S In finite poset lower upper sets sets maximal represented upper lower boundaries minimal Lemma 2 Let P finite poset suppose S 2 P lowerset S JmaxS IfS If S upper set S TminS 1 2 A generalization result needed later consider similar repre sentations infinite poset Lemma 3 Let P poset suppose S jite subset P Then 1 IS lmaxS 2 TS rminS To Lemma 3 generalization Lemma 2 note lower subset S finite poset finite 1 S S The proof Lemma 3 illustrative issues arise representation infinite sets finite boundaries Proof Let consider similar It clear 1 max S J S So x E 1 S Is y E max S x 3 y Let suppose case x maximal contrary y Then 1 proof 2 362 CA Gunter et dArtificial Intelligence 95 1997 357407 element XI Z x x XI Assuming S built chain elements x xa 5 xi 1 xi xi distinct S x0 maximal x assumption 5 X xi E S j n extend chain additional element conclude x forced S infinite contradicting x 3 x But implies 0 22 Antichains What kinds subsets poset boundaries upper lower subsets Definition 4 Let P 5 poset A subset S c P antichain comparable pair distinct elements notation AntiP contains x y E S x 3 y x y We use set antichains P Lemma 5 Let P finite poset 1 The upwardclosure operation S H r S bijection mapping antichains upwardclosed onetoone subsets P 2 The downwardclosure downwardclosed subsets P operation S ct 1 S bijection antichains The lemma proved demonstrating min max inverses upward closure downward closure respectively 23 Computing basic operations posets antichains The significance bility representing downwardclosed set elements operations relationship operations sets indirectly described Lemma 5 comes possi terms operations antichains Let S T like perform upwardclosed testing set membership S T Aside l Difference T S T S T upper sets I S T S T lower sets l Union S U T S T upper sets lower sets l Heterogeneous intersection 1 U n L T U II L U upper set L lower set l Homogeneous intersection S n T S T upper sets lower sets A notes form operations clarify union intersection It easy check uniformity upper set A similar preservation S T upper set upwardset difference ordinary sections operation taking settheoretic difference A similar consideration apparent lack pair upper sets property holds lower sets However modify upward closure TS T inter holds heterogeneous S T essential CA Gunter et alArtijicial Intelligence 95 1997 357407 363 Fig 3 The lower difference S T antichains S T representing boundary R region R figure lower sets S T upper Our goal mathematical chains represented mathematically efficiently computationally long clear collections given description operations terms anti The description given question computed Let begin operation j S T S T lower sets represented S T S J S T J T We want antichain R set elements x E S easy calculate takes element T turn removes elements S way It closure antichains antichains I R 1 S T This set R shown y E T x 5 y This collection simply dominates Now want helpful difference operation difference representing need denote elements T different symbol We write operation binary operation antichains downward remember represent intended treated S T x E S Vy E T x y superscript 1 intended reminder representation antichains The desired property lower sets manipulated ISTJlSLT Fig 3 provides define picture desired result It possible S I T x E S 1 vy E T x 2 y write x 2 y mean y 5 x TSTTTSTT The union sets easy represent 1 S U 1 T 1 S UT Unfortunately maxima terms If ST antichains essential S UT antichain 364 CA Gunter et al Artijicial Intelligence 95 1997 357407 Fig 4 The lower union antichains S T representing figure boundary R shown lower sets S 7 dark region R pYJGziq Fig 4 pictures desired result Similarly define 1 SUTminSUT 1 JSuT JSuIT tSuT tSuIT Now U upper set L lower set wish calculate lower set generated define upper U L terms boundaries We intersection U l L x E L 1 3y E U y 3 x YL ymJL We deliberately tion intersection similar representation avoid intersection homogeneous symbol n heterogeneous intersec intersection The upper heterogeneous u U L y E U 3x E L y j x satisfies TUL ttunlL Fig 5 provides picture 1 Actually essential include heterogeneous intersection collection antichain operations defined terms difference operation CA Gunter et al Artijicial Intelligence 95 1997 357407 365 U U Fig 5 The lower upper heterogeneous intersection antichains CJ L representing upper set Ii lower set L respectively U L upper boundary RI I e L lower boundary Ru Proposition 6 Let P poset suppose S T antichains P 1 STSSIT 2 SlTS ST Proof We prove equation proof second similar Let x element P let consider means case x E S I S l T By definition x E S means Vz E S I T x 2 z 2 x 6 S T By definition 2 Since S antichain means y E T x 3 y But fact x E S definition x E S 9 T case x z formula x z equivalent 0 The operations U U defined terms difference operations given usual set union intersection operations Proposition 7 Let P poset suppose S T antichains P 1 SUTSTUSnTUTSand sVTSJTUSnTUTJS 2 Proof We prove I proof 2 similar Suppose x E S U T There cases x E S x E T Let consider similar Now y c T x 3 y second y If fact x maximal S U T implies x y Thus x E S f T If hand y x E S T definition I Thus C holds sets left right sides 1 Suppose x E S T U S n T U T S There possibilities If x E S l T element y E S UT lower difference operation y element T If member S x y S antichain Thus x E max S U T The second possibility x 5 y definition 366 CA Gunter et al Artificial Intelligence 95 1997 357407 y E S U T x 3 y If y E S x E S n T Suppose fact S antichain means x y similar fact holds y E T Thus x maximal S UT The case x E T I S proof similar case 0 24 Computing homogeneous intersections lattices Of basic operations set covered U U intersection I homogeneous lower upper union operations upper I This leaves intersection lower upper difference lower upper heterogeneous difficult interesting lower Let focus homogeneous upper sets S intersection dual Suppose want compute antichains S T S r S T t T T representations incorrect To consider poset P Taking elements b 3 c 3 If S b T c S b T c While S n T S n T 0 In case value S fl T clearly needs 0 The question intersection S f T clearly b c lower upper issues homogeneous order relationships intersection intersection Let consider calculated intersection example poset PwrA particular A finite set propositional PwrA minimal z E T This equivalent saying element x S f T element S T atoms If given upper sets S T S T elements sets superset y E S superset y U z Hence upper sets calculated environments subset ordering S n T x 1 x 2 y u z y E S z E T clear But subset ordering sets form y U z y E S z E T So desired operation collection minimal given elements relative S 0 T miny U z y t S z E T 3 To calculate problem removing subset x minimal elements finite collection R environments R element x E R compare supersets removing x element R elements Rather equation 3 gives desired property let look posets problem abstractly PwrA equation applied Definition 8 A poset P 5 said lattice satisfies element I _L 3 x x E P element T x 5 T x E P l There l There l For pair elements x y E P element x A y called meet x y x A y 5 x x A y 5 y z E P z 5 x z 5 y z 5 x A y following conditions CA Gunter et al Artificial Intelligence 95 1997 357407 361 l For pair elements x y E P element x V y called join x y x 3 x V y y 5 x A y z E P z Z x z y z x V y place lengthy discussion properties lattices I T operations A V uniquely determined definition Other basic properties lattices This important properties note elements ascribed source like 11 Example 9 The poset Pwr A C environments The meet x A y x n y join x V y x U y lattice I 8 T A Let consider calculate intersections lower upper subsets lattices terms antichains Let P lattice For antichains ST P define S n T maxx A y 1 x E S y E T lattices 1 S W T minx V y 1 x E S y E T lattices It shown following equations satisfied JSnT iSnLT TSfYT TSnTT A generalization case P fails lattice facts proved Lemma 19 precise section consider 25 Using pairs antichains represent convex spaces One key ideas exploited work representation kind subset poset called convex space Formally Definition x y z E P conditions 10 Let P 5 poset A subset C C P said convex space x 5 y 5 z x z E C imply y E C This defined contained ordertheoretic convex analog convexity elements line points plane region C C C Convex spaces described variety ways Lemma 11 Let P poset suppose lower sets P Each following subsets P convex space Ul U2 upper sets Li L2 6 nLl UI Ll LI u1 Ll L2 u v2 368 CA Gunter et al Artial Intelligence 95 1997 357407 L I LnU Fig 6 Representation convex spaces pairs antichains Fig 6 pictures combinations Two concern paper convex space represented l intersection l difference upper sets In cases upper lower sets represented antichains upper set lower set follows convex spaces represented convex space intersection upper set lower set following fact pairs antichains For representation Definition 12 Let P 5 poset suppose U L C P Define B Cr L z E P 1 x 5 z 3 y x E U z E L Lemma 13 Let P 3 finite poset suppose C 2 P Then C convex space C BminCmaxC In words convex space maximal minimal elements general For instance convex space maximal minimal element A small generalization sets pair antichains The result true posets collection rational numbers q 0 q 1 finite poset represented CA Gunter et alArtificial Intelligence 95 1997 357407 369 lemma allow P poset restrict C finite However interested situations C infinite 3 Version spaces Let consider antichain operations described related version space algorithm Mitchell Hirsh 71 Mellish lo The results add new insights 81 generalize Mitchells original construction ideas For purposes concept space set sets P 8 E P UP E P iYPaIaEnforsomexEP space note partially ordered set inclusion general instances elements P called concepts The elements UP called x 3 y iff x y It A concept important particular P typically collection subsets UP deviation If x 5 y x A training set x specic set positive version instances A UP called set negative instances The version space K r A determined r A defined equation space P pair r A P C UP called known structure poset y y general 9 concept space representational bias A complement consistent training version spaces training set extended uA calculating idea refined Hirsh KrAU 7 IcTU A UP This collection set r A Computationally In lo represents set concepts goal calculate new instance This algorithm KIA question efficiently calculates u Icu7 Uf294 UA2 terms K rl Al K r2 AZ He aptly terms solution viewed generalization version space merging algorithm Our goal algorithm understood directly terms antichain operations defined Mitchells original approach previous section incremental 31 Using pairs antichains version spaces The key observation concerning representation version spaces version set convex space represented induced training space ways discussed earlier In particular lo represents version space This slight misnomer training set actually pair sets 370 CA Gunter et al Art1 Intelligence 95 1997 357407 pair antichains merging algorithm consisting maximal minimal elements The incremental defined terms succinct data representation Lemma 14 space K r A convex space I P concept space r A training set version pair consisting Lemmas 13 I4 tell version spaces finite concept space P elements Another maximal represented upper lower way view light correspondence sets view convex space C pair consisting upper set JS lower set j G S min C set specific elements C G max C set general elements compute minimal antichains The key question desired operations version spaces terms equation antichains To note following training sets rr Al r2 AZ IcT1 Uf24 UA2 KTIAIKTA 4 suffices This means terms pairs antichains succinctly definition able compute represent intersection We operations following version spaces antichain terms collection SlGl nc S2G2 S f g 2 cl n c2 S n s I cc II c2 5 Correctness equation described following Theorem 15 Let P finite concept space Tz AZ training sets lattice suppose rl Al SI minKTlAl GI maxKrlAl S2 minKr2 G2 maxKr2A2 If Gj maxC G3 SGl W S2G2 C KlTl U r2 AI U AT minC S3 The theorem immediate consequence following Lemma 16 Let CI C2 convex spaces subsets finite lattice P ST minCt maxCr nC minC2maxCz Then min Cr n CT S max Ct n C2 T In particular c n C2 BST CA Gunter et al Artijicial Intelligence 95 1997 357407 371 Table I Incremental version space merging algorithm function mergeVSS1 Gi let value u Sl CP 52 S2 G2 L Gl n C2 S3 U L G3 S3 L S3 G3 endlet We omit Lemma 20 proof similar general result From computational perspective redundancy Eq 5 anti twice Moreover optimization value A realistic algorithmic presentation chains S S rP S2 G G1 n G2 apparently calculating given merging appropriate Table 1 program antichain operations described given calculated second component pseudocode version space The basic constructs brief explanation G The form pseudocode later examples As S written parentheses commas tuples pairs function f x E declares function pair pairs argument The form f formal parameter x body E It useful formal parameter pattern For example function mergeVS takes let D E endlet evaluates expression E establishing tion form value x1 El x2 E2 x E bindings declaration D The declara Table 1 essentially binds xi environment obtained establishing bindings xj j It differs The calculation calculating S1 fS 82 Gl n G2 course value described S3 compute G3 U SI n S2 purpose To equivalent following value described Eq 5 need establish 7 lo Eq 5 equation uLiLvlL antichains ZJ L To implies Table 1 matches value calculated Eq 5 let U S rP S2 L G nt G2 value SS G3 computed 6 312 CA Cunter et al Artcial Intelligence 95 1997 357407 Table 2 Version space learning learnVSGS GS good function GS let value newC newS learned CbetterG betters mergeVSGS CnewG news new information learnVSbetterG betters endlet endif substitute x E U L L Unfolding intersection assertion yields Eq 6 To 6 holds definitions let analyze means upper lower heterogeneous xELandCIyEULyix means x E L 3y E U 3x0 E L y 3 x0 y 5 x But clearly equivalent x E L 3y E U y 5 x x E U L The version space learning algorithm proceeds repeated merging version assumes given way obtain new information spaces The algorithm form version space extending training set examining new instance method suit algorithm The new information level accuracy merged old desired achieved Pseudocode domain knowledge given Table 2 process exploitation including The code uses form B El E2 endif boolean B depending evaluates evaluates expression El E2 respectively function invoked initial version space value true false resulting value The 1earnVS returns 32 A simple concept learning example We illustrate simple concept objects UP theoretical learning problem context space UP set identified shape color The concept space P set subsets section 10 J The instance introduced concepts adapted UP Redo Redo BlueO BlueO CA Gunter et al Artcial Intelligence 95 I 997 357407 373 P 8 Redo Redo BlueO BlueO RedQRedO RedOBlueO BlueOBlueO RedOBlueO UP Note 10 16 possible bias provides elements P ordered subset means making nontrivial generalizations subsets represented P This concept space instances The observed inclusion Thus Redo 3 Redo BlueO Consider version space generated training set 0 BlueO X0 BlueO x E P 1 8 C x L UP BlueO 8 Redo Redo BlueO RedCtRedO RedOBlueo represent minimal maximal boundaries version space The antichains Sl 0 Gt RedRedORedBlueO NOW consider version space generated RedCl 0 KRedn 0 x E P Redo c x C UP Redo RedORedO RedUBlueO Redo BlueO Redo BlueO The antichains represent boundaries version space SZ Redn G2 Redo Redo Blueo BlueO We steps computation K Redo BlueO X0 BlueO xRedn 8 terms antichains Table 1 represent r xRedo BlueO Redo RedORedO RedOBlueCl St nU 52 RedO GI n G2 Redo Redo Redo Blueo S3 St nu s2 u G n G2 y E Sl flu S2 1 3x E Cl dG2 y x RedO G3S3 t GI nG2 x E GI d G2 1 3y E S3 y I x Redo Redo Redo BlueCi We easily S3 G3 K Redo BlueO 374 CA Gunter et nl ArtQicial Intelligence 95 I 997 357407 Fig 7 Quasimeets quasijoins 33 More general concept spaces We shown operations version spaces calculated concept space finite lattice way work spaces finite lattices sufficient condition We necessary incremental usable principle The key idea identify update algorithm need able compute given following assured Definition 17 Let P 3 poset x y E P The quasimeet x y defined equation xAymaxz E P 1 z 5x z 5 quasijoin x y defined xOyminzEPIzxandzY In 8 JxAy If P lattice called bbxy fxOy called aaxy easy cheek dealing lattices quasimeets meets joins However singletons A graphical event correspond quasijoins Fig 7 x vy gt concept generalizations space x A y x A y x v y x V y basically given poset P quasijoins case quasimeets Hasse diagram s When representation g x A y si elements set x V y x y x A y called general specializations specialized called x y It sufficient know simply operations know compute quasimeets compute antichains special property concept quasijoins represent version spaces However essential needed CA Gunter et al Artificial Intelligence 95 1997 357407 375 space Just defined lattice poset operations A V special properties need analogous definition Definition 18 A poset P said property W l min P finite P r min P l X y E P quasimeet xii v finite lxhy z E P I z 5 x z 5 y said property M l max P finite P 1 max P l X y E P quasijoin x V y finite TxVy z E P I z k x z ty poset properties said property MW theory topology Property M familiar ideas mulation important property compact subsets called coherence domain necessary condition closure properties need finite quasimeets duced element hold 151 bases domains good pairs elements P fiat intro P M W properties ordertheoretic 81 noted conditions 141 Mellish quasijoins identified Given MW poset P express greater generality intersection upper sets lower sets carried terms representation antichains We define SnTmaxUxiylxtSandyET forMWposets S fY T minux D y x E S y E 7 MW posets A P infinite S T finite S n T finite The definition fY given Eq 5 Note particular S VT operations taken MW posets That definitions I unchanged f nU ones given Lemma 19 Let P poset suppose S T antichains P 1 IfP hasproperty W LSfT 2 IfP hasproperty M TSfFT IsnlT TSflTT Proof We prove 1 proof 2 x E J S f T Then elements y U u x 3 y y E u A u u E S u E T This means x 3 u x _i 1 x E 1 S n I T dual First suppose 376 CA Gunter et alArtcial Inrelligence 95 1997 357407 Now suppose x E 1 S x E 1 T Then elements ua E S uc E T n 5 0 ua By property W x E J uo A 0 x element 1 X uuAuIxSandyT The set X finite Lemma 3 1 X Jmax X 1 S n T desired 0 Lemma 20 Suppose P MW poset Cl C2 C P convex spaces sets S1 min Ct Cl maxCt S2 minCz G maxC finite equations Cl B S1 Cl C2 B ST G2 hold If ST minCi maxCt nYminC2maxC2 min Ci n C2 S maxCt n C2 T In particular Cl n C2 BST Proof The desired result follows Lemma 13 minCi n C2 Si V S2 Gi f G2 maxCr nC2 Si nU S2 Cl i7 G2 Let second similar proof Starting Eq 1 Lemma 20 calculate TSl nS2 u Gi nG2 Tum ms2mwl fuG2 slnlGlnrs2nlG2 TBSIG nBS2G2 wl n c2 It difficult The desired equation follows 0 check U antichain U t U U min U 34 Necessity properties M W The MW property difficult condition satisfy For instance finite poset property MW lattice property MW But examples concept spaces satisfied We essentially claimed spaces antichain Table 1 depends sense poset satisfies space merging MW algorithm MW property representation concept incremental version CA Gunter et al Artcial Intelligence 95 1997 357407 371 The key assumption underlying antichain convex space way form S G S representation convex spaces G finite antichains Some vocabulary represented helpful max S representable Definition 21 Let P poset A lower subset S P said finitely repre finite S 1 max S A upper subset T C P said sentable finite T t minT A convex space C C_ P finitely said finitely finite C aminCmaxC minr representable max C minC In version spaces terms possible express succinctly Admissibility Theorem Theorem 22 Admissibility If Let P concept space satisfies property ME instance convex spaces Ka0 KQ u finitely representable K P A training set P A properties M W concerning Proof Note Ic 8Q Bmin P max P finitely conditions Eq 4 says possible spaces forms Ka0 collections representable finitely collections min P max P convex intersections ase d Lemma 20 assumption follows KaB representable Kr A express collections representable finitely 0 Theorem 23 Let P poset If set min P representable upwardsclosed 1 finite P T min P intersections finitely subsets finitely representable P prop 2 erty W If set max P representable upwardsclosed finite P J max P intersections finitely P prop subsets arejnitely representable erty M 3 If poset P finitelyrepresentable convex space intersections finitelyrepresentable convex subsets finitely representable P properties M W similar proofs Let X y E P let L lx f Proof We prove Since ly representable max L Since L z 1 z 5 x z 3 y follows intersection suppose L antichain 1 finitely representable sets finitely L I L In case L L x K y Hence IxAy z E P 1 z 3 x z 3 y means P property W q Theorems 22 23 significantly extend 78 lo They provide direct means known verifying theory admissibility antichain presented repre 378 CA Gunter et al Artijicinl Intelligence 95 1997 357407 adopted version sentation sequence concept element set training language instances space algorithm correct satisfies MW property arbitrary training terms behavior 35 A complex concept learning example We turn complex example concept space order illustrate version space fr subsets fr subsets admissibility finitely representable role properties M W play algorithm Theorem 23 says intersections fr poset P fr P property MW Since version space algorithm result clearly relevant However relies intersecting fr subsets case algorithm actually need intersections possible pairs fr subsets problem arise To illustrate happen examine axisparallel introduced learning methods task learning labeled points plane This problem geometric analysis subsymbolic plane lo applications If intersections rectangles finite represented conjunction Consider integer grid imposed xy plane Labeled examples points x y rectangle The grid marked inside outside target axisparallel target rectangle intervals natural numbers N We formally define set UP instances set P concepts composed elements learning example instances product pair closed halfopen open intervals x y To precise suppose R E define concept representational generalization In particular P consists subsets UP represented subsets UP As previous P permit nontrivial bias introduced closed Pxy j ZRxRrlAbRyRtl1btENu UPxy IxENandyEN open halfopen closed rectangles The elements P points defining halfclosed intervals open interval intervals closed This poset rectangle element UP elements p 4 P yield greatest Let define A operation p q Let largest axisparallel define rectangle grid contains operation V elements p q P smallest rectangle grid contained To proviso existence comes consider rectangles corresponding RI xy 10 x 20 0 y 30 R2 x y 1 10 x 30 0 y 30 element P difficult Their union element P contains true property M fails To note That RI V R2 undefined But case CA Gunter et al Artificial Intelligence 95 1997 357407 319 element P containing RI U R2 minimal element P containing Let concerns aside focus algorithms partially defined operations conjunction closed target concept 2 carried tion The Should 1 r b t set inclusion inclusion checking construction 2 Because special representations antichain inclusion rectangle defined I x r b 6 y t rectangle The ordering 5 P P check set x y intervals We use fact form elements version space Tables 1 disjunc We calculate version space given training 11 11 positive sume thatthey definition arelearned instances point thefollowingorder set having 12 12 13 13 negative Let points 121213131111By K12120 SE P 1212 c s c UP The antichains SI Gl representing K 1212 0 sets elements P In G example Sl Gi singletons St contains point rectangle 1212 halfopen left corner 0O right corner ooco rectangle S xy 1 12 Q x 12 12 y 12 G x y IO 6 x 03 0 y oc Now 1313 point outside target closed rectangle definition X0 1313 S E P 1 0 C S c UP 1313 While S2 singleton consisting rectangle G consists elements P denoting rectangles plane point 1313 exclude s2 0 Gxy 10 6 x 13 0 6 y 13 xy IO x 13 13 y xy I 13 x 0 y 13 Y I 13 x 00 13 y 00 We calculate antichains representing version space construction Table 1 Each element closed rectangle The pairwise V rectangle G1 yields Sr The pairwise A operation elements elements G2 turn elements antichain SI S2 yields open halfopen point G2 element 380 CA Gunter et al Artcial Intelligence 95 1997 357407 SI flu S2 minp V q 1 p E 4 q E xy 1 12 x 12 12 6 y 12 GrfGrnaxpqIpS andqE xvY 0 x 13 0 y 13 XT Y tY I Y 0 x 13 13 y oo 13 x 03 0 y 13 13 x 00 13 y CXI To obtain antichains Ss Gs representing boundaries 121213 13 complete steps algorithm Table 1 Ss Sr nU Sz Gr n G2 P E 6 nU S2 I 3q E WI ff G2 P 5 4 xy I 12 x 12 12 y 12 G3 Sr V S2 GI n G2 q E G1 n G2 I 3 E SI ws2 P 15 4 xy IO 6 x 13 0 6 y 13 As expected Ss point rectangle 1212 included rectangle left corner 0O right corner 1313 1313 G halfopen rectangle The version space positive instance 11ll represented pair S4 G4 xy I 11 x 11 11 y ll G4xy IO x cc 0 y ce When merge Ss Gs boundary upper boundary remains Gs new lower SS xy I 11 x 12 11 y 12 Let return question algorithm value S3 fP S4 closed square corners 11 11 12 12 work property M fails The need property M arises example lower set boundaries serve use algorithm quasijoins hard lower boundaries concept P arise element lower boundary S version space training sequences points generate version spaces To note lower boundary version space single closed rectangle convex version spaces However calculate CA Gunter et al Artificial Intelligence 95 1997 357407 381 training rectangle containing specific fact smallest sequence Our counterexample positive property M obtained instances training attempting union closed rectangle open situation arise algorithm new convex spaces learned upper boundaries version means spaces concept space open rectangles include stipulate Table 2 test goodenough defined happen So referring test S G singleton border width 1 S learned S G version space coincide sets difference sequences points By contrast finite boundaries consequence rectangles This heterogeneity concept space closed rectangles In general terms space representation space Another way rectangles To incorporate success version concept open concept lie special specific concepts general concepts theory section partial orders upper bound upper lower boundaries space seen relying fact upper lower boundaries subsets concept represented represented described view version aries lower boundaries The satisfy property M second satisfy property W The order comparing upper lower need satisfy ordertheoretic properties version space merging algorithm tersections We attempt elaboration paper execute compute heterogeneous accommodate course able comparing generalization require generalizing general compute order spaces 4 Assumptionbased truth maintenance systems relative involved given structure 23 based section theory Our goal An AssumptionBased System compute ATMS expressed Truth Maintenance intended ATMS sets assumptions introduced terms anti ATMS reveals efficient calculations ATMS need ideas logic We work language falsehood Kleer conclusion computations chains This provides semantic basis understanding representations Is To propositional In general atoms denoted lower case letters 6 c beginning Latin alphabet Propositions usual logical connectives disjunction A theory 3 atom interpreted M interprets 4 true usual truth table interpretation logical connectives We write 3 CJ model elements 3 theory 3 set propositions A model M subset C I true E M We write M C includes atom I standardly models equivalently 1 negation A conjunction model We 4 IJ built atoms implication inconsistent formulas V 3 k 1 interpreted atoms 382 CA Gunter et ul ArtiJicial Intelligence 95 1997 357407 As discussed example earlier let A finite subset C subset ordering Assumption elements assumptions A B C help distinguish lower case letters x y t near end alphabet poset environments Pwrd atoms written upper case letters general atoms Environments denoted define Given theory ZF assumption set A ATMS designed efficiently calculate collection nogoods defined NF xEERJxI E L set VaxEEUxIand3Uxa In practice function invoked different different 3s primary computational goal ATMS calculate function VF typically notation representing let write NT NF hash table lookup atoms L For uniformity There important observations aid design efficient represen tation computation First let note Lemma 24 Va S convex space pair antichains This 23 diference So represented upper subsets The efficiency representation share common upper boundary subsets Va terms nogoods In particular simply maintain mapping atoms antichains effectively E owes fact computed function following JQ minxEEjFUxJ_ minxEEIUx_landUxa I ifa 1 Knowing LF allows compute desired values Example 25 If _4 A B C D assumption set F theory b_a A B C 1 CD CAACADBCACAB represented space Va difference upper sets t LZF T LF I The convex illustrated lightly shaded Fig 8 Lemma 26 Given theory F assumption set A 1 NFtLFj 2 Ma t LAa t LAL CA Gunter et al Arfificial Intelligence 95 1997 357407 383 Fig 8 The convex space VJZ environments represented difference antichains LFN ABC LF CD In practice efficient use boundary representation work LF I LF LF 1 I respectively Knowing NT VF These sets called labels 21 labels sufficient reconstruct V3 7a bl T LFLJ lIba T b_l N3 TTWa NF NT Tka NF VFLI So referring earlier discussion mization represents convex space difference upper sets surrounding Lemma 11 proposed opti 41 The ATMS interface type assumptions abstract data justify propositional It client problemsolving An ATMS understood described course FinPwr C collection finite sets propositional creates ATMS based given set propositional terms semantic cache atoms The ATMS data type Table 3 The ATMS data type denoted atoms atoms interpretation inferences defined operators given atms The function plays associates atom E A label u atom b E L A label antichain update finite subsets A The function initatms role assumption set A This function generates ATMS interface given theory poset I environments label propositional set propositions label The function workhorse computes atom label 384 CA Gunter et nlMrtQScial Intelligence 95 1997 W407 Table 3 The ATMS interface init_atms label update FinFWrL atms L x atms AntiE theory x atms atms ATMS produces updated ATMS labels provided new theory labels determined initial ATMS updated incorporate information previous theories basic operations antichains basic operations desired functionality implementable manner For compute succinctly ATMS instance The combination ATMS provide clear efficiently meant ATMS The true functions consider arguments label words x consistent In terms ATMS antichain simply Tables 3 A2 A3 consistent atom E Z environment extension function nodeconsistentwith x E returns environment environment interfaces modular functions semantically 2 expressed interfaces 4 p4401 This takes true y superset x In follows terms operators boolean value 4 To examples lowerrmember label theATMS x upper 4 useful theATMS member ple described supportingantecedent ronment x arguments x In terms interfaces mathematical ATMS uppermemberA set corresponding antichain A Another inference E checks element E exam function envi S holds S x mixing atoms engines checks takes set atoms S al conjunction uppermember programming notation sophisticated S labelul theATMS fl flu label theATMS binary operation upperhomogeneousintersection Using calculated We extend interface analog Common Lisp utility apply information provide additional antichain S client problem solver For example include function atoms atms FinPwrL set atoms mentioned current ask collection atoms theory ATMS believed given environment X This collection possible finite returns This relative calculated collecting superset element L label element holds unlikely want theATMS case upperrmemberLx actually called context x x In particular x superset true However form context environment equal atoms atomstheATMS CA Gunter et alArtcial Intelligence 95 1997 357407 385 solver function set cases want know atom context determined uppermember ATMS requires client problem learned label atoms On hand implementation given environment cost making functions function available recourse atoms explainnode 4 p 4421 described interface This function arguments 4 requires extension takes described returns proof atom based To provide different nature basic atom environment theory ATMS given environment ATMS chosen information assumptions retaining atom derived To add function need provide propositional theorem prover assumptions interesting essentially computational ATMS choices interfaces right appropriateness proofs atoms sets assumptions associated The design appropriate needs client problemsolving proofs atoms antichain minimal needed functionality overhead delivering reconstruct rich subject For present antichain compromises formulation instead 42 The basic ATMS While imposed restrictions theories ATMS function involve computation absence restrictions exponential efficiently expressive Horn clauses A Horn clause proposition form size A One way ensure reasonably restrict update language update calculated theories propositions al A Aaa proposition write form n 0 means For applications expressiveness original paper computational decision problem F k linear size A proven provide good balance efficiency The restriction 2 discussion advantage Horn clauses Horn clauses ATMS lies size F fact complexity exponential opposed logical Kleers 4 The function update specified The logical meaning interface label function L3 3 theory associated ATMS The question remains calculated Our goal provide abstract descrip function called tion closure operators The idea declarative executable specification particular In words semantics pro fixedpoint functional treatment realized gramming 6121 The benefit mathematical denotational described mathematical class functions terms antichains computation languages entity 2 The mathematical notion closure operator confused closure functional programming languages term refers pair consisting code pointer environment 386 CA Gunter et alArfificial Intelligence 95 1997 357407 concerned computing semantics given 51 What add treatment proving correctness algorithms based fixedpoint far basic ATMS chain operations use antichain operators makes pseudocode properties closure operators allow algorithm ATMS relative labels Indeed proof correctness terms anti fuller discussion role closure operators The description use We label update basic ATMS later section use develop new algorithm close actual efficient general class propositions mathematical implementation succinct formulation possible capture Turning technical details let AntiE set antichains Let form partial ordering antichains taking x 3 y Suppose C Horn clause A A proposition C induces functional viewed operation atom Repeated application informationimproving ATMS We view F describing Let function G informative C Anti label function label update algorithm Suppose current state knowledge label key idea F function improving information functionals F write F 5 G information provided CJ 3 Gb Fb applying operator atom b Taking account 1 T x C T y 4 C Antil L f AntiE defined equation Fb b Fb Fa U nFai 1 1 n b function There special characteristics G labeling informative dF contains atom 6 Third applying 4F 2F pF informative F 3 G implies 4 proof discuss First Second F J F 1 4G Fb adds 3 JF b information information twice consecutively JG F These defining properties closure operator Definition 27 Let P poset suppose closure operator f P P function Then f 0 monotone x 5 y implies l inflationary x 3 fx x E P l idempotent 3 fy fx ffx fx Lemma 28 For Horn clause c function 4 closure operator Proof Say 4 al A atom If b JF hand b A To C monotone b Fb 5 G 6 4G suppose F 3 G b b F 5 G On CA Gunter et alArtcial Intelligence 95 1997 357407 387 tb TFW uu nUFai I I G G 4 t FU u nft FUi I 1 rl 5 t G4 u nit GUi I 1 4 1 G 6 II t GU UL nGui tGb C monotone To inflationary suppose b Fb 4F b If b tFb T Fn U nYai I 1 G 6 4 W4 untWi 16 n 2 t Fb To prove idempotence consider 4 If holds pF calculate follows F F If holds 4F cases Either ai uninformative ai ui F ui easy verify case argument Fa Fa uUnFai I 1 n Fu U nFu 1 n uU nF ui I 1 G G n Fu U nUFui 1 6 n Fu If argument b result immediate q The key point concerning closure operators partial information members family S operators eventually new information application stability S This point stability S We require slightly general technically added additional common repeated leads point operators fixed point operators applications fact theorem expresses Theorem 29 Suppose P jinite poset S u family closure operators P P For point x0 E P commoned element x E P x0 3 x f x x f E S f point S x0 That This corollary following lemma describes fixed point computed 388 CA Gunter et al Artificial Intelligence 95 I 997 357407 Lemma 30 Suppose fi 1 E I family monotone inationaryfunctions poset P indexed finite set I Suppose infinite sequence members element I appears ix P finite x0 E P Let v u Let n nth element LT Consider set This set upper bound x This point x commonJixed point x0 futctions f fi I Proof The fact r upper bound chain y 3 z z 5 y y z E r follows observation poset P finite To prove x common fixed point need convenient notation composing sequences composition nondecreasing upper bound fis We write T length n prefix u We write fonl 0 fvj_l 1 0 o fa 11 First note elements r written order fi inflations Second P finite attained finite stage n upper fg x0 Let notation frrrnlfrrlnlIflllXo f boundofris begin noting 172 2 n x funx 7 Since x upper bound r know fg f CT nI J I f rrlkl inflations know x fv x0 5 fvn x0 x0 3 n Now consider functions let nz number greater nz assumption x f_ x0 Applying f 7 equal x Thus n fixed point functions frrrlll sides equation yields n appears f We fiX crm know suffix I By x To end 7 know x0 r fixed point easy induction fi fact x0 _i x fiX Suppose x common m m f x0 3 x monotonicity Thus x upper bound r x upper bound x 5 x 0 The upshot lemma wish common fixed point succession systematic order fixed point The appearance formalize finitely set closure operators need apply necessarily infinite sequence g proof fact P finite ensures required notion iterations applications order reach desired fixed point We use theorem express ATMS label update computation Suppose LB label function constructed label function Ls set F Horn formulas set s Horn clauses The improvement characterized follows Theorem 31 Soundness atoms suppose associated environment A E suppose basic ATMS algorithm Let A set assumption lattice Let L label function If Lg C AntiE 3 G sets Horn clauses CA Gunter et al Artijicial Intelligence 95 1997 357407 389 Table 4 Converting Horn clause q5 closure operator 6 function dF b b Fa U endif Fb foldn mapFS 0 4 Horn clause S set premises conclusion label function functions relative G common fixed point F LG Moreover jxed point satisjes equation Fuga Fa FI ifa f I FI ifa 1 8 k relating involves entailment semantic A proof theorem Horn clause formulas CJ fixed point closure operators 4 This use minimal model collection Horn clauses Details sufficient construct proof Theorem 3 1 It worth noting Theorem 31 reflects fixed point computation f LBU account necessarily F monotone operator labeling function X ordering sets formulas subset arises upper difference Fa monotonicity labels despite operators Since members I nogoods deductions based 3 taken case Lga 5 LFUB Put generally functions LX monotone This non 51 111 nonmonotonicity based monotonic taken 8 inclusion I FI Using Lemma 30 8 shows calculate Lug LG 3 use common pseudocode operation 4 H 4 label functions given fixed point We convert way Tables 1 2 version spaces Pseudocode mathematics ATMS computation closure operator takes Horn clause corresponding Table 4 following functions taken antichains interface In program upperunion singleton upper_homogeneous_intersection The operation singleton antichain x set upper set antichain singletonempty takes T0 E Aside operations antichains require basic The encountered element x forms antichain represents operations sets singleton In particular map fold 390 CA Gunter et al Artijicial Intelligence 95 1997 357407 Table 5 Basic ATMS label update function improveLABEL let L CL ifLL Aatom atom I LI Latom II LI improveLABEL endif endlet f fold fold set ob function F set S returns The function map takes arguments I 23 tained applying F elements S For instance map square 149 A Common Lisp analog lists mapcar The function takes binary operation set T XI x end value x returns XI x2 x x T x x For 0 6 If T 8 similar 8 42 42 The Common Lisp fold use end value X In Table 4 end value J confused In particular note taken form set The upper union single Fa ton containing lattice environ ment set The upper set entire environment S emptyset In case upper union premise set 0 case expect instance function singleton holds fold apply containing 123 To use operation 4 H 4 calculate label use label Table 5 Since function pseudocode appears function evaluating function This represented improveLABEL new labeling function pseudocode form improvement result returned value Ax E anonymous The algorithms Tables 4 5 correctly efficient optimize 1 algorithms cases function formal parameter x body E implement ATMS computation How changes test The test L L line Table 5 accomplished saving second pass CL calculation termination Improving combined structures L L In actual implementation flag set change test check flag set Optimizing determine yield new information label atom updated directly consider occurs antecedent computation choice application sequences closure operators It possible closure operators In particular current state information relevant Horn clauses proceeds L occurs The test C L L replaced 2 CA Gunter et al Artificial Intelligence 95 1997 357407 391 Table 6 Basic ATMS label update algorithm Assume C Horn clause form ccL CL function PROPAGATE 4 b I let S WEAVECb I wcn S 0 UPDATERS endif endlet function UPDATERS al NOGOOD La S U La C antecedent CJ PROPAGATEaS S S U La1 Li S return endif endfor endif function WEAVEb I II cl u I b I I n Lq LI endif endfor return I function NOGOOD LI LL U s atom b 1 Lb Lb S endfor 3 removing nogoods Rather Incrementally calculation improveLABEL course update new environments nogoods All optimizations rithm The Forbusde Kleer algorithm antichain operations The closure operators ATMS implemented Table 6 procedural real implementations eliminated removing nogoods end incrementally antichain added reconstructed occur declarative basic ATMS update algo Table 6 specification 4 iteration constructs The chief labels algorithm insight update computation We define propagate changes incremental labels information entire provided Horn clause b application operator A C f AntiE t C t Anti defined equation Ab 0 b nP ai 1 1 6 n b The procedure WEAVE Table 6 implements A Nogoods removed algorithm The procedure NOGOOD Table 6 imple discovered KleerForbus 392 CA Gunter et al Artificial Intelligence 95 1997 357407 nogood include incremental eliminate new labels evolving label set Fa I E C updated antichain nogoods FI removal inplace update evolving ments F When antichain S added subsumed S Fa updated closure operator consisting relevant Horn clauses antecedent Horn clauses respect change reconstruction package label function S S In procedure UPDATE label atom antichain S In loop procedure occurs label function F updated procedure PROPAGATE PROPAGATE computes A label propagation WEAVE terminates label set S 8 The compact semiproceduraldeclarative allows use antichains constructed turn given Horn clause optimizations algorithm implementation incrementally environments effective ones 5 Extended ATM Closure operators crucial largely unappreciated manipulate partial information We illustrate algorithms called extended ATMS The extended ATMS defined Horn clauses L disjunctions ATMS interface disjunctions compute Lla 7 theories propositional set disjunctions given assumptions 31 ATMS input theory consists assumptions Al V V A The extended Table 3 basic ATMS permits certain kinds Horn clauses That goal set Horn clauses addition atoms E C 3 importance designing Kleer Example 32 If A A B C assumption set 3Au Bb Csc CAU crbI set Horn clauses 7 A V B set disjunctions assumptions LFL A C B C LFUlJ C A B guaranteed hold models 3 U 1 As Kleer notes 3 Horn clause label update algorithm theories basic ATMS incomplete disjunctions labels respect labels computed respect 3 U 7 31 uses hyper 3 basic ATMS sound complete allowed To correctly compute resolution algorithm fix rules Our approach extended ATMS generalizes disjunctions assumptions 31 formulas form rqq v4q vvq CA Gunter et al Artijicinl Intelligence 95 1997 357407 393 form 4 A 17 A A A E A normal equivalent step note formulas form In words simple disjunctions assumptions form assumptions Let refer formula having generalized ADNFs disjunctions natural environment like essentially conjunction A like 7 viewed antichain E provided disjunctive 7 Assumption Disjunctive Normal Form ADNF To appreciate generalizing primitive assumptions formula subsumed In effect permitting chain directly asserted problemsolving To develop 7 set environments 7 I operators theories optimizations formulation A E E A s import anti form ADNF like t A A We use symbols terms closure In addition new So write t environment n That sets ADNF hidden revealed t E T mean corresponds allows derive new algorithm distinction ADNF assumption DNFs prove formulas Our mathematical help confuse label computations labels respect computing soundness include details logical treatment We examine introduction propositional assumption DNF formulas A changes atom holds Continuing Exam set environments ple 32 NF 1Ll NRJ T LIJ CCC C AC R C A B C The set environments tion A V B include environments To identify environments operator I holds expands introduction disjunc x E E x U A E N3 x U B E N3 added assumption DNF formula 7 E 7 define q7 Pwr8 4 PwrE intended upward closed sets Vu7 N3v7 respectively Given set S C E define upward closed set environments VFa N3 extend SxEtE7XUtE1S It easy pT S upward closed set 1 pS given theories defined Example 32 pT S For instance NFUAVR ABNF Note working operations antichains environments We define antichain analog ly T S S Ultimately interested pS Q7 AntiE AntiE 394 CA Gunter et al Articial Intelligence 95 I 997 357407 p7 follows equivalently GS unique antichain Lemma 33 The function P7 closure operator ADNF formula r Proof Let S C T S T E Pwr This means monotonicity 1 S C r T We establish xEP7S vtErXUfEfS VE7XUCETT x ePT To p inflationary x E PT S Thus S c q7 S To demonstrate FT S _ We know Yr S C Wp 5 To prove opposite environment suppose x E S t E r Then clearly x u t c 7 S idempotence p p7 S let x inclusion x E FTPS vt E 7 x u t E TPS vtErXUtEPS j j JtE7XUfExrEEE7XUtETS vtETxUtUtES XEPTS Hence ly idempotent closure operator 0 Corollary 34 The function Q7 closure operator ADNF formula r Proof Recall S 3 T antichains S T means t S C T T Now t QS PAS C PTT t TT QD monotone Moreover t S C pT T S pS means SmintS 5minlyS S Gj7 inflationary Finally Q7 07 S cPi S Hence Gp idempotent q CA Cunrer et al Artcial Intelligence 95 1997 357407 395 In general results sponding operators isomorphic tively like corollary follow spaces antichains fact Cp P corre upper sets respec Lemma 35 Suppose S E Anti r172 ADNFs Then JS S S 7 minx E E 3tl E q3t2 E 72 x tl U tz Proof Let S antichain environments suppose y environment y E JT TS 3 vt E 7 y ut1 3 vt E 71 321 E zS E TTS ZI L Y Ufl VEZIEZIUETSICYUI vt E 3l vt2 E 72 y u t1 u t2 E T S y E TS H Vt2 E 72 Vt1 E 71 y U t2 U t1 E t S H dt2 E r1 322 Oh1 E 71 22 U tl E T S 22 I Y U f2 tErl322ESz2CyUt2 H Vt2 E 72 y U t2 E T Q7 9 y ETS q It illuminating note formula antichain viewed antichains obtain r r1 0 72 r lemma essentially taking upper intersection corresponds 71 r2 Lemma 36 For S E Anti monfuedpointof 1 ii6aboveSisS closure operators QT jr com Proof This consequence Corollary 34 Lemma 35 Lemma 30 0 Given set 7 71 7 ADNF formulas fixed point S closure operators a7 Lemma 36 tells compute I S let define Qil S Our goal calculate label function extended ATMS This parts compute second compute 7S desired result labels operators Q antichains S For step Theorem 37 Extended ATMS algorithm let 7 71 Let F set Horn clauses C r set ADNF formulae assumption set A Then 396 CA Gunter et ulArtifcirrl Intelligence 95 1997 357407 propositional atom E C kma dL3a U LFI LFuIJ ifa 1 ifaI The proof theorem demonstration ATMS algorithm Let F theory best establishing formulas ADNF Then following correspondence case actually interested holds soundness extended general equations preliminary F need Horn clauses ADNFs x E E r Suppose FU7Uxka iff QtETFUtUxka 9 model FU TUX model To let look Suppose M k F U t U x t E T Then M k 3 U T U x suppose assumption M k Thus Qt E T 3 U t U x Turning proof suppose t E T model F U t U x model If M h 3 U T U x M r M k t t E 7 Hence M k 3 U t U x hypothesis allows conclude M This establishes 9 Now convenient notation upper set environments prove given conclusion So given theory 3 define UFa xEI FUxa Given theory F collection 7 ADNF formulas U following main fact UFr PI 0 u3 10 This proved induction number elements 7 desired result known 7 Given atom prove Suppose 7 When 0 r E 7 7 7 r UuaxE3U7U7Uxa xEEjQtEFU7UtUxfa WU3wa pTPtU3a PTou3 11 12 Eq 11 follows 9 Eq 12 follows inductive hypothesis Proof Theorem 37 To calculate L37 I minUFll minPlUFl equal equal z1 If atom I note defined Eq 10 This turn CA Gunter et alArtcial Intelligence 95 1997 357407 397 LFu U bl minPrtda U bF minFdt ba U t bl minP7U7a minUmla hJ7a u hJlL Thus hJ7 kw7a u kJ7u 1 u hJIJ eba Ub4l hJ7l 0 What Ss remains showing calculate Gp Given collection antichains s useful write U s S u lJL s u YES s S flu flu s h XES The desired following expression QS terms antichain operations given Lemma 38 For S E Anti ADNF formula r d GS Js t IE7 YES Proof We calculate follows QS minPTS minxEItE7XUtErS minxEItE73sESsCxUt u numinxEEIsEaut ET YES Now consider contains The equation sets es x E I 1 s C x U t An environment t Hence s t unique minimum x es case element es environment lemma s follows q The algorithms Table 7 Table 8 correctly implement extended ATMS label computations We examples use algorithms 398 CA Gunter et ul Artcial Intelligence 95 I 997 357407 Example 39 We illustrate computation label _L example introduced start subsection Recall assumption set A A B C Our aim calculate ZFT I First use basic ATMS algorithm compute LzKL AC B C Next closure operator T constructed Lemma 38 algorithm Table 7 AB ij A nu fib B s s Finally use Theorem 37 algorithm Table 8 obtain desired result JAJB ABACI BC AS A U BC A1 n AC B U KC Bl fC u BXl 0 AC u C1 UCH fI tic wu Example 40 We demonstrate power antichains formulation label compu tations context example complex T Consider FAhBbCebccd 7BVCAvi wm BL WIL Al Gw We need calculate LFT From basic ATMS algorithm know LA4 tB C LF AA Next use Lemma 35 reduce 7 71 2 single ADNF formula 7 7minx E 13 Eilt2 E 72xtl Ut2 mABABiCAC B A C A CA Gunter et al Artijicial Intelligence 95 1997 357407 399 Table 7 Converting ADNF formula Q closure operator function e7S foldrlmapAt foldWmapAss tS 0 CT 0 7 ADNF formula S antichain Now construct I algorithm Table 7 qS fis sES x I ijs v BJ I ijs CA s We calculate LFI I LFld algorithm Table 8 LFM A xii Til 0 AA BAl 0 Ax CA1 W n H n A z LmTd 7LFd u kJ1 LFU TB C A A zB 3 A IB A u C x u A I n IBBAUUCAUAABAl lfUl WI u W u HWI nz f0 u c u I nu r WW uu 101 u GWi IB Cl Al Note A added basic ATMS label d extended ATMS F U 7 U A d W e note follows fact sinceAVBVCistrueandthatFUBVC kd computation This means thatFUIUABVC BdandCd 400 CA Cunter er al Artcial Intelligence 95 I 997 357407 Table 8 Extended ATMS label update function correctLABELLFQs7 let L 7I atom atom L lFatorn endif U LFI I L endlet The computation label Lla restricted 131 Thus size A De Kleer general case expect 7 cause exponentiality atom E C essentially enu atoms A FU 7 This task perform com incorporate labels computed Horn terms closures meration minimal models Pcomplete known putation exponential disjunctions theory 3 Our ordertheoretic antichains indirectly computationally expensive multiple proofs literal 3 U 7 based support set x E E All proofs enumerated label rules correction labels directly allows enumerate space proofs A prooftheoretic space models scheme course application hyperresolution 31 uses hyperresolution label computation computation modeltheoretic approach reconstruction The fundamental computation framework incorporate ADNF formula 7 antichain S r 6s t YES rS AL t tn S st s ti s E E straightforward operations mn upper requires mn setdifference intersections Any reduction number opera sizes arguments upper unions If 7 t implementation unions n upper homogeneous tions win reduction upper homogeneous implemented intersections We list optimizations achieve types reductions computation cheaply computation changes labels caused introduction 7 We compute entire new label In effect extended ATMS new operator A shown use calculate 1 Computing labels changes define label QiS Su AS AS fjAyt ET AY fi s t s 8 s t YES CA Gunter et al Artificial Intelligence 95 1997 357407 401 Table 9 The optimized GS computation function QS let dS infort 0 E Tdo fl8 0 let Y E S s t s dyt AK U s t endif endf AS AS n Ayt endf return S U AS endlet For s t pair s t s save upper union operation sizes arguments A intuition shown Table 6 remaining upper unions Ys This optimization De Kleer Forbus In addition reduced work Table 9 employs basic ATMS algorithm shown computation 2 Detection early termination During GS S terminate G7 S detect early conditions t E T s E S s t s It easy Suppose corresponding Y S We Wl 5 yt property f But Q5 S f7K S Qr closure operator Therefore K S t E T Q7 S S stop label computation At best save m 1 n set differences intersections At worst m 1 n upper unions n upper homogeneous condition true t E 7 examined save n upper homogeneous intersections involving U 0 We use properties nU U simplify 3 SimpliJications computation computation individual Ys Q7 S 8 UU S8 S E AntiE 0 VkS S E Anti Thus instance encounter s t pair computation s 2 t s m 1 upper unions 1 upper intersection t 8 immediately computation report X 0 rS specific K saving upto Acknowledgements This project come existence AI representations Panangaden played key role inciting helping explore usefulness semantics concurrency He responsible closures play ATMS Haym Hirsh helpful abstractions VS algorithm We thank anonymous kinds ordertheoretic understanding showing participation Prakash potential structures key role usefulness referees read 402 CA Gunter et alArtijicial Intelligence 95 1997 357407 Bonnie Webber paper Ziqiang He Leonid Libkin Rona Machlin Gunters work supported Ngairs work supported Institute Systems Science Singapore Subramanians work supported NSF grant IRI8902721 ONR grant N000149510245 Appendix A Antichain library interface In appendix signatures Standard MetaLanguage implementation lattices With implementation brief explanation provide readers familiar SML An SML signature antichains sense expected present called structures Signatures values values In signature value given type For example declare line section contain names types exceptions list names implementations signature names structures types exceptions denotes value mapping elts singleton cases consider acs includes contain val singleton elt ac antichains antichain structure contains type called elt exception called NotFound given end paper It indicates signature The signature type called example failure ac There type ac The signature elt elts viewed elements ac It describes types values lists names exceptions ac value semantics objects For instance types present signal Before giving detailed discussion particular values ANTICHAIN lattice independently sets bindings defined producing posets antichains special kinds subsets poset makes sense simply signature sketch role signature plays programming antichains Antichains speak antichains The signature ANTICHAIN viewed type operator environments environments defining antichains lattice provided Like antichains operators expect present The particulars signature discussed antichains operator called afunctor takes lattice structure produces antichain lattice structure follows signature LATTICE signature ANTICHAIN If analogize functions types write given signature LATTICE Table A 1 taking parameter environment SML term parameterized shortly Now implementation lattices come collection implementation implementation taken operations new environment structure structure functor Lattice2AC LATTICE ANTICHAIN In summary implementation antichains given coding transformation CA Gunter et al Artijcial Intelligence 95 1997 357407 403 Table A1 LATTICE signature LATTICE sig type elt datatype relationship Less I Greater I Equal datatype option Some None val 1atOrd elt elt relationship option val elt val meet elt elt elt val elt val join elt elt elt val sort0rd elt 1 elt relationship end LATTICE Let begin discussing signature LATTICE lattices given lattice set relation In LATTICE lattice elements drawn type called elt represented function mapping pairs elts Table A1 constants definition According binary operators order relation 1atOrd elts values type relationship h Greater Less relationships produces relationship form Some x x relationship constants binary operations Equal option The values relationship represent 3 In lattice given pair elements satisfy takes pair lattice elements 1atOrd operation option output An element relationship option form None The meet join The function sortOrd mathematical definition lattice It arises wish form useful lattice elements To represent sets efficiently given purposes efficiency significance sets antichains linear ordering set elements related This allows sets represented element quickly It important trees generally different balanced lattice need linear ordering 1atOrd representing relationship pairs elements antichain option relative elements ordering trees searching balanced appreciate ordering ordering 1atOrd lattice fact image reflected relationship Note particular lattice ordering relationship antichains IZO satisfy stipulation linear order An LATTICE assumed Now let turn signature ANTICHAIN lattice axioms The semantics signature LATTICE given mathematical sortOrd semantics SML check Tables A2 A3 given selfevident mapping Table A2 taken analogy library The semantics The The semantics described mathematics names Constants operations described values described half ANTICHAIN ones basically notes delimited comment characters sets signature SMLNJ interface operations Table A3 signature Section 2 assuming operations implementation succinctly 404 CA Gunter et dArtificial Intelligence 95 1997 357407 Table A2 ANTICHAIN signature ANTICHAIN sig type elt type ac exception NotFound val ac Empty ac val singleton elt ac Create singleton ac val isEmpty ac boo1 Return true ac val equal ac ac boo1 Return true iff ats equal val oumElts ac int Return number elts ac val 1istElts ac elt Return list list elts ac val app elt b ac unit Apply function elts 1 ac decreasing order val revapp elt b ac unit Apply function elts ac increasing order val fold elt b b ac b 7 b Apply folding function elts ac decreasing order val revfold elt b b ac 7 b 7 b Apply folding function elts ac increasing order val exists elt bool 7 ac elt option Return elt ac satisfying predicate t return NONE sets antichains operation set antichain like singleton However essential apply antichains The important thing note refers meant antichain downward upwardclosed functions represent This distinction means taken gives number elements note function numElts equal regardless meaning CA Gunter et al Artijicial Intelligence 95 1997 357407 405 Table A3 ANTICHAIN continued val upperadd ac elt ac val loweradd ac elt ac Insert elt val upperfind ac elt elt val lowerfind ac elt elt Find elt set raise NotFound val val upperpeek ac elt elt option lowerpeek ac elt elt option Look elt set return NONE elt val val uppermember ac elt boo1 lowermember ac elt boo1 Return true iff elt set val val uppersubset ac ac boo1 lowersubset ac ac boo1 Subsets val val upperdifference ac ac ac lowerdifference ac ac ac Difference val val upper_union ac ac ac lowerunion ac ac ac Union val val upperhomogeneousintersection ac ac ac lower_homogeneous_intersection ac t ac ac Homogeneous intersection val val upperheterogeneousintersection ac ac ac lower_heterogeneous_intersection ac ac ac Heterogeneous intersection end ANTICHAIN end representing set represented distinction set So instance antichain number elements In semantic description given comments distinguishing comment consistently lower upper signatures antichain Return number elts antichain numElts means number elements takes set represented representing antichain antichain argument returns know If wanted 406 CA Gunter et 11 Artificial Intelligence 95 1997 357407 elements set antichain know antichain way enumerating For functions represents elements counting fold app revapp revf old meant represent need upper set lower set order increasing decreasing course sorttlrd The values declared second column ANTICHAIN come flavors upper_ value latOrdxy case value simply S If applied antichain viewed representing application upperaddS representing S means upper set x inserts x upper x added S instead Greater functions loweradd Less Equal Similarly finding peeking upper lower sets depending lower depending lower set So instance set S If S antichain element y S Equal check sortClrdxy peeking f inding prefixed The key points interfaces way described 1 The semantics model 2 What interfaces clear overconstrain include given abstractly mathematical implementation interface based selection mathematical express algorithms implementations support supporting sets operations substantial computationally described provides feasible needed primitives interfaces intended language interface 3 The types abstractions task techniques independent implementation implementation Although emphasis mathematical choice interfaces significantly desirable available achieve The interfaces provide vocabulary formally Let illustrate inefficient For example elements possible cases lattice mathematically difficult implement Hence omits LATTICE implementation descriptions influenced tension trying kind reuse programmer tradeoffs discuss In contexts Lattice2AC prove awkward lattices calls elements lattice signature implement ANTICHAIN Moreover In SML implementation desirable use thinner mathematics LATTICE LATTICE little lost thinning issue arises knows lattice input implementation efficient lattice finite set atoms antichains For instance anti lattice boolean implementation optimized taking advantage fact A functor lacks interface ANTICHAIN lattices terms takes atoms model Another useful knows chain LATTICE LATTICE needed primitives Moreover needs probably makes sense organize code functor input So given signature lattice operations defined use For reasons sets atoms chooses know atoms boolean simple representation input like CA Gunter et al Artificial Intelligence 95 19971 357407 407 signature sig ATOMS type elt val val elt eq atoms elt elt list boo1 end ATOMS implements functor Atoms2AC ATOMS ANTICHAIN Whether antichains mathematical plementations undoubtably differ lattice produced Lattice2AC remain semantics antichain operations Atoms2AC The im References I I I BA Davey HA Priestley Introduction httices Order Cambridge University Press Cambridge MA 1990 12 1 J Kleer An assumptionbased 3 J Kleer Extending 14 1 KD Forbus I Kleer Building Problem Solvers MIT Press Cambridge MA 1993 S Honiden On logical IS I Y Fujiwara Y Mizushima ATMS Artificial Intelligence 28 1986 163196 TMS Artijicial Intelligence 28 1986 127162 foundations ATMS 1990 Proceedings ECAI90 Workshop Truth Maintenance Systems Stockholm Sweden I6 1 CA Gunter Semanfics Programming Languages Structures Techniques Foundations Computing 7 I H Hirsh MIT Press Cambridge MA 1992 Incremental Version Space Merging A General Framework jbr Concept Learning Kluwer Academic Publishers Dordrecht Netherlands 1990 18 I C Mellish The description I9 I TM Mitchell The need biases identification problem Artificial Intelligence 52 1991 15 l167 generalization J Shavlik T Dietterich eds Readings Machine Learning Morgan Kaufmann Los Altos CA 1990 II0 I TM Mitchell Version Space approach concept leaning PhD Thesis Stanford University Stanford CA 1978 Ill I TH Ngair Convex spaces ordertheoretic basis problem solving PhD Thesis University Pennsylvania Philadelphia PA 1992 II2 I DS Scott C Strachey Towards mathematical semantics languages J Fox ed Computers Automata Polytechnic I 13 I J Simon On central problems Institute Brooklyn Press 1971 1946 computational complexity PhD Thesis Come11 University Ithaca NY 1975 I 141 M Smyth The largest Cartesian closed category domains Theoret Comput Sci 27 1983 109I 19 I I5 I S Vickers Topology Logic Tracts Press Cambridge MA 1989 Theoretical Computer Science Vol 5 Cambridge University