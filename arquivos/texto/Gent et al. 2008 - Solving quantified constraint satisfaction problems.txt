Artiﬁcial Intelligence 172 2008 738771 wwwelseviercomlocateartint Solving quantiﬁed constraint satisfaction problems Ian P Gent Peter Nightingale Andrew Rowley Kostas Stergiou b School Computer Science University St Andrews St Andrews Fife KY16 9SS UK b Department Information Communication Systems Engineering University Aegean Greece Received 15 August 2006 received revised form 2 April 2007 accepted 5 November 2007 Available online 22 November 2007 Abstract We number contributions study Quantiﬁed Constraint Satisfaction Problem QCSP The QCSP extension constraint satisfaction problem model combinatorial problems containing contingency uncertainty It allows universally quantiﬁed variables model uncertain actions events unknown weather future party opponents game In paper report signiﬁcant contributions different methods solving QCSPs The ﬁrst approach implement special purpose algorithms QCSPs second encode QCSPs Quantiﬁed Boolean Formulas use specialized QBF solvers The discovery particularly effective encodings inﬂuenced design effective algorithms analyzing properties encodings identify features QBF solvers responsible efﬁciency This enables devise analogues features QCSPs implement special purpose algorithms yielding effective special purpose solver QCSPSolve Experiments solver highly optimized QBF encoding orders magnitude efﬁcient initially developed algorithms A ﬁnal signiﬁcant contribution identiﬁcation ﬂaws simple methods generating random QCSP instances means generating instances known ﬂawed 2007 Elsevier BV All rights reserved Keywords Quantiﬁed constraint satisfaction problems Quantiﬁed Boolean formulas Arc consistency Search algorithms Random problems 1 Introduction Quantiﬁed Constraint Satisfaction Problems QCSPs model PSPACEcomplete combina torial problems domains like planning uncertainty design adversary game playing model checking For example game playing want determine consistent strategy exists possible moves opponent In design problem required conﬁguration possible possible sequences user choices As ﬁnal example planning safety critical environment nuclear station Parts paper appeared conference papers I Gent P Nightingale A Rowley Encoding quantiﬁed CSPs quantiﬁed Boolean formulae Proceedings ECAI2004 2004 pp 176180 I Gent P Nightingale K Stergiou QCSPSolve A solver quantiﬁed constraint satisfaction problems Proceedings IJCAI2005 2005 Corresponding author Email addresses ipgdcsstandacuk IP Gent pndcsstandacuk P Nightingale agdrdcsstandacuk A Rowley konstergaegeangr K Stergiou 00043702 matter 2007 Elsevier BV All rights reserved doi101016jartint200711003 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 739 require action possible eventuality QCSPs extend traditional unquantiﬁed CSPs deal kind contingency examples The QCSP naturally generalizes standard CSP formalism allowing universally quantiﬁed variables Universal variables model actions events contingent uncertain control Examples contingencies user choices conﬁguration problem uncertainties weather plan hold garden party opponent moves adversary game In conventional CSP variables existentially quantiﬁed control The values domain universal variable capture possible outcomes event action modelled variable In way QCSPs model bounded uncertainty In QCSP try ﬁnd strategy deﬁning values existential variables possible sequences instantiations universal variables constraints problem satisﬁed Such strategy guarantees solution values universal variables outcome uncertain actions events The generalization CSPs QCSPs increases expressiveness framework time complexity decision task rises NPcomplete PSPACEcomplete 82638 There considerable quantiﬁed constraint reasoning case Quantiﬁed Boolean Formulae QBF generalization SAT allows universal quantiﬁcation example 1323293233 Also signiﬁcant body work quantiﬁed problems continuous real domains 541 Ratschan gives numerous references papers subject 40 As far QCSPs discrete ﬁnite nonBoolean domains concerned recent research theory deﬁning complexity reasoning tasks specifying tractable subclasses 8111518 Also useful concepts CSPs global local consistency substitutability interchangeability deﬁned QCSPs 1112 However little far algorithms solving QCSPs concerned In existing works Bordeaux Monfroy introduced framework implementing arc consistency described ﬁltering operators certain classes constraints 9 12 Also recently Verger Bessière proposed bottomup solver QCSPs called BlockSolve 44 Benedetti Lallouet Vautard implemented QeCode QCSP solver built CSP solver Gecode 4 In paper report ﬁrst comprehensive attempt build effective QCSP solvers limit case constraints binary We contributions different approaches solving QCSPs These special purpose solvers QCSPs encoding QCSPs QBF instances existing QBF solvers In approach introduce novel effective techniques We experience encodings directly inﬂuenced design better techniques specialized solvers We ﬁrst approach QCSPs directly extending wellknown algorithms standard quantiﬁed case This analogous approach taken early stages research QBF We widely techniques CSPs adapted deal quantiﬁcation We ﬁrst generic arc consistency algorithm enforce AC binary QCSP We extend chronological backtracking BT forward checking FC maintaining arc consistency MAC algorithms handle quantiﬁcation We propose modiﬁcations FC MAC advantage properties QCSPs Then follow orthogonal approach based encoding QCSPs QBFs A particular advantage encod ing search problem occurs search techniques target problem highly developed original In contrast QCSP numerous advanced solvers available QBF We ﬁnelytuned encoding orders magnitudes efﬁcient direct methods described far The tuning encodings effective search considerably involved case SAT encodings elegant simplicity A simple way lifting CSP encodings QCSP ineffective explore implement new ideas analogues SAT search effective Apart obtaining efﬁcient tools QCSP solving beneﬁt study development encodings learn valuable lessons transferred direct algorithms So ﬁnal stage development algorithms QCSPs analyze advantages offered QBF encoding identify features responsi ble efﬁciency We identify sophisticated techniques conﬂictbased backjumping 39 solutiondirected backjumping 32 importantly pure literal rule 14 important reasons success QBF solvers solving encoded QCSP instances We devise analogues features QCSPs implement direct algorithms yield specialized direct solver called QCSPSolve A ﬁnal issue address paper benchmarking naturally distinct lack benchmarks compare algorithms This familiar problem appeared early stages experimental research 740 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 areas As case CSP SAT QBF address problem proposing methods generate random instances We simple generalization random generation models CSPs QBF QCSPs prone ﬂaws quickly affect generated instances We introduce random generator free ﬂaws remains possible suffer currently unknown ﬂaw Experiments run problems created generator reveal progressive dramatic improvement efﬁciency methods starting initial direct algorithms culminating QCSPSolve highly optimized QBF encoding This paper structured follows In Section 2 necessary deﬁnitions background We present progressively efﬁcient methods handling QCSPs In Section 3 follow direct approach extending standard algorithms CSPs QCSPs In Section 4 existing work encodings develop ﬁnelytuned encoding remarkably efﬁcient direct approaches In Section 5 lessons learned encoding QCSP QBF utilized enhance direct algorithms resulting QCSPSolve advanced solver QCSPs Section 6 describes ﬂaw arise random QCSPs introduces random generator QCSPs gives indicative experimental results demonstrate building progressively efﬁcient techniques Finally Section 7 conclude 2 Preliminaries A Constraint Satisfaction Problem CSP consists set variables associated domain possible values set constraints restricting combinations values variables simultaneously In CSPs variables existentially quantiﬁed QCSPs expressive allow universally quantiﬁed variables In way enable formulation problems contingencies allowed We formal deﬁnition QCSP instance As usual practice CSPs use QCSP denote particular instances decision problem determining instance true soluble Deﬁnition 1 A Quantiﬁed Constraint Satisfaction Problem QCSP F tuple cid3V Q D Ccid4 V linearly ordered set n variables In following denote vi ith element V respect linear order Q mapping V set quantiﬁers For variable vi V Qvi quantiﬁer associated vi D mapping V set domains D Dv1 Dvn For variable vi V Dvi ﬁnite domain possible values C c1 cm set m constraints Each constraint ci C deﬁned pair varsci relci 1 varsci vj1 vjk ordered subset V called constraint scope The size varsci called arity ci 2 relci subset Cartesian product Dvj1 Dvjk speciﬁes allowed combinations values variables varsci The deﬁnition QCSP reduces standard CSP universally quantiﬁed variables problem A block variables QCSP F maximal subsequence variables V quantiﬁcation The assignment called instantiation value aj Dvj variable vj V denoted vj cid8 aj Accordingly tuple assigning values a1 ai variables v1 vi denoted cid3v1 cid8 a1 vi cid8 aicid4 The set variables tuple τ deﬁned denoted varsτ For subset varscid10 varsτ τ varscid10 denotes subtuple τ includes assignments variables varscid10 A tuple τ consistent iff ci C st varsci varsτ τ varsci relci For constraint ci C variable vj V value Dvj denote civj cid8 subset relci includes tuples vj takes value If vj varsci civj cid8 relci We write Cvj cid8 shorthand c1vj cid8 cmvj cid8 In follows refer universally existentially quantiﬁed variables universals existentials respectively IP Gent et al Artiﬁcial Intelligence 172 2008 738771 741 Fig 1 A solution problem Example 1 Deﬁnition 2 QCSP semantics A QCSP F cid3V Q D Ccid4 represents logical formula φ Qv1v1 Dv1 Qvnvn Dvn C The semantics QCSP deﬁned recursively follows The base case QCSP instance quantiﬁer preﬁx Q variables assigned This QCSP stance true iff constraint ci C tuple values assigned variables scope varsci belongs relation relci Note QCSP vacuously true If φ form v1 Dv1 Qv2v2 Dv2 Qvnvn Dvn C F true iff exists value Dv1 Qv2v2 Dv2 Qvnvn DvnCv1 cid8 true Or words assignment v1 cid8 rest prob lem true If φ form v1 Dv1 Qv2v2 Dv2 Qvnvn Dvn C F true iff value Dv1 Qv2v2 Dv2 Qvnvn DvnCv1 cid8 true To better understand semantics QCSP ﬁrst need deﬁne notion strategy A strategy tree level tree corresponding variable Level 1 corresponds ﬁrst variable v1 V levels follow order V A node ith level tree corresponds tuple variable assignments cid3v1 cid8 a1 vi cid8 aicid4 a1 Dv1 ai Dvi The root tree corresponds tuple ﬁrst level nodes correspond 1tuple assigning value ﬁrst variable V second level nodes correspond 2tuples assigning ﬁrst variables V generated extending ﬁrst level assignment A node tree corresponding tuple cid3v1 cid8 a1 vi cid8 aicid4 children values Dvi1 vi1 universally quantiﬁed single child vi1 existentially quantiﬁed A node corresponding tuple τ cid3v1 cid8 a1 vi cid8 aicid4 true iff τ consistent Otherwise node false A tuple assignments variables QCSP ntuple constitutes scenario Within scenario value existential variable depends values universal variables precede V A scenario consistent iff variable assignments scenario satisfy constraints problem We alternative deﬁnition semantics QCSP A QCSP n variables true satisﬁable iff exists strategy leaf nodes nodes level n true1 Or words iff exists strategy scenarios strategy consistent Such strategy called consistent strategy simply solution QCSP As backtrackingbased algorithms solve QCSP traversing space strategies discover consistent prove exists Example 1 Consider problem v1v2v3v4 v1 cid14 v2 v1 cid14 v4 v3 cid14 v4 This QCSP V consists variables C conjunction constraints The problem reads values v1 exist values v2 values v3 exist values v4 constraints satisﬁed Assuming variables domain 0 1 2 problem true A solution problem depicted Fig 1 Each path leaf node consistent scenario Note contrast standard CSPs variables QCSP ordered This means changing order gives rise different problem For example problem vivj vi vj Dvi Dvj 0 1 true value vi ﬁnd value vj satisfy constraint However problem vj vi vj vi Dvj Dvi 0 1 false value vj satisﬁes constraint possible assignments vi 1 This deﬁnition easily extended case nodes pruned propagation 742 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 In paper restrict attention binary QCSPs As common assume constraint deﬁned pair variables In binary QCSP constraint denoted cij involves variables vi vj universally existentially quantiﬁed We assume constraint cij variable vi precedes vj V explicitly speciﬁed Some techniques described easily extended constraints arity extension involved We brieﬂy elaborate Section 31 3 Extending CSP algorithms handle QCSPs In section begin presentation techniques solving QCSPs We ﬁrst approach problem directly extending standard algorithms CSPs deal quantiﬁcation Namely arc consistency algorithm binary QCSPs adapt widely backtracking search algorithms handle QCSPs We notion value interchangeability exploited QCSPs break symmetries 31 Arc consistency An important concept CSPs concept local consistency Local consistencies properties achieved CSP typically algorithms polynomial time complexity remove inconsistent values prior search Arc consistency commonly local consistency property existing constraint programming engines A constraint cij CSP arc consistent AC iff value Dvi exists value b Dvj assignments vi cid8 vj cid8 b compatible satisfy cij In case b support constraint cij Accordingly support b constraint A binary CSP arc consistent iff constraints arc consistent The operation performed determine value Dvi supported value b Dvj respect constraint cij called constraint check Bordeaux Monfroy extended deﬁnition AC QCSPs described schema generic AC3based algorithm QCSPs 12 This algorithm instantiated achieve AC speciﬁc constraints necessarily binary ﬁltering operators deﬁned constraints A ﬁltering operator constraint c function speciﬁes values domains variables involved c arc inconsistent respect c taking consideration quantiﬁcation variables 12 Consider following example Example 2 Bordeaux Monfroy deﬁned ﬁltering operators constraint vi vj vi vj Boolean domains 12 These operators specify values Dvi Dvj arc inconsistent according quan tiﬁcation variables The application AC algorithm prune values domains For instance vi existentially quantiﬁed vj universally quantiﬁed formula vivj vi vj following applies If Dvj 0 value 0 pruned Dvi If Dvj 1 value 1 pruned Dvi The deﬁnition AC AC algorithm 12 based decomposing complex constraints constraints high arity present QCSP primitive constraints AC ﬁltering operators deﬁned As noted 12 deﬁnition somewhat different standard deﬁnition AC CSPs actually closer deﬁnition relational consistency 21 In 12 later 9 ﬁltering operators constraints Boolean variables linear numerical constraints deﬁned The aim work AC QCSPs deﬁne ﬁltering operators arbitrary binary constraints opposed speciﬁc constraints known semantics embed efﬁcient algorithm We ﬁrst alternative deﬁnition AC binary QCSPs closely follows standard CSP deﬁnition Based deﬁnition deﬁne ﬁltering operators arbitrary binary constraints straightforward way Finally QAC2001 generic AC algorithm utilizes ﬁltering operators achieve AC arbitrary binary QCSPs In contrast algorithm 12 based AC3 QAC2001 based AC200131 AC algorithm 6 binary CSPs2 2 Note AC algorithms like AC6 basis We chose use AC200131 simplicity optimal time complexity IP Gent et al Artiﬁcial Intelligence 172 2008 738771 743 Deﬁnition 3 A binary QCSP F cid3V Q D Ccid4 arc consistent iff constraints cij C arc consistent Consider constraint cij C vi vj V There possible combinations quantiﬁcation vi vj For case constraint cij arc consistent iff vi vj Each value Dvi supported value Dvj value b Dvj supported value Dvi vi vj Each value Dvi supported values Dvj value b Dvj supported values Dvi vi vj Each value Dvi supported value Dvj value b Dvj supported value Dvi vi vj Each value Dvi supported values Dvj value b Dvj supported value Dvi Matching cases deﬁnition deﬁne ﬁltering operators arbitrary binary constraint cij follows These ﬁltering operators specify values arc inconsistent removed domains variables involved constraint vi vj cij If value Dvi support Dvj removed Dvi Similarly value b Dvj support Dvi b removed Dvj If domains problem false vi vj cij If value Dvi supported values Dvj case value b Dvj supported values Dvi problem false Note sufﬁces check constraint direction If values vi supported values vj obviously opposite holds vi vj cij If value Dvi support Dvj problem false If value b Dvj support Dvi b removed Dvj If Dvj problem false vi vj cij If value Dvi supported values Dvj removed Dvi If Dvi problem false If value b Dvj support Dvi problem false Note sufﬁces check constraint direction If value Dvi supported values Dvj obviously values Dvj support Dvi In Fig 2 sketch algorithm QAC2001 The algorithm takes input QCSP F cid3V Q D Ccid4 removes unsupported values domains variables ﬁltering operators described If domain existential value removed domain universal algorithm returns FALSE The algorithm performs constraintbased propagation That uses stack constraints propagated instead stack variables Apart similar AC200131 augmented handling universal variables As AC200131 use structure called currentSupport corresponding structure Last 6 track recently discovered supports values variables To precise cij C currentSupportvi avj value Dvj currently supports value Dvi For vi V Dvi vj V st vi constrained vj currentSupportvi avj initialized NIL As 6 value NIL deﬁned dummy value precedes value domain We assume exists order values domains Initially constraints added stack S Constraints form vivj cij vivj cij dealt preprocessing step function QAC2001 For value Dvi supported values Dvj removed Dvi For value Dvi supported values Dvj determine problem false Such constraints removed S considered propagation phase In propagation phase function Revise called constraint cij stack This function looks support Dvj value Dvi This ﬁrst looking value currentSupportvi avj If NIL removed Dvj propagation values vj examined starting immediately currentSupportvi avj If support removed Dvi In case vi 744 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 Boolean QAC2001F cid3V Q D Ccid4 input A QCSP F output TRUE AC successfully applied F FALSE domain wipeout existential value removed domain universal constraints C S Scid10 cij C Qvi Qvj Dvi supported values Dvj return FALSE add cij Scid10 cij C Qvi Qvj Dvi supported values Dvj remove Dvi Dvi return FALSE add cij Scid10 S S Scid10 return PropagationF S function PropagationF S stack input A QCSP F stack variables S output TRUE AC successfully applied F FALSE domain wipeout existential value removed domain universal constrained pair variables vi vj V Dvi currentSupportvi avj S cid14 NIL pop constraint cij S Revisevi vj currentSupport Qvi Dvi return FALSE constraint cki S return TRUE function Revisevi vj currentSupport input A pair variables vi vj data structure currentSupport output TRUE value removed domain FALSE DELETION FALSE Dvi currentSupportvi avj NIL longer Dvj exists b Dvj currentSupportvi avj b supports currentSupportvi avj remove Dvi b Qvi return TRUE DELETION TRUE return DELETION Fig 2 QAC2001 An arc consistency algorithm binary QCSPs universally quantiﬁed Dvi determine problem false Otherwise constraint cki involving vi variable vk added stack revised The algorithm terminates successfully stack We despite presence universal quantiﬁers worstcase time complexity QAC2001 AC200131 We assume m number binary constraints problem d maximum domain size IP Gent et al Artiﬁcial Intelligence 172 2008 738771 745 Proposition 1 The worstcase time complexity algorithm QAC2001 Omd 2 Proof The worstcase time complexity algorithm determined examining constraint checks exe cuted loops function QAC2001 function Propagation In ﬁrst loop iterate constraints cij involve universal variables vi vj For value Dvi check supported values Dvj Therefore iteration costs Od 2 constraint checks Hence ﬁrst loop costs Omd 2 checks In second loop iterate straints cij involve existential variable vi universal vj As ﬁrst loop easy cost second loop Omd 2 Function Revise called d times constraint cij C deletion value Dvj In Revise algorithm performs d checks value Dvi currentSupportvi avj domain Dvj If NIL algorithms tries ﬁnd new support Dvj starting value immediately currentSupportvi avj Since use structure currentSupport time Revise called cij value Dvi check values checked In words check d values Dvj value vi So overall worst case d checks plus d checks test validity current support For d values vi upper bound checks performed variable AC Od 2 For m constraints worstcase complexity bound Propagation Omd 2 Hence worstcase time complexity QAC2001 Omd 2 md 2 md 2 Omd 2 cid2 The generalization AC nonbinary constraints usually referred Generalized Arc Consistency GAC Processing nonbinary constraint achieve GAC according deﬁnition Bordeaux et al 91112 challenging binary case reasons Firstly level consistency generalization GAC CSP enforcing takes exponential time general binary quantiﬁed arc consistency enforced Omd 2 Secondly algorithm achieves GAC nonbinary QCSPs considerably complex similar algorithm GAC CSP constraint arity k able handle 2k different quantiﬁer sequences Thirdly support value nonbinary constraint c longer simply tuple includes value allowed c CSP case Here need complex deﬁnition support takes account quantiﬁed variables constraints scope Hence restrict attention binary QCSPs paper leave consistency algorithms nonbinary QCSPs future work Finally compared work 12 AC note following differences We deal binary constraints deﬁnition 12 generic covers GAC We deﬁned ﬁltering operators arbitrary binary constraints 12 deﬁned ﬁltering operators speciﬁc binary ternary Boolean numerical constraints The AC algorithm 12 based AC3 based AC200131 32 Search algorithms Numerous search algorithms developed CSPs Most based backtracking search In section adapt chronological backtracking BT forward checking FC 35 maintaining arc consistency MAC 42 deal binary QCSPs Also slightly modifying FC MAC algorithms discover inconsistencies earlier efﬁcient For algorithm assume commencing search input QCSP AC algorithm QAC2001 Under assumption consider constraints form vivj cij vivj cij algorithms All values variable vi constraints deﬁnitely consistent values variable vj If value consistent removed application QAC2001 This implies search safely ignore variables V universally quantiﬁed For instance problem vivj vkvl cij cj k ckl AC remove constraint ckl ignore variable vl Hence sufﬁces apply search simpliﬁed problem vivj vk cij cj k 321 Chronological backtracking BT depicted Fig 3 straightforward extension corresponding algorithm standard CSPs It takes input QCSP F traverses space strategies truth problem proved disproved To simplify 746 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 assign vcur value Dvcur vcur cid8 compatible assignments past variables vcur last_evcur values Dvcur tried Boolean BTF cid3V Q D Ccid4 input A QCSP F output TRUE solution F exists FALSE 1 vcur v1 2 vcur cid14 NIL Qvcur 3 4 5 6 7 8 9 10 11 12 13 Qvcur 14 15 16 17 18 19 vcur NIL return FALSE vcur ﬁrst universal V return TRUE vcur last_uvcur universals V return TRUE vcur last_uvcur assign vcur value Dvcur values Dvcur tried vcur nextvcur vcur nextvcur vcur vn Fig 3 Chronological backtracking binary QCSPs description algorithm ones follow assume variables assigned values following order V However consecutive variables quantiﬁcation instantiated order The variable currently instantiated called current variable denoted vcur The variables V vcur called future variables ones vcur called past variables A situation values current variable deemed inconsistent called deadend We use following functions For variable vi function nextvi returns variable immediately vi V last_u For variable vi function last_uvi returns variable vj V vj universally quan tiﬁed precedes vi V universal variable vj vi V If vf u ﬁrst universal V last_uvf u NIL last_e For variable vi function last_evi returns variable vj V vj existentially quan tiﬁed precedes vi V existential variable vj vi V If vf e ﬁrst existential V last_evf e NIL BT terminates successfully values ﬁrst universal variable consistent scenario line 15 In case universals problem algorithm terminates successfully existential consistently instantiated line 10 problem standard CSP If current variable existential deadend occurs algorithm backtracks previously instanti ated existential variable possibly jumping universal variables lines 45 Detecting deadend means algorithm determines currently explored strategy extended solution Therefore backtracks previous existential assign new value explore alternative strategy If deadend available value current variable checked previous assignments line 8 If value compatible assignments past variables BT reached true leaf node backtracks previous universal variable line 11 If BT leaf node proceeds moving variable line 12 In case constraint check fails BT tries value current variable iteration loop If current variable universal cases If values proved consistent scenario BT backtracks previous universal variable lines 14 16 assign value If current variables values tried BT assigns value proceeds variable lines 17 18 Note BT assigns value universal variable check value IP Gent et al Artiﬁcial Intelligence 172 2008 738771 747 previously assignments The reason AC preprocessing values universal variable vi deﬁnitely consistent values variables vi V Correctness BT We demonstrate informally correctness BT To soundness need demon strate BT returns true traversing strategy strategy consistent Or words scenarios strategy consistent Take scenario strategy consider tuple signments τ cid3v1 cid8 a1 vi cid8 aicid4 scenario BT extends tuple variable vi1 assigning value ai1 ai1 consistent assignments τ Therefore tuple cid3v1 cid8 a1 vi cid8 an1cid4 extended ntuple assignments tuple consistent This means tuple consistent scenario To completeness need demonstrate consistent strategy exists BT correctly verify returning true traversed It sufﬁces BT traverses entire search space apart subspaces consistent strategy BT systematically explores search space trying verify sequence assignments universals ﬁnd consistent scenario includes assignments Search subspaces skipped 1 value current variable fails constraint check assignment past variable 2 backtrack existential In ﬁrst case let τ cid3v1 cid8 a1 vi1 cid8 ai1cid4 current tuple assignments assume value ai current variable vi fails constraint check assignment τ Tuple τ extended consistent scenario ai subtree corresponding node correctly pruned A backtrack existential vi assigned value ai means currently explored strategy extended consistent strategy ai subtree corresponding node correctly pruned 322 Forward checking MAC Many ways improve performance BT proposed CSP literature Most classiﬁed lookahead lookback methods The try detect inconsistencies early performing local reasoning variable instantiation The try deal deadend intelligent way identifying variables responsible deadand directly backtracking variables We commonly lookahead algorithms FC MAC adapted QCSPs Lookback methods QCSPs discussed Section 5 The algorithm FC0 shown Fig 4 extension standard FC QCSPs It operates way similar BT difference standard CSPs constraint checks future instead past variables To precise variable assignment existential universal checked values future existentials function Forward_Check0 lines 9 25 In function value compatible current assignment temporarily removed domain corresponding variable As mentioned constraints form vi vj cij vi vj cij handled preprocessing Therefore checks universals performed If values removed domain variable domain wipeout current assignment rejected In case vcur existential procedure Restore called undo changes domains variables line 16 Then algorithm try value vcur iteration loop If vcur universal algorithm backtrack previous existential last_evcur V line 29 Before backtracking values temporarily removed assignments variables last_evcur vcur restored domains procedure Restore line 28 Note Restore called backtrack occurs That apart case described restoration values domains required deadend encountered line 5 true leaf node reached line 13 assignments universal proved consistent scenario line 21 By slightly modifying forward checking function FC0 algorithm FC1 discover inconsistencies earlier FC0 Algorithm FC1 exactly behavior FC0 current variable existentially quantiﬁed If current variable vcur universally quantiﬁed ﬁrst check value vcur future variables assigning speciﬁc value This Function Forward_Check1 depicted Fig 5 If vcurs values causes domain wipeout backtrack existential variable Otherwise proceed usual way instantiating vcur available value removing values future variables incompatible assignment vcur cid8 In way discover deadends earlier avoid fruitless exploration search tree branches 748 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 vcur vn values Dvcur tried RestoreF vcurlast_evcur vcur last_evcur universals V return TRUE assign vcur value Dvcur Forward_Check0F vcur Boolean FC0F cid3V Q D Ccid4 input A QCSP F output TRUE solution F exists FALSE 1 vcur v1 2 vcur cid14 NIL Qvcur 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Qvcur 18 19 20 21 22 23 24 25 26 27 28 29 30 vcur NIL return FALSE RestoreF vcurlast_uvcur vcur last_uvcur vcur nextvcur RestoreF vcur vcur assign vcur value Dvcur Forward_Check0F vcur vcur ﬁrst universal V return TRUE RestoreF vcurlast_uvcur vcur last_uvcur RestoreF vcurlast_evcur vcur last_evcur values Dvcur tried vcur nextvcur function Forward_Check0F vcur input A QCSP F current variable vcur assigned value output TRUE domain wiped FALSE 1 existential vi vcur V 2 3 4 5 6 return TRUE vi cid8 b incompatible vcur cid8 temporarily remove b Dvi Dvi wiped return FALSE b Dvi procedure RestoreF vcur vback input A QCSP F current variable vcur variable algorithm backtrack vback output 1 vi vback vcur 2 3 restore Dvj value removed vi s instantiation existential vj vi V Fig 4 FC0 Forward checking binary QCSPs Note lookahead FC1 need applied algorithm reaches universal branch search tree That immediately trying ﬁrst available assignment universal Assuming universals possible assignments causes domain wipeout applying FC1 type lookahead IP Gent et al Artiﬁcial Intelligence 172 2008 738771 749 function Forward_Check1F vcur input A QCSP F current variable vcur output FALSE value vcur incompatible values existential TRUE 1 Dvcur 2 3 4 return TRUE vcur cid8 incompatible values Dvi return FALSE existential vi vcur V Fig 5 Forward checking function algorithm FC1 backtrack universal occurs redundant This obvious restoration values guarantees result remaining possible assignments universal cause domain wipeout It easy FC1 visit number search tree nodes FC0 discover inconsistency earlier FC0 later The algorithms incomparable number constraint checks perform That depending problem FC0 perform checks FC1 vice versa Correctness FC The correctness FC informally demonstrated following similar arguments case BT In addition need forward checking functions FC0 FC1 correct That prune parts search space belong consistent strategy Function Forward_Check0 called assigning existential universal variable vi value ai Assume current tuple assignments τ cid3v1 cid8 a1 vi cid8 aicid4 Forward_Check0 prune value domain future existential fails constraint check assignment vi cid8 ai This means value consistent τ τ extended consistent scenario includes value Hence correctly pruned Forward_Check1 called assigning universal variable vi value ai Dvi temporarily prunes value domain future existential fails constraint check ai If domain future existential vj wiped algorithm backtracks Assume assignment vi cid8 ai causes wipeout Dvj This means value vj participate consistent scenario currently explored strategy includes assignment vi cid8 ai Therefore consistent scenario includes vi cid8 ai exists current strategy algorithm correctly backtracks try alternative strategy Maintaining arc consistency Based description FC easily adapt MAC algorithm QCSPs MAC widely complete search algorithm CSPs It reduces domains future variables search applying AC algorithm problem variable instantiation In way inconsistencies discovered early search effort saved To implement MAC QCSPs need simple modiﬁcation pseudocode FC0 We need replace calls Forward_Check0 lines 9 25 Fig 4 calls function Propagation QAC2001 In case stack constraints initialized adding constraints involve current variable MAC modiﬁed way FC yield MAC1 algorithm analogous FC1 That current variable vcur universally quantiﬁed temporarily enforce AC instantiation vcur cid8 Dvcur committing particular instantiation If instantiations causes domain wipeout backtrack Otherwise commit values proceed variable 33 Symmetry breaking Many CSPs contain symmetries means given solution equivalent solutions This profound effect search cost looking solutions CSP Various methods symmetry breaking proposed Most methods add symmetry breaking constraints problem statically search dynamically search A survey work symmetry standard CSPs recently published giving extensive references large body work area 30 QCSPs particular greatly beneﬁt symmetry breaking techniques check exists consistent scenario values universally quantiﬁed variables We propose exploitation value 750 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 interchangeability static dynamic symmetry breaking technique QCSPs However consider simple type symmetry paper leaving future work extension powerful techniques devised constraint satisfaction Some advanced concepts like value substitutability symmetry breaking QCSPs deﬁned implemented 11 The notion interchangeable values CSPs deﬁned Freuder 24 A value variable vi fully interchangeable value b vi iff solution contains assignment vi cid8 remains solution substitute b vice versa Since determining interchangeability coNPcomplete 10 Freuder deﬁned local interchangeabilities polynomially computable Deﬁnition 4 Given variable vi V value Dvi neighborhood interchangeable NI value b Dvi iff vj V vj constrained vi b supported exactly values Dvj Neighborhood interchangeability sufﬁcient necessary condition interchangeability 24 A set NI values replaced single representative set losing solutions Experiments showed reduce search effort standard CSPs applied preprocessing step search especially looking solutions problem 236 In follows refer NI values simply interchangeable In context QCSPs exploit interchangeability break symmetries pruning domains universal variables That set called bundle NI values representative remove permanently search temporarily search If algorithm ﬁnds consistent scenario representative value surely exists rest NI values Therefore branching values redundant Consider following example Example 3 We QCSP v1v2v3 v1 cid14 v2 v1 cid14 v3 domains variables Dv1 0 1 2 3 4 Dv2 0 1 Dv3 0 2 Values 3 4 v1 NI supported values v2 v3 Therefore replaced single value differently pruned domain The cost computing neighborhood interchangeable values CSP algorithm 24 Od 2n2 In QCSPs detect NI values preprocessing step remove values domains universal variables detect dynamically search avoid repeated exploration similar subtrees Example 4 Assume variables vivj vkvl QCSP domains Dvi a1 a2 Dvj Dvk Dvl a3 a4 a5 a6 Also QCSP includes constraints cij cik cil Assume value a1 supported values a3 a4 a5 vj vk vl a2 supported a3 a4 a6 If current variable stage search vi values a5 a6 previously removed domains vj vk vl stage a1 a2 NI We proceed search consistent scenario includes assignment vi cid8 a1 If backtrack universal variable vi need perform similar search assignment vi cid8 a2 If backtrack undo deletions values a5 a6 domains vj vk vl time reach variable vi values a1 a2 NI Naturally use NI reduce domains existential variables proposed Freuder However experiments showed overhead slows algorithms The small reduction number search tree node visits outweighed cost computing NI values existentials NIbased symmetry breaking embedded search algorithms described previously simple procedures The ﬁrst detects bundles NI values preprocessing step keeps representative bundle removes rest domains universals To check values b universal variable vi NI procedure iterates domain existential variable vj V constrained vi vi V If value support b vice versa b NI Otherwise NI removed This repeated pairs values vi In similar way second procedure dynamically detects bundles NI values time algorithm reaches universal variable vi In case representative bundle kept rest values temporarily removed Dvi The IP Gent et al Artiﬁcial Intelligence 172 2008 738771 751 values restored algorithm backtracks variable vi V The worstcase time complexity symmetry detecting procedures currently implemented Od 3n2 4 Encoding QCSP QBF In section ﬁrst general background QBFs Then brieﬂy elaborate difﬁculties encoding QCSP QBF features QBF solver experiments In main section present previous best encoding QCSP QBF adapted log encoding introduce new encoding improves simplicity performance 41 Quantiﬁed Boolean Formulae A special case QCSP Quantiﬁed Boolean Formula QBF A QBF form cid3V Q D Ccid4 V Q deﬁned Deﬁnition 1 domain D elements F T 0 1 C Boolean formula conjunctive normal form CNF conjunction clauses clause disjunction literals Each literal variable sign A literal said negative negated positive A universal literal literal variable universally quantiﬁed existential literal literal variable existentially quantiﬁed The semantic deﬁnition QCSPs Note 2QBF QBF problems literals clause solvable polynomial time However binary QCSPs PSPACEcomplete 8 A QBF vacuously true consists set clauses It vacuously false set clauses contains clause clause literals universal clause clause universal literals 42 The difﬁculty encoding QCSP QBF Gent Nightingale Rowley introduced number different ways encode QCSP instance QBF 27 To encode existential QCSP variable set QBF variables assignments QBF variables represent values original variable assignments ruled adding clauses formula For example assignment QBF variables indicates original QCSP variable values domain assignment invalid ruled clause However approach possible universal QCSP variable To consider following example In QBF instance φ universal variables xi xj φ represents adversarial game assignment xi T xj T represents cheating game Naively use clause xi xj rule assignment Unfortunately clause trivially false render φ false The encodings introduced 27 able overcome difﬁculty However global acceptability encod ing local acceptability encoding inefﬁcient compared direct QCSP algorithms In contrast adapted log encoding turned efﬁcient 43 QBF solver Many advanced solvers QBF proposed literature 3722323437 We concentrate search based solvers interleave search instantiating variables individually quantiﬁer order reasoning formula local reasoning They based DavisPutnamLogemannLoveland algorithm 1920 adapted QBF 14 Local reasoning cuts search space Also certain situations backjumping applied allows solver jump levels search tree undoing search operations identifying cause success failure We brief overview literature set encodings context We use solver CSBJ 37 implements following local reasoning techniques We sketch technique broadest way refer reader details Unit propagation A literal l variable x unit appears clause literals clause universal corresponding variables quantiﬁed x 14 When l unit instantiated 752 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 l T formula simpliﬁed If x universal formula simpliﬁes false Otherwise clauses containing l removed literals l removed This cause literals unit The pure literal rule A literal l called pure monotone complementary literal appear clause 14 Such literals important immediately assigned value need branching This pure literal rule If existential pure literal l set true If false leaf node reached assigning l false unnecessary certain lead false leaf node If universal pure literal l set false If true leaf node reached assigning l true unnecessary certain lead true leaf node As mentioned local reasoning search commonly augmented backjumping CSBJ implements ﬂict solution backjumping We informally techniques This intended ﬂavor techniques Conﬂictbased backjumping Conﬂictbased backjumping CBJ lookback technique originally proposed CSPs tries reduce number backtracks performed search algorithm 39 CBJ tries deal deadends intelligent way recording exploiting conﬂict sets A conﬂict set set existential literals assignments responsible contradiction formula universal clause When contradiction encountered CBJ backjumps existential literals conﬂict set current variable instead blindly backtracking assigned existential In way search effort saved Solutiondirected backjumping Solutiondirected backjumping SBJ specialized technique QBF tries avoid redundant search true leaf node reached search tree 32 This accomplished recording exploiting solution sets A solution set set universals clauses satisﬁed current assignment existentials satisﬁed universals After true leaf node reached solution set calculated SBJ backjumps variables set possibly jumping universals Efﬁcient implementation crucial SAT domain techniques carried solver For example watched literals efﬁcient lazy unit propagation watched clauses pure literal rule 37 44 Adapted log encoding This section describes previous contribution adapted log encoding Gent Nightingale Rowley 27 It described order set enhanced log encoding following section context We brieﬂy explain main groups clauses encoding For technical details refer reader Gent et al 27 In order deal difﬁculty described adapted log encoding uses indicator variables ﬁrst described Rowley 31 indicate universal assignment valid An indicator variable takes value T iff particular invalid assignment universal variables There indicator variable zv original universal QCSP variables v zv existentially quantiﬁed ﬁnal block end variable sequence All clauses representing constraints contain literal zv Hence true assignment setting zv true In way invalid assignment universal variables formula simpliﬁes true unit propagation required deal difﬁculty In SAT noted variables needed encode 8 values CSP variable instead 8 direct encoding 2545 This known log encoding Walsh proves unit propagation log encoding work direct encoding 45 rarely However adapt log encoding QCSP good results Each variable QCSP encoded set variables QBF sets quantiﬁed way order QCSP Additional existential variables added end variable sequence For existential variable QBF variable represents value For universal value represented unique assignment QBF variables value represented existential QBF variable quantiﬁed IP Gent et al Artiﬁcial Intelligence 172 2008 738771 753 end There clauses maintain correspondence representations named channelling clauses We encoding We ﬁrst QCSP variables encoded present clauses encoding The notation wu set w variables superscript u subscript The way xu iu Quantiﬁcation To encode existential variable v 1 d We use existential variables xv To encode universal variable u 1 d We use universal variables wu We use existential variables representing value xu 1 xu d Finally We use indicator variables invalid assignment wu cid18log2dcid191 wu 1 xv d 0 iu zu overall indicator variable For universal variable v following clauses map assignments wv These channelling clauses ensure xv set T wv variables corresponding invalid assignment Variable u universal directly precedes v QCSP variable order The indicator variable zu T u previous universal invalid assignment channelling clauses true situation variables set T indicator variable iv iv iv xv The clauses given example d 5 general form easy infer example Channelling clauses zu zu zu zu zu zu zu zu cid3 cid3 cid2 wv wv wv 1 2 cid2 wv wv wv 1 2 cid2 wv wv wv 1 2 cid2 wv wv wv 1 2 cid2 wv wv wv 1 2 cid2 wv wv wv 1 2 cid2 wv wv wv 1 2 cid2 wv wv wv 1 2 0 xv 1 cid3 0 xv 2 0 xv 3 cid3 0 xv 4 0 xv 5 0 iv 6 0 iv 7 cid3 0 iv 8 cid3 cid3 cid3 These expressions correspond possible assignments wv cid3F F F cid4 ﬁrst ex pression cid3T T T cid4 Each assignment linked xv variable valid iv variable The expressions expanded clauses encoding 2 wv 1 wv 0 The variables iv single indicator variable zv T iff iv T indicate assignment invalid particular way These variables accumulated T previous accumulated indicator variable zu Indicator collector clauses zv iv 6 iv 7 iv 8 zu Note zv set T assignment propagated indicator collector clause accumulated indicator variable T This assignment propagated For existential variable v QBF variables xv set true ensure v assigned value This accomplished atleastone ALO clause 754 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 ALO clause cid4 xv i1d Constraints represented follows Consider constraint cuv variables u v u precedes v variable order A pair values cid3i j cid4 Du j Dv satisfy constraint belong relcuv represented single clause QBF Assume variable t universally quantiﬁed directly precedes v variable order Note t u The indicator variable zt t preceding universal variable set invalid way conﬂict clause satisﬁed When universal set invalidly remaining QBF true Given conﬂict clauses contain indicator variables negative literals Conﬂict clauses cid3i j cid4 relcuv zt xu xv For channelling conﬂict clauses preceding universal variable QCSP indicator variable omitted To illustrate encoding example simple QCSP Example 5 Consider QCSP vu v cid14 u Dv Du 1 5 This encoded follows QBF variables 1 xv 2 wv Channelling clauses v 0 xv 1 wv wv 2 xv 3 xv 4 xv 5 xu 1 xu 2 xu 3 xu 4 xu 5 zv iv 6 iv 7 iv 8 0 xv wv wv wv 1 1 2 0 xv wv wv wv 2 1 2 0 xv wv wv wv 3 1 2 0 xv wv wv wv 4 1 2 0 xv wv wv wv 5 1 2 0 iv wv wv wv 6 1 2 0 iv wv wv wv 7 1 2 0 iv wv wv wv 8 1 2 Indicator collector clauses v iv 7 iv zv iv 8 6 Atleastone clause u xu xu 4 2 xu 3 Conﬂict clauses representing v cid14 u xu 5 xu 1 zv xv 1 zv xv 2 zv xv 3 zv xv 4 zv xv 5 xu 1 xu 2 xu 3 xu 4 xu 5 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 755 The subtlety encoding omit clauses force equivalence xv b implication way channelling clauses involving xv 2 It erroneous allows universal values xv corresponding So omit clauses zu values wv wv xv 1 xv 2 true 1 But way setting universal variables wv true The advantage arrangement xv variables occur positively channelling clauses Therefore particular variable v occur conﬂict clause pure Furthermore lead wv x1 variables pure reducing need search So sufﬁcient care use pure literal rule included QBF solver work QCSP case This property carries enhanced log encoding described force xv 45 Enhanced log encoding The enhanced log encoding reﬁnement adapted log previously published Each universal consecutively universally quantiﬁed The order variables d variables universal QCSP variable v existentially quantiﬁed variables channelled variable v encoded cid18log2dcid19 variables wv preserved We introduce xv end variable sequence These xv xv variables set d clauses For following example d 5 variables conﬂict clauses The wv 1 xv Channelling clauses 0 xv 1 0 xv 2 wv wv wv 1 2 wv wv wv 1 2 1 xv wv wv 3 2 1 xv wv wv 4 2 1 xv wv wv 5 2 There 8 possible assignments wv variables 5 values values 3 4 5 wv assignments mapped 8 assignments valid In contrast adapted log local acceptability variable zv previous subsection present assignments previous universal variables invalid To state formally represent QBF tuple F cid10 cid3Qcid10 V cid10 Ccid10cid4 Qcid10 quantiﬁer mapping V cid10 ordered set Boolean variables Ccid10 set disjunctive clauses mirror QCSP F cid3Q V D Ccid4 Domains excluded 0 1 The ordered set variables V QCSP encoded ordered set Boolean variables shown following recursive rules translateV V cid10 translatev 1 d V1 xv translatev 1 d V2 wv 1 xv cid18log2dcid191 wv An existential variable v QCSP instance mapped d existential variables xv 0 translateV2 xv d translateV1 1 xv d 1 xv d encoding cid5 i1d xv These represent value domain The enhanced log encoding atleastone clause In respect enhanced log encoding identical adapted log A universal variable v QCSP mapped l cid18log2dcid19 variables wv Every complete assignment A 2l mapped value b Dv All values b map assignment variables wv assignments literal different It necessary value b mapping signments value d 2l d values map assignments An assignment A represented conjunction literals wv 1 For value b maps assignment A channelling 0 clause follows A xv b wv The negated conjunction A converted disjunction usual way For value c maps assignments A1 A2 channelling clause given A1 A2 xv c 756 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 The simpliﬁcation A1 A2 ends disjunction l 1 literals For constraint cij satisfying tuples relcij conﬂict clauses Conﬂict clauses For tuples cid3a bcid4 relcij xvi x vj b To illustrate encoding encode QCSP Example 5 Example 6 We QCSP vu v cid14 u Dv Du 1 5 This encoded follows QBF variables 1 xv 2 wv Channelling clauses v 0 xv 1 wv wv 2 xv 3 xv 4 xv 5 xu 1 xu 2 xu 3 xu 4 xu 5 0 xv 1 0 xv 2 wv wv wv 1 2 wv wv wv 1 2 1 xv wv wv 3 2 1 xv wv wv 4 2 1 xv wv wv 5 2 Atleastone clause u xu 1 xu 2 xu 3 xu 4 xu 5 Conﬂict clauses representing v cid14 u xv 1 xv 2 xv 3 xv 4 xv 5 xu 1 xu 2 xu 3 xu 4 xu 5 Theorem 1 A QCSP true encoded QBF true enhanced log encoding Proof The proof recursive closely follows deﬁnition QCSP semantics deﬁnition 2 A QCSP F cid3V Q D Ccid4 represents logical formula φ Qv1v1 Dv1 Qvnvn Dvn C encoded QBF F cid10 cid3V cid10 Qcid10 Ccid10cid4 representing φcid10 Qcid10x1x1 Qcid10xnxn Ccid10 The encoding QCSP containing variables constraints QBF vacuously true Existential case Assume φ form v1Qv2 C domains omitted simplicity Now φcid10 form xv1 d translateQv2 Ccid10 By Deﬁnition 2 F true iff exists value Dv1 Qv2 QvnCv1 cid8 true Equivalently encoding F cid10 true iff exists assignment A xv1 1 cid8 b1 xv1 d 1 xv1 cid8 bd ALO clause true translateQv2 Ccid10A true The QCSP value value xv1 extended solution cid8 1 If st xv1 cid8 1 values IP Gent et al Artiﬁcial Intelligence 172 2008 738771 757 Universal case Assume φ form v1Qv2 C Now φcid10 form wv1 wv1 l By Deﬁnition 2 F true iff values Dv1 Qv2 Cv1 cid8 true Equivalently encoding F cid10 true iff assignments A wv1 cid8 bl wv1 l 0 0 translateQv2 Ccid10 l cid18log2dcid19 1 Ccid10A true cid8 b0 translateQv2 Note value covered assignment A If assignment A additional xv1 introduced encoding 1 channelling clauses Other variables xv1 channelling clauses set 0 contained conﬂict clause variable bcid14a constrained Therefore examination Deﬁnition 2 encoding true iff original QCSP true step recursion Deﬁnition 2 performed equivalently QCSP encoding cid2 The problem encoding QBF solver search equivalent subtrees cases example wv 2 After setting wv cid8 T wv 1 2 wv cid8 T solver branch wv 0 contained clause 0 wv 0 exist Both wv 1 set T ﬁrst clauses satisﬁed reduced set clauses wv 0 pure solver implements pure literal rule branch variable This solves repeated subtree problem mentioned condition wv 0 set Also common adapted log encoding channelling works wv xv variables positive xv literals included clause set pure literal rule detect cases xv involved conﬂicts In circumstances lead elimination wv variables For example 4 xv xv 2 pure search reduced accordingly 5 pure wv 5 QCSPSolve A direct solver QCSPs The efﬁciency adapted enhanced log encodings largely ability exploit sophisticated techniques offered underlying QBF solver pure literal rule conﬂictbased backjumping solutiondirected backjumping Two questions immediately arise techniques correspond QCSPs implement direct algorithms In section try answer questions resulting efﬁcient direct solver QCSPSolve QCSPSolve performs backtracking search described Section 3 augmented capabilities First QCSPSolve applies algorithm QAC2001 preprocessing step As explained Section 31 apart reducing problem size deleting values domains existentials QAC2001 removes problem constraints form vi vj cij vi vj cij During search QCSPSolve apply basic forms lookahead described Section 3 FC0 MAC0 enhancements FC1 MAC1 In follows new lookahead lookback techniques combined FCbased lookahead Most techniques combined MACbased lookahead similar way 51 The pure value rule Our experiments showed important QBF technique terms practical effectiveness encoded QCSPs pure literal rule We explain corresponds binary QCSP exploit prune search space We ﬁrst deﬁne notion pure value Deﬁnition 5 A value Dvi QCSP F cid3V Q D Ccid4 pure iff vj V vj cid14 vi b Dvj assignments vi cid8 vj cid8 b compatible 28 Bordeaux et al introduced notion ﬁxable value CSP 10 In words value variable v ﬁxable solution includes assignment value b v solution v cid8 b substituted v cid8 As noted 10 sufﬁcient necessary condition determining ﬁxability value computed local reasoning polynomial time This similar pure literal rule SAT The 758 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 authors deﬁned notion ﬁxability QCSPs 11 Following terminology 11 value pure sufﬁcient necessary condition value dﬁxable In way analogous pure literal rule QBF devised implemented lookahead technique pure value PV rule detects exploits pure values The actions taken dual existential universal pure values An existential variable pure value set value violate constraint scenario On hand pure value removed domain universal variable certainly solution need search consistent scenario includes This duality reﬂects dual semantics existential universal variables For universal variable showing value pure prove leads consistent scenario value variable leads consistent scenario Hence subsumption rule value domain removed Note values pure dynamically search variable assignments constraint propagation remove values domains variables Example 9 Section 53 Therefore PV rule applied preprocessing technique dynamic lookahead technique search The PV rule works follows If pure value existential vi discovered preprocessing search assignment vi cid8 values vi permanently temporarily removed Dvi To check search value existential vi pure need check assignment vi cid8 compatible values future variables FC MAC guarantee vi cid8 compatible instantiations past variables If pure value universal vi discovered preprocessing search permanently temporarily removed Dvi ﬁnal value Dvi To check value universal pure need check future variables preprocessing AC guarantees constraints universal past variable If discover preprocessing values universal pure ignore certain values consistent scenario In cases value temporarily removed pure value rule restored backtrack variable vi V occurs Currently PV rule implemented simple functions preprocessing dynamic application rule search In cases detect pure values variable vi iterate domains variables constrained vi variables vi case dynamic application During preprocessing repeat variables problem gives worst case time complexity On2d 2 During search restrict PV detection values current variable This gives worstcase time complexity Ond 2 The function applies PV rule search need called assigning current variable vcur ﬁrst available value That immediately line 2 Fig 4 assuming underlying algorithm FC0 Calling function backtrack vcur later occurs redundant restoration domains backtrack guarantees pure values previously detected remain pure new values pure Relation pure value pure literal rule The PV rule applied QCSP F similar effect application pure literal rule PL enhanced log encoding E In cases PV PL equivalent cases details different exact equivalence elusive To discuss consider cases existential universal variables If existential variable ve pure value F ve assigned F In encoding PL assign xve cid8 T ve cid8 contained conﬂict F xve contained conﬂict clause E The instantiation xve cid8 T makes ALO clause ve true If existential variable ve F pure value b pure values instantiated PV rule The value instantiated typically ﬁrst discovered algorithm In encoding corresponding variables xve b positively pure instantiated T PL rule Again makes ALO clause true xve If universal variable vu F set pure values P P cid2 Dvu values P removed In encoding variables xvu P positively pure instantiated T PL rule Thus channelling clauses containing variables true variables entirely removed E This IP Gent et al Artiﬁcial Intelligence 172 2008 738771 759 cause variables set wvu pure reducing number branches explored QBF solver However exact equivalence PV PL If values universal variable vu F pure removed F In encoding variables xvu positively pure set true PL rule Consequently channelling clauses true variables wvu pure Therefore instantiated QBF solver branch variable set wvu Similarly QCSP solver branch vu instantiating 52 CBJ solutiondirected pruning 521 Conﬂictbased backjumping CBJ successfully combined FC CSPs 39 DLLbased procedure QBF 32 deal deadends intelligent way avoid redundant search We explain CBJ implemented QCSPSolve As CSPs variable vi V set variables called conﬂict set denoted conf_setvi This holds past existentials responsible deletion values Dvi Initially conﬂict sets When encountering deadend existential value universal rejected algorithm exploits information kept conﬂict set current variable vcur backjump past existentials responsible deadend instead blindly backtracking chronologically previous existential V To precise algorithm backjumps recently instantiated existential vk existentials conf_setvcur reassigns available value As vks previous assignment caused deletion value Dvcur reassign values Dvcur available In contrast algorithm backtracks chronologically BT FC variants repeatedly encounter deadend existential immediately vcur V belong conf_setvcur In case reassigning existential free vcurs values deadend vcur encountered Conﬂict sets updated follows If current variable vcur existentially quantiﬁed forward checking value future variable vj incompatible assignment vcur vcur added conf_setvj This straightforward assignment vcur responsible removal value Dvj If assigning value vcur existential universal forward checking domain future existential vj wiped existentials conf_setvj added conﬂict set current variable This domain wipeout vj result value rejected The past existentials considered responsible rejection ones instantiations removed values Dvj To understand consider assignments existentials rejected Dvj wiped Note way conﬂict set universal updated Backjumping occur following cases 1 If current variable vcur existential values tried algorithm backjumps latest recently instantiated existential vk V belongs conf_setvcur At time variables conf_setvcur vk copied conf_setvk information conﬂicts lost This requires explanation Assume vk added conf_setvcur assignment vk cid8 resulted removal value b Dvcur If backjump vk remaining values vk rejected deadend jump Now assume recent existential vl conf_setvk algorithm backjump copied conf_setvk conf_setvcur Since vl conf_setvcur current assignment resulted removal value vcur When change vls assignment possible values removed Dvcur Therefore possible reassign vk future causing deadend vcur search tree This gain search effort possible conf_setvcur copied conf_setvk backjump existential vl V encountering deadend vk Example 7 demonstrates reasoning 760 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 Fig 6 The search tree explored FC1 CBJ problem Example 7 The consistent strategy depicted bold lines 2 If current variable vcur universal values fails results domain wipeout existential vj algorithm backjumps latest existential vk V belongs conf_setvcur That recent existential instantiation removed value Dvj Again variables conf_setvcur vk copied conf_setvk information conﬂicts lost The reasoning similar Example 7 Consider following QCSP V consists 6 quantiﬁed variables C conjunction 5 constraints v1v2v3v4v5v6v1 v3 v2 cid14 v6 v3 cid14 v6 v4 cid2 v6 v5 cid14 v6 Assume domains variables follows Dv1 Dv3 Dv4 Dv5 Dv6 0 1 2 Dv2 2 3 Algorithm FC1 equipped CBJ proceed solve problem follows Variable v1 assigned ﬁrst value 0 Forward checking removes values 1 2 Dv3 set conf_setv3 v1 Variable v2 assigned ﬁrst value 2 Forward checking removes value 2 Dv6 set conf_setv6 v2 Variable v3 assigned ﬁrst value 0 Forward checking removes value 0 Dv6 v3 added conf_setv6 So conf_setv6 v2 v3 Variable v4 assigned ﬁrst value 0 For ward checking We reach variable v5 universally quantiﬁed FC1 forward check v5s values v6 Value 1 v5 results domain wipeout v6 Therefore conf_setv6 copied conf_setv5 conf_setv5 v2 v3 Since v5s values failed backjump recent variable conf_setv5 v3 All variables conf_setv5 v3 copied conf_setv3 conf_setv3 v1 v2 There available values Dv3 algorithm jump recent variable conf_setv3 v2 Variable v2 assigned value 3 Forward checking Variable v3 assigned ﬁrst value 0 Forward checking removes value 0 Dv6 set conf_setv6 v3 Variable v4 assigned ﬁrst avail able value 0 Forward checking We reach variable v5 FC1 forward check v5s values v6 None values results domain wipeout v6 Therefore deadend consistent strategy shown Fig 6 Note added variables conf_setv5 conf_setv3 backjump v1 encountering deadend v3 This result different solution search effort 522 Solutiondirected pruning As discussed Section 43 Giunchiglia et al introduced solutiondirected backjumping QBF 32 This allows backjumps universally quantiﬁed literals reaching true leaf node Inspired idea imple mented technique prune values universal variables reaching true leaf node perform solutiondirected backjumps We solutiondirected pruning SDP SDP based following idea Assume vi universal V q vi1 vn sequence existentials vi V Also assume consistent scenario including assignment vi cid8 ai cid3vi1 cid8 ai1 vn cid8 ancid4 assignments existential variables vi1 vn scenario Then value vi compatible IP Gent et al Artiﬁcial Intelligence 172 2008 738771 761 assignments obviously consistent scenario Therefore value avoid running search remaining existentials value pruned Based reaching true leaf node SDP ﬁrst computes values universal vi V property All values temporarily pruned Dvi If available values Dvi SDP proceeds universal immediately vi V vj SDP checks vj s remaining values compatible assignments existentials vj Each value pruned Dvj condition values Dvi ﬁrst previously pruned SDP Or words values vi compatible set assignments cid3vi1 cid8 ai1 vn cid8 ancid4 existentials vi Essentially means prune value Dvj compatible assignments previously discovered strategy setting variables vj This repeated recursively universal available values left domain SDP applied The algorithm backjumps universal Example 8 illustrates SDP operates Example 8 Consider QCSP v1v2v3v4v5 C Assume variables domain 0 1 2 v1 domain 0 1 2 3 C includes constraints dont mention simplicity reasons Imagine BT coupled SDP solve problem Fig 7 depicts solution problem nodes pruned SDP subtrees searched Assume consistent scenario cid3v1 cid8 0 v2 cid8 1 v3 cid8 0 v4 cid8 1 v5 cid8 2cid4 discovered The al gorithm backtrack universal v3 apply SDP Assuming values 1 2 v3 compatible assignments v4 cid8 1 v5 cid8 2 SDP prune values 1 2 Dv3 avoid searching subtrees corresponding nodes Since values left Dv3 algorithm apply SDP previous universal v1 Assuming value 1 v1 compatible assignments v2 cid8 1 v4 cid8 1 v5 cid8 2 SDP prune value 1 Dv1 According deﬁnition SDP pruning possible values Dv3 ﬁrst pruned SDP previously That assignment v1 cid8 1 compatible assignments previously discovered strategy setting variables v1 Now assuming value 2 v1 compatible assignments v2 cid8 1 v4 cid8 1 v5 cid8 2 algorithm backjump v1 proceed making assignment v1 cid8 2 As shown Fig 7 algorithm ﬁnd consistent scenarios values 0 1 v3 SDP prune value 2 v3 compatible assignments v4 cid8 1 v5 cid8 1 Since values Dv3 algorithm apply SDP v1 However value 3 v1 pruned v3s values ﬁrst previously pruned SDP Therefore algorithm proceed usual explore subtree node corresponding assignment v1 cid8 3 Note SDP able detect subtrees nodes corresponding v1 cid8 2 v1 cid8 3 similar uses information recently discovered consistent scenario The way SDP operates illustrated Example 8 immediately suggests possible enhancements For example algorithm stores history consistent scenarios discovered earlier opposed able perform pruning SDP albeit greater spatial requirements We plan investigate learning techniques future Fig 7 A solution problem Example 8 Dark nodes pruned SDP subtrees enclosed dotted areas searched 762 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 53 The algorithm QCSPSolve A high level description QCSPSolves algorithm shown Fig 8 It takes QCSP F cid3V Q D Ccid4 determines problem true false The version QCSPSolve shown Fig 8 based FC In Fig 8 preprocess function preprocesses problem applying algorithm QAC2001 computing pure NI values compute_PV computes pure values vcur search If vcur existential values pure compute_PV assigns vcur temporarily removes rest Dvcurs values If vcur universal compute_PV temporarily removes pure values Dvcur The statement line 4 ensures compute_PV called vcur assigned ﬁrst available value Forward_Check0 function Fig 4 implements FC0type lookahead It called current variable existential universal assigned checks assignment future existentials constrained vcur If value variable vi deleted vcur added conf_setvi If Dvi wiped vj conf _setvi added conf_setvcur Forward_Check1 function Fig 5 implements FC1type lookahead It called vcur assigned universal checks Dvcurs available values future variables constrained vcur If domain variable vi wiped vj conf _setvi added conf_setvcur The statement line 30 ensures f c1 called vcur assigned ﬁrst available value SDP implements solutiondirected pruning SDP prunes values universals according reasoning scribed Section 52 returns ﬁrst universal values left domain SDP applied Restore procedure depicted Fig 9 restore values domains variables backtracks This procedure slightly different FC restore values pruned PV rule addition ones pruned forward checking QCSPSolve works follows It takes input QCSP F cid3V Q D Ccid4 preprocessing problem line 1 proceeds making assignments values variables truth problem proved disproved Before assigning value vcur QCSPSolve calls compute_PV compute pure values vcur lines 45 If vcur existential available values Dvcur algorithm backtracks latest variable V belonging conf_setvcur lines 710 Otherwise vcur assigned available value assignment checked future variables lines 1213 If domain wipeout algorithm reached true leaf node vcur variable V SDP called perform solutiondirected pruning lines 1619 If QCSPSolve leaf node proceeds moving variable line 20 If domain wipeout value vcur tried iteration loop Note universals problem standard CSP QCSPSolve terminates true leaf node reached line 15 If vcur universal consistent scenarios values cases If vcur ﬁrst universal QCSPSolve terminates successfully line 24 Otherwise backtracks universal line 27 Before assigning value universal variable QCSPSolve calls Forward_Check1 perform FC1 type lookahead lines 3031 If domain wipeout algorithm backtracks latest variable V belonging conf_setvcur lines 3639 If domain wipeout Forward_Check1 called level vcur assigned available value line 33 assignment checked future variables line 34 QCSPSolve proceeds variable line 35 Although shown Fig 8 QCSPSolve employ dynamic symmetrybreaking technique based computing NI values described Section 33 However experiments run far showed time overheads technique outweigh beneﬁts offers PV rule That included pseudocode Fig 8 However problems ones tried better implementation possible dynamic NIbased symmetry breaking useful The following example demonstrates QCSPSolve operates Example 9 Consider following QCSP V consists 7 quantiﬁed variables C conjunction 9 constraints v1v2v3v4v5v6v7v1 cid14 v6 v1 cid14 v7 v2 cid14 v6 v3 cid14 v6 v3 v7 v4 cid14 v6 v4 cid14 v7 v5 cid14 v6 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 763 Boolean QCSPSolveF cid3V Q D Ccid4 input A QCSP F output TRUE solution F exists FALSE vcur vn Qvcur compute_PVF vcur values Dvcur tried previously assigned variable vcur1 universals V return TRUE assign vcur available value Dvcur Forward_Check0F vcur vback SDPF RestoreF vcur vback vcur vback vcur nextvcur RestoreF vcur vcur vback latest variable V belonging conf_setvcur RestoreF vcur vback vcur vback 1 preprocessF 2 vcur v1 3 vcur cid14 NIL 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Qvcur 23 24 25 26 27 28 29 30 31 32 33 34 35 36 vback latest variable V belonging conf_setvcur 37 RestoreF vcur vback 38 vcur vback 39 40 vcur NIL return FALSE assign vcur available value Dvcur Forward_Check0F vcur vcur nextvcur FC_result TRUE previously assigned variable vcur1 FC_result Forward_Check1F vcur vcur ﬁrst universal V return TRUE RestoreF vcurlast_uvcur vcur last_uvcur values Dvcur tried FC_result Fig 8 The algorithm QCSPSolve procedure RestoreF vcur vback input A QCSP F current variable vcur variable algorithm backtrack vback output 1 vi vback vcur 2 3 4 restore Dvj value removed vi s instantiation restore Dvj value removed PV rule variable vj vi V Fig 9 Restoration procedure QCSPSolve 764 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 Fig 10 Search tree Example 9 Dark nodes pruned QCSPSolve Such nodes feature responsible pruning included dotted ovals ﬁgure Dotted edges denote parts tree visited past DWO stands domain wipeout v5 v7 Assume domains variables follows Dv1 2 3 Dv2 0 1 2 Dv3 0 3 Dv4 0 1 6 Dv5 4 5 Dv6 0 1 2 3 Dv7 0 2 3 6 Let trace execution QCSPSolve steps understand features prune search space Figs 10a 10k demonstrate search tree explored QCSPSolve built certain nodes pruned way domains variables change search Fig 10a Preprocessing applied line 1 algorithm There arc inconsistent pure values pruning performed3 Fig 10b The assignment v1 cid8 2 line 12 Forward_Check0 reduces Dv6 Dv7 0 1 3 0 3 6 respectively line 13 We following conf_setv6 conf _set v7 v1 3 Values 4 5 v5 NI let ignore sake example IP Gent et al Artiﬁcial Intelligence 172 2008 738771 765 Fig 10c Now value 2 v2 pure supported values future variables lines 45 The PV rule immediately assignment v2 cid8 2 Fig 10d The variable universal Forward_Check1 lines 3031 wipe future domain assignment v3 cid8 0 line 33 Forward_Check0 reduces Dv6 Dv7 1 3 3 6 respectively line 34 Fig 10e Value 0 v4 pure lines 45 Therefore removed Forward_Check1 lines 3031 wipe future domain assignment v4 cid8 1 line 33 Forward_Check0 reduces Dv6 3 line 34 Fig 10f The variable v5 Forward_Check1 wipe future domain lines 3031 assign ment v5 cid8 4 line 33 Forward_Check0 reduces Dv7 6 line 34 Fig 10g v6 v7 assigned available values line 12 true leaf node line 14 Fig 10h Now function SDP called line 17 SDP discovers value 5 universal v5 compatible assignments existentials v5 Therefore value removed Dv5 SDP applied previous universal v4 Value 6 v4 compatible assignments v6 v7 Therefore solutiondirected backjump v4 performed line 19 Fig 10i The assignment v4 cid8 6 line 33 Forward_Check0 reduces Dv6 Dv7 1 3 3 respectively line 34 Fig 10j Forward_Check1 lines 3031 applied v5 wipes Dv7 value 4 v5 incompatible value Dv7 Therefore deadend conf_setv7 added conf_setv5 Fig 10k The algorithm backjump latest variable V belonging conf_setv5 v1 line 3739 Fig 10l shows search tree traced example illustrates subtrees pruned applying lookahead lookback techniques 6 Experimental evaluation To compare performance methods presented previous sections ran experiments randomly generated QCSPs Before presenting results discuss issue ﬂaws random instances familiar search problems CSP QBF signiﬁcant impact experimental studies We random generators derived extending standard generators QBF CSP rise ﬂaws quickly infect generated problems Since important problem experiments QCSP propose random generator free ﬂaws 61 Flaws random QCSP generation Local ﬂaws discovered random generation models search problems CSPs 1 QBF 29 We random generation models QCSPs based standard generators QBF CSPs suffer local ﬂaw speciﬁc QCSPs makes generated instances false small problem sizes Consider example kQBF random generation model 29 widely experiments QBF In model k 1 blocks variables alternating quantiﬁcation variables ﬁrst block existentially quantiﬁed For example 2QBF problem block existential variables followed block universal variables followed block existential variables This model easily adapted generate QCSP instances The blocks variables generated kQBF binary constraints generated standard model binary CSPs model B 43 However kQCSP generator subject local ﬂaw Suppose ﬁnd assignments cid3v1 cid8 7 v2 cid8 2 vk cid8 3cid4 universals v1 vk exists existential ve appearing later V variables vi 1 k If value ve conﬂicts chosen values universals tuple assignments inconsistent But remains inconsistent irrespective assignments universals existentials problem trivially false Even taking extreme case conﬂict constraint happen long universals ve values domain 766 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 Assume d universals constraint pair variables probability p Each constraint nogood Assume Dve 1 d The probability conﬂict universal value 1 Dve pdd pick universal u d universals probability p constraint u ve probability 1d single conﬂict involves value 1 Dve For value 2 set available universals size d 1 probability pd 1d Overall probability ﬂaw existential ve d particular universals P ve With k existential variables quantiﬁed d universals probability ﬂaw occurring 1 P vek Since P ve depend k ﬁxed d p probability tends 0 k Not ﬂaws certain occur phase transition p 0 problems false asymptotically cid6 d i1 pid This ﬂaw common discovering presence NPcomplete problem Let repeat description ﬂaw slightly formally Deﬁnition 6 Flawed problem Suppose set variable assignments S v1 cid8 a1 vi cid8 ai aj j 1 aj Dvj vj j 1 universally quantiﬁed appears V existential variable ve If value b Dve incompatible value assignment vj cid8 aj S cid3aj bcid4 cj e entire problem false said ﬂawed Notice case detected QCSP technique encoding case set variablevalue pairs singleton Ie vj cid8 aj inconsistent value ve In case algorithm QAC2001 reports failure For case constraint contains conﬂict easy check existential variable ﬂaw That computed proportion ﬂawed problems However general hard conﬁrm existence ﬂaw Theorem 2 Checking presence ﬂaw QCSP NPcomplete Proof Consider SAT instance We convert QCSP SAT instance solution iff QCSP ﬂawed For SAT variable v corresponding universal QCSP variable v values 0 1 We single existential variable ve quantiﬁed domain size equal number clauses SAT problem We constraint universal variable ve This constraint conﬂict SAT clause variable occurs If literal clause v conﬂict rules pair cid3v cid8 0 ve cid8 icid4 literal v conﬂict rules cid3v cid8 1 ve cid8 icid4 Now consider satisfying assignment SAT instance This set literals occurs clause Say v set occurs clause Then translation ensures v cid8 0 rules ve cid8 Similarly u assignment occurs clause j u cid8 1 conﬂict ve cid8 j So value ve ruled We need set variable 0 1 simultaneously satisfying assignment contain variable negation The reverse direction similar Say translated QCSP ﬂawed Then set assignments vi cid8 ai ruling value ve If ai 0 construction literal v occurs clause satisﬁes And ai 1 v occurs clause As values ve ruled SAT instance satisﬁed The ﬂaw easily witnessed choice values universal variables problem instances ﬂawed NP NPcomplete cid2 Note ﬂaw simply situation search terminated As rise interesting new propagation techniques QCSP valuable new clauses QBF encodings 611 Random problem generator The random generator controls probability ﬂaws Variables appear blocks alternating quan tiﬁcation For simplicity model case blocks That block existentials followed block universals block existentials The generator takes 7 parameters cid3n n npos d p q qcid4 n total number variables n number universally quantiﬁed variables npos position ﬁrst universally quantiﬁed variable V d uniform domain size p number binary constraints fraction possible constraints IP Gent et al Artiﬁcial Intelligence 172 2008 738771 767 q number goods satisfying tuples vi vj cij constraints fraction possible tuples q similar quantity vi vj cij constraints explained The types binary constraint removed entirely preprocessing generate Since ﬂaw characteristic vi vj cij constraints restrict following way generate random total bijection onetoone correspondence domain Dvi Dvj Conﬂicts chosen pairs bijection All 2tuples bijection goods Now q fraction goods d tuples bijection Notice p q q q parameters proportions probabilities model similar style model B random CSPs To control probability pf ﬂaw write expression pf approximating proportions p q q probabilities n number universal variables n number existential variables second existential block For existential assignment ve cid8 1 probability covered universal vu p1 q If variable ve ﬂawed values conﬂict value universal variable However universal variable cover value use bijection For individual existential variable ve second existential block representing domain values positive integers start writing following equation It places ordering values represents probability values Dve ﬂawed product probabilities value given values ﬂawed So example 5 probability value 5 ﬂawed given values 1 2 3 4 ﬂawed written p51 2 3 4 pve ﬂaw p1p21p31 2 1 The probability value ﬂawed given previous 1 values ﬂawed given Eq 2 1 q probability particular value Dve nogood particular constraint This multiplied p1 obtain approximate probability particular universal vg constraint cge having nogood containing Dve The exponent n 1 number universal variables minus 1 variables instantiated conﬂict 1 lower values Dve The probability p11 q particular universal having conﬂict Dve complemented raised exponent complemented obtain probability remaining universal variable having conﬂict Dve pa1 1 1 cid2 cid3 na1 1 p11 q Substituting Eq 2 Eq 1 gives probability particular existential variable ﬂawed pve ﬂaw d1cid7 i0 cid2 1 cid2 cid3 ni 1 p11 q cid3 The probability existential variables ﬂawed given This formula gives incorrect results d n In case pf 1 universal variables cover elements domain cid3 cid2 1 pve ﬂaw pf n 4 62 Experimental results In section present experimental results problems generated model described Our aim demonstrate huge progress efﬁciency QCSP solving starting ﬁrst methods culminating advanced ones Therefore indicative results techniques 621 Direct algorithms Fig 11 presents comparison algorithms FC1 FC1 PV MAC1 PV QCSPSolve problems generated according model described All algorithms apply AC NI preprocessing For value q shown ﬁgures 100 problem instances generated use mean average The generation parameters n 21 d 8 p 02 q 05 Variables v1 v7 existentials v8 v14 universals v15 v21 2 3 768 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 Fig 11 Comparison direct algorithms QCSPs n 21 n 7 d 8 p 020 q 12 Fig 12 Comparison enhanced log encoding adapted log QCSPSolve existentials These parameters ensure instances unﬂawed Finally q varied satisﬁability phase transition We include FC1 PV MAC1 PV comparison illustrate power PV rule Note problems tried FCbased algorithms efﬁcient corresponding MACbased ones However larger problems easily reversed In problems Fig 11 execution FC1 stopped cutoff limit 2 hours 50 instances As QCSPSolve orders magnitude faster FC1 The speedup obtained largely application PV rule Similar results obtained parameter settings At point note recently proposed QCSP solvers BlockSolve QeCode 44 4 respectively achieved good results randomly generated QCSPs Both solvers considerably different QCSPSolve BlockSolve bottomup solver displays better performance QCSPSolve satisﬁable instances downside requires exponential space QeCode built Gecode equipped advanced CSP techniques GAC algorithms certain global constraints On hand lacks specialized features QCSPs pure value handling 622 Encodings QCSP QBF As explained Section 4 global local acceptability encodings perform poorly compared encodings direct methods Therefore include results encodings The enhanced log encoding gives remarkable improvement adapted log It competitive QCSPSolve orders magnitude better Fig 12 shows results methods The generation parameters n 24 d 9 p 02 q 05 Variables v1 v8 existentials v9 v16 universals v17 v24 existen IP Gent et al Artiﬁcial Intelligence 172 2008 738771 769 tials q varied satisﬁability phase transition For point 100 instances generated The median average high outliers The time taken encode instances included linear encoding negligible difﬁcult instances The closest setting q phase transition 055 43 instances 100 true This ap proximately coincides difﬁculty peaks encodings QCSPSolve For lower values q fewer instances true enhanced log encoding competitive QCSPSolve For example q 035 99 instances false QCSPSolve outperforms enhanced log encoding Where q 08 instances true enhanced log encoding outperforms QCSPSolve At q 09 median enhanced log encoding fell resolution timer shown graph This suggests QBF solver CSBJ effective pruning backjumping universal variables looselyconstrained instance main cost branching universals Testing identifying rules CSBJ responsible remains future work We brieﬂy experimented solvers resolution solver Quantor hybrid search resolution solver sKizzo The aim gather initial evidence enhanced log encoding efﬁcient nonsearchbased solvers searchbased ones like CSBJ The random instances run following parameters n 24 3 blocks 8 variables alternating quantiﬁcation d 9 ensuring instances unﬂawed p 02 q 05 q 05 phase transition difﬁculty peak CSBJ 10 instances generated CSBJ solved 9 instances half second tenth 898 s Quantor quickly ran memory 1 GB instances solved 298 s ran time 60 s sKizzo unable solve instance 60 s From conjecture searchbased solvers preferable encoding However experiments necessary validate conjecture 7 Conclusions In paper studied methods solving QCSPs ﬁnite discrete nonBoolean domains Our ﬁrst approach based adapting techniques CSPs deal QCSPs We described AC algorithm QCSPs deal arbitrary binary constraints We extended BT FC MAC algorithms handle quantiﬁcation We proposed modiﬁcations FC MAC better suited QCSPs Our second approach based encoding QCSPs QBFs Our motivation early stage research new problem like QCSP encoding studied problem like QBF likely provide competitive performance We introduced progressively efﬁcient encodings culminating enhanced log encoding orders magnitude faster direct QCSP algorithms Through study demonstrated effective encoding QCSP QBF complex process simple generalizations CSPtoSAT encodings inefﬁcient Apart giving efﬁcient tools QCSP solving performance properties encodings techniques QBF solving indicated signiﬁcant enhancements direct QCSP algorithms We identiﬁed features log encodings underlying QBF solver largely responsible success ﬁrst ability advantage pure literal rule QBF second backjumping capabilities manifested CBJ SBJ We devised implemented analogues features direct QCSP algorithms resulting QCSPSolve efﬁcient direct solver Finally proposed model random generation QCSPs free known ﬂaws Experiments problems generated model demonstrated dramatic improvement performance comparing initial QCSP solving attempts sophisticated techniques developed later Acknowledgements We like thank anonymous reviewers comments suggestions helped greatly improve presentation paper References 1 D Achlioptas LM Kirousis E Kranakis D Krizanc MSO Molloy YC Stamatiou Random constraint satisfaction A accurate picture Proc CP97 Springer 1997 pp 107120 770 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 2 A Beckwith B Choueiry On dynamic detection interchangeability ﬁnite constraint satisfaction problems Proceedings CP 2001 2001 p 760 3 M Benedetti sKizzo A suite evaluate certify QBFs Proc 20th International Conference Automated Deduction CADE05 2005 4 M Benedetti A Lallouet J Vautard Reusing CSP propagators QCSPs Proceedings CSCLP2006 2006 5 F Benhamou F Goualard Universally quantiﬁed interval constraints Proceedings CP2000 2000 pp 6782 6 C Bessière JC Régin R Yap Y Zhang An optimal coarsegrained arc consistency algorithm Artiﬁcial Intelligence 165 2 2005 165185 7 A Biere Resolve expand Proc 7th Intl Conf Theory Applications Satisﬁability Testing SAT04 vol 3542 2005 pp 5970 8 F Boerner A Bulatov P Jeavons A Krokhin Quantiﬁed constraints Algorithms complexity Proceedings CSL2003 2003 pp 244258 9 L Bordeaux Boolean interval propagation quantiﬁed constraints Proceedings CP2005 Workshop Quantiﬁcation Constraint Programming 2005 10 L Bordeaux M Cadoli T Mancini Exploiting fixable removable implied values constraint satisfaction problems Proceedings LPAR2004 2004 pp 270284 11 L Bordeaux M Cadoli T Mancini CSP properties quantiﬁed constraints Deﬁnitions complexity Proceedings AAAI2005 2005 pp 360365 12 L Bordeaux E Monfroy Beyond NP Arcconsistency quantiﬁed constraints Proceedings CP2002 2002 pp 371386 13 M Cadoli A Giovanardi M Schaerf An algorithm evaluate quantiﬁed Boolean formulae Proceedings AAAI98 1998 pp 262267 14 M Cadoli M Schaerf A Giovanardi M Giovanardi An algorithm evaluate quantiﬁed Boolean formulae experimental evaluation Journal Automated Reasoning 28 2 2002 101142 15 H Chen The computational complexity quantiﬁed constraint satisfaction PhD Thesis 2004 16 H Chen Collapsibility consistency quantiﬁed constraint satisfaction Proceedings AAAI04 2004 pp 155160 17 H Chen Quantiﬁed constraint satisfaction bounded treewidth Proceedings ECAI04 2004 pp 161165 18 Complexity Classiﬁcations Boolean Constraint Satisfaction Problems N Creignou S Khanna M Sudan Eds SIAM Monographs Discrete Mathematics Applications SIAM 2001 19 M Davis G Logemann D Loveland A machine program theorem proving Communications ACM 5 7 1962 394397 20 M Davis H Putnam A computing procedure quantiﬁcation theory Journal ACM 7 1 1960 201215 21 R Dechter P van Beek Local global relational consistency Theoretical Computer Science 173 1997 283308 22 A Tacchella E Giunchiglia M Narizzano Learning quantiﬁed Boolean logic satisﬁability Proc 18th National Conference Artiﬁcial Intelligence AAAI02 23 U Egly T Eiter H Tompits S Woltran Solving advanced reasoning tasks quantiﬁed Boolean formulas Proceedings AAAI2000 2000 pp 417422 24 E Freuder Eliminating interchangeable values constraint satisfaction problems Proceedings AAAI91 1991 pp 227233 25 A Frisch TJ Peugniez Solving nonBoolean satisﬁability problems stochastic local search Proc IJCAI01 2001 pp 282288 26 M Garey D Johnson Computers Intractability A Guide Theory NPCompleteness WH Freeman 1979 27 I Gent P Nightingale A Rowley Encoding quantiﬁed CSPs quantiﬁed Boolean formulae Proceedings ECAI2004 2004 pp 176 180 28 I Gent P Nightingale K Stergiou QCSPSolve A solver quantiﬁed constraint satisfaction problems Proceedings IJCAI2005 2005 29 I Gent T Walsh Beyond NP The QSAT phase transition Proceedings AAAI99 1999 pp 648653 30 IP Gent JF Puget KE Petrie Symmetry constraint programming F Rossi P van Beek T Walsh Eds Handbook Constraint Programming Elsevier 2006 pp 329376 31 IP Gent AGD Rowley Encoding connect4 quantiﬁed Boolean formulae Proceedings Workshop Modelling Reformu lating Constraint Satisfaction Problems 2003 pp 7893 32 E Giunchiglia M Narizzano A Tacchella Backjumping quantiﬁed Boolean logic satisﬁability Proceedings IJCAI2001 2001 pp 275281 33 E Giunchiglia M Narizzano A Tacchella Learning quantiﬁed Boolean logic satisﬁability Proceedings AAAI2001 2002 pp 649 654 34 E Giunchiglia M Narizzano A Tacchella Clauseterm resolution learning evaluation quantiﬁed Boolean formulas Journal Artiﬁcial Intelligence Research 26 2006 371415 35 RM Haralick GL Elliot Increasing tree search efﬁciency constraint satisfaction problems Artiﬁcial Intelligence 14 1980 263313 36 A Haselbock Exploiting interchangeabilities constraint satisfaction problems Proceedings IJCAI93 1993 pp 282287 37 M Narizzano A Rowley I Gent E Giunchiglia A Tacchella Watched data structures qbf solvers Proceedings SAT 2003 Springer 2003 pp 2536 38 C Papadimitriou Ed Computational Complexity Addison Wesley 1994 39 P Prosser Hybrid algorithms constraint satisfaction problem Computational Intelligence 9 3 1993 268299 40 S Ratschan Applications quantiﬁed constraint solving reals bibliography httpwwwcscasczratschanappqcshtml 2003 41 S Ratschan Efﬁcient solving quantiﬁed inequality constraints reals ACM Transactions Computational Logic 7 4 2006 723748 IP Gent et al Artiﬁcial Intelligence 172 2008 738771 771 42 D Sabin E Freuder Contradicting conventional wisdom constraint satisfaction Proceedings ECAI94 1994 pp 125129 43 B Smith Phase transition mushy region constraint satisfaction problems Proceedings ECAI94 1994 pp 100104 44 G Verger C Bessière Blocksolve A bottomup approach solving quantiﬁed CSPs Proceedings CP2006 Springer 2006 pp 635 649 45 T Walsh SAT v CSP Proceedings CP2000 LNCS vol 1894 Springer 2000 pp 441456