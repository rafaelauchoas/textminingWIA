ELSEVIER Artificial Intelligence 106 1998 l75 Artificial Intelligence Prolog technology default reasoning proof theory compilation techniques Torsten Schaub Stefan Briining bl Institut fiir Informatik Universitiir Potsdam Posrfnch 60 15 53 D14415 Potsdam Germany b TLC GmbH HahnstraJe 43a D60528 Francurt Germany Received 24 February 1997 received revised form 3 June 1998 Abstract The aim work Prolog technology efficient implementation query answering default logics The idea translate default theory query Prolog program Prolog query original query derivable default theory iff Prolog query derivable Prolog program In order comply goaloriented proof search approach focus default theories supporting exemplified socalled semimonotonic default theories Reiters interpretation local proof procedures capture general alternative ones theories Although default For providing theoretical underpinnings techniques topdown proof procedure based model elimination We notion model elimination proof refined implementing improving model elimination theorem provers regularity lemmas adapted default reasoning This integrated approach allows push concepts needed extended handling defaults underlying calculus resulting compilation capture default proofs standard resulting compilation techniques techniques theorem proving This method default incremental consistency checking We crucial task consistency checking benefit keeping models order restrict attention ultimately necessary consistency checks This supported concept default lemmas allow additional avoidance redundancy 0 1998 Elsevier Science BV All rights reserved modelbased complemented approach Keywords Defmlt reasoning Automated reasoning Default Logic Model elimination PlTP Modelbased consistency checking Corresponding author Email torstencsunipotsdamde Email StefanBrneningtlcde 00043702986 matter 0 1998 Elsevier Science BV All rights reserved PII SOOO4370298000927 2 I Schaub S Briining Artificial Intelligence 106 1998 175 1 Introduction In AI applications default reasoning plays important role subtasks great need In fact underlying problems default reasoning Therefore systems For undertaking reasoning incomplete information This involve systematic methods allow integrate default reasoning capabilities decades provided profound understanding resulted wellunderstood ready build advanced default reasoning chosen Reiters default logic 71 point departure classical inferences formal approaches logic dejbdt Default logic augments rules sanctioning represented standard rely given absent information differ rules default logics default types antecedents inference D W consisting Knowledge set formulas W called facts set default rules D A default rule consistent derivable y If conditions hold justijication sanctioned default consequent y concluded default A set conclusions logic called extension initial set facts given set rules classical formulas W set default rules D extension E deductively closed set formulas containing W 6 established I_I established l consistent prerequisite theories introduction default logic given E E I 4 E y E E A formal Section 2 In underlying basic approach implementing determining formula query address problem follows interested allows answering logic default extension given default theory 2 Unlike approaches theorem prover separate module proposing encapsulating theorem different approach integrates default reasoning classical provers center overall approach local theorem provers indispensable allow deciding set default proof procedures rules forms default proof looking constituent rules This procedures permit validating default inference step goaldirected proof search locally determinable way Section 2 details In order comply methodology existing automated proof procedures queryoriented underlying The methodology presented paper origins approach 79 This approach logic renders default query notion default proof implementations 79 furnishes mating default proofs inside framework provided connection answering proposed classical calculus means existing based characterization method socalled semi calculus monotonic default logics The advantage default systems allow integrates especially qualified theorem provers To precise Schaub 151 This results connection query answering Membership extensions actually computable appeal procedure testing membership Verne extension 89 1 Schaub S Briining Artijcial Intelligence 106 1998 I75 3 aforementioned numerous implementations theorem prover SETHEO member family connection local proof procedures Section 2 In fact connection calculi Most like high performance 53 regarded 47 based model elimination calculi implementation provide We draw relationship paper implementation technique Prolog Technology Theorem Proving PTTP 8788 looked different default semimonotonic theorem prover means handling proof lemmas model elimination default reasoning Our overall contribution perspectives logics Second extend existing automated default information refined capture semimonotonic implementing adapted extended logic programming default negation default reasoning And finally view contribution In particular notion model elimination default proofs standard techniques improving model elimination disjunction classical theorem provers regularity integrating techniques procedure deductive As anticipated address In formalisms default reasoning added standard techniques borrowed To precise overview approach start noting consistencybased approaches consistencydriven logical formalization explained default logic means justification In way default reasoning task Of course carries resulting proof procedures default logic logic As default rule mapped deductive task consistency checking task default query answering appeal Prolog Technology Theorem Proving The idea translate default theory query Prolog program Prolog query theory iff Prolog original query belongs query derivable theoretical underpinnings techniques topdown proof procedure based modelelimination default query answering given 79 integrates calculus classical needed handling defaults underlying resulting compilation procedure task consistency notion default proof logic This integrated approach allows push concepts proof This proof procedure roots matingbased Prolog program For providing calculus corresponding extension default interesting question resulting compilation query answering characterization As regards techniques checking formula subproofs reducing checking For observe computational consistent way pruning inconsistent efforts consistency iff model This leads following satisfiable checking start model initial set facts Each time consistency default apply default rule check logic If case assumptions If try generate new model initial set facts continue proving partial default proof satisfying hand If succeed simply continue proving new model Otherwise know considered default assumption assumed consistent way current default proof default rule model continuation current default assumptions underlying linear time propositional actual model satisfies underlying incremental approach 4 I Schaub S Briining Artificial Intelligence 106 1998 175 hand In way restrict ones generation new models ultimately necessary simultaneous The second interesting question checking allows proof procedures benefiting sharing This important sources putative exponential proving satisfiability information orthogonal query answering idea communicate This communication traditional usage lemmas improving communication drastic reduction search space case new model generated treatment theorem structure tasks encompass genuine reflected fact issue model generator lemma handling That apart logics information accomplished default processes We allows inferential processes use furthermore theorem prover 42 For addressing device Elcomplete complexity default The paper organized follows After inserting current work literature logic basic proof theory furnishes default semimonotonic query answering modelelimination Section 2 introduction proven sound complete theories Section 3 introduces theoretical Section 5 This section extends provide normal default normal default calculus techniques compilation foundation logic This calculus work 75 While integral introduced approach addresses fullfledged default logics support local proof procedures restrict exposition Section 6 socalled normal default theories propositional theories carry consistency general case modifications Hence present Section 4 model based approach consistency checking normal default theories This section extends general default theories work 20 We ultimately lift overall approach Section 6 We accomplish approach Section 4 modelbased order encompass variety consistency checks existing default logics This builds work 76 As final outcome obtain PTTPbased platform query answering language This restriction checking techniques developed default logics support local proof procedures justified fact normal default extending implementation We draw readers attention approach proof theoretical right start fact paper focuses issues compilation fundamentals techniques A detailed description experimental techniques resulting objectcode analysis 59 companion paper implementation preparation For impression consult Appendix A containing example resulting Our freely available 83 Documentation sets test cases In order use need obtained standard Prolog preferably Eclipse Prolog location In follows assume reader familiar basic concepts propo logic 10321 presume acquaintance automated paper treats variables regarded considered We sitional firstorder theorem proving deal propositional finite universe rudimentary representative ground instances details Section 525 sense formula rule respectively skolemization case implementation language Prolog 27 Throughout 1553 programming T Schaub S Briining Artcial Intelligence 106 1998 l75 5 11 Related work The question determining formula framework extension approaches construction extended containing like 211254550638182 integrating default reasoning related decision procedures 71 An alternative approach recently proposed extension given default 79 like 62 45 Levy 50 propose truth maintenance 1 l reduce default reasoning constraint inference theory addressed In contrast work literature focuses determination entire extensions lookup operations 631 In approaches queries answerable query hand restricting based systems Ben Junker Konolige satisfaction problem Eliyahu Dechter systems classical Among extensions logic 1821 tableauxbased 81 theories normal default tableaux justified constrained default logic 721 In framework clausal Amati Sor capturing maximal consistency et al 2 use parallel tableau checks In approaches proposed Another hybrid method sequent calculus based This consists parts classical LKcalculus rules Along antisequents skeptical line research Bonatti Olivetti approaches like 5254563 reasoning default theorem 7 11 abstract underlying prover module furnishing oracle classical relations There variety approaches addressing certain fragments default logic like 13187 1821 notably Pooles Theorist framework inference 16 propose sequent calculus default capturing default final extensions characterized resulting 17 cutfree sequent calculus inference engine presuppose automated rules Unlike inferences computation certain default sets consistent logic In contrast classical default consistency fullfledged 64656769 checking inference tableaux logic Apart context default logic mention work automating temic logic 6162 circumscription conceptually different approach Gelfond Lifschitz tion logic programs Przymusinski related model elimination 637394370 Among autoepis 37 compile circumscrip 70 uses form linear resolution Along techniques broader implementing default reasoning literature Among work Hoppe theme work utilization standard automated clearly broader theorem proving 44 range background default reasoning different settings Sattar 74 dealing incremental case Moreover lot effort aforementioned Theorist framework devoted specific topics like consistency lemma handling outcomes rely giving detailed account literature And mentian large efforts taken logic programming extended Among logic programming implementing approaches community default checking 36 groups NiemelH 25 impressive performances arguably Truszczyiiski soning systems These approaches orthogonal reasons aim primarily computing entire extensions reasoning exposed position 63 Marek exhibited default rea proposed paper comprising query answer aforementioned held 6 I Schaub S Briining Artcial Intelligence 106 1998 175 underlying theorem prover Moreover Niemela ing aforementioned way ii deal Reiters original default logic iii encapsulate 63 puts strong techniques Cholewidski et al 25 discuss depth emphasis conflict resolution In paper shift emphasis influence stratification techniques adopting utilization classical automated queryoriented As regards iii acknowledge use independent DavisPutnam relies local proof procedures perspective default reasoning fully homogeneous final implementation 28 modelfinding theorem proving techniques procedure As mentioned introductory section decision motivated desire integrating center approach existing goal local proof procedures validity oriented topdown automated inference step performed order improve proof search A related aim approaches splitting default theories smaller parts order apply default 26 reasoning takes notion stratification 3 provide salient DeReS 25 263390 For example Cholewinski theorem prover We aim verifying local way Among logic programming techniques known In restriction default theories supporting local proof procedures exemplified default theories default deductive power advanced seen compromise semimonotonic ultimate goal exploit expressiveness fact default logics denying semimonotonicity necessitate setting incompatible idea local goaloriented proof procedures requires global approach explains aforementioned primarily computation inspection entire set default rules inference engines ii theories consideration The like Reiters fullfledged default logic inspection aZE default rules answering matter query This relying arguably bottomup procedures This logic setting necessitates approaches entire extensions Reiters original default interested 2 Default logic This section introduces Reiters classical default logic important formal concepts needed providing proof theory adequate purposes section default introductory As sketched logic augments classical logic default rules form 3 G Such rule called normal B equivalent y I impli y We denote prerequisite u default called seminormal y ConseqG rule 6 PrereqG justification D zfD Accordingly PrereqD ConseqD defined analogously A set default rules D set consistent formulas 4 W form default theory D W induce single multiple extensions following way 7 11 JustifS set prerequisites consequent default rules 3 Reiter 71 considers default rules having finite sets justifications Marek Truszczyriski 57 default rule tmnsformed set default rules having single justification 4 The restriction consistent set facts necessary simplifies matters T Schaub S Briining Articial Intelligence IO6 1998 175 7 Definition 21 Let D W default theory For set formulas S let rS smallest set formulas S 1 w c S 2 ThS S 3 y E D E S S U j3 consistent y E S A set formulas E classical extension D W iff rE E Observe E fixed point r Any set represents possible set beliefs world hand sufficient logics feasible As forward default 71 query answering presence property semimonotonicity D C D sets default rules E extension D W extension E D W consider relevant subset default rules E C E Given property query applying default rules enlarge answering preserve Rartial extension hand In Reiters default logic semimonotonicity enjoyed normal default theories Moreover major variants default logic classical default logic 71 justified default logic 55 cumulative default logic 5 19 constrained default logic 30 rational default logic 58 coincide particular fragment This chosen normal default theories initial exemplar approach We Section 6 general default theories treated aforementioned variants provided enjoy semimonotonicity In presence semimonotonicity truly iterative way applying applicable default rule appeal local notion consistency constructible extensions Theorem 21 Let D W normal default theory let E set offormulas Then E extension D W ifs maximal D 5 D enumeration 6iiet thatfor E I E Th W U Conseq D W U lConseqGo SiI k Prereq W U ConseqSo 8il y COWqGi 1 2 3 This type characterization given 82 condition 3 reflecting incremental approach opposed global approach requiring W U ConseqD v 1 Condition 2 spells D grounded set facts W iff exists enumeration W In general set default 6iiez D 3 expresses notion incremental consistency Here application default rule checked step 2 Condition rules D grounded satisfies condition consistent respect thenal extension nonsemimonotonic default logic 5 This meant modulo augmented language Section 6 details 8 Z Schaub S Briining Artificial Intelligence 106 1998 l75 These notions lead following notion default proof normal default theories build initial formal characterization query answering Definition 22 Let II W normal default theory p formula A normal default proof p D W finite sequence default rules 6iiC1 6i E D E I W U Conseq 2 3 satisfied 1 E I t yz conditions E I The following immediate consequence Theorem 21 assures query extension normal default theory hand iff normal default proof 6 Theorem 22 Let D W normal default theory cp formula Then q E E extension E 0 W iff normal defaultprooffor q D W Now given concept default proof let elucidate That verifying q extension default theory D W determine grounded consistent set default rules D C D allows proving 60 facts W consequents default rules OP computational deciding set local proof procedures provided semimonotonicity default rules forms default proof sufficient rules A local proof procedure consider rule D Dq deciding D default proof query o Note absence property like semi monotonicity consider default rules given case general default theories Reiters default theory 7 This instance interested Finally emphasize interpretation draw essential aiming proof procedure necessarily feature model elimination localness proof procedures based theorem provers semimonotonicity constituent investigate resulting advantage As example consider following set statements allergy milk products children normally usually contains icecream case predisposition predispo expressing following considered The corresponding contains usually default sugar milk child predisposed icecream eat icecream allergen theory facts child A predisposition child aforementioned child icecream icecream milk icecream sugar icecream milk sugar child predispo milk A predispo allergen 4 6 Since deal normal default theories Section 6 omit prefix norm01 point 7 Unless particular proof procedure structure allowing localizing syntactical instance stratification 3 similar techniques This actually extremely rich nontrivial domain studying default reasoning Z Schmb S Briining Artcial Intelligence IO6 1998 l75 9 For instance explain allergen child A predispo means default proof presence allergen situation proving chilcl icecream icecream milk icecream milk 1 Importantly query ignoring irrelevant default rule proof topdown backwardchaining 5 procedure starts icecream sugar sugar This illustrates great advantage local proof procedures following For paper follow 79 dealing default theories atomic format D W language CZ alphabet Z let Lz language alphabet Z obtained adding new propositions named og s ys 6 E D Then D W mapped default theory D W Lx sense default theory theory restrict attention atomic default rules D W called atomic format original default The resulting default affect computation theory D W As shown 73 transformation queries original default theory That terms default proofs given query ye LE p default proof D W iff q default proof D W We losing generality The advantages atomic default rules arbitrary ones constituents clausal format Section 3 spread clauses transforming second The motivations referable uniquely constituents format similar ones definitional clausal form automated theorem naming defaults Poole 67 proving 31 For default reasoning For clarity refrain turning default rules atomic counterparts case Default Section 4 composed atomic components This theory 4 For example transformation Section 52 describes instance reader level benefits implementation referred 3 Query answering default logics The aim section provide formal underpinnings compilation Section 5 As mentioned characterization calculi structureoriented means characterizing introductory default proofs developed formulas For brevity refer reader details approach introduced rooted matingbased matings connection unsatisfiability 79 confine better understanding model elimination section techniques section approach 79 Such ideas needed major follows introduction underlying calculus presented 10 T Schaub S Briining Articial Intelligence 106 1998 I75 First introduce following L We mainly deal formulas complementary given conjunction formulas clause set literals L 1 L representing called negative iff contains negative literals disjunctions clausal form formula conventions let Lc denote literal conjunctive normal form CNF literals To ease notation denote CNF given set clauses disjunction L1 v f v L A clause The matingbased characterization decomposed default proofs relies idea atomic implication u y classical conditions usage resulting clause LX v conditions Intuitively rely sequence default rules induced underlying mating default rules given default rule G prooftheoretii referred admissibility compatibility clauses stemming 79 Such sequence amounts Theorem 21 Definition 22 In fact admissibility provides prooftheoretic counterpart condition consistency described 2 groundedness enumeration notion compatibility condition enforces 3 Now order formula p extension default theory default rules D set transform D W proceed follows indexed implications WD In example encoding yields set WD childs icecreams icecreams milks icecreams sugar 6 The indexes denote respective default rules 4 left right 9 Second transform W Wo clausal forms Cw CD The clauses form lo YCQ 8 clauses referred In example obtain following clause set CW U Co CD called 8clauses wclauses predispo child predispo milk allergen U childs icecreams 1 icecreams milks icecreamg sugars 7 query 60 derivable D W iff unsatisfiable agrees matingbased set clauses Cw U CD U concepts admissibility Finally lp compatibility 31 A default model elimination calculus For providing formal underpinnings compilation sequel proof procedure finds default CW U CD iff exists default proof p D W refutation techniques develop D clause set 53 This Unlike 79 address problem means variant model elimination purely declarative ME default proofs abstract provide adequate basis characterization compilation provide means representing derivations reflect relation goals Section 5 In particular approach provides matingbased introduced techniques 9 Of course indexes influence lo Recall atomic format allows deal binary Sclauses literals complementarity Z Schmb S Briining Artijcial Intelligence 106 1998 I75 11 In contrast adequate account notions furnished subgoals MEbased approach The basic inference allergen extension step amounts let consider Intuitively resolved input clause Lc K1 Kn resulting For illustration initial goal Tmilk resolved clause step renders inference complete solved complementary obtain set allergen steps allows applying subsequently milk steps MEbased calculi called extension reduction step subgoal L Prologs use input resolution new subgoals K1 K clauses 7 query allergen resolve subgoal The reduction clause logic subgoal l1 In example extension steps putative subgoals allergen milk ancestor goals aforementioned milk allergen The resulting ancestor subgoals propositional milks Acecreams clause predispo reduction default reasoning care groundedness For incorporating adapted appropriately end guarantee ye resolved ii extension resulting subgoal cog subsequent extension step guarantee cf condition Among calculus inference steps 2 To dclause US ys input clause step ancestor goals reduction steps Moreover iii consistency previous proof segment diverse mouldings MEbased calculi consider variant relies cf condition 3 socalled MEtableaux basic proof objects cf 4748 Note original definition ME given 54 based socalled MEchains roughly speaking correspond ME open tableau branches time chains basic proof objects time derivations deduction checking consistency Such global view derivations motivated requirement Our choice use MEtableaux consider In follows restrict furnished entire MEtableaux definitions clause logic 4748 The following propositional definitions concepts needed resulting MEcalculus case corresponding list gives definitions Literal tree A literal tree pair t h consisting ordered tree t labeling function h assigning We node t labeled literal L ho L literals nonroot nodes t Successor sequence The successor sequence node o ordered sequence nodes immediate predecessor o order given t tree t Clausal tableau A CZUUSUZ tableau 7 set clauses M literal tree t h hol Ao E M maximal successor sequence 01 0 Tableau clause literals Such clause kol hon E M called tableau clause elements tableau clause called tableau Ziterals This implementations goals normally accumulated keeping previous input clause 12 T Schaub S Briining Artzcial Intelligence 106 1998 175 Depth tableau clause The depth tableau clause hot hon clausal tableau t A defined depth 01 t root node oft depth 0 depth nonroot node t depth direct predecessor plus Model elimination tableau A tableau called model elimination tubkau inner node o labeled literal L leaf node o successor nodes labeled literal Lc Given tableau 7 containing 7 Alo simply ho clear context node o denote literal attached o MEtableau immediate Branch A brunch tableau 7 sequence nodes 7 root 7 oi immediate predecessor oir 1 II o leaf of7 We denote branch nodes write k02 ho labeled literal o sequence containing labels note root node tableau Complementary branch A brunch complementary labels nodes 01 contain literal L complement Lc Open closed branch In order distinguish simple presence complementary branch detection fact allow label branches closed Each branch labeled closed complementary A branch marked closed called open branch Open closed tableau A tableau closed branches closed open Ancestor node ancestor literal Given branch 01 MEtableau oi ancestor node oj h7oi We denote immediate ancestor oi node oir prevoi ancestor literal A7oj 7 iff C j Successor node successor literal Correspondingly oi successor node oj h7oi successor liter k7oj iff j Open goal Let b open branch MEtableau 7 If literal L label leaf node b L called open goal 7 allergen MEtableau 7 given Fig 1 contains predispo Consider allergen allergen plementary closed Closed branches marked underlining open branches milk allergen icecreams contain complementary allergen lpredispo Two branches allergen milk closed milks icecreams allergen tableaux clauses branches milk milks com literals labeled leaf nodes Since 7 contains The following theorem proven 49 forms basis calculi MEtableaux proof objects Z Schaub S Btining Artcial Intelligence 106 1998 175 13 lallergen allergen lpredispo Tmilk milks Acecream6 Fig 1 An MStableau clause set 7 query allergen Each node tableau root node depicted represented label Theorem 31 Let M clause set Then M unsatisable model elimination tableau M exists closed Based definitions apt introduce inference steps inference calculus needed furnishing modeleliminationbased MEtableaux allows build socalled wextension extended w bclauses check complementarity open goal ancestors step tableaux consisting root node tableau clause By tableaux given clause set Finally reduction steps steps bextension steps respectively topdown socalled step introduced technique generating initialization initial Throughlout following definitions set input clauses M CW U Co comprising dclauses let 7 t h arbitrary fixed tableau set CD set CW oclauses Definition 31 Znitialization step Tableau 7 obtained initialization following way step l Let o root onenode tree Select M negative oclause L 1 L E M l Then attach n new successor nodes o label turn L1 L ILl L called topclause For extending tableaux define different variants extension steps The restricted variant identical extension step classical MEcalculi use input clauses CW wclauses tableau expansion Definition 32 wextension following way step Tableau 7 obtained 7 wextension step Select t leaf node o open branch labeled literal L LetLt LbeawclauseinMsuchthatLCLforsomeiE1n Then attach n new successor nodes 01 _ o o label turn Ll Ln respectively l The new branch leaf node oi marked closed 14 I Schaub S Briining Artificial Intelligence 106 1998 175 Co introduce Sextension For extending tableaux 8clauses fact defaults inference rules clause crs 6 Co applied definition reflect formulas 76 Taking account ME topdown backwardchaining application underlying default rule Note taking czg wclause allows applying wextension reasoning contraposition denies Such inferences disallowed sextension step open goal corresponds inference steps steps To begin branch open goal amounts ye ordinary rule character default rules calculus Definition 33 extension following way step Tableau 7 obtained 7 aextension step l Select t leaf node o open branch labeled literal L Let cq ys dclause M Lc ys l Then attach new successor nodes 01 02 o label turn og ys respectively l The new branch leaf node 02 marked closed vocabulary following follows need 33 respectively oi 02 oextension In Definition element 01 o oi ol wextensionresulting resulting node simply nonextension node Jextension extension lited We omit prefixes w awhenever context node called oextension literal aextension node A literal attached considering Definition 32 node bextension node node Aextension wextension literal non clear As argued use clauses tableaux extension reflect properties default rules Apart inference consistencypreserving step bclause end sufficient current derivation way Transposed l2 rule default rules applied clauses guarantee Sextension US ys violate consistency criterion check ys consistent extension 3 Theorem 21 To literals Definition 34 Compatible Sextension step Let 7 tableau let ys ysj set Sextension literals occurring 7 A dextension step Sclause 8 applied 7 called compatible CW U h 9 9 ysj U 6 consistent Observe definition accord consistency 2 flavor involves different set underlying default common rules This fashion Definition 34 relies topdown approach For default rule 8k entire default proof iCI criterion considers default IIlk incremental condition involves default rules ik bottomup conceived condition 8iik I2 Note extension literals correspond long normal default rules considered justifications respective default rules T Schub S Btining Artificial Intelligence 106 1998 175 15 lallergen allergen allergen allergen lpredispo milk allergen lpredispo lmilk Fig 2 The tableaux generated derivation steps clause set 7 topclause allergen cecreams Even conceptions involve multiple default rules bclauses tively sufficient This notion localness backed semimonotonicity compatibility global opposed I bextension respec actual derivation Nonethe treatment steps We come issue end section Actually Definition 33 furnishes onehalf machinery needed ensuring special status restrict attention necessitates inference rule character default rules Intuitively reasoning cases Sclauses This restricting step classical MEcalculi The sole difference literal CQ solved reduction exist independent words exist closed MEtableau topclause US subgoals Sextensionresulting steps ancestors CQ l3 There default proof og ignores ancestors eliminate reduction wellknown Definition 35 Reduction step Tableau T obtained I following way l Select t leaf node Ok open branch b 01 Ok Ok labeled literal L l If ancestor node oi b labeled literal Lc nodes Oit Ok wextensionresulting nodes mark b closed Consider tableaux depicted step topclause initialization 55 iapplying oextension sole open goal allergen The rightmost step 8clause extension Fig 2 The leftmost allergen step oclause tableau 7j generated The second tableau 72 generated tableau emerges 72 application predispo allergen milk Acecreams milks open goal milk The inference steps provide sound complete calculus given definition Definition 36 Default model elimination A sequence called DMEderivation clause set M called set input clauses Tr 7n MEtableaux l 71 obtained initialization l 1 K 6 n x obtained step x1 applying 31 reduction step l3 This restriction reflects property admissibility introduced 79 16 I Schaub S Briining ArtQicial Intelligence 106 1998 I75 allergen allergen allergen Tpredispo Tmilk allergen lpredispo Tmilk Ih predispo milka cecream62 ___ I h predispo milka cecreams icecreamg child icecreams childa I child Fig 3 Generating closed tableau clause set 7 topclause allergen wextension compatible extension step A DMEderivation step called DMErefutation generates closed tableau Observe clause extension step definition input clause For convenience elements derivation identify tableaux generating Piln obtaining z di denotes inference steps write instance respective dl dn instead rule inference Let L open goal attached node o MEtableau 7 A DMEsubderivation 2 o L sequence derivation steps element D selects o element selects descendant o ID called DMEsubrefutation applying V 7 branch containing o closed We omit prefix DME clear context We continue example developed Fig 2 A DMErefutation follows wextension tableau rightmost query allergen step wclause Fig 2 Second applied open goal predispo step clause clause set 7 constructed predispo dextension As result tableau leftmost tableau Fig 3 containing single open branch This open branch closed application wextension step unit clause child Hence resulting tableau right Fig 3 closed DMErefutation The following allergen clause set 7 theorem icecreams applied open goal Acecreams generating DMEderivations tells mechanism childs exhaustive manner constitutes sound complete proof mechanism default logic restricted normal default theories query answering Theorem 32 Let D W normal default theory CP atomic formula Let M clausal representation atomic format D W Then defaultprooffor q D W iff DMErefutation M topclause IQ Z Schaub S Briining ArtQicial Intelligence 106 1998 l75 17 The restriction atomic queries query formula 4 replaced atomic rp additional 4 q IV This technique It worth emphasizing PTTP 86 pure propositional limitation approach arbitrary formula like ordinary ME defined example clause sets Sclauses Default 47 Model Elimination This behaves exactly l definitions initialization steps wextension steps exactly classical propositional MEcalculi l 6extension l dclauses derivation DMEreduction steps enter derivation steps correspond exactly classical MEreduction steps inspecting reduction aextension implementation dextension step searching literals occurring The material presented section constitutes allows ignoring check As result inference logic The resulting DMEcalculus default systematic characterization relies local proof procedure employing steps DMEcalculus compiling query answering homogeneous diverse design decisions regards ultimate approach consistency local fashion This comprises ancestor goals verification compatibility involves nonetheless consistency derivations This clause combinatoric disjunctions Another objection impracticable formulas necessary represent eventually issue addressed Section 5 fundamental basis approach provides default proofs leaves room In fact salient feature incremental executable steps tableau hand But current derivation check Of course speaking unsuccessful ME l4 infeasible gets worse presence aim compiling DMEderivations sets Section 4 checks actually check This yield ordinary MEtableaux generalization logic We argue explosion repeated open branch mechanism special status involved check mapped 34 Moreover argue perform exhaustive consistency approach saturations Section 4 introduce reuse result successful deal dynamically Prologs negationasfailure default clauses outside actual compilation continuously consistency cf Definition consistency consistency comprising techniques checking changing roughly 32 Extensions renements 321 Lemma handling Lemma handling important means automated eliminating cf 4 This task difficult context proofs redundancy theorem proving depend default rules induced consistency requirements In fact classical MEbased calculi lemma 1 simply set literals allows elements I labels nodes It known closing branch containing I4 A similar approach pursued 79 facile decision procedure 18 T Schaub S Briining Articial Znrelligence IO6 1998 175 given clause sets M M M c M lemma 1 generated MEderivation M That branch b generated derivation M containing 1 subset labels b marked closed M 1 applied safely derivations Unlike classical approach default impossible theorem proving This derivation generated depend set dclauses CDS The use 1 derivation employing defaults consistent CDS lead incorrect results In context default theorem proving extend concept lemmas subrefutation simply use lemmas like 1 1 Definition 37 DMElemma Let CW set wclauses CD set clauses let 7 tableau generated DMEderivation CW U CD Let o node 2 7 branch 7 containing o closed exists subrefutation o Further let 01 ancestor nodes o reduction steps D let M C Cw U CD set input clauses D Then clause ho kol h called DMElemma respect M set default rules S 1 ye E CD n M Formal underpinnings notion given appeal socalled lemma default rules 78 Restricted D W constructed normal default theories lemma default rule 61 formula 1 default proof 1 following way 61 AsE Conw 1 nonnormal default rule precise meaning fixed Since results respect fullfledged default logic For fullfledged Reiters default logic shown 78 E extension D W iff E extension D U al W Our approach justified following result Theorem 33 Let Cw set wclauses CD set dclauses W U ConseqD subset consistent Let 1 DMElemma respect Cw U CD set default rules D G D Further let I tableau generated Cw U CD let b 01 ou o branch 1 DMEderivation nodes 1 c ho o wextensionresulting b ho Lf Oul marked closed losing soundness As corollary result obtain soundness preserved extending DME derivations appropriate Lemma step given shape follows For let 7 t h I LI _ L accord Theorem 33 Definition 38 Lemma step Tableau 7 obtained 7 following way l Selectintanopenbranchbol 0 If ovto K mark b closed wextensionresulting nodes b Ll L E K o olabeledwithKl K K I Schaub S Briining Articial Intelligence 106 1998 l75 19 The concept DMElemmas discussed example 1n particular rely DMElemmas information DMEderivations attached consistency checker Section 4 including illustrative Section 4 communicating 322 LOOD checking blockwise regularity tableaux It forbids search space MEbased nodes 01 02 Regularity provides highly efficient means restricting tableaux containing generate Unfortunately build deduction decreases considerably theorem proving branch 01 02 labeled literal Using refinement number possible cases 4748 important classical ME applied Default losing completeness However sequel Model Elimination needs default reasoning This leads adapt regularity possible subgoal L1 equal blockwise regularity requires literal Lr L2 ii ancestors 1 different aextension resulting nodes branch ancestor nodes labeled equal literals words need construct branch clauses corresponding defaults consequent extensionresulting refinement In fact pure classical parts default proof blockwise exactly like ordinary regularity parts derivation guarantees Besides pruning completeness large parts search space blockwise necessarily violated infinite branches dclauses consequent constructing regularity involving bclauses regularity behaves branch guarantees The following definition formal defjnition blockwise classical branch regularity introduces regularity Roughly spoken block considered concept blocks required block branch classical restriction applied losing completeness Definition 39 Block Let 7 MEtableau clause set M let b 01 branch 7 The sequence oi oj 1 j n called block b iff generated DMEderivation 1 Ok immediate ancestor Ok1 k j 2 oi aextension 3 ok k j wextension node wextension resulting node generated initialization step resulting node 3 asserts simply literal attached ok stems wclause M Condition For illustration represented label root node indicated l The start block marked typesetting respective consider Fig 4 There node branch The purpose underlining explained Then blockwise defined follows literal boldface regularity Definition 310 derivation conditions hold Blockwise clause set M 7 regularity Let 7 MEtableau generated DME called blockwisely iff following regular 1 Foreachblockot oofabranchof7hoihojforalllijn 20 T Schaub S Briining Artficial Intelligence 106 1998 l75 Fig 4 Some branches illustrating blockwise regularity 2 For branch dextension We DMEderivation blockwisely regular 01 7 Lprevoi hprevoj oi oj resulting nodes 1 6 j n regular D blockwisely iff tableau generated D clauses stemming The effect blockwise Condition 2 asserts simply literals branch proved defaults having consequent nodes characterizing failure blockwise branches violate condition regularity illustrated branches shown Fig 4 underlined An containing branches need considered 1 Definition 310 The 2 consequent Bs different blocks Only rightmost MEtableau deduction holds MEtableau containing Definition 310 This Ba2 respectively As Bs 1 DJ BJ Observe occurrences 1 B branch belong branch violate criteria blockwise branch meet condition bclauses having regularity regularity The following theorem guarantees derivation generating nonregular tableau pruned away losing completeness Theorem 34 Let R DMErefutation generated R blockwisely M tableau I generated R blockwisely regular clause set M tableau 7 regular Then exists DMErefutation R 4 Modelbased consistency checking This section According compatibility presuppose devoted section aextension incremental implementation amounts checking verifying steps For start taking abstract point view mechanism developing mechanism consistency procedure enumerating DMEderivations I Schaub S Briining Articial Intelligence 106 1998 I75 21 finding models formulas CNF The usage formulas ones motivated need continuous modifications reductions formulas handed consistency implemented effectively formulas CNF CNF opposed arbitrary like additions subsequent check These operations situations encounter aextension incrementally involved steps The aim search potentially Now checking consistency reuse checks possible Of course reusability partial default proof In way model bears witness reducing computational allows pruning inconsistent repetitively clearly efforts Our goal avoid exhaustive general purpose mechanisms subproofs furnish approach restricting exhaustive consistency checks ultimately necessary ones We address problem lmeans modelbased approach use model compact representation consistency compatibility model subsequent compatibility depends chosen model Hence loolk better model We support treatment theorem proving model handling This approach reduced clause sets containing rules precise We refer clause sets modelclausesets representations underlying following way First time default rule applies modelclauseset extension prover added Both sorts added formulas reduce modelclause set hand Conversely theorem prover benefit provided model current derivation proven great value classical automated In follows concentrate realizing search models transferring finder synergistic relies repeatedly applied default current derivation compact set models Mutual benefits obtainable added literal 6 lemmas provided theorem semantic account proof search This avenue cf SS issues supporting theorem prover model That normal default rules Jextension step added set In addition certain initial facts justifications exploit literals occurring theorem proving bextension justification governing information First let precise treat consistency checks model handling set formulas W sequence default rules W U ConseqG0 _1 Function V checks W U ConseqSo Si_l Conseq let m model 3 Definition 34 stipulated condition Sjji m W Sjji m W 6jji m I Consed m k ConseqSi V m W Sjj I I m fm m W U COTLSeGj 1 j m mN b W U COKWqSj 1 j Function V gives general description approach making precise intuition given We refine specification sequel The following result shows V provides sound complete specification consistency condition expressed condition 3 Definition 21 Definition 34 22 Z Schaub S Briining ArtQicial Intelligence 106 1998 l75 Theorem 41 Let W set offormulas SiiI sequence normal default rules Then E I model m W U ConseqGo _I model m W U ConseqGo Si V m W Sjji m W ajji ifs W U ConseqGo 6i_lyCOnSeqSi V6i m W SjjiL iff W U ConseqGo Silk COZSeq Observe m m need distinct At start derivation m set arbitrary model set premises CW l5 From conceptual point view actually easy read model clause set taking literal clause taking literal wclause set CW predispo negation Consider milk Cw models allergen cases V 7 We obtain child predispo covering given models actually partial models degrees predispo child milk refineable predispo child allergen fix truthvalues literals freedom We rely feature sequel certain Note Whenever clause ys selected aextension step course DME derivation check JQ satisfied current model m In setting actually simply checking 16 m nature m 8 If m U 6 case ys added partial model m In way enforce model W VS3YSi uYSJ 8 y6i stand consequents given Sextension derivations This treatment amounts Definition 34 Otherwise carrying derivation current situation literals occurring previously defaults In DME tableau hand steps M E m new model 8 If model provided Sclause CQ 6 imposed aextension compatibility criterion relation For reducing computational efforts searching new models consider afore denoted M simplified equivalent variants mentioned modelclausesets clause set 8 Coexisting models modelclausesets considered model satisfies current nected satisfiability equals CW Dur modelclauseset At start DMEderivation defaults ing DMEderivation certain lemmas provided theorem prover The principal idea simpliJj 44 addition Hence case new model generated start clause set 8 set cut possible appeal previously gathered information 16 t7 Each extended justifications modelclauseset invariantly l5 Such model exists assume W consistent cf Footnote 4 I6 Notably simplifications I7 Note doable anytime manner case derivation steps withdrawn corresponding modifications respective modelclausesets withdrawn 7 Schaub S Briining ArtQicial Intelligence 106 1998 175 23 techniques automated unitreductions subsumptiondeletion time While unitreduction L simplification modelpreserving partial models original In simplifications possible model generations eliminating restrict known reduction polynomial simplified clause set reduce search space easing invalid superfluous ones In paper theorem proving cf 2353 carried allows replace clause Ll L presence unit clause LF subsumption byLlLilLil deletion allows remove clause Ll L subsets In fact reductions essential proof procedures For illustration presence proper Resolution based cf Section 5 l8 allergies lively normally stressed lively children considered child usually stressed stay home normally scratches Also know home sugar milk In case milk causes allergic reaction sugar stress Her allergy makes scratch This represented following default theory consider set statements dealing nutrition 28 implementation apathetic DavisPutnam lively lively A home stress D livtly 3 stress 9 stress A scratch apathetic apathetic IT W home sugar V milk milk allergy stress A sugar allergy allergy scratch For instance explain considered child apathetic lively lively A home stress stress A scratch apathetic lively stress apathetic The atomic format exemplary default theory D W D W D lively R stress Q apathetic lively stress apathetic W W U lively A home _ R stress A scratch Q 9 10 11 Let illustrate approach explaining D W means DMErefutation childs apathy apathetic theory Cwt IJ Cp U apathetic 12 Figs 59 snapshots interplay DMEderivations models modelclausesets lo 11 letters capitalized For brevity abbreviate form corresponding follows propositions As initial model CW modelclauseset MO mu HO SU AL SC LI Q MO mu given right Fig 5 Intuitively mu obtained Mu taking HO clause Mu SU second AL Now start DMEderivation initialization step topclause YAP The resulting tableau open goal AP given left Fig 5 l8 An elabomted account effective methods procedure 34 DavisPutnam simplifying clause sets implementations Z Schaub S Briining Artificial Intelligence 106 1998 I75 HO MI MI SU AL 4T YAP cWtMo t AL SC 1AL 1LI 4c G 4iU 1HO 4T m0 HOSUALSCLIQ Fig 5 Snapshot derivation AP TAP HO MI YMI APB lQ6s M1 SU AL 4T AL 1LI 4C SU 4T AL SC APa 4T 2c SC 1AL AL 4T JJ 4 m U APJI HO SU AL SC lLl Q U APb3 Fig 6 Snapshot derivation AP tableau steps Since clause set Fig 6 contains Fig 6 emerges applying Sextension steps 6 extension The second step uses aclause es APs wextension modelclauseset Ml Since mo satisfies clause R LI HO reduced mo W 83 extend mu APg terms V63 mu W 0 equals rnb mg U APs continue mb Recall V deals total models actually account partial ones extending transition degrees freedom R LI unitreduction APs3 Observe mg mb clause The Sextension step applied subgoal ST uses Sclause STa The following tableau Fig 7 Since rn satisfies ST8 proceed simply extending rnb rn rnb U STs Furthermore add clause STa Ml apply unitreduction gives modelclauseset M2 clause set Fig 7 steps applied subgoals tableau Fig 8 The second Sextension step uses Sclause Lls Notably rng satisfy Lla Therefore search new model ml modelclauseset M3 emerges M2 U Lls application unitreduction Note rigorous application unitreductions M3 comprises merely 25 32 potential models opposed 23 x 33 216 case Cwl Formally extension LI HO RJ V mi w9 6362 ml w 8382 m 1 HO SU AL SC R Q APs STs Lls Schaub S Briining Articial Intelligence 106 1998 175 25 t HO MI MI SU AL AL SC Mz A 1 ST AL TLI SC su 1 rng rnb U ST HO SU AL SC yLl Q APa3 U STJ Fig 7 Snapshot derivation AP TAP _I AP6 lQ6s _ ic SC AL T ST M3 4T 2iu AL I ST6 rw 12 7LI I L16 HO I HO u SU AL 7AL SC HO MI 1MI AL SC A ST Lb ml HOSUALSCRQAP6ST62Lldl Fig 8 Snapshot derivation AP Now DMEderivation reached point subgoals LI HO RJ ST proven According Definition 37 DMElemma respect HO set defaults l HO l LI DMElemma respect Lls Sl DMElemma respect HO DMElemma respect HO l Rs2 l ST Llsl R LI ILlsI R LI HO al HO STs Ral I 821 In words shown open branch tableau generated DME derivation 13 26 Z Schmb S Briining Artificial Intelligence 106 1998 l75 I TAP f HO MI SU M4 SC R A ST Lb AL Fig 9 Snapshot derivation AP marked closed contains tLI HO 7Ra2 ST It important exploited modelclauseset realize information reducing number potential models This partial model instance Ma 13 l9 way round set lit erals model 13 model M3 Formally capture Section 321 DMElemma 1 introduced idea concept DMElemmas clause set M partial model M contain generated DMEderivation model M This ing 1 subset considered searching DMEderivation considera tions Theorem 32 Hence generation DMElemma E entailed M As consequence A4 implies subset invalid ignored I clause set potential model containing 1 considered classical MEderivation For simplification issues socalled unit lemmas consisting singleton sets literals DMElemma L clause lL particular In fact generating simplification Other non added respective modelclauseset model unit default lemmas kind constraints searching modelclauseset sub set Moreover need consistency check lemmas drawn current default proof We discuss socalled relative dynamic default rules belonging Section 521 lemmas skip potential model containing DMElemma Turning running example advantage generated cor ST However M3 contains negated unit clauses particular DMElemmas DMElemmas responding HO LI IR lg This modelclauseset derivation subset added respective modelclauseset contains C W simplified form ii Sclause I Schaub S Briining Artificial Intelligence 106 1998 175 27 M3 Nevertheless steps illustrated tableau useful Such situation situations ex given following Fig 9 note steps use AL C proven negated unit clauses M3 note extend turns provide useful AL adding resulting unit clause AL Ms allows subsequent simplifications ploitation DMElemmas inference clauses The reader verify subgoals add corresponding ml iaheady contains AL SC In particular DMElemma unit subsumptionreductions Fig 9 Obviously new model needed example efforts The resulting modelclauseset M4 Finally sole remaining subgoal treated far viz ST proven previously generated DMElemma ST In shown exists DMErefutation clause set 12 steps warranted ml We shown AP explained means involved aextension clause AP The compatibility models mu mbm default proof 9 D W Apart reuse models compact representations previous consistency doable implementation classical modelclauseset subject backtracking strategies One extreme trigger simplifications shown forward approach In fact anytime manner And addition lemmas lemmata set liclauses derivation This leaves room item principle checks example puts emphasis simplifications simplifications depending default assumptions independently different added modelclauseset need enforced search new Another altlemative parallel setting model The moulding anytime property allows continued simplifications putting brakes actual inference engine In purely sequential setting second variant appropriate ultimately necessary ones This chosen option implementing modelbased approach consistency checking shown section arguably appealing efforts polynomial simplification restricted 5 Implementing query answering default theories section The key observation led results reported query answering presented ogy straightforward manner This fact model elimination closely related Prologs linear input resolution implementation 86883 As regards classical impressive highperformance vincing performance systems similar systems based Warren Abstract Machine approach previous sections allows apply Prolog technol 53 renders especially qualified means socalled Prolog Technology Theorem Provers PTTPs theorem proving proof systems like 94186 The main reason ability advantage highly efficient underlying Prolog approach resulted l In follows Prolog technology implementing fault reasoning systems As regards classical theorem proving follow approach 28 lY Schaub S Briining ArtiJicial Intelligence I06 1998 175 taken Stickels PTTP 8788 PTTP seen extension Prolog pro In order attain vides proof firstorder predicate calculus enhance Prolog measures guaranteeing ii complete search In follows concentrate item inference iii complete restricted exposition propositional classical methods addressing refer reader details 87 case In fact need modifying issues dealing default reasoning sound unification 51 Implementation extended Prolog compiler The standard approach based idea transform theory W query q Prolog program Pw Prolog query Qp QV derivable PW iff W A IJYJ unsatisfiable transformation approach conceptually simple proven successful In way Prolog inference mechanism guarantee remains unchanged items iiii Although implementation The step Stickels transformation set Prolog rules Since Prolog rule clauses cation t b idea transform clause log rule More generally clause Ll L transformed Li t LE A A Lf_1 A LF1 A A Lh referred implication contrapositive direct translation given set input b read impli Pro like 6 original clause 2o However order guarantee completeness reasoning contrapo sition generate Prolog rule contrapositive clause hand Our exemplary clause b results contrapositives consider For illustration t b b classical t contrapositive milk formulas t 4 While child predispo respectively t milk A predispo allergen allergen t child predispo allergen A predispo predispo schema 87 amounts following Prolog rules 21 t allergen A milk Following turned single obtain contrapositives predispo t milk PTTPs translation child predispo allergen notmilk not_predispo milk notallergen predispo predispo notallergen milk We refer rules orules Prologs treatment wrule corresponds extension step original clause input clause closing head literal For set containing n clauses maximal cardinality obtain 12 x m wrules account rule corresponds Prologs inference Taking branch w labeled m extension step obviously provide additional means complete means reasoning cases This actually accomplished extending order integrate reduction steps Section 31 Following PITPs translation classical ME inference translation schema 2o Taking commutativity 21 Following FITPs syntax allergen A account clause consisting n literals n contrapositives stand allergen allergen notallergen I Schaub S Briining Arcial Intelligence 106 1998 175 29 following way First memorize 87 achieved adding additional argument refer list ancestor notmilk list like allergen ancestor order allow testing subsequent memorized example following ancestors goals list tic literal left column We list Second literal added rule rule added possibly rules given right column 22 In subgoal complementary literal These additional rules child Ant predispo Ant allergenAnc KewAnc allergenlAncl milkNewAnc predispoNewAnc notLmilkAnc NewAnc not_milklAnc rot_allergenNewAnc predispoNewAnc not_allergenAnc memberallergenAnc milkAnc membernot_milkAnc not_predispoAnc predispoAnc NewAnc not_predispolAnc not_allergenNewAnc milkNewAnc membernot_predispo ATK For clause set alphabet counting Prolog rules As shown 88 aforementioned proof propositional rules implementing address issues separately I letters obtain 2 x 1 additional provide clause logic For brevity refrain adding Prolog Section 32 We regularity checks lemma handling discussed time transformations Section 52 compile Let turn transformations needed integrating default rules We seen Section 31 classical MEbased calculus adapted default reasoning classical definition reduction schema order incorporate steps In follows advance PTTPs step bclauses ii restricting adding restricted extension enhancements As pointed Section 31 definition Jextension steps reflects fact translation dextension literals corresponding defaults inference rules demanding defaults conventional wextension treat Sclauses oclauses YCQ ys equals wclause contrapositives transformation account analogous way In fact translation clause considered ya t 8 This yields single Prolog literals This actually distinguishes steps 23 By taking difference consequents rule yd The 22 For examples 23 Note talking compatible Sextension steps stage second Prolog rule procedure Fig A2 30 T Schaub S Briining Articial Intelligence 106 1998 I75 single contrapositive inferences clauses restriction refuses preserving 6s inference abbreviate Srule stemming obtain default rules 4 following Prolog rules renders reason contraposition ineffective like 8 solve open goal like CQ rule character We refer resulting Prolog rules Srules default 5 rc In example icecream child milk icecream sugar icecream In analogy orules rule describes possible transition tableaux means Sextension step underlying default rule For clause set containing d clauses obtain d rules As ordinary clauses provide means applying argument memorizing resulting add additional extending list set list avoiding way resulting Prolog program steps given Definition 35 For clauses reduction implements ancestor reduction steps As subgoals But instead ancestor steps ancestor subgoals 8 In reduction restriction classical example list head literal 8 considered brule icecreamAnc child milkAnc icecream sugarAnc icecream transformation bextension provides means The step compatibility guaranteeing partial model m compact representation proof For implementing argument mforCwUyjIjiprovidedthatIrtdesrs derivation point effectuated brules r6 r6r_1 preserved compatibility checking steps We seen Section 4 single consistency default checking add partial model ts_ successfully applied steps generated Prolog rule containing In way m guarantees dextension modelbased consistency consistency approach When testing compatibility drule rs check yai satisfied m Note size ysi If easy test succeeds satisfiability continue extending partial model m order account ysi If try generate new model m satisfying test linear CWUYSj lj iuYSil If succeeds continue proving m Otherwise backtracking proceeding guards compatible application subsequent extension specification function V given Section 4 14 engaged This steps according T Schub S Bribing Artificial Intelligence 106 1998 l75 31 However order able generate new models dynamically increasing decreasing clause sets form 14 need extremely corresponding modelclausesets sets current model rigid Prolog code This chosen propagate modelclause instead compiling ongoing derivation flexible representation As consequence suggestsverifies function V implemented runtime predicate compa t ble 3 whichas step drule rsi given ysi 24 compatib1e The argument comprises current model m current model While second argument encapsulates clauseset information enriched informa tion gathered successful application Q In case failure m b 16 new model m 14 modelclauseset ble Jextension justification argument contains 3 fails backtracking predicate compati engaged In need physical variables physical variables derivation 13ecause tight relationship means binary regroup example MM NewMM propagating modelclausesets M NewM propagating models models modelclausesets following rules functor m 2 This yields icecreamAncmMMMmNewMNewMM childmMMMmMlMMl 1 compatibleicecreammMlMMlmNewMNewMM milkAncmMMMmNewMNewMM icecream I mMMM mMlMMl compatiblemilkmM1MMlmNewMNewMM sugarAncmMMYMmNewMNewMM icecream compatiblesugarmMlMMl mMMM mMlMMl mNewMNewMM pairs like m M MM correspond Observe rng M ml M3 Figs 59 like instance Notably implementation time check compatibility finding proof original prerequisite From rule ya t CQ generate following Prolog rules depending choose compiler option ucorn corna allows decide compile accm ys a8 compatible ys corna ya compatible ayg Under option ocorn Prolog tries proof prerequisite cxg checking compatibility 6 corna compatibility checked 24 Actually implemented argument Icontains CNF justification See Section 524 deals default components negation normal form Consequently 32 I Schaub S Btining Artificial intelligence 106 1998 175 Turning example Prolog rules replaced corno icecreamAncmMMMmNewMNewMM compatibleicecreammMMM childlmMlMMlmNewMNewMM mMlMMl 1 search space knowledge bases comprising A detailed empirical analysis options preceding verification compatibility pruning conflicts For instance deciding Hamiltonian better results observed guided classical example terminological inferencing 25 belated compatibility given Section 53 We report turns extremely valuable corno high number potential compiler option leads check acorn The inverse knowledge bases search cycle problems From schematic perspective simplistic setting 26 following predicate compatible Prolog clauses 3 defined compatibleKmMMMmKIMNewMM negated_literalKNOT_K memberNOT_KM reduced_clause_setlMMNewMM compatibleKmMMM mNewMNewMM negated_literalKNOT_K NOTK 14 member reduced_clause_set model NewMM NewM KlIMMlNewMM teral Runtime predicate negated_li X Runtime predicate member 2 implements sets represented lists lists literals X Y true Y bound common membershiprelation negation Clause To begin observe combination variable K term m M MM information passed function V Section 4 V6 m W SjjJ amounts While K stands justification current model m current modelclauseset M providing representation justifications ye 6 ConseqG ya M MM represent compact I j E I This sufficient V deals W U ConseqSj consequents respectively considered normal default rules The clause handles case K satisfied model M In simplistic setting NOTK M In addition reduced run subsumption tested 1s m expressed member modelclauseset MM extended unit clause time predicate 2 involving unitreductions Kl reduced_clause_set 25 In fact gain case drastic case hand inherent complexity problem set decreasing 26 This involves literal justifications normal form ii closed formulas justifications details atomic format opposed restrictions unleashed general ones conjunctive See 59 T Schaub S Briining Artcial Intelligence 106 1998 l75 33 described Section 4 Finally ys added deletions occurrences Prologs head matching steps new model NewM computed runtime predicate model clauseset NewMM results clause m neglecting multiple In case 1s E m second Prolog clause 2 model reductions Kl MM applying This proceeding accord principled continuous modelclauseset As anticipated end Section 4 actually simplifies model reusable case simplifications pursue pragmatic approach need Thus simplification This yields following alternative pattern clause approach allowing current implementation compatibleKmMMM negatedliteral member NOT_KM m KIM KNOT_K Kl MMl solution This pragmatic model switches Investigations profiler showed cases considerable CPUtime justified fact observe examples consumed simplification procedures procedure For finding new models runtime predicate model DavisPutnam finding propositional models Importantly information modelclauseset lead drastic reduction search space finding new models illustrated Section 4 Further implementationbased 2 use adapted variant 28 currently fastest complete methods task supported repeated reductions proof search This gathered improvements detailed 21 83 affects Prolog rules stemming The propagation models modelclausesets classical clauses completes resulting Prolog program childAncMMMMMM predispoAncMMMMMM allergenAncMMMIMMMO not_allergenAncMMMMMM NewAnc allergenIAncl memberallergenAnc milkNewAncMMMIMMMl redispoNewAncMMMlMMMO not_milkAncMMMIMMMO milkAncMMMMMM Newc not_milklAncl membernot_milkAnc xot_allergenNewAncMMMIMMMl redispoNewAncMMMlMMMO not__predispoAncMMMIMMMO predispoAncMMMMMM Bew_nc notqredispoAncl membernot_predispoAnc not_allergenNewAncMNMIMMMl nilkNewAncMMMlMMMO The material provides simplified theory D W Prolog program PD For query answering provide like p Following PTTP use purpose recipe transforming transformation queries default 34 7 Schaub S Briining Articial Intelligence IO6 1998 l75 Number Purpose Source nxm 2x1 wrules reduction rules d 1 rules query rule W D cp nxm2xZdl WDcp Fig 10 Estimated size Prolog code resulting basic compilation techniques Prolog rule form query special predicate query application rule similar treatment consistency enriched runtime predicate model generates initial model C w Furthermore list set list propagate p Basically For 2 ancestor model generated model step DMEderivations rule initialize initialization 2 In example query allergen schematically following Prolog rule CW represents reduced variant Cw query model C_WM allersenlmMC_Wm__ 16 This rule allows pose initial query allergen Prolog query query In compile default theory program PDw PDW U 16 Prolog query query program performance Subsequent queries easily posed replacing recompiling query rule D W query p Prolog The resulting leads impressive single standard Prolog compiler compilable Finally let estimate number resulting Prolog rules obtained compilation atomic default theory D W query IJJ alphabet _K Let symbols CW contain 12 clauses maximal cardinality Fig 10 let D cardinality d The estimate resulting code summarized We refine estimate refinements approach Section 526 incorporate m let Z count 1 propositional rules stemming For impression consult Appendix A containing examples treated paper resulting objectcode 52 Extensions refinements implementation The previous section presented basic approach implementing default reasoning taking advantage power provided PMP Our current implementation refines basic approach ways order improve flexibility efficiency This section summarizes important improvements I Schmb S Btining Artificial Intelligence 106 1998 l75 35 521 Lemma handling We stressed Section 321 importance lemma handling means theorem proving We seen task eliminating difficult context proofs depend default rules lemma handling independent automated redundancy subtasks We actually distinguish generation usage lemmas For generating subderivations stleps ancestor goals outside lemmas knowledge deriving This know subgoals solved ii reduction consistency assumptions Aextension steps This requires recording lemmatized This means PTTPs subderivations overall proof proof recording facilities standard PTTP recording order query For purpose arguments added Prolog predicate account runtime Prolog code complemented extracting subderivations relevant subderivations proposition considered subderivation information accomplished passing proven subgoal infor predicate 1 emma t z e encapsulates subderivation mation gathered actual lemmatization Prolog rules simply attaching predicate 1 emma t z e end rules bodies At location rules body possession entire subderivation subgoals proven proceeding Concretely add lemma generation Lemma generation For example case Prolog rule headed allergen obtain detailing extant construction following rule allergen milk predispo lemmatizeallergen allergen subderivations For propagating extended passed lemmatize allergen additional variables outcome extending compilations Note lemma generation add entire rules resulting Prolog code single subgoal proposition course lemmatized appropriately predispo The entire subject milk rule This subgoal composed lemma proof aforementioned generated database available later usage The dumped lemma information means Prologs final form predicate 1 emma t z e actual Prolog subproof analysis dumps proof assertl extracted standard predicate items following format lemrrlaGoalAncestorsAssumptions 17 This signifies Ancestors given disjunction Section 32 lemma DMElemmaLLt Goal consistency assumptions Assumptions proven means reductions ancestor goals That terms Ll L A represents literals Ancestors The lemma Goal item lemmaL L respect set default rules St 8k 36 I Schaub S Briining Artficial Intelligence 106 1998 I75 For lemmas simply add terminating Prolog rules procedure For resolving schematically Prolog rule allergen lemma usage allergen lemma allergen Prolog add example procedure allergen For predicate lemma looks Prolog database corresponding actually matches final form lemma items given 17 Once lemmas item retrieved usually 27 account attached stored lemma 5 According rule 28 consistency model handling described steps Section 5 obtain compilation requirements Sections 4 following allergenAncmMMMmNewMNewMM lemmaallergenAncestorsAssumptions compatibleAssumptionsmMMM mNewMNewMM entire rule As dealing disjunctive Ancestors form subset nc 29 subject compilations Among lemmas addressed checking ancestor goals In feature adds 2 x I additional Prolog rules 1 size underlying alphabet In current implementation particularly unrestricted mechanisms swamping successful approaches storage To end employ lemma fashion leads generation flood useless lemmas care fact roots techniques theorem proving restrict lemma usage classical First actually distinguish static dynamic lemmas cf 51 Dynamic lemmas disappear lemmas temporary steps expires soon subderivation lemmas derived deduction number available dynamic lemma subsequent derivation Hence subgoals warranted presence compatible usable consistency checks 3o For dynamic rule replaced following tableau consideration Notably backtracking tracked limited number proved consistent use lemmas lemmas Prolog lemma handling subderivation Thus valid dynamic subderivation allergenAncMMMMMM lemmaallergenAncestors_ 27 This applies static lemmas details Anticipating clause set treatment general default rules Section 524 Assumptions represents actually 29 While actual implementation allows generating disjunctive lemmas actually use We concentrate unit lemmas usage effective See 3o Hence application dynamic lemma tracked Section 523 T Schaub S Brining Artcial Intelligence IO6 1998 I75 31 Experiments shown use dynamic lemmas result significant speed practically harm proof search restricted viability This actually related technique illustrated classical MEbased foldingup highly effective technique lemmas theorem proving Section 53 The use dynamic 48 Creduction 84 As opposed static lemmas kept underlying consistency Second implementation deduction requires verifying compatibility assumptions time lemma These lemmas dealt carefully flood useless lemmas swamping lead aforementioned socalled restrict unit lemmas consist literal Due fact application unit lemmas depend existence suitable ancestor goals lemmas clearly effective dynamic lookup database For dynamic unit lemma handling Prolog rule simplified ordinary ones Furthermore checked efficiently generation lemmas lemmas considered application simple particular storage allows allergenAncMMMMIVM lenunaallergen I_ In field classical strengthening theorem proving unit lemmas shown inevitable deductive power MEbased proof systems 141 522 Loop checking blockwise regularity As described Section 322 regularity provides highly efficient means discarding proof systems based model ancestor subgoals identical subgoals elimination As Ilemmas adapt tool default Section 322 called blockwise regularity requiring identical branch contain identical literals Sextension step applied reasoning This led block literals ii branch contain regularity For verifying condition Both conditions easily implemented lists forward use fact 87 classical steps Hence literals block exactly simply Prolog procedure terminating Prolog rule clause checks ancestor steps contain literals reduction list memorizing potential candidates literals For instance identical reduction ancestor allergen Ant memberallergenAnc fail procedure allergen procedure Fig A2 For examples Prolog rule For verifying condition ii check Srule ye ag brule head ys prove 6 To end actually add list memorizing 38 I Schaub S Briining Artiial Intelligence IO6 1998 175 ancestors bextension ones checking condition As implementing resulting prevent derivations violating condition steps literals provide clauses similar ii reduction lemma feature adds 2 x 1 additional Prolog rules 1 size alphabet 523 Avoiding useless backtracking For propositional step G The holds application dynamic clauses known reduction steps extension steps apply derivation unit clauses need tracked That possible apply step open goal G tableau 7 check derivations derivation branch open goal G tableau 7 marked closed application dynamic extension tableau 7 corresponding derivation contains brule r derivation 1 Sextension application E 7 restrict application extension Fortunately enhancements need check derivation step G 7 This dynamic lemma 1 applied easily implementable applies reduction step r Hence lemmas lemma steps Prologclauses guarantee unit clauses lemma usage Prolog clauses extension steps ii clauses ends implementing Prologs cut steps reduction steps extension implementing 524 General default rules For simplicity presentation far dominated default rules having atomic negation deals formulas components As PTTP implementation normal form Let illustrate detailing transformation default rule AABvC DvE 642 DvE To begin note translating rule atomic format yields os4 I642 A A 1B v C ys42 D v E 3642 D v E y642 B42 y642 new atoms The obtained single contrapositive ys42 t CQ turned drule atomic default rule 42 transformed gamma42 This drule alpha42 D v E This furthermore motivated concern consistency Bs42 JUstif This accomplished wrapping justif woven ication Justif information implications handling fact provided form check These rules transformed rule term atomic default intermediate Srule stemming justification Justif6i adding body drule In general generate default rule 6i exactly drule following format gammai alphai justification Justif 18 Z Schaub S Btining Artificial Intelligence 106 1998 175 39 Among tumedinto Although compilation steps term formed means j t f ca t 1 procedure compatible3 implications remaining viz A A B v C agd2 y642 D v E treated ordinary wclauses use fact aa42 instance normally o y6s42 new atoms occurring 16 t D A E clause yg D redundant t rule having vs body literals Generally leave contrapositives head ysi contrapositives yad2 A D The contrapositive D E rise particular places ysi Conseq obtained ysd2 A E E t A similar argument shows eliminate contrapositives literals rulebodies having agi rules head CQ Since PTTP supports form obtain 118 t A A B v C In general default single example directly negation normal body furthermore contrapositive wrule having alpha head negation normal form Prereq body alpha Prereq6 See wrule obtained results In proceeding example drules sharing syntactical format given 18 ariginal constituents treated classical way means standard HTTPtechniques default rules pushed wrules In concrete terms generates default rule following intermediate Prolog code not__d lot_e lgamma42 _ e 13 I gamma42 gamma42 42 alpha justificationnot_d alpha 42 3 I notb c From perspective default rule AAIBvC DvE DvE ell rules tell intuitively apply default rule indicated gamma That prove D E gamma prove E prove D gamma Analogously D v E prove use consequent 40 Z Schaub S Briining Artcial Intelligence 106 1998 175 proving rule accounts receive special treatment drule treated standard PITPtechniques notd prerequisite Only Prolog rule subsequently The body Srule comprises term structure ication justif clausal representation term later turned el I containing As mentioned compatible3 membership satisfiability test linear size clause set We refer interested 83 implementation ID E default rules justification subgoal runtime predicate rely Section 5 test taking partial model clause set arguments Recall reader 59 compatible3 setting test forward simplistic implementation The actual details In view details estimate default rules nonatomic consequents m literals obtain default theory including d default rules m x d wrules default m 1 ys body 1 g head d brules default rule number Prolog rules stemming prerequisites case assuming 525 Variables afinite universe treatment word Finally respectively implemented skolemization formula rule implementation sense variables As mentioned treats variables finite Herbrand instances logic allows expressing automated introductory universe regarded considered Although things concisely theorem proving makes Prolog rules rangerestricted inserting unary predicates section current rudimentary ground representative boils propositional This deductive databases enumerating 22 In way inference unbound variable open goal bound ground term furnished unary predicate This allows handle variables default rules Prolog variables avoid generation ground occurring instances 31 The particular justifications occur corresponding restriction impose concerns default rules variables unbound variables violating prerequisite consequent Herbrand universe rangerestrictedness technique known 526 Intermediate Prolog code We given estimate number resulting Prolog rules obtained basic setting Let precise details discussed Consider default theory D W query p negation alphabet E counting 1 propositional negation normal normal form Let m maximal number literals occurring constituent default rule The resulting estimate form let D contain d default rules constituents symbols Let W contain n formulas light refinements formula W given Fig 11 As example consider initial default theory 4 With I 6 n 3 m 3 d 3 60 Prolog clauses worst case estimate Without reduces 48 Prolog clauses This contrasted actual number Prolog rules lemma handling 31 A sortoriented insertion ground terms currently implemented Z Schaub S Briining Artificial Intelligence 106 1998 l75 41 Number Purpose Source nxm 2x1 2x1 2x1 dxm d 1 1 1 wrules reduction rules regularity rules lemma rules rules wrules regularity rule gamma lemma rule gamma query rule I I W D v n d x m d 6 x I 3 WDcp Fig 11 Estimated size Prolog code resulting actual compilation techniques including lemma handling blockwise regularity obtained lemma handling actually 34 testified resulting Prolog code given Fig A2 53 Experimental results case study This secfon gives series experimental results obtained implementation XRay 77 A detailed report experiments implementation details case study illustrating given 2159 83 concentrate main features resulting test series generators So able concentrate utility different features decided series test cases This provided encoding cycle problem default theories advocated 24 32 This encoding focus parameterizable Hamiltonian detailed 59 To begin experimental complemented inferences obtained varying Table 1 taken provides results impact certain features runtime This time behavior number Table 2 focuses compile 59 test series features excluding Table 1 filled items containing time length resulting proof user time33 1000 seconds parentheses An entry like 1000 means proof obtained The test series vary respects leading different columns columns contain results obtained checking existence proof prerequisite seconds comprising time measure compile 32 Actually encoding maps Hamiltonian default logic Section 61 arguably discussed Theorem 61 33 The sum user time necessary underlying biprocessor cycle problem query answering problem variant default logic closest normal default constrained theories 42 I Schaub S Briining Artcial Intelligence 106 1998 l75 Table 1 Runtime experiments Linux BiPentiumPro 200 MHz 256 MB ordering lemma handling Ycorn 1 C orncr c people 008 64 008 50 009 64 008 50 ham_4_min 001 36 00 21 001 36 00 21 ham_4_max 42403 36 1699 21 134 36 05 21 ham_5_min 1000 1000 012 52 006 26 ham_5_max 1000 1000 751 52 166 26 ham_6_min 1000 1000 037 71 015 31 ham_6_max 1000 1000 33053 71 6972 31 ham_7_min han_7_max ham_8_min 1 1000 1000 103 93 025 36 1000 1000 1000 lOoO 2000 2000 1183 118 176 41 ham_8_max 2000 2000 z 2000 2000 ham_lO_min 2000 z 2000 2791 177 538 51 ham_lO_max 2000 2000 2000 2000 ham2 O_min 5000 t 5000 5000 3094 101 ham2 O_max 5000 5000 5000 r5OcKl compatibility default rule subsequently indicated ocorn The order tasks switched This compiler option described 15 Furthermore concerns lemmas set dynamic unit lemmas stemming blockwise regularity checks static lemmas usage dynamic lemmas indicated fZ The configuration extension columns headed corna step columns differ dynamic default consequents All tests constraints knowledge implications For contrast scalable given taxonomic integrity test series place meaningful base comprising 62 formulas default example including rules 40 propositional people disjunctive symbols The test vector obtained querying ternary disjunction tests natural wellstructured prover rarely corrected subsequent defaultspecific examples efficient query answering underlying theorem checks Hence obtained means power choices underlying inference engine representative examples This changes considering Hamiltonian default theory corresponding II identifiers n2 1 defaults 59 details encoding 34 For instance graph n vertices build 3 predicate symbols nodes Let note hamn contains classical formula results cycle problems denote hamn 34 To precise IZ x n 1 n 1 special treatment starting node Z Schaub S Briining Artificial Intelligence 106 1998 175 43 ham1 5 comprising originally 224 default rules intermediate Prolog code provided XRay containing 904 rules 400 kbytes takes 39 seconds including printing Eclipse Prolog cf Table 2 compilation For test series actually constructed selected permutations minimal different column obtained permutations ham_n_min randomly set defaults From problem hamn test series times maximal ham_n_max This witnjesses important influence programming solved time varying 2000 seconds ham_8_max problem instance ham_8 ham_8_min pushed bit 200 permutations The minimum phenomenon In order diminish influence stick PTTPs search blockwise default set ham_8 test vector 35 obtained 005 118 002 41 004 118 002 41 This fixed search strategy imposed underlying Prolog iterative deepening proof regularity guarantees finite search space knowledge base 2 seconds configuration We lemma lemma indicate improve move1 inference ham4 gamma7 andgamma3 31 move2 lemmas reduces Let closer illustrated Figs 12 13 look Table 1 First observe proof length importantly proof In figures ext use time proof The testified fact matter order magni time The impact lemma handling proof partic given red unit reduction unit default repeated sub 21 41 vs t d 4 Fig 12 entirely default lemmas dynamic spent finding der tasks employed tude elapsed ular length withoult use lemmas f au1 t dyn dynamic proofsofgamma4 vstd2 placed Fig 13 corresponding solved proving ext vs td 4 37 Now let turn Table 2 observing application extension respectively 36 In fact observe vstd3 features series compile theories simply tests refrain samples analogous directly issued generator This advantage structure The columns Table 2 indicate lemma configuration time setting Let explain compile source target 007O 11 tells took XRay 7 milliseconds including printing dump Prolog file disk took 4 additional milliseconds compiled Eclipse Prolog The size source target code given number default Prolog rules respectively number resulting bytes For instance source file 863 bytes including table looking line ham_3 The compile compiled Symbol e stands previous time behavior total number inferences text In setting compiled consists 8 default rules source code ham3 impact previous rules consider corresponding permuting considered sample Prolog In contrast move3 35 Such vet tar corresponds 36 A unit inference 37 Since XRay use FTTPs iterative deepening line Table 1 extension inference unit clause search assure shortest proofs 44 Schaub S Briining Artijicial Intelligence 106 1998 175 extquery Iextvstd2 Iextalpha3 Iextvstd4 1 Idefaultgamrna3 I I I I I I I I Iextvstd3 1 Idefaultgamma4 I Iextalpha4 I Iextvstd2 I I I I I I Iunitvstdl Iextvstdtwicel Idefaultgamina7 Iextalpha7 l extvstd3 Iunitvstdl move2 4 vstd4 vstd2 Idefaultgamma7 Iextalpha7 move3 2 vstd2 vstd3 Iextvstd3 Idefaultgamma4 Iextalpha4 movel 3 vstd3 vstdl 1 Iunitvstdl move1 vstdl 31 vstd3 move3 vstd3 2 vstd2 l defaultgamma4 Iextalpha4 move1 3 vstd3 vstd1 Iunitvstdl Idefaultgamrnal5 move4 I vstdtwicel Iextalphal5 vstd4 Iextvstd4 Idefaultgamma3 Iextalpha3 move2 4 vstd4 vstd2 Iextvstd2 Idefaultgamma7 Iextalpha7 move3 Z vstd2 vstd3 Iextvstd3 Idefaultgamma4 Iextalpha4 move1 3 vstd3 vstdl Iunitvstdl Fig 12Prooftree obtained ham4 witboutlemmahandling setting cornu files containing letters A larger difference target sizes viz 11246 11207 obtained switching acorn 40 Prolog rules having 11246 bytes query rule having 442 bytes The slightly different corno variable namings Prolog compiler In fact pretty printer like _g9 894 maps identical single reflected size query code viz 442 versus 512 additional lemma proofs The size query rule interesting variables initial modelclauseset By large observe examples body contains number comprising default rules classical ones factor 14 default Prolog rules 38 In efforts taken overall compilation 8186 bytes replacing variables observed lemma handling tracing 38 The corresponding number bytes insignificant resulting code lengthy strings Z Schaub S Briining Artcial Intelligence 106 1998 I75 45 extquery Iextalpha3 vstd2 move2 4 vstd4 Idefaultgamma7 move3 21 vstd2 l extalpha7 vstd3 Iextvstd3 Idefaultgamma4 movel 31 vstd3 Iextvstd2 Iextvstd 4 1 Idefaultgamma3 I I I I I I I I Iextvstd3 1 Idyn_lemmagamma4 Iextvstd2 1 Idyn_lemmagamma7 Iunitvstdl Iextvstdtwicel I extalpha4 vstdl Iunitvstdl move1 3 vstd3 move3 2 vstd2 defaultgammal5 move4 l vstdtwice1 Iextalphal5 vstd4 extvstd4 Idyn_lemmagamma3 move2 4 vstd4 Fig 13 Proof tree obtained ham4 lemma handling setting corna small despite multiple pass compiling fact measured technique times include printing 39 easing implementation employ finding refinements The columns reflect resulting ones Table 1 help relate runtime behavior The format samples total number given figures substantiate identical extreme mouldings given The column provides inferences performed importance proofs significantly check allows finding preceding compatibility lemmas reduces This smaller number inferences The usage dynamic impressively witnessed ham_4 features lead speedup orders magnitude 80 opposed 323136 inferences Notably features free lemma handling obtainable low compilation adds given configuration single Prolog rule predicate gamma subgoal Srule proof 4o Actually enhancing costs task switching basic approach A signilclcant speedup Hamiltonian cycle problems achieved verifying compatibility complex justifications subsequent assumptions proof search way discard large number putatively So comes guaranteeing constrained justifications compatibility consistency applicable actual Aextension steps In particular case 39 In tbe current implementation actually goovertbe source code 17 timesifall features areenabled 4oWe refrained tbe series tests counting inferences slows theorem prover considerably 46 I Schaub S Briining Artijicial Intelligence IO6 1998 175 Table 2 Compile time experiments Solaris Ultra2S 12 MB Problem Contigu Compile time Source Target Inferences Runtime ration secskecs rulesbytcs rulesbytes sets infers ham3 ocorn 007Q 11 ham3 corna 006009 ham3 ocorn e 008O 11 ham3 corno e 009o 11 8863 8863 8863 8863 4011246 1442 302 007 23 4011207 1442 4113495 1512 4113495 1512 28 83 19 001 23 004 16 00 16 ham4 ocorn OlUO16 151505 6820999 1516 323136 19413 36 hart4 corno 012015 151505 6821079 1516 ham4 acorn e 014017 151505 6925208 I600 ham4 corno e 014019 15 1505 6925354 1600 ham5 corno 021027 2412525 10433730 1590 162 8079 80 369 045 36 851 21 016 21 307 52 ham5 ocorn e 024033 2412525 10541311 1706 14241619 150691 26 ham5 corno f 024103 1 242525 10541307 1706 ham6 corno 033104 354035 14851763 1700 ham6 corno I 038049 354035 14961855 1796 ham7 corno 04806 486131 20072796 1778 ham7 corno 057lO71 486131 20187306 1904 122 712 176 1225 242 058 26 1426 71 177 31 5131 93 467 36 ham8 c omo 069084 638909 2609909 1 1875 1942 15396 118 ham8 corno C 0731092 638909 261120270 11035 320 1052 41 hair9 c omo 09Y116 8012465 328128785 1955 2897 41121 146 ham9 corno C lOY13 80 12465 329158569 11131 410 2208 46 ham1 5 corno 3931452 22458133 904416574 11447 15529 241377 377 ham15 corno 445615256 22458133 905531435 11757 1202 507952 76 ham2 0 corno e 11180284 399138978 16051081161 I2388 2192 296859 101 approach consistency checking The inverse phenomenon incompatible defaults course rest proof search This great advantage incremental albeit observed taxonomic knowledge base largely different significance choices inference engine rarely corrected subsequent check compatibility Another significant given cycle problems lemmas practically harm proof search dynamic restricted viability This testified failing query 4 ham4 yielding test vector 396403 19164 1769 464 format Table 1 We despite usage dynamic failure detected faster influence resolving Hamiltonian lemmas In addition dynamic lemmas 41 A failing query obtained adding f ai 1 tbe end successful query Z Schaub S Briining Artijkial Intelligence 106 1998 l75 41 fact propositional Technically unit lemmas treatable unit clauses application lemma derivation needs replaced derivation step cf Section 523 similar We discussed salient current work includes benchmark cycle problem This problem features XRay means test series settings 25 computation classical default 60 basis parameterizable Hamiltonian like colmputation extensions stable models logic programs Actually semimonotonic problems apply A selection generators resulting test sets 83 test sets coloring problems random graphs initially drawn Stanford GraphBase 46 For complement 83 couple example A discussion examples default logics existing ones aiming aforementioned problem query answering application modelbased scope paper files stemming generators diagnosis set tailored logic 6 Treating general default theories normal default logics For generalizing Up concentrated fragment default theories somewhat greatest approach actually 30 rational check Due treatment consistency concentrate issue keeping common techniques fullfledged default default 1ogic 58 differ way deal consistency modular techniques developed deduction groundedness 55 constrained previous sections This 71 justified like classical developed logics alternatives For implementing semimonotonic fragments aforementioned variants actually turn provide technique general cover The option clearly general Apart fact allows realizing option mix multiple conceptions default logics setting advantage This chosen pursue general approach address variant This undertaking benefits fact theoretical underpinnings 121 contextbased established In approach variant default logic corresponds uniform default reasoning called contextual default logic framework default logics proposed fragment general 61 The general setting contextual default logic As mentioned fullfledged default logics differ basically consistency While classical justified default consistency separately verifying rational default logic global approach stipulating jointly consistent extension hand consistency justification logic employ way address local notion constrained justifications Let illustrate allergic children Assume briefly taking situation frequently encountered inviting kid stayed overnight remember 48 T Schaub S Briining Artcial Intelligence 106 1998 175 eat eggs diet denies milk If consistently eat eggs serve omelette consistently milk serve porridge This represented following default theory assume assume eggs omelette milk porridge I eggs v milk 19 eggs logic provide alternative rational default logic yield single extension containing omelette A While classical justified default porridge constrained extensions containing omelette porridge Because extensions contain assume v milk global approach permit eggs milk case treating separately For brevity justifications results refer reader literature refrain commenting detailed discussion technical intuitive consequences literature shows different approaches In summary formal need distinct notions consistency order obtain different knowledge engineering formal properties need stemming numerous commonsense handled intuitively appealing way 42 demand conception 193035386880 consistency examples arising So order combine variants default logic compromise different notions consistency 121 capture means notion pointwise closure Ths T Definition 61 Let T S sets formulas T S defined If T nonempty pointwise closure T u ThS U WI ET In addition Ths0 ThS Given sets formulas T S T pointwisely closed S iff T ThsT For illustration consider express context witnessing derivation omelette A porridge Theory 19 classical default logic Theggsmilkomeletteporridgeeggs milk 20 This set comprises containing milk taken sets inconsistent yield formula applying deductive closure Such contexts explicit framework provided contextual default logic consistent deductively closed sets formulas containing eggs In approach considers sets formulas set facts W extension E certain context C W 5 E C C The set formulas C established assumptions given justifications consistency rules For familiar facts default consequents applying default underlying 42 Interestingly Reiter anticipated 71 p 831 providing appropriate formal definition ofthis consistency requirement thorniest issue defining logic default reasoning T Schaub S Briining Artcial Intelligence 106 1998 175 49 default aforementioned existing default default logic Y E E 3 A v C constrained default logic conditions Y E E B E case classical logics approach trivially captures application logics y This variety application conditions motivates extended notion default rule 121 contextual default rule S expression form owIoEIoc BCIBEISW Y ow CIE oc c BE 3w y formulas Cprerequisites noted called C E Wjustifications y called lthe consequent contextual default rules obvious way Justify convenience omit tautological identified T W E fereqw6 PrereqES Prereqc PC BE extend sets UsDJustif6 For component noted Justifc S Justify noted ConseqG These projections YW cz oc called nonexisting components JustwG A contextual default theory pair 0 W D set contextual default rules pair E C E closed set formulas We closed set formulas C pointwisely set formulas 43 A contextual extension W consistent deductively quasiiterative characterization contextual extensions Definition 62 Let II W contextual default formulas Define theory let E C sets Eo IW Th W 3 0 d 1 wIQEIc BcIBEIBw ED Wtaw EikaE Citac I Y CYPC EVBE WYBw I Eil ZhW U ConseqA cil WUConsesAiUJusrifcAiJifEi Then E C contextual extension D W ECgEigCi The extension E built successively applying contextual default rules For partial context Cir partial extension Eil united Cjustifications turn Ejustification applying contextual default rules 41 This set united applying contextual default rules consequents introducing 43 Originally Besnard Schaub 12 deal deductively closed set W accord closure E C By compactness actually consider deductively closed premises automated theorem proving purposes 41 To observe TI WUConseqAiUJrifCAiJtifEi hEiUJusfifcAiJUStifi 50 Z Schaub S Briining Artial Intelligence 106 1998 I75 In 121 shown classical justified constrained default logic embedded contextual default rational default logic For brevity exemplarily resulting mappings refer reader 12521 corresponding logic Linke Schaub embeddings 52 extend equivalence results Definition 63 Let D IV default theory We define mD IV 1 y 1 y E D w Classical default logic JDJDLD W aySBAy 1 y E D W Justified default logic Constrained default logic Rational default logic extend These embeddings variants default 19 Delgrande et al 30 constrained cumulative default logic assertions 191 equivalent modulo representation The shown Giordano Martinelli 40 classical Qdefault CAdefault logic 40 Linke Schaub 52 rational logic relying labeled logic 40 respectively formulas For example obtain theory D W given 19 following theories JDLD w omelette 11 omelette eggs A omelette I 11 porridge 1 milk A porridge 1 porridge I eggsv milk 21 1 I eggs A omelette I I I milk A porridge I I DLD w omelette 22 verify JDLD It instructive omelette A porridge DLD W yields omelette porridge This different consistency theory While Cjustification W single contextual distinct extensions eggs A omelette extension containing containing requirements I I eggs A omelette I I omelette consistent extension hand justifications applying default rules Ejustification eggs A omelette I I omelette I eggs A omelette I omelette requires consistency extension This default rules JDL contribute extension D W single extension rule RoLD W engenders distinct T Schaub S Briining Artificial Intelligence 106 1998 175 51 In order capture family default logics described Definition 63 restrict contextual default rules following form 23 As motivated introductory sections approach relies ability forming default proofs local fashion This applied approach normal default theories theories enjoy property semimonotonicity default proofs Analogously contextual default subsets Df D D D E D C D E C contextual extension D W E C D W E C E C G C For contextual extension example theory 0 W semimonotonic relies locally determinable generalization theories 21 22 semimonotonic constrained default justified Actually logic enjoy semimonotonicity Yearly carries corresponding fragments contextual default generality variants default logic Notably logic approach extends immediately allowing treating extends union respective default theories default rules according constrained default justified default logic according logic For classical rational default logic hand restrict semimonotonic appropriate remains future stratification work concrete adaptation techniques determinable Such fragments techniques fragments For furnishing appropriate proof theory provide prooftheoretic characterization contextual extensions presence semimonotonicity Theorem 6l Let D W semimonotonic contextual default theory D s D let E C sets offormulas Then E C contextual extension D W iff maximal D s D enumeration E I 6iiEI thatfor E q Th W U Conseq D C ThmastifcDq WE CD I W II Conseq 60 Si1 I PrereqE Si W J ConseqSo Si UJustifc60 y JustifE jbrkEOi I 24 25 26 It instructive dealing normal default theories matter translation verify specification reduces given Theorem 21 As example consider constrained default logic condition definition C reduces C Th E U Justifc D dealing deductively closed 25 specification E 24 remain definition instantiation 52 Z Schaub S Briining ArtiJcial Intelligence IO6 I998 175 sets Another simplification Ejustifications 45 observed condition 26 absence W U COReqGfJ SiI U JUStifC Sil y COllSefJGj V lJUStifC Si distinguished condition 21 While cf Definition This consistency theories consequents constrained default logic distinctive machinery developed simply replacing manipulation corresponding constrained default logic maintaining set justification actually closely related theories justifications normal default fullfledged default normal default coincide logic In fact way normal default theories consequent y conjunction treatment consistency checking checking fi A y As result address compatibility single model single modelclause In analogy Definition 22 default proof formula q contextual default theory D W finite sequence contextual default rules biier 6i E D E I W U ConseqGi 1 E I I cp conditions 25 26 satisfied derivation p W 6iieI E I Clearly conditions previous sections So groundedness concentrate implementation subsection Siiel treated developed 26 This accomplished condition 62 Generalizing modelbased consistency checking theories W satisfying In sequel extend modelbased approach introduced setting described For normal default model premises presence putatively contradictory Ejustifications compatibility model structures guaranteeing W entail consequents current derivation model Ejustification Observe models covering Ejustifications distinctness Section 4 general furnish single In need complex In fact need models default rules Cjustifications presence contradictory Ejustifications necessarily distinct default conclusions proof hand46 necessary sufficient Let precise sequel For formula 4 set models M write m E M For set semantic M b 4 m t CI m E M M 4 m b 4 formulas S define set models ModS First account counterpart notion pointwise closure cf Definition 61 sets formulas S T define ModsT ET MOS u Ml T PI ModS I 45 To precise Ejustifications 46 This extends actually tautological nonexistent default logics employing Cjustifications constrained default logic T Schaub S Briining Artcial Intelligence 106 1998 175 53 For set formulas W sequence contextual default rules form 23 interested set models ModsT obtained taking S U U Cunseq 1 E I U htifc6i 1 E Z T Jzistif 1 E I For readability abbreviate subset set models MwZ analogy denote m E MwZ 1 m hstifE MZ E I In fact nonempty covers different Ejustification ZUStifE ZUsfifE 8i I E I I MwZ equals UiE MaZ Consider semantic counterpart pointwisely closed set given 20 This set models eggs A milk satisfying milk A eggs actually composed distinct sets model set satisfying actually comply M 12 M 12 12 index set corresponding default rules obtained applying ok default theory 19 Such sets models furnish domain select individual models witnessing compatible application default rules Now order characterize compatible default proofs il set premises subsets M Mw I M fl MaZ 0 E I W consider nonempty use I indicate writing M Cl MwZ property holds Observe underlying model Ejustification Justify subset M Mw 0 ModW guaranteed W assumed consistent sets MaZ nonempty This guarantees nonempty Z existence set M implies M contains In case Z deal non M write M J Mw 0 The nonemptiness structural set inclusion For contextual default rule index set Z K U function V addresses condition mapping format condition trilples form M W SkkE M MwK 26 true yields I condition 26 false 26 Theorem 61 triples VJi5 M W EK M W ir M b y A c m k BE m E M MWI ifMkyrc mtj3EforallmEM M MwK M k y A c m b BE m E M _L M K MwK M b y A PC m b BE m E M 54 I Schaub S Briining Artificial Intelligence 106 1998 l75 discussion M EK MwK sets M absence Ejustifications implies M 0 K 0 consistency Observe Theorem 61 restrict attention W As anticipated amounts singleton approach presented differing associated consequents M contain multiple models dealing inconsistent Ejustifications In worst case dealing IZ pairwisely inconsistent Ejustifications M includes n distinct models Section 4 integration justifications The following result shows approach accord conception consistency expressed Definition 61 Theorem 62 Let W set formulas 6ticI sequence contextual default rules 6i E D E I Then E Z K 0 1 andLO nonempty set models M EL MwL tf set models M CK MwK V6i M W kE M W tE condition 26 true V6i M W kE I iff condition 26 false Observe M M need distinct covering cases V As argued Section 4 provide efficient means supporting model searching For purpose use extended modelclausesets form M compact clausal representation W U COZSfq 1 E I UJUStifcSi 1 E I Mi compact clause sets representing default proof fragment modelclausesetof Also analogy invariantly clauseset 6iiEr 0 W Similar Section 4 start extended form Cw 0 singular set models M m m b W Section 4 coexisting model sets extended modelclausesets coupled satisfiability That model set M extended model M Miil Justif ESi respectively true tautological Ejustifications This trivially observe model like m cover multiple clause sets form Mi jointly consistent M That number involved Ejustifications upper bound number models M yielding Mi 0 It important 1 II The important supported DMEderivations reduction search space models obtained reductions modelclausesets Section 4 appeal continued modelpreserving means lemmas Actually information techniques apply general case pay attention scope applicability This fact share M clause sets form Mi In fact separate treatment instances form M U Mi allow Section 4 straightforward way cost applying techniques developed Z Schuub S Btining ArtQicial Intelligence 106 1998 175 55 Cw70 cw G Wl MO tMl W W M TEG MI OMg EGJGMJI M EII MI JV Obl 6 M M AI EG lMI OMB POsz M My EGsl M ffI6 P06z i16 Fig 14 Governing compatibility deriving OM A PO JDLD W redundancy As consequence allow applying subsumptions restricted current DMEderivation trivially compatible They addable entire extenlded modelclauseset reductions M U Mi M modifications Mi We restrict lemma usage depending default rules involved This reasonable actually highly efficient M allows reductions freely unitreductions resulting Let illustrate verifying compatibility including clause sets like Mi default proof omelette 1 eggs A omelette 1 I I porridge 1 milk A porridge I omelette porridge 61 62 short omelette A porridge JDLD arbitrary model CW model set MO The extended modelclauseset given line Fig 14 Applying rules yields W We start putting CW 0 V MO W 0 Ml V62 WI W I M2 model sets MO Ml M2 given Fig 14 abbreviating milk eggs omelette porridge Ml EG OM PO respectively Ml obtained MO simply extending model model ensures compatible application 61 M2 necessitates generation model satisfying Ejustification Let closer look underlying extended modelclausesets omelettes Cw resulting eggs A omelettes engenders makes add Cjustification justification M reducible However reduce M U M subsumption But alternatives deletion reduction affect clauses Mi This OMs deleted M M following symbol The type reduction reductions indicated step Actually creation M Observe applied following M E 82 Applying 61 56 I Schaub S Briining Artifiial Intelligence 106 1998 175 Cw 0 CW lEG YMI W 0 MO MI 1 MI t Ob EGq Fig 15 Denial compatibility deriving OM A PO CDLD W applying 82 forced generate alternative model Ejustifications 61 82 contradictory This prevent explained Finally model set M2 contains model 44 U M M u M joint application For complement let 11 eggs A omelette 1 1 milk A porridge I omelette porridge illustrated 6 6 short compatible default proof omeletteA porridge cnLD W Fig 15 First observe example The proceeding comprise nontautological secondary clause sets extended modelclauseset allows restrict attention model sets Applying 8 makes add Cjustification singleton Cw eggss A omelettes Ejustifications resulting M obtain singular model set A41 MI OM EGs reduced unitreduction Next underlying DMEderivation makes 8 The model Mt satisfy Cjustification S M check compatibility MI OM EG k Mls A PO Thus look new model testifying explanation For purpose extend modelclauseset resulting immediate performing actual consistency joint compatibility M Applying inconsistency indicates reductions yields clause set clause In case able detect inconsistency Sl 6 8s Cjustification check In terms function V V MO W 0 Ml V6 WI W 6 I Mu Ml given Fig 15 I Schaub S Briining Artificial Intelligence 106 1998 I75 5l generalized For implementing checking extending encapsulated functor m 2 conceive additional means check All follow large approach described datastructure treating notably reusing models possible compatibility detailed 21 83 consistency Section 5 This necessitates modelbased approach 63 Experimental results tests inferences enhancing XRay 77 overall The approach implemented performance discussed follows implementation checking For purpose developed tool 59 build generic contextual default number model generations query theories order able parameterize answering Since deal different sorts justifications study influence different compatibility Section 53 Hence concentrate modelbased consistency interesting approach For abstracting underlying generated default tlhe query fact predicate compatible theories structure As result default rules applied order fixed inferential results proving reusing regenerating model varies test cases This gives constant effort inferencing matter model switches provoked The different number literals set premises model generations extended modelclausesets view fixed application order rules known sear strategy model generator As additional constraint imposed Ejustifications rise different models different Ejustifications achieved reordering pairwisely inconsistent For brevity present exemplary test series taken 59 refer 21 83 series 50 100 fixed number model switches This gives putative reader details default rules contains additionally 50 100 binary clauses respectively provoking models 2O 210 The number effectuated model generations column subsequent default rules having Cjustifications iii C E justifications These cases listed order columns headed DC BE c E furthermore Table 3 The column headed fit BE distinguishes test cases left column model generations originated Cjustifications model generations caused Ejustifications right column Each item contains time measure 47 seconds search space indicated major test cases comprising ii Ejustifications tables We distinguish Note limiting cases given line representing single consecutive ones Also model switches generally model generation expensive presence types justifications This reflected fact encounter higher figures columns Ic BE corresponding ones headed c BE respectively 47 As comprising user time 58 T Schaub S Briining Artificial Intelligence 106 1998 175 Table 3 Experimental results modelbased consistency checking lagaffeunivangersfr HP 71564 I50 1 10 25 50 I BE PC pE loo PC BE kk BE 36 36 26 81 57 76 44 93 80 188 98 191 1 111 94 385 285 25 50 163 663 422 876 466 1321 925 1662 119 313 180 352 100 1027 2607 1356 3304 consistency We observe expensive BE confirmed model switches caused Ejustifications search successful particular That consistency Cjustification immediate search Ejustifications caused Cjustifications This related fact impose stronger concerns consistency constraint needs single model The failure current models Ejustification falsifies Cjustification model warranting involves subsequent witnessed second case specification V verify m F BE models m ultimate failure Since aim provoke model generations consistency test cases recycling Note sole use Cjustifications makes treat turn single different model proof including n default rules involves handling n distinct models pairwise inconsistency Ejustifications Hence case single model generation sole usage Cjustifications individual model clearly maintained The aforementioned primary clause set subject rapidly amortized increasing observed nonartificial model switches indicates detailed experimental number model switches Finally mention Section 53 putative feasibility approach practice A details given 21 Ejustifications easier way n different models reductions These efforts exclusive usage Ejustifications fact Cjustifications analysis implementation like discussed setting consecutive added exception examples provokes better P31 7 Discussion concluding remarks We showed Prolog technology implementing appeal approach systems This accomplished theory Prolog program PO w derivable reasoning PTTP We described default transformed query A particularity allow verifying simplicity restricted arguably simplest fragment default logic supporting approach stems centering validity inference exposition D W query Prolog query query efficient default taken Stickels p D W local proof procedures performed For normal default theories local proof procedures step PDw iff p finite default proof Z Schaub S Briining Artijicial Intelligence 106 1998 175 59 approach applies semimonotonic treatment fullfledged default logics identical theories compatibility general methodology candidate Section 6 Note normal default check In way approach regarded logics prime semimonotonic local proof procedures default logics supporting logic detailed implementing default default compilation From anher perspective shown existing highperformance PTTPbased theorem provers enhanced means handling default information For providing theoretical underpinnings underlying topdown proof procedure based modelelimination We called Default Model Elimination This proof procedure roots approach query answering based connection method This consequent automated logic feature approach resulting As byproduct forward appropriate enhancements known concepts automated lemma handling techniques proposed resulting method default integration classical salient technology overall performance regularity diverse forms performance inference engine techniques particular improving novel default theorem proving theorem proving like blockwise responsible finally view contribution And gramming standard integrating logic pro default negation That logic program clauses cf 56 p t default rules interpretation rn p qi ri atomic formulas propositional disjunction classical qm notrd q1 form 41 A rqrn rlr P Our approach First exlcept literature 525456371 actually experiment resulting default rules different tions given Section 6 n 1 generalization straightforward This allows furthermore nonatolmic investigating logic programming interpreta extensions p qi ri justifications multiple formulas disjunctive different approaches 2177281 inference engine We integrate groundedness approaches like standard normal default existing theorem prover standard underlying consistency generating models Poole proposes prerequisitefree restriction renders implementation underlying hand resulting Theorist handling treatment 69 approach dealing fragment prerequisitefree default rules PTTP serves mainly theorem prover consistency checking failing derivations On advanced regards variable normal default rules restriction groundedness unnecessary incremental subprover based PTTP In addition framework rules abstract methods described Second extensions Reiters default This unavoidable allow local proof procedures This concentrate query answering logics actually apt semimonotonic standard query answering process PTTP logic queries answerable Reiters default entire extension logic lacks semimonotonicity aim primarily computing default arguably rooted 66 2545506381 60 I Schmb S Briining Artiial Intelligence 106 1998j l75 Third consistency checking treated differently instance Reiter 7 l puts forward belated consistency check Schwind Risch 8 l computes entire sets consistent default rules verifies groundedness separately exponential exhaustive restrict computational checks In framework hand crucial task consistency Moreover approach differs aforementioned ones pursuing model compu based treatment consistency checking This novel approach aims minimizing tational efforts reusing models compact representations consistency checks We demonstrated checking efforts ultimately necessary ex benefit keeping models check haustive consistency generation new model aim reusing existing amounts models performing fast linear satisfiability test In Section 4 seen different defaults new model generated The tests consistent application defaults warranted satisfiability On hand demonstrated rigorous application reductions search space Furthermore shown concept default lemmas allows In way achieved syn modelclausesets additional avoidance redundancy ergistic potentially parallel Our handling lemmas systems treatment theorem proving satisfiability socalled nogoods related 29 For instance Sattar Goebel truth maintenance amending Theorist kind lemma consisting literals inconsistency DMEderivation literal derivation rejected prior checking compatibility The integration technique checking assumptionbased 74 use nogoods In setting nogood defaults contains element nogood Sextensionresulting detected previous compatibility remains interesting piece future work use modelclausesets reduction underlying implementation justifications check Whenever correspond recognizing significant inconsistent hypothesis results The extended approach Section 6 provided general default logics supporting variety consistency encompassing query answering implementing accomplished logics Actually default approach allows resulting unique default logics apart capturing diverse fullfledged combine offering simultaneously variants framework checks local proof procedures This existing logics fashion The multiple arbitrary expressiveness default taxonomies artificial examples For finding new models implementation Putnam procedure propositional models Our current experiments meaningful expressing parameterizable course proof search That resulting default proofs contained occasions choosing incompatible rules For instance observed examples model switches This argument check reuses information gathered previous compatibility compatibility uses adapted variant Davis 28 currently fastest complete methods finding precise rules random problems model changed rarely theorem prover cycle problem favor checks examples observed like graph problems Hamiltonian distracting deciding examples Actually current work includes benchmark generators default logics existing ones aiming computation entire query answering semimonotonic tailored 1 Schaub S Briining Artificial Intelligence 106 1998 175 61 reasoning promising On different logic apply On experiments Reiters default pursued avenue implementation In fact credulous 42 sources exponentiality extensions shown families examples current outperforms previous ones rely PTTP order magnitude logic JC propositional default complete reflected extended PTTP inference engine model handling capacities approach orthogonal computing entire extensions For instance DeReS 25 performs graphbased examples cycle problems Similar problem sets feasibly manageable albeit smaller scale performance subject ordering rules default logic program On hand observed rapid answers short proofs taxonomic knowledge bases which1 DeReS collapse like Hamiltonian Interestingly impressively Finally simplest symbols Practically natural questions arise choose PTTP unproblematic instance 91 allows simpler coding extended number generated Prolog rules And alternatives approaches choice regards PTTP For case remark approach Umrigar place PTTP certainly set connectives Pitchumani allow apply compilation techniques For note blowup resulting code linear number clauses default rules space propositional topic problems like future research approaches similar instance 78 correspondingly way Another major avenue future research crossfertilization topdown default reasoning manifested distinction query bottomup approaches In paper relied property answering semimonotonicity 26 aim techniques framework computing extensions stratification 90 particular local fashion carry queryoriented remains interesting generation contrapositives compiled knowledge bases Nonetheless speaking far encountered resulting systems 9 enhanced It interesting local proof procedures computation extensions like splitting obtaining avoiding Acknowledgements We grateful Mark Stickel providing HTTP fruitful discussions stay Darmstadt Great thanks anonymous referees detailed comments This extends Philippe Besnard Pascal Nicolas provided constant valuable feedback Appendix A Compilation results examples For ultimate transparency provide Example 4 Fig Al The resulting Prolog code stemming authentic knowledge base corresponding Prolog code given Fig A2 query separate file order ease prettyprinted 62 T Schaub S Briining Artificial Intelligence 106 1998 175 Filename allergylkb Usage Date xrayallergy1 141196 child predispo notmilk not_predispo allergen icecream child icecream milk icecream milk sugar icecream sugar query allergen Fig Al The knowledge base Example 4 recompilation lemma handling subsequent queries This code obtained compilation These files ones dealing Example 10l 1 retrieved 83 Appendix B Proofs theorems B 1 Proofs theorems Section 2 Proof Theorem 21 This immediate consequence general result expressed inTheorem61 q Proof Theorem 22 The result follows Theorem 21 compactness monotonicity 0 semi B2 Proofs theorems Section 3 For proof Theorem 32 need following lemma Lemma Bl Let W set formulas 61 sequence default rules Then ViEl n W U ConseqG1 Si_l I Prereq B1 iff ViEl n W U PrereqSl Conseq Prereq_1 ConseqSi_l k Prereq B2 I Schaub S Briining Artificial Intelligence 106 1998 l75 63 llerqe_1_2_3_4_5_6_6_1_8 denticalglemberallergen_l fail allergen_1_2_3_4_4_5_5_6_7 identrcal_membernat_allerqen_2 6 ireductionnof_allerqen1_7 aeqe_1_2_3_4_5_6_7_8_9 _6 2_10 6 2 _I1 allerqenLll 8 extensioni allergen 1_121 milkl_11_2_3_4_13_10_14_12_15 Predspo_11_2_3_13_5_14_7_15_9 not_allergen_1_2_3_4_5_6_67_8 identlcal_membernot_allergen_Z fail not_alerqen_1_2_3_4_4_5_5_6_7 identlcal_memberallergen_l 6 reuctlonrllerqe_71 identcal_meernar_chil_2 6 reductionrlot_child I71 child J_2_3_44 5_5_6_7 6 unitl child I71 icecreaml_1_2_3_456_6_8 identical_membericecream_l fail icecrem_1_2_3_44_5_7 identrcal_membernct_icecream_2 6 reductlonot_lcecream_7 lcecream_1_2_3_4_5_6_7_8_9 C6 I_10 _6 1 11 icecreaml_ll 8 Lextensionl icecream ILl21 milkI_1_23_45_6_67_8 identical_membermilk_l fail milk_1_2_3_4_4_55_6_7 identical_membernat_milk_Z _6 Lreductlonnot_milk I71 milk_1_2_3_4_5_6_7_8_9 l6 I_10 6 I 11 milkl_ll 8 iextensionC5 milk1_121 vamma5mi1k_11_2_3_4_510_7_12_9 not_miLk_1_2_3_4_5_6_6_7_8 identlcal_membernatimilk_2 fail not_milk_1_2_3_4_4_5_5_6_7 identcal_membelmllk_l 6 reductlonmlk_71 notJnilk_1_2_3_4_5_6_7_9 6 2_1O 6 2 11 Iot_mllk_Pl 8 Lextension3 not_milk l121 predispoi_1l13_4310_1412_15 n0t_a11ergenl_1_11_313_5_14_7_15_9 redispoL1_2_3_4_5_6_6_7_78 identical_member predispo_l fail xedispo_1_2_3_4_4_5_5_6_7 identical_membernatgredspo_2 6 reductonInotgredispo_7 JredisPo_1_2_34_4_5_5_6_67 6 unit2 SNredispo I71 notqredispo_1_2_3_4_5_6_6_7_6 identical_memberjnotqredispo_2 fail notgredispo_1_2_3_4_4_5_5_6_7 identical_member 6 reductionpredispo l71 not_psedispol_l_2_3_45_6_7_9 predispo_l _6 2_10 6 2 11 not_predispoI_Zl 8 _ Lexteslon3 notgredispol_121 milk_1_11_3_4_13_10_14_12_15 not_allerqen_1_11_3_13_5_14_7_l5_9 suqr_1_2_3_4_5_6_6_7_ identlcalmembersuqar_l fail suvarl_1_2_3_4_4_5_5_5_6_7 ldentcalJnembernot_suqar_Z 6 reductonnot_suqar_71 suvarl23_45_6789 I_6 l_lO 6 l 11 suqar_ll 8 extension6 sugar I121 gaa6suqar_11_2_3_4_5_10_7_12_9 wmna4icecream_1_2_3_4_5_6_7_8_9 6 110 6 1 11 qamma4icecream I31 8 defaultC4 licecreamchild alphallchild I 1_11_4_13_10_7_12_9 compatbleIicecreaml135 amma5milk_1_2_3_4_5_6_7_6_9 icecreamll 1_12 C6 l_lO 6 11 Igamma5mlk I31 8 default5 milkicecream IImllkll 1_121 a1pha5icecream111_11_413_10_7_129 compatiblefImilkll_13_5 amma6suqar_12_34_5_6_78_9 _6 l_lO 6 I 11 qamma6suqar1_31 8 default6 sugaricecream suqarll 1121 alpha6icecream11_11_4_13_10_7_12_9 compatlbleLsvarll_13_5 lhal4chld_1_2_3_456_78_9 _6 I_10 IS 6 1 8 LextenslonIl alphalchild 1_111 16 l_lO 6 _8 extension5 alphal5icecreamF 1_111 icecreamll_3_4_5_0_7_11_9 1 lpha6icecream_l_2_3_4_5_6__8_9 C6 l_lO 6 1 8 extensionC6 alpha6icecream I111 icecreamIllr3r_4r_5_10_7_11_9 queryl_1_2_3_4_5_6 model_initializationlallergenl ichild Lpredispol 5 extension7 query I_Bl allergenll 1_7_9_1_2_3_4_8_6 writegrove1_5_6 111 Fig A2 The Prolog code resulting Example 4 64 T Schaub S Briining Artcial Intelligence I06 1998 175 Proof The onlyif Lemma B I trivial ConseqGj subsumes PrereqGj 1 1 In ConseqGj To prove ifpart follows abbreviate PrfWq Pk COnSeq Ck Since let j arbitrary number WUp1 Cl Pj1 Cj11 k Pj obviously wuplcl PjlCjlPjCjPj9PjlCjl Pil Ci1 k Pi B3 B4 Because ofi pi Cj uj l cj ii cj subsumes pj cj B4 equivalent w u Pl Cl PjlCj13CjPjPjlCjl Pi1 Ci11 I pi But B3 B5 equivalent w u IPl Cl 3Pjl CjltCjPjl CjlPi1CjltPi Applying argumentation j E 1 1 Lemma B 1 q B5 B6 Proof Theorem 32 In follows let D W atomic format D W let CW clausal representation prove theorem default theory D W W Due 79 Theorem 331 sufficient ifpart Let R DMErefutation c q Let D ak yk set Sclauses R In follows di The WYlI Sclause vi abbreviated di Let 6i default corresponding tableau generated R denoted T M topclause MErefutation Sinceforeachi It remains Since c topclause R DMErefutation M know ME sound M viewed restricted Cw U D U c inconsistent l prove Definition 22 conditions k di subsumed vi follows W U 1 yn t cp 2 3 Theorem 21 W U yl yn consistent But steps note Sextension 3 obviously fulfilled guaranteed Condition guaranteed compatibilityrestriction use di derivation possibility To condition application compatible Sextension 2 holds difficult This fact subrefutation R clause dj prove subgoal ai R Sclause di prove oj Hence order bclauses subrefutation use desired order tableau generated R automatically defaults 61 However ordered sequence 6i defaults satisfies condition iterative manner follows 2 constructed step Let TC tl tl tableau clauses T generated aextension steps Let c loi vi element TC maximal depth T Due definition reduction steps reduction step subrefutation Ri ai uses ancestor literal loi Hence subrefutation Ri constitutes refutation ai Further maximal depth c clauses needed Ri lti clauses W Hence W k cxi set ii Z Schaub S Briining ArtQicial Intelligence 106 1998 l75 65 To determine i2 modify R T subrefutation ai R replaced Ri This possible definition reduction step Ri use ancestor goal Now let TC tl tl tableau clauses steps clauses dl di let T generated bextension yi element TC maximal depth T Again c ai constitutes refutation ai Then argumentation subrefutation Ri ai modification R guaranteed Ri uses clauses W dclause di With Lemma B 1 follows W U yi I cti set i2 steps reduction This procedure iterated k times sequence 6i 6i fulfills condition k different clauses 2 completes R The resulting proof ifpart onlyifpart The proof onlyifpart induction number defaults default proof p Let c n 0 jince default proof q uses default rules W F cp Due ME exist MErefutation R CW U c topclause c equals DMEderivation completeness Since shown Section 31 MEderivation dextension steps R DMErefutation n 0 Let 61 sequence default rules default proof DP 40 Note existence DP implies existence default proof DP 40 62 S W U 1 Since DP uses n 1 default rules induction hypothesis tells thal exists corresponding DMErefutation R Cw Cal 1 U y1 c topclause c In follows modify R way resulting DMErefutation R DMErefutation Cw U c topclause c To end use fact exist proof Cal 0 W Hence exists DMErefutation R1 CW U al topclause steps Further open goal assume RI contain extension 1 solved reduction step topclause RI topclause al uses Sextension steps clause al literal 11 Hence clause al Now easy construct R We simply replace tableau clause n tableau clause YY 1 This replacement step unit clause 1 Aextension step Aclause CY goals solved subrefutation corresponds RI corresponding steps R compatible That aextension 3 Theorem 21 fact set extension R equals 1 yn consider construction R given o R replacement extension 1 The resulting open consequence condition literals tableau generated Proof Iheorem 33 Suppose conditions Definition 37 fulfilled Let Mw set ccclauses M MD set Sclauses M let D set defaults corresponding elements MD Then obvious exists DMErefutation R topclause ho uses clauses Mw U MD U hol U U ho extension steps Further E 1 n R restricted use unit clauses hoi steps applied nodes ancestors aresulting nodes note reduction steps D Definition 35 unit clauses needed substitute wextension 66 I Schaub S Briining Artificial Intelligence IO6 1998 l75 reduction steps subrefutation aresulting D This implies Theorem 32 enumeration literal generated Siil D Mw U CheqSl il I fqGi Mw U ConseqS1 Si_I y Conseq B7 038 Now easy recognize E 1 n exists default proof oi M 0 M Mw U hol U U Al U IhlJ U u mdJ u VW This B7 B8 fact Mw u Mo U IUol U u WJJ U GWJ inconsistent corresponding DMErefutation R topclause ioi R exist Hence know exists Furthermore B7 B8 know resulting nodes R prove Sextensionresulting R modification This implies jEl oextensionresulting resulting node literal node successors n Ao extension i1i1 subproofs Sextension nodes generated course R unit clauses hoj steps prove extension Now turn proof Theorem 33 For readability distinguish nodes given theorem attaching prime identifier We Let 7 tableau generated DMEderivation O 0 oh branch 7 CW U Co let b uk wextensionresulting If o marked closed losing soundness nodes 1 G hoL kok b LetkokbeasubsetofvmsuchthatZhooandkok2 kn For simplicity assume m k ui lemma 1 applied earlier course thlderivation leaf node b Due considerations know DMErefutation clause hd uses clauses Mw MD unit clauses hoij R j n extension steps Further unit clauses R prove w extensionresulting This fact bclauses violating consistency applied successors step R literals R dextension conditions theorem literals Sextensionresulting step unit clauses ob Only extension implies replaced corresponding extensionresulting literals Hence b marked closed q reduction step possible o oh o Proof Theorem 34 Since 7 blockwisely 1 condition violate condition 2 Definition 310 First case 7 violates condition regular I Schaub S Briining Articial Intelligence 106 1998 175 61 2 exists DMErefutation condition 2 R generates tableau 7 violate dextension labeled literal Since oj aextension If 7 violates condition 2 7 contains branch b 01 violates condi tion 2 b contains resulting nodes oi oj C j prevoi prevnodej sulting node reduction step applied successor node oj uses ancestor node oj note reduction step applied oj But obvious DMEsubrefutation prevoi The resulting R tableau generated R1 strictly DMErefutation smaller 7 Hence transformation applied finitely times resulting DMErefutation R generates tableau 7 agrees condition applied prevoj R1 strictly smaller applied directly 2 Second case 7 violates condition l exists DMErefutation l let 01 R blockwisely block different nodes oi oj h7 oi Al oj Then let S1 clause set containing regular Suppose 7 violates condition W7olJ ii tableau clause corresponding nodes successors 01 belong iii blocks starting 01 unit clauses A7 ok AT okl Ok generated Sextension 110 node 01 Oki generated Sextension Ok extension nodes steps 1 I Oki successor 01 step closed tableau easy exists MErefutation Since 7 S1 topclause Aol But exists regular MErefutation Rs S1 topclause h7ol Let DS subderivation derivation oclause That derivation initialization contains steps Rs use clauses M note clauses DS hTokr steps 01 R removed The resulting derivation D1 labeled steps unit clauses subrefutation tableau open goal derivation D2 contains h7 01 Now apply DS open goals belonging generates open goal The step extension steps unit clauses h7ok Rz R follows derivation steps Rs belong Now construct applied k701 Rs extension DMErefutation resulting liter frOn1 h7OkI Ok h7 a7 Ok h7okl applied DMEsubrefutation 1 I applied oki R applied open goals labeled open goals Finally A7 2 This transformation Note thalt tableau 72 generated resulting DMErefutation R2 steps steps use literals case literal L 72 violate condition reduction steps literals stemming Sclauses remain unchanged stems bclause ancestor holds 7 72 violate condition literal L stems dclause 2 affects wextension wclauses guaranteed In particular Inference However R2 longer R 72 contain blocks 7 violate blockwise regularity However easy transformation applied finitely times To end observe maximal number ml blocks Since m 1 finite maximal branch increase transformation 68 I Schaub S Briining Artcial Intelligence 106 1998 175 number literals clause finite maximal number rn2 blocks tableau applied m2 times limited fix constant Hence transformation Afterwards regular tableau resulting DMErefutation 7 R generate blockwisely 13 B3 Proofs theorems Sections 4 6 Proof Theorem 41 Let W set formulas Siiel sequence normal default rules Consider 6i E I By definition V V m W CSjljd m W ajji iff m model W U ConseqSj 1 j This includes m model W U ConseqGo Si1 definition V m b Conseq case m m And V m W Sjji l iff model W U ConseqGj 1 j cases We distinguish 1 W U ConseqSo This equivalent equivalent I W U ConseqSo tf lCOKWqGi Si y 1 By propositional logic existence model m m W U COSeqGj 1 j proves claim 2 W U ConseqGo SiI I COKXq This equivalent equivalent establishes nonexistence 0 claim W U ConseqSo 8 k 1 By propositional model W U ConseqGj logic I j Proof Theorem 61 ifpart Let E C contextual extension semimonotonic contextual default theory D W Consider set generating contextual default rules The case r 0 trivial concentrate nonempty r according 12 Theorem 511 r satisfies 24 That E TtE ThW U Conseqr C C ThwuconseqruJustifCr hfEr BlO Bll 039 Condition contextual extension 29 groundedness verified r definition For ensuring condition 26 observe Justifc 0 JustifEr 0 provided r 0 We PC 4 ThWUconseqrUJustifcr JuStifE m I Schuub S Briining Artcial Intelligence IO6 1998 175 69 PC E Zustifc r That Or W U ConseqF UhstCF U BE C BE E ZustifE f By PC E Justifc r W U Conseqr U Justifcr y BE BE E JustifEF By monotonicity establkhing condition Finally suppose r 26 maximal Then r 2 r property holds subset r 2 r loI BCIBEI crr Y satisfying conditions 25 26 Condition 25 implies 01 E E Moreover W U Conseq I U Justifc f y BE E E JudfE manipulations BE E monotonicity Consequently I The fact r satisfies condition 24 yields inversing Ic 4 C previous nonderivability proposition lo1 kIBEI Er Y contradiction onlyifpart Let SiieZ enumeration maximal D g D satisfying conditions Consider 2426 sequence default theories Sj E D I j W E Z family pairs sets formulas Ei Ciir Ei ThW U ConseqGj E D I j Ci ThEiJustifcsjEoljiJustifEISi E D I j I With define r I loI kkIbi Y ED JEEEiTBCCiTIBEEi By constructionof Ei Ciil TieZ EJEi CUCi UI iei id ieZ E C defined 24 r defined B9 7Q I Schaub S Briining Artificial Intelligence IO6 1998 175 We prove induction I Eit Cit extension Sj E D 1 j W 6j E D j 6 C I1 E I From follows semimonotonicity E C contextual extension D W Clearly TzW Thw0 equivalently Now suppose extension 0 W TzW ZW Ei Ci extension Sj E D I j W 6j E D 1 j C E C Sj E D j W contextual extension c By semimonotonicity Ei s E Ci C C Depending si IUI BCISEI Y contributes E C consider cases We E Ei C Ci UE E PC E C BE E E Because W s Ei C E Sj E D I j s c c E C BE E E 26 According imply cz E E 23 W U ConSeqSu Si UJkStif Si IfB Si 3 E JudfE60 By fact E Ei ThW U ConseqGj E D I j monotonicity deduce BE E recall 3 JustifE Rewriting order yields statement reverse nonderivability DC 6 WUCe4SGiUJusrifc606iJtifEIO t I Ic E Justif definition C monotonicity This contradiction assumption PC C recall PC JUstifcSi E Ei C Ci 60 6i As case E BE obtain appeal l We E Eil C Cil SO ay E E PC C BE 4 E Eil Cil contextual extension Sj E D I j W This implies 6j E D I j c fit We shown E C contextual extension D W By maximality D contextual default rule 6 E D D violates 25 26 This disqualifies E C E c E C C C 6 contribute obtainable semimonotonicity Hence E C contextual extension contextual extension DW q Proof Theorem 62 Let W set formulas 6iiel sequence contextual default rules Si E D E I Consider 6i Ia1 kIBEI Y E I K 0 1 L 0 By definition V V3 MT WT BkkK M W3 ZlL I Schub S Briining Artijicial Intelligence 106 1998 l75 71 iff al nonempty M M assumption M MwK set models M 5 MwL This comprises case M G lJkEKMW MnMkK0 forallkEK Because M I y A c k E K MKmIWUC onseqK U JustifcK U Justify m 1 m W U ConseqL UJustifL U Justify ML m b PIE m E M gives recalling BE Justif E MnMK0 Hence M nonempty set models M LL Mw L And V M W WY 1 iff set models M M LL MwL This follows fact M Mw K satisfying y A 3c including m m b BE In analogy 1 Condition Proof 41 consider 26 true That cases distinguish cases W U ConseqSo 8i U JUdfcSo tfJtifSk k E 0 Or equivalently W U ConseqGo U JuGifc60 Si U hdfEfik y _L k E 0 By propositional logic equivalent existence model mk mk W U ConseqGo Sj U Justifc60 U JustifE k E 0 Defining M U kEoimk establishes 26 false That 2 Condition claim W U ConseqGo U JUstifcSo 8i k dLYtifk k E 0 Or equivalently W U ConseqGo Si U JUstifcGo Si U JUStifESk E I k E 0 logic By propositional satisfying equivalent nonexistence model ink ink W U Conseq8o U Justifc60 Sj U Justify forsomekEOi In words ML 0 k E 0 That set models M satisfying M EL MwL k E 0 q M f ML 0 12 T Schmb S Briining Artificial Intelligence 106 1998 I75 References l H AitKaci Warrens Abstract Machine A Tutorial Reconstruction MIT Press Cambridge MA 1991 2 G Amati L Aiello D Gabbay F Pirri A proof theoretical approach default reasoning I Tableaux default logic J Logic Comput 6 2 1996 205231 3 K Apt H Blair A Walker Towards theory declarative knowledge J Minker Ed Foundations Deductive Databases Logic Programming Morgan Kaufmann San Mateo CA 1987 Chapter 2 pp 89148 4 0 Astrachan M Stickel Caching lemmaizing model elimination theorem provers D Kapur Intelligence Vol 607 Ed Proceedings Conference Automated Deduction Lecture Notes Artificial Springer Berlin 1992 pp 224238 5 E Baader B Hollunder Embedding defaults terminological knowledge representation formalisms B Nebel C Rich W Swartout Knowledge Representation 6 A Baker M Ginsberg A theorem prover prioritized circumscription Reasoning Cambridge MA October 1992 pp 306317 Proceedings International Joint Eds Proceedings 3rd International Conference Principles Conference Artificial Intelligence IJCAI89 Detroit MI 1989 pp 463467 7 P Baumgartner U Furbach Model ehmination contrapositives Conference Automated Deduction Lecture Notes Artificial 1994 pp 87101 A Bundy Ed Proceedings Intelligence Vol 814 Springer Berlin 8 P Baumgartner U Furbach Model elimination contrapositives application PTTP Preprints Tableaux94 1994 9 P Baumgartner U Furbach PROTEIN PROver Theory Extension A Bundy Ed Proceedings Conference Automated Deduction Lecture Notes Artificial Intelligence Vol 814 Springer Berlin 1994 pp 769773 INterface lo JL Bell M Machover A Course Mathematical Logic NorthHolland Amsterdam ll R BenEliyahu R Dechter Default logic constraints logic propositional 1977 Proceedings AAAI National Conference Artificial Intelligence AAAI91 Anaheim CA MIT Press 1991 pp 37385 12 P Besnard T Schaub An approach contextbased default reasoning Fundamenta Informaticae 23 24 1995 175223 131 P Besnard R Quiniou P Quinton A theoremprover AAAI National Conference Artificial Intelligence decidable subset default logic Proceedings AAAI83 Washington DC 1983 pp 2730 14 W Bibel S Brtining U Egly T Rath KoMeT A Bundy Ed Proceedings Conference Automated Deduction Lecture Notes Artificial Intelligence Vol 84 Springer Berlin 1994 pp 783787 15 W Bibel Automated Theorem Proving 2nd ed Vieweg Braunschweig 16 P Bonatti N Olivetti A sequent calculus skeptical default logic Proceedings Tableaux97 Lecture 1987 Notes Artificial Intelligence Vol 1227 Springer Berlin 1997 pp 107121 17 P Bonatti Proof systems default autoepistemic Eds Proceedings Tableaux96 Lecture Notes Artificial P Miglioli U Moscato D Mundici Intelligence Vol 1071 Springer logic M Omaghi Berlin 1996 pp 127142 18 S Brass Deduction supernormal defaults P Schmitt G Brewka K Jantke Eds Nonmonotonic Inductive Logic Springer Berlin 1991 pp 153174 19 G Brewka Cumulative default logic defense nonmonotonic inference rules Artificial Intelligence 50 2 1991 183205 20 S Brilning T Schaub A modelbased approach Eds Proceedings 9th International Symposium Methodologies Artificial Intelligence Vol 1079 Springer Berlin 1996 pp 315324 consistencychecking Z Ras M Michalewicz Intelligent Systems Lecture Notes 21 S Brtining T Linke P Nicolas T Schaub Prolog technology XRay Technical Report Institute Informatics University Potsdam 1998 This extended version 59 Full version preparation 22 S Ceri G Gottlob L Tanca Logic Programming 23 CL Chang RCT Lee Symbolic Logic Mechanical Theorem Proving Academic Press New York Databases Springer Berlin 1990 default reasoning implementation 1973 24 P Cholewiriski V Marek A Mikitiuk M Truszczyriski Experimenting nomnonotonic reasoning Proceedings International Conference Logic Programming MIT Press Cambridge MA 1995 7 Schaub S Briining Artificial Intelligence 106 1998 l75 73 25 P Cholewiriski V Marek M Truszczydski Default reasoning tional Conference Principles Knowledge Representation Mateo CA 1996 DeReS Proceedings 5th Intema Reasoning Morgan Kaufmann San 26 P Cholewifiski Reasoning stratified default theories Nonmonotonic Reasoning 1995 Logic Programming Proceedings 3rd International Conference 27 W Clocksin C Mellish Programming 28 M Davis H Putnam A computing procedure Prolog Springer Berlin 1981 quantification theory Journal ACM 7 1960 201 215 29 J Kleer An assumptionbased 30 J Delgranh T Schaub W Jackson Alternative approaches truth maintenance Artificial Intelligence 28 1986 163196 default logic Artificial Intelligence 70 l2 1994 lr237 31 E Eder Relative Complexities FirstOrder Calculi Vieweg Braunschweig 32 H Enderton A Mathematical Introduction J Crawford Towards 33 D Etherton Logic Academic Press New York 1972 reasoning efficient default 1992 Proceedings AAAI National Conference Artificial Intelligence AAAI96 Portland OR 1996 pp 627632 search algorithms PhD Thesis University 34 JW Freeman Pennsylvania propositional Improvements 1995 J Mengin Default logic unified view Computational satisfiability 35 C Froidevaux 36 D Gabbay C Hogger J Robinson Eds Handbook Logic Programming Oxford University Press Oxford 1994 circumscriptive 37 M Gelfond V Lifschitz Compiling theories Proceedings AAAI National Conference Artificial Kaufmann San Mateo CA 1988 pp 455459 Intelligence Intelligence 10 3 1994 331369 Logic Intelligence Artificial logic programs report AAAI88 St Paul MN Morgan preliminary 38 M Gelfortd V Lifschitz H Przymusinska M Truszczyiiski Disjunctive defaults J Allen R Fiies Eds Proceedings 2nd International Conference Principles Knowledge Represen E Sandewall tation Reasoning Cambridge MA Morgan Kaufmann San Matco CA 1991 pp 230237 39 M Ginsberg A circumscriptive 40 L Giordano A Martinelli On cumulative default logics Artificial Intelligence 66 1 1994 161179 41 C Goller R Letz K Mayr J Schumann SETHEO V32 recent developments theorem prover Artificial Intelligence 39 1989 209230 A Bundy Ed Intelligence Vol 814 Proceedings Conference Springer Berlin 1994 pp 778782 Automated Deduction Lecture Notes Artificial 42 G Gottlob Complexity 43 N Helft K Inoue D Poole Extracting results nomnonotonic l428 Mita Minatoku Tokyo 108 Japan University British Columbia Vancouver BC Canada V6T lW5 December 1989 ICOT Technical Memorandum No 855 ICOT Research Center circumscription answers logics J Logic Comput 2 3 1992 397425 44 T Hoppe Incremental Partial Deduction Dissertationen zur Kiinstlichen Intelligenz Vol Diski 97 Infix 1995 45 U Junker K Konolige Computing Proceedings AAAI National Conference Artificial Intelligence 283 extensions autoepistemic default logic TMS AAAI90 Boston MA 1990 pp 278 46 D Knuth The Stanford GraphBase A Platform Combinatorial Computing AddisonWesley Reading MA 1993 47 R Letz S Bayerl J Schumann W Bibel SETHEO highperformance theorem prover J Automat Reason 8 2 1992 183212 48 R Letz K Mayr C Goller Controlled J Automat Reason 13 3 1994 297338 integrations cut rule connection tableau calculi 49 R Letz Fistorder calculi proof procedures automated deduction PhD Thesis Technische Hochschule Darmstadt Fachbereich Informatik 1993 50 F Ly Computing extensions default theories Conference Symbolic Quantitative Approaches Vol 548 Springer Berlin 1991 pp 219226 R Kruse P Siegel Eds Proceedings European Uncertainty Lecture Notes Computer Science 51 T Linke T Schaub Lemma handling default logic theorem provers C Froidevaux J Kohlas Eds Proceedings European Conference Symbolic Quantitative Approaches Lecture Notes Artificial Intelligence Vol 946 Springer Berlin 1995 pp 285292 Reasoning Uncertainty 74 Z Schaub S Brtining Artcial Intelligence 106 1998 I75 52 T Linke T Schaub Towards classification default logics J Appl NonClassical Logics 7 4 1997 39745 1 53 D Loveland Automated Theorem Proving A Logical Basis NorthHolland Amsterdam 54 D Loveland Mechanical 55 W Lukaszewicz Considerations theorem proving model elimination Journal ACM 15 1986 23625 1 Intelligence 4 alternative approach Computational default logican 1978 1988 116 56 W Marek M Truszczyiiski Nonmonotonic Logic ContextDependent Reasoning Artificial Intelligence Springer Berlin 1993 57 W Marek M Truszczyriski Normal form results default logics Inductive Logic Lecture Notes Artificial G Brewka K Jantke P Schmitt Intelligence Vol 659 Springer Eds Nomnonotonic Berlin 1993 pp 153174 58 A Mikitiuk M Truszczyriski Rational default Eds Proceedings logic disjunctive 2nd International Workshop Logic Programming logic programming A Nerode Nonmonotonic L Pereira Reasoning MIT Press Cambridge MA 1993 pp 283299 59 I Nicolas T Schaub The XRay implementation platform local query answering default Information Systems A Hunter S Parsons Eds Applications logics Lecture Notes Artificial Intelligence Springer Berlin 1998 Uncertainty Formalisms 60 I Niemell P Simons Evaluating algorithm Implementations Workshop Applications 1995 pp 6672 default reasoning Working Notes IJCAI95 Nonmonotonic Reasoning Systems Montreal Quebec 61 I Niemell Decision procedure autoepistemic logic Proceedings Ninth International Conference Automated Deduction Argonne IL 1988 pp 675684 62 I Niemell A decision method nonmonotonic J Doyle reasoning based autocpistemic Eds Proceedings 4th International Conference Principles Knowledge reasoning 63 I Niemela Towards efficient default Reasoning Bonn Germany Morgan Kaufmann San Mateo CA 1994 pp 473484 C Mellish Joint IJCAI95 Montreal Quebec Morgan Kaufmann San Mateo CA Ed Proceedings International reasoning P Torasso E Sandewall Representation Conference Artificial 1995 pp 312318 Intelligence 64 D Poole R Goebel R Aleliunas Theorist logical reasoning N Cercone G McCalla Springer New York 1987 Chapter 13 pp 331352 Eds The Knowledge Frontier Essays defaults diagnosis Representation Knowledge 65 D Poole A Theorist Prolog Compiler Logic Programming Computer Science University Waterloo October 1987 Artificial Intelligence Group Department 66 D Poole Variables hypotheses Proceedings International Joint Conference Artificial Intelligence IJCAI87 Milan Italy Morgan Kaufmann San Mateo CA 1987 pp 905908 default reasoning Artificial Intelligence 36 1988 2747 67 D Poole A logical framework 68 D Poole What lottery paradox R Reiter Eds Proceedings Reasoning Toronto Ontario Morgan Kaufmann San Mateo CA 1989 pp 333340 tells default R Brachman H Levesque reasoning 1st International Conference Principles Knowledge Representation 69 D Poole Compiling default reasoning Prolog New Generation Computing 9 1 1991 338 70 T Przymusinski An algorithm 71 R Reiter A logic default reasoning Artificial 72 V Risch Analytic 73 A Rothschild Algorithmische tableaux default logics J Appl NonClassical Logics 6 1 1996 7188 compute circumscription Artificial Intelligence 38 1 1989 4973 zu Defaultlogiken Diplomarbeit Intelligence 13 l2 FG Intellektik FB 1980 81132 Untersuchungen Informatik TH Darmstadt Germany 1993 74 A Sattar R Goebel Using crucial literals select better theories Computational Intelligence 7 1 1991 1 l22 75 T Schaub S Brtining Prolog technology Conference Artificial Intelligence default reasoning W Wahlster Ed Proceedings European ECAI96 Wiley New York 1996 pp 105109 76 T Schaub P Nicolas An implementation theoretical Z Ras A Skowron Eds Proceedings 10th International Symposium Methodologies underpinnings Intelligent Systems Lecture Notes Artificial Intelligence Springer Berlin 1997 query answering default platform logics 77 T Schaub S Brtining P Nicolas XRay Prolog technology theorem prover default reasoning J Slaney Eds Proceedings Conference Automated Deduction Lecture description Notes Artificial Intelligence Vol 1104 Springer Berlin 1996 pp 293297 M McRobbie T Schaub S Briining Artificial Intelligence 106 1998 175 15 78 T Schaub On constrained default Intelligence Artificial 79 T Schaub A new methodology theories B Neumann Ed Proceedings European Conference ECAI92 Vienna Austria Wiley New York 1992 pp 304308 default logics structureoriented query answering theorem proving J Automat Reason 15 1 lY95 95165 80 T Schaub The family default logics D Gabbay P Smets Eds Handbook Defeasible Reasoning Uncertainty Management Systems Vol 2 Oxford University Press Oxford 1998 Chapter 5 81 C Schwirtd V Risch Tableaubased characterization theorem proving default logic J Automat Reason 13 1994 223242 82 C Schwirtd A tableauxbased theorem prover decidable subset defauit logic M Stickel Ed Proceedings Conference Automated Deduction Springer Berlin 1990 83 XRay An implementation platform local query answering default logics URL http www _ haiticsunipotsdamdexray1998 84 R Shostak Refutation graphs Artificial Intelligence 7 1976 5 l64 85 J Slaney SCCYTT modelguided theorem prover Proceedings Artificial ntelligence IJCAI93 Chamby France 1993 pp 109114 International Joint Conference 86 M Stickel A Prolog technology 87 M Stickel A Prolog technology theorem prover New Generation Computing 2 1984 371383 theorem prover new exposition implementation Institute SRI Menlo Park CA 1989 Prolog Technical Report Technical Note 464 Stanford Research 88 M Stickel A Prolog technology theorem prover M Stickel Ed Proceedings Conference Automated Deduction Lecture Notes Artificial Intelligence Vol 449 Springer Berlin 1990 pp 673674 89 M Thielscher T Schaub Default reasoning deductive planning J Automat Reason 15 1 1995 l10 Intelligence 90 H Turner Splitting default theory Proceedings AAAI National Conference Artificial AAAI96 Portland OR 1996 pp 64545 1 91 Z Umrigar V Pitchumaui An experiment programming firstorder logic IEEE 1985 Symposium Logic Programming Boston MA 1985 pp 447