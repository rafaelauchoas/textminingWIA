Artiﬁcial Intelligence 136 2002 189213 wwwelseviercomlocateartint Ordered binary decision diagrams knowledgebases Takashi Horiyama Toshihide Ibaraki b Graduate School Information Science Nara Institute Science Technology Nara 6300101 Japan b Department Applied Mathematics Physics Graduate School Informatics Kyoto University Kyoto 6068501 Japan Received 28 April 2000 received revised form 22 November 2001 Abstract We consider use ordered binary decision diagrams OBDDs means realizing knowledgebases view point space requirement OBDDbased representation efﬁcient suitable cases compared traditional CNF based andor modelbased representations We present polynomial time algorithms problems testing given OBDD represents unate Boolean function testing represents Horn function 2002 Published Elsevier Science BV Keywords Knowledge representation Automated reasoning Ordered binary decision diagrams OBDDs Recognition problems Unate functions Horn functions 1 Introduction Logical formulae traditional means representing knowledge artiﬁcial intelligence AI 24 However known deduction knowledgebase consists set propositional clauses coNPcomplete abduction cid2p 2 com plete 12 Recently alternative way representing knowledge subset models called characteristic models proposed 171820 21 By restricting knowledgebase Horn deduction modelbased approach performed linear time abduction performed polynomial time 17 Corresponding author Email addresses horiyamaisaistnaraacjp T Horiyama ibarakiikyotouacjp T Ibaraki 0004370202 matter 2002 Published Elsevier Science BV PII S 0 0 0 4 3 7 0 2 0 2 0 0 1 1 9 4 190 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 In addition favorable properties computational complexity approach good evaluation practical sense 1819 In paper propose knowledge representation use ordered binary decision diagrams OBDDs 1425 An OBDD directed acyclic graph representing Boolean function considered variant decision tree By restricting order variable appearances sharing isomorphic subgraphs OBDDs following useful properties 1 When ordering variables speciﬁed OBDD unique reduced canonical form Boolean function 2 Many Boolean functions appearing practice compactly represented 3 When OBDD given satisﬁability tautology represented function easily checked constant time 4 There efﬁcient algorithms Boolean operations OBDDs As result properties OBDDs widely practical applications especially computeraided design veriﬁcation digital systems 6727 One notable advantages OBDDs practical sense minimization DNFs CNFs considerably faster approaches 8 These observations encourage use OBDDs knowledgebases The manipulation knowledgebases OBDDs deduction abduction ﬁrst discussed Madre Coudert 23 We ﬁrst compare representations formulabased modelbased OBDDbased basis sizes This foundation analyzing comparing time space complexities operations Comparisons representations attempted different communities In AI community shown formulabased modelbased representations incomparable respect space requirement 17 Namely allows exponentially smaller sizes depending functions In theoretical science VLSI design communities pointed formulabased OBDDbased representations incomparable 14 However representations compared ground We paper cases OBDD based representation requires exponentially smaller space cases requires exponentially smaller space OBDD Thus OBDDs ﬁnd place knowledgebases We point unfortunate result exists Horn function requires exponential size representations OBDDs known efﬁcient knowledgebase operations deduction abduction 23 Given OBDDs knowledgebase deductive query decided polynomial time query consequence knowledge knowledge general Boolean function 23 As abduction polynomial time algorithm Horn knowledgebases introducing constraints assumption set remains NPcomplete general case 15 By restricting knowledgebase Horn OBDDs translated CNFs characteristic models respectively polynomial time speciﬁcally output T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 191 polynomial time vice versa 16 Since negative function Horn technique applied unate OBDD changing polarities variables variables negative We investigate paper fundamental recognition problems OBDDs testing given OBDD represents unate Boolean function testing represents Horn function We recognition problems solved polynomial time unate Horn cases We encounter problems knowledgebase representing realworld phenomenon required unate Horn hypothesis posed phenomenon andor investigation mechanism causing phenomenon For example knowledgebase represents data set test results physical measurements body temperature blood pressure number pulses case diagnosis certain disease monotonically depending test result The dependency unate property tests negative polarity Also AI common assume Horn knowledgebases processed efﬁciently respects example deduction set Horn clauses linear time 10 These recognition problems play fundamental role area learning identifying meaningful structures empirical data 91329 We emphasize OBDDbased approach suitable tasks structure identiﬁcation discussed 9 ﬁnding effective representations 41229 devising decompositions database schema 2230 synthesizing simple Boolean expressions 3 11 casting logical theories render subsequent processing tractable 1526 The rest paper organized follows The section gives fundamental deﬁnitions concepts We compare representations Section 3 consider problems recognizing unate Horn OBDDs Sections 4 5 respectively 2 Preliminaries 21 Notations fundamental concepts We consider Boolean function f 0 1n 0 1 An assignment vector 0 1n ith coordinate denoted ai A model f satisfying assignment f f 1 theory Σf representing f set models f Given b 0 1n denote cid1 b usual bitwise componentwise ordering assignments ai cid1 bi 1 2 n 0 1 Given subset E 1 2 n equals 1 E 0 χ E denotes characteristic vector E ith coordinate χ E E Let x1 x2 xn n variables f xi corresponds ith coordinate assignments evaluates 0 1 Negation variable xi denoted xi Variables negations called literals A clause disjunction literals conjunction clauses called conjunctive normal form CNF We f represented CNF ϕ f ϕa holds 0 1n Any Boolean function represented CNF unique 192 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 We distinction function f theory Σf CNF ϕ represents f confusion arises We deﬁne restriction f replacing variable xi constant ai 0 1 denote f xi ai Namely f xi ai x1 xn f x1 xi1 ai xi1 xn holds Restriction applied variables We deﬁne f cid1 g respectively f g Σf Σg respectively Σf Σg Lemma 21 Relation cid1 following properties 1 f cid1 g holds f xi ai 2 f g cid1 h holds f cid1 h g cid1 h hold cid1 gxi ai holds ai 0 1 For assignment p 0 1n deﬁne cid1p b bit p cid1 b bit p holds bit denotes bitwise componentwise exclusiveor operation A Boolean function f unate polarity p f cid1 f b holds assignments b cid1p b A theory Σ unate Σ represents unate function A clause unate po larity p pi 0 positive literals xi pi 1 negative literals xi clause A CNF unate polarity p contains unate clauses polarity p It known theory Σ unate Σ represented unate CNF A unate function positive respectively negative polarity 00 0 respectively 11 1 A theory Σ Horn Σ closed operation bit bit b bitwise AND models b 0 1n For example 0011 b 0101 bit b 0001 The closure theory Σ respect bit denoted Clbit Σ deﬁned smallest set contains Σ closed bit We use operation bit set operation Σf bit Σg b bit c holds b Σf c Σg We denote Σf bit Σg f bit g convenience Note functions f g f bit g different A Boolean function f Horn Σf Horn equivalently f bit f f holds sets models A clause Horn number positive literals CNF Horn contains Horn clauses It known theory Σ Horn Σ represented Horn CNF By deﬁnition negative function Horn conversely For Horn theory Σ model Σ called characteristic produced bitwise AND models Σ Clbit Σ The set characteristic models Horn theory Σ characteristic set Σ denoted CharΣ Note Horn theory Σ unique characteristic set CharΣ satisﬁes Clbit CharΣ Σ The set minimal models f respect p 0 1n deﬁned minpf cid1 Σf exists b Σf satisfying b p cid2 b p denotes b cid1p b cid17 hold The following lemma gives upper bound size cardinality characteristic set T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 193 Lemma 22 21 Let f Horn function n variables Then characteristic set minpf Bn χ Eni 0 1 n χ Eni f size characteristic vector set Eni 0 1 n given pBn cid3 cid4 En0 1 2 n Eni En0 0 χ En0 11 1 1 2 n 22 Ordered binary decision diagrams An ordered binary decision diagram OBDD directed acyclic graph represents Boolean function It sink nodes 0 1 called 0node 1node respectively called constant nodes Other nodes called variable nodes variable node v labeled variables x1 x2 xn Let varv denote label node v Each variable node exactly outgoing edges called 0edge 1edge respectively One variable nodes unique source node called root node Let X x1 x2 xn denote set n variables A variable ordering total ordering xπ1 xπ2 xπn associated OBDD π permutation 1 2 n 1 2 n The level1 node v denoted levelv deﬁned label node v label xπi levelv deﬁned n 1 That root node level n label xπ1 nodes level n 1 label xπ2 The level constant nodes deﬁned 0 On path root node constant node OBDD variable appears decreasing order levels Every node v OBDD represents Boolean function fv deﬁned subgraph consisting edges nodes reachable v If node v constant node fv equals label If node v variable node fv deﬁned varvf0succv varvf1succv Shannons expansion 0succv 1succv respectively denote nodes pointed 0edge 1edge node v The function f represented OBDD represented root node Fig 1 illustrates OBDDs representing x3x2 x1 variable ordering x3 x2 x1 Given assignment value f determined following corresponding path root node constant node following manner variable node v outgoing edges selected according assignment avarv variable varv The value function label ﬁnal constant node When nodes u v OBDD represent function levels called equivalent A node 0edge 1edge point node called redundant An OBDD called dense variable node v satisfy level0succv level1succv levelv 1 paths root node constant nodes visit n 1 nodes A dense OBDD equivalent nodes quasireduced An OBDD mutually equivalent nodes redundant nodes reduced The OBDDs b c Fig 1 dense quasireduced reduced respectively A reduced OBDD obtained quasireduced OBDD deleting redundant nodes v changing incoming edges e u v u 0succv 1 This deﬁnition level different common use 194 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 Fig 1 OBDDs representing x3x2 x1 In following assume OBDDs reduced stated The size OBDD number nodes OBDD Given function f variable ordering reduced OBDD unique minimum size OBDDs variable ordering The minimum sizes OBDDs representing given Boolean function depends variable orderings 4 Given OBDD represents f OBDDs f xi 0 f xi 1 obtained Of time f denotes size OBDD f 2 The size increase restriction Given OBDDs representing f g applying fundamental logic operators f g f g f g f g performed Of g time property f cid1 g checked Of g time 4 A partition f pair sets L R satisfying L R X x1 x2 xn L R X L R L called left partition R called right partition Let l denote assignment variables L r denote assignment variables R Then l r denotes complete assignment obtained combining l r Let Xcid21 subset X ω positive number satisfying 0 ω 1 Then partition L R called ωbalanced Xcid21 satisﬁes cid22ωXcid21cid23 cid1 Xcid21 L cid1 cid24ωXcid21cid25 Given partition L R set A assignments li L r R 1 2 h called fooling set satisﬁes 1 f li r 2 f li r j cid17 f lj r cid17 cid17 j 0 1 The lemma tells size h fooling set gives lower bound size OBDD represents f Lemma 23 52 Let f Boolean function n variables Xcid21 subset variables ω positive number satisfying 0 ω 1 If f fooling set size h ωbalanced partition L R Xcid21 size OBDD representing f h variable ordering 2 Although original lemma Lemma 2 5 states case h cn constant c 1 proof applied h straightforward manner T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 195 3 Three approaches knowledgebase representation In section compare knowledgebase representations CNFbased model based OBDDbased It known CNFbased modelbased representations play orthogonal roles respect space requirement Namely allows exponentially smaller sizes depending functions We OBDDbased representation incomparable sense We start relations OBDD CNF representations Lemma 31 There exists negative theory n variables OBDD CNF require size On characteristic set requires size 2n2 Proof Consider function mcid5 fA x2i1 x2i i1 n 2m The size CNF obviously On The characteristic set given 0 12m exactly a2i1 a2i 0 1 2 m size 2n2 17 The OBDD representing fA illustrated Fig 2 variable ordering xn xn1 x1 The size OBDD On Lemma 32 There exists negative theory n variables OBDD requires size On characteristic set requires size On2 CNF requires size 2n2 Fig 2 OBDD representing fA cid6 m i1 x2i1 x2i 196 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 Fig 3 OBDD representing fB cid7 m i1 x2i1 x2i Proof Consider function mcid8 fB x2i1 x2i cid5 r 1 r2 r m i1 r1r2rmSB n 2m SB r1 r2 rm ri x2i1 x2i 1 2 m fB dual fA The smallest CNF representation fB given 2n2 clauses The characteristic set χ 122mS 0 12m S 2i 1 2i S 2i 1 2i j 1 2 m j cid17 2i 1 2i 1 2 2m size On2 17 The OBDD representing fB illustrated Fig 3 variable ordering xn xn1 x1 Note fB dual fA OBDD obtained negating input variables exchanging roles 0edges 1edges negating output exchanging roles 0node 1node OBDD Fig 2 The size OBDD On By combining Lemmas 31 32 theory OBDD exponentially smaller characteristic set CNF representations Theorem 31 There exists negative theory n variables OBDD requires size On characteristic set CNF require sizes 2n4 Proof Consider function cid9 cid10 cid9 fC x2i1 x2i mcid5 i1 cid10 x2i1 x2i 2mcid8 im1 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 197 Fig 4 OBDD representing fC cid6 m i1 x2i1 x2i cid7 2m im1 x2i1 x2i n 4m As shown Lemma 31 characteristic set requires size 2n4 represent ﬁrst half Also Lemma 32 CNF representation requires size 2n4 represent second half Note ﬁrst second halves independent variables ﬁrst half appear second half vice versa Therefore lower bounds characteristic set CNF valid fC An OBDD represents fC illustrated Fig 4 variable ordering xn xn1 x1 The size OBDD On We turn opposite direction CNF characteristic set exponentially smaller size OBDD Lemma 33 The size characteristic set On following Horn function n variables xij 1 cid1 j cid1 m 1 n m 12 fD cid9 m1cid5 i1 cid9 xim1 cid10cid10 cid9 xij mcid8 j 1 m1cid5 j 1 cid9 xm1j cid10cid10 xij mcid8 i1 198 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 Proof Consider χ En0 χ Enij 1 cid1 j cid1 m 1 set Bn deﬁned Lemma 22 convenience En0 j 1 cid1 j cid1 m1 Enij set En0 j corresponding variable xij fDχ En0 1 holds characteristic vector χ En0 Thus minχ En0 fD 1 Similarly minχ Enij fD 1 holds 1 2 m j 1 2 m fDχ Enij 1 Next fDχ Enim1 0 implied cid10 cid9 mcid8 xim1 xij cid11 χ Enim1 cid12 0 j 1 cid7 1 2 m enumerate minimal models χ Enim1 By deﬁnition obtain χ En0 ﬂipping m 1th coordinate χ Enim1 This χ En0 minimal model χ Enim1 fDχ En0 1 When m 1th coordinate ﬁxed 0 clause xim1 xij satisﬁed ﬂipping j th coordinates j 1 2 m However j th coordinates ﬂipped corresponding vector minimal Thus minχ Enim1 fD m1 1 2 m Similarly minχ Enm1j fD m 1 j 1 2 m m j 1 We enumerate minimal models χ Enm1m1 fDχ Enm1m1 0 We obtain χ En0 ﬂipping m 1 m 1th coordinate When m 1 m 1th coordinate ﬁxed 0 minimal models obtained ﬂipping exactly m 1th coordinates 1 2 m exactly m 1 j th coordinates j 1 2 m Thus minχ Enm1m1 fD m2 1 In total minafD Om2 On By Lemma 22 means size characteristic set fD On aBn cid3 Lemma 34 28 Let f Boolean function n variables xij 1 cid1 j cid1 m n m2 Then partition L R satisfying L R n2 following properties holds 1 There m 2 different satisfying xi1 xi2 xim L cid17 2 There m 2 different j s satisfying x1j x2j xmj L cid17 xi1 xi2 xim R cid17 x1j x2j xmj R cid17 Lemma 35 The size OBDD representing following negative function fE n variables xij 1 cid1 j cid1 m n m2 2m cid10cid10 2 variable ordering cid10cid10 cid9 cid9 cid9 cid9 mcid5 mcid8 mcid5 mcid8 fE xij xij i1 j 1 j 1 i1 Proof We prove Lemma 23 Section 22 Let consider set Xcid21 Lemma 23 given set variables ω 12 Then balanced partition L R assuming case 1 Lemma 34 loss generality 2 different satisfying xi1 xi2 xim L cid17 xi1 xi2 xim m T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 199 R cid17 We select m variables xiklk assignment satisﬁes following restrictions L xikrk 2 I i1 i2 im For ik I select R We construct set A assignments 2 1 For ik I xik lk xik rk assigned 0 1 1 0 2 For ik I variables xik1 xik2 xikm xiklk xikrk 3 Other variables assigned 0 assigned 1 The size set A 2m assignment satisfying h ik I h satisﬁes 0 cid1 h 2m 2 m 2 2 choices restriction 1 Let lh r h denote cid3 ak k1 ak 2k1 xiklk ak 0 1 xik rk cid7 cid7 m i1 Next fElh r hcid21 m fElh r h 1 h Since xiklk xikrk assigned 0 j 1 ik I For ik I xi1 xi2 xim assigned 0 Also Now prove set A fooling set deﬁned Lemma 23 First xikj 1 holds cid7 xij 1 xij 1 holds j 1 2 m Thus fElh r h 1 h 0 holds h hcid21 Since h hcid21 exists By restriction 1 xikrk Therefore xiklk xikrk assigned 1 xikj 0 holds This proves A fooling set 2 balanced partition lemma variable xiklk assigned 1 lh r h 0 lhcid21 r hcid21 assigned 0 lh r h 1 lhcid21 r hcid21 assignment lh r hcid21 Since size fooling set 2m follows Lemma 23 implying m j 1 m j 1 cid7 Theorem 32 There exists Horn theory n variables CNF characteristic set require sizes On size smallest OBDD representation 2 2 n Proof Consider function fD Lemma 33 As stated Lemma 33 size characteristic set On Also size CNF obviously On The function fE Lemma 35 obtained restricting x1m1 xmm1 xm11 xm1m xm1m1 fD 0 Since size OBDD increase restriction size 2 smallest OBDD fD 2 n The results representations dominate Therefore OBDDs ﬁnd place knowledgebases represent theories efﬁciently Unfortunately combining Theorems 31 32 construct following function exponential representations Corollary 31 There exists Horn function n variables characteristic set CNF require sizes 2n8 size smallest OBDD representation 2 n2 Proof Consider conjunction fC fD fC respectively fD deﬁned proof Theorem 31 respectively Theorem 32 Note fC fD n2 200 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 variables share variables Then similarly case Theorem 31 stated lower bounds representations easily obtained 4 Checking unateness OBDDs In section discuss problem checking given OBDD represents unate function We assume loss generality variable ordering xn xn1 x1 The following wellknown property indicates problem solved polynomial time Property 41 Let f Boolean function n variables x1 x2 xn Then f unate polarity p p1 p2 pn f xi0 cid1 f xi1 pi 0 respectively f xi0 cid2 f xi 1 pi 1 holds 1 2 n As noted Section 22 OBDD representing f xi 0 respectively f xi 1 obtained Of time OBDD representing f f denotes size The size increase restriction f xi0 f xi1 Since property g cid1 h checked Og h time unateness f checked Onf 2 time checking conditions f xi 0 cid1 f xi 1 f xi0 cid2 f xi 1 1 2 n The following wellknown property useful reduce computation time Property 42 Let f Boolean function n variables x1 x2 xn Then f unate polarity p p1 p2 pn f xn0 f xn1 unate polarity p1 p2 pn1 ii pn 0 implies f xn0 cid1 f xn1 pn 1 implies f xn0 cid2 f xn1 The unateness functions f xn0 f xn1 checked applying Property 42 recursively check additional condition f xn0 f xn1 polarity Our algorithm similar implementation OBDDmanipulation systems Bryant 4 sense cache intermediate computational results avoid duplicate computation In Bryants idea different computational results stored memory order handle different operations computation repeated However algorithm aims checking unateness avoid cache conﬂict explicitly preparing memory result This key reduce computation time We check unateness f bottomup manner checking unateness nodes corresponding intermediate results Note property f xn0 cid1 f xn1 respectively f xn0 cid2 f xn1 checked bottomup manner g cid1 h holds gxi 0 cid1 hxi 0 gxi 1 cid1 hxi 1 hold Algorithm CHECKUNATE Fig 5 checks unateness polarity given OBDD manner described We use array p denote polarity f respect x level element stores 0 1 checked We use twodimensional array impu v denote fu cid1 fv holds element stores YES NO checked In Step 2 unateness polarity T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 201 Algorithm CHECKUNATE Input An OBDD representing f variable ordering xn xn1 x1 Output yes polarity f unate Step 1 initialize Set pi 1 2 n cid13 impu v fu fv 1 0 NO YES fu fv 0 0 0 1 1 1 1 Step 2 check unateness level compute p For node v level labeled x apply Steps 21 22 Step 21 Set pol 0 imp0succv 1succv YES holds set pol 1 imp1succv 0succv YES holds output halt Step 22 If p set p pol If p cid17 p cid17 pol hold output halt Step 3 compute imp level For pair nodes u v u v ordered pair levelu cid1 levelv cid1 levelu levelv equal set impu v YES imp0suss imp1suss Step 4 iterate If n n level root node output yes polarity p p1 p2 pn halt Otherwise set 1 return Step 2 cid21v YES set impu v NO cid21u 0succ cid21u 1succ cid21v Fig 5 Algorithm CHECKUNATE check unateness OBDD speciﬁed p checked nodes level More precisely unateness checked Step 21 consistency polarities checked Step 22 In Step 3 impu v computed functions fu fv levels The unateness check fv Step 21 easily f0succv fvx0 f1succv fvx1 checked unate polarity imp0succv 1succv imp1succv 0succv computed previous iteration Note constant functions 0 1 considered unate The polarity fv respect x level temporarily stored pol step In Step 22 polarity consistency x checked comparing polarity node v pol p If p v ﬁrst node checked level store pol p Otherwise pol checked p output consistent Note CHECKUNATE outputs p nodes level f depend x In Step 3 comparison fu fv performed easily comparisons fuxa fvxa 0 1 completed Here use convention 0succcid21v respectively 1succcid21v denotes 0succv respectively 1succv levelv denotes v levelv This fvx0 f0succv fvx1 f1succv hold levelv fvx0 fvx1 fv holds levelv Note fu fv holds u v node After Step 3 know impu v pairs nodes u v 202 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 Fig 6 OBDD representing fF x1x2 x2 x3 x3x1 levelu cid1 levelv cid1 We store results needed Example 41 Consider OBDD fF x1x2 x2 x3 x3x1 variable ordering x3 x2 x1 As shown Fig 6 OBDD 6 nodes v1 v2 v6 respectively represent following functions fv1 fv2 fv3 fv4 fv5 fv6 0 1 x1 x1x2 x1 x2 x1x2 x2 x3 x3x1 Algorithm CHECKUNATE starts initializing step Here pi 1 2 n impv1 v1 impv1 v2 impv2 v2 YES impv2 v1 NO 1 In rest example pay attention imp s evaluated YES In Step 2 ﬁrst iteration p1 0 v3 unique node level 1 imp0succv3 1succv3 impv1 v2 YES holds In Step 3 ﬁrst iteration impv1 v3 impv3 v3 impv3 v2 YES conﬁrmed implication 0 cid1 x1 cid1 x1 cid1 1 In computa tion impv1 v3 0succcid21v1 1succcid21v1 interpreted node v1 0succcid21v3 1succcid21v3 interpreted 0succv3 v1 1succv3 v2 respectively In second iteration level 2 p2 0 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 203 imp0succv4 1succv4 impv1 v3 YES imp0succv5 1succv5 impv3 v2 YES We impv1 v4 impv1 v5 impv3 v5 impv4 v2 impv4 v3 impv4 v4 impv4 v5 impv5 v2 impv5 v5 YES In iteration level 3 p3 1 imp1succv6 0succv6 impv4 v5 YES Then Algorithm CHECKUNATE outputs answer yes polarity p 0 0 1 fF Now consider computation time algorithm In Step 2 computation node v performed constant time data computed previous Step 3 Thus total time Step 2 Of In Step 3 comparison fu fv pair u v performed constant time The number pairs compared f 2 Of 2 requires Of 2 time Step 3 entire computation O The time rest computation minor Theorem 41 Given OBDD representing Boolean function f checking f unate Of 2 time f size given OBDD If start Algorithm CHECKUNATE initial condition pi 0 respectively pi 1 1 2 n check positivity respectively negativity f This f positive respectively negative polarities nodes 0 respectively 1 Corollary 41 Given OBDD representing Boolean function f checking f positive respectively negative Of 2 time f size given OBDD As stated necessary compute impu vs pairs u v nodes The following theorem gives unfortunate instance requires computation impu vs f 2 pairs Theorem 42 There exists OBDD positive function f requires check f 2 impu vs f size given OBDD Proof Consider function fG n 3m 1 variables deﬁned fG x3m1fm x3m1gm cid4 fi gi cid4 x2mi fi1xmi1 0 xmigi1 xmi1 0 1 2 m 0 1 2 m 0 The OBDDs fi gi illustrated Figs 7a b respectively As shown Fig 8 OBDD fG 4m 2 nodes 204 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 Fig 7 OBDDs representing fi x2mi fi1xmi1 b gi xmi gi1 xmi1 Fig 8 OBDD representing fG x3m1fm x3m1gm T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 205 The upper bound Of 2 obvious Theorem 41 Now order prove lower bound fG requires check m2 imp s Since fm gm positive functions Algorithm CHECKUNATE executes iterations Steps 2 4 initial level 1 level 3m In level 3m 1 order obtain result p3m 1 YES Step 2 necessary property fm cid1 gm By applying Lemma 21 recursively property fm cid1 gm conﬁrmed checking properties f cid21 cid1 gm 1 2 m f cid21 k1 xk Similarly property f cid21 cid1 gm conﬁrmed cid7 checking properties f cid21 j j 1 2 m gcid21 cid1 gcid21 j k1 xk Therefore cid1 gcid21 need check f cid21 j 1 2 m j 1 2 m m2 imp s cid6 j 5 Checking Horn property OBDDs In section discuss problem checking given OBDD represents Horn function After examining condition Horn property subsection algorithm given Section 52 51 Conditions Horn property We assume loss generality variable ordering xn xn1 x1 Denoting f xn0 f xn1 f0 f1 simplicity f given f xnf0 xnf1 f0 f1 Boolean functions n 1 variables x1 x2 xn1 By deﬁnition determine f Horn checking condition f bit f f For ﬁrst construct OBDD f bit f check equivalence f bit f f However following theorem says check require exponential time intractable general Theorem 51 There exists Boolean function f n variables OBDD requires size On2 OBDD representing f bit f requires 2n4 variable ordering Proof Consider function 2mcid8 fH fi i1 fi gi xi2m cid14 cid5 cid15 xj 2m 1 2 2m cid4 j 122mi m 1 m 2 2m xim xi xi xim 1 2 m gi n 4m We ﬁrst prove upper bound size OBDD fH We assume variable ordering x4m x4m1 x1 fH rewritten 206 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 fH h2m cid4 hi xi2m 0 cid11 gi cid11cid6 j 12i1 xj 2m cid12cid12 xi2mhi1 1 2 2m 0 Shannons expansion The OBDD hi 1 2 2m root node labeled xi2m 1edge 0edge pointing OBDD hi xi2m1 hi xi2m0 respectively Thus size OBDD hi following upper bound hi cid1 hi xi2m1 hixi2m0 1 cid15cid16 cid16 cid16 cid16 hi1 1 j 12i1 xj 2m cid16 cid16 cid16 cid16gi cid6 cid14 hi denotes size OBDD hi Since gi j 12i1 xj 2m AND n negative literals size OBDD On By deﬁnition h0 0 means size OBDD h0 1 By induction fH h2m cid1 On h2m1 1 cid1 O2mn h0 2m cid6 Namely upper bound On2 cid6 m i1 gi Now consider second theorem lower bound fH bit fH First identity fH bit fH fH g considering models g cid7 xj 2m Let b c models fH By deﬁnition b respectively c model fk respectively f k respectively k 1 2 2m Then cases 1 k 2 k cid17 In case 1 fk Horn b bit c model fk In case 2 model b satisﬁes 2m j 1 bk bkcid21 0 bj 2m 0 kcid21 denotes k m k 1 2 m denotes k m k m 1 m 2 2m Similarly model c satisﬁes j 1 2 2m k bk2m 1 c ccid21 0 c2m 1 cj 2m 0 j 1 2 2m Thus k cid17 implies b bit c satisﬁes following restrictions ak akcid21 acid21 0 aj 2m 0 j 1 2 2m This means model g By considering cases ΣfH bit fH ΣfH Σg ΣfH g 1 On hand let model g Then form b bit c b c satisfy following restrictions bk2m 1 ck3m 1 bj aj cj aj j 1 2 4m k 2m j 1 2 4m k 3m By deﬁnition satisﬁes ak akm 0 k 1 2 m aj 2m 0 j 1 2 2m Since b c models fH Σg ΣfH bit fH Also deﬁnition bitwise AND operation implies ΣfH ΣfH bit fH Thus ΣfH g ΣfH bit fH 2 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 207 cid7 The size OBDD By combining 1 2 identity fH bit fH fH g m i1 gi m i1 xi xim known 2m variable ordering x2m x2m1 x1 4 function obtained fE bit fE restricting x4m x4m1 x2m1 0 Since size increase restriction size OBDD fE bit fE 2n4 cid7 Our main result shows condition f bit f f checked polynomial time explicitly constructing OBDD f bit f For goal following lemmas tell key property problem divided subproblems solved divideandconquer approach Lemma 51 Let f Boolean function n variables x1 x2 xn ex panded f xnf0 xnf1 Then f Horn f0 f1 Horn f0 bit f1 cid1 f0 holds Proof We ﬁrst prove onlyifpart Let b c models f b c identical Then deﬁnition Horn function b bit c model f By considering nth bits bn cn models b c loss generality following cases 1 Both 0s b bcid21 0 c ccid21 0 bcid21 bn concatenation bcid21 0 1n1 bn 2 Both 1s b bcid21 1 c ccid21 1 3 One 0 1 b bcid21 0 c ccid21 1 Case 1 implies bcid21 0 bit ccid21 0 acid21 0 Namely models bcid21 ccid21 f0 bcid21 bit ccid21 model f0 By deﬁnition says f0 Horn Similarly case 2 implies f1 Horn Finally case 3 implies bcid21 0 bit ccid21 1 acid21 0 Namely models bcid21 f0 ccid21 f1 bcid21 bit ccid21 models f0 Thus property Σf0 bit Σf1 Σf0 f0 bit f1 cid1 f0 Now proof ifpart trivial For models b c f cases 1 2 3 holds In case 1 respectively case 2 f0 respectively f1 Horn acid21 0 bcid21 0 bit ccid21 0 respectively acid21 1 bcid21 1 bit ccid21 1 model f In case 3 f0 bit f1 cid1 f0 holds acid21 0 bcid21 0 bit ccid21 1 model f Since b bit c model f deﬁnition f Horn The Horn property f0 f1 checked applying Lemma 51 recursively The following lemma says condition f0 bit f1 cid1 f0 Lemma 51 checked recursively Lemma 52 Let f g h Boolean functions n variables expanded f xnf0 xnf1 g xng0 xng1 h xnh0 xnh1 respectively Then property f bit g cid1 h holds f0 bit g0 cid1 h0 f0 bit g1 cid1 h0 f1 bit g0 cid1 h0 f1 bit g1 cid1 h1 hold 208 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 Proof The identity cid11 f bit g xn f0 bit g0 f0 bit g1 f1 bit g0 cid12 xnf1 bit g1 3 proved manner similar Lemma 51 considering models Then f bit g cid1 h holds f bit gxn0 f0 bit g0 f0 bit g1 f1 bit g0 cid1 hxn0 h0 f bit gxn1 f1 bit g1 cid1 hxn1 h1 hold lemma follows Lemma 212 Note condition type f bit g cid1 f Lemma 51 requires check condition type f1 bit g0 cid1 f0 checking type f bit g cid1 h functions f g h The condition checked recursively Lemma 52 52 Algorithm check Horn property Algorithm CHECKHORN Fig 9 checks Horn property given OBDD bottomup manner applying Lemmas 51 52 recursively The bottomup caching techniques similar CHECKUNATE However emphasize case unateness naive algorithm check condition Property 41 polynomial time naive algorithm check condition Lemma 51 require exponential time Theorem 51 This CHECKHORN ﬁrst polynomial time algorithm possible Lemmas 51 52 In Algorithm CHECKHORN use array hornv denote node v represents Horn function threedimensional array bitimpu v w denote fu bit fv cid1 fw holds Each element arrays stores YES NO Algorithm CHECKHORN Input An OBDD representing f variable ordering xn xn1 x1 Output yes f Horn Step 1 initialize Set cid4 hornv YES v constant node 0 1 cid13 bitimpu v w fu fv fw 1 1 0 NO YES fu fv fw 0 1 fu fv fw cid17 1 1 0 1 Step 2 check Horn property level For node v level labeled x set hornv YES horn0succv horn1succv bitimp0succv 1succv 0succv YES output halt Step 3 compute bitimp level For triple u v w nodes levelu cid1 levelv cid1 levelw cid1 levelu levelv levelw equal check fu bit fv cid1 fw holds according Fig 10 Set result YES NO bitimpu v w Step 4 iterate If n output yes halt Otherwise set 1 return Step 2 Fig 9 Algorithm CHECKHORN check Horn property OBDD T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 209 YES bitimp1succ cid21v 0succ 0succ bitimp1succ cid21v 1succ cid21u 1succ cid21w bitimp0succ cid21u 0succ cid21v 0succ cid21w bitimp0succ cid21v 0succ cid21u 1succ cid21u cid21w cid21w YES NO Fig 10 Checking bitimpu v w fu bit fv cid1 fw triple nodes u v w Step 3 Algorithm CHECKHORN checked hornv YES says fv Horn bitimpu v w YES says fu bit fv cid1 fw holds We note given OBDD reduced condition fu bit fv cid1 fw checked functions different levels case functions considered lmax variables x1 x2 xlmax lmax denotes maximum level nodes u v w In Step 2 Algorithm CHECKHORN hornv v easily computed according Lemma 51 Note node v satisﬁes fvxlevelv0 f0succv fvxlevelv1 f1succv Also note horn0succv horn1succv bitimp0 succv 1succv 0succv computed previous iterations Similarly bitimpu v w Step 3 triple u v w computed easily Fig 10 corresponds Lemma 52 Similar case checking unateness 0succcid21v respectively 1succcid21v denotes 0succv respectively 1succv levelv denotes v levelv Upon completing Step 3 results triples u v w nodes levelu cid1 levelv cid1 levelw cid1 These contain information required iteration needed Example 51 Consider OBDD fI x3 x2 x1 x3 x2 x3 x1 variable ordering x3 x2 x1 As shown Fig 11 OBDD 7 nodes v1 v2 v7 respectively represent following functions fv1 fv2 fv3 fv4 fv5 fv6 fv7 1 0 x1 x1 x2 x1 x2x1 x3 x2 x1 x3 x2 x3 x1 Algorithm CHECKHORN starts initializing step hornv1 hornv2 YES hornvi 3 4 7 bitimpv1 v1 v2 NO bitimpvi vj vk YES triples vi vj vk v1 v23 v1 v1 v2 1 210 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 Fig 11 OBDD representing fI x3 x2 x1 x3 x2 x3 x1 In rest example pay attention bitimp s needed following computation In Step 2 ﬁrst iteration hornv3 hornv4 YES hornv1 hornv2 YES bitimpv1 v2 v1 bitimpv2 v1 v2 YES hold In Step 3 ﬁrst iteration bitimpv1 v3 v1 YES conﬁrmed property 1 bit x1 0 1 bit 1 0 1 1 We property bitimpv2 v4 v2 bitimpv3 v2 v1 bitimpv3 v4 v3 bitimpv1 v4 v1 YES In second iteration level 2 hornv5 hornv6 YES properties hornv1 hornv2 hornv3 hornv4 YES bitimpv1 v3 v1 bitimpv2 v4 v2 YES hold We property bitimpv5 v6 v5 YES bitimpv3 v4 v3 bitimpv1 v2 v1 bitimpv1 v4 v1 bitimpv3 v2 v1 YES Note bitimpv3 v2 v1 example general property checking condition type f bit g cid1 f Lemma 51 requires checking condition type f bit g cid1 h In iteration level 3 hornv7 YES properties hornv5 hornv6 YES bitimpv5 v6 v5 YES hold Then Algorithm CHECKHORN outputs answer yes halts T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 211 Now consider computation time Algorithm CHECKHORN In Step 2 hornv node v computed constant time Thus total time Step 2 Of In Step 3 bitimpu v w triple u v w computed constant time The number triples checked Step 3 entire computation Of 3 The time rest computation minor Theorem 52 Given OBDD representing Boolean function f checking f Horn Of 3 time f size given OBDD As stated necessary compute bitimpu v ws triples u v w nodes The following theorem gives unfortunate instance requires computation bitimpu v ws f 3 triples Theorem 53 There exists OBDD Horn function f requires check f 3 bitimpu v ws f size given OBDD Proof By argument similar Theorem 42 prove theorem Consider function fJ n 6m 2 variables deﬁned fJ x6m2g0 x6m2g1 g0 x6m1hAm x6m1hBm g1 x6m1hCm x6m10 cid4 hAi hBi hCi cid4 cid4 x3mi hAi1 x3mi1 xm1 x1 0 1 2 m 0 x4mi hBi1 x2mi1 0 1 2 m 0 x5mi hCi1 xmi1 0 1 2 m 0 The OBDD fJ 6m 6 nodes The upper bound Of 3 obvious Theorem 52 We fJ requires check m3 bitimp s proves lower bound Since hAm hBm hCm negative functions Horn functions Algorithm CHECKHORN executes iterations Steps 2 4 initial level 1 level 6m In level 6m 1 order obtain result g0 bit g1 cid1 g0 Step 3 necessary property hBm bit hCm cid1 hAm Note property g0 bit g1 cid1 g0 checking Horn property fJ By Lemma 52 g0 bit g1 cid1 g0 holds hAm bit hCm cid1 hAm hAm bit 0 cid1 hAm hBm bit hCm cid1 hAm hBm bit 0 cid1 hBm 212 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 hold In order conﬁrm hBm bit hCm cid1 hAm need check hcid21 triples j k 1 2 m3 bit hcid21 Cj cid1 hcid21 Ak Bi hcid21 Ai x2mk xm1 x1 hcid21 Bi cid10 cid9 icid5 k1 icid5 k1 xmk hcid21 Ci icid5 k1 xk Thus necessary check m3 bitimp s 6 Conclusion In paper considered use OBDDs represent knowledgebases We shown conventional CNFbased modelbased representations new OBDD representation mutually incomparable respect space requirement Thus OBDDs ﬁnd place knowledgebases represent theories efﬁciently We considered problem recognizing given OBDD represents unate Boolean function represents Horn function It turned checking unateness quadratic time respect size OBDD checking Horn property cubic time OBDDs dominatingly ﬁeld computeraided design veriﬁcation digital systems The reason Boolean functions encounter practice compactly represented operations OBDDs efﬁciently performed We believe OBDDs useful manipulating knowledge bases Developing efﬁcient algorithms knowledgebase operations deduction abduction addressed work Acknowledgement The authors like thank Professor Endre Boros Rutgers University valuable comments This research partially supported Scientiﬁc GrantinAid Ministry Education Culture Sports Science Technology Japan References 1 SB Akers Binary decision diagrams IEEE Trans Comput C27 1978 509516 2 KS Brace RL Rundell RE Bryant Efﬁcient implementation BDD package Proc ACMIEEE Design Automation Conference Orlando FL 1990 pp 4045 3 RK Brayton GD Hachtel AL SangiovanniVincentelli Multilevel logic synthesis Proc IEEE 78 2 1990 264300 4 RE Bryant Graphbased algorithms Boolean function manipulation IEEE Trans Comput C35 1986 677691 5 RE Bryant On complexity VLSI implementations graph representations Boolean functions application integer multiplication IEEE Trans Comput 40 1991 205213 T Horiyama T Ibaraki Artiﬁcial Intelligence 136 2002 189213 213 6 P Buch A Narayan AR Newton A SangiovanniVincentelli Logic synthesis large pass transistor circuits Proc IEEEACM International Conference Computer Aided Design San Jose CA 1997 pp 663670 7 JR Burch EM Clarke KL McMillan DL Dill Sequential circuit veriﬁcation symbolic model checking Proc ACMIEEE Design Automation Conference Orlando FL 1990 pp 4651 8 O Coudert Doing twolevel logic minimization 100 times faster Proc ACMSIAM Symposium Discrete Algorithms San Francisco CA 1995 pp 112118 9 R Dechter J Pearl Structure identiﬁcation relational data Artiﬁcial Intelligence 58 1992 237270 10 WF Dowling JH Gallier Linear time algorithms testing satisﬁability Horn formula J Logic Programming 3 1984 267284 11 R Drechsler N Drechsler W Günther Fast exact minimization BDDs Proc ACMIEEE Design Automation Conference San Francisco CA 1998 pp 200205 12 T Eiter G Gottlob The complexity logicbased abduction J ACM 42 1995 342 13 C Glymour R Scheines P Spirtes K Kelly Discovering Causal Structure Academic Press Orlando FL 1987 14 K Hayase H Imai OBDDs monotone function implicants Proc International Symposium Algorithms Computation Lecture Notes Computer Science Vol 1178 Springer Berlin 1996 pp 136145 15 T Horiyama T Ibaraki Reasoning ordered binary decision diagrams Proc International Symposium Algorithms Computation Lecture Notes Computer Science Vol 1969 Springer Berlin 2000 pp 120131 16 T Horiyama T Ibaraki Translation CNFs characteristic models ordered binary decision diagrams Proc International Symposium Algorithms Computation Lecture Notes Computer Science Vol 2223 Springer Berlin 2001 pp 231243 17 HA Kautz MJ Kearns B Selman Reasoning characteristic models Proc AAAI93 Washington DC 1993 pp 3439 18 HA Kautz MJ Kearns B Selman Horn approximations empirical data Artiﬁcial Intelligence 74 1995 129245 19 HA Kautz B Selman An empirical evaluation knowledge compilation theory approximation Proc AAAI94 Seattle WA 1994 pp 155161 20 D Kavvadias C Papadimitriou M Sideri On Horn envelopes hypergraph transversals Proc International Symposium Algorithms Computation Lecture Notes Computer Science Vol 762 Springer Berlin 1993 pp 399405 21 R Khardon D Roth Reasoning models Artiﬁcial Intelligence 87 1996 187213 22 YT Lai KR Pan M Pedram OBDDbased functional decomposition Algorithms implementation IEEE Trans CAD 15 8 1996 977990 23 JC Madre O Coudert A logically complete reasoning maintenance based logical constraint solver Proc IJCAI91 Sydney Australia 1991 pp 294299 24 J McCarthy PJ Hayes Some philosophical problems standpoint artiﬁcial intelligence D Michie Ed Machine Intelligence Vol 4 Edinburgh University Press Edinburgh 1969 25 S Minato N Ishiura S Yajima Shared binary decision diagram attributed edges efﬁcient Boolean function manipulation Proc ACMIEEE Design Automation Conference Orlando FL 1990 pp 5257 26 K Ravi KL McMillan TR Shiple F Somenzi Approximation decomposition binary decision diagrams Proc ACMIEEE Design Automation Conference San Francisco CA 1998 pp 445450 27 N Takahashi N Ishiura S Yajima Fault simulation multiple faults BDD representation fault sets Proc IEEEACM International Conference Computer Aided Design Santa Clara CA 1991 pp 550553 28 Y Takenaga Theoretical studies memorybased parallel computation ordered binary decision diagrams PhD Thesis Graduate School Engineering Kyoto University Kyoto Japan 1994 29 LG Valiant A theory learnable Comm ACM 27 11 1984 11341142 30 C Yang M Ciesielski V Singhal BDS A BDDbased logic optimization Proc ACMIEEE Design Automation Conference Los Angeles CA 2000 pp 9297