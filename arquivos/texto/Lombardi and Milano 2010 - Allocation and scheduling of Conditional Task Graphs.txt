Artiﬁcial Intelligence 174 2010 500529 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Allocation scheduling Conditional Task Graphs Michele Lombardi Michela Milano DEIS Universita di Bologna Viale Risorgimento 2 40136 Bologna Italy r t c l e n f o b s t r c t Article history Received 29 October 2008 Received revised form 22 February 2010 Accepted 22 February 2010 Available online 24 February 2010 Keywords Constraint Programming Probabilistic reasoning Scenarios Conditional Task Graphs Conditional constraints Optimization We propose original complete eﬃcient approach allocation scheduling Conditional Task Graphs CTGs In CTGs nodes represent activities branches labeled condition arcs rooted branch nodes labeled condition outcomes corresponding probability A task executed run time condition outcomes label arcs path task hold schedule execution time captured offline adopting stochastic model Tasks need execution unary cumulative resources tasks executed alternative resources The solution problem single assignment resource start time task allocation schedule feasible scenario expected value given objective function optimized For problem need extend traditional constraintbased scheduling techniques directions compute probability sets scenarios polynomial time order expected value objective function ii deﬁne conditional constraints ensure feasibility scenarios We application framework problems objective functions depending allocation resources tasks scheduling Also present conditional extension timetable global constraint Experimental results effectiveness approach set benchmarks taken ﬁeld embedded design Comparing solver scenario based solver proposed literature advantages approach terms execution time solution quality 2010 Elsevier BV All rights reserved 1 Introduction Conditional Task Graphs CTG directed acyclic graphs nodes represent activities linked arcs representing precedence relations Some activities branches labeled condition run time suc cessors branch chosen execution depending occurrence condition outcome labeling corresponding arc The truth falsity condition outcomes known priori sets challenge offline design approach account presence elements uncertainty A natural answer issue adopting stochastic model Each activity release date deadline needs resource executed The problem ﬁnd resource assignment start time task solution feasible run time scenario expected value given objective function optimized We account different objective functions depending resource allocation tasks depending scheduling problem Corresponding author Email address michelamilanouniboit M Milano 00043702 matter 2010 Elsevier BV All rights reserved doi101016jartint201002004 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 501 Fig 1 Some pseudocode translation CTG CTG ubiquitous number real life problems In compilation programs 13 example CTGs explicitly account presence conditional instructions Similarly ﬁeld design 39 CTGs applications ifthenelse statements case tasks represent processes arcs data communications Once hardware platform application given design amounts allocate platform resources processes compute schedule context taking account branches allows better resource usage lower costs CTG Business Process Management BPM 34 workﬂow management 30 mean describing operational business processes alternative control paths For solving allocation scheduling problem CTG need extend traditional constraint based techniques ingredients First compute expected value objective function need eﬃcient method reasoning task probabilities polynomial time For example compute probability certain task executes general probability given set scenarios uniform features objective function value Second need extend traditional constraints account feasibility scenarios For purpose deﬁne data structure called BranchFork Graph BFG We CTG satisﬁes property called Control Flow Uniqueness CFU mentioned probabilities computed polynomial time CFU property holds number interesting applications example compilation programs embedded design structured business processes The paper organized follows Section 2 presents applications CTG convenient representation problem entities relations Section 3 provide preliminary notions ConstraintBased Scheduling Section 4 introduces concept Conditional Task Graphs Control Flow Uniqueness sample space scenarios deﬁnes scheduling allocation problem consider In Section 5 deﬁne data structure implementing eﬃcient probabilistic reasoning BranchFork Graph related algorithms In Section 6 use algorithms eﬃciently computing expected value objective function types Section 7 exploit BFG implementing conditional variant timetable global constraint Section 8 discusses related work Section 9 shows experimental results comparison scenario based approach 2 Applications CTGs Conditional Task Graphs suitable data structure representing activities temporal relations real life applications In scenarios CTG allocation scheduling central issue In compilation programs 13 example CTGs explicitly account presence conditional instructions For instance Fig 1 shows simple example pseudocode natural translation CTG node corresponds instruction branch node test branch arcs label outcome represent In case probabilities condition outcomes derived code proﬁling Clearly programs contain loops treated CTGs modern compilers adopt loop unrolling 17 technique obtaining cycle free task graphs Similarly ﬁeld embedded design 39 common model parallel application task graph The task graph structure similar data ﬂow graph tasks task graph represent larger units functionality However task graph model control dependency information capture data dependency speciﬁcation Recently researchers cosynthesis domain tried use conditional task graph capture data dependencies control dependencies speciﬁcation 4218 Once hardware platform application given design amounts allocate platform resources processes compute schedule context taking account branches allows better resource usage lower costs However presence probabilities makes problem extremely complex real time quality service constraints satisﬁed execution scenario Embedded design applications paper experimentally evaluate performance quality approach CTG appear Business Process Management BPM 34 workﬂow management 30 mean describing operational business processes alternative control paths Workﬂows instances workﬂow models repre sentations realworld business processes 41 Basically workﬂow models consist activities ordering They serve different purposes employed documentation business processes input Workﬂow Management System allows machineaided execution 502 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 One widely systems representing business processes BPEL 27 BPEL graphstructured lan guage allows deﬁne workﬂow model nodes edges The logic decisions branching expressed transition conditions join conditions Transition conditions join conditions Boolean expressions As soon activity completed transition conditions outgoing links evaluated The result set status link true false Afterwards target link visited If status incoming links deﬁned join condition activity evaluated If join condition evaluates false activity called dead status outgoing links set false If join condition evaluates true activity executed status outgoing link evaluated CTGs behave exactly fashion model BPEL workﬂow models In addition CTG provide probabilities branches Such numbers task durations resource consump tion availability extracted process event logs The CTG allocation scheduling proposed paper context workﬂow management mean predict completion time running instances 1 scheduling tasks obtain minimal expected completion time 3 Preliminaries constraintbased scheduling In paper extend constraintbased scheduling techniques dealing probabilistic information conditional task graphs We provide preliminary notions ConstraintBased Scheduling ConstraintBased Scheduling 4 subﬁeld area Constraint Programming CP Generally speaking CP cerned solving Constraint Satisfaction Problems CSPs A CSP triple cid3 X D Ccid4 X set variables D set domains C set constraints constraint denotes relation values variables refers Solving CSP consists assigning values variables constraints satisﬁed simultaneously In CP constraints actively exploited reduce domains variables detect inconsistencies constraint propagation For example let D X denote domain variable x given Dx D y 0 1 2 3 constraint x y constraint propagation Dx reduced 0 1 2 D y 1 2 3 Note detecting problem consistencies diﬃcult solving original problem Thus constraint propagation enforces partial local consistency 11 consequently needs perform kind search determine CSP instance hand solution Scheduling problems set activities classically modeled CP introducing activity vari ables representing start time start end time end duration dur In context solution schedule assignment start end variables Start end duration variables satisfy constraint end start dur Activities require certain resources execution We consider paper unary resources discrete cumulative resources Unary resources capacity equal tasks unary resource overlap time cumulative resources ﬁnite capacity exceeded point time Scheduling problems involve precedence relations alternative resources precedence relations modeled means constraints start end variables different activities special resource constraints guarantee capacity resource exceeded schedule number different propagation algorithms temporal resource constraints 321 enable effective reduction search space Finally special scheduling oriented search strategies 4 devised eﬃciently ﬁnd consistent schedules prove infeasibility 4 Problem description The problem consider scheduling Conditional Task Graphs CTG presence unary cumulative alternative resources In following introduce deﬁnitions needed rest paper In Section 41 provide notions Conditional Task Graphs Section 42 concerns Control Flow Uniqueness CTG property enables deﬁnition polynomial time CTG algorithms Section 43 introduces concept sample space scenarios Section 44 describes scheduling allocation problem considered paper 41 Conditional Task Graph A CTG directed acyclic graph nodes partitioned branch fork nodes Branches execution ﬂow labeled condition Arcs rooted branch nodes labeled condition outcomes representing true order traverse arc execution time probability Intuitively fork nodes originate parallel activities branch nodes mutually exclusive outgoing arcs More formally Deﬁnition 1 A CTG directed acyclic graph consists tuple cid3T A C P cid4 T T B T F set nodes ti T B called branch node ti T F fork node T B T F partition set T T B T F Also T B graph deterministic task graph A set arcs ordered pairs ah ti t j C set pairs cid3ti cicid4 branch node ti T B ci condition labeling node M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 503 Fig 2 A example CTG B probabilities condition outcomes P set triples cid3ah Out Probcid4 labeling arc ah ti t j rooted branch node ti Out Outi j possible outcome condition ci labeling node ti Prob pi j probability Outi j true pi j 0 1 The CTG contains single root node incoming arcs connected directly indirectly For branch node ti T B condition ci outgoing arc ti t j labeled distinct outcome Outi j node graph cid2 ti t j pi j 1 Intuitively run time subgraph CTG execute depending branch node condition outcomes Each time branch node executed condition evaluated outgoing arcs evaluated true In Fig 2A condition true run time arc t1 t2 status true node t2 executes arc t1 t5 status false node t5 execute Without loss generality examples paper target graphs condition exactly outcomes true false However model multiple alternative outcomes 1 2 3 provided mutually exclusive true run time In Fig 2A t0 root node fork node executes run time Arcs t0 t1 t0 t12 rooted executing fork node evaluated true Node t1 branch node labeled condition With abuse notation omitted condition node labeled arc t1 t2 outcome meaning true t1 t5 meaning false The probability true 05 probability false 05 Let A ti set outgoing arcs node ti A ti ak A ak ti t j similarly let A ingoing arcs node ti A ingoing arc ti tail node A ti ak A ak t j ti Then ti said root node A ti 0 ti outgoing arc ti set ti 0 ti Without loss generality restrict attention CTGs node ti ingoing arcs ti 1 andnode ornode The concept andornodes executing node arc status A formalized recursive fashion Deﬁnition 2 Run time execution nodes arc status andor node deﬁnition The root node executes The status arc ti t j rooted fork node ti T F true node ti executes The status arc ti t j rooted branch node ti T B true node ti executes outcome Outi j labeling arc true A node ti A An ornode ti executes arc A A node ti A An andnode executes arcs A ti status equal true ti status equal true ti cid2 1 andnode possible ingoing arcs status true run time ti 1 ornode ingoing arcs status true runtime Note deﬁnition recursive deciding node ti A ti andornode depends predecessors execute deciding node execute requires know predecessors andornodes The consistent concepts depend information concerning predecessors considered node ti root node deﬁnition executes CTG contains cycle concept andornode executing nodestatus arc deﬁned 504 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 Observe ingoing arcs ornode mutually exclusive mixed andornodes allowed modeled combining pure possibly fake andnodes ornodes Note nodes single ingoing arc classiﬁed andnodes Again sake simplicity paper examples ingoing arcs andornodes presented results valid general apply number ingoing arcs In Fig 2A t15 ornode run time status t14 t15 t13 t15 true depending outcome condition d t21 andnode condition outcome false arc t20 t21 true arc t10 t21 status true outcome c true holds Therefore possible incoming arcs true run time t15 executes ingoing arcs status true t21 executes ingoing arc status evaluate true 411 Activation event node For modeling purposes useful express combination outcomes determining execution node compact expression As outcomes logical entities true false run time convenient formulate combination outcomes logical expression referred activation event The activation event node ti denoted εti obtained recursive fashion similarly deﬁnition executing node andornodes In practice εti true cid7 akt j ti Ati cid8 akt j ti Ati A ti 0 ti root node εak ti ornode εak ti andnode A ti 1 εak activation event arc ak deﬁned follows cid9 cid10 ak ti t j ε cid11 εti εti Outi j ti fork ti branch For example activation event task t2 Fig 2A εt2 activation event t21 εt21 b b c b c b c c b b c In general need express activation events Disjunctive Normal Form DNF disjunction conjunctions literals 42 Control ﬂow uniqueness Even deﬁnitions algorithms present paper work general case interested speciﬁc CTG satisfying property called Control Flow Uniqueness CFU1 Intuitively CFU satisﬁed node ti graph requires execution occurrence outcomes separated paths root ti More formally Deﬁnition 3 A CTG satisﬁes CFU andnode ti single arc A arcs ti cid11 A status arc true status arc cid11 true ti incoming ti logically responsible symbol denotes logical implication Intuitively single ingoing arc A execution andnode ti status arc true point time status ingoing arcs true Note actual run time execution ti occurs ingoing arcs true As consequence path root andnode logically responsible execution node More formally Corollary If CTG satisﬁes CFU task ti conjunction condition outcomes activation event εti DNF derived collecting condition outcomes following single path root node ti For example Fig 3A task t8 andnode activation event εt8 b b b CFU holds Conversely Fig 3B b strictly required execution t7 appear sequence path root t7 CFU satisﬁed In practical cases CFU restrictive assumption example graph results parsing program written high level language C Java C CFU naturally enforced scope rules language easily valid proper modeling For example consider pseudocode Fig 1 1 In rest paper explicitly underline algorithmsproperties need CFU M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 505 Fig 3 A CTG satisﬁes CFU B CTG satisfy CFU One easily check 1 CFU satisﬁed 2 exist simple translation pseudo code violating CFU conditional instruction collector node end Moreover application domains business process management embedded design common sumption consider called structured graphs graphs single collector node conditional branch In case CFU trivially satisﬁed Note structured graph model early exits case error reported Fig 1 43 Sample space scenarios On CTG deﬁne sample space S Deﬁnition 4 The sample space CTG set events occurring possible executions CTG event set condition outcomes For example sample space deﬁned CTG Fig 2A computed enumerating possible graph executions contains 20 events Again abuse notation refer outcome true outcome false Also sake clarity removed logical conjunctions conditions term b e simpliﬁed abe Therefore sample space associated CTG Fig 2A following S ade ade ade ade abcde abcde abcde abcde abcde abcde abcde abcde abcde abcde abcde abcde abcde abcde abcde abcde We need associate probability element sample space s S ps cid12 pi j Outi j s For instance reference Fig 2A probability event ade 05 03 07 0105 Each event sample space CTG associated scenario A scenario corresponds deterministic task graph containing set nodes arcs active scenario We deﬁne build task graph This task graph deﬁned recursively Deﬁnition 5 Given CTGcid3T A C P cid4 event s S deterministic task graph TGs associated s deﬁned follows The CTG root node belongs TGs A CTG arcti t j belongs TGs ti fork node ti belongs TGs ti branch node Outi j s ti belongs TGs arc ak A ti TGs A CTG node ti belongs TGs andnode arcs ak A ti TGs ornode TGs called scenario associated event s 506 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 Fig 4 The deterministic task graph associated run time scenario true d true e false CTG Fig 2 With abuse notation following refer event s scenario The deterministic task graph derived CTG Fig 2A associated run time scenario true d true e false equivalently ade depicted Fig 4 Often interested identifying set scenarios instance scenarios given task executes We start identifying events associated scenarios task ti executes This set deﬁned S s S ti TGs The probability node ti executes let pti computed easily pti ps For example let consider task t2 Fig 2A St2 ade ade ade ade pt2 05 03 07 05 03 03 05 07 07 05 07 03 05 Alternatively probability pti computed starting activation event example εt2 pt2 pa 05 εt8 b pt8 pa pb 05 04 02 sS cid2 For modeling purposes deﬁne task activation function fti s stochastic function fti S 0 1 cid11 fti s 1 ti TGs 0 Finally need deﬁne concept mutually exclusive tasks Deﬁnition 6 Two tasks ti t j said mutually exclusive mutexti t j iff scenario TGs tasks execute ti TGs t j TGs equivalently fti s ft j s 1 44 Scheduling allocation CTG Problem deﬁnition model The allocation scheduling problem face deﬁned conditional task graph nodes interpreted activities referred tasks arcs precedence relations pairs activities The CTG annotated number activity features duration release dates alternative resource sets resource consumption We schedule tasks assign resources alternative resource set temporal resource constraints run time scenario satisﬁed expected value given objective function optimized More formally Deﬁnition 7 An instance CTG allocation scheduling problem tuple cid3CTG Obj Dur Rel Due ResSet ResConscid4 In CTG cid3T A C P cid4 T represents set nonpreemptive tasks allocated scheduled A represents set precedence constraints pairs tasks C set conditions labeling nodes P set outcomes probabilities labeling arcs Obj objective function Dur Rel Due ResSet ResCons functions mapping task T respective duration release date date alternative resource set resource consumption Given task ti T duration referred Duri release date Reli date Duei alternative resource set ResSeti resource consumption ResConsi exception ResSet mentioned functions values N For sake simplicity assume task ti needs single resource taken ResSeti execution results presented paper easily extended tasks requiring resource More suppose task requires m types resource provided separate ResSet ResCons functions presented results apply type straightforward fashion 441 Modeling tasks temporal constraints As far model concerned node CTG corresponds task called activity Similarly constraint based scheduling task ti associated time interval startti endti startti decision variable denoting starting time task endti variable linked startti follows endti startti Duri Depending problem duration known advance decision variable In paper consider ﬁxed known advance durations M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 507 The start time variable task ti domain possible values ranging earliest start time estti latest start time lstti Similarly end time variable domain ranging earliest latest end times referred eetti letti Initially startti endti range schedule horizon time point 0 end horizon 0eoh Each arc ti t j CTG corresponds precedence constraint decision variables form startti Duri cid3 startt j Due dates release dates translate constraints startti Duri cid3 Duei startti cid2 Reli 442 Modeling alternative resources Beside start time activities additional decision variable resti represents resource assigned activity ti The domain possible values resti ResSeti Resources problem discrete unary Discrete resources referred cumulative resources known maximal capacity A certain resource ResConsi consumed activity ti assigned discrete resource resti start time activity ti quantity released end time A unary resource unit capacity It imposes activities requiring unary resource totally ordered Given resource R capacity referred CapR 443 Classical objective function types Depending problem objective function depend temporal allocation activities decisions variables start equivalently variables end duration ﬁxed resource assignments decisions variables res In constraintbased scheduling widely studied objective function makespan length sched ule It maximum value endti variables Obj1 max ti T endti 1 Another example objective function sum costs resource assignments single tasks As example consider case running task given resource consumes certain energy power cid13 Obj2 cid9 cid10 ti resti cost 2 ti T In hypothesis cost matrix element ci j cost assigning resource j task ti resti j costti resti ci j A example consider paper depends resource assignment pairs assignments cid9 cid10 ti resti t j rest j cost 3 cid13 Obj3 akti t j A For instance suppose arcs represent communication activities tasks If ti t j assigned resource communication cost zero assigned different resources communication cost increases Suppose vector element ck cost arc arck ti t j ti t j assigned different resources cid9 cid10 ti resti t j rest j cost cid11 ck 0 resti cid17 rest j Other objective functions considered For example cost having task certain resource turn resource In case cost associated execution sets tasks objective function considered generalization Obj3 dealt means techniques Clearly having probabilities conditional branches account possible run time scenarios optimize expected value objective function Therefore given objective function Obj scenario s refer s objective function computed scenario s Objs For example Obj 1 maximum end variables restricted tasks active scenario s belonging TGs Obj s 1 max ti TGs endti max ti T fti sendti Similarly Obj s 2 cid13 ti TGs costti cid13 ti T fti scost cid9 cid10 ti resti 508 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 s Obj 3 cid13 cid9 cid10 resti rest j cost akti t j TGs cid13 fti s ft j scost akti t j A cid10 cid9 ti resti t j rest j Finally recalling deﬁnition expected value probability theory state Deﬁnition 8 The expected value given objective function Obj weighted sum Objs weighted scenario probabilities EObj cid2 sS psObjs 444 Solution CTG scheduling problem The solution CTG scheduling problem given terms scheduling allocation table 42 task assigned different resource different start time depending scenario unique allocation schedule task assigned single resource single start time independently run time scenario The ﬁrst solution precise able better optimize expected value objective function Unfortunately size table grows exponentially number scenarios increases making problem computing optimal scheduling table PSPACE complete analogous ﬁnding optimal policy stochastic constraint programming 40 We chose provide compact solution task assigned unique resource unique start time feasible possible run time scenario keeps problem NPhard This choice goes line notion strong controllability deﬁned 37 temporal constraint networks uncertainty particular network said strongly controllable exists single control sequence satisfying temporal constraints scenario In addition classes problems compilation programs kind solution actually implemented executed 31 More formally provide following deﬁnition Deﬁnition 9 The solution allocation scheduling problem cid14 cid3T A C P cid4 Obj Dur Rel Due ResSet ResCons cid15 assignment task ti T start time startti 0eoh resource resti ResSeti 1 ti T startti cid2 Reli 2 ti T startti Duri cid3 Duei 3 ti t j A startti Duri cid3 startt j 4 t 0 eoh s S R cid16 ti TGs ResSeti cid13 ti TGs resti R startti cid2tendti ResConsi cid3 CapR Constraints 1 2 ensure task executed release date date Constraints 3 enforce prece dence constraints constraints 4 enforce resource capacity restrictions scenarios time instant t time line A solution optimal EObj minimized resp maximized For example Fig 5A small CTG scheduling problem Fig 5B corresponding solution Note tasks unique start time unique resource assignment independent scenario feasible scenarios For instance tasks t1 t2 mutually exclusive appear scenario Therefore use unary resource execution overlap time 5 Probabilistic reasoning The model presented Section 4 solved traditional constraintbased scheduling techniques In fact aspects require probabilistic reasoning handled eﬃciently resource constraints en forced scenarios computation expected value objective function weighted sum scenarios In cases principle able enumerate possible scenarios number exponential Thus need eﬃcient way cope expression One contribution paper deﬁnition data structure called BranchFork Graph BFG compactly rep resents scenarios parametric polynomial time algorithm working BFG enables eﬃcient probabilistic reasoning For instance instantiate parametric algorithm computation probability given set scenarios probability scenarios given set tasks execute resp execute M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 509 Fig 5 A CTG scheduling problem B possible solution Fig 6 A CTG Fig 2 B associated BFG C probabilities condition outcomes 51 BranchFork Graph A BranchFork Graph BFG intuitively represents skeleton possible control ﬂows compactly encodes scenarios corresponding CTG example Fig 6B shows BFG associated CTG Fig 2A reported Fig 6A simplicity A BFG acyclic directed graph Nodes branch nodes Bnodes dots Fig 6B fork nodes F nodes circles Fig 6B There branch node BFG branch node CTG Fnodes instead represent sets events group CTG nodes executing events For example Fig 6B Fa groups nodes t2 t3 t4 execute scenarios true More formally Deﬁnition 10 A BranchFork Graph directed acyclic graph associated CTG cid3T T B T F A C P cid4 types nodes referred Bnodes Fnodes BFG nodes satisfy following conditions 1 The graph Bnode B branch node t T B associated CTG 2 Let S sample space CTG BFG Fnode F subset events σ 2S cid2ti T s σ ti TGs 510 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 b ck C I outcome ck appear scenarios σ II outcomes ck appear σ c σ cid11 2S b satisﬁed Fnode built σ σ cid11 The CTG branch node corresponding Bnode B denoted tB The Fnodes said represent set events σ correspond denoted σ F The set CTG nodes ti s σ F ti TGs said mapped F denoted tF i2 BFG arcs satisfy following conditions 1 An Fnode F connected Bnode B j arc F B j tB j tF 2 A Bnode B connected means arc labeled outcome OuttBi k Fnode F j tk tF j 3 An Fnode F connected Fnode F j path F F j exists σ F j σ F b There exists Fnode Fk σ F j σ Fk σ F Condition BFG nodes 1 tells BFG Bnode branch associated CTG Following condition 2 Fnode models subsets events σ 2S need model subset σ conditions 2a2c holds In particular 2a There need model sets events σ task graph mapped resulting Fnode sets events ultimate purpose BFG support reasoning task executions probability 2b There need model set events σ outcomes condition ck appear σ outcome ck σ In fact outcomes ck σ σ depends ck model Fnodes referring single outcome If outcomes ck σ σ independent ck 2c Provided condition 2a 2b holds need build Fnode exist larger set condition 2a 2b holds In practice condition 2c Fnodes events σ cid11 model maximal sets events For instance according deﬁnition BFG corresponding CTG Fig 6A contains branch node branch B0 corresponds t1 tB0 t1 B1 t6 B2 t7 B3 t12 B4 t15 As Fnodes F 0 represents sample space nodes t0 t1 t12 t15 mapped tF 0 t0 t1 t12 t15 execute scenarios Fnode Fb corresponds set events abcde abcde abcde abcde abcde abcde abcde abcde set events outcomes b true t8 task tFb executes scenarios condition 2a execute superset scenarios condition 2c Concerning BFG connectivity condition 1 intuitively states Bnode ingoing arc Fnodes corresponding CTG branch mapped BFG Fig 6B condition 1 yields arcs Fnodes Bnodes Condition 2 deﬁnes instead connectivity Bnodes Fnodes tells Bnode outgoing arc outcome corresponding CTG branch destination BFG arc Fnode destination arc outcome task tk mapped The BFG arc labeled corresponding CTG outcome In Fig 6B condition 2 yields arcs Bnodes Fnodes Finally condition 3 happens CTG satisfying CFU deﬁnes connectivity Fnodes F nodes linked path resulting conditions 1 2 In particular arcs F F j built F j destination minimal condition 3b Fnode σ F j σ F condition 2b Observe Fnode F parents Bnodes Fnodes parents Fnode Fnodes Bnodes children Bnodes Fnodes children Fnodes Fnodes Bnodes As example consider Fig 7 links Fnodes BFG corresponding CTG satisfy CFU Some properties follow BFG deﬁnition First given CTG associated BFG uniquely deﬁned The result comes fact node condition 1 univocally deﬁnes set Bnodes node condition 2c univocally selects set scenarios Fnode corresponds graph connectivity univocally deﬁned Fnodes Bnodes given The family mappings CTG nodes Fnodes general partition nodes CTG Fig 8 shows example graph node t3 mapped Fnode BFG F F b The following theorem holds Theorem 1 If CTG node ti mapped Fnode Fnodes mutually exclusive represent pairwise disjoint sets scenarios 2 Note tB node tF set M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 511 Fig 7 A nonCFU CTG Fig 3B B associated BFG Fig 8 Task t3 mapped Fnodes F F b Proof Suppose ti mapped Fnodes F j Fh true set events σ cid11 exists 2a 2b 2c satisﬁed From condition 2b ti TGs s σ F j σ Fh σ cid11 σ F j σ Fh satisﬁes 2b course 2c Hence σ cid11 σ F j σ Fh violate 2a ti mapped F j Fh Therefore condition ck let O set outcomes events σ F j σ Fh contain set outcomes ck σ F j σ Fh contains exactly outcome ck As different outcomes condition generate mutually exclusive events σ F j σ Fh mutually exclusive cid2 Note general Fnodes Bnodes parent despite case Fnodes Figs 6 8 child In particular Theorem 2 Parents Bnodes mutually exclusive parents Fnodes mutually exclusive Now let F Fnode Fnode parents F Proof Let B Bnode connectivity condition 1 parents Fnodes corresponding CTG branch tB mapped Theorem 1 Fnodes mutually exclusive σ F σ F cid11 cid3 σ F cid11cid11 connectivity F cid11cid11 cid17 Therefore condition 3 Note strict inclusion holds σ F parents nonmutually exclusive share event The reasoning holds parent Bnode B j substituting σ F cid11 σ F σ F cid11 s σ F cid11 tB j tF cid11cid11 σ F cid11cid11 cid3 σ F cid11 σ F cid11cid11 σ F cid11 cid2 cid11cid11 cid11 52 BFG control ﬂow uniqueness Control ﬂow uniqueness translates additional properties BFG Theorem 3 If CFU holds Fnode single parent Bnode Proof Every Fnode single parent Suppose node F parents F cid11cid11 cid11 F proof Theorem 2 adapt reasoning Bnodes 512 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 Fig 9 A BFG graph Fig 6 B stree associated scenario abcde C subgraph set strees associated scenarios ace holds Let t j CTG andnode tF consider incoming arcs t cid11 t j tF mapped ancestors F case CFU hold parents t execute events represented descendant ancestors consequence connectivity conditions execute parents F cid11cid11 t j cid11cid11 t cid11 cid11 t cid11cid11 cid11cid11 cid11 It possible identify t j t j tF cid11 b parents t cid11cid11 t respectively execute events σ F cid11 σ F cid11cid11 Now cid11cid11 cid3 σ F σ F cid11 cid11cid11 terms set events implies σ F cid11cid11 σ F cid11 However Theorem 2 know cid11 leads contradiction Hence CFU holds Fnode single parent cid2 The parent Bnode Suppose exists Fnode F single Fnode parent F parent F cid11 At time connectivity condition 3 cid11 node F existent fail satisfy node condition 2c Therefore single parent intermediate Bnode node t j tF executes σ F σ F σ F Fnode Bnode cid2 As F cid11 cid11 From Theorem 3 deduce CFU holds BFG bichromatic alternate graph Moreover branch node m outgoing arcs originates exactly m Fnodes BFG exactly 1 Fnodes number condition outcomes reason CFU satisﬁed denote Fnodes root outcome refer example Fnode referring outcome true denoted Fa referring b false F b CFU necessary condition structural property listed hold check CFU trying build BFG single parent Fnode original graph satisfy condition The BFG construction procedure case CFU satisﬁed outlined Appendix A 53 BFG scenarios The interesting feature BFG select encode groups scenarios arbitrarily chosen nodes execute A speciﬁc algorithm applied scenarios order compute corresponding probability feature Groups scenarios encoded BFG sets strees Deﬁnition 11 stree An stree subgraph BFG satisfying following properties 1 The subgraph includes root node 2 If subgraph includes Fnode includes children 3 If subgraph includes Fnode includes parents 4 If subgraph includes Bnode includes children Note stree associated scenario s BFG associated deterministic task graph TGs Despite stree necessarily tree case CFU holds required Deﬁnition 11 Fig 9AB CFU holds Fnodes labeled condition outcome refer M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 513 By relaxing condition 4 Deﬁnition 11 allowing inclusion condition Bnode subgraph representing set strees single stree scenario derived choosing subgraph single outcome branch condition For example subgraph Fig 9C extract set strees corresponding abcde abcde abcde abcde This encoding method suﬃcient represent sets scenarios practical required algorithm constraints discussed paper The importance strees mainly lies fact required algorithm presented forthcoming Section 55 54 Querying BFG We restrict attention CTG satisfying Control Flow Uniqueness want provide way select set strees representing set scenarios include exclude speciﬁed group nodes subgraph available execution probability extracted proper algorithm We consider selection rules speciﬁed means conjunctions disjunctions positive negative terms3 Each basic term query ti meaning task ti executes ti meaning task ti execute Some examples valid queries q0 ti t j q1 ti t j tk q2 ti t j A query returns BFG subgraph representing events speciﬁed tasks executedo execute null case event exists The idea query processing procedure complete BFG represents possible scenarios select subset removing Fnodes satisfy boolean query Thus order processed queries ﬁrst negated q0 ti t j q1 ti t j tk q2 ti t j Each element negated disjunction mapped set Fnodes removed BFG This eﬃciently precomputing BFG node inclusion label exclusion label 1 Inclusion labels A CTG task ti inclusion label iF j Fnode F j directly mapped ti tF j ti inclusion label parents A CTG task ti inclusion label iB j Bnode B j ti inclusion label parents In practice ti iF j resp iB j execute scenarios corresponding stree containing F j resp B j 2 Exclusion labels A CTG task ti exclusion label eF j Fnode F j parents F j Fnodes4 ti exclusion label parent parent F j Bnode exists brother node Fk ti mapped descendant direct Fk ti mapped descendant direct F j A CTG task ti exclusion label eB j Bnode B j ti exclusion label parents In practice ti eF j resp eB j execute scenario correspondent stree containing F j resp B j For example Fig 6B reproduced Fig 10A sake clarity inclusion label node F 0 iF 0 t0 t1 t12 t15 iB3 equal iF 0 iFd iF 0 t14 iF d iF 0 t13 iB4 equal iF 0 t13 t14 mapped parents B 4 As exclusion labels eF 0 eB0 eF t2 t3 t4 tasks mapped brother node Fa mapped descendant F Once inclusion exclusion labels computed conjunctive term query ti t j mapped set FBnodes satisfying ti iF j iB j positive element ti term ti eF j eB j negative element ti term For example cid18 B j ti iB j cid17 cid18 F j ti iF j cid17 cid17 cid17 ti ti ti tk ti tk cid18 F j ti eF j cid17 cid18 B j ti eB j cid18 F j ti tk iF j cid17 cid18 F j ti iF j tk eF j cid18 B j ti tk iB j cid17 cid17 cid18 B j ti iB j tk eB j 3 Mixed queries allowed converting groups conjunctive queries representing disjoint sets scenarios paying exponential complexity blowup depending size structure query Pure conjunctive disjunctive queries managing cases practical shown rest paper 4 This property holds general CTG CFU satisﬁed parents Fnodes Bnodes 514 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 Fig 10 A The BFG Fig 6B B subgraph Fig 9C Note originally conjunctive query mapped set terms consisting single positive negative task literal query processed removing complete BFG F Bnodes corresponding term Conversely originally disjunctive query yields single term consisting conjunction positive negative task query processed removing BFG F Bnodes corresponding term For example graph Fig 6B reproduced Fig 10A sake clarity query q t21 t3 t16 t21 t3 t16 processed removing BFG F c Fa F e t21 eF c t3 iFa t16 iF e The resulting subgraph shown Fig 9C reproduced Fig 10B Disconnected nodes removed end process During query processing check step Bnode loses children case output null returned BFG subgraph contain Bnode allowed outcome impossible Similarly result null BFG nodes removed A query processed linear time Finally following theorem holds Theorem 4 If query returns BFG subgraph represents set strees Proof Assume query result null remember consider CFU satisﬁed condition 1 Deﬁni tion 11 trivially satisﬁed nonempty query includes root node Conditions 2 3 satisﬁed graph satisfying CFU children parents Fnodes Bnodes Bnodes removed processing query Finally condition 4 satisﬁed query processing remove children Bnode null returned cid2 As result query set strees input backward visit algorithm 55 Visiting BFG Many algorithms paper based backward visit BFG During visits algorithm collects attributes stored F Bnodes We propose meta algorithm set parameters deﬁned case case All backward visit based algorithms assume CFU satisﬁed require input subgraph representing set strees BFG particular case In particular Algorithm 1 shows generic structure backward visit given BFG The visit starts leaves proceeds root predecessor node visited successors visited lines 1213 The meta algorithm parametric ﬁvetuple cid3 A init F initB updateF updateB cid4 In particular A set possible attribute values characterizing F Bnode An denotes values attributes node n function init F F A F B j A associates Fnode element A values attributes function updateF associates Fnode Bnode element A The functions initB B A updateB B F j A deﬁned similarly init F updateF Bnodes In algorithm init F initB assign initial value attributes A F Bnode line 2 function updateF update attribute values parent Fnode Bnode line 6 initB update attributes parent Bnode Fnode line 8 In following use Algorithm 1 different parameter settings different purposes M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 515 Algorithm 1 Backward visit A init F initB updateF updateB Anp updateF n np n Bnode pick node n L n Fnode parent np 1 let L set nodes visit V visited nodes Initially L contains subgraph leaves V 2 F Bnode store values attributes A Initially set An init F n F nodes An initB n Bnodes 3 L cid17 4 5 6 7 8 9 10 11 12 13 14 end 15 end end V V n L L n parent np children np V L L np parent np Anp updateB n np 56 Computing subgraph probabilities In following compute probability given BFG sets strees derived querying BFG The probability subgraph computed backward visit instantiation meta Algorithm 1 In particular single attribute p representing probability stored F Bnodes A 0 1 The result algorithm probability value root node The init update functions follows init F F probability outcome labeling arc single Bnode parent F F init B B 0 updateF F B j pB j pF updateB B F j pF j pB As example consider subgraph Fig 9C reported Fig 10B probabilities The computation starts leaves example beginning pFb 04 pF b 06 pF c 06 set init F Then proba bilities Bnodes weighted sum children update F example pb1 pFb pF b 04 06 1 pb2 pF c 06 Probabilities Fnodes instead product children updateB pF pb1pb2 06 The visit proceeds backwards pF 0 computed prob ability subgraph 6 Objective function One purposes probabilistic reasoning presented far derive expected value given objective function eﬃciently We consider section examples objective functions commonly constraint based scheduling described Section 443 minimization costs single taskresource assignments minimization assignment cost pairs tasks makespan We refer ﬁrst examples objective functions depending resource allocation refer case objective function depending task schedule This ﬁrst second case easier transform expected value objective function deter ministic objective function provided able compute probability single task executes probabilities pair tasks executes respectively The example complicated declarative scription objective function computed polynomial time Therefore provide operational deﬁnition expected value deﬁning expected makespan constraint corresponding ﬁltering algorithm 61 Objective function depending resource allocation We ﬁrst consider objective function depending single tasks assignments run time scenario example suppose ﬁxed cost assignment task ti resource resti case objective 2 Section 443 The general form objective function given scenario s Objs cid13 cost ti TGs cid9 cid10 ti resti cid13 fti scost ti T cid9 cid10 ti resti We remind fti s 0 ti TGs According Deﬁnition 8 expected value objective function cid9 cid10 ti resti psObjs EObj ps cid13 cid13 cid13 fti scost sS sS ti T 516 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 We remind S s ti TGs set scenarios task executes Thus cid20 cid19 EObj cid13 cost ti T cid9 ti resti cid10 cid13 ps sS Now stochastic dependence removed expected value reduced deterministic expression Note cid2 ps simply probability execution nodetask This probability eﬃciently computed running Algorithm 1 instantiated explained Section 56 BFG subgraph resulting query q ti sS As second example suppose objective function related arcs run time scenario assume ﬁxed cost activation arc case objective 3 Section 443 The general form objective function cid13 cid9 cid10 resti rest j Objs cost akti t j TGs cid13 fti s ft j scost akti t j A cid9 cid10 ti resti t j rest j The expected value objective function EObj cid13 sS ps cid13 fti s ft j scost cid9 cid10 ti resti t j rest j akti t j A note costti resti t j rest j cost derive cost matrix c EObj cid13 cid19 cid9 ti resti t j rest j cid10 cid13 cost cid20 ps akti t j A sS S j cid2 Now stochastic dependence removed expected value reduced deterministic expression Note ps probability tasks j execute Again probability eﬃciently computed sS S j Algorithm 1 BFG subgraph resulting query q ti t j 62 Objective function depending task schedule For deterministic task graph makespan simply end time task expressed makespan maxendti ti T If task graph conditional task depends occurring scenario Remember interested ﬁnding single assignment start times valid execution scenario case scenario s identiﬁes deterministic Task Graph TGs makespan maxendti ti TGs Thus natural declarative expression expected makespan cid13 Emakespan ps max sS cid17 cid18 endti ti TGs 4 ps probability scenario s Note expression simpliﬁed considering tail tasks ti 0 For example consider CTG depicted Fig 11A scenarios b b tasks A expected makespan expressed Emakespan pa max cid17 cid18 endt2 endt6 cid17 pa b max cid18 endt4 endt6 cid17 pa b max cid18 endt5 endt6 Unluckily number scenarios exponential number branches limits direct use expression 4 small simple instances Therefore deﬁned expected makespan global constraint cid22 endt1 endtn exp_mkspan_cst emkspan cid9cid21 cid10 aim compute legal bounds expected makespan variable emkspan end times tasks endti procedural fashion We devised ﬁltering algorithm described Section 621 aim prune expected makespan variable basis task end variables viceversa Section 622 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 517 Fig 11 Temporal task grouping 621 Filtering expected makespan variable The ﬁltering algorithm based simple idea computation expected makespan tractable order tasks consequently end variables known Consider schedule Fig 11B tasks use unary resource URes0 t5 task makespan scenarios containing t5 endt5 Similarly t4 task endt4 makespan value scenarios containing t4 containing t5 The computation start times assigned long endorder tasks known general let t0 t1 tnt 1 sequence CTG tasks ordered increasing end time Emakespan nt 1cid13 i0 pti ti1 tnt 1endti 5 The expected makespan computed weighted sum end times weight task ti given probability 1 ti executes 2 task ending later ti executes The sum contains nt terms nt number tasks number decreased considering tail tasks Hence end order tasks ﬁxed compute expected makespan polynomial time need able eﬃciently compute probability weights expression 5 CFU holds explained Section 5 running Algorithm 1 probability computation version BFG subgraph resulting query q ti ti1 tnt 1 In general search order tasks ﬁxed possible identify possibly infeasible task schedules makespan computed expression 5 bound expected makespan variable We refer schedules Smin Smax Fig 12 In particular Smin schedule tasks assumed end minimum possible time sorted increasing minendti conversely Smax tasks assumed end maximum possible time ordered according maxendti Obviously situations likely infeasible taken account Moreover following theorem holds Theorem 5 The expected makespan assumes maximum possible value Smax schedule minimum possible value Smin schedule Proof Let account Smax Let t0 tn1 respective task order corresponding expected makespan value expression 5 weighted sum maximum end times emkspanSmax w 0 max wn1 max cid9 cid10 endt0 cid9 cid10 endtn1 cid2 w 1 weights probability note weights univocally deﬁned task order If Smax Note expected maximum makespan schedule possible increase expected makespan value reducing end time tasks Now let gradually decrease maxendti maintaining maxendti cid2 maxendti1 long w change expected makespan value necessarily decreases When maxendti gets lower maxendti1 weights w w i1 change follows w pti ti1 tn1 pti ti1 ti1 tn1 w i1 pti1 ti ti1 tn1 pti1 ti1 tn1 cid2 constant equal 1 swap w i1 gets higher w gets lower As sum w i1 grows exactly w shrinks terms weight ti transferred ti1 equivalently ti1 steals weight ti From decreasing maxendti expected makespan decrease slower pace lower value w w 0 Hence reducing end time single time variable expected makespan worse Moving tasks complicates situation reasoning holds An analogous proof expected makespan S min schedule cid2 w 518 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 Fig 12 A Example S min S max sequences B An update endt1 causes swap S max Fig 13 Upper bound end variables We prune expected makespan variable enforcing emkspanSmin cid3 emkspan cid3 emkspanSmax 6 In order improve computational eﬃciency use Fnodes BFG instead tasks computation emkspanSmin emkspanSmax exploiting mapping tasks CTG nodes Fnodes details Ap pendix B Pruning makespan variable requires compute makespan schedules S min Smax performing BFG query complexity O nt probability computation complexity O nt task O nt iter ations The basic worst case complexity O n2 t reduced O nt lognt exploiting caching dynamic updates search As intuition probability weights BFG computed root search tree cached Then time variable endti changes possibly nodes change positions Smin Smax Fig 12B maxendt1 changes lower maxendt3 nodes swapped situation probabilities repositioned nodes updated Each update O lognt modifying probability weights BFG nt nodes search node children overall complexity O nt lognt 622 Filtering end time variables When dealing makespan minimization problem crucial eﬃciency search process exploit makespan variable domain updates new bound discovered ﬁlter end variables domains Bounds endti computed expression 5 example compute upper bound endti subtract maximum expected makespan value maxmkspan minimum contribution tasks ti maxemkspan endti cid3 jcid17i pt j t j1 minendt j pti ti1 cid2 7 t0 ti1 ti ti1 sequence contribution t j j cid17 minimized Unfortunately sequence affected value endti In principle compute bound possible assignments endti keeping contribution nodes minimized M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 519 Note sequence contribution tasks minimized S min schedule compute set bounds endti sweeping position sequence repeatedly applying formula 7 An example shown Fig 13 bound computed t0 step 1 Fig 13 We start computing bound based current position t0 sequence step 2 Fig 13 bound minendt1 maxendt0 pruned swap t0 t1 sequence update probabilities original probability w 0 w 1 according expression 5 The process continues comparing t0 t2 maxendt0 pruned end Smin reached Lower bounds minendti computed similarly reasoning Smax A detailed description ﬁltering procedure given Algorithm 2 The tasks processed appear S min line 2 t j algorithm starts scan intervals line 6 For interval compute bound lines 7 11 based maximum makespan value maxmkspan current task probabilityweight wgt contribution tasks makespan lower bound rest If end list reached bound interval line 12 prune end variable current task line 13 task processed If bound exceeds current interval In transition current task possibly gains weight stealing activity crossed lines 15 18 wgt rest updated accordingly Algorithm 2 End variables pruning upper bound 1 let S min t0 t1 tk1 2 j 0 k 1 3 4 5 6 7 compute result query q t j t j1 tk1 probability pq wgt pq rest mkspanS min minendt j w gt h j k 1 wgt 0 UB maxmkspan rest wgt UB end h k 1 UB cid2 minendth1 set UB upper bound t j remove element th1 query q update pq newwgt pq rest rest newwgt wgt minendth1 wgt newwgt 8 9 10 11 12 13 14 15 16 17 18 19 20 21 end end end The algorithm takes account tasks complexity O nt analyzes subsequent intervals complexity O nt weights updated transition complexity O lognt taking care fact task mapped Fnode note directly working F nodes avoids issue The overall complexity O n2 o logno number condition outcomes CTG Appendix B t lognt manipulating Fnodes instead tasks reduced O nt n2 7 Conditional constraints To tackle scheduling problems conditional task graphs introduced called conditional constraints extend traditional constraints account feasibility scenarios Let C constraint deﬁned set variables X let S set scenarios given CTG let Xs X set variables related tasks appearing scenario s S The conditional constraint corresponding C enforce s S C Xs C Xs denotes restriction constraint C variables Xs A simple example disjunctive conditional constraint 18 models temporal relations tasks ti t j need unary resource execution The disjunctive constraint enforces cid9 cid9 cid10 endti cid3 startt j cid10 endt j cid3 startti mutexti t j mutexti t j holds tasks ti t j mutually exclusive Deﬁnition 6 access resource competition 520 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 As example let consider cumulative constraint modeling limited capacity resources The traditional Fig 14 Capacity cumulative resource CTG source constraint enforces time instant t cid23 cid13 time t R ResSeti ti ti startti cid2tendti resti R ResConsi cid3 CapR conditional version enforces time t s S R cid23 ResSeti ti T Gs cid13 ti TGs startti cid2tendti resti R ResConsi cid3 CapR constraint hold scenario amounts relaxation deterministic case As consequence resource requirements mutually exclusive tasks summed appear scenario In principle conditional constraint implemented checking correspondent nonconditional constraint scenario number scenarios CTG grows exponentially number branch nodes case case check affordable practice Therefore implementing conditional constraints requires eﬃcient tool reason CTG scenarios provided BFG framework described Section 51 We deﬁned implemented conditional version timetable constraint 23 cumulative resources described following section conditional constraints implemented BFG framework taking inspiration existing ﬁltering algorithms 71 Timetable constraint A family ﬁltering algorithms cumulative resource constraints based timetables data structures storing worst case usage proﬁle resource time 23 While timetables traditional resources relatively simple eﬃcient computing worst usage proﬁle presence alternative scenarios mutually exclusive activities trivial varies nonlinear way furthermore activity resource view Suppose instance CTG Fig 14A tasks t0 t4 t6 scheduled start time durations reported Fig 14B tasks require single cumulative resource capacity 3 requirements reported node graph Tasks t5 t7 scheduled t5 present scenario resource usage proﬁle ﬁrst reported Fig 14B hand t7 present scenario b usage proﬁle Fig 14B Therefore resource view given time depends activity considering In case activity present scenario worst case time instant considered M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 521 We introduce new global timetable constraint cumulative resources conditional tasks nonpreemptive case The global constraint keeps list known starting ending points activities particular latest start times earliest end times given activity ti lstti cid3 eetti activity obligatory lstti eetti contributing resource proﬁle The ﬁltering algorithm described Algorithm 3 All algorithm ti target activity variable time represents time point currently exam ﬁnish ﬁnish line value reached ﬁltering ﬁnally ﬁrstPStart represents ﬁrst time point ti start good ﬂag value false resource capacity exceeded examined time point Algorithm 3 keeps scanning meaningful end points obligatory parts interval estti ﬁnish line 4 1 The resource capacity exceeded current time point good false current time point gone latest start time ti case constraint fails 2 The resource capacity exceeded current time point good true ﬁnish line reached time cid2 ﬁnish Next resource usage checked current time point line 5 case capacity exceeded recorded good false line 7 algorithm moves end point obligatory eett j hope resource freed time In case capacity exceeded A current time point suitable activity start line 10 B ﬁnish line updated line 11 current time value plus duration activity algorithm keeps checking starting time obligatory parts line 14 If ﬁnish line reached reporting resource overusage start time ti updated line 18 Algorithm 3 Filtering algorithm conditional timetable constraint good false let time eett j let good false ResConsi resUsageti time resCapacity 1 let time estti ﬁnish eetti 2 let ﬁrstPStart time 3 let good true 4 good false time lstti good true time ﬁnish 5 6 7 8 9 10 11 12 13 14 15 16 end 17 good true 18 19 20 fail 21 end let ﬁrstPStart time let ﬁnish maxﬁnish time Duri let good true end let time lstt j let estti ﬁrstPStart end Algorithm 3 treats computation resource usage black box resUsageti time denotes worst case usage time time seen task ti worst case usage cumulative resource seen current activity computed eﬃciently backward visit described Algorithm 1 BFG Fnodes labeled weight value follows To compute worst case usage resource time t ﬁrst load requirement task ti executing time t lstti cid3 t cid3 eetti Fnode F j ti belongs node inclusion label ti iF j For computation maximum weight scenario F Bnode single attribute w representing weight value particular A 0 The init update functions deﬁned follows init F F cid13 ResConsi lstt j cid2tcid2eett j t j iF init B B 0 cid9 updateF F B j max updateB B F j wF j wB cid10 wB j wF At end process weight root node worst case resource usage 522 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 Basically Algorithm 1 instantiated described performs backward visit BFG summing weight child Fnode updateB choosing Bnode maximum weight children updateF As outcome processed complexity O loading CTG task Fnode complexity O The timetable ﬁltering algorithm Algorithm 3 worst case loads CTG node computes weight task nt times complexity ﬁltering algorithm time window single task O ntno O ntno This value reduced caching results updating data structures time window task ti modiﬁed updating data Fnodes propagating change backward BFG tree like structure O logno overall complexity reduced O nt logno 8 Related work This paper substantially revised extended version previous papers 25 propose similar frame work dealing objective functions depending task allocation ﬁeld embedded design 24 face makespan minimization problem In present paper recall ideas previous papers addition conditional constraints formalize overall stochastic framework perform extensive evaluation The area CTG allocation scheduling received attention probably embedded design In context Conditional Task Graphs represent functional abstraction embedded applications optimally mapped multi core architectures Multi Processor Systems Chip MPSoCs The optimal allocation schedule guarantees high performances entire life time The problem faced mainly incomplete approaches particular 12 earliest works CTGs referred Conditional Process Graphs focus minimizing worst case completion time solution provided means branch outcome dependent schedule table list scheduling based heuristic provided inter tasks communications taken account In 42 genetic algorithm devised basis conditional scheduling table exponential number columns represent combination conditions CTG rows starting times activities appear scenario The size table reasonable real world applications Another incomplete approach described 39 proposes heuristic algorithm task allocation scheduling based computation mutual exclusion tasks Finally 31 describes incomplete algorithm minimizing energy consumption based task ordering task stretching To knowledge previous work CTG complete approach CTG allocation scheduling problem proposed 18 based Constraint Programming The solving algorithm scales small task graphs 10 activities cumulative resources taken account Only simple unary resource constraint implemented paper Also expected value objective function taken account Another complete CP based approach described 19 targets low level instruction scheduling Hierarchi cal Conditional Dependency Graphs HCDG conditional dependencies modeled HCDGs introducing special nodes guards condition execution operation complexity blowup avoided providing single schedule operations mutually exclusive guards allowed execute time step access resource We basically adopted approach avoid scheduling scenario independently Mutual exclusions rela tions listed HCDGSs pair tasks computed line checking compatibility guard expressions CTGs deduced graph structure note insearch computation described paper support speculative execution Pairwise listing exclusion relations general approach lacks nice properties necessary eﬃciently handle nonunary capacity resources particular computing worst case usage resource NPcomplete problem pairwise mutual exclusions known fact 19 unary resources taken account An interesting framework CTG allocation scheduling ﬁt presented 9 The framework general taking account forms stochastic variables example task durations integrate general families techniques cope uncertainty proactive techniques use information uncertainty generate solve problem model revision techniques change decisions relevant execution progressive techniques solve problem piece piece gliding time horizon Our paper general focused eﬃcient solution speciﬁc aspect framework conditional branches alternative activities Conditional Task Graph arise context conditional planning 28 Basically conditional planning check execution path scenario consistent temporal constraints For purpose extensions traditional temporal constraint based reasoning proposed 36 35 However approaches account presence resources conversely crucial constraint based scheduling Other graph structures similar CTG considered 207 These graphs contain called optional activities choice execution decided scheduler based condition outcome Basically straint based scheduling techniques extended cope graphs probability reasoning required For graphs optional activities eﬃcient unary resource constraint ﬁltering algorithm proposed 38 Close spirit optional activities Temporal Networks Alternatives TNA introduced 5 TNA augment Simple Temporal Networks alternative subgraphs consisting principal node arcs number M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 523 branching nodes user choose runtime execution Like optional activities user responsible choosing node unlike optional activities exactly branching node selected TNA allow early exits approach require condition CFU The followup work 6 proposes heuristic algorithm identify equivalent nodes TNA similarly BFG Note F nodes necessarily represent equivalence classes think fact CTG node mapped Fnode elementary groups scenarios subset tasks execute Speaking generally stochastic problems widely investigated Operations Research community Artiﬁcial Intelligence community Operations Research extensively studied stochastic optimization The main approaches grouped categories sampling 2 consisting approximating expected value average value given sample l shaped method 22 faces stochastic problems recourse featuring second stage decision variables ﬁxed stochastic variables known The method based Benders Decomposition 8 master problem deterministic problem computing ﬁrst phase decision variables The subproblem stochastic problem assigns second stage decision variables minimizing average value objective function A method based branch bound extended dealing stochastic variables 26 In ﬁeld stochastic optimization important role played stochastic scheduling This ﬁeld motivated problems arising systems scarce resources allocated time activities random features The aim stochastic scheduling problems come policy prioritize time activities awaiting service Mainly methodologies developed Models scheduling batch stochastic jobs tasks scheduled known processing time random known distribution seminal papers 3229 Multi armed bandit models 14 concerned problem optimally allocating effort time collection projects change state random fashion Queuing scheduling control models 10 concerned design optimal service discipline set activities executed known advance arrives random fashion known distribution Temporal uncertainty considered Artiﬁcial Intelligence community extending Temporal Constraint Networks TCSP allow contingent constraints 37 linking activities effective duration decided provided external world In cases notion consistency redeﬁned terms controllability intuitively network controllable consistent situation assignment set contingent intervals arise external world Three levels controllability distinguished strong weak dynamic We ensure paper strong controllability enforce consistency scenarios The Constraint Programming community recently faced stochastic problems 40 stochastic constraint program ming formally introduced concept solution replaced policy In paper algorithms proposed based backtrack search This work extended 33 algorithm based cept scenarios proposed In particular paper shows reduce number scenarios provide reasonable approximation value optimal solution We compare approach reported paper terms eﬃciency solution quality 9 Experimental results Our approach referred conditional solver implemented state art ILOG Cplex 110 Solver 63 Scheduler 63 We tested approach number instances representing variants real world hardware design problem multi task application described means CTG scheduled multiprocessor hardware platform The problem features complex precedence relations representing data communications unary resources processors single cumulative resource modeling shared communication channel ca pacity total bandwidth Instances problem variants realistic meaning randomly generated base real world instances 15 We designed groups experiments variants problem described respectively Sections 91 92 evaluate conditional timetable constraint objective functions presented paper perfor mance BFG framework Also compare approach scenario based solver 33 explicitly considers scenarios subset 91 Bus traﬃc minimization problem In ﬁrst problem variant hardware resources like processing elements memory devices allocated tasks order minimize expected bus traﬃc Once resources assigned tasks scheduled speciﬁed global deadline met The objective depends allocation choices counts contributions 524 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 Table 1 Performance tests expected bus traﬃc minimization problem tasks arcs acts scens proc 1012 1214 1415 1518 1819 2021 2123 2425 2528 2829 812 1016 1217 1322 1622 1625 1928 2029 2230 2333 2636 3246 3849 4162 5063 5271 5979 6483 6988 7495 16 39 29 218 430 324 624 436 572 848 22 22 23 33 33 44 44 45 55 55 time min 002 004 003 011 031 029 127 073 019 249 Table 2 Performance tests expected bus traﬃc minimization problem scens proc 13 34 46 66 68 89 912 1212 1224 2472 23 24 25 25 24 25 25 35 35 35 S100 T T cond 130 098 133 106 096 089 124 138 098 121 TL inf 1 2 2 0 1 6 3 3 2 3 3 5 4 5 6 5 6 8 6 2 S80 T T cond 131 122 085 131 115 100 111 096 096 104 TL inf 1 2 1 0 1 6 4 4 3 3 3 5 4 5 6 5 6 8 6 2 med 007 012 022 043 178 168 127 325 237 1149 Z Zcond 100 100 097 096 093 088 096 091 087 081 max 2541 61096 3370 256 8752 74149 64174 47916 38236 7846 S50 T T cond 085 057 104 083 120 048 079 097 059 089 TL 0 1 0 1 2 2 3 2 4 4 TL inf 1 1 0 0 0 5 3 4 3 3 3 1 4 4 6 4 6 8 5 2 inf 3 1 7 7 2 4 11 5 7 4 Z Zcond 086 074 069 078 069 062 079 073 079 064 depending single taskresource assignments depending pairs taskresource assignments Basically objective function captures cases described Section 61 We faced problem means Logic Based Benders Decomposition 16 explained 25 master problem resource allocation subproblem computation feasible schedule We implemented conditional solver based BFG scenario based 33 In ﬁrst case stochastic ob jective function master problem reduced deterministic expression scenario probabilities computed described Section 61 scheduling subproblem unary resources processors modeled conditional disjunctive constraints communication channel considered cumulative resource modeled ditional timetable constraint In scenario based solver objective function sum exponential number linear terms scenario Processors modeled conditional disjunctive constraints communication channel collection discrete resources scenario A simple scenario reduction technique implemented solver conﬁgured account portion likely scenarios We generated 200 instances problem ranging 10 29 tasks 8 33 arcs amounts 26 95 activities scheduling subproblem tasks arcs split activities All instances satisfy Control Flow Uniqueness number scenario ranges 1 72 The CTG generation process works ﬁrst building deterministic Task Graph randomly selecting fork nodes turned branches provided CFU remains satisﬁed outcome probabilities chosen randomly according uniform distribution The number processors platform goes 2 5 We ran experiments Pentium IV 2 GHz 512 MB RAM time limit 900 seconds The ﬁrst set experiments reported Table 1 goal test performance conditional solver Each row refers group 20 instances reports minimum maximum number tasks arcs scheduling activities sce narios processors columns tasks arcs acts scens proc minimum column min median med maximum max computation time instances solved optimality included time perform preprocessing build BFG Then number instances solved time limit follows TL number infeasible instances inf As median computation time pretty low grows size instance maxi mum erratic behavior inﬂuenced presence uncommonly diﬃcult instances The number timedout instances intuitively grows size graph Then compared conditional solver realized scenario based problem results second group tests shown Table 2 Each row reports results group 20 instances shows minimum maximum number scenarios column scens minimum maximum number processors procs data scenario based solver 100 S100 80 S80 50 S50 likely scenarios M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 525 Table 3 Performance tests acts 3745 4550 5054 5457 5760 6065 6569 6976 7681 8186 8693 93109 scens 12 13 13 24 16 16 28 312 120 324 236 4135 proc 34 35 35 45 45 46 46 46 56 56 56 56 T C 154 267 900 2568 2978 2403 3212 9645 14467 14331 16574 18556 F C 3115 4943 17 505 52 949 77 302 28 514 47 123 101 800 134 235 130 561 119 930 127 321 TL 0 0 0 1 1 0 2 14 21 17 25 28 C W 083 088 088 088 094 085 090 086 090 084 093 093 stc C W 080 084 085 085 090 080 084 082 086 075 087 087 T T cond considered In particular report scenario based solver average solution time ratio conditional solver instances solved approaches number timed instances TL considered average time computation number infeasible instances inf For S50 S80 solvers average solution quality ratio shown Note Table 2 instances sorted number scenarios size consequence ﬁrst rows necessarily refer smallest easiest scheduling problems Z Zcond On average conditional solver improves scenario based 13 factor impressive improve ment Also improvement occur cases reason computation time problem dominated ﬁnding optimal resource allocation regard subproblem conditional approach offers eﬃcient way build objective function expression We expect better results importance scheduling subproblem grows Note use scenario reduction techniques speeds solution process S80 S50 introduces Also infeasible inaccuracies objective function value lower column instances missed value inf column S50 lower S100 Z Zcond 92 Makespan minimization problem In second problem variant consider minimization expected makespan expected application completion time This complex previous case objective function depends scheduling related variables We chose limit computing optimal schedule given resource allocation As previous problem variant implemented conditional scenario based solver In conditional solver makespan computation handled global constraint described Section 62 scenario based solver makespan sum completion time possible scenario weighted scenario probability expression 4 Processors bus constraints modeled described Section 91 For problem generated 800 instances ranging 37 109 tasks 2 5 heads tasks predecessor 3 11 tails tasks successor 1 135 scenarios The number processors unary resources ranges 3 6 Again instances satisfy control ﬂow uniqueness We ran experiments time limit 300 seconds tests executed AMD Turion 64 186 GHz We performed ﬁrst group tests evaluate eﬃciency expected makespan conditional constraint quality solutions provided particular gain achieved minimizing expected makespan compared worst case based approaches second group experiment performed compare performances conditional solver scenariobased Table 3 shows results ﬁrst group tests evaluate performance solver conditional timetable constraint referred C compare quality computed schedules versus identical model deterministic makespan minimized referred W In case expected makespan constraint objective function deterministic amounts minimizing worst case makespan objective deterministic model necessarily worse conditional The models C W identical regard use conditional resource constraints assign ﬁxed start time task Each row identiﬁes group 50 instances For group report minimum maximum number activities acts scenarios scens unary resources proc average solution time T C average number fails F C number instances solved time limit TL conditional solver In column CW report makespan value ratio shows average improvement 12 deterministic objective The gain 16 consider instances makespan actually improved column stc CW The computing time approaches surprisingly roughly equivalent instances 526 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 Table 4 Comparison scenario based solver scens 12 23 34 45 56 66 68 89 912 1214 1420 20135 T C 4100 6602 4380 4994 6639 5126 3885 5778 5296 11793 9574 17888 TL 5 8 5 6 9 5 5 9 5 17 11 24 T S100 T C 2260 1985 3505 7375 4874 652 8221 6632 8952 4560 3262 6619 TL 5 10 8 9 12 8 11 10 13 22 22 37 T S80 T C 2266 1993 3512 7363 1664 611 7109 6370 8697 4302 3185 6556 TL 5 10 8 9 12 8 9 10 13 22 21 37 S80 C 100 100 100 100 098 096 098 098 098 097 099 100 T S50 T C 058 169 919 5703 077 4199 8441 2676 4043 3735 2876 2209 TL 3 7 5 8 8 8 3 9 6 18 15 35 S50 C 077 080 079 080 082 080 080 085 085 084 090 0912 Table 4 compares conditional model scenario based solver remind second case cumulative resource implemented constraint scenario expected makespan expressed declarative formula 4 In models unary resources processors implemented conditional constraints Again rows Table 4 report average results groups 50 instances instances grouped sorted increasing number scenarios results ﬁrst row necessarily refer easiestsmallest instances The table reports solution time conditional solver T C performance ratios wrt scenario based solver 100 S100 80 S80 50 S50 likely scenarios The columns TL number instances solved time limit approach Finally columns S50C S80C accuracy solution provided S50 S80 solvers As seen conditional model outperforms scenario based average factor 4908 For problem fact conditional approach provides completely different eﬃcient representation objective function eﬃcient procedure build expression case traﬃc minimization By reducing number considered scenarios performance gap decreases conditional solver remains better S80 outperformed S50 number scenarios low solution provided average 17 inaccuracy Moreover S50 S80 guarantee feasibility cases scenarios considered solution 10 Conclusion CTG allocation scheduling problem arising application areas deserves speciﬁc methodology eﬃcient solution We propose use data structure called BranchFork Graph enabling eﬃcient probabilistic reasoning BFG related algorithms extending traditional constraint conditional case computation expected value given objective function The experimental results conditional solver effective practice outperforms scenario based solver problem The performance gap signiﬁcant makespan objective function considered Current research devoted taking account problems stochastic variables task durations resource availability Also application CTG allocation scheduling time prediction business process management subject current research activity Appendix A BFG construction procedure CFU holds The BFG construction procedure exponential time complexity case CTG satisﬁes CFU number possible conjunctions activation events exponential practice devise polynomial time algorithm Control Flow Uniqueness holds In case know BFG contains Fnode condition outcome original CTG plus F root node design algorithm build BFG Fnode condition outcome check step CFU actually holds violation encountered return error In following suppose CTG node ti labeled set condition outcomes paths root node ti upstream conditions easily polynomial time means forward visit graph A polynomial time complexity BFG building procedure graphs satisfying CFU shown Algorithm 4 The algorithm performs forward visit Conditional Task Graph starting root node visit proceeds BFG built CTG nodes mapped Fnodes The acyclicity CTG ensures CTG node ti visited Fnodes needed map built M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 527 Fig 15 shows example procedure input subgraph CTG Fig 2A Initially Fig 15B L set contains root task t5 V The CTG node t5 visited line 5 mapped prebuilt Fnode F 0 The mapping_set function line 6 returns set Fnodes current BFG t5 mapped details compute set given later In step Fig 15C t6 processed mapped F 0 t6 branch new Bnode built line 9 Fnode condition outcome Fb F b In Fig 15D t7 visited similarly t6 new Bnode new Fnodes built Next t8 visited mapped Fb Fig 15E similarly t9 mapped F b t10 F c t11 F c steps shown ﬁgure Finally Figs 15F 15G nodes t20 t21 visited ﬁrst triggered outcomes b b mapped directly F 0 t21 instead node main predecessor t10 mapping_set function maps Fnode t10 Algorithm 4 Building BFG 1 input Conditional Task Graph nodes labeled set upstream conditions 2 build root Fnode F 0 3 let L set nodes visit V visited nodes Initially L contains CTG root V 4 L cid17 5 pick ﬁrst node ti L remove ti L let F ti mapping_setti set Fnodes ti mapped 6 7 map ti Fnodes F ti 8 ti branch build Bnode B build Fnode F Out condition outcome Out branch connect Fnode F ti B end add ti V child node t j ti parent nodes t j V add t j L 9 10 11 12 13 14 15 end 16 17 end The set F ti CTG node computed means twophase procedure In ﬁrst place extended set Fnodes derived forward visit BFG built far The visit starts root Fnode At step A Fnode visited children visited B Bnode visited child node visited corresponding condition outcome appears label ti reports upstream outcomes The CTG node ti initially mapped leaves reached visit example reference Fig 15G CTG node t21 ﬁrst mapped Fb F b F c In second phase extended set Fnodes simpliﬁed recursively applying simpliﬁcation rules order description clearer temporarily allow CTG branch nodes mapped Bnodes Bnode mappings discarded end simpliﬁcation process rule 1 rule 2 Bnode B parent Fnodes F 0 F 1 task t j mapped add B F t j For example reference Fig 15G initially F t21 Fb F b F c application rule 1 F t21 Bleft Fb F b F c task t j mapped Bnode B parent F 0 F 1 B descendants removed F t j If end process descendant F 0 F 1 F t j map t j F 0 F 1 For example application rule 2 F t21 F c Once simpliﬁcations remaining Fnodes F ti mutually exclusive said Section 51 shown Fig 8 fails occur means BFG Fnodes mapping turn means original graph meet CFU In case error reported Appendix B Improving eﬃciency expected makespan constraint In order improve computational eﬃciency ﬁltering algorithms expected makespan constraint Section 621 use Fnodes instead tasks computation emkspanS min emkspanSmin Remember mapping tasks CTG nodes Fnodes Each Fnode assigned minimum maximum end value computed follows cid10 cid24 cid18 cid24 ti tF j cid10 cid24 cid18 cid24 ti tF j cid17 maxendF j max cid17 minendF j max max cid9 min endti endti cid9 The rationale formulas tasks mapped Fnode F execute events σ F end time set tasks dominated ending 528 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 Fig 15 BFG building procedure The schedules Smin Smax store Fnodes sorted minend maxend instead activities size reduced 1 number condition outcomes cid23 nt fact number Fnodes BFG CFU holds Section 42 Each time end variable task ti mapped F j changes values maxendF j minendF j updated possibly nodes swapped Smin Smax similarly Fig 12B shows tasks These updates complexity O maxnt nt number tasks The makespan bound calculation constraints 6 substituting tasks Fnodes expression 5 shown expression 8 Emakespan pF F i1 Fno1 endF 8 endF minendF max endF probabilities pF F i1 Fno1 computed querying BFG q F F i1 Fno1 BFG queries involving Fnodes processed similarly usual queries basically whilst task mapped Fnodes Fnode mapped single Fnode inclusion exclusion labels computed usual b update weight time window Fnode performed strictly logarithmic time The algorithms devised tasks prune makespan end variables overall complexity goes O maxnt n2 o logno References 1 WMP van der Aalst MH Schonenberg M Song Time prediction based process mining BPM Center Report BPM0904 BPMcenterorg 2009 httpistmtuenlstaffwvdaalstBPMcenterreportshtm 2 S Ahmed A Shapiro The sample average approximation method stochastic programs integer recourse Optimization Line 2002 3 P Baptiste C Le Pape Constraint propagation decomposition techniques highly disjunctive highly cumulative project scheduling problems Constraints 5 12 2000 119139 4 P Baptiste C Le Pape W Nuijten ConstraintBased Scheduling Kluwer Academic Publisher 2003 5 R Bartak Ondrej Cepek Temporal networks alternatives Complexity model FLAIRS 2007 2007 pp 641646 6 R Bartak O Cepek P Surynek Modelling alternatives temporal networks IEEE Symposium Computational Intelligence Scheduling SCIS07 2007 pp 129136 cid13 M Lombardi M Milano Artiﬁcial Intelligence 174 2010 500529 529 7 JC Beck MS Fox Constraintdirected techniques scheduling alternative activities Journal Artiﬁcial Intelligence AI 121 12 2000 211250 8 JF Benders Partitioning procedures solving mixedvariables programming problems Numerische Mathematik 4 1962 238252 9 J Bidot T Vidal P Laborie JC Beck A general framework scheduling stochastic environment Proc Intl Joint Conference Artiﬁcial Intelligence IJCAI 2007 2007 pp 5661 10 DR Cox WL Smith Queues Chapman Hall 1961 11 R Dechter Constraint Processing Morgan Kaufmann 2003 12 P Eles Z Peng Bus access optimization distributed embedded systems based schedulability analysis International Conference Design Automation Europe DATE2000 IEEE Computer Sociery 2000 13 P Faraboschi JA Fisher C Young Instruction scheduling instruction level parallel processors Proceedings IEEE 89 11 2001 16381659 14 JC Gittins DM Jones A dynamic allocation index sequential design experiments Progress Statistics Colloq Math Soc Janos Bolyai 9 1974 241255 15 A Guerri M Lombardi M Milano Challenging scheduling problem ﬁeld design Workshop Scheduling Scheduling Competi tion ICAPS 2007 2007 available httpwwwliadeisuniboitStaffMicheleLombardi Task Graph Generator section 16 JN Hooker G Ottosson Logicbased benders decomposition Mathematical Programming 96 2003 3360 17 K Kennedy R Allen Optimizing Compilers Modern Architectures A Dependencebased Approach Morgan Kaufmann 2001 18 K Kuchcinski Constraintsdriven scheduling resource assignment ACM Transactions Design Automation Electronic Systems 8 2003 19 K Kuchcinski C Wolinski Global approach assignment scheduling complex behaviors based HCDG constraint programming Journal Systems Architecture 49 1215 2003 489503 20 J Kuster D Jannach G Friedrich Handling alternative activities resource constrained project scheduling problems Proc Intl Joint Confer ence Artiﬁcial Intelligence 2007 pp 19601965 21 P Laborie Algorithms propagating resource constraints AI planning scheduling Existing approaches new results Journal Artiﬁcial Intelligence 143 2003 151188 22 G Laporte FV Louveaux The integer lshaped method stochastic integer programs complete recourse Operations Research Letters 13 1993 23 C Le Pape Implementation resource constraints ILOG SCHEDULE A library development constraintbased scheduling systems Intelligent Systems Engineering 3 2 1994 5566 24 M Lombardi M Milano Scheduling conditional task graphs Proc CP 2007 2007 pp 468482 25 M Lombardi M Milano Stochastic allocation scheduling conditional task graphs MPSoCs Proc CP 2006 2006 pp 299313 26 VI Norkin G Pﬂug A Ruszczynski A branch bound method stochastic global optimization Mathematical Programming 83 1998 27 Organization Advancement Structured Information Standards OASIS Web Services Business Process Execution Language Version 20 OASIS Standard 2007 httpdocsoasisopenorgwsbpel20wsbpelv20html 28 MA Peot DE Smith Conditional nonlinear planning Proc Intl Conference AI Planning Scheduling 1992 pp 189197 29 MH RothKopf Scheduling random service times Management Science 12 1966 707713 30 N Russell WMP van der Aalst AHM ter Hofstede D Edmond Workﬂow data patterns Identiﬁcation representation tool support Proc 17th Intl Conference Advanced Information Systems Engineering 2005 pp 216232 31 D Shin J Kim Poweraware scheduling conditional task graphs realtime multiprocessor systems International Symposium Low Power Electronics Design ISLPED ACM 2003 pp 408413 32 WE Smith Various optimizer single stage production Naval Research Logistic Quarterly 3 1956 5966 33 A Tarim S Manandhar T Walsh Stochastic constraint programming A scenariobased approach Constraints 11 2006 5380 34 AHM Ter Hofstede M Weske Business process management A survey Proc 1st International Conference Business Process Management LNCS vol 2678 2003 pp 112 35 I Tsamardinos ME Pollack JF Horty Merging plans quantitative temporal constraints temporally extended actions conditional branches Proc 5th International Conference AI Planning Systems 2000 pp 264272 36 I Tsamardinos T Vidal ME Pollack CTP A new constraintbased formalism conditional temporal planning Constraints 8 4 2003 365388 37 T Vidal H Fargier Handling contingencies temporal constraint network consistency controllability Journal Experimental Theoretical Artiﬁcial Intelligence 11 1999 2345 38 P Vilim R Bartak O Cepek Extension log n ﬁltering algorithms unary resource constraint optional activities Constraints 10 2005 403425 39 Y Xie W Wolf Allocation scheduling conditional task graph hardwaresoftware cosynthesis Proc Design Automation Test Europe DATE2001 2001 pp 620625 40 T Walsh Stochastic constraint programming Proc European Conference Artiﬁcial Intelligence ECAI 2002 41 M Weske Business Process Management Concepts Languages Architectures Springer Berlin 2007 42 D Wu B AlHashimi P Eles Scheduling mapping conditional task graph synthesis low power embedded systems Computers Digital Techniques IEEE Proceedings 150 5 2003 262273