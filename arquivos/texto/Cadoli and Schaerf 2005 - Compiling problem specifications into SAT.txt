Artiﬁcial Intelligence 162 2005 89120 wwwelseviercomlocateartint Compiling problem speciﬁcations SAT Marco Cadoli Andrea Schaerf b Dipartimento di Informatica e Sistemistica Università di Roma La Sapienza Via Salaria 113 I00198 Roma Italy b Dipartimento di Ingegneria Elettrica Gestionale e Meccanica Università di Udine Via delle Scienze 208 I33100 Udine Italy Received 20 November 2001 accepted 21 January 2004 Available online 10 December 2004 Abstract We present compiler translates problem speciﬁcation propositional satisﬁability test SAT Problems speciﬁed logicbased language called NPSPEC allows deﬁnition complex problems highly declarative way expressive power capture problems belong complexity class NP The target SAT instance solved stateoftheart solvers available community The obtained executable speciﬁcation language NP problems shows interesting computational properties The performance tested classical problems graph coloring Hamiltonian cycle jobshop scheduling realworld scheduling application tournament scheduling problem 2004 Elsevier BV All rights reserved Keywords Automatic generation problem reformulation Executable speciﬁcations SAT problem NPcomplete problems This paper extended revised version Compiling problem speciﬁcations SAT appeared Proceedings European Symposium Programming ESOP 2001 Lecture Notes Computer Science vol 2028 Springer Berlin 2001 pp 387401 Corresponding author Email addresses cadolidisuniroma1it M Cadoli schaerfuniudit A Schaerf URLs httpwwwdisuniroma1itcadoli M Cadoli httpwwwdiegmuniuditschaerf A Schaerf 00043702 matter 2004 Elsevier BV All rights reserved doi101016jartint200401006 90 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 1 Introduction We present writing executing speciﬁcations search problems makes use NPSPEC highly declarative speciﬁcation language NPSPEC DATALOGlike syntax PROLOG function symbols Its semantics based notion model minimality extension wellknown leastﬁxedpoint seman tics Horn fragment ﬁrstorder logic 1 NPSPEC allows user express problem belonging complexity class NP 2 includes notorious prob lems interesting realworld applications Restriction expressiveness NP guarantees termination helps obtain efﬁcient executions The core compiler called SPEC2SAT translates problem speciﬁcations written NPSPEC instances propositional satisﬁability problem SAT An instance π original problem translated formula T propositional logic conjunctive normal form way T satisﬁable π solution Moreover constructs solution π variable assignments satisfy T A speciﬁcation S π set metarules deﬁning search space plus set rules deﬁning admissibility function Both metarules rules transformed set clauses T encoding semantics The translation rules based ground instantiation Herbrand universe Our algorithm instantiation uses complex auxiliary data structures avoid generation useless clauses insofar possible The approach translation SAT motivated huge research voted problem recent years 3 number fast solvers available research community Such solvers complete incomplete ones able solve instances hundreds thousands clauses seconds result inconceivable years ago In addition community working SAT active better better SAT solvers expected future SAT prototypical NPcomplete problem instance π problem NP translated instance SAT polynomial size size π In prac tice idea exploited number years problems planning 46 scheduling 7 theorem proving ﬁnite algebra 8 generation test patterns combinatorial circuits 9 cryptography 10 Those papers showed translating problem SAT good performance resulting compared stateoftheart dedicated solvers The shortcoming previous works translator completely hand problem Conversely aim automatically translates NP problem SAT simple declarative language NPSPEC In terms performance NPSPEC obviously outperform stateoftheart solvers wellstudied problems However believe valuable tool developing fast prototypes new problems variations known ones speciﬁc solver available Nevertheless experimental results able solve medium size instances classical problems reasonable time In addition works faster original NPSPEC engine 11 based translation input speciﬁcation logic programming language PROLOG M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 91 The paper organized follows In Section 2 introduce language NPSPEC recall state art SAT technology In Section 3 compiler In Section 4 illustrate performance problems graph color ing Hamiltonian cycle jobshop scheduling tournament scheduling Related work discussed Section 5 Finally Section 6 draw conclusions discuss future work 2 Preliminaries 21 Overview NPSPEC language As ﬁrst example NPSPEC program Hamiltonian path NP complete problem 2 Prob GT39 p 199 problem input graph question traversal exists touches node exactly DATABASE n 6 edge 12312362564535 nodes SPECIFICATION 1441 Permutation1npath fail pathXP pathYP1 NOT edgeXY H1 H2 The following comments order The input graph deﬁned DATABASE section generally provided separate ﬁle In search space declaration metarule H1 user declares predicate symbol path guessed implicitly arity 2 All predicate symbols default guessed Being guessed means admit extensions predicate subject constraints path declared permutation ﬁnite domain 1n This means extension represent permutation order 6 As example 1 5 2 3 3 6 4 2 5 1 6 4 valid extension Comments inserted symbol Rule H2 constraint permutations obey order Hamiltonian paths permutation fails valid nodes X Y adjacent permutation connected edge X Y adjacent hold places P P1 permutation respectively Running program NPSPEC compiler produces following output path 1 1 2 5 3 6 4 2 5 3 6 4 means 1 ﬁrst node path 4 second node path 3 sixth node path Hamiltonian path 92 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 More formally NPSPEC program consists DATABASE section SPEC IFICATION section cf Appendix A complete syntax The DATABASE section includes Deﬁnition extensional relations kind r t1tn r input relation ti tuple arity r The constant symbols allowed tuples integers strings Deﬁnition constants The SPECIFICATION section consists parts A search space declaration corresponds deﬁnition domain guessed predicates In basic NPSPEC sequence declarations form 1 Subsetdomain predicate_id 2 Permutationdomain predicate_id 3 Partitiondomain predicate_id n 4 IntFuncdomain predicate_id minmax predicate_id guessed predicate domain ﬁnite set deﬁned input relation enumeration means union intersection difference Cartesian product domain identiﬁes domain extension predicate guessed Subset arity predicate_id In cases predicate_id guessed predicate arity equal arity domain plus 1 Such declaration means predicate_id extensions ﬁrst arguments coincide member domain depends metapredicate In particular For Permutation extension predicate_id represent bijec tive function domain interval 1c c cardinality domain Declarations metapredicate Partition integervalued argu ment n states number subsets domain partitioned The extension predicate_id represent function domain interval 1n argument element interval Subset special case Partition n 2 syn tax different declaration Subsetdomain predicate_id im plies arity predicate_id equals arity domain The metapredicate IntFunc generalization Partition model functions domain interval minmax min max integers Since IntFunc generalizes Partition Subset strictly necessary Nevertheless usage improves readability speciﬁcation A stratiﬁed DATALOG program possibly include predeﬁned relational operators negative literals form NOT A A atom Strat M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 93 iﬁcation introduces restricted form negation allowing negative literals body rules 12 Intuitively program stratiﬁed predicate deﬁned recur sively negation More formally precedence graph contain cycle negative edge Such graph contains node predicate symbol positive negative edge node A node B A occurs positively negatively body rule B head This includes rules necessary specifying problem rules fail head Another example concerns famous nqueens problem goal place n nonattacking queens n n chessboard The NPSPEC program 12queens following DATABASE nb_queens 12 SPECIFICATION Permutation1nb_queens queens queensRC queen row Rcolumn C fail queensR1C1 queensR2C2 2 queens attacking R1 R2 R1 R2 C1 C2 SENW diagonals fail queensR1C1 queensR2C2 2 queens attacking R1 R2 R1 R2 C2 C1 NESW diagonals Also case declare queens guessed predicate arity 2 search space declaration Declaring permutation rules attacks row column The example shows arithmetical operators allowed As example graph coloring NPcomplete problem 2 Prob GT4 p 191 input graph G positive integer k representing number available colors question possible node G color way adjacent nodes colored way The intuitive structure search space case partition nodes G k distinct subsets assignment nodes colors guessed The NPSPEC program checking colorability DATABASE k 3 n 6 edge 12312362564535 colors nodes SPECIFICATION Partition1ncoloringk fail edgeXY coloringXC coloringYC GC1 GC2 Another typical structure search space integer function assignment value speciﬁed domain set variables As example quadratic Diophantine equations problem 2 Prob AN8 p 250 input given positive integers b c question integer solution equation ax2 c In NPSPEC program following declare considering assignments x y range 10100 94 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 DATABASE 5 b 3 c 1874 SPECIFICATION IntFuncxyassign10100 fail assignxXval assignyYval c aXval2 bYval Finally present speciﬁcation 3SAT problem SAT problem 2 Prob L01 p 259 cf Section 24 clause exactly literals In case want guess subset variables assign value true variables implicitly assigned value false DATABASE n 100 clauseL1L2L3 L1 L2 L3 literals clause clause 21 40 11 37 88 6 28 1 94 SPECIFICATION Subset1ntrue valLVS L literal V corresponding variable S opposite sign L V truth value S L false valLL0 L 0 valLV1 L 0 V L assignV0 NOT trueV assignV1 trueV fail clauseL1L2L3 valL1V1S1 valL2V2S2 valL3V3S3 assignV1S1 assignV2S2 assignV3S3 We remark declarative style programming NPSPEC similar DATALOG easy extend programs incorporating constraints As example program Hamiltonian path extended Hamiltonian cycle problem 2 Prob GT37 p 199 adding following rule fail pathXn pathY1 NOT edgeXY H3 Moreover undirected graphs handled including literal NOT edgeYX body rules H2 H3 Concerning syntax remark NPSPEC offers useful SQLstyle aggregates SUM COUNT MIN MAX They discussed paper considered current implementation 11 syntax semantics M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 95 22 Formal properties NPSPEC The formal properties NPSPEC explained 11 brieﬂy recalled The semantics NPSPEC program explained twostep process First syntactic sugar eliminated speciﬁcation result set metarules containing Subset metapredicate corresponding reformulation rules As example concerning speciﬁcation nqueens problem shown metarule containing Permutation metapredicate rewritten Subset guessing possible pairs consisting row column Since guaranteed queens attacking row column set appropriate rules enforcing constraints added As second step brieﬂy recall couple elementary notions The Herbrand universe U NPSPEC program S set constant symbols oc curring S The Herbrand base S set pe1 en p predicate symbol arity n S e1 en U An interpretation S subset Herbrand base interpretation satisﬁes rules S obvious meaning im plication model S Some models selected minimal respect speciﬁc criterion based generalization wellknown minimal model semantics deﬁned 1 called P Qminimal model semantics 13 Intuitively P Qminimal model semantics introduces partial order interpretations interpretations assigning extension guessed predicates comparable guarantees possible choices guessed predicate taken account The partial order states comparable extensions smaller extension nonguessed predicate preferred guaran tees atoms head rules true reason Finally P Qminimal models S assign false fail considered guarantees constraints S satisﬁed The answer S mod els As computational properties data complexity NPSPEC com plexity query answering measured size input extensional database NPcomplete The expressiveness NPSPEC language captures NP This formally proven 11 resorting Fagins famous theorem 14 states speciﬁcation problem NP complexity class stated formula existential secondorder logic ESO interpreted ﬁnite database conversely formula ESO corresponds speciﬁcation problem NP The proof shows ESO formula problem NP A ﬁxed databasefree NPSPEC program SP instance db A encoded input database DB holds SP DB returns solution db yes instance A A consequence fact speciﬁcation NPSPEC capable speci fying exactly problems belonging NP We note conversely DATALOG capable specifying strict subset polynomialtime problems For example express query input domain C objects question Is cardinality C 96 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 23 PROLOGbased compilation The ﬁrst implementation NPSPEC ECLi PSe 15 PROLOG engine integrated extensions The compiler takes ﬁles containing speciﬁcation sec tion S containing database section D NPSPEC program analyzes produces description search space constraints corresponding S list facts corresponding D PROLOG format Such PROLOG ﬁle merged programindependent header form ECLiPSe target program ﬁle The programindependent header contains PROLOG rules traversing search space purely enumerative fashion constraint propagation pruning At point search space constraints corresponding rules NPSPEC pro gram evaluated As example search space nqueens problem ECLi PSe runtime starts generating n possible permutations stops soon ﬁnds permutation constraints satisﬁed This approach allowed obtain fast implementation relies uniﬁcation mechanisms typical PROLOG As example easy implement arithmetical expressions readily translated ECLiPSe As efﬁciency able solve toysize instances NPcomplete problems owing naivety algorithm traversing search space In present paper presenting approach differs search space considered way traversed As examplemore details given following sectionsthe nqueens problem automatically translated propositional formula containing n2 variables satisﬁability checked SAT solver The search space composed possible assignments propositional variables traversed efﬁcient manner powerful constraint propagation mechanism typical SAT solvers 24 SAT technology A propositional formula conjunctive normal form CNF set clauses clause set literals A literal propositional variable negation propositional variable Sometimes formula CNF referred conjunction clauses clause disjunction literals The vocabulary V T formula T set propositional variables occurring T An interpretation T assignment Boolean value true false variable V T A model T interpretation assigns true T usual semantical rules interpretation negation disjunction conjunction The SAT problem input formula T CNF question T satisﬁable model Algorithms SAT problem complete model guaranteed ﬁnd incomplete fail ﬁnd model The main complete algorithms SAT based famous DPLL procedure 16 17 differ lot heuristics variable selection The relatively simple mechanism constraint propagation DPLL implemented ef ﬁcient way gives surprisingly good results Complete algorithms able solve SAT instances hundreds variables thousands clauses M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 97 worst conditions socalled crossover point 18 Such point refers particular random generation CNFs determined experimentally point probability formula satisﬁable equals probability unsatisﬁable As instances SAT randomly generated size formulae dealt typically larger Generally incomplete algorithms faster complete ones Most popular algorithms GSAT WALKSAT 19 based randomized local search Many solvers publicly available WWW cf 20 use DIMACS 3 input format text ﬁle containing clause line line contains positive resp negative integer positive resp negative literal terminated 0 Although performed preliminary tests solvers experiments presented Section 4 DPLLbased complete SATZ described 21 3 Compilation SAT Our entirely written C general architecture shown Fig 1 The module PARSER receives text ﬁle containing speciﬁcation S NPSPEC parses builds internal representation The module SPEC2SAT compiles S CNF formula T DIMACS format builds object representing dictionary makes 11 correspondence ground atoms Herbrand base S propo sitional variables vocabulary V T The ﬁle DIMACS format given input SAT solver delivers text ﬁle containing model T satisﬁable indication unsatisﬁable At point MODEL2SPEC module performs ing dictionary backward translation model original language speciﬁcation In current version allow aggregates recursion negative occurrences deﬁned predicates NPSPEC It important note syntactic restrictions Fig 1 Architecture NPSPEC compilation execution environment 98 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 limit expressive power NPSPEC express complexity class NP 22 readability efﬁciency speciﬁcation affected In rest section focus SPEC2SAT module important We start general description algorithm present main optimizations introduced 31 Basic algorithm SPEC2SAT Formally SPEC2SAT module receives input NPSPEC speciﬁcation S cid4DB SPcid5 outputs propositional formula T CNF T satisﬁable answer S yes T satisﬁable model T corresponds solution S As example concerning graph coloring cf Section 21 Fig 2 shows input graph supposed 3colored corresponding dictionary b DIMACS ﬁle generated c In case n 4 nodes k 3 possible colors chosen number colors greater minimum translation inter esting The graph obviously 3colorable corresponding SAT instance satisﬁed assigning true propositional variables 1 2 3 4 8 11 13 coloring nodes 1 4 color 0 nodes 2 3 color 1 4 5 0 4 6 0 5 6 0 4 5 6 0 7 8 0 7 9 0 8 9 0 7 8 9 0 10 11 0 10 12 0 11 12 0 10 11 12 0 13 14 0 13 15 0 14 15 0 13 14 15 0 b 1 0 2 0 3 0 16 1 4 7 0 16 2 4 10 0 16 3 7 13 0 16 1 5 8 0 16 2 5 11 0 16 3 8 14 0 16 1 6 9 0 16 2 6 12 0 16 3 9 15 0 16 0 c d c NPSPEC var kind atom edge12 edge13 edge24 coloring10 coloring11 coloring12 coloring20 coloring21 coloring22 coloring30 coloring31 coloring32 coloring40 coloring41 coloring42 fail 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 b α β γ Fig 2 Example output SPEC2SAT module Problem instance b Dictionary c CNF formula clauses kinds b c d M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 99 Obtaining vocabulary V T starting speciﬁcation S principle easy need compute Herbrand base S deﬁne set propositional variables 11 However vocabulary unnecessarily large cases For example ground instantiations predicate DB facts database neglected building vocabulary V T The basic idea construction V T complex techniques described subsection consider propositional variables kinds α variable fact DB β variable ground instantiation guessed predicate elements relevant domain γ variable ground instantiation predicates Fig 2b shows kinds variables graph coloring instance In particular coloring predicate n k 12 atoms kind β predicate DB guessed fail We turn attention set clauses T Such clauses belong distinct classes A clause c variable c kind α Such clauses state fact DB true b Clauses variables kind β encoding meaning corresponding metarule Such clauses express propositional logic structure search space permutation c Clauses variables kind α β γ encoding meaning rules SP Such clauses express constraints speciﬁcation d The clause fail states looking truth assignments constraints satisﬁed As clauses kind c body rule contains relational operator cf quadratic Diophantine equations problem Section 21 expression containing operator evaluated processed true clause generated clause discarded Fig 2c shows sets clauses current example In particular rule GC2 originates clauses kind c metarule GC1 Partition1ncoloring k originates clauses kind b following subkinds coloringr c1 coloringr c2 r 1n 1 c1 c2 0k 1 c1 cid8 c2 coloringr 0 coloringr k 1 r 1n 2 Set 1 states n nodes color 0 k 1 set 2 node color interval In general metarule 100 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 like Partitiondomain predicate_id k generates n k variables On k2 clauses like 1 2 n size domain As metapredicates Permutation IntFunc Subset appropriate sets variables kind β clauses kind b encoding meaning propositional logic As example metarule H1 Permutation1n path Hamiltonian path speciﬁcation cf Section 21 originates following sets clauses kind b pathr 1 pathr n r 1n pathr c1 pathr c2 r c1 c2 1n c1 cid8 c2 pathc1 r pathc2 r r c1 c2 1n c1 cid8 c2 3 4 5 Set 3 states n nodes n places order Set 4 states node place Finally set 5 states place node Since clauses logically imply place node need explicitly state In general metarule like Permutationdomain predicate_id generates n2 variables On3 clauses like 35 n size domain Alternative ways encode problems based permutations similar structures discussed Section 5 For sake completeness set variables clauses generated metarules A metarule like IntFuncdomain predicate_id minmax generates following sets clauses predicate_idr c1 predicate_idr c2 r 1n c1 c2 minmax c1 cid8 c2 predicate_idr min predicate_idr max r 1n 6 7 The metarule generates n max min 1 variables On max min 12 clauses like 6 7 n size domain A complex example involving metapredicate given Section 43 Finally metarule Subsetdomain predicate_id cf 3SAT example Section 21 generates n variables clauses imply constraint 32 Optimization SPEC2SAT In subsection optimizations implemented order obtain propositional formula T small possible shortest time First simpliﬁcations T obvious example unary clauses kinds d eliminated better generated Clearly implies clauses literals occur beaccording signeither shortened eliminated M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 101 321 Reducing number clauses The ﬁrst optimizations consider involve clauses kind c based elimination useless variables kind γ Since optimizations apply simple speciﬁcations graph coloring turn abstract examples For example let consider following rule pXYZ qXY sYZW rZW 8 Since distinct NPSPEC variables occurring rule principle T contain clause U 4 ground instantiations This obviously impractical Herbrand universe U sufﬁciently large U 100 Our goal avoid instantiations information plausible ex tensions predicates As example rule instantiations rule knew relevant instantiations predicate s Unfortunately possible easily know relevant instantiations predicates DB corresponding variables kind α guessed predicates kind β For deﬁned predicates corresponding variables kind γ use auxiliary data structures First build dependency graph G SP The nodes G predicates SP edge q p SP rule p head q body Since relational operators evaluated processed speciﬁc mechanism correspond nodes Predicates SP naturally partitioned subsets primitive sources G predicates DB guessed predicates deﬁned occur head rule Note special predicate fail deﬁned actually sink G Note G DAG recursion allowed As example Fig 3 dependency graph speciﬁcation 3SAT problem cf Section 21 Basically predicates processed time Each predicate contributes V T set propositional variables indirectly T set clauses The order processed given according topological sort G node processed predecessors processed cf 23 In particular primitive predicates processed ﬁrst They straightforward deal taken account clauses kinds b As deﬁned predicate p assumption considered predicates occurring body rules p head considered Fig 3 Dependency graph speciﬁcation 3SAT problem 102 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 important cases discard instantiations rules As example rule 8 s DB predicate consider value assignments Y Z W correspond facts DB instead U 3 assignments Generalizing idea introduce notion alive ground instantiations predicates In particular set alivep subset Herbrand base ground stances p deﬁned following way p primitive predicate alivep set ground instantiations correspond ing variables kinds α β p deﬁned predicate alivep recursively deﬁned set atoms occurring head ground instances rules p head positive literals body alive Our algorithm traverses G following topological sort topological sort unique sort ensures predicates body rule processed predicate head algorithm works way The choice order nodes visited affect performance algorithm processing predicate occurring head rule predicates occurring body evaluated When predicate p analysis set alivep built clauses kind c corresponding instantiations rules p head generated Referring example rule 8 consider value assignments NPSPEC variables X Y W Z according aliveq alives aliver 322 Partial rule instantiation The technique reduces size generated propositional formula T We optimization reduce size formula generates shorter time This technique concerns way assignments NPSPEC variables occurring rule speciﬁcation generated As previously mentioned number n dis tinct variables rule crucial parameter worst case U n variable assignments taken account process variable instantiation In simple speciﬁcations n large 10 cf ﬁrst rule speciﬁcation job shop scheduling Section 43 The size U Herbrand universe depends instance size greater 100 common As consequence important avoid simpleminded enumeration variable assignments To aim use backtrackingbased algorithm rule n distinct variables occur explores tree depth n uses sets alive pruning search At step algorithm considers partial assignment assignment subset m variables m n For example referring rule 8 Z W assigned 2 7 r2 7 aliver useless consider assignments variables X Y In addition relational operators evaluated soon operands instantiated algorithm backtracks soon expression involving relational operator evaluated false body rule false M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 103 323 Inlining predicates A idea dramatically improved performance compiler concerns special treatment named inlining predicates ﬁrst step Potentially predicate inlined know exactly possible instantiations happens example predicates DB deﬁned DB relational operators These ﬁxedextension predicates extension evaluated resorting guessed predicates We predicates inlineable example inlineable predicate predicate val speciﬁcation 3SAT Section 21 From denote extension inlineable predicate extP The inlining predicate d works follows positive occurrence d instan tiated possible ways instantiating corresponding variables The corresponding rule replicated possible instantiations Moreover d DB occurs positively bodies completely eliminated DB As example consider following speciﬁcation fragment p DB pred icate DATABASE p 123245467 SPECIFICATION rXWT pXYZ pYVW qZVT R1 If p declared inline rule replaced set rules obtained possible instantiation p In ﬁrst step inlining process replace ﬁrst occurrence literal p yielding following set rules rules ﬁrst occurrence p uniﬁed different ways atoms DB r1WT p123 p2VW q3VT r2WT p245 p4VW q5VT r4WT p467 p6VW q7VT In second step replace literal pYVW obtaining following rules second occurrence p uniﬁed different ways atoms DB r15T p123 p245 q34T R2 r27T p245 p467 q56T R3 The occurrences p R2 R3 removed In addition p appear negatively rule SP end inlining process predicate p removed The resulting speciﬁcation following DATABASE p removed 104 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 SPECIFICATION r15T q34T R4 r27T q56T R5 The order literals inlined affect efﬁciency translation In order number intermediate rules small possible ﬁrst inline literals predicate smallest extension Although inlining process general increases number rules speciﬁ cation beneﬁcial effect number distinct NPSPEC variables rule discussed crucial parameter variables eliminated As example jobshop scheduling speciﬁcation Section 43 8 cluding 3 mute ones 10 variables ﬁrst rule eliminated inlining predicate task 324 The complete algorithm We end section giving outline algorithm SPEC2SAT accounts features described The module SPEC2SAT corresponds 2500 lines C code For sake readability modularized algorithm deﬁning auxiliary procedures Algorithm SPEC2SAT Input speciﬁcation S cid4DB SPcid5 aggregates recursion negative occurrences deﬁned predicates Output CNF formula T T satisﬁable answer S yes T satisﬁable model T corresponds solution S begin step 0 preliminary deﬁnitions set clauses T int n number predicate symbols occurring S array subsets Herbrand base aliven G dependency graph SP TS topological sort G predicate symbol p occurring S alivep step 1 perform inlining S PerformInliningS step 2 deal primitive predicates cid4T alive cid5 ProcessPrimitivePredicatesS T alive step 3 deal deﬁned predicates T ProcessDeﬁnedPredicatesS T alive return T end SPEC2SAT M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 105 Procedure PerformInlining Input speciﬁcation S cid4DB SPcid5 restrictions SPEC2SAT apply Output modiﬁed speciﬁcation S equivalent input begin set predicates I inlineable predicates SP predicate d I following order TS begin rule r SP d occurs begin fact da st extd begin r cid10 instantiation r SP SP r cid10 end fact da st extd SP SP r end rule r SP d occurs d occurs positively rules SP eliminate d SP end predicate d I return S end PerformInlining Procedure ProcessPrimitivePredicates Input speciﬁcation S cid4DB SPcid5 restrictions SPEC2SAT apply set clauses T array subsets Herbrand base alive Output modiﬁed pair cid4T alive cid5 encoding semantics primitive predicates begin predicate d DB begin alived da da DB T T alived end predicate d DB guessed predicate q deﬁned metaclause m SP begin aliveq ground instantiations deﬁned m m declares Partition T T propositional encoding m deﬁned clauses form 12 m declares Permutation T T propositional encoding m deﬁned clauses form 35 m declares IntFunc T T propositional encoding m deﬁned clauses form 67 end m declares 106 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 end guessed predicate q deﬁned metaclause m SP return cid4T alive cid5 end ProcessPrimitivePredicates Procedure ProcessDeﬁnedPredicates Input speciﬁcation S cid4DB SPcid5 restrictions SPEC2SAT apply set clauses T array subsets Herbrand base alive Output modiﬁed set clauses T encoding semantics deﬁned predicates begin deﬁned predicate p following order TS begin rule r p head begin instantiation σ variables occurring r actually partial instantiations considered backtrackinglike algorithm begin r cid10 instantiation r σ pw head r cid10 atom body r cid10 t alivea begin alivep alivep w T T r cid10 end end instantiation σ variables occurring r end rule r p head end deﬁned predicate p following order TS return T end ProcessDeﬁnedPredicates 4 Performance considerations In section discuss effectiveness solution NPcomplete problems It obvious terms performance outperform stateoftheart solvers original problems In fact meant mainly developing executable speciﬁcations effective program development The main emphasis work obtaining simple readable speciﬁcations activity NPSPEC typically takes hours minutes On hand implementing efﬁcient solver new problem NP weeks months Nevertheless wish able solve mediumsize instances classical hard problems Conversely algorithm original PROLOG engine NPSPEC able solve small instances We believe ability solve non trivial cases helps user better understanding herhis application capture aspects problem fail appear small instances M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 107 In following subsections analyze performance prob lems graph coloring Hamiltonian cycle job shop scheduling tournament scheduling Experiments use solver SATZ run AMD Athlon 1533 MHz PC running Linux GNU g compiler version 296 Times expressed seconds CPU use The total time ﬁnding solution sum compilation time t1 time t2 needed SAT solver SATZ We remark asymptotically t1 polynomial size input t2 exponential worst case Nevertheless cases t1 t2 generated CNF large models 41 Graph coloring The speciﬁcation graph coloring problem provided Section 21 Given graph G n nodes e edges k colors compilation metarule GC1 generates formula n k propositional variables pair cid4nodecid5 cid4colorcid5 The formula contains On k2 clauses kind b state node exactly color The rule GC2 adds e k clauses kind c forbid adja cent nodes color cf Fig 2c For experimentation use set instances taken DIMACS benchmark repository In particular select family DSJC randomlygenerated graphs proposed 24 Table 1 reports results The table shows able solve large instances In case instance DSJC1251 able prove minimality k 5 This result obtained proving unsatisﬁability formula generated 4 colors ﬁrst line table Conversely instances solution constrained instance number colors larger minimum provided parenthesis 42 Hamiltonian cycle The speciﬁcation Hamiltonian cycle problem provided Sec tion 21 Table 1 Performance graph coloring problem Graph 1251 1251 1255 2501 2505 5001 10001 Nodes Edges 125 125 125 250 250 500 1000 736 736 7782 3218 31336 12456 49629 Colors min 4 5 5 21 16 9 9 39 27 16 14 26 19 Colorable NO YES YES YES YES YES YES Compile time 07 033 653 749 5856 5782 45912 SAT time 008 005 1616 134 6476 2303 663 Variables Clauses 500 625 2625 2250 9750 8000 26000 3819 5055 108086 41430 796552 272286 1665983 108 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 Table 2 Performance Hamiltonian cycle problem Nodes Edges Cycle Compile time Avg SAT time Variables Clauses 15 15 15 15 17 17 17 17 20 20 20 20 30 60 60 90 35 70 70 105 43 86 86 130 NO NO YES YES NO NO YES YES NO NO YES YES 022 022 022 022 030 030 030 030 051 051 051 051 13133 024 009 102 014 7682 225 225 225 225 289 289 289 289 400 400 400 400 6090 5640 5640 5190 8976 8364 8364 7752 14780 13900 13900 13020 Given graph G n nodes e edges resulting SAT formula n2 variables On3 clauses In fact compilation generates propositional variable fact form pathij j ranging 1 n The number clauses generated metapredicate Permutation On3 cf set clauses 35 The number clauses generated rules H2 H3 depends e In extreme cases complete graph clauses exactly n3 clauses respectively generated We tested random instances It known 25 difﬁcult ran dom instances obtained number edges e equal p n log n2 p socalled crossover point half instances solution We consider graphs e p taking account solvable unsolvable instances In addition consider graphs far point solvable instances e 3p2 unsolvable ones e p2 Table 2 shows average results 5 instances n 15 17 20 p 60 70 86 respectively The symbol means SATZ terminate half hour instance We note compilation fast SAT solver slow In fact solver able easily handle satisﬁable instances n 15 17 Unsatisﬁable instances solved slowly SATZ easy instances original problem For larger instances solver inefﬁcient satisﬁable cases totally ineffective unsatisﬁable ones Experiments SAT solvers provide similar results current solvers Hamiltonian cycle problem able solve larger instances easily cf 26 Therefore conclude translation SAT encoding effective problem 43 Job shop scheduling Job shop scheduling 2 Prob SS18 p 242 popular NPcomplete scheduling problem In job shop scheduling n jobs m tasks p processors Jobs ordered collections tasks task integervalued length processor M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 109 performs Each processor perform task time tasks belonging job performed order Finally global deadline D met jobs In NPSPEC problem speciﬁed follows DATABASE nb_tasks 36 D 55 instance FT06 taskTJPoPrL task T belongs job J position Po runs processor Pr length L task 11121 21263 31316 366621 SPECIFICATION start_timeTS task T starts time S IntFunc1nb_tasksstart_time0D1 tasks T1 T2 job J ordered correctly fail start_timeT1 S1 taskT1 J Po _ L1 start_timeT2 S2 taskT2 J Po 1 _ _ S2 S1 L1 overlap tasks processor fail start_timeT1 S1 taskT1 _ _ Pr L1 start_timeT2 S2 taskT2 _ _ Pr L2 T1 T2 S1 S2 S2 S1 L1 fail start_timeT1 S1 taskT1 _ _ Pr L1 start_timeT2 S2 taskT2 _ _ Pr L2 T1 T2 S2 S1 S1 S2 L2 meet deadline fail start_timeT1 S1 taskT1 _ _ _ L1 L1 S1 D Compilation NPSPEC ﬁle generates SAT instance m D propositional variables Regarding number clauses quadruple cid4t1 t2 j cid5 formed tasks t1 t2 time points j clause rules prohibits t1 start t2 start j jointly This number clauses Om2 D2 actual value depends relative length tasks belong job processor Many benchmark instances available problem sizes range 36 1000 tasks We consider relatively small instances known FT06 36 tasks 6 jobs 6 processors solvable deadline 55 LA02 50 tasks 10 jobs 5 processors solvable deadline 655 available OR library httpwwwmsicacukinfohtml As shown Table 3 ﬁrst instance solved easily proof deadline optimal solution deadline 54 fast Unfortunately second instance SAT instance generated billion clauses big solved current solvers In order ﬁnd approximate solution create new instance called LA02r lengths divided 20 rounded This corresponds reducing granularity problem allowing starting times divisible 20 The smallest deadline LA02r D 43 corresponds 860 43 20 LA02 This result took long time looser deadlines D 46 48 50 problem solved quicker We remark 110 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 Table 3 Performance job shop scheduling problem Instance Tasks Deadline Solvable Compile time SAT time Variables Clauses FT06 FT06 LA02 LA02 LA02 LA02 36 36 50 50 50 50 54 55 860 920 960 1000 NO YES YES YES YES YES 753 789 902 934 987 1027 1728 457 73217 11998 2326 360 1944 1980 2150 2300 2400 2500 203792 214034 201813 228929 236508 257745 minimum value deadline instance 655 stateoftheart solvers ﬁnd solutions 700 Summing results job shop scheduling critical factors compilation times size SAT formula obtained Conversely solution formulae relatively fast compared size We remark optimization steps described Section 32 instances Table 3 compiled SPEC2SAT 24 hours 44 Tournament scheduling As ﬁnal example propose real world problem speciﬁcation complex classical academic problems proposed far The Tournament Scheduling problem consists assigning matches rounds roundrobin tournament sport league Many different versions problem proposed literature We specify version solved 27 However given problem 27 optimization problem omit objective function focus underlying search problem We given 2n teams tournament pattern complete roundrobin tournament numbers 1 2n teams An example pattern 2n 6 given Fig 4 order teams determines location match The ﬁrst team plays home second away The problem consists ﬁnding matching actual teams numbers called dummy teams appearing pattern The matching satisfy following general constraints Round 1 Round 2 Round 3 Round 4 Round 5 16 62 36 64 56 25 31 42 53 14 43 54 15 21 32 Fig 4 A pattern 2n 6 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 111 Complementarity Teams t1 t2 complementary schedules For round r t1 plays home r t2 plays away r t1 plays away r t2 plays home r Availability Team t play away round r NoMating Team t1 play home team t2 round r Triplets Three teams t1 t2 t3 simultaneously home round Besides general ones second group constraints pre supposes prior notions We teams members subset teams composed strongest teams require special treatment We match match teams We distance matches number rounds place The constraints following Top matches schedule For given set rounds R match place round r R Top matches distance Two matches place distance smaller given value TopMatchDistance Top opponent distance Any team match teams distance smaller given value TopOpponentDistance A sample instance NPSPEC following DATABASE nb_teams 6 top_match_distance 1 top_opponent_distance 1 patternRD1D2 D1 D2 play round R D1S home stadium pattern 116 125 143 262 231 254 336 342 315 464 453 421 556 514 532 no_matingRT1T2 T1 T2 play round R T1s home no_mating 112 346 unavailableRT1 T1 play home round R unavailable 1135 tripletT1T2T3 T1 T2 T3 home triplet 146 complementary_teams 34 top_teams 12 forbidden_rounds_for_top_matches 15 112 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 The speciﬁcation NPSPEC following For sake readability variables denoting dummy teams named D D1 D2 variables denoting actual teams named T T1 T2 variables denoting rounds named R R1 R2 SPECIFICATION assignmentDT D assigned T Permutation1nb_teams assignment rule 1 mating constraints fail no_matingRT1T2 assignmentD1T1 assignmentD2T2 patternRD1D2 rule 2 availability constraints fail unavailableRT1 assignmentD1T1 patternRD1_ rule 3 triplet constraints fail tripletT1T2T3 assignmentD1T1 assignmentD2T2 assignmentD3T3 patternRD1_ patternRD2_ patternRD3_ rules 4 5 definition noncomplementary pairs dummy teams overlapping_dummy_teamsD1D2 patternRD1_ patternRD2_ overlapping_dummy_teamsD1D2 patternR_D1 patternR_D2 rule 6 complementarity constraints fail complementary_teamsT1T2 assignmentD1T1 assignmentD2T2 overlapping_dummy_teamsD1D2 rules 7 8 definition separation rounds separationR1R2D R1 R2 R1 R2 D separationR1R2D R2 R1 R2 R1 D rule 9 matches distance constraints fail top_teamsT1 top_teamsT2 top_teamsT3 top_teamsT4 T1 nb_teams T2 T3 nb_teams T4 T2 nb_teams T1 T3 nb_teams T4 assignmentD1T1 assignmentD2T2 assignmentD3T3 assignmentD4T4 patternR1D1D2 patternR2D3D4 separationR1R2top_match_distance rules 10 11 definition game dummy teams regardless order M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 113 gameRD1D2 patternRD1D2 gameRD1D2 patternRD2D1 rule 12 matches schedule constraints fail top_teamsT1 top_teamsT2 forbidden_rounds_for_top_matchesR assignmentD1T1 assignmentD2T2 gameRD1D2 rule 13 opponent distance constraints fail top_teamsT1 top_teamsT2 NOT top_teamsT3 T1 T2 assignmentD1T1 assignmentD2T2 assignmentD3T3 gameR1D1D3 gameR2D2D3 separationR1R2top_opponent_distance In speciﬁcation extensive use deﬁned predicates In particular overlapping_dummy_teams representing fact dummy teams complementary separation representing minimum distance rounds game representing matches dummy teams matter order Notice rule 9 conditions T1 nb_teams T2 T3 nb_teams T4 T2 nb_teams T1 T3 nb_teams T4 state unordered pair T1T2 different unordered pair T3T4 Note condition T1 T2 rule 13 This small concession efﬁciency looser condition T1 T2 correct generates duplicate clauses We experiment real instances 27 2n 18 perturb data order understand behavior translation different condi tions The important parameters turned surprisingly number teams values top_match_distance top_opponent_distance Table 4 shows results values parameters keeping data normal values The symbol means SATZ terminate half hour The specialized solver 27 sensitive parameters takes 3 seconds 3 minutes solve types instances Table 4 Performance tournament scheduling problem 2n 18 Number teams Top match distance Top opponent distance Compile time SAT time Variables Clauses 0 2 2 3 3 1 1 1 1 1 2 1 2 233 248 714 322 988 034 032 038 324 324 324 324 324 18315 19035 33179 19935 59715 114 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 Table 4 shows rapidly solve instances special constraints large number satz unable ﬁnd solution This result somewhat conﬁrms problems involving permutations like Hamil tonian cycle difﬁcult solve satz 45 Further considerations As ﬁnal comment analysis notice compilation execution perfor mance completely independent different problem problem In cases Hamiltonian path compilation faster solving SAT instance graph coloring comparable The cost compilation depends number rules number variables rule size Herbrand universe Conversely cost solver depends combinatorial structure instance Obviously speciﬁcation play important role For example job shop scheduling speciﬁed different way based permutations tasks processor Such alternative speciﬁcation result different performance numbers In order understand overhead introduced SPEC2SAT conclude section brieﬂy analyzing behavior translation 3SAT problem cf Section 21 We compare running times sizes input output formulas Recalling speciﬁcation Section 21 n c number propositional variables number clauses input formula DATABASE section We ﬁrst realize output formula 3n variables n predicate true 2n predicate assign No variable created predicate val inlined removed The number clauses 2n c given 2n generated behavior predicates true assign truel NOT truel true clauses onetoone correspondence clauses original formula We shown overhead terms space linear number variables Experiments running times satz solving input output formulas close For example instances n 260 c 1118 running time output formula average 25 times higher running time input formula A analytical comparison possible stage given use solver black box 5 Related work Other researchers proposed DATALOGlike languages problem speciﬁcation The main difference NPSPEC languagesnotably DLV 28 SMODELS 29is semantics based notion model minimality Alloy Analyzer reasoning extension ﬁrstorder logic based translation SAT proposed 30 The main difference respect NP M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 115 SPEC Alloy Analyzer general decidability guaranteed consequently user supply bound number atoms universe Regarding encoding work general mechanism creates propositional variable element Herbrand base This choice ensures required generality expressing kind problems However speciﬁc struc tures search space possible resort ad hoc encodings likely allow efﬁcient search strategies average case We want discuss differ ences approach respect manual translations problems considered Section 4 Crawford Baker 7 propose ad hoc SAT encoding generalization job shop scheduling problem cf Section 43 socalled machine shop scheduling problem 31 The generalization consists taskordering machinecapacity constraints having general form job shop ﬁxed form given job structure chains tasks onejobatthetime behavior machines The encoding Crawford Baker creates 2mp variables pair t represents fact t starts later represents fact t ends earlier In addition include set m m 12 variables called precedence variables pair tasks t1 t2 state processed ﬁrst Crawford Baker discuss encoding generated SPEC2SAT creates variable pair tasktime point called obvious claim encoding efﬁcient This probably presence precedence variables guide search feasible assignments claim explained supported paper Iwama Miyazaki 32 propose speciﬁc SAT translation Hamiltonian cycle cf Section 42 Unlike SPEC2SAT algorithm translation based binary encoding integer variables Therefore produce formula number variables logarithmic respect produced Spec2Sat The IwamaMiyazaki translation Hoos 33 study performance solver GSAT instances obtained translation Hamiltonian cycle Hoos shows instances generally difﬁcult GSAT provides explanations Going details phenomenon scope paper results conﬁrm instances obtained Hamiltonian cycle difﬁcult SATZ noticed Section 42 SAT solvers The Hamiltonian cycle belongs class problems called permutation problems context constraint satisfaction problems CSP Roughly speaking CSP permuta tion problem problem number variables domain values possible exchange variables values 34 In CSP com munity large body research permutation problems It shown permutation problems reformulated dual form formula tion alternative combination primal original Different equivalent combinations variables constraints generate representa tions problem computational properties differ signiﬁcantly The CSP formulation translated SAT ways The main point translation regards number propositional letters encode CSP variable Such numbers linear logarithmic domain size 116 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 35 corresponding unary binary encoding domain An example binary encoding IwamaMiyazaki translation mentioned Thus combining repre sentations permutation problems CSP different ways translate CSP SAT obtain large variety possible options permutation problems The automatic detection situations alternative encoding likely provide large improvement addressed future project 6 Conclusions future work We presented novel approach execution speciﬁcations problems NP based translation SAT The performance resulting good compared previous PROLOGbased engine underlying NPSPEC For example able solve benchmarks graph coloring problems 1000 nodes previous approach able deal graphs 14 nodes As example able increase size chessboard nqueens problem 12 60 The reason increase performance exploit best SAT solvers developed parties Further improvements SAT solvers lead improvements Moreover tool generation new benchmark stances SAT In fact SAT solvers currently tested encodings variety problems graph coloring planning Latin square blocks world Towers Hanoi circuit fault analysis 20 Using SPEC2SAT possible generate SAT instances NPcomplete problem We claim SPEC2SAT research projects aim provide highly declarative language constraint solving capable 1 specifying problems signiﬁcant complexity class 2 solving nontrivial instances The distinguishing fea ture SPEC2SAT respect projects DLV SMODELS capability thirdparty solver SAT black box In future plan include aspects NPSPEC neglected version aggregates recursion As far efﬁciency concerned plan translate speciﬁcation improve compilation terms size dif ﬁculty generated formula For example mentioned management permutation problems signiﬁcantly improved ways As shown Section 4 bottleneck size SAT instance languages expressive propositional logic smaller output compilation phase As example use quantiﬁed Boolean formulae target language efﬁcient solvers exist cf 36 Finally wish equip learning mechanism automatic selection best SAT solver instance hand For example fast incomplete algorithms instances known satisﬁable M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 117 Acknowledgements The authors grateful Giovambattista Ianni Luigi Palopoli Domenico Vasile useful discussion providing examples Adrian Rollett careful proofreading Anonymous referees comments suggestions led substantial improve ments quality paper Appendix A Syntax NPSPEC NPSPEC casesensitive syntax language follows upper_case_letter A Z lower_case_letter z letter string upper_case_letter lower_case_letter letter string letter variable_id upper_case_letter upper_case_letter string symbol lower_case_letter predicate_id lower_case_letter lower_case_letter string lower_case_letter string domain_id constant_id string string 0 9 digit digits digit digits digit integer digits digits spec_program instance specification instance declarations declaration declarations declaration declaration DATABASE declarations domain_id extension constant_id integer extension tuples tuple sequence value interval integer_constant integer constant_id tuples interval tuple tuples tuple sequence value value sequence value integer symbol integer_constantinteger_constant specification SPECIFICATION metapredicates rules metapredicates metafact metapredicates metafact metafact Subset domain predicate_id Permutation domain predicate_id Partition domain predicate_id 118 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 integer_constant IntFunc domain predicate_id interval domain domain_id extension domain domain domain domain domain domain domain domain rules rule rule rules rule atom body atom predicate_id predicate_id terms terms term term terms term integer_constant value variable_id _ body literal literal body literal atom NOT atom expression relational_operator expression aggregate expression integer_constant variable_id expression expression expression expression expression expression expression expression expression relational_operator aggregate agg_op predicate_id agg_terms agg_terms agg_term agg_op agg_terms agg_term agg_term term COUNT MAX MIN SUM variable_id References 1 MH van Emden RA Kowalski The semantics predicate logic programming language J ACM 23 4 1976 733742 2 MR Garey DS Johnson Computers IntractabilityA Guide NPCompleteness WH Freeman San Francisco CA 1979 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 119 3 DS Johnson MA Trick Eds Cliques Coloring Satisﬁability Second DIMACS Implementation Challenge DIMACS Series Discrete Mathematics Theoretical Computer Science vol 26 American Mathematical Society Providence RI 1996 4 HA Kautz B Selman Planning satisﬁability Proceedings Tenth European Conference Artiﬁcial Intelligence ECAI92 1992 pp 359363 5 HA Kautz B Selman Pushing envelope planning propositional logic stochastic search Pro ceedings Thirteenth National Conference Artiﬁcial Intelligence AAAI96 Portland OR 1996 pp 11941201 6 HA Kautz D McAllester B Selman Encoding plans propositional logic Proceedings Fifth International Conference Principles Knowledge Representation Reasoning KR96 1996 pp 374384 7 JM Crawford AB Baker Experimental results application satisﬁability algorithms scheduling problems Proceedings Twelfth National Conference Artiﬁcial Intelligence AAAI94 Seattle WA 1994 pp 10921097 8 M Fujita J Slaney F Bennett Automatic generation results ﬁnite algebra Proceedings Thirteenth International Joint Conference Artiﬁcial Intelligence IJCAI93 Chambéry France 1993 pp 5257 9 T Larrabee Test pattern generation Boolean satisﬁability IEEE Trans ComputerAided Design 1992 415 10 F Massacci L Marraro Logical cryptanalysis SATproblem encoding analysis US Data Encryption Standard J Automat Reason 24 12 2000 165203 11 M Cadoli G Ianni L Palopoli A Schaerf D Vasile NPSPEC executable speciﬁcation language solving problems NP Computer Languages 26 2000 165195 12 KR Apt HA Blair A Walker Towards theory declarative knowledge J Minker Ed Founda tions Deductive Databases Logic Programming Morgan Kaufmann Los Altos CA 1988 pp 89 142 13 V Lifschitz Computing circumscription Proceedings Ninth International Joint Conference Artiﬁcial Intelligence IJCAI85 Los Angeles CA 1985 pp 121127 14 R Fagin Generalized ﬁrstorder spectra polynomialtime recognizable sets RM Karp Ed Com plexity Computation American Mathematical Society Providence RI 1974 pp 4374 15 A Aggoun et al ECLi PSe User Manual Version 40 ICParc London UK July 1998 16 M Davis H Putnam A computing procedure quantiﬁcation theory J ACM 7 1960 201215 17 M Davis G Logemann DW Loveland A machine program theorem proving Comm ACM 5 7 1962 394397 18 B Selman D Mitchell H Levesque Generating hard satisﬁability problems Artiﬁcial Intelligence 81 1996 1729 19 B Selman H Kautz B Cohen Noise strategies improving local search Proceedings Twelfth National Conference Artiﬁcial Intelligence AAAI94 Seattle WA 1994 pp 337343 20 SATLIB The Satisﬁability Library httpwwwsatliborg 21 C Li Anbulagan Heuristics based unit propagation satisﬁability problems Proceedings Fifteenth International Joint Conference Artiﬁcial Intelligence IJCAI97 Nagoya Japan 1997 pp 366 371 22 M Cadoli L Palopoli Circumscribing DATALOG expressive power complexity Theoret Comput Sci 193 1998 215244 23 E Horowitz S Sahni Fundamentals Data Structures Pitman London 1976 24 DS Johnson CR Aragon LA McGeoch C Schevon Optimization simulated annealing experi mental evaluation II graph coloring number partitioning Oper Res 39 3 1991 378406 25 P Cheeseman B Kanefski WM Taylor Where hard problem Proceedings Twelfth International Joint Conference Artiﬁcial Intelligence IJCAI91 Sydney Australia 1991 pp 163169 26 B Vandegriend Hamiltonian cycles algorithms graphs performance MSc Thesis University Al berta Edmonton AB February 1998 27 A Schaerf Scheduling sport tournaments constraint logic programming CONSTRAINTS 4 1 1999 4365 120 M Cadoli A Schaerf Artiﬁcial Intelligence 162 2005 89120 28 T Eiter N Leone C Mateis G Pfeifer F Scarcello The KR dlv progress report comparisons benchmarks Proceedings Sixth International Conference Principles Knowledge Repre sentation Reasoning KR98 Trento Italy 1998 pp 406417 29 I Niemelä Logic programs stable model semantics constraint programming paradigm Ann Math Artiﬁcial Intelligence 25 34 1999 241273 30 D Jackson Automating ﬁrstorder relational logic Proc ACM SIGSOFT00 8th SIGSOFT Sympo sium Foundations Software Engineering 2000 pp 130139 31 N Sadeh Lookahead techniques microopportunistic job shop scheduling Tech Rept CMU CS91102 School Computer Science Carnegie Mellon University Pittsburgh PA available httpwwwcscmuedusadeh 1992 32 K Iwana S Miyazaki SATvariable complexity hard combinatorial problems Proc World Computer Congress IFIP vol 1 Elsevier Science Amsterdam 1994 pp 253258 33 HH Hoos Solving hard combinatorial problems GSATa case study Proceedings Twenti eth German Annual Conference Artiﬁcial Intelligence KI96 Lecture Notes Computer Science vol 1138 Springer Berlin 1996 pp 197212 34 BM Smith Dual model permutation problems Proceedings Seventh International Conference Principles Practice Constraint Programming CP 2001 Lecture Notes Computer Science vol 2239 Springer Berlin 2001 pp 615619 35 T Walsh Permutation problems channelling constraints Proceedings Eighth International Conference Logic Programming Artiﬁcial Intelligence Reasoning LPAR 2001 Springer Berlin 2001 pp 377391 36 M Cadoli M Schaerf A Giovanardi M Giovanardi An algorithm evaluate quantiﬁed boolean formulae experimental evaluation J Automat Reason 28 2002 101142