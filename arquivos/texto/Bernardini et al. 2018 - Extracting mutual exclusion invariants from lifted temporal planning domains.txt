Artiﬁcial Intelligence 258 2018 165 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Extracting mutual exclusion invariants lifted temporal planning domains Sara Bernardini Department Computer Science Royal Holloway University London Egham Surrey TW20 0EX UK b Department Mathematical Sciences G L Lagrange Politecnico di Torino Corso Duca degli Abruzzi 24 10129 Torino Italy c Intelligent Systems Division NASA Ames Research Center Moffett Field CA 94035 United States Fabio Fagnani b David E Smith c r t c l e n f o b s t r c t Article history Received 6 January 2017 Received revised form 24 January 2018 Accepted 27 January 2018 Available online 6 February 2018 Keywords Automated planning Temporal planning Mutual exclusion invariants Automatic domain analysis We present technique automatically extracting mutual exclusion invariants temporal planning instances It ﬁrst identiﬁes set invariant templates inspecting lifted representation domain checks templates properties assure invariance Our technique builds approaches invariant synthesis presented literature departs limited focus instantaneous actions addressing temporal domains To deal time formulate invariance conditions account entire temporal structure actions possible concurrent interactions As result construct comprehensive technique previous methods able ﬁnd invariants temporal domains broader set invariants sequential domains Our experimental results provide evidence domain analysis effective identifying extensive set invariants results generation fewer multivalued state variables We turn reduction number variables reﬂects positively performance temporal planners use variablevalue representation 2018 The Authors Published Elsevier BV This open access article CC BY license httpcreativecommonsorglicensesby40 1 Introduction This paper presents technique synthesising mutual exclusion invariants temporal planning domains expressed PDDL21 21 A mutual exclusion invariant set ground atoms means atom set true given moment Mutual exclusion invariants expressed multivalued state variables adding special null value moments precisely value holds For instance consider Floortile domain 8th International Planning Competition IPC14 Appendix A A mutual exclusion invariant domain states ground atoms indicate position robot true time Intuitively means robot different locations simultaneously To concrete case consider planning problem Floortile domain robot r1 locations t1 t2 t3 We create state variable indicates position r1 domain values robotAt_r1_t1 robotAt_r1_t2 robotAt_r1_t3 Although number approaches invariant synthesis proposed far 2745462033 limited scope deal sequential domains Recently Rintanen 47 proposed technique temporal domains technique scale complex problems requires grounding domain We address Corresponding author Email addresses sarabernardinirhulacuk S Bernardini fabiofagnanipolitoit F Fagnani davidsmithPSresearchxyz DE Smith httpsdoiorg101016jartint201801004 00043702 2018 The Authors Published Elsevier BV This open access article CC BY license httpcreativecommonsorglicensesby40 2 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Table 1 Examples planners classiﬁcation based treat time explicitly implicitly use Boolean propositional representation multivalued state variable representation Propositional Variablevalue Classical Temporal HSP 9 FF 35 YAHSP 49 LPG 25 POPF 12 FD 32 LAMA 44 TFD 18 EUROPA2 23 limitations We ﬁnd invariants temporal domains applying algorithm works lifted level representation consequence eﬃcient scales large instances Our invariant synthesis builds Helmert 33 presents technique translate nontemporal subset PDDL22 17 Finite Domain Representation FDR multivalued planning task formalism Fast Down ward 32 Since ﬁnding invariants temporal tasks complex tasks instantaneous actions simple generalisation Helmerts technique temporal settings work In temporal case simultaneity interference concurrent actions occur algorithm check actions individually invari ance conditions needs consider entire set actions possible intertwinements time In capturing temporal case formulate invariance conditions account entire structure action schemas possible interactions As result construct signiﬁcantly comprehensive technique able ﬁnd invariants temporal domains broader set invariants sequential domains We approach major steps First provide general theory ground level offer results insure invariance types properties safety conditions individual instantaneous durative actions collective conditions prevent dangerous intertwinements durative actions Then lift results level schemas checks needed verifying invariance performed higher level need grounding domain The complexity checks linear low polynomial order terms number schemas literals appearing domain 11 Motivations Automated planning wellestablished ﬁeld artiﬁcial intelligence ﬁfty years appear ance paradigms emerged One fundamental difference paradigms time treated implicitly explicitly While classical planning focuses causal evolution world temporal planning concerned temporal properties world In classical planning actions considered instantaneous tem poral planning actions durations executed concurrently Another important difference planning paradigms relates world modelled adopting Boolean propositional representation representation based multivalued state variables The majority work planning devoted classical planning domains expressed propositional languages particular PDDL 41 successors 21 language International Planning Competition IPC However parallel development classical propositional planning number temporal planning systems proposed coping practical problems especially space mission op erations 2311284224 Typically systems use variablevalue representations Table 1 shows classiﬁcation wellknown planners based different characteristics Recently techniques proposed translating propositional representations variablevalue represen tations 32547 A central task techniques generation state variables propositions actions The basic procedure use baseline experiments relies generating state variable values true false proposition Naturally translation produces performance advantage A sophisticated strategy produces compact optimised encodings rests extracting mutual exclusion invari ants propositional domains invariants generate multivalued state variables This focus work These translation techniques important allow fair testing planners developed variablevalue repre sentations PDDL benchmarks propositional The practical issue planners permit variablevalue representation need feature thoroughly exploited perform competitively Since translation different representations cheaply automated reason avoid providing richer representations planners accept translation expensive reasonably argue fairness process As consequence translation techniques extremely useful comparing alternative planning paradigms promoting crossfertilisation ideas different planning communities primary motivation However importance translation techniques goes engineering bridge different input languages In transforming propositional representations state variable representations generate new domain knowledge new means accessible context Effectively techniques internal mini theorem provers merely translating ﬁrstly selectively explore deductive closure original theory ﬁnd theorems permit optimising representation secondly execute optimisations We cost performing optimisations worth fast amortised problems S Bernardini et al Artiﬁcial Intelligence 258 2018 165 3 Mutual exclusion invariants beneﬁcial pruning search space search methods symbolic tech niques based SAT 3937 backward chaining search 8 In addition invariants help reduce number variables required encode domain planning systems based binary decision diagrams BDDs 16 constraint programming 14 causal graph heuristics 32 pattern databases 31 Finally knowledge engineering perspective invariant synthesis presented paper powerful tool debugging temporal planning domains We focus speciﬁcally paper present case study Example 19 As shown Cushing et al 13 temporal planning tasks developed IPC competitions buggy consequence planners long time solve actually manage As invariants capture intuitive properties physical systems described domains easy domain expert identify modelling mistakes inspecting Discrepancies invariants automatic technique expert expects given domain indicate domain encode physical correctly In consequence expert revise domain repair For example considering Rover domain expect store time point However invariant synthesis produce invariant atoms It shown action drop properly modelled Our technique alerts expert properly modelled refers expert action encoded correctly This useful feature ﬁx modelling errors quickly safely 12 Contributions paper In brief contributions paper following From theoretical point view We ﬁrst formal account mutual exclusion invariant synthesis temporal domains works lifted level representation Our presentation topic rigorous comprehensive theory general Our technique based inferring general properties state space studying structure action schemas lifted relations domain need ground This generally hard task Our theoretical framework sophisticated results practical tools high eﬃciency low computational cost From practical point view We provide domain analysis tool optimising generation state variables propositions actions instantaneous durative This results compact encodings related techniques Sections 101 102 Succinct domain representations beneﬁt performance planners Section 103 We offer technique debugging tool temporal planning domains As types domains particularly challenging encode especially large complex rigorous debugging process crucial producing correct representations systems consideration Example 19 13 Organisation paper This paper organised follows After presenting PDDL21 input language Section 2 formally introduce notion invariance Section 3 Sections 4 5 6 devoted detailed analysis actions ground level In particular Section 4 focuses instantaneous actions fundamental concept strong safety introduced analysed ﬁrst suﬃcient result invariance Corollary 23 established Section 5 analyses sequences actions particular durative actions seen sequence instantaneous actions new concepts safety formulated investigated individual simple safety Our main technical results presented Section 6 consist Theorems 51 53 Corollary 58 results ensure invariance milder safety requirements durative actions Corollary 23 This obtained adding requirements prevent intertwinement durative actions strongly safe Sections 7 8 lift concepts results obtained previous sections level action schemas In par ticular Section 7 deals problem lifting concept strong safety instantaneous schemas Section 8 considers durative action schemas presents lifted version main results Corollaries 92 97 98 These results basic ingredients algorithm ﬁnd invariants present Section 9 Section 10 reports extensive experimental evaluation approach domains temporal IPCs Sections 11 12 conclude paper description related works closing remarks There appendices AD contain speciﬁcations planning domains running examples paper 2 Canonical form planning tasks In work consider planning instances expressed PDDL21 21 However applying algorithm ﬁnd invariants manipulate domain enforce regular structure speciﬁcation action schemas In 4 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Section 21 detailed account canonical form use Section 22 form obtained starting domain expressed PDDL21 21 PDDL canonical form Let consider ﬁrst order language L denumerable set individual variable symbols V v 1 v 2 signature denumerable set constants K k1 k2 denumerable set relation symbols Z r Z associated positive integer called arity indicated arit yr Given language L planning instance tuple I D P D planning domain P planning problem The domain D R Ai Ad 3tuple consisting ﬁnite sets relation symbols R Z instantaneous durative actions The problem P O Init G triple consisting objects O K initial logical state logical goal speciﬁcation The ground atoms planning instance Atms ﬁnitely atomic formulas formed applying relations R objects O respecting arities A logical state subset Atms Considering logical state s denote sc complement sc Atms s S 2Atms denotes set logical states The initial logical state chosen arbitrarily Init S A logical goal speciﬁcation choice desired set ﬁnal logical states G S It typical restrict considering goals form G S C S S conjunction atoms C Atms A state tuple R S ﬁrst value time state second value logical state subset Atms The initial state planning instance I implicitly form t0 Init t0 beginning plan execution time value t0 0 paper convention IPC benchmarks1 The set Ai collection instantaneous action schemas An instantaneous action schema α composed follow ing sets V α V distinct schemas variables Pre α positive preconditions Pre α negative preconditions Eff α add effects Eff α delete effects If schema α clear context drop subscript For convenience deﬁne Preα Pre α Effα Eff α Pre α Eff α Preconditions effects sets formulas l form v 1 vk q q atomic formula q rv v 1 vk v cid7 v 1 v cid7 1 v V quantiﬁed variables l v 1 vk V α schemas variables l cid7 n r R arityr n k cid7 1 v cid7 n cid7 n The universal quantiﬁcation trivial quantiﬁcation zero variables case omitted Note allow repeated arguments speciﬁcation schema formulas appear preconditions effects positive The representation untyped Given formula l form v 1 vk q indicate sets positions free quantiﬁed variables starting zero order appear q respectively VarFl VarQl For example l x z f x y z k VarQl 0 2 VarFl 1 3 Let Rell cid9rkcid10 denote relation symbol r arity k appears atomic formula q In example Rell f 4 Considering position VarFl indicate corresponding variable Vari l For instance Var2 l z The set Ad collection durative action schemas A durative action schema Dα triple instantaneous action schemas Dα αst αinv αend common set variables V Dα V Dα V αst V αinv V αend αinv having effects Effαinv We indicate Dα set αst αinv αend We A set instantaneous action schemas domain including induced durative actions Dα Consider action schemas α1 α2 A exist durative action Dα A Ai cid2 DαAd α1 α2 Dα We assume variables α1 α2 disjoint sets2 V α1 V α2 1 We write t0 emphasise choice starting time theoretically unimportant 2 Our implementation forces assumption true performing preprocessing step appropriately renames variables unrelated action schemas apart S Bernardini et al Artiﬁcial Intelligence 258 2018 165 5 Given action schema α Ai variables V α consider grounding function gr V α O maps schemas variables α problems objects O The function gr induces function formulas α follows Take formula l appears α We cid3grl formula obtained l substituting schemas variables l objects O according gr We grl set ground atoms obtained cid3grl substituting quantiﬁed variable l objects O possible ways Note quantiﬁed variables cid3grl grl singletons For set L containing formulas l1 ln cid3grL cid3grl1 cid3grln grL grl1 grln We cid3grα action schema obtained α grounding formula l appears α according gr grα ground action obtained cid3grα replacing quantiﬁed variables set ground atoms formed substituting objects O quantiﬁed variables possible ways Considering durative action schema Dα Ad grounding function gr ground durative action grDα obtained applying gr instantaneous fragments Dα grDα grαst grαinv grαend Note apply different grounding functions different parts durative action schema We Prea Pre We indicate positive negative preconditions instantaneous ground action Pre add delete Eff effects Eff Ground actions obtained grounding different action schema assumed distinct case preconditions effects In particular different durative actions distinct start end fragments Such fragments distinct instantaneous action We GAi GAd respectively set instantaneous durative ground actions Finally GA set ground actions I obtained grounding schemas A Pre Effa Eff For sake simplicity ground action simply action lifted level use term action schema Moreover term instantaneous dropped cause ambiguity assuming actions action schemas appellative durative instantaneous An action applicable logical state s Pre applicable The result applying s state s cid7 ξs s s Pre cid7 s s We denote Sa set states cid7 s Eff We ξ transition function Eff The transition function ξ generalised ﬁnite set actions A executed simultaneously s cid7 ξs A However order handle simultaneous actions need introduce socalled moving targets rule actions simultaneously use value accessing value update The value moving target action access This rule avoids conﬂicting effects applies preconditions action concurrent actions affect parts state relevant precondition tests actions set regardless effects harmful In formula actions b noninterfering Preb Effa Prea Effb Eff Eff Eff Eff b b If actions noninterfering mutex In work consider set simultaneous actions A implicitly assume component actions pairwise noninterfering Moreover deﬁne Pre A cid4 A Pre Eff A cid4 A Eff 1 We A applicable state s component A applicable s The set states A applicable S A s P sc Given s S A transition function s cid7 ξs A deﬁned follows s P A A s cid7 s Eff A We A executable S A cid14 equivalently A Eff Pre A Pre A 2 Sets actions executable play role analysis appear executable plans exact deﬁnition For reason analysis restrict consideration executable sets actions This implies particular single action consider satisﬁes condition Pre Pre The following result shows application set actions serialised Proposition 1 Serialisability Consider set pairwise noninterfering actions A logical state s S A Let σ 1 n A permutation A consider sequence states recursively deﬁned s0 s sk ξsk1 σ k k 1 n Then Each σ k applicable sk1 sk welldeﬁned Pre σ k ii The ﬁnal logical state coincides state obtained applying set A sn ξs0 A sk1 Pre σ k sk1 6 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Proof The action σ 1 applicable s0 deﬁnition Assuming σ j applicable s j1 j 1 k σ k 1 applicable sk Note deﬁnition transition function ξ single actions sk s0 assumption σ k 1 interfering s0 s0 Pre σ j Since Pre σ k1 σ j σ k1 Eff Eff kcid2 kcid2 j1 j1 σ 1 σ 2 σ k Pre σ k1 sk Pre σ k1 sk Also note sn s0 ξs A cid2 ncid2 j1 Eff σ j ncid2 j1 Eff σ j An instantaneous timed action following syntactic form t t positive rational number ﬂoating cid7 t rational nonnegative rationalvalued duration It possible multiple timed point syntax action A durative timed action following syntactic form t Dat valued time point Da durative action t actions given time stamp indicating executed concurrently cid7 Given planning instance I plan cid5 consists ﬁnite set instantaneous durative timed actions The happening time sequence ti cid7 cid5 The simple plan π induced plan cid5 set instantaneous timed actions i0k plan cid5 t t cid5 t Dat cid7 cid5 t t cid7 Dat t π t cid5 action ii t ast π t t iii ti ti12 ainv π t Dat cid7 aend π t Dat cid7 cid5 Da durative action cid7 cid5 t ti t t cid7 ti ti1 happening time sequence cid5 For durative action t Dat cid7 cid5 simple plan π contains instantaneous timed actions t ast cid7 aend midway instantaneous timed action ti ti12 ainv A plan cid5 corre t t sponding induced simple plan π admissible concurrent instantaneous actions noninterfering actions happening inside durative action Da ast ainv aend noninterfering action ainv More precisely t t b π imply b noninterfering cid7 cid5 s b π time s t t t t Dat cid7 imply ainv b noninterfering The happening time sequence ti i0k plan π t0 t t π The happening time t plan π deﬁned At GA t π Clearly At cid14 iff t happening time sequence The sequence action sets Aπ At0 At k called happening sequence π An admissible simple plan π planning instance I executable given happening time sequence ti i0k sequence logical states si i0k s0 Init 0 k si1 result executing happening time ti π Formally Ati1 applicable si si1 ξsi Ati1 The state sk called ﬁnal logical state produced π The sequence times states S ti sii0k called unique trace π traceπ Two simple plans said equivalent rise trace We Plans executable simple plans I Sr union logical states appear traces associated plans Plans Sr s π Plans t s traceπ Note Sr S We states Sr reachable states Finally executable simple plan planning instance I valid produces ﬁnal state sk Note passage original plan cid5 simple plan π formally lost coupling start end fragments durative actions Since certain cases information necessary set deﬁnition cid7 holds true original plan cid5 durative action Da said happen π time interval t t t cid7 cid5 It convenient following assumption Whenever durative timed t Dat cid7 cid7 actions t1 Da1t 2 1 cid7 2 constituent durative actions different Da1 cid14 Da2 This entails loss plan cid5 different durations t generality In fact Da1 Da2 different obvious If create multiple copies durative action different labels preconditions effects fragment different Durative actions type called equivalent Note ﬁnally equivalent durative actions Da1 Da2 cid7 cid5 rid appear plan starting point duration t Da1t obtain equivalent simple plan For reason assume plans considered free simultaneous happening equivalent durative actions start point t1 t2 end point t1 t cid7 t Da2t t2 Da2t t2 t G cid14 t cid7cid7 2 cid7 1 cid7 1 All concepts results presented paper consideration goal G They concerned family Plans executable plans valid ones Moreover convenient think Init parameter taking possible values S results universally quantiﬁed respect Whenever paper ﬁx instance I think family instances parameterised possible Init G S Bernardini et al Artiﬁcial Intelligence 258 2018 165 7 22 From PDDL21 canonical PDDL We build canonical form described starting PDDL21 instances characterised numeric temporal information 21 We consider numeric expressions canonical form We potentially exploit metric information ﬁnd additional invariants currently Instead ignore numeric expres sions domain focus logical temporal structure Setting numeric expressions aside consequences eliminate numeric constraints actions speciﬁcation actions preconditions effects depend duration actions durations interval 0 rational numbers Note cru cially invariants ﬁnd domain numeric constraints invariants original domain removing expanding set possible valid plans Temporal information handled PDDL21 means durative actions They discretised continuous focus discretised durative actions They duration ﬁeld temporally annotated conditions effects The duration ﬁeld contains temporal constraints involving terms composed arithmetic expressions dedicated variable duration As mentioned ignore numeric constraints consequently speciﬁc durations actions substitute interval 0 Such precise durations irrelevant technique We care possible intertwinement durative actions studied considering exact durations The annotation condition makes explicit associated proposition hold start interval point action applied end interval point ﬁnal effects asserted interval open ends start end invariant duration action The annotation effect makes explicit effect immediate happens start interval delayed happens end interval No time points accessible Logical changes considered instantaneous happen accessible points To build canonical form transform durative actions triples instantaneous actions We way change set plans obtained goal speciﬁcation Plans durative actions fact assigned semantics terms semantics simple plans 21 explained previous section Let obtain PDDL canonical form PDDL21 instances PDDL21 typed representation We compile away types type occurs domain introduce new unary relation For example Floortile domain contains type robot tile color introduce new unary relations cid9robot 1cid10 cid9tile 1cid10 cid9color 1cid10 We use relations speciﬁcation initial state list objects planning instance speciﬁcation actions For typed variable appears action specify giving type introduce new precondition action associates variable corresponding unary relation We follow procedure described Helmert 33 consulted details In PDDL21 domain instead Ai Ad ﬁnd set Aa contains instantaneous durative action schemas following characteristics Durative action schemas temporally annotated conditions ef fects indicate Prepx Effpy p x st inv end y st end For action schema Aa durative condition formula relation negation conjunction disjunction relations quantiﬁed formula relations The effect formula relation negation conjunction relations universally quantiﬁed formula relations conditional effect formula tuple formed precondition formula effect formula We manipulate action schemas Aa obtain Ai Ad action schema sets canonical form described Section 21 First eliminate conditional effects existentially quantiﬁed formulae operation referred ﬂattening Fox Long 21 details These features eliminated applying syntactic transformations resulting schemas equivalent original ones This procedure potentially lead exponential blowup task description Given ﬂattened action schema α formulas temporally annotated conditions effects normalise algorithm introduced Helmert 33 We refer interested reader paper description normalisation process Our normalisation differs Helmert 33 initially eliminate conditional effects applying ﬂattening operation normalisation universal quantiﬁcation preconditions We apply normalisation formulas appearing instantaneous actions Helmert 33 temporally annotated formulas durative actions We normalise formulas leave temporal annotation unchanged After normalisation action schema conditions effects sets formulas l form v 1 vk q q atomic formula quantiﬁcation trivial We indicate Pre α set α set positive formulas appear negative positive formulas appear positive α Pre α α Eff α Eff After ﬂattening normalisation transform durative action schemas Aa triples instantaneous action schemas For durative action Dα Aa create instantaneous action schemas correspond end points Dα αst αend corresponds invariant conditions hold duration Dα αinv More formally durative action schema Dα create αst αinv αend indicated Table 2 8 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Table 2 Transformation durative action schemas triples instantaneous action schemas αst Pre Pre Eff Eff αst αst αst αst Pre Pre Eff Eff st Dα st Dα st Dα st Dα Pre Pre αinv αinv αinv αinv αinv Eff Eff Pre Pre inv Dα inv Dα Pre Pre αend αend αend αend αend Eff Eff Pre Pre Eff Eff end Dα end Dα end Dα end Dα Table 3 Durative action schema paintUp seen triple instantaneous action schemas α V α Pre α Pre Eff Eff α α α paintUpst r y x c robotAtr x cleary robotr tiley tilex colorc cleary paintUpinv r y x c robotHasr c upy x robotr tiley tilex colorc paintUpend r y x c robotr tiley tilex colorc paintedy c At point ready construct Ai Ad Aa We add ﬂattened normalised instantaneous action Aa Ai For durative action Dα Aa applying ﬂattening normalisation create corresponding tuple αst αinv αend add Ad Consider planning instance I canonical form obtained PDDL21 instance Icid7 valid plan cid5 I cid5 converted equivalent valid plan cid5cid7 Icid7 23 Running example Floortiledomain We use Floortile domain running example It introduced IPC14 reused 2015 The PDDL21 speciﬁcation available Appendix A The domain describes set robots use different colours paint patterns ﬂoor tiles The robots ﬂoor tiles directions left right Robots paint color time change spray guns available color Robots paint tile tile painted robot stand We following relations domain R right left robotAt robotHas painted clear availableColor They arity arity availableColor dicates colour gun available picked robot right left indicate respective positions tiles As automatically infer invariant synthesis Example 1 relation clear context means tile unpainted painted unoccupied The set instantaneous action schemas Ai set durative action schemas Ad Ad changeColor paintUp paintDown right left As example durative action schema paintUp corresponds following triple paintUpst paintUpinv paintUpend single instantaneous action schemas speciﬁcations shown Table 3 Note triple single instantaneous action schemas canonical form obtained following PDDL21 speciﬁcation durative action paintUp parameters r robot y t l e x t l e c c o l o r duration duration 2 c o n d t o n l l t s t r t l l t s t r t robothas r c robotAt r x y x c l e r y c l e r y e f f e c t t s t r t t end painted y c 3 Mutual exclusion invariants templates In section formally introduce concept mutual exclusion invariant examples In PDDL21 language invariant planning instance property world states satisﬁed initial state Init satisﬁed reachable states Sr For example Floortile domain trivial invariant says S Bernardini et al Artiﬁcial Intelligence 258 2018 165 9 object x x robot x tile Similar invariants hold type deﬁned original PDDL domain A interesting invariant says objects x y upxy holds downyx holds downxy It possible identify invariants Floortile domain ranging trivial invariants involving type predicates complex invariants In paper focus mutual exclusion invariants state set ground atoms true time From assume ﬁxed planning instance I PDDL canonical form Deﬁnition 2 Mutual exclusion invariant A set ground atoms Z S mutual exclusion invariant set element Z true initial state element Z true reachable state Z Init 1 Z s 1 s Sr We abuse distinction set Z formula directly brevity invariant cid5 x y Z x y Z mutual exclusion invariant Example 1 Floortile domain A mutual exclusion invariant domain states ground atoms indicating position robot identiﬁed rbt1 robotAtrbt1tile1 robotAtrbt1tile2 true time Intuitively means rbt1 different positions simultaneously Another complex invariant states given tile tile1 robot rbt1 colour clr1 atoms form cleartile1 robotAtrbt1 tile1 paintedtile1clr1 true time This means tile possible states painted clear painted occupied robot painting adjacent tile preceding tile painted Although aim ﬁnd sets mutually exclusive ground atoms work relations action schemas control complexity A convenient compact way indicating invariant sets time involves invariant templates deﬁned introducing preliminary deﬁnitions Deﬁnition 3 Component A component c tuple cid9rk pcid10 r relation symbol R arity k arit yr p 0 k Take component c cid9rk pcid10 set variables v 0 vk1 consider atomic formula m rv 0 vk1 When p k 1 number p c represents position variables m counted variable When p k counted variables The set ﬁxed variables c formally deﬁned F c c 0 k 1 cid14 p We deﬁne set ﬁxed variables set components C c1 c2 cn FC F c cid2 cC Deﬁnition 4 Admissible partition Given set components C corresponding set ﬁxed variables FC admissible partition FC partition FC G 1 G s G j F c 1 c C If elements c1 c2 j FC belong set partition FC use notation c1 FC c2 j Remark 5 Note existence admissible partition FC implies components C number ﬁxed variables number sets partition In special case number ﬁxed variables component equal admissible trivial partition FC FC Deﬁnition 6 Template A template T pair C FC C set components FC admissible partition FC We simply write T C partition trivial FC FC Deﬁnition 7 Template instance Given objects O template T C FC instance γ FC O T maps elements partition object γ ca γ cb j ca FC cb j ca cb j C Deﬁnition 8 Template instantiation The instantiation T according instance γ γ T set ground atoms 2Atms obtained follows component c cid9rk pcid10 T relation symbol r element c F c bind variable position according γ c counted variable position p objects O In formula γ T cid4 cid6 rx0 xk1 xp O xi γ c cid14 p cid7 ccid9rkpcid10T 3 10 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Instances interesting reason exponentially larger instantiations fact constructing instantiations Considering template T instance γ ground atoms instantiation T according γ mutually exclusive initial state Init remain reachable state s Sr γ T deﬁnition mutual exclusion invariant set A template property possible instantiation γ called invariant template Deﬁnition 9 Invariant template A template T invariant template instance γ instantiation T accord ing γ mutual exclusion invariant set Given invariant template T create state variable instances The domains variables corresponding mutual exclusion invariant sets additional null value element mutual exclusion invariant set true Before describing situations feasibly prove template invariant introduce ﬁnal concept Deﬁnition 10 Template instances weight Take instance γ template T instantiation γ T The weight wγ s γ state s number ground atoms instantiation true s wγ s cid8 cid8γ T s cid8 cid8 Proposition 11 A template T invariant instance γ T instantiation γ T wγ Init 1 wγ s 1 state s Sr Proof It follows Deﬁnitions 9 10 cid2 Example 2 Floortiledomain A template domain T f t c1 c2 c3 c1 cid9robotAt2 0cid10 ﬁrst component It includes relation robotAt arity relation robotAtrobot tile variables variable position zero robot counted variable The remaining variable tile position ﬁxed variable F c1 c1 1 c2 cid9painted2 1cid10 second component F c2 c3 cid9clear1 1cid10 component F c3 c3 0 c2 0 For example component ﬁxed argument admissible partition trivial places components FC c1 1 c2 0 c3 0 Assume problem P robots rbt1 rbt2 tiles tile1 tile2 tile3 colour black Consider possible instance γ1 γ1c1 1 γ1c2 0 γ1c3 0 tile1 The instantiation template T f t according γ1 γ1T f t cleartile1 robotAtrbt1 tile1 robotAtrbt2tile1 paintedtile1black The weight instance γ1 state s atoms γ1T f t true s For example wγ1 s0 1 plausible initial state s0 cleartile1 robotAtrbt1tile2 robotAtrbt2tile3 intersection state s0 instantiation γ1T f t contains cleartile1 We actually prove T f t invariant states given tile tile1 instanceinstantiation γ1 satisﬁes 1 clear 2 painted colour 3 occupied robot Hence problem P create state variables represent tiles The domains vari ables possible conﬁgurations tiles null value As happens situation abovementioned values true robot adjacent tile painting tile question The special null value state variable meaning For example SVtile1 robotAtrbt1tile1 robotAtrbt2tile1 paintedtile1black cleartile1 null simi larly SVtile2 SVtile3 4 Safe instantaneous ground actions In following sections ﬁx planning instance I D P recalling consider family planning instances parameterised initial state Init G We consider template T discuss conditions T invariant More precisely determine suﬃcient conditions families instantaneous durative actions D ensure instance γ wγ Init 1 wγ s 1 reachable states s Sr S Bernardini et al Artiﬁcial Intelligence 258 2018 165 11 41 Strong safety We assume template T ﬁxed instance γ In following A GA denotes set pairwise noninterfering actions assumed executable Deﬁnition 12 Strongly safe actions The set actions A strongly γ safe s S A wγ s 1 successor state s cid7 ξs A satisﬁes wγ s cid7 1 The following result shows strong γ safety checked level single actions Proposition 13 Let A set actions Then A strongly γ safe strongly γ safe A Proof Write A a1 let s S A Note Proposition 1 actions A serialised cid7 sn By assumption successor state s follows wγ si 1 In particular wγ s cid7 ξs A recursively obtained s0 s sk ξsk1 ak k 2 n s cid7 1 cid2 The converse result hold A counterexample shown later Example 3 In order tease apart property strong γ safety need formal deﬁnitions following subsections Firstly consider restricting action particular instantiation complement Deﬁnition 14 Given action GA aγ aγ actions respectively speciﬁed Pre Pre aγ aγ γ T Pre Eff γ T c Eff Pre aγ aγ Eff Eff γ T γ T c Ac denotes set complement A Given action set A deﬁne action sets Aγ aγ A Aγ aγ A We split states similar way s S sγ s γ T sγ s γ T c Remark 15 For state s action set A s S A sγ S Aγ sγ S Aγ holds cid7 ξs A s cid9 cid7 s γ cid7 γ s ξsγ Aγ ξsγ Aγ This leads following simple useful result 4 Proposition 16 For set actions A following conditions equivalent A strongly γ safe ii Aγ strongly γ safe iii For s S Aγ s γ T wγ s 1 holds successor state s cid7 ξs Aγ wγ s cid7 1 Proof ii iii trivial iii immediate consequence 4 fact wγ s wγ sγ wγ s cid7 wγ s Finally ii follows following argument Take s S Aγ wγ s 1 Consider s S A If consider successor states s S Aγ follows s sγ Pre cid7 ξs Aγ Aγ cid7 γ Since s γ cid7 ξs s sγ S Aγ s Pre Aγ Aγ follows 4 γ cid7 γ s ξsγ Aγ ξs γ Aγ s cid7 γ Therefore wγ s cid7 wγ s cid7 γ wγ s cid7 γ wγ s cid7 1 equality follows assumption A strongly γ safe cid2 12 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 42 Characterisation ground actions respect strong safety Based structure preconditions effects classify actions classes relate class notion strong safety Deﬁnition 17 Classiﬁcation ground actions A set actions A 2 γ unreachable Pre Aγ γ heavy Pre 1 Eff Aγ Aγ γ irrelevant Pre 1 Eff Aγ 1 Eff γ relevant Pre Aγ Aγ 2 0 Aγ 1 Each A GA belongs disjoint classes The following result clariﬁes relation strong safety Proposition 18 Let A set actions Then 1 A γ unreachable γ irrelevant A strongly γ safe 2 A γ heavy A strongly γ safe Proof If A γ unreachable A applicable state s follows Pre shows condition wγ s 1 veriﬁed A strongly γ safe A s wγ s Pre Aγ 2 This If A γ irrelevant A applicable state s successor state s cid7 ξs s This yields wγ s cid7 wγ s This implies A strongly γ safe Suppose A γ heavy consider state s Pre 1 After applying A s successor state s 2 proves A strongly γ safe cid2 wγ s Pre Aγ Eff α A A applicable s assumption 2 cid7 cid7 Eff cid7 ξs A s This yields wγ s Aγ The following example shows converse Proposition 13 hold Example 3 Consider template T instance γ γ T q q q actions cid7 Let A cid7cid7cid7 cid7 cid7 q cid7cid7 q q cid7 q cid7cid7 distinct ground atoms Pre q q cid7 Effa Preacid7 Eff acid7 q cid7cid7 cid7cid7cid7 q Then γ unreachable strongly γ safe A γ unreachable strongly γ safe cid7 γ heavy strongly γ safe However set actions As example shows γ relevant action sets strongly γ safe Example 4 Consider template T instance γ γ T q q q Since Eff ground atoms action Pre 1 Eff cid7 q cid7cid7 q q cid7 γ T 1 γ relevant q cid7cid7 distinct Suppose Pre q wγ s 1 q wγ s cid7 1 Suppose Prea Eff In fact consider starting state s q wγ s cid7 2 cid7 Eff cid7 s consequence wγ s 1 Given s cid7 shown Fig 1 left In case strongly γ safe In fact s Sa cid7 ξs q q s cid7 s q cid7 cid7 q cid7 shown Fig 1 right In case γ relevant strongly γ safe cid7 ξs cid7cid7 wγ s 1 Since q cid7cid7 Eff q Eff s Proposition 18 classiﬁes relevant actions Let consider relevance We split categories analyse strong safety case Deﬁnition 19 Classiﬁcation relevant actions A γ relevant set actions A relevant precondition Pre 1 A γ weighty p single relevant precondition Pre p A γ weightless Pre Aγ 0 Aγ Aγ S Bernardini et al Artiﬁcial Intelligence 258 2018 165 13 Fig 1 Relevant actions safe left unsafe right See Example 3 Empty action parts shown A γ weighty p action set A γ balanced precondition effect p Eff Aγ γ unbalanced p Eff Aγ A γ weightless action set A γ bounded entire instantiation accessed Pre Aγ γ unbounded Pre Aγ cid14 γ T Eff Aγ Eff Aγ γ T Every relevant set actions A belongs disjoint classes The balanced bounded cases discussed Example 4 To understand bounded case better recall relevant action set l When A bounded rest instantiation γ T l accessed relevant positive effect l Eff negatively γ T Pre Aγ Eff Aγ Pre A So weight Aγ executing bounded set exactly regardless In words bounded safer balanced Formally l imply γ T l Pre A Aγ Eff Eff Aγ Proposition 20 Let A γ relevant set actions Then 1 A γ balanced γ bounded A strongly γ safe 2 A γ unbalanced γ unbounded A strongly γ safe Proof We prove corresponding property Aγ making use Condition iii Proposition 16 We ﬁrst analyse q2 Suppose A γ balanced ﬁx state case A γ weighty Let Pre s γ T wγ s 1 Aγ applicable s Since q1 s necessarily s q1 wγ s 1 Consider subsequent state s cid7 1 Suppose A unbalanced consider state s q1 The s subsequent state s cid7 s q1 q2 q2 wγ s cid7 ξs Aγ If q1 q2 s cid7 1 If instead q1 Eff cid7 s wγ s q1 Eff Aγ Aγ Aγ cid7 2 We consider case A γ weightless Pre cid7 ξs Aγ q1 q2 wγ s Eff Aγ Let Eff q2 Suppose A γ bounded ﬁx cid7 ξs Aγ cid7 wγ s 1 The case need consider wγ s 1 Suppose s q1 Since Aγ In ﬁrst case q1 q2 cid7 1 Finally A γ unbounded consider Aγ cid7 ξs Aγ q1 q2 state s γ T wγ s 1 Aγ applicable s Since A γ relevant subsequent state s wγ s assumption Pre Aγ applicable state s Therefore necessarily q1 Eff s ground atom q1 γ T Pre Aγ q1 Pre Aγ wγ s wγ s 1 Since holds q1 Eff cid7 2 cid2 Eff Aγ set s q1 We Aγ applicable q1 Pre Eff Aγ We q1 Pre Aγ T γ follows q1 Pre Aγ cid7 s q1 In second case s subsequent state s cid7 q2 In cases wγ s q1 Eff Aγ Aγ Aγ Aγ Aγ Putting Propositions 18 20 following result Theorem 21 Let A set actions Then 1 A γ unreachable γ irrelevant γ balanced γ bounded A strongly γ safe 2 A γ heavy γ unbalanced γ unbounded A strongly γ safe 14 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Any state γ heavy γ unbalanced action executed immediately weight 2 In contrast possible γ unbounded action execute violating weight bound conceivable reachable states γ unbounded actions end safe In sense Theorem 21 arguably complete classiﬁcation appear A possibly interesting way approach knowledge generated stronger prover augment descriptions actions derived preconditions properties hold reachable states freely added precon dition actions That convert γ unbounded actions γ balanced γ bounded actions negative conditions added Example 5 Floortiledomain Take schema α paintUpend variables V α r y x c Table 3 grounding gr grr rbt1 gry tile1 grx tile3 grc red Let c cid9painted2 1cid10 component counts colour argument painted T c c 0 template component Consider safety grα respect T Let γ1c 0 tile1 instance tile robot painting γ2c 0 tile2 instance unrelated tile γ3c 0 tile3 instance tile robot standing Each instantiation set possible colours tile The action γ2irrelevant expected meaning γ2T preconditions effects trivially strongly γ2safe While tile3 relevant action access painted tile3 likewise irrelevant safe respect γ3 The action γ1relevant adds paintedtile1red γ1T It strongly γ1safe cause executed state tile black tile end painted colours ξpaintedtile1black aγ1 paintedtile1red paintedtile1black In particular γ1un bounded If altered adding negative preconditions colours bounded safe If added clear template instead balanced safe instantiation tile1 43 Template safety This concluding section presents deﬁnition strong safety respect template presents ﬁrst result expresses suﬃcient condition template invariant Deﬁnition 22 For template T set actions A GA strongly safe strongly γ safe instance γ We following result Corollary 23 For template T T invariant GA strongly safe Proof We proceed follows We ﬁx instance γ T wγ Init 1 wγ s 1 s Sr This Proposition 11 yields result By deﬁnition set reachable states Sr s Sr obtained initial state Init recursively applying sequence action sets Precisely exists sequence sets consisting pairwise noninterfering actions A1 A2 Ak sequence states sii0k s0 Init sk s 0 k 1 si1 ξsi Ai1 We prove wγ s 1 induction k Notice case k 0 boils s s0 Init wγ Init 1 standing assumption Assume true k 1 let prove k Notice write s sk ξsk1 Ak induction assumption implies wγ sk1 1 By assumption GA strongly safe Deﬁnition 22 strongly γ safe Using Proposition 13 obtain particular Ak strongly γ safe Consequently wγ sk 1 cid2 The condition expressed Corollary 23 inverted general Indeed template invariant actions strongly safe We happens following section 5 Safe action sequences safe durative actions A template invariant actions strongly safe This happens reasons On hand set reachable states Sr general smaller S states responsible lack strong safety unreachable Sr On hand domains durative actions instantaneous actions temporally coupled start end fragments durative action This coupling imposes constraints states end applied prove helpful establish template invariant While paper analyse ﬁrst case require analysis set reachable states Sr infeasible elaborate suitable simple concepts safety durative actions weaker strong safety These extensions important realworld temporal planning domains In S Bernardini et al Artiﬁcial Intelligence 258 2018 165 15 experience domains present endfragments durative actions unsafe written γ unbalanced Nonetheless use executable plan preserves weight condition typically associated startfragments force weight zero invariantfragments A γ unbalanced action safe executes weight zero states We deﬁnition safety durative actions captures case However plan durative action intertwine actions happen start end points need work concept safety general sequences actions durative ones Below consider general sequences action sets A A1 A2 An Any simple plan π generates object i0k related happening time sequence Ati relative happenings consider contains information plan π time values Indeed ti happening sequence Aπ At0 At k actions happen To study invariance template break happening sequence plan subsequences determined happenings durative actions More precisely consider sequences A A1 A2 An durative action Da ast ainv aend ast A1 aend An The sets A2 An1 A1 An possibly contain actions executed duration Da However convenient consider general sequences actions A A1 A2 An referring plans durative actions Hence section ﬁrst deﬁnition safety A A executed serially executable plan π weight constraint violated state sequence initially applied violated intermediate step end sequence For single action sets sequences length n 1 concept coincides notion strong safety We consider slightly stronger notion safety robust insertion elements sequence actions positive effects intersection template To necessary introduce number auxiliary concepts relating state dynamics induced execution A This general theory applied sequences constructed durative actions We recall standing assumption considered subset actions Ai consists pairwise noninterfering actions assumed executable 51 Safe ground action sequences For sequence action sets A A1 A2 An denote SA set state sequences s0 sn Sn1 si ξsi1 Ai Ai applicable si1 1 n If s0 sn SA s0 sn state sequence compatible A Given instance γ deﬁne SAγ s0 sn SA wγ s0 1 We use following notation subsequences A Ak h Ah Ah1 Ak We ﬁx template T instance γ following natural deﬁnition safety sequence Deﬁnition 24 Individually safe actions A sequence action sets A A1 A2 An individually γ safe sequence states s0 sn SA wγ s0 1 wγ si 1 1 n The invariance template expressed terms individual safety happening sequences Proposition 25 Let T template Suppose executable simple plan π happening sequence Aπ individually γ safe instance γ Then T invariant Proof Take instance γ assume wγ Init 1 We need wγ s 1 s Sr For s Sr exists executable simple plan π having traceπ S ti sii0k s happening sequence Aπ We state sequence s0 sk SAπ Since assumption wγ s0 1 individual γ safety Aπ implies wγ s j 1 j 1 k In particular wγ s 1 cid2 s0 Init sk Below elementary properties individual γ safety subsequences A Proposition 26 Consider sequence action sets A A1 A2 An The following properties hold k h k h 1 Ak 1 A1 A2 Ak An h Ah An individually γ safe A individually γ safe ii A individually γ safe Ak Ak1 noninterfering A iii A individually γ safe B j j 1 n action sets Eff B j A individually γ safe If addition A j B j noninterfering j 1 n A individually γ safe cid7 A1 A2 Ak Ak1 An individually γ safe cid7 A1 B1 A2 Bn An cid7cid7 A1 B1 An Bn 16 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Fig 2 The insertion γ irrelevant action b fails individual γ safety sequence A See Example 6 Proof If s0 s1 sn SA s0 s1 sk SAk 1 sh1 s1 sn SAn h Therefore wγ s0 1 fact Ak In particular k h 1 wγ sh1 1 From fact An wγ s j 1 j h n This implies wγ s j 1 j 1 n proves property 1 individually γ safe follows wγ s j 1 j 1 k h individually γ safe follows ii Suppose s0 s1 sk1 sk1 sn SAcid7 sk1 ξ Ak Ak1 sk1 Put sk ξ Ak sk1 note serialisability Proposition 1 sk1 ξ Ak1 sk s0 s1 sk1 sk sk1 sn SA This implies wγ s j 1 j 1 n proves property ii cid7 k1 sk k 1 n s0 s1 sn SA Individual γ safety cid7 n1 sn SAcid7 s cid7cid7 individually γ safe case A establishes property iii Regarding A ii cid2 property follows fact A cid7 0 s1 s iii If s0 s cid7 The following useful consequence previous results asserts individual safety holds locally se quence holds globally Corollary 27 For sequence action sets A A1 A2 An following conditions equivalent sequence A individually γ safe ii j 1 n exists subsequence A js jr r s 0 individually γ safe Proof ii trivial ii follows iterative use Proposition 26 cid2 Individual safety weak property robust respect insertion actions actions irrelevant possess delete effects This connected fact individual safety nice local global feature illustrated Corollary 27 possess opposite feature subsequences individually safe sequences individually safe The following example shows phenomena Example 6 Consider template T instance γ γ T q q A a1 a2 Fig 2 diagram SA s0 s1 s2q s0 s1 s0 q a2 applicable s1 s1 s0 q a1 γ unbounded strongly γ safe A1 1 cid7 The set state sequences compatible cid7 s2 s1 Note q s0 hypothesis cid7 A individually γ safe wγ si 1 state si appears SA Note a1 individually γ safe Now consider sequence A a1 b a2 Fig 2 diagram γ irrelevant action b inserted a1 a2 The new set state sequences compatible A S A cid7 s2 s1 q s3 s2 Note q s0 action b ensures applicability a2 If q s0 a1 adds q s0 wγ s1 2 This new sequence individually γ safe The insertion γ irrelevant action failed individual γ safety sequence A s0 s1 s2 s3s1 s0 q cid7 For proving results concept individual safety suﬃcient Below present stronger deﬁnition safety action sequence robust respect insertion irrelevant actions First deﬁne simple concepts executable reachable sequences Deﬁnition 28 Executable reachable actions The sequence A A1 A2 An called S Bernardini et al Artiﬁcial Intelligence 258 2018 165 17 executable SA cid14 γ unreachable SAγ cid14 SAγ Remark 29 Note following chain implications nonexecutable γ unreachable individually γ safe Note π executable simple plan γ instance wγ Init 1 happening sequence Aπ γ reachable Moreover subsequence A Aπ executable If subsequence A Aπ γ unreachable weight surely exceed 1 point plan π template T invariant In special case sequence length 2 executability reachability admit simple characterisations We report need later First deﬁne generic set actions A postconditions cid8 A A Eff Pre A We following result Eff A cid8 A Pre A Eff A Eff A 5 Proposition 30 For sequence action sets A A1 A2 following conditions equivalent A executable Pre ii cid8 cid8 A1 A2 A1 Pre A2 Proof ii Note s0 s1 s2 SA follows Pre s0 Since s1 s0 Eff s1 A1 Eff A1 A1 c s1 Since A2 applicable s1 condition ii A1 c s0 follows cid8 Analogously fact Pre immediately follows A1 follows cid8 A1 ii Consider s0 Pre A1 Pre A2 Eff A1 Straightforward set theoretic computation conditions ii A1 applied s0 A2 applied s1 ξ A1 s0 This proves cid2 Proposition 31 For sequence action sets A A1 A2 following conditions equivalent A γ reachable ii A executable Pre A1 γ Pre A2 γ Eff A1 γ 1 Proof ii It follows proof ii Proposition 30 exists s0 s1 s2 SA s0 Pre Pre A2 A1 By assumption wγ s0 1 proves A1 ii follows fact s0 s1 s2 SA necessarily Pre A1 Pre A2 Eff A1 s0 cid2 Eff The following result shows executability γ reachability robust respect speciﬁc modiﬁcations sequence notably deletion actions containing effects serialisation Proposition 32 Consider sequence A A1 A2 An executable γ reachable Then B j A j Eff B j j 1 n 13 A cid7 A1 B1 A2 B2 An Bn respectively executable γ reachable cid7 j A ii A j A cid7cid7 j j 1 n A cid7 A1 A2 A cid7 j A cid7cid7 j An respectively executable γ reachable Proof If s0 s1 sn1 sn SA s0 s1 sn1 s deﬁnition executability γ reachability ii This follows immediately serialisability Proposition 1 cid2 cid7 n SAcid7 suitable state s cid7 n The result follows Here stronger notion safety Deﬁnition 33 Safe actions A sequence action sets A A1 A2 An γ safe executable subsequences 1 individually γ safe k 1 n Ak 3 Bn constrained removing effects end sequence alter executability reachability 18 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Fig 3 Lack robustness individually γ safe actions See Example 7 Example 6 illustrates individual safety fragile concept We like infer A Example 6 unsafe appropriate notion safety example shows concept individual safety Deﬁ nition 33 accomplishes aim Indeed note sequence A a1 a2 considered Example 6 γ safe a1 individually γ safe The deﬁnition safety asks executability addition asking preﬁx individually safe executability individual safety vacuous condition In particular like conclude happening sequence Example 7 considered unsafe reason shown By having Deﬁnition 33 require executability attain judgment Example 7 Motivating executability safety Consider nonexecutable sequence A a1 a2 depicted Fig 3 cid7cid7 required false a2 asserted a1 Consider template T instance γ diagram q cid7cid7 As happens A individually safe vacuously nonexecutable However cid7 q γ T q q safe arrangement like inserting γ irrelevant actions preserves safety consider inserting A a1 b a2 depicted Fig 3 diagram Then weight bound held action b deleting q vacuously A violated A q q end true conclude individually safe weak purposes Observe requiring executability deﬁnition safety rules counterexample A γ safe desired Note unlike Example 6 preﬁxes individually safe cid7cid7 cid7 Remark 34 If A A1 A2 An γ safe ﬁrst action set A1 necessarily strongly γ safe In direction note A executable A j j 1 n strongly γ safe A γ safe This motivates following deﬁnition Deﬁnition 35 Strongly weakly safe actions A sequence action sets A A1 A2 An strongly γ safe executable A j j 1 n strongly γ safe weakly γ safe γ safe strongly γ safe With ﬁnished upgrading notion safety point consider having safety let prove safety preserves weight bound force true initially So general need consider sequences γ safe γ reachable We notions separate combine deﬁnition technical reasons γ safe shown entire planning domain γ reachable checked problem The ﬁrst things said sequences γ safe γ reachable exclude γ heavy γ unbalanced actions cf Propositions 16 18 cid7 Example 8 Motivating reachability Proposition 36 Consider template T instance γ γ T q q Now consider executable γ unreachable sequence A a1 a2 depicted Fig 4 consisting γ unreachable action a1 γ heavy action a2 In general want quickly exclude sequence containing γ heavy action insisting safety example demonstrates Action a1 requires q q true weight 2 initially A execute consequently A γ reachable Perhaps counterintuitively reason A γ safe preﬁxes a1 a1 a2 individually safe executions begin weight bound violated implications comprising safety hold vacuously cid7 What example illustrates general undesirables γ heavy actions hidden nominally safe sequences failing reachability Formally insisting safety reachability rule heavy unbalanced actions S Bernardini et al Artiﬁcial Intelligence 258 2018 165 19 Fig 4 Safety rule heavy actions A safe a2 heavy See Example 8 Proposition 36 Let A A1 A2 An sequence action sets If A γ safe γ reachable j 1 n A j γ heavy γ unbalanced Proof Since A γ reachable set SAγ Fix s0 sn SAγ note A γ safe wγ si 1 1 n For j 1 n s j s j1 Eff A j This implies A j Eff Eff Pre Eff A j A j A j Pre A j γ Eff A j γ Eff 1 A j γ j A γ Eff As consequence Eff 1 says A j γ heavy If assume Eff implies Pre A j γ Eff A j γ Hence A j γ unbalanced cid2 A j γ 6 1 Relation 6 A j γ In studying safety properties sequence A introduced far essentially restrict study state dynamics template instantiation γ T strong γ safety instantaneous actions Remark 15 γ Considering sequence A A1 A2 An denote Aγ A1 γ Aγ A1 γ An γ An γ A2 γ A2 corresponding restricted sequences We following result Proposition 37 Given sequence A A1 A2 An A executable Aγ Aγ executable ii A γ reachable Aγ γ reachable Aγ executable iii A individually γ safe Aγ individually γ safe iv A γ safe Aγ γ safe Aγ executable Proof It follows 4 sequence states s0 sn Sn1 cid10 s0 sn SA s0 γ sn γ sn γ SAγ γ SAγ s0 7 This immediately proves implication On hand s cid7cid7 s γ SAγ s s Statement ii proven analogously statement iii follows straightforward extension argument prove Proposition 16 Finally statement iv follows deﬁnition strong γ safety previous statements iii cid2 SA 7 cid7cid7 SAγ s cid7 SAγ s SAγ cid7cid7 γ s cid7 γ cid7 γ We ready state prove following fundamental result ensures concept safe sequence robust insertion irrelevant actions Theorem 38 Consider γ safe sequence A A1 A2 γ irrelevant action sets B 1 B2 Bn Then sequence A A1 B1 Bn A2 non executable γ safe Proof Consider sequences restricted instantiation γ T complement Aγ Aγ respectively Aγ Aγ By virtue Proposition 37 Aγ γ safe prove result suﬃcient Aγ non executable γ safe 20 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Assume Aγ executable let s0 s1 s2 sn1 sn2 S Aγ γ strongly safe follows wγ s1 1 Note s j s j1 Eff A1 implies j1 γ B wγ s0 1 Since s0 s1 S A1 j 2 n 1 immediately γ wγ sn1 wγ sn wγ s1 1 What remains shown wγ sn2 1 To accomplish introduce set F n consider new initial state s0 s0 F Pre A1 γ A1 γ Since s0 s0 know Pre A1 γ γ applied state s0 obtain state Pre s0 Thus A1 s0 Moreover construction i1Eff Bi γ A1 γ Eff s1 s0 Eff A1 γ Note sn1 s1 F s1 implies Pre A2 γ A2 γ γ applicable sn1 The fact Aγ γ safe executable implies Proposition 30 state sn1 follows Pre γ applicable state s1 exists s2 S cid8 A1 A2 γ γ s1 s2 S A2 Therefore conclude s0 s1 s2 SAγ Since Aγ γ safe wγ s0 wγ s0 1 wγ s2 1 At time sn1 s1 sn2 s2 wγ sn2 1 This completes proof cid2 Therefore Pre A2 γ s1 A2 Since A2 s1 Also s1 sn1 cid8 Pre A1 γ γ Remark 39 We conjecture Theorem 38 generalised sequences actions length longer proof complex Since extension needed paper present proof For future use convenient deﬁnition safeness depend particular chosen instance Deﬁnition 40 A sequence action sets A safe template T γ safe instance γ T A sequence action sets A strongly safe template T strongly γ safe instance γ T It weakly safe safe strongly safe 52 Safe ground durative actions We restrict attention durative actions Da ast ainv aend If interpret Da sequence actions treat properties deﬁned general sequences γ safety strong γ safety Before studying properties convenient considerations way durative actions appear admissible simple plans Indeed constraints emerge direct consequence deﬁnition induced simple plan concept admissibility explained Section 21 Consider admissible simple plan π happening sequence Aπ At0 At k If durative action Da happens π time interval ti1 t j ast Ati1 aend At j Moreover j necessarily odd h 2 4 j 1 Atih consists ainv possibly conditions durative actions happening original plan cid5 simultaneously intertwined Da Finally h 1 3 n 2 Atih consists actions appear simple admissible plans consequently inherit constraints Deﬁnition 41 Admissible actions A sequence A A1 A2 An admissible exists admissible simple plan π happening sequence Aπ At0 At k A1 A2 An Ati1 Atin 0 k n Daadmissible durative action Da admissible Da happens corresponding simple plan π ti1 tin In particular ast A1 aend An The existence Daadmissible sequences executable imposes speciﬁc conditions durative action Da Proposition 42 Consider durative action Da ast ainv aend assume exists executable Daadmissible sequence Then following conditions satisﬁed cid8 ast Pre Pre aend cid8 ast ainv Pre ainv Pre aend ainv Pre ainv Pre 8 9 postconditions cid8 deﬁned 5 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 21 Proof Suppose A A1 A2 An Daadmissible executable Since A1 A2 executable Proposition 30 implies cid8 A1 Pre A2 cid8 A1 Pre A2 Since ast A1 A1 consists pairwise noninterfering actions cid8 ast cid8 A1 cid8 ast cid8 A1 10 11 Finally equations 10 11 fact ainv A2 yield conditions 8 Conditions 9 similarly proven cid2 Durative actions satisfying conditions expressed previous result ignored analysis From assume durative actions satisfy conditions 8 9 To study safety Daadmissible sequence cases reduce analysis durative action Da analysis auxiliary sequence actions Da ast aend ast aend actions Eff Eff ast aend Eff Eff Pre ast aend Pre ast aend Pre ast Pre aend Pre ainv Pre ainv Eff ast Remark 43 The executability assumption 2 automatically extends ast aend auxiliary actions ast consequence condition 9 aend The relation sequences Da Da clariﬁed following result Assume template T instance γ ﬁxed Proposition 44 The following facts hold s0 s1 s2 Sastainv s1 s2 s0 s1 Sast ii s0 s1 s2 Sainvaend s0 s1 s1 s2 Saend iii s0 s1 s2 s3 SDa s1 s2 s0 s1 s3 SDa iv ast ainv individually γ safe ast strongly γ safe v ainv aend individually γ safe aend vi Da individually γ safe Da individually γ safe strongly γ safe ainv ast Eff ast satisfy conditions Pre Proof Suppose s0 s1 s2 Sastainv Since ainv contains preconditions s1 s2 Note s1 ξast s0 s0 Eff ainv c This yields Pre ast ainv ainv c obtain s0 Pre Eff Eff Pre effects If instead s0 s1 Sast ast applicable s0 s1 ξast s0 ξast s0 ii proven applicable s0 preconditions ast preconditions ast similarly iii follows ii ﬁnally iv v vi follow respectively ii iii cid2 s0 Eff ast c This implies ast ast s0 ast ast s0 Similarly s0 Eff s1 ξast s1 Pre Pre ainv ainv ast The result studies effect exchanging start end durative action Da auxiliary sequence Da Daadmissible sequence Proposition 45 Consider durative action Da ast ainv aend Daadmissible sequence actions A ast A2 An1 aend Let A ast Then SA SA In particular A individually γ safe A individually γ safe A2 An1 aend Proof Since A differs A having preconditions holds SA SA Conversely suppose s0 sn SA Then s0 s1 s1 Sastainv Therefore Proposition 44 s0 s1 Sast Similarly ii Proposition 44 obtain sn1 sn Saend These facts s1 s2 sn1 S A2 An1 yield s0 sn SA cid2 The proposition implies analysing state dynamics executable plan replace start end durative action Da corresponding ones auxiliary sequence Da start end isolated actions This useful reasons On hand cases Da strongly safe Da On hand directly apply Theorem 38 Da length 2 22 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 aend As shall later suﬃcient results invariance template require safety strong simple auxiliary actions Da ast The check strong safety considering single components Da referring analysis carried previous section Below characterisation simple safety auxiliary actions Note ﬁrst Da ast aend strongly γ safe aend strongly γ safe If properties Da γ unreachable Da weakly γ safe Remark 29 If instead assume Da weakly γ safe γ reachable Proposition 36 aend γ unbounded The following result completely characterises simple γ safety actions weakly γ safe Deﬁnition 35 necessarily Da executable ast Proposition 46 Let Da ast weakly γ safe following mutually exclusive conditions satisﬁed γ reachable sequence ast aend strongly γ safe aend γ unbounded Then Da ast b ast c ast d ast γ irrelevant Pre 1 Pre astγ astγ γ irrelevant Pre 1 Pre astγ astγ γ irrelevant Pre 0 Pre astγ astγ Effaendγ γ relevant Eff astγ Eff astγ cid2 Eff astγ Effastγ Pre astγ Effaendγ Effaendγ γ T Proof Note Da γ reachable ast strongly γ safe Hence Da weakly γ safe Daγ individually γ safe This fact equivalent showing given state sequence s0 s1 s2 SDaγ s0 γ T wγ s0 1 holds wγ si 1 2 1 follows strong safety ast Let Wγ s1 γ T s0 s2 γ T wγ s0 1 s0 s1 s2 SDaγ We need s1 Wγ wγ s2 1 s2 ξaend γ s1 s1 Eff aendγ Eff aendγ Since aend γ unbounded condition wγ s2 1 equivalent s1 Effaendγ 12 Since ast γ reachable strongly γ safe follows Theorem 18 γ irrelevant γ relevant If Combining 12 astγ 1 Wγ Pre astγ Eff γ irrelevant Pre ast astγ case Da γ safe astγ astγ Pre Eff Effaendγ This leads possible cases b γ irrelevant Pre astγ Suppose ast 0 In case Wγ s1 γ T wγ s1 1 s1 Pre astγ Eff astγ Combining 12 case Da γ safe Pre astγ Eff astγ Effaendγ γ T This leads case c Finally αst γ relevant Wγ Eff condition d veriﬁed cid2 astγ Combining 12 obtain case Da γ safe Remark 47 If Condition Proposition 46 holds implies conditions need satisﬁed ast Pre ast γ 1 Pre ast γ Eff ast γ Deﬁnition 48 Weakly safe durative actions We Da weakly γ safe type x x b c d γ reachable ast γ unbounded ﬁnally Da satisﬁes condition x Proposition 46 strongly γ safe aend Example 9 Consider template T instance γ γ T q q types ad cid7 Fig 5 shows possible instances actions 13 14 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 23 Fig 5 Examples weakly γ safe actions types ad See Example 9 Fig 6 The sequence A individually γ safe See Example 10 When start end durative action Da happens simultaneously actions reduction Da Da performed general shown following example cid7 Example 10 Consider template T instance γ γ T q q considered isolation ast actions Da Da cid7 end aend γ safe However consider case Da Da A A1 ast s1 ξs0 A1 q q γ irrelevant Da Da cid7 st A2 ainv cid7cid7 Fig 6 shows durative strongly γ safe γ unreachable Since individually happen simultaneously giving rise sequence cid7cid7 wγ s0 1 cid7cid7cid7 wγ s1 3 violates deﬁnition individual γ safety cid7 inv A individually γ safe In fact set s0 q cid7 strongly γ safe Proposition 44 Da Da cid7cid7 q cid7 q cid7 st cid7 cid7 Note previous example durative actions γ unreachable The following result shows pathological phenomena happen case instrumental results section Proposition 49 Let Da γ reachable durative action ast strongly γ safe ast strongly γ safe Then γ bounded ast ii action set A1 ast A1 ainv executable ast A1 ainv individually γ safe Proof Since Da γ reachable follows Proposition 36 ast necessarily γ unbounded In particular yields Pre γ balanced Since γ unreachable Da γ reachable follows Corollary 21 ast γ bounded This proves intersection Eff ast γ Therefore Pre astγ This says ast Pre ainv γ Eff ast γ ast γ 24 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Fig 7 The sequence A individually γ safe See Example 11 Suppose sequence ast A1 ainv executable let q Eff ast γ Note q belong Eff Pre ast γ ast actions A1 noninterfering On A1 γ By follows q Effast γ Pre astγ ainv γ ast γ hand q belong Pre As result Eff sequence executable Therefore possibility Consider A1 action set obtained A1 eliminating q Eff positive effects belonging γ T We ast A1 ast A1 Consider sequence A1 ast ainv note A1 γ irrelevant ast ainv individually γ safe iv Proposition 44 Therefore Proposition 26 A1 ast ainv individually γ safe ast A1 ainv cid2 Eff A1 γ ast γ No similar results hold end parts durative actions example shows γ irrelevant Da Da Example 11 Consider template T instance γ γ T q q Fig 7 considered isolation aend cid7 st Moreover Da Da A A1 ainv s1 ξs0 A1 s2 ξs1 A2 q q cid7 When durative actions Da Da individually γ safe happen simultaneously giving rise sequence cid7 end A individually γ safe If s0 wγ s0 0 cid7 wγ s2 2 violates deﬁnition individual γ safety cid7 strongly γ safe Proposition 44 Da Da strongly γ safe γ bounded Since ast γ reachable However Da Da cid7 inv A2 aend cid7 end cid7 cid7 cid7 cid7 6 Conditions invariance template Any plan π actions strongly safe durative actions safe place isolation actions happening yields safe happening sequence Aπ consequence Corollary 27 The diﬃculty general durative actions principle start end intertwined instan taneous durative actions Safety durative actions accompanied suitable hypotheses guaranteeing dangerous intertwinements simultaneous happenings place executable plans In way work suﬃcient conditions invariance template useful analysing concrete examples In section present results suﬃcient conditions invariance template The ﬁrst deals particular case instantaneous actions strongly safe durative actions Da Da strongly safe The second result considers general case durative actions Da Da weakly safe Considering template T instance γ denote GAdwk γ collection durative actions strongly γ safe GAstwk γ GAendwk γ collection start end fragments respectively The following property prevents simultaneous end durative actions yield unsafe phenomena Deﬁnition 50 Relevant right isolated actions For template T set durative actions GAd said relevant right isolated instance γ Da1 Da2 GAdwk γ following conditions satisﬁed Eff a1end γ Eff a2end γ 1 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 25 ii pairs a1end a2end a1inv a2inv mutex non executable iii sequence a1inv a2inv a1end a2end γ unreachable Theorem 51 Consider template T suppose set instantaneous actions GAi durative actions GAd satisfy following properties GAi strongly safe ii instance γ Da GAdwk γ Da γ reachable strongly γ safe iii GAd relevant right isolated Then T invariant Proof Consider executable simple plan π happening sequence Aπ At0 At k Aπ individually γ safe We split happenings follows Ati Ast ti As ti Aend ti instance γ We prove consists start fragments GAdwk γ consists ending fragments GAdwk γ Ast ti Aend ti As ti At Ast ti Aend ti durative actions GAd GAdwk γ consists strongly γ safe actions instantaneous possibly starting ending ti Ast ti Ast ti ainv Ast ti cid14 consists strongly γ safe actions strongly γ safe exists durative Note Ast ti action Da GAdwk γ ast strongly safe ast Ast Considering second case note Ati1 simply ti consists ainv possibly fragments durative actions The executability Ati Ati1 yields ainv By hypothesis Da ainv Ati1 ii Proposition 32 executability Ati ainv individually γ reachable ast γ safe Using iii Proposition 26 obtain Ast Ati1 ti individually γ safe Similarly Aend strongly γ safe apply Proposition 49 conclude Ast ti Ati1 individually γ safe Therefore Ast ti cid14 consists strongly γ safe actions strongly γ safe exists durative action Da GAdwk γ aend strongly γ safe aend Aend Suppose exists cid7 end aend durative action Da necessarily composed noninterfering actions executable Since GAd right relevant isolated cid7 end γ unreachable Since Ati1 consists actions implies sequence ainv effects follows Proposition 32 sequence Ati1 Aend γ unreachable individually action set obtained Aend γ safe The possibility Eff Aend ti γ aend Aend aend eliminating positive effects belonging γ T We Aend ainv contains preconditions Aend individually γ safe v Proposition 44 Considering Ati1 γ safe applying order items iii ii Proposition 26 obtain Ati1 aend Ati1 aend Aend Ati1 Aend Note ainv strongly ﬁnally cid7 end γ heavy The pairs ainv Consider case Aend cid7 GAdwk γ individually γ safe cid7 inv aend cid7 inv aend cid7 end Aend cid14 Ast ti aend γ Eff ti ti ti ti ti ti ti ti ti ti Note happening time ti possibilities Ast ti Ast ti ti ti As case Ati ti case As ti Aend cid14 Aend obtain As ti cid14 arguing analogously case obtain Ati1 Ati individually γ safe Aend cid14 arguing analogously case obtain Ati1 Ati Ati1 individually γ safe cid14 Aend strongly γ safe deﬁnition Ast ti Ati1 Ati Ati1 As ti Ati1 individually γ safe ii Proposition 26 Ast ti Ati1 individually γ safe Ast ti ti Ast ti Ast ti ti Using Corollary 27 obtain Aπ individually γ safe cid2 Note assumption iii statement Theorem 51 excludes simultaneous end durative actions phenomena excluded apriori hypothesis removed4 4 It believable synchronise beginning actions ends imagine deﬁning temporal planning language priori excludes simultaneous endings having effect sequenced We imagine imposing restriction beginnings It 26 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Fig 8 Action schemas Da Da cid7 intertwine way rise sequence individually γ safe See Example 12 When durative actions Da Da strongly γ safe hypotheses needed order guarantee template T invariant In case simultaneity harmful intertwinement durative action actions The following examples type phenomena happen theorem extending Theorem 51 needs prevent cid7cid7 Both durative actions Da Da Example 12 Consider template T instance γ γ T q q Fig 8 γ safe However intertwine way rise sequence individually cid7 end If s0 q wγ s0 1 s4 γ safe A A1 ast A2 cid7cid7 wγ s4 2 q cid7 st A3 aend A4 cid7 q cid7 q cid7 The following deﬁnition describes set durative actions phenomena place It consists requirements acting instantiation γ subset GAdγ durative actions containing potentially dangerous actions GAdwk γ The ﬁrst prevents simultaneous happening start fragments durative actions The second requirement states instead happening start fragments end durative action GAdγ This fact ﬁniteness plans lead impossibility intertwining durative actions family GAdγ Finally requirement prevents possibility γ relevant actions happen middle durative action GAdγ Before stating exact deﬁnition set following notation Given instance γ GAdγ subset durative actions denote GAstγ GAendγ respectively set start end fragments Deﬁnition 52 Relevant non intertwining actions Given template T set durative actions GAd said relevant non intertwining instance γ ﬁnd subset durative actions GAdγ GAdwk γ following property satisﬁed For Da GAdγ γ reachable Daadmissible sequence actions A A1 A2 An1 An A1 GAstγ following conditions satisﬁed 15 A1 ast ii If b A j GAstγ 1 j n exists b iii If A j GAstγ GAendγ j 2 n 1 A j γ irrelevant j 2 n 1 cid7 GAendγ 1 j cid7 A j cid7 j Considering deﬁnition subsets durative actions possibly larger GAdwk γ leads ﬂexible theory An instance ﬂexibility later shown Example 13 PDDL21 tries beginnings endings nomovingtargets rule fact PDDL21 permits precise synchronisation different result seen Example 10 In case scenarios condition iii costly check omitted S Bernardini et al Artiﬁcial Intelligence 258 2018 165 27 The following main technical result section expresses suﬃcient condition template invariant assumptions instantaneous durative actions safe relevantnonintertwining property holds Later look easytocheck conditions guarantee relevant non intertwining property Theorem 53 Consider template T suppose set instantaneous actions GAi durative actions GAd satisfy following properties GAi strongly safe ii Da GAd Da safe iii set GAd relevant non intertwining Then T invariant Proof Fix executable simple plan π happening sequence Aπ At0 At k wγ Init 1 We prove Aπ individually γ safe instance γ Assume Consider set durative actions GAdγ Deﬁnition 52 Suppose prove Da GAdγ appears π time window th tk ast Ath aend Atk corresponding action sequence A Ath Atk satisﬁes following conditions h k Ati consists exclusively γ irrelevant actions b h k Ati contain actions GAstγ ast Ath Note b holds true Da GAdγ automatically c h k Ati contain actions GAendγ aend Atk Assuming hold proceed proof Theorem 51 split happening Ati way We let Ati Ast ti As ti Aend ti following Ast ti Aend ti As ti consists start fragment GAstγ consists ending fragment GAendγ At Ast ti Aend ti consists strongly γ safe actions We consider new plan π π t π As t t cid9 π Aend t t cid9 π Ast t cid9 0 chosen way cid9 ti1 ti 0 k 1 It follows Proposition 1 serializability plan π executable We denote happening sequence A π At0 At k For sake notational simplicity happening times denoted π general differ form larger set Note happening times π split singletons ti Ati consists strongly γ safe actions intervals ti1 t j exists durative action Da GAdγ happening interval In case subsequence A Ati1 At j Daadmissible Let A Ati ainv Note A executable appears executable plan A executable Proposition 45 Since assumption ii Da γ safe follows Theorem 38 A γ safe Using Proposition 45 ﬁnally obtain A individually γ safe ainv At j We proven happening time ti new plan π stays inside individually γ safe sequence possibly length 1 Fig 9 By Corollary 27 implies A π individually γ safe A repetitive use statement ii Proposition 26 yields Aπ individually γ safe We left proving durative action Da GAdγ π satisﬁes properties b stated Suppose true let Da ﬁrst action start π time window th tk violate condition b Note durative actions GAdγ happening π starting strictly time th necessarily end time t th way Da chosen Moreover durative actions satisfy properties h note th b We proceed consider splitting Ati Ast ti As ti Aend ti 28 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Fig 9 Structure plan π constructed Theorem 53 Strongly safe actions indicated green relevant red irrelevant grey For interpretation references colour ﬁgure legend reader referred web version article th Consider auxiliary plan π constructed exactly principle starting action Ast th like t th coinciding π t th As denote happening sequence A π At0 At k notation happening times π assume Ath Ast simplicity notation th considering instead Athcid9 Ast Note π executable wγ Init 1 sequence Aπ γ reachable consequently ii Proposition 32 A π γ reachable Arguing obtain At0 Ath1 individually γ safe If s0 sk SA π γ wγ sh1 1 Consider A Ath Ath1 Atk Ast Ath1 Atk note sh1 sk SAγ A γ reachable It follows ast Suppose property b stated relevant non intertwining property Deﬁnition 52 Ast th GAstγ cid14 By ii Deﬁnition 52 follows satisﬁed let l h k ﬁrst index Atl cid7 h l Note durative exist durative action Da action start plan π plan π time th way Da chosen start time th previous considerations interval th tlcid7 way l chosen This proves property b satisﬁed Note shows Ati contain actions GAendγ h k corresponding start fragment happen time th Finally Ati γ irrelevant h k iii Deﬁnition 52 Therefore A satisﬁes properties b contrarily assumptions Da The proof complete cid2 cid7 GAdγ cid7 end Atl cid7 l th cid7 The properties set durative actions GAd needs satisfy relevant non intertwining expressed Deﬁnition 52 general diﬃcult check require considering sequences actions possibly length Below suﬃcient condition guarantees properties hold involves pairs durative instanta neous actions It computationally simpler suitable later analysed lifted level action schemas We start property pairs actions veriﬁed prevents happening action followed executable plan irrelevant actions certain family happen See 5 recall cid7 cid7 deﬁnition postconditions cid8 cid8 action Deﬁnition 54 Mγ unreachable actions Consider template T instantiation γ subset Mγ GA γ irrelevant actions A pair actions exists q cid8 ii exists q cid8 Eff iii Pre aγ Pre acid7 Pre acid7 aγ 1 cid7 Mγ unreachable following conditions satisﬁed cid7cid7 Mγ q Eff cid7cid7 Mγ q Eff acid7cid7 acid7cid7 Pre cid7 γ The ﬁrst condition essentially says application action leads state containing ground atom q needs false order apply action Mγ atom false The second condition analogous ﬁrst exchanges role true false atoms Finally condition requires cid7 γ unreachable pair assuming executable The following result explains chosen properties cid7 Proposition 55 If pair actions cid7 Mγ unreachable sequence actions A A2 An1 cid7 2 n 1 Ai Mγ γ unreachable Proof Assume contradiction exists γ reachable sequence A A2 An1 cid7 A j Mγ j Consider s0 sn SAγ Suppose condition satisﬁed We q s1 assumption follows q Eff j 2 n 1 Therefore q sn1 Since q Pre acid7 contradiction A similar argument condition ii satisﬁed A j S Bernardini et al Artiﬁcial Intelligence 258 2018 165 29 Finally assume condition iii satisﬁed Note A2 An1 γ irrelevant Pre aγ contradicts fact s0 sn SAγ cid2 Pre cid7 γ Eff aγ s0 The following stronger version relevant non intertwining property completely formulated level pairs actions referring sequences It consists points correspond properties required Deﬁnition 52 It convenient ﬁrst introduce additional notation Given instance γ GAdγ subset durative actions denote GAγ irr GAγ rel set actions GA GAstγ GAendγ respectively γ irrelevant γ relevant Deﬁnition 56 Pairwise relevant nonoverlapping actions For template T set durative actions GAd said pairwise relevant nonoverlapping instance γ ﬁnd subset durative actions GAdγ GAdwk γ following properties satisﬁed A Da1 Da2 GAdγ following conditions holds true Ai pairs a1st a2st a1inv a2inv mutex non executable Aii sequence a1st a2st a1inv a2inv γ unreachable Aiii pairs a1inv a2end a1end a2inv mutex Da1 Da2 equivalent pair a1end a2end mutex non executable B Da1 Da2 GAdγ following conditions holds true Bi a1inv a2st mutex Bii a1st a2st GAγ irrunreachable Biii pairs a1inv a2end a1end a2inv mutex pair a1end a2end mutex non executable C Da1 GAdγ a2 GAγ rel following conditions satisﬁed Ci a1inv a2 mutex Cii a1st a2 GAγ irrunreachable The result expresses suﬃcient condition set GAd relevant non intertwining Proposition 57 Consider template T The set GAd relevant non intertwining following conditions satisﬁed Da GAd ast strongly safe ii GAd pairwise relevant nonoverlapping Proof For ﬁxed γ consider set durative actions GAdγ Deﬁnition 56 Let Da GAdγ consider γ reachable Daadmissible sequence A A1 A2 An1 An cid7 st ainv cid7 st A1 We Da Da cid7 inv noninterfering executable We ast cid7 cid14 A1 GAstγ We ﬁrst property Deﬁnition 52 holds true Assume contradiction Da cid7 violate property A deﬁnition Indeed A Da cid7 inv cid7 st ainv admissible ast γ reachable Note ﬁrst A1 A2 clearly γ reachable By assumption ii A1 A1 ast cid7 st consists strongly γ safe actions Consider A A1 ast cid7 st A2 Notice s0 s1 s2 S A1 A2γ s0 s1 s1 s2 S Aγ cid7 st A2 γ reachable s1 s1 s2 SB Considering s1 wγ s1 1 This implies B ast cid7 inv γ reachable Finally note A2 consists invariants Proposition 32 ast appear Ak k n appear An appear end fragment durative action Da ends plan A subsequence end Da In ﬁrst sequence durative action Da cid7 end case respectively ainv mutex non executable Note second case happen Da Da equivalent differ fragment standing assumption simple plans This shows Aiii hold Therefore GAstγ ast This proves Deﬁnition 52 cid7 inv noninterfering In second case aend cid7 end aend cid7 st ainv cid7 cid7 cid7 cid7 GAdγ Suppose ii Deﬁnition 52 hold true A Let j 1 ﬁrst index ii violated cid7 j The pair cid7 st A j A j cid7 st noninterfering Deﬁnition 41 admissible sequence Moreover arguing previous case conclude pairs a1inv a2end a1end a2inv cid7 st cid7 cid2 GAγ irr Let cid7 j A j cid7 GAstγ GAendγ exist b cid71 b γ reachable construction cid7 1 property C Deﬁnition 56 violated Therefore proves ii Deﬁnition 52 ﬁnd Da ainv timing end fragments Da Da noninterfering pair a1end a2end noninterfering executable Since ast A2 A j1 γ reachable follows assumption B Deﬁnition 56 exist 0 j cid7 j A j Ah GAγ irr h 2 j ﬁrst index happens Since construction A j cid7 GAγ rel Clearly ainv b non interfering ast A2 A j cid7 GAendγ 0 j cid7 30 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Suppose A j GAstγ GAendγ j 2 n 1 If iii Deﬁnition 52 hold true γ irrelevant let b A j A consider j 1 ﬁrst index iii violated A j action γ irrelevant Clearly b GAγ rel arguing deduce Da b violate property C The proof complete cid2 Based previous results conclude simple suﬃcient condition invariance useful analysing concrete cases Corollary 58 Consider template T suppose instance γ Da GAdwk γ Da weakly γ safe type GA GAstwk γ GAendwk γ γ irrelevant γ balanced Then T invariant Proof It clear condition ii Theorem 53 satisﬁed In order check GAd relevant non intertwin ing properties ii Proposition 57 satisﬁed Fix instance γ Note assumption st ast irrelevant strongly γ safe Therefore Da weakly γ safe type implies particular property satisﬁed We choosing GAdγ GAdwk γ properties A B C pairwise relevant non overlapping property satisﬁed Consider Da1 Da2 GAdwk γ It follows fact Da1 Da2 weakly γ safe type Remark 47 Pre ai st γ qi Eff ai st γ 1 2 16 If a1 st a2 st noninterfering follows q1 cid14 q2 case a1 st a2 st γ unreachable This proves property A In order prove B 16 consider possible cases If q1 q2 q1 cid8 γ irrelevant This implies condition ii acid7cid7 Deﬁnition 54 satisﬁed If instead q1 cid14 q2 condition iii Deﬁnition 54 instead satisﬁed In case says pair a1 st a2 st GAwk γ irrunreachable This proves B Finally C proven exactly like B cid2 a2 st q1 γ T sure q1 Eff Pre a1 st cid7cid7 Our results broader application case Corollary 58 shown following example Example 13 Consider domain durative actions Da1 Da2 shown Fig 10 template T cid7 Da1 strongly γ safe Da2 weakly γ safe type Note Corollary 58 instance γ γ T q q applied a1end γ bounded Indeed template invariant Fig 10 shows triple intertwinement copies Da1 Da2 leads sequence individually γ safe This sequence certainly thought happening sequence executable simple plan Consequently T invariant If modify durative action Da1 adding condition Prea1inv q intertwining proposed longer admissible sequence Even Corollary 58 applied modiﬁcation set GAd Da1 Da2 pairwise relevant non overlapping To ﬁx GAdγ Da1 Da2 Deﬁnition 56 Conditions A B checked ordered pair durative actions In case possibilities identical copies Da1 Da2 pair Da1 Da2 pair Da2 Da1 Note pick copies Da1 conditions Aiii Biii hold true condition If pick copies Da2 Ai holds true Moreover considering GAγ irr follows pair a2st a2st GAγ irrunreachable condition ii Deﬁnition 54 satisﬁed Therefore copies Da2 satisfy condition Bii Finally consider pair Da1 Da2 Da2 Da1 cid7 a1st a2st γ unreachable Aii satisﬁed Using condition ii Pre Deﬁnition 54 check pairs a1st a2st a2st a1st GAγ irrunreachable Bii holds true Finally note condition C case GAγ rel Thanks Proposition 57 Theorem 53 conclude T invariant a1sta2st q q 7 Safety action schemas template In Section 6 presented results guaranteed invariance template Theorems 51 53 Corollary 58 To applied need check instantaneous durative actions satisfy safety condition extra properties prevent potentially dangerous simultaneous happenings intertwinements actions Since aim ﬁnd invariants offline quickly eﬃciently algorithm work level actions Instead reasons lifted level uses structure action schemas conditions effects decide ground instantiations schemas safe Our main goal section obtain lifted versions Theorems 51 53 Corollary 58 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 31 Fig 10 A triple intertwinement copies action schemas Da1 Da2 leads sequence individually γ safe See Example 13 In section following sections important assumption groundings action schemas Precisely action schema α instantaneous durative assume grounding functions consider gr V α O injective This restriction plays crucial role formulations results hand essentially entail loss generality allow suitable modiﬁcation domains action schemas First observe domains injectivity follows automatically type restrictions explicit constraints given variables x1 x2 action α preconditions α contain requirement x1 cid14 x2 If variables bound value proceed follows Given subset variables W V deﬁne action schema α W substituting variable w W amalgamated symbol W formulas α For example action schema moverbt loc1 loc2 create additional schema moveSamerbt loc The set free variables new action schema α W V α W V α W W Note injective grounding α W corre sponds grounding gr α grw 1 grw 2 w 1 w 2 W injectivity maintained grv 1 cid14 grv 2 v 1 v 2 cid2 W Adding action schemas α W W varies possible subsets V α equivalent considering possible grounding functions original action schema α This procedure potentially leads exponential increase cardinality V α number action schemas However practical applications possibility noninjectivity typically limited variables procedure leads controlled growth number schemas consequently computation complexity Following assumption 2 concerning singleton actions sets actions assume action schema satisﬁes condition Pre α Pre α 17 Note conditions 17 injectivity constraint groundings automatically imply grounded action grα satisﬁes condition 2 gr In general liftable property P ground actions given action schema α instantiation satisﬁes P instantiations grα satisfy P In case action schema α satisﬁes property P α The results presented sections achieve main goals On hand properties safety introduced instantaneous durative actions Sections 4 5 liftable non intertwining properties weaker sense formulation Theorems 51 53 On hand eﬃcient characterisations properties lifted level use algorithmic implementation Section 9 In remaining section analyse action schemas ground instantiations We strong safety liftable work complete characterisation property lifted level The section devoted lifting properties durative actions 32 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 71 Structure properties action schemas We start following deﬁnition introduces key concept matching It couples action schema template allows understand ground world ground formula appearing action schema γ T Deﬁnition 59 Matching Consider template T C FC action schema α A A formula l appears α said match T templates component c cid9rk pcid10 C Rell cid9rkcid10 ii l universally quantiﬁed VarQl p Given formulas l l cid7 α T coupled write l T l cid7 cid7 l l b c FC c cid7 j Varl Varl cid7 j individually match T components c c cid7 We ﬁx template T action schema α study properties relation T literals α match T introduced First following simple result Proposition 60 For template T C FC action schema α T equivalence relation Proof Reﬂexivity symmetry obvious deﬁnition Regarding transitivity assume l1 l2 l3 formulas α matching T components c1 c2 c3 respectively l1 T l2 l2 T l3 Suppose c1 F c1 c3 j F c3 c1 FC c3 j The fact FC admissible partition implies exists c2 h F c2 c1 FC c2 h FC c3 j The assumptions l1 T l2 l2 T l3 yield Varl1 Varl2 h Varl3 j This shows l1 T l3 cid2 Deﬁnition 61 T class For template T C FC action schema α equivalence class literals respect T called T class We derive concrete description concept matching Remark 62 Suppose l formula action schema α matches template T component c cid9rk pcid10 The possible structure l shown p k l rv 0 vk1 v V α p k l rv 0 vk1 v V α p k l v p rv 0 vk1 cid14 p v V α 18 Suppose l1 l2 formulas action schema α match template T c1 cid9r1k1 p1cid10 c2 cid9r2k2 p2cid10 respectively We represent 1 2 li riv pi ki The T coupling condition l1 T l2 equivalent requiring pair ﬁxed variables c1 j F c1 c2 h F c2 following holds li v pi riv 0 v 0 v ki 1 ki 1 c1 j FC c2 h v 1 j v 2 h 19 We consider grounding function gr α instance γ T If l formula α matches T component c cid9rk pcid10 depending structure l illustrated 18 l rv 0 vk1 l v p rv 0 vk1 grl rx0 xk1 xp O xi grv cid14 p grl rx0 xk1 xi grv 20 Considering deﬁnition γ T 3 fact quantiﬁed case appear p k follows grl subset γ T intersection γ T This motivates following deﬁnition Deﬁnition 63 Coherence gr γ coherent l grl γ T Referring representation 20 coherence equivalently expressed grv j γ c j j cid14 p 21 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 33 The following result immediate conditions 21 Proposition 64 Consider template T C FC action schema α Let l formula action schema α matches T Then grounding function gr α possible ﬁnd instance γ T gr γ coherent l vice versa The following result explains coherence interacts equivalence relation T Lemma 65 Consider template T C FC instance γ action schema α grounding gr Assume gr γ coherent formula l1 α let l2 formula α matches T Then gr γ coherent l2 l2 T l1 Proof We assume 1 2 li matches T components ci cid9riki picid10 We represent li Remark 62 li riv 0 v ki 1 li v pi riv 0 v ki 1 The fact gr γ coherent l1 yields grv 1 j γ c1 j j cid14 p1 22 Suppose l2 T l1 consider ﬁxed variable c2 h c2 h 0 k2 1 p2 From fact FC admissible partition follows ﬁnd ﬁxed variable c1 j c1 c1 j FC c2 h The T coupling condition 19 implies v 1 j h This yields 22 fact γ instance v 2 grv 2 h grv 1 j γ c1 j γ c2 h We proven grv 2 h γ c2 h h cid14 p2 23 On hand assume gr γ coherent l2 pick ﬁxed variables c1 j c2 h c1 c2 respectively c1 j FC c2 h Using deﬁnition instance equations 22 23 h This shows T coupling obtain grv 2 condition 19 expressed Remark 62 holds true Therefore l2 T l1 cid2 j The standing assumption gr injective yields v 1 h grv 1 v 2 j The following result immediately follows deﬁnition coherence Lemma 65 Proposition 66 Suppose M subset formulas appearing α Then grM γ T grM L L T class formulas α gr γ coherent Proposition 66 important practical consequence Once gr γ ﬁxed α formulas class L gr γ coherent affect state dynamics concerning set γ T Precisely grα follows deﬁnition aγ Remark 15 Pre aγ grPre α L Eff aγ grEff α L Considering Proposition 16 strongly γ safe aγ strongly γ safe property strong safety action schema α depend formulas α match T Hence principle property analysed studying restrictions α different T classes L matching formulas This intuition leads following deﬁnition Deﬁnition 67 Pure action schemas Considering template T action schema α T class L formulas α deﬁne αL action schema consider formulas belonging L More precisely αL action schema Pre αL Pre αL We αL pure action schema L α Eff Eff α L 34 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Example 14 Floortile domain Consider template T f t robotAtrx cleary Eff cleary α Example 2 action schema α paintUpst Pre α Note formulas robotAtrx cleary α match T f t form different T classes satisfy condition ii Deﬁnition 59 L1 robotAtrx L2 cleary Consider instance γ1 associates tile1 ﬁxed variable components T f t grounding function grr rbt1 grx tile1 gry tile2 In case gr γ1 coherent T class L1 We pure action schemas corresponding α αL1 αL2 αL1 following speciﬁcation Pre αL1 robotAtr x αL2 Pre αL2 cleary Eff αL2 cleary 72 Pure action schema classiﬁcation We carry detailed analysis pure action schemas showing particular check strong safety action grα eﬃciently performed lifted level working different pure action schemas αL We ﬁx action schema α T class L formulas First introduce concept weight level formulas L allows distinguish simple universally quantiﬁed formulas Precisely given l L deﬁne wl 1 l simple wl ω l universally quantiﬁed ω O For subset A L deﬁne l A wl Note w simply cardinality formulas L simple If consider grounding function w A gr α subset A L following holds cid11 gr A w A 24 Similarly c component T deﬁne wc equal 1 ω c respectively counted variable We need additional concept Deﬁnition 68 Coverage Consider component c T We let Lc subset formulas L match T component c A subset formulas M L said cover component c wM Lc wc M said cover T M covers component c T Remark 69 If consider component c T ground atoms generated c grM M covers c In particular γ T grM M covers T We classiﬁcation pure action schemas αL formally analogous introduced action sets Deﬁnitions 17 19 simply replace preconditions effects aγ αL concept cardinality weight Deﬁnition 70 Classiﬁcation pure action schemas The pure action schema αL unreachable T wPre 2 αL heavy T wPre 1 wEff αL irrelevant T wPre 1 wEff αL relevant T wPre 1 wEff αL αL αL 2 0 αL 1 Deﬁnition 71 Classiﬁcation relevant action schemas The pure relevant action schema αL weighty single relevant precondition wPre αL 1 A weightless wPre 0 αL A weighty action schema αL balanced T Pre Eff αL unbalanced T Pre αL αL Eff αL Eff Eff αL αL A weightless action schema αL bounded T L covers T unbounded T L cover T The following result clariﬁes relation corresponding grounded actions Proposition 72 Consider action schema α T class L formulas grounding function gr instance γ coherent L Let grα Then αL satisﬁes property expressed Deﬁnitions 70 71 satisﬁes corresponding γ property deﬁned Deﬁnitions 17 19 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 35 Proof An immediate consequence fact aγ grαL Equation 24 Remark 69 cid2 We ready following ﬁnal result concerning strong safety general action schemas It shows strong safety seen property action schema interpreted analysing pure parts Corollary 73 Strong safety liftable property Moreover action schema α strongly safe T class formulas L α αL unreachable irrelevant balanced bounded Proof Suppose grα gr let γ instance Then aγ grαL L T class gr γ coherent The result straightforward consequence Proposition 72 Corollary 21 cid2 Example 15 Floortile domain Consider template T f t action schema α paintUpst Example 14 The pure action schemas αL1 αL2 irrelevant strongly safe Hence α strongly safe Now consider action schema αcid7 paintUpend speciﬁcation Eff αcid7 paintedy c This pure action schema It unbounded strongly safe An immediate consequence Corollary 23 Corollary 74 Given template T T invariant α A α strongly safe 8 Durative action schemas Our goal work proper lifted versions properties durative actions presented Section 5 particular involved statement main results Theorems 51 53 Some properties concern durative action safety involve actions noninterfering irrelevantunreachable We start analysing ﬁrst type properties presenting particular explicit characterisation safety durative actions lifted level We use following notation Take durative action schema Dα αst αinv αend grounding function gr Dα We let Da grDα Da ast ainv aend ast grαst ainv grαinv aend grαend Our ﬁrst goal lift assumptions 8 9 durative actions First deﬁne generic action schema α subsets postconditions cid8 α Pre α Eff α Eff α cid8 α Pre α Eff α Eff α We standing assumption durative action schema Dα αst αinv αend satisﬁes relations cid8 Pre αst αend cid8 αst αinv Pre αinv Pre αinv Pre αend Pre Pre αinv 25 26 Since recall grounding functions injective 25 26 equivalent requiring grounding function Da grDα satisﬁes conditions 8 9 Also deﬁne auxiliary durative action schema Dα αst αend αst αend action schema Eff Eff αst αend Eff Eff Pre αst αend Pre αst αend Pre αst Pre αend Pre αinv Pre αinv Eff αst Da grDα corresponding auxiliary action previously deﬁned Section 52 81 Safety durative action schemas We ﬁx template T start analyse safety We consider durative action schema Dα auxiliary action schema Dα groundings Da grDα Da grDα Strong safety durative actions reduces strong safety components liftable property As consequence talk strong safety Dα Dα equivalent strong safety groundings Da grDα respectively Da grDα Checking property lifted level applying Corollary 73 start end fragments We want characterise simple safety auxiliary durative action Da grDα lifted level First consider executability 36 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Proposition 75 Executability auxiliary durative actions lifted property Precisely Dα executable cid8 αst Pre αend cid8 αst Pre αend Proof An immediate consequence Proposition 30 cid2 27 Assume Dα executable Fix grounding gr let Da grDα Consider instance γ let L T class formulas Dα gr γ coherent Let DαL αst L αend L Note Daγ grDαL Therefore simple γ safety Da depends Daγ executability assumed expect property formulated terms pure auxiliary durative action schema DαL To aim durative action schemas classiﬁcation introduced durative actions Deﬁnition 48 First need concept DαL αst L αinv αend L L Deﬁnition 76 Reachable action schemas DαL said reachable executable wPre αst L Pre αend L Eff αst L 1 Proposition 77 If gr γ coherent L Da grDα Daγ γ reachable DαL reachable Proof An immediate consequence Propositions 31 66 equation 24 cid2 Deﬁnition 78 Safe durative action schemas When DαL DαL reachable ii αst L strongly safe iii αend unbounded L iv DαL satisﬁes conditions αst b αst c αst d αst L irrelevant wPre αst L L irrelevant wPre αst L L irrelevant wPre αst L Effαend L relevant Eff 1 Pre αst L 1 Pre αst L 0 Pre αst L L αst L Eff αst L cid2 Eff αst L Eff αst L Pre αst L Effαend L Effαend covers T L We DαL weakly safe type x x b c d Corollary 79 Safety durative auxiliary actions liftable property Da grDα safe Dα executable For T class L formulas Dα following conditions hold DαL strongly safe αst L strongly safe DαL unreachable DαL weakly safe type x x b c d Proof An immediate consequence previous deﬁnitions Proposition 46 cid2 Example 16 Floortiledomain Consider usual template T f t cid9robotAt2 0cid10 cid9painted2 1cid10 cid9clear1 1cid10 action schema Dα paintUp paintUpst paintUpinv paintUpend single instantaneous action schemas speciﬁcations shown Table 4 In action schema formulas match T f t robotAtrx cleary paintedyc They form T classes L1 robotAtrx L2 cleary paintedyc Note case paintUpst Li equal paintUpst Li 1 2 holds paintUpend Li S Bernardini et al Artiﬁcial Intelligence 258 2018 165 37 Table 4 Durative action schema paintUp abbreviated speciﬁcation See Example 16 α Pre α Eff Eff α α paintUpst robotAtr x cleary cleary paintUpinv robot hasr c upy x paintUpend paintedy c The pure action schemas paintUpst L1 unbounded pure schema paintUpend L2 paintUpst L2 paintUpend L1 strongly safe irrelevant The The pure durative action schema paintUpL1 strongly safe paintUpst L1 paintUpend L1 strongly safe irrelevant The pure schema paintUpL2 weakly safe type paintUpL2 reachable paintUpst L2 paintUpst L2 paintUpend L2 wPre paintUpst L2 Eff strongly safe irrelevant unbounded Pre paintUpst L2 paintUpst L2 1 preconditions start consist cleary delete effects start contain cleary reachable paintUpend L2 contain preconditions 82 Lifting properties multiple actions In section study properties involve action mutex lifted This requires working simultaneously different groundings reason additional concepts needed Consider action schemas α1 α2 instantaneous durative sets variables V α1 V α2 respectively Whenever consider groundings gr1 gr2 α1 α2 respectively pairwise properties actions ai griαi properties sequence a1 a2 set a1 a2 non liftable general depend speciﬁc groundings chosen A key aspect possible presence action schemas pairs variables v V f gr1v 1 gr2v 2 cause ground atom appear actions a1 a2 principle affect validity certain properties noninterference To cope complexity lifted level introduce concept reduced union sets V α1 V α2 common set variables schemas We deﬁne matching α1 α2 subset M V α1 V α2 If v 1 v 2 w 1 v 2 M v 1 w 1 If v 1 v 2 v 1 w 2 M v 2 w 2 We deﬁne set V α1 cid23M V α2 obtained V α1 V α2 reducing pair variables v 1 V α1 v 2 V α2 v 1 v 2 M new variable denoted v 1 v 2 Note case M reduction takes place V α1 cid23 V α2 V α1 V α2 For matching M natural maps π M V f V α1 cid23M V α2 associating variable v v new reduced variable v v j case v v j M The schemas α1 α2 rewritten new alphabet formally substituting variable v V f Mli formula obtained substitution Similarly Ai set formulas αi π Mv If li formula αi denote π formulas π For formulas schemas expressed common variable set V α1 cid23M V α2 jointly apply set theoretic operators If li formula αi Ai set formulas αi 1 2 use notation l1 M l2 M A2 π 1 M A2 Similarly A1 M A2 π 1 Ml2 l1 M A2 π 1 M A1 π 2 Ml1 π 2 Ml1 π 2 Mli li Ai M Ai π We investigate relation matchings speciﬁc groundings schemas Deﬁnition 80 Coherent grounding functions Consider action schemas α1 α2 matching M Two grounding functions gr1 gr2 α1 α2 respectively said Madapted given v V f 1 2 holds gr1v 1 gr2v 2 v 1 v 2 M Remark 81 Note groundings gr1 gr2 consider M v 1 v 2 gr1v 1 gr2v 2 M matching recall maps gri injective gr1 gr2 Madapted Coherent groundings factored reduced set V α1 cid23M V α2 38 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Proposition 82 Consider action schemas α1 α2 matching M grounding functions gri αi 1 2 The following conditions equivalent gr1 gr2 Madapted ii exists injective function gr V α1 cid23M V α2 O gri gr π M 1 2 Suppose gr1 gr2 Madapted groundings α1 α2 let gr function ii previous proposition If Ai set formulas αi 1 2 set theoretic operation holds M A1 grπ 2 gr1 A1 gr2 A2 grπ 1 M A2 gr A1 M A2 This follows Proposition 82 fact gr injective An iterative use 28 shows set theoretic expression grounded actions griαi bijection gr corresponding expression action schemas αi expressed common reduced set V α1 cid23M V α2 As consequence property actions standing assumption Madapted groundings expressed set theoretic operations formulas reformulated rewriting formulas new alphabet V α1 cid23M V α2 This key observation order lift properties pairs actions To concrete consider example noninterfering actions needed follows 28 Deﬁnition 83 Mutex simple action schemas We action schemas α1 α2 M noninterfering cid14 j αi M Eff Eff Preαi M Effα j α j If α1 α2 M noninterfering called Mmutex Deﬁnition 84 Executable action schemas We set M noninterfering action schemas α1 α2 Mexecutable cid14 j Pre αi M Pre α j Proposition 85 Consider action schemas α1 α2 matching M grounding functions gr1 gr2 respectively α1 α2 Madapted Put ai griαi 1 2 Then α1 α2 Mmutex a1 a2 mutex ii α1 α2 Mexecutable a1 a2 executable Proof An immediate consequence Deﬁnitions 88 84 equation 28 cid2 Remark 86 Note certain properties depend matching M monotonic behaviour true matching M remain true larger matching Mcid7 M This case instance properties expressed terms identities formulas type l1 M l2 Mmutex property To cope properties related template instantiations useful introduce family matchings induced presence formulas schemas matching template Precisely consider template T C FC action schemas α1 α2 Consider T classes Li formulas αi 1 2 There natural way associate matching L1 L2 follows Pick formulas li Li 1 2 consider components ci C li matches T ci Let M L1L2 Varl1 j Varl2 h c1 j FC c2 h It immediately follows deﬁnition T coupled pairs formulas Deﬁnition 59 M particular formulas li chosen T classes Li Essentially M L1L2 rewriting variables formulas L1 L2 correspond FC equivalent variables template T The proposition shows role played matching 29 L1L2 depend Proposition 87 Consider groundings gr1 gr2 α1 α2 respectively Madapted Then following facts hold instance γ T Li T classes formulas αi gri γ coherent Then M ii T classes formulas Li αi M L1L2 M exists instance γ T gri γ coherent Li L1L2 M S Bernardini et al Artiﬁcial Intelligence 258 2018 165 39 Proof Fix 1 2 li Li Assume li matches T components ci cid9riki picid10 represent li Re mark 62 li riv 0 v ki 1 li v pi riv 0 v ki 1 Let j cid14 p1 h cid14 p2 c1 j FC c2 h The fact gri γ coherent yields gr1v 1 j γ c1 j γ c2 h gr2v 2 h This implies Deﬁnition 80 v 1 j v 2 h M By deﬁnition 29 M L1L2 M ii Choose γ way gr1 γ coherent γ c1 j gr1v 1 j j cid14 p1 Now ﬁx h cid14 p2 choose j cid14 p1 c1 j FC c2 h Then M L1L2 M γ c2 h γ c1 j gr1v 1 j gr2v 2 h This implies gr2 coherent γ cid2 We ready lift properties Section 6 We start unreachability fragments durative action schemas Deﬁnition 88 Unreachable durative action schemas Take durative action schemas Dα1 Dα2 corresponding T classes formulas L1 L2 1 We α1inv α2inv α1end α2end L1 L2unreachable following conditions satisﬁed 2 We α1st α2st α1inv α2inv L1 L2unreachable following conditions satisﬁed M M Pre ii Pre α1inv α1inv iii wPre α1end L1 L1L2 Pre α2end L1L2 Pre α2end M Pre α2end L2 cid14 cid14 2 matching M M L1L2 cid8 ii cid8 α1st α1st iii wPre M M α1st L1 L1L2 Pre α2inv L1L2 Pre α2inv M Pre α2st L2 cid14 cid14 2 matching M M L1L2 Note check property iii deﬁnition principle involves possible matchings containing L1L2 In Section 92 propose eﬃcient check condition exhibits computational complexity polyno M mial order number variables formulas domain Proposition 89 Suppose Dα1 Dα2 durative action schemas gr1 gr2 corresponding grounding functions Let Dai grDαi consider instance γ Let Li T class formulas Dαi gri γ coherent If α1inv α2inv α1end α2end L1 L2unreachable a1st a2st a1inv a2inv γ unreachable If α1st α2st α1inv α2inv L1 L2unreachable a1st a2st a1inv a2inv γ unreachable Proof We prove ﬁrst point second analogous Let M matching gr1 gr2 Madapted It follows Proposition 87 M M L1L2 Note conditions ii expressed Deﬁnition 88 true M L1L2 true matching M Remark 86 Consequently know conditions ii iii expressed Deﬁnition 88 holds true M It follows 28 following conditions holds ib Pre a1inv iib Pre a1inv iiib Pre a1inv γ Pre a2end Pre a2end Pre a1end γ cid14 cid14 Pre a2inv γ Pre a2end γ 2 By virtue Propositions 30 31 implies a1inv a2inv a1end a2end γ unreachable cid2 We lifted version relevant right isolated 40 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Deﬁnition 90 Relevant right isolated schemas For template T set durative action schemas Ad said relevant right isolated Dα1 Dα2 Ad corresponding T classes L1 L2 formulas Dαi Li strongly safe following conditions satisﬁed use notation M M L1L2 Eff M Eff 1 α1end L1 α2end L2 ii pairs α1end α2end α1inv α2inv Mmutex non Mexecutable iii α1inv α2inv α1end α2end L1 L2unreachable Proposition 91 For template T suppose set durative action schemas Ad relevant right isolated Then GAd relevant right isolated Proof Fix instance γ consider Da1 Da2 GAdwk γ Let Dαi gri 1 2 durative schemas groundings Dai griDαi Let Li T class formulas schema Dαi gri γ coherent Li 1 2 Therefore Dα1 Dα2 satisfy conditions iii Deﬁnition 90 Let M matching gr1 gr2 adapted sense Remark 81 We know Proposition 87 M M L1L2 Note condition holds true holds true larger M Remark 86 yields condition Deﬁnition 50 Similarly condition ii yields condition new M Remark 86 condition ii Deﬁnition 90 follows Proposition 85 Finally condition iii holds true condition iii Deﬁnition 90 follows Proposition 89 Therefore Deﬁnition 90 durative action schemas Dα1 Dα2 satisfy conditions iii deﬁnition From fact gr1 gr2 Madapted follows conditions Deﬁnition 90 yields condition Deﬁnition 50 Condition ii iii Deﬁnition 50 ﬁnally follow conditions ii iii Deﬁnition 90 Propositions 85 89 cid2 We ready propose lifted version ﬁrst invariant result Theorem 51 Corollary 92 Consider template T suppose set instantaneous action schemas Ai durative action schemas Ad satisfy following properties α Ai strongly safe ii Dα Ad T class L DαL strongly safe DαL reachable strongly safe iii Ad relevant right isolated Then T invariant In order lift remaining results invariance template key point lift fundamental Deﬁnition 56 pairwise relevant non overlapping To convenient introduce compact notation concerning sets action schemas relative classes We deﬁne AdCT Dα L Dα Ad L T class Dα AdCwk T Dα L AdCT DαL weakly safe ACT α L α A L T class α α L Dα L called respectively schemaclass durative schemaclass pairs We propose lifted version property unreachability expressed Deﬁnition 54 Deﬁnition 93 MC unreachable schemas Consider template T subset MC ACT α L MC αL irrelevant Consider pair action schemas α1 α2 A relative classes L1 L2 respectively α1 α2 MC L1 L2unreachable following conditions satisﬁed exist l1 cid8 α2 l1 M α1 l2 Pre M α1 α M M α2 l1 M α1 l2 Pre M α1 α M M ii exist l1 cid8 L1L2 l2 schemaclass α L MC matching L1L l1 M Eff L1L2 l2 schemaclass α L MC matching L1L l1 M Eff L1L2 α α iii wPre α1 L1 M Pre α2 L2 α1 L1 M Eff 2 matching M M Note check properties principle involve possible matchings containing M L1L2 In Section 92 propose eﬃcient check condition exhibits computational complexity polynomial order number variables formulas domain S Bernardini et al Artiﬁcial Intelligence 258 2018 165 41 The following result shows notion unreachability Deﬁnition 93 lifted version expressed Deﬁnition 54 Proposition 94 Consider template T subset MC ACT α L MC αL irrelevant Consider pair action schemas α1 α2 A relative groundings gr1 gr2 Let ai grαi consider instance γ Let Li T class formulas αi gri γ coherent If α1 α2 MC L1 L2unreachable a1 a2 Munreachable M set actions obtained For α L MC grounding gr α gr γ coherent L let grα L1L2 Suppose holds q gr1l1 gr2l2 cid81 Proof Let M matching groundings gr1 gr2 Madapted By Proposition 87 M M Consider action M let α action schema grα grounding gr Let L T class formulas α gr γ M α1 α coherent By construction follows α L MC Consider matching gr1 gr Madapted We α implies q Eff This shows condition Deﬁnition 54 satisﬁed Similarly prove condition ii Deﬁnition 93 yields condition ii Deﬁnition 54 Finally fact iii Deﬁnition 93 yields condition iii Deﬁnition 54 follows repeated application relation 28 cid2 L1L Then l1 M Eff M M Pre2 We ready lift Deﬁnition 56 Given set durative actions classes AdCT AdCT AstCT αst L ACT Dα L AdCT AendCT αend L ACT Dα L AdCT ACT irr ACT rel α L ACT AstCT AendCT αL irrelevant α L ACT AstCT AendCT αL relevant Deﬁnition 95 Pairwise relevant nonoverlapping action schemas For template T set durative action schemas Ad said pairwise relevant nonoverlapping ﬁnd set durative schemaclass pairs AdCT AdCT AdCT AdCwk T following properties satisﬁed A Dα1 L1 Dα2 L2 AdCT denoted M M L1L2 following conditions holds true Ai pairs α1st α2st α1inv α2inv Mmutex non Mexecutable Aii α1st α2st α1inv α2inv L1 L2unreachable Aiii pairs α1inv α2end α1end α2inv Mmutex pair α1end α2end Mmutex non Mexecutable B Dα1 L1 Dα2 L2 AdCT denoted M M L1L2 following conditions holds true Bi α1inv α2st Mmutex Bii α1st α2st ACT Biii pairs α1inv α2end α1end α2inv Mmutex pair α1end α2end Mmutex non irr L1 L2unreachable α2 L2 ACT rel denoted M M L1L2 following conditions satisﬁed Mexecutable C Dα1 L1 AdCT Ci α1inv α2 Mmutex Cii α1st α2 ACT irr L1 L2unreachable Proposition 96 Consider template T If set durative action schemas Ad pairwise relevant nonoverlapping corresponding set durative actions GAd pairwise relevant nonoverlapping Proof Consider set durative action schemas classes AdCT Deﬁnition 95 Fix instance γ deﬁne GAdγ set durative actions Da obtained follows Dα L AdCT consider grounding gr Dα gr γ coherent L Da grDα We properties A B C Deﬁnition 56 hold respect choice GAdγ To prove A B ﬁx Da1 Da2 GAdγ Let Dαi gri 1 2 durative schemas groundings Dai grDαi Let Li T class formulas schema Dαi gri γ coherent Li 1 2 By way GAdγ deﬁned Dαi Li AdCT Let M matching gr1 gr2 adapted sense Remark 81 We know Proposition 87 M M L1L2 We know pairs Dαi Li satisfy conditions Ai Aiii Notice Ai Aiii satisﬁed Ai Aiii satisﬁed respect larger matching M Remark 86 Using Proposition 85 conclude Da1 Da2 satisfy corresponding condition Ai Aiii Deﬁnition 56 Finally If instead Dαi Li satisfy Aii condition Aii Deﬁnition 56 follows Da1 Da2 Proposition 89 Condition A pair Da1 Da2 satisﬁed 42 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 We come condition B We know pair Dαi Li satisfy conditions Bi Biii Arguing previous point satisfy Bi Biii Da1 Da2 satisfy corresponding Bi Biii Deﬁnition 56 Alternatively Bii Dαi Li yields Bii Da1 Da2 consequence Proposition 94 We ﬁnally consider condition C To aim ﬁx Da1 GAdγ a2 GAγ rel Consider action schema Dα1 Ad α2 A corresponding groundings gri 1 2 Da1 gr1Dα1 a2 gr2α2 Let Li T class formulas schema gri γ coherent Li 1 2 By way GAdγ deﬁned Dα1 L1 AdCT rel We Dα1 α2 satisfy properties Ci Cii Arguing previous points obtain properties imply corresponding Ci Cii Da1 a2 α2 L2 ACT The proof complete cid2 We ready lifted versions main results Theorem 53 Corollary 58 Proofs straightforward consequences previous deﬁnitions results Corollary 97 Consider template T suppose set instantaneous action schemas Ai durative action schemas Ad satisfy following properties α Ai strongly safe ii Dα Ad Dαst strongly safe Dα safe iii Ad pairwise relevant nonoverlapping Then T invariant Corollary 98 Consider template T suppose set instantaneous action schemas Ai durative action schemas Ad satisfy following properties Dα L AdCwk T DαL weakly safe type ii α L ACT AstCwk T AendCwk T αL irrelevant balanced Then T invariant We end section presenting examples IPCs apply Corollaries 98 92 demonstrate invariance templates consideration Corollary 97 general complex cases Example 17 Floortiledomain Consider usual template T f t cid9robotAt2 0cid10 cid9painted2 1cid10 cid9clear1 1cid10 The action schemas domains Ad changeColor paintUp paintDown right left The schemas paintUp paintDown symmetrical differ formulas matching T f t They T classes L1 robotAtrx L2 cleary paintedyc As seen Example 16 pure schemas paintUpst paintUpend irrelevant paintUpL2 weakly safe type The holds L1 L1 paintdownL1 paintdownL2 The schemas right left symmetrical differ formulas components T f t They T classes L3 robotAtrx clearx L4 robotAtry cleary The schemas upLi downLi rightLi leftLi 3 4 weakly safe type The schema changeColor formula matching template start end fragments irrelevant By Corollary 98 template T f t invariant Example 18 Depotdomain Consider domain Depot Appendix B template Tdp cid9lifting2 1cid10 cid9available1 1cid10 Invariants template mean hoist possible states lifting crate available The action schemas domains durative Ad drive lift drop load unload We indicate Dα1 Dα5 respectively given Dαi variables xi yi To demonstrate Tdp invariant want apply Corollary 92 We start condition ii Ai S Bernardini et al Artiﬁcial Intelligence 258 2018 165 43 The action Dα1 drive formulas match template strongly safe The schemas respectively T classes Li liftingxi yi availablexi There fragments durative actions strongly safe unbounded α3end strongly safe balanced condition liftingx3 y3 added end effects matches delete effect liftingx3 y3 balances add effect availablex3 similar considerations hold Dα4 Reachability α3end L3 straightforward check In consequence condition ii holds However auxiliary versions α3end L3 α4end L4 α4end L4 α4end We need verify condition iii Corollary 92 Ad relevant right isolated Under rewriting ML3 L4 availablex3 availablex4 Hence ML3 L4 Eff L4 L3 α4end L4 x3 x4 y3 y4 Eff condition Deﬁnition 90 satisﬁed We conclude Tdp invariant template α3end L3 Example 19 Roversdomain Consider domain Rovers Appendix C template Tr v cid9full1 0cid10 cid9empty1 0cid10 Invariants template mean store rover possible states Since rovers stores contain object promising template To verify invariant analyse safety schema domain The schemas domain durative Ad navigate sample_soil sample_rock drop calibrate take_image communicate_soil_data communicate_rock_data communicate_image_data We indicate Dα1 Dα9 respectively given Dαi variables xi yi The actions Dα1 Dα5 Dα9 formulas match template irrelevant conse quently strongly safe We left Dα2 sample_soil Dα3 sample_rock Dα4 drop Each T class Li emptyxi fullxi 2 3 4 Note Dα2 L2 strongly safe α4st L4 weakly safe type Dα4 L4 Note conclude invariance Corollary 92 schemas strongly safe Corol relevant bounded We directly surprisingly Tr v invariant If γ lary 98 α4end instance T consider groundings gri 2 4 gri γ coherent Li Dai griDαi Now essentially case analysed Example 13 intertwining copies Da4 Da2 leads admissible individually γ safe sequence irrelevant α4end relevant bounded Dα3 L3 If modify durative action schema Dα4 adding condition Preα4inv fullx4 arguing similarly Example 13 prove Ad pairwise relevant non overlapping conclude Corollary 97 T invariant L4 L4 This example shows invariant synthesis debugging tool method improve modelling planning domains In case addition condition suﬃcient prevent erroneous physical phenomena store time 9 Guess check repair algorithm As related techniques 26274533 algorithm ﬁnding invariants implements guess check repair ap proach It starts generating set initial simple templates For template T applies results stated previous sections check invariance If T invariant algorithm outputs However algorithm manage prove invariance T discards Before rejection algorithm tries ﬁx template generating set new templates guaranteed fail reasons T In turn new templates need checked invariance conditions fail reasons 91 Guessing initial templates When create set initial templates ignore constant relations relations ground atoms truth value states example type predicates In fact trivially invariants typically interesting For modiﬁable relation r arity k generate k 1 initial templates They component zero counted variable position 0 k 1 cid9rk kcid10 counted variable cid9rk pcid10 p 0 k 1 Since templates component possible admissible partition FC C c Hence construct template T C FC 44 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Example 20 Floortiledomain Consider components c1 cid9robotAt 2 1cid10 Let FC F 1 F 1 c1 0 An initial template T1 c1 F 1 Intuitively invariants T1 mean robot occupy position time algorithm validates invariant Another initial template built considering component c2 cid9robotAt 2 0cid10 partition FC F 2 F 2 c2 1 We initial template T2 c2 F 2 Invariants tem plate mean tile occupied robot true general algorithm correctly discards Finally consider component c3 cid9robotAt 2 2cid10 partition FC F 3 F 3 c3 0 c3 1 Another initial template T3 c3 F 3 This invariant rejected If repeat process modiﬁable relation r Floortile domain obtain set initial tem plates 92 Checking conditions invariance We apply results stated previous sections check invariance template In particular apply operative results Corollaries 74 92 97 98 All results work level action schemas ground actions We ﬁrst need verify instantaneous action schemas A domain native ones obtained fragmentation durative actions respect strong safety conditions We check safety conditions involve durative action schemas strongly safe Finally validate additional conditions avoid intertwinement potentially dangerous durative actions Given different computational complexity results considerations algorithm checks applicability following order ﬁrst Corollary 74 involves conditions instantaneous schemas Corollary 98 considers safety conditions individual action schemas ﬁnally Corollaries 92 97 need verify conditions involving pairs durative action schemas To implement procedure apply decision tree shown Fig 11 set action schemas A The leaves labelled Possibly Not Invariant arise suﬃcient results apply In case assert invariance template Our checks involve analysis T classes action schema α domain Since T classes form partition set formulas schema match template maximum number T classes equal number formulas We estimate term product ω C ω maximum number formulas schema shares relation C cardinality templates component set C We deduce safety checks individual schemas instantaneous durative ones computational complexity order M A ω C M maximum number formulas appearing schema A total number schemas Consequently computational complexity Corollaries 74 98 involve safety checks The check right relevant isolated property Deﬁnition 90 needed Corollary 92 check pairwise relevant non overlapping property Deﬁnition 95 Corollary 97 instead involve schemaclass pairs possibly families matchings When condition checked involves ﬁxed matching computational complexity order M2 A2 ω2 C2 This leaves checks unreachability conditions pairs schemas iii Deﬁnition 90 Aii Bii Cii Deﬁnition 95 need verify conditions expressed Deﬁnitions 88 93 Below provide details conditions eﬃciently checked algorithmic level αiend Li Check Deﬁnition 88 The instances conditions ii involve ﬁxed matching The instances L1L2 Consider ﬁrst case 2 1 2 case condition iii condition iii instead quantiﬁed possible matchings containing M second analogous We ﬁrst check wPre αiend Li αiend Li veriﬁed If Pre li formulas li Rell1 cid14 Rell2 condition iii veriﬁed If instead Rell1 Rell2 condition iii satisﬁed Indeed case formulas match k1 1 2 note template component c cid9rk pcid10 We write li rv v 1 L1L2 l2 If instead p k l1 M l2 consider M M p Finally condition iii certainly veriﬁed Pre L1L2 j cid14 p Therefore p k variables ﬁxed component necessarily l1 M 1 2 For given schemaclass pairs check complexity M2 L1L2 v 1 0 v j M p v 2 j v 2 L1L2 We ﬁrst consider Suppose ﬁnd l1 l2 satisfy l1 M Check Deﬁnition 93 All properties deﬁnition principle involve checking condition possible L1L2 l2 Now ﬁx α k1 l rv 0 vk1 L1L j v j M matching j v j j v 1 matchings containing M α L MC If l Eff Rell Rell1 cid9rkcid10 proceed follows We write l1 rv 1 j 0 k 1 consider variables v 1 w V α v j w 1 v j M M M 1 k matching l1 M l L1L veriﬁed Now consider case veriﬁed Now M M α Rell cid14 Rell1 holds If instead l Eff j v j If exists j v 1 L1L w 1 V α1 v 1 sure v 1 j w M 0 v 1 L1L j S Bernardini et al Artiﬁcial Intelligence 258 2018 165 45 Fig 11 Decision Tree deciding invariance template T Checking condition ii analogous As far condition iii concerned note need check li property schemas involved reachable heavy For property iii hold Pre 1 2 Following argument previous item Rell1 Rell2 iii veriﬁed If instead l Rell cid14 Rell2 iii veriﬁed Rell1 cid14 Rell2 consider set Eff If Eff α1 L1 α1 L1 Otherwise We conclude given schemaclass pairs check complexity M3 A ω C N N maximum number variables formula domain αi Li The considerations allow conclude check right relevant isolated property complexity M2 A2 ω2 C2 check pairwise relevant non overlapping property complexity M3 A3 ω3 C3 N There complexities checking properties Corollaries 92 97 respectively 46 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Example 21 Floortiledomain The variables computational complexity analysis follows A 14 M 4 ω 1 C 3 N 2 93 Repairing templates In analysing action schema α reach failure node decision tree discard template T consideration prove invariance This reasons T invariant suﬃcient conditions powerful capture Before discarding template try ﬁx way obtain new templates possible prove invariance conditions In particular based schema α enlarge set components template adding suitable formulas appear preconditions negative effects α useful prove α weakly strongly safe If algorithm rejects T ﬁnds instantaneous schema heavy unbalanced ﬁrst step decision tree ﬁxes possible T Since α leads weight greater equal instance T enlarging set components T help repairing template Similarly durative schemas nonexecutable unreachable ﬁxes possible properties changed adding components However failure node reached presence unbounded schemas enlarging set components prove useful making weakly strongly safe schemas We operate follows unbounded schema α try turn balanced action schema α end fragment durative action Dα alternatively attempt Dα weakly safe schema deﬁned Deﬁnition 78 Take template T C FC rejected algorithm Let k number ﬁxed variables T let m number components Consider unbounded schema α relevant formula l We look formula l cid7 α following characteristics cid7 k 1 cid7cid10 cid7 k cid7a cid7 cid9r Rell ii There exists bijection β variables l variables l iii l Eff cid7 Pre α α cid7 Argi l Argβi l cid7 I If α end fragment durative action Dα condition iii substituted alternative following conditions iv l v l cid7 Pre αst cid7 Pre αst Eff Eff αst αend cid7 cid7k cid7 p For formula l satisﬁes conditions ii conditions iii iv v create new component cid7 0 k cid7 cid9r C admissible c partition FCcid7 c1 c2 C c1 F Ccid7 c2 j c1 F C c2 j c F Ccid7 c cid7 new template T cid7 Ccid7 F cid7 cid7 equivalently j βi C Ccid7 C c cid7cid10 p cid7 F cid7 satisﬁes condition iii schema α guaranteed balanced T cid7 formula l cid7 cid7 j Argi l Arg j l If ﬁnd formula l cid7 satisﬁes condition iv α guaranteed weakly safe type T cid7 α guaranteed weakly safe type b T cid7 ﬁnally formula l satisﬁes condition v cid7 α Example 22 Floortiledomain Consider template T2 c2 F 2 indicated Example 21 action schema α robotAtry clearx The formula robotAtry matches T2 forms T class L1 upend Preα Eff robotAtry The pure action schema αL1 unbounded end parts schemas indicate movements If apply decision tree T2 set actions A prove T2 invariant unbounded schemas weakly safe Before discarding T2 try ﬁx In particular formula cleary satisﬁes conditions ii iv If add T2 obtain new template T cid7 cid9clear 1 1cid10 cid7 F c 2 invariant Corollary 98 successfully applied schemas strongly safe weakly safe type Intuitively invariants template mean tile clear occupied robot 2 0 If apply decision tree new template prove T cid7 cid7 2 0 F c2 1 c c c2 c c F cid7 2 cid7 2 cid7 2 cid7 2 cid7 2 2 10 Experimental results To evaluate performance Temporal Invariant Synthesis referred TIS follows performed number experiments IPC benchmarks We implemented TIS algorithm reported Section 9 Python language conducted experiments Quad Core 26 GHz Intel i5 processor 4 GB memory Since paper proposes domain analysis core measure success analysis ﬁnd invariants previous methods We carry evaluation Sections 101 102 In particular Section 101 focus number quality invariants TIS In Section 102 present comparison TIS invariant synthesis planner TFD 18 terms invariants state variables synthesised based invariants The experimental results particular Fig 13 Table 6 TIS S Bernardini et al Artiﬁcial Intelligence 258 2018 165 47 Table 5 Number invariants Inv obtained Simple Invariant Synthesis SIS Temporal Invariant Synthesis TIS temporal domains IPC08 IPC11 IPC14 TIS run time RT generating invariants number invariants obtained TIS repairing failed templates Fix Domains IPC08 CrewPlanning ElevatorsNum ElevatorsStr Modeltrain OpenstacksAdl OpenstacksNum OpenstacksNumAdl OpenstacksStr Parcprinter Pegsol Sokoban Transport Woodworking IPC11 Floortile Matchcellar Parking Storage TMS TurnAndOpen IPC14 Driverlog Mapanalyser RTAM Satellite Inv SIS Inv TIS TIS RT Fix TIS 0 0 0 3 2 4 2 4 5 0 0 0 2 0 3 0 0 0 2 0 3 6 0 2 2 3 7 7 8 5 9 5 2 3 2 5 5 3 3 3 0 5 2 5 15 2 029 002 002 023 001 006 001 009 059 0002 001 001 020 005 0003 003 005 002 003 003 004 020 001 0 1 1 2 4 6 4 6 2 1 1 1 3 2 2 3 2 0 2 2 4 8 1 ﬁnds invariants related techniques turn results compact representation smaller set state variables To enrich experimental analysis test hypothesis compact encodings beneﬁt performance planners use state variables In Section 103 present experiments impact TIS results smaller set state variables performance stateoftheart planners use variablevalue representation 101 Quality representation In section discuss number quality invariants TIS eﬃciency algorithm Fig 12 shows invariants technique ﬁnds IPC temporal domains IPC02 IPC14 Each set Fig 12 corresponds set C components separated comma indicated relation arity omitted brevity positions ﬁxed variables enclosed square brackets position counted variable enclosed square brackets For example 0 1 0 1 indicates invariant components c1 cid9at2 1cid10 c2 cid9in2 1cid10 The admissible partitions shown brevity cases admissible partition trivial For comparison purposes devised variant invariant synthesis technique refer Simple Invariant Synthesis SIS SIS simplest possible extension Helmerts original technique temporal domains It fragments durative schema instantaneous schemas applies Helmerts original technique judges safe instantaneous schemas classiﬁcation irrelevant balanced We use SIS technique explore impact runtime sophisticated checks need perform sure durative actions balanced safe The second columns Table 5 compare number invariants SIS TIS temporal domains competitions IPC08 IPC11 IPC14 The fourth column reports TIS runtime RT generating invariants The numbers tell TIS computation time calculate invariants negligible signiﬁcant delay associated checks required algorithm particular complex checks involving pairs schemas While checks impact computational time allow ﬁnd comprehensive set invariants simpler technique SIS The column Table 5 Fix reports number invariants obtained repairing failed templates TIS algorithm provides indication importance repair step algorithm 102 Comparison temporal fast downward invariant synthesis Currently diﬃcult compare technique generating temporal invariants lifted domains related techniques handle non temporal domains 2027454633 work ground level rep 48 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Fig 12 Invariants temporal domains IPCs Each invariant enclosed braces relation names indicate components invariant numbers enclosed square brackets indicate positions ﬁxed variables list variables corresponding relation numbers enclosed square brackets indicate position counted variables resentation 4748 The approach appears similar invariant synthesis implemented Temporal Fast Downward TFD planner 18 refer TFDIS simply TFD tables ﬁgures This tech nique works lifted domains reﬁnes results obtained level information reachable ground atoms In section present comparison TIS TFDIS respect invariants approaches ii state variables synthesised based invariants In comparing invariants consider temporal domains IPCs comparing state variables focus domains TFDIS TIS output different invariants We start brief description TFDIS Our knowledge TFDIS based examination code5 analysis results code produces formal account technique TFDIS extension Helmerts original synthesis described Section 112 devised deal temporal numeric domains As original technique TFDIS employs guess check repair approach ﬁnd invariants The algorithm analyses temporal schemas directly splitting start end fragments Only types relevant durative action schemas evaluated safe 5 TFD04 code available http gki informatikunifreiburg tools tfd index html We socalled Safe version invariant synthesis S Bernardini et al Artiﬁcial Intelligence 258 2018 165 49 Fig 13 Examples different invariants produced TIS TFDIS taking domain IPC competition Table 6 Number invariants Inv TIS TFDIS IPC temporal domains Domains IPC02 Depots DriverLog ZenoTravel Rover Satellite IPC04 Airport Pipesworld tankage Pipesworld tankage UMTS IPC06 Openstack Pathways Storage TPP Trucks Inv TFD Inv TIS Domains Inv TFD Inv TIS 0 2 1 5 2 1 0 1 2 6 0 1 1 2 5 2 1 8 2 10 2 6 2 6 0 3 1 2 IPC08 CrewPlanning ElevatorsNum ElevatorsStr Modeltrain OpenstacksNum OpenstacksNumAdl OpenstacksStr Parcprinter Pegsol Sokoban Transport Woodworking IPC11 Floortile Matchcellar Parking TMS TurnAndOpen IPC14 Mapanalyser RTAM 2 2 3 6 8 5 9 5 1 1 2 5 3 3 3 0 5 3 11 2 2 3 7 8 5 9 5 2 3 2 5 5 3 3 0 5 5 15 classiﬁcation balanced start irrelevant end weakly safe type In cases action schemas labelled unsafe candidate invariant dismissed Fig 13 shows examples different sets invariants TFDIS TIS taking temporal domain IPC competition Table 6 shows number invariants techniques domains IPC competitions In 12 33 cases TIS outperforms TFD synthesis cases synthesis output invariants In cases difference number invariants signiﬁcant Depots TIS ﬁnds ﬁve invariants zero TFDIS Airport TIS ﬁnds invariants TFDIS We investigate different number invariants reﬂects number state variables generated based In context TIS TFDIS consider case invariants synthesise state variables referred NIS No Invariant Synthesis In case state variable truth values true false produced atom domain We use NIS baseline experiments Table 7 reports comparison IPC temporal domains TIS TFDIS produce different invariants brevity shows 50 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Table 7 Number state variables SV obtained instantiating invariants coming 1 No Invariant Synthesis NIS 2 TFD Invariant Synthesis TFD 3 Temporal Invariant Synthesis TIS We focus temporal IPC domains TIS TFD ﬁnd different invariants We consider problems domain ﬁrst intermediate instance benchmark Domains Depots p1 Depots p10 Depots p20 Rover p1 Rover p10 Rover p20 Airport p10 Airport p30 Airport p50 Pipes NoTank p10 Pipes NoTank p30 Pipes NoTank p50 Pipes Tank p10 Pipes Tank p30 Pipes Tank p50 Storage p10 Storage p20 Storage p30 SV NIS 46 198 758 35 125 480 218 7068 18071 100 527 1225 148 647 1385 98 546 1930 TFD 46 198 758 32 105 289 218 7068 18071 100 527 1225 122 590 1240 86 456 1630 TIS 14 32 67 25 77 204 172 3828 9145 98 522 1216 96 525 1151 38 136 350 Domains Pegsol p10 Pegsol p20 Pegsol p30 Modeltrain p10 Modeltrain p20 Modeltrain p30 Sokoban p10 Sokoban p20 Sokoban p30 Floortile p1 Floortile p10 Floortile p19 MapAnalyser p1 MapAnalyser p10 MapAnalyser p20 RTAM p1 RTAM p10 RTAM p20 SV NIS 67 67 67 589 588 1270 490 127 1131 64 126 186 215 752 854 1279 1498 3114 TFD 67 67 67 383 380 750 490 127 1131 40 67 97 179 677 729 341 407 677 TIS 34 34 34 191 188 390 72 37 75 16 26 36 174 670 722 311 374 614 problems domain The table shows increasing number invariants TIS gives rise compact representation NIS TFDIS In domains TIS produces signiﬁcant reduction number state variables comparison NIS TFDIS In Sokoban example reduction greater order magnitude 103 Performance temporal planners We performed number additional experiments order evaluate impact state variables generated TIS performance planners use variablevalue representation In particular focus performance planners Temporal Fast Downward TFD 18 POPFSV version POPF 12 makes use multivalued state variables6 1031 TFD temporal fast downward TFD planning temporal numeric problems based Fast Downward FD 32 limited non temporal non numeric domains TFD uses multivalued variable representation called Temporal Numeric SAS direct extension Finite Domain Representation FDR FD handle tasks TNSAS time numeric ﬂuents TNSAS captures features PDDL Level 3 represents planning tasks set state variables divided logical numeric state variables ii set axioms represent logical dependencies arithmetic subterms iii set durative actions comprise duration variable b start persistent end conditions c start end effects TFD translates PDDL21 tasks TNSAS tasks ﬁrst performs heuristic search space timestamped states contextenhanced additive heuristic 34 extended handle time numeric ﬂuents The translation PDDL21 TNSAS works steps First PDDL instance normalised types removed conditions effects simpliﬁed Then instance formulas ground produced grounding step invariant synthesis previously indicated TFDIS applied generate invariants grounding invariant synthesis performed parallel Starting invariants provided invariant synthesis ground domain set multivalued state variables generated Finally set actions obtained starting PDDL actions state variables change time In Figs 1416 compare TFD alternative versions substitute technique TIS original TFDIS substitute baseline technique NIS No Invariant Synthesis TFDIS We focus IPC domains TFDIS TIS produce different invariants Table 6 The search time ST seconds following conventions IPCs timeout set 1800 seconds Problems plan timeout techniques appear table In cases lower number state variables produced TIS speeds TFD planner example mains Modeltrain Sokoban Storage problems gain high example Storagep12p14p15 Sokobanp03p05p07p16 In domains Rover Mapanalyser Floortile TFD manages solve 6 This version POPF available authors Andrew Amanda Coles S Bernardini et al Artiﬁcial Intelligence 258 2018 165 51 Fig 14 Search time ST seconds planner TFD IPC temporal domains Three versions invariant synthesis 1 No Invariant Synthesis NIS 2 original TFD synthesis 3 Temporal Invariant Synthesis TIS We focus domains TIS TFD synthesis produce different invariants The timeout 1800 seconds Problems techniques ﬁnd plan timeout appear tables problems fast impact number state variables negligible There cases results mixed example Depots versions Pipesworld tankage tank age The reduction number variables constitutes advantage planner exam ple Depotsp16 PipesworldNoTankagep13p20p25 p30p31p35p37 PipesworldTankagep09p29p30 times detrimental search Depotsp21 PipesworldNoTankagep27p28p39 PipesworldTank agep36p37p39p45p49 It noted Depots PipesworldNoTankage TFDIS ﬁnd invari ants effectively comparing binary encoding based NIS multivalue state variables encoding based TIS It interesting PipesworldTankage instances example p36 p39 p49 binary encoding performs best In terms problem coverage techniques perform similarly In cases ﬁnding invariants helps solving diﬃcult problems example PipesworldNoTankagep25 p35p37 Storagep15 Sokobanp07 However cases opposite true example PipesworldNoTankagep39 PipesworldTankagep36 p37 p45 p49 Note problems binary representation works best PipesworldTank agep39 p49 The intuition inﬂuence number state variables planning performance comes observation TFD uses graph structures computation heuristic estimates complexity strongly inﬂuenced number Our results indicate intuition probably correct details heuristic computation need considered connection number state variables graphs structure analysed greater depth The experiments TIS potential speed search improve coverage planners research needed understand compact representation exploited potential domains problems For example interesting analyse performance TFD different subsets invariants generate state variables We perform experiments analysis scope work 52 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Fig 15 Search time ST seconds planner TFD IPC temporal domains Three versions invariant synthesis 1 No Invariant Synthesis NIS 2 original TFD synthesis 3 Temporal Invariant Synthesis TIS We focus domains TIS TFD synthesis produce different invariants The timeout 1800 seconds Problems techniques ﬁnd plan timeout appear tables 1032 POPFSV forwardchaining partialorder planner state variables POPFSV version forwardchaining temporal planner POPF 12 reads variablevalue representation domain uses performing inference step preprocessing phase reducing size states search In particular POPFSV reads standard PDDL task corresponding TNSAS translation This translation TFD invariant synthesis POPFSV TFDIS described previous version domain section However unlike TFD POPFSV reasons original PDDL domain TNSAS The multivalued state variable representation task heuristic computation employed different purposes An inference step based state variables performed support temporal preferences This step extracts rules search example possible action 10 time units action b The second use invariant analysis aims state representation eﬃcient Only value multivalued state variable needs stored state true necessarily false This property results massive savings memory This particularly beneﬁcial POPF memory generally causes planner fail time In Figs 1719 compare POPFSV alternative versions replace original TFDIS POPFSV technique TIS replace TFDIS NIS use baseline experiments We focus IPC domains TFDIS TIS produce different invariants Table 6 The search time ST seconds following conventions IPCs timeout set 1800 seconds Problems plan timeout techniques appear table The tables clearly POPFSV dealing fewer state variables beneﬁcial algorithm domains In domains challenging planner Depots PipesworldTankage PipesworldNoTankage Sokoban Floortile gain signiﬁcant These results line intuition larger set invariants help obtain compact representations turn positive impact planners performance The versions work similarly terms coverage 104 Beyond IPC The generality approach synthesising invariants lifted temporal domains fully appreciated considering IPC domains This durative actions domains present uniform structure actions balanced weakly safe type However domains practical applications types actions For example data processing web services composition production software S Bernardini et al Artiﬁcial Intelligence 258 2018 165 53 Fig 16 Search time ST seconds planner TFD IPC temporal domains Three versions invariant synthesis 1 No Invariant Synthesis NIS 2 original TFD synthesis 3 Temporal Invariant Synthesis TIS We focus domains TIS TFD synthesis produce different invariants The timeout 1800 seconds Problems techniques ﬁnd plan timeout appear tables domains 2294030 creation new objects set required Typically actions create new objects bounded weakly safe type c TFDIS fails identify invariants situations regards actions unsafe As example consider following case Example 23 DataProcessingdomain Consider domain DataProcessing Appendix D template Tdl cid9at2 1cid10 Assuming ﬁle unique identiﬁcation ﬁle invariant template ﬁle location point time The action schemas domains durative Ad create remove compress uncompress We indicate Dα1 Dα5 respectively given Dαi variables xi yi 54 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Fig 17 Search time ST seconds planner POPFSV IPC temporal domains Three versions invariant synthesis 1 No Invariant Synthesis NIS 2 original POPFSV synthesis TFDIS 3 Temporal Invariant Synthesis TIS We focus domains TIS TFDIS produce different invariants The timeout 1800 seconds Problems techniques ﬁnd plan timeout appear tables cid7 For 2 5 Dαi equivalence class Li atxi yi atxi zi Instead 1 3 4 Dαi equiva cid7 w We set AdCTdl1 Dαi Li 2 5 AdCTdl2 lence classes Li yi atxi yi atxi zi L atx cid7 1 3 4 We note Dα L AdCTdl1 DαL Dαi Li 1 3 4 AdCTdl3 Dαi L weakly safe type b Dα L AdCTdl2 DαL weakly safe type c Moreover Dα L AdCTdl3 DαL irrelevant In particular AdCwk Tdl AdCTdl1 AdCTdl2 We want use Corollary 97 prove invariance template Assumptions ii evident We need property iii Ad pairwise relevant nonoverlapping Deﬁnition 95 To aim ﬁx AdCT AdCwk T check properties A B C hold true We note Dαi Li Dα j L j AdCTdl1 properties Ai Bi hold true Indeed idlexi x j Preαi st MLi L j Eff α j st αi st α j st αi inv α j st MLi L j mutex Instead Eff α j st idlexi x j Preαi inv MLi L j Dαi Li Dα j L j AdCTdl2 properties Aiii Biii hold true Indeed atxi x j y j Preαi inv MLi L j Eff α j end Eff α j end αi inv α j end αi end α j end MLi L j mutex We consider atxi x j y j Preαi end MLi L j Dαi Li AdCTdl1 Dα j L j AdCTdl2 We atxi x j yi Pre α j st αi st α j st αi st non MLi L j executable This yields property Ai We prove property Bii pair To end note ACT Ast CTdl3 AendCTdl3 property Deﬁnition 93 holds true αi st α j st Indeed irr irr L Eff α atxi x j yi M atxi x j yi cid8 irr Li L junreachable Finally following Eff analogous argument α j inv αi st non MLi L j executable property Bi holds pair Dα j L j Dαi Li Finally properties C trivially veriﬁed ACT α j st hand α L ACT α matching M MLi L This tells αi st α j st ACT MLi L j MLi L j αi st Pre Pre rel S Bernardini et al Artiﬁcial Intelligence 258 2018 165 55 Fig 18 Search time ST seconds planner POPFSV IPC temporal domains Three versions invariant synthesis 1 No Invariant Synthesis NIS 2 original POPFSV synthesis TFDIS 3 Temporal Invariant Synthesis TIS We focus domains TIS TFDIS produce different invariants The timeout 1800 seconds Problems techniques ﬁnd plan timeout appear tables TFDIS reason weakly safe actions type b c consequence produce invari ant Tdl The FD invariant synthesis similar behaviour corresponding sequential domain 11 Related work Several approaches invariant synthesis available literature In follows present approaches depth highlighting similarities differences technique 111 Previous work synthesising temporal invariants The invariant synthesis presented Bernardini Smith 6 represents preliminary version technique described paper Bernardini Smith 6 lacks rigorous presentation theoretical framework synthesis invariants In addition algorithm capture cases unsafe intertwinements durative actions happen results generation unsafe invariants violated circumstances For example domain ZenoTravel IPC02 algorithm classiﬁes Tzt cid9fuellevel2 1cid10 invariant However shown Tzt invariant schema refuel weakly safe type b rise dangerous intertwinements invalidate invariant conditions 112 Fast downward temporal fast downward Helmert 33 presents translation subset PDDL22 FDR Finite Domain Representation multivalued planning task formalism planner Fast Downward 32 The translation handles nontemporal 56 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 Fig 19 Search time ST seconds planner POPFSV IPC temporal domains Three versions invariant synthesis 1 No Invariant Synthesis NIS 2 original POPFSV synthesis TFDIS 3 Temporal Invariant Synthesis TIS We focus domains TIS TFDIS produce different invariants The timeout 1800 seconds Problems techniques ﬁnd plan timeout appear tables nonnumeric PDDL22 domains socalled PDDL Level 1 equivalent STRIPS 19 extensions known ADL 43 One steps translation identiﬁcation mutual exclusion invariants extension technique presented Edelkamp Helmert 15 developed STRIPS When considering sequential domains invariant synthesis presented paper works similarly Helmerts tech nique In particular work lifted level related techniques discussed work ground level Both techniques start simple invariant candidates check conditions ensure invariance analysing structure action schemas domain When candidate rejected try reﬁne create new stronger candidate checked scratch However contrast technique Helmerts method considers schema safe weight transitions zero Potentially safe transitions zero ignored This simpliﬁed analysis results identiﬁcation smaller set invariants compared technique For example Helmerts invariant synthesis labels unsafe action schemas add relevant formula deleting formula relevant preconditions impose weight zero action schema applied In way Helmerts invariant synthesis misses invariants technique able ﬁnd Example 23 Chen et al 10 builds Helmerts invariant synthesis multivalued domain formulation synthesise long distance mutual exclusions londex capture constraints actions facts time step multiple steps The londex successfully SATbased planners improve performance It worth considering concept londex extended temporal domains Within context Temporal Fast Downward TFD 18 simple extension Helmerts invariant synthesis deal temporal numeric domains ICPs See Section 102 description technique 113 Rintanens invariant synthesis An algorithm inferring invariants propositional STRIPS domains proposed Rintanen 4546 It synthesises mutualexclusion invariants types invariants The algorithm works ground representation domain starting inductive deﬁnition invariants formulae true initial state S Bernardini et al Artiﬁcial Intelligence 258 2018 165 57 preserved application action algorithm based iterative computation ﬁxpoint useful reasoning invariants domain time inferring invariants ﬁrst inferring Rintanens algorithm uses guess check repair approach unlike technique starts stronger invariant candidates progressively weakens preserved actions Thus repair phase starts considering general invariant instead general For example let consider schema σ x cid14 y P x y Q y z potential invariant invariants considered implicative form One weakening operation consists identifying variables In case z set equal x weaker candidate σ x cid14 y P x y Q y x obtained checked This technique successfully Graphplan based planners 8 helps identify unreach able subgoals SATbased planners 39 useful reduce search required However implementation limited invariants involving formulas incurs high performance penalty large instances Rintanen 47 extends original algorithm presented Rintanen 4546 order handle temporal domains As original algorithm temporal works ground domains lifted representation stage The format invariants l1 V r l2 l1 l2 positive negative ground facts r ﬂoating point number formula says l1 true l2 true interval 0r relative current time point If r inf formula means l1 false l2 remain true forever Since Rintanens invariant synthesis exploits initial conditions ground representation domain usually ﬁnds broader range invariants technique However makes invariant synthesis computationally costly Reachability analysis ground representation planning instances computationally expensive algorithm takes seconds run Rintanens synthesis requires tens minutes ﬁnd invariants domains Table 1 Rintanen 47 In recent work Rintanen 48 proposed hybrid algorithm performs basic invariance tests ground method grounds actions formulas respect smaller number objects order reduce complexity We directly compare technique Rintanens algorithm Section 10 techniques aim ﬁnd different types invariants focuses mutual exclusion invariants Rintanens tackles broad range invariant types work different representations problem lifted versus ground However follows examples output Rintanens technique completeness Consider Crewplanning domain IPC08 IPC11 For crew member ci Rintanens algorithm ﬁnds ground invariants type current_day ci d j V inf current_day ci dk means day d j crew member ci day dk time If k days results k2 invariants crew member All invariants correspond single lifted invariant current_day 0 1 invariant synthesis For domain Rintanens algorithm ﬁnds additional invariants express temporal relations atoms Our technique aim ﬁnd type invariant For example Rintanens method ﬁnds temporal invariants form done_sleep ci dk V 255 done_meal ci dk2 means crew member ci atom done_meal day k 1 true 255 time units atom done_sleep true day k In fact day k done_sleep true end effects action sleep From time point order done_meal true day k 1 actions need executed post_sleep duration 195 have_meal duration 60 total time separation 255 time units For Crewplanning domain run time algorithm 029 seconds Rintanens algorithm runtime 1 minute 2324 seconds hard instances This actually best run times problems Parcprinter Elevators Sokoban Transportnumeric algorithm run time 4 hours Given run times plausible use Rintanens algorithm preprocessing step improve search planning important uses invariant synthesis algorithms 114 DISCOPLAN DISCOPLAN DIScovering State COnstraints PLANning 26 technique generating invariants nontemporal PDDL Level 1 tasks DISCOPLAN supports conditional effects compiling DISCOPLAN discovers mutual exclusion invariants types invariants static predicates simple implicative strict single valuedness nvaluedness antisimmetry OR XOR invariants For mutual exclusion invariants DISCOPLAN uses guess check repair approach similar approach hypo thetical invariant generated simultaneously analysing preconditions effects action instantiation literal deleted instantiation literal added Then candidate checked actions initial conditions If hypothetical invariant valid unsafe actions collected set possible reﬁnements generated However technique 58 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 tries reﬁne candidate soon unsafe action DISCOPLAN tries address unsafe causes time generating reﬁnements This approach leads informed choices reﬁne hypothetical invariants result identiﬁcation invariants However expensive computational point view DISCOPLAN ineﬃcient big instances DISCOPLAN ﬁnding invariants inferring actionvariable domains An actionvariable domain set includes objects instantiate variables action Such sets possible tuples variables forward propagation ground atoms initial state This technique related reachability analysis performed Graphplan 8 implement mutual exclusion calculation DISCOPLAN usually combination SAT encodings planning problems In particular preprocessing step performed domain consideration order ﬁnd invariants variable domains domain invariants variable domains translated SAT Finally SATbased planner solve resulting translated domain SATbased planners 3937 signiﬁcant speedup invariants actionvariable domains 115 Type inference module TIM Type Inference Module 20 uses different approach ﬁnding invariants nontemporal PDDL Level 1 domains More precisely TIM prepreprocessing technique inferring object types basis actions initial state Data obtained computation inferring invariants TIM recognises kinds invariants 1 Identity invariants example considering domain Blockworld objects place time 2 Unique state invariants example object place time point 3 State membership invariants example object place time point 4 Resource invariants example 3blocks world 4 surfaces Invariants types 1 2 correspond mutual exclusion invariants The invariants TIM exploited improve performance STAN planner 22 116 Knowledge representation engineering In addition works address creation invariants directly works literature highlight importance multivalued state variables debugging domain descriptions assisting domain designer building correctly encoded domains 20713 In particular Cushing et al 13 analyse wellstudied IPC temporal numeric domains reveal modelling errors affect domains This analysis lead authors suggest better ways describing temporal domains They identify direct speciﬁcation multivalued state variables key feature help domain experts write correct models Other works literature use creation invariants state variables intermediate step translation PDDL languages In particular Huang et al 37 introduce SASE novel SAT encoding scheme based SAS formalism 1 The state variables extracted invariants SASE play key role improving eﬃciency Since technique generates broader set invariants related techniques results SAS tasks smaller sets state variables We speculate positively impact SATbased planners use SASE encoding Testing hypothesis future work 12 Conclusions future work In paper present technique automatically ﬁnding mutual exclusion invariants lifted temporal planning domains expressed PDDL21 Our technique builds Helmerts invariant synthesis 33 generalises extends temporal domains Synthesising invariants temporal tasks complex tasks instantaneous actions actions occur simultaneously concurrently interfere For reason simple generalisation Helmerts approach work temporal settings In extending theory capture temporal case formulate invariance conditions account temporal structure actions possible interactions As result constructed technique signiﬁcantly comprehensive related techniques Our technique presented formally proofs offered support soundness In contrast majority related approaches technique works lifted level representation eﬃcient The experimental results run time negligible allows ﬁnd wider set invariants turn results synthesising smaller number state variables represent domain The experiments indicate temporal planners use state variables represent world beneﬁt dealing smaller number state variables S Bernardini et al Artiﬁcial Intelligence 258 2018 165 59 Our approach ﬁnding invariants incorporated translation PDDL21 language based multi valued state variables For example simpliﬁed version temporal invariant synthesis described paper translator PDDL21 NDDL 5 domain speciﬁcation language EUROPA2 planner 38 EUROPA2 core planning technology NASA space mission operations It uses language based multivalued state variables departs PDDL21 ways The use translator PDDL21 NDDL facilitated testing EUROPA2 domains IPCs originally expressed PDDL21 34 This originally motivated work temporal invariant synthesis In future work plan extend experimental evaluation incorporating invariant synthesis plan ners use multivalued variable representation currently publicly available This allow assess exhaustively impact handling fewer state variables performance temporal planners The experimental results shown paper provide evidence research needed In addition plan exploit metric information encoded planning domains ﬁnd broader range invariants Invariants domains metric ﬂuents interesting challenging We envisage kinds situations considered shown linear combination ﬂuents invariant relevant domains linear effects variables metric ﬂuents interact propositional ﬂuents complex way For example think domain encoding act juggling number balls air plus number hands constant balls hand encoded propositionally example literal holding_left air encoded count Finding invariant case challenging problem crosses propositional metric ﬂuent spaces Finally shown Example 19 technique valuable tool debugging temporal planning domains We intend work direction incorporating technique validation tools VAL 36 Acknowledgements We thank Malte Helmert Gabriele Röger Jussi Rintanen making code synthesising invariants available William Cushing helpful discussions conﬁgurations temporal actions Maria Fox Derek Long insightful discussions semantics PDDL21 We thank anonymous reviewers detailed rigorous reviews They greatly contributed improving paper This work supported EPSRC grant EPJ0121571 Royal Holloway University London Kings College London Politecnico di Torino NASA Ames Research Center All research data included paper Appendix A PDDL21 speciﬁcation Floortile domain d e f n e domain f l o o r t l e requirements typing durative actions types robot t l e c o l o r o b j e c t p r e d c t e s robotAt r robot x t l e x t l e y t l e x t l e y t l e r g h t x t l e y t l e l e f t x t l e y t l e c l e r x t l e painted x t l e c c o l o r robothas r robot c c o l o r v l b l e C o l o r c c o l o r free color r robot durative action changecolor parameters r robot c c o l o r c2 c o l o r duration duration 5 c o n d t o n t s t r t l l robothas r c v l b l e C o l o r c2 robothas r c e f f e c t t s t r t t end robothas r c2 durative action paintUp parameters r robot y t l e x t l e c c o l o r duration duration 2 c o n d t o n l l t s t r t l l t s t r t robothas r c robotAt r x y x c l e r y c l e r y e f f e c t t s t r t t end painted y c 60 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 durative action paintdown parameters r robot y t l e x t l e c c o l o r duration duration 2 c o n d t o n l l t s t r t l l t s t r t robothas r c robotAt r x y x c l e r y c l e r y e f f e c t t s t r t t end painted y c durative action parameters r robot x t l e y t l e duration duration 3 c o n d t o n t s t r t l l t s t r t robotAt r x y x c l e r y e f f e c t robotAt r x t s t r t t end robotAt r y t s t r t t end c l e r x c l e r y durative action parameters r robot x t l e y t l e duration duration 1 c o n d t o n t s t r t l l t s t r t robotAt r x y x c l e r y e f f e c t t s t r t robotAt r x t end robotAt r y t s t r t t end c l e r x c l e r y durative action r g h t parameters r robot x t l e y t l e duration duration 1 c o n d t o n t s t r t l l t s t r t robotAt r x r g h t y x c l e r y e f f e c t t s t r t robotAt r x t end robotAt r y t s t r t t end c l e r x c l e r y durative action l e f t parameters r robot x t l e y t l e duration duration 1 c o n d t o n t s t r t l l t s t r t robotAt r x l e f t y x c l e r y e f f e c t t s t r t robotAt r x t end robotAt r y t s t r t t end c l e r x c l e r y Appendix B PDDL21 speciﬁcation Depot domain d e f n e domain Depot requirements typing durative actions types place l o c t b l e o b j e c t depot d s t r b u t o r place truck h o s t s u r f c e l o c t b l e p l l e t c r t e s u r f c e p r e d c t e s t x l o c t b l e y place x c r t e y s u r f c e x c r t e y truck l f t n g x h o s t y c r t e v l b l e x h o s t c l e r x s u r f c e S Bernardini et al Artiﬁcial Intelligence 258 2018 165 61 durative action Drive parameters x truck y place z place duration duration 10 c o n d t o n t s t r t e f f e c t t x y t x y t s t r t t end t x z durative action L f t parameters x h o s t y c r t e z s u r f c e p place duration duration 1 c o n d t o n l l t s t r t t s t r t v l b l e x y z t s t r t t s t r t t x p t y p c l e r y t y p c l e r y t s t r t c l e r z t s t r t t s t r t e f f e c t t s t r t t s t r t t s t r t l f t n g x y v l b l e x y z durative action Drop parameters x h o s t y c r t e z s u r f c e p place duration duration 1 c o n d t o n l l l l t x p c l e r z l l l l t z p l f t n g x y e f f e c t t end v l b l e x t end t y p t end c l e r y t end y z t end c l e r z t end l f t n g x y durative action Load parameters x h o s t y c r t e z truck p place duration duration 3 c o n d t o n l l l l t x p l f t n g x y t end l f t n g x y t end v l b l e x l l e f f e c t t z p t end y z durative action Unload parameters x h o s t y c r t e z truck p place duration duration 4 c o n d t o n l l t s t r t t x p v l b l e x t s t r t l l t z p y z e f f e c t t s t r t t s t r t y z l f t n g x y t s t r t v l b l e x Appendix C PDDL21 speciﬁcation Rovers domain d e f n e domain Rover requirements typing durative actions types rover waypoint s t o r e camera mode lander o b j e c t v e p r e d c t e s t x rover y waypoint t _ l n d e r x lander y waypoint c n _ t r v e r s e r rover x waypoint y waypoint e q u p p e d _ f o r _ s o l _ n l y s s r rover e q u p p e d _ f o r _ r o c k _ n l y s s r rover equipped_for_imaging r rover s s t o r e h v e _ r o c k _ n l y s s r rover w waypoint h v e _ s o l _ n l y s s r rover w waypoint f u l l s s t o r e c l b r t e d c camera r rover supports c camera m mode v l b l e r rover v s b l e w waypoint p waypoint have_image r rover o o b j e c t v e m mode communicated_soil_data w waypoint communicated_rock_data w waypoint communicated_image_data o o b j e c t v e m mode t _ s o l _ s m p l e w waypoint at_rock_sample w waypoint v s b l e _ f r o m o o b j e c t v e w waypoint s t o r e _ o f s s t o r e r rover 62 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 c l b r t o n _ t r g e t camera o o b j e c t v e on_board camera r rover channel_free l lander durative action navigate parameters x rover y waypoint z waypoint duration duration 5 c o n d t o n l l t s t r t c n _ t r v e r s e x y z t x y t x y e f f e c t t s t r t l l t s t r t v l b l e x v s b l e y z t end t x z durative action sampl e_ soil parameters x rover s s t o r e p waypoint duration duration 10 c o n d t o n l l t s t r t t s t r t t s t r t t x p t _ s o l _ s m p l e p e q u p p e d _ f o r _ s o l _ n l y s s x s t o r e _ o f s x t s t r t t s t r t t x p s e f f e c t t s t r t s t end f u l l s t end h v e _ s o l _ n l y s s x p t end t _ s o l _ s m p l e p durative action sample_rock parameters x rover s s t o r e p waypoint duration duration 8 c o n d t o n l l t s t r t t s t r t t s t r t t s t r t t x p at_rock_sample p e q u p p e d _ f o r _ r o c k _ n l y s s x s t o r e _ o f s x s s e f f e c t t s t r t t s t r t t end f u l l s t x p t end h v e _ r o c k _ n l y s s x p t end at_rock_sample p durative action drop parameters x rover s s t o r e duration duration 1 c o n d t o n t s t r t e f f e c t t end f u l l s s t o r e _ o f s x t s t r t t end s f u l l s durative action c l b r t e parameters r rover camera t o b j e c t v e w waypoint duration duration 5 c o n d t o n t s t r t t s t r t t s t r t equipped_for_imaging r c l b r t o n _ t r g e t t v s b l e _ f r o m t w t end c l b r t e d r t s t r t l l e f f e c t t r w on_board r durative action take_image parameters r rover p waypoint o o b j e c t v e camera m mode duration duration 7 c o n d t o n l l t s t r t l l l l l l l l c l b r t e d r on_board r equipped_for_imaging r supports m v s b l e _ f r o m o p t r p e f f e c t t end have_image r o m t end c l b r t e d r durative action communicate_soil_data parameters r rover l lander p waypoint x waypoint y waypoint duration duration 10 c o n d t o n l l t s t r t t s t r t t s t r t t r x h v e _ s o l _ n l y s s r p v s b l e x y channel_free l t _ l n d e r l y v l b l e r t s t r t l l e f f e c t t s t r t v l b l e r t s t r t channel_free l t end channel_free l t end communicated_soil_data p t end v l b l e r durative action communicate_rock_data parameters r rover l lander p waypoint x waypoint y waypoint duration duration 10 c o n d t o n l l t _ l n d e r l y t r x l l S Bernardini et al Artiﬁcial Intelligence 258 2018 165 63 t s t r t t s t r t t s t r t h v e _ r o c k _ n l y s s r p v s b l e x y channel_free l t s t r t v l b l e r e f f e c t t s t r t v l b l e r t s t r t channel_free l t end channel_free l t end communicated_rock_data p t end v l b l e r durative action communicate_image_data parameters r rover l lander o o b j e c t v e m mode x waypoint y waypoint duration duration 15 c o n d t o n l l t s t r t t s t r t t s t r t l l t r x have_image r o m v s b l e x y channel_free l t _ l n d e r l y t s t r t v l b l e r e f f e c t t s t r t v l b l e r t s t r t channel_free l t end channel_free l t end communicated_image_data o m t end v l b l e r Appendix D PDDL21 speciﬁcation DataProcessing domain d e f n e domain DataProcessing requirements typing durative actions negative preconditions types reg d r f l e constants t r s h d r p r e d c t e s d l e f f l e compressed f f l e uncompressed f f l e t f f l e d d r durative action Create parameters f f l e d d r duration duration 1 c o n d t o n t s t r t l l t end f o r l l t end d l e f f o r l l f o r l l e f f e c t x d r x d r t f x t f x x d r t end t f d t f x durative action Remove parameters f f l e d d r duration duration 1 c o n d t o n t s t r t l l d l e f t s t r t d l e f t f d e f f e c t t s t r t d l e f t end t f d t end t f t r s h t end d l e f durative action Compress parameters f s f l e f t f l e d d r duration duration 5 c o n d t o n t s t r t t s t r t l l l l t end f o r l l d l e f s t s t r t f o r l l f o r l l d l e f s t f s d x d r t f t x x d r t f t x e f f e c t t s t r t d l e f s t end d l e f t t end compressed f t x d r t f t x t end d l e f s t end t f t d durative action Uncompress parameters f s f l e f t f l e d d r duration duration 5 c o n d t o n t s t r t t s t r t l l l l t end f o r l l d l e f s t s t r t f o r l l f o r l l d l e f s t f s d x d r t f t x x d r t f t x x d r t f t x e f f e c t t s t r t d l e f s t end uncompressed f t t end d l e f s t end t f t d t end d l e f t durative action Move parameters f f l e ds d r dt d r duration duration 3 151182 Planning ECP99 1999 pp 135147 Universität Freiburg 2004 64 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 c o n d t o n t s t r t l l d l e f t s t r t d l e f t f ds e f f e c t t s t r t d l e f t end t f ds t end t f dt t end d l e f References 1 C Bäckström B Nebel Complexity results SAS planning Comput Intell 11 4 1995 625655 2 JM Barnes A Pandey D Garlan Automated planning software architecture evolution 2013 28th IEEEACM International Conference Auto mated Software Engineering ASE 2013 pp 213223 3 S Bernardini DE Smith Developing domainindependent search control EUROPA2 Proc Workshop Heuristics Domainindependent Planning Progress Ideas Limitations Challenges 17th International Conference Automated Planning Scheduling ICAPS07 2007 4 S Bernardini DE Smith Automatically generated heuristic guidance EUROPA2 Proc 9th International Symposium Artiﬁcial Intelli gence Robotics Automation Space iSAIRAS08 2008 5 S Bernardini DE Smith Translating pddl22 constraintbased variablevalue language Proc Workshop Knowledge Engineering Planning Scheduling 18th International Conference Automated Planning Scheduling ICAPS08 2008 6 S Bernardini DE Smith Automatic synthesis temporal invariants Proc Ninth Symposium Abstraction Reformulation Approxima tion SARA11 Parador Cardona Spain 2011 pp 1017 7 S Bernardini DE Smith Finding mutual exclusion invariants temporal planning domains Proc Seventh International Workshop Planning Scheduling Space IWPSS11 Darmstadt Germany 2011 8 A Blum M Furst Fast planning planning graph analysis Artif Intell 90 1997 281300 9 B Bonet H Geffner Planning heuristic search Artif Intell 129 2001 533 10 Y Chen R Huang Z Xing W Zhang Longdistance mutual exclusion planning Artif Intell 173 2 2009 365391 11 S Chien G Rabideau R Knight R Sherwood B Engelhardt D Mutz T Estlin B Smith F Fisher T Barret G Stebbins D Tran ASPEN automated planning scheduling space missions operations 6th International Conference Space Operations 2000 12 AJ Coles AI Coles M Fox D Long Forwardchaining partialorder planning Proceedings Twentieth International Conference Automated Planning Scheduling ICAPS10 2010 pp 4249 13 W Cushing D Weld S Kambhampati Mausam K Talamadupula Evaluating temporal planning domains Proc Seventeenth International Conference Automated Planning Scheduling ICAPS07 2007 pp 105112 14 MB Do S Kambhampati Planning constraint satisfaction solving planning graph compiling CSP J Artif Intell Res 132 2001 15 S Edelkamp M Helmert Exhibiting knowledge planning problems minimize state encoding length Proc Fifth European Conference 16 S Edelkamp M Helmert The model checking integrated planning MIPS AI Mag 22 3 2001 6771 17 S Edelkamp J Hoffmann PDDL22 The Language Classical Part 4th International Planning Competition Tech Rep 195 AlbertLudwigs 2006 187231 ligence AAAI98 1998 pp 905912 AAAI2000 2000 pp 761767 18 P Eyerich R Mattmüller G Röger Using contextenhanced additive heuristic temporal numeric planning Proc Nineteenth International Conference Automated Planning Scheduling ICAPS09 2009 pp 4964 19 R Fikes N Nilsson STRIPS new approach application theorem proving problem solving Artif Intell 2 34 1971 189208 20 M Fox D Long The automatic inference state invariants TIM J Artif Intell Res 9 1998 367421 21 M Fox D Long PDDL 21 extension PDDL expressing temporal planning domains J Artif Intell Res 20 2003 61124 22 M Fox D Long Eﬃcient implementation plan graph STAN J Artif Intell Res 10 2011 87115 23 J Frank A Jónsson Constraint based attribute interval planning Constraints 8 4 2003 339364 Special Issue Planning 24 S Fratini F Pecora A Cesta Unifying planning scheduling timelines componentbased perspective Arch Control Sci 18 2 2008 545 25 A Gerevini A Saetti I Serina An approach temporal planning scheduling domains predictable exogenous events J Artif Intell Res 25 26 A Gerevini L Schubert Inferring state constraints domainindependent planning Proc Fifteenth National Conference Artiﬁcial Intel 27 A Gerevini L Schubert Discovering state constraints discoplan new results Proc 17th National Conference Artiﬁcial Intelligence 28 M Ghallab H Laruelle Representation control IxTeT temporal planner Proc Second International Conference Artiﬁcial Intelligence Planning Systems AIPS94 AAAI Press 1994 pp 6167 29 N Ghosh SK Ghosh An intelligent approach security management enterprise network planner DK Pratihar LC Jain Eds Intelligent Autonomous Systems Foundations Applications SpringerVerlag 2010 pp 187214 Ch 9 30 K Golden A domain description language data processing Proceedings ICAPS03 Workshop PDDL 2003 31 P Haslum A Botea M Helmert B Bonet S Koenig Domainindependent construction pattern database heuristics costoptimal planning Proc TwentySecond National Conference Artiﬁcial Intelligence AAAI07 2007 pp 10071012 32 M Helmert The Fast Downward planning J Artif Intell Res 26 2006 191246 33 M Helmert Concise ﬁnitedomain representations PDDL planning tasks Artif Intell 3 17 2009 503535 34 M Helmert H Geffner Unifying causal graph additive heuristics Proc Eighteenth International Conference Automated Planning Scheduling ICAPS08 2008 pp 140147 35 J Hoffmann B Nebel The FF planning fast plan generation heuristic search J Artif Intell Res 14 2001 253302 36 R Howey D Long M Fox Val automatic plan validation continuous effects mixed initiative planning pddl 16th IEEE International Conference Tools Artiﬁcial Intelligence 2004 pp 294301 37 R Huang Y Chen W Zhang A novel transition based encoding scheme planning satisﬁability Proc TwentyForth National Conference Artiﬁcial Intelligence AAAI10 vol 2 AAAI Press 2010 pp 8994 38 M Iatauro EUROPA main wiki page httpgithubcomnasaeuropawiki 2017 39 H Kautz B Selman Unifying SATbased graphbased planning Proc Sixteenth International Joint Conference Artiﬁcial Intelligence IJCAI99 Morgan Kaufmann Publishers Inc 1999 pp 318325 40 Z Liu A Ranganathan A Riabov A planning approach messageoriented semantic web service composition Proceedings 22nd National Conference Artiﬁcial Intelligence Volume 2 AAAI07 AAAI Press 2007 pp 13891394 41 D McDermott The 1998 AI planning systems competition AI Mag 21 2 2000 3555 42 N Muscettola HSTS integrating planning scheduling M Zweben M Fox Eds Intelligent Scheduling Morgan Kauffmann 1994 pp 451469 S Bernardini et al Artiﬁcial Intelligence 258 2018 165 65 43 E Pednault Toward Mathematical Theory Plan Synthesis PhD thesis Stanford University Department Electrical Engineering 1986 44 S Richter M Westphal The LAMA planner guiding costbased anytime planning landmarks J Artif Intell Res 39 1 Sep 2010 127177 45 J Rintanen An iterative algorithm synthesizing invariants Proc Seventeenth National Conference Artiﬁcial Intelligence AAAI00 46 J Rintanen Regression classical nondeterministic planning Proc 18th European Conference Artiﬁcial Intelligence ECAI08 IOS 47 J Rintanen Constraintbased algorithm computing temporal invariants Proc European Conference Logic Artiﬁcial Intelligence 2000 pp 806811 Press 2008 pp 568571 JELIA14 SpringerVerlag 2014 pp 665673 17 AAAI Press 2017 pp 36443650 48 J Rintanen Schematic invariants reduction ground invariants Proceedings ThirtyFirst AAAI Conference Artiﬁcial Intelligence AAAI 49 V Vidal The YAHSP planning forward heuristic search lookahead plans analysis Proceedings 4th International Planning Com petition IPC2004 Whistler BC Canada Jun 2004 pp 5960