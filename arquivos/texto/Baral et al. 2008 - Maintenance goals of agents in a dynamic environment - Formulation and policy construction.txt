Artiﬁcial Intelligence 172 2008 14291469 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Maintenance goals agents dynamic environment Formulation policy construction Chitta Baral Thomas Eiter c Marcus Bjäreland b Mutsumi Nakamura Department Computer Science Engineering Arizona State University Tempe AZ 85287 USA b AstraZeneca RD S43183 Mölndal Sweden c Institute Information Systems Vienna University Technology A1040 Vienna Austria r t c l e n f o b s t r c t Article history Received 25 September 2005 Received revised form 3 March 2008 Accepted 18 March 2008 Available online 3 April 2008 Keywords Maintenance goals kmaintainability Agent control Computational complexity agent design Answer set programming Horn theories SAT solving Discrete event dynamic systems Selfstabilization The notion maintenance appears AI literature context agent behavior planning In paper argue earlier characterizations notion maintenance intuitive characterize maintenance behavior certain agents dynamic environment We propose different characterization maintenance distinguish earlier notions stabilizability Our notion maintenance sensitive goodnatured agent struggles adversary environment hinders unforeseeable events reach goals principle case It parameter k referring length noninterference exogenous events needed maintain goal refer notion kmaintainability We demonstrate notion examples address important nontrivial issue eﬃcient construction maintainability control functions We present algorithm polynomial time constructs kmaintainable control function exists tells control possible Our algorithm based SAT Solving employs suitable formulation existence kmaintainable control fragment SAT tractable For small k bounded constant algorithm linear time We logic programming implementation algorithm use standard procedural algorithm analyze complexity constructing kmaintainable controls different assumptions k 1 states described variables On hand work provides new concepts algorithms maintenance dynamic environment hand fruitful application computational logic tools We compare work earlier works control synthesis temporal logic speciﬁcation relate work Dijkstras notion selfstabilization related notions distributed computing 2008 Elsevier BV All rights reserved A preliminary version formulation entitled A formal characterization maintenance goals presented AAAI00 preliminary version algorithm entitled A polynomial time algorithm constructing kmaintainable policies presented ICAPS04 The current version revises combines additional elaborations examples results proofs The major algorithms Chitta Baral visiting Vienna University Technology 2003 Marcus Bjäreland carried major work Department Computer Information Science Linkoping University Corresponding author Email addresses chittaasuedu C Baral eiterkrtuwienacat T Eiter marcusbjarelandastrazenecacom M Bjäreland mutsumiasuedu M Nakamura 00043702 matter 2008 Elsevier BV All rights reserved doi101016jartint200803005 1430 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1 Introduction motivation For agent situated static environment goal reach states certain conditions satisﬁed Such goal usually expressed formula propositional ﬁrstorder logic Sometimes goal requires constraining path taken reach states In case goal expressed formula temporal logic 3754 Our concern paper agents dynamic environment In case things complex state world change actions agent environment The agents goal dynamic environment achieving desired state agent successfully acted reach desired state environment change state In case common goal agent maintain achieve certain conditions The goal maintaining certain conditions set states satisfy conditions referred maintenance goals Maintenance goals wellknown AI literature 327415567 counterparts areas stability theory discrete event dynamic systems 5658616266 active databases 1751 However argue paper earlier characterizations maintenance goals adequate circumstances To wrong earlier deﬁnition maintenance goals suppose agents goal maintain ﬂuent f proposition f true A straightforward attempt1 express temporal operators formula cid2 f cid2 temporal operator Always cid2 f means f true future states world This strong condition maintaining inherently means things shape maintained shape A better temporal logic representation goal formula cid2cid3 f cid3 temporal operator Eventually Intuitively formula cid2cid3 f satisﬁed inﬁnite trajectory states form s0 s1 s2 stage cid2 0 exists stage j cid2 f true s j An agents control said satisfy cid2cid3 f trajectories characterize evolution world environment agents control satisfy cid2cid3 f At ﬁrst glance formula cid2cid3 f express goal maintaining f encodes f f alse state trajectory true later state We consider cid2cid3 f strong speciﬁcationin situationsto express intuitive notion main taining f reﬁned view nasty environment play illustrate examples Suppose f denotes condition Inbox customer service department Here environment makes f false adding new requests Inbox agent tries f true process ing messages Inbox removing If agent diligent processing message Inbox makes chance agent gets like agent maintains Inbox But control satisfy formula cid2cid3 f circumstances trajectories agent overwhelmed environment ﬂooding Inbox f true Another example support intuition maintainability notion maintaining consistency database 175168 When direct updates database maintaining consistency database entails triggering additional updates bring additional changes database ﬁnal state triggering database reaches consistent state This mean database reach consistency continuous updates given chance recover In fact continuous update requests similar denial service attacks In case fault triggers saying maintain consistency database They It need given window opportunity respite continuous harassment environment bring additional changes necessary restore database consistency The holds maintaining room clean fault cleaning person continually sent away room continuously Another example mobile robot 1547 asked maintain state obstacles Here belligerent adversary keeps putting obstacle robot way robot reach state obstacle But satisﬁed robot avoids obstacles continually harassed Of course robot path adversary absence path acceptable takes available path maintains states obstacles The inadequacy expression cid2cid3 f deﬁned trajectories distinguish transitions agent actions environment actions Thus distinguish cases expressing intuition maintaining f cid2cid3 f agent best maintain f thwarted environment f true k steps interference environment steps ii agent try 1 All paper consider evaluation linear temporal formulas respect valid trajectories An alternative approach use variation branching time quantiﬁer A operator Aπ 9 linear temporal formulas Another alternative approach referred boolean task speciﬁcation 272869 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1431 We refer kmaintainability paper The expression cid2cid3 f express idea window opportunity window noninterference agent perform actions necessary maintaining In fact standard notions temporal logics 2048 deﬁned trajectories distinguish cause transitions agents actions environment2 express idea kmaintainability The main contributions paper summarized follows 1 We introduce formally deﬁne notion kmaintainability distinguish earlier notions maintain ability particular speciﬁcation cid2cid3 f similar notion stabilizability discrete event dynamic systems 2 We provide polynomial time algorithms construct kmaintainable control policies exists In rest paper refer control policy simply control Our algorithm based SAT Solving employs suitable formulation existence kmaintainable control tractable fragment SAT We logic programming implementation method ﬁnally distill standard procedural algorithm We brieﬂy discuss earlier approaches controller synthesis 11019414960 respect temporal logic speciﬁcations compare complexity algorithms 3 We analyze computational complexity constructing kmaintainable controls different settings en vironment windows opportunity open agent different forms representation We problem complete PTIME standard setting possible states enumerated complete EXPTIME STRIPSstyle setting states given value assignments ﬂuents Furthermore elucidate impact different factors proofs hardness results problem complexity inherent certain restricted cases Overall work provides new concepts algorithms realizing maintenance agent dynamic environment illustrates fruitful application computational logic tools The rest paper organized follows In Section 2 present background deﬁnitions agent environment deﬁne notions stability stabilizability In Section 3 example buffers We use example illustrating concepts stabilizability kmaintainability formally deﬁned Section 4 In Section 5 present algorithms constructing kmaintaining controls based SAT Solving genuine algorithm extracted In Section 6 present encoding computing control function logic programming engine devote Section 7 complexity analysis Finally Section 8 present experimental results discuss related work outline future directions 2 Background Systems goals control stability stabilizability In paper concerned goaldirected agents dynamic world Such agents perform actions change state world Because dynamic nature world certain changes happen state world control agent The agents job world evolve way coherent goal assigned As agent control adopt agent follows Markovian control policy job control function set states set actions detailed follows Deﬁnition 1 System A quadruple A S A Φ poss S ﬁnite set states A ﬁnite set actions union set agents actions Aag set environmental actions Aenv S Φ S A 2 actions poss S 2 A nondeterministic transition function speciﬁes state world changes response function describes actions possible states The notion discrete event dynamic systems community instance 5658616266 In practice functions Φ poss required effectively eﬃciently computable speciﬁed representation language 323463 The possibility action different meaning depending agents action environmental action In case agents action dictated policy followed agent For environmental actions encodes possibilities accounted model We tacitly assume possible actions lead successor state axiom Φs cid4 posss holds state s action satisﬁed 2 If distinguishes cause transitions temporal logic express maintainability We discuss Sec tion 41 1432 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 Fig 1 S b c d f g h A cid7 e Aag cid7 Aenv e Φ shown An example A S A Φ poss S b c d f g h A shown Fig 1 s leaving s Notice example Φs deterministic Φs singleton nonempty The evolution world respect characterized following deﬁnition cid7 Φs iff arc s s cid7 cid7 e transition function Φ labeled present posss actions label arcs Deﬁnition 2 Trajectory Given A S A Φ poss alternating inﬁnite sequence states actions s0 a1 s1 a2 sk ak1 sk1 said trajectory consistent A sk1 Φsk ak1 ak1 posssk The notion trajectory require agent actions environment actions interleaved formulations games It allows agent action followed multiple environment actions viceversa real worlds arbiter enforce alternation agent environment actions The notion assumes time points ﬁne point action occur Thus allow explicit occurrence agent environment actions time A common restriction world evolves deﬁned notion stability The following deﬁnition stability adapted 56 origin control theory discrete event dynamic systems 56586162 Deﬁnition 3 Stable state 1 Given A S A Φ poss set states E state s said stable A wrt E trajectories consistent A starting s visit E inﬁnitely A set states S stable respect E states S stable respect E We A S A Φ poss stable states S stable A respect E Although deﬁnition stability respect set states E easily adapted propositional formula ϕ evaluated states A In case E s S A s cid8 ϕ A s cid8 ϕ denotes s A satisﬁes propositional logic sense ϕ Thus E set states s ϕ satisﬁed An alternative approach characterize evolution states temporal operators Some important temporal operators talking future cf 3048 Next cid9 Always cid2 Eventually cid3 Until U Their meaning respect trajectory τ s0 a1 s1 sk ak1 sk1 deﬁned follows Let τ j j cid2 0 denote remainder τ starting s j τ j cid8 p iff p true s j proposition p τ j cid8 cid9φ iff τ j 1 cid8 φ τ j cid8 cid2φ iff τ k cid8 φ k cid2 j τ j cid8 cid3φ iff τ k cid8 φ k cid2 j τ j cid8 φ1 U φ2 iff exists k cid2 j τ k cid8 φ2 j cid3 k τ cid8 φ1 The standard Boolean connectives deﬁned usual An alternative deﬁnition stability given follows Deﬁnition 4 Stable state 2 Given A S A Φ poss objective formula ϕ temporal oper ators let Eφ s S A s cid8 φ A state s said stable A wrt E trajectories τ form τ s0 a1 s1 sk ak1 sk1 s0 s consistent A holds τ 0 cid8 cid2cid3ϕ In fact deﬁnition equivalent Deﬁnition 3 The advantage temporal operators deﬁnition instead Deﬁnition 3 allows specify larger class goals build notion stability For example notion similar stability referred response property 48 form cid2p cid3q C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1433 21 Stabilizability The notion stability deﬁned respect evolution world consistent When focus agent ability stable need notion stabilizability intuitively means exists control policy agent use fashion stable Given A S A Φ poss discussing stabilizability need consider following additional aspects set actions Aag agent capable executing principle Aag A set exogenous actions occur state s agents control modeled function exo S Aenv exos posss state s recall Aenv environmental actions We exo 2 exogenous function Intuitively given A S A Φ poss Aag exo E state s stabilizable respect E able ﬁnd policy control function makes resulting stable agent starting s following policy reach state actions possible The condition referred aliveness It formally deﬁned following deﬁnitions ﬁrst deﬁnes set R A s states reached s A Deﬁnition 5 Closure Given A S A Φ poss state s R A s S smallest set states satisfying following conditions 1 s R A s 2 If s cid7 R A s posss cid7 Φs cid7 R A s For set states S S closure A wrt S deﬁned ClosureS A cid2 sS R A s Example 1 In A Fig 1 R A d d h R A f f g h Closured f A d f g h This illustrated Fig 2 Note ClosureS A satisﬁes Kuratowski closure axioms 43 Closure A S ClosureS A ClosureClosureS A A ClosureS A ClosureS1 S2 A ClosureS1 A ClosureS2 A Furthermore Φs ClosureS A holds state s ClosureS A posss Deﬁnition 6 Aliveness Given A S A Φ poss state s s alive posss We A S A Φ poss alive states S alive cid7 cid4 s cid7 R A s The notion control function formally deﬁned follows Fig 2 R A d d h R A f f g h Closured f A d f g h 1434 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 Fig 3 Policy K states b c d f possb cid7 possK exob Closureb c A b c d f g h Closureb c A K exo b c d h Deﬁnition 7 Control Given A S A Φ poss set Aag A agent actions control function A wrt Aag partial function K S Aag K s posss K s deﬁned3 We ready formally deﬁne notion stabilizability Deﬁnition 8 Stabilizability Given A S A Φ poss set Aag A function exo set states E s S stabilizable respect E exists control function K S Aag A wrt Aag following properties 1 s stable respect E A K exo S A Φ possK exo state s exos cid7 2 s alive A K exo cid7 possK exos cid7 K s cid7 A set states S S stabilizable respect E control function K A wrt Aag state s S stabilizable respect E witnessed K Having provided deﬁnition shall illustrate elaborated example section intuitive control function management ﬁnite buffers Before closing section introduce later use notion nondeterministic control Deﬁnition 9 Nondeterministic control Given A S A Φ poss set Aag A agent actions partial Aag K s posss K s cid4 K s deﬁned called nondeterministic control function K S 2 A wrt Aag Informally nondeterministic control leaves agent choice execute actions It envelope multiple control functions result reﬁning K arbitrary action K s K s deﬁned cid7 notion stabilizability deﬁned similar control functions change A K exo set possK exos K s cid7 exos cid7 K s cid7 cid7 exos cid7 place possK exos The following proposition immediate Proposition 1 Given A S A Φ poss set Aag A function exo set states S S stabilizable wrt set states E S control function K A wrt Aag iff S stabilizable wrt E nondeterministic control K A s K s deﬁned wrt Aag Furthermore K reﬁnement K iff K property s K s K control function witnessing stabilizability S wrt E s deﬁned reﬁnement K K 3 Example scenario Two ﬁnite buffers In section introduce example use illustrating notion stabilizability concepts later sections paper 3 In planning literature Markov Decision Planning control function called control policy usually assumed total function 35 ModelBased Planning 18 called deterministic stateaction table nondeterministic controls introduced called nondeterministic stateaction tables 35 refers nondeterministic plans policies respectively C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1435 We imagine ﬁnite buffers b1 b2 objects added b1 uncontrollable way An agent moves objects b1 b2 processes When object processed automatically removed b2 This slight modiﬁcation ﬁnite buffer example 58 generalizes problems ftp agents maintaining clean ftp area moving submitted ﬁles directories robots moving physical objects location In framework shall Ab models scenario For simplicity assume agent control actions M12 moves object b1 b2 object exists opposite action M21 moves object b2 b1 Proc processes removes object b2 There exogenous action Ins inserts object buffer b1 The capacities b1 b2 assumed equal Let assume control goal b1 Then stabilizable objects continually inserted agent chance buffer However insertions performed certain window noninterference agent b1 This implies maintainable stabilizable We argument explicit concrete instance Ab Example 2 Buffer example We assume maximum capacity buffers b1 b2 3 The components Ab Sb Ab Φb possb follows We model state current number objects b1 b2 That state s identiﬁed pair integers cid14i jcid15 denotes number objects b1 j number objects b2 With maximum capacity 3 set states Sb consists 4 4 16 states given Sb 0 1 2 3 0 1 2 3 The set actions Ab M12 M21 Proc Ins We assume transition function Φb deterministic Φbs cid3 1 deﬁned follows write cid7 For j 0 3 let Φbs s cid4 cid7 Φb Φbs s cid3 cid14i jcid15 M12 cid3 cid14i jcid15 M21 cid3 cid14i jcid15 Proc cid4 cid3 cid14i jcid15 Ins Φb Φb Φb cid4 cid14i 1 j 1cid15 cid14i 1 j 1cid15 cid4 cid14i j 1cid15 cid14i 1 jcid15 addition subtraction modulo 3 cases Φbs The enabling function possb deﬁned cid4 cid3 M12 possb cid14i jcid15 cid4 cid3 M21 possb cid14i jcid15 cid4 cid3 cid14i jcid15 Proc possb cid4 cid3 cid14i jcid15 Ins possb iff iff cid2 1 j cid3 2 cid3 2 j cid2 1 iff j cid2 1 iff cid3 2 It easy S cid140 0cid15 objects buffers E cid140 0cid15 cid140 1cid15 cid140 2cid15 cid140 3cid15 want b1 S stabilizable wrt E exogenous action Ins interfere task bringing E For example consider control Kb deﬁned follows cid4 cid3 cid14i jcid15 cid3 cid4 cid14i jcid15 Kb Kb M12 cid2 1 j 3 Proc 0 j cid2 1 j 3 Intuitively control directs transfer objects buffer 1 2 possible possible directs processing objects buffer 2 possible In Fig 4 shows transition diagram states transitions control Kb marked M12 Proc Consider following trajectory consistent control A K exo Sb Ab Φb possb Kb exo τ cid140 0cid15 Ins cid141 0cid15 Ins cid142 0cid15 M12 cid141 1cid15 Ins cid142 1cid15 M12 cid141 2cid15 Ins cid142 2cid15 M12 cid141 3cid15 Proc It consists preﬁx cid140 0cid15 Ins M12 cycle cid141 2cid15 Proc In τ state E reached starting state cid140 0cid15 Similar trajectories control S stabilizable respect E On hand S cid140 0cid15 stabilizable wrt E objects b1 time Following Kb states Sb E execution control actions exogenous actions possible states cid7 0 1 2 0 1 2 3 want cid7 cid143 0cid15 cid143 1cid15 cid143 2cid15 cid143 3cid15 E cid7 1436 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 Fig 4 The transition diagram buffer Ab concrete instance buffer capacity 3 4 Limited interference kmaintainability As mentioned Section 1 main intuition notion maintainability maintenance possible window noninterference environment maintenance performed agent In words agent kmaintains condition c control reaction allow controlling actions interference environment k steps gets state satisﬁes c k steps Our deﬁnition maintainability following parameters A S A Φ poss ii set initial states S initially iii set desired states E want maintain iv set Aag A agent actions Aenv detailing exogenous actions exos posss v function exo S 2 vi control function K mapping relevant S Aag K s posss The step formulate control K maintains E assuming initially states S For require A K exo S A Φ possK exo possK exos K s exos restricts agent actions control K agent state s reached state S s ClosureS A K exo given window noninterference exogenous actions desired state window One importance notion closure focus possibly smaller set states states limiting possibility exponential blowupas warned 36of number control rules Now question Suppose condition maintainability satisﬁed control leading desired state exogenous action happens takes path What The answer state reach exogenous action state closure Thus left interference exogenous actions way desired state So notion maintainability control taking desired state disturbance exogenous action control puts path desired state We deﬁne notion unfolding control follows Deﬁnition 10 Unfoldks A K Let A S A Φ poss Unfoldks A K set sequences σ s0 s1 sl l cid3 k s0 s K s j deﬁned s j1 Φs j K s j lk K sl undeﬁned let s S let K control A Then j l Intuitively element Unfoldks A K sequence states length k 1 follows control K starting state s If length sequence k 1 means state sequence K undeﬁned sequence unfold Fig 5 illustrates The deﬁnition Unfoldks A K easily extended case K nondeterministic control meaning K s set actions instead single action In case overload Φ set actions cid5 deﬁne Φs aa Φs C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1437 Fig 5 Let K policy action states b c d f Unfold3b A K cid14b c d hcid15 cid14b gcid15 Unfold3c A K cid14c d hcid15 Fig 6 Let S b E h A 3maintainable policy respect states b c d We deﬁne notion kmaintainability verify correctness control Deﬁnition 11 kmaintainability Given A S A Φ poss set agents action Aag A speciﬁcation exogenous action occurrence exo control4 K A wrt Aag kmaintains S S respect E S k cid2 0 state s ClosureS A K exo sequence σ s0 s1 sl Unfoldks A K s0 s holds s0 sl E cid4 We set states S S resp A S S kmaintainable k cid2 0 respect set states E S exists control K kmaintains S wrt E K referred witnessing control function Furthermore S resp A called maintainable wrt E S resp A kmaintainable wrt E k cid2 0 In following omit explicit mention Aag S E control functions maintainability clear context Intuitively condition s0 s1 sl E cid4 means state s0 outside E state E k transitionswhere transition dictated control K world unfold s0 s1 sl s0 s In particular 0maintainability means agent exogenous action happening state E Therefore trivial control K undeﬁned state Note deﬁnition longer require aliveness If nonalive state reached unfolding unfolding stops deﬁnition kmaintainability requires goal state E reached cid7 exos e iff s f exos Example 3 Reconsider A Fig 1 Let assume Aag Suppose want 3maintainable control policy S b wrt E h Clearly control policy K b c d Indeed Closureb A K exo b c d h Unfold3b A K cid14b c d hcid15 Unfold3c A K cid14c d hcid15 Unfold3d A K cid14d hcid15 furthermore sequence contains h See Fig 6 Suppose shown Fig 7 exogenous action e c f Then kmaintainable control policy S b wrt E h exists k cid2 0 Indeed agent end deadend g If cid7 possg 3maintainable control policy K K s s b c d f addition Φg K g cid7 f h cid7 4 Note K s s ClosureS A K exo relevance For s K s arbitrary undeﬁned 1438 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 Fig 7 Let S b E h No 3maintainable policy respect exists Example 4 Buffer example contd Earlier showed Ab S cid140 0cid15 stabilizable wrt E cid140 0cid15 cid140 1cid15 cid140 2cid15 cid140 3cid15 Thus ask S maintainable wrt E The answer positive For worst case state cid143 3cid15 control cid143 0cid15 transitions executing Proc interfering occurrences exogenous actions If transitions interference control apply M12 times effect state cid140 3cid15 This implies S 6maintainable wrt E We similar argument A 9maintainable wrt cid140 0cid15 A similar argument respect control Kb Example 2 However A maintainable wrt example cid140 3cid15 Since example cid140 0cid15 cid140 3cid15 control actions As example points possible S maintainable stabilizable respect E The converse possible In words certain cases given S stabilizable respect set E maintainable This happens path state S state E involves exogenous action In case agent control exogenous actions transition state S state E However exogenous action equivalent terms effects agent actions In case stabilizable maintainable We note following monotonicity property kmaintainability easy consequence deﬁnition Proposition 2 Suppose A S A Φ poss set agents action Aag A speciﬁcation exogenous action cid7 ClosureS A K exo occurrence exo control function K kmaintains S S wrt E S Then K kmaintains set S respect set E cid7 E 41 An alternative characterization kmaintainability The characterization stability stabilizability Section 2 based imposing conditions trajectories obtained transition graph Such characterization advantage amenable developing temporal operators express general conditions In contrast deﬁnition maintainability Deﬁnition 11 based trajectories Nonetheless alternative characterization based trajectories To bridge ﬁnite trajectories relevant respect maintainability inﬁnite ones Deﬁnition 2 consider A S A Φ poss state s extension A Φs anop s anop posss posss A Informally A results adding fresh environmental action anop A adds inﬁnite loops halting states A Proposition 3 Given A S A Φ poss set agents action Aag A speciﬁcation exogenous action occurrence exo set states E set states S kmaintainable respect E k cid2 0 exists control K A wrt Aag state s S trajectory form τ s0 a1 s1 a2 j s j j1 consistent A K exo s0 s holds ai1 aik Aag aik anop cid2 0 implies si sik E cid4 Proof For direction suppose S kmaintainable wrt E witnessed control function K Let s S K exo s0 s ai1 aik Aag aik anop τ s0 a1 s1 a2 j s j j1 consistent A cid2 0 Then si ClosureS A K exo If k 0 K witnessing control si E si si1 sik E cid4 holds Consider k 0 If aik Aag implies ai1 aik Aag sequence si si1 sik belongs Unfoldksi A K Since K witnessing control function si si1 sik E cid4 Otherwise aik anop let l cid2 1 index al anop By deﬁnition A K exo K sl1 undeﬁned Hence sequence σ sl1 belongs Unfoldksl1 A K Since K control follows sl1 E Since s j sl1 j cid2 l particular sik sl1 follows si si1 sik E cid4 This proves direction C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1439 Conversely suppose K control A wrt Aag s S trajectory τ s0 a1 s1 a2 j s j K exo s0 s holds ai1 aik Aag aik anop cid2 0 implies j1 consistent A si si1 sik E cid4 We claim K witnesses kmaintainability S wrt E Towards contradiction sup K exo state s S trajectory τ pose contrary Hence follows deﬁnition A s0 a1 s1 a2 j s j j1 consistent A K exo s j s j1 s jl Unfoldks j A K l cid3 k E s j s jl K exo s0 s j cid2 0 s j ClosureS A By deﬁnition Unfoldks j A K j1 jl1 Aag jl jl1 jk anop By hypothesis E s j s jk cid4 holds Thus conclude E s jl1 s jk cid4 hold l k However deﬁnition Φs anop s jl s jl1 s jk This implies E s j s jl cid4 contradiction This proves K witnesses kmaintainability S wrt E cid2 While result shows equally developed notion kmaintainability basis trajectories rest paper shall stick setting uses closure unfolding We ﬁnd intuitive convenient designing algorithms proofs Furthermore setting requires special handling possible ﬁnite trajectories complicates matters apparent Proposition 3 This alternative characterization suggests express notion kmaintainability existing temporal logics distinction made5 states reached agents actions states reached exogenous action To distinction let assume kind states ﬂuent interfered true false Now let Stepkφ shorthand formula φ cid9φ cid9 cid9 φ cid9 cid9 cid6 cid7cid8 cid9 φ k subformula involves k consecutive cid9s Intuitively formula Stepkφ means φ true k steps Now Proposition 3 ignoring issue anop actions simplicity follows state s S trajectory form τ s0 a1 s1 a2 j s j j1 consistent A ai1 aik Aag cid2 0 implies si sik E cid4 K exo s0 s This expressed LTL φS cid2Stepkinterfered StepkφE equivalently φS cid2Stepkinterfered φE φS φE propositional formulas described states S E respectively Using formula kmaintainability written follows There exists control K A wrt Aag state s S trajectory s0 a1 s1 a2 j s j j1 consistent A cid2Stepkinterfered φE form τ K exo s0 s trajectory satisﬁes temporal formula φS To capture complete deﬁnition temporal formula needs branching time temporal operators akin A like operator Aπ 9 meaning paths following policy consideration In case speciﬁcation Aπ cid2φS cid2Stepkinterfered φE Note need cid2 Aπ φS indirectly account phrase state s S In upcoming sections discuss characterization context general control generation algorithms work arbitrary temporal speciﬁcations However use characterization kmaintainability Deﬁnition 11 matches closely algorithms necessitate deﬁning compilation eliminates exogenous actions introduces new ﬂuent interfered proving equivalence compilation 5 Polynomial time methods construct kmaintainable controls Now deﬁned notion kmaintainability step kmaintainable control constructed automated way We start historical background In program speciﬁcation synthesis literature number works 19495960 automatically synthesize programs similar control policies given temporal logic speciﬁcations Although algorithms accept richer goals allude worst case exponential nature algorithms prove complexity exponential higher None study special classes speciﬁcations lower complexity constructing control We discuss papers complexity results Section 82 5 Such distinctions compiling set agent actions speciﬁcation exogenous action occurrence set goal states set initial states automata eliminates transitions exogenous actions records presence ﬂuent interfered We discuss compilation Section 821 1440 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 There extensive use situation control rules 26 reactive control AI literature But efforts AI literature deﬁne correctness control rules 86 automatically construct correct control rules general goals 1037417 In 42 suggested control rule form condition c satisﬁed action action action leads goal state condition c satisﬁed In 8 formal meaning leads given states s satisfy c ﬁrst action minimal cost plan s goal Using deﬁnition algorithm presented 52 construct kmaintainable controls This algorithm sound complete sense generates correct controls guarantee ﬁnd control exists In 1041 algorithm construct control respect linear temporal logic goals given This algorithm based progressing linear temporal formulas The worst case complexity algorithm given double exponential respect number subformulas goal speciﬁcation f assuming ﬁxed number states Note temporal representation kmaintainability subformulas k nested operators cid9 However studies complexity speciﬁc goal speciﬁcations earlier With help authors 1041 explored algorithms 1041 respect goal algorithm given 1041 complexity exponential size k In Section 821 discuss In following overcome problems faces mentioned approaches sound complete polynomial time algorithm constructing kmaintainable control policies In fact algorithm works linear time k bounded constant adapted linear time algorithm maintainability k arbitrary ﬁnite We provide steps First consider case transition function Φ deterministic generalize case Φ nondeterministic In case present different methods illustrates discovery process gives better grasp ﬁnal algorithm We ﬁrst present encoding problem propositional theory appeal propositional SAT solvers construct control As turns encoding tractable fragment SAT specialized solvers particular Horn SAT solvers easily Finally present direct algorithm distilled previous methods The reasoning line presentation following It illustrates methodology SAT Horn SAT encodings solve problems ii encodings allow quickly implement test algorithms iii proof correctness mimics encodings iv exploit known complexity results Horn SAT determine complexity algorithm particularly establish tractability As ii use answer set solvers DLV 2945 Smodels 5365 extend Horn logic programs nonmonotonic negation These solvers allow eﬃcient computation model maximal models Horn theory exploited construct robust small controls respectively Just clariﬁcation approach going SAT encoding Horn SAT encoding procedural algorithm suggest better eﬃcient Rather shows usefulness general methodology logical speciﬁcation SAT encoding case procedural algorithm transformations Horn SAT encoding help prove polynomial nature algorithm The problem want solve refer kMaintain following input output Input An input I A S A Φ poss sets states E S S S set Aag A function exo integer k cid2 0 Output A control K S kmaintainable respect E control K control exists Otherwise output answer control exists We assume functions posss exos eﬃciently evaluated functions given graphs table 51 Deterministic transition function Φs We start case deterministic transitions Φs singleton set s notation simply write Φs s cid7 case cid7 nonempty In abuse 6 Here exclude works related MDPs known express kind goal interested insuch kmaintenance goalsusing reward functions 7 In recent years planning algorithms systems developed 131418394044 generate control rules particular classes goals C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1441 Our ﬁrst algorithm solve kMaintain based reduction propositional SAT solving Given input I kMaintain construct SAT instance satI polynomial time satI satisﬁable input I allows kmaintainable control satisfying assignments satI encode possible controls In encoding shall use state s S propositional variables s0 s1 sk Intuitively si denote path state s state E agent actions refer apath s E length The encoding satI contains following formulas 0 For s S j 0 cid3 j k s j s j1 1 For s E S s0 2 For states s s cid7 sk s k cid7 S Φa s s cid7 action exos 3 For state s S E 1 cid3 cid3 k cid7 i1 si cid10 s scid7PSs PSs s 4 For s S E cid7 S Aag posss s cid7 Φa s sk 5 For s S E s0 cid7 The intuition encoding follows The clauses 0 state apath s E length j logically apath length j 1 The clauses 1 states s S E apath length 0 s E Next 4 states starting state s S outside E apath s E length k 5 states state s outside E apath s E length 0 The clauses 3 state state s apath s E length possible E length 1 When looking agent action successor state s kmaintainable controls clauses 2 account possibility s closure If s closure apath s E length k true respect states cid7 s reachable s exogenous actions When looking nondeterministic control play role computing maximal nondeterministic controls The role clauses clear relating models satI controls kmaintain Φa s apath s Given model M satI extract desired control K deﬁning K s s outside E sk closer E s In case multiple cid7 Φs s true M possible agent action s s possible s arbitrarily picked Otherwise K s left undeﬁned In particular k 0 clauses 1 2 4 5 exist As easily seen satI satisﬁable case S E exogenous action leads outside E closure S exogenous actions contained E This means actions agent required point time obtain trivial 0control K undeﬁned states desired cid7 cid7 cid7 The result states SAT encoding works properly general Proposition 4 Let I consist A S A Φ poss Φ deterministic set Aag A sets states E S S S exogenous function exo integer k For model M satI let C M s S M cid8 sk state s C M let cid8M s denote smallest index j M cid8 s j s0 s1 s j1 f alse s j true level s wrt M Then S kmaintainable wrt E iff satI satisﬁable ii Given model M satI partial function K cid11 Aag posss Φs s s valid nondeterministic control A wrt Aag M s K cid7 M S 2 cid7 C M cid8M s Aag deﬁned C M E cid12 cid8M s cid7 iii control K reﬁnes K M model M satI kmaintains S wrt E The proof proposition easily obtained adapting proof Proposition 6 1442 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 511 Horn SAT encoding While satI constructible polynomial time I automatically infer solving kMaintain poly nomial SAT canonical NPhard problem However closer look structure clauses satI reveals instance solvable polynomial time Indeed reverse Horn theory reversing propositions obtain Horn theory Let use propositions si intuitive meaning converse meaning si Then Horn theory corresponding satI denoted satI follows 0 For s S j 0 cid3 j k s j1 s j 1 For s E S s0 2 For states s s cid7 S s cid7 Φa s action exos cid7 s k sk 3 For state s S E 1 cid3 cid3 k cid13 cid14 cid15 s cid7 i1 si scid7PSs cid7 S Aag posss s cid7 Φa s PSs s 4 For s S E sk 5 For s S E s0 Here denotes falsity We obtain result similar Proposition 4 models M satI lead kmaintainable controls construct similarly replace ii C M C M s S M cid4cid8 sk Notice C M coincides set states C M model M satI M cid8 p iff M cid4cid8 p atom p We illustrate Horn encoding respect example Example 5 Consider A S A Φ poss S b c d f g h A sition function Φ shown Fig 1 Φs s actions label arcs leaving s iff arc s s cid7 cid7 cid7 e deterministic tran labeled present posss For A cid7 exos e iff s f exos leads S b E h k 3 following Horn encoding satI From 0 From 1 From 2 From 3 b1 b0 d1 d0 g1 g0 b2 b1 d2 d1 g2 g1 b3 b2 d3 d2 g3 g2 c1 c0 f 1 f 0 h1 h0 c2 c1 f 2 f 1 h2 h1 c3 c2 f 3 f 2 h3 h2 g3 f 3 c0 f 0 b1 d0 c1 h0 d1 h0 f 1 g1 c1 f 1 b2 d1 c2 h1 d2 h1 f 2 g2 c2 f 2 b3 d2 c3 h2 d3 h2 f 3 g3 From 4 From 5 b3 b0 c0 d0 f 0 g0 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1443 Fig 8 Computing model 6 From 5 b0 c0 d0 f 0 g0 7 From 3 g1 g2 g3 8 From 6 3 b1 c1 9 From 7 2 f 3 10 From 0 9 f 2 11 From 0 10 f 1 12 From 3 8 11 b2 This theory model M g3 g2 g1 g0 f 3 f 2 f 1 f 0 b2 b1 b0 c1 c0 d0 Hence C M b c d h gives rise nondeterministic control K s undeﬁned s f g h In case single control K reﬁning K s s b c d K s s b c d K undeﬁned This intuitive The agent reach h avoid taking b arrive nogood state g Thus b choice subsequent states c d Also add state apart b c d losing 3maintainability In particular case M maximal propositions s3 s S E b c d f g By 4 add b3 0 clauses c2 f 2 b3 d1 c2 3 c3 d3 Thus control K smallest fact possible 3maintainability K cid7 As computing model Horn theory wellknown polynomial problem 25 obtain following result Theorem 5 Under deterministic state transitions problem kMaintain solvable polynomial time cid2 An interesting aspect wellknown satisﬁable Horn theory T model M T given intersection models Moreover model computable linear time cf 2550 This model leads kmaintainable control leads maximal control sense control This deﬁned greatest set states outside E possible kmaintainable controls S gives clear picture states added S kmaintainability preserved states C M T Furthermore control K computed M T applying method Proposition 4 C M T works extension S wrt E S S cid7 cid7 On hand intuitively kmaintainable control constructed maximal model satI respect propositions sk undeﬁned largest extent works merely smallest extension We generate starting M T maximal model T trying ﬂip ﬁrst step step propositions sk f alse true propositions entailed In way generate maximal model T sk s S E polynomial time lean control computed polynomial time 52 Nondeterministic transition function Φs We generalize method constructing kmaintainable controls case transitions Φ nondeterministic As ﬁrst present general propositional SAT encoding rewrite propositional Horn SAT encoding To explain notations need following deﬁnition generalizes notion apath nondeterministic setting Deﬁnition 12 apath We exists apath length k cid2 0 state s set states S s S s S length k 1 s k 0 action Aag posss s cid7 Φs exists apath S cid7 cid7 cid7 cid7 cid7 In following encoding instance I problem kMaintain SAT referred sat cid7I si intuitively denote apath s E length The proposition s_ai 0 denote s cid7I groups 05 apath s E length starting action posss The encoding sat clauses follows 1444 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 0 1 4 5 satI 2 For state s S s s cid7 cid7 Φa s action exos cid7 sk s k cid16 3 For state s S E 1 cid3 cid3 k aAagposss s_ai 31 si 32 Aag posss s cid7 i1 33 Aag posss k s_ai s cid7 Φs s_ai s_ai1 Group 2 similar group 2 satI previous subsection The change cid7 Φa s The main difference group 3 We explain clauses The clauses 31 cid7 Φa s instead s s 32 state apath s E length possible action agent state s E length 1 The clauses s_ai s_ai1 33 longer apath s agent able pick Notice formulas sat state s nondeterministic control reﬁne easily control cid7I forbid pick different actions potentially results taking s apath s cid7 cid7 cid7 Proposition 6 Let I consist A S A Φ poss set Aag A sets states E S S exogenous function exo cid7I let C M s S M cid8 sk state s C M E let cid8M s denote smallest index j integer k For model M sat M cid8 s_a j action Aag posss alevel s wrt M Then S kmaintainable wrt E iff sat ii given model M sat cid7I satisﬁable cid7I partial function K M S 2 Aag deﬁned C M E K M s M cid8 s_acid8M s valid nondeterministic control iii control K reﬁnes K M model M sat cid7I kmaintains S wrt E Proof Since direction follows ii iii suﬃcient direction ii iii As direction suppose S kmaintainable wrt E Then exists control K state s ClosureS A K exo sequence σ s0 s1 sl Unfoldks A K s0 s s0 sl E cid4 We construct interpretation M sat cid7I follows For s ClosureS A K exo sequence σ s0 s1 sl Unfoldks A K s s0 let iσ cid2 0 smallest index si E let length longest path tree root s node n E sprouted taking control action K n adding state 0 s_ai s_ai1 s_ak K s All Φn K n child Then assign true si si1 sk propositions assigned f alse M We argue M model satI maximum iσ s Intuitively cid7 k generated 2 If sk true s ClosureS A K exo construction In case s It straightforward M satisﬁes formulas generated 0 1 4 5 Now consider formulas cid7 Φa s sk s cid7 cid7 ClosureS A K exo K kmaintains S wrt E s true M cid3 k exogenous action s cid7 implies construction s k assigned true M Let ﬁnally consider formulas generated 3 If si s S E assigned true M 1 cid3 cid3 k s ClosureS A K exo holds construction M Since K kmaintaining control s E K s deﬁned construction M s_K si assigned true M Since K s Aag posss clause 31 satisﬁed Furthermore clause 32 satisﬁed cid4 K s sai true M construction cid7 Φs belongs ClosureS A Kexo Let sequence σ cid7 s0 si Since K kmaintaining control state s cid7 s1 sl Unfoldks A K s0 s sequence P σ s0 s1 si shortest preﬁx σ si E notice k Then sequence s P σ preﬁx sequence Unfolds A K Hence follows construction M number Thus construction M follows s larger s cid7 s i1 assigned true M This means formulas 32 satisﬁed M Finally clauses 33 clearly satisﬁed M construction M Thus M model sat assigned f alse M For K s proposition sai cid7I means sat cid7I satisﬁable cid7 To ii let assume sat C M E K By clause 31 deﬁnition C M cid8M K M s M cid8 s_acid8M s We K M immediate cid7I model M consider partial function K S 2 M s cid4 K M s posss K Aag deﬁned M s deﬁned M C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1445 To iii let K control reﬁnes K cid7I Let distance dK s S state s set states S proof Proposition 4 minimum number transitionsthrough exogenous actions andor control actions dictated control K needed reach s state S M model M sat We induction ds S cid2 0 state s ClosureS A K exo sequence σ s0 s1 sl s s0 Unfoldks A K set s0 sl intersects E M cid8 sk s C M This proves K kmaintains S wrt E The base case ds S 0 states s S From formulas 0 1 4 M cid8 sk state s Consider sequence σ s0 s1 sl Unfoldks A K s s0 If s E l 0 s0 sl E cid4 Otherwise M cid8 sak K s We s1 Φs construction l K clauses 32 M cid8 s kl assigned true M If k l follows clauses 5 sl E Otherwise l k K undeﬁned sl clauses 1 means sl E Hence s0 sl E cid4 1 k1 Repeating argument infer s 1 k1 s 0 k s Thus statement holds base case Now induction step let assume holds state s cid7 S ClosureS A K exo distance ds S d cid2 0 S Let consider state s ClosureS A K exo distance ds cid7 ii d 1 S Then state s cid7 K s k conclude M cid8 sk clauses 2 case construction K clauses 32 1 0 case ii respectively Furthermore similar argumentation case d 0 obtain sequence σ s0 s1 sl Unfoldks A K s s0 holds s0 sl E cid4 This concludes induction proof iii cid2 cid7 In cases induction hypothesis M cid8 s distance ds S d S s Φa s cid7 exos cid7 One advantage encoding sat cid7I encoding satI deterministic transition function Φ directly gives possibility read suitable control s_ai propositions posss true model M computed looking transition function Φs On hand encoding cid7I benign involved uses larger set propositions Nonetheless structure formulas sat computation allows compute model kmaintainable control polynomial time 521 Horn SAT encoding general case The encoding sat cid7I reversing propositions intuitive meaning si s_ai converse meaning si s_ai respectively The encoding sat cid7I like satI reverse Horn theory We rewrite sat cid7I similarly Horn theory sat cid7I follows 0 1 4 5 satI 2 For states s s cid7 S s cid7 Φa s action exos cid7 s k sk 3 For state s S E 1 cid3 cid3 k cid17 aAagposss s_ai si 31 32 Aag posss s cid7 Φs s cid7 i1 s_ai 33 Aag posss k s_ai1 s_ai We obtain Proposition 6 easily following result main result section far Theorem 7 Let I consist A S A Φ poss set Aag A sets states E S S exogenous function exo cid7I C M s M cid4cid8 sk let cid8M s min j M cid4cid8 s_a j Aag posss s S integer k Let model M sat Then S kmaintainable wrt E iff Horn SAT instance sat ii Given model M sat cid7I control K K s deﬁned iff s C M E cid12 cid11 Aag posss M cid4cid8 s_a j j cid8M s K s cid7I satisﬁable kmaintains S wrt E Corollary 8 Problem kMaintain solvable polynomial time More precisely solvable time O kcid22Icid22 cid22Icid22 denotes size input I 1446 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 cid7I measured number atoms O kS Φ Proof A straightforward analysis yields size sat poss Aag S E Φ poss exo stored standard way bitmaps multidimensional array value cid7I easily generated range 01 cid22Icid22 O S2A log k Furthermore clauses sat time bound Since model Horn theory T computable time O T T number atoms cid7I feasible O kcid22Icid22 time Furthermore C M 2550 deciding satisﬁability computing model M sat s cid8M s s S computable M linear time number atoms suitable data structures control K Theorem 7ii time Hence kmaintaining control S wrt E computable O kcid22Icid22 time Note economic representation stores S E Aag sets lists Φ poss exo graphs tables sets tuples cid14s Φs acid15 s S A cid14s possscid15 s S cid14s exoscid15 s S Also rep resentation tuples Φs resp posss exos stored cid7 Φa s cid14s acid15 posss cid14s acid15 exos O kcid22Icid22 time order storing sets tuples cid14s s bound holds Indeed arrays storing S E Aag lookup O 1 time constructible time O S A Then cid14s acid15 poss Aag storing Aag posss s constructible O poss time From clauses possag The clauses 2 32 easily sat cid7cid15 Φ posss time O Φexo O kΦposs constructed Φexo cid14s s respectively The sets Φexo Φposs generated Φ exo time O Φ exo poss auxiliary cid7I array auxA S enable random access Φa s notice auxa s needs deﬁned Φa s In total sat constructible O A exo kS Φ poss O kcid22Icid22 time cid2 cid7I 2 32 readily generated time O kS possag cid7cid15 Φ exos Φposs cid14s s cid7cid15 s Thus particular ﬁnding maintaining control small window opportunity maintenance k maintaining control k bounded constant feasible linear time size input Similar Section 511 model theory given sat cid7I Msatcid7I leads maximal control sense preimage K outside E states outside E K deﬁned greatest possible kmaintaining controls include S Furthermore smallest kmaintaining control similarly computed cid7I respect propositions sk s outside E generated Msatcid7I maximal model sat stepwise maximization Again maximal smallest controls computed polynomial time Example 6 Reconsider A S A Φ poss Example 5 Let modify transition function Φ Φc d f instead Φc d Then respective modiﬁed instance I 3Maintain denoted I1 encod ing sat cid7I1 looks follows 0 1 2 4 5 satI1 Example 5 31 b_a1 b_a b_a2 b_a b_a3 b_a cid7 b1 1 c_a1 c1 d_a1 d1 f _a1 f 1 g1 cid7 b2 2 c_a2 c2 d_a2 d2 f _a2 f 2 g2 cid7 b3 3 c_a3 c3 d_a3 d3 f _a3 f 3 g3 32 h0 d_a1 d0 c_a1 c0 b_a1 h1 d_a2 d1 c_a2 c1 b_a2 h2 d_a3 d2 c_a3 c2 b_a3 h0 f _a1 f 0 c_a1 cid7 f 0 b_a 1 h1 f _a2 f 1 c_a2 cid7 f 1 b_a 2 h2 f _a3 f 2 c_a3 cid7 f 2 b_a 3 33 d_a2 d_a1 c_a3 c_a2 d_a3 d_a2 b_a2 b_a1 f _a2 f _a1 b_a3 b_a2 f _a3 f _a2 bcid7_a2 bcid7_a1 c_a2 c_a1 bcid7_a3 bcid7_a2 It turns sat cid7I models From g3 clause g3 f 3 2 clauses 0 obtain f cid7 cid7I1 Hence clause f 2 b_a3 32 b_a 0 3 true model M sat 3 true M On hand formula f 1 c_a2 32 obtain c_a2 true M clauses c_a2 c2 b3 implies b3 true M 31 c2 b_a3 32 b_a3 true M The clause b_a3 b_a cid7I1 exist Theorem 7 However formula b3 4 b3 false M Thus model M sat means 3maintaining control S b wrt E h Indeed regardless control function K state b 2 steps b state f reached exogenous function selects nogood state g cid7 3 cid7 Suppose Φc d f agent f h cid7 possg Then Horn encoding sat cid7I1 changes follows cid7 g results h f Φg cid7 In 31 facts gi 1 2 3 replaced g_ai gi In 32 clauses cid7 f h added 1 2 3 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1447 f 0 g_a cid7 1 cid7 2 f 2 g_a cid7 3 h0 g_a cid7 1 h1 g_a cid7 2 h2 g_a cid7 3 f 1 g_a cid7 In 33 clauses g added g_a cid7 2 g_a cid7 3 cid7 2 g_a g_a cid7 1 cid7I2 modiﬁed instance I2 longer fact g3 31 derivation cid7I2 satisﬁable cid7I2 applicable In fact sat In encoding sat contradiction truth value b3 model sat model M b0 c0 d0 f 0 g0 b_a1 c_a1 b_a cid7 1 g_a cid7 1 b1 c1 g1 b_a2 Then C M b c d f g h cid8M b cid8M c cid8M g 2 cid8M d cid8M f 1 leads single 3 maintaining control K K s s b c d f K g Note K deﬁned state h 3maintains set S wrt E includes h As S b K c K d remain undeﬁned closure b easily detected price losing robustness respect en larging S There alternative solution K b instead K b Here K s undeﬁned s cid4 h cid7 cid7 53 Genuine algorithm From encoding Horn SAT distill direct algorithm construct kmaintainable control cid7I It uses counters cs cs_a exists The algorithm mimics steps SAT solver order solve sat state s S possible agent action state s range 1 0 k 0 1 k respectively Intuitively value counter cs particular step computation represents far s0 si assigned true 1 steps needed s reach E particular 1 represents si assigned true Similarly value cs_a particular step computation represents far s_a1 s_ai assigned true particular 0 s_ai assigned true 1 steps needed s reach E starting Starting initialization algorithm updates demand clauses sat cid7I counters sets proposi tions true command updc short c c ﬁxpoint If counter violation detected corresponding violation clause s0 s S E 1 sk s S E 4 control possible Otherwise control constructed counters The detailed algorithm shown Fig 9 It easily adjusted simply want output nondeterministic control reﬁnements kmaintainable control leaving choice reﬁnement user Alternatively implement Step 4 choice based preference information The following proposition states algorithm works correctly runs polynomial time Proposition 9 Algorithm kControl solves problem kMaintain terminates input I polynomial time Furthermore implemented run O kcid22Icid22 time Algorithm kControl Input Output A A S A Φ poss set Aag A agent actions sets states E S S exogenous function exo integer k cid2 0 A control K kmaintains S respect E control exists Otherwise output control exists Step 1 Initialization cid7cid15 s S exos s cid7 Φs Φ E poss cid14s s cid7cid15 s S E posss s cid7 Φs s S possags Set Φexo cid14s s Aag posss ii For s E set cs 1 iii For s S E set cs k possags set cs 0 iv For s S E possags set cs_a 0 Step 2 Repeat following steps change cs k s S E cscid20 s S E cid7 k updcs k cid7 For cid14s s ii For cid14s s cid7cid15 Φexo cs cid7cid15 Φ E poss cs 0 cid3 k updcs_a 1 elseif k updcs_a k iii For state s S E possags cid4 mincs_a possags updcs Step 3 If cs k s S E cs cid2 0 s S E output S kmaintainable wrt E halt Step 4 Output control K S E Aag deﬁned states s S E cs k K s possags cs_a minbpossag s cs_b k Fig 9 Algorithm problem kMaintain 1448 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 Proof The correctness algorithm follows Theorem 7 fact kControl mimics starting facts cid7I standard ﬁxpoint computation As polynomial time 5 31 computation model sat complexity counters increased loop Step 2 reentered counter increased latest run follows number iterations polynomially bounded Since body Step 2 step polynomial follows kControl runs polynomial time For detailed account note bitmaps S E A available input generated time poss constructed time O Φ exo O Φ poss S O S A In Step 1 sets Φexo Φ E respectively auxiliary array random access Φa s case functions given graphs cf proof Corollary 8 Constructing possags s S takes O poss time iiiv Step 1 feasible time O S poss Using ﬂags signal changes counters cs csa auxiliary counters mincs_a possags number calls upd Step 2 O kΦexo Φposs S takes O 1 time The loop condition checked O m time m number changes loop Hence total time Step 2 O kcid22Icid22 Step 3 O 1 ﬂag set Step 2 indicating reason loop exit Finally Step 4 control K easily output time O poss In total time O kcid22Icid22 cid2 Thus k bounded constant kControl implemented run linear time We remark improve ments possible For example states eliminated reachable state S control eventually constructed This eﬃciently computing upper bound ClosureS K Aexo possible actions state merged single action Similarly eﬃciently prune states reach E k steps linear time This achieved slight extension algorithm K Control ﬂags ﬁnals ﬁnals_a states s actions possags signal counters cs cs_a correspond shortest distance E Step 2 ii iii chose s_a respectively s ﬁnal ﬂag switched false true cs_a resp cs smaller k We leave discussion reﬁnements future work 54 Generic maintaining controls By results previous subsections solve problem Maintain analogous kMaintain k input arbitrarily chosen time O Scid22Icid22 time quadratic size input This follows fact kmaintainability S wrt E arbitrary ﬁnite k cid2 0 equivalent kmaintainability S wrt E k S number states However advantage property exact number steps reach E matter long ﬁnite design eﬃcient linear time algorithm proceeds phases In ﬁrst phase states s determined E reachable apath arbitrary length states pruned In second phase states iteratively pruned taken exogenous action state apath action leads pruned state We obtain genuine lineartime algorithm solving problem Maintain adapting algorithm kControl implements phases counters cs cs_a range ﬁxed domain independent k However skip discovery process straight simple algorithm shown Fig 10 We refer algorithm ωcontrol ωmaintaining control It implements phases 1 2 steps 2 3 respectively If Step 4 maintaining control exist Step 5 extracts control data structures Like kmaintainability requires care naïve extraction work particular cycles cause problems The following result proof omitted states algorithm works properly Proposition 10 Algorithm ωControl solves problem Maintain terminates input I polynomial time Furthermore implemented run time O cid22Icid22 linear time 6 Encoding kmaintainability answer set solver In section use results previous section computing kmaintainable control en coded ﬁnding answer sets nonmonotonic logic program More precisely encoding nonmonotonic logic programs Answer Set Semantics 33 executed available answer set solvers DLV 2945 Smodels 5365 These solvers support computation answer sets models given program solutions case kmaintaining controls extracted The encoding generic given ﬁxed program evaluated instance I represented input facts F I It makes use fact nonmonotonic logic programs multiple models correspond different solutions different kmaintainable controls C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1449 Algorithm ωControl Input Output A A S A Φ poss set Aag A agent actions sets states E S S exogenous function exo A control K maintains S respect E control exists Otherwise output control exists Step 1 X E Step 2 Repeat change X X X s Aag s cid7 cid7 Φs s cid7 X s Step 3 Repeat change X X X s exos s cid7 cid7 Φs s cid7 s X X X s Aag s cid7 s cid7 Φs s cid7 X Step 4 If S X cid4 output S maintainable wrt E halt Step 5 Construct control going backwards goal states following manner Initialize counters s X Aag cs_a Φs ii For state s E s nop queue Q iii While Q Pop element s x Q s E K s x transitions s cid7 cs _a cs cs cid7 s s Φs cid7 _a 1 _a 0 K s cid7 cid7 s cid7 X cid7 undeﬁned s cid7 Q Fig 10 Algorithm problem Maintain In following ﬁrst represented logic program develop logic programs deterministic general nondeterministic domains We shall follow syntax DLV changes needed adapt programs answer set solvers Smodels minor 61 Input representation The input I problem kMaintain represented facts F I follows The A S A Φ poss represented predicates state transition poss following facts states s S actiona A cid7 s s transitionsas posssa s S A posss cid7 S A s cid7 Φs set AagA agent actions represented predicate agent facts agenta Aag set states S represented predicate start facts starts s S set states E represented predicate goals facts goals s E exogenous function exo represented predicate exo facts exosa s S exos The integer k represented constant k Example 7 Coming Example 3 input I represented follows stateb statec stated statef stateg stateh actiona actiona1 actione transbac transba1f transcad transdah transfah transfeg possba possba1 possfa possfe possca possda agenta agenta1 startb goalh exofe const k3 1450 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 62 Deterministic transition function Φ The following program executable DLV engine deciding existence kcontrol In addition predicates input facts F I employs predicate n_pathXI intuitively corresponds X I auxiliary predicates Define range 01k stages range0k Rule 0 n_pathXI stateX rangeI I k n_pathXJ J I1 Rule 1 n_pathX0 goalX startX Rule 2 n_pathXk transXAY exoXA n_pathYk Rules 3 n_pathXI stateX goalX rangeI I0 some_passXIsmallskip some_passXI rangeI I0 transXAY agentA possXA n_pathYJ IJ1 Rule 4 n_pathXk startX goalX Rule 5 n_pathX0 stateX goalX The predicate rangeI speciﬁes index range 0 k given input limitk The rules encoding clause groups 02 4 5 straightforward self explanatory For 3 need encode rules bodies different size depending transition function Φ input We use antecedent cid7 PSs false assess implication 3 true falsiﬁed falsiﬁcation means atom s use auxiliary predicate some_passXI To compute nondeterministic control K add rule cid7 i1 s Define C_M cbarX stateX n_pathXk Define state level L levelXI cbarX n_pathXI I 0 n_pathXJ IJ1 levelX0 cbarX n_pathX0 Define nondeterministic control k_plus k_plusXA agentA transXAY possXA levelXI levelYJ JI goalX In cbarX compute states C M levelXI level cid8M s state s C M C M corresponding model M satI The nondeterministic control K M computed k_plusXA Finally following rules nondeterministically generate control reﬁnes K Selecting control k_plus controlXY k_plusXY exclude_k_plusXY exclude_k_plusXY k_plusXY controlXZ YZ M The ﬁrst rule enforces possible choice K s taken excluded second rule case choice In combination rules effect element K M s chosen K s C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1451 Example 8 If input representation Example 5 ﬁle exa3dlv program denoted Πdet ﬁle detdlv DLV engine invoked dlv exa3dlv detdlv N3 filtercontrol outputs controls N3 sets range integers dynamically supported engine 3 ﬁltercontrol effects answer sets clipped predicate control In particular case output apart version information controlba controlca controlda yielding unique control exists case If add agent action a2 action set extend transition function Φb a2 c DLV respective representation yield controlba2 controlca controlda controlba controlca controlda corresponding alternative controls emerge agent action action a2 state 63 Nondeterministic transition function Φ As deciding existence kmaintaining control change code deterministic case affects Step 3 The modiﬁed code follows n_apathXAI intuitively corresponds X_ A I Rules 3 different 31 n_pathXI stateX goalX rangeI I0 some_apassXI some_apassXI rangeI I0 agentA possXA n_apathXAI goalX 32 n_apathXAI agentA transXAY possXA rangeI I0 n_pathYJ IJ1 goalX 33 n_apathXAI agentA possXA rangeI I0 Ik n_apathXAJ JI1 goalX Here some_apassXAI plays encoding 31 similar role some_passXI encoding 3 deter ministic encoding To compute nondeterministic control K M add following rules Define C_M cbarX stateX n_pathXK limitK Define state action level alevel 1 alevelXI alevel_leqXI IJ1 rangeJ level_leqXJ alevel_leqXI cbarX goalX possXA agentA I0 rangeI n_apathXAI Define nondeterministic control k_plus k_plusXA agentA alevelXI possXA n_apathXAI Here value cid8M s computed alevelXI auxiliary predicate alevel_leqXI intuitively means cid8M X cid3 I M add rules selecting control k_plus program For computing controls reﬁning K deterministic case Example 9 Let revisit instance I1 Example 6 We DLV representation transcaf representation I Assuming ﬁle exa4dlv program Πndet ndetdlv I1 adding fact ﬁle dlv exa4dlv ndetdlv N3 filtercontrol 1452 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 yields output apart version print correct On hand consider input I2 variant Example 6 agent action cid7 f h output possible g Φg cid7 controlba1 controlca controlda controlfa controlga1 a1 encodes cid7 Again correct result 64 Layered use negation An important note point programs Πdet Πndet necessarily models corre cid7I respectively The reason use negation spond models Horn theories satI sat some_passXI resp some_apassXI lead cycles recursion Thus control com puted necessarily maximal maximal controls computed models Furthermore cyclic negation priori clear program deciding existence control evaluated DLV cid7I polynomial time However consistency existence answer set guaranteed satI resp sat model It possible modify Πdet use negation recursion cycles eliminated standard coding methods evaluate body rule 3 Namely introduce Πdet predicate all_true replace some_passXI code 3 all_trueXI deﬁned all_trues represents scid7 i1 PSs assigned true checked linear ordering cid3 PSs However refrain Notice case PSs size bounded constant c use predicate ps arity c 1 represent PSs s1 sl single fact pss s1 sl sl sl reduplicated l c It easy express clause 3 We similarly modify Πndet use negation recursion cycles eliminated use linear ordering Aag posss simply Aag assuming agent actions overall Finally use program Πdet simply ordering Aag deterministic transformation Φs partial surjective mapping A PSs guarantees A posss s cid7 PSs accessed Φ The modiﬁed programs use negation stratiﬁed manner evaluated DLV guaranteed polynomial time size DLV representation satI sat 65 State descriptions variables cid7I respectively In cases states described vector values parameters variable time It easy incorporate state descriptions LP encoding evaluate answer set solvers provided variables range ﬁnite domains In fact state s given unique vector s cid14s1 smcid15 m 0 values si 1 cid3 cid3 m variables Xi ranging nonempty domains represent s fact statev use vector X1Xm state variables DLV code place single variable X No change programs needed 1 v ri Similarly easily accommodate actions aP 1 P 2 Pm parameters P 1 Pm important ﬁnite set desired However rule deﬁning exclude_k_plusXY replaced rules emerging atom Y Z body replaced Yi Zi 1m assuming Y Z replaced Y1Ym Z1Zm respectively Another possibility handle state descriptions variables implement coding scheme maps vector s cid14s1 smcid15 integer represented fact codeis s1 sm Furthermore point input need consist merely facts involve rules deﬁne predicates input representation compactly Finally facts action dropped referenced rule programs Πdet Πndet For illustration consider buffer example Section 3 Example 10 Recall states buffer example given pairs integers cid14i jcid15 j numbers objects buffer b1 b2 respectively We use variables X1X2 Y1Y2 place X Y respectively For buffer capacity 3 S cid140 0cid15 E cid140 jcid15 1 cid3 j cid3 3 k 6 input represented follows stateX1X2 intX1 intX2 X1 3 X2 3 start00 goal0X2 state0X2 transX1X2m_12Y1Y2 stateX1X2 stateY1Y2 X1Y11 Y2X21 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1453 transX1X2m_21Y1Y2 stateX1X2 stateY1Y2 Y1X11 X2Y21 transXX2procXY2 stateXX2 stateXY2 X2Y21 transX1XinsY1X stateX1X stateY1X Y1X11 possX1X2m_12 stateX1X2 1 X1 X2 2 possX1X2m_21 stateX1X2 1 X2 X1 2 possX1X2proc stateX1X2 1 X2 possX1X2ins stateX1X2 X1 2 agentm_12 agentm_21 agentproc exoins const k 6 Here equalities X10 X1X2 rule deﬁning goal X1Y1 deﬁnition transXX2procXY2 pushed Invoking DLV assuming representation stored ﬁle exabufferdlv expanded version Πdet ﬁle det2dlv dlv exabufferdlv det2dlv N6 filtercontrol yields 13 models encode different controls Among maximal controls control10m_12 control11m_12 control12m_12 control13proc control20m_12 control21m_12 control22proc control23proc control30m_12 control31proc control32proc control33proc deﬁned states outside E constitutes 6maintaining control 7 Computational complexity In section consider complexity constructing kmaintainable controls assumptions To end ﬁrst problems analyzed overview complexity results After results established separate subsection reader interested technical proofs safely skip 71 Problems considered overview results Following common practice consider decision problem associated kMaintain refer kMaintainability Given A S A Φ poss set Aag A agent actions sets states E S S exogenous function exo integer k cid2 0 decide S kmaintainable respect E A Furthermore consider Maintainability input k asks S maintainable respect E A We consider problems different input settings line previous sections Enumerative representation The constituents instance I explicitly given sets A S Aag S E enumerative form functions Φa s posss exo graphs tables State variables representation A state s represented vector s v 1 vm values variables f 1 fm ranging given ﬁnite domains D1 Dm A Aag given enumerative form We assume polynomialtime procedures evaluating following predicates available cid7 in_posss in_exos deciding s in_Phis s in_Ss in_Es deciding s S s E respectively cid7 Φs posss exos respectively Orthogonal consider 1 general k versus constant k order highlight complexity small windows opportunity maintenance 2 absence exogenous actions cost intuitively caused adversary 3 nondeterministic versus deterministic actions The results complexity analysis compactly summarized Tables 1 2 stated entries stand completeness results logspace reductions We assume reader familiar classes P polynomial time EXP exponential time L logarithmic workspace NL nondeterministic logarithmic work space coNP conondeterministic polynomial time PSPACE polynomial space appearing tables refer 57 references background complexity By LH denote logarithmic time hierarchy 1138 given LH icid20 Σ log Σ log denotes decision problems solvable alternating Turing machine cid5 1454 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 Table 1 Complexity deciding kMaintainability enumerative representation logspace completeness exogenous actions deterministic nondeterministic kMaintainability given k P NL Th 1115 P Th 1113 constant k cid2 1 P LH L Th 1116 P LH L Th 1116 Maintainability P NL Co 12Th 15 P Co 12Th 13 Table 2 Complexity deciding kMaintainability state variables representation logspace completeness exogenous actions deterministic nondeterministic kMaintainability given k EXP PSPACE Th 1821 EXP Th 1820 constant k cid2 1 EXP coNP Th 1822 EXP coNP Th 1822 Maintainability EXP PSPACE Co 19Th 21 EXP Co 19Th 20 logarithmic time i1 alternations existential universal states starting existential state Note LH strictly included L A reﬁned complexity assessment given Section 72 However refrain providing sharp complexity characterization problems classiﬁed LH terms completeness suitable notion reduction central maintainability issue adversarial environment Under enumerative representation Table 1 kMaintainability complexity Horn SAT P complete 57 In fact holds case constant k 1 restriction actions deterministic single exogenous action Thus simplest setting adversary according dimensions problem harbors complexity excluding nondeterministic actions andor ﬁxing k problems simpler Intuitively help exogenous actions simulate nondeterminism split sequences agent maintenance actions small segments On hand exogenous actions excluded listed kMaintainability easier actions deterministic maintenance window small k constant In summary results exoge nous actions compiled eﬃciently away reasonable complexity instance maintainability small maintenance window nondeterministic actions indispensable compilation The reason absence exogenous actions k Maintainability akin graph reachability resp planning problem Section 83 Indeed deﬁne ﬁxed A S A Φ poss set agent action Aag A sets E S S states predicates ris cid2 0 s S inductively r0s s E ri1s s E Aag posss s cid7 S cid3 s cid7 Φs ris cid7 cid4 cid2 0 1 Informally ris expresses state E reached s agent actions holds S k maintainable respect E exactly rks holds s S proved Lemma 1 The predicate rks deﬁnable ﬁrstorder predicate logic suitable relational vocabulary predicates given enumerative representation As wellknown ﬁrstorder deﬁnable properties decided LH 1138 Since LH considered contain problems lower complexity hard problems P effect exogenous actions drastic complexity terms Under state variables representation Table 2 complexity problems exceptions increases exponential This increase intuitively explained fact state variables permit general exponentially smaller input representation unpacked solving problem The exception constant k absence exogenous functions complexity increases LH coNP intuitively explained fact quantiﬁer cid7 S ranges polynomial set values input size Aag posss Eq 1 opposed s deterministically eliminated Exogenous actions compiled eﬃciently away cases enumerative representation For practical concerns draw results following conclusions While kMaintainability tractable enumerative representation Pcompleteness amenable eﬃcient parallel com putation solvable polylogarithmic workspace widely believed complexity hypotheses However exogenous actions absent maintenance window size bounded constant problem solved constant time polynomial number processors follows membership LH 38 The EXPcompleteness results state variables representation imply problems provably intractable exponential time current methods exponential workspace needed solve Thus polynomial time reduction popular propositional logic engines SATUNSAT QBF solvers httpwwwsatcompetitionorg httpwwwqbﬂiborg stateoftheart systems infeasible general Only cheapest cases size C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1455 maintenance window bounded constant exogenous actions absent polynomialtime reduction k Maintainability SATUNSAT solvers feasible polynomialtime reduction kMaintainability QBF solvers feasible deterministic domains absence exogenous actions When exogenous actions possible com plexity shows resort expressive engines answer set solvers discussed Section 65 instance We remind results Table 2 worstcase complexity results constraints problems solvable polynomial resources A detailed study issue remains future work 72 Enumerative representation We start case enumerative representation Our ﬁrst result following Theorem 11 Problem kMaintainability Pcomplete logspace reductions The Phardness holds restriction k f A S E function A S E f A S E cid2 1 particular ﬁxed k cid2 1 addition actions deterministic exogenous action Proof The membership kMaintainability P follows Corollary 8 We prove Phardness stated restriction reduction deciding logical entailment π cid8 q proposi tional atom q propositional Horn logic program PHLP π set rules form b0 b1 bn n cid2 0 2 bi propositional atom underlying atom set At b0 head b1 bn body rule As wellknown π cid8 q holds iff sequence rules r1 r2 rm m cid2 1 π ri form bi0 bi1 bin bi1 bin q called proof q π Informally q derived successive application rules r1 rm ri ﬁres previous rules r1 ri1 ﬁred 1 m particular 1n 0 bm0 b10 bi10 A natural idea represent backward rule application rm rm1 r1 agent actions rule r form 2 agent action a_r applied state sb0 representing b0 brings agent nondeterministically state sbi representing bi 1 n Given state sq encoding q S sq maintainable wrt set states E encoding facts π q proof π However account restriction k f A S E f The key establish result extremal case k 1 constant 1maintainability extend general case Using constrained rule format π exogenous action emulate nondeterministic agent actions sequences agent actions coding tricks alternating sequences deterministic agent exogenous actions provability q π corresponds 1maintainability S wrt set E A constructible logarithmic workspace q π Without loss generality assume rule zero atoms body n 0 n 2 2 We construct π q A S A Φ poss sets states S E set Aag A function exo follows 1 S For atom f π rule r π f 0 f m r1 rm states S Furthermore body r u v u v0 u vm1 states S 2 A a_r r π e 3 Φ For rule r π head f Φa_r f ri 1 m Φa_r f vi ri f vi S 1 m 1 If r body u v Φe ri u vi1 Φe u vi1 v i1 1 m 1 In cases Φa s 4 poss For state s posss A Φa s cid4 5 E r1 rm r π 6 S qm 7 Aag A e 8 exo rules r π form f u v exori e 1 m exou v j e j 1 m 1 For states s exos The transition diagram constructed π b c b c shown Fig 11 Intuitively state f encodes f derived π proof length This propagated backward rule application Each agent action a_r selects rule r prove atom f rule body u v exogenous action pushes agent prove u u v v decreased recursion depth We claim π cid8 q iff exists 1maintaining control K S respect E A Suppose ﬁrst π cid8 q We construct 1maintaining control K S respect E follows Let P r1 rk proof q π loss generality rules ri different heads Set D qm iterate following D remains unchanged For f D resp u vi D cid2 0 let r j rule head f 1456 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 Fig 11 Transition diagram π b c b c q S E encircled cid7i1 resp u P Deﬁne K f a_r j resp K u vi a_r j add r j body u D Since P proof q π rule r j exists state s ClosureS A K exo E D K s deﬁned ΦK s s yields state E Hence K 1maintaining control S respect E A states u vi1 v cid7 v cid7 Conversely suppose K 1maintaining control S respect E A Without loss generality K s undeﬁned states s E An easy induction cid2 1 shows f ClosureS A K exo resp u vi ClosureS A K exo holds π cid8 f resp π cid8 u π cid8 v For 1 suppose ﬁrst K f 1 a_r Rule r form f states u v0 v 0 ClosureS A K exo contradicts K 1maintaining control Hence π cid8 f Next suppose K u v1 a_r Then similar reasons r form u π cid8 u Furthermore v 1 ClosureS Aexo established π cid8 v For 1 suppose K f a_r Then r form f π cid8 f form f u v In case u vi1 ClosureS A K exo induction hypothesis π cid8 u π cid8 v Consequently π cid8 f Similarly K u vi a_r r form u form u u π cid8 u Since v ClosureS A K exo established π cid8 v Consequently π cid8 f This proves statement 1 concludes induction Since qm ClosureS A K exo π cid8 q This proves claim cid7i1 ClosureS A K exo induction hypothesis implies π cid8 u π cid8 v u cid7 v cid7 v cid7 cid7 cid7 Notice A S E constructed logarithmic workspace π q This proves Phardness 1 Maintaintability An easy observation agent action A leads state set E described Hence S 1maintainable respect E A iff S kmaintainable respect E A f A S E f A S E cid2 1 Hence Phardness stated restriction follows cid2 The following result immediate result fact maintainability equivalent kmaintainability k S number states Corollary 12 Maintainability Pcomplete The Phardness holds actions deterministic exogenous action The following result states Pcomplete restriction problems Theorem 13 kMaintainability Maintainability exogenous actions Pcomplete Proof Membership P established The Phardness follows Theorem 11 merging single exogenous action e agent actions follows For state s e exos redeﬁne action posss Aag Φs Φs Φs e It easy given S E S Smaintainable wrt E resulting A iff S Smaintainable wrt E A Furthermore A computable logspace A This implies result cid2 cid7 cid7 The hardness results border hardness frontier sense absence exogenous actions case Maintainability nondeterminism problems longer Phard The following lemma gives useful characterization kmaintainability purpose Lemma 14 Given A S A Φ poss set agents action Aag A set states E set states S kmaintainable respect E absence exogenous actions exo void k cid2 0 iff rks 1 holds s S Proof For direction consider 1maintaining control K loss generality undeﬁned s E For state s ClosureS A K exo ClosureS A K let ds distance s E K C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1457 largest σ s0 s1 si Unfoldks A K s0 s By easy induction ds cid2 0 obtain K s witness 1 rds s rds1s rks hold s Hence rks holds s S Conversely let s S integer ris holds If 0 deﬁne K s arbitrary action Aag posss witnessing 1 1 0 ris hold cid2 0 let K s undeﬁned Then K kmaintaining control S respect E deﬁnition relations ri s ClosureS A K σ s0 s1 sl Unfoldks A K s0 s holds l cid3 k sl E recall tacitly assumed Φa s cid4 possa Hence S kmaintainable respect E cid2 We establish following result Theorem 15 kMaintainability Maintainability systems deterministic actions exogenous actions NLcomplete cid7 Φs Proof In case deciding ris given s S cid2 0 NL If s E proper 1 s cid7 established maintaining counter This feasible logarithmic workspace guessed recursively rk1s representation size A By looping s S follows Lemma 14 deciding S k maintainable respect E k cid3 S nondeterministically feasible logarithmic workspace This implies NLmembership kMaintainability Maintainability The hardness follows simple reduction wellknown NLcomplete Reachability problem 57 kresp Maintainability Given directed graph G V E nodes s t V decide directed path s t G Deﬁne A S A Φ poss S A V Φv w w possv w v w E Then Aag A S s V maintainable wrt E t A iff directed path s t G Clearly A constructible logarithmic workspace G This shows NLhardness cid2 In case constant k Eq 1 decidable straightforward deterministic recursive procedure logarithmic workspace nondeterminism recursion depth bounded constant recursion level requires logarithmic work space Hence kMaintainability decidable logarithmic space A ﬁner grained analysis class Π log k1 logarithmic time hierarchy better upper bound makes completeness logspace suitable reductions fairly unlikely We assume input I kMaintainability ﬁxed k relational structure MI universe U MI S A cid7 in_posss in_exos in_Ss in_Es relations U MI predicates in_Phis s relations additional predicates ag_acta in_Ss in_Aa representing membership Aag s S A s U M respectively The structure MI encoded standard way bitstring 38 Theorem 16 Problem kMaintainability systems exogenous actions Π log 2k1 coΣ log 2k1 k cid2 0 constant Proof Any ﬁrstorder formula ψ1 Q xψ2 resp ψ1 Q xψ2 ψ1 free variables Q logically equivalent Q xψ1 ψ2 resp Q xψ1 ψ2 Exploiting rks 1 written vocabulary ﬁrstorder formula φkx prenex form x1x2x3 Q kxkψx1 xk x ψx1 xk x quantiﬁerfree element s U MI input structure M sentence in_Ss φks true M iff rks holds Hence Lemma 14 kmaintainability S wrt E A deﬁnable Πk1 prenex sentence x0x1 Q kxkψ cid7x0 x1 xk ψ cid7x0 x1 xk quantiﬁerfree vocabulary Whether ﬁxed sentence false given structure MI decided alternating Turing machine starting existential state logarithmic time k alternations 1138 Hence problem coΣ log 2k1 cid2 k1 Π log We remark hardness results section strengthened case 2 agent actions available leave proof interested reader 73 State variables The following easy lemma combination results previous subsection implies upper bounds Table 2 Lemma 17 For instance kMaintainability resp Maintainability states represented variables corre sponding instance ordinary enumerative form generated polynomial workspace Using lemma prove following result Theorem 18 Under state representation variables kMaintainability EXPcomplete The EXPhardness holds restric tion k f A S E function A S E f A S E cid2 1 particular ﬁxed k cid2 1 addition actions deterministic exogenous action 1458 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 Proof Membership EXP follows easily Lemma 17 Theorem 11 The EXPhardness shown reduction deciding inference π cid8 pt ground atom pc functionfree Horn logic program π variables datalog program consists rules form p0t0 p1t1 pntn n cid2 0 3 pi predicate arity ai cid2 0 ti ti1 tin list constants variables ti j p0t0 head p1t1 pntn body rule It holds π cid8 pc iff sequence rules ri form pi0 ti0 pi1 ti1 pin tin substitutions θi ri mappings variables ri set constants Cπ π pi1 ti1 θi pin tin θi p10 t10 θ1 pi10 ti10 θi1 1 m particular 1n 0 pm0 tm0 θm pc called proof pc π Informally pc derived successive application rule instances r1θ1 rmθm like propositional logic program Deciding π cid8 pt wellknown EXPcomplete cf 22 The construction similar spirit proof Theorem 11 involved To prove EXPhardness kMaintainability given restriction ﬁrst focus 1Maintainability reduce π cid8 pc logarithmic workspace deciding 1maintainability set states S wrt set states E agent A Without loss generality following assumptions π pc The set constants occurring π Cπ 0 1 rule r π zero atoms body rules r safe variable X occurring head rule r occurs body π uses predicate p c 0 0 0 Any problem π cid8 pc transformed equivalent form logarithmic workspace Similar propositional case idea represent reversed proof rm θm r1θ1 pc π agent actions model backward rule applications agent actions note m ranges 1 2ap ap arity p m requires ap bits The problem makes complex fact rule ri θi account If ri nonempty body candidates θi systematically generated alternating agent exogenous actions For possible θi derivation body atoms pti2 θi pti2 θi explored More precisely ground atom pc m 0 2pa state c m prove outside E intuitively says pc derivable m 0 cid3 m cid3 2pa steps For rule r π agent action ar possible c m prove m 0 pc uniﬁes head pt r results state c m r apply E For r form pt pt1 pt2 phases established 1 selection substitution θ variables X r 2 generation states c1 m1 prove c1 m1 prove c1 θ1 c2 θ2 recursive test As 1 exogenous action e pushes agent c m r apply state c m 0 0 0 r sel_θ Here 0 0 0 substitution θ X1 0 Xk 0 variables r By executing agent action incθ state vector incremented 0 0 0 1 resulting state c m 0 0 0 1 r incθ E e pushes agent state c m 0 0 1 r sel_θ Xn 1 θ Here incθ possible leading state c m 0 0 1 0 r incθ E e pushes agent state m1 t 0 0 1 0 r sel_θ Here action possible agent In state c m θ r sel_θ ptθ c agent alternatively action choose brings state c m θ r chosenθ E closes phase 1 The exogenous action e pushes agent state state m t1θ t2θ do_split E From state e pushes agent state t1θ m1 prove agent m t1θ t2θ do_split action split brings state t2θ m1 goto_prove E e pushes agent t2θ m1 prove Fig 12 gives summary steps graphical form Fig 12 Schematic transition diagram backward application rule r pt pt1 pt2 substitution θ prove pc C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1459 In way derivation p0 0 0 π encoded deciding 1maintainability S 2d 0 0 0 prove respect set states E described Note prove pc π rule r instance rθ chosen 1maintaining control single θ proper placement action chosenθ The proof correctness lines respective Theorem 11 Given regular structure states easy checks manipulations need determining applicability actions determining successor state respectively diﬃcult representation 1Maintainability instance state variables compiled π p0 0 0 logarithmic work space cid7 in_posss particular polynomialtime procedures deciding membership predicates in_Phis s in_exos in_Ss in_Es provided polynomial time Note instance employs deterministic actions single exogenous action This establishes EXPhardness 1Maintainability Furthermore A E constructed agent action results state E Thus kmaintainability S wrt E A k f A S E f A S E cid2 1 equivalent 1maintainability S wrt E A Hence reduction shows EXPhardness kMaintainability stated restriction cid2 Corollary 19 Under state representation variables Maintainability EXPcomplete The EXPhardness holds actions deterministic exogenous action Using Theorem 18 instead Theorem 11 prove following result similarly Theorem 13 Theorem 20 Under state representation variables absence exogenous actions kMaintainability Maintainability EXPcomplete For case exogenous actions deterministic actions lower complexity Theorem 21 Under state representation variables k Maintainability Maintainability systems deterministic actions exogenous actions PSPACEcomplete Proof By wellknown standard methods computation composed PSPACE computation A piped NL computa tion B NPSPACE size input A redesigned NPSPACE computation Since NPSPACE PSPACE membership problems PSPACE follows Lemma 17 Theorem 15 The PSPACEhardness shown straightforward reduction propositional STRIPS planning 16 Rather introduce STRIPS completeness sake simple reduction Succinct Reachability 57 version Reachability G V E nodes v given binary vectors v v 1 vn n cid2 1 0 1 problem input consists Boolean circuit C G 2n inputs v 1 vn w 1 wn outputs true iff v w E s 0 0 0 t 1 1 1 We construct instance kMaintainability resp Maintainability follows S V V described 2n binary variables f 1 f 2n A arc Aag Φv w cid7 w 1 modulo 2n Φv w arc w 0 0 0 v w G Φv w arc v w v w posss A state s Then state s 1 1 1 0 0 0 Smaintainable respect E 1 1 1 1 1 1 A iff 1 1 1 reachable 0 0 0 G A state variable representation A easily generated circuit C G logarithmic workspace This implies PSPACEhardness problems cid2 w cid7 If maintenance window bounded constant problem easier Theorem 22 Under state representation variables kMaintainability systems exogenous actions constant k cid2 0 coNPcomplete Proof For given s S falsity rks proved exhibiting assuming s E Aag posss witness ws S ws Φs rk1ws false recursion proved similarly For constant k leads O Aagk guesses ws polynomial size input By Lemma 14 follows deciding complement kMaintainability NP This proves membership coNP The coNPhardness k cid2 0 simple consequence representation state variables deciding S E coNPcomplete shown simple reduction propositional unsatisﬁability cid2 8 Discussion conclusion In paper gave formal characterization maintenance goals distinguished notions stabi lizability temporal goals form cid2cid3 f valid trajectories We present motivating examples illustrate need notion maintainability The basic idea certain kinds maintenance im portant maintaining agent given window noninterference environment 1460 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 maintenance To formalize need distinguish agents actions environments actions In formalization deﬁne notion kmaintainability k refers maximum window opportunity necessary maintenance We gave polynomial time algorithms compute kmaintainable controls lineartime small k analyzed complexity determining kmaintainability assumptions One interesting aspect polynomial time algorithm approach led ﬁnding use SAT encoding complexity results special Horn subclass propositional logic We report experiments carried discuss related work conclude 81 Experimental results The different methods constructing kmaintaining controls previous sections implemented order compare experimental basis More speciﬁcally programs generating SAT encoding Horn SAT encoding written propositional logic program implemented Java algorithm k Control For SAT solving zChaff employed evaluating Horn SAT instances answer set solvers DLV Smodels plus preprocessor Lparse The logic programs variables given Section 6 ready use DLV described minor adjustments needed Smodels The encodings implementations descriptions domains available httpwwwpublicasuedujzhao6kmaintain To evaluate performance implementations conducted experiments buffer domain described Section 3 varying size buffers max number k maintaining control In experiments single goal state 0 0 buffers single initial state 1 1 3 5 note cases smallest k kmaintaining control exists k 2 max 1 The results experiments shown Table 3 They collected Dell desktop Intel Pentium 4 253 GHz 512 MB main memory 753 MB swap space Slackware 110 including Linux kernel 24333 We prerelease betaversion DLV version 200710118 Lparse 1017 Smodels 232 In table leftmost column shows buffer size max parameter k rightmost column tells solution exists The times reported deciding kmaintaining control exists computing model control eﬃciently extracted fact linear time genuine algorithm output control Step 4 fast For SAT Horn SAT encodings column instance shows timings generating respective instances Section 63 input representation Section 61 columns timings solving instances respective solver numbers parentheses total instance generation solving Since Lparse preprocessor Smodels solves Horn SAT instances Smodels actually omitted The column genuine algorithm shows results implementation Algorithm kControl columns right results logic programming encodings deterministic nondeterministic transition function Here problem input explicit form facts described rules Section 65 However generating factual representation takes short time 14 115 ms larger problem size negligible compared time required solving instance The experiments interesting results Among SAT Horn SAT solving methods logic programming engines perform overall better SAT solver This explained fact generating SAT instance solver takes longer generating corresponding Horn logic program One possible reason input format SAT solver requires strings mapped integers represent propositional variables This hashmap vectors better design data structure save time translation On hand SAT solver needs time solve instance LP engines We remind committed compute special model SAT solver compute arbitrary model instance The SAT solver scales reasonably instances similarly DLV small factor cases Moreover DLV scales overall time Smodels showed weakness Both SAT solving Horn logic programs limitations constructed instances larger memory exhausted memory experimental setting modest The genuine algorithm faster SAT solving method larger instances slower Horn SAT solving The explained fact internal Java data structures vectors maps optimal However implementation scales respect k The logic programming encodings variables behave similar Horn SAT encodings apart case timings nondeterministic LP encoding LparseSmodels comparable Horn SAT method DLV The nondeterministic LP encoding DLV cases faster Lparsesmodels shows smooth scaling cases This discrepancy explained different heuristics systems model search The deterministic encodings cases faster nondeterministic counterparts speedup limited small factor 2 3 We remark extracting actual control model computed LP engine adding rules Section 62 program scale large k general The reason rule k_plus single 8 Kindly provided DLV team The oﬃcial release 20071011 behaves similarly C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1461 Table 3 Experimental results deciding kmaintainability Buffer Domain times secs start state 11 goal state 00 Problem max k SAT encoding instance zChaff Horn SAT instance Lparse Smodels 105 1010 1015 1020 1021 1025 1030 1035 1040 1045 205 2010 2015 2020 2025 2030 2035 2040 2045 2050 2055 2060 0648 0021 1439 0062 3320 0079 6543 0100 7421 0209 12335 0276 19467 0346 26236 0398 35321 0417 45195 0463 0669 1501 3399 6643 7630 12611 19813 26634 35738 45658 8054 7933 0121 35221 35043 0178 88978 88729 0249 164540 164208 0332 264032 263623 0409 397537 397018 0519 564703 564108 0595 685489 684858 0631 852107 1990 854097 1073237 2315 1075552 2526 1326045 1323519 1630561 3448 1634009 start state 35 goal state 00 205 2010 2015 2020 2025 2030 2035 2040 2045 2050 2055 2060 305 3010 3015 3020 3025 3030 3035 3040 3045 3050 3055 3060 3065 3070 7771 7646 0125 33988 33814 0174 86507 86259 0248 158415 158087 0328 252753 252355 0398 383609 383141 0468 525977 525430 0547 697157 696514 0643 893684 3417 897101 1072981 2831 1075812 1327165 2541 1329706 1601926 3335 1605261 51410 51629 0219 206995 206631 0364 496586 496045 0541 866907 0723 867630 1388404 0880 1389284 1971139 1065 1972204 1267 2686884 2685617 3408562 1663 3410225 4272727 1818 4274545 memory memory memory memory memory 0465 0533 0613 0650 0665 0688 0761 0801 0851 0883 2347 2532 2735 2933 3207 3250 3523 3691 3758 3889 4071 4353 2483 2564 2767 2983 3113 3307 3444 3607 3839 3938 3981 4327 10176 10569 10754 11153 11595 12306 12522 13252 18476 31191 0435 0842 1211 1676 1606 1770 1656 1809 2034 2111 1602 3196 4240 6299 7981 9709 11138 12757 13119 13650 13923 28818 1639 3146 4661 6252 7781 9242 10853 13342 13781 13250 13547 15091 0900 1375 1824 2326 2271 2458 2417 2610 2885 2994 3949 5728 6975 9232 11188 12959 14661 16448 16877 17539 17994 33171 4122 5710 7428 9235 10894 12549 14297 16949 17620 17188 17528 19418 13733 3557 17482 6913 20861 10107 24941 13788 38341 26746 37625 25319 137047 124525 665565 678817 681040 699516 624709 593518 memory memory memory memory DLV 0118 0203 0271 0380 0599 0743 0865 1007 1220 1455 0425 0814 1152 1624 1955 2359 3166 3560 8353 7885 8247 8795 0432 0860 1206 1656 1925 2319 3115 3388 7721 7552 7681 8055 0867 1862 3025 3668 4664 7637 7333 7675 8421 9450 Genuine Algorithm DLV det Lparse Smodels ndet det ndet solution yesno 0583 0736 0884 1030 1264 1431 1626 1808 2071 2338 2772 3346 3887 4557 5162 5609 6689 7251 12111 11774 12318 13148 2915 3424 3973 4639 5038 5626 6559 6995 11560 11490 11662 12382 1819 3127 4269 5576 5598 6235 5440 5412 5422 5418 23177 43569 67770 82192 102264 120628 144418 151763 162128 172677 193645 152911 22734 41956 59228 78784 95766 115793 132549 150920 161092 172896 185470 153073 125925 11043 235732 12431 332056 13779 444367 14821 16259 535193 19943 646284 742747 19855 863109 20927 26897 940408 40641 1065352 1155366 1262594 1319128 1387423 0157 0094 0308 0171 0485 0227 0607 0282 0866 0399 1771 0523 4444 2022 6664 2916 4310 10935 5481 14787 0257 0365 0486 0615 0769 0971 1141 1284 1445 1628 0405 0691 0955 1245 1536 1619 1929 2226 2534 2831 0655 0334 1531 0934 1363 0623 2765 1595 2046 0915 4022 2229 2878 1192 5294 2862 3752 1561 6573 3569 4704 1844 7848 4187 5932 2274 4856 9108 2724 6489 5536 10381 3907 14954 7523 12224 24345 22828 8309 13655 9398 15083 48505 35543 79994 55327 10496 16530 0355 0642 0623 1349 0932 2012 1220 2803 1596 3592 1897 4588 2247 5834 6285 2653 3593 13752 11786 23132 20229 38767 33750 62340 10415 1047 1533 1611 2790 2249 4026 2896 5344 3573 6671 4210 7944 4850 9106 10363 5619 7393 12216 7548 13655 8924 15047 16558 3904 2628 1424 0871 4428 7215 3003 1732 6323 10395 5593 2718 6784 8228 13693 4090 9013 10308 17057 3929 4718 12072 20498 12413 5846 14634 13823 23927 7185 16401 16230 27347 8269 19305 17985 30798 19646 34278 9656 21914 37816 11058 25889 21517 41146 13481 31304 23919 17987 53466 29790 56084 43161 89959 32501 80523 yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes cid7 s s cid7 Φs quadratically ground instances k possible transition sas Although single instance relevant solver predetermine grounding phase However problem easily circumvented keeping additional rules separate postprocessing program feeding model computed main program Then control quickly output time largely dominated time model computation worst case seconds cid7 S A posss s ωmaintaining controls We conducted experiments different methods deciding existence ωmaintaining control More speciﬁcally following twophase approach Section 54 considered proposi tional logic programs genuine algorithm logic programs variables note SAT encoding phases straightforward need compute transitive closure phases phase 2 accesses complement output phase 1 simple realization requires layered use negation logic program ming encodings generic programs variables unstratiﬁed negation avoided method Section 64 1462 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 Table 4 Experimental results deciding maintainability Buffer Domain times secs s g sol methodmax 10 20 30 40 50 60 70 80 90 100 11 yes propositional DLV genuine algorithm 00 LparseSmodels DLV propositional Lparse 03330056 11920186 45780362 101820677 239921041 527122148 1026323717 1810205801 2971729154 44614113399 03330018 11920104 45780270 101820439 239920693 527121054 1026321134 1810201694 2971722134 4461412535 42432 23770 4576097 6206 5781 1835164 3278 4071 9762176 10949 8770 629925 1522 1815 152918 0631 0922 20266 0226 0398 28304 17687 17919 12832 1034 0044 0124 propositional Lparse 03420094 11740224 49750496 107650675 253351237 554922154 1024013672 1809495808 3012498514 44567812074 91 yes propositional DLV 03420065 11740136 49750330 107650456 253350672 554920984 1024011172 1809491534 3012492103 4456782446 55 43868 23106 genuine algorithm LparseSmodels DLV 2813434 7140 5656 5097606 10909 8653 1315840 3234 3626 553806 1497 1725 127646 0610 0903 28932 17505 19647 12048 15898 0200 0388 0738 0048 0056 32 propositional DLV genuine algorithm 44 LparseSmodels DLV propositional Lparse 03570072 11840213 46470376 101910630 239651054 525742074 1027433640 1806016251 3024368869 44586712019 03570017 11840129 46470222 101910316 239650507 525740807 1027431006 1806011282 3024362392 4458672177 43159 17803 8973392 11122 6286 2772359 6553 4035 1281064 3384 2414 125848 0591 0617 542273 1503 1322 28787 13152 18343 9292 15702 0180 0259 0698 0049 0040 19 propositional DLV genuine algorithm 74 LparseSmodels DLV propositional Lparse 03450090 11010217 45880374 101730688 240851162 526552092 1020923633 1809005771 2985408529 44683311969 03450017 11010093 45880196 101730297 240850497 526550800 1020921013 1809001291 2985401844 4468332170 43260 18442 3943009 6325 4005 1523882 3512 2377 8735724 11194 6219 498534 0503 1280 112653 0607 0581 28862 12922 18351 9190 12519 0184 0214 0511 0051 0066 Phase 2 fact realized logic programs computing ﬁrst set states pruned complementing The results experiments summarized Table 4 There s single start state g single goal state For propositional LP program times creating factual representation solving shown ms dash means timeout 10000 seconds The ﬁrst instances solution As seen LP encodings variables scale linear time trend note instance size problem quadratic buffer size Unsurprisingly propositional LP encodings evaluated faster LP encodings variables lot time needed construct respective programs total nonground programs faster The implementation genuine algorithm scale way slower LP encodings However similar case kmaintainability implementation use optimal data storage structures room improvement We remark propositional LP encoding constructed faster experiments times exploits domain deterministic Furthermore variant DLV encoding variables pruning phase 2 focused states having apath goal set determined phase 1 shows similar performance With respect methodological approach observe following Using SAT solving logic programming construct kmaintaining ωmaintaining controls example theoretical shows value obtain quick implementations perform reasonably Genuine algorithms extracted SAT logic programming solutions potential require implementation optimization efforts order highly eﬃcient signiﬁcantly faster ﬁrst shot methods In particular state space large maintenance window small logic programming based approach attractive mind preferences constraints imposed solutions declarative manner 82 Relation earlier work control synthesis In section compare work earlier work control synthesis 11019414960 We start papers Barbeau et al 10 Kabanza et al 41 AI literature 821 Relation Barbeau et als Kabanza et als work Barbeau et al 10 Kabanza et al 41 present method synthesize reactive plans9 based progressing mulas linear temporal logic called Metric Temporal Logic MTL allows specify durations temporal operators If ignore durations operator speciﬁcation language linear temporal logic LTL operators cid9 cid2 cid3 U Similar allow actions nondeterministic transitions However 41 allow exogenous actions Although 10 allows exogenous actions requires exogenous actions agent actions interleaved Thus use formulation translate formalism theirs For example compile away 9 Their notion reactive plans slightly different notion control functions case state world state associated plan states For type goal control functions sense easily extracted reactive plans blowup C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1463 exogenous actions10 formulation mentioned earlier introduce ﬂuent interfered remember transi tion immediately exogenous action The resulting transition function nondeterministic transitions need speciﬁcation Aπ cid2φS cid2Stepkinterfered φE language 9 express kmaintainability However control generation algorithm 1041 able construct control goals form Aπ f f LTL formula algorithm focuses f Their algorithm based progressing LTL formula The intuition progression given sequence states σ s0 s1 LTL formula f progression f respect state si satisﬁes property σ cid8 f iff σ 1 cid8 progression f si A partial deﬁnition progression needed illustration follows proposition p progressionp s true p true s false progression f s progression f s progression f g s progression f s progressiong s progression f g s progression f s progressiong s progressioncid2 f s progression f s cid2 f progressioncid9 f s f To illustrate algorithm works consider important fragment LTL goal cid2Stepk interfered φE To simplify let ϕ denote interfered φE let sϕ denote state ϕ true sϕ denote state ϕ true In following let progression f s1 s2 sn denote progressionprogression progression f s1 sn We illustrate progression works respect goal progressioncid2Stepkϕ sϕ cid2Stepkϕ Stepkϕ cid9cid2Stepkϕ progressioncid2Stepkϕ sϕ Stepk1ϕ cid2Stepkϕ Stepk1ϕ cid9cid2Stepkϕ progressioncid2Stepkϕ sϕ sϕ Stepk2ϕ cid9cid2Stepkϕ progressioncid2Stepkϕ sϕ sϕ sϕ Stepk3ϕ cid9cid2Stepkϕ As evident progression lead k different formulas The general algorithm 1041 introduces decomposition connective Stepkϕ 2k formulas labeling state leading search space 2k I Since need worry cycles avoid double exponential search However noticing goal speciﬁcation unbounded eventualities modify algorithm avoid decomposition restrict search space k I After needs eﬃcient search search space search algorithm given 1041 eﬃcient backtracking In conclusion algorithm 1041 presented ﬁnd kmaintainable control polynomial time certain modiﬁcations algorithm eﬃcient This illustrates importance work 1041 It suggests research direction exploring subclasses LTL goal speciﬁcations identifying appropriate modiﬁcations simpliﬁcations algorithms 1041 lead eﬃcient control ﬁnding method In slight contrast approach ﬁnd eﬃcient algorithm speciﬁc goal logical manipulations It led ﬁnding eﬃcient different algorithms goal speciﬁcations strong planning strong cyclic planning weak planning discuss 4 822 Relation work control synthesis Most works control synthesis dates earlier time temporal logics proposed program speciﬁcation purposes Clarke Emerson 19 consider speciﬁcations branching time temporal logic CTL present algorithm construct synchronization skeletons concurrent programs scratch The algorithm constructs ﬁnite model formula tableaubased procedure factors control skeletons individual processes global ﬂow graph deﬁned model There complexity analysis given authors mention algorithm potentially exponential Furthermore algorithm assumes closed environment actions 10 One compilation involves following For state s new state called sint created The states s sint equivalent respect ﬂuents newly introduced ﬂuent interfered false true later ii All edges original transition diagram agent action original transition diagram transition sint agent actions kept iii If transition s s cid7 s s cid7 agent action transition s int introduced v The set initial states enlarged follows If s initial state transition s s cid7 int initial state However complexity results Table 1 following discussions suggest compilation high worstcase effort doable agent action introduced iv For transitions s s series exogenous actions edge s series exogenous actions s s cid7cid7 cid7cid7 cid7 cid7 cid7 nondeterministic logspace This remains true respect compilation new k depends old k It noted respect buffer example compilation linear size input original transition O n2 nodes arcs n buffer size compiled O n2 nodes cid14n3 arcs come transitive closure exogenous actions Thus example compilation solving LTL planning problem solve kmaintainability ﬁxed k linear time algorithm 1464 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 speciﬁc agent actions constrains model building respected However crucial construction kmaintaining control applied CTL speciﬁcation control S wrt E algorithm return model states corresponding states outside S Independently Manna Wolper 49 consider construction synchronization communicating processes speciﬁcations linear time temporal logic PTL As mention main differences approach 19 usage PTL instead CTL 19 synthesizes shared memory programs Manna Wolpers synthesis method employs tableaustyle satisﬁability algorithm essentially 12 restricted linear time operators modiﬁed assumption state exactly atomic proposition true The algorithm declares speciﬁcation unsatisﬁable constructs model graph possible models PTL speciﬁcation extracted In construction PTL formulas decomposed identities cid2 f f cid9cid2 f cid3 f f cid9cid3 f f 1 f 2 f 2 f 1 cid9 f 1U f 2 enables model ﬂow graph talking current follow state execution As Manna Wolper argue size model graph exponential size speciﬁcation formula In ﬁnal step control code generated model graph Special care applied called eventuality conditions conditions form cid3 f satisfaction indeﬁnitely postponed aspect addressed 19 Since like 19 method assumes closed environment readily applicable constructing kmaintainable control Pnueli Rosner 60 algorithm synthesize reactive module input x output y environ ment values ﬁnite domain speciﬁed linear temporal formula ϕx y The running time algorithm constructed automatatheoretic results double exponential length given speciﬁcation nature diﬃcult perform construction kmaintaining control Abadi et al 1 introduce notion realizability somewhat general notion implementability 60 considers environment behavior restricted They distinguish environment agent activity changes environment deﬁne speciﬁcations abstract level sets behaviors alternating sequences states active parties environment agent satisfying conditions Realizability given subset behaviors generated runs restricted possibly nonrecursive partial function preﬁxes behaviors states noted realizability necessary suﬃcient condition existence real implementation A weaker notion realizability takes account implementor knows exactly environment behaves deterministic manner considered shown equivalent realizability important class speciﬁcations Finally issue realizability ﬁnite state transition systems P t represented automata equipped restriction inﬁnite behaviors systems given ﬁnitestate Büchi automaton P considered As pointed different consistency behaviors P t P Applying like Rosner Pnueli automatatheoretic results argued deciding realizability EXPTIME PSPACEhard logspace reductions An important note realizability Abadi et al view nondeterministic transitions optional outcomes actions implementor realization choose arbitrary subset For notion control required particular agent action chosen state outcomes action chosen Since realization merely compatible inﬁnite behaviors need manifest enforcing choice inﬁnite behaviors infeasible Hence method 1 applicable constructing kmaintaining control setting Recently works developing polynomial time control generation algorithms size state space particular classes LTL goals In particular paper 59 presents cubic algorithm size state space automatically construct controls GR1 goals form cid2cid3p1 cid2cid3pm cid2cid3q1 cid2cid3qn pi s q j s propositional formulas This complexity higher algorithm remains open ﬁnd approach lead eﬃcient algorithm GR1 goals 83 Other related work Besides related works mentioned stabilizability temporal logic notion maintenance appeared AI papers For example 55 Ortiz discusses maintenance actions His notion maintenance stronger notion stabilizability notion requires formula maintained true The notion maintenance related notion execution monitoring studied context robot programs 23 In execution monitoring world monitored discrepancy prediction agent real world new plans recover discrepancy A deliberative architecture maintenance extrapolated notions 5 agent executes cycle observe assimilate replan_from_current_situation execute_part_of _the_plan In series papers 272869 Wooldridge Dunne formalized problem constructing agent control func tions analyzed complexity rich framework kinds tasks achievement tasks agent bring certain goal condition maintenance tasks agent avoid goal dition satisﬁed execution combinations thereof 27 Their notion boolean task speciﬁcation allows seamless combination achievement maintenance goals In notion goal speciﬁcation propositional C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1465 formula proposition corresponds set states The intuitive meaning goal speciﬁcation p reach sure states corresponding p This corresponds achievement goal speciﬁcation p intuitively means agent avoid state p They refer later maintenance task bad states Thus notion maintenance differs While concerned hindrance posed adversary explicitly account number steps adversary interfering exogenous actions account explicitly They allow nondeterministic effect actions partially exoge nous actions account straightforward compilation keeping count window noninterference straightforward Their control policies richer In framework action effects selection agent action control depend history execution Under restriction historyindependent state transitions reactive agents ﬁnding controls achievement tasks framework corresponds ﬁnding maintaining controls unbounded window opportunity framework In 27 comprehensive complexity analysis agent design framework There natural correspondence complexity results theirs In particular Theorems 15 21 correspond respective results 27 In AI planning seminal STRIPS approach 32 inﬂuential approaches We brieﬂy recall STRIPS states modeled sets propositional atoms actions operators given precondition terms conjunction literals true current state transform successor state removing atoms delete list adding atoms add list A plan achieving goal described conjunction atoms γ initial state S0 sequence operators op1 opn takes agent S0 state γ holds STRIPS planning generalized directions conditional effects nondeterministic actions planning incomplete information partial observability conditional conformant plans respectively number papers considered computation complexity planning settings 616183164 However like framework Wooldridge Dunne works agent actions exogenous actions viewed separately best compared framework absence exogenous functions Furthermore plans se conceived action strategies cf 64 principle different actions taken agent plan execution state entered looping priori excluded goal achieved contingencies Daniele et al 21 introduce notion strong cyclic planning similarity notion main tainability In particular accept possibility environment belligerent case needs differentiate agent trying agent However encode environmental interference nondeterminism allow explicit representation environmental actions Daniele et al later Cimatti et al 18 consider constructing universal plans akin policies different semantics weak strong strong cyclic goal achievement based OBDD methods algorithms In particular absence exogenous actions maintaining controls correspond strong solutions planning problem For discussion refer 4 As complexity Theorem 21 corresponds classical result Bylander 16 deciding plan existence propo sitional STRIPS PSPACEcomplete Theorem 20 corresponds Littmans result conditional planning STRIPS nondeterministic actions EXPTIMEcomplete 4664 In conditional planning conditions current state branching subplans possible appropriate plan followed depending state evolution Branching modeled actions conditional planning problem loops disregarded problem constructing maintaining control In related work Jensen et al 3940 consider somewhat dual problem developing policies achieve given goal interferences environment In model environment actions actions multiple agents combined joint action transferred current state set pos sible successor states With nondeterministic transitions Jensen et al aim modeling adversial environment infrequent errors deterministic action nondeterministic In 39 consider construct ing policies coping arbitrarily interferences environment action failure extension OBDDbased universal planning 40 consider generating policies tolerate given number n er rors modeled secondary action effects caused improper action execution environment interference reducing called strong planning problem solved OBDD based methods For arbitrarily environment interferences 39 problem basically similar problem unbounded maintainability interfer ence goal states different signiﬁcance goal achievement guaranteed possible loops A formal connection kmaintainable controls nfault tolerant policies remains open Intuitively nfault tolerant plans easier construct number errors occurred recorded plan construction limit n reached problem boils ordinary planning problem For kmaintaining controls environment interference goal state causes restart pushes agent new initial state Outside AI notion kmaintenance closely related notion selfstabilization 24 characterizing faulttolerant systems There concern proving correctness hand developed selfstabilization protocols achieving selfstabilization distributed algorithms mutual exclusion Our algorithm thought algorithm automatically generates selfstabilization protocol Although new dimension existing work selfstabilization research needed compare assumptions formulation ones selfstabilization literature overcome In particular selfstabilization literature 1466 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 global states composed local states distributed elements particular element access complete global state In cases directly use kind global policies generated algorithm paper We elaborate Appendix A 84 Further work open issues There directions research extending work paper One direction concerns classes goal speciﬁcations apart kmaintainability maintainability controls synthesized polynomial time Another direction general execution models instance taking action duration account In scenario maintenance goal formulated requirement agent reaches desired state given time frame disturbed environment Preliminary investigations suggest results paper extended handle setting alternatively algorithm Barbeau et al 10 Kabanza et al 41 eﬃcient computation long durations long binary number representation lead increase complexity The intractability results problems state variable representations challenges methods techniques handling problem practice Suitable heuristics researched allow solve problems cases polynomial time reﬁned complexity analysis meaningful tractable cases singled Furthermore issue computing optimal kmaintenance controls eﬃciently sense k small possible trivially polynomially solvable enumerative setting interesting issue variable state representation Another issue concerns investigating computational transformations maintenance planning By com plexity results 46 paper transformations kMaintainability conditional planning feasible polynomial time It interesting study different transformations assess possible beneﬁts trans formations solving kMaintainability planning crossutilizing different algorithms implementations 18 planning nondeterministic domains In particular transformation similar proof Theorem 13 additional parameter counts number agent actions exogenous action can11 compile exogenous actions transform ﬁnding kmaintainable policies ﬁnding strong cyclic plans 18 On hand encodings similar Section 52 obtaining strong cyclic plans lineartime Horn logic programming designed For details results refer 4 Acknowledgements This work partially supported FWF Austrian Science Fund projects P16536N04 Z29N04 European Commission grant IST 200137004 WASP NSF National Science Foundation USA grant numbers 0070463 0412000 NASA grant number NCC21232 contracts ARDA DTO We like acknowledge W Cushing feedback earlier draft S Gupta M Gouda clariﬁcations selfstabilization Furthermore acknowledge comments J Rintanen ICAPS04 paper grateful pointers related work We owe special thanks F Kabanza helping understand coauthored papers 1041 making observations algorithms papers modiﬁed eﬃcient speciﬁc goal speciﬁcations We furthermore appreciate constructive comments reviewers improve presentation suggestion LTL formulation Section 41 suggestion linear time algorithm generic maintainability Finally indebted J Zhao implementing algorithms running experiments appreciate support DLV team Appendix A Selfstabilization related notions distributed computing Earlier remarked notion maintainability similarities Dijkstras notion selfstabilization 24 In appendix elaborate relationship notions Dijkstras similar notions distributed computing 2 A1 Dijkstras notion selfstabilization Dijkstra considers 24 connected graph majority edges missing ﬁnite state machine placed node machines placed directed connected nodes called neighbors For node machine Boolean function state machine states neighbors called privilege deﬁned There central daemon select privileges graph true The machine privilege selected state state based policy function state machine neighbors states results state transition machine consideration If machine privilege present new state depend privilege selected 11 This transformation increases number states k times It unknown exist transformation eliminate exogenous actions increasing number states able model notion kmaintainability C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1467 There global criterion telling legitimate state It required legitimate state privileges present ii legitimate state possible bring legitimate state iii privilege present legitimate state iv pair legitimate states exists sequence moves transferring The called selfstabilizing regardless initial state privilege selected time privilege present guaranteed ﬁnd legitimate state ﬁnite number moves Comparison notion maintainability Our notion state corresponds Dijkstras global state composed local states goal states legitimate states Analogous actions moves analogous policies selections privileges present Our policies select action executed based current state In Dijkstras model moves selected based current global state selection ﬁner privileges present selected The transition moves similar transition states action But Dijkstras transition ﬁner grained changes happen local state machine privilege selected change depends local state prior machine local state neighbors privilege selected We speciﬁc set initial states use exogenous actions compute closure states reached In Dijkstras deﬁnition selfstabilization states possible initial states This having closure set states Modulo differences Dijkstras notion selfstabilization notion ﬁnite maintainability If thinks terms global states essentially selfstabilization ﬁnite maintainability Our major contribution unlike research area selfstabilization protocols protocols invented people selfstabilizability systems protocols proven method automatically come protocols policies terms Nonetheless large body research selfstabilization respect distributed systems access global state deciding action Thus direction future research ﬁnd algorithms similar generate protocols policies distributed domain A2 Arora Goudas notion closure convergence faulttolerance Arora Goudas abstraction 2 closer Dijkstras We start deﬁnitions terminology A program consists set variables set processes Each process consists set conditionstatement pairs B st B Boolean expression program variables st updates zero program variables terminates execution A state program p deﬁned value variable p For process program p set conditionstatement pairs construct mapping states sets statements s maps set containing st iff B st process B evaluates true s This mapping referred policy corresponding process If program single process policy corresponding process referred policy program A state predicate p Boolean expression variables p A conditionstatement pair B st enabled state iff B evaluates true state A process said enabled state iff pair B st process enabled state Closure A state predicate S closed program p iff pair B st process p executing st starting state B S holds results state S holds A computation p sequence states satisﬁes following conditions pair consecutive states c d sequence exists pair B st process p B holds c executing st starting c results d ii sequence maximal sequence inﬁnite ﬁnite conditionstatement pair enabled state iii process j p continuously enabled sequence eventually action j chosen execution Convergence Let S T state predicates p T said converge S p iff S T closed p b computation p starting state T holds exists state S holds Faulttolerance Let S closed state predicate p let F set conditionstatement pairs variables p Then p F tolerant S iff exists state predicate T p T holds state S holds b pair B st F executing st starting state B T holds results state T holds c T converges S p 1468 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 The notions closure convergence fault tolerance Arora Gouda close similar notions deﬁnition maintainability We compare notions Comparison notions Arora Goudas notion states similar notion states notion statements similar notion actions statements cause deterministic transition states executable states actions nondeterministic effects executable states Their notion process consisting set conditionstatement pairs similar policy notion program consists set variables deﬁne states set processes Their notion closure notion closure assume absence exogenous actions presence single process We assume presence single process rest comparison Their notion computation similar notion sequence states obtained Unfold function fairness condition need single policy consideration policy dictates execution action state Arora Goudas notion T converges S single process similar ﬁnite maintainability absence exogenous actions T S correspond closure initial ﬁnal states respectively In notion fault tolerance captured p F tolerant S fault set F corresponds exogenous actions occur S corresponds set ﬁnal states p reﬂects statespace policy consideration In Arora Goudas deﬁnition fault tolerance T corresponds closure set initial states additional requirement set ﬁnal states S subset T Thus p F tolerant S corresponds notion policy p maintaining set initial states closure contains S respect S presence exogenous actions described F While notion maintainability similar notion tolerance class faults 2 Arora Gouda algorithm automatically construct policy process terms result tolerance algorithms generate policies policies exist guarantee maintainability References 1 M Abadi L Lamport P Wolper Realizable unrealizable speciﬁcations reactive systems Proc 16th International Conference Automata Languages Programming ICALP 89 LNCS vol 372 Springer 1989 pp 117 2 A Arora MG Gouda Closure convergence A foundation faulttolerant computing IEEE Transactions Software Engineering 19 11 1993 10151027 3 F Bacchus F Kabanza Planning temporally extended goals Annals Mathematics Artiﬁcial Intelligence 22 1998 527 4 C Baral T Eiter J Zhao Using SAT LP design polynomialtime algorithms planning nondeterministic domains Proc 20th National Conference Artiﬁcial Intelligence AAAI 05 AAAI Press 2005 pp 578583 5 C Baral M Gelfond A Provetti Representing actions Laws observations hypothesis Journal Logic Programming 31 1997 201243 6 C Baral V Kreinovich R Trejo Computational complexity planning approximate planning presence incompleteness Artiﬁcial Intelli gence 122 12 2000 241267 7 C Baral V Kreinovich R Trejo Computational complexity planning temporal goals B Nebel Ed Proc 17th International Joint Conference Artiﬁcial Intelligence IJCAI01 Morgan Kaufmann 2001 pp 509514 8 C Baral T Son Relating theories actions reactive control Electronic Transactions Artiﬁcial Intelligence 2 34 1998 211271 9 C Baral J Zhao Goal speciﬁcation presence nondeterministic actions RL Mántaras L Saitta Eds Proc 16th European Conference Artiﬁcial Intelligence ECAI 2004 IOS Press 2004 pp 273277 10 M Barbeau F Kabanza R StDenis Synthesizing plan controllers realtime goals Proc 14th International Joint Conference Artiﬁcial Intelligence IJCAI95 1995 pp 791800 11 D Barrington N Immerman H Straubing On uniformity NC 1 Journal Computer System Sciences 41 1990 274306 12 M BenAri Z Manna A Puneli The temporal logic branching time Proc 8th Symposium Principles Programming Languages 1981 pp 164176 13 P Bertoli A Cimatti M Pistore Strong cyclic planning partial observability ECAI 2006 pp 580584 14 P Bertoli M Pistore Planning extended goals partial observability S Zilberstein J Koehler S Koenig Eds ICAPS 2004 pp 270278 15 R Brooks A robust layered control mobile robot IEEE Journal Robotics Automation 2 1 1986 1423 16 T Bylander The computational complexity propositional strips planning Artiﬁcial Intelligence 69 1994 165204 17 S Ceri J Widom Deriving production rules constraint maintenance PMG Apers G Wiederhold Eds Proc 15th International Conference Very Large Data Bases VLDB90 1990 pp 566577 18 A Cimatti M Pistore M Roveri P Traverso Weak strong strong cyclic planning symbolic model checking Artiﬁcial Intelligence 147 12 2003 3584 19 E Clarke E Emerson Design synthesis synchronization skeletons branchingtime temporal logic Proc Workshop Logic Programs LNCS vol 131 Springer 1981 pp 5271 20 E Clarke E Emerson A Sistla Automatic veriﬁcation ﬁnitestate concurrent systems temporal logic speciﬁcations ACM Transactions Programming Languages Systems 8 2 1986 244263 21 M Daniele P Traverso M Vardi Strong cyclic planning revisited Proc 5th European Conference Planning ECP99 LNCSLNAI vol 1809 Springer 1999 pp 3548 22 E Dantsin T Eiter G Gottlob A Voronkov Complexity expressive power logic programming ACM Computing Surveys 33 3 2001 374425 23 G De Giacomo R Reiter M Soutchanski Execution monitoring highlevel robot programs Proc Sixth Conference Principles Knowledge Representation Reasoning KR98 1998 pp 453465 24 EW Dijkstra Selfstabilizing systems spite distributed control CACM 17 11 1974 644843 25 W Dowling JH Gallier Lineartime algorithms testing satisﬁability propositional Horn theories Journal Logic Programming 3 1984 267284 26 M Drummond Situation control rules Proc First International Conference Principles Knowledge Representation Reasoning KR89 1989 pp 103113 C Baral et al Artiﬁcial Intelligence 172 2008 14291469 1469 27 P Dunne M Laurence M Wooldridge Complexity results agent design problems Annals Mathematics Computing Teleinformatics 1 1 2003 1936 28 P Dunne M Wooldridge Optimistic disjunctive agent design problems C Castelfranchi Y Lespéranceand Eds Proc 7th International Work shop Intelligent Agents ATAL VII LNCS vol 1986 Springer 2001 pp 114 29 T Eiter W Faber N Leone G Pfeifer Declarative problemsolving DLV J Minker Ed LogicBased Artiﬁcial Intelligence Kluwer 2000 pp 79103 30 E Emerson Temporal modal logics J van Leeuwen Ed Handbook Theoretical Computer Science vol B Elsevier 1990 Chapter 16 31 K Erol V Subrahmanian D Nau Complexity decidability undecidability results domainindependent planning Artiﬁcial Intelligence 76 1995 7588 32 RE Fikes NJ Nilsson Strips A new approach application theorem proving problem solving Artiﬁcial Intelligence 2 34 1971 189208 33 M Gelfond V Lifschitz Classical negation logic programs disjunctive databases New Generation Computing 9 1991 365385 34 M Gelfond V Lifschitz Representing action extended logic programs Proc Joint International Conference Symposium Logic Programming JICSLP92 MIT Press 1992 pp 559573 35 M Ghallab D Nau P Traverso Automated PlanningTheory Practice Morgan Kaufmann 2004 36 ML Ginsberg Universal planning An universally bad idea AI Magazine 10 4 1989 4044 37 A Harding M Ryan PY Schobbens A new algorithm strategy synthesis ltl games N Halbwachs LD Zuck Eds TACAS LNCS vol 3440 Springer 2005 pp 477492 38 N Immerman Descriptive Complexity Springer 1999 39 RM Jensen MM Veloso MH Bowling OBDDbased optimistic strong cyclic adversarial planning Proc 6th European Conference Planning ECP01 2001 40 RM Jensen MM Veloso RE Bryant Fault tolerant planning Toward probabilistic uncertainty models symbolic nondeterministic planning S Zilberstein J Koehler S Koenig Eds Proc 14th International Conference Automated Planning Scheduling ICAPS 2004 2004 pp 335344 41 F Kabanza M Barbeau R StDenis Planning control rules reactive agents Artiﬁcial Intelligence 95 1 1997 67113 42 LP Kaelbling SJ Rosenschein Action planning embedded agents Maes 47 pp 3548 43 C Kuratowski Topology I Academic Press New York 1966 44 UD Lago M Pistore P Traverso Planning language extended goals AAAIIAAI 2002 pp 447454 45 N Leone G Pfeifer W Faber T Eiter G Gottlob S Perri F Scarcello The DLV knowledge representation reasoning ACM Transactions Computational Logic 7 3 2006 499562 46 ML Littman Probabilistic propositional planning Representations complexity Proc 14th National Conference Artiﬁcial Intelligence 9th Innovative Applications Artiﬁcial Intelligence Conference AAAIIAAI 1997 1997 pp 748754 47 P Maes Ed Designing Autonomous Agents Theory Practice Biology Engineering Back MIT Press 1990 48 Z Manna A Pnueli The Temporal Logic Reactive Concurrent Systems Speciﬁcation Springer 1992 49 Z Manna P Wolper Synthesis communicating processes temporal logic speciﬁcations ACM Transactions Programming Languages Systems 6 1 1984 6893 50 M Minoux LTUR A simpliﬁed linear time unit resolution Horn formulae implementation Information Processing Letters 29 1988 112 51 M Nakamura C Baral Invariance maintenance declarative objectives triggersa formal characterization active databases J Lloydet al Ed Proc First International Conference Computational Logic CL 2000 LNAI vol 1861 Springer 2000 pp 12101224 52 M Nakamura C Baral M Bjæreland Maintainability A weaker stabilizability like notion high level control Proc 17th National Conference Artiﬁcial Intelligence Twelfth Conference Innovative Applications Artiﬁcial Intelligence AAAIIAAI 2000 AAAI Press 2000 pp 6267 53 I Niemelä P Simons T Syrjänen Smodels A answer set programming C Baral M Truszczy nski Eds Proc 8th International Workshop NonMonotonic Reasoning NMR2000 2000 available httpxxxlanlgovabscsAI0003033 54 R Niyogi S Sarkar Logical speciﬁcation goals RK Ghosh D Misraand Eds Proc 3rd International Conference Information Technology CIT 2001 Tata McGrawHill 2000 pp 7782 55 C Ortiz A commonsense language reasoning causation rational action Artiﬁcial Intelligence 111 2 1999 73130 56 O Ozveren A Willsky P Antsaklis Stability stabilizability discrete event dynamic systems Journal ACM 38 3 1991 730752 57 CH Papadimitriou Computational Complexity AddisonWesley 1994 58 K Passino K Burgess Stability Analysis Discrete Event Systems John Wiley Sons 1998 59 N Piterman A Pnueli Y Saar Synthesis reactive1 designs VMCAI 2006 pp 364380 60 A Pnueli R Rosner On synthesis reactive module Proc 16th Annual ACM Symposium Principles Programming Languages POPL 1989 1989 pp 179190 61 P Ramadge W Wonham Modular feedback logic discrete event systems SIAM Journal Control Optimization 25 5 1987 12021217 62 P Ramadge W Wonham Supervisory control class discrete event process SIAM Journal Control Optimization 25 1 1987 206230 63 R Reiter Knowledge Action Logical Foundation Describing Implementing Dynamical Systems MIT Press 2001 64 J Rintanen Complexity planning partial observability S Zilberstein J Koehler S Koenig Eds Proc 14th International Conference Automated Planning Scheduling ICAPS 2004 2004 pp 345354 65 P Simons I Niemelä T Soininen Extending implementing stable model semantics Artiﬁcial Intelligence 138 2002 181234 66 E Sontag Stability stabilization Discontinuities effect disturbances F Clarke R Sternand Eds Proc NATO Advanced Study Institute Kluwer 1998 pp 551598 67 D Weld O Etzioni The ﬁrst law robotics arms Proc Twelfth National Conference Artiﬁcial Intelligence AAAI94 AAAI Press 1994 pp 10421047 68 J Widom S Ceri Eds Active Database Systems Triggers Rules For Advanced Database Processing Morgan Kaufmann 1996 69 M Wooldridge The computational complexity agent design problems Proc Fourth International Conference MultiAgent Systems ICMAS 2000 IEEE Press 2000 pp 341348