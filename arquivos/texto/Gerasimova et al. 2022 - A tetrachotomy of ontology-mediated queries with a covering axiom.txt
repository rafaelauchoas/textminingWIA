Artiﬁcial Intelligence 309 2022 103738 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint A tetrachotomy ontologymediated queries covering axiom Olga Gerasimova Stanislav Kikot b Agi Kurucz c Michael Zakharyaschev e HSE University Moscow Russia b Institute Information Transmission Problems Moscow Russia c Department Informatics Kings College London UK d Steklov Mathematical Institute Moscow Russia e Department Computer Science Information Systems Birkbeck University London UK Vladimir Podolskii da r t c l e n f o b s t r c t Article history Received 19 July 2020 Received revised form 4 May 2022 Accepted 5 May 2022 Available online 13 May 2022 Keywords Ontologymediated query Description logic Datalog Disjunctive datalog Firstorder rewritability Data complexity Our concern problem eﬃciently determining data complexity answering queries mediated description logic ontologies constructing optimal rewritings standard database queries Originated ontologybased data access datalog optimisation problem known computationally complex general explicit syntactic characterisations available In article aiming understand fundamental roots diﬃculty strip problem bare bones focus Boolean conjunctive queries mediated simple covering axiom stating class covered union classes We hand rudimentary ontologymediated queries called disjunctive sirups dsirups capture features diﬃculties general case For example answering dsirups cid2p 2 complete combined complexity AC0 L NL P coNP complete data complexity problem recognising FOrewritability dsirups 2ExpTimehard dsirups exponentialsize resolution proofs doubleexponentialsize positive existential FOrewritings singleexponentialsize nonrecursive datalog rewritings On hand prove partial suﬃcient necessary conditions FO symmetriclinear datalog rewritability dsirups Our main technical result complete transparent syntactic AC0NLPcoNP tetrachotomy dsirups disjoint covering classes pathshaped Boolean conjunctive query To obtain tetrachotomy develop new techniques establishing P coNP hardness answering nonHorn ontologymediated queries showing answered NL 2022 The Authors Published Elsevier BV This open access article CC BY license httpcreativecommonsorglicensesby40 Corresponding author V Podolskii michaeldcsbbkacuk M Zakharyaschev Email addresses ogerasimovahseru O Gerasimova staskikotxgmailcom S Kikot agikuruczkclacuk A Kurucz podolskiimirasru httpsdoiorg101016jartint2022103738 00043702 2022 The Authors Published Elsevier BV This open access article CC BY license httpcreativecommonsorglicensesby40 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 1 Introduction 11 The ultimate question The general research problem concerned article formulated follows given ontology mediated query OMQ short Q O q description logic ontology O conjunctive query q data complexity determine computational complexity answering Q input data instance A open rewritability reduce task ﬁnding certain answers Q input A task evaluating conventional called rewriting OMQ optimal data complexity directly A query Q cid3 cid3 world semantics possible database query Q Q Ontologybased data access Answering queries mediated description logic DL ontology known im portant reasoning problem knowledge representation early 1990s 1 The proliferation DLs applications 23 development DLunderpinned Web Ontology Language OWL1 especially paradigm ontologybased data access OBDA 46 proposed mid 2000s recently rebranded virtual knowledge graph VKG paradigm 7 theory practice answering ontologymediated queries OMQs hot research area lying crossroads Knowledge Representation Reasoning Semantic Technologies Semantic Web Knowledge Graphs Database Theory Technologies In nutshell idea underlying OBDA follows The users OBDA Mastro2 Ontop3 assume data want query given form directed graph nodes labelled concepts unary predicates classes edges labelled roles binary predicates propertieseven reality data physically stored different possibly heterogeneous data sourceshence moniker VKG The concept role labels come ontology designed domain expert familiar intended users hand know real data sources Apart providing user friendly vocabulary queries highlevel conceptual view data important role ontology enrich possibly incomplete data background knowledge To illustrate imagine interested life scientists like satisfy curiosity querying data available Web come universities databases publishing companies personal web pages social networks An ontology O scientists provided OBDA contain following axioms given readability DL concept inclusions ﬁrstorder sentences BritishScientist cid4 aﬃliatedWithUniversityInUK x BritishScientistx y aﬃliatedWithx y UniversityInUK y worksOnProject cid4 Scientist x y worksOnProjectx y Scientistx Scientist cid9 aﬃliatedWithUniversityInUK cid4 BritishScientist x Scientistx y aﬃliatedWithx y UniversityInUK y BritishScientistx BritishScientist cid4 Brexiteer cid10 Remainer x BritishScientistx Brexiteerx Remainerx Now ﬁnd example British scientists execute simple OMQ Q x O qx query 1 2 3 4 qx BritishScientistx mediated ontology O The OBDA expected return members concept BritishScientist extracted original datasets mappings database queries connecting data ontology vocabulary virtually populating concepts roles deduced data axioms O 3 It reasoning task makes OMQ answering nontrivial potentially intractable practice complexity theoretic point view 1 httpswwww3 org TR owl2 overview 2 httpswwwobdasystems com 3 httpsontopic biz 2 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 Uniform approach To ensure theoretical practical tractability OBDA paradigm presupposes users OMQs reformulatedor rewrittenby OBDA conventional database queries original data sources proved eﬃciently evaluated existing database management systems Whether rewriting possible query language naturally depends OMQ question One way uniformly guarantee desired rewritability delimit language OMQ ontologies queries Thus DLLite family description logics 5 OWL 2 QL proﬁle4 OWL 2 designed guarantee rewritability OMQs DLLite ontology conjunctive query CQ ﬁrstorder FO queries essentially SQL queries 8 In complexitytheoretic terms FOrewritability OMQ means answered LogTime uniform AC0 smallest complexity classes 9 In example axioms 1 2 allowed OWL 2 QL Various dialects tuplegenerating dependencies tgds aka datalog existential rules admit FOrewritability extend OWL 2 QL identiﬁed 1013 Any OMQ EL OWL 2 EL HornSHIQ ontology datalogrewritable 1417 answered Ppolynomial time size datausing datalog engines GraphDB5 LogicBlox6 RDFox7 Axioms 13 admitted EL syntax On hand OMQs ALC notational variant multimodal logic Kn 18 ontology CQ general coNPcomplete 1 regarded intractable suitable OBDA rewritten disjunctive datalog 1921 supported systems DLV8 clasp9 For example coNPcomplete OMQ 4 q1 CQ w x y z Brexiteerw hasCoAuthorw x Remainerx q1 hasCoAuthorx y Brexiteer y hasCoAuthor y z Remainerz representation q1 labelled graph It note making role hasCoAuthor symmetric example role inclusion axiom hasCoAuthor cid4 hasCoAuthor x y hasCoAuthorx y hasCoAuthor y x 5 obtain OMQ 4 5 q1 rewritable symmetric datalog query answered highly parallelisable algorithm complexity class L logarithmic space For reasons existing ontologies comply restrictions imposed standard languages OBDA Notable examples include largescale medical ontology SNOMED CT10 entirely EL oil gas NPD FactPages11 ontology Subsurface Exploration Ontology 22 fall outside OWL 2 QL whisker particular covering axioms like 4 typical conceptual modelling One way partially resolve issue compute approximation given ontology required ontology language interesting challenging reasoning problem 2326 references In practice noncomplying axioms simply omitted ontology hope answers OMQs lost An attempt ﬁgure case OMQs Subsurface Exploration Ontology geologists queries 22 starting point research led article Nonuniform approach An ideal alternative uniform approach OBDA discussed admit OMQs suﬃciently expressive language supply OBDA algorithm recognises data complexity given OMQ rewrites database query corresponding target language For example answering OMQ 4 q1 coNPcomplete shall later paper 4 q2 ontology CQ q2 shown picture Pcomplete datalogrewritable 4 q3 NL nondeterministic logarithmic space complete lineardatalogrewritable 4 q4 Lcomplete symmetricdatalogrewritable 4 q5 AC0 FOrewritable In picture F u stands Brexiteeru T u q1 F w R T x F y R T z R q2 T x T y S R F z 4 httpswwww3 org TR owl2 proﬁles 5 httpsgraphdb ontotext com 6 httpsdeveloperlogicblox com 7 httpswwwoxfordsemantic tech 8 httpwwwdlvsystem com 9 httpspotassco org clasp 10 httpsbioportal bioontologyorg ontologies SNOMEDCT 11 httpsfactpages npd 3 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 q3 T x T y R F z R q4 x S T y R F z q5 T x R y R F T z Remaineru Ru v hasCoAuthoru v Su v hasBossx y variables w x y z assumed existentially quantiﬁed Another example experiments NPD FactPages Subsurface Exploration ontologies testing OBDA industry 152227 Although ontologies contain covering axioms form A cid4 B 1 cid10 cid10 Bn allowed OWL 2 QL concrete queries provided endusers feel dangerous axioms FOrewritable Note experiments 28 showing rewriting nonHorn OMQs datalog signiﬁcantly improve eﬃciency answering means existing engines Is possible eﬃciently recognise data complexity answering given OMQ construct optimal rewrit ing The database community investigating questions context datalog optimisation 1980s Section 13 details references For families DLs complexitytheoretic analysis data complex ity problem launched Lutz Wolter 29 Bienvenu et al 30 Incidentally discovered close connection important rapidly growing area Computer Science AI constraint satisfaction problems CSPs PNPdichotomy conjectured Feder Vardi 31 recently established 3233 We brieﬂy survey current state art Section 13 Here suﬃces recognising FOrewritability ExpTime complete OMQs lightweight EL ontology 3435 2NExpTimecomplete OMQs fullﬂedged ALC ontology 36 In case problem complex universal algorithmic solution experi ments 37 demonstrated reallife atomic OMQs EL eﬃciently rewritten nonrecursive datalog ExpTime algorithm A practical rewritability problem started Motik 19 exploits datalog connection mentioned In nutshell idea follows OMQs Horn DL ontology rewritten datalog queries treated datalog optimisation techniques removing linearising recursion partial FOrewriting algorithms 38 NonHorn OMQs transformed possibly exponentialsize 20 disjunctive datalog queries partial datalog rewriting algorithms ones 28 applied It emphasised tractable datalog optimisation rewriting techniques complete In article propose approach ultimate question different bottomup direction In order wood trees isolate major sources diﬃculty data complexity rewritability syntactically simple highly nontrivial class OMQs Apart unearthing fundamental roots high complexity allow obtain explicit syntactic rewritability conditions complete classiﬁcations OMQs according data complexity rewritability type Note similar approaches taken analysing datalog programs CSPs Sections 12 13 12 Our contribution We investigate data complexity rewritability problems OMQs Q simple form dsirup Q cov A q cov A A cid4 F cid10 T q Boolean CQ unary predicates F T arbitrary binary predicates Our ultimate aim understand interplay covering axiom A cid4 F cid10 T structure q determines complexity rewritability properties Q By q data instances labelled directed graphs like picture formulate problem answering Q plain graphtheoretic terms Instance labelled directed graph digraph short A Problem decide digraph obtained labelling Anode A F T contains homomor phic image q case certain answer Q A yes By deﬁnition 39 coNP q ﬁxed existence homomorphism q labelling A checked polynomial time inspecting possible Aq maps q A In practice try solve problem resolutionbased prover Example 2 evaluating disjunctive datalog program 6 7 A require ﬁnding proofs exponential size general Theorem 3 The data complexity rewritability problems ask exists eﬃcient algorithmic solution given Q principle realised standard linear symmetric datalog FOquery evaluated input graphs A The OMQ Q cov A q equivalent monadic disjunctive datalog query T x F x Ax G q 4 6 7 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 nullary goal predicate G In 1980s trying understand boundedness FOrewritability linearisability linear datalogrewritability datalog queries database community introduced notion sirupstanding datalog query single recursive rule 4042which thought crucial understanding datalog recursion optimising datalog programs 43 Problem 4210 Our OMQs Q disjunctive datalog queries 6 7 Gwhich henceforth referred monadic disjunctive sirups simply dsirupsplay fundamental role understanding OMQs expressive ontologies monadic disjunctive datalog queries Looking pretty trivial syntactically dsirups form sophisticated class OMQs For example deciding FO rewritability dsirups equivalent monadic datalog sirups turns 2ExpTime hard 44as complex deciding program boundedness arbitrary monadic datalog programs 4546 Interestingly sources unexpectedly high complexity twin F T labels nodes CQs like q5 We eliminate source imposing standard disjointness constraint F cid9 T cid4 F x T x datalog parlance ontologies conceptual modelling Thus arrive ddsirups form ddsirup Q cov A q cov A A cid4 F cid10 T F cid9 T cid4 The complexity rewritability d ddsirups depend structure CQs q suggests research programme classifying ddsirups type graph underlying qdirected path tree undirected variants etcand characterising data complexity rewritability OMQs resulting classes Thus context datalog sirups Afrati Papadimitriou 47 gave complete characterisation binary chain sirups computable NC parallelisable Actually according 47 Kanellakis Papadimitriou investigated case unary sirups progress complete characterization Unfortunately work published12 As shown later article 44 unary datalog sirups closely connected dsirups The main achievement article complete characterisation ddsirups pathshaped CQ like q1q3 q5 Syntactically obtained characterisation tetrachotomy transparent easily checkable ddsirup Q cov A q pathshaped CQ q AC0 Q FOrewritable answered AC0 iff q contains F T twin F nodes T nodes NL Q lineardatalogrewritable answering NLcomplete q periodic CQ single F node single T node P Q datalogrewritable answering Pcomplete q aperiodic CQ single F T node CONP answering Q coNPcomplete q F nodes T nodes Assuming NL cid14 P cid14 coNP replaced iff From technical point view establish ﬁrst complete syntactic characterisation OMQs disjunctive axioms require adaptation known methods description logic 3435 datalog 4546 developing novel techniques proving P especially coNPhardness As cruel exercise reader tempted consider ddsirup q1 permute F s T s The known techniques encoding NPcomplete problems 22CNF graph A capable reasoning bar binary 3colouring terms OMQ answering applicable case cov case distinction q1 binary relation To compare ﬁrst coNPhard dsirup Schaerf 1 ﬁve roles encode clauses literals 22CNFs An harder problem ﬁnd uniﬁed construction arbitrary pathshaped CQs different types require different treatment In remainder section brieﬂy review related work Section 2 contains necessary Structure article background deﬁnitions It shows reduction mutilated chessboard problem 4849 answering dsirups resolutionbased provers requires ﬁnding proofs exponential size general In Section 3 initial scan battleground obtain relatively simple complexity rewritability results arbitrary necessarily pathshaped d ddsirups First reduction SAT answering ddsirups cid2p 2 complete combined complexity size q A harder answering DLLite EL OMQs 5015 NP cid2p 2 NP PSpace This result improvement cid2p 2 hardness answering OMQs Schema org ontology 51 expressive ddsirups Then start classifying dsirups terms occurrences F T CQs q Those occurrences solitary F like q5 solitary T readily seen FOrewritable All twinless dsirups shown Lhard certain symmetric dsirups solitary F solitary T rewritable symmetric datalog Lcomplete Dsirups single solitary F single solitary T possibly twins shown rewritable monadic datalog queries 12 httpsen wikipedia org wiki Paris _Kanellakis 5 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 follows 28 This observation allows use datalog expansions 52 called cactuses context automata theoretic techniques 45 analyse FO lineardatalogrewritability corresponding dsirups In 44 criterion FOrewritability terms cactuses prove deciding FOrewritability dsirups single solitary F T monadic datalog sirups 2ExpTimecomplete Here nonrecursive datalog positive existential UCQrewritings dsirups single double tripleexponential size worst case respectively As far aware known semantic syntactic criterion distinguishing datalog programs NL P Lutz Sabellek 3435 gave nice semantic characterisation OMQs EL ontology In Section 4 combine ideas automatatheoretic technique Cosmadakis et al 45 prove useful graphtheoretic suﬃcient condition dsirups lineardatalogrewritable NL Note dsirup CQ q ditree single solitary F T root rewritten atomic OMQ EL ExpTimecomplete trichotomy 34 applicable Finally Sections 5 6 obtain tetrachotomy pathshaped ddsirups discussed Items AC0 NL upper bound P follow previous sections By far hardest tetrachotomy establishing P coNPhardness To prove assemble AND ORgates copies given aperiodic CQ use gates construct ABoxes compute arbitrary monotone Boolean circuits known Pcomplete The structure gates circuits uniform type aperiodicity In proof coNPhardness building 3CNFs copies given CQ q uniform parts construction subtly depend order distances F T nodes q We aware remotely similar methods literature believe novel bike technique showing coNPhardness classes OMQs It note coNPhardness result tetrachotomy implies completeness datalog rewriting algorithm 28 pathshaped ddsirups In Section 7 summarise obtained results formulate open problems future research An extended abstract 53 results article presented 17th International Con ference Principles Knowledge Representation Reasoning 13 Related work There big waves research related data complexity rewritability ontologymediated queries The ﬁrst started mid 1980s database community working optimisation paralleli sation datalog programs hoped intelligent compilers 54405559 surveys 4360 references One fundamental problems considered decide depth recursion quired evaluate given datalog query bounded independently input data implies FOrewritability datalog query Boundedness shown decidable P classes linear programs 6154 NP complete linear monadic dyadic single rule programs 41 PSpacecomplete linear monadic programs 4562 2ExpTimecomplete arbitrary monadic programs 4546 63 On hand boundedness linear datalog queries binary predicates ternary linear datalog queries single recursive rule proved undecidable 6465 semantic properties datalog programs including linearisability L NC 66 The computational complexity evaluating datalog sirups arbitrary arity descriptive complexity studied 42 The second wave largely caused apparent success story DLunderpinned Web Ontology Language OWL OBDA paradigm theory practice On hand mentioned earlier large families DLs guarantee FOrewritability 567 DLLitefamily datalogrewritability 6870 ELfamily 1420 Horn DLfamily designed investigated Other types rulebased languages FOrewritability identiﬁed 71721113 On hand methods rewriting expressive OMQs disjunctive datalog suggested implemented 161773287475 For example PAGOdA combines datalog reasoner RDFox OWL 2 reasoner HermiT 24 A partial FOrewriting algorithm OMQs ELU ontology allowing disjunction EL atomic query suggested 38 sound complete necessarily terminating algorithm OMQs existential rules 13 Complexitytheoretic investigations data complexity rewritability problems DL OMQs fall categories depending ontology language Horn FOrewritability OMQs ontology given Horn DL EL HornSHIF studied 763777 provided semantic characterisations estab lished automatatheoretic techniques complexity deciding FOrewritability ranging ExpTime NExpTime 2ExpTime A complete characterisation OMQs ELontology obtained 3435 establishing AC0NLP data complexity trichotomy corresponds FOlineardatalogdatalogrewritability trichotomy Deciding trichotomy shown ExpTimecomplete FOrewritability OMQs ontology set frontierguarded existential rules investigated 78 For nonHorn ontology languages allowing disjunctive axioms crucial step understanding data complexity rewritability discovery 3036 connection OMQs nonuniform constraint satisfaction prob lems CSPs ﬁxed template MMSNP 31 It deciding FO datalogrewritability OMQs ontology DL ALC SHIU atomic query NExpTimecomplete The FederVardi 6 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 dichotomy CSPs 3233 implies PcoNP dichotomy OMQs decidable NExpTime For monadic disjunc tive datalog OMQs ALCI ontology ALC inverse roles CQ deciding FOrewritability rises 2NExpTimecomplete deciding OMQ rewritable monadic datalog 2NExpTime 3NExpTime 7936 Deciding FOrewritability OMQs Schemaorg13 ontology admits inclusions concept role names covering axioms role domains ranges union CQs UCQ PSpacehard acyclic UCQs NExpTime 51 The data complexity rewritability OMQs ontology given guarded fragment ﬁrstorder logic considered 80 Despite discovery general algebraic automata graphtheoretic semantic characterisations data com plexity rewritabilitywhich usually hard checkthere explicit easily checkable possibly partial applicable limited OMQ families suﬃcient andor necessary conditions let complete classiﬁcations Notable examples include nonlinearisability conditions chain datalog queries 8183 markability condition datalog rewritability disjunctive datalog programs DL ontologies 28 explicit NCPdichotomy datalog chain sirups 47 Classiﬁcations dichotomies CSPs intensively investigated Schaefers classiﬁcation theorem 84 85883233 references The natural idea 30 translating OMQs CSPs algorithms techniques developed checking complexity looks hardly viable general instance reported 89 Polyanna program 90 designed check tractability CSPs failed recognise coNPhardness simple OMQ obtained swapping F T labels 4 q1 CSP translation unavoidably exponential 2 Preliminaries Using standard description logic syntax semantics 3 consider ontologymediated queries OMQs form Q O q O ontologies cov A A cid4 F cid10 T cov A A cid4 F cid10 T F cid9 T cid4 q Boolean conjunctive query CQ short FOsentence q x ϕx ϕ conjunction constant functionfree atoms variables x We think q set atoms In context paper CQs contain unary predicates F T arbitrary binary predicates As previous section OMQs Q covA q called dsirups Q cov Occasionally set A cid15 case A cid4 F cid10 T total covering axiom F cid10 T It noted axiom domain dependent 8 regarded unsafe disallowed disjunctive datalog In general answering dsirup cov A q harder answering corresponding OMQ covcid15 q shown Example 20 We consider OMQs covcid15 q examples proving lower complexity bounds A q ddsirups An ABox data instance A ﬁnite set ground atoms unary binary predicates We denote indA set constants individuals A An interpretation structure form I cid4I I domain cid4I cid14 constant cid15I cid4I interpretation function I unary predicate P I cid4I cid4I binary P The truthrelation I q CQ q deﬁned usual ﬁrstorder logic The P I model A P A implies interpretation I model O A I P P b A implies O cov A F I F I b I P I T I I cid4I I cid4I I P I T The certain answer OMQ Q O q ABox A yes I q models I O Ain case write O A qand A model O A minimal undecided Aindividual Aa A F T exactly holds Clearly O A q iff I q minimal model I O A So model means minimal model I F I T I I I I It convenient regard CQs ABoxes interpretations digraphs labelled edges partially labelled nodes F T CQs F T A ABoxes interpretations It straightforward truthrelation I q equivalent existence digraph homomorphism h q I preserving labels nodes edges Without loss generality assume CQs connected undirected graphs This graphtheoretic perspective allows consider special classes CQs treeshaped CQs underlying undirected graph tree ditreeshaped CQs underlying directed graph tree edges pointing away root dagshaped CQs contain directed cycles In particular pathshaped CQ q path CQ short mean simple directed path edges labelled binary predicate In words binary atoms q form sequence R1x1 x2 R2x2 x3 Rnxn xn1 xi pairwise distinct variables q R necessarily dis tinct We illustrate reasoning required ﬁnd certain answer dsirup ABox intuitive formal levels Our ﬁrst example shows unsurprisingly answering dsirups plain proof cases Example 1 Consider OMQ Q covcid15 q A cid15 path CQ q shown picture 13 httpsschema org 7 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 T T F S R By analysing possible cases b F I T readily contains q subgraph certain answer Q ABox yes arbitrary model I covcid15 ABox I b S R T R F S T T T R S Indeed I F If b case b I I T I I I F I q homomorphically embeddable SR path lefthand I Otherwise q homomorphically embeddable SR path righthand I In remaining I T homomorphism q SR path I Such proofs given formal resolution refutations derivations clause clausal logic Example 2 The certain answer dsirup Q cov A q ABox A yes iff following set S Q A clauses unsatisﬁable cid2 S Q A A y F y T y cid3 cid4 P x A P xq For ddsirup Q cov A q set S Q A contains clause F z T z In words certain answer Q A yes iff derivation clause S Q A classical ﬁrstorder resolution calculus 91 By grounding S Q A uniformly substituting individuals indA variables x y z ﬁrst clauses S Q A obtain set S Q A essentially propositional clauses S Q A polynomial A Again certain answer Q A yes iff derivation clause S Q A propositional resolution We general derivations exponential size A Theorem 3 There exist CQ q sequence An n 0 ABoxes An polynomial n resolution refutation S Q An S Q An Q cov A q size 2cid5n Proof We mutilated chessboard problem solved answering dsirup Q certain ABoxes An The problem follows given chessboard size 2n 2n n 0 white corner squares removed prove covered domino tiles rectangles squares This problem encoded set propositional clauses size linear n 4849 resolution proof size 2cid5n 48 Theorem 21 We encode problem set S Q An dsirup Q cov A q ABox An Since encoding 48 locally translatable view 49 Proposition 34 resolution refutation S Q An S Q An size 2cid5n Our CQ q shown lefthand Fig 1 The mutilated 2n 2n chessboard turned ABox An replacing squares pattern shown middle Fig 1 The encodings different squares connected contacts depicted nodes Each contacts labelled A F depending inbetween squares boundary board righthand Fig 1 All binary edges q An assumed labelled R Labels w x y z pointers parts q An We model I cov A An covering exactly contact encoding square T Covering models clearly onetoone correspondence dominocoverings contact T iff squares covered domino We model I cov A An covering iff I cid14 q This implies correctness encoding 2n 2n mutilated chessboard covered dominos iff answer Q An yes exist resolution refutations S Q An S Q An If I covering contacts square labelled F Thus node x q homomorphically mapped node w encoding square y mapped z But T nodes q mapped different contacts square contrary fact covering models contact labelled T Therefore q I homomorphism If I covering square contacts labelled T mapping x z encoding square obtain q I homomorphism And square contacts labelled T obtain q I homomorphism mapping x w y z cid2 I I 8 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 q F x F F T y F T An AF T AF cid2 z AF F F F F F A A A A A A A A A F F F A A F T AF F w F F Fig 1 Encoding mutilated chessboard problem Scov A qAn F A A F A A F F F A A F F A A A F Our concern remainder article combined data complexity deciding given ddsirup Q O q ABox A O A q In case q A regarded input q ﬁxed It clear cid2p upper bound combined complexity problem 2 amounts checking model I O A exists homomorphism q I NP complete For data complexity q ﬁxed checking existence homomorphism q I P problem coNP coNPNP We interested types rewritability ddsirups An OMQ Q O q called FOrewritable FOsentence cid6 O A q iff cid6 true A given FOstructure 9 In terms circuit complexity FOrewritability equivalent answering Q logtimeuniform AC0 9 Recall 8 datalog program cid2 ﬁnite set rules form x γ0 γ1 γm γi constant functionfree atom Q y y x As usual omit x The atom γ0 head rule γ1 γm body All variables head occur body The predicates heads rules called IDB predicates rest EDB predicates The arity cid2 maximum arity IDB predicates 1ary cid2 called monadic A datalog query article takes form cid2 G 0ary goal atom G The answer cid2 G ABox A yes G true structure cid2A obtained closing A rules cid2 case write cid2 A G We cid2 G datalogrewriting OMQ Q O q case O A q iff cid2 A G ABox A containing EDB predicates cid2 If Q datalogrewritable answered P data complexity 60 If rewriting Q cid2 G linear program cid2 having IDB predicate body rules Q answered NL nondeterministic logarithmic space The NL upper bound holds datalog queries linearstratiﬁed program deﬁned follows A stratiﬁed program 8 sequence cid2 cid20 cid2n datalog programs called strata cid2 predicate cid2 occur head rule stratum cid2i occur body rule strata cid2 j j If addition body rule cid2 contains occurrence head predicate stratum cid2 called linearstratiﬁed Every linearstratiﬁed program converted equivalent linear datalog program 83 datalog queries linearstratiﬁed program answered NL data complexity A linear program cid2 symmetric recursive rule Ix J y Ez cid2 goal rules J IDB predicate Ez conjunction EDBs rule symmetric counterpart J y Ix Ez rule cid2 It known 92 symmetric programs evaluated L deterministic logarithmic space data complexity Thus Q rewritable symmetric datalog query answered L The complexity classes deal article form chain AC0 cid2 L NL P coNP cid2p 2 inclusions strict major open problem complexity theory The PNP dichotomy CSPs 32 33 reductions 3036 imply ddsirup P coNPcomplete However far know moment established dichotomies OMQs disjunctive axioms On hand mentioned OMQ answering AC0 equivalent FOrewritability OMQ answering L NL P implies symmetricdatalogrewritability respectively lineardatalog datalogrewritability remains open 3 Initial observations In section obtain number relatively simple complexity rewritability results applicable arbi trary necessarily path d ddsirups 9 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 31 Combined complexity Our ﬁrst result pushes limit 51 Theorem 5 according answering OMQs Schema org ontology 2 complete combined complexity hardness proof theorem uses ontology enumeration deﬁnition cid2p E 0 1 additional concept names unary predicates available case Theorem 4 Answering dsirups covA q ddsirups cov A q cid2p 2 complete combined complexity ii Answering d ddsirups treeshaped CQ q coNPcomplete combined complexity Proof As mentioned Section 2 deciding O A q given ddsirup Q O q ABox A coNP Turing machine checking models I O A NPoracle checking existence homomorphism h q I treeshaped q Poracle 93 references The lower bound ii follows Theorem 27 For prove reduction cid2p 2 complete 3SAT 94 We remind reader propositional formula ψx y tuples x y propositional variables 3CNF conjunction clauses form cid21 cid22 cid23 cid2i literal propositional variable negation thereof The decision problem 3SAT asks fully quantiﬁed propositional formula ϕ x y ψx y true given 3CNF ψ We assume clause contains variable Denote qϕ CQ clause c cid21 cid22 cid23 ψ contains atoms Rc 1 2 3 uc xc x x occurs cid2i case qϕ contains T xc cid2i x F xc cid2i x For example clauses c1 x1 x2 y1 c2 y1 x2 y2 contribute following atoms qϕ y y y occurs cid2i uc zc uc T F xc1 1 xc1 2 T xc2 2 Rc1 1 zc1 y1 zc2 Rc2 2 Rc1 3 Rc2 1 Rc1 2 Rc2 3 y2 y Aϕ contains atoms Aa For O cov A ABox Aϕ deﬁned follows For x x individuals x y y individuals b F x x x x For c cid21 cid22 cid23 deﬁne set E c triples bT x F individuals e1 e2 e3 E c iff 1 2 3 ei x x occurs cid2i ii 1 2 3 ei x ei bν b F y assignment y ν makes cid2i true Now c e1 e2 e3 E c fresh individual dc e1e2e3the centre pair cid6 cid5 e1e2e3 ei 1 2 3 Aϕ To illustrate c1 x1 x2 y1 set E c1 c e1 e2 e3 contains triples form y y occurs cid2i iii 1 2 3 ei add atoms Rc dc μ2 x2 bν y1 gives following fragment Aϕ x T μ1 x1 y bT y b F y1 x x1 x2 x y A x1 F T x1 Rc1 1 Rc1 1 A x2 Rc1 1 Rc1 1 Rc1 2 dc1 x1 x2 b F y1 Rc1 1 dc1 Rc1 2 x1 x2 b F y1 Rc1 2 Rc1 1 dc1 x1 x2 b F y1 Rc1 1 Rc1 2 dc1 F T x2 Rc1 2 Rc1 2 x1 x2 bT y1 dc1 x1 x2 bT y1 Rc1 2 dc1 x1 x2 bT y1 dc1 x1 x2 bT y1 Rc1 3 Rc1 3 Rc1 3 Rc1 3 Rc1 3 Rc1 3 Rc1 3 b F y1 bT y1 For O cov x aT A aF deﬁnition E c icid3 x add atoms F aF x aT x The number atoms Aϕ polynomial size ϕ 1 2 3 ei x instead x aF x x occurs cid2i x T aT x instead F x T x replace item 10 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 Claim 41 Suppose x F T assignment Aa ϕ Aϕ T x ax F x x There exists assignment b y F T makes ψax b y true iff Aa ϕ x ax T x x F qϕ b b y y 1 ec 2 ec ec x labelled F Aa 3 E c Then deﬁne map h taking hzc centre follows We let ec cid5 c ec Case covA For clause c cid21 cid22 cid23 ψ 1 2 3 deﬁne ec x x x occurs cid2i makes cid2i false iii ec Proof Suppose b ψax b y true We need homomorphism h qϕ Aa ϕ x x x y y occurs occurs cid2i makes cid2i true ii ec cid6 cid2i As ψax b y true ec 2 ec 1 ec 3 It follows construction h welldeﬁned homomorphism qϕ Aϕ respect huc binary atoms We preserves unary atoms Indeed c x x occurring literal cid2i c cases 1 If xc labelled T qϕ cid2i x So makes cid2i true ec x labelled T Aa ϕ 2 If xc labelled F qϕ cid2i x So makes cid2i true ec x labelled T F Aa ϕ Case cov aF x cid2i x x x ax F iicid3cid3 x cid2i x x x ax T Again claim h deﬁned preserves unary atoms Indeed ec c x x occurring literal cid2i c cases 1 If xc labelled T qϕ cid2i x So makes cid2i true ec x labelled T Aa ϕ And makes cid2i false ec x labelled T Aa ϕ 2 If xc labelled F qϕ cid2i x So makes cid2i true ec ϕ And makes cid2i false ec x labelled T F Aa ϕ And makes cid2i false ec ϕ And makes cid2i false ec replace ii iicid3 A In deﬁnition ec ϕ Then y y h y bν y ν F T We set b y ν We claim ψax b y true Indeed clause c cid21 cid22 cid23 ψ e1 e2 e3 E c h maps x 1 2 3 e1e2e3 If e1 e2 e3 E c ei contribution c qϕ star centre dc x Aa x x label ϕ ax As h homomorphism label xc qϕ ax makes c true deﬁnition qϕ And e1 e2 e3 E c ei b 1 2 3 y y b y making cid2i true c clearly true cid2 x labelled F Aa Suppose h qϕ Aa x labelled F Aa ϕ aT aT aF b y y ec Finally prove ϕ satisﬁable iff O Aϕ qϕ iff I qϕ model I O Aϕ Given I deﬁne Then I AaI I ϕ ϕ model O Aϕ assignment assignment aI x F T taking aIx T Claim 41 The implication follows Claim 41 Aa x F T cid2 aIx F F T x x I 32 Data complexity AC0 L From focus data complexity answering dsirups cov A q ddsirups cov A q We start classi fying ddsirups terms occurrences F T CQs q Atoms F x T x q variable x referred F T twins q If q contain F T twins twinless similarly ABoxes By solitary F T mean nontwin F respectively T node Observe answering covA q easier answering cov A q If given ABox A contains F T twins cov A A q model cov A A q Also A A cov A A q cid5 If q contains F T twins x A q In general rewriting cov A q converted rewriting cov A q language For example cid2 G symmetriclinear datalog rewriting covA q cid2 F x T x G symmetriclinear datalog rewriting cov twinless ABox A cid6 F x T x FOrewriting cov cov 8 iff Aiming identify FOrewritable ddsirups consider ﬁrst CQs solitary F solitary T calling 0CQs Queries type common asking covering predicates undergraduate students symbolic AI courses postgraduate ones provided students undergraduate postgraduate The following theorem establishes complexity dichotomy 0CQs non0CQs contain occurrences covering predicates undergraduate postgraduate students Colleges University Challenge team A q Theorem 5 If q 0CQ covA q cov A q answered AC0 q FOrewriting ii If q twinless contains solitary F solitary T answering covcid15 q cov covA q cov A q Lhard 11 cid15 q O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 A We O A q iff A q q FOrewriting O q Proof Let O cov A cov Suppose A cid14 q q solitary F case similar Let Acid3 result adding label F undecided Anode A Clearly Acid3 model O A Acid3 cid14 q trivial ii The proof FOreduction Lcomplete reachability problem undirected graphs Denote q cid3 obtained gluing T nodes gluing F nodes q Thus q cid3 T x F y x single F node y Clearly homomorphism h q q Let q cid3cid3 q cid3 CQ contains single T node cid3 q Suppose G V E graph s t V We regard G directed graph u v E iff v u E cid3cid3 e cid3cid3 e node x renamed u y v nodes z fresh copy ze Then AG comprises cid3cid3 e e E atoms T s F t We path s t G s G t symbols iff u v V Construct twinless ABox AG G following way Replace edge e u v E copy q cid3cid3 q q covcid15 AG q iff cov cid15 AG q cf 8 Suppose path s v0 vn t G ei vi vi1 E n Consider arbitrary model I As covcid15 AG Since I covcid15 T s F t AG ﬁnd n vi T cid3cid3 q ei isomorphic copy q Suppose s cid14G t Then construction t reachable s AG undirected path set nodes AG reachable s undirected I Deﬁne model I cov I path F nodes Since q connected contains T F follows I cid14 q cid2 complement Clearly connected component AG undirected graph contains T cid15 AG taking T obtain I q I q vi1 F F I I I I cid3cid3 cid3cid3 As AC0 cid2 L x F x T x FOrewriting cov necessary criterion FOrewritability ddsirups A q q contains twin Theorem 5 gives suﬃcient Corollary 6 A ddsirup Q cov A q answered AC0 iff q 0CQ contains twin Characterising FOrewritable dsirups CQ containing twins turns harder problem discussed Section 34 Example 7 Meanwhile reader invited dsirups CQs FOrewritable Example 14 Note CQs minimal equivalent proper subCQs F T T F F T T F T F R R R S S S R R R R R The lower bound result Theorem 5 ii complemented following simple suﬃcient condition To formulate require nonBoolean CQs qx apart existentially quantiﬁed variables contain free variables x cid3x y symmetric ABox A b indA called answer distinguished variables Such CQ q A q cid3b A regarded FOstructure usual ﬁrstorder truth relation cid3a b iff A q Theorem 8 Let O cov A cov A let q Boolean CQ equivalent cid5 cid3 x y F x q cid3 1x q cid3 1x q cid3x y q CQs q disjoint x y common variables q answered L x y q cid3 2 y contain solitary T F b q cid6 cid3 2 y T y cid3 cid3x y symmetric c q 2 y cid3x y Then O q rewritable symmetric datalog program cid3 1x q Proof Suppose O cov A We claim O A q iff exist n 1 v 0 v 1 vn indA S1 F v 0 Av 1 Avn1 T vn A S2 A q S3 A q S4 A q cid3v v i1 0 n cid3 1v 0 n cid3 2v 1 n I Indeed suppose v 0 v 1 vn indA S1S4 hold Consider model I O A By S1 Then S2S4 guarantee I q Conversely suppose O A q n v F A ABox A For P F T A let P cid3 cid3 cid3a b q 1a q j0 F j F cid5 cid6 cid7 j cid3 A j T j1 F j A A indA P A Deﬁne inductively sets F j F cid3 2b F j F j1 A By assumption homomorphism h q I Thus hx F j h y F cid3 j j 0 setting F 0 F cid7 cid3 j Let I model O A F b A q A I T v i1 T A F I I 12 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 A j Then h y T n 1 If j 0 hx A cid3vn2 vn1 q q A F cid3 2vn1 By iterating process obtain v 0 v 1 vn indA required h y F j1 contrary h y T cid3 j1 vn2 F j1 A q Now let vn1 hx vn h y If j 0 cid3 1vn2 It remains observe checking v 0 v 1 vn indA S1S4 hold I following symmetric datalog program Bx Ax q cid3 1x q cid3 2x G q G F x q P x Bx q P x Bx q x y P y cid3 cid3 1x q cid3 x y q cid3 2 y T y x y P y B y cid3 symmetry q counterpart If O cov cid3x y recursive rule P x Bx q cid3x y P y B y equivalent symmetric A add nonrecursive rule G F x T x program cid2 Example 9 By Theorems 8 5 ii dsirup covcid15 q q shown Lcomplete F T R S S Q Q 33 Datalog rewritability dsirups 1CQ In section introduce technical tool datalog rewritability ddsirups CQ contains exactly solitary F solitary T exactly solitary T solitary F We refer CQs 1CQs The tool adaptation known disjunctive datalog technique expansions 544552 We use tool observe ddsirup 1CQ rewritten simple datalog querynearly sirup sense 4041 answered P Note general markability technique tracing dependencies disjunctive predicates program rules rewriting disjunctive datalog programs datalog developed 28 In Section 34 adapt datalog expansion technique characterise FOrewritability datalog queries semantically Throughout section assume q 1CQ F x T y1 T yn solitary occurrences F T q As let O cov A cov A For ddsirup Q O q deﬁne monadic having unary IDB predicates datalog program cid2 Q nullary goal G rules G F x q cid3 P y1 P yn P x T x P x Ax q cid3 P y1 P yn 9 10 11 G F x T x 12 cid3 q F x T y1 T yn P fresh predicate symbol occurs ABoxes Thus body q rule 11 obtained q replacing F x Ax T yi P yi If O covA rule 12 omitted We deﬁne induction class K Q ABoxes called cactuses Q We start setting K Q q q ABox recursively apply K Q following budding rule bud T y C K Q solitary T y add K Q ABox obtained replacing T y C set q F x Ax x renamed y variables given fresh names It straightforward structural induction O C q C K Q 13 For C K Q refer copies s maximal subsets q comprising C segments The skeleton Cs C ditree nodes segments s C edges s scid3 mean scid3 attached s budding The depth s C number edges branch root Cs s The depth C maximum depth segments Example 10 In picture cactus C2 obtained applying bud 1CQ q twice Its skeleton Cs segments s0 s1 s2 shown righthand picture 2 13 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 q T y2 S T y1 R F x T s2 T S R C2 A y2 T S S s0 A y1 R F x R T s1 Cs 2 s0 s1 s2 Theorem 11 For ddsirup Q O q 1CQ q ABox A following conditions equivalent O A q ii cid2 Q A G iii exists homomorphism h C A C K Q O cov A A contains F T twin Proof We implications ii iii I A A contains node labelled T F G holds closure cid2 Q A A ii If O cov cid2 Q rule 12 In case deﬁne model I based A labelling undecided Anode T P I holds cid2 Q A F As I model O A homomorphism h q I Then h yi T holds cid2 Q A n rule 10 deﬁnition I We claim hx F node P cid2 Q A G holds cid2 Q A rule 9 Indeed hx F deﬁnition I hx Anode P node cid2 Q A contrary rule 11 cid6 cid5 h yi n If ya ii iii Suppose O covA A contain node labelled T F Then rule 12 cid2 Q We deﬁne inductively applications rule 11 derivation G cactus C K Q homomorphism h C A To begin objects xa ya n rule 9 triggered Thus xa F node cid2 Q A F node A Take function h0 q A preserves binary predicates h0x xa T node A n h h0 required homomorphism q K Q h0 yi ya A If ya Anode n Let C cactus obtained A Also xb ya q budding yi We extend h0 function h1 C A preserves binary predicates h1 ys j yb j T node A j n h h1 required homomorphism T nodes ys C K Q A Otherwise bud C repeat argument As derivation G A cid2 Q ﬁnite sooner later procedure stops cactus homomorphism T node A ya yb P node cid2 Q A obtained rule 11 ya n rule 11 triggered xb yb j new segment s If yb A A contains node labelled T F O A q obviously holds Otherwise iii If O cov O C pulling I homomorphism h I Thus composition g h By 13 homomorphism g q I arbitrary model I O A We deﬁne model I node x C x A q I homomorphism required cid2 iff hx A 1 yb 1 yb 1 ya I j Corollary 12 Any ddsirup O q 1CQ q datalogrewritable answered P As mentioned introduction problems FOrewritability aka boundedness datalog literature lineardatalogrewritability aka linearisability datalog queries thoroughly investigated 1980s In Sections 34 4 discuss questions ddsirups 1CQ 34 Deciding FOrewritability d ddsirups 1CQ A key understanding FOrewritability d ddsirups 1CQ following semantic criterion wellknown datalog setting 5445 Theorem 13 A ddsirup Q O q 1CQ q FOrewritable iff exists d ω cactus C K Q contains homomorphic image cactus C K Q depth d case disjunction cactuses depth d regarded Boolean CQs FOrewriting Q qn qi CQs Treating Proof By 30 Proposition 59 Q FOrewriting form q1 q Theorem 11 homomorphism Ci K Q qi qi ABoxes obviously O qi Now let d maximum depths Ci Consider C K Q depth d Then homomorphisms Ci qi C 1 n required Given d ω cactuses C1 Cn depth d isomorphism Now consider Ci CQ Then C1 Cn FOrewriting Q Indeed O A q homomorphisms Ci C A C Theorem 11 cid2 14 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 Example 14 Let Q 1 dsirup ﬁrst CQ Example 7 It hard verify cactus Q 1 contains homomorphic image CQ FOrewriting Q 1 Now let Q 2 dsirup second CQ Example 7 Let Ck cactus obtained applying bud ktimes original cactus C0 isomorphic given CQ There homomorphisms h C1 Ck k 2 Q 2 rewritable C0 C1 As follows 45 considered arbitrary monadic datalog queries checking criterion Theorem 13 2ExpTime A matching lower bound monadic datalog queries multiple recursive rules estab lished 46 It recently shown deciding FOrewritability monadic datalog sirups form 10 11 P x dsirups 1CQ 2ExpTimehard 44 Thus obtain Theorem 15 453644 Deciding FOrewritability dsirups 2NExpTime Deciding FOrewritability dsirups 1CQ 2ExpTimecomplete It follows deciding FOrewritability CQs mediated Schema org DLLitebool 67 ontology 2NExpTime 2ExpTimehard The exact complexity deciding FOrewritability dsirups 2NExpTime 2ExpTime remains open problem An important issue OBDA datalog optimisation succinctness problem FOrewritings 9550 It known FOrewritable dsirup polynomialsize FOrewriting However case UCQ PE NDLrewritings standard OBDA systems We remind reader 50 details references UCQrewriting takes form disjunction union CQs positive existential PE rewriting built atoms arbitrary way A nonrecursive datalog NDL rewriting datalog query cid2 G dependency digraph cid2 acyclic predicate P depends predicate P cid2 cid2 clause P head P body cid3 cid3 Theorem 16 There sequence FOrewritable dsirups Q n NDLrewritings Q n triple double single exponential size n respectively cov A qn polynomial size n 0 UCQ PE Proof Consider alternating Turing machine ATM M n works follows input length n Its tape size exponential n counter 0 22n The tape extra cells b M n begins state writing 0 1 cell alternative branches computation space Then M n continues state writing 0 1 cell b alternative branches computation space If bits b given branch tree distinct Mn enters accepting state Otherwise counter increased 1 ATM repeats previous steps If counter exceeds 22n Mn enters rejecting state Thus Mn rejects input Moreover given input w computation tree Mn w contains exactly rejecting conﬁguration leaf branch length doubleexponential n We use ATMs M n input w length n construct described 44 polynomialsize 1CQs qn Then direction 44 Lemma 4 dsirups Q n cov A qn FOrewritable On hand similarly proof direction 44 Lemma 4 computation tree Mn w corresponds cactus C K Q n tripleexponential size n smaller cactus homomorphically embeddable C It follows UCQrewritings Q n tripleexponential size Any PErewritings Q n doubleexponential size Indeed given PErewriting prenex form size s number atoms formula transform matrix quantiﬁerfree DNF obtain UCQ rewriting size s2s So s subdoubleexponential size UCQrewriting tripleexponential A similar argument shows impossible obtain NDLrewritings subexponential size transform subdoubleexponential PErewritings cid2 The proof provide lower bound size FOrewritings result Gurevich Shelah 96 potentially nonelementary blowup length homomorphism invariant FOsentence shortest equivalent PEsentence We illustrate Theorem 16 simple example FOrewritable dsirup UCQrewritings doubleexponential size Example 17 Consider dsirups Q n edges R r ai bi ci pointers labels qn cov A qn qn n 2 1CQ depicted omitted labels S cn cn1 cn2 c2 c1 r F Q S T a1 b1 S Q T a2 b2 F T a3 b3 a0 b0 15 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 C C 1 ha0 C 1 hai C 2 j 0 1 hb j b C 3 1 2 3 hb j b C denote copy x root segment C Observe C For cactus C K Q n node x qn let x C n Anodes ﬁrst depth n iff C contains Rpath π starts r 2 We C ﬁrst depth C n homomorphism h qn 1 C C deﬁne h taking hr r 3 j 2 3 c1 cn1 hmapped n 1 Anodes π hcn F T node segment root hcn1 The case ﬁrst Anode π C 2 similar So Theorem 13 implies Q n FOrewritable C Indeed ﬁrst Anode π On hand claim C Ccid3 cactuses depths n homomorphism h C Ccid3 We induction depth C exceed depth Ccid3 C C Ccid3 Observe ﬁrst x Ccid3 C C x F T node a3 Ssuccessors 0 depth qn hx Ccid3 Ccid3 C Ccid3 1 cid14 3 a0 a1 common successor 2 a2 Q predecessor ha n ha Ccid3 C x x c1 cn1 a3 a0 a3 similar argument ha It follows C qn Ccid3 qn hold h preserve T If depth C 0 root node let C 1 2 let si segment Cs having subcactus C skeleton subtree Cs root si We deﬁne Ccid3 similarly An inspection qn shows homomorphisms h1 C h2 C C Ccid3 induction hypothesis IH Therefore 1 1 C Ccid3 follows UCQ rewriting cid6n Q n provided Theorem 13 contains different cactuses depth n On number 22 disjuncts For cid6n C D Ccid3 D homomorphisms pigeonhole principle exist different disjuncts C Ccid3 disjunct D cid6cid3 cid6n shown C Ccid3 Ccid3cid3 C Ccid3 Thus C n On hand D Ccid3cid3 C 2 clearly hx It follows UCQrewritings cid6cid3 homomorphism disjunct C n Q n 22 contradiction This holds r C 1 cid14 Ccid3 2 Ccid3 2 Ccid3 1 One readily transform cid6n equivalent PErewriting exponential size expense nested But proof Theorem 16 PErewritings subexponential size On hand datalog program 911 converted NDLprogram describing cactuses depth n containing O n rules On cid3cid3 2 1 2 Finding explicit syntactic characterisation FOrewritable dsirups turns nearly hard characterising FOrewritable OMQs fullyﬂedged expressive DLs monadic disjunctive datalog queries Notice 1 CQs Example 17 construction 44 underlying Theorem 16 involved dags multiple edges possibly multiple F T twins So hope restricting shape CQs andor disallowing F T twins obtain impenetrable practically useful classes dsirups Indeed dsirups Q 1CQ ditree unique solitary F node root program cid2 Q reformulated ELontology use AC0NLP trichotomy 3435 checkable ExpTime Example 18 To illustrate consider 1CQ q F F T T R S Q We covA A q iff E A x Bx E EL TBox F cid9 Cq cid4 B T cid4 P A cid9 Cq cid4 P Cq RF cid9 T cid9 SQ P DL syntax illustrated terms ﬁrstorder logic 14 Section 1 Further shown 44 dsirup ditree 1CQ necessarily having F labelled root FO rewritable Lhard deciding dichotomy ﬁxedparameter tractable regard number solitary T nodes parameter Moreover ddsirups arbitrary ditree CQ explicit syntactic trichotomy FOrewritable Lcomplete NLhard On hand readily available machinery explicitly characterising NLcompleteness P coNPhardness ddsirups let general types OMQs We going ﬁll gap extent remainder article To begin combine ideas 4534 prove general suﬃcient condition linearisability dsirups 1CQ 4 Lineardatalogrewritability d ddsirups 1CQ We require new deﬁnitions assuming O cov A cov A First extend class K Q Q cactuses ddsirup Q O q wider class K class structures obtained q recursively applying bud following pruning rule Q adding inductive rule deﬁnition We deﬁne K prune C K Q O C q C C T y solitary T y C add C K Q obtaining C prune deﬁne skeleton Cs C If C cactuses We write Ccid3 C regarded ABoxes sets atoms cactus Ccid3 Cs We continue members K Q isomorphic subset 16 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 cactus C A cactus C K denoted Kmin Q minimal Ccid3 K Q It clear 13 holds Kmin Q place K Q Q Ccid3 C implies Ccid3 C The class minimal cactuses K Q Example 19 Consider dsirup Q cov A q q shown lefthand picture Rlabels edges omitted The cactus C1 obtained budding y1 q C2 obtained budding y2 C1 F q T y1 T y2 T y2 F A y1 T T C1 F A A y1 y2 C2 T T T T 1 result removing T y2 C1 Then cov A C Let C Based observation skeleton cactus Kmin q pruned cactus C 1 Q branch 1 minimal C2 C 1 The branching number 34 rooted tree T deﬁned follows For node u T compute inductively branching rank bru taking bru 0 u leaf nonleaf u cid8 bru m 1 m u 2 children branching rank m 14 m maximum branching ranks children The branching number T branching rank root node In words branching number T b largest binary tree minor T depth b Q branching number Cs We Kmin The branching number cactus C K boundedly branching b ω Kmin contains cactus branching number b cactus greater branching number Otherwise Kmin Q unboundedly branching Q Q Example 20 The branching number cactus Kmin Example 19 0 cactuses K Q arbitrarily large branching number b ω As instructive example consider 1CQ q depicted lefthand The cactus C2 Q covcid15 q righthand obtained ﬁrst budding y2 Q F q T y1 T y2 T T F T y1 y2 y cid3 1 T C2 cid3 1 pruned y1 removing T y1 node model covcid15 labelled F T Using y Q branching number 1 On hand Q cov A q observation cactus Kmin Kmin Q unboundedly branching follows Theorems 21 26 Theorem 21 Every ddsirup Q O q 1CQ q boundedly branching Kmin answered NL Q lineardatalogrewritable Proof Similarly 45 represent cactuslike ABoxes terms tree alphabet construct tree automaton A Q accepted A Q ii ABox A accepted A Q O A q Then cactuses Kmin ideas 34 Kmin boundedly branching automaton A Q transformed monadic linearstratiﬁed datalog rewriting Q As shown 83 rewriting converted linear datalog rewriting expense increasing arity IDB predicates program Q Q We consider case O cov A leaving similar proof cov A reader As assume q 1CQ F x T y1 T yn solitary occurrences F T q 17 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 0ary F F F F cid5 cid6 s2 s3s2 s1 F s1 F x T T T T 1ary F F F F A A T y1 T y2 A T A T A A 2ary F A A 1CQ q symbols cid12 Q Fig 2 An example tree alphabet cid12 Q cactus cid12 Q tree s2 s3 T T T A s2 T T Recall 97 tree alphabet ﬁnite set cid12 symbols associated natural number arity A cid12tree ground term built inductively symbols cid12 functions 0ary symbols cid12 cid12trees kary cid12 cid12trees C1 Ck term aC1 Ck cid12tree The branching number cid12tree parse tree We deﬁne tree alphabet cid12 Q follows Consider cactuslike ABoxes built q bud prune applications allowed cov A C cid14 q resulting ABox C extend notions skeleton branching number segments natural way The symbols cid12 Q segments s ABoxes arity s number budding nodes xnode s labelled F Then cactus K Q encoded cid12 Q tree Fig 2 example On hand cid12 Q tree represents cactuslike ABox So slight abuse terminology cid12 Q tree mean corresponding term ABox However ABox C necessarily cactus K Q possible reasons cov A C cid14 q C having F nodes wrong segments cactus unique F node viz xnode root segment We interested cid12 Q trees C cov A C q To capture use tree automata 97 A nondeterministic ﬁnite tree automaton NTA tree alphabet cid12 quadruple A Q Q f cid4 cid12 Q ﬁnite set states Q f Q set ﬁnal states cid4 set transitions form q1 qk q k 1 arity cid12 q1 qk q Q symbols arity 0 initial transitions cid4 form q A run A cid12tree C labelling function r subterms C Q satisfying following condition subterm C aC1 Ck C transition q1 qk q cid4 rC1 q1 rCk qk rC q case transition r A cid12tree C accepted A run A C labels C ﬁnal state Let LA set cid12trees accepted A A set L cid12trees called regular tree language L LA NTA A cid12 Claim 211 L Q C C cid12 Q tree covA C q regular tree language Proof We proceed series steps In construction use Theorem 11 describing L Q means datalog program cid2 Q 9 10 11 We extend tree alphabet cid12 Q tree alphabet cid12e Q follows For symbol s cid12 Q label possibly nodes segment s P We resulting segment se extension s Each symbol cid12 Q extensions arity s Let cid12e Q consist Q tree Ce extension cid12 Q tree C isomorphic possible extensions s cid12 Q We cid12e tree structures symbol se Ce extension corresponding symbol s C For example closure cid2 Q C cid12 Q tree C cid2 Q extension C For cid12e Q tree Ce write Ce G goal predicate G cid2 Q homomorphism qe Ce qe q T y1 T yn P y1 P yn We claim following regular tree language set cid12e Q trees Ce Ce cid14 cid2 Q Ce 18 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 Q trees Ce Ce G b set cid12e c set cid12 Q trees C extension Ce Ce cid2 Q Ce Ce cid14 G d set cid12 Q trees C cid2 Q C G Indeed need NTA detecting pattern ABox Ce falsifying rules 1011 cid2 Q Similarly b need NTA detecting pattern Ce corresponding application rule 9 cid2 Q Now c follows b fact regular tree languages closed taking complements intersections linear homomorphisms 97 forgetting function substituting s se linear tree homomorphism cid12e Q trees cid12 Q trees mapping extension Ce C To d complement c observe cid2 Q C G iff extension Ce C Ce cid2 Q Ce Ce G Finally follows d Theorem 11 L Q regular tree language cid2 An NTA A Q Q f cid4 cid12 linearstratiﬁed function st Q ω transition q1 qk q cid4 stqi stq 1 k 1 k stqi stq Claim 212 For NTA A b ω linearstratiﬁed NTA As C LA branching number C b LAs LA 15 Proof Suppose A Q Q f cid4 cid12 We deﬁne As Q s Q s f cid4s cid12 follows First set Q s Q 0 b Q f Q f 0 b Then transition form q cid4 add transition q 0 cid4s For transition q1 qk q cid4 m b add cid4s transitions q1 m1 qk mk q m m1 mk m mi m j m 1 cid14 j mi m m j m j cid14 m q Q m b To 15 observe LAs LA As linearstratiﬁed set st run r As C obtain run A C replacing q1 m1 qk mk q m r q1 qk q For inclusion given run r A C branching number b obtain run As cid6 C labelling subterm C branching number C C state cid5 rC b b cid2 cid5 cid6 q m We complete proof Theorem 21 Indeed suppose cactus Kmin b ω By Claims 211 212 linearstratiﬁed NTA A Q Q f cid4 cid12 Q Q branching number C L Q branching number C b LA L Q Using A construct monadic linearstratiﬁed program cid2A goal predicate G A follows For q Q introduce fresh unary predicate P q For ﬁnal state q Q f program cid2A contains rule G A P qx 16 For transition q1 qk s q cid4 budding nodes kary segment s yi1 yik cid2A contains P qx s P q1 yi1 P qk yik 17 As A linearstratiﬁed easy program cid2A linearstratiﬁed We claim cid2A G A datalog rewriting Q ABox A P q cid2A A G A iff cov A A q By Theorem 11 homomorphism h C A C K Q As C contains Ccid3 Kmin Q assume C Kmin Q follows C L Q C LA Let r accepting run A C We construct derivation G A cid2AA induction C cid12 Q tree moving leaves root For segment s C transition q1 qk s q r apply 17 substitution hz node z s Also rC q ﬁnal state q A apply 16 substitution hxs0 xs0 xnode root segment s0 C It follows cid2A A G A Q C branching number b As cov A C q clearly holds C Kmin By induction derivation G A construct cid12 Q tree B accepting run r A B homomorphism f B A To begin object xa 16 triggered q Q f Then P qxa deduced application 17 s If s 0ary s cid12 Q tree depth 0 function r labelling s q accepting run s substitution f 0 17 homomorphism s A If s kary k 0 ya i1 17 triggered For j 1 k consider rule ya ik 19 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 P q j x s j P yi1 P q j 1 yik j q j k j deduced Take ABox B built glueing x node segment s j yi j node P q j ya j s extend r labelling s j q j extend f 0 B A homomorphism taking substitutions rules Now s j 0ary B cid12 Q tree Otherwise repeat procedure arguments s j arity 0 As derivation G A ﬁnite sooner later procedure stops required As B LA L Q Theorem 11 exists homomorphism h C B cactus C K Q Then compo sition h f homomorphism C A cov A A q Theorem 11 required cid2 We know suﬃcient condition Theorem 21 lineardatalogrewritability ddsirups 1CQ necessary As follows 3435 ditree 1CQs root labelled F Example 18 We use Theorem 21 section answering pathshaped ddsirups certain periodic structure NL 5 AC0 NL P CONPtetrachotomy ddsirups path CQ We obtain main result article complete syntactic classiﬁcation ddsirups cov A q path shaped CQ q according data complexity rewritability type While AC0NL AC0NLPcoNP tetrachotomy follows earlier results proving P especially coNPhardness turns tough requires development novel machinery From consider path CQs q digraph pathshaped Solitary F T nodes simply called F T nodes respectively We denote ﬁrst root node q bq leaf node eq Given nodes x y write x y directed path x y q usual x cid29 y means x y x y For x cid29 y set x y comprises atoms q variables interval z x cid29 z cid29 y x y x y T x F x T y F y For x y let length path x y q bq eq We divide path CQs disjoint classes 0CQs 1CQs deﬁned earlier 2CQs contain F nodes T nodes As saw Section 32 ddsirups cov A q q containing F T twins FOrewritable We split twinless 1CQs periodic aperiodic ones considering 1CQs single F node T node case single T node F node symmetric Given twinless 1CQ q natural numbers l r l r 1 write q qlr q lmany T nodes xl x1 precede F node x0 rmany T nodes x1 xr succeed x0 For l r 1 deﬁne set ri binary atoms taking ri xi1 xi xl1 bq xr1 eq Note ri cid14 l r 1 rl bq xl rr1 xr eq q qlr rl T xl bq r0 T x1 F x0 r1 T x1 rr1 T xr eq Each ri determines ﬁnite sequence cid30ricid31 binary predicate symbols We q rightperiodic q q0r r 1 cid30ricid31 cid30r1cid31 1 r cid30rr1cid31 cid30r1cid31λ possibly preﬁx λ cid30r1cid31 By taking mirror image deﬁnition obtain notion leftperiodic 1CQ case q ql 0 l 1 cid30ricid31 cid30r0cid31 1 l 1 cid30rlcid31 λcid30r0cid31 possibly suﬃx λ cid30r0cid31 A twinless 1CQ q called periodic right leftperiodic aperiodic Theorem 22 tetrachotomy Let Q dsirup twinless path CQ q ddsirup path CQ q Then following tetrachotomy holds replaced iff provided NL cid14 P cid14 coNP AC0 Q FOrewritable answered AC0 iff q 0CQ contains F T twin NL Q lineardatalogrewritable answering NLcomplete q periodic 1CQ P Q datalogrewritable answering Pcomplete q aperiodic 1CQ CONP answering Q coNPcomplete q 2CQ The ﬁrst item follows Theorem 5 fact AC0 cid14 L The upper bounds remaining given Theorem 24 Corollary 12 Theorem 4 respectively The matching lower bounds established Theorems 23 26 27 proved We begin following criterion Theorem 23 If q twinless path 1CQ answering covA q cov A q NLhard 20 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 Proof The proof FOreduction NLcomplete reachability problem directed acyclic graphs dags We assume exist T node x F node y q x y case symmetric F T nodes Given dag G V E nodes s t V construct twinless ABox AG follows Replace edge e u v E fresh copy qe q node x qe renamed u T u replaced Au node y renamed v F v replaced Av Then AG comprises qe e E T s F t We s G t iff cov A AG q iff cov A AG q cf 8 Suppose path s v0 vn t G ei vi vi1 E n Then model I cov A Thus isomorphism mapping q copy qei q I vi1 F I I AG n vi T homomorphism I q Suppose s cid3G t Deﬁne model I cov A AG labelling T undecided Anodes AG reachable s directed path F remaining ones By excluding possible locations T node x mapped homomorphism h q I Indeed suppose hx copy qe edge e u v E Then hx precede u succeed v qe room qe rest q mapped And hx u v q twinless T nodes x y q If hx u exclude options F node y mapped h y succeed u qucid3u edge ucid3 u lack room qucid3u h y vcid3 hold quvcid3 edge u vcid3 E vcid3 labelled T I For similar reasons hx v happen cid2 A generalisation theorem dsirups ditreeshaped 1CQs possibly containing F T twins proved 44 involved construction Example 25 By Corollary 12 ddsirups 1CQ datalogrewritable answered P Our task establish NLP dichotomy dsirups twinless path 1CQ Theorem 24 If q periodic twinless path 1CQ covA q cov answered NL A q lineardatalogrewritable Proof We use notation consider case Q cov A q q q0r rightperiodic twinless path 1CQ single F node x0 T nodes x1 xr We cactus Kmin Q branching number 1 use Theorem 21 If r 1 cactuses Kmin Q branching number 0 So suppose r 2 C Kmin Q For nodes u v C write u C v directed path u v acyclic digraph C We node C T copy copy T node xi q 1 r There kinds T copies budded constructing C labelled A pruned label rest labelled T Observe ﬁrst T copy u unlabelled C T copy v u C v v labelled T 18 cid3 cid3 u C u I As cov A C q Indeed consider model I cov A C Anodes u s0 homomorphism h q I As x0 F node q copy x root segment s0 C F node C 0 follows assumption I u C hx0 We u C hxi r Indeed clear hx0 C u s0 So suppose hx0 C u C hxr Then hx0 x 0 hx0 budded T copy C preceding u By q right periodic T copy path hx0 hxr C different hx0 labelled T However case u contradiction As u C hxi r bud prune construct cactus C1 K unlabelled Then C1 C Q C apart T labelled T copies u C Kmin Q implies C C1 proving 18 Next consider branch s0 sn1 sn skeleton Cs C Anodes segment sn1 Csucceeding Alabelled T copy w budded obtain leaf segment sn Let π path C root node s0 leaf node sn We claim u C u T cid3 cid3 T copies π labelled T A 19 Indeed 18 T copies sn labelled T Suppose contrary Let I model cov A C Anode w labelled F Then homomorphism h q I hxi cid14 w 0 r Thus bud prune construct cactus C2 K Q C apart w sn1 budded pruned w unlabelled C2 sn 2 Then C2 C C2 cid14 C contrary C Kmin segment Cs Q Now 19 q rightperiodic imply model I cov A C homomorphism h q I mapping x0 x0 eq π Indeed hx0 z z Clast F labelled Anode π s0 0 By deﬁnition budding q preceding x0 mapped I possibly covering x parts C π childsegment si Therefore bud prune construct Q skeleton consists branch s0 sn children segments si 0 n 1 cactus C3 K 21 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 T copies labelled A budded C children unlabelled C3 T copies C3 C Then C3 C branching number C3 1 As C Kmin Q C C3 follows cid2 One generalise proof Theorem 24 path 1CQs F T twins Here examples Example 25 We invite reader answering dsirups following 1CQs NLcomplete F F T F T T T F F T F T T T T T F T F T T F T F T F T F F T T T We answering dsirup twinless path 1CQs covered Theorem 24 Phard Theorem 26 If q aperiodic twinless path 1CQ answering covA q cov A q Phard Proof The theorem proved FOreduction monotone circuit evaluation problem known P complete 98 We remind reader monotone Boolean circuit directed acyclic graph C vertices called gates Gates indegree 0 input gates Each noninput gate g ANDgate ORgate indegree 2 edges coming gates inputs g One noninput gates distinguished output gate Given assignment α F T input gates C compute value gate C α usual Boolean logic The output C α C α truthvalue output gate For monotone Boolean circuit C assignment α construct twinless ABox AC α size polynomial sizes q C C α T iff cov A AC α q iff cov We prove theorem aperiodic 1CQs single F node case symmetric Suppose q qlr l r l r 1 Then reasons q aperiodic l 0 q rightperiodic ii r 0 q leftperiodic iii l r 1 In cases iiii different reduction A AC α q cf 8 If q q0r q rightperiodic r 2 We let cid9 n r min 1 randcid30ricid31 cid14 cid30r1cid31 cid30r1cid31 cid30r2cid31 cid30rrcid31 Then n 2 The ABox AC α built isomorphic copies following intervals l bq x0 r1 x0 x1 r x1 xn1 s xn1 xn t xn eq Note s nonempty T nodes On hand l bq x0 r n 2 t xn eq l F x0 r1 T x1 bq r2 T r T xn rn1 T s rn xn1 t T xn eq cid3 We use gadgets Fig 3 simulate AND ORgates For ANDgates distinguish cases s r1 s r1 gadget ORgates cases Throughout pictures ABoxes cid3 b lower case letters like b z pointers actual labels nodes In Fig 3 r z labelled A z Given monotone circuit C assignment α construct AC α follows With noninput gate g associate fresh copy gadget When inputs g gates ga gb b gi noninput gate merge node c gadget gi node gadget g gi input gate replace label A available gadget g αgi Finally replace label A node c gadget output gate F We claim cov A AC α q iff C α T proved induction number noninput gates C The basis obvious For induction step suppose output gate g C ANDgate inputs ga gb noninput gate Let I arbitrary model cov A AC α If b gadget g T easy check q I homomorphism matter labels available It remains consider case b F C output gate gi Then α subABox AC α node c gadget gi topmost node Ac replaced F c Now A C I homomorphism I q restriction I A C The case output gate g C ORgate similar corresponding gi input gate Take subcircuit C IH q I α c F b I I I cid3 cid3 cid3 22 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 ANDgate gadget s r1 s r1 c A s T z r cid3 r1 A r1 T r u T s A l l t t A cid3 b l r1 T r T s t A b A r1 T r A c l cid3 z ORgate gadget c A r1 l r1 T T r s T T r s s t A b t A t A b Fig 3 Gate gadgets case cid3 Suppose C α F To cov A AC α cid14 q deﬁne model I cov A AC α inductively labelling Anodes gadget noninput gate g C F T follows node c labelled truthvalue g applicable b labelled truthvalue gi α ga gb α node node inputs g Suppose contrary homomorphism h q I We exclude options image hq q To end track possible locations hx0 F Let noninput gate g hx0 gadget g inputs g gates ga gb We assume hx0 different nodes b hx0 b gi noninput gate room hq AC α hx0 c gadget gi I Suppose ﬁrst g ANDgate s r1 We following cases cid3 I I b b cid3 c F If hx0 c hx1 cid3 T But s r1 node hxn strictly u impossible T nodes cid3 s We hx0 b cid3 c F cid3 T If hx0 T node But s r1 node hxn1 strictly b T nodes s cid3 c F cid3 b b hq continue vertically Then hx1 central z impossible hq continue horizontally b This case covered previous ones b F cid3 F room hq t b I b b cid3 F I I I I I cid3 cid3 I hxn located gadget g Suppose g ANDgate s r1 Then hx0 c hxn1 b provided b T h impossible means F node c merged current b hxn1 However impossible following In gadget edges leaving node c s r1 hxn labelled r1 As xn1 sconnected xn hxn1 c gadget g strictly c endnode r1edge T nodes So suppose s r1 Then hxn cid30scid31 cid30r1cid31 Now follows deﬁnition n s n r endnode r1edge gadget g cid30r1cid31 cid30rrcid31 cid30scid31 As hxr hxn endnode r1edge starting c gadget g inspection gategadgets shows rr1 xr eq t mapped nonempty sequence r1intervals followed t subsequent gadgets So cid30rr1cid31 possibly sequence cid30r1cid31s possibly gadget g followed nonempty proper preﬁx cid30r1cid31 contrary q rightperiodic Finally g ORgate hx0 c gadget g b gadget F I hxn F I cid3 cid3 cid3 cid3 cid3 I contradiction The proof ii mirror image previous iii If q qlr l r 1 AC α built isomorphic copies following intervals l bq x1 r x1 x0 s x0 xr t xr eq Note r T nodes l t l T x1 r F x0 s T xr t eq bq We use gadgets Fig 4 simulate AND ORgates The number Anodes gadget nonoutput ANDgate exceeds q 2 Given monotone circuit C assignment α construct AC α follows With noninput gate g associate fresh copy gadget When inputs g gates ga gb b gi noninput gate 23 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 output ANDgate gadget F nonoutput ANDgate gadget output ORgate gadget l l r A r A nonoutput ORgate gadget l r A s A r A r A b T b T b F s s A z t t l t l Fig 4 Gate gadgets case iii T T T T s s s s r r r A z A A A A l l l l l r A s A b t t t t t merge topmost Anode gadget gi node gadget g gi input gate replace label A gadget g αgi We claim cov A AC α q iff C α T proved induction number noninput gates C The basis C noninput gate obvious For induction step suppose output gate g C ORgate inputs ga gb I noninput gate Let I arbitrary model cov A AC α If b gadget g T clearly I q It remains consider case b F Let gi noninput gate C output gate gi There cases If node z gadget gi F Then A restriction C I I A gi ANDgate topmost Anode gadget gi F Anode gadget gi Anode F I So q I homomorphism The case output gate C T ANDgate similar α subABox AC α z topmost node Az replaced F z Now I homomorphism I q b If z T IH q I consider subcircuit C α z F Suppose C α F To cov A AC α cid14 q deﬁne model I cov A AC α putting Anodes truthvalue g α F respectively T Suppose contrary gadget gate g C F homomorphism h q I We track possible locations hx0 F T I I I I I I I I C If output gate ANDgate hx0 F node gadget hx1 hxr b F I contradiction If output gate ORgate hx0 F node gadget hx1 hx1 b hx1 F I contradiction So suppose hx0 Anode gadget noninput nonoutput gate g If g ORgate hx1 hx1 b gadget g hx1 F I contradiction So suppose g AND gate consider gadget g Then hx0 Anode located z hx1 contradiction Finally hx0 z vertical line comprised r previous Anode F longer q contains T nodes hx1 T gadget g horizontal s But impossible r nonempty distance z hx0 hx1 gadget greater distance x0 x1 q I I Thus homomorphism h q I cid2 The proof bears superﬁcial similarities construction Afrati Papadimitriou 47 clas siﬁcation binary chain sirups One draw parallels proof Phardness OMQs EL ontology given Lutz Sabellek 3435 reduction path systems accessibility PSA monotone circuit evaluation The diﬃcult tetrachotomy proving coNPhardness ddsirups path 2CQs Despite abun dance results algorithmic aspects graph homomorphisms 87 failed ﬁnd known technique applicable case In remainder article develop new method establishing coNPhardness disjunctive OMQs 24 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 6 Proving CONPhardness bike technique Theorem 27 If q twinless path 2CQ answering covA q cov A q coNPhard We prove Theorem 27 polynomial reduction complement NPcomplete 3SAT 98 Recall 3CNF conjunction clauses form cid21 cid22 cid23 cid2i literal propositional variable negation thereof The decision problem 3SAT asks given 3CNF ψ satisﬁable For 3CNF ψ construct twinless ABox Aqψ A Aqψ cid14 q cf size polynomial sizes q ψ ψ satisﬁable iff cov A Aqψ cid14 q iff cov 8 The construction called bike technique builds Aqψ copies q major steps 1 First represent truthvalues literals ψ gadgets called cogwheels 2 Next connect cogwheels represent negation properly gadgets called bikes 3 Finally connect bikes represent interaction clauses ψ obtain Aqψ I These steps deﬁned investigated Sections 6163 But explain underlying ideas illustrate example Each cogwheel W Step 1 Anodes number depends q number clauses ψ different copies q meet Each W model I cov A W If variable p occurs ψ Step 2 bike B I cid14 q iff Anodes W T representing pair p p literals assembled disjoint cogwheels connecting Anodes copies q We pairwise disjoint bikes variables occurring ψ Each bike B constructed way model I cov A B I cid14 q iff truthvalues I represented cogwheels B opposites Finally Step 3 clause c cid21 cid22 cid23 ψ use copy qc q connect Anodes cogwheels bikes representing cid21 cid21 cid22 cid22 cid23 cid23 way model I cov A resulting ABox Aqψ I cid14 q iff labels cconnection Anodes I deﬁne assignment satisfying c If Step 1 choose number Anodes cogwheels large cogwheel use different cconnection Anodes different clauses different Anodes constructing bikes cogwheels F I Example 271 Consider dsirup cov A q 2CQ q shown picture R edges omitted T T F F Let ψ c1 c2 c3 c1 p q r c2 p q r c3 p q r Fig 5 shows steps construction Aqψ In Step 1 construct cogwheels copies q representing p p q q r r Then Step 2 construct bikes representing pairs p p q q r r Finally connect bikes Step 3 obtain Aqψ Given assignment p q r T F deﬁne model Ia cov A Aqψ follows v p q r Ia av F av T Anodes vcogwheel T Ia It tedious hard check Ia cid14 q Anodes vcogwheel F iff satisﬁes ψ Ia vcogwheel F Ia vcogwheel T It far obvious exactly particular properties construction generalised arbitrary twinless path 2CQs consider permutations F T nodes q On hand easy identify needed cov A Aqψ cid14 q ψ satisﬁable direction hold However main obstacle proving converse implication given model I determined assignment satisfying ψ need exclude q I homomorphisms map q copies Aqψ At steps parasite q I homomorphisms single universal way correctly assembling Aqψ q ψ In remainder article overcome obstacle cid3 We ﬁx twinless path 2CQ q use following notation For k let tk fk denote kth T node F node q In particular t1 tlast1 tlast denote respectively ﬁrst T node q δqcid3 x y Given path CQ q cid3 q set number edges path x y x cid29qcid3 y As omit subscripts q q δbq eq ﬁrst root node bq leaf node eq q write qcid3 cid29qcid3 ordering nodes q δqcid3 distance q Throughout proving statements form cov A A cid14 q ABox A use generalisation homomor phisms allows regard CQs contained single binary predicate Given model I ABox A map h q I subhomomorphism following conditions hold cid3 cid3 I hx T T node x q hx F nodes x y q Rx y q R S cid6 cid5 hx h y F node x q I A S 25 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 A cid2 A Step 1 A T F F T Step 2 T T F T A T F A cid2 A A cid2 A q1 qk1 Step 3 T T qc1 qc2 qc3 T F F Fig 5 An example biketechnique t 1 A f n t k1 A f k qn q2 W f 1 A t 2 f k1 A t k Fig 6 An ncogwheel W q A q A q A A r A r A Aqψ A p A p A qk1 qk The ABoxes A build copies q contain cycles cycles large compared q Thus subhomomorphism h mapping q model I A hq regarded path CQ following obvious hshift property δ y z δhq cid5 cid6 h y hz nodes y z q 61 Representing truthvalues literals cogwheels 20 For n q n disjoint copies q1 qn q For j 1 j n node x q let x j denote copy x q j For j pick T node t j F node f j q j calling selected nodes contacts We replace T F labels contacts A glue f j t j1 j 1 j n understood modulo n We resulting ABox W ncogwheel q Fig 6 Given contacts c1 f t i1 c2 f j t j1 deﬁne contactdistance c1 c2 W min cid5 j n j As shown Lemma 273 straightforward ncogwheel W I model cov A W I cid14 q contacts W T We want converse implication hold case W represent truthvalue In order achieve need choose contacts way possible locations W image hq potential homomorphism h q I excluded The following example shows improper choice contacts contacts W F cid6 I I Example 272 Consider 2CQ shown picture q T t1 F f 1 T t2 T t3 F f 2 Take copies q1 q2 q W If choose contacts t 1 t1 contacts W F 1 f 1 f 1 following h q I homomorphism I 1 t 2 t2 3 f 2 f 1 2 I 26 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 T q2 F T T I F t 2 f 1 h F T F q1 T T T q F To search space contacts smaller exclude cases like Example 272 following assump tions To begin assume t1 f 1 21 case symmetric We assume contacts ncogwheel W following properties q j f j j 1 j n t j t j1 t j1 f j f j t f j 1 j n 22 23 Note 23 hold Example 272 t3 f 1 For j nodes preceding t j q j form initial cog nodes succeeding f j q j form ﬁnal cog The following general criterion gives ﬂexibility designing cogwheels Lemma 273 Suppose W ncogwheel n q satisfying 22 23 For model I cov A W I cid14 q iff contacts I T F I I Proof Suppose contact f i1 t T I induction contacts W T f i2 t i1 F I Since I cid14 q clockwise contact f t i1 T I It follows anticlockwise contact If contact f i1 t F I I I follows induction contacts F First suppose I model cov A W contacts I F The proof excluding possible locations W image hq potential subhomomorphism h q I As n q consider hq path CQ cid29hq δhq welldeﬁned Observe t f t j t j f j f j j deﬁnition minimal model I clearly ht t j h f f j In particular q I subhomomorphism mapping q q j hq intersect copies q W Further 23 room hq start initial cog reaching contact ﬁnish ﬁnal cog like Example 272 I So loss generality assume k 2 k n hq intersects copies q1 qk q1 hbq b1 q hq qk cid14 t k q1 f 1 24 25 26 t 1 q1 hq f 1 t 2 q2 q1 q3 f 2 t 3 f k1 t k qk q2 qk1 qk f k Now consider subABox H W consisting copies q1 qk For cid16 1 cid16 k let ιcid16 qcid16 q isomorphism mapping xcid16 x We deﬁne function g indH indH taking gx h x node qcid16 consider contact c f cid16 t cid161 1 cid16 k node qcid161 gc gt cid161 cid6 cid5 ιcid161t cid161 Throughout use following property g straightforward consequence hshift h 20 similar property isomorphism ιcid16 cid16 1 cid16 k cid6 cid5 ιcid16x y z copy qcid16 y z cid14 f cid16 cid16 k y cid29 qcid16 z g y cid29hq gz δqcid16 y z δhq 27 cid5 cid6 g y gz 27 29 30 cid6 cid5 t cid16 j y j Let K N O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 As H ﬁnite exists ﬁxpoint g node x H number N 0 g N ﬁxpointcycle left More precisely claim x x We shift contact c g N c c 28 Indeed let y0 x y1 gx y2 g2 y j y j j N y j contact 28 So suppose We y j q1 27 25 j N x Then g N x y N1 g N1 cid6 q g y j modulo N Therefore 26 q y j δhq δq1 b1 gb1 cid5 δhq cid5 cid6 hbq y j1 cid5 cid6 hbq y j1 cid5 cid6 b1 q y j1 δq1 δq1 exists j N y j qcid16 j t cid16 j q cid16 j y j cid16 j 1 When cid16 j 1 contact t cid16 j necessarily exist For j N cid16 j 1 set d j δ q cid16 j dK mind j j N cid16 j 1 welldeﬁned 30 set c f cid16K 1 t cid16K By 24 y j deﬁnition K 27 j N g j c belongs copy qcid16K j y K j g q cid16 j f cid16 j 1 cid16 j k Thus j c cid29 q cid16K j y K j dK δ q cid16K j cid5 g j c y K j cid6 It follows particular g N c c required 28 g N c belongs copy qcid16K y K δqcid16K cid5 g N c y K cid6 δqcid16K c y K Therefore It remains 28 leads contradiction Indeed c F I cid6 cid5 ιcid16t cid16 I minimality I On hand induction j 1 g gc h cid16 gc T j1 c T g cid5 j1 j c h ιcid16 c g The case I contacts T cid6 cid5 ιcid16x h gf cid16 h j1 c contact ιcid16 IH Thus g T h subhomomorphism cid6 cid5 ιcid16f cid16 cid6cid6 g cid5 I I I similar Now deﬁne function g indH indH taking gx x node qcid16 consider contact c f cid16 t cid161 node qcid16 gc Then proof 28 g shift ﬁxpointcycle right cid2 assumption c T I If j 1 ιcid16t cid16 T node q h subhomomorphism If j 1 T node q cid16 Therefore c g N cid6 j1 c j c T c T g cid5 I I Remark 274 It noted specialised assumptions choice contacts Lemma 273 j straightforward proof For example suppose ncogwheel W satisﬁes 22 f j f 1 j 1 j n Given model I contacts W truthvalue subhomomorphism h q I exists excluding possible locations h f 1 h f 1 contact f j ht contact T node t t j t j h f 1 ﬁnal cog q j room hq cog options h f 1 F node preceding f 1 q Unfortunately illustrated Example 276 assume ncogwheels simple 62 Representing negation bikes For variable 3CNF ψ fresh pair cogwheels W W connect fresh copies q special way We want achieve model I cov A resulting twowheel ABox I cid14 q iff cogwheels W W represent opposite truthvalues contacts W F I contacts W T I contacts W T I contacts W F I 31 To end suppose W W disjoint ncogwheels n 4q 2 built qcopies q n respectively For 1 n denote contacts f t j1 W q 1 node x q denote q We pick contacts x copy x t i1 q n q 1 t q f j f 28 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 q q j1 t A f i1 f j1 A t j2 q i1 W q j F f t i1 A f t j1 A f j Tt F f f A t i1 Fq t j1 A f j Tt Tq Fig 7 An nbike B q q W q j1 t i2 A f i1 f j1 A t j q i1 q j far sense contactdistance W 2q Similarly pick contacts t j1 W contactdistance W 2q t i1 f j f Next let Fq Tq fresh disjoint copies q For Z F T node x q denote Zx copy x Zq We connect W W Fq Tq follows First pick F nodes f f Fq contact t i1 W q replace F labels A Then glue node F f t contact glue F f q t t j1 W glue replace T labels A Then glue node Tt t j1 W The resulting ABox B called nbike q Fig 7 We Tt t i1 F connections B F neighbourhood B consists contacts f contacts F f t j1 contactdistance F connection q Similarly contacts Tt Tconnections B Tneighbourhood B consists contacts contactdistance Tconnection q t i1 W Finally pick T nodes t Tq contact contact f f j t j1 Tt f j t i1 F f f j f j f f t f f Using Lemma 273 fact F connections F nodes Fq Tconnections T nodes Tq straightforward nbike B I model cov A B I cid14 q 31 holds However converse implication hold need choose contacts F connections Fq b Tconnections Tq c located F Tneighbourhoods cogwheels B carefully way possible locations B image hq potential homomorphism h q I excluded So suppose I model cov A B satisﬁes 31 We try exclude h q I subhomomorphisms To begin n 4q q consider image hq q I path CQ If choose contacts ac way 22 23 hold cogwheels B Lemma 273 know hq intersect Fq Tq Therefore intersection hq ncogwheels F Tneighbourhoods Further straightforward 31 subhomomorphism h q I hf F f subhomomorphism h q I ht F f hf Tt ht Tt 32 In particular q I subhomomorphism mapping q Fq Tq Because hq properly intersect ncogwheels W W sense intersection hq cogwheel T F connection As F connections contactdistance 2q Tconnections hq intersect Fq Tq time It easy check 32 options hq covered cases given Fig 8 We aim 2CQ suitable contact choices exist actually providing algorithm given 2CQ q describes contact choices suitable nbike constructed copies q For 2CQs suitable contact choices straightforward uniquely determined 22 23 In general different cases Fig 8 place different constraints suitable contact choices There interaction constraints hq intersect Tneighbourhoods cogwheels B These interactions constraints 22 23 ﬁnding general solution tricky catandmouse game We tried different ways systematising search solutions ended following choices heuristics Remark 274 motivating H2 H1 We try choose contacts way results cases possible H2 In excluding possible locations hq aim track h f 1 So aim choose contacts way leaves options h f 1 possible 29 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 1T hq starts W ht hq Tt 2T hq starts Tq ends W Tt W hq Tt W Tq hq Tt W Tt W 3T hq starts W ends Tq 4T hq ends W Tt hq ht Tt W Tt W hq Tq hq Tt W Tt W 1F hq starts W hf hq F f 2F hq starts Fq ends W F f W hq F f W Fq hq F f W F f W 3F hq starts W ends Fq 4F hq ends W F f hq hf F f W F f W hq Fq hq F f W F f W Tq Tq Fq Fq Fig 8 Possible locations hq intersecting Fq Tq In particular light H1 H2 decided f options h f 1 Fq contacts f t i1 illustrated following examples t i1 f f 2 F connections This leaves However deal case distinctions choices f 1 f Example 275 Consider 2CQ q T t1 T t2 F f 1 F f 2 If choose I T t i1 t i1 1 f i1 f i1 1 I contacts W F I contacts W following h q I homomorphism case 2F Fig 8 Fq I T I F F f 1 f i1 1 T I F f i1 1 q i1 F W T T h q T T Note choosing f i1 ii Consider 2CQ f i1 2 help q T t1 F T F f 2 F T t2 F f 1 30 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 If choose I F t i1 t i1 1 f i1 f i1 1 I contacts W T I contacts W following h q I homomorphism case 4F Fig 8 q i1 F T W T T I F f i1 1 F I F F f 2 t i1 1 F T Fq T I T F f 1 h q T T T help Note choosing f i1 f i1 2 iii On hand shown Lemma 277 contact choices t i1 t i1 1 f i1 f i1 1 suitable following 2CQs t i1 1 f i1 f i1 1 t i1 T t1 T t2 F f 1 F f 2 T t1 F f 1 T t2 F f 2 T t1 F f 1 F f 2 T t2 There sources inherent case distinctions For example light Remark 274 tempting try copies f 1 contacts F neighbourhoods W W However possible illustrated following examples f Example 276 Take 2CQ q contains F nodes Thus choose f 1 f case 2F possible start hq Fq map f 1 F f 1 ﬁnish hq ﬁnal cog f 1 If choose f f f 1 q ii Consider 2CQ T t1 T t2 F f 1 F f 2 Then choose f contacts W T case 4F Fig 8 f 1 f I f 2 F f contacts W F F f 1 F f I F f 2 If choose f 1 I following h q I homomorphism f T Fq T T h q I T F f 1 I F F F f 2 f 1 f 2 q T F F There examples showing unlike F connections Tconnections chosen uniformly possible 2CQs q The problems face symmetric counterparts F connections overall assumption t1 f 1 21 We hope examples convince reader ﬁxing H1 H2 heuristics ﬁnding general solution satisﬁes 22 23 excludes cases Fig 8 2CQ q challenge The following lemma describes solution lines H1 H2 Lemma 277 Let B nbike n 4q 2 built ncogwheels W W satisfying 22 23 Suppose B following hold Tconnections cid8 t1 t t t tlast f 1 tlast t ﬁrst T node succeeding f 1 tlast f 1 following hold Tneighbourhood 31 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 t j t j cid2 tcid2 T node preceding f 1 f j t j t j 1 f j cid8 f f tlast f 1 δtlast1 tlast δtlast f 1 j 2 j 1 cid8 f f j 1 j 2 f 1 tlast tlast f 1 t k t k 1 f k f k 1 k j q k j q following hold F connections f 1 f f 2 f following hold F neighbourhood 1 f ik t icid16 f 0 k q f 2 f ik t t 1 t ik t ik 1 cid8 t icid16 1 t icid16 cid2 tcid2 T node preceding f 1 f icid16 f icid16 tlast f 1 δ f 1 f 2 δt1 f 1 tlast f 1 δ f 1 f 2 δt1 f 1 f icid16 cid8 2 1 1 cid16 q Then model I cov A B I cid14 q iff contacts W T I contacts W F I contacts W F I contacts W T I It straightforward check nbikes B satisfying conditions lemma exist The F T neighbourhoods B kept disjoint taking 2q contactdistance F Tconnections cogwheels B choosing 2 k conditions 22 23 f k hold cogwheels 1 t k t k f k Proof The implication Lemma 277 clearly holds nbike B direction Lemma 273 To suppose B I model cov A B 31 holds The proof excluding possible locations B image hq potential subhomomorphism h q I As discussed cases Fig 8 In line H2 cases track location h f 1 exclude options Throughout arguments use hshift property 20 explicit reference First deal cases hq Tq cid14 1T hq starts W ht hq Tt W Tt hq Tt Tq W f jk 1 hq Then hq deﬁnitely properly intersects Tneighbourhood W properly intersect T T f 1 As t j1 neighbourhood W It follows ht t q jk k q oth t jk q jk erwise room hq cog As k 0 k q ht1 contact W contradicting 31 For h f 1 contact W different Tt remaining options consider cases f 1 tlast tlast f 1 Tt k q h f 1 initial cog h f 1 Tq h f 1 Tq q j1 jk f 1 If f 1 tlast t t j t W As contradicting 31 As F node preceding f 1 q options h f 1 W T f 1 Tq j 1 h f 1 contact Tt As F node preceding T f 1 Tq h f 1 1 htcid2 contact W t1 f 1 t t jk t cid2 j f jk f j j1 1 jk 1 Tt j f f 32 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 q j t j cid2 q j1 Tt Tt1 Tq T f 1 Tt f j 1 t j1 1 W q t1 cid29 tcid2 F f 1 If tlast f 1 t t1 t h f 1 W W tlast tcid2 Tt Ttlast Tq T f 1 As F node preceding T f 1 Tq q j1 Tt Tt1 Tt Ttlast T f 1 T f 2 Tq f j 2 f j 1 q j t cid2 j t j W f 1 f 2 q tcid2 tlast F First exclude remaining options W As htcid2 h f 2 contacts W contradicting 31 And h f 1 contact Tt track location htlast As hq starts W htlast hq h f 1 htlast W As t1 tlast htlast initial cog cog Thus j 1 f j 2 f j1 t j1 t 1 q j1 room hq 2 h f 1 cid2 j t j t f j j f cid5 htlast cid6 f j 2 δhq δhq cid5 cid6 htlast h f 1 δtlast f 1 δtlast f 2 δq j cid5 t j f j 2 cid6 htlast node t preceding f 2 q f 1 options h f 1 W tcid2 t j 2 But T node j j f q j As F node t j h tcid2 tlast f j 1 f j 2 q j q f 1 f 2 T If h f 1 W Tt htlast ht case room hq cog Thus hq Tt j1 t j1 t 1 Ttlast cid29hq h f 1 We track location htlast As ht hq assumption htlast W htlast hq htlast Tq In Tt q j1 t1 tlast htlast initial cog Tt cid5 htlast cid6 f j 2 δhq δhq cid5 htlast Tt cid6 cid5 cid6 htlast h f 1 δhq δtlast f 1 δtlast f 2 δq j cid5 t j f j 2 cid6 htlast node t j t j tcid2 f j 2 But T node q j 33 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 q j t j f j 1 Tt Tq Tt h tcid2 tlast f j 2 T f 1 f 2 W q So suppose ht ht1 initial cog htlast Tq Now track location ht j1 1 q j1 room hq cog Thus ht1 W As t j1 t cid5 ht1 cid6 f j 2 δhq δhq cid5 ht Tt cid6 cid6 cid5 ht Tt δTq cid5 cid6 htlast h f 1 cid6 cid5 htlast Ttlast δTq δtlast f 1 δtlast f 2 δq j cid5 t j f j 2 cid6 δhq ht1 node t j f j 2 But T node q j W t j f j 1 Tt1 Tq Ttlast h t1 f j 2 F tlast f 1 f 2 T W q 2T hq starts Tq ends W hq Tt Tt Tq W W t1 t1 f 1 21 h f 1 W Then hq properly intersects Tneighbourhood W As t Tt1 cid29hq h f 1 room hq Tq Now track location ht1 Again Tt Tt1 cid29hq ht1 room hq Tq As q ht1 W Tt preceding t1 containing F T nodes h q I subhomomorphism modify obtain subhomomorphism q restriction I W contradicts Lemma 273 31 3T hq starts W ends Tq Tt Tt hq Tq W W Then hq properly intersects Tneighbourhood W As cog k 0 k q h f 1 contact W different Tt 31 To exclude remaining options consider cases f 1 tlast tlast f 1 q j1 room hq cog As h f 1 initial jk 1 ht1 contact contradicting t j1 q j1 If f 1 tlast T f 1 Tq t j t dicting 31 As F node preceding f 1 q options h f 1 W j 1 h f 1 contact Tt h f 1 Tq room hq Tq As 1 ht1 contact W contra j1 f 1 t jk t 1 f jk f j jk 1 Tt j j f f f If tlast f 1 t tlast Tt Ttlast Tq T f 1 As F node preceding T f 1 Tq h f 1 cid29hq Tt h f 1 W h f 1 T f 1 room hq Tq We exclude f j f j Suppose ﬁrst h f 1 W As 1 ht1 contact W j 1 If ht1 h f 2 contacts W contradicting 35 cases As F node preceding f 2 q f 1 remaining option h f 1 W h f 1 j 2 Now track location htlast 2 h f 1 f f j 1 t j t f j Tt f j j j j j 2 1 f f f f 34 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 t j f j 1 Tt Ttlast f j 2 h tlast f 1 T q f 2 t j1 t As cog Thus j1 1 htlast initial cog q j1 room hq cid5 htlast cid6 f j 2 δhq δhq cid5 cid6 htlast h f 1 δtlast f 1 δtlast f 2 δq j cid5 t j f j 2 cid6 t j t As j 1 h f 1 W q j t j follows htlast t j f j 2 But T node q j If h f 1 c f 1 htlast Ttlast Tt j1 We track location htlast1 As 1 initial cog q j1 room hq cog As t f j htlast j t 1 T node succeeding tlast1 q Therefore f j htlast1 t q j htlast1 q j htlast1 j cid29q j q j f hold tlast t j1 t j last1 cid29q j t j j 1 δtlast1 tlast δhq cid6 cid5 htlast1 htlast cid8 cid5 cid5 t t δq j δq j cases impossible cid6 cid6 f f j 2 j 1 δtlast f 2 δtlast f 1 δtlast1 tlast δtlast f 1 δtlast1 tlast cid14 δtlast f 1 j j t j h T f 1 T f 2 Tq Ttlast f j tlast1 tlast f 1 f 2 T T q hq ht Tt Tq 4T hq ends W Tt hq Tt W W f jcid16 1 cid29q jcid16 Then hq deﬁnitely properly intersects Tneighbourhood W properly intersect T q jcid16 neighbourhood W As cid16 q room hq cog As cid16 1 cid16 q h f 1 contact W different Tt ht1 contact contradicting 31 As F node preceding f 1 q follows h f 1 Tq To exclude remaining options consider cases f 1 tlast tlast f 1 f jcid16 cid16 q h f 1 ﬁnal cog jcid16 t jcid16 t 1 If f 1 tlast t hq ht t t ﬁrst T node succeeding f 1 As assumption hq ends W Tt Now track location htcid2 T node tcid2 Tt preceding f 1 As t1 cid29 tcid2 f 1 follows htcid2 Ttcid2 h f 1 Ttcid2 Tt But T node Tq follows T f 1 Tq h f 1 cid29Tq f jcid16 jcid16 1 Tt f 35 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 Tt Tt1 Ttcid2 T f 1 Tt Tt Tq h tcid2 q f 1 t T If tlast f 1 t tlast As hq ends W Tt hq ht follows Tt hq htlast hq h f 1 Thus h f 1 Tq leaving options Next deal cases hq Fq cid14 1F hq starts W hf hq F f W F f hq F f Fq W f 1 h f 1 hq t i1 h f 1 initial cog f jk Then hq deﬁnitely properly intersects F neighbourhood W properly intersect F neighbourhood W As f F f choice q i1 room hq cog As k 0 k q h f 1 contact W different f F f 2 h f 1 f 1 ht1 h f 2 contacts W contradicting 31 As F node preceding f 2 q f 1 options h f 1 t jk t ht1 contact W contradicting 31 And h f 1 W As t i1 q i1 1 t t f jk 1 f i1 jk 1 1 f W q i2 q i1 f i2 1 t i2 1 t i1 1 q q q i1 f i1 1 t 1 h F f 1 Fq f 1 f 2 t1 F f 1 f 2 F Fq 2F hq starts Fq ends W hq F f F f W W Then hq properly intersects F neighbourhood W As f room hq Fq Thus F f cid16 q h f 1 ﬁnal cog cog To exclude remaining options consider cases f 1 tlast tlast f 1 F f 1 f icid16 q cid16 q room hq cid29hq h f 1 h f 1 W As f 1 h f 1 hq t icid16 cid2 f 1 Thus h f 1 contact W different F f F node preceding f 1 q remaining option h f 1 h f 1 F f 31 We track location ht ﬁrst T node t succeeding f 1 q F cid16 1 cid16 q tcid2 T node preceding htcid2 contact contradicting 31 As Then contacts W If f 1 tlast F f cid29q icid16 t icid16 f icid16 f icid16 f icid16 I 1 1 36 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 Fq f 2 q f i1 1 t i1 cid2 F f t i2 cid2 h tcid2 f 1 T q i1 q icid16 t icid16 f icid16 1 q t As f 2 ht ﬁnal cog f q h f 2 cog room hq cog unlike Example 276 Further ht contact W contacts W q icid16 cid16 F 1 cid16 q Then As T node tcid2 f 1 q ht ﬁnal cog I cid5 cid6 ht f icid16 1 δq icid16 cid5 cid6 ht F f δhq cid5 cid6 h f 1 ht δhq δ f 1 t δq icid16 cid5 f icid16 1 t icid16 cid6 ht f icid16 1 t icid16 But T node q icid16 If tlast f 1 cases depending relationship δ f 1 f 2 δt1 f 1 t icid16 If δ f 1 f 2 δt1 f 1 contact W different F f preceding f 1 q remaining option h f 1 h f 1 F f f unlike Example 276 Thus 2 h f 2 ﬁnal cog f cid16 1 cid16 q Thus h f 1 ht1 contact contradicting 31 As F node Next track location h f 2 As q room hq cog f icid16 1 1 f icid16 t icid16 cid5 t i1 1 cid6 h f 2 δhq δhq cid5 cid6 h f 2 F f δhq cid5 cid6 h f 1 h f 2 h f 2 t i1 1 δ f 1 f 2 δt1 f 1 δq p w1 f i1 1 But F node q i1 f 2 q f t i1 1 q i1 W f i1 1 cid5 t i1 1 f i1 1 cid6 q t1 F h f 1 f 2 If δ f 1 f 2 δt1 f 1 t icid16 cid16 1 cid16 q tcid2 T node preceding f 1 Thus h f 1 hold cid16 1 cid16 q htcid2 h f 2 contacts W contradicting 31 As F node preceding f 2 q f 1 remaining option h f 1 contact W h f 1 cid16 1 cid16 q Again track location h f 2 As q room hq cog Thus 2 h f 2 ﬁnal cog f f icid16 f t icid16 cid2 t icid16 cid2 f icid16 f icid16 1 2 cid5 cid6 t icid16 cid2 h f 2 δhq δhq cid5 cid6 h f 1 h f 2 δ f 1 f 2 δt1 f 1 δtcid2 f 1 δq icid16 cid5 t icid16 cid2 f icid16 1 cid6 On hand cid5 cid6 t icid16 cid2 h f 2 δhq δhq cid5 cid6 h f 1 h f 2 δ f 1 f 2 δtcid2 f 2 δq icid16 cid5 t icid16 cid2 f icid16 2 cid6 h f 2 f icid16 1 f icid16 2 But F node q icid16 37 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 f icid161 2 q icid161 t icid16 cid2 f icid16 1 f icid16 2 q icid16 W q h tcid2 f 1 f 2 F F 3F hq starts W ends Fq F f F f hq Fq W W Then hq properly intersects F neighbourhood W We hf room f 2 h f 1 hq h f 2 cid29hq h f 1 W We exclude possible locations hq Fq As f F f h f 1 argument case 1F F neighbourhood W place F neighbourhood W F f cid29hq 4F hq ends W F f hq F f hq hf F f Fq W W Then hq deﬁnitely properly intersects F neighbourhood W properly intersect F cid29hq h f 1 f 2 F node F f neighbourhood W As f h f 1 W We exclude possible locations h f 1 argument case 2F F neighbourhood W place F neighbourhood W Fq F f f 1 f F f We excluded possible locations B image hq potential subhomomorphism h q I completes proof Lemma 277 cid2 63 Representing clauses shared literals Suppose ψ 3CNF nψ clauses form cid21 cid22 cid23 cid2i literal We build ABox Aqψ follows We let n nψ 22q 1 propositional variable p ψ fresh nbike Bp having n cogwheels W p satisfying conditions Lemma 277 We pick nodes v1 v2 v3 q vz T node F node v1 v2 v3 We nodes special triple q Then clause c cid2c 3 special 1 triple cq replace F T labels A Then z 1 2 3 glue vc 3 ψ proceed follows We fresh copy cq q consider copies vc z contact 2 vc W p cid2c 2 1 vc cid2c p1 W p p2 W p iff cid2c z iff cid2c z p vz F node q cid2c z p vz T node q cid2c z p vz T node q p vz F node q For example q looks like lefthand picture c p q r obtain graph shown righthand picture ncogwheels depicted circles q T v1 F v2 F v3 A W p A Wq A Wr cq 1 vc 2 vc We vc 3 cconnections cneighbourhood consists contacts ncogwheels contactdistance cconnection q For different clauses c c connections sharing ncogwheel W way c c neighbourhoods disjoint F Tneighbourhoods W We n nψ 22q 1 We treat resulting labelled graph ABox ψ ngadget q denote Aqψ Clearly size Aqψ polynomial sizes q ψ The following lemma consequence deﬁnition Aqψ easy direction Lemma 277 pick c c cid3 cid3 cid3 Lemma 278 If cov A Aqψ cid14 q ψ satisﬁable 38 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 I T contacts W p Proof Suppose I model cov A Aqψ I cid14 q As variable p ψ nbike Bp satisﬁes I conditions Lemma 277 contacts ncogwheel W p contacts W p cid2c 3 ψ 2 z 1 2 3 vz T node q vc Deﬁne assignment z z T clause c ψ arbitrary We claim welldeﬁned sense setting acid2c set ap T ap T Indeed suppose Suppose cid2c1 z1 clause c1 cid2c2 z2 clause c2 I Case 1 vz1 T node q vc1 z1 I As I cid14 q clause c cid2c 1 I T p p2 construction vc1 vz F node q vc z contacts W p T cid2c F I F F F I As ap T implies cid2c1 z1 F z2 contact W p On hand ap T implies cid2c2 z2 I F p1 contacts W p I vc2 z2 contact W p p2 contacts W p z1 contact p If vz2 contradiction T I ncogwheel W p So contacts W p T node q vc2 F z2 And vz2 F node q vc2 z2 contradiction vc2 T I I Case 2 vz1 F node q vc1 z1 Thus assignment welldeﬁned makes true literal clause ψ cid2 This case similar left reader T I It remains ﬁnd conditions Aqψ guarantee converse Lemma 278 holds So suppose ψ satisﬁable assignment We deﬁne model Ia cov A Aqψ follows For variable p ψ contacts W p contacts W p F T Ia contacts W p Ia contacts W p F T Ia ap T Ia ap F 33 We aim ﬁnd conditions Aqψ imply Ia cid14 q Just like case ABoxes built copies q looking conditions exclude possible locations Aqψ image hq potential sub homomorphism h q Ia The deﬁnition Aqψ allows ﬂexibility choice special triple v1 v2 v3 q choices contacts cneighbourhoods clause c If choose contacts way 22 23 conditions Lemma 277 hold 33 Lemma 277 know hq intersect cq clause c Therefore intersection hq ncogwheels cneighbourhoods Further claim vz T node q vc z clause c ψ subhomomorphism h q Ia hvz vc Ia W p p dually symmetric It follows acid2c 34 In particular q Ia subhomomorphism mapping q cq Indeed suppose contrary p vz F node q subhomomorphism h c Suppose acid2c T vc z The case z cid2c z By 34 hq properly intersect ncogwheels Wc 3 glued cq sense hq Wc z z 1 2 3 z Also Lemma 273 assume hq properly intersects Wc z cid3 cneighbourhood Wc neighbourhoods disjoint unique c hq properly c c intersecting ncogwheels Wc 1 Wc 3 glued cq properly intersect It easy check 34 options hq covered cases 1c 6c Fig 9 z 1 2 3 By 33 Lemma 273 assume hq cid5 Wc z cid14 T z 1 2 3 contrary satisfying ψ z T If cid2c Ia W p F impossible hvz vc z node hq Wc z z 1 2 3 z As c cid14 c 2 Wc 2 Wc 1 Wc cid5 vc z z cid3 We aim 2CQ suitable contact choices exist actually providing algorithm given 2CQ q describes contact choices large n suitable 3CNF ψ ψ ngadget constructed copies q Just like case bikes different potential locations homomorphic image place different constraints choices By following heuristics choices H1 H2 able use techniques bikes proof Lemma 277 In light H1 algorithm chooses v1 t1 This assumption t1 f 1 cf 21 t1 node followed F T nodes tlast f 1 2CQ q q contains F nodes T nodes Similarly v3 chosen f 2 general f 2 node preceded F T nodes t1 f 1 And v2 chosen middle nodes present tlast f 1 The choice smaller tlast f 1 v2 motivated H2 However 3CNF ψ introduces variables constraint In order reduce search space choices heuristics H3 Given 2CQ q assignment satisfying 3CNF ψ algorithm describing choices suitable achieving Ia cid14 q q choices depend ψ q 39 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 1c hq starts W1 hv1 hq vc 1 2c hq starts cq ends W1 vc 1 W1 hq vc 2 W2 vc 3 W3 3c hq starts W2 hv2 cid29hq vc 2 vc 1 W1 5c hq starts W3 vc 1 W1 vc 2 W2 vc 2 W2 hq vc 3 W3 vc 3 W3 cq cq hq vc 1 W1 vc 2 W2 4c hq ends W2 vc 2 cid29hq hv2 hq vc 1 W1 vc 2 W2 hq cq 6c hq ends W3 vc 3 hq hv3 vc 1 W1 hq vc 2 W2 cq cq cq vc 3 W3 vc 3 W3 vc 3 W3 Fig 9 Possible locations hq intersecting cq H4 The algorithm chooses contacts cneighbourhoods Aqψ uniformly depending particular clause c q Yet diﬃculty 34 weaker 32 It exclude cases h ﬁxes cconnections Say case 3c happen hq intersects W2 W3 properly intersect W1 hv2 vc 3 hold The following example shows need excluding situation force particular contact choices cconnection middle cogwheel half cneighbourhood 2 hv3 vc Example 279 Consider 2CQ Example 272 q T t1 F f 1 T t2 T t3 F f 2 According f 1 tlast t3 choose v2 f 1 v1 t1 v3 f 2 Suppose clause c c f 1 2f x2 copy 2q x2 q Then argument contact middle cogwheel W2 glued vc 2 Example 276 shows choose 2f x2 2 f x2 2 Now choices 2t x2 However choose 2t x2 2t x2 2 Ia contacts W1 W2 W3 Ia following h q Ia homomorphism case 3c Fig 9 F 1 2f x2 2 f x2 1 2t x2 2t x2 T 2q x2 F 2q x21 W2 2t x21 2t x2 2f x21 cq T T q T T T Ia c f 2 F Ia c f 1 F 2 f x2 2 W3 F T T F Therefore 2t x2 2t x2 3 hold Let continue contact choices cneighbourhood W2 In light Remark 274 want stick default contact choice 2q x21 choose 2f x21 2 f x21 Then 2t x21 2q x2 However case 23 fails h q Ia homomorphism shown Example 272 In fact repeating argument obtain choose 2f x2k 2 f x2k 2f x21 22 choose 2t x21 2t x21 2t x2k 2t x2k k q 1 1 1 2 3 40 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 In Lemma 2710 general algorithmic solution constraint lines H1H4 solution converse Lemma 278 holds In order formulate solution need ﬁx notation cneighbourhoods With slight abuse notation light H4 given clause c ψ denote z cq glued For z 1 2 3 Wz built qcopies W1 W2 W3 ncogwheels node vc z cq contact zfxz ztxz1 Wz zq1 zqn cconnection Wz obtained glueing node vc modulo n cq vc 1 W1 vc 2 W2 vc 3 W3 zq xz1 zq xz zq xz vc z zf xz zt xz1 Wz zq xz1 zq xz1 zq xz2 For node x q denote cx copy x cq 1 n z 1 2 3 denote zxi copy x zq Recall k let tk fk denote kth T node F node q In particular tlast1 denotes T node q tlast T node We assume t1 f 1 cf 21 let tcid2 denote T node preceding f 1 Lemma 2710 Given 3CNF ψ let Aqψ ψ ngadget n nψ 22q 1 built nbikes satisfying conditions Lemma 277 Suppose Aqψ following hold special triple v1 t1 v2 cid8 f 1 tlast f 1 tlast tlast f 1 v3 f 2 clause c ψ following hold cneighbourhood W1 cid8 1t x1 1t x1cid2 1f x1 1t k 1t k 1 1f k 1 f k 1 f 1 tlast tlast f 1 1 f x1 1 1 f x1 2 k x1 q k x1 q following hold cneighbourhood W2 k q 1 cid16 q f 1 tlast T node tcid3 tcid3 f 2 δtcid3 f 2 δt1 f 1 cid8 1 2t x2k 2f x2k 2t x2k cid3 2t x2k 2 f x2k 2 2 f x2 2 2 f x2k 2t x2cid16 cid2 2t x2cid16 2f x2cid16 2 f x2cid16 2t x2cid16 cid8 1 1 1 3t x3 3t x3 1 3t x3k 3t x3k 1 cid8 3t x3cid16 cid8 3f x3cid16 1 3t x3cid16 3t x3cid16 cid2 3 f x3cid16 3 f x3cid16 2 1 f 1 tlast k 0 tlast f 1 δtlast1 tlast δtlast f 1 f 1 tlast tlast f 1 3f x3 3 f x3 2 3f x3k 3 f x3k tlast f 1 δ f 1 f 2 δt1 f 1 0 k q 1 tlast f 1 δ f 1 f 2 δt1 f 1 1 cid16 q following hold cneighbourhood W3 Then Ia cid14 q assignment satisfying ψ 41 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 It straightforward check ψ ngadgets Aqψ satisfying conditions lemma exist As ψ nψ clauses n nψ 22q 1 different clauses c c neighbourhoods ncogwheel W kept disjoint F Tneighbourhoods W Thus choices present lemma interfere choices Lemma 277 Also choosing corresponding copies t1 f 2 contacts outside F T cneighbourhoods conditions 22 23 hold cogwheels Aqψ c c cid3 cid3 Proof Suppose assignment satisfying ψ model cov A Aqψ deﬁned 33 In light H4 use speciﬁcs clause c explicit information particular labelings 3 Ia However 33 implies attached cogwheels W1 W2 W3 cconnections vc 1 vc represents truthvalue 2 vc z 1 2 3 contacts Wz T Ia F Ia 35 Now proof Lemma 2710 excluding possible locations Aqψ image hq potential sub homomorphism h q Ia As explained 34 Lemmas 273 277 cases 1c 6c Fig 9 remain location hq need possible In light H2 track location h f 1 possible try reduce cases cases proof Lemma 277 bikes 1c hq starts W1 hv1 hq vc 1 vc 1 hq vc 2 W1 W2 cq vc 3 W3 Then hq deﬁnitely properly intersects cneighbourhood W1 properly intersect cneighbourhoods W2 W3 It follows hv1 hq vc c f 1 We exclude possible locations h f 1 argument case 1T proof Lemma 277 cneighbourhood W1 place Tneighbourhood W 1 h f 1 cq h f 1 cq 2c hq starts cq ends W1 vc 1 hq vc 2 W1 W2 cq vc 3 W3 Then hq properly intersects cneighbourhood W1 We exclude possible locations h f 1 argument case 2T proof Lemma 277 cneighbourhood W1 place Tneighbourhood W 3c hq starts W2 hv2 cid29hq vc 2 vc hq 1 vc 2 W1 W2 cq vc 3 W3 Then hq deﬁnitely properly intersects cneighbourhood W2 properly intersect c neighbourhood W3 We consider cases f 1 tlast tlast f 1 2 As 2f x2k 2 f x2k If f 1 tlast v2 f 1 h f 1 cid29hq hold k ht h f 2 contacts W2 T node t 2t x2k 2t x2k contradicting 35 Since F node preceding f 2 q f 1 remaining option h f 1 h f 1 2 f x2k contact W2 k q Now track location ht1 We k q h f 1 2 f x2k c f 1 vc 1 2 2 cid5 ht1 2 f x2k 2 cid6 δhq δhq cid5 cid6 ht1 h f 1 δt1 f 1 δ y f 2 δ2q x2 k cid5 2yx2k 2 f x2k 2 cid6 36 y node q y f 2 δ y f 2 δt1 f 1 Consider cases depending y T node If y T node tcid3 2t x2k 2t x2k cid3 ht1 2t x2k 36 Thus ht1 contact contradicting 35 fact h f 1 contact W2 If y T node tcid3 2t x2k 2t x2k 1 δ y f 2 δt1 f 1 δt1 f 2 Then ht1 2yx2k follows 36 But 2yx2k T node While y cid29 f 1 f 1 y possible surely t1 y If tlast f 1 v2 tlast If follows hv2 cid29hq vc c f 1 As F node preceding c f 1 cq h f 1 W2 h f 1 c f 1 We exclude possible locations h f 1 2 h f 1 cq h f 1 cid29cq 42 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 argument case 3T proof Lemma 277 cneighbourhood W2 place Tneighbourhood W 4c hq ends W2 vc 2 hq cid29hq hv2 vc 2 vc 3 vc 1 cq W1 W2 W3 Then hq deﬁnitely properly intersects cneighbourhood W2 properly intersect c neighbourhood W1 We consider cases f 1 tlast tlast f 1 If f 1 tlast v2 f 1 vc 2 c f 1 cid29hq h f 1 h f 1 W2 We exclude possible locations h f 1 argument case 2F proof Lemma 277 cneighbourhood W2 place F neighbourhood W If tlast f 1 v2 tlast As assumption hq ends W2 vc 2 cid29hq htlast hq h f 1 We exclude possible locations h f 1 argument case 4T proof Lemma 277 cneighbourhood W2 place Tneighbourhood W cid29hq hv2 follows vc 2 5c hq starts W3 vc 1 W1 vc 2 W2 hq cq vc 3 W3 Then hq properly intersects cneighbourhood W3 We hv3 cid29hq vc 3 3 h f 1 W3 We exclude possible room hq cq As v3 f 2 h f 1 hq h f 2 cid29hq vc locations h f 1 argument case 1F proof Lemma 277 cneighbourhood W3 place F neighbourhood W 6c hq ends W3 vc 3 vc 1 W1 hq hv3 hq vc 2 W2 cq vc 3 W3 Then hq deﬁnitely properly intersects cneighbourhood W3 properly intersect hq h f 2 Therefore h f 1 cq c f 1 cq h f 1 cneighbourhood W1 W2 As v3 f 2 c f 2 vc 3 cid29hq h f 1 h f 1 W3 We As vc 2 exclude possible locations h f 1 argument case 2F proof Lemma 277 cneighbourhood W3 place F neighbourhood W c f 1 F node c f 1 c f 2 cq follows vc 3 cid29 cq We excluded possible locations Aqψ image hq potential subhomomorphism h q Ia completes proof Lemma 2710 cid2 To complete proof Theorem 27 given 3CNF ψ nψ clauses set n nψ 22q 1 ψ ngadget Aqψ satisfying conditions Lemma 2710 By Lemmas 278 2710 obtain cov A Aqψ cid14 q iff ψ satisﬁable 7 Conclusion This article contributes nonuniform approach ontologybased data access whichbroadly conceivedalso cludes optimisation datalog disjunctive datalog programs There distinctive directions research area detailed references Section 13 I Finding general automatatheoretic modeltheoretic algebraic characterisations OMQs given data com plexity rewritability type investigating computational complexity checking characterisations As turned standard DL ontology languages monadic disjunctive datalog programs complexity deciding FO datalogrewritability ranges ExpTime 3ExpTime II Designing practical possibly incomplete rewriting approximation algorithms For example algorithm 28 successfully rewrites given disjunctive datalog program equivalent plain datalog program fails decide input datalog rewritable III Obtaining explicit classiﬁcations natural restricted families OMQs instance binary chain datalog sirups 47 Apart supplementing II results direction help pinpoint key sources high complexity I identify interesting better behaved classes OMQs develop ﬁne methods establishing data complexity bounds OMQ answering 43 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 This article contributes directions I III We introduce classes rudimentary OMQs called d ddsirups capture diﬃculties general OMQs disjunctive DL ontology general monadic plain disjunctive datalog queries Indeed syntactically simple seemingly inexpressive dsirups reveal complex unexpected behaviour answering cid2p 2 complete combined complexity requires ﬁnd ing exponentialsize resolution proofs general ii deciding FOrewritability turns 2ExpTimehard 44as hard deciding FOrewritability arbitrary monadic datalog querieswith iii nonrecursive datalog positive existential UCQ rewritings single double tripleexponential size worst case respectively Thus derstanding behaviour dsirups challenging fundamental developing OBDA expressive ontologies note dsirups constitute new interesting class CSPs The proofs negative results mentioned point culprits possibly intersecting classes F T covering axiom F x T x Ax multiple binary relations pair variables query We demonstrate elimination culprits lead nontrivial OMQ classes admit complete explicit classiﬁca tions need development new methods tricky laborious proofs Our main achievement explicit AC0 NL P coNPtetrachotomy pathshaped ddsirups disjoint F T required new tech niques establishing membership NL proving P especially coNPhardness Incidentally bike technique proving coNPhardness shows algorithm 28 mentioned II complete pathshaped ddsirups We believe techniques wider classes OMQs witnessed AC0 L NLhardness trichotomy ditreeshaped ddsirups 44 71 Next steps Interesting challenging problems arising research abundant 1 Find complete explicit classiﬁcations following families OMQs dsirups path CQs contain F T twins ii undirected pathshaped iii ditree v undirected treeshaped dd dsirups Also consider ddsirups covcid15 q cov cid15 q total covering x F x T x 2 Settle tight complexity deciding FO types rewritability arbitrary dsirups ii ddsirups We conjecture harder ii general 3 Identify complexity deciding FO types rewritability ontologies Schema org ii DLLitekrom DLLitebool 67 Ontologies allow multiple disjunctions covering number classes ii allow restricted existential quantiﬁcation righthand implications 4 Analyse size FOrewritings OMQs disjunctive axioms starting d ddsirups Could FOrewritings substantially succinct NDL PErewritings cf 96 Theorem 61 Note succinctness problem OMQ rewritings closely related circuit complexity 9550 5 Consider data complexity rewritability problems d ddsirups multiple answer variables lead simpler classiﬁcations indicated 51 6 Investigate interconnections ddsirups CSPs starting 3036 aim transferring results formalism 7 Using techniques developed article establishing lower data complexity bounds identify classes OMQs rewriting algorithms ones 3828 complete Declaration competing The authors declare known competing ﬁnancial interests personal relationships appeared inﬂuence work reported paper Acknowledgements The work O Gerasimova funded RFBR project number 203190123 The work V Podolskii supported HSE University Basic Research Program The work M Zakharyaschev supported EPSRC UK grant EPS032282 We grateful Frank Wolter remarks helped improve article Thanks anonymous referees careful reading valuable comments constructive suggestions References 1 A Schaerf On complexity instance checking problem concept languages existential quantiﬁcation J Intell Inf Syst 2 1993 265278 2 F Baader D Calvanese DL McGuinness D Nardi PF PatelSchneider Eds The Description Logic Handbook 2 ed Cambridge University Press 2007 3 F Baader I Horrocks C Lutz U Sattler An Introduction Description Logic Cambridge University Press 2017 4 A Poggi D Lembo D Calvanese G De Giacomo M Lenzerini R Rosati Linking data ontologies J Data Semant X 2008 133173 5 D Calvanese G De Giacomo D Lembo M Lenzerini R Rosati Tractable reasoning eﬃcient query answering description logics DLLite family J Autom Reason 39 2007 385429 44 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 6 G Xiao D Calvanese R Kontchakov D Lembo A Poggi R Rosati M Zakharyaschev Ontologybased data access survey J Lang Ed Proc IJCAI 2018 2018 pp 55115519 ijcai org 7 G Xiao L Ding B Cogrel D Calvanese Virtual knowledge graphs overview systems use cases Data Intell 1 2019 201223 8 S Abiteboul R Hull V Vianu Foundations Databases AddisonWesley 1995 9 N Immerman Descriptive Complexity Springer 1999 10 C Civili R Rosati A broad class ﬁrstorder rewritable tuplegenerating dependencies Proc 2nd Int Datalog 20 Workshop Lecture Notes Computer Science vol 7494 Springer 2012 pp 6880 11 G Gottlob G Orsi A Pieris Query rewriting optimization ontological databases ACM Trans Database Syst 39 2014 2512546 12 J Baget M Leclère M Mugnier E Salvat On rules existential variables walking decidability line Artif Intell 175 2011 16201654 13 M König M Leclère M Mugnier M Thomazo Sound complete minimal UCQrewriting existential rules Semant Web 6 2015 451475 14 U Hustadt B Motik U Sattler Data complexity reasoning expressive description logics LP Kaelbling A Saﬃotti Eds Proc IJCAI 2005 Professional Book Center 2005 pp 466471 15 R Rosati On conjunctive query answering EL D Calvanese E Franconi V Haarslev D Lembo B Motik A Turhan S Tessaris Eds Proc DL 2007 CEUR Workshop Proceedings vol 250 2007 CEURWS org 16 H PérezUrbina B Motik I Horrocks Tractable query answering rewriting description logic constraints J Appl Log 8 2010 186209 17 T Eiter M Ortiz M Šimkus T Tran G Xiao Query rewriting HornSHIQ plus rules J Hoffmann B Selman Eds Proc AAAI 2012 AAAI 18 D Gabbay A Kurucz F Wolter M Zakharyaschev ManyDimensional Modal Logics Theory Applications Studies Logic Foundations 19 B Motik Reasoning description logics resolution deductive databases PhD thesis Karlsruhe Institute Technology Germany 2006 20 U Hustadt B Motik U Sattler Reasoning description logics reduction disjunctive datalog J Autom Reason 39 2007 351384 21 B Cuenca Grau B Motik G Stoilos I Horrocks Computing datalog rewritings Horn ontologies F Rossi Ed Proc IJCAI 2013 IJCAIAAAI Press 2012 Mathematics vol 148 Elsevier 2003 2013 pp 832838 22 D Hovland R Kontchakov MG Skjæveland A Waaler M Zakharyaschev Ontologybased data access Slegge C dAmato M Fernández VAM Tamma F Lécué P CudréMauroux JF Sequeda C Lange J Heﬂin Eds Proc ISWC 2017 Part II Lecture Notes Computer Science vol 10588 Springer 2017 pp 120129 23 D Carral C Feier B Cuenca Grau P Hitzler I Horrocks ELifying ontologies S Demri D Kapur C Weidenbach Eds Proc IJCAR 2014 Lecture Notes Computer Science vol 8562 Springer 2014 pp 464479 24 Y Zhou B Cuenca Grau Y Nenov M Kaminski I Horrocks PAGOdA payasyougo ontology query answering datalog reasoner J Artif Intell Res 54 2015 309367 25 E Botoeva D Calvanese V Santarelli DF Savo A Solimando G Xiao Beyond OWL 2 QL OBDA rewritings approximations D Schuurmans MP Wellman Eds Proc AAAI 2016 AAAI Press 2016 pp 921928 26 A Bötcher C Lutz F Wolter Ontology approximation Horn description logics S Kraus Ed Proc IJCAI 2019 2019 pp 15741580 ijcai org 27 E Kharlamov D Hovland MG Skjæveland D Bilidas E JiménezRuiz G Xiao A Soylu D Lanti M Rezk D Zheleznyakov M Giese H Lie YE Ioannidis Y Kotidis M Koubarakis A Waaler Ontology based data access Statoil J Web Semant 44 2017 336 28 M Kaminski Y Nenov B Cuenca Grau Datalog rewritability disjunctive datalog programs nonHorn ontologies Artif Intell 236 2016 90118 29 C Lutz F Wolter Nonuniform data complexity query answering description logics G Brewka T Eiter SA McIlraith Eds Proc KR 2012 30 M Bienvenu B Cate C Lutz F Wolter Ontologybased data access study disjunctive datalog CSP MMSNP ACM Trans Database 31 T Feder MY Vardi The computational structure monotone monadic SNP constraint satisfaction study datalog group theory 32 AA Bulatov A dichotomy theorem nonuniform CSPs C Umans Ed Proc FOCS 2017 IEEE Computer Society 2017 pp 319330 33 D Zhuk A proof CSP dichotomy conjecture C Umans Ed Proc FOCS 2017 IEEE Computer Society 2017 pp 331342 34 C Lutz L Sabellek Ontologymediated querying description logic EL trichotomy linear datalog rewritability C Sierra Ed Proc IJCAI 35 C Lutz L Sabellek A complete classiﬁcation complexity rewritability ontologymediated queries based description logic EL CoRR 36 C Feier A Kuusisto C Lutz Rewritability monadic disjunctive datalog MMSNP expressive description logics Log Methods Comput Sci 15 37 P Hansen C Lutz I Seylan F Wolter Eﬃcient query rewriting description logic EL Proc IJCAI 2015 AAAI 2015 pp 30343040 38 M Kaminski B Cuenca Grau Suﬃcient conditions ﬁrstorder datalog rewritability ELU T Eiter B Glimm Y Kazakov M Krötzsch Eds Proc DL CEUR Workshop Proceedings vol 1014 2013 pp 271293 CEURWS org 39 S Arora B Barak Computational Complexity A Modern Approach 1st ed Cambridge University Press 2009 40 SS Cosmadakis PC Kanellakis Parallel evaluation recursive rule queries A Silberschatz Ed Proc PODS 1986 ACM 1986 pp 280293 41 MY Vardi Decidability undecidability results boundedness linear recursive queries C EdmondsonYurkanan M Yannakakis Eds Proc PODS 1988 ACM 1988 pp 341351 42 G Gottlob CH Papadimitriou On complexity singlerule datalog queries Inf Comput 183 2003 104122 43 PC Kanellakis Elements relational database theory J van Leeuwen Ed Handbook Theoretical Computer Science Volume B Formal Models Semantics Elsevier MIT Press 1990 pp 10731156 44 S Kikot A Kurucz V Podolskii M Zakharyaschev Deciding boundedness monadic sirups Proc PODS 2021 ACM Press 2021 45 SS Cosmadakis H Gaifman PC Kanellakis MY Vardi Decidable optimization problems database logic programs Proc STOC 1988 1988 pp 477490 46 M Benedikt B Cate T Colcombet M Vanden Boom The complexity boundedness guarded logics Proc LICS 2015 2015 pp 293304 47 FN Afrati CH Papadimitriou The parallel complexity simple logic programs J ACM 40 1993 891916 48 SS Dantchev S Riis Planar tautologies hard resolution Proc FOCS 2001 IEEE Computer Society 2001 pp 220229 49 M Alekhnovich Mutilated chessboard problem exponentially hard resolution Theor Comput Sci 310 2004 513525 50 M Bienvenu S Kikot R Kontchakov V Podolskii M Zakharyaschev Ontologymediated queries combined complexity succinctness rewritings circuit complexity J ACM 65 2018 2812851 51 A Hernich C Lutz A Ozaki F Wolter Schemaorg description logic Q Yang MJ Wooldridge Eds Proc IJCAI 2015 AAAI Press 2015 pp 30483054 52 JD Ullman Principles Database KnowledgeBase Systems Volume II Computer Science Press 1989 53 O Gerasimova S Kikot A Kurucz V Podolskii M Zakharyaschev A data complexity rewritability tetrachotomy ontologymediated queries covering axiom D Calvanese E Erdem M Thielscher Eds Proc KR 2020 2020 pp 403413 45 AAAI Press 2012 Syst 39 33 2014 144 SIAM J Comput 28 1998 57104 2017 2017 pp 11811187 ijcai org arXiv1904 12533 abs 2019 2019 O Gerasimova S Kikot A Kurucz et al Artiﬁcial Intelligence 309 2022 103738 54 JF Naughton Data independent recursion deductive databases A Silberschatz Ed Proc PODS 1986 ACM 1986 pp 267279 55 JD Ullman AV Gelder Parallel complexity logical query programs Algorithmica 3 1988 542 56 JF Naughton Minimizing functionfree recursive inference rules J ACM 36 1989 6991 57 R Ramakrishnan Y Sagiv JD Ullman MY Vardi Prooftree transformation theorems applications A Silberschatz Ed Proc PODS 1989 ACM Press 1989 pp 172181 58 YP Saraiya Linearizing nonlinear recursions polynomial time A Silberschatz Ed Proc PODS 1989 ACM Press 1989 pp 182189 59 K Wang Some positive results boundedness multiple recursive rules G Gottlob MY Vardi Eds Proc ICDT 1995 Lecture Notes Computer Science vol 893 Springer 1995 pp 383396 60 E Dantsin T Eiter G Gottlob A Voronkov Complexity expressive power logic programming ACM Comput Surv 33 2001 374425 61 YE Ioannidis A time bound materialization recursively deﬁned views A Pirotte Y Vassiliou Eds Proc VLDB 1985 Morgan Kaufmann 1985 pp 219226 62 R van der Meyden Predicate boundedness linear monadic datalog PSPACE Int J Found Comput Sci 11 2000 591612 63 JF Naughton Y Sagiv A decidable class bounded recursions MY Vardi Ed Proc PODS 1987 ACM 1987 pp 227236 64 GG Hillebrand PC Kanellakis HG Mairson MY Vardi Undecidable boundedness problems datalog programs J Log Program 25 1995 163190 65 J Marcinkowski Achilles turtle undecidable boundedness problems small DATALOG programs SIAM J Comput 29 1999 231257 66 H Gaifman HG Mairson Y Sagiv MY Vardi Undecidable optimization problems database logic programs J ACM 40 1993 683713 67 A Artale D Calvanese R Kontchakov M Zakharyaschev The DLLite family relations J Artif Intell Res 36 2009 169 68 F Baader S Brandt C Lutz Pushing EL envelope LP Kaelbling A Saﬃotti Eds Proc IJCAI 2005 Professional Book Center 2005 pp 364369 69 F Baader C Lutz B Suntisrivaraporn Eﬃcient reasoning EL B Parsia U Sattler D Toman Eds Proc DL 2006 CEUR Workshop Proceedings 70 F Baader S Brandt C Lutz Pushing EL envelope K Clark PF PatelSchneider Eds Proc OWLED 2008 DC Workshop OWL vol 189 2006 CEURWS org Experiences Directions 2008 71 A Calì G Gottlob T Lukasiewicz A general datalogbased framework tractable query answering ontologies J Web Semant 14 2012 5783 72 A Calì G Gottlob A Pieris Towards expressive ontology languages query answering problem Artif Intell 193 2012 87128 73 M Kaminski Y Nenov B Cuenca Grau Datalog rewritability disjunctive datalog programs applications ontology reasoning CE Brodley P Stone Eds Proc AAAI 2014 AAAI Press 2014 pp 10771083 74 D Trivela G Stoilos A Chortaras GB Stamou Optimising resolutionbased rewriting algorithms OWL ontologies J Web Semant 33 2015 3049 75 D Trivela G Stoilos A Chortaras G Stamou Resolutionbased rewriting hornSHIQ ontologies Knowl Inf Syst 62 2020 107143 76 M Bienvenu C Lutz F Wolter Firstorder rewritability atomic queries Horn description logics F Rossi Ed Proc IJCAI 2013 IJCAIAAAI 77 M Bienvenu P Hansen C Lutz F Wolter First orderrewritability containment conjunctive queries Horn description logics S Kambham pati Ed Proc IJCAI 2016 IJCAIAAAI Press 2016 pp 965971 78 P Barceló G Berger C Lutz A Pieris Firstorder rewritability frontierguarded ontologymediated queries J Lang Ed Proc IJCAI 2018 2018 pp 17071713 ijcai org Proc KR 2016 AAAI Press 2016 pp 207216 79 P Bourhis C Lutz Containment monadic disjunctive datalog MMSNP expressive description logics C Baral JP Delgrande F Wolter Eds 80 A Hernich C Lutz F Papacchini F Wolter Dichotomies ontologymediated querying guarded fragment ACM Trans Comput Log 21 81 YP Saraiya Polynomialtime program transformations deductive databases DJ Rosenkrantz Y Sagiv Eds Proc PODS 1990 ACM Press 1990 82 W Zhang CT Yu D Troy Necessary suﬃcient conditions linearize double recursive programs logic databases ACM Trans Database Syst 15 83 FN Afrati M Gergatsoulis F Toni Linearisability datalog programs Theor Comput Sci 308 2003 199226 84 TJ Schaefer The complexity satisﬁability problems RJ Lipton WA Burkhard WJ Savitch EP Friedman AV Aho Eds Proc STOC 1978 ACM 85 AA Bulatov P Jeavons AA Krokhin Classifying complexity constraints ﬁnite algebras SIAM J Comput 34 2005 720742 86 B Larose C Loten C Tardif A characterisation ﬁrstorder constraint satisfaction problems Log Methods Comput Sci 3 2007 87 P Hell J Nesetril Colouring constraint satisfaction complexity Comput Sci Rev 2 2008 143163 88 H Chen B Larose Asking metaquestions constraint tractability ACM Trans Comput Theory 9 2017 1111127 89 O Gerasimova S Kikot M Zakharyaschev Checking data complexity ontologymediated queries case study nonuniform CSPs Polyanna C Lutz U Sattler C Tinelli A Turhan F Wolter Eds Description Logic Theory Combination All That Lecture Notes Computer Science vol 11560 Springer 2019 pp 329351 90 R Gault P Jeavons Implementing test tractability Constraints 9 2004 139160 91 CL Chang RCT Lee Symbolic Logic Mechanical Theorem Proving 1st ed Academic Press 1973 92 L Egri B Larose P Tesson Symmetric datalog constraint satisfaction problems logspace Proc LICS 2007 IEEE 2007 pp 193202 93 M Grohe The complexity homomorphism constraint satisfaction problems seen J ACM 54 2007 11124 94 LJ Stockmeyer The polynomialtime hierarchy Theor Comput Sci 3 1976 122 95 G Gottlob S Kikot R Kontchakov V Podolskii T Schwentick M Zakharyaschev The price query rewriting ontologybased data access Artif Intell 213 2014 4259 96 B Rossman Homomorphism preservation theorems J ACM 55 2008 1511553 97 H Comon M Dauchet R Gilleron C Löding F Jacquemard D Lugiez S Tison M Tommasi Tree automata techniques applications Available 2013 pp 754760 2020 2012047 pp 132144 1990 459482 1978 pp 216226 httpwwwgrappa univlille3 fr tata 2007 98 C Papadimitriou Computational Complexity AddisonWesley 1994 46