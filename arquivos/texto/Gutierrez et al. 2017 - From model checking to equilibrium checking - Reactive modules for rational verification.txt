Artiﬁcial Intelligence 248 2017 123157 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint From model checking equilibrium checking Reactive modules rational veriﬁcation Julian Gutierrez Paul Harrenstein Michael Wooldridge Department Computer Science University Oxford United Kingdom r t c l e n f o b s t r c t Article history Received 2 July 2015 Received revised form 2 April 2017 Accepted 8 April 2017 Available online 12 April 2017 Keywords Complexity equilibria Reactive modules Temporal logic Model checking bestknown successful approach formally verifying systems satisfy speciﬁcations expressed temporal logic formulae In article develop theory equilibrium checking related distinct problem Equilibrium checking relevant multiagent systems components agents assumed acting rationally pursuit delegated goals concerned understanding temporal properties hold systems assumption agents select strategies equilibrium The formal framework use study problem assumes agents modelled Reactive Modules modelling language range practical model checking systems Each agent player Reactive Modules game speciﬁed nondeterministic guarded command program players goal speciﬁed temporal logic formula player desires satisﬁed A strategy player Reactive Modules game deﬁnes player selects enabled guarded commands execution successive rounds game For general setting investigate games players goals speciﬁed Linear Temporal Logic case assumed players choose deterministic strategies Computation Tree Logic case players select nondeterministic strategies For cases formally deﬁning game setting characterise complexity range problems relating Nash equilibria computation veriﬁcation existence Nash equilibrium checking given temporal formula satisﬁed Nash equilibrium We model present encode example games choices available players speciﬁed STRIPS planning operators 2017 Elsevier BV All rights reserved 1 Introduction Our main paper analysis concurrent systems composed multiple nondeterministic programs runtime program resolves nondeterminism rationally strategically pursuit individual goal speciﬁed formula temporal logic Since programs assumed acting strategically game theory provides natural collection analytical concepts systems 53 If apply gametheoretic analysis systems main questions answered systems computations produce computations produce constituent programs act rationally If interpret acting rationally mean choosing strategies resolving nondeterminism Nash equilibrium Corresponding author Email address mjwcsoxacuk M Wooldridge httpdxdoiorg101016jartint201704003 00043702 2017 Elsevier BV All rights reserved 124 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 question amounts asking possible computations produced equilibrium Further use temporal logic language expressing properties multiagent concurrent standard aided veriﬁcation community 20 interpret question temporal logic formulae satisﬁed computations arising selection strategies equilibrium We refer general problem equilibrium checking 75 Related questions previously considered science artiﬁcial intelligence 1423 293051138 However common feature previous work computational models basis analysis highly abstract particular directly based realworld programming models languages For example 29 authors deﬁne investigate iterated Boolean games iBG generalisation Boolean games 3637 agent exercises unique control set Boolean variables execution proceeds inﬁnite sequence rounds agent selecting valuation variables control round Each player goal speciﬁed formula Linear Temporal Logic LTL desires achieved The iterated Boolean games model simple natural provides compelling framework pose questions relating strategic multiagent interaction settings agents goals speciﬁed logical formulae However model arguably abstract distance realistic programming languages modelling languages discuss work related work section end article In brief main aim study framework limitations Speciﬁcally study gamelike systems players speciﬁed subset Reactive Modules language 2 widely modelling language practical model checking systems mocha 4 Prism 43 Reactive Modules intended support succinct highlevel speciﬁcation concurrent multiagent systems As Reactive Modules readily encode frameworks modelling multiagent systems multiagent STRIPS planning systems 10 The remainder article structured follows We begin following section motivating work particular arguing classical notion correctness limited value multiagent systems introducing idea equilibrium checking representing appropriate framework understand behaviour systems We survey logics LTL CTL semantic basis Kripke structures present srml sublanguage Reactive Modules use article develop formal semantics We introduce Reactive Modules games structure game arena speciﬁed Reactive Modules preferences players speciﬁed associating temporal LTL CTL goal formula player deﬁnes runs computation trees satisfy players goal We investigate complexity gametheoretic questions Reactive Modules games LTL CTL settings conclude discussing complexity expressiveness new framework relevant related work Table 2 end paper summarises ﬁndings Finally demonstrate wider applicability framework capture propositional STRIPS games cf 221225 MASTRIPS model Brafman Domshlak 10 Although largely selfcontained technical presentation necessarily terse readers ﬁnd useful familiarity temporal logics 2018 model checking 16 complexity theory 54 basic concepts noncooperative game theory 53 2 Motivation Our aim section motivate introduce idea equilibrium checking multiagent systems counter standard notion veriﬁcation model checking Many readers familiar material beg indulgence tell story entirety Correctness formal veriﬁcation The correctness problem widely studied problems science past ﬁfty years remains topic fundamental concern present day 9 Broadly speaking correctness problem concerned checking systems behave designer intends Probably important problem studied correctness domain formal veriﬁcation Formal veriﬁcation problem checking given program P correct respect given formal mathematical speciﬁcation ϕ We understand ϕ description behaviours designer judges acceptable program guarantees generate behaviour described ϕ deemed correctly implement speciﬁcation ϕ A key insight Amir Pnueli temporal logic useful language express formal speciﬁca tions behaviour 56 Pnueli proposed use Linear Temporal Logic LTL expressing desirable properties computations LTL extends classical logic tense operators X state F eventually G U 20 For example requirement enters crash state naturally ex pressed LTL formula Gcrash If let cid2P cid3 denote set possible computations produced program P let cid2ϕcid3 denote set state sequences satisfy LTL formula ϕ veriﬁcation LTL properties J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 125 Fig 1 Model checking A model checker takes input model representing ﬁnite state abstraction claim behaviour expressed temporal logic It determines claim true model practical model checkers provide counter example reduces problem checking cid2P cid3 cid2ϕcid3 Another key temporal formalism Computation Tree Logic CTL modiﬁes LTL preﬁxing tense operators path quantiﬁers A paths E path While LTL suited reasoning runs computational histories CTL suited reasoning transition systems encode possible behaviours Model checking The successful approach veriﬁcation temporal logic speciﬁcations model checking 16 Model checking starts idea behaviour ﬁnite state program P represented Kripke structure transition K P Now Kripke structures interpreted models temporal logic So example checking program P satisﬁes LTL property ϕ reduces problem checking ϕ satisﬁed path K P Checking CTL speciﬁcation ϕ simpler Kripke structure K P CTL model simply need check K P ϕ holds For illustration Fig 1 These checks eﬃciently automated cases In case CTL example checking K P ϕ holds solved time O K P ϕ 1520 LTL problem complex PSPACEcomplete 20 automata theoretic techniques solved time ϕ 69 result indicating approach feasible small speciﬁcations Since model O K P 2 checking paradigm ﬁrst proposed 1981 huge progress extending range systems amenable veriﬁcation model checking extending range properties checked 16 Multiagent systems We turn class systems concerned present paper The ﬁeld multiagent systems concerned theory practice systems containing multiple interacting semiautonomous software components known agents 7262 Multiagent systems generally understood distinct conventional distributed concurrent systems respects important distinction purposes different agents assumed operating behalf different external principals delegate preferences goals agent Because different agents owned different principals assumption agents preferences aligned Correctness multiagent systems Now consider following question How interpret correctness formal veriﬁcation context multiagent systems In sense question easily answered We certainly think multiagent collection interacting nondeterministic programs nondeterminism representing idea agents choices available model number readily available model checking systems allow start reasoning possible computational behaviours principle exhibit But analysis entirely legitimate yield important insights misses key story relevant order understand multiagent This ignores fact agents assumed pursue preferences rationally strategically Thus certain behaviours possible principle arise practice arise rational choices agents 126 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 Fig 2 Equilibrium checking The key difference model checking input preferences components key question asked temporal property ϕ holds someall equilibria The classical formulation correctness naturally match multiagent setting single speciﬁcation ϕ correctness multiagent judged Instead agents carry speciﬁcation agent judged correct acts rationally achieve delegated preferences goals There single standard correctness judged attempting apply standard help understand behaviour So replace classical notion correctness context multiagent systems We argue concept rational veriﬁcation equilibrium checking Rational veriﬁcation equilibrium checking We believe researchers 5262 game theory provides appropriate analytical framework analysis multiagent systems Originating economics game theory essentially theory strategic interaction selfinterested entities 49 While mathematical framework game theory developed speciﬁcally study computational settings toolkit analytical concepts provides adapted applied multiagent settings A game sense game theory usually understood abstract mathematical model situation selfinterested players decisions A game speciﬁes decisionmakers game players choices available strategies For combination possible choices players game speciﬁes outcome result player preferences possible outcomes A key concern game theory try understand outcomes game assumption players choose rationally pursuit preferences To end solution concepts proposed Nash equilibrium probably bestknown A Nash equilibrium collection choices participant game player beneﬁt unilaterally deviating combination choices Nash equilibria like reasonable candidates outcome game unilaterally away Nash equilibrium result player worse clearly rational In general case given game Nash equilibrium multiple Nash equilibria It easy general setup maps multiagent systems setting players map agents players preferences deﬁned delegated goals choices available player correspond possible courses action taken agent Outcomes correspond computations runs agents preferences runs act try bring preferred runs With mind believe natural think following problem counterpart model checking classical veriﬁcation We given multiagent temporal logic formula ϕ representing property We ask ϕ satisﬁed run arise Nash equilibrium collection choices agents We equilibrium checking refer general paradigm rational veriﬁcation For illustration Fig 2 This idea captured following decision problem ENash Given Multiagent M temporal formula ϕ Question Is case ϕ holds computation M arise agents M choosing strategies form Nash equilibrium J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 127 The obvious counterpart decision problem ANash asks temporal formula ϕ satisﬁed computations arise result agents choosing strategies form Nash equilibrium A higherlevel question simply Nash equilibria NonEmptiness Given Multiagent M Question Does M Nash equilibria A Nash equilibria inherently unstable collection choices consider agents player preferred alternative choice Notice eﬃcient algorithm solving ENash imply eﬃcient algorithm NonEmptiness Finally consider question verifying given strategy proﬁle represents Nash equilibrium NEMembership Given Multiagent M strategy proﬁle cid4σ Question Is cid4σ Nash equilibrium The aim present article formulate investigate main computational questions relating equilibrium checking In order able study questions need ﬁx appropriate model multiagent systems way deﬁning preferences model As noted model multiagent systems adopt Reactive Modules 2 Our argument studying framework wellknown widely studied importantly widely framework modelling concurrent multiagent systems 46743 In short Reactive Modules represents realistic computational framework study questions This leaves question deﬁne preferences Our approach natural assume preferences deﬁned giving agent temporal logic goal agent required try accomplish The use logicallyspeciﬁed goals commonplace AI temporal logic widely goal speciﬁcation language AI planning community 25 Moreover approach ﬁts classic view correctness discussed temporal logic goal interpreted speciﬁcation agent satisfy 3 Preliminaries We dealing logics extend propositional logic Thus logics based ﬁnite set cid4 Boolean variables contain classical connectives implies iff Boolean constants cid9 truth falsity A valuation propositional logic given subset v cid4 intended interpretation x v means x true valuation v x cid12 v means x false v For propositional formulae ϕ write v ϕ mean ϕ satisﬁed v Let V cid4 2cid4 set valuations variables cid4 cid4 clear omit reference write V Let v valuation variables false Where v V let χv denote characteristic formula v satisﬁed valuation v cid2 cid2 χv x x xv xcid12v 31 Kripke structures We use Kripke structures 16 p 14 model dynamics systems A Kripke structure K cid4 given tuple K S S 0 R π S ﬁnite nonempty set states typical element s R S S left total cid14 R transition relation S Left totality means state s S state s Moreover S 0 S set initial states π S V valuation function assigning valuation π s s S See Fig 3 illustration Kripke structure cid4 x y Where K S S 0 R π Kripke structure cid4 cid7 cid4 denote restriction K cid7 K cid7 K cid7 S S 0 R π cid7 K valuation function π cid7 deﬁned follows π cid7 s π s cid7 We size Kripke structure K denoted K S R π cid14 S s s ρ π ρ0 π ρ1 π ρ2 32 Computation runs A run Kripke structure K sequence ρ s0 s1 s2 states t N st st1 R Using square brackets parameters referring time points let ρt denote state assigned time point t N run ρ We ρ srun ρ0 s A run ρ K ρ0 S 0 referred initial run Thus example Fig 3 s0 s0 s2 s3 s3 s3 s2 s3 s1 s0 s1 s0 runs initial run Let runsK s 128 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 indicates cid14 R The annotations inside vertices indicate propositional variables set true respective state set false Fig 3 A Kripke structure states s0 s1 s2 s3 initial states An arrow state s state s s s x indicates variable x set false cid14 set sruns K let runsK set initial runs K Notice run ρ runsK sequence states Every sequence induces inﬁnite sequence ρ V ω valuations given refer computation run In example Fig 3 ﬁnd x y x y x computation run instance y x x y x y The set sequences sequences valuations corresponding runs runsK denote runsK Given cid7 cid4 ρ N V cid4 denote restriction ρ cid7 ρcid7 ρcid7 t ρt cid7 t N We refer ﬁnite preﬁx run partial run denote partial runs cid10 cid10cid14 We extend notations runs restrictions runs initial runs restrictions partial runs obvious way 33 Linear temporal logic We use wellknown framework Linear Temporal Logic LTL express properties runs systems 204647 Formulae LTL essentially predicates inﬁnite sequences states LTL extends propositional logic modal tense operators X U Formally syntax LTL deﬁned respect set cid4 Boolean variables follows ϕ x ϕ ϕ ϕ Xϕ ϕ U ϕ x cid4 The remaining classical logical connectives deﬁned terms usual way Two key derived LTL operators F eventually G deﬁned terms U follows Fϕ cid9 U ϕ Gϕ Fϕ Given set variables cid7 let Ltlcid7 set LTL formulae cid7 variable set clear context write Ltl We interpret formulae LTL respect pairs ρ t ρ V ω run t N temporal index ρ Any given LTL formula true multiple time points run example formula Xp true time point t N run ρ p true run ρ time t 1 We write ρ t ϕ mean ϕ Ltl true time t N run ρ The rules deﬁning formulae true semantics LTL deﬁned follows x cid4 iff iff ρ t x ρ t ϕ ρ t ϕ ψ iff ρ t Xϕ ρ t ϕ U ψ iff iff x ρt case ρ t ϕ ρ t ϕ ρ t ψ ρ t 1 ϕ t t t cid14 t ρ t cid14 ρ t cid14cid14 t cid14cid14 ϕ cid14 ψ If ρ 0 ϕ write ρ ϕ ρ satisﬁes ϕ We ϕ ψ equivalent ρ ρ ϕ ρ ψ A formula ϕ Ltl satisﬁable run satisfying ϕ satisﬁed Kripke structure K satisﬁed initial runs satisﬁed ρ runsK As usual size LTL formula ϕ denoted ϕ number subformulae 34 Computation tree logic In order express branchingtime properties use Computation Tree Logic CTL branching temporal logic extends propositional logic tense modalities path quantiﬁers 20 Speciﬁcally CTL combines tense operators X J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 129 U path quantiﬁers A E path quantiﬁer A means paths E means path Formally given set cid4 Boolean variables syntax CTL deﬁned follows ϕ x ϕ ϕ ϕ AXϕ Eϕ U ϕ Aϕ U ϕ x cid4 Assuming remaining classical connectives deﬁned usual deﬁne remaining CTL operators follows EFϕ Ecid9 U ϕ AFϕ Acid9 U ϕ EXϕ AXϕ AGϕ EFϕ EGϕ AFϕ Let Ctlcid4 denote set CTL formulae cid4 cid4 clear context write Ctl CTL formulae interpreted respect pairs K s K Kripke structure s state K We write K s ϕ mean CTL formula ϕ Ctl satisﬁed state s K Formally Kripke structures K states s K x cid4 K s x K s ϕ K s ϕ ψ K s AXϕ K s Eϕ U ψ iff iff iff iff iff K s Aϕ U ψ iff x π s case K s ϕ K s ϕ K s ψ ρ runsK s K ρ1 ϕ ρ runsK s t N K ρt ψ t cid14 N 0 t cid14 t K ρt cid14 ϕ ρ runsK s t N K ρt ψ t cid14 t K ρt ϕ cid14 N 0 t If K s0 ϕ s0 S 0 write K ϕ K satisﬁes ϕ A CTL formula ϕ satisﬁable K ϕ K We ϕ ψ equivalent K ϕ iff K ψ K We size CTL formula ϕ denoted ϕ number subformulae 35 Computation trees We ﬁnd convenient adopt alternative view Kripke structures unfold transition relation R obtain computation tree We present associated technical deﬁnitions unfoldings First assume standard deﬁnitions word string preﬁx string Where w ﬁnite word alphabet denote preﬁxw set nonempty preﬁxes w A tree alphabet cid12 deﬁne nonempty set T cid12 nonempty strings cid12 T cid12 singleton root tree ii T closed nonempty preﬁxes preﬁxw T w T iii w T implies wa T cid12 The set T ﬁxes set vertices edge vertices w w w cid14 wa A statetree Kripke structure K S S 0 R π tree κ S s s cid14 T An stree statetree κ root s s κ Observe condition statetree w S stree exactly state s S If s S 0 stree called initial statetree By treesK s denote set strees treesK set initial statetrees Kripke structure K cid14 R ws wss cid14 T iff cid12 By computation tree understand tree set V cid4 valuations cid4 For cid7 cid4 κcid7 denote restriction κ cid7 u T κcid7 u κu cid7 Notice statetree κ Kripke structure K induces computation tree κ κ π s0 π sk s1 sk κ In case κ said computation tree K If κ initial statetree corresponding computation tree κ said initial computation tree The set initial computation trees K denote treesK We refer Fig 4 illustration concept By unfolding K S S 0 R π understand maximal initial computation tree K Let κ treesK initial statetree K s0 sk κ implies s0 sksk1 κ state sk1 sk R sk1 Then corresponding computation tree κ T V K unfolding K Each initial state s S 0 induces unique unfolding By unfoldK denote set unfoldings K 130 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 Fig 4 The ﬁgure left initial state tree Kripke structure Fig 3 The ﬁgure right corresponding computation tree vertex v 1 vk labelled element vk vertex x yx xy x y x y labelled x y 4 The simple reactive modules language In section language use modelling multiagent systems Simple Reactive Modules Language srml This language subset Reactive Modules Language rml 2 widely model checkers Mocha 4 Prism 43 The fragment use known srml introduced van der Hoek et al 67 study complexity model checking Alternatingtime Temporal Logic ATL 3 Our presentation srml largely follows 67 formal semantics srml hinted 67 complete formal semantics language showing srmldeﬁned systems induce computational runs Kripke structures The structures deﬁne agents srml known modules An srml module consists n interface deﬁnes module lists Boolean variables control module ii number guarded commands deﬁne choices available module state Guarded commands kinds initialising variables modules control init guarded commands updating variables subsequently update guarded commands A guarded command parts condition guard corresponding action deﬁnes update value variables control module The intuitive reading guarded command ϕ cid2 α condition ϕ satisﬁed choices available module execute action α It important note truth guard ϕ mean α executed enabled execution chosen An action α sequence assignment statements These statements deﬁne subset modules trolled variables updated guarded command executed If state guarded command given module enabled values variables module assumed remain unchanged state module choice Here example guarded command x y cid3 cid4cid5 cid6 guard cid2 x cid3 cid14 y cid4cid5 action cid14 cid9 cid6 The guard propositional logic formula x y guarded command enabled state variables x y value cid9 If guarded command chosen execution effect state variable x value y value cid9 The prime notation x means value variable x statement executed cid14 The following example illustrates concrete syntax modules module toggle controls x init cid9 cid2 x cid9 cid2 x update x cid2 x x cid2 x cid14 cid9 cid14 cid14 cid14 cid9 This module named toggle controls single Boolean variable x There init guarded commands update guarded commands The symbol syntactic separator The init guarded commands toggle deﬁne choices initialisation variable assign value cid9 value With respect update guarded commands ﬁrst command says x value cid9 corresponding choice assign value second command says x value subsequently assigned value cid9 In words module nondeterministically chooses value x initially subsequent rounds toggles value Notice example init commands nondeterministic update commands deterministic J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 131 41 Formal deﬁnition We formal deﬁnition semantics srml Formally guarded command g Boolean variables cid4 expression cid14 ϕ cid2 x 1 cid14 ψ1 x k ψk ϕ ψi propositional logic formula cid4 xi member cid4 Let guardg denote guard g Thus rule guardg ϕ We require variable appears left hand assignment cid14 cid14 statements guarded command x k distinct The intended interpretation g 1 x propositional formula ϕ evaluates true valuation v corresponding current state statement enabled execution executing statement means evaluating ψi current state v setting corresponding variable xi truth value obtained evaluating ψi way We x1 xk controlled variables g denote set ctrg If guarded commands module enabled values variables ctrg left unchanged In follows write skip abbreviation assignment leaves value variable controlled module unchanged Now recall init guarded command initialise values variables begins execution Full rml allows sophisticated initialisation schemes srml assumed guards init command cid9 init command enabled execution initialisation round We cid14 ψ right hand init command expressions ψ simply assume assignment statements x Boolean constants cid9 Formally srml module mi deﬁned triple mi cid4i Ii U cid4i cid4 ﬁnite set variables controlled mi Ii ﬁnite set initialisation guarded commands g Ii ctrg cid4i U ﬁnite set update guarded commands g U ctrg cid4i An srml arena A given n 2tuple A N cid4 m1 mn N 1 n set agents cid4 set Boolean variables N mi cid4i Ii U srml module cid4 deﬁnes choices available agent We require cid41 cid4n forms partition cid4 variable cid4 controlled agent variable controlled agent For propositional valuation v cid4 let v denote v cid4i The size srml arena A N cid4 m1 mn denoted A deﬁned m1 mn size module mi denoted mi given cid4i number guards assignment statements module polynomially bounded number guarded commands multiplied number variables controlled mi polynomially bounded Ii U cid4i For technical reasons introduce module mi cid4i Ii U auxiliary guarded command g skip given g skip guardg cid2 skip cid2 gU skip Thus executing g leaves values variables cid4i unchanged1 Given module mi cid4i Ii U valuation v deﬁne enablediv set update guarded commands enabled v proviso guarded commands U enabled g skip Formally enablediv g U g skip v guardg Observe deﬁned way enablediv contain g guarded commands U enabled2 skip unique element We deﬁne function speciﬁes semantics guarded commands Let g ϕ cid2 x ψk guarded command module mi controls variables cid4i Then execig v denotes propositional valuation variables cid4i result execution g v Notice execi gives valuation cid14 ψ1 x k cid14 1 skip introduced facilitate clear semantical deﬁnition behaviour reactive module point time 1 The command g update guarded commands enabled There course ways resolve issue For example require U contains g 2 Recall initial guarded commands enabled initially considerably complicated deﬁnition execi gi v given main text skip 132 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 module mi controls x module m j controls y init cid9 cid2 x cid9 cid2 x cid14 cid9 cid14 g1 g2 init cid9 cid2 y cid14 cid9 g1 j update x y cid2 x y cid2 x x cid2 x cid14 cid9 g3 cid14 x g4 cid14 y g5 update x y cid2 y x y cid2 y cid9 cid2 skip cid14 cid9 g2 j cid14 x g3 j g4 j Fig 5 The reactive modules mi m j Example 1 variables cid4i controlled mi specify value variables controlled modules Formally cid14 function execi deﬁned guarded command g ϕ cid2 x 1 execig v v ctrg xi x1 xk v ψi ψk valuation v follows cid14 ψ1 x k The behaviour srml arena obtained executing enabled guarded commands module syn chronous concurrent way A joint guarded command J g1 gn proﬁle guarded commands module We extend notations guarded commands joint guarded commands obvious way In particular write enabledv enabled1v enablednv Moreover use exec J v exec1g1 v execngn v denote execution joint guarded command J g1 gn valuation v Then deterministic execution srml arena proceeds rounds In ﬁrst round choices available module mi correspond initialisation guarded commands Ii mi module selects execution guarded command gi The result deﬁned execigi v The collection choices players deﬁnes choice mi initial valuation appears run In subsequent rounds choices available module mi correspond update guarded commands enabled execution valuation produced previous round Again player selects enabled guarded command execution collective result choices deﬁnes valuation appears run More formally deterministic execution srml arena A N cid4 m1 mn produces run ρ N V joint guarded command J I1 In ρ0 exec J v t 0 joint command J enabledρt 1 ρt exec J ρt 1 An srml arena A allow different runs depending joint guarded commands selected execution set runs arena A permits denote runs A An srml arena A N cid4 m1 mn executed nondeterministically case produces computation tree κ For computation tree joint initial guarded command J I1 In exec J v κ v 0 vk v 0 vk vk1 κ enabled J enabledvk exec J vk vk1 An arena A allow multiple computation trees set computation trees arena A allows denote trees A Since bisimilar trees satisfy set LTL CTL formulae simplify presentation results allow trees A treesK K Kripke structure closed bisimulation 38 To illustrate concepts consider following example SRML arena Example 1 Let cid4 x y consider srml arena A j x y mi m j agent controls x agent j controls y mi m j speciﬁed Fig 5 Thus enabledix y U enabledi x g5 enabledi y g4 enabledi g skip enabled jx y U j enabled j x g3 enabled j y g3 enabled j g2 j j g4 j g4 j g4 j j Furthermore observe execg1 j It follows x y x run runs A By similar argument readily appreciated g4 partial computation tree Fig 4 depicts initial computation tree contained trees A Fig 6 illustrates transitions valuations induced enabled guarded commands j x x execg j v x y execg3 j x y x execg5 g3 g3 g1 skip J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 133 Fig 6 Graphical depiction behaviour srml Arena Example 1 Here x y represents x valuation sets x true y false If edge valuations v w labelled guarded command gk player j gk player guarded command gm gm j enabledv execkgk j v w gm j 42 Kripkebased logicbased semantics Above presented formal semantics srml showing arenas executed deterministically leading runs nondeterministically leading computation trees We present semantics extensively follows In ﬁrst srml arenas induce Kripke structures second semantics srml arenas deﬁned terms temporal logic formulae Whenever enabled joint guarded command srml arena executed describes seen transitioning state Moreover set enabled commands state depends set propositional set true state states associated valuation viewed identical Thus srml arena induces ﬁnite Kripke structure For instance comparison Fig 6 reveals Kripke structure Fig 3 models behaviour srml arena Example 1 way At point useful remind reasons srml speciﬁcations allow succinct representation models capture possible inﬁnite computations distributed concurrent multi agent For technical reasons cases useful explicitly refer Kripke structure transition induced arena A N cid4 m1 mn structure denote K A general exponential size A Formally Lemma 2 Kripkebased semantics For arena A Kripke structure K A size exponential A set runs set computation trees runs A runsK A trees A treesK A Likewise Kripke structure K S S 0 R π exists srml arena A K containing single srml module mK cid4 S I K U K linear size respect K runs computation trees restricted cid4 exactly K runsK ρcid4 ρ runs A K treesK κcid4 κ trees A K Proof An algorithm construct Kripke structures K A srml arenas A given Fig 12 Appendix To prove second half lemma provide general explicit construction srml module based given Kripke structure Thus let K S S 0 R π π S V cid4 Deﬁne srml module mK Kripke structure K Fig 7 Observe construction introduces new variables addition variables cid4 Kripke structure Speciﬁcally introduce new variable state Kripke structure3 In module Fig 7 s follows s s hold All states set indicate currently states cid9 means initial state s0 In update rules transition relation R modelled state propositions p cid14 R rule indicating s choose s cid14 0 cid14 To size mK linear size K observe exactly controlled variable state Kripke structure exactly update guarded command pair R On hand fact K mK sets runs computation trees trees induced A K restricted variables cid4 immediately follows construction Fig 7 cid3 3 Observant readers note fact need introduce O log2 convoluted S 1 new variables construction mK case 134 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 module mK controls S cid4 init indicate state s0 S 0 propositions p hold q cid14 cid9 cid2 s cid4cid5 cid6 cid4π s0 q cid14 cid9 s 1 cid6 cid4cid5 cid3 Ss0 s1 cid14 cid9 p cid3 cid6 cid4cid5 π s0 p q cid3 cid14 0 update indicate states s propositions p hold q s cid2 s cid14 Rs cid14 cid14 cid9 s cid6 cid4cid5 cid3 Sscid14 si cid14 cid9 p cid6 cid4cid5 cid3 π scid14 p q cid3 cid14 cid4cid5 cid6 cid4π scid14 q Fig 7 Construction generating srml modules Kripke structures We present lemma useful subsequently The lemma shows ﬁrstly arena A possible deﬁne LTL formula ThLT L A acts LTL theory A sense runs satisfying ThLT L A exactly runs A Formally following result Lemma 3 Logicbased semantics For arena A size A LTL formula ThLT L A size polynomial A ρ N 2cid4 ρ runs A ρ ThLT L A Moreover ThLT L A computed time polynomial size A Proof Let A N cid4 m1 mn given arena We deﬁne formula ThLT L A conjunction formulae roughly speaking deﬁne effect initialisation update commands A respectively ThLT L A Init A Update A We begin deﬁning temporal predicate Unchcid7 asserts variables cid7 cid4 value state present state remain unchanged cid2 Unchcid7 x Xx xcid7 Then deﬁne effect single initialisation guarded command cid14 Initig cid9 cid2 x 1 cid14 b1 x k bk cid7 kcid2 l1 cid8 xl bl cid7 cid2 cid8 x xcid4i ctrg The expression Initi captures semantics initialisation commands write abbreviation exactly operator equivalent exclusiveor operator binary case cid9 Initi Initig cid10 cid7 Initig cid2 Initig cid14 cid8 gIi gIi gcid14Ii g Then Init A cid2 iN Initi Next deﬁne semantics update rules Again parts We ﬁrst deﬁne effect single update guarded command cid14 Updateig ϕ cid2 x 1 cid14 ψ1 x k ψk ϕ cid12 ψl Xxl Unchcid4i ctrg cid11 kcid2 l1 We deﬁne overall effect update commands Updatei cid2 gU guardg Unchcid4i cid9 gU Updateig J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 135 Finally Update A G cid2 iN Updatei In order ρ runs A ρcid4 ThLT L A proceeds induction Moreover ThLT L A polynomial size A immediately follows construction LTL formula computed time polynomial size A follows similarly cid3 Hereafter write Th A ThLT L A Moreover temporal logic formula ϕ characterises rep resents behaviour arena A ϕ logically equivalent Th A It easy constructions Th A arenas restricted characterise behaviour subsets single modules In particular write Thmi formula characterises behaviour module mi write Thmi formula characterises behaviour set modules m j j N cid12 j 5 Reactive modules games We introduce game model work remainder article The games consider called reactive modules games RMGs components The ﬁrst component arena deﬁnes players game variables control choices available players game state The arena RMG plays role analogous game form conventional game theory 53 p 201 deﬁnes players choices specify preferences players Preferences RMGs speciﬁed second component RMG player assumed associated goal γi RMGs temporal logic formula The idea players desire goal satisﬁed Moreover expect indifferent outcomes satisfy goal indifferent outcomes achieve Formally RMG G given structure G A γ1 γn A N cid4 m1 mn srml arena components deﬁned earlier N formula γi goal player represented temporal logic formula follows consider LTL CTL possible goal languages Games players goals expressed LTL formulae called LTL RMGs games players goals expressed CTL formulae called CTL RMGs Both types game played player selecting strategy σi deﬁne choices time In case LTL RMGs strategies deterministic CTL RMGs strategies nondeterministic Formal deﬁnitions given shortly Then player selected strategy σi strategy proﬁle cid4σ σ1 σn results game outcome given nature strategies A run inﬁnite word denoted ρ cid4σ LTL RMGs A Kripke structure denoted K cid4σ CTL RMGs In case outcome determine players goal satisﬁed Recall LTL formulae interpreted runs CTL formulae Kripke structures In order simplify notation game clear context write cid4σ ϕ ρ cid4σ ϕ ϕ Ltl K cid4σ ϕ ϕ Ctl Although strategies outcomes ρ cid4σ K cid4σ formally given deﬁned sections position deﬁne preference relation cid2i outcomes player goal γi For strategy proﬁles cid4σ cid4σ cid14 cid4σ cid2i cid4σ cid14 cid4σ cid14 γi implies cid4σ γi We player strictly prefers outcome σ σ cid14 σ cid14 cid2i σ indifferent σ σ cid14 σ cid14 cid2i σ As deﬁned players strictly prefer outcomes satisfy goals σ cid2i σ cid14 comes indifferent It easily established preference relations cid2i satisfy standard requirements reﬂexivity transitivity completeness play conventional role subsequent gametheoretic deﬁnitions 53 p 7 Here state lemma omit straightforward proof σ cid2i σ cid14 Lemma 4 Each relation cid2i deﬁned reﬂexive transitive complete We deﬁne standard solution concept Nash equilibrium RMGs For need small additional piece notation Given strategy proﬁle cid4σ σ1 σi1 σi σi1 σn strategy σ cid14 denote strategy proﬁle cid4σ strategy player σ cid14 player cid4σi σ cid14 136 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 cid4σi σ cid14 σ1 σi1 σ cid14 σi1 σn Then cid4σ said Nash equilibrium G players strategies σ cid14 player cid4σ cid2i cid4σi σ cid14 Hereafter let NEG set pure strategy Nash equilibria RMG G As usually case game theory possible NEG equilibria NEG contains multiple equilibria inﬁnitely equilibria If equilibria inherently unstable key properties interested checking form NonEmptiness problem described If multiple equilibria presents players game coordination problem need ﬁnd way ﬁxing equilibria One way players look focal points equilibria stand sense certain distinctive features 61 In RMGs setting example equilibrium satisﬁed goals players regarded particularly distinctive From point view designer existence multiple equilibria issue equilibria satisfy certain desirable properties This key computational problem study form ANash decision problem described Before studying LTL CTL RMGs explicit important assumptions underpin work The gametheoretic interpretation place RMGs essentially corresponds standard gametheoretic model noncooperative strategic form games common work assumptions First assume game common knowledge players players know arena A goals γi know players know Second assume players act rationally taking account fact players act rationally We emphasise common universal assumptions game theory Dropping interesting topic future work present paper 51 LTL reactive modules games Players LTL RMG possess LTL goals choose deterministic strategies The interaction parallel com position strategies determine unique run arena inﬁnite sequence statesvaluations LTL model interpret players goals Let ﬁx notation We write cid4i cid4 cid4i let V respectively V denote set valuations variables cid4i respectively cid4i For LTL RMGs model strategies ﬁnite state machines output technically deterministic Moore machines The input language machine representing strategy player corresponds choices players assignments variables players control V outputs variable assignments player implementing strategy V Representing strategies ﬁnite state machines number advantages First suggests ﬁnite representation scheme A mathematically abstract representation strategies model functions V functions map sequence choices players choice player The problem f V representation computational point view domain functions inﬁnite raises substantial diﬃculties want study decision problems strategies input Second appear ﬁnite state machine representations weaker mathematically abstract representation fact case concerned players goals expressed temporal logic formulae In cases need ﬁnite state machine strategies existence general strategy player accomplish players goal implies existence ﬁnite state machine strategy job Finally use ﬁnite state machine strategies fact standard literature iterated games 6 These related questions discussed 29 Now given A N cid4 m1 mn srml arena deﬁne deterministic strategy module mi cid4i Ii U structure σi Q q0 δi τi Q initial state Q ﬁnite nonempty set states q0 δi Q V Q transition function τi Q V output function Note particular strategies given module comply modules speciﬁcation For instance cid14 strategy mi prescribe mi set x δi τi module mi guarded command module mi form cid9 cid2 x true contingency Thus given arena A N cid4 m1 mn strategy σi Q q0 consistent mi following conditions satisﬁed f initial state q0 ii f q q gi enablediv τiq0 execig v g I1 In cid14 Q v v vi V δq vi q cid14 v τiq τiq cid14 execigi v J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 137 Fig 8 Three deterministic machine strategies The states represented vertices The labels inside vertices denote truth values player sets propositional variables corresponding state An arrow vertices indicates transition machine makes reading choices propositional variables controlled players given label Note deﬁned way strategies implicitly perfect information player completely correctly perceive choices players game Clearly ultimately strong assumption settings suﬃce ﬁrst approximation Also implicitly assuming strategies ﬁnite memory impose bounds memory size If strategy σi consistent module mi simply σi strategy mi Given srml arena A N cid4 m1 mn strategy proﬁle cid4σ σ1 σn consistent A σi consistent mi In remainder article restrict attention consistent strategies term strategy understood mean consistent strategy Finally strategy σi deterministic unique run induced cid4σ denote ρ cid4σ Example 5 Consider srml arena Example 1 deterministic strategies depicted Fig 8 First consider strategy proﬁle σi σ j gives rise computation run starts y x y x y Here machine strategy σi subsequently visits states q0 σ j states q0 j Both cid14 strategies comply respective modules For instance transition δqi q σi warranted basis cid14 cid14 y Notice x cid12 y execig5 x cid2 x x τ q guarded command g5 condition ii satisﬁed By contrast strategy σ cid14 cid14 y r0 observe g4 comply mi To consider transition δr y x y cid2 x execig4 cid14 x update guarded command enabled valuation y Yet τir0 y x condition ii require τir0 j q j q j q0 qi qi q x j q0 cid14 q0 52 CTL reactive modules games Players CTL RMG possess CTL goals nondeterministic strategies disposal Intuitively deterministic strategies seen controllers resolve nondeterminism choosing single computation path nondeterministic strategies understood supervisors disable undesirable behaviours leave remaining choices selectedexecuted nondeterministic manner Thus proﬁle cid4σ deterministic strategies associated unique inﬁnite sequence statesval uations proﬁle nondeterministic strategies associated unique inﬁnite tree statesvaluations nondeterministic choices cid4σ left tree The deﬁnition nondeterministic strategies simple generalisation deterministic ones transition function redeﬁned follows δi Q V 2Q Finally deﬁnitions outcome K cid4σ consistency Nash equilibrium respect proﬁles cid4σ consistent nondeterministic strategies straightforwardly extended 53 Example rational mutual exclusion Mutual exclusion algorithms MEAs play fundamental role distributed computing As suggests designed ensure mutual exclusion concurrent settings processes agents simultaneously enter critical region CR Classic examples MEAs Petersons algorithm 55 Lamports bakery algorithm 44 Ricart Agrawalas improvement 59 We algorithm deﬁned srml ensures mutual exclusion rational action guarantee nonstarvation Nonstarvation desirable property process agent perpetually denied access shared resource context MEAs resource question access CR In ringbased MEA agents organised cycle token passed similar distributed implementation roundrobin scheduler 40 Possession token signiﬁes exclusive permission enter CR agent enter CR possession token The modules Fig 9 specify srml arena 138 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 module rbme0 controls x0 y0 module rbme1 controls x1 y1 module rbme2 controls x2 y2 init cid14 cid9 cid2 x 0 y cid14 0 init cid14 cid9 cid2 x 1 y cid14 1 init cid14 cid9 cid2 x 2 y cid14 2 cid9 update cid14 y2 x0 cid2 x 0 cid14 y2 x0 cid2 x 0 y0 cid2 y cid14 0 cid9 y cid9 cid14 0 update cid14 y0 x1 cid2 x 1 cid14 y0 x1 cid2 x 1 y1 cid2 y cid14 1 cid9 y cid9 cid14 1 update cid14 y1 x2 cid2 x 2 cid14 y1 x2 cid2 x 2 y2 cid2 y cid14 2 cid9 y cid9 cid14 2 Fig 9 Modules ringbased mutual exclusion algorithm Fig 10 Kripke structure arena Arbme Table 1 Description behaviour agents respect Fig 10 A cid2symbol indicates respective step repeated number times State x0 y0 x1 y1 x2 s0 s1 s2 s3 s4 s5 s0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 y2 1 Annotation 2 passes token agent 0 0 cid2 0 token CR 0 0 passes token agent 1 0 cid2 1 token CR 0 1 passes token agent 2 0 cid2 2 token CR 1 2 passes token agent 0 Arbme 0 1 2 x0 x1 x2 y0 y1 y2 rbme0 rbme1 rbme2 implements threeagent distributed ringbased MEA cf 17 pp 474475 The algorithm easily extends settings ﬁnite number agents Thus Arbme agent controls variables xi yi Variable xi true means agent token enters CR yi indicates agent token passes agent 1 We assume arithmetic modulo 3 example In initial state agent 2 token passes agent 0 agent CR On possession token agent decide enter CR pass token Once agent CR xi true remain long suits On exiting CR xi yi holds agent immediately passes token agent 1 The behaviour described modules speciﬁcations The Kripke structure arena Arbme depicted Fig 10 Table 1 illustrates dynamics Observe state time runs Arbme agent token enter CR Hence formula cid7 cid8 xi yi xi1 yi1 xi2 yi2 cid2 G i012 satisﬁed signiﬁes protocol guarantees mutual exclusion The allows different runs undesirable point agent enters CR leave Such behaviour violate desired starvationfree property This case assume agent goal token ability enter CR inﬁnitely γi GFxi yi restrict attention runs sustained Nash equilibrium If agents adopt strategy enter CR remain given opportunity Nash equilibrium results agents enter CR If hand agent goal CTL formula γi GFxi CR inﬁnitely guarantee goal satisﬁed simply adopting strategy according exits CR ﬁnite period time possession token Thus agent perpetually excluded having J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 139 opportunity enter CR agent rationally follows starvationfree protocol Under preferences powerful property gamelike speciﬁcation ringbased mutual exclusion algorithm runs sustained Nash equilibrium distributed guaranteed starvationfree Thus safety mutual exclusion starvationfreeness distributed uniformly dealt RMGs 54 Example deferred acceptance The deferred acceptance algorithm proposed 1962 David Gale Lloyd Shapley 24 tremendously inﬂuential theory practice The power twosided allocation scheme lies simplicity ramiﬁcations numerous practical applications kidney exchange school choice assignment doctors hospitals 602745 Agents divided disjoint ﬁnite groups magents fagents agent preferences agents group The goal ﬁnd stable matching pairing magents fagents matched pairs mi f m j f j mi f j prefer f m j respectively The deferred acceptance algorithm DA scheme magent proposes preferred fagents If offer accepted engagement stands preferred magent comes proposes fagent If offer rejected magent strikes fagent list proposes preferred fagents The algorithm guaranteed terminate yield stable matching We model reason DA setting RMG framework We assume magents m1 mk xi1 xik zi1 zik past y1 j ykj yi j signiﬁes fagent f j provisionally equal number fagents f 1 fk Every magent mi controls set variables cid4mi xi j Similarly fagent f j controls set variables cid4 f j accepts mi s proposal indicates magent mi proposes fagent f j zi j records mi proposed f j In setting agent dichotomous preferences dividing agents group approved approved Let magent mi set indices approved fagents denoted F fagent f j set indices approved magents M j That F j mi approves f j M j f j approves mi The preferences magent mi fagent f j given γmi AFAG γ f j AFAG cid7 cid10 cid8 yi j jF cid7 cid10 cid8 yi j iM j respectively magent wishes eventually matched approved fagents fagent approved magents In setting dichotomous preferences stability means magent mi fagent f j f j mi s approved fagents mi f j s approved magents mi matched approved fagents f j matched approved magents If j Fmi M j j blocking pair let X denote set blocking pairs Then ϕstability cid2 cid17 cid10 cid10 cid18 yil ylj AFAG j X lF lM j signiﬁes computation path eventually stable matchings obtain desirable property The execution DA algorithm takes place rounds We assume odd round magents engaged nondeterministically propose fagents proposed By contrast round fagents nondeterministically engage magent proposed previous round alternatively decide stay current ﬁancé remain single Observe fagent engaged engaged necessarily magent These provisions laid modules depicted Fig 11 It worth observing speciﬁcations independent agents preferences guarantee agents engaged agent time Obviously ϕstability hold computation tree resulting RMG G DA fagent accept unfavourable offer stick approved magents rejected approved fagents More surprisingly ϕstability hold hold run sustained Nash equilibrium To consider f 1 f 2 magents approve f 1 f 2 case magents m1 m2 fagents fagents approve m1 m2 Thus m1 f blocking pair Let furthermore m1 m2 adopt strategies propose ﬁrst round f 2 f 1 respectively f 1 invariably accepts offers m2 Then f 2 accepts f 1s proposal ﬁrst round nonstable matching prevail ϕstability fail hold forever Even m1s f 1s strategies irrational leads formers latters goal satisﬁed offset folly choosing strategy As m2 f 2 fully satisﬁed outcome follows strategy proﬁle described Nash equilibrium If situation different magents wishing end approved fagent weaken goals aim proposed approved fagents proposing nonapproved fagent nondeterministic computations sustained Nash equilibrium satisfy ϕstability To appreciate assume 140 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 module mi controls xi1 xik zi1 zik module f j controls y1 j ykj init cid14 cid9 cid2 x i1 cid9 cid14 cid9 cid2 x ik cid9 update xi1 cid2 zi1 cid9 xi1 cid19 xik cid2 zik cid9 xik cid14 1 jkxi j yi j zi1 cid2 x i1 cid19 cid14 1 jkxi j yi j zik cid2 x ik init cid9 cid2 skip update cid9 cid2 skip x1 j cid2 y cid14 1 j cid9 y cid14 2 j cid14 x kj xkj cid2 y cid14 1 j y cid14 k j 1 j y cid14 kj cid9 cid9 cid9 Fig 11 Modules magents mi left fagents f j right deferred acceptance setting blocking pair mi f j ends forever unmatched approved agents Then mi successfully proposed nonapproved fagent proposing f j f j declined proposal mi In case mi achieve goal diverting strategy proposes approved fagents proposing agents In case f j obtained better outcome accepted mi s proposal stuck 6 Equilibrium analysis In section study following gametheoretic decision problems RMGs Realizability player guarantee satisfaction temporal formula given arena Nonemptiness given game Nash equilibrium NEmembership strategy proﬁle forms Nash equilibrium ENash ANash temporal logic formula satisﬁed Nash equilibria given game In order solve problems mentioned ﬁrst note similar case Kripke structures strategy σi player speciﬁed srml module We construction modules nondeterministic strategies clearly construction deterministic strategies appears simpler special case cid14 module specifying σi Q q0 δi τi module mi cid4i Ii U With state qi Q associate fresh propositional variable presentational convenience denote qi The module mσi controls variables cid4cid14 cid14 miσi contains single guarded command cid4i Q The init I Let mσi cid4cid14 cid14 U I cid9 cid2 q0 cid9 x1 cid9 xk cid9 cid4cid5 cid6 x1 xk cid3 τi q0 cid14 module miσi encode output function τi transition We use update commands U function δi The update contains valuations v v vi V q r Q r δiq vi cid19 τiq v update guarded command recall deﬁned χv xk1 xl cid3 cid4cid5 cid6 cid4i τir xk1 xl χv q cid2 q r cid9 x1 cid9 xk cid9 cid6 cid4cid5 τi rx1xk x given xv x xcid12v cid19 cid3 q cid12 r update guarded command given xk1 xl χv q cid2 r cid9 x1 cid9 xk cid9 cid3 cid6 cid3 cid6 cid4cid5 cid4i τi r xk1 xl cid4cid5 τi r x1 xk Note mσi initialisation rule rule transition δi Then mσi size linear σi That behaviour mσi exactly behaviour σi obvious construction Moreover Lemmas 2 3 fact size mσi linear σi analogous results respect strategies strategy proﬁles obtained In particular given arena A N cid4 m1 mn strategy σi deﬁne Kripke structure runs N cid4 Q induced σi A replacing mi mσi induced semantics srml arena Aσi m1 mσi mn The outcome respect cid4σ given Kripke structure runs associated J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 141 cid20 srml arena A cid4σ N cid4 iN Q mσ1 mσn Since interested computation runs trees respect cid4 associated K cid4σ A cid4σ let write runsK cid4σ cid4 restriction respect cid4 set ρcid4 ρ runsK cid4σ similarly set computation trees Then cid4σ speciﬁed srml following result immediately follows Lemma 2 Lemma 6 srml semantics strategies Let cid4σ strategy proﬁle respect arena A Then srml modules mσ1 mσn srml module mσi linear size σi runsK cid4σ cid4 runs A cid4σ cid4 treesK cid4σ cid4 trees A cid4σ cid4 Notice case strategy proﬁles containing nondeterministic strategies behaviour strategies easily handled semantics modules nondeterminism simply captured choices module representing particular strategy disposal Finally strategy proﬁles speciﬁed linear size arenas srml preserving induced sets runs computation trees deﬁne temporal logicbased theory strategy proﬁles Note outcomes new arena A cid4σ respect valuations set cid4 iN Q respect valuations cid4 One restrict outcomes projection valuations cid4 A simple corollary Lemma 6 Lemma 3 following result cid20 Corollary 7 Logic theory strategies Let A N cid4 m1 mn arena For strategy proﬁle cid4σ σ1 σn size cid4σ A LTL formula ThLT L A cid4σ size polynomial cid4σ ρcid4 runsK cid4σ cid4 ρcid4 ThLT L A cid4σ With results place start investigate decision problems discussed beginning section linear branching time case 61 On complexity LTL RMGs The ﬁrst problem study Realizability LTL RMGs asks player strategy achieve temporal logic goal context given arena matter agents behave Realizability RMG G player LTL formula ϕ Given Question Does exist strategy σi cid4σi holds ρ cid4σi σi ϕ Proposition 8 Realizability LTL RMGs 2EXPTIMEcomplete It 2EXPTIMEhard 2player games PSPACEcomplete 1player games Proof For membership reduce Realizability synthesis problem respect reactive environments problem known 2EXPTIMEcomplete LTL speciﬁcations 42 First let Thmi LTL formula characterising module player let Thmi LTL formula characterising modules players G LTL formula srml comprising modules m1 mi1 mi1 mn We construction Thmi immediate results given Then easy LTL formula ϕ realizable context LTL srml games following LTL formula synthesised respect reactive environment Thmi Thmi ϕ provided environment coalition players N controls variables cid4 cid4i player controls variables cid4i Note order solve Realizability problem checked LTL formula Thmi Thmi ϕ synthesised size formula polynomial sizes LTL formula ϕ game G follows Realizability 2EXPTIME sizes game G input formula ϕ For hardness ﬁrst reduce LTL games called control games LTL 5 instance Realizability 3 playersmodules sake simplicity presentation instance game 2 modules Now let introduce LTL games An LTL game twoplayer zerosum game given G LT L ϕ v 0 ϕ LTL formula set 2cid12 G LT L V G V 0 V 1 γ V 2V μ V 2cid12 142 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 graph vertices V G partitioned player 0 vertices V 0 player 1 vertices V 1 The transitions graph given γ v assume cid14 Each vertex v set properties P associated given μ P 2cid12 holds vertex v labelled v P μv The graph G LT L assumed total v V G γ v cid12 cid14 V G transition v v cid14 γ v v v The game played inﬁnitely rounds player choosing successor vertex turn player 0 plays vertices V 0 player 1 plays vertices V 1 The game starts initial vertex v 0 V G Playing game deﬁnes inﬁnite sequence vertices w v 0 v 1 v 2 vk k N vk1 γ vk An LTL game won player 0 w ϕ player 1 wins LTL games determined winning strategy player 0 player 1 Checking player 0 winning strategy LTL game 2EXPTIMEcomplete problem 5 cid14 We construct LTL RMG players m0 m1 player 0 winning strategy LTL game G LT L ϕ v 0 exists strategy σ0 m0 strategy proﬁles cid4σ K cid4σ0 σ0 ϕ The construction given similar Lemma 2 translate Kripke transition systems srml modules Let ﬁrst deﬁne following sets controlled variables S 0 0 S 1 0 S 0 1 S 1 1 xv v V 0 xv v V 1 y v v V 0 y v v V 1 Using sets controlled variables deﬁne following modules module m0 controls S 0 0 S 1 0 cid9 init indicate initial state v 0 cid14 cid9 cid2 x v0 update v V 0 w γ v v cid14 cid14 xv y v cid2 x x w v v V 0 v γ v loops cid14 xv y v cid2 x v v V 1 player 1 moves cid14 xv cid2 x v module m1 controls S 0 1 S 1 1 cid9 cid9 cid14 v0 cid9 init indicate initial state v 0 cid9 cid2 y update v V 1 w γ v v cid14 xv y v cid2 y w v V 1 v γ v loops xv y v cid2 y v V 0 player 0 moves y v cid2 y y cid9 cid9 cid14 v cid14 v cid14 v module controls cid12 init initialize propositions cid12 false cid9 cid2 skip update v V 0 V 1 μv p1 pk cid12 μv q1 qm cid9 q xv y v cid2 p cid9 p cid14 q m cid14 1 cid14 1 cid14 k Now runs respect completely deﬁned possible runs LTL game More precisely runsout ρ ρ runsG LT L As consequence formula ψ run ρ LTL game G LT L strategy proﬁle cid4σ following holds J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 143 ρ ψ K cid4σ Xψ Based facts player 0 winning strategy σc LTL game G LT L ϕ v 0 exist winning strategy σ0 m0 associated srml game deﬁned First suppose player 0 winning strategy σc given LTL game G LT L ϕ v 0 assumed ﬁnite memory Then use construction similar given Lemma 6 deﬁne srml module mσc characterises σc Because deﬁnition srml game induced LTL game immediately follows module m0 winning strategy speciﬁed mσc Xϕ Now suppose srml module m0 winning strategy σ0 game A γ0 Xϕ γ1 Xϕ γout cid9 A deﬁned srml modules given Then σ0 ﬁnitememory strategy straightforwardly deﬁnes strategy LTL game ϕ This proof shows problem 2EXPTIMEhard 3player games However note deter ministic module trivial goal cid9 As consequence eliminated game Let G 2 game built based G controlled variables guarded commands given player It follows player strategy σi cid4σi holds ρ cid4σi σi ϕ G strategy σ cid4σ ϕ G 2 The direction trivial simply let σ strategy plays σi σout strategy G The direction easy Consider contrapositive argument strategy realise ϕ G 2 strategy realise ϕ G Now simply observe set strategies G 2 super set set strategies G Therefore strategy realise ϕ G 2 o strategy G completes proof 2EXPTIMEhardness result 2player games holds ρ cid4σ σ Finally consider case 1player games For membership PSPACE consider arena A formula ϕ We simply need check LTL formula Th A ϕ satisﬁable clearly PSPACE For hardness immediately reduce LTL satisﬁability problem formulae variable details straightforward description given cid3 It natural ask classes games decision problems study easier While study classes main focus paper natural subsets LTL decision problems discuss easier Consider class Objective LTL OLTL formulae Informally OLTL formula temporal connective occurs scope classical connective Thus FGp p U Gq OLTL formulae p Xq OLTL formula OLTL formula X operator occurs scope operator Formally syntax OLTL formulae given follows ϕ Xϕ ϕ U ϕ ψ ψ x ψ ψ ψ Now Proposition 9 Realizability OLTL RMGs EXPTIMEcomplete Proof We ﬁrst overview Given arena A player target formula ϕ start constructing K A Kripke structure induced A As noted K A computed time exponential size A We use dynamic programming label state s K A subformulae ϕ guarantee able bring s The actual algorithm closely related standard explicit state CTL model checking algorithm 20 The algorithm purpose arbitrary LTL formulae possibility temporal operators occurring scope classical connective However approach works OLTL formulae The algorithm operates time polynomial size K A Finally check initial states K A labelled target formula ϕ answer yes answer Realizability problem yes The detailed algorithm presented Fig 13 Appendix For EXPTIMEhardness straightforwardly reduce problem determining player winning strategy game PeekG 4 proof Proposition 15 details problem cid3 Next ask strategy proﬁle Nash equilibrium NEmembership Given Question RMG G strategy proﬁle cid4σ Is case cid4σ NEG Note strategies cid4σ σ1 σn given input problem represented ﬁnite state machines We assume represented explicitly enumerating components ﬁnite state machine 144 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 Proposition 10 NEmembership LTL RMGs PSPACEcomplete In addition PSPACEhard oneplayer games LTL goals singleton variable set cid4 Proof For membership PSPACE deﬁne procedure uses oracles LTL modelchecking satisﬁability known PSPACE 63 The procedure based observation proﬁle cid4σ Nash equilibrium ρ cid4σ γi ρ cid4σi σ cid14 For hardness reduce LTL satisﬁability formulae propositional variable 19 oneplayer LTL RMG Let ﬁrst prove membership PSPACE cid12 γi player strategy σ cid14 Recall proﬁle cid4σ deterministic strategies LTL RMG purestrategy Nash equilibrium player N ρ cid4σ γi ρ cid4σi σ cid14 cid12 γi strategy σ cid14 Thus player check ρ cid4σ cid12 γi ρ cid4σi σ cid14 γi strategy σ cid14 cid12i cid12i conclude cid4σ cid12 NEG statement holds cid4σ NEG Checking ρ cid4σ cid12 γi PSPACE First use Lemma 6 Corollary 7 construct LTL formula Th A cid4σ characterises cid4σ It diﬃcult runs ρ satisfy Th A cid4σ case ρcid4 ρ cid4σ To simplify notation write Th cid4σ Th A cid4σ Such formula Th cid4σ polynomial cid4σ Following automatatheoretic approach model checking construct alternating Büchi word ABW automata ATh cid4σ Aγi accept exactly words satisfy formulae Th cid4σ γi respectively Such alternating automata polynomial Th cid4σ γi We simply ask LATh cid4σ cid4 LAγi language accepted ATh cid4σ restricted cid4 included language accepted Aγi Such question answered PSPACE If LATh cid4σ cid4 LAγi ρ cid4σ γi ρ cid4σ cid12 γi Since PSPACE deterministic complexity class checking ρ cid4σ cid12 γi PSPACE required On hand checking ρ cid4σi σ cid14 cid12i constructions similar Lemma 6 Corollary 7 case check LTL satisﬁability instead First let write Thmσ j LTL formula characterises σ j j N Speciﬁcally check LTL formula γi jNi Thmσ j satisﬁable PSPACE cid19 Note order solve NEmembership problem checked LTL formula γi jNi Thmσ j satisﬁable size formula polynomial sizes LTL goals γi strategies σ j follows NEmembership PSPACE sizes game G input strategy proﬁle cid4σ γi σ cid14 cid19 Now hardness reduce LTL satisﬁability problem PSPACEcomplete formulae propositional variable 19 way iBG 29 More speciﬁcally class LTL formulae propositional variable ask given LTL formula ϕ class satisﬁable Because formula propositional variable p model produced srml module Then reasoning proof iBG 29 srml module m deﬁned winning strategy satisfy ϕ q formula ϕ satisﬁable This strategy build strategy proﬁle σm Nash equilibrium ϕ satisﬁable module m controls p q init cid9 cid2 p cid9 cid2 p cid9 cid2 q cid9 cid2 q update cid9 cid2 p cid9 cid2 p cid14 cid9 cid14 cid14 cid9 cid14 cid14 cid9 cid14 Now consider strategy σm q cid12 τ q0 Then follows σm cid12 ϕ q If ϕ satisﬁable m beneﬁcial deviation switch strategy σ cid14 m builds model ϕ q τ q0 However ϕ satisﬁable strategy m satisfy ϕ q σm Nash equilibrium case Note reason reduction works arena game played constant size ϕ formula propositional variable cid3 The problem asks game Nash equilibrium Nonemptiness Given Question RMG G Is case NEG cid12 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 145 Proposition 11 Nonemptiness LTL RMGs 2EXPTIMEcomplete 2EXPTIMEhard 2player games Proof For membership 2EXPTIME instantiate ENash problem described ϕ cid9 For hardness reduce LTL synthesis variables x y twoplayer game ﬁve Boolean variables The reduction takes input LTL synthesis game players 1 2 LTL formula ϕ player 1 winning strategy synthesis game ϕ synthesised player 2 winning strategy ϕ synthesised zerosum game Based input game reduction uses modules following LTL goals γ1 ϕ p q ϕ r γ2 ϕ p q ϕ ϕ r ϕ LTL formula Boolean variables x y module m1 controls x p r init cid9 cid2 x p r cid9 cid2 x p r cid9 cid9 cid2 x p cid9 r cid9 cid2 x p cid9 r cid9 cid9 cid2 x cid9 p r update cid9 cid2 x p r cid9 cid2 x p r cid9 cid9 cid2 x p cid9 r cid9 cid2 x p cid9 r cid9 cid9 cid2 x p r module m2 controls y q init cid9 cid2 y q cid9 cid2 y q cid9 update cid9 cid2 y q cid9 cid2 y q cid9 Given twoplayer game G hard check player 1 winning strategy synthesise ϕ G Nash equilibrium 2EXPTIMEhardness follows Assume player 1 winning strategy synthesise ϕ Then module m1 use winning strategy ensure ϕ holds setting r cid9 Then γ1 satisﬁed m1 deviate On hand case m2 goal γ2 satisﬁed beneﬁcially deviate ϕ ϕ r false unilateral deviation m2 We prove contrapositive statement assume player 1 winning strategy synthesise ϕ case G Nash equilibrium Since game LTL synthesis determined player 1 winning strategy synthesise ϕ know player 2 winning strategy ϕ We analyse possible cases instance players beneﬁcial deviation Let cid4σ σ1 σ2 arbitrary strategy proﬁle assume ﬁrst cid4σ ϕ Then cid4σ p q player m2 beneﬁcial deviation If hand cid4σ p q player m1 beneﬁcial deviation Now suppose cid4σ ϕ Then cid4σ r player m1 beneﬁcial deviation If hand cid4σ r player m2 beneﬁcial deviation case cid4σ p q player m2 simply deviate strategy σ cid14 2 winning ϕ value q case cid4σ p q player m2 deviate strategy σ cid14 2 winning ϕ change value q respect given σ2 This analysis covers possible cases respect ϕ r p q Then problem 2EXPTIMEhard players ﬁve Boolean variables cid3 146 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 Arguably key decision problems relating gametheoretic analysis gamelike concurrent multiagent systems checking LTL formula holds run given Nash equilibrium ii checking given LTL formula holds runs given Nash equilibria These problems formalised ENash ANash problems respectively ENash Given Question Does ρ cid4σ ϕ hold cid4σ NEG RMG G LTL formula ϕ ANash Given Question Does ρ cid4σ ϕ hold cid4σ NEG RMG G LTL formula ϕ These decision problems ﬁrst studied 29 iterated Boolean games iBG In setting language specify systems iBGs model Even setting simple assumed state variables updated In article study systems impose restriction obtain similar complexity results case Note RMGs allows express systems directly expressed iBGs noted RMGs succinctly express iBGs More speciﬁcally RMGs impose constraints choices players values variables control possible ﬁnd reduction ENash ANash LTL RMGs problems context iBGs Before describing reduction let deﬁne iBG G supervised game Nash equilibria iBG G consistent Nash equilibria initially given LTL RMG G cid14 cid14 Formally iterated Boolean game structure N cid4 cid4iiN γiiN element structure LTL RMGs Strategies deﬁned LTL RMGs Moore ﬁnitestate machines However arena iBG played implicitly given unique clique vertices valuations V 2cid4 Having arena play game informally means iBG assumed state agents update values variables control note contrast LTL RMG variables scope enabled guarded commands updated More speciﬁcally note general LTL RMG representation iBG result game exponential size specify LTL RMG exponentially choices respect cid4 players iBG disposal This reason simple polynomialtime reduction iBG LTL RMGs possible order obtain hardness results LTL RMGs Nevertheless mentioned particular case ENash ANash problems reduction LTL RMGs iBGs possible We ﬁrst present key technical result relies following game construction Given LTL RMG G A N cid4 miiN γiiN let iBG G iNcid14 supervised game given cid14 cid4cid14 cid4iiNcid14 γ cid14 cid14 N N γ cid14 γ cid14 n1 γ cid14 n2 cid14 N n 1 n 2 cid4cid14 cid4 xn1 xn2 cid19 jN cid19 cid19 Thm j γi jN jN Thm j xn1 xn2 Thm j xn1 xn2 N Recall Thmi LTL formula characterises module mi Based deﬁnition supervised games obtain following result Lemma 12 Let G A N cid4 miiN γiiN LTL RMG let G cid14 N cid14 cid4cid14 cid4iiNcid14 γ cid14 iNcid14 supervised game cid4σ NEG cid4σ σn1 σn2 NEG cid4σ strategies σn1 σn2 players n 1 n 2 cid14 Proof We ﬁrst prove lefttoright direction Since cid4σ proﬁle strategies consistent A LTL formula cid2 Thm j jN satisﬁed LTL goals γn1 γn2 Thus players n 1 n 2 deviate Moreover players n 1 n 2 control variable present game G goals γ cid14 iN depend Boolean variables xn1 xn2 follows J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 147 cid14 ρ cid4σ γi iff ρ cid4σ σn1 σn2 γ cid14 iff ρ cid4σ σn1 σn2cid4 γ cid14 iN strategies σn1 σn2 players n 1 n 2 Then players N goal ρ cid4σ σn1 σn2 want deviate Similarly ρ cid4σ σn1 σn2 provided use strategies consistent cid19 Thm j false Then player beneﬁcial deviation switching strategy consistent A As consequence goals γ cid14 achieved G ρ cid4σ satisﬁed G players N goal achieved G ρ cid4σ satisﬁed G beneﬁcial deviation G A Then player beneﬁcial deviation G consistent A But case goal γi satisﬁed conjunct G cid4σ σn1 σn2 NEG G switching strategy σ cid14 We prove righttoleft direction Since cid4σ σn1 σn2 NEG cid14 know players n 1 n 2 goals achieved strategies cid4σ consistent srml modules miiN LTL ﬁnal players playing version formula Matching Pennies pure Nash equilibrium Thm j necessarily satisﬁed Nash equilibria G cid14 desired Hence cid4σ legal strategy G consistent arena given miiN For exactly reasons given jN jN cid19 cid14 cid14 cid14 cid14 cid14 lefttoright direction strategy proﬁle cid4σ Nash equilibrium G ρ cid4σ σn1 σn2 γ cid14 iff ρ cid4σ σn1 σn2cid4 γ cid14 iff ρ cid4σ γi needed Note particular player goal γ cid14 ρ cid4σ σn1 σn2 satisﬁed G Thm j necessarily satisﬁed Then ρ cid4σ cid12 γi strategy proﬁle satisfy γi LTL formula jN Moreover player beneﬁcial deviation G switching alternative strategy strategy G available G cid3 cid19 cid14 cid14 cid14 The reason iBG G supervised game G deﬁnition given G introduced new players n 1 n 2 act supervisors behaviour players N following sense players n 1 n 2 easily ensure strategy proﬁle iBG G forms Nash equilibrium possible players comply constrained behaviour imposed speciﬁcation Thm j Then Lemma 12 modules G behaviour formally speciﬁed LTL formula result jN cid19 cid14 cid14 Proposition 13 The ENash ANash problems LTL RMGs 2EXPTIMEcomplete Proof Consider ENash ﬁrst For hardness trivially reduce Nonemptiness problem LTL RMGs asking cid9 satisﬁed Nash equilibrium outcome For membership use Lemma 12 construct supervised game straightforwardly reduce ENash LTL RMGs ENash iBG known 2EXPTIMEcomplete 29 Since 2EXPTIME deterministic complexity class desired complexity result ANash problem immediately follows Finally 29 use rational synthesis 23 solve ENash problem iBG 2EXPTIME sizes players goals input LTL formula obtain ENash LTL RMGs 2EXPTIME respect size RMG G input LTL formula ϕ cid3 This result shows particular lineartime setting analysing equilibrium properties ENash ANash problems hard controller synthesis problem LTL 57 expressed gametheoretic terms hard solving twoplayer zerosum perfectinformation games LTL goals 62 On complexity CTL RMGs In section interested computational complexity decision problems investigated branchingtime framework developed previous sections The ﬁrst complexity result present Realizability obtain reduction CTL supervisorycontrol games 42 aka CTL games graphs Proposition 14 Realizability CTL RMGs 2EXPTIMEcomplete Proof For membership 2EXPTIME similar case LTL use reduction controlsynthesis problem CTL speciﬁcations reactive environments 42 Firstly set modules given game G construct induced Kripke structure K exponential size modules Now associate player CTL controlsynthesis problem set players N reactive environment let ϕ CTL goal ϕ CTL goal environment zerosum game It hard player strategy achieve ϕ strategy win CTL controlsynthesis 148 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 game4 Because complexity doubly exponential size formula ϕ exponential size given graph K case procedure doubly exponential size initial game G Therefore containment 2EXPTIME follows exponentially higher complexity matching result lineartime case logicbased approach instead decision procedure doubly exponential sizes systemgame formula For hardness analogous LTL case use CTL supervisorycontrol games 5 particular nondeterministic strategies instead deterministic ones considered cid3 This result sharply contrasts computational complexity usual realizability problem CTL speciﬁcations known EXPTIMEcomplete 21 There clear difference standard realizability problem considering strategy player constructed respect known special strategy environment players N construct strategy ensures goal player respect strategy player opponents Proposition 14 shows addition lineartime framework Realizability multiplayer game hard synthesis twoplayer branchingtime context problem considerably harder synthesis CTL speciﬁcations EXPTIMEcomplete Realizability CTL RMGs 2EXPTIMEcomplete On hand following complexity result shows lineartime case NEmembership problem hard satisﬁability problem temporal logic consideration Proposition 15 NEmembership CTL RMGs EXPTIMEcomplete Proof To membership EXPTIME use variation algorithm given Proposition 6 29 In particular use following facts CTL model checking Kripke structures polynomial time Kripke structure K A induced arena A exponential size A intersection nonemptiness problem Alternating Büchi Tree ABT automata EXPTIMEcomplete Then ﬁrstly order check K cid4σ cid4 cid12 ϕ ϕ CTL formula construct Kripke structure K cid4σ induced A cid4σ Since Kripke structure K cid4σ exponential size cid4σ step check player gets goal achieved cid4σ EXPTIME The step player goal γi achieved beneﬁcial deviation switching alternative strategy reduced intersec tion nonemptiness problem ABT automata deviate algorithm given Proposition 6 29 Instead checking satisﬁability CTL formula construct ABT Aγi represents γi Such automa ton polynomial size γi 4170 Also strategies nondeterministic transducers particular Nondeterministic Büchi Tree NBT automata trivial acceptance condition states accepting states Write Aσi strategy regarded NBT kind Then checking player strategy deviate achieve goal veriﬁed checking nonemptiness following automaton Aσn Aσi1 Aσi1 Aγi Aσ1 need check language trees accepted automaton nonempty Because automaton Ax linear polynomial size x step exponential size x exponential sizes strategies σi goal γi Then inclusion EXPTIME follows Hardness hand shown reduction problem determining given player winning strategy game peekG 4 64 p 158 construction CTL RMG instance peekG 4 inspired construction presented 67 An instance peekG 4 given structure X1 X2 X3 ϕ X1 X2 disjoint ﬁnite sets Boolean variables intended interpretation variables X1 control agent 1 X2 control agent 2 X3 X1 X2 variables deemed true initial state game ϕ propositional logic formula variables X1 X2 representing winning condition The game played series rounds agents 1 2 alternating turns agent 1 moving ﬁrst select value cid9 variables Xi The game starts initial assignment truth values deﬁned X3 Variables changed retain truth value subsequent round An agent wins given round makes resulting truth assignment deﬁned round makes ϕ true 4 The difference G players play concurrently CTL controlsynthesis game play sequentially A similar situation Proposition 3 32 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 149 The decision problem associated peekG 4 determining agent 2 winning strategy given instance X1 X2 X3 ϕ We like remark peekG 4 requires memoryless strategies modelled ﬁnitestate machine model strategies agent win depends current truth assignment distribution variables winning formula turn currently As corollary agent force win force O 2 X1X2 moves From X1 X2 X3 ϕ following CTL RMG constructed For Boolean variable x X1 X2 create variable srml model create additional Boolean variables turn p The intended interpretation turn cid9 agent 1s turn turn agent 2s turn We srml module purpose control turn toggling value successive round starting initial case agent 1s Note deﬁnition module possible legal strategy equality respect observable behaviour cid9 cid9 The goal γmove player CTL RMG deﬁned γmove cid9 module controls turn cid14 cid9 init cid9 cid2 turn update turn cid2 turn turn cid2 turn cid14 cid14 cid9 Moreover peekG 4 players 1 2 create srml module agi controls variables Xi We let module ag2 control p The modules ag1 ag2 follows For ag1 begins deterministically initialising values variables values deﬁned X3 variable x X1 appears X3 variable initialised cid9 initialised The module ag2 deﬁned ag1 save ag2 init commands instead init commands sets p cid9 sets p Then initialisation players turn player nondeterministically choose variables control toggle value variable players turn choice leaving value variables unchanged The general structure ag1 follows X1 x1 xk module ag1 controls x1 xk xk init initialise based values X3 cid14 cid9 cid2 x 1 update cid14 turn cid2 x 1 cid14 turn cid2 x 1 cid14 turn cid2 x k cid14 turn cid2 x k cid9 cid2 skip cid9 cid9 And general structure ag2 follows X2 y1 yl module ag2 controls p y1 yl cid14 1 cid14 1 cid14 cid9 y cid14 y init initialise based values X3 yl cid9 cid2 p cid9 cid2 p yl update turn cid2 y turn cid2 y turn cid2 y turn cid2 y cid9 cid2 skip cid9 cid9 cid14 1 cid14 1 cid14 l cid14 l Notice agent skip electing leave variables unchanged agents turn choice The srml arena consideration contains modules We deﬁne goal agent 1 γ1 cid9 goal agent 2 CTL formula γ2 p Aϕ U turn ϕ In addition let strategy σ1 agent 1 trivial nondeterministic strategy contains possible choices available round game strategy round nondeterministically chooses 150 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 commands update module ag1 For ag2 let strategy σ2 strategy chooses initialisation command p Then clearly strategy proﬁle σ1 σ2 σmove players ag1 goals satisﬁed player ag2 fails goal γ2 satisﬁed σ2 makes p More formally respect strategy proﬁle know Kσ1σ2σmove cid12 γ2 However agent 2 winning strategy peekG 4 player ag2 beneﬁcial deviation σ cid14 2 strategy making choices winning strategy sets p cid9 initialisation stage goal γ2 achieved Hence σ1 σ2 σmove Nash equilibrium strategy proﬁle σ1 σ cid14 2 σmove equilibrium case players goals satisﬁed Formally following holds agent 2 winning strategy σ1 σ2 σmove cid12 NEG If hand agent 2 winning strategy peekG 4 strategy σ1 ag1 deﬁned contains possible choices agent 1 necessarily follows run game witness γ2 satisﬁed particular strategies σ cid14 2 set p cid9 agent 2 winning strategy contradicting initial hypothesis Then follows case player ag2 beneﬁcial deviation strategy proﬁle σ1 σ2 σmove fact Nash equilibrium Formally case following statement holds agent 2 winning strategy σ1 σ2 σmove NEG Thus agent 2 winning strategy instance peekG 4 σ1 σ2 σmove Nash equilibrium Since EXPTIME deterministic complexity class hardness NEmembership problem CTL RMGs respect EXPTIME complexity class follows Finally observe use intersection nonemptiness membership EXPTIME obtain NEmembership EXPTIME sizes RMG G strategy proﬁle cid4σ cid3 Finally lineartime case checking systemgame Nash equilibrium CTL formula holds Nash equilibria gamelike multiagent 2EXPTIMEhard problems Formally Proposition 16 The following problems 2EXPTIMEhard Nonemptiness ENash ANash CTL RMGs Proof For results reduce CTL supervisorycontrol games graphs Nonemptiness problem game construction add new players ensure player initially given CTL supervisory control game winning strategy Nash equilibrium constructed CTL RMG Then decision problems considered ENash ANash inherit hardness complexity result cid3 7 Beyond reactive modules The results prove article ﬁrst sight appear closely tied single formalism deﬁning game arenas Reactive Modules language However language fact general To illustrate scope framework standard AI formalism planning agents directly modelled framework propositional STRIPS notation 221225 Descendants STRIPS notation remain widely planning community multiagent planning models based STRIPS investigated literature MASTRIPS model Brafman Domshlak 10 The basic idea STRIPS notation model effects actions terms precondition delete add lists precondition deﬁnes true order action executed add list deﬁnes propositions true execution action delete list deﬁnes propositions false execution action As previously assume vocabulary cid4 propositional variables characterise state Formally STRIPS descriptor action α given structure α Tα Fα Dα Aα Tα set propositions true order α executed Fα set propositions false order α executed Dα set propositions characterise facts false performance α delete list Aα set propositions characterise facts true performance α add list As RMGs model state given time valuation v V For action α deﬁne propositional formula preα formula satisﬁed valuation precondition α met J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 151 preα cid2 x cid2 xTα yFα y The effect executing action α world described valuation v denoted eff α v partial function deﬁned follows cid21 eff α v v Dα Aα undeﬁned v preα We naturally deﬁne multiagent STRIPS arena A N cid4 v 0 Ac1 Acn N 1 n set players cid4 vocabulary propositional variables represent state v 0 V initial state game player N Aci α1 set action descriptors representing actions perform The domain action α denoted dom α set variables truth status changed performance α dom α Dα Aα To things simple assume actions different players disjoint αk cid12 j N α1 Aci α2 Ac j dom α1 dom α2 cid20 Let cid4i α Aci dom α set variables control player The execution STRIPS arena proceeds inﬁnite sequence rounds ﬁrst round variables initialised values v 0 subsequent round player selects action α Aci precondition satisﬁed proﬁle actions selected players executed deﬁned eff function generate state Each player chooses action precondition satisﬁed A STRIPS game given structure G A γ1 γn A multiagent STRIPS arena γi temporal logic goal player RMGs consider LTL CTL goals Given setup clear deﬁne strategies agents way RMGs runs Kripke structures similarly The details straightforward tedious omit We remark deﬁnition similar MASTRIPS model Brafman Domshlak 10 MASTRIPS goals represented sets states idea agent wants bring set This represented directly model giving agents goals form Fϕ We translate STRIPS arena equivalent RML arena First let α Tα Fα Dα Aα action descriptor Then deﬁne guarded command gα action descriptor follows cid14 preα cid2 r cid3 1 cid14 k cid9 r cid4cid5 Aα r1rk cid9 cid6 cid14 z cid3 1 cid14 z k cid4cid5 Dα z1zk cid6 We deﬁne single init guarded command g0 valuation v 0 cid14 cid9 cid2 x cid3 cid9 cid6 cid4cid5 xi cid4i v0 cid14 x j cid3 cid6 cid4cid5 x j cid4i v0 player sets variables control correspond Finally module mi player simply mi cid4i Ii U cid4i deﬁned Ii g0 single initialisation guarded command deﬁned U gα α Aci set update guarded commands Now clear construction srml arena constructed way operate way STRIPS arena began In particular player selects enabled update command gα execution corresponds selecting action α Aci precondition satisﬁed Executing guarded command simulates behaviour executing action α deﬁned descriptor Tα Fα Dα Aα Thus translate propositional multiagent STRIPS systems formalism Note translation opposite direction directly possible srml guarded commands richer propositional STRIPS operators cid14 ϕ meaning variable x action guarded command allowed actions x value formula ϕ Such constructs provided propositional STRIPS simulated cost exponential blow number actions Finally note fact propositional STRIPS planning games encoded game framework implies membership results corresponding decision problems studied article carry directly hardness results carry automatically seen hold constructions presented earlier 152 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 8 Related work Our work antecedents closely related threads science research ﬁrst arising computeraided veriﬁcation community use logics techniques inspired game theory automated veriﬁcation programs 3 second arising largely artiﬁcial intelligence community use logic formal speciﬁcation veriﬁcation multiagent systems 7668 surveys Historically computeraided veriﬁcation community focussed problem checking S sat isﬁes given property ϕ ϕ expressed formula temporal logic typically LTL CTL 2016 Using temporal logics LTL CTL makes possible express properties relating temporal ordering events enable expression strategic properties component guarantee enters fail state This observation motivated Alur et al develop Alternatingtime Temporal Logic ATL 3 explicitly intended support reasoning However important limitations game properties expressed ATL First ATL provides direct mechanism refer strategies object language appears required intends capture gametheoretic properties Nash equilibrium Second language provides mechanism directly representing preferences components appropriate hopes reason gametheoretic equilibrium properties paper The idea introducing strategies object language pursued number researchers 1450 Probably bestknown successful formalism Strategy Logic SL thought temporal logic includes framework naming strategies reasoning properties 661450 Relatively little work aided veriﬁcation community addressed problem capturing preferences players role preferences play strategic game theoretic reasoning However work topic present literature fairly common model player preferences way present paper temporal logic formulae player desires satisﬁed 523 generally ωregular objectives 138 To pick example work Alur et al 5 investigated complexity gametheoretic questions games played graphs players attempt satisfy goal expressed temporal logic formula One aspect work assumes agents moves game arena explicitly modelled graph This unrealistic assumption practice state transition graph real size exponential number variables Moreover signiﬁcance complexity results games reasonably questioned unrealistic representation game arena assumed Similar comments apply studies gametheoretic properties concurrent systems In second strand work researchers AI community developed range formalisms intended speciﬁcation veriﬁcation multiagent systems Originally work focussed practical reasoning agents planning systems 25 particular beliefdesireintention model agency 58 In model agents viewed selecting intentions set possible desires represent commitments achieve certain states affairs select execute plans action achieve intentions However diﬃculties obtaining satisfactory formalisation rational mental states led researchers seek alternative foundations modelling rational action multiagent systems game theory increasingly adopted foundation See 39 excellent survey stream work Of body work worth identifying threads research related present paper Bulling et al 11 consider variations ATL explicit intention reasoning temporal properties strategic notions Nash equilibrium The key differences present work ﬁrst aim reason game theoretic properties object language second use compact modelling language srml deﬁne underpinning game structure Our work present article draws paradigms closely related work presented 293033 In 29 Gutierrez et al introduced model called Iterated Boolean Games iBGs In iBG player exercises unique control set Boolean variables play proceeds inﬁnite series rounds round player makes Boolean assignment variables control Each player associated LTL formula player desires satisﬁed LTL model traced inﬁnite play game A key concern Gutierrez et al classify complexity gametheoretic decision problems iBGs checking existence pure strategy Nash equilibria5 Observe contrast studies game properties concurrent systems arena iBG played deﬁned succinctly simply listing variables player controls While believe iBG model Boolean games model generalises simple elegant models formulate questions strategic interaction multiagent systems clearly represent highlevel abstraction real systems In particular iBGs assumed time point player complete freedom assign values variables controls This greatly limits multiagent scenarios modelled iBGs In 3033 Gutierrez et al presented realistic model concurrent programs studies gamelike properties concurrent systems assumes game arenas explicitly presented reasons described believe unrealistic assumption practice 5 The iBG model essentially generalisation conventional Boolean games model introduced Harrenstein et al 37 Conventional Boolean games like iBGs play takes round goals expressed classical propositional logic LTL J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 153 Table 2 Overview computational complexity results Realizability NEmembership Nonemptiness ENash ANash LTL RMGs 2EXPTIMEc PSPACEc 2EXPTIMEc 2EXPTIMEc 2EXPTIMEc Proposition 8 Proposition 10 Proposition 11 Proposition 13 Proposition 13 CTL RMGs 2EXPTIMEc 2EXPTIMEc 2EXPTIMEhard 2EXPTIMEhard 2EXPTIMEhard Proposition 14 Proposition 15 Proposition 16 Proposition 16 Proposition 16 In short broad aim 511138293033 gametheoretic analysis concurrent multiagent systems approach use language deﬁning game arenas closer realworld program ming modelling We represent game arenas Reactive Modules language permits succinct deﬁnition concurrent multiagent systems protocols Questions relating complexity gametheoretic questions succinctlyspeciﬁed arenas believe meaningful context arenas game graph explicitly presented Interestingly ﬁnd decision problems consider complexity increase studying game arenas speciﬁed Reactive Modules 9 Conclusion future work In article studied novel game model admits natural characterisation simple computation ally powerful syntactic fragment Reactive Modules language 2 Also complexity reasoning equilibria model checking synthesising temporal properties multiagent systems speciﬁed language investigated lineartime branchingtime frameworks 20 Several research groups working problems related equilibrium checking Fisman et al 23 study problem synthesising systems certain desirable properties hold equilibrium addition extensive overviews decision problems related equilibrium checking given 138 range concurrent game models In work investigated issues surrounding rational veriﬁcation particularly Boolean games 37 Boolean games essentially oneshot versions iterated Boolean games described play consists single round agent goals γi speciﬁed propositional formulae A question investigated length possible mechanisms managing games This necessary example game contains socially undesirable equilibria 73 game possesses equilibrium wish introduce sta bilisation One obvious mechanism manipulating games use taxation schemes provide incentives players avoid undesirable equilibria prefer desirable equilibria 74 Related issues recently studied context concurrent games 1 Another possibility try inﬂuence players changing beliefs communication For example 26 considered Boolean games setting players choices based beliefs variables environment central authority able reveal certain information order modify beliefs Another issue investigated extent develop language supports reason ing strategies directly object language Strategy Logic SL variation temporal logic closely related Alternatingtime temporal logic 3 includes names strategies object language 14 SL pos sible reason Nash equilibria However SL general undecidable raises question weaker languages For instance 30 temporal logic containing quantiﬁer NEϕ meaning ϕ holds Nash equilibrium computations proposed Also 31 shown existence Nash equilibria represented bisimilarity logic languages weaker SL Other researchers investigated similar cerns 11 Another interesting question extent model interaction particular setting affects possible equilibria result In 35 investigated Nash equilibria games based event structures 71 able characterise conditions required existence equilibria Another research direction extent representation preferences simple binary formulae possible approach investigated 48 represent players goals formulae Łukasiewicz logic permits richer class preferences directly represented Many issues currently studied remain future work Mixed stochastic strategies obvious major topic possibility imperfect information 34 course solution concepts Nash equilibria subgame perfect equilibrium Our Eagle tool prototype 65 limited scope optimised extensions supporting LTL incomplete information highly desirable Our main complexity results summarised Table 2 surprising For instance showed respect goals given LTL formulae deterministic strategies equally hard verify equilibrium proper ties studied ENash ANash regardless arenas modelling systems explicitly speciﬁed srml implicitly given iterated Boolean games iBGs 29 induced Kripke struc tures exponential number variables Recall general srml model iBG exponential size Less surprising fact complexity key questions studied 2EXPTIMEhard This high com putational complexity presents real challenge practical implementations Our results LTL 154 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 S A S A S 0 A v S A J C1 Cn S A S A exec J v S 0 A π A π A exec J v exec J v function Arena2Kripke A N cid4 m1 mi mn R A π A 1 2 C1 I1 Cn In 3 4 5 6 7 endfor X 8 9 X cid12 S A X S A 10 11 12 13 14 15 16 17 18 endwhile 19 20 21 22 23 24 25 26 endfor C1 enabled1π Av Cn enablednπ Av J C1 Cn exec J π Av π Av R A R A v v cid14 S A S A endif endfor v v endfor endfor cid14 cid14 C1 enabled1π Av Cn enablednπ Av J C1 Cn S A S A exec J π A v π A π A exec J π A v exec J π Av Fig 12 Algorithm generating Kripke structures Here K A S A S 0 N cid4 m1 mn passed input A R A π A output function produced srml arena A synthesis problems best As consequence practical implementations desired look suitable simpliﬁcations main setting instance games memoryless strategies games goals simpler LTL syntactic fragments In case better EXPTIME general LTL goals case complexity reduced PSPACE safety goals Either way practical implementation probably deal associated synthesis problem logical speciﬁcation likely high complexity In fact deal succinct speciﬁcations closer ones realistic scenarios clearly shown 5 high complexities obtained explicit representations simply fact players goals expressed language LTL An alternative studied 28 Nash equilibria studied respect fragments LTL iBG framework Moreover expressivity standpoint RMGs general iBGs Indeed class induced Kripke struc tures induced RMGs strictly larger class semantic structures associated iBGs A simple example distributed algorithm Section 53 speciﬁed iBG srml representation Then RMGs expressive power complexity A somewhat different question extent techniques solution concepts developed practice example designing electronic commerce systems The issue touches substantial debate game theory concerning applicability gametheoretic concepts If view game theory descriptive theory aims predict people actually strategic settings gametheoretic solution concepts limited value cases 7 extensive discussion There points First argue people fail rational sense game theory deﬁnes design programs decisions design act rationally Second suggest Nash equilibrium analysis starting point understanding rational dynamics end point The Nash equilibrium computations RMG subset overall possible computations hand assuming rational action actual trajectory lie Nash equilibrium set But analysis present paper stops point identiﬁed rational computations Finally aim use techniques understand rational dynamics human work needed developing computational models human strategic decision making This territory behavioural game theory somewhat scope present paper In future work plan use speciﬁcation language games framework implement model checker equi librium properties gamelike concurrent multiagent systems It interesting investigate complexity results obtained far affected adoption temporal logic languages solution cepts Studying relationship Markov games probabilistic model checking interesting logics PCTL 43 It interesting study situations actions players unreliable effects nondeterministic actions Finally work remains settings considers imperfect information 34 general payoff sets preference relations All issues certainly investigated J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 155 cid18 let L set osf ϕ ordered according length shortest ﬁrst c 1 L Lc propositional formula cid14 Lc repeat s cid14 S A return π As function realizablei ϕ s 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 endfor 19 ϕ cid18s return cid9 return elsif Lc Xψ cid14 return cani ψ s elsif Lc ψ U χ ψ cid18s cid18s change cid18 endif endfor χ cid18s cid14 cid18s cid14 endif cid14 cani ψ U χ s cid14 ψ U χ cid14 g Ci T J C1 g Cn function cani ϕ s 1 C1 enabled1π As Cn enablednπ As 2 ﬂag 3 4 5 6 7 8 9 10 endif 11 endfor 12 return f lag T T exec J π A s cid14 s ﬂag cid9 cid14 T ϕ cid18s endfor T s cid14 Fig 13 Algorithm checking player realise formula ϕ state s Acknowledgements We like thank Giuseppe Perelli Alexis Toumi useful comments earlier version paper Richard Appleby helped debug algorithms This work ﬁnancially supported ERC Grant 291528 RACE Oxford The paper includes motivationalbackground material AAAI2016 paper 75 emphasise results presented present paper new Appendix A Algorithms main text In appendix present algorithms held main text interests readability First Fig 12 presents algorithm takes input RML arena A arena computes Kripke structure induced A From inspection straightforward algorithm correct guaranteed terminate time exponential A Lines 37 compute initial states S 0 A Lines 818 extend initial states compute reachable states Finally lines 1926 compute relation R A Fig 13 presents algorithm checking OLTL formula ϕ realizable player state s Kripke structure K A S A S 0 A R A π A The algorithm works backwards induction building labelling function cid18 associates state S A formulae realize state The algorithm closely related Zermelos algorithm critically depends fact input OLTL formula The algorithm makes use subsidiary function cani ϕ s checks player guarded command available execution state s states result execution guarded command formula ϕ true It straightforward construction algorithm correct guaranteed terminate time exponential size A 156 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 References 1 S Almagor G Avni O Kupferman Repairing multiplayer games L Aceto D Frutos Escri Eds Proceedings TwentySixth Annual Conference Concurrency Theory CONCUR15 Madrid Spain Leibniz International Proceedings Informatics LIPIcs 2015 pp 325339 2 R Alur TA Henzinger Reactive modules Form Methods Syst Des 15 11 1999 748 3 R Alur TA Henzinger O Kupferman Alternatingtime temporal logic J ACM 49 5 2002 672713 4 R Alur TA Henzinger FYC Mang S Qadeer SK Rajamani S Ta siran MOCHA modularity model checking Proceedings 10th International Conference Computer Aided Veriﬁcation CAV98 LNCS vol 1427 Springer 1998 pp 521525 5 R Alur S La Torre P Madhusudan Playing games boxes diamonds Proceedings Fourteenth Annual Conference Concurrency Theory CONCUR03 LNCS vol 2761 Springer 2003 pp 127141 6 K Binmore Fun Games A Text Game Theory DC Heath Company Lexington MA 1992 7 K Binmore Does Game Theory Work The MIT Press Cambridge MA 2007 8 P Bouyer R Brenguier N Markey M Ummels Pure Nash equilibria concurrent games Log Methods Comput Sci 2 2015 9 9 RS Boyer JS Moore Eds The Correctness Problem Computer Science The Academic Press London England 1981 10 R Brafman C Domshlak On complexity planning agent teams implications single agent planning Artif Intell 198 2013 5271 11 N Bulling W Jamroga J Dix Reasoning temporal properties rational play Ann Math Artif Intell 53 14 2008 51114 12 T Bylander The computational complexity propositional STRIPS planning Artif Intell 69 12 1994 165204 13 K Chatterjee TA Henzinger A survey stochastic ωregular games J Comput Syst Sci 78 2012 394413 14 K Chatterjee TA Henzinger N Piterman Strategy logic Inf Comput 208 6 2010 677693 15 EM Clarke EA Emerson Design synthesis synchronization skeletons branching time temporal logic Proceedings Workshop Logics Programs LNCS vol 131 SpringerVerlag Berlin Germany 1981 pp 5271 16 EM Clarke O Grumberg DA Peled Model Checking The MIT Press Cambridge MA 2000 17 G Coulouris J Dollimore T Kindberg Distributed Systems Concepts Design AddisonWesley 2005 18 S Demri V Goranko M Lange Temporal Logics Computer Science FiniteState Systems Cambridge Tracts Theoretical Computer Science vol 58 Cambridge University Press 2016 pp 9961072 19 S Demri Ph Schnoebelen The complexity propositional linear temporal logics simple cases Inf Comput 174 1 2002 84103 20 EA Emerson Temporal modal logic Handbook Theoretical Computer Science Volume B Formal Models Semantics Elsevier 1990 21 EA Emerson EM Clarke Using branching time temporal logic synthesize synchronization skeletons Sci Comput Program 2 3 1982 241266 22 RE Fikes N Nilsson STRIPS new approach application theorem proving problem solving Artif Intell 2 1971 189208 23 D Fisman O Kupferman Y Lustig Rational synthesis 16th International Conference Tools Algorithms Construction Analysis Systems TACAS10 LNCS vol 6015 Springer 2010 pp 190204 24 D Gale LS Shapley College admissions stability marriage Am Math Mon 69 1 1962 915 25 M Ghallab D Nau P Traverso Automated Planning Theory Practice Morgan Kaufmann Publishers San Mateo CA 2004 26 J Grant S Kraus M Wooldridge I Zuckerman Manipulating games sharing information Stud Log 102 2014 267295 27 D Gusﬁeld RW Irving The Stable Marriage Problem Structure Algorithms MIT Press Cambridge MA USA 1989 28 J Gutierrez P Harrenstein G Perelli M Wooldridge Expressiveness Nash equilibrium iterated Boolean games CM Jonker S Marsella J Thangarajah K Tuyls Eds Proceedings 2016 International Conference Autonomous Agents Multiagent Systems AAMAS16 ACM 2016 pp 707715 29 J Gutierrez P Harrenstein M Wooldridge Iterated Boolean games F Rossi Ed Proceedings TwentyThird International Joint Conference Artiﬁcial Intelligence IJCAI13 IJCAIAAAI Press 2013 pp 932938 30 J Gutierrez P Harrenstein M Wooldridge Reasoning equilibria gamelike concurrent systems C Baral G De Giacomo Th Eiter Eds Proceedings Fourteenth International Conference Principles Knowledge Representation Reasoning KR14 Vienna Austria AAAI Press 2014 31 J Gutierrez P Harrenstein M Wooldridge Expressiveness complexity results strategic reasoning Proceedings TwentySixth Annual Conference Concurrency Theory CONCUR15 Madrid Spain Leibniz International Proceedings Informatics LIPIcs vol 42 2015 pp 268282 32 J Gutierrez P Harrenstein M Wooldridge Iterated Boolean games Inf Comput 242 2015 5379 33 J Gutierrez P Harrenstein M Wooldridge Reasoning equilibria gamelike concurrent systems Ann Pure Appl Logic 169 2 2017 373403 34 J Gutierrez G Perelli M Wooldridge Imperfect information reactive modules games C Baral JP Delgrande F Wolter Eds Proceedings Fifteenth International Conference Principles Knowledge Representation Reasoning KR16 AAAI Press 2016 pp 390400 35 J Gutierrez M Wooldridge Equilibria concurrent games event structures Proceedings Joint Meeting TwentyThird EACSL Annual Conference Computer Science Logic CSL14 TwentyNinth Annual ACMIEEE Symposium Logic Computer Science LICS14 Vienna Austria 2014 Article No 46 36 P Harrenstein Logic Conﬂict PhD thesis Utrecht University 2004 37 P Harrenstein W van der Hoek JJCh Meyer C Witteveen Boolean games J van Benthem Ed Proceedings Eighth Conference Theoretical Aspects Rationality Knowledge TARK01 Siena Italy 2001 pp 287298 38 M Hennessy RA Connolly Milner Algebraic laws nondeterminism concurrency J ACM 32 1 1985 137161 39 W Jamroga W Penczek Speciﬁcation veriﬁcation multiagent systems N Bezhanishvili V Goranko Eds Lectures Logic Computa tion LNCS vol 7388 Springer 2012 pp 210263 40 L Kleinrock Analysis timeshared processor Nav Res Logist Q 11 1 1964 5973 41 O Kupferman MY Vardi P Wolper An automatatheoretic approach branching time model checking J ACM 47 2 2000 312360 42 Orna Kupferman P Madhusudan PS Thiagarajan Moshe Y Vardi Open systems reactive environments control synthesis C Palamidessi Ed Proceedings Eleventh International Conference Concurrency Theory CONCUR00 LNCS vol 1877 Springer 2000 pp 92107 43 M Kwiatkowska G Norman D Parker PRISM probabilistic model checking performance reliability analysis ACM SIGMETRICS Perform Eval Rev 36 4 2009 4045 44 L Lamport A new solution Dijkstras concurrent programming problem Commun ACM 17 8 1974 453455 45 D Manlove Algorithmics Matching Under Preferences World Scientiﬁc Publishing Company 2013 46 Z Manna A Pnueli The Temporal Logic Reactive Concurrent Systems Springer 1992 47 Z Manna A Pnueli Temporal Veriﬁcation Reactive Systems Safety Springer 1995 48 E Marchioni M Wooldridge Łukasiewicz games logicbased approach quantitative strategic interactions ACM Trans Comput Log 16 4 2015 Article No 33 49 M Maschler E Solan S Zamir Game Theory Cambridge University Press Cambridge England 2013 50 F Mogavero A Murano G Perelli MY Vardi Reasoning strategies modelchecking problem ACM Trans Comput Log 15 4 2014 J Gutierrez et al Artiﬁcial Intelligence 248 2017 123157 157 land 2008 51 F Mogavero A Murano MY Vardi Reasoning strategies K Lodaya M Mahajan Eds Proceedings IARCS Annual Conference Foundations Software Technology Theoretical Computer Science FSTTCS10 Leibniz International Proceedings Informatics LIPIcs vol 8 2010 pp 133144 52 N Nisan T Rougarden E Tardos VV Vazirani Eds Algorithmic Game Theory Cambridge University Press Cambridge England 2007 53 MJ Osborne A Rubinstein A Course Game Theory The MIT Press Cambridge MA 1994 54 CH Papadimitriou Computational Complexity AddisonWesley Reading MA 1994 55 GL Peterson Myths mutual exclusion problem Inf Process Lett 12 3 1981 115116 56 A Pnueli The temporal logic programs Proceedings Eighteenth IEEE Symposium Foundations Computer Science FOCS77 The Society 1977 pp 4657 57 A Pnueli R Rosner On synthesis asynchronous reactive module G Ausiello M DezaniCiancaglini S Ronchi Della Rocca Eds Proceed ings Sixteenth International Colloquium Automata Languages Programs ICALP89 1989 pp 652671 58 AS Rao M Georgeff Decision procedures BDI logics J Log Comput 8 3 1998 293344 59 G Ricart AK Agrawala An optimal algorithm mutual exclusion networks Commun ACM 24 1 1981 917 60 AE Roth MAO Sotomayor TwoSided Matching A Study Game Theoretic Modelling Analysis Cambridge University Press 1990 61 TC Schelling The Strategy Conﬂict Harvard University Press 1981 62 Y Shoham K LeytonBrown Multiagent Systems Algorithmic GameTheoretic Logical Foundations Cambridge University Press Cambridge Eng 63 AP Sistla EM Clarke The complexity propositional linear temporal logics J ACM 32 3 1985 733749 64 LJ Stockmeyer AK Chandra Provably diﬃcult combinatorial games SIAM J Comput 8 2 1979 151174 65 A Toumi J Gutierrez M Wooldridge A tool automated veriﬁcation Nash equilibria concurrent games M Leucker C Rueda FD Valencia Eds Proceedings Twelfth International Colloquium Theoretical Aspects Computing ICTAC15 LNCS vol 9399 Springer 2015 pp 583594 66 W van der Hoek W Jamroga M Wooldridge A logic strategic reasoning M Pechoucek D Steiner S Thompson Eds Proceedings Fourth International Joint Conference Autonomous Agents Multiagent Systems AAMAS05 2005 pp 157164 67 W van der Hoek A Lomuscio M Wooldridge On complexity practical ATL model checking H Nakashima MP Wellman G Weiss P Stone Eds Proceedings Fifth International Joint Conference Autonomous Agents Multiagent Systems AAMAS06 ACM 2006 pp 201208 68 W van der Hoek M Wooldridge Towards logic rational agency Log J IGPL 11 2 2003 135159 69 MY Vardi P Wolper An automatatheoretic approach automatic program veriﬁcation First Symposium Logic Computer Science LICS86 IEEE Computer Society 1986 pp 322331 vol 2 Amsterdam University Press 2008 pp 629736 70 Moshe Y Vardi Thomas Wilke Automata logics algorithms Logic Automata History Perspectives Texts Logic Games 71 Glynn Winskel Event structures W Brauer W Reisig G Rozenberg Eds Advances Petri Nets 1986 Proceedings Advanced Course Bad Honnef 819 September 1986 Part 2 Petri Nets Applications Relationships Other Models Concurrency LNCS vol 255 1987 pp 325392 72 M Wooldridge An Introduction Multiagent Systems second edition John Wiley Sons 2009 73 M Wooldridge Bad equilibria L De Raedt C Bessiere D Dubois P Doherty P Frasconi F Heintz P Lucas Eds Proceedings Twentieth European Conference Artiﬁcial Intelligence ECAI12 Montpellier France 2012 pp 611 74 M Wooldridge U Endriss S Kraus J Lang Incentive engineering boolean games Artif Intell 195 2013 418439 75 M Wooldridge J Gutierrez P Harrenstein E Marchioni G Perelli A Toumi Rational veriﬁcation model checking equilibrium checking D Schuurmans M Wellman Eds Proceedings Thirtieth AAAI Conference Artiﬁcial Intelligence AAAI16 Phoenix AZ 2016 pp 41844190 76 M Wooldridge NR Jennings Intelligent agents theory practice Knowl Eng Rev 10 2 1995 115152