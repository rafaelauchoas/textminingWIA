Artiﬁcial Intelligence 173 2009 748788 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Practical solution techniques ﬁrstorder MDPs Scott Sanner Craig Boutilier b Statistical Machine Learning Group National ICT Australia Canberra ACT 0200 Australia b Department Computer Science University Toronto Toronto ON M5S 3H5 Canada r t c l e n f o b s t r c t Article history Received 21 October 2007 Received revised form 4 November 2008 Accepted 9 November 2008 Available online 24 November 2008 Keywords MDPs Firstorder logic Planning number domain objects exponential Many traditional solution approaches relationally speciﬁed decisiontheoretic planning problems stated probabilistic planning domain description language PPDDL ground speciﬁcation respect speciﬁc instantiation domain objects apply solution approach directly resulting ground Markov decision process MDP Unfortunately space time complexity grounded solution approaches polynomial predicate arity number nested quantiﬁers relational problem speciﬁcation An alternative grounding relational planning problem tackle problem directly relational level In article propose approach translates expressive subset PPDDL representation ﬁrstorder MDP FOMDP speciﬁcation derives domainindependent policy grounding intermediate step However generality come set challengesthe purpose article explore practical solution techniques solving FOMDPs To demonstrate applicability techniques present proofofconcept results ﬁrstorder approximate linear programming FOALP planner problems probabilistic track ICAPS 2004 2006 International Planning Competitions Crown Copyright 2008 Published Elsevier BV All rights reserved 1 Introduction There extensive line research years aimed exploiting structure order compactly repre sent eﬃciently solve decisiontheoretic planning problems modeled Markov decision processes MDPs 12 While traditional approaches operations research typically use enumerated state action models 62 proved impractical largescale AI planning tasks number distinct states model easily exceed limits primary secondary storage modern computers Fortunately MDPs compactly described factored state action representation exploiting independences reward transition functions 12 The independencies regularities laid bare representations exploited exact approximate solution methods Such techniques permitted practical solution MDPs possible enumerated state action models 22363875 However factored representations type structure exploited representation MDPs Many MDPs described abstractly terms classes domain objects relations domain objects change time For example logistics problem speciﬁed probabilistic planning domain description Parts article appeared preliminary form S Sanner C Boutilier Approximate linear programming ﬁrstorder MDPs Uncertainty Artiﬁcial Intelligence UAI05 Edinburgh Scotland 2005 pp 509517 S Sanner C Boutilier Practical linear evaluation techniques ﬁrstorder MDPs Uncertainty Artiﬁcial Intelligence UAI06 Boston MA 2006 Corresponding author Email address ssannernictacomau S Sanner 00043702 matter Crown Copyright 2008 Published Elsevier BV All rights reserved doi101016jartint200811003 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 749 language PPDDL 89 refer domain objects boxes trucks cities If objective deliver boxes assigned destination cities locations boxes trucks change result actions taken pursuit objective Since action templates loading unloading box likely apply generically domain objects speciﬁed independently ground domain instantiation 4 trucks 5 boxes 9 cities permits compact MDP descriptions exploiting existence domain objects relations objects ability express objectives action effects quantiﬁcation Unfortunately relational speciﬁcations PPDDL permit compact domainindependent descriptions variety MDPs compactness translate directly effective solutions underlying planning problems For example approach solving relational decisiontheoretic planning problem ﬁrst construct sets state variables actions possible ground instantiations relation action respect speciﬁc domain 4 trucks 5 boxes 9 cities Then approach apply known solution techniques ground factored representation MDP Unfortunately approach domainspeciﬁc size ground MDP grows polynomially number domain objects exponentially predicate arity number nested quantiﬁers problem speciﬁcation For suﬃciently large domains complex relational MDP speciﬁcations grounding viable option An alternative approach grounding apply solution approach directly relational level In article discuss technique translates expressive subset relational PPDDL representation ﬁrstorder MDP FOMDP 14 speciﬁcation A symbolic policy derived respect FOMDP resulting domain independent solution exploits purely lifted version Bellman equations avoids grounding intermediate step This stands contrast alternate ﬁrstorder approaches discussed Section 62 induce symbolic representations solution samples Bellman equation ground problem instances Unfortunately use ﬁrstorder logical languages FOMDP speciﬁcation solution introduces need computationally expensive logical simpliﬁcation theorem proving While means exact solutions tractable FOMDPs high degree regularity structure present FOMDPs exploited approximate heuristic solution techniques proposed article To end article continues tradition exploiting structure ﬁnd effective solutions large MDPs After providing review MDPs relevant solution techniques Section 2 FOMDP formalism solution symbolic dynamic programming 14 Section 3 following contributions practical solution FOMDPs 1 Section 322 We translate subset PPDDL problems including universal conditional effects FOMDPs 2 Section 41 We exploit logical structure reward value transition functions ﬁrstorder extensions algebraic decision diagrams ADDs 4 use exact approximate FOMDP solutions 3 Section 42 We apply additive decomposition techniques universal reward speciﬁcations manner leads eﬃcient solutions FOMDP representation reasonable empirical performance example problems 4 Section 53 We generalize approximate linear programming technique MDPs 193672 case FOMDPs casting optimization problem terms ﬁrstorder linear program 5 Section 54 We deﬁne linear program LP ﬁrstorder constraints provide constraint generation algorithm utilizes relational generalization variable elimination 91 exploit constraint structure eﬃcient solution ﬁrstorder LP FOLP To demonstrate eﬃcacy techniques present proofofconcept results ﬁrstorder approximate linear programming FOALP planner problems probabilistic track ICAPS 2004 2006 International Plan ning Competitions Section 56 Following discuss number related ﬁrstorder decisiontheoretic planning approaches discuss relative advantages disadvantages Section 6 We conclude discussion possible extensions techniques Section 7 2 Markov decision processes Markov decision processes MDPs ﬁrst introduced developed ﬁelds operations research eco nomics 64173 The MDP adopted model decisiontheoretic planning fully observable state ﬁeld artiﬁcial intelligence 7812 provides formal underpinning framework article In section algorithmic approaches making optimal sequential decisions MDPs later generalize case ﬁrstorder MDPs The following presentation derives Puterman 62 21 The MDP model optimality criteria Formally ﬁnite state action MDP speciﬁed tuple cid3S A T R h γ cid4 S set distinct states An agent MDP effect changes state executing actions set A We base initial presentation section ﬁnite state action MDPs follows assume inﬁnite discrete state action 750 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 space The standard techniques MDPs discussed generalized countable continuous state action spaces 62 The transition function T family probability distributions T s s cid5a s denotes probability cid5 P s cid5 S action A executed This representation enforces Markov world transitions s S s property distribution states st1 time t 1 independent previous state sti action ati cid2 1 given st The preferences agent encoded reward function R S A R In addition specifying singlestep preferences agent specify trades reward horizon h remaining decision stages In article focus expected sum discounted accumulated reward inﬁnite horizon h compatible approximate linear programming approach adopt later In calculation discounted accumulated reward discount rewards t time steps future discount factor γ t γ 0 1 Throughout article assume γ 1 The use γ 1 allows model notion immediate reward r worth equivalent reward delayed time steps future Practically γ 1 required ensure total expected reward bounded case inﬁnite horizon MDPs A stationary policy takes form π S A π s denoting action executed state s The value policy π expected sum discounted future rewards horizon h given π executed Its value function given 1 V π s Eπ cid2 cid4 hcid3 t0 γ t rt s0 s cid5 πV s arg max aA Rs γ cid3 scid5S cid6 cid6 rt reward obtained time t γ discount factor deﬁned s0 initial starting state A greedy policy πV respect value function V simply policy takes action state maximizes expected value respect V deﬁned follows P s cid5s aV s cid5 2 Thus value function derive corresponding greedy policy represents best action choice respect value estimation An optimal policy π greedy policy respect optimal value function V optimal policy V π s V s We note V satisﬁes following ﬁxedpoint equality inﬁnite horizon MDP maximizes value function states An optimal policy π likewise optimal value function value T s s cid5 V cid5 s 3 cid5 V s max Rs γ cid3 scid5S Finding V denote attempt approximating V constitutes ﬁnding exact solution MDP Throughout article use term solution loosely approximation guarantees error bounds simply heuristic 22 MDP solution algorithms In section exact approximate solution techniques MDPs later extend ﬁrstorder case 221 Value iteration We begin discussion MDP solutions providing equations form basis stochastic dynamic programming algorithms solve MDPs We deﬁne V 0 π s Rs π s inductively deﬁne tstagetogo value function policy π follows π s Rs π s γ V t T s π s s cid5 V t1 π s cid5 4 Based deﬁnition Bellmans principle optimality 6 establishes following relationship optimal value function stage t optimal value function previous stage t 1 cid5 V ts max aA Rs γ cid6 T s π s s cid5 V t1s cid5 5 The computation V t V t1 relationship referred Bellman backup The value iteration algorithm consists repeatedly performing Bellman backups compute tstagetogo value functions We note Bellman backup rewritten following steps separate backup value function single action maximization value actions cid3 scid5S cid3 scid5S S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 Q ts Rs γ V ts max aA cid7 cid8 Q ts cid3 scid5S T s s cid5 V t1s cid5 Puterman 62 shows terminating following Bellman error condition met cid9 cid9 cid9 cid9V ts V t1s max s cid41 γ 2γ 751 6 7 8 guarantees estimated value function V t cid4optimal inﬁnite horizon value cid4 optimal value maxs V ts V s cid4 We note value iteration approach requires time polynomial backup depth d number states actions O S2 A d Puterman 62 provides proof value iteration converges linearly 222 Linear programming An MDP solved following linear program LP Variables V s s S cid3 Minimize V s sS Subject 0 cid2 Rs γ cid3 scid5S P s cid5s aV s cid5 V s s S A 9 Puterman 62 provides proof solution LP optimal value function MDP 223 Approximate linear programming One general popular approximate solution technique MDPs linearvalue function approximation 36 4647717278 Representing value functions linear combination basis functions convenient computational properties evident incorporate relational structure MDP model However useful properties linear value function representations lead MDP solutions requiring optimization respect linear objectives linear constraintsthat formulated LPs In nstate MDP exact value function speciﬁed vector Rn This vector approximated value function V cid10w linear combination k ﬁxed basis functions nvectors denoted bis V cid10w s kcid3 i1 w bis 10 The linear subspace spanned basis set generally include true value function use pro jection methods minimize error measure true value function linear combination basis functions The basis functions speciﬁed domain experts constructed learned automated fash ion 61 51 We consider ﬁrstorder methods automated basis function construction Section 5 related work Section 6 Approximate linear programming ALP simply extension linear programming solution MDPs case value function approximated In linear value function representation objective constraints linear weights optimized leading direct LP formulation Consequently arrive following variant previous exact LP solution Variables Minimize cid10w cid3 sS V cid10w s Subject 0 cid2 Rs γ cid3 scid5S P s cid5s V cid10w s cid5 V cid10w s s S A 11 23 Selecting MDP solution approach The choice use linear programming dynamic programming solution MDPs clear Linear programming offers simple oneshot solution relies eﬃcient LP solvers Dynamic programming straightforward implement require large number iterations converge However choice exact vs approximate invariably determined size state space For suﬃciently large state spaces approximate solution techniques viable option But statement depends critically measures size state space 752 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 Fig 1 An example BoxWorld problem Trucks drive solid lines planes ﬂy dashed lines The goal instance boxes Paris indicated star Despite promise exact approximate solution techniques discussed represent value function policy required vectors functions explicitly enumerated state action space This simply feasible largescale AI planning problems Fortunately representations factored relational suited decisiontheoretic planning require explicit state action enumeration problem repre sentation solution To end concerned exploitation relational planning structure remainder article 3 Firstorder MDPs Given relational representations natural planning problems makes sense attempt exploit relational structure ﬁrstorder level resorting grounding This precisely idea ﬁrstorder MDP model FOMDP symbolic dynamic programming solution 14 review section For remainder article refer FOMDP qualiﬁcation refer speciﬁc formalization presented 14 possible ﬁrstorder MDP formalizations associated solution approaches discuss alternatives Section 6 The reader familiar motivations FOMDPs presentation notation 14 wish skip section proceed directly main contributions article Sections 4 5 31 Motivation Before introduce FOMDPs solution begin basics relational planning problem speciﬁcations motivate need exploiting structure lifted ﬁrstorder level ground propositional level 311 Relational planning speciﬁcations We assume basic familiarity unsorted ﬁrstorder logic equality While use sorted notation specifying object types variables predicate slots assume sort information compiled unsorted logical form Sort c φc rewritten c Sortc φc likewise Sort c φc rewritten c Sortc φc Assuming transformations draw logical notation semantics unsorted ﬁrstorder logic given 16 Speciﬁcally Predicate Symbols We assume set predicates P arity 0 cid3 cid3 m ﬁnite maximum m We assume P 2 usual interpretation Function Symbols We assume set function symbols f j arity 0 cid3 j cid3 n ﬁnite maximum n In addition use notational conventions All predicates including unary predicates denoting domain object classes capitalized variables constants lowercased We denote types predicate arguments notation φSort1 Sortk predicate arity k1 1 Logically requires background theory axiom x1 xk φx1 xk cid10 k 11 Sorti xi predicate φSort1 Sortk S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 753 Domain Object Types Box Truck City Relational State Descriptors parameter sorts BoxInBox City TruckInTruck City BoxOnBox Truck Reward Box bBoxInb paris 10 0 Actions parameter sorts T ransition Function loadBox b Truck t Effects probability 09 City c BoxInb c TruckInt c BoxOnb t City c BoxInb c TruckInt c BoxInb c unloadBox b Truck t Effects probability 09 City c BoxOnb t TruckInt c BoxInb c City c BoxOnb t TruckInt c BoxOnb t driveTruck t City c Effects probability 10 City c1 TruckInt c1 TruckInt c City c1 TruckInt c1 TruckInt c1 noop No effects Fig 2 A PPDDLstyle representation simple variant BoxWorld problem The deterministic PDDL subset exclude probabilistic annota tions effects assuming effects occur probability 10 We view decisiontheoretic planning problems consisting classes domain objects changing relations hold objects different points time For example BoxWorld logistics problem 79 illustrated Fig 1 classes domain objects Box City Truck Plane For relations hold BoxInBox City BoxOnTruckBox Truck TruckInTruck City PlaneInPlane City BoxOnPlaneBox Plane In framework generic action templates loading unloading box truck plane driving trucks ﬂying planes cities likely apply generically domain objects planning problem speciﬁed independently ground domain instantiation One recent language representing relational probabilistic planning problems PPDDL 89 At core PPDDL probabilistic extension subset PDDL conforming deterministic ADL planning language 58 ADL turn introduced universal conditional effects STRIPS representation 29 To compactness relational representation provide PPDDL representation BoxWorld problem Fig 2 simplicity omit Plane class objects associated actions relations abbreviate BoxOnTruckBox b Truck t BoxOnBox b Truck t General PPDDL speciﬁcations compact problems PPDDL subset refer article For example general PPDDL universal conditional effects probabilities arbitrarily nested allowing exponentially compact representations probabilistic action effects achieved probabilities toplevel effects 66 In addition general PPDDL speciﬁcations translated PPDDL subset described If general PPDDL speciﬁcation uses probabilistic effects nested universal effects box falls truck independent probability generally impossible translate problem restricted PPDDL subset requires indeﬁnitely factored transition probability model expressed ﬁnite probability speciﬁcations restricted level effects While discuss model expressivity refer reader Sanner Boutilier 70 Chapter 6 Sanner 67 treatment issues ﬁrstorder MDPs While meaning PPDDL representation Fig 2 intended relatively straightforward important points explained First assume actions executed states encode explicit preconditions While assumption necessary effect value optimal policy domain noop action helps simplify later notation When action executes probabilistic effect realized independently according speciﬁed probability For example unload action realizes effects 90 time drive action deterministically realizes effects execution Probabilistic effects toplevel effect speciﬁcation consist conjunctions effects Each individual effect universal conditional Universal effects denoted universally quantiﬁed variables clause permit effect apply arbitrary number objects explicitly named actions parameter list Conditional effects denoted arbitrary ﬁrstorder formulae specifying effects listed clause hold postaction state conditions hold preaction state When universally quantiﬁed variables shared whenthen clause pair refer effects universal conditional We note individual effect allowed mention positive negative relation portion clause A conjunction effects easily speciﬁed multiple effects condition Disjunctive nondeterministic effects prohibited PPDDL For example loadb t action executed effects realized probability 09 When effects realized city c satisﬁes BoxInb c TruckInt c preaction state BoxOnb t BoxInb c hold 754 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 Domain Object Instantiation Box box1 box2 box3 paris berlin rome Statevariable Atoms binary state variables Truck truck1 truck2 City BoxIn BoxInbox1 paris BoxInbox2 paris BoxInbox3 paris BoxInbox1 berlin BoxInbox2 berlin BoxInbox3 berlin BoxInbox1 rome BoxInbox2 rome BoxInbox3 rome TruckIn TruckIntruck1 paris TruckIntruck1 berlin TruckIntruck1 rome TruckIntruck2 paris TruckIntruck2 berlin TruckIntruck2 rome BoxOn BoxOnbox1 truck1 BoxOnbox2 truck1 BoxOnbox3 truck1 BoxOnbox1 truck2 BoxOnbox2 truck2 BoxOnbox3 truck2 Actions load loadbox1 truck1 loadbox2 truck1 loadbox3 truck1 loadbox1 truck2 loadbox2 truck2 loadbox3 truck2 unload unloadbox1 truck1 unloadbox2 truck1 unloadbox3 truck1 unloadbox1 truck2 unloadbox2 truck2 unloadbox3 truck2 drive drivetruck1 paris drivetruck1 berlin drivetruck1 rome drivetruck2 paris drivetruck2 berlin drivetruck2 rome T ransition Function Follows directly ground instantiation PPDDL actions Fig 2 Reward BoxInbox1 paris BoxInbox2 paris BoxInbox3 paris 10 0 Fig 3 One possible ground MDP instantiation BoxWorld FOMDP postaction state effects equivalent conditions When effects realized 10 loadb t executions state changes occur equivalent noop action One easily relationally speciﬁed domainindependent speciﬁcation allows compact MDP speciﬁ cations compared corresponding ground factored MDP representation For example consider instantiating PPDDL problem Fig 2 ground factored MDP representation Fig 3 assume problem instance domain instantiation boxes cities trucks While trivially small domain instantiation note factored MDP representation requires 21 propositional atoms corresponding million distinct states 18 distinct actions executed state And reward uses existential quantiﬁcation relational PPDDL speciﬁcation grounded obtain corresponding factored MDP representation Clearly n objects grounded factor formula Box b BoxInb paris contain Box state variables reward changed City c Box b BoxInb c ground reward representation contain Box City state variablesthus implying combinatorial growth number nested quantiﬁers In general number ground atoms factored MDP representation scale linearly number relations exponentially arity relation assuming domain object polynomially number domain objects ﬁll relation argument To let assume simplicity object class instantiations k instances Then single unary relation represented k ground atoms binary relation k2 atoms nary relation kn atoms Similarly size grounding quantiﬁed formula exponential number nested quantiﬁers linear number relations exponential size domain object classes quantiﬁed Assuming k instances object classes q nested nonvacuous quantiﬁers formulae containing r relations resulting unsimpliﬁed ground representation formula require rkq ground atoms For suﬃciently small predicate arities levels quantiﬁer nesting assuming remain constant problem domain size varies space requirements representing ground MDP acceptable Thus adequate space permit grounding relational MDP obtain factored MDP time ﬁnd optimal solution factored MDP grounding gives approach representing solving relational MDPs speciﬁc domain instances However note solving MDPs exactly known polynomial number states Section 222 number states exponential number ground atoms factored representation This Bellmans 6 wellknown curse dimensionality number ground atoms linear domain size implies exact solution methods discussed previously require time exponential domain size This precludes general possibility exact solutions grounded relational MDPs smallest domain sizes While suggests use approximation methods solving grounded MDPs useful lifted alternatives representing solving relational MDPs discuss S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 755 bBoxInb paris paris BoxOnb t noop value 10000 b t unloadb b b c t drivet c t loadb 1 t drivet b c value 890 TruckInt t BoxOnb t paris value 800 BoxInb t c2BoxInb c c value 720 1 value 647 noop value 00 TruckInt c c TruckInt c 1 TruckInt c2 Fig 4 A decisionlist representation expected discounted reward value exhaustive partitioning state space BoxWorld problem The optimal action shown partition optimal bindings action variables denoted correspond binding satisfying variable names state formula 312 Grounded vs lifted solutions In contrast grounded approach representing relational MDPs factored MDPs important point matter domain objects actual problem instance size PPDDL relational planning problem speciﬁcation Fig 2 remains constant Consequently invites following question avoid domain dependent blowup representation relational MDP PPDDL avoid domaindependent blowup solution Although discuss speciﬁcs ﬁnd domain independent solution PPDDL representation Fig 4 provide optimal domainindependent value function corresponding policy relational PPDDL speciﬁcation BoxWorld problem Fig 2 discount factor γ 09 The key features note state action abstraction value policy representation afforded ﬁrstorder speciﬁcation solution problem That solution refer speciﬁc set domain objects C y paris berlin rome provides solution possible domain object instantiations And BoxWorld problem represented grounded factored MDP suﬃciently large domain instanti ations solved domainindependent solution particular problem simple applies domain instances size power state action abstraction afforded ﬁrstorder logical representation Thus alternative idea grounding relational MDP speciﬁcation solving particular domain instance translate PPDDL relational speciﬁcation ﬁrstorder MDP representation directly amenable solutions lifted symbolic dynamic programming This approach obtains solution applies universally possible domain instantiations time complexity independent domain size As power lifted style solution exploits existence domain objects relations objects ability express objectives action effects quantiﬁcation 32 Situation calculus background Before present ﬁrstorder MDP FOMDP formalism discuss basics situation calculus turn provides logical foundations FOMDP representation We begin describing necessary background material situation calculus Reiters default solution frame problem 64 required understand FOMDPs This includes discussion basic ingredients situation calculus formulation actions situations ﬂuents relevant axioms unique names actions domainspeciﬁc axioms Next introduce effect axioms explain derived PDDL speciﬁcation Then effect axioms compiled successor state axioms underly default solution frame problem situation calculus We conclude introducing regression operator Regr prove crucial symbolic dynamic programming solution ﬁrstorder MDPs 321 Basic ingredients The situation calculus ﬁrstorder language axiomatizing dynamic worlds 52 Its basic language elements consist actions situations ﬂuents Actions Actions ﬁrstorder terms consisting action function symbol arguments For example action loading box b truck t running BoxWorld example represented loadb t Situations A situation ﬁrstorder term denoting speciﬁc state The initial situation usually denoted s0 subsequent situations resulting action executions obtained applying function doa s representing situation resulting executing action situation s For example situation resulting loading box b truck t initial situation s0 driving truck t city c given term dodrivet c doloadb t s0 Fluents A ﬂuent relation truth value varies situation situation A ﬂuent simply relation argument situation term For example imagine initial state s0 ﬂuent BoxOnb t s0 false ﬂuents TruckInt c s0 BoxInb c s0 true Then semantics deterministic version loadb t 756 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 action formally deﬁne moment BoxOnb t doloadb t s0 holds We consider functional ﬂuents exposition easily added language adverse computational effects 64 322 From PDDL ﬁrstorder logic domain theory To axiomatize PDDL domain theory ﬁrstorder logic ﬁrst consider effects non effects actions We begin describing positive negative effect axioms characterize ﬂuents change result actions Note following presentation relations change states PPDDL rewritten ﬂuents extra situation term In addition assume axioms implicitly universally quantiﬁed Positive Effect Axioms positive effect axioms state actions explicitly ﬂuent true example c loadb t BoxInb c s TruckInt c s BoxOnb t doa s t unloadb t BoxOnb t s TruckInt c s BoxInb c doa s c1 drivet c TruckInt c1 s TruckInt c doa s Negative Effect Axioms negative effect axioms state actions explicitly ﬂuent false example c unloadb t BoxOnb t s TruckInt c s BoxOnb t doa s t loadb t BoxInb c s TruckInt c s BoxInb c doa s c drivet c TruckInt c1 s TruckInt c1 doa s In general positive negative effect axioms speciﬁed considering ways action affect ﬂuent Fortunately axioms easy derive directly PDDL representation given Fig 2 In fact verify effect axioms simply syntactic rewrites PDDL effects following transformations 1 The action PDDL effect placed equality LHS 2 All universal quantiﬁers universal effects dropped unquantiﬁed variables assumed universally quantiﬁed effect axioms 3 The conditions PDDL effect conjoined LHS ﬂuents speciﬁed terms situation s 4 The portion effect single literal placed RHS parameterized postaction situation doa s Whether literal negated nonnegated respectively determines resulting axiom negative positive 5 Any free variables appearing LHS appearing free action term explicitly existen tially quantiﬁed LHS This takes care specifying changes provided axioms specifying change socalled frame axioms Obviously want prove useful theory specify frame axioms Otherwise able infer properties successor predecessor state action simple noop However specifying exactly change compact manner extremely diﬃcult problem solve situation calculusthis course infamous frame problem An especially elegant solution frame problem proposed 63 In solution specify positive negative effects ﬂuent conveniently translation PDDL We use following normal form positive effect axioms F ﬂuent γ F cid10x s represents ﬁrstorder formula true s results F cid10x doa s true action acid10x executed situation s γ F cid10x s F cid10x doa s Likewise use following normal form negative effect axioms γ true s results F cid10x doa s false action acid10x executed situation s 12 F cid10x s represents ﬁrstorder formula γ F cid10x s F cid10x doa s 13 We note potential difference previous presentation positive negative effect axioms normal form exactly positive effect axiom positive ﬂuent negative effect axiom negative ﬂuent This happens case example use simple logical equivalence C1 F C2 F C1 C2 F rewrite set effect axioms derived PDDL subset PPDDL normal form Next need add unique axioms pairs distinct action names A B stating Acid10x cid17 Bcid10y 14 15 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 identical actions identical arguments Ax1 xk A y1 yk x1 y1 xk yk 757 16 From normal form unique names axioms explanation closure axioms state effects hold world model Reiter showed build successor state axioms SSAs compactly encode effect frame axioms ﬂuent The format successor state axiom ﬂuent F follows F cid10x doa s ΦF cid10x s γ F cid10x s F cid10x s γ F cid10x s 17 For running BoxWorld example obtain following SSAs BoxOnb t doa s ΦBoxOnb t s c loadb t BoxInb c s TruckInt c s BoxOnb t s c unloadb t BoxOnb t s TruckInt c s BoxInb c doa s ΦBoxInb c s t unloadb t BoxOnb t s TruckInt c s BoxInb c s t loadb t BoxInb c s TruckInt c s TruckInt c doa s ΦTruckInt c s c1 drivet c TruckInt c1 s TruckInt c s c1 drivet c TruckInt c1 s While notation bit cumbersome meaning axioms intuitive For example suc cessor state axiom BoxOnb t states box b truck t action iff action loaded box b truck t box b truck t begin action unload 323 Regression An important tool development ﬁrstorder MDPs ability ﬁrstorder state description ψ backproject deterministic action conditions held prior executing action ψ holds executing action This precisely deﬁnition regression Fortunately SSAs lend natural speciﬁcation deﬁnition regression want regress ﬂuent F cid10x doa s action need replace ﬂuent equivalent preaction formula ΦF cid10x s In general inductively deﬁne regression operator Regr ﬁrstorder formulae follows 64 RegrF cid10x doa s ΦF cid10x s Regrψ Regrψ Regrψ1 ψ2 Regrψ1 Regrψ2 Regrxψ xRegrψ Using unique names assumption actions regression rules perform regression ﬁrstorder logic formula For example b BoxInb paris dounloadb t s holds use regression operator determine held preaction situation s Following derivation rules Regrb BoxInb paris dounloadb t b RegrBoxInb paris dounloadb b ΦBoxInb paris unloadb s b t unloadb t s t s t BoxInb paris s t unloadb unloadb t BoxOnb t s TruckInt paris s loadb t BoxInb paris s TruckInt paris s t At point use unique names axioms actions simplify exploit rules distributing quantiﬁers renaming variables respect equality obtain following equivalent representation b t b b t t BoxOnb t s TruckInt paris s bb b b BoxInb paris s tt t b BoxInb paris s BoxOnb t s TruckInt paris s 758 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 We assume rest article object domains nonempty2 This leads following fully simpliﬁed form regression Regrb BoxInb paris dounloadb s TruckInt BoxOnb t s t paris s b BoxInb paris s This ﬁnal result intuitive states exists box b paris unloading box b t paris box paris begin truck t 18 truck 33 FOMDP representation Having deﬁned deterministic situation calculus translation simple PDDL model use building block obtain ﬁrstorder MDP FOMDP 14 restricted PPDDL syntax relational MDPs introduced earlier A FOMDP thought universal MDP abstractly deﬁnes state action transition reward tuple cid3S A T Rcid4 possible domain instantiations inﬁnite number ground MDPs In subsection formalize building blocks FOMDPs We begin introducing case notation operations discuss representation reward value function case statements Then stochastic actions represented building previous situation calculus formalization Once components deﬁned needed generalize dynamic programming solution MDPs ground case lifted case symbolic dynamic programming FOMDPs 331 Case representation rewards values probabilities We introduce useful variants case notation logical deﬁnition allow ﬁrstorder speciﬁcations rewards probabilities values required FOMDPs t caseφ1 t1 φn tn t φ1 t1 φn tn cid17 cid15 cid16 icid2n φi t ti 19 Here φi state formulae ﬂuents formulae contain term ti terms We note contrast states situations reﬂect entire history action occurrences However speciﬁcation FOMDP dynamics Markovian allows recovery state properties situation terms For reason represent situation term free variable s loss generality Often ti numerical constants φi partition state space We emphasize case notation logical formula syntactic form t caseφ1 t1 φn tn tabular form simply metalogical notation compact representation logical formula In metalogical notation cases formulae φi terms ti parameters case statement situation term s refer symbols underlying logical language At metalogical level case statement viewed relation case partition formulae overlap exhaustive Case statements compared inequalities manipulated arithmetic operations produce case statements metalogical level To illustrate notation concretely represent BoxWorld FOMDP reward function Rs PPDDL repre sentation Fig 2 following rCases statement reﬂects immediate reward obtained situation s rCases bBoxInb paris s 10 bBoxInb paris s 0 20 For simplicity presentation assume reward action dependent dependencies introduced diﬃculty Throughout text Rs represent generic FOMDP reward case statement rCases refer speciﬁc reward function Thus BoxWorld write Rs rCases Rs occurs substitute logical formula rCases Here ﬁrstorder formulae case statement divide possible ground states regions constantvalue exists box paris reward 10 achieved reward 0 achieved Likewise value function V s derive symbolic dynamic programming represented exactly case format Indeed V 0s Rs ﬁrstorder version value iteration The case representation specify transition probabilities We ﬁrst discuss operations performed case statements 2 Logically requires background theorem axiom object type Sort states o Sorto With use simpliﬁcation Sort o o o cid18 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 759 332 Case operations In subsection introduce operations applied case statements providing formal logical deﬁnition graphical example intuitively demonstrates application case operation We begin formally introducing following binary cid21 operators case statements 14 caseφi ti cid3 n caseψ j v j j cid3 m caseφi ψ j ti v j cid3 n j cid3 m caseφi ti cid3 n caseψ j v j j cid3 m caseφi ψ j ti v j cid3 n j cid3 m caseφi ti cid3 n cid21 caseψ j v j j cid3 m caseφi ψ j ti v j cid3 n j cid3 m 21 22 23 Intuitively perform operation case statements simply perform corresponding operation cross product case partitions operands Letting φi ψ j denote generic ﬁrstorder formulae perform crosssum case statements following manner φ1 10 φ2 20 ψ1 1 ψ2 2 φ1 ψ1 11 φ1 ψ2 12 φ2 ψ1 21 φ2 ψ2 22 Likewise perform cid21 max operations respectively subtracting multiplying taking max partition values Note binary operation involving scalar case statement scalar value C viewed casecid18 C cid18 tautology We use operators respectively denote summations products multiple case operands cid18 cid19 It important note partitions resulting application cid21 operators incon sistent identify inconsistency simply discard partitions When case partitions contain general ﬁrstorder logic formulae inconsistency detection undecidable However symbolic dynamic programming algo rithm discussed section required inconsistent partitions discarded failing simply results nonminimal case representation contains partitions corresponding world state In practice rely timelimited incomplete theorem proving inconsistency pruning We deﬁne additional operations case statements ﬁrst binary operation caseφi ti cid3 n caseψ j v j j cid3 m caseφ1 t1 φn tn ψ1 v 1 ψm vm 24 In operation simply construct union partitions case statements example φ1 10 φ2 20 ψ1 1 ψ2 2 φ1 10 φ2 20 ψ1 1 ψ2 2 Next deﬁne unary operations The cid10x casecid10x operation simply existentially quantiﬁes casecid10x statement Since casecid10x deﬁned logically disjunction distribute cid10x inside disjunction cid10x t φ1cid10x t1 φncid10x tn cid16 cid10x φicid10x t ti cid16 icid2n cid10x φicid10x t ti icid2n t cid10x φ1cid10x t1 cid10x φncid10x tn 25 Normally assume implicit t case statement logical clarity The second unary operation denoted casemax max produces case statement opposed single numerical value The result casemax case statement maximal possible value case argument assigned region state space resulting case statement Assuming case partitions presorted ti ti1 partitions equal value disjunctively merged formally deﬁne operation follows cid20 casemax caseφ1 t1 φn tn case φi cid22 φ j ti cid3 n cid21 ji 26 760 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 Following intuitive graphical exposition casemax operation casemax φ1 t1 φ2 t2 φn tn φ1 t1 φ2 φ1 t2 φn φ1 φ2 φn1 tn One easily verify partitions sorted highest value t1 lowest tn highest value consistent state formula input case statement assigned unique partition consistent state formulae resulting case statement If φi input mutually exclusive casemax results case statement logically equivalent original The application casemax requires constructing new partition formulae n times length original formulae case statement n partitions Fortunately use inconsistency detection discussed previously ﬁrstorder ADDs FOADD introduce section mitigate impact blowup respectively pruning inconsistent case partitions simplifying representation case formulae It important point case operators purely symbolic ti case partition values necessarily restricted constant numerical values arbitrary symbolic possibly statedependent terms 14 However casemax operator deﬁned implicitly requires ordering ti We assume rest section case values numeric symbolic apply natural operator ordering 333 Stochastic actions transition probabilities To state FOMDP transition function action stochastic agent actions decomposed collection deterministic actions corresponding possible outcome stochastic action We use case statement specify distribution according Nature choose deterministic action set stochastic action executed As consequence need formulate SSAs deterministic Natures choices 2155964 obviating need special treatment stochastic actions SSAs Letting Acid10x stochastic action Natures choices deterministic actions n1cid10x nkcid10x represent probability nicid10x given Acid10x executed s P n jcid10x Acid10x s Continuing translation simple PPDDL example note loadb t action set effects occurs probability 09 We use deterministic action loadSb t denote successful occurrence effects let deterministic action loadFb t denote failure effects execute To redeﬁne SSAs previous PDDL case loadb t stochastic action executed agent loadSb t loadFb t possible outcomes deterministic actions chosen Nature Similarly interpret actions unloadSb tunloadFb t deterministic outcomes unloadb t driveSt cdriveFt c deterministic outcomes drivet c For completeness correctness redeﬁne SSAs BoxWorld terms new deterministic actions BoxWorld FOMDP BoxOnb t doa s ΦBoxOnb t s c loadSb t BoxInb c s TruckInt c s BoxOnb t s c unloadSb t BoxOnb t s TruckInt c s BoxInb c doa s ΦBoxInb c s t unloadSb t BoxOnb t s TruckInt c s BoxInb c s t loadSb t BoxInb c s TruckInt c s TruckInt c doa s ΦTruckInt c s c1 driveSt c TruckInt c1 s TruckInt c s c1 driveSt c TruckInt c1 s Here simply replaced previous deterministic action names PDDL version deterministic success versions Natures choice actions use FOMDP Note failure versions actions correspond effects case obviously play role SSAs The frame assumption present SSAs ensures explicitly changed remains We specify distribution P n jcid10x Acid10x s Natures choice deterministic outcome case statements specify families distributions partitions case statements correspond different classes states stochastic action parameters distributions conditioned We denote speciﬁc instances P n jcid10x Acid10x s case statement pCasen jcid10x Acid10x s cid18 tautology example pCaseloadSb t loadb t s cid18 09 pCaseloadFb t loadb t s cid18 01 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 pCaseunloadSb t unloadb t s cid18 09 pCaseunloadFb t unloadb t s cid18 01 pCasedriveSb t driveb t s cid18 10 pCasedriveFb t driveb t s cid18 00 761 27 28 The axiomatization fully illustrate power FOMDP representation probabilities state action dependent brieﬂy digress demonstrate slightly interesting variant Suppose success driving truck city depends truck contains box b volatile material denoted predicate Volatileb Then specify family distributions Natures choices stochastic action follows pCasedriveSt c drivet c s pCasedriveFt c drivet c s bBoxOnb t s Volatileb 09 bBoxOnb t s Volatileb 10 bBoxOnb t s Volatileb 01 bBoxOnb t s Volatileb 00 Here transition probability drivet c easily conditioned state properties s action param eters t c It important note probabilities deterministic Natures choices stochastic action sum kcid23 j1 P n jcid10x Acid10x s cid18 1 cid10x s In addition P n jcid10x Acid10x s disjoint partitioning state space case partitions ambigu ously assign multiple probabilities state These properties crucial having welldeﬁned probability distribution possible deterministic action outcomes possible state For example second property easily veriﬁed pCase driveSt c drivet c s pCase driveFt c drivet c s cid18 1 34 Symbolic dynamic programming SDP Symbolic dynamic programming SDP 14 dynamic programming solution FOMDPs produces logical case description optimal value function This achieved symbolic operations ﬁrstorder decisiontheoretic regression maximization perform traditional dynamic programming Bellman backup abstract level explicit enumeration state action spaces FOMDP Among possible applications use SDP leads directly domainindependent value iteration solution FOMDPs We assume constant numerical representation values order explicitly perform casemax SDP article However note appropriate generalization casemax cf Chapter 6 67 Regr functional ﬂuents 64 allows deﬁnitions covered apply general symbolic value representations general terms constants original use symbolic SDP algorithm 341 Firstorder decisiontheoretic regression Suppose given value function V s The ﬁrstorder decisiontheoretic regression FODTR 14 value function action Acid10x yields case statement containing logical description states values rise V s action Acid10x This analogous classical goal regression key difference action Acid10x stochastic In MDP terms result FODTR roughly corresponds Qfunction albeit free variables action parameters corresponds ﬁrst half Bellman backup operation given Eq 63 We deﬁne ﬁrstorder decision theoretic regression FODTR situation calculus analog Eq 6 note different successor states arise different Natures choice deterministic actions FODTRV s Acid10x Rs γ cid2 kcid23 j1 P n jcid10x Acid10x s V jcid10x s 29 cid4 3 We use action dependent reward Rs Acid10x substitute needed 762 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 FODTR uses metalogical notation takes arguments V s representing logical case statement value function situation variable s parameterized stochastic action term Acid10x free variables cid10x All subsequently deﬁned operations case statements article deﬁned analogously The problem FODTRV s Acid10x operation currently deﬁned formula V jcid10x s refers current situation s future situation jcid10x s easily remedied regression FODTRV s Acid10x Rs γ cid2 kcid23 j1 P n jcid10x Acid10x s RegrV jcid10x s 30 cid4 This equivalent FODTR operation Eq 29 Regr operation preserves equivalence deﬁnition Also account equivalence preserving properties Regr note V s partitions state space resulting case statement FODTRV s Acid10x Thus logical description V s derive decision theoretic regression FODTRV s Acid10x This key avoiding state action enumeration dynamic programming We denote instance value function V s case statement vCases As deﬁned previously assume reward function Rs instances Natures choice probabilities P n jcid10x Acid10x s denoted rCases pCasen jcid10x Acid10x s respectively As example let compute FODTR vCases rCases stochastic action Acid10x unloadb rCases BoxWorld reward previously deﬁned Eq 20 Since vCases logically deﬁned push Regr operator individual vCases partitions follows t FODTRvCases unloadb cid24 kcid23 cid2 t rCases γ pCasen jcid10x unloadb j1 Now stochastic action Acid10x unloadb unloadSb unloadFb t t t unloadFb Eqs 27 28 respectively obtaining rCases cid20cid5 t FODTRvCases unloadb t s RegrbBoxInb paris jcid10x s 10 RegrbBoxInb paris jcid10x s 0 cid25cid4 We substitute pCase deﬁnitions deterministic actions unloadSb know Natures deterministic action choices n jcid10x range t t γ cid5 t cid18 09 RegrbBoxInb paris dounloadSb RegrbBoxInb paris dounloadSb t cid18 01 RegrbBoxInb paris dounloadFb RegrbBoxInb paris dounloadFb s t t 10 0 10 s 0 cid6cid22 cid6 We computed RegrbBoxInb paris dounloadSb And properties Regr know Regrφ Regrφ PDDL case renamed unloadSb easily obtain regression negated partition rCases It important note rCases partitioned postaction state space Regr operator preserves partitioning preaction state space We note Eq 18 deterministic unloadb t t t Regrφcid10x dounloadFb t φcid10x s t effects equivalent noop action Making substitutions easily derived unloadFb explicitly multiplying action probabilities discount factor γ 09 explicitly writing rCases obtain following readability use denote conjunction negation partitions given partition case statement FODTRvCases unloadb t bBoxInb paris s 10 0 s TruckInt t BoxOnb b BoxInb paris s bBoxInb paris s 09 0 paris s 81 0 Finally explicitly carrying s simplifying yields ﬁnal result FODTR vCases unloadb t b BoxInb paris s BoxOnb t s TruckInt 190 paris s 81 0 31 The case statement resulting FODTR contains free variables action parameters case Acid10x unloadb free parameters b This result intuitive states box paris reward 19 10 current reward 9 discounted 1step reward Otherwise box paris current t t S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 763 truck t paris action speciﬁcally unloadb expected future state box b reward 81 taking account success probability unloading box discount factor Finally box paris current state unload box 0 total reward t This case statement represents value taking stochastic action unloadb acting obtain value given rCases However need symbolic dynamic programming logical description Qfunction recall Eq 6 tells possible values achieved action instantiation b This leads following deﬁnition Q A s ﬁrstorder Qfunction makes use previously deﬁned cid10x unary case operator t t Q t A s cid10x FODTRV t1s Acid10x 32 We denote speciﬁc instance Q t A s case statement qCasets A We think qCasets A logical description Qfunction action Acid10x indicating values achieved instantiation Acid10x By ﬁrstorder case representation states action quantiﬁcation cid10x operation FODTR effectively achieves action state abstraction Letting vCase0s rCases continue running example obtain Qfunction description action unload removed vacuous quantiﬁers Technically qCase1unload s exhaustive partitioning state space 0 value partition Eq 32 implied partition formulae quantiﬁed However article exploit assumption FOMDPs noop action assume minimum value state 0 opposed undeﬁned Thus ﬁnal 0 partition indicate partitions explicitly assigned value partitions assigned default value 0 Thus arrive following intuitive result qCase1unload s b t FODTRvCase0s unloadb t b BoxInb paris s b BoxOnb t t s TruckInt 190 paris s 81 0 In words states box paris discounted reward 19 Otherwise box paris current state exists box truck paris unload expected discounted reward 81 Finally box truck unload paris box paris 0 expected discounted reward It instructive compare description prior description FODTR existential action quantiﬁcationthe difference subtle important action abstraction 342 Symbolic maximization At point decisiontheoretically regress value function single stochastic action obtain representation Qfunction complete dynamic programming Bellman backup step spirit Eq 7 Section 2 need know maximum value achieved action For example BoxWorld FOMDP possible action choices unloadb t loadb t drivet c Qfunction computations Eq 32 qCase1unload s qCase1load s qCase1drive s In general assume m stochastic actions A1cid10x1 Amcid10xm corresponding set Qfunctions qCaset A1 s qCaset Am s derived common value function vCaset1s We try obtain case description value function vCasets simply applying case operator merge partitions Qfunctions qCasets A1 qCasets Am While provides description possible values value function state spaces Qfunction overlap potentially assigning multiple values underlying state What want instead assign highest possible value portion state space Fortunately easy casemax operator Thus following equation symbolic maximization Qfunctions V ts casemax Q t A1 s Q t Am s 33 Recalling way casemax operation computed Eq 26 resulting instance vCasets value function V ts following case statement format value case partition ψ j corresponds value v j v v i1 vCasets ψ1 v 1 ψ2 ψ1 v 2 ψn ψ1 ψ2 ψn1 vn This approach effectively gives decisionlist representation value function recall optimal value function representation Fig 4 Thus determine value state simply traverse list highest lowest value value ﬁrst case partition satisﬁed The casemax operation guarantees value function disjoint partitioning state space previous assumption actions executable states ensures value function exhaustively assigns value possible states assuming vCaset1 exhaustive 764 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 343 Firstorder value iteration One note SDP equations given exactly lifted versions classical dynamic programming solution MDPs given previously Eqs 6 7 Section 2 Since equations deﬁne value iteration algorithm use lifted versions deﬁne ﬁrstorder value iteration algorithm cid4 error tolerance 1 Initialize V 0s Rs t 1 2 Compute V ts given V t1s Eqs 32 33 3 If following Bellman error inequality holds cid26 cid26 cid26V ts cid21 V t1s cid26 cid3 cid41 γ 2γ terminate return V ts step 2 34 Here deﬁne cid23V ts cid21 V t1scid23 maximal absolute value consistent partition case statement result ing V ts cid21 V t1s For example applying ﬁrstorder value iteration 0stagetogo value function vCase0s rCases given pre viously Eq 20 yields following simpliﬁed 1 2stagetogo value functions BoxWorld problem domain vCase1s vCase2s bBoxInb paris s 190 b tTruckInt paris s BoxOnb t s 81 00 bBoxInb paris s 261 b tTruckInt paris s BoxOnb t s 154 b c tBoxOnb t s TruckInt c s 73 00 After suﬃcient iterations ﬁrstorder value iteration tstagetogo value function converges giving optimal value function derive moment optimal policy Fig 4 Boutilier et al 14 provide proof SDP step value iteration produces correct logical description value function From lift error bounds ground MDP case Eq 8 domain independent error bounds ﬁrstorder abstracted value estimate Corollary 341 Let V value iteration guarantees cid23V ts V s optimal value function FOMDP Terminating according criteria given Step 3 ﬁrstorder scid23 cid4 domain instantiation inﬁnite FOMDP More generally direct result corollary derive domainindependent error bounds ﬁrstorder representation value function produced ﬁrstorder MDP algorithm Section 6 ﬁrstorder algo rithms Corollary 342 Let ˆV s arbitrary ﬁrstorder case representation value function Let ˆV 33 ˆV s FOMDP Let cid4 2 1γ cid5s cid21 ˆV scid23 Then cid23 ˆV s V cid5s result applying Eqs 32 scid23 cid4 domain instantiation FOMDP cid23 ˆV The difference γ bounds Corollaries 341 342 occurs refers bound V ts refers bound ˆV s V t1s value iteration known contract error γ iteration 344 Policy representation Given value function important able derive ﬁrstorder greedy policy representation ground case Section 2 This policy directly determine actions apply acting ground instantiation FOMDP deﬁne ﬁrstorder versions approximate policy iteration 69 Fortunately given value function V s easy derive greedy policy Assuming m parameterized actions A1cid10x Amcid10x formally derive policy π s denote value representation policy derived follows taking account modiﬁcations case operators discuss moment cid15 cid27 cid17 π sV s casemax cid10x FODTRV s Aicid10x 35 i1m We refer speciﬁc instance π s case statement π Cases For bookkeeping require partition cid3φ tcid4 cid10x FODTRV s Aicid10x maintain mapping action Ai generated denote cid3φ tcid4 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 765 Ai Then given particular world state s evaluate π Cases determine maximal policy partition cid3φ tcid4 Ai satisﬁed s action Ai applied If retrieve bindings existentially quantiﬁed action variables cid10x satisfying policy partition easily determine parameterization action Ai apply according policy To concrete derive simple greedy policy BoxWorld FOMDP assuming value function noop Noting computed Eq 31 FODTRrCases noop rCases 10 replaced 19 t V s rCases actions unloadb t FODTRrCases unloadb obtain following policy π CaserCases casemaxb t FODTRrCases unloadb t b BoxInb paris s t b BoxOnb t s TruckInt FODTRrCases noop 190 noop paris s 81 unloadb t 0 noop For interesting policy refer reader optimal value function policy BoxWorld given Fig 4 Technically note inﬁnite number actions applied inﬁnite depending domain instantiation Thus policy representation t number ground instantiations unloadb manages compactly represent selection optimal action inﬁnite set 4 Practical FOMDP solution techniques The section reviewed symbolic dynamic programming SDP algorithm theoretically capable producing cid4 optimal value function FOMDP require theorem proving detect inconsistent case partitions logical simpliﬁcation maintain compact representations case partition formulae However practice theorem proving simpliﬁcation needed control representational blowup value function occurring step value iteration To end ﬁrst half section introduces practical ﬁrstorder extension algebraic decision diagram ADD 4 data structure ﬁrstorder ADD FOADD maintaining case statements simpliﬁed nonredundant format facilitates theorem proving inconsistency detection We FOADDs exploit structure SDP FOMDPs manner ADDs exploit structure dynamic programming MDPs 38 We conclude illustrative empirical results demonstrating FOADDs enable automated solution basic FOMDPs We discuss related work ﬁrstorder decision diagrams FODDs 81 applied FOMDPs Section 6 In second half introduce additive decomposition approach approximately solving FOMDPs universal reward speciﬁcations This approach motivated previous decomposition methods enables application FOMDP solution techniques reward speciﬁcation renders SDP solution approaches intractable 41 Representation solution ﬁrstorder ADDs An algebraic decision diagram ADD 4 data structure compactly representing function Bn R directed acyclic graph ADDs compactly model transition functions rewards value functions factored MDPs 12 Moreover value iteration deﬁned terms ADD operations yielded substantial improvements time space complexity enumerated state representations 38 To extend ideas ﬁrstorder framework deﬁne methods breaking ﬁrstorder case partition formulae boolean propositional components create compact ﬁrstorder ADD FOADD representation case statements Then apply known ADD algorithms perform cid21 case operations Once shown end discussion practical use FOADDs small example FOADD application SDP 411 FOADD construction operations The ﬁrst aspect FOADDs concerns construct automatically case representation Since ADDs propositional need method ﬁnding propositional structure ﬁrstorder formulae We permut ing quantiﬁers level nesting x yφ y xφ distributing quantiﬁers deeply case formulae possible following rewrite rule templates cid24 indicates variables explicitly quantiﬁed x Ax cid24 Bx cid24 x Ax cid24 x Bx cid24 x Ax cid24 Bx cid24 x Ax cid24 x Bx cid24 x Ax cid24 Bcid24 x Ax cid24 Bcid24 x Ax cid24 Bcid24 x Ax cid24 Bcid24 36 37 38 39 766 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 Fig 5 An example conversion case statement compact FOADD representation demonstrating ﬁrstorder CSI We perform equality simpliﬁcation nonempty domain assumption following rules x x y Ax cid24 A y cid24 x x cid17 y Ax cid24 A y cid24 40 41 The ﬁrst rule fairly straightforward second rule follows simply negation ﬁrst rule renaming In practice iteratively apply simpliﬁcation rules 40 41 followed rewrite rules 3639 working inner outermost quantiﬁers rewrites applied While orders different potentially smaller results ﬁnd deterministic approach generally suﬃcient expose propositional structure ﬁrstorder formulae We provide following example application rewrite simpliﬁcation rules demonstrate power x z x y Ax cid24 B y z x x y Ax cid24 z B y z x x y Ax cid24 z B y z A y cid24 z B y z Apply rewrite rule 38 z Apply rewrite rule 38 x Apply simpliﬁcation rule 40 x To build FOADD ﬁrst apply rules expose propositional structure ﬁrstorder formula Consider example Fig 5ab start x Ax y Ax Bx A y apply rewrite rule 39 y followed 36 x obtain x Ax x Ax Bx y A y 42 43 Once pushed quantiﬁers far possible extract propositional structure formula considering propositional connectives quantiﬁed formulae follows cid15 cid17 x Ax x Ax Bx y A y 44 Each boxes represents formula decompose propositional components Consequently treat boxed formulae propositions To maintain table mappings propositional variables p naming ﬁrstorder formula ﬁrstorder formulae ψ p ψ To convert new formula φ case statement propositional variable examine formulatoproposition mapping table If φ ψ ψ table return corresponding proposition p φ ψ return p add new proposition label q add mapping q φ table return q In example having built table shown Fig 5b convert formula propositional counterpart b 45 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 767 At point build ADD case statement formulae purely propositional What makes ADD ﬁrstorder additional proposition ﬁrstorder formula mapping gives proposition ﬁrstorder deﬁ nition Standard ADDs exploit contextspeciﬁc independence CSI 13 value function independent input variable given assignment variables There additional form CSI exploit FOADDsﬁrstorder CSI This ﬁrstorder CSI follows structured potentially overlapping nature propositional variables For instance example b traverse FOADD representation force decision node b context This shown Fig 5c The options detecting ﬁrstorder CSI include Do perform ﬁrstorder CSI detection b Maintain information pairwise implications propositional mapping table detect pairwise ﬁrstorder CSI application FOADD operations c Perform simpliﬁcation decision nodes context conjunction decisions parent nodes operations FOADD Obviously requires additional computation rise FOADDs potentially dead paths In contrast c requires substantial computation return extensive simplication In practice ﬁnd b offer reasonable tradeoff computation simpliﬁcation timelimited theorem proving incomplete suﬃces identify pairwise node implications lead substantial ﬁrstorder CSI pruning It trivial extend ADD algorithm additional consistency check presence parent decisions performing standard ADD Apply Reduce operations However b c sound reorder ADD nodes ﬁrstorder context prunings change longer valid node reordering Once convert case statement FOADD apply cid21 case operations FOADDs making direct use ADD Apply operations multiplication addition subtraction 4 We reuse standard ADD oper ations FOADDs ADDs augmented variable deﬁnitions propositional mapping table Thus practical difference ADD FOADD operations augmented variable deﬁnitions lead additional pruning structure ﬁrstorder CSI In general FOADDs treated ADDs requirement consult propositional mapping table following circumstances 1 constructing FOADD 2 converting FOADD case representation evaluating ground state 3 exploiting ﬁrstorder CSI method b c consult table ADD Reduce Apply procedures 412 Practical considerations Replacing case statements FOADDs representation solution FOMDPs potential exploit great deal structure naturally occurs representations First disjunctive nature positive effects regression FOMDP formulae introduces number disjunctions application algorithms SDP Second existential quantiﬁcation action variables formulae introduce existential quantiﬁers distributed disjunctions introduced Regr Consequently SDP step introduces structure directly exploited previously described methods exposing propositional structure ﬁrstorder formulae As approach representing FOADDs wellsuited FOMDPs demonstrate small example However deﬁne complete SDP algorithm FOMDPs uses FOADDs need deﬁne special unary FOADD operations Regr casemax cid10x SDP algorithm While Regr easily deﬁned note FOADD compact representation case statement Regr applied changes logical meaning FOADD nodes ﬁrstorder deﬁnition In general maintaining canonical represen tation performing Regr FOADD requires expensive node reordering operations The application cid10x casemax generally require expensive node reordering operations For reasons apply Regr casemax cid10x FOADDs practice instead opting pragmatic use FOADDs exploits strengths4 The primary advantage FOADDs provision eﬃcient binary operations formula simpliﬁcation breakdown propositional structure elimination redundancy occurs construction In simpliﬁcation FOADDs remove lot burden theorem prover detect inconsistency highly redundant representations Thus SDP algorithms use FOADDs useful eﬃcient binary operations logical simpliﬁcationand revert case representation perform unary operations Regr casemax cid10x expensive need internal node rotations This approach leads viable SDP algorithm turn 4 While discuss Regr casemax cid10x FOADDs reader referred 67 additional information perform operations eﬃciently 768 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 Fig 6 An example FOADD representation reward BoxWorld FOADD representation optimal value function policy domain 413 Symbolic dynamic programming FOADDs The use FOADDs somewhat hybrid manner discussed allows development practical SDP algorithm We implemented fully automated ﬁrstorder value iteration algorithm tested examples velop sense effectiveness One problem tested running BoxWorld FOMDP example The FOADDs reward optimal value function policy given Fig 6 For variable ordering simply maintain order formulae added variable mapping table FOADD SDP algorithm We use Vampire theorem prover 65 detecting equivalence inconsistency The total running time solution convergence tolerance 1e4 157 s 2 Ghz Pentium 2 Gb RAM Unsurprisingly ﬁnal FOADD problem gives exactly decision list structure expect BoxWorld problem shown Fig 4 We FOADD value iteration algorithm solve variants BoxWorld problem including version given 14 extra ﬂuent Rains action probabilities conditioned ﬂuent We BoxWorld reward following structure Rs bBoxInb paris s TypeAb 10 bBoxInb paris s TypeAb 5 0 46 Here addition Rains ﬂuent added nonﬂuent predicate TypeAb distinguish types boxes varying rewards type box The FOADDs solutions large display note small number steps value iteration value function FOADD stopped growing indicating relevant state partitions identiﬁed Value iteration continued quiesced FOADD values leaves converged The respective solution times convergence tolerance 1e4 complex problems 704 s 489 s 2 Ghz Pentium 2 Gb RAM For comparison ReBel algorithm 43 produced solution ﬁrst FOMDP variant Rains ﬂuent 6 s 31 Ghz machine ReBels specialization expressive subset FOMDPs capturing BoxWorld results substantial performance edge We discuss differences ReBel work article Section 6 There appear general criteria problem domains demonstrate ﬁnitelysized optimal value func tions current case representation occurred examples 1 nonzero reward case partitions existentially quantiﬁed 2 FOMDP dynamics introduce transitive structure ﬁnitely bounded domain axioms As requirement vague provide example In BoxWorld problem covered section implicitly assume cities accessible drive action If instead underlying road topology indicated ConnCity c1 City c2 restricted drive action know topology terms prior knowledge speciﬁed domain axioms SDP algorithm likely need generate representations possible topologies likely leading value function inﬁnite size Inﬁnitesized value func tions occur condition 1 violated discuss subsection We discuss potential research directions mitigate observed deﬁciencies case representation Section 71 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 769 Unfortunately FOADD solution approach failed scale complex problems planning com munity particularly problems ICAPS 2004 2006 International Planning Competitions typically use complex rewards including universal quantiﬁers Whereas problems existentially quantiﬁed rewards exhibit ﬁnitesize optimal value function rarely case universal rewards Thus additional techniques required handle problem discuss 42 Decomposing universal rewards In ﬁrstorder domains faced universal reward expressions assign positive value world states satisfying formula general form y φ y s 0 For instance BoxWorld problem deﬁne reward having boxes b assigned destination city c given Dstb c Rs b c Dstb c BoxInb c s 1 0 47 One diﬃculty rewards case statements provide piecewiseconstant representation value function However universal rewards value function typically depends number domain objects In example value state depends number boxes proper destination impact minimum number steps obtain reward So tstagetogo value function case following characteristic structure use English place ﬁrstorder logic readability V ts b c Dstb c BoxInb c s 1 γ One box destination Two boxes destination γ 2 t 1 boxes destination γ t1 Obviously t distinct values optimal tstagetogo value function piecewiseconstant case repre sentation requires minimum t case partitions represent value function And combine counting dynamics interacting processes FOMDP uncontrollable combinatorial blowup num ber case partitions value functions FOMDPs universally deﬁned rewards As noted 33 effectively handling universally quantiﬁed rewards pressing issues practical solution FOMDPs To address problem adopt decompositional approach motivated techniques additive rewards MDPs 11536174 We divide solution offline online components online component requires ﬁnitedomain assumption order execute policy 421 Oﬄine generic goal solution Intuitively given goaloriented reward assigns positive reward cid10y Gcid10y s satisﬁed zero decompose set ground goals G cid10y1 G cid10yn possible cid10y j ground domain If reach state ground goals true satisﬁed y G y s Of course methods solve FOMDPs knowledge speciﬁc domain set ground goals generic faced runtime unknown Thus oﬄine FOMDP solution assume generic ground goal Gcid10y object vector cid10y Assuming universal reward takes implicative form reworked BoxWorld example conditions antecedent Dstb c indicate goal objects pairs cid3b ccid4 satisfying Dstb c consequent implication indicates speciﬁc goal Gcid10y s achieved objects BoxInb c s It easy construct generic instance reward function R Gcid10ys given single goal In BoxWorld example c denote goal objects Gb c introduce distinguished constants b c rCaseGbcs BoxInb BoxInb s c 1 s 0 48 Given simple reward easy derive value function V Gcid10ys FOMDP SDP approximate FOMDP solution algorithms introduce subsequent sections V Gcid10ys corresponding policy assume cid10y object vector satisfying relevant type constraints goal preconditions domain In running BoxWorld example optimal vCaseGbcs look similar Fig 4 6 differences owing fact reward deﬁned terms constants b existentially quantiﬁed variables b c c We derive Qfunctions action Aicid10x value function V Gcid10ys generic domain Q Gcid10y Ai s cid10x FODTRV Gcid10ys Aicid10x 49 For running BoxWorld example derive qCaseGbc Ai s Ai unload load drive 770 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 Algorithm 1 EvalPolicyqCaseGcid10y G cid10y1 G cid10yn s Ai cid10c 422 Online policy evaluation With oﬄine solution Qfunction action generic goal FOMDP hand address line problem action selection speciﬁc domain instantiation given runtime We assume set ground goals G cid10y1 G cid10yn corresponding speciﬁc ﬁnite domain given runtime If assume typed domain objects treated uniformly uninstantiated FOMDP case logistics planning problems obtain Qfunction goal G cid10y j replacing ground terms cid10y qCaseGcid10y Ai s respective terms cid10y j obtain qCaseG cid10y j Ai s Returning running example value function vCaseGbcs derived Qfunction qCaseGcid10y Ai s action Ai If runtime given goals Dstb1 paris Dstb2 berlin Dstb3 rome substitute goals Qfunctions obtain goalspeciﬁc Qfunctions action Ai qCaseGb1paris Ai s qCaseGb2berlin Ai s qCaseGb3rome Ai s 50 Action selection requires ﬁnding action maximizes value respect original universal reward Follow ing 1153 treating sum Qvalues action subgoal MDPs measure Qvalue joint original MDP Speciﬁcally assume goal contributes uniformly additively reward Qfunction entire set ground goals G cid10y1 G cid10yn determined domain instantiation cid28 n 1 n qCaseG cid10y j Ai s Action selection runtime ground state realized choosing action max j1 imum additive Qvalue Naturally want explicitly create joint Qfunction instead use eﬃcient scoring technique evaluates potentially useful actions iterating individual Qfunctions described Algorithm 1 While additive uniform decomposition appropriate domains goaloriented universal rewards certainly offers performance guarantees account heuristic nature provide reasonable results domains BoxWorld empirically demonstrate section While approach currently handles rewards universal quantiﬁers reﬂects form planning problems Nonetheless technique extended complex universal rewards general open question assign credit constituents reward 5 Linearvalue approximation FOMDPs Perhaps greatest diﬃculty symbolic dynamic programming SDP approach practical extensions dis cussed section size value function case representation grows polynomially iteration S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 771 exponentially terms number iterations5 Similar growth occur ﬁrstorder formulae representing state partitions Once formulae large practically detect equivalence inconsistency hope obtaining compact representation value function lost number partitions case represen tation grow unboundedly practical means simpliﬁcation pruning Indeed SDP approaches FOADDs universal reward decomposition incapable producing value functions policies competitive planners ICAPS 2004 2006 International Probabilistic Planning Competitions 3250 Given approximate solution techniques linear value approximation 193671 allowed MDP solutions scale far limits exact algorithms time offering reasonable error guarantees suggests generalizing linear value approximation techniques FOMDPs In section generalize LP methods ground MDPs discussed Section 2 ﬁrstorder case This reduces task solving FOMDP obtaining good weights set basis functions approximates optimal value function This requires generalization linear programs handle ﬁrstorder constraints requires eﬃcient extensions solution methods constraint generation variable elimination cost networks exploit ﬁrstorder structure constraints To develop completely automated linearvalue approximation approach FOMDPs address issue au tomatic basis function construction adapt techniques proposed 33 With appropriate domain axioms deﬁning legal states techniques provide fully ﬁrstorder nongrounded solutions FOMDPs derived PPDDL compete planners ICAPS 2004 ICAPS 2006 International Probabilistic Planning Competitions 51 Beneﬁts linearvalue approximation Linearvalue approximation FOMDPs attractive reasons Given computation linear value approximation reduces solving LPs reduces algorithm design space setup solution linear programs Since size linearvalue approximations ﬁxed moderate complexity resulting solution algorithm This leads ﬂexible solution approach trades approximation accuracy computation Linear value approximation require extensive logical simpliﬁcation practice weight projections use theorem prover This tremendous advantage exact techniques require substantial simpliﬁ cation order maintain compact representation Linear value approximation yielded reasonable empirical performance ground factored MDPs suggesting promise application FOMDPs If use additive reward decomposition techniques Section 42 approximate FOMDP model derive domainindependent error bounds resulting value function Corollary 342 52 Firstorder linearvalue representation We represent value function weighted sum k ﬁrstorder basis functions denoted bis ideally containing small number formulae provide ﬁrstorder abstraction state space V s kcid23 i1 w bis 51 Throughout section assume individual basis function bis represented case statement exhaustive disjoint partitioning state space This property useful deﬁne backup operators However basis functions assign nonzero values overlapping regions state space fact useful representing additively decomposable values Such linear value function representation provide reasonable approximation exact value function especially given additive structure inherent realworld problems For example argued previous sections planning problems additive reward functions multiple goals lend approximation linearly additive basis functions Unlike exact solution methods value functions grow exponentially size solution process logically simpliﬁed maintain value function compact form requires simpliﬁcation discovery good weights As example consider approximation value function BoxWorld FOMDP section following basis functions refer speciﬁc instances bis bCaseis bCase1s b BoxInb paris s 1 0 5 In worst case single case operation yield quadratic blowup number case partitions terms maximum number case partitions operands 772 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 bCase2s bCase3s b t BoxOnb t s 1 0 b t TruckInt paris s BoxOnb t s 1 0 Then instance V s denoted vCases form vCases w 1 bCase1s w 2 bCase2s w 3 bCase3s 52 53 Each basis function relatively small represents portion state space expect assign positive value order approximate BoxWorld value function 521 Backup operators Suppose given value function V s Backing value function action Acid10x yields case state ment containing logical description states rise V s action Acid10x values obtained However free variables action Acid10x fact types backups perform The ﬁrst B Acid10x regresses value function action produces case statement free variables action parameters The second B A existentially quantiﬁes free variables cid10x B Acid10x Thus application B A results case description regressed value function indicating values achieved instantiation Acid10x preaction state The deﬁnition B Acid10x ﬁrstorder decision theoretic regression FODTR operator Eq 30 explicitly add reward Slightly modifying deﬁnitions Section 333 let n1cid10x nqcid10x set Natures deterministic actions stochastic action Acid10x Then deﬁne B Acid10x follows B Acid10xV s γ cid2 qcid23 j1 P n jcid10x Acid10x s RegrV jcid10x s 54 cid4 Deﬁning B Acid10x way reward makes linear operator Thus apply operator linear value function representation distributes ﬁrstorder basis function B Acid10xV s B Acid10x cid4 w bis cid2 kcid23 i1 kcid23 i1 w B Acid10xbis Having deﬁned B Acid10x use deﬁne B A6 B Acid10xV s B AV s cid10x cid8 cid7 Unfortunately apply B A linearvalue function representation B A necessarily linear B AV s B A cid2 kcid23 i1 cid4 cid24 w bis cid10x kcid23 i1 cid25 w B Acid10xbis 55 56 57 The diﬃculty existential quantiﬁcation B A jointly constrains backup basis functions contain existentially quantiﬁed variable free variable These problems mitigated We begin deﬁnitions Deﬁnition 521 We deterministic action n jcid10x affects ﬂuent F positive negative effect axiom contains n jcid10x body axiom F head cf Section 322 We stochastic action Acid10x affects ﬂuent F Natures choices n jcid10x Acid10x affects F Finally formula φ affected stochastic action Acid10x iff φ contains ﬂuent affected Acid10x Since case statement deﬁned logical formula deﬁnition extends case statements obvious way Property 522 When basis function case statement bis affected stochastic action Acid10x B Acid10xbis contain action arguments cid10x free variables The inverse property true stochastic action Acid10x affect basis function bis B Acid10xbis contain action arguments free variables 6 For simplicity assume reward independent action arguments cid10x allowing exclude reward cid10x operation B A If required dependencies added appropriate adjustments deﬁnitions S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 773 To exploit property let I A denote set indices basis functions bis affected action Acid10x I A denote set indices A B Acid10xbis contains free variables cid10x basis functions bis affected action I We exploit fact cid10x vacuous case statements containing free variables cid10x remove terms scope cid10x quantiﬁcation This yields following form B A A B Acid10xbis contains free variables cid10x Likewise let I cid20cid23 B A cid22 w ibis cid15 cid23 iI A cid17 w B Acid10xbis cid10x cid17 w B Acid10xbis cid15 cid23 iI A 58 Consequently ﬂuent occurs basis functions action affects ﬂuents reasonably expect result applying B A retain additive structure The ﬁrst property controlled appropriate design basis functions The second true typical planning domains As concrete example demonstrate backup operators exploitation additive structure let compute Bdrive previously speciﬁed linearvalue function Eq 53 BdrivevCases t t t t c c c c c Bdrivet Bdrivet w 1 Bdrivet cid5 c w 1 vCases w 1 bCase1s w 2 bCase2s w 3 bCase3s c bCase1s w 2 Bdrivet c b BoxInb paris s 09 0 b t t t TruckInt paris s BoxOnb t s c w 2 paris c1TruckInt c1 s bCase2s w 3 Bdrivet b t BoxOnb t s 09 0 09 0 c bCase3s 59 w 3 action backup Here note ﬁrst second basis functions affected drivet action equivalent backup noop Since basis function affected action drivet c result backup push quantiﬁers case statement introduces action parameters t c c BdrivevCases t c w 1 c vCases Bdrivet b BoxInb paris s 09 0 w 2 b t BoxOnb t s 09 0 w 3 t c c paris c1TruckInt c1 s b t t t TruckInt paris s BoxOnb t s 09 0 Finally carry explicit t case partitions simplify This allows remove t domain assumption c operation case statement distribute quantiﬁers inside rewriting equalities exploiting nonempty c BdrivevCases t c w 1 c vCases Bdrivet b BoxInb paris s 09 0 b t BoxOnb t s 09 0 b t c1 TruckInt c1 s TruckInt paris s BoxOnb t s 09 0 w 2 w 3 60 This example demonstrates best case performance B A action affects basis function allowing basis functions removed scope cid10x operator Then cid10x operator easily applied single case statement incurring representational blowup occur cid10x ranged sum case statements explicit crosssum required Of course cases basis function affected action For example computed BunloadvCases basis functions affected action explicitly compute crosssum backups basis functions While effectively counteracts beneﬁts linearvalue approximation additive structure longer exploited generating basis functions restricted manner manage avoid computing explicit basis functions affected action We discuss discuss basis function generation 774 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 53 Firstorder approximate linear programming We generalize approximate linear programming ALP approach MDPs Eq 11 ﬁrstorder MDPs If simply substitute appropriate notation arrive following formulation ﬁrstorder ALP FOALP 68 Variables w cid3 k Minimize cid3 kcid23 s i1 w bis cid2 Subject 0 cid2 Rs B A cid4 w bis cid21 kcid23 i1 w bis A s 61 kcid23 i1 As ALP variables weights basis functions objective minimize sum values states s We constraint stochastic action A BoxWorld A unload load drive state s One advantage FOALP SDP require casemax avoiding representational blowup incurred step SDP7 Unfortunately objective constraints ALP ground MDP range ﬁnite number states direct generalization FOALP approach FOMDPs requires dealing inﬁnitely indeﬁnitely states s Since summing inﬁnitely states FOALP objective illdeﬁned Thus redeﬁne FOALP objective manner preserves intention original approximate linear programming solution MDPs In ALP Eq 11 objective equally weights state minimizes sum value function states However look case partitions cid3φis ticid4 basis function bis case statement case partition serves aggregate representation ground states assigned equal value Consequently count ground states FOALP objectiveof generally inﬁnite number partitionwe suppose basis function partition chosen represented potentially useful partitioning state space weight case partition equally Consequently rewrite FOALP objective follows cid3 kcid23 s i1 w bis kcid23 cid3 w i1 s bis kcid23 cid3 w i1 cid3φ j t j cid4bi t j bi We use bi indicate number partitions ith basis function This approach seen aggregating states basis function partition abstract state weighting abstract state uniformly importance For cid28 k i1 w Of course solution case 01 indicator basis functions Eq 52 yields simple objective requires approximating original objective FOALP represent exact generalization ground ALP approach ﬁrstorder case Nonetheless approximation leads reasonable results empirical evaluation With issue inﬁnite objective resolved leaves ﬁnal problemthe inﬁnite number constraints state s Fortunately work case statements ﬁnite Since value ti case partition cid3φis ticid4 constant situations satisfying φis explicitly sum caseis statements constraint yield single case statement representation constraints The key observation ﬁnite number constraints represented single ﬂattened case statement hold iff original inﬁnite set constraints Eq 61 hold To understand consider constraints drive action FOALP substituting previously deﬁned basis functions bCaseis Eq 52 bis results Bdrive operator basis functions Eq 60 reward deﬁnition BoxWorld given rCases Eq 20 Rs We substitute directly constraint form Eq 61 obtain 0 cid2 bBoxInb paris s 10 0 w 1 b BoxInb paris s 09 0 w 2 w 3 cid21 w 1 cid21 w 3 b t BoxOnb t s 09 0 b t c1 TruckInt c1 s TruckInt paris s BoxOnb t s 09 0 b BoxInb paris s 1 0 b t TruckInt paris s BoxOnb t s 1 0 b t BoxOnb t s 1 0 cid21 w 2 s 7 The reasons lack max ground case discussed Section 223 62 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 775 Next perform explicit cid21 case statements simplify resulting partitions distribute weights partition values 0 cid2 b BoxInb paris s 10 01 w 1 0 b t BoxOnb t s 01 w 2 0 b t TruckInt paris s BoxOnb t s 01 w 3 b t c1 TruckInt c1 s BoxOnb t s 09 w 3 0 s 63 To maintain representation compact perspicuous form deﬁne following propositional renamings ﬁrstorder formulae case statements8 φ1s b BoxInb paris s φ2s b t BoxOnb t s φ3s b t TruckInt paris s BoxOnb t s φ4s b t c1 TruckInt c1 s BoxOnb t s Finally fully expand obtain explicit representation FOALP constraints drive action BoxWorld example φ1s φ2s φ3s 0 cid2 10 01 w 1 01 w 2 01 w 3 φ1s φ2s φ3s φ4s 0 cid2 10 01 w 1 01 w 2 09 w 3 φ1s φ2s φ3s φ4s 0 cid2 10 01 w 1 01 w 2 φ1s φ2s φ3s 0 cid2 10 01 w 1 01 w 3 φ1s φ2s φ3s φ4s 0 cid2 10 01 w 1 09 w 3 φ1s φ2s φ3s φ4s 0 cid2 10 01 w 1 01 w 2 φ1s φ2s φ3s 0 cid2 01 w 2 01 w 3 φ1s φ2s φ3s φ4s 0 cid2 01 w 2 09 w 3 φ1s φ2s φ3s φ4s 0 cid2 01 w 2 0 cid2 01 w 3 φ1s φ2s φ3s 0 cid2 09 w 3 φ1s φ2s φ3s φ4s 0 cid2 0 φ1s φ2s φ3s φ4s s 64 Here detected partition formula inconsistent removed corresponding constraint While note technically inﬁnite number constraints possible state s ﬁnite number distinct constraints In fact case representation conveniently partitions state space regions constraint Thus solve FOALP problem enumerate consistent constraints action directly solve resulting LP In addition constraints drive action BoxWorld approach require carry similar procedure unload load noop actions constraints necessary solving FOALP ﬁrstorder linear program speciﬁcation However number basis functions increases number constraints grow exponentially number case statements constraint To tackle problem examine underlying optimization problem section 54 Firstorder linear programs We restate FOALP problem optimal solution general ﬁrstorder linear program FOLP provide generic solution A FOLP standard linear program constraints written terms sum case statements case partition values speciﬁed linear combinations weights Eﬃciently solving FOLPs poses number diﬃcultiesand tackle diﬃculties 541 General formulation A FOLP speciﬁed follows 8 One note renaming ﬁrstorder formulae propositional variables spirit FOADDs Consequently note FOADDs prove eﬃcient method representing performing operations constraints occur FOALP 776 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 Algorithm 2 FOMaxC cid3R1 Rncid4 cid3S vcid4 Variables w 1 wk Minimize kcid3 i1 ci w Subject 0 cid2 case11 cid10w s case1l1 cid10w s s 0 cid2 casem1 cid10w s casemln cid10w s s 65 The k variables cid10w cid3w 1 wkcid4 objective weights cid10c cid3c1 ckcid4 deﬁned typical LP main difference form constraints Here m different constraints varying length l j number case statements constraint j 1 cid3 j cid3 n We allow ti partition cid3φi ticid4 case cid10w s linearly dependent weights cid10w ti 3w 1 2w 2 We note ﬁrstorder LP FOALP cast general form As previously discussed FOALP example simply compute explicit crosssum ﬂatten constraint j single case statement Eq 64 However ineﬃcient scales exponentially number summed case statements Fortunately extend constraint generation methods factored MDPs 71 ﬁrstorder case S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 777 542 Firstorder cost network maximization In constraint generation approach solving FOLP important operation ﬁnd mostviolated straint given current solution setting weights cid10w In section formulate problem maximization ﬁrstorder generalization cost network 23 represented follows 0 cid2 max s case1 cid10w s casen cid10w s 66 The use maxs indicates interested single value corresponding case partitions contributing value maximizes RHS casemax eﬃcient exhaustively enumerate values constraints require single maximal value constraint To determine maxs form constraints deﬁne FOMax algorithm Algorithm 2 carry computation It similar variable elimination 90 bucket elimination 23 makes stronger connection resolution use simple ordered version ﬁrstorder resolution place propositional ordered resolution Thus term generalized variable elimination technique FOMax relation elimination Ostensibly relation elimination technique ﬁrstorder variable elimination FOVE 202160 appear similar deal lifted versions variable elimination However fundamentally apply different problems FOVE permit quantiﬁed formulae representation relational elimination permits ﬁrstorder logic representation furthermore FOVE permits representation indeﬁnite products sums relation elimination permits ﬁnite products sums Here require ﬁrstorder logic indeﬁnite products sums While scope article delve detailed discussion note relation elimination FOVE combined required occurs example FOALP approaches factored FOMDP solutions cf 70 Chapter 6 67 We provide concrete example FOMax relation elimination Fig 7 Relation elimination proceeds analogously variable elimination choose relation R eliminate step propositional variable Elimination order affect time space requirements FOMax eliminating R requires crosssum case statements containing R incurring polynomial blowup number case statements summed In practice greedily eliminate relation R step minimizes representational blowup guaranteed provide optimal order On elimination step FOMax case statements containing R explicitly crosssummed step determine case partitions inconsistent resolution θ subsumed dominated value generalized θ subsumption operator cid27θ 18 respect background theory similar approach ReBeL 43 cases partitions removed contribute maximally consistent partition Once relations eliminated maximal case partitions values extracted Fig 7 An example use FOMAx ﬁnd maximally violated constraint ﬁrstorder constraint generation 778 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 remaining sum case statements generate maximal value case partitions contributing value We note ordered resolution strategy use FOMax refutationcomplete loop indeﬁnitely intermediate relation elimination step ﬁnding relation resolve contradiction This unavoidable consequence fact refutation resolution general ﬁrstorder theories semidecidable From practical standpoint necessary bound number resolutions performed relation elimination step 100 clauses elimination step experiments prevent nontermination FOMax inﬁnite number resolutions This incomplete theorem proving approach generate unnecessary constraints corresponding unsatisﬁable regions state space constraints serve overconstrain set feasible solutions led infeasibility problems practice Furthermore omit generalized θ subsumption test cid27θ savings simpliﬁcation outweigh computational cost This affect completeness simpliﬁcation required inconsistency detection Finally remark resolution procedure ﬁnitely terminate inference limit reached step FOMax conjunction case partition formulae returned FOMax guaranteed satisﬁable consequence completeness refutation resolution Research decidable resolution procedures expressive subsets ﬁrstorder logic 54 pave way stronger completeness guarantees FOMax future work 543 Firstorder constraint generation We use FOMax algorithm ﬁnd maximal constraint violation constraints form Eq 66 This allows deﬁne following ﬁrstorder constraint generation algorithm speciﬁed solution tolerance cid4 1 Initialize LP 0 cid10w cid100 constraint set 2 For constraint costnetwork form Eq 66 ﬁnd maximally violated constraint C exists FOMax algorithm applied constraint instantiated cid10w 3 If C s constraint violation larger cid4 add C LP constraint set return cid10w solution 5 Solve LP new constraints obtain cid10w i1 goto step 2 In ﬁrstorder constraint generation initialize LP initial setting weights constraints Note initial weights cid10w 0 cid100 violate constraint FOMDP nonzero reward Then alternate generating constraints based maximal constraint violations current solution resolving LP additional constraints This process repeats constraints violated optimal solution In practice approach typically generates far fewer constraints exhaustive enumeration approach given Eq 64 To provide intuitions refer example ﬁnding violated constraint Fig 7 Using ﬁrstorder constraint generation solution ﬁrstorder LP Eq 65 providing general solution FOALP At point step FOALP automated generation basis functions discuss 55 Automatic generation basis functions The effective use linear approximations requires good set basis functions spans space containing good approximation true value function Previous work addressed issue basis function generation ground MDPs 5157 work addressed inductive generation ﬁrstorder features basis functions sampled experience 8386 Here consider deductive ﬁrstorder basis function generation method draws work 33 Speciﬁcally use regressions reward candidate basis functions learning value function This technique allowed generate fully tstagetogo optimal policies range BlocksWorld problems We leverage similar approach generating candidate basis functions regression use candidate basis functions learn value function ﬁt weights sampling grounding FOALP Algorithm 3 provides overview basis function generation algorithm The motivation approach follows portion state space φ value v τ existing approximate value function nontrivial threshold τ suggests states reach region Regrφ deterministic action reasonable value However assigned value φ want new basis function focus area state space covered φ negate φ conjoin Regrφ As small example given initial weighted basis function bCase1s w 1 rCases BoxWorld bCase1s w 1 b BoxInb paris s 10 0 derive following weighted basis function bCase1s considering deterministic action Ai unloadSb basis function generation bCase2s w 2 b BoxInb paris s c BoxOnb t s TruckInt paris s 1 0 67 t 68 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 779 Algorithm 3 BasisGenFOMDP τ n B If examines form basis functions inherent orthogonality new basis functions ones derived allows signiﬁcant computational optimizations For example partition bCase1s takes form φ1 partition bCase2s takes form φ1 φ2 partitions mutually exclusive jointly contribute value state Thus basis functions orthogonal manner eﬃciently perform explicit crosssum obtain single compact case statement representing weighted basis functions bCase12s bCase1s bCase2s b BoxInb paris s b BoxInb paris s c BoxOnb t s TruckInt paris s w 1 10 w 2 0 69 This style basis function generation computational advantages FOALP To return original discussion concerning fact B A operator deﬁned Eq 58 able preserve additive structure basis functions linearvalue function representation affected stochastic action Acid10x Recalling Property 522 basis functions affected Acid10x backup B A sum basis functions require explicit crosssum free variables cid10x causing summed cid10x applied However best case explicit crosssum precomputed orthogonal basis functions merging blowup occur Of course different actions generate different nonorthogonal basis functions parent basis function generally hold basis functions pairwise orthogonal Nonetheless exploit mutual orthogonality subsets basis functions eﬃciently carryout explicit crosssum achieve exponential time speedup relative worstcase B A operator requires explicit computation crosssum To subsets basis functions eﬃciently summed refer Eq 69 provides example sum orthogonal basis functions In general mutually orthogonal subset basis functions merged way As consequence exploit properties orthogonal basis function generation FOALP mitigate exponential space time scaling number basis functions worstcase exponential scaling arises points need explicitly compute crosssum linearvalue representation While claim method basis function generation appropriate domains demonstrate works reasonably stochastic planning problems evaluated section 780 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 56 Empirical results We evaluated FOALP PPDDL planning problems ICAPS 2004 50 ICAPS 2006 32 International Proba bilistic Planning Competitions IPPC We divide discussion results according competition order reﬂect differences competition setup data collected speciﬁc planners entered competition We Vampire theorem prover CPLEX 90 LP solver9 FOALP implementation applied BasisGen Algorithm 3 FOMDP translation PPDDL domains generated described Section 322 We additively composed universal rewards technique described Section 42 note prevents obtaining approximation guarantees solution generated FOALP We provided FOALP additional background theory axioms encoded PPDDL source ﬂuent intended functional arguments PPDDL PPDDL provisions specifying property explic itly provide background axiom stating So example running BoxWorld example provide following functional constraint axioms b c1 c2 s BoxInb c1 s BoxInb c2 s c1 c2 t c1 c2 s TruckInt c1 s TruckInt c2 s c1 c2 b t1 t2 s BoxOnb t1 s BoxOnb t2 s t1 t2 In words axioms state box city truck city box truck Any searchbased inductive planner given initial state respecting constraints case competition instances consider erroneous states violating constraints unreachable nonerroneous states satisfying constraints However FOALP initial state knowledge oﬄine solution phase produce extremely poorly approximated value functions rule erroneous states inconsistent The need constraints viewed major drawback FOALP approach reason FOALP entered ICAPS 2006 Probabilistic Planning Competition compete 6 10 problem domains 6 problem domains released start competition rules prevented planners modiﬁed point On hand note functional constraints ﬂuents represent minimal type problem knowledge easily encoded person specifying PPDDL problem constraints BoxWorld good example As aid future nongrounding planners recommend capability specify functional constraints ﬂuents incorporated future versions PPDDL speciﬁcation If constraints known hold initial states automated techniques based reachability analysis prove constraints hold In following sections present proofofconcept results comparing FOALP planners sampling problems FOALP able generate policies IPPC problems 561 ICAPS 2004 probabilistic planning competition problems We applied FOALP BoxWorld logistics BlocksWorld probabilistic planning problems ICAPS 2004 IPPC 50 In BoxWorld logistics problem domain objects consist trucks planes boxes cities The number boxes cities varied problem instance 5 trucks 5 planes Trucks planes restricted particular routes cities problem instancespeciﬁc manner The goal BoxWorld deliver boxes destination cities costs associated action The transition functions allowed trucks planes stochastically end destinations intended execution respective drive ﬂy actions BlocksWorld stochastic version standard domain blocks moved table stacks blocks form goal conﬁguration In version block dropped probability picking placing stack We stopped oﬄine basis function generation algorithm iteration 7 BasisGen Algorithm 3 taking 2 hours problems 2 Ghz Pentium 2 Gb RAM iteration 8 complete memory constraints We note orthogonal basis function generation described Section 55 past iteration 2 basis function generation terminate 10 hours iteration 3 optimizations substantially increased number basis functions FOALP viable solution option We compared FOALP topperforming planners problems NMRDPP temporal logic planner humancoded control knowledge 77 mGPT RTDPbased planner 10 PurdueHumans humancoded plan ner Classy inductive ﬁrstorder policy iteration planner FFReplan 85 2004 version deterministic replanner based FF 39 Results planners given Fig 8 Since FOALP able complete 7 iterations basis function generation effectively limits lookahead horizon basis functions 7 steps A lookahead 8 required properly plan ﬁnal BoxWorld prob lem instance FOALP failed instance It important note comparing FOALP planners 9 httpwwwilogcomproductscplex S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 Problem Competing Probabilistic Planners NMRDPP mGPT Humans Classy FFReplan bx c10 b5 bx c10 b10 bx c10 b15 bw b5 bw b11 bw b15 bw b18 bw b21 438 376 0 495 479 468 352 286 184 0 494 466 397 419 317 129 494 480 469 462 456 376 0 0 495 480 468 0 455 425 346 279 494 481 0 0 459 781 FOALP 433 366 0 494 480 470 464 456 Fig 8 Cumulative reward 5 planning systems FOALP 100 run avg BoxWorld BlocksWorld probabilistic planning problems ICAPS 2004 IPPC indicates data BoxWorld problems indicated preﬁx bx followed number cities c boxes b domain BlocksWorld problems indicated preﬁx bw followed number blocks b domain NMRDPP Humans handcoded control knowledge FFReplan eﬃcient searchbased deterministic plan ner signiﬁcant advantage nearoptimal policies speciﬁc goaloriented problems obtained assuming highest probability action effects occur deterministically making use classical searchbased planning techniques The autonomous fully stochastic planners mGPT Classy inductive ﬁrstorder planning approach FOALP performs comparably planners outperforms considerable margin problem instances 562 ICAPS 2006 probabilistic planning competition problems We present results FOALP problem domains ICAPS 2006 IPPC 32 BlocksWorld TireWorld Elevators10 In BlocksWorld blocks table goal stack unstack blocks effort achieve goal conﬁguration blocks respect table TireWorld relatively simple problem goal drive goal city destination city able pick spare tire cities One stochastic outcome driving cities tire ﬂat ﬁxed spare tire present Thus routes cities contain spare tires preferred routes Finally Elevators problem gridlike state space The horizontal dimension grid corresponds positions ﬂoor vertical dimension corresponds different ﬂoors There elevators position vertically ﬂoors An agent occupy position ﬂoor left right positions elevator appropriate ﬂoor position Any elevator moved independently agent resides There gates certain positions probabilistically teleport agent start position ﬂoor 1 position 1 Finally number coins different known positions goal agent retrieve In following results BasisGen Algorithm 3 run fourhour ﬁxed time limit 2 Ghz Pentium 2 Gb RAM generate solutions successively larger sets basis functions At fourhour mark halted solution process largest recent set basis functions weights FOALP successfully terminated Since oﬄine solution time 4 hours amortized indeﬁnite number instances given problem report online policy evaluation times following results In Figs 9 10 11 provide data FOALP competing planners speciﬁes number problem instances solved online solution generation time average number actions required reach goal successful problem We compare following planners entered competition11 1 FPG 17 uses policy gradient search factored representation Qfunctions 2 sfDP 76 uses ADDbased dynamic programming 38 reachability constraints based initial state knowledge 3 Paragraph 49 uses probabilistic extension Graphplan 9 probabilistic planning 4 FFReplan 88 2006 version deterministic replanner based FF 39 We note planners competition aside FOALP ground planners use propositional representation PPDDL problem speciﬁc domain instantiation The results vary problem explain turn In TireWorld FOALPs policy allowed solve problems policy suboptimal number actions problems solved comparison FFReplan In case appears approximation inherent FOALP approach fared poorly comparison deterministic replanner like FFReplan perform nearly optimally problem FOALPs slow policy evaluation problem transitive nature road connection topology lack optimization FOALPs logical policy evaluator In Elevators planners including FOALP performed comparably deterministic replanner performing 10 In ICAPS 2006 IPPC FOALP ran problems reported ExplodingBlocksWorld reported We report ExplodingBlocksWorld results competition version FOALP planner restricted use BlocksWorld subset Exploding BlocksWorld problem description In section results problems FOALP able generate policy problem description 11 Not planners ran problems competition Furthermore planners provide results problem instances noted result plot 782 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 Fig 9 A boxplot performance planners 15 instances TireWorld problem domain probabilistic track ICAPS 2006 IPPC sfDP produce results problem planners reported results instances Fig 10 A boxplot performance planners 15 instances Elevators problem domain probabilistic track ICAPS 2006 IPPC sfDP Paragraph produce results problems FFReplan FPG report results 2 3 problem instances respectively consistently faster suitability domain deterministic replanning relative speed approach The goals domain highly decomposable FOALP beneﬁted substantially additive goal decomposition approach In BlocksWorld FOALP shows best performance solving problems S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 783 Fig 11 A boxplot performance planners 15 instances BlocksWorld problem domain probabilistic track ICAPS 2006 IPPC Paragraph produce results problems FFReplan FPG sfDP report results 1 5 10 problem instances respectively taking time hard instances FPG report results 5 hardest instances skewing results reaching goal fewer actions sfDP report results 10 hardest instances skewing results In case FOALPs performance owes advantages 1 ﬁrstorder abstraction BlocksWorld considerably helps avoid combinatorial complexity ground planners face 2 additive goal decomposition optimal BlocksWorld problems performed problem instances 563 Summary results In summary ﬁrstorder representation FOALP offer robust performance range domain instance sizes problems However discussed end Section 413 case representation FOALP limiting factor performance inability exploit value structure problems requiring reasoning universal rewards suboptimal additive reward decomposition techniques transitive reachability deﬁciency clear TireWorld results We discuss potential research directions mitigate observed deﬁciencies Section 71 6 Related work In section review work related presented article important dimensions deductive ﬁrst order decisiontheoretic planners based symbolic dynamic programming SDP inductive lifted decisiontheoretic planners based learning ﬁrstorder representations value functions control knowledge policies grounded domain instantiations 61 Variants symbolic dynamic programming There variety alternative exact approaches solving relationally speciﬁed MDPs grounding spirit SDP Each approaches apply SDPlike algorithm ﬁrstorder MDP representation Like SDP algorithms guarantees domainindependent error bounds value functions produce produce exact domainindependent value functions exist However approaches restricted solve expressive variants relational MDPs SDP Firstorder value iteration FOVIA 4042 Relational Bellman algorithm ReBel 43 value iteration algo rithms solve restricted subclass relational MDPs notably disallowing combined universal conditional effects deﬁned Section 311 Since universal conditional effects powerful planning formalism underlying ADL ex tension STRIPS argued signiﬁcant limitation alternate SDP approaches Both provided 784 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 fully automated proofofconcept results able directly compare SDP FOADDs ReBel BoxWorld problem Section 413 ReBels specialization expressive subset FOMDPs capturing BoxWorld results substantial performance edge problem produce exact solution Results ReBel FOVIA available speciﬁc versions planning competition domains examined Section 5 Firstorder decision diagrams FODDs 81 introduced compactly represent case statements permit eﬃcient application symbolic dynamic programming operations restricted class relational MDPs value iteration 80 policy iteration 82 Since FODDs similar spirit FOADDs deﬁned Section 41 enumerate major differences formalisms 1 FODDs disallow explicit universal quantiﬁcation This prevents FODDs applied relational MDPs universal preconditions alternating quantiﬁers effects importantly handle universal ditional effects 2 Unlike FOADDs maintained canonical form FODDs maintained sorted format guaranteed canonical form As rely range simpliﬁcation rules maintain compact rep resentations This approach advantage diagrams strict order exponentially compact diagrams strict order 80 However having welldeﬁned simpliﬁcation algorithm leading canonical form simpliﬁcation FODDs somewhat openended heuristic 3 There need reorder internal decision nodes Regr FODDs order maintain canonical form In way Regr eﬃcient FODDs FOADDs This results value policy iteration algorithms performed completely terms FODDs unlike current FOADD representation 4 FODDs assume implicit semantics maximal value assumed instantiations free variables precluding need perform explicit x casemax In FOADDs operations need performed explicitly As use FODDs lead compact representations decisiontheoretic planning semantics interfere extensions FODDs handle universally quantiﬁed formulae Consequently FODDs represent interesting alternative design space data structures compact represen tation case statements Nonetheless major limitation respect work present article limitations wrt representing forms universal quantiﬁcation Ideally best approach combine advantages FOADDs FODDs This nontrivial problem interesting future research direction 62 Alternative lifted approaches decisiontheoretic planning There alternative approaches ﬁrstorder decisiontheoretic planning reason inductively sample domain instances sample trajectories produce lifted value functions policies This stands alternative reasoning symbolically actions rewards directly ﬁrstorder level grounding article In class approaches sampled experience grounded domain instantiations directly induce relational representations value Qfunctions reinforcement learning approach This pure reinforcement learning relational decision regression trees learn value Qfunction 25 combining supervised guidance 24 Gaussian processes graph kernels relational structures learn value Qfunction 31 A second approach uses experience sampled ground domain instantiations induce ﬁrstorder policy repre sentations In version policies learned directly sampled experience trajectories generated planners 84 In different vein policies learned approximate policy iteration framework 87 combines trajectory sampling policy updates derived trajectories In approach sample experience trajectories generated planning heuristics 26 andor random walks problem sizes adaptively scaled planner performance improves 27 A inductive approach conjunction FOALP allows ﬁrstorder features learned experience symbolically deriving directly relational MDP speciﬁcation described Sec tion 55 In approach heuristic control knowledge represented ﬁrstorder taxonomic syntax learned solution trajectories given problem 86 In recent approach relational basis functions learned sampled trajectories approximate value iteration framework 83 Since approaches subsection produce ﬁrstorder value functions policies important compare contrast symbolic deductive approach adopt In approach ideal objectives threefold 1 Obtaining domainindependent exact bounded approximate solutions possible exploiting natural rela tional ﬁrstorder planning structure 2 Avoiding potential pitfalls value functions policies speciﬁc biases small sampled domain instantiations 3 Avoiding intractable representational blowup grounding solution algorithm S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 785 In practice approaches advocated article unable effectively achieve objective 1 heuristics universal reward decomposition Section 42 required apply techniques planning competition problems prevent derivation bounds Objective 2 met practice approximations required practical applications introduce representational biases Finally objective 3 satisﬁed practice domainindependent approach introduces representational blowup effectively planning possible domain instantiation In comparison inductive ﬁrstorder approaches outlined share goal similar 1 exploiting natural relational planning structure domainindependent manner claim support 2 sample Theoretical complexity results 4445 indicate 3 possible achieve inductive approaches settings We note practice bias computational complexity inherent sampling small set possible ground domain instantiations MDP generally problematic policies work domain instantiation generalize similar larger domains given appropriate representation language 87 So ask ﬁrstorder approach better inductive deductive12 Empirically recent results 83 inductive ﬁrstorder approaches outperform FOALP Is ﬁnal answer Hopefully clearly great deal work order ﬁrstorder deductive approaches fully competitive recent stateofthe art ﬁrstorder inductive approaches Perhaps promising potential combine advances approaches 33 work combines inductive logic programming ﬁrstorder decisiontheoretic regression showing optimal policies induced training samples deductive methods generate candidate policy structure Such approaches offer hope combining best worlds sharing goal exploiting ﬁrstorder structure relational decisiontheoretic planning problems 7 Future directions concluding remarks In article motivated need exploit relational structure decisiontheoretic planning problems To end provided thorough review FOMDP representation 14 showed translate expressive subset PPDDL particular FOMDP representation We reviewed solution FOMDPs symbolic dynamic pro gramming contributed additional practical solution techniques based use ﬁrstorder ADDs FOADDs additive value decomposition universal rewards ﬁrstorder approximate linear programming FOALP Combining ideas provided proofofconcept results probabilistic track ICAPS 2004 2006 International Planning Competitions We outline interesting directions future work offer concluding remarks decisiontheoretic plan ning framework FOMDPs 71 Future directions There number open issues raised work merit exploration We enumerate 1 An interesting approach practical application FOMDPs decisiontheoretic planning combine approximate oﬄine solution online methods enhancing performance We need look range successful planners planning competitions ideas Perhaps useful approaches use oﬄine methods solving FOMDPs generate ﬁrstorder approximated value function Then use value function heuristic seed online search methods RTDP 522 Another approach consider domainspeciﬁc control knowledge encoded temporal logic constraints TLPlan 3 program constraints Golog 48 TLPlan Golog deterministic planners decisiontheoretic extensions DTGolog 15 We discuss use program constraints moment 2 We explore approximate extensions value iteration FOMDPs Given success APRICODD plan ner 75 performs approximate value iteration ADDs approach appealing ﬁrstorder approxi mate value iteration FOADDs When FOADD representing value function large simply prune nodes FOADD effort reduce size value function minimizing approximation error 3 One promising use FOMDPs highest level abstraction hierarchy agentbased decisiontheoretic planning 22 demonstrate MDP model approximated structure eﬃciently solvable error bounds obtained resulting optimal policy abstracted model respect optimal policy nonabstracted version If lift results FOMDPs offers appealing paradigm use approximate general FOMDP model level know solve eﬃciently obtaining error bounds performance optimal policy approximated model Or aﬁeld use solution 12 To clarify use term inductive refer algorithm inductive component However noted inductive approaches mentioned incorporate form deduction sampling Bellman equations induction obtain symbolic representation samples In contrast SDP FOALP approaches advocated article viewed pure symbolic deduction deduce value representations lifted version Bellman equation 786 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 approximated model guidance computationally expensive algorithms like ground heuristic search seed values 22 shaped rewards 55 value iteration nonabstracted MDP model In addition immediate open problems posed techniques touched surface FOMDPs vast array stochastic decision processes symbolic solution methods possible There remain number promising directions exploitation structure relationallyspeciﬁed decisiontheoretic planning problems brieﬂy 1 One original goals FOMDP symbolic dynamic programming frameworks 14 allow general symbolic representations While current FOMDP research assumed constant numerical representation values case statement partitions situations obtain nonconstant values case statements compactly representing value functions FOMDPs universal rewards depend count objects satisfying property given situation context modeling continuous state properties combined discrete state properties ﬁrstorder generalization hybrid MDPs 3437 However case statement generalized handle nonconstant numerical representations case operators like casemax appropriately generalized eﬃciently handle value representations Section 623 67 example casemax generalization Furthermore theorem provers capable reasoning counting properties constrained continuous variables symbolic case statement enhancements order detect inconsistency state partitions 2 In FOMDPs element underlying topological graph structure For example logistics planning graph structure involve accessibility different cities roads ﬂight routes Currently graph structure exploited solution methods Yet regularity known priori likely exploitable solution methods compile graph structure This approach far advantageous relying ﬁrstorder case representation extract relevant graph properties cumbersome speciﬁcation transitively composed relations c1 c2 Roadc1 c2 c3 Roadc2 c3 c4Roadc3 c4 3 We predeﬁned set constraints behavior agent need optimize agents policy respect constraints If specify program constraints form Golog program 48 generalize hierarchy abstract machines HAM architecture 156 case solving FOMDPs respect Golog program constraints Such solution permit approximately optimal execution incompletely speciﬁed program possible domaininstantiations Various approaches decisiontheoretic DTGolog framework 1528 provided initial investigation ideas The suggestions possible extensions work presented article ﬁrstorder decisiontheoretic planning general 72 Concluding remarks For years immediately succeeding publication symbolic dynamic programming solution 14 rela tionally speciﬁed MDPs domainindependent nongrounding approach disparaged unrealistic practical applications complexity value functions need logical simpliﬁcation theorem proving 30 3584 While fact signiﬁcant obstacles overcome practical application ﬁrstorder MDPs decisiontheoretic planning article aimed obstacles insurmountable It provided substantial step direction demonstrating careful attention paid ﬁrstorder representation algorithms speciﬁcally designed exploit representation nongrounded lifted solutions viable practice demonstrated proofofconcept results ICAPS 2004 2006 International Planning Competitions Our hope article lays foundations exploration nongrounding approaches permits integration ideas lines research decisiontheoretic planning Acknowledgements We grateful anonymous reviewers extensive comments suggestions vastly improved presentation discussion work We grateful Kee Siong Ng provided suggestions corrections This work supported Natural Sciences Engineering Research Council NSERC Canada This research conducted ﬁrst author NICTA Department Computer Science University Toronto NICTA funded Australian Governments Backing Australias Ability Centre Excellence programs References 1 D Andre S Russell Programmable reinforcement learning agents Advances Neural Information Processing Systems NIPS01 vol 13 2001 pp 7885 2 F Bacchus JY Halpern HJ Levesque Reasoning noisy sensors situation calculus International Joint Conference Artiﬁcial Intelligence IJCAI95 Montreal 1995 pp 19331940 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 787 3 F Bacchus F Kabanza Using temporal logics express search control knowledge planning Artiﬁcial Intelligence 116 12 2000 123191 4 RI Bahar E Frohm C Gaona G Hachtel E Macii A Pardo F Somenzi Algebraic decision diagrams applications IEEEACM International Conference CAD 1993 pp 428432 5 AG Barto SJ Bradtke SP Singh Learning act realtime dynamic programming Tech Rep UMCS1993002 U Mass Amherst 1993 6 RE Bellman Dynamic Programming Princeton University Press Princeton NJ 1957 7 DP Bertsekas Dynamic Programming Prentice Hall Englewood Cliffs NJ 1987 8 DP Bertsekas JN Tsitsiklis NeuroDynamic Programming Athena Scientiﬁc Belmont MA 1996 9 AL Blum ML Furst Fast planning graph analysis IJCAI 95 Montreal 1995 pp 16361642 10 B Bonet H Geffner mGPT A probabilistic planner based heuristic search Online Proceedings The Probabilistic Planning Track IPC04 httpwwwcsrutgersedumlittmantopicsipc04ptproceedings 2004 11 C Boutilier RI Brafman C Geib Prioritized goal decomposition Markov decision processes Toward synthesis classical decision theoretic planning International Joint Conference Artiﬁcial Intelligence IJCAI97 Nagoya 1997 pp 11561162 12 C Boutilier T Dean S Hanks Decisiontheoretic planning Structural assumptions computational leverage Journal Artiﬁcial Intelligence Re search JAIR 11 1999 194 13 C Boutilier N Friedman M Goldszmidt D Koller Contextspeciﬁc independence Bayesian networks Uncertainty Artiﬁcial Intelligence UAI 96 Portland OR 1996 pp 115123 14 C Boutilier R Reiter B Price Symbolic dynamic programming ﬁrstorder MDPs International Joint Conference Artiﬁcial Intelligence IJCAI 01 Seattle 2001 pp 690697 15 C Boutilier R Reiter M Soutchanski S Thrun Decisiontheoretic highlevel agent programming situation calculus AAAI00 Austin TX 2000 pp 355362 16 R Brachman H Levesque Knowledge Representation Reasoning Morgan Kaufmann Publishers Inc San Francisco CA 2004 17 O Buffet D Aberdeen The factored policy gradient planner ipc06 version Proceedings Fifth International Planning Competition 2006 18 W Buntine Generalized subsumption application induction redundancy Artiﬁcial Intelligence 36 1988 375399 19 D Farias BV Roy The linear programming approach approximate dynamic programming Operations Research 51 6 2003 850865 20 R Salvo Braz E Amir D Roth Lifted ﬁrstorder probabilistic inference 19th International Joint Conference Artiﬁcial Intelligence IJCAI2005 Edinburgh UK 2005 pp 13191325 21 R Salvo Braz E Amir D Roth MPE partial inversion lifted probabilistic variable elimination National Conference Artiﬁcial Intelligence AAAI06 Boston USA 2006 22 R Dearden C Boutilier Abstraction approximate decisiontheoretic planning Artiﬁcial Intelligence 89 12 1997 219283 23 R Dechter Bucket elimination A unifying framework reasoning Artiﬁcial Intelligence 113 1999 4185 24 K Driessens S Dzeroski Integrating experimentation guidance relational reinforcement learning International Conference Machine Learning ICML 2002 pp 115122 25 S Dzeroski L DeRaedt K Driessens Relational reinforcement learning Machine Learning Journal MLJ 43 2001 752 26 A Fern S Yoon R Givan Approximate policy iteration policy language bias Advances Neural Information Processing Systems 16 NIPS 03 December 2003 27 A Fern S Yoon R Givan Learning domainspeciﬁc control knowledge random walks International Conference Planning Scheduling ICAPS04 June 2004 pp 191199 28 A Ferrein C Fritz G Lakemeyer Extending DTGolog options 18th International Joint Conference Artiﬁcial Intelligence IJCAI2003 Aca pulco Mexico 2003 pp 144151 29 RE Fikes NJ Nilsson STRIPS A new approach application theorem proving problem solving AI Journal 2 1971 189208 30 NH Gardiol LP Kaelbling Envelopebased planning relational MDPs Advances Neural Information Processing Systems 16 NIPS03 Vancou ver CA 2004 pp 10401046 31 T Gartner K Driessens J Ramon Graph kernels Gaussian processes relational reinforcement learning Machine Learning Journal MLJ 64 2006 91119 32 A Gerevini B Bonet B Givan Eds Online Proceedings The Fifth International Planning Competition IPC05 httpwwwldcusbve bonetipc5docsipc2006bookletpdfgz Lake District UK 2006 33 C Gretton S Thiebaux Exploiting ﬁrstorder regression inductive policy selection Uncertainty Artiﬁcial Intelligence UAI04 Banff Canada 2004 pp 217225 34 C Guestrin M Hauskrecht B Kveton Solving factored MDPs continuous discrete variables 20th Conference Uncertainty Artiﬁcial Intelligence 2004 pp 235242 35 C Guestrin D Koller C Gearhart N Kanodia Generalizing plans new environments relational MDPs 18th International Joint Conference Artiﬁcial Intelligence IJCAI2003 Acapulco Mexico 2003 pp 10031010 36 C Guestrin D Koller R Parr S Venktaraman Eﬃcient solution methods factored MDPs Journal Artiﬁcial Intelligence Research JAIR 19 2002 399468 37 M Hauskrecht B Kveton Linear program approximations factored continuousstate Markov decision processes Advances Neural Information Processing Systems 16 2004 pp 895902 38 J Hoey R StAubin A Hu C Boutilier SPUDD Stochastic planning decision diagrams Uncertainty Artiﬁcial Intelligence UAI99 Stock holm 1999 pp 279288 39 J Hoffmann B Nebel The FF planning Fast plan generation heuristic search Journal Artiﬁcial Intelligence Research JAIR 14 2001 253302 40 S Hölldobler E Karabaev O Skvortsova FluCaP A heuristic search planner ﬁrstorder mdps Journal Artiﬁcial Intelligence Research JAIR 27 2006 419439 41 RA Howard Dynamic Programming Markov Processes MIT Press 1960 42 E Karabaev O Skvortsova A heuristic search algorithm solving ﬁrstorder MDPs Uncertainty Artiﬁcial Intelligence UAI05 Edinburgh Scotland 2005 pp 292299 43 K Kersting M van Otterlo L Raedt Bellman goes relational International Conference Machine Learning ICML04 ACM Press 2004 pp 465472 44 R Khardon Learning action strategies planning domains Artiﬁcial Intelligence 113 12 1999 125148 45 R Khardon Learning actions Machine Learning 35 1 1999 5790 46 D Koller R Parr Computing factored value functions policies structured MDPs International Joint Conference Artiﬁcial Intelligence IJCAI 99 Stockholm 1999 pp 13321339 47 D Koller R Parr Policy iteration factored MDPs Uncertainty Artiﬁcial Intelligence UAI00 Stockholm 2000 pp 326334 48 HJ Levesque R Reiter Y Lespérance F Lin R Scherl GOLOG A logic programming language dynamic domains Journal Logic Program ming 31 13 1997 5983 788 S Sanner C Boutilier Artiﬁcial Intelligence 173 2009 748788 49 I Little Paragraph A Graphplanbased probabilistic planner Proceedings Fifth International Planning Competition 2006 50 ML Littman HLS Younes Eds Online Proceedings The Probabilistic Planning Track IPC04 httpwwwcsrutgersedumlittmantopicsipc04 ptproceedings Vancouver Canada 2004 51 S Mahadevan Samuel meets Amarel Automating value function approximation global state space analysis National Conference Artiﬁcial Intelligence AAAI05 Pittsburgh 2005 pp 10001005 52 J McCarthy Situations actions causal laws Tech rep Stanford University 1963 reprinted M Minsky Ed Semantic Information Processing MIT Press Cambridge MA 1968 pp 410417 53 N Meuleau M Hauskrecht KE Kim L Peshkin LP Kaelbling T Dean C Boutilier Solving large weakly coupled Markov decision processes National Conference Artiﬁcial Intelligence AAAI98 Madison WI 1998 pp 165172 54 B Motik Reasoning description logics resolution deductive databases PhD thesis Univesität Karlsruhe TH Karlsruhe Germany January 2006 55 AY Ng D Harada S Russell Policy invariance reward transformations theory application reward shaping Proc 16th International Conf Machine Learning Morgan Kaufmann San Francisco CA 1999 pp 278287 56 R Parr S Russell Reinforcement learning hierarchies machines MMK Jordan S Solla Eds Advances Neural Information Processing Systems 10 MIT Press Cambridge MA 1998 pp 10431049 57 R Patrascu P Poupart D Schuurmans C Boutilier C Guestrin Greedy linear valueapproximation factored Markov decision processes National Conference Artiﬁcial Intelligence AAAI02 Edmonton 2002 pp 285291 58 EPD Pednault ADL Exploring middle ground STRIPS situation calculus KR 1989 pp 324332 59 D Poole The independent choice logic modelling multiple agents uncertainty Artiﬁcial Intelligence 94 12 1997 756 60 D Poole Firstorder probabilistic inference IJCAI 2003 pp 985991 61 P Poupart C Boutilier R Patrascu D Schuurmans Piecewise linear value function approximation factored MDPs National Conference Artiﬁcial Intelligence AAAI02 Edmonton 2002 pp 292299 62 ML Puterman Markov Decision Processes Discrete Stochastic Dynamic Programming Wiley New York 1994 63 R Reiter The frame problem situation calculus A simple solution completeness result goal regression V Lifschitz Ed Artiﬁcial Intelligence Mathematical Theory Computation Papers Honor John McCarthy Academic Press San Diego CA 1991 pp 359380 64 R Reiter Knowledge Action Logical Foundations Specifying Implementing Dynamical Systems MIT Press 2001 65 A Riazanov A Voronkov The design implementation vampire AI Communications 15 2 2002 91110 66 J Rintanen Expressive equivalence formalisms planning sensing 13th International Conference Automated Planning Scheduling 2003 pp 185194 67 S Sanner Firstorder decisiontheoretic planning structured relational environments PhD thesis University Toronto Toronto ON Canada March 2008 68 S Sanner C Boutilier Approximate linear programming ﬁrstorder MDPs Uncertainty Artiﬁcial Intelligence UAI05 Edinburgh Scotland 2005 pp 509517 69 S Sanner C Boutilier Practical linear evaluation techniques ﬁrstorder MDPs Uncertainty Artiﬁcial Intelligence UAI06 Boston MA 2006 70 S Sanner C Boutilier Approximate solution techniques factored ﬁrstorder MDPs 17th International Conference Automated Planning Scheduling ICAPS07 2007 pp 288295 71 D Schuurmans R Patrascu Direct value approximation factored MDPs Advances Neural Information Processing 14 NIPS01 Vancouver 2001 pp 15791586 72 P Schweitzer A Seidmann Generalized polynomial approximations Markovian decision processes Journal Mathematical Analysis Applica tions 110 1985 568582 73 LS Shapley Stochastic games Proceedings National Academy Sciences 39 1953 327332 74 SP Singh D Cohn How dynamically merge Markov decision processes Advances Neural Information Processing Systems NIPS98 MIT Press Cambridge MA 1998 pp 10571063 75 R StAubin J Hoey C Boutilier APRICODD Approximate policy construction decision diagrams Advances Neural Information Processing 13 NIPS00 Denver 2000 pp 10891095 76 F Teichteil P Fabiani Symbolic stochastic focused dynamic programming decision diagrams Proceedings Fifth International Planning Competition 2006 77 S Thiebaux C Gretton J Slaney D Price F Kabanza Decisiontheoretic planning nonMarkovian rewards Journal Artiﬁcial Intelligence Re search 25 January 2006 1774 78 JN Tsitsiklis B Van Roy Featurebased methods large scale dynamic programming Machine Learning 22 1996 5994 79 M Veloso Learning analogical reasoning general problem solving PhD thesis Carnegie Mellon University August 1992 80 C Wang S Joshi R Khardon First order decision diagrams relational MDPs Twentieth International Joint Conference Artiﬁcial Intelligence IJCAI07 Hyderabad India 2007 pp 10951100 81 C Wang S Joshi R Khardon First order decision diagrams relational MDPs Journal Artiﬁcial Intelligence Research JAIR 31 2008 431472 82 C Wang R Khardon Policy iteration relational MDPs Uncertainty Artiﬁcial Intelligence UAI07 Vancouver Canada 2007 83 J Wu R Givan Discovering relational domain features probabilistic planning 17th International Conference Automated Planning Scheduling ICAPS 2007 2007 pp 344351 84 S Yoon A Fern R Givan Inductive policy selection ﬁrstorder Markov decision processes Uncertainty Artiﬁcial Intelligence UAI02 Ed monton 2002 pp 569576 85 S Yoon A Fern R Givan Learning reactive policies probabilistic planning domains Online Proceedings The Probabilistic Planning Track IPC04 httpwwwcsrutgersedumlittmantopicsipc04ptproceedings 2004 86 S Yoon A Fern R Givan Learning measures progress planning domains 20th National Conference Artiﬁcial Intelligence July 2005 pp 12171222 87 S Yoon A Fern R Givan Approximate policy iteration policy language bias Learning solve relational Markov decision processes Journal Artiﬁcial Intelligence Research JAIR 25 2006 85118 88 S Yoon A Fern R Givan FFReplan A baseline probabilistic planning 17th International Conference Automated Planning Scheduling ICAPS07 2007 pp 352359 89 HLS Younes ML Littman D Weissman J Asmuth The ﬁrst probabilistic track international planning competition Journal Artiﬁcial Intelli gence Research JAIR 24 2005 851887 90 NL Zhang D Poole A simple approach Bayesian network computations Proc Tenth Canadian Conference Artiﬁcial Intelligence 1994 pp 171178 91 NL Zhang D Poole Exploiting causal independence Bayesian network inference Journal Artiﬁcial Intelligence Research JAIR 5 1996 301328