Artiﬁcial Intelligence 144 2003 157211 wwwelseviercomlocateartint A logic programming approach knowledgestate planning II The DLVK Thomas Eiter Wolfgang Faber Nicola Leone b Gerald Pfeifer Axel Polleres Institut für Informationssysteme Technische Universität Wien Favoritenstraße 911 A1040 Wien Austria b Department Mathematics University Calabria 87030 Rende CS Italy Received 10 January 2002 Abstract In Part I series papers proposed new logicbased planning language called K This language facilitates description transitions states knowledge suited planning incomplete knowledge Nonetheless K supports representation transitions states world states complete knowledge special case proving ﬂexible In present Part II DLVK planning implements K disjunctive logic programming DLV This novel planning allows solv ing hard planning problems including secure planning incomplete initial states called conformant planning literature solved logicbased planning systems traditional satisﬁability planners We present detailed comparison DLVK sys tem stateoftheart conformant planning systems level features benchmark problems Our results indicate thanks power knowledgestate problem encoding DLVK competitive special purpose conformant planning systems supplies natural simple representation planning problems 2002 Elsevier Science BV All rights reserved Keywords Deductive planning Disjunctive logic programming Answer sets Knowledgestates Incomplete information Conformant planning Secure planning A preliminary description appeared Thomas Eiter Wolfgang Faber Mirosław Truszczynski editors Proceedings 6th International Conference Logic Programming Nonmonotonic Reasoning LPNMR01 Lecture Notes Computer Science Vol 2173 Springer 2001 pp 429433 Corresponding author Email addresses eiterkrtuwienacat T Eiter faberkrtuwienacat W Faber leoneunicalit N Leone pfeiferdbaituwienacat G Pfeifer axelkrtuwienacat A Polleres 0004370202 matter 2002 Elsevier Science BV All rights reserved doi101016S0004370202003673 158 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 1 Introduction The need modeling behavior robots formal way led deﬁnition logicbased languages reasoning actions planning 1316182021 263345 These languages allow specifying planning problems form Find sequence actions leads initial state goal state A state characterized truth values number ﬂuents describing relevant properties domain discourse An action applicable preconditions formulas ﬂuents hold current state executing action changes current state modifying truth values ﬂuents Most languages based extensions classical logics transitions possible states world ﬂuent necessarily true false However robots usually complete view world Even knowledge incomplete number ﬂuents unknown door robot open decisions execute actions reason basis incomplete information hand For example known door open robot sensing action decide push In 56 proposed new language K K remind states knowledge planning incomplete knowledge This language ﬂexible capable modeling transitions states world states complete knowledge reasoning particular case Compared similar planning languages particular Giunchiglia Lifschitz action language C 172629 K closer spirit answer set semantics 12 classical logics It supports explicit use default negation exploiting power answer sets deal incomplete knowledge In 6 deﬁned syntax semantics K discussed knowledge representation plus analyzed computational complexity planning K In present paper Part II series papers turn DLVK planning implements K DLV answer set program ming 79 DLVK powerful planning freely available URLhttpwwwdbaituwienacatprojdlv readytouse experiments In com parison similar logicbased planning systems like CCALC 3031 CPlan 1015 CMBP 4 DLVK following key features Explicit background knowledge The planning domain background represented stratiﬁed Datalog program describes static predicates Type declarations The arguments changeable predicates called ﬂuents action atoms typed Strong weak negation The DLVK provides kinds negation familiar answer set semantics weak default negation strong classical negation denoted Weak negation allows simple intuitive statement inertia rules ﬂuents statement default values ﬂuents domain Complete incomplete states By default states DLVK consistent sets ground literals atom appear represent states T Eiter et al Artiﬁcial Intelligence 144 2003 157211 159 knowledge However suitable constructs DLVK allows representing transitions possible states world seen states complete knowledge ParallelSequential execution actions Simultaneous execution actions possi ble fact default mode All actions executed qualify executability condition Mutual exclusion actions enforced sequential planning mode Secure conformant planning DLVK able compute secure plans called conformant plans literature 1942 Informally plan secure applicable starting legal initial state enforces goal regardless state evolves Using feature model possibleworlds planning incomplete initial state initial world partially known looking plan reaching desired goal possible world according initial state Main contributions The main contributions present paper following 1 We reduce planning K answer set programming means efﬁcient transformation Using transformation planning problem K translated equivalent disjunctive logic program submitted DLV evaluation The solutions original planning problem obtained answer sets produced DLV correspond optimistic plans The use disjunctive rules transformation use natural problem modeling easily eliminated unstratiﬁed negation instead adapted transformation implemented systems Smodels 35 2 We discuss issue secure planning alias conformant planning realization DLVK Brieﬂy imposes security check optimistic plans order assess plan secure transformed nested DLV By foundational results 6 ﬁnding secure plan cid2P 3 hard1 problem twostep approach secure planning ﬁrst ﬁnd optimistic plan check security mandatory polynomial reductions answer set programming DLV solve problems complexity cid2P 2 polynomial overhead 3 We compare DLVK following stateoftheart conformant planning systems CCALC 3031 CMBP 4 CPlan 1015 GPT 3 SGP 47 In particular ﬁrst provide overview systems comparing main features We consider number benchmark problems problems blocksworld bomb toilet domains discuss encodings different systems viewpoint knowledge representation Having conducted extensive experimentation report execution times systems number 1 We use common notion cid2P nondeterministic Turing machine NP oracle cid2P polynomially nondeterministic Turing machine cid2P 2 describes class problems solvable polynomial time 3 respectively problem class solvable 2 oracle cf 36 160 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 planningproblem instances compare performance systems As turns thanks power knowledgestate problem encodings DLVK compete special purpose conformant planning systems experiments supplies elegant succinct representation planning problems This taken promising evidence potential usefulness knowledge state problem encodings conformant planning To best knowledge DLVK ﬁrst declarative logicprogramming based planning allows solving cid2P 2 hard planning problems like planning incomplete initial states The remainder paper organized follows In section introduce DLVK planning user architecture levels After turn technical realization DLVK discuss Sections 3 4 transformation DLVK planning problems answer set programs section devoted optimistic planning considers secure planning After compare DLVK planning number planning systems Section 6 discusses related work presents outlook ongoing future work In order alleviate reading relevant deﬁnitions notation foundational Part I 6 provided Appendix A present paper 2 The planning DLVK In section DLVK planning provides imple mentation language K frontend DLV 79 We ﬁrst planning problems speciﬁed DLVK followed architecture sys tem ﬁnally brieﬂy usage DLVK In order abundant shall strict short exposition focus essential facts Fur ther information foundational paper 6 DLVK web page URLhttpwwwdbaituwienacatprojdlvK 21 Planning problems DLV K In section planning problems represented programs DLVK For purpose shall consider example wellknown blocksworld domain DLVK programs built statements language K plus optional control statements We shall exhaustively repeat details K particular shall formally deﬁne semantics K The details formal deﬁnition semantics K include abbreviated form Appendix A 6 A planning problem pair P cid5PD qcid6 planning domain informally world discourse PD query q speciﬁes goal A planning problem T Eiter et al Artiﬁcial Intelligence 144 2003 157211 161 represented combination background knowledge Π stratiﬁed Datalog program cf Section 31 program following general form fluents actions initially goal FD AD IR CR q sections fluents optional omitted They consist statements described terminated Together background knowledge Π specify K planning domain form PD cid5Π cid5D Rcid6cid6 Appendix A declarations D given FD AD rules R IR CR The statements FD AD ﬂuent action declarations respectively type ﬂuents actions respect static background predicates They form pX1 Xn requires t1 tm 1 p ﬂuent action predicate arity n cid1 0 ti classical literals atom α negation α denoted α predicates background knowledge variable Xi occurs t1 tm common upper case letters denote variables Only ground instances ﬂuents actions supported ground instance declaration requires true need considered The initiallysection speciﬁes conditions hold initial state note general initial state unique They form causal rules described The alwayssection speciﬁes dynamics planning domain terms causation rules form caused f b1 bk bk1 bl a1 am1 2 f classical literal ﬂuent false representing absurdity bi s classical literals ﬂuents background predicates aj s positive action atoms classical literals ﬂuent background predicates Informally rule 2 states f true new state reached executing simultaneously actions provided condition true respect old state actions executed condition true new state Both afterparts optional Speciﬁcally omitted causedkeyword represent simple facts The alwayssection contains executability conditions actions expressions form executable b1 bk bk1 bl 3 162 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 Fig 1 Sussmans blocksworld planning problem fluents onB L requires blockB locationL occupiedB requires locationB moveB L requires blockB locationL actions initially ona table onb table onc caused occupiedB onB1 B blockB executable moveB L B L nonexecutable moveB L occupiedB nonexecutable moveB L occupiedL noConcurrency caused onB L moveB L caused onB L1 moveB L onB L1 L L1 inertial onB L onc b onb ona table 3 goal Fig 2 DLV K program Sussmans problem blocksworld domain PDbw action atom b1 bl classical literals Informally condition says welltyped action eligible execution state b1 bk known hold bk1 bl known hold state The goalsection ﬁnally speciﬁes goal reached form g1 gm gm1 gn 4 g1 gn ground ﬂuent literals n cid1 m cid1 0 cid1 0 number steps plan reach goal All rules IR CR satisfy safety requirement default negated type literals2 variable occurring default negated type literal occur nonnegated type literal dynamic literal Note safety restriction apply action ﬂuent literals variables range restricted respective declarations Example 21 Sussmans blocksworld planning problem An example DLVK program given Fig 2 It represents Sussmans famous planning problem blocksworld domain 44 depicted Fig 1 showed anomalous behavior STRIPS planning The blocksworld planning domain PDbw involves distinguishable blocks table Blocks table serve locations blocks block 2 These literals corresponding predicates deﬁned background knowledge T Eiter et al Artiﬁcial Intelligence 144 2003 157211 163 hold block table hold arbitrarily blocks The background knowledge Πbw predicates block location deﬁned follows blocka blockb blockc locationtable locationB blockB In DLVK program ﬂuents declared representing states onBL states block B resides location L occupiedL true location L capacity holding blocks exhausted Furthermore single action predicate moveBL represents moving block B location L implicitly removes block previous location With ﬂuent action repertoire initial state causal rules executability conditions guarding state transitions As initial state conﬁguration blocks shown left Fig 1 expressed facts onatable onbtable onca Note positive facts stated initial state unique ﬂuent interpreted closed world assumption CWA 40 onBL hold assume false The values ﬂuent occupied initial state speciﬁed explicitly obtained general rule applies states alwayssection program ﬁrst rule It says block B occupied B1 Note rule apply B table table supposed unlimited capacity Furthermore B1 block declaration ﬂuent Next specify action moveBL executable The ﬁrst condition states possible block B target location L distinct block moved The negative conditions nonexecutable state executable block B target location L occupied respectively These statements shorthand macros causation rules interdict execution action Appendix A3 Thus executable positive condition holds negative conditions fail In standard blocksworld setting block moved time Another macro noConcurrency enforces This macro convenient computing sequential plans plans mutual exclusion parallel actions The effects action deﬁned dynamic rules The ﬁrst states moved block target location second block location moved provided moved different location The statement alwayssection inertial statement ﬂuent macro Appendix A3 informally expressing ﬂuent stay true explicitly false new state To solve Sussmans problem query goalsection contains conﬁguration right Fig 1 furthermore prescribes plan length 3 feasible 164 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 The semantics planning domains deﬁned terms legal states state transitions Informally state consistent collection ground ﬂuent literals respect typing information It legal initial state satisﬁes rules initiallysection rules alwayssection answer set semantics cf Section 31 causal rules read logic programming rules A state transition triple t cid5s A scid10cid6 s scid10 states A set legal action instances PD action instances respect typing information Such t legal action set A executable wrt s action A head clause 3 body true scid10 satisﬁes causal rules 2 alwayssection true respect s A answer set semantics An optimistic plan goal g1 gm gm1 gn sequence action sets cid5A1 Aicid6 cid1 0 corresponding sequence T cid5cid5s0 A1 s1cid6 cid5s1 A2 s2cid6 cid5si1 Ai sicid6cid6 legal state transitions cid5sj 1 Aj sj cid6 exists leads legal initial state s0 state si establishes goal g1 gm si gm1 gn si This sequence legal state transitions called trajectory solution DLVK planning problem optimistic plan length speciﬁed goalsection cf 4 Example 22 Sussmans problem continued A wellknown solution Sussmans problem consists ﬁrst moving block c table moving b ﬁnally moving c b In DLVK setting amounts optimistic plan cid2 movec table moveb movec b cid1 We omit description unique trajectory plan point given Section 23 211 Secure planning DLVK special statement securePlan speciﬁed goalsection It instructs compute secure plans special optimistic plans Note securePlan macro complexity arguments expressible macro expanded efﬁciently Informally optimistic plan cid5A1 Ancid6 secure applicable evolution starting legal initial state s0 ﬁrst action set A1 cid1 1 legal transition cid5s0 A1 s1cid6 exists possible state s1 action set A2 eventually having performed actions goal established Secure plans called conformant plans literature considered scenarios incomplete information initial states nondeterministic action effects Example 23 Blocksworld incomplete initial state Let consider different planning problem blocksworld illustrated Fig 3 Here block d present exact location unknown know c T Eiter et al Artiﬁcial Intelligence 144 2003 157211 165 Fig 3 A blocksworld planning problem incomplete initial state The background knowledge Πbw DLVK program Sussmans problem modiﬁed follows For introducing block d planning domain add fact blockd Πbw fact ondc initiallysection DLVK program Let ﬁrst consider necessary extensions handling cases initial state description incorrect completing partial initial state description incorrect initial states arise The following conditions hold block It unique location ii block iii supported table table stack blocks table 27 It straightforward incorporate conditions ii initiallysection initially forbidden onB L onB L1 L L1 forbidden onB1 B onB2 B blockB B1 B2 Here forbidden macro cf Section A3 amounts constraint For condition iii introduce ﬂuent supported true block legal initial state fluents supportedB requires blockB We supported include constraint block supported initially caused supportedB onB table caused supportedB onB B1 supportedB1 forbidden supportedB Now modify goalsection goal ona c onc d ond b onb table 4 ﬁnally obtain plan works possible location block d beginning use total f macro DLVK deﬁned Appendix A3 generates alternatives value ﬂuent f initially total ond Y In way completions satisfy initial state constraints lead legal initial states fact states corresponding ondb ondtable 166 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 fluents onB L requires blockB locationL occupiedB requires locationB supportedB requires blockB actions moveB L requires blockB locationL initially ona table onb table onc ond c total ond Y forbidden onB L onB L1 L L1 forbidden onB1 B onB2 B blockB B1 B2 caused supportedB onB table caused supportedB onB B1 supportedB1 forbidden supportedB caused occupiedB onB1 B blockB executable moveB L B L nonexecutable moveB L occupiedB nonexecutable moveB L occupiedL noConcurrency caused onB L moveB L caused onB L1 moveB L onB L1 L L1 inertial onB L ona c onc d ond b onb table 4 goal Fig 4 DLV K program variant Sussmans problem incomplete world The rewritten DLVK program depicted Fig 4 program able compute following solution secure plan cid1 moved table moved b movec d movea c cid2 212 Knowledgestate vs worldstate planning Knowledge state planning K offers features available planning languages Recall knowledge state set consistent ﬂuent literals describes current knowledge planning world The negation failure construct allows expressing defeasible rules default conclusions natural modeling rational planning agents deal incomplete information possible qualitative level In fact knowledge state describes accurately belief set agent world formed strict defeasible causal laws This particular relevant interested reasonable plans achieving goal However framework limited elementary level directly allow representation disjunctive knowledge A useful feature knowledgestate planning allow elegant encoding conformant planning problems worldstate model values certain ﬂuents remain open In particular applies world states projected subsets ﬂuents This supports forgetting information extent focusing restricting attention ﬂuents value inﬂuence evolution world depending actions taken The advantages knowledge T Eiter et al Artiﬁcial Intelligence 144 2003 157211 167 Fig 5 DLV K architecture state encoding worldstate encoding wellknown bomb toilet problem 34 discussed Appendix C For discussion knowledgestate planning 6 22 System architecture The architecture DLVK outlined Fig 5 It accepts ﬁles containing DLVK input background knowledge stored plain Datalog ﬁles Then means suitable transformations K disjunctive logic programming Section 3 uses classic DLV core solve corresponding planning problem DLVK comes parsers The ﬁrst accepts DLVK ﬁles ﬁles ﬁlename extension plan constitute DLVK program second parser accepts optional background knowledge speciﬁed stratiﬁed Datalog Both parsers able read input arbitrary number ﬁles convert input internal representation store common database The actual DLVK frontend consists main modules Controller Plan Generator Plan Checker Plan Printer The Controller manages modules performs user interactions appropriate controls execution entire frontend To end Controller ﬁrst invokes Plan Generator translates planning problem hand suitable program core language DLV disjunctive logic programming answer set semantics described Section 31 according transformation lpP provided Section 32 The Controller invokes DLV kernel solve corresponding problem The resulting answer sets fed Controller extracts solutions original planning problem answer sets transforms original planning domain saves common database The Controller optionally user speciﬁed securePlan command invoked secure check interactively invokes Plan Checker Similarly Plan Generator Checker uses original problem description optimistic plan computed Generator generate disjunctive logic program solves problem verifying optimistic plan fact secure plan intuitively 168 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 introduced Section 211 details actual transformation employed Plan Checker provided Section 4 The Plan Printer ﬁnally translates solutions Generator optionally veriﬁed Checker suitable output planning user prints 23 Using DLVK DLVK commandline oriented realized frontend DLV logic programming It accepts types input ﬁles DLVK ﬁles carry ﬁlename extension plan contain DLVK code described Section 21 ii optional background knowledge form stratiﬁed Datalog program kept ﬁles ﬁlename extension The planning frontend invoked means FP family commandline options FP FPopt FPsec followed number DLVK ﬁles ﬁles containing background knowledge FP invokes DLVK interactive mode optimistic plan computed user prompted perform security check plan compute optimistic plan respectively FPopt computes optimistic plans batch mode user intervention FPsec computes secure plans applying default secure check SC1 deﬁned Section 4 batch mode In cases means commandline option n x number plans computed printed limited x default possible plans computed Further DLVK commandline options affect security checking introduced end Section 4 As example assume DLVK program Sussmans blocksworld planning problem Fig 2 Section 21 resides ﬁle blocksworldplan background knowledge blocks locations saved ﬁle background Invoking dlv FP blocksworldplan background results following output DLV build DEVDec 17 2001 gcc 2953 release STATE 0 occupieda onatable onbtable onca ACTIONS movectable STATE 1 onatable onbtable onctable onca ACTIONS moveba STATE 2 occupieda onatable onba onctable onbtable ACTIONS movecb T Eiter et al Artiﬁcial Intelligence 144 2003 157211 169 STATE 3 onatable onba oncb onctable PLAN occupieda occupiedb movectable moveba movecb Check plan secure yn y The plan secure Search plans yn y This describes successful trajectory cid5cid5s0 A1 s1cid6 cid5s1 A2 s2cid6 cid5s2 A3 s3cid6cid6 s0 s3 correspond lines starting STATE 0 STATE 3 output A1 A2 A3 correspond ACTIONS lines entire plan printed end Now let consider program Fig 4 variant Sussman problem incomplete initial state Let assume added fact blockd background knowledge modiﬁed ﬁle blocksworldplan accordingly Again invoking DLVK produce following output DLV build DEVDec 17 2001 gcc 2953 release STATE 0 occupieda onatable onbtable onca ondc supporteda supportedb supportedc onda ondtable ondb ondd supportedd ACTIONS movectable STATE 1 onatable onbtable onctable ondtable onca ACTIONS movedb STATE 2 onatable onbtable onctable ondb ondtable occupiedb ACTIONS movecd STATE 3 onatable onbtable oncd ondb onctable occupiedb occupiedd ACTIONS moveac STATE 4 onac onbtable oncd ondb onatable occupiedb occupiedc occupiedd movectable movedb movecd moveac PLAN Check plan secure yn y The plan NOT secure Search plans yn y 170 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 The ﬁrst plan arrive secure answer question search plans positively ﬁnd secure plan observe initial states STATE 0 larger total statement ondY STATE 0 occupieda onatable onbtable onca ondc supporteda supportedb supportedc onda ondtable ondb ondd supportedd ACTIONS movedc STATE 1 onatable onbtable onca ondc ondtable occupieda occupiedc ACTIONS movedb STATE 2 onatable onbtable onca ondb ondc occupieda occupiedb ACTIONS movecd STATE 3 onatable onbtable oncd ondb onca occupiedb occupiedd ACTIONS moveac STATE 4 onac onbtable oncd ondb onatable occupiedb occupiedc occupiedd movedc movedb movecd moveac PLAN Check plan secure yn y The plan secure Search plans yn While looking secure plans encounter optimistic plans secure change strategy invoke DLVK FPsec option instead interactive mode enabled FP This yield following result DLV build DEVDec 17 2001 gcc 2953 release PLAN movedc movedb movecd moveac PLAN movedtable movedb movecd moveac Indeed optimistic plans single secure plan addition Note secure plans usually different trajectories DLVK prints plans omitting information states T Eiter et al Artiﬁcial Intelligence 144 2003 157211 171 3 Transforming optimistic planning answer set programming In section discuss planning problems DLVK transformed answer set programs We consider optimistic planning deal secure planing section As preliminary ﬁrst recall concepts disjunctive logic programming 31 Disjunctive logic programming We consider extended disjunctive logic programs kinds negation like K language weak negation strong negation introduced 12 functionfree ﬁrstorder language Strings starting uppercase respectively lowercase letters denote variables respectively constants A positive respectively negative classical literal l atom negated atom respectively complement denoted l respectively A positive respectively negative failure NAF literal form l l l classical literal Unless stated literal mean classical literal A disjunctive rule rule short R formula a1 v v b1 bk bk1 bm 5 ai bj classical literals n cid1 0 m cid1 k cid1 0 The left respectively right head respectively body R omitted m 0 We let H R a1 set head literals BR BR BR set body literals BR b1 bk BR bk1 bm A constraint rule head n 0 A disjunctive logic program DLP P simply program ﬁnite set rules It positive notfree r P Br normal vfree R P H R cid2 1 A normal program called Datalog program As usual term atom rule ground variables appear A ground program called propositional Answer sets DLPs deﬁned consistent answer sets EDLPs 1225 That program P let UP Herbrand universe BP Herbrand base P UP constant appears P arbitrary constant added UP Let groundP RP groundR denote grounding P groundR set ground instances R cid3 Then interpretation set I BP ground literals An answer set positive ground program P consistent interpretation I I l l I I wrt set inclusion set closed rules P BR I implies H R I cid20 R P 3 An interpretation I answer set arbitrary ground program P answer set GelfondLifschitz reduct P I program obtained P deleting 3 We consider consistent answer sets 1225 inconsistent set BP answer set Technically assume negative classical literals viewed new atoms constraints implicitly added This standard way true negation implemented systems like DLV Smodels 172 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 rules R P BR I cid20 negative body literals remaining rules The answer sets nonground program P ground instantiation groundP We shall denote ASP set answer sets program P 32 Transformation lpP The main buildingblock underlying realization DLVK translation DLVK planning problem P given background knowledge Π DLVK program Section 21 logic program lpP answer sets represent optimistic plans P For sake translation extend ﬂuent action literals timestamp parameter T answer set AS translated program lpP corresponds successful trajectory T cid5cid5s0 A1 s1cid6 cid5sn1 An sncid6cid6 P following sense The ﬂuent literals AS having timestamp 0 represent legal initial state s0 T The ﬂuent literals AS having timestamp 0 represent state si obtained executing action sets represent evolution steps The action literals AS having timestamp represent actions Ai1 actions executed step 1 Moreover trajectories encoded answer sets lpP guaranteed establish goal planning problem underlying sequence action sets optimistic plan In following incrementally transformation planning problem P logic program lpP We illustrate transformation blocksworld planning problem Section 21 In follows let σ act σ ﬂ σ typ sets action ﬂuent type names act Lﬂ Ltyp set action positive action ﬂuent act dyn respectively let Lact L type literals respectively Furthermore Lﬂtyp Lﬂ Ltyp Ldyn Lﬂ L stands dynamic literals Step 0 Macro expansion In preliminary step replace macros DLVKprogram deﬁnitions cf Appendix A3 Example In encoding Sussmans problem macros nonexecutable moveBL occupiedB inertial onBL replaced caused false moveBL occupiedB onBL onBL onBL T Eiter et al Artiﬁcial Intelligence 144 2003 157211 173 Step 1 Background knowledge The background knowledge Π given logic program rules Π directly included lpP modiﬁcation Step 2 Auxiliary predicates To represent steps add following facts lpP time0 timei next0 1 nexti 1 plan length query q Gi P hand The predicate time denotes possible timestamps predicate describes successor relation timestamps program Note refrain builtin predicates particular logic programming engine In DLVK implementation auxiliary predicates efﬁciently handled preprocessing step Example For Sussmans problem q onc b onb ona table 3 add following facts time0 time1 time2 time3 next01 next12 next23 Step 3 Causation rules For causation rule rcaused H B A CR include rule r cid10 lpP follows cid4 cid10 hr H false H f t f σ ﬂ T1 new variable To body r cid10 add following literals f t T1 default type literal r notl A B l Ltyp bt T1 bt B bt Lﬂ bt T0 bt A bt Ldyn T0 new variable timing add timeT1 A nextT0T1 To respect typing declarations establish standard safety r cid10 add actionﬂuent literal H default negated ﬂuentsactions literals typing information corresponding actionﬂuent declarations That H pt respectively pt A B pt Ldyn pY requires t1Y1 tmYm actionﬂuent declaration standardized apart θ substitution θ Y t add θ t1Y1 θ tmYm body r cid10 If p multiple actionﬂuent declarations considered separately gives rise multiple typed versions r cid10 174 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 Example In encoding Sussmans problem statement caused occupiedB onB1 B blockB leads following rule lpP occupiedB T1 onB1 B T1 blockB locationB timeT1 Here timing atom timeT1 added type information locationB ﬂuent occupiedB H statement Step 4 Executability conditions For executability condition e form executable B CR introduce rule ecid10 lpP follows cid10 T0 v T0 T0 new variable To body ecid10 add following literals Each default type literal e notl B l Ltyp bt T0 bt B l Ldyn nextT0T1 T1 new variable typing safety type information literals default literal pcid22t B pcid22t Ldyn similar Step 3 lead multiple rules ecid10 Example In running example condition executable moveBL B L introduces lpP rule moveB L T0 v moveB L T0 B L blockB locationL nextT0 T1 Here type information blockB locationL added moveBL Step 5 Initial state constraints Initial state constraints IRcid10 transformed like static causation rules r Step 3 A use constant 0 instead variable T1 omit literal time0 Example The facts IR initially onatable onbtable onca onatable0 onbtable0 onca0 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 175 Step 6 Goal query Finally query q goal g1t1 gmtm gm1tm1 gntn translated goal_reached g1t1 gmtm gm1tm1 gntn goal_reached goal_reached new predicate symbol Example q onc b onb ona table 3 goal Sussmans problem leads following rules lpP goal_reached onc b 3 onb 3 ona table 3 goal_reached The complete transformation Sussmans blocksworld problem Pbw expansion macros Appendix A3 shown Fig 6 As reader easily verify transformation employs disjunction Step 4 translating executability conditions Furthermore negated action atoms T occur heads rules lpP Thus program headcyclefree proﬁtably exploited DLV engine underlying implementation The disjunction informally encodes guess action executed time blocka blockb blockc locationtable locationB blockB time0 time1 time2 time3 next0 1 next1 2 next2 3 ona table 0 blocka locationtable onb table 0 blockb locationtable onc 0 moveB L T0 v moveB L T0 B L blockB blockc locationa locationL nextT0 T1 moveB L T0 occupiedB T0 nextT0 T1 moveB L T0 occupiedL T0 nextT0 T1 occupiedB T1 onB1 B T1 blockB locationB timeT1 onB L T1 onB L T0 onB L T1 blockB locationL nextT0 T1 onB L T1 onB L1 T1 moveB L T0 blockB locationL nextT0 T1 moveB L T0 onB L1 L L1 blockB locationL1 nextT0 T1 1 tcid10 movet1 t2 T0 movetcid10 2 T0 t2 tcid10 2 b c table t1 t2 cid20 tcid10 t1 tcid10 1 b c 1 tcid10 2 goal_reached onc b 3 onb 3 ona table 3 goal_reached Fig 6 Transformation Sussmans planning problem Pbw Section 21 176 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 T0 equivalently replaced vfree guessing rules The adapted transformation engines computing answer sets normal programs Smodels The following result formally states desired correspondence solutions DLVK planning problem P answer sets logic program lpP obtained following procedure described Theorem 31 Answer set correspondence Let P planning problem given background knowledge Π DLVKprogram let lpP logic program generated Steps 06 Deﬁne consistent set literals S sets AS j j 1 S σ act sS j f t f t j S f t Lﬂ j cid1 0 Then optimistic plan P cid5A1 Aicid6 P witnessing trajectory T cid5cid5s0 A1 s1cid6 cid5s1 A2 s2cid6 cid5si1 Ai si cid6cid6 exists answer set S lpP Aj AS j j 1 sj sS j j 0 ii answer set S lpP sequence P cid5A1 Aicid6 solution P optimistic plan witnessed trajectory T cid5cid5s0 A1 s1cid6 cid5s1 A2 s2cid6 cid5si1 Ai sicid6cid6 Aj AS k j 1 k 0 j sk sS Proof The proof based wellknown notion splitting logic program deﬁned 28 We deﬁne splitting sequence U cid5UBG U0 Ui UGcid6 cid5BG BG S0 BG S0 Si BG S0 Si Gcid6 program P cid10 groundlpP follows BG set type literals time literals occurring P cid10 Sj 0 cid2 j cid2 set literals P cid10 form f t j f σ ﬂ form j 1 σ act G goal_reached By Splitting Sequence Theorem 28 P cid10 lpP sistent answer set S iff S XBG X0 Xi XG solution X cid5XBG X0 Xi XGcid6 P cid10 wrt U We note following facts PBG bUBGP cid10 deﬁned 28 intuitively program corresponding UBG consists background program facts deﬁning time P0 eUBGbU0P cid10 bUBGP cid10 XBG deﬁned 28 intuitively program corresponding U0 consists rules constraints translations initial state constraints static rules causation rules argument time argument head predicates instantiated 0 Pj eUj1bUj P cid10bUj1 P cid10 XBG X0 Xj 1 1 cid2 j cid2 intuitively program corresponding Uj consists rules constraints translations causation rules executability conditions alwayssection argument time second argument instantiated j T Eiter et al Artiﬁcial Intelligence 144 2003 157211 177 argument head predicates causation rules executability conditions j j 1 respectively PG eUi bUGP cid10 bUi P cid10 XBG X0 Xi intuitively program corresponding UG consists rule constraint generated Step 6 XBG X0 Xi XG consistent set iff sets XBG X0 Xi XG consistent literal sets BG S0 Si G exists complement contained sets We prove ii theorem We optimistic plan corresponding answer set S lpP described exists By Splitting Sequence Theorem prove respective solution X cid5XBG X0 Xi XGcid6 lpP exists XBG X0 Xj XG As s0 legal initial state background knowledge consistent answer set Thus deﬁnition PBG clearly consistent answer set XBG s0 witnessing trajectory legal initial state s0 satisﬁes rules initiallysection rules alwayssection answer set semantics causal rules read logic programming rules These rules essentially identical modulo time literals timestamp arguments P0 X0 exists s0 sSP For 1 cid2 j cid2 cid5sj 1 Aj sj cid6 legal transition We proceed inductively Aj executable action set wrt sj 1 action Aj occur head executability condition body true wrt sj 1 There corresponding clause Pj constructed Step 4 translation body true wrt Xj 1 If choose Xj ASP Aj rules satisﬁed Each rule Pj action literal la head la Aj true body Xj 1 include negation la Xj 0 j Furthermore sj satisﬁes causal rules alwayssection true wrt sj 1 Aj answer set semantics From correspondence causal rules alwayssection rules Pj Aj ASP conclude Pj answer set Xj st sj sSP seen si satisﬁes goal P Let g1 gm gm1 gni goal P Then g1 gm si gm1 gn si hold Since si sXi P body rule generated Step 6 true XG goal_reached exists j j In total shown optimistic plan P corresponding answer set S lpP exists contains literals representing witnessing trajectory ii We prove answer set S lpP corresponding optimistic plan P exists By Splitting Sequence Theorem solution X cid5XBG X0 Xi XGcid6 178 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 exists lpP Since X0 answer set program corresponding initial state constraints static rules legal initial state s0 sSP 0 exist For Xj 1 cid2 j cid2 proceed inductively All rules corresponding executability conditions wrt time j 1 satisﬁed literal la Xj corresponds positive action literal rule Pj body true wrt Xj 1 la true head literal exist By construction executability condition body true wrt sj 1 head corresponding action literal exist P executable action set Aj ASP exists wrt sj 1 All rules Pj corresponding causal rules alwayssection P satisﬁed Xj Xj 1 literals translated afterparts So causal rule P afterpart false wrt Aj sj 1 causal rule satisﬁed state sj sSP j Finally XG exists goal_reached true Hence body rule generated Step 6 true si establish goal P In total shown answer set S lpP optimistic plan P exists witnessing trajectory constructed S described j 4 Secure planning The translation previous section results logic programs projections answer sets positive actions correspond optimistic plans As mentioned DLVK provides functionality checking given optimistic plan secure certain planning domains Thus secure plan steps follows Find optimistic plan P ii check P secure The test ii informally amounts testing following conditions 1 actions P executable respective stages execution 2 stage executing respective actions P leads legal successor state 3 goal true possible state reached steps plan successfully executed In arbitrary planning domains security check P 2 complete 64 widely believed complexity hypotheses polynomially reducible SAT solver computational logic expressiveness bounded NP coNP However shown 6 polynomial reduction possible class proper propositional planning problems planning problem P proper underlying planning domain PD proper given state s set actions A deciding legal state transition cid5s A scid10cid6 exists possible polynomial time 4 Ie cocid2P 2 complete cf 36 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 179 In DLVK focused proper propositional planning domains implemented security checking polynomial reduction logic programs complexity coNP Note proper planning domain PD algorithm APD given arbitrary state s set actions A decides polynomial time legal transition cid5s A scid10cid6 exists The existence algorithm APD given PD difﬁcult decide propositional case APD efﬁciently constructible widely accepted complexity beliefs We looked suitable semantic properties planning domains ensured syntactic conditions enable simple trivial check existence legal transition cid5s A scid10cid6 uniformly works class accepted planning domains 41 falsecommitted domains security check SC1 One condition informally existence legal transition cid5s A scid10cid6 blocked causal rule head false implicit consistency constraint f f That constraints disregarded legal transition cid5s A scid10cid6 exists constraint violated scid10 legal transition cid5s A scid10cid6 exists This condition ensured syntactic condition employs stratiﬁcation causation rules With mind develop security check SC1 given optimistic plan P cid5A1 Ancid6 length n cid1 0 planning problem P rewrites logic program lpP Section 3 logic program Π1P P returns yes program answer set The modiﬁcations follows In order check condition 1 mentioned beginning section rules resulting executability conditions removed lpP Instead executability condition form executable aX B1Y1 BmYm Bm1Ym1 BnYn P generate following rule ac Aj 1 j 0 n 1 P σ substitution mapping variables X c cid5 σ aX j B1Y1 j BmYm j Bm1Ym1 j BnYn j nextj j 1 cid6 This enforces action ac plan P executable respective state j ac j derived Π1P P actions derived To guarantee actions plan P executable add rule notex ac j ac Aj 1 Here notex new auxiliary predicate intuitively expresses plan P properly executed truth allows building witness insecurity P 180 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 Concerning condition 2 situation causal rule head false violated ﬂuent inconsistency arises answer set witnessing insecurity P generated To end transformation modiﬁed follows Each constraint Body timeT1 lpP derived causal rule form caused false rewritten notex Body timeT1 T1 0 σ Body σ substitution mapping T1 0 Observe violation constraints referring initial state generate counterexample Each constraint Body nextT0 T1 lpP derived causal rule caused false rewritten notex Body nextT0 T1 And ﬂuent f X implicit consistency constraint discussed Footnote 2 transformed rule noninitial states notex f X T1 f X T1 timeT1 T1 0 initial state remain unchanged f X 0 f X 0 Constraint violations explicit implicit noninitial states lead witnessing answer set containing notex Finally condition 3 goal constraint goal_reached modiﬁed goal_reached notex We read rewritten goal constraint follows The constraint satisﬁed plan P secure notex true means action P executed constraint violated executing actions P ii goal_reached false means successfully executing actions P goal established Before state informal conditions security check SC1 works precisely need auxiliary concepts Deﬁnition 41 Constraintfree constraint executabilityconditionfree shadow For planning domain PD cid5Π cid5D Rcid6cid6 let cfsPD denote planning domain results PD dropping causal constraints head false interpreting negative ﬂuents new positive ﬂuents constraintfree shadow PD Furthermore let cefsPD denote planning domain derived cfsPD omitting executability conditions adding executable legal action instance constraint executabilityconditionfree shadow PD Deﬁnition 42 falsecommitted planning domains We planning domain PD falsecommitted following conditions hold T Eiter et al Artiﬁcial Intelligence 144 2003 157211 181 If s legal state PD A action set executable s wrt PD i1 legal transition cid5s A scid10cid6 cfsPD legal transition PD i2 cid5s A scid10cid10cid6 legal transition PD states scid10cid10 PD ii For state s action set A cefsPD exists legal transition cid5s A scid10cid6 cefsPD Example 41 Blocksworld incomplete initial state continued Let reconsider blocksworld planning problem Example 23 It easily seen formulation respective planning domain PDbwi falsecommitted Indeed contains single occurrence default negation statement inertial onBL critical existence successor state cefsPD condition ii guaranteed As condition state s action set A executable s single legal transition cid5s A scid10cid6 cfsPDbwi cases i1 i2 apply Consider ﬁrst optimistic plan P secure seen cid2 moved table moved b movec d movea c cid1 build answer set S Π1Pbwi P fails starting Indeed attempt initial state actions Ai executable constraint vio lated notex included S To satisfy rewritten goal constraint goal_reachednot notex goal_reached included atoms onac2 oncd2 ondb2 S However easily seen onbtable2 included S This means goal_reached included S contradiction Thus answer set S exists means plan P secure Let modify number steps goal 2 consider optimistic plan P cid1 movec d movea c cid2 In case build answer set Π1Pbwi P starting initial state block d table including stage literals enforced Then actions plan executed end state goal satisﬁed Both goal_reached notex derived constraint goal_reached notex Π1Pbwi P satisﬁed admitting answer set witnesses insecurity P Hence check outputs plan secure To security check SC1 works properly falsecommitted planning domains need notions soundness completeness security checks Deﬁnition 43 Security check A security check class planning domains PD algorithm takes input planning problem P planning domain class PD optimistic plan P P outputs yes A security check sound reports yes P secure plan P complete reports yes case P secure plan P 182 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 In words sound security check yes trusted complete security check trusted Theorem 41 The security check SC1 sound complete class false committed planning domains Proof We outline proof omit details Let P cid5A1 Ancid6 optimistic plan planning problem P falsecommitted planning domain PD Soundness Suppose P secure This means initial state s0 trajectory T cid5cid5s0 A1 s1cid6 cid5sj 1 Aj sj cid6cid6 PD 0 cid2 j cid2 n exist conditions 13 plan security stated beginning section violated We build answer set S program Π1P P starting s0 respective literals included correspond legal transitions T lpP We consider cases Suppose ﬁrst condition 1 violated action ac action set Aj P executable Then rule head ac j ﬁres add notex S derived rule notex ac j By ii false committedness PD add literals stages j 1 n modeling transitions cefsPD S obtain answer set Π1P P Suppose condition 2 violated successor state exists By ii falsecommittedness PD add literals S modeling legal transition cid5sj Aj 1 sj 1cid6 cfsPD falsecommittedness PD notex derived PD rule head false ﬁres opposite ﬂuent literals f f S Using ii add literals remaining stages j 2 n modeling transitions cefsPD obtain answer set S Π1P P Suppose ﬁnally condition 3 violated That j n goal satisﬁed sn Then rule head goal_reached applicable modiﬁed goal constraint satisﬁed answer set S exists Note includes case n 0 In cases answer set S Π1P P exists SC1P P outputs Completeness Suppose SC1P P outputs Π1P P answer set S Then notex S goal_reached S hold In case notex derived rule r notex ac j b rule notex timej corresponding rewritten constraint head false consistency constraint strong negation Let r j minimal Then S encodes respect stages 0 j 1 trajectory T cid5cid5s0 A1 s1cid6 cid5sj 1 Aj sj cid6cid6 Aj 1 executable sj wrt PD In case immediately obtain condition 1 security violated P secure In case b trajectory T cid5cid5s0 A1 s1cid6 cid5sj 2 Aj 1 sj 1cid6cid6 PD exists executing Aj sj 1 wrt cfsPD encoded S leads state sj violates constraint PD head false contains opposite literals By item falsecommittedness PD conclude legal transition cid5sj 1 Aj sj cid6 exists PD violates condition 2 security On hand goal_reached S notex S S encodes trajectory T Eiter et al Artiﬁcial Intelligence 144 2003 157211 183 T cid5cid5s0 A1 s1cid6 cid5sn1 An sncid6cid6 wrt PD ﬁnal state sn goal false condition 3 security violated That cases P secure Now introduced class falsecommitted planning domains look syntactic conditions planning domains efﬁciently checked guarantee falsecommittedness One condition obtained imposing stratiﬁcation causation rules follows For causation rule r form A2 let lpr corresponding logic programming rule f b1 bk bk1 bl emerges skipping afterpart Deﬁnition 44 Stratiﬁed planning domain A planning domain PD cid5Π cid5D Rcid6cid6 stratiﬁed logic program ΠPD consisting rules lpr r CR hr cid20 false nonempty ifpart stratiﬁed usual sense strongly negated atoms treated new atoms For example blocksworld planning domain PDbwi described stratiﬁed It easy stratiﬁed planning domains falsecommitted Indeed stratiﬁed logic program guaranteed answer set item ii Deﬁnition 42 holds Furthermore legal state s action set A executable s wrt PD exists single candidate state scid10 legal transition cid5s A scid10cid6 cfsPD computed evaluating subset rules ΠPD transition legal PD scid10 violates constraint CR head false introduces inconsistency Note stratiﬁed planning domains PD proper Corollary 42 The security check SC1 sound complete class stratiﬁed planning domains A possible extension Corollary 42 allows limited usage unstratiﬁed causation rules For example pairs inertial f inertial f positive negative inertia rules ground ﬂuent f rules r f r f caused f f f caused f f f violate stratiﬁcation Nevertheless pairwise inertia ﬂuent f allowed safely rules remainder planning domain stratiﬁed That check stratiﬁcation subdomains result planning domain PD omitting positive negative inertia rules f denoted PDf PDf respectively If PDf PDf stratiﬁed SC1 sound complete PD This holds state s rules r f active respect s f r 184 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 We extend multiple pairs ground inertia rules combinations positive negative inertia rules checked We step extend muxstratiﬁed planning domains deﬁne Two causation rules r0 r1 PD mutually exclusive pair muxpair afterparts simultaneously satisﬁable state s executable action set A wrt s PD Deﬁnition 45 Muxstratiﬁed planning domains Let PD planning domain E ri0 ri1 1 cid2 cid2 n n cid1 0 set muxpairs PD Then PD called mux stratiﬁed wrt E planning domain PDcid10 results PD removing rules ri0 ri1 1 n stratiﬁed Notice E necessarily contain muxpairs occurring PD choose E muxstratiﬁed coincides stratiﬁed planning domain Note E induces bipartite graph GE vertices rules occurring E edges pairs E The removal sets building PDcid10 need considered given maximal independent sets GE There exponentially sets cost simple muxstratiﬁcation testing grows fast We establish following result Theorem 43 Every planning domain PD muxstratiﬁed wrt set mux pairs E falsecommitted Proof Consider state s executable action set A wrt s PD Denote actives A PD set ground rules groundΠPD correspond instances r cid10 causation rules PD afterpart r cid10 true wrt s A answer set M background knowledge Then claim actives A PD stratiﬁed ground dependency graph contain negative cycle Indeed contradiction assume ground dependency graph actives A PD contains negative cycle C Then C involves rules correspond instances causation rules occurring E rules correspond instances causation rules r1i1 rnin E ri0 ri1 1 cid2 cid2 n ij 0 1 j 1 n A rule R involved edges l1 l2 dependency graph l1 H R l2 BR This means C present ground dependency graph ΠPDcid10 PDcid10 results PD removing causation rules r111j r112j rn1nj Consequently nonground dependency graph ΠPDcid10 contains negative cycle This contradicts PD muxstratiﬁed wrt E claim proved Since ground program actives A PD stratiﬁed easily seen conditions ii falsecommittedness hold s Since s arbitrary follows PD falsecommitted By combining Theorems 41 43 obtain following corollary T Eiter et al Artiﬁcial Intelligence 144 2003 157211 185 Corollary 44 The security check SC1 sound complete class muxstratiﬁed planning domains particular E consists opposite ground inertialrules The DLVK provides limited support testing muxstratiﬁcation currently works set E consisting opposite ground inertia rules extension larger classes planned future DLVK releases Notice deciding given pair r0 r1 muxpair given planning domain intractable general A generalization result Corollary 44 sets E nonground opposite inertial rules fails The reason case multiple transition candidates cid5s A scid10cid6 exist cfsPD general correspond multiple answer sets program actives A PD However legal PD condition falsecommittedness violated Preliminary results suggest restrictions like excluding constraints causation rules opposite uniﬁable heads SC1 applied We leave work 42 Serial planning domains security check SC2 Besides SC1 DLVK provides alternative security check SC2 handling classes proper planning domains design easily allows incorporation security checks The check SC2 obtained slight modiﬁcation program clauses Π1PD P resulting program Π2PD P follows head notex rule stems causal rule r hr false ifpart shifted negative body notex Body rewritten Body notex Informally shift means violation constraint successor state scid10 tolerated eliminate scid10 counterexample security plan We check works following class planning domains Deﬁnition 46 Serial planning domains A planning domain PD serial following properties s state PD A executable s wrt PD legal transition cid5s A scid10cid6 guaranteed exist ii state s set actions A cefsPD legal transition cid5s A scid10cid6 exists wrt cefsPD Obviously serial planning domains PD proper check APD telling legal transition exists s executable A trivial return yes The following observed 186 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 Theorem 45 The security check SC2 sound complete serial planning domains The proof result similar proof Theorem 41 omit A syntactical restriction guaranteeing seriality stratiﬁed planning domains PD contain rules r hr false employ strong negation The serial property preserved allow arbitrary totalization statements limited use strong negation occurrences ﬂuent strongly negated Note planning domains falsecommitted general The security check SC2 works generalizations serial planning domains For example safely add rules r form caused false B Furthermore SC2 proﬁtably combined SC1 order enlarge classes security checking supported 43 Incomplete security checking We combine fast security checks sound security checks complete obtain checks return correct answer possible leave answer open This similar use incomplete constraint solvers constraint programming return yes unknown queried satisﬁability constraint obvious requirement answer returned contradict correct result Suppose suite security checks SC1 SCn SC1 SCj j cid2 n known sound class planning domains PD SCk SCn k cid2 n known complete PD Then combine following test T cid7 T P P yes unknown SCiP P yes 1 j SCiP P k n Observe yes case T SCiP P yes hold k n symmetrically case SCiP P 1 j checking integrity sound respectively complete security checks involved Note use dummy complete security check reports yes input By merging unknown case case combine sound security checks SC1 SCj powerful sound security check SC class PD In particular SC1 SCj known exhaust secure plans SC sound complete security check PD To account results section addition commandline options FP FPopt FPsec seen Section 23 DLVK provides options controlling security checking FPcheckn n 1 2 correspond SC1 SC2 current implementation selects security check FPsoundcheckn FPcompletecheckn n 1 2 specify security check known sound complete respectively input domain The incorporation builtin security checks support userdeﬁned security checks planned future T Eiter et al Artiﬁcial Intelligence 144 2003 157211 187 5 Comparison experiments In following compare DLVK stateoftheart conformant planning systems report experimental results performance The results presented mainly intended momentary view state current implementation DLVK capabilities To end present extensive benchmark results compare expressive power ﬂexibility systems 51 Overview compared systems 511 CCALC The Causal Calculator CCALC model checker languages causal theories 30 It translates programs action language C language causal theories turn transformed SAT problems literal completion described 31 This approach based Satisﬁability Planning 22 planning problems reduced SAT problems solved means efﬁcient SAT solver like SATO 48 relsat 1 Though input language allows nondeterminism initial state nondeterministic action effects CCALC capable conformant planning computes optimistic plans according DLVK terminology Plan length ﬁxed sequential concurrent planning supported CCALC written Prolog For tests version 190 CCALC obtained URLhttpwwwcsutexaseduuserstagcc trial version SICStus Prolog 386 tested SATO 321 relsat 112 On instances SATO solve signiﬁcantly faster relsat relsat instances SATO solve experiments 512 CMBP The Conformant Model Based Planner 4 based model checking paradigm relies symbolic techniques BDDs CMBP allows sequential planning Its input language extension AR 16 Unlike action languages C K language supports propositional actions Nondeterminism allowed initial state action effects The length computed plans minimal user declare upper bound commandline option pl If pl set equal minimal plan length speciﬁc problem ﬁx plan length advance We method comparable DLVK currently deal ﬁxed plan length For tests CMBP 10 available URLhttpsraitcitpeopleroveri cmbp 513 CPlan Introduced 1015 CPlan conformant planner based CCALC C action language 172629 This language similar K respects close classical logic K logic programming oriented use default negation 188 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 6 discussion CPlan uses CCALC generate SAT instance replaces optional SATsolvers CCALC procedure extracts conformant plans SAT instances CPlan implements conformant planning supports computation minimal length plans plans ﬁxed length incrementing plan length given lower bound plan given upper bound reached We set upper lower bound equal minimal plan length speciﬁc problems experiments comparable DLVK Sequential concurrent planning possible nondeterminism allowed initial state action effects For tests CPlan 130 available URLhttpfregemrgdist unigeitottocplanhtml CCALC 190 produce input CPlan 514 GPT The General Planning Tool 3 employs heuristic search techniques like A search belief space Its input language subset PDDL Nondeterminism allowed initial state action effects GPT supports sequential planning calculates plans minimal length We version GPT 114 obtained URLhttpwwwcsuclaedubonet software 515 SGP In addition conformant planning Sensory Graphplan SGP 47 deal sensing actions SGP extension Graphplan algorithm 2 Its input language extension PDDL 14 Nondeterminism allowed initial state The program calculates plans minimal length5 SGP support sequential planning computes concurrent plans automatically recognizing mutually exclusive actions That means minimal length plans terms SGP plans minimal number actions minimal number steps needed At step arbitrary number parallel actions allowed long preconditions effects mutually exclusive automatically detected algorithm SGP written LISP available URLhttpwwwcswashingtoneduaisgp html For tests trial version Allegro Common Lisp 60 516 Speciﬁc features We like point speciﬁc features special purpose planning systems SGP automatically recognizes mutually exclusive actions concurrent plans It possible encode concurrent plans DLVK explicitly describing mutually exclusive actions encodings bomb toilet benchmark problems multiple toilets Section 522 However language K 5 SGP comprises functionality Smith Weld called CGP Conformant Graphplan 42 slower general As CGP longer maintained available online decided choose SGP experiments T Eiter et al Artiﬁcial Intelligence 144 2003 157211 189 Table 1 Overview features Input language Sequential plans Concurrent plans Optimistic plans Conformant plans K DLV K yes yes yes yes CCALC C CPlan C CMBP AR SGP GPT PDDL PDDL yes yes yes yes yes yes yes yes yes yes yes yes yes yes Minimal plan length Fixed plan length An upper bound speciﬁed computed plans minimal yes noa yes yes yes yes complex PDDL makes automatic recognition possible conﬂicts actions harder framework On hand notions executability nonexecutability allow ﬂexible encodings parallel actions SGP GPT SGP compute minimal plans possible current version DLVK CMBP CPlan optionally compute minimal plans user specify upper andor lower bounds plan length Table 1 provides comparison DLVK systems introduced Note CCALC capable conformant planning use respective benchmark problems On hand CPlan showed slow performance deterministic planning benchmarks considered Therefore considered systems combination CCALC deterministic planning benchmarks CPlan conformant planning benchmarks 52 Benchmark problems encodings 521 Blocksworld For benchmarking chosen blocks world instances illustrate performance DLVK deterministic domains Problems P1P4 8 problem P5 slight modiﬁcation P4 needs moves The initial conﬁgurations respective goal conﬁgurations P1P5 minimum number moves steps needed solve problems shown Fig 7 522 Bomb toilet To capabilities DLVK planning incomplete information particular conformant planning chosen wellknown bomb toilet problem 34 variations thereof employ naming convention 4 The respective planning domain comprises actions nondeterministic effects initial state incomplete elaborated versions actions available parallel 190 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 Fig 7 Blocksworld planning instances BTpBomb toilet p packages The basic scenario bomb toilet problem follows We alarmed bomb exactly lavatory There p suspicious packages contain bomb There toilet bowl possible dunk package If dunked package contained bomb bomb disarmed safe state reached The obvious goal reach safe state secure plan BTCpBomb toilet certain clogging In slightly elaborated version dunking package clogs toilet making dunking impossible The toilet unclogged ﬂushing The toilet assumed unclogged initially Note domain comprises deterministic action effects BTUCpBomb toilet uncertain clogging In elaboration domain dunking package nondeterministic effect status toilet clogged clogged BMTCpt BMTUCptBomb toilet multiple toilets Yet elabora tion toilet bowls t cid1 1 available lavatory 523 Encodings As far possible original encodings come distributions respective systems CCALCCPlan CCALC capable conformant planning CPlan proved slow deterministic domains Thus blocksworld problems P1P5 C encoding provided Esra Erdem pure CCALC 8 CPlan bomb toilet problems slight modiﬁcations C encodings provided current CPlan distribution T Eiter et al Artiﬁcial Intelligence 144 2003 157211 191 CMBP For CMBP bomb toilet encodings included distribution BMTUCp t included trivial modiﬁcation BMTCp t needed obtain encoding BMTUC Because propositional actions allowed input language CMBP encoding blocks world different moves possible large As encoding included examples straightforward encoding P1 comparison Section B1 Appendix B GPT The distribution GPT provides encodings bomb toilet problems BMTUCp t included respective extension BTUCp trivial For blocksworld adapted version SGP encoding PDDL dialects systems slightly differ The encoding P1 appendix SGP For SGP blocks world bomb toilet encodings coming distribution BTUCp BMTUCp t encoded SGP allows nondeterminism initial state SGP generates concurrent plans compare sequential versions BTp BMTCp t Furthermore blocks world problems means minimal plan lengths differ K encodings provide extra column Table 2 Note number actions plans computed SGP necessarily minimal For example P3 plan 4 steps 9 moves exists SGP ﬁnds plan 4 steps 12 moves DLVK We tested bomb toilet problems different encodings DLVK developed 6 The ﬁrst labeled ws results mimics worldstate planning different completions states totalizations worldstates considered The second labeled ks uses power knowledgestate planning provided DLVK complete states right away leaves value unknown ﬂuents open accordance real knowledge planning agent state affairs In encodings ﬁrst consider concurrent actions action time Since blocksworld problems conformant planning instances use optimistic planning For knowledgestate encoding bomb toilet problems applicability security check SC1 straightforward BTUCp BMTUCp t domains muxstratiﬁed wrt inertia rules clogged clogged ﬂuents occur bodies causation rules Furthermore thanks knowledgestate representation domains deterministic unique initial states security check trivial negligible timing The worldstate encodings BTp BTCp BMTCp t stratiﬁed security check SC1 guaranteed sound complete problems Corollary 42 In case BTUCp BMTUCp t worldstate programs macro total violates stratiﬁcation However BTUCp BMTUCp t falsecommitted domains security check SC1 sound complete problems Theorem 45 Indeed respective programs cycle odd number negative arcs dependency graphs cf BMTUCp t 192 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 Appendix C1 BTUCp t BMTUCp t dependency graph difference ﬂuents additional argument 6 known results answer set guaranteed condition ii false committedness holds Furthermore constraints resulting expanding nonexecutable statements Since constraints refer actions scid10 transition cid5s A scid10cid6 satisfy scid10 Therefore condition false committedness enforced The worldstate encodings bomb toilet deterministic security check responsible considerable portion timings 53 Benchmark results discussion In section compare systems terms representation capabilities runtime benchmarks 531 Test environment All tests performed Pentium III 733 MHz machine 256 MB main memory running SuSE Linux 64 The results blocks world problems summarized Table 2 Tables 39 results bomb toilet problems The minimal plan length reported second column table Note CCALC results include 123 s startup time SICStus Prolog SGP 027 s startup time included Runtimes longer 1200 CPU seconds omitted indicated dash tables 532 Representation From viewpoint expressiveness language K allows compact readable encoding AR PDDL dialects CMBP allows propositional actions Appendix B1 blocks world encoding AR languages like C K allow elegant encoding complex actions PDDL dialects GPT SGP hand allow expressing ramiﬁcations makes encoding Table 2 Experimental results blocksworld problems P1P5 Problem Steps Blocks K DLV CCALC CMBP GPT SGP stepsactionsa time 4 6 8 9 11 P1 P2 P3 P4 P5 As SGP supports concurrent planning number steps number actions solutions 173 s 218 s 542 s 1583 s 35043 sb 969 s 4385 s 24845 s 004 s 011 s 881 s 891 s 2114 s 113 s 252 s 018 s 795 s 34 57 412 4 5 8 11 11 displayed extra column Note number actions necessarily minimal b With CCALC SATO solution P5 timing P5 generated relsat signiﬁcantly slower problem instances T Eiter et al Artiﬁcial Intelligence 144 2003 157211 193 Table 3 Experimental results BTp concurrent dunks BTp Steps K DLV CPlan SGP BT2 BT3 BT4 BT5 BT6 BT7 BT8 BT9 BT10 BT11 BT12 BT13 BT14 BT15 BT16 BT17 BT18 BT19 BT20 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ws ks 001 s 002 s 001 s 002 s 002 s 002 s 002 s 001 s 002 s 002 s 002 s 003 s 003 s 003 s 003 s 003 s 003 s 003 s 004 s 001 s 001 s 001 s 001 s 001 s 001 s 001 s 002 s 002 s 002 s 002 s 002 s 001 s 001 s 001 s 002 s 002 s 002 s 002 s 138 s 138 s 139 s 142 s 147 s 156 s 179 s 229 s 341 s 604 s 1198 s 2528 s 5771 s 12775 s 29444 s 67819 s 069 s 080 s 095 s 121 s 155 s 200 s 256 s 332 s 427 s 534 s 666 s 816 s 998 s 1211 s 1457 s 1743 s 2074 s 2447 s 2878 s Table 4 Experimental results BTp sequential Tp Steps K DLV CPlan CMBP GPT BT2 BT3 BT4 BT5 BT6 BT7 BT8 BT9 BT10 BT11 BT12 BT13 BT14 BT15 BT16 BT17 BT18 BT19 BT20 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ws 002 s 003 s 011 s 150 s 2878 s 59315 s ks 002 s 002 s 002 s 003 s 003 s 003 s 005 s 006 s 008 s 010 s 013 s 016 s 021 s 028 s 035 s 047 s 061 s 078 s 098 s 137 s 139 s 139 s 145 s 181 s 512 s 6585 s 003 s 004 s 004 s 004 s 004 s 005 s 006 s 007 s 010 s 019 s 039 s 082 s 176 s 400 s 882 s 1903 s 3895 s 9189 s 19963 s 056 s 055 s 061 s 061 s 063 s 067 s 068 s 078 s 095 s 127 s 212 s 389 s 887 s 1913 s 4217 s 9369 s 20800 s 49695 s 54643 s 194 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 Table 5 Experimental results BTCp BTCp Steps K DLV CPlan CMBP GPT SGP BTC2 BTC3 BTC4 BTC5 BTC6 BTC7 BTC8 BTC9 BTC10 BTC11 BTC12 BTC13 BTC14 BTC15 BTC16 BTC17 BTC18 BTC19 BTC20 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 38 39 ws 002 s 008 s 156 s 3628 s ks 001 s 002 s 002 s 003 s 004 s 006 s 008 s 011 s 014 s 020 s 026 s 034 s 045 s 058 s 074 s 094 s 117 s 146 s 180 s 137 s 139 s 139 s 236 s 2895 s 17897 s 004 s 004 s 005 s 005 s 006 s 007 s 012 s 021 s 039 s 081 s 172 s 379 s 882 s 1692 s 4292 s 9203 s 19785 s 059 s 060 s 060 s 062 s 066 s 068 s 074 s 081 s 104 s 148 s 251 s 468 s 1084 s 2331 s 5140 s 11421 s 27325 s 37400 s 092 s 330 s 19160 s Table 6 Experimental results BTUCp BTUCp Steps K DLV CPlan CMBP GPT BTUC2 BTUC3 BTUC4 BTUC5 BTUC6 BTUC7 BTUC8 BTUC9 BTUC10 BTUC11 BTUC12 BTUC13 BTUC14 BTUC15 BTUC16 BTUC17 BTUC18 BTUC19 BTUC20 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 38 39 ws 003 s 061 s 8754 s ks 002 s 002 s 003 s 003 s 004 s 005 s 008 s 010 s 014 s 019 s 025 s 033 s 043 s 055 s 071 s 090 s 115 s 141 s 174 s 135 s 145 s 193 s 248 s 5172 s 003 s 004 s 004 s 006 s 006 s 007 s 012 s 020 s 039 s 080 s 172 s 379 s 881 s 1694 s 4293 s 9202 s 19784 s 059 s 060 s 061 s 066 s 065 s 074 s 075 s 088 s 118 s 181 s 318 s 642 s 1443 s 3225 s 7110 s 15953 s 36812 s T Eiter et al Artiﬁcial Intelligence 144 2003 157211 195 Table 7 Experimental results BMTCp concurrent dunks BMTCp t Steps K DLV CPlan SGP BMTC2 2 BMTC3 2 BMTC4 2 BMTC5 2 BMTC6 2 BMTC7 2 BMTC8 2 BMTC9 2 BMTC10 2 BMTC2 3 BMTC3 3 BMTC4 3 BMTC5 3 BMTC6 3 BMTC7 3 BMTC8 3 BMTC9 3 BMTC10 3 BMTC2 4 BMTC3 4 BMTC4 4 BMTC5 4 BMTC6 4 BMTC7 4 BMTC8 4 BMTC9 4 BMTC10 4 1 3 3 5 5 7 7 9 9 1 1 3 3 3 5 5 5 7 1 1 1 3 3 3 3 5 5 ws 002 s 004 s 011 s 279 s 3704 s 002 s 002 s 008 s 035 s 1781 s 22331 s 002 s 002 s 003 s 018 s 529 s 6173 s 66874 s ks 001 s 002 s 003 s 004 s 007 s 052 s 1066 s 20627 s 002 s 002 s 003 s 003 s 006 s 013 s 074 s 590 s 38908 s 002 s 002 s 002 s 004 s 005 s 009 s 041 s 106 s 1214 s 141 s 150 s 172 s 337 s 1304 s 7150 s 162 s 231 s 481 s 1355 s 4334 s 21071 s 41762 s 289 s 919 s 3755 s 15874 s 57177 s 095 s 340 s 717 s 115 s 176 s 1501 s 7628 s 59241 s 152 s 234 s 371 s 37274 s action effects readable elaboration tolerant Appendix B2 GPT encoding blocksworld Similar remarks apply bomb toilet problems K allows compact time intuitive encodings 533 Performance The running times blocksworld instances Table 2 DLVK signiﬁcantly faster systems action instances Under worldstate encodings different bomb toilet instances DLVK competitive BTp concurrent dunks plan length 1 BMTCp This indicates DLVKs performance sensitive increasing plan length especially sequential planning Still DLVK outperforms SGP special purpose planning comparable instances CPlan comparable DLVK terms expressiveness similar nature reach 196 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 Table 8 Experimental results BMTCp sequential BMTCp t Steps K DLV CPlan CMBP GPT BMTC2 2 BMTC3 2 BMTC4 2 BMTC5 2 BMTC6 2 BMTC7 2 BMTC8 2 BMTC9 2 BMTC10 2 BMTC2 3 BMTC3 3 BMTC4 3 BMTC5 3 BMTC6 3 BMTC7 3 BMTC8 3 BMTC9 3 BMTC10 3 BMTC2 4 BMTC3 4 BMTC4 4 BMTC5 4 BMTC6 4 BMTC7 4 BMTC8 4 BMTC9 4 BMTC10 4 2 4 6 8 10 12 14 16 18 2 3 5 7 9 11 13 15 17 2 3 4 6 8 10 12 14 16 ws 002 s 007 s 247 s 20852 s 002 s 003 s 184 s 29124 s 002 s 041 s 060 s 14965 s ks 002 s 002 s 004 s 005 s 007 s 010 s 013 s 020 s 028 s 002 s 002 s 003 s 006 s 009 s 025 s 1542 s 002 s 002 s 003 s 006 s 010 s 015 s 047 s 6707 s 141 s 150 s 164 s 266 s 3277 s 1246 s 150 s 185 s 286 s 592 s 1450 s 4041 s 202 s 367 s 903 s 3055 s 19973 s 004 s 005 s 006 s 006 s 009 s 012 s 023 s 048 s 096 s 004 s 004 s 006 s 009 s 014 s 030 s 062 s 144 s 331 s 004 s 005 s 007 s 013 s 023 s 051 s 113 s 294 s 638 s 076 s 078 s 081 s 082 s 086 s 096 s 111 s 148 s 226 s 076 s 081 s 084 s 090 s 099 s 117 s 166 s 279 s 564 s 081 s 083 s 092 s 101 s 127 s 185 s 334 s 718 s 1734 s Under knowledgestate encodings DLVK outperforms competitors chosen examples The sensitivity increasing plan lengthsearch space partly observed execution times grow drastically instance This partly explained general heuristics underlying DLV scale cases For instance DLV general purpose problem solver include special heuristics plan search In particular answer set generation process distinction actions ﬂuents useful planning tasks control generation answer sets respectively plans investigations 534 Effect concurrent actions default negation Once consider concurrent actions supported GPT CMBP DLVK performs better CPlan larger instances BMTCp t BMTUCp t Tables 7 9 Using expressive power default negation express unknown ﬂuents knowledgestate encodings bomb toilet K pays DLVK outperforms T Eiter et al Artiﬁcial Intelligence 144 2003 157211 197 Table 9 Experimental results BMTUCp concurrent dunks BMTUCp t Steps K DLV BMTUC2 2 BMTUC3 2 BMTUC4 2 BMTUC5 2 BMTUC6 2 BMTUC7 2 BMTUC8 2 BMTUC9 2 BMTUC10 2 BMTUC2 3 BMTUC3 3 BMTUC4 3 BMTUC5 3 BMTUC6 3 BMTUC7 3 BMTUC8 3 BMTUC9 3 BMTUC10 3 BMTUC2 4 BMTUC3 4 BMTUC4 4 BMTUC5 4 BMTUC6 4 BMTUC7 4 BMTUC8 4 BMTUC9 4 BMTUC10 4 1 3 3 5 5 7 7 9 9 1 1 3 3 3 5 5 5 7 1 1 1 3 3 3 3 5 5 ws 002 s 011 s 739 s 002 s 002 s 028 s 3409 s 002 s 002 s 003 s 084 s 74890 s ks 002 s 003 s 003 s 004 s 007 s 080 s 2357 s 81823 s 002 s 002 s 003 s 003 s 005 s 010 s 074 s 955 s 69399 s 002 s 002 s 002 s 004 s 005 s 008 s 055 s 098 s 1789 s CPlan 140 s 206 s 354 s 818 s 78758 s 155 s 1027 s 4103 s 18145 s 60066 s 254 s 11918 s 58284 s systems including special purpose conformant planners GPT CMBP sequential BMTCp t BMTUCp t toilets Tables 8 10 CMBP fastest 535 Summary experimental results Overall results indicate DLVK competitive state art conformant planners especially exploiting K language features terms knowledgestate problem encodings Recall systems compute minimal plans currently supported DLVK The comparison DLVK CCALCCPlan particularly relevant systems closest spirit DLVK As advanced features knowledgestate encoding lead signiﬁcant performance improvements 198 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 Table 10 Experimental results BMTUCp sequential BMTUCp t Steps K DLV CPlan CMBP GPT BMTUC2 2 BMTUC3 2 BMTUC4 2 BMTUC5 2 BMTUC6 2 BMTUC7 2 BMTUC8 2 BMTUC9 2 BMTUC10 2 BMTUC2 3 BMTUC3 3 BMTUC4 3 BMTUC5 3 BMTUC6 3 BMTUC7 3 BMTUC8 3 BMTUC9 3 BMTUC10 3 BMTUC2 4 BMTUC3 4 BMTUC4 4 BMTUC5 4 BMTUC6 4 BMTUC7 4 BMTUC8 4 BMTUC9 4 BMTUC10 4 2 4 6 8 10 12 14 16 18 2 3 5 7 9 11 13 15 17 2 3 4 6 8 10 12 14 16 ws 002 s 052 s 26420 s 002 s 004 s 7103 s 001 s 078 s 581 s ks 002 s 002 s 004 s 005 s 007 s 010 s 014 s 021 s 027 s 002 s 003 s 004 s 005 s 008 s 021 s 1339 s 002 s 002 s 004 s 006 s 009 s 013 s 042 s 6402 s 139 s 196 s 337 s 36164 s 149 s 647 s 2207 s 15072 s 193 s 4170 s 18292 s 83733 s 004 s 004 s 005 s 006 s 008 s 012 s 023 s 047 s 096 s 004 s 005 s 006 s 009 s 014 s 029 s 061 s 145 s 331 s 004 s 005 s 007 s 012 s 023 s 051 s 113 s 294 s 637 s 078 s 080 s 081 s 085 s 092 s 104 s 134 s 200 s 371 s 079 s 081 s 086 s 098 s 119 s 174 s 315 s 669 s 1557 s 079 s 086 s 097 s 133 s 223 s 479 s 1137 s 2807 s 6826 s 6 Further related work conclusion We discussed relation DLVK number planning systems Section 5 complement brieﬂy addressing approaches systems 61 Further related work The idea employ declarative logic programming systems planning ﬁnds roots seminal paper Subrahmanian Zaniolo 43 carried idea satisﬁability planning 22 framework declarative logic programming Planning incomplete knowledge widely investigated AI literature Most works extend algorithmssystems classical planning deduction techniques solving planning tasks proposed paper The systems Buridan 23 UDTPOP 37 Conformant Graphplan 42 CNLP 38 CASSANDRA 39 fall class In particular Buridan UDTPOP Conformant Graphplan solve secure planning called conformant planning problems like DLVK On hand T Eiter et al Artiﬁcial Intelligence 144 2003 157211 199 systems CNLP CASSANDRA deal conditional planning sequence actions executed depends dynamic conditions More recent works propose use automated reasoning techniques planning incomplete knowledge In 41 technique encoding conditional planning problems terms 2QBF formulas proposed The work 11 proposes technique based regression solving secure planning problems framework Situation Calculus presents Prolog implementation technique In 31 sufﬁcient syntactic conditions ensuring security optimistic plan singled While sharing logicbased nature work presented paper differs considerably proposals based different formalism 62 Summary In paper presented DLVK planning implements K action planning language introduced discussed companion paper 6 DLV logic programming In course shown transformation planning problems K logic programming In particular given transformation optimistic planning planning traditional sense discussed secure planning conformant planning realized certain classes planning problems transformation security checking logic programming Our transformations use disjunctions rule heads supported DLV easily adapted disjunctionfree available logic programming systems Smodels 35 Furthermore compared standard benchmark problems similar logicbased planning systems CCALC 3031 CPlan 1015 CMBP 4 GPT 3 SGP 47 We obtained promising performance results secure planning exploiting power knowledgestate problem encodings distinguishing feature K planning language As believe results present paper knowledgestate encoding planning problems conceptual conciseness natural appeal potential computational perspective 63 Further future work Enhancing improving DLVK planning ongoing effort There issues address current future research One issue discussed companion paper 6 development methodology proﬁtably knowledgestate planning approach Another issue concerns improvements enhanced capabilities secure planning We performed experiments different approach conformant answer set planning presented 24 In contrast plan security checking described paper sketches integrated encoding conformant planning domains In approach answer sets correspond secure plans checking necessary These results encouraging possible encode restricted class domains DLV In fact secure planning cid2P 3 complete 6 complexity arguments method efﬁciently extended planning domains 200 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 On hand security checking planning domains class P 2 polynomially encoded DLV However transformation remains designed generality Besides issues extended handling incomplete security checking described paper research consider builtin support userdeﬁned security checks Finally use DLV engine computational backbone suggests use ca pabilities enhance DLVK planning features In particular use weak constraints possible compute DLV optimal answer sets logic program This provides computational basis determining optimal plans planning problem plans minimize given objective function cost actions execution time To knowledge current logicbased planning systems offer comprehensive capabilities Enhancing K language DLVK opti mal planning agenda features included future DLVK releases Acknowledgements This work greatly beneﬁted interesting discussions comments Michael Gelfond Vladimir Lifschitz Riccardo Rosati Hudson Turner Furthermore grateful Claudio Castellini Alessandro Cimatti Esra Erdem Enrico Giunchiglia David E Smith Dan Weld kindly supplying explanations support comments systems comparison Furthermore appreciate review comments helped improve paper This work supported FWF Austrian Science Funds projects P14781INF Z29INF European Commission projects FET200137004 WASP IST200133570 INFOMIX Appendix A Deﬁnition language K This appendix contains shortened form deﬁnition language K 6 details examples A1 Basic syntax We assume σ act σ ﬂ σ typ disjoint sets action ﬂuent type names respectively predicate symbols arity cid1 0 disjoint sets σ σ var constant variable symbols Here σ ﬂ σ act dynamic knowledge σ typ describes static background knowledge An action respectively ﬂuent type atom form pt1 tn p σ act respectively σ ﬂ σ typ arity n t1 tn σ σ var An action respectively ﬂuent type literal l action respectively ﬂuent type atom negation alternatively true negation symbol We deﬁne l l l l atom A set L literals consistent L L Furthermore L respectively L set positive respectively negative literals L The set action respectively ﬂuent type literals denoted T Eiter et al Artiﬁcial Intelligence 144 2003 157211 201 Lact respectively Lﬂ Ltyp Furthermore Lﬂtyp Lﬂ Ltyp Ldyn Lﬂ L L Lﬂtyp L act act All actions ﬂuents declared statements follows Deﬁnition A1 Action ﬂuent declaration An action respectively ﬂuent declaration form pX1 Xn requires t1 tm act respectively p L p L t1 tm Ltyp m cid1 0 Xi occurs t1 tm A1 ﬂ X1 Xn σ var n cid1 0 arity p If m 0 keyword requires omitted Causation rules specify dependen cies ﬂuents ﬂuents actions Deﬁnition A2 Causation rule A causation rule rule short expression form caused f b1 bk bk1 bl a1 am1 A2 f Lﬂ false b1 bl Lﬂtyp a1 anL l cid1 k cid1 0 n cid1 m cid1 0 Rules n 0 static rules dynamic rules When l 0 respectively n 0 respectively omitted l n 0caused optional r b1 bk r am1 litr r accesses state We access parts causation rule r hr f post r bk1 bl pre post f b1 bl a1 Intuitively pre respectively actions happen r a1 pre r respectively post Special static rules speciﬁed initial states Deﬁnition A3 Initial state constraint An initial state constraint static rule form A2 preceded initially The language K allows conditional execution actions alternative executability conditions speciﬁed Deﬁnition A4 Executability condition An executability condition e expression form executable b1 bk bk1 bl A3 L act b1 bl L l cid1 k cid1 0 If l 0 executability unconditional skipped The parts e e b1 bk pre e bk1 bl lite accessed pre e refers state actions suitability b1 bl Intuitively pre evaluated Here state action execution involved For convenience deﬁne post e post e 202 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 All causal rules executability conditions satisfy following condition similar safety logic programs 46 Each variable defaultnegated type literal occur literal defaultnegated type literal No safety requested variables appearing literals The reason variables appearing ﬂuent action literals implicitly safe respective type declarations Notation For causal rule initial state constraint executability condition r ν post pre b deﬁne νr νr νr bsr postsr presr A11 Planning domains planning problems Deﬁnition A5 Action description planning domain An action description cid5D Rcid6 consists ﬁnite set D action ﬂuent declarations ﬁnite set R safe causation rules safe initial state constraints safe executability conditions A K planning domain pair PD cid5Π ADcid6 Π stratiﬁed Datalog program background knowledge safe cf 46 AD action description We PD positive default negation occurs AD Deﬁnition A6 Planning problem A planning problem P cid5PD qcid6 pair planning domain PD query q g1 gm gm1 gn A4 g1 gn Lﬂ variablefree n cid1 m cid1 0 cid1 0 denotes plan length A2 Semantics We start preliminary deﬁnition typed instantiation planning domain This similar grounding logic program difference correctly typed ﬂuent action literals generated Let PD cid5Π cid5D Rcid6cid6 planning domain let M unique answer set Π 12 Then θ pX1 Xn legal action respectively ﬂuent instance action respectively ﬂuent declaration d D form A1 θ substitution deﬁned X1 Xn θ t1 θ tm M By LPD denote set legal action ﬂuent instances The instantiation planning domain respecting type information follows Deﬁnition A7 Typed instantiation For planning domain PD cid5Π cid5D Rcid6cid6 typed instantiation given PD cid5Π cid5D Rcid6cid6 Π grounding Π σ R θ r r R θ 9r 9r set substitutions θ variables r σ litθ r Ldyn LPD LPD L ﬂ In words PD replace Π R ground versions rules atoms ﬂuent action literals agree declarations We PD cid5Π cid5D Rcid6cid6 ground Π R ground welltyped PD PD coincide T Eiter et al Artiﬁcial Intelligence 144 2003 157211 203 A21 States transitions Deﬁnition A8 State state transition A state wrt planning domain PD consistent set s Lﬂ litPD litPD legal ﬂuent instances negations A state transition tuple t cid5s A scid10cid6 s scid10 states A Lact litPD set legal action instances PD Observe state necessarily contain f f legal instance f ﬂuent s State transitions constrained deﬁnition legal state transitions We proceed analogy deﬁnition answer sets 12 considering ﬁrst positive involving positive planning domain general planning problems In follows assume PD cid5Π cid5D Rcid6cid6 welltyped ground planning domain M unique answer set Π For PD respective concepts deﬁned typed grounding PD Deﬁnition A9 Legal initial state A state s0 legal initial state positive PD s0 set wrt postc s0 M implies hc s0 initial state constraints static rules c R For positive PD state s set A L act called executable action set wrt s A exists executability condition e R pree Lﬂtyp s M pree L A Note deﬁnition allows act modeling dependent actions actions depend execution actions Deﬁnition A10 Legal state transition Given positive PD state transition t cid5s A scid10cid6 called legal A executable action set wrt s scid10 minimal consistent set satisﬁes causation rules wrt s A M That causation rule r R postr scid10 M ii prer Lﬂtyp s M iii prer Lact A hold hr cid20 false hr scid10 This extended general welltyped ground PD containing default negation GelfondLifschitz type reduction positive planning domain 12 Deﬁnition A11 Reduction Let PD ground welltyped planning domain let t cid5s A scid10cid6 state transition Then reduction PDt cid5Π cid5D Rt cid6cid6 PD t planning domain Rt obtained R deleting 1 r R post 2 default literals L L L remaining r R r scid10 M cid20 pre r s A M cid20 Note PDt positive ground We extend deﬁnitions follows Deﬁnition A12 Legal initial state executable action set legal state transition For planning domain PD state s0 legal initial state s0 legal initial state 204 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 PDcid5s0cid6 set A executable action set wrt state s A executable wrt s PDcid5sAcid6 state transition t cid5s A scid10cid6 legal legal PDt A22 Plans Deﬁnition A13 Trajectory A sequence state transitions T cid5cid5s0 A1 s1cid6 cid5s1 A2 s2cid6 cid5sn1 An sncid6cid6 n cid1 0 trajectory PD s0 legal initial state PD cid5si1 Ai sicid6 1 cid2 cid2 n legal state transitions PD If n 0 T cid5 cid6 s0 associated explicitly Deﬁnition A14 Optimistic plan A sequence action sets cid5A1 Aicid6 cid1 0 optimistic plan planning problem P cid5PD qcid6 trajectory T cid5cid5s0 A1 s1cid6 cid5s1 A2 s2cid6 cid5si1 Ai si cid6cid6 exists PD establishes goal g1 gm si gm1 gn si Optimistic plans plans valid plans deﬁned literature The term optimistic stress credulous view deﬁnition respect incom plete ﬂuent information nondeterministic action effects In cases execution optimistic plan P fail reach goal We resort secure plans Deﬁnition A15 Secure plans alias conformant plans An optimistic plan cid5A1 Ancid6 secure plan legal initial state s0 trajectory T cid5cid5s0 A1 s1cid6 cid5sj 1 Aj sj cid6cid6 0 cid2 j cid2 n holds j n T establishes goal ii j n Aj 1 executable sj wrt PD legal transition cid5sj Aj 1 sj 1cid6 exists Note plans admit general concurrent execution actions We plan cid5A1 Ancid6 sequential nonconcurrent Aj cid2 1 1 cid2 j cid2 n A3 Macros K includes macros shorthands frequently concepts Let L act denote action atom f Lﬂ ﬂuent literal B possibly sequence b1 bk bk1 bl bi Lﬂtyp 1 l A possibly sequence a1 am1 aj L j 1 n Inertia To allow easy representation ﬂuent inertia K provides inertial f B A caused f f B f A Defaults A default value ﬂuent expressed shortcut default f caused f f It effect causation rule provides evidence opposite value T Eiter et al Artiﬁcial Intelligence 144 2003 157211 205 Totality For reasoning incomplete total knowledge K provides f positive total f B A caused f f B A caused f f B A State integrity For integrity constraints refer preceding state K provides forbidden B A caused false B A Nonexecutability For specifying action executable K provides nonexecutable B caused false B By deﬁnition nonexecutable overrides executable case conﬂicts Nonconcurrent plans To exclude simultaneous execution actions K provides noConcurrency caused false a1 a2 a1 a2 range possible actions a1 a2 LPD Lact a1 cid20 a2 In macros B respectively A omitted B respectively A Appendix B Problem encodings systems B1 Blocksworld problem P1 CMBP DOMAIN blocks_P1 ACTIONS act move_1_4 move_1_3 move_1_2 move_1_0 move_2_4 move_2_3 move_2_1 move_2_0 move_3_4 move_3_2 move_3_1 move_3_0 move_4_3 move_4_2 move_4_1 move_4_0 FLUENTS on_1 04 on_2 04 on_3 04 on_4 04 blocked_1 boolean blocked_2 boolean blocked_3 boolean blocked_4 boolean INERTIAL on_1 blocked_1 on_2 blocked_2 on_3 blocked_3 on_4 blocked_4 CAUSES act move_1_4 FALSE IF blocked_1 blocked_4 CAUSES act move_1_3 FALSE IF blocked_1 blocked_3 CAUSES act move_1_2 FALSE IF blocked_1 blocked_2 CAUSES act move_1_0 FALSE IF blocked_1 CAUSES act move_1_4 on_1 4 blocked_4 IF 1 CAUSES act move_1_4 blocked_2 IF on_1 2 CAUSES act move_1_4 blocked_3 IF on_1 3 CAUSES act move_1_3 on_1 3 blocked_3 IF 1 CAUSES act move_1_3 blocked_2 IF on_1 2 CAUSES act move_1_3 blocked_4 IF on_1 4 206 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 CAUSES act move_1_2 on_1 2 blocked_2 IF 1 CAUSES act move_1_2 blocked_3 IF on_1 3 CAUSES act move_1_2 blocked_4 IF on_1 4 CAUSES act move_1_0 on_1 0 IF 1 CAUSES act move_1_0 blocked_2 IF on_1 2 CAUSES act move_1_0 blocked_3 IF on_1 3 CAUSES act move_1_0 blocked_4 IF on_1 4 CAUSES act move_2_4 FALSE IF blocked_2 blocked_4 CAUSES act move_2_3 FALSE IF blocked_2 blocked_3 CAUSES act move_2_1 FALSE IF blocked_2 blocked_1 CAUSES act move_2_0 FALSE IF blocked_2 CAUSES act move_2_4 on_2 4 blocked_4 IF 1 CAUSES act move_2_4 blocked_1 IF on_2 1 CAUSES act move_2_4 blocked_3 IF on_2 3 CAUSES act move_2_3 on_2 3 blocked_3 IF 1 CAUSES act move_2_3 blocked_1 IF on_2 1 CAUSES act move_2_3 blocked_4 IF on_2 4 CAUSES act move_2_1 on_2 1 blocked_1 IF 1 CAUSES act move_2_1 blocked_3 IF on_2 3 CAUSES act move_2_1 blocked_4 IF on_2 4 CAUSES act move_2_0 on_2 0 IF 1 CAUSES act move_2_0 blocked_1 IF on_2 1 CAUSES act move_2_0 blocked_3 IF on_2 3 CAUSES act move_2_0 blocked_4 IF on_2 4 CAUSES act move_3_4 FALSE IF blocked_3 blocked_4 CAUSES act move_3_2 FALSE IF blocked_3 blocked_2 CAUSES act move_3_1 FALSE IF blocked_3 blocked_1 CAUSES act move_3_0 FALSE IF blocked_3 CAUSES act move_3_4 on_3 4 blocked_4 IF 1 CAUSES act move_3_4 blocked_1 IF on_3 1 CAUSES act move_3_4 blocked_2 IF on_3 2 CAUSES act move_3_2 on_3 2 blocked_2 IF 1 CAUSES act move_3_2 blocked_1 IF on_3 1 CAUSES act move_3_2 blocked_4 IF on_3 4 CAUSES act move_3_1 on_3 1 blocked_1 IF 1 CAUSES act move_3_1 blocked_2 IF on_3 2 CAUSES act move_3_1 blocked_4 IF on_3 4 CAUSES act move_3_0 on_3 0 IF 1 CAUSES act move_3_0 blocked_1 IF on_3 1 CAUSES act move_3_0 blocked_2 IF on_3 2 CAUSES act move_3_0 blocked_4 IF on_3 4 CAUSES act move_4_3 FALSE IF blocked_4 blocked_3 CAUSES act move_4_2 FALSE IF blocked_4 blocked_2 CAUSES act move_4_1 FALSE IF blocked_4 blocked_1 CAUSES act move_4_0 FALSE IF blocked_4 CAUSES act move_4_3 on_4 3 blocked_3 IF 1 CAUSES act move_4_3 blocked_1 IF on_4 1 CAUSES act move_4_3 blocked_2 IF on_4 2 CAUSES act move_4_2 on_4 2 blocked_2 IF 1 CAUSES act move_4_2 blocked_1 IF on_4 1 CAUSES act move_4_2 blocked_3 IF on_4 3 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 207 CAUSES act move_4_1 on_4 1 blocked_1 IF 1 CAUSES act move_4_1 blocked_2 IF on_4 2 CAUSES act move_4_1 blocked_3 IF on_4 3 CAUSES act move_4_0 on_4 0 IF 1 CAUSES act move_4_0 blocked_1 IF on_4 1 CAUSES act move_4_0 blocked_2 IF on_4 2 CAUSES act move_4_0 blocked_3 IF on_4 3 INITIALLY on_1 0 on_2 0 on_3 0 on_4 3 blocked_3 blocked_1 blocked_2 blocked_4 CONFORMANT on_1 0 on_2 1 on_3 2 on_4 3 B2 Blocks world problem P1 GPT define domain bw model SEARCH types BLOCK functions BLOCK BLOCK clear BLOCK boolean objects table BLOCK action puton parameters X BLOCK Y BLOCK Z BLOCK precondition X Z effect clear X true clear Y true Y table Y Z X Z X table set X Y set clear Z true set clear Y false define problem p1 domain bw objects b0 b1 b2 b3 BLOCK init set b0 table set b1 table set b2 table set b3 b2 set clear b0 true set clear b1 true set clear b2 false set clear b3 true set clear table false goal b3 b2 b2 b1 b1 b0 b0 table 208 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 Appendix C DLVK encodings BMTUCp t C1 Worldstate encoding Background knowledge package1 package2 packagep toilet1 toilet2 toilett DLVK program fluents actions cloggedT requires toiletT armedP requires packageP unsafe dunkP T requires packageP toiletT flushT requires toiletT inertial armedP inertial cloggedT caused cloggedT flushT caused armedP dunkP T total cloggedT dunkP T caused unsafe armedP executable flushT executable dunkP T cloggedT nonexecutable dunkP T flushT nonexecutable dunkP T dunkP1 T P P1 nonexecutable dunkP T dunkP T1 T T1 initially total armedP forbidden armedP armedP1 P P1 forbidden unsafe In encoding weak negation ﬂuent clogged CWA representation negated ﬂuent clogged relieves storing negative information explicitly The possible worldstates encoded 1 totalstatement ﬂuent armed initially section generates possible initial states 2 totalstatement ﬂuent clogged section speciﬁes effect dunking package C2 Knowledgestate encoding Background knowledge package1 package2 packagep toilet1 toilet2 toilett DLVK program fluents actions T Eiter et al Artiﬁcial Intelligence 144 2003 157211 209 cloggedT requires toiletT armedP requires packageP dunkedT requires toiletT unsafe dunkP T requires packageP toiletT flushT requires toiletT inertial armedP inertial cloggedT dunkedT inertial cloggedT dunkedT caused dunkedT dunkP T caused cloggedT flushT caused armedP dunkP T caused unsafe armedP executable flushT executable dunkP T cloggedT nonexecutable dunkP T flushT nonexecutable dunkP T dunkP1 T P P1 nonexecutable dunkP T dunkP T1 T T1 initially cloggedT In encoding ﬂuents armed clogged treated threevalued Instead encoding possible initial world states cases single initial state know toilets clogged values ﬂuents armed open We gain hand knowledge ﬂuent armed executing action flush hand lose forget information ﬂuent clogged know dunked respective toilet projection use auxiliary ﬂuent dunked An advantage encoding optimistic secure plans coincide encoding nondeterministic effects action dunk treated forgetting value respective ﬂuent clogged We point bomb toilet problem se computationally easy encodings based worldstates artiﬁcially bloat problem lack natural statement ﬂuents unknown state For discussion refer 6 References 1 R Bayardo R Schrag Using CSP lookback techniques solve realworld SAT instances Proc AAAI 97 Providence RI 1997 pp 203208 2 AL Blum ML Furst Fast planning planning graph analysis Artiﬁcial Intelligence 90 1997 281300 3 B Bonet H Geffner Planning incomplete information heuristic search belief space S Chien S Kambhampati CA Knoblock Eds Proc AIPS00 Breckenridge CO 2000 pp 5261 210 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 4 A Cimatti M Roveri Conformant planning symbolic model checking J Artiﬁcial Intelligence Res 13 2000 305338 5 T Eiter W Faber N Leone G Pfeifer A Polleres Planning incomplete knowledge J Lloyd V Dahl U Furbach M Kerber KK Lau C Palamidessi LM Pereira Y Sagiv PJ Stuckey Eds CL2000 Lecture Notes AI LNAI Vol 1861 Springer London 2000 pp 807821 6 T Eiter W Faber N Leone G Pfeifer A Polleres A logic programming approach knowledgestate planning Semantics complexity Technical Report INFSYS RR18430111 TU Wien 2001 7 T Eiter N Leone C Mateis G Pfeifer F Scarcello The KR dlv Progress report comparisons benchmarks AG Cohn L Schubert SC Shapiro Eds Proc KR98 Morgan Kaufmann San Mateo CA 1998 pp 406417 8 E Erdem Applications logic programming planning Computational experiments unpublished draft 1999 httpwwwcsutexaseduusersesrapapershtml 9 W Faber N Leone G Pfeifer Pushing goal derivation DLP computations M Gelfond N Leone G Pfeifer Eds Proc LPNMR99 El Paso TX Lecture Notes AI LNAI Vol 1730 1999 pp 177 191 10 P Ferraris E Giunchiglia Planning satisﬁability nondeterministic domains Proc AAAI00 Austin TX AAAI PressMIT Press Cambridge MA 2000 pp 748753 11 A Finzi F Pirri R Reiter Open world planning situation calculus Proc AAAI00 Austin TX AAAI PressMIT Press Cambridge MA 2000 pp 754760 12 M Gelfond V Lifschitz Classical negation logic programs disjunctive databases New Generation Comput 9 1991 365385 13 M Gelfond V Lifschitz Representing action change logic programs J Logic Programming 17 1993 301321 14 M Ghallab A Howe C Knoblock D McDermott A Ram M Veloso D Weld D Wilkins PDDLThe Planning Domain Deﬁnition language Tech Report Yale Center Computational Vision Control 1998 available httpwwwcsyaleedupubmcdermottsoftwarepddltargz 15 E Giunchiglia Planning satisﬁability expressive action languages Concurrency constraints nondeterminism AG Cohn F Giunchiglia B Selman Eds Proc KR2000 Morgan Kaufmann San Mateo CA 2000 pp 657666 16 E Giunchiglia GN Kartha V Lifschitz Representing action Indeterminacy ramiﬁcations Artiﬁcial Intelligence 95 1997 409443 17 E Giunchiglia V Lifschitz An action language based causal explanation Preliminary report Proc AAAI98 Madison WI 1998 pp 623630 18 E Giunchiglia V Lifschitz Action languages temporal action logics situation calculus Working Notes IJCAI99 Workshop Nonmonotonic Reasoning Action Change Stockholm Sweden 1999 19 R Goldman M Boddy Expressive planning explicit knowledge Proc AIPS96 AAAI Press 1996 pp 110117 20 L Iocchi D Nardi R Rosati Planning sensing concurrency exogenous events Logical framework implementation AG Cohn F Giunchiglia B Selman Eds Proc KR2000 Morgan Kaufmann San Mateo CA 2000 pp 678689 21 GN Kartha V Lifschitz Actions indirect effects preliminary report Proceedings Fourth International Conference Principles Knowledge Representation Reasoning KR94 Bonn Germany 1994 pp 341350 22 H Kautz B Selman Planning satisﬁability Proc ECAI92 Vienna Austria 1992 pp 359363 23 N Kushmerick S Hanks DS Weld An algorithm probabilistic planning Artiﬁcial Intelligence 76 12 1995 239286 24 N Leone R Rosati F Scarcello Enhancing answer set planning A Cimatti H Geffner E Giunchiglia J Rintanen Eds IJCAI01 Workshop Planning Uncertainty Incomplete Information Seattle WA 2001 pp 3342 25 V Lifschitz Foundations logic programming G Brewka Ed Principles Knowledge Representa tion CSLI Publications Stanford 1996 pp 69127 T Eiter et al Artiﬁcial Intelligence 144 2003 157211 211 26 V Lifschitz Action languages answer sets planning K Apt VW Marek M Truszczynski DS Warren Eds The Logic Programming ParadigmA 25Year Perspective Springer Berlin 1999 pp 357373 27 V Lifschitz Answer set planning DD Schreye Ed Proc ICLP99 MIT Press Las Cruces NM 1999 pp 2337 28 V Lifschitz H Turner Splitting logic program P Van Hentenryck Ed Proc ICLP94 MIT Press Cambridge MA 1994 pp 2337 29 V Lifschitz H Turner Representing transition systems logic programs M Gelfond N Leone G Pfeifer Eds Proc LPNMR99 El Paso TX Lecture Notes AI LNAI Vol 1730 Springer Berlin 1999 pp 92106 30 N McCain H Turner Causal theories actions change Proc AAAI97 Providence RI 1997 pp 460465 31 N McCain H Turner Satisﬁability planning causal theories AG Cohn L Schubert SC Shapiro Eds Proc KR98 Morgan Kaufmann San Mateo CA 1998 pp 212223 32 J McCarthy Formalization Common Sense Papers John McCarthy edited V Lifschitz Ablex Norwood NJ 1990 33 J McCarthy PJ Hayes Some philosophical problems standpoint artiﬁcial intelligence B Meltzer D Michie Eds Machine Intelligence 4 Edinburgh University Press Edinburgh 1969 pp 463502 reprinted 32 34 D McDermott A critique pure reason Comput Intelligence 3 1987 151237 cited 4 35 I Niemelä Logic programming stable model semantics constraint programming paradigm Ann Math Artiﬁcial Intelligence 25 34 1999 241273 36 CH Papadimitriou Computational Complexity AddisonWesley Reading MA 1994 37 MA Peot Decisiontheoretic planning PhD thesis Stanford University Stanford CA 1998 38 MA Peot DE Smith Conditional nonlinear planning Proceedings First International Conference Artiﬁcial Intelligence Planning Systems AAAI Press 1992 pp 189197 39 L Pryor G Collins Planning contingencies A decisionbased approach J Artiﬁcial Intelligence Res 4 1996 287339 40 R Reiter On closed world data bases H Gallaire J Minker Eds Logic Data Bases Plenum Press New York 1978 pp 5576 41 J Rintanen Constructing conditional plans theoremprover J Artiﬁcial Intelligence Res 10 1999 323352 42 DE Smith DS Weld Conformant Graphplan Proc AAAI98 Madison WI AAAI PressMIT Press Cambridge MA 1998 pp 889896 43 V Subrahmanian C Zaniolo Relating stable models AI planning domains L Sterling Ed Proceedings 12th International Conference Logic Programming Tokyo Japan MIT Press Cambridge MA 1995 pp 233247 44 GJ Sussman The virtuous nature bugs J Allen J Hendler A Tate Eds Readings Planning Morgan Kaufmann San Mateo CA 1990 Chapter 3 pp 111117 originally written 1974 45 H Turner Representing actions logic programs default theories A situation calculus approach J Logic Programming 31 13 1997 245298 46 JD Ullman Principles Database Knowledge Base Systems Vol 1 Computer Science Press 1989 47 DS Weld CR Anderson DE Smith Extending Graphplan handle uncertainty sensing actions Proc AAAI98 Madison WI AAAI PressMIT Press Cambridge MA 1998 pp 897904 48 H Zhang SATO An efﬁcient propositional prover Proceedings International Conference Automated Deduction CADE1997 1997 pp 272275