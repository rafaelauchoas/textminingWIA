Artiﬁcial Intelligence 174 2010 14071429 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Implementing logical connectives constraint programming Christopher Jefferson b Neil CA Moore b Peter Nightingale b Karen E Petrie School Computing University Dundee Dundee DD1 4HN UK b School Computer Science University St Andrews St Andrews Fife KY16 9SX UK r t c l e n f o b s t r c t Article history Received 31 July 2009 Received revised form 30 June 2010 Accepted 2 July 2010 Keywords Constraint programming Constraint satisfaction problems Propagation algorithms Logical connectives Combining constraints logical connectives disjunction ubiquitous constraint programming adds considerable expressive power constraint language We explore solver architecture needed propagate combinations constraints eﬃciently In particular new features named satisfying sets constraint trees We use movable triggers Gent et al 2006 1 complementary features able considerable eﬃciency gains A key reason success Boolean Satisﬁability SAT solvers ability propagate Or constraints eﬃciently making use movable triggers We successfully generalise approach Or arbitrary set constraints maintaining crucial property constraints active time computation We And propagator framework embedded Or Using approach demonstrate speedups 10000 times cases compared traditional constraint programming approaches We prove Or algorithm enforces generalised arc consistency GAC child constraints GAC propagator variables shared children By extending Or propagator present propagator AtLeastK expresses k child constraints satisﬁed solution Some logical expressions exclusiveor compactly expressed And Or AtLeastK Therefore investigate reiﬁcation constraints We present fast generic algorithm reiﬁcation satisfying sets movable triggers 2010 Published Elsevier BV 1 Introduction Problems consist choices Making optimal choice compatible choices diﬃcult Constraint programming CP branch Artiﬁcial Intelligence computers help users choices Con straint programming multidisciplinary technology combining science operations research mathematics Constraints powerful natural means knowledge representation inference areas industry academia arising design conﬁguration planning scheduling diagnosis testing contexts A constraint satisfaction problem CSP 2 set decision variables associated domain potential values set constraints For example problem ﬁt components values circuit boards decision variables subject constraint components overlapping An assignment maps variable value domain Each constraint speciﬁes allowed combinations assignments values subset variables A solution Corresponding author Email addresses cajcsstandrewsacuk C Jefferson ncamcsstandrewsacuk NCA Moore pncsstandrewsacuk P Nightingale kpetriecomputingdundeeacuk KE Petrie 00043702 matter 2010 Published Elsevier BV doi101016jartint201007001 1408 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 CSP assignment variables satisﬁes constraints In paper consider solving CSPs backtrack search inference step node 2 Modelling process representing problem CSP To allow natural modelling problems logical connectives And Or required constraints For example school timetabling problem Teacher1 Or Teacher2 And Teacher3 taking particular class It useful able apply Not constraint CSP means reiﬁcation The reiﬁcation constraint C produces constraint Cr Cr extra Boolean variable r variable set solution r set true original constraint C satisﬁed In paper discuss neglected area eﬃciently implement logical connectives constraints fundamental building blocks CSP models 3 Chapter 11 During search solution CSP constraint propagation algorithms These propagators inferences recorded domain reductions based domains variables constrained If point inferences result variable having domain search backtracks new branch considered Propagators generalised arc consistency GAC important concepts paper When considering single constraint C GAC strongest possible consistency propagation algorithm enforce Enforcing GAC removes domain values compatible solution C In 3 Chapter 3 Bessiere deﬁnes GAC discusses complexity enforcing In paper consider propagating logical combinations constraints For example constraints C1 C2 C3 C4 wish post following expression propagate eﬃciently C1 C2 C3 C4 It desirable use existing propagators C1 C2 C3 C4 highly eﬃcient specialised propagators 11 A traditional approach A traditional approach probably common individually create reiﬁed propagators constraints These introduce additional Boolean variable representing truth constraint reiﬁed form C1 constraint r1 C1 solution r1 True C1 satisﬁed A logical expression enforced additional Boolean variables obtain desired combination The example translates following collection constraints1 r1 C1 r1 r2 r3 r4 r3 C3 r4 C4 r2 C2 This scheme major disadvantages First ineﬃcient reiﬁed constraint propagated time For example consider Or set n constraints As demonstrate Section 4 constraints need actively checked time However reiﬁcation approach propagate n reiﬁed constraints times Second developing reiﬁed propagators individually constraint major effort Third variable occurs multiple times expression reiﬁed decomposition propagate poorly In paper address ﬁrst issues achieve level consistency reiﬁed decomposition 12 Two vital features solver new approach The key ﬁnding work vital features solver combined achieve eﬃcient propagation logical connectives If feature available limited beneﬁt The features constraint trees allow parent constraint control propagation children movable triggers allow constraint change events 3 Chapter 14 interested search Consider Or n constraints disjoint variable sets We constraints need considered time constraints satisﬁable propagation occur Once satisﬁable constraints identiﬁed constraints presently irrelevant computation time wasted This essential eﬃciency n large Constraint trees allow stop checking irrelevant constraints However achieve zero cost irrelevant constraints cost generate trigger events constraints It necessary remove triggers currently movable triggers required The following table summarises costs caused irrelevant constraints Reiﬁcation Constraint trees Static triggers All reiﬁed constraints propagated times Trigger events received constraints times Movable triggers All reiﬁed constraints propagated times Irrelevant constraints cause cost 1 In solvers necessary decompose r1 r2 r3 r4 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1409 Our implementations Minion solver 4 presentation speciﬁc Minion 13 Overview There number solver architecture decisions impinge propagating logical combinations constraints In Section 3 architecture features key new algorithms presented paper Satisfying sets Section 33 novel best knowledge We provide ﬁrst implementation constraint trees Section 32 Movable triggers 1 described Section 31 aid understanding rest paper In Section 4 present propagator constraint AtLeastK ensures k set constraints satisﬁed solution Both And Or special cases AtLeastK Via constraint trees framework AtLeastK constraints nested depth reiﬁed algorithms given Section 5 The AtLeastK propagator maintains crucial property k 1 constraints checked k propagated time computation Section 4 contains experiments eﬃciency Watched Or And AtLeastK demonstrate huge speedups cases In Section 5 consider reiﬁcation Some logical expressions exclusiveor compactly expressed And Or AtLeastK general approach needed Therefore investigate use satisfying sets movable triggers constraint trees reiﬁcation constraints To avoid implementing reiﬁed propagators individual constraints developed generic algorithms constraint C provided propa gator C available We compare algorithms use satisfying sets movable triggers alternatives static triggers demonstrate huge speedups cases Finally paper concluded Section 6 2 Background 21 Preliminaries A CSP P cid7X D Ccid8 deﬁned sequence n variables X cid7x1 xncid8 sequence domains D cid7D1 Dncid8 D ﬁnite set potential values xi set C C1 C2 Ce constraints A literal pair cid7xi dicid8 xi X di D An assignment A partial function A X Dall Axi D Dall D In complete assignment A total function xi X mapped A Within CSP P cid7X D Ccid8 constraint Ck C consists sequence r 0 variables Xk cid7xk1 xkr cid8 Xk cid8 st Xk subsequence2 X Dk scope constraint respective domains Dk cid7Dk1 Dkr corresponding subsequence D Ck associated set C S Dkr tuples specify allowed combinations k values variables Xk A constraint satisﬁed complete assignment variables iff assigned values Xk sequence form tuple C S k A solution CSP complete assignment satisﬁes constraints The reiﬁed form rk Ck constraint Ck satisﬁed iff rk assigned 1 Ck satisﬁed rk assigned 0 Ck satisﬁed The reifyimplied form rk Ck Ck satisﬁed iff rk assigned 0 rk assigned 1 Ck satisﬁed The And set constraints satisﬁed iff constraints set satisﬁed The Or set constraints satisﬁed iff constraints set satisﬁed The AtLeastK set constraints parameter k satisﬁed iff k constraints set satisﬁed Dk1 cid2 A subdomain variable x subset initial domain A subdomain list sequence subdomains distinct variables A subdomain list cid7D1 Dkcid8 allows set assignments corresponding D1 Dk A propagator constraint C function takes subdomain list XC returns new subdomain list allow extra assignments remove assignments satisfy C Further subdomain subdomain list S D XC singleton propagator domains iff C s contain single allowed assignment S D A propagator GAC removes domain value possible violating deﬁnition propagator A complete discussion propagators 3 Chapter 3 Given constraint c subdomain list S D variables Xc c disentailed assignment allowed S D satisfy c c entailed assignment allowed S D satisﬁes c 22 Related work propagation control Brand Yap 5 present framework reducing redundant propagation logical combinations constraints This named controlled propagation framework CPF In CPF standard reiﬁcation approach improved adding control ﬂags constraint For individual reiﬁed constraint C b value b controls propagated positively negatively control ﬂags indicate prunes b ﬂags chktrue chkfalse indicate C checked entailment disentailment b pruned chktrue chkfalse 2 We use subsequence sense cid71 3cid8 subsequence cid71 2 3 4cid8 1410 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 present The ﬂag irrelevant indicates C b need propagated current search node descendents This usually mean C b revoked triggers removed The control ﬂags manipulated implication rules CPF implemented Constraint Logic Programming context allows constraints posted triggers added search moves forward The posted constraints triggers removed backtracking This allows parts decomposition generated needed search Constraints revoked restored backtracking CPF goals work A detailed comparison given Section 34 23 Related work Or Many authors considered constructive disjunction propagating Or For example Müller Würtz 67 present constructive disjunction algorithm implemented Oz Assuming child constraints GAC propagators construc tive disjunction able enforce GAC Or regardless child constraints share variables However achieved making copy variable domains child constraint propagating child independently A value pruned child constraint pruned copy domains pruned globally Or It clear algorithm implemented eﬃciently Lagerkvist Schulte 8 observed performance penalty 45 executing propagators copies domains mirroring result primary domains compared executing directly original variables Constructive disjunction valuable problems strong propagation Or required However paper consider lightweight methods require duplication variable domains Therefore consider constructive disjunction outside scope paper Bacchus Walsh 9 theoretical results logical combinations constraints including And Or negation Concerning Or paper states set inconsistent values Or intersection inconsistent values child constraint This perform domain reductions constructive disjunction The authors basic algorithm consider incremental propagation vital eﬃciency Adapting algorithm incrementality require tracking state variable domains independently child essentially duplicating variable domains This equivalent algorithm Müller Würtz 67 Lhomme 1011 presents alternative constructive disjunction performs domain reductions Lhom mes algorithm claimed eﬃcient constructive disjunction It based ﬁnding satisfying assignments represented tuples values constraints Each relevant variablevalue pair supported satisfying tuple constraints disjunction pruned While Lhommes algorithm faster constructive disjunction maintains large set supporting tuples variablevalue pair variable shared child constraints Our proposed algorithm maintains partial tuples enforces weaker consistency lightweight In SAT constraints Or Boolean literals propagated 2literal watching 12 This scheme advantage literals active time incur cost One major contributions paper proposed algorithm Watched Or Section 4 shows basic techniques 2literal watching eﬃciently extended support arbitrary constraints propagators keeping eﬃciency comes having active disjuncts time 24 Related work reiﬁcation Reiﬁcation constraint C produces constraint r C r Boolean variable We focus generic ap proaches reiﬁcation applied constraint appropriate algorithms deﬁned For example prove generic reiﬁcation algorithm enforces GAC eﬃciently requires GAC propagators constraint negation Indexicals proposed Van Hentenryck et al 13 allow simple propagators speciﬁed highlevel language They extended slightly allow reiﬁcation 3 Section 1426 However possible express polynomialtime GAC propagators constraints AllDifferent 14 indexicals language Propia 15 allows constraints expressed Prolog predicates The predicate speciﬁes constraint semantically opposed giving propagator constraint To implement reiﬁcation predicate required constraint negation Similarly indexicals possible specify sophisticated propagators propia offer eﬃcient generic solution Schulte proposed generic reiﬁcation algorithm 16 based concept computation spaces A computation space isolated environment allows propagator executed affecting primary variables The computation space includes independent variable domains For ri Ci Ci posted space propagated If fails ri cid12 1 1 pruned ri If entailed equivalent constraint True ri cid12 0 If ri 1 effects propagating Ci copied primary variables In case ri 0 propagation Ci algorithm Ci entailed The approach later proposed Lagerkvist Schulte 8 virtually algorithm implemented propagator groups C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1411 Fig 1 Constraint tree x 1 y 2 x 3 Both approaches disadvantages duplicate variables propagate negative constraint C r 0 Lagerkvist Schulte compared handimplemented reiﬁed constraint generic algorithm The generic algorithm substantially slower solver taking 29 106 extra time 8 The commercial product ILOG Solver implements reiﬁcation literature describing algorithm In Section 5 propose new reiﬁcation algorithms avoid overhead duplicating variables able encapsulate propagator unlike indexicals propia 241 Triggering Given propagator P constraint c subdomain lists S D P S D S D In situations necessary run propagator Rather invoke propagators domain change solvers provide list events propagators subscribe A propagator subscribes event attaching trigger Executing trigger calls propagator generated reference event occurred refer triggering propagator When events occur placed queue Items queue processed executing trigger event turn The exact set events subscribed varies solvers For variable x domain Dx domain value Minion supports following events removed Dx value removed Dx x assigned maximum value Dx removed minimum value Dx removed The propagator triggered P S D cid12 S D propagator fail enforce correct level consistency 242 Constraint trees There highly eﬃcient propagators written constraints We like able combine propagators build new propagators Constraint trees provide highly eﬃcient framework achieving goal To deﬁne constraint trees deﬁne concept metavariables These CSP variables associated overhead merely pedagogical purposes Metavariables Boolean states 0 1 unset The current subdomain metavariable xm constraint c denotes current subdomain list c entailed xm 1 disentailed xm 0 xm 0 1 The state xm property c stored A constraint tree rooted tree T cid7V E rcid8 root r V Each node b V associated constraint metavariable The scope constraint node b contain CSP variables metavariables children b A constraint tree satisﬁed iff constraint associated r satisﬁed A constraint tree type constraint contained CSP deﬁned Section 21 Constraint trees novel concept example Bacchus Walsh use 9 allow deﬁne novel propagation framework Now discuss propagation constraint trees The constraint vertex V propagator P associated Propagators leaves tree conventional propagators described Section 21 The propagator P b internal vertex b V tree able prune CSP variables query child constraint disentailment invoke propagator child constraint By abuse notation refer vertices T constraints The parent constraint attached node parent T The children constraint attached node V children T Constraint trees implement constraints expressed logical combinations constraints For example x 1 y 2 x 3 represented constraint tree Fig 1 We present propagators interior nodes Section 4 One issue ignored discussing propagation algorithms variables repeated straint Most propagation algorithms enforce GAC enforce GAC variables repeated Many constraints polynomialtime GAC propagators NPhard enforce GAC repeated variables taken account example Global Cardinality Constraint 17 We address issue repeated variables separately proposed algorithms paper 3 Solver architecture In order implement logical connectives eﬃciently number solver architecture decisions described section 1412 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 31 Movable triggers One important propagators implemented triggered described Section 241 In Minion classes triggers discussed depth 1 In paper exploit static movable triggers In 1 movable triggers referred watched literals Static These triggers placed variables beginning search They moved removed Movable These triggers placed moved removed search When search backtracks restored previous place Using movable triggers produce great improvements performance solver observed SAT 12 CSP 1 Some solvers support movable triggers backtrack search The algorithms described paper trivially modiﬁed work solvers cost extra overhead backtracking triggers data structures 32 Constraint trees All following algorithms use concept Constraint Tree deﬁned Section 242 In paper assume parent constraint controls child propagated constraint method detect constraint disentailed We Section 4 detect disentailment interior nodes disentailment detectors children Any constraint propagator disentailment checker function child constraint allowing leverage large number implemented highly eﬃcient propagators CP literature All parent constraints paper function child constraint Static triggers handled follows tree constraints At setup time propagators tree place static triggers need During search trigger events passed topmost propagator Each parent propagator passes appropriate trigger events children currently propagating discards An example shown Fig 2 Three assignments occur sequence x2 0 x6 0 x1 0 corresponding events passed propagator c1 solver core In Fig 2b c1 propagating children discards events In c c1 propagating left child trigger event belongs right child discarded In d c1 passes trigger event c2 c2 currently propagating Movable triggers somewhat complicated allow triggers nonpropagating children removed reducing number unnecessary trigger events Operations movable triggers described algo rithms Sections 4 5 For classes trigger trigger events passed tree ﬁlter adds small overhead propagating constraints leaves tree However propagators invoked execute constraint tree directly reading changing subdomain variables 33 Satisfying sets In algorithms paper want fast method checking constraint satisﬁable One way execute propagator check removes values domain variable However clearly ineﬃcient computes domain deletions deducing constraint satisﬁable In section introduce satisfying sets simple eﬃcient framework checking disentailment Deﬁnition 1 Given constraint C satisfying set set literals F XC assignment XC contains literals F satisﬁes C A satisfying set F complete additionally subdomain list XC contains literals F allows assignment satisﬁes C Example 2 Consider constraint X Y Z cid2 2 variables X Y Z domains 0 1 The set liter als cid7 X 1cid8 cid7Y 1cid8 complete satisfying set It satisfying set assignments contain literals cid7 X Y Z cid8 cid71 1 0cid8 cid71 1 1cid8 satisfy constraint It complete subdomain list XC tain satisfying set contain assignment X 1 Y 1 Therefore regardless assignment Z sum variables greater equal The set literals cid7 X 0cid8 cid7 X 1cid8 trivially satisfying set assignment contains literals variable It complete subdomain list X 0 1 Y Z 0 contain assignment satisﬁes constraint Given satisfying set constraint know literals satisfying set removed end state variable assigned constraint satisﬁed This basic guarantee C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1413 Fig 2 Example static trigger events satisfying sets constraint tree representing x1 x2 x3 x4 1 x5 x6 Satisfying sets written constraints list values For example satisfying set c5 cid7x4 0cid8 cid7x5 0cid8 cid7x6 1cid8 Movable trigger events omitted diagram In table static triggers placed constraint listed ensure algorithms satisfying sets correct A complete satisfying set produces stronger guarantee constraint disentailed long literal satisfying set removed This necessary propagator makes use satisfying sets enforce GAC Deﬁnition 3 introduces concept satisfying set generator Deﬁnition 3 A satisfying set generator constraint C function takes subdomain list S D returns satisfying set S D Fail A satisfying set generator return Fail assignment S D satisﬁes C A satisfying set generator complete returns complete satisfying sets This implies return Fail exactly assignment S D satisﬁes C One question constraints satisfying set generators implemented polynomial time complete Deﬁnition 4 presents trivial satisfying set generator provides polynomialtime satisfying set generator constraint Lemma 5 shows trivial satisfying set generator valid Notice incomplete satisfying set contain literals variable Deﬁnition 1 The following trivial satisfying set generator makes use fact Deﬁnition 4 The trivial satisfying set generator constraint C subdomain list S D deﬁned follows 1 There exists X XC S D X 1 Return satisfying set containing literals S D X 2 S D allows exactly assignment If assignment satisﬁes C return satisfying set containing literals S D return Fail 1414 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 Lemma 5 For constraint C trivial satisfying set generator valid runs polynomial time Proof Any set literals contains assignments variable satisfying set assignment contain values variable Once variables assigned trivial satisfying set generator returns Fail returns complete assignment satisfy C The complexity result trivial cid2 Theorem 6 categorises complexity complete satisfying set generators Theorem 6 A constraint C polynomial time complete satisfying set generator polynomial time GAC propagator Proof Given complete satisfying set generator possible check subdomain list XC contains satisfying assignment seeing satisfying set generator returns Fail Lemma 1 17 proves polynomially equivalent having GAC propagator Alternatively given GAC propagator C construct complete satisfying set generator follows The GAC propagator domains variables subdomain list contains assignment sat isﬁes C exactly situation complete satisfying set generator return Fail Assuming GAC propagator domains contain satisfying assignment A complete assignment satisﬁes C complete satisfying set subdomain list contains contains satisfying assignment The following algorithm produces assignment satisﬁes C XC invocations propagator 1 Run GAC propagator 2 If unassigned variable exists choose assign value current subdomain 3 If variable unassigned return step 1 cid2 While Theorem 6 shows build complete satisfying set generator GAC propagator constraints faster complete satisfying set generator produces smaller satisfying sets Theorem 6 returns complete satisfying set literals variables XC The complexity ﬁnding smaller complete satisfying sets open problem leave future work For constraints Minion GAC propagators constructed complete satisfying set generators taking small propagator We present cases examples Example 7 Consider constraint Mx y array variables M variables x y Given subdomain list constraint satisﬁable exist j subdomain x j subdomain Mi y If j exist literals cid7x icid8 cid7Mi jcid8 cid7 y jcid8 form complete satisfying set Example 8 The complete satisfying set generator given Theorem 6 requires ﬁnding complete assignment satisﬁes constraint The ﬁrst AllDifferent propagator 14 ﬁnds satisfying assignment complete satisfying set generator formed truncating algorithm point 34 Comparison previous work The closely related previous work Brand Yap 5 CPF described Section 22 There impor tant differences work CPF Firstly approach reiﬁcation variables constraint trees able avoid reduce overheads Secondly constraint trees static framework posts new straints revokes constraints search potentially saving space time overhead Thirdly approach restricted propagation checking child constraints It possible propagate negation child introducing negation child constraint CPF allows propagation checking negation constraint cost requiring propagator reiﬁed form constraint Fourthly importantly CPF use movable triggers Constraints posted revoked search events triggers ﬁxed The framework proposed makes extensive use movable triggers satisfying sets check disentailment primitive parent constraints For example checking disentailment AllDifferent constraint requires movable trigger literal variable By contrast CPF necessary check constraint domain change3 It possible implement 2literal watching SAT clause Boolean variables CPF This dynamically posting literals checked disentailment time The technique applied disjunction constraints CPF able combine technique movable triggers satisfying sets eﬃcient disentailment checking child constraints 3 Assuming complete satisﬁability checking required C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1415 4 Eﬃcient propagators ATLEASTK AND OR In section present new algorithm AtLeastK set constraints deﬁned Section 21 Then algorithm specialised And Or 41 Theoretical overview The AtLeastK algorithm deﬁned AtLeastKk Con true k constraints Con true In Theorem 9 fundamental result algorithm AtLeastK uses enforce GAC assuming constraints Con GAC propagator constraints Con share variable Theorem 9 Let constraint C AtLeastKk Con1 Con2 Conn constant k constraints Coni scopes Coni disjoint Given subdomain list S D XC subdomain variable S D nonempty S D GAC respect C 1 At k 1 Coni satisfying assignments S D 2 exactly k Coni satisfying assignment S D S D GAC respect k constraints Proof 1 Assume exists set S S k 1 Coni satisfying assignment S Then given assignment variable k members S contain variable scope A satisfying assignment C generated assigning k constraints satisfying assignment assigning variables value Therefore assignment variable supported 2 Assume exists set S S k Coni satisﬁable S This implies satisfying assignment C Coni S satisﬁed Therefore S assignment variable scope Coni extended satisfying assignment Coni removed This deﬁnition GACConi Any variable scope Coni S assigned value If k members Con satisﬁable clearly assignment satisfy C cid2 42 The watched AtLeastK propagator Our algorithm split distinct phases setup phase watching phase propagation phase In section present phase separately Before presenting steps algorithm ﬁrst state algorithm stores calls PropagateMode Boolean represents propagation phase algorithm It reverted search backtracks Watches The indices k 1 child constraints currently watched These reverted search backtracks The algorithm operates child constraints c1 cn required propagator satisfying set generator By constraint trees framework Section 32 child propagators able use kind trigger available Minion executing eﬃcient propagating ordinary constraint overhead passing trigger events AtLeastK The algorithm begins setup phase This searches k 1 satisﬁable children If k 1 watched If exactly k propagation phase entered fewer k constraint fails signalling search backtrack The code setup phase shown Algorithm 1 While PropagateMode False literal satisfying set pruned watching phase algorithm called This ﬁnds new satisfying set k children satisﬁable starts propagate k satisﬁable children The code watching phase shown Algorithm 2 Finally propagation phase active PropagateMode True All trigger events belonging c j j Prop passed c j We code propagation phase It possible receive stale trigger events movable triggers placed different phase movable triggers backtracked Therefore watching propagation phases trigger events ignored handled specially These listed Algorithms 1 2 assume events dealt appropriately Watching Phase Trigger events propagation phase received phase Movable triggers removed ignored static triggers removed ignored 1416 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 PropagateMode False S 1 n S k 1 ci S ci satisfying set Place movable triggers satisfying sets ci S Watches S S 1 n S k ci S ci satisfying set Initialise propagation ci S PropagateMode True Fail end end Algorithm 1 Code setup phase Input The satisfying set constraint ci lost Global Data PropagateMode PropagateMode Return end ci satisﬁable Move movable triggers new satisfying set ci k ck satisﬁable k Watches Move movable triggers satisfying set ck ci Watches Watches k Prop Watches Initialise propagation c j j Prop PropagateMode True end end Algorithm 2 Code watching phase Propagation Phase Static trigger events children propagated ignored All trigger events setup watching phases ignored movable trigger events nonpropagating child cause corresponding movable trigger removed To prove algorithm correct present invariants These invariants exactly conditions required enforce GAC AtLeastK Theorem 9 algorithm achieves GAC assumptions children GAC propagators satisfying set generators complete pair children share variables Lemma 10 After setup phase algorithm completed point search failure occurred items constraint queue executed following invariants true 1 PropagateMode False implies k 1 satisfying sets k 1 child constraints watched 2 PropagateMode True implies n k child constraints known unsatisﬁable k propagated Proof Invariant 1 true setup search progresses forward However consider happens search backtracks If PropagateMode True remains condition trivially true There cases consider Backtrack node A PropagateMode False node B PropagateMode False The k 1 satisfying sets A retained valid B domain sets B nonstrict supersets A Backtrack node A PropagateMode True node B False The k 1 satisfying sets node B intermediate state A B They remain valid B domain sets B supersets intermediate state For invariant 2 places PropagateMode set True invariant holds Suppose PropagateMode set True node A For nodes B A search tree domain sets subset A invariant holds n k unsatisﬁable children remain unsatisﬁable B When backtracking A PropagateMode reverted False invariant holds cid2 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1417 As stated proof assumes child constraint GAC propagator satisfying set generators complete If case invariant 2 k children propagated guarantee GAC lost clear algorithm remains correct long children propagators meeting deﬁnition Section 21 The proof assumes variables shared children However assumption met requires discussion In terms constraint trees consider AtLeastK vertex child vertices b associated metavariables xa xb associated constraints y 1 y 3 variable y 1 2 3 Both meta variables unassigned AtLeastK algorithm deduce equal 1 time The level consistency enforced AtLeastK achieved following replace y 3 cid17 3 new variable y apply Watched AtLeastK y cid17 3 longer share variables Watched AtLeastK enforces algorithm In translation children y 1 y GAC identical domain add new GAC constraint y y cid17 cid17 In general level consistency enforced AtLeastK shared variables achieved following reformulating AtLeastK remove shared variables duplicating variables adding GAC equality constraints enforcing GAC reformulated AtLeastK It assumed child constraint GAC propagator child constraint repeated variables scope propagator enforces GAC As discussed Section 23 previous work shown given disjunction constraints polynomialtime GAC propagator possible achieve GAC propagation disjunction polynomialtime disjuncts share variables constructive disjunction We leave eﬃciently combining constructive disjunction constraint trees satisfying sets future work 421 A satisfying set generator AtLeastK Our Watched AtLeastK algorithm uses satisfying sets extensively To able use AtLeastK nonroot node constraint tree necessary satisfying set generator AtLeastK Deﬁnition 11 Given satisfying set generators set c1 cn constraints satisfying set generator AtLeastKc1 cn deﬁned follows If satisfying set generators n k children return Fail return Fail Otherwise choose set k children satisfying set generators return Fail return union satisfying sets generate Lemma 12 The satisfying set generator C AtLeastKc1 cn given Deﬁnition 11 correct Further complete satisfying set generators ci complete cid12 j Xci Xc j disjoint Proof Correct The satisfying set generator C returns Fail fewer k children satisﬁable matching deﬁnition AtLeastK A satisfying set F generated C contain satisfying sets k children assignment contains F satisfy k children Completeness If C unsatisﬁable exist k children C complete satisfying set satisfying set generator C return Fail If C satisﬁable k satisﬁable children complete satisfying sets generated k children Given subdomain list S D XC contains k complete satisfying sets k children satisfying assignment S D Joining k disjoint assignments assignment variable XC produces satisfying assignment C Therefore satisfying set generator C complete long satisfying set generators children complete scopes children disjoint cid2 43 The watched Or And propagators It easy algorithm AtLeastK generate algorithms And Or Or logically identical AtLeastK k 1 course algorithm achieve constructive disjunction discussed Section 23 Furthermore And equivalent AtLeastK k set equal number children Watched And useless isolation achieve identical propagation posting child constraints individually However useful child Or AtLeastK constraint Given observation propagators satisfying set generators Watched Or Watched And straightfor ward specialisations Watched AtLeastK For algorithms simpliﬁcations performance gains achieved ﬁxing k The algorithm Or generalisation unit propagation 2literal watching SAT 12 A SAT clause Or literals Boolean variables cid7xi 0cid8 cid7xi 1cid8 44 Complexity Lemma 10 showed polynomialtime algorithm given AtLeastK achieves GAC repeated vari ables specialisations Section 43 Watched Or Watched And run polynomial 1418 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 time achieve GAC As discussed previously Section 23 possible achieve GAC polynomial time Watched Or variables repeated different disjuncts Lemma 14 shows case AtLeastK k cid2 2 Deﬁnition 13 The True constraint constraint variables contains single tuple Therefore satisﬁed The False constraint constraint variables contains tuples false Lemma 14 GAC propagation And C NP hard C cid2 2 AtLeastK k C NPhard k cid2 2 C cid2 2 Proof Bacchus Walsh 9 And constraints polynomialtime GAC propagators NPhard constraints allowed share variables We extend result And C C cid2 3 adding C 2 copies True constraint Deﬁnition 13 We extend result AtLeastK k C adding k 2 copies True C k copies False Deﬁnition 13 cid2 45 Experimental results We claimed Section 12 constraint trees movable triggers essential propagation logical nectives Here test claim different problems All experiments use Minion version 010 downloaded httpminionsourceforgenet We ran experiments 4 servers Intel Xeon 24 GHz CPUs Each server 2 cores 2 GB memory running Linux kernel 2618 We repeated experiment 5 times took instance minimum runtime representative run suffering interference closely approximating ideal The maximum coeﬃcient variation set 5 runs 13 All problem instances available online4 All times given seconds 451 The generalised pigeonhole problem The ﬁrst experiment generalisation pigeonhole problem We consider problem ﬁnding assignments twodimensional array variables pair rows array unequal The parameters problem number rows n number columns p domain size d We introduce matrix variables M1 n 1 p 1 d All ﬁve models introduce nn 12 notequal constraints pairs rows M We compare ﬁve representations constraint rows r1 r2 equal Watched OR Implement Mr1 1 cid12 Mr2 1 Mr1 p cid12 Mr2 p Watched Or described Section 43 enforces GAC Element We ensure r1 r2 differ position adding pair rows Sum New variables X 1 p Y Z 1 d The constraints Mr1 X Y Mr2 X Z Y cid12 Z Decompose model Watched OR New variables N1 p 0 1 The constraints Ni Mr1 cid12 Mr2 cid3 cid3 N cid2 1 Watched Sum The model Sum constraint N cid2 1 replaced SAT clause implemented movable triggers Custom A customwritten propagation algorithm static triggers variables enforcing level consis tency Watched OR GAC These models explore possibilities static movable triggers reiﬁcation constraint trees shown table Reiﬁcation Constraint trees Static triggers Sum Custom Movable triggers Watched Sum Watched OR Note Theorem 66 18 long GAC constraints Sum Watched Sum models GAC Or long place new variables end search ordering resulting searches identical Watched OR model Therefore model result different sized search Element Since achieve GAC scope Lhommes algorithm 1011 constructive disjunction algorithms enforce stronger consistency Lhommes algorithm statically triggered similar Custom context 4 httpwwwcsstandrewsacukpnorreifyjournalinstancestarbz2 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1419 Table 1 Search size small instances array pigeonhole problem cid7n p dcid8 cid78 3 2cid8 cid78 3 3cid8 cid78 4 2cid8 cid78 4 3cid8 Element Time 2581 802862 213713 10906770 Nodes 12335593 3112501760 1092789218 45000000000 Table 2 Nodes second averaged 100 seconds pigeonhole instances n 100 cid7n p dcid8 cid7100 5 2cid8 cid7100 10 2cid8 cid7100 20 2cid8 cid7100 30 2cid8 cid7100 40 2cid8 cid7100 50 2cid8 cid7100 5 10cid8 cid7100 10 10cid8 cid7100 20 10cid8 cid7100 30 10cid8 cid7100 40 10cid8 cid7100 50 10cid8 Watched OR 19153622 49900721 157641385 157934799 146131606 143979697 69048251 37925581 23993797 20399109 15588724 12414139 Sum 1930405 126815 75548 54823 42432 37062 140405 81718 37853 26658 23483 20379 Watched OR Time 027 027 027 027 Nodes 25 28 33 36 Watched Sum Custom 2940422 137721 78240 56470 42823 37395 143998 83869 38592 30782 25354 22554 5418004 7970414 8744399 8417060 7823420 7676677 10523471 10345750 7941876 7191423 6557234 5668584 Table 1 shows badly Element model performs practice small instances quickly leading insolvable problems models consider able solve second Due poor performance model considered As remaining models produce identical search trees Table 2 compare instances terms number nodes search perform second The Custom model improves signiﬁcantly Sum Watched Sum eliminating additional variables Watched OR faster Custom orders magnitude When watching phase Watched Or algorithm use movable triggers watched child constraint By comparison custom algorithm assignment triggers variables This illustrates importance appropriate triggering mechanism case movable triggers With domain size 2 Watched Or algorithm increases speed instance size increases This surprising result caused decrease proportion variables movable trigger The small differences Sum Watched Sum gain movable triggers sum constraint insigniﬁcant compared cost propagating reiﬁed notequal constraints In summary results support hypothesis constraint trees movable triggers eﬃ ciently propagate Or 452 The antichain problem In second experiment consider antichain problem deﬁned Deﬁnition 15 An antichain set S multisets x y S x cid12 y y cid12 x The cid7n l dcid8 instance antichain ﬁnds set n multisets cardinality l drawn d elements total satisfying constraint Deﬁnition 15 We model CSP n arrays variables denoted M1 Mn containing l variables domain 0 d 1 constraints cid12 j 1 n k 1 n Mik M jk Each variable Miv represents number occurrences value v multiset maximum d 1 Each pair rows Mi M j differ places position k Mik M jk position p Mip M jp This ensures multiset contains Similarly generalised pigeonhole problem consider 4 implementations constraint Mi Ni arrays M N Watched OR Element Sum Implemented Watched Or Introduce variables domain 0 l 1 m n domain 0 d 1 Impose constraints Mi m Ni n m n Introduce new array Boolean variables b length l impose set constraints Mi Ni bi cid3 bi j cid2 1 1420 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 Table 3 Search size ﬁnding ﬁrst solution antichain problem cid7n l dcid8 cid711 4 3cid8 cid712 4 3cid8 cid713 4 3cid8 cid714 4 3cid8 cid79 4 10cid8 cid710 4 10cid8 cid711 4 10cid8 cid712 4 10cid8 cid711 5 2cid8 Element Time 383 7740 448845 493110 376 2831 17182 77536 73576 Nodes 142674 3030555 166888355 166888372 90678 636635 3340225 12311354 47602427 Table 4 Finding solutions instances antichain problem cid7n l dcid8 cid72 4 3cid8 cid73 4 3cid8 cid74 4 3cid8 cid73 6 2cid8 cid73 7 2cid8 Element Time 002 362 81442 279 6105 Nodes Solutions 18628 2855281 561666863 3102719 70533119 8748 1269108 240375312 1551360 35266560 Table 5 Nodes second achieved antichain instances cid7n l dcid8 cid7100 5 2cid8 cid7100 10 2cid8 cid7100 20 2cid8 cid7100 30 2cid8 cid7100 40 2cid8 cid7100 50 2cid8 cid7100 5 10cid8 cid7100 10 10cid8 cid7100 20 10cid8 cid7100 30 10cid8 cid7100 40 10cid8 cid7100 50 10cid8 Watched OR 2235138 1350304 881230 656440 642652 487018 34469 38278 38545 41334 50679 67259 Watched OR Time 064 968 41689 44487 034 073 316 1568 18830 Nodes 8099 288377 7657223 167999 1845143 Watched OR Time 000 016 494 010 104 Sum 72777 59867 46601 49244 43464 45168 4223 3408 3959 4292 5650 6706 Nodes 77117 2189034 95301659 95301661 12349 75807 399997 1815755 47602427 Solutions 4050 144150 3823200 84000 922572 Watched Sum 98432 55210 64004 38665 37449 34352 3289 3495 3725 4185 5496 6939 Watched Sum The model Sum constraint implemented movable triggers cid3 b cid2 1 replaced SAT clause b1 bl We construct custom propagator experiment takes considerable effort concerned generic algorithms Similarly previous experiment Watched OR Sum Watched Sum models enforce equivalent GAC original expression Element Once consider Element model separately compare time nodes second In experiments search ﬁrst solution results given Table 3 These results closer pigeonhole problem On instances cid711 5 2cid8 Element model achieves sized search Watched OR However Element slower terms nodes second instances considered Furthermore Element exhibits larger number solutions Table 4 shows results ﬁnding solutions small set problems The number solutions Watched OR model correct number solutions Element duplicates solutions multiple times fact auxiliary variables multiple values solution problem This shows limitation Element model practice To compare models consider nodes second particular model solve averaged ﬁrst 100 seconds search In cases consider solving antichain problem 100 arrays n 100 varying length domain size C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1421 Table 6 Nodes second achieved Hamming instances Distance s Watched AtLeastK 49 45 40 30 20 10 5 3 2 1266001 5501206 5300573 15952897 18424749 7653180 150250971 173325503 172641528 Sum 1093219 5050898 5220072 5494308 5477075 2040595 161326 122618 116695 Watched Sum 174642 444696 949113 1933615 3090058 1328160 163926 123955 116650 A number conclusions drawn results experiment given Table 5 First algorithm performs compared Sum short vectors performance decreases length increases For example Boolean domains length 5 arrays algorithm 31 times faster decreasing 11 times length 50 We note larger domains nodes second increases problem size increases This common pigeonhole problem caused decrease proportion variables movable trigger This experiment partially supports hypothesis constraint trees movable triggers required eﬃ ciently propagate Or However algorithm static triggers constraint trees fully explored space 453 The Hamming codes problem In section consider Hamming codes 19 deﬁned Deﬁnition 16 The cid7n l d scid8 instance Hamming problem ﬁnd set n codewords length l alphabet 1 d pair codewords differ s positions This modelled follows We n arrays integers named M1 Mn length l domain 1 d k1l Mik cid12 M jk cid2 s We compare 3 repre following Hamming distance constraints j 1 n sentations constraint i1l Mi cid12 Ni cid2 s cid3 cid3 Watched ATLEASTK Directly represented Watched AtLeastK algorithm described Section 42 Sum Introduce array auxiliary Boolean variables bl add set constraints 1 l Mi cid12 Ni bi Then impose cid3 b cid2 s cid3 Watched Sum The model Sum constraint b cid2 s replaced watched sum constraint For problem attempt Element model preliminary experiments showed performance poor impossible usefully compare models All models enforce GAC child constraints AtLeastK share variables We experimented Hamming codes problem n l 50 d 2 Hamming distance s varied The results presented Table 6 As stated Section 42 expect Watched AtLeastK algorithm eﬃcient k small k s This supported Table 6 shows Watched AtLeastK performing better low values s high values However Watched AtLeastK dominates Sum Watched Sum values s At s 49 Watched AtLeastK watch child constraints little scope improve Sum In summary experiment provides evidence gains constraint trees movable triggers apply AtLeastK Or 454 The supertree problem The supertree problem 20 transforming input set rooted bifurcating trees species trees describing evolutionary history set species output tree respecting relationships input Various CP models created solve problem use model 21 optimisation model 22 Both consist entirely constraints form cid3 b c b cid3 c c cid3 b b c The standard model requires constraints satisﬁed optimisation model maximises number satisﬁed This modelled directly OrAnda cid3 b b c Andb cid3 c Andc cid3 b Anda b c b c Watched And Watched Or Note modelling require auxiliary variables The conjuncts disjuncts share variables GAC enforced Watched And Or propagators We compare Sum model We described Or handled sums Section 451 To represent And reify conjunct use sum constraint represent conjunction This encoding uses auxiliary variables enforces level consistency Watched Or And encoding We use instances Moore Prosser 22 input trees small load The model takes cubic space larger instances exceeded 2 GB RAM These partitioned solvable instances 1422 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 Table 7 Experimental data solvable supertree instances Instance Nodes Watched time Sum time AB AD AF AG BD BF BG CD CF DF 58 97 66 152 72 27 78 53 30 81 032 045 032 041 054 033 047 058 038 094 042 079 040 073 072 043 073 114 053 107 Table 8 Experimental data unsolvable supertree instances Instance AC BC CG DG Best sol 48 cons satisﬁed 27 13 43 Watched time 306309 359110 126482 376626 Sum time 1114644 2223587 236006 840440 Saving 2212 4224 2060 4387 2465 2436 3512 4850 2914 1276 Saving 7252 8385 4641 5519 instances input trees contain conﬂicting information tree 1 says b closer relatives c tree 2 says c closest The standard model solvable instances optimisation model unsolvable ones Table 7 shows watched model signiﬁcantly faster Sum solvable instances These times include time load instances load times larger Sum concise Table 8 presents results unsolvable instances We ran instances 2000000 nodes results favour watched model Using proﬁler discovered speedups increase propagation speed reduced cost creating setting backtracking additional auxiliary variables insigniﬁcant effect case In summary ﬁnal experiment shows Watched Or algorithm valuable combined parent constraint 5 Reiﬁcation The reiﬁcation constraint C produces constraint Cr Cr extra Boolean variable r scope solution r set true iff original constraint C satisﬁed def r C Cr Constraints combined arbitrary ways reiﬁcation For example consider exclusiveor set straints follows C1 C2 Cn An odd number constraints satisﬁed solution It straightforward represent structure reiﬁcation The constraints C1 Cn reiﬁed creating extra variables r1 rn These added sum constraint total variable constrained odd Previous work generic reiﬁcation Section 24 limited ways method use eﬃcient global propagators Régins AllDifferent 14 indexicals propia 1315 GAC propagation achieved 168 Our methods overcome limitations cost requiring propagators C C In section ways propagate reiﬁed constraints compare empirically The ﬁrst method uses static triggers The second method uses movable triggers complex overcomes apparent disadvantages ﬁrst method We investigate form reiﬁcation reifyimply reiﬁcation variable implies straint follows def r C Cri Again algorithm based checking movable trigger algorithm propagate reifyimplied constraints 51 Theoretical analysis Theorem 17 provides simple algorithm achieves GAC propagation r C given GAC propagator C C We shall consider different ways making algorithm eﬃcient incrementality In general C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1423 propagators C C different different complexities Lemma 18 shows propagator r C tractable propagators C C tractable Theorem 17 The following Algorithm 3 GAC propagation algorithm r C Boolean variable r constraint C assuming r scope C propagators C C achieve GAC propagation Input r C Domainr True False There satisfying assignment C r cid12 True end There satisfying assignment C r cid12 False end end Domainr True PropagateC Domainr False PropagateC end end Algorithm 3 GAC propagation algorithm reify Proof Consider following cases entering algorithm 1 Domainr TRUE FALSE In case check values r supported This requires ﬁnding assignment XC satisﬁes C assignment satisfy C If value unsupported removed algorithm continues case 2 If value r removed value domain variable scope C supported C C Any assignment variables C extended satisfying assignment r C adding r True r False depending assignment satisﬁes C C 2 Domainr contains single value In case domain r True r C exactly equivalent C domain r False constraint equivalent C cid2 Lemma 18 GACr C NPhard GACC GACC Proof Running GACC subdomain list removes domain values satisfying assignment C Therefore Theorem 17 demonstrates implement GACr C invocation GACC invocation GACC Therefore GACr C polynomial time GACC GACC By assigning r True False GACr C hard GACC GACC cid2 In paper reiﬁcation implemented constraint tree child constraints C C This raises issue shared variables child constraints discussed Section 242 However constraint tree propagator implements Algorithm 3 enforces GAC despite shared variables Theorem 19 presents basic algorithm implementing constraint r C We improve basic algorithm incrementality Theorem 19 The following Algorithm 4 GAC propagation algorithm r C Boolean variable r constraint C assuming r scope C propagator C achieves GAC Input r C Domainr True False There satisfying assignment C r cid12 True end Domainr True PropagateC end end Algorithm 4 GAC propagation algorithm reifyimply 1424 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 Proof This proof follows cases algorithm 1 Domainr TRUE FALSE In case value domain variable scope C supported assignment contains r False satisﬁes constraint Therefore value possibly eliminated r True This value allowed exists assignment XC satisﬁes C 2 Domainr contains single value In case domain r True constraint exactly equivalent C domain r False assignment satisﬁes constraint pruning occur cid2 52 Algorithms reiﬁcation reifyimply The following algorithms r C r C features common They phase checking entailmentdisentailment C r set necessary watching checking phase They phase propagating C C necessary propagation phase The movable trigger algorithms setup phase movable triggers placed ﬁrst time When describing algorithms C described child constraint object methods propagation checking disentailment checkUnsat satisfying set generator Checking disentailment equivalent checking satisfying set generator return Fail This means implemented eﬃciently Full reiﬁcation C child Child constraints receive trigger events passed parent 53 Watched reiﬁcation First implementing reiﬁcation movable triggers Following simple modiﬁca tions algorithm In scheme positive negative child constraints implement satisfying set generator Watched reiﬁcation phases described There sets triggers triggers required child constraints static trigger r movable triggers placed phases 1 2 watch satisfying sets Setup Phase If r assigned propagation phase Otherwise satisfying set generator child constraints If child returns Fail disentailed Set r appropriately propagation phase Otherwise place static triggers r movable triggers satisfying sets watching phase Watching Phase If r assigned propagation phase If domain value watched removed termine child belongs satisfying set generator child If returns Fail set r appropriately propagation phase If returns satisfying set place movable triggers remain phase Propagation Phase If r 1 propagate positive constraint propagate negative constraint Trigger events appropriate child constraint passed Since movable triggers backtracked possible receive stale trigger events movable triggers placed different phase Therefore watching propagation phases trigger events ignored handled specially These listed Watching Phase Trigger events propagation phase received phase case movable trigger removed event ignored Any trigger events belonging child constraints ignored Propagation Phase When propagating child constraint trigger events child ignored Movable trigger events setup watching phases ignored Notice movable triggers setup watching phases removed propagation phase When backtracking watching phase opportunity place movable triggers previous set present need replace The setup phase occurs propagator ﬁrst invoked The phases occur search use backtracking Boolean indicate phase algorithm This algorithm use fact disentailment C implies entailment C perform unnecessary propagation entailed child constraints We leave future work 531 Reifyimply We implemented watched reifyimply abstract Algorithm 4 As Algorithm 4 subset Algorithm 3 taking subset concrete algorithm described Section 53 This required removing child constraint C necessary check disentailment propagate C Also necessary trigger r assigned 1 propagation occurs r assigned 0 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1425 Table 9 Times counts steelmill instances Instance 40 50 60 70 80 90 Watched Time 212002 232973 283990 354202 448840 539012 Calls SSG 151 131 156 246 282 320 Static Time 218097 236271 288410 361998 462278 524809 Calls CU 1350922599 758088075 1193581857 1589486539 2525193986 2596608279 Overall Winner W 287 W 142 W 156 W 220 W 299 S 263 54 Static reiﬁcation We implement static variant reify reifyimply These use disentailment checker instead combination satisfying set generator movable triggers detect constraint disentailed Static reiﬁcation requires positive negative child constraints checkUnsat method checks constraint disentailed Before search begins static triggers positive negative constraints placed variables trigger reiﬁcation variable5 55 Empirical comparison reiﬁcation algorithms In section empirical comparison reify reifyimply watched static forms range realistic benchmark problems Notice checkUnsat CU static reiﬁcation satisfying set generators SSG watched reiﬁcation perform similar tasks Both determine constraint disentailed Satisfying set generators additionally return satisfying set literals constraint disentailed For reiﬁed reifyimplied constraints benchmarks functions equivalent determining disentailment Hence static watched algorithms provide level consistency solver explores number search nodes benchmarks One metric use compare static watched algorithms number calls CU SSG Consider hypothetical solver offers triggers static watched individual domain values CU static triggers value important time search SSG able place watches search In solver SSG called times CU In cases carries Minion Minion assignment triggers available SSG For movable triggers potential number calls SSG substantially fewer cost calling somewhat higher additional overhead placing movable triggers The methodology hardware following experiments described Section 45 551 Steel slab design Our ﬁrst benchmark consists instances steel slab design problem 23 This wellknown optimisation problem involving assigning orders steel slabs minimising total waste Our instances include reifyimplied lex ordering constraints rows 01 matrix constraints break symmetry rows reifyimplied switched row corresponding slab needed fulﬁl set orders Our evaluation instances exhibits solid results favour watched reifyimply Table 9 shows exceptional decrease calls SSG compared CU watched versus static reifyimply running instances 100000000 nodes Here billions calls CU compared hundreds SSG In fact ﬁrst 100 nodes search examples movable triggers hardly moved Instance 90 typical ﬁrst 100 nodes SSG called 260 times 10000 nodes called 301 times 1000000 nodes called 315 times For instance CU called 60 times node average 1000000 nodes This dramatic improvement movable triggers rarely triggered watched variant static variant bound triggers woken frequently constraint remains satisﬁable SSG needs place movable triggers values scope lexleq needed ensure remains satisﬁable CU bound triggers variables scope constraint Table 9 shows improvement calls translates improvement solution time This improvement rela tively small absolute terms time spent propagating constraints reifyimply With aid proﬁler discovered benchmark 90 average SSG lexicographic ordering constraint consumes 2695 CPU instructions average CU consumes 54 These statistics im pression SSG movable triggers triggered substantially static triggers justify cost case 50 times additional overhead placing dynamic triggers literals 5 Our implementation static reiﬁcation allow children use movable triggers 1426 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 Fig 3 Comparison calls SSG CU blackhole problems Fig 4 Comparison time spent blackhole problems 552 Blackhole solitaire Blackhole solitaire 24 singleplayer card game The initial layout 17 stacks 3 cards cards visible There special stack containing ace spades initially named black hole Cards moved stack black hole game completed 51 cards moved black hole The card moved adjacent previous card black hole regardless suit adjacency wraps king adjacent ace A solution sequence 51 valid moves Our model blackhole solitaire contains reifyimplied lessthan constraints r x1 x2 The lessthan constraint places static triggers lower bound x1 upper bound x2 SSG returns movable triggers lower bound x1 upper bound x2 When bounds restored backtracking movable triggers longer bounds This effect allows SSG called fewer times CU benchmarks The model contains reiﬁed lessthan sumgreater constraints propagated statically cases inﬂuence results As shown Fig 3 total number calls SSG constraints smaller number calls CU instance blackhole tried The black line plot line y x10 10 times better line points beneath line use 10 times calls CU SSG static watched reifyimply respectively Using proﬁler discovered mean number CPU instructions SSG 54 versus 9 instructions CU meaning ratio CU SSG 6 dynamic reifyimply chance winning This account time additionally place watches Fig 4 shows ratio 10 suﬃcient static algorithm slightly faster benchmark 553 Contrived benchmark We use reiﬁed allDifferent constraint contrived problem intended demonstrate potential watched reiﬁca tion We expect watched reiﬁcation perform movable triggers settle values rarely removed This effect observed watched reifyimply steel slab design problem Problem instances generated positive integer k consist kvectors X Y mains 1 k The constraints follows 1 k 2 Xi cid12 Y Xk 1 cid12 Xk Xk 1 Xk r allDifferentY C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1427 Fig 5 Comparison time spent English peg solitaire instances The allDifferent constraint uses GAC algorithm 25 maintains matching variables distinct values SSG positive constraint returns kmatching exists movable trigger variable X For static reify CU called domain change CU similar SSG maintains maximal matching algorithm SSG The negative constraint waits variables assigned checks assignment6 SSG negative constraint places movable triggers different values unassigned variable possible If variables assigned SSG checks constraint disentailed CU requires assignment trigger variable The variable ordering X index order values branched ascending order Xk consistently assigned restriction rest X solver explores kk1 assignments X1 k 1 Whenever variable Xi set j 2 j removed Y notequal constraint Therefore odd values Y removed movable triggers settle We ran instance k 20 node limit 10000000 Watched reify 2509 calls SSG compared 10526315 calls CU With static reify Minion took 5082 s watched reify took 5016 s Using callgrind proﬁler node limit 500000 Minion uses 660 bn CPU instructions static reify 642 bn watched reify The static reify propagator uses 193 m instructions compared 790 m watched reify propagator This clearly shows cost outside reiﬁcation watched reify performing better static variant expect counts 554 English peg solitaire Finally consider game English peg solitaire 26 played 32 pegs placed board 33 holes Pegs removed hopping moves similar checkersdraughts goal state reached moves possible We use model C Jefferson et al 26 slightly adapted suit Minion ILOG Solver These benchmarks contain large number reiﬁed sum constraints The constraints state sum Boolean variables 1 The length sum ranges 1 8 variables We 33 instances different goals All instances run node limit 10000000 Fig 6 shows instances number calls SSG watched reiﬁcation usually half calls CU static reiﬁcation However Fig 5 shows static reiﬁcation faster instances We proﬁler callgrind instance solitaire_benchmark_6 takes 40 s static reiﬁcation Minion uses 712 billion CPU instructions static reiﬁcation 781 watched Static reify uses 218 bn watched reify uses 265 increase 227 555 Conclusion empirical comparison The results experiments conclusive demonstrating different implementations perform better dif ferent constraints problems In cases shown potential movable triggers approach demonstrating SSG function called CU On hand static reiﬁcation reifyimply simple fast cases faster watched variant 6 The standard implementation Minion 010 Watched Or equal constraints pairs variables Unfortunately Watched Or incompatible static reiﬁcation algorithm experiment Watched Or replaced assignment checker 7 Changing reiﬁcation algorithm changes propagation order affects constraints In case difference reify 48 bn solver 69 bn 1428 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 Fig 6 Comparison calls SSG CU English peg solitaire instances 6 Conclusion In paper explored possibilities implementing logical connectives constraint solver overall hypothesis movable triggers constraint trees invaluable These solver features combined satisfying set generators provide eﬃcient way checking satisﬁability constraint First focused AtLeastK Or And arbitrary constraints The ubiquitous way modelling CP reifying constraints applying sumcid2 k constraint equivalent reiﬁcation variables With approach solver required propagate reiﬁed constraints times By contrast Watched AtLeastK algorithm present k 1 active constraints time zero cost Using approach Hamming codes able demonstrate 2000 times speedup instances compared reiﬁcation We presented Watched Or specialisation Watched AtLeastK In evaluation observed Watched Or 10000 times faster reiﬁcation consistently faster problems tested By implementing satisfying set generators Watched AtLeastK Or And parent constraints arbitrarily nested giving rich language logical expressions We hope extend work logical connectives achieve GAC case child constraints share variables maintaining high performance Secondly investigated ways implementing reiﬁcation reifyimply constraint We described simple algorithms use static triggers sophisticated algorithms use movable triggers reduce number constraint checks In experiments results mixed In cases simple static algorithms faster watched algorithms paid additional overhead eﬃcient The common thread paper movable triggers satisfying sets constraint trees allow simple eﬃcient implementation logical connectives constraints Once constraint satisfying set generator usually simpler propagation function Watched Or parent constraints reiﬁed reifyimplied This makes simple general compelling framework implementing logical connectives Acknowledgements We like thank anonymous reviewers helpful comments earlier version paper This work funded EPSRC research grant numbers EPC5232291 Jefferson EPH0040921 Jefferson Nightingale Petrie EPE0303941 Moore Nightingale Royal Society Dorothy Hodgkin Fellowship Petrie References 1 IP Gent C Jefferson I Miguel Watched literals constraint propagation minion F Benhamou Ed CP Lecture Notes Computer Science vol 4204 Springer 2006 pp 182197 2 KR Apt Principles Constraint Programming Cambridge University Press 2003 3 F Rossi P van Beek T Walsh Eds Handbook Constraint Programming Elsevier 2006 4 IP Gent C Jefferson I Miguel Minion A fast scalable constraint solver G Brewka S Coradeschi A Perini P Traverso Eds ECAI Frontiers Artiﬁcial Intelligence Applications vol 141 IOS Press 2006 pp 98102 5 S Brand RHC Yap Towards propagation logic control S Etalle M Truszczynski Eds ICLP Lecture Notes Computer Science vol 4079 Springer 2006 pp 102116 6 T Müller J Würtz Constructive disjunction Oz Workshop Logische Programmierung WLP GMDStudien vol 270 Gesellschaft für Mathe matik und Datenverarbeitung MBH 1995 pp 113122 7 J Würtz T Müller Constructive disjunction revisited G Görz S Hölldobler Eds German Conference Artiﬁcial Intelligence KI LNCS vol 1137 Springer 1996 pp 377386 8 MZ Lagerkvist C Schulte Propagator groups IP Gent Ed CP Lecture Notes Computer Science vol 5732 Springer 2009 pp 524538 C Jefferson et al Artiﬁcial Intelligence 174 2010 14071429 1429 9 F Bacchus T Walsh Propagating logical combinations constraints LP Kaelbling A Saﬃotti Eds IJCAI Professional Book Center 2005 pp 35 40 10 O Lhomme An eﬃcient ﬁltering algorithm disjunction constraints F Rossi Ed CP Lecture Notes Computer Science vol 2833 Springer 2003 pp 904908 11 O Lhomme Arcconsistency ﬁltering algorithms logical combinations constraints JC Régin M Rueher Eds CPAIOR Lecture Notes Computer Science vol 3011 Springer 2004 pp 209224 12 MW Moskewicz CF Madigan Y Zhao L Zhang S Malik Chaff engineering eﬃcient sat solver DAC 01 Proceedings 38th Annual Design Automation Conference ACM New York NY USA 2001 pp 530535 13 PV Hentenryck V Saraswat Y Deville Constraint processing ccfd Technical report Brown University 1991 14 JC Régin A ﬁltering algorithm constraints difference CSPs Proceedings 12th National Conference Artiﬁcial Intelligence AAAI 94 1994 pp 362367 15 A Aggoun D Chan P Dufresne E Falvey H Grant W Harvey A Herold G Macartney M Meier D Miller S Mudambi S Novello B Perez E van Rossum J Schimpf K Shen PA Tsahageas DH Villeneuve Eclipse user manual release 510 httpeclipseclporg 2006 16 C Schulte Programming deep concurrent constraint combinators Proceedings Practical Aspects Declarative Languages PADL 2000 LNCS vol 1753 Springer 2000 pp 215229 17 C Bessiere E Hebrard B Hnich T Walsh The complexity reasoning global constraints Constraints 12 2 2007 239259 18 C Jefferson Representations constraint programming PhD thesis University York 2007 19 CJ Colbourn JH Dinitz Handbook Combinatorial Designs second edition Discrete Mathematics Its Applications Chapman HallCRC 2006 20 P Daniel C Semple Supertree algorithms nested taxa O BinindaEmonds Ed Phylogenetic Supertrees Combining Information Reveal Tree Life Computational Biology Series Kluwer 2004 pp 151171 21 IP Gent P Prosser BM Smith W Wei Supertree construction constraint programming F Rossi Ed CP Lecture Notes Computer Science vol 2833 Springer 2003 pp 837841 22 NC Moore P Prosser The ultrametric constraint application phylogenetics Journal Artiﬁcial Intelligence Research 32 2008 901938 23 AM Frisch I Miguel T Walsh Modelling steel slab design problem IJCAI01 Workshop Modelling Solving Problems Constraints 2001 pp 3945 24 IP Gent C Jefferson T Kelsey I Lynce I Miguel P Nightingale BM Smith Search patience game black hole AI Communications 20 3 2007 211226 25 IP Gent I Miguel P Nightingale Generalised arc consistency alldifferent constraint An empirical survey Artiﬁcial Intelligence 172 18 2008 19732000 26 C Jefferson A Miguel I Miguel A Tarim Modelling solving English peg solitaire Computers Operations Research 33 10 2006 29352959