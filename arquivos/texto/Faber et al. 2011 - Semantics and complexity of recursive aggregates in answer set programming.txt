Artiﬁcial Intelligence 175 2011 278298 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Semantics complexity recursive aggregates answer set programming Wolfgang Faber Gerald Pfeifer Nicola Leone Department Mathematics University Calabria 87030 Rende CS Italy r t c l e n f o b s t r c t Article history Available online 3 April 2010 Keywords Nonmonotonic reasoning Answer set programming Aggregates Computational complexity The addition aggregates relevant enhancements language answer set programming ASP They strengthen modelling power ASP terms natural concise problem representations Previous semantic deﬁnitions typically agree case nonrecursive aggregates picture clear aggregates involved recursion Some proposals explicitly avoid recursive aggregates differ satisfy desirable criteria minimality coincidence answer sets aggregatefree case In paper deﬁne semantics programs arbitrary aggregates including monotone antimonotone nonmonotone aggregates ASP language allowing disjunction head disjunctive logic programming DLP This semantics genuine generalization answer set semantics DLP deﬁned natural variant GelfondLifschitz transformation treats aggregate nonaggregate literals uniform way This novel transformation interesting se aggregatefree case simpler original transformation need differentiate positive negative literals We prove semantics guarantees minimality incomparability answer sets demonstrate coincides standard answer set semantics aggregatefree programs Moreover carry indepth study computational complexity language The analysis pays particular attention impact syntactical restrictions programs form limited use aggregates disjunction negation While addition aggregates affect complexity DLP language turns presence increase complexity normal nondisjunctive ASP programs second level polynomial hierarchy However large classes aggregates addition cause complexity gap normal programs including fragment allowing arbitrary monotone arbitrary antimonotone stratiﬁed nonrecursive nonmonotone aggregates The analysis provides useful indications possibility implement aggregates existing reasoning engines 2010 Elsevier BV All rights reserved Parts work published preliminary form proceedings conferences JELIA04 Faber et al 2004 1 IJCAI05 Calimeri et al 2005 2 Corresponding author Email addresses fabermatunicalit W Faber geraldpfeifercom G Pfeifer leonematunicalit N Leone 00043702 matter 2010 Elsevier BV All rights reserved doi101016jartint201004002 W Faber et al Artiﬁcial Intelligence 175 2011 278298 279 1 Introduction Around 1960 McCarthy proposed use logical formulas basis knowledge representation language 34 It soon realized classical logic adequate model commonsense reasoning 5 As alterna tive suggested represent commonsense reasoning logical languages nonmonotonic consequence relations allow new knowledge invalidate previous conclusions This observation led velopment investigation new logical formalisms nonmonotonic logics The famous circumscription 67 default logic 8 nonmonotonic modal logics 911 More recently cross fertilizations ﬁeld nonmonotonic logics logic programming nonmonotonic language called Answer Set Programming ASP 1213 emerged Answer Set Programs 1213 called Disjunctive Logic Programs DLP 14 logic programs nonmonotonic negation occur bodies disjunction occur heads rules This language expressive precise mathematical sense allows express property ﬁnite structures decidable complexity class 2 NPNP 15 The high expressive power language simplicity availability number Σ P eﬃcient ASP systems 1623 encouraged usage ASP investigation new constructs enhancing capabilities One relevant improvements language answer set programming addition aggregates 2437 Aggregates signiﬁcantly enhance language answer set programming ASP allowing natural concise mod elling problems Nonrecursive called stratiﬁed aggregates clear semantics capture large class meaningful problem speciﬁcations However relevant problems recursive unstratiﬁed aggregate formulations natural Company Control problem illustrated typical example cf 242629 Example 11 We given set facts predicate company X denoting companies involved set facts predicate ownsStkC 1 C 2 Perc denoting percentage shares company C 2 owned company C 1 Then company C 1 controls company C 2 sum shares C 2 owned directly C 1 companies controlled C 1 50 This problem encoded following program Pctrl authors literature 2426291 controlsStkC 1 C 1 C 2 P ownsStkC 1 C 2 P controlsStkC 1 C 2 C 3 P companyC 1 controlsC 1 C 2 ownsStkC 2 C 3 P controlsC 1 C 3companyC 1 companyC 3 cid2 sum cid3 P C 2 controlsStkC 1 C 2 C 3 P 50 Intuitively controlsStkC 1 C 2 C 3 P denotes company C 1 controls P percent C 3 shares company C 2 C 1 controls C 2 C 2 owns P percent C 3 shares Predicate controlsC 1 C 2 encodes company C 1 controls company C 2 For companies c1 c3 controlsc1 c3 derived sum elements multiset P C 2 controlsStkc1 C 2 c3 P greater 50 Note adopted DLV syntax multiset expressed P C 2 controlsStkc1 C 2 c3 P variable C 2 avoids duplicate occurrences P eliminated The encoding Company Control contains recursive aggregate predicate controlsStk aggregate depends head predicate controls Unfortunately recursive aggregates easy handle semantics straightforward Example 12 Consider following programs cid2 cid2 pacount cid3 X pX cid3 0 P 1 cid2 cid2 pacount cid3 X pX cid3 1 P 2 In cases pa atom p true intuitively following closedworld assumption expect count X p X 0 true iff pa true count X p X 1 true iff pa false Thus programs respectively behave like following standard programs cid2 cid3 papa cid4 1 P cid2 cid3 panot pa cid4 2 P This case literature debate best semantics recursive aggregates There attempts deﬁning suitable semantics recursive aggregates 2527303437 However previous semantic deﬁnitions typically agree nonrecursive case picture clear recursion Some 1 Throughout paper adopt concrete syntax DLV language 38 express aggregates examples 280 W Faber et al Artiﬁcial Intelligence 175 2011 278298 proposals explicitly avoid recursive aggregates differ satisfy desirable criteria minimality2 For detailed analysis refer Section 5 In paper step forward provide fully declarative semantics works disjunctive programs arbitrary aggregates Moreover carry indepth analysis computational complexity ASP aggre gates pays particular attention impact syntactical restrictions programs form limited use aggregates disjunction negation The main contributions paper following We provide deﬁnition answer set semantics disjunctive programs arbitrary aggregates including monotone aggregates antimonotone aggregates aggregates monotone antimonotone This semantics fully declarative given standard way answer sets generalization wellknown GelfondLifschitz transformation treats aggregate nonaggregate literals uniform way This novel trans formation interesting se aggregatefree case simpler original transformation differentiate types literals positive negative program Interestingly generality transformation allows deﬁning semantics arbitrary linguistic extensions ASP applied contexts Section 5 We study properties proposed semantics following results Our answer sets subsetminimal models incomparable generally seen important property nonmonotonic semantics 3229 For aggregatefree programs semantics coincides standard answer set semantics From semantic viewpoint monotone aggregate literals analogous positive standard literals antimono tone aggregates analogous negative standard literals We provide rewriting standard logic programs negation positive programs antimonotone aggregate atoms We carry indepth analysis computational complexity disjunctive programs polynomialtime com putable aggregate functions fragments thereof deriving picture complexity ASP languages negation andor disjunction combined different kinds aggregates monotone antimonotone nonmono tone stratiﬁed3 The analysis brings interesting results including following The addition aggregates increase complexity ASP language Cautious reasoning ASP programs disjunction negation including considered types aggregates monotone antimonotone nonmonotone unstratiﬁed remains Π P 2 complete standard DLP The cheapest aggregates complexity viewpoint monotone ones addition cause complexity increase negationfree programs unstratiﬁed monotone aggregates The hardest aggregates complexity viewpoint nonmonotone ones nondisjunctive pos itive programs deﬁnite horn clauses addition causes big complexity jump P Π P 2 Instead antimonotone aggregates behave like negation nondisjunctive positive programs presence increases complexity P coNP The largest set aggregates added nondisjunctive ASP inducing complexity overhead consists arbitrary monotone arbitrary antimonotone stratiﬁed nonmonotone aggregates When adding kinds aggregates nondisjunctive ASP complexity reasoning remains coNP Importantly mentioned complexity results valuable information intertranslatability differ ent languages having relevant implications possibility implement aggregates existing reasoning engines rewritingbased techniques like employed ASSAT 39 Cmodels 20 implementation Section 42 The sequel paper organized follows Section 2 deﬁnes syntax formal semantics based A notion answer set DLP Section 4 carries computational complexity analysis Section 5 discusses related work Section 6 draws conclusion extension DLP aggregates Section 3 studies semantic properties DLP A 2 The DLP A language In section provide formal deﬁnition syntax semantics DLP language extension Disjunctive Logic Programming DLP setoriented functions called aggregate functions For background DLP refer 1318 A 2 The subsetminimality answer sets holds aggregatefree case main nonmonotonic logics 31 guarantees answer sets incomparable allows deﬁne transitive closure impossible minimality lost 29 3 Note results mentioned refer complexity propositional programs In Section 42 discuss complexity nonground programs W Faber et al Artiﬁcial Intelligence 175 2011 278298 281 21 Syntax We assume sets variables constants predicates given Similar Prolog assume variables strings starting uppercase letters constants integers strings starting lowercase letters Predicates strings starting lowercase letters symbols socalled builtin predicates ﬁxed meaning An arity nonnegative integer associated predicate Standard atoms literals A term variable constant A standard atom expression pt1 tn p predicate arity n t1 tn terms A standard literal L standard atom A case positive standard atom A preceded default negation symbol case negative A conjunction standard literals form L1 Lk Li 1 cid2 cid2 k standard literal An expression standard atom standard literal conjunction ground expression subexpressions contain variables A set term symbolic set ground set A symbolic set pair Vars Conj Vars Set terms A DLP list variables Conj conjunction standard atoms4 A ground set set pairs form cid6t Conjcid7 t list constants Conj ground variable free conjunction standard atoms Aggregate functions An aggregate function form f S S set term f aggregate function symbol Intuitively aggregate function thought possibly partial function mapping multisets5 constants constant Example 21 The following aggregate functions common currently supported DLV min minimal term undeﬁned set max maximal term undeﬁned set count number terms sum sum integers times product integers Aggregate literals An aggregate atom f ST f S aggregate function cid2 cid3 cid9 comparison operator T term variable constant We note choice notation aggregate atoms primarily motivated readability One deﬁne aggregate atoms arbitrary relation sequence aggregate functions terms In fact aggregates DLV cardinality weight constraints Smodels form T f SU semantically shorthand conjunction T f S f SU Example 22 The following aggregate atoms DLV notation contains ground set ground instance cid3 Z rZ aZ V cid5 cid2cid4 2 r2 a2 x Y 2 r2 a2 y cid2 max max 1 cid5cid3 cid4 An atom standard DLP atom aggregate atom A literal L atom A atom A preceded default negation symbol A aggregate atom L aggregate literal A DLP programs A DLP A rule r construct a1 anb1 bk bk1 bm a1 standard atoms b1 bm atoms n cid3 0 m cid3 k cid3 0 n m 0 The disjunction a1 referred head r conjunction b1 bk bk1 bm body r Let Hr a1 r Furthermore let P redσ denote set r b1 bk B B predicates occur σ σ program rule set atoms literals atom literal Whenever A clear set element standard atoms literals Predσ denote single predicate A DLP program set DLP r bk1 bm Br B r B rules A 211 Syntactic properties A local variable r variable appearing solely aggregate function r variable r local called global A nested atom r atom appearing aggregate atom r atom r nested called unnested 4 Intuitively symbolic set X X Y pY stands set X values making X Y pY true X Y st X Y pY true 5 Note aggregate functions evaluated valuation ground set wrt interpretation multiset cf Section 22 282 W Faber et al Artiﬁcial Intelligence 175 2011 278298 Deﬁnition 21 Safety A rule r safe following conditions hold global variable r appears positive standard unnested literal body r ii local variable r appears symbolic set Vars Conj appears Conj Finally program safe rules safe Condition standard safety condition adopted datalog guarantee variables range restricted 40 Condition ii speciﬁc aggregates pXqX Y V Example 23 Consider following rules cid2 Y max cid2 Y sum cid2 T min pXqX Y V pXqX Y V cid3 Z rZ aZ V cid3 Z aX S cid3 Z rZ aZ V The ﬁrst rule safe second local variables Z violates condition ii The rule safe global variable T violates condition Deﬁnition 22 Aggregatestratiﬁcation A DLP cid12 cid12 PredP ordinals rule r P PredHr following holds program P stratiﬁed aggregate atom A exists level mapping A 1 For b PredBr cid12bcid12 cid2 cid12acid12 2 A Br b Pred A cid12bcid12 cid12acid12 3 b PredHr cid12bcid12 cid12acid12 A A DLP program P aggregatestratiﬁed stratiﬁed aggregate atoms P Intuitively aggregatestratiﬁcation forbids recursion aggregates While semantics aggregatestratiﬁed pro grams agreed different disagreeing semantics aggregateunstratiﬁed programs deﬁned past instance discussion 29 In paper shall provide novel characterization directly extends wellknown formulations semantics aggregatefree programs Example 24 Consider program consisting set facts predicates b plus following rules cid2 qXpX count cid3 Y aY X bX cid2 2 pXqX bX The program stratiﬁed countY aY X b X cid2 2 level mapping cid12acid12 cid12bcid12 1 cid12pcid12 cid12qcid12 2 satisﬁes required conditions The program aggregatestratiﬁed If add rule b Xp X levelmapping exists program aggregateunstratiﬁed Deﬁnition 23 Negationstratiﬁcation A program P called negationstratiﬁed 4142 exists level mapping cid12 cid12n PredP rule r P PredHr following holds 1 For b PredBr cid12bcid12 cid2 cid12acid12 2 standard literal L B 3 b PredHr cid12bcid12 cid12acid12 r cid12PredLcid12 cid12acid12 We note dealing ground programs consider program ground standard atom replaced unique predicate arity 0 This program clearly equivalent original program modulo renaming One consider rewritten program determining aggregate negationstratiﬁcation Example 25 Consider following ground program panot pb pacount c pc 0 cid2cid4 cid5cid3 While aggregatestratiﬁed negationstratiﬁed according deﬁnition considers predicate symbol p renamed variant panot pb cid2 pacount cid3 cid6c pccid7 0 aggregatestratiﬁed negationstratiﬁed consider original program aggregatestratiﬁed negationstratiﬁed W Faber et al Artiﬁcial Intelligence 175 2011 278298 283 22 Semantics program P let U P denote set constants appearing P BP set Universe base Given DLP standard atoms constructible standard predicates P constants U P Given set X let 2 X denote set multisets elements X Without loss generality assume aggregate functions map Z set integers A Example 26 Let look common domains aggregate functions Example 21 count deﬁned 2U P sum 2 min max deﬁned 2 times 2 Z Z Z Instantiation A substitution mapping set variables U P A substitution set global variables rule r U P global substitution r substitution set local variables symbolic set S U P local substitution S Given symbolic set global variables S Vars Conj instantiation S following ground set pairs instS cid5 cid6 cid6 γ local substitution S γ Vars γ Conj cid3 6 cid2cid4 A ground instance rule r obtained steps 1 global substitution σ r ﬁrst applied r 2 symbolic set S σ r replaced instantiation instS The instantiation GroundP program P set possible instances rules P Example 27 Consider following program P1 q1 p2 2 q2 p2 1 tXqX sum cid2 cid3 Y pX Y 1 Here U P1 1 2 instantiation GroundP1 following q1 p2 2 q2 p2 1 t1q1 sum t2q2 sum cid4 cid2cid4 cid2cid4 cid5 1 p1 1 cid5 1 p2 1 cid4 2 p1 2 2 p2 2 cid5cid3 cid5cid3 1 1 program P set standard ground atoms I BP A standard ground atom Interpretation An interpretation DLP true wrt interpretation I denoted I cid15 I false wrt I A standard ground literal true wrt interpretation I denoted I cid15 I cid9cid15 false wrt I A An interpretation provides meaning ground sets aggregate functions aggregate literals multiset value truth value respectively Let f S aggregate function The valuation IS S wrt I multiset IS deﬁned follows Let S I cid6t1 tncid7 cid6t1 tn Conjcid7 S Conj true wrt I IS multiset obtained projection tuples S I ﬁrst constant IS t1 cid6t1 tncid7 S I The valuation I f S aggregate function f S wrt I result application f 7 IS If multiset IS domain f I f S ﬁxed symbol occurring P An instantiated aggregate atom A f Sk true wrt interpretation I denoted I cid15 A I f S cid9 ii I f Sk holds8 A false An instantiated aggregate literal A f Sk true wrt interpretation I denoted I cid15 A I f S cid9 ii I f Sk hold A false Example 28 Let I interpretation f 1 g1 2 g1 3 g1 4 g2 4 h2 h3 h4 With respect inter pretation I assuming variables local check count X g X Y 2 false S I corresponding ground set cid61cid7 cid62cid7 IS 1 2 count X Y g X Y 2 true S I cid61 2cid7 cid61 3cid7 cid61 4cid7 cid62 4cid7 IS 1 1 1 2 23 timesY f X g X Y cid2 24 true case S I cid62cid7 cid63cid7 cid64cid7 IS 2 3 4 sum A g A B hB cid2 3 true S I cid61cid7 cid62cid7 IS 1 2 sum1 2 3 sum A B g A B hB cid2 3 cid62 4cid7 S I cid61 2cid7 cid61 4cid7 cid61 3cid7 false IS 1 1 1 2 count1 2 2 count1 1 1 2 4 times2 3 4 24 sum1 1 1 2 5 min X f X g X cid3 2 false evaluation instantiation X f X g X wrt I yields set belong domain min Imin 6 Given substitution σ DLP 7 We assume f ﬁxed interpretation 8 Again assume ﬁxed interpretation A object Obj rule set denote σ Obj object obtained replacing variable X Obj σ X 284 W Faber et al Artiﬁcial Intelligence 175 2011 278298 A rule r satisﬁed wrt I denoted I cid15 r head atom true wrt I h Hr I cid15 h body literals true wrt I b Br I cid15 b Example 29 Consider atom A sumcid61 p2 1cid7 cid62 p2 2cid7 1 Example 27 Let S ground set A For interpretation I q2 p2 2 t2 IS 2 application sum 2 yields 2 I cid15 A 2 1 Deﬁnition 24 A ground literal cid6 monotone interpretations I J I J I cid15 cid6 implies J cid15 cid6 antimonotone interpretations I J I J nonmonotone monotone antimonotone J cid15 cid6 implies I cid15 cid6 Note positive standard literals monotone negative standard literals antimonotone Aggregate literals monotone antimonotone nonmonotone regardless positive negative Example 210 All ground instances following aggregate literals monotone cid2 count cid3 Z rZ 1 cid2 count cid3 Z rZ 1 following antimonotone cid2 count cid3 Z rZ 1 cid2 count cid3 Z rZ 1 Nonmonotone literals include sum possibly negative integers average Also monotone antimono tone functions combined equality operator yield nonmonotone literals decomposed conjunction monotone antimonotone aggregate 23 Answer sets A We deﬁne notion answer sets DLP programs While usually ﬁrst deﬁning notion answer sets positive programs coinciding minimal model semantics negative programs stability condition reduct aggregates considered notions positive negative literals general clear If monotone antimonotone aggregate atoms considered simply treat monotone literals like positive literals antimonotone literals like negative ones follow standard approach hinted 29 Since consider nonmonotone aggregates categorization feasible rely deﬁnition employs stability condition reduct The subsequent deﬁnitions directly based models An interpretation M model DLP program P denoted M cid15 P M cid15 r rules r GroundP An interpretation M subsetminimal model P I M model GroundP A Example 211 It veriﬁed q2 p2 2 t2 model program Example 27 Next provide transformation reduct ground program wrt interpretation formed Note deﬁnition generalization GelfondLifschitz transformation DLP programs Theorem 36 The intuition similar Treating interpretation assumption create program relevant according given interpretation In particular consider rule body satisﬁed irrelevant Deﬁnition 25 Given ground DLP P deleting rules body literal false wrt I A program P interpretation I let P I denote transformed program obtained P I cid2 r cid6 cid6 r P b Br I cid15 b cid3 Example 212 Consider Example 12 GroundP 1 GroundP 2 cid2 cid2 pacount pacount cid2cid4 cid2cid4 pa pa cid5cid3 cid5cid3 cid3 cid3 0 1 With interpretations I1 pa I2 obtain W Faber et al Artiﬁcial Intelligence 175 2011 278298 285 GroundP 1I1 GroundP 1 GroundP 1I2 GroundP 2I1 GroundP 2I2 GroundP 2 We ready formulate stability criterion answer sets Deﬁnition 26 Answer sets DLP subsetminimal model GroundP A A programs Given DLP A program P interpretation A P answer set It noted deﬁnition grasps original motivation answer sets stable models interpre tation stable model answer set nonredundant explanation program relevant Looking particular aggregates observe aggregates treated black boxes monoliths checking stability present entirety missing altogether This main distinguishing features semantics Indeed Section 5 discuss approaches semantics programs containing aggregates treat aggregates monoliths It worth noting deﬁnition general treats atoms black boxes In fact applicable programs containing arbitrary forms atoms long satisfaction interpretation determined That means syntax adopted aggregate literals irrelevant deﬁnition deﬁnition cf Section 5 programs containing arbitrary kinds atoms Example 213 For programs Example 12 I2 Example 212 answer set P 1 I1 minimal model GroundP 1I1 P 2 admits answer set I1 minimal model GroundP 2I1 I2 model GroundP 2 GroundP 2I2 For Example 11 following input facts companya companyb companyc ownsStka b 40 ownsStkc b 20 ownsStka c 40 ownsStkb c 20 set A controlsStka b 40 controlsStka c 40 controlsStkb b c 20 controlsStkc c b 20 omitting facts answer set means company controls company Note A1 A controlsa b controlsa c controlsStka b c 20 controlsStka c b 20 answer set reasonable basis truth literals A1 A This deﬁnition somewhat simpler deﬁnitions given 4332 In particular different 32 deﬁne answer programs transforming positive program sets directly notion models DLP 3 Semantic properties A We ﬁrst note simple consequences Deﬁnition 26 Proposition 31 Any answer set A DLP A program P model P Proof Since GroundP A GroundP A satisﬁes rules GroundP A rules GroundP GroundP A satis ﬁed wrt A deﬁnition GroundP A cid2 Moreover answer set answer set program reduct Proposition 32 Any answer set A DLP A program P answer set GroundP A Proof We note GroundGroundP A GroundP A GroundP A A GroundP A Since A answer set P subsetminimal model GroundP A GroundGroundP A A cid2 A generally desirable important property nonmonotonic semantics minimality 3229 particular semantics reﬁne notion minimal models We semantics property Theorem 33 Answer sets DLP A program P subsetminimal models P 286 W Faber et al Artiﬁcial Intelligence 175 2011 278298 Proof Our proof contradiction Assume I1 model P I2 answer set P I1 I29 Since I2 answer set P subsetminimal model GroundPI2 Deﬁnition 26 Therefore I1 model GroundPI2 I2 subsetminimal model GroundPI2 Thus rule r GroundPI2 satisﬁed wrt I1 Since GroundPI2 GroundP r GroundP I1 model P contradicting assumption cid2 As consequence theorem incomparability answer sets Corollary 34 Answer sets DLP A program P incomparable wrt set inclusion Theorem 33 reﬁned DLP A programs containing monotone literals Theorem 35 The answer sets DLP A program P P contains monotone literals precisely minimal models P A program containing monotone literals I minimal model P Clearly I Proof Let P DLP model P I We proceed contradiction J I model P I Assume model J P exists satisﬁes rules GroundPI All rules GroundP GroundPI satisﬁed I body false wrt I But P contains monotone literals false literal I false J I J satisﬁes rules GroundP GroundPI model P contradicting assumption I minimal model Together Theorem 33 result follows cid2 Clearly desirable feature semantics extended language properly extends agreedupon se mantics base language semantics equal base language Therefore DLP programs semantics coincides standard answer set semantics Note semantics proposed programs aggregates meet requirement cf 29 Theorem 36 Given DLP program P interpretation I answer set P according Deﬁnition 26 iff answer set P according standard deﬁnition classic GelfondLifschitz transformation 12 cid4cid4 Proof Assume I answer set wrt Deﬁnition 26 I minimal model GroundPI Let denote cid4 GLGroundP I standard GelfondLifschitz transformed program GLGroundP I For r GroundPI r exists obtained r removing negative literals Since r GroundPI negative literals r true cid4cid4 GLGroundP I exists corresponding rule GroundPI I cid4cid4 J I Therefore positive body literal r I model GLGroundP I ii J I model GLGroundP I model GroundPI I minimal model GroundPI Hence I minimal model GLGroundP I minimal model GroundPI J I For rules r false wrt I r included GroundPI false wrt Now assume I standard answer set P I minimal model GLGroundP I By similar cid4 GroundPI reasoning rule r GLGroundP I true body wrt I corresponding rule r cid4cid4 GLGroundP I contains negative body original rule ro GroundP true wrt false body wrt I model GroundPI ii J I model GroundPI J model GLGroundP I As consequence I minimal model GroundPI minimal model GLGroundP I cid2 contained GroundPI satisﬁed J I Therefore I J I Any rule r 4 Computational complexity 41 Complexity framework We analyze complexity DLP A Cautious Reasoning main reasoning task nonmonotonic formalisms program P standard ground atom A A true A amounting following decision problem Given DLP answer sets P A use notation LPL A L A Ms M As A Ns N For identifying fragments DLP Let P LPL A If L rules P contain negative literals Likewise L rules P disjunctive heads If Ms A resp As A Ns A P contain monotone resp antimonotone nonmonotone aggregates P stratiﬁed If M A resp A A N A P contain monotone resp antimonotone nonmonotone aggregates P necessarily stratiﬁed If symbol absent set respective feature 9 Throughout paper denotes strict set inclusion W Faber et al Artiﬁcial Intelligence 175 2011 278298 287 Table 1 The complexity cautious reasoning ASP aggregates completeness results logspace reductions M As Ns M As M Ns As Ns M As Ns A M A A Ns M A Ns N M N As N M As N A N M A N P P P P P P P P coNP coNP coNP coNP Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 1 coNP coNP coNP coNP coNP coNP coNP coNP coNP coNP coNP coNP Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 2 coNP coNP Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 3 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 Π P 2 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 occur P symbol included speciﬁes general feature For example P LP antimonotone aggregates P stratiﬁed occur P As speciﬁed A For technical results consider ground variablefree DLP programs polynomialtime computable ag gregate functions note sample aggregate functions appearing paper fall class However overview provide discussion results change considering nonground programs aggregates harder compute A 42 Overview complexity results Table 1 summarizes complexity results derived sections fragments LPL A L speciﬁed A Ms L omitted Table 1 readability equal columns A rows Results LPL respective fragment containing M instead Ms An important result addition aggregates increase complexity disjunctive logic programming language including considered types aggregates monotone antimonotone A Cautious reasoning DLP nonmonotone unstratiﬁed remains Π P 2 complete standard DLP The cheapest aggregates viewpoint complexity monotone ones addition causes complexity increase negationfree programs unstratiﬁed monotone aggregates The largest polynomialtime computable fragment LP M AsNs positive free programs suggesting stratiﬁed aggregates As Ns cheap Indeed behave similarly stratiﬁed negation complexity viewpoint increase complexity case positive disjunctive programs coNP Π P Antimonotone aggregates unstratiﬁed behave like unstratiﬁed negation In positive free case presence increase complexity P coNP The complexity remains monotone stratiﬁed nonmonotone aggre gates added The maximal coNPcomputable fragments LPnot 2 M ANs LP M The expensive aggregates viewpoint complexity nonmonotone ones In positive free 2 For language fragment containing 2 completeness Intuitively reason nonmonotone aggregates express case deﬁnite Horn programs cause big complexity jump P Π P nonmonotone aggregates obtain Π P properties written negation disjunction standard DLP Note implemented ASP systems allow expressing nonmonotone aggregates 1 count X p X 3 treated like conjunction monotone antimonotone aggregate atom count X p X 1 count X p X 3 The complexity nondisjunctive programs constructs LPnot In 44 broad class nonmonotone aggregates rewritten mono tone antimonotone aggregates style identiﬁed Note sum aggregates weight constraints positive negative integers nonmonotone general decomposed monotone antimonotone aggregates M A lower LPnot N 288 W Faber et al Artiﬁcial Intelligence 175 2011 278298 The complexity results valuable information intertranslatability different languages having im portant implication possibility implement aggregates existing reasoning engines For instance know cautious reasoning LPnot M ANs eﬃciently translated UNSAT complement propositional satis ﬁability cautious reasoning nondisjunctive ASP arbitrary monotone arbitrary antimonotone stratiﬁed nonmonotone aggregates implemented eﬃciently SAT solvers nondisjunctive ASP systems On hand nonmonotonic aggregates negation disjunction bring complexity Π P 2 exis tence polynomial translation cautious reasoning nonmonotonic aggregates UNSAT exist polynomial hierarchy collapses Therefore rewriting UNSAT viable implement nonmonotone aggregates require powerful solvers As mentioned results rely assumption aggregate functions computable polynomial time If allow computationally expensive aggregates complexity rise according complexity additional oracles needed compute truth value aggregate We end overview brieﬂy addressing complexity nonground programs When considering datacomplexity program P ﬁxed input consists facts results propositional programs If considers program complexity program P given input complexity rises similar manner aggregate free programs A nonground program P reduced naive instantiation ground instance problem In general case P given input size grounding GroundP single exponential size P Informally complexity Cautious Reasoning increases accordingly exponential P EXPTIME coNP coNEXPTIME Π P 2 coNEXPTIMENP For aggregatefree programs complexity results nonground case reported 45 For fragments results derived complexity upgrading techniques presented 1546 43 Proofs hardness results In section provide proofs hardness results Table 1 431 Nondisjunctive programs All Phardness results Table 1 rows 18 column 1 follow directly wellknown result positive propositional logic programming Phard 45 An important observation negation simulated antimonotone aggregates It possible turn aggregatefree programs negation corresponding positive programs aggregates Let ﬁrst deﬁne simulation achieved Deﬁnition 41 Given program P LPnot literal P countcid6cid8 acid7 1 cid8 arbitrary constant let Γ P DLP A program obtained replacing negative We aggregatefree program transformed version equivalent Lemma 41 Each program P LPnot transformed equivalent program Γ P LP antimonotone If P negationstratiﬁed Γ P LP As A aggregate literals Proof Note interpretation I true wrt I countcid6cid8 acid7 1 antimonotone aggregate literal By virtue Theorem 36 answer sets semantics Deﬁnition 26 equivalent standard answer set semantics Thus valuation literals equal P Γ P programs answer sets iff countcid6cid8 acid7 1 true wrt Since aggregates place negative literals P negationstratiﬁed exists level mapping predicates negative literals map ordinal ordinal head atom maps The levelmapping showing Γ P aggregatestratiﬁed aggregate literals cid2 I Moreover transformation low computational cost Lemma 42 Let P LPnot Then Γ P size number rules literals P ii Γ P LOGSPACE computable P Proof The Γ P transformation replaces negative literal aggregate atom add literal program Therefore increase program size It easy Γ P computed LOGSPACE Turing Machine Indeed Γ P generated dealing rule P time storing intermediate data apart ﬁxed number indices cid2 W Faber et al Artiﬁcial Intelligence 175 2011 278298 289 As consequence lemmata obtain hardness positive nondisjunctive programs containing antimonotone aggregates Theorem 43 Cautious reasoning LP A programs coNPhard Proof Follows coNPhardness cautious reasoning positive disjunctive aggregatefree programs programs LP Theorem 61 45 Lemmata 41 42 cid2 Whenever allows nonmonotone aggregates positive nondisjunctive programs cautious reasoning harder level polynomial hierarchy Theorem 44 Cautious reasoning LP N programs Π P 2 hard Proof We provide reduction deciding validity quantiﬁed boolean formula 2QBF Ψ x1 xm y1 yn E Without loss generality assume E propositional formula 3CNF format precisely 2 hard 47 Observe Ψ equivalent Ψ cid4 variables x1 xm y1 yn Deciding Ψ valid Π P Ψ cid4 x1 xm y1 yn E cid4 3DNF equivalent E literal reversed polarity wrt E conjunctions disjunctions inverted Clearly Ψ cid4 eﬃciently constructable Ψ Ψ valid Ψ cid4 N program Π Ψ cautiously entails atom w Ψ cid4 invalid To prove theorem construct LP invalid w cautious consequence Π Ψ Ψ valid E cid4 Let E cid4 l11 l12 l13 lk1 lk2 lk3 deﬁne LP cid4 cid5 1 txi 1 cid2cid4 cid3 0 cid5cid3 cid5cid3 cid2cid4 1 txi 1 cid4 cid5 1 txi 1 cid5 1 t yi 1 cid2cid4 1 txi 1 cid5cid3 cid4 1 t yi 1 cid4 cid5 1 t yi 1 1 t yi 1 cid2 0 cid3 0 cid5cid3 1 m 1 m 1 n cid2 0 1 n N program Π Ψ follows r1 txi 1sum r2 txi 1sum cid2cid4 r3 t yi 1sum r4 t yi 1sum r5 t yi 1 sat E r6 t yi 1 sat E r7 sat E r8 wsum cid2cid4 cid4 cid4 1 cid4 1 1 n 1 n 1μli1 μli2 μli3 cid4 cid4 1 sat E 1 sat E cid5 1 1 k cid5cid3 cid4 1 cid2 0 1 k cid4 μl ta 1 l positive μl ta 1 l negative Intuitively propositional variable atoms Π Ψ ta 1 ta 1 representing respectively truth appearing E cid41μli1 μli2 μli3 Π Ψ corresponding clause falsity Atom sat E li1 li2 li3 true E cid41 derivable rule sat E We claim w cautious consequence Π Ψ Ψ valid We equivalently prove sat E cid4 cid41 valid 1 w cautious consequence Π Ψ cid41 false answer set answer set brave consequence Π Ψ Ψ cid4 sat E semantics rule r8 equivalent wnot sat E cid41 brave consequence Π Ψ note sat E cid41 2 Ψ valid Ψ cid4 invalid valid Thus Π Ψ answer set containing sat E Assume ﬁrst Π Ψ answer set A containing sat E cid41 Ψ cid4 cid41 Observe A contains exactly txi 1 txi 1 1 cid2 cid2 m held rule satisﬁed held A minimal model reduct Therefore A encodes truth assignment ϕ x1 xm ϕxi true txi 1 A ϕxi false txi 1 A Furthermore A contain t yi 1 t yi 1 1 cid2 cid2 n rules r5 cid41 Since A minimal model Π Ψ A r6 unsatisﬁed wrt A body true wrt A contains sat E cid41 follows A model Π Ψ A forcing sat E So class rules r7 Π Ψ body literal A contains encoding ϕ arbitrary truth assignment y1 yn sat E cid41 This turn means extension ϕ y1 yn satisﬁes E Ψ cid4 Assume Ψ cid4 cid4 valid exists truth assignment ϕ x1 xm extension ϕ satisﬁed Let I interpretation containing encoding ϕ txi 1 iff xi assigned true ϕ cid41 y1 yn E txi 1 iff xi assigned false ϕ addition t yi 1 t yi 1 1 cid2 cid2 n sat E Π Ψ I contains rules Π Ψ valid cid4 cid4 cid4 cid4 sat E cid2cid4 1sum 1 sat E cid4 cid4 cid5 1 1 sat E cid4 cid5cid3 1 cid2 0 290 W Faber et al Artiﬁcial Intelligence 175 2011 278298 Interpretation I clearly model Π Ψ I encoding ϕ order satisfy ﬁrst groups rules r1 r2 Furthermore I truth assignment y1 yn order satisfy fourth groups rules Then E cid41 I cid4 truth assignment sat E t yi 1 t yi 1 1 cid2 cid2 n I cid4 I I answer set Π Ψ clearly contains sat E I cid4 I exists It contain contain encoding satisﬁed order satisfy group rules r7 However means cid4 I contradicting order satisfy groups rules r5 r6 So I cid41 cid2 To prove minimality assume model I cid4 cid4 cid4 We note related result deciding answer set exists positive nondisjunctive program 2 complete shown 37 Weight constraints weight constraints possibly negative integers Σ P monotone antimonotone nonmonotone aggregate atoms Leveraging results literature hardness proofs ﬁelds nondisjunctive programs Table 1 Theorem 45 All ﬁelds column 1 ﬁelds column 2 Table 1 states respective hardness cautious reasoning corresponding fragment DLP A Proof Phardness results ﬁelds rows 1 8 column 1 follow fact cautious reasoning LP programs Phard 45 corresponding languages supersets LP coNPhardness ﬁelds rows 9 12 column 1 stem Theorem 43 corresponding languages supersets LP A The coNPhardness ﬁelds rows 1 12 column 2 based Theorem 67 48 states cautious reasoning LPnot coNPhard All languages corresponding ﬁelds supersets LPnot 2 hardness results ﬁelds rows 13 18 columns 1 2 backed Theorem 44 fact corresponding languages supersets LP All Π P N cid2 432 Disjunctive programs Exploiting Lemma 41 says aggregatefree program negation transformed equiv alent program antimonotone aggregates converting negationstratiﬁcation aggregatestratiﬁcation 2 hardness cautious reasoning LP Π P As programs Theorem 46 Cautious reasoning LP As programs Π P 2 hard Proof Follows Π P 2 hardness cautious reasoning standard literal queries positive disjunctive aggregatefree LP programs Theorem 36 49 Given program P literal l form standard ground atom let P cid4 P ql q ground atom occur P Obviously P cid4 LPnot negationstratiﬁed cautious reasoning q P cid4 equivalent cautious reasoning l P Together Lemmata 41 42 result follows cid2 Next note program containing stratiﬁed antimonotone aggregates transformed equivalent program containing stratiﬁed nonmonotone aggregates Lemma 47 Each LPnot As program transformed equivalent LPnot Ns program cid4 Proof Wlog consider ground program P We transform antimonotone aggregate literal l containing cid4k We introduce fresh constants τ cid8 ν new predicate aggregate atom f Sk l symbol Π Let f l undeﬁned multisets τ τ cid8 ν return value making l true τ cid8 obtained adding cid6τ Πτ cid7 cid6cid8 Πcid8cid7 value exist f l equal f Furthermore S cid6ν Πνcid7 ground set S The transformed program P cid4 contains nonmonotone aggregates stratiﬁed P clearly equivalent P cid2 containing f lS cid4 cid4 As consequence Π P 2 hardness holds LP Ns programs Corollary 48 Cautious reasoning LP Ns programs Π P 2 hard Proof Follows directly Theorem 46 Lemma 47 cid2 These results results literature suﬃcient hardness results columns 3 4 Table 1 W Faber et al Artiﬁcial Intelligence 175 2011 278298 291 Theorem 49 Each ﬁeld columns 3 4 Table 1 states respective hardness cautious reasoning corresponding fragment DLP A programs coNPhard fact LP Proof coNPhardness ﬁelds rows 1 2 column 3 rely Theorem 61 45 states cautious reasoning LP 2 hardness ﬁelds rows 3 18 column 3 follow Theorem 46 Corollary 48 fact corresponding languages supersets LP As LP Ns Π P 2 hardness ﬁelds column 4 follows Theorem 62 45 states cautious reasoning LPnot Π P 2 hard fact corresponding languages supersets LPnot LP M Π P cid2 In total proved hardness results Table 1 44 Proofs membership results For membership proofs reverse order ﬁrst prove results richer languages cover results sublanguages In membership proofs implicitly use following lemma Lemma 410 Given interpretation I DLP time A program P truth valuation aggregate atom L computable polynomial Proof Let L f T k To determine truth valuation L compute valuation IT ground set T wrt I ii apply aggregate function f IT iii compare result f IT k wrt Computing valuation ground set T requires scanning element cid6t1 tn Conjcid7 T adding t1 result multiset Conj true wrt I This evidently polynomial application aggregate function IT framework Section 41 The comparison k ﬁnally straightforward cid2 441 Disjunctive programs Let ﬁrst focus language Let ﬁrst problem answer set checking coNP Lemma 411 Checking interpretation M answer set arbitrary DLP A program P coNP Proof To prove M answer set P guess interpretation M following conditions hold M conditions clearly polynomial time problem coNP cid2 model P M M P check cid4 M ii M model P M The checking cid4 cid4 Using result able guess check algorithm proving membership Π P 2 Theorem 412 Cautious reasoning LPnot M AN programs Π P 2 program P follows Guess interpre Proof We verify ground atom A cautious consequence DLP tation M BP check 1 M answer set P 2 A true wrt M Task 2 clearly polynomial 1 coNP virtue Lemma 411 The problem lies Π P A 2 cid2 Concerning disjunctive programs fragments cautious reasoning Π P 2 exceptions coNP The reason respective classes suﬃcient look arbitrary model answer set minimal model Lemma 413 Let P LP model M P contain A10 M program standard ground atom A cautious consequence P exists Proof Observe ﬁrst P contain negation monotone aggregate literals literal appearing P monotone The existence model M P containing A implies existence minimal model M cid4 cid4 M containing A By virtue Theorem 35 M P answer set P Therefore A cautious consequence cid4 M P 10 Note M model possibly nonminimal P 292 W Faber et al Artiﬁcial Intelligence 175 2011 278298 Since A cautious consequence P deﬁnition cautious reasoning exists answer set M P contain A By Proposition 31 M model P cid2 This lemma allows prove coNPmembership cautious reasoning programs Theorem 414 Cautious reasoning LP M programs coNP Proof By Lemma 413 check ground atom A cautious consequence program P follows Guess interpretation M P ii check M model M The check clearly polynomialtime computable problem coNP cid2 These results suﬃcient hardness results columns 3 4 Table 1 Theorem 415 Each ﬁeld columns 3 4 Table 1 states respective membership cautious reasoning corresponding fragment DLP A Proof Membership Π P corresponding languages subsets LPnot column 3 follow Theorem 414 fact LP 2 ﬁelds column 4 ﬁelds rows 3 18 column 3 follow Theorem 412 M AN Membership coNP ﬁelds rows 1 2 LP M cid2 442 Nondisjunctive programs Π P 2 memberships nondisjunctive programs follow respective result disjunctive programs remains coNP Pmemberships Let ﬁrst consider complex language LP answer sets computed eﬃciently M AsNs We programs fragment Lemma 416 An LP polynomial time M AsNs program answer set answer sets LP M AsNs program computed Proof For LP P I cid15 Br h Hr Furthermore given interpretation I let sequence Tn P TP Ti1 Ti ﬁxpoint T M AsNs program P let deﬁne operator TP interpretations P follows TP I h r P I I P I 0 Since TP monotone number interpretations P ﬁnite sequence reaches P I P InN deﬁned T0 Consider level mapping cid12 cid12 rule r P Hr h antimonotone nonmonotone predicate h Moreover occurs head p body rule Without aggregate literal A Br holds predicate p nested A cid12pcid12 cid12p cid12pcid12 cid2 cid12p p loss generality assume codomain cid12cid12 0 n cid4cid12 holds pair predicates p p cid4cid12 p Based cid12 cid12 deﬁne partition P0 Pn Pconstr P n maximum codomain cid12 cid12 P ﬁnite integer follows Pi r r P Hr h cid12Predhcid12 Pconstr r r P Hr P If FPP model Pconstr Furthermore deﬁne FP0 let FMP FPP FMP P 0 cid2 n let FPP FPn P T P0 P T Pi FPi FPi1 cid4 cid4 cid4 In sequel use shorthand HP h r P h Hr denote set head atoms program We induction FPP A answer set A P The base FP0 P HP0 A HP0 answer set A P To prove FP0 P0 The base T0 Pi P HP0 A HP0 use induction Ti A answer set A P Then assuming S A answer set A P TP0 S A answer set A P Each rule r P0 P A model Proposition 31 S cid15 b b Br answer set A A cid15 b Br contain antimonotone nonmonotone aggregate literals cid12pcid12 0 predicate aggregate hold Since Hr h h contained answer set It P HP0 FP0 follows FP0 P HP0 A HP0 P HP0 cid9 We A X model P A contradicting assumption A answer set Each rule P A P0 clearly satisﬁed A X satisﬁed FP0 P Now recall rule r P A P0 true body wrt A true false wrt A X Since Hr X X HP0 deﬁnition partition HP0 HP P0 r satisﬁed A X Therefore P HP0 A HP0 We shown base induction A answer set P X cid9 FP0 FP0 Now assume X A HP0 FP0 A It easy FP0 P T P0 P HP0 A HP0 W Faber et al Artiﬁcial Intelligence 175 2011 278298 293 FPi1 FPi1 FPi1 P FPi1 P The base T0 Pi For inductive step assume FPk P HPi A HPi use induction T j Pi P HPk A HPk holds k 0 answer set A In order P A FPi FPi1 answer set A holds inductive hypothesis larger induction Now assume T j P A holds Pi answer set Tpi T j P A holds answer set We observe rule r Pi Pi P A model Proposition 31 T j P cid15 b b Br answer set A Pi A cid15 b antimonotone nonmonotone literals aggregates contain atoms formed predicates p cid12pcid12 Any atoms HPk k inductive hypothesis larger induction T j Pi It remains FPi FPi1 P HPi A HPi Similar base case larger induction assume X A HPi FPi P HPi cid9 We A X model P A contradicting assumption A answer set Each rule P A Pi clearly satisﬁed A X satisﬁed FPi P Now recall rule r P A Pi true body wrt A true false wrt A X Since Hr X X HPi deﬁnition partition HPi HP Pi r satisﬁed A X Therefore A answer set P P HPi A HPi X cid9 FPi answer set A P HPi A HPi We shown step induction FPi P HPk A HPk In total FPi P T Pi FPi1 A In total FPP FPP answer set P answer set A FPP It follows P answer set i1 HPi A i1 HPi answer set A P It easy i1 HPi P Pconstr Therefore answer set A P know cid7 n Moreover note rules Pconstr satisﬁed body literals false heads Now FPP answer set P Pconstr minimal model P PconstrFPP If FPP satisﬁes rules Pconstr P PconstrFPP P FPP FPP answer set P If rule Pconstr exists satisﬁed FPP rule occurs P FPP FPP model P FPP answer set P case In total FMP set answer sets P Computing FPP FMP TP clearly feasible polynomial time size program cid2 cid7 n cid7 n Given compute set answer sets polynomial time cardinality set 1 cautious reasoning easily computed answer sets Theorem 417 Cautious reasoning LP M AsNs P Proof This simple consequence Lemma 416 We compute set answer sets polynomial time If atoms cautious consequence If answer set check polynomial time contains query atom cid2 Let focus coNPmemberships For reuse fact answer sets LP M AsNs programs answer set computable polynomial time The point checking interpretation I LPnot M ANs program The crucial point checking I minimal model P I case answer set eliminate antimonotone literals P I M ANs program P form reduct P I LPnot Lemma 418 Given LPnot model Ψ P I derived P I deleting antimonotone literals M ANs program P interpretation I BP I subsetminimal model P I iff subsetminimal cid4 Proof If I minimal model P I obviously model Ψ P I Moreover interpretation N I model P I rule r P I N cid9cid15 r body atoms true wrt N head true atoms false wrt N Now rule r satisﬁed N As consequence N model Ψ P I I minimal wrt N r model Ψ P I cid4 Ψ P I Hr Hr cid4 So body r cid4 Br Br Let I minimal model Ψ P I We ﬁrst note rule P I body literal false wrt I construction P I rule Ψ P I body literal false wrt I So rule Ψ P I body literals true wrt I head atoms true wrt I I model Since rule Ψ P I corresponding rule P I equal head rule P I body literal false wrt I I model P I Now consider arbitrary interpretation N I N model Ψ P I rule r Ψ P I body literals r true wrt N head atoms r false wrt N Now consider corresponding rule cid4 p I Br Br r true wrt I deleted body literal cid4 Br antimonotone literal negative standard literal antimonotone aggregate literal cid6 cid6 Br cid4 By construction p I literals r cid4 cid4 294 W Faber et al Artiﬁcial Intelligence 175 2011 278298 cid4 Hr head atom r true wrt N Hence body r satisﬁed N model P I obtain I minimal model P I cid2 true wrt N Hr cid4 cid4 false wrt N Hence r cid4 So answer set checking LPnot LP earlier task polynomial M ANs program checking interpretation minimal model MNs program case equivalent checking answer set We shown Theorem 419 Cautious reasoning LPnot M ANs coNP Proof We guess interpretation I check answer set contain queried atom The check clearly polynomial Answer set checking amounts checking I subsetminimal model P I Because Lemma 418 I subsetminimal model P I iff I subsetminimal model Ψ P I negative standard antimonotone aggregate literals deleted transformation obviously polynomial Because answer set Ψ P I Proposition 32 I Now Ψ P I LP M AsNs know Lemma 416 answer sets computable polynomial time So compute set minimal models Ψ P I polynomial time If I answer set exactly minimal model check equal I If I answer set Checking I answer set feasible polynomial time cid2 answer set P I I subsetminimal model P I MNs LP I We proved membership results Table 1 nondisjunctive programs Theorem 420 Each ﬁeld columns 3 4 Table 1 states respective membership cautious reasoning corresponding fragment DLP A Proof Membership Π P 2 ﬁelds rows 13 18 columns 1 2 follow Theorem 412 corresponding languages subsets LPnot M AN Membership coNP ﬁelds rows 9 12 column 1 rows 1 12 column 2 consequence Theorem 419 corresponding languages subsets LPnot M ANs Finally membership P ﬁelds rows 1 8 column 1 Theorem 417 corresponding languages subsets LP M AsNs cid2 5 Related work There considerable efforts deﬁne semantics logic programs aggregates For historical background refer 50 Here focus work proposed ﬁeld Answer Set Programming deﬁn ing semantics recursive aggregates Several works consider monotone aggregates 313330 We details respect approaches focus having aggregate atoms rule heads feature absent framework working algebraic methods disjunctive programs Moreover semantically monotone aggregates rule bodies straightforward handle perfectly correspond standard positive atoms behavior We note related works consider disjunctive programs A thorough discussion pros cons approaches recursive aggregates given 503436 The approaches 252728 basically admit nonminimal answer sets In particular program P 1 Example 12 pa answer sets As shown Example 213 Theorem 33 semantics proposed paper admits guarantees minimality answer sets The work 51 deals abstract concept generalized quantiﬁers semantics allows nonminimal answer sets The approach 43 deﬁned nondisjunctive programs particular kinds aggregates called cardinality weight constraints basically correspond programs count sum functions As shown 29 52 presence negative weights negative literals inside aggregates11 semantics 43 lead unintuitive results For example program asumcid61 acid7 cid2 1 intuitively answer set minimal truth founded However according 43 answer sets12 Our semantics allows answer set according intuition However 37 shown semantics 43 equal answer set semantics Deﬁnition 26 programs sum respectively weight constraints positive integers An extension approach 43 presented 32 allows arbitrary aggregates nondisjunctive programs A difference respect 4332 languages allow aggregate atoms rule heads consider paper 11 Note negative literals inside aggregates allowed framework negative integers allowed correctly dealt 12 Interestingly lparse version 1017 smodels version 232 software implementing semantics 43 computes W Faber et al Artiﬁcial Intelligence 175 2011 278298 295 A major contribution understanding aggregates ASP presented 37 The author provides way represent ground aggregates means propositional formulas building earlier work reported 52 Together reductbased semantics propositional formulas presented 37 called answer sets yields semantics programs aggregates In Theorem 3 37 Ferraris proves semantics coincides programs presented paper Deﬁnition 26 Ferraris refers FLPprograms ground DLP aggregate atoms preceded A It noted representation 37 careful way order guarantee monolithic stability justiﬁcation capabilities aggregates In particular forming reduct respect interpretation I deﬁned 37 formula representing aggregate satisﬁed I completely replaced falsity rendering corresponding rule irrelevant reduct On hand formula representing aggregate satisﬁed I stay reduct This behavior precisely coincides main motivation reduct Deﬁnition 25 distinguishes approach discussed However difference respect semantics 37 negated aggregate atoms occur program This work treat negation operator simply complement operator aggregates 37 treated negationasfailure operator The difference best shown example Example 51 Given program cid2 anot count cid3 cid61 acid7 1 r answer set respect Deﬁnition 26 37 allow answer sets So presence negated literals semantics 37 allows nonminimal answer sets Both ways dealing aggregates motivated For language seen shorthand complement aggregate rule equivalent cid4 r cid2 acount cid3 cid61 acid7 cid3 1 In 37 rule r viewed equivalent cid4cid4 r answer sets according 53 It notable language considered 37 general semantics language mind semantics coincide We view A deﬁned independently having DLP conﬁrmation robustness semantics In 37 author given complexity results In particular shown deciding non 2 complete This disjunctive program weight constraints sumaggregate notation answer set Σ P strictly related result cautious reasoning program LP N Π P 2 complete Recently 54 language called RASPL1 deﬁned essentially allows possibly nonground counting aggregates The semantics language deﬁned analogously 37 case means representation ﬁrstorder formula interpreted semantics arbitrary ﬁrstorder formulas presented 55 Also semantics RASPL1 shown coincide Deﬁnition 26 large common language fragment refer 54 details We furthermore like point reduct semantics deﬁned paper spread scientiﬁc community work Indeed main advantage semantic deﬁnition respect generality Being based deﬁnition reduct refer aggregates special structures allows deﬁning semantics arbitrary linguistic extensions Indeed 5657 authors use Deﬁnition 25 deﬁning semantics programs higher order externally deﬁned atoms This work set context reasoning Semantic Web aggregates involve querying ontologies example seen variant semantics framework However suggestions semantics programs aggregates Most representative 2934 semantics nondisjunctive programs aggregates deﬁned closest semantics paper Dstable semantics In 3635 notions ﬁxpoint answer set unfolding answer set deﬁned nondisjunctive programs aggregates 35 shown equivalent Moreover Dstable semantics ﬁxpoint answer sets equivalent shown 3635 Also Dstable semantics minimality coincidence answer sets aggregatefree case guaranteed Another equivalent deﬁnition programs catoms essentially extensional representations aggregate atoms given 58 In Theorem 4 36 Proposition 81 34 shown Dstable model answer set deﬁned Deﬁnition 26 However answer set deﬁned Deﬁnition 26 necessarily Dstable model noted 3634 In doctoral thesis 50 Pelov deﬁnes semantics disjunctive programs aggregates close However differences Dstable model semantics surface To differences let consider Example 9 36 296 W Faber et al Artiﬁcial Intelligence 175 2011 278298 Example 52 Given program cid2 p1sum cid3 X pX p1p1 obtain answer set p1 p1 respect Deﬁnition 26 Dstable model p1p1 cid3 0 The authors 36 argue program equivalent aggregatefree program p1not p1 p1not p1 p1 p1p1 p1 p1p1 p1p1 p1 p1p1 p1p1 Here forming reduct wrt p1 p1 ﬁrst rules deleted This intuition literal particular aggregate literals considered monolithic structure verifying stability Indeed example representation aggregate retained reduct This situation occur setting aggregate relevant entirety effect Interestingly semantics 37 shares precisely view yields unique answer set p1 p1 program As example shows approach line semantics 37 differs 3634 assumption aggregate literal justify answer set We believe approaches motivated choice right semantics depends interprets justiﬁcation capabilities aggregate However accepts assumption aggregates serve justiﬁers monolithic way semantics behave intuitive way Indeed shown Example 52 unclear allow aggregate stability answer set candidate Moreover monolithic approach advantage generally applicable speciﬁc aggregates depends basic satisfaction expressions language In 50 Pelov provides complexity analysis reasoning tasks setting semantics proposed work In particular problem model existence studied related query answering problems studied work Pelov differentiate types literals differentiates semantics deﬁned evaluation complexity aggregate literals Also 35 contains similar analysis The results compatible ones derived paper model existence located ﬁrst second level polynomial hierarchy 6 Conclusions Concluding proposed declarative semantics ASP programs arbitrary aggregates DLP programs This semantics generalizes answer set semantics standard ASP simple elegant way new deﬁ nition reduct simpler original treats negative literals positive literals aggregates literals fully uniform manner We demonstrated semantics endowed desirable properties guarantees subsetminimality incomparability answer sets coincides standard answer set seman tics aggregatefree programs We analyzed computational complexity language depth drawing picture complexity ASP fragments negation andor disjunction combined different kinds ag gregates monotone antimonotone nonmonotone stratiﬁed Importantly proved aggregate literals increase computational complexity disjunctive ASP programs approach increase complexity normal nondisjunctive programs Π P 2 We singled relevant classes aggregates cause complexity overhead normal programs eﬃciently implemented normal ASP systems A Acknowledgements This work greatly beneﬁted interesting discussions comments Paolo Ferraris Michael Gelfond Vladimir Lifschitz Nikolay Pelov We grateful competent comments suggestions reviews The work partially supported MIUR projects Potenziamento e Applicazioni della Programmazione Logica Disgiuntiva Sistemi basati sulla logica la rappresentazione di conoscenza estensioni e tecniche di ottimizzazione tocaiit Tecnologie Orientate alla Conoscenza Aggregazioni di Imprese Internet References 1 W Faber N Leone G Pfeifer Recursive aggregates disjunctive logic programs Semantics complexity JJ Alferes J Leite Eds Proceedings 9th European Conference Artiﬁcial Intelligence JELIA 2004 Lecture Notes AI LNAI vol 3229 SpringerVerlag 2004 pp 200212 2 F Calimeri W Faber N Leone S Perri Declarative computational properties logic programs aggregates Nineteenth International Joint Conference Artiﬁcial Intelligence IJCAI05 2005 pp 406411 3 J McCarthy Programs common sense Proceedings Teddington Conference Mechanization Thought Processes Her Majestys Stationery Oﬃce 1959 pp 7591 4 J McCarthy PJ Hayes Some philosophical problems standpoint artiﬁcial intelligence B Meltzer D Michie Eds Machine Intelligence vol 4 Edinburgh University Press 1969 pp 463502 reprinted 59 5 M Minsky A framework representing knowledge PH Winston Ed The Psychology Computer Vision McGrawHill 1975 pp 211277 6 J McCarthy Circumscription A form nonmonotonic reasoning Artiﬁcial Intelligence 13 12 1980 2739 W Faber et al Artiﬁcial Intelligence 175 2011 278298 297 7 J McCarthy Applications circumscription formalizing commonsense knowledge Artiﬁcial Intelligence 28 1 1986 89116 8 R Reiter A logic default reasoning Artiﬁcial Intelligence 13 12 1980 81132 9 DV McDermott J Doyle Nonmonotonic logic I Artiﬁcial Intelligence 13 12 1980 4172 10 DV McDermott Nonmonotonic logic II Nonmonotonic modal theories Journal ACM 29 1 1982 3357 11 RC Moore Semantical considerations nonmonotonic logic Artiﬁcial Intelligence 25 1 1985 7594 12 M Gelfond V Lifschitz Classical negation logic programs disjunctive databases New Generation Computing 9 1991 365385 13 C Baral Knowledge Representation Reasoning Declarative Problem Solving Cambridge University Press 2003 14 J Minker On indeﬁnite data bases closed world assumption DW Loveland Ed Proceedings 6th Conference Automated Deduction CADE 82 Lecture Notes Computer Science vol 138 Springer New York 1982 pp 292308 15 T Eiter G Gottlob H Mannila Disjunctive DATALOG ACM Transactions Database Systems 22 3 1997 364418 16 P Simons I Niemelä T Soininen Extending implementing stable model semantics Artiﬁcial Intelligence 138 2002 181234 17 T Janhunen I Niemelä D Seipel P Simons JH You Unfolding partiality disjunctions stable model semantics ACM Transactions Computa tional Logic 7 1 2006 137 18 N Leone G Pfeifer W Faber T Eiter G Gottlob S Perri F Scarcello The DLV knowledge representation reasoning ACM Transactions Computational Logic 7 3 2006 499562 19 F Lin Y Zhao ASSAT Computing answer sets logic program SAT solvers Artiﬁcial Intelligence 157 12 2004 115137 20 Y Lierler M Maratea Cmodels2 SATbased answer set solver enhanced nontight programs V Lifschitz I Niemelä Eds Proceedings 7th International Conference Logic Programming NonMonotonic Reasoning LPNMR7 Lecture Notes AI LNAI vol 2923 Springer 2004 pp 346350 21 C Anger K Konczak T Linke NoMoRe A nonmonotonic reasoning T Eiter W Faber M Truszczy nski Eds Logic Programming Nonmonotonic Reasoning Proceedings 6th International Conference LPNMR 01 Vienna Austria September 2001 Lecture Notes AI LNAI vol 2173 SpringerVerlag 2001 pp 406410 22 C Anger M Gebser T Linke A Neumann T Schaub The nomore approach answer set solving G Sutcliffe A Voronkov Eds Logic Programming Artiﬁcial Intelligence Reasoning 12th International Conference LPAR 2005 Lecture Notes Computer Science vol 3835 SpringerVerlag 2005 pp 95109 23 M Gebser B Kaufmann A Neumann T Schaub Conﬂictdriven answer set solving Twentieth International Joint Conference Artiﬁcial Intelli gence IJCAI07 Morgan Kaufmann Publishers 2007 pp 386392 24 IS Mumick H Pirahesh R Ramakrishnan The magic duplicates aggregates Proceedings 16th International Conference Very Large Data Bases VLDB 90 Morgan Kaufmann 1990 pp 264277 25 DB Kemp PJ Stuckey Semantics logic programs aggregates VA Saraswat K Ueda Eds Proceedings International Symposium Logic Programming ISLP 91 MIT Press 1991 pp 387401 26 KA Ross Y Sagiv Monotonic aggregation deductive databases Journal Computer System Sciences 54 1 1997 7997 27 M Gelfond Representing knowledge AProlog AC Kakas F Sadri Eds Computational Logic Logic Programming Beyond Lecture Notes Computer Science vol 2408 Springer 2002 pp 413451 28 T DellArmi W Faber G Ielpa N Leone G Pfeifer Aggregate functions DLV M Vos A Provetti Eds Proceedings ASP03 Answer Set Programming Advances Theory Implementation Messina Italy 2003 pp 274288 online httpCEURWSorgVol78 29 N Pelov M Denecker M Bruynooghe Partial stable models logic programs aggregates Proceedings 7th International Conference Logic Programming NonMonotonic Reasoning LPNMR7 Lecture Notes AI LNAI vol 2923 Springer 2004 pp 207219 30 N Pelov M Truszczy nski Semantics disjunctive programs monotone aggregates An operatorbased approach Proceedings 10th International Workshop NonMonotonic Reasoning NMR 2004 Whistler BC Canada 2004 pp 327334 31 VW Marek JB Remmel On logic programs cardinality constraints S Benferhat E Giunchiglia Eds Proceedings 9th International Workshop NonMonotonic Reasoning NMR 2002 Toulouse France 2002 pp 219228 32 VW Marek JB Remmel Set constraints logic programming V Lifschitz I Niemelä Eds Proceedings 7th International Conference Logic Programming NonMonotonic Reasoning LPNMR7 Lecture Notes AI LNAI vol 2923 Springer 2004 pp 167179 33 VW Marek I Niemelä M Truszczy nski Logic programming monotone cardinality atom V Lifschitz I Niemelä Eds Proceedings 7th International Conference Logic Programming NonMonotonic Reasoning LPNMR7 Lecture Notes AI LNAI vol 2923 Springer 2004 pp 154166 34 N Pelov M Denecker M Bruynooghe Wellfounded stable semantics logic programs aggregates Theory Practice Logic Program ming 7 3 2007 301353 35 TC Son E Pontelli A constructive semantic characterization aggregates ASP Theory Practice Logic Programming 7 2007 355375 36 TC Son E Pontelli I Elkabani On logic programming aggregates Tech Rep NMSUCS2005006 New Mexico State University 2005 37 P Ferraris Answer sets propositional theories C Baral G Greco N Leone G Terracina Eds Logic Programming Nonmonotonic Reasoning 8th International Conference LPNMR 05 Diamante Italy September 2005 Lecture Notes Computer Science vol 3662 SpringerVerlag 2005 pp 119131 38 T DellArmi W Faber G Ielpa N Leone G Pfeifer Aggregate functions disjunctive logic programming Semantics complexity implementation DLV Proceedings 18th International Joint Conference Artiﬁcial Intelligence IJCAI 2003 Morgan Kaufmann Publishers Acapulco Mexico 2003 pp 847852 39 F Lin Y Zhao ASSAT Computing answer sets logic program SAT solvers Proceedings Eighteenth National Conference Artiﬁcial Intelligence AAAI 2002 AAAI PressMIT Press Edmonton Alberta Canada 2002 40 JD Ullman Principles Database Knowledge Base Systems Computer Science Press 1989 41 KR Apt HA Blair A Walker Towards theory declarative knowledge J Minker Ed Foundations Deductive Databases Logic Program ming Morgan Kaufmann Publishers Inc Washington DC 1988 pp 89148 42 TC Przymusinski On declarative semantics deductive databases logic programs J Minker Ed Foundations Deductive Databases Logic Programming Morgan Kaufmann Publishers Inc 1988 pp 193216 43 I Niemelä P Simons T Soininen Stable model semantics weight constraint rules M Gelfond N Leone G Pfeifer Eds Proceedings 5th International Conference Logic Programming Nonmonotonic Reasoning LPNMR 99 Lecture Notes AI LNAI vol 1730 SpringerVerlag El Paso Texas USA 1999 pp 107116 44 W Faber Decomposition nonmonotone aggregates logic programming M Fink H Tompits S Woltran Eds Proceedings 20th Work shop Logic Programming WLP 2006 Vienna Austria 2006 pp 164171 45 E Dantsin T Eiter G Gottlob A Voronkov Complexity expressive power logic programming ACM Computing Surveys 33 3 2001 374425 46 G Gottlob N Leone H Veith Succinctness source expression complexity Annals Pure Applied Logic 97 13 1999 231260 47 LJ Stockmeyer AR Meyer Word problems requiring exponential time Preliminary report Conference Record 5th Annual ACM Symposium Theory Computing STOC 73 ACM Press 1973 pp 19 48 VW Marek M Truszczy nski Autoepistemic logic Journal ACM 38 3 1991 588619 298 W Faber et al Artiﬁcial Intelligence 175 2011 278298 49 T Eiter G Gottlob On computational cost disjunctive logic programming Propositional case Annals Mathematics Artiﬁcial Intelli gence 15 34 1995 289323 50 N Pelov Semantics logic programs aggregates PhD thesis Katholieke Universiteit Leuven Leuven Belgium Apr 2004 51 T Eiter G Gottlob H Veith Modular logic programming generalized quantiﬁers J Dix U Furbach A Nerode Eds Proceedings 4th International Conference Logic Programming Nonmonotonic Reasoning LPNMR 97 Lecture Notes Computer Science vol 1265 Springer 1997 pp 290309 52 P Ferraris V Lifschitz Weight constraints nested expressions Theory Practice Logic Programming 5 12 2005 4574 53 V Lifschitz LR Tang H Turner Nested expressions logic programs Annals Mathematics Artiﬁcial Intelligence 25 34 1999 369389 54 J Lee V Lifschitz R Palla A reductive semantics counting choice answer set programming D Fox CP Gomes Eds Proceedings 23rd National Conference Artiﬁcial Intelligence AAAI 08 AAAI Press 2008 pp 472479 55 P Ferraris J Lee V Lifschitz A new perspective stable models Twentieth International Joint Conference Artiﬁcial Intelligence IJCAI07 2007 pp 372379 56 T Eiter G Ianni R Schindlauer H Tompits A uniform integration higherorder reasoning external evaluations answer set programming International Joint Conference Artiﬁcial Intelligence IJCAI 2005 Edinburgh UK 2005 pp 9096 57 T Eiter G Ianni H Tompits R Schindlauer Effective integration declarative rules external evaluations semantic web reasoning Pro ceedings 3rd European Semantic Web Conference ESWC 2006 2006 pp 273287 58 TC Son E Pontelli PH Tu Answer sets logic programs arbitrary abstract constraint atoms Journal Artiﬁcial Intelligence Research 29 2007 353389 59 J McCarthy Formalization Common Sense papers John McCarthy edited V Lifschitz Ablex 1990