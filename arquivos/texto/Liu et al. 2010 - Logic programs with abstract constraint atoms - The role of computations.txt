Artiﬁcial Intelligence 174 2010 295315 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Logic programs abstract constraint atoms The role computations Lengning Liu Enrico Pontelli b Tran Cao Son b Miroslaw Truszczy nski Department Computer Science University Kentucky Lexington KY 40506 USA b Department Computer Science New Mexico State University Las Cruces NM 88003 USA r t c l e n f o b s t r c t Article history Received 3 September 2008 Received revised form 16 November 2009 Accepted 23 November 2009 Available online 27 November 2009 Keywords Logic programs abstract constraint atoms Answer sets Computations We provide new perspective semantics logic programs arbitrary abstract constraints To end introduce notions computation We use results computations specify answer sets programs constraints We present rationale classes computations consider discuss relationships We discuss relationships corresponding concepts answer sets One concepts compelling characterizations properties propose correct generalization answerset semantics case programs arbitrary constraints We notions answer set proposed literature programs constraints obtained framework results appropriately selected classes computations 2009 Elsevier BV All rights reserved 1 Introduction motivation We study logic programs arbitrary abstract constraints simply constraints Programs constraints provide general framework study semantics extensions logic programs aggregates It fact mal logic programs programs monotone convex constraints proposed Marek Truszczy nski 31 Liu Truszczy nski 25 classes programs aggregates 6143540 viewed special programs arbitrary constraints The original deﬁnition syntax programs constraints possible semantics proposed Marek Remmel 29 An alternative semantics later proposed Son Pontelli Tu 42 revisited Shen You 38 You Yuan Liu Shen 45 In paper introduce general framework deﬁning investigating semantics programs constraints We base development notion computation The proposed framework builds general principles elicited semantics traditional normal logic programs logic programs negation failure The answerset semantics logic programs introduced Gelfond Lifschitz 20 The semantics generalizes stablemodel semantics Gelfond Lifschitz 19 proposed class normal logic programs logic programs negations negation failure classical negation In paper consistently use term answerset semantics currently widely bulk paper concerned programs normal An extended abstract paper appeared Proceedings 2007 International Conference Logic Programming Corresponding author Email addresses lliu1csukyedu L Liu epontellcsnmsuedu E Pontelli tsoncsnmsuedu TC Son mirekcsukyedu M Truszczy nski 00043702 matter 2009 Elsevier BV All rights reserved doi101016jartint200911016 296 L Liu et al Artiﬁcial Intelligence 174 2010 295315 The answerset semantics forms foundation AnswerSet Programming ASP 303318 Intuitively answer set program represents set justiﬁed beliefs agent knowledge encoded program Over years researchers developed characterizations answer sets identify emphasize key features suggest ways compute The original deﬁnition answer sets 19 introduces guessandcheck approach computing answer sets program The process starts guessing interpretation candidate answer set proceeds validating The validation consists recomputing guessed interpretation starting set iteratively applying immediate consequence operator 43 GelfondLifschitz reduct program 19 The interpretation accepted limit iterative process In approach guess validation entirely deterministic Other characterizations answer sets suggest alternative scheme constructing answer sets The process starts case set At step add set construction heads rules applicable step Typically use rules selected previous steps longer applicable construction terminates failure plus additional ones When process stabilizesie new elements introduced setthe result answer set 2732 In approach replace initial nondeterministic step guessing entire interpretation local nondeterministic choices rules ﬁre step construction Similarly task validation distributed computation Observe approach characterizing answer sets represents underlying model employed ASP solvers 3valued partial models 44 extended stable models Example 1 Let consider program P 1 consisting following rules b b c d b This program answer sets c b d1 In guessandcheck approach guess c candidate answer set To verify guess compute GelfondLifschitz reduct consisting rules c d b The validation requires determining ﬁxpoint immediate consequence operator reduct programie Herbrand model reduct programwhich corresponds c Since coincides initial guess guess validated answer set In way validate guess b d However validation failssince reduct program contains rules c d b iteration immediate consequence operator converges c different initial guess The alternative approach mentioned starts interpretation makes rules applicable b b The algorithm needs select application selects b The choice results new interpretation Two rules applicable b c Let select rules application The resulting interpretation c The rules applicable previous step applicable rules applicable Thus possibility add new elements current set The computation stabilizes c making c answer set We note ﬁrst approach starts tentative answer set program second starts interpretation In ﬁrst approach guess entire answer set point proceed determin istic fashion In second approach construct answer set incrementally making nondeterministic choices 1 Since example paper consider classical negation following tradition logic programming answer set set atomsthat contains atoms true remaining atoms considered false default L Liu et al Artiﬁcial Intelligence 174 2010 295315 297 way Thus approach involves nondeterminism However second approach role nondeterminism potentially limited In paper cast approaches terms abstract principles related notion computation We lift principles case programs abstract constraints derive approach wellmotivated semantics programs The recent ASP fueled development inference engines compute answer sets logic programs notably systems like Smodels 34 Cmodels 23 clasp 16 DLV 22 allow programmers tackle complex realworld problems 22113 To facilitate declarative solutions problems knowledge represen tation reasoning researchers proposed extensions logic programming language support aggregates 336 814173539 These development efforts stimulated logic programming formalisms based abstract constraint atoms orig inally proposed Marek Remmel 29 Marek Truszczy nski 31 The objective introduce knowledge representation language abstract framework study semantics knowledge representation systems obtained extending syntax logic programs aggregates The need arose introduction constraints aggregates logic programming created challenge extend semantics Researchers proposed possible approaches 14840421141 These approaches agree large classes programs including normal logic programs extension contains class programs monotone aggregates weight atoms weights nonnegative upper bound given regarded special programs monotone constraints presented Marek Truszczy nski 31 programs convex aggregates weight atoms weights nonnegative lower bounds given regarded special programs monotone constraints presented Liu Truszczy nski 25 However proposed approaches tend differ programs arbitrary aggregates What makes task deﬁning answer sets programs aggregates diﬃcult interesting nonmonotonic behavior constraints For instance let consider constraint p1 p1 p1 p12 seen encoding aggregate cid4 cid4 X 1 1 pX 0 Sum cid5cid6 cid2cid3 X This aggregate atom true interpretations p1 p1 false p1 p1 Therefore monotone observe convex In paper propose study general framework deﬁning semantics different types answer sets logic programs constraints Our proposal relies notion incremental computation We introduce classes computations use results deﬁne different types answer sets The approach traced basic methods characterize answer sets normal logic programs mentioned The notion computation introduce use generalizes developed Marek Truszczy nski 31 Liu Truszczy nski 25 programs monotone convex constraints We study properties classes computations introduced corresponding notions answer sets We relate computationbased concepts answer sets earlier proposals An interesting observation investigation characterizations converge semanticswhich correspond proposed Son Pontelli Tu 42 A preliminary approach notion computation investigated paper presented Liu Pontelli Son Truszczy nski 24the present manuscript deeply revises reorganizes ideas work leading deﬁnitions results signiﬁcantly different advanced presented earlier The contributions presented work importance ﬁeld logic programming overall domain knowledge representation AnswerSet Programming gained momentum instrument design intelligent agents investigating properties reasoning complex domains domains multiple interacting agents domains incomplete knowledge domains nondeterministic actions Several recently explored extensions languages AnswerSet Programming motivated needs applications areas research 910 In invited talk AAAI05 conference given Baral 4 logic programming answerset semantics presented attractive suitable knowledge representation language AI research features desirable properties In particular formalism declarative simple syntax nonmonotonic expressive representing classes problems complexity hierarchy 5 solid theoretical foundations large body building block results 3eg equivalence programs systematic program development relationships nonmonotonic formalisms supported eﬃcient computational tools mentioned earlier 2 We introduce notation Section 4 298 L Liu et al Artiﬁcial Intelligence 174 2010 295315 The general framework abstract constraints provides foundation investigation generalizations current ASP formalisms meet needs knowledge representation reasoning applications 2 Normal logic programs answerset semantics A normal logic program P set rules form a1 am1 1 0 cid2 m cid2 n ai atom ﬁrstorder language L negationasfailure default negation nective An expression form atom default literal A literal atom default literal A program positive Horn contain default literals The Herbrand universe Herbrand base program deﬁned standard way 26 All major semantics programs restricted Herbrand interpretations program ground instantiation equivalent That includes answerset semantics Ground programs semantics Herbrand models essentially propositional programs Thus consider propositional programs ﬁxed countable set At propositional atoms For propositional rule r form 1 head r We denote hdr We set posr a1 negr am1 Finally denote bodyr body rule r set literals righthand rule r We represent Herbrand interpretations subsets At An atom satisﬁed Herbrand interpretation M At M A default literal satisﬁed M M We write M cid8 cid2 denote literal cid2 satisﬁed M Similarly S set conjunction literals write M cid8 S denote M cid8 cid2 cid2 S A rule r Mapplicable M cid8 bodyr We denote P M set Mapplicable rules P An atom supported M P head Mapplicable rule r P An interpretation M satisﬁes P model P contains atoms supported M P An interpretation M supported model P M model P atom M supported M P Observe model program supported model For example set b model program P b supported model P b supported b The immediate consequence operator referred onestep provability operator maps interpretations interpre tations Speciﬁcally assigns interpretation M set heads rules P M set atoms supported M P We denote operator T P Formally cid3 hdr M cid8 bodyr r P T P M cid5 One check ﬁxpoints T P supported models P 1 For later use let introduce following notion iterated applications T P Let cid9T P icid11 i0 sequence T P 0 T P 1 T P T P We note P positive program T P monotone continuous operator ﬁxpoint denoted i0 T P Many properties T P lfpT P unique Herbrand model P It known lfpT P discussed example Lloyd 26 cid7 The GelfondLifschitz reduct P wrt M denoted P M program obtained P deleting 1 rule body contains default literal M 2 default literals bodies remaining rules Note P M positive program model lfpT P M An interpretation M stable model answer set P M model P M Thus M answer set P M lfpT P M It follows directly deﬁnitions model positive program answer set program 3 Computations normal logic programs Principles We start motivating notion computation central paper tool determine answer sets normal logic programs Our starting point collection considerations introduced Example 1 In particular use computations characterize answer sets We deﬁne computations normal program P sequences cid9 Xicid11 i0 sets atoms propositional interpretations Xi represents state computation step In particular require X0 A key intuition step cid3 1 use P revise state Xi1 computation new state Xi We base revision L Liu et al Artiﬁcial Intelligence 174 2010 295315 299 nondeterministic operator ConclP Given interpretation X ConclP X consists possible revisions X grounded P Formally set atoms Y grounded set atoms X program P Y T P X atom Y supported X P Thus ConclP X Y Y T P X The ﬁrst principle impose computations formalizes way states computations revised We principle revision R Revision successive element computation grounded preceding program Xi ConclP Xi1 cid3 1 Computations answer sets program methods described Example 1 produce sequences sets monotonically growing wrt set inclusion set answer set construction Thus step new atoms computed atoms established earlier recomputed This suggests principle computations principle persistence beliefs P Persistence beliefs element computation contain previous revise atom Xi1 Xi 1 cid2 For sequence cid9 Xicid11 i0 Xi refer X result cid9 Xicid11 i0 The result computation interpretation revised This suggests additional basic principle computations principle convergence i0 satisfying principle P deﬁne X cid7 C Convergence computation continues stabilizes additional revisions Formally speaking convergence requires X T P X T P onestep provability operator P In particular convergence implies X supported model P These observations summarized following deﬁnition Deﬁnition 1 Let P normal logic program A sequence interpretations cid9 Xicid11 cid9 Xicid11 i0 satisﬁes principles R P C i0 computation P X0 Computations relevant task describing answer sets normal logic programs We following result Proposition 1 Let P normal logic program If set atoms X answer set P exists computation cid9 Xicid11 P X X i0 Proof If X answer set P X ﬁxpoint T P X Let deﬁne Xi T P X It follows property operator T P X X lfpT P X i0 computation P i0 Xi To complete proof suﬃces cid9 Xicid11 i0 T P X cid7 cid7 First note T P X monotone operator X0 It follows cid3 1 Xi1 T P X Xi1 Xi Thus principle persistence beliefs holds We cid3 0 Xi X X X Consequently cid3 1 Xi T P X Xi1 T P Xi1 principle revision holds Finally X answer set P X supported model P Consequently T P X X principle convergence holds cid2 Proposition 1 implies principles R P C notion computation broad encompass answer sets Is concept computation needed characterize answer sets In words sequence sets atoms starting satisfying principles R P C result answer set It case positive programs Proposition 2 Let P positive logic program The result computation equal model P unique answer set P Proof Let cid9 Xicid11 i0 computation P M model P Since P positive T P monotone operator By deﬁnition computation monotonicity T P Xi T P This implies X M cid7 i0 T P On hand M model P X model P M X M This proves proposition cid2 However case arbitrary normal programs computations result answer sets shown following example 300 L Liu et al Artiﬁcial Intelligence 174 2010 295315 Example 2 Let consider program P 2 containing rules This program answer sets The sequence X0 X1 X2 satisﬁes R P C compu tation P However X i0 Xi answer set P 2 cid7 It follows notion computation deﬁned principles R P C broad capture precisely notion answer set Let reconsider Example 2 In example X1 body ﬁrst rule satisﬁed interpretation However body ﬁrst rule satisﬁed set Xi cid3 1 On hand Xi cid3 2 body second rule satisﬁed Xi1 Thus reason presence revision changes ﬁrst second step This reason computation result answer set satisﬁes principle P These considerations suggest useful classes computations obtained requiring atoms reasons including atoms persist Intuitively like associate atom included Xi rule supports inclusion rule remain applicable point More formally state principle follows Pr Persistence reasons X rule ra P called reason head body holds Xi cid3 ia 1 ia integer Xia It turns persistence reasons exactly needed characterize answer sets normal logic programs Deﬁnition 2 Let P normal logic program A computation cid9 Xicid11 i0 P persistent satisﬁes principle Pr The proposition shows principle persistence reasons exactly need capture answerset semantics computations Proposition 3 Let P normal logic program A set X answer set P persistent computation P result X Let cid9 Xicid11 Proof Let X answer set P It easy computation constructed proof Proposition 1 result X persistent computation P That proves onlyif proposition i0 persistent computation P X X First observe cid3 0 Xi T P X We prove induction The base case evident proceed induction step consider Xi1 By persistence reasons rule ra integer ia cid2 hdra X j cid8 bodyra j cid3 ia It follows P X r X default literal b bodyra b X Thus r X denote rule obtained ra removing Xi T P X Xi By induction ia cid2 Xia default literals body ra Since Xia hypothesis monotonicity T P X T P X T P X It follows T P X 1 Xi1 T P X 1 That lfpT P X completes induction shows X On hand X supported model P X model P X Hence lfpT P X X Thus X lfpT P X X answer set P proves proposition completes proof cid2 cid8 bodyr X i0 T P X cid7 In general operator ConclP offers choices revising current interpretation Xi1 Xi compu tation A natural question freedom needed restrict principle R loosing ability characterize answer sets normal logic programs Example 3 Let P 3 normal logic program b c b e c f c This program answer set M c e generated computation c c e L Liu et al Artiﬁcial Intelligence 174 2010 295315 301 In computation step 1 2 select Xi greatest element ConclP 3 Xi1 exists given T P 3 Xi1 Thus element computation result ﬁring applicable rules On hand selecting element ConclP 3 X T P 3 X result sequences ex tended computation For example sequence f represents potential computation satisﬁes R P principles Yet possible extension sequence satisﬁes C principle This example indicates interesting classes computations obtained restricting operator ConclP Since X T P X ConclP X restrict choice possible revisions X based P T P X The class computations obtained restriction proper subset class computations For instance program P 1 Example 1 admit computations revise X0 X1 T P X0 Thus class computations adequate task characterizing answer sets normal logic program We note characterize answer sets certain special classes logic programs instance stratiﬁed logic programs 1 To obtain general characterization answer sets restricting choices offered ConclP X need modify operator T P X The ﬁrst approach computing answer sets discussed introduction provides clue need modify notion satisﬁability deﬁnition T P X Let M interpretation We deﬁne satisﬁability relation cid8M sets atoms conjunctions literals follows given set atoms S conjunction literals F relation S cid8M F holds S cid8 F M cid8 F That satisfaction based S current state computation M context computation We deﬁne contextbased onestep provability operator T M P follows cid4 cid4 X cid8M bodyr r P hdr cid3 cid5 P X T P X consequently T M P X ConclP X Thus obtain following result P X T M We note T M Proposition 4 Let P normal logic program M interpretation A sequence cid9 Xicid11 1 2 computation P satisﬁes principles P C i0 Xi T M P Xi1 Given interpretation M sequence cid9 Xicid11 P Xi1 1 2 uniquely determined M Whenever sequence satisﬁes principles P C refer Mcomputation We observe Mcomputations deﬁne answer sets illustrated following example i0 Xi T M Example 4 Let P 4 normal logic program b b Let M One check rule r P 4 M cid8 bodyr Thus set X atoms T M Consequently b Mcomputation However b answer set P 4 P X T P X The problem Mcomputations fail persistent In fact Mcomputation described Example 4 satisfy persistence reasons principle However persistent Mcomputations special persistent computations result answer sets Moreover answer set result persistent Mcomputation Proposition 5 Let P normal logic program A set M At answer set P Mcomputation persistent result M Proof If M result persistent X computation M particular result persistent computation Thus Proposition 3 M answer set On hand let assume M answer set P We observe set atoms Y T P MY T P M Y Moreover Y M converse inclusion holds Indeed Y M T P M Y rule r P hdr M cid8 bodyr Y cid8 bodyr M r M denotes rule obtained r removing bodyr default literals In particular follows r P M T P MY The inclusions imply Y M T P MY T P M Y We observe T M P Y T P M Y It follows computation constructed proof Proposition 1 Mcomputation persistent Proposition 3 Since result M assertion follows cid2 P Y T P MY Thus Y M T M An stronger result proved answer sets characterized proper subclass persistent M computations We Mcomputation selfjustiﬁed result M In general class selfjustiﬁed Mcomputations proper subclass Mcomputations Indeed shown Example 4 Mcomputations persistent 302 L Liu et al Artiﬁcial Intelligence 174 2010 295315 prove selfjustiﬁed Mcomputations satisfy persistence reasons property We use fact selfjustiﬁed computations characterize answer sets Proposition 6 Let P normal logic program A set atoms M answer set P Mcomputation selfjustiﬁed Proof In proof Proposition 5 showed M answer set P generates Mcomputation result M proves direction proposition Conversely let M set atoms determines selfjustiﬁed Mcomputation let cid9 Xicid11 i0 computation conclude desired result suﬃces cid9 Xicid11 i0 computation i0 persistentthen result Since cid9 Xicid11 immediate Proposition 3 Thus let M let integer Xi It follows cid3 1 T M P Xi1 Thus rule r P M M cid8 bodyr Xi1 cid8 bodyr For j cid3 Xi1 X j M Thus X j cid8 bodyr persistence computation follows cid2 We summarize discussion section follows Our goal characterize answer sets normal logic programs terms computations More speciﬁcally taking ways computing answer sets starting point introduced characterizations answer sets terms computations persistent computations persistent M computations selfjustiﬁed Mcomputations subsequent class proper subclass preceding In Sections 5 6 generalize classes computations discussed case programs constraints We use generalized computations deﬁne characterize answer sets programs 4 Programs abstract constraints Basic deﬁnitions We recall basic deﬁnitions concerning programs constraints 293125 As ﬁx countable inﬁnite set At propositional atoms An arbitrary abstract constraint simply constraint expression A X C X At ﬁnite set C P Xwhere P X denotes powerset X The set X called domain A elements C called satisﬁers A Given constraint A X C denote X Adom C Asat Intuitively sets Asat precisely subsets Adom satisfy constraint It common recognize special types constraints A constraint inconsistent satisﬁers We distinguish special inconsistent constraint denote A constraint A monotone X Asat Y X Y Adom Y Asat A constraint A convex X Y Asat Z X Z Y Z Asat Constraints building blocks rules programs A rule expression A A1 Ak 2 A A1 Ak constraints A constraint program program collection rules A program monotone convex constraint occurring monotone convex Given rule r form 2 constraint A head r set constraints A1 Ak body r view body rule conjunction constraints Following notation introduced earlier denote head body r hdr bodyr respectively We deﬁne headset r hsetr domain head r hsetr hdrdom For set rules P deﬁne hsetP We view subsets At interpretations We M At satisﬁes constraint A denoted M cid8 A M Adom Asat For rule r M satisﬁes r denoted M cid8 r M satisﬁes hdr M satisfy constraint bodyr An interpretation M model program P satisﬁes rules P rP hsetr cid7 Let M interpretation A rule Mapplicable M satisﬁes constraint bodyr M cid8 bodyr As Section 2 denote P M set Mapplicable rules P Let P program A model M P supported M hsetP M Observe deﬁnition conclude model M supported M satisfy hdr rule r applicable M Let P program M set atoms A set X nondeterministically onestep provable M means P X hsetP M X cid8 hdr rule r P M The nondeterministic onestep provability operator P PAt P T nd cid2 cid6 PAt program P operator T nd means P M At In words cid3 P M T nd X X hset cid2 cid6 P M cid2 r P M cid6cid5 X cid8 hdr P M consists sets nondeterministically onestep provable M Observe X T nd P M X model P M L Liu et al Artiﬁcial Intelligence 174 2010 295315 303 For arbitrary atom At constraints said elementary Since models identify denote constraint simply For analogous reasons identify constraint literal Given normal logic program P rule r P denote Cr rule obtained replacing positive atom r constraint replacing literal r constraint Let CP Cr r P We Cr CP constraint representation r P respectively It easy CP convex program It possible supported models P coincide supported models CP answer sets P coincide answer sets CP according deﬁnition answer sets presented Liu Truszczy nski 25 In words programs constraints suﬃcient express normal logic programs We conclude section example illustrating different concepts related constraints Example 5 Consider program P b b c c b c b c cid5cid6 cid2 cid5cid6 cid2 cid3 cid5cid6 b cid3 b cid5cid6 b b cid3 cid3 cid2 cid2 b c b c b b c r1 r1 r2 r3 r4 We constraints occurring P consistent written rules r2 r3 monotone constraint b c b c b c monotone constraint convex constraint b b monotone convex hsetr1 hsetP b c hsetr2 set M satisﬁes head r1 satisfy body r1 M set Mapplicable rules r3 r4 P r3 r4 set model program satisfy r3 set c model program b c supported M P M r1 r4 implies T nd P M c b c 5 Computations programs constraints In section extend notion computation programs constraints use computations deﬁne generalization answerset semantics programs Our approach based exploiting intuitions developed Section 3 case normal logic programs In order deﬁne computations programs constraints consider principles identiﬁed Section 3 The key step generalize revision principle For normal programs principle based sets atoms grounded set atoms X current interpretation P We extend concept programs constraints Deﬁnition 3 Let P program constraints let X At set atoms A set Y grounded X P exists set rules Q P X Y T nd Q X We denote ConclP X collection sets Y grounded X P The intuition analogous case normal logic programs There set Y grounded X normal logic program P Y justiﬁed means X applicable rules P That Y ConclP X Y T Q X Q P X Thus deﬁnition ConclP X constraint program P generalizes earlier deﬁnition With deﬁnition ConclP X principle R lifts changes program constraintswe refer cid17 The true principle P cid17 An appropriate generalization principle C expressed terms supported models version principle R case program constraints R referred P follows cid17 Convergence X supported model P X T nd C P X Finally principle Pr generalized At step computation satisﬁes R element ConclP Xi1 From deﬁnition ConclP Xi1 program P i1 P Xi1 Xi T nd P i1 cid17 follows Each program viewed reason Xi We state generalized principle Pr cid17 select Xi Xi1 304 L Liu et al Artiﬁcial Intelligence 174 2010 295315 cid17 Persistence reasons There sequence programs cid9P icid11 i0 cid3 0 P P i1 P P Xi Pr Xi1 T nd P Xi The deﬁnition implies j cid3 P P j P P X j That principle requires rules step persist P P j j cid3 applicable successive steps P P X j j cid3 Having generalized principles R P C Pr deﬁne R cid17 class programs constraints extend concept computation literally lifting deﬁnitions developed case normal logic programs However resulting notion undesired properties shown example cid17 Pr cid17 P cid17 C Example 6 Let P 5 program cid3 b b b b cid2 cid2 cid6 cid5cid6 The constraint body satisﬁed interpretations b true false The head rule satisﬁed case b true It easy sequence b b satisﬁes properties R cid17 On hand outcome satisfactory b result computation selfsupport Given b result sequence set ensuring rule b b b b remains applicable independently happen later computation b Indeed satisﬁer body rule weak nonmonotonicity constraint The set potentially revised b possible priori possible rules present program For sets rule applicable persistence reasons violated cid17 Pr cid17 P cid17 C To better present point let contrast situation case logic program P 6 consisting following rules syntax resembling Smodels b 1a b c2 The body second rule satisﬁed interpretation contains b c The cid17 Also case look b self sequence b b satisﬁes properties R supported But fact Given result computation b establish computation second rule remain applicable matter current state revised long revision b In words view second rule b hold suﬃces know b depends cid17 Pr cid17 P cid17 C The key convexity constraint 1a b c2 ensures gaps derivation atom trigger rule result computation b Every set guaranteed activate rule satisfying body This exactly property missing case program P 5 Our example suggests case programs arbitrary constraints properties introduced capture needed computation rise reasonable notion answer set We need require result computation wellfounded element derived process remains founded elements derived earlier rest computation In order formalize concept need introduce additional deﬁnitions Let A constraint X Y set atoms The set Y X trigger A set Z Y Z X Z cid8 A If r rule Y X trigger r X trigger constraint A body R set Z Y Z X Z cid8 bodyr Thus Y X trigger r long computation X Y suﬃcient justiﬁcation applying r atoms derived based r regarded founded Y This idea captured following property FPr Founded persistence reasons There sequence programs cid9P icid11 P Xi Xi1 T nd P Xi rule P Xtrigger contained Xi i0 cid3 0 P P i1 P Thus principle founded persistence reasons simply strengthens persistence reasons founded ness requirement We use principles introduced deﬁne types computations programs arbitrary straints Deﬁnition 4 Let P program constraints A sequence interpretations cid9 Xicid11 cid17 C sequence satisﬁes principles R A computation founded satisﬁes principle FPr cid17 A computation persistent satisﬁes principle Pr i0 computation P X0 cid17 cid17 P L Liu et al Artiﬁcial Intelligence 174 2010 295315 305 Persistent computations computations As case normal programs converse true general Let consider program CP 2 P 2 normal logic program Example 2 The sequence computation persistent It coincidence derive counterexample normal logic program We following general result Proposition 7 Let P normal logic program The class computations P deﬁned Section 3 coincides class computations CP deﬁned section Similarly class persistent computations P deﬁned Section 3 coincides class persistent computations CP deﬁned section Proof It straightforward verify sequence cid9 Xicid11 deﬁned Section 3 cid9 Xicid11 computation P CP coincide i0 satisﬁes properties R i0 satisﬁes properties R cid17 P cid17 C cid17 P cid17 respect P cid17 respect CP Thus notions cid17 C Let result holds case persistent computations Let assume cid9 Xicid11 i0 satisﬁes cid17 P deﬁned Section 3 For atom X let ra denote rule satisfying condition cid17 Let P Cra Xi1 From persistence reasons P P P i1 P P Xi Xi1 cid17 CP deﬁned i0 sequence subprograms CP satisfying conditions Pr Xi Hence cid9P icid11 property Pr persistence Pr T nd P section Conversely let assume cid9 Xicid11 i0 satisﬁes property Pr cid17 CP deﬁned section let cid9P icid11 i0 sequence subprograms CP demonstrates For X let index Xi1 Xi Because Xi1 T nd P Xi conclude exists rule ra P Cra P hsetra Since P CP Xi Xi cid8 bodyra hdra The monotonicity cid9P icid11 i0 implies Cra P j j cid3 The condition P j CP X j implies Cra applicable X j j cid3 Thus ra applicable X j j cid3 Hence cid9 Xicid11 i0 persistent computation P according deﬁnition Section 3 cid2 For normal logic programs need impose principle founded persistence explicitly It possible case normal logic programs persistent computations founded3 Thus normal logic programs classes computations coincide In fact property holds larger classes programsthe class programs convex constraints includes normal logic programs precisely programs form CP P normal program Proposition 8 Let P program convex constraints A computation P founded persistent Proof From previous observations know founded computation persistent Thus need persistent computation P founded Let cid9 Xicid11 i0 sequence programs demonstrating cid9 Xicid11 i0 persistent computation P let cid9P icid11 Let r P cid3 0 It follows r P Xi Xi cid8 bodyr From persistence reasons r P X j j cid3 ﬁniteness domains constraints r P X Thus X cid8 bodyr Since constraints body r convex Z Xi Z X Z cid8 bodyr It follows Xi Xtrigger r Consequently computation cid9 Xicid11 i0 satisﬁes property Pr i0 founded cid2 cid17 However general case programs arbitrary constraints class persistent computations proper subclass class founded computations The inclusion follows directly deﬁnition The program P 5 Example 6 shows proper For programs arbitrary constraints use founded computations basis generalization answerset semantics Deﬁnition 5 Let P program constraints A set X answer set P founded computation P result X Propositions 7 8 imply concept answer set speciﬁed Deﬁnition 5 generalizes normal logic programs Corollary 1 Let P normal logic program A set X At answer set P X answer set CP Proof We X answer set P persistent computation P result X From Proposition 7 case founded computation CP result X X answer set CP cid2 3 We assume natural deﬁnition founded persistence normal logic programs based correspondence P CP 306 L Liu et al Artiﬁcial Intelligence 174 2010 295315 We deﬁnition answer set generalizes notion answer set programs convex constraints proposed Liu Truszczy nski 25 property formally state prove later paper We conclude section observing determined far distinct classes models programs constraints answer sets models obtained persistent computations models obtained results computations supported models Each class models subclass general proper successive The role classes models properties require studies scope paper We note thanks principle C cid17 supported models form superclass class results computations However supported models programs obtained results computations For instance supported model program CP P computation CP result To capture supported models results bottomup process notion computation broadened relaxing key principles In following section way goal accomplished 6 Computations quasisatisﬁability relations The notion computation discussed far makes use nondeterministic operator ConclP revise interpre tations occurring computation As mentioned earlier use ConclP provides wide range choices revising state computation considering subsets applicable rules In section study sequences interpretations generated narrowing set choices allowed ConclP X possible revisions X In case normal logic programs accomplished goal means P based satisﬁability relation cid8M In case computation determined operator T M choice M Thus nondeterministic decision selection M Once nondeterminism left We proved M answer set logic program P M result computation generates In words computation contextdependent This idea studied context default logic Marek Truszczy nski 32 We generalize approach case programs constraints Deﬁnition 6 A sequence cid9 Xicid11 C cid17 X0 i0 weak computation program constraints P satisﬁes properties P cid17 Thus weak computations sequences rely program P moving step step 1 Next deﬁne broad class weak computations degree restores role P revision mechanism Let cid18 relation sets atoms interpretations abstract constraints We extend relation cid18 case conjunctions sets constraints follows X cid18 A1 Ak X cid18 Ai 1 cid2 cid2 k This relation intended represent concept satisﬁability constraints conjunctions We relations quasisatisﬁability relations They later allow generalize relation cid8M For quasisatisﬁability relation cid18 deﬁne cid18 P X cid4 cid5 cid4 X cid18 bodyr cid3 r P cid18 X set rules P applicable respect X satisﬁability relation cid18 cid3 In words P Next deﬁne T ndcid18 In words T ndcid18 similarly T nd X P P Y Y hset cid2 cid18 cid6 X P r P cid18 cid2 X cid6cid5 Y cid8 hdr X consist sets Y hsetP cid18 X Y cid8 hdr r P cid18 X Thus T ndcid18 P works P rules P cid18 X ﬁred P X Deﬁnition 7 Let cid18 quasisatisﬁability relation A weak computation cid9 Xicid11 T ndcid18 Xi cid3 1 P i0 weak cid18computation P Xi1 Since impose particular properties quasisatisﬁability relation cid18 guaranteed X ConclP X Thus weak cid18computations guaranteed computations There simple T ndcid18 suﬃcient conditions guaranteeing weak cid18computations computations P We quasisatisﬁability relation cid18 subsatisﬁability relation X At abstract cid18 X P X This property straint A X cid18 A implies X cid8 A Observe cid18 subsatisﬁability relation P appropriate deﬁnitions imply X T ndcid18 P cid18 XX T nd P cid18 XX T ndcid18 P 3 We observe relation cid8M considered Section 3 subsatisﬁability relation Proposition 9 Let P program constraints If cid18 subsatisﬁability relation X At T ndcid18 ConclP X P X L Liu et al Artiﬁcial Intelligence 174 2010 295315 307 Proof Consider Y T ndcid18 P cid18 X X Thus follows Y ConclP X cid2 T nd P X Since cid18 subsatisﬁability relation P cid18 X P X Moreover Eq 3 T ndcid18 P X The following corollary obvious consequence Proposition 9 Corollary 2 If cid18 subsatisﬁability relation weak cid18computation computation Thus cid18 subsatisﬁability relation write cid18computation interchangeably weak cid18com putation We recall P normal logic program M answer set P M result Mcomputation P We use weak cid18computations cid18computations generalize notion Mcom putation programs constraints To end extend approach proposed studied Son et al 42 Our method requires mapping f X Thus explore possibility quasisatisﬁability relation change function target model X trying achieve Later section explore particular mapping f alternative mappings explored later section assigns set X atoms quasisatisﬁability relation cid18 f Deﬁnition 8 Let P program constraints f mapping assigning set X atoms quasisatisﬁability relation cid18 f X computation P A set atoms X f model P X result selfjustiﬁed weak cid18 f X computation P X result C C selfjustiﬁed weak cid18 f X If C weak cid18 f X computation P The deﬁnition f model sound Since weak computations satisfy property C cid17 results models P In fact supported models Several interesting classes models programs constraints described terms f models specializing mapping f We demonstrate ﬂexibility approach presented later paper In order specialize general approach selfjustiﬁed weak computations generalize notion answer set need identify mappings f ensure selfjustiﬁed weak computations computationsie satisfy revision principleand founded We seen cid18 f X subsatisﬁability relation weak cid18 f X computations We seek conditions guaranteeing foundedness cid18 f X computations computations referred cid18 f X computations We ﬁrst address weaker property persistence reason Pr cid17 The proposition follows Eq 3 Proposition 10 Let cid18 subsatisﬁability relation let C cid9 Xicid11 0 1 Xi cid18 A implies Xi1 cid18 A C persistent i0 cid18computation If constraint A Proof Since cid18 subsatisﬁability relation P P P cid18 Xi satisﬁes persistence condition cid2 cid18 X P X It follows Eq 3 Deﬁnition 7 sequence We subsatisﬁability relation proposed Son et al 42 gives rise founded computations X A set Z Y Z X Z cid8 A equivalently subsatisﬁability relation Thus deﬁnes computations Secondly C X satisﬁes assumptions Proposition 10 Using terminology X A Y X trigger A The connection Given set X atoms deﬁne cid18spt Z Adom Asat It easy cid18spt X computation persistent relation cid18spt cid18spt introduced earlier restate deﬁnition cid18spt deﬁnition founded persistence evident surprisingly selfjustiﬁed cid18spt X follows Y cid18spt X follows Y cid18spt X X computations founded Proposition 11 Let P program constraints If C selfjustiﬁed cid18spt X computation founded computation Proof To simplify notation write cid18 cid18spt i0 selfjustiﬁed cid18computation We cid17 cid18 Xi 0 1 property Pr argued C persistent computation sequence P P holds We rule P X trigger contained Xi To end let r P It follows Xi cid18 bodyr By deﬁnition cid18 cid18spt X Xi Z X Z cid18 bodyr Thus Xi X trigger r Consequently C founded cid2 X proof Let C cid9 Xicid11 Not founded computation C selfjustiﬁed cid18spt X computation This seen following example 308 L Liu et al Artiﬁcial Intelligence 174 2010 295315 Example 7 Consider program P remember shorthand b c cid2 cid3 b b cid5cid6 We b b c b c founded computation P selfjustiﬁed cid18spt end set b abcomputation Although founded computation selfjustiﬁed cid18spt X computation Thus results selfjustiﬁed cid18spt ﬁed cid18spt following result X computation answer set X selfjusti X computations P precisely answer sets P Formally Proposition 12 Let P program constraints let X answer set P Then selfjustiﬁed cid18spt P X computation Proof Also proof simplify notation write cid18 cid18spt X let cid9P icid11 i0 sequence programs demonstrating FPr holds X Let cid9 Xicid11 i0 founded computation result Let deﬁne Y 0 Y i1 hsetP X cid8 P X cid8 P Since hsetr hsetP Thus cid9Y icid11 i0 cid18computation P cid18Y By deﬁnition cid18 cid18spt cid18Y Y i1 cid8 hdr It follows Y i1 T nd cid18Y X 0 1 It follows 0 1 Y X Further cid18Y X cid8 bodyr Thus X cid8 hdr Y T nd Y X rule r P P cid18Y Y Since T ndcid18 P cid18Y Y Y i1 T ndcid18 P P Moreover Xi Y We prove claim induction For base case note X0 Y 0 Let cid18Y Indeed assume Xi Y We Xi1 T nd P r P r X trigger U r U r Xi It follows Z U r Z X Z cid8 bodyr Thus cid18Y Z Y Z X Z cid8 bodyr r P Xi Since Xi Y foundedness cid9 Xicid11 i0 implies P P Clearly P P turn implies cid18Y implies Xi1 hsetP cid7 i0 Y X It follows cid9Y icid11 cid18Y X Y i1 This completes proof claim The claim i0 selfjustiﬁed cid18spt X computation cid2 7 Discussion In section discuss additional properties semantics answer sets introduced paper In particular present alternative characterizations semanticsone based concept strong groundedness based existence ranking atoms second based program transformation Finally discuss alternative proposals semantics programs constraints aggregates 71 Strong groundedness answer sets One key properties answer sets normal logic programs selfsupported Namely following property derived general results Theorem 1 proposed Erdem Lifschitz 12 Theorem 1 Let P normal logic program M model P Then M answer set P ranking k assigning nonnegative integers atoms M atom M rule r P M hdr b posr ka kb We extend property case programs arbitrary constraints concept answer set introduced The notion Mtrigger property founded persistence reasons critical We recall set X Mtrigger rule r precisely Y X Y M Y cid8 bodyr In words X Mtrigger r having computed X guarantees rule remain applicable later computation long computation stays M In case X Mjustiﬁcation atom hsetr M We note rule Mtriggers Mjustiﬁcation elements headset rule We model M program arbitrary constraints strongly grounded ranking atoms M atom Mjustiﬁcation consisting entirely atoms strictly lower ranks We answer sets precisely models strongly grounded We start example Example 8 Let consider following program P 6 L Liu et al Artiﬁcial Intelligence 174 2010 295315 309 cid3 b cid5cid6 b cid2 b b Clearly M b model P 6 It easy M strongly grounded Indeed Mjustiﬁcation atom provided ﬁrst rule bthe satisﬁer Mtrigger rule supersets satisfy body rule The Mjustiﬁcation provided second rule b Mjustiﬁcation b provided rule Thus clear ranking necessary strong groundedness exists One verify P 6 answer sets The theorem relates notions answer sets strongly groundedness Theorem 2 A model M program arbitrary constraints answer set P strongly grounded Proof First let assume M answer set P It follows founded computation cid9 Xicid11 X M Let M We deﬁne ka minimum Xi Since M atom M i0 i0 Xi value ka deﬁned cid7 We ranking k witness M strongly grounded To end need atom M Mjustiﬁcation Let M Since cid9 Xicid11 i0 founded rule r set atoms Y hdr Y Xi1 Y Mtrigger r We observe b Y kb cid2 1 Thus Y Mjustiﬁcation Conversely let assume M strongly grounded model P We M answer set structing founded computation cid9 Xicid11 i0 M X Let k ranking witnesses strong groundedness M We deﬁne X0 We proceed inductively follows We deﬁne P cid3 0 consist rules Xi Mtrigger We deﬁne Xi1 cid3 0 setting Xi1 hsetP M Directly deﬁnition follows cid3 0 Xi M P P Xi P iM Since M model P i0 satisﬁes Xi Xi1 ConclP Xi cid9 Xicid11 r P hsetP M cid8 hdr Thus Xi1 T nd P principle R Next prove cid9 Xicid11 cid17 cid3 0 Xi Xi1 We proceed induction The inclusion X0 X1 evident By induction hypothesis Xi1 Xi Since Xi M Xi Mtrigger rule P i1 Thus P i1 P It follows i0 satisﬁes principle P cid17 Xi hsetP i1 M hsetP M Xi1 That completes proof inductive step claim property P cid17 The principle P cid17 implies cid3 0 P P i1 Together earlier observations implies cid9 Xicid11 i0 By deﬁnition X M We prove converse inclusion To end let consider M We prove satisﬁes principle FPr induction rank k Xk1 If M rank 0 Mjustiﬁcation rule r hsetr Mtrigger r It follows r P 0 hsetP 0 M X1 The reasoning inductive step essentially Let consider M ka k cid3 1 By deﬁnition rule r Y Mtrigger r Y consists atoms ranks strictly lower By induction hypothesis Y Xk Thus r P k Xk1 It follows M X Consequently M X To complete proof remains X supported model P cid9 Xicid11 cid17 To end recall cid3 0 P P iM Thus P P M Xi hsetP M X hsetP M Since M model P follows X supported model P cid2 i0 satisﬁes principle C 72 Answerset semantics program transformations Program transformations mappings assigning programs programs They form useful tool studies seman tics programs Invariance semantics particular program transformation yields methods program rewriting simpliﬁcation normal form representations programs Alternatively program transformations generalize semantics deﬁned programs simple syntactic form syntactic restrictions We consider simple transformation programs arbitrary constraints programs convex straints We transformation preserves semantics answer sets Given major proposals semantics programs convex constraints coincide result provides additional support notion answer set deﬁned 310 L Liu et al Artiﬁcial Intelligence 174 2010 295315 First program arbitrary constraints transformed headconvex program A rule r headconvex hdr convex constraint A program headconvex rules headconvex Let r A A1 Ak rule arbitrary constraints We represent headconvex rules cstrr spptr The ﬁrst rule cstrr A A1 Ak A denotes complement A constraint B B dom Adom Bsat X Adom X Asat The second rule cid2 cid6 spptr Adom X X Adom A1 Ak Clearly Adom X X Adom convex Thus rules cstrr spptr headconvex The role cstrr capture precisely constraint expressed r The role spptr support precisely atoms r exactly circumstances For program arbitrary constraints P deﬁne cid3 hcP cstrr cid5 cid4 cid4 r P cid3 spptr cid5 cid4 cid4 r P Theorem 3 Let P program arbitrary constraints M At Then M answer set P M answer set hcP Proof It evident M model P M model hcP Moreover directly deﬁnition follows M strongly grounded respect P M strongly grounded respect hcP Thus result follows Theorem 2 cid2 Next headconvex program transformed program convex constraints answer sets preserved Let A B constraints We A subconstraint B Adom Bdom Asat Bsat For constraint A denote mc A set maximal convex subconstraints A We note satisﬁer X A satisﬁer constraints mc A Given headconvex rule A A1 Ak deﬁne Cvxr set rules form A A mc Ai For headconvex program P set A cid17 cid17 1 A cid17 k CvxP cid8 rP Cvxr It clear CvxP program convex constraints Theorem 4 Let P headconvex program arbitrary constraints M At Then M answer set P M answer set CvxP Proof Sketch As ﬁrst note M model P M model CvxP Next note X Mtrigger rule r P rule r It follows M strongly grounded P M strongly grounded CvxP Thus result follows Theorem 2 cid2 cid17 Cvxr X Mtrigger r cid17 It follows transformation P CvxhcP preserves answer sets We note role transforma tion conceptual practical The program CvxhcP grow exponentially relative P size explosion potentially occurs second step transformation 73 More selfjustiﬁed weak cid18 f c computations Several interesting classes models deﬁned specifying mapping sets quasisatisﬁability relations determines class selfjustiﬁed weak computations class models Each class models deﬁned way consists supported modelssince require weak computations satisfy convergence principle We particular class supported models deﬁned terms Deﬁnition 9 Let X set atoms For set Y atoms constraint A deﬁne relation cid18supp X follows Y cid18supp X A X cid8 A We denote mapping X cid20 cid18supp X supp L Liu et al Artiﬁcial Intelligence 174 2010 295315 311 Let M supported model P We sequence C cid9 M M cid11 satisﬁes P cid17 weak computation Furthermore M supported model P P suppM P M This implies M T ndsupp M Thus C weak cid18supp M computation Thus supported models P suppmodels P As observed earlier f models supported models It follows supported models P precisely suppmodels P M computation As M result C C selfjustiﬁed weak cid18supp cid17 C P Next discuss semantics programs abstract constraints proposed Marek Remmel 29 That proposal based specialized notion program reduct Let A constraint By cid9A denote closure A constraint Adom Y Y Adom Z AsatZ Y Now given program P interpretation M NSSreduct P respect M obtained removing rules body satisﬁed M ii replacing remaining rule A A1 Ak set rules cid10A1 cid10Ak M Adom A set M atoms mranswer set M unique model NSSreduct P respect M NSSreducts unique models 29 Deﬁnition 10 Let X set atoms For set Y atoms constraint A deﬁne relation cid18mr X follows Y cid18mr X A exists Y cid17 Y Y cid17 cid8 A X cid8 A cid18mr M X P We mrmodels P precisely mranswer sets P Let M mranswer set P Q NSSreduct P respect M By deﬁnition M ﬁxpoint operator4 T Q X hdr r Q X cid8 bodyr Consider sequence C cid9 Xicid11 Q Because constraint Q monotone T Q M X Y M monotonic operator Thus C weak computation Furthermore deﬁnition cid18mr P M computation result M M mrmodel P M Xi This implies C selfjustiﬁed weak cid18mr M Y Xi1 T ndcid18mr cid18mr i0 Xi T Conversely M mrmodel P M result selfjustiﬁed weak cid18mr i0 Again let Q NSSreduct P respect M Since M cid8 A implies M cid8 cid11A constraint A M model Q Let Y T M construction Q operator T Q conclude X1 Y 1 Using induction similar arguments conclude Xi Y Thus ﬁxpoint Q cid17 M M M mranswer set P Q By deﬁnition operator T ndcid18mr model Q implies M This fact M satisfying M M M computation C cid9 Xicid11 The approach selfjustiﬁed weak cid18 f X computations extended Namely instead f assign ing quasisatisﬁability relations sets atoms assume f assigns quasisatisﬁability relations computations To illustrate point let assume C cid9 Xicid11 i0 computation deﬁne cid18C follows Y cid18C A Y Xi 0 cid2 X j cid8 A j cid2 j This particular approach interesting connections basic idea reduct We recall normal case set atoms context rejustify check phase Here computation context rejustify elements check phase The corresponding notion cid18C model desirable properties weak One cid18C models answer sets general conversely cid17 cid17 cid17 Even general version approach deﬁne classes models selfjustiﬁed weak computations limitations Let recall semantics programs aggregates proposed Faber et al 14 restate programs constraints A set atoms M FLPanswer set program constraints P M minimal model P M So far unable cast semantics terms selfjustiﬁed weak computations 74 Answer sets programs aggregates As discussed papers considering abstract constraints 293128 abstract constraints represent extensions logic programs including aggregates 814153541 Intuitively aggregate atom A represented constraint C A Adom Asat Adom set atoms occurring set expression A Asat contains subsets Adom satisfy aggregate In remainder section AP mean program constraints obtained program aggregates replacing aggregates corresponding constraints Proposition 12 results developed Son Pontelli Elkabani 41 Son Pontelli Tu 42 allow relate answer sets introduced semantics programs aggregates proposed First note monotone aggregates constraints allowed approaches coincide Proposition 13 See 42 For program monotone aggregates P M answer set AP answer set P respect deﬁnitions proposed Faber et al 14 Ferraris 15 Another important approach semantics aggregates logic programming investigated Pelov De necker Bruynooghe 36 Pelov 35 based approximation theory developed 7 The proposal Pelov 4 Abusing notation use immediate consequence operator T P deﬁned normal logic programs 312 L Liu et al Artiﬁcial Intelligence 174 2010 295315 et al 36 Pelov 35 deﬁnes exploits socalled ultimate approximation operator Φ aggr A complete twovalued interpretation M answer set according Pelov et al 36 ﬁxpoint Φ aggr If P positive program aggregates notion deﬁned Pelov et al 36 Pelov 35 program AP monotone constraints bodies rules following result P P Proposition 14 Let P positive program aggregates Then answer set AP answer set according deﬁnition Pelov et al 36 vice versa The proof proposition relies Proposition 12 Theorem 3 Son Pontelli 40 The relationship semantics discussed brakes allow programs aggregates monotone This illustrated following examples Example 9 Consider program P cid3 cid2cid3 cid3 cid5 p1 p1 p1 p1 p1 p1 p1 cid5cid5cid6 p1 p1 Intuitively abstract atom A p1 p1 p1 p1 represents aggregate atom Sum X p X 0 Count X p X cid22 1 domain variable X 1 1 This program model M1 p1 p1 The approaches Marek Remmel 29 Faber et al 14 Ferraris 15 accept M1 answer set approach Pelov 35 Denecker et al 8 admit answer sets It easy founded computation P result M1 In fact program computation applicable rule given X0 ﬁrst rule X1 p1 applicable rule respect X1 rule X2 p1 sequence violates property P Alternatively argue semantics allowing p1 p1 answer set noting model p1 p1 selfsupported Indeed strongly grounded proper ranking elements note program P isomorphic program P 6 considered Example 8 cid17 Let consider program consisting rules p p cid2 p p cid6 The approach Pelov et al 36 accepts M p answer set approach Finally note proposals developed Faber et al 14 Pelov 35 allow aggregates head rules consider disjunctive logic programs aggregates 75 Other semantics programs abstract constraints We mentioned relationship computation characterization answer sets charac terization proposed Son et al 42the described subsatisﬁability relation cid18spt X For semantics proposed Marek Remmel 29 following observations corollaries results results Son et al 42 1 Each answer set P according deﬁnition given paper answer set according Marek Remmelthis result derived observation analogous property holds answer sets discussed Son et al 42 2 There answer sets according Marek Remmel answer sets according deﬁnitions paper This seen program b c cid2 cid3 b c b c cid5cid6 The characterization Marek Remmel accepts b c answer set On hand computation order produce b c need organized follows b c But computation clearly founded L Liu et al Artiﬁcial Intelligence 174 2010 295315 313 Marek Truszczy nski 31 Marek et al 28 propose characterization answer sets program monotone constraints later extended case convex constraints Liu Truszczy nski 25 These semantics proved coincide answer sets obtained cid18spt X Son et al 42 answer sets deﬁned paper Another interesting line research recently proposed Shen You 38 The authors propose model theoretic semantic characterization programs constraints based generalized GelfondLifschitz trans formation The resulting semantics proved coincide notion answer sets discuss work answer sets deﬁned Son et al 42 This provides reinforcement validity semantics discuss paper The work Shen You 38 nicely complements computationbased approach offering modeltheoretic characterization answer sets 8 Conclusions In paper conducted indepth investigation semantics logic programs general abstract constraints Programs constraints important Arbitrary abstract constraints subsume types constraints aggre gates arise practice Moreover use arbitrary constraints allows eliminate explicit use negation failure compromising expressive power Our effort extends complements earlier proposals generalizing wellestablished notions answer sets normal logic programs programs monotone convex abstract constraints The backbone proposal notion computation viewed regulated sequence interpretations Compu tations speciﬁed terms basic principles revision convergence persistence beliefs persistence reasons founded persistence reasons These principles derived analysis properties answer sets normal logic programs Building connection proposed answer sets programs arbitrary constraints results computations founded satisfy properties listed The problem assigning answerset semantics programs arbitrary constraints received attention lately In paper compared proposal alternative ones Clearly question proposed generalizations answerset semantics case normal programs case programs arbitrary constraints correct given deﬁnitive answer Indeed concept correctness formal deﬁnition However identify desirable properties answer sets satisfy evaluate proposed semantics based behave relative properties In respect note concept answer set strong constructive ﬂavor It rooted notion computation turn based fundamental principles computations obey Next coincides earlier proposal Son et al 42 expected semantics answer sets programs arbitrary constraints generalizes answer sets normal logic programs programs convex constraints Furthermore answer sets deﬁned equivalent characterizations They deﬁnition provided Section 5 deﬁnition given Son et al 42 closely related characterization terms subsatisﬁability relations Section 6 characterization terms transformation programs arbitrary constraints programs convex ones All characterizations point multitude intuitions underlie semantics proposed Lastly answer sets free selfsupportedness feature lacking proposals semantics programs arbitrary constraints notably proposal developed Faber et al 14 We conclude noting challenging open problem Namely far unable extend computation based approach capture special case semantics answer sets disjunctive logic programs Answer sets disjunctive programs minimal models Therefore class computations guaranteed produce minimal models However ﬁnding concept computation easy In particular obvious attempt require computations increase minimally step computation address problem 37 For instance let consider program consisting rules b b Every reasonable class computations look ahead result decides expand based computed far contain computation b b But result computation minimal model In time way determine computing ﬁrst step incorrect based current case initial state computation It possible order capture minimality necessary impose global minimality requirement opposed local deﬁnition increment step step This diﬃculty heart problem expressing semantics Faber et al 14 terms computations noted earlier Acknowledgements The authors wish thank anonymous reviewers insightful comments This research partially supported NSF grants 0812267 0420407 References 1 K Apt Logic programming J van Leeuven Ed Handbook Theoretical Computer Science Elsevier Amsterdam 1990 pp 493574 2 M Balduccini M Gelfond M Nogueira Answer set based design knowledge systems Annals Mathematics Artiﬁcial Intelligence 47 12 2006 183219 314 L Liu et al Artiﬁcial Intelligence 174 2010 295315 3 C Baral Knowledge Representation Reasoning Declarative Problem Solving Cambridge University Press 2003 4 C Baral From knowledge intelligencebuilding blocks applications Invited talk AAAI 2005 wwwpublicasueducbaralaaai05invitedtalkppt 5 E Dantsin T Eiter G Gottlob A Voronkov Complexity expressive power logic programming ACM Computing Surveys 33 3 2001 374425 6 T DellArmi W Faber G Ielpa N Leone G Pfeifer Aggregate functions disjunctive logic programming Semantics complexity implementation DLV Proceedings 18th International Joint Conference Artiﬁcial Intelligence IJCAI 2003 2003 pp 847852 7 M Denecker V Marek M Truszczy nski Ultimate semantic treatment default autoepistemic logics Proceedings KR Principles Knowl edge Representation Reasoning 2000 pp 7484 8 M Denecker N Pelov M Bruynooghe Ultimate wellfounded stable semantics logic programs aggregates P Codognet Ed Logic Programming Proceedings 17th International Conference ICLP 2001 Paphos Cyprus November 26December 1 2001 Lecture Notes Computer Science vol 2237 Springer 2001 pp 212226 9 T Eiter W Faber N Leone G Pfeifer A Polleres A logic programming approach knowledge state planning II The DLV Artiﬁcial Intelli K gence 144 12 2003 157211 10 T Eiter W Faber N Leone G Pfeifer A Polleres Answer set planning action costs Journal Artiﬁcial Intelligence Research 19 2003 2571 11 I Elkabani E Pontelli TC Son Smodels CLP applications A simple effective approach aggregates ASP B Demoen V Lifschitz Eds Logic Programming Proceedings 20th International Conference ICLP 2004 SaintMalo France September 610 2004 Lecture Notes Computer Science vol 3132 Springer 2004 pp 7389 12 E Erdem V Lifschitz Tight logic programs Theory Practice Logic Programming 3 45 2003 499518 13 E Erdem V Lifschitz D Ringe Temporal phylogenetic networks logic programming Theory Practice Logic Programming 6 5 2006 539558 14 W Faber N Leone G Pfeifer Recursive aggregates disjunctive logic programs Semantics complexity JJ Alferes JA Leite Eds Logics Artiﬁcial Intelligence Proceedings 9th European Conference JELIA 2004 Lisbon Portugal September 2730 2004 Lecture Notes Computer Science vol 3229 Springer 2004 pp 200212 15 P Ferraris Answer sets propositional theories C Baral G Greco N Leone G Terracina Eds Logic Programming Nonmonotonic Reasoning Proceedings 8th International Conference LPNMR 2005 Diamante Italy September 58 2005 Lecture Notes Computer Science vol 3662 Springer 2005 pp 119131 16 M Gebser B Kaufmann T Schaub clasp A conﬂict driven answer set solver C Baral G Brewka J Schlipf Eds Logic Programming Non monotonic Reasoning Proceedings 9th International Conference LPNMR 2007 Tempe USA May 1517 2007 Lecture Notes Computer Science vol 4483 Springer 2007 pp 260265 17 M Gelfond Representing knowledge AProlog A Kakas F Sadri Eds Computational Logic Logic Programming Beyond SpringerVerlag 2002 pp 413451 18 M Gelfond N Leone Logic programming knowledge representationthe AProlog perspective Artiﬁcial Intelligence 138 12 2002 338 19 M Gelfond V Lifschitz The stable model semantics logic programming R Kowalski K Bowen Eds Logic Programming Proceedings Fifth International Conference Symposium The MIT Press 1988 pp 10701080 20 M Gelfond V Lifschitz Logic programs classical negation D Warren P Szeredi Eds Logic Programming Proceedings Seventh International Conference The MIT Press 1990 pp 579597 21 K Heljanko I Niemelä Bounded LTL model checking stable models Theory Practice Logic Programming 3 45 2003 519550 22 N Leone G Pfeifer W Faber T Eiter G Gottlob S Perri F Scarcello The DLV knowledge representation reasoning ACM Transactions Computational Logic 7 3 2006 499562 23 Y Lierler M Maratea Cmodels2 SATbased answer set solver enhanced nontight programs V Lifschitz I Niemelä Eds Proceedings 7th International Conference Logic Programming Nonmonotonic Reasoning Conference LPNMR04 LNCS vol 2923 SpringerVerlag 2004 pp 346350 24 L Liu E Pontelli TC Son M Truszczy nski Logic programs abstract constraint atoms The role computations V Dahl I Niemelä Eds Proceedings 23rd International Conference Logic Programming ICLP 2007 Porto Portugal September 813 Lecture Notes Computer Science vol 4670 Springer 2007 pp 286301 25 L Liu M Truszczy nski Properties programs monotone convex constraints MM Veloso S Kambhampati Eds Proceedings The Twentieth National Conference Artiﬁcial Intelligence Seventeenth Innovative Applications Artiﬁcial Intelligence Conference July 913 2005 AAAI PressThe MIT Press Pittsburgh Pennsylvania USA 2005 pp 701706 26 J Lloyd Foundations Logic Programming 2nd edition SpringerVerlag 1987 27 VW Marek A Nerode JB Remmel Logic programs wellorderings forward chaining Ann Pure Appl Logic 96 13 1999 231276 28 VW Marek I Niemelä M Truszczy nski Logic programs monotone abstract constraint atoms Theory Practice Logic Programming 8 2 2008 167199 29 VW Marek JB Remmel Set constraints logic programming Logic Programming Nonmonotonic Reasoning Proceedings 7th Interna tional Conference LPNMR 2004 Fort Lauderdale FL USA January 68 2004 Lecture Notes Computer Science vol 2923 SpringerVerlag 2004 pp 167179 30 VW Marek M Truszczy nski Stable models alternative logic programming paradigm The Logic Programming Paradigm A 25year Perspec tive SpringerVerlag 1999 pp 375398 31 VW Marek M Truszczy nski Logic programs abstract constraint atoms Proceedings Nineteenth National Conference Artiﬁcial Intelligence Sixteenth Conference Innovative Applications Artiﬁcial Intelligence July 2529 2004 San Jose California USA AAAI PressThe MIT Press 2004 pp 8691 32 W Marek M Truszczy nski NonMonotonic Logic Context Dependent Reasoning SpringerVerlag 1993 33 I Niemelä Logic programming stable model semantics constraint programming paradigm Annals Mathematics Artiﬁcial Intelli gence 25 34 1999 241273 34 I Niemelä P Simons Smodelsan implementation stable model wellfounded semantics normal logic programs Logic Programming Nonmonotonic Reasoning 7th International Conference LPNMR 1997 SpringerVerlag 1997 pp 420429 35 N Pelov Semantic logic programs aggregates PhD thesis Katholieke Universiteit Leuven 2004 wwwcskuleuvenacbepublicatiesdoctoraten cwCW2004_02abshtml 36 N Pelov M Denecker M Bruynooghe Partial stable models logic programs aggregates Logic Programming Nonmonotonic Reasoning 7th International Conference LPNMR 2004 SpringerVerlag 2004 pp 207219 37 N Pelov M Truszczy nski Semantics disjunctive programs monotone aggregatesan operatorbased approach JP Delgrande T Schaub Eds Proceedings 10th International Workshop NonMonotonic Reasoning NMR04 2004 pp 327334 38 YD Shen JH You A generalized GelfondLifschitz transformation logic programs abstract constraints AAAI AAAI Press 2007 pp 483 488 39 P Simons N Niemelä T Soininen Extending implementing stable model semantics Artiﬁcial Intelligence 138 12 2002 181234 40 TC Son E Pontelli A constructive semantic characterization aggregates answerset programming Theory Practice Logic Programming 7 3 2007 355375 L Liu et al Artiﬁcial Intelligence 174 2010 295315 315 41 TC Son E Pontelli I Elkabani An unfoldingbased semantics logic programming aggregates Computing research repository csSE0605038 2006 42 TC Son E Pontelli PH Tu Answer sets logic programs arbitrary abstract constraint atoms Journal Artiﬁcial Intelligence Research 29 2007 353389 43 M van Emden R Kowalski The semantics predicate logic programming language Journal ACM 23 4 1976 733742 44 A Van Gelder K Ross J Schlipf The wellfounded semantics general logic programs Journal ACM 38 3 1991 620650 45 JH You LY Yuan G Liu YD Shen Logic programs abstract constraints Representation disjunction complexities C Baral G Brewka JS Schlipf Eds Logic Programming Nonmonotonic Reasoning Proceedings 9th International Conference LPNMR 2007 Tempe AZ USA May 1517 2007 Lecture Notes Computer Science vol 4483 Springer 2007 pp 228240