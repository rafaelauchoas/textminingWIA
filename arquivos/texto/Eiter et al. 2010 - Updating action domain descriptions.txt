Artiﬁcial Intelligence 174 2010 11721221 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Updating action domain descriptions Thomas Eiter Esra Erdem b Michael Fink Ján Senko Institute Information Systems Vienna University Technology Vienna Austria b Faculty Engineering Natural Sciences Sabancı University Istanbul Turkey r t c l e n f o b s t r c t Article history Received 28 November 2008 Received revised form 4 June 2010 Accepted 27 June 2010 Available online 17 July 2010 Keywords Knowledge representation Reasoning actions change Theory change Action languages Preferencebased semantics Incorporating new information knowledge base important problem widely investigated In paper study problem formal framework reasoning actions change In framework action domains described action language semantics based notion causality Unlike formalisms considered related work language allows straightforward representation nondeterministic effects indirect effects possibly concurrent actions state constraints updates general elementary statements The expressivity formalism allows study update action domain description general approach compared related work First consider update action description respect criteria instance ensuring updated description entails observations assertions general domain properties constitute constraints expressible action description general Moreover framework allows discriminate alternative updates action domain descriptions single preferable based given preference relation possibly dependent speciﬁed criteria We study semantic computational aspects update problem establish basic properties updates decomposition theorem gives rise divide conquer approach updating action descriptions certain conditions Furthermore study computational complexity decision problems computing solutions generic setting particular preference relations viz setinclusion weightbased preference While deciding existence solutions recognizing solutions PSPACEcomplete problems general problems fall polynomial hierarchy restrictions additional constraints We ﬁnally discuss methods compute solutions approximate solutions disregard preference Our results provide semantic computational basis developing systems incorporate new information action domain descriptions action language presence additional constraints 2010 Elsevier BV Open access CC BYNCND license 1 Introduction As live world knowledge information ﬂux updating knowledge bases important issue widely studied area knowledge representation reasoning 67122061 references This paper revised signiﬁcantly extended version preliminary paper appeared Proc 19th International Joint Conference Artiﬁcial Intelligence IJCAI 2005 pp 418423 Corresponding author Email addresses eiterkrtuwienacat T Eiter esraerdemsabanciunivedu E Erdem michaelkrtuwienacat M Fink jankrtuwienacat J Senko 00043702 2010 Elsevier BV doi101016jartint201007004 Open access CC BYNCND license T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1173 However problem far trivial different methods proposed incorporate new information aﬃrmative prohibitive based different formal philosophical underpinnings cf 67 3957 It appears general purpose method work settings partly fact update method dependent extent application domain In particular reasoning actions change dynamicity world domain theory requires special attention update methods For approaches formal action theories including prominent situation calculus event calculus action languages emerged research nonmonotonic reasoning problem change widely studied different methods proposed 64 background refer ences Section 81 detailed discussion To simple example consider agent having following knowledge K TV TV remote control TV1 If power pushing power button TV turns power TV2 If power pushing power button TV turns power TV3 The TV power on1 TV4 The TV power Now assume agent know remote control works know effect pushing power button remote control Suppose later obtains following information K RC remote controls RC1 If power TV pushing power button remote control turns TV RC2 If TV pushing power button remote control turns TV The task incorporate new knowledge current knowledge base K TV In particular case unproblematic simply adding K RC KTV resulting stock knowledge consistent general inconsistent major issue overcome inconsistency We study incorporation problem context action languages 30 In formalisms actions change described causal laws For instance action language C 32 direct effect action pushing power button TV stated TV1 described causal law caused PowerON PushPBTV PowerON 1 expresses action represented PushPBTV causes value ﬂuent PowerON change false true indirect effect action stated TV3 described causal law caused TvON PowerON 2 expresses ﬂuent PowerON caused true ﬂuent TvON caused true Action description languages expressive easily handle nondeterminism concurrency ramiﬁcations qualiﬁca tions The meaning action description represented transition diagrama directed graph nodes correspond states edges correspond action occurrences Fig 1 Section 2 shows example There reasoning systems like CCalc2 DLVK 3 accept domain descriptions action language like C K respec tively support kinds reasoning tasks descriptions including planning prediction postdiction CCcalc computing different kinds plans DLVK As far action languages concerned update problem studied remarkably little extent For basic action language A 30 far expressive C update problem considered 44 47 Both works focused updates consist elementary statements essentially facts time presented speciﬁc update methods focusing contents knowledge base We address update problem general perspective following ways We consider richer language fragment C study update problem updates represented terms set arbitrary causal laws We view update problem general perspective Sometimes ensuring consistency suﬃcient want ensure updated action description entails scenarios conditions general properties domain expressed causal laws In update framework knowledge taken account For example effective use TV scenario following constraint imposed C Pushing power button remote control possible4 1 Note statement wrong defectiveness observed resolved update 2 httpwwwcsutexaseduuserstagcc 3 httpwwwdbaituwienacatprojdlvK 4 Note conceptual difference C TV2 C expresses executability condition TV2 captures causal relationship 1174 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 If KRC simply added KTV C satisﬁed KRC KTV power TV pushing power button remote control possible RC2 TV3 contradict The question agent update KTV incorporating KRC relative C note C expressible causal laws action language C To represent constraints like C use formulas queries action languages like 30 formula ALWAYS executable PushPBRC 3 evaluate true PushPBRC stands concrete action pushing power button remote control Similarly consider following scenario want updated action description entail S Sometimes power pushing power button TV turns power push power button TV power This scenario expressed means causal laws expressed formula SOMETIMES evolves PowerON PushPBTV PowerON PushPBTV PowerON Sometimes action description updated ways Our framework allows discriminate alternatives single preferable candidate result based given preference relation possibly dependent additional constraint formulas In paper consider generic framework incorporating new causal laws existing action description takes account constraint formulas satisﬁed end We stance causal laws designed user knowledge engineer modiﬁed constraint formulas subject change capture indisputable properties domain violation constraints tolerated indicated user Our main contributions summarized follows 1 We introduce formal notion action update problem given action descriptions D I set C incorporates I D While D I constraint formulas determine possibly new action description D canonical subset C conditions like C scenarios like S constraints formulas action query language similar 30 In ﬁnegrained treatment D split unmodiﬁable D u modiﬁable Dm C split obligatory constraints Co hold circumstances preference constraints C p ideally hold violated cid5 A solution action update problem deﬁned terms action description D cid5 consists I statements D Co satisﬁed D possible use strict preference relation cid2C action descriptions5 order discriminate alternatives single result Here subscript C indicates preference relation possibly dependent preferable candidate D set C constraints Such preference relation deﬁned different ways terms syntactic conditions set causal laws action description semantic conditions presence absence paths transition diagram general different candidates D cid5 cid5 cid5 2 We investigate semantic properties action updates establish basic properties solution pref erence special forms updates serve tests suitability notions proposed We furthermore determine conditions computing solution action update problem structurally decomposed divideandconquer approach feasible In particular possible action description straints split disjoint parts interfere benign way preference ordering gracefully decomposed split cid5 cid5 holds given D D 3 We study computational complexity action update problem consider generic setting making assumptions cost deciding constraints C satisﬁed action description D denoted D cid6 C D cid2C D natural instances Among preference relation cid2C ordinary setinclusion weightbased relative satisﬁed constraints Under assumption testing D cid6 C D cid2C D feasible polynomial space deciding existence solution action update problem turns PSPACEcomplete general verifying given solution candidate complexity However complexity problems falls polynomial hierarchy deciding D cid6 C D cid2C D located located level higher recall deciding consistency action description C intractable general NPcomplete canonical fragment concern Given test D cid6 C D cid2C D polynomial deciding solution existence NPcomplete harder consistency problem recognizing given solution mildly harder cid5 cid5 cid5 4 We discuss methods computing solutions presolutions approximate disregarding solution preference As solutions focus setinclusion particular weightbased comparison preference relations 5 That cid2C irreﬂexive transitive T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1175 cid2C use oracle presolutions For presolutions present method reduces problem reasoning action description constructed problem input evaluating constraint formulas exploited test given candidates 5 Finally applicability algorithm based computation presolutions usefulness theoretical results decomposability update problem context Zoo World action domain proposed Erik Sandewall Logic Modelling Workshop6 The Zoo World consists cages exterior gates animals species including humans actions include moving cages opening closing gates mounting riding animals description domain action language C given 1 Our results signiﬁcantly previous results literature Section 81 provide semantic com putational basis developing systems incorporate new information action descriptions action language presence constraints expressed formulas entailed updated description Our generic framework instantiated different settings reﬂect different intuitions criteria solution prefer ence It provides ﬂexible tool modeling action update As byproduct obtain decomposition results action descriptions emerge special cases action update instances interesting right The rest paper structured follows In section provide preliminaries transition diagrams action languages constraint formulas needed problem setting After deﬁne Section 3 update problem generic framework brieﬂy introduce syntactic semantic instance In Section 4 study semantic properties updates including possible decompositions After turn computational issues In Section 5 characterize computational complexity problems updates Section 6 provide algorithms computing updates Example applications Zoo World considered Section 7 After discussion related work aspects problem Section 8 conclude summary issues research 2 Preliminaries We action domains updates action description language fragment C 32 causal laws Therefore following ﬁrst syntax semantics action description language deﬁned means transition systems While updating action domain description like ensure updated description entails conditions scenarios Most time scenarios conditions expressible action language We constraints formulas action query language like 30 Therefore action query language use deﬁne satisfaction constraint action domain description Finally sample constraints useful action updates represented action description language We discuss emphasize necessity query language addition description language 21 Transition diagrams We start propositional action signature consists set F ﬂuent names set A action names A literal expression form P P P ﬂuent An action truthvalued function A denoted set action names mapped t Thus action names represent basic atomic actions compound action identiﬁed basic actions taking place time providing intuitive representation atomic concurrent actions Deﬁnition 1 See 30 A propositional transition diagram action signature L cid7F Acid8 consists set S states cid5 function V F S f t subset R S 2A S transitions We V P s value P s The states s cid5cid8 R possible results execution action A state s We A executable s cid7s A s state s exists A deterministic s s cid5 cid5 A transition diagram thought labeled directed graph Every state s represented vertex labeled cid5cid8 R represented edge leading function P cid12 V P s ﬂuent names truth values Every triple cid7s A s s s labeled A An example transition diagram shown Fig 1 cid5 22 Action description languages We consider prime subset action description language C 32 consists kinds expressions called causal laws static laws form caused L G 6 httpwwwidaliuseextetailmw 4 1176 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Fig 1 A transition diagram Fig 2 An action description KTV L literal G propositional combination ﬂuent names dynamic laws form caused L G H 5 L G H propositional combination ﬂuent names action names In 4 5 G dropped G True An action description set causal laws For instance knowledge base TV D agent previous section described causal laws Fig 2 An expression form inertial L1 Lk stands causal laws caused Li Li Li 1 cid2 cid2 k 6 describing value ﬂuent Li stays changed action The meaning action description represented transition diagram Let D action description signature L cid7F Acid8 Then transition diagram cid7S V Rcid8 described D denoted T D deﬁned follows S set interpretations s F static law 4 D s satisﬁes G L ii V P s sP iii R set triples cid7s A s cid5cid8 s unique interpretation F satisﬁes heads L cid5 static laws 4 D s dynamic laws 5 D s cid5 cid5 satisﬁes G satisﬁes G s A satisﬁes H cid5 The laws included iii applicable transition s s causal laws sure s causal laws handle preconditions direct effects A caused executing A static state handles ramiﬁcations qualiﬁcations A dynamic Action language C based principle universal causation according fact obtains caused In deﬁnition condition s interpretation satisfying heads applicable causal laws ensures For instance transition diagram described action description K TV Fig 2 presented Fig 1 Consider transition cid7PowerON TvON PushPBTV PowerON TvONcid8 The causal laws applicable transition cid5 cid5 caused PowerON PushPBTV PowerON caused TvON PowerON Here PowerON TvON interpretation satisﬁes heads causal laws PowerON TvON Now consider triple cid7PowerON TvON PowerON TvONcid8 There causal laws applicable triple viz second There interpretations satisfy head causal law PowerON TvON PowerON TvON In words causal law provides causal explanation PowerON Therefore triple transition T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1177 We action description consistent represented transition diagram nonempty state set In following suppose action description D consists parts D u unmodiﬁable causal laws Dm modiﬁable causal laws Therefore denote action description D D u Dm 23 Why action languages In work consider action languages formalize action domains There reasons decision First action description languages like C expressive easily handle nondeterminism concurrency ramiﬁcations defaults qualiﬁcations state constraints For instance express tossing coin lead Heads Tails causal laws caused Heads Heads Toss caused Heads Heads Toss Concurrency allowed qualiﬁcation constraint violated explicitly stated causal law like caused False MoveRight MoveLeft The commonsense law inertia immediately expressed causal laws form 6 A direct effect turning power power ramiﬁcation turning power TV We express ramiﬁcation causal law caused TvON PowerON We springloaded door default closed causal laws caused Open Open Second reasoning systems like CCalc DLVK K respectively allow kinds reasoning tasks descriptions accept domain descriptions action language like C Third large theoretical applicationoriented work action languages including earlier work planning monitoring On hand discussed brieﬂy introduction update problem studied remarkably little extent context action languages This paper extends earlier work updates account fulﬁlls need general approach updates action languages 24 Expressive constraints Once action domain want check domain description entails observations world assertions effects execution actions scenarios Similarly 18 express conditions constraints formulas action query language like 30 After check given action description satisﬁes given constraint reasoning systems CCalc cf examples Appendix C Now constraint formulas formally deﬁned follows7 An open constraint static constraint form holds F F ﬂuent formula b dynamic constraint form necessarily Q A1 An 7 8 Q open constraint Ai action8 c propositional combination open constraints An existential constraint expression form SOMETIMES Q Q open constraint universal constraint form ALWAYS Q 9 10 Q open constraint A constraint q propositional combination existential constraints universal straints 7 In action query languages constraints called queries term appealing satisfaction required 8 This amounts Q A1 An dynamic logic 37 stick commonly syntax action queries 1178 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 For open constraint q maximal nesting depth dynamic constraints k deﬁned inductively follows If q static constraint k 0 q dynamic constraint form 8 k k Q 1 k Q maximal nesting depth dynamic constraints Q q Boolean combination open constraints k maximal element set maximal nesting depths dynamic constraints subformulas This deﬁnition easily extended general constraints For existential universal constraint form 9 resp form 10 maximal nesting depth dynamic constraints k Q maximal nesting depth dynamic constraints Q For propositional combination existential universal constraints maximal nesting depth dynamic constraints maximal element set maximal nesting depths dynamic constraints subformulas As semantics let T cid7S V Rcid8 transition diagram set S states value function V mapping state s ﬂuent P truth value set R transitions A history T length n sequence s0 A1 s1 sn1 An sn 11 cid7si Ai1 si1cid8 0 cid2 n R We state s S satisﬁes open constraint Q form 7 resp 8 relative T denoted T s cid6 Q interpretation P cid12 V P s satisﬁes F resp history h s0 A1 s1 sn1 An sn T length n s s0 open constraint Q satisﬁed state sn For forms open constraints Q satisfaction deﬁned truth tables propositional logic If T described action description D satisfaction relation s open constraint Q denoted D s cid6 Q cid5 cid5 Note state s ﬂuent formula F D s cid6 holds F D s cid6 holds F For state s ﬂuent formula F action sequence A1 An n cid3 1 D s cid6 necessarily holds F A1 An D s cid6 necessarily holds F A1 An We D satisﬁes constraint q denoted D cid6 q following holds q existential constraint 9 D s cid6 Q state s S q universal constraint 10 D s cid6 Q state s S cid5 q q q q1 q2 D cid6 q1 D cid6 q2 q q1 q2 D cid6 q1 D cid6 q2 D cid16cid6 q cid5 For open constraint Q D cid6 SOMETIMES Q iff D cid6 ALWAYS Q For set C constraints D satisﬁes C denoted Dcid6C D satisﬁes constraint C Consider action description presented Fig 2 It satisfy set constraints containing ALWAYS necessarily holds TvON PushPBRC constraint satisﬁed state TvON PowerON satisﬁes constraints ALWAYS holds PowerON TvON ALWAYS holds PowerON TvON necessarily holds TvON PushPBTV 12 13 In rest paper expression form possibly Q A1 An Q open constraint Ai action stands dynamic constraint necessarily Q A1 An expression form evolves F 0 A1 F 1 Fn1 An Fn F ﬂuent formula Ai action stands cid2 holds F 0 possibly holds F 1 possibly holds F 2 A2 cid3 A1 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1179 executable A1 An Ai action stands possibly True A1 An We drop holds static constraints appearing dynamic constraints 241 Examples To better intuition capability constraints examples properties expressed Existence certain states transitions histories For instance express existence states formula F holds means constraint SOMETIMES holds F Similarly express existence transition state formula F holds state formula F holds execution action A cid5 SOMETIMES holds F possibly F cid5 A In general existence history 11 si history interpretation P cid12 V P si satisﬁes formula F expressed constraint SOMETIMES evolves F 0 A1 F 1 Fn1 An Fn For instance constraint SOMETIMES evolves PowerON PushPBTV PowerON PushPBTV PowerON describes presence following history Fig 1 PowerON TvON PowerON TvON PushPBTV PushPBTV PowerON TvON Nonexecutability action Like 16 executability action sequence A1 An n cid3 1 state described ALWAYS executable A1 An That action possible state formula F holds expressed SOMETIMES holds F cid4 necessarily False A A2A Mandatory possible effects actions Like 16 mandatory effects sequence A1 An n cid3 1 actions given context described ALWAYS holds G necessarily F A1 An possible effects sequence actions context ALWAYS holds G possibly F A1 An In constraints F describes effects G context 242 Constraints vs causal laws In action languages 30 queries expressed language different action description languages As consider constraints queries evaluate true look suggestive merge causal laws constraints single set formulas constitute action description However constraints causal laws conceptually different causal laws axioms action domains generative manner particular action language C causation constraints express conditions refer time steps like ensure action domain serve eliminating unwanted models In words constraints restrict possibilities action description nonconstructive sense causally generate transitions The cid5cid8 transition diagram causally heart C action languages edge cid7s A s 1180 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 explained generated meaning follow state s laws ﬁre causal laws applicable cid7s A s uniquely described literals heads causal cid5cid8 cid5 For instance action description consists causal law caused G A1 F ﬂuent inertial transition diagram edge cid7F G A1 F Gcid8 cid5 F G occurrence action A1 However transition diagram state s F G state s edge cid7 A1 F Gcid8 If instead causal law consider constraint ALWAYS holds F necessarily G A1 similar causal law cid7F G A1 F Gcid8 cid7 A1 F Gcid8 included transition diagram F false wrt s implication true Although cases constraint expressed equivalent causal law multiple laws case Moreover meaning set causal laws described set nodes set edges form transition edges expresses causal relationship generates edge roughly speaking meaning constraint described set paths transition diagram causal relation In words constraints conditions characterizing subgraphs transition diagram Consequently constraints expressed causal laws instance existential constraints like constraint SOMETIMES possibly F A constraint 21 similar constraints Section 241 They expressed causal laws inherently universal statements Also universal constraints like ALWAYS possibly F A possibly F A implicitly enforce existence causal transitions diﬃcult express causal laws Another aspect constraints allow talk sequences actions causal laws Due syntactic semantic differences causal laws queries reasoning systems like CCalc based action languages different syntax query formulas cf Appendix C difference practice For instance reasoning systems queries reasoning tasks like temporal projection planning given action domain Although formalisms like situation calculus 60 dynamic logic 37 answer set program ming 48 axioms constraints distinction formalisms express axioms constraints unusual areas Consider instance description circuit propo sitional logic conditions want check circuit expressed temporal logic 25 Also consider ontologies described ontology description languages like RDF constraints described ontology query languages like SPARQL The differences causal laws query formulas affect computational eﬃciency reasoning systems For instance given domain description query CCalc checks query entailed domain description follows 1 transforms causal laws propositional theory ΓD 2 transforms negated query propositional theory ΓP 3 checks ΓD ΓP satisﬁable 4 ΓD ΓP unsatisﬁable returns Yes 5 returns No presents counter example extracted satisfying interpretation ΓD ΓP The transformations ﬁrst steps different 1 based literal completion 2 based simpler procedure 31 detailed description Such difference allows check entailment queries executing ﬁrst step If described constraint means causal laws general transform union causal laws constraint propositional theory large domain descriptions like Zoo World bulk transformation lead ineﬃcient computations 3 Problem description In section provide formal description update problem solution weaker form solution called presolution The basic problem theory change problem problem incorporating new information existing stock knowledge cf Sections 42 82 detailed discussions relations wellknown work area Since study incorporation problem context action language consider single causal laws atomic entities subject change discussion reﬁne Section 83 In addition causal laws incorporation new information contain constraints characterize intended properties T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1181 change reasons distinction causal laws constraints discussed previous section Concerning solutions problem aim keeping size search space practically reasonable building natural analogies change operators developed areas database AI research cf 676157 references Informally deﬁne Action Description Update ADU problem action description D D u Dm set I causal laws partial action description set C Co C p constraints preference relation cid2C action descriptions Here D u Dm unmodiﬁable protected modiﬁable D respectively I update incorporated The constraints Co hard obligatory constraints satisﬁed acceptable action description constraints C p soft preference constraints accounted preference relation cid2C In D cid2C D expresses D preferable compared D cid5 cid5 Deﬁnition 2 Action description update Given action description D D u Dm set I causal laws partial action description set C Co C p constraints preference relation cid2C action descriptions signature L action description D accomplishes action description update D I relative C cid5 consistent cid5 D ii D u I D cid5 cid6 Co iii D iv consistent action description D cid5 D I cid5cid5 D u I D cid5cid5 D I D cid5cid5 cid6 Co D cid5 cid2C D cid5cid5 9 cid5 called solution ADU problem D I C cid2C If action description D Such D presolution ADU problem D I C cid2C cid5 satisﬁes iiii D cid5 Condition expresses action description update modeling dynamic domain TV Sec tion 1 state According Condition ii new knowledge world invariable existing action description kept causal laws variable considered correct wrong case simply disposed Condition iii imposes semantical constraints Co D comprise knowledge action domain gained experience It important note C modiﬁed later action description update discussed cid5 Finally Condition iv picks preferred action description ones Conditions iiii satisﬁed In ADU problem preference relation described ways For instance deﬁned terms syntactic conditions like simple set inclusion If deﬁne cid2C action description D preferable Alternatively preference relation cid2C deﬁned terms semantic action description D conditions For instance weight assigned action description respect semantic measure number certain paths present transition diagram description function weight cid2C operator weight comparing weights action descriptions action description D preferable action description D D D cid5 cid5 cid5 cid5 D weight D In literature kinds changes incorporate new information knowledge base identiﬁed viz revision adds precise knowledge domain update change world se 66 governed different sets postulates axiomatic approaches like AGM theory 2 KM theory 39 Our notion ADU revision ﬂavor govern AGM KM postulates formalism satisfy prerequisites Section 82 discussion However constraints C adjusted nature change I known In case revision C reasonably contain conditions corresponding observations domain conditions kept dropped hand I change world se conditions corresponding observations dropped Eventually remark descriptive domains like physical domains carry tests collect respective results observations order ﬁnd erroneous causal laws In case update problem viewed diagnosis problem Note approach hinges possibility observations learning causal relationships In contrast approach intended allow normative artiﬁcial worlds modeled action descriptions agent systems games protocols world designed perceived In domains likewise physical worlds observable impeded observations reason feasible treat update problem diagnosis problem 9 Note soft constraints C p implicitly deﬁnition preference relation cid2C C Co C p explicitly known parameter 1182 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Fig 3 Causal laws KRC Fig 4 Transition diagram described D I Example 1 31 Examples The following example ADU problem syntaxbased preference relation Example 1 Let D action description KTV Fig 2 D D u Dm D u caused PowerON PushPBTV PowerON caused PowerON PushPBTV PowerON inertial PowerON PowerON TvON TvON Dm caused TvON PowerON caused TvON PowerON let I set causal laws K RC Fig 3 caused TvON PushPBRC PowerOn TvON caused TvON PushPBRC TvON Furthermore let C Co contain constraints 3 13 ALWAYS executable PushPBRC ALWAYS holds PowerON TvON necessarily holds TvON PushPBTV constraint ALWAYS executable PushPBTV 14 strict setinclusion preference relation cid2C The transition diagram described D I shown Fig 4 Here state PowerON TvON mapped t action PushPBRC executable Therefore D I solution ADU problem D I C cid2C In fact solution obtained dropping static law 2 caused TvON PowerON D I For instance semantic deﬁnition cid2C consider following setting based weights assigned constraints C weighted constraints 18 We deﬁne weight action description D relative set C constraints weight function f C R mapping constraint C real number weightqD cid5 cCDcid6c f c Intuitively weight action description deﬁned relative weights constraints encodes extent set C given preferable constraints satisﬁed Note f easily express threshold function With deﬁnition highly preferred constraints satisﬁed preferred action description T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1183 Example 2 Reconsider previous example C p consists constraint 13 weight 1 ALWAYS holds PowerON TvON necessarily holds TvON PushPBTV Suppose preference relation cid2C deﬁned terms weight function constraints cid2C weightq action descriptions D cid5cid5 However D Then cid5cid5 D u I satisfy Co presolutions cid5 D I caused TvON PowerON D satisfy C p implies weightqD cid5cid5 0 weightqD cid5 1 D cid5cid5 cid2C D cid5 For details comparing action descriptions means weighted constraints semantic preferences refer reader 18 In rest paper study ADU problems abstract level leaving preference relation undeﬁned For problems provide concrete results instantiating preference relation cid2C C p C Co instance syntaxbased relation consider cid2C weightq representative semanticbased approaches 4 Properties updates In section study basic properties solutions ADU problem To end ﬁrst introduce subsumption relation action descriptions solutions ADU problem fulﬁll desired properties special updates provided preference relation cid21C obeys natural conditions We sider structure solutions presolutions establish disjoint factorization result allows decomposing ADU smaller parts 41 Basic update properties We deﬁne subsumption causal laws action description follows Deﬁnition 3 Subsumption Let D action description signature L cid7F Acid8 Then static law 4 L subsumed D state s T D interpretation F describing s satisﬁes G L cid5cid8 T D following holds inter dynamic law 5 L subsumed D transition cid7s A s satisﬁes G L pretation F A describing s A satisﬁes H interpretation F describing s cid5 A set S causal laws subsumed action description D law S subsumed D Furthermore build properties preference relation cid2C introduced In following action description D set C constraints let denote C D set c C D cid6 c Deﬁnition 4 Given set constraints C signature L cid7F Acid8 preference relation cid2C L called monotone respect C action descriptions D D monotone respect C additionally C Dcid5 C D implies D monotone respect L action descriptions D D cid5 cid2C D monotone respect L additionally D cid5 D implies D cid5 cid2C D cid5 L C Dcid5 C D implies D cid16cid2C D cid5 strongly cid5 L D cid5 D implies D cid16cid2C D cid5 strongly nonminimizing respect L action description D L D cid6 C implies D cid16cid2C D cid5 D cid5 D strongly nonminimizing respect L additionally D cid6 C implies D cid5 cid2C D D cid5 D We cid2C monotone monotone respect C monotone respect L Monotonicity intuitive potential requirement preference relation monotonicity respect C encodes semantically motivated preference satisfying preferable constraints possible mono tonicity respect L expresses syntactic view retaining causal laws possible This reﬂected representative preference relations Notice strongly monotone respect L necessarily spect C weightq monotone respect C instance weights nonnegative necessarily respect L Obviously monotone preference relation nonminimizing respect L strong monotonicity respect L implies cid2C strongly nonminimizing respect L Intuitively nonminimizing preference relation respect L ensures syntactically smaller respect subset inclusion action descriptions prevent action description satisﬁes constraints solution respective strong property explic itly excludes syntactically smaller action descriptions solutions case note additional condition implies 1184 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 condition nonminimizing serve deﬁnition This intuition motivates basic properties solutions ADU problem follows Proposition 1 Subsumption Let D I C cid2C ADU problem cid2C nonminimizing respect L D consistent D cid6 C If D subsumes I D I solution D I C cid2C Moreover cid2C strongly nonminimizing respect L D I unique solution cid5 cid6 Co implies D I cid16cid2C D cid5 R cid5 V Let T D I cid7S cid5 S Since D D I S S laws form 4 I S S cid5 V Follows S cid5 R Let cid7s A s V R cid5 Proof Let D D u Dm let T D cid7S V Rcid8 Since D I D u I Dm trivially satisﬁes ii deﬁnition update cid5 D I accomplishment remains D I consistent iii D I cid6 Co iv D D D u I D cid5 cid5 cid5cid8 In following prove T D I T D cid5 S Furthermore D subsumes I s S satisﬁes G L static cid5 S labeling convention states cid5cid8 candidate transition relation R action description D s cid5 cid5 satisﬁes G s A satisﬁes H Furthermore let s satisﬁes G b s cid5 static laws form 4 D s cid5 D s heads laws applicable cid7s A s F Then cid7s A s candidate cid7s A s cid5 R candidate R cid5 R A follows R cid5cid8 R As cid7s A s cid5 cid5cid8 R iff candidate R s cid5 cid5cid8 R R cid5cid8 uniquely determines s cid5 satisﬁes heads L satisﬁes heads L dynamic laws form 5 cid5 determined successor s wrt A set contains ﬂuent literal ﬂuent determined successor s respect A Since D D I cid5cid8 determined successor s respect s cid5 cid5 candidate R Moreover D subsumes I implies candidate cid7s A s Given D consistent D cid6 C T D I T D proves iii As iv D cid6 C T cid5 T implies cid5 D I cid6 C Since cid2C nonminimizing respect L follows D u I D proves iv Therefore D I solution D I C cid2C Moreover cid2C strongly nonminimizing respect L cid5 D I This implies D I unique solution D I C cid2C D case cid3 cid5 cid2C D I holds D u I D cid5 D I D I cid16cid2C D From result obtain following corollaries telling solution ADU expect extremal cases correspond cases considered nonmonotonic logic programming updates 520 Corollary 1 Void update Let D C cid2C ADU problem If cid2C nonminimizing respect L D consistent D cid6 C D solution D C cid2C If cid2C strongly nonminimizing respect L D unique solution Corollary 2 Idempotence Let D D C cid2C ADU problem cid2C nonminimizing respect L D consistent D cid6 C D unique solution D D C cid2C Note Void Update Idempotence easily extended cases I D given D consistent D cid6 C holds D solution cid2C nonminimizing strongly nonminimizing cid2C unique solution Let causal law tautological subsumed action description D Informally causal law logical content updating lead change In fact following property Corollary 3 Addition tautologies Let D I C cid2C ADU problem cid2C nonminimizing respect L D consistent D cid6 C If I consists tautological causal laws D I solution D I C cid2C If cid2C strongly non minimizing respect L D I unique solution Notice similar property fails logic programming updates 520 Example 3 Consider action description D following causal laws inertial LightON LightON caused LightON SwitchLight LightON caused LightON SwitchLight LightON Since D consistent strongly nonminimizing state set C constraints D cid6 C D cid5 C unique solution D C void update D D C idempotence D D tautological action description D addition tautologies cid5 nonnegative weights constraint c C instead preference relation Considering weightq nonminimizing infer D cid5 solution general need unique T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1185 42 Postulates belief change In literature kinds changes identiﬁed incorporation new information viz revision adds precise knowledge domain update change world se 66 Despite nature change distinction beliefs represented theory logically closed set sentences theory base knowledge base ﬁnite representation theory 33 Ideally operators different kinds belief change characterized different sets axioms postulates like AGM theory 2 belief revision KM theory 39 belief base update Fitting approach context ﬁrst observe common basic assumption different belief change postulates beliefs sentences given logical language closed standard Boolean connec tives case action languages In order evaluate approach style AGM KM respectively necessary interpret adapt respective postulates We note additional assumptions AGM theory underlying inference relation satisﬁes superclassicality modus ponens deduction theorem cf 57 inapplicable Since action description constitutes ﬁnite representation theory action domain update approach classiﬁed operating belief bases Let brieﬂy recall KM postulates belief base update10 U1 KB cid22 φ implies φ U2 If KB implies φ KB cid22 φ KB U3 If KB φ satisﬁable KB cid4 φ satisﬁable U4 If KB1 KB2 φ1 φ2 KB1 cid22 φ1 KB2 cid22 φ2 U5 KB cid22 φ1 φ2 implies KB cid22 φ1 φ2 U6 If KB cid22 φ1 implies φ2 KB cid22 φ2 implies φ1 KB cid22 φ1 KB cid22 φ2 U7 If KB complete KB cid22 φ1 KB cid22 φ2 implies KB cid22 φ1 φ2 U8 KB1 KB2 cid22 φ KB cid22 φ1 KB cid22 φ2 Besides postulates update Katsuno Mendelzon reformulated AGM postulates case belief base revision propositional logic R1 KB cid4 φ implies φ R2 If KB φ satisﬁable KB cid4 φ KB φ R3 If φ satisﬁable KB cid4 φ satisﬁable R4 If KB1 KB2 φ1 φ2 KBcid4φ1 KB2 cid4 φ2 R5 KB cid4 φ1 φ2 implies KB cid4 φ1 φ2 R6 If KB cid4 φ1 φ2 consistent KB cid4 φ1 φ2 implies KB cid4 φ1 φ2 421 Interpretation postulates As interpretation postulates setting subsumption relation action description set causal laws characterizing implication equivalence Lemma 1 Equivalence Let D1 D2 action descriptions signature L cid7F Acid8 Suppose causal law l L holds D1 subsumes l iff D2 subsumes l Then T D1 T D2 Proof Let T D1 cid7S1 V 1 R1cid8 T D2 cid7S2 V 2 R2cid8 Towards contradiction ﬁrst suppose S1 cid16 S2 Wlog sume s state S1 s S2 Consider arbitrary ﬂuent F let F denote F F true s F Then D1 subsume l caused F G D2 trivially subsumes l contra sGt G cid5cid8 R1 diction Hence S1 S2 holds V 1 V 2 Next suppose R1 cid16 R2 wlog assume cid7s A s cid7s A s F Then D1 subsume cid5cid8 R2 Again consider arbitrary ﬂuent F let F denote F F true s sG f cid6 cid6 cid5 l caused F cid4 cid4 cid4 cid4 cid4 cid4 G G Ha Ha H s H s Ha A D2 trivially subsumes l contradiction Therefore R1 R2 holds This proves claim cid3 sH s f HaA A sH st scid5G f scid5Gt Closing language conjunction problem action description regarded junction causal laws However meaning negation disjunction causal laws action descriptions ambiguous undeﬁned Therefore refrain interpretation postulates U7 U8 10 Hanssons 33 postulates contraction style Levi Identity rise revision contraction expansion requires use negation lack 1186 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Another diﬃculty arises fact new information incorporated action description char acterized syntactically semantically different entities causal laws constraints Naturally KB implies φ understood componentwise KB subsumes causal laws given φ KB satisﬁes constraints given φ Given considerations paraphrase postulates follows R1 U1 R2 U2 R3 U3 cid5 If D solution D I C cid2C D If D I consistent D I cid6 C T D cid5 T D solution D If D subsumes I D cid6 C T D cid5 cid5 If exists action description D D solution D I C cid2C If D consistent exists action description D D I C cid2C solution consistent D cid5 cid5 cid5 subsumes I D cid5 T D solution D cid5 cid6 C D I C cid2C cid5 D I C cid2C cid5 subsumes I D cid5 cid6 C exists D cid5 consistent D cid5 subsumes I D cid5 cid6 C R4 U4 If T D1 T D2 T I1 T I2 C1 C2 T D cid5 1 T D cid5 2 solutions D cid5 1 D cid5 2 D1 I1 C1 cid2C D2 I2 C2 cid2C respectively R5 U5 If D cid5 solution D I1 C1 cid2C D cid5 I2 subsumes l D cid5cid5 subsumes l solution D cid5cid5 R6 U6 solution D I1 C1 cid2C D cid5 D I1 I2 C1 C2 cid2C If D subsumes l solution D If D D cid5 2 subsumes I1 D cid5cid5 cid5 2 cid5 1 solution D I1 C1 cid2C D cid6 C1 T D D I1 I2 C1 C2 cid2C cid5 1 subsumes I2 D cid5 1 T D cid5 2 cid5 I2 consistent satisﬁes C2 D cid5cid5 subsumes l implies D cid5 I2 cid5 1 cid6 C2 D cid5 2 solution D I2 C2 cid2C Obviously R1 U1 hold deﬁnition R2 holds strongly nonminimizing cid2C For U2 know Proposition 1 holds D consistent addition strongly nonminimizing cid2C Both conditions necessary Concerning R3 U3 hold general D u D cid5 D I In case hold deﬁnition wit let D D u caused F cid2C I caused F C Note property holds C D u Proposition 2 Solution existence Let D I C cid2C ADU problem D action description D ii C D u consistent D signature L Then exists solution D I C cid2C D u D cid5 cid5 cid5 cid6 C D cid5 D I D cid5 subsumes I cid5 I cid6 C cid5 I Proof Note consistency D cid5 I presolution proves existence cid5 I cid6 C hold Hence D consistent Furthermore D u D solution For ii observe D u I D I I cid6 C C Hence I presolution proves existence solution cid3 subsumes I implies I consistent In Case implies D cid5 D cid5 I D I D cid5 Irrelevance Syntax R4U4 hold cid2C C Consider D1 caused F caused F D2 caused G caused F G caused F G I1 I2 We remark counterexample canonical sense I1 I2 C inconsistent D1 D2 Note easily modiﬁed counterexample D1 D2 consistent instance I1 I2 nonempty Property R5 U5 holds consistency required C D cid5 I2 consistent cid2C strongly non minimizing In general fails witnessed D Dm caused F A cid2C I1 caused F A F cid5cid5 I1 I2 solution I2 caused F A F C SOMETIMES executable A In case D D I1 I2 C cid2C D I1 I2 satisfy C However D subsume caused F A cid5 I2 incon case D cid5cid5 I1 I2 subsume sistent Let D Dm caused F cid2C I1 caused G I2 caused F Then D caused F cid5 D I1 The property hold strongly nonminimizing cid2C case C D Similarly R6 holds consistency required C cid2C strongly nonminimizing In general fails Let D Dm caused F A F cid2C I1 I2 caused F A F C1 SOMETIMES executable A cid5 I2 D I2 subsume l C2 Then D consistent trivially satisﬁes C2 cid5cid5 I2 subsumes l caused F A F However D cid5cid5 Proposition 3 Unique consequence Let D I1 cid2C D I1 I2 cid2C ADU problems cid2C strongly non minimizing wrt L If D cid5 I2 solution D I1 I2 cid2C solution D I1 cid2C D cid5 I2 consistent D cid5 Proof Obviously D contradiction assume consistent action description D cid5 I2 presolution D I1 I2 cid2C consistent trivially satisﬁes C Towards cid5cid5 cid5cid5 D u I1 I2 D cid5 I2 cid2C D D cid5cid5 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1187 cid5 Then D I1 I2 Then cid2C strongly nonminimizing wrt L conclude D cid5 D1 Furthermore D1 consistent satisfaction static laws monotone trivially satisﬁes C D1 D cid5 cid2C D1 This presolution D I1 cid2C Because cid2C strongly nonminimizing wrt L follows D cid5 I2 solution contradicts assumption D D I1 I2 cid2C cid3 solution D I1 cid2C Therefore D cid5 D1 D exist D Let D1 D cid5 I2 D cid5cid5 I2 D cid5cid5 cid5cid5 cid5 Eventually U6 fails hold strongly nonminimizing cid2C consistency required C Let D cid2C I1 caused F A F I2 caused F A C1 C2 Then I1 subsumes I2 vice versa T I1 cid16 T I2 422 Discussion Summing observe simple setting unmodiﬁable laws D u constraints C set inclusion preference relation cid2C postulates satisﬁed Concerning revision postulates apart additional consistency requirement solution existence R5 postulate completely fails Irrelevance Syntax R4U4 This intuitive given causal information action description depends syntactical representation terms causal laws While different sets causal laws knowledge bases represent transition diagram new information incorporated longer needs case Concerning update postulates addition failure U4 postulate U2 hold general The reason solutions consistent property discussed discriminating properties update revision In respect approach certainly acts like revision operator Moreover U6 fails hold simple setting Let turn sophisticated ADU problems static consistency required solutions dynamic requirements need hold changing knowledge base Recall general requirements expressed terms causal laws With represent action domains satisfy respective requirement specify solution new information incorporated expressing requirement As soon dynamic requirements demanded C cid16 postulates cease hold R3 U3 R5 U5 R6 For R3 U3 reason solution space constrained causal laws occurring D I consider reasonable assumption practical change operations setting In case R5 U5 R6 related supplementary AGM postulates AGM postulates K7 K8 57 simple counterexamples reveal main reason failure nonmonotonicity action language independent problem deﬁnition 43 Disjoint factorization We consider structural property solutions presolutions exploited syntactical decompo sition ADU problem divideandconquer manner Because involved semantics transitions causation general prerequisites needed Deﬁnition 5 NOP We action description D NOP T D transition cid7s scid8 state s ii state s exists transition cid7s s cid5cid8 Notice NOP natural property applies particular timedriven domains passage time causes cid7s scid8 inertia usually states s LD appears action description D The following lemma key disjoint factorization result For action signature L cid7F Acid8 denote Lemma 2 Let T D cid7S V R icid8 action descriptions D 0 1 L following hold D0 L D1 Let T D0 D1 cid7S V Rcid8 Then S s0 s1 s0 S 0 s1 S 1 ii R0 cid16 R1 cid16 cid7s0 D0 A L iii cid7s A s cid5cid8 R cid7s L 0 A0 s0 D0 s 1 cid5 L cid8 R0 cid7s1 0 A1 s1 D0 cid8 R0 cid7s L cid8 R1 cid7s0 0 D1 A L 1 s1 D1 s 0 A0 A1 s0 cid5 L D1 cid8 R1 1 s1 1 cid8 R cid8 R Suppose case Then following cases holds Proof trivial We prove ii iii follows s0 1 ii Suppose R0 cid16 R1 cid16 Take cid7s0 s1 1 1 For dynamic law d form 5 D0 D1 s0 0 D1 s0 Wlog suppose d D0 Then L cid8 R0 contradiction cid7s0 0 A0 s0 D0 L 1 0 0 A0 s0 1 cid8 R0 cid7s1 0 A1 s1 1 cid8 R1 We cid7s0 0 s1 0 A0 A1 A0 A1 satisﬁes H s0 1 s1 0 A0 satisﬁes H s0 1 satisfy G L 1 satisfy G L This implies s1 1188 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 s1 2 s0 2 2 state different s0 1 satisﬁes heads static laws 4 D0 D1 s0 s1 0 0 A0 A1 implies s0 s1 satisﬁes G dynamic law 5 D0 D1 satisfaction H s0 1 0 1 D0 L satisﬁes G Then causal law D0 D1 L 2 satisﬁes heads static laws 4 D0 s0 0 satisﬁes G dynamic law 5 D0 satisfaction cid8 R1 Symmetrically claim holds D1 This H s0 0 contradiction s1 0 D1 follows s0 1 satisﬁes G This implies cid7s0 A0 implies s0 0 A0 s0 s1 1 1 iii Take cid7s A s cid5cid8 R Wlog suppose cid7s L D0 A L D0 s cid5 L D0 cid8 R0 Then following cases holds Since L 2 s0 D1 s A satisﬁes H s 1 For dynamic law d form 5 D0 s L D0 A L D0 L satisfy G L This implies cid7s A s 2 state satisﬁes heads static laws D0 s L cid5cid8 R contradiction D0 satisﬁes G dynamic law 5 D1 satisfaction H s L D0 satisﬁes G Consider s D1 D0 L Due s satisﬁes heads static laws 4 D0 D1 s satisﬁes G dynamic law 5 D0 D1 satisfaction H s A implies cid5 s D0 A L D1 following holds s cid5cid8 R contradiction cid3 satisﬁes G This implies cid7s A s D0 satisfy G L cid5cid5 S Moreover L D0 satisﬁes H s D0 implies s cid5cid5 s0 2 cid5 L cid5cid5 cid5 L s cid5 cid5 L Intuitively lemma describes transition diagram action description composed action description consists syntactically disjoint parts It exploited decompose given action description disjoint parts result For decomposition faithful sense solutions respective ADU subproblems composed yield solution original ADU problem care taken respect aspects First set transitions shall compromise approach avoided presence dynamic constraints cf Lemma 2ii This guaranteed NOP property fact suﬃcient composing presolutions Second composing solutions composed preference relation needs comply preferences subproblems Stated viewpoint decomposition preference relation factorizable Towards formal treatment ideas need terminology We L0 L1 Li cid7Fi Aicid8 0 1 partitioning signature L cid7F Acid8 F0 F1 A0 A1 partitioning F A respectively We ﬁrst deﬁne decompositions action descriptions constraints Deﬁnition 6 ADconstraint decomposition Suppose L0 L1 partitioning signature L cid7F Acid8 let X action description set constraints L Then partitioning X 0 X 1 X called decomposition X X Li 0 1 Furthermore X decomposable respect L0 L1 decomposition respect L0 L1 L exists Based deﬁne notion neardecomposition ADU problem splits action description constraints separate parts disregarding preference Deﬁnition 7 Neardecomposition Let D I C cid2C ADU problem signature L let D0 D1 I 0 I 1 C 0 C 1 decompositions D I C respectively respect partitioning L0 L1 L Then D0 I 0 C 0 D1 I 1 C 1 neardecomposition D I C cid2C respect L0 L1 The following theorem formally shows presolutions ADU problem obtained neardecomposition provided ramifying conditions hold We constraint c occurs positively resp negatively set C constraints c occurs scope resp odd number negations constraint C Theorem 1 Disjointness Given ADU problem D I C cid2C signature L let D0 I 0 C 0 D1 I 1 C 1 near decomposition respect partitioning L0 L1 L let cid21Ci arbitrary preference ordering action descriptions Li 0 1 Then following holds Let X presolution D I C cid2 Then X 0 X 1 presolution D I C cid2C C X NOP dynamic constraint occurs negatively C 1i 0 1 ii Let X presolution D I C cid2C let X 0 X 1 partitioning X respect L0 L1 X D X NOP dynamic constraint occurs positively C 1i 0 1 Then X presolution D I C cid2 C 0 1 Proof Let T X 0 X 1 cid7S V Rcid8 let T X cid7S V R icid8 We ﬁrst static constraint c X 0 X 1 s cid6 c c C X si cid6 c s Li si Since ﬂuent literal L c si cid6 L implies s cid6 L c L C Li c contains ﬂuent literals Li claim follows Conversely static constraint c holds X si cid6 c c C X 0 X 1 s cid6 c si s Li Again fact ﬂuent literal L c Li conclude C Li exists s cid6 L implies si cid6 L proves claim Therefore conclude static constraint c L T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1189 state s S X 0 X 1 s cid6 c iff exists state si S X si cid6 c Moreover structure S cf Lemma 2i X 0 X 1 s cid6 c s S iff X si cid6 c si S Hence C contains static constraints X 0 X 1 satisﬁes C iff X 0 satisﬁes C 0 X 1 satisﬁes C 1 We consider dynamic constraints c form necessarily Q A1 An necessarily Q A1 An following 1 X 0 X 1 s cid6 c c C X si cid6 c s Li si X 1i NOP c negative Q contains negative dynamic constraint 2 X si cid6 c c C X 0 X 1 s cid6 c si s Li X 1i NOP c positive Q contains positive dynamic constraint We proceed induction nesting depth k constraint cid16cid6 Q Since X 1i NOP exists sequence n 1 states h1i s1i s1i Base case k 0 1 Let c positive contradiction consider state s S s Li si exists history h s A1 s1 sn1 An sn sn cid16cid6 Q By Lemma 2iii transition history hi si A1 s1 Li sn1 Li An sn Li R Furthermore sn cid16cid6 Q implies sn Li cid16cid6 Q c X Q contains static constraints Contradiction If c negative exists history hi si A1 si n si n n history X 1i By Lemma 2ii h si s1i A1 An si cid16cid6 Q implies si n n1 An si s1i history X 0 X 1 Furthermore si n cid16cid6 Q c X Q contains static constraints Contradiction This proves 1 k 0 s1i n 2 Let c positive contradiction consider state si S si s Li exists history cid16cid6 Q Since X 1i NOP exists sequence n 1 states h si A1 si 1 si h1i s1i s1i history X 0 X 1 Furthermore si cid16cid6 Q c X Q contains static constraints Contradiction If n c negative exists history h s A1 s1 sn1 An sn sn cid16cid6 Q By Lemma 2iii transition history hi si A1 s1 Li sn1 Li An sn Li R Furthermore sn cid16cid6 Q implies sn Li cid16cid6 Q c X Q contains static constraints Contradiction This proves 2 k 0 history X 1i By Lemma 2ii h si s1i A1 An si n1 s1i n cid16cid6 Q implies si n n1 An si s1i n si n n1 s1i 1 si s1i n s1i n s1i n 1 1 n n Induction step Let 1 2 true dynamic constraints nesting depth k 1 consider dynamic constraint c nesting depth k Then Q contains static constraints dynamic constraints nesting depth k 1 Thus 1 2 hold c follows easily arguments base case replacing justiﬁcations fact Q contains static constraints respective justiﬁcation Q contains static constraints dynamic constraints nesting depth k 1 So far shown 1 2 hold open constraint By structure S cf Lemma 2i conclude existential universal constraint c X 0 X 1 cid6 c c C X cid6 c X 1i NOP c contains negative dynamic constraint X cid6 c c C X 0 X 1 cid6 c X 1i NOP c contains positive dynamic constraint Therefore X cid6 C X 1i NOP C contains negative dynamic constraint 0 1 implies X 0 X 1 cid6 C Conversely X 0 X 1 cid6 C X 1i NOP C contains positive dynamic constraint implies X cid6 C 0 1 We proceed proof theorem Case Let X presolution D I C cid2 C 0 1 Suppose 0 1 X NOP dynamic constraint occurs negatively C 1i We X 0 X 1 presolution D I C cid2C By Lemma 2i X 0 X 1 consistent X 0 X 1 consistent Furthermore D0 I 0 I 1 u I 1 X 1 D1 I 1 respectively Eventually X 0 cid6 C 0 X 0 X 1 D I follows D0 u X 1 cid6 C 1 implies X 0 X 1 cid6 C This proves X 0 X 1 presolution D I C cid2C I 0 X 0 D0 I 0 D1 u Case ii Let X presolution D I C cid2C let X 0 X 1 partitioning X X 0 D0 X 1 D1 Suppose 0 1 X NOP dynamic constraint occurs positively C 1i We prove 0 1 X presolution D I C cid2 C Since X consistent X 0 X 1 consistent To observe wlog X 0 inconsistent static laws X 0 unsatisﬁable implies X unsatisﬁable contradiction Moreover D u I X D I implies D0 I 1 X 1 D1 I 1 Finally X 0 X 1 cid6 C implies u X 0 cid6 C 0 X 1 cid6 C 1 Thus X 0 X 1 near solutions D0 I 0 C 0 cid2 I 0 X 0 D0 I 0 D1 u D1 u C 0 D1 I 1 C 1 cid2 C 1 respectively cid3 Informally NOP property Theorem 1 needed ensure transition diagrams presolutions sub problems combined As mentioned necessary presence dynamic constraints For decomposition ADU problem need near decomposition factorization preference relation formally deﬁned follows Deﬁnition 8 Preference factorization Let cid2C preference relation action descriptions signature L let C action descriptions Li 0 1 L0 L1 partitioning L A pair cid2 C 1 preference relations cid2 cid5 L decomposable respect factorization cid2C respect L0 L1 action descriptions D D L0 L1 holds D cid2C D C 1 D1 D C 1 D implies D0 cid2 C 0 D0 D1 cid2 cid50 D C 0 cid2 C 0 D cid50 cid16cid2 cid51 cid16cid2 cid51 cid5 Note preference strict subset inclusion cid21C factorizable taking preference relations factorization We remark set constraints C decomposable respect L0 L1 constraint weight preference weightq factorizable provided weights nonnegative instance taking weights factorization A decomposition ADU problem follows 1190 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Deﬁnition 9 ADU decomposition A decomposition given ADU problem D I C cid2C respect partitioning L0 L1 signature L pair D0 I 0 C 0 cid2 C 0 D1 I 1 C 1 cid2 C 1 D0 I 0 C 0 D1 I 1 C 1 near C 1 factorization cid2C decomposition D I C cid2C cid2 C 0 cid2 The following result main result section solutions ADU problem easily obtained Theorem 1 C 1 decomposition ADU problem D I C cid2C respect parti Theorem 2 Let D0 I 0 C 0 cid2 tioning L0 L1 signature L Suppose dynamic constraint occurs C ii dynamic constraint occurs C 1 If X solution D I C cid2 C 0 1 case ii X 1 NOP X 0 X 1 solution D I C cid2C Furthermore case solution D I C cid2C represented form C 0 D1 I 1 C 1 cid2 Item states fully decompose ADU components solutions obtained simple combination solutions individual components However works general absence dynamic constraints combining transition graphs components unproblematic Item ii accounts possible dynamic constraints component unproblematic long solutions NOP However solutions composed solutions components general Example 4 Consider ADU problem D D Since X 0 D I caused TvON PowerON solution D I C cf Example 1 X 1 D D caused TvON PowerON solution D D cid5 cf Example 3 D cid5 I C D cid5 I C I C Example 1 D NOP easily veriﬁed Theorem 2ii X 0 X 1 D D Example 3 unique solution cid5 I cid5 cid5 cid5 Example 5 Consider ADU problem D D cid5 I caused TvON PowerON solution D D Example 3 Again X 0 X 1 D D I caused TvON PowerON solution D I C weightq cf Example 2 X 1 D D D I C weightq Moreover setting weight constraint 13 cid5 I C weightq X 0 D unique solution cid5 I different presolution ADU problem D u I presolution cid5 I C weightq D I C weightq Example 2 D cid5 weightq By Theorem 1 D u D cid5 cid5 ALWAYS holds PowerON TvON necessarily holds TvON PushPBTV 0 amounts assigning preferred constraints dont care status solution Theorem 1 provides basis decomposing ADU smaller ADUs solved divideandconquer manner11 Theorem 2 shows possible exploitation These results integrated algorithms computing solutions consider Section 6 effectiveness demonstrated practical example Section 72 Finally note exemplary preference relations weightq nonnegative weights benign properties monotonicity nonminimization respect L carry standard factorizations given restricting relation relevant domain recursively exploited 5 Complexity analysis In section investigate computational complexity relevant tasks solving ADU problem including decide solution exists given action description solution The complexity tasks strongly depends complexity deciding given action description satisﬁes set obligatory constraints D cid6 Co action description preferred action description given preference relation D cid2C D cid5 We ﬁrst consider worstcase complexity mentioned subproblems parameter derive upper bounds terms membership results deciding ADU problem solution checking action description solution ADU problem generic setting We instantiate generic setting considering different classes restricted sets constraints yield different complexities deciding D cid6 Co studying concrete preference relations complexity deciding D cid2C D differs In particular provide com pleteness results syntactic preference deciding D cid2C D polynomial semantic preference cid5 weightq ranges PSPACE classes constraints considered Note class admitted constraints main source complexity concrete settings particular deciding D cid2C D reduces deciding constraint fulﬁllment deciding D cid2C D cid5 cid5 cid5 11 For similar stronger results classical propositional logic 54 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1191 Table 1 Complexity deciding solution existence solution checking depending complexity relevant sub problems completeness results hardness holds ﬁxed preference relation cid2C D cid6 Co D cid2C D cid5 PSPACE cid5P 1 P Solution existence Solution checking PSPACE Σ P NP PSPACE Π P DP 51 Generic upper bounds Our main result generic upper bounds gives general picture precise complexity characterizations summarized Table 1 Recall PSPACE class decision problems decided deterministic Turing machine space polynomial length input PSPACE contains socalled Σ P Π P polynomial hierarchy sequence classes deﬁned cid5P 0 0 0 Π P Finally DP class decision problems yes instances characterized conjunction NP problem independent coNP problem The prototypical problem SATUNSAT yes instances pairs F G propositional formulas F satisﬁable G unsatisﬁable problem complete DP For background complexity theory refer 53 P cid3 0 cid5P coNPΣ P NPΣ P PΣ P Σ P i1 i1 i1 Informally results modulo cost deciding satisfaction constraints preference com plexity solution existence checking increases level polynomial hierarchy exponential search space solution respectively better solution candidate nondeterministically guessed Since search space traversed polynomial space increase complexity general case We formally establish Table 1 Given ADU problem D I C cid2C let Ccheck denote class problems cid5 D I Similarly let Pcheck denote class problems deciding cid5 cid6 Co D u I D deciding D D1 cid2C D2 holds action descriptions D u I D D I 1 2 Theorem 3 Deciding given ADU problem D I C cid2C solution presolution PSPACE Ccheck PSPACE Ccheck cid5P ii Σ P iii NP Ccheck P 1 Given ADU problem D I C cid2C action description D cid5 deciding D cid5 solution PSPACE Ccheck Pcheck PSPACE b Π P Ccheck Pcheck cid5P c DP Ccheck Pcheck P 1 cid5 Proof Let D D u Dm In order decide D I C cid2C solution guess presolution D D u I D polynomial time iii respectively help Σ P cid5 D u I state s D witness consistency check D cid5 cid6 Co polynomial space i1oracle This proves ii iii D solution state s As deciding given D cid5 cid16 D I We check D let consider complementary problem We non proceed follows We check polynomial time cid5 inconsistent polynomial space respectively b cid5 cid16cid6 Co polynomial space Case polynomial cid5cid5 D I D i1oracle Case b Furthermore check polynomial time D u I D PSPACE b Two checks decide D i1oracle Thus complementary problem PSPACE respectively b Σ P deterministically guess D D u I cid16 D single NPoracle Deciding D time Σ P consistent s polynomial time help Σ P proving b cid5cid5 cid6 Co D state D cid5 cid2C D cid5cid5 cid5cid5 cid5cid5 cid5cid5 cid5cid5 cid5cid5 cid5 cid5 cid5 For c nondeterministically guess state s decide D u I D cid5cid5 complementary problem guessing D cid5 cid2C D cid5cid5 s cid5cid5 cid6 Co D use check consistency polynomial time Also cid5 D u I polynomial time An independent coNPcheck excludes preferred presolutions cid5cid5 D I consistency checking D u I D state s cid5cid5 polynomial time This proves DP membership c cid3 state D D D cid5cid5 cid5cid5 cid5 cid5 Before turn attention instantiating general result ADU problems different classes restricted sets constraints concrete preference relations yield precise complexity characterizations terms completeness results remark ease exposition remainder section proofs sketched summarizing main arguments constructions proofs given Appendix A 1192 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 52 Constraint fulﬁllment As outlined beginning section important subtasks solving ADU problems checking set constraints satisﬁed action description This subtask major inﬂuence complexity ﬁnding solutions ADU problem Therefore considering arbitrary constraints investigate restricted classes constraints In particular maximal nesting depth dynamic constraints ﬁxed integer k dynamic constraints occur Theorem 4 Given action description D set C constraints deciding D cid6 C PSPACEcomplete general ii Θ P iii PNP k3complete k maximal nesting depth dynamic constraints C cid24 complete C involve dynamic constraints Here PNP cid24 means polynomialtime single parallel evaluation calls NP oracle Similarly 1 Θ P class problems decided polynomial time parallel calls Σ P characterized allowing O log n oracle calls 65 i1 oracle alternatively class Proof Concerning result shown 18 Membership Case iii follows fact checking truth negated universal constraint form ALWAYS Q Q conjunction clauses static constraints form holds F holds F NP Hence complementary task checking truth positive universal constraint ALWAYS Q coNP Thus D cid6 c decided polynomial time single parallel evaluation n NPoracle calls given n number universal constraints c Similarly proves Case ii induction nesting depth k D cid6 c decided polynomial time parallel Σ P k2oracle calls As hardness problem iii reduced following PNP cid24 hard decision version Maximum CNF Satisﬁabil ity 40 Given Boolean formula F conjunctive normal form CNF integer k decide maximum number clauses F simultaneously satisﬁed interpretation 0 mod k Consider 3CNF formula form cid6 i1 Li1 Li2 Li3 Li j 1 cid2 cid2 n 1 cid2 j cid2 3 literal atoms X X1 Xm following action n description D1 caused Ci Li1 caused Ci Li2 caused Ci Li1 Li2 Li3 caused Ci Li3 1 cid2 cid2 n cid7 caused F 11 C1 caused F 10 C1 caused F j Ci F i1 j1 caused F j Ci F i1 j1 caused F 11 C1 caused F 10 C1 cid7 caused F j Ci F i1 j caused F j Ci F i1 j cid7 2 cid2 cid2 n 1 cid2 j cid2 2 cid2 cid2 n 0 cid2 j Then D1 cid6 ck iff maximum number clauses F simultaneously satisﬁed interpretation 0 mod k ck following constraint ALWAYS holds Fn0 SOMETIMES holds Fnk ALWAYS holds Fnk1 holds Fnn SOMETIMES holds Fnlk ALWAYS holds Fnlk1 holds Fnn For hardness Case ii consider m Quantiﬁed Boolean Formulas QBFs Φl Q 1 Xl n El 1 cid2 l cid2 m j 1 cid2 j cid2 n 1 cid2 k l cid2 m pairwise disjunct sets Q 1 mod 2 Q X k propositional variables cid16 j k cid16 l El Boolean formula atoms Xl Xl n Φl false 1 Φl1 Φm false Deciding maximum index o 1 cid2 o cid2 m Φo true odd Θ P n1 hard 65 The problem deciding D cid6 c constraint c nesting depth k dynamic constraints reduced problem follows Xl Xl Q n Xl 1 Q 2 Xl 2 Let n k 2 1 cid2 l cid2 m let action description D2 consist following statements T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1193 cid7 caused F l caused F l caused F l caused F l Ai1 Ai1 F l F l j Ai1 F l j j Ai1 F l j 2 cid2 cid2 n F l Xl cid8 2 cid2 cid2 n 1 cid2 j cid2 n cid16 j F l j Xl j cid9 cid10 Consider constraint m32 l0 m22 l0 cid10 SOMETIMES f 2l1 ALWAYS f 2l2 gm m odd SOMETIMES f 2l1 ALWAYS f 2l2 gm SOMETIMES f m f l p1 N p1 cid2 pn1 N pn1 holds Elafter An1 cid3 A1 N necessarily pi pi void 1 cid2 cid2 n 1 Then maximum index o Φo true odd iff D2 cid6 cid3 53 Solution existence Equipped precise complexity characterizations Ccheck ADU problems classes constraints aim characterize exactly complexity solution ﬁnding tasks classes constraints particular preference relations Notice checking solution exists independent concrete preference relation computation This leads following result Theorem 5 Deciding given ADU problem D I C cid2C solution presolution PSPACEcomplete general ii Σ P iii Σ P iv NPcomplete Co k3complete k maximal nesting depth dynamic constraints Co 2 complete Co involve dynamic constraints Proof Membership follows Theorems 3 4 hardness Case follows Theorem 4 For hardness Case ii let n k 2 let Φ Y Q 1 X1 Q n Xn E QBF Q 0 mod 2 Q Consider D u D2 caused Y Ai1 Y caused Y Ai1 Y 2 cid2 cid2 n D2 action description proof Theorem 4 l 1 Dm caused Y caused Y Y Y I C Co C p C p Co ALWAYS p1 N p1 pn1 N pn1 holds E An1 A1 cid2 cid2 cid3 cid3 N necessarily pi odd void 1 cid2 cid2 n 1 Then exists solution action description update problem D u Dm I C cid2C iff Φ true For iii let Φ Y X E consider action description update problem D u Dm I C cid2C D u Dm caused Y caused Y Y Y I C Co ALWAYS holds E Again action description update problem D u Dm I C cid2C solution iff Φ true Finally iv let E Boolean formula atoms Y let deﬁne D u caused Y 1 E caused Y 1 E Dm caused Y caused Y Y Y I C Then D u Dm I C cid2C solution iff E satisﬁable cid3 This result instantiated preference relation yields completeness results deciding existence solution When instantiated syntactic preference remarkable consequence following Deciding D I solution ADU problem D I C complexity deciding D cid6 Co general Deciding existence arbitrary solution slightly harder deciding D cid6 Co restricted settings constraints Co Intuitively additional computational effort accounts search solution candidate 54 Solution checking We ﬁnally turn attention recognition solutions provide respective results syntactic preference semantic preference weightq Again problem turns PSPACEcomplete general Similarly restricted constraint settings testing arbitrary solution candidates higher complexity testing D I intuitively accounts additional maximality criterion checked solution 1194 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Theorem 6 Given ADU problem D I C action description D cid5 deciding D cid5 solution PSPACEcomplete general constraints Co ii Π P iii Π P iv DP complete Co k3complete k maximal nesting depth dynamic constraints Co 2 complete Co involve dynamic constraints Proof Membership follows Theorem 3 observing given action descriptions D polynomial time Pcheck P Hardness Case follows Theorem 4 For ii let n k 2 let Φ Y Q 1 X1 Q n Xn E QBF cid5 cid5cid5 D deciding D cid5 D cid5cid5 Q 1 mod 2 Q Consider D u D2 caused Y Ai1 Y caused Y Ai1 Y 2 cid2 cid2 n D2 action description proof Theorem 4 l 1 Dm caused Y caused Y Y Y I C Co ALWAYS f g cid2 cid2 cid3 cid3 f p1 N p1 cid4 g pn1 N pn1 holds E An1 SOMETIMES holds Y SOMETIMES holds Y A1 Y Y N necessarily pi odd void 1 cid2 cid2 n 1 pn 1 n odd void Then D u solution action description update problem D u Dm I C iff Φ true For iii let Φ Y X E consider action description update problem D u Dm I C D u Dm caused Y caused Y Y Y I C Co ALWAYS holds E g g The ADU problem D u Dm I C D u solution iff Φ true let E1 E2 Boolean formulas atoms Y 1 Y 2 respectively Consider D u caused F caused F E1 Dm caused F E2 I C Then D u Dm I C solution D u iff E1 satisﬁ able E2 unsatisﬁable cid3 Finally iv We consider solution checking semantic preference weightq Note Pcheck polynomial However intuitively complexity Pcheck outweigh longer case weightq complexity Ccheck allow complex constraints C p Co stay upper bounds Providing matching lower bounds yields following result differs previous C The intuitive reason syntactic preference case maximality check needed recognize solution semantic preference indifferent C means basically consistency check suﬃcient presolution solution Theorem 7 Given ADU problem D I C weightq action description D cid5 deciding D cid5 solution PSPACEcomplete general constraints C ii Π P iii Π P iv NPcomplete C k3complete k maximal nesting depth dynamic constraints C 2 complete C involve dynamic constraints cid5 decide D Proof Membership ii iii follows easily Theorems 3 4 For iv C Pcheck trivial weightq solution essentially checking consistency Hardness Case follows Theorem 4 For ii let n k 2 consider Φ D u Dm I Co proof Theorem 6ii Additionally let C p ALWAYS holds Y ALWAYS holds Y Y Y consider weight 1 c C p Then D u solution D u Dm I Co C p weightq iff solution D u Dm I Co For iii consider Φ D I Co proof Theorem 6ii Again let C p ALWAYS holds Y ALWAYS holds Y Y Y weight 1 c C p Then reason D u solution D u Dm I Co C p weightq iff solution D u Dm I Co Finally iv let E Boolean formula atoms Y consider ADU problem given D u caused Y 1 E caused Y 1 E Dm I C Then D u solution D u Dm I C weightq iff E satisﬁable cid3 Hence recognizing solutions hard However recognizing presolutions easier restricted sets cid24 complete C dynamic k3complete maximal nesting depth dynamic constraints C k PNP straints Θ P constraints NPcomplete C This follows easily Theorem 4 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1195 Fig 5 Algorithm compute solution preferred setinclusion 6 Computing solutions Equipped clear picture computational cost terms complexity relevant subtasks solving ADU problem turn issue computing solutions dedicated deterministic algorithms 61 General algorithms With oracle presolutions case syntactic preference incrementally compute solution ADU problem D I C D D u Dm polynomial time algorithm Fig 5 By virtue Theorems 5 6 algorithm worst case optimal nesting depth k dynamic constraints restricted computing k3 oracle If existence test presolution D u Dm I C Step 1 Step 2 solution needs power Σ P cid5 Dn fact returns presolution Dn replace respective assignment D Dm Dm Dn assignments D cid5 We remark semantic preferences like weightq deterministic polynomial time procedure computing solutions oracle computing near solutions work general However certain cases oracle presolutions effectively similar way For instance constraints C p strictly ordered according nonnegative weights subset constraints constraint c ordering sum higher weight c Then procedure similar Solution iterate set constraints C p oracle determine presolutions exist slightly modiﬁed problem certain constraints C p added Co order determine set constraints C p satisﬁed optimal solution Once set known presolution problem constraints added Co solution original problem For general case weightq nonnegative weights instance branch bound algorithm devised Algorithm Solution uses oracle presolutions compute initial solution candidate computation better candidates usual style anytime algorithm For preferences cid2C algorithms developed similarly exploit structure cid2C prune search space effectively If cid2C monotone respect underlying signature adapt Algorithm Solution similarly weightq branch bound algorithm aims enumerating presolutions techniques 13 useful cuts branches search tree better presolutions compared currently preferred ones D1 Dm precisely branch partial presolution D cut D cid101 cid10m cid2C D D Note solution preferred cid2C preferred set inclusion adapt way variant Algorithm Solution exploits presolutions returned oracle This scheme reﬁned usual exploiting properties like solution dominance possible cid5 cid101 cid10m solutions D preferred investigation remains future solution D work D D cid5 62 Presolutions Presolutions given ADU problem nondeterministically computed membership Theorem 5 obtained QBF encoding QBF solver We present different computation method builds update descriptions update ﬂuent sets Roughly consider varying update descriptions method problem compiled single action description called update description special update ﬂuents govern inclusion exclusion causal laws Determining update amounts determine appropriate update ﬂuent set semantically deﬁned computed constraint satisfaction state set generation algorithms 1196 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Fig 6 Algorithm compute presolution Deﬁnition 10 Let D D u Dm action description signature cid7F Acid8 The update description U D action description obtained D follows 1 Extend cid7F Acid8 set H k Dm new ﬂuents called update ﬂuents H 1 Hk 2 label static law 4 Dm ﬂuent H H caused L G H dynamic law 5 Dm ﬂuent H H caused L G H H laws labeled ﬂuent H 3 H labeling law add dynamic law inertial H H 15 16 17 C S U We deﬁne update ﬂuent sets To end deﬁne given action description D u Dm set constraints C C state set S U update description U U D D u Dm having cid5 H s cid5 cid6 Q holds Hs Case c existential 9 E s Hs iii c Boolean combination existential s S U c Hs c C Furthermore rest section identify states sets ﬂuents signature partitioning S U cid5 S U let s H s set H update ﬂuents follows For states s s Given constraint c state s S U c holds s wrt S U cid5 S U s universal constraints ci combination evaluates true ci value s wrt S U holds s wrt S U true state Hs ii c universal 10 E s cid5 H let S U Hs cid5 cid6 Q holds s Hs Then S U iff s H s cid5 S U s cid5 S U s C cid5 Deﬁnition 11 An update ﬂuent set U relative C set M H s H M s S U ii S U S U C Hs With notions compute presolution ADU problem D I C cid2C D D u Dm Algorithm PreSolution shown Fig 6 The key correctness following proposition Proposition 4 Let D I C cid2C ADU problem D D u Dm Let U update description D I D u I Dm cid5 D u I W presolution let W denote subset Dm containing laws labeled elements M H U Then D D I C cid2C iff M update set U relative Co The proof correspondence result technically involving given Appendix B It follows intuition considering update set D I relative Co adding corresponding labeled laws construction Dm D u I ends action description D satisﬁes Co The essential argument showing turn state s D implies s S D consistent Vice versa Co presolution corresponds update set M given labels modiﬁable laws included presolution cid5 s M state U Condition ii Deﬁnition 11 state S U Co cid5 cid6 Co Moreover Condition Deﬁnition 11 guarantees D D cid5 cid5 cid5 From Proposition 4 correctness Algorithm PreSolution easily established Theorem 8 Let D I C cid2C ADU problem D D u Dm Then Algorithm PreSolution outputs presolution D I C cid2C presolution D I C cid2C exists T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1197 We observe preference ordering cid2C algorithm easily adapted ﬁnd solutions instead near solutions end Step 3 maximal We note Step 1 necessary far mere computation presolution concerned However view ADU problem solving worthwhile particularly return D I ﬁrst presolution constitutes case I incorporated modiﬁcation D This particular relevant preference relations cid2C nonminimizing fact solution output Example 6 Consider ADU problem D I C cid2C given D I C presented Example 1 Note D I cid16cid6 C explained Example 1 We obtain following update description U D u I Dm contains D u I laws caused TvON PowerON H1 caused TvON PowerON H2 inertial H H 1 cid2 cid2 2 According transition diagram described U action PushPBRC executable constraint 3 ALWAYS executable PushPBRC violated state s PowerON TvON H 1 Moreover state s PowerON TvON H2 s constraint 13 ALWAYS holds PowerON TvON necessarily holds TvON PushPBTV cid11 S U C satisﬁed missing causation TvON At state U constraint 14 ALWAYS executable PushPBTV satisﬁed We obtain s S U cid12 cid12 s satisﬁes H1 H2 instance PowerON TvON H 2 S U C Therefore H2 update set U relative C obviously Hence add law labeled H 2 D u I equivalently remove law caused TvON PowerON labeled H1 D I obtain presolution problem cf Example 1 cid13 Example 7 Consider slight variant previous Example 6 dynamic laws D inertia laws modiﬁable following causal laws added Dm caused TvON PushPBTV PowerON caused TvON PushPBTV PowerON The transition diagram described D I Fig 4 reasons mentioned Example 1 D I cid16cid6 C The update description U D u I Dm consists D u I labeled laws presented Example 6 following causal laws caused PowerON PushPBTV PowerON H3 caused PowerON PushPBTV PowerON H4 caused TvON PushPBTV PowerON H5 caused TvON PushPBTV PowerON H6 3 cid2 cid2 6 inertial H H Constraint 3 ALWAYS executable PushPBRC violated according transition diagram described U action PushPBRC executable s PowerON TvON H 1 Let consider remaining states s U H1 s We ﬁrst observe violation constraint 13 ALWAYS holds PowerON TvON necessarily holds TvON PushPBTV witnessed state s PowerON TvON H 6 s H2 s H4 s causation TvON executing PushPBTV Finally constraint 14 ALWAYS executable PushPBTV hold state s power TV s PowerON TvON H 2 H5 s H3 s More formally cid11 S U C s S U cid12 cid12 s satisﬁes H1 cid2 cid3 H6 H2 H4 cid13 H3 H2 H5 Two update sets U relative C H 3 H4 H5 H6 H2 H3 H4 H6 That actually constitute update sets witnessed H3 H4 H5 H6 S U C respectively We choose C H2 H3 H4 H6 S U 1198 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 adding corresponding causal laws D u I presolution problem Note case cid2C instance presolutions solution removing caused TvON PowerON suﬃcient This reﬂected maximal update set H 2 H3 H4 H5 H6 Algorithm PreSolution run polynomial space worst case optimal bounds Indeed update description U D C easily computed polynomial time consistency constraint fulﬁllment check Step 1 bulk work Step 3 compute update set M Here resort different methods If state set S U U explicitly given Step 3 clearly feasible polynomial time Otherwise use algorithm enumerates S U state s generated s H candidate update set H M H M condition ii S U cid6 belongs S U Hs Then existential constraint c form 9 deﬁne cs SOMETIMES holds F s Q universal constraint c form 10 deﬁne cs ALWAYS holds F s Q For Boolean combination c existential universal constraints deﬁne cs constraint obtained rewriting C equivalent U cid6 cs occurrence existential universal constraint described Then S U constraint c C C tested constraint satisfaction brief outline follows Let F s Hs H intuitively F s holds state s H HM S U S U iff s cid6 Hs cid5 cid5 Thus build algorithms compute presolutions ADU basic reasoning services action descrip tions generate sets states allow checking satisfaction constraints supported ADConstraint 21 limitations applied update description U D Compared simple search cid5 cid6 Co approach attractive presolution candidates D advantages One compile transition diagram U D eﬃcient representation binary decision diagrams customary eﬃcient processing transitionbased formalisms perform state generation check constraint fulﬁllment single representation consider reasoning varying transition diagrams considerable management cost setting data structures anew precaution effort cid5 D I testing D D u I D cid5 Furthermore update description useful basis iterated Markovian historyless updates lazy evaluation generally realizing nonMarkovian semantics sequences updates I1 Ik analogy update programs context logic programming updates 520 In Markovian case result updating action description D obtained incorporating I 1 k D The update description U D generalized capture iterative updates easily time stamped copies action descriptions suitably linked modifying preference ordering cid2C appropriately prioritized version In nonMarkovian case linkage preference ordering tailored realize particular update semantics Investigating left work 7 Examples updating Zoo World Circus The Zoo World action domain proposed Erik Sandewall Logic Modelling Workshop It consists cages exterior gates animals species including humans Actions domain include moving cages opening closing gates mounting riding animals This domain described action language C 1 We present examples updating action description Zoo World C derived 1 obtain description Circus The ﬁrst example illustrates applicability method computing presolutions second example illustrates usefulness decomposability theorem 71 Singing mounting Circus Suppose like update action description Zoo World C way obtain description Circus taking account following new information human sing happy mounted animal We want ensure following condition different Zoo World Circus humans expected mount mount large animal First transform description 1 action language C modiﬁed description available Appendix C Next new information I following causal laws Suppose h ranges constants denoting humans anml ranges constants denoting animals zoo caused Happyh True Singh Mountedh anml Note h anml schematic variables expression stands set ground causal laws Next identify causal laws Dm modiﬁed The modiﬁcations desire mounting action particular let Dm consist following causal laws Suppose h h1 range constants denoting humans anml ranges constants denoting animals zoo p ranges positions zoo If human tries mount animal doesnt change position mounting successful caused Mountedh anml Posanml p Posanml p Mounth anml 18 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1199 Fig 7 The landscape little zoo 1 positions 14 inside cage positions 58 outside cage dashed lines denote gate A human attempt mount human mounted caused False True Mounth h1 Mountedh1 anml A human mounted human mounted caused False Mountedh h1 Mountedh1 anml 19 20 We assume little Circus humans small boy named Bart adult named Homer elephant Jumbo We assume Circus landscape little Zoo 1 cage positions inside outside cage positions Fig 7 We express desired conditions scenarios little Circus constraints For instance consider fol lowing scenario steps Initially Jumbo Bart different positions cage Homer outside cage Homer happy It possible point ﬁrst Homer mounts Jumbo Bart mounts Homer end Homer mounted Jumbo Bart mounted Homer Homer happy Suppose Jumbo change location scenario We scenario following constraint C SOMETIMES cid14 holds PosBart l Pos cid2 Homer l cid5 cid3 cid2 Pos Jumbo l cid3 cid5cid5 HappyHomer lcid16lcid5cid5 llcid5cid55 lcid54 cid2 possibly MountedBart Homer MountedHomer Jumbo HappyHomer MountHomer Jumbo MountBart Homer possibly MountedBart Homer MountedHomer Jumbo cid3 HappyHomer True MountHomer Jumbo MountBart Homer cid2 cid14 cid2 cid3 cid3 cid2 cid3 evolves Pos Jumbo l cid5cid5 True Pos Jumbo l True Pos Jumbo l cid5cid5 cid5cid5 lcid5cid55 True Pos cid2 cid2 Jumbo l cid3 cid5cid5 cid5cid5 cid2 cid3 True Pos cid2 Jumbo l cid3 cid5cid5 cid3 cid5cid5 True Pos cid2 Jumbo l cid3 cid5cid5 True 21 Pos Jumbo l True Pos Jumbo l We present constraint CCalc Fig 14 Appendix C CCalc ﬁnds scenario possible Zoo World Let ﬁnd presolution D ADU problem D I C applying Algorithm 6 For ﬁrst construct cid5 update description U Zoo World 1 We introduce update ﬂuents auxiliary ﬂuents following forms Aux1h anml p Aux2h h1 anml Aux3h h1 anml 2 We add new causal laws inertial inertial Aux1h anml p Aux2h h1 anml Aux3h h1 anml inertial Aux1h anml p Aux2h h1 anml Aux3h h1 anml 3 We replace causal laws 1820 following causal laws respectively caused Mountedh anml Posanml p Posanml p Mounth anml Aux1h anml p caused False True Mounth h1 Mountedh1 anml Aux2h h1 anml 1200 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 caused False Mountedh h1 Mountedh1 anml Aux3h h1 anml After check scenario represented constraint 21 possible causal laws labeled Aux2Bart Homer Jumbo Aux3Bart Homer Jumbo For need modify CCalc constraint adding lines shown Fig 15 Appendix C Then CCalc ﬁnds possible execution scenario presented Fig 16 Appendix C It suggests dropping Dm causal laws caused False True MountBart Homer MountedHomer Jumbo caused False MountedBart Homer MountedHomer Jumbo update Zoo World description little Circus 72 Exchanging hats Circus Consider world involves monkeys dogs animals monkeys wear hats We obtain C description D0 world C description missionaries cannibals exchanging hats 50 presented CCalc Fig 17 Appendix D Now consider variation Zoo World described Section 71 involves monkeys dogs monkeys wear hats This variation Zoo World described union Zoo World description D 1 discussed Section 71 Figs 813 Appendix C description D0 mentioned Suppose like update action description D0 D1 extended Zoo World obtain description Circus humans mount mount large animal animals exchange hats Assume modiﬁable D1 m D1 Section 71 modiﬁable D0 m D0 consists following causal laws caused False Ownerha anml ha ranges hats anml ranges animals monkeys We assume little Circus landscape Fig 7 contains humans small boy Bart adult Homer elephant Jumbo dog Snoopy monkeys small monkey Abu large monkeys hats In little Circus addition desired conditions scenarios presented Section 71 set C 1 constraints 21 consider following scenario initially Snoopy Abu wearing hats exchange hats We express condition constraints C 0 SOMETIMES cid2 evolves Ownerha1 Abu Ownerha2 Snoopy exchangeha1 ha2 True evolves Ownerha1 Abu Ownerha2 Snoopy True True exchangeha1 ha2 True evolves Ownerha1 Abu Ownerha2 Snoopy True True True True True exchangeha1 ha2 True cid3 ha1 ha2 range hats This constraint presented CCalc Fig 18 Appendix D Here update D0 D1 relative C 0 C 1 On hand D0 C 0 D1 C 1 near decomposition D0 D1 C 0 C 1 Theorem 1 update D0 D1 separately parallel Considering computation time CCalc takes verify given constraints approach takes time With approach CCalc veriﬁes constraints C 0 C 1 respect propositional theory size 20 450 atoms 398 430 clauses obtained update description D0 D1 9 minutes including grounding completion time With approach CCalc veriﬁes C 0 respect propositional theory size 164 atoms 766 clauses obtained update description D0 second including grounding completion time veriﬁes C 1 respect propositional theory size 5462 atoms 60 567 clauses obtained update description D 1 30 seconds including grounding completion time 8 Discussion 81 Related work Updating revising knowledge bases studied extensively context databases AI different approaches representation frameworks 673457 references The relation T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1201 problem reasoning actions identiﬁed earlier 665956 effects executing action given situation modeled change theory representing current state formula representing action effects However compared reasoning action languages approach leaves action consideration effects implicit Therefore restrict attention works treat notion action explicitly language closely related work Sakama Inoues work 61 similar work studies update problems nonmonotonic frame work logic programming considers criterion minimal change It deals kinds updates knowledge base D theory update D new information I inconsistency removal D view update D D u Dm new information I In context reasoning actions change kinds updates expressible ADU problems D I D D u Dm I Sakama Inoue 61 checking solution existence NPhard problem complies Theorem 5iii An important difference 61 ADU problem D I C constraints C directly expressed D Moreover se mantics action description D C transition diagram captured answer sets logic program corresponding D known transformations Li Pereira 44 Liberatore 47 study like theory update problems context reasoning actions change based action language language A instead C New information I contains facts describing observations time action PushPBRC occurs time stamp 0 The action language C use expressive A accommodates nondeterminism concurrency changes world direct effects actions To formulate temporal observations extend constraint language formulas shapes E occurs ti P holds ti 22 23 E action P ﬂuent ti time stamp state s satisﬁes constraint 22 resp 23 history 11 s s0 E Ai1 resp si satisﬁes P Our notion consistency action description D essence existence state different Zhang 68 They action domains propositional dynamic logic require consistency existence model action description Different setting conﬂicting action effects prevent model With extension constraint language discussed forms consistency studied 68 achieved framework describing possible scenarios formulas constraints Some related work mentioned like 649337 study action description updates connection problem elaboration tolerance The goal answer following question action description updated tolerate new elaborations action domain 37 studies update problem context dynamic logic 35 Here action domains represented simpliﬁed version dynamic logic An action domain description consists static laws Up Light expresses switch light effect laws actions Up ToggleUp expresses switch toggling room lit executability laws actions Broken cid7Togglecid8cid28 expresses toggle executed switch broken To handle frame problem ramiﬁcation problem consequence relation built metalanguage action description Note action description language C require metalanguage able handle problems In formal framework reasoning actions change authors consider revising beliefs states world 3862 revising beliefs action laws They update action descriptions respect elaborations described causal laws modifying causal laws action description ﬁrst contraction expansion In end antecedents causal laws action description strengthened respect new elaborations Consider example blackout agent toggles switch room dark A respective elaboration described causal law like Blackout ToggleLight contracted action description The action description modiﬁed elaboration ﬁrst contracting effect laws Up ToggleUp expanding theory weakened laws Up Blackout ToggleUp The idea modifying theory elaboration form φ aψ way ensure conditions φ hold ﬁrst effect ψ second effect literals consequences ψ The semantics syntactic operations given terms changes additionremoval edges transition diagram Note 37 modiﬁes causal laws tolerate elaborations add new causal laws obtained observations elaborations original description furthermore drop minimal set causal laws original theory given constraints desiredpreferred conditions domain satisﬁed updated description In words 37 suitable incorporation new information compared approach For instance example given elaborating wrt effect law Blackout ReplaceFuseBlackout serve intended purpose incorporate effects replacing broken fuse approach simply update causal law caused Blackout ReplaceFuse Blackout purpose Another related work studies action description updates elaboration tolerance 3 The authors introduce action description language called Evolp Action Programs EAPs built update language Evolp 4 This language represent action domains updates elaborations An action domain description 1202 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 consists static rules Light Up dynamic rules effectLight Up Toggle Up expresses step n switch switch toggled step n Light Up true step n 1 inertial declarations inertialLight initialize declarations initializeLight stands Light prevLight prevF new atom introduced describing value ﬂuent F previous state introduced representing inertia Note action language C need introduce new atoms able handle frame problem An elaboration encoded separate action description D asserted main description assert construct Evolp The semantics EAP assert construct given means stable models 29 Adding assertD initial description different adding D like approach ensures static consistency resulting action description update consistent preference implicitly given set inclusion maximal consistent subsets initial laws retained Another similarity work updates consist staticdynamic rules described language action description Additionally language 3 allows specify changes rules update assert construct For instance consider adding assertLight Up Toggle action description Then switch toggled rule Light Up remains inertially true truth possibly deleted However apart cumbersome language extensions handling frame problem EAPs provide means specify certain dynamic requirements update satisfy particular universal properties quantifying states main feature approach For instance setting Example 1 translating D I respective EAP represent update equivalent action description D I satisfy constraints C Since constraints expressed language additional analysis needed different I enforce required behavior asserted initial action identify update I description D cid5 The works Lifschitz 49 Balduccini Gelfond 6 similar 3 modify action scriptions respect new elaborations means adding causal laws sense additive elaboration tolerance 5255 Lifschitz describes 49 action domain language C causal law defeasible means abnormality predicate To formulate variations domain agent add new causal laws disable existing causal laws In 6 authors extend action description encoded logic program consistency restoring rules action description given observations incompatible rules applied consistent answer set This geared handling exceptions causal laws modiﬁed The approaches provide tools user enact updates defeating causal laws respectively applying consistency restoring rules different approach particular modiﬁcations characterized ﬁrst princi ples intended solutions update problem remains user While adding abnormality predicates 49 simple technique support preference constraints 6 geared diagnosis requires anticipate possible updates order encode priori solutions potential inconsistencies subsequent updates initial domain description design time support preferences consistency restoring rules limited cardinality based preferences diﬃcult represent Furthermore result updating action description action description adjustments iterated updates necessary Concerning results computational complexity Eiter Gottlob 23 study number syntaxbased modelbased knowledge base revision operators provide precise complexity characterizations problem checking given formula derivable revised updated knowledge base reducing problem evaluation counterfactuals Herzig 36 improved complexity bounds restricted settings Winsletts Possible Models Approach Liberatore 46 considers approaches belief update literature derived corresponding complexity results extended problem iterated update Baral Zhang 7 considers complexity model checking knowledge update As traditional belief update relation reasoning actions consists effects action update current state However motivated sensing actions change world Baral Zhang distinguish knowledge updates belief updates changes correspond alterations real world affect agents knowledge world They model theoretic account knowledge updates based modal logics complexity model checking second layer polynomial hierarchy identify tractable subclasses More closely related work investigations concerning complexity reasoning actions action language For action language A Liberatore 45 establishes instance NPcompleteness consistency checking coNPcompleteness entailment essentially amounts checking D cid6 ALWAYS necessarily holds F A1 An given action description D ﬂuent F sequence actions A1 An setting Lang et al 42 investigated computational complexity progression problem simple causal action theories constitute special case causal theories different languages particular capturing fragment action language C sidered Besides progression problem complexity reasoning tasks including executability determinism addressed framework extended socalled generalized action theories We remark like progression results obtained special cases deciding D cid6 c particular constraints c setting Moreover best knowledge complexity deciding constraint fulﬁllment addressed far apart PSPACE result general case constraint language considered proven 18 let problem updating action descriptions presence constraints T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1203 82 Nature change As stated problem description approach intended allow designed normative worlds represented means action descriptions changes considered updates revisions How brieﬂy mentioned Section 3 notion action update belief revision belief update ﬂavor This view supported deeper analysis change connection reasoning actions change 4158 Lang 41 describes scope revision update notices pointed 2728 scope simply decided theory static vs dynamic worlds Then pointed 1014 Lang lates revision update means backwardforward reasoning particular means action progression According 41 belief revision correct initial beliefs pastpresentfuture state world observations pastpresent state world On hand belief update formula α corresponds progressing theory speciﬁc feedbackfree action α true respect given update operator α observations In framework Lang says approach closer revision process update approach changes transition diagram action description meaningful consider update process However update revision behave problem technically different informally revision operators aim selecting models new information closest models knowledge base globally update opera tors change model knowledge base locally intuitively captured axiom U8 KM postulates As action description D unique associated model given T D methods yield result The main difference remaining behavior inconsistent action descriptions Revision consistent information inconsistent knowledge base consistent approach update preserve inconsistency Clearly method easily adapted behavior update ﬂavor The AGM KM postulates 239 based assumptions hold action language C One quirement met underlying formal language governed logic closed Boolean connectives Other requirements including superclassicality modus ponens deduction theorem essentially restrict formalisms underlying monotonic logic explicit restriction instance Hanssons work 33 How action language C nonmonotonic For instance D consists single law caused P P P single ﬂuent transition diagram described D T D states s1 P s2 P transitions cid7s1 s1cid8 cid7s2 s1cid8 Thus causal law caused P satisﬁed T D equivalently D cid6 ALWAYS necessarily holds P seen semantic consequence D However add caused P P D T D additional transitions cid7s1 s2cid8 cid7s2 s2cid8 D cid16cid6 ALWAYS necessarily holds P caused P longer semantic consequence The AGM framework similarly KM framework suitable nonmonotonic settings discussed nonmonotonic logic programming 20 defeasible logic 9 This conﬁrmed study KMstyle properties Section 4 nonmonotonicity turned reason properties fail Thus governing action description updates AGM KM postulates meaningful intuitively true postulates contraction developed monotonic settings We refrained formal investigation direction reason action language C closed complement precisely deﬁned clear complement action language represented As consequence constitute logic wellknown identities like Levi Identity classical belief change settings relate contraction expansion revision applied By counterexamples KM postulates given Section 4 clear results obtained general alternative deﬁnitions For instance consider initial action description D0 set straints C0 initial knowledge modiﬁed new information consists set causal laws D1 set constraints C1 considered hold sure solution Preference given solutions max imal sets original laws constraints wrt set inclusion resulting action description consistent satisﬁesin addition constraints C1also constraints C0 kept Note setting cid5cid5 amounts particular case D Dm D0 Co C1 C p C0 cid2C deﬁned D C p c C p D cid6 c action description D Note counterexamples inclusions strict D C p stated Section 4 counterexamples setting We remark properties require strongly minimizing cid2C case preference relation particular results computational complexity hold particular setting cid5 cid2C D cid5 D D iff D cid5 C p D cid5cid5 cid5cid5 An AGM respectively KMstyle theory nonmonotonic logics signiﬁcant attention knowledge missing We note 38 instance considers incorporation belief change ﬂuent calculus geared axiomatic treatment belief revision update satisfying AGM KM postulates respectively However underlying logic monotonic static knowledge subject change preference based ranking states Another notable work 26 considers revision rational preference orderings underly certain non monotonic consequence operators However order avoid shortcomings concerning general principles success 1204 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 minimality change impossible adhere general nonmonotonic setting restrictions imposed concerning knowledge bases conditionals akin laws setting admissible revision More closely related setting recent approach belief revision answerset programs 15 operator satisﬁes majority AGM postulates This achieved building strong underlying notion equivalence socalled strong equivalence respective monotonic formal characterization answerset programs called SEmodels applying wellknown techniques classical belief revision Applying similar methods action language C order come theoryrevision operator interesting subject future work Work Turner 63 SEmodels causal theories serve starting point However issues immediate need consideration For instance direct application Turners SEmodels laws C achieved static laws dynamic laws mainly interested revision Hence concept SEmodel adapted appropriately Note revision operator respectively update operator obtained way characterized semantic structures orthogonal aims article It clear resulting semantic structures syntactically represented achieved characterization SEmodels terms answerset programs 15 Even suitable representation means causal laws developed likely resulting action description change reminiscent original description discussions 17 comments work following subsection 83 Repair action descriptions We improve solutions presolutions ADU problem D I C cid2C considering slightly different version problem We view causal law completely wrong instance holds certain contexts Suppose I dynamic law form caused L cid5 A cid5 G cid5 cid5 cid5 L D describes transition diagram D replacing dynamic law 5 Dm propositional combination ﬂuents A literal G action We obtain action description D s cid5 caused L F H G caused L F H G cid5 cid5 cid5 cid5 D I C cid2C exists presolution D scid5 D s I C cid2C We presolution D subset particular subset preference solution D I C gives rise solution contains D C solutions D I C cid2C D s I C adhoc adaptation solution preference cid2C cid2s recovered ones D s I C cid2s C Therefore replacement method useful prevent complete removal laws given action description Furthermore solutions D s I C cid2s C correspond solutions original problem D I C cid2C viewed approximations solutions They particular original problem solution Similar methods useful repairing action description dynamic laws 5 action description missing formulas H In case need replace causal laws modiﬁed statements candidate space Our current framework generalized direction changing candidate solution space holds solution D cid5 candD I modiﬁable causal law cid10i D gives rise alternative candidate replacements candcid10i I candD I D cid15 n cid5 D u I set action descriptions candD I D u I D i1 D D candcid10i I hold D cid101 cid10n D u D cid5 cid5 We note repairing action descriptions 17 took slightly different semanticsoriented view resolving conﬂicts action description set constraints context action language C Conﬂicts character ized means states transitions transition diagram described given action description violate given constraints The goal resolve conﬂict modifying action description necessarily deleting causal laws However repair single conﬂict achieved numerous alternative changes action description candidate solution space large furthermore repairs individual conﬂicts interfere introduce conﬂicts This led authors 17 propose support user terms reasoning services action description given constraints provide explanations certain disorders automated repair respective tool methodology usage correct editorial errors knowledge represen tation process typos omitted formula parts described 2122 An interesting issue work analyze conditions repairs obtained solutions ADU problem generalized framework outlined 9 Conclusion In paper considered problem updating action description new information framework action languages knowledge domain terms observations constraints spected To end introduced formal notion action description update given action description D T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1205 new information I set statements desired constraints C expressed formulas action query language singles solution update problem based preference relation cid2C action descriptions We studied semantical computational properties action updates framework presented results decomposition results complexity characterizations basic decision problems associated computing solutions viz deciding solution existence solution recognition We considered complexity analysis generic settings particular instances paying attention different classes constraints preference relations Furthermore presented algorithms computing solutions presolutions approximate solutions discussed work context literature Several issues remain work Our computational results provide basis realization concrete imple mentations incorporate updates action descriptions action language C based existing reasoning systems like causal calculator 51 ADConstraint 21 important need deploying systems applications However practical concerns eﬃcient domaintailored algorithms need developed In connection meaningful fragments low polynomial complexity related study language fragments correspond simpler expressive action languages A B 30 However intractability results established involved simple action descriptions suggests polynomial complexity achieved pragmatic constraints logical structural conditions On hand richer expressive action languages language C disjunctive causal laws studied action language C 43 action language K 19 language considered maps naturally studied Further issues consider richer forms constraints generalized action query languages extend current computational study notions preference relations For example syntaxbased preference cardinality lexicographic ordering formula ranking possibly priority levels 811 semanticbased preference uses weight assignments like 18 computable polynomial space preference based state transitionrankings inspired approaches conditional reasoning 24 Another issue multiple updates The update descriptions presented provide useful basis real ization Markovian historyless updates I1 I2 Ik action description lazy evaluation similar update programs context logic program updates 520 realize nonMarkovian semantics sequence updates action description However remains explored investigation Finally regard connection AGM KM theory postulates properties tailored theories action nonmonotonic setting interesting Acknowledgements We like thank anonymous referees comments helped improve paper considerably This work supported Austrian Science Fund FWF grant P16536N04 European Commission IST pro gramme grants FET200137004 WASP IST200133123 CologNeT Vienna Science Technology Fund WWTF grant ICT08020 Appendix A Proofs Section 5 Theorem 4 Given action description D set C constraints deciding D cid6 C PSPACEcomplete general ii Θ P iii PNP k3complete k maximal nesting depth dynamic constraints C cid24 complete C involve dynamic constraints Proof Concerning result shown 18 We proceed proof ii iii Membership Wlog C contains single constraint c Let consider iii ﬁrst Then c conjunction clauses universal constraints following form ALWAYS Q ALWAYS Q Q conjunction clauses static constraints form holds F holds F Checking truth negated universal subconstraint form NP To nondeterministically guess possible state s D verify polynomial time s state D satisﬁes static laws D s satisfy Q clause Q static constraints satisﬁed s Hence complementary task checking truth positive universal constraint ALWAYS Q coNP Thus decide D cid6 c polynomial time single parallel evaluation n NPoracle calls given n number universal constraints c This proves PNP For ii constraint c conjunction clauses universal constraints form ALWAYS Q ALWAYS Q Q conjunction clauses static constraints dynamic constraints form necessarily Q k1 A1 An necessarily Q k1 A1 An Q k1 basic constraint nesting depth k 1 Let c1 c4 denote constraints form c1 ALWAYS Q c2 ALWAYS Q c3 ALWAYS Q c4 ALWAYS Q respectively We induction deciding D cid6 c Θ P cid24 membership k3 1206 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Base case k 0 For static Q iii deciding D cid6 ci PNP cid24 1 cid2 cid2 4 Hence let Q necessarily Q k1 A1 An dynamic constraint Deciding D cid6 c1 NP complementary problem D cid6 c2 coNP The problem decided nondeterministically guessing history h s0 A1 s1 sn1 An sn length n checking polynomial time h history D si 0 cid2 cid2 n state D cid7si Ai1 si1cid8 0 cid2 n R Furthermore D sn cid6 Q k1 checked polynomial time Q k1 propositional combination static constraints witnessing D cid16cid6 c1 Deciding D cid6 c3 Π P 2 To wit order disprove D cid6 c3 guess state s andas outlined aboveuse NPoracle verify histories h length n emanating s s0 s holds D sn cid6 Q k1 This establishes D s cid16cid6 Q D cid16cid6 c3 Putting order decide D cid6 c oracle Σ P 2 problems suﬃcient decide truth universal constraint c Thus D cid6 c checked polynomial time polynomial number parallel Σ P 2 oracle calls Θ P 3 Induction step Let nesting depth dynamic constraints k 0 assume deciding D cid6 Q k1 Θ P k2 subconstraint nesting depth k 1 Then easily seen arguments base case D cid6 I decided means Σ P k3 cid24 hard decision version Maximum CNF Satisﬁability Given Boolean formula F conjunctive normal form CNF integer k decide maximum number clauses F simultaneously satisﬁed interpretation 0 mod k k2oracle universal constraint Q c Thus parallel evaluation D cid6 c Θ P Hardness In order prove iii reduce problem following PNP 2 complementary problem D cid6 c4 Σ P Wlog let F 3CNF formula form i1 Li1 Li2 Li3 Li j 1 cid2 cid2 n 1 cid2 j cid2 3 literal atoms X X1 Xm For Xi X L denote Xi L Xi Xi L Xi Consider action description D1 consisting cid6 n cid7 caused Ci Li3 1 cid2 cid2 n caused Ci Li2 caused Ci Li1 caused Ci Li1 Li2 Li3 caused F 11 C1 caused F 10 C1 caused F j Ci F i1 j1 caused F j Ci F i1 j1 caused F j Ci F i1 j caused F j Ci F i1 j cid7 caused F 11 C1 caused F 10 C1 cid7 2 cid2 cid2 n 1 cid2 j cid2 2 cid2 cid2 n 0 cid2 j Observe D1 contains static laws A state s consistent D1 corresponds arbitrary total interpretation X total interpretation ﬂuents Ci 1 cid2 cid2 n Ci true s iff interpretation X satisﬁes clause Ci The enforced ﬁrst 4n laws D1 The remaining laws cause total interpretation ﬂuents F j 1 cid2 j cid2 cid2 n F j true s iff interpretation X satisﬁes j clauses C1 Ci Now consider following constraint ck ALWAYS holds Fn0 SOMETIMES holds Fnk ALWAYS holds Fnk1 holds Fnn SOMETIMES holds Fnlk ALWAYS holds Fnlk1 holds Fnn l cid30nkcid31 We maximum number clauses F simultaneously satisﬁed interpretation 0 mod k iff D1 cid6 ck Onlyif Suppose maximum number o clauses F simultaneously satisﬁed interpretation 0 mod k Consider o 0 ﬁrst Then clause F satisﬁable By construction F i0 holds 1 cid2 cid2 n state s D1 In particular Fn0 holds state ALWAYS holds Fn0 satisﬁed D1 D1 cid6 ck Now let o 0 Wlog o ak 1 cid2 cid2 l Then construction Fn j false o j cid2 n state s D1 Therefore D1 cid6 ALWAYS holds Fnak1 holds Fnn Also construction Fno true state corresponding assignment maximizes simultaneously satisﬁed clauses This implies D1 cid6 SOMETIMES holds Fnak Observing constraints constitute conjunct ck conclude D1 cid6 ck If Suppose D1 cid6 ck assume D1 cid6 ALWAYS holds Fn0 ﬁrst Then construction clause F satisﬁable maximum number o clauses F simultaneously satisﬁed interpretation 0 o 0 mod k Now let conjunct ck satisﬁed D1 1 cid2 cid2 l holds D1 cid6 SOMETIMES holds Fnak D1 cid6 ALWAYS holds Fnak1 holds Fnn Then state s Fnak true By construction means ak clauses F simultaneously satisﬁed Moreover Fn j false state s D1 j ak Again construction implies ak maximum number clauses F simultaneously satisﬁed Since ak 0 mod k proves claim T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1207 For hardness Case ii consider m quantiﬁed Boolean formulas form Φl Q 1 Xl n El 1 cid2 l cid2 m 1 Q 2 Xl j 1 cid2 j cid2 n 1 cid2 k l cid2 m pairwise disjunct sets Q 1 mod 2 Q X k propositional variables cid16 j k cid16 l El Boolean formula atoms Xl Xl n Φl 1 false Φl1 Φm false Deciding maximum index o 1 cid2 o cid2 m Φo true odd Θ P n1hard We reduce problem deciding D cid6 c constraint c nesting depth k dynamic constraints problem Xl Xl Q n Xl 2 follows Let n k 2 1 cid2 l cid2 m let D2 action description consisting statements cid7 caused F l caused F l caused F l caused F l Ai1 Ai1 F l F l j Ai1 F l j j Ai1 F l j 2 cid2 cid2 n F l Xl cid8 2 cid2 cid2 n 1 cid2 j cid2 n cid16 j F l j Xl j Observe state s D2 corresponds arbitrary consistent total interpretation X 1 Xm Note cid5cid8 1 cid2 cid2 n 1 transition transition diagram described D2 iff ﬂuents interpreted identically cid7s Ai s X 1 Xm i1 i1 Consider constraint cid9 cid10 cid10 m32 l0 m22 l0 SOMETIMES f 2l1 ALWAYS f 2l2 gm m odd SOMETIMES f 2l1 ALWAYS f 2l2 gm SOMETIMES f m f l p1 N p1 cid2 cid2 pn1 N pn1 holds Elafter An1 cid3 cid3 A1 N necessarily pi pi void 1 cid2 cid2 n 1 Xl Xl n turn assignment Xl 1 We ﬁrst prove Φl true iff exists state s D2 D2 s cid6 f l For onlyif direction suppose Φl true We recursive argument state s0 coincides 1 D2 s0 cid6 f l Assume sn2 state D2 coincides satisfying truth assignment Φl Xl n1 We D2 sn2 cid6 pn1 N pn1 holds El An1 If Xl satisfying truth assignment Φl Xl 1 n 1 odd Q n Thus assignment Xl n1 given sn2 satisfying assignment El Thus transition An1 sn2 lead state sn1 satisﬁes El This proves D2 sn2 cid6 necessarily holds El An1 n 1 odd So let n 1 Then Q n In n assignment Xl case exists assignment Xl n1 given sn2 sat 1 isfying assignment El Thus transition An1 sn2 state sn1 satisﬁes El Therefore D2 sn2 cid6 necessarily holds El An1 n 1 In case D2 sn2 cid6 pn1 N holds pn1 El An1 Applying argument recursively proves claim state s0 coincides satisfying truth assignment Φl 1 D2 s0 cid6 f l exists state D2 D2 s cid6 f l Xl For ifdirection let s state D2 D2 s cid6 f l We establish truth Φl recursively follows Let h s A1 s1 sn3 An2 sn2 history D2 We sn2 state D2 coincides truth n1 Q n El true If n 1 odd D2 sn2 cid6 necessarily holds El An1 Xl assignment Xl 1 D2 s cid6 f l Thus assignment Xl n turn assignment Xl n1 given sn2 satisfying 1 assignment El If n 1 D2 sn2 cid6 necessarily holds El An1 D2 s cid6 f l Therefore exists assignment Xl n1 given sn2 satisfying assignment El Hence case Q n El true Applying argument recursively proves claim D2 s cid6 f l implies truth Φl n turn assignment Xl 1 We maximum index o Φo true odd iff D2 cid6 Onlyif Let maximum index o Φo true odd Consider state s D2 D2 s cid6 f o If o m D2 Hence D2 cid6 SOMETIMES f o proves D2 cid6 So let o m Then additionally D2 s cid16cid6 f o1 state s D2 cid6 ALWAYS f o1 l o 12 D2 cid6 SOMETIMES f 2l1 ALWAYS f 2l2 This proves D2 cid6 If Assume D2 cid6 If m odd D2 cid6 gm Then m maximum index o Φo true o odd This proves claim So consider remaining cases index l 0 cid2 l cid2 m 32 m odd 0 cid2 l cid2 m 22 D2 cid6 SOMETIMES f 2l1 ALWAYS f 2l2 Then state s D2 f 2l1 satisﬁed f 2l2 satisﬁed state s D2 Let o 2l 1 We conclude Φo true Φo1 false Thus o maximum index Φo true odd This proves claim Θ P k3 hardness cid3 n1hardness Θ P Xl Xl cid5 cid5 1208 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Theorem 5 Deciding given ADU problem D I C cid2C solution presolution PSPACEcomplete general ii Σ P iii Σ P iv NPcomplete Co k3complete k maximal nesting depth dynamic constraints Co 2 complete Co involve dynamic constraints Proof Membership Follows Theorems 3 4 Hardness Hardness Case follows Theorem 4 For ii let n k 2 let Φ Y Q 1 X1 Q n Xn E QBF Q 0 mod 2 Q Consider D u D2 caused Y Ai1 Y caused Y Ai1 Y 2 cid2 cid2 n D2 action description proof Theorem 4 l 1 Dm caused Y caused Y Y Y I C Co C p C p Co ALWAYS p1 N p1 pn1 N pn1 holds E An1 A1 cid2 cid2 cid3 cid3 N necessarily pi odd void 1 cid2 cid2 n 1 We exists solution action description update problem D u Dm I C cid2C iff Φ true For onlyif direction let D u D coincide interpretation Y arbitrary interpretation X1 Xn By arguments hardness proof Theorem 4ii fact D cid5 cid6 Co witnesses truth Φ For ifdirection let Φ true Consider satisfying truth assignment Y let D consistent states D cid5 D u Dm solution Then D cid5 cid5 cid5 D u D cid5 m Then D cid5 consistent D u D cid5 cid6 Co This proves D cid5 m set static causal laws cid5 D u Dm Moreover presolution cid5 Dm compliant assignment let D arguments hardness proof Theorem 4ii D existence solution For iii let Φ Y X E consider action description update problem D u Dm I C cid2C D u Dm caused Y caused Y Y Y I C Co ALWAYS holds E We prove action description update problem D u Dm I C cid2C solution iff Φ true For onlyif direction let D u D coincide cid5 cid6 Co E true state witnessing interpretation Y arbitrary interpretation X Since D truth assignment X turns joint assignment Y X satisfying assignment E This proves truth Φ consistent states D cid5 Dm solution Then D cid5 cid5 For ifdirection let Φ true Consider satisfying truth assignment Y let D set static causal laws cid5 Dm Moreover Φ true truth Dm compliant assignment Then D assignment X turns joint assignment Y X satisfying assignment E Therefore E holds states D presolution existence solution consistent D u D cid5 cid6 Co This proves D witnessing D Finally iv let E Boolean formula atoms Y let deﬁne D u caused Y 1 E caused Y 1 E Dm caused Y caused Y Y Y I C Then D u Dm I C cid2C solution iff E satisﬁable cid5 cid5 cid5 For onlyif direction let D u D cid5 D u Dm solution Then D cid5 consistent states D coincide cid5 cid5 interpretation Y Since D u D cid5 E true state This proves satisﬁability E For ifdirection let E satisﬁable Consider satisfying truth assignment Y let D laws Dm compliant assignment Then D cid5 trivially This proves D presolution existence solution cid3 cid5 D u D cid5 m consistent D u D cid5 m set static causal cid5 cid6 Co cid5 D u Dm Moreover D Theorem 6 Given ADU problem D I C action description D cid5 deciding D cid5 solution PSPACEcomplete general constraints Co ii Π P iii Π P iv DP complete Co k3complete k maximal nesting depth dynamic constraints Co 2 complete Co involve dynamic constraints Proof Membership Follows Theorem 3 observing given action descriptions D polynomial time Pcheck P Hardness Hardness Case follows Theorem 4 For ii let n k 2 let Φ Y Q 1 X1 Q n Xn E QBF cid5 cid5cid5 D deciding D cid5 D cid5cid5 Q 1 mod 2 Q Consider D u D2 caused Y Ai1 Y caused Y Ai1 Y 2 cid2 cid2 n D2 action description proof Theorem 4 l 1 Dm caused Y caused Y Y Y I C Co ALWAYS f g T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1209 cid2 cid2 pn1 N pn1 holds E An1 cid3 cid3 A1 f p1 N p1 cid4 g SOMETIMES holds Y SOMETIMES holds Y Y Y N necessarily pi odd void 1 cid2 cid2 n 1 pn 1 n odd void We D u solution action description update problem D u Dm I C iff Φ true Obviously D u consistent I D u Additionally states D u consist arbitrary truth assignments Y X1 Xn Therefore D u satisﬁes g D u cid6 Co This proves D u presolution We maximum presolution iff Φ true For onlyif direction contradiction assume Φ false Then Φ true Observe Φ QBF form considered hardness proof Theorem 5ii E negated Applying arguments proof obtain exists set D u D Note pn1 accounts negation E Therefore D presolution This contradicts maximality D u cid5 cid5 cid6 Co D cid5 D u Dm D state s D consistent D cid5 s cid6 f cid5 cid5 f For ifdirection contradiction assume D u maximal Then states maximum solution coincide assignment Y Y satisfy g Consequently satisﬁed states maximum solution Applying arguments hardness proof Theorem 5ii conclude Φ true contradiction For iii let Φ Y X E consider action description update problem D u Dm I C D u Dm caused Y caused Y Y Y I C Co ALWAYS holds E g g We prove action description update problem D u Dm I C D u solution iff Φ true Obviously D u consistent I D u Additionally states D u consist arbitrary truth assignments Y X Therefore D u satisﬁes g D u cid6 Co This proves D u presolution We maximum pre solution iff Φ true For onlyif direction contradiction assume Φ false Then Φ true Observe Φ QBF form considered hardness proof Theorem 5iii E negated Applying arguments proof cid5 cid6 Co Therefore obtain exists set D u D D presolution contradicts maximality D u For ifdirection contradiction assume D u maximal Then states maximum solution coincide assignment Y Y satisfy g Consequently maximum solution satisfy ALWAYS holds E Applying arguments hardness proof Theorem 5iii conclude Φ true contradiction cid5 cid6 ALWAYS holds E D cid5 Dm D consistent D Finally iv let E1 E2 Boolean formulas atoms Y 1 Y 2 respectively Consider D u caused F caused F E1 Dm caused F E2 I C Then D u Dm I C solution D u iff E1 satisﬁable E2 unsatisﬁable cid5 cid5 Obviously I D u D u cid6 Co Therefore D u solution iff consistent maximal superset D u consistent We conditions hold iff E 1 satisﬁable E2 unsatisﬁable For onlyif direction assume D u consistent maximal Then E1 satisﬁable witnessed truth assignment Y 1 state D u Furthermore D u Dm inconsistent solution trivially satisﬁes Co implies E2 unsatisﬁable For ifdirection let E1 satisﬁable E2 unsatisﬁable Then satisfying assignment ﬂuents Y 1 assigning falsity F truth assignment ﬂuents Y 2 yields state D u witnessing consistency Moreover D u Dm inconsistent unsatisﬁability E 2 implies D u maximal This proves DP hardness cid3 Theorem 7 Given ADU problem D I C weightq action description D cid5 deciding D cid5 solution PSPACEcomplete general constraints C ii Π P iii Π P iv NPcomplete C k3complete k maximal nesting depth dynamic constraints C 2 complete C involve dynamic constraints Proof Membership For ii iii membership follows Theorems 3 4 Note order decide D2 action descriptions D1 D2 D u I D D I 1 2 set weighted D1 weightq constraints C p decide D cid6 c c C p polynomially sum corresponding weights polynomial time Thus D cid6 c decided polynomial space respectively polynomial time help For iv C Pcheck trivial weightq Σ P In case decide D polyno cid5 D I polynomial time This proves mial time witnessing consistency additionally checking D u I D NPmembership iv i1oracle Pcheck PSPACE respectively cid5P solution guessing state s checking state D weightq D cid5 cid5 cid5 1210 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 cid5 cid5 Hardness Hardness Case follows easily Theorem 4 For ii let n k 2 consider Φ D u Dm I Co proof Theorem 6ii Additionally let C p ALWAYS holds Y ALWAYS holds Y Y Y consider cid5 D u Dm weightqD u 0 states weight 1 c C p Then D u weightq coincide assignment Y Y making constraints C p true D cid5 cid3 1 Therefore D u solution D u Dm I Co C p weightq iff solution D u Dm I Co weightqD proves Π P k3hardness cf Theorem 6ii Y Y weight 1 c C p Then reason D u weightq Therefore D u solution D u Dm I Co C p weightq iff solution D u Dm I Co proving Π P For iii consider Φ D I Co proof Theorem 6ii Again let C p ALWAYS holds Y ALWAYS holds Y cid5 D u Dm 2 hardness Finally iv let E Boolean formula atoms Y consider ADU problem given D u caused Y 1 E D u D D u D D D caused Y 1 E Dm I C Then D u solution D u Dm I C weightq iff E satisﬁable cid5 For onlyif direction let D u solution Then D u consistent states D u coincide interpretation Y E true state This proves satisﬁability E For ifdirection let E satisﬁable A satisfying truth assignment Y state D u D u consistent Moreover D u I D u D I D u cid6 Co trivially And D u I D u D I conclude D u solution cid3 Appendix B Proofs Section 6 Prior proof Proposition 4 establish following lemma pinpoints relation states obtained arbitrary selection modiﬁable laws transitions update description U action description D cid5 Lemma 3 Let D D u Dm action description let D D diagram described U Let M subset H labeling laws D cid5 m subset Dm Let cid7S V Rcid8 transition diagram described cid5 m Let U U D update description D set H update ﬂuents let cid7S U V U R U cid8 transition cid5 D u D cid5 m Then following hold s H S iff s S U s H M cid5cid8 R U iff s H s ii cid7s A s iii cid7s H A s cid5 Hcid8 R iff cid7s A s cid5 cid5cid8 R U s H M Proof For onlyif direction consider state s S By deﬁnition transition diagram described action description static law 4 D s satisﬁes G L cid5 Case 1 Take static law 4 U contain H H By deﬁnition update description static law D u Then s satisﬁes G L s M satisﬁes G L Case 2 Take static law 15 U H M By deﬁnition update description corresponding static law 4 D cid5 m Then s satisﬁes G L s M satisﬁes G H L Case 3 Take static law 15 U H M Since s M satisfy G H s M satisﬁes G H L By deﬁnition update description U contain static laws Therefore cases follows s M state S U For ifdirection consider state s S U s H M By deﬁnition transition diagram described action description static law 4 U s satisﬁes G L Case 1 Take static law 4 D u By deﬁnition update description U contain element H Therefore s H satisﬁes G L cid5 Case 2 Take static law 4 D m static law 15 U Since corresponding static law 15 U s satisﬁes G H L assumption H s s H satisﬁes G L cid5 m By deﬁnition update description static law 4 D From cases follows static law 4 D ii Since element H appears head causal law U inertia laws 17 conclude s H satisﬁes G L Thus s H S cid5 cid7s A s cid5cid8 R U iff s H s cid5 iii For onlyif direction consider cid7s A s description dynamic law 5 D satisﬁes G Due s M s cid5 s cid5 cid5 M S U cid5cid8 R By deﬁnition transition diagram described action cid5 cid5cid8 s A satisﬁes H s satisﬁes L law applicable cid7s A s T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1211 Fig 8 The Zoo World animals Case 1 Consider dynamic law 5 U contain H H Suppose applicable cid7s M A s Mcid8 Then H H occurs law applicable cid7s A s cid5cid8 R s law D u Since cid7s A s cid5 cid5cid8 By deﬁnition update description cid5 M satisﬁes L satisﬁes L Then s cid5 Case 2 Consider dynamic law 16 U form 17 H labels dynamic law 5 D H M Suppose applicable cid7s M A s contain H H s A satisﬁes H G contain H H s dynamic law 5 D cid5 Mcid8 That s M A satisﬁes H H s cid5 m cid5 M satisﬁes G Since H satisﬁes G Then corresponding cid5 M satisﬁes L cid5cid8 Since cid7s A s satisﬁes L Then s cid5cid8 R s cid5 m applicable cid7s A s cid5 cid5 1212 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Fig 9 The Zoo World movement Case 3 Consider dynamic law 17 U By ii conclude cid7s A s cid5 M satisﬁes H Therefore law applicable cid7s M A s s Consequently M interpretation H satisfying heads applicable inertia laws cid5 Hence s M satisﬁes H iff cid5 Mcid8 iff L H H M L H H M cid5cid8 R U iff s H s By deﬁnition update description U contain dynamic laws applicable cid7s M A s So far shown cid7s A s cid5cid8 R s cid5 Mcid8 Moreover observe b dynamic law D cid5 M satisﬁes heads dynamic law U cid5cid8 cid5 cid5 Mcid8 c inertia laws 17 U contain applicable cid7s A s cid5 Mcid8 applicable cid7s M A s corresponding law U applicable cid7s M A s dynamic laws applicable cid7s M A s cid5 cid5 Mcid8 Since know s interpretation satisfying heads dynamic laws D cid5cid8 cid5 M interpretation satisfying heads dynamic laws U applicable cid7s A s cid5 follows ac Case 3 s applicable cid7s M A s cid5 Mcid8 Therefore cid7s M A s cid5 Mcid8 R U For ifdirection consider cid7s A s cid5 H M Due s H s By deﬁnition transition diagram described action description dynamic law 5 U s law applicable cid7s A s cid5cid8 s A satisﬁes H s cid5cid8 R U s H s satisﬁes G cid5 H S cid5 satisﬁes L cid5 Suppose applicable cid7s H A s cid5 cid5 Hcid8 That s H A satisﬁes H Consider dynamic law 5 D cid5 H satisﬁes G s Case 1 This law D u Since G H contain element H s A satisﬁes H s law 5 applicable cid7s A s R U s satisﬁes L Since L contain element H s cid5cid8 By deﬁnition update description law U Since cid7s A s satisﬁes G cid5cid8 cid5 H satisﬁes L cid5 cid5 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1213 Fig 10 The Zoo World actions 1 Case 2 This law D By deﬁnition update description corresponding law 16 U applicable cid7s A s cid7s A s cid5 m Since s contains element H H labeling dynamic law D satisﬁes L Since L contain element H s cid5 m s A satisﬁes H H cid5cid8 Since cid5 H satisﬁes L cid5cid8 R U s cid5 So far shown cid7s A s cid5 H satisﬁes heads dynamic law D cid5 Hcid8 Moreover observe b dynamic law U applicable cid7s A s cid5cid8 R U s applicable cid7s H A s inertia laws 17 corresponding law D dynamic laws applicable cid7s H A s cid5 Hcid8 cid5 applicable cid7s H A s cid5 Hcid8 c D cid5 cid5 cid5cid8 contain Since know s follows ac s cid7s H A s cid5 Hcid8 Therefore cid7s H A s cid5 Hcid8 R cid3 cid5 interpretation satisfying heads dynamic laws U applicable cid7s A s cid5 H interpretation satisfying heads dynamic laws D cid5 cid5cid8 applicable Proposition 4 Let D I C cid2C ADU problem D D u Dm Let U update description D I D u I Dm cid5 D u I W presolution let W denote subset Dm containing laws labeled elements M H U Then D D I C cid2C iff M update set U relative Co Proof Let D I C cid2C ADU problem D D u Dm Let U update description D I D u I Dm set H update ﬂuents describing transition diagram T U cid7S U V U R U cid8 Let W subset Dm containing laws labeled M H U Let T cid7S V Rcid8 transition diagram described D presolution D I C cid2C iff M update set U relative Co cid5 D u I W We D cid5 For ifdirection suppose M update set U relative Co We D cid2C deﬁnition solution hold cid5 presolution D I C Since s H M state s S U Lemma 3i S Therefore D D u I D ii It follows deﬁnition D iii For state s S observe Lemma 3i s M S U cid5 D I cid5 cid5 consistent 1214 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Fig 11 The Zoo World actions 2 We static dynamic constraint c state s S U s M cid6 c implies D cid5 s cid6 c Towards cid5 s cid16cid6 c consider static constraint c ﬁrst Since element H appears c contradiction assume U s M cid6 c D constraint static s M cid16cid6 c follows However contradicts assumption So let c dynamic constraint cid5 sn cid16cid6 Q We continue induction nesting depth k c If k 0 h history 11 T s0 s D Q static constraint element H appears c follows sn M cid16cid6 Q Moreover Lemma 3iii hU s0 M A0 s1 M sn1 M An sn M history T U Thus conclude U s M cid16cid6 c contradiction So let assume claim holds dynamic constraints maximum nesting depth k 1 consider dynamic constraint nesting depth k Then Q contains static cid5 sn cid16cid6 Q implies U sn M cid16cid6 Q constraints dynamic constraints nesting depth k 1 By hypothesis D Furthermore Lemma 3iii history hU corresponding h history T U Thus conclude U s M cid16cid6 c cid5 s cid6 c s S static dynamic constraint c contradiction This proves U s M cid6 c implies D open constraint c We continue considering existential universal constraints c We c holds s M wrt S U HsM cid5 cid6 c For existentially quantiﬁed open constraint Q claim follows fact deﬁnition c holds cid5 H state cid5 cid6 c So let c cid5 S U exists U s cid5 cid6 Q fact Q open follows D cid5 H s By Lemma 3i conclude s HsM s Moreover U s D s M wrt S U D cid5 H cid6 Q D cid5 cid6 Q s cid5 s cid5 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1215 Fig 12 The Zoo World actions 3 cid5 D cid5 s cid5 cid16cid6 Q Note Lemma 3i s cid5 s cid5 cid6 Q follows contradiction assumption However U s universally quantiﬁed open constraint Q contradiction assume D cid5 M cid16cid6 Q D cid5 M cid16cid6 Q contradicts c D cid5 cid6 c existential universal holds s M wrt S U constraint c follows Boolean combination existential universal constraints This proves c holds s M wrt S U cid5 M S U Moreover Q open conclude U s HsM Therefore c holds s M wrt S U cid5 cid6 c constraint c HsM D cid5 cid16cid6 c Then exists state s cid5 HsM D Finally D cid5 cid6 Co Consider arbitrary s S exists D cid5 cid5 cid6 c c Co This proves D This means deﬁnition c holds s wrt S U cid5 cid6 Co presolution D I C cid2C We M update set U relative Co consistent Then Hs c Co As Condition ii update ﬂuent sets s M S U Co shown implies D For onlyif direction let D cid5 s H M s S U ii S U Hs S U Co consistent exists state s S Furthermore Lemma 3i conclude s M S U cid5 Since D state s 1216 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Fig 13 The Zoo World actions 4 Fig 14 The sample constraint given Section 71 updating Zoo World little Circus expressed query CCalc T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1217 Fig 15 The constraint Fig 14 modiﬁed adding constraints described Section 71 Fig 16 A possible scenario shows constraint Fig 15 satisﬁed Zoo World Zoo World updated little Circus remove causal laws labeled aux2bart homer jumbo aux3bart homer jumbo ii We ﬁrst static dynamic constraint c state s S D cid5 s cid6 c implies U s M cid6 c Towards cid5 s cid6 c U s M cid16cid6 c consider static constraint c ﬁrst Since element H appears contradiction assume D cid5 s cid6 c So let c dynamic c constraint static s cid16cid6 c follows However contradicts assumption D constraint hU history 11 T U s0 s M U sn cid16cid6 Q We continue induction nesting depth k c If k 0 Q static constraint element H appears c follows sn H cid16cid6 Q Furthermore Lemma 3ii si H s0 1 cid2 cid2 n Therefore Lemma 3iii h s0 H A0 s1 H sn1 H An sn H cid5 s cid16cid6 c contradiction So let assume claim holds dynamic constraints history T Thus conclude D maximum nesting depth k 1 consider dynamic constraint nesting depth k Then Q contains static constraints cid5 sn H cid16cid6 Q Furthermore dynamic constraints nesting depth k 1 By hypothesis U sn cid16cid6 Q implies D cid5 s cid16cid6 c contradiction Lemma 3ii iii history h corresponding hU history T Thus conclude D 1218 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 Fig 17 Monkeys exchanging hats Fig 18 The sample constraint check Snoopy Abu exchange hats Fig 19 The sample constraint check Snoopy Abu exchange hats remove causal laws labeled aux4 description Fig 17 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1219 Fig 20 A possible scenario sample constraint check Snoopy Abu exchange hats satisﬁed description Fig 17 remove causal laws labeled aux4 This proves D constraint c cid5 s cid6 c implies U s M cid6 c s S static dynamic constraint c open D cid5 S D cid5 M cid6 Q Moreover s cid5 cid6 c implies c holds s wrt S U We continue considering existential universal constraints c Let s state S U s H M We Hs For existentially quantiﬁed open constraint Q claim follows cid5 M state S U Q open Hs deﬁnition So let c universally Hs Then exists cid5 s cid16cid6 Q follows However Q open D Hs existential universal constraint c cid5 cid6 c implies c fact exists state s follows U s quantiﬁed open constraint Q contradiction assume c hold s wrt S U cid5 M state D cid5 S U s cid5 cid6 c c holds s wrt S U contradicts D follows Boolean combination existential universal constraints This proves D holds s wrt S U cid5 M H s c holds s wrt S U cid5 cid16cid6 Q By Lemma 3i s cid5 cid6 Q By Lemma 3i s cid5 cid6 c Therefore D Hs U s cid5 s cid5 Hs Therefore given D cid5 presolution D cid5 cid6 Co conclude S U Hs S U Co cid3 Appendix C The Zoo World C The Zoo World described action language C presented language CCalc 1 ﬁve parts animals zooanimals movement zoomovement actions zooactions landscape zoolandscape union zoo We transformed ﬁrst components C language CCalc well12 shown Figs 813 replacing nonBoolean ﬂuents form posAnimal Position Boolean ﬂuents posAnimalPosition adding causal laws sure express ﬂuent13 constraint P posANML P caused posANMLP posANML P1 P P1 The ﬁrst forms causal laws Fig 13 constitute modiﬁable Dm description The sample constraint given Section 71 represented CCalc query given Fig 14 Appendix D Exchanging hats Circus Consider Circus world including monkeys dogs monkeys exchange hats We obtain C description world C description missionaries cannibals exchanging hats 50 present CCalc Fig 17 Now consider variation Zoo World described Section 71 involves monkeys dogs monkeys exchange hats This variation Zoo World described union Zoo World description D1 discussed Section 71 Figs 813 description D0 mentioned Fig 17 Suppose like update action description D0 D1 extended Zoo World obtain description Circus humans mount mount large animal animals exchange hats Assume modiﬁable D1 m D1 Section 71 modiﬁable m D0 consists causal law Fig 17 The sample constraint given Section 72 represented D0 CCalc query Fig 18 See Figs 19 20 12 The input language CCalc explained manual httpwwwcsutexaseduuserstagcc examples 13 In CCalc expression form constraint G called constraint shorthand causal law caused False G 1220 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 References 1 V Akman ST Erdogan J Lee V Lifschitz H Turner Representing zoo world traﬃc world language causal calculator Artiﬁcial Intelligence 153 12 2004 105140 2 C Alchourrón P Gärdenfors D Makinson On logic theory change Partial meet contraction revision functions Journal Symbolic Logic 50 1985 510530 3 JJ Alferes F Banti A Brogi From logic programs updates action description updates Proc CLIMA V revised selected invited papers Lecture Notes Computer Science vol 3487 Springer 2004 pp 5277 4 JJ Alferes A Brogi JA Leite LM Pereira Evolving logic programs Proc JELIA02 2002 pp 5061 5 JJ Alferes JA Leite LM Pereira H Przymusinska TC Przymusinski Dynamic updates nonmonotonic knowledge bases Journal Logic Program ming 45 13 2000 4370 6 M Balduccini M Gelfond Logic programs consistencyrestoring rules International Symposium Logical Formalization Commonsense Reasoning AAAI 2003 Spring Symposium Series 2003 pp 918 7 C Baral Y Zhang Knowledge updates Semantics complexity issues Artiﬁcial Intelligence 164 12 2005 209243 8 S Benferhat C Cayrol D Dubois J Lang H Prade Inconsistency management prioritized syntaxbased entailment Proc IJCAI93 1993 pp 640647 9 D Billington G Antoniou G Governatori MJ Maher Revising nonmonotonic theories The case defeasible logic Proc German National Confer ence Artiﬁcial Intelligence KI99 1999 pp 101112 10 C Boutilier A uniﬁed model qualitative belief change A dynamical systems perspective Artiﬁcial Intelligence 98 12 1998 281316 11 C Cayrol MC LagasquieSchiex T Schiex Nonmonotonic reasoning From complexity algorithms Annals Mathematics Artiﬁcial Intelli gence 22 34 1998 207236 12 J Chomicki R van der Meyden G Saake Logics Emerging Applications Databases SpringerVerlag 2003 13 R Dechter A Itai Finding solutions ﬁnd Technical Report ICSTR9261 University California Riverside September 1992 14 A del Val Y Shoham A uniﬁed view belief revision update Journal Logic Computation 4 5 1994 797810 15 JP Delgrande T Schaub H Tompits S Woltran Merging logic programs answer set semantics PM Hill DS Warren Eds ICLP Lecture Notes Computer Science vol 5649 Springer 2009 pp 160174 16 T Eiter E Erdem M Fink J Senko Updating action domain descriptions Proc IJCAI05 2005 pp 418423 17 T Eiter E Erdem M Fink J Senko Resolving conﬂicts action descriptions Proc ECAI06 2006 pp 424433 18 T Eiter E Erdem M Fink J Senko Comparing action descriptions based semantic preferences Annals Mathematics Artiﬁcial Intelli gence 50 34 2007 273304 19 T Eiter W Faber N Leone G Pfeifer A Polleres A logic programming approach knowledgestate planning Semantics complexity ACM Transactions Computational Logic 5 2 2004 206263 20 T Eiter M Fink G Sabbatini H Tompits On properties update sequences based causal rejection Theory Practice Logic Programming 2 6 2002 721777 21 T Eiter M Fink J Senko A tool answering queries action descriptions Proc JELIA06 Lecture Notes Computer Science vol 4160 Springer 2006 pp 473476 22 T Eiter M Fink J Senko Error classiﬁcation action descriptions A heuristic approach Proc AAAI08 AAAI Press 2008 pp 905910 23 T Eiter G Gottlob On complexity propositional knowledge base revision updates counterfactuals Artiﬁcial Intelligence 57 23 1992 227270 24 T Eiter T Lukasiewicz Default reasoning conditional knowledge bases Complexity tractable cases Artiﬁcial Intelligence 124 2 2000 169241 25 EA Emerson Temporal modal logic J van Leeuwen Ed Handbook Theoretical Computer Science Volume B Formal Models Seman tics B Elsevier 1990 pp 9951072 26 M Freund On revision preferences rational inference processes Artiﬁcial Intelligence 152 1 2004 105137 27 N Friedman JY Halpern Belief revision A critique Journal Logic Language Information 8 4 1999 401420 28 N Friedman JY Halpern Modeling belief dynamic systems II Revision update Journal Artiﬁcial Intelligence Research 10 1999 117 167 29 M Gelfond V Lifschitz The stable model semantics logic programming Proc International Conference Symposium Logic Programming ICLPSLP 1988 pp 10701080 30 M Gelfond V Lifschitz Action languages Electronic Transactions Artiﬁcial Intelligence 3 1998 195210 31 E Giunchiglia J Lee V Lifschitz N McCain H Turner Nonmonotonic causal theories Artiﬁcial Intelligence 153 12 2004 49104 32 E Giunchiglia V Lifschitz An action language based causal explanation Preliminary report Proc AAAI98 1998 pp 623630 33 SO Hansson Knowledgelevel analysis belief base operations Artiﬁcial Intelligence 82 12 1996 215235 34 SO Hansson A Textbook Belief Dynamics Theory Change Database Updating Applied Logic Kluwer 1999 35 D Harel D Kozen J Tiuryn Dynamic logic Handbook Philosophical Logic MIT Press 1984 pp 497604 36 A Herzig The PMA revisited Proc KR96 1996 pp 4050 37 A Herzig L Perrussel IJ Varzinczak Elaborating domain descriptions Proc ECAI06 2006 pp 397401 38 Y Jin M Thielscher Representing beliefs ﬂuent calculus Proc ECAI04 2004 pp 823827 39 H Katsuno AO Mendelzon On difference updating knowledge base revising Proc KR91 1991 pp 387394 40 M Krentel The complexity optimization problems Journal Computer System Sciences 36 1988 490509 41 J Lang Belief update revisited Proc IJCAI07 2007 pp 25172522 42 J Lang F Lin P Marquis Causal theories action A computational core Proc IJCAI03 2003 pp 10731078 43 J Lee V Lifschitz Describing additive ﬂuents action language C Proc IJCAI03 2003 pp 10791084 44 R Li LM Pereira What believed explained Proc AAAI96 1996 pp 550555 45 P Liberatore The complexity language A Electronic Transactions Artiﬁcial Intelligence 1 1997 1338 46 P Liberatore The complexity belief update Artiﬁcial Intelligence 119 12 2000 141190 47 P Liberatore A framework belief update Proc JELIA00 2000 pp 361375 48 V Lifschitz Answer set planning DD Schreye Ed Proceedings 16th International Conference Logic Programming ICLP99 Las Cruces New Mexico USA The MIT Press 1999 pp 2337 49 V Lifschitz Missionaries cannibals causal calculator Proc KR00 2000 pp 8596 50 V Lifschitz W Ren Irrelevant actions plan generation extended abstract Proc Ninth IberoAmerican Workshops Artiﬁcial Intelligence IBERAMIA 2004 2004 pp 7178 51 N McCain H Turner Satisﬁability planning causal theories Proc KR98 Morgan Kaufmann 1998 pp 212223 52 J McCarthy Elaboration tolerance Proc 1998 Symposium Logical Formalizations Commonsense Reasoning CommonSense 98 London January 79 1998 pp 198216 Available wwwidaliuseextetainjfcs98198paperps accessed June 3 2010 T Eiter et al Artiﬁcial Intelligence 174 2010 11721221 1221 53 C Papadimitriou Computational Complexity AddisonWesley 1994 54 R Parikh Beliefs belief revision splitting languages Journal Logic Language Information 2 1999 266278 55 A Parmar Formalizing elaboration tolerance Dissertation Department Computer Science Stanford University August 2003 56 P Peppas Belief change reasoning action axiomatic approach modelling dynamic worlds connection logic theory change Dissertation Basser Department Computer Science University Sydney 1993 57 P Peppas Belief revision F van Harmelen V Lifschitz B Porter Eds Handbook Logic Artiﬁcial Intelligence Logic Programming Elsevier 2008 pp 317360 Chapter 8 58 P Peppas AC Nayak M Pagnucco NY Foo RBH Kwok M Prokopenko Revision vs update Taking closer look Proc ECAI96 1996 pp 9599 59 AS Rao NY Foo Minimal change maximal coherence A basis belief revision reasoning actions Proc IJCAI89 1989 pp 966 971 60 R Reiter Knowledge Action Logical Foundations Specifying Implementing Dynamical Systems MIT Press 2001 61 C Sakama K Inoue An abductive framework computing knowledge base updates Theory Practice Logic Programming 3 6 2003 671713 62 S Shapiro M Pagnucco Y Lespérance HJ Levesque Iterated belief change situation calculus Proc KR00 2000 pp 527538 63 H Turner Strong equivalence causal theories V Lifschitz I Niemelä Eds LPNMR Lecture Notes Computer Science vol 2923 Springer 2004 pp 289301 64 F van Harmelen V Lifschitz B Porter Handbook Logic Artiﬁcial Intelligence Logic Programming Elsevier 2008 65 K Wagner Bounded query classes SIAM Journal Computing 19 5 1990 833846 66 M Winslett Reasoning actions possible models approach Proc AAAI88 1988 pp 8993 67 M Winslett Updating Logical Databases Cambridge University Press 1990 68 D Zhang S Chopra N Foo Consistency action descriptions Proc PRICAI02 2002 pp 7079