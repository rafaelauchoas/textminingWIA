Artificial Intelligence 98 1998 I47 Artificial Intelligence Schema induction logic program synthesis Nancy Lynn Tinkham Computer Science Department Rowan University 201 Mullica Hill Road Glassboro NJ 08028 USA Received February 1993 revised August 1997 Abstract Prolog program synthesis efficient schemata capture similar ities previouslyseen programs Such schemata narrow search involved synthesis new program We define generalization operator forming schemata programs downward refinement operator constructing programs schemata These operators define schemahierarchy graphs aid synthesis new programs Algorithms presented efficiently obtaining generalizations schemata adding new schemata schemahierarchy graph schemata construct new programs 1998 Elsevier Science KV Keywords Inductive logic programming Inductive inference Automatic programming Learning 1 Introduction When writing programs people useful draw knowledge programs written An experienced programmer presented new problem recall solving similar problem earlier occasion novice programmer use examples classroom textbook guide problem solving This observation motivates following hypothesis One way machines syn thesize programs 1 examples programs 2 form generalizations capture information forms programs 3 use general izations writing future programs This paper language expressing generalizations programs algorithm deriving generalizations algorithm synthesizing program generalization Email nltrowauedu 00043702981900 1998 Elsevier Science BV All rights reserved HI SOOO4370297000556 2 NL TinkhatnArtcial Intelligence 98 1998 l47 As illustration sujixSuList List succeeds amples intended behavior suix predicate task SufJixist consider synthesizing predicate Prolog suffix List given ex positive examples wmcl7 GhCl wYql LLY41 negative examples sufJix b b c sufJix z I w x Our task easier knowledge similar predicates pre PrejixList List ITW Pwx predXIYlXIZl pyWIZ succeeds PrefixList prefix List memberElement List member Y VI W member X YlZ member X Z succeeds generalization Element member List The step derive schema prejix member One schema following QK XIYI QtZ Y This schema expresses base recursion Further recursive involves information tail list structure recursive clause clause serving Prolog programs arguments structure common list Taking schema starting point search program special ization schema succeeds positive examples negative examples eventually search finds wfJixw v suX YIZ suX Z The process generalization programs information examples program set programs captures structural major components 1 derive schema information 2 derive schema making use structural consistent given set positive negative I I Background Inductive inference tions including grammatical process learning inference examples covers range applica structures inference logic formulas learning NL ikhamArtcial Intelligence 98 1998 147 3 encoded semantic nets hypothesizing mathematical theorems automatic pro gramming Gold 1 161 introduced identification limit model inference language examples Learning Golds paper performed enumerative algorithms systematic way consider machines algorithmsthat given class machine target language The main advantage enumerauve algorithm thoroughness makes possible prove classes languages identified algorithm This thoroughness main disadvantage enumerative approach vast number possibilities examined makes search extremely slow One oF improvements enumerative algorithms introduction refinement operators prune search sacrificing theoretical power Refinement op 30321 refining discarded erators introduced Shapiro hypotheses The mathematics refinement operators studied Laird 19201 described downward refinement Shapiros op erators examples upward refinement We return refinement op erators Section 22 defining operators generalizing specializing pro grams Concept learning studied Valiant 401 Angluin Laird 11 Mitchell 251 Michalski 241 Winston 41 Early work finding gener alizations literals clauses Popplestone 2S Reynolds 29 Plotkin 2627 A survey inductive inference systems given Angluin Smith 21 work grammatical inference surveyed Biermann Feldman 61 Automatic programming systems designed work LISP Prolog languages input systems variously includes inputoutput examples 371 inputoutput specifications 472334 computation traces 51 The use transformation rules construct improve programs studied Burstall Darlington 81 Dershowitz 11121 Logic program 131 Gilbert Hogger 151 synthesis studied Flener Deville Sterling Kirschenbaum 351 Lau Prestwich 211 Bergadano Gunetti 31 Grobelnik 171 Johansson 181 12 Prcject overview This paper describes project applies idea refinement operators problem known programs aid synthesis new program fit set positive negative examples It defines upward refinement operator algorithm operator efficiently generalizations programs called schemata The paper shows schemata narrow search involved program synthesis These ideas implemented Prolog repeatedly adds new schemata knowledge base increasingly efficient synthesizing new programs This implemented described end paper 4 NL linkhamArtijcial Intelligence 98 1998 l47 2 Language operator definitions Prolog chosen paper basis language express programs schemata Programs represented multisets Prologlike clauses clauses differ standard Prolog form right hand clause regarded multiset sequence literals We restrict attention programs defining single predicate Hence example program Jrafl4RISl m WWlIW9X atomRR jLmwST CfrattenUVlYJlattenUZuppendIZX Observe program continue correct definition Jten sequence literals clauses different specifically choosing study orderindependent programs This enables view programs directly logic expressions involving extralogical concept order computation It keeping philosophy Prolog programming favors writing possible programs depend order execution correctness A schema representation like program schema contain predicate variables contain symbol Cl clause The special symbols 0 Cl represent specific general schemata respectively We use program special case schema predicate variables clauses occur program schema schema program For overview Prolog programming language 101 361 21 Language deJinitions terminology introduced describing programs schemata Some A term individualvariable individualconstant function symbol arguments In flatten program X 1 RIS terms A literal predicate symbol arguments atomR example literal A clause 0 representing clause single literal expression form Ai A literals AZ An multiset liter The literal singleliteral clause literal lefthand multiliteral clause Ai positive literals literals righthand clause AZ A negative literals As example clauses thehtten program A multiset collection objects repetition significant set order significant The operations U union n intersection C subset c proper subset sum difference literals clauses clauses schemata multiset operations For definition multiset operators Appendix A 22 NL TinkhamArtijcial Intelligence 98 1998 147 5 JlattfmUlVlIWlX CflattenUlVlYttenZuppendZZX literal jZutfen UlV WI X It contains positive literals Jlatren UlV Y jkuten W Z append x Z X A schema multiset clauses contains predicate symbol clauses positive literals Thus flatten program schema negative PX RXJN PW PZ However PX NXJ qZ PZ schema contains p q positive literals A schema contains predicatevariables contain Cl called program The definition en example program letters b function symbols lowercase The following notation conventions constant variable symbols Individualvariables written uppercase letters X x individualconstants lowercase letters f g predicateconstants lowercase letters p q predicatevariables upper case letters P Q When needed clarity arity function predicate indicated superscript f p4 Mnemonic names constants functions append numerals As Prolog working listforming functor usually use list notation explicitly nested functions represent list For example b written b ubX written ublX For particular application define schemata terms finite set function symbols predicateconstants models setting finite set Prolog predicates known having previously defined defining single new predicate A finite set K function symbols individualconstants predicateconstants called constant set If K constant set A set integers predicateconstant K arity L defined language K L set schemata u schemadeition function symbol individualconstant predicateconstant occurring c element K predicatevariable P occurring arity E A Observe regardless choice K L contain elements 0 Cl Example Let K p 42 f b let L schemadefinition language K Some examples schemata L 1 PX 41ZPfYPZ Pb 2 RX PX 6 NL 7hkhamArtiJicial Intelligence 98 1998 I47 Example expression 1 program schema contains predicatevariables L An example 3 PX rX pfZ PZ contains predicateconstant r member K The choice use multisets ordinary representing initially viewed computation hand Prolog predicate sense putation literal removed Second degree recursion schemata reasons First identical observe duplication program properties studied wellbehaved multiset sets intuitive program literals appear right cause repeated com duplicated Section 3 degree branching representation form PXl language constant Three final languagerelated definitions discussion operators X individualvariables definition schemadefinition section easier Let L schemadefinition mostgeneral positive literal schema u E L positive P predicatevariable predicatevariable XI Recall integer predicateconstant mostgeneral negative literal E L similarly defined negative form PO form P XI X2 X XI X individualvariables occurring exactly cr additional constraint occur literals requirement literals schema identical set K A literal form PO X2 X P n 0 exactly rr K A literal P positive positive occurring language constants predicate symbols appearing predicatevariable T This constraint definition arity n omitted A mostgeneral term cr term term form fXtXz individualvariables occurring exactly ff X f function individualconstant symbol Xt X 22 Operator denitions ordering This section introduces operators The section follows operators V t written Vt In presentation relation schemata family refinement properties relation replacing substitution occurrences An interpretation set I ground atoms A goal single ground atom A schema u said cover goal g I 1 clauses 2 g symbol 0 T contains 8 CUB g Ai0 I u covers AiB 1 n clause K form At A substitution The set goals covered schema interpretation I denoted CU NL 7inkhamArtificinl Intelligence 98 1998 147 1 Let 1 u quqbru Exwle covers goal pa 0 contains clause pa pa pu covers goal pfu u contains clause pfX qX apply substitution Xu literals clause obtaining p f puqu I cover pb pfb pfu matches goal pu covered U qu pXqX pupfX pX Definition Define equivalence relation z schemata For schemata I uz 1 M 2 exactly I uz identical possibly naming variables order listing negative literals clause clauses schema ExampIes renamed Y PX PX p4 QY Qd P renamed Q X qXrXPa M PuPX rXqXsincetheydiffer order For simplicity presentation remainder paper schemata equivalent sense M schemata differ variable names order literals clauses considered schema Definitioa Define partial order schemata 5 follows If 1 1 S1 K2 Y2 2 clauses Si S2 possibly multisets literals 1 6 K exactly 1 K2isClor 2 substitution B 1 726 Si multiset subset relation If gi 3 schemata TI 5 2 exactly 1 1 2 contain 0 clauses 1 contains clauses 2 2 ai contains nonCl clause onetoone mapping 4 clauses I clauses uz substitution 6 1 E 1 2 E c2 2 1 KI 5 2 With substitution 8 Example If 1 PU QaVrb pu 72 PZ PW SX Y PC Pd u1 5 2 8 ZU wv SQ XU rv 8 NL 7FnkhamArtcial Intelligence 98 1998 l47 The ordering 5 easily seen reflexive let 0 substitution transitive compose substitutions Tinkham 381 shows 5 antisymmetric 5 partial order Given ordering expressions 5 Laird 20 defines upward jinement y recursively enumerable relation expressions y 5 downward renement p recursively enumerable relation expressions p 5l When viewed computationally y p referred denotes set ward downward refinement operators The notation ra set expressions produced applying y cr ya expressions produced n applications y u ya set expressions produced 0 applications y u We introduce refinement operators upward refinement generalization downward refinement specialization In order properties operators clearer study operators divided parts define generalization operators yi y2 specialization operators pr 2 Definition yl Let K set function symbols predicateconstants Let L schemadefinition language K let err z schemata L Then 72 E ye al exactly following holds 1 Deleting negative literal 2 derived 1 deleting mostgeneral negative literal A clause K ur 2 Separating individualvariables X individualvariable occurring I 12 derived 1 replacing occurrences X individualvariable Y occurring I 3 Separating predicatevariables P predicatevariable occurring I 72 derived 1 replacing occurrences P predicatevariable Q occurring I This rule set clauses applied result schemathat predicate symbol positive literals 4 Generalizing predicate p predicateconstant occurring negative literal 1 P predicatevariable occurring ui u2 derived ut replacing occurrences p negative literals P 5 Generalizing predicate p predicateconstant occurring positive literal ur P predicatevariable occurring ur u2 derived ur replacing occurrences p positive literals optionally occurrences p negative literals P 6 Generalizing term 172 derived ur replacing occur rences mostgeneral term t ur individualvariable X occurring 1 Definition 2 Let K set function symbols predicateconstants Let L schemadefinition language K let UI u2 schemata L Then u2 E yz ur exactly following holds NL TinkhumArtifcial Intelligence 98 1998 147 9 1 E YlUl 2 Adding clause ITI 02 contain Cl 72 derived ui adding clause K set clauses I 3 Replacing mostgeneral positive literal 0 Clause K CT set containing single mostgeneral positive literal negative literals 2 derived I replacing K 0 4 Deleting duplicate occurrence 0 1 set containing n 1 occurrences 0 clauses 72 set containing n occurrences 0 clauses n 0 Definition 1 Let K set function symbols predicateconstants Let L schemadefinition language K let 1 cr2 schemata L Then 72 E pi 1 exactly following holds 1 Adding negative literal 9 derived I adding mostgeneral negative literal A clause K I K q 2 Unifying individualvariables X Y distinct individualvariables occurring q 2 derived 1 replacing occurrences Y X 3 Unifying predicatevariables P Q distinct predicatevariables occurring ut c2 derived ut replacing occurrences Q P 4 Replacing predicatevariable predicateconstant P predicatevariable occurring ut p predicateconstant u2 derived ut replacing occurrences P p 5 Replacing individualvariable mostgeneral term X individualvariable occurring 1 t mostgeneral term 2 derived ut replacing occurrences X t Definition pz Let K set function symbols predicateconstants Let L schemadefinition language K let ut 2 schemata L Then 2 E p2 ui exactly following holds 1 u2 E PlUl 2 Dleleting clause I 2 contain 0 K clause ut derived ui deleting K 3 Replacing 0 mostgeneral positive literal 0 E 1 u2 derived 1 replacing 0 mostgeneral positive literal This rule set clauses applied result schema predicate symbol positive literals 4 Duplicating 0 UI set containing n occurrences cid144i clauses u2 set containing n 1 occurrences 0 clauses n 0 We add definitions discussing operators Definition Let ui 2 schemata If ui E yq generalization 172 We ui general ut 10 NL TinkhamArtificial Intelligence 98 1998 147 A schema T said generalization set schemata I7 u general ization schema n Definition Let 1 2 schemata specialization 2 We I specific 72 If TI E pg q I Example To illustrate tion program mar general schema indicated use refinement operator 2 example deriva step bold First apply rule 4 p2 produce 2clause schema Changes 0 Then replace 0 mostgeneral literal t PX1 x2 X3 0 PXlX2X3PYlY2Y3 Next add mostgeneral negative literals clauses PXlX2X3PYlY2Y3 RY4YS PXlX2X3 QX4X5PYlY2Y3 RY4Y5 Then replace predicatevariables predicateconstants maxXlX2X3 QX4X5mwYlY2Y3 RY4Y5 4 maxXlX2X3 QX4XSmauYlY2Y3 Y4 YS maxXl X2 X3 X4 2 X5 maxY1 Y2 Y3 Y4 Y5 Finally unify individualvariables goal program produced maxX1 X2 X3 X4 2 X5 maxY1 Y2 Y3 Y4 Yl maxXlX2X3 X4 X5maxYlY2Y3 Y2 Yl maxXlX2X3 X4 2 X5maxYlY2Y2 Y2 Yl mauXlX2X3 X4 X2maxYlY2Y2 Y2 Yl maxXlX2X3 Xl X2maxYlY2Y2 Y2 Yl mX1X2X1 Xl X2maxYlY2Y2 Y2 Yl 23 Basic properties Tinkham 38391 proves properties y2 2 listed Properties 18 Property 1 Let I 72 schemata UI E ylu2 pI inverse operations iff E pl That y1 NL ikhamArtificial Intelligence 98 1998 l47 11 Property 2 Let 1 2 schemata I E yza2 p2 inverse operations ifs a2 E pz 01 That y2 Property 3 Let K constant set 79 let L schemadefinition language K Then yz 8 L That yg suficiently powerful generate schemadefinition language minimal element Property 4 Let K constant set 2 let L schemadefinition language L That suciently powerful generate K Then p 0 schemaceition language maximal element Property 5 Let 1 2 schemata Then I 2 iff q E plaz That ordering induced specialization operator 5 generalization specialization renement operators The basic properties use function 6 maps schemata integers A similar function Reynolds 291 Definition Define number nonpunctuation symbols o number distinct variables occurring number literals For example Punctuation symbols parentheses braces commas Symbols ex pressions containing lists counted lists represented nested binary functions abbreviated list notation b analyzed b containing 5 nonpunctuation symbols Propewy 6 That application p1 adds 1 5 value schema UI u2 schemata u2 E p1 I 5 UI 1 5 2 PropeWy 7 If UI u schemata 172 E p 1 2 E py 1 n lq applications PI That u2 derived 1 2 al orfewer Property 8 shows schemata related 5 related sets goals covered Property 8 Let I u2 schemata I interpretation If I 5 2 Cl UI G Cl 2 That ul specialization 2 u1 covers subset goals covered 2 12 NL TinkhamArhjicial Intelligence 98 1998 147 3 Finding generalizations The main intuition explored paper ought easier solve new problem seen problems similar solutions Capturing similarity collection programs focus section We want similarities specific informative possible ask question way Given set programs nd generalization set programs A generalization defined follows Definition A schema u said generalization set schemata L7 u generalization II schema T ut specialization u o generalization 17 Observe generalization general unique For example PX da Y PX CqXd generalizations set PX da b dc d pX da d derived 31 A simple algorithm jinding generalizations One method finding generalization set programs 17 vn perform breadthfirst search space defined yz Beginning n sets q add schemata yzri ith set Next add schemata 3z yz ri ith set Continue intersection generalizations 71 7r2 7 nonempty Return intersection output While procedure generalization possibly search examine large number schemata graph defined yz large branching factor After examining properties refinement operators able better algorithm performs constrained search 32 Properties rejkement operators In order develop efficient algorithm finding generalizations explore properties generalization refinement operators y2 pz properties restrict search space Two properties particular degree branching degree recursion NL linkhamArtijkial Intelligence 98 1998 l47 13 Definition The degree branching schema U bd CT defined number clauses u Definition Let u schema positive predicate symbol 4 Define constant maximum occurrences n 1 4 clause K T negative degree recursion u rda literals contain exactly n literals g contain variable Example If CT 44 9 400 rX 07 Izwqzqw bdcr 3 rda 2 These natural measures consider Prolog programs depart straightline clauses conditional repetition allowing branch Degree branching degree recursion behaved application yi pi This feature finding generalizations obvious ways form 1 containing multiple recursive calls creating 2 containing certain conditions leads efficient algorithm We begin noting results follow immediately definitions 2 P l A single application y2 increase leave unchanged degree branching schema single application p2 decrease leave unchanged branching degree l If y p2 applied leave degree branching unchanged case m degree recursion degree recursion added case 72 deleted clause application y2 decrease leave unchanged p2 increase leave unchanged application recursion degree increase application y2 clauses It possible added decrease application p2 clauses removed However existence generalization set schemata n property recursion degree minimum recursion degrees schemata selt regardless degrees branching This task following lemmas theorem Lemma 9 gives generalization singleclause schema degree recur sion r Lemma Let K schema O arity bd K 1 rdK r Then P predicatevariable X10 X distinct individualvariables generarization K WXLOJLO JYXJI X PXI 14 NL TinkhatnArtcial Intelligence 98 1998 147 K replace p predicatevariable K replace c individualvariable V variable W occurring variable V replace K Repeat step Proof Apply following operations K p occurring K 1 For predicateconstant occurring 2 For individualconstant occurring If K contains occurrence variable occurs K K occurrence c occurring 3 4 K consists entirely mostgeneral positive occurring predicatevariable predicatevariable literals Let P predicatevariable literal K If literal h K contains step P delete h K Repeat P appears Call result sequence operations K By derivation K K general ization original schema K Since K XIO xao XII I pxlr xa lemma follows 0 Lemma 10 gives generalization singleclause schema independent degree recursion Lemma 10 Let K schema O arity bd K 1 Then P predicatevariable X1 X distinct indi PW1JLd vidualvariables generalization K Proof By Lemma 9 generalization negative literals K Since P x10 Xaa derived u deleting r result follows El These described lemmas extended definition theorem generalization multiclause schemata Definition Define G b r schema containing clause PXllO 9 X710 PXll1 9 I1 19 9 PXllr9 9 Xa1r 2 b clauses PXlo Xaia For example G 342 pxll0210310 11121131111221232 px120 x2209 x320 7 px130 x230 x330 9 p xl 40 1 x240 9 x340 NL IinkhamAmjkial Intelligence 98 1998 147 15 Observe defines variable predicate arity Ga b r schema branchingdegree b recursiondegree r Theorem 11 Let WI T schemata containing 0 define predicates gener arity Then Gamaxbdlbdminrdrlrd alization 971 IT Proof For 1 6 n let Ki clause Lemma 9 ri rd Ki rd ri By I XllOl 7 lO JYXIlI 5 x711 1 XlI Xl r minrdrr let result removing By repeated use Lemma 10 rdrr generalization 1 K Ki ri let ci number clauses For nf llO 9 x10 XlCiO 9 wo generalization 7 2 XllO9 3 lO 3 PXlcO 9 o c maxcr c maxbd q bd rr 1 generalization IT 7r Thus Gamaxbdbdminrdrd UI generalization nr n El Example A generalization pre_order pre_order nil pre_order tree Node Lefi Right NodeIT preorderL LL pre_order Right RL append LL RL T flatten Cflatfen I I uttenHlITll HllT2 atomHlJlattenTlT2 jZatten AIB IT3 L JlattenABlLluttenT3L2appendLl L2 L G232 PC XIlO9 X210 fYXIII7 X2IIX112 X2L29 PX120 X220 I px130 x230 16 NL iinkhamArtificial Intelligence 98 1998 147 The importance Theorem 11 generalization produced directly search maximum generalization exactly clauses CT generalization derived generalizations u applying PI This gives efficient algorithm u set schemata branching degree CT finding degrees schemata section set branching shown 33 An improved algorithm jinding generalization PI refinement finding Algorithm apply downward section suggest procedure initial approximation The results preceding generalization generaliza appropriate branching degree recursion degree tions generalization set programs The computation minrdrrt generalization U yielding 9 CT generalization wise retain T This process repeated pt longer applied point definition generalization A set MARKED record past applications begins taking Ga maxbdq approximation CT shown n1 T p1 applied generalization PI prevent needless new approximation 1 uses approach 91 rn 7 bdrn rda repetition Algorithm 1 Derive schema set programs Input A set programs Output A schema IL7 rq rn arity fl feast generalization programs l7 Data structures A set MARKED elements representations applications pI An element MARKED following application r2 VI VZ VI 2 individualvariables rule PI forms ri record representing unification zq 2 r3 9 Pz PI PZ predicatevariables representing unification PI P2 r4 V f Y individualvariable representing replacement Y mostgeneral f function symbol term functor f r5 P p P predicatevariable p predicateconstant representing replacement P p A set CONSTSET containing constant function symbols Procedure CONSTSET c set individualconstants function symbols predicateconstants u c Gamaxbdq MARKED 8 repeat occurring lI7 bdm minrdq rdr Select application CY PI u NL lMhamArtcial Intelligence 98 1998 147 17 CY member MARKED constant function symbol introduced pl element CONSTSET predicatevariable predicateconstant CONST_SET arity b introduced p1 arity b Apply PI u determined previous step producing Q MARKED MARKED U If CT generalization al IT u t T leave unchanged p1 longer applied U return ff In order discuss efficiency Algorithm 1 introduce following tation u schema length u written 1 denote number nonpunctuation symbols c Similarly 17 1 T set schemata 1n7 denote 1q I jr21 IT I total number nonpunctuation symbols II The difficult portion computation Algorithm 1 comparison schemata 1 u2 determine cq 5 2 Chandra Merlin 91 graph isomorphism problem polynomially reducible problem determining sets firstorder atomic formulas identical renaming variables problem trivially reducible problem determining 2 This problem turn reduces problem clauses ICI 2 1 x comparing schemata determine generalization 2 2 5 KI Since 1 polynomialtime algorithm known graph isomorphismGarey Johnson 14 pp 154158 2851 conjecture belongs class problems intermediate difficulty P NPcomplete problemsit unlikely polynomialtime algorithm exists determine general schema generalization 2 containing q KI iff KI 2 c 5 If consider search space Algorithm 1 efficient number schemata examines theorem shows Theorem 12 Algorithm 1 examines 0 j1713 schemata Proof For brevity notation let b max bd q bd r r minru 1 r4qTn I We begin examining number ways p1 applied u 1 A literal added u bdu A ways A number different arities occurring predicateconstants II 2 There VI VI 1 ways unify individualvariables u 6 number individualvariables occurring u 3 There VP VP 1 ways unify predicatevariables u Vp number predicatevariables occurring u 4 There VP C ways replace predicatevariable u predicateconstant C number predicateconstants occurring 17 18 NL lXhamArtijicial Intelligence 98 1998 147 5 There V F ways replace individualvariable mostgeneral 17 term F number function curring IT generalization n Hence u examined symbols individualconstants oc number immediate successors bdaAblVVplVpCVIF joI A v VP Iv lITI ICI III 6 IcT A 101 21al 1171 derived G b r pi bdcr b bdii By way Ga b r defined bdii b Since u ii E pi T Applying pt schema leaves length schema unchanged cases unifying variables replacing variables constants increases length schema arity greater previous literals replacing variables terms program E n number successors T 11 ii 6 Inl Substituting 0 Hence know cases adding formula IL71 A lZ7 2171 1171 171 A 3L71 By Property 7 number applications G b r pt needed derive generalization mCI4 5Ga br 6 2lnl Multiplying A 6 171 algorithm examines bound number applications pt noting lZTl 3jLTl 21171 81U13 successors Ga b r examines 0 ln13 schemata cl Algorithm 1 runs quickly actual elapsed 9 seconds generalizations time In examples discussed cuberoot reciprocal difficult Section 5 Section 5 generalization example 2 seconds 34 Summary Finding generalizations In Section 3 defined concepts degree branching degree recursion described vary yz pz applied These observa tions allowed construct algorithm set schemata specializing G b r generalization number nodes examined algorithm input twostep process finding generalization Ga b r immediately length able generalization We showed polynomial NL lTnkhamArtiial Intelligence 98 1998 147 19 4 Finding programs Now generalizations programs turn look ways use program synthesis The synthesis problem considering generalizations following Given set positive examples set negative examples program covers positive examples negative examples Examples ground atoms positive examples ground atoms predicate succeed negative examples ground atoms synthesized desired behavior predicate union program succeed We instance way Positive examples union b cl b c 4 b c 4 mid bl cl b cl Negative examples union b cl b c 4 b cl 1 unionabl aI I want program union b cl bc covers union b c 6 c d b union bc bcl bcdl We cd uniontzbl We want al 1 I model situation called subroutines new programs single new program described examples We assume synthesis algorithms utility predicates programs known synthesize predicate constants represent provided Prolog definitions predicate synthesized member append predicate constants want Most 41 A search algorithm finding programs Our synthesis algorithm Algorithm 2 takes input schema u set positive negative examples produces output program T covers n E p2 exists It positive negative examples 7 covers proper examples An generates search covers oracle COVERS determine program produced given example C0VERS adequate general undecidable discussed An implementation Section 52 practical purposes question specializations Algoritlhm 2 Find program starting schema Input fit set positive negative examples given A schema 0 A set positive examples E eT e set negative examples E ee 20 N L Tinkham ArtiJcial Intelligence 98 I 998 l47 Output A program covers examples E E Oracle algorithm COVERSr e returns Y 7 program covers e returns N Data structure A queue schemata Q Procedure Q vol Q Remove If T program Q member CT add end Q members pza Else u program COVERSa e Y e E E COWRSa e N e E E halt return u Else CT program COVERSa e Y e E E COVERSa e Y e E E add end Q members p2 Theorem 13 Let E set positive examples E set negative examples a0 schema Algorithm 2 input E E a0 halt return program 7 covering members E members E IT E p2 0 exists Proof Assume Ef E Any ancestor CY v covers members E LY goal program selected Q immediate descendants selected Because algorithm halts halt halt exhausting Q exists program 7 E p2 0 covers members program program goal program Q ancestor T possibly T goal program LY added Q Hence Q exists finding goal Since algorithm examines order increasing n members particular value n finite finite number schemata pz 0 generated rr systematic application 2 Hence algorithm halt finding T selecting goal program computation halts program covering members E E halt selecting T Q In case computation q Q earlier 42 Schema hierarchy In examining Prolog programs certain structural patterns recur program consist recursive clause base case instance contain clauses select actions based collection nonrecursive NL GkhamArtcial Intelligence 98 1998 147 21 deciding program mental actions selecting truth condition A programmer looping basic fonm program requires recursive clause nonrecursive form details required program behavior clearer instance deciding list recursion tail list base case Some structural patterns described schemata general patterns described general schemata specific patterns specific schemata refine base clause involves language particular The generalization schemata Such graph seen classifying programs according instances y2 imposes hierarchical Very general schemata operator yz allows draw directed acyclic graph schemata grouping programs relatively alike dislike language structure entirety given schemadefinition indicating schemata general P P P PI appear high hierarchy More specific schemata P XlZll XIZ21 IXIZ31 PZl Z223 PWIZ41 WZSl tYZ61 PZ4Z5Z6 P iUIZ71 VZSl VIZ91 1 PZ7 Z occur lower hierarchy programs I 1 I I awl amlZllZ21Z3andZlZ223 amd 0124 WIZSI OlZ6 andZ4Z526 und 11271 OIZS OjZS undZ7ZSZ9 occur lower programs consisting entirely ground clauses appear nfear 22 NL Tinkham Artificial Intelligence 98 1998 147 1 PXX I PaY I ww lPWYl 0 I P4ZY 1 I PWYZ 1 PXY cWZ I Fig 1 There types hierarchical complete graph containing definition language arc representing levels complete graph language containing predicate constant p2 shown Fig 1 nodes schemata expressible graphs construct 2 The given schema single application 79 The f constant function A second type obtained selecting nodes complete graph allowing yz These nodes selected according groupings pro factor schemata schemata represent important giving graph desired depth branching arcs represent applications aesthetic criteria grams computational reasons This gives relatively according similarity generalization small graph classifies selecting criteria relation patterns labelled bl binary predicates We significant term produces b3 adding second Fig 2 The general 4clause schema arity 2 b2 specific variable recursive recursive programs preorder recursion tail list special cases list base 69 schema 61 clauses contains mostgeneral clause produces b4 schema specializations flatten leaft b7 specialization listtraversal list base case b6 singleton recursive clauses b8 describes recursive Replacing inorder postorder b7 containing doublyrecursive b5 represents treetraversal twoclause programs programs Fig 3 shows graph schemata schema 1 appears 2 schema describing predicates arity 3 The general 4clause selection input NL lhkham Artificial Intelligence 98 1998 l47 23 7 leaf_ El list Fig 2 Hierarchical graph selected schemata arity 2 The definitions programs schemata diagram appear Appendix B max min 3 schema containing programs menus intdiv mod schemata clause recursive calls 5 schema 7 recursion recursion tail list generalization s9 recursion lists s5 6 input parameters appears based test generalization parameters recursive descendants s4 5 4 schema containing representing occurs lists s7 turn generalization generalization lefthand1 righthand replacement turn 6 The diagram adjacent individualvariables illustrates clause Unification mostgeneral intersection like deleteall terms produces s8 10 form individualvariables like append intersection resembles append closely 43 Using schema hierarchy program synthesis A schemahierarchy schemata collection schema retain generality graph makes synthesizing begin new program easier gives general root graph search ensure finding solution But including search By choosing Cl P___P___P___ 24 N L Flinkhatn Arhjicial Intelligence 98 1998 147 Fig 3 Hierarchical graph selected schemata arity 3 The definitions programs schemata diagram appear Appendix C useful program generalizations A wellselected graph concentrate search patterns set schemata specific schemata known greatly narrow search Schemahierarchy graphs directed acyclic graphs consisting nodes representing applications p2 While schemahierarchy tree consider ones sufficiently schemata arcs representing graph necessarily contain nodes outdegree 0 leaves Conceivably contain nodes interesting exactly node indegree 0 root graph root set leaves contain small subset nodes deemed generality intermediate treelike Since power p2 produce lengthy relatively uninformative addition number literals refinements K restrict attention correspond degree branching We I 2 graph I 1 generalization 2 r applications p1 onlyhence Sections 431 432 sequences clause K followed deletion graphs arcs graphs nodes condition 2 path ul impose NL linkhantArtijcial Intelligence 98 1998 147 25 We need definition speaking generalizations graph Definition Let 2 set schemata r hierarchical graph schemata schema r u generalization If 19 r 2 u generalization 2 2 specialization generalization relative r graph Example union append xor relative If r intersection relative r Fig 3 schema 10 generalization s5 generalization adjacent r 431 Expanding schema hierarchy In order construct maintain graphs properties described graphs To state formally graph r contain want nodes 1 2 r ut need able add new programs schemata given schema u hierarchical insert T r preserving generalization property 2 path ut allows set schemata add group schemata useful The algorithm graph The ability new programs known grouped parent node representing closely 2 r added schemahierarchy instance like related generalization new root graph general begins finding generalization LG set new schemata graph new schemata LGs children We LG vice versa root generalization root new graph schemata graph adds appropriate calls addschema finds relative new schema LG root added new root To add individual generalizations specializations addschemaset LG added establish generalization addschemaset general arcs graph Algorithm 3 Add set new schemata Input schemahierarchy graph A schemahierarchy A set schemata SchemaSet CT u Graph graph Graph rooted Root output A schemahierarchy nodes Graph Procedure graph NewGraph contains ut u addschemaset Root SchemaSet NewGraph Add schemata SchemaSet graph rooted Root yielding NewGraph singleton SchemaSet add ut return resulting graph NewGraph set Graph addschema 26 NL TinkhatnArtcial Intelligence 98 1998 I47 compute generalization LG SchemaSet LG specialization Root add LG Graph addschema add member SchemaSet Graph addschema split SchemaSet 21 set schemata _I set schemata SchemaSet specializations SchemaSet specializations Root Root add Graph members 21 addschema individually compute generalization LGz compute generalization NewRoot Root LG2 add NewRoot NewRoot Graph parent Root renaming variables identical LGz add schemata Graph children NewRoot add LG graph child NewRoot add schemata 22 Graph children LGz return resulting graph NewGraph addschema Root Schema NewGraph Add Schema graph rooted Root yielding NewGraph add node Schema set nodes Graph findrelative_lgsRoot Schema ListG o E LG establish arc Schema Graph jndspecializationsRoot u E Lists Schema Lists establish arc Schema Graph Root Schema incomparable compute generalization LG RootSchema add LG Graph parent Root Schema return resulting graph NewGraph jindrelative_lgs Root Schema List Find generalizations List Schema relative Root generalization Schema graph rooted Root IL1 r 1 child C Root jnd_relative_lgsC Schema L2 append L2 Ll Ll List t List c Ll Root List NL TinmnArtificial Intelligence 98 1998 147 21 jindspecializations Root Schema List Find general specializations List Schema relative ROOI specialization Schema graph rooted Root List Root List child C Root jirzdspecializations C Schema L2 append L2 List remove new List schemata appearing List 432 Program synthesis ancestor graph Algorithm 2 breadthfirst search single starting schema program fit set positive negative examples Algorithm 4 uses alternative approach uses begins schemahierarchy bounded depthfirst search focused As Algorithm 2 assume existence oracle COVERS T e given program 7 example e returns Y T covers e N single schema search graph Algorithm 4 Find program hierarchical graph schemata Input fit set positive negative examples graph schemata Graph rooted Root A hierarchical A set positive examples E set negative examples E A nonnegative integer D output A program D steps node Graph covers examples program exists E E Data structure A stack schema depth pairs S Procedure Node Graph S Node O S Pop S member D D v 0 T program schema r_ p2 push D 1 S g program COVERSa ef Y e E E COVERSu e N e E E 28 NL TinkhamArtcial Intelligence 98 1998 147 halt return CT u program COVERSa COVERSr e Y e E Ef e Y e E E schema U p2 g push u D 1 S 5 A learning schemata This section describes implementing main ideas preceding sections inference program synthesis computed illustrated examples schema 51 Description The writes output composed modules files modules communicate takes input means files Find generalization Input A set programs 17 71 rTT Output A generalization IZ b Add program set Input A schemahierarchy graph rt A set programs 17 1 VT rt Output A new schemahierarchy graph r2 contains 1 n c Find program Input A set positive examples E set negative examples E A schemahierarchy graph r A nonnegative integer D output A program covers examples E examples E program exists NL lbhamArtificial Intelligence 98 1998 I47 29 structured The makes schemata grouped longterm use files schemata graph In general known schemata defined given alphabet number type useful graphs 2 hierarchical stored single file practically different files according problem human user selecting schema As Section 43 assume property path 1 2 graph The algorithm creating adding property schemahierarchy The learning schemahierarchy 2 graph 1 generalization features arity degree branching cycle consists repeatedly adding new programs files known file graphs maintains contain likely schemata ways 1 The told directly program set related programs The new programs added graph add program set module 2 The asked produce program set positive negative Once new program graph add In case jind program module original hierarchical added examples program set 52 Implementation All modules implemented SICStus Prolog run Silicon Graphics Indy The jind generalization module implementation Algorithm 1 The add program set module uses Algorithm 3 add set new programs graph The jnd program module implements Algorithm 4 It takes input set positive graph r integer D returns examples set negative examples program 7 D pzsteps node r v covers positive examples negative examples Note special case D 0 asks r known schemata program Since seen problem determining program covers particular example In general D 0 looking r predetermined genera undecidable runs program succeeded halt examples example treated candidate programs finitely oracle COVERS vr e approximated predicate number steps reports program fail positive future general refined halt allotted finitely time A program failed failed produce assuming 53 A sample problem As illustration look generalization problems performed listprocessing We start programs double double I I double HITl H HIT2 doubleTlT2 synthesis sequence 30 NL rinkhamArticial Intelligence 98 1998 I47 doublelast double_last Xl X Xl doublelast HITl HIT2 Tl doubleJastTlT2 ask generalization The schema P WI 7 ql pm I From form graph I PH ITlHIl I PT_1 I PiJ1 Suppose want synthesize program finding prefixes lists Taking input positive examples yrqWabl abcl pqWal ahcl prejW I abcl prGWa9bcl abcl prefuccl cl prefibl ihal negative examples prqWbcl abcl precl abcl pvWabcl abl graph search depth 5 finds program PreJix Iv pWW HIT1 1 fW21 prWl T2 We add pre graph producing new graph 1 I PlH I WH I _1 I PL la I Supposing given program reverse reverse I I reverse HIT L reverse T TR append TR H L NL TinkhatnArtifcial Intelligence 98 1998 147 31 add reverse graph producing I WI TL I PT2 I PL I 1 I PH I THH I _I 1 PL 1 PL t We use new graph synthesize program finding suffixes list positive examples whcl9 bcl qYw4bcl cl sufJixabcl I wFcl ahcl UfJixCl cl Mwbal al negative examples wGhcl abl sufJixabcl bl suabl ubcl depth 3 program SUx X X 9 IT1 9 y MT Y When suffix program added graph final graph 1 FTL I Tl3 I PTJ I I 54 Numeric examples This designed numeric predicates mind numeric com Prolog literals appear For example pair literals X 2 2 X 0 succeed reverse order instantiated putation Prolog X 0 X 2 2 cause runtime error X order sensitive 32 NL TXhamArtificial Intelligence 98 1998 l47 value prior context Since formalism treats programs schemata orderindependent guarantee output programs contain literals ordered properly Prolog compiler However numeric programs synthesized 541 Numeric list examples For simple example predicates sumsquaresList Ssq Ssq sum squares elements List sumsquares I 0 sumsquares HIT Ssq sumsquaresK TS Ssq TS H H prodlistList Product Product product elements List prodlist I 1 prod_list HIT Product prod_list T TProduct Product TProduct H generalization P I P IT X PT _ X _ The constructs graph From new schema predicates sum_list listlength synthesized Using positive examples sum_list123410 sum_list10515 sum_list 11 1 sumlist 0 negative examples sumlist 1234 ll sumJist 105 10 sum_list lO synthesizes program sum_list 0 sum_list HIT X sum_list T Y X H Y NL lMhamArtcial Intelligence 98 1998 147 33 Starting schema positive examples list_rengthl23414 Zist_length1052 listiengrh 1 1 list_length 0 negative examples listiengfhl2343 list_lengthlO510 list_iengrh 105 5 list_length 1 0 synthesizes program Zisl_Length 0 list_Zength IT X Zist_Zength T Y X Y 1 The resulting graph 542 Successive approximation example A example begins pair predicates cuberoot reciprocal based successive approximation algorithm described 121 The cuberoot program takes parameters l N tlhe number taking cube root l R Ann uninstantiated parameter hold root end calculation l Range number indicating desired precision answer The root N R3 R Range3 For example cube_root80001 R R 20 2001 The program proceeds doubling Range recursive Range N recursive calls sequence Range 2 Range 4 Range 8 Range As execution backs recursion numbers sequence added accumulating sum depending cube sum equal I For cube_root 3Ol R example recursive calls cube_root 301 R cube_root 302 R cube_root 304 R cuberoot 332 R The root case 14 08 04 02 Note 143 3 14 01 3 14 satisfies precision requirements root 34 NL TinkhamArtijcial Intelligence 98 1998 l47 This algorithm integer cube roots largest integer equal Ne3 range value 1 cube_root 91 R example finds integer root 2 cube_root N Range R Find R cube root N specifically R3 N RRange3 cube_root N RI Range Call N 0 Range desired precision R uninstantiated initially R interval 1 ints cuberootNlRangelO Range1 Nl cuberoot N Range R Range N Range2 Range 2 cube_root N Range2 R2 Square R2 Range R2 Range R2 Range incamount Square 6 N Range Inc R R2 kc The reciprocal program uses approach cuberoot reciprocal N Range R YO Find R reciprocal N specifically R lR 6 N lR Range Ireciprocal N R Range Call N 0 Range desired precision R uninstantiated initially interval 1 ints reciprocal Nl Rangel 0 Range1 Nl reciprocal N Range R Range N Range2 Range 2 reciprocal N Range2 R2 Product N R2 Range incamount Product 1 Range Znc R R2 Znc The utility predicate incamount called cuberoot reciprocal incamount Condition Quantity Increment Increment Quantity Condition true 0 Condition false inc_amount Condition Quantity Quantity Condition incamount Condition _ 0 Condition The finds generalization NL linkhamArtijcial Intelligence 98 1998 l47 35 PNlRangelO Range1 Nl P N Range R Range f N Range2 Range 2 PNRange2R2 X_ R2Range incamount X _ Range Inc R R2 kc caiptures essence successive approximation algorithm programsS A sqaare root program synthesized schema Using positive examples sq_root 9l 3 sq_root 25l 5 sq_root 1 1 l sq_rootO 0O sq_root 100 1 lo negative examples sq_root910 sq_root91 l sq_root912 sq_root914 finds program sq_root Nl Rangel 0 Range1 Nl sq_root N Range R Range N Range2 Range 2 sq_root N Range2 R2 X RangeR2R2Range incamount X N Range Y R R2 Y The resulting schema graph 6 Conchsions The enumerative search approach automatic programming carries benefits liabilities The chief benefit enumerative search thoroughness covers easilydescribed space allowing prove theorems circumstances guaranteed locate target successfully This thoroughness 36 NL GkhamArtkial Intelligence 98 1998 147 main weakness approach exponentially narrowing avoid having use schemata examine starting point search examine large number possibilities We discussed 1 use upward downward entire space syntactically entire space generated refinement operators search program refinement operators correct programs 2 avoid having enumerative search generally examines mechanisms finding algorithm schemata generalizations It described This paper described programs stores collection gen uses starting point program synthesis By efficiently eralizations starting particular schema specifications quickly provided schema As derives programs life efficient time synthesis increasingly fit inputoutput information add schemata derive program broad range programs collection enabling Acknowledgements This paper summarizes advisor Alan Biermann David Plaisted Bilge Karal Say Joseph Shoenfield helpful comments research drafts paper Pierre Flener Donald Loveland Gopalan Nadathur research Duke University anonymous I grateful reviewers doctoral Appendix A Glossary Numbers parentheses indicate section term introduced 1 An upward refinement operator refinement operator 2 An upward p1 A downward 2 A downward x For schemata refinement operator refinement operator I 2 1 M z exactly 22 22 22 22 naming variables possibly clause clauses schema 22 22 5 A partial order schemata Ci The set goals covered schema u interpretation The number nonpunctuation athe symbols order listing negative I 22 number distinct variables 01 az identical literals c number literals u 23 replacing occurrences variable V term t 22 Vt A substitution A builtin Prolog predicate X Y X Y identical U As multiset operator b b U c b b c fl As multiset operator b b II c 5 As multiset operator b b c b bc b b s b b b b b c NL linkhamArtijcial Intelligence 98 1998 147 31 C As multiset operator abb c abbc abb abb b El b c As multiset operator b b c b b c As multiset operator b b c b b c bda The degree branching schema 32 Constant set A finite set functions symbols individualconstants predicate stants 21 Degree branching The number clauses schema 32 Degree recursion If T schema positive literal CT contains variable constant predicate symbol q5 degree recursion u maximum n 1 clause K g negative literals contain exactly n occurrences 1 32 Downward reJinement operator Given ordering relation expressions operator p downward refinement operator p recursively enumerable relation expressions p 22 Generalization schema Schema ul generalization schema 2 schema T 1 cz 0 u E 79 2 22 Generalization set A schema CT generalization set schemata n generalization schema n 22 Least generalization A schema CT generalization set schemata 17 g generalization II schema I specialization CT generalization J7 Multiset A collection objects repetition significant set order significant See definitions U fl s C 22 2 Program A schema containing predicatevariables containing Cl 21 rd The degree recursion schema g 32 Rejinement operator See upward refinement operator downward rejinement operator Schema A multiset clauses predicate symbol appearing positive literals clauses 21 SchemadeJnition language constant set K If A set integers predicate constant K arity L schemadefinition language K L set schemata c function symbol individualconstant predicateconstant s occurring fl element K predicate variable P occurring T arity ap ap E A 21 Specialivztion schema Schema 01 specialization schema u2 schema CT UI x u u E p2 2 22 Upward rejnement operator Given ordering relation expressions operator y upward refinement operator y recursively enumerable relation expressions y 22 Appendix B Schemata arity 2 Listed schemata programs mentioned Fig 2 To programs easier read lines comments included The symbols 38 1 9 NL TinkhamArtifcial Intelligence 98 1998 l47 preceding parameter names comment parameter variable names readability indicate respectively input In places adhering parameter output parameter mnemonic constant singleletter strictly names PC7l b5 P PIV PC PC9I PK 66 PIv PC IT1 1J fYT 61 I P PC ITI 1 PT I PC PCv b8 IT P Ppl PT1 bl Pv P P PI b2 P P P PI P b3 P P II1 P P3 I P b4 P P P P P 69 P 191 P Tll P T21 Pm PTIJ Lisd alternate Listl List2 contains For example afternate Adapted alternat aZternate X _ITl XIT2 alternate Tl T2 33 p2661 I I b c d e c e elements Listl member L X X member list L member Xll X member IT X member T X sufJix S L S suffix list L NL TinkhamArtifcial Intelligence 98 1998 147 39 w7w L L mx ITI L Qw L element doublelast Listl Lisn Double Eg aouble_last bc bc I double_iast Xl X X doubleIast HIT1 I HIT21 Listl producing Lisn Tl 1 doubleJast Tl Z2 Lisa intersect_listLLl List2 intersection intersecilist X X interseckZist HIT L lists LLI intersect_ZistT Ll intersectH Ll L telescope Listl Lisn For example Adapted elescope I 11 33 pp 264 2661 teZescope b c d b c d b c d c d d telescope HIT L telescopeT L2 append HIT L2 L listthm Listl List2 Convert list elements For example Adapted listthru I I listth HITl HI list singleton lists listthru b c 33 p 2661 b c IT2 listthruTlT2 double Listl List2 Double element Eg Llouble bc aa b bccl double 1 IIt double HIT1 1 H HIT21 doubZeTI T2 Listl producing List2 reverse Listl List2 List2 k List1 reversed reveN I 1 I reverse HIT L reverseTTRappendTR HL pre P L P prefix list L pre 1 v prefiVll IHIT2lpreTlT2 complementVl V2 40 NL iMhamArtificial Intelligence 98 1998 147 V2 complement I I 1 I complement Vl bitwise compZementOTl compZement 1 T3 OT4 complement T3 T4 complementTlT2 lT2 removeduplicates Listl Remove duplicate elements removeduplicates 1 removeduplicates HIT L List2 Listl producing List2 member H T removeduplicatesT L remoue_duplicates Hl Tl Hl IT21 nonmember Hl Tl removeduplicates Tl T2 even_elts Listl EvenList EvenList contains elements Listl For example even_eZts45302l evencW even_elts HlITl I I HllT2 0 HI mod2even_eltsTlT2 H2lT3 L 402 1 H2 mod 2 even_eltsT3 L positive elements Listl PosList positive_elts Listl PosList contains Forexamplepositive_elts453021452 positive_eZts 1 positive_elts Hl Tl Hl IT21 Hl Opositive_eltsTlT2 positive_eZts H2T3 L H2 Opositive_eZtsT3 L fiatten LL FlatList Flatten list LL produce FlatList atten I 1 I JIatten Hl IT11 Hl IT21 atomHljlattenTlT2 Jiatten AB IT3 L CflattenAIBl LlttenT3 L2appendLl L2 L Quicksort I I qsort Unsorted Sorted qrort qsort PivotIT Sorted spUt T Pivot Ll L2 qsort Ll Sorted1 NL lMhamArtijcial Intelligence 98 1998 l47 41 qsort L2 Sorted2 append Sorted1 PivotjSorted21 Sorted pre_order Tree Nodes Nodes preorder list nodes Tree pre_order nil pre_order tree Node Left Right NodeIT prelwder Left LL pre_order Right RL uppen LL RL 7 in_ordw Tree Nodes Nodes inorder list nodes Tree inmder nil in_order tree Node Left Right List in_order Left LL in_order Right RL appendNodelRLLl append LL Ll List post_olpder Tree Nodes Nodes postorder list nodes Tree postorder nil postorder treeNode Left Right List poskxder Lefr LL post_order Right RL uppend RL Node Ll append LL Ll List leafl Tree List List list leaves Tree leuflist nil leafAist tree _ Left Right List lecffJist Lefi LL leafJistRight RL append LL RL List Appendix C Schemata arity 3 Listed schemata programs mentioned Fig 3 As Appendix B comments mnemonic variable names NL lTnkhamArtifcial Intelligence 98 I 998 l47 PC P391 PP PI PCI s5 PC1 P IT 1 PC PC P 4 I s6 P I PITlX1 PC PC I 4 PKX 42 sl PCJ PC PI PCI s2 PW X W QK XI PPZ Z RKZ s3 P7 PC PC PCv PCv9 1 s4 s7 Plll PXII PIYll PZll 4X21 IY21J rlz21 PXlX2 PYLY2I PZlZ2 s8 P I PITllX PC IT21 1 PVL PTlX 3 I s9 Plll PIXll PlYl1 PIZII SlO P I 1X21 4X31 IY21 IY31 4Z31 221 PXlX2X3 PYlRY3 PZlZ2Z3 PITllX PC lT21 KZ lT31 PTlXT3 PT2 XZ mux X Y Z Z larger X Y muxAlB1Al maxA2 B2 B2 AlBl B2 A2 minX IZ minAl 41 AIBI Z smaller X Y NL linkhamArtQzial Intelligence 98 1998 l47 43 min A2 B2 B2 B2 A2 monusiX K Z X Y Z X Y Z 0 successor notation Numbers represented IV 0 N monus monus 0 _ 0 monussXsYZ monusXZ intdiv x xZ Z X divided Y remainder Numbers represented int_v N N s 0 int_divXIsZ greakrJhan intdiv A B 0 Zess_than A B ignored successor notation X Y monus X xX2 intdiv X2 r Z Z XmodY represented successor notation modX xZ Numbers mod N N 0 modX KZ greaterfhun X Y monus X K X2 mod X2 Y Z modA B A less_thunA B list X produce list Z Y work space Jlatten2 X I Z Flatten Adapted Cflatten2 1 Ws Ws tten2 XIXs Zs Ys 36 p 2861 CfEatte2XsZsYsl7utren2XYslYs JEatten K Vs VIVs constunt V y udjucent X YZ Y Z adjacent elements list X udjucenl A BI_ A B udjucenl IT X Y udjucent T X Y insert Listl Elt List2 Insert Elt sorted List1 inseM I X Xl insert HIT X X HIT H X insert HIT11 X HIT21 H X insertT1 X T2 produce sorted List2 mergei Listl List2 List3 44 NL lhkhamArtificial Intelligence 98 1998 147 Merge sorted List1 sorted Lisd producing List3 merge I L L mergeL 1 I L L I merge HlITl H2T2 Hl H2 mergeT1 H2T2 mergeHlITl HlT3 H2T2 T3 iY2T3 Hl H2mergeHljTlT2T3 shue Listl List2 List3 For example shufJle b cl Ed e f Adapted 33 p 2661 d b e c f shwW shufJEeHlTl I 1 I H2lT2 HlH2T3 shufJleT1 T2 T3 nd_reverse X I 2 Z X reversed duplicate elements Y scratch list initially From nd_reuerse 36 p 1461 1 Es Es 1 removed nd_reverse AAs Revs Bs member A Revs nd_reverse As Revs Bs ndreverse CICs Revs2 Ds nonmember C Revs2 nd_reverse Cs C IRevs Ds uppend X I Z uppend I L L uppend HIT L2 HINewT uppend T L2 NewT urzd X Y Z I Iv I ahd Z bitwise X Y undlT11T21T3undT1T2T3 undOlT4 und llT7 undT4T5T6 _jT5 OIT6 OJTQ OIT9 undT7T8T9 Z bitwise X Y X xZ I 1 IIy orOTl orlIT451T6orT4T5T6 orOlT7lllT81 lJT9lornT8T9 orTlT2T3 OIT2 OIT3 xor X y Z Z bitwise xor X Y rE 1 E 1 I xor HT4 xorT4T5T6 OIT6 HT5 NL linkhamArticial Intelligence 98 1998 l47 45 xorHlITl H2T2 llT3 HlH2 norTlT2T3 L3 p2 Listl List2 For example pair b cl d e fl 4 b el c fl I Adapted paW 1 1 I I 9 puir2 HlTl paiRTlT2T3 HlH2IT3 33 p 2661 H21T2 unionX e 2 1 X4 X4 union union XSlRS Y525 member X5 Y5 union R5 Y5Z5 union X61R6 Y6 X6Z61 Y6 unionR6 Y626 nonmemberX6 intersection X I Z intersection intersection 1 _ X2jR2 Y2 X2lZ2 member X2 Y2 intersection R2 Y222 intersection X3lR3 Y323 nonmember X3 Y3 intersectiun R3 Y323 deleterst X xZ Delete occurrence Y list X producing list Z deleterst deleterst deEeterst I I EIT E T HIT11 Elt HIT21 H Elt deleteJirstT1 Elt T2 deleteall X xZ Delete occurrences deleteu delete_ull EIT E L deleteallT deletexll HIT1 1 Elt HT2 E L Y list X producing list Z Elt deleteallTl EltT2 setd X I Z setdifS I 111 setdiJf HITI Seti HIT31 nonmember H Set2 set_diffTl Set2 T3 set_di HI IT S2 Difl member Hl S2 setdT S2 Difl 46 N L Tinkharn Artificial Intelligence 98 1998 I47 References I D Angluin PD Laird Identifying kCNF formulas noisy examples Technical Report TR478 Computer Science Department Yale University New Haven CT 1986 21 D Angluin CH Smith Inductive inference theory methods Computing Surveys 15 3 1983 237269 31 F Bergadano D Gunetti Y Deville ed Logic Program Synthesis Transformation Proceedings LOPSTR 93 International Workshop Logic Program Synthesis Transformation Inductive synthesis logic programs inductive Springer Berlin 1994 4556 logic programming 4 W Bibel KM HGmig LOPSa based strategical approach program synthesis AW Biermann G Guiho Y Kodratoff Macmillan New York 1984 6989 eds Automatic Program Construction Techniques 5 1 AW Biermann The inference regular LISP programs examples IEEE Trans Systenzs Man Cybernet 8 8 1978 585600 6 AW Biermann JA Feldman A survey results YH Pao GW Ernst eds Tutorial ContextDirected Pattern Recognition Machine Intelligence Techniques S Watanabe IEEE Silver Spring MD 1982 113136 Information Processing ed Proceedings International Conference Frontiers Pattern Recognition Academic Press New York 1972 3654 71 M Broy Program construction transformations grammatical inference reprinted family tree sorting programs AW Biermann 1983 G Guiho eds Computer Program Synthesis Methodologies Reidel Dordrecht Netherlands I49 S RM Burstall J Darlington A transformation developing recursive programs J ACM 24 I 1977 4467 9 AK Chandra PM Merlin Optimal implementation conjunctive queries relational data bases Proceedings 9th ACM Symposium Theory Computing ACM New York 1977 7790 lo WF Clocksin CS Mellish Programming I1 N Dershowitz The Evolution Programs 121 N Dershowitz Programming Analogy Prolog Springer Berlin 4th ed 1994 Birkhluser Boston MA 1983 Machine Learning Vol II Morgan Kaufmann Los Altos CA 1986 393421 131 P Flener Y Deville Synthesis composition divideandconquer Wiley New York 1993 6796 1 141 MR Garey DS Johnson Computers Intractability A Guide Theory NPCompleteness discrimination JM Jacquet ed Constructing Logic Programs logic programs operators WH Freeman New York 1979 1151 D Gilbert C Hogger Deriving logic programs observations JM Jacquet ed Constructing Lugic Programs Wiley New York 1993 113126 161 EM Gold Language identification limit Inform Control 10 5 1967 447474 171 M Grobelnik Induction Prolog programs Markus Y Deville ed Logic Program Synthesis Transformation Proceedings LOPSTR 93 International Workshop Logic Program Synthesis Transformation Springer Berlin 1994 5763 Interactive program derivation program generated Y Deville ed Logic Program Synthesis Transformation Proceedings LOPSTR Springer Berlin 1994 IS AL Johansson strategies 93 International Workshop Logic Program Synthesis Transformation 100l 12 191 PD Laud inference refinement Technical Report TR376 Computer Science Department incrementahy Inductive schemata Yale University New Haven CT 1986 120 I I Laird Learning CT 1987 good data bad PhD Dissertation TR551 Yale University New Haven 121 I KK Lau SD Prestwich Topdown logic DHD Warren P Szeredi eds Logic Programming Proceedings Seventh recursive procedures firstorder synthesis specifications International Conference I22 I CL Liu Elements Discrete Mathematics McGrawHill New York 1977 MIT Press Cambridge MA 1990 667684 NL TinkhamArtificial Intelligence 98 1998 147 47 23 Z Manna R Waldinger A deductive approach program synthesis Nilsson eds Readings ACM Trans Programming Languages Systems 2 1 1980 12015 1 Artificial Intelligence Tioga Palo Alto CA 1981 141172 BL Webber NJ reprinted 24 RS Michalski implementation Techniques Inductive theory AW Biermann G Guiho Y Kodratoff eds Automatic Program Construction learning ruleguided generalization symbolic descriptions Macmillan New York 1984 5 17552 25 TM hilitchell Generalization 1261 GD Plotkin A note search Artificial Intelligence 18 2 1982 203226 B Meltzer D Mitchie inductive Intelligence Vol 5 Halsted Press New York 1970 153163 generalization eds Machine 27 GD Plotkin A note inductive generalization B Meltzer D Mitchie eds Machine fntelligence Vol 6 Halsted Press New York 1971 101124 28 I RJ Popplestone An experiment Intelligence Vol 5 Had 1291 JC Reynolds Transformational automatic deduction Press New York 1970 101124 systems algebraic B Meltzer D Mitchie eds Machine structute atomic formulas B Mehzer D Mitchie eds Machine Intelligence Vol 5 Halsted Press New York 1970 13515 I 30 EY Shapiro Inductive inference theories facts Research Report 192 Computer Science Department Yale University New Haven CT 1981 31 EY Shapiro An algorithm infers theories facts Proceedings IJCAI81 Vancouver BC 1981 I 446451 32 EY Shapiro Automatic Program Debugging 33 D Shaw W Swartout C Green Inferring LISP programs MIT Press Cambridge MA 1982 examples Proceedings IJCAI75 Tblisi Georgia 1975 260267 34 DR Smith The Structure Palo Alto CA 1988 Design Global Search Algorithms KESU8712 Kestrel Institute 1351 L Sterling M Kirschenbaum Applying techniques skeletons JM Jacquet ed Constructing Logic Programs Wiley New York 1993 127140 36 L Sterling E Shapiro The Art Prolog MIT Press Cambridge MA 2nd ed 1994 371 PD Summers A methodology LISP program construction examples J ACM 24 I 1977 161175 38 NL Tinkham Induction schemata program synthesis Technical Report CS199014 Duke University Durham NC 1990 1391 NL Tinkham A theorem refinement operators Rowan University Glassboro NJ 1997 logic program synthesis Technical Report TR971 40 LG Valiant A theory learnable Comm ACM 27 11 examples 41 PH Winston Learning structural descriptions 1984 1134l 142 PH Winston ed The Psychology Computer Vision McGrawHill New York 1975 157209