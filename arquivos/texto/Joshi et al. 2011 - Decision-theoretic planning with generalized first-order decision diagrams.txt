Artiﬁcial Intelligence 175 2011 21982222 Contents lists available SciVerse ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Decisiontheoretic planning generalized ﬁrstorder decision diagrams Saket Joshi Kristian Kersting b Roni Khardon c School Electrical Engineering Computer Science Oregon State University Corvallis OR 97331 USA b Knowledge Discovery Department Fraunhofer IAIS 53754 Sankt Augustin Germany c Department Computer Science Tufts University Medford MA 02155 USA r t c l e n f o b s t r c t Article history Received 19 February 2010 Received revised form 9 September 2011 Accepted 11 September 2011 Available online 16 September 2011 Keywords Knowledge representation Automated reasoning First order logic Model checking Markov decision process Dynamic programming Decision theoretic planning Many tasks AI require representation manipulation complex functions FirstOrder Decision Diagrams FODD compact knowledge representation expressing functions relational structures They represent numerical functions constrained Boolean range use existential quantiﬁcation Previous work developed set operations composition removing redundancies FODDs keeping compact showed successfully employ FODDs solving largescale stochastic planning problems formalism relational Markov decision processes RMDP In paper introduce new ideas enhancing applicability FODDs More speciﬁcally ﬁrst introduce Generalized FODDs GFODD composition operations generalizing FODDs arbitrary quantiﬁcation Second develop novel approach reducing GFODDs model checking This yields ﬁrst time reduction maximally reduces diagram FODD case provides sound reduction procedure GFODDs Finally GFODDs principle solve RMDPs arbitrary quantiﬁcation develop complete solution case reward function speciﬁed arbitrary number existential quantiﬁers followed arbitrary number universal quantiﬁers 2011 Elsevier BV All rights reserved 1 Introduction The problem autonomous agent acting optimally environment central Artiﬁcial Intelligence There variants problem For case stochastic dynamics environment known objective described reward function Markov decision processes MDP standard model 12 Classical dynamic programming algorithms solving MDPs 34 require explicit state enumeration This imprac tical number states grows quickly number domain objects relations For example domain predicate X Y n objects substituted X Y n2 ground propositions 2n2 potential states Classical solutions require enumeration 2n2 states In words classical dynamic programming solutions MDPs scale bigger problems size state space large One potential solution problem use structure representing state action spaces Many problems naturally described referring objects relations Relational representations naturally factor state space capture parameterized functions state space The past years seen successes approach ﬁeld Statistical Relational Learning 5 combines expressive knowledge representation formalisms Corresponding author Email address ronicstuftsedu R Khardon 00043702 matter 2011 Elsevier BV All rights reserved doi101016jartint201109001 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2199 statistical approaches perform probabilistic inference learning relational domains MDPs enhanced representations known relational ﬁrstorder MDPs Recently Boutilier et al 6 shown algorithms relational MDPs RMDP solve stochastic planning problems Inspired seminal work authors developed different representation schemes al gorithms implementing idea 710 In particular Wang et al 9 Joshi Khardon 11 introduced FirstOrder Decision Diagram FODD representation showed RMDPs solved FODDs provided prototype imple mentation performs problems International Planning Competition The use FODDs date main limitations The ﬁrst representation power FODDs roughly speaking represent existential statements allow universal quantiﬁcation This excludes basic planning tasks For example company plan physical meeting employees requires single location requiring quantiﬁer preﬁx goal goal expressed exists location employees location The second manipulation algorithms FODDs require special reductions ensure size small Such reductions introduced complete yield small FODD exists In article overcome limitations Speciﬁcally following contributions First introduce Generalized FODDs GFODD novel FODD variant allows arbitrary quantiﬁcation general aggregations values Basic algorithms allow perform operations functions represented GFODDs developed Second GFODDs solve RMDPs arbitrary quantiﬁcation Finally provide novel reduction approach based model checking This provides ﬁrst reduction FODDs guarantees resulting FODD maximally reduced sense deﬁned precisely technical section This signiﬁcantly stronger reduction ones existed previously FODDs In addition develop model checking reductions quantiﬁer setting GFODDs ﬁnite number existential quantiﬁers followed ﬁnite number universal quantiﬁers We enables solutions RMDPs reward functions given statements intermediate constructs algorithm maintained form The new representations algorithms developed form signiﬁcant extension scope FODD approach decisiontheoretic planning signiﬁcant improvement understanding reductions The new reductions presented paper relatively high complexity likely eﬃcient practice large diagrams However provide basis easytoimplement heuristic reductions FODDs In recent work 12 developed heuristic reductions heuristics generating models problem descriptions The new reductions provide signiﬁcant speedup planning time implementation theorem proving reductions maintaining stateoftheart performance problems international planning competition Model checking reductions important expanding applicability FODDs decision theoretic planning Practical implemen tations reductions GFODDs similarly important applicability Our results closely related recent work probabilistic inference large models In fact relational value iteration algorithm Boutilier et al 6 implementation algorithm GFODDs seen perform form lifted inference probabilistic models Recently algorithms advantage model structure inference proposed 1321 Whereas existing approaches essentially single ground model single ground question calculate numerical solution question solutions RMDPs family models potentially nonground question input calculate numerical solutions members family Of course planning models structure possible precisely structure algorithms advantage We proceed follows After brieﬂy reviewing FODDs present model checking reduction operator FODDs Section 3 Then Section 4 introduce GFODDs composition operations Section 5 extends model checking reduction operator GFODDs quantiﬁer setting Finally Section 6 shows utility GFODDs solving RMDPs To end devise value iteration approach RMDPs GFODDs Note knowledge RMDPs required development algorithms GFODDs deferred introduction RMDPs Section 6 2 Firstorder decision diagrams This section brieﬂy reviews previous work FODDs 9 We use standard terminology ﬁrstorder logic 22 A ﬁrst order decision diagram labeled directed acyclic graph nonleaf node exactly 2 outgoing edges labeled true false The nonleaf nodes labeled atoms generated predetermined signature predicates stants enumerable set variables Leaf nodes nonnegative numeric values The signature deﬁnes total order atoms FODD ordered parent smaller child according order Example 1 Two examples FODDs given Fig 1 diagrams paper left going edges represent branch taken predicate true right edges false branches Thus FODD similar formula ﬁrstorder logic Its meaning similarly deﬁned relative interpretations symbols An interpretation deﬁnes domain objects identiﬁes constant object speciﬁes truth value predicate objects In context relational MDPs interpretation represents state world objects relations Given FODD interpretation valuation assigns variable FODD 2200 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 Fig 1 Examples FODDs Left going edges represent branch taken predicate true right edges false branches Fig 2 A FODD example illustrating need DPOs object interpretation Following Groote Tveretina 23 semantics FODDs deﬁned follows If B FODD I interpretation valuation ζ assigns domain element I variable B ﬁxes truth value node atom B I The FODD B traversed order reach leaf The value leaf denoted MapB I ζ MapB I deﬁned maxζ MapB I aggregation MapB I ζ valuations ζ Example 2 Consider FODD Fig 1a interpretation I objects b true atoms pa qb The valuations xa ya xa yb xb ya xb yb produce values 0 1 0 0 respectively By max aggregation semantics MapB I max0 1 0 0 1 Thus FODD equivalent formula x y px q y In general max aggregation yields existential quantiﬁcation leaves binary When numerical values similarly capture value functions relational MDPs The following notation discuss FODDs properties If e edge node n node m targete m For node n symbols nt n f denote true false edges n respectively Furthermore ln denotes atom associated node n Node formulas NF edge formulas EF deﬁned recursively follows For node n labeled ln incoming edges e1 ek node formula NFn EFei The edge formula true outgoing edge n EFnt NFn ln The edge formula false outgoing edge n EFn f NFn ln These formulas variables existentially quantiﬁed capture conditions node edge reached Similarly B FODD p path root leaf B path formula p denoted PFp conjunction literals p When variables p existentially quantiﬁed satisﬁability PFp interpretation I necessary suﬃcient condition path p traversed valuation I If ζ valuation deﬁne PathB I ζ p The leaf reached path p denoted leaf p cid2 As seen FODDs represent functions relational structures These functions combined arith metic operations reduced order remove redundancies manner extends ideas developed propositional binary algebraic decision diagrams 2425 In particular Groote Tveretina 23 introduced reduction oper ators R1 R4 augmented seven reductions R5 R11 911 Intuitively redundancies FODDs arise different ways In ﬁrst scenario edges traversed valuation Reduction operators redundancies called strong reduction operators The second scenario requires subtle analysis parts FODD traversed valuations max aggregation valu ations traverse parts important determining map Operators redundancies called weak reductions operators Strong reductions preserve MapB I ζ valuation ζ preserving MapB I weak reductions preserve MapB I necessarily MapB I ζ ζ Using classiﬁcation R1R5 strong reductions R6R11 weak reductions Weak reductions basis idea parts FODD dominate map parts dominated removed replaced 0 leaf However cases parts FODD dominate Example 3 Consider FODD Fig 2 This simple FODD contains 2 paths leading nonzero leaves 1 px p y 1 2 px pz 1 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2201 Notice valuation traversing paths valuation traversing reaching leaf Either edges reaching 1 leaf point 0 leaf changing map However allow edges point zero leaf change map interpretations To avoid ambiguity specify total order paths way choose path remove A descending path ordering DPO constructed speciﬁcally purpose Deﬁnition 1 A descending path ordering DPO ordered list paths root leaves FODD sorted descending order value leaf reached path The relative order paths reaching leaf set arbitrarily A DPO provides preference ordering paths Paths different values naturally ordered values incorporated DPO Paths value ordered according arbitrary ordering DPO paths lower index preferred paths higher index This preference captured notion instrumental paths deﬁned Deﬁnition 2 If B FODD PL DPO B path p j PL instrumental respect PL iff interpretation I 1 valuation ζ PathB I ζ p j 2 valuations η PathB I η pk k cid2 j Paths instrumental removed diagram changing function computes The choice DPO affect size reduced diagram clear outset best choose DPO maximally reduce size diagram This illustrated discussed context R12 reduction Finally additional subtlety arises RMDP domains background knowledge predicates domain specifying constraints For example blocks world block clear onx false values x This fact help simplify diagram We denote background knowledge B allow reductions rely knowledge 3 R12 The model checking reduction FODDs In section introduce new reduction operator R12 numbered agree previous work The basic intuition R12 use semantics FODD directly reduction process According semantics FODDs map generated aggregation values obtained running possible valuations FODD Therefore run possible valuations diagram document paths taken valuations possible interpretations identify parts diagram important determining map Such parts eliminated reduce diagram Crucially bookkeeping possible obtain information enumerating possible interpretations enumerating possible valuations variables diagram This basic intuition R12 We avoid enumerating possible interpretations observation interpreta tions set domain objects ﬁxed number paths FODD valuation traverse For given valuation ζ interpretation classiﬁed set equivalence classes based path p forces ζ All interpretations belonging equivalence class following common 1 They force ζ path p leaf p leaf reached path p 2 They consistent PFpζ PFpζ general interpretation forces ζ p viewed key identiﬁer equivalence class For purpose reduction interested interpretations paths force valuations Therefore restrict attention equivalence classes avoid enumerating possible interpretations In words collect abstract interpretation PFpζ path p valuation ζ possibly path PFpζ consistent corresponding path leaf reached information need behavior ζ possible interpretations The procedure getBehaviors described exactly simulating run valuation FODD The output procedure set cid9leaf EL Icid10 3tuples leaf leaf reached valuation ζ traversing path p described set edges EL I PFpζ Recall B denotes background knowledge domain The procedure follows 2202 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 Fig 3 An example reduction operator R12 FODDs Each entry form valuepathinterpretation table enclosing angle brackets removed ﬁgure improve readability expresses value obtained running valuation corresponding row diagram equivalence class interpretations The max3 aggregation function calculates possible aggregates generated different equivalence classes interpretations Since edge 1 f appear paths result max3 important determining map removed Procedure 1 getBehaviorsvaluation ζ PathFormula PF EdgeList EL Node n 1 If n leaf return ln EL PF 2 If B cid11 PF lnζ return getBehaviorsζ PF lnζ EL nt targetnt Else If B cid11 PF lnζ return getBehaviorsζ PF lnζ EL n f targetn f Else return getBehaviorsζ PF ln EL nt targetnt getBehaviorsζ PF ln EL n f targetn f Example 4 Fig 3 shows example R12 reduction details developed For example focus table center ﬁgure The table illustrates result running getBehaviors procedure possible valuations set domain objects b variables x y appearing left FODD For example traversal valuation xa yb FODD 3 possible eventualities Either reaches 10 leaf traversing path 1t short path consisting true edge node 1 abstract interpretation pa reaches 10 leaf traversing path 1 f 2t short path consisting false edge node 1 followed true edge node 2 abstract interpretation pa pb cases reaches 0 leaf Note different behaviors valuation mutually exclusive abstract interpretations associated behaviors partition space worlds Any interpretation consistent exactly abstract interpretations force behavior corresponding abstract interpretation valuation Thus Fig 3 help getBehaviors procedure tabulate possible behaviors valuations set domain objects The step generate possible ways aggregate value derived This enumerating interpretations The table potential behaviors gives suﬃcient information list possible ways aggregate set valuations considering combinations behaviors set valuations Every combination long consistent produces map aggregate value To facilitate reduction aggregation augmented expose valuations paths prove important determining map Intuitively paths shown important spite listing possible ways aggregate set valuations removed To end section introduces variants max aggregation function max2 max3 31 Generalized aggregation function R12 reduction When calculating map max aggregation operation applied values obtained evaluating FODD different valuations As discussed R12 interested aggregate value information help identify edges determine map Toward calculating maximum S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2203 collect information winning path valuation leads interpretation captured ground path formula happens To enable accounting deﬁne variants max aggregation operator max1 The ﬁrst variant max1 usual aggregation operator given set values v 1 vn returns aggregate v maxv 1 vn max2 requires DPO calculate output The input max2 set 3tuples form cid9v pathi I icid10 intention 3tuple produced getBehaviors different valuation ζi The output 3tuple cid9vo patho Iocid10 1 vo max1v 1 v 2 vn 2 Io 3 patho cid3 n i1 I pathi pathi index DPO paths value vo In words max2 takes input possible behavior valuation entry row valuation table Fig 3 aggregates result recording winning path interpretation induces corresponding behavior valuation Example 5 The example Fig 3 shows DPO 3 possible aggregation results derived table Each 3 results derived max2 variant For example aggregating cid910 1t pacid10 xa ya cid910 1t pacid10 xa yb cid910 1t pbcid10 xb ya cid910 1t pbcid10 xb yb max2 variant gives cid910 1t pa pbcid10 indicating possible aggregation path consisting edge 1t instrumental determining map The example illustrates max2 captures combined behavior valuations interpretation I0 output As motivated like capture information possible interpretations Instead enumerating interpretations generate possible scenarios considering possible ways rows table produced getBehaviors combined This max3 max3 requires DPO calculate output The input max3 set sets 3tuples set 3 tuples associated valuation corresponds entire table Fig 3 denoted T cid9valuation1 valueset1cid10 cid9valuation2 valueset2cid10 cid9valuationn valuesetncid10 Let T Cartesian product valuesetcid4 ei T set tuples cid9value path Interpretationcid10 cid13 cid13 max3T deﬁned cid4 max3T cid9valuer pathr Ircid10 max2ei cid5 cid5 ei T cid13 valuer cid2 0 Ir consistent cid6 Thus max3T collection results max2 applied element T combined interpretation consistent aggregate value greater zero cid13 restricted cases Example 6 The example Fig 3 shows result applying max3 elements table There 2 3 3 2 36 possible combinations valuation behaviors 36 elements T corresponding calls max2 However 3 combinations result consistent combined interpretation positive value For example given DPO max2cid910 1t pacid10 cid910 1t pacid10 cid910 1 f 2t pa pbcid10 cid910 1t pbcid10 cid910 1t pa pb pbcid10 omitted result max3T combined abstract interpretation consistent Aggregations resulting 0 value ignored 0 smallest obtainable value uninteresting max aggregation semantics Observe example path 1t instrumental path Intuitively implies target edge path instance edge 1 f set 0 changing map The resulting FODD shown right cid13 Example 7 Consider example Fig 3 DPO reverses order paths 1 2 In case table produced getBehaviors identical aggregated value But maximizing paths The outputs max3 cid910 1t pa pbcid10 cid910 1 f 2t pa pbcid10 andcid910 1 f 2t pa pbcid10 Thus case paths instrumental reduction achieved This illustrates choice DPO important reducing diagram However clear best choose DPO A preference shorter paths defaults lexicographic ordering equal length paths makes easy implementation best Our implementation 1112 heuristically alternates DPO reverse hope enabling reductions 2204 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 The reduction formalized Procedures 2 3 Procedure 2 R12FODD B 1 Let PL DPO B 2 Let O set v objects v number variables B 3 Let U set possible valuations variables B O 4 Let S output ReductionAggregationB U PL That S cid9value1 path1 I1cid10 cid9value2 path2 I2cid10 cid9valuen pathn Incid10 cid13 set edges appear path pathi 3tuple set S 5 Let E 6 Deﬁne E B E E 7 For edges e E set targete B 0 produce FODD B 8 Return B B E set edges B cid13 cid13 cid13 Procedure 3 ReductionAggregationFODD B set valuations U DPO PL 1 Let Val 2 Do valuation ζ U 21 valueset getBehaviorsζ B root 22 Add entry cid9ζ valuesetcid10 Val 3 Let T max3Val PL 4 Return T 32 Proof correctness This section shows R12 procedure removes exactly right edges input FODD The proof relies lemma shows instrumental path potential interpretation I discovered procedure This shown arguing small portion I suﬃces purpose portion constructed R12 Lemma 1 If path pi FODD B instrumental PL path reaches nonzero leaf exists interpretation Io leaf pi pi Io set S calculated Step 4 R12 procedure cid13 cid13 Proof If pi instrumental PL exist I ζ PathB I ζ pi η PathB I η cid13 cid3 O O set objects p j implies j cid2 Let O sets O constructed Step 2 algorithm Let o1 object O O deﬁning truth values predicates new objects behave identically o1 cid13 new objects O Add O O ﬁrst projecting I include objects O set objects I participate ζ Clearly 1 cid3 O equal size Construct interpretation I includes relevant portion I valuation ζ traverses pi I cid13 ˆζ p j j construct valuation ˆζ cid13 PathB I PathB I ˆζ cid13 p j But possible assumption Therefore conclude η PathB I j cid2 Additionally exists valuation ˆζ replacing new objects ˆζ o1 cid13 η p j implies Since I cid13 cid13 cid13 cid13 cid13 cid13 Let U set valuations variables B O cid13 participate traversing paths B η U By construction corresponding parts PFPathB I atoms I included valueset returned getBehaviors procedure Clearly Io I Io By deﬁnition max3 S max3Val PL contain leaf pi pi Io leaf pi nonzero cid2 Therefore I cid13 cid13 ηη That Io includes cid13 ηη consistent cid13 cid3 cid13 Let Io ηU PFPathB I The proof previous lemma implicitly assumes signature include equality truth value changes objects reassigned The lemma subsequent discussion allow equality having steps 2 4 R12 repeated object set sizes v step 5 union exposed edges This makes longer arguments adding signiﬁcant insight focus simpler version paper The previous lemma implies discover edges instrumental paths turn implies removing edges change map diagram This intuition captured lemma theorem Lemma 2 If exists instrumental path PL contains edge e B path reaches nonzero leaf e set E calculated Step 5 R12 procedure cid13 Proof If instrumental path pi PL contains edge e reaches nonzero leaf Lemma 1 exists interpretation Io leaf pi pi Io S By deﬁnition E e E cid2 cid13 cid13 Theorem 1 Soundness For FODD B FODD B cid13 output R12B interpretations I MapB I MapBcid13 I S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2205 Fig 4 Example R12 reduce diagram previous reductions fail cid13 cid13 Proof By deﬁnition R12 difference B B point 0 leaf B crossing edges achieves value 0 B Valuations crossing edges achieve value B valuation ζ MapB I ζ cid2 MapBcid13 I ζ MapB I cid2 MapBcid13 I edges pointed subFODDs B These edges set E end R12 procedure Therefore valuation achieved higher value B interpretation B Therefore interpretation I Fix interpretation I v MapB I Let ζ valuation MapB I ζ v If ζ gives value v choose path p j index PL By deﬁnition p j instrumental Lemma 2 leaf p j 0 edges p j removed R12 In cases MapBcid13 I ζ v MapB I By deﬁnition max aggregation semantics MapBcid13 I cid2 MapBcid13 I ζ MapBcid13 I cid2 MapB I cid2 cid13 cid13 We reduction achieved R12 best possible respect notions DPO instru mental paths Theorem 2 Maximum reduction wrt DPO If path crossing edge e reaching nonzero leaf B instrumental PL R12 removes e Proof By deﬁnition set edges B partitioned sets E E exist path pi PL interpretation Io e edge pi leaf pi nonzero leaf pi pi Io set S calculated Step 4 R12 procedure The existence leaf pi pi Io S implies Io valuation ζ U PathB Io ζ pi η U PathB Io η p j implies j cid2 Therefore pi instrumental Therefore edges E belong instrumental path This implies e statement theorem E cid13 removed R12 cid2 Now construction e E cid13 cid13 cid13 33 Discussion The R12 procedure provides comprehensive reduction operation FODDs guaranteeing maximum reduction wrt DPO This contrast fact previous published reductions taken provide guarantee The main reason previous reduction operators rely theorem proving single path formulas edge implications As following example shows cases reduction operators fail reduce diagram R12 successful Example 8 Fig 4 shows example R12 succeeds previous reductions fail Notice paths reaching 10 leaf left FODD In diagram valuation reaches 1 leaf valuation reaches 10 leaf paths However path formulas individually implied formula path reaching 1 leaf Similarly edge formulas edges terminating 10 leaf implied edge formula edge terminating 1 leaf R12 hand relies model checking able reduce FODD left FODD right It important note principle deﬁne theorem proving reduction giving guaran tees1 For example state path instrumental write cid7 cid8 xpi PFpi cid9cid10 cid7 cid11 cid8 xp j PFp j ji The path instrumental formula satisﬁable Thus theorem proving provide maximum reduction respect DPO way R12 However theorem proving complex involves 1 We grateful anonymous reviewer suggested 2206 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 disjunctive reasoning In fact R10 reduction 11 performs similar reasoning checks paths j cid3 time order simpler theorem proving provide guarantees More importantly formulation signiﬁcant disadvantage shared R10 enumerates paths index smaller The main point adopting decision diagram representation decision tree fact diagram exponentially smaller repeated subtrees represented decision diagram In words number paths diagram exponential size In case enumerating paths DPO practical theorem proving formulation fail In contrast R12 need generate DPO explicitly Instead procedure needs able compare paths max3 decide higher DPO As mentioned easy perform eﬃciently suitably chosen DPOs ones preferring shorter path lexicographic ordering Therefore number paths large R12 superior theorem proving formulation On hand complexity R12 high involves enumeration possible valuations exponential number variables Therefore direct implementation R12 speciﬁed practical FODDs large number variables In recent work introduced heuristic variants R12 eﬃcient shown lead signiﬁcant speedup theorem proving reductions 12 Finally R12 distinguished previous reductions fact employs aggregation function FODD main subroutine Therefore imagine generalizing diagrams containing aggregation functions Indeed sections deﬁne generalized diagrams model checking reductions Corresponding generalized variants reductions based theorem proving easy obtain 4 Generalized FODDs Syntax semantics The max aggregation FODDs makes suﬃciently expressive represent planning problems However max aggregation mirrors existential quantiﬁcation variables FODD functions logical spaces represented FODDs These functions represented aggregation function complex This idea captured following deﬁnition Deﬁnition 3 An aggregation function function f takes input nonempty set real values returns real value Concrete examples aggregation functions discussed include max min sum mean Other functions like product variance possible We pay special attention min aggregation allows capture universally quantiﬁed formulas In section discuss properties generalized FODDs arbitrary aggregations operations performed manipulate We start formal deﬁnition Generalized FirstOrder Decision Diagrams Deﬁnition 4 A Generalized FirstOrder Decision Diagram GFODD 2tuple cid9V Dcid10 1 V ordered list pairs v opv v variable opv 2 The variables v distinct v exactly aggregation operator V 3 D FODD leaves labeled special character D discard aggregation operator An example GFODD given Fig 5 The corresponding list V formal speciﬁcation c max b min use intuitive alternative notation maxc minb maxc minb clear context The discard value D deﬁnition allows paths diagram provide value This useful multiple types aggregations need default value like value zero max aggregation affect result This simpliﬁes implementation analysis reductions presented 41 Semantics GFODDs The semantics GFODDs follow approach FODDs ﬁrst calculate map valuations aggregate values Whereas FODDs maximum values computation GFODDs complex follows aggregation function To simplify notation following B cid9V Dcid10 ζ valuation refer MapD I ζ MapB I ζ Formally let B cid9V Dcid10 GFODD V v 1 op1 v1 v 2 op2 v2 vn opn vn let I interpretation The map value MapB I deﬁned following steps 1 Each valuation ζ mapping v 1 vn domain interpretation I associated value MapD I ζ 2 We divide valuations blocks All valuations block assignment values variables S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2207 Fig 5 A generalized FODD example v 1 vn1 differ value variable vn 3 We collapse block single valuation variables v 1 vn1 eliminating variable vn replacing set associated values aggregate value If values block value D aggregate value D Otherwise remove D set values apply opn remaining set This yields table set possible valuations deﬁned variables v 1 vn1 associated value obtained aggregating valuations variable vn block 4 We repeat procedure variables vn1 v 1 produce ﬁnal aggregate value The value MapB I ﬁnal aggregate value The treatment D values step 3 captures idea ignoring corresponding paths calculating aggregate value Thus D inputs aggregation operator ignored values D information passed level Example 9 The GFODD B Fig 5 captures following statement logistics domain There exists city c boxes b box b city c The output B 10 boxes city 0 otherwise2 In example GFODD shown V c max b min Aggregation right left variable time In example table left shows value MapB I ζ possible valuation ζ MapB I calculated ﬁrst aggregating values MapB I ζ assignments variable b min aggregation This yields table middle We aggregate produced values assignments variable c max operation The resulting value 0 case MapB I In following need notation refer map value calculation The procedure described seen perform aggregation variables V nesting aggregation operators left outermost right innermost MapB I op1 v1 cid7 op2 v2 cid7 cid7 opn vn cid7 MapB cid12 I v 1 v 2 vn cid13cid8cid8 cid8cid8 The term center MapB I v 1 v 2 vn value obtained running valuation deﬁned assignment variables v 1 vn B I In order reduce notational clutter rest paper drop brackets equation looks follows op2 v2 opn vn cid7 cid12 MapB I v 1 v 2 vn cid13cid8 op1 v1 op2 v2 opn1 vn1 opn cid7 c v1vn1 1 c v1vn1 m cid8 value corresponding different object assignment variable vn block deﬁned MapB I op1 v1 v1vn1 c values assigned variables v 1 vn1 42 Basic properties GFODDs Several observations GFODDs semantics First order variables V important Chang ing order variables obviously change map diagram Second FODDs form proper subclass GFODDs aggregation operator associated variable max In case properties max aggregation order variables V important Third GFODDs 01 leaves express functions closed functionfree ﬁrstorder formulas In particular employing min aggregation operator universally quantiﬁed variables max aggregation 2 In example GFODD diagram simple assume variables typed use valuations conform types variables Had possible valuations set objects b1 b2 c1 c2 diagram complicated represent formula c b cityc boxb inb c 2208 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 Table 1 List safe unsafe pairs operators opc max max max max opa max min sum avg max min sum avg max min sum av g Safeunsafe safe safe unsafe safe safe safe safe safe safe safe unsafe unsafe operator existentially quantiﬁed variables To consider GFODD cid9V Dcid10 01 leaves let F quantiﬁerfree formula capturing disjunction path formulas paths leading 1 leaf Then interpreting V quantiﬁers V F closed ﬁrst order formula evaluates true exactly cid9V Dcid10 evaluates true On hand given closed ﬁrstorder formula prenex normal form V F F disjunctive normal form build FODD D representing conjunct F FODD directly represent disjunction apply procedure Wang et al 9 Now cid9V Dcid10 equivalent V F Finally deﬁnition allows ﬁnal aggregate value D case reachable paths I yield value D To ensure GFODDs represent deﬁned functions disallow case Deﬁnition 5 A GFODD B legal iff obeys GFODD syntax interpretations I valuation ζ MapB I ζ cid17 D 43 Combining GFODDs So far focused syntax semantics GFODDs represent complex functions relational structures The utility representation performing operations functions example max taking maximum addition multiplication We operators combination operators provide algorithm Exapply implement Notice combination operators operate functions different aggregation operators operate sets real values The deﬁnition provides intended meaning combination Deﬁnition 6 GFODD B combination GFODDs B 1 B2 binary combination operator opc iff interpretations I MapB I MapB1 I opc MapB2 I In assume functions represented B 1 B2 independent variables aggregate constrain In principle try deﬁne meaning combination variable appears diagrams aggregated similarly However awkward necessary calculus functions use Therefore following assume functions combined share variables quantiﬁerfree portion standardized apart Aggregation combination operators interact complicating result combination operation In follow ing cases happen essentially use algorithm combines FODDs combine GFODDs This captured following condition combination aggregation operators Deﬁnition 7 A combination operator opc aggregation operator opa safe pair iff opc distributes opa iff set nonnegative values x1 x2 xk nonnegative constant b holds opax1 x2 xk opc b opax1 opc b x2 opc b xk opc b Example 10 The aggregation operator max combination operator form safe pair set S c1 cm constant b maxc1 cm b maxc1 b cm b The aggregation operator mean combination op erator max form safe pair For example maxmean1 5 3 4 4 meanmax1 4 max5 4 max4 4 mean4 5 4 433 Table 1 summarizes safe unsafe pairs operators We later use fact max min aggregation operators safe combination operators listed As mentioned condition allow use simple algorithm combination The cases safe processed algorithms leave details future work S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2209 Fig 6 A simple example adding FODDs We review details procedure applyB 1 B2 op combining FODDs B1 B2 operation op 9 Recall FODDs use ordering atoms labeling nodes atoms higher ordering higher diagram Let p q roots B 1 B2 respectively The apply procedure chooses new root label lower labels p q recursively combines corresponding subdiagrams according relation labels cid19 Example 11 Fig 6 illustrates operation apply procedure In example assume predicate ordering p1 p2 parameter ordering x1 x2 Nonleaf nodes annotated numbers numerical leaves underlined identiﬁcation execution trace For example level adds functions corresponding nodes 1 3 Since p1x1 smaller label picked label root result Then add left right child node 1 node 3 These calls performed recursively yield diagram right The lemma Wang et al 9 shows apply procedure provides correct map valuation Lemma 3 See 9 Let C apply A B op I ζ MAP AI ζ op MAPB I ζ MAPC I ζ We deﬁne combination procedure GFODDs prove correctness Deﬁnition 8 Let B1 cid9V 1 D1cid10 B2 cid9V 2 D2cid10 GFODDs V 1 V 2 variables common let opc combination operator ExapplyB1 B2 opc returns cid9V Dcid10 1 V aggregation function obtained appending V 2 V 1 2 D applyD1 D2 opc To procedure correct start observing combining diagram B constant generate diagram leaf node value constant push combination operation leaves Lemma 4 Let B cid9V Dcid10 GFODD b nonnegative constant opc combination operator If aggregation operator opa V opa opc safe pair interpretations I MapB I opc b op1 v1 MapB I v 1 v 2 vn opc b opn vn op2 v2 Proof The proof induction n number operators variables V By semantics GFODDs cid13cid8 cid12 cid7 MapB I opc b op1 v1 opn vn MapB I v 1 vn opc b When n 1 MapB I opc b op1 v1 cid12 cid7 MapB cid13cid8 I v 1 opc b op1 v1 cid7 MapB cid12 cid13 I v 1 opc b cid8 op1 opc form safe pair Assume statement true V n 1 fewer aggregation operators Consider V n aggregation operators We cid13cid8 cid12 cid8 cid7 opc b op1 v1 v1 1 c v1 m opc b cid7 c MapB I opc b op1 v1 op1 v1 opn MapB vn cid7 v1 opc b c c 1 cid8 I v 1 vn v1 m opc b v1 op1 opc form safe pair Here c v 1 By inductive hypothesis know cid13cid8 cid12 op2 v2 opn vn cid7 MapB I v 1 v 2 vn opc b op2 v2 op2 v2 opn vn MapB I v 1 v 2 vn ith value variable opn vn cid7 MapB cid12 cid13 I v 1 v 2 vn cid8 opc b 2210 Thus S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 MapB I opc b op1 v1 op2 v2 opn vn cid7 cid12 cid13 I v 1 v 2 vn cid8 opc b MapB cid2 The theorem uses lemma repeatedly different constants prove correctness Exapply Theorem 3 Let B1 cid9V 1 D1cid10 B2 cid9V 2 D2cid10 GFODDs share variables assume opc forms safe pair operators V 1 V 2 Then B cid9V Dcid10 ExapplyB1 B2 opc combination B1 B2 operator opc Proof Let opi j v j denote ith operator variable respectively V j V concatenation V 1 V 2 deﬁnition Exapply Therefore deﬁnition GFODD semantics interpretation I cid7 MapB I v 11 vn1 v 12 vm2 MapB I op11 v11 opm2 vm2 opn1 vn1 op12 v12 cid13cid8 cid12 Since D applyD1 D2 opc Lemma 3 interpretations I valuations ζ MapD I ζ MapD1 I ζ opc MapD2 I ζ In addition variables V 1 V 2 disjoint write valuation ζ ζ1ζ2 ζ1 subvaluation ζ variables V 1 ζ2 subvaluation ζ variables V 2 Thus write MapB I op11 v11 opn1 vn1 op12 v12 opm2 vm2 cid7 MapB1 cid12 cid13 I v 11 vn1 cid12 opc MapB2 I v 12 vm2 cid13cid8 Now important observation MapB1 I v 11 vn1 depend variables V 2 aggre gating variables V 2 MapB1 I v 11 vn1 treated constant Since opc forms safe pair aggregation operators V 2 Lemma 4 cid12 cid13cid13cid13 cid12 cid12 cid12 MapB I op11 v11 op11 v11 opn1 vn1 opn1 vn1 cid12 MapB1 MapB1 cid12 cid13 I v 11 vn1 cid13 I v 11 vn1 opm2 opc op12 v12 vm2 cid13 opc MapB2 I MapB2 I v 12 vm2 Similarly aggregating variables V 1 MapB2 I treated constant depend value variables V 1 Since opc forms safe pair aggregation operators V 1 Lemma 4 cid13cid13 cid12 cid12 MapB I op11 v11 opn1 vn1 MapB1 I v 11 vn1 opc MapB2 I MapB1 I opc MapB2 I Thus deﬁnition B ExapplyB 1 B2 opc combination B1 B2 combination operator opc cid2 The following theorem strengthens result showing Exapply freedom reordering aggregation operators maintaining correctness This property useful solution RMDPs Theorem 4 Let B1 cid9V 1 D1cid10 B2 cid9V 2 D2cid10 GFODDs share variables assume opc forms safe pair operators V 1 V 2 Let B cid9V Dcid10 ExapplyB1 B2 opc Let V permutation V long relative order operators V 1 V 2 remains unchanged let B cid13 Dcid10 Then interpretation I MapB I MapBcid13 I cid13 cid9V cid13 k V 2 F 2 F 1 Proof Let V 1 F 1 k F 2 1 F 1 1 F 2 tors V Then V V 2 remains unchanged By semantics GFODDs 1 F 1 2 cid13 F 1 F 1 F 2 2 F 2 2 2 k F 1 F 2 j series zero consecutive aggregation opera k represents permutation V relative order operators V 1 MapBcid13 I F 1 1 F 2 1 F 1 k F 2 k MapB cid12 cid13 I v 11 vn1 v 12 vm2 v j variable B j Now applying Lemma 3 cid7 MapB1 cid13 I v 11 vn1 MapBcid13 I F 1 F 1 k F 2 1 F 2 opc MapB2 cid12 1 k cid12 I v 12 vm2 cid13cid8 Since B1 B2 share variables opc forms safe pair operators V 1 V 2 following sequence equations step use Lemma 4 fact arguments constant respect corresponding block aggregation operators 1 MapBcid13 I F 1 F 1 1 F 2 1 F 2 1 F 1 k F 2 cid12 cid7 MapB1 cid7 F 1 k MapB1 k1 cid13 I v 11 vn1 cid12 opc F 2 cid13 I v 11 vn1 k MapB2 opc F 2 cid12 k MapB2 cid12 I v 12 vm2 I v 12 vm2 cid13cid8 cid13cid8 F 1 1 F 1 k MapB1 cid12 cid13 I v 11 vn1 opc F 2 1 F 2 k MapB2 cid12 cid13 I v 12 vm2 Finally Theorem 3 term equal MapB I implying MapBcid13 I MapB I cid2 5 Model checking reductions GFODDs S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2211 The R12 procedure introduced Section 3 extended operate GFODDs In section present extensions R12 forms aggregation functions The ﬁrst set diagrams min aggregation The second set diagrams max aggregation In case aggregation function consists series zero max operators followed series zero min operators For case introduce variants R12D R120 differing computational costs quality reduction We discuss turn starting R12 procedure min operator min 51 R12 min aggregation The case min aggregation obtained dual max aggregation case However worthwhile considering explicitly building block construction The notion instrumental paths dual notion instrumental paths max aggregation Deﬁnition 9 If B GFODD min aggregation function PL DPO B path p j PL instrumental respect PL iff interpretation I 1 valuation ζ PathB I ζ p j 2 valuations η PathB I η pk k cid3 j The generalized aggregation function min aggregation operator max operator max replaced min special treatment given paths reaching 0 leaf We min3 generalized aggregation function Notice max aggregation choose reachable path smallest index instrumental record max3 min3 pick reachable path greatest index instrumental The reduction procedure identical case max aggregation min3 instead max3 edges E targets replaced discard value D instead 0 This strictly necessary replace target edges large value But useful preparation construction A trivial adaptation proofs previous section yields corresponding properties min aggregation Lemma 5 If path pi GFODD B instrumental PL exists interpretation Io leaf pi pi Io S Lemma 6 If exists instrumental path PL contains edge e B e E cid13 Theorem 5 Soundness For GFODD B min aggregation GFODD B tions I MapB I MapBcid13 I cid13 output R12B interpreta Theorem 6 Maximum reduction wrt DPO If path crossing edge e B instrumental PL R12 removes e 52 Model checking reduction max min aggregation This section concerned GFODDs employing max aggregation The aggregation function consists series min zero max operators followed series zero min operators The aggregation function V split V l variables aggregated max aggregation operator V r variables aggregated min aggregation operator Thus V V l V r We use superscripts l r left right refer corresponding blocks max min variables The set U possible valuations variables B split U l U r sets valuations variables V l V r respectively Any valuation ζ U written ζ lζ r ζ l U l ζ r U r Thus deﬁnition GFODD semantics interpretation I cid13cid8 cid14 cid12 cid12 cid7 MapB I op1 v1 opn vn cid7 MapB I v 1 vn max ζ lU l min ζ r U r MapB cid13cid8cid15 I ζ lζ r 521 The procedure R12D Our ﬁrst reduction operator captures simple notion instrumental paths The intuition view model evaluation performed blocks First ζl assignment objects V l max variables perform min competition valuations V r Each ζl associated path value won min competition perform max competition corresponding values Therefore path wins min competition able change value changing map diagram The new value chosen carefully affect min max competition interpretation requires complex analysis Instead choosing concrete value change value D This makes sure path win min max competitions change ﬁnal value diagram 2212 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 Fig 7 An example reduction operator R12D GFODDs max Aggregation Each entry form valuepathinterpretation table enclosing angle brackets removed ﬁgure improve readability expresses value obtained running valuation corresponding row diagram equivalence class interpretations The min3 aggregation function applied block case block ζ l variable x associated max aggregation operator calculates possible aggregates generated different equivalence classes interpretations Since edge 3t appear paths result min3 instrumental removed min We proceed technical details idea A path instrumental wins min competition inter pretation I Deﬁnition 10 If B GFODD max instrumental iff interpretation I valuation ζ ζ lζ r ζ U ζ l U l ζ r U r aggregation function P DPO B path pi P min 1 PathB I ζ pi 2 For ηr U r PathB I ζ lηr p j j cid3 P The R12D procedure max min following exceptions aggregation identical R12 procedure min aggregation 1 Recall variables split V l max aggregation followed V r min aggregation The set U valuations built following way Let O l set V l objects O r set V r objects O l O r disjoint Let U l sets possible valuations variables V l objects O l let U r set possible valuations variables V r objects union O l O r The set U deﬁned U ζ lζ r ζ l U l ζ r U r The set valuations U captures arbitrary valuation variables V l objects O l constrained Similarly valuation V r constrained allows bind objects O l objects O r serves unconstrained objects The proof shows set suﬃcient expose instrumental paths 2 The set S deﬁned S ζ l ReductionAggregationB U ζ l PL U ζ l block valuations corresponding ζ l Thus set Val procedure divided blocks containing set valuations ζ l S union sets generated result applying ReductionAggregation min3 block Val cid3 Example 12 Fig 7 shows small example reduction The process similar R12 procedure max aggregation generalized aggregation function A DPO ﬁrst established shown Sets O l O r b constructed table Val generated running getBehaviors procedure valuations generated Finally Val consists single block variable associated max operator min3Val evaluated produce 5 cid9leaf path Interpretationcid10 3tuples shown For example combining 01t2 f 3 f pa qa 101t2 f 3t4tpa qa qb rb min3 01t2 f 3 f pa qa qb rb The targets edges ones present paths resultant 3tuples concretely edge 3t replaced value D S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2213 The proof correctness follows outline accounts extra aggregation operators We ﬁrst instrumental path potential interpretation I discovered procedure Lemma 7 If path pi GFODD B employing max Io leaf pi pi Io set S calculated R12D procedure min semantics instrumental PL exists interpretation cid13 l 1 cid13 r cid13 l o Proof If pi instrumental PL exists interpretation I set objects O I valuation ζ ζ lζ r cid13 l set objects PathB I ζ pi ηr PathB I ζ lηr p j j cid3 PL Let O cid13 r cid3 cid13 l cid3 V l 1 cid3 O participate ζ l let O cid13 r V r Let o O 1 cid13 r set objects participate ζ r ζ l Clearly 1 cid3 O O cid13 Construct interpretation I cid13 r deﬁning truth values cid13 r predicates new objects O sets O l O r R12D procedure generate set valuations U The set U split blocks valuation η ηlηr belonging U assigned block corresponding ηl Let U ζ l block corresponding ζ l cid13 r Add V l O cid13 l V r O cid13 l new objects O ﬁrst projecting I include objects O cid13 r new objects O cid13 l O cid13 r 1 respectively Let O cid13 r behave identically o cid13 l 1 o cid13 l O cid13 l O Let Io Since ζ U ζ l I contains relevant portion I ζ traverses pi I Additionally valuation η U ζ l cid13 η p j j PL construct valuation ˆη ηl ˆηr replacing new objects cid13 r 1 PathB I ˆη p j However know ˆη exists Therefore η U ζ l cid3 cid13 η p j j PL PathB I ˆηr o PathB I cid13 ηη That Io includes atoms I participate traversing paths B cid13 ηη included valueset returned valuations U ζ l By construction corresponding parts PFPathB I getBehaviors procedure Clearly Io I consistent Io If Valζ l block Val corresponding valuations U ζ l deﬁnition min3 min3Valζ l contain entry leaf pi pi Io Finally min3Valζ l subset S S contain leaf pi pi Io cid2 Therefore I PFPathB I ηU ζ l cid13 cid13 cid13 cid13 cid13 The lemma implies edges instrumental paths discovered result replacing values edges D change map diagram This intuition formalized lemma theorem Lemma 8 If exists instrumental path B PL contains edge e e E cid13 Proof If instrumental path pi PL contains edge e Lemma 7 exists interpretation Io leaf pi pi Io S By deﬁnition E e E cid2 cid13 cid13 Theorem 7 Soundness For GFODD B max tations I MapB I MapBcid13 I min aggregation GFODD B cid13 output R12DB interpre Proof By deﬁnition R12D difference B B edges pointed subFODDs cid13 B point discard leaf D B These edges set E end R12D procedure Therefore valuation crossing edges discarded aggregation function Valuations crossing edges achieve value B B cid13 cid13 Fix interpretation I set O I objects Let U set valuations variables B O I Each valuation η U expressed η ηlηr ηl U l ηr U r MapB I expressed MapB I max ηlU l min ηr U r cid14 cid12 cid7 MapB I ηlηr cid13cid8cid15 Now ηl U l let pi path exists valuation ηr U r PathB I ηlηr pi ιr U r PathB I ηlιr p j implies j cid3 DPO employed R12D reduction procedure By deﬁnition instrumental Lemma 8 edges pi affected R12D Therefore MapB I ηlηr pi MapBcid13 I ηlηr We conclude block ηl real value minimizing exists values replaced D ignored aggregation function Therefore cid12 cid7 MapB I ηlηr cid13cid8 min ηr U r min ηr U r cid12 cid7 MapBcid13 cid13cid8 I ηlηr Since true ηl U l true aggregation cid14 max ηlU l min ηr U r cid12 cid7 MapB I ηlηr cid13cid8cid15 cid14 max ηlU l min ηr U r cid12 cid7 MapBcid13 I ηlηr cid13cid8cid15 Therefore MapB I MapBcid13 I cid2 2214 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 522 The procedure R120 min The introduction discard value leaves makes handling interpretation diagrams awkward In section additional computational cost avoided With extra bookkeeping variant R12 procedure avoid replacing edge targets discard value D process potentially remove GFODD To motivate new procedure consider happens evaluation redundancies max interpretation I GFODD B As observed block b valuations corresponding ζ l collapsed min aggregation Let P b denote set paths B traversed valuations b ordered given DPO We view procedure competition paths P b The winner competition path highest index P b Denote path pb The min competition applied blocks creates super block ˆb winners corresponding ζ l Finally ζ ls collapsed max aggregation This process turn viewed max competition paths P ˆb Obviously path wins min competition inside block Note block winning max competition uniquely determined block path winning min competition We refer unique winning path pb Then block max block refer max blocks generically b MapB I leaf pb The winner competition path index P ˆb We use notation introduced discussion rest section In particular ζl valuation max variables block b set paths P b path winning min competition pb In addition max block b corresponding P b unique winning path pb All implicitly depend interpretation I suppress I notation clear context Using analysis observe following 1 If value leaf reached path max block reduced value large leaf pb map remains unchanged This min competition max block produce result Additionally reducing values paths values winners min competitions reduced pb win max competition 2 If value leaf reached path block b max blocks reduced 0 leaf pb win max competition map preserved The observations suggest reduce GFODD following way 1 Preserve targets edges paths winning ﬁnal max competition interpretation We instrumental edges 2 Identify edges paths B appear max blocks possible interpretation I We block edges For block edge e replace targete value 1 large leaf pb I 2 larger smallest leaf reachable traversing e Notice 1 means pb wins min competition max blocks 2 makes sure add value path 3 Replace targets edges 0 In remainder section develop ideas formally R120 reduction procedure prove We correctness The input procedure GFODD B cid9V Dcid10 DPO B The output reduced GFODD B ﬁrst redeﬁne generalized aggregation functions min3 max3 capture bookkeeping needed block edges cid13 min3 input Val min3 set sets 3tuples cid9value path interpretationcid10 set 3tuples associated valuation The output set possible 4tuples cid9vo po Eo Iocid10 generated follows 1 Let X cid9v 1 p1 I1cid10 cid9vVal pVal IValcid10 set constructed picking 3tuple set corresponding valuation ζ Val 2 vo minv 1 vVal 3 po path highest index DPO PL appears 3tuple X leaf po vo 4 Eo set edges appearing paths 3tuples X edges po 5 Io 6 Io consistent I cid9v pi I icid10 X cid3 Thus min3 exactly collect set Eo Notice p0 happens instrumental E0 identiﬁes edges act block edges case If p0 instrumental E0 Next max3 adapted input set outputs min3 run different ζl identify output instrumental path winning blocks blocks edges I0 generated max3 input Val max3 set sets 4tuples cid9value path EdgeList interpretationcid10 set 4tuples associated valuation The output set possible 4tuples cid9vo po Eo Iocid10 generated follows 1 Let X cid9v 1 p1 E1 I1cid10 cid9vVal pVal EVal IValcid10 set constructed picking 4tuple set corre sponding valuation ζ Val 2 vo maxv 1 vVal S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2215 3 po path index DPO PL appears 4tuple X leaf po vo 4 Eo set E po pi vo v satisfying condition E given separate output tuple cid3 I cid9v pi E I icid10 X 5 Io 6 Io consistent Thus max3 exactly process sets E produce set Eo max3 picks E corresponds winning path pi input If block winning path produces output tuple Therefore output max3 I0 consistent interpretation instrumental path p0 block edges listed E 0 The R120 procedure follows 1 Recall variables split V l max aggregation followed V r min aggregation The set U valuations built following way Let O l set V l objects O r set V lV l 1V r objects O l O r disjoint Let U l sets possible valuations variables V l objects O l let U r set possible valuations variables V r objects union O l O r The set U deﬁned U ζ lζ r ζ l U l ζ r U r As previous reduction set U constructed allow suﬃciently rich set valuations Here allow arbitrary valuation V l objects O l Next consider ﬁxed valuation V l block valuations V r extends We allow V lV l blocks use fresh set V r objects objects In way winner min competition block constrained valuations blocks Finally allow path block edges unconstrained bindings block We add set V r objects As proof shows allows expose instrumental paths block edges diagram 2 For edge maintain 3 variables lowe highe bounds value InstrEdgee ﬂag These initialized follows For edges e B set lowe 1 highe le le value smallest leaf reachable e B InstrEdgee 0 3 Run max min3 procedure follows Divide Val U l blocks valuations block corresponding valuation ζ l U l Let X set blocks b Let Y cid9ζ l ReductionAggregationB b PLcid10 ζ l U l b X block corresponding ζ l Reduction Aggregation uses newly deﬁned min3 c Let S max3Y d For 4tuple cid9vo po Eo Iocid10 S For edge e po set InstrEdgee 1 ii For edge e Eo set lowe maxlowe vo 4 Finally target edge e replaced follows If InstrEdgee 1 replace b If InstrEdgee 0 lowe cid17 1 e block edge highe cid2 lowe replace targete suitable value v lowe cid3 v cid3 highe c If InstrEdgee 0 lowe 1 e block edge replace targete 0 Fig 8 shows example R120 reduction steps algorithm illustrated In remainder section provide proof soundness R120 To end ﬁrst deﬁne idealized properties reduction procedure style R120 We reduction properties sound R120 properties This allows break argument independent portions way simpliﬁes proof Deﬁnition 11 An edge e GFODD B instrumental iff e pb interpretation Deﬁnition 12 An edge e GFODD B block edge instrumental e path P b max block b interpretation Deﬁnition 13 For block edge e CannotExceede value smallest leaf reachable e CannotLage value largest value leaf pb possible interpretations path containing e appears max block Deﬁnition 14 A reduction procedure R reduces given GFODD B produce GFODD B following rules cid13 blocksafe conforms 2216 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 Fig 8 An example reduction R120 The initial diagram Example 12 Fig 7 We V l V r 1 O l 1 O r V lV l 1V r 2 y allowed bind 3 objects O l O r Each entry form valuepathinterpretation table enclosing angle brackets removed ﬁgure improve readability expresses value obtained running valuation correspond ing row diagram equivalence class interpretations The max min3 aggregation function calculates possible aggregates generated different equivalence classes interpretations Since block need run extended min3 aggregation example The result shown table For example entries 01t2 f 3 f pa qa 101t2 f 3t4tpa qa qb rb 101t2 f 3t4tpa qa qc rc row result Overall edges 3t 4t 4 f identiﬁed block edges For edge 3t InstrEdge3t 0 winner max block contains edge 3t high3t 0 smallest leaf reachable traversing 3t 0 The maxmin3 procedure sets low3t 0 highest leaf reached path defeating paths containing 3t max block 0 Thus target3t set 0 violating constraint low3t cid2 target3t cid2 high3t Setting target 3t 0 reduces diagram Note example edges shown block edges block max block All edges appearing result max min3 instrumental edges targets preserved reduction procedure 1 R identiﬁes instrumental edges B identiﬁed edge e R maintains targete 2 R identiﬁes block edges B identiﬁed edge e R replaces targete leaf value v CannotLage cid3 v cid3 CannotExceede 3 For edge e identiﬁed R instrumental block edge R replaces targete 0 Thus idealized reduction blocksafe theorem shows procedure sound Theorem 8 If reduction procedure R blocksafe B cid13 RB interpretation I MapB I MapBcid13 I Proof Fix interpretation I set O I objects Let U set valuations variables B O I Let ζ ζ lζ r U valuation traversing pb B MapB I expressed MapB I max ηlU l cid14 max cid14 cid7 MapB min ηr U r cid7 MapB min ζ r U r cid13cid8cid15 cid12 I ηlηr cid13cid8 cid12 I ζ lζ r cid14 max ηlcid17ζ lU l min ηr U r cid12 cid7 MapB I ηlηr cid13cid8cid15cid15 Since deﬁnition blocksafe guarantees target edge e replaced value greater CannotExceede targete decreases value Therefore valuation η U leaf PathB I η cid2 leaf PathBcid13 I η Therefore cid14 max ηlcid17ζ lU l min ηr U r cid12 cid7 MapBcid13 I ηlηr cid13cid8cid15 cid14 cid12 cid7 MapB I ηlηr cid13cid8cid15 cid3 max ηlcid17ζ lU l min ηr U r Additionally deﬁnition blocksafe guarantees instrumental edges preserved value reached block edges reduced leaf pb Therefore ζ reaches leaf pb B B No valuation max block b Thus cid13 cid13 reaches value leaf pb evaluated B cid12 cid13cid8 cid13cid8 cid12 cid7 MapBcid13 I ζ lζ r min ζ r U r cid7 MapB min ζ r U r I ζ lζ r leaf pb Finally cid14 MapBcid13 I max min ζ r U r MapB I S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2217 cid7 cid12 MapBcid13 I ζ lζ r cid13cid8 cid14 max ηlcid17ζ lU l min ηr U r cid7 cid12 MapBcid13 I ηlηr cid13cid8cid15cid15 min ζ r U r cid7 cid12 MapBcid13 I ζ lζ r cid13cid8 leaf pb cid2 Therefore prove soundness R120 focus showing blocksafe theorem It clear construction R120 identiﬁes instrumental edges block edges The diﬃculty showing identiﬁes edges inﬁnite set interpretations inﬁnite domains The following proof shows edge discovered ﬁnite combinations procedure Note edges block edges pb need discovered time Io procedure Instead suﬃcient discovered marked block edge point algorithm This approach taken proof showing instrumental edge pb block edge p j appropriately accounted R120 Theorem 9 R120 blocksafe Proof Line 4 R120 procedure enumerates treatment different edges B Accordingly prove theorem need 1 If edge e B instrumental interpretation I R120 sets InstrEdgee 1 2 If edge e block edge interpretation I R120 sets value lowe cid2 CannotLage 3 If edge e block edge interpretation I R120 sets value highe cid3 CannotExceede Of 3 true deﬁnition R120 highe initialized correct value changed We procedure correctly identiﬁes instrumental edge block edge sets correct bound block edges Consider interpretation I Let ζ ζ lζ r valuation traversing pb pi B I Therefore ζ l identiﬁes max block refer block b win min competition let PathB I η p j Therefore pi instrumental edges p j potentially block edges holds instrumental I lower bound edges cid2 leaf pi Let η ζ lηr valuation max block b Let O cid13 l set objects participate ζ l deﬁne set O cid13 r o O cid13 l ιlιr wins min competition block ιl By construction O cid13 l o cid13 r 1 O cid13 r Add V l O cid13 l new objects O cid13 l o participates ηr ιr cid13 l cid3 V l cid13 r new cid13 l V lV l 1V r O ιl contains objects O cid13 r cid3 V lV l 1V r Let o O objects O cid13 r cid13 l 1 O cid13 Construct interpretation I ﬁrst projecting I include objects O predicates new objects added O sets O l O r R120 procedure generate set valuations U cid13 r behave identically o cid13 l O cid13 l O cid13 l 1 o cid13 r deﬁning truth values cid13 r cid13 r 1 respectively Let O cid13 l O cid13 Since I contains relevant portion I PathB I I cid13 η p j In addition pi winner min cid13 ζ lιr pk To note exists valuation ζ lιr U PathB I competition block b k PL construct valuation ζ l ˆιr replacing new objects ιr o cid13 r 1 PathB I ζ l ˆιr pk However know ζ l ˆιr An identical argument proves b block U corresponding ιl pb deﬁned relative I winner min competition b I cid13 ζ pi PathB I cid13 cid13 So far shown winners min competitions I blocks U maintained I direct cid13 reference algorithm We focus R120 showing appropriate paths discovered Let Iιlιr PFPathB I cid13 ιlιrιlιr set atoms path pιlιr cid13 B traversed valuation ιlιr I By construction 3tuple cid9leaf pιlιr pιlιr Iιlιr cid10 appears output getBehaviors procedure run ιlιr Therefore deﬁnition ReductionAggregation min3 set Y generated Step 3b R120 contain cid13 ιlιrιlιr Similarly set produced applying min3 max entry cid9leaf pb pb Eb Ibcid10 Ib cid13 ζ lιrζ lιr In addition block b argument Eb contain edges p j contain entry cid9leaf pb pb Eb Ib cid10 Ib ιr U r PFPathB I ιr U r PFPathB I cid3 cid3 Now deﬁnition max3 set S built Step 3 R120 contain entry cid9leaf pb pb Eb Iocid10 cid3 Io ιU PFPathB I cid13 ιι consistent subset I cid13 Therefore e pb marked instrumental R120 Every edge e p j marked lowe cid2 leaf pb Since choice I pb p j arbitrary argument holds block edges implying lowe cid2 CannotLage Thus R120 blocksafe cid2 Corollary 1 Soundness For GFODD B max tations I MapB I MapBcid13 I min aggregation GFODD B cid13 output R120B interpre 2218 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 6 An application GFODDs value iteration relational MDPs So far described general theory GFODDs This included syntax semantics GFODDs combination procedures reduction procedures GFODDs In section GFODDs solve Relational MDPs 61 Relational Markov decision processes A Markov decision process MDP mathematical model decision making dynamic environment 12 Formally MDP 4tuple cid9S A T Rcid10 deﬁning set states S set actions A transition function T deﬁning probability P s j si getting state s j state si taking action immediate reward function Rs The objective solving MDP generate policy maximizes agents total expected discounted reward Intuitively expected utility value state equal reward obtained state plus discounted value state reached cid13 best action state This captured Bellman equation V s MaxaRs γ The value iteration algorithm dynamic programming algorithm treats Bellman equation update rule iteratively updates value state convergence The value iteration update V n1s MaxaRs cid13 Once optimal value function known policy generated assigning state γ action maximizes expected value cid13s aV ns cid13s aV s scid13 P s scid13 P s cid16 cid16 Several approaches introduced advantage factored state spaces state described spec cid13 s V s ifying values set propositions 2628 In particular Hoey et al 29 showed Rs P s represented algebraic decision diagrams ADD 2425 value iteration performed entirely ADD representation avoiding need enumerate state space This improved scalability classical solutions MDPs replacing enumeration states implicit equation ADDs compact feature based represen tation taking advantage structure problem However structure domain exploited general solutions viewing world consisting objects relations MDPs represented way known Relational MDPs Addressing Relational MDPs Boutilier et al 6 developed Sym bolic Dynamic Programming SDP algorithm context situation calculus This algorithm provided framework dynamic programming solutions Relational MDPs later employed formalisms systems 78109 One important ideas SDP represent stochastic actions deterministic alternatives natures control This helps simplify probabilistic reasoning required goal regression deterministic action alternatives decoupled probabilities action effects This separation necessary transition functions represented relational schema Using ideas RMDP speciﬁed 1 A set world predicates Each literal formed instantiating predicate objects domain true false given state For example boxworld domain world literals form boxincitybox city boxontruckbox truck truckincitytruck city 2 A set action predicates Each action literal formed instantiating action predicate objects domain deﬁnes concrete action For example boxworld domain action literals form loadboxontotruckincitybox truck city unloadboxfromtruckincitybox truck city drivetrucktruck sourcecity destcity 3 A state transition function provides abstract description probabilistic state For example STRIPSlike notation transition deﬁned action loadboxontotruckincity described Action loadboxontotruckincitybox truck city Preconditions boxincitybox city truckincitytruck city Outcome 1 probability 08 boxontruckbox truck boxincitybox city Outcome 2 probability 02 changes If preconditions action boxincitybox city truckincitytruck city satisﬁed probability 08 action generate effect boxontruckbox truck boxincitybox city The state remains unchanged probability 02 As example illustrates effects actions RMDPs correlated considered occur independently Therefore scheme captures correlations compactly useful context 4 An abstract reward function describing conditions rewards obtained For example boxworld domain reward function boxcity destinationbox city boxincitybox city constructed capture goal transporting boxes source cities respective destination cities An interesting fact notice RMDPs state space underlying MDP fully speciﬁed set objects domain left When ﬁxing domain objects speciﬁcation induces concrete MDP Thus RMDP represents family concrete MDPs The RMDP described schema languages Wang et al 9 RMDP representing reward function domain dynamics FODDs Domain dynamics described Truth Value Diagrams S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2219 Fig 9 Example Regression Object Maximization VIGFODD algorithm This domain contains single deterministic action Therefore Steps 2 4 algorithm needed The reward 1 x y px y 0 The reward function regressed deterministic The action deﬁned pU V true action true qU V true action performed action Ax AU V Regression replaces node value function corresponding TVD object maximization replaces action parameters quantiﬁed variables y TVD diagrams capturing probabilistic action choice A TVD FODD describing deterministic alternative probabilistic action world predicate conditions corresponding world literal true action executed action alternative occurs Fig 9 shows example TVD parameterized hypothetical planning domain In addition y world predicate pU V deterministic action Ax deterministic action variant A jcid22x diagram prob A jcid22x provides probability A jcid22x chosen Acid22x executed 62 The VIGFODD algorithm In section FODD based value iteration VI algorithm generalized handle cases aggregation We start describing VIGFODD algorithm reward function described GFODD max A subsequent discussion shows VIGFODD produces correct result step The algorithm follows min 1 Regression The n steptogo value function V n regressed deterministic variant A jcid22x action Acid22x produce RegrV n A jcid22x replacing node V n1 corresponding Truth Value Diagram TVD changing aggregation function 2 Add action variants The Qfunction Q Acid22x V n ated combining regressed diagrams Exapply R γ jprob A jcid22x RegrV n A jcid22x action Acid22x gener 3 Object maximization Maximize action parameters Q Acid22x V n action Acid22x ob taining value achievable best ground instantiation Acid22x This step implemented converting action parameters Q Acid22x variables associated max aggregation operator appending operators V n head aggregation function produce Q A V n 4 Maximize actions The n 1 steptogo value function V n1 max A Q A V n Exapply generated combining diagrams Example 13 Fig 9 shows example VI algorithm GFODDs simple domain This domain contains single deterministic action Therefore need multiply prob A jcid22x sum variants A j Step 2 algorithm similarly Step 4 needed In example completely skip Step 2 focus steps algorithm The reward 1 x y px y holds 0 The reward function regressed deﬁned px y true action true deterministic action Ax qx y true action performed Ax y Since action px y true time intuitively regressed diagram capture union following conditions returning value 1 y 2220 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 1 There exists x y px y holds 2 There exists x y px y true y qx y true Fig 9 shows diagram regressed object maximized The ﬁnal diagram correct returns 1 iff situations occur If x y px y true valuations blocks value x ﬁxed values w z reach 1 leaf directly root Evaluating Min y collapse blocks partial valuations 1 value Now rest aggregation maximization 1 value returned map If exists x y px y true y qx y true valuations blocks value x values y ﬁxed values w z reach 1 leaf directly root The valuation block value y traverse right root reach 1 leaf depending condition w x z y Note exactly block valuation reach 1 leaf Evaluating Min y collapse block valuation value 1 Since rest aggregation maximization 1 value returned map When conditions true valuation block reaches 0 leaf Hence evaluating Min y collapse block valuation 0 value For Value Iteration work correctly GFODDs steps algorithm listed correct Regression block replacement correct regardless aggregation function Recall TVD predicate deterministic action A jcid22x describes conditions predicate true A jcid22x executed Wang et al 9 impose constraint TVDs include free variables Using constraint diagrams regression exactly variables Wang et al 9 regression correct valuation Lemma 9 See 9 Fix concrete instantiation state space Let s denote state resulting executing action Acid22x state ˆs If V n n steptogo value function BRregressV n Acid22x result regressing V n deterministic action Acid22x ζ valuation variables V n variables BRregressV n Acid22x MAPV n s ζ MAPBRregressV n Acid22xˆs ζ The lemma shows corresponding map values valuation ζ Therefore aggregation values aggregation function V n The step Object Maximization correct converting action parameters Q Acid22x V n variables associated interpretation map Q Acid22x V n max aggregation operator appending operators head aggregation function Q A V n map Q A maximized possible values V n action parameters required Steps 2 4 correct Theorem 4 showing correctness Exapply Since value iteration requires combining diagrams max operators GFODDs aggregation operators safe combination operators max Thus aggregation operators max min To extend algorithm use aggregation operators like sum mean needs develop appropriate combination algorithms rest algorithm remains implies Thus correct value iteration algorithm GFODDs max min aggregations In addition Theorem 4 guarantees start reward function GFODD aggregation form max value iteration GFODDs produced aggregation function form With R12 reduc tions case sound procedure help diagrams compact value iteration process We shown min Theorem 10 For Relational MDP aggregation function reward function diagram contains operators safe combination operators max algorithm VIGFODD produces correct value function iteration Corollary 2 For Relational MDP reward function max function iteration intermediate results ﬁnal result use max reduce diagrams algorithm min aggregation VIGFODD produces correct value aggregation R12 procedure min 7 Conclusions future work This paper signiﬁcantly extends representation power ﬁrstorder decision diagrams algorithmic standing reductions We Generalized FODDs allow arbitrary aggregation functions facilitating representation complex functions basic operations performed In particular naturally capture manipulate logical formulas existential universal quantiﬁers max min aggregation In addi tion ﬁrstorder value iteration supported expressive setting MDP represented GFODDs This new formulation naturally handle universal goals handled heuristically previous imple mentations ﬁrstorder value iteration 1011 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 2221 Fig 10 Reward value function goal cla blocksworld domain Additionally GFODDs prove useful addressing issues related problems lifted value function inﬁnite size For instance Kersting et al 7 showed example blocksworld domain goal particular block clear denoted cla value function inﬁnite size number blocks However value function represented compactly GFODDs conjunction descriptive predicate shown Fig 10 In ﬁgure X true block X tower stacked block aggregation X performed multiplication operator discount factor 09 Thus multiplicative aggregation implicitly captures number steps goal Although existence compact value function imply eﬃcient algorithm produce particular case know problem inherently representation The main contribution paper idea analysis model checking reductions The basic idea provides model checking reduction operators FODDs useful subset GFODDs In case prove reduction technical sense maximal The maximum reduction guarantee FODDs falls short providing normal form relies DPO deﬁne parts diagram reduced mutual impli cation relations Therefore semantic function different minimal representations However guarantee stronger previous reductions Wang et al 9 discuss normal form FODDs Examples FODDs given simple decidable fragment normal form need syntactic manipulation diagrams Therefore going guarantee given paper hard expensive compute Nevertheless potential exploring possibility eﬃcient reductions interesting subsets GFODDs future work This work suggests new approach practical implementations FODDs The model checking reductions paper require enumeration substitutions high complexity A promising idea use sample interpre tations judicially chosen reduce diagrams relative interpretations We refer reader 12 recent work providing validation idea context RMDPs implementation shows signiﬁcant speedup theorem proving reductions maintaining performance terms solving planning problems FODDs It interesting develop extensions heuristics support eﬃcient reductions GFODDs Such ap proach allow expressive setting GFODDs handled eﬃciently heuristic approximation embedded model checking reductions Finally interesting investigate utility GFODDs applications like lifted inference Statis tical Relational Learning beneﬁt expressive function representations Acknowledgements Kristian Kersting supported Fraunhofer ATTRACT fellowship STREAM Saket Joshi Roni Khardon partly supported NSF grants IIS 0936687 IIS 0964457 Saket Joshi additionally supported Computing Innovation Postdoctoral Fellowship References 1 ML Puterman Markov Decision Processes Discrete Stochastic Dynamic Programming Wiley 1994 2 S Russel P Norvig Artiﬁcial Intelligence A Modern Approach Prentice Hall Series Artiﬁcial Intelligence 2002 3 R Bellman Dynamic Programming Princeton University Press Princeton NJ 1957 4 R Howard Dynamic Programming Markov Processes MIT Press 1960 5 L Getoor B Tasker An Introduction Statistical Relational Learning MIT Press 2007 6 C Boutilier R Reiter B Price Symbolic dynamic programming ﬁrstorder MDPs Proceedings International Joint Conference Artiﬁcial Intelligence 2001 pp 690700 7 K Kersting M van Otterlo L De Raedt Bellman goes relational Proceedings International Conference Machine Learning 2004 pp 465 472 8 S Hölldobler E Karabaev O Skvortsova FluCaP heuristic search planner ﬁrstorder MDPs Journal Artiﬁcial Intelligence Research 27 2006 419439 9 C Wang S Joshi R Khardon Firstorder decision diagrams relational MDPs Journal Artiﬁcial Intelligence Research 31 2008 431472 10 S Sanner C Boutilier Practical solution techniques ﬁrstorder MDPs Artiﬁcial Intelligence 173 2009 748788 11 S Joshi R Khardon Probabilistic relational planning ﬁrstorder decision diagrams Journal Artiﬁcial Intelligence Research 41 2011 231266 12 S Joshi K Kersting R Khardon Selftaught decision theoretic planning ﬁrstorder decision diagrams Proceedings International Confer ence Automated Planning Scheduling 2010 pp 8996 13 D Poole Firstorder probabilistic inference Proceedings International Joint Conference Artiﬁcial Intelligence 2003 pp 985991 2222 S Joshi et al Artiﬁcial Intelligence 175 2011 21982222 14 R Braz E Amir D Roth Lifted ﬁrstorder probabilistic inference Proceedings International Joint Conference Artiﬁcial Intelligence 2005 pp 13191325 15 A Jaimovich O Meshi N Friedman Templatebased inference symmetric relational Markov random ﬁelds Proceedings Uncertainty Artiﬁcial Intelligence 2007 pp 191199 16 B Milch L Zettlemoyer K Kersting M Haimes L Kaelbling Lifted probabilistic inference counting formulas Proceedings National Conference Artiﬁcial Intelligence 2008 pp 10621068 17 P Singla P Domingos Lifted ﬁrstorder belief propagation Proceedings National Conference Artiﬁcial Intelligence 2008 pp 10941099 18 P Sen A Deshpande L Getoor Exploiting shared correlations probabilistic databases Proceedings International Conference Very Large Data Bases 2008 pp 809820 19 P Sen A Deshpande L Getoor Bisimulationbased approximate lifted inference Proceedings Uncertainty Artiﬁcial Intelligence 2009 pp 496 505 20 K Kersting B Ahmadi S Natarajan Counting belief propagation Proceedings Uncertainty Artiﬁcial Intelligence 2009 pp 277284 21 J Kisynski D Poole Lifted aggregation directed ﬁrstorder probabilistic models Proceedings International Joint Conference Artiﬁcial Intelligence 2009 pp 19221929 22 J Lloyd Foundations Logic Programming second edition SpringerVerlag 1987 23 J Groote O Tveretina Binary decision diagrams ﬁrstorder predicate logic Journal Logic Algebraic Programming 57 2003 122 24 R Bryant Graphbased algorithms boolean function manipulation IEEE Transactions Computers C35 1986 677691 25 R Bahar E Frohm C Gaona G Hachtel E Macii A Pardo F Somenzi Algebraic decision diagrams applications Proceedings IEEEACM International Conference ComputerAided Design 1993 pp 188191 26 C Boutilier R Dearden M Goldszmidt Stochastic dynamic programming factored representations Artiﬁcial Intelligence 121 2000 49107 27 M Kearns D Koller Eﬃcient reinforcement learning factored MDPs Proceedings International Joint Conference Artiﬁcial Intelligence 1999 pp 740747 28 C Guestrin D Koller R Parr S Venkataraman Eﬃcient solution algorithms factored MDPs Journal Artiﬁcial Intelligence Research 19 2003 399468 29 J Hoey R StAubin A Hu C Boutilier SPUDD Stochastic planning decision diagrams Proceedings Uncertainty Artiﬁcial Intelligence 1999 pp 279288