Artiﬁcial Intelligence 177179 2012 124 Contents lists available SciVerse ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Ordered completion ﬁrstorder logic programs ﬁnite structures Vernon Asuncion Fangzhen Lin b Yan Zhang Yi Zhou Intelligent Systems Lab School Computing Mathematics University Western Sydney Penrith South DC NSW 1797 Australia b Department Computer Science Hong Kong University Science Technology Clear Water Bay Kowloon Hong Kong r t c l e n f o b s t r c t Article history Received 20 October 2010 Received revised form 16 November 2011 Accepted 17 November 2011 Available online 25 November 2011 Keywords Answer set programming Ordered completion Knowledge representation Nonmonotonic reasoning In paper propose translation normal ﬁrstorder logic programs stable model semantics ﬁrstorder sentences ﬁnite structures The translation ordered completion modiﬁcation Clarks completion auxiliary predicates added track derivation order We ﬁnite structures classical models ordered completion normal logic program correspond exactly stable models program We extend result normal programs constraints choice rules From theoretical viewpoint work clariﬁes relationships normal logic programming stable model semantics classical ﬁrstorder logic It follows ﬁnite structures normal program deﬁned ﬁrstorder sentence new predicates allowed This tight result normal logic program deﬁned ﬁrstorder sentence extra predicates allowed inﬁnite structures considered Furthermore result extended disjunctive logic programs assuming NP cid3 coNP From practical viewpoint work leads new type ASP solver grounding programs ordered completion instead program We report ﬁrst implementation solver based optimization techniques Our experimental results solver compares favorably major ASP solvers Hamiltonian Circuit program especially large domains Crown Copyright 2011 Published Elsevier BV All rights reserved 1 Introduction This work translating logic programs stable model answer set semantics 12 ﬁrstorder logic Viewed context formalizing semantics logic programs classical logic work direction goes Clark 4 gave called Clarks completion semantics work like work direction based In terms stable model semantics Clarks completion semantics weak sense models Clarks completion stable models programs tight 8 Various ways remedy proposed particularly propositional case given recent Answer Set Programming ASP prospect SAT solvers compute answer sets 19 This paper considers ﬁrstorder logic programs prospect capturing answer sets programs ﬁrstorder logic A crucial consideration work kind auxiliary symbols propositional case predicates ﬁrstorder case For propositional logic programs BenEliyahu Dechters translation 1 polynomial space uses O n2 auxiliary variables Lin Zhaos translation 19 loop formulas exponential Corresponding author Email addresses vernonscmuwseduau V Asuncion ﬂincseusthk F Lin yanscmuwseduau Y Zhang yzhouscmuwseduau Y Zhou 00043702 matter Crown Copyright 2011 Published Elsevier BV All rights reserved doi101016jartint201111001 2 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 worst case use auxiliary variables Chen et al 2 extended loops loop formulas ﬁrstorder case showed ﬁnite domains answer sets ﬁrstorder normal logic program captured completion ﬁrstorder loop formulas However general program inﬁnite number loops loop formulas But best hope auxiliary predicates known transitive closure easily written ﬁrstorder logic program captured ﬁnite ﬁrstorder theory ﬁnite structures 5 The situation different introduce auxiliary predicates Our main technical result paper additional predicates track derivation order bodies heads program modify Clarks completion ordered completion captures exactly answer set semantics ﬁnite structures The rest paper organized follows We recall background knowledge section In Section 3 deﬁne ordered completions ﬁrstorder normal logic programs capture exactly stable models programs ﬁnite structures We result extended normal programs constraints choice rules However extended disjunctive logic programs hold arbitrary structures Speciﬁcally Section 3 arbitrary structures exist normal logic programs captured ﬁrstorder theory ﬁnite structures exists disjunctive logic program captured ﬁrstorder sentence provided NP cid3 coNP We present techniques optimizing ordered completions Section 4 These techniques implementation ﬁrstorder solver We solver experimental results Section 5 We discuss related work Section 6 conclude paper Section 7 2 Preliminaries We assume readers familiar basic notions notations classical ﬁrstorder logic Here consider ﬁnite ﬁrstorder language function symbols equality In particular atom called equality atom form t1 t2 proper atom Let σ σ1 signatures σ σ1 Given structure A signature σ1 reduct A σ denoted A σ σ structure agrees A interpretations predicates constants σ Conversely A expansion A σ σ1 A normal logic program program short ﬁnite set rules following form α β1 βk γ1 γl 1 α proper atom 0 cid2 k cid2 l βi 1 cid2 cid2 k γ j 1 cid2 j cid2 l atoms Given rule r form 1 α head r denoted Headr β1 βk γ1 γl body r denoted Bodyr In particular β1 βk positive body r denoted Posr γ1 γl negative body r denoted Negr We variable rule body variable occurs body head rule Given program Π predicate called intensional occurs head rule Π extensional The signature Π contains intensional predicates extensional predicates constants occurring Π For convenience loss generality following assume programs normalized sense intensional predicate P tuple cid7x distinct variables matching arity P rule head mentions P head P cid7x So rules P occurring heads program enumerated P cid7x Body1 P cid7x Bodyk 21 Clarks completion Our following deﬁnition Clarks completion standard completions extensional predicates Given program Π predicate P Clarks Completion P Π following ﬁrstorder sentence 4 cid7yi cid2 Bodyi 2 cid2 cid7x P cid7x cid3 1cid2icid2k cid4 P cid7x Body1 P cid7x Bodyk rules heads mention predicate P cid7yi tuple body variables P cid7x Bodyi cid2 Bodyi conjunction elements Bodyi simultaneously replacing occurrences Clarks Completion completion short clear context Π denoted CompΠ set Clarks completions intensional predicates Π Example 1 Transitive Closure TC The following normal logic program TC computes transitive closure given graph V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 3 Sx y Ex y Sx y Ex z Sz y E extensional predicate TC representing edges graph S intensional predicate TC Ideally intensional predicate computes transitive closure paths given graph The Clarks Completion TC following ﬁrstorder sentence cid6cid6 cid5 cid5 xy Sx y Ex y zEx z Sz y 22 The stable model semantics propositional programs In propositional case stable model semantics normal propositional programs proposed Gelfond Lifschitz 12 later extended answer set semantics propositional programs classical nega tion constraints disjunctions operators 61113172122 Several equivalent characterizations proposed including GelfondLifschitz transformation 12 logic GK 20 loop formulas 19 equilibrium logic 26 gen eral reduction 11 Here brieﬂy review standard GelfondLifschitz transformation semantics 12 loop formula characterization propositional case 19 needed proof main theorem Let Π propositional program A set atoms We A satisﬁes rule r Π Headr A Posr A Negr A Then A satisﬁes Π satisﬁes rules Π The reduct Π relative A denoted Π A program obtained Π deleting rule r Π negative body satisﬁed A disjoint A ii deleting negative atoms rules Then A said stable model answer set Π iff A satisﬁes Π exist Acid16 A Acid16 satisﬁes Π A An equivalent characterization stable model semantics loop formula approach 19 Let Π program The positive dependency graph Π denoted GΠ ﬁnite graph V E V set atoms occurring Π x y edge E iff exists rule r Π head x positive body contains y A set atoms L said loop exists cycle GΠ goes nodes L Let x propositional atom If exists rule r Π head x body r support x Π Let L loop x atom L We support Body x Π external support respect L positive Body contains atoms L Given loop L use ESL Π denote set external supports element L respect L Π Then loop formula L Π denoted LFL Π following formula cid3 x cid3 cid2 Body xL BodyESLΠ Lin Zhao 19 showed propositional case set atoms answer set stable model ﬁnite program model Clarks completion loop formulas program 23 The stable model semantics ﬁrstorder programs In Gelfond Lifschitzs seminal work 12 stable modelanswer set semantics ﬁrstorder logic programs programs variables deﬁned grounding Herbrand structures Recently deﬁning stable model semantics ﬁrstorder programs directly ﬁrstorder level 2310202527 Such semantics usually consider arbitrary structures instead Herbrand structures Nevertheless normal logic programs coincide Gelfond Lifschitzs original semantics 12 considering Herbrand structures 310162027 We brieﬂy review translational semantics 10 deﬁning stable model semantics logic programs second order logic Under context consider normal ﬁrstorder logic programs Given normal logic program Π let ΩΠ Q 1 Q n set intentional predicates Π Let Ω Π 1 Q new set predicates corresponding ΩΠ Q Π arity predicate Ω n Q Q ΩΠ Given rule r Π form α β1 βm γ1 γl cid7r denote universal closure following formula β1 βm γ1 γl α r denote universal closure following formula β m β 1 α Q cid7x α Q cid7x γ1 γl α 4 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 cid8 β 1 cid2 cid2 m j cid7t j Q βi βi Q jcid7t j Q j ΩΠ By cid7Π denote ﬁrstorder sentence logic program By SMΠ denote following secondorder sentence ˆr Π rΠ denote ﬁrstorder sentence cid9 cid9 rΠ r Let Π normal cid7Π Ω Π cid5cid5 Ω Π ΩΠ cid6 cid6 Π Ω Π ΩΠ abbreviation formula cid10 cid10 cid5 cid7x Q cid6 cid7x Q icid7x cid5 cid7x Q icid7x Q cid6 cid7x 1cid2icid2n 1cid2icid2n This secondorder sentence capture stable models Π We translational semantics Here purposes present alternative characterization semantics grounding Similar Gelfond Lifschitzs grounding approach deﬁne stable model semantics grounding propositional case However consider grounding arbitrary structures instead Herbrand structures It worth mentioning arbitrary structures unique assumption distinct constants interpreted differently necessarily hold Consequently assume grounding procedure Deﬁnition 1 The grounding program Π structure M written ΠM union following sets 1 The set instances rules Π M instance rule M result simultaneously replacing constant rule interpretation M variable x rule domain object d M 2 EQM u u u domain object M1 3 ExtM P cid7u P extensional predicate cid7u P M P M interpretation P M We following deﬁnition Deﬁnition 2 Let Π normal logic program M structure We M stable model answer set Π following set EQM ExtM IntM answer set ΠM propositional case IntM following set cid11 cid12 cid12 P intensional predicate cid7u P M cid13 P cid7u Example 2 Consider following program Π0 P x Q x P a1 Q a2 According Gelfond Lifschitzs original stable model semantics 12 unique stable modelanswer set Π0 X P a1 Q a2 Now let reconsider program Π0 new semantics Deﬁnition 2 Notice P Q intensional predicates According Deﬁnition 2 following structure M0 M0 d1 d2 M0 d1 a1 M0 d2 a2 M0 d1 P M0 d2 Q stable model Π0 In fact structure M0 corresponds unique stable model X Π0 original semantics Notice similar classical ﬁrstorder logic distinguish a1 d1 a2 d2 constant language domain element However new semantics M0 stable model Π0 The following structure M1 M1 d1 M1 d1 a1 M1 d1 a2 M1 Q P M1 d1 1 Note u u propositional atom equality atom V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 5 stable model Π0 Here a1 a2 mapped domain element d1 This allowed unique assumption distinct constants interpreted different domain elements assumed new semantics Also new semantics allow new objects stable models For instance following structure M2 M2 d1 d2 d3 a2 stable model Π0 Notice d3 P M2 d1 M2 d2 M2 d3 mapped constants program M2 d1 d3 M2 d2 a1 Q P In fact deﬁnition stable model answer set new The grounding technique Deﬁnition 1 basically standard 12 arbitrary structure instead Herbrand structure The reason propose alternative deﬁnition suitable understanding proof main theorem Theorem 2 Also following theorem shows semantics grounding arbitrary structures actually coincides translational semantics mentioned previously section Theorem 1 Let Π normal logic program signature σ A ﬁnite σ structure Then A stable model Π Deﬁnition 2 iff A model SMΠ Proof For convenience use GrA denote EQ A ExtA IntA First GrA satisﬁes ΠA iff GrA satisﬁes instances rules Π A iff GrA satisﬁes rη r Π η assignment iff A satisﬁes cid7r r Π iff A cid20 cid7Π Second A cid20 Ω Π Ω We A cid20 Ω constants extensional predicates A Π ΩΠ Π iff exists structure Acid16 Π Ω Π ΩΠ Π iff exist X GrA X satisﬁes ΠAGrA domain A interprets Acid16 Acid16 Q intensional predicates Q Π Q intensional predicates Q Q assignment η rule r form 1 Π 1 cid2 cid2 k βiη Acid16 A A Acid16 Q γ jη A αη Acid16 j 1 cid2 j cid2 l iff exists X Gr A satisfying rηGrA pair r η r Π η assignment let X EQ A ExtA IntAcid16 iff exists X Gr A satisfying ΠAGrA This shows original assertion holds cid2 As consequence theorem Theorem 1 10 Deﬁnition 2 basically coincides Gelfond Lifs chitzs original semantics Herbrand structures The main difference consider Herbrand structures arbitrary ones For need unique assumption Example 2 Notice deﬁnitions applied inﬁnite structures stable model answer set se mantics inﬁnite propositional programs deﬁned GelfondLifschitz transformation 12 However paper mainly concerned ﬁnite structures stated particularly Section 35 3 The ordered completion It known Clarks completion fully capture answer set semantics positive cycles As simple example following program p q q p answer set Clarks completion p q models p q Here propose modiﬁcation Clarks completion address issue The main technical property new translation ﬁnite ﬁrst order logic program translation yields ﬁnite ﬁrstorder theory captures exactly ﬁnite stable models program The ideas translation best illustrated simple propositional programs Consider program mentioned We introduce auxiliary symbols T pq T pp Tqq Tqp read T pq p q translate program following theory p q q p p q T qp T pq q p T pq T qp T pq T qp T pp T qp T pq T qq 6 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 The ﬁrst sentence direct encoding rules The second similar Clarks completion p add T qp T pq p true q true case q derive p way The sentence similar sentences transitivity T atoms It checked models sentences p q false 31 Deﬁnition ordered completion In general let Π ﬁrstorder normal logic program ΩΠ set intensional predicates For pair predicates P Q P Q ΩΠ introduce new predicate cid2PQ called comparison predicate arity sum arities P Q The intuitive meaning cid2PQ cid7x cid7y read P cid7x Q cid7y P cid7x deriving Q cid7y In following use inﬁx notation cid2PQ write cid2PQ cid7x cid7y cid7x cid2PQ cid7y Deﬁnition 3 Ordered completion Let Π normal logic program The ordered completion Π denoted OCΠ set following sentences For intensional predicate P following sentences cid2 cid3 cid7x cid4 cid7yi cid2 Bodyi P cid7x 3 1cid2icid2k cid2 cid7x P cid7x cid2 cid7yi cid2 Bodyi cid3 1cid2icid2k cid10 cid4cid4 cid7z cid2QP cid7x cid7x cid2PQ cid7z Q cid7zPosi Q ΩΠ borrowed notations deﬁnition Clarks completion assume Posi positive Bodyi Q cid7z ranges intensional atoms positive Bodyi For triple intensional predicates P Q R following sentence cid10 P Q RΩΠ cid7xcid7ycid7zcid7x cid2PQ cid7y cid7y cid2Q R cid7z cid7x cid2P R cid7z 4 In following use MCompΠ denote set formulas 3 4 TranSΠ set formulas 4 So OCΠ MCompΠ TranSΠ Clearly ﬁnite programs OCΠ ﬁnite predicates occurring OCΠ predicates occurring Π comparison predicates cid2PQ P Q ΩΠ Notice Clarks completion predicate rewritten parts cid2 cid3 cid7x cid4 cid7yi cid2 Bodyi P cid7x 1cid2icid2k cid2 cid7x P cid7x cid4 cid7yi cid2 Bodyi cid3 1cid2icid2k Thus difference MCompΠ CompΠ introduces assertions compar ison predicates intuitively mean exist derivation paths intensional atoms body head way Eq 4 In addition TranSΠ simply means comparison predicates satisfy transitivity Proposition 1 Let Π normal logic program Then OCΠ introduces m2 new predicates arities 2s size OCΠ O s m3 s n m number intensional predicates Π s maximal arity intensional predicates Π n length Π Example 3 Transitive Closure continued Recall Transitive Closure program TC presented Example 1 In case intensional predicate S need introduce additional predicate cid2S S arity 4 The ordered completion TC consists following sentences cid5cid5 cid5 cid5 Ex y z cid5 Sx y xy xy xyuv zw xy cid2S S Ex z Sz y cid5 cid6cid6 cid6 Sx y Ex z Sz y zy cid2S S zw zw xy cid2S S Ex y z uv uv cid2S S xy xy cid2S S cid6cid6cid6 zy 5 6 7 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 7 Fig 1 An example graph uv mean Sx y establish Su v So sentence 6 means Intuitively understand Sx y true Ex y base case inductively z Ex z true Sz y establish Sx y way xy cid2S S To axioms work consider graph Fig 1 vertices b c d E representing edge relation Ea b Eb Ec Ec d Clearly path x y Sx y sentence 5 We want path x y Sx y Consider Sd If true Ed x Ed x Sx da cid2S S This false edge going d da xa cid2S S xa Now consider Sa c If true z ac Ea z Sz c zc ac cid2S S zc cid2S S So z b Sb c bc cid2S S ac ac cid2S S bc 8 Since Sb c true edge b c y bc cid2S S Eb y S y c bc yc cid2S S yc So y Sa c ac cid2S S bc bc cid2S S ac However contradicts 8 Notice Clarks completion TC xySx y Ex y zEx z Sz y Example 1 assure S transitive closure edge relation For instance following interpretation S Sa b Sb Sa c Sc Sb c Sc b Sa d Sb d Sc d satisﬁes Clarks completion TC However path c graph shown Fig 1 32 The main theorem In order introduce main theorem ﬁrst consider notion called derivation order reformulation Fages wellsupportedness context 7 Roughly speaking derivation order sequence ground atoms anterior ones derive posterior ones Formally derivation order ﬁnite structure A program Π sequence ground atoms P 1cid7a1 P kcid7ak P 1cid7a1 P kcid7ak IntA Deﬁnition 2 1 cid2 cid2 k exists rule r Π assignment η Headrη P icid7ai intensional atoms Q cid7t Posr Q cid7tη P 1cid7a1 P i1 intensional atoms Q cid7t Negr Q cid7tη IntA extensional atoms Q cid7t Posr Negr resp Q cid7tη ExtA Q cid7tη ExtA resp ai1 Example 4 Consider following program Π1 p1 p2 p2 p1 p1 p3 8 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 Clearly X p1 p2 answer set Π1 According deﬁnition p1 p2 derivation order X Π1 p2 p1 This p1 derive p2 way We derivation orders answer sets corresponded Lemma 2 Let Π normal logic program signature σ A ﬁnite σ structure Then A answer set Π iff A cid20 cid7Π ii exists possibly derivation order A Π Proof According grounding deﬁnition Deﬁnition 1 suﬃces prove assertion propositional case On hand consider ﬁnite propositional program Π set A atoms If A answer set Π A satisﬁes Π according GelfondLifschitz transformation semantics In addition construct sequence atoms p1 p2 pk A follows 1 cid2 cid2 k exists rule r Π Headr pi Posr p1 pi1 Negr A exist r Π Posr p1 pk Negr A Headr p1 pk Then p1 p2 pk A Otherwise p1 p2 pk cid20 Π A pk derivation order A Π p1 p2 pk A contradiction Hence p1 p2 On hand suppose A cid20 cid7Π exists derivation order A Π To prove A answer set Otherwise let p atom AAcid16 Π suﬃces exist Acid16 A Acid16 ordinal derivation order Then according deﬁnition exists rule r Headr p Posr Acid16 p ordinal derivation order Negr A Therefore Negr Acid16 It follows Acid16 cid20 Posr Acid16 cid3cid20 Headr Hence Acid16 contradiction cid2 satisﬁes Π A satisfy r A Now able present following main theorem Theorem 2 Let Π normal logic program signature σ A ﬁnite σ structure Then A answer set Π exists model M OCΠ A reduct M σ Proof On hand ﬁnite answer set A Π expanded model OCΠ By Lemma 2 exists derivation order A Π Then based construct ﬁnite structure M expanding A following interpretations cid2PQ pair P Q intensional predicates Π cid7b iff exists path Q cid7b P cid7a dependency graph ground program ΠA position cid7a cid2PQ P cid7a position Q cid7b derivation order cid7a cid7b tuples elements domain A match arities P Q respectively In case derivation path P cid7a Q cid7b respect derivation order We need prove M model TranSΠ MCompΠ Firstly easy M model TranSΠ contradiction Secondly M model MCompΠ Clearly M model ﬁrst MCompΠ Eq 3 M expanded A model Clarks completion Π For second MCompΠ Eq 4 prove contradiction Suppose M model Eq 4 Then M cid20 cid3 P ΩΠ cid2 cid7x P cid7x cid10 1cid2icid2k cid2 cid7yi cid2 Bodyi cid3 Q cid7zPosi ΩΠ cid4cid4 cid7z cid2QP cid7x cid7x cid2PQ cid7z Therefore exists P cid7a M assignments η rules r head mentions P M cid20 cid3 exists intensional atom Q cid7z positive body r M cid20 cid7z cid2QP cid7xη M cid20 cid7x cid2PQ cid7zη Now consider position P cid7a derivation order There exists rule r assignment η satisfying conditions mentioned Hence according conditions intensional atom Q cid7t positive body r ordinal Q cid7tη derivation order ordinal P cid7a derivation order Hence M cid20 cid7t cid2QP cid7xη M cid3cid20 cid7x cid2PQ cid7tη contradiction This shows M expanded A model OCΠ On hand prove reduct ﬁnite model M OCΠ σ answer set Π Clearly M σ model CompΠ MCompΠ cid20 CompΠ Hence according loop formula characterization answer set semantics propositional case 19 suﬃces loops L ground program ΠMσ set ground atoms EQMσ ExtMσ IntMσ model loop formula Bodyrη V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 9 We prove contradiction Suppose exists loop L ground program ΠMσ set ground atoms model LFL ΠMσ Then exists ground atom P 0cid7a0 L P 0cid7a0 IntMσ Q cid7b L Q cid7b external support respect L ground program ΠMσ Since M model MCompΠ exists support Body0 P 0cid7a0 ground program ΠMσ ground atoms Q cid7b positive body Body0 cid7b cid2Q P 0 cid7b holds Q intensional predicate Π cid7b tuple elements M matches arity Q If Q cid7b L Body0 external support P 0cid7a0 respect L contradiction Hence exists P 1cid7a1 positive body Body0 P 1cid7a1 IntMσ P 1cid7a1 L cid7a1 cid2P 1 P 0 cid7a1 holds Again following procedure described exists support Body1 P 1cid7a1 ground atom P 2cid7a2 positive body Body1 P 2cid7a2 IntMσ P 2cid7a2 L cid7a2 cid2P 2 P 1 cid7a2 holds Hence sequence ground atoms P 0cid7a0 P 1cid7a1 P icid7ai P icid7ai IntMσ P icid7ai L In addition cid7a1 cid7a1 cid2P 1 P 2 cid7a0 cid7a0 cid2P 0 P 1 cid7a0 cid7a0 cid2P 0 Q Next sequence inﬁnite ﬁniteness structure M fact new comparison predicates satisfy transitivity Since M ﬁnite exists k l P kcid7ak Plcid7al se cid7ai holds cid7al cid2Pl Pk1 quence However ak1 holds according transitivity ak1 holds P kcid7ak Plcid7al This contradicts fact axioms Hence cid7ak cid2Pk Pk1 ak1 cid2Pk1 Pk ai1 cid2P i1 P cid7ak holds cid7ai cid7ai cid2P P i1 ai1 cid2P i1 P ai1 hold This shows M σ answer set Π cid2 From proof main theorem basic idea ordered completion atom answer set ﬁnite program justiﬁed stepbystep In sense ﬁnite structure A answer set program Π iff model Π satisﬁes following conditions downgrading ground atom P cid7a A supports earlier stages The support ensured Clarks completion earlier stages ensured adding assertions comparison predicates Eq 4 loopfree downgrading procedure contain loop This ensured TranSΠ states comparison predicates satisfy transitivity wellfoundedness downgrading procedure end step This ensured ﬁniteness ﬁnite structures taken account Together conditions ground atom P cid7a ﬁnite answer set A justiﬁed stepbystep track justifying atom captured comparison predicates 33 Normal logic program constraints Recall required head rule proper atom If allow head socalled constraints β1 βk γ1 γl 9 βi 1 cid2 cid2 k γ j 1 cid2 j cid2 l atoms A model said satisfy constraint satisﬁes corre sponding sentence cid7yβ1 βk γ1 γl cid7y tuple variables occurring 9 In following c constraint form 9 use ˆc denote corresponding formula A normal logic program constraints ﬁnite set rules constraints The stable model answer set se mantics extended normal logic programs constraints model answer set program constraints answer set set program satisﬁes constraints Both Clarks completion ordered completion extended normal logic programs constraints simply adds sentences corresponding constraints respective completions Proposition 3 Let Π normal logic program signature σ C set constraints A ﬁnite σ structure Then A answer set Π C iff exists model M OCΠ ˆc c C A reduct M σ Proof A answer set Π C iff A answer set Π A model ˆc c C iff exists M model OCΠ ˆc c C reduct σ A iff exists M model OCΠ ˆc c C A reduct M σ cid2 10 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 Example 5 The following program checks nodes given graph reached given initial node Ra Rx R y E y x Rx E extensional predicate representing edges graph constant representing initial node R intensional predicate representing node reached The program stable model iff nodes graph reached According Proposition 3 program captured following sentence Ra xy cid5 cid6 E y x R y Rx cid5 Rx x y cid5 x xyzx cid2R R y y cid2R R z x cid2R R z xRx R y E y x y cid2R R x x cid2R R y cid6cid6 34 Adding choice rules Another widely extension normal logic program allow choice rules following form cid11 cid13 P cid7x 10 P predicate cid7x tuple variables associated P Intuitively choice rule P means intensional predicate P interpreted arbitrarily stable models The stable model answer set semantics normal logic programs choice rules possibly constraints deﬁned similarly grounding More precisely set ground rules choice rule form 10 structure M contains rules form cid11 cid13 P cid7u cid7u tuple domain elements M matches arity P The set ground constraints constraint form 9 structure M contains instances constraint M The answer set semantics propositional programs choice rules constraints deﬁned Gelfond Lifschitz transformation 22 Let p propositional atom A set atoms The reduct choice rule p relative A p p A cid21 Again set A propositional atoms said answer set propositional program Π choice rules constraints A cid20 Π 2 A minimal model Π A Then structure A said stable model ﬁrstorder normal program Π choice rules constraints EQ A ExtA IntA answer set ground program ΠA propositional case The following proposition shows programs choice rules captured ordered completions Proposition 4 Let Π normal logic program signature σ Ω σ set predicates σ C set constraints ChoiceΩ set choice rules predicate Ω A ﬁnite σ structure Then A answer set Π C ChoiceΩ iff exists model M following set sentences A reduct M σ For intensional predicate P following sentence cid2 cid3 cid7x 1cid2icid2k cid4 cid7yi cid2 Bodyi P cid7x For intensional predicate P Ω following sentence cid2 cid2 cid3 cid7x P cid7x cid7yi cid2 Bodyi cid10 cid4cid4 cid7z cid2QP cid7x cid7x cid2PQ cid7z 1cid2icid2k Q cid7zPosi Q ΩΠ Ω For triple intensional predicates P Q R Ω following sentence cid10 cid7xcid7ycid7zcid7x cid2PQ cid7y cid7y cid2Q R cid7z cid7x cid2P R cid7z P Q RΩΠ Ω Finally c C sentence ˆc 2 Firstly means A satisﬁes constraints Secondly A regarded model choice rule V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 11 Proof This assertion follows directly Proposition 3 following fact answer sets Π C ChoiceΩ exactly answer sets Π C Π program obtained Π rewriting rule form 1 head mentions predicates Ω following constraint β1 βk γ1 γl α cid2 Example 6 Consider following normal program constraints choice rules computing Hamiltonian circuits graph cid11 cid13 hcx y hcx y Ex y hcx y hcx z y cid3 z hc y x hcz x y cid3 z Rx hca x Rx R y hc y x Rx E extensional predicate representing edges graph constant representing particular node Hamiltonian circuit hcx y intensional predicate representing Hamiltonian circuit Rx intensional predicate check vertices Hamiltonian circuit In particular ﬁrst rule program choice rule guess possible Hamiltonian circuit According Proposition 4 program captured following sentence cid5 cid6 hc y x R y Rx R y hc y x y cid2R R x x cid2R R y cid6cid6 xy cid5 cid5 cid6 hca x Rx x cid5 Rx hca x y x xyzx cid2R R y y cid2R R z x cid2R R z cid6 cid5 xy hcx y Ex y cid5 hcx y hcx z y cid3 z xyz cid5 xyz hc y x hcz x y cid3 z xRx cid6 cid6 35 Arbitrary structures It worth mentioning correspondence classical ﬁrstorder models ordered completions stable models logic program holds ﬁnite structures In general result hold inﬁnite structures allowed For instance ordered completion Transitive Closure TC Example 3 ﬁnite structures capture TC inﬁnite structures Example 7 Transitive Closure continued Consider graph contains inﬁnite chain individual vertex Let a1 a2 inﬁnite chain Eaiai1 b node different ai Consider structure M signature E S cid2S S Sai j j Sai b aia j cid2S S aib cid2S S akal j cid2 l k j k l jb j It checked M model ordered completion TC Example 3 However clearly S transitive closure graph given example It remains question Transitive Closure captured ﬁrstorder theories inﬁnite auxiliary predicates Unfortunately answer negative Proposition 5 There exist ﬁrstorder theory signature contains signature TC reducts models exactly corresponding stable models TC arbitrary structures 12 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 Proof We prove assertion contradiction Let σ signature TC We assume φ ﬁrstorder theory vocabulary σ1 σ σ1 reducts models φ σ exactly stable models TC It known TC deﬁned universal secondorder theory 5 Therefore complement TC deﬁned existential secondorder theory Hence exists ﬁrstorder theory signature contains σ reducts models σ exactly complement class stable models TC arbitrary structures Let ψ theory signature σ2 Without loss generality assume σ1 σ2 σ Then φ cid20 ψ ﬁrst order language σ1 σ2 Thus according Craigs Interpolation Theorem exists theory φ0 signature σ1 σ2 σ φ cid20 φ0 φ0 cid20 ψ This shows TC exactly captured theory φ0 signature σ This contradicts wellknown result TC ﬁrstorder deﬁnable arbitrary structures 5 cid2 36 Disjunctive logic programs Disjunctive logic programs important extension normal programs dealing incomplete information 613 A disjunctive logic program ﬁnite set disjunctive rules following form α1 αn β1 βk γ1 γl 11 Similar normal programs distinguish intensional extensional predicates The answer set semantics disjunctive logic programs deﬁned similarly grounding 613 A natural question arises ordered completion extended ﬁrstorder disjunctive programs Un fortunately answer negative provided wellrecognized assumptions computational complexity theory true Actually following proposition shows stronger result exist disjunctive programs captured ﬁrstorder sentences larger signature Proposition 6 There exists disjunctive program Π captured ﬁrstorder sentence larger signature NP coNP That ﬁrstorder sentence φ signature contains signature Π reducts ﬁnite models exactly ﬁnite stable models Π Proof We following program 3UNCOLOR originated Example 2 6 captured ﬁrstorder sentences ﬁnite structures NP cid3 coNP Rx Gx Bx NC Ex y Rx R y NC Ex y Gx G y NC Ex y Bx B y Rx NC Gx NC Bx NC NC NC E extensional predicate represent graph R G B different colors respectively NC 0ary predicate claim graph colored It diﬃcult check program answer sets iff graph represented E colored colors In addition case unique answer set contains given graph NC interpretation R G B Assuming NP cid3 coNP coNP complete problem NP Hence problem 3uncolorability wellknown coNP complete problem NP By Fagins theorem 9 Boolean query 3uncolorability given graph deﬁned existential secondorder sentence On hand assume exists ﬁrstorder sentence φ signature contains signature 3UNCOLOR reducts ﬁnite models exactly corresponding ﬁnite stable models 3UNCOLOR Then Boolean query 3uncolorability deﬁned following existential secondorder sentence Pφ P set predicates including NC R G B predicates φ 3UNCOLOR contradiction This shows 3UNCOLOR captured ﬁrstorder sentences larger signature cid2 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 13 Following proof Proposition 6 Theorem 2 negative result likely ﬁrstorder disjunc tive logic programs reduced normal programs ﬁnite structures new predicates Corollary 7 Unless NP cid3 coNP normal program signature contains signature 3UNCOLOR reducts ﬁnite stable models exactly corresponding ﬁnite stable models 3UNCOLOR Proof Otherwise according Theorem 2 program 3UNCOLOR captured ﬁrstorder sentence larger signature cid2 In fact results coincide result presented 6 stating terms brave reasoning disjunc 2 normal programs tive logic programs stable model semantics exactly capture complexity class Σ P capture NP 4 Optimizations In section present techniques optimize ordered completion introduced Section 3 The goal techniques simplifying translation including reducing number new predicates arities new predicates overall length ordered completion As techniques presented combined For sake clarity introduce stepbystep 41 Exploiting maximal predicate loops In deﬁnition ordered completion introduce comparison predicate pair predicates This necessary We need pairs predicates belong strongly connected component predicate dependency graph program Formally predicate dependency graph ﬁrstorder program Π ﬁnite graph PGΠ cid22V Ecid23 V set intensional predicates Π P Q E iff rule head mentions P positive body contains Q Maximal predicate loops program Π strongly connected components PGΠ Since PGΠ constructed easily maximal predicate loops Π identiﬁed polynomial time respect size Π The ordered completions maximal predicate loops ordered completions com parison predicates cid2PQ deﬁned P Q belong maximal predicate loop More precisely ordered completion Π maximal predicate loops denoted OC1Π similar form ordered completion Π Deﬁnition 3 Q cid7z Eq 4 ranges intensional atoms positive Bodyi Q P maximal predicate loop Π P Q R Eq 4 intensional predicates belong maximal predicate loop Π The following proposition reﬁnement main theorem Proposition 8 Let Π normal logic program signature σ A ﬁnite σ structure Then A answer set Π exists model M OC1Π A reduct M σ Proof The proved similar construction comparison predicates cid2PQ deﬁned pairs P Q maximal predicate loop For prove contradiction Similarly sequence ground atoms P 0cid7a0 P 1cid7a1 P icid7ai P icid7ai IntMσ P icid7ai L ai1 hold Notice cid3 0 exists edge P P i1 PGΠ Again exists k l P kcid7ak Plcid7al Hence P k P k1 Pl maximal predicate loop Π L Hence according transitivity axioms respect L cid7al cid2Pl Pk1 ak1 holds This contradicts facts P kcid7ak Plcid7al cid7ak cid2Pk Pk1 ak1 holds cid2 cid7ai cid7ai cid2P P i1 ai1 cid2P i1 P In cases restricting comparison predicates maximal predicate loops results smaller ordered comple tion As benchmark logic programs predicate loops cases OC1Π exactly Clarks completion Π Even programs predicate loops optimization technique signiﬁcantly simplify ordered completion cases predicates predicate loop Let consider following program computing Hamiltonian circuits 14 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 Example 8 The following program HC encoding computing Hamiltonian circuits given graph 22 hcx y arcx y otherroutex y otherroutex y arcx y arcx z hcx z y cid3 z otherroutex y arcx y arcz y hcz y x cid3 z reached y arcx y hcx y reachedx initx reached y arcx y hcx y initx vertexx reachedx This program intensional predicates hc otherroute reached According original version ordered completion Deﬁnition 3 need introduce 9 comparison predicates maximal arity 4 However maximal predicate loops auxiliary predicate needed HC maximal predicate loop reached The comparison predicate needed cid2R R x y binary Hence OC1H C following set sentences xy xy cid5 cid6 hcx y arcx y otherroutex y cid5 otherroutex y z z cid5 arcx y arcx z hcx z y cid3 z cid5 arcx y arcz y hcz y x cid3 z cid6 cid6cid6 cid5cid5 y cid5 y cid5 cid6 x arcx y hcx y reachedx initx cid5 cid6cid6 x arcx y hcx y initx cid6 cid5 cid5 arcx y hcx y initx x cid5 x arcx y hcx y reachedx initx x cid2R R y y cid2R R x cid6 reached y reached y cid6cid6cid6 cid6 vertexx reachedx cid5 x xyzx cid2R R y y cid2R R z x cid2R R z 42 Folding reverse comparison predicates In deﬁnition ordered completion pair intensional predicates P Q introduce new comparison predicates cid2PQ cid2QP This simpliﬁed introducing derivation path ground atom way Formally abbreviate cid7x cid2PQ cid7y cid7y cid2QP cid7x cid7x PQ cid7y meaning derivation path P cid7x Q cid7y way We rank intensional predicates occurring Π P 1 Pn deﬁne RankP 1 cid2 cid2 n For maximal predicate loop L Π predicates P P j L introduce new compar ison predicate P P j RankP cid2 RankP j This method reduces half comparison predicates introduced The new version ordered completion folding reverse comparison predicates denoted OC2Π deﬁned based OC1Π cid7z cid2QP cid7x cid7x cid2PQ cid7z Eq 4 replaced cid7z QP cid7x RankQ cid2 RankP cid7x PQ cid7z RankQ RankP transitivity axioms Eq 4 respect predicate loop L replaced follows P L sentence cid7xcid7x P P cid7x P P j P k L RankP cid2 RankP j cid2 RankP k following sentences cid7xcid7ycid7zcid7x P P j cid7xcid7ycid7zcid7x P P j cid7y cid7y P j Pk cid7y cid7y P j Pk cid7z cid7x P Pk cid7z cid7x P Pk cid7z cid7z Proposition 9 Let Π normal logic program signature σ A ﬁnite σ structure Then A answer set Π exists model M OC2Π A reduct M σ cid7ai holds RankP i1 cid2 RankP cid7ai P P i1 Proof Again easy Now prove contradiction Similarly sequence ground atoms P 0cid7a0 P 1cid7a1 P icid7ai P icid7ai IntMσ P icid7ai ground loop L In addition ai1 P i1 P ai1 holds RankP i1 RankP Note rank P Since PQ RankP cid2 RankQ satisfy new transitivity axioms induction cid7a j holds RankP j RankP Again proved cid2 j ﬁnd k l P kcid7ak Plcid7al sequence Hence cid7al Pl Pk1 ak1 holds RankPl cid2 RankP k1 ak1 Pk1 Pl cid7al holds RankPl RankP k1 There cases cid7ai holds RankP j cid2 RankP j P j P ai P P j V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 15 Case 1 Case 2 Case 3 RankP k RankPl RankP k1 Then cid7al Pl Pk1 Plcid7al contradiction RankP k RankPl RankP k1 Then Plcid7al contradiction RankP k RankPl RankP k1 Then cid7al Pl Pk1 cid7ak holds Then according transitivity axioms cid7ak Pk Pk ak1 Pk1 Pl ak1 holds Therefore cid7ak Pk Pk1 cid7al holds Therefore ak1 Pk1 Pk ak1 holds P kcid7ak cid7ak holds P kcid7ak ak1 holds Therefore cid7ak Pk Pk1 ak1 holds Also cid7ak holds contradiction cid2 ak1 Pk1 Pk Example 9 Recall program Π1 Example 4 p1 p2 p2 p1 p1 p3 Then according deﬁnition OC2Π1 p2 p3 p1 p1 p2 p3 p1 p2 p1 p2 p2 p1 p1 p2 p1 p1 p1 p1 p1 p2 p2 p2 p1 p1 equivalent p1 p1 p1 p2 p2 p2 p2 p2 p2 p2 p1 p1 p1 p1 p1 p2 p1 p1 p1 p2 p1 p2 p2 p2 p2 p2 p1 p1 p1 p2 p2 p2 p2 p2 p1 p1 p1 p2 p1 p2 p2 p2 p2 p3 p1 p1 p2 p1 p2 p1 p2 p3 p2 p1 p1 p2 p1 p1 p2 p2 Then OC2Π1 models p3 p1 p2 p1 p2 43 Simplifying transitivity axioms p3 p1 p2 p1 p2 Hence Π1 answer sets p3 Now consider simplify transitivity axioms In deﬁnition ordered completion variations presented previously need introduce transitivity axioms intensional predicates P Q R maximal predicate loop RankP cid2 RankQ cid2 RankR In words expand maximal predicate loop complete graph introduce transitivity axioms vertices In fact reduced expanding maximal predicate loop conservatively Let Π program L P 1 Pn maximal predicate loop PGΠ The following procedure generates set triples undirected version L 1 pick vertex P undirected version L number edges 2 predicates Q R connected P undirected version graph add edge Q R select triples related predicates P Q R 3 delete vertex P L 4 step 1 repeat procedure till triples generated Example 10 Consider following program Π2 P 1cid7x1 P 2cid7x2 P 2cid7x2 P 3cid7x3 P 3cid7x3 P 4cid7x4 P 4cid7x4 P 1cid7x1 P 1cid7x1 P 5cid7x5 16 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 The predicate dependency graph Π2 contains nodes P 1 P 2 P 3 P 4 In OC2Π transitivity axioms need consider combination predicates counts 43 groups According procedure reduce number 2 33 groups First pick vertex number edges P 1 Then need connect P 2 P 4 connected P 1 predicate dependency graph Now triple selected P 1 P 2 P 4 Then delete node P 1 dependency graph The rest triple P 2 P 3 P 4 Hence need 2 33 groups triples generated It expected bigger predicate dependency graph transitivity axioms reduced Then ordered completion simplifying transitivity axioms denoted OC3Π deﬁned based OC2Π replacing transitivity axioms triples intensional predicates generated according procedure Proposition 10 Let Π normal logic program signature σ A ﬁnite σ structure Then A answer set Π exists model M OC3Π A reduct M σ Proof The proved similarly For prove contradiction Otherwise following proof techniques Proposition 9 sequence ground atoms P kcid7ak P k1 ak1 Plcid7al k cid2 cid2 l P icid7ai IntMσ k cid2 cid2 l P icid7ai ground loop ΠMσ k cid2 cid2 l 1 ai1 P i1 P RankP i1 RankP P kcid7ak Plcid7al cid7ai holds RankP i1 cid2 RankP cid7ai P P i1 ai1 P P i1 cid7ai ai1 holds Assume L sequence ground atoms satisﬁes conditions number ground atoms Select ground atom P icid7ai k cid2 cid2 l L P ﬁrst predicate calculated according pro ai1 According cedure predicates occurred ground loop L Now consider P i1 procedure triple cid22P i1 P P i1cid23 selected Then cases order ranks predicates P i1 P P i1 It checked matter order rank ai1 holds RankP i1 cid2 RankP i1 ai1 holds RankP i1 RankP i1 cid22P i1 P P i1cid23 satisfy new transitivity axioms Hence LP icid7ai satisﬁes conditions This contradicts assumption L number ground atoms satisfying conditions cid2 ai1 P i1 ai1 P i1 P i1 ai1 P i1 P i1 44 Ordered completion SMT In worst case transitive formulas ordered completion need introduce O m2 new predicates O s m3 new formulas m number intensional predicates s maximal arity intensional predicates Π consider program predicated dependency graph complete This heavy burden implementation To address issue propose alternative solution Inspired Niemeläs translation 23 use Satisﬁability Modulo Theories SMT 24 instead classical ﬁrstorder logic host language That translate normal logic program stable model semantics sentence ordered completion SMT classical ﬁrstorder logic Roughly speaking Satisﬁability Modulo Theories 24 ﬁrstorder theories background theories theory real numbers theory data structures For purpose need theory partial orders eliminate transitivity axioms The ordered completion SMT theory partial orders background theory basically version classical ﬁrstorder logic need transitivity axioms TranSΠ This comparison predicates cid2PQ regarded builtin predicates theory partial orders naturally satisfy transitivity In sense ordered completion Π SMT theory partial orders background theory simply modiﬁed Clarks completion Π MCompΠ However theory partial orders wellsupported modern SMT solvers To address issue capturing ordered completion use linear arithmetic background theory SMT The main reason linear arithmetic supported modern SMT solvers Z33 Formally ordered completion SMT linear arithmetic background theory deﬁned follows Deﬁnition 4 Ordered completion SMT Let Π normal logic program The SMTordered completion Π denoted OC cid16Π following set sentences intensional predicate P 3 httpresearchmicrosoftcomenusumredmondprojectsz3 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 17 cid4 cid7yi cid2 Bodyi P cid7x cid2 cid3 cid7x 1cid2icid2k cid2 cid7x P cid7x cid2 cid7yi cid2 Bodyi cid3 1cid2icid2k cid10 cid4cid4 n Q cid7z n P cid7x Q cid7zPosi Q ΩΠ notations borrowed Deﬁnition 3 In addition intensional predicate P arity n n P function domain tuples integers n P Dn N builtin predicate linear arithmetic meaning We stable models program equivalently captured SMTordered completion Theorem 3 Let Π normal logic program signature σ A ﬁnite σ structure Then following statements equivalent 1 A answer set Π 2 exists model M OCΠ A reduct M σ 3 exists model Mcid16 cid16Π A reduct Mcid16 OC σ Proof Theorem 2 proves 1 2 Now 2 3 Suppose structure M signature σ cid2PQ P Q ΩΠ model OCΠ MCompΠ TranSΠ Since M satisﬁes TranSΠ deﬁne order cid4 set IntM intensional ground atoms P cid7u P ΩΠ cid7u P M Π follows P cid7u IntM P cid7u cid4 P cid7u pair P cid7u Q cid7v IntM P cid7u cid4 Q cid7v iff cid7u cid7v cid2PQ pair P cid7u Q cid7v IntM write P cid7u Q cid7v iff P cid7u cid4 Q cid7v Q cid7v cid4 P cid7u M Clearly cid4 partial order IntM comparison predicates cid2PQ satisfy transitivity axioms TranSΠ There fore cid4 extended total order called linear order cid4cid16 IntM We construct mapping f IntM natural numbers f IntM N P cid7u IntM f P cid7u position P cid7u total order cid4cid16 f P cid7u t iff exist t elements E1 Et IntM E cid3 E j 1 cid2 j cid2 t E cid4cid16 P cid7u That 1 cid2 cid2 t Now construct Mcid16 based M f follows domain M constant interpretations M Mcid16 M P σ P Q ΩΠ cid7u Mn n Q cid7u f Q cid7u Mcid16 P cid16Π M model MCompΠ intensional ground It shown Mcid16 atoms P cid7u Q cid7v IntM cid7u cid2PQ cid7v cid7u cid7v cid2PQ For 3 2 suppose structure Mcid16 model OC cid16Π We construct M structure M σ cid2PQ P Q ΩΠ M agrees signature σ cid7u cid7v cid2PQ iff n P cid7u n Q cid7v n P cid7u n Q cid7v Following similar arguments shown M model MCompΠ In addition M model TranSΠ functions n P naturally yield total order partial order IntM IntMcid16 Hence M model OCΠ cid2 iff n P cid7u n Q cid7v n P cid7u n Q cid7v M σ n P P ΩΠ model OC 5 Implementation experimental results To best knowledge ordered completions provide ﬁrst time translation ﬁrstorder normal logic programs stable model semantics classical ﬁrstorder logic ﬁnite structures Signiﬁcantly trans lation enables develop new kind ASP solvers grounding programs ordered completion instead program 51 Implementation In section report ﬁrst implementation solver In order consistent existing ASP solvers consider Herbrand structures arbitrary structures stage As stated Section 23 context proposed semantics coincides Gelfond Lifschitzs original semantics 12 Following current practice input program divided parts 18 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 Fig 2 Traditional ASP solvers Fig 3 Our new ASP solver 1 ﬁrstorder normal logic program 2 set ground facts deﬁnes extensional predicates4 We set extensional database Our goal compute answer sets program based given set ground facts answer set interpretations extensional predicates coincide extensional database It worth mentioning ﬁrstorder logic program different extensional databases provided For instance transitivity closure program TC Example 1 extensional database graph edges represented E graph Fig 1 Our goal compute answer set program TC based given graph What need compute interpretation intensional predicates S example represents transitive closure graph Again TC program extensional database graph purpose TC compute transitive closure given graph Typically existing ASP solvers components Fig 2 1 A grounder lparse5 gringo6 transforms ﬁrstorder logic program set ground facts propositional program 2 A propositional ASP solver clasp7 cmodels8 lp2diff9 computes answer sets propositional program correspond answer sets original ﬁrstorder program based ground facts Using ordered completion differently Fig 3 cid16 cid16 cid16 1 2 3 A translator translates ﬁrstorder logic program ordered completion Deﬁnition 3 A grounder transforms ordered completion set ground facts propositional theory A SATSMT solver called compute models propositional theory correspond answer sets original ﬁrstorder program based ground facts Theorem 23 We following potential beneﬁts approach Grounding ordered completion ﬁrstorder sentence based semantics classical logic Therefore simpliﬁcation techniques classical ﬁrstorder logic available logic programs 4 Notice set ground facts contains information intensional predicates 5 httpwwwtcshutﬁSoftwaresmodels 6 httpsourceforgenetprojectspotasscoﬁlesgringo 7 httpwwwcsunipotsdamdeclasp 8 httpwwwcsutexasedutagcmodels 9 httpwwwtcshutﬁSoftwarelp2diff V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 19 stable semantics These simpliﬁcation techniques crucial scale grounding process deal large extensional databases In addition simpliﬁcation technique run time grounding similar techniques simplify ordered completion ﬁrstorder program extensional database given Importantly line ﬁrstorder logic program The SAT solver black box Any SAT solver Hence beneﬁt progress SAT Based Theorem 3 implemented prototype new ASP solver contains steps First trans cid16Π Notice optimization techniques mentioned late program Π SMTordered completion OC cid16Π propositional SMT theory Section 4 Second use grounder groc ground OC Finally SMT solver Z3 compute model SMT theory Theorem 3 corresponding answer set Π Next report preliminary experimental results solver Hamiltonian Circuit program Example 8 compared major modern ASP solvers 52 Experimental results The goal experiments compare new ASP solver existing ASP solvers Again input divided parts ﬁrstorder program set ground facts extensional database The output return answer set program based extensional database exists return As mentioned earlier order solve problem existing ASP solvers normally use 2step approach First grounder transform ﬁrstorder program extensional database propositional pro gram In experiments use gringo version 303 grounder Secondly propositional ASP solver called compute answer set In paper consider different propositional ASP solvers clasp version 201 cmodels version 381 lp2diff version 127 Z3 version 3218 Our solver needs 3 steps First translate ﬁrstorder program SMTordered completion As step normally fast line count time step Secondly implemented ﬁrstorder theory grounder called groc use transform ordered completion extensional database proportional SMT theory Finally SMT solver compute model SMT theory answer set program based extensional database Theorem 3 We use Z3 version 3218 SMT solver step We consider Hamiltonian Circuit benchmark program Niemelä 22 Example 8 The current benchmark graph instances HC program normally contain 150 nodes Here instead consider bigger graph instances That consider random graphs nodes ranging 200 1000 numbers edges times numbers nodes The graph instances named rand_nodes_edges_number rand means random graph nodes represents number nodes graph edges represents number edges graph number code graph category For instance rand_200_2000_6 random graph 200 nodes 2000 edges 6th graph instance category Table 1 reports runtime data experiments HC program relatively big graph instances The experiments performed CENTOS version 2160 LINUX platform 2 GB memory AMD Phenom 9950 QuadCore processor running 26 GHz For space reasons report overall time following different approaches gringo grounder clasp propositional ASP solver gringo clasp gringo grounder cmodels propositional ASP solver gringo cmodels gringo grounder lp2diff translator propositional programs SMT Z3 SMT solver gringo ﬁnally solver groc ground ordered completion extensional databases calling lp2diff Z3 SMT solver Z3 groc Z3 We set timeout threshold 900 seconds denoted experimental results In Table 1 ﬁrst column speciﬁes graph instances In second column y n means corresponding graph Hamiltonian Circuit means problem instance solved approaches limited time The rest columns record overall time seconds different approaches It worth mentioning normally grounding time gringo groc solving time Table 1 shows solver compares favorably Hamiltonian Circuit benchmark program especially big graph instances For 200node random graphs solver good gringo classp general looks slightly better However graph goes bigger advantages emerge For 400 node 600node graphs solver clearly outperforms approaches Moreover 1000node random graphs solver capable solving problems time threshold Also interesting closer 20 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 Table 1 Experimental results Hamiltonian Circuit program Instances rand_200_2000_1 rand_200_2000_2 rand_200_2000_3 rand_200_2000_4 rand_200_2000_5 rand_400_4000_1 rand_400_4000_2 rand_400_4000_3 rand_400_4000_4 rand_400_4000_5 rand_600_6000_1 rand_600_6000_2 rand_600_6000_3 rand_600_6000_4 rand_600_6000_5 rand_1000_10000_1 rand_1000_10000_2 rand_1000_10000_3 rand_1000_10000_4 rand_1000_10000_5 gringo clasp gringo cmodels gringo lp2diff Z3 groc Z3 y y n y y y y y y y y y y y y y y y y 0325 0604 0175 1453 0329 24110 140830 3130 3310 0150 7960 7600 6954 10185 2507 18412 8899 49506 46938 162277 114973 203500 340219 83650 403075 179 195 000 166 1524 508 5931 810 800 1216 3841 4584 5213 920 32422 13366 9932 25691 29589 look instance answer sets rand_200_2000_3 With grounder groc inconsistency immediately identiﬁed More importantly reasonable believe performance solver improved employing optimization techniques In particular interesting technique developed simplify ordered completion As mentioned earlier line needs program We observed logic programs ordered completion simpliﬁed yield ﬁrstorder sentence signiﬁcantly smaller size To important future work 6 Related work discussions In section discuss compare translation translations logic programs stable model answer set semantics classical logic In general intuitions translations similar The main differences ways intuitions formalized 61 Firstorder case Other ﬁrstorder translations As focus paper consider ﬁrstorder case ﬁrst review existing work translating ﬁrstorder logic programs stable model semantics standard ﬁrstorder logic To best knowledge translation loop formula approach 216 From syntactical viewpoint main difference approach ordered completion results ﬁnite ﬁrstorder theory represented single ﬁrstorder sentence uses auxiliary predicates loop formula approach use auxiliary predicates general results inﬁnite ﬁrstorder theory From semantical viewpoint approaches share similar ideas First extended Clarks completion extended parts play similar role eliminate structures models Clarks completion stable models logic program The main difference loop formula approach uses loop formulas purpose ordered completion uses additional comparison predicates track deriva tion order Secondly require ground atom stable model justiﬁed certain derivation path However purpose loop formula approach claims loop ground atom external supports ordered completion approach explicitly enumerates derivation order derivation path new comparison predicates Similar translations Datalog Another related work 15 area ﬁnite model theory ﬁxedpoint logic Al ﬁxedpoint logic normal logic programming comparable common fragment Datalog Kolaitis 15 showed ﬁxedpoint query conjunctive deﬁnable ﬁnite structures That given ﬁxedpoint cid16 implicitly deﬁnable ﬁnite query Q exists ﬁxedpoint query Q structures As consequence Datalog query conjunctively deﬁnable ﬁnite structures From result al tedious actually derive translation Datalog ﬁrstorder sentences new predicates signatures original Datalog programs conjunctive query Q Q cid16 We details comparing translation derived Kolaitis result focus normal logic programs Suﬃce different ways based V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 21 Clarks completion sense additional conditions added necessary parts intensional predicates derived Kolaitis result We mention work Kolaitis result inspired initial study topic We speculated possible translate Datalog programs ﬁrstorder sentences new predicates possible normal logic programs true doable modifying Clarks completion As happened turned case 62 Propositional case Translations propositional case The ordered completion viewed propositional translation normal logic programs propositional theories treating propositional atom 0ary predicate Several proposals direction proposed literature 114181923 An early attempt BenEliyahu Dechter 1 assigned index level numbering p propo sitional atom p added assertions p q Clarks completion pair p q similar ordered completion q head rule p ranges atoms positive body rule A closely related work recently proposed Niemelä 23 level mappings comparisons captured difference logic extension classical propositional logic More precisely atom p assigned number xp meaning level stage Then assertions xq 1 cid3 xp added Clarks completion similar BenEliyahu Dechter dered completion In addition approaches optimization technique exploiting strongly connected components discussed Another translation sharing basic idea comparing stages indices Janhunen 14 proposed simpliﬁed translation level numbering Different approaches Lin Zhao 18 translated arbitrary normal logic program equivalently tight program ﬁrst adding new atoms use Clarks completion new program capture answer sets original Finally loop formula approach propositional case 19 yields translation propositional normal logic programming propositional logic Again loop formula approach requires new atoms However polynomial sense program exponential loop formulas worst case Comparisons BenEliyahu Dechters Niemeläs work Here discuss relationships ordered completion BenEliyahu Dechters translation Niemeläs work translations closely related slightly different In fact translations basically share intuitions propositional case This modiﬁed Clarks completion adding comparisons indiceslevelsstages Speciﬁcally comparisons represented cid2pq cid2qp ordered completion p q BenEliyahu Dechters translation xq 1 cid3 xp Niemeläs work approaches q head rule p ranges atoms positive body rule Indeed assertions play role state stage level p q In sense modiﬁed completion approaches transformed In BenEliyahu Dechters translation explicitly enumerate indices p comparisons p q propositional logic 1 turns complicated This issue Niemeläs work 23 level numbering xp associated atoms comparisons xq 1 cid3 xp directly represented built predicates language difference logic Finally ordered completion introduce indices directly use additional atoms cid2pq classical propositional logic explicitly represent comparisons cid2pq cid2pq speciﬁed transitivity formulas The similarities differences approaches illustrated following example Example 11 Recall program Π1 Example 4 p1 p2 p2 p1 p1 p3 According deﬁnitions modiﬁed completion Π1 ordered completion p2 p3 p1 p1 p2 cid5 cid2p1 p2 p1 p2 cid2p2 p1 cid2p2 p1 p2 p1 cid2p1 p2 cid5 p3 cid6 cid6 BenEliyahu Dechters translation p2 p3 p1 p1 p2 cid5 p1 p2 p2 p1 p3 cid6 p2 p1 p1 p2 cid5 cid6 22 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 ﬁnally Niemeläs work is10 p2 p3 p1 p1 p2 cid5 p1 p2 xp1 p2 p1 xp2 1 cid3 xp2 1 cid3 xp1 p3 cid6 cid5 cid6 It observed modiﬁed completion approaches easily obtained For instance Niemeläs work ordered completion needs replace subformula form xp 1 cid3 xq xp1 1 cid3 xp2 corresponding counterpart cid2qp cid2pq ordered completion cid2p2 p1 cid2p1 p2 resp The main difference approaches translation encode new indices comparisons The host formalism BenEliyahu Dechters translation ordered completion propositional logic Niemeläs work difference logic extension classical propositional logic linear constraints propositional logic As result encoding problem comparisons Niemeläs work 1 cid3 xp2 naturally represented language difference logic issue comparisons xp1 builtin predicate cid3 However approaches work need In ordered completion use additionally transitivity formulas new atoms cid2pq purpose For instance program Π1 transitivity formulas is11 cid2p1 p2 cid2p2 p1 cid2p2 p1 cid2p1 p2 cid2p1 p1 cid2p2 p2 In BenEliyahu Dechters translation needs explicitly encode indices p comparisons p q classical propositional logic This complicated enumerate possibilities For instance program Π1 encoding index p1 cid5 p1 1 p1 2 cid6 p1 1 p1 2 encoding comparison instance p1 p2 p1 1 p2 2 63 Firstorder deﬁnability weak deﬁnability Since ordered completion translating logic programs ﬁrstorder logic closely related concepts ﬁrstorder deﬁnability answer set programming 1627 A program ﬁrstorder deﬁnable ﬁnite structures iff exists ﬁrstorder sentence signature pro gram ﬁnite models exactly ﬁnite stable models program It known programs ﬁrstorder deﬁnable program TC Example 1 arbitrary structures ﬁnite structures 5 A weaker notion ﬁrstorder deﬁnability allow new predicates A program ﬁrstorder weakly deﬁnable ﬁnite structures iff exists ﬁrstorder sentence signature containing signature program reducts ﬁnite models signature program exactly ﬁnite stable models program It easy program weakly deﬁnable ﬁnite structures deﬁned existential secondorder sentence ﬁnite structures The following result immediately follows Theorem 2 Corollary 11 Every normal logic program weakly deﬁnable ﬁnite structures More precisely program weakly deﬁned ordered completion ﬁnite structures However shown Proposition 5 result hold arbitrary structures For instance TC program weakly deﬁnable arbitrary structures In fact following similar proof Proposition 5 extended following result Proposition 12 On arbitrary structures normal logic program deﬁnable weakly deﬁnable 10 It observed new atoms bdi 11 All transitive formulas trivially true Niemeläs work necessary V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 23 New predicates Allowed Not allowed Not allowed Allowed Resulting theory No restriction Finite No restriction Finite Translation Does exist Does exist Loop formula Ordered completion Table 2 From normal ASP FOL Structures Arbitrary Finite Finite Finite 7 Conclusion The main contribution paper introducing notion ordered completion captures exactly answer set semantics ﬁrstorder normal logic programs constraints choice rules ﬁnite structures Theorem 2 Propositions 3 4 It summarized follows For ﬁrstorder normal logic programs ﬁnite structures Answer set Clarks completion Derivation order Ordered completion This tight result First seen result extended disjunctive logic programs NP coNP Proposition 6 For normal logic programs result complete picture mappings logic programs ﬁrstorder logic summarized Table 2 The signiﬁcance ordered completion seen theoretical practical point view To best knowledge provides ﬁrst time translation ﬁrstorder normal logic programs stable model semantics ﬁrstorder sentences Furthermore makes possible implement new ASP solver grounding ﬁrstorder theory instead program idea motivated work 2 We report ﬁrst implementation solver Section 5 experiments Hamiltonian Circuit problems far best known benchmark logic programs loops Our results clearly showed new solver competitive edge large problems Table 1 We working improving solver believe new results report near future Acknowledgements We like thank anonymous reviewers valuable comments This research supported ARC Discovery project grant DP0988396 HK RGC GRF 616909 NSFC grants 90718009 60963009 References 1 BenEliyahu Rachel Rina Dechter Propositional semantics disjunctive logic programs Annals Mathematics Artiﬁcial Intelligence 12 12 1994 5387 2 Yin Chen Fangzhen Lin Yisong Wang Mingyi Zhang Firstorder loop formulas normal logic programs Proceedings 10th International Conference Principles Knowledge Representation Reasoning KR06 2006 pp 298307 3 Yin Chen Fangzhen Lin Yan Zhang Yi Zhou Loopseparable programs ﬁrstorder deﬁnability Artiﬁcial Intelligence 175 34 2011 890913 4 Keith L Clark Negation failure H Gallaire J Minker Eds Logics Databases Plenum Press New York 1978 pp 293322 5 HeinzDieter Ebbinghaus Jörg Flum Finite Model Theory SpringerVerlag 1995 6 Thomas Eiter Georg Gottlob Heikki Mannila Disjunctive Datalog ACM Transactions Database Systems 22 3 1997 364418 7 Fran cois Fages A new ﬁxpoint semantics general logic programs compared wellfounded stable model semantics New Generation Computing 9 34 1991 425443 8 Fran cois Fages Consistency Clarks completion existence stable models Journal Methods Logic Computer Science 1 1994 5160 9 Ronald Fagin Contributions model theory ﬁnite structures PhD Thesis UC Berkeley 1973 10 Paolo Ferraris Joohyung Lee Vladimir Lifschitz A new perspective stable models Artiﬁcial Intelligence 175 1 2011 236263 11 Paolo Ferraris Answer sets propositional theories Proceedings 8th International Conference Logic Programming Nonmonotonic Reasoning LPNMR05 2005 pp 119131 12 Michael Gelfond Vladimir Lifschitz The stable model semantics logic programming Proceedings Fifth International Conference Symposium ICLP88 1988 pp 10701080 13 Michael Gelfond Vladimir Lifschitz Classical negation logic programs disjunctive databases New Generation Computing 9 34 1991 365386 14 Tomi Janhunen Representing normal programs clauses Proceedings 16th European Conference Artiﬁcial Intelligence ECAI04 2004 pp 358362 15 Phokion G Kolaitis Implicit deﬁnability ﬁnite structures unambiguous computations preliminary report Proceedings Fifth Annual Symposium Logic Computer Science LICS90 1990 pp 168180 16 Joohyung Lee Yunsong Meng On loop formulas variables Proceedings Eleventh International Conference Principles Knowledge Representation Reasoning KR08 2008 pp 444453 17 Vladimir Lifschitz R Tang Lappoon Hudson Turner Nested expressions logic programs Annals Mathematics Artiﬁcial Intelligence 25 34 1999 369389 18 Fangzhen Lin Jicheng Zhao On tight logic programs translation normal logic programs propositional logic Proceedings 18th International Joint Conference Artiﬁcial Intelligence IJCAI03 2003 pp 853858 24 V Asuncion et al Artiﬁcial Intelligence 177179 2012 124 19 Fangzhen Lin Yuting Zhao ASSAT computing answer sets logic program SAT solvers Artiﬁcial Intelligence 157 12 2004 115137 20 Fangzhen Lin Yi Zhou From answer set logic programming circumscription logic GK Artiﬁcial Intelligence 175 1 2011 264277 21 Victor W Marek Miroslaw Truszczynski Stable models alternative logic programming paradigm The Logic Programming Paradigm A 25 Year Perspective SpringerVerlag 1999 pp 375398 22 Ilkka Niemelä Logic programs stable model semantics constraint programming paradigm Annals Mathematics Artiﬁcial Intelli gence 25 34 1999 241273 23 Ilkka Niemelä Stable models difference logic Annals Mathematics Artiﬁcial Intelligence 53 14 2008 313329 24 Robert Nieuwenhuis Albert Oliveras Cesare Tinelli Solving SAT SAT modulo theories abstract DavisPutnamLogemannLoveland proce dure DPLLT Journal ACM 53 6 2006 937977 25 David Pearce Agustín Valverde Towards ﬁrst order equilibrium logic nonmonotonic reasoning Proceedings 9th European Conference Logics Artiﬁcial Intelligence JELIA04 2004 pp 147160 26 David Pearce A new logical characterisation stable models answer sets NonMonotonic Extensions Logic Programming NMELP96 1996 pp 5770 27 Yan Zhang Yi Zhou On progression semantics boundedness answer set programs Proceedings Twelfth International Conference Principles Knowledge Representation Reasoning KR10 2010 pp 518527