Artiﬁcial Intelligence 187188 2012 5289 Contents lists available SciVerse ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Conﬂictdriven answer set solving From theory practice Martin Gebser Benjamin Kaufmann Torsten Schaub Universität Potsdam Institut für Informatik AugustBebelStr 89 D14482 Potsdam Germany r t c l e n f o b s t r c t Article history Received 19 March 2010 Received revised form 26 February 2012 Accepted 5 April 2012 Available online 10 April 2012 Keywords Answer set programming Logic programming Nonmonotonic reasoning We introduce approach computing answer sets logic programs based concepts successfully applied Satisﬁability SAT checking The idea view inferences Answer Set Programming ASP unit propagation nogoods This provides uniform constraintbased framework capturing diverse inferences encountered ASP solving Moreover approach allows apply advanced solving techniques area SAT As result present ﬁrst fullﬂedged algorithmic framework native conﬂictdriven ASP solving Our approach implemented ASP solver clasp demonstrated competitiveness versatility winning ﬁrst places solver contests 2012 Elsevier BV All rights reserved 1 Introduction Answer Set Programming ASP 67941026687665 attractive paradigm knowledge representation reasoning appealing combination rich simple modeling languages1 powerful solving engines Albeit specialized ASP solvers highly optimized cf 1198315 performance far matched modern solvers Satisﬁability SAT 12 checking However computational mechanisms SAT ASP solvers faroff witnessed SATbased ASP solvers assat 90 cmodels 71 Nonetheless stateoftheart lookback techniques SAT generally Constraint Programming CP 26113 backjumping conﬂictdriven learning established native ASP solvers In fact previous approaches adopt techniques 12611291 implementationspeciﬁc focus describing modiﬁcations existing ASP solving approaches lack generality We address deﬁciency introducing novel computational approach ASP solving building Boolean straints Apart fact allows easily integrate solving techniques related areas like SAT backjumping conﬂictdriven learning restarts provides uniform characterization inferences logic program rules unfounded sets conﬂict conditions As major results inferences ASP solv ing reduced unit propagation nogoods devise ﬁrst selfcontained algorithmic framework native conﬂictdriven ASP solving While general outline search ConﬂictDriven Clause Learning CDCL 971272396 stateoftheart algorithm industrial SAT solving integration unfounded set checking particular ASP owed elevated expressiveness cf 1177688 However approach favors local unit propagation unfounded set checks tests inherent loop nogoods unit violated We elaborate This paper combines extends work presented Anger et al 2005 2 Gebser et al 2007 2007 2009 545256 Corresponding author Tel 49 331 977 30803081 fax 49 331 977 3122 Torsten Schaub aﬃliated School Computing Science Simon Fraser University Burnaby Canada Institute Integrated Intelligent Systems Griﬃth University Brisbane Australia Email addresses gebsercsunipotsdamde M Gebser kaufmanncsunipotsdamde B Kaufmann torstencsunipotsdamde T Schaub 1 The interested reader referred 1204583 detailed accounts ASPs modeling languages 00043702 matter 2012 Elsevier BV All rights reserved httpdxdoiorg101016jartint201204001 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 53 formal properties conﬂictdriven algorithmic framework demonstrate soundness completeness ASP solving Our approach led implementation awardwinning ASP solver clasp taking ﬁrst places ASP CASC MISC PB SAT contests 2011 110 details We discuss major features clasp provide empirical evaluation performance comparing stateoftheart ASP solvers class NP decision problems second ASP competition 28 Generally clasp powerful native ASP solver offering reasoning modes attractive tool knowledge representation reasoning2 This witnessed increasing number applications relying clasp derivatives reasoning engine 9913801227564 Along grounder gringo 51 clasp constitutes central component Potassco 44 Potsdam Answer Set Solving Collection bundling tools ASP developed University Potsdam The outline paper follows After establishing formal background provide Section 3 constraint based speciﬁcation answer sets terms nogoods Based uniform characterization develop Section 4 algorithms ASP solving incorporate advanced lookback techniques In Section 5 awardwinning ASP solver clasp implementing approach Section 6 provides systematic empirical evaluation demonstrating com petitiveness clasp We conclude related work summary Proofs formal results provided Appendix A 2 Background Given alphabet P propositional normal logic program ﬁnite set rules form p0 p1 pm pm1 pn 1 0 cid2 m cid2 n pi P atom 0 cid2 cid2 n A body literal atom p default negation p For rule r 1 let headr p0 head r bodyr p1 pm pm1 pn body r The intuitive reading r headr true bodyr holds p1 pm provably true pm1 pn assumed false Given set β body literals let β p P p β β p P p β For bodyr pm1 pn The set atoms occurring logic program Π bodyr denoted atomΠ bodyΠ bodyr r Π set bodies rules Π For regrouping rule bodies sharing head p deﬁne bodyΠ p bodyr r Π headr p A set X P atoms model logic program Π headr X bodyr X cid7 holds r Π In ASP semantics Π given answer sets 67 The reduct Π X Π relative X deﬁned X Note Π X Horn program possessing unique minimal Π X headr bodyr model cf 30 Given X answer set Π X minimal model Π X Note answer set Π model Π converse hold general p1 pm bodyr r Π bodyr cid2 X bodyr The positive dependency graph program Π given atomΠ cid2 atomΠ cid2 p headr set vertices directed edges respectively This graph allows identify circular r Π p bodyr positive dependencies atoms According 90 nonempty L atomΠ loop Π pair p L q L including p q path nonzero length p q atomΠ cid2 vertices path belong L We denote set loops Π loopΠ loopΠ loopΠ cid7 Π tight non tight program As shown 40 exploited Section 3 answer sets tight program Π coincide models Clark completion Π 21 referred supported models Π 3 A strongly connected component atomΠ cid2 maximal subgraph pair vertices connected path nontrivial contains edge Note loop L Π atoms L belong nontrivial strongly connected component atomΠ cid2 Moreover Π tight iff atomΠ cid2 include nontrivial strongly connected component Example 21 Consider following logic program3 cid3 cid2 Π2 b d c e c d e b e e 2 This program answer sets c d Note Π2 nontight positive dependency graph contains nontrivial strongly connected component e e e In practice propositional logic programs usually obtained inputs ﬁrstorder language cf 1204583 grounding We grounding mention offtheshelf grounders dlvs grounding component 105 gringo 51 lparse 120 available accomplish task Moreover particular classes logic 2 Beyond search answer set propositional normal logic program detailed paper clasp supports socalled extended rules 47 solution enumeration 5357 optimization 48 Due versatile core engine clasp run solver ASP SAT Maximum Satisﬁability MaxSAT 85 PseudoBoolean PB 114 constraint satisfactionoptimization incorporating dedicated frontends diverse input formats 3 Our enumeration scheme particular logic programs Π follows equations 54 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 programs admit language extensions like classical negation disjunctions 68 nested expressions 89 propositional formulas 10641 cardinality weight constraints 119 aggregates 39 In paper focus mainly normal propositional logic programs particular solving decision problem answer set existence For details broader overviews area ASP refer interested reader 665 The concepts introduced central context conﬂictdriven answer set computation A Boolean assignment A domain domA sequence σ1 σn signed literals σi form Tv Fv v domA 1 cid2 cid2 n v cid7 v j j cid2 n A literal Tv expresses v true Fv false We omit attribute signed literals clear context We denote complement literal σ σ Tv Fv Fv Tv The sequence obtained appending literal σ A denoted A σ We abuse notation identify assignment set contained literals Given access true false members A AT v domA Tv A AF v domA Fv A For A σ1 σi1 σi σn let Aσi σ1 σi1 preﬁx A relative σi deﬁne Aσ A σ A For canonical representation Boolean constraints rely concept nogood cf 26113 reﬂecting par tial assignments extended solution In setting nogood set σ1 σm signed literals expressing assignment containing σ1 σm unintended4 Accordingly nogood σ1 σm violated assignment A σ1 σm A In turn assignment A AT AF domA solution set cid5 nogoods nogood cid5 violated A Given nogood δ assignment A literal σ A unitresulting δ wrt A δ A σ This designates σ single literal δ contained A σ necessarily added A avoiding violation δ Note violated nogood unitresulting literal prerequisite σ A precludes duplicates A contains σ unitresulting5 For example Fq unitresulting nogood Fp Tq wrt assignment Fp wrt Fp Fq Fp Tq Along lines SAT set cid5 nogoods refer iterated process extending A unitresulting literals unit propagation We nogood δ antecedent σ wrt A σ unitresulting δ wrt preﬁx Aσ In turn σ A implied cid5 wrt A antecedent σ wrt A cid5 3 Nogoods logic programs Inferences ASP solving rely truth values atoms applicability program rules expressed assignments atoms bodies Given program Π ﬁx domain assignments A domA atomΠ bodyΠ Such hybrid approach result exponentially smaller search space traversals purely atom bodybased approach 6362 allows succinct representation nogoods section While syntactic translations logic programs clauses cf 57086 primarily aim reducing ASP SAT solving nogoods provided semantic conditions assignment atomΠ bodyΠ represents answer set Π Our approach guided idea Lin Zhao 90 decomposes ASP solving local inferences obtainable Clark completion 21 program obtainable loop formulas 90 While Clark completion captures answer sets tight programs compactly terms theories propositional logic 40 exponentially loop formulas required addition extend characterization answer sets nontight programs 88 31 Completion nogoods We begin nogoods capturing constraints induced Clark completion program use denoting classical connectives propositional logic Then Clark completion program Π deﬁned follows cid4 pβ p1 pm pm1 pn cid4 p pβ1 pβk cid5 cid5 p atomΠ bodyΠ p β1 βk cid6 cid5 cid5 β bodyΠ β p1 pm pm1 pn cid6 3 4 This formulation relies atoms p auxiliary propositions pβ representing bodies β Such propositions introduced Conjunctive Normal Form CNF transformations abbreviations avoiding exponential blowup 123 The models Clark completion program called supported models 3 tight programs coincide answer sets 40 The equivalences 3 deﬁne propositions standing bodies 4 deﬁne atoms terms sup porting bodies For identifying underlying constraints begin bodyoriented equivalences 3 In fact decomposed kinds implications considered 4 Any nogood σ1 σm syntactically represented clause σ1 σm dropping T replacing F σ1 σm stay syntax propositional logic representations like logic program rules PB constraints Boolean circuit gates possible 5 The concept unitresulting literal closely related unit clauses considered SAT cf 12 clause unit iff nogood represents unitresulting literal M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 55 Table 1 Bodyoriented nogoods cid5bodyΠ2 Body β d δβ F Fnot Fa Fa d Ta Fd c e Fnot c e Fc Fe b e Fb Tb Fe Te Table 2 Atomoriented nogoods cid5atomΠ2 Atom p b c d e cid5p Fa T Fb Tnot Fc Ta d Fd Tnot c e Fe Tb Fe Te cid5β Tnot Ta Ta d Fa Ta d Td Tnot c e Tc Tnot c e Te Tb Fb Te Fe δp Ta F Tb Fnot Tc Fa d Td Fnot c e Te Fb Fe On hand obtain p1 pm pm1 pn pβ That body β rule holds body literals true Conversely literal β false β hold So given body β p1 pm pm1 pn previous implication expresses nogood δβ Fβ Tp1 Tpm Fpm1 Fpn Note nogoods treat atoms bodies equitable objects In terms unit propagation δβ constraint enforcing truth β falsity contained literal For instance body d Program Π2 obtain δa d Fa d Ta Fd Table 1 On hand body β false literals false literals β true β holds This expressed second implication obtained 3 viz pβ p1 pm pm1 pn It equivalent conjunction clauses pβ p1 pβ pm pβ pm1 pβ pn For β p1 pm pm1 pn clauses induce following set nogoods Tβ Fp1 Tβ Fpm Tβ Tpm1 Tβ Tpn Taking body d gives cid5a d Ta d Fa Ta d Td cid5β cid6 cid4 We come constraints primarily aiming atoms In analogy derive corresponding nogoods equivalences 4 To begin implication pβ1 p tells atom p true element bodyΠ p holds conversely elements bodyΠ p false p false For bodyΠ p β1 βk set nogoods6 cid5p Fp Tβ1 Fp Tβk pβk cid6 cid4 For example atom e Program Π2 bodyΠ2 e b e obtain cid5e Fe Tb Fe Te Ta ble 2 Finally according implication p pβ1 pβk element bodyΠ p hold p true p false elements bodyΠ p false For bodyΠ p β1 βk reﬂected following nogood δp Tp Fβ1 Fβk Taking atom e bodyΠ2 e b e δe Te Fb Fe Combining types nogoods stemming Clark completion program Π obtain following sets nogoods cid4 cid5bodyΠ δβ cid4 cid5atomΠ δp cid5Π cid5bodyΠ cid5atomΠ cid5 cid6 cid5 β bodyΠ cid5 cid6 cid5 p atomΠ cid4 δ cid5β cid4 δ cid5p cid5 cid6 cid5 β bodyΠ cid5 cid6 cid5 p atomΠ 5 6 6 For sake simplicity leave underlying program Π implicit notations cid5p δp 56 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 Table 3 Supported models Π2 corresponding solutions cid5Π2 Supported model d p pnot cnot e c p panot d c e p panot d pe Assignment Ta Td Fc Fe Fb T Tnot c e Fa d Fe Fnot Fb Ta Fd Tc Fe Fb T Fnot c e Ta d Fe Fnot Fb Ta Fd Tc Te Fb T Fnot c e Ta d Te Fnot Fb For illustration Tables 1 2 provide set cid5Π2 nogoods stemming Clark completion Pro gram Π2 While Table 1 shows bodyoriented nogoods cid5bodyΠ2 Table 2 comprises atomoriented ones cid5atomΠ2 In follows develop result section solutions cid5Π coincide supported models Π tight answer sets Π As auxiliary property truth values bodies uniquely determined atoms Lemma 31 Let Π logic program X atomΠ Then A Tp p X cid6 cid4 Fp cid5 cid5 β bodyΠ β cid5 cid7 cid5 β bodyΠ β cid5 cid5 p atomΠ X X β cid7 X cid8cid8 atomΠ X cid6 cid4 cid4 Tβ Fβ cid7 X β cid8 cid6 cid7 unique solution cid5bodyΠ AT atomΠ X Observe given X atomΠ unique solution A cid5bodyΠ assign T F β bodyΠ according semantics conjunction expected The auxiliary result establishes onetoone correspondence supported models Π satisfying equiva lences 3 4 solutions cid5Π Lemma 32 Let Π logic program X atomΠ bodyΠ Then X atomΠ pβ β X bodyΠ supported model Π iff Tv v X Fv v atomΠ bodyΠ X solution cid5Π Since supported models answer sets coincide tight programs Π obtain following correspondence answer sets Π solutions cid5Π Theorem 33 Let Π tight logic program X atomΠ Then X answer set Π iff A Tp p X cid6 cid4 Fp cid5 cid5 β bodyΠ β cid5 cid7 cid5 β bodyΠ β cid5 cid5 p atomΠ X X β cid7 X cid8cid8 atomΠ X cid6 cid4 cid4 Tβ Fβ cid7 X β cid8 cid6 cid7 unique solution cid5Π AT atomΠ X Example 31 For illustration let inspect supported models answer sets Π2 Example 21 non tight rule e e The equivalences Clark completion Π2 p p cid15 b pnot pnot c panot d panot d d d pnot cnot e pnot cnot e c e e pb pe pb b pe e The supported models Π2 corresponding solutions cid5Π2 shown Table 3 Note atoms belonging ﬁrst supported models correspond answer sets Π2 The reason mismatch rule e e makes Π2 nontight When dropping rule Π2 ﬁrst supported models remain valid e longer supported By Lemma 32 allows conclude ﬁrst assignments Fe solutions cid5Π2ee Since Π2 e e tight use Theorem 33 d c answer sets Π2 e e As pointed beginning section nogoods contributing cid5bodyΠ 5 cid5atomΠ 6 directly linked clauses obtained decomposing equivalences Clark completion program Π M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 57 straightforward way Hence nogoods cid5Π essentially characterize supported models terms assignments atoms rule bodies Note atom body deﬁned equivalence given implicitly semantics Π written explicitly Clark completion Π In sense view Π shorthand representation conditions rules fulﬁlled true atom supported rule body holds 32 Loop nogoods Every answer set program Π supported model Π converse hold general In fact mismatch nontight programs potential circular support positive recursion true atoms admissible supported models answer sets Hence improper support suppressed distinguish supported models answer sets rest approaches accomplish On hand wellfounded semantics based unfounded sets 124 viz sets atoms noncircularly supported false While unfounded sets traditionally determined wrt partial interpretations atoms alternative approach identifying unfounded sets wrt false rule bodies described 2 On hand loop formulas utilized characterize answer sets classical models propositional theories Here main focus restricting consideration unfounded sets particular syntactic classes sets atoms loops 90 82 elementary sets 6158 In section introduce concept unfounded set setting relate traditional approaches 12484 We exploit unfounded sets extend constraintbased characterization answer sets nontight programs yields close relationship loop formulas To begin program Π U atomΠ deﬁne external bodies U Π EBΠ U cid4 bodyr cid5 cid5 r Π headr U bodyr U cid6 A body EBΠ U provide noncircular support U positively contain atom U Then U unfounded external bodies false noncircular support left U In setting amounts following deﬁnition Deﬁnition 31 Let Π logic program A assignment U atomΠ Then deﬁne U unfounded set Π wrt A EBΠ U AF In deﬁnition determines U unfounded Π wrt A r Π headr U U cid7 bodyr AF For comparison traditional unfounded set deﬁnition Van Gelder Ross bodyr Schlipf 124 reformulated wrt assignments follows Deﬁnition 32 Let Π logic program A assignment U atomΠ Then deﬁne U GRSunfounded set Π wrt A cid5 cid5 cid4 β bodyΠ AT AF EBΠ U cid7 β cid7 β cid7 cid8 cid8 cid6 Note deﬁnition requires external body contain false literal order witness unavailability noncircular support For comparing concept unfounded set traditional deﬁne following properties program assignment Deﬁnition 33 Let Π logic program A assignment Then deﬁne A 1 bodysaturated Π cid7 cid4 β bodyΠ AF β 2 bodysynchronized Π cid4 β bodyΠ AF β cid5 cid5 cid7 cid5 cid5 cid8 cid8 cid7 cid7 AT β AT β cid8 cid8 cid6 cid6 cid7 cid7 AF AF bodyΠ In words bodysaturation requires bodies containing false literals likewise assigned false converse holds bodysynchronization Based properties formalize relationships GRSunfounded sets unfounded set notion Proposition 34 Let Π logic program A assignment U atomΠ If A bodysaturated Π U unfounded set Π wrt A U GRSunfounded set Π wrt A 58 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 Fig 1 The positive dependency graph Π7 Proposition 35 Let Π logic program A assignment U atomΠ If A bodysynchronized Π U unfounded set Π wrt A iff U GRSunfounded set Π wrt A These results GRSunfounded set turned unfounded set assigning bodies containing false literals false way establishing bodysaturation For body β nogoods cid5β enable forwarding falsity unit propagation cf Section 2 As following example illustrates straightforward converse transformation turn unfounded sets GRSunfounded sets Example 32 Consider following nontight program cid2 Π7 b c b c b d d e d b c e b e c d cid3 7 The positive dependency graph Π7 shown Fig 1 Observe c d d e c d e nonempty sets atoms elements reach loopinternal paths nonzero length loopΠ7 c d d e c d e In particular U d e unfounded Π7 wrt A Fb c Fb view EBΠ7 U b c b This tells answer set Π7 rules d b c e b inapplicable bodies b c b hold contain d e In fact remaining rules supporting d e d e e c d circular provide external support U However U GRSunfounded set Π7 wrt A nogood δb c Fb c Tb Tc δb Fb Tb Fa allows deriving falsity body literal unit propagation wrt A That fact remaining supports d e circular reﬂected GRSunfounded sets On hand U GRSunfounded set Π7 wrt B Fb positive body literal b b c b false wrt B The mismatch U unfounded set Π7 cid16 containing Fb c Fb wrt B B bodysaturated Π7 Yet bodysaturated assignment B easily derived B unit propagation view nogoods Tb c Fb Tb Fb belonging cid5b c cid16 cid5b respectively Then U unfounded set Π7 wrt B In order identify constraints induced unfounded sets inspect loop formulas Reusing auxiliary propositions rule bodies given 3 program Π U atomΠ disjunctive loop formula written follows cid9 cid10 cid11 cid9 cid10 p cid11 pβ pU βEBΠ U Such loop formula stipulates body EBΠ U hold atom U true An alternative reading elements U false U unfounded For Program Π7 U d e loop formula d e pbc pbnot corresponding clauses d pbc pbnot e pbc pbnot To capture unit propagation loop formulas program Π nonempty U atomΠ p U deﬁne loop nogood λp U Tp Fβ1 Fβk EBΠ U β1 βk For Program Π7 U d e obtain λd U Td Fb c Fb λe U Te Fb c Fb Notice literals form Fβ β EBΠ U λp U p U Overall following set loop nogoods program Π cid5 cid5 p U λp U cid12 ΛΠ cid6 cid4 U atomΠ The result describes relationship loop nogoods unfounded sets Proposition 36 Let Π logic program A assignment AT AF atomΠ bodyΠ Then A solution ΛΠ iff U AF unfounded set U Π wrt A In combination Proposition 35 previous result tells bodysynchronized total assignment A unfoundedfree 84 iff A solution ΛΠ Along Lemma 31 establishes solution cid5Π body synchronized allows extend Theorem 33 nontight programs M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 59 Theorem 37 Let Π logic program X atomΠ Then X answer set Π iff A Tp p X cid6 cid4 Fp cid5 cid5 β bodyΠ β cid5 cid7 cid5 β bodyΠ β cid5 cid5 p atomΠ X X X β cid7 cid8cid8 atomΠ X cid6 cid4 cid4 Tβ Fβ cid7 X β cid8 cid6 cid7 unique solution cid5Π ΛΠ AT atomΠ X We established nogoods cid5Π ΛΠ set constraints need checked iden tifying answer sets However size cid5Π linear size Π ΛΠ general exponential As shown Lifschitz Razborov 88 defect construction ΛΠ implication widely accepted assumptions complexity theory Hence answer set solvers work logic programs succinct represen tations loop nogoods formulas respectively check eﬃciently determining unfounded sets relative assignments To end program structure viz loops elementary sets conﬁne unfounded set checking necessary parts In remainder section theoretical foundations completeness looporiented unfounded set detection algorithm presented Section 43 To begin note assumption body saturation eliminate false atoms unfounded set order obtain unfounded set nonfalse atoms Proposition 38 Let Π logic program A assignment U unfounded set Π wrt A If A bodysaturated Π U AF unfounded set Π wrt A For instance U b d e unfounded set Π7 wrt bodysaturated assignment A Fnot Fb Fb d Fb c Fb Proposition 38 tells U AF d e remains unfounded Π7 wrt A That limit attention unfounded sets containing exclusively nonfalse atoms In follows exploit loops conﬁne consideration unfounded sets essentially reproducing results similar 902 setting To accomplish introduce atomsaturation property dual bodysaturation Deﬁnition 34 Let Π logic program A assignment Then deﬁne A atomsaturated Π cid4 p atomΠ cid5 cid5 bodyΠ p AF cid6 AF This deﬁnition requires atoms p support assigned false stipulated nogood δp Tp Fβ1 Fβk bodyΠ p β1 βk Given atomsaturated assignment nonempty unfounded set nonfalse atoms contains unfounded loop Proposition 39 Let Π logic program A assignment U atomΠ AF nonempty unfounded set Π wrt A If A atomsaturated Π unfounded set L U Π wrt A L loopΠ For illustration note U d e unfounded loop Π7 wrt atom bodysaturated assignment A Fnot Fb Fb d Fb c Fb Moreover nonempty unfounded set Π7 wrt B Fnot b atomsaturated BF The fact false given B expressed δa Ta Fnot b λa δa provide additional information nonloop Given program yield exponentially loops unfounded separately wrt different assignments impractical identify arbitrary loops priori However nontrivial strongly connected components positive dependency graph limit atoms jointly belong unfounded loops scope unfounded set checking procedures 1191723147 restricted In setting fact consideration unfounded sets conﬁned nontrivial strongly connected components immediate consequence Proposition 39 Corollary 310 Let Π logic program A assignment U atomΠ AF nonempty unfounded set Π wrt A If A atomsaturated Π nonempty unfounded set U nontrivial strongly connected component atomΠ cid2 cid16 U Π wrt A p U cid16 belong Finally combine Propositions 38 39 establish formal basis completeness unfounded set detection algorithm Section 43 60 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 Theorem 311 Let Π logic program A assignment If A atom bodysaturated Π unfounded set U Π wrt A U cid2 AF unfounded set L U AF Π wrt A L loopΠ Since ﬁxpoints unit propagation cid5Π atom bodysaturated Π Theorem 311 tells founded set checking focus loops nonfalse atoms For Program Π7 loopΠ7 c d d e c d e cf Fig 1 principle restrict unfounded set checking loops order test nogoods ΛΠ7 As mentioned impractical consider arbitrary loops long unfounded strongly connected components easily determined statically 121 The role components means limit scope unfounded set checks summarized following immediate consequence Theorem 311 Corollary 312 Let Π logic program A assignment If A atom bodysaturated Π unfounded set U Π wrt A U cid2 AF belong nontrivial strongly connected component cid16 U AF Π wrt A p U cid16 nonempty unfounded set U atomΠ cid2 With characterization answer sets terms nogoods relevant background knowledge unfounded sets hand section provides conﬂictdriven approach computation solutions representing answer sets 4 Conﬂictdriven ASP solving Given speciﬁcation answer sets terms nogoods use advanced search techniques SAT developing equally advanced ASP solving procedures But SAT deals plain nogoods represented clauses algorithms work logic programs inducing kinds nogoods In particular exponentially nogoods stemming unfounded sets succinctly given program algorithms devised determine dividual ones unfounded set falsiﬁcation The main purpose associating nogoods logic program provide reasons literals derived unit propagation This puts ASP solving logical fundament SAT solving similar reasoning strategies applied relying translation SAT proprietary techniques apart unfounded set checking In follows ﬁrst present main conﬂictdriven ASP solving procedure We subroutines prop agation unfounded set checking main particularity ASP compared SAT Furthermore resolutionbased conﬂict analysis setting Finally outline derivation soundness completeness results 41 Conﬂictdriven nogood learning Our main procedure deciding program answer set similar CDCL FirstUIP scheme 97 1272396 In fact clauses viewed particular syntactic representations nogoods representations gates inequalities rules Hence abstract syntax present conﬂictdriven algorithm ASP solving terms nogoods ConﬂictDriven Nogood Learning ASP CDNLASP Given program Π CDNLASP shown Algorithm 1 starts assignment A set recorded nogoods The include nogoods derived conﬂicts encountered search Π nontight loop nogoods explaining inferences unfounded sets Moreover decision level dl initialized 0 count decision literals literals A heuristically selected cf Lines 1417 literals derived propagation Line 5 implied For literal σ A access dlσ decision level σ value dl σ added A values relevant conﬂict analysis Line 8 backjumping Line 10 Algorithm 1 follows standard proceeding CDCL First NogoodPropagation detailed Section 42 determin istically extends A possibly records loop nogoods ΛΠ Afterwards following cases applies Conﬂict If propagation led conﬂict checked Line 6 possibilities If current decision level 0 means conﬂict occurred independently heuristic decision input program Π answer set Otherwise ConflictAnalysis detailed Section 44 performed Line 8 determine conﬂict nogood δ recorded Line 9 decision level jump Note assume δ asserting literal unitresulting δ wrt A backjumping Line 10 This condition guaranteed ConflictAnalysis makes sure backjumping CDNLASP traverses search space differently explicitly ﬂipping decision literal Solution If A conﬂicting ε cid2 A ε cid5Π total AT AF atomΠ bodyΠ checked Line 11 atoms true A form answer set Π Decision Finally A conﬂicting total decision literal σd selected according heuristic Section 5 details added A We assume σd Tv σd Fv v atomΠ M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 61 Algorithm 1 CDNLASP A logic program Π An answer set Π answer set Input Output 1 A 2 3 dl 0 4 loop 5 A NogoodPropagationdl Π A ε A ε cid5Π dl 0 return answer set δ dl ConflictAnalysisε Π A δ A A σ A dl dlσ AT AF atomΠ bodyΠ return AT atomΠ σd SelectΠ A dl dl 1 dlσd dl A A σd 6 7 8 9 10 11 12 13 14 15 16 17 assignment atomΠ bodyΠ set dynamic nogoods decision level conﬂict learning backjumping answer set decision bodyΠ AT AF v belong domA unassigned Then σd assigned new decision level dl 1 Example 41 Although detailed subroutines Algorithm 1 let consider fullﬂedged com putation answer set b c d e Program Π7 To end Table 4 shows current assignment A different stages CDNLASPΠ7 columns provide value dl viz current decision level line Algorithm 1 particular contents A andor nogood δ inspected Note literals added A Line 17 Algorithm 1 decision literals implied nogood Unlike literal added A Line 5 execution NogoodPropagation antecedent δ cid5Π7 Furthermore indicate successes test violated nogood performed Line 6 nogood δ recorded decision level dl jump returned ConflictAnalysis invoked Line 8 In computation CDNLASPΠ7 start successively picking decision literals Td Fb Tc Fnot levels 1 2 3 4 respectively Observe exactly decision literal level decision immediately followed propagation step performed making decision At start propagation derive literals decision levels 1 2 assignment A stays partial After decision literals assigned Tc unitresulting respective nogoods δ cid5Π7 wrt A Hence added A decision level 3 Since A partial decision literal Fnot picked level 4 The following propagation step yields total assignment true atoms viz c d e belong supported model Π7 However d e unfounded Π7 wrt A corresponding loop nogoods λd d e λe d e violated Such violations detected NogoodPropagation unfounded atom lead recording associated loop nogood In Table 4 assume λd d e Td Fb c Fb recorded conﬂict encountered Line 6 Algorithm 1 Note Fb c single literal λd d e assigned decision level 4 Hence λd d e instantly asserting returned ConflictAnalysis Line 8 smallest decision level backjumping Tb c unitresulting λd d e 2 The peculiarity ConflictAnalysis launched asserting loop nogood results unidirectional propagation loop nogoods current ASP solvers cf 6362 We comment phenomenon Section 44 Given dl 2 level jump computation proceeds retracting literals added A levels 3 4 retaining decision literals Td Fb assigned levels 1 2 In contrast pre vious visit decision level 2 asserting nogood λd d e enables derivation literals unit propagation results conﬂict time completion nogood Tnot Ta Starting ConflictAnalysis determines asserting nogood Fb Td As consequence CDNLASPΠ7 turns decision level 1 Tb unitresulting Fb Td A ﬁnal propagation step leads Notably nogoods ΛΠ7 left implicit tested total assignment violating nogood cid5Π7 NogoodPropagation unfounded set checking subroutine The true atoms obtained solution underlined Table 4 associated answer set Program Π7 b c d e returned result CDNL ASPΠ7 After general outline subroutines CDNLASP computations 62 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 Table 4 A computation answer set b c d e CDNLASPΠ7 dl 1 2 3 4 2 1 A Td Fb Tc Tc d Te Te Fnot Ta Ta Tnot b Fb Fb c Fb d Fb Tb c Tb Ta Tnot Td Tb Tb Fa Tnot Fnot b Fa Te Te Tb d Tc Tb c Tc d δ Fc d Tc Td Fe Tc d Fe Te Fnot Fa Fa Ta Ta Fnot b Tb Fnot Tb c Fb Tb d Fb Td Fb c Fb Td Fb c Fb Td Fb c Fb Tb c Fb Fb Tb Fa Tb Fnot Tnot Ta Fb Td Fb Td Tb Fb Tb Ta Tb Fnot Tnot b Tb Ta Fa Fe Tb Fe Te Fb d Tb Td Fc Tb d Fb c Tb Tc Fc d Tc Td δc d cid5e δe δnot δa δa δb cid5b c cid5b d λd d e dl 2 cid5b c δb δb cid5not dl 1 cid5b cid5b δb cid5not b cid5a cid5e δe δb d cid5c δb c δc d Line 17 17 17 5 5 5 17 5 5 5 5 5 5 6 8 5 5 5 5 6 8 5 5 5 5 5 5 5 5 5 5 5 5 42 Nogood propagation Our subroutine deterministically extending assignment A shown Algorithm 2 It combines unit propagation completion nogoods cid5Π recorded nogoods Lines 39 unfounded set checking Lines 1014 While unit propagation run ﬁxpoint conﬂict sophisticated unfounded set checks performed input program Π nontight In fact ﬁnishing loop Lines 39 assignment A hand atom bodysaturated Π results Section 32 serve basis demanddriven unfounded set checking In particular Π tight Theorem 311 tells unfounded sets U falsiﬁed U AF holds unit propagation cid5Π suﬃcient falsify unfounded atoms Example 42 The central idea integrating unfounded set checking unit propagation loop nogoods ΛΠ explicit order trigger falsiﬁcation unfounded atoms unit propagation To consider program Π containing following rules x y z y x z y Let A atomsaturated assignment U x y z unfounded Π wrt A U AT AF Then EBΠ U AF Fx F y Fz unitresulting λx U λ y U λz U respectively While literals unitresulting completion nogood cid5Π Fx F y F y z derived unit propagation given cid5Π λx U That adding λx U unfounded set U falsiﬁed unit propagation However addition single loop nogood suﬃcient falsify unfounded set depends structure Π For instance augment Π y z derivation F y Fz unit propagation longer certain circular supports y z z y eliminated assigning x false We derive Fx rule y x inapplicable EBΠ y z A Fx FxF This shows U AF x y z x y z remains smaller unfounded set M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 63 Algorithm 2 NogoodPropagation A decision level dl logic program Π set nogoods assignment A An extended assignment set nogoods Input Output 1 U repeat 2 loop 3 4 5 6 7 8 δ A δ cid5Π return A Σ δ cid5Π δ A σ σ A Σ cid7 let σ δ A δ Σ dlσ dl A A σ 9 10 11 12 13 14 Σ loopΠ return A U U AF U U UnfoundedSetΠ A U return A let p U λp U unfounded set conﬂict unitresulting nogoods unfounded set U atomΠ AF unfounded set U atomΠ AF record loop nogood The observations Example 42 motivate strategy Algorithm 2 successively falsify elements unfounded set U At start nonempty unfounded set determined U initialized Line 1 Provided unit propagation Lines 39 ﬁnishes conﬂict Π nontight remove false atoms U Line 11 In ﬁrst iteration outer loop Lines 214 U stays subrou tine unfounded set detection detailed Section 43 queried Line 12 The crucial assumption UnfoundedSetΠ A returns unfounded set U atomΠ AF U nonempty nonempty subset atomΠ AF unfounded Then EBΠ U AF λp U A Tp p U Hence nonempty U returned addition λp U arbitrary p U Line 14 yields conﬂict unitresulting literal Fp iteration loop Lines 214 In case literals derived elements U falsiﬁed computing ﬁxpoint unit propagation When reconsider previously determined unfounded set U removal false atoms Line 11 guaranteed result smaller unfounded set U AF Hence U AF nonempty checked Line 12 computing unfounded set NogoodProp agation proceeds adding loop nogood yields conﬂict unitresulting literal Thus nonempty unfounded set U detected falsiﬁed element element expending elements U new unfounded set computed Overall NogoodPropagation terminates soon conﬂict encountered Line 4 ﬁxpoint unit propagation cid5Π nonempty subset atomΠ AF unfounded If Π tight immediately veriﬁed Line 10 Otherwise UnfoundedSet subroutine queried Line 12 detect nonempty unfounded set nonfalse atoms ﬁnishing Line 13 Example 43 To illustrate NogoodPropagation utilizes nogoods reconsider computation CDNLASPΠ7 shown Table 4 All implied literals ones assigned decision literal level dl unitresulting successively derived unit propagation In particular decision level 4 implied literals σ nogoods cid5Π7 antecedents δ cid5Π7 literals δ σ contained A σ assigned The impact loop nogoods ΛΠ7 observed conﬂict encountered decision level 4 Here U d e AT unfounded A violates λd U λe U After detecting unfounded set U recording λd U violation gives rise leaving NogoodPropagation Line 4 Algorithm 2 In summary subroutine propagation interleaves unit propagation recording loop nogoods The input program nontight falsity unfounded atoms derived unit propa gation available nogoods Clearly approach favors unit propagation unfounded set computations motivated follows For unit propagation contribute new dynamic nogoods economic unfounded set checking For unfounded set detection algorithms like described linear time complexity analyze logic program global fashion unit propagation While investigates rules nogoods directly related literals assigned unfounded set computations inspect signiﬁcant parts program positive dependency graph eventually detecting nonempty unfounded set But given unfounded set checking wrt total assignments mandatory soundness wrt par tial assignments helps detect inherent conﬂicts early respective subroutine nonetheless integral NogoodPropagation 64 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 43 Unfounded set checking Our unfounded set checking procedure invoked nontight program Π unit propagation reaches ﬁxpoint conﬂict computed unfalsiﬁed unfounded atoms cf Algorithm 2 As matter fact ﬁxpoint unit propagation atom bodysaturated Π Hence Corollary 312 applies allows focus unfounded sets nonfalse atoms contained nontrivial strongly connected components positive dependency graph Π To end p atomΠ let sccp denote set atoms belonging strongly connected component p atomΠ cid2 We p cyclic cid2 sccp sccp cid7 sccp cid7 acyclic As consequence Proposition 39 rule r Π headr sccp bodyr immediately unfounded set checking concentrate exclusively cyclic atoms belong unfounded loops7 Beyond static information strongly connected components unfounded set detection algorithm makes use source pointers 119 indicate noncircular supports atoms Given program Π idea associate cyclic p atomΠ element bodyΠ p specialpurpose symbols cid15 denoted sourcep point ing chain rules witnessing p unfounded Hence long sourcep remains intact p excluded unfounded set checks In way source pointers enable lazy incremental unfounded set checking relative recent changes assignment To sure unfounded set missed following invariants need guaranteed 1 For cyclic p atomΠ require sourcep bodyΠ p 2 The subgraph atomΠ cid2 containing cyclic p atomΠ edges q p q sourcep sccp acyclic8 For program Π collection links sourcep p atomΠ source pointer conﬁguration We source pointer conﬁguration valid satisﬁes aforementioned invariants For appropriate initialization deﬁne initial source pointer conﬁguration Π cid2 sourcep p atomΠ cyclic cid15 p atomΠ acyclic While cid15 expresses acyclic atom p need linked element bodyΠ p indicates non circular support cyclic atom p needs determined We assume initial source pointer conﬁguration Π valid deﬁnition place invocation CDNLASPΠ Given program Π assignment A UnfoundedSet shown Algorithm 3 starts collecting nonfalse cyclic atoms p source pointers false sourcep AF undetermined sourcep Line 1 possibility noncircularly supporting atoms question In Lines 25 set successively extended adding atoms source pointers positively rely providing scope S second unfounded set checking In fact loop Lines 617 aims reestablishing source pointers atoms S rules bodies positively rely S rules provide noncircular support Conversely source pointers reestablished unfounded set detected In long scope S nonempty arbitrary atom p S picked Line 6 Algorithm 3 start ing point construction nonempty unfounded set U If EBΠ U AF holds Line 9 unfounded set U immediately returned NogoodPropagation successively falsify atoms unit propagation cf Algo rithm 2 Otherwise external body β EBΠ U AF selected Line 10 investigation If β contains atoms scope S belong strongly connected component atomΠ cid2 starting point p checked Line 11 add U Line 16 makes β nonexternal wrt extended set U On hand atoms exist β means β noncircularly support associated head atoms q U Then Lines 1215 source pointers atoms q set β atoms q removed unfounded set U construction scope S The described process continues U checked Line 17 case remaining atoms S investigated nonempty unfounded set U detected returned Line 9 Finally scope S runs source pointers reestablished atoms contained S UnfoundedSet returns unfounded set Line 18 In order provide intuitions let stress major design principles unfounded set detection algo rithm 7 Strongly connected components positive dependency graphs exploited unfounded set checking procedures 119172 native ASP solvers clasp We discuss relationships Section 7 8 Recall sourcep p1 pm rule body sourcep p1 pm pm1 pn For specialpurpose symbols cid15 let cid15 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 65 Algorithm 3 UnfoundedSet Input Output A logic program Π assignment A An unfounded set Π wrt A T p atomΠ AF S sourcep sccp S cid7 S S T 1 S p atomΠ AF sourcep AF 2 repeat 3 4 5 T 6 S cid7 let p S 7 8 9 U p repeat EBΠ U AF return U let β EBΠ U AF β sccp S foreach q U β bodyΠ q sourceq β U U q S S q U U β sccp S U 10 11 12 13 14 15 16 17 initialize scope S extend scope S select starting point unfounded set U atomΠ AF shrink U extend U 18 return unfounded set U atomΠ AF 1 At stage loop Lines 617 atoms U belong sccp p atom added ﬁrst U Line 7 This atoms added U Line 16 elements sccp However U sccp necessarily imply p U nonempty unfounded set U returned Line 9 2 At stage loop Lines 617 U S atoms added U Line 7 16 belong S Hence holds q S sourceq set external body β bodyΠ q Line 13 β sccp S checked Line 11 This makes sure setting sourceq β introduce cycle source pointers 3 Once detected nonempty unfounded set U immediately returned Line 9 NogoodPropagation takes care falsifying atoms U checking unfounded set cf Algorithm 2 This reduces laps unit propagation completion nogoods cid5Π handles unsupported atoms singleton unfounded sets bodies relying 4 The source pointer atom q unfounded set U returned Line 9 needs reset In fact sourceq set Line 13 reestablishing potential noncircular support q Rather admit sourceq AF long q AF derived NogoodPropagation falsifying U Thus Fq unassigned later backjumping sourceq allows lazy unfounded set checking Example 44 Let illustrate Algorithm 3 invocations UnfoundedSetΠ7 A computation answer set b c d e Program Π7 described Example 41 To end Table 5 indicate stages Unfound edSetΠ7 A queried wrt ﬁxpoints A unit propagation decision levels 0 2 4 respectively Beforehand note sccc sccd scce c d e b acyclic Hence ﬁrst invocation Unfounded SetΠ7 A decision level 0 sourcea sourceb cid15 sourcec sourced sourcee In view Line 1 Algorithm 3 obtain scope S c d e Then assume e picked Line 6 added U Line 7 c d EBΠ7 e selected Line 10 Since c d scce S c d makes augment U c d Line 16 resulting intermediate stage U c d e Further assume b EBΠ7 c d e selected Line 10 b scce S holds Line 11 Hence sourcee set b Line 13 e removed U S Lines 14 15 respectively In manner sourced sourcec following iterations loop Lines 817 set e b d respectively Afterwards U S unfounded set returned Line 18 Given nonempty unfounded set literal derived unit propagation decision level 0 indicated omitting level Table 4 The invocation UnfoundedSetΠ7 Td decision level 1 shown Table 5 yields scope S Unlike UnfoundedSetΠ7 Td Fb decision level 2 sourcee b AF S S e obtained Line 1 Algorithm 3 In Lines 25 successively add d c S sourced e e cid7 sourcec S d b d d e cid7 Afterwards assume d added ﬁrst U Line 7 selecting b c EBΠ7 d Line 10 leads U d b c sccd S c d When investigating EBΠ7 c d b c EBΠ7 d iterations loop Lines 817 set sourcec sourced b c obtaining U S e Since S cid7 iteration loop Lines 617 adds e U removes U S setting sourcee c d Given U S unfounded set result 66 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 Table 5 Runs UnfoundedSetΠ7 A computation answer set b c d e dl 0 2 4 sourcep sourcee sourced sourcec Fb e b d sourcec sourced sourcee Fb c c d S c d e c d e c d e c d c e d e c d e c d e c d e d e e e d d e d e d e U e c d e c d c d c d d e e d e β EBΠ7 U AF Line c d b e b d b c b c c d c d 1 7 16 13 13 13 1 4 4 7 16 13 13 7 13 1 4 7 16 At decision level 3 unfounded set checking effect shown Table 4 rule body particular source pointer falsiﬁed However decision level 4 sourced b c AF S d Line 1 Algorithm 3 In iteration loop Lines 25 add e S sourcee S c d d cid7 c stays unaffected view sourcec AF After adding e U Line 7 U extended d e Line 16 given c d EBΠ7 e c d scce S d We obtained U d e holds EBΠ7 d e b c b AF That termination condition Line 9 applies UnfoundedSetΠ7 A returns nonempty unfounded set d e To conclude example Table 4 observe adding loop nogood λd d e Td Fb c Fb leads conﬂict decision level 4 After backjumping decision level 2 NogoodPropagation encounters conﬂict invoking UnfoundedSetΠ7 A Hence UnfoundedSetΠ7 A queried wrt total assignment A rived unit propagation returning decision level 1 In view sourcec AF ﬁnal invocation shown Table 5 makes reset source pointers follows sourcee b sourced e sourcec b d like decision level 0 As yields unfounded set nonfalse atoms NogoodPropagation terminates conﬂict CDNLASPΠ7 returns answer set b c d e Π7 Note nonempty unfounded set U returned Line 9 Algorithm 3 general guaranteed loop sense 90 However Theorem 311 tells U contains loop L unfounded One loops L posteriori extracted U purpose approaches 907191259 principle applied 44 Conﬂict analysis Finally turn subroutine conﬂict analysis purpose determine asserting nogood literal unitresulting backjumping To end resolves violated nogood δ A antecedent ε implied literal σ δ nogood ε ε Aσ σ obtaining new violated nogood δ σ ε σ Iterated resolution proceeds inverse order assigned literals resolving ﬁrst literal σ δ assigned A viz δ Aσ σ stops soon δ contains exactly literal called Unique Implication Point UIP 97 assigned decision level conﬂict encountered The effectiveness approach referred FirstUIP scheme cf 1273596 area SAT demonstrated empirically 12711529 analytically 109 Despite small peculiarities discussed Example 45 FirstUIP scheme applied unaltered conﬂictdriven ASP solving However identifying antecedents implied literals straightforward clauses For instance note subroutine propagation Algorithm 2 records priori implicit loop nogoods ΛΠ sure implied literal antecedent cid5Π Conﬂict resolution according FirstUIP scheme performed ConflictAnalysis shown Algorithm 4 In fact loop Lines 17 proceeds resolving literal σ violated nogood δ assigned A given δ Aσ σ required Line 2 assertion level 23 greatest level dlρ associated literals ρ δ σ different actually smaller dlσ If nogood δ assertion level k determined Line 3 returned Line 7 δ A σ unitresulting δ backjumping decision level k Otherwise k dlσ σ implied literal antecedent ε cid5Π σ chosen Line 5 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 67 Algorithm 4 ConﬂictAnalysis Input Output A violated nogood δ logic program Π set nogoods assignment A A derived nogood decision level 1 loop 2 3 4 5 6 let σ δ δ Aσ σ k maxdlρ ρ δ σ 0 k dlσ let ε cid5Π ε Aσ σ δ δ σ ε σ resolution 7 return δ k Table 6 Run ConﬂictAnalysisTnot Ta Π7 A decision level 2 δ Tnot Ta Ta Tb Tb Fb Tb c Fb Fb Td ε Tb Fnot Fb Tb Fa Tb c Fb Td Fb c Fb resolution δ Line 6 Note antecedents σ cid5Π choice ε Line 5 general nondeterministic cf 32 Regarding termination Algorithm 4 note decision literal σd cf Algorithm 1 ﬁrst literal A positive level dlσd σd literal dlσd implied Given ConflictAnalysis applied nogoods violated decision levels 0 conﬂict resolution steps welldeﬁned stop latest decision literal σd However resolving σd regarded worst case FirstUIP scheme aims resolution steps obtain nogood close conﬂict hand Example 45 To illustrate Algorithm 4 let inspect resolution steps shown Table 6 They applied resolving violated nogood Tnot Ta antecedents shown Table 4 analyzing conﬂict encountered decision level 2 computation CDNLASPΠ7 described Example 41 The literal σ violated nogood δ assigned A complement σ antecedent ε σ surrounded box Table 6 literals assigned decision level 2 underlined The result iterated resolution Fb Td contains Fb single literal assigned decision level 2 Td assigned assertion level 1 In example ﬁrst UIP Fb happens decision literal level 2 In general ﬁrst UIP necessarily decision literal instance observed UIP Fb c serting nogood Td Fb c Fb returned ConflictAnalysis decision level 4 Example 41 Also recall λd d e Td Fb c Fb served starting point ConflictAnalysis containing ﬁrst UIP requiring resolution step This phenomenon unidirectional propagation loop nogoods given unfounded set checks cf Algorithm 3 merely identify unfounded atoms rule bodies necessarily hold noncircularly supporting true atom In Example 41 fact Tb c required decision level 2 recognized level 4 assigning Fb c leads conﬂict In view Algorithm 3 understood checking routine guaranteeing soundness CDNLASP inference capabilities match unit propa gation loop nogoods Similar observations 6362 powerful eﬃcient reasoning mechanisms unfounded set handling diﬃcult develop instance approach suggested 1819 computationally complex quadratic beneﬁcial practice Despite fact conﬂict resolution ASP fashion SAT input format logic programs makes predetermined For completion nogoods cid5Π contain rule bodies structural variables sake succinct representation For number relevant inherent loop nogoods ΛΠ exponential 88 Fortunately satisfaction ΛΠ checked linear time Algorithm 3 explicit representation elements required However NogoodPropagation cf Algorithm 2 records loop nogoods ΛΠ antecedents easily accessible ConflictAnalysis Alternatives representation constraints induced logic program apparent considering tradi tional ASP solvers dlv 83 smodels 119 assignments logically identiﬁed interpretations atoms In order augment smodels conﬂictdriven learning smodelscc 126 pursues algorithmic approach extract antecedents atoms relative smodels inference rules In setting restrict heuristic decisions Line 14 Algorithm 1 atoms mimicking atomonly approach truth values rule bodies determined 68 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 literals However ConflictAnalysis remains unaltered asserting nogoods enable unit propagation derive falsity bodies known false body literals associated false head atoms occur atombased approaches To ultimately avoid inferences need unconditionally eliminate literals bod ies conﬂict nogoods resolution antecedents possible heuristic decisions restricted atoms This idea comes close learning technique smodelscc breaking derivations relying bodies contained literals Although body elimination enable learning atombased approaches goes exponentially increased bestcase complexity independent irreparable conﬂictdriven nogood learning 62 45 Soundness completeness CDNLASP algorithm In follows elaborate formal properties provided algorithms Generally speaking soundness wrt decision problem answer set existence obtained fact NogoodPropagation Conflict Analysis exploit possibly tighten available knowledge draw incorrect conclusions In course UnfoundedSet performs suﬃcient work distinguish answer sets inadmissible circularly supported models The completeness CDNLASP follows observation subroutines loop inﬁnitely fact conﬂictdriven assertions relocate variables smaller decision levels guarantees termination cf 128115 To begin consider crucial properties UnfoundedSet Algorithm 3 First positive depen dencies source pointers inherently acyclic Lemma 41 Let Π logic program A assignment bodysaturated Π If UnfoundedSetΠ A invoked valid source pointer conﬁguration source pointer conﬁguration remains valid execution UnfoundedSetΠ A The property holds potential noncircular supports atoms β established source pointer set body β Line 13 Algorithm 3 In particular atoms β contained investigated strongly connected component atomΠ cid2 belong scope S comprising potentially unfounded atoms In fact following result shows interesting unfounded sets unfounded loops S conversely atoms outside S belong unfounded loop Lemma 42 Let Π logic program A assignment atomsaturated Π If UnfoundedSetΠ A invoked valid source pointer conﬁguration unfounded set U atomΠ AF Π wrt A p U belong strongly connected component atomΠ cid2 contained S Line 6 Algorithm 3 entered The previous lemmas Corollary 312 combined essentially establish completeness Algorithm 39 Theorem 43 Let Π logic program A assignment atom bodysaturated Π If UnfoundedSetΠ A invoked valid source pointer conﬁguration UnfoundedSetΠ A returns unfounded set U atomΠ AF Π wrt A U iff unfounded set U Π wrt A U cid16 cid16 cid2 AF After considering unfounded set detection turn NogoodPropagation Algorithm 2 The lemma straightforward helpful assures prerequisites demanddriven unfounded set checking mainly focusing unfounded loops Lemma 44 Let Π logic program cid16 set nogoods dl N A cid16 assignment Then A atom bodysaturated Π Line 10 Algorithm 2 entered execution NogoodPropagationdl Π cid16 A cid16 The following properties essential ConflictAnalysis welldeﬁned soundness com pleteness CDNLASP Lemma 45 Let Π logic program cid16 set nogoods dl N A cid16 assignment If NogoodPropagationdl Π cid16 A cid16 invoked valid source pointer conﬁguration NogoodProp agationdl Π cid16 A cid16 returns pair A 9 Soundness viz property set U returned UnfoundedSet unfounded obvious view test Line 9 Algorithm 3 fact returned Line 18 trivially unfounded M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 69 1 cid16 cid16 ΛΠ 2 A assignment A 3 δ A δ cid5Π λp U A λp U ΛΠ cid16 A σ A A cid16 implied cid5Π wrt A The ﬁrst item expresses loop nogoods possibly added NogoodPropagation viz Line 14 Algorithm 2 provided Π nontight In view Theorem 37 makes sure recorded nogoods eliminate answer set Π The second item states literal assigned NogoodPropagation antecedent later conﬂict resolution Finally item exploits Theorem 43 Lemma 44 establish violations loop nogoods stay undetected Regarding ConflictAnalysis Algorithm 4 lemma states derived nogoods asserting en tailed nogoods given Lemma 46 Let Π logic program set nogoods A assignment σ A ρ Aσ dlσ dlρ σ A ρ Aσ dlρ dlσ σ A ε cid5Π ε Aσ σ δcid16 A m maxdlσ σ δcid16 0 cid7 0 Then ConflictAnalysisδcid16 Π A returns pair δ k 1 δ A 2 σ δ k dlσ 1 3 δ cid2 B solution B cid5Π δcid16 The prerequisites A δcid16 stipulate existence antecedents ﬁrst literal assigned decision level m 0 These conditions guaranteed CDNLASP increments dl Line 15 Algorithm 1 assigning decision literal antecedent Line 17 conﬂicts analyzed encountered decision level 0 After inspecting subroutines CDNLASP important invariants assignments nogoods generated CDNL ASP summarized follows Lemma 47 Let Π logic program Then following holds Line 5 Algorithm 1 entered execution CDNLASPΠ 1 set nogoods δ cid2 B δ solution B cid5Π ΛΠ 2 A assignment σ A ρ Aσ dlσ dlρ σ A dlσ cid2 maxdlρ ρ Aσ 0 σ A ε cid5Π ε Aσ σ 3 dl N δ cid2 σ A dlσ dl δ cid5Π ΛΠ Given implied literals belonging current assignment A require antecedents second invariant hold dynamic nogoods antecedents optionally deleted This yields polynomial space complexity CDNLASP number required antecedents bounded maximum number assigned literals viz atomΠ bodyΠ In practice nogood deletion cf 7235 important technique preventing conﬂictdriven learning solvers blowing space Finally results allow deriving soundness completeness CDNLASP Theorem 48 Let Π logic program Then CDNLASPΠ terminates returns answer set Π iff Π answer set Soundness wrt decision problem answer set existence follows observations violated loop nogoods detected nogoods added NogoodPropagation derived ConflictAnaly sis entailed The completeness CDNLASP viz fact decision procedure termination Notably arguments termination CDCL cf 128115 apply CDNLASP given search procedures use conﬂictdriven assertions exclude repetitions assignments 5 The clasp Our approach conﬂictdriven ASP solving implemented clasp 545256 combining highlevel modeling ca pacities ASP stateoftheart Boolean constraint solving techniques The solver clasp freely available open source package 110 distributed GNU general public license The clasp originally designed optimized conﬂictdriven ASP solving described Section 4 To end features number sophisticated reasoning implementation techniques speciﬁc ASP borrowed CDCLbased SAT solvers Moreover clasp fullﬂedged SAT MaxSAT PB solver accepting propositional CNF formulas extended dimacs format PB formulas opb format The ﬂexibility input formats 70 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 reasoning modes cf Section 52 tuning parameters cf Section 54 supported clasp goes margins typical ASP SAT solvers This section primarily devoted ASP solving describing main features clasp Albeit theoretical considerations Section 4 concentrated normal logic programs feature clasps ability treat extended rules 119 intrinsically priori compilation supporting choice constructs rule heads cardinality weight constraints rule bodies While nogoods stemming normal programs described Section 3 represented clauses clasp includes dedicated data structures dealing linear inequalities obtained extended programs PB formulas In order comprehensive overview functionalities provided clasp discuss features 51 Interfaces preprocessing For ASP solving clasp reads propositional logic programs proper disjunctions rule heads lparse mat 120 provided lparse 120 gringo 51 Choice rules cardinality weight constraints cf 119120 compiled normal rules parsing conﬁgurable option transext dealt intrinsic fashion default Section 53 details At beginning logic program subject extensive preprocessing 55 The idea simplify program identifying equivalences relevant constituents These equivalences building compact program representation terms Boolean constraints Logic program preprocessing conﬁgured option eq taking integer value ﬁxing number iterations Once program transformed Boolean constraints subject preprocessing primarily based resolution 33 Such SatELitelike preprocessing invoked option sat prepro parameters However care taken adapting techniques SAT preprocessing eliminate variables relevant unfounded set checking occur extended rules optimization statements A major internal feature clasp stateful way That clasp state involving program representation recorded nogoods heuristic values invoked additional temporary assumptions andor adding new atoms rules The corresponding interfaces fundamental supporting incremental ASP solving realized iclingo 46 combination gringo clasp incremental grounding solving Furthermore solving assumptions 34 parallel ASP solver claspar 3711850 52 Reasoning modes Although clasps primary use case computation answer sets allows computing supported models logic program option suppmodels10 In addition clasp provides number reasoning modes determining proceed model Enumeration Solution enumeration nontrivial context backjumping conﬂictdriven learning A simple ap proach relies recording solutions nogoods exempting deletion Although clasp supports option solutionrecording prone blow space view exponential number solutions worst case Unlike default enumeration algorithm clasp runs polynomial space 53 Both enumeration approaches allow projecting models subset atoms 57 invoked project conﬁgured wellknown di rectives hide lparse gringo This option great practical value faces overwhelmingly models involving solutionirrelevant variables having proper combinatorics For example program consisting choice rule abc obvious answer sets When augmented directive hide c solutions obtained including duplicates Unlike invoking clasp project yields answer sets differing andor b As regards implementation interesting note clasp offers dedicated interface enumeration This allows abstracting proceed model makes search algorithm independent concrete enumeration strategy Further reasoning modes implemented enumeration interface admit computing intersection union answer sets program cautious brave respectively Rather computing collection possibly exponentially answer sets idea compute ﬁrst answer set record constraint eliminating solutions compute second answer set strengthen constraint represent intersection union ﬁrst answer sets continue like answer set obtained This process involves computing answer sets atoms input program Either cautious brave consequences given atoms captured ﬁnal constraint Optimization As common lparselike languages objective function speciﬁed sequence minimize maximize statements For ﬁnding optimal solutions clasp offers options First objective function ini tialized optvalue Second clasp allows computing optall optimal solutions Such options 10 To precise option suppmodels disables unfounded set checking Sometimes grounder preprocessing eliminate supported models recovered later M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 71 useful interested computing consequences belonging optimal solutions combination cautious To end starts searching arbitrary optimal answer set relaunches clasp bounding search obtained optimum Doing cautious yields atoms belong optimal answer sets On application problems option restartonmodel making clasp restart putatively optimal solution turned effective ameliorating convergence optimum Particular strategies lexi cographic optimization 48 available clasp series 2 serve purpose especially large underconstrained multicriteria optimization problems Moreover option optheu alter sign selection better objective function value Optimization implemented aforementioned enumeration interface When lution optimization constraint updated corresponding objective function value Then decision level violating constraint identiﬁed retracted constraint violated decision level 0 search terminates It worth mentioning clasp propagates optimization constraints imply provide reasons literals unit propagation Finally optimization actually undesired solutions ought inspected instead option optignore available modifying input removing optimization statements obsolete 53 Propagation search Propagation clasp relies interface called Boolean constraint limited clausal representations nogoods cf 35 However dedicated data structures binary ternary nogoods cf 115 accounting short nogoods stemming Clark completion More complex constraints accessed watch lists variable storing Boolean constraints need updated variable true false respectively While unit propagation long nogoods based wellknown twowatchedliteral data structure 101 counter based approach propagating cardinality weight constraints 47 A literal implied Boolean constraint unit propagation stores reference constraint turn queried antecedent During unit propagation binary nogoods handled ternary ones turn inspected Boolean constraints As detailed Algorithm 2 propagation procedure distinct giving clear preference unit propagation unfounded set computations Unfounded set detection follows Algorithm 3 aims small greatest unfounded sets As detailed 47 intrinsic treatment cardinality weight constraints augments unfounded set detection means source pointers aiming lazy unfounded set checking The representation loop nogoods controlled option loops In default setting loop nogoods generated individual unfounded atoms shown Algorithm 2 Like nogoods derived conﬂicts subject unit propagation deletion However loopsno speciﬁed loop nogoods stored long serve antecedents falsiﬁed unfounded atoms Decision heuristics The primary decision heuristics clasp use lookback strategies derived corresponding CDCL based approaches SAT viz vsids 101 berkmin 72 vmtf 115 Such heuristics privilege variables involved recent conﬂicts To end maintain activity score variable increased conﬂict resolution decayed peri odically The major difference approaches vsids berkmin lies scope variables considered decision making While vsids selects free variable globally active berkmin restricts selection variables belonging recently recorded undispelled dynamic nogood Although lookback heuristics implemented clasp modeled corresponding CDCLbased approaches clasp optionally scores variables contained loop nogoods In case berkmin select free variable belonging recently recorded loop nogood Finally note clasps heuristic based lookahead strategies extending unit propagation failedliteral detection 42 This makes sense running clasp conﬂictdriven nogood learning operating similar smodels Once decision variable selected sign heuristic decides truth value The main criterion look heuristics satisfy greatest number conﬂict nogoods pick literal occurs fewer Initially tiebreaking clasp sign selection based type variable atoms preferably set false bodies true This aims maximizing number resulting implications Another sign heuristic implemented clasp progress saving 107 The idea remember truth values retracted variables backjumping restarting assigned decision level These saved values sign selection The intuition strategy literals assigned prior decision level lead conﬂict satisﬁed subproblem Hence reestablishing help avoid solving subproblems multiple times Progress saving invoked option saveprogress computational impact depends heavily structure application hand cf Section 54 Restart policies The robustness clasp boosted multiple restart strategies cf 74 geometric ﬁxedinterval Lubystyle nested policy The ﬁrst start initial number conﬂicts clasp restarts threshold increased restart The policy going Luby Sinclair Zuckerman 92 schedules restarts according recurrent progressively growing sequence numbers conﬂicts 32 32 64 32 32 64 128 32 unit 32 In addition nested policy ﬁrst picosat 11 offered clasp This policy takes parameters x y z makes restarts follow twodimensional pattern increases geometrically repeated reaches outer limit z y j counts dimensions The geometric restart sequence x yi 72 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 number performed restarts j outer limit hit far Usually restart strategies based total number encountered conﬂicts Beyond clasp features local restarts 116 Here counts number conﬂicts decision level order measure diﬃculty subproblems locally Furthermore bounded approach restarting backjumping enumerating answer sets described 53 To complement determined search clasp allows initial randomized runs 35 typically small restart threshold hope extract putatively interesting nogoods Finally worth noting despite fact recent SAT solvers use aggressive restart strategies cf Section 54 clasp defaults conservative geometric policy cf 35 performs better ASPspeciﬁc benchmarks Nogood deletion To limit number nogoods stored simultaneously dynamic nogoods periodically subject deletion Complementing lookback heuristics clasps nogood deletion strategy associates activity recorded nogood incremented nogood conﬂict resolution Borrowing ideas minisat 35 berkmin 72 initial threshold number stored nogoods calculated size input program increased certain factor restart As soon current threshold exceeded deletion initiated removes 75 recorded nogoods Nogoods currently locked serve antecedents activities signiﬁcantly exceed average activity exempt deletion However nogoods deleted activities decayed order account recency usage All clasps nogood deletion strategy aims limiting overall number stored nogoods keeping relevant recently recorded ones This likewise applies conﬂict loop nogoods 54 Finetuning Advanced Boolean constraint solving technology adds multitude degrees freedom ASP solving Currently clasp 40 options half control search strategy Although considerable efforts taken ﬁnd default parameters jointly boosting robustness speed default setting leaves room drastic improvements speciﬁc benchmarks ﬁnetuning parameters The question arises deal vast conﬁguration space conciliate idea declarative problem solving Currently alternative manual ﬁnetuning addressing highly demanding applications As rules thumb usually start investigating following options heuristic Try vsids instead clasps default berkminstyle heuristic transext Applicable program contains extended rules rules including cardinality weight constraints Try dynamic transformation satprepro Resolutionbased preprocessing SatELite 33 works best tight programs cardinality weight constraints It extended rules transformed normal ones transext restarts Try aggressive restart policies like Luby256 nested policy try disabling restarts problem deemed unsatisﬁable saveprogress Progress saving typically works nicely average backjump length choicesconﬂicts ratio high cid310 It usually performs best combination aggressive restarts The impact ﬁnetuning seen following examples As observed 78 clasp times satisﬁable 4 coloring problems However saveprogress clasp solves instance second average backjump length 60 For example consider benchmark class WeightBoundedDomSet second ASP compe tition 28 The default conﬁguration clasp results timeouts section vanish aggressive restarts Similar effects observed application problems featuring different characteristics Although ﬁnetuning greatly improve eﬃciency clasp hard accomplish unpracticed user takes away ideals declarative problem solving To end advocate extension clasp called claspfolio 49 maps benchmark features solver conﬁgurations machine learning techniques It ongoing work investigate far selection effective parameter settings automated 6 Experimental results We conducted experiments NP decision problems second ASP competition 28 encodings Potassco team11 Our comparison considers clasp version 131 default setting setting suited better invokes clasp options satprepro trans benchmarks focus The denoted clasp extdynamic SatELitelike preprocessing 33 nogoods contextdependent handling extended 11 See httpdtaicskuleuvenbeeventsASPcompetitionSubmittedBenchmarksshtml detailed descriptions benchmark classes httpdtai cskuleuvenbeeventsASPcompetitionencodingsshtml benchmark instances encodings M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 73 rules excluding small extended rules intrinsic treatment cf 47 transforming normal rules For comparison consider cmodels version 379 minisat 20 smodels version 234 option restart lp2sat version 113 minisat 20 clasp 13112 For cmodels lp2sat indicate use minisat clasp underlying SAT solver adding m c respectively The experiments run sequentially Linux Intel QuadCore Xeon E5520 machine equipped 227 GHz processors Every benchmark instance lparse output format 120 generated oﬄine gringo run times solver run restricted 600 seconds time 2 GB RAM A run ﬁnished solver answer set reported unsatisﬁability answer set aborted time memory exhaustion SATbased solver cmodels converts logic program propositional clauses Clark completion delegates search supported models minisat Except treatment extended rules approach comparable clasp tight programs In nontight case cmodels delays sophisticated unfounded set checks assignment total clasp smodels integrate propagation In fact smodels traditional ASP solver search pattern based systematic backtracking unfounded set checking procedure computing greatest unfounded sets Finally lp2sat like cmodels converts logic program propositional clauses delegates search model SAT solver On tight programs lp2sats translation amounts Clark completion level mappings 76103 capture noncircular derivability atoms nontight programs Among solvers accepting lparse output format experiments include ones leading NP decision category second ASP competition cf 2813 In particular lp2sat edge lp2diff 78 applies translation difference logic solvers Satisﬁability Modulo Theories SMT 10 search backends investigated benchmarks 77 Our experimental results summarized Tables 79 giving average runtimes seconds numbers aborted runs parentheses solver benchmark class time memory exhaustions taken 600 seconds More detailed benchmark results including individual times instances solver conﬁgurations provided 22 While Table 7 considers benchmarks divided tight nontight ones Tables 8 9 analogously report results restricted satisﬁable unsatisﬁable instances respectively Each table gives number instances benchmark class column headed In addition Table 7 provides respective partition satisﬁable satisﬁable instances parentheses The column amounts virtual best solver composed smallest runtime smallest number aborts observed benchmark class The rows marked average runtimes time memory exhaustions collection benchmark classes consideration14 The following row gives Euclidean distance ndimensional space n number benchmark classes point column n average runtimes solver virtual best respective collection focus quadratic distance calculation scheme punishes imbalanced rewards consistent performance averaging Some benchmark classes cmodels signiﬁcant impact heavy use extended rules different treatments clasp observed performances benchmark classes marked Tables 79 Considering results tight benchmarks upper Table 7 note traditional ASP solver smodels consistently outperformed systems exploiting conﬂictdriven learning For instance smodels times satisﬁable instances 15Puzzle unproblematic solvers In fact occasional varying performances tight programs different treatments extended rules andor determinizations inherent non determinisms minisat clasp respectively Any differences turn advantageous lp2satc edge solvers GraphColouring clasp default setting fastest way clasp SchurNumbers lp2satm yields fewest aborts WeightBoundedDomSet On nontight benchmarks observe problem representation overhead incurred lp2sats translational approach major handicap minisat clasp react sensitively cf Labyrinth TravellingSalesperson Except MazeGeneration strategy cmodels verify candidate supported models minisat improves eager translation lp2sat However integrating unfounded set checking propagation usually effective observed comparing cmodels KnightTour WireRouting Beyond dealing nontightness treatment extended clasp clasp rules crucial factor benchmark classes Their transformation normal rules cmodels lp2sat turns helpful ConnectedDomSet15 drastically blows problem representations deteriorates performance TravellingSalesperson Focusing satisﬁable unsatisﬁable instances Tables 8 9 respectively sheds light distri bution hardness benchmark classes exhibiting overwhelming impact relative solver performances In fact look Table 8 especially cmodels smodels reveals satisﬁable instances Channel Routing GraphPartitioning MazeGeneration easy Interestingly lp2sat variants diﬃculties nontight benchmarks viz GraphPartitioning MazeGeneration indicating eager translation logic programs diminish search performance On hand solvers perform worse satisﬁable instances SchurNumbers 12 Additional results cmodels zchaff 2007312 smodels restarts available 22 13 Some nonparticipating solvers assat sag 91 smodelscc longer maintained incorporated Although original smodels participate close derivative smodelsie 15 consider reference At time running experiments solver minisatid 95 supporting inductive deﬁnitions propositional theories accept lparse output format 14 We provide averages sums balancing diverse numbers instances benchmark class 15 Interestingly single instance ConnectedDomSet responsible timeouts clasp clasp Table 7 Average runtimes benchmarks second ASP competition Benchmark 15Puzzle BlockedNQueens ChannelRouting EdgeMatching Fastfood GraphColouring Hanoi HierarchicalClustering SchurNumbers Solitaire Sudoku WeightBoundedDomSet Eucl dist tight tight ConnectedDomSet GeneralizedSlitherlink GraphPartitioning HamiltonianPath KnightTour Labyrinth MazeGeneration Sokoban TravellingSalesperson WireRouting Eucl dist nontight nontight Eucl dist 16 29 10 29 29 29 15 12 29 27 10 29 160 1514 64 290 1019 920 150 84 1316 225 100 290 264 18282 21 29 13 29 10 29 29 29 29 23 1011 290 67 290 100 290 1019 920 290 1211 241 17368 505 355150 clasp 3301 509 12013 023 117 42155 1176 016 1744 20478 015 12313 7822 8180 4042 010 927 007 12429 12382 9117 073 005 4281 4327 6237 6233 10286 0 0 6 0 0 60 0 0 0 27 0 15 900 3 0 0 0 6 12 12 0 0 3 360 655 clasp 2018 491 12014 041 090 35788 397 017 4960 16282 016 10218 6861 3258 3611 022 798 006 9180 8292 8989 080 006 3636 3462 2897 5316 4359 cmodelsm smodels lp2satm lp2satc virtual best 0 0 6 0 0 39 0 0 0 21 0 12 650 3 0 0 0 3 6 12 0 0 3 270 477 3136 904 12058 5932 2922 42266 292 076 7570 17569 255 30026 10250 22719 746 192 2019 021 24248 14224 9041 339 31782 17573 10019 38316 10145 44545 0 0 6 0 0 57 0 0 0 21 0 36 1000 0 0 0 0 12 6 12 0 7 12 490 768 60000 2937 12090 6032 8393 45377 52377 156 50417 31696 025 40084 25799 99176 18376 016 9210 222 15055 59410 29362 17601 022 44832 19411 73935 22895 123702 48 0 6 0 3 63 39 0 72 36 0 51 2650 15 0 3 0 3 81 42 15 0 45 2040 2373 2221 1319 12134 1305 4685 40970 381 094 9088 22260 087 17956 9375 14167 1343 505 36518 345 54542 28223 12594 611 44168 46089 22494 86608 15338 87759 0 0 6 0 0 51 0 0 6 27 0 9 825 0 0 21 0 27 27 9 0 55 48 1870 1300 1513 522 12108 558 2495 35757 536 086 3693 21014 082 14387 7729 7051 1362 1290 34439 1568 48761 53462 8557 399 19834 45997 21567 83252 14019 83550 0 0 6 0 0 39 0 0 0 27 0 12 700 0 0 21 0 24 75 6 0 9 51 1860 1227 1513 491 12013 023 090 35757 292 016 1744 16282 015 10218 6538 000 746 010 798 006 9180 8292 8557 073 005 3636 3130 000 4989 000 0 0 6 0 0 39 0 0 0 21 0 9 625 0 0 0 0 3 6 6 0 0 3 180 423 7 4 M G e b s e r e t l A r t ﬁ c l I n t e l l g e n c e 1 8 7 1 8 8 2 0 1 2 5 2 8 9 Table 8 Average runtimes satisﬁable benchmarks second ASP competition Benchmark 15Puzzle BlockedNQueens ChannelRouting EdgeMatching Fastfood GraphColouring Hanoi HierarchicalClustering SchurNumbers Solitaire Sudoku WeightBoundedDomSet Eucl dist tight sat tight sat ConnectedDomSet GeneralizedSlitherlink GraphPartitioning HamiltonianPath KnightTour Labyrinth MazeGeneration Sokoban TravellingSalesperson WireRouting nontight sat Eucl dist nontight sat Eucl dist sat sat 16 15 6 29 10 9 15 8 13 22 10 29 182 10 29 6 29 10 29 10 9 29 12 173 355 clasp 3301 348 016 023 012 2499 1176 014 3725 11496 015 12313 2911 5907 928 010 011 007 12429 12382 007 063 005 7400 3324 5399 3099 8002 0 0 0 0 0 0 0 0 0 12 0 15 225 0 0 0 0 6 12 0 0 0 3 210 218 clasp 2018 493 017 041 049 3266 397 013 10913 6346 016 10218 2816 7248 174 022 014 006 9180 8292 008 078 006 6263 2404 020 2629 7248 cmodelsm smodels lp2satm lp2satc virtual best 0 0 0 0 0 0 0 0 0 6 0 12 150 0 0 0 0 3 6 0 0 0 3 120 136 3136 752 067 5932 926 9864 292 102 16677 7925 255 30026 6329 25602 1206 192 452 021 24248 14224 008 540 31782 13494 8617 36412 7369 44512 0 0 0 0 0 3 0 0 0 6 0 36 60000 2213 135 6032 8244 12880 52377 152 60000 25263 025 40084 48 0 0 0 0 3 39 0 39 21 0 51 375 22284 103756 1675 0 0 0 0 12 6 0 0 7 3 280 332 13510 016 056 222 15055 59410 015 32054 022 40744 16110 70978 19478 125711 6 0 0 0 3 81 0 9 0 18 1170 1445 2221 1399 163 1305 4533 5793 381 120 20049 13682 087 17956 5641 20365 1757 505 11421 345 54542 28223 11432 1077 44168 51320 20479 81854 12385 84349 0 0 0 0 0 0 0 0 6 12 0 9 225 0 0 3 0 27 27 0 0 55 30 1420 768 1513 416 137 558 1854 3127 536 103 8040 12154 082 14387 3576 8596 1236 1290 11825 1568 48761 53462 1092 434 19834 51994 19149 78978 10655 79444 0 0 0 0 0 0 0 0 0 12 0 12 200 0 0 3 0 24 75 0 0 9 30 1410 750 1513 348 016 023 012 2499 292 013 3725 6346 015 10218 2085 000 174 010 011 006 9180 8292 007 063 005 6263 2401 000 2229 000 0 0 0 0 0 0 0 0 0 6 0 9 125 0 0 0 0 3 6 0 0 0 3 120 123 M G e b s e r e t l A r t ﬁ c l I n t e l l g e n c e 1 8 7 1 8 8 2 0 1 2 5 2 8 9 7 5 Table 9 Average runtimes unsatisﬁable benchmarks second ASP competition Benchmark BlockedNQueens ChannelRouting Fastfood GraphColouring HierarchicalClustering SchurNumbers Solitaire Eucl dist tight unsat tight unsat ConnectedDomSet GraphPartitioning MazeGeneration Sokoban WireRouting nontight unsat Eucl dist nontight unsat 14 4 19 20 4 16 5 82 11 7 19 20 11 68 Eucl dist unsat unsat 150 clasp 682 30010 172 60000 021 134 60000 21574 9579 6873 1712 13912 078 878 4691 6703 14539 11691 0 6 0 60 0 0 15 1157 3 0 12 0 0 300 800 clasp 488 30010 111 50424 024 124 60000 20169 003 6735 1470 13716 081 770 4554 6524 13663 6524 cmodelsm smodels lp2satm lp2satc virtual best 0 6 0 39 0 0 15 857 3 0 12 0 0 300 625 1068 30044 3972 56848 024 170 60000 21732 7518 328 3362 13795 249 22023 7951 21378 15990 22662 0 6 0 54 0 0 15 1071 0 0 12 0 9 420 800 3714 30023 8471 60000 163 42630 60000 29286 44484 22799 17056 44809 11097 49292 29010 65333 29171 79039 0 6 3 60 0 33 15 1671 9 3 42 6 27 1740 1700 1233 30090 4766 56799 042 182 60000 21873 7930 967 58029 13206 401 40383 22597 69059 22175 69513 0 6 0 51 0 0 15 1029 0 18 9 0 18 900 975 635 30066 2832 50440 050 161 60000 20598 2726 1477 53822 12486 383 39456 21525 65105 20984 65162 0 6 0 39 0 0 15 857 0 18 6 0 21 900 875 488 30010 111 50424 021 124 60000 20168 000 328 1470 12486 078 770 3027 000 13026 000 0 6 0 39 0 0 15 857 0 0 6 0 0 120 550 7 6 M G e b s e r e t l A r t ﬁ c l I n t e l l g e n c e 1 8 7 1 8 8 2 0 1 2 5 2 8 9 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 77 unsatisﬁable ones applies clasp clasp lp2sat WireRouting Looking classes Table 9 observe unsatisﬁable instances SchurNumbers trivial solvers smodels clasp clasp complete unsatisﬁable WireRouting instances The suggests instances inherently hard lacking conﬂictdriven learning smodels native unfounded set checking cmodels lp2sat renders diﬃcult Unlike SchurNumbers WireRouting unsatisﬁable instances ChannelRouting GraphColouring Soli taire MazeGeneration turn harder satisﬁable counterparts considered solvers Notably lp2satc running clasp SAT solver completes unsatisﬁable MazeGeneration instances clasp clasp contrasts behavior observed satisﬁable instances cf MazeGeneration Tables 8 9 A similar shift behaviors unsatisﬁable instance ConnectedDomSet poses problem intrinsic treatment extended rules clasp clasp cmodels lp2sat encounter diﬃculties In view believe dynamic selection possible handlings extended rules intrinsic treatment andor transforma tion interesting future work 7 Related work Our approach conﬂictdriven ASP solving borrows extends stateoftheart techniques area SAT 12 Its global search pattern similar CDCL FirstUIP scheme developed decade ago 97101127 nowadays quasi standard industrial SAT solving cf 35115100291142396 While traditional search procedures like DavisPutnamLogemannLoveland DPLL 2524 polynomially equivalent treelike resolution CDCL unlimited restarts amounts general resolution 109 strictly powerful bestcase complexity unsatisﬁability proofs DPLL Several investigations 627970 separation carries forward native ASP solvers standard translations ASP SAT viz Clark completion reduction 102 The clasp implements CDCL search pattern likewise logic programs answer set semantics propositional CNF PB formulas In contrast translational approaches minisat 36 offers dedicated data structures internal representation reasoning linear inequalities 47 This relates clasp SMT 10 techniques applying theory propagation cf 104 concepts available extended logic programs 119 viz unfounded sets positive recursion linear inequalities Boolean variables SATbased ASP solvers like assat 90 cmodels 71 sag 91 exploit conﬂictdriven learning search supported models answer set candidates accomplished underlying SAT solvers However integration unfounded set checking loose native ASP solvers To knowledge native ASP solver clasp implements conﬂictdriven learning smodelscc 12616 ASP solvers like dlv 83 smodels 119 nomore 1 perform DPLLstyle search For enabling conﬂict analysis smodelscc takes algorithmic approach monitoring applications smodels inference rules ontheﬂy build implication graph 971279 representation antecedents Unlike clasp directly incorporates suitable data structures designed accommodate backjumping conﬂictdriven learning similar SAT solvers merely stores references antecedents propagation incurs negligible constant overhead A prototypical extension 112 dlv includes backjumping learning based tracking dlvs inference rules Given answer sets determined atoms native ASP solvers dlv smodels smodelscc logically restricted assignments atoms As shown 6362 yields exponential separation tight logic programs solvers addition assign decisions rule bodies To knowledge clasp nomore ASP solvers deliberately taking advantage rule bodies assignments Regardless minor technical differences compar ison smodels nomore inferences 62 reveals based structural propositions bodies restricted scope heuristic decisions main trait smodels atomoriented approach In view similarities smodels cf 70 applies dlv smodelscc Interestingly CNF conversions SATbased ASP solvers cf 5 introduce auxiliary propositions rule bodies prevent exponential blowup Although auxiliary propositions exploited underlying SAT solvers motivation need design However consensus represent Boolean constraints induced logic programs proposals 57086 nogoods express conditions unit propagation separating semantics syntactic representations As pointed 6386 SATbased native ASP solvers differ laziness apply unfounded set checks While conﬁne ﬁnal tests required soundness terminology 104 investigating SMT native ASP solvers perform theory propagation unfounded sets17 Notably virtually ASP solvers exploit strongly connected components positive dependency graphs limit work necessary parts Unlike unfounded set checking procedures dlv 17 smodels 119 computing greatest unfounded sets ones clasp nomore 2 aim small unfounded sets return soon identiﬁed The main motive reduce overlaps unit propagation unfounded set checking Another difference unfounded set checking approaches dlv 16 The solver minisatid 95 supports inductive deﬁnitions propositional theories Inductive deﬁnitions closely related logic programs involve totality condition shared 17 The approach lp2diff 78 relies reduction difference logic SMT solvers supporting logic accomplish unfounded set checks compute answer sets 78 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 nomore use ﬂag mustbetrue indicate logically true atoms noncircular derivability uncertain purpose smodels clasp exploit source pointers 119 The advantage source pointers need updated backtracking backjumping respectively true turned mustbetrue Albeit approaches 907191259 admit restricting consideration unfounded sets loops clasp guarantee detected nonempty unfounded set loop contains interesting open question strict limitation loops advantageous We note unidirectional unfounded set handling native ASP solvers realizing unit propagation loop formulas recognized 6362 Unfortunately approach remedy peculiarity suggested 1819 computationally complex quadratic beneﬁcial practice open intended effect achieved economic techniques On basic decision procedure clasp supports extended functionalities cf 56 Particular backtracking schemes applied ﬁnding solution admit repetitionfree enumeration answer sets 53 projections 57 polynomial space Optimization strategies wrt multiple lexicographically ordered objectives described 48 Furthermore clasp offers advanced preprocessing level logic programs 55 induced constraints 33 Techniques intrinsic treatment extended rules presented 47 particular include unfounded set checking procedure extending Algorithm 3 Finally systems implement elaborate features clasp disjunctive ASP solver claspD 31 internally couples clasp engines clingcon 60 embeds gecode constraint library18 clasps propagation routine deal nonBoolean variables iclingo 46 exploits clasps incremental interface solve series problems increasing horizons 2034 parallel ASP solver claspar 3711850 augments clasp communication module enable message passing distributed solver instances 8 Summary We provided uniform approach conﬂictdriven ASP solving allowing transparent technology transfer neighboring areas like SAT The idea view inferences ASP solving unit propagation nogoods reﬂecting constraints Clark completion unfounded sets conﬂicts We seen inclusion rule bodies assignments allows natural extension unit propagation ASP abolishing preexisting need multiple inference rules In contrast SAT ASP induces implicit constraints given loop nogoods Though inherently present nogoods need expatiated serve antecedents This puts sophisticated unfounded set checks logical basis plain SAT provided conﬂictdriven algorithmic framework ASP solving incorporating state oftheart SAT solving techniques Notably approach favors unit propagation explicit nogoods unfounded set checks testing implicit loop nogoods unit violated In fact combinatorially constructable loop nogoods ΛΠ redundant entailed Clark completion andor loop nogoods For tight programs set ΛΠ loop nogoods redundant In view approach makes sure inspected loop nogoods 1empowering 108 supplement available constraints We implemented approach ASP solver clasp demonstrated competitiveness settings instance winning ﬁrst places ASP CASC MISC PB SAT contests 2011 The clasp implements stateoftheart techniques Boolean constraint solving deploying modifying legacy SAT solver Rather clasp extends functionalities plain SAT solvers unfounded set checking intrinsic treatment cardinality weight constraints optimization Beyond search answer set clasp enumerate falling solution recording techniques detailed 53 57 All clasp powerful native ASP solver reasoning modes 56 attractive tool knowledge representation reasoning The clasp constitutes central component Potassco tool suite 44 applications diverse areas like assisted living 99 music composition 13 temporal reasoning 80 general game playing 122 hardware synthesis 75 systems biology 64 Acknowledgements We grateful ASP research user community valuable contributions Potassco project anonymous reviewers paper helpful comments This work supported German Science Foundation DFG grants SCHA 55081 2 Appendix A Proofs In Appendices A1 A2 provide proofs formal results presented Sections 3 45 respectively 18 Available httpwwwgecodeorg M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 79 A1 Nogoods logic programs We begin Lemma 31 establishing solution cid5Π uniquely determined literals atoms Lemma 31 Let Π logic program X atomΠ Then A Tp p X cid4 cid6 Fp cid5 cid5 β bodyΠ β cid5 cid7 cid5 β bodyΠ cid5 cid5 p atomΠ X X β X cid8cid8 cid7 atomΠ X β cid6 cid4 cid4 Tβ Fβ cid7 X β cid8 cid6 cid7 unique solution cid5bodyΠ AT atomΠ X Proof Consider β p1 pm pm1 pn bodyΠ recall δβ Fβ Tp1 Tpm Fpm1 Fpn cid5β Tβ Fp1 Tβ Fpm Tβ Tpm1 Tβ Tpn Then following cases applies β X β X We Tp1 Tpm Fpm1 Fpn A Fp1 Fpm Tpm1 Tpn A In view δ cid2 A δ cid5β Furthermore Tβ A Fβ A sure δβ cid2 A δβ A Fβ β atomΠ X β X cid7 We Fp1 Fpm Tpm1 Tpn A cid7 Tp1 Tpm Fpm1 Fpn cid2 A The yields δβ cid2 A Furthermore Fβ A Tβ A sure δ cid2 A δ cid5β δ A Tβ δ cid5β The cases β bodyΠ nogood δβcid5β contained A A solution cid5bodyΠ δβ β bodyΠ δ cid5β β bodyΠ On hand β bodyΠ δβ A Fβ δ A Tβ δ cid5β Hence solution B cid7 A cid5bodyΠ BT atomΠ X cid2 Theorem 33 correspondence answer sets tight program Π solutions cid5Π derived Lemma 32 establishing onetoone correspondence supported models Π solutions cid5Π Both results demonstrated Lemma 32 Let Π logic program X atomΠ bodyΠ Then X atomΠ pβ β X bodyΠ supported model Π iff Tv v X Fv v atomΠ bodyΠ X solution cid5Π Proof Let M X atomΠ pβ β X bodyΠ A Tv v X Fv v atomΠ bodyΠ X Then p atomΠ β bodyΠ p M pβ M iff Tp A Tβ A p M pβ M iff Fp A Fβ A Considering β p1 pm pm1 pn bodyΠ diﬃcult check δ A δ δβ cid5β Fβ Tp1 Tpm Fpm1 Fpn Tβ Fp1 Tβ Fpm Tβ Tpm1 Tβ Tpn iff M cid7cid20 pβ p1 pm pm1 pn Likewise p atomΠ bodyΠ p β1 βk δ A δ δp cid5p Tp Fβ1 Fβk Fp Tβ1 Fp Tβk iff M cid7cid20 p pβ1 pβk This shows M supported model Π iff A solution cid5Π cid2 Theorem 33 Let Π tight logic program X atomΠ Then X answer set Π iff A Tp p X cid4 cid6 Fp cid5 cid5 β bodyΠ β cid5 cid7 cid5 β bodyΠ cid5 cid5 p atomΠ X X β X cid8cid8 cid7 atomΠ X β cid6 cid4 cid4 Tβ Fβ cid7 X β cid8 cid6 cid7 unique solution cid5Π AT atomΠ X Proof By Lemma 31 subset cid5Π A unique solution AT atomΠ X Along Lemma 32 conclude M atomΠ X supported model M Π iff A unique solution cid5Π 80 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 AT atomΠ X Finally Theorem 32 40 showing supported models answer sets Π coincide Π tight19 conclude X answer set Π iff A unique solution cid5Π AT atomΠ X cid2 In order extend Theorem 33 nontight programs provide properties unfounded sets To begin GRSunfounded sets linked unfounded sets fact wrt bodysaturated assignment GRSunfounded set unfounded set Proposition 34 Let Π logic program A assignment U atomΠ If A bodysaturated Π U unfounded set Π wrt A U GRSunfounded set Π wrt A Proof Assume A bodysaturated Π Then β bodyΠ β AF β AT cid7 implies β AF Hence U GRSunfounded set Π wrt A EBΠ U β bodyΠ β AF β AT cid7 implies EBΠ U AF U unfounded set Π wrt A cid2 Further considering relationships unfounded set concepts unfounded sets GRSunfounded sets coincide wrt bodysynchronized assignments Proposition 35 Let Π logic program A assignment U atomΠ If A bodysynchronized Π U unfounded set Π wrt A iff U GRSunfounded set Π wrt A Proof Assume A bodysynchronized Π Then A bodysaturated Π according Deﬁnition 33 Proposition 34 U unfounded set Π wrt A U GRSunfounded set Π wrt A It remains converse holds Since A bodysynchronized Π β bodyΠ β AF implies β AF β AT cid7 Hence U unfounded set Π wrt A EBΠ U AF implies EBΠ U β bodyΠ β AF β AT cid7 U GRSunfounded set Π wrt A cid2 The following characterization solutions ΛΠ provides analogy unfoundedfree interpretations 84 identi ﬁed wrt GRSunfounded sets terms unfounded set notion Proposition 36 Let Π logic program A assignment AT AF atomΠ bodyΠ Then A solution ΛΠ iff U AF unfounded set U Π wrt A Proof We A solution ΛΠ iff λp U A U atomΠ p U iff p U AT EBΠ U AF U atomΠ iff U cid2 AF unfounded set U Π wrt A cid2 We ready extend Theorem 33 nontight programs Theorem 37 Let Π logic program X atomΠ Then X answer set Π iff A Tp p X cid6 cid4 Fp cid5 cid5 β bodyΠ β cid5 cid7 cid5 β bodyΠ cid5 cid5 p atomΠ X X β cid7 β X cid8cid8 atomΠ X cid6 cid4 cid4 Tβ Fβ cid7 X β cid8 cid6 cid7 unique solution cid5Π ΛΠ AT atomΠ X Proof By Lemma 31 subset cid5Π A unique solution AT atomΠ X Along Lemma 32 conclude M atomΠ X supported model M Π iff A unique solution cid5Π AT atomΠ X For supported model M Π clear M atomΠ model Π M cid7 holds r Π Hence A unique solution cid5Π headr M bodyr AT atomΠ X AT atomΠ model Π In addition A bodysynchronized Π according Deﬁnition 33 AF bodyΠ β bodyΠ β atomΠ X β X cid7 β bodyΠ β AF β AT cid7 We use properties implications statement cid2 M bodyr 19 Note equivalences 3 deﬁne auxiliary propositions bodies terms atoms Hence representation conservative extension completion Π originally described propositions bodies 21 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 81 Assume X answer set Π Then Corollary 1 93 M atomΠ X supported model M Π See Footnote 19 remarks role auxiliary propositions bodies Clark completion Π That A unique solution cid5Π AT atomΠ X Furthermore Theorem 46 84 U X holds GRSunfounded set U Π wrt X Since A bodysynchronized Π Proposition 35 conclude U AT U AF hold unfounded set U Π wrt A Hence Proposition 36 A solution ΛΠ unique solution cid5Π ΛΠ AT atomΠ X Assume A unique solution cid5Π ΛΠ AT atomΠ X Then Proposition 36 U AT holds unfounded set U Π wrt A Since A bodysynchronized Π Proposition 35 yields U X holds GRSunfounded set U Π wrt X Along fact AT atomΠ X model Π Theorem 46 84 conclude X answer set Π We shown implications statement hold cid2 In follows crucial properties unfounded sets To begin false atoms unfounded set removed maintaining unfoundedness assignment hand bodysaturated Proposition 38 Let Π logic program A assignment U unfounded set Π wrt A If A bodysaturated Π U AF unfounded set Π wrt A Proof Assume A bodysaturated Π Then β EBΠ U AF EBΠ U fact β U AF cid7 implies β AF Along EBΠ U AF conclude EBΠ U AF AF U AF unfounded set Π wrt A cid2 The following auxiliary result shows wrt atomsaturated assignment nonempty unfounded set nonfalse atoms loop contains turn nonempty proper subset unfounded Lemma A1 Let Π logic program A assignment U atomΠ AF nonempty unfounded set Π wrt A If A atomsaturated Π U loopΠ nonempty unfounded set U cid16 U Π wrt A Proof Assume A atomsaturated Π U loopΠ Then p U prerequisite U atomΠ AF implies bodyΠ p cid2 AF EBΠ U AF yields bodyΠ p EBΠ U AF That p U β bodyΠ p AF β U cid7 holds β bodyΠ p AF Hence atom U predecessor belonging U atomΠ cid2 However U loopΠ subgraph atomΠ cid2 induced U strongly connected Along fact U ﬁnite conclude strongly connected component U vertices C reach atoms U C 20 The U p headr r Π headr U p bodyr means β C holds β EBΠ U C EBΠ U C EBΠ U Since C U EBΠ U AF shows U cid16 U C nonempty unfounded set Π wrt A U cid16 U cid2 The previous lemma allows conclude wrt atomsaturated assignment nonempty unfounded set nonfalse atoms contain unfounded loop Proposition 39 Let Π logic program A assignment U atomΠ AF nonempty unfounded set Π wrt A If A atomsaturated Π unfounded set L U Π wrt A L loopΠ Proof Assume A atomsaturated Π Then U atomΠ AF nonempty unfounded set Π wrt A nonempty unfounded set L U Π wrt A L unfounded sets Π wrt A contained L For L U Lemma A1 conclude L loopΠ cid2 Corollary 310 Let Π logic program A assignment U atomΠ AF nonempty unfounded set Π wrt A If A atomsaturated Π nonempty unfounded set U nontrivial strongly connected component atomΠ cid2 cid16 U Π wrt A p U cid16 belong Proof This result follows immediately Proposition 39 atoms L loopΠ belong strongly connected component atomΠ cid2 nontrivial deﬁnition loop cid2 Finally combine Propositions 38 39 wrt assignment atom bodysaturated unfounded set includes nonfalse atoms contain unfounded loop nonfalse atoms 20 Note condensation U p headr r Π headr U p bodyr single vertex directed acyclic graph cf 111 U obtained contracting strongly connected component 82 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 Theorem 311 Let Π logic program A assignment If A atom bodysaturated Π unfounded set U Π wrt A U cid2 AF unfounded set L U AF Π wrt A L loopΠ Proof Assume A atom bodysaturated Π unfounded set U Π wrt A U cid2 AF Then Proposition 38 U AF nonempty unfounded set Π wrt A Furthermore Proposition 39 unfounded set L U AF Π wrt A L loopΠ cid2 Corollary 312 Let Π logic program A assignment If A atom bodysaturated Π unfounded set U Π wrt A U cid2 AF belong nontrivial strongly connected component cid16 U AF Π wrt A p U cid16 nonempty unfounded set U atomΠ cid2 Proof This result follows immediately Theorem 311 atoms L loopΠ belong strongly connected component atomΠ cid2 nontrivial deﬁnition loop cid2 A2 Soundness completeness CDNLASP algorithm We begin showing fundamental properties UnfoundedSet Algorithm 3 Lemmas 41 42 establish invariants crucial soundness completeness stated Theorem 43 Lemma 41 Let Π logic program A assignment bodysaturated Π If UnfoundedSetΠ A invoked valid source pointer conﬁguration source pointer conﬁguration remains valid execution UnfoundedSetΠ A Proof Assume UnfoundedSetΠ A invoked valid source pointer conﬁguration Then invalid source pointer conﬁguration principle obtained Line 13 Algorithm 3 sourceq set cyclic q atomΠ However induction executions Line 13 source pointer conﬁguration remains valid cid13 Base case Since given source pointer conﬁguration valid A bodysaturated Π ﬁnishing loop Lines 25 Algorithm 3 sourcep bodyΠ p AF sourcep AF sccp S hold cyclic p atomΠ AF S For atoms C nontrivial strongly connected component pCAFSsourcep C C AF S In words source pointers atomΠ cid2 implies atoms C false A scope S contain atom C false A scope S Induction step Let q U cyclic atom condition Line 12 Algorithm 3 applies q let C sccq Then view choice p S Line 6 Lines 7 1416 manipulating contents U S respectively U C S yields q C S Furthermore assume pCAFSsourcep C C AF S holds setting source pointer conﬁguration valid sourceq β bodyΠ q Line 13 In terms subgraph atomΠ cid2 containing cyclic pCAFSsourcep C C AF S cid16 sourcep sccp p atomΠ edges p means contain edge atom C AF S atom C AF S For β A bodysaturated Π condition β EBΠ U AF Line 10 makes sure β AF β C S veriﬁed Line 11 Hence β C C AF S edges p q atoms p β C q holds p C AF S As seen q C S reach atoms C AF S conclude subgraph atomΠ cid2 containing cyclic p atomΠ edges p cid16 p cid16 sourcep sccp remains acyclic setting sourceq β Line 13 This shows source p pointer conﬁguration obtained executing Line 13 turn valid Finally induction hypothesis pCAFSsourcep holds S q constructed Line 15 C β C C AF S C AF S q pCAFSqsourcep C cid16 p p cid13 cid13 cid13 cid13 We shown valid source pointer conﬁguration invalidated invoking UnfoundedSetΠ A assignment A bodysaturated Π cid2 Lemma 42 Let Π logic program A assignment atomsaturated Π If UnfoundedSetΠ A invoked valid source pointer conﬁguration unfounded set U atomΠ AF Π wrt A p U belong strongly connected component atomΠ cid2 contained S Line 6 Algorithm 3 entered Proof Assume UnfoundedSetΠ A invoked valid source pointer conﬁguration Then let U atomΠ AF unfounded set Π wrt A p U belong strongly connected component atomΠ cid2 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 83 Since U AF A atomsaturated Π bodyΠ p cid2 AF p U EBΠ U AF implies β U cid7 holds β bodyΠ p AF That p U cyclic sourcep bodyΠ p holds given source pointer conﬁguration valid By induction executions test Line 6 Algorithm 3 U cid2 S impossible Line 6 entered Base case For sake contradiction assume U cid2 S ﬁnishing loop Lines 25 Algorithm 3 Then view Line 1 p U S sourcep AF implies sourcep bodyΠ p AF sourcep U cid7 Moreover condition sourcep sccp S cid7 Line 3 apply sourcep yields sourcep U S sourcep U S cid7 Since U S ﬁnite atom U S predecessor belonging U S subgraph atomΠ cid2 containing cyclic p atomΠ edges q p q sourcep sccp conclude subgraph acyclic contradiction assumption UnfoundedSetΠ A invoked valid source pointer conﬁguration Induction step For sake contradiction assume U S beginning iteration loop Lines 617 Algorithm 3 U cid2 S Line 6 reentered ﬁnishing iteration In iteration elements U S successively removed S Line 15 In particular q U S removed S atom U To achieve condition Line 11 applied β bodyΠ q AF yields β sccq U U Since U sccq implies β U contradiction assumption U unfounded set Π wrt A cid16 superset U cid16 We shown UnfoundedSetΠ A invoked valid source pointer conﬁguration assign ment A atomsaturated Π unfounded set U atomΠ AF Π wrt A p U belong strongly connected component atomΠ cid2 contained S Line 6 Algorithm 3 en tered If unfounded set U nonempty invariant excludes termination Algorithm 3 returning Line 18 cid2 Theorem 43 Let Π logic program A assignment atom bodysaturated Π If UnfoundedSetΠ A invoked valid source pointer conﬁguration UnfoundedSetΠ A returns unfounded set U atomΠ AF Π wrt A U iff unfounded set U Π wrt A U cid16 cid16 cid2 AF cid16 Π wrt A U Proof Assume UnfoundedSetΠ A invoked valid source pointer conﬁguration Then view condi tion EBΠ U AF Line 9 Algorithm 3 fact returned Line 18 trivial unfounded set Π wrt A UnfoundedSetΠ A return unfounded set Π wrt A By Corollary 312 cid16 cid2 AF implies nonempty unfounded existence nonempty unfounded set U cid16 AF p U belong strongly connected component atomΠ cid2 Furthermore set U U Lemma 42 unfounded set U Π wrt A contained scope S Line 6 entered This shows UnfoundedSetΠ A return Line 18 nonempty unfounded set U Π wrt A U cid16 cid2 AF It remains UnfoundedSetΠ A terminates To end note scope S increasing iterations loop Lines 25 Algorithm 3 strictly decreasing iterations loop Lines 617 For U handled loop Lines 817 observe strictly increasing U extended Line 16 strictly decreasing element q removed U Line 14 q added later removed S Line 15 Since atomΠ ﬁnite U S atomΠ AF conclude loops Algorithm 3 iterated inﬁnitely Rather atom added removed S U respectively yields time complexity UnfoundedSetΠ A linear size Π cid2 cid16 Next properties NogoodPropagation Algorithm 2 Lemma 44 essentially establishes applicability Theorem 43 unfounded set check initiated Line 12 Algorithm 2 Lemma 45 provides properties crucial soundness completeness conﬂictdriven ASP solving Lemma 44 Let Π logic program cid16 set nogoods dl N A cid16 assignment Then A atom bodysaturated Π Line 10 Algorithm 2 entered execution NogoodPropagationdl Π cid16 A cid16 Proof For sake contradiction assume Line 10 Algorithm 2 entered execution NogoodPropaga tiondl Π cid16 A cid16 current assignment A atomsaturated bodysaturated Π Then following cases applies bodyΠ p AF Fp A p atomΠ The nogood δp Tp Fβ1 Fβk bodyΠ p β1 βk δp A Tp In view condition Line 4 Algorithm 2 tested previous iteration 84 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 loop Lines 39 Tp A δp A Tp But implies Fp unitresulting δp wrt A condition Σ hold Line 9 contradicts Line 10 entered A current assignment β AF β AT cid7 Fβ A β bodyΠ Some nogood δ Tβ ρ cid5β δ A Tβ In view condition Line 4 Algorithm 2 tested previous iteration loop Lines 39 Tβ A δ A Tβ But implies Fβ unitresulting δ wrt A condition Σ hold Line 9 contradicts Line 10 entered A current assignment Since cases yields contradiction conclude A atom bodysaturated Π Line 10 Algorithm 2 entered cid2 Lemma 45 Let Π logic program cid16 set nogoods dl N A cid16 assignment If NogoodPropagationdl Π cid16 A cid16 invoked valid source pointer conﬁguration NogoodProp agationdl Π cid16 A cid16 returns pair A 1 cid16 cid16 ΛΠ 2 A assignment A 3 δ A δ cid5Π λp U A λp U ΛΠ cid16 A σ A A cid16 implied cid5Π wrt A Proof Assume NogoodPropagationdl Π cid16 A begin showing items statement hold NogoodPropagationdl Π cid16 A cid16 invoked valid source pointer conﬁguration Then cid16 returns pair A 1 Since cid16 2 In view Line 5 Algorithm 2 literal σ added assignment B A augmented elements ΛΠ Line 14 Algorithm 2 cid16 cid16 ΛΠ cid16 B A σ σ B antecedent δ cid5Π σ wrt B σ implied cid5Π wrt A 3 For sake contradiction assume δ cid2 A δ cid5Π λp U A λp U ΛΠ Then U unfounded set Π wrt A U cid2 AF Furthermore A returned Line 10 13 Algorithm 2 Lemma 44 tells A atom bodysaturated Π By Theorem 311 conclude L loopΠ unfounded Π wrt A Π tight Hence A returned Line 13 obtaining result UnfoundedSetΠ A Line 12 However Lemmas 44 41 conclude Theorem 43 applicable contradicts obtained result UnfoundedSetΠ A Line 12 cid16 terminates To end note assignment B It remains NogoodPropagationdl Π cid16 A cid16 B increasing iterations loop Lines 39 Algorithm 2 shown proof second A item Furthermore Theorem 43 Lemmas 44 41 invocation UnfoundedSetΠ B Line 12 terminates unfounded set U atomΠ BF Π wrt B Hence U λp U B Tp p U Lemma 44 Proposition 38 applies U BF determined Line 11 Thus execution Lines 1112 followed termination Algorithm 2 Line 13 view Line 14 termination Line 4 addition literal Fp p atomΠ BT BF B Line 8 iteration loop Lines 214 Since atomΠ bodyΠ ﬁnite inﬁnitely literals added A iterations loops Lines 214 39 respectively NogoodPropagationdl Π cid16 A cid16 terminates returning pair A cid2 cid16 The following lemma expresses ConflictAnalysis Algorithm 4 returns asserting nogood given nogood violated decision level greater 0 Lemma 46 Let Π logic program set nogoods A assignment σ A ρ Aσ dlσ dlρ σ A ρ Aσ dlρ dlσ σ A ε cid5Π ε Aσ σ δcid16 A m maxdlσ σ δcid16 0 cid7 0 Then ConflictAnalysisδcid16 Π A returns pair δ k 1 δ A 2 σ δ k dlσ 1 3 δ cid2 B solution B cid5Π δcid16 Proof Given σ A ρ Aσ dlσ dlρ εcid16 A maxdlρ ρ εcid16 0 m contains literal σ εcid16 Aσ σ dlσ m Such literals σ determined Line 2 Algorithm 4 Then induction iterations loop Lines 17 Algorithm 4 items statement hold Con flictAnalysisδcid16 Π A returns pair δ k Base case Let δ A set literals maxdlρ ρ δ 0 m δ cid2 B solution B cid5Π δcid16 For literal σ δ determined Line 2 Algorithm 4 test Line 4 yields k maxdlρ ρ δ σ 0 cid7 m ρ δ k dlρ σ 1 δ k returned Line 7 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 85 Induction step Let εcid16 A set literals maxdlρ ρ εcid16 0 m εcid16 cid2 B solution B cid5Π δcid16 For literal σ εcid16 determined Line 2 Algorithm 4 test Line 4 yields maxdlρ ρ εcid16 σ 0 m ρ Aσ dlρ dlσ m Given σ A ρ Aσ dlρ dlσ σ A ε cid5Π ε Aσ σ cid5Π contains antecedent σ wrt A ε selected Line 5 Since εcid16 σ Aσ A ε σ Aσ A εcid16 σ ε σ constructed Line 6 holds εcid16 σ ε σ Aσ A Furthermore maxdlρ ρ εcid16 σ 0 m implies maxdlρ ρ εcid16 σ ε σ 0 m Finally solution B cid5Π δcid16 contains σ σ εcid16 cid2 B ε cid2 B εcid16 σ ε σ cid2 B It remains ConflictAnalysisδcid16 Π A terminates base case induction eventually applies To end note induction step εcid16 σ ε σ Aσ A literals ρ εcid16 σ ε σ precede σ A From fact A include duplicate literals conclude inﬁnitely applications induction step iterations loop Lines 17 Algorithm 4 ConflictAnalysisδcid16 Π A terminates returning pair δ k cid2 We turn CDNLASP Algorithm 1 deciding logic program answer set Lemma 47 establishes invariants crucial main soundness completeness result stated Theorem 48 Lemma 47 Let Π logic program Then following holds Line 5 Algorithm 1 entered execution CDNLASPΠ 1 set nogoods δ cid2 B δ solution B cid5Π ΛΠ 2 A assignment σ A ρ Aσ dlσ dlρ σ A dlσ cid2 maxdlρ ρ Aσ 0 σ A ε cid5Π ε Aσ σ 3 dl N δ cid2 σ A dlσ dl δ cid5Π ΛΠ Proof By induction iterations loop Lines 417 Algorithm 1 items statement hold Line 5 entered execution CDNLASPΠ Base case Before ﬁrst iteration view Lines 13 Algorithm 1 A dl 0 items statement trivially hold maxdlσ σ A 0 cid2 dl cid16 Induction step At beginning iteration loop Lines 417 Algorithm 1 let cid16 cid16 0 cid2 21 Then Lemma 45 Lemmas 41 44 view Lines 78 Algorithm 2 cid16 invoked Line 5 returns pair A items statement Afterwards items 1 2 3 statement satisﬁed wrt assume maxdlσ σ A dl cid16 NogoodPropagationdl hold A dl following cases applies respectively In addition maxdlσ σ A 0 cid2 dl Π cid16 A cid16 dl A cid16 cid16 cid16 ε A ε cid5Π If condition Line 7 Algorithm 1 applies CDNLASPΠ immediately ter minates returning answer set Otherwise Lemma 46 ConflictAnalysisε Π A σ δ k dlσ 1 δ cid2 B solution B returns pair δ k δ A cid5Π Since solution B cid5Π ΛΠ solution cid5Π follows δ cid2 B 1 B solution cid5Π δ δ constructed Line 9 Furthermore Ak A σ A k dlσ constructed Line 10 2 σ Ak ρ Akσ dlσ dlρ σ Ak dlσ cid2 maxdlρ ρ Akσ 0 σ Ak ε cid5Π δ ε Akσ σ Since 0 cid2 k holds view Line 3 Algorithm 4 maxdlσ σ Ak 0 cid2 dl dl set k Line 8 Finally δ A σ δ k dlσ 1 yield dl dl δ cid2 Ak 3 dl N δcid16 cid2 σ Ak dlσ dl δcid16 cid5Π ΛΠ δ That induction hypotheses apply wrt δ Ak dl cid16 If condition Line 11 Algorithm 1 applies CDNLASPΠ terminates Line 12 returning AT atomΠ Otherwise decision literal σd Tv σd Fv returned SelectΠ A v atomΠ bodyΠ AT AF required Section 41 Line 14 Let dl dl Line 16 0 dl 2 σ Aσd σ 0 σ Aσd Aσd σ σ Finally note 1 altered item ε cid5Π ε Aσd cid16 1 set Line 15 Since dlσd set dl A σd constructed Line 17 maxdlσ σ Aσd ρ Aσd σ dlσ dlρ σ Aσd dlσ cid2 maxdlρ ρ Aσd ε cid2 A ε cid5Π 21 We indicate derivations induction hypotheses 1 2 3 standing ﬁrst second item statement respectively expressing maxdlσ σ A 0 cid2 dl holds assignment A current value dl 86 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 statement Lemma 45 3 dl N δ cid2 σ Aσd δ cid5Π ΛΠ That induction hypotheses apply wrt Aσd dl dlσ dl We shown items statement hold Line 5 Algorithm 1 entered cid2 Theorem 48 Let Π logic program Then CDNLASPΠ terminates returns answer set Π iff Π answer set Proof If AT atomΠ returned Line 12 Algorithm 1 test Line 6 item statement Lemma 45 establish A solution cid5Π ΛΠ Furthermore Lemma 31 solution B cid7 A cid5Π ΛΠ BT atomΠ AT atomΠ Hence Theorem 37 conclude AT atomΠ answer set Π On hand CDNLASPΠ returns answer set Line 7 view item statement Lemma 47 maxdlσ σ ε 0 0 ε cid5Π ε A Then second item statement Lemma 47 σ ε antecedent σ wrt A cid5Π solution cid5Π Along ﬁrst item statement Lemma 47 follows solution cid5Π ΛΠ Hence Theorem 37 conclude Π answer set It remains CDNLASPΠ terminates In view second item statement Lemma 47 condition Line 7 Algorithm 1 Lemma 46 applies Conflict Analysisε Π A invoked Line 8 Hence returns pair δ k literal ρ unitresulting δ wrt A σ A k dlσ As consequence ρ added A σ A k dlσ Line 5 iteration loop Lines 417 That backjump Line 10 element atomΠ bodyΠ assigned smaller nonnegative decision level Since atomΠ bodyΠ ﬁnite implies CDNLASPΠ admits ﬁnitely backjumps22 Along fact A strictly extended Line 17 backjump termination Line 12 inevitable linear number iterations loop Lines 417 conclude CDNLASPΠ eventually terminates Line 7 12 Algorithm 1 cid2 References 1 C Anger M Gebser T Linke A Neumann T Schaub The nomore approach answer set solving G Sutcliffe A Voronkov Eds Proceedings Twelfth International Conference Logic Programming Artiﬁcial Intelligence Reasoning LPAR05 Lecture Notes Artiﬁcial Intelligence vol 3835 SpringerVerlag 2005 pp 95109 2 C Anger M Gebser T Schaub Approaching core unfounded sets J Dix A Hunter Eds Proceedings Eleventh International Workshop Nonmonotonic Reasoning NMR06 number IFI0604 Institute Informatics Clausthal University Technology Technical Report Series 2006 pp 5866 3 K Apt H Blair A Walker Towards theory declarative knowledge J Minker Ed Foundations Deductive Databases Logic Programming Morgan Kaufmann Publishers 1987 pp 89148 Chapter 2 4 G Audemard L Simon Predicting learnt clauses quality modern SAT solvers Boutilier 2009 14 pp 399404 5 Y Babovich V Lifschitz Computing answer sets program completion httpwwwcsutexaseduuserstagcmodelscmodels1ps 2003 6 C Baral Knowledge Representation Reasoning Declarative Problem Solving Cambridge University Press 2003 7 C Baral G Brewka J Schlipf Eds Proceedings Ninth International Conference Logic Programming Nonmonotonic Reasoning LPNMR07 Lecture Notes Artiﬁcial Intelligence vol 4483 SpringerVerlag 2007 8 C Baral G Greco N Leone G Terracina Eds Proceedings Eighth International Conference Logic Programming Nonmonotonic Rea soning LPNMR05 Lecture Notes Artiﬁcial Intelligence vol 3662 SpringerVerlag 2005 9 P Beame H Kautz A Sabharwal Towards understanding harnessing potential clause learning Journal Artiﬁcial Intelligence Research 22 2004 319351 10 C Barrett R Sebastiani S Seshia C Tinelli Satisﬁability modulo theories A Biere et al Eds Handbook Satisﬁability Frontiers Artiﬁcial Intelligence Applications vol 185 IOS Press 2009 pp 825885 Chapter 26 11 A Biere PicoSAT essentials Journal Satisﬁability Boolean Modeling Computation 4 2008 7597 12 A Biere M Heule H van Maaren T Walsh Eds Handbook Satisﬁability Frontiers Artiﬁcial Intelligence Applications vol 185 IOS Press 2009 13 G Boenn M Brain M De Vos J Fitch Automatic composition melodic harmonic music answer set programming Garcia la Banda Pontelli 2008 43 pp 160174 14 C Boutilier Ed Proceedings TwentyFirst International Joint Conference Artiﬁcial Intelligence IJCAI09 AAAI PressMIT Press 2009 15 M Brain M De Vos The signiﬁcance memory costs answer set solver implementation Journal Logic Computation 19 4 2009 615641 16 G Brewka J Lang Eds Proceedings Eleventh International Conference Principles Knowledge Representation Reasoning KR08 AAAI Press 2008 17 F Calimeri W Faber G Pfeifer N Leone Pruning operators disjunctive logic programming systems Fundamenta Informaticae 71 23 2006 183214 18 X Chen J Ji F Lin Computing loops external support rule Brewka Lang 2008 16 pp 401410 19 X Chen J Ji F Lin Computing loops external support rule disjunctive logic programs Erdem et al 2009 38 pp 130144 22 See 128115 detailed arguments fact search pattern combining backjumping conﬂictdriven assertions complete UNSAT In nutshell arguments work ranking assignments according numbers variables assigned decision level verifying sequence assignments generated search strictly monotonic Since total number variables ﬁnite sequence ﬁnite length depends heuristics Note necessitate keeping recorded conﬂict loop nogoods Rather antecedents assigned literals ultimately needed conﬂict resolution number bounded number variables M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 87 20 K Claessen N Sörensson New techniques improve MACEstyle ﬁnite model ﬁnding P Baumgartner C Fermüller Eds Proceedings Workshop Model Computation Principles Algorithms Applications MODEL03 2003 21 K Clark Negation failure H Gallaire J Minker Eds Logic Data Bases Plenum Press 1978 pp 293322 22 clasp httpwwwcsunipotsdamdeclasp 23 A Darwiche K Pipatsrisawat Complete algorithms A Biere et al Eds Handbook Satisﬁability Frontiers Artiﬁcial Intelligence Applications vol 185 IOS Press 2009 pp 99130 Chapter 3 24 M Davis G Logemann D Loveland A machine program theoremproving Communications ACM 5 1962 394397 25 M Davis H Putnam A computing procedure quantiﬁcation theory Journal ACM 7 1960 201215 26 R Dechter Constraint Processing Morgan Kaufmann Publishers 2003 27 J Delgrande W Faber Eds Proceedings Eleventh International Conference Logic Programming Nonmonotonic Reasoning LPNMR11 Lecture Notes Artiﬁcial Intelligence vol 6645 SpringerVerlag 2011 28 M Denecker J Vennekens S Bond M Gebser M Truszczy nski The second answer set programming competition Erdem et al 2009 38 pp 637654 29 N Dershowitz Z Hanna A Nadel Towards better understanding functionality conﬂictdriven SAT solver MarquesSilva Sakallah 2007 98 pp 287293 30 W Dowling J Gallier Lineartime algorithms testing satisﬁability propositional Horn formulae Journal Logic Programming 1 1984 267284 31 C Drescher M Gebser T Grote B Kaufmann A König M Ostrowski T Schaub Conﬂictdriven disjunctive answer set solving Brewka Lang 2008 16 pp 422432 32 C Drescher M Gebser B Kaufmann T Schaub Heuristics conﬂict resolution M Pagnucco M Thielscher Eds Proceedings Twelfth International Workshop Nonmonotonic Reasoning NMR08 number UNSWCSETR0819 School Computer Science Engineering The Uni versity New South Wales Technical Report Series 2008 pp 141149 33 N Eén A Biere Effective preprocessing SAT variable clause elimination F Bacchus T Walsh Eds Proceedings Eighth International Conference Theory Applications Satisﬁability Testing SAT05 Lecture Notes Computer Science vol 3569 Springer Verlag 2005 pp 6175 34 N Eén N Sörensson Temporal induction incremental SAT solving Electronic Notes Theoretical Computer Science 89 4 2003 35 N Eén N Sörensson An extensible SATsolver Proceedings Sixth International Conference Theory Applications Satisﬁability Testing SAT03 2003 pp 502518 36 N Eén N Sörensson Translating pseudoBoolean constraints SAT Journal Satisﬁability Boolean Modeling Computation 2 2006 126 37 E Ellguth M Gebser M Gusowski R Kaminski B Kaufmann S Liske T Schaub L Schneidenbach B Schnor A simple distributed conﬂictdriven answer set solver Erdem et al 2009 38 pp 490495 38 E Erdem F Lin T Schaub Eds Proceedings Tenth International Conference Logic Programming Nonmonotonic Reasoning LPNMR09 Lecture Notes Artiﬁcial Intelligence vol 5753 SpringerVerlag 2009 39 W Faber G Pfeifer N Leone Semantics complexity recursive aggregates answer set programming Artiﬁcial Intelligence 175 1 2011 278298 40 F Fages Consistency Clarks completion existence stable models Journal Methods Logic Computer Science 1 1994 5160 41 P Ferraris Answer sets propositional theories Baral et al 2005 8 pp 119131 42 J Freeman Improvements propositional satisﬁability search algorithms PhD thesis University Pennsylvania 1995 43 M Garcia la Banda E Pontelli Eds Proceedings TwentyFourth International Conference Logic Programming ICLP08 Lecture Notes Computer Science vol 5366 SpringerVerlag 2008 44 M Gebser R Kaminski B Kaufmann M Ostrowski T Schaub M Schneider Potassco The Potsdam answer set solving collection AI Communica tions 24 2 2011 105124 45 M Gebser R Kaminski B Kaufmann M Ostrowski T Schaub S Thiele A users guide gringo clasp clingo iclingo available httppotasscosourceforgenet 46 M Gebser R Kaminski B Kaufmann M Ostrowski T Schaub S Thiele Engineering incremental ASP solver Garcia la Banda Pontelli 2008 43 pp 190205 47 M Gebser R Kaminski B Kaufmann T Schaub On implementation weight constraint rules conﬂictdriven ASP solvers Hill Warren 2009 73 pp 250264 48 M Gebser R Kaminski B Kaufmann T Schaub Multicriteria optimization answer set programming J Gallagher M Gelfond Eds Technical Communications TwentySeventh International Conference Logic Programming ICLP11 Leibniz International Proceedings Informatics LIPIcs vol 11 Dagstuhl Publishing 2011 pp 110 49 M Gebser R Kaminski B Kaufmann T Schaub M Schneider S Ziller A portfolio solver answer set programming Preliminary report Delgrande Faber 2011 27 pp 352357 50 M Gebser R Kaminski B Kaufmann T Schaub B Schnor Clusterbased ASP solving claspar Delgrande Faber 2011 27 pp 364369 51 M Gebser R Kaminski A König T Schaub Advances gringo series 3 Delgrande Faber 2011 27 pp 345351 52 M Gebser B Kaufmann A Neumann T Schaub clasp A conﬂictdriven answer set solver Baral et al 2007 7 pp 260265 53 M Gebser B Kaufmann A Neumann T Schaub Conﬂictdriven answer set enumeration Baral et al 2007 7 pp 136148 54 M Gebser B Kaufmann A Neumann T Schaub Conﬂictdriven answer set solving Veloso 2007 125 pp 386392 55 M Gebser B Kaufmann A Neumann T Schaub Advanced preprocessing answer set solving M Ghallab C Spyropoulos N Fakotakis N Avouris Eds Proceedings Eighteenth European Conference Artiﬁcial Intelligence ECAI08 IOS Press 2008 pp 1519 56 M Gebser B Kaufmann T Schaub The conﬂictdriven answer set solver clasp Progress report Erdem et al 2009 38 pp 509514 57 M Gebser B Kaufmann T Schaub Solution enumeration projected Boolean search problems W van Hoeve J Hooker Eds Proceedings Sixth International Conference Integration AI OR Techniques Constraint Programming Combinatorial Optimization Problems CPAIOR09 Lecture Notes Computer Science vol 5547 SpringerVerlag 2009 pp 7186 58 M Gebser J Lee Y Lierler Elementary sets logic programs Gil Mooney 2006 69 pp 244249 59 M Gebser J Lee Y Lierler Headelementarysetfree logic programs Baral et al 2007 7 pp 149161 60 M Gebser M Ostrowski T Schaub Constraint answer set solving Hill Warren 2009 73 pp 235249 61 M Gebser T Schaub Loops Relevant redundant Baral et al 2005 8 pp 5365 62 M Gebser T Schaub Characterizing ASP inferences unit propagation E Giunchiglia V Marek D Mitchell E Ternovska Eds Proceedings First International Workshop Search Logic Answer Set Programming SAT LaSh06 2006 pp 4156 63 M Gebser T Schaub Tableau calculi answer set programming S Etalle M Truszczy nski Eds Proceedings TwentySecond International Conference Logic Programming ICLP06 Lecture Notes Computer Science vol 4079 SpringerVerlag 2006 pp 1125 64 M Gebser T Schaub S Thiele P Veber Detecting inconsistencies large biological networks answer set programming Theory Practice Logic Programming 11 23 2011 323360 88 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 65 M Gelfond Answer sets V Lifschitz F van Harmelen B Porter Eds Handbook Knowledge Representation Elsevier 2008 pp 285316 Chapter 7 66 M Gelfond N Leone Logic programming knowledge representation The AProlog perspective Artiﬁcial Intelligence 138 12 2002 338 67 M Gelfond V Lifschitz The stable model semantics logic programming R Kowalski K Bowen Eds Proceedings Fifth International Conference Symposium Logic Programming ICLP88 MIT Press 1988 pp 10701080 68 M Gelfond V Lifschitz Classical negation logic programs disjunctive databases New Generation Computing 9 1991 365385 69 Y Gil R Mooney Eds Proceedings TwentyFirst National Conference Artiﬁcial Intelligence AAAI06 AAAI Press 2006 70 E Giunchiglia N Leone M Maratea On relation answer set solvers Annals Mathematics Artiﬁcial Intelligence 53 14 2008 169204 71 E Giunchiglia Y Lierler M Maratea Answer set programming based propositional satisﬁability Journal Automated Reasoning 36 4 2006 345377 72 E Goldberg Y Novikov BerkMin A fast robust SAT solver Proceedings Fifth Conference Design Automation Test Europe DATE02 IEEE Press 2002 pp 142149 73 P Hill D Warren Eds Proceedings TwentyFifth International Conference Logic Programming ICLP09 Lecture Notes Computer Science vol 5649 SpringerVerlag 2009 74 J Huang The effect restarts eﬃciency clause learning Veloso 2007 125 pp 23182323 75 H Ishebabi P Mahr C Bobda M Gebser T Schaub Answer set vs integer linear programming automatic synthesis multiprocessor systems realtime parallel programs Journal Reconﬁgurable Computing 2009 httpwwwhindawicomjournalsijrc2009863630html 76 T Janhunen Some intranslatability results normal logic programs propositional theories Journal Applied NonClassical Logics 16 12 2006 3586 77 T Janhunen I Niemelä Compact translations nondisjunctive answer set programs propositional clauses M Balduccini T Son Eds Logic Programming Knowledge Representation Nonmonotonic Reasoning Essays Dedicated Michael Gelfond Occasion His 65th Birthday Lecture Notes Computer Science vol 6565 SpringerVerlag 2011 pp 111130 78 T Janhunen I Niemelä M Sevalnev Computing stable models reductions difference logic Erdem et al 2009 38 pp 142154 79 M Järvisalo E Oikarinen Extended ASP tableaux rule redundancy normal logic programs Theory Practice Logic Programming 8 56 2008 691716 80 T Kim J Lee R Palla Circumscriptive event calculus answer set programming Boutilier 2009 14 pp 823829 81 H Kleine Büning X Zhao Eds Proceedings Eleventh International Conference Theory Applications Satisﬁability Testing SAT08 Lecture Notes Computer Science vol 4996 SpringerVerlag 2008 82 J Lee A modeltheoretic counterpart loop formulas L Kaelbling A Saﬃotti Eds Proceedings Nineteenth International Joint Conference Artiﬁcial Intelligence IJCAI05 Professional Book Center 2005 pp 503508 83 N Leone G Pfeifer W Faber T Eiter G Gottlob S Perri F Scarcello The DLV knowledge representation reasoning ACM Transactions Computational Logic 7 3 2006 499562 84 N Leone P Rullo F Scarcello Disjunctive stable models Unfounded sets ﬁxpoint semantics computation Information Computation 135 2 1997 69112 85 C Li F Manyà MaxSAT A Biere et al Eds Handbook Satisﬁability Frontiers Artiﬁcial Intelligence Applications vol 185 IOS Press 2009 pp 613631 Chapter 19 86 Y Lierler Abstract answer set solvers learning Theory Practice Logic Programming 11 23 2011 135169 87 V Lifschitz Answer set programming plan generation Artiﬁcial Intelligence 138 12 2002 3954 88 V Lifschitz A Razborov Why loop formulas ACM Transactions Computational Logic 7 2 2006 261268 89 V Lifschitz L Tang H Turner Nested expressions logic programs Annals Mathematics Artiﬁcial Intelligence 25 34 1999 369389 90 F Lin Y Zhao ASSAT Computing answer sets logic program SAT solvers Artiﬁcial Intelligence 157 12 2004 115137 91 Z Lin Y Zhang H Hernandez Fast SATbased answer set solver Gil Mooney 2006 69 pp 9297 92 M Luby A Sinclair D Zuckerman Optimal speedup Las Vegas algorithms Information Processing Letters 47 4 1993 173180 93 V Marek V Subrahmanian The relationship stable supported default autoepistemic semantics general logic programs Theoretical Computer Science 103 2 1992 365386 94 V Marek M Truszczy nski Stable models alternative logic programming paradigm K Apt V Marek M Truszczy nski D Warren Eds The Logic Programming Paradigm A 25Year Perspective SpringerVerlag 1999 pp 375398 95 M Mariën J Wittocx M Denecker M Bruynooghe SATID Satisﬁability propositional logic extended inductive deﬁnitions Kleine Büning Zhao 2008 81 pp 211224 96 J MarquesSilva I Lynce S Malik Conﬂictdriven clause learning SAT solvers A Biere et al Eds Handbook Satisﬁability Frontiers Artiﬁcial Intelligence Applications vol 185 IOS Press 2009 pp 131153 Chapter 4 97 J MarquesSilva K Sakallah GRASP A search algorithm propositional satisﬁability IEEE Transactions Computers 48 5 1999 506521 98 J MarquesSilva K Sakallah Eds Proceedings Tenth International Conference Theory Applications Satisﬁability Testing SAT07 Lecture Notes Computer Science vol 4501 SpringerVerlag 2007 99 A Mileo D Merico R Bisiani A logic programming approach home monitoring risk prevention assisted living Garcia la Banda Pontelli 2008 43 pp 145159 100 D Mitchell A SAT solver primer Bulletin European Association Theoretical Computer Science 85 2005 112133 101 M Moskewicz C Madigan Y Zhao L Zhang S Malik Chaff Engineering eﬃcient SAT solver Proceedings ThirtyEighth Conference Design Automation DAC01 ACM Press 2001 pp 530535 102 I Niemelä Logic programs stable model semantics constraint programming paradigm Annals Mathematics Artiﬁcial Intelli gence 25 34 1999 241273 103 I Niemelä Stable models difference logic Annals Mathematics Artiﬁcial Intelligence 53 14 2008 313329 104 R Nieuwenhuis A Oliveras C Tinelli Solving SAT SAT modulo theories From abstract DavisPutnamLogemannLoveland procedure DPLLT Journal ACM 53 6 2006 937977 105 S Perri F Scarcello G Catalano N Leone Enhancing DLV instantiator backjumping techniques Annals Mathematics Artiﬁcial Intelli gence 51 24 2007 195228 106 D Pearce A new logical characterisation stable models answer sets J Dix L Pereira T Przymusinski Eds Proceedings Sixth Workshop NonMonotonic Extensions Logic Programming NMELP96 Lecture Notes Computer Science vol 1216 SpringerVerlag 1996 pp 5770 107 K Pipatsrisawat A Darwiche A lightweight component caching scheme satisﬁability solvers MarquesSilva Sakallah 2007 98 pp 294 299 108 K Pipatsrisawat A Darwiche A new clause learning scheme eﬃcient unsatisﬁability proofs D Fox C Gomes Eds Proceedings TwentyThird National Conference Artiﬁcial Intelligence AAAI08 AAAI Press 2008 pp 14811484 M Gebser et al Artiﬁcial Intelligence 187188 2012 5289 89 109 K Pipatsrisawat A Darwiche On power clauselearning SAT solvers resolution engines Artiﬁcial Intelligence 175 2 2011 512525 110 Potassco httppotasscosourceforgenet 111 P Purdom A transitive closure algorithm BIT Numerical Mathematics 10 1970 7694 112 F Ricca W Faber N Leone A backjumping technique disjunctive logic programming AI Communications 19 2 2006 155172 113 F Rossi P van Beek T Walsh Eds Handbook Constraint Programming Elsevier 2006 114 O Roussel V Manquinho PseudoBoolean cardinality constraints A Biere et al Eds Handbook Satisﬁability Frontiers Artiﬁcial Intelligence Applications vol 185 IOS Press 2009 pp 695733 Chapter 22 115 L Ryan Eﬃcient algorithms clauselearning SAT solvers Masters thesis Simon Fraser University 2004 116 V Ryvchin O Strichman Local restarts Kleine Büning Zhao 2008 81 pp 271276 117 J Schlipf The expressive powers logic programming semantics Journal Computer System Sciences 51 1995 6486 118 L Schneidenbach B Schnor M Gebser R Kaminski B Kaufmann T Schaub Experiences running parallel answer set solver Blue Gene M Ropo J Westerholm J Dongarra Eds Proceedings Sixteenth European PVMMPI Users Group Meeting Recent Advances Parallel Virtual Machine Message Passing Interface PVMMPI09 Lecture Notes Computer Science vol 5759 SpringerVerlag 2009 pp 6472 119 P Simons I Niemelä T Soininen Extending implementing stable model semantics Artiﬁcial Intelligence 138 12 2002 181234 120 T Syrjänen Lparse 10 users manual httpwwwtcshutﬁSoftwaresmodelslparsepsgz 121 R Tarjan Depthﬁrst search linear graph algorithms SIAM Journal Computing 1 2 1972 146160 122 M Thielscher Answer set programming singleplayer games general game playing Hill Warren 2009 73 pp 327341 123 G Tseitin On complexity derivation propositional calculus A Slisenko Ed Structures Constructive Mathematics Mathematical Logic 2 Consultants Bureau 1970 pp 115125 124 A Van Gelder K Ross J Schlipf The wellfounded semantics general logic programs Journal ACM 38 3 1991 620650 125 M Veloso Ed Proceedings Twentieth International Joint Conference Artiﬁcial Intelligence IJCAI07 AAAI PressMIT Press 2007 126 J Ward J Schlipf Answer set programming clause learning V Lifschitz I Niemelä Eds Proceedings Seventh International Conference Logic Programming Nonmonotonic Reasoning LPNMR04 Lecture Notes Artiﬁcial Intelligence vol 2923 SpringerVerlag 2004 pp 302 313 127 L Zhang C Madigan M Moskewicz S Malik Eﬃcient conﬂict driven learning Boolean satisﬁability solver Proceedings International Conference ComputerAided Design ICCAD01 2001 pp 279285 128 L Zhang S Malik Validating SAT solvers independent resolutionbased checker Practical implementations applications Proceedings Sixth Conference Design Automation Test Europe DATE03 IEEE Press 2003 pp 1088010885