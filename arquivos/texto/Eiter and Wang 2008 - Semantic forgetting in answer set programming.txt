Artiﬁcial Intelligence 172 2008 16441672 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Semantic forgetting answer set programming Thomas Eiter Kewen Wang b1 Institut für Informationssysteme Technische Universität Wien Favoritenstraße 911 A1040 Vienna Austria b School Information Communication Technology Griﬃth University Brisbane QLD 4111 Australia r t c l e n f o b s t r c t Article history Received 3 November 2007 Received revised form 6 May 2008 Accepted 24 May 2008 Available online 29 May 2008 Keywords Answer set programming Nonmonotonic logic programs Knowledge representation Forgetting Computational complexity The notion forgetting known variable elimination investigated extensively context classical logic nonmonotonic logic program ming nonmonotonic reasoning The approaches exist based syntactic modiﬁcations program hand In paper establish declarative theory forgetting disjunctive logic programs answer set semantics fully based semantic grounds The suitability theory justiﬁed number desirable properties In particular results shows notion forgetting entirely captured classical forgetting We present algorithms computing representation result forgetting provide characterization computational complexity reasoning logic program forgetting As applications approach present fairly general framework resolving conﬂicts inconsistent knowledge bases represented disjunctive logic programs semantics inheritance logic programs update logic programs literature characterized forgetting The basic idea conﬂict resolution framework weaken preferences agent forgetting certain knowledge causes inconsistency In particular use notion forgetting provide elegant solution preference elicitation disjunctive logic programming 2008 Published Elsevier BV 1 Introduction For intelligent agents ability discard irrelevant information recognized important feature mastered humans received broad attention artiﬁcial intelligence cognitive computational perspective In area knowledge representation ability referred forgetting 49 variable elimina tion 9 studied different names including irrelevance independence irredundancy novelty separability 3463 details Forgetting root Boolean Algebra 6 fundamental reasoning process CI Lewis 41 pointed purposes application Boolean logic commonsense reasoning eliminationforgetting process important solution2 processes reasoning place elimination middle variables Boole writes middle variables usually happens commonsense reasoning especially premises elements premises required appear conclusion Preliminary versions paper results presented AAAI 2006 NMR 2006 Corresponding author Email addresses eiterkrtuwienacat T Eiter kwanggriﬃtheduau K Wang 1 Part work author visiting Technische Universität Wien 2 In 41 problem formulated Boolean equation solution Boolean equation corresponds solution given problem In particular solving Boolean equation treated process eliminatingforgetting variables represent unknowns 00043702 matter 2008 Published Elsevier BV doi101016jartint200805002 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1645 Forgetting applications investigated extensively context classical logic example 53436 3749555667 nonmonotonic logic programming reasoning In context ﬁrst considered 7071 types forgettingstrong weak forgettinghave deﬁned ﬁrst transforming logic program P reduced form deleting rules literals While approach works number cases major drawbacks First semantic underpinning fully clear Speciﬁcally relationship intended semantics logic program terms answer sets result syntactic transformations carried strong weak forgetting unclear Second approach address desirable properties reasonable notion forgetting nonmonotonic logic programming In particular ask difference notions forgetting traditional approaches deletion rulesliterals logic programming databases A aspect strong weak forgetting syntaxsensitive programs semantically equiva lent different results forgetting literal For example programs P p q p Q p equivalent answer set semantics Weak forgetting p P yields program WForgetLPP p q Q program WForgetLPQ p clearly programs equivalent While role syntax logic programming respect reading rules classical logic wellacknowledged argue relative semantics syntax equivalent programs behave way In particular example result forgetting p P Q yield semantically result note answer set semantics second rule P redundant A similar phenomenon observed strong forgetting Consider P q p q q Q q Then programs equivalent answer set semantics However results strong forgetting p P Q SForgetLPP p q q SForgetLPQ p q respectively obviously equivalent The discrepancy noticeable result strong forgetting atom consistent program inconsistent Thus alternative notion forgetting nonmonotonic logic programming highly desirable In paper choose answer set programming ASP 44 underlying nonmonotonic logic ASP new paradigm logic programming answer set semantics 29 major tool knowledge representation reasoning simplicity expressive power connection major nonmonotonic logics A number eﬃcient ASP solvers DLV Smodels ASSAT Cmodels Clasp available 3 handle large problem instances Prior deﬁning notion forgetting nonmonotonic logic programming pose question desirable properties reasonable theory forgetting The following ones appear natural candidates Let P logic program let P result forgetting literal l P cid4 F1 The proposed notion forgetting natural generalization relate forgetting classical logic vocabulary stays F2 No new symbols introduced P F3 The reasoning P F4 The result forgetting sensitive syntax results forgetting l semantically equivalent equivalent reasoning P l ignored cid4 cid4 programs semantically equivalent F5 The semantic notion forgetting coupled syntactic counterpart effective constructible syntax representing result forgetting cid4 Property F1 speciﬁes major intuition forgetting clariﬁes difference forgetting deletion F2 necessary forgetting eliminate symbols forgotten This difference forgetting approaches revision update deletion 110161931 note combine forgetting ap proaches adding new information different issue Property F3 provides semantic justiﬁcation forgetting Note P P different answer sets general Proposition 1 F4 guarantees notion forget ting semantically welldeﬁned Finally property F5 useful applications forgetting knowledge representation To best knowledge theory forgetting nonmonotonic reasoning logic programming based criteria notice properties F3 F4 hold weak strong forgetting 7071 Section 7 discussion However deﬁnition forgetting classical logic directly adapted logic programming cf Section 31 The main contributions present paper follows We establish declarative semantically deﬁned notion forgetting disjunctive logic programs answer set se mantics called semantic forgetting The suitability semantic forgetting justiﬁed number desirable properties including ones given As notion forgetting naturally captures classical forgetting As exploited reasoning forgetting literal logic program resorting representations nonmonotonic logic program terms classical logic 395051 As property consistent disjunctive program P literal l syntactic representation forgetP l forgetting l P terms nonmonotonic logic program exists Besides semanticsbased algo rithms computing representation present transformationbased algorithm This algorithm allows obtain result forgetting literal l P series program transformations rewritings 1646 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 In connection algorithms characterize computational complexity major reasoning tasks logic programs forgetting literal As turns model checking credulous reasoning forget ting literal logic program complex standard setting level polynomial hierarchy skeptical reasoning complexity These results provide useful insights feasible rep resentations forgetting suggest polynomialsize result forgetting feasible This stronger results established applying theory Cadoli et al 1213 As application approach present fairly general framework resolving conﬂicts inconsistent knowl edge bases The basic idea framework weaken preferences agent forgetting subgoals cause inconsistency In particular use notion forgetting provide elegant solution preference elicitation ASP Furthermore inheritance programs 10 update programs 1819 fragments dynamic programs 12 characterized terms semantic forgetting While paper focus nonmonotonic logic programs basic ideas underlying approach semantic forgetting applied known formalisms nonmonotonic reasoning default logic 60 au toepistemic logic 57 nonmonotonic logic programs answer set semantics seen particular fragments In fact formalisms extend classical logic notion forgetting complies classical forgetting based semantics needed Our results provide benchmark approaches forgetting formalisms nonmonotonic reasoning remain developed The rest paper organized follows Section 2 brieﬂy recalls basics disjunctive logic programs answer sets Section 3 deﬁnes notion forgetting ASP shows important properties relates classical forgetting independence 34 Thereafter Section 4 presents algorithms computing result forgetting ASP Section 5 studies complexity issues Section 6 presents applications conﬂict resolution multiagent systems inheritance logic programs logic program updates The ﬁnal Section 7 concludes work 2 Preliminaries We brieﬂy review basic deﬁnitions notation answer set programming paper A disjunctive logic program simply logic program ﬁnite set rules form a1 b1 bm c1 cn 1 s m n cid2 0 ai b j ck set Lit classical literals propositional language We assume ai pairwise distinct similarly b j ck A literal positive literal p negative literal p atom p For atom p p p called complementary For literal l complementary literal denoted l Given rule r form 1 headr a1 bodyr body r c1 cn body r q q body r b1 bm r Occasionally abuse notation view headr r body r body body set a1 A rule r form 1 normal nondisjunctive s cid3 1 positive n 0 negative m 0 constraint s 0 fact m 0 n 0 The rule s n m 0 constant false A logic program P called normal resp positive negative rule P normal resp positive negative We denote Lit P Lit literal base logic program P set literals occurring P Unless stated clear context Lit implicitly given Lit P An interpretation set literals X Lit contains pair complementary literals A disjunction a1 satisﬁed X denoted X cid9 a1 ai X 1 cid3 cid3 s A rule r satisﬁed X denoted X cid9 r X cid9 headr body r X hold Furthermore X model P denoted X cid9 P X cid9 r rule r P A model X P minimal model P model X r X body cid4 X implies X cid4 X P X cid4 The semantics logic program P deﬁned terms answer sets 30 follows Given interpretation X r X Then X answer set P X r r P body reduct P X deﬁned P X headr body minimal model P X By ASP denote collection answer sets P A logic program P zero multiple answer sets P consistent answer set It cid4 ASP X X cid4 implies X X cid4 known answer sets logic program P incomparable X X Example 1 Let P logic program consisting following rules b c d d b Then P answer sets X1 d X2 b d Obviously X1 X2 incomparable Two logic programs P P cid4 equivalent denoted P P cid4 ASP ASP cid4 P P cid4 answer T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1647 sets By P cid9s l P cid9c l denote skeptical credulous consequence literal l logic program P respectively P cid9s l iff l S S ASP P cid9c l iff l S S ASP 3 Forgetting logic programming In section deﬁne means forget literal l logic program P The idea obtain logic program contain l equivalent original logic program ignore existence literal l We believe forgetting syntactic removal rulesliterals close classical forgetting answer set semantics keeping spirit time Thus deﬁnition forgetting section given semantics terms based answer sets 31 Deﬁnition semantic forgetting In classical propositional logic result forgetting forgetT p proposition p ﬁnite theory T veniently deﬁned T ptrue T pfalse T ptrue T pfalse obtained taking conjunction sentences T replacing occurrences p true false respectively This method directly gen eralized logic programming notion disjunction logic programs However look forgetting modeltheoretic perspective obtain models forgetT p follows compute ﬁrst 2 valued models T remove p model contains p The resulting collection sets M p M cid9 T exactly set models forgetT p Similarly given consistent logic program P literal l naively deﬁne result forgetting l answer sets exactly ASP l X l X ASP However notion P logic program P simple programs For example consider P p q forgetting guarantee existence P Here ASP p q ASP p q Since q known answer sets incomparable set inclusion ASP p set answer sets logic program cid4 cid4 A solution problem suitable notion minimal answer set deﬁnition answer sets minimality cid4 l X l cid4 l X X literals lequivalent forgetting fruitfully combined To end set X Similarly set X cid4 denoted X l X cid4 l X l Two sets X X strict lsubset X denoted X lsubset set X denoted X cid4 l X X l X cid4 l X X X cid4 cid4 cid4 cid4 Deﬁnition 1 lAnswer Set Let P consistent logic program let l literal Lit P let X Lit P set literals 1 For collection S sets literals X S lminimal X cid4 S X cid4 l X By minlS denote collection lminimal elements S 2 An answer set X logic program P lanswer set X lminimal ASP By ASlP denote set lanswer sets P For example P p q answer sets X p X cid4 q X panswer set P X cid4 This example shows logic program P literal l answer set lanswer set The sets ASlP l X l X ASlP incomparable ﬁnd logic program collection answer sets Note achieve incomparability select answer sets minimal ASP l maximal ones However selecting minimal answer sets line guiding principle logic programming nonmonotonic reasoning minimize positive information Note deﬁnition P assumed consistent ASP cid15 If logic program inconsistent result forgetting clear possibility removing inconsistency logic program considered For example logic program P partial stable models 61 inconsistent answer set semantics stable model semantics Forgetting inconsistent programs interesting issue consider In rest paper assume P consistent logic program The following proposition collects easy properties lanswer sets Proposition 1 For consistent program P literal l Lit P following holds 1 Every lanswer set X P answer set P 2 For answer set X P exists lanswer set X 3 Every answer set X P l X lanswer set P 4 If answer set X P lanswer set P exists lanswer set Y P l Y Y l X 5 If l Lit P X lanswer set P iff X answer set P P X cid4 l X cid4 1648 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 Having notion minimality forgetting literal position deﬁne result forgetting literal logic program Deﬁnition 2 Semantic forgetting Let P consistent logic program l literal A logic program P result forgetting l P cid4 represents 1 Lit P cid4 Lit P l l occur P cid4 cid4 ASlP l set X 2 ASP cid4 literals l X set X P X cid4 l X cid4 cid4 X answer set P cid4 iff exists lanswer We use forgetP l generic notation logic program representing result forgetting l P An important difference notion forgetting existing approaches updating merging logic pro grams cf 110161931 merely l possibly literals removed However new symbols introduced P cid4 For consistent logic program P program P deﬁnition exists cf Algorithm 2 details cid4 However P unique It follows deﬁnition equivalent answer set semantics cid4 Proposition 2 Let P consistent logic program let l Lit P literal If P P equivalent P cid4cid4 cid4 cid4 cid4cid4 P results forgetting l P Before properties forgetting explored Section 32 let look example programs Example 2 1 If P 1 q p forgetP 1 q answer set forgetP 1 p answer set q A possible rep resentation forgetP 1 p obtained P 1 removing p rule q p forgetP 1 q removing rule q p 2 If P 2 q p p q forgetP 2 p answer set represented pro gram Indeed P 2 answer sets p q p panswer set P 2 Similarly forgetP 2 q answer set 3 Consider P 3 q p p single answer p Thus forgetP 3 p answer set represented program q This intuitive forgetting impacts p P 3 In particular forgetting p different assuming p From examples guess program forgetP p obtained simply removing rules andor literals head p andor positive body literal p removing p remaining rules However example shows true general 4 Let P 4 b b p c p According 71 result weak forgetting p P 4 program WForgetLPP 4 p b b c result strong forgetting p P 4 program SForgetLPP 4 p b b Neither fully intuitive c depends means double negation WForgetLPP 4 p SForgetLPP 4 p connection c lost In contrast forgetP 4 p answer sets b c connection c equivalence double negation p maintained Syntactically forgetP 4 p represented program b b c instance connection maintained rule c 5 P 5 p q p c q single answer set q c Here p involved unstratiﬁed negation false answer set Thus forgetP 5 p answer set P 5 syntactic representation program q c intuitively results pushing possible value p simplifying program 6 Let P 6 p b c p b This program single answer set b c atom p involved cyclic negation Forgetting p P 6 change answer set possible program forgetP 6 p c b corresponds simpliﬁed version program P 6 results pushing value p note ﬁrst rule P 6 applicable We discuss obtain concrete program forgetP l section 32 Basic properties forgetting In subsection present properties forgetting First number answer sets increase Proposition 3 Let P consistent logic program Then literal l Lit P holds ASforgetP l cid3 ASP T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1649 This simple consequence fact answer sets P lanswer sets Note property compliant principle closing world eliminating possibilities favor default case The following proposition generalizes Proposition 2 Proposition 4 Let P P forgetP cid4 l equivalent cid4 consistent logic programs l literal P If P P cid4 equivalent forgetP l However forgetting preserve special equivalences logic programs stronger ordinary equiv alence like strong equivalence 45 uniform equivalence 1720 We recall programs P Q strongly equivalent ﬁnite set rules R programs P R Q R answer sets uniformly equivalent holds set facts R We forgetting preserves equivalence X logic programs logic programs Q Q cid4 l Here X strong equivalence uniform equivalence literal l Q X Q equivalence relation collection disjunctive logic programs implies forgetQ l X forgetQ cid4 cid4 An equivalence relation X logic programs Lit invariant literal extensions following holds wrt programs Lit P Lit P cid4 Lit l Lit new literal P X P wrt Lit iff P X P cid4 cid4 cid4 P P Lit l An equivalence X stronger ordinary equivalence following conditions satisﬁed P X P 1 For programs P P cid4 2 There exist programs P P cid4 cid4 cid4 implies P P P P cid4 P cid15 X P cid4 Proposition 5 Let X equivalence relation collection logic programs Lit stronger ordinary equivalence invariant literal extensions Then forgetting preserve X Both strong uniform equivalence 1745 clearly stronger ordinary equivalence clearly invariant literal extensions Hence preserved deﬁnition forgetting introduced This consequence freedom arbitrarily instantiate generic program forgetP l For speciﬁc realizations forgetP l strong uniform equivalence preserved forgetting example realizations forget1P l forget2P l Section 4 property A suitable notion forgetting preserves strong equivalence interesting applications scope paper An issue related possible deﬁnition forgetting terms consequence relation logic programs analogy deﬁning forgetting classical context 34 strongest program consequence given program P independent literal l forgotten This requires suitable notions consequence dependence straightforward The depend application purpose logic program query answering representing solutions problem answer sets according ASP paradigm Furthermore answer set semantics monotonic simple consequence operator cid9 rule rule bases P cid9 Q P cid9 r rule r Q suitable For example rule p p true answer sets P p vice versa p true answer sets Q p p P Q equivalent different answer sets This problem overcome consequence operator SEconsequence equivalently Logic HereandThere 45 UEconsequence 20 Also notion independence literal logic program deﬁned different ways An obvious notion syntactic independence given l occur P However semantic notions independence conceivable deﬁned terms forgetting discuss Section 64 cid4 Q S S Technically reconstruct notion forgetting logic program terms syntactic independence following consequence relation logic programs P cid9 Q answer set S P exists answer Clearly cid9 reﬂexive transitive P cid9 Q Q cid9 P implies P Q set S answer sets Then hard strongest program Q literals Lit P l P cid9 Q represents forgetP l We leave issue program Q deﬁning forgetting notions consequence investigation Lit P l P cid9 Q holds Q cid9 Q cid4 cid4 cid4 cid4 The following proposition summarizes simple helpful properties forgetting Proposition 6 For consistent program P literal l Lit P following holds 1 ASforgetP l X l X ASlP 2 If X ASlP l X X ASforgetP l 3 For X ASP l X X l ASforgetP l cid4 l ASP 4 For X 5 For X ASP exists X 6 If l appear P forgetP l P cid4 ASforgetP l X cid4 ASforgetP l X X cid4 cid4 X 1650 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 The proposition says forgetting literal logic program resulting program equivalent original skeptical reasoning weaker credulous reasoning inferences lost Proposition 7 Let P consistent logic program let l l cid4 literals Lit P l cid4 cid15 l Then cid4 1 P cid9s l 2 P cid9c l cid4 iff forgetP l cid9s l cid4 forgetP l cid9c l cid4 The deﬁnition forgetting single literal l logic program P straightforwardly extended set F literals We similarly deﬁne X1 F X2 X1 F X2 F answer sets logic program properties forgetting single literal generalized setting Furthermore result forgetting set F obtained forgetting literals F Proposition 8 Let P consistent logic program let F l1 lm set literals Then cid2 forgetP F forget cid2 forgetP l1 l2 forget cid3 lm cid3 Notice particular indexing literals F matter This result allows reduce forgetting basic operation single literal useful proof given Appendix A requires technicalities We remark removing proposition p entirely program P suggestive remove literals p p P positive negative information p This easily accomplished forgetP p p Let consider simple logic program contains pair complementary literals Example 3 Let P following logic program ﬂiesTweety pigeonTweety ﬂiesTweety penguinTweety pigeonTweety penguinTweety This program answer sets pigeonTweety ﬂiesTweety penguinTweety ﬂiesTweety If forget ﬂiesTweety ﬂiesTweety complementary literal result forgetting For stance forgetP ﬂiesTweety answer sets pigeonTweety penguinTweety ﬂiesTweety second contains ﬂiesTweety possible program representing forgetP ﬂiesTweety ﬂiesTweety penguinTweety pigeonTweety penguinTweety However Proposition 8 forgetforgetP ﬂiesTweety ﬂiesTweety forgetforgetP ﬂiesTweety ﬂiesTweety equivalent answer sets pigeonTweety penguinTweety represented program pigeonTweety penguinTweety 33 Relation classical forgetting We consider relationship classical forgetting forgetT p logic programming forgetting forgetP p Besides stable answer set semantics 2830 inﬂuential semantics nonmonotonic logic programming Clarkes completion semantics 14 deﬁnes semantics logic programs terms classical logic It known answer set completion semantics different general For example logic program P p q q p unique answer set However Clarkes completion P gives p q models p q Lin Zhao 5051 showed answer set semantics logic program characterized simple extension Clarkes program completion adding called loop formulas They consider normal logic programs contain constraints This approach allows compute answer sets normal logic program classical SAT solver Lee Lifschitz 39 extended characterization class disjunctive logic programs For simplicity assume subsection programs strong negation compiled away standard way usual For logic program P completion compP set propositional formulas containing bodyr headr rule r P formula rP aheadrbodyr cid4 cid5 pheadra p atom Here headr L set atoms L head set atoms occur headr L comma rule bodies translated negation conjunction classical propositional logic respectively An head headr translated T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1651 Given logic program P positive dependency graph G P directed graph vertices atoms occurring P edge p q iff exists rule r P p headr q body r A nonempty set L p1 pk atoms loop P distinct pi p j L exists path nonzero length pi p j G P vertices path belong L The conjunctive loop formula L CLFL p1 pk cid6 cid7 cid8 φ φRL RL set formulas bodyr p rules r P headr L cid15 body r L For example L p q loop logic program P r p q q p In example RL right hand CLFL disjunction Thus CLFL propositional formula p q Let lcompP compP CLFP CLFP set loop formulas A fundamental result established Lin Zhao 50 shows generalized completion lcompP exactly characterizes answer set semantics This extended disjunctive logic programs Lee Lifschitz 39 follows cid5 pheadrL Theorem 1 See 39 Let P disjunctive logic program let X Lit P set atoms Then X answer set P iff X model lcompP Since L p q loop P r p q q p CLFP p q Since compP r q q p q r q p obtain simpliﬁcations lcompP p q r p r q r p q This theory exactly model unique answer set P It easy lcompP compP P negative Hence Corollary 2 Let Q negative program strong negation let X Lit P set literals Then X answer set Q X model compQ This corollary special case previous results 426 Since logic program P atom p classical theories lcompforgetP p forgetlcompP p formed logic programming forgetting applied P classical forgetting theory lcompP natural question theories related Intuitively models ﬁrst theory incomparable models second theory For example let P p q q p Then lcompforgetP p q single model forgetlcompP p T q F q T comparable models q However minimal models forgetlcompP p models lcompforgetP p In fact holds general Theorem 3 Let P consistent disjunctive logic program let p Lit P atom Then X Lit P answer set forgetP p iff X minimal model forgetlcompP p That cid3 cid2 forgetlcompP p cid3 cid2 forgetP p MMod AS MModT denotes set minimal models wrt theory T classical logic The proof theorem given Appendix A We remark Lang et al considered 34 notion forgetting literal l formula T classical logic semantically deﬁned forgetT l T pα l T pα α cid21 l p positive α l p negative Note forgetting atom p literal stronger forgetting p propositional variable general forgetting p p literal yields p variable yields cid21 It easy Theorem 3 remains valid notion literal forgetting The result Theorem 3 means forgetP p characterized forgetting classical If use forgetminT p denote set classical formulas models minimal models classical forgetting forgetT p equation Theorem 3 reformulated logic cid2 forgetP p cid3 lcomp forgetmin cid2 lcompP p cid3 denotes classical equivalence This result graphically represented commutative diagram Fig 1 It useful implies bypass use logic programming engine entirely represent answer sets forgetP p frameworks circumscription closed world reasoning 274354 This applying circumscription lcompP explain In circumscription minimality understood impossibility making context predicate logic extent predicates p1 pk circumscribed theory T smaller changing extent predi cates Furthermore predicates z1 zl allowed vary process minimizing p1 pk needed applications As concern propositional logic pi z j atoms CircT cid22p cid22z propositional formula quantiﬁers atoms semantically captures circumscription ﬁnite theory T 1652 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 Fig 1 Commuting logic program completion forgetting Algorithm forget1P l Input Consistent disjunctive logic program P literal l P Output A normal logic program representing forgetP l Method Step 1 Compute ASP ASP solver DLV gnT Step 2 Remove l set ASP denote resulting collection Acid4 Step 3 Obtain Acid4cid4 Step 4 Construct P removing nonminimal sets Acid4 cid4 answer sets exactly Acid4cid4 A1 Am For Ai let P l cid4 P 1 Pn Let P cid4 Ai l cid4 Ai Ai Lit P Ai Step 5 Output P cid4 forgetP l Fig 2 Algorithm forget1P l respect cid22p p1 pk cid22z z1 zl As known CircT cid22p cid22z logically equivalent Gelfond et als extended closed world assumption ECWAT cid22p cid22z 27 augments T additional formulas Let write CircT z respectively ECWAT z case cid22z contains single atom z cid22p atoms cid4 z M Then M model CircT z respectively ECWAT z exactly M zminimal model T sense M implies M T We following result cid4 z M model M cid4 Theorem 4 Let P consistent disjunctive logic program let p Lit P atom Then X Lit P p answer set forgetP p X X p model CirclcompP p resp ECWAlcompP p A proof given Appendix A By intuitive result exploit circumscription engines reasoning forgetP p3 feed loop completion lcompP P Note exploited ASP solvers viz ASSAT Cmodels stepping stone compute answer sets classical forgetting p lcompP performed eﬃciently formula lcompP pcid21 lcompP p represents classical forgetting forgetlcompP p lcompP viewed single formula pα denotes substitution p α computable linear time On hand lcompP exponential size P general P exponentially loops Section 433 discussion size lcompP 4 Computation forgetting As noted forgetP l exists consistent logic program P literal l In section discuss issues computing result forgetting 41 Naive algorithm By Deﬁnition 2 easily obtain naive algorithm computing forgetP l ASP solver logic programs like DLV 40 GnT 33 shown Fig 2 It known collection S sets consistent literals pairwise incomparable represented logic program P ASP S In fact P constructed S polynomial time Algorithm forget1P l sound complete wrt forgetting Deﬁnition 2 Theorem 5 Given consistent disjunctive logic program P literal l Algorithm forget1P l outputs correct representation forgetP l 3 Eg circ2dlp httpwwwtcshutﬁSoftwarecirc2dlp circum1 circum2 httpwwwailabseshibauraitacjpcircumscriptionhtml T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1653 Algorithm forget2P l Input Consistent disjunctive logic program P literal l P Output A normal logic program representing forgetP l Method Step 1 Let P 1 P l Compute answer sets P 1 DLV gnT Remove l obtained answer set Let A1 resulting collection sets Each set A1 answer set forgetting l P Step 2 Let P 2 P l a1 ak a1 ak A1 Compute answer sets P 2 DLV gnT let A2 result Set A A1 A2 Step 3 Construct P cid4 answer sets exactly A A1 Am For Ai let P l cid4 P 1 Pn Let P cid4 Ai l cid4 Ai Ai Lit P Ai Step 4 Output P cid4 forgetP l Fig 3 Improvement Algorithm forget1P l The Step 2 return answer sets Acid4 minimal fact easy ﬁnd examples Acid4 contains exponentially sets minimal For example let P p q ai bi q 1 cid3 cid3 n Then P single pminimal answer set p exponentially answer sets q l1 ln li ai bi lead nonminimal sets Acid4 To avoid problem present improved version Algorithm forget1P l subsection 42 Improved algorithm An improved version Algorithm forgetP l shown Fig 3 pushes task minimality checking candidate lanswer sets P constraint satisﬁability augmented program It exploits way constraint solving capabilities offered ASP solvers Since answer sets P cid4 exactly A Algorithm forget2P l sound complete wrt semantic forgetting Theorem 6 For consistent disjunctive logic program P literal l Algorithm forget2P l outputs correct representation forgetP l The advantage Algorithm forget2P L strategy Steps 1 2 makes lminimization obsolete blowup large intermediate result respect number answer sets Algorithm forget1P l large compared small program representing forgetP l fact happen Still resulting program P exponentially larger constructed P means refer discussion Algorithm forget3P l In subsection discuss construct representation forgetP l syntactic manner program transformations cid4 However semantic constructions forget1P l forget2P l advantage clearly preserve equivalence logic programs notion equivalence X logic programs stronger ordinary equivalence particular strong weak equivalence This simple consequence fact programs P ordinarily equivalent output forget1P l similarly forget2P l 43 Transformationbased algorithm The algorithm forget1P l forget2P l based semantic view forgetting aim computing result forgetting syntaxoriented manner modifying rules P In subsection present algorithm forget3P l kind based program transformations This algorithm outputs differently forget1P l forget2P l ordinary logic programs logic programs literals double negation failure They inherit semantics general class nested logic programs 46 Before presenting algorithm forget3P l need preliminaries program transformations programs double negation failure 1654 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 431 Basic program transformations We start recalling program transformations discussed 866 More precisely consider following collection T program transformations Elimination Tautologies P r body body cid4 obtained P elimination tautologies rule r headr r P headr body r cid15 P cid4 P r Example 4 Let P 1 consist following rules p p q1 p p1 q1 p1 q p2 q1 p2 q r1 p p1 p1 r2 r3 r4 r5 r6 p q1 r7 p1 p3 r8 p3 p p Then r2 tautology P 2 r1 r3 r4 r5 r6 r7 r8 obtained P elimination tautologies Elimination Head Redundancy P cid4 literal l headr body disjunction obtained removing l headr obtained P elimination head redundancy rule r P cid4 P r headr l bodyr Here headr l r P By elimination head redundancy r1 simpliﬁed r cid4 r 1 r3 r4 r5 r6 r7 r8 The transformations guarantee rules head body common literals removed p p1 P 2 transformed P 3 cid4 1 Positive Reduction P obtained P positive reduction rule r headr body cid4 r body P c body P r headr body r c headP P r body r c Here headP cid9 cid4 rP headr obtained P removing c r That P r cid4 cid4 cid4 P 4 r 4 r 1 r3 r cid4 5 q1 p2 p1 r cid4 5 r6 r7 r8 obtained P 3 r cid4 1 r3 r4 r5 r6 r7 r8 positive reduction r cid4 4 rule Negative Reduction P cid4 cid4 r headr obtained P negative reduction rules r headr body cid4 P headr r P cid4 P r cid4 body r body r In example P 5 r3 r For deﬁning program transformation need notion implications rules deﬁned 8 We r cid4 5 r6 r7 r8 obtained P 4 negative reduction r r cid4 1 r cid4 r cid4 4 r cid4 4 implication r headr headr cid4 bodyr bodyr cid4 inclusions strict cid4 Elimination Implications P obtained P elimination implications distinct rules r r cid4 P r implication r P cid4 P r cid4 cid4 cid4 In example r7 implication r implications cid4 4 P 6 r3 r cid4 4 r cid4 5 r6 r8 obtained P 5 elimination Elimination Contradictions P body r body r cid15 P cid4 P r cid4 obtained P elimination contradictions rule r P By elimination contradictions r8 removed P 6 obtain P 7 r3 r cid4 4 r cid4 5 r6 Unfolding P cid4 obtained P unfolding rule r body r cid15 P cid4 P r cid10 Hr r cid4 b Br r cid4 b b body r r cid2 headr cid4 P b headr cid3 cid4 b cid4 r cid4 cid15 r cid11 cid4 b body r b body r bodyr b headr cid4 Hr r cid4 Br r T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1655 P 7 transformed P 8 r cid4 4 cid4 5 removed special case unfolding rule P 7 head unfolded p q1 obtained P 7 unfolding r3 r cid4 4 r6 r cid4 3 r cid4 3 particular r positive body literal p2 r cid4 5 Note example illustrate deﬁnitions program transformations In practice process simplifying P 1 eﬃcient choosing different transformations different orderings As shown 7 program transformations T considered elimination head redun dancy preserve answer set semantics The holds transformation Proposition 9 Let P disjunctive program If P answer sets cid4 obtained elimination head redundancy P P P cid4 Furthermore 8 disjunctive program converted transformations T considered equivalent negative disjunctive program Moreover elimination tautologies elimination head redundancy preserves negative rules literal occurs head body rule removed Thus following result Lemma 1 Every logic program P transformed equivalent negative program N T headr bodyr rule r N fulﬁlls In fact transformations applied arbitrary manner backtracking necessary construct negative program N choices transformations dont care In addition introduce basic program transformations One introduce program transformations elimination simplications 66 simplify negative program obtained basic transformations 432 Logic programs double negation A disjunctive logic program double negation failure DDLP ﬁnite set rules r form a1 b1 bm c1 cn d1 dt 2 s m n t cid2 0 ai b j ck dl set Lit classical literals assume ai similarly b j ck dl pairwise distinct Note form 1 results t 0 The deﬁnition headr r d1 dt Thus r denoted headr body body r analogous ordinary rules 1 body r body r body r l l body r body r body r Every DDLP P nested logic program 46 inherits answer set semantics programs Formally reduct r X As usual r X body r r P body P wrt interpretation X deﬁned P X headr body X answer set P iff X minimal model P X Different ordinary logic programs answer sets DDLP comparable For example DDLP P p p answer sets p For purposes use answer sets P minimal Clearly answer sets P minimal iff incomparable equivalent fact P rewritten ordinary logic program While diﬃcult expensive check general4 attractive syntactic class simple rewriting exists Similar logic programs default negation rule heads 32 double negations safely eliminated DDLP changing semantics cycle positive double negated dependencies Deﬁnition 3 A DDLP P Nacyclic level mapping L Lit P 0 1 literals P nonnegative integers rule r P following conditions hold Ll cid2 Ll ii Ll Ll cid4 l headr l cid4 l headr l cid4 body cid4 body r r Note conditions Ll Ll cid4 cid4 l headr l headr familiar deﬁnition stratiﬁed logic programs By exploiting standard methods testing logic program stratiﬁed cf 38 eﬃciently decide given DDLP program P Nacyclic linear time size P cid4 literals l l r Ll Ll cid4 body Given DDLP P let T P logic program obtained P canceling double negation For example P 0 p q q cid4 q cid4cid4 T P 0 p q q cid4 q cid4cid4 We following result 4 More precisely problem cid4p 2 complete comparable answer sets P guessed checked polynomial time NP oracle 2 hardness shown easy reduction deciding given logic program strong negation answer set The cid4p cid4p 2 complete 22 1656 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 Algorithm forget3P l Input Consistent disjunctive logic program P literal l P Output DDLP logic program N cid4 minimal answer sets ASforgetP l Method Step 1 Apply program transformations T Step 2 Separate l head disjunction semishifting P obtain negative program N0 Replace rule r N0 headr l l1 lk k cid2 1 rules l l1 lk bodyr l1 lk l bodyr Let N resulting logic program Step 3 Suppose r1 rn rules N head l r j l l j1 l jm j m j cid2 0 1 cid3 j cid3 n Distinguish cases 31 If n 0 obtain program Q removing N literals l 32 If n 0 m j 0 1 cid3 j cid3 n l rule N obtain pro gram Q removing N rules bodies contain l 33 If n 0 m j 0 1 cid3 j cid3 n let D 1 D s possible conjunctions form l1k1 lnkn 0 cid3 k1 cid3 m j 1 cid3 j cid3 n Obtain program Q replacing N l D time Step 4 Remove rules l head Q output resulting program N cid4 Theorem 7 For Nacyclic DDLP P holds ASP AST P Fig 4 Syntaxbased algorithm compute forgetting See Appendix A proof Note ordinary logic program trivially Nacyclic view Nacyclic DDPs syntactic extension ordinary logic programs The fact Nacyclic DDLPs easily cast ordinary logic programs transformationbased forgetting 433 The algorithm We position present syntaxbased algorithm computing forgetting logic program The algorithm forget3P l shown Fig 4 ﬁrst translates input program P negative program N Step 1 separates l head disjunction Step 2 After l eliminated rule bodies Step 3 ﬁnally rule heads Step 4 The resulting output program general logic program double negation failure Example 5 Consider P 4 c q p q q p Then Step 1 N0 P 4 P 4 negative Step 2 N P 4 P 4 normal In Step 3 n 1 r1 p q Thus case applies cid4 c q q q D1 q obtain Q c q p q q q In Step 4 program N output This program answer sets c q minimal They answer sets forgetP 4 p Note Algorithm 1 65 outputs input P 4 p program N cid4 c q q q single answer set c However semantic result forgetting p P 4 deﬁned 65 paper answer set viz q This shows Algorithm 1 65 incomplete outputs general logic program represents subset answer sets forgetting Several remarks Algorithm forget3P l order 1 As formulated algorithm stated general form A number reﬁnements improvements order eﬃcient result compact For example Step 1 program transformations omitted special programs heuristics employed In Step 3 D need considered removal duplicate literals properly contained D j To compute use eﬃcient hypergraph transversal algorithms 25 2 In construction D li j replaced li j normal logic program As shown Example 5 resulting output program c q q q represent subset ASlP incorrect The use double negation failure remedies problem intuitive It remains interesting issue avoided similar transformation based algorithm 3 The running time algorithm forget3P l worst case exponential output program exponentially representing large As follows complexity considerations Section 5 ordinary nested logic program P forgetP l constructed polynomial time auxiliary literals projected answer sets P cid4 cid4 4 In essence algorithm forget3P l improves corresponding Algorithm 1 65 ways works expressive class disjunctive logic programs importantly output correctly represents result forgetting This shown formally following result T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1657 Theorem 8 Let P consistent disjunctive logic program let l Lit P literal Then forget3P l correctly represents forgetP l X answer set forgetP l iff X minimal answer set N cid4 For proof Appendix A While output program forget3P l generally contains double negation failure minimal answer sets considered Theorem 7 provides simple condition transforming output Algorithm forget3P l ordinary logic program cases Proposition 10 Let P consistent logic program let l Lit P literal let N Nacyclic ASlP AST P cid4 ordinary logic program T P cid4 cid4 correctly represents forgetP l output Algorithm forget3P l If N cid4 For arbitrary inputs clear output forget3P l Nacyclic program We note relevant subclass property given simple syntactic condition eﬃciently recognized Recall standard dependency graph program P denoted DG P Lit P vertices positive edge r rule r P A directed cycle graph DG P negative contains r headr l rule r P negative edge l l l headr l cid4 cid4 body cid4 body cid4 literal l literal l l headr l negative edge Proposition 11 Let P consistent normal logic program let l Lit P literal If negative cycle DG P contains l forget3P l outputs Nacyclic program In Example 2 l p programs P 1 P 3 P 4 property P 6 removal redundant disjunctive rule Hence outputs respective calls forget3P p cast ordinary logic programs Unfortunately extension Proposition 11 normal disjunctive logic programs fails simple case P p q l p However possible single fragments possible leave future work Computing representation forgetP l reﬁned different directions One localize computation relevant program P subject modiﬁcation forgetting literal l rest P remains untouched This example easy P normal logic program case merely value l single answer set P plugged occurrences l P resulting program simpliﬁed Another case P splits separate components P 1 Pn answer sets P obtained combining local answer sets P cid4 To end literal l program P unaffected forgetting literal l path l l undirected version dependency graph DG P Suppose U P l set rules P involve literals l Then following easy property holds cid4 cid4 Proposition 12 For consistent program P literal l holds forgetP l U P l forgetP U P l This property line Nacyclicity disconnected components destroy Nacyclicity rewritten program Furthermore combined Proposition 11 enlarge classes programs P forgetP l representable ordinary logic program Note Proposition 12 independent concrete syntactic form forgetP l generalized speciﬁc forms andor classes programs For example P split programs P 1 P 2 l occurs P 1 program P 2 single answer set S P 2 normal stratiﬁed head rule P 1 occurs P 2 forget3P l forget3 P 1 l cid4 l cid4 S l P 2 cid2 cid3 A detailed study issue remains future work We close section brief comparison representation size forgetP l terms programs output algorithms forget1P l forget2P l forget3P l formula CirclcompP l Section 33 l atom p CirclcompP l viewed formula quantiﬁers usual cf 4243 size polynomial size lcompP Note forget1P l forget2P l output Compared algorithms forget1P l forget2P l size output forget3P l orthogonal sense instances produce output program exponentially smaller respectively larger produced forget3P l For example program P ai bi 1 cid3 cid3 n p exponentially answer sets contains p output forget1P p forget2P p contains exponentially rules forget3P p consists P p On hand program Q pi p qi p p pi qi 1 cid3 cid3 n answer sets viz p p1 q1 pn qn forgetQ p answer set forget1Q p forget2Q p consist single rule forget3Q p contains exponentially rules form pi a1 qi a1 j p j q j 1 n 1658 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 Table 1 Complexity forgetting entries completeness results l l cid4 literals P logic program X set literals Program P X ASlP model checking cid4 forgetP l cid9c l cid4 forgetP l cid9s l disjunctive cid4p 2 cid5 p 3 cid4p 2 negative coNP cid5 p 2 coNP normal coNP cid5 p 2 coNP Also representation forgetQ p terms minimal models described Section 33 CirclcompQ p expo nentially smaller forget3Q p Q negative lcompQ compQ On hand program P lcompQ like forget3P p small forget1P p forget2P p exponentially larger Finally easy ﬁnd programs P atom p forget3P p exponentially smaller lcompP optimization applied holds P negative lcompP easily formed Thus summary representations obtained forget1P lforget2P l forget3P l CirclcompP p basic form orthogonal size 5 Computational complexity In section address computational complexity forgetting different classes logic programs Our main complexity results forgetting compactly summarized Table 1 They general logic programs 1 model checking forgetting cid4p 2 complete 2 credulous reasoning forgetting cid5 p 3 complete 3 skeptical rea soning forgetting cid4p 2 complete Intuitively complexity explained respectively intermingled sources complexity iiii For prob cid4 l S lem 1 given answer set S program P literal l number candidate answer sets S fact answer set P problem 2 addition iii number ii test given S candidate lanswer sets S containing query literal l Note problem 3 source absent Propo sition 7 ii iii dual form present causing complexity standard skeptical reasoning forgetting S cid4 cid4 cid4 For normal programs negative logic programs complexity problems lowered level Poly nomial Hierarchy Intuitively reason source ii model checking programs polynomial cases In rest section state develop complexity results formally argue spaceeﬃcient representations forgetP l terms ordinary disjunctive logic programs unlikely exist The design Algorithm forget3P l Section 4 heavily inﬂuenced complexity analysis Theorem 9 Given consistent disjunctive logic program P literal l set literals X deciding X lanswer set P cid4p 2 complete Intuitively order X lanswer set witness X answer set coNP cid4 l X Any X disproving guessed P X complete test answer set X checked NPoracle polynomial time Thus lanswer set checking cid4p 2 stated Theorem 9 The hardness result shown reduction deciding given logic program P strong negations answer set cid4p cid4 cid4 2 complete 22 If P negative normal lanswer checking coNPcomplete Theorem 10 Given consistent normal logic program P literal l set literals X deciding X lanswer set P coNPcomplete The proof theorem exploits reduction proof Theorem 9 works normal programs deciding normal logic program answer set known NPcomplete 452 Using minor modiﬁcation reduction proof Theorem 9 coNPcompleteness negative programs Notice mentioned deciding given set literals answer set negative program feasible polynomial time explains complexity drop Theorem 11 Given consistent negative program P literal l set literals X deciding X lanswer set P coNPcomplete The following theorem shows credulous reasoning forgetting higher complexity Theorem 12 Given consistent disjunctive logic program P literals l l cid4 deciding forgetP l cid9c l cid4 cid5 p 3 complete T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1659 In Theorem 12 suitable lanswer set containing l 3 The cid5 p credulous inference forgetP l cid9c l QBFs form Z XY φ cid5 p cid4 cid4 guessed checked Theorem 9 cid5 p 2 oracle Hence 3 hardness shown encoding quantiﬁed Boolean formulas The construction proof Theorem 11 lifted credulous inference forgetting cid5 p 2 complete negative programs Theorem 13 Given consistent negative program P literals l l cid4 deciding forgetN l cid9c l cid4 cid5 p 2 complete In fact program constructed hardness result normal Therefore easily derive following result Theorem 14 Given consistent normal program N literals l l cid4 deciding forgetN l cid9c l cid4 cid5 p 2 complete The complexity results skeptical reasoning forgetting straightforward Proposition 7 wellknown results complexity normal logic programs 152252 Theorem 15 Given consistent logic program P literals l l disjunctive logic programs P ii coNPcomplete normal logic programs negative logic programs P deciding forgetP l cid9s l cid4p cid4 cid4 2 complete arbitrary By applying techniques build nonuniform complexity classes 12 given disjunc representing forgetP l size tive program P literal l generally ordinary disjunctive program P polynomial size P Polynomial Hierarchy collapses This remains true auxiliary literals obtain models forgetP l This means P exponential blow forgetP l formal sense unavoidable general representation projected models P cid4 cid4 cid4 2 deﬁned 1213 Informally means problem hardest cid25cid2cid4p More precisely shown model checking problem forgetting complete complexity class cid25cid2cid4p 2 contains prob lems decidable cid4p 2 preprocessing input depends ﬁxed size input The preprocessing resort precompiled knowledge polynomialsize data structures compilation cost count Technically cid4p 2 completness model checking forgetting implies syntactic variant prob lem belongs cid25cid2cid4p 2 hard evaluating QBF form XY φ reduced suitable notion reduction model checking forgetting The proof similar spirit Theorem 32 13 shows cid25cid2cid4p 2 hardness clause inference minimal models propositional CNF uses encoding QBFs model checking forgetting given proof Theorem 9 22 We refrain details 2 On hand problem cid25cid2cid4p Now model checking forgetting cid25cid2cid4p 2 hard model checking ordinary disjunctive programs known coNP cf 1521 From Theorem 5 12 follows arbitrary logic programs P literal l exists representation forgetP l ordinary disjunctive logic program size polynomial size P Polynomial Hierarchy collapses considered unlikely Analogously normal programs P forgetP l representable normal programs poly nomial size size P Polynomial Hierarchy collapses auxiliary literals However point auxiliary literals allowed represent forgetP l terms minimal answer sets polynomialsize logic program double negation failure More precisely let s pl fresh auxiliary literals use l auxiliary literal Let P 1 program resulting P adding s rule body let P 2 program resulting P replacing occurrence l pl adding s rule body let Q P 1 P 2 s s l s l s pl s Note Q easily constructed P l linear time Informally s switch P 1 P 2 compute answer sets P l true P 1 constraint l s s false respectively false P 2 s true In order answer sets lcomparable computations P 2 literal pl replaces l l artiﬁcially included l s pl excluded pl s The answer sets S Q contain l pl correspond onetoone answer sets P Now S s S minimal answer set Q s S S minimal iff contains answer set S properly Consequently minimal answer sets S Q encode lanswer sets P answer sets forgetP l given S l s Q s S cid4 cid4 1660 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 6 Applications In section present applications results forgetting logic programs previous sections In particular consider applications conﬂict resolution logicbased multiagent systems obviously im portant task inheritance logic programs model objects classes inheritance properties logic program updates A application area ontology merging alignment extended framework scribed 24 The applications usefulness results forgetting different respects On hand ﬁnding novel solutions problems like conﬂict resolution ontology merging hand obtain novel characterizations interpretations existing concepts like inheritance logic programs logic program updates 61 Resolving conﬂicts multiagent systems As ﬁrst application present general framework resolving conﬂicts multiagents systems inspired preference recovery problem 35 In particular example given elegance semantic forgetting answer set programming solve problem preference recovery multiagents Suppose n agents different preferences issue In cases preferences constraints conﬂicts satisﬁed time It important issue constraint reasoning ﬁnd intuitive criteria preferences higher priorities satisﬁed Consider following example Example 6 See 35 Suppose group residents complex tries reach agreement building swimming pool andor tennis court The preferences constraints follows 1 Building tennis court swimming pool costs unit money 2 A swimming pool red blue 3 The ﬁrst resident like spend money unit prefers red swimming pool 4 The second resident like build tennis court swimming pool If swimming pool built prefer blue 5 The resident prefer swimming pool color ﬁne 6 The fourth resident like tennis court swimming pool built He care color pool Obviously preferences group jointly inconsistent impossible satisfy time In following resolve kind preference conﬂicts ﬁnd possible agreements minimal costs theory forgetting An nagent S ntuple P 1 P 2 Pn logic programs n 0 P represents agent knowledge including preferences constraints As shown Example 6 P 1 P 2 Pn inconsistent The basic idea approach forget literals agent conﬂicts resolved Deﬁnition 4 Let S P 1 P 2 Pn nagent A compromise S sequence C F 1 F 2 Fn F set literals An agreement S C answer set logic program forgetS C forgetS C forgetP 1 F 1 forgetP 2 F 2 forgetPn Fn Intuitively set F compromise contains aspects agents care For speciﬁc application need impose certain conditions F Example 7 Example 6 continued The scenario encoded collection ﬁve disjunctive programs P 0 stands general constraints S P 0 P 1 P 2 P 3 P 4 u0 s t u2 s t P 0 red blue s red blue u1 s t u1 s t P 1 u0 u1 red s P 2 s t blue s P 3 s P 4 s t Since knowledge base jointly inconsistent resident weaken preferences agreement reached Some possible compromises T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1661 1 C1 F F F F F s blue red Every resident willing weaken preferences swim ming pool color Since forgetS C1 P 0 u0 u1 t S unique agreement t u1 C1 That tennis court built 2 C2 F F F F F u0 u1 u2 blue red Every resident weaken preferences price pool color Since forgetS C2 P 0 s t s t S possible agreements s t red s t blue C2 That tennis court swimming pool built pool color red blue 3 C3 blue red t The ﬁrst resident weaken preference pool color fourth resident weaken preference tennis court Since forgetS C3 P 0 P 2 P 3 u0 u1 s t s S unique agreement s blue u1 C3 That swimming pool built color blue 4 C4 blue red blue red s t s t The ﬁrst second residents weaken preference pool color fourth residents mind tennis court swimming pool built Since forgetS C4 P 0 u0 u1 s t S possible agreements u1 t u1 s blue u1 s red C4 It noted solution problem provided 35 forgetting propositional logic theory propositional logic possible agreements produced A model theory represent agreement sense Deﬁnition 4 For example solution C4 given 35 theory T 4 s red blue red blue s t u1 s t u1 s t u2 s t u0 models include agreements nonminimal costs u2 s t red model T 4 However approach answer set corresponds exactly agreement minimal cost In addition issue resolving conﬂicts multiagent systems challenging numerous proposals suggested different systems example 64 Thus interesting explore applications technique practical multiagent systems 62 Inheritance logic programs In section investigate relationships forgetting logic programs inheritance logic programs 11 As semantics programs expressed forgetting logic program Let P logic program classical negation rule r P labeled symbol symbol The symbol means r defeasible rule symbol means r strict rule In approach proposed 11 P inheritance program P classiﬁed different objects object higher priority object For objects o1 o2 o1 o2 denotes o1 higher priority o2 This priority relation naturally deﬁnes priority rules objects r1 r2 r1 o1 r2 o2 o1 o2 Example 8 Let P inheritance logic program consists objects o1 o2 o3 cid10 cid10 cid10 o1 o2 o3 cid11 penguinTweety birdx penguinx ﬂiesx penguinx ﬂiesx birdx cid11 cid11 o1 o2 o3 speciﬁc rules higher priority In rest section view accordance 11 inheritance programs pairs P P ground propositional logic program classical negation strict preorder irreﬂexive transitive relation rules P r r iff r higher priority r 5 cid4 cid4 The semantics inheritance programs deﬁned terms inheritance answer sets based notion models inheritance program The notion satisﬁability rules inheritance programs encodes priority information different traditional notion Given ground rules r1 r2 r1 threatens r2 literal l 1 l headr1 2 r1 r2 3 r2 defeasible recall l denotes complement literal l Deﬁnition 5 Given inheritance program P interpretation S rule r1 overrides r2 S 1 r1 threatens r2 literal l 2 l S 3 S cid9 bodyr2 A rule r overridden S l headr exists rule r P r overrides r l S cid4 cid4 Informally rule r overridden rule r cid4 lower priority r cid4 conﬂict r cid4 Obviously strict rule overridden An interpretation S model P rule P satisﬁed overridden S The GelfondLifschitz reduct extended inheritance programs follows 5 Cf 11 p297 technical assumptions ensure 1662 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 Deﬁnition 6 Given inheritance program P interpretation S reduction P wrt S denoted P S r S cid15 set rules obtained P removing 1 rule overridden S 2 rule r body 3 body r remaining rule r An interpretation S inheritance answer set P S minimal model P S Example 9 The ground version inheritance program Example 8 groundP single inheritance answer set S penguinTweety birdTweety ﬂiesTweety Indeed instance rule o3 ﬂiesTweety birdTweety overridden rule instance ﬂiesTweety penguinTweety o2 S groundP S consists rules penguinTweety birdTweety penguinTweety ﬂiesTweety penguinTweety Clearly S unique answer set means S inheritance answer set groundP Let P inheritance program S set literals We introduce new literal l rule r P r overridden S literal l headr replaced l denoted P cid4 r The following theorem provides semantic characterization inheritance programs terms semantic forgetting new literal l Let F l cid4 headr cid4 P cid4 l cid4 cid4 cid4 cid4 literal l P For The resulting program P cid4 Theorem 16 Let P inheritance program let S set literals Then S inheritance answer set P iff S answer set forgetP obtained cid4 F P cid4 Example 10 Continuing birds example S penguinTweety birdTweety ﬂiesTweety corresponding ordi cid4 nary logic program groundP penguinTweety consists following rules birdTweety penguinTweety ﬂiesTweety penguinTweety ﬂiesTweetycid4 birdTweety cid4 For F ﬂiesTweetycid4 obtain forgetgroundP unique answer set S stated Theorem 16 F represented ﬁrst rules This program The proof Theorem 16 based following result independent Proposition 13 Let P logic program let F consistent set literals Suppose 1 literal F occurs rule body P 2 rule r literal headr F Then forgetP F P RF RF r P r contains literal F Note conclusion Proposition 13 true F contains opposite literals For example consider logic program P p p b b F p p Then P RF b b answer sets b forgetP F answer set b 63 Update logic programs Update programs 1819 dynamic logic programs 12 536269 major approaches updating non monotonic logic programs particular geared modeling sequences updates 68 recent survey comparison approaches An update program sequence P P 1 P 2 P t t cid2 1 P logic program 1 cid3 cid3 t Informally P i1 assumed update information represented P 1 P So P i1 represents recent information P rules P i1 assigned higher priority case conﬂicts The semantics update programs given means translation ordinary logic program P cid4 characterized purely declarative way Let P P 1 P 2 P t update program We introduce new atom rejr rule r P new atom ai atom P 1 cid3 cid3 t If l ai denoted li The transformation P cid4 deﬁned ordinary logic program consisting following rules constraints P 1 cid3 cid3 t ii r P head h 1 cid3 cid3 t hi bodyr rejr iii r P head h 1 cid3 cid3 t rejr bodyr hi1 iv literal l occurring P 1 cid3 cid3 t l l1 li li1 Deﬁnition 7 See 19 Let P P 1 P 2 P t update program let X set literals Then X answer set P answer set transformation P cid4 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1663 It shown 1819 update program P naturally translated equivalent inheritance logic program ihpP P r r cid4 r P r cid4 P j 1 cid3 j cid3 t More precisely Lemma 2 See 19 For update program P P 1 P 2 P t set S answer set P iff S answer set inheritance program ihpP Combining lemma Theorem 16 gives characterization update programs terms semantic forgetting logic program Corollary 17 Let P update program let S set literals Then S answer set P S answer set obtained P described forgetP cid4 F ihpP P P cid4 Finally results 19 certain classes update programs semantics coincides dynamic logic programming 12 Hence consequence results 19 respective classes dynamic logic programs characterized semantic forgetting way described 64 Forgetting vs independence As argued 34 notion independence important automated deduction query answering belief revision For example intelligent agent possess ability determining discarding irrelevant information eﬃciently When reasoning involved issue independence irrelevance delicate complex The idea forgetting independent literals useful improving reasoning procedures Informally logic program P independent literal l answer set semantics P unchanged forget l P So natural reasonable formally deﬁne notion semantic independence follows Deﬁnition 8 Let P consistent logic program P semantically independent literal l Lit P ASforgetP l ASP Obviously P semantically independent literal l l safely forgotten P Example 11 Consider program P p q s s Clearly P forgetP q forgetP s single answer set p Hence P semantically independent s q The following proposition provides intuitive characterization semantic independence Proposition 14 Let P logic program P semantically independent literal l Lit P l S answer set S P This result straightforward Deﬁnition 2 intuitive P independent literal l l false respect answer set P P cid15cid9c l In cases semantic independence literals veriﬁed P syntactically shown result Let T respective canonical form program P program transformations introduced Section 431 let T Proposition 15 Let P logic program let l Lit P literal Suppose P formations T l occur T l occur P P cid4 cid4 Then P semantically independent l Furthermore program P negative program obtained P trans exists iff cid4 The converse Proposition 15 true general For example consider program P p q q p q cid4 p Then P semantically independent p On hand p occurs program P resulting P P p q q p q q It repeated transformations T remains interesting issue set program transformations strong syntactically characterize notion semantic independence literals particular canonical form T 7 Conclusion While widely acknowledged forgetting atomic propositions knowledge bases important technique AI applications clear materialize context nonmonotonic reasoning logic programming To best knowledge paper ﬁrst attempt identifying criteria operation context In particular speciﬁed desirable properties forgetting nonmonotonic logic 1664 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 programming Based criteria proposed semanticsbased theory forgetting literals disjunctive logic programming Compared preliminary work distinguishing feature approach forgetting deﬁned purely semantical terms However shown declarative approach forgetting syntactic counterpart based program transformations The properties forgetting approach paper extends classical notion forgetting satisﬁes criteria identiﬁed As explained naturally generalizes notion forgetting normal programs investigated 65 Furthermore presented algorithms analyzed computational complexity major reasoning tasks forgetting Another approach forgetting normal logic programs proposed 7071 Different approach Zhang colleagues procedural The result forgetting obtained removing rules andor literals little semantic justiﬁcation removals provided global perspective logic programming For ap proaches weak strong forgetting criteria F3 F4 foster semantic justiﬁcation forgetting irrelevance syntax answer set semantics hold In Section 1 shown strong weak forgetting property F4 To F3 satisﬁed strong weak forgetting consider example programs Section 1 For program P p q p result weak forgetting WForgetLPP p q WForgetLPP p cid9s q P cid15cid9s q Similarly P q p q q SForgetLPP p q q inconsistent SForgetLPP p cid9s q P cid15cid9s q If adopts natural read ing rules b1 bm c1 cn formulas b1 bm c1 cn propositional logic weak strong forgetting appear intimately related Lins weakest suﬃcient strongest necessary conditions 48 respectively strong classical ﬂavor As application forgetting presented fairly general framework resolving conﬂicts disjunctive logic programming In particular framework provides elegant solution preference recovery problem Fur thermore results semantic forgetting close relationship inheritance programs 10 update programs 1819 fragments dynamic logic programs 12 Semantic forgetting extended 24 hexprograms allow combine logic programs Description Logics 23 applied deﬁning notion forgetting Web Ontology Language OWL6 Furthermore prototype semantic forgetting called LPForget comprises modules implemented available experiments7 The module Forgetting serves computing result forgetting certain literals logic program answer set semantics algorithms introduced paper implemented The module named CRS facilitates conﬂict resolution preference recovery multiagent systems approach Section 61 In constraints different agents speciﬁed CRS ﬁrst check constraints consistent If consistent user compromises forgetting literals agree ment reached The recommendations set literals forgotten However current recommendation algorithm optimized remains explore eﬃcient algorithms Several interesting issues remain research One issue eﬃcient implementations improved algo rithms computing result forgetting In particular given disjunctive logic program P literal l Algorithm forget3P l outputs generally nested logic program represents result forgetting l P min imal answer sets It known nested logic programs eﬃciently transformed equivalent ordinary disjunctive programs new symbols allowed 59 However carry minimal answer sets minimization needed It interesting syntaxbased algorithm based merely program transforma tions actual answer sets outputs ordinary disjunctive logic program original vocabulary result forgetting Another issue application forgetting scenarios conﬂict resolving ontology merging alignment Semantic Web 58 In applications closed open world reasoning involved Exploring theory forgetting setting interesting issue Strong equivalence 45 received lot attention nonmonotonic logic programming importance program modularity applications like information integration It interesting introduce notion semantics forgetting preserves strong equivalence line properties approach paper Finally extension approach paper semantics nonmonotonic logic programming general formalisms default logic autoepistemic logic intriguing issue Acknowledgements The authors like thank FuLeung Cheng Esra Erdem Paolo Ferraris Fangzhen Lin Abdul Sattar Kaile Su Rodney Topor Yan Zhang helpful comments discussions We grateful reviewers helpful constructive comments clarify aspects paper This work partially supported Austrian Science Funds FWF Projects P17212 P18019 EC project REWERSE IST2003506779 Australia Research Council ARC Discovery Projects DP0666107 DP0666540 6 httpwwww3org2004OWL 7 The LPForget website httpwwwcitgueduaukewenLPForget T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1665 Appendix A Proposition 5 Let X equivalence relation collection logic programs Lit stronger ordinary equivalence invariant literal extensions Then forgetting preserve X Proof Since X stronger ordinary equivalence logic programs exist programs P P P P forgetting l P Obviously P X P results forgetting P P result equivalent X cid3 Let l new literal appears P P Then forgetP l P P P cid15 X P cid4 cid4 cid4 cid4 cid4 cid4 Proposition 8 Let P consistent logic program let F l1 lm set literals Then cid3 lm cid2 cid2 forgetP F forget forgetP l1 l2 forget cid3 Proof Assume m 1 Let M ASforgetP F M cid4 l1 lm1 F cid4 ASforgetP F cid4 M cid4cid4 ASforgetforgetP F cid4 lm We claim M M Consider set X M Then analogue item 5 Proposition 6 exists stable model S P X S F Now process iterative construction let To prove ﬁrst M M cid4cid4 cid4cid4 P 0 P P forgetP i1 li 1 m By item 5 Proposition 6 fact li occur P induction 1 2 m exist answer set S P S S i1 li Consequently Sm S l1 lm S F Hence exists answer set Sm Pm Sm X Furthermore Sm X impossible Otherwise Sm X X hold Thus Sm F cid4 F answer cid4 S F Hence S F answer set P contradiction Thus Sm X In F cid4 set P Sm F cid4cid4 conclusion M M Conversely suppose X M cid4cid4 That X answer set Pm By deﬁnition oneliteral forgetting means exists answer set S P S F X Towards contradiction suppose X M Then exists set Y M Y X As shown Y answer set P m But contradicts X answer set P m X minimal Hence X M cid3 Theorem 3 Let P consistent disjunctive logic program let p Lit P atom Then X Lit P answer set forgetP p iff X minimal model forgetlcompP p That cid3 cid2 forgetlcompP p cid3 cid2 forgetP p MMod AS Proof We use following lemma Lemma 3 Let X Lit P p X cid9 forgetlcompP p Then X ASP X p ASP Proof Lemma 3 By Theorem 1 X lcompP ptrue lcompP pfalse X Lit P p X cid9 forgetlcompP p X X cid9 lcompP pfalse X cid4 X p ASP X cid9 lcompP ptrue holds cid3 cid4 ASP iff X cid4 cid9 lcompP holds X cid4 Lit P Since forgetlcompP p cid4 X ASP ASforgetP p MModforgetlcompP p Let X ASforgetP p Then exists S AS pP X p S By Theorem 1 S cid9 lcompP Since S p X X cid9 forgetlcompP p To X cid4 minimal assume contradiction X cid4 p S contradicts S AS pP This proves cid4 X cid4 ASP holds S X MModforgetlcompP p cid4 cid9 forgetlcompP p By Lemma 3 S cid4 X exists X cid4 p In cases S cid4 X ii MModforgetlcompP p ASforgetP p Let X MModforgetlcompP p By Lemma 3 S ASP ei ther S X S X p We cases S AS pP Towards contradiction suppose S AS pP cid4 p ASforgetP p By cid4 S Then exists S cid4 X contradicts X MModforgetlcompP p Hence follows X S AS pP By item 1 Proposition 6 S p X ASforgetP p This proves result cid3 cid4 AS pP S cid4 MModforgetlcompP p Since X cid4 p S item 1 Proposition 6 X S Theorem 4 Let P consistent disjunctive logic program let p Lit P atom Then X Lit P p answer set forgetP p X X p model CirclcompP p resp ECWAlcompP p 1666 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 Proof By Theorem 1 ASP S Lit P S cid9 lcompP Hence characterization models CirclcompP p terms p p easily seen AS pP S Lit P S cid9 CirclcompP p Consider X Lit P p Suppose ﬁrst X ASforgetP p Then X p S S AS pP S X S X p hold As S cid9 CirclcompP p onlyif direction theorem holds Conversely suppose S cid9 CirclcompP p S X S X p Then S AS pP item 1 Proposition 6 S p X ASforgetP p This proves result cid3 Theorem 6 For consistent disjunctive logic program P literal l Algorithm forget2P l outputs correct representation forgetP l Proof By construction P 1 Step 1 ASP 1 X ASP l X By Proposition 1 A1 consists sets X l X X l ASlP In Step 2 constraint l guarantees answer set X P 2 answer set P l X The constraint a1 ak M a1 ak A1 enforces M l cid15 X holds Consequently A2 consists sets X ASlP l X Combining cases ASlP X l X A1 A2 item 1 Proposition 6 ASforgetP l A A1 A2 It easy ASP cid4 A proves result cid3 Proposition 9 Let P disjunctive program If P answer sets cid4 obtained elimination head redundancy P P P cid4 Proof Let P P 0 r l headr body S Lit P following statement holds S ASP iff S ASP Otherwise l S rule r1 headr body cid4 cid9 r1 iff S Furthermore S holds cid3 cid4 S holds S r let P cid4 P 0 headr l bodyr We cid4S holds cid4S cid4S Again follows r P S iff rule r2 headr l body cid4 cid9 r2 S cid4 If l S P S P cid4 cid9 P S iff S r P cid4 cid9 P To prove Theorem 7 ﬁrst lemma Lemma 4 Let P DDLP let S interpretation P If S AST P S minimal answer set P Proof Let S AST P We ﬁrst S ASP Let r headr body body S cid9 P S r r P body r T P S Now body r body Consider S cid4 S S literals body As S AST P follows S cid4 ASP S Consider S cid4 S cid3 follows S cid4 cid9 P S Then S cid4 S Then S cid4 P S S cid9 bodyr cid4 Then r cid4 r S body r S S cid9 headr S cid9 body r S Furthermore rule r r Hence S cid9 r form cid4cid4 headr It follows cid4 cid4 cid9 T P S rule T P S results rule P S adding cid4 S This proves S ASP It remains S minimal cid4 cid9 T P S As S AST P S Since T P S T P S cid4 cid9 T P S cid4 cid4 Theorem 7 For Nacyclic DDLP P holds ASP AST P Proof AST P ASP Immediate Lemma 4 ASP AST P Suppose S ASP S AST P Then S minimal model T P S Note cid4 cid9 T P S We interpretation cid4 S S cid4cid4 cid9 P S means S minimal model P S contradicts S cid9 T P S Hence exists interpretation S cid4cid4 exists S S S S ASP proving result cid4cid4 S S We ﬁrst assume P normal headr cid3 1 r P Let L level mapping witnessing Nacyclicity cid4 S cid4 set literals S S having smallest level Since S Ll cid3 Ll cid4 S S cid4 l cid4 P let X l S S X cid15 We claim S cid4 cid4cid4 S X cid9 P S Towards contradiction suppose S cid4cid4 Since r stems rule r r S body follows body body S ASP Hence result normal programs P proved cid4 cid15 b body r cid15 S cid4 P S cid9 r cid4 S r X cid15 body r S r cid4cid4 cid4cid4 cid15cid9 r r P S Since S cid9 P S r form l body cid4 r l X cid4 cid9 T P S cid4 body cid4 cid15 The minimality Ll implies case cid4cid4 cid9 P S contradicts r headr cid4 S r contradiction This proves claim S The result arbitrary programs easy consequence result following facts Call program P results P replacing rule r form l1 lk B k cid2 2 normal cid4 cid4 split DDLP P P rules l1 B lk B Now Fact A For S ASP exists split P cid4 P S ASP cid4 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1667 Indeed split P cid4 P r replaced rules li B li S headr S cid15 S answer set This simple extension folklore result ordinary logic programs 2830 Fact B If DDLP P Nacyclic split P cid4 P Nacyclic cid3 Theorem 8 Let P consistent disjunctive logic program let l Lit P literal Then forget3P l correctly represents forgetP l X answer set forgetP l iff X minimal answer set N cid4 Proof By Lemma 1 P transformed equivalent negative program N0 Furthermore easy extension Corollary 2 implies N0 equivalent N Hence P N forgetP l forgetN l Let AS minN cid4 denote minimal answer sets program N cid4 wrt To prove theorem item 1 Proposition 6 suﬃcient prove following claim Claim For set X cid4 literals l X cid4 X cid4 AS minN cid4 iff X cid4 X l X ASlN Due elimination tautology elimination head redundancy headr bodyr rule r N Thus program N split disjoint parts N N1 N2 N3 N1 consists rules N l r Notice Step 3 appear N2 r N l headr l body cid4 Algorithm forget3P l performed rules N3 Let program N 3 result N3 transformations cid4 3 Let D1 D2 D s denote possible conjunctions constructed li Step 3 note Step 3 Then N N2 r1 rn We consider cases Step 3 r N3 r N l headr l body cid4 N1 N 31 If n 0 rule N l head Thus l false answer set N N N cid4 cid4 ordinary program AS minN cid4 ASN cid4 It follows AS minN cid4 ASlN ASlN ASN Since N claim holds 32 If n 0 m j 0 j 1 n rule l N Hence answer set N contains As previous case cid4 l ASN holds set literals X l X cid4 cid4 cid4 iff X l clearly X ASlN ASN AS minN cid4 ASN cid4 ASN cid4 claim holds 31 n cid2 1 mi cid2 1 1 n We use following lemmas Lemma 5 If l X cid4 X cid4 cid9 D i0 i0 1 cid3 i0 cid3 s N3 X cid4 N cid4 3 X cid4 Lemma 6 For X cid4 AS minN cid4 1 X 2 X cid4 cid9 D i0 i0 1 cid3 i0 cid3 s X cid4 cid15cid9 D 1 s X cid4 ASN cid4 l ASN cid4 Proof Lemma 6 1 N X N cid4 X So X cid4cid4 X If X 2 Let X X cid4 cid9 N X cid4 X cid4cid4 cid9 N X cid4 cid4 cid4 N2 X N1 X N1 X rule N2 head l Thus X cid9 N X cid4 N1 X cid4 N3 X cid4 X cid4 cid9 D i0 implies l X cid4 By Lemma 5 N3 X cid4 N cid4 cid4 3 X N X cid4 X minimal model N X cid4 l Since l X l appear N1 N X N1 N2 N3 X N1 X N2 X Obviously X cid9 N2 X l X cid4 l By assumption X X cid9 N1 X cid4 cid9 N1 X Therefore X Since X X cid4 cid4 cid4 ASN cid4cid4 cid9 N cid4 X cid4 cid4 cid4cid4 X cid4 cid4 Now suppose Y X Y cid9 N X Since l N X l Y Let Y Y cid4 X Thus Y Y cid4 cid9 N cid4 N1 X N minimal model N X X ASN cid3 cid4 X cid4 X Y cid4 X cid4 cid4 cid4 cid4 minimality X cid4 l l Y cid4 By This implies Y X So X Then Y cid4 cid9 N1 X cid4 cid4 We prove claim Let X cid4 ASlN Then X ASN X X cid4 X X cid4 l l X Consider cases cid4 Case 1 X X Note X cid4 N1 X cid4 N cid4 N1 X 3 X cid4cid4 X Suppose X cid4 X Suppose Y AS minN follows Y X So X implies X Case 2 X X cid4 ASN cid4 cid4 follows X cid4 cid9 N cid4 X X cid4 cid4 cid9 D i0 i0 1 cid3 i0 cid3 s l X cid4 N3 X X cid4 X Since X cid4 cid9 N cid4cid4 cid9 N X This implies X cid4cid4 cid9 N Then X cid4 X cid4 cid4 cid4 cid4 cid4 cid4 By Lemma 5 N3 X cid4 N cid4 cid4 3 X Therefore N cid4 X cid4 minimal model N X cid4 X cid4cid4 X cid4 Thus cid4 Y X cid4 AS minN cid4 If Y cid9 D j0 j0 1 cid3 j0 cid3 s Lemma 6 Y ASN cid4 If Y cid15cid9 D 1 cid3 j0 cid3 s Y l ASN Lemma 6 This cid4 ASlN contradiction Therefore X cid4 l Then N X N X cid4l N1 X cid4 cid15cid9 D 1 cid3 cid3 s Thus N cid4 AS minN cid4 cid4 l Since l X X cid15cid9 D 1 cid3 cid3 s From l X cid4 cid4 X cid4 N1 X cid4 N cid4 3 X cid4 N1 X cid4 Since X cid9 N X X cid4 cid9 N1 X cid4 1668 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 cid4 cid4 cid4cid4 X cid4cid4 X If X X cid4 Thus X X If Y AS minN cid4 means Y X cid4cid4 l cid9 N X By minimality X X cid4cid4 cid9 N cid4 X X cid4 ASN cid4 cid4 Y X answer sets N incomparable Thus X cid4 cid4 AS minN cid4 Y cid15cid9 D 1 s Consequently Y l ASN So Y l X cid4 l This cid4cid4 l X Since l X cid4 l X cid4cid4 Suppose X cid4 AS minN cid4 Consider possible cases Case 1 X cid4 cid15cid9 D 1 s By Lemma 6 X X cid4 l ASN Thus X cid4 ASlN l X item 3 Proposi tion 1 Case 2 X cid4 cid4 cid9 D i0 i0 1 cid3 i0 cid3 s By Lemma 6 X Then l Y l X Y l X proof onlyif Y l minimal answer set N X cid4 ASlN cid3 answer sets N incomparable Thus Y ASlN Proposition 1 From This proves cid4 ASN Consider Y ASN Y cid15 X By minimality X Y l X cid4 cid4 cid4 cid4 cid4 Proposition 11 Let P consistent normal logic program let l Lit P literal If negative cycle DG P contains l forget3P l outputs Nacyclic program Proof The result consequence fact program P described dependency graph DG N0 program N0 Step 1 forget3P l negative cycle contain l This transformations preserves property literal l occur negative cycle DG P 0 original program P 0 T occur negative cycle DG P 1 transformed program P 1 Indeed transformation Unfolding removes edges Unfolding add positive edges l l cid4cid4 l negative edge l Thus occurrence l negative cycle DG P 1 implies occurrence l negative cycle DG P 0 negative edges l l positive edge l l positive edges l l exist literal l As consequence Step 3 N N0 replacements l D performed violate exist literal l l l cid4cid4 cid4cid4 cid4cid4 cid4cid4 cid4cid4 cid4 cid4 cid4 cid4 condition ii Nacyclicity condition vacuously true cid3 Theorem 9 Given consistent disjunctive logic program P literal l set literals X deciding X lanswer set P cid4p 2 complete Proof Deciding X ASlP NP time NP oracle 1 X ASP guessed coNP cf 22 2 exists X checked NPoracle polynomial time Consequently lanswer set checking coNPNP cid4p 2 cid4 ASP X cid4 l X X cid4 The hardness result shown reduction deciding given logic program P strong negations answer set cid4p 2 complete 22 In fact given disjunctive logic program P construct logic program P cid4 headr p bodyr r P q p p q p appears P p q fresh atoms This program P answer set X0 p false atoms true answer sets form X p X ASP It holds X0 AS pP cid4 iff P answer set cid3 cid4 Theorem 10 Given consistent normal logic program P literal l set literals X deciding X lanswer set P coNPcomplete Proof Similar proof Theorem 9 order X ASlP 1 X ASP tested polynomial time 2 exists X guessed checked polynomial time Hence deciding X ASlP NP implies lanswer set checking coNP cid4 ASP X cid4 l X Such X cid4 The hardness result shown reduction Theorem 9 In fact note consider normal programs P normal program The problem deciding P answer set strong negation P coNPcomplete reduced deciding X0 panswer set P cid3 cid4 cid4 Theorem 11 Given consistent negative program P literal l set literals X deciding X lanswer set P coNPcomplete Proof The coNP membership follows fact given set literals X negative program P deciding X ASP polynomial Indeed X ASP iff X cid9 P X X l cid15cid9 P X l X Thus testing 1 X ASP 2 X cid4 ASP X cid4 l X feasible coNP T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1669 As coNPhardness let C C1 Ck propositional CNF atoms y1 ym C j nonempty Deﬁne N mcid12 cid2 i1 Ni C cid3 cid4 l y1 l y cid4 1 Ni yi y cid4 j yi yi C j y yi yi l y cid4 yi C j 1 cid3 j cid3 k C cid4 y cid4 cid4 l 1 cid3 cid3 m Clearly satisfying assignments C correspond onetoone answer sets N containing l Furthermore set X yi y 1 cid3 cid3 m answer set N It holds X lanswer set N iff C unsatisﬁable establishes coNPhardness cid3 cid4 Theorem 12 Given consistent disjunctive logic program P literals l l cid4 deciding forgetP l cid9c l cid4 cid5 p 3 complete Proof Given logic program P literals l l cid4 S Since deciding S ASlP cid4p l 2 problem cid5 p 3 cid4 forgetP l cid9c l cid4 holds iff exists S ASlP The cid5 p 3 hardness shown encoding quantiﬁed Boolean formulas QBFs form Z XY C It known problem deciding disjunctive logic program answer sets cid4p 2 complete 22 As shown QBF F XY C exists polynomialtime constructible logic program P F answer set cid4 Z XY C credulous inference forgetting iff F true We extend program encoding QBF F follows First P F easily extended program P F Z encoding QBF F Z XY C Z free variables parame ters Z new atoms P F Z Z occur rule heads truth assignment τ Z program P F Z τ Z P F Z z z Z τ Z true answer set iff QBF F Z τ Z evaluates true F Z τ Z results F Z replacing z Z T τ z true F τ z false More suppose loss generality C Z C1 Cr Ci cid7i1 cid7i2 cid7i3 disjunction cid4 y Y w new atoms Then P F Z consists cid4 y cid4 x X Y cid4 x literals cid7i j atoms X Y Z Let X rules cid4 cid4 x x y y y w w σ lk1 σ lk2 σ lk3 w w y cid4 w w y y cid4 x X y Y k 1 r σ maps classical literals cid7 classical literals follows cid7 x x X cid7 y y Y cid7 z z Z cid4 x y z cid7 σ cid7 cid4 Notice literals occurring P F Z w rule literals z rule bodies furthermore atoms Z occur rule bodies For void Z program P F Z amounts program P F 22 Proof Theorem 3 converting QBF QBF A simple extension proof Theorem 3 22 gives following lemma Lemma 7 For truth assignment τ Z XY C Z τ Z evaluates true iff program P F Z τ Z answer set Let Z cid4 z Z l l rule following rules cid4 z cid4 fresh atoms let P logic program obtained P F Z adding l body cid4 1 l l l cid4 z 2 z z 3 x l x 4 rule w l cid4 l cid4 z cid4 l y l y z Z cid4 l x X y Y rules 2 select truth assignment τ Z If l selected Informally rules 1 select l l program P F Z activated evaluated selected τ rules 3 4 discarded The evaluation lead answer set Sl τ iff program P F Z τ Z answer set note S contains l On cid4 1670 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 selected rules 24 active The truth assignment τ selected 2 cid4 hand l complemented X X l Sl cid4 Y Y τ holds Sl cid4 cid4 w unique answer set Sl τ Furthermore answer sets S S cid4 cid4 τ program P Now Sl τ respectively incomparable wrt Z Z τ cid4 set P iff answer set Sl evaluates true Hence τ Sl set P contains l Since P constructible polynomial time F corresponding different truth assignments τ cid4 τ lanswer τ exists P F Z τ Z answer set Lemma 7 equals XY C Z τ Z cid4 Z XY C evaluates true Since lanswer evaluates true cid4 τ lanswer set P iff F τ τ follows Proposition 6 forgetP l cid9c l 3 hardness proved cid3 wrt l Therefore τ Sl form Sl cid5 p iff F cid4 cid4 cid4 cid4 cid4 cid4 Theorem 13 Given consistent negative program P literals l l cid4 deciding forgetN l cid9c l cid4 cid5 p 2 complete Proof By Theorem 11 guess lanswer set X P l time Hence deciding forgetP l cid9c l cid5 p 2 cid4 cid4 k As cid5 p 2 hardness QBF XZ E E i1 D DNF X Z loss generality disjunct D variable Z occurs Construct program Theorem 11 C E cid4 Y X Z y1 arbitrary variable Z 1 omit clauses xi l x l 2 add clause cid4 l l l cid4 fresh literal Then set X cid4 Z z z j Z l xi X X cid4 j cid4 X set cid4 S X cid4 X cid4 cid4 x cid4 X veriﬁed NP oracle polynomial answer set N The sets S X cid4 answer sets N contain l lanswer set N iff exists satisfying truth assignment C E corresponds X S X cid4 obvious way In summary means N lanswer set l XZ E evaluates true cid3 contain l Furthermore S X cid4 iff formula true forgetN l cid9c l cid4 cid4 cid4 Theorem 14 Given consistent normal program N literals l l cid4 deciding forgetN l cid9c l cid4 cid5 p 2 complete Proof It suﬃcient note program N constructed proof Theorem 13 normal cid3 Theorem 15 Given consistent logic program P literals l l arbitrary disjunctive logic programs P ii coNPcomplete normal logic programs negative logic programs P deciding forgetP l cid9s l cid4p 2 complete cid4 cid4 Proof By Theorem 7 decide forgetP l cid9s l 2 complete logic pro grams 22 coNP complete normalnegative programs cases membership coNP follows testing X ASP polynomial cf proof Theorem 11 negative programs coNP hardness results 52 incorporating consistency requirement easy cid3 need decide P cid9s l The cid4p cid4 cid4 Proposition 13 Let P logic program let F consistent set literals Suppose 1 literal F occurs rule body P 2 rule r literal headr F Then forgetP F P RF We ﬁrst provide lemmas straightforward corollaries wellknown general Splitting Set Theo rem 47 elementary properties answer set semantics To avoid introducing necessary notions result provide selfcontainedness simple genuine proofs Lemma 8 Let P F Q P RF given Proposition 13 If S S answer set P cid4 Y cid4 cid4 answer set Q exists subset Y cid4 F Since special case Lemma 8 allows simple proof cid4 Proof Suppose S F Let Y S answer set P minimal model D answer set Q Denote D cid4 Y cid4 S S cid4 cid4 headr r RF S cid4 By assumption F S cid4 cid9 bodyr Then literal D cid4 S consistent We cid4 Y cid4 First P S P S cid4 Q S cid4 cid4 RF S X cid4 S cid4 cid4 cid9 Q S cid4 S cid9 P S Next suppose X S X cid9 P S Take X cid4 X F X Notice Y cid4 S F minimal model D cid4 X F cid9 D cid4 cid4 cid4 S implies We X X F S F Thus X S cid3 Lemma 9 Let P F Q P RF given Proposition 13 If S answer set P S F answer set Q T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 1671 cid4 Proof By P S P S Suppose Y cid4 S F Y cid4 cid9 Q S cid4 Here F Lit P F cid4 S Therefore S F answer set Q cid3 Q P easy S cid4 S Then Y cid9 P S Y S cid4 cid4 cid4 cid4 cid9 Q S cid4 P S Y Y S cid4 S F cid4 S F Thus Y S Since Y cid4 Y F Proof Proposition 13 Denote Q P RF Suppose S F S S cid4 To S answer set P cid4 Y answer set forgetP F suﬃces prove S F answer set P In fact Z cid4 cid4 Z cid4 Z F By Lemma 9 Z answer set Q Thus S answer set Q By Lemma 8 exists subset Y cid4 S cid4 cid4 cid4 cid4 cid4 answer set P Z F S Z Z means Z F S That S F answer set P cid4 On hand S cid4 By Lemma 9 S answer set Q cid3 answer set forgetP F exists F answer set S P S cid4 S F We ready prove Theorem 16 Theorem 16 Let P inheritance program let S set literals Then S inheritance answer set P iff S answer set forgetP obtained cid4 F P cid4 Proof S inheritance answer set P iff S minimal model P S iff S answer set P RF iff S answer set forgetP cid4 F Proposition 13 cid3 References 1 J Alferes J Leite L Pereira H Przymusinska T Przymusinski Dynamic logic programming A Cohn L Schubert S Shapiro Eds Proceedings Sixth International Conference Principles Knowledge Representation Reasoning Morgan Kaufmann Publishers 1998 pp 98109 2 J Alferes J Leite L Pereira H Przymusinska T Przymusinski Dynamic updates nonmonotonic knowledge bases Journal Logic Program ming 45 13 2000 4370 3 Asparagus homepage httpasparaguscsunipotsdamde Since 2005 4 R BenEliyahu R Dechter Propositional semantics disjunctive logic programs Annals Mathematics Artiﬁcial Intelligence 12 12 1994 5387 5 W Bledsoe L Hines Variable elimination chaining resolutionbased prover inequalities W Bibel RA Kowalski Eds Proceedings 5th Conference Automated Deduction CADE 1980 Lecture Notes Computer Science vol 87 Springer 1980 pp 7087 6 G Boole The Mathematical Analysis Logic G Bell London 1847 reprinted Philosophy Library New York 1948 7 S Brass J Dix Characterizations disjunctive stable semantics partial evaluation Journal Logic Programming 32 3 1997 207228 8 S Brass J Dix Semantics disjunctive logic programs based partial evaluation Journal Logic Programming 38 3 1999 167312 9 F Brown Boolean Reasoning The Logic Boolean Equations second ed Dover Publications 2003 10 F Buccafurri W Faber N Leone Disjunctive logic programs inheritance D De Schreye Ed Proceedings International Conference Logic Programming ICLP99 The MIT Press 1999 pp 7993 11 F Buccafurri W Faber N Leone Disjunctive logic programs inheritance Theory Practice Logic Programming 2 3 2002 293321 12 M Cadoli F Donini P Liberatore M Schaerf Space eﬃciency propositional knowledge representation formalisms Journal Artiﬁcial Intelligence Research 13 2000 131 13 M Cadoli FM Donini P Liberatore M Schaerf Preprocessing intractable problems Information Computation 176 2 2002 89120 14 K Clark Negation failure H Gallaire J Minker Eds Logic Data Bases Plenum Press 1978 pp 293322 15 E Dantsin T Eiter G Gottlob A Voronkov Complexity expressive power logic programming ACM Computing Surveys 33 3 2001 374425 16 A Waal J Gallagher Logic program specialisation deletion useless clauses D Miller Ed Proceedings 1993 International Sym posium Logic Programming ILPS 1993 MIT Press 1993 p 632 17 T Eiter M Fink Uniform equivalence logic programs stable model semantics C Palamidessi Ed Proceedings 19th International Conference Logic Programming ICLP 2003 Lecture Notes Computer Science vol 2916 Springer 2003 pp 224238 18 T Eiter M Fink G Sabbatini H Tompits Considerations updates logic programs M OjedaAciego IP Guzmán G Brewka LM Pereira Eds Proceedings Seventh European Workshop Logics Artiﬁcial Intelligence JELIA2000 Lecture Notes Artiﬁcial Intelligence vol 1919 SpringerVerlag 2000 pp 220 19 T Eiter M Fink G Sabbatini H Tompits On properties update sequences based causal rejection Theory Practice Logic Programming 2 6 2002 711767 20 T Eiter M Fink S Woltran Semantical characterizations complexity equivalences answer set programming ACM Transactions Computa tional Logic 8 3 Aug 2007 21 T Eiter G Gottlob The complexity logicbased abduction Journal ACM 42 1995 342 22 T Eiter G Gottlob On computational cost disjunctive logic programming Propositional case Annals Mathematics Artiﬁcial Intelli gence 15 34 1995 289323 23 T Eiter G Ianni R Schindlauer H Tompits A uniform integration higherorder reasoning external evaluations answer set programming LP Kaelbling A Saﬃotti Eds Proceedings 19th International Joint Conference Artiﬁcial Intelligence IJCAI05 Professional Book Center 2005 pp 9096 24 T Eiter G Ianni R Schindlauer H Tompits K Wang Forgetting managing rules ontologies Proceedings IEEEWICACM International Conference Web Intelligence WI 2006 Hongkong December 2006 IEEE Computer Society 2006 pp 411419 Preliminary version ALPSWS 2006 25 T Eiter K Makino G Gottlob Computational aspects monotone dualization A brief survey Discrete Applied Mathematics 2007 doi101016 jdam200704017 Preliminary version available Tech Rep INFSYS RR18430601 Institute Information Systems TU Vienna 26 E Erdem V Lifschitz Tight logic programs Theory Practice Logic Programming 3 2003 499518 27 M Gelfond V Lifschitz Compiling circumscriptive theories logic programs Proceedings 7th National Conference Artiﬁcial Intelligence AAAI 1988 AAAI PressThe MIT Press 1988 455449 1672 T Eiter K Wang Artiﬁcial Intelligence 172 2008 16441672 28 M Gelfond V Lifschitz The stable model semantics logic programming RA Kowalski KA Bowen Eds Proceedings Fifth International Conference Symposium Logic Programming ICLPSLP 1988 The MIT Press 1988 pp 10701080 29 M Gelfond V Lifschitz Logic programs classical negation DHD Warren P Szeredi Eds Proceedings Seventh International Conference Logic Programming ICLP 1990 The MIT Press 1990 pp 579597 30 M Gelfond V Lifschitz Classical negation logic programs deductive databases New Generation Computing 9 1991 365385 31 J Grant J Horty J Lobo J Minker View updates stratiﬁed disjunctive databases Journal Automated Reasoning 11 2 1993 249267 32 K Inoue C Sakama Negation failure head Journal Logic Programming 35 1 1998 3978 33 T Janhunen I Niemelä P Simons JH You Partiality disjunctions stable model semantics AG Cohn F Giunchiglia B Selman Eds Proceedings Seventh International Conference Principles Knowledge Representation Reasoning KR 2000 April 1215 Breckenridge Colorado USA Morgan Kaufmann Publishers Inc 2000 pp 411419 34 J Lang P Liberatore P Marquis Propositional independence Formulavariable independence forgetting Journal Artiﬁcial Intelligence Re search 18 2003 391443 35 J Lang P Marquis Resolving inconsistencies variable forgetting D Fensel F Giunchiglia DL McGuinness MA Williams Eds Proceedings Eighth International Conference Principles Knowledge Representation Reasoning Morgan Kaufmann 2002 pp 239250 36 J Larrosa Boosting search variable elimination R Dechter Ed Proceedings 6th International Conference Principles Practice Constraint Programming CP 2000 Lecture Notes Computer Science vol 1894 Springer 2000 pp 291305 37 J Larrosa E Morancho D Niso On practical use variable elimination constraint optimization problems stilllife case study Journal Artiﬁcial Intelligence Research 23 2005 421440 38 C Lassez K McAloon GS Port Stratiﬁcation knowledge based management JL Lassez Ed Proceedings Fourth International Confer ence Logic Programming ICLP 87 MIT Press 1987 pp 136151 39 J Lee V Lifschitz Loop formulas disjunctive logic programs C Palamidessi Ed Proceedings Nineteenth International Conference Logic Programming ICLP03 Lecture Notes Computer Science vol 2916 Springer 2003 pp 451465 40 N Leone G Pfeifer W Faber T Eiter G Gottlob S Perri F Scarcello The DLV knowledge representation reasoning ACM Transactions Computational Logic 7 3 2006 499562 41 CI Lewis A Survey Symbolic Logic University California Press 1918 reprinted Dover Pubs Inc New York 1960 Chapter II The Classic BooleSchroder Algebra Logic 42 V Lifschitz Computing circumscription AK Joshi Ed Proceedings 9th International Joint Conference Artiﬁcial Intelligence IJCAI85 Morgan Kaufmann 1985 pp 121127 43 V Lifschitz Circumscription D Gabbay C Hogger J Robinson Eds Handbook Logic Artiﬁcial Intelligence Logic Programming vol III Clarendon Press Oxford 1994 pp 297352 44 V Lifschitz Answer set programming plan generation Artiﬁcial Intelligence 138 2002 3954 45 V Lifschitz D Pearce A Valverde Strongly equivalent logic programs ACM Transactions Computational Logic 2 4 2001 426541 46 V Lifschitz L Tang H Turner Nested expressions logic programs Annals Mathematics Artiﬁcial Intelligence 25 1999 369389 47 V Lifschitz H Turner Splitting logic program P Van Hentenryck Ed Proceedings 11th International Conference Logic Programming ICLP 1994 MIT Press 1994 pp 2337 48 F Lin On strongest necessary weakest suﬃcient conditions Artiﬁcial Intelligence 128 12 2001 143159 49 F Lin R Reiter Forget R Greiner D Subramanian Eds Proceedings AAAI Fall Symposium Relevance The AAAI Press 1994 pp 154 159 Technical Report FS9402 50 F Lin Y Zhao ASSAT computing answer sets logic program SAT solvers Proceedings AAAI National Conference Artiﬁcial Intelli gence The AAAI Press 2002 pp 112117 51 F Lin Y Zhao ASSAT computing answer sets logic program SAT solvers Artiﬁcial Intelligence 157 2004 115137 52 W Marek M Truszczy nski Autoepistemic logic Journal ACM 38 3 1991 588619 53 W Marek M Truszczy nski Revision programming Theoretical Computer Science 190 1998 241277 54 J McCarthy Circumscriptiona form nonmonotonic reasoning Artiﬁcial Intelligence 13 12 1980 2739 55 A Middeldorp S Okui T Ida Lazy narrowing Strong completeness eager variable elimination Theoretical Computer Science 167 12 1996 95130 56 Y Moinard Forgetting literals varying propositional symbols Journal Logic Computation 17 5 2007 955982 57 R Moore Semantical considerations nonmonotonic logics Artiﬁcial Intelligence 25 1985 7594 58 NF Noy H Stuckenschmidt Ontology alignment An annotated bibliography Semantic Interoperability Integration Dagstuhl Seminar Proceedings vol 04391 IBFI Schloss Dagstuhl Germany 2005 59 D Pearce H Tompits S Woltran Encodings equilibrium logic logic programs nested expressions P Brazdil A Jorge Eds 10th Portuguese Conference Artiﬁcial Intelligence EPIA 2001 Lecture Notes Computer Science vol 2258 Springer 2001 pp 306320 60 R Reiter A logic default reasoning Artiﬁcial Intelligence 13 1980 81132 61 D Sacca C Zaniolo Partial models threevalued stable models logic programs negation A Nerode W Marek VS Subrahmanian Eds Proceedings Workshop Nonmonotonic Reasoning Logic Programming MIT Press 1991 pp 87101 62 C Sakama K Inoue An abductive framework computing knowledge base updates Theory Practice Logic Programming 3 6 2003 671713 63 D Subramanian R Greiner J Pearl Eds Artiﬁcial Intelligence Journal Special Issue Relevance 97 12 1997 64 C Tessier L Chaudron H Müller Conﬂicting AgentsConﬂict Management MultiAgent Systems Kluwer Academic Publishers Cambridge 2001 65 K Wang A Sattar K Su A theory forgetting logic programming Proceedings 20th National Conference Artiﬁcial Intelligence AAAI Press 2005 pp 682687 66 K Wang L Zhou Comparisons computation wellfounded semantics disjunctive logic programs ACM Transactions Computational Logic 6 2 2005 295327 67 A Weber Updating propositional formulas L Kerschberg Ed Proceedings First Conference Expert Database Systems EDS 1986 Ben jamin Cummings 1987 pp 487500 68 Y Zhang Logic programbased updates ACM Transactions Computational Logic 7 3 2006 421472 69 Y Zhang N Foo Towards generalized rulebased updates Proceedings Fifteenth International Joint Conference Artiﬁcial Intelligence IJCAI 97 Morgan Kaufmann 1997 pp 8287 70 Y Zhang N Foo Solving logic program conﬂict strong weak forgettings Artiﬁcial Intelligence 170 89 2006 739778 71 Y Zhang N Foo K Wang Solving logic program conﬂicts strong weak forgettings LP Kaelbling A Saﬃotti Eds Proceedings International Joint Conference Artiﬁcial Intelligence IJCAI 2005 AAAI Press 2005 pp 627632