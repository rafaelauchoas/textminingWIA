Artiﬁcial Intelligence 321 2023 103936 Contents lists available ScienceDirect Artiﬁcial Intelligence journal homepage wwwelseviercomlocateartint Polynomial combined ﬁrstorder rewritings linear guarded existential rules Georg Gottlob Marco Manna b Andreas Pieris cd Department Computer Science University Oxford UK b Department Mathematics Computer Science University Calabria Italy c School Informatics University Edinburgh UK d Department Computer Science University Cyprus Cyprus r t c l e n f o b s t r c t Article history Received 4 May 2021 Received revised form 19 April 2023 Accepted 25 April 2023 Available online 2 May 2023 Keywords Ontologies Existential rules Tuplegenerating dependencies Guardedness Conjunctive queries Query answering Query rewriting Combined approach We consider problem ontological query answering problem answering database query typically conjunctive query presence ontology This means query answering process need account knowledge inferred given database ontology Building ontologyaware database systems scratch sophisticated optimization techniques highly nontrivial task requires great engineering effort Therefore exploiting conventional database systems important route eﬃcient ontological query answering Nevertheless standard database systems unaware ontologies An approach ontological query answering enables use standard database systems socalled polynomial combined query rewriting originally introduced context description logics conjunctive query q ontology cid2 rewritten polynomial time ﬁrstorder query qcid2 databaseindependent way database D ontology cid2 rewritten polynomial time new database Dcid2 queryindependent way answer q presence cid2 D coincides answer qcid2 Dcid2 The computed exploiting conventional database In work focus linear guarded existential rules form robust rulebased languages modeling ontologies investigate limits polynomial combined query rewriting In particular type rewriting successfully applied linear existential rules rewritten query use power ﬁrstorder queries ii linear existential rules arity underlying schema ﬁxed rewritten query positive existential uses existential quantiﬁcation conjunction disjunction iii guarded existential rules underlying schema ﬁxed rewritten query positive existential We results reach limits standard complexitytheoretic assumptions PSpace cid3 ExpTime polynomial combined query rewriting case linear guarded existential rules 2023 The Authors Published Elsevier BV This open access article CC BY license httpcreativecommons org licenses 4 0 This paper extended revised version papers 1 2 3 Corresponding author Email addresses georggottlobcsoxacuk G Gottlob mannamatunicalit M Manna apierisinfedacuk A Pieris httpsdoiorg101016jartint2023103936 00043702 2023 The Authors Published Elsevier BV This open access article CC BY license http creativecommons org licenses 4 0 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 1 Introduction Over past decades seen shift world data public private organizations stored wellstructured relational databases modest size treated complete world data large heterogeneous distributed different sources incomplete This makes task extracting useful information data means queries extremely tedious complex At time massive amounts data large amounts knowledge application domain data form taxonomies fullﬂedged ontologies This gave rise new research ﬁeld recently dubbed knowledgeenriched data management 4 lies intersection data management knowledge representation reasoning A major challenge knowledgeenriched data management provide end users ﬂexible integrated access data exploiting available knowledge underlying application domain This builds hypothesis end users deep understanding speciﬁc domain able formulate complex queries understand performance implications Ontologybased data access OBDA 5 known ontologybased data integration proposed general paradigm addressing central challenge It facilitates access data separating end user raw data sources This ontology models underlying application domain semantically linked data declarative mappings mediator data sources end user The purpose ontology twofold 1 It provides integrated global view data close conceptual model underlying application domain end user good understanding This makes raw data accessible database queries formulated solely vocabulary ontology requiring knowledge actual structure data sources 2 It enriches possibly incomplete data sources domain knowledge This allows infer new knowledge explicit data enabling complete answers queries The main algorithmic task underlying OBDA paradigm querying knowledgeenriched data words querying data presence ontology This means query answering process need account inferred knowledge This problem known ontological query answering 11 Query rewriting Building ontologyaware database systems scratch sophisticated optimization techniques highly non trivial task requires great engineering effort An alternative route eﬃcient ontological query answering use conventional database management systems DBMSs The fact DBMSs unaware ontologies addressed query rewriting database query q typically conjunctive query ontology cid2 rewritten new query qcid2 socalled rewriting computes answer q presence cid2 input databases It course essential qcid2 expressed language handled standard DBMSs The typical language ﬁrst order FO queries The Pure Approach What described socalled pure approach FO rewritability sense FO rewriting qcid2 powerful compute correct answer given query q given ontology cid2 input databases This essentially means construction qcid2 independent database The advantage pure approach FO rewritability clear precompute qcid2 oﬄine database D changes simply need reevaluate qcid2 D having recompute This approach successfully applied range lightweight description logics mainly members DLLite family 6 classes existential rules linear existential rules 78 details existential rules given On hand pure approach FO rewritability comes inevitable shortcomings 1 Query rewriting algorithms generate reasonably sized conjunctive query large FO query prohibitive eﬃcient execution standard database We actually know lightweight ontology languages DLLiteR 6 logical underpinning OWL 2 QL proﬁle OWL 21 FO rewriting polynomial size polynomial hierarchy collapses 9 Further strong evidence nonexistence FO rewriting polynomial size case DLLiteR given 10 In particular shown existence FO rewriting equivalent major open problem computational complexity NC1 NPpoly2 We know exponential blowup provably unavoidable rewriting existential positive FO query FO query uses existential quantiﬁcation conjunction disjunction 9 1 httpswwww3 org TR owl2 proﬁles OWL _2 _QL 2 NC1 class decision problems decidable uniform Boolean circuits polynomial number gates inputs depth O log n NPpoly nonuniform analogue NP 2 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 2 FO rewritability applies lightweight ontology languages data complexity ontological query answering query ontology considered ﬁxed low More precisely problem eval uating ﬁxed FO query input database known AC03 class properly contained DLogSPace Therefore useful formalisms PTimehard DLogSpacehard data complexity description logic EL 11 immediately excluded The Combined Approach To overcome shortcomings ﬁner approach FO rewritability proposed context description logics known combined approach 12 The crucial difference compared pure approach rewriting database queryindependent way possible More precisely conjunctive query q ontology cid2 rewritten new query qcid2 databaseindependent way database D ontology cid2 rewritten new database Dcid2 queryindependent way answer q presence cid2 D coincides answer qcid2 Dcid2 It shown shortcomings pure approach FO rewritability discussed overcome adopting combined approach It successfully applied range lightweight description logics mainly members DLLite EL families guarantee database query rewriting feasible polynomial time 1214 It applied description logics members DLLite EL families 15 12 Research challenges All results discussed concerning combined approach FO rewritability description logics But rulebased ontology languages It generally agreed rulebased ontologies wellsuited data intensive applications OBDA allow conveniently deal higherarity relations naturally appear standard relational databases Therefore studying combined approach FO rewritability applied rulebased ontology languages highly relevant task deserves attention Towards direction focus ontologies modeled existential rules called tuplegenerating dependencies ﬁrstorder sentences form x y φx y z ψx z φ ψ conjunctions atoms Sentences form known literature Datalog rules 16 However ontological query answering arbitrary existential rules undecidable 17 This led intensive research activity decade identifying restrictions existential rules lead decidability The basic decidable paradigms emerged effort guardedness 1718 weakacyclicity 1920 stickiness 21 shyness 22 In work concentrate guardedness investigate limits polynomial combined approach FO rewritability term polynomial refers fact database query rewriting feasible polynomial time An existential rule guarded φ atom contains guards universally quantiﬁed variables 17 A central subclass guarded existential rules linear existential rules existential rules φ consists single atom 7 Interestingly main members EL family description logics certain normal form special cases guarded existential rules main members DLLite family modulo easily handled features special cases linear existential rules By employing simple complexitytheoretic arguments delineate limits polynomial combined approach FO rewritability case guarded linear existential rules Targeting Arbitrary FO Queries Evaluation FO queries known PSpacecomplete Thus rewritten query freedom use power FO queries unlikely polynomial combined approach applied ontology languages complexity ontological query answering PSpace This immediately excludes guarded existential rules ontological query answering 2Exptimecomplete 17 It actually excludes class guarded existential rules arity underlying schema ﬁxed PSpace ExpTime case ontological query answering known ExpTimecomplete 17 On hand ontological query answering linear existential rules PSpacecomplete Therefore complexitytheoretic argument polynomial combined approach applied linear existential rules Targeting Existential Positive FO Queries The problem evaluating positive existential FO queries known NP complete Hence rewritten query positive existential FO query unlikely polynomial combined approach applied linear existential rules NP PSpace On hand ontological query answering guarded existential rules underlying schema ﬁxed linear existential rules arity underlying schema ﬁxed NPcomplete actually 3 The class AC0 consists languages accepted polynomialsize circuits constant depth unbounded fanin number inputs gates 3 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 result present work details given Hence complexitytheoretic argument polynomial combined approach applied cases rewritten FO query positive existential The discussion leads following fundamental research questions concerning limits polynomial combined approach FO rewritability 1 Is applicable linear existential rules rewritten query use power FO queries 2 Is applicable linear existential rules arity underlying schema ﬁxed rewritten FO query positive existential 3 Is applicable guarded existential rules underlying schema ﬁxed rewritten FO query positive existential 13 Summary contributions The goal present work provide answers challenging questions Our main results summa rized follows In Section 3 linear existential rules enjoy socalled bounded witness property Theorem 31 This sult essentially tells ontological query answering linear existential rules suﬃces apply bounded number inference steps bound depends set rules CQ input database This result independent allows provide answers main research questions Note result obtained 23 singlehead linear existential rules linear existential rules atom righthand implication However result straightforwardly transferred singlehead multihead linear existential rules We provide proof deals linear existential rules generality In Section 4 polynomial combined approach applicable linear existential rules ii applicable rewriting positive existential FO query providing arity underlying schema ﬁxed Theorem 41 This result heavily relies fact linear existential rules enjoy bounded witness property As corollary ontological query answering case linear existential rules schemas ﬁxed arity NP evaluating positive existential FO queries NP Note results linear existential rules schemas ﬁxed arity item ii Theorem 41 NP upper bound ontological query answering known singlehead linear existential rules 923 We provide proofs deal linear existential rules generality Finally Section 5 polynomial combined approach applicable guarded existential rules rewriting positive existential FO query providing underlying schema ﬁxed Theorem 51 This result exploits item ii Theorem 41 fact polynomial combined approach applicable linear existential rules rewriting positive existential FO query providing arity underlying schema ﬁxed In fact provide polynomialtime combined reduction ontological query answering guarded existential rules ﬁxed schemas ontological query answering linear existential rules schemas ﬁxed arity apply item ii Theorem 41 As corollary ontological query answering case guarded existential rules ﬁxed schemas NP The complexity result known singlehead guarded existential rules 17 This recently brought attention colleague 24 explicitly discussed 25 We proof deals guarded existential rules generality Singlehead vs Multihead Existential Rules We conclude introductory section discussing subtle issue singlehead multihead existential rules As mentioned results known singlehead existential rules This sound contradictory general assumption ontological query answering purposes allowing conjunction atoms righthand existential rule actually syntactic sugar This convert set cid2 existential rules set cid21 existential rules atom righthand cid2 cid21 logically equivalent equivalent ontological query answering This fact relies simple transformation replaces existential rule σ cid2 form cid2 x y φx y z R1x1 z1 Rnxn zn xi x zi z set existential rules cid2 x y φx y z Auxσ x z xzAuxσ x z R ixi zi 1 n 4 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 Auxσ fresh predicate occurring cid2 Notice cid2 linear resp guarded cid21 linear resp guarded Due transformation usually case ontological query answering linear guarded existential rules studied assumption righthand existential rule atom The reason purely technical simplify technical deﬁnitions proofs Although simplifying assumption general affecting generality results true schemas ﬁxed arity ﬁxed schemas This start set existential rules ﬁxed schema obtained set singlehead existential rules transformation mentions unbounded number new predicates unbounded arity auxiliary predicates 2 Preliminaries We consider disjoint countably inﬁnite sets C N V constants nulls variables respectively We refer constants nulls variables terms For integer n 1 write n set 1 n Relational Instances Consider countably inﬁnite set Rel relation symbols called predicates associated arity We write arR arity predicate R A relational schema S ﬁnite subset Rel We write arS arity S number maxRSarR An atom S expression form Rt R S t tuple terms For atom α domα nullα varα set terms nulls variables respectively notations naturally extend sets atoms Given set terms T deﬁne BT S Rt R S t T arR set atoms formed terms T predicates S An instance S possibly inﬁnite set atoms S constants nulls database S ﬁnite instance S constants We write D family databases We write DS S ﬁnite inﬁnite family schemas family databases schema S S Homomorphisms A homomorphism set atoms A set atoms B function h dom A domB identity C Rht B Rt A We write A B fact homomorphism A B For set terms S A B Sisomorphic denoted A cid11S B 11 homomorphism h A B identity S h 1 maps B A Queries A ﬁrstorder query FO schema S expression qx x φ φ ﬁrstorder formula uses predicates S mentions constants variables x tuple possibly repetitions free variables φ free variable φ occurs x We q existential positive FO φ uses existential quantiﬁcation conjunction disjunction For database D S evaluation qx D denoted qD set tuples cid4 x c x D FO φc cid3 c domD c x denotes fact c c1 cn compatible x x1 xn xi x j implies ci c j φc sentence obtained instantiating free variable φ corresponding constant c FO denotes standard active domain semantics ﬁrstorder logic Recall active domain semantics essentially mean quantiﬁed variables range terms occurring underlying database active domain active domain semantics Let FO FO family FO FO A subclass ﬁrstorder queries central present work conjunctive queries actually corre sponds ﬁrstorder queries use existential quantiﬁcation conjunction In particular conjunctive query CQ schema S formula form queries qx y cid6 cid2 cid5 R1 v 1 Rm vm cid9 cid7cid8 φ R v atom nulls variable mentioned v s appears x y x tuple possibly repetitions free variables φ free variable φ occurs x If x q Boolean CQ For instance I S evaluation qx I denoted qI set cid3 c domI C x c x qc I cid4 tuples constants c qc mapped homomorphism I notice abuse termi nology treat conjunction atoms set atoms Let CQ family CQs For family schemas S let CQS family CQs schema S Note evaluation CQs deﬁned databases instances This needed arbitrary FO FO queries rest paper evaluated databases 5 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 Tuplegenerating Dependencies A tuplegenerating dependency TGD σ schema S ﬁrstorder sentence form cid2 cid5 φx y z ψx z x y φ ψ nonempty conjunctions atoms S mention variables For brevity write σ φx y z ψx z use comma instead joining atoms We φ ψ body head σ denoted bodyσ headσ respectively An instance I S satisﬁes σ written I σ φx y I homo morphism h ψx z I homomorphism h agrees h x The instance I satisﬁes set cid2 TGDs written I cid2 I σ σ cid2 Let T GD family ﬁnite sets TGDs4 A class C TGDs subset T GD We write CS S family schemas class TGDs cid2 C cid2 schema S cid14 Guardedness Linearity A TGD σ guarded exists atom bodyσ called guard contains body variables By convention leftmost body atom guarded TGD σ guard denoted guardσ atoms atoms σ We write G class sets guarded TGDs A subclass G crucial work class linear TGDs denoted L collects sets TGDs bodyatom Ontological Query Answering Given database D set cid2 TGDs schema S model D cid2 possibly inﬁnite instance I D I cid2 We write modsD cid2 set models D cid2 The certain answers CQ q S wrt D cid2 deﬁned set tuples certq D cid2 cid10 qI ImodsDcid2 Ontological query answering problem computing set certq D cid2 The associated decision problem deﬁned follows Let C class TGDs PROBLEM INPUT QUESTION OQAC A database D set cid2 C TGDs CQ qx tuple c domDx Does c certq D cid2 Polynomial Combined Rewritability We introduce central notion polynomial combined ﬁrstorder rewritabil ity As discussed Introduction proposed alternative query rewriting aim overcoming limitations standard ﬁrstorder rewritability approach ontological query answering A database rewriter function takes input database set TGDs outputs database query rewriter function takes input CQ set TGDs outputs FO query We clear domain codomain database query rewriters A class C T GD TGDs polynomially combined FOrewritable resp FO rewritable polynomialtime computable database query rewriters f DB D C D f Q CQ C FO resp f Q CQ C FO respectively database D set cid2 C CQ q certq D cid2 qcid2Dcid2 Dcid2 f DBD cid2 qcid2 f Qq cid2 The deﬁned analogously case focus family schemas S More precisely CS polynomially combined FOrewritable resp FO rewritable polynomialtime computable database query rewriters f S DB DS CS D f S Q CQS CS FO resp f S Q CQS CS FO Q q cid2 respectively database D DS set cid2 CS CQ q CQS certq D cid2 qcid2Dcid2 Dcid2 DBD cid2 qcid2 f S f S The Chase Procedure The chase procedure useful algorithmic tool reasoning TGDs Let ﬁrst deﬁne single chase application A trigger set cid2 TGDs instance I pair σ h σ cid2 h homomor cid14headσ h phism bodyσ I An application σ h I returns instance J I h extends h cid14z N domI ii distinct existentially quantiﬁed way existentially quantiﬁed variable z σ h variables z w σ h cid14w Such trigger application denoted Icid17σ hcid18 J cid14z cid3 h cid14 The main idea chase starting database D exhaustively apply distinct triggers given set cid2 TGDs instance constructed far ﬁxpoint reached This formalized follows 4 We work ﬁnite sets TGDs Thus rest paper set TGDs ﬁnite 6 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 A ﬁnite sequence instances Ii0in D I0 n 0 chase derivation D wrt cid2 0 n trigger σ h cid2 Ii Iicid17σ hcid18Ii1 ii 0 j n assuming Iicid17σi hicid18Ii1 I jcid17σ j h jcid18I j1 σi σ j implies hi cid3 h j iii trigger σ h cid2 In σ h σi hi0in In case result chase ﬁnite instance In An inﬁnite sequence instances Iii0 chase derivation D wrt cid2 0 exists trig ger σ h cid2 Ii Iicid17σ hcid18Ii1 ii j 0 cid3 j assuming Iicid17σi hicid18Ii1 I jcid17σ j h jcid18I j1 σi σ j implies hi cid3 h j iii 0 trigger σ h cid2 Ii exists j I jcid17σ hcid18I j1 The called fairness condition ensures triggers applied The result chase inﬁnite instance cid11 i0 Ii We write chaseδD cid2 result ﬁnite inﬁnite chase derivation δ D wrt cid2 The key property chase follows Proposition 21 Consider database D set cid2 TGDs chase derivation δ D wrt cid2 For instance I modsD cid2 holds chaseδD cid2 I In later technical proofs silently use crucial consequence result tuple c belongs certq D cid2 iff exists preﬁx Ii0in n 0 chase derivation D wrt cid2 c qIn We conclude discussion chase procedure deﬁning useful relation result chase derivations Consider chase derivation δ Iii0 database D wrt set cid2 TGDs assume 0 Iicid17σi hicid18Ii1 The parent relation δ denoted p δ β iff 0 α hibodyσi β Ii1 Ii Let p δ forms possibly inﬁnite directed acyclic graph δ binary relation chaseδD cid2 α p transitive closure p δ Note p δ 3 Bounded witness property linearity We start analysis introducing socalled bounded witness property class TGDs class linear TGDs enjoys property This essentially tells ontological query answering purposes suﬃces apply bounded number chase steps bound depends set TGDs CQ input database As shall fact linear TGDs enjoy bounded witness property crucial obtaining desired polynomial combined ﬁrstorder rewritings subject Sections 4 5 Deﬁnition 31 Bounded Witness Property A class C TGDs enjoys bounded witness property f f computable function C CQ natural numbers database D set cid2 C TGDs CQ qx c certq D cid2 implies existence sequence Ii0in n f cid2 q preﬁx chase tuple c C derivation D wrt cid2 c qIn We simply C enjoys bounded witness property enjoys bounded witness property computable function f C CQ natural numbers5 cid2 x We proceed main result section class linear TGDs enjoys bounded witness property We ﬁrst deﬁne function fL maps L CQ natural numbers Given set cid2 TGDs CQ q schema S fLcid2 q cid2 S 2 q arS arSarS It clear fL computable function We proceed Theorem 31 L enjoys bounded witness property fL The proof Theorem 31 proceeds main steps 1 We characterize L enjoys bounded witness property fL parsimonious quasi chase derivations sequences preﬁx chase derivation number distinct triggers involved bounded fL 2 We focus L fact tuple certain answer witnessed parsimonious quasi chase derivation 5 When f polynomial function known literature polynomial witness property 9 7 G Gottlob M Manna A Pieris 31 Some auxiliary notions Artiﬁcial Intelligence 321 2023 103936 Before technical details steps ﬁrst need introduce auxiliary technical notions needed proof cid14headσ h cid14 cid14z N domI distinct existentially quantiﬁed variables z w σ h Quasi Chase Derivations Let σ h trigger set cid2 TGDs instance I A partial application σ h I returns instance J I K K h extends h way existentially cid14w quantiﬁed variable z σ h Such partial application denoted Icid17σ hcid18p J A sequence instances Ii0in n 0 quasi chase derivation resp quasi chase derivation total applications D wrt cid2 0 n exists trigger σ h cid2 I Iicid17σ hcid18p Ii1 resp Iicid17σ hcid18Ii1 Observe quasi chase derivation total applications trivially quasi chase derivation opposite necessarily true A quasi chase derivation δ Ii0in Iicid17σi hicid18p Ii1 k parsimonious k 0 σi hi k k distinct triggers involved δ The parent relation δ denoted p δ transitive closure p deﬁned usual In nutshell quasi chase derivation chase derivation exactly chase derivation cid14z cid3 h 0in cid11 δ following reasons 1 applications partial trigger application atoms generated 2 triggers repeat trigger different applications 3 triggers applied Of course case quasi chase derivations total applications reasons apply Moreover triggers repeat kparsimonious quasi chase derivation k distinct triggers generation Contractions Consider database D set cid2 L TGDs quasi chase derivation δ Ii0in n 0 D wrt cid2 Let A In h function dom A domIn The A hcontraction δ sequence instances δcid14 J i0in 0 n6 cid4 cid4 J Ii cid3 α α Ii A p δ α cid3 hα α Ii A p δ α For notational convenience write A p δ α atom β A To understand essence notion contraction observe ﬁrst consider linear TGDs p δ actually forms forest atoms D roots talk subtree atom Now simple words A hcontraction δ essentially obtain updating according function h atoms subtrees p δ rooted A A simple example illustrates notion contraction follows δ α fact β p Example 31 Consider database D Ra b set cid2 L consisting σ1 Rx y zw P x z P y w σ2 P x y S y x σ3 Sx y z T x z T y z Let δ I0 I1 I6 quasi chase derivation D wrt cid2 I0 D I1 I0 P 1 P b 2 I2 I1 S1 I3 I2 P 3 P b 4 I4 I3 S3 I5 I4 T 3 5 T 6 I6 I5 S4 b It easy verify δ quasi chase derivation D wrt cid2 Let A P 3 P b 4 I6 h function dom A domI6 ha hb b h3 1 h4 2 The A hcontraction δ sequence instances δcid14 J 0 J 1 J 6 6 Note notion different wellknown notion homomorphism contraction 8 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 J 0 D J 1 J 0 P 1 P b 2 J 2 J 1 S1 J 3 J 2 P 3 P b 4 J 4 J 3 J 5 J 4 T 1 5 T 6 J 6 J 5 S2 b In words sequence δcid14 α Ii A p δ α hα cid2 obtained δ follows 0 1 6 J obtained replacing We discuss details proof Theorem 31 32 Bounded witness property parsimonious quasi chase derivations The characterization bounded witness property fL parsimonious quasi chase derivations step 1 proof Theorem 31 follows Proposition 31 The following equivalent 1 L enjoys bounded witness property fL 2 For database D set cid2 L CQ qx tuple c C x quasi chase derivation total applications Ii0in D wrt cid2 c qIn c certq D cid2 implies exists fLcid2 qparsimonious Let k fLcid2 q It clear 1 implies 2 preﬁx chase derivation length k D wrt cid2 deﬁnition kparsimonious quasi chase derivation D wrt cid2 The direction immediate kparsimonious quasi chase derivation δ D wrt cid2 total applications necessarily preﬁx length k chase derivation D wrt cid2 triggers repeat Thus eliminate δ repeated triggers introducing repetitions triggers end ﬁnite preﬁx chase derivation D wrt cid2 length k turn implies bounded witness property fL This achieved iterative contractions explain Assume trigger σ h applied steps j j H H j set atoms generated ith jth step respectively The key observation H cid11S H j S domH domH j Due linearity safely subtrees rooted H j corresponding atoms H consistently update atoms introducing repetitions triggers This essentially H j μcontraction δ μ Sisomorphism H j H This seen Example 31 Observe instances I1 I3 quasi chase derivation δ obtained applying trigger σ1 h hx h y b δcid14 obtained moving subtrees rooted P 3 P b 4 corresponding atoms P 1 P b 2 consistently updating atoms The discussion formalized following technical lemma For quasi chase derivation δ I i0in cid14 Iicid17σi hicid18Ii1 write H δ set atoms generated ith step set atoms h extension hi employed trigger application Iicid17σi hicid18Ii1 cid14 iheadσi h Lemma 31 Consider database D set cid2 L CQ qx tuple c C Let δ Ii0in quasi chase derivation total applications D wrt cid2 Iicid17σi hicid18Ii1 assume c qIn For pair indices 0 k cid9 n σk hk σcid9 hcid9 let δkcid9 J i0in H cid9 δ The following hold δ μcontraction δ μ domH k δ isomorphism H cid9 δ domH cid9 δ Hk x 1 δkcid9 quasi chase derivation total applications D wrt cid2 0 1 n 1 homomor phism μi bodyσi J J icid17σi μicid18 J i1 p 2 There α J n H cid9 δ δkcid9 3 For j 0 1 n 1 σi hi σ j h j iff σi μi σ j μ j 4 c q J n H cid9 δ Hk δ α Proof For 0 1 n deﬁne sets atoms cid3 cid4 I α Ii H cid9 δ p δ α I Ii I 9 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 In simple words I contraction By construction atoms Ii reachable atom H cid9 δ atoms updated μ I μI J μI μI μIi H cid9 δ I H cid9 δ I implies μIi J 0 1 n We deﬁne 0 1 n function μi μ hi We proceed prove statements claimed Lemma 31 1 We need 0 n 1 J icid17σi μicid18 J i1 J i1 J μcid14 μi We ﬁrst σi μi trigger cid2 J We know hibodyσi Ii Since μIi J μhibodyσi J Since deﬁnition μi μ hi σi μi trigger cid2 J It remains exists μcid14 hi cid14 Ii1 Ii h iheadσi J i1 Since μ isomorphism clear μcid14 cid14 iheadσi Since μIi1 J i1 conclude μh cid14 extension μi claim follows iheadσi By hypothesis know exists h μi J i1 J μcid14 iheadσi μcid14 2 This consequence contraction operator triggers deﬁned In fact easy induction δ Note δ μ replaces terms terms possible following new triggers atoms μI atom μI δ domHk domHk n contains term domH cid9 δ domH cid9 n descendants Hk 3 This statement direct consequence fact μi μ hi μ j μ h j μ isomorphism 4 By hypothesis qc In homomorphism h This implies μ h maps qc J n Observe μIn H cid9 δ δ domHk δ domH cid9 μ h δ cid14 δ immediately implies μ h maps qc J n H cid9 Hk δ Hk δ needed This completes proof Lemma 31 cid2 We explain direction 2 implies 1 Proposition 31 shown Assume c certq D cid2 By hypothesis exists fLcid2 qparsimonious quasi chase derivation total applications δ Ii0in D wrt cid2 c qIn By iteratively applying Lemma 31 eventually construct fLcid2 qparsimonious quasi chase derivation total applications δcid14 J i0in D wrt cid2 J icid17σi hicid18 J i1 0 j n exists 0 j σi hi σ j h j α J n H j c q J n H δ H δ j δ p δcid14 α Therefore drop applications δcid14 K i0im m fLcid2 q preﬁx chase derivation D wrt cid2 c qKm needed use trigger applied order obtain δcid14cid14 33 Ontological query answering parsimonious quasi chase derivations We proceed second step proof Theorem 31 class linear TGDs fact tuple certain answer witnessed kparsimonious quasi chase derivation k given function fL Proposition 32 Consider database D set cid2 L CQ qx tuple c C parsimonious quasi chase derivation total applications J i0in D wrt cid2 c q J n x If c certq D cid2 exists fLcid2 q To establish result suﬃces preﬁx Ii 0in chase derivation D wrt cid2 wit nesses fact c certq D cid2 c qIn converted fLcid2 qparsimonious quasi chase derivation total applications J i0in D wrt cid2 c q J n To end rely iterative contractions explain Consider Sisomorphic atoms α β In α appear subtree rooted β S set terms occurring hqc h homomorphism maps qc In Due linearity safely subtree rooted β α consistently update atoms affecting fact c certain answer We achieve β μcontraction Ii0in μ Sisomorphism β α7 Notice 7 For singleton instance γ simply write γ 10 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 contraction create partial applications repeated triggers Hence result necessarily preﬁx chase derivation quasi chase derivation This formalized following technical lemma Lemma 32 Consider database D set cid2 L CQ qx tuple c C wrt cid2 qc In h For atoms α β In β p β μcontraction δ μ Sisomorphism β α The following hold Let δ Ii0in quasi chase derivation D δ α α cid11S β S domhqc let δαβ J i0in x 1 δαβ quasi chase derivation D wrt cid2 2 There γ J n β p δαβ 3 For γ γ cid14 J n γ cid11S γ cid14 4 qc J n h γ iff μ1γ cid11S μ1γ cid14 Proof For 0 1 n deﬁne sets atoms cid3 cid4 I γ Ii β p δ γ I Ii I In simple words I Moreover deﬁne set integers atoms Ii reachable β atoms updated μ contraction X hibodyσi β β p We ﬁnally deﬁne 0 1 n function δ hibodyσi μi cid12 μ hi X hi We proceed statements Lemma 32 1 We 0 1 n J icid17σi μicid18p J i1 By hypothesis exists h cid14 hi Ii1 Ii cid14 iheadσi We proceed case analysis h hibodyσi cid3 β hibodyσi I Since X μi hi Since I J i1 J Ii1 Ii X conclude J icid17σi μicid18p J i1 h J μibodyσi J σi μi trigger cid2 J Since cid14 μi hibodyσi I hibodyσi β Since X μi μ hi Clearly μβ μhibodyσi α Since α I J μibodyσi J σi μi trigger cid2 J Since J i1 J μ1Ii1 Ii X conclude J icid17σi μicid18p J i1 μ h I μi cid14 hibodyσi I Since μI μIi1 Ii X J icid17σi μicid18p J i1 μ h J μhibodyσi μibodyσi J σi μi trigger cid2 J Since J i1 J μi 2 This consequence contraction operator triggers deﬁned Actually easy induction n descendants α Note possible following new triggers atoms μI atom μI n contains term domβ S μ replaces terms terms domα S cid14 3 This statement follows fact μ1 Sisomorphism 4 This holds γ J n domγ S γ In domγ S This completes proof Lemma 32 cid2 We ready explain Proposition 32 shown By hypothesis exists preﬁx δ Ii0in n 0 chase derivation D wrt cid2 qc In homomorphism h By deﬁnition δ quasi chase derivation D wrt cid2 The binary relation cid11S In S domhqc equivalence relation Let Incid11S set equivalence classes In wrt cid11S For equivalence class C Incid11S canonical atom arbitrarily chosen set atoms α C β C β p δ α For atom α In write α canonical atom equivalence class ια Sisomorphism maps α α We proceed construct fLcid2 qparsimonious quasi chase derivation total applications δcid14 J i0in D wrt cid2 c q J n Let α In α cid3 α By Lemma 32 α ιαcontraction δα Iα 0in δ enjoys following properties δα quasi chase derivation D wrt cid2 β J n α p δα β 11 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 β βcid14 J n β cid11S βcid14 qc J n h iff ι1 α β cid11S ι1 α βcid14 We iteratively apply Lemma 32 discussed quasi chase derivation δcid23 I wrt cid2 following hold cid23 0in D 1 For α I 2 qc I cid23 n α cid3 α implies β I cid23 n h cid23 n α δcid23 β Note δcid23 necessarily total applications However converted total applications simply adding atoms needed order ensure application δcid23 total Let δcid14 J i0in resulted quasi chase derivation total applications D wrt cid2 It clear qc J n h c qIn It remains δcid14 fLcid2 qparsimonious Since δcid14 canonical atoms trigger TGDs ﬁrst property δcid23 stated inherited δcid14 suﬃces count triggers cid2 instance K α α canonical atom set C Jncid11S formed Due linearity assume loss generality δcid14 q atoms D trigger TGD cid2 implies K contains q atoms D Therefore assuming cid2 q schema S K S cid2 cid5 2 q arS arS arS number nonS consists set S set constants T occurring atoms D trigger TGD Actually upper bound consequence fact S q arS T q arS Since atom K trigger TGDs cid2 total number triggers cid2 K formed fLcid2 q needed isomorphic atoms S formed S Theorem 31 follows Propositions 31 32 34 Bounded witness property linear TGDs normal form In proofs Section 4 class linear TGDs polynomially combined ﬁrstorder rewritable technically convenient work linear TGDs normal form TGDs atom head contains occurrence existentially quantiﬁed variable appears position headatoms To end establish result similar Theorem 31 linear TGDs normal form Let ﬁrst recall normalization procedure Consider linear TGD σ schema S form P x y z1 zm R1x1 z1 Rnxn zn n m 0 xi x zi z1 zm m x set linear TGDs consisting cid11 xi z1 zm cid11 zi We deﬁne Nσ Aux1 P x y z1 Aux1 σ x z1 z2 Aux2 σ x z1 σ x z1 z2 Auxm1 σ Auxm x z1 zm1 zm Auxm σ x z1 zm R1x1 z1 σ x z1 zm Auxm σ x z1 zm Rnxn zn σ Auxm cid11 auxiliary predicates Aux1 set Ncid2 set N σ belong schema S Given set cid2 linear TGDs deﬁne σ cid2 Nσ The easy lemma collects useful facts concerning normalization procedure Lemma 33 Consider set cid2 L schema S The following hold 1 Ncid2 computed polynomial time size cid2 12 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 2 Given database D CQ qx S certq D cid2 certq D Ncid2 Note item 2 Lemma 33 holds fact auxiliary predicates introduced normalization occur D q Recall goal establish result similar Theorem 31 class linear TGDs normal form precisely class TGDs LN Ncid2 cid2 L Of course surprising LN enjoys bounded witness property fL LN L immediate consequence Theorem 31 Thus goal new result simply LN enjoys bounded witness property property holds function provides bound wrt original set TGDs normalization Since normalization procedure preserve arity predicates8 result particularly important showing section case schemas ﬁxed arity class linear TGDs polynomially combined FO rewritable It diﬃcult verify pair sets TGDs cid21 cid22 L Ncid21 Ncid22 implies cid21 cid22 actually consequence normalization procedure Therefore given set cid2 LN TGDs exists unique set cid2 Ncid2 In simple words cid2 TGDs L denote cid2 unique set linear TGDs obtain denormalizing cid2 We write exvarσ set existentially quantiﬁed variables occurring TGD σ We deﬁne function fLN maps LN CQ natural numbers follows cid13 cid14 fLN cid2 q max σ cid2 exvarσ max σ cid2 headσ fLcid2 q It clear fLN computable fL computable We proceed Theorem 32 LN enjoys bounded witness property fLN Proof Consider database D set cid2 LN CQ qx tuple c C We need c certq D cid2 implies existence sequence Ii0in n fLN cid2 q preﬁx chase derivation D wrt cid2 c qIn By Lemma 33 certq D cid2 certq D cid2 Since construction cid2 L Theorem 31 conclude following c certq D cid2 implies existence sequence J i0im m fLcid2 q preﬁx chase derivation D wrt cid2 c q J n Our goal convert J i0im desired sequence Ii0in n fLN cid2 q preﬁx chase derivation D wrt cid2 c qIn turn shows claim x Assume J jcid17σ j h jcid18 J j1 j 0 m 1 σ j form P x y z1 zk j R1x1 z1 Rcid9 j xcid9 j zcid9 j cid14 jheadσ j h cid14 j extension h j employed application We assume J j1 J j h σ j h j We deﬁne sequence instances 1 Ik1cid911 0 Ik0cid901 0 I 1 I 0 1 I 1 I 0 1 0 I 0 m1 I 1 m1 I km1cid9m11 m1 I 0 m j 0 m I 0 j j 0 m 1 1 k j cid4 x z1 zi I i1 J j cid3 h cid14 jAuxi σ j I j j j 0 m 1 k j 1 k j cid9 j 1 I j I i1 j cid3 h cid4 cid14 jR ik j xi k j zik j j σ k j cid9 j We proceed desired sequence instances For j 0 m 1 let σ 1 linear TGDs Nσ j TGDs obtained normalizing σ j order presented deﬁnition x z1 zi k j 1 k j cid9 j σ Nσ j In words 1 k j σ j TGD head Auxi σ j j TGD head R ik j xik j zik j It diﬃcult verify j 0 m 1 following hold j cid17σ 1 j h jcid18I 1 j I 0 j 1 k j 1 I j cid17σ i1 j hi1 j cid18I i1 j hi1 j restriction h cid14 j variables x z1 zi 8 In fact consider set TGDs schema ﬁxed arity normalized set general contain predicates unbounded arity auxiliary predicates 13 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 k j k j cid9 j 2 I j I h cid17σ k j cid9 j k j cid9 j 1 j j1 cid18I 0 cid14 j j cid17σ i1 j h cid14 j cid18I i1 j Therefore sequence instances deﬁned preﬁx chase derivation D wrt cid2 cid13 cid14 c qI 0 m It remains max j0m1 k j max j0m1 cid9 j m fLN cid2 q Observe max j0m1 max j0m1 k j max σ cid2 cid9 j max σ cid2 m fLcid2 exvarσ headσ q claim follows cid2 4 Polynomial combined rewritability linearity We proceed study notion polynomial combined rewritability case linear TGDs We family schemas S ﬁxed arity exists integer k 0 schema S S holds arS k Theorem 41 The following hold 1 L polynomially combined FOrewritable 2 For family schemas S ﬁxed arity LS polynomially combined FO rewritable Since evaluation problem FO query qx tuple c domDx given database D FO decide c qD NP immediate consequence Theorem 41 following complexity result discussed Introduction closes complexity gap problem OQAL case schemas ﬁxed arity In fact following result known singlehead atom head linear TGDs 23 straightforwardly transferred multihead atom head linear TGDs Corollary 41 OQAL NPcomplete schemas ﬁxed arity The proof Theorem 41 heavily relies Proposition 41 actually main technical result section For database D deﬁne D01 D Zero0 One1 0 1 new constants domD Zero One new predicates mentioned D In words D01 obtained adding domain D new constants 0 1 access unary predicates Zero One respectively Moreover family schemas S write LS N class cid2 LN cid2 LS essentially collects sets linear TGDs normal form denormalizing set linear TGDs schema S Proposition 41 The following hold 1 There polynomialtime computable query rewriter f Q CQ LN FO database D set cid2 LN TGDs CQ q certq D cid2 qcid2D01 qcid2 f Qq cid2 2 For family schemas S ﬁxed arity polynomialtime computable query rewriter f S Q Q q cid2 N q CQS certq D cid2 qcid2D01 qcid2 f S D DS cid2 LS CQS LS N FO Before giving proof Proposition 41 let explain Theorem 41 exploiting Proposition 41 For item 1 need polynomialtime computable database query rewriters gDB gQ respectively 14 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 database D set cid2 L CQ q certq D cid2 qcid2Dcid2 Dcid2 gDBD cid2 qcid2 gQq cid2 We deﬁne database rewriter gDBD cid2 D01 clearly computable constant time9 query rewriter gQq cid2 f Qq Ncid2 f Q polynomialtime computable rewriter provided item 1 Proposition 41 recall Ncid2 LN normalized version cid2 Since Lemma 33 Ncid2 computable polynomial time gQ computable polynomial time Moreover item 1 Proposition 41 certq D Ncid2 qcid2Dcid2 Dcid2 gDBD cid2 qcid2 gQq cid2 By Lemma 33 certq D cid2 certq D Ncid2 certq D cid2 qcid2Dcid2 needed Item 2 Theorem 41 shown similar argument relying item 2 Proposition 41 The rest section devoted showing Proposition 41 Here roadmap long proof We start Section 41 introducing main technical tool socalled witness generator formalizes intuitive idea linear TGDs ontological query answering realized reachability problem di rected graph actually forest linearity formed parent relation chase derivation In particular given database D set cid2 LN CQ qx tuple c domDx characterize fact c certq D cid2 existence witness generator qc wrt D cid2 The characterization essentially tells desired query rewriters build ﬁrstorder queries check input database D exists witness generator qd d domDx candidate certain answer wrt D cid2 To end need encode witness generator way ﬁrstorder query talk This Section 42 representing predicates nulls binary strings strings consisting 0 1 turn leads notion binary witness generator We proceed Section 43 44 establish item 1 2 respectively Proposition 41 constructing desired query rewriters 41 Witness generator Before delving formal deﬁnitions let ﬁrst illustrate key ideas underlying notion witness generator simple example Example 41 Consider database D P b c P b c d set cid2 consisting linear TGDs β w P x y w β w P z x w β P z y x β w P y z w β P x y z Boolean CQ q x yzw P x y P z y b P w c b As illustrated following ﬁgure homomorphism h dashed arrows ﬁgure maps q initial segment forest formed parent relation chase derivation δ D wrt cid2 certq D cid2 cid3 9 Notice result gDBD cid2 depend cid2 simply add D constants 0 1 15 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 It interesting observe nulls occurring hq nulls 1 3 4 5 form rooted forest F following properties let ν atom chaseδD cid2 null invented shaded atoms ν1 ν3 ν4 ν5 root node ν reachable D edge cid14 νcid14 reachable ν atom α hq unique path π F contains nulls α assuming leaf node π α reachable ν Indeed easy ν1 ν5 reachable D ν3 ν4 reachable ν1 ﬁnally hP x y P 3 1 reachable ν3 hP z y b P 4 1 b reachable ν4 hP w c b P 5 c b reachable ν5 Roughly speaking triple consisting 1 homomorphism h maps q chaseδD cid2 2 function ν gives atoms chaseδD cid2 nulls occurring hq invented 3 forest F encodes nulls hq depend order generation witness generator q wrt D cid2 The existence triple allows generate preﬁx chase derivation δ witness witness generator entails query q cid2 Let formalize intuition underlying notion witness generator described Example 41 To end ﬁrst need introduce auxiliary notions Rooted Forests A rooted tree T set V directed tree V node set T node denoted rootT root edges orientation away root The treeorder T nonstrict partial order cid24T V v cid24T u iff unique path root u passes v The corresponding strict partial order given v T u iff v cid24T u v cid3 u A rooted forest F set V collection rooted trees T 1 Tn V 1 V n respectively V 1 V n partition V We deﬁne rootF inrootT The forestorder F partial order cid24F cid24T v F u iff v cid24F u v cid3 u Let U V v u U v cid24F u u cid24F v It veriﬁed exists unique v U denoted maxF U u F v u U cid11 cid11 Witness Generator Scheme As discussed witness generator Boolean CQ q wrt database D set cid2 LN triple consisting function h maps varq constants nulls function ν assigns null nullhq atom corresponds atom invented rooted forest F nullhq Such triple order valid candidate witness generator satisfy certain properties 1 atoms hq atoms nulls hq invented contain incomparable wrt cid24F nulls hq 16 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 2 nullhq recently generated null nulls ν These formalized notion witness generator scheme Recall set T terms schema S BT S set collects atoms formed terms T predicates S Deﬁnition 41 Witness Generator Scheme Consider Boolean CQ q schema S A witness generator scheme q triple h ν F h varq C N ν nullhq BC N S F rooted forest nullhq 1 α hq ν nullhq pair nulls 1 2 nullα nullhq 1 cid24F 2 2 cid24F 1 2 nullhq maxF nullν nullhq cid2 Witness Generator We ready deﬁne key notion witness generator A witness generator essen tially witness generator scheme gives rise witness given query Consider set cid2 LN schema S We ﬁrst need inductively deﬁne binary relation cid25k cid2 BC N S k 0 follows α cid250 α cid25k cid2 β α β αcid17σ hcid18α β σ h trigger cid2 α cid2 β exists atom γ BC N S domα domβ domγ α cid25k1 cid2 γ γ cid25k1 cid2 β Intuitively α cid25k relation α cid25k cid2 β null follows cid2 β means β derivable α 2k chase steps TGDs cid2 We deﬁne α cid250 α cid25k cid2 β domβ domα αcid17σ hcid18α β σ h trigger cid2 α cid2 β exists atom γ BC N S domα domβ domγ α cid25k1 cid2 γ γ cid25k1 cid2 β Roughly α cid25k The notion witness generator follows cid2 β means β derivable α 2k chase steps TGDs cid2 invented β Deﬁnition 42 Witness Generator Consider database D schema S set cid2 LN TGDs S Boolean CQ q S A kwitness generator k 0 q wrt D cid2 witness generator scheme h ν F q 1 For rootF exists α D α cid25k 2 For edge 1 2 F ν1 cid25k2 3 For α hq maxF nullα ν cid25k 4 For α hq nullα exists β D β cid25k cid2 ν ν2 cid2 α cid2 cid2 α cid2 Note witness generator h ν F q wrt D cid2 holds range h domD N range ν BdomD N S conditions 3 4 trivially fail We proceed characterize candidate answer certain answer existence appropriate witness generator Lemma 41 Consider database D set cid2 LN TGDs CQ qx tuple c domDx The following equivalent 1 c certq D cid2 2 There exists cid26log fLN cid2 qcid27witness generator qc wrt D cid2 Proof 1 2 By Theorem 32 LN enjoys bounded witness property fLN Thus c certq D cid2 exists preﬁx Ii0in n LNcid2 q chase derivation δ D wrt cid2 c qIn This turn implies homomorphism h maps qc In For null nullhq exists unique integer n domIi domIi1 We write α single atom Ii Ii1 atom invented according δ deﬁne function ν nullhq chaseδD cid2 way ν α nullhq We ﬁnally deﬁne rooted forest F nullhq follows nullhq F forest nullhq F consists single node nullhq 1 m m 1 j 1 m cid3 j exists edge j iff δ α j Note F αi forest p δ α j integer k m j αi forms forest chaseδD cid2 linearity δ αk αk p p p δ 17 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 We triple h ν F cid26log fLN cid2 qcid27witness generator qc wrt D cid2 The fact h ν F witness generator scheme q easily veriﬁed linearity It remains conditions Deﬁnition 42 hold k cid26log fLN cid2 qcid27 To end suﬃces distinct atoms α β cid2qcid27 chaseδD cid2 α p β β atom null invented holds cid26log fLN α cid25 cid2 cid26log fLN β holds α cid25 cid2 β Assume cid2qcid27 δ α α1 p δ α2 p δ p δ αcid9 β 1 cid9 fLN cid2 q α1 αcid9 path α β forest formed p cid9cid14 2 cid2qcid27 cid9 1 sequence atoms cid26log fLN δ It easy verify α1 α2 αcid9 α1 α1 cid9 cid7cid8 cid6 cid9cid14 cid26log fLN witnesses fact α cid25 cid2 according δ needed cid2qcid27 cid26log fLN β fact α cid25 cid2 cid2qcid27 β case β atom invented cid11 n i0 hi δ 2 1 We ﬁrst observe quasi chase derivation Ii 0in n 0 D wrt cid2 following holds chase derivation δ D wrt cid2 exists homomorphism hδ maps In chaseδD cid2 This established easy inductive argument shows 0 1 n exists homomorphism hi δ Ii chaseδD cid2 0 hi δ welldeﬁned Therefore hδ deﬁned δ compatible hi1 hi1 From observation claim suﬃces existence cid26log fLN cid2 qcid27witness generator qc wrt D cid2 implies existence quasi chase derivation Ii0in n 0 D wrt cid2 c qIn Indeed case qc In In chaseδD cid2 δ chase derivation D wrt cid2 qc chaseδD cid2 c certq D cid2 needed The rest proof devoted showing 2 implies existence quasi chase derivation Ii0in n 0 D wrt cid2 c qIn Let cid14 h ν F cid26log fLN cid2 qcid27witness generator qc wrt D cid2 The construction desired quasi hi δ δ chase derivation proceeds main steps We ﬁrst construct forest F cid14 atoms induced cid14 As shall leaves forest precisely atoms hqc We apply renaming step atoms F cid14 leads forest F cid15 occurrences null semantically Then leaves F cid15 hqc renaming step alter atoms leaves F cid14 cid14 This step ensures different cid14 precisely atoms We ﬁnally convert F cid15 cid14 sequence instances Ii0in quasi chase derivation D wrt cid2 guaranteed renaming step c qIn leaves F cid15 cid14 atoms hqc Step 1 Construction F cid14 We explain rooted forest F cid14 constructed To end ﬁrst construct auxiliary forest F cid14 cid14 atoms D ν nullhq hq following edges edges For brevity let k cid26log fLN cid2 qcid27 For rootF assuming α D atom provided cid14 α cid25k cid2 ν edge α For edge 1 2 F edge ν1 ν2 For α hq maxF nullα edge ν α For α hq nullα assuming β D atom provided cid14 β cid25k cid2 α edge ν β α 2k1 β γ e We construct forest F cid14 F 1 γ e cid14 cid14 path atoms cid2 β case β ν sequence atoms witnesses α cid25k α γ e 2k1 cid14 cid14 nonempty cid14 case γ e 1 γ e Let clarify distinct edges e e F Nevertheless common atoms rise different nodes F cid14 This completes construction F cid14 It easy leaves F cid14 precisely atoms hqc leaves F cid14 cid14 follows replace edge e α β F cid2 β α cid25k γ e 2k1 cid14 cid14 precisely atoms hqc 1 γ e 1 γ e cid14 2k1 cid14 Step 2 Renaming Nulls The goal step ensure different occurrences null F cid14 semantically It case certain null subforest F cid14 induced subforest obtained keeping nodes atoms containing disconnected In case occurrences different connected components F cid14 semantically different despite fact On hand occurrences 18 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 appear connected component semantically invented propagated valid chase steps We explain renaming step works leads forest F cid15 cid14 1 T m m 1 connected components subforest F cid14 induced Let null F cid14 let T We consider following cases 1 Assume nullhqc We rename occurrence T 2 Assume nullhqc By construction exists j m T j rooted ν We rename m j The difference case occurrences j remain unchanged This captures intuition real occurrences invented ν m occurrence T T propagated valid chase steps This completes construction F cid15 cid14 We proceed establish following claim Claim 41 The following hold 1 For null F cid15 2 Let L set atoms occurring leaves F cid15 cid14 subforest F cid15 cid14 induced connected cid14 Then L hqc Proof It easy item 1 holds construction It remains item 2 Recall leaves F cid14 precisely atoms hqc It clear 11 correspondence leaves F cid14 leaves F cid15 cid14 renaming step alter structure F cid14 Thus leaf node β F cid14 refer corresponding leaf node βcid15 F cid15 cid14 Therefore suﬃces leaf node β F cid14 β βcid15 syntactically atom Consider arbitrary leaf node β F cid14 let α1 α2 αcid9 β unique path F cid14 root node β We proceed renaming step alter β turn implies β βcid15 atom needed The proof case analysis β contains null null null 1 Assume nullβ means domβ domD In case claim holds trivially renaming step constants domD renamed β βcid15 2 Assume nullβ β contains null Since deﬁnition cid14 witness generator scheme qc conclude exists atom γ α2 αcid9 γ ν Furthermore occurs β γ domβ domγ occurs atom γ β Thus β renamed renaming step β βcid15 3 Assume nullβ 1 m m 1 β contains null Since cid14 witness generator scheme qc nulls 1 m comparable wrt cid24F let 1 cid24F 2 cid24F cid24 m Furthermore conclude m 1 νi contain null i1 m Therefore atoms γ1 γm α2 αcid9 γi νi m path α1 β F cid14 form α1 γ1 γ2 γm β Moreover m null domβ domγi occurs atom γi β Therefore nulls 1 m β renamed renaming step β βcid15 This completes proof Claim 41 cid2 Step 3 Construction quasi chase derivation In step explain F cid15 sequence edges obtained traversing F cid15 cid14 breadthﬁrst fashion10 Let s s removing edges form α α α D For example F cid15 cid14 form cid14 converted desired quasi chase derivation D wrt cid2 Let s sequence edges obtained 10 Here simply need mechanism traverse F cid15 cid14 We traverse F cid15 cid14 depthﬁrst fashion 19 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 s α1 α4 α1 α1 α3 α5 α1 α1 α5 α6 α5 α7 α1 α4 α3 α5 α5 α6 α5 α7 s We inductively deﬁne sequence instances let s e1 en n 0 I0 D n ei α β Ii Ii1 β It easy Claim 41 Ii0in quasi chase derivation D wrt cid2 c qIn Let conclude proof clarifying Ii0in preﬁx chase derivation D wrt cid2 think triggers repeat trigger different applications cid2 42 Binary witness generator Lemma 41 essentially tells desired query rewriters needed establishing Proposition 41 build ﬁrstorder queries check cid26log fLN cid2 qcid27witness generator qc wrt D cid2 To end need encode witness generator way ﬁrstorder query talk The key idea underlying encoding represent predicates nulls binary strings strings consisting 0 1 binary witness generator In rest paper write ok string o o length k o symbol k 0 k 0 ok string EncodingDecoding Atoms Consider set cid2 LN CQ qx schema S P 1 P m m 1 We consider integer cid15 τ cid16 logq arS fLN cid2 q 1 suﬃciently large ensure nulls occurring witness induced cid26log fLN cid2 qcid27witness generator represented binary strings length τ We deﬁne set binary strings cid4 cid3 0i110mi m BS collects encodings predicates S In particular predicate P S encoded binary string 0i110mi We deﬁne set strings cid18 cid17 cτ c C BC collects encodings constants C Note constant c C represented string cτ The reason c represented string length τ instead c purely technical need terms constants nulls witness induced cid26log fLN cid2 qcid27witness generator represented strings length We ﬁnally deﬁne set binary strings BN b1 bτ bi 0 1 τ cid18 cid17 0τ collects encodings null values appear witness induced cid26log fLN cid2 qcid27witness generator Note string 0τ reserved padding purposes excluded set BN clear later Having sets strings BS BC BN place explain atom encoded Consider atom α P it1 tn BC BC BN S m The encoding α denoted encα string length m arS τ 0i110mi arSarP cid8 cid9cid6 cid7 0τ 0τ f t1 f tn cid12 f t tτ t t C t BC BN Note arP arS ﬁrst arS arP positions encoded atom padded special string 0τ reason 0τ BN Now string t length m arS τ form 0i110mi arSarP cid8 cid9cid6 cid7 0τ 0τ t1 tarP 20 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 t j BC BN j arP let dect atom P it1 tarP decoding t For atom α BC BC BN S let bnullα set strings domα C BC binary strings α encode nulls notation extends sets atoms The following example builds Example 41 illustrates encoding atoms binary witness generator looks like Example 42 Consider database D P b c P b c d set cid2 consisting linear TGDs β w P x y w β w P z x w β P z y x β w P y z w β P x y z Boolean CQ q x yzw P x y P z y b P w c b introduced Example 41 In following cid2 normal form assume cid2 Ncid2 coincide Recall normal form TGDs discussed Section 3 Observe D cid2 Q schema S P Clearly S 1 arS 3 cid2 4 q 3 Therefore fLN cid2 q cid2 S 2 q arS arSarS 4 1 2 3 3 33 37044 turn implies τ cid15 cid15 cid16 logq arS fLN cid2 q 1 cid16 log3 3 37044 1 19 Therefore cid4 cid3 0i110mi S cid4 cid3 c19 c C BS BC 1 BN b1 b19 bi 0 1 19 019 Consider atom α P b c Since S 1 arS arP 0 encoding encα string 1a19b19c19 Now atom P b 1 Example 41 ﬁrst encoded atom BC BC BN S α P b t t 0181 ﬁrst tuple BN according lexicographic order encodes 1 Then α encoded string 1a19b190181 The chase forest rooted forest F nulls Example 41 remain structurally key difference atoms nulls encoded described In particular hq P t3 t1 P t4 t1 b P t5 c b t1 0181 t3 01711 This completes example cid2 t4 016100 t5 016101 Binary Witness Generator Scheme The notion binary witness generator scheme deﬁned way notion witness generator scheme Deﬁnition 41 difference use binary encoding terms atoms discussed 21 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 Deﬁnition 43 Binary Witness Generator Scheme Consider Boolean CQ q schema S A binary witness generator scheme q triple h ν F h varq BC BN ν bnullhq encα α BBC BN S F rooted forest bnullhq 1 For α hq dect t bnullhq pair distinct strings t1 t2 bnullα bnullhq t1 cid24F t2 t2 cid24F t1 2 For t bnullhq t maxF bnulldecνt bnullhq cid2 Binary Witness Generator We proceed deﬁne notion binary witness generator Consider set cid2 LN cid2 k 0 encodings atoms encα α schema S We ﬁrst need deﬁne binary relation cid25k BBC BN S t cid250 t cid25k cid2 u t u dectcid17σ hcid18dect decu σ h trigger cid2 dect cid2 u v encα α BBC BN S domdect domdecu domdecv t cid25k1 cid2 u v cid25k1 cid2 v Intuitively t cid25k deﬁne relation cid25kv cid2 v BN follows cid2 u means decu derivable dect 2k chase steps TGDs cid2 We t cid250v t cid25kv cid2 u v domdecu domdect dectcid17σ hcid18dect decu σ h trigger cid2 dect cid2 u w encα α BBC BN S domdect domdecu domdecw t cid25k1 cid2 w w cid25k1v u cid2 Roughly t cid25kv decu Let clarify chase step dectcid17σ hcid18dect decu invented nulls strings BN cid2 u means decu derivable dect 2k chase steps TGDs cid2 v invented Deﬁnition 44 Binary Witness Generator Consider database D S set cid2 LN S Boolean CQ q S A binary kwitness generator k 0 q wrt D cid2 binary witness generator scheme h ν F q 1 For t rootF exists α D encα cid25kt 2 For edge t1 t2 F νt1 cid25kt2 3 For α hq t maxF bnullα νt cid25k 4 For α hq st bnullα β D encβ cid25k cid2 encα cid2 νt2 cid2 νt cid2 encα cid2 Note binary witness generator h ν F q wrt D cid2 range h cτ c domD BN range ν encα α Bcτ c domD BN S conditions 3 4 trivially fail The easy lemma follows deﬁnition shows correspondence cid26log fLN cid2 qcid27witness generators binary cid26log fLN cid2 qcid27witness generators Lemma 42 Consider database D set cid2 LN TGDs CQ qx tuple c domDx The following equivalent 1 There exists cid26log fLN cid2 qcid27witness generator qc wrt D cid2 2 There exists binary cid26log fLN cid2 qcid27witness generator qc wrt D cid2 43 Item 1 Proposition 41 We ingredients showing Proposition 41 We start ﬁrst item recall polynomialtime computable query rewriter f Q CQ LN FO database D cid2 LN CQ q By Lemmas 41 42 suﬃces deﬁne f Q way given database D set cid2 LN CQ qx certq D cid2 qcid2D01 qcid2 f Qq cid2 tuple c following equivalent 1 c qcid2D01 qcid2 f Qq cid2 2 There exists binary cid26log fLN cid2 qcid27witness generator qc wrt D cid2 Consider set cid2 LN CQ qx schema S P 1 P m m 1 We proceed deﬁne ﬁrstorder query f Qq cid2 Henceforth brevity write ω arS We assume CQ qx form 22 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 Table 1 U W possibly subscripts V τ tuples variables represent terms R Stuple variables represents predicate Yi Ai Bi variables Q Shortcut U W U W DomU NullU QNullU AtomR U1 Uω U 1 W U i1 W U W MinU MaxU W1 Wω Deﬁnition cid19 iU Ui Wi cid21cid19 cid20 i0U1 j1i U j W j ZeroUi 1 OneWi 1 cid19 Zerou Oneu uU uU Zerou Oneu cid19 cid20 cid2cid20 cid5 NullU cid21 cid20 icid9 U Yi cid19 uU Oneu cid19 cid19 OneRi im jωarP U j 0τ jωarP 1ω jmi ZeroR j cid5cid22 cid2 DomU j NullU j cid2cid20 cid5 icid91 U Ai W Bi U W V U V V 1 W cid20 icid91 U W cid5 VA U V iω U Wi iωQNullWi U Wi Wi U cid5 VB U V cid2cid20 cid19 cid5 cid2cid20 cid2cid20 qx1 xk y1 ycid9 P a1 t1 P tn The ﬁrstorder query qcid2 f Qq cid2 conjunction following components let D input database qcid2 evaluated Component 1 Guess candidate binary witness generator h ν F k hxi cτ c domD Component 2 Assuming hxi cτ k verify h ν F binary witness generator scheme qc c c1 ck Component 3 Finally verify h ν F binary cid26log fLN cid2 qcid27witness generator qc wrt D cid2 Before giving syntactic shape query f Qq cid2 let introduce variables underlying meaning use For k Xi x1 xτ represents string cτ c domD free variable xi q mapped h For cid9 Yi y1 yτ mapped h For cid9 Ai Pi T1 represents string represents string cτ c domD BN variable yi q Tω Pi p1 p S T j τ tuple distinct variables j ω encα α Bcτ c domD BN S h yi mapped ν h yi BN For cid9 1 pair Ai Bi Ai Bi τ tuples distinct variables represents edge rooted forest F bnullhq For brevity write A B sets A1 Acid91 B1 Bcid91 respectively We deﬁne Q set collects variables introduced apart variables x1 syntactic shape qcid2 1 x1 k The general Q TripleQ WitnessGeneratorSchemeQ WitnessGeneratorQ subquery Triple corresponds Component 1 discussed subquery WitnessGeneratorScheme Compo nent 2 subquery WitnessGenerator Component 3 In follows write NameQ mean free variables subquery Name Q With aim simplifying deﬁnition qcid2 use useful shortcuts given Table 1 usual Xi refer ith element tuple X The intuitive meaning shortcuts follows U W checks τ tuples U W equal 23 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 U W checks binary string length τ corresponds U seen binary number strictly binary string binary number corresponds W DomU checks U corresponds element BC This checking U contain 0 1 NullU checks U corresponds element BN QNullU checks U corresponds element BN occurs image h query corre sponds null value image existentially quantiﬁed variable yi q AtomR U1 Uω checks R U1 Uω corresponds encoding atom words corresponds element encα α BBC BN S U 1 W checks U W corresponds edge forest F U i1 W checks w reachable F u path length 1 assuming U W correspond strings u w respectively U W checks w reachable F u path assuming U W correspond strings u w respectively Note path length cid9 1 cid9 maximum number strings BN appear image query q cid9 existentially quantiﬁed variables query maximum number nodes F MinU checks U corresponds root node u F boils checking u incoming edge F MaxU W1 Wω checks u corresponds greatest element wrt cid24F w 1 wω assuming U W1 Wω correspond strings u w 1 wω respectively We ready deﬁne queries TripleQ WitnessGeneratorSchemeQ WitnessGeneratorQ rise desired FO query qcid2 The Subquery TripleQ The goal subquery perform consistency checks ensure guessed triple right syntactic form We ﬁrst need ensure free variables q mapped strings cτ c domD existentially quantiﬁed variables mapped strings cτ c domD BN This achieved query VariableConsistencyQ cid23 ik DomXi cid23 j2τ x1 x j cid23 icid9 DomYi cid23 j2τ y1 y j NullYi We need check tuples Ai represent strings encα α Bcτ c domD BN S query AtomConsistencyQ AtomAi cid23 icid9 cid23 We check ν total function query TotalFunctionQ cid2 NullYi NullY j Yi Y j Ai A j cid5 cid23 cid2 NullYi Yi Tω cid5 jcid9 icid9 The query essentially checks following existentially quantiﬁed variables yi y j q mapped h string BN holds νh yi νh y j ν function ii existen tially quantiﬁed variable yi q h yi BN h yi invented atom represented Ai ν total recall Tω term Ai represents h yi We check F rooted forest bnullhq query RootedForestQ cid23 icid91 QNullAi QNullBi cid23 icid9 cid28 NullYi cid29 cid30 Yi U UAB cid23 Ai Bi cid23 cid2 Bi B j Ai A j cid5 icid91 jcid91 Recall pair Ai Bi represents edge F Hence query checks nodes F tuples bnullhq ii tuple bnullhq occurs F iii edges A1 B1 Acid91 Bcid91 form rooted forest Consequently TripleQ deﬁned ﬁrstorder query VariableConsistencyQ AtomConsistencyQ TotalFunctionQ RootedForestQ The Subquery WitnessGeneratorSchemeQ We check guessed triple represents binary witness generator scheme qc c hx1 1 hx1 k But let ﬁrst introduce auxiliary notation 24 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 For n recall P ai ti atom q TTi deﬁned tuple ωarPai cid9cid6 cid8 0 0 cid6 cid7cid8 cid9 τ cid7 0 0 cid6 cid7cid8 cid9 τ f ti1 f tiarP ai f t t t cid6 cid7cid8 cid9 τ t1 tτ t C t x y Moreover deﬁne TT j 0 0 cid6 cid7cid8 cid9 τ f ti j j 1 ω arP ai j ω arP ai 1 ω For example ω 4 ti c y3 y1 τ 2 TTi 0 0 c c y1 TT4 1 y2 y1 1 We ready proceed queries check conditions Deﬁnition 43 3 y2 3 y1 1 y2 1 TT1 0 0 TT2 c c TT3 The ﬁrst condition α hq decνt t bnullhq pair distinct strings t1 t2 bnullα 3 y2 3 y1 bnullhq t1 cid24F t2 t2 cid24F t1 checked query WGS1Q cid23 cid23 cid21 jrω NullTT j NullTTr TT j TTr TT j TTr TTr cid22 j TT cid23 cid23 cid21 icid9 jrω QNullT j QNullTr T j Tr T j Tr Tr cid22 j T The ﬁrst conjunction implications checks α hq distinct strings bnullα comparable wrt cid24F The second conjunction implications takes care atoms νt t bnullhq In particular atom α checks distinct strings bnullα comparable wrt cid24F The second condition Deﬁnition 43 t bnullhq t maxF bnulldecνt bnullhq checked query WGS2Q cid2 cid23 QNullTω MaxTω T1 cid5 Tω icid9 Note query WGS2Q assumes following existentially quantiﬁed variable yi q h yi BN h yi invented atom decνh yi Yi Tω This guaranteed query TotalFunctionQ deﬁned Hence WitnessGeneratorSchemeQ deﬁned ﬁrstorder query WGS1Q WGS2Q The Subquery WitnessGeneratorQ We ﬁnally check guessed triple h ν F binary cid26log fLN cid2 qcid27 witness generator qc wrt input database D cid2 c hx1 k Note check witness generator scheme taken care previous query Therefore remaining task check conditions given Deﬁnition 44 1 hx1 We assume moment available subqueries π πG Intuitively speaking given A B represent strings tA tB encα α Bcτ c domD BN S respectively π A B tA cid25 cid2qcid27 cid26log fLN cid2 tB πG A B tA cid25 cid2qcid27t cid26log fLN cid2 tB t BN string length τ tB π πG deﬁned The ﬁrst condition Deﬁnition 44 t rootF exists α D encα cid25kt cid2 νt checked query WG1Q 25 G Gottlob M Manna A Pieris cid13 cid23 QNullTω MinTω p1 pms1 sω Artiﬁcial Intelligence 321 2023 103936 icid9 cid29 Atomp1 pm s1τ sωτ cid13 Onep j P jsωarP j 1 sω jm cid14cid14 πG p1 pm s1τ sωτ Ai The second condition edge t1 t2 F νt1 cid25kt2 cid2 νt2 checked query WG2Q cid13 cid23 jcid9 QNullTω QNullTω j Tω cid14 j πG Ai A j 1 Tω The condition α hq t maxF bnullα νt cid25k cid2 encα checked query WG3Q cid13 cid23 cid23 jcid9 QNullTω j MaxTω j TTi π A j 0 0 cid6 cid7cid8 cid9 ai 1 1 0 0 cid6 cid7cid8 cid9 mai TTi cid14 Finally fourth condition α hq st nullα β D encβ cid25k cid2 encα checked query WG4Q cid23 cid13 cid23 jω DomTT j p1 pms1 sω cid29 Atomp1 pm s1τ sωτ cid13 Onep j P jsωarP j 1 sω jm π p1 pm s1τ sωτ 0 0 cid6 cid7cid8 cid9 ai 1 1 0 0 cid6 cid7cid8 cid9 mai cid14cid14 TTi Consequently WitnessGeneratorQ deﬁned ﬁrstorder query WG1Q WG2Q WG3Q WG4Q It remains deﬁne crucial subqueries π πG The Subqueries π πG Assume moment query πiA B s A B represent strings cid2 tB tA tB encα α Bcτ c domD BN S states following tA cid25i t substring length τ tB s 1 Then deﬁne crucial queries cid2 tB s 0 tA cid25it cid21 π A B s πG A B s πcid26log fLN cid21 πcid26log fLN cid22 cid2qcid27A B s Zeros cid22 cid2qcid27A B s Ones Let proceed formal deﬁnition πi To end given tuples A B represent strings tA tB encα α Bcτ c domD BN S need way check dectB obtained dectA single chase step uses linear TGD σ cid2 This achieved subquery σ AB s AB denotes tuple A B tuple obtained appending B A following meaning s 0 dectB obtained dectA applying σ s 1 addition string length τ BN occurring position dectB invented dectB Before giving formal deﬁnition need auxiliary function Assume σ linear TGD form Rtω2arR tω1 P t2ω3arP t2ω2 Let Ind 1 ω 1 arR ω 2 2ω 2 arP These positions encodings bodyσ headσ encoding predicates special string 0τ occurs In words positions nonvalid term appears We deﬁne function ξσ 2ω 2 2ω 2 follows 26 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 ξσ Ind ti ti1 t2ω2 t j j Ind μi μi min j j 1 2ω 2 Ind ti t j In words given position variable v occurring σ ξσ position lefttoright variable v occurs σ For example assuming ω 3 σ Rx1 x2 x3 P x2 x1 x3 ξσ 1 1 ξσ 2 2 ξσ 3 7 ξσ 4 6 ξσ 5 5 ξσ 6 6 ξσ 7 7 ξσ 8 8 We ready deﬁne ˆσ In follows A B seen tuples consisting ω 1 tuples ﬁrst length S rest length τ Ai Bi refer ith tuple A B respectively We write ABi ith tuple AB We consider following cases σ contains existentially quantiﬁed variable If σ contains existentially quantiﬁed variable σ AB s deﬁned NullBω 1 Zeros Ones cid23 i2ω2 ABi ABξσ cid23 i2ω1 Ai Bω 1 If σ contain existentially quantiﬁed variable σ AB s Zeros cid23 i2ω2 ABi ABξσ We ingredients deﬁne πi This inductively follows The query π0A B s deﬁned A B cid29 σ cid2 ˆσ AB s Note shortcut A B deﬁned Table 1 deﬁned way U W Then πi1A B s deﬁned C AtomC cid23 cid29 Ai B j i2ω1 cid13 DEs cid14 j2ω1 AtomD AtomE cid13 cid2 Ai C j cid29 j2ω1 D A E C Zeros cid14 cid5 cid2 D C E B s s cid14 cid5 cid14 cid14 πiD E s cid14 It checks exists string tC encα α Bcτ c domD BN S represented C assuming A B correspond strings tA tB respectively tA cid252i cid2 tC tC cid252i cid2 tB s 1 t substring length τ tB cid2 tB s 0 tC cid252i t The deﬁnition query f Qq cid2 complete It veriﬁed following technical lemma holds fact follows construction essentially states correctness query rewriter f Q Lemma 43 Consider database D set cid2 LN TGDs CQ qx tuple c domDx hold Let qcid2 f Qq cid2 The following 1 c qcid2D01 iff exists binary cid26log fLN cid2 qcid27witness generator qc wrt D cid2 2 qcid2 computed polynomial time By combining Lemmas 41 42 43 exists polynomialtime computable query rewriter f Q database D cid2 LN CQ q certq D cid2 qcid2D01 qcid2 f Qq cid2 item 1 Proposition 41 follows 27 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 44 Item 2 Proposition 41 Let proceed second item Proposition 41 recall family schemas S ﬁxed arity polynomialtime computable query rewriter f S Q Q q cid2 N q CQS certq D cid2 qcid2D01 qcid2 f S D DS cid2 LS CQS LS N FO By Lemmas 41 42 suﬃces deﬁne f S N TGDs CQ qx CQS tuple c following equivalent assume loss generality D cid2 q schema S S collects predicates occurring D cid2 q Q way database D DS set cid2 LS 1 c qcid2D01 qcid2 f S 2 There exists binary cid26log fLN cid2 qcid27witness generator qc wrt D cid2 Q q cid2 Consider set cid2 LS FO N CQ qx CQS assume cid2 q schema S S The Triple Q q cid2 query f S cid2 Q Q N Triple WitnessGeneratorScheme WitnessGenerator adaptation query NQ deﬁned Q N previous section In fact goal convert FO query NQ equivalent FO losing crucial property constructed polynomial time Q WitnessGeneratorScheme Q WitnessGenerator cid5 Q query N The Subqueries Triple Q WitnessGeneratorScheme Q We ﬁrst observe TripleQ WitnessGeneratorSchemeQ transformed polynomial time equivalent queries TriplennfQ WitnessGeneratorSchemennfQ negation normal form negation operator applied atoms allowed Boolean operators It easy verify reasons obtained queries negation normal form positive expressions form s s cid14 inequalities witnesses variables s s cid14 0 1 constants input database atoms form Zeros Ones Since variables s s inequalities positive expression cid2 Zeros Zeros cid14 Ones Ones cid2 cid5 cid14 cid5 cid14 expressions s s cid14 values 0 1 simply replace kind We replace Zeros Ones equivalent positive expression Ones ADoms Zeros ADoms respectively ADoms subquery computes active domain input database set constants occurring input database More precisely query ADoms deﬁned s1 si1si1 sarR Rs1 si1 s si1 sarR cid29 cid29 RS iarR The replacements TriplennfQ WitnessGeneratorSchemennfQ lead positive existential queries Triple ProofGeneratorScheme Q Q Q We convert WitnessGeneratorQ equivalent positive existential query The Subquery WitnessGenerator applying following steps We ﬁrst redeﬁne subqueries π πG relying different deﬁnition πcid26log fLN cid2qcid27A B s In particular query π0A B s deﬁned cid29 A B ˆσ AB s σ cid2 actually πi1A B s deﬁned cid13 cid14 Cs AtomC cid23 NullAi i2ω1 cid29 Ai B j cid29 Ai C j j2ω1 j2ω1 cid14 πiA C s cid14 Zeros cid14 πiC B s 28 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 Note propagation check focus null values expression NullAi checks ﬁrst Ai encodes null turn guarantees equalities variables instantiated values 0 1 This affecting correctness construction assuming tA tB tC atom encodings represented A B C respectively dectC contain string BC occurs dectA dectB πiC B s trivially evaluated false Let WitnessGeneratorcid15Q query deﬁned WitnessGeneratorQ new deﬁnition π πG given cid2qcid27A B s Before proceed important stress S ﬁxed arity πcid26log fLN cid2qcid27A B s takes structed polynomial time Without assuming arity ﬁxed construction πcid26log fLN exponential time This precisely reason simpler construction avoids use universally quan tiﬁed variables proof item 1 Proposition 41 We observe WitnessGeneratorcid15Q transformed equivalent query WitnessGeneratornnfQ cid14 witnesses negation normal form negation operator applied equalities s s 0 1 atoms form Zeros Ones variables s s cid14 We ﬁnally convert WitnessGeneratornnfQ positive existential query WitnessGenerator cid14 Zeros Zeros cid14 Ones Ones Q eliminating cid14 Zeros negation explained simply replace s s Ones ADoms Ones Zeros ADoms It diﬃcult task verify following technical lemma holds essentially states correctness query rewriter f S Q Lemma 44 Let S family schemas ﬁxed arity Consider database D DS set cid2 LS tuple c domDx Q q cid2 following statements hold11 With qcid2 f S N TGDs CQ qx CQS 1 c qcid2D01 iff exists binary cid26log fLN cid2 qcid27witness generator qc wrt D cid2 2 qcid2 FO query computed polynomial time By Lemmas 41 42 44 conclude family schemas S ﬁxed arity exists polynomial N q CQS time computable query rewriter f S CQS LS N Q certq D cid2 qcid2D01 qcid2 f S Q q cid2 needed This completes proof Proposition 41 D DS cid2 LS FO 5 Polynomial combined rewritability guardedness We concentrate notion polynomial combined rewritability guarded TGDs A family schemas S ﬁxed size exists integer k 0 schema S S S k arS k Our goal following Theorem 51 For family schemas S ﬁxed size GS polynomially combined FO rewritable Recall evaluation problem FO NP Therefore immediate consequence Theorem 51 following complexity result discussed Introduction closes complexity gap OQAG case schemas ﬁxed size In fact following result known singlehead guarded TGDs 17 straightfor wardly transferred multihead guarded TGDs Corollary 51 OQAG NPcomplete schemas ﬁxed size The proof Theorem 51 exploits Proposition 51 main technical result section It essentially provides polynomialtime combined reduction ontological query answering guarded TGDs schemas ﬁxed size ontological query answering linear TGDs schemas ﬁxed arity Before introducing Proposition 51 need auxiliary notions A TGD rewriter function takes input set TGDs outputs set TGDs For families schemas S GS polynomially combined reducible LScid14 written GS pc LScid14 exist Scid14 polynomialtime computable database rewriter f S DB polynomialtime computable TGD rewriter f S T polynomialtime computable query rewriter f S Q DS GS DScid14 GS LScid14 CQS GS CQScid14 11 We assume loss generality D cid2 q schema S S 29 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 D DS cid2 GS q CQS holds certq D cid2 cert f S We following Q q cid2 f S DBD cid2 f S T cid2 Proposition 51 For family schemas S ﬁxed size family schemas Scid14 ﬁxed arity GS pc LScid14 Observe polynomial combined FO rewritability closed pc Since Theorem 41 LScid14 polynomially rewritable Proposition 51 immediately implies Theorem 51 The rest section devoted showing combined FO Proposition 51 This main steps 1 We deﬁne database TGD query rewriters f S 2 We establish correctness D DS cid2 GS q CQS certq D cid2 Q respectively T f S DB f S cert f S Q q cid2 f S 3 We ﬁnally f S DBD cid2 f S DB f S T cid2 T f S Q polynomialtime computable Before proceeding steps ﬁrst need introduce notion central reasoning guarded TGDs known type atom This notion play important role steps 51 Guarded types Consider database D set cid2 G Let δ Iii0 ﬁnite inﬁnite chase derivation D wrt cid2 Iicid17σi hicid18Ii1 Given atom α chaseδD cid2 δtype wrt D cid2 set atoms typeδα β chaseδD cid2 domβ domα collects atoms result δ mention terms occurring α The key property type shown 17 singlehead guarded TGDs easily extended multihead guarded TGDs It roughly states set atoms chaseδD cid2 derived α guard determined δtype To precise need auxiliary notions δ binary relation chaseδD cid2 α gp The guarded parent relation δ denoted gp δ β iff exists 0 α higuardσi β Ii1 Ii Let gp forms forest atoms D roots We deﬁne notion projection δ allow state key property type Consider atom α chaseδD cid2 let j j0 sequence indices 0 i1 i2 i3 cid9 0 cid9 j j0 iff hcid9guardσcid9 α α gp hcid9guardσcid9 Simply stated j j0 collects applications δ ascending order use α gp δ descendant α guard The αprojection δ denoted δα sequence instances J ii0 J 0 typeδα j 0 transitive closure gp δ Note gp δ δ δ cid17 J j J j1 β Ii j 1 hi j guardσi j gp δ β cid18 We state key property notion type relies guardedness Lemma 51 Consider database D set cid2 G For chase derivation δ D wrt cid2 atom α chaseδD cid2 δα chase derivation typeδα wrt cid2 Proof Let δ Iii0 Iicid17σi hicid18Ii1 By deﬁnition δα J ii0 J 0 typeδα j 0 cid18 cid17 J j J j1 β Ii j 1 hi j guardσi j gp δ β j j0 sequence indices 0 i1 i2 i3 cid9 0 cid9 j j0 iff hcid9guardσcid9 α α gp hcid9guardσcid9 We proceed following statements turn imply δα chase derivation typeδα wrt cid2 needed δ 1 For j 0 J j1cid17σi j hi j 2 For j k 0 j cid3 k σi j hi j cid3 σik hik 3 For j 0 trigger σ h cid2 J j exists k j σ h σik1 hik1 cid18 J j Item 1 consequence following observations turn hold fact cid2 guarded brevity guarded TGD σ write sideσ atoms σ set atoms bodyσ guardσ hi1 sideσi1 typeδα For j 1 hi j sideσi j typeδα β Ii j11 α gp δ β 30 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 Items 2 3 hold hypothesis δ chase derivation Indeed contradiction 2 resp 3 hold δ applies certain trigger resp fair contradicts fact chase derivation cid2 With notion type place ready proceed proof Proposition 51 In rest section let S family schemas ﬁxed size 52 The database TGD query rewriters Before deﬁne desired rewriters ﬁrst need introduce auxiliary technical notions crucial deﬁnitions Auxiliary Notions We need encode equality type guard atom positions mention term equality type atoms occurring type guard This notion Stype S schema The equality type atom encoded atom mentions integer values For example equality type Ra b c encoded atom R1 2 1 3 Formally Stype τ pair α T α Rt1 tn R S t1 1 ti t1 ti1 ti1 1 2 n T Bt1 tn S α We write guardτ atom α atomsτ set atoms α T arτ maximum integer occurring guardτ schema S τ τ Stype τ new predicate S arity arτ clear We write S arS arS ﬁxed arity S ﬁxed size ﬁxed arity We tuple u u1 isomorphic t t1 tn written u cid11 t ui u j iff ti t j Given tuple u u cid11 t instantiation τ u denoted τ u set atoms obtained atomsτ replacing ti ui The projection τ P 1 arτ The family schemas S S S It clear S deﬁned S cid19P τ β atomsτ domβ P The completion instance I S wrt set TGDs cid2 S instance completeI cid2 R u R S u certRx I cid2 u u1 x x1 xn Note completion instance wrt set TGDs relies notion certain answers At ﬁrst glance circular trying devise machinery computing certain answers combined approach FOrewritability However deﬁnition completion needs compute certain answers atomic queries CQs consisting single atom existentially quantiﬁed variables simpler task Further details problem computing certain answers atomic queries known instance checking given Section 54 polynomialtime computability rewriters shown The Database Rewriter Given database D DS set cid2 GS assuming D cid2 schema S S DBD cid2 f S τ c Rc D τ Stype Rt T c cid11 t τ c completeD cid2 It clear f S database rewriter introduced follows DB database rewriter form DS GS DS A simple example illustrates notion Example 51 Let S P Q R S T S Consider database D Ra b c S set cid2 guarded TGDs S consisting σ P x y x u w Sx u z1z2 Ru y x z1 T z1 z2 x σ cid14 Rx x y z Q x z It clear pair τ R1 1 2 3 Q 1 3 Stype b c cid11 1 1 2 3 Stype Moreover easy verify Ra b c Q c completeD cid2 turn implies f S Ra b c type cid2 DBD cid2 τ b c In simple words τ b c compact encoding guard 31 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 The TGD Rewriter Given set cid2 GS schema S S f S T cid2 deﬁned union sets linear TGDs cid2tg cid2ex cid2tg socalled type generator responsible generating new Stypes existing ones cid2ex socalled expander responsible expanding derived Stype τ explicitly constructs atoms S encoded τ The type generator deﬁned follows For σ cid2 ϕx y z1 zm R1 u1 Rn guardσ G u x ziim variables occurring headσ Stype τ homomorphism h ϕx y atomsτ hG u guardτ add cid2tg linear TGD τ u z1 zm τ1 u1 τn 1 n τi deﬁned follows Let f function variables headσ natural numbers cid12 f t ht arS t x t zi With ui u1 u arR αi R f u1 f u arR deﬁne set T β completeI cid2 domβ domαi αi I α1 αn cid19hxxxτ Note αi T proper Stype integers atoms appear correct order Let ρ renaming function renames integers atoms order appear increasing order starting 1 ρR2 2 4 1 R1 1 2 3 formal deﬁnition omitted clear function ρ We deﬁne τi Stype ραi ρT The expander constructs guard atom τ Stype τ To end Stype τ add cid2ex linear TGD τ x1 xk Rx1 xk R kary predicate guardτ It clear f S simple example illustrates notion TGD rewriter introduced follows T TGD rewriter form GS LS A Example 52 Let cid2 σ σ cid14 set guarded TGDs given Example 51 Consider Stype τ P 1 2 1 2 3 S1 2 S1 1 It easy verify h x 1 y 2 u 2 w 3 homomorphism bodyσ atomsτ P 1 2 1 2 3 S1 2 S1 1 hP x y x u w P 1 2 1 2 3 Therefore linear TGD τ x y x u w z1z2 τ1u y x z1 τ2z1 z2 x τ1 R1 1 2 3 S2 1 S2 2 Q 1 3 belongs type generator cid2tg Moreover linear TGDs τ2 T 1 2 3 τ x1 x5 P x1 x5 τ1x1 x4 Rx1 x4 τ2x1 x2 x3 T x1 x2 x3 belong expander cid2ex cid2 The Query Rewriter Due expander cid2ex deﬁned explicitly constructs atoms original schema S S encoded Stype τ leave query untouched In words q CQS cid2 GS f S Q q cid2 q 32 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 53 Correctness rewriters We proceed establish correctness database TGD query rewriters deﬁned In fact need following Lemma 52 Consider database D DS set cid2 GS TGDs CQ q CQS It holds certq D cid2 certq f S DBD cid2 f S T cid2 The proof Lemma 52 relies following technical lemma fact Lemma 52 immediate consequence Lemma 53 shown We instances I J homomorphically equivalent I J J I We write IS restriction I schema S set atoms Rt I R S For brevity simply write Dcid15 cid2cid15 f S DBD cid2 f S T cid2 respectively Lemma 53 Consider database D DS set cid2 GS S S Let δ chase derivation D wrt cid2 δcid14 chase derivation Dcid15 wrt cid2cid15 It holds chaseδD cid2 chaseδcid14 Dcid15 cid2cid15S homomorphically equivalent Proof We ﬁrst need establish auxiliary technical results reveal relationship chaseδD cid2 chaseδcid14 Dcid15 cid2cid15 For atom α chaseδD cid2 let γα function renames arguments α integers increasing order α Ra b γαα R1 2 1 3 The deﬁnition γα obvious omitted We α Stype γαα γαtypeδα α We ready present ﬁrst auxiliary technical write τ δ result Lemma 54 Let δ chase derivation D wrt cid2 δcid14 Rt chaseδD cid2 implies τ δ ht chaseδcid14 Dcid15 cid2cid15 Rt chase derivation Dcid15 wrt cid2cid15 There homomorphism h Proof Assume δ Iii0 We induction k 0 hk Rt Ik implies hkt chaseδcid14 Dcid15 cid2cid15 k 0 hk compatible hk1 This implies claim holds τ δ Rt cid11 h i0 hi Base Case Consider atom Rt I0 D By construction τ δ t Dcid15 Since Dcid15 chaseδcid14 Dcid15 cid2cid15 claim follows Rt h0 identity domD Inductive Step Assume Rt generated kthe step k 0 Rt Ik Ik1 Assume Ik1cid17σ μcid18Ik σ μ trigger cid2 Ik1 let σ form ϕx y z1 zm R1 u1 Rn guardσ G u x ziim variables occurring headσ Clearly μ homomorphism maps ϕx y Ik1 Ik Ik1 μcid14headσ By induction hypothesis conclude τ δ Gμ u hk1μ u chaseδcid14 Dcid15 cid2cid15 Observe γGμ u μ maps ϕx y atomsτ δ tion cid2cid15 contains linear TGD σL form Gμ u γGμ uμG u guardτ δ Gμ u Therefore construc τ δ Gμ u u z1 zm τ1 u1 τn Furthermore Lemma 51 conclude n τi τ δ chaseδcid14 Dcid15 cid2cid15 Therefore exists extension λcid14 R iμcid14 ui n conclude τ δ λcid14 ui chaseδcid14 Dcid15 cid2cid15 Let R μcid14 ui Observe λ hk1 μ maps bodyσL λ maps τi uiin chaseδcid14 Dcid15 cid2cid15 Since Rt R y hk hk1 μcid14 zi λ cid14 ziim note σ existentially quantiﬁed variables hk hk1 It clear hk welldeﬁned μcid14z1 μcid14zm occurs domain hk1 It easy verify τ δ λcid14 ui chaseδcid14 Dcid15 cid2cid15 cid2 hkt τ δ Rt Rt We proceed second technical claim needed establishing Lemma 53 Let note construction τ t chaseδcid14 Dcid15 cid2cid15 guardτ R u t cid11 u This means given atom τ t chaseδcid14 Dcid15 cid2cid15 refer instantiation τ t τ t welldeﬁned Lemma 55 Let δ chase derivation D wrt cid2 δcid14 τ t chaseδcid14 Dcid15 cid2cid15 implies hτ t chaseδD cid2 chase derivation Dcid15 wrt cid2cid15 There homomorphism h 33 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 Proof Assume δcid14 Iii0 We induction k 0 exists hk τ t Ik implies hkτ t chaseδD cid2 k 0 hk compatible hk1 This implies claim holds h i0 hi Base Case Consider τ t I0 Dcid15 By construction τ t completeD cid2 Since completeD cid2 chaseδD cid2 h0 cid11 identity domD Inductive Step Assume τ t generated kth step k 0 τ t Ik Ik1 Assume Ik1cid17σ μcid18Ik σ μ trigger cid2cid15 Ik1 let σ form τ u z1 zm τ1 u1 τn Clearly μ homomorphism maps τ cid14 u Ik1 Ik Ik1 μcid14headσ By induction hypothesis conclude hk1τ cid14 μ u chaseδD cid2 By construction exists TGD σG cid2 form ϕx y z1 zm R1 u1 Rn guardσ G u ϕx y mapped atomsτ cid14 homomorphism λ λG u guardτ cid14 Clearly isomorphism γ atomsτ cid14 τ cid14μ u implies μ γ λ Thus ν hk1 μ maps ϕx y chaseδD cid2 Therefore extension νcid14 ν maps R uiin chaseδD cid2 By Lemma 51 conclude n τi τ δ R νcid14 ui Let hk hk1 μcid14 zi νcid14 ziim note σ existentially quantiﬁed variables hk hk1 It clear hk welldeﬁned μcid14z1 μcid14zm occurs domain hk1 It easy verify hkτ t τiνcid14 ui n Since τiνcid14 ui typeδR iνcid14 ui chaseδD cid2 conclude hkτ t chaseδD cid2 claim follows cid2 Having Lemmas 54 55 place conclude proof Lemma 53 We ﬁrst chaseδD cid2 chaseδcid14 Dcid15 cid2cid15S Let h homomorphism provided Lemma 54 Due expander cid2cid15 set TGDs form τ x Rx τ Stype R S conclude atom Rt chaseδD cid2 Rht chaseδcid14 Dcid15 cid2cid15S Therefore hchaseδD cid2 chaseδcid14 Dcid15 cid2cid15S needed We ﬁnally chaseδcid14 Dcid15 cid2cid15S chaseδD cid2 Let h homomorphism provided Lemma 55 It clear h τ tchaseδcid14 Dcid15cid2cid15 Since construction chaseδcid14 Dcid15 cid2cid15S τ t chaseδD cid2 τ t τ tchaseδcid14 Dcid15cid2cid15 hchaseδcid14 Dcid15 cid2cid15S chaseδD cid2 claim follows cid2 As said Lemma 52 establishes correctness database TGD query rewriters deﬁned immediate consequence Lemma 53 34 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 54 Polynomialtime computability rewriters We ﬁnally proceed establish rewriters deﬁned polynomialtime computable Actually need concentrate database TGD rewriters query rewriter f S Q trivially computable polynomial time Let recall family schemas S ﬁxed size schema S S S arS bounded integer This crucial validity lemma Lemma 56 The functions f S DB f S T polynomialtime computable Observe deﬁnitions f S T heavily rely instance checking simpler version tological query answering query atomic query single atom existentially quantiﬁed variables Indeed notion completion deﬁnitions f S T exploits instance checking Therefore Lemma 56 ﬁrst need pinpoint complexity instance checking deﬁned follows let C class TGDs DB f S DB f S PROBLEM INPUT QUESTION ICC A database D set cid2 C CQ Rx c domDarR Does c certRx D cid2 It clear Stype schema S S depends S Since S ﬁxed size constant number Stypes schemas S S formed constructed constant time This implies instance checking GS feasible polynomial time Lemma 56 follows Lemma 52 establishes Proposition 51 The rest section devoted showing following Lemma 57 ICGS PTime Before proceed let clarify result shown 17 assuming singlehead guarded TGDs TGDs atom head sophisticated alternating algorithm uses logarithmic space However result 17 straightforwardly transferred multihead guarded TGDs arbitrary junction atoms head The fact need directly deal multiheads causes nontrivial complications require novel ideas Those complications issue singlehead TGDs To better understand different nature settings let stress case singlehead guarded TGDs ﬁxing size underlying schema implicitly ﬁx set TGDs Indeed number different guarded nonisomorphic TGDbodies formed schema ﬁxed size constant turn implies constant number different singlehead guarded TGDs variable renaming This true multihead guarded TGDs unbounded number different TGDs guarded body unguarded multiheads We establish Lemma 57 novel alternating algorithm designed directly operate multihead guarded TGDs But ﬁrst need auxiliary result Pivotal Atoms Our alternating algorithm exploits existence special atoms called pivotal guarded subsets result derivation Roughly check guarded set atoms Q result chase derivation δ suﬃces check Q result αprojection δ α pivotal atom Q Consider database D set TGDs cid2 G schema S A ﬁnite set Q BC N S guarded α Q domα domQ We Q ungrounded atoms contains null N Consider chase derivation δ Iii0 D wrt cid2 Iicid17σi hicid18Ii1 set atoms Q BC N S guarded ungrounded An atom α called δpivotal Q α higuardσi 0 nullQ cid4 domIi nullQ domIi1 In simple words δpivotal atom Q atom chaseδD cid2 nulls Q occur ﬁrst time according δ The key lemma concerning pivotal atoms follows Lemma 58 Consider database D set TGDs cid2 G schema S Let δ chase derivation D wrt cid2 Q BC N S guarded ungrounded set atoms The following equivalent 1 Q chaseδD cid2 2 There exists exactly δpivotal atom α chaseδD cid2 Q Q chaseδαtypeδα cid2 Proof Clearly 2 1 chaseδαtypeδα cid2 chaseδD cid2 δα chase derivation typeδα wrt cid2 Lemma 51 It remains 1 2 Let γ Q atom contains terms domQ α β chaseδD cid2 atoms α gp γ nullα cid4 nullβ nullβ nullγ By guardedness conclude α δpivotal atom Q αcid14 Q holds α gp αcid14 typeδα Hence Q chaseδαtypeδα cid2 cid2 δ β β gp αcid14 δ δ 35 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 We ingredients needed introducing new alternating algorithm lead desired complexity result stated Lemma 57 Algorithm 1 Instance Checking EntailD cid2 Rx c Rc D return Accept guess σ cid2 h dombodyσ domD cid23cid15 cid2 Rc hheadσ return Reject return Proofhbodyσ ProofQ cid17 cid18 Rc Q c CarR cid14 cid14 Q Q N nullQ universally universally select atom Rc Q Q cid14 return EntailD cid2 Rx c N return Accept guess D cid2step σ h s T scid2σ h N nullhguardσ N cid3 s1 scid9σ return Reject universally universally select atom β Q return Reachσ h s T β return ProofT Reachσ h s T β guess atom α cid2σ h scid3 α β return Accept S scid2σ h s scid2nullβ guess D cid2step σ cid14 h cid14 T cid14 s cid14guardσ cid14 cid3 α h return Reject cid14 S universally return Reachσ cid14 h universally select atom βcid14 T cid14 β cid14 T cid14 s return Reachσ h s T βcid14 cid14 T cid14 T The Alternating Algorithm Consider database D set cid2 guarded TGDs CQ Rx tuple c domDarR We assume D cid2 Rx schema S S Checking c certRx D cid2 boils checking Rc chaseδD cid2 chase derivation δ D wrt cid2 Lemma 58 suggests following strategy task ﬁnd σ cid2 function h variables bodyσ domD N Rc hheadσ check exists δpivotal atom ungrounded subset hbodyσ chase derivation δ D wrt cid2 ground atom hbodyσ recursively apply Our alternating algorithm described performs steps parallel universal computations ensures logarithmic space needed Recall polynomial time coincides alternating logarithmic space 26 Some Preparation We ﬁrst introduce auxiliary notions Since use logarithmic space ex plicitly store atoms generated single chase step deal unguarded multiheads note possible case singlehead TGDs Therefore need way compactly represent set atoms representation logarithmic space This socalled D cid2step compact representation guard atom chase step type atoms generated chase step Let cid23cid2 1 2arcid21 set collects different sorts nulls needed perform s j s check bounded number nulls turn ensure use logarithmic space Let cid23cid15 cid2 36 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 cid23cid2 jcid9cid2 N cid9cid2 maxσ cid2cid9σ cid9σ number existential variables σ A D cid2step set S cid5 cid23cid2 tuple σ h s T σ cid2 h dombodyσ domD cid23cid15 cid2 s cid23cid2 S hbodyσ T Bdomhguardσ S cid14headσ h cid14 Such D cid2step interpreted follows The triple σ h s encodes set atoms h cid14zi si sort s variable zi extends h follows z1 zk existential variables σ h uniquely determine null assigned zi We refer set atoms cid2σ h scid3 Note fresh nulls sort s cid2σ h scid3 occur hguardσ hguardσ contain null sort s The set T corresponds type hguardσ For set N cid23cid15 cid2 useful able extract set sorts nulls occurring N set scid2N s s j N cid23cid2 For brevity simply write scid2σ h instead formal scid2nullhbodyσ Description Algorithm Our alternating algorithm presented Algorithm 1 Recall alternation extension nondeterminism apart existential steps perform universal steps independent computations run parallel Indeed Algorithm 1 alternating existential guesses performed universal steps The expressed key word universally followed list steps starting symbol executed parallel key word universally select essentially means element set select elements execute parallel command follows Here detailed description algorithm cid14 cid14 cid14 cid14 cid14 cid14 The procedure Entail implements strategy discussed ﬁnd σ cid2 function h maps varbodyσ cid2 Rc hheadσ check procedure Proof hbodyσ derivable chase domD cid23cid15 derivation Note afford use unlimited number nulls limited space The nulls cid23cid15 cid2 performing check nullQ means Q The procedure Proof checks set atoms Q derivable chase derivation Each ground atom Q proved parallel universal computation recursively calling procedure Entail The remaining atoms form algorithm accepts In guarded ungrounded set Q parallel universal computation checks δpivotal atom α Q chase derivation δ Q derivable applying chase steps starting δtype α Lemma 58 notice simply exploit existence δpivotal atom The guessed D cid2step σ h s T actually hguardσ corresponds δpivotal atom Q algorithm performs parallel universal computations following checks atom β Q δtype hguardσ given T derivable applying chase steps starting T parallel universal computations calling procedure Reach ii T δtype hguardσ recursively calling procedure Proof The procedure Reach actually checks chase derivation δ T wrt cid2 hguardσ gp cid14 T cid14guardσ cid14 α sort fresh nulls appear generated atoms s β It starts guessing atom α cid2σ h scid3 If α atom targeting β accepts proceeds check α gp β Due Lemma 51 check α gp β suﬃces consider δtype α In fact guessed D cid2step σ cid14 h cid14 h δtype δtype α The check α T cid14 For check suggest recursively calling procedure Reach input σ cid14 h cid14 algorithm simply ProofT share null values cid14 parallel universal computation loose connection fact preserved However calling ProofT cid14 T guarded ungrounded β T cid14 T set atoms β coming set atoms δpivotal atom Q item 2 Lemma 58 unique atom hguardσ Hence prove T algorithm recursively calls atom βcid14 T cid14 T parallel universal computation Reachσ h s T βcid14 cid14 provides trigger apply step σ cid14 h lead unsound results The key observation T cid14 It overlooked β T It remains verify α gp β ii T cid14 s cid14 cid14 T cid14 s δ δ δ δ cid14 cid14 cid14 cid14 By Lemmas 51 58 algorithm Entail correct EntailD cid2 Rx c accepts iff Rc chaseδD cid2 chase derivation δ D wrt cid2 Furthermore step computation algorithm uses logarithmic space storing elements domD auxiliary pointers recall S coming family schemas S ﬁxed size Since polynomial time coincides alternating logarithmic space Lemma 57 follows 6 Conclusion We considered classes linear guarded existential rules investigated limits polynomial combined approach FO rewritability We proved successfully applied linear existential rules rewritten query use power ﬁrstorder queries ii linear existential rules arity underlying schema ﬁxed rewritten query positive existential ﬁrstorder query iii guarded existential rules 37 G Gottlob M Manna A Pieris Artiﬁcial Intelligence 321 2023 103936 underlying schema ﬁxed rewritten query positive existential ﬁrstorder query As immediate corollaries ontological query answering linear existential rules schemas ﬁxed arity guarded existential rules ﬁxed schemas NP This closes gap complexity picture ontological query answering linear guarded existential rules passed unnoticed recently brought attention colleague 24 discussed 25 The results work moment theoretical nature simply tell exploitation conventional database systems ontological query answering purposes case linear guarded existential rules principle possible We claim directly lead eﬃcient algorithms A smart implementation evaluation obtained rewritings obvious step Declaration competing The authors declare known competing ﬁnancial interests personal relationships appeared inﬂuence work reported paper Data availability No data research described article Acknowledgements Gottlob Royal Society Research Professor acknowledges support Royal Society context project RAISON DATA project reference RPR1201074 Part Gottlobs work visiting University Cyprus Manna supported MISE project S2BDW F0503890103X32 Horizon 2020 PON IC201420 Regione Calabria project DLV LargeScale CUP J28C17000220006 POR Calabria 201420 PNRR MUR project PE0000013FAIR Spoke 9 Greenaware AI WP91 Pieris supported EPSRC grant EPS0038001 EQUID References 1 G Gottlob M Manna A Pieris Polynomial combined rewritings existential rules KR 2014 2014 2 G Gottlob M Manna A Pieris Polynomial rewritings linear existential rules IJCAI 2015 2015 pp 29922998 3 G Gottlob M Manna A Pieris Multihead guarded existential rules ﬁxed signatures KR 2020 2020 4 S Abiteboul M Arenas P Barceló M Bienvenu D Calvanese C David R Hull E Hüllermeier B Kimelfeld L Libkin W Martens T Milo F Murlak F Neven M Ortiz T Schwentick J Stoyanovich J Su D Suciu V Vianu K Yi Research directions principles data management abridged SIGMOD Rec 45 2016 517 5 A Poggi D Lembo D Calvanese G De Giacomo M Lenzerini R Rosati Linking data ontologies J Data Semant 10 2008 133173 6 D Calvanese G De Giacomo D Lembo M Lenzerini R Rosati Tractable reasoning eﬃcient query answering description logics DLLite family J Autom Reason 39 2007 385429 7 A Calì G Gottlob T Lukasiewicz A general datalogbased framework tractable query answering ontologies J Web Semant 14 2012 5783 8 G Gottlob G Orsi A Pieris Query rewriting optimization ontological databases ACM Trans Database Syst 39 2014 2512546 9 G Gottlob S Kikot R Kontchakov VV Podolskii T Schwentick M Zakharyaschev The price query rewriting ontologybased data access Artif Intell 213 2014 4259 circuit complexity J ACM 65 2018 2812851 10 M Bienvenu S Kikot R Kontchakov VV Podolskii M Zakharyaschev Ontologymediated queries combined complexity succinctness rewritings 11 F Baader S Brandt C Lutz Pushing EL envelope IJCAI 2005 2005 pp 364369 12 C Lutz D Toman F Wolter Conjunctive query answering description logic EL relational database IJCAI 2009 2009 pp 20702075 13 R Kontchakov C Lutz D Toman F Wolter M Zakharyaschev The combined approach query answering DLLite KR 2010 2010 14 R Kontchakov C Lutz D Toman F Wolter M Zakharyaschev The combined approach ontologybased data access IJCAI 2011 2011 15 C Feier D Carral G Stefanoni B Cuenca Grau I Horrocks The combined approach query answering OWL 2 proﬁles IJCAI 2015 16 A Calì G Gottlob T Lukasiewicz B Marnette A Pieris Datalog family logical knowledge representation query languages new appli 17 A Calì G Gottlob M Kifer Taming inﬁnite chase query answering expressive relational constraints J Artif Intell Res 48 2013 115174 18 JF Baget M Leclère ML Mugnier E Salvat On rules existential variables walking decidability line Artif Intell 175 2011 16201654 19 R Fagin PG Kolaitis RJ Miller L Popa Data exchange semantics query answering Theor Comput Sci 336 2005 89124 20 T Lukasiewicz MV Martinez A Pieris GI Simari From classical consistent query answering existential rules AAAI 2015 2015 pp 15461552 21 A Calì G Gottlob A Pieris Ontological query answering expressive entityrelationship schemata Inf Syst 37 2012 320335 22 N Leone M Manna G Terracina P Veltri Fast query answering existential rules ACM Trans Comput Log 20 2019 1211248 23 DS Johnson AC Klug Testing containment conjunctive queries functional inclusion dependencies J Comput Syst Sci 28 1984 167189 24 M Benedikt Personal communication 2018 25 K Kappelmann Decision procedures guarded logics CoRR arXiv191103679 abs 2019 26 CH Papadimitriou Computational Complexity AddisonWesley 1994 38 pp 26562661 2015 pp 29712977 cations LICS 2010 2010 pp 228242