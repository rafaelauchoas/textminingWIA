Artiﬁcial Intelligence 175 2011 586614 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint The extended global cardinality constraint An empirical survey Peter Nightingale School Computer Science University St Andrews St Andrews Fife KY16 9SX United Kingdom r t c l e n f o b s t r c t Article history Received 1 March 2010 Received revised form 18 October 2010 Accepted 18 October 2010 Available online 21 October 2010 Keywords Global cardinality constraint Constraint programming Global constraints Propagation algorithms The Extended Global Cardinality Constraint EGCC vital component constraint solv ing systems widely model diverse problems The literature contains different versions constraint trade strength inference compu tational cost In paper I focus highest strength inference usually considered enforcing generalized arc consistency GAC target variables This work exten sive empirical survey algorithms optimizations considering GAC target variables tightening bounds cardinality variables I evaluate number key techniques literature report important implementation details tech niques described published papers Two new optimizations proposed EGCC One novel optimizations dynamic partitioning generalized AllDifferent speed search 56 times best case 156 times average exploring search tree The empirical work represents far extensive set experiments variants algorithms EGCC Overall best combination optimizations gives mean speedup 411 times compared implementation optimizations 2010 Elsevier BV All rights reserved 1 Introduction Constraint programming powerful ﬂexible means solving combinatorial problems Constraint solving combinatorial problem proceeds phases First problem modelled set decision variables set constraints variables solution satisfy A decision variable represents choice order solve problem The domain potential values associated decision variable corresponds options choice Consider sports scheduling problem team plays team exactly season No team play matches time Each team plays particular stadium twice season In example decision variables match representing teams For set matches played stadium global cardinality constraint 24 ensure occurrences team The second phase consists constraint solver search solutions assignments values decision variables satisfying constraints The simplicity generality approach fundamental successful application constraint solving wide variety disciplines scheduling industrial design combinatorial mathematics 34 11 The Global Cardinality Constraint GCC important global constraint present constraint solving toolk solvers languages It restricts number occurrences values assigned set variables In original version constraint 24 value given lower bound upper bound In solution number occur rences value fall bounds The literature contains propagation algorithms constraint Email address pncsstandrewsacuk 00043702 matter 2010 Elsevier BV All rights reserved doi101016jartint201010005 P Nightingale Artiﬁcial Intelligence 175 2011 586614 587 trade strength inference computational cost example bound consistency 1319 range consistency 18 generalized arcconsistency GAC 2418 GCC widely variety constraint models diverse problems routing wavelength assignment 30 car sequencing 25 combinatorial mathematics 11 Returning sports scheduling example GCC express stadium constraint team plays particular stadium twice season Each value representing team given bounds 0 2 variables slots particular stadium GCC generalized replacing ﬁxed bounds values cardinality variables 18 cardinality variable represents number occurrences value To avoid confusion I refer Extended Global Cardi nality Constraint EGCC Thus EGCC constraint target variables number occurrences values constrained cardinality variables In paper I focus highest strength inference enforcing GAC target variables This allows study methods great depth leads surprising conclusions I survey methods pruning cardinality variables depth The main contributions paper follows A literature survey GAC propagation algorithms target variables optimizations Section 3 Discussion important implementation decisions Section 3 frequently omitted original papers lack space For example ﬁnd augmenting paths Régins algorithm 24 The proposal new optimizations Section 34 One based modifying ﬂow network Régins algorithm greater eﬃciency novel generalization dynamic partitioning optimization AllDifferent 6 A careful description concrete algorithms pruning cardinality variables Section 4 Easily largest empirical study GAC propagation methods target variables EGCC Section 5 This involves basic algorithms seven optimizations Experimental conclusions implementation advice GAC target variables Section 6 An empirical study pruning cardinality variables comparing methods Section 58 leading experi mental conclusions Section 6 It shown appropriate combination optimizations 4 times faster average careful unoptimized implementation Régins algorithm Section 510 benchmark set A fast variant EGCC typically orders magnitude better set occurrence constraints Even EGCC propagation effective slowed solver 166 times experiments Section 510 2 Background 21 Preliminaries For CSP P cid2X D Ccid3 constraint Ck C consists sequence m 0 variables Xk cid2xk1 xkm A CSP P cid2X D Ccid3 deﬁned set n variables X cid2x1 xncid3 set domains D cid2Dx1 Dxncid3 Dxi cid2 Z Dxi ﬁnite set potential values xi conjunction C C1 C2 Ce constraints cid3 domains Dk cid2Dxk1 Dxkm cid3 st Xk subsequence1 X Dk subsequence D variable xki domain Dxki matches variable x j domain Dx j P Ck associated set C S Dxk1 Dxkm tuples specify allowed combinations values variables Xk Although I deﬁne constraint Ck scope cid2xk1 xkm cid3 discussing particular constraint I frequently omit k k subscript refer variables cid2x1 xmcid3 domains cid2Dx1 Dxmcid3 A literal deﬁned variablevalue pair xi cid8 j xi X j Z To prune literal remove value k j domain Dxi In context constraint Ck I refer tuple τ values acceptable iff τ C S valid iff τ m j τ j Dxk j value tuple respective domain A solution CSP P cid2X D Ccid3 tuple τ size X τ Dxi τ represents assignment variables constraints satisﬁed τ constraint Ck C scope cid2xk1 xkm k τ cid11 constructed j τ cid11 j τ k j τ cid11 C S Generalized ArcConsistency GAC constraint Ck deﬁned function domains Dk set literals P Note k deﬁned terms Dk A literal xi cid8 j j Dxi P iff present tuple C S k k τ j Literals P acceptable valid tuple constraint pruned set C S cid3τ C S reducing set solutions CSP P cid3 new tuple τ cid11 acceptable 211 Graph theory Régins algorithm 24 Quimpers algorithm 18 pruning EGCC use network ﬂow bipartite matching theory 2 strongly connected components 31 Similarly Régins AllDifferent algorithm 23 makes use results graph theory particular maximum bipartite matching 1 strongly connected components 1 I use subsequence sense cid21 3cid3 subsequence cid21 2 3 4cid3 588 P Nightingale Artiﬁcial Intelligence 175 2011 586614 A bipartite graph G cid2V Ecid3 deﬁned set vertices V set edges E V V edges interpreted having direction vertices partitioned sets V 1 V 2 elements set adjacent A digraph G cid2V Ecid3 deﬁned set vertices V set edges E V V edges interpreted having direction 212 Propagation search Propagation basic operations constraint solvers simpliﬁes CSP pruning values domains For example applying GAC deﬁned constraint gives set values pruned changing solution set Constraint solvers provide propagation algorithm propagator type constraint applied ﬁxpoint reached constraints Propagation typically interleaved splitting Splitting basic operation search splitting operation transforms CSP simpler CSPs Hence depthﬁrst backtracking search performed propagation occurring node search tree A propagator PropCk Dk constraint Ck computes function domains Dk new domains Dcid11 k For example propagator compute GAC prunings P deﬁned prune literal P Dk construct Dcid11 k cid11 Propagators reduce variable domains contracting j D Dk j Propagators correct k j respect Ck set C S k preserved propagator applied allow assignments satisfy constraint These conditions correctness weak monotonicity deﬁned Schulte Tack 28 The propagators considered paper idempotent assuming variable duplicated cid2xk1 xkm cid3 means application propagator reach ﬁxpoint constraint PropCk Dk PropCk PropCk Dk 22 Extended GCC A traditional Global Cardinality Constraint set variables target variables Each domain value ﬁxed lower upper bounds associated An assignment target variables solution iff number occurrences value bounds value The main focus paper Extended Global Cardinality Constraint EGCC The EGCC second set variables cardinality variables representing number occurrences value Cardinality variables replace ﬁxed bounds value EGCC ﬂexible GCC EGCC following form egccX V C X vector target variables V vector domain values C vector cardinality variables value V The constraint satisﬁed assignment iff indices V number variables X set V equal Ci There restriction number occurrences value V In Régins original deﬁnition GCC 24 value target domains cardinality interval In contrast V include values default interval 0 Throughout I use r number target variables X constraint question I use d represent number target variable domain values d Dx1 Dxr X cid2x1 xrcid3 Propagation EGCC typically phases prune target cardinality variables respectively Quimper et al 18 shown enforcing GAC EGCC NPHard general However known domains cardinality variables unbroken interval GAC tractable 26 To exploit tractable case algorithms paper read prune bounds cardinality variables prune target variables bounds cardinality variables The pruning target variables similar GAC Section 21 new deﬁnition required Deﬁnition 21 For constraint Ck egcc X V C target variables X cid2x1 xrcid3 cardinality variables C cid2c1 cV cid3 cid11 cid11 constructed GACOnX deﬁned function Dk literal set P follows A new constraint C egcc X V C k cid11 cid11 cid11 cid2c ci ci The GAC function applied C Finally P k obtain literals P C set literals P cid11 V cid3 domains Dc pertaining X P yi cid8 P cid11 yi X cid11 1 c cid11 cid11 GACOnX EGCC constraint equivalent reading bounds cardinality variables creating new GCC constraint bounds enforcing GAC GCC Samer Szeider identify tractable cases example treewidth variablevalue graph bounded 26 While work theoretical clear tractable cases typi cal uses EGCC constraint 23 Basic deﬁnitions EGCC I refer target variables X x1 xr domains Dx1 Dxr The size union target domains d For simplicity domain elements assumed 1 d P Nightingale Artiﬁcial Intelligence 175 2011 586614 589 Bipartite variablevalue graph B b Flow network NC Fig 1 Example variablevalue graph ﬂow network First variablevalue graph deﬁned The variablevalue graph set vertices representing target variables second set representing values There edge variable xi value iff Dxi Fig 1a gives example variablevalue graph Deﬁnition 22 Given EGCC K bipartite variablevalue graph deﬁned BK cid2V Ecid3 V x1 xr 1 d E xi j j Dxi Next ﬂow network NK EGCC K deﬁned It derived variablevalue graph NK capacity c lower bound l edge It includes vertices variablevalue graph source vertex s sink t It deﬁned example given Fig 1b Deﬁnition 23 Given EGCC K parameters X cid2x1 xrcid3 V cid2v 1 vmcid3 C cid2c1 cmcid32 ﬂow graph NK deﬁned digraph NK cid2V Ecid3 V x1 xr 1 d s t E union following edge sets For edge BK orient edge values variables For edges v x set lv x 0 cv x 1 For value vertices v V edge s v lower bound ls v ci capacity cs v ci ﬂow s v bounds cardinality variable ci For values 1 d V edge s ls 0 cs For variables xi edge xi t lxi t 0 cxi t 1 The intuition NK integer ﬂow s t corresponds assignment target variables If ﬂow uses edge xi assignment xi If ﬂow NK covers variable vertices meets lower bounds capacities corresponds satisfying assignment target variables 24 Hall sets EGCC Hall sets useful understanding pruning target variables EGCC Two types Hall set required upper bounds lower bounds respectively The following deﬁnition upperbound Hall set equivalent Quimpers deﬁnition 17 51 Deﬁnition 24 A UBHall set H u set variables corresponding values DH u sum upper bounds DH u equals number variables H u cid3 v DHu ci cid2 Dxi xi H u In solution constraint variables H u assigned values DH u assignment meets upper bound value DH u Therefore variable x j H u assigned value DH u pruning performed Variables H u consume values DH u A small example UBHall set given Fig 2a In case variables x1 x2 x3 adjacent values 1 2 The sum upper bounds 1 2 x1 x2 x3 UBHall set 2 For simplicity assumed V 1 d If case value v 1 d corresponding cardinality variable ci set 0 590 P Nightingale Artiﬁcial Intelligence 175 2011 586614 GCC instances represented variablevalue graphs Values labelled lower upper bound interval b Example UBHall set Variables x1 x2 x3 consume values 1 2 The dotted lines pruned b Example LBHall set Values 1 2 consume variables x1 x2 x3 The dotted lines pruned Fig 2 Example UBHall set LBHall set For lower bounds Hall set similar variables values swapped This deﬁnition equivalent unstable sets deﬁned Quimper 17 52 Deﬁnition 25 An LBHall set Hl set values corresponding variables VarsHl xi Hl Dxi cid15 sum lower bounds Hl equals number variables VarsHl cid3 ci v Hl In case solution constraint variables VarsHl assigned values Hl exclusively meet lower bounds Hl Therefore values pruned The values Hl consume variables VarsHl A small example LBHall set shown Fig 2b The sum lower bounds values 1 2 values adjacent variables x1 x2 x3 1 2 LBHall set This leads pruning values The deﬁnition LBHall set captures reason prunings failure The constraint fails C S k set values Hl sum lower bounds greater number variables VarsHl cid3 exists v Hl ci UB LBHall sets closely related enforcing GACOnX Deﬁnition 21 Quimper 17 proved lower bounds upper bounds considered separately losing GACOnX decomposing EGCC upperbound constraint ubc lowerbound constraint lbc He showed correspondence Halls marriage theorem satisﬁability ubc It follows ﬁnding UBHall sets H u pruning values DH u variables suﬃcient enforce GACOnX ubc For lbc Quimper shows directly ﬁnding LBHall sets suﬃcient enforce GACOnX The algorithms presented section use UB LBHall sets prune target variables 25 Experimental context Experiments performed Minion 45 version 09 The solver modiﬁed add variants EGCC In section I overview Minion Constraint solvers provide propagation loop calls propagators global ﬁxpoint reached Propagators subscribe variable events scheduled executed events occurs Subscription event referred placing trigger trigger object placed list related event A propagator triggered called event occurred Minion provides following variable event types maxDxi changed minDxi changed value removed Dxi Dxi changed way xi assigned Triggers identiﬁed number passed propagator Therefore propagator identify exact event caused called Notiﬁcation events important EGCC propagators facility propagator scan variable domains adding linear quadratic cost The exact use variable events described Section 352 Minion variablecentric solver additional constraintcentric queue The solver queues eﬃciency reasons variable queue fast adding variable event queue O 1 operation constraint queue trigger copied queue However variable queue allow constraints given different priorities Having additional constraint queue overcomes limitation The variable queue contains variable events listed The constraint queue contains pointers constraints Con straints responsible adding constraint queue necessary It lower priority variable queue variable queue emptied item processed constraint queue In experiments presented EGCC AllDifferent constraints use constraint queue Propagators require internal state eﬃciency Minion provides backtracked memory restored search backtracks nonbacktracked memory The backtracked memory allocated search begins blocked It backtracked copying block The consequences memory architecture discussed Section 521 P Nightingale Artiﬁcial Intelligence 175 2011 586614 591 3 Pruning target variables EGCC In section I discuss pruning target variables beginning survey relevant literature There published algorithms enforce GACOnX given lower upper bounds occurrence value Régin 24 presented algorithm based network ﬂow It makes use FordFulkerson algorithm 2 compute ﬂow represents assignment target variables The assignment satisﬁes lower upper bounds value Then Tarjans algorithm compute set edges belong maximum ﬂow These edges correspond domain values pruned The time complexity algorithm O r2d dominated FordFulkerson algorithm An alternative algorithm presented Quimper et al 18173 The approach split GCC constraints enforcing GAC equivalent enforcing GAC GCC In way obtain better time bound Régins algorithm 31 Régins algorithm The ﬁrst stage Régins algorithm computes ﬂow feasible meets lower bounds maximum exceeding capacities First feasible ﬂow computed extended maximum ﬂow 311 Computing feasible ﬂow To compute feasible ﬂow second ﬂow network LBK identical NK additional edge There edge t s lt s 0 ct s In order use FordFulkerson algorithm 2 Régin deﬁnes residual graph ﬂow network ﬂow A ﬂow function mapping edges quantity material passing nonnegative integer The intuition residual graph edge vertex vertex b iff possible increase ﬂow b violating capacity ca b reduce ﬂow b violating lower bound lb The ﬁrst case applies b edge NK second case applies b edge NK Deﬁnition 31 The residual graph ResG f derived ﬂow network G ﬂow f It digraph set vertices G For edge b G f b la b edge b present ResG f If f b ca b edge b present ResG f No edges present ResG f The algorithm compute feasible ﬂow follows Suppose f infeasible ﬂow Pick edge b LBK f b la b Find simple path b ResLBK f This named augmenting path deﬁnition ResLBK f ﬂow increased path b 1 unit This denoted applying augmenting path For edge x y path f x y increased edge oriented y x LBK cid11a b f b In context increase ﬂow f y x decreased This creates new ﬂow f b 1 If augmenting path b impossible satisfy lower bound EGCC fails f cid11 Fig 3 shows examples augmenting paths residual graph ResLBK f The existing ﬂow f passes s 3 3 x3 x3 t t s In CSP terms ﬂow represents assignment x3 3 For EGCC edges lower bound nonzero s domain value s v An augmenting path forms It passes edge t s shown Fig 3a pass t s shown Fig 3b In ﬁrst case applying augmenting path increases overall ﬂow s t assigning x2 1 example In second case applying augmenting path affect overall ﬂow s t In example ﬂow s 2 increased setting x3 2 ﬂow s 3 decreased For paper implementation iterates values v f s v ls v meets lower bound v possible An augmenting path sought starting vertex v The search succeeds discovers s t fails reachable vertices explored Terminating s corresponds Fig 3b When terminating t edge t s appended augmenting path corresponds Fig 3a 312 Computing maximum ﬂow feasible ﬂow Given feasible ﬂow f 0 FordFulkerson algorithm compute maximum feasible ﬂow An augment ing path sought s t ResNK f 0 This applied create ﬂow f 1 The process repeated f 1 create f 2 The algorithm terminates augmenting path exists s t ResNK fk If maximum feasible ﬂow fk cover variable vertices constraint fails An example given Fig 4a In example feasible ﬂow f 0 uses edges 1 x1 1 x2 2 x3 edges reversed ResNK f 0 The augmenting path uses edge 4 x4 completes maximum ﬂow 3 The algorithm described ClaudeGuy Quimpers PhD thesis 17 I refer Quimpers algorithm 592 P Nightingale Artiﬁcial Intelligence 175 2011 586614 Augmenting path edge s 1 passes t b Augmenting path edge s 2 pass t Fig 3 Examples augmenting paths residual graph compute feasible ﬂow Augmenting path s t b SCCs residual graph Fig 4 Examples computing maximum feasible ﬂow SCCs residual graph 313 Finding augmenting paths FordFulkerson The main options depthﬁrst search FFDFS breadthﬁrst search FFBFS The problem similar maximum bipartite matching augmenting path alternates variables values ignoring s t Therefore I refer bipartite matching literature Setubal empirically compared ABMP FFBFS FFDFS Goldbergs algorithm 29 He generated bipartite graphs 2p vertices partition p 8 17 With estimate 29 vertices fewer partition4 examination Setubals results sequential computers taking size closest 29 smaller sizes shows FFBFS competitive classes eﬃcient equal 811 classes graphs 1013 sets particular size Setubal recommends FFBFS graphs thousands vertices Given results I FFBFS 314 Pruning domains The second stage Régins algorithm makes use strongly connected components SCCs An SCC maximal set vertices digraph property path vertex set It follows cycles SCCs cycles edges SCCs The set SCCs forms partition vertices digraph Tarjans algorithm eﬃciently compute SCCs digraph O V E time 31 An edge form v x j NK maximum feasible ﬂow corresponds value pruned v pruned x j Given maximum feasible ﬂow f covers variable vertices residual graph ResNK f partitioned SCCs If edge v x j goes SCCs ﬂow f algorithm prunes v Dx j 4 The largest EGCC constraint benchmark instances 200 variables fewer values smaller 29 P Nightingale Artiﬁcial Intelligence 175 2011 586614 593 The intuition result edge v x j residual graph v x j SCC simple path x j v deﬁnition SCCs This path augmenting path increase ﬂow v x j Hence v x j maximum feasible ﬂow However v x j different SCCs path x j v v x j maximum feasible ﬂow f In case algorithm prunes v x j Another understanding Régins algorithm comes Hall sets Every pruning justiﬁed UBHall set Deﬁni tion 24 LBHall set Deﬁnition 25 Section 24 For deletion Dxi consumed UBHall set contain xi xi consumed LBHall set contain In cases Hall set corresponds directly SCC residual graph ﬁrst case SCC containing second SCC containing xi Fig 4b shows example f ﬂows edges 1 x1 1 x2 2 x3 4 x4 SCCs ResNK f marked dotted lines The edges 4 x3 3 x3 3 x1 cross SCCs corresponding values pruned target domains Tarjans algorithm pruning domains implemented exactly described 6 315 Time complexity Régins algorithm If δ number edges BK sum sizes target variable domains r number target variables time ﬁnd maximum feasible ﬂow FordFulkerson O rδ No r augmenting paths applied The complexity Tarjans algorithm Θδ run time bounded δ asymptotically Tarjans algorithm uses edge graph Régin suggests Dinics algorithm 32 faster practice FordFulkerson 24 However Dinics al gorithm SleatorTarjan method ﬁnding blocking ﬂow described Tarjan 32 upper bound O rδ logr d This bound tight problem In paper I consider Dinics algorithm greater complication worse time bound 32 Quimpers algorithm The approach taken Quimper et al 1817 split GCC lower bound constraint lbc upper bound constraint ubc The lbc ensures lower bound value respected similarly ubc enforces upper bound Enforcing GAC lbc ubc independently prunes values GAC GCC 19 For lbc ubc twostage algorithm similar Régins For ﬁrst stage lbc ubc variablevalue graph BK structure similar maximum matching computed A conventional maximum matching M maximumcardinality set edges BK vertex occurs M This generalized allowing vertices occur value vertices occur multiple times capacity capa value Variable vertices occur A generalized maximum matching computed modiﬁed HopcroftKarp algorithm 10 The modiﬁcation simple affect worstcase execution time In lbc capa set lower bound value ubc upper bound At point lbc fails matching meet lower bounds The lbc matching completed cover variable vertices matching unmatched variable vertex arbitrary value The ubc fails generalized matching cover variables For second stage algorithms matchings translated ﬂows NK For matching M cor responding ﬂow f M edge x y M carries unit ﬂow f M Each edge BK M carries ﬂow f M The second stage Régins algorithm changes bounds ubc 0 lower bound values lbc upper bound values Finally necessary run propagators alternately ﬁxpoint enforce GAC GCC It suﬃcient run The implementation paper runs lbc propagator ubc propagator The use HopcroftKarp place FordFulkerson produces tighter time bound O r15d O r05δ propagator Although Quimpers algorithm tighter upper bound better practice maintains maximal matchings Régins algorithm makes calls Tarjans algorithm The algorithms compared experimentally Section 53 33 Review optimizations basic algorithms The algorithms described similar Régins AllDifferent algorithm 23 A number opti mizations collection algorithms proposed authors They surveyed section 331 Incremental matching The maximum ﬂow M matchings Ml Mu case Quimpers algorithm maintained incrementally search 24 This storing M calls propagator When propagator called M longer maximum domain removals ﬂow matching algorithm repair For AllDifferent incremental matching shown improve eﬃciency 6 594 P Nightingale Artiﬁcial Intelligence 175 2011 586614 332 Incremental graph maintenance The original GAC AllDifferent algorithm 23 stores graph calls maintaining graph incrementally variable domains change One parameter algorithm set values deleted variable domains ﬁrst step algorithm update graph This idea costs updating graph removing edges backtracking graph search backtracks Whether beneﬁt outweighs cost empirical question answered The implementation incremental graph maintenance discussed Section 351 An algorithm incremental graph maintenance discover graph traversed querying variable domains maximum ﬂow This approach AllDifferent Gent et al 6 333 Priority queue Many constraint solvers priority queue constraints Choco 14 Gecode 27 priorities determine order constraint propagators executed It standard practice EGCC low priority Schulte Stuckey demonstrate importance priority queueing 27 evaluated experiments 334 Staged propagation Schulte Stuckey proposed multiple staged propagation AllDifferent 27 cheap propagator high priority combined expensive low priority propagator I experiment staged propagation EGCC paper interesting area future work 335 Dynamic partitioning Gent et al 6 proposed algorithm partitions AllDifferent constraint search Suppose example AllDifferentx1 x6 x1 x3 1 3 x4 x6 4 6 This partitioned independent cells AllDifferentx1 x3 AllDifferentx4 x6 The main beneﬁt variable xi changed propaga tor need executed cell containing xi original constraint This saves time Tarjans algorithm A cheap way obtaining partition use SCCs residual ﬂow network computed Régins AllDifferent algorithm In cases possible ﬁnd ﬁner partition SCCs However experiments showed SCCs partition effective practice 6 In paper I generalize dynamic partitioning EGCC constraint This described Section 342 336 Assigned variable removal The implementation EGCC Gecode 27 updates array target variables time called removing assigned variables5 This promises lightweight effective optimization It evaluated Section 56 Dynamic partitioning subsumes assigned variable optimization assigned variable singleton SCC active cell constraint However dynamic partitioning likely expensive 337 Domain counting Recall Quimpers algorithm divides constraint upperbound constraint ubc lowerbound constraint lbc Quimper Walsh observed ubc need propagated domains large 20 They proposed algorithm constructs sorted list sizes target variable domains It iterates list determines ubc propagator run I suspect algorithm expensive general use problem classes prove valuable Quimper Walsh domain counting algorithm lbc A simpler form domain counting AllDifferent Lagerkvist Schulte following scheme triggered target variable xi propagator runs Dxi cid2 r r arity constraint 15 Gent et al improved threshold Dxi cid2 r 1 6 ﬁnd domain counting useful experiments It possible derive similar domain size threshold ubc deﬁnition UBHall set Deﬁnition 24 However possible lbc Consider deﬁnition LBHall set Deﬁnition 25 The size domains variables LBHall set restricted deﬁnition Since possible lbc possible EGCC I experiment domain counting form 338 Important edges Katriel observed value removals affecting GCC constraint result value removals work processing wasted 12 She introduces concept important edge residual graph An important edge removal causes pruning variablevalue pair Therefore unimportant edge removed necessary run propagator Where r number target variables Katriel gave upper bound 3r number important edges correspond domain values edges variable vertices value vertices 5 Guido Tack personal communication P Nightingale Artiﬁcial Intelligence 175 2011 586614 595 Katriel shows allowed values variable expected cost propagation reduced She proposes count pruned values run propagator counter reaches threshold value The threshold set propagator likely prune value executed This algorithm enforce GAC GCC Katriel report implementation observes risks failing propagate outweigh reduced cost propagation While implementation Katriels probabilistic algorithm interesting fact maintain GAC GCC puts outside scope paper Gent et al 6 gave algorithm AllDifferent identify small set edges containing important edges possibly The identiﬁed edges correspond important domain values The propagator executed important domain value removed maintaining GAC fewer calls propagator This approach adapted EGCC Section 353 339 Entailment Quimper et al conditions GCC constraint entailed unacceptable tuples relation constraint current domains 18 If constraint entailed need propagated current search node descendents For lower bound constraint condition value v lower bound LBv LBv variables assigned v Similarly upper bound constraint value v UBv domains contain v However EGCC entailed variables assigned If variable assigned acceptable tuple turned unacceptable tuple changing value variable I experiment entailment GCC conditions tight likely occur large number variables assigned beneﬁt appears limited Also architecture Minion suited entailment discussed Section 521 34 Novel optimizations pruning target variables In section I optimizations The ﬁrst change Régins algorithm intended improve computa tion maximum ﬂow The second generalizes dynamic partitioning described Section 335 EGCC 341 Transpose graph computing maximum ﬂow To compute maximum feasible ﬂow feasible ﬂow Régins algorithm uses graph NK seeks paths s t NK An alternative use transpose NK denoted NK T The transpose NK direction edge reversed A path t s NK T equivalent path s t NK The direction ﬂow f reversed form f T algorithm searches paths t s residual graph ResNK T f T The algorithm works follows Iterate edges t xi carry ﬂow For edge search path p xi s If path augment ﬂow p t xi If path p possible construct ﬂow covers variables algorithm fails immediately The conventional Régins algorithm completes maximum ﬂow testing covers variables When transpose graph algorithm potentially stop earlier discovers variable maximum ﬂow Also search augmenting path focused starts speciﬁc variable Quimpers algorithm uses transpose graph like Régins algorithm completes maximum ﬂow testing covers variables 18 In Section 54 approach evaluated compared Régins original algorithm For algorithms breadthﬁrst search ﬁnd augmenting paths 342 Dynamic partitioning Dynamic partitioning essentially rewrites EGCC constraint multiple independent constraints domains narrowed As described Section 335 Gent et al gave algorithm dynamic partitioning AllDifferent 6 The AllDifferent algorithm maintains partition set variables I generalize algorithm EGCC Consider following EGCC constraint x4 x6 2 3 4 x1 x3 1 3 c1 c2 0 1 cid4 EGCC c3 c4 0 1 2 cid5 x1 x6 1 2 3 4 c1 c2 c3 c4 GACOnX propagation removes value 3 variables x4 x6 Following domains x1 x3 x4 x6 disjoint constraint rewritten constraints shown cid4 EGCC cid4 EGCC cid5 x1 x3 1 3 c1 c3 cid5 x4 x6 2 4 c2 c4 596 P Nightingale Artiﬁcial Intelligence 175 2011 586614 Fig 5 The reﬁnement partition EGCC constraint rewritten multiple constraints Suppose x3 assigned 3 The ﬁrst constraints rewritten follows cid4 EGCC cid4 EGCC cid4 EGCC cid6 c1 c3 1 cid7cid5 x1 x2 1 3 cid5 x3 3 1 cid5 x4 x6 2 4 c2 c4 In case domains x1 x2 x3 disjoint share value 3 One occurrence 3 resides x3 c3 1 occurrences 3 reside x1 x2 Suppose x1 assigned 3 Now occurrences 3 reached upper bound propagation rewriting situation cid4 EGCC cid4 EGCC cid4 EGCC cid4 EGCC cid5 x2 1 1 cid5 x1 3 1 cid5 x3 3 1 cid5 x4 x6 2 4 c2 c4 The EGCC algorithm maintains partition set containing target variables values The major changes AllDifferent values included partition corner cases EGCC involving singleton variables values accounted Initially partition cell consisting target variables values The partition reﬁned propagation search progresses restored search backtracks In example ﬁnal reﬁned partition x1 x2 x3 1 3 x4 x5 x6 2 4 Assigned variables singleton sets values number occurrences reached upper bound The partition I use corresponds SCCs residual graph Section 314 stored partition data structure described 6 Target variables represented integers 0 r 1 values r r d 1 d values The data structure allows item located O 1 time cell iterated linear time Splitting cell takes linear time undoing split operation backtracking O 1 Fig 5 gives example partition data structure 6 works EGCC Each cell stored setElements contiguous block particular order The array splitPoint marks cell ends Only splitPoint backtracked search backtracks cells join elements different order A array maps variable value index setElements allowing located O 1 time An assigned target variable forms singleton SCC assigned variables removed active cells constraint cause overhead Triggering dynamic partitioning The constraint maintains set τ target variables values processed When constraint notiﬁed domain change event adds variable changed target variables corresponding value cardinality variables τ τ cleared propagator executes search backtracks P Nightingale Artiﬁcial Intelligence 175 2011 586614 597 When propagator called iterates τ constructs set cells propagated A cell prop agated iff cell contains variable value τ Propagation performed cell set independently Cells propagated costfree This scheme relies solver notifying propagator changed variables If information available propagator discover changed variables iterating target variable domain add quadratic cost outweigh speedup caused optimization Dynamic partitioning affects worstcase analysis Tarjans algorithm Without dynamic partitioning bound Θδ δ number edges residual graph With dynamic partitioning bound O δ runs Tarjans algorithm triggered cells constraint effect ignoring parts residual graph 35 Implementation optimizations literature In section I implementation details optimizations literature speciﬁed original papers 351 Incremental graph maintenance In optimization variablevalue graph stored calls updated incrementally This ﬁrst Régin 23 described Section 332 For vertex variablevalue graph iterable list adjacent vertices required The order iteration important obtaining element O 1 Similarly removing element testing presence list O 1 operations Restoring list backtracking cheap possible The following representation vertex represented unique integer small range List An array vertices integers backtracked ListSize A single integer representing size adjacency list This backtracked InvList An array mapping vertices positions List Not backtracked This representation advantages minimizing backtracking memory directly iterable The removal operation vertex swap item end list place position ListSize1 reduce ListSize disappears list On backtracking ListSize restored reappears list end InvList allows constant time updated swap performed Thus removal operation O 1 An item list iff InvLista ListSize This data structure solver Mistral 8 ListSize backtracked copying described Section 25 The constraint notiﬁed pruned value target variables These events maintain adjacency lists queue constraint propagation necessary Fixpoint reasoning It helpful perform ﬁxpoint reasoning 27 The EGCC propagator idempotent repeated variables When prunes value target variable notiﬁed later pruning need run propagator When adjacency lists relevant lists updated immediately pruning occurs When constraint notiﬁed pruning tests lists need updated If constraint queued propagation Hence adjacency lists propagator limited ﬁxpoint reasoning 352 Priority queueing triggering EGCC places triggers upper lower bounds cardinality variables If incremental graph mainte nance notiﬁed individually value removed target variable Otherwise notiﬁed changes target variables specifying variable affected values removed The EGCC triggered ways depending conﬁguration Normal priority The propagator executed notiﬁed event Low priority The propagator queued added constraint queue present event Low priority incremental graph The propagator queued event cardinality variable For target variables propagator queued notiﬁed value removal reﬂected adjacency lists 353 Important edges dynamic triggers The edges residual graph partitioned important unimportant discussed Section 338 Only removal important edge cause pruning target variables The number calls Régins algorithm reduced ignoring removal unimportant edges The algorithm presented Gent et al 6 records edges T Tarjans algorithm uses internal proof SCC strongly connected Tarjans algorithm performs depthﬁrst search DFS residual graph R The edges R traversed DFS included T The algorithm maintains integer named lowLink vertex During DFS lowLink values updated edges graph criterion identifying SCC based 598 P Nightingale Artiﬁcial Intelligence 175 2011 586614 Fig 6 Finding important edges T ResNK f The ﬂow f uses edges x1 1 x2 2 x3 3 The DFS tree Tarjans algorithm shown red dotted lines The edges T shown black lines Three edges corresponding domain values unimportant For interpretation references color reader referred web version article lowLink value For vertex lowLink value changed times ﬁnal value identifying SCCs edge obtain ﬁnal value included T All edges R included T This algorithm correct EGCC Fig 6 shows example ﬁnding T EGCC constraint While edges T remain residual graph component remain strongly connected pruning possible This method yields 2r d edges correspond domain values Compared Katriels theoretical bound 3r 12 d r spurious edges However method simple fast minimal instrumentation Tarjans algorithm change time bound Two variants AllDifferent implemented Gent et al 6 based important edges The ﬁrst variant dynamic triggers movable triggers restored backtracking moving 2r d value triggers time Tarjans algorithm executed Dynamic triggers substantially expensive static triggers experiments cost dynamic triggers outweighed beneﬁt cases The second variant records important domain values backtracking arrays When propagator triggered returns immediately important value removed The main cost backtracking arrays block copying In experiments minor improvement average 6 speedup This approach referred internal dynamic triggers simulates dynamic triggers constraint The internal dynamic triggers method Gent et al 6 trivially adapted EGCC The algorithm constructing set T unchanged For variable list values stored corresponding edges T The lists linked lists stored block backtracking memory size O 3r d This allows O 1 append quick iteration lineartime clear The propagator changed places Tarjans algorithm changed record T values backtracking array When cell target variables Xcell triggered changed variable xi Xcell checked list T values If T values deleted target variables pruned cell6 Cardinality variables pruned regardless This approach evaluated Section 57 4 Pruning cardinality variables In section I algorithms pruning cardinality variables The ﬁrst simple approach counts values target domains use ﬂow network The second approach use simple algorithm add implied sum constraint The approach computes maximum minimum ﬂow particular value In cases algorithm described run pruning target variables These methods compared empirically Section 58 41 A simple algorithm For domain value simple upper bound number target variables domain A lower bound number target variables assigned For value incremental graph maintenance algorithm iterates target variables computes upper lower bound When incremental graph maintenance upper bound known length adjacency list The algorithm ﬁnds lower bound iterating adjacency list counting assigned variables 6 If dynamic partitioning consider constraint cell containing target variables P Nightingale Artiﬁcial Intelligence 175 2011 586614 599 If dynamic partitioning algorithm processes values cells constraint triggered Assigned variables removed active cells constraint values occur assigned variables processed The algorithm described stateless requires backtracking state quadratic O rd behaves combined dynamic partitioning incremental graph maintenance A stateless O r d algorithm possible preliminary experiments beneﬁt algorithm partition dynamically I disregarded It possible construct stateful O d algorithm maintaining number variables assigned value set backtracking integers I avoided requires backtracking memory 42 An implied sum constraint A second approach use simple algorithm add implied sum constraint cardinality variables The total occurrences values equal number target variables egccX V C cid8 C r This implied constraint sound iff values domains target variables V corre sponding cardinality variable This approach Gecode 277 However Gecode deﬁnition EGCC slightly different variables X allowed values V Therefore sum constraint sound Gecode 43 A ﬂow network algorithm Quimper et al 18 proposed algorithm based ﬂow network NK For value cardinality variable ca algorithm ﬁnds maximum ﬂow containing minimum occurrences This prune lower bound ca Similarly ﬁnds maximum ﬂow containing maximum occurrences prune upper bound ca This expensive method provides maximum possible pruning assumption domains cardinality variables unbroken interval 431 Pruning lower bounds The algorithm described Quimper et al follows Take existing maximum ﬂow f respects upper bounds values Remove units ﬂow pass valuevertex form reduced ﬂow fa Similarly remove vertex incident edges NK form new network NK Using FordFulkerson algorithm cid11 network NK augment fa ﬁnd maximum ﬂow f s t cid11 represents maximum assignment target variables X values occurrences upper cardinality bounds Therefore complete assignment X r f ca cid3 r f cid11 f cid11 The implementation makes use transpose graph identical described Section 341 changes algorithm stop encounters variablevertex augmenting path graph NK T place NK T algorithm halts size ﬂow reaches r ca case possible prune ca The time required prune cardinality lower bounds O r2d 18 O rδ δ number edges NK This algorithm seeks r augmenting paths 432 Pruning upper bounds To ﬁnd new upper bound value ﬂow edge s NK maximized observing lower cardinality bound values Quimper et al prove O r266 time To ﬁnd upper bound start nonmaximal ﬂow fl exactly cb occurrences value b maximum number free variables The goal maximize ﬂow paths free variable If valuevertex fl path excluding s free variable ResNK fl The number reachable vertices 2r 1 The authors identify network special case cite proof maximum ﬂow O r266 time The implementation simpler It begins maximum ﬂow f respects lower bounds values To ﬁnd upper bound algorithm maximizes ﬂow s ﬁnding augmenting paths BFS NK excluding s starting ending valuevertex b f s b cb ﬂow b greater lower bound The path applied increase ﬂow decrease b The algorithm halts size ﬂow reaches ca case possible prune ca The ﬁnal ﬂow edge s new upper bound ca 7 Guido Tack personal communication 600 P Nightingale Artiﬁcial Intelligence 175 2011 586614 In common Quimpers algorithm number reachable vertices 2r 1 fewer To prune capacity vari ables C time bound O Cr3 factor r13 eﬃcient 5 Experimental evaluation In section I context experimental evaluation Then I present groups experiments First I compare algorithms optimizations pruning target variables experiments ﬁve Secondly I compare algorithms pruning cardinality variables experiment Finally Section 510 best propagation method target variables compared careful unoptimized implementation Régins algorithm Also best EGCC propagator compared decomposition EGCC set occurrence constraints demonstrating utility EGCC global constraint 51 Benchmark set In section I problem classes instances compare propagation algorithms 511 Car sequencing The car sequencing problem 9 prob001 sequence cars conveyor factory There number optional parts ﬁtted cars optional corresponding machine ﬁts For option machine accept pi cars qi Therefore contiguous subsequence length qi pi cars requiring option There number l different types car type set options requires A ﬁxed number type required sequence Finally length n sequence given Three models problem presented They share common core There explicit representation seq sequence This array length n variables domain 0 l 1 representing type car An EGCC constraint placed seq enforce required number type car All models contain twodimensional array optused Boolean variables For sequence index j option k optused j k indicates car position j requires option k Each element optused j k connected seq j binary table constraint Model A Régin Puget presented encoding capacity constraints machines set EGCC constraints 25 It complex model I reproduce For option n qi 1 subsequences seq consider For subsequence need state pi cars require option This n qi extra variables qi EGCC constraints n target variables There cardinality variable subsequence giving number cars subsequence require option Two consecutive subsequences length overlap qi 1 cars corresponding cardinality variables differ 1 difference easily determined A set logic arithmetic constraints added capture fact The key advantage Régin Pugets model EGCC constraints combine subsequence capacities straints sequence Each car type requires option represented auxiliary variables required number car type enforced EGCC constraints Régin Puget report level consistency EGCC cardinality variables However instance 2 Régin Puget report 9355 fails ILOG Solver 25 Minion performs 9452 left branches simple cardinality pruning algorithm Section 41 Instance 1 similar 0 fails ILOG Solver 113 left branches Minion This suggests model propagation variable ordering equivalent Model B In car sequencing single sequence constraint 33 represent capacity constraints option The sequence constraint option given parameters pi qi posted variables optusedi It restricts number position occurrences value 1 optusedi Van Hoeve et al 33 proposed encoding sequence constraint regular constraint constraint recognizes regular language In case language set assignments optusedi satisfy capacity constraints option The corresponding deterministic ﬁnite automaton DFA O 2qi states A cost parameter added ﬁx total number cars option ﬁx number 1s optusedi costregular propagator 3 enforce GAC resulting constraint Minion costregular regular propagators constraint encoded table constraints First DFA augmented counter counts number 1s sequence Only sequences correct number 1s accepted augmented DFA The number states increased O n2qi The augmented DFA encoded set ternary table constraints described Quimper Walsh 21 GAC enforced table constraints This equivalent enforcing GAC original costregular constraint P Nightingale Artiﬁcial Intelligence 175 2011 586614 601 Table 1 EFPA example v 5 q 3 λ 2 d 4 c1 c2 c3 c4 c5 0 0 0 0 0 0 1 1 2 2 1 0 2 1 2 1 2 0 2 1 2 1 2 0 1 2 2 1 1 0 Model AB Model AB combination models A B This similar model C A REG cost van Hoeve et al 33 Variable value ordering All models use variable value ordering Régin Puget 25 First options ordered according measure tightly constrained For option measure uses demand denoted ki number cars sequence require The slack option n qikipi low slack indicates option tightly constrained8 The optused variables searched First options ordered slack slack ﬁrst For option variables branched middle step unassigned variable closest middle sequence selected Finally value order 1 0 80 instances Instances 0 4 Régin Puget9 5 79 instances given CSPLib prob001 9 512 Magic sequence The magic sequence problem 9 prob019 ﬁnd sequence length n element sequence number occurrences sequence It modelled list X n variables domain 0 n 1 There constraint EGCC X cid20 n 1cid3 X The variables searched index order values explored ascending order Instances generated n 20 30 40 50 100 150 200 300 513 Equidistant frequency permutation arrays EFPAs The EFPA problem 11 ﬁnd set maximal size codewords pair codewords Hamming distance d apart Each codeword considered sequence symbols alphabet 1 q symbol occurring ﬁxed number λ times codeword A fourth parameter v number codewords set Typically v maximized Table 1 shows example EFPA The problem modelled twodimensional array variables row represents codeword The model given Huczynska et al 11 nonBoolean model implied constraint set The variable value ordering described The 24 instances EFPA experiments 11 added d 4 q λ 5 v 11 12 This provides mixture 13 satisﬁable instances 13 unsatisﬁable unknown instances Each row model EGCC constraint qλ target variables enforce λ occurrences symbol There EGCC constraints λ target variables implied constraints 514 Roundrobin sports scheduling The roundrobin sports scheduling problem 9 prob026 schedule games n teams n2 pitches n 1 weeks The model variable value ordering given 6 EGCC constraints added enforce requirement team plays pitch twice This gives n2 EGCCs 2n 1 target variables capacities 0 2 values Instances generated n 10 12 14 16 52 Experimental setup For experiments I use Minion described Section 2510 The instances preprocessed I timeout 1800 s The experiments run Linux Ubuntu 910 server Intel Xeon quadcore E5520 CPUs clocked 227 GHz 12 GB RAM Minion performs binary search left branch assigns variable It counts left branches The speed search measured dividing number left branches time taken referred branch rate In setup timings branch rates exhibit variation To measure variation I PriorityQIncMatch IncGraph propagator Section 55 measured branch rate twice benchmark timeout 1800 s 8 Régin Puget claim negative slack means capacity constraint option satisﬁed 25 This true ends sequence special case Consider problem n 8 option parameters pi 2 qi 3 demand ki 6 The slack option 1 capacity constraint satisﬁed optused sequence cid21 1 0 1 1 0 1 1cid3 9 For instances 0 3 option ordering derived slack reported Régin Puget 25 adjusted hand 10 Source code solver available httpwwwcsstandrewsacukpnegcc 602 P Nightingale Artiﬁcial Intelligence 175 2011 586614 For instance absolute difference rates divided smaller rate obtain proportional difference The mean values 003 larger branch rate 3 larger smaller maximum 050 Those instances completed 01 s showed variation excluding mean 003 maximum 017 In experiments median runs For experiment comparing algorithms A B determine statistical signiﬁcance I Wilcoxon paired signedrank test implemented R 22 The branch rates A B measured benchmark instances The null hypothesis branch rates drawn distribution A B run speed The difference A B deemed signiﬁcant probability null hypothesis 001 The implementations EGCC extensively tested debugged variants report branch count instances complete timeout 521 Solver architecture The EGCC propagators use Minion features available solvers Perhaps important notiﬁcation variables changed incremental graph values pruned This granularity events widely available example Gecode advisors 15 Choco 14 Another important consideration memory architecture Minion allows propagators backtracked non backtracked memory The backtracked memory propagators blocked allocated freed search Memory backtracked copying block eﬃcient backtracked memory small static Memory architecture affects optimizations EGCC experimental results marginal reversed different architecture Different data structures required different architecture In contrast Minion Gecode backtracks state copying When search branches Gecode traverses tree objects including constraints variables copies individually This architecture different properties Minion Entailment Section 339 case point Gecode constraint entailed removed tree triggers removed cost copying constraint triggers removed In Minion triggers copied search branches backtracking state constraint deallocated Therefore potential gain detecting entailment Minion Gecode employs entailment GCC11 53 Experiment comparing Quimpers Régins algorithms In section I compare basic algorithms pruning target variables To choices These choices mainly based current stateoftheart literature I use priority queue EGCC low priority Section 352 incremental matching Section 331 incremental graph mainte nance Section 351 including ﬁxpoint reasoning I use dynamic partitioning Section 342 assigned variable removal Section 336 dynamic triggers Section 353 transpose graph Section 341 The weakest algorithm prune cardinality variables Section 41 The algorithms referred BaselineRégin Baseline Quimper Fig 7 shows experimental results comparing Régins algorithm Quimpers The results strongly favour Régins algorithm despite better worstcase bound Quimpers algorithm The results statistically signiﬁcant mean speedup 162 times Recall speed solver measured 162 lower bound true speedup EGCC propagator The performance algorithms closest car sequencing model B These instances contain EGCC constraint large set table constraints typically 1000 constraints Therefore potential speed improving EGCC algorithm limited Quimpers algorithm intends speed ﬁrst stage process computing maximum ﬂow matching sophisticated algorithm The second stage identical Régins performed twice Quimpers algorithm To investigate I proﬁled BaselineRégin Callgrind 35 Table 2 shows proportion CPU instructions spent ﬂow algorithm Tarjans algorithm The solver proﬁled easy satisﬁable instance problem class For instances algorithm spends 60 CPU instructions Tarjans algorithm 15 ﬂow algorithm This consistent empirical results Tarjans algorithm expensive stage counterproductive run twice order speed ﬁrst stage In cases proportion instructions spent maximum ﬂow algorithm surprisingly low bulk instructions spent Tarjans algorithm While ﬂow algorithm worse upper bound Tarjans algorithm reaches upper bound Section 315 Based results Régins algorithm rest experiments 11 Guido Tack personal communication P Nightingale Artiﬁcial Intelligence 175 2011 586614 603 Fig 7 Speedup BaselineRégin compared BaselineQuimper The graph scatterplot point comparing results single instance The xaxis represents run time Quimpers algorithm solve instance The yaxis gives speedup obtained Régins algorithm instead Quimpers algorithm A ratio 1 indicates methods run speed ratios higher 1 indicating Régins algorithm faster ratios 1 indicating Quimpers algorithm faster The ratio calculated dividing branch rate Régins algorithm Quimpers algorithm In graph Régins algorithm performs substantially better Quimpers algorithm All subsequent graphs labelled Speedup X compared Y follow conventions case X BaselineRégin Y BaselineQuimper Table 2 Instructions spent ﬂow algorithm Tarjans algorithm proportion propagator BaselineRégin To avoid inlining solver recompiled optimizations Instance EFPA4448 Magic sequence 40 Car seq A instance 1 Car seq B instance 1 Car seq AB instance 1 Sports scheduling 10 Search nodes 27100 145 113 111 111 36926 Calls 86824 40157 6400 116 6064 324860 Proportion ﬂow algorithm 14 14 57 73 58 74 Proportion Tarjans algorithm 71 67 65 92 64 76 54 Experiment making use transpose graph In Section 341 I described change Régins algorithm intended speed computation maximum ﬂow To evaluate I use experimental setup previous experiment simply compare Régins original algorithm variant Fig 8 plot results It appears measurement noise hides difference algorithms The difference statistically signiﬁcant To obtain exact data I proﬁled solver Callgrind 35 The proﬁler provides total number structions spent function functions called Table 3 shows instruction counts ﬁnding repairing maximum ﬂow transpose graph The proportion compared propagator given Using transpose graph substantial gains cases For example car sequencing A instance 33 better However instance overall gain low propagator spends 57 instructions maximum ﬂow algorithm Based results experiment I use Régins algorithm transpose graph 55 Experiment standard optimizations Régins algorithm In section I experiment optimizations literature investigate worthwhile The following variants Régins algorithm 604 P Nightingale Artiﬁcial Intelligence 175 2011 586614 Fig 8 Speedup transpose compared Régins original algorithm Table 3 Instruction counts ﬁnding repairing maximum ﬂow transpose graph To avoid inlining solver recompiled optimizations Instance EFPA4448 Magic seq 40 Car seq A 1 Car seq B 1 Car seq AB 1 Sports sched 10 Search nodes 27100 145 113 111 111 36926 Calls 86824 40157 6400 116 6064 324860 Standard Régins algorithm 267 m 315 m 290 m 463 m 284 m 1724 m Transpose 247 m 297 m 193 m 462 m 188 m 1201 m Instructions max ﬂow standard 14 14 57 73 58 74 Simple The algorithm described Section 31 transpose graph optimization Section 341 run normal priority The weakest algorithm prune cardinality variables Section 41 PriorityQ The Simple algorithm run low priority described Section 352 PriorityQIncMatch PriorityQ plus incremental matching described Section 331 PriorityQIncMatchIncGraph PriorityQIncMatch plus incremental graph maintenance described Section 351 Fig 9 shows worthwhile use priority queue All instances faster PriorityQ compared Simple Even Magic Sequence instances constraint beneﬁt PriorityQ propagator called multiple variable events Fig 10 shows worthwhile use incremental matching Almost instances faster PriorityQIncmatch compared PriorityQ substantial speedups cases Finally Fig 11 shows cases worthwhile use PriorityQIncMatchIncGraph compared PriorityQ IncMatch The main exception magic sequence problem instances slower PriorityQIncMatch IncGraph For comparisons difference statistically signiﬁcant Based results I use PriorityQIncMatch IncGraph baseline subsequent experiments The results PriorityQ IncMatch broadly similar AllDifferent 6 However AllDifferent speedup IncGraph substantial 16 Also dynamic partitioning IncGraph detrimental instances 16 56 Experiment assigned variable removal dynamic partitioning In experiment I evaluate assigned variable removal AVR dynamic partitioning These optimizations closely related dynamic partitioning subsumes AVR partitions assigned variables singleton cell I compare following variants experimentally P Nightingale Artiﬁcial Intelligence 175 2011 586614 605 Fig 9 Speedup PriorityQ compared simple Fig 10 Speedup PriorityQIncMatch compared PriorityQ Baseline The PriorityQIncMatchIncGraph previous section BaselineAVR Baseline assigned variable removal Section 336 BaselineCell Baseline dynamic partitioning described Section 342 The second stage Régins algorithm Tarjans algorithm expensive ﬁrst stage Table 2 As discussed Section 342 dynamic partitioning improves time bound Tarjans algorithm Θδ O δ AVR effect Fig 12 shows worthwhile remove assigned variables cases diﬃcult instances In best case sped solver 25 times worst case slowed 35 The comparison BaselineCell Baseline plotted Fig 13 In case results pronounced AVR speed 56 times best case Car sequencing models A AB magic sequence problem beneﬁt substantially dynamic partitioning EFPA sports scheduling substantial beneﬁt Car sequencing 606 P Nightingale Artiﬁcial Intelligence 175 2011 586614 Fig 11 Speedup PriorityQIncMatchIncGraph compared PriorityQIncMatch Fig 12 Speedup BaselineAVR compared Baseline model B shows beneﬁt 6780 instances running faster dynamic partitioning EGCC constraint The mean average speedup 156 For comparisons difference statistically signiﬁcant For AllDifferent dynamic partitioning effective 6 yielding mean speedup 298 times assignment optimization Dynamic partitioning superﬁcially appears effective AllDifferent benchmark sets entirely different 57 Experiment ﬁve internal dynamic triggers All previous optimizations intended speed propagator In contrast internal dynamic triggers IDT Section 353 intended reduce number times Régins algorithm called P Nightingale Artiﬁcial Intelligence 175 2011 586614 607 Fig 13 Speedup BaselineCell compared Baseline Table 4 Calls Régins algorithm comparing Baseline BaselineIDT Instance EFPA4448 Magic sequence 40 Car seq A instance 1 Car seq B instance 1 Car seq AB instance 1 Sports scheduling 10 Search nodes 27100 145 113 111 111 36926 Calls Baseline 86824 40157 6400 116 6064 324860 Calls BaselineIDT 57260 8116 1856 114 1662 196472 Dynamic partitioning reduces cost pruning target variables reduces potential internal dynamic triggers save time Therefore I evaluate internal dynamic triggers dynamic partitioning Four variants Baseline The Baseline previous section BaselineIDT Baseline internal dynamic triggers Section 353 BaselineCell Baseline dynamic partitioning BaselineCellIDT BaselineCell internal dynamic triggers Table 4 shows number calls Régins algorithm Baseline BaselineIDT easy problems previously It shows dynamic triggers approach substantially reduce number calls The encouraging magic sequence 40 number calls reduced 80 Fig 14 shows empirical results comparing BaselineIDT Baseline The magic sequence problem beneﬁts IDT red herring unusual structure For problems difference ranges 05 16 times faster Overall mean speedup 115 This indicates overhead maintaining tracking internal dynamic triggers cancels beneﬁt cases Although algorithms similar difference statistically signiﬁcant As expected dynamic partitioning reduces beneﬁt dynamic triggers BaselineCellIDT 7 slower average BaselineCell benchmarks BaselineCellIDT faster 69 278 instances The maximum speedup 7 The difference statistically signiﬁcant As discussed Section 353 cost collecting trigger values negligible likely IDT help particularly long constraints However observed Dynamic triggers unsuccessful AllDifferent applied dynamic partitioning 6 608 P Nightingale Artiﬁcial Intelligence 175 2011 586614 58 Experiment pruning cardinality variables Fig 14 Speedup BaselineIDT compared Baseline In experiment I compare methods pruning cardinality variables described Section 4 Dynamic partitioning BaselineCell substantial improvement Baseline I use BaselineCell combine methods follows BaselineCell The BaselineCell previous section This employs simple cardinality algorithm described Section 41 BaselineCellSum BaselineCell additional sum constraint described Section 42 For benchmarks sum constraint correct BaselineCellFlow BaselineCell ﬂow cardinality algorithm described Section 43 The variants perform different levels propagation ordered powerful In exper iment I compare run times branch rates I evaluate instances cardinalities constants This leaves car sequencing models A AB magic sequence EFPA The Wilcoxon paired signedrank test applied run time branch rate result pair methods signiﬁcantly different Since BaselineCellSum improvement BaselineCell I compare ﬁrst Fig 15 shows usefulness sum constraint depends problem class On magic sequence consistently useful It useful majority car sequencing problems variant timed As shown Table 5 BaselineCellSum able solve additional instance magic sequence 300 time limit For 20 instances 109 reduced number search nodes These 20 instances consist magic sequences unsatisﬁable EFPA instances d 3 car sequencing model A There number car sequencing model AB instances BaselineCellSum reached ﬁxed point faster root node However instances faster search In conclusion adding sum constraint lowrisk helpful good default choice place BaselineCell Next BaselineCellFlow compared BaselineCellSum Table 5 shows BaselineCellFlow robust solving extra instances time limit car sequencing 12 models A AB BaselineCellFlow explores fewer nodes 21 111 benchmarks The instances solved BaselineCellFlow appear upper right corner Fig 16 BaselineCellFlow ineﬃcient shown Fig 16 worst case 48 times slower BaselineCellSum easy car sequencing instances The bulk slowdown root node surprisingly solver takes 45 s reach ﬁxed point car sequencing benchmarks In contrast BaselineCellSum takes 131 s root node For ﬁrst propagation EGCC dynamic partitioning effect cardinality variables pruned For car sequencing costly EFPA magic sequence If root node excluded worst case BaselineCellFlow takes 573 times longer BaselineCellSum 017 yaxis Fig 16 P Nightingale Artiﬁcial Intelligence 175 2011 586614 609 Fig 15 Time comparison BaselineCellSum BaselineCell The xaxis time taken BaselineCell yaxis proportion total times BaselineCell divided BaselineCellSum The timeout 1800 s Table 5 For cardinality algorithm number instances solved number instances reduced node count vs weaker algorithms Instances solved 194 Saved nodes vs Simple Saved nodes vs Sum BaselineCell BaselineCellSum BaselineCellFlow 108 109 111 20 33 23 Both Sum Flow hugely eﬃcient BaselineCell magic sequence problem In cases mainly explore fewer branches Taking magic sequence 100 example BaselineCell solves 385 branches 675192 executions EGCC propagator average 1754 calls branch This extremely pathological behaviour instance constraint caused cardinality variables target variables BaselineCellSum reduces pathological behaviour solving 242 branches 41428 calls propaga tor average 171 calls branch The speedup 47 times greater 159 times reduction number branches greater 16 times reduction number calls Therefore adding sum constraint reduces average time taken EGCC reducing number calls In conclusion BaselineCellFlow risky frequently slowing solver substantially appear good default choice However able solve instances halfhour time limit 59 Experiment seven comparing EGCC AllDifferent Given eﬃcient implementation EGCC worthwhile implementing GAC AllDifferent The BaselineCell propagator adapted removing cardinality variables 0 1 cardinality values The adapted Baseline Cell compared SCCAssignOpt variant AllDifferent described Gent et al 6 benchmarks paper The difference statistically signiﬁcant AllDifferent 131 times faster average 510 Evaluating optimizations combined In previous sections I individually evaluated eﬃciency measures pruning target variables EGCC In section I consider effect When simple cardinality algorithm eﬃcient variant BaselineCell BaselineCell 515 times faster Simple average maximum speedup 237 times However Simple include priority queue optimization ubiquitous external propagator Fig 17 compares BaselineCell PriorityQ The mean speed 411 times maximum 209 BaselineCell substantial improvement PriorityQ underlines importance implementing EGCC Fig 18 plot nodes explored second BaselineCell This gives idea speed propagator different classes instances The EFPA instances fast exceeding 20000 nodes second cases 610 P Nightingale Artiﬁcial Intelligence 175 2011 586614 Fig 16 Time comparison BaselineCellFlow BaselineCellSum The xaxis time taken BaselineCellSum yaxis proportion total times Sum divided Flow The timeout 1800 s Fig 17 Speedup BaselineCell compared PriorityQ remarkable maintaining GACOnX In case constraints short For example instance cid24 4 4 9cid3 longest EGCC 16 target variables Magic sequence far slowest class single EGCC constraint arity length sequence This class extremely pathological behaviour BaselineCell making large number calls propagator reach ﬁxed point branch instance 100 average 1754 calls branch This caused target cardinality variables constraint triggers times reaching ﬁxed point Finally I compare best EGCC variants BaselineCellSum decomposition EGCC constraint set occurrence constraints The decomposition follows For constraint egcc X V C value V corresponding cardinality variable ca C occurrence constraint occurrence X ca created stating ca number occurrences X The decomposition referred Occurrence Fig 19 compares BaselineCellSum Occurrence Many instances solved BaselineCellSum Occurrence righthand plot The speedup orders magnitude extreme point magic sequence 20 Occurrence times BaselineCellSum takes 001 s BaselineCellSum P Nightingale Artiﬁcial Intelligence 175 2011 586614 611 Fig 18 Plot BaselineCell branches second The xaxis BaselineCell runtime yaxis number branches searched second Fig 19 Time comparison BaselineCellSum Occurrence The xaxis time taken Occurrence yaxis proportion total times Occurrence divided Sum The timeout 1800 s appears faster problem classes EFPA Occurrence faster 15 instances class EFPA solves 21 total BaselineCellSum solves 109 The proportion run times ranges 06 180000 For 1415 cases Occurrence wins number branches 10 BaselineCellSum EGCC propagation ineffective However size search tree EGCC slows solver 166 times 6 Experimental conclusions In section I summarize important outcomes experiments 612 P Nightingale Artiﬁcial Intelligence 175 2011 586614 61 The basic algorithm pruning target variables First published algorithms enforcing GACOnX Régins algorithm Quimpers algorithm Quimpers algorithm tighter worstcase bound attractive choice However I Régins algorithm eﬃcient substantial margin 162 times faster average The second stage Régins algorithm Tarjans algorithm appears expensive ﬁrst based solver proﬁling This counterintuitive observation inform optimizations explains Quimpers algorithm eﬃcient Régins Despite experimental ﬁndings possible Quimpers algorithm outperform Régins large straints However given size problems solved real life small asymptotic difference algorithms constants important asymptotic behaviour Also clear maximum ﬂow algorithm Régins algorithm Only experimented FordFulkerson breadthﬁrst search Depthﬁrst search Dinics algorithm possibilities ruled 62 Optimizations basic algorithm The results huge beneﬁt following optimizations priority queue running EGCC low priority incremental matching incremental graph maintenance dynamic partitioning The results optimizations substantial unlikely reversed different implementation choices study different instances optimizations remain effective combined It possible deﬁnitive order importance optimizations experiments cu mulative However likely priority queue far important dynamic partitioning particularly important showed beneﬁt largest hardest instances Using transpose graph compute maximum ﬂow measurably faster shown fewer CPU instructions proﬁling Some results depend context EGCC In particular internal dynamic triggers IDT beneﬁt benchmarks combined dynamic partitioning actually slow solver In benchmarks target domains small cases smaller equal number target variables IDT expected work best target domains large proportion important values small Therefore IDT considered EGCC constraint large domains ameliorate overheads case 63 Algorithms pruning cardinality variables The ﬁndings pruning cardinality variables straightforward Adding implied sum constraint cardinality variables low overhead frequently helpful reducing number branches time reach ﬁxpoint Using Quimpers ﬂowbased algorithm expensive slowing substantial number benchmarks I recommend default choice However powerful simple algorithm sum constraint solving extra instances halfhour time limit 64 Comparing Occurrence BaselineCellSum takes twice long Occurrence solve benchmarks typically orders magnitude faster This encouraging suggests BaselineCellSum default choice automated modelling assistant 65 Other levels consistency In paper I focused exclusively GACOnX allowed extensive study algorithms case However I compared GACOnX bounds range consistency offer conclusions relative merits different levels consistency This interesting avenue work 7 Conclusions I presented extensive survey propagation methods EGCC constraint studying pruning target variables cardinality variables surveying methods literature presenting methods previously reported I focused generalized arcconsistency target variables GACOnX evaluated basic algorithms literature ﬁve optimizations literature novel optimizations In case I reported implementation given empirical analysis behaviour While impossible experiment possible combination optimizations I took care compare optimization appropriate baseline method P Nightingale Artiﬁcial Intelligence 175 2011 586614 613 avoid straw men Particular attention paid evaluating combinations optimizations naturally usually feature papers propose optimizations The experiments presented comprise easily deepest experimental analysis GACOnX algorithms Based I able conclude optimizations key generally useful I like draw particular attention results dynamic partitioning novel generalization optimiza tion AllDifferent 6 With EGCC dynamic partitioning 156 times faster average maximum 56 times The largest gains seen diﬃcult instances solver timed The gain EGCC pronounced AllDifferent 6 albeit entirely different benchmarks different combination optimizations For best combination optimizations I mean improvement 4 times runtime careful unoptimized implementation Régins algorithm This conﬁrms optimizations essential practical implementation EGCC Regarding cardinality variables I able conﬁrm implied sum constraint Gecode valuable stronger ﬂowbased pruning algorithm given Quimper et al 18 valuable solves instances time limit method Finally fast variant EGCC typically orders magnitude better set occurrence constraints Even EGCC propagation effective slowed solver 166 times experiments Acknowledgements I owe debt people helpful discussions particular Ian Gent Ian Miguel Guido Tack I like thank Ian Gent Ian Miguel comments draft paper I thank Chris Jefferson helpful discussions pointing EGCC entailed Andrea Rendl use Tailor 7 generating benchmarks This work supported EPSRC grants EPE0303941 EPH0040921 References 1 Claude Berge Graphs Hypergraphs NorthHolland Publishing Company 1973 2 Thomas H Cormen Charles E Leiserson Ronald L Rivest Introduction Algorithms MIT Press 1990 3 Sophie Demassey Gilles Pesant LouisMartin Rousseau A costregular based hybrid column generation approach Constraints 11 2006 315333 4 Ian P Gent Chris Jefferson Ian Miguel Minion A fast scalable constraint solver Proceedings 17th European Conference Artiﬁcial Intelligence ECAI 2006 2006 pp 98102 5 Ian P Gent Chris Jefferson Ian Miguel Watched literals constraint propagation minion Proceedings 12th International Conference Principles Practice Constraint Programming CP 2006 2006 6 Ian P Gent Ian Miguel Peter Nightingale Generalised arc consistency alldifferent constraint An empirical survey Artiﬁcial Intelligence 172 18 2008 19732000 7 Ian P Gent Ian Miguel Andrea Rendl Tailoring solverindependent constraint models case study Essence Minion Proceedings SARA 2007 2007 pp 184199 8 Emmanuel Hebrard Mistral constraint satisfaction library Proceedings Third International CSP Solvers Competition CPAI08 2008 pp 31 40 9 Brahim Hnich Ian Miguel Ian P Gent Toby Walsh CSPLib problem library constraints httpcspliborg 10 JE Hopcroft RM Karp An n25 algorithm maximum matchings bipartite graphs SIAM Journal Computing 2 4 1973 225231 11 Sophie Huczynska Paul McKay Ian Miguel Peter Nightingale Modelling equidistant frequency permutation arrays application constraints mathematics Proceedings CP2009 2009 pp 5064 12 Irit Katriel Expectedcase analysis delayed ﬁltering J Christopher Beck Barbara M Smith Eds CPAIOR Lecture Notes Computer Science vol 3990 Springer 2006 pp 119125 13 Irit Katriel Sven Thiel Complete bound consistency global cardinality constraint Constraints 10 3 2005 191217 14 Francoise Laburthe Choco constraint programming kernel solving combinatorial optimization problems httpchocosourceforgenet 15 Mikael Z Lagerkvist Christian Schulte Advisors incremental propagation Proceedings 13th Principles Practice Constraint Program ming CP 2007 2007 pp 409422 16 Peter Nightingale Are adjacency lists worthwhile alldifferent Technical Report CIRCA preprint 200920 University St Andrews 2009 17 ClaudeGuy Quimper Eﬃcient propagators global constraints PhD thesis University Waterloo 2006 18 ClaudeGuy Quimper Alejandro LópezOrtiz Peter van Beek Alexander Golynski Improved algorithms global cardinality constraint Pro ceedings 10th Principles Practice Constraint Programming CP 2004 2004 pp 542556 19 ClaudeGuy Quimper Peter van Beek Alejandro LópezOrtiz Alexander Golynski Sayyed Bashir Sadjad An eﬃcient bounds consistency algorithm global cardinality constraint Proceedings 9th Principles Practice Constraint Programming CP 2003 2003 pp 600614 20 ClaudeGuy Quimper Toby Walsh The different global cardinality constraints set multiset tuple variables Recent Advances Constraints Lecture Notes Artiﬁcial Intelligence vol 3419 2006 21 ClaudeGuy Quimper Toby Walsh Global grammar constraints Proceedings CP2006 2006 pp 751755 22 R Development Core Team R A Language Environment Statistical Computing ISBN 3900051070 R Foundation Statistical Computing Vienna Austria 2008 23 JeanCharles Régin A ﬁltering algorithm constraints difference CSPs Proceedings 12th National Conference Artiﬁcial Intelligence AAAI 94 1994 pp 362367 24 JeanCharles Régin Generalized arc consistency global cardinality constraint Proceedings 13th National Conference Artiﬁcial Intelli gence AAAI 96 1996 pp 209215 25 JeanCharles Régin JeanFrançois Puget A ﬁltering algorithm global sequencing constraints Proceedings 3rd Constraint Programming CP 97 1997 pp 3246 26 Marko Samer Stefan Szeider Tractable cases extended global cardinality constraint Proceedings Fourteenth Computing The Aus tralasian Theory Symposium CATS 2008 2008 pp 6774 614 P Nightingale Artiﬁcial Intelligence 175 2011 586614 27 Christian Schulte Peter J Stuckey Eﬃcient constraint propagation engines ACM Transactions Programming Languages Systems TOPLAS 31 1 2008 28 Christian Schulte Guido Tack Weakly monotonic propagators Principles Practice Constraint Programming CP 2009 2009 pp 723730 29 João C Setubal Sequential parallel experimental results bipartite matching algorithms Technical Report IC9609 Institute Computing University Campinas Brazil 1996 30 Helmut Simonis A hybrid constraint model routing wavelength assignment problem Proceedings CP2009 2009 pp 104118 31 Robert Endre Tarjan Depthﬁrst search linear graph algorithms SIAM Journal Computing 1 2 1972 146160 32 Robert Endre Tarjan Data Structures Network Algorithms SIAM 1983 33 WillemJan van Hoeve Gilles Pesant LouisMartin Rousseau Ashish Sabharwal Revisiting sequence constraint Proceedings 12th Princi ples Practice Constraint Programming CP 2006 2006 pp 620634 34 Mark Wallace Practical applications constraint programming Constraints 1 12 1996 139168 35 Josef Weidendorfer Markus Kowarschik Carsten Trinitis A tool suite simulation based analysis memory access behavior Proceedings 4th International Conference Computational Science ICCS 2004 2004