Artiﬁcial Intelligence 174 2010 10931141 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Logicbased ontology comparison module extraction application DLLite Roman Kontchakov Frank Wolter b Michael Zakharyaschev Department Computer Science Information Systems Birkbeck College London UK b Department Computer Science University Liverpool UK r t c l e n f o b s t r c t Article history Received 31 July 2009 Received revised form 30 April 2010 Accepted 17 June 2010 Available online 23 June 2010 Keywords Description logic Ontology Module extraction Entailment Computational complexity Uniform interpolation Forgetting We develop formal framework comparing different versions ontologies apply ontologies formulated terms DLLite family lightweight description logics designed dataintensive applications The main feature approach account vocabulary signature respect wants compare ontologies Five variants difference inseparability relations ontologies introduced respective applications ontology development maintenance discussed These variants obtained generalising notion conservative extension mathematical logic distinguishing differences observed concept inclusions answers queries ABoxes taking account additional context ontologies considering modeltheoretic language independent notion difference We compare variants study metaproperties determine computational complexity corresponding reasoning tasks present decision algorithms Moreover checking inseparability automated means encoding QBF satisﬁability offtheshelf general purpose QBF solvers Inseparability relations ontologies develop formal framework minimal module extraction We demonstrate different types minimal modules induced inseparability relations automatically extracted realworld mediumsize DLLite ontologies composing known tractable syntactic localitybased module extraction algorithm nontractable extraction algorithms multiengine QBF solver aqme Finally explore relationship uniform interpolation forgetting inseparability 2010 Elsevier BV All rights reserved 1 Introduction In science ontologies provide common vocabulary logic parlance signature domain description certain relationships terms built vocabulary Ontology languages based description logics represent ontologies TBoxes terminological boxes containing inclusions complex concepts vocabulary 2 An increasingly important application ontologies management large amounts data ontologies provide ﬂexible eﬃcient access repositories consisting data sets instances concepts relations In description logics repositories typically modelled ABoxes assertion boxes 2 Corresponding author Email addresses romandcsbbkacuk R Kontchakov frankcsclivacuk F Wolter michaeldcsbbkacuk M Zakharyaschev 00043702 matter 2010 Elsevier BV All rights reserved doi101016jartint201006003 1094 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Developing maintaining ontologies purposes diﬃcult task When description logics including description logic based dialects Web Ontology Language OWL1 ontology designer supported eﬃcient reasoning tools classiﬁcation instance checking variety reasoning tasks However support generally recognised insuﬃcient ontologies developed monolithic entities means importing merging combining reﬁning extending existing ontologies In cases reasoning support analysing impact respective operation ontology extremely useful Typical examples unorthodox reasoning services include following Comparing versions ontologies The standard syntactic diff utility indispensable tool comparing different versions text ﬁles helpful similar versioning tool ontologies However purely syntactic operation computing difference ontologies little value 3 concern syntactic form ontologies differing logical consequences Moreover instead comparing arbitrary logical consequences useful informative compare logical consequences common vocabulary Σ versions consequences certain subject matter corresponding subvocabulary Σ Thus reasoning service need case able compare logical consequences different versions ontologies vocabulary Σ Ontology reﬁnement When reﬁning ontology adding new axioms usually wants preserve relationships terms certain Σ vocabulary The reasoning service required case check reﬁned ontology precisely logical consequences Σ original Ontology reuse When importing ontology wants use vocabulary Σ originally deﬁned However relation ships terms Σ change interaction axioms importing ontology So need reasoning service capable checking new logical consequences Σ derivable service termed safety checking 4 In cases interested comparing logical consequences vocabulary Σ drawn different ontologies This gives rise main notions investigate paper Σ difference Σ entailment Σ inseparability Roughly Σ difference ontologies set formulas Σ derivable ontology ontology Σ entails Σ formulas derivable derivable ontologies Σ inseparable Σ entail In discussion far speciﬁed language logical consequences Σ drawn This language depends application For example mainly interested terminological reasoning differences visible applications use relationships concepts appropriate language set concept inclusions The Σ difference consists concept inclusions Σ derivable ontology And ontology Σ entails ontology concept inclusion Σ derivable derivable If mainly interested ontologies query instance data appropriate consider language consequences Σ reﬂects way answers queries signature Σ Σ queries instance data Σ In case ontologies Σ inseparable answers Σ query chosen language instance data Σ Even language insuﬃcient applications different versions ontologies imported context ontology case ontologies deemed Σ inseparable importing ontology Σ resulting extensions answers Σ queries The ﬁrst aim paper precise formalisations ﬁve variants Σ difference Σ entailment Σ insepa N N horn These variants Σ difference Σ entailment bool DLLite rability ontologies given DLLite logics DLLite obtained distinguishing differences visible concept inclusions answers queries ABoxes taking additional context ontologies account considering modeltheoretic languageindependent notions Σ difference Σ entailment The DLLite family description logics 58 originally designed aim providing query access large amounts data highlevel conceptual ontological interface Thus DLLite logics result compromises necessity retaining data complexity query answering close possible complexity standard database query evaluation ii desire having expressive means representing constraints N bool 10 data modelling formalisms ER model UML class diagrams 9 For example logic DLLite containing DLLite logics express isa hierarchies concepts disjointness covering constraints N bool AC0 concepts domain range cardinality constraints binary relations Instance checking DLLite data complexity complexity database query evaluation answering conjunctive queries N horn express covering constraints boasts AC0 query answering coNPcomplete On hand DLLite unique assumption 11 To simplify presentation paper consider DLLite logics role inclusions focusing mainly impact Boolean constructs concept inclusions number restrictions 1 httpwwww3org2007OWL R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1095 We note DLLite family forms basis OWL 2 QL proﬁles Web Ontology Language OWL 2 For Σ entailment Σ inseparability applicable practice understand basic metaproperties develop corresponding decision algorithms The important metaproperties Σ entailment formalised inves tigated specify type modiﬁcations signature Σ Σ entailment preserved operations TBoxes type context ontologies preserve Σ entailment Thus second aim paper compare notions Σ difference Σ entailment study meta properties determine computational complexity deciding Σ entailment Σ inseparability DLLite tologies develop decision algorithms The notions Σ entailment Σ inseparability investigated paper employed provide formal foun dation module extraction forgetting Module extractionthe problem ﬁnding minimal subset given ontology provides description relationships terms given subvocabulary ontologyhas recently active research topic recent volume ontology modularisation 12 WoMO workshop series devoted problem 1314 The reasons manifold important ontology reuse It impossible desirable develop entirely new ontology new application better methodology reuse appropriate existing ontologies However typically relatively small vocabulary possibly large ontology required needs subset module ontology gives description subvocabulary The phrase gives description vocabulary vague It interpreted variety ways ranging structural approaches 1516 logicbased approaches 17118 It come surprise paper propose understand claim ontologies description vocabulary Σ ontologies Σ inseparable senses described Thus different variants Σ inseparability rise different modules module extraction problems use notion Σ inseparability develop framework investigating modules algorithms extraction Forgettingthe problem constructing given ontology vocabulary Γ new ontology results original forgetting Γ retaining information remaining symbols Γ introduced investigated AI 1921 uniform interpolation mathematical logic 2225 Forgetting ontology engineering variety reasons 2627 For example similarly module extraction extract given ontology ontology provides description certain vocabulary original However contrast module extraction new ontology formulated forgotten symbols Γ axioms new ontology necessarily come original In paper propose deﬁne ontology OΓ result forgetting vocabulary Γ given ontology O OΓ use symbols Γ O OΓ Γ inseparable vocabulary Γ consists remaining nonΓ symbols O So like case modules different variants Σ inseparability induce different variants forgetting Thus aim paper formal deﬁnitions modules module extraction forgetting Σ inseparability We develop generic module extraction algorithms extract minimal modules algorithms deciding Σ inseparability oracles We present ﬁrst results forgetting uniform interpolation Finally fourth aim ﬁnd logicbased approach detecting inseparability relations DLLite ontologies practice particular minimal module extraction With aim mind N bool ontologies containing 1250 conducted series experiments number realworld mediumsize DLLite axioms Instead implementing dedicated algorithms checking Σ entailment encoded semantic criteria Σ entailment developed paper means quantiﬁed Boolean formulas QBFs short employed standard offtheshelf general purpose QBF solvers governed selfadaptive multiengine QBF solver aqme 28 The paper extended version 29 containing results 30 structured following way We begin Section 2 introducing DLLite logics discussing properties need paper giving N bool ontology In Section 3 introduce motivate illustrate ﬁve different variants illustrative example DLLite Σ entailment derivatives Σ difference Σ inseparability We start discussing relationships variants In Section 4 formulate semantic criteria Σ entailment We introduce illustrate technical notions involved actual proofs Appendix A apart illustrative purposes In Section 5 investigate important robustness metaproperties Σ entailment mentioned In Section 6 determine computational complexity deciding Σ entailment relations DLLite ontologies present corresponding decision algorithms Again technical proofs Appendix A In Section 7 notion Σ inseparability employed deﬁne modules analyse relationships modules design module extraction algorithms Section 8 discuss notion forgetting In Section 9 experiments analyse results We draw conclusions discuss open problems directions research Section 10 2 DLLite One interesting promising recent applications description logics DLs short provide access large amounts data highlevel conceptual interface areas data integration 1096 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Fig 1 A UML class diagram ontologybased data access The reasoning services required context include traditional knowledge base satisﬁability instance checking answering complex databaselike queries taking account terminological axioms data stored knowledge base As data supposed large key property approach viable practice eﬃciency query evaluation ideal target traditional database query processing With aim mind DLLite family DLs designed 58 supporting QuOnto implemented 3132 The DLLite family forms basis OWL 2 QL proﬁles OWL 22 According oﬃcial W3C proﬁles document purpose OWL 2 QL language choice applications use large amounts data query answering important reasoning task A detailed analysis impact DL constructs computational behaviour DLLite logics conducted 11 resulted ﬁnegrained classiﬁcation extensive class DLLite related logics Two contradicting requirements determined shape DLLite logics answering conjunctive queries reducible standard query evaluation databases words belong complexity class AC0 respect data complexity ii logics able capture typical conceptual modelling formalisms UML class diagrams ER models possible Before deﬁning syntax semantics DLLite logics formally let consider UML class diagram depicted Fig 1 representing portion science department information For example according diagram research visiting staff disjoint project managers visiting academic staff project managed managers researcher works project way round A crucial observation information binary relations manages works provided UML class diagram concerns domains ranges domain manages subset project managers range set projects multiplicity project managed managers This observation motivates following description logic called DLLite N bool consists pairwise disjoint countably inﬁnite sets object names a1 a2 concept N bool deﬁned inductively follows names A1 A2 role names P 1 P 2 Complex roles R concepts C DLLite N bool 11 DLLitebool 10 The alphabet DLLite R P P B cid4 Ai cid2 q R C B C C1 cid5 C2 q positive integer given binary3 The concepts form B called basic Other standard concept structs R cid3 q R C1 cid7 C2 introduced abbreviations R cid2 1 R cid3 q R cid2 q 1 R C1 cid7 C2 C1 cid5 C2 Concepts form cid3 q R cid2 q R called number restrictions form R cid2 1 R existential concepts A concept inclusion DLLite denoted T ﬁnite set concept inclusions DLLite C1 cid8 C2 C2 cid8 C1 N N N bool form C1 cid8 C2 C1 C2 DLLite bool concepts A TBox DLLite bool N bool As usual write C1 C2 instead inclusions We use cid4C denote length concept C number symbols required write The length cid2 size cid4T TBox T deﬁned taking C1cid8C2T cid4C1 cid4C2 2 The OWL 2 proﬁles fragments OWL 2 designed standardised speciﬁc application requirements httpwwww3orgTRowl2proﬁles 3 In fact complexity results depend numbers given unary binary Remark 45 Example 1 The UML class diagram Fig 1 represented following DLLite N bool TBox R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1097 manages cid8 ProjectManager cid8 Project manages Project cid8 manages cid8 cid2 3 manages Visiting cid8 ProjectManager ProjectManager cid8 Academic cid7 Visiting worksOn cid8 Research cid8 Project worksOn Research cid8 worksOn Project cid8 worksOn Academic cid8 ProjectManager Research cid8 Staff Visiting cid8 Staff Research cid5 Visiting cid8 Academic cid8 Staff We consider sublanguage DLLite sions DLLite N horn restricted form B1 cid5 cid5 Bk cid8 B N horn DLLite N bool called Horn fragment DLLite N bool The concept inclu Horn cid3 B B basic concepts Note inclusions N horn ﬁnite set concept inclusions DLLite DLLite N horn A TBox N bool basic concepts N horn express global functionality role called DLLite local functionality functionality restricted basic concept B means concept inclusions cid2 2R cid8 cid2 2R cid5 B cid8 N horn In context fragment DLLite N horn concepts It worth noting DLLite k Bk cid8 cid4 cid8 B legal DLLite N bool DLLite Let L languages DLLite N horn An ABox L denoted A ﬁnite set assertions form Cai Rai j ai j ai cid11 j C Lconcept R role ai j object names An L knowledge base LKB short pair K T A TBox T ABox A L By signature understand ﬁnite set Σ concept role names As TBoxes DLLite N bool contain object names include signatures Given concept role TBox ABox expression E N bool denote sigE signature E set concept role names occur E It alphabet DLLite noted cid4 regarded logical symbols sig sigcid4 A concept role TBox ABox E called Σ concept role TBox ABox respectively sigE Σ Thus P Σ role P Σ Given signature Σ deﬁne Σ interpretation I structure form cid5I I cid5I interpretation function assigns concept Ai Σ subset A nonempty set cid5I domain interpretation I domain role P Σ binary relation P domain object ai If I interprets concept role names Σ understood usually drop modiﬁer Σ element I simply interpretation For interpretation I signature Σ denote I cid4Σ Σ reduct I Σ Σ interpretation domain cid5I role Icid2Σ names P Σ concept names Ai Σ P object names ai cid5I cid5I A cid5I Icid2Σ Icid2Σ A P I I I I I I Complex roles concepts interpreted I follows y x cid5I cid5I x y P cid7 I cid6 cid8 cid8 cid6 y cid5I cid8 cid8 x y R cid7 I cid7 cid2 q cid4 cid6 cid5I P cid4I cid5I I cid2q RI CI cid5I C I C1 cid5 C2I C 1 cid6 x cid5I I C I 2 inverse role domain set q Rsuccessors C C1 C2 typographical reasons denote cardinality X cid6 X instead usual X The satisfaction relation cid15 deﬁned taking I cid15 C1 cid8 C2 I cid15 Cai I cid15 Rai j iff C iff cid4 iff I 1 I C I 2 I C cid5 I I j R I cid15 ai j I cid15 ai cid11 j iff iff I I cid11 I j I j I C C1 C2 Lconcepts R role ai j object names An LKB K T A said satisﬁable consistent interpretation I satisfying members T A In case write I cid15 K I cid15 T I cid15 A I model K T A A concept inclusion C1 cid8 C2 follows logical consequence T T cid15 C1 cid8 C2 symbols model T satisﬁes C1 cid8 C2 A concept C T satisﬁable exists model I T C I cid11 1098 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 An essentially positive existential query qx1 xn L simply query L understood ﬁrstorder formula y1 ymϕx1 xn y1 ym ϕ constructed atoms form Ct Rt1 t2 C Lconcept R role ti object variable list x1 xn y1 ym The free variables q called distinguished variables q bound ones nondistinguished variables q We write qx1 xn query distinguished variables x1 xn Given query qx x x1 xn ntuple object names write qa result replacing occurrence xi qx ith member Queries containing distinguished variables called ground Boolean Let I cid5I I interpretation An assignment cid5I y cid5I respect given assignment deﬁned inductively taking We use following notation I y Ia function associating variable y element Ia y The satisfaction relation existential queries I cid15a Ct I cid15a Rt1 t2 I cid15a ϕ1 ϕ2 I cid15a ϕ1 ϕ2 I cid15a yϕ iff Ia C t cid4 Ia t 1 I cid5 Ia 2 t R I iff iff I cid15a ϕ1 I cid15a ϕ2 iff I cid15a ϕ1 I cid15a ϕ2 iff I cid15b ϕ assignment b cid5I differ y For ground query qa satisfaction relation depend assignment write I cid15 qa instead I cid15a qa For KB K T A tuple object names A certain answer qx respect K write K cid15 qa I cid15 qa I cid15 K A certain answer ground query qa respect K yes K cid15 qa The query answering problem L formulated follows given LKB K T A query qx L tuple object names A decide K cid15 qa N bool essentially positive existential queries contain complex atoms Ct like cid2 7 P Remark 2 The reader probably noticed class essentially positive existential queries L deal paper larger standard class positive existential queries built atoms form Ait P jt1 t2 Ai P j concept role names respectively In particular j cid5 Ai y The case DLLite reason consider complex queries discussed Section 51 Note query answering essentially positive existential queries L reduced query answering L positive existential queries given LKB K T A essentially positive existential query qx L replace occurrence complex atom Ct qx AC t fresh concept AC add T deﬁnition AC C clearly belongs L Denote resulting positive existential query q It readily seen tuple object names A K cid15 qa Kcid18 cid15 q cid18x resulting LKB Kcid18 cid18a Remark 3 unique assumption According deﬁnitions given adopt unique assumption UNA short formulated follows We interpretation I model I KB K T A UNA I cid15 K j distinct object names ai j occurring A Instead follow liberal approach taken OWL UNA dropped user provided means cid11 explicitly object names denote individual different Of course enforce UNA adding ABox A inequalities ai cid11 j pairs distinct object names ai j occurring A In fact shall Theorem 18 purposes matter approaches taken However complexity standard reasoning tasks like satisﬁability checking query answering DLLite logics depend UNA adopted We recall following complexity results 1011 DLLite logics UNA cid11 I With UNA satisﬁability problem knowledge bases NPcomplete DLLite respect combined complexity answering positive existential queries AC0 DLLite complete DLLite N bool KBs respect data complexity Without UNA satisﬁability NPcomplete respect combined complexity query answering coNP N complete respect data complexity DLLite horn limiting number restrictions global functionality constraints cid2 2R cid8 existential concepts R reduce complexity sat isﬁability query answering Horn fragment P functionality constraints removed complexity satisﬁability UNA case query answering Horn fragment drops LogSpace AC0 use allowed N bool DLLite N bool Pcomplete DLLite N horn KBs coNP N horn R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1099 3 What difference In section precise deﬁnitions notions difference entailment inseparability tologies respect signature discuss notions related N bool DLLite Intuitively ontology T1 inseparable ontology T2 respect signature Σ T1 T2 distinguished means consequences Σ To intuition precise specify language consequences drawn As consider ontologies formulated DLLite logics N horn obvious language consequences probably concept inclusions L Thus L DLLite TBoxes T1 T2 L Σ inseparable T1 T2 imply Σ concept inclusions L The cor responding nonsymmetric notion Σ entailment formulated follows T1 Σ entails T2 Σ concept inclusion L follows T2 follows T1 T1 T2 Σ inseparable Σ entail Finally Σ difference T1 T2 deﬁned set Σ concept inclusions L follow T2 T1 To indicate interested consequences ontologies form concept inclusions preﬁx notions difference entailment inseparability modiﬁer concept Here formal deﬁnition Deﬁnition 4 The Σ concept difference TBoxes T1 T2 L set cDiff C cid8 D L T1 cid11cid15 C cid8 D T2 cid15 C cid8 D L Σ T1 T2 Σ concept inclusions T1 Σ concept entails T2 L cDiff L Σ T1 T2 T1 T2 Σ concept inseparable L Σ concept entail L Σ concept inseparability T1 T2 means T1 replaced T2 application cerned Σ concept inclusions L elaborate claim An ontology developer wants compare versions T1 T2 ontology respect signature Σ check Σ concept inseparable L Σ T2 T1 analyse Σ differences case inspect cDiff versions L Σ T1 T2 cDiff Remark 5 The notion Σ concept entailment TBoxes generalisation notion conservative extension investigated 2433 expressive descriptions logics ALC ALCQI Namely TBox T2 conservative ex tension TBox T1 T1 T2 T1 Σ concept entails T2 Σ sigT1 The notion conservative extension originates mathematical logic relative consistency proofs arithmetic set theory 34 information In science conservative extensions applications modular software speciﬁcation veriﬁcation 3538 The ﬁrst papers suggesting use conservative extensions variants thereof modular ontology engineering 391724 In answer set programming modularity variations conservative extensions investigated 4043 Concept inclusions interesting type consequences TBoxes In context DLLite ontologies answers queries ABoxes probably greater importance concept inclusions The following example shows conceptbased notions difference entailment introduced appropriate applications involve query answering The claims examples explained informal way strict proofs easily given semantic criteria discussed Section 4 Example 6 Let Σ Lecturer Course cid6 T1 T2 Lecturer cid8 teaches teaches cid8 Course cid7 Intuitively nontautological consequence T2 Σ lecturer course N expressed means Σ concept inclusions Thus T1 T2 Σ concept inseparable DLLite bool N horn On hand T1 T2 Σ separable query ABoxes For instance let DLLite A Lecturera q y Course y Although sigA sigq Σ separate T1 T2 T1 A cid11cid15 q T2 A cid15 q Thus applications TBoxes query ABoxes T1 regarded indistinguishable T2 respect Σ ﬁnd Σ ABox Σ query presence T1 behaves differently T2 To account differences TBoxes detected means ABoxes queries propose following deﬁnition L Deﬁnition 7 The Σ query difference TBoxes T1 T2 L set qDiff Σ T1 T2 pairs form A qx A Σ ABox L qx Σ query L T1 A cid11cid15 qa T2 A cid15 qa tuple object names A T1 Σ query entails T2 L qDiff L Σ T1 T2 T1 T2 Σ query inseparable L Σ query entail L 1100 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 In deﬁnition Σ query difference consideration arbitrary Σ ABoxes L The reason ontology design phase data repositories ontology applied completely unknown subject frequent changes Thus assume ﬁxed ABox unrealistic checking Σ query differences ontologies approach regard ABoxes black boxes This notion Σ query difference entailment discussed 25 investigated description logic EL 44 As shall later cf Theorem 24 DLLite N horn implies Σ concept en N bool However implication hold Σ query entailment shown following example N horn TBoxes Σ concept entailment DLLite tailment DLLite Example 8 Let Σ Lecturer T1 T2 cid6 Lecturer cid8 teaches Lecturer cid5 teaches cid7 cid8 Then T1 Σ query entail T2 DLLite T1 A cid11cid15 q T2 A cid15 q On hand allow negation DLLite T1 Σ query entails T2 DLLite N bool Indeed A Lecturera q y Lecturer y N horn queries N horn Similarly Σ concept inseparability Σ query inseparability TBoxes T1 T2 means T1 replaced T2 applications answers Σ queries Σ ABoxes However informal explana tion taken caution To recall reasons studying inseparability difference ontology reuse instead constructing ontologies scratch preferable import parts existing ontologies In words ontologies designed union Tself Timp Tself ontology developed speciﬁcally given application Timp imported ontology A problem arises choice different versions Timp preferable import small subset Timp later Section 7 called module contains relevant information new application In cases like able detect makes difference import version T cid18 imp version T cid18cid18 imp Timp likewise makes difference Timp imported subset M In words like know Tself T cid18 Tself M Tself Timp Σ inseparable imp Tself T cid18cid18 imp Σ inseparable Σ signature required application Now instead checking Σ inseparability taking union Tself useful able check Σ inseparability independently Tself importing ontologies interested Consider example situation Tself evolving subject frequent changes Thus desirable notion Σ inseparability following replacement property replace T1 T2 Σ inseparable L T T1 T T2 Σ inseparable L Σ TBoxes T L If notion Σ inseparability property Σ inseparability T1 T2 ensures T1 replaced T2 context Σ TBox T given language L For discussions replacement property refer reader Section 7 Σ inseparability module extraction Section 54 consider context TBoxes given expressive DLs SHIQ Unfortunately notions inseparability introduced far enjoy replacement property Example 9 Let T1 T2 TBox Example 8 saying lecturer teaches lecturer N taught As consider Σ Lecturer Then T1 T2 Σ concept inseparable DLLite bool N horn But T cid4 cid8 Lecturer T1 T cid11cid15 cid4 cid8 T2 T cid15 cid4 cid8 TBox consistent DLLite Thus difference T1 T2 visible consider Σ concept inclusions TBoxes different apparent presence extra Σ TBox T To context ontologies account introduce stronger variants Σ inseparability deﬁnitions enjoy replacement property Deﬁnition 10 The strong Σ concept difference L TBoxes T1 T2 set scDiff T Σ TBox L C cid8 D belongs cDiff scDiff L Σ T1 T2 pairs T C cid8 D L Σ T T1 T T2 T1 strongly Σ concept entails T2 L L Σ T1 T2 T1 T2 strongly Σ concept inseparable L strongly Σ concept entail L R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1101 The strong Σ query difference L T1 T2 set sqDiff L Σ T1 T2 triples T A qx T L L Σ T1 T2 T1 T2 Σ T T1 T T2 T1 strongly Σ query entails T2 L sqDiff Σ TBox L A qx qDiff strongly Σ query inseparable L strongly Σ query entail L Sometimes convenient use following rephrasing deﬁnition strong Σ concept entailment analogously strong Σ query entailment T1 strongly Σ concept entails T2 L T T1 Σ concept entails T T2 Σ TBoxes T L Thus versions ontologies strongly Σ inseparable shared signature Σ safely replaced ontology T uses symbols Σ replacement differences sets derivable Σ concept inclusions answers Σ queries detected In context deﬁning modules ontologies taking account changes ontologies context ontologies strongly advocated 4 inspired deﬁnition Section 7 The notions difference inseparability introduced far languagedependent set syntactic objects collected difference ontologies depends description logic consideration We N seen Example 8 Σ query entailment DLLite horn N DLLite horn imply strong Σ concept entailment DLLite N horn TBoxes Here example showing strong Σ concept entailment DLLite N bool coincide Σ query entailment DLLite N bool Example 11 Consider DLLite N horn TBoxes T1 Male cid5 Female cid8 cid4 cid8 father cid4 cid8 mother father T2 cid4 cid8 id Male cid5 id cid8 Female cid5 id cid8 cid8 Male mother cid8 Female let Σ Male Female It follows T2 range role id disjoint Male Female Now let T cid4 cid8 Male cid7 Female Then T T1 consistent T T2 inconsistent Thus T T2 cid15 cid4 cid8 N bool However T1 strongly T T1 cid11cid15 cid4 cid8 T1 strongly Σ concept entail T2 DLLite N Σ concept entails T2 DLLite horn express Male Female cover domain N horn Intuitively reason DLLite Languagedependence notions difference ontologies unproblematic justiﬁed languages involved application known advance For example application involves conceptual reasoning DLLite N horn N DLLite bool query answering ABoxes languages corresponding notions introduced entirely appropriate Moreover weaker descriptions logics query languages ones considered sound work notions difference introduced far relevant differences missed In cases interested importing DLLite ontologies ontologies formulated expressive languages SHIQ 2 ﬁrstorder logic Or interested querying DLLite ontologies expressive languages essentially positive existential queries In cases notions difference incomplete expressive languages potentially detect differences observable DLLite The following example illustrates point Example 12 Let T1 T2 cid4 cid8 cid2 2P Σ The difference T1 T2 respect signature Σ T1 model domain cardinality T2 model Using observa tion T1 Σ entails T2 notions Σ entailment introduced notions insensitive cardinalities However ﬁrstorder Σ sentence ϕ x yx cid11 y distinguishes T1 T2 T1 cid11cid15 ϕ T2 cid15 ϕ Instead deﬁning investigating Σ entailment languages SHIQ ﬁrstorder logic paper consider languageindependent purely modeltheoretic notion difference covers differences detectable standard description logics ﬁrstorder secondorder logic Apart Section 5 N strong Σ query entailment DLLite bool actually extremely robust terms language extensions family description logics Theorem 40 Deﬁnition 13 The Σ model difference TBoxes T1 T2 class mDiffΣ T1 T2 Σ interpretations I exists model I1 T1 I1 cid4Σ I model I2 T2 I2 cid4Σ I We T1 Σ model entails T2 mDiffΣ T1 T2 T1 T2 Σ model inseparable Σ model entail Observe T1 T2 Σ Example 12 mDiffΣ T1 T2 consists isomorphic copies Σ interpretation domain exactly element We example illustrating languageindependent notion Σ difference 1102 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Example 14 Let T1 TBox DLLite N horn stating auxiliary role R concept B nonempty T1 cid4 cid8 R R cid8 B Consider TBox T2 DLLite N horn stating P injective function A B T2 A P P cid8 B cid2 2 P cid8 cid2 2 P cid8 Let Σ A B Then mDiffΣ T1 T2 set Σ interpretations I B I larger cardinality B injection A As set interpretations nonempty T1 Σ model entail T2 One T1 Σ entails T2 languagedependent notions Σ entailment introduced Example 22 nonempty cardinality A B I I I I The following proposition provides basic implications variants Σ entailment introduced systematic investigation conducted section Proposition 15 Let L DLLite N bool DLLite N horn T1 T2 TBoxes L Σ signature If T1 Σ query entails T2 L T1 Σ concept entails T2 L In words cDiff ii If T1 Σ model entails T2 T1 strongly Σ query entails T2 L In words sqDiff L L Σ T1 T2 cid11 Σ T1 T2 cid11 qDiff L Σ T1 T2 cid11 mDiffΣ T1 T2 cid11 Proof To difference T1 T2 detectable means concept inclusions detected means queries suppose T1 cid11cid15 C1 cid8 C2 T2 cid15 C1 cid8 C2 Σ concept inclusion C1 cid8 C2 L N Consider ABox A C1a query q C2a Then T2 A cid15 q T1 A cid11cid15 q Note DLLite horn ABox query deﬁned correctly C1 B1 cid5 cid5 Bk C2 B B B1 Bk basic concepts A B1a Bka q Ba ii To difference T1 T2 detectable triples T A qx detected means Σ interpretations suppose T T1 A cid11cid15 qa T T2 A cid15 qa T A q contain symbols Σ Take model I T T1 A I cid11cid15 qa We Icid4Σ mDiffΣ T1 T2 Indeed model Icid18 T2 Icid4Σ Icid18cid4Σ But T A q use symbols Σ Icid18 cid15 T T2 A Icid18 cid11cid15 qa contrary T T2 A cid15 qa cid2 We conclude section important observations First consider Σ entailment DLLite TBoxes containing role namesin essence Σ entailment propositional theoriesand case variants Σ entailment introduced coincide And prove notions Σ entailment depend unique assumption UNA promised Section 2 Example 16 Σ entailment propositional logic If TBox T contain role names identify concept names propositional variables regard T ﬁnite set T propositional Boolean formulas obvious correspondence concept construct cid5 Boolean conjunction concept inclusion cid8 Boolean implication Moreover T DLLite ﬁnite set propositional Horn formulas This brings Σ entailment propositional theories horn TBox T N A propositional theory ﬁnite set propositional formulas propositional signature set propositional variables Let Σ signature Say propositional theory Φ1 Σ entails propositional theory Φ2 propositional formula ϕ Σ Φ1 cid15 ϕ Φ2 cid15 ϕ This notion characterised purely model theoretic terms Φ1 Σ entails Φ2 propositional model I assigning truthvalues propositional variables Φ1 exists propositional model Φ2 coincides I variables Σ Indeed implication trivial To converse suppose Φ1 Σ entails Φ2 model I Φ1 model Φ2 coincides I variables Σ Consider formula I cid18 cid9 cid10 cid10 p cid11 p χIΣ pΣ Icid15p pΣ Icid11cid15p By assumption Φ2 cid15 χIΣ But Φ1 cid15 χIΣ contrary I cid15 Φ1 I cid11cid15 χIΣ Thus contrast notions Σ entailment DLLite TBoxes propositional case canonical languagedependent notion Σ entailment coincides modeltheoretic notion Σ entailment It diﬃcult prove propositional Horn theory Φ1 Σ entails propositional Horn theory Φ2 propositional Horn formula ϕ Σ Φ2 cid15 ϕ implies Φ1 cid15 ϕ cf Theorem 24 somewhat general R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1103 result In words Horn theories difference considers Horn arbitrary formulas languagedependent notion Σ entailment Theorem 17 Let L DLLite Then following conditions equivalent N bool DLLite N horn Let T1 T2 TBoxes L occurrences role names Σ signature T1 strongly Σ concept entails T2 L T1 strongly Σ query entails T2 L T1 Σ model entails T2 1 Σ entails T T 2 propositional theories N N Proof Assume ﬁrst L DLLite bool Since T1 T2 contain role bool T1 T2 DLLite names assume loss generality Theorem 33 Σ contains role names It clear Example 16 T1 Σ concept entails T2 DLLite 2 Thus view Proposition 15 suﬃces T1 Σ entails T2 T1 Σ model entails T2 Suppose Then model I T1 model Icid18 T2 I cid4Σ Icid18 cid4Σ In fact T1 T2 contain role names ﬁnd I domain consists single point x Then similarly argument Example 16 Σ concept inclusion cid4 cid8 CIΣ bool T 1 Σ entails T N cid9 cid11 CIΣ cid3Ai Σ x A I Ai cid5 Ai cid3Ai Σ x A I By assumption T2 cid15 cid4 cid8 CIΣ T1 cid15 cid4 cid8 CIΣ contrary I cid15 T1 I cid11cid15 cid4 cid8 CIΣ Now assume T1 T2 DLLite suﬃces T1 Σ concept entails T2 DLLite DLLite required cid2 horn Horn formula ϕ Σ T N 2 N horn As proved result DLLite 1 Σ entails T horn T cid15 ϕ Thus Example 16 T cid15 ϕ implies T 1 N bool view Proposition 15 2 But T1 Σ concept entails T2 2 1 Σ entails T N As mentioned Section 2 main paradigms interpreting object names One typically adopted DL community treats different object names given ABox denoting different objects interpretations known unique assumption UNA According paradigm standard OWL community ﬁrstorder logic assumption object names interpreted general users provided ABox constructs cid11 order impose constraints object interpretations want For example simulate UNA add ABoxes interested inequalities ai cid11 j pairs distinct object names ai j occurring ABoxes Fortunately context present investigation matter paradigms adopted Theorem 18 Let L DLLite introduced T1 Σ entails T2 L UNA T1 Σ entails T2 L UNA cid11 Let T1 T2 TBoxes L Σ signature Then variant Σ entailment N bool DLLite N horn Proof The claim clear Σ concept strong Σ concept Σ model entailments ABoxes involved deﬁnitions Consider Σ query entailment As observed case UNA covers UNA So suppose T1 Σ query entail T2 UNA T1 Σ query entail T2 UNA Let A Σ ABox L qx Σ query L T2 A cid15 qa T1 A cid11cid15 qa tuple A Let I model T1 A UNA assignment axi ai I cid11cid15a qx Deﬁne I equivalence relation set object names taking ai j j Take member aξ cid18x ABox query result A qx replacing equivalence class ξ deﬁne Acid18 cid18 ai aξ equivalence class ξ ai Then clearly I model T1 Acid18 UNA I cid11cid15 q cid18 tuple obtained replacing ai aξ equivalence class ξ ai On hand immediately obtain T2 A cid15 qa q cid18 holds model T2 Acid18 UNA cid2 q cid18a cid18a I For technical reasons convenient adopt UNA assume ABox A contains inequalities ai cid11 j distinct ai j occurring A 4 Semantic criteria Σ entailment In section semantic criteria languagedependent notions Σ entailment DLLite N bool N horn These criteria classify notions Σ entailment investigate robustness properties DLLite 1104 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Section 5 provide tight complexity bounds deciding Σ entailment Section 6 design practical decision procedures Section 9 Detailed proofs results given Appendix A2 41 Semantic criteria DLLite N bool According Proposition 15 Σ model entailment implies languagedependent variants Σ entailment consid ered paper Thus develop modeltheoretic characterisations languagedependent notions Σ entailment weaken following condition characterising Σ model entailment TBoxes T1 T2 model model T1 transformed model T2 changing interpretation nonΣ symbols We means additional modiﬁcations models T1 transforming models T2 Our criteria somewhat syntactic ﬂavour sense formulated terms typessyntactic abstractions domain elementsrealised models The advantage characterisations directly designing N decision algorithms despite fact underlying models inﬁnite DLLite horn ﬁnite model property 45 Needless correctness typebased characterisations presented requires model constructions Appendix A N bool DLLite Let Σ signature Q set positive natural numbers containing 1 A basic Σ Q concept B concept form cid4 Ai cid2 q R Ai Σ Σ role R q Q Σ Q literal mean basic Σ Q concept negation A Σ Q type set t Σ Q literals containing cid4 following conditions hold basic Σ Q concept B B t B t numbers q q Q cid2 q cid18 cid18 R t cid2 q R t cid18 Q cid2 q R t cid2 q cid18 R t Clearly interpretation I It follows numbers q q point x cid5I cid8 cid8 x C tI x set cid7 I C Σ Q literal cid6 C 1 Σ Q type Conversely Σ Q type t t interpretation I point x x C C t In case t realised x I Thus Σ Q types regarded abstractions domain elements To avoid syntactic clutter examples include cid4 Σ Q types I Deﬁnition 19 Given TBox T Σ Q type T realisable realised model T A set Ξ Σ Q types said T realisable model T realising types Ξ We Ξ precisely T realisable model I T realising types Ξ Σ Q type realised I Ξ Now returning characterisation model Σ model entailment I cid4Σ Icid18 cid4Σ Icid18 realise Σ Q types obtained I modifying interpretation nonΣ symbolsthen I Icid18 set Q numerical parameters Thus T1 Σ model entails T2 T1realisable Σ Q type T2realisable precisely T1realisable set Σ Q types precisely T2realisable These conditions ﬂexible model types abstractions domain elements domain model ﬁxed anymore manipulate domain elements removing introducing new ones The following theorems state conditions provide semantic characterisations Σ entailments looking For TBox T let Q T denote set numerical parameters occurring T number 1 Theorem 20 The following conditions equivalent TBoxes T1 T2 DLLite N bool signature Σ ceb T1 Σ concept entails T2 DLLite r T1realisable Σ Q T1T2 type T2realisable N bool Note equivalence trivial considers ΣNtypes types arbitrary parameters instead Σ Q T1T2 types Thus message suﬃcient consider parameters Q T1T2 N The theorem characterises remaining languagedependent variants Σ entailment DLLite bool TBoxes Theorem 21 The following conditions equivalent TBoxes T1 T2 DLLite N bool signature Σ R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1105 sceb T1 strongly Σ concept entails T2 DLLite qeb T1 Σ query entails T2 DLLite sqeb T1 strongly Σ query entails T2 DLLite pr precisely T1realisable set Σ Q T1T2 types precisely T2realisable N bool N bool N bool Comparing criteria Σ concept entailment local sense refers single point model Σ query strong Σ conceptquery entailments global points model considered Example 22 To illustrate criteria reuse Examples 6 14 Consider ﬁrst TBoxes T1 T2 signature Σ Lecturer Course Example 6 There exactly Σ Q T1T2 types Lecturer Course Lecturer Course Lecturer Course Lecturer Course T1realisable To T1 Σ concept entails T2 remains check types T2realisable On hand singleton Lecturer Course precisely T1realisable precisely T2realisable Thus T1 Σ query entail T2 ii Consider TBoxes T1 T2 Example 14 states B nonempty injection A B Let Σ A B The Σ Q T1T2 types A B A B A B A B Ti realisable 1 2 Thus T1 Σ concept entails T2 To T1 Σ query entails T2 let Ξ precisely T1realisable set Σ Q T1T2 types Then exists t Ξ B t Take Σ interpretation I precisely realising Ξ set d cid5I t tI d countably inﬁnite t Ξ Then exists injection countably inﬁnite Thus I extended A countably inﬁnite A model T2 Ξ precisely T2realisable It observe models I T2 precisely realising Ξ A B A B inﬁnite A B proper subset cid5I I cid5I B B I I I I I 42 Semantic criteria DLLite N horn The language DLLite N horn contain negation operates basic concepts Like previous section use modiﬁer Σ Q indicate syntactic object built concept role names Σ numerical N horn concept inclusion form B 1 cid5 cid5 Bk cid8 B parameters Q For example Σ Q concept inclusion DLLite B understood cid4 basic B1 Bk B basic Σ Q concepts As usual conjunction Σ Q concept Σ Q cid3 include negative literals taking Given Σ Q type t deﬁne positive t B t B basic concept t Say Σ Q type t1 positively contained Σ Q type t2 t positive Thus frequently deﬁne Σ Q type t giving positive t example deﬁnition Given TBox T DLLite N horn Σ Q type t Σ sigT Q T Q deﬁne T closure t consists basic sigT Q concepts B 2 Clearly Σ Q type uniquely determined Here ﬁrst sigT Q type denoted clT t clT t t 1 T cid15 Bkt Bk cid8 B cid3 N horn checked polynomial time follows clT t computed polynomial Since subsumption DLLite time size T The following lemma provides simple standard criterion T realisability types T TBox DLLite N horn Proposition 23 Let T TBox DLLite N horn Σ sigT A Σ Q type t T realisable t clT t cid4Σ t Here Σ cid18 Turning typebased criteria Σ entailment DLLite Q type t denote t cid4Σ restriction t Σ concepts t cid4Σ C t C Σ Q literal N horn ﬁrst observe Σ concept entailment new N criterion required coincides Σ concept entailment DLLite bool Thus generalise wellknown result propositional logic according propositional Horn theories entail Horn formulas theories consequences class propositional formulas 1106 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Theorem 24 The following conditions equivalent TBoxes T1 T2 DLLite N horn signature Σ ceh T1 Σ concept entails T2 DLLite ceb T1 Σ concept entails T2 DLLite N horn N bool Proof The implication ceb ceh obvious To converse suppose T1 Σ concept entail T2 N bool Without loss generality assume Σ sigT1 Σ sigT2 If case DLLite add A cid8 A P cid8 P T1 T2 A P Σ sigT1 sigT2 respectively By Theorem 20 exists T1realisable Σ Q T1T2 type t T2realisable Consider T1 T2closures clT1 t clT2 t t Since t T1realisable clT1 t cid4Σ t Proposition 23 On hand t T2realisable Proposition 23 implies t properly positively contained clT2 t cid4Σ Therefore B clT2 t cid4Σ clT1 t cid4Σ T1 cid11cid15 Bkt Bk cid8 B T2 cid15 Bkt Bk cid8 B cid3 cid3 Since deﬁnition sigBk Σ Bk t T1 Σ concept entail T2 DLLite N horn cid2 Examples 8 11 theorem hold stronger notions Σ entailment Moreover DLLite N horn DLLite N bool stronger notions equivalent Σ concept entailment The following deﬁnition characterise Σ entailments DLLite N horn Deﬁnition 25 A set Ξ Σ Q types said subprecisely T realisable model I T I realises types Ξ Σ Q type realised I positively contained type Ξ We Ξ meetprecisely T realisable model I T realising types Ξ Σ Q type t realised I Ξt cid11 t Ξt t Ξ t t cid12 t t Ξt The notion meetprecise T realisability stronger notion subprecise T realisability Indeed I model T realising types Ξ meeting conditions subprecise realisability t realised I Ξt cid11 t Thus t positively contained type Ξ cid18 Ξt t t cid18 Theorem 26 The following conditions equivalent TBoxes T1 T2 DLLite N horn signature Σ qeh T1 Σ query entails T2 DLLite spr precisely T1realisable set Σ Q T1T2 types subprecisely T2realisable N horn Theorem 27 The following conditions equivalent TBoxes T1 T2 DLLite N horn signature Σ sceh T1 strongly Σ concept entails T2 DLLite N sqeh T1 strongly Σ query entails T2 DLLite horn mpr precisely T1realisable set Σ Q T1T2 types meetprecisely T2realisable N horn Example 28 Consider TBoxes signature Example 8 The T1realisable Σ Q T1T2 types Lecturer N Lecturer T2realisable Hence T1 Σ concept entails T2 DLLite horn The singleton Lecturer precisely T1realisable precisely T2realisable Hence T1 Σ query entail T2 N N bool However Lecturer subprecisely T1realisable T1 Σ query entails T2 DLLite horn On DLLite N hand Lecturer meetprecisely T2realisable T1 strongly Σ concept entail T2 DLLite horn N bool DLLite Example 29 Consider TBoxes T1 T2 signature Σ Male Female Example 11 We T1 N strongly Σ concept entails T2 DLLite horn One readily exist exactly T1realisable Σ Q T1T2 types t1 Male Female t2 Male Female t3 Male Female Moreover exactly sets Σ Q T1T2 types precisely T1realisable Ξ1 t1 t2 Ξ2 t1 t2 t3 We Ξ1 Ξ2 meetprecisely T2realisable This seen taking terpretation I cid5I x y z Male I x Female I y I id cid6 cid7 x z y z z z I model T2 precisely realising Ξ2 Hence meetprecisely realises Ξ2 It remains meetprecisely realises Ξ1 The interesting type Ξ1 t3 realised I But t 1 t coincides intersection t 3 2 required R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1107 Table 1 Comparing notions Σ entailment DLLite N bool DLLite N horn Every T1realisable type T2realisable cid24 Thm 20 Σconcept cid24 Thm 24 Prop 15i Ex 9 22cid15 DLLite N bool DLLite N horn Σconcept Prop 15icid15 Every precisely T1realisable set types precisely T2realisable cid24 Thm 21 Σquery Ex 8 28 Σquery cid24 Thm 26 Thm 21 Ex 28cid15 strong Σconcept Ex 11 Thm 21 strong Σquery strong Σconcept cid24 Thm 27 Thm 27 strong Σquery Prop 15ii Ex 14cid15 Prop 15ii Ex 14cid15 Σmodel cid24 def Σmodel Every precisely T1realisable set types subprecisely T2realisable Every precisely T1realisable set types meetprecisely T2realisable Table 1 shows relative strength variants Σ entailment introduced Section 3 languages DLLite N horn stands notions equivalent cid24 notions equivalent TBoxes formulated DLLite smaller language mean notion properly weaker TBoxes smaller language case N bool 43 Σ difference L Σ T1 T2 qDiff L Σ T1 T2 scDiff The semantic criteria formulated approximate different variants Σ difference ontolo gies When comparing ontologies respect signature ontology engineer needs yes answer informative representation difference ontologies different It hard L Σ T1 T2 mDiffΣ T1 T2 Σ differences deﬁned sets cDiff Section 3 inﬁnite Thus approximations sets computed practice One possibility obtain approximations exploit semantic criteria provided For example criterion Theorem 20 Σ concept difference Σ Q T1T2 types T1realisable T2realisable obvious candidates inclusion approximation For basic Σ Q T1T2 concept B types contain B negation Of course exponentially types size Σ T1 T2 method unfeasible practice types analyse resulting list incomprehensible For stronger versions Σ difference consider sets Σ Q T1T2 types cf criteria Theorems 21 26 27 A detailed investigation approach representing Σ differences ontologies scope paper leave future research L Σ T1 T2 sqDiff 5 Robustness properties The results Σ difference Σ entailment easily misinterpreted considered context certain robustness properties notions Σ difference Σ entailment limited use enjoy properties In section discuss types robustness conditions First consider robustness deﬁnitorial extensions TBoxes justify decision work essentially positive existential queries seemingly natural positive existential queries Second consider preservation results Σ entailment addition fresh symbols Σ analyse robustness Σ inseparability entailment taking unions TBoxes These robustness properties closely related interpolation theorem Robinsons joint consistency property mathematical logic Finally consider robustness extensions description logic question new constructs means extensions TBox ABox query languages Rather surprisingly turns N bool expressive SHIQ preserve important cases extend lightweight DL DLLite Σ entailment An important robustness property discussed section robustness replacement introduced Section 3 replacement property justify explain strong notions Σ difference entailment Deﬁnition 10 We revisit robustness replacement discussion inseparability modules 51 Robustness deﬁnitorial extensions concepts negated concepts allowed case DLLite Recall Section 2 essentially positive existential queries ABoxes DLLite N bool allow negated N horn proper positive existential N queries An alternative approach allow positive concepts DLLite horn concept names As mentioned Remark 2 ways essentially equivalent presence TBoxes Yet rise different notions Σ query entailment Indeed positive concepts allowed queries TBox T2 Example 8 1108 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 N Σ query entailed T1 DLLite bool We argue essentially positive existential queries considered context investigation The reason positive existential queries allowed addition deﬁnition A Lecturer T1 T2 A Σ result TBoxes T cid18 2 signature N T cid18 Σ cid18 bool This kind nonrobust behaviour Σ query entailment 2 DLLite clearly undesirable 1 Σ cid18 query entail T cid18 1 T cid18 To able speak notions entailment inseparability time introduce following notation Given DL L use cid5 denote ternary entailment relation L arguments ontologies T1 T2 L signature Σ Thus T1 cid5Σ T2 shorthand T1 Σ entails T2 L In words cid5 collection respective Σ entailment relations signatures Σ Likewise use denote ternary inseparability relation L T1 Σ T2 T1 cid5Σ T2 T2 cid5Σ T1 Deﬁnition 30 An entailment relation cid5 DL L called robust deﬁnitorial extensions signature Σ T1 cid5Σ T2 implies T1 A C cid5Σ A T2 A C A sigT1 T2 C Σ concept L The proof following result straightforward left reader Theorem 31 All entailment relations Section 3 robust deﬁnitorial extensions DLLite N bool DLLite N horn 52 Robustness vocabulary extensions Clearly entailment relations preserved removing symbols Σ T1 cid5Σ T2 implies T1 cid5Σ cid18 T2 Σ cid18 Σ Obviously converse implication hold general However turns holds fresh symbols added signature Deﬁnition 32 An entailment cid5 L robust vocabulary extensions T1 cid5Σ T2 implies T1 cid5Σ cid18 T2 Σ Σ cid18 Σ cid18 sigT2 Σ Robustness vocabulary extensions particular importance Σ query entailment strong versions Σ entailment For example means T1 strongly Σ query entails T2 ABox A TBox T query q containing apart symbols Σ arbitrary symbols occurring T2 T1 T A cid15 qa T2 T A cid15 qa This property critical applications hardly possible restrict ABoxes context ontologies ﬁxed signature Σ permit use fresh symbols Theorem 33 All entailment relations Section 3 robust vocabulary extensions DLLite N bool DLLite N horn Remark 34 Robustness vocabulary extensions important consequences investigation computational complexity deciding TBox T1 Σ entails TBox T2 Namely T1 Σ entails T2 T1 Σ cid18 entails T2 Σ cid18 sigT2 Σ assume Σ sigT2 Thus cid4T1 cid4T2 size input neglect size Σ measuring size input decision problem T1 Σ entail T2 Sometimes assume Σ sigT1 Σ sigT1 The assumption Σ sigT1 justiﬁed add A cid8 A P cid8 P T1 A P Σ We work Σ sigT1 uniformly rename occurrences concept role names sigT1 Σ T2 fresh concept respectively role names work resulting TBox T cid18 2 instead T2 53 Robustness joins Apart addition fresh symbols important guarantee robustness certain joins ontologies Deﬁnition 35 An inseparability relation L robust joins TBoxes T T1 T2 L signa ture Σ T Σ T1 T2 T Σ T1 T Σ T2 sigT1 sigT2 Σ Robustness joins collaborative ontology development This property means example ontology developers extend independently ontology T ontologies T1 T T2 T use common symbols apart certain signature Σ form union T1 T2 potentially damaging additional Σ consequences provided Ti T Σ inseparable 1 2 Theorem 36 All inseparability relations Section 3 robust joins DLLite N bool DLLite N horn R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1109 Note instead deﬁnition given consider stronger replacing Σ inseparability Σ entailment More precisely require TBoxes T T1 T2 L signature Σ T Σ entails T1 T2 T Σ entails Ti 1 2 sigT1 sigT2 Σ Unfortunately stronger robustness property hold inseparability relations Section 3 We example showing Σ concept inseparability investigate stronger notion inseparability relations scope paper Example 37 Let T1 A cid8 R R T1 T2 cid15 A cid8 T Σ concept entail T1 T2 cid8 B T2 T B cid8 Σ A B Then T Σ concept entails Ti 1 2 Remark 38 Robustness vocabulary extensions robustness joins ﬁrst introduced 25 That paper investigates relationship properties wellknown Robinson consistency lemma Craig interpolation property 46 For description logic EL robustness conditions investigated 44 expressive description logics ALC extensions ﬁrstorder logic investigated 25 Rather interestingly robustness vocabulary extensions robustness joins interpolation typically fail description logics nominals andor role inclusions 4725 54 Robustness language extensions As seen general languagedependent notions Σ entailment depend underlying logic stronger logic induce differences So natural expect languagedependent notions Σ N bool expressive description logics ALC SHIQ Rather entailment robust extending DLLite N bool strong Σ query entailment robust surprisingly turns Σ query entailment DLLite N bool language queries ABoxes context TBoxes SHIQ In fact result holds extending DLLite DLs class models TBoxes closed disjoint unions Appendix A1 deﬁnition disjoint unions We note typical DLs class models TBoxes closed disjoint unions DLs nominals DLs universal role We remind reader compared DLLite N bool SHIQ allows qualiﬁed number restrictions form cid2 qRC role inclusion axioms R1 cid8 R2 transitivity constraints stating certain roles interpreted transitive relations 2 details An ABox SHIQ consists assertions form Ca C SHIQconcept essentially positive existential query SHIQ contain atoms Ct C SHIQconcept With auxiliary deﬁnitions hand repeat Deﬁnition 10 L SHIQ Deﬁnition 39 Let T1 T2 TBoxes Σ signature We T1 strongly Σ query entails T2 SHIQ TBoxes T ABoxes A queries q SHIQ sigT A q Σ tuples object names A T2 T A cid15 qa implies T1 T A cid15 qa The following result proved Appendix A3 Theorem 40 For TBoxes T1 T2 DLLite entails T2 DLLite N bool T1 strongly Σ query entails T2 SHIQ N bool signature Σ T1 Σ query entails equivalently strongly Σ concept 6 Complexity Σ entailment Now investigate computational complexity deciding Σ entailment Σ inseparability N horn TBoxes A ﬁrst impression expect given Theorem 17 known com DLLite plexity results deciding Σ entailment propositional theories N bool DLLite 61 Lower bounds We remind reader complexity class Π p 2 denoted coNPNP consists problems solved coNP Turing machines NP oracle A typical example Π p 2 complete problem determining truth quantiﬁed Boolean formulas QBFs short form pqϕp q ϕp q propositional formula built propositional variables lists p q 4849 Σ entailment propositional theories reduced satisﬁability QBFs form Indeed let ϕp q ψr q propositional formulas disjoint p q r Σ q Then ϕp q Σ entails ψr q QBF qprϕp q ψr q true The following result proved 50 proved directly discussion Example 16 Theorem 41 Deciding Σ entailment propositional theories Π p Horn theories coNPcomplete 2 complete Deciding Σ entailment propositional 1110 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 As propositional theory Φ trivially encoded linear time means TBox T Φ T N horn Φ Horn theory Theorems 41 17 obtain logically equivalent T DLLite following complexity lower bounds Theorem 42 Deciding Σ entailment DLLite DLLite N horn coNPhard N bool Π p 2 hard variants Σ entailment deciding Σ entailment It turns lower bounds actually coincide upper bounds deciding languagedependent Σ N horn prove Section 62 Deciding Σ model en entailments inseparability DLLite tailment turns harder problem In Section 63 discuss establish decidability Σ model entailment DLLite N bool problem coNExpTimehard N bool DLLite Remark 43 For expressive DLs EL computational complexity certain notions Σ entailment inseparability known Interestingly EL deciding Σ entailment typically harder DLLite For example Σ concept entailment Σ query entailment ExpTimecomplete EL 5144 However EL TBoxes consisting possibly cyclic concept deﬁnitions Σ concept entailment tractable 52 When moving expressive DLs ALC ALCQI Σ concept entailment 2ExpTimecomplete ALCQIO Σ concept entailment undecidable 2433 For expressive DLs ALC complexity Σ query entailment currently unknown Σ model entailment undecidable EL extensions 51 62 Complexity languagedependent Σ entailments As mentioned Section 2 satisﬁability problem DLLite N horn KBs Pcomplete UNA It follows problem deciding type t T realisablethat N N KB T Ca C t satisﬁableis NPcomplete DLLite bool Pcomplete DLLite horn We employ result criterion Theorem 20 prove following N bool KBs NPcomplete DLLite Theorem 44 Deciding Σ concept entailment DLLite DLLite N horn TBoxes coNPcomplete N bool TBoxes Π p 2 complete Deciding Σ concept entailment Proof Let T1 T2 TBoxes DLLite Σ sigT1 T2 By Theorem 20 following algorithm decides T1 Σ concept entail T2 N bool Σ signature By Remark 34 assume loss generality 1 Guess Σ Q T1T2 type t Observe size t quadratic size T1 T2 2 Check calling NPoracle t T1realisable ii t T2realisable 3 Return T1 Σ concept entails T2 answers ii positive Clearly algorithm runs Σ p 2 problem deciding T1 Σ concept entail T2 Π p 2 The algorithm calling Poracle DLLite TBoxes T1 T2 T1 Σ concept entails T2 coNP cid2 N horn TBoxes runs NP problem deciding given DLLite N horn Remark 45 The size Σ Q T1T2 type quadratic cid4T1 T2 numbers Q T1T2 occur numerical parameters T1 T2 Under binary coding numbers exponential cid4T1 T2 included Q T1T2 natural numbers 1 maximal number qmax occurring TBoxes It follows particular complexity result subsequent results depend numbers coded binary We note possible deﬁne types linear size cid4T1 T2 serving purpose types considering numerical parameters role separately To simplify notation refrained However experiments described Section 9 precisely reduce size QBFs To check criterion Theorem 21 languagedependent variants Σ entailment able establish precise realisability sets types The following simple example illustrates intuition notions need cid8 B B cid8 R suppose want know Example 46 Let Σ A B Q 1 T A P P A B T realisable In words set Ξ t like know model I T points x0 x1 t t tI xi 0 1 tI xi sigT Q type xi deﬁned 1 If I xi exist clearly P t0 R t1 means P arrow starts x0 Rarrow starts x1 But exist witness types ends respectively By axioms T arrows sigT Q types tP tR containing P cid8 B R cid18 A B t 1 Σ Q types t R cid18 0 t cid18 1 cid18 0 cid18 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1111 Fig 2 The ﬁrst steps constructing model realising t cid18 0 t cid18 1 means unravelling types contain B R requires witness type R tR In fact types t0 t1 tP tR need construct inﬁnite forestlike model T realising Ξ precisely realising set t0 t1 tP tR This construction known unravelling appropriate I shown Fig 2 It hard general TBox m role names unravelling procedure having started k types produce model k 2m distinct types More precisely set Ξ cid18 Σ Q types T realisable Σ sigT Q T Q precisely T realisable set Ξ sigT Q types Ξ cid3 Ξ cid18 2m m number role names T ii type Ξ cid18 extended type Ξ This example motivates following deﬁnition Let T TBox DLLite natural numbers Σ sigT Q T Q N bool Σ signature Q set positive k 1 Σ Q types pair sequences Ξ T t 0 tk tk1 tk2m Deﬁnition 47 Given set Ξ t necessarily distinct sigT Q types called T witness Ξ m number role names T following conditions satisﬁed cid18 0 t cid18 k cid18 t icid4Σ 0 cid3 cid3 k w1 t w2 type sequence t0 tk tk1 tk2m T realisable w3 role P T 1 cid3 cid3 m types tk2i1 tk2i witnesses P P respectively precisely P tk2i1 P tk2i A T witness Ξ T called precise T witness Ξ cid6 P P cid7 t j cid11 0 cid3 j cid3 k 2m wpr type t sequence tk1 tk2m type t cid18 j Ξ t icid4Σ t cid18 j Example 48 In setting Example 46 pair t0 t1 t 0 tP t1 tR precise T witness Ξ t cid18 0 t cid18 1 It follows deﬁnition unravelling construction Example 46 10 Proposition 49 A set Ξ Σ Q types T realisable T witness Ξ ii A set Ξ Σ Q types precisely T realisable precise T witness Ξ cid18 cid18 k I cid18 0 t cid18 Proof Suppose Ξ t cid3 k sigT Q type t realised I t t icid4Σ For role P T 1 cid3 cid3 m I In case tk2i1 tk2i sigT Q types realised I containing cid11 P P respectively In case deﬁne tk2i1 tk2i sigT Q types realised I It P P readily checked t 0 tk tk1 tk2m T witness Ξ T realisable Take model I T realising Ξ Then Σ Q type t Conversely assume t 0 tk tk1 tk2m T witness Ξ We construct model I T precisely arbitrary countably inﬁnite set Take surjective function f cid5I way B f x Such interpretation function deﬁned set natural numbers For basis induction A f 0 concept A Given role R let q maximal cid2 q R f 0 If realising set t0 tk2m Its domain cid5I t0 tk2m inﬁnite f basic sigT Q concept B x B inductively unravelling construction Suppose cid5I set 0 A 1t cid3 k 2m deﬁne interpretation function I I I 1112 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 f ni 1 cid3 cid3 q Such numbers exist view w3 Then set 0 ni R q 0 Otherwise q numbers n1 nq involved construction R In induction step number n taking account incoming Rarrow successors n I q cid2 1 l n R f n To constructed interpretation I model T suﬃces recall maximal cid2 q R types t T realisable w2 Indeed I cid11cid15 T C cid8 D T x cid5I x D R l n case need q 1many fresh R case type f x T realisable x C I I I I The proof ii similar left reader cid2 Recall Theorem 21 check T1 Σ query entails T2 verify condition pr precisely T1realisable set Σ Q T1T2 types precisely T2realisable The unravelling construction illustrated Example 46 Proposition 49 indicate instead considering arbitrary T1realisable sets Σ Q T1T2 types deal T1witnesses generated single Σ Q T1T2 type More precisely simplify pr following criterion Theorem 50 T1 Σ query entails T2 DLLite N bool following condition holds cid18 pr Σ Q T1T2 type t T1witness t 0 t1 t2m1 t precise T2witness set t0cid4Σ t1cid4Σ t2m1 cid4Σ m1 number role names T1 cid18 Proof pr pr set t0cid4Σ t1cid4Σ t2m1 precise T2witness It follows proof Proposition 49 t 0 t1 t2m1 T1witness t cid4Σ precisely T1realisable By pr set precisely T2realisable Proposition 49 cid18 pr pr Suppose set Ξ t Σ Q T1T2 types precisely T1realisable By Proposi tion 49 exists precise T1witness Ξ T1 t 0 tk tk1 tk2m1 Ξ Then clearly sequences t tk1 tk2m1 T1witnesses singletons t 0 cid3 cid3 k According pr Proposition 49 cid4Σ Ξ Now deﬁne interpretation I models Ji T2 precisely realising sets Ξi t icid4Σ tk1cid4Σ tk2m1 disjoint union Ji precise deﬁnition given Appendix A1 As i0 Ξi Ξ easy I model T2 precisely realising Ξ cid2 cid13 k cid18 cid18 0 t cid18 k Note size witnesses mentioned condition pr polynomial size T1 T2 T1witness contains 1 2m1 types T2witness 1 2m1 2m2 types mi number roles names Ti 1 2 type quadratic size size T1 T2 Thus t condition pr checked nondeterministic polynomial time details consult Section 91 We use observation construct Π p 2 algorithm deciding N Σ query strong forms entailment DLLite bool TBoxes But let modify N notions witnesses DLLite horn TBoxes cid18 cid18 Deﬁnition 51 Given TBox T DLLite T witness Ξ T t0 tk tk1 tk2m Ξ satisfying following condition N horn set Ξ Σ Q types subprecise T witness Ξ understand wspr type t sequence tk1 tk2m type t cid18 j Ξ t cid4Σ t cid18 j A meetprecise T witness Ξ T witness Ξ T t0 tk tk1 tk2m Ξ wmpr type t tk1 tk2m set Ξt t cid18 j Ξ t cid4Σ t cid18 j nonempty t cid4Σ cid12 t t cid18 j cid18 j Ξti It follows deﬁnition unravelling construction Proposition 52 For TBox T DLLite N horn set Ξ Σ Q types subprecisely T realisable subprecise T witness Ξ ii set Ξ Σ Q types meetprecisely T realisable meetprecise T witness Ξ Since realisability single type respect TBox DLLite N horn checked deterministic polynomial time number types witnesses linear number roles length TBox check given set precise sub meetprecise witness compute polynomial time proof Appendix A4 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1113 Lemma 53 There algorithm given TBox T DLLite istic polynomial time Ξ precise subprecise meetprecise T witness constructs witness exists N horn set Ξ Σ Q types Q Q T decides determin Similarly Theorem 50 conditions spr mpr Theorems 26 27 equivalently reformulated terms sub meetprecise witnesses Theorem 54 T1 Σ query entails T2 DLLite N horn following condition holds spr cid18 Σ Q T1T2 type t T1witness t 0 t 1 t2m1 t subprecise T2witness set t0cid4Σ t1cid4Σ t2m1 ii T1 strongly Σ query entails T2 DLLite N horn following condition holds cid18 Σ Q T1T2 type t T1witness t 0 t1 t2m1 t meetprecise T2witness set t0cid4Σ t1cid4Σ t2m1 cid4Σ m1 number role names T1 cid4Σ m1 number role names T1 mpr We position obtain following tight complexity results Theorem 55 Deciding Σ query strong Σ concept strong Σ query entailment DLLite ii Deciding Σ query strong Σ concept strong Σ query entailments DLLite N bool TBoxes Π p N horn TBoxes coNPcomplete 2 complete Proof Let T1 T2 TBoxes DLLite Σ sigT1 T2 By Theorem 50 following algorithm decides T1 Σ query entail T2 N bool Σ signature By Remark 34 assume loss generality 1 Guess Σ Q T1T2 type t 2 Check calling NPoracle precise T1witness t 0 t1 t2m1 t b precise T2witness t0cid4Σ t1cid4Σ t2m1 cid4Σ 3 Return T1 Σ query entails T2 answers b positive This algorithm runs Σ p 2 problem deciding T1 Σ query entails T2 Π p 2 ii Here use similar algorithm calling Poracle Lemma 53 compute given set types subprecise meetprecise T2witness This algorithm clearly runs NP cid2 63 Decidability Σ model entailment In section Σ model entailment TBoxes DLLite N horn decidable coNExpTimehard The decidability proof embedding twosorted ﬁrstorder theory Boolean algebras BA combined Presburger arithmetic PA representing cardinalities sets The decidability theory called BAPA ﬁrst proved 53 The computational complexity practical algorithms BAPA investigated 54 The coNExpTime lower bound proved reduction model conservativity problem modal logic S5 known coNExpTimecomplete 55 As reasoning BAPA known harder coNExpTime encoding exponential worst case precise computational complexity Σ model entailment remains open We provide brief discussion feasibility Σ model entailment practice end section N bool DLLite Let begin expanding Example 14 showing uncountable models considered deciding Σ model entailment Example 56 Let T1 DLLite N horn TBox stating auxiliary role names R R B concept B inﬁnite T1 B For T2 TBox Example 14 stating P injection A B cid8 B B cid8 R B cid2 2 R cid8 R B R cid4 cid8 R R cid8 R cid5 R B B cid7 cid8 T2 A P P cid8 B cid2 2 P cid8 cid2 2 P cid7 cid8 cid6 cid6 I Let Σ A B There exists uncountable model I T1 uncountable A injection A I countably inﬁnite model T1 injection A exists model Icid18 T2 languagedependent notions Σ entailment Thus Icid4Σ mDiffΣ T1 T2 T1 Σ model entail T2 It observe Thus case T2 coincides I Σ Using semantic criteria readily checked T1 Σ entails countable B B B I I I I I 1114 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 This example shows decide Σ model entailment reason effectively possibly inﬁnite cardi nalities sets course basic settheoretic operations intersection complement BAPA twosorted ﬁrstorder language designed precisely purpose Formally language BAPA deﬁned follows Its terms sort set constructed variables X1 X2 constants 0 set 1 set binary function symbols intersection union complement The terms sort number constructed variables x1 x2 constants unary function symbol set K 0 1 2 natural numbers expressions B B term sort set binary function symbol As usual prefer inﬁx notation binary function symbols write X Y instead X Y Atomic BAPA formulas form cid12 B1 B2 B1 B2 B1 B2 terms sort set B k B cid2 k B term sort set k term sort number k1 cid3 k2 k1 k2 sort number BAPA formulas constructed standard way ﬁrstorder quantiﬁcation variables sort set number conjunction negation We interested validity BAPA formulas twosorted relational structures called BAPA structures form cid4cid4 cid5 cid4 A 2cid5 cid5 cardcid5 0 1 2 cid5 cid5 2cid5 cid5 Boolean algebra subsets nonempty set cid5 cardcid5 set cardinal numbers κ κ cid3 cid5 B cardinality subset B cid5 A BAPA model M consists BAPA structure A interpretation n n cid3 cid5 variables xi sort XM number cardinal numbers greater cardinality cid5 Our use exactly symbols BAPA formulas BAPA structures deliberate ease presentation cid5 variables Xi sort set subsets cid5 interpretation xM Decidability validity BAPA formulas follows 53 Theorem 57 The problem BAPA sentence true BAPA models decidable In fact follows 54 validity problem BAPA sentences 2ExpSpace We reduction N bool validity BAPA sentences As BAPA binary relation symbols main Σ model entailment DLLite problem encode truth conditions number restrictions cid2 q R BAPA sentences N bool signature Σ given By Remark 34 assume loss Suppose TBoxes T1 T2 DLLite generality Σ sigT1 For basic concept B occurring T1 T2 BAPA variable X B sort set concept C signature T1 T2 deﬁne inductively BAPA term C s sort set B s X B s 0 cid4s 1 Cs Cs C1 cid5 C2s C s 1 C s 2 We set 1 2 cid8 cid6 cid8 C1 cid8 C2 Ti C s 2 C s 1 T s cid7 As ﬁrst approximation try translate problem T1 Σ model entails T2 validity problem BAPA sentences form cid10 cid9 cid10 X α Y cid11 α 2 αT s 1 αT s 2 2 T s X sequence variables sort set occurring T s 1 Y sequence variables sort set occur 1 This sentence supposed convey meaning T1 Σ model entails T2 Σ sigT1 T s Σ model T1 extended model T2 cf Deﬁnition 13 The problem encoding account semantics number restrictions Let qmax maximal numerical parameter occurring T1 T2 parameters set qmax 0 For role P T1 T2 introduce sets additional fresh variables sort set R P P set XR Xq R 0 cid3 q cid3 qmax Xqmax R Intuitively want Xq R stand set points precisely q Rsuccessors Xqmax R set points qmax Rsuccessors To ensure ﬁrst add T s following obviously sound equations role P Ti R P P R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1115 cid18 0 distinct X X X X X0 R Xqmax R Xqmax R 1 Xcid3q R Xq R Xq1 R Xqmax R Xqmax R basic concept cid2 q R Ti cid18 XR The resulting sets BAPA sentences denoted T se interpretations variables XP X ocid16d d cid18 cid16 cid16indegree d icid16d d cid18 d d cid18 d cid18 d cid16 It remains formulate relationships cardinality P For binary relation cid16 deﬁne cid16outdegree ocid16d point d Deﬁnition 58 Let qmax cid2 0 natural number A setsystem S A1 Aqmax A B1 Bqmax B consists ﬁnite sequences sets sets sequence mutually disjoint A binary relation cid16 called solution S Aq set points cid16outdegree q 1 cid3 q cid3 qmax A set points cid16outdegree qmax Bq set points cid16indegree q 1 cid3 q cid3 qmax B set points cid16indegree qmax The following result proved Appendix A4 Lemma 59 For role P number qmax cid2 1 construct BAPA formula ϕP qmax free variables X1 P Xqmax P Xqmax P X1 P Xqmax P Xqmax P BAPA model M following conditions equivalent M cid15 ϕP qmax ii setsystem XM 1 P XM qmax P XM qmax P XM 1 P XM qmax P XM qmax P solution Given lemma rectify 2 straightforward way Let X sequence variables sort set occurring X Then deﬁne BAPA formula let Y sequence variables sort set occurring T se 2 T se 1 ϕT1T2 taking ϕT1T2 X cid9cid9 cid10 cid10 α αT se 1 P sigT1 cid11 ϕP qmax Y cid9 cid10 cid10 α cid11cid11 ϕP qmax αT se 2 P sigT2 qmax 0 ϕT1T2 form 2 qmax 0 Now prove following reduction theorem proof given Appendix A4 Theorem 60 Let Σ sigT1 Then T1 Σ model entails T2 ϕT1T2 valid It follows Remark 34 decidability BAPA Σ model entailment decidable The formula ϕP qmax structed proof Lemma 59 exponential qmax upper bound computational complexity ciding Σ model entailment obtained reduction disappointing 4ExpSpace qmax coded binary In Appen dix A4 establish reduction model conservativity problem modal logic S5 following lower bound Theorem 61 Deciding Σ model entailment TBoxes DLLite hard N horn maximal numerical parameter qmax 3 coNExpTime Finding tight complexity bounds deciding Σ model entailment remains open problem scope paper As encoding Σ model entailment BAPA uses little arithmetic exhibited construction ϕP qmax proof Lemma 59 conjecture complexity actually coNExpTime ExpSpace It important note formula ϕP qmax constructed Lemma 59 polynomial size maximal parameter qmax ﬁxed This appears natural assumption cases number restrictions introduce functional roles It conduct experiments TBoxes Σ model entailment encoding BAPA BAPA reasoner introduced 54 7 Inseparability modules In section discuss notions Σ inseparability employed deﬁne modules analyse relationships modules design module extraction algorithms Intuitively module TBox T subset M T says 1116 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 certain subject matter T Assuming subject matters represented signatures Σ saying Σ formalised Σ inseparable come modules Σ inseparable TBoxes containing Many interesting properties modules module extraction algorithms described refer ring particular notion Σ inseparability certain properties inseparability relations So like Section 5 consider abstract notion inseparability relation DL L covers variants Σ inseparability introduced develop corresponding notions modules framework One obvious N property need equivalence relation As assume L logics DLLite bool DLLite N horn Deﬁnition 62 We inseparability relation L monotone satisﬁes following conditions TBoxes T1 T2 L signatures Σ Msig Σ cid18 Σ T1 Σ T2 T1 Σ cid18 T2 MT TBox T L T1 T T2 T1 Σ T2 T Σ T1 Condition Msig formalises intuition TBoxes Σ inseparable Σ cid18 inseparable MT demands TBox sandwiched inseparable TBoxes inseparable smaller signature Σ cid18 The following statement left reader easy exercise Theorem 63 All inseparability relations DLLite N bool DLLite N horn Section 3 monotone We introduce discuss notions modules induced inseparability relation The ﬁrst formalises intuition discussed account additional properties want modules Deﬁnition 64 Let inseparability relation L T TBox L M T Σ signature We M Σ module T M Σ T selfcontained Σ module T M ΣsigM T depleting Σ module T ΣsigM T M M minimal selfcontained depleting Σ module T M selfcontained depleting Σ module T proper subset M selfcontained depleting Σ module T The main feature selfcontained Σ modules indistinguishable original TBox respect Σ respect signature Such module selfcontained sense original TBox imply extra consequences modules signature It follows deﬁnition satisﬁes Msig case inseparability relations selfcontained Σ module Σ module Depleting modules emphasise different aspect modularity depleting module required TBox module imply nontautological consequences Σ modules signature We certain conditions inseparability relation implies selfcontained module However general nontrivial inclusions types modules exist Example 65 Let T A cid8 B B cid8 A Σ E Then M A cid8 B clearly Σ module T inseparabil ity relation introduced Section 3 On hand M selfcontained Σ module T inseparability relation Section 3 T cid15 B cid8 A M cid11cid15 B cid8 A A B sigM ii To selfcontained Σ modules depleting Σ modules consider T A cid8 B A cid8 B cid5 B Σ A B Then M1 A cid8 B M2 A cid8 B cid5 B selfcontained Σ modules T depleting Σ module T inseparability relation introduced Section 3 A interesting example needed depleting c Σ modules selfcontained c Σ modules c Σ Σ concept inseparability relation DLLite N bool Example 66 Consider following modiﬁcation Example 6 Let Σ Lecturer Course T cid6 Lecturer cid8 teaches teaches Then M Course cid8 depleting c c Σ module T T cid15 Lecturer cid8 cid7 cid8 Course Course cid8 Σ module T However M c Σ module selfcontained R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1117 Before investigating relationship selfcontained depleting modules present straightforward algorithm extracting minimal Σ module given TBox oracle deciding inseparability relation Theorem 67 Let inseparability relation L satisfying MT T TBox L Σ signature Then following algorithm computes minimal Σ module T input T Σ M T α M M α Σ M M M α end output M Proof By MT algorithm computes Σ module M T M α Σ module T α M Again MT proper subset M Σ module cid2 Note minimal Σ module extracted algorithm depends order picking axioms α principle exponentially distinct minimal Σ modules TBox Example 68 Consider following generalisation TBox Example 65 n cid2 0 let Tn Ai cid8 B Ai cid8 B cid5 B cid3 n let Σn Ai B cid3 n Then M Tn containing Ai cid8 B Ai cid8 B cid5 B cid3 n clearly minimal c module Tn number modules 2n Σn We investigate modules induced inseparability relations satisfy replacement property replace considered Section 3 For convenience reader deﬁnition Deﬁnition 69 An inseparability relation L robust replacement TBoxes T T1 T2 L signatures Σ T1 T Σ T2 T T1 Σ T2 sigT Σ As explained Section 3 robustness replacement fundamental ontology reuse Taken ro bustness vocabulary extensions having deﬁned notion module importance justiﬁed succinct precise way Suppose ontology developer imports Σ module M TBox T TBox O If robust replacement vocabulary extensions O T Σ cid18 O M signature Σ cid18 Σ cid18 sigT Σ sigT sigO Σ cid18 To observe robustness vocabulary extensions T Σ cid18sigO M Thus robustness replacement O T Σ cid18sigO O M It follows robustness proper ties ensure difference far signature Σ cid18 concerned imports T Σ module M T O Moreover properties depend signature O checked considering T M The following result summarises shown Examples 9 11 follows corresponding theorems equivalence inseparability notions Theorem 70 The following inseparability relations robust replacement Σ concept inseparability DLLite Σ query inseparability DLLite N horn ii The following inseparability relations robust replacement Σ query inseparability DLLite N bool DLLite N horn Σ model inseparability strong Σ query inseparability DLLite N bool Σ concept N bool strong Σ concept We reasons explaining importance robustness replacement Theorem 71 If inseparability relation L robust replacement depleting Σ module selfcontained Σ module Proof If T M ΣsigM robustness replacement implies T T M M ΣsigM M M cid2 Thus reason depleting c Σ modules selfcontained c Σ concept inseparability relation c robust replacement Σ modules cf Example 66 1118 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Theorem 72 Let monotone inseparability relation L robust replacement T TBox L Σ signature Then unique minimal depleting Σ module T computed following algorithm input T Σ M W T M cid11 W choose α T M W W W α W cid11ΣsigM M M α W endif end output M Proof Let M depleting Σ module T T M ΣsigM We ﬁrst prove following Claim For signatures Σ cid18 Σ Σ cid18 Σ sigM M0 T minimal set M0 cid11Σ cid18 M0 M Proof claim Suppose claim hold M0 cid11 M Then X Σ cid18 X M M0 X proper subset M0 X cid11Σ cid18 contrary minimality M0 As M depleting Σ module sigX sigM robustness replacement T M X ΣsigM X Using Σ cid18 Σ sigM Msig transitivity Σ cid18 obtain X Σ cid18 T M X Σ cid18 By MT obtain M0 T M X M0 Σ cid18 contradiction cid2 Using claim easily prove induction M computed run algorithm Theorem 72 input T Σ contained depleting Σ module T Hence output M contained depleting Σ module T On hand termination condition algorithm M depleting Σ module T algorithm terminates T partitioned M W Σ sigMinseparable Consequently M unique minimal depleting Σ module T cid2 The algorithm computes minimal depleting Σ module time quadratic number concept inclusions T T calling oracle deciding inseparability relation T 2 times It follows minimal depleting modules advantage uniquely determined mild conditions sharply contrasts behaviour types modules Another advantage depleting modules support modular ontology development following sense Suppose M depleting Σ module T robust replacement vocabulary extensions Then import ontology T M module Mcid18 sigMcid18 sigT Σ sigM sure T M interfere Mcid18 T M Mcid18 Σ cid18 Mcid18 Σ cid18 sigT M Σ sigM The importance property ﬁrst pointed 1 In following illustrative example compute kinds modules DLLite minimal Σ concept inseparability modules MCM minimal Σ query inseparability modules MQM minimal depleting Σ query inseparability modules MDQM These abbreviations Section 9 Example 73 Consider following DLLite N bool TBox T N bool cid8 Distributor 1 Publisher cid8 pubHasDistrib 2 pubHasDistrib 3 Publisher cid8 Distributor 4 pubHasDistrib cid8 Publisher 5 Publisher cid8 cid3 1 pubHasDistrib 6 Role cid8 Distributor 7 User cid8 Distributor cid8 AdmUser cid7 BookUser 8 Publisher cid8 pubAdmedBy 9 pubAdmedBy 10 AdmUser cid8 User 11 BookUser cid8 User 12 User cid8 hasRole cid8 Role 13 hasRole 14 Role cid8 Publisher 15 User cid8 Publisher 16 Role cid8 User 17 User cid8 userAdmedBy 18 userAdmedBy 19 userAdmedBy cid8 User 20 pubAdmedBy cid8 Publisher cid8 AdmUser R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1119 larger Core ontology discussed Section 9 let Σ Publisher Observe MCM T typical singleton signatures Σ concept inseparability interesting concept inclusions singleton signature exist However Σ query inseparability ask Publisher Publisher gives precisely different MQMs T MD cid6 cid7 1 2 3 MR cid6 cid7 8 9 10 11 12 13 14 MU cid6 cid7 8 9 10 11 15 First Σ query inseparable T veriﬁed semantic criterion Theorem 21 Second minimal For consider ABox A Publishera query q x Publisherx Clearly T A cid15 q T cid18 A cid11cid15 q proper subset T cid18 MD MR MU As experiments described Section 9 checked MQM exists In contrast ﬁnding MDQM T T To illustrate case consider TBox T cid18 concept inclusions 1719 M T T cid18 sigMquery separable Note sigM sigT userAdmedBy Let A Usera q x AdmUserx Then clearly T cid18 A cid15 q MDQM T In words T cid18 Consider Σ cid18 Publisher pubHasDistrib Then MCM T respect Σ cid18 consists concept inclu sions 15 MQMs respect Σ cid18 Mcid18 R MD MR cid6 cid7 4 5 6 Mcid18 U MD MU cid6 cid7 4 5 7 To MCM MQMs left reader Again fact MCMs MQMs shown experiments 8 Forgetting uniform interpolation When extracting subset M ontology T says signature Σ T typically include M large number axioms T contain nonΣ symbols Example 73 shows Σ size additional symbols occur module In section aim extracting new ontologies given ontology Σ original ontology addition use nonΣ symbols Often achieved introducing new axioms occur original ontology In mathematical logic parlance ontology called uniform interpolant original ontology 2223 artiﬁcial intelligence computing new ontology known forgetting nonΣ symbols 192027 The advantage forgetting module extraction depend way original ontology formulated modules subsets original ontology forgetting deﬁned independently axiomatisation ontology Of course regarded disadvantage ontology engineer familiar new axioms hard understand process To formalise forgettinguniform interpolation employ notions Σ inseparability TBox TΣ uniform interpolant TBox T respect Σ signature TΣ included Σ T TΣ Σ inseparable Of course problems TBox TΣ exists size constructed effectively depend available language constructs signature Σ type Σ inseparability interested N In section consider notions uniform interpolation corresponding Σ concept inseparability DLLite horn N DLLite bool A systematic study inseparability relations deﬁne forgetting scope paper 26 study extensions description logic EL N bool Σ query inseparability DLLite We start deﬁning forgetting uniform interpolation based Σ concept inseparability DLLite DLLite N horn N bool Deﬁnition 74 Let L DLLite TBox T L signature Σ exists TBox TΣ L sigTΣ Σ T TΣ Σ cid18 inseparable L Σ cid18 L We L admits forgetting uniform interpolation concept sigT Σ cid18 Σ In case TΣ called uniform interpolant T respect Σ N horn DLLite N bool Note deﬁnition appears restrictive indicated informal discussion instead concept inseparable sigT Σ cid18 Σ It readily seen deﬁnitions actually equivalent Σ concept demanding TΣ T Σ concept inseparable require TΣ T Σ cid18 Σ cid18 entailment robust vocabulary extensions Example 75 Let T Hand cid8 BodyPart BodyPart cid8 PhysicalObject Σ Hand PhysicalObject Then TBox TΣ Hand cid8 PhysicalObject uniform interpolant T respect Σ DLLite N bool DLLite N horn Note L uniform interpolation principle use uniform interpolants check Σ concept en L want T Σ concept tailment L Indeed suppose given TBoxes T T cid18 1120 entails T cid18 following R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 L To end compute uniform interpolant T cid18 Σ T cid18 respect Σ L And T Σ concept entails T cid18 T cid15 C cid8 D C cid8 D T cid18 Σ Thus checking Σ concept entailment reduced computing uniform interpolants checking subsumption L N The following theorem states DLLite horn enjoy uniform interpolation It proved Ap pendix A1 subsequently establish results stated earlier paper N bool DLLite Theorem 76 Let L DLLite Σ L constructed effectively N bool DLLite N horn Then L uniform interpolation uniform interpolant TBox T respect In worst case uniform interpolants given proof theorem exponential size T Note propositional logic known algorithms computing uniform interpolants return worst case interpolants exponential size In fact known P NC polynomialtime problem solved polylogarithmic time parallel polynomial number processors regarded unlikely exist uniform interpolants polynomial size propositional logic 56 Example 77 For DLLite case exponential size Indeed let cid6 Tn A B1 cid5 cid5 Bn N horn simple example showing minimal uniform interpolants worst cid8 cid8 1 cid3 cid3 n j 1 2 cid7 cid8 B Σn A cid6 Ai j cid8 cid8 1 cid3 cid3 n j 1 2 cid7 Ai j Then cid6 cid8 cid8 1 cid3 j1 jn cid3 2 cid7 A1 j1 TΣn cid8 A cid5 cid5 An jn uniform interpolant Tn respect Σn DLLite DLLite polynomial size cid14 cid15 T cid18 Σn cid31cid4icid4n cid4 cid5 Ai 1 cid7 Ai 2 cid8 A N horn It size 2n smaller uniform interpolant N N horn It worth mentioning exists uniform interpolant Tn respect Σn DLLite bool Of course worst case lower bounds imply practice unfeasible compute uniform interpolants example interesting conduct experiments deciding Σ concept entailment Theorem 76 compare performance approach based QBF encoding discussed For experimental results computing uniform interpolants TBoxes description logic EL refer reader 26 The notion uniform interpolation considered reﬂects interpretation saying vocabulary Σ Σ concept inseparable How notion uniform interpolation modiﬁed interested Σ concept inseparability Σ query inseparability The straightforward modiﬁcation Deﬁnition 74 replacing concept inseparability query inseparability notion inseparability introduced unsatisfactory shown following example Example 78 Let L DLLite N horn cid6 Lecturer cid8 teaches teaches N bool DLLite Consider TBox cid8 Course cid7 T Example 6 let Σ Lecturer Course Then TΣ uniform interpolant T respect Σ L seen TBox T Σ concept inseparable L Equivalently know set Σ concept inclusions C cid8 D T cid15 C cid8 D consists tautologies We know Σ TBox consisting tautologies Σ query inseparable L T Thus exist Σ TBox T cid18 Σ T Σ query inseparable Hence straightforward modiﬁcation Deﬁnition 74 replacing concept inseparability N bool signatures Σ uniform query inseparability leads deﬁnition allows simple TBoxes DLLite interpolants bool T cid18 Σ DLLite N The example shows obtain satisfactory notion forgetting uniform interpolation reﬂects Σ query inseparability apart replacing Σ concept inseparability Σ query inseparability Deﬁnition 74 increase expressive power description logic uniform interpolants formulated Denote DLLiteu bool extension DLLite N bool universal role U DLLiteu bool concepts deﬁned follows D C UC D1 cid5 D2 D R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1121 C DLLite N bool concepts Given interpretation I set UCI cid5I The remaining modeltheoretic notions deﬁned exactly DLLite subsumption problem T cid15 C1 cid8 C2 coNPcomplete TBoxes T DLLiteu C1 cid8 C2 DLLiteu bool It important regard U logical symbol sigUC sigC C I cid11 UCI N bool Using construction 10 bool concept inclusions Deﬁnition 79 Let T TBox DLLite T respect Σ DLLiteu N bool Σ signature A TBox TΣ DLLiteu bool called uniform query interpolant bool T cid15 α α TΣ sigTΣ Σ T TΣ Σ query inseparable Example 80 Consider TBox cid6 T Lecturer cid8 teaches teaches cid8 Course cid7 Σ Lecturer Course Then TΣ Lecturer cid8 UCourse uniform query interpolant T respect Σ DLLiteu bool To analyse justify deﬁnition uniform query interpolants ﬁrst use uniform query interpolants understand Σ query entailment way uniform interpolants understand Σ concept entailment Theorem 81 Let T T cid18 Σ DLLiteu TBoxes DLLite bool Then T Σ query entails T cid18 N bool Σ signature And let T cid18 T cid15 C cid8 D C cid8 D T cid18 Σ Σ uniform query interpolant T cid18 respect Finally uniform query interpolants exist Theorem 82 For TBox T DLLite respect Σ DLLiteu bool N bool signature Σ construct uniform query interpolant TΣ T DLLite N horn query inseparability DLLite We proposed notions forgetting uniform interpolation induced concept inseparability DLLite We close section brief discussion open problems related work forgetting uniform interpolation N bool N bool We seen case straightforward N enrich underlying description logic DLLite bool universal role obtain notion query uniform interpolants exist Developing uniform interpolants based remaining Σ inseparability relations interesting problem goes scope paper Forgetting concepts roles DLLite studied 27 resolutionbased technique It worth mentioning standard DLs ALC EL uniform interpolants exist 2426 9 Experimental results In order logicbased approach checking inseparability relations extracting minimal modules DLLite ontologies feasible practice conducted series experiments number typical N bool ontologies Instead developing implementing algorithms checking Σ concept mediumsize DLLite Σ query entailment criteria Theorems 20 21 50 encoded criteria means quantiﬁed Boolean formulas QBFs short employed standard offtheshelf general purpose QBF solvers In section discuss details encodings results experiments 91 QBF encodings We begin showing conditions Proposition 49 realisability precise realisability sets types encoded means QBFs Given signature Σ ﬁnite set Q natural numbers ﬁx list B 1 Bn basic Σ Q concepts different cid4 Denote b sequence B 1 b n pairwise distinct propositional variables containing variable B b basic Σ Q concept B save cid4 Such sequence b called Σ Q type variable It follows deﬁnitions b Bn Proposition 83 Let assignment truthvalues propositional variables satisfying following condition tp Σ role R numbers q q cid18 Q acid2 q cid18 Rb true acid2 q Rb true Then deﬁnes unique Σ Q type ta unique assignment truthvalues propositional variables sequence b b B ta b aB b true Conversely Σ Q type t t determines 1122 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Let T TBox DLLite N bool m number role names T Q Q T To encode notion T witness set k 1many Σ Q types Proposition 49 k 2m 1many distinct sigT Q type variables b0 bk2m consider propositional formula Φk T b0 bk2m k2mcid10 cid10 cid4 j0 C1cid8C2T C1b j C2b j cid5 k2mcid10 mcid10 cid10 cid16cid4 cid2 q P ib j cid4 cid18 cid2 q P cid4cid4 cid5 cid5 b j cid2 q P cid5 b j cid4 cid18 cid2 q P cid5 cid5cid17 b j cid18q cid18Q q qq cid18cid18q q cid18cid18Q j0 i1 q cid18q cid18cid9 k2mcid19 cid4 mcid10 i1 j0 P cid11 P ibk2i1 cid5 b j cid9 k2mcid19 j0 P ib j cid5 cid4 P bk2i cid11cid20 Cb C Σ Q concept deﬁned inductively follows b cid4b cid4 Cb Cb C1 cid5 C2b C1b C2b The second conjunct formula represents condition tp Proposition 83 ﬁrst conjuncts represent conditions w2 w3 Deﬁnition 47 respectively The following proposition immediate consequence Proposition 83 Deﬁnition 47 Proposition 84 Let Σ sigT let assignment truthvalues propositional variables Then Φk true pair Ξ T ta b0 set Ξ ta b0 T b0 bk2m sequences sigT Q types T witness cid4Σ Σ Q types cid4Σ ta bk ta bk ta ta bk2m bk1 Note size formula Φk Using formulas Φk T b0 bk2m linear k polynomial size cid4T T T b0 bk2m Propositions 49 84 represent problem deciding T1 Σ concept entails T2 truth problem certain QBFs Let mi number role names Ti 1 2 Q Q T1T2 We assume basic sigT1Q sigT2Q concepts ordered way Σ Q cid21 concepts precede sigTi ΣQ concepts 1 2 Take Σ Q type variable b sigTi ΣQ type variable bi 0 sigTiQ type variables bi 1 2 1 bi 2mi Proposition 85 The QBF b cid16 cid21 0 b1 b1 1 b1 2m1 cid4 Φ 1 T1 b cid21 0 b1 b1 1 b1 2m1 cid5 cid21 0 b2 b2 1 b2 2m2 cid4 Φ 1 T2 b cid21 0 b2 b2 1 b2 2m2 cid5cid17 true T1 Σ concept entails T2 DLLite 1 2 N bool Here b cid21 0 sigTiQ type variable obtained appending bi 3 cid21 bi 0 b Informally QBF 3 says following Σ Q type t represented b sense Proposition 83 t cid21 0 exist 2m1many sigT1Q types represented b1 b1 extended sigT1Q type means 2m1 resulting set 2m1 1 types T1realisable stated Φ 1 t T1 extended sigT2Q type 2m2many sigT2Q types resulting set 2m2 1 N types T2realisable In words QBF 3 true T1 Σ concept entails T2 DLLite horn Note way known results complexity classes QBFs 5057 encoding provides N N alternative proof upper complexity bounds deciding Σ concept entailment DLLite bool DLLite horn N bool TBoxes 1 2 sigT2Q type variables In similar manner encode criterion Theorem 50 Σ query entailment DLLite N bool DLLite b cid21 0 b1 b1 1 b1 1 b1 2m1 Take Σ Q type variables b0 b2m1 sigTi ΣQ type variables 1 b3 b3 cid21 bi 0 cid21 bi 2m1 2m2 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1123 Proposition 86 The QBF cid22 cid21 b1 0 b0 b2m1 cid21 b1 2m1 cid4 Φ 1 T1 cid23 cid21 b2 0 cid21 2m1 b3 b2 1 b3 2m2 Φ 12m1 T2 b0 cid21 b1 0 b2m1 cid21 b1 2m1 cid5 cid4 b0 cid21 b2 0 b2m1 cid21 b2 2m1 b3 1 b3 2m2 cid24cid25 cid5 2m2cid10 2m1cid19 cid5 cid4 χ b3 b j i1 j0 4 true T1 Σ query entails T2 DLLite Σ Q concepts N bool Here χ b3 b j conjunction formulas B b3 B b j basic b j required encode condition wpr Deﬁnition 47 Note χ b3 Although QBFs 3 4 look similar belong class QBFs practice behave differently In 3 Σ Q type t extend t sigT1Q type ii check witnesses roles type types providing witnesses case repeat ii T2 place T1 QBF 4 complex start set 1 2m1 Σ Q types single type More importantly T2witnesses choose types notarbitrary Σ restrictions coincide original 1 2m1 Σ Q types This condition represented formula 2m2 1 2m1many occurrences χ b3 b j makes QBF 4 computationally costly practice 92 Experiments Σ entailment To evaluate performance QBF solvers checking Σ concept Σ query entailment extension N DLLite bool approximation standard Department ontology cf httpswatcselehigheduprojectslubm The ontology details experiments available httpwwwdcsbbkacukromanqbf The reader appreciate complexity problems QBF solvers facing trying check hand following ontology T1 tiny Department ontology Σ concept Σ query entails ontology T2 T1 Visiting cid8 cid2 2 writes Σ teaches ResearchStaff cid5 Visiting cid8 teaches cid8 Academic cid7 ResearchStaff ResearchStaff cid8 worksIn Project cid8 manages Academic cid8 teaches cid5 cid2 2 teaches writes cid8 Academic cid7 ResearchStaff worksIn manages cid8 Academic cid7 Visiting cid8 Project As benchmarks considered series instances form T1 T2 Σ T1 T2 subsets Department ontology In NNseries T1 Σ concept entails T2 YNseries T1 Σ concept Σ query entails T2 YYseries T1 Σ query entails T2 The sizes instances uniformly distributed intervals given table Series NN YN YY Number instances 840 504 624 Number concept inclusions T1 T2 59308 56302 43178 74396 77382 43222 Number basic concepts T1 T2 47250 44246 40158 49300 58298 40188 Σ 5103 689 564 The table illustrates sizes QBF translations instances Σ concept Σ query entailment Series NN YN YY Σconcept entailment QBF Σquery entailment QBF Number variables Number clauses Number variables Number clauses 146948631 146046873 100616033 239174621 235271177 142023363 171560499 175559397 120220513 57631217151 70061122361 2963204889 Note large difference sizes QBF translations Σ concept Σ query entailment 74621 vs 1217151 clauses instance reﬂects difference QBFs 3 4 discussed Although worstcase complexity practice Σ concept entailment turns easier check Σ query entailment Fig 3 graphs left right column percentage solved instances Σ concept respectively Σ query entailment 1124 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Fig 3 Percentage solved Σ entailments given timeout We experimented standard QBF solvers Skolemisationbased sKizzo 58 searchbased 2clsQ 59 yQuaf ﬂe 6061 QuBE 62 The tests conducted 3 GHz P4 machine 2 GB RAM It turned solvers better instances example QuBE performed stronger sKizzo NN YN series outperformed sKizzo harder YY series Moreover solvers cope singlehandedly tests solver successful runtime unpredictable range seconds hours To select best QBF solver given instance employed selfadaptive multiengine aqme 28 tool capable learning choosing QBF engine chances solve given input As yQuaﬄe outperformed solvers excluded experiments An important property R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1125 aqme update learned policies usage scenario changes substantially adaptation schema called retraining Prior experiments aqme computed selection syntactic features characterising particular problems question pool suitable QBF instances A typical run aqme follows First leverages inductive model built 1nearest neighbour predict best engine given input QBF If engine solves QBF aqme terminates returns answer Otherwise starts selfadaptive mechanism It calls different engine solve input formula If successful retraining procedure called inductive model updated Which engine called retraining CPU time granted engine critical points aqmes performance As follows Fig 3 aqme managed select best solver cases absolutely crucial module extraction experiments 93 Practical module extraction We extracted minimal modules DLLite N bool encodings realworld commercial software applications called Core Umbrella The Core ontology based supplychain management bookstore chain Ot takars rebranded Waterstones It contains 1283 concept inclusions 83 concept names 77 role names features numerous functionality constraints covering disjointness constraints concepts form cid2 q R q 2 The Umbrella ontology based specialised research data validation processing Intensive Care National Audit Research Centre httpwwwicnarcorg It contains 1247 concept inclusions 79 cept names 60 role names Both ontologies representations relevant data structures constructed analysing data model database schema applicationlevel business logic The publisher ontology Example 73 Core We conducted experiments types minimal module extraction DLLite N bool TBox T signa ture Σ extract minimal Σ concept inseparability module MCM T minimal Σ query inseparability module MQM minimal depleting Σ query inseparability module MDQM T As seen extraction problems solved algorithms Theorems 67 72 QBF oracle deciding Σ concept Σ query inseparability relations Unfortunately naïve implementation MDQM extraction algorithm turns hopelessly ineﬃcient typical realworld examples ontology thousand concept inclusions algorithm oracle 500 thousand times To reduce number calls modiﬁed algo rithm Theorem 72 making choose group concept inclusions α1 αk single concept inclusion α time W α1 αk Σ sigMquery inseparable set αi moved M subset α1 αk considered instead In practice optimisation reduced number calls thousand ontology thousand axioms On hand reduce size original ontology preprocessed means tractable syntactic localitybased algorithm 1 extracting socalled cid4module cid4M necessarily minimal module respect Σ model inseparability relation contains minimal modules interested In fact following inclusions MCM MQM MDQM cid4M ﬁrst read MQM contains MCM second MQM contained MDQM MDQM contained cid4M Thus use inclusions computing modules right left Modules Σ 1 Our ﬁrst experiment extract minimal modules types singleton sig natures compare relative sizes modules For instance extracted MCM MQM MDQM Core Σ Publisher given Example 73 contain 0 3 20 concept inclusions respectively correspond ing cid4M 228 concept inclusions Fig 4 summarises results experiments average module terms number concept inclusions modules It contains average sizes segments extracted Fig 4 Average module size standard deviation singleton signatures 1126 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Table 2 Extraction time distribution calls MDQM extracted cid4M ontology Extraction time Total aqme calls sKizzo 2clsQ QuBE Core cid4M 126 s 385 14 2 84 Full 2233 s 565 76 17 7 Umbrella cid4M 60 s 254 4 1 95 Full 2488 s 463 74 14 12 approaches SR 16 Prompt 15 Econn 17 Since approaches support role names initial signature extracted modules concept names cases Furthermore SR Prompt logicbased general preserve entailments The Publishersegments SR Prompt Econn contain 19 189 349 cept inclusions respectively Interestingly segments extracted Prompt signiﬁcantly larger modules extracted logicbased approach Fig 5 On hand segments extracted SR smaller MDQMs properties segments unclear Finally modules extracted Econn behave differently MDQMs Core typically larger MDQMs Umbrella slightly smaller MDQMs Further experiments required satisfactory explanation phenomenon Our second experiment extract MDQMs Core Umbrella ontologies corresponding precomputed cid4Ms Table 2 compares average extraction time distribution QBF engine calls sce narios The distribution calls QBF engines changes notably MDQMs extracted ontology cid4Ms case majority calls issued sKizzo QuBE handles calls case This complies observation general QuBE tends solve easier instances quickly sKizzo performs successfully harder instances We extracted MCMs MQMs respective MDQMs average extraction time 271 s 233 s respectively Core 225 s 144 s Umbrella Modules Σ 10 Then ontologies randomly generated 30 signatures 10 concept names extracted modules MCMs MQMs extracted MDQMs turn extracted cid4Ms The average sizes standard deviation shown Fig 5 We extracted MCMs MDQMs average runtime 30 minutes MDQMs 90 s MCMs It noted able extract 23 10 MQMs Umbrella Core respectively runtime certain instances unfeasible One reasons growth QBF instances generated algorithm needs test query inseparability module candidates original ontology In case MDQMs candidates complement needs compared TBox eﬃciently The case MQMs involves comparisons similar TBoxes leads generation QBF instances quadratic number roles involved opposed linear MCMs Section 91 At time preparing paper publication aware new QBF solver DepQBF 63 outper forms searchbased solvers QuBE 2clsQ QBF instances 64 With DepQBF sKizzo main engines aqme improved performance MQM extraction algorithm managed extract number new modules Fig 5 Average module size standard deviation Σ 10 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1127 10 Conclusion We introduced analysed framework signaturebased notions difference entailment inseparability N ontologies description logics DLLite horn These notions compare versions ontology check importing ontology possibly unwanted sideeffects study deﬁne reﬁnements given ontology We demonstrated Σ inseparability framework module extraction forgetting Finally presented promising experimental results QBF solvers decide Σ inseparability extract minimal modules N bool DLLite Many open problems remain Here mention Approximating Σ difference In paper focused deciding Σ entailment application module ex traction However equal importance investigate exponential Σ difference ontologies approximated practice Any approximation provide developers users tologies suﬃcient information decide different versions ontologies reconciled differences relevant certain application Complexity Σ model entailment It interesting establish precise computational complexity Σ model N bool TBoxes corresponding entailment understand practical applicability We conjecture DLLite UML class diagrams ER models practice typically small counterexamples Σ model entailment exist discovering computing feasible Forgetting uniform interpolation strong query inseparability DLLite It interesting investigate forgetting uniform interpolation N bool necessary extend expressive N power DLLite horn able express uniform interpolants We conjecture universal role employed deﬁne suitable extensions We need experiments showing size uniform inter polants realworld ontologies So far experimental results available EL 26 N horn Similarly DLLite Σ entailment module extraction DLLite logics In paper considered wider class DLLite logics 11 In context OWL 2 QL eﬃcient query answering consider socalled core variants DLLite concept inclusion form B 1 cid8 B2 B1 cid5 B2 cid8 B N basic concepts We believe Σ entailment DLLite core tractable uniform interpolants polynomial size Another important construct OWL 2 QL role inclusions To investigate impact Σ entailment interesting open problem Axiomatic characterisation Σ entailment inseparability In Section 7 developed rudiments ax iomatic approach understanding inseparability We introduced properties inseparability relations monotonicity robustness properties seen related modularity known metaproperties logics interpolation property Robinson joint consistency property However fullﬂedged axiomatic approach introduce additional abstract properties inseparability relations establish representation theorems relating abstract properties query languages induce insepara bility relations having Finer complexity analysis It provide ﬁner analysis complexity checking Σ entailment separating inﬂuence T1 T2 complexity deciding T1 Σ entails T2 As ﬁrst step ﬁx T1 T2 analyse complexity Σ entailment varying T2 respectively T1 In context ALC results type obtained 24 Another interesting parameter difference T2 T1 T1 T2 T1 T2 In applications set small compared sizes T1 T2 helpful understand inﬂuence complexity deciding Σ entailment Acknowledgements We thank Marco Benedetti Florian Lonsing Luca Pulina Uli Sattler Thomas Schneider Petra Selmer help conducting experiments described Section 9 We thank anonymous referees paper helpful suggestions improvement ﬁrst draft Appendix A Here provide omitted proofs statements previous sections We begin establishing number basic results required proofs A1 Preliminaries The aim section introduce Lemma 87 operation allows amalgamate interpretations truthpreserving way We need simple deﬁnitions Given signature Σ interpretations I J Σ isomorphic write I Σ J bijection concept A object x A f f cid5I cid5J f x A I J J I 1128 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Σ x y P distinguished Σ TBoxes Σ ABoxes Σ queries f x f y P J I Given family interpretations Ii I 0 I deﬁne interpretation role P Σ Clearly Σ isomorphic interpretations J cid26 iI Ii Ii concept cid5J w I w cid5Ii Ii role P J called disjoint union Ii A P The disjoint union ω copies4 interpretation I disjoint union family Ii ω Ii I denoted Iω J w 1 w 2 I w 1 w 2 P I0 object A J w I w A J 0 Iω cid26 iω Ii It clear Σ TBoxes Σ ABoxes Σ queries languages signature Σ distinguish I Iω The following lemma provides important modeltheoretic property DLLite tablish modeltheoretic characterisations notions Σ entailment N bool frequently es Lemma 87 Let T1 T2 TBoxes DLLite types Then countable model I1 T1 precisely realising Ξ signature Σ cid18 model I N bool Σ signature let Ξ T1 T2precisely realisable set Σ Q T1T2 Σ cid18 sigT2 Σ T2 I Σ cid18 Iω 1 ii I precisely realises Ξ In particular sigT1 Σ cid18 I model T1 T2 Proof Let I2 countable model T2 precisely realising Ξ As Iω 2 cid5Iω Ξ countably inﬁnite number points bijection f cid5Iω Iω 1 basic Σ Q T1T2 concepts Deﬁne I types means x B cid5Iω 1a cid14 1 object names 1 Iω 2 realise Σ Q T1T2 type 1 invariant Σ Q T1T2 taking cid5I f x B I f 2 Iω 2 Iω cid14 I A x f x A A Iω 2 Iω 1 A Σ Σ cid18 I P x y f x f y P P Iω 2 Iω 1 P Σ Σ cid18 concept names A role names P By deﬁnition I ΣΣ cid18 Iω 1 Therefore I Σ cid18 Iω Observe point x cid5I Σ Q T1T2 types basic Σ Q T1T2 concept B x B basic sigT2 ΣQ T1T2 concept B B Iω 2 deﬁnition Therefore I cid15 T2 sigT2Q T1T2 type Iω Iω 2 2 I 1 I Indeed f precisely realises Ξ invariant f x B Iω 1 x B I And Finally sigT1 Σ cid18 I Σ cid18 Iω I B 1 I cid15 T1 cid2 I Next establish analogue Lemma 87 TBoxes DLLite N horn subprecise realisability Given signature Σ I object interpretations I J map h cid5I cid5J J x A implies hx A N role P Σ x y cid5I horn positive existential formulas Σ homomorphism I J I cid15 qa implies J cid15 qa Σ query qx DLLite J ha called Σ homomorphism I x y P A Σ homomorphism surjective Queries DLLite concept A Σ x cid5I implies hx h y P J N horn tuple Lemma 88 Let T1 T2 TBoxes DLLite subprecisely T2realisable Then countable model I1 T1 precisely realising Ξ signature Σ cid18 Σ cid18 sigT2 Σ exist model I T2 realising types Ξ Σ cid18 I N horn Σ signature let Ξ set precisely T1realisable Σ Q T1T2 types I1 In particular homomorphism I subprecisely realises Ξ 4 As usual set theory identify ordinal ω set natural numbers R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1129 Proof Let I2 countable model T2 subprecisely realising Ξ Without loss generality assume interpretations symbols sigT2 We construct sequence pairs cid5i hi ω cid5i cid5Iω 2 hi cid5i cid5I1 Σ homomorphism cid5i Iω cid27 2 I1 cid5i cid5i1 ω cid5i cid5Iω 2 iω To start choose cid50 cid5Iω Σ Q T1T2 type realised Iω Iω Assume ordering cid5Iω 2 2 bijection h0 cid50 cid5I1 way h0 invariant Σ Q T1T2 types 2 cid50 Such bijection exists 2 realised countably inﬁnitely points cid5Iω 2 realises Σ Q T1T2 type Ξ countably inﬁnitely times construct cid5k1 hk1 apply following rules x cid5Iω y cid5Iω 2 y x isomorphic ω suppose cid5k hk constructed To 2 provided applicable If x cid5k Σ Q T1T2 type x Iω 2 contains cid2 q R R 2 cid5k Σ Q T1T2 type point z cid5I1 hkx z R Iω 2 cid5k cid5k fewer q pairs x xi pick I1 2 positively contained Σ Q T1T2 type hkx I1 Then set cid5k1 cid5k y point y cid5Iω Σ Q T1T2 type x Iω hk1 hk y z If x cid5Iω 2 cid5k select z cid5I1 Σ Q T1T2 type x Iω z I1 Set cid5k1 cid5k x hk1 hk x z 2 positively contained Σ Q T1T2 type cid13 Let h cid14 iω hi Deﬁne interpretation I taking cid5I cid5Iω 2 I h 1 0 I1 object names A Iω 2 I1 I x hx A A A Σ Σ cid18 concept names A role names P Clearly function h Σ Σ cid18 I1 recall I2 interpretations symbols Σ cid18 sigT2 sigT2Q T1T2 type x I Iω P Σ Σ cid18 homomorphism I x y hx h y P P model T2 cid2 I I1 Iω 2 P 2 Hence I cid14 Theorem 76 Let L DLLite Σ L constructed effectively N bool DLLite N horn Then L uniform interpolation uniform interpolant TBox T respect cid3 N bool Σ signature Let TΣ set concept inclusions Proof Let T TBox DLLite Ct C cid8 t N Σ Q T type T realisable We TΣ uniform interpolant T respect Σ DLLite bool Clearly TΣ cid15 C cid8 D implies T cid15 C cid8 D concept inclusions C cid8 D Conversely assume TΣ cid11cid15 C cid8 D sigC cid8 D Σ cid18 Σ cid18 sigT Σ Let I1 model TΣ I1 cid11cid15 C cid8 D By Löwenheim Skolem closure disjoint unions assume I1 countable realises set Ξ TΣ realisable Σ Q T types By deﬁnition TΣ Ξ coincides set T realisable Σ Q T types Thus Ξ T TΣ precisely realisable So Lemma 87 model I Σ cid18 Iω 1 T It follows I cid11cid15 C cid8 D Thus T cid11cid15 C cid8 D required signature Σ cid18 horn TBox Deﬁne T cid18 Assume T DLLite N T t Σ Q T type T realisable B 0 t t T respect Σ To end T cid18 Ct C cid8 equivalently inclusions form enjoy disjunction property exists B 0 t t obtain T cid18 Ct C cid8 required cid2 Σ Bt B cid8 B0 follow Σ set concept inclusions We T cid18 Σ uniform interpolant Σ implies concept inclusion TΣ Indeed TΣ consists concept Btt B Take concept inclusion As Horn KBs Σ Bt B cid8 TΣ cid15 Bt B cid8 B0 Thus Bt B cid8 B0 T cid18 cid3 cid3 cid3 cid3 cid3 cid3 cid15 cid3 A2 Proofs results Section 4 Now use technique developed previous section order prove claims Section 4 Throughout section use fact type realised realised countable model similarly set types precisely realisable precisely realisable countable model Theorem 20 The following conditions equivalent TBoxes T1 T2 DLLite N bool signature Σ ceb T1 Σ concept entails T2 DLLite r T1realisable Σ Q T1T2 type T2realisable N bool 1130 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 cid3 Proof ceb r Suppose t T1realisable Σ Q T1T2 type T2realisable Then T2 cid15 T1 cid11cid15 Ct C cid8 contrary T2 Σ concept entailed T1 Ct C cid8 cid3 r ceb Suppose ceb hold Using Theorem 76 proof construct uniform interpolant N bool As T2 T2Σ Σ concept insep T2Σ T2 respect Σ consists Σ Q T2 concept inclusions DLLite N arable ﬁnd C1 cid8 C2 T2Σ T1 cid11cid15 C1 cid8 C2 And C1 cid8 C2 Σ Q T2 concept inclusion DLLite bool ﬁnd T1realisable Σ Q T1T2 type T2realisable Indeed let I model T1 point x x C1 cid5 C2I Then Σ Q T1T2 type realised x I T2realisable cid2 Theorem 21 The following conditions equivalent TBoxes T1 T2 DLLite N bool signature Σ sceb T1 strongly Σ concept entails T2 DLLite qeb T1 Σ query entails T2 DLLite sqeb T1 strongly Σ query entails T2 DLLite pr precisely T1realisable set Σ Q T1T2 types precisely T2realisable N bool N bool N bool Proof The implication sqeb qeb immediate deﬁnitions sqeb sceb proved similar Proposi tion 15i pr sqeb Suppose Σ TBox T Σ ABox A Σ query qa DLLite N bool T2 T A cid15 qa T1 T A cid11cid15 qa Take model I1 T1 T A I1 cid11cid15 qa let Ξ set Σ Q T1T2 types realised I1 By pr Ξ precisely T2realisable Then Lemma 87 exists model I T2 I Σ Iω 1 I cid15 T A I cid11cid15 qa contrary T2 T A cid15 qa qeb pr Let Ξ set Σ Q T1T2 types realised model I T1 let AΞ Cat C t t Ξ fresh object t Ξ It follows I cid15 T1 AΞ Suppose Ξ precisely T2realisable Then cases possible 1 If model Icid18 T2 t Ξ realised Icid18 Icid18 cid11cid15 AΞ consider query q T2 AΞ cid15 q T1 AΞ cid11cid15 q contradiction 2 Otherwise model T2 realise Σ Q T1T2 type Ξ Let Θ set T2realisable Ct Cx Then T2 AΞ cid15 q Σ Q T1T2 types Ξ As Θ cid11 q x I cid11cid15 q T1 AΞ cid11cid15 q contradiction tΘ cid29 cid28 sceb pr Let Ξ set precisely T1realisable Σ Q T1T2 types let TΞ cid4 cid8 t Ξ T1 TΞ cid11cid15 cid3 realising t Σ Q T1T2 types realised Ξ Clearly types Ξ cid2 Ct C cid8 Therefore sceb T2 TΞ cid11cid15 cid3 cid3 Ct C Then tΞ cid3 Ct C cid8 model It T2 TΞ cid30 It model T2 precisely realising tΞ Theorem 26 For TBoxes T1 T2 DLLite N horn signature Σ following conditions equivalent qeh T1 Σ query entails T2 DLLite spr precisely T1realisable set Σ Q T1T2 types subprecisely T2realisable N horn N Proof spr qeh Suppose Σ ABox A Σ query qa DLLite horn T2 A cid15 qa T1 A cid11cid15 qa Let I1 countable model T1 A I1 cid11cid15 qa let Ξ set Σ Q T1T2 types realised I1 By spr Ξ subprecisely T2realisable By Lemma 88 model I T2 Σ homomorphism I I1 But I cid15 A I cid11cid15 qa T2 A cid11cid15 qa contrary assumptions qeh spr Let Ξ set Σ Q T1T2 types realised model I T1 let AΞ Bat B t t Ξ fresh object t Ξ It follows I cid15 T1 AΞ Suppose Ξ subprecisely T2 realisable Then cases possible 1 If model Icid18 T2 t Ξ T1 AΞ cid11cid15 q T2 AΞ cid15 q contradiction cid3 Bt BIcid18 Icid18 cid11cid15 AΞ consider query q 2 Otherwise model Icid18 type Ξ Let Θ set Σ Q T1T2 types As Θ cid11 q x T2 AΞ cid15 q T1 AΞ cid11cid15 q contradiction T2 satisfying AΞ realise Σ Q T1T2 type positively contained Bt Bx Then tΘ cid29 cid28 This completes proof theorem cid2 The following modeltheoretic property TBoxes DLLite N horn standard Horn logic 10 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1131 Lemma 89 Let T TBox DLLite JT t realises t model I T realising t exists Σ homomorphism JT t I N horn t T realisable Σ Q type Then exists countable model JT t T In follows ﬁx model JT t mentioned formulation lemma minimal model T realising t Given realisable set Ξ Σ Q types let TBox TΞ contain Σ Q concept inclusions B1 cid5 cid5 Bk cid8 B N horn B t DLLite distinct Σ Q concepts B 1 Bk t Ξ B1 Bk t ii B t T realisability set Ξ terms T TΞ realisability t Ξ We TΞ TBox induced Ξ Note B1 cid5 cid5 Bk cid8 TΞ t Ξ cid4 cid8 B TΞ The following lemma establishes useful criterion deciding meetprecise B1 Bk t Lemma 90 Let Ξ set Σ Q types t Σ Q type Let Ξt t Ξ t t cid12 t t Ξt In particular Ξ meetprecisely T realisable TBox T DLLite t Then t TΞ realisable Ξt cid11 N horn type Ξ T TΞ realisable Bt B cid8 TΞ t TΞ realisable If Ξt cid11 B cid18 cid12 t Ξt t Proof If Ξt cid18 cid3 Bt B cid8 B TΞ B If model TΞ realising t TΞ cid15 Thus t cid3 cid18 cid18 cid18 t Bt cid8 B Bt B cid8 B t t TΞ cid15 t Ξt t Bt B cid8 TΞ Therefore B cid3 cid3 cid12 cid3 cid3 Btt B Theorem 24 B impossible cid2 cid18 t cid18 Lemma 91 Let Ξ T realisable set Σ Q types If Σ Q type t TΞ realisable t T realisable Proof By Lemma 90 t1 tk Ξ t suppose model T realising t As saw follows B B Now way proof Lemma 90 cid18 t t cid18 Bt cid8 B contradiction cid2 cid18 t 1 k But B T cid15 cid18 t cid3 t cid12 We position prove following criterion Theorem 27 For TBoxes T1 T2 DLLite N horn signature Σ following conditions equivalent sceh T1 strongly Σ concept entails T2 DLLite N sqeh T1 strongly Σ query entails T2 DLLite horn mpr precisely T1realisable set Σ Q T1T2 types meetprecisely T2realisable N horn Proof The implication sqeh sceh trivial mpr sqeh Suppose Σ TBox T Σ ABox A Σ query qa DLLite N horn T2 T A cid15 qa T1 T A cid11cid15 qa Let I model T1 T A I cid11cid15 qa let Ξ set Σ Q T1T2 types realised I Since I cid15 TΞ type Ξ TΞ realisable Let Ξ set TΞ realisable Σ Q T1T2 types Consider cid26 J I JTΞ t tΞ As Ξ T1 T realisable Lemma 91 TΞ realisable type T1 T realisable Lemma 89 J cid15 T1 T Clearly J cid15 A Σ homomorphism J I J cid11cid15 qa Also observe J precisely realises Ξ J realises type Ξ conversely Σ Q T1T2 type realised J TΞ realisable T2 realising types Ξ By mpr Lemma 90 exists model Icid18 Σ Q T1T2 type realised Icid18 TΞ realisable Lemma 91 TΞ realisable type t TΞ realisable t Ξ T2 I Σ J ω It follows I model T2 T A I cid11cid15 qa contradiction We apply Lemma 87 J Ξ TΞ realisable In fact Icid18 realises precisely set Ξ ﬁnd model I sceh mpr Let Ξ set precisely T1realisable Σ Q T1T2 types Then T1 TΞ cid11cid15 Btt B sceh T2 TΞ cid11cid15 t Ξ Therefore t Ξ B As intersection models Horn KB model KB obtain T2 TΞ cid11cid15 Bt B cid8 B Bt B cid8 cid3 cid3 Btt B t T2 TΞ realisable t Ξ Take disjoint union J models It T2 TΞ realising t t Ξ Clearly J realises types Ξ Σ Q T1T2 type realised J T2 TΞ realisable Therefore Lemma 90 Ξ meetprecisely T2realisable cid2 T1 TΞ cid11cid15 Ξ Bt B cid8 B Bt B cid8 cid18 t t cid3 cid3 cid3 cid3 cid18 cid18 1132 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 A3 Proofs results Section 5 Theorem 33 All entailment relations Section 3 robust vocabulary extensions DLLite N bool DLLite N horn Proof We different notions Σ entailment Σ concept entailment DLLite N bool This case follows uniform interpolation DLLite rem 76 Suppose T1 Σ concept entails T2 sigT2 Σ cid18 Σ T2 cid15 C1 cid8 C2 sigC1 cid8 C2 Σ cid18 T1 cid15 C1 cid8 C2 Let T2Σ uniform interpolant T2 respect Σ DLLite T2Σ cid15 C1 cid8 C2 deﬁnition uniform interpolants Hence T1 cid15 C1 cid8 C2 required b Σ concept entailment DLLite N horn This case follows uniform interpolation DLLite N bool proved Theo We N bool Then T1 cid15 T2Σ N horn way 1 Therefore I precisely realises Ξ N c Σ query entailment DLLite Suppose T1 Σ query entails T2 Σ cid18 Assume model I1 T1 precisely realising set Ξ Σ cid18 T1precisely realisable precisely T2realisable By Lemma 87 obtain model I I Σ cid18 Iω N bool equivalently strong Σ concept entailment strong Σ query entailment signature sigT2 Σ cid18 Σ We use criterion Theorem 21 Q T1T2 types Let Ξcid4Σ tcid4Σ t Ξ As Ξcid4Σ T2 d Σ query entailment DLLite signature sigT2 Σ cid18 Σ We use criterion Theorem 26 Assume model T1 precisely realising set Ξ Σ cid18 Q T1T2 types Let Ξcid4Σ tcid4Σ t Ξ As Ξcid4Σ T1precisely realisable model I1 subprecisely T2realisable By Lemma 88 obtain model I I1 Therefore I subprecisely realises Ξ horn Suppose T1 Σ query entails T2 Σ cid18 T2 realising types Ξ Σ cid18 homomorphism I e Strong Σ query entailment DLLite Q T1T2 types precisely T1realisable Consider set Ξ N horn equivalently strong Σ concept entailment Suppose T1 strongly signature sigT2 Σ cid18 Σ We use criterion Theorem 27 Assume Σ concept entails T2 Σ cid18 set Ξ Σ cid18 Q T1T2 types constructed way proof Theorem 27 mpr sceh It precisely realised model J Let Ξ cid4Σ tcid4Σ t Ξ As Ξ cid4Σ precisely T1realisable J exists model I2 T2 meetprecisely realising Ξ cid4Σ By Lemma 90 type Ξ cid4Σ T2 TΞ cid2Σ realisable Lemma 91 TΞcid2Σ realisable Thus J I2 precisely realise set Ξcid4Σ Σ Q T1T2 types By Lemma 87 obtain model I T2 I Σ cid18 J ω precisely realising Ξ Σ cid18 Q T1T2 type Ξ T2 TΞ realisable Lemma 90 Ξ meetprecisely T2realisable TΞ realisable Σ cid18 As Ξ Ξ f Σ model entailment Suppose T1 Σ model entails T2 Σ cid18 signature sigT2 Σ cid18 Σ Let I T2 coincides I Σ As sigT2 Σ cid18 Σ actually assume model copy valuation symbols Σ cid18 sigT2 I Hence T1 Σ cid18 model T1 Then exists model Icid18 Icid18 coincides I Σ cid18 entails T2 cid2 Theorem 36 All inseparability relations Section 3 robust joins DLLite N bool DLLite N horn N N bool Suppose T Ti Σ concept inseparable DLLite bool 1 2 Proof Σ concept inseparability DLLite Consider T realisable Σ Q type t Q Q T T1T2 By Theorem 20 suﬃcient t T1 T2realisable Let Ξ set T realisable Σ Q types As T Ti Σ concept inseparable Ξ set Ti realisable Σ Q types 1 2 It follows Ξ precisely Ti realisable 1 2 Using Lemma 87 Σ cid18 sigT1 obtain model T1 T2 precisely realising Ξ This model realises t N b Σ concept inseparability DLLite horn This case follows Theorem 24 N bool equivalently strong Σ concept inseparability strong Σ query insepa c Σ query inseparability DLLite N rability Suppose T Ti Σ query inseparable DLLite bool 1 2 let Ξ precisely T realisable set Σ Q types Q Q T T1T2 By Theorem 21 suﬃcient Ξ precisely T1 T2realisable By Theorem 21 Ξ precisely Ti realisable 1 2 Using Lemma 87 obtain model T1 T2 precisely realising Ξ N N horn Suppose T Ti Σ query inseparable DLLite horn 1 2 let Ξ precisely T realisable set Σ Q types Q Q T T1T2 By Theorem 26 suﬃcient Ξ subprecisely T1 T2realisable As T Ti Σ query inseparable obtain set Ξ cid18 Ξ precisely T T1 T2realisable t Ξ cid18 positively contained type Ξ By Lemma 87 obtain model T1 T2 precisely realising Ξ cid18 But Ξ subprecisely T1 T2realisable d Σ query inseparability DLLite N horn equivalently strong Σ concept inseparability Suppose T Ti e Strong Σ query inseparability DLLite N horn 1 2 let Ξ precisely T realisable set Σ Q types strongly Σ query inseparable DLLite Q Q T T1T2 Let I model T precisely realising Ξ Consider set Ξ TΞ realisable Σ Q types proof Theorem 27 mpr sceh As follows proof set Ξ precisely Ti realisable 1 2 Hence Lemma 87 exists model T1 T2 precisely realising Ξ meetprecisely realising Ξ f Σ model inseparability Suppose T Ti Σ model inseparable sigT1 sigT2 Σ Let I model T Then models I1 I2 T1 T2 respectively coincide I Σ As sigT1 sigT2 Σ assume I1cid4sigT2Σ I2 Thus I1 model T1 T2 coinciding I Σ cid2 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1133 Theorem 40 If T1 Σ query entails equivalently strongly Σ concept entails T2 DLLite T2 SHIQ N bool T1 strongly Σ query entails Proof Suppose T1 T A cid11cid15 qa Take model J T1 T A J cid11cid15 qa By Lemma 87 ﬁnd model I model T T2 A I cid11cid15 qa Hence T2 T A cid11cid15 qa cid2 T2 I Σ J ω But I A4 Proofs results Section 6 Lemma 53 There algorithm given TBox T DLLite istic polynomial time Ξ precise subprecise meetprecise T witness constructs witness exists N horn set Ξ Σ Q types Q Q T decides determin N Proof First observe given TBox T DLLite horn Σ Q type t Q Q T clT t computed polynomial time extend t basic sigT Q concepts B B 1 cid5 cid5 Bk cid8 B T B computed extension t cid18 0 t In algorithms ﬁrst extend types Ξ sigT Q types check Let Ξ t cid18 k T realisable cf w1 w2 Deﬁnition 47 1 For 0 cid3 cid3 k compute t clT t answer Proposition 23 cid18 check t icid4Σ t cid18 t If case stop The types t0 tk form ﬁrst sequence sigT Q types T witness Ξ provided exists So remains construct second sequence actually ﬁnd required witnesses nonempty roles The algorithm iterative To start let t j t0 k j cid3 k 2m m number role names T note choice t0 arbitrary Also let set Ω0 processed roles Suppose step n Select role P T nonempty processed cf w3 P Ωn P P cid7 cid6 t j cid11 0 cid3 j cid3 k 2m If role exists terminate t0 tk tk1 tm2k required T witness Ξ Otherwise compute tk2i1 clT tP tk2i clT tP B Terminate answer tk2i1 tk2i types T realisable Proposition 23 w1 The step algorithm depends particular type witness t tk2i1 tk2i check t B sigT Q type t B cid18 2a tcid4Σ t cid4Σ t 2b t 2c Ξt cid11 t t cid18 cid18 Ξ need precise T witness t cid12 cid4Σ cid18 Ξ need subprecise T witness t Ξt Ξt t cid4Σ t Ξ t cid18 cid18 cid18 t need meetprecise T witness Terminate answer test fails Otherwise update types tk2i1 tk2i sequence computed ones set Ωn1 Ωn P Clearly algorithm runs polynomial time cid2 Next provide proofs Lemma 59 Theorems 60 61 For Lemma 59 construct BAPA formula ϕP qmax stating setsystem S solution For construction require addition notion solution S following notion left solution Let S A1 Aqmax A B1 Bqmax B setsystem A relation ρ called left solution S Aq set points ρoutdegree q 1 cid3 q cid3 qmax A set points ρoutdegree qmax point Bq ρindegree cid3 q 1 cid3 q cid3 qmax B set points ρindegree qmax Thus difference left solution solution points Bq necessarily ρindegree q ρindegree cid3 q First establish necessary suﬃcient conditions setsystem left solution special case Lemma 92 Let qmax ω S A1 Aqmax B1 Bqmax setsystem B If S solution qmaxcid31 qmaxcid31 q Aq q Bq 5 q1 Conversely cid2 qmax q1 q1 Aq cid2 q2 max cid2 qmax q1 Bq cid2 q2 max 5 implies S solution 1134 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 BL If S left solution qmaxcid31 q1 q Aq cid3 qmaxcid31 q1 q Bq 6 Conversely cid2 qmax q1 Aq cid2 q2 max cid2 qmax q1 Bq cid2 q2 max 6 implies S left solution Before come proof note B 5 imply S solution As example consider set A1 A2 B1 B2 A1 B1 A2 B2 Clearly 5 holds S solution The example shows BL 6 imply S left solution We come proof 7 8 qmax q1 Aq cid2 q2 Proof B A straightforward pigeonhole argument shows 5 holds S solution Now suppose 5 holds cid2 max If sums 5 inﬁnite Aq Bq inﬁnite cardinal qmax q1 Aq solution ρ readily constructed So concentrate case sums ﬁnite Let A qmax q1 Bq We ﬁrst exists map f A B N 1 cid3 q cid3 qmax B cid31 cid31 cid13 cid13 f d q Aq f d b q b Bq dB cid31 d A cid31 Assume map exist Take map f A B N 1 cid3 q cid3 qmax f d cid3 q Aq f d b cid3 q b Bq dB d A set maps nonempty 5 f x y 0 satisﬁes 8 cid2 x y AB f x y maximal By assumption cid31 x y AB f x y qmaxcid31 q1 q Aq qmaxcid31 q1 q Bq cid2 cid2 cid2 x y AB f cid2 dB f a1 d q1 cid18x y contrary f having maximal cid18x y f x y x y A B distinct b Then 8 holds f Thus exist q1 q2 Aq1 b Bq2 cid18a b f b 1 f f cid2 x y AB f x y We actually exists map 7 0 1 Suppose map exist Take map f x y1 f x y 1 minimal ﬁnd b f b 1 We max cid18 b 0 Indeed let C c f c 0 cid18 A D max As A cid2 q2 max exists cid18 b 0 Deﬁne new map f 0 coincides f 7 cid18 0 f cid18 b exists D d c C f d c 0 We C qmax D q2 7 exists b f cid4 b cid5 cid18 cid18 b cid4 cid18 b cid5 cid18 f 1 cid18 A B f d A f d b q2 Deﬁne f cid18 0 By construction setting cid18 x y AB f x y cid18 B f Aq cid2 q2 cid18 f cid18 0 1 1 f b f b qmax q1 cid4 cid4 cid18 b cid18 b b cid2 cid2 cid5 cid5 cid18 cid18 f 0 f 0 cid18 f 0a b f b 1 cid2 cid2 f 0 cid2 Then f 0 7 cid2 Bq cid2 q2 f 0x y1 f 0x y max considered analogously qmax q1 Let f A B 0 1 satisfy 7 Then relation ρ b A B f b 1 solution S BL proved way B cid2 f x y1 f x y contrary f x y1 f x y minimal The case Note existence left solution setsystem S depend sets cardinalities Thus equivalently represent setsystem S form S n1 nqmax n m1 mqmax m ni mi cardinal numbers In follows choose representation convenient purposes The following lemma prove Lemma 59 It covers possible combinations reduces problem S solution special cases mentioned Lemma 92 Lemma 93 Let qmax cid2 0 For setsystem S A1 Aqmax A B1 Bqmax B following holds C0 If A qmax B qmax S solution C1 If A qmax B cid3 qmax S solution following holds R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1135 B 0 Scid18 1 B 0 Scid18 2 A1 Aqmax A B1 Bqmax left solution AB1 Aqmax A B B1 Bqmax left solution C2 If A cid3 qmax B qmax S solution following holds B1 Bqmax B A1 Aqmax left solution B A1 Bqmax B A A 0 Scid18 1 A 0 Scid18 2 A1 Aqmax left solution C3 If A cid3 qmax B cid3 qmax S solution numbers nD q D B 1 cid3 q cid3 qmax cid2 mD DB nD q e B Scid18 n q D A 1 cid3 q cid3 qmax following holds cid2 Bq 1 cid3 q cid3 qmax D A mD q q qmax A e A nD cid18 0 solution 1 m DB eD 0 m cid18 qmax cid2 cid2 qmax q1 D A eD mD q qmax B nD q cid18 m k qmaxcid31 cid31 q1 D A qDk mD q 1 cid3 k cid3 qmax Aq cid2 cid2 qmax q1 cid18 cid18 1 n qmax qmaxcid31 cid31 q1 DB qDk cid18 n k cid13 Proof Let A qmax q1 Aq B qmax q1 Bq cid13 cid13 C0 A qmax B qmax For Aq set Ya B cardinality q A set Ya B cardinality qmax 1 Such sets exist B qmax Similarly b Bq set Xb A cardinality q b B set Xb A cardinality qmax 1 Such sets exist A qmax Then bBB Xb b clearly solution S relation ρ C1 A qmax B cid3 qmax Consider ﬁrst B 0 Let ρ solution S For A oρ qmax 1 remove oρ qmax 1many pairs b ρ denote resulting binary relation ρcid18 left solution Scid18 Then oρcid18 qmax 1 A ρcid18 1 left solution ρ For q cid3 qmax b Bq iρ b q q iρ bmany points A b ρ add pairs b ρ This possible A qmax Then resulting relation ρcid18 1 Conversely assume S cid18 A A Ya solution S cid13 The claim B 0 proved similarly C2 A cid3 qmax B qmax This mirror image C1 C3 A cid3 qmax B cid3 qmax Suppose S solution ρ Deﬁne A D q D B 1 cid3 q cid3 qmax B D q D A 1 cid3 q cid3 qmax taking cid8 cid4 cid8 b B cid8 cid8 A cid6 Aq cid6 b Bq A D q B D q cid4 b ρ b D b ρ D cid5cid7 cid5cid7 q points Aq ρrelated exactly points D B We numbers nD A D Thus A D q satisfy inequalities C3 S cid18 Aq follows B D mD q q fact Aq exactly set form A D q number points e ρ A This number greater qmax A iρ e qmax q considered way Consider restriction ρcid18 A points A e ρ The numbers mD cid18 k deﬁned C3 number points b B ρ A B Then number points A oρ k n cid18 cid18 k deﬁned C3 Thus ρcid18 iρ b k m 1 n solution n qmax For converse direction suppose numbers nD q satisfying conditions C3 Let ρ solution 0 We assume ρ solution A q Let e B Then solution The equality 0 required eDB nD cid18 1 m DB nD q B q mD 0 m 0m cid18 qmax qmax q1 cid2 cid2 cid2 q cid18 cid18 1 A cid18 qmax cid18 1 B cid18 qmax cid18 1 m cid18 qmax cid18 1 n n cid18 qmax A B cid18 k disjoint union sets cid21A D k disjoint union sets cid21B D k k cid18 A cardinality nD B cardinality mD q D B q D k q D A q D k cid18 cid2 cid2 cid2 k add ρ pairs d d D pairs d Now cid21A D k b cid21B D resulting relation ρ0 It follows cid2 Denote Aq number points oρ0 q Aq Similarly Bq obtain number points b iρ0 b q Bq For e B inequality cid18 A indegree q qmax A expand ρ0 suﬃciently pairs e qmax q qmax B q1 cid18 B outdegree e A qmax 1 The e B qmax 1 Similarly e A inequality cid18 e expand ρ0 suﬃciently pairs e e resulting relation ρ solution setsystem A1 Aqmax A B1 Bqmax B cid2 D A mD q eDB nD cid18 e e eD A mD DB nD q cid18 b d cid18 D qmax q1 cid2 cid2 cid18 1136 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 We position prove following Lemma 59 For role P number qmax cid2 1 construct BAPA formula ϕP qmax free variables X1P Xqmax P Xqmax P X1P Xqmax P Xqmax P BAPA model M following conditions equivalent 9 M cid15 ϕP qmax ii setsystem XM 1P XM qmax P XM qmax P XM 1P XM qmax P XM qmax P solution Proof The formula ϕP qmax deﬁned case distinction similar formulation Lemma 93 Namely deﬁne ϕP qmax conjunction formulas Xqmax P qmax Xqmax P qmax 0 0 Xqmax P qmax Xqmax P cid3 qmax ψ1 Xqmax P cid3 qmax Xqmax P qmax ψ2 Xqmax P cid3 qmax Xqmax P cid3 qmax ψ3 qmax q1 XM q P The ﬁrst conjunct corresponds C0 Lemma 93 stating solution exists cardinalities sets points outdegree respectively indegree qmax greater qmax To deﬁne formulas ψ1 ψ2 ψ3 note ﬁrst trivially construct BAPA formula ϕ0 satisfying conditions Lemma 59 models M cid2 Xq P M q2 max free variables 9 solutions exist Note formula exponential size qmax Now according B Lemma 92 deﬁne formula ψ B intended meaning 1P XM XM P qmax max simply listing possible conﬁgurations cardinalities q2 1P XM XM solution max qmax P qmax P q2 qmax q1 cid4 cid2 cid4 cid5 cid5 taking cid23 qmaxcid31 q1 cid4 q Xq P cid5 cid4 q Xq P cid5 qmaxcid31 q1 cid24 cid23cid23 qmaxcid31 cid4 q1 Xq P q2 max qmaxcid31 cid4 cid5 q1 Xq P q2 max cid24 cid5 cid24 ϕ0 P qmax Similarly condition BL Lemma 92 deﬁne BAPA formula ψ B L stating setsystem XM 1P XM And Lemma 93 ψ1 ψ2 ψ3 constructed ψ B ψ B L appropriate renaming variables We qmax P left solution qmax P XM 1P XM leave tedious straightforward construction interested reader cid2 Theorem 60 Let Σ sigT1 Then T1 Σ model entails T2 ϕT1T2 valid Proof The proof indirect We T1 Σ model entail T2 ϕT1T2 valid The proof converse direction similar omitted Let I model T1 expanded model T2 Let A BAPA structure based cid5 cid5I We construct BAPA model M based A refuting ϕT1T2 M cid15 cid10 α cid10 αT se 1 P sigT1 ϕP qmax M cid15 Y cid10 α cid10 αT se 2 P sigT2 cid23 cid24 ϕP qmax I A To deﬁne M set XM A d cid5 exactly q points d canonical way R observe setsystem I X A X A concept XqR X deﬁne XM qR set The remaining values XM qmax R deﬁned It clear M cid15 α α T se To M cid15 ϕP qmax P sigT1 cid3qR XM d d cid18 R I cid18 cid4 1 P XM XM solution ρ P I qmax P XM qmax P 1 P XM XM qmax P XM qmax P cid5 cid4 cid5 Thus Lemma 59 M cid15 ϕP qmax cid29 α To second assume contrary claim exist values Y N Y Y N cid15 P sigT2 ϕP qmax N based A interprets symbols X X way M By Lemma 59 αT se 2 cid29 P sigT se cid4 P Σ exists solution ρP setsystem cid5 2 1 P X N X N 1 P X N X N qmax P X N qmax P X N qmax P qmax P cid4 cid5 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1137 We deﬁne interpretation J coincides I symbols Σ A A sigT2 Σ P assumption model T2 exists cid2 A concept names J ρP role names P sigT2 Σ It diﬃcult J model T2 contrary J X N In remainder section proof Theorem 61 stating deciding Σ model entailment TBoxes N horn maximal numerical parameter qmax 3 coNExpTimehard The proof reduction model DLLite conservativity problem modal logic S5 Recall formulas propositional modal language ML constructed propositional variables p1 p2 Booleans modal possibility operator cid3 MLformulas K interpreted Kripke models form K cid5K p 1 p propositional variables pi The interpretation ϕK K modal formula ϕ K deﬁned inductively follows 2 cid5K nonempty set p cid5K K ψ K 2 1 ψ1 ψ2K ψ K ψK cid5K ψ K cid8 cid6 cid8 d d cid5K cid3ψK cid18 ψ K cid7 A global formula modal formula propositional variable scope cid3 Observe global formula ϕ model K ϕK cid5K We K model global formula ϕ ϕ true K ϕK cid5K A global formula ϕ2 said ﬁnite model conservative extension global formula ϕ1 ﬁnite model variables pi ϕ1 The following result ϕ2 cid5K cid5Kcid18 p p K Kcid18 K ϕ1 exists model Kcid18 proved 555 Theorem 94 For global modal formulas ϕ1 ϕ2 ϕ2 model conservative extension ϕ1 ϕ2 ﬁnite model conservative extension ϕ1 ii It NExpTimehard decide global formula ϕ2 ﬁnite modelconservative extension global formula ϕ1 We ﬁrst present reduction model conservativity S5 Σ model entailment DLLite modify reduction obtain reduction ﬁnite modelconservativity S5 Σ model entailment DLLite TBoxes Fix global modal formulas ϕ1 ϕ2 Denote sϕi set formulas ψ ψ ψ subformula ϕi For ψ sϕi concept Aψ additionally cid3ψ sϕi role names Scid2ψ Lcid2ψ Scid2ψ Let Dom Box fresh concept names The extensions Dom employed simulate domains S5models Thus interpretation ψ K N horn N bool TBoxes Then subformula ψ ϕi correspond Aψ cid5 DomI cid5I DLLite prefer allowing Dom proper subset cid5I N horn description logic interpretation I We work Dom necessary reduction We assemble TBox T1 ﬁrst encoding truthconditions obvious manner taking I Aψ cid5 Dom Aψ cid5 Dom cid5 Dom Aψ1ψ2 cid5 Aψ2 ψ sϕ1 10 Aψ1 11 To encode truth condition cid3 use Acid2ψ role names Scid2ψ Scid2ψ Lcid2ψ First state cid3ψ sϕ1 extensions Scid2ψ Acid2ψ negations coincide Dom cid5 Dom ψ1 ψ2 sϕ1 Dom cid5 Acid2ψ Dom cid5 Scid2ψ Dom cid5 Acid2ψ Dom cid5 Scid2ψ Next state Scid2ψ Scid2ψ cid3ψ sϕ1 binary relations Dom Box Scid2ψ cid8 Dom Scid2ψ cid8 Dom To ensure Box nonempty Dom nonempty ϕ1 occurrences cid3 cid8 Box cid8 Box S S cid2ψ cid2ψ Dom cid8 R0 R 0 cid8 Box 12 13 14 fresh role R0 Finally connect Aψ Acid2ψ Scid2ψ Scid2ψ Lcid2ψ stating cid3ψ sϕ1 Aψ cid5 Dom cid8 Scid2ψ Scid2ψ cid8 Lψ L ψ cid8 Dom cid5 Aψ S cid2ψ cid5 S cid2ψ cid8 15 5 Note result formulated explicitly 55 follows immediately proof 55 Theorem 4 stating conservativity problem coNExpTimehard large family normal modal logics including S5 1138 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 These inclusions enforce Acid2ψ cid5 Dom simulates cid3ψ models Box singleton set model I Scid2ψ I Scid2ψ I inclusion 15 condition range Scid2ψ Scid2ψ subset Box Thus Scid2ψ I cid11 12 10 Scid2ψ I Dom Using implication remaining inclusions 15 12 13 obtain Aψ cid5 DomI cid11 Scid2ψ I cid11 Scid2ψ I Dom required Finally ϕ1 true Acid2ψ cid5 DomI Dom I I I Dom cid8 Aϕ1 16 Thus T1 consists concept inclusions 1016 We construct T2 way taking concept inclusions ψ sϕ2 include Dom cid8 Aϕ2 corresponding 16 T2 Instead set inclusions forces satisﬁable Box include T2 following axioms stating singleton set To end consider fresh role names S0 S S cid18 S S reader cid18 cid18 functions Dom Box leave inclusions S cid2 2 S cid8 cid8 Box S S Dom We add axiom saying point range S S cid18 domain S0 S cid5 S cid18 cid8 S0 Finally encode ϕ2 true taking S 0 cid8 Dom cid5 Aϕ2 Lemma 95 ϕ2 model conservative extension ϕ1 T1 Σ model entails T2 Σ sigT1 17 18 19 Proof Suppose ϕ2 model conservative extension ϕ1 Take model K ϕ1 model Kcid18 ϕ2 having domain interpretations variables ϕ1 K case simply K expanded model ϕ2 Deﬁne interpretation I taking cid5I cid5K I d d cid5I I cid5I Dom Box b S I A ψ I cid2ψ I ψ I 0 c L d R ψ K ψ sϕ1 I cid3ψK d S cid2ψ I ψ K cid3ψ sϕ1 I I Box Dom Dom cid3ψK d cid3ψ sϕ1 I exists Then 1719 Box It readily checked I model T1 We expanded model T2 Assume expansion Icid18 K singleton set A Icid18 singleton set setting p p induction ψ Kcid18 A nonempty coincides domain Kcid18 contradiction variables p ϕ2 occur ϕ1 Using fact Box ψ ψ sϕ2 Hence ϕKcid18 Icid18 nonempty Deﬁne expansion Kcid18 Kcid18 A Conversely assume T1 Σ model entail T2 Let I witness modelie model T1 I cid11 14 We ﬁrst Box I expanded model T2 It readily checked Dom deﬁne extension I0 I taking singleton set Assume case Choose distinct d d I d I0 Dom Then I0 model 1719 independently interpretation S Aϕ2 It straightforward interpret remaining fresh symbols T2 way I0 model T2 contrary assumption I cid11 Hence Box I cid18 Box cid18 I0 Dom I d S cid18 S I0 0 Icid18 ϕ2 I 2 Now model K domain Dom I singleton set easily checked induction ψ sϕ1 K A Dom p I p I variables p ϕ1 Using fact Box I ψ K A I ψ Dom I Thus K model ϕ1 We exist expansion Kcid18 exists Deﬁne expansion Icid18 I setting A Deﬁne extensions Scid2ψ Scid2ψ Lψ bc Kcid18 I I Dom Box contradiction cid2 Icid18 0 function Box ψ Kcid18 let S Dom Icid18 ψ I I K model ϕ2 Assume Kcid18 I I Dom cid3ψ sϕ2 Let S Icid18 ϕ2 Icid18 ϕKcid18 Dom S functions model T2 cid18Icid18 It readily checked Icid18 new ψ sϕ2 Then A We modify reduction aim obtaining reduction DLLite lematic axiom 10 encoding negation To construct DLLite First state auxiliary role P domain exactly twice large Dom N horn TBox T cid18 N horn Observe prob 1 1116 replace 10 follows cid2 3 P cid8 Dom cid2 2 P P cid8 Dom cid2 2 P cid8 cid4 cid8 P 20 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1139 We state Aψ Aψ disjoint ψ sϕ1 Aψ cid5 Aψ cid8 21 Finally add Dom Aψ cardinality ψ sϕ1 To end use fresh role P ψ P ψ bijection Dom Aψ Aψ P ψ cid2 2 P ψ cid8 cid2 2 P ψ cid8 22 Dom P ψ N horn TBox T cid18 The DLLite 1 consists concept inclusions 1116 2022 Lemma 96 If I ﬁnite model T cid18 1 ψ sϕ1 Aψ cid5 DomI Aψ cid5 DomI Proof By 21 A cid5I Dom I I ψ A cardinality cid5I I ψ disjoint Thus suﬃcient A I ψ ﬁnite simple pigeonhole argument shows A In fact A A I Dom A I ψ I ψ A I ψ I I ψ Dom cid5I cid2 I ψ Note Lemma 96 hold inﬁnite models To construct T cid18 lated ψ sϕ2 16 We add axioms 17 18 deﬁnition T2 For T cid18 add 19 ensure Box 19 axioms saying fresh role Z injective function cid5I 1 formu 2 suﬃcient singleton set I ﬁnite To end replace 2 concept inclusions T cid18 cid5I I cid4 cid8 Z cid2 2 Z cid8 cid2 2 Z cid8 23 following concept inclusion stating point range Z range S 0 Dom cid5 Aϕ2 0 cid8 Dom cid5 Aϕ2 cid5 Z 24 S To understand purpose axioms recall set cid5I ﬁnite exist injective function cid5I surjective Thus interpretation I inﬁnite expand model Icid18 23 24 choosing injective nonsurjective function Z range disjoint range S0 choose S0 having point range On hand I ﬁnite 23 24 enforce way 19 Dom cid5 Aϕ2 nonempty Box singleton set cid5I The following lemma proved observation combining proof Lemma 95 Lemma 96 Lemma 97 ϕ2 ﬁnite model conservative extension ϕ1 T cid18 1 Σ model entails T cid18 2 Σ sigT cid18 1 Remark 98 It worth mentioning TBox T cid18 DLLite 1 constructed ﬁnite model reasoning N horn nontractable contrast results 45 showing logics DLLite family ﬁnite model 1 propositional formula ϕ1ie assume modal cid5 Dom satisﬁable ﬁnite model N horn TBox NPhard reasoning tractable Indeed consider DLLite operator cid3 occur ϕ1 Then ϕ1 satisﬁable concept Aϕ1 N T cid18 horn concept satisﬁable ﬁnite model DLLite 1 Thus problem DLLite horn TBox T cid18 N A5 Proofs results Section 8 Here prove Theorems 81 82 Theorem 81 Let T T cid18 Σ DLLiteu TBoxes DLLite bool Then T Σ query entails T cid18 N bool Σ signature And let T cid18 Σ uniform query interpolant T cid18 T cid15 C1 cid8 C2 C1 cid8 C2 T cid18 Σ respect Proof Suppose T Σ query entails T cid18 Σ Let I model T I cid11cid15 cid21 Let Q set numerical parameters T T cid18 cid21 Ξ set Σ Q types realised I Then Ξ T precisely realisable Hence Theorem 21 Ξ T cid18 precisely realising Ξ Then Icid18 cid11cid15 cid21 I Icid18 realise Σ Q types It follows T cid18 cid11cid15 cid21 cid21 T cid18 T cid11cid15 cid21 cid21 T cid18 precisely realisable Let Icid18 model T cid18 Σ contradiction By Theorem 21 exists set Ξ Σ Q T T cid18 types Conversely suppose T Σ query entail T cid18 realisable Let precisely T realisable precisely T cid18 cid9 D UC T cid11cid15 cid21 cid2 U cid3tΞ cid3Ct cid18 UC cid18 cid11 cid9 C cid5 U cid11 C tΞ cid3Ct Then T cid11cid15 D cid8 T cid18 cid15 D cid8 It follows T cid18 Σ cid15 D cid8 So exists cid21 T cid18 Σ 1140 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 Theorem 82 For TBox T DLLite respect Σ DLLiteu bool N bool signature Σ construct uniform query interpolant TΣ T Proof Let T TBox DLLite containing concept inclusions form concept inclusions form cid3 N bool Σ signature Let m number role names T Deﬁne TΣ set Ct C cid8 t Σ Q T type T realisable cid9 cid11 Ct C cid8 cid3 Ξ Ω cid3tcid18Ξ U C cid3Ctcid18 t T realisable Σ Q T type Ω set sets Ξ Σ Q T types Ξ cid3 2m 1 t Ξ precisely T realisable It follows TΣ constructed exponential time size T It remains TΣ uniform query interpolant Clearly T cid15 cid21 cid21 TΣ For converse direction suﬃcient precisely TΣ realisable set Σ Q T types precisely T realisable Let Ξ0 set By complexity analysis N bool Section 62 t Ξ0 exists Ξt Ξ0 t Ξt T precisely Σ query entailment DLLite realisable Take disjoint union models T realising t Ξt t Ξ0 It readily seen model T precisely realising Ξ0 cid2 References 1 B Cuenca Grau I Horrocks Y Kazakov U Sattler Modular reuse ontologies Theory practice J Artiﬁcial Intelligence Research 31 2008 273318 2 F Baader D Calvanese D McGuinness D Nardi PF PatelSchneider Eds The Description Logic Handbook Theory Implementation Applications Cambridge University Press 2003 3 N Noy M Musen Promptdiff A ﬁxedpoint algorithm comparing ontology versions Proc 18th Nat Conf Artiﬁcial Intelligence AAAI 2002 2002 pp 744750 4 B Cuenca Grau I Horrocks Y Kazakov U Sattler A logical framework modularity ontologies Proc 20th Int Joint Conf Artiﬁcial Intelligence IJCAI 2007 2007 pp 298303 5 D Calvanese G De Giacomo D Lembo M Lenzerini R Rosati DLLite Tractable description logics ontologies Proc 20th Nat Conf Artiﬁcial Intelligence AAAI 2005 2005 pp 602607 6 D Calvanese G De Giacomo D Lembo M Lenzerini R Rosati Data complexity query answering description logics Proc 10th Int Conf Principles Knowledge Representation Reasoning KR 2006 2006 pp 260270 7 D Calvanese G De Giacomo D Lembo M Lenzerini R Rosati Tractable reasoning eﬃcient query answering description logics The DLLite family J Automated Reasoning 39 3 2007 385429 8 A Poggi D Lembo D Calvanese G De Giacomo M Lenzerini R Rosati Linking data ontologies J Data Semantics X 2008 133173 9 A Artale D Calvanese R Kontchakov V Ryzhikov M Zakharyaschev Reasoning extended ER models Proc 26th Int Conf Conceptual Modeling ER 2007 Lecture Notes Computer Science vol 4801 Springer 2007 pp 277292 10 A Artale D Calvanese R Kontchakov M Zakharyaschev DLLite light ﬁrstorder logic Proc 22nd Nat Conf Artiﬁcial Intelligence AAAI 2007 2007 pp 361366 11 A Artale D Calvanese R Kontchakov M Zakharyaschev The DLLite family relations J Artiﬁcial Intelligence Research 36 2009 169 12 H Stuckenschmidt C Parent S Spaccapietra Eds Modular Ontologies Concepts Theories Techniques Knowledge Modularization Lecture Notes Computer Science vol 5445 Springer 2009 13 P Haase V Honavar O Kutz Y Sure A Tamilin Eds Proc 1st Int Workshop Modular Ontologies WoMO06 colocated Interna tional Semantic Web Conference ISWC06 Athens Georgia USA November 5 2006 CEUR Workshop Proceedings vol 232 CEURWSorg 2007 14 B Cuenca Grau V Honavar A Schlicht F Wolter Eds Proc 2nd Int Workshop Modular Ontologies WoMO 2007 Whistler Canada October 28 2007 CEUR Workshop Proceedings vol 315 CEURWSorg 2008 15 NF Noy MA Musen Specifying ontology views traversal SA McIlraith D Plexousakis F van Harmelen Eds Proc 3rd Int Semantic Web Conf ISWC 2004 Lecture Notes Computer Science vol 3298 Springer 2004 pp 713725 16 J Seidenberg A Rector Web ontology segmentation Analysis classiﬁcation use L Carr DD Roure A Iyengar CA Goble M Dahlin Eds Proc 15th Int Conf World Wide Web WWW 2006 ACM Press New York NY USA 2006 pp 1322 17 B Cuenca Grau B Parsia E Sirin A Kalyanpur Modularity web ontologies P Doherty J Mylopoulos CA Welty Eds Proc 10th Int Conf Principles Knowledge Representation Reasoning KR 2006 AAAI Press 2006 pp 198209 18 B Konev C Lutz D Walther F Wolter Semantic modularity module extraction description logics M Ghallab CD Spyropoulos N Fakotakis N Avouris Eds Proc 18th Europ Conf Artiﬁcial Intelligence ECAI08 Frontiers Artiﬁcial Intelligence Applications vol 178 IOS Press 2008 pp 5559 19 J Lang P Liberatore P Marquis Propositional independence Formulavariable independence forgetting J Artiﬁcial Intelligence Research 18 2003 391443 20 F Lin R Reiter Forget Proc AAAI Fall Symposium Relevance 1994 pp 154159 21 T Eiter K Wang Semantic forgetting answer set programming Artiﬁcial Intelligence 172 3 2008 16441672 22 A Pitts On interpretation secondorder quantiﬁcation ﬁrstorder intuitionistic propositional logic J Symbolic Logic 57 1 1992 3352 23 A Visser Uniform interpolation layered bisimulation P Hájek Ed Gödel96 Lecture Notes Logic vol 6 Springer 1996 pp 139164 24 S Ghilardi C Lutz F Wolter Did I damage ontology A case conservative extensions description logic Proc 10th Int Conf Principles Knowledge Representation Reasoning KR 2006 2006 pp 187197 25 B Konev C Lutz D Walther F Wolter Formal properties modularisation Modular Ontologies Concepts Theories Techniques Knowledge Modularization Springer 2009 pp 2566 26 B Konev D Walther F Wolter Forgetting uniform interpolation largescale description logic terminologies Proc 21st Int Joint Conf Artiﬁcial Intelligence IJCAI 2009 2009 pp 830835 27 Z Wang K Wang RW Topor JZ Pan Forgetting concepts DLLite S Bechhofer M Hauswirth J Hoffmann M Koubarakis Eds Proc 5th Europ Semantic Web Conf ESWC 2008 Lecture Notes Computer Science vol 5021 Springer 2008 pp 245257 28 L Pulina A Tacchella A selfadaptive multiengine solver quantiﬁed Boolean formulas Constraints 14 1 2009 80116 R Kontchakov et al Artiﬁcial Intelligence 174 2010 10931141 1141 29 R Kontchakov F Wolter M Zakharyaschev Can tell difference DLLite ontologies Proc 11th Int Conf Principles Knowledge Representation Reasoning KR 2008 2008 pp 285295 30 R Kontchakov L Pulina U Sattler T Schneider P Selmer F Wolter M Zakharyaschev Minimal module extraction DLLite ontologies QBF solvers Proc 21st Int Joint Conf Artiﬁcial Intelligence IJCAI 2009 2009 pp 836840 31 A Acciarri D Calvanese G De Giacomo D Lembo M Lenzerini M Palmieri R Rosati QuOnto Querying ontologies Proc 20th Nat Conf Artiﬁcial Intelligence AAAI 2005 2005 pp 16701671 32 A Poggi M Rodriguez M Ruzzi Ontologybased database access DIGMastro OBDA Plugin Protégé K Clark PF PatelSchneider Eds Proc 4th Int Workshop OWL Experiences Directions OWLED 2008 DC 2008 33 C Lutz D Walther F Wolter Conservative extensions expressive description logics Proc 20th Int Joint Conf Artiﬁcial Intelligence IJCAI 2007 2007 pp 453458 34 C Lutz F Wolter Mathematical logic life science ontologies H Ono M Kanazawa RJGB Queiroz Eds Logic Language Information Computation 16th Int Workshop WoLLIC 2009 Lecture Notes Computer Science vol 5514 Springer 2009 pp 3747 35 R Diaconescu J Goguen P Stefaneas Logical support modularisation G Huet G Plotkin Eds Logical Environments Cambridge University Press New York 1993 pp 83130 36 P Mosses Ed CASL Reference Manual The Complete Documentation Common Algebraic Speciﬁcation Language Lecture Notes Computer Science vol 2960 Springer 2004 37 P Byers DH Pitt Conservative extensions A cautionary note Bulletin EATCS 41 1990 196201 38 T Maibaum Conservative extensions interpretations theories M Bidoit M Dauchet Eds Proc 7th Int Joint Conf CAAPFASE Theory Practice Software Development TAPSOFT 97 Lecture Notes Computer Science vol 1214 Springer 1997 pp 4066 39 G Antoniou A Kehagias A note reﬁnement ontologies Int J Intelligent Systems 15 7 2000 623632 40 T Eiter M Fink S Woltran Semantical characterizations complexity equivalences answer set programming ACM Trans Comput Log 8 3 41 M Fink Equivalences answerset programming countermodels logic hereandthere MG la Banda E Pontelli Eds Proc 24th Int Conf Logic Programming ICLP 2008 Lecture Notes Computer Science vol 5366 Springer 2008 pp 99113 42 D Pearce A Valverde Synonymous theories answer set programming equilibrium logic Proc 16th European Conf Artiﬁcial Intelligence ECAI 2004 2004 pp 388392 43 V Lifschitz D Pearce A Valverde A characterization strong equivalence logic programs variables Proc 9th Int Conf Logic Programming Nonmonotonic Reasoning LPNMR 2007 pp 188200 44 C Lutz F Wolter Deciding inseparability conservative extensions description logic EL J Symbolic Computation 45 2 2010 194228 45 R Rosati Finite model reasoning DLLite S Bechhofer M Hauswirth J Hoffmann M Koubarakis Eds Proc 5th Europ Semantic Web Conf ESWC 2008 Lecture Notes Computer Science vol 5021 Springer 2008 pp 215229 46 C Chang H Keisler Model Theory Elsevier 1990 47 C Areces B Cate Hybrid logics P Blackburn J van Benthem F Wolter Eds Handbook Modal Logic Elsevier 2006 pp 821868 48 C Papadimitriou Computational Complexity AddisonWesley 1994 49 D Kozen Theory Computation Springer 2006 50 H Kleine Büning T Lettman Propositional Logic Deduction Algorithms Cambridge University Press 1999 51 C Lutz F Wolter Conservative extensions lightweight description logic EL F Pfenning Ed Proc 21st Conf Automated Deduction CADE21 Lecture Notes Computer Science vol 4603 Springer 2007 pp 8499 52 B Konev D Walther F Wolter The logical difference problem description logic terminologies Proc Int Joint Conf Automated Reasoning IJCAR08 LNAI Springer 2008 pp 259274 53 S Feferman RL Vaught The ﬁrstorder properties algebraic systems Fundamenta Mathematicae 47 1959 57103 54 V Kuncak HH Nguyen MC Rinard Deciding Boolean algebra Presburger arithmetic J Automated Reasoning 36 3 2006 213239 55 S Ghilardi C Lutz F Wolter M Zakharyaschev Conservative extensions modal logics G Governatori I Hodkinson Y Venema Eds Advances Modal Logics vol 6 College Publications 2006 pp 187207 56 H Liu C Lutz M Miliˇci c F Wolter Updating description logic ABoxes Proc 10th Int Conf Principles Knowledge Representation Reasoning KR 2006 2006 pp 4656 57 A Remshagen K Truemper The complexity futile questioning HR Arabnia PL Zhou Eds Proc Int Conf Foundations Computer Science FCS 2007 CSREA Press 2007 pp 132138 58 M Benedetti sKizzo A suite evaluate certify QBFs R Nieuwenhuis Ed Proc 20th Int Conf Automated Deduction CADE20 Lecture Notes Computer Science vol 3632 Springer 2005 pp 369376 59 H Samulowitz F Bacchus Binary clause reasoning QBF A Biere CP Gomes Eds Proc 9th Int Conf Theory Applications Satisﬁability Testing SAT 2006 Lecture Notes Computer Science vol 4121 Springer 2006 pp 353367 60 L Zhang S Malik Towards symmetric treatment satisfaction conﬂicts quantiﬁed Boolean formula evaluation PV Hentenryck Ed Proc 8th Int Conf Principles Practice Constraint Programming CP 2002 Lecture Notes Computer Science vol 2470 Springer 2002 pp 200215 61 L Zhang S Malik Conﬂict driven learning quantiﬁed Boolean satisﬁability solver LT Pileggi A Kuehlmann Eds Proc IEEEACM Int Conf Computeraided Design ICCAD ACM 2002 pp 442449 62 E Giunchiglia M Narizzano A Tacchella Clauseterm resolution learning quantiﬁed Boolean logic satisﬁability J Artiﬁcial Intelligence Re search 26 2006 371416 63 F Lonsing A Biere DepQBF A dependencyaware QBF solver J Satisﬁability Boolean Modeling Computation 2010 press 64 C Peschiera L Pulina A Tacchella U Bubeck O Kullmann I Lynce The seventh QBF solvers evaluation QBFEVAL10 O Strichman S Szeider Eds Proc 13th Int Conf Theory Applications Satisﬁability Testing SAT10 Lecture Notes Computer Science vol 6175 Springer 2010 pp 237250 httpwwwqbﬂiborgindex_evalphp