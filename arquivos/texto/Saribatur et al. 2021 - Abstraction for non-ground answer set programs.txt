Artiﬁcial Intelligence 300 2021 103563 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Abstraction nonground answer set programs Zeynep G Saribatur Thomas Eiter Peter Schüller Institute Logic Computation TU Wien Favoritenstraße 911 A1040 Vienna Austria r t c l e n f o b s t r c t Article history Received 20 December 2019 Received revised form 11 May 2021 Accepted 21 July 2021 Available online 28 July 2021 Keywords Abstraction Answer set programming Declarative problem solving Knowledge representation reasoning Nonmonotonic formalisms Explaining unsatisﬁability Counterexampleguided abstraction reﬁnement Abstraction important technique utilized humans model building problem solving order ﬁgure key elements relevant details world This naturally led investigations abstraction AI Computer Science simplify problems especially design intelligent agents automated problem solving By omitting details scenarios reduced ones easier deal understand details added matter Despite fact abstraction powerful technique considered context nonmonotonic knowledge representation reasoning speciﬁcally Answer Set Programming ASP apart related simpliﬁcation methods In work introduce notion abstracting domain ASP program domain size shrinks set answer sets models program overapproximated To achieve program transformed abstract program abstract domain preserving structure rules We elaboration achieved single multiple subdomains sorts domain case structured domains like grid environments structure preserved Furthermore introduce abstractionreﬁnement methodology makes possible start initial abstraction achieve automatically abstraction associated abstract answer set matches answer set original program provided program satisﬁable Experiments based prototypical implementations reveal potential approach problem analysis ability focus parts program cause unsatisﬁability achieving concrete abstract answer sets merely reﬂect relevant details This makes domain abstraction interesting topic research use important areas like Explainable AI remains explored 2021 The Authors Published Elsevier BV This open access article CC BY license httpcreativecommonsorglicensesby40 1 Introduction Abstraction technique applied human reasoning understanding reasoning models world built mentally 3068 Although meaning comes draw away precise deﬁnition capable covering meanings abstraction utilizations There variety interpretations different Some results article presented preliminary form JELIA 2019 113 XAI 2019 45 This work partially supported Austrian Science Fund FWF grant W1255 EUs H2020 research innovation programme grant agreements 825619 AI4EU 952026 HumanEAI Net Corresponding author Email addresses zeynepkrtuwienacat ZG Saribatur eiterkrtuwienacat T Eiter pskrtuwienacat P Schüller httpsdoiorg101016jartint2021103563 00043702 2021 The Authors Published Elsevier BV This open access article CC BY license httpcreativecommonsorglicensesby40 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 2 2 blue 1 4 5 3 6 red 1 4 5 green 3 6 red 7 6 5 9 8 1 2 4 9 3coloring graph b Sudoku Fig 1 Use abstraction disciplines Philosophy Cognitive Science Art Mathematics Artiﬁcial Intelligence shared consensus aim distill essential 108 Among capability abstract thinking achieved removing irrelevant details identifying essence problem 71 The notion relevance especially important problem solving problem complex solve taken account A good strategy solve complex problem start coarse solution reﬁne adding details When planning trip instance ﬁrst pick destination determine coarse travel plan ﬂeshing precise details travel taking subway airport comes later This hierarchy levels abstraction lowest level containing details Another view abstraction generalization aspect singling relevant features properties shared objects For example features airplane color cargo capacity possible differences irrelevant travel plan interested fact airplane takes Vienna New York Overall general aim abstraction simplify problem hand easier understand deal For solving combinatorial problems ﬁguring key elements humans arguably employ abstraction In Artiﬁcial Intelligence problems vary planning problems like order blocks achieve ﬁnal conﬁguration solving constraint problems ﬁnding admissible coloring nodes given graph In problem instance isolated nodes viewed single node colored thinking speciﬁc details Fig 1a If given graph noncolorable try ﬁnd subgraph clique causes unsolvability care nodes graph Similarly blocks labels important disregard ﬁguring actions If goal conﬁguration achieved initial aim ﬁnd particular blocks cause Notably disregard occurs problems multidimensional structures gridcells wellknown Sudoku problem partially ﬁlled 9 9 board completed ﬁlling numbers 19 cells constraints If instance unsolvable reason meaningfully grasped human focusing relevant subregions looking grid complex For illustration Fig 1b shows sub regions instance contain reason solution exists 6 7 occur middle column appear subregion left column unfeasible cell All examples demonstrate abstraction abilities humans come naturally Due important role knowledge representation reasoning abstraction explored AI research early useful tool problem solving solve problem hand ﬁrst abstracted space use abstract solution heuristic guide search solution original space 7092106 This approach planning speeding solving 64 especially computing heuristic functions guide plan search state space Several abstraction methods introduced direction especially automatically compute abstractions good heuristic 3861116 However known success solving problem relies good abstraction For theoretical approaches deﬁning abstractions desired properties investigated 5990 Apart gaining eﬃciency materialize 863 abstraction forms basis obtain highlevel explanations understanding problem For details related works Section 73 Abstraction studied areas AI Computer Science modelbased diagnosis 2389 constraint satisfaction 1352 theorem proving 102 Particularly fruitful applications model checking highly successful approach aided veriﬁcation 27 tackle state explosion problem property preserving abstractions 263282 Furthermore seminal counterexample guided abstraction reﬁnement CEGAR method 25 allows automatic generation abstractions starting initial abstraction approximates behavior verify stepwise reﬁning abstraction long needed long spurious false counterexamples exist Abstraction Answer Set Programming Answer Set Programming ASP 1879 declarative problem solving paradigm rooted knowledge representation logic programming nonmonotonic reasoning A problem represented nonmonotonic logic program answer sets called stable models 57 correspond solutions problem Thanks availability eﬃcient solvers expressiveness formalism ASP gaining 2 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 popularity applications areas AI cf 4749 references combinatorial search problems conﬁguration diagnosis planning modeling behavior dynamic systems beliefs actions agents knowledgeintensive applications query answering explanation generation 47 The declarative nature ASP enables ﬂexible use solving different reasoning problems provides useful basis investigating ways help understanding problem key elements Studies understanding ASP programs ﬁnd solution problem conducted mainly focus debugging answer sets 165593 ﬁnding justiﬁcations 20103115 These approaches aid understanding problem hand noted 50 explanations offered contain high number details prevent seeing crucial parts This abstraction come handy fruitfully Somewhat surprisingly abstraction considered context nonmonotonic knowledge represen tation reasoning including ASP premier formalism area Simpliﬁcation methods equivalencebased rewriting 5397 partial evaluation 1767 forgetting 73 recent survey extensively studied strive preserving semantics abstraction provides approximation answer sets logic program modiﬁed language We aim approximation answer set lost answer set original program corresponds answer set abstract program This enables distill answer sets original program abstract answer sets perform sound reasoning abstract answer sets Specif ically spurious answer sets abstract answer sets correspond answer set original program discarded overapproximation cautious reasoning abstract answer sets ensures soundness respect cautious reasoning answer sets original program case spurious answer set exists completeness particular abstract answer set exists This makes abstraction interesting topic research In recent work 110111 notion abstraction ASP introduced focuses omission atoms vocabulary ensures overapproximation rewriting rules given program That approach propositional nature related forgetting 112 difference overapproximation vs preserving answer sets Further unsatisﬁable programs related minimal unsatisﬁable subsetcore MUS extraction SAT instances propositional answer set programs aims identifying smallest set clauses respectively rules asserted literals prohibit model respectively answer set cf 1257685 This exploited explanation non3colorability graph nonsolvability Sudoku instance Fig 1 terms clauses respectively ground literals rules explanation lacks structure terms showing subgraphs subareas extracted post processing propositional encoding For discussion omission abstraction MUS extraction refer 111 We follow orthogonal approach 110111 introduce work notion abstraction ASP ﬁrst order level concerned collapsing clustering objects Herbrand domain program It way multiplicity removed spirit Occams razor1 If graph Fig 1a represented facts node1 node6 edge1 2 edge1 3 edge2 3 collapsing nodes 4 5 6 abstract node affect 3colorability graph expect abstract version ASP program encodes 3colorings graph yield answer sets 3colorings recovered However edge 4 5 overapproximation yield abstract program spurious answer sets abstract node single color abstract answer set I 4 5 original answer set I different colors I mapped I Similarly nodes 1 2 collapsed graph 2colorable 1 2 share color original graph 2colorable These simple examples naive use domain abstraction replace individuals cluster elements work subtle effects surface programs recursive deﬁnitions reachability cid3 cid3 In fact suitable domain abstraction ASP nontrivial challenges First abstract program automatically constructed structure original rules preserved feasible Second abstraction reﬁnement unclustering objects eliminating spurious answer sets automated This non trivial given large space possible reﬁnements objects related multiple ways temporal spatial relationships reasoning actions instance And capability dealing structure support hierarchical abstraction handle objects different granularities different levels abstraction needed Contributions We address issues work main contributions summarized follows cid3 D 1 We formally introduce notion domain abstraction ASP programs To end deﬁne abstraction map construct abstract program pings m original concrete domain D program abstract domain D cid2cid3 We propose systematic approach answer set I cid2 maps abstract answer set I construction abstract program works modularly syntactic level transforms rule cid2 set abstract rules similar structure In transformation builtin relations particular equality treatment provides backbone method lifted abstract level uncertainty caused abstracted cid2cid3 cid3 cid3 1 Often referred Entia non sunt multiplicanda praeter necessitatem entities multiplied necessity 3 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 cid3 domain D carefully respected Our notion abstraction different applications obtaining abstract solutions ASP programs showing reasons unsatisﬁability case answer set exists We illustrate problems expressed ASP problems combinatorial search planning agent behavior assessment cid3 cid3 2 We present method case abstract answer set I abstraction order eliminate I cid3 constructed I program cid2 wrt mapping m spurious computes cid3 To end reduce test spuriousness unsatisﬁability reﬁnement m nonground ASP program cid2cid3 cid2 m As unsatisﬁability cid2cid3 leaves clueless modify m order eliminate spuriousness present method catching causes unsatisﬁability The method uses debugging technique metaprogramming ASP obtains useful information computing promising reﬁnement m removes spuriousness Building ASP solver uses hood assumption based search To end lift SPOCK approach 16 tight programs nonground level decisions reﬁnements based special atoms computed debugging Intuitively atoms single changes spurious answer set I corresponding answer set I original program cid2 atoms based heuristics introduce different reﬁnement strategies eliminate spurious answer sets These strategies employed CEGARstyle 25 methodology iterative abstraction reﬁnement starts highly coarse abstraction automatically searches outputs abstraction nonspurious concrete answer set exists cid3 cid3 3 We introduce possibility multidimensional abstraction mappings domain While abstraction method deal sorts modify form abstraction relations akin existential abstraction 25 viewed simpliﬁcation initially presented abstraction method order enable elements mixed levels abstraction handled properly This fact needed relate Fig 1b cells like topleft corner abstract cells midleft 3 3 subregion express abstract locations leftof We extend abstractionreﬁnement methodology handling structural aspects gridcells abstraction quadtrees tree structure partition 2dimensional spaces consider sophisticated decision making reﬁnement observe effects resulting abstractions 4 We analyze semantic computational properties abstraction approach exploited modeling guiding design suitable implementations Among results establish abstractions sequences reﬁnements built incrementally Proposition 36 abstractions independent sorts naturally composed Proposition 37 Furthermore variants domain abstractions consider semantically equivalent demonstrate basic case Theorem 51 features making attractive different contexts As regards complexity checking abstract answer set normal logic program spurious coNEXPcomplete deciding abstraction mapping faithful spurious abstract answer sets coNEXPNPcomplete Thus worst case complexity problems coincides unsatisﬁability testing normal respectively disjunctive nonground ASP programs 33 Furthermore predicate arities bounded constant problems cid2p p complete respectively complexity unsatisﬁability testing normal disjunctive nonground ASP programs respectively bounded predicate case 39 Reducing spurious checking unsatisﬁability testing normal logic programs worstcase optimal settings 2 complete cid23 cid3 cid3 abstract answer set I abstract program cid2cid3 5 We implemented abstractionreﬁnement approach prototypical tools DASPAR mDASPAR plain multidimensional abstraction respectively They input nonground program cid2 initial coarse main mapping m default trivial mapping clusters elements output reﬁnement mapping nonspurious exists case cid2 m abstract answer sets The unsatisﬁable provide reﬁnement mapping m implementations include different reﬁnement strategies support independent sorts 2dimensional abstrac tions quadtreestyle reﬁnement process Based tools conducted experimental evaluation approach set experiments focused ﬁnding nontrivial abstractions problems expressed wellknown ASP programs graph coloring scheduling consisted detecting unsolvability benchmark problems involving gridcells In experiments different debugging strategies considered measure assess ing quality multidimensional abstraction developed The results potential approach particular small userstudy natural gridcell problem indicates capability putting humanlike focus grid unsatisﬁability faithful cid2cid3 cid3 Summarizing work domain abstraction ASP opens intriguing line research aims making possible identify gist programs domain responsible matters inconsistency certain solutions The approach present provides ability adjust granularity abstraction details relevant problem semiautomated way The experimental results indicate value domain abstraction program analysis use important areas like Explainable AI remains explored Organization The remainder article organized follows The section recalls notions ASP needed work reviews seminal approach abstraction essence propositional ASP programs introduced 110111 After Section 3 turn domain abstraction nonground ASP programs present abstraction procedure consider extensions study semantic computational properties approach In subsequent Section 4 present reﬁnement methodology based debugging ASP programs After Sections 3 4 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 4 equipped apply CEGARstyle abstraction reﬁnement procedure answer set programs As consideration Section 5 focus multidimensional abstraction alternative abstraction method based existential abstraction needed combined reﬁnement method Section 4 apply CEGARstyle procedure Implementation evaluation approach abstraction types considered Section 6 Section 7 discuss notions abstraction possible use cases related work The ﬁnal Section 8 provides summary outlines issues future research In order distract ﬂow reading longer proofs details moved Appendix A B provides use case agent behavior assessment C 2 Background 21 Answer set programming In section recall concepts notions Answer Set Programming ASP need article We refer 1819114 background references We start syntax semantics ASP programs recall notions useful work Syntax We consider ﬁrstorder vocabulary V P C consisting nonempty ﬁnite sets P predicates C constants Let X represent set variable symbols A term constant C variable X An atom expression α form pt1 tn p P ti term n 0 arity p argα t1 tn denotes set arguments α Atoms called propositional n 0 ground contain variables A literal formula α positive literal α negative literal α atom Intuitively negative literal α true α derived rules false called weak default negation Deﬁnition 21 A normal logic program cid2 ﬁnite set rules A rule r expression form α0 α1 αm αm1 αn 0 m n 1 We refer α0 head r α1 αm αm1 αn body r We write r α0 Br r α1 αm positive body r r clear We refer normal logic Hr α0 denotes head Hr B r αm1 αn negative body r We omit r Br B B programs programs noted r B r B A rule r constraint α0 propositional atom omitted predicate constant falsity Furthermore r fact n 0 variable occurs r r positive n m A rule ground literals occurring ground A program cid2 positive ground rules respective property safe variable occurs rule occurs rule positive body literal We assume safety programs usually achieved making use domain predicates unary predicates given facts true constants variables program grounded We use predicate dom domain predicate For simplicity presentation omit dom representation necessary ensure safety answer sets Choice rules syntactic sugar form B stands rules B B new atom Semantics The answer set semantics deﬁned ground programs For program cid2 deﬁne ground instantiation follows Given program cid2 Herbrand universe denoted HUcid2 set constant symbols C C appearing cid2 case constant symbol HUcid2 c arbitrary constant symbol The Herbrand base program cid2 denoted HBcid2 set ground atoms constructed predicates P constants C The ground instances rule r cid2 denoted grdr set rules obtained replacing variables r constant symbols HUcid2 possible ways The grounding program cid2 grdcid2 rcid2 grdr To group rules grdcid2 head α use def α cid2 r grdcid2 Hr α group nonground rules cid2 deﬁne atoms predicate p use pdef p cid2 r cid2 Hr pt1 tn Let cid2 ground program An interpretation I subset HBcid2 I satisﬁes rule r cid2 denoted I r r I An interpretation model cid2 denoted I cid2 I r r cid2 r I B Hr I B A model I minimal model J cid2 J I cid2 Example 21 Consider program cid2 interpretation I b d c d d c b c 5 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 b d I model cid2 minimal interpretation I cid3 b d model cid2 Deﬁnition 22 GLreduct The GelfondLifschitz GLreduct program cid2 relative interpretation I HBcid2 denoted cid2I ground positive program obtained grdcid2 rule Hr B r B r B ii replaced Hr B r I cid13 deleted r Informally ﬁrst step remove rules I contradicts default negated literal remaining rules second step removes negative body Deﬁnition 23 An interpretation I answer set program cid2 minimal model GLreduct cid2I Apart GLreduct considered standard deﬁnition stable models answer sets collection deﬁnitions 78 The set answer sets program cid2 denoted A Scid2 A program cid2 unsatisﬁable A Scid2 Example 22 ctd cid2 answer sets viz I1 c I2 d b cid2I1 c c b d I1 minimal model cid2I1 similarly cid2I2 d b d I2 minimal model Dependencies The dependency graph ground program cid2 directed graph Gcid2 V E vertices V equal E HBcid2 edges E E r r cid2 q Hr p2 B q Hr p1 B r negative edges E consist positive edges E Example 23 ctd Gcid2 positive edges c b d negative edges c d d c b The positive dependency graph dependency graph containing positive edges denoted G cid2 A program cid2 cid2 acyclic A nonempty set L ground atoms describes positive loop cid2 pair p q L tight G path τ p q G cid2 atom τ L As consider nonground programs need care cyclic dependencies atoms nonground level V E vertices V r r r cid2 A nonground negative dependency cycle For given nonground cid2 consider nonground dependency graph G ng cid2 atoms appearing cid2 edges E E negative edges E length n 2 form a1x1 Hr a2x2 B a1x1 Hr a2x2 B consist positive edges E E a1x1 a2x2 anxn a1x1 denotes path τ G ng α αcid3 including negative edge For example choice rule consists nonground negative dependency cycle length 2 In article focus predicates ai atoms determine dependency consider negative dependency cycles form a1 a2 a1 Accordingly consider set Lc atoms cyclic pair α1 α2 Lc chain predα1 predα2 exists Two cyclic sets Lc1 Lc2 atoms called independent share atom Lc1 Lc2 ASP solvers ﬁrst generate grounding given program search answer set conducted cid2 α atom αcid3cid3 uniﬁes αcid3 ground program 22 Abstraction ASP Abstraction aims discarding details problem obtain highlevel view solution This overapproximation means original solution corresponding solution abstraction encounter abstract solutions corresponding original solution In 110 authors introduced notion abstraction ASP overapproximating given ground program cid2 A Acid3 More formally abstraction smaller vocabulary Acid3 vocabulary A constructing ground program cid2cid3 deﬁned semantic level follows 6 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 2 1 6 7 5 3 4 8 2 1 3 4 Fig 2 Non3colorable graph respectively mapping m A Acid3 cid16 cid16 propositional constant truth cid2cid3 AAcid3 A Acid3 cid3 mα α I answer set cid2cid3 sets ground atoms cid2 abstraction Furthermore cid2cid3 Deﬁnition 24 cf 110 Given programs cid2 cid2cid3 cid2cid3 cid2 respect m answer set I cid2 I abstraction cid2 mapping m exists We refer m abstraction mapping tacitly assumed given This notion abstraction smaller vocabulary Acid3 In 110 focus gives possibility clustering atoms program The abstract program cid2cid3 serves represent abstract answer sets While reduced vocabulary eases search abstract answer set I additional check needed original program cid2 answer maps I abstraction omitting atoms program clustering cid16 cid3 cid3 Example 24 Consider program describes graph 3coloring problem adapted coloring encoding ASP Competition 2013 graphs shown Figs 1a 2 colorred colorgreen colorblue chosenColorN C nodeN colorC coloredN chosenColorN C coloredN nodeN chosenColorN C1 chosenColorN C2 C1 cid13 C2 chosenColorN1 C chosenColorN2 C edgeN1 N2 2 If omit ground version encoding 2 instance shown Fig 1a atoms involving nodes 4 5 6 resulting abstract program answer sets correspond answer set original pro gram omitted nodes colored arbitrarily destroying 3colorability We likewise map atoms α involving 4 5 6 atoms αcid3 nodes replaced new node k node4 nodek node5 nodek The abstract answer sets correspond original answer sets coloring 4 5 6 matter On hand consider graph Fig 2 omit atoms involve nodes 5 6 7 8 resulting abstract program answer sets remaining clique 1 2 3 4 3colorable original program answer set The observations accident fact useful property Proposition 21 Let cid2cid3 abstraction cid2 If A Scid2cid3 A Scid2 In general overapproximation cause abstract answer sets corresponding original answer set Deﬁnition 25 spurious concrete answer sets Let cid2cid3 concrete exists answer set I A Scid2 mI I abstraction cid2 mapping m The answer set I spurious cid3 cid3 A Scid2cid3 In terms abstract answer sets ﬁrst abstract program constructed Example 24 concrete drop atoms involving nodes 1 2 3 4 graph Fig 2 abstract answer sets resulting abstract program spurious 7 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 2 green green 2 blue 3 1 red 1 red 1 red Fig 3 Abstraction reﬁnement spurious graph colorings uncolorable 3 4 2 1 Input cid2 m Step 1 Construct cid2cid3 Step 2 A Scid2cid3 cid13 yes Output cid2cid3 m Get I Step 3 cid3 A Scid2cid3 Step 5 Reﬁne m Step 4 cid3 I concrete yes Output cid3 cid2cid3 m I Fig 4 Abstraction Reﬁnement Methodology 221 Abstraction reﬁnement methodology To rid spurious abstract answer sets abstraction mapping m needs reﬁned ﬁnegrained abstraction case omission abstraction reﬁnement add omitted atoms We consider CEGARstyle 25 abstraction reﬁnement approach reﬁnes initial abstraction repeatedly concrete solution inconsistency absence solutions detected Before describing general methodology ﬁrst illustrate idea graph coloring example Example 25 ctd Fig 3 shows abstraction omitting 7 8 nodes edges Deciding color remaining node easy However original domain coloring match node 1 colored red graph uncolorable A reﬁnement abstraction add nodes knowledge edges Until abstraction achieved nodes causing uncolorability distinguished spurious coloring occurs exists If turn abstract program cid2cid3 Fig 4 depicts methodology introduced 110 For program cid2 start initial abstraction mapping m construct abstract program cid2cid3 Step 1 overapproximates original program cid2 compute abstract answer sets Overapproximation guarantees cid2 answer set I corresponding abstract answer set mI abstract program cid2cid3 answer set Step 2 Proposition 21 cid2 unsatisﬁable In case abstract program cid2cid3 mapping m returned When pick abstract answer concrete shows solution cid2 case set I abstract program cid2cid3 cid3 spurious reﬁne abstraction mapping m m Step 5 loop Step 1 This loop continues picked abstract answer set concrete abstract program answer sets Termination guaranteed extreme case m reﬁned trivial identity mapping element original domain mapped cid2cid3 coincide cid2 Thus cid2 unsatisﬁable procedure stop Step 2 Step 4 cid3 A Scid2cid3 Step 3 check concreteness Step 4 If I mapping m concrete abstract answer set I returned If I cid3 cid3 cid3 In section introduce new abstraction method Step 1 We investigate abstraction nonground ASP programs given mapping domain Herbrand universe singles domain elements The correctness checking abstract answer set Step 4 deciding reﬁnement Step 5 debugging approach introduced Section 4 8 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 3 Domain abstraction The omissionbased abstraction approach 110111 propositional nature account fact ASP nonground rules talk domain discourse nonexistence answer set precise set elements matter certain elements related For example graph coloring encoding 2 expresses node colored differently neighbors The names neighbor nodes relevant color determination relation having neighbor certain chosen color In section tackle issue automatically constructing evaluating suitable abstract program cid2cid3 given nonground ASP program cid2 abstraction domain To illustrate abstraction challenges use following example Example 31 running example Consider following example program cid2 domain D 1 5 a1 a3 c2 d5 bX Y aX dY eX cX aY X cid13 Y bX Y eX 3 4 5 6 Note cid2 answer set I a1 a3 d5 c2 b1 5 b3 5 e2 The abstraction mapping deﬁned Herbrand universe cid2 called domain merging constants Deﬁnition 31 Given domain D cid2 domain abstraction mapping surjective function m D cid3D set cid3D abstracted domain Thus domain abstraction mapping divides D clusters d ˆd cid3D If unambiguous write ˆd cluster m 1ˆd cid3 D md cid3 ˆd elements seen equal Example 32 ctd The Herbrand universe program cid2 HUcid2 1 2 3 4 5 A possible mapping cid2 cid3D1 k1 k2 k3 clusters 2 3 element k2 4 5 element k3 1 singleton cluster k1 m1 1cid17k1 2 3cid17k2 4 5cid17k32 A naive mapping m2 1 5cid17k cid3D2k Abstracting elements Herbrand universe induces abstraction Herbrand base Each domain abstraction mapping m naturally extends ground atoms α pv 1 vn mα pmv 1 mvn α mapped singleton cluster m 1mα 1 mapped nonsingleton cluster Example 33 ctd In Herbrand base HBcid2 atoms predicates b c d e modiﬁed according m a1 b1 5 e2 changed ak1 bk1 k3 ek2 a1 mapped singleton cluster b1 5 e2 mapped nonsingleton clusters Given program cid2 induced mapping m A ˆA Herbrand base A cid2 ˆA mA mα α A want abstract program cid2cid3 achieves overapproximation Deﬁnition 24 However ground case simply applying m cid2 work general Moreover want domain abstraction nonground cid2 results nonground program cid2cid3 turns challenging needs solve issues discuss section Building suitable cid2cid3 31 Towards overapproximation Given mapping m describes abstraction domain program cid2 start intuition applying m rule atom rule modiﬁed according m order obtain abstraction cid2cid3 cid2 To end extend mapping m nonground case follows 2 By abuse notation write e1 encid17ˆd e1cid17ˆd en cid17 ˆd e1 en m 1ˆd 9 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Deﬁnition 32 extended nonground mapping For domain mapping m D cid3D let m X X X X variables remain unchanged Furthermore extend m atoms α pt1 tn negated atoms α sets L literals mpt1 tn pmt1 mtn mnot α mα mL mλ λ L respectively One think simply keeping rules cid2 considering abstract domain evaluation achieve overapproximation However hold general Example 34 ctd If nonfact rules 46 program cid2 lift domain facts cid3D1 mapping m1 resulting program unsatisﬁable Indeed lifting facts yields ak1 ak2 ck2 dk3 Thus rule 4 derives bk1 k3 bk2 k3 rule 5 derives ek2 Consequently constraint 6 ﬁres X k2 Y k3 If lift domain cid3D3 k1 k2 mapping m3 1 2 3cid17k1 4 5cid17k2 resulting program answer set ak1 dk2 ck1 bk1 k2 lifting facts yields ak1 ck1 dk2 rule 4 derives bk1 k2 rules 5 ﬁre The original answer set I mapped abstract answer set m3e2 ek1 occur We look naive approach fail achieve overapproximation present idea approach deal arising issues If consider rule 4 keeping rule unchanged abstraction cause issues ensures b X Y holds true answer set X dY hold true X Y value This similar rules arguments body literals unconstrained independently value domain inequality relations occur body Issues arise case Shared arguments Arguments rule body shared cause issue depending abstraction mapping This atom pk abstract program holds true cluster k represents necessarily original domain elements x cluster k atom px holds true If atom qk occurs cid3 different truth body pk qk true x x values original rule ﬁre Hence interaction shared arguments abstract level treated considering different cases involved predicates behave original level k atoms px qx cid3 Instead ad hoc adopt uniform approach treatment relegated auxiliary atoms To end standardizing apart shared arguments effects nonrelation literals remain untouched Example 35 ctd The constraint 6 b X Y e X shared use variable X If constraint kept mapping m1 rules 4 5 derive bk2 k3 ek2 ak2 dk3 ck2 ak1 respectively As 6 excludes bk2 k3 ek2 true abstract answer set exists This issue arises k2 2 3 nonsingleton cluster X k2 Y k3 atoms bx y ex mapped bk2 k3 ek2 respectively hold true original answer set b3 5 e2 We address standardizing apart multiple occurrence X replace second occurrence fresh variable X1 equated X leading rule bX Y eX1 X X1 7 In way focus abstraction directed relation X X1 rule In similar way constants interact arguments rule bodies standardized apart Details given Section 311 Inequality relation abstract domain The domain clustering cause inequality relations abstract domain fail hold original domain resulting uncertainty treated abstraction process Example 36 ctd The uncertainty caused applying relation abstract domain observed Example 35 k2 k2 holds abstraction elements mapped k2 satisfy relation 2 cid13 3 Consider rule 5 domain cid3D3 mapping m3 Example 34 There saw simply keeping rules results abstract answer set contain ek1 This happens having ak1 ck1 makes rule 5 inapplicable k1 cid13 k1 hold true However elements mapped k1 relation cid13 holds original domain 2 cid13 3 Table 1 shows cases behavior relations abstract domain particular mappings In Section 312 handle uncertainties caused domain clusters assigning types relations respect mappings For example refer case X X1 holds true abstract program elements mapped X X1 satisfy type III The case X cid13 Y false original domain elements mapped X Y satisfy cid13 referred type IV For cases turn head rule choice order capture possible ﬁring nonﬁring original rule alternative abstract answer sets 10 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Table 1 Behavior relations cid13 cid3D 1 mapping m1 cid3D 3 mapping m3 assuming symmetry cid13 k1 cid13 k3 1 cid13 4 1 cid13 5 k2 cid13 k3 2 cid13 4 2 cid13 5 3 cid13 4 3 cid13 5 k2 k2 2 2 3 3 2 cid13 3 k2 k2 4 4 5 5 4 cid13 5 cid3D 1 D cid3D 3 D k1 k1 1 1 k1 k1 1 1 2 2 3 3 1 cid13 2 1 cid13 3 2 cid13 3 k3 k3 4 4 5 5 4 cid13 5 k1 cid13 k2 1 cid13 2 1 cid13 3 k1 cid13 k2 1 cid13 4 1 cid13 5 2 cid13 4 2 cid13 5 3 cid13 4 3 cid13 5 Default negation For nonsingleton clusters negative literals result losing original answer set This default negation issues uncertainty similar inequality relations However important difference interpretation relations depends domain evaluated removed program instantiation process So treatment looking behavior relations abstract domain mapping capable handling uncertainty This possible deﬁned predicates constructing abstract program cid2cid3 cid2 original program reduct cid2I answer set I cid2 appropriately reﬂected answer set I gets lost Example 37 ctd Suppose modify rule 4 adding default negation d bX Y aX dY domY 8 The answer set modiﬁed program cid2 I a1 a3 d5 c2 b1 1 b1 4 b3 1 b3 4 e2 When modiﬁed rule remains unchanged abstraction cid2cid3 obtain mapping m3 1 2 3cid17k1 4 5cid17k2 abstract domain cid3D3 answer set I cid3 ak1 dk2 ck1 bk1 k1 atoms b1 4 e2 contain abstractions m3b1 4 bk1 k2 m3e2 ek1 The reason dk2 false cid3 I body rule 8 satisﬁed This makes reduct cid2cid3 I contain 8 rule cid3 bk1 k1 ak1 domk1 rule k2 However look cluster k2 4 5 literal d5 false original answer set I d4 true I So original reduct cid2I rules b1 4 a1 dom4 b3 4 a3 dom4 8 represented cid2cid3 I cid3 The example shows having negative literal α false α true abstract interpretation I allow mapped α true original interpretation I I answer set However mapped α ensured argument ˆdi α pˆd1 ˆdn conclude atoms αcid3 possible atom αcid3 singleton cluster cid3 We deal issue adding rule nonsingleton clusters original rule polarity α shifted head turned choice Speciﬁcally rule 8 rule bX Y aX dY isSingletonY 9 added abstract program isSingleton auxiliary predicate introduced Section 32 In conclusion need ﬁnegrained systematic approach deal uncertainties Furthermore Example 37 treatment described suﬃcient predicate d deﬁned terms predicates One pay particular attention cycles negation wellknown ASP create alternative answer sets 11 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Table 2 Cases lifting binary relation cid13 D cid3D according map ping m D cid3D applying relation ˆd1 ˆd2 cid3D The symbol stands complement relation I ˆd1 ˆd2 ˆd1 ˆd2 x1 m τ II ˆd1 ˆd2 ˆd1 ˆd2 x1 m τ IIIˆd1 ˆd2 ˆd1 ˆd2 x1 m τ IVˆd1 ˆd2 ˆd1 ˆd2 x1 m τ 1ˆd1 x2 m 1ˆd1 x2 m 1ˆd1 x2 m 1ˆd1 x2 m 1ˆd2 x1 x2 1ˆd2 x1 x2 cid4 1ˆd2 x1 x2 1ˆd2 x1 x2 cid4 certain cases uncertain cases 311 Standardizing apart A rule standardized apart nonrelational atoms predicates cid13 dom contain vari ables nonrelational atoms share variable In order allow uniform treatment interaction arguments rule bodies abstraction rules rewritten follows Suppose r α Br rule form 1 Then following steps performed long possible 1 If variable X occurs nonrelational atoms αi piti B cid3 j respectively replace t j α2 fresh variable X t2 t1 allowed cid13 j required X occurs atom α different argument positions j r 1 2 p1 p2 cid13 dom rule body α1 α2 r B add X X 1 ti ni cid3 2 If constant symbol c occurs nonrelational atom α pt1 tn B cid3 add X cid3 c rule body replace t j α fresh variable X r B r p cid13 dom t j If steps 12 applicable r standardized apart Example 38 ctd Applying procedure rule 6 obtain standardized apart form 7 The rule qX pX X Z qY W r3 Y V domV Z cid13 1 Y cid13 W standardized apart rewriting second occurrence left X Y occurrence 3 order qX pX X1 Z qY W rY 2 Y 1 V domV Z cid13 1 Y cid13 W X X1 Y Y 1 Y 2 3 10 11 Clearly rule r transformed standardized apart form equivalent answer set semantics linear time order steps applied choice variables occurrence matter Notably result arguments nonrelational atoms different dom atoms distinct variables need standardize arguments dom literals apart original domain D abstract domain D dom atom evaluates true 312 Lifted equality relation As shown inequality relations rules cause issues abstraction process To deal focus rules r form r l Bstdr cid6relr 12 Bstdr nonrelation atoms standardized apart cid6rel consists relation atoms constrain variables Bstdr If r contains relation cid6rel cid16 arbitrary rule r easily rewritten form We use B std resp Bstd refer positive resp negative nonrelational literals standardized apart The uncertainty arises abstraction caused relation restrictions nonsingleton clusters cid3d cid3d 1 negative literals mapped nonsingleton abstract literals In order address uncertainty relation restrictions rules consider notion relation types respect abstraction For simplicity focus binary relation cid13 relation cid6relr relation atom Later Section 33 forms relations addressed When relation lifted abstract domain cid3D applying relation ˆd1 ˆd2 cid3D ˆd1 ˆd2 result outcomes different original domain depending mapping seen Example 36 Table 1 II cases uncertainty hold abstract elements ˆd1 ˆd2 relation ˆd1 ˆd2 true resp false original elements x1 x2 mapped ˆd1 ˆd2 respectively x1 x2 true resp false original domain Table 2 shows computation facts representing types relation Type I τ I type II τ Example 39 Consider mapping m1 1cid17k1 2 3cid17k2 4 5cid17k3 Table 1 The relation k1 k1 holds x1 x2 k1 1 x1 x2 holds type I applies having k1 k1 true Further k1 k2 hold k1 cid13 k2 x k1 1 y k3 2 3 x y hold type II applies k1 k2 false 12 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 As relation cid13 k1 cid13 k2 holds true x k1 1 y k3 2 3 x cid13 y holds true type I applies having k1 cid13 k2 true Further relation k1 cid13 k1 hold x1 x2 k1 1 x1 cid13 x2 hold type II applies having k1 cid13 k1 false As type III type IV Table 2 cause uncertainty Type III τ IV holds abstract elements ˆd1 ˆd2 ˆd1 ˆd2 true resp true x1 x2 mapped ˆd1 ˆd2 x1 x2 hold true resp holds true original domain III resp Type IV τ Example 310 Example 39 ctd Consider mapping m1 Table 1 The relation k2 k2 holds x1 x2 k1 2 3 x1 x2 hold 2 cid13 3 type III applies Further k2 cid13 k2 hold k2 k2 x y k2 2 3 x cid13 y hold 2 cid13 3 type IV applies If ˆd1 ˆd2 holds ˆd1 ˆd2 cid3D type III common practice domain abstractions clusters standardization relation occurs type I occurs singleton mappings ˆd1 ˆd2 1 relation cid13 If ˆd1 ˆd2 hold ˆd1 ˆd2 cid3D type II common relation type IV occur relation cid13 In order refer abstract relation atoms introduce following notation Deﬁnition 33 Tm For abstraction m let Tm set atoms τ binary relation ˆd1 ˆd2 m ι ˆd1 ˆd2 ι I IV type We remark Tm easily computed Armed techniques proceed construct abstract program given program cid2 abstraction mapping m use Tm facts Example 311 Example 39 ctd For mapping m1 shown Table 1 facts Tm1 τ I k1 k1 τ τ cid13 I k1 k2 τ III k2 k2 τ III k3 k3 τ II k1 k2 τ II k1 k3 τ cid13 I k1 k3 τ cid13 I k2 k3 τ cid13 II k1 k1 τ II k2 k3 cid13 cid13 IV k3 k3 IV k2 k2 τ 32 Abstract program construction By analysis Section 31 basic idea construct abstract program cid2cid3 program cid2 domain mapping m follows We abstract atom rule case uncertainty domain abstraction guess rule heads catch possible cases treat negated literals shifting polarity depending abstract domain clusters We use auxiliary fact isSingletonˆd abstract domain elements ˆd cid3D denote ˆd singleton cluster 1ˆd 1 These atoms represent abstract atom mα singleton cluster exists mαcid3 mα term t argmα satisﬁes isSingletont mα singleton cluster m atom αcid3 Example 312 Example 31 ctd Consider domain mapping m1 1cid17k1 2 3cid17k2 4 5cid17k3 For abstract domain isSingletonk1 For literals singleton clusters ak1 ck1 dk1 ek1 bk1 k1 remaining literals nonsingletons We remark deﬁnition τ IIIˆd1 ˆd2 τ IVˆd1 ˆd2 holds true ˆd1 ˆd2 cid3D means ˆd1 ˆd2 nonsingleton cluster For ease presentation systematic treatment issues identiﬁed Section 31 shall ﬁrst deal Section 321 programs restrictions gradually lifted Section 322 arrive arbitrary programs 321 Restricted case We ﬁrst consider programs cid2 rules fulﬁll following conditions R1 Unique negative literal Each rule negative body literal R2 Unique relation atom Each rules single binary relation atom R3 No negative cycles There negative cyclic dependencies nonground literals occurring cid2 For rules r relation cid6rel cid16 introduce convenience dummy relation relcid16 X Y holds pairs elements domain D add body r atom relcid16 X Y lifting relcid16 D cid3D 13 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 mapping m relation type τ relcid16 types We assume rules single binary relation atom t1 t2 body ˆd1 ˆd2 similar Table 2 ˆd1 ˆd2 cid3D true type T I false T We deﬁne construct given rule r abstract set rules rm Deﬁnition 34 rule abstraction rm Given rule r α Bstdr t1 t2 domain mapping m set rm tains following rules mα mBstdr mt1 mt2 τ b mα mBstdr mt1 mt2 τ c mα mBstdr mt1 mt2 τ d For t argαi Bstdr αi IIImt1 mt2 IVmt1 mt2 I mt1 mt2 mα mBsh αi ii mα mBsh αi r mt1 mt2 isSingletonmt r mt1 mt2 τ IVmt1 mt2 isSingletonmt Bsh αi r Bstdr αi In step case uncertainty abstraction Steps b c cases uncertainty behavior relations The head choice case IV ﬂip relation order catch case relation holds true actually reason uncertainty No rules added case II body rule satisﬁed relation hold true abstract domain similar original domain As constraints 6 note m Consequently head unchanged optimization steps bd omitted choice ineffective choose false Recall lifted relation relcid16 type I relcid16t1 t2 rules steps di case added relcid16mt1 mt2 τ relcid16 mt1 mt2 omitted true I Example 313 ctd The abstract rules 5 7 standardized apart version 6 eX cX aY X cid13 Y τ eX cX aY X cid13 Y τ eX cX aY X Y τ cid13 I X Y cid13 III X Y cid13 IV X Y 13 14 15 bX Y eX1 X X1 τ Here rule 14 omitted X cid13 Y τ body unsatisﬁable I X X1 cid13 III X Y unsatisﬁable X cid13 Y type III rule 16 In step d Deﬁnition 34 grasp uncertainty arising negation adding rules shift negative literal shares arguments mapped nonsingleton cluster Example 314 ctd The abstract rules rule 8 Example 37 default negated literal be3 bX Y aX dY domY bX Y aX dY isSingletonY 17 18 We remark simply omitting default negated literals abstract rule possible However cause trigger choice rules case resulting abstract answer sets necessary shown Example 315 Let rule 8 Example 37 contain addition relation X cid13 Y bX Y aX dY X cid13 Y domY If instead adding rule bX Y aX dY X cid13 Y τ cid13 I X Y omit dY turn head choice 19 20 3 When negated literal contains argument rules form 18 added argument 14 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 bX Y aX X cid13 Y isSingletonY domY 21 case Y cluster X cid13 Y holds true choice unnecessarily trigger actually dY true To consider mapping m 1 k1 2 5 k2 The original program rule 19 answer set I a1 a3 d5 c2 b1 2 b1 3 b1 4 b3 1 b3 2 b3 4 e2 Even abstract program fact dk1 exist added choice rule 21 causes guess bk2 k1 results cid3 ak1 ak2 ck2 dk2 ek2 bk1 k2 bk2 k2 spurious answer sets containing bk2 k1 I Adding instead rule 20 abstract program avoids spurious answer sets Distinguishing different cases helps avoid unnecessary answer sets actually uncertainty caused Thus abstract rules 19 bX Y aX dY X cid13 Y τ bX Y aX dY X Y τ bX Y aX dY X cid13 Y isSingletonY bX Y aX dY X Y τ cid13 I X Y cid13 IV X Y rule case b omitted X cid13 Y τ cid13 IV X Y isSingletonY cid13 III X Y unsatisﬁable 22 23 24 25 Semantically rules added steps ab Deﬁnition 34 ensure model I cid2 carries model mI rule abstraction original rule kept changed choice rule As regards answer set I steps cd serve catch particular cases violate minimality abstraction negative literal relation nonsingleton clusters The abstract program follows Deﬁnition 35 abstract program cid2m restricted case Given standardized apart program cid2 domain abstrac tion m abstract program m denoted cid2m consists rules cid5 cid2m r αBstdrt1t2cid2 rm x x Tm mpcid22c pcid22c cid2 isSingletonˆd m 1ˆd 1 26 Notably construction cid2m modular rule rule The following result states abstraction works Theorem 31 restricted program abstraction Let m domain mapping standardized apart program cid2 assumptions R1R3 Then I AScid2 holds mI Tm AScid2m The proof result proceeds intuition formally showing abstraction mI answer set I minimal model recursive dependencies negative literals ought considered Since negative cyclic dependencies ground literals exist counterexamples minimality dependencies excluded 322 General case We remove restrictions R1R3 programs G1 Multiple negative literals If rule r multiple negative literals B shares arguments mapped nonsingleton cluster Thus instead shifting literal αi B r shifting multiple literals L B r time combinations nonshifting literals B r1 shift negative literal r consider Deﬁnition 36 treating multiple negative literals Step d Deﬁnition 34 modiﬁed d For L α1 αn Bstdr n 1 t1 tn ti argαi 1 n mα mBsh ii mα mBsh L r mt1 mt2 isSingletonmt1 isSingletonmtn L r mt1 mt2 τ IVmt1 mt2 isSingletonmt1 isSingletonmtn Bsh L rBstdr L BstdrL Shifting negated atoms L case atoms rise nonsingleton clusters occurs atom αi argument ti mapped nonsingleton cluster original domain negative rule body L evaluate true rule possible ﬁre The rules added arguments t1 tn ensure cases covered Steps di dii coincide steps di dii Deﬁnition 34 respectively 15 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Table 3 cid3 Cases lifting nary relation rel cid3 ˆd1 ˆdn τ rel rel I cid3 ˆd1 ˆdn rel τ rel II cid3 III ˆd1 ˆdn τ rel rel cid3 IV ˆd1 ˆdn rel τ rel cid3 cid3 cid3 cid3 ˆd1 ˆdn x1 m ˆd1 ˆdn x1 m ˆd1 ˆdn x1 m ˆd1 ˆdn x1 m cid3 1ˆd1 xn m 1ˆd1 xn m 1ˆd1 xn m 1ˆd1 xn m 1ˆdn rel 1ˆdn rel 1ˆdn rel 1ˆdn rel cid3 x1 xn cid3 x1 xn x1 xn cid3 x1 xn Example 316 Consider rule dX cX aX1 X X1 domX domX1 The constructed nonground abstract rules following step di Deﬁnition 36 dX cX aX1 X X1 isSingletonX domX1 dX cX aX1 X X1 isSingletonX1 domX dX cX aX1 X X1 isSingletonX isSingletonX1 Step dii similarly applied G2 Multiple relation atoms A simple approach handle multiple relations cid6rel t11 1 t21 t1k k t2k k 1 view atom 2kary relation rel relations t11 1 t21 t1k k t2k true false rel false The abstract version rel cid3 cid3 cid3 t11 t21 t1k t2k The atom rel t11 t21 t1k t2k true t11 t21 t1k t2k true relation t1i t2i cid3 cases IIV lifted x1 x2 x1 xn Table 3 27 X1 X2 X3 X4 If abstract values ˆd1 ˆd4 cid3 Example 317 For cid6rel X1 X2 X3 X4 use new relation rel ˆd1 ˆd2 ˆd3 ˆd4 holds type τI ˆdi singleton clusters type τIII ˆdi nonsingleton cid3 rel ˆd1 ˆd2 ˆd3 ˆd4 holds type τII applies G3 Cyclic negative dependencies Rules involved negative cyclic dependency need special consideration Example 318 Example 31 ctd Now consider adding following rules program cid2 removing facts d5 c2 cX dX domX dX cX domX 28 29 These rules create answer sets cid2 containing different appearances c d The abstract rules follows cX dX domX cX dX isSingletonX dX cX domX dX cX isSingletonX 30 31 32 33 Now consider answer set I cid2 contains d1 c2 d3 c4 d5 naive mapping m2 1 5cid17k The mapping ˆI mI answer set I contains ck dk Although ˆI model cid2mI ei ther ck dk unfounded ˆI minimal answer set cid2m The reason negative cyclic dependency choice c datoms occur ck dk constructed cid2m To resolve literals cid2 involved negative cycle treated specially We lift restriction R3 restricted case follows Deﬁnition 37 treating negative cyclic dependency Suppose Lc1 Lcl independent sets literals involved negative cyclic dependency If l 0 item d Deﬁnition 34 changed follows d For t argαi Bstdr αi j 1 l 16 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 mα mBsh ii mα mBsh αi Lc j r mt1 mt2 isSingletonmt r mt1 mt2 τ IVmt1 mt2 isSingletonmt αi Lc j cid6 Bsh αi Lc j r Bstdr αi Bstdr αi α cid2 Lc j αi α Lc j In generalization step d Deﬁnition 34 newly deﬁned Bsh r eliminates atoms αi involved negative cycle head α rule r αi α Lc j j body instead shifting polarity Since sets Lc1 Lcl independent rule involved cyclic set Lc j literals cycles treated time αi Lc j Example 319 ctd For program cid2 consisting rules 46 2829 abstract nonground rules cX dX domX cX isSingletonX domX dX cX domX dX isSingletonX domX bX Y aX dY eX cX aY X cid13 Y τ eX cX aY X Y τ cid13 I X Y cid13 IV X Y 34 35 36 37 38 39 40 bX Y eX1 X X1 τ 41 For mapping m 1 5cid17k facts a1 a3 cid2 lifted ak type facts Tm cid13 τ IV k k Note fact isSingletonk true The abstract program cid2m consists abstract rules mentioned facts Notice rules grounded relation type facts Tm rules 3438 40 remain answer set computation III k k τ I X Y G1G3 arbitrary programs Lifting R2 G2 easily jointly lifting R1 G1 R3 G3 respectively The joint lifting R1 R3 achieved generalization Deﬁnition 34 combines ideas Deﬁnitions 36 37 Deﬁnition 38 treating cyclic dependency multiple negative literals Suppose Lc1 Lcl independent sets literals involved negative cyclic dependency Then item d Deﬁnition 34 changed Deﬁnition 36 l 0 follows d For L α1 αn Bstdr n 1 t1 tn ti argαi 1 n j 1 l r mt1 mt2 isSingletonmt1 isSingletonmtn r mt1 mt2 τ IVmt1 mt2 isSingletonmt1 isSingletonmtn mα mBsh LLc j ii mα mBsh LLc j cid6 Bsh LLc j r Bstdr L Bstdr L Bstdr L Lc j Bstdr L α Lc j Lc j α Lc j Lc j L L cid13 42 negative literals L polarity shifted occur Lc j head α rule r omitted As mentioned Example 315 simply omitting negated literals possible cause spurious abstract answer sets Thus Deﬁnition 36 considered positive shift negated atoms considering combi nations As negated atoms involved negative cycle rule head Example 318 showed positive shift prevent overapproximation Deﬁnition 38 combines insights ensures atoms subset L Bstdr omitted shifting involved cycle head remaining atoms L shifted As consider subsets L B stdr construct abstract rules literals remain untouched 17 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Example 320 Consider rules cX dX domX dX cX aX1 X X1 domX domX1 aX bX domX bX aX domX 43 independent cycles Lc1 ing step di Deﬁnition 38 d X c X Lc2 X b X The constructed nonground abstract rules 43 follow dX aX1 X X1 isSingletonX domX domX1 dX cX aX1 X X1 isSingletonX domX1 dX cX aX1 X X1 isSingletonX1 domX dX aX1 X X1 isSingletonX isSingletonX1 domX dX cX aX1 X X1 isSingletonX isSingletonX1 44 45 46 47 48 Observe 44 constructed Bsh c X The rule 46 gets constructed Bsh involved negative cycle d X The rule 47 outcome Bsh shifted stronger rule 48 constructed Bsh X1Lc2 X1Lc1 c XLc1 Bsh X1c XLc1 X1c XLc2 stronger rule 45 constructed Bsh omission c XLc2 X1 omitted c X gets omitted X1 The nonsubsumed rules constructed following step di Deﬁnition 38 rules 44 46 47 cX isSingletonX domX aX isSingletonX domX bX isSingletonX domX Step dii similarly applied We bits order deﬁne abstract version arbitrary program cid2 Deﬁnition 39 abstract program cid2m general case Given standardized apart program cid2 domain abstraction m abstract program m denoted cid2m consists rules 26 rm r cid2 Deﬁnition 38 cid3 modiﬁed version Deﬁnition 34 multiple relations 27 replaced relation rel described respective case G2 Note programs fulﬁll restrictions R1R3 Deﬁnitions 39 35 coincide cid2m welldeﬁned The main result section follows Theorem 32 general program abstraction Let m domain mapping standardized apart program cid2 Then I AScid2 abstract interpretation ˆI mI Tm answer set cid2m This result shown extension proof Theorem 31 general conditions taken account Example 321 ctd The constructed abstract program cid2m ﬁve answer sets ˆI1 ak dk bk k ˆI2 ak ck ˆI3 ak ck dk bk k ˆI4 ak ck ek ˆI5 ak ck dk ek bk k Furthermore answer set I cid2 mI answer set cid2m The abstraction yields general overapproximation answer sets program The notion spurious concrete answer sets amounts following Deﬁnition 310 cf Deﬁnition 25 An abstract answer set ˆI AScid2m concrete exists answer set I AScid2 ˆI mI Tm spurious 18 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 A spurious abstract answer set corresponding concrete answer set Example 322 ctd The abstract answer sets ˆI2 ak ck ˆI3 ak ck dk bk k spurious 323 Abstract program size vs overapproximation quality The abstract program cid2m Deﬁnition 39 general exponentially larger original program cid2 owing fact dealing multiple negative literals introduce subset L B stdr negative literals rule r rules item d Deﬁnition 38 respectively 36 On hand multiple negative cycles cause exponential blowup number independent negative cycles bounded number atoms occur program cid2 The items ac Deﬁnition 38 introduce rules akin original rules preserve way structure This blowup unpleasant cognitive computational perspective However mitigated following observations First rules item d Deﬁnition 38 generated systematically view subprogram expanded demand user wants inspect similarly exploited evaluation algorithms avoid exponential space consumption Section 35 Second cases number negative literals rule bounded constant means exponential blowup happens Furthermore grounding rules relation type facts Tm remove The size abstract program kept smaller price weaker overapproximation Speciﬁcally Deﬁnition 38 replace negative cycle Lc j arbitrary superset S Lc j literals cid2 resulting abstract program cid2m overapproximation cid2 For example choose S Lc1 Lcl merge negative cycles set save half rules item d Deﬁnition 38 As programs practice including considered multiple negative cycles obtain abstraction In fact seen holds multiple negative cycles Appendix A1 If let S set literals program cid2 42 amounts replacing systematically negated atoms αi cluster information isSingletonti However worst case unbounded number negative literals incurs exponential blowup cid2m We avoid simply dropping item d rule r negative literals adding auxiliary literals results overapproximation price spurious answer sets For example consider simple program X d X dom X domain 1 2 3 fact d3 If abstract program omit d X choice X occur matter d3 mapped singleton Having auxiliary atoms distinguish case useful Furthermore reduce number rules item d auxiliary predicates hasClusterk X1 Xk arity 1 express argument Xi 1 k nonsingleton cluster instead isSingletonmti simple add αi ps1 sk atom hasClusterks1 sk rule bodies Another possibility simplify chosen set S literals program cid2m eliminating subsumed rules Example 320 replacing multiple rules rules answer sets program affected think replacing rules b di resp c dii Deﬁnition 34 atom αi Bstdr exists merged rule atom αi removed suitable terms t t t1 t2 t1 t2 instance To end program rewriting optimization techniques ASP exploited Section 731 information However change structure resulting program signiﬁcantly diﬃcult user understand working abstraction program obtaining intuitive explanations spuriousness diﬃcult systematic approach Furthermore extending approach language constructs diﬃcult accomplish Exploring tradeoff semantic accuracy overapproximation size abstract program space possible choices supersets S possible structurepreserving optimizations interesting issue article 33 Syntactic extensions considerations 331 Other forms relations It customary use ASP programs relations apart cid13 comparison nonbinary relations addition X Y Z multiplication X Y Z ASP solvers support input syntax builtin relations typically preevaluated program grounding A simple way treat relations follows 1 rewrite relations adding instead auxiliary atoms represent 2 standardize apart auxiliary atom arguments similarly remaining atoms 3 add original program facts auxiliary atom domain elements relation holds true In abstraction procedure facts added lifted abstract domain abstraction handled relations arguments standardized apart We illustrate small example Example 323 Consider rule bX Y aX dY X 1 Y 19 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 For addition relation auxiliary atom plusOne X Y introduced adding facts plusOne1 2 plusOne2 3 plusOne3 4 plusOne4 5 cid2 stating domain elements relation holds The respective rule gets standardized apart following form bX Y aX dY plusOneX1 Y 1 X X1 Y Y 1 Fortunately standardizing shared arguments frequently builtin atoms X Y X Y apart introduces new variables auxiliary atoms avoided end relation types Table 2 extended relations cid13 directly Respecting order relation If original domain D order relation elements x1 x2 deﬁned cid3D ˆd1 ˆd2 evaluated abstract values ˆd1 ˆd2 Furthermore abstraction mapping respect ordering elements avoid unnecessary uncertainty cid3 4cid17k1 1 5cid17k2 2 3cid17k3 allow respect usual Example 324 ctd Consider mapping m ordering abstraction 1 4 5 need ordering k2 k1 k2 possible resorting nonstrict ordering fail While relation types deﬁned m type III IV resulting uncertainties cid3 332 Strong negation function symbols Our abstraction method applied programs contain strongly classically negated atoms The simple way achieve apply traditional transformation strongly negated atom pt1 tn replaced atom neg pt1 tn neg p fresh auxiliary predicate constraint pt1 tn neg pt1 tn added program 57 For programs uninterpreted function symbols auxiliary atoms emulate terms containing function symbols new constant symbols similarly discussed 41 Section 6 For illustration rule p f f X q X rewritten pY q X aux f X U aux f U V informally predicate aux f c1 c2 links constant symbol c1 representing term t1 constant symbol c2 represents f t1 Nested function terms represented example rule multiple atoms The predicate aux f precomputed provided facts Notably ASP programs generally evaluated ﬁnite grounding input program 3 potentially inﬁnite Herbrand universe prevent apply method programs 333 Treating choice rules cardinality constraints So far considered choice rules shorthand ordinary rules standard deﬁnition semantics It sense consider primitive constructs dedicated treatment achieve structure preservation To end choice rules treated ensuring body abstracted choice abstracted head kept Deﬁnition 311 Given choice rule r α Bstdr t1 t2 domain mapping m set rm contains rules Deﬁnition 34 steps bd step contains mα mBstdr mt1 mt2 τ I mt1 mt2 Cardinality constraints conditional literals common syntactic extensions 117 particular icid8a X b Xiu true icid8 iu instances X subject b X true Choice rules involve cardinality constraints n1 α n2 Br immediately treated similarly Lifting cardinality constraints analogously abstract rule causes force occurrence abstract atoms ensuring lower bound Example 325 ctd Consider instead 4 rule 2 bX Y dY 4 aX 49 gets lifted abstract rule However mapping m 1 2 3 4 5cid17k ak dk holds true cause bk k hold true atoms predicate Thus lower bound satisﬁed causing abstract program unsatisﬁable The issue arises fact atom choice head involved nonsingleton cluster multiple original atoms mapped satisfying lower bound constraint original program Such choice rules treated modifying lower bounds abstract program adding constraint ensure original lower bound met atom involved singleton clusters 20 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Deﬁnition 312 Given rule r n1 α n2 Bstdr t1 t2 abstraction procedure choice head changed mα n2 additional constraint following form added mα isSingletonms1 isSingletonmskn1 Bstdr mt1 mt2 τ I mt1 mt2 mα isSingletonms1 mα isSingletonmsk 1 50a 50b α pt1 tn s1 sk terms t1 tn local variables r variables occurring Bstdr t1 t2 The idea additional constraint ensure lower bound n1 satisﬁed literals mapped singleton clusters 50a literal nonsingleton cluster 50b occur Example 326 ctd Instead lifting choice rule Example 325 add following abstract rules bX Y dY 4 aX bX Y isSingletonY 2 aX bX Y isSingletonY domY 1 This way lower bound number occurrences b X Y causes unsatisﬁability abstract program Furthermore mapping m 1cid17k1 2 3 4 5cid17k2 answer set containing bk1 k1 constraint ensures contains bk1 k2 original lower bound met By taking numeric information cluster sizes account ﬁnegrained treatment lower bound n1 possible On hand eliminate cases captured constraint 50a50b abstract models overestimate number atoms original answer set exceed n1 overestimate computed aggregates size clusters In dual approach adjust n1 underestimate cid3 n1 number atoms present abstract answer set depending size largest cluster n 1 abstract constant instantiate local variable example Y dY To illustrate 49 lower bound 5 variable Y instantiated abstract constants maximum cluster size 4 know need abstractly instantiated atoms b X Y satisfy concrete lower bound 5 In cid24n1mcsnlvcid25 general adapt lower bound n1 abstract version cardinality constraint n mcs mcsm r maximum cluster size abstract constant mapping m instantiate local variable r nlv nlvr number local variables In example computation adapts lower bound cid24541cid25 2 However adaptations depend concrete mapping m numbers n1 5 n provided nonabstracted auxiliary atoms computed nonabstracted subprogram For space reasons omit working concrete encoding techniques cid3 1 cid3 1 334 Concreteness projection Usually problem encodings contain auxiliary atoms insigniﬁcant solutions When constructing abstract program auxiliary atoms treated introducing choices uncertainty However causes spurious guesses auxiliary atoms making sure abstract answer set concrete wrt atoms ambitious encountering concrete abstract answer set spurious ones diﬃcult For reason consider projected notion determining concreteness abstract answer set focusing certain set atoms Deﬁnition 313 For set A atoms abstract answer set ˆI AScid2m concrete wrt A ˆI ˆA set I AScid2 ˆA m A mI A Tm answer Example 327 Consider modiﬁed instance graph coloring isolated nodes connected shown Fig 5 For abstraction abstract coloring spurious nodes cluster 4 5 6 colored red original graph edges However abstract coloring concrete wrt nodes 1 2 3 Such notion concreteness useful abstraction applied analyze problems focus atoms deemed important For user idea atoms matter determining valid solution Eg planning problems notion help focusing actions directly affected objects serve solution One obtains abstract answer sets concrete truth assignments atoms auxiliary atoms concrete truth assignments irrelevant 21 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 blue 2 red 1 green 3 red 4 5 6 Fig 5 Concreteness wrt projection nodes 1 2 3 34 Properties domain abstraction We consider basic semantic properties formulation program abstraction Nonexisting spurious answer sets allow infer properties original program Proposition 33 For program cid2 AScid2mid I Tmid ii AScid2m implies AScid2 iii AScid2 iff cid2m spurious answer sets I AScid2 identity mapping mid xcid17x x D Proof Having identity mapping id causes singleton clusters abstract domain resulting τI τII type facts Tmid This causes rules step Deﬁnitions 34 311 remain rules grounded relation types Hence answer sets obtained ii Corollary Theorem 32 iii If AScid2 ˆI AScid2m m concrete answer set cid2 abstract answer sets cid2m spurious Now assume holds AScid2 cid13 Then cid2 answer set I Theorem 32 mI Tm AScid2m contradict cid2m spurious answer sets cid2 The abstract program built syntactic transformation The abstraction domain incre mentally end amounts overall abstraction To establish formally recall Deﬁnition 33 Tm contains type atoms τ Tm j mi m j composition mi m j ι ˆd1 ˆd2 mapping m let Tmi m j Tmi Lemma 34 For program cid2 mappings m m1 m2 m2m1D mD grdTm2m1 grdTm cid2m grdT denotes grounding program relation type facts T cid2m1 m2 For proving Lemma 34 use following result Lemma 35 For relation d1 d2 mappings m m1 m2 m2m1D mD T set type atoms related relation m2m1 T m T denotes Proof The relation type computation T m1 m2m1d1 m2m1d2 md1 md2 resulting relation type facts T m1d1 m1d2 relation type computation T m2m1 m cid2 Proof Lemma 34 From rules cid2m1 rules cid2m1 m2 constructed according Deﬁnitions 34 311 Consider rule r body B stdr t1 t2 cid2 The set rm1 cid2m1 contains rules body m1Bstdr ˆt1 ˆt2 τ ˆt1 ˆt2 ˆtk m1tk tk constant ˆtk tk cid3 rm1 body abstracted constant 51 ˆˆtk tk Since For set rm1 rules new set rm1 m2 constructed Let r ˆˆt2 m2Br rel ˆˆt1 ˆˆt1 ˆˆt2 τ j cid3 m2Br m2τ ˆt1 ˆt2 cid3 m2m1Bstdr m2τ ˆˆt1 ˆˆt2 51 form m2ˆt1 m2ˆt2 τ ˆˆt2 τ ˆˆt1 ˆˆt2 rel j ˆˆtk tk ˆt1 ˆt2 τ ˆˆt1 ˆˆt1 mBstdr τ ˆˆtk mtk tk constant ˆˆt2 ˆˆt j m2m1tk tk 22 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 c X d X dom X c X isSingleton X dom X d X c X dom X d X isSingleton X dom X b X Y X dY ek0 ck0 ak1 ek2 ck2 ak1 ek0 ck0 ak2 ek2 ck2 ak2 ek1 ck1 ak2 ek0 ck0 ak0 ek1 ck1 ak0 ek1 ck1 ak1 ek2 ck2 ak0 bk2 k2 ek2 c X d X dom X c X isSingleton X dom X d X c X dom X d X isSingleton X dom X b X Y X dY ea0 ca0 aa0 grdTm1 cid2m1 b grdTm2 m1 cid2m1 m2 Fig 6 Abstract programs Example 328 m1 1 2cid17k0 3 4cid17k1 5cid17k2 m2 k0 k1 k2cid17a0 The rules rm1 m2 types relation differ cid13 j τ ˆˆt2 insigniﬁcant atoms hold true Tm2m1 appear grdTm2m1 rm1 m2 As remaining rules rm1 m2 correspond rules rm Thus Lemma 35 m2m1pcid22c pcid22c cid2 mpcid22c pcid22c cid2 obtain grdTm2m1 cid2m1 m2 grdTm cid2m cid2 ˆˆt2 τ j ˆˆt1 ˆˆt1 Example 328 Example 31 ctd Applying ﬁrst mapping m1 1 2cid17k0 3 4cid17k1 5cid17k2 mapping m2 k0 k1 k2cid17a0 yields mapping m 1 2 3 4 5cid17a0 Fig 6 shows constructed abstract programs Notice program Fig 6b nonground program Example 319 updated mapping m a0 replaced k grounded Tm2m1 An easy induction argument shows possibility abstraction sequentially having abstract mappings deﬁned previously abstracted domains Proposition 36 For program cid2 mappings m m1 mn mn m1D mD grdTm cid2m grdTmn m1 cid2m1 mn In Section 52 demonstrate uses having hierarchy abstractions We remark general properties spurious answer sets overapproximation apply domain abstraction instance Examples properties mentioned omission abstraction 110111 nonreoccurrence elimination spurious answer ˆI set program cid2m corresponding mapped answer set answer set ˆI cid3cid3 corresponding ˆI convexity ˆI cid3 reﬁnement m m reﬁnement m contrary ˆI corresponding answer set ˆI cid3 m m admits spurious answer set ˆI cid3cid3 cid2m corresponds ˆI reﬁnement m m m cid3cid3 cid3cid3 cid3cid3 cid3 cid3 cid3 cid3 341 Abstraction sorts Applications ASP usually contain sorts form subdomains Herbrand universe For example graph coloring sorts nodes colors We deﬁne abstraction sort follows Deﬁnition 314 An abstraction limited sort D D elements x D D form singleton clusters xcid17x Example 329 In graph coloring sorts node color domain 1 6 red green blue instance Fig 1a An abstraction mapping m limited sort node means mx x x red blue green In order obtain coarser abstractions applying abstraction multiple sorts possible given individual sorts fulﬁll following property Deﬁnition 315 sort independence For program cid2 domain D subdomains D1 Dn D independent D D j cid13 j For independent sorts abstractions composed 23 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 greenblue 2 greenblue 2 red 1 greenblue greenblue greenblue 3 6 red 4 5 1 4 5 3 6 red A concrete answer set b A spurious answer set Fig 7 Abstraction set nodes set colors Proposition 37 For domain mappings m1 m2 independent subdomains D1 D2 holds grdTm1m2 grdTm2m1 cid7 cid2m1 cid8 m2 cid7 cid2m2 cid8 m1 Proof The mapping mi Dcid17cid3D form xcid17x x D D mD 1 2 mD describes mapping D abstract domain cid3D We know miD D D D D1 D2 independent D1 m2D D2 m1D Consequently apply mappings independently m2m1D m1m2D cid3cid3D By achieve abstract domain Lemma 34 result cid2 cid3cid3D D D1 D2 cid3D1 cid3D2 Another mapping m deﬁned map D 342 Cartesian abstraction Given domain mappings m1 mn limited subdomains D1 Dn respectively cartesian abstraction map pings corresponds abstract domain mD1 mDn Assuming subdomains D1 Dn independent Deﬁnition 34 altered applied rule form r α Bstdr t1 D1 t2 t1 Dn t2 considering possible combinations τ Di applying abstraction subdomain step time extending Proposition 37 multiple sorts mt1 mt2 j 1 n Alternatively deﬁne cartesian abstraction j Proposition 38 For domain mappings m1 mn independent domains D1 Dn holds cid2m1mn cid2mπ 1 mπ n π permutation 1 n Example 330 Example 24 ctd In graph coloring instance Fig 1a consider mappings mn 4 5 6cid17ˆ4 mc redcid17ˆr green bluecid17 ˆgb sorts nodes colors respectively The abstract program cid2mn mc concrete answer set chosenColor1 ˆr chosenColor2 ˆgb chosenColor3 ˆgb chosenColorˆ4 ˆr shown Fig 7a chooses color cluster ˆgb nodes 2 3 matches intuition coloring neighbor nodes node 1 color different color Notably cid2mn mc spurious answer set shown Fig 7b chosenColor1 ˆgb chosenColor2 ˆgb chosenColor3 ˆgb chosenColorˆ4 ˆr guesses introduced uncertainty In Section 72 demonstrate uses multistep abstraction subdomains 35 Computational complexity In section turn computational complexity reasoning tasks associated program abstraction We build complexity results 3339 cover basic reasoning tasks arbitrary nonground programs nonground programs bounded predicate arities maximum arity predicate occurring program bounded constant Lemma 39 Given arbitrary nonground program cid2 mapping m abstract interpretation ˆI checking ˆI A Scid2m holds feasible cid10p 2 24 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Intuitively holds nondeterministically generate rule r cid2m polynomial time I model reduct cid2mI instance r witnessing fact The minimality I cid2mI shown polynomialsize proof tree guessed checked Armed lemma consider problem identifying concrete abstract answer sets Theorem 310 Given program cid2 domain mapping m abstract interpretation ˆI deciding ˆI concrete abstract answer set cid2m NEXPcomplete general cid11p 2 complete bounded predicate arities Furthermore complexity remains unchanged ˆI AScid2m asserted That worst case complexity answer set existence nonground programs 3339 problems reduced polynomial time Intuitively general abstract atom ˆI mapped exponentially atoms answer set I original program cid2 witnesses concreteness ˆI I guessed checked nondeterministic exponential time Accordingly complexity drops cid11p 2 domain size D polynomial abstracted domain size cid3D interpretations represented bitmaps customary drops abstract cluster small multiple clusters exist Under bounded predicate arities abstract atom maps polynomially original atoms guess I polynomial size checking I NP oracle polynomial time cf Lemma 39 The matching lower bounds shown reductions deciding given nonground program answer set As immediate consequence Theorem 310 obtain following result spuriousness checking Corollary 311 Given program cid2 domain mapping m abstract interpretation ˆI deciding ˆI spurious abstract answer set cid2m coNEXPcomplete general cid2p 2 complete bounded predicate arities Furthermore complexity remains unchanged ˆI AScid2m asserted Next consider deciding abstract program spurious answer set This problem turns higher complexity Theorem 312 Given program cid2 domain mapping m deciding ˆI AScid2m exists spurious NEXPNP complete general cid11p 3 complete programs bounded predicate arities Intuitively compared previous problem ﬁrst guess ˆI abstract answer set cid2m concrete size ˆI exponential input problem relative testing concreteness feasible nondeterministic polynomial time NP oracle The matching hardness shown reductions evaluating secondorder logic formulas suitable form ﬁnite relational structures Faithful abstraction An abstract program spurious answer set faithful abstraction original program Example 331 Example 24 ctd In graph coloring instance Fig 1a mapping m 4 5 6cid17ˆ4 maps nodes 1 2 3 singleton clusters yields abstract program cid2m 42 answer sets combinations 6 possible correct colorings nodes 1 3 7 possible colorings red blue green red blue red green green blue red green blue node cluster ˆ4 resulting faithful abstraction Ideally faithfulness hard achieve general From Theorem 312 immediately obtain Corollary 313 Given program cid2 domain mapping m deciding cid2m faithful coNEXPNPcomplete general cid2p 3 complete bounded predicate arities 4 Reﬁnement debugging nonground spuriousness Overapproximation answer set program unavoidably introduces spurious answer sets Once spurious abstract answer set encountered continue searching concrete abstract answer set reﬁne abstraction reach spurious answer sets occur Deﬁnition 41 Given domain mapping m D cid3D m 1mx cid3x m cid3 1m cid3 mapping m cid3 D cid3D cid3cid3 reﬁnement m x D That reﬁnement dividing abstract clusters ﬁner grained domain 25 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Example 41 Example 321 ctd The mapping m m 1 5cid17k Furthermore cid2m answer set ˆI2 cid2m eliminated answer set ˆI cid3 cid3 1cid17k1 2 3cid17k2 4 5cid17k3 reﬁnement mapping cid3 ˆI2 ak ck spurious mm cid3 1ˆI cid3 In CEGAR methodology 25 decision reﬁnement step depends correctness checking spurious abstract solution problematic abstraction detected Inspired develop alter native checking correctness abstract answer sets determine reﬁnement Correctness checking constraints That abstract answer set ˆI spurious means original program cid2 answer set matching ˆI In words querying cid2 match abstract answer set ˆI return result exactly ˆI spurious Deﬁnition 42 query answer set Given abstract answer set ˆI mapping m query Q m ˆI matches ˆI described following constraints answer set α mα ˆα 0 α ˆα ˆI Tm ˆα ˆI Tm mα ˆα 52 53 Here 52 ensures witnessing answer set I cid2 mI ˆI contains nonτι abstract atom ˆI atom mapped 53 ensures atom I mapped abstract atom ˆI The following easy establish Proposition 41 Suppose m domain abstraction mapping program cid2 abstract answer set ˆI A Scid2m spurious iff cid2 Q m ˆI unsatisﬁable Proof As ˆI spurious exists I A Scid2 mI ˆI Tm match original answer set I ˆI atoms I mapped abstract atoms contained ˆI Tm atoms I mapped abstract atoms contained ˆI Tm Q ˆI enforces match returns unsatisﬁability Having match ˆI means original answer set mapped ˆI spurious cid2 Correctness checking debugging We employ ASP debugging approach debug inconsistency original program cid2 caused checking spurious answer set ˆI referred inconsistency cid2 wrt ˆI order hints reﬁning abstraction Different usual ASP program debugging approach need shift focus debugging original program debugging inconsistency caused spurious answer set Unfortunately immediate application available ASP debugging tools possible For purposes use meta level debugging language 16 based tagging technique allows control building answer sets manipulate program evaluation The metaprogram constructed spock 16 introduces tags control answer set building Given ground program cid2 viewed program propositional alphabet ground atoms propositional atoms set N names rules cid2 creates enriched alphabet adding propositional atoms apnr blnr oknr konr nr N r cid2 The atoms apnr blnr express rule r applicable blocked respectively oknr konr manipulating application r For domain abstraction debugging nonground program diﬃculties The approach 16 propositional level immediately applied Also debugging nonground programs straightforward propositional case additional need debug checking original answer set mapped given abstract answer set However nonground program debugging approaches 3693 easily adjustable need shifting focus debugging correctness check Using available debuggers Debugging nonground ASP programs metaprogramming 55 approach studied 93 drawback considering possible explanations given interpretation I answer set program cid2 For given input I order prove I answer set cid2 debugging considers possible guesses variable assignments matches I faulty behavior In case input I abstract answer set stating original answer set I mapped abstract atom ˆα I This adds guess original atom mapped ˆα However debugging aims showing I answer set cid2 additional guessing comes play guesses original atoms create faulty behavior I atoms occur original answer set Thus immediate application metaprogramming approach infeasible cid2 atom I cid3 cid3 In order use available nonground debugging tools offtheshelf possibility ﬁrst guess possible com binations original atoms match abstract answer set ˆI separately debug If ˆI fact 26 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 spurious caught possible guess return inconsistency If ˆI concrete point guess correspond original answer set inconsistency However approach cumbersome possible concrete guesses abstract I checking concrete exists highly ineﬃcient Our approach debugging As existing nonground debugging tools readily applicable debug unsatisﬁability spurious abstract answer set ˆI following debugging approach based 16 In previous cid2 Q m ˆI work domain abstraction 113 considered simpliﬁed debugging approach inspired ko atoms 16 based detecting rules deactivated order satisﬁability checking concreteness abstract answer set ˆI case spurious As naive debugging address debugging cases work extension reﬁnement method lifting spock 16 debugging approach nonground case conﬁning class programs subsumes tight programs When demonstrating different debugging approaches use nonground version Q m ˆI Deﬁnition 43 nonground query Given abstract answer set ˆI mapping m expressed set facts form mx cid3d mx cid3d nonground query answer set matches ˆI described follows inp ˆX1 ˆXk pX1 Xk mX1 ˆX1 mXk ˆXk 0 pX1 Xk inp ˆX1 ˆXk mX1 ˆX1 mXk ˆXk inpˆd1 ˆdk pˆd1 ˆdk ˆI Tm p cid13 dom nonrelational predicate 54 55 56 Example 42 Example 31 ctd For program cid2 mapping m 1 2 3 4 5cid17k given facts m1 k m2 k m3 k m4 k m5 k abstract program cid2m answer set ˆI ak ck The query Q m ˆI ind A1 dX1 mX1 A1 A1 cX1 mX1 A1 ina A1 aX1 mX1 A1 ine A1 eX1 mX1 A1 inb A1 A2 bX1 X2 mX1 A1 mX2 A2 inb A1 A2 bX1 X2 mX1 A1 mX2 A2 0 inak inck ind A1 dX1 mX1 A1 0 A1 cX1 mX1 A1 0 ina A1 aX1 mX1 A1 0 ine A1 eX1 mX1 A1 0 41 Nonground debugging tagging We extend reﬁnement method described 113 lifting tagging approach spock 16 non ground case conﬁning class programs makes possible avoid unfounded loop checking debugging spuriousness query Given cid2 construct meta program Tmetacid2 similar spock 16 extension having arguments apnr blnr atoms information constants rules applicable blocked Deﬁnition 44 Given nonground program cid2 program Tmetacid2 vocabulary Vmeta enriches vocabu lary V cid2 predicates apnr blnr apnr konr nr N consists following rules r cid2 c1 cn denoting set terms arguments Hr d1 dncid3 denoting set terms arguments literals Br If Br If Hr cid13 n 0 If Hr n 0 r Hr apnr c1 cn konr apnr c1 cn Br blnr c1 cn apnr c1 cn Hr apnr d1 dncid3 konr apnr d1 dncid3 Br apnr d1 dncid3 apnr apnr blnr In case head rule r contain arguments atom use arguments body know r applicable 27 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 We abnormality atoms indicate actions required avoid inconsistency ab_deactnr signals r applicable interpretation deactivated similarly ab_deactConsnr talks constraints ab_act pc1 cn α pc1 cn says atom α true rule deriving α applicable α unsupported4 Deﬁnition 45 Given nonground program cid2 vocabulary V following additional metaprograms constructed vocabulary Vdebug enriches Vmeta abnormality predicates ab_deactnr ab_deactConsnr ab_act p c1 cn d1 dncid3 Deﬁnition 44 follows 1 Rule Deactivation Tdeact cid2 r cid2 Br cid13 Hr cid13 konr Hr apnr c1 cn ab_deactnr c1 cn apnr c1 cn Hr 2 Constraint Deactivation TdeactConscid2 r cid2 Hr ab_deactConsnr d1 dncid3 apnr d1 dncid3 konr konr 3 Rule Head Activation Tact cid2 V rule heads α pc1 cn cid2 α V pdef p cid2 r1 rk k 1 α blnr1 c1 cn blnrk c1 cn ab_act pc1 cn α blnr1 c1 cn blnrk c1 cn The arguments ab_deact contain ones head rule This representation choice avoid dealing variables involved body head rule For deﬁnition ab_deactCons variables body Having different representation deactivation constraints allow steer debugging constraints assigning different costs occurrence computing answer sets smallest number ab atoms Deﬁnition 46 debugging program cid2debug For program cid2 vocabulary V let program cid2debug Vdebug deﬁned cid2debug Tmetacid2 Tdeactcid2 TdeactConscid2 Tactcid2 V We use cid2debug checking correctness abstract answer set deciding reﬁnement Adding weak constraints abnormality atoms yields answer set fewest ab atoms We use weak constraints 74 form α1 αm αm1 αn w t1 tk w weight positive integer constant variable t1 tk terms α1 αn For answer set set tuples w t1 tk violated weak constraints computed sum ﬁrst components set assigned answer set cost Among answer sets cost smallest chosen optimal answer sets Using weak constraints convenient way performing optimizations Example 43 Example 42 ctd The program cid2debug additional weak constraints abnormality atoms shown Fig 8 The minimal answer set cid2debug Q m ˆI ab_deactr41 ab_deactr42 ab_deactr45 This debugging approach able handle shortcomings naive approach 113 Tact cid2 V activate original atoms necessary achieving satisﬁability cid2debug Q m ˆI 4 An atom α unsupported interpretation I r def α cid2 B r cid2 I B r I cid13 120 28 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 c X apr1 X kor1 apr1 X d X blr1 X apr1 X d X apr2 X kor2 apr2 X c X blr2 X apr2 X b X Y apr3 X Y kor3 apr3 X Y X dY blr3 X Y apr3 X Y e X apr4 X kor4 apr4 X c X aY X cid13 Y blr4 X apr4 X apr5 X Y kor5 apr5 X Y b X Y e X apr5 apr5 X Y blr5 apr5 a1 a3 kor1 c X apr1 X ab_deactr1 X apr1 X c X ab_deactr1 X 1 r1 X kor2 d X apr2 X ab_deactr2 X apr2 X d X ab_deactr2 X 1 r2 X kor3 b X Y apr3 X Y kor5 ab_deactConsr5 X Y kor5 apr5 X Y ab_deactConsr5 X Y 1 r5 X Y c X blr1 X ab_actc X c X blr1 X ab_actc X 1 X d X blr2 X ab_actd X d X blr2 X ab_actd X 1 X ab_deactr3 X Y apr3 X Y b X Y b X Y blr3 X ab_deactr3 X Y 1 r3 X Y ab_actb X Y b X Y blr3 X ab_actb X Y 1 X Y kor4 e X apr4 X ab_deactr4 X apr4 X e X ab_deactr4 X 1 r4 X e X blr4 X ab_actc X e X blr4 X ab_acte X 1 X Fig 8 Debugging program cid2debug Example 42 weak constraints As ﬁrst property cid2debug Q m ˆI answer set abstract answer set ˆI dismissed provided program cid2 hand obeys following property We cid2 positivedependency founded negative edge Gcid2 points cycle G cid2 atoms positive loops negatively conditioned atom Note positive dependency founded programs subsume tight programs G cid2 acyclic Proposition 42 Given positivedependency founded program cid2 mapping m answer set ˆI A Scid2m cid2debug Q m ˆI answer set The result shows use cid2debug Q m ˆI obtain hints spuriousness reason ˆI Proposition 43 Given positivedependency founded program cid2 mapping m answer set ˆI A Scid2m spurious ab_deactnr c1 cn S ab_deactConsnr d1 dncid3 S r cid2 answer set S AScid2debug Q m ˆI ii ab_act pc1 cn S r grdcid2 Hr pc1 cn Less surprisingly programs positivedependency founded debugging correctness check result unsatisﬁability Appendix B1 example To avoid unfounded loop checking handled introduc ing additional abnormality atom abloop 16 lifting nonground setting However solution causes guessing rules involved nonground debugging Also existence abloopα indicate loop formula violated makes search diﬃcult considering possibili ties guesses Therefore choose focus positivedependency founded programs concentrate determination reﬁnement The obtained debugging atoms correctness check hints domain elements involved cluster Deﬁnition 47 reﬁnementhint program cid2hint The reﬁnementhint gathering program cid2hint program cid2 contains following rules c1 cn d1 dncid3 Deﬁnition 44 For ci argab_deactnr c1 cn reﬁnec1 cn ab_deactnr c1 cn mci ai isSingletonai 29 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Algorithm 1 decideReﬁnement Search Input program cid2 domain mapping m Output reﬁnement m m cid3 1 m nonsingleton clusters reﬁnecosts allrefs 2 compute 1distance refinements m refs computeReﬁnementsm 1 forall m cid3 refs c getCostOfMappingcid2 m c 0 concrete abstract answer set cid3 3 4 5 6 7 8 9 10 return m cid3 allrefsappendm reﬁnecostsappendc cid3 11 12 minrefs getRefsMinCostreﬁnecosts allrefs m pickRandomRef minrefs 13 return m 14 15 def getCostOfMappingcid2 m 16 17 cid2m constructAbsProgcid2 m cid2debug constructDebugProgcid2 Pick ˆI A Scid2m Find optimum answer set I s I return I cid3ab cid3 18 19 20 cid2debug Q m ˆI cid3ab smallest number s abatoms For di argab_deactConsnr d1 dncid3 reﬁned1 dncid3 ab_deactConsnr d1 dncid3 mdi ai isSingletonai For ci argpc1 cn reﬁnec1 cn ab_actpc1 cn mci ai isSingletonai From cid2hint hints domain elements mapped abstract cluster elements cause ab atoms debugging 42 Deciding reﬁnement The introduced debugging approach ﬁnds set abnormality atoms case abstract answer set spurious We consider ways obtained debugging output deciding reﬁnement v1 The smallest number ab atoms occurring answer set cost corresponding mapping v2 The inferred reﬁne atoms decide reﬁnement abstraction In v1 cost local search possible reﬁnements abstraction minimum cost picked Approach v2 closer CEGARlike approach 25 reﬁnement determined spuriousness check We approaches report comparison Section 63 v1 Local Reﬁnement Search The idea search possible reﬁnements mapping deciding reﬁnement cid3 mapping mD cid3D reﬁnement To single close reﬁnements measure distance distm m cid3 cid3D number additional clusters distm m m 1distance reﬁnement m cid3 cid3D In case distm m cid3 1 m cid3D cid3D cid3 cid3 Example 44 Each mapping m reﬁnement m 1 2 3 4 5cid17k cid2 cid3 CCCcid17k1 1 5 Ccid17k2 C 1 1 2 1 2 3 1 2 3 4 1distance Algorithm 1 shows procedure deciding reﬁnement given mapping m distancebased search possible reﬁnements mapping picking cost All 1distance reﬁnements m computed cost determined calling getCostOfMapping This function constructs abstract program cid2m according mapping picks abstract answer set ˆI It ﬁnds answer set smallest number s abatoms program cid2debug Q m cost 0 returned ˆI Otherwise reﬁnements costs collected In Line 11 reﬁnements minimum cost gathered random pick If given mapping contains singleton clusters means original domain reached returns s If reﬁnement m cid3 30 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 v2 Abstraction Reﬁnement Using Hints The abstract answer set correctness checking returns abatoms contain domain elements involved debugging unsatisﬁability The hints mapping reﬁne The idea reﬁne atoms hints domain elements involved cluster Given hint atom reﬁnec1 cn consider actions reﬁnement m m cid3 1 For reﬁnec1 cn 1 n m 2 For reﬁnec1 cn ci cid13 c j c1 cn mci mc j reﬁnement m 1mci 1 reﬁnement m satisﬁes m cid3 cid3 1m satisﬁes m cid3 cid3ci 1 cid3ci cid13 m cid3c j Applying reﬁnement action 1 means reﬁne abstraction mapping elements occurring reﬁne atom singletons reﬁnement action 2 ensure distinct elements occurring reﬁne atom longer mapped cluster Example 45 Example 43 ctd The hint atoms minimal answer set cid2debug Q m ˆI Applying reﬁnement action 1 means map elements 1 5 singletons m trivial abstraction m cid3 1cid17k1 2cid17k2 3cid17k3 4cid17k4 5cid17k5 reﬁne1 reﬁne5 making reﬁnement cid3 As spurious answer set ˆI3 ak ck dk bk k cid2m Example 321 minimal answer ab_deactr41 resulting hint atom reﬁne1 When abstraction mapping reﬁned set cid2debug Q m ˆI3 m cid3 1cid17k1 2 3 4 5cid17k2 spurious answer set longer appears Note obtaining reﬁne atom correctness checking guaranteed ˆI spurious ab atoms contain domain elements mapped singleton clusters In case abstract answer set ˆI cid2m picked correctness checking cid3 5 Multidimensional domain abstraction With methods abstraction reﬁnement Sections 3 4 hand equipped run CEGARstyle abstraction reﬁnement procedure answer set programs As seen Proposition 38 possible deal sorts important practical applications We construct abstract program multiple sorts manner cartesian abstraction achieved abstraction sorts time However drawback certain interdependencies sorts account scenarios needed We illustrate need examples present alteration abstraction method interdependencies sorts account Example 51 Example 330 ctd An interesting abstraction assign color cluster cid13rgb nodes 4 5 6 clustered node ˆ4 nodes 1 2 3 original colors considered Fig 9 Such abstraction achieved cartesian style abstraction color cluster cid13rgb meant considered node cluster ˆ4 Thus desired abstraction deﬁned multidimensional mapping m Dn Dc cid3Dn cid3Dc follows cid6 mi j j ˆ4 cid13rgb 1 2 3 j red green blue 4 5 6 j red green blue To motivate need multidimensionality consider gridcell domains commonly Example 52 gridcell domains Usually gridcells represented sorts row column The following rules Sudoku encoding guesses assignment symbols cells ensures cell number solX Y N occupiedX Y numN rowX columnY hasNumX Y solX Y N rowX columnY hasNumX Y rowX columnY Further constraints ensure cells column 58 row 59 contain symbol solX Y 1 M solX Y 2 M Y 1 Y 2 solX1 Y M solX2 Y M X1 X2 A involved constraint cf Appendix B2 ensures cells subregion satisfy 31 57 58 59 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 blue 2 red 1 4 5 green 3 6 redgreenblue Fig 9 Joint abstraction nodes colors x y 1 2 3 4 x y 1 2 3 4 1 2 3 4 A B 1 2 3 4 A B 2 3 4 x y 1 2 3 4 1 A B b c Fig 10 Abstractions gridcells An abstraction gridcells cluster rows columns order deﬁne abstract gridcell Although abstraction sorts time achieve certain abstract cell structures obtain phisticated abstractions sorts jointly abstracted Consider example abstractions Fig 10 Those Figs 10a10b achieved independent mappings rows columns mrow mcol 123cid17a123 4cid17a4 mrow mcol 12cid17a12 34cid17a34 For given program cid2 construct abstract program cid2mrow mcol However achieve Fig 10c rows columns jointly abstracted While cells ai b j 1 j 2 singletons mapped j abstract regions given mrowcolx y a12 b34 x 1 2 y 3 4 a34 b12 x 3 4 y 1 2 a34 b34 x 3 4 y 3 4 60 Observe abstract row a12 describes cluster abstracts individual abstract rows a1 a2 The original rows 1 2 mapped a12 combination columns 3 4 mapped a1 a2 51 Existential abstraction relations The abstraction method described Section 312 aims keeping builtins abstract program ﬁnds way handle different behavior abstract domain However approach achieve mentioned multidimensional abstraction Consider rule 58 standardized apart rows columns having relations X1 X2 Y 1 Y 2 If mapping mrowcol Fig 10c relations lifted following Section 312 relation yaxis deﬁned A located B AY B Y relation A X B X unclear abstract clusters X values different different levels abstraction To tackle issue alternative abstraction method needed abstracts builtin relations reasons abstracted relation abstract domain This leads notion abstraction similar spirit called existential abstraction 25 allows introduce domain mappings multiple sorts m D1 Dn cid3D1 cid3Dn handle relations different levels abstraction For introduce abstract relation cid3rel kary relation rel follows ˆdi cid3D cid3relˆd1 ˆdk k k i1 ˆdi cid3D neg_ cid3relˆd1 ˆdk k i1xi m i1xi m 1ˆdirelx1 xk 1ˆdirelx1 xk k i1 62 Ie cid3relˆd1 ˆdk true corresponding original values original relation holds opposite cid3relˆd1 ˆdk neg_ cid3relˆd1 ˆdk true Notably versions hold simultaneously depending domain clusters 61 32 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Example 53 Example 31 ctd For mapping 1 5cid17k abstract relation k cid3 k holds true X Y X Y mapped k Both k cid3 k k neg_cid3 k hold true X1 X2 holds X1 X2 values mapped k Notice having rel neg_rel hold means uncertainty truth value relation abstract clusters This brings determining types relations abstract clusters similar Abstract relation types The following cases τI τIII occur mapping abstract relation predicates cid3relˆd1 ˆdk neg_ cid3relˆd1 ˆdk ˆd1 ˆdk cid3relˆd1 ˆdk neg_ cid3relˆd1 ˆdk cid3rel τ I cid3rel II ˆd1 ˆdk neg_ cid3relˆd1 ˆdk cid3relˆd1 ˆdk τ cid3rel cid3relˆd1 ˆdk neg_ cid3relˆd1 ˆdk III ˆd1 ˆdk τ 63 Type I case abstraction cause uncertainty relation rules contain cid3rel type I remain abstract program Type II shows cases cid3rel hold abstract domain Type III case uncertainty needs dealt creating abstract rules To ensure overapproximation achieved head respective rule changed choice For abstraction m compute set Tm atoms τ m cid3rel ι ˆd1 ˆdk ι I II III type cid3relˆd1 ˆdk 511 Abstraction procedure For simplicity ease presentation consider programs rules having single relation atom ii cyclic dependencies nonground literals Deﬁnition 51 rule abstraction Given rule r α Bstdr relt1 tk domain mapping m set rm following rules contains cid3rel ˆt1 ˆtk mα mBstdr τ I cid3rel III ˆt1 ˆtk b mα mBstdr τ c For L Bstdr mα mBsh mα mBsh cid3rel ˆt1 ˆtk isSingletonmt L r τ I cid3rel III ˆt1 ˆtk isSingletonmt L r τ Bsh L rBstdr L BstdrL t argαi αi L The idea introduce guesses uncertainty relation holding abstract domain b negated atoms abstract clusters c considering combinations negative literals abstracting rule The abstraction procedure introduced Deﬁnition 51 obtains semantically abstract program Deﬁni tion 34 rules form α Bstdr relt1 t2 relt1 t2 t1 t2 binary relation cid13 Deﬁnition 52 existential abstract program cid2m cid5 Given program cid2 domain mapping m denote cid2m x x Tm mpcid22c pcid22c cid2 isSingletonˆd m rm 1ˆd 1 64 r αBstdrrelt1t2cid2 program obtained cid2 existential abstraction m We Theorem 51 For domain mapping m standardized apart program cid2 rules having single relation atom cyclic dependencies nonground literals A Scid2m A Scid2m coincide modulo auxiliary atoms A generalization multiple relation atoms handling cyclic dependencies removing restrictions iii similarly cases GII GIII Section 32 33 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Example 54 Example 31 ctd For program cid2 46 choice rules 2829 m 1 5cid17k program cid2m cX dX domX cX isSingletonX domX dX cX domX dX isSingletonX domX bX Y aX dY ˆcid13 I X Y eX cX aY τ eX cX aY τ bX Y eX1 τ ˆ ˆcid13 III X Y I X X1 65 66 abstract fact ak furthermore Tm τ 65 66 respectively involved negative cycle similar rules 35 37 Example 319 III k k Note atoms d X c X omitted ˆcid13 III k k τ ˆ The abstract program similar constructed lifting relations Example 319 As easily checked programs modulo auxiliary atoms abstract answer sets We note previous reﬁnement methods applied abstract program constructed way changes regard program reﬁned Furthermore observe treating nary relations n 2 modify Deﬁnition 51 create ﬁner abstractions Example 55 Consider argument Z following rule involving addition r eZ cX aY Z X Y 67 We denote Z X Y relation plus X Y Z Regarding arguments argeZ argplus X Y Z Z cid13 argeZ X Y X Y shared arguments body literals relation plus argBr argplus X Y Z X Y Consider mapping m 1 cid17 a1 2 3 cid17 a23 4 5 cid17 a45 Xa1 Y a1 For abstract relation cid13plus cid13plusa1 a1 a23 neg_cid13plusa1 a1 a23 hold true 1 1 2 1 1 cid13 3 As Z body literals cause uncertainties applying rule abstraction caught eZ cX aY τ cid3rel XY Z III isSingletonX isSingletonY In general adding Deﬁnition 51 rule mα mBstdr τ cid3rel III ˆt1 ˆtk ˆti argi relargα isSingletonˆti argα argrel cid13 argα argBstdr argrel cid14 guess b avoided arguments rel involved head l singleton clusters The use abstract relations opens wide range possible applications simpliﬁes use given program preprocessing match restrictions forms relations previous abstraction method 512 Computing joint abstract relation types Abstract relations easily employed abstraction mappings sorts domain m D 1 Dn cid3D1 cid3Dn If rule relations sorts joint abstract relation combining computed We example gridcell abstraction illustration Example 56 abstracting gridcells Consider relations rel1 X1 X2 X1 X2 rel2Y 1 Y 2 Y 1 Y 2 X1 X2 row Y 1 cid15rel III cid15rel combines Y 2 column standardizing apart variables 58 The rules compute types τ rel1 rel2 follows cid15rel I τ 1 Deﬁne abstract relations This step corresponds existential abstraction 61 cid13rel1 ˆX1 ˆY 1 ˆX2 ˆY 2 rel1X1 X2 mX1 Y 1 ˆX1 ˆY 1 mX2 Y 2 ˆX2 ˆY 2 cid13rel2 ˆX1 ˆY 1 ˆX2 ˆY 2 rel2Y 1 Y 2 mX1 Y 1 ˆX1 ˆY 1 mX2 Y 2 ˆX2 ˆY 2 34 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 1 dn2 1 dn2 1 ˆc1 md1 1 ˆc1 md1 k dn2 k dn2 k ˆck k ˆck cid3reliˆc1 ˆck relidi neg_ cid3reliˆc1 ˆck reli di 1 di k md1 τ τ k md1 1 di ˆc1 ˆck cid3reliˆc1 ˆck neg_ cid3reli ˆc1 ˆck ˆc1 ˆck cid3reliˆc1 ˆck neg_ cid3reli ˆc1 ˆck cid3reli I cid3reli II cid3reli III ˆc1 ˆck cid3reliˆc1 ˆck neg_ cid3reliˆc1 ˆck τ cid2rel1reln1 I cid2rel1reln1 III τ τ ˆc1 ˆck τ ˆc1 ˆck τ ˆc1 ˆck τ cid3rel1 I cid3reli III ˆc1 ˆck cid14 ˆc1 ˆck cid3rel j II n2 j1 jcid13i τ ˆc1 ˆck cid3reln1 I 1 n1 1 n1 1 n1 1 n1 1 n1 1 n1 Fig 11 Computation multidimensional relation types ˆc j ˆd1 j ˆdn2 j 1 j k The negations neg_cid13rel1 neg_cid13rel2 computed similarly 62 neg_cid13rel1 ˆX1 ˆY 1 ˆX2 ˆY 2 rel1X1 X2 mX1 Y 1 ˆX1 ˆY 1 mX2 Y 2 ˆX2 ˆY 2 neg_cid13rel2 ˆX1 ˆY 1 ˆX2 ˆY 2 rel2Y 1 Y 2 mX1 Y 1 ˆX1 ˆY 1 mX2 Y 2 ˆX2 ˆY 2 2 Compute types abstract relation cid3reli 1 2 objects ˆCi ˆXi ˆY 1 2 63 ˆC1 ˆC2 cid15reli ˆC1 ˆC2 neg_ cid15reli ˆC1 ˆC2 ˆC1 ˆC2 cid15reli ˆC1 ˆC2 neg_ cid15reli ˆC1 ˆC2 cid15reli τ I cid15reli τ II cid15reli III ˆC1 ˆC2 cid15reli ˆC1 ˆC2 neg_ cid15reli ˆC1 ˆC2 τ 3 Compute types joint abstract relation cid3rel cid3reli 1 2 ˆC1 ˆC2 τ cid13rel1 II cid13rel2 I cid15rel cid13rel1 ˆC1 ˆC2 τ τ I I cid15rel III ˆC1 ˆC2 τ τ cid13rel1 cid15rel III ˆC1 ˆC2 τ τ III ˆC1 ˆC2 cid13rel2 III cid13rel2 II ˆC1 ˆC2 ˆC1 ˆC2 ˆC1 ˆC2 τ ˆC1 ˆC2 τ The mapping 60 shown Fig 10c gives types τ ing abstract pairs cid15rel I cid15rel a1 b1 a1 b2 τ I a2 b1 a2 b2 τ cid15rel III remain Fig 11 presents multidimensional case computing abstract ktuple relations given relations rel1 reln1 variables cid3D1 cid3Dn2 We assume simplicity uniform arity k Note joint abstract relation cid15rel type τ computation needed abstract rule construction cid15rel combination deals types I III To emphasize abstracted relations denote cid15rel τ relations abstract relation built joint relation type rel1 X1 X2 X1 X2 rel2Y 1 Y 2 Y 1 Y 2 write τ τ cid15rel II The multidimensional abstraction constructs abstract structure object abstracted sorts combinations abstract sorts yield valid object To illustrate Example 51 color cluster cid13rgb considered node cluster ˆ4 This needs taken account constructing abstract program I III Example 57 The abstract program Sudoku 5759 occurrences row X columnY replaced cell X Y follows hasNumX Y solX Y N cellX Y solX Y N occupiedX Y numN cellX Y solX Y N occupiedX Y numN isSingletonX cellX Y solX Y N occupiedX Y numN isSingletonY cellX Y hasNumX Y cellX Y solX1 Y 1 M solX2 Y 2 M τ solX1 Y 1 M solX2 Y 2 M τ I I X1 Y 1 X2 Y 2 cellX Y 1 cellX2 Y 2 X1 Y 1 X2 Y 2 cellX1 Y cellX2 Y 2 35 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 a1 a2 a34 a5 a6 a78 1 2 b12 3 b34 b1 b2 b3 b4 b5678 4 b5678 Fig 12 Quadtree representation regions a1234 a5678 513 Reﬁnement multidimensional abstractions The reﬁnement method introduced Section 4 multidimensional abstractions For work need ktuples abstraction occur rules For example 2dimensional ab straction pairs X Y appear rules This ensure metaprograms constructed Deﬁnitions 44 45 abnormality atoms contain tuples The nonground query Q m ˆI Deﬁnition 43 updated mappings form m X1 Y 1 ˆX1 ˆY 1 instead m X1 ˆX1 The program cid2hint gets hints reﬁnec1 cn cluster reﬁne Deﬁnition 47 needs updated reﬁne multidimensional abstraction mapping For example case 2 dimensional abstraction mapping cxi c yi argab_deactnr cx y cx y cx1 c y1 cxn c yn reﬁnecx y ab_deactnr cx y mcxi c yi axi yi isSingletonaxi reﬁnecx y ab_deactnr cx y mcxi c yi axi yi isSingletona yi 68 69 In fact focus abstract region needs reﬁned use atoms reﬁneaxi yi heads rules 68 69 decide reﬁnement region axi yi A similar change needed ab_deactConsnr ab_act After changes reﬁnement method applied multidimensional abstractions More information approach deciding reﬁnement implementation given Section 622 52 Quadtree abstraction Gridcell environments particular type environment describes structure For problems gridcells case certain parts environment crucial ﬁnding solution In order obtain abstraction gridcell allows adjust granularity multidimensionality considered Multidimensional abstraction allows express abstractions sort domain X coordinate abstracted depending context depending second sort domain occurs Y coordinate For systematic reﬁnement abstractions gridcell environments consider generic quadtree representation Fig 12 concept path planning 69 Initially environment abstracted regions n2 n2 gridcells This amounts tree leaf nodes correspond main regions Each region contains 4 leaves smaller regions The leaves quadtree original cells gridcell level 0 A reﬁnement region amounts dividing subregions sprouting respective node children Given original X Y coordinates a1 b1 bn respectively represent coordinates abstract region level log2k1 0 k n deﬁned cells coordinates ai aik b j b jk respectively shorthand notation aiik b j jk Starting initial abstraction level log2n quadtree split operations abstraction reﬁnement operations automatically search suitable quadtreestructured abstractions grids Section 622 Importantly multi dimensional abstraction reﬁnement structure aware reﬁning squares quadtree area 3 Fig 12 maintains structure abstraction squares We illustrate structure adjust granularity abstraction gridcell Example 58 Reachability Suppose wants check cells reachable given starting point grid obstacles In case unreachable cells obstacles separating cells For person glance area obstacles suﬃcient realize cells unreachable The rules compute obstaclefree cells points reachable starting point additional constraint 75 checks points reachable pointX Y obsAtX Y rowX columnY 70 36 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Fig 13 Original gridcell domain Initial abstraction b Distinguishing obstacles cause unreachability starta1234 b1234 obs Ata1234 b1234 obs Ata1234 b5678 obs Ata5678 b1234 obs Ata5678 b5678 starta12 b12 obs Ata1 b4 obs Ata2 b4 obs Ata3 b5 obs Ata4 b6 obs Ata3 b7 obs Ata4 b8 obs Ata12 b12 obs Ata5678 a1234 obs Ata5678 a5678 Fig 14 Abstractions gridcell domain obstacles Fig 13 reachableX Y startX Y reachableX1 Y 1 reachableX Y pointX1 Y 1 neighborX Y X1 Y 1 neighborX Y X1 Y X X1 1 columnY neighborX Y X Y 1 Y Y 1 1 rowX pointX Y reachableX Y rowX columnY 71 72 73 74 75 Fig 13 shows instance gridcell domain obstacles program unsatisﬁable unreachable cells lower left area Fig 14 shows abstractions gridcells including abstracted start obstacle positions initial abstraction dividing gridcell 4 regions Fig 14a abstraction distinguishes area shows obstacles causing unreachable cells lowerleft corner Fig 14b Appendix B3 provides detailed example applying automatic reﬁnement Section 513 mDASPAR tool Section 622 example 6 Implementation evaluation 61 Overall methodology The abstraction reﬁnement method domain abstraction shown Algorithm 2 In initialization phase abstract program constructed mapping m depending mode abstraction lifted existential built ins Line 2 relation types computed step After constructing debugging program Line 3 abstract answer set computed Lines 5 concreteness checked function getASWithMinAbAtoms nonground query Q m ˆI minimal number ab atoms If positive ˆI spurious m reﬁned given ab atoms check Line 9 abstract program relation types recomputed looping evaluation Among possible variations algorithm want mention following Deﬁnition 43 m ˆI Line 6 returns answer set cid2debug Q m ˆI Abstraction subdomainssorts For abstraction particular subdomain resp sort Algorithm 2 extended predicate s sort input computation abstract program relation types debugging program focused domain elements related s Correctness checking relevant atoms The correctness checking abstract answer sets conﬁned relevant atoms describing solution constructing Q m Line 6 atoms An abstract answer set pass ˆI concrete long describes concrete solution respect 37 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Algorithm 2 DomainAbsRef Input program cid2 domain mapping minit mode lifted existential Output cid2m mapping m reﬁning minit abstract answer set ˆI cid2m resp cid2m unsatisﬁable 1 m minit 2 cid2m Tm constructAbsProgcid2 m mode 3 cid2debug constructDebugProgcid2 4 A Scid2m Tm cid13 Get ˆI A Scid2m Tm 5 C getASWithMinAbAtomscid2debug Q m 6 ˆI Cab ˆI concrete 7 return cid2m m ˆI 8 9 10 11 return cid2m m m decideReﬁnementm Cab cid2m Tm constructAbsProgcid2 m mode Diverse abstract answer sets The reﬁnement decision looking multiple abstract answer sets single Lines 58 changed collect checking results C1 Cn abstract answer sets I1 In decideReﬁnement use collected results C1ab Cnab assumed nonempty deciding reﬁnement We v1 reﬁnement approach answer set Ci cost aggregated collection picked reﬁnement approach v2 decides choosing reﬁne atom occurs frequently answer sets C1 Cn 62 Implementation The methodology Section 61 implemented tools called DASPAR mDASPAR based clingo 522 Python Ouroboros debugging tool 93 MetaTranslator exploited obtain reiﬁed program debugging program constructed cf Section 4 negative cycles merged described Section 323 More tails provided subsections The implementations online available httpwwwkrtuwien ac research systems abstraction 621 DASPAR The program DASPAR supports abstraction sorts input program cid2 adhere certain restrictions variable rule guarded domain predicate abstraction subset S sorts variables referring sorts S standardized apart For example rule form aX bX X1 cX2 dX2 X X1 needs converted aX bX X1 cX2 dX3 X X1 X2 X3 domX domX1 domX2 domX3 domain predicate dom In order support case having relation syntactic change rule These relations need combined auxiliary relation atom represents combination relations The rule needs converted aX bX X1 cX2 dX3 leqEqu4X X1 X2 X3 leqEqu4 X X1 X2 X3 auxiliary atom holds true respective relation holds true arguments A basic set auxiliary relation combinations built tool easily added DASPAR invoked follows python dasparpy prog mapping pred ref_type focus_atoms Here prog contains original program input format mapping abstraction mapping information DASPAR supports abstraction sort Section 622 multidimensional tool mDASPAR pred sort abstracted The parameter ref_type allows specify reﬁnement respect order relation 1 0 Section 331 If 1 given reﬁnement step considers splitting domain 0 given reﬁnement step unrestricted The parameter focus_atoms optional input projection correctness check Section 61 DASPAR different settings picking abstract answer sets deciding reﬁnement For default ﬁrst computed answer set picked This changed considering diverse set abstract answer sets For deciding reﬁnement forms mentioned Section 4 implemented Later evaluate effects having different settings methodology achieved resulting abstractions 38 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 pointXY obsAtXY rowX columnY reachableXY startXY rowX columnY reachableX1Y1 reachableXY pointX1Y1 neighborX2Y2X3Y3 equEqu4XX2X1X3 equEqu4YY2Y1Y3 rowX columnY rowX1 columnY1 rowX2 columnY2 rowX3 columnY3 pointXY reachableX1Y1 XX1 YY1 rowX columnY rowX1 columnY1 neighborXYX1Y1 dist1XX1 YY1 rowX columnY rowX1 columnY1 neighborXYX1Y1 XX1 dist1YY1 rowX columnY rowX1 columnY1 Fig 15 Input program rules 7075 Subdomain predicates row column For practical purposes sorts overlapping provided occurrences sort guarded subdomain predicates Eg blocksworld sorts block time use integers Note restriction aid machine knowing relations arguments user implicitly knows encoding problem With guidance clear arguments rule abstraction focus 622 mDASPAR The program mDASPAR extends DASPAR multidimensional domain abstraction It handles 2dimensional abstractions quadtree style reﬁnement process applied problems cells grids size n 2k k 2 We discuss challenges multidimensional abstractions tackled Abstract objects A multidimensional abstraction creates abstract objects tuples concrete objects combinations abstracted sorts row column correspond valid object To avoid combinations constructed abstract program comply abstract objects rules For mDASPAR postprocesses abstract program replaces occurrence abstracted sorts new object Note grouping objects automatically correctly needs guidance For given encoding humans capable detecting cells implicitly machine readily The user provide guidelines recognize objects adjusting encoding grids explicitly shown For impose syntactic restrictions input program postprocessing technique relies Given sorts s1 s2 2dimensional abstraction input program adhere following restrictions order achieve correct object naming 1 The rules atoms contain pairs X Y variables X s1 Y s2 2 subdomain predicates sorts s1 s2 written order pairs If restrictions satisﬁed mDASPAR correctly convert sort names abstract object cell For example row X1 columnY 1 changed cell X1 Y 1 Example 61 ctd The rule 72 standardized apart reachableX1 Y 1 reachableX Y pointX1 Y 1 neighborX2 Y 2 X3 Y 3 X X2 X1 X3 Y Y 2 Y 1 Y 3 Then multiple relations related sort converted auxiliary relation atom reachableX1 Y 1 reachableX Y pointX1 Y 1 neighborX2 Y 2 X3 Y 3 equEqu4X X2 X1 X3 equEqu4Y Y 2 Y 1 Y 3 The subdomain predicates rule need written format pairs X Y X1 Y 1 X2 Y 2 X3 Y 3 appear Fig 15 shows resulting rules input program including subdomain predicates Relation type computation When abstracting rule mDASPAR gathers relations related abstracted sorts creates abstract relation atom following description Section 5 The relation type facts τ computed auxiliary programs The program mDASPAR invoked similarly DASPAR additional parameter size number n The example shows input format mDASPAR created abstract program Example 62 ctd Fig 15 shows input program mDASPAR rules 7075 variables standardized apart The program constructed abstracting sorts row column shown Fig 16 occurrence sorts renamed new object cell The rules original program numbered r1 r6 relation 39 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 pointXY cellXY obsAtXY pointXY cellXY obsAtXY isSingletonX pointXY cellXY obsAtXY isSingletonY reachableXY startXY cellXY reachableX1Y1 reachableXY pointX1Y1 neighborX2Y2X3Y3 cellX2Y2 cellX3Y3 cellXY cellX1Y1 relr3XYX2Y2X1Y1X3Y3i reachableX1Y1 reachableXY pointX1Y1 neighborX2Y2X3Y3 cellX2Y2 cellX3Y3 cellXY cellX1Y1 relr3XYX2Y2X1Y1X3Y3iii pointXY cellXY cellX1Y1 reachableX1Y1 relr4XYX1Y1i neighborXYX1Y1 dist1XX1 cellXY cellX1Y1 relr5YY1i neighborXYX1Y1 dist1XX1 cellXY cellX1Y1 relr5YY1iii neighborXYX1Y1 dist1YY1 cellXY cellX1Y1 relr6XX1i neighborXYX1Y1 dist1YY1 cellXY cellX1Y1 relr6XX1iii Fig 16 Nonground abstract program constructed mDASPAR atoms abstract program named wrt rule number For example constraint 75 numbered r4 standardization creates relations X X1 Y Y 1 abstraction joint relation type atom τ X Y X1 Y 1 I body unsatisﬁable gets omitted abstraction similar omitting 14 Example 313 X Y X1 Y 1 type I The abstracted constraint containing type III relation atom τ III Furthermore standardizing apart variables negative literal 75 relaxes aim ensuring points reachable hold abstraction reﬁned satisfy relation atom relr4XYX1Y1i Having 75 standardization ensure satisﬁed coarser abstractions We standardized apart variables negative literal obtain ﬁnegrained abstractions distinguish original cells reach concrete solution This makes easier visualize resulting abstractions understand solutions obtained 623 Implementation aspects mDASPAR Twophase debugging The multidimensionality domain mapping gives rise possible causes spuriousness Debugging nonground spuriousness searching answer set smallest number ab atoms diﬃcult To handle implemented twophase debugging approach In phase 1 debugging program cid2debug created modifying debugging atoms ab_deact ab_deactCons Deﬁnition 45 rule argu ments We denote program cid2debug0 This results easier computation answer set minimal ab atoms In phase 2 new program cid2debug created according original deﬁnition ab atoms created rule names atoms occurring ab atoms I This way search optimal answer set focuses troublemaking rulesatoms Steer debugging constraints In problems focus constraints program cause unsatisﬁ ability obtain particular solution given instance In order help reaching abstractions relevant constraints distinguished assign cost obtaining answer sets ab_deactCons atoms optimal answer set search debugging Getting hints Since reﬁnement region means split subregions need hint region reﬁne This different hints obtained DASPAR decision reﬁnement relies domain elements occurring debugging atoms We alter reﬁne atoms information abstract domain occurs reason spuriousness Modular concreteness checking In cases twophase checking help easily ﬁnding optimal answer set debugging step original domain large atoms cause consider possible concretizations We considered orthogonal approaches 1 For programs modular contain clear order atoms plan checking incrementally approach similar spirit 53 builds concept modules 94 2 Using hierarchy abstractions possible Proposition 36 checking incrementally concretizing abstract domain following iterative deepening style Fig 17 The aim Approach 1 avoid checking ordered sequence atoms plan catching spuriousness preﬁx Approach 2 applied avoid making concreteness check directly original domain If abstract answer set spurious detected partially concretized domain We check correctness ˆI abstract level mi cid2mi If ˆI concrete wrt partially concretized abstraction concretization 40 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Fig 17 Stepwise partial concretization gridcell abstraction increased redoing check However spuriousness detected mapping reﬁned partial concretization continues updated mapping Further details implementation Appendix B4 63 Evaluation obtaining abstract solutions The main aim evaluation domain abstraction reﬁnement method ﬁnd automatically nontrivial domain abstractions yield concrete answer sets We wanted observe effect variants picking abstract answer sets Section 61 making reﬁnement decisions Section 4 631 Experiments We DASPAR v02 experiments employs sophisticated debugging program concreteness check ing5 The variations considered follows When computing abstract answer sets s pick single abstract answer set div pick diverse set answer sets wrt focus atoms Deciding reﬁnement v1 assigning costs possible reﬁnements picking smallest cost v2 hints obtained debugging atoms checking For v2 ensured distinct domain elements picked debugging atom occur cluster We conducted experiments benchmark problems ASP competitions viz graph coloring disjunctive scheduling For graph coloring randomly generated 20 graphs 10 nodes edge probability 01 02 05 100 graphs 74 3colorable We different graph coloring encodings shown Fig 18 effect resulting abstractions In ﬁrst encoding GCenc1 Fig 18a color assignment node guessed 7678 common approach default negation auxiliary atom hasEdgeTo X C shows colors C node X neighbors The second encoding GCenc2 Fig 18b uses choice rule 83 guess assignment ensures 84 node assigned color The rules 8586 alternative way writing rule chosenColor X1 C chosenColor X2 C edge X1 X2 X1 X2 variables standardized apart sort node fewer relation atoms occur rule Also notice GCenc2 imposes order relation nodes reduce duplications constraints For disjunctive scheduling t 10 20 30 generated 20 instances 5 tasks time 1 t We encoding6 ASP Competition 2011 precomputed deterministic involved unstratiﬁed negation resp guesses program lifted abstract program introducing unnecessary nondeterminism Appendix B2 The initial abstraction mapping singlecluster abstraction clustering nodes graph coloring time points disjunctive scheduling In experiments use lifted relation approach While existential abstraction relations Section 51 fewer relation types consider observed improvement computation effort type III abstract relations combination type III IV lifted relations Thus difference relation type approach experiments 5 Results version v01 reported 113 6 wwwmat unical aspcomp2011 ﬁles DisjunctiveScheduling disjunctive _scheduling enc asp 41 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 chosenColor X r chosenColor X g chosenColor X y node X chosenColor X g chosenColor X r chosenColor X y node X chosenColor X y chosenColor X g chosenColor X r node X hasEdgeTo X C edge X Y chosenColorY C hasEdgeTo X C chosenColor X C colored X chosenColor X C node X colored X chosenColor X C node X colorC GCenc1 chosenColor X C1 chosenColor X C2 C1 cid13 C2 adj X Y edge X Y X Y adj X Y chosenColor X C chosenColorY C colored X chosenColor X C node X colored X b GCenc2 76 77 78 79 80 81 82 83 84 85 86 87 88 Fig 18 Two encodings Graph Coloring problem GCenc1 GCenc2 Table 4 Experimental results graph coloring GCenc1 GCenc2 number steps abstraction domain size faithful abstraction domain size trivial abstractions id faithful nonid abstractions nonfaithful abstractions number steps abstraction domain size faithful abstraction domain size trivial abstractions id faithful nonid abstractions nonfaithful abstractions projected s div s div v1 738 838 684 13 30 57 701 801 888 19 22 59 v2 783 884 804 23 32 45 640 864 862 13 24 63 v1 704 804 612 4 29 67 656 756 797 5 25 70 v2 769 869 751 12 27 61 637 829 866 13 22 65 v1 524 624 602 2 56 42 353 453 486 3 54 43 v2 648 748 571 1 61 38 376 673 544 2 59 39 v1 483 583 565 2 50 48 340 440 475 3 54 43 v2 614 714 582 2 47 51 352 636 572 2 48 50 632 Results We report average results 10 runs variation To ease presentation discuss results benchmark separately concentrating different observations experimental evaluation Graph coloring The evaluation results obtained abstractions presented Table 4 The ﬁrst rows average number reﬁnement steps average domain size number clusters resulting abstractions The best abstraction smallest domain size instance runs checked faithfulness observe corresponding abstract program contains concrete answer sets The domain size faithful abstractions shown row The frequencies abstractions trivial faithful nontrivial faithful nonfaithful shown rows The left column shows results concreteness checking different variations We observe deciding reﬁnement based single abstract answer set s results ﬁner abstractions larger domain size diverse set abstract answer sets div The number trivial abstractions obtained smaller div better decisions chance encountering concrete abstract answer set larger The causes obtain nonfaithful abstractions reﬁnement abstraction spurious answer sets As v2 decide reﬁnements observe better obtaining coarser abstractions minimal 42 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Table 5 Experimental results scheduling time t 10 t 20 t 30 number steps abstract domain size calls abstract program calls debugging program number steps abstract domain size calls abstract program calls debugging program number steps abstract domain size calls abstract program calls debugging program v1 722 822 4135 4090 1471 1571 16848 16828 2282 2382 39188 39143 s v2 481 848 581 536 765 1416 865 845 957 1902 1057 1012 v2 356 846 456 411 547 1412 647 627 776 1912 876 831 v1 604 704 4072 5630 1200 1300 15741 24445 2057 2157 36609 58023 div v2 481 838 581 687 753 1416 853 1208 956 1907 1056 1459 v2 354 835 454 544 533 1381 633 874 768 1868 868 1224 cost method v1 general yields trivial abstractions v1 splitting domain repeatedly break clusters certain abstract elements quickly ends original domain The right column shows results projected notion concreteness limits checking set relevant atoms picked nodes 123 assigned colors As expected concrete abstract answer set encountered coarser abstractions colors assigned nodes matter In case projection trivial abstraction reached nontrivial faithful abstractions reached This beneﬁcial computed abstractions obtain concrete solutions nodes focused The main difference encodings size achieved abstract domains GCenc2 requires fewer reﬁne ment steps achieve abstraction concrete solution GCenc1 need preserve node ordering leaves fewer reﬁnement possibilities On average resulting abstractions coarser GCenc1 domain sizes faithful abstractions larger This choice rule GCenc2 causing spurious answer sets treated reﬁnement steps Disjunctive scheduling We compared effects variations resulting abstractions calls ASP solver obtain abstract answer set respectively check concreteness debugging Table 5 shows collected results For reﬁnement search considered v1 v2 variant v2 v2 abstract element obtained debugging atom mapped singleton cluster reﬁnement As expected minimal cost method v1 causes calls ASP solver cost possible reﬁnement computed While achieves coarser abstractions half cases large number calls clear disadvantage For example case t 20 v1 achieves div average abstract domain 1300 clusters 400 calls ASP solver v2 achieves average 1381 clusters 15 calls For instances t 20 reﬁnement hints v2 achieves coarser abstractions v1 single abstract answer sets picked Here hints guide reﬁnement better cost single abstract answer set For cost diverse set abstract answer sets signiﬁcantly coarser abstractions achieved Looking t 30 observe cost approach v1 results ﬁner abstractions hint based approaches v2 v2 provide better guidance This shows local search 1step reﬁnements yield best outcome expensive cid3 We observe v2 achieves coarser abstractions v2 immediately singling domain elements connected spuriousness helps It needs smallest number reﬁnement steps compared approaches reaches concrete solution faster reﬁnement decisions The results larger domains effect abstraction seen better best abstract domain size reached t 10 average 704 70410 original domain size t 30 shrinks 62 186830 Summary The results domain abstraction possible achieve concrete solutions abstracting details program Reaching faithful abstractions desired occur projected concreteness check considered distinguishes details relevant solution problem Obtaining hints set abstract spurious answer sets instead single answer set results better decisions coarser abstractions 64 Evaluation unsolvable problem instances gridcells We investigated obtaining explanations unsatisﬁable gridcell problems achieving abstraction instance focus troubling area We considered following benchmark problems 43 cid3 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 cm 4231 642161 0076 b cm 20231 642161 0299 Reachability R This problem needs neighboring cell information encoded introducing guesses Fig 19 Measure quality quadtree abstraction We check cell reachable unsatisﬁability layout obstacles Knights Tour KT This problem ﬁnding tour knight visits square board returns starting point It commonly ASP Competitions possible addition forbidden cells Unsolvability forbidden cells prevent knight moving In ASP competitions problem encoded guessing set X1 Y 1 X2 Y 2 atoms ensuring cell incoming outgoing movement7 There time sort planning order Visitall We extended planning problem visiting cell revisiting cell obstacles This problem needs neighboring cell information encoded forms V planning problem order ﬁnd sequence actions visits cell VKT combinatorial problem similar Knights Tour encoding To allow shorter plans encoded V X Y T actions horizontallyvertically cell X Y passing obstacles passed cells visited set limit 30 time steps Sudoku S This problem ASP competitions8 Its encoding consists guess numbers cells combined simple constraints symbol column symbol subregion The unsolvability occurs violation constraints We generated 10 unsatisﬁable instances complying following properties unsolvability explained focusing troubling area9 In Reachability instances group neighboring cells unreachable obstacles surrounding For Knights Tour instances cells picked valid movement obstaclefree cell This way cells obstacles allow valid movements reason unsolvability The Visitall instances consist deadend cells areas cell passage forced pass cells allowed For Sudoku generated layout numbers force violate constraints solving problem Measuring abstraction quality We consider quality measure quadtree abstraction normalizing number abstract regions certain size level quadtree The cost mapping m n n grid cm cid8cid16 i0 r2i mcid8 cid17 cid8cid16 i0 i2 n22 cid8 cid8 log2n 1 level r2i m number abstract regions size 2i 2i m n22 number abstract regions size 2i 2i n nsized cell The factor cid8i weight gives higher cost abstractions lowlevel regions An abstraction mapping smaller cost intuitively smaller level considered better quality i2 Fig 19 shows measures abstraction mappings The abstraction Fig 19a coarser Fig 19b reﬂected computed measures Assigning weight having coarser regions stress importance having coarse abstraction The computation measure purely structural domainindependent Other measures deﬁned dependent domain considers aspects abstraction singles smallest number cells obstacles preferred 7 wwwmat unical aspcomp2013 KnightTour 8 dtai cs kuleuven events ASPcompetition Benchmarks Sudoku shtml 9 All benchmark instances encodings user explanations Visitall Reachability available wwwkrtuwien ac research systems abstraction mdaspar _material zip 44 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Table 6 Evaluation results applying different debugging approaches debugging type default 2phase default 2phase 2phase gridinc 2phasea timeinc 2phase gridinc average minimum steps 54 55 65 43 143 101 162 163 157 130 cost 0227 0233 0696 0476 0643 0442 0708 0712 0693 0569 steps 54 53 51 34 104 63 139 135 130 103 cost 0227 0222 0550 0391 0460 0277 0608 0569 0572 0449 R S KT V VKT best steps cost 50 32 56 87 76 0208 0371 0245 0360 0317 A total 16 runs completed memory errors The results computed runs completed inst 10 b V spurious action transitions c VKT separate action sequences visit cells reachable singlecell passages Fig 20 Spurious plans abstractions distinguish singlecell passages 641 Effects different debugging approaches We compared different debugging approaches Section 623 observe effects resulting abstractions taken reﬁnement steps Due encodings constraints Knights Tour Visitall problems challenging ones To observe incremental checking help deciding reﬁnement achieve better abstractions applied KT VKT partial concretization V incremental time checking To evaluate far sulting abstraction best possible abstraction showing unsolvability checked coarser abstraction property exists Table 6 shows main evaluation results We compare different debugging approaches terms average ﬁnement steps average costs resulting abstractions 10 runs best outcome obtained minimum reﬁnement steps minimum mapping cost The rightmost columns concern existence coarser abstraction best outcome obtained The time ﬁnd optimal solution debugging step limited 50 seconds If exceeded reﬁnement decided basis suboptimal analyses considering optimal debugging solution computed time limit For Reachability Sudoku observe abstractions close best possible ones obtained Better ab stractions obtained 2phase debugging cases majority clear margin S ﬁrst step focus right abstraction For Knights Tour Visitall observe incremental checking obtain better abstractions This 2phase debugging programs timeouts decide suboptimal concreteness checking outputs Moreover V encoding 2phase debugging caused memory outages limit 500 MB runs instances 10 runs completed We difference resulting abstractions encodings Visitall The planning encoding achieves unsatisﬁability coarse abstractions Guesses spurious sequences actions abstraction cause debugging decide reﬁnements avoid sequences The focus moves unsolvability abstract action sequence executable obstacle In instances reason unsolvability easily caught having deadends focusing existence obstacles achieve unsatisﬁability abstract encoding manages ﬁnd plan passing different sized regions avoiding constraints uncertainty For instances abstraction needs ﬁnegrained rid uncertainty Fig 20a shows example instance An abstraction distinguishes onepassageentries obsta cles surround cells achieve unsatisﬁability encoding V Fig 20b shows spurious action transitions 45 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Fig 21 Explanatory abstractions unsatisﬁable Reachability instances determined plan V encoding regions avoiding constraints uncertainty Unsatisﬁability achieved VKT This guess atoms achieve cell visited lack corresponding original order movements Fig 20c shows spurious order movements split visit cell reachable onepassageentry If abstraction reﬁned distinguish cells respective corners unsatisﬁability realized 642 User study unsatisﬁability explanations We interested checking obtained abstractions match intuition human explanation For Reachability Visitall ﬁnding reason unsolvability instance possible looking obstacle layout Thus conducted user study problems order obtain regions humans focus realize unsolvability problem instance As participants PhD students Computer Science TU Wien We asked mark area shows reason having unreachable cells Reachability instances reason ﬁnding solution visits cells Visitall instances multiple reasons mark different colors Explanations 10 instances problem collected9 We discuss results problems showing responses expected unexpected best abstraction obtained mDASPAR starting initial mapping Reachability The expected explanations Figs 21a 21d focus obstacles surround unreachable cells prevent reachable When respective abstraction mappings given mDASPAR constructed abstract program unsatisﬁable The explanation Fig 21b puts focus unreachable cells Fig 21e distinguishes particular obstacle reason The mark Fig 21e actually possible solution unreachability cells removing marked obstacle makes cells reachable When respective abstraction mappings given mDASPAR needs reﬁne abstraction distinguish obstacles realize unsatisﬁability In ASP checking cells reachable straightforward introducing guesses This observed helpful mDASPAR resulting abstractions similar gathered answers Since initial abstraction abstract program knows agent located upperleft abstract region instance 10 mDASPAR follows different path reﬁning abstraction reaches abstraction shown Fig 21f Although different users shows reason having unreachable cells Humans use implicit knowledge agent located upperleft corner order determine reason unreachability cells focus different area mDASPAR Such abstraction achieved method inﬂuencing reﬁnement decisions singling initial location agent The abstractions achieved mDASPAR general precise initial location agent immaterial distinguish unreachable cells cells mapped respective abstract region The precise obstacle layout abstracted regions plays role determining unreachability distinguished cells 46 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Fig 22 Explanatory abstractions unsatisﬁable Visitall instances Visitall Most users picked deadend cells instances occur explanation unsatisﬁability instead obstacles surrounding cells Fig 22a actual cause deadend cells Even abstraction mappings distinguish surrounding obstacles deadend cells corresponding abstract program remains satisﬁable Then mDASPAR needs reﬁne abstraction distinguish neigh boring cells Fig 22c realize pass gridcell reaching deadend cells achieve unsatisﬁability Unexpectedly users marked deadend cells explanation Fig 22b actually focusing possible solution unsolvability marked area deadend cells visited Some instances contain deadend cells singlecell passages regions Fig 22d shows entry distinguishes passages focusing cells For instances results mDASPAR different A discussion having abstraction distinguishes onepassageentries obstacles surround cells achieve unsatisﬁability given Fig 20 Section 641 Fig 22f shows best abstraction achieved VKT Instead focusing passages distinguishes cells onepassageentry regions realize desired action sequence manage visit cells revisiting The generality achieved abstractions observable precise agent position obstacle layout abstracted areas change unsatisﬁability result cells distinguished parts visited Observations The abstraction method demonstrate capability humanlike focus certain parts grid unsolvability reason However humans implicitly use background knowledge need explic itly state relations objects Empowering machines capabilities remains challenge The study showed difference understanding meaning explanation For study participants showing rid unsolvability seen explanation This discrepancy shows needs clearly specify wanted mark obstacles cause unreachable cells achieve variety results 7 Discussion In section ﬁrst discuss possible way achieve abstraction predicates method focus ASP planning use case order highlight potential domain abstraction ﬁnding essence planning problems After discuss related work literature 71 Predicate abstraction Predicate abstraction ASP introduce literals involving new predicates abstraction original literals rewriting program mention new literals Naively replacing literals abstract ones achieve overapproximation 47 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Example 71 Example 31 ctd Consider predicate abstraction maps atoms X d X ad X ad dd holds true d D add holds true When replace datoms Example 31 obtain following program bX Y adX adY eX cX adY X cid13 Y bX Y eX ad1 ad3 c2 ad5 However answer set program contains b1 1 b3 1 match original answer set A simple way achieve predicate abstraction domain abstraction reiﬁcation predicates original program For example p X Y written xp X Y sort predicate names viewed constants introduced By standardizing apart variables predicate names clustered builtin relations Example 72 ctd Rewriting atoms X d X xa X xd X respectively yields program bX Y xP 1 X xP 2 Y P 1 P 2 d predP 1 predP 2 eX cX xP Y P predP X cid13 Y bX Y eX xa 1 xa 3 c2 xd 5 preda predd Then abstraction m sort pred dcid17ad applied This approach works predicate abstraction corresponding literals arguments sort argument position In case literal fewer arguments dummy values ﬁll remaining argument positions Another way achieve predicate abstraction following motivation existential abstraction rela tions The idea introduce new set predicates relation types according abstraction abstract rules formed combinations abstraction types bodies choice added head type I Example 73 ctd Similar Example 71 abstract predicate ad introduced relation type τ ad III Note arguments literal important abstraction predicate domain elements The abstract program follows bX Y adX adY τ ad III eX cX adY τ ad III X cid13 Y bX Y eX ad1 ad3 c2 ad5 We remark approach similar rewriting original program reiﬁcation predicates applying existential abstraction relations 72 Use case abstraction ASP planning Domain abstraction gives possibility adjust granularity problem relevant details By achiev ing abstract answer sets concrete catch relevant details allows problem solving abstract notions useful wide range applications We discuss possible use domain abstraction ASP planning particular understanding planning problems expressed ASP abstracting unnecessary details Another use case policy refutation described Appendix C Planning problems ASP represented time sort sequence states changes according actions taken 77 There usually types objects represented different sort types objects actions direct effect blocks blocksworld moved 48 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Fig 23 Initial state blocksworld multiple tables concrete m abstract objects unaffected actions involved decision making table blocksworld blocks moved We discuss use domain abstraction objects talk abstract states plans Describing actions ASP First emphasize blocksworld example different ways expressing planning prob lems ASP The effects moving block block expressible following rules onBB B1 T 1 moveToBlockB B1 T onBB B2 T onBB B1 T B1 cid13 B2 89 models direct 90 indirect effect Alternatively effects expressed direct effects onBB B1 T 1 moveToBlockB B1 T onBB B2 T moveToBlockB B1 T B1 cid13 B2 89 90 91 92 The preconditions action described constraints condition action applicable For example block sit block smaller expressed constraint onBB B1 T B1 B Alternatively respective action forbidden condition satisﬁed following rules moveToBlockB B1 T precondmtbB B1 T precondmtbB B1 T B B1 blockB blockB1 Note alternative version closer PDDLstyle encoding The law inertia described rule onBB B1 T 1 onBB B1 T onBB B1 T 1 721 Abstracting irrelevant details We ﬁrst possibility abstraction details objects indirectly affected actions For demonstration consider extensions wellknown planning domains Multitable blocksworld MTB blocks moved multiple tables table hold multiple blocks plan needed piles blocks given speciﬁc table Package delivery checkpoints PDC packages carried initial goal location passing checkpoint reachable initial location Multitable blocksworld Fig 23 illustrates instance MTB blocks piled table t1 b1 b2 b2 b3 Here reaching goal state depend concrete tables blocks moved moving goal table However computing plan based original program planner consider possible movements Fig 24 shows natural encoding problem actions moveToTB Ta T moveToBB B T moving cid3 block B table Ta block B resp time T Consider initial state shown Fig 23 cid3 onTb1 t1 onBb2 b3 onTb3 t2 chosenTablet1 After ensuring variables guarded domain predicates related table sort standardized apart run DASPAR initial mapping t1 tncid17ˆt The abstraction obtained shown Fig 23 singles chosen table ˆt1 clusters ˆt2 We compute concrete abstract answer set moveToTb2 ˆt2 0 moveToTb3 ˆt1 1 moveToBb2 b3 2 moveToBb1 b2 3 49 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 action choice moveToBB B1 T blB blB1 moveToTB L T blB tblL 1 T tmax gaps moves doneT moveToBB B1 T doneT moveToTB L T doneT 1 doneT T tmax preconditions moveToBB B2 T onBB1 B T moveToBB B2 T onBB1 B2 T moveToTB L T onBB1 B T moveToTB L T onTB L T effects onBB B1 T 1 moveToBB B1 T T tmax onTB L T 1 moveToTB L T T tmax onBB B2 T onBB B1 T B1cid13B2 onTB L T onBB B1 T onBB B1 T onTB L T onTB L1 T onTB L2 T L1cid13L2 inertia onBB B1 T 1 onBB B1 T onTB L T 1 onTB L T onBB B1 T 1 T tmax onTB L T 1 T tmax state constraints onBB1 B T onBB2 B T B1cid13B2 onBB B1 T onBB B2 T B1cid13B2 onBB B1 T onTB L T onBB B1 T B1 B onTB L1 T onTB L2 T L1 cid13 L2 goal constraints notblockgoalT onTB L T onTB1 L1 T Bcid13B1 notblockgoalT T tmax notblockgoalT onTB L T chosenT ableL Fig 24 Encoding Multitable Blocksworld Fig 25 Initial state package delivery checkpoints concrete m abstract describes plan going table blocks moved The abstraction shows solving problem essential distinguish picked table number tables irrelevant Furthermore abstraction faithful projection actions moveToB moveToT Package delivery checkpoints Fig 25 illustrates instance PDC packages location l1 carried location l10 As locations directly connected truck pass middle point point truck passes immaterial reaching goal state For problem Nomystery encoding ASPCOMP2015 altered fuel computation shown Fig 26 Furthermore dri veT L1 L2 S action possible added additional condition locations L1 L2 connected edge edgeL1 L2 Consider initial state shown Fig 25 T t l1 0 P p1 l1 0 P p2 l1 0 P p3 l1 0 P p4 l1 0 goalp1 l10 goalp2 l10 goalp3 l10 goalp4 l10 picted edge facts Running DASPAR mapping l1 l10cid17ˆl sort location results abstraction mapping l1cid17ˆl1 l2 l9cid17ˆl2 l10cid17 ˆl3 shown Fig 25 With abstraction following concrete abstract answer set computed loadp4 tˆl1 1 loadp3 tˆl1 2 loadp1 tˆl1 3 loadp2 tˆl1 4 dri vetˆl1ˆl2 5 dri vetˆl2ˆl3 6 unloadp3 tˆl3 7 unloadp1 tˆl3 8 unloadp4 tˆl3 9 unloadp2 tˆl3 10 It describes plan loads packages moves middle cluster location moves goal location unloads packages resulting abstraction faithful projection actions load unload dri ve Domain abstraction simpliﬁed details unimportant essence plan feasible The faithful abstraction gives understanding problem realizing neuralgic points If constraints details needed construct plan faithfulness achievable nontrivial abstraction 722 Computing abstract plans Abstracting objects directly affected actions empower talk abstract plans How ASPstyle encodings abstracting object sort causes abstract program compute plans original time sort For example Package Delivery problem checkpoints locations 50 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 action choice unloadP T L S packageP truckT locL loadP T L S packageP truckT locL dri veT L1 L2 S edgeL1 L2 locL1 locL2 truckT 1 stepS S 0 gaps moves doneS unloadP T L S doneS loadP T L S doneS dri veT L1 L2 S doneS1 doneS effects P P L S unloadP T L S inP T S unloadP T L S P P L S loadP T L S inP T S loadP T L S T T L1 S dri veT L1 L2 S T T L2 S dri veT L1 L2 S precondition check unloadP T L S preconduP T L S preconduP T L S T T L S1 inP T S1 loadP T L S precondlP T L S precondlP T L S T T L S1 P P L S1 dri veT L1 L2 S preconddT L1 L2 S preconddT L1 L2 S T T L1 S1 inertia T T L S T T L S1 T T L S P P L S P P L S1 P P L S inP T S inP T S1 inP T S goal check goalP L P P L S maxstepS Fig 26 Encoding Package Delivery l1 l2 cluster packages abstract package ˆp0 Then abstract program abstract actions load ˆp0 t l s unload ˆp0 t l s lead plan load ˆp0 t l1 1 dri vet l1 l2 2 unload ˆp0 t l2 3 However plan clearly spurious original action match load ˆp0 t l1 1 loads packages step spurious answer sets result In order avoid abstraction time sort necessary By talk abstract instances actions abstract concrete order application Given sorts blocks time respectively packages time independent multiple calls DASPAR abstract sort onebyone achieves desired abstract program For Package Delivery problem consider abstraction mappings mpackage p1 p2 p3 p4cid17 ˆp mtime 1 2 3 4cid17ˆt1 5cid17ˆt2 6 7 8 9cid17ˆt3 The constructed abstract program yields abstract plan load ˆp t l0 ˆt1 dri vet l1 l2 ˆt2 unload ˆp t l2 ˆt3 abstracts order package unloading includes abstract actions time clusters Unfortunately ﬁnding suitable abstraction multiple sorts especially time domain nontrivial The abstraction time time clusters steers plan computation action ordering For example time mapping 1cid17ˆt1 2 3cid17ˆt2 4 5 6 7 8 9cid17ˆt3 abstract plan spurious To summarize use abstraction ASP planning appears attractive cognitive perspective research issues needed order unleash potential approach 73 Related work In context logic programming abstraction considered years classic work Cousot Cousot 29 However focus studies use abstract interpretations termination analysis programs stable semantics addressed The work related notion abstraction ASP simpliﬁcation methods strive preserving semantics Such methods extensively studied years overview notions Notice different simpliﬁcation methods abstraction lead overapproximation answer sets program changes semantics modiﬁed language Overapproximation abstraction reduces vocabulary makes different relaxation methods 5881 These methods translate ground program completion 24 search answer set relaxed model As focus ground programs compared abstraction omits atoms program need account loop formulas searching concrete abstract answer set However ﬁnding reason spuriousness abstract answer set trickier ﬁnding reason model program completion answer set original program abstract answer set contains fewer atoms search original program needed detect reason matching answer set 731 Equivalencebased rewriting program transformations ASP Equivalence logic programs considered answer set semantics follows program cid21 equivalent program cid22 AScid21 AScid22 Strong equivalence 80 stricter condition cid21 cid22 strongly equivalent 51 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 set R rules cid21 R cid22 R equivalent This notion makes possible replace Q cid3 logic program strongly equivalent simpler program Q looking rest 429597119 ways transforming programs ensuring property holds A liberal notion uniform equivalence 86107 R equivalent respect factual inputs 40 The notions strong restricted set facts Q Q uniform equivalence generalized relativized equivalence 43 alphabet R restricted notion addition occurrence atoms heads bodies rules R distinguished 122 relativized strong equivalence projections 56104 allows remove answer sets auxiliary atoms Relativized equivalence related projected notion concreteness certain usually auxiliary atoms considered concreteness checking Section 334 cid3 In terms abstraction abstraction mapping needs taken account constructed program contain modiﬁed language mapping relate original language Thus deﬁne equivalence original program cid2 abstraction cid2m according mapping m need compare mAScid2 AScid2m The equivalence cid2 cid2m similar notion faithfulness However shown abstract program cid2m faithful reﬁning m lead abstract program having spurious answer sets Thus simply lifting current notions equivalence abstraction achieve useful results Reﬁnementsafe faithfulness allow use cid2m instead cid2 preserves answer sets This property achieved abstract program unsatisﬁable implies original program unsatisﬁable However original programs consistent reaching abstraction reﬁnementsafe faithful easy dividing domain cluster immediately cause guess introduces spurious solutions The notions equivalence complemented ones allow relating logic programs different alphabets Correspondence frameworks ASP programs 46 triples form F U C ρ U set propositional atoms C context class programs U ρ binary relation 2 programs P Q U corresponding respect F R C answer sets P R Q R relation ρ These generic frameworks allow capture notions equivalence furthermore notion overapproximation simply expressed setting C consist program ρU cid3 check overapproximation answer sets P R answer sets Q R relative set atoms U cid3 However 46 discussed characterize equivalence correspondence frameworks ρU cid3 semantic terms nonclassical hereandthere models 98 presented general complexity results issue obtain programs Q overapproximate answer sets Q addressed furthermore setting propositional U Synonymous theories 99101 aimed lift notion strong equivalence programs setting programs formulated different languages language bijectively interpretable To end authors developed notion synonymous theories quantiﬁed equilibrium logic wellknown extension quantiﬁed logic hereandthere provides logical reconstruction answer set semantics 98 100 In notion equilibrium models synonymous theories T 1 T 2 representing logic programs onetocorrespondence remain addition new formulas suitable sense It builds deﬁnability interpretation classical logic extended nonclassical setting For Herbrand models setting synonymous theories allow domain shrinking faithful bijective interpretation property preserves sense equilibrium models permit strict overapproximation apply nonHerbrand models static domains elements clustered preserving equivalence Exploring notion overapproximation framework 98100 consider possible application interesting issue future research Other transformation methods especially help grounding solving ASP programs investigated A preprocessing technique considered 54 assignment relation expressing equivalences parts program assigned Another form preprocessing 1288 applied rule program computing tree decomposition splitting rule multiple smaller rules accordingly 732 Abstraction planning agent veriﬁcation Starting early years AI planning applications abstraction help search planning complex domains received lot attention One main research focus hierarchical planning considers different abstraction levels problem space A plan searched abstract level solution reﬁned successively detailed levels abstraction hierarchy concrete plan computed original level Sacerdoti 106 showed abstraction notion keeps critical preconditions actions ignores rest For example Knoblock 70 proposed ordered monotonicity property ensure solving subproblems reﬁning certain parts plan change remainder abstract plan A similar property considered Bacchus Yang 7 states original problem solvable abstract solution reﬁnement Anderson Farley 4 constructed operator hierarchies having classes operators share common effects forming new abstract operators shared preconditions Another research focus abstractions compute heuristics estimates distances solution guide plan search Pattern databases 31 constructed results projecting state space set variables planning task called pattern solved optimally The omission abstraction 110 matches intuition projection notion Edelkamp 38 ﬁrst apply technique planning 52 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 He showed precompiled lookup table costs abstract solutions help heuristic search ﬁnding optimal solutions The merge shrink abstraction method Helmert et al 61 starts suite single projections computes abstraction merging shrinking A CEGARinspired method proposed Seipp Helmert 116 based cartesian abstractions form general class abstractions The reason abstract plan spurious detected trying construct concrete plan abstraction reﬁned splitting states Obtaining cartesian abstraction possible domain abstraction introduced Section 3 empower abstraction multidimensional handle Section 5 capability representing hierarchy abstraction levels Giunchiglia Walsh 59 presented theory abstractions provided basis understand different types ab stractions characterizing abstractions syntactic mappings programs Later Nayak Levy 90 considered semantic theory ﬁrst original domain abstracted domain model gets abstracted capture abstracted domain Their notion model increasing MI abstractions similar abstraction overapproximation notion ASP Although investigated notions related domain abstraction considered heuristicsearch plan ning Hernádvölgyi Holte 62 presented domain abstraction notion states represented ﬁxed length vectors labels noted possibility encountering spurious states abstractions Hoffman et al 63 considered variable domain abstraction modifying add delete lists operators accordingly They argued obtaining eﬃcient results abstraction planning relies irrelevance problem observation similarly experiments To investigate structure problems obtain good results especially context ASP interesting research direction The notion irrelevant information effects analyzed planning Nebel et al 91 different heuristics introduced omit information Fox Long 51 described method detecting symmetries problem treated indistinguishable help planner Abstraction studied situation calculus action theories Banihashemi et al 9 imposed bisimulation restriction abstraction order ensure reasoning actions agent abstract level mapped concrete reasoning They later showed restricted notion abstraction reasoning strategy agent achieve goal high level mapping lowlevel strategy 10 However focus abstraction For verifying behavior multiagent systems use abstraction investigated Lomuscio et al ab stracting agent construct abstract preserving properties expressed temporalepistemic logic 28 alternatingtime temporal logic 83 In 28 focus abstraction built In 83 abstraction states possible actions execute action abstraction keeps ac tions certain agents omitting rest They considered threevalued logic abstraction preserves behavior satisfying property Spuriousness occur case achieving uncertain result checking speciﬁcation abstract level forces reﬁne abstraction splitting states investigating subformulas speciﬁcation They later extended work inﬁnite state models 84 abstracted ﬁnite models predicate abstraction presented interpolantbased reﬁnement method 11 In context ASP action languages Dix et al 35 proposed way formulating solving hierarchical planning ASP semantics focus ordered task decomposition planning step order later executed For particular application mobile robot planning Zhang et al 123 performed hierarchical planning action language BC 733 Generalized planning Finding plan achieve goal class problem instances understanding details relevant problems The plan particular problem instance need search Note discussed Section 72 plans computed domain abstraction method seen generalized plans work original problem instance maps abstract instance Srivastava et al 118 proposed abstraction method constructing generalized plans loops focusing classical planning selecting good abstraction scope Bonet Geffner 15 considered setting uncertainty represented set states clustering states provide observations This view similar indistinguishability notion proposed 109 They studied conditions policy plan general work instances Later considered trajectory constraints 14 Illanes McIlraith 65 studied abstraction numeric planning problems compiling classical planning Recently abstraction problems quantiﬁable objects 66 number packages deliver points A B ﬁnd abstracting quantiﬁcation generalized plans work multiple instances For built quantiﬁed planning problem clustering indistinguishable objects reformulation techniques 105 reduce symmetry compute general policy While quantiﬁability conditions 66 restrict applicability method potential drawback spurious answers 53 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 8 Conclusion Abstraction important aspect Artiﬁcial Intelligence aiming omission ﬁnegrained structure problem solving reduce cognitive andor computational complexity order better understand respectively effectively ﬁnd solutions In spirit introduced notion domain abstraction Answer Set Programming size domain ASP program shrinks collection answer sets overapproximated original answer set mapped abstract answer set We shown applied single multiple sorts domain multidimensionality handled enables hierarchical view abstraction quadtree abstractions showcase multigranular abstraction grids More speciﬁcally introduced structurepreserving approaches apply abstraction rules The ﬁrst approach keeps builtin relations rules lifted abstract domain second approach existential abstraction loses original format beneﬁt ability handle different levels abstractions abstract elements needed hierarchical abstraction As overapproximation result spurious abstract answer sets correspond original answer sets presented method reﬁning abstractions uses ASPdebugging techniques obtain hints reﬁnements CEGARstyle methodology iterated abstraction reﬁnement 25 The approach implemented tools DASPAR mDASPAR multidimensional domain mappings given ASP program initial abstraction auto matically reﬁne induced abstract program concrete answer set encountered unsatisﬁability detected proves original program unsatisﬁable Our experiments showed potential approach understanding core parts ASP program In case satisﬁability abstract answer sets focus relevant details case planning problems Blocksworld Package Delivery justiﬁcation technique ASP cf 20103 understand particular abstract answer set computed abstraction faithful identify details irrelevant ﬁnding solution In case unsatisﬁability automatic abstraction reﬁnement able catch unsatisﬁability reﬁning original program Furthermore gridcell problems multidimensional view abstraction enables zooming area gridcell shows reason unsolvability compared results small user study explanations decent quality achieved suggests continue line research 81 Outlook This article provided seminal concepts notions domain abstraction ASP assessment semantic computational properties results prototypical evaluation The work domain abstraction continued extended directions One direction obtain general notions abstraction apply abstraction larger classes ASP programs As remark domain abstraction combined omission abstraction 110 obtain abstraction omits certain details abstracts domain This achieved current deﬁnitions ﬁrst applying desired domain abstraction program grounding constructed nonground abstract program omit atoms The reﬁnement decisions need account causes spuriousness bad clustering domain elements bad omission atoms As regards larger classes ASP programs language constructs like disjunction rule heads aggregates weak constraints ASP Core 2 standard 21 natural targets Furthermore extensions nested rules external atoms constraint solving interesting target languages An important aspect abstractionreﬁnement method inital abstraction mapping Starting coarse abstractions mislead method reﬁning irrelevant parts abstraction To overcome understanding good initial abstraction needs investigated Employing symmetry breaking techniques 3437 order hints good initial abstraction promising subject future research Furthermore use abstraction depends problem structure hand characterizations different problem types better understanding effects abstraction necessary Another research direction concerns abstraction reﬁnement Different methods explored help decision making reﬁnement step On hand heuristics deciding reﬁnement collection abstract answer sets considered range local search increased addition domainspeciﬁc knowledge exploited On hand justiﬁcation methods 20103 obtain explanation abstract answer set built check original program In case failure reason spuriousness abstract justiﬁcation distilled exploited abstraction reﬁnement Related issue abstraction assessment question good abstraction needs studied Different criteria relevant respect technical ones like degree spuriousness measured number spurious answer sets level abstraction measured granularity clustering cognitive appeal human user perspective terms understandability abstraction abstract program Addressing appears challenging harder developing measures technical criteria given humans implicit background knowledge domain 54 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 A research direction advanced implementations tuning current prototypes An apparent bottleneck concreteness checking costly need grounding original program process Here explore use lazygrounding 227296121 nonground ASP solving 687 develop native techniques concreteness checking Further improvements justiﬁcation methods explain abstract answer sets mentioned beneﬁt mitigates grounding issue yield substantial gains embed debugging program evaluation abstract program hints obtained embedded checking achieve works eﬃciently nontrivial Last use domain abstraction remains explored applications Different possibilities envisaged ASP program development obvious candidate Different common debugging techniques domain abstraction aims rules effect certain behavior identify gist domain responsible aids gaining insight program hand Another possible use domain abstraction solving technique address scalability While stateoftheart ASP solvers eﬃcient solving problems struggle problems create huge search spaces require optimization For problems abstraction useful However achieving good abstraction help solving nontrivial advances performance particular concreteness checking necessary fruitful deployment Finally believe domain abstraction potential building systems explain matters human end user useful tool realizing explainable AI Our experiments grid cell puzzles nurtured view reasons unsolvability obtained automated way tools good match human intuition However initial step signiﬁcant research efforts invested view reality Declaration competing The authors declare known competing ﬁnancial interests personal relationships appeared inﬂuence work reported paper Acknowledgements We grateful reviewers helpful constructive comments improve work presentation Appendix A Proofs Proof Theorem 31 Let ˆI cid3cid2 denote mI cid2m respectively Towards contradiction assume exists ˆITm ii ˆI Tm I A Scid2 st ˆI Tm A Scid3cid2 This occur ˆI Tm model cid3cid2 minimal model cid3cid2 ˆITm ˆI Tm Bˆr ˆI Tm cid3 Hˆr ˆITm Then exists rule ˆr cid3cid2 By construction cid2 ˆr obtained step ˆr choice rule head Hˆr mα ˆr satisﬁed Consequently ˆr rule step r cid2 ˆITm Suppose ˆI Tm model cid3cid2 Since ˆI Tm mBstdr ˆd1 ˆd2 τ I ˆd1 ˆd2 ˆI Tm mBstdr If pˆe1 ˆen mBstdr ei ˆei exists pe1 en I variables standardized apart I B stdr choice As pˆe1 ˆen mBstdr pe1 en I ei ˆei So instantiate abstract body mB stdr I ˆd1 ˆd2 means I d1 d2 di ˆdi original body Bstdr I Bstdr Also having ˆI ˆd1 ˆd2 τ I Bstdr d1 d2 So r α Bstdr d1 d2 cid2I As I model follows I α means ˆI mα contradiction ii Suppose exists cid3J ˆI cid3J Tm model cid3cid2 1cid3J I model cid2I J I holds contradict I A Scid2 Assume J cid3 cid2I Then J satisfy rule r α Bstdr d1 d2 cid2I J Bstdr d1 d2 J cid3 α As J I I model cid2I I α α I J ˆITm We claim J m Now look cases applying mapping m r considering abstractions mB stdr md1 md2 contradiction achieved First assume ˆI mBstdr There following cases m J 11 m J mB stdr 12 m J cid3 mBstdr 11 As m J mBstdr look md1 md2 We know J d1 d2 If md1 md2 relation type τ I md1 md2 means m J md1 md2 m J Tm md1 md1 τ I md1 md2 nonground rule created step instantiation mα mB stdr md1 md2 ˆITm As ˆJ ˆI models cid3cid2 1 ˆJ I md1 md2 cid3cid2 τ α I deﬁnition J α J J α contradiction I md1 md2 As ˆJ m J ˆJ ˆI ˆI Tm md1 md2 τ ˆITm ˆJ mα ˆI mα Thus α m If md1 md2 relation type τ m J Tm md1 md2 τ IIImd1 md2 means m J md1 md2 IIImd1 md2 Thus mα ˆI IIImd1 md2 ˆI Tm md1 md2 τ 55 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 nonground choice rule created step b amounts mα mB stdr md1 md2 τ cid3cid2 ˆITm achieves ˆJ mα J α contradiction IIImd1 md2 If md1 md2 relation type τ m J Tm md1 md2 τ nonground rule created step c achieve J α contradiction IVmd1 md2 m J cid3 md1 md2 m J md1 md2 IVmd1 md2 With similar reasoning ﬁnd instantiation 12 We possibility ˆJ cid3 mBstdr ˆJ m J ˆI mBstdr In order ˆJ cid3 mBstdr positive literal ˆαi mBstdr occur ˆI ˆJ ˆJ cid3 mBstdr However contra dicts J Bstdr Now assume ˆI cid3 mBstdr As I Br know ˆI mBstdr holds So rule r form l Bstdr αi d1 d2 according restriction R1 having negative literal αi cid13 α ˆI cid3 mBstdr means ˆI mαi αi Bstdr I cid3 αi αi I So ˆI mBsh r Then αi following cases m J 21 m J mB sh αi r 22 m J cid3 mBsh αi r r look md1 md2 We know J d1 d2 21 As m J mBsh αi I md1 md2 τ For cases τ IIImd1 md2 J d1 d2 ˆJ md1 md2 ˆI md1 md2 Notice mαi ˆI αi cid3 αi mapped nonsingleton cluster mαi So atom isSingletonm j holds true ˆJ ˆI j argαi m r md1 md2 isSingletonm j nonground rule created step di achieve J α contradiction ˆITm instantiation mα mB sh αi cid3 I mαi mαi 1m j 1 Thus cid3cid2 For case τ IVmd1 md2 similar reasoning 11 ﬁnd instantiations nonground rules created step dii achieve J α contradiction r ˆI mBsh αi cid3 I mαi mαi 22 We possibility m J cid3 mB sh αi m J mBstdr holds So m J cid3 mBsh αi αi cid2I We look abstraction r cid3 m J mαi yields contradiction As 22 means rule r m J mαi cid3 αi2 d cid3 Bstdr αi cid3cid3 αcid3 Bstdr form r i2 atoms recursive process eventually ends n steps rule r case 22 applicable m J mαcid3 Thus m J cid3 mBsh αi r As J Br know r means m J cid3 mαi ˆI mαi Now look cid2I As cid3 2 By case analysis 11 12 21 achieve cid3 cid2I mαi2 By restriction R3 negative cyclic dependency cid3 n 2 achieved Then tracing rules r m J mαi cid3 2 want claim m J cid3 mαi2 For look rule r d cid3 means rule r r possible cid2 form r cid3cid3 2 mαcid3 cid3 d 1 cid3cid3 cid3cid3 d 1 cid3 Bstdr cid3 n αcid3 Bstdr cid3 n d cid3 αi cid3 d d d cid3 n 1 cid3 1 i2 cid3cid3 cid3 cid3 Let ˆI Tm model cid3cid2 Proof Theorem 32 Similar proof Theorem 31 assume contradiction exists I A Scid2 ˆITm ii ˆI Tm minimal ˆI Tm A Scid3cid2 This occur ˆI Tm model cid3cid2 model ˆITm ˆI Tm Bˆr ˆI Tm cid3 Hˆr For cases G1 G3 contradiction achieved similar proof Theorem 31 ˆr rule step As ˆd ˆd shorthand ˆd11 ˆd21 ˆd1k ˆd2k deﬁnition case G2 ˆI Tm rel cid3 means I Bstdr d11 1 d21 d1k k d2k d11 ˆd11 d21 ˆd21 d1k ˆd1k d2k ˆd2k r cid3 rel cid2I This reaches contradiction I model I α means ˆI mα ˆITm Then exists rule ˆr cid3cid2 ii Now let cid3J ˆI cid3J Tm model cid3cid2 1cid3J I I model cid3 cid2I contradict I A Scid2 Assume J cid3 cid2I J satisfy rule r α B stdr rel d cid2I J Bstdr d11 1 d21 d1k k d2k J cid3 α α J As J I I model cid2I I α α I J We consider abstractions mB stdr md11 1 md21 md1k k md2k ˆITm We claim J m ˆd τ rel First assume ˆI mBstdr There following cases m J 11 m J mB stdr m J cid3 mBstdr I cid3 11 As m J mBstdr look md11 1 md21 md1k k md2k We know J d11 1 d21 d1k k I md1i md2i means m J md11 1 d2k 11a If md1i md2i relation type τ md21 md1k k md2k m J Tm rel cid3 ˆd τ rel I cid3 ˆd As ˆJ m J ˆJ ˆI ˆI Tm rel cid3 cid3 instantiation mα mBstdr rel ˆI mα Thus deﬁnition J J α contradiction ˆd cid3cid2 ˆd τ rel ˆd τ rel I I cid3 cid3 93 ˆd nonground rule created step ˆITm ˆJ mα ˆITm As ˆJ ˆI models cid3cid2 56 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 11b If md1i md2i relation type τ relation type τ IVˆd1 j ˆd2 j 93 achieved τ rel III ˆd place τ rel I cid3 cid3 ˆd III md1i md2i md1 j j md2 j 11c If md1i md2i relation type τ cid3 md1i md2i Thus rel ˆd m J cid3 rel cid3 IV md1i md2i means m J ˆd m J rel ˆd cid3 cid3 m J Tm rel cid3 ˆd τ rel IV ˆd 94 By reasoning 11a nonground choice rule created step c amounts ˆITm reach contradiction cid3 mα mBstdr rel ˆd τ rel cid3 IV ˆd cid3cid2 12 This case handled proof 12 Theorem 31 Now focus case ˆI cid3 mBstdr As I Br know ˆI mBstdr hold Then ˆI cid3 mBstdr means nonempty set L B stdr atoms ˆI αi αi L 1 n I cid3 αi αi I Assume set Lc j atoms involved negative cycle α Since B sh r literals αi L shifted omitted αi α Lc j 42 ˆI mBsh r ˆI mnot Bstdr L LLc j Then following cases m J 21 m J mB sh r m J mnot Bstdr L 22 LLc j LLc j m J cid3 mBsh LLc j r m J cid3 mnot Bstdr L LLc j ˆd21 ˆd1k k 21 As m J mBsh abstraction ˆd11 1 21a By 11a 11b case 93 τ rel r m J mnot Bstdr L similar proof 11 21 Theorem 31 ˆd2k relations considered contradiction J l achieved III ˆd We know αi L 1 n m J mαi αi J J I αi I means isSingletonm ji holds true m J ˆd isSingletonm j1 isSingletonm jn ˆI ji argαi Thus m J Tm rel cid3 means mα ˆI α I deﬁnition J α J contradiction cid3 21b By 11c case 94 similar reasoning 21a m J isSingletonˆj1 cid3 isSingletonm jn m J Tm rel isSingletonm j1 ˆd τ rel cid3 IV ˆd isSingletonˆjn Thus similarly achieve contradiction 22 We ﬁrst possibility m J cid3 mB sh m J mBstdr hold So m J cid3 mBsh αi α Lc j ˆI mαi Now look cid2I As αi cid3 Bstdr means rule r r yields contradiction As 22 m J cid3 mB sh LLc form means rule r cid3 d By case analysis 11 12 21 achieve m J mαi r As J Br know LLc j r means m J cid3 mαi αi L Lc j showing cid3 cid3 2k cid2I We look abstraction cid3 m J mαi cid3 cid3 αi cid3 L Bstdr Lc j cid3 I mαi mαi cid3 21 d cid3 Lc j cid3 αi r ˆI mBsh 1 d k d cid3 11 cid3 1k LLc j LLc j r cid3 cid3 cid3 j cid3 cid3 cid3cid3 r r r d cid3 1k cid3 11 k d 1 d cid3 αi Bstd cid3 Bstd cid3 21 d cid2I form r Bstdr exists st li2 cid3 2k cid3 Lc j cid3 want claim m J cid3 mli2 For li2 cid3cid3 d mαi2 Since 1 d look rule r backwards traverse negated literals involved negative cycles head respective rules recursive process eventually ends n steps rule r case 22 applicable m J mαcid3 m J mαi actually holds Thus m J cid3 mBsh r possible The case m J cid3 mnot Bstdr L hold mean exists αi Bstdr L m J mαi ˆI cid3 mαi ˆI mnot Bstdr L contradiction m J ˆI cid2 cid3 n 2k achieved Then tracing rules r 2k mαcid3 cid3 n cid3 n d 11 cid3 li2 αi Bstdr L Lc j cid3cid3 αcid3 i2 cid3 n 21 d cid3cid3 21 d cid3 n αcid3 Bstdr 1 d k d k d cid3cid3 11 cid3 n 1k cid3cid3 1k LLc j i2 cid3cid3 Proof Lemma 39 By deﬁnition need check 1 ˆI model cid2m model cid2m ˆI ˆI 2 ˆI minimal ˆJ ˆI As 1 refute property guessing rule r cid2m variable substitution θ verifying ˆI ˆI rθ denotes ground instance r obtained applying θ variables note case satisfy rθ ˆI cid2m rθ Each rule r cid2m polynomial size input Checking r cid2m holds feasible polynomial time computing independent negative cycles Lc1 Lcl program cid2 feasible polynomial time Furthermore ˆI holds 57 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 checking instance r respect ˆI feasible polynomial time Overall refuting 1 consequently NP cid3 rθ r abstract domain GLreduct cid2m As 2 ˆI minimal atom I proof given sequence r1 r2 rk applications rules ˆI positive body literal ri occurs head r j j Note wlog ˆI a1 ak ri cid2m ai proof r1 ri 1 k As proof guessed nondeterministically veriﬁed polynomial time follows 2 NP Hence follows problem cid10p 2 precisely class DP cid2 ˆI abstract program cid2m Proof Theorem 310 To ˆI concrete abstract answer set cid2m guess interpretation J cid2 check m J ˆI b m J AScid2m c J AScid2 Testing clearly polynomial size J 2 size J cid2 exponential time size ˆI cid2 Lemma 39 b c feasible cid10p consequently deciding ˆI concrete abstract answer set cid2m NEXP For bounded predicate arities guess J polynomial size input check conditions b c Lemma 39 NP oracle polynomial time establishes cid11p The matching lower bounds shown reduction deciding given nonground program cid2 2 membership answer set NEXPcomplete general case cid11p 2 complete bounded predicate arities 3339 Without loss generality cid2 involves single predicate p achieved reiﬁcation padding arguments contains fact pcid22d The mapping deﬁne m d1 dncid17ˆd d1 dn form Herbrand domain Then ˆI pˆd ˆd concrete abstract answer set cid2m iff cid2 answer set Note actually ˆI AScid2m holds overall complexity change property asserted This proves result cid2 Proof Theorem 312 For membership guess interpretation ˆI cid2m ˆI answer set cid2m check ˆI spurious By Theorem 310 spuriousness check coNEXP oracle general cid11p 2 oracle bounded predicate case However applying standard padding techniques10 follows coNP oracle suﬃcient general case This proves membership problem NEXPNP general case cid11p 3 bounded predicate case respectively The NEXPNPhardness general case shown reduction evaluating secondorder logic formulas suitable form ﬁnite relational successor structures relational structures S D R S universe D inter relations R R R1 Rk include relations ﬁrstx nextx y lastx associated pretations R S linear ordering D Lemma A1 Given secondorder SO sentence form cid14 P Q ϕ P P 1 P m1 Q Q 1 Q m2 predi cate variables ϕ j ϕ j FO ϕ j form ϕ j x1 xnl j1 l jk li j FOliteral ﬁnite relational successor structure S deciding S cid14 NEXPNPcomplete cid18 This lemma obtained facts 1 evaluating SOsentences form cid16 P Q ϕ ϕ ﬁrst order formula ﬁnite relational successor structures NEXPNPcomplete cf 60 2 cid16 transformed cid14 form described polynomial time possible secondorder skolemization auxiliary predicates quantiﬁer elimination cf 44 denoting subformulas ϕcid22x P ϕcid22x ϕcid22x ϕ1cid22x ϕ2cid22x expressed P ϕcid22x P ϕ1 cid22x P ϕ2 cid22x We ﬁrst encode evaluating sentence cid14cid3 P Q ϕ ordinary program cid20 extend encoding prove result We deﬁne rules cid20 follows D serves domain predicate constants C x1 xn P jiX1 Xn P jiX1 Xn DX1 DXn P jiX1 Xn P jiX1 Xn DX1 DXn Q jiY 1 Yn Q jiY 1 Yn DY 1 DYn Q jiY 1 Yn Q jiY 1 Yn DY 1 DYn l jk j1 sat l ok ok ok sat P ji P P ji P Q ji Q Q ji Q 95 96 97 98 99 100 101 l denotes replacement l not11 10 The input x oracle changed x y y exponentially long string y oracle query considers x input This artiﬁcially lowers time bound query measured size x y answered 11 To rules 99 safe body atoms D X added unsafe variables X 58 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Informally rules 95 96 97 98 guess extensions predicates P Q respectively rules 99 evaluate formula ϕ A guess P Q yields answer set cid20 augmented S provided positive facts iff ϕ evaluates S false case rule 99 ﬁres sat derived means turn ok derived 101 constraint 100 satisﬁed On hand deriving ok necessary answer set means sat derived guess P Q cid3 y1 yn link xi yi predicate eqx y holds x y D D We extend program cid20 spuriousness checking To end introduce domain D x1 xn iff x xi y yi hand copy D 1 n The idea use D D single element guess χ P abstract answer set ˆIχ abstract program cid2m exist ˆIχ concrete guess Q answer set cid2 program equivalent cid20 ˆIχ spurious iff guess Q yield answer set cid20 means formula P Q ϕ evaluates true predicates P Q respectively abstract D cid3 cid3 cid3 We following adjustments 1 First replace 97 98 predicate D D 2 Next rule r 99 add term t occurs rule body typing atom Dt replace term t occurs Q literal fresh variable Xt add atoms D cid3 Xt eqt Xt 3 To rule r obtained previous step add succ y1 y1 body literal evaluates true cid3 abstraction abstraction cause uncertainty lead choice rule cid3 yi 1 n 4 We add facts eqxi yi Dxi D 5 We add facts Q ji y0 y0 Q ji y0 y0 Q ji Q y0 fresh constant It hard establish answer sets I resulting program cid2 S correspond answer sets I0 cid20 S I obtained I0 replacing Q ji Q ji atoms constant xl corresponding yl adding facts Q ji y0 y0 Q ji y0 y0 adding eqxi yi D cid3 y j facts 1 n The mapping construct m x1cid17x1 xncid17xn y0 y1 yncid17 ˆy In abstract program cid2m rules 95 96 carried modiﬁed rules 97 98 turned rules derive abstract atoms Q ji resp Q ji However cid2m contains abstracted facts Q ji ˆy ˆy Q ji ˆy ˆy rules redundant The modiﬁed rules 99 turned guessing rules sat rules 100 101 remain unchanged The abstract answer sets cid2m correspond guesses χ P ok Q ji ˆy ˆy Q ji ˆy ˆy added sat guessed false denote answer set Iχ The answer set Iχ concrete guess μ Q obtain answer set I program cid2 mapped Iχ mI1 Iχ I1 corresponds answer set I0 described Thus Iχ spurious guess μ Q exists Putting holds cid2 respect mapping m x1cid17x1 xncid17xn y0 y1 yncid17 ˆy spurious answer iff formula cid14 Lemma A1 evaluates S true Since cid2 m constructable polynomial time cid14 S proves coNEXPNP hardness general case For bounded predicate arities case evaluation formula cid14 Lemma A1 cid11p steps producing program cid2 preserves bounded arities Thus argument obtain cid11p deciding spurious answer set exists bounded predicate arities This proves result cid2 3 complete furthermore 3 hardness Proof Proposition 42 Let X interpretation V m X ˆI We help auxiliary rulesatoms interpretation X built starting X To end ﬁrst add facts α cid2 X atoms konr Hr Br cid13 rule r grdcid2 The resulting X debug facts cid2 konr body konr head Furthermore construction X We satisfy remaining rules Tmetacid2 adding apnr blnr atoms order ii Tdeactcid2 TdeactConscid2 Tact cid2 V auxiliary atoms pc1 cn choicerules ab_ atoms deactivationactivation rules Vdebug minimal model cid2cid3 X satisfy rules grdcid2debug cid2 X cid2cid3 cid2debug Q m ˆI satisfy Q m ˆI cid3 cid3 cid3 cid3 cid3 For instance r rule r cid2 X cid3 Br cid3 add X cid3 c1 cn Hr cid13 n 0 b atoms apnr apnr d1 dncid3 argBr Br 0 After add X apnr X respectively ground atoms blnr c1 cn blnr apnr c1 cn X cid3 cid3 atom apnr c1 cn argHr cid3 cid3 d1 dncid3 Hr cid3 ii For instance r rule r cid2 Br cid13 Hr cid13 argHr cid3 cid3 add Hrcid3 ab_deactnr c1 cn X cid3 cid3 d1 dncid3 apnr d1 dncid3 X cid3 cid3 cid3 X Hr Hr argBr atom pc1 cn A instance r blnr c1 cn X ab_actpc1 cn X pc1 cn X cid3 cid3 cid3 cid3 rules r deﬁning p add pc1 cn X rule r cid2 exists Hr furthermore instance r add ab_deactConsnr d1 dncid3 X cid3 cid3 cid3 c1 cn apnr c1 cn X rule r cid2 Finally cid3 cid3 Br cid3 b cid3 pc1 cn X pc1 cn X cid3 cid3 59 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 As X cid3 cid3 X coincide V X cid3 HBcid2 X HBcid2 X X minimal model cid2cid3 X X U HBcid2cid3 U 75 cid2cid3 cid3 cid13 atom α HBcid2cid3 r cid3 cid3 cid3 Q m ˆI claimed X cid3 cid2cid3 X cid3 U unfounded set U wrt X cid3 B cid3 cid13 Br cid3 grdcid2cid3 X To cid3 U X cid3 cid13 r cid3 U cid13 cid3 easily checked α X rule r satisfy blnr atoms konr atoms cid3 cid3 cid3 cid3 r cid3 U r B occur U Towards contradiction suppose U exists By construction X cid3 grdcid2cid3 exists Hr cid3 α X cid3 Br cid3 Thus particular α U cid3 cid13 Inspecting rules cid2cid3 cid3 α atoms ab_atoms U cid3 construction X cid3 cid3 r r r contains apnr atoms resp atom α HBcid2 cid3 U cid3 cid3 U cid3 Now case apnr c1 cn U cid3 similarly apnr d1 dncid3 U cid3 cid3 In turn α U cid3 atom α B atom α B cid3 atom apnr c1 cn U Br Br α pc1 cn choice rule Hr apnr c1 cn Continuing argument obtain atom α U cid3 dependency founded rule r cid2 instance r Deﬁne abstract interpretation ˆI rules ac Deﬁnition 34 rules body shifts literal removals Hence instance r cid3 HBcid2 Consequently ˆI cid3 rule derive mα α U cid2m U supposed exist Consequently X result cid2 cid2cid3 Since cid2 positive r cid13 r B cid3 HBcid2 consider cid2m The abstraction r introduces satisﬁes ˆI contradicts ˆI AScid2m Thus unfounded set proves ˆI However means ˆI minimal model cid2 cid3 HBcid2 positive cycle G cid3 α B Hr cid3 form apnr c1 cn form apnr d1 dncid3 form α apnr c1 cn α cid3 HBcid2 atom mβ B answer set cid2cid3 minimal model cid2cid3 X r β U cid3 ˆI mα α U r cid3 r cid3 cid3 cid3 Proof Proposition 43 If ˆI spurious Proposition 41 program cid2 Q m unsatisﬁable We focus debugging ˆI cause inconsistency Since cid2 positivedependency founded inconsistency unsatisﬁed rule ii unsupported atom iii supported atom positive cycle positive atom dependencies Indeed rules satisﬁed cid2 S answer set cid2 unfounded set U cid2 wrt S exists U S cid13 cf 75 atoms S supported atom α U S positive cycle G cid2 nodes U S α positive atom dependencies cid2 positivedependency founded Consider cases Let r cid2 unsatisﬁed rule wrt S This means constraints Q m ˆI causing Hr false Br satisﬁed By program Tmetacid2 depending r apnr c1 cn apnr d1 dncid3 true By Tdeactcid2 S S Tmetacid2 ab_deactnr c1 cn S If Hr TdeactConscid2 konr ab_deactConsnr d1 dncid3 S ii Let α pc1 cn S unsupported atom cid2 wrt S domain elements c1 cn Then rule instance r deriving α blnr c1 cn S Tact cid2 V ab_act pc1 cn S iii Assuming rules cid2 satisﬁed atoms S supported case possible rule r α Br cid2 α U S deriving contradiction For U described instance r r Thus abstract program cid2m includes r S satisﬁes Br rules bodyshifts rules ac Deﬁnition 34 By positivedependency foundedness interpretation S U S satisﬁes rules cid2 Consequently abstract interpretation ˆI mU S satisﬁes rules ac constructed r model cid2m means ˆI minimal model GLreduct cid2m wrt ˆI contradicts ˆI AScid2m cid2 cid3 means B cid3 B r cid3 Proof Theorem 51 For assignment I need I Tm minimal model cid2m minimal model cid2mI I I Tm Towards contradiction assume I Tm minimal model cid2m I I Tm minimal model cid2mI Then I Tm model cid2mI ii I Tm minimal model cid2mI There rule ˆr cid2mI I Tm Bˆr I cid3 Hˆr By construction cid2m ˆr obtained step Deﬁnition 34 ˆr choice rule head Hˆr ml ˆr satisﬁed Consequently I ˆd1 ˆd2 Since deﬁnitions ˆr rule step r cid2 Thus I Tm mBstdr ˆd1 ˆd2 τ I ˆd1 ˆd2 relation type I lifted relations abstract relations correspond Tm τ cid3rel ˆd1 ˆd2 abstract rule r constructed Tm τ I I I Hˆr Hence reach contradiction step Deﬁnition 51 Since I Tm minimal model cid2m ˆd1 ˆd2 This means I Tm mBstdr τ cid15rel I ii Let J I J Tm model cid2mI We claim J Tm model cid2m I I J Tm Bˆr contradict I Tm AScid2m J cid3 Hˆr I Hˆr We need corresponding rule cid2mI ˆr achieve contradiction J Hˆr Below denote Bˆr ˆcid6r abstract body excluding abstracted relation relation type atom I Then rule ˆr cid2m Assume J Tm cid3 cid2m 60 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 If ˆr contains τ ˆd1 ˆd2 step c Deﬁnition 51 know Tm τ cid3rel I ˆt1 ˆt2 achieve J Tm ˆd1 ˆd2 τ cid3rel τ I I Bˆr ˆcid6r Thus Hˆr Bˆr ˆcid6r ˆd1 ˆd2 τ J Tm model cid2mI J Hˆr contradiction I ˆd1 ˆd2 J Tm ˆd1 ˆd2 Since ˆr cid2m I ˆd1 ˆd2 Tm I know I Bˆr I ˆd1 ˆd2 Hˆr Bˆr ˆcid6r ˆd1 ˆd2 cid2mI Since cid3rel III ˆd1 ˆd2 step b c Deﬁnition 51 J Tm τ If ˆr contains τ d11 d12 m following cases ˆd1 ˆd2 1 J ˆd1 ˆd2 2 J cid3 ˆd1 ˆd2 1ˆd1 d21 d22 m 1ˆd2 J 1 J J cid3 m cid3rel III ˆd1 ˆd2 means exist cid3 cid3 d12 d22 There cid3 d11 d21 J 1 Since know J cid3 cid3 d12 d22 case obtains τ soning obtaining Hˆr Bˆr ˆcid6r ˆd1 ˆd2 τ cid2mI achieve J Hˆr contradiction 2 Since know J cid3 d11 d21 case obtains τ reasoning reach contradiction IIIˆd1 ˆd2 J Tm ˆd1 ˆd2 τ IIIˆd1 ˆd2 With similar rea IIIˆd1 ˆd2 cid2mI Hˆr Bˆr ˆcid6r ˆd1 ˆd2 IVˆd1 ˆd2 J Tm ˆd1 ˆd2 τ IVˆd1 ˆd2 With similar Towards contradiction assume I Tm minimal model cid2mI I Tm minimal model cid2m Then I Tm model cid2m I ii I Tm minimal model cid2m I I There rule ˆr cid2m I I Tm Bˆr I cid3 Hˆr By construction cid2m ˆr obtained step Deﬁnition 51 With analogous reasoning item achieve contradiction ii Let J I J Tm model cid2m cid3rel I I achieves J Hˆr contradiction I We claim J Tm model cid2mI contradict I Tm AScid2m Assume J Tm cid3 cid2mI Then rule ˆr cid2mI J Tm Bˆr J cid3 Hˆr I Hˆr We need corresponding rule cid2m I ˆr achieve contradiction J Hˆr If ˆr contains ˆd1 ˆd2 τ Hˆr Bˆr ˆcid6r τ If ˆr contains ˆd1 ˆd2 τ I ˆd1 ˆd2 step Deﬁnition 34 analogous reasoning item ii obtains exist d1 m relation type τ 1 2 With similar reasoning obtaining Hˆr Bˆr ˆcid6r τ contradiction ˆd1 ˆd2 cid2m IIIˆd1 ˆd2 means J ˆd1 ˆd2 IIIˆd1 ˆd2 step b Deﬁnition 34 J Tm ˆd1 ˆd2 τ 1ˆd2 J cid3 cid3 d1 d2 This obtains abstract 1 J J cid3rel III ˆd1 ˆd2 Notice J isSingletonˆdi holds cid3rel III ˆd1 ˆd2 cid2m I achieve J Hˆr IVˆd1 ˆd2 means cid3 d1 d2 This IVˆd1 ˆd2 step c dii Deﬁnition 34 J Tm0 1ˆd1 d2 m cid3rel III ˆd1 ˆd2 J Tm τ J cid3 ˆd1 ˆd2 exist d1 m obtains abstract relation type τ 1ˆd1 d2 m cid3rel III ˆd1 ˆd2 J Tm τ If ˆr contains ˆd1 ˆd2 step di Deﬁnition 34 means J Tm τ I ˆd1 ˆd2 J Tm IIIˆd1 ˆd2 holds Also know J isSingletonˆdi holds 1 2 So similar achieve τ contradiction cid2 cid3rel III ˆd1 ˆd2 reaches contradiction ˆd1 ˆd2 τ 1 J J If ˆr contains ˆd1 ˆd2 τ 1ˆd2 J cid3 m cid3 m A1 Merged vs individual independent cycles Let cid2Lc1 Lcl denote program constructed Deﬁnition 38 Lc1 Lcl let cid2S denote program Lcl S instead Lc j deﬁning Bsh LS r Then obtain structed considering big cycle S Lc1 following result Proposition A2 For program cid2 holds AScid2Lc1 Lcl AScid2S Proof Let L Lc1 Lcl We ﬁrst observe rules cid2L cid2S related following way We r rule r tightening rule r Hr Hr r B r B cid3 B cid3 B r cid3 cid3 Lemma A3 For rule r cid2L according d exists tightening r exists tightening r r cid2L cid3 cid3 r cid2S rule r cid2S according d Bsh To ﬁrst α Lc j α S α L Lc j α L S Suppose rule r d included cid2L r L applies r0 rule r0 cid2 If 42 condition α Lc j Lc j L cid13 42 condition α Lc j Lc j L cid13 applies tightening r LS r0 condition α Lc j Lc j included cid2S Bsh LLc j cid3 61 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 likewise tightening r condition α Lc j Lc j cid3 L cid13 r included cid2S Bsh LS r0 condition α Lc j Lc j L r r cid3 For second r stems rule r0 cid2 S L For Lc j r0 rule r L Lc j cid3 added cid2L If r r cid3 Consider set L cid2 Otherwise follows α Lc j L Lc j cid3 As cycle Lc j cid3cid3 cid13 hold cid3 cid13 j disjoint Lc j α Lc j L Lc j condition α Lc j Lc j cid3 j cid2L L cid3 L jcid3cid13 j Lc j cid3 cid3 Lc j cid13 L cid13 Consequently d stemming r0 rule r L S L 42 Since L cid3 L rule r cid3cid3 cid3 Lci The result follows following lemma tightening r This proves lemma Lemma A4 Let cid21 cid22 programs differ choice rules choice rule r cid21 tightening cid3 r r cid22 exists Then AScid21 AScid22 Indeed consider I AScid21 choice rule r cid3 cid22 If r cid3 I Hr r building nswer set I Br rule r cid2I model cid2I 1 I Br tightening cid2I tigthening rule r cid21 I Br 2 2 possible I cid3 discard r 2 exists smaller model J cid2I Then construction I cid2I cid3 1 Thus I answer set cid22 proves lemma Putting things programs cid2L cid2S differ choice rules according d Lemma A3 condition Lemma A4 veriﬁed conclude AScid2L AScid2S AScid2S AScid2L respectively completes proof cid2 Appendix B Further details B1 Correctness checking failure nonpositivedependency founded programs The following example shows procedure correctness checking work programs positivedependency founded general Example B1 Consider program unsatisﬁable contains positive loop r1 aX aX domX r2 aX aX dom1 dom2 dom3 For mapping m 1 2 3cid17k constructed abstract program cid2m aX aX domX aX isSingletonX domX aX aX domk abstract answer set ˆI ak Checking correctness cid2debug Q m ˆI requires ac c m More program cid2debug contains following rules results unsatisﬁability 1k hold true loop covered deﬁnition cid2debug aX apr1 X apr1 X aX domX blr1 X apr1 X domX aX apr2 X apr2 X aX blr2 X apr2 X domX aX blr1 X blr2 X proof Proposition 42 Following steps obtain X cid2cid3 cid2debug Then pick X a1 omitting domain facts starting set building answer set X cid3 a1 apr2 1 blr1 1 apr1 2 blr2 2 a2 Q m ˆI apr1 3 blr2 3 a3 This answer set cid2cid3 cid2cid3 unfounded set cid2cid3 Notice ma1 ak cid2m founded support choice rule allows having ˆI answer set cid2m We obtain similar picture choose X A m X ˆI starting set viz c 1 2 3 ac X apr2 c X constructed U ac apr2 c unfounded set cid2m wrt X atoms a1 apr2 1 form cycle G X wrt X cid3 cid3 cid3 cid3 cid3 62 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 B2 Gridcell problem encodings In appendix provide details slight modiﬁcations existing common encodings order use experiments The encodings wwwkrtuwien ac research systems abstraction mdaspar _material zip Sudoku We encoding DLV group ASPCOMP09 slight modiﬁcations The guessing assignment numbers free cells written solX Y N numN occupiedX Y rowX columnY hasNumX Y solX Y N hasNumX Y rowX columnY The constraints assigning symbol column symbol row original encoding standardizing apart sorts row column solX Y 1 M solX2 Y 2 M X X2 Y 1 Y 2 solX1 Y M solX2 Y 2 M X1 X2 Y Y 2 For constraint assigning symbol subregion standardizing apart original rules caused relations arguments converted rules solX1 Y 1 M solX2 Y 2 M sameSubSquareLessThanX1 Y 1 X2 Y 2 sameSubSquareLessThanX1 Y 1 X2 Y 2 sameSubSquareX1 Y 1 X2 Y 2 X1 X2 sameSubSquareLessThanX1 Y 1 X2 Y 2 sameSubSquareX1 Y 1 X2 Y 2 Y 1 Y 2 sameSubSquareX1 Y 1 X2 Y 2 subrangeRX1 M subrangeRX2 M subrangeCY 1 R subrangeCY 2 R hardcoded facts subrangeR X M subrangeCY R subregions wrt rows columns respectively Knights tour We encoding ASPCOMP1112 slight modiﬁcations At atom valid movement cells moveX1 Y 1 X2 Y 21 validX1 Y 1 X2 Y 2 In original encoding valid cells computations rules form validX1 Y 1 X2 Y 2 pointX1 Y 1 pointX2 Y 2 X1 X2 2 Y 1 Y 2 1 modiﬁed validcellX1 Y 1 X2 Y 2 dist1X1 X2 dist2Y 1 Y 2 validcellX1 Y 1 X2 Y 2 dist2X1 X2 dist1Y 1 Y 2 validX1 Y 1 X2 Y 2 validcellX1 Y 1 X2 Y 2 pointX1 Y 1 pointX2 Y 2 auxiliary facts dist1 X1 X2 dist2 X1 X2 represent arithmetic operations X1 X2 2 Y 1 Y 2 1 The constraints ensure exactly enteringleaving movement cell original encoding Having cell visited ensured following rules reachedX Y moveX1 Y 1 X Y startX1 Y 1 reachedX2 Y 2 reachedX1 Y 1 moveX1 Y 1 X2 Y 2 pointX Y reachedX Y rowX columnY atom start X Y starting point instead having rule atom move1 1 X Y originally This change makes treating program convenient rules contain constants need mapped different abstract constants depending mapping 12 wwwmat unical aspcomp2011 ﬁles KnightTour knight _tourenc asp 63 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Visitall We encoded planning problem guidelines Section 72 representing actions change We sidered X Y T actions horizontallyvertically cell X Y For action ensure action pass obstacle previously visited cell passed cells visited A common way encoding auxiliary atoms track cells aux_passedX Y 2 T 1 r AtX Y T goX Y 1 T Y Y 2 Y 2 Y 1 aux_passedX Y 2 T 1 r AtX Y T goX Y 1 T Y 1 Y 2 Y 2 Y aux_passedX2 Y T 1 r AtX Y T goX1 Y T X X2 X2 X1 aux_passedX2 Y T 1 r AtX Y T goX1 Y T X1 X2 X2 X passedX Y aux_passedX Y T ensure conditions passedX Y obs AtX Y visitedX Y T aux_passedX Y T aux_passedX Y T 1 visitedX Y T We follow remark Section 5 handling different abstraction levels variables rule For example ﬁrst rule addition standardizing apart rule aux_passedX Y 2 T 1 r AtX Y T goX1 Y 1 T X X1 Y Y 2 Y 2 Y 1 add additional rule aux_passedX1 Y 2 T 1 r AtX Y T goX1 Y 1 T X X1 Y Y 2 Y 2 Y 1 We proceed similarly remaining rules Furthermore knowing action X1 Y 1 T picked horizontal resp vertical direction r At X Y T drop relation X X1 resp Y Y 1 body smaller B3 Example run mDASPAR To illustrate considerations debugging reﬁnement example run mDASPAR Example B2 ctd We run mDASPAR input program Fig 15 instance shown Fig 13 initial mapping m clustering gridcell regions Fig 14a Step 1 After constructing nonground abstract program Fig 16 computing relation types mDASPAR com putes abstract answer set reachablea1234 b1234 reachablea5678 b1234 reachablea1234 b5678 Step 2 Correctness checking ﬁrst uses cid2debug0 answer set ab_deactConsr3 ab_deactr2 ab atoms contain rule names Fig 27 obtain optimal Step 3 cid2debug constructed r2 r3 respecting variables rules deﬁning ab_deactr2 X1 Y 1 ab_deactr2X1 Y 1 apr2X1 Y 1 reachableX1 Y 1 ab_deactr2X1 Y 1 1 r2 X1 Y 1 ab_deactr2X1 Y 1 mapToX1 Y 1 A1 B1 isSingleton A1 isSingletonB1 20 r2 X1 Y 1 reﬁne A1 B1 ab_deactr2X1 Y 1 mapToX1 Y 1 A1 B1 isSingleton A1 reﬁne A1 B1 ab_deactr2X1 Y 1 mapToX1 Y 1 A1 B1 isSingletonB1 similarly ab_deactConsr3 X Y X1 Y 1 Correctness checking ﬁnds optimal answer set atoms reﬁnea1234 b5678 reﬁnea5678 b5678 64 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 kor1 reachable X Y apr1 X Y ab_deactr1 apr1 X Y reachable X Y ab_deactr1 1 r1 kor2 reachable X1 Y 1 apr2 X1 Y 1 ab_deactr2 apr2 X1 Y 1 reachable X1 Y 1 ab_deactr2 1 r2 kor3 ab_deactConsr3 kor3 apr3 X Y X1 Y 1 ab_deactConsr3 1 r3 kor5 kor6 neighbor X Y X1 Y 1 apr5 X Y X1 Y 1 ab_deactr5 apr5 X Y X1 Y 1 neighbor X Y X1 Y 1 ab_deactr5 1 r5 neighbor X Y X1 Y 1 apr6 X Y X1 Y 1 ab_deactr6 apr6 X Y X1 Y 1 neighbor X Y X1 Y 1 ab_deactr6 1 r6 neighbor X Y X1 Y 1 blr5 X Y X1 Y 1 blr6 X Y X1 Y 1 ab_actneighbor X Y X1 Y 1 blr5 X Y X1 Y 1 blr6 X Y X1 Y 1 neighbor X Y X1 Y 1 ab_actneighborX Y X1 Y 1 1 X Y X1 Y 1 reachable X Y blr1 X Y blr2 X Y ab_actreachable X Y blr1 X Y blr2 X Y reachable X Y ab_actreachable X Y 1 X Y Fig 27 Constructed debugging program Tdeact cid2 TdeactConscid2 Tact cid2 A Step 4 Step 5 The region a1234 b5678 randomly picked reﬁne a12 b56 a12 b78 a34 b56 a34 b78 updating corresponding mapping m Relation types according new mapping computed loop goes step 1 compute new abstract answer set The loop continues unsatisﬁability achieved The abstraction shown Fig 14b abstraction unsatisﬁability observed B4 Modular concreteness checking Ordered modularity An incremental approach ASP solving proposed Gebser et al 53 builds concept modules 94 gradually increases bound solution size represented parameter k help grounding solving They searching answer set minimum size k increment parameter answer set computed We use similar idea detect spuriousness abstract answer set gradually increasing parameter However case increment continued spuriousness realized debugging answer set abnormality atom obtained We simpler view limiting generated grounding program parameter Let cid2 program Herbrand base HBcid2 LB Lk parameter k ranging natural numbers LB represents static literals arguments independent parameter k Lk represents dynamic literals argument k For set X literals denote grdcid2 X r Hr Br X set ground rules Lk j contain literals X Let Xi HBcid2 denote set literals parameter value Xi LB Lk j denotes set literals respective argument value j The rules grdcid2 parameter value given grdcid2 Xi simply denoted grdcid2i cid2 Let Ii denote projection interpretation I literals related parameter value Ii I LB Li We cid2 ordered modular I A Scid2 holds Ii A Sgrdcid2i 0 k We 0 ji know determining occurrence literal l answer set Ii relies decisions point j0 cid2 Proposition B1 Let cid2 ordered modular program m domain mapping cid2 let ˆI AScid2m If ˆIi ˆI spurious n ˆI spurious Proof Assume ˆI concrete This means exists I cid2 mI ˆI As cid2 ordered modular Ii A Sgrdcid2i Thus mIi ˆIi concrete cid2 We implementation approaches 65 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Incrementing time Approach 1 implemented mDASPAR handle planning problems atoms having time argu ments By Proposition B1 know ﬁrst actions potential plan described abstract answer set corresponding original plan conclude plan spurious A common description planning problem ASP uses sorts time timea 0 n 1 action atoms time 0 n ﬂuents For given program cid2 description planning problem contains facts sort time mDASPAR works follows We denote Tmetacid2i metaprogram Tmetacid2 contains time facts resp timea domain element resp 1 cid2debugi analogous restricted version cid2debug For computed abstract answer set ˆI encoding plan s0 a0 s1 sn1 an1 sn denote ˆIi plan time point Starting 1 continue iteration n Step 1 Create Tmetacid2i1 cid2debugi Step 2 Check correctness ˆIi cid2debugi Tmetacid2i1 Q m ˆIi Step 3 If ˆIi spurious exit loop increase 1 This way check correctness ˆI action taken time debugging time point guessing time points t restricted Tmetacid2i1 The time increased incrementally partial solution yields concrete partial plan Once spuriousness observed checking stopped Partial concretization For approach 2 use possibility hierarchy abstractions mentioned Propo sition 36 The idea partially concretize abstract domain fully concretizing certain regions keeping remaining ones abstract Fig 17 shows hierarchy partial concretizations initial mapping For given mapping m consider set possible partial concretizations We check correctness abstract answer set I program partially concretized domain As describes abstraction compared original domain check immediately original program For check correctness debugging abstract program relative partial concretization The approach implemented mDASPAR follows For given mapping m starting j 1 iteration focuses concretizing j regions time checks correctness jregion combination The iteration continues spuriousness detected m mid step 1 Compute jregion concretizations m m1 mn step 2 For mi m1 mn 1 Create cid2mi Tmi set mipc pc cid2 facts cid2mi 2 Create mapping m 3 Check correctness I cid2mi 4 If spurious exit loop debug answer C cid3miD mD Q m I m debug cid3 cid3 debug step 3 If C cid13 reﬁne m according C step 1 increase j 1 step 1 We correctness checking abstract level mi cid2mi If I concrete wrt partially concretized abstraction guarantee I concrete concretization increased redo check If spuriousness detected mapping reﬁned partial concretization continues updated mapping Appendix C Use case abstraction policy refutation As example consider checking agent manages ﬁnd missing person given policy grid environment obstacles If policy work counterexample trajectory environment reveal inspecting guess fails Depending problem focus points different nature For reachability example shown Section 52 focus area environment remain local person search example path trajectory needs distinguished For illustration use following running example Example C1 Example 58 contd Consider reachability problem described following encoding reachability 7274 redeﬁned prioritizing east neighbor rest case east neighbor obstacle choosing south neighbor pointX Y obsAtX Y rowX columnY reachableX Y startX Y 66 102 103 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Original domain b Distinguishing cells reachable restrictions starta1 b1 obs Ata6 b1 obs Ata7 b4 obs Ata56 a34 obs Ata1234 a5678 obs Ata4 b1 obs Ata2 b2 obs Ata12 a34 obs Ata56 a56 Fig 28 Reachability abstraction east neighbor prioritization neighborEX Y X1 Y X1 X 1 columnY neighborSX Y X Y 1 Y 1 Y 1 rowX reachableEX Y X1 Y reachableX Y pointX1 Y neighborEX Y X1 Y hasNeighborEX Y reachableEX Y X1 Y 1 reachableX1 Y 1 reachableEX Y X1 Y 1 reachableX Y 1 reachableX Y pointX Y 1 104 105 106 107 108 109 neighborSX Y X Y 1 hasNeighborEX Y For instance shown Fig 28a reachable cells determined order 256 The abstraction shown Fig 28b singles area contains cells reachable according restrictions We focus abstraction gridcells problem checking policies manage guide agent goal We consider versions problem discuss use abstraction As running example consider agent trying ﬁnd way maze goal point similar spirit example ﬁnding missing person For representing generating mazes use altered version Maze Generation encoding ASP Competition 201113 A policy come ones mind talking mazes wellknown righthand rule known work maze instances goal middle area agent forced loop obstacle layout Does policy work given instance For ﬁxed problem instances check search counterexample trajectory follows policy reach goal If unsatisﬁability achieved conclude policy works instance Abstraction focus instance policy fails works notice case similar having unsatisﬁable problems The necessary granularity abstraction depends complexity policy As demonstrated Fig 30 refuting righthand rule policy abstraction reﬁne outer area To observe policy type affects resulting abstraction experiments To help reﬁnement decisions initial abstraction distinguishes starting point agent abstracts rest We consider following policies A Righthand rule Follow wall righthand B Naive policy Choose direction priority right left We generated 20 instances policies work For debugging method picked time increment wanted focus step abstract trajectory starting beginning steps match policys decisions corresponding original trajectory Furthermore reﬁnement decision abstract answer set avoid concrete answer set encountered spurious ones ﬁnalize search achieve clearly nonfaithful abstraction Table 7 shows results mDASPAR achieve abstraction concrete solution Obtaining SAT means program concrete solution concrete counterexample trajectory shows policy work having UNSAT means policy works As expected naive policy failed work 13 httpswwwmat unical aspcomp2011 ﬁles MazeGeneration maze _generation enc asp 67 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Table 7 Policy checking maze instances satunsat avg step avg cost avg best step avg best cost naive righthand 164 614 72 125 0391 0630 65 118 0362 0599 Fig 29 Abstractions policy checking maze instances supportingrefuting paths instances Since righthand rule forces traverse environment mDASPAR required ﬁner abstractions ﬁgure concrete solution In cases obtained abstractions distant best possible ones focus shifted irrelevant parts grid All obtained resulting abstractions faithful means able actual behavior policy Fig 29 shows resulting abstractions instances Does policy work This involved check set possible instances considered search counterexample trajectory instance needs If policy works possible policy trajectories instances checked conclude result For case considering abstraction focuses certain grid useful depending structure instances different parts grid need singled However policy work ﬁnd instance counterexample policy trajectory shown Thus abstraction focuses certain grid instance counterexample useful 68 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 Fig 30 Can refute righthand rule policy maze instances abstraction In ASP check making sets guesses 1 choose valid instance guessing layout environment position goal 2 determine counterexample trajectory guessing movements agent following policy achieve goal instance If policy deterministic chooses exactly action state second guessing straightforward However nondeterministic policies choice possible actions exists adds complexity search The experiments showed combining guesses introduced syntactic transformation causes spurious abstract answer sets force reﬁnement decisions useless parts grid For example general policy checking righthand rule mDASPAR original domain catch instance counterexample trajectory policy forces traverse environment abstract encoding guesses instance movements cause create spurious trajectories As naive policy mDASPAR encounter counterexample trajectory reﬁnement steps suﬃcient realize policy fails creating partial instance agent enters deadend leave moving left starts looping moving right left We remark failing policy expect abstraction mapping applied possible instance catch counterexample trajectory mapping faithful instance Fig 30a shows instance righthand policy unable reach green goal point red entry point upper left corner An abstraction Fig 30b realize loop occurs goal reached faithful abstraction instance However abstraction distinguish cells force obtain counterexample trajectory possible refuting instance For example instance Fig 30c forces agent loop abstraction Fig 30d uncertainty abstract regions possible create spurious counterexample trajectories Thus faithfulness achieved Here identity abstraction faithfully refute policy possible instances References 1 M Alviano C Dodaro Anytime answer set optimization unsatisﬁable core shrinking Theory Pract Log Program 16 2016 533551 2 M Alviano C Dodaro M Järvisalo M Maratea A Previti Cautious reasoning ASP minimal models unsatisﬁable cores Theory Pract Log Program 18 2018 319336 httpsdoi org 10 1017 S1471068418000145 3 M Alviano W Faber N Leone Disjunctive ASP functions decidable queries effective computation Theory Pract Log Program 10 2010 497512 httpsdoi org 10 1017 S1471068410000244 AAAI 1988 1988 pp 100104 4 JS Anderson AM Farley Plan abstraction based operator generalization Proceedings 7th National Conference Artiﬁcial Intelligence 5 B Andres B Kaufmann O Matheis T Schaub Unsatisﬁabilitybased optimization clasp Technical Communications 28th International Conference Logic Programming ICLP 2012 Schloss DagstuhlLeibnizZentrum Fuer Informatik 2012 pp 211221 6 J Arias M Carro E Salazar K Marple G Gupta Constraint answer set programming grounding Theory Pract Log Program 18 2018 337354 7 F Bacchus Q Yang Downward reﬁnement eﬃciency hierarchical problem solving Artif Intell 71 1994 43100 69 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 8 C Backstrom P Jonsson Planning abstraction hierarchies exponentially eﬃcient Proceedings 14th International Joint Conference Artiﬁcial Intelligence vol 2 IJCAI 1995 Morgan Kaufmann Publishers Inc 1995 pp 15991604 9 B Banihashemi G De Giacomo Y Lespérance Abstraction situation calculus action theories Proceedings 31st AAAI Conference Artiﬁcial Intelligence AAAI 2017 2017 pp 10481055 10 B Banihashemi G De Giacomo Y Lespérance Abstraction agents executing online abilities situation calculus Proceedings 27th International Joint Conference Artiﬁcial Intelligence IJCAI 2018 2018 pp 16991706 11 F Belardinelli A Lomuscio J Michaliszyn Agentbased reﬁnement predicate abstraction multiagent systems Proceedings 22nd European Conference Artiﬁcial Intelligence ECAI 2016 IOS Press 2016 pp 286294 12 M Bichler M Morak S Woltran The power nonground rules answer set programming Theory Pract Log Program 16 2016 552569 13 S Bistarelli P Codognet F Rossi Abstracting soft constraints framework properties examples Artif Intell 139 2002 175211 14 B Bonet G De Giacomo H Geffner S Rubin Generalized planning nondeterministic abstractions trajectory constraints Proceedings 26th International Joint Conference Artiﬁcial Intelligence IJCAI 2017 2017 pp 873879 15 B Bonet H Geffner Policies generalize solving planning problems policy Proceedings 24th International Joint Conference Artiﬁcial Intelligence IJCAI 2015 AAAI Press 2015 16 M Brain M Gebser J Pührer T Schaub H Tompits S Woltran Debugging asp programs means asp Proceedings 9th International Conference Logic Programming Nonmonotonic Reasoning LPNMR 2007 Springer 2007 pp 3143 17 S Brass J Dix Characterizations disjunctive stable semantics partial evaluation J Log Program 32 1997 207228 18 G Brewka T Eiter M Truszczy nski Answer set programming glance Commun ACM 54 2011 92103 19 G Brewka T Eiter M Truszczy nski Eds Answer Set Programming AI Mag 37 3 2016 AAAI Press 20 P Cabalar J Fandinno M Fink Causal graph justiﬁcations logic programs Theory Pract Log Program 14 2014 603618 21 F Calimeri W Faber M Gebser G Ianni R Kaminski T Krennwallner N Leone M Maratea F Ricca T Schaub ASPcore2 input language format arXiv191104326 2019 httpsdoi org 10 1613 jair4591 22 BD Cat M Denecker M Bruynooghe PJ Stuckey Lazy model expansion interleaving grounding search J Artif Intell Res 52 2015 235286 23 L Chittaro R Ranon Hierarchical modelbased diagnosis based structural abstraction Artif Intell 155 2004 147182 24 KL Clark Negation failure Logic Data Bases Springer 1978 pp 293322 25 E Clarke O Grumberg S Jha Y Lu H Veith Counterexampleguided abstraction reﬁnement symbolic model checking J ACM 50 2003 752794 26 EM Clarke O Grumberg DE Long Model checking abstraction ACM Trans Program Lang Syst 1994 15121542 27 EM Clarke TA Henzinger H Veith R Bloem Handbook Model Checking Springer 2018 28 M Cohen M Dam A Lomuscio F Russo Abstraction model checking multiagent systems International Conference Autonomous Agents Multiagent Systems vol 2 2009 pp 945952 29 P Cousot R Cousot Abstract interpretation application logic programs J Log Program 13 1992 103179 30 KJW Craik The Nature Explanation vol 445 CUP Archive 1952 31 JC Culberson J Schaeffer Pattern databases Comput Intell 14 1998 318334 32 D Dams R Gerth O Grumberg Abstract interpretation reactive systems ACM Trans Program Lang Syst 19 1997 253291 33 E Dantsin T Eiter G Gottlob A Voronkov Complexity expressive power logic programming ACM Comput Surv 33 2001 374425 34 J Devriendt B Bogaerts M Bruynooghe M Denecker On local domain symmetry model expansion Theory Pract Log Program 16 2016 35 J Dix U Kuter D Nau Planning answer set programming ordered task decomposition Annual Conference Artiﬁcial Intelligence 36 C Dodaro P Gasteiger B Musitsch F Ricca K Shchekotykhin Interactive debugging nonground asp programs Logic Programming Non 636652 httpsdoi org 10 1017 S1471068416000508 Springer 2003 pp 490504 monotonic Reasoning LPNMR Springer 2015 pp 279293 37 C Drescher O Tifrea T Walsh Symmetrybreaking answer set solving AI Commun 24 2011 177194 httpsdoi org 10 3233 AIC 2011 0495 38 S Edelkamp Planning pattern databases Proceedings 6th European Conference Planning ECP 2001 2001 pp 1324 39 T Eiter W Faber M Fink S Woltran Complexity results answer set programming bounded predicate arities implications Ann Math Artif Intell 51 2007 123 Springer 2003 pp 224238 40 T Eiter M Fink Uniform equivalence logic programs stable model semantics International Conference Logic Programming 41 T Eiter M Fink T Krennwallner C Redl HEXprograms existential quantiﬁcation M Hanus R Rocha Eds Declarative Programming Knowledge Management Declarative Programming Days KDPD 2013 Unifying INAP WFLP WLP Kiel Germany September 1113 2013 Springer 2013 pp 99117 Revised Selected Papers httpsdoi org 10 1007 978 3 319 08909 6 _7 42 T Eiter M Fink H Tompits S Woltran Simplifying logic programs uniform strong equivalence V Lifschitz I Niemelä Eds Proceed ings 7th International Conference Logic Programming Nonmonotonic Reasoning LPNMR 2004 Springer 2004 pp 8799 43 T Eiter M Fink S Woltran Semantical characterizations complexity equivalences answer set programming ACM Trans Comput Log 8 44 T Eiter G Gottlob Y Gurevich Normal forms secondorder logic ﬁnite structures classiﬁcation NP optimization problems Ann Pure 2007 17 httpsdoi org 10 1145 1243996 1244000 Appl Log 78 1996 111125 45 T Eiter ZG Saribatur P Schüller Abstraction zoomingin unsolvability reasons gridcell problems Proceedings IJCAI 2019 Work shop Explainable Artiﬁcial Intelligence XAI 2019 pp 713 Online available httpsdrive google com ﬁle d 1ma5wilaj31A0d5KC4I2fYaTC _Lqm _ d9X view httparxivorg abs 1909 04998 46 T Eiter H Tompits S Woltran On solution correspondences answerset programming LP Kaelbling A Saﬃotti Eds IJCAI05 Proceedings Nineteenth International Joint Conference Artiﬁcial Intelligence Edinburgh Scotland UK July 30 August 5 2005 Professional Book Center 2005 pp 97102 httpijcai org Proceedings 05 Papers 1177pdf 47 E Erdem M Gelfond N Leone Applications answer set programming AI Mag 37 2016 5368 48 E Erdem V Patoglu Applications ASP robotics Künstl Intell 32 2018 143149 49 AA Falkner G Friedrich K Schekotihin R Taupe EC Teppan Industrial applications answer set programming Künstl Intell 32 2018 165176 50 J Fandinno C Schulz Answering answer set programming survey explanation approaches Theory Pract Log Program 19 2019 51 M Fox D Long The detection exploitation symmetry planning problems Proceedings 16th International Joint Conference 114203 Artiﬁcial Intelligence IJCAI 1999 1999 pp 956961 52 EC Freuder Eliminating interchangeable values constraint satisfaction problems AAAI 1991 pp 227233 53 M Gebser R Kaminski B Kaufmann M Ostrowski T Schaub S Thiele Engineering incremental ASP solver Proceedings 24th Interna tional Conference Logic Programming ICLP 2008 2008 pp 190205 54 M Gebser B Kaufmann A Neumann T Schaub Advanced preprocessing answer set solving Proceedings 18th European Conference Artiﬁcial Intelligence ECAI 2008 IOS Press 2008 pp 1519 70 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 55 M Gebser J Pührer T Schaub H Tompits A metaprogramming technique debugging answerset programs Proceedings 23rd AAAI Conference Artiﬁcial Intelligence AAAI 2008 2008 pp 448453 56 T Geibinger H Tompits Characterising relativised strong equivalence projection nonground answerset programs F Calimeri N Leone M Manna Eds Logics Artiﬁcial Intelligence 16th European Conference Proceedings JELIA 2019 Rende Italy May 711 2019 Springer 2019 pp 542558 57 M Gelfond V Lifschitz Classical negation logic programs disjunctive databases New Gener Comput 9 1991 365385 58 E Giunchiglia Y Lierler M Maratea Satbased answer set programming Proceedings 19th National Conference Artiﬁcial Intelligence AAAI 2004 2004 pp 6166 59 F Giunchiglia T Walsh A theory abstraction Artif Intell 57 1992 323389 60 G Gottlob N Leone H Veith Succinctness source complexity logical formalisms Ann Pure Appl Log 97 1999 231260 61 M Helmert P Haslum J Hoffmann et al Flexible abstraction heuristics optimal sequential planning Proceedings 17th International Conference Automated Planning Scheduling ICAPS 2007 2007 pp 176183 62 IT Hernádvölgyi RC Holte Psvn A Vector Representation Production Systems 1999 63 J Hoffmann A Sabharwal C Domshlak Friends foes An AI planning perspective abstraction search Proceedings 16th Interna tional Conference Automated Planning Scheduling ICAPS 2006 2006 pp 294303 64 RC Holte T Mkadmi RM Zimmer AJ MacDonald Speeding problem solving abstraction graph oriented approach Artif Intell 85 1996 65 L Illanes SA McIlraith Numeric planning search space abstraction Proceedings Workshop KnowledgeBased Techniques Problem 66 L Illanes SA McIlraith Generalized planning abstraction arbitrary numbers objects Proceedings 33rd AAAI Conference Artiﬁcial 67 T Janhunen I Niemelä D Seipel P Simons JH You Unfolding partiality disjunctions stable model semantics ACM Trans Comput Log 7 321361 Solving Reasoning 2016 Intelligence AAAI 2019 2019 2006 137 68 PN JohnsonLaird Mental Models Towards Cognitive Science Language Inference Consciousness Harvard University Press 1983 69 S Kambhampati L Davis Multiresolution path planning mobile robots IEEE J Robot Autom 2 1986 135145 70 CA Knoblock Automatically generating abstractions planning Artif Intell 68 1994 243302 71 J Kramer Is abstraction key computing Commun ACM 50 2007 3642 72 C Lefèvre C Béatrix I Stéphan L Garcia Asperix ﬁrstorder forward chaining approach answer set computing Theory Pract Log Program 17 73 J Leite A birdseye view forgetting answerset programming Proceedings 14th International Conference Logic Programming Nonmonotonic Reasoning LPNMR 2017 Springer 2017 pp 1022 74 N Leone G Pfeifer W Faber T Eiter G Gottlob S Perri F Scarcello The DLV knowledge representation reasoning ACM Trans 2017 266310 Comput Log 7 2006 499562 75 N Leone P Rullo F Scarcello Disjunctive stable models unfounded sets ﬁxpoint semantics computation Inf Comput 135 1997 69112 76 MH Liﬃton KA Sakallah Algorithms computing minimal unsatisﬁable subsets constraints J Autom Reason 40 2008 133 77 V Lifschitz Answer set planning International Conference Logic Programming ICLP 1999 pp 2337 78 V Lifschitz Twelve deﬁnitions stable model M Garcia la Banda E Pontelli Eds Logic Programming Springer Berlin Heidelberg 2008 pp 3751 79 V Lifschitz What answer set programming Proceedings 23rd AAAI Conference Artiﬁcial Intelligence AAAI 2008 2008 pp 15941597 80 V Lifschitz D Pearce A Valverde Strongly equivalent logic programs ACM Trans Comput Log 2 2001 526541 81 F Lin Y Zhao Assat computing answer sets logic program sat solvers Artif Intell 157 2004 115137 82 C Loiseaux S Graf J Sifakis A Bouajjani S Bensalem D Probst Property preserving abstractions veriﬁcation concurrent systems Form Methods Syst Des 6 1995 1144 83 A Lomuscio J Michaliszyn An abstraction technique veriﬁcation multiagent systems atl speciﬁcations Proceedings 14th International Conference Principles Knowledge Representation Reasoning KR 2014 AAAI Press 2014 84 A Lomuscio J Michaliszyn Veriﬁcation multiagent systems predicate abstraction ATLK speciﬁcations Proceedings AAMAS 2016 85 I Lynce JPM Silva On computing minimum unsatisﬁable cores Proceedings 7th International Conference Theory Applications 86 MJ Maher Equivalences logic programs E Shapiro Ed Third International Conference Logic Programming Springer Berlin Heidelberg pp 662670 Satisﬁability Testing SAT 2004 2004 1986 pp 410424 87 K Marple E Salazar G Gupta Computing stable models normal logic programs grounding arXiv1709 00501 2017 88 M Morak S Woltran Preprocessing complex nonground rules answer set programming Technical Communications 28th International Conference Logic Programming 2012 p 247 89 I Mozetiˇc Hierarchical modelbased diagnosis Int J ManMach Stud 35 1991 329362 90 PP Nayak AY Levy A semantic theory abstractions Proc International Joint Conference Artiﬁcial Intelligence 1995 pp 196203 91 B Nebel Y Dimopoulos J Koehler Ignoring irrelevant facts operators plan generation European Conference Planning Springer 1997 pp 338350 92 A Newell HA Simon Human Problem Solving PrenticeHall 1972 93 J Oetsch J Pührer H Tompits Catching ouroboros debugging nonground answerset programs Theory Pract Log Program 10 2010 94 E Oikarinen T Janhunen Modular equivalence normal logic programs Proceedings 17th European Conference Artiﬁcial Intelligence 95 M Osorio JA Navarro J Arrazola Equivalence answer set programming A Pettorossi Ed Logic Based Program Synthesis Transformation 513529 ECAI 2006 IOS Press 2006 pp 412416 Springer Berlin Heidelberg 2002 pp 5775 96 AD Palù A Dovier E Pontelli G Rossi Gasp answer set programming lazy grounding Fundam Inform 96 2009 297322 97 D Pearce Simplifying logic programs answer set semantics Logic Programming 2004 pp 210224 98 D Pearce Equilibrium logic Ann Math Artif Intell 47 2006 341 99 D Pearce A Valverde Synonymus theories answer set programming equilibrium logic RL Mántaras L Saitta Eds Proceedings 16th Eureopean Conference Artiﬁcial Intelligence ECAI2004 Including Prestigious Applicants Intelligent Systems PAIS 2004 Valencia Spain August 2227 2004 IOS Press 2004 pp 388392 100 D Pearce A Valverde Quantiﬁed equilibrium logic foundations answer set programs MG la Banda E Pontelli Eds Logic Program ming 24th International Conference Proceedings ICLP 2008 Udine Italy December 913 2008 Springer 2008 pp 546560 101 D Pearce A Valverde Synonymous theories knowledge representations answer set programming J Comput Syst Sci 78 2012 86104 httpsdoi org 10 1016 j jcss 201102 013 71 ZG Saribatur T Eiter P Schüller Artiﬁcial Intelligence 300 2021 103563 1987 pp 349362 102 DA Plaisted Theorem proving abstraction Artif Intell 16 1981 47108 103 E Pontelli TC Son O Elkhatib Justiﬁcations logic programs answer set semantics Theory Pract Log Program 9 2009 156 104 J Pührer H Tompits Casting away disjunction negation generalisation strong equivalence projection E Erdem F Lin T Schaub Eds Logic Programming Nonmonotonic Reasoning 10th International Conference Proceedings LPNMR 2009 Potsdam Germany September 1418 2009 Springer 2009 pp 264276 105 P Riddle J Douglas M Barley S Franco Improving performance reformulating PDDL bagged representation Proceedings Work shop Heuristics Search DomainIndependent Planning HSDIP 2016 2016 pp 2836 106 ED Sacerdoti Planning hierarchy abstraction spaces Artif Intell 5 1974 115135 107 Y Sagiv Optimizing datalog programs Proceedings 6th ACM SIGACTSIGMODSIGART Symposium Principles Database Systems ACM 108 L Saitta JD Zucker Abstraction Artiﬁcial Intelligence Complex Systems vol 456 Springer 2013 109 ZG Saribatur T Eiter Reactive policies planning action languages Proceedings 15th European Conference Logics Artiﬁcial Intelligence JELIA 2016 Lecture Notes Computer Science vol 10021 Springer 2016 pp 463480 110 ZG Saribatur T Eiter Omissionbased abstraction answer set programs Proceedings 16th International Conference Principles Knowledge Representation Reasoning KR 2018 AAAI Press 2018 pp 4251 111 ZG Saribatur T Eiter Omissionbased abstraction answer set programs Theory Pract Log Program 2020 151 Extended version 110 112 ZG Saribatur T Eiter A semantic perspective omission abstraction ASP Proceedings 17th International Conference Principles Knowledge Representation Reasoning KR 2020 IJCAI Organization 2020 pp 733737 113 ZG Saribatur P Schüller T Eiter Abstraction nonground answer set programs Proceedings 16th European Conference Logics Artiﬁcial Intelligence JELIA 2019 Lecture Notes Computer Science Springer 2019 pp 576592 114 T Schaub S Woltran Answer set programming unleashed Kidney Int 32 2018 105108 115 C Schulz F Toni ABAbased answer set justiﬁcation Theory Pract Log Program 2013 45 116 J Seipp M Helmert Counterexampleguided Cartesian abstraction reﬁnement Proceedings 23rd International Conference Automated Planning Scheduling ICAPS 2013 2013 117 P Simons I Niemelä T Soininen Extending implementing stable model semantics Artif Intell 138 2002 181234 118 S Srivastava N Immerman S Zilberstein A new representation associated algorithms generalized planning Artif Intell 175 2011 615647 119 H Turner Strong equivalence easy nested expressions weight constraints Theory Pract Log Program 3 2003 609622 120 A Van Gelder KA Ross JS Schlipf The wellfounded semantics general logic programs J ACM 38 1991 619649 121 A Weinzierl Blending lazygrounding CDNL search answerset solving Logic Programming Nonmonotonic Reasoning 14th Interna tional Conference Proceedings LPNMR 2017 Espoo Finland July 36 2017 2017 pp 191204 122 S Woltran A common view strong uniform notions equivalence answerset programming Theory Pract Log Program 8 2008 217234 httpsdoi org 10 1017 S1471068407003250 123 S Zhang F Yang P Khandelwal P Stone Mobile robot planning action language BC abstraction hierarchy Proc International Conference Logic Programming Nonmonotonic Reasoning LPNMR Springer 2015 pp 502516 72