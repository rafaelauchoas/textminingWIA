Artiﬁcial Intelligence 174 2010 105132 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Bounded treewidth key tractability knowledge representation reasoning Georg Gottlob Reinhard Pichler b Fang Wei c Computing Laboratory Oxford University Oxford OX1 3QD UK b Institut für Informationssysteme Technische Universität Wien A1040 Vienna Austria c Institut für Informatik AlbertLudwigsUniversität Freiburg D79110 Freiburg Br Germany r t c l e n f o b s t r c t Article history Received 9 October 2008 Received revised form 6 October 2009 Accepted 15 October 2009 Available online 20 October 2009 Keywords Fixedparameter tractability Treewidth Monadic datalog Abduction Closed world reasoning Disjunctive logic programming 1 Introduction Several forms reasoning AI like abduction closed world reasoning circumscription disjunctive logic programming known intractable In fact relevant problems second level polynomial hierarchy In paper notion treewidth fruitfully applied area In particular problems tractable actually solvable linear time treewidth involved formulae programs bounded constant Clearly theoretical tractability results immediately yield feasible algorithms However recently established new method based monadic datalog allowed design eﬃcient algorithm related problem database area In work exploit monadic datalog approach construct new algorithms logicbased abduction 2009 Elsevier BV All rights reserved In nineteennineties forms reasoning AI like abduction closed world reasoning circumscription disjunctive logic programming shown highly intractable In fact relevant problems area second level polynomial hierarchy 2022 In recent years parameterized complexity evolved interesting approach dealing intractability 19 It turned hard problems tractable problem parameter ﬁxed bounded ﬁxed constant If problem enjoys property speak ﬁxedparameter tractability FPT short In arena graph problems important parameter investigated socalled treewidth graph G measure treelikeness G If treewidth graphs consideration bounded ﬁxed constant intractable problems tractable 3colorability Hamiltonicity More generally treewidth considered arbitrary ﬁnite structures Treewidth applied areas AI notably constraint satisfaction 2 A deep result mathematical tool deriving new FPTresults Courcelles Theorem 14 states property ﬁnite structures expressible Monadic Second Order MSO short sentence property decidable linear time structures treewidth bounded ﬁxed constant Courcelles Theorem This extended enhanced version results published Gottlob Pichler Wei 2006 2008 2931 The work supported Austrian Science Fund FWF project P20704N18 Corresponding author Email addresses georggottlobcomlaboxacuk G Gottlob pichlerdbaituwienacat R Pichler fweiinformatikunifreiburgde F Wei 00043702 matter 2009 Elsevier BV All rights reserved doi101016jartint200910003 106 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 developed works recent paper 24 eﬃcient algorithm counting solutions SAT Generalized SAT problem presented In paper revisit intractable problems AI Our goal harness powerful machinery Courcelles Theorem area knowledge representation reasoning We virtually decision problems arising context abduction closed world reasoning circumscription disjunctive logic programming tractable treewidth involved formulae programs bounded constant The central idea deriving FPTresults encode decision problems terms MSO sentences Clearly MSO description algorithm highly nontrivial task turn theoretical tractability result based Courcelles Theorem feasible computation Actually recipes devise concrete algorithms based Courcelles Theorem literature 3121125 The basic idea algorithms transform MSO evaluation problem equivalent tree language recognition problem solve appropri ate ﬁnite tree automaton FTA 174647 In theory generic method turning MSO description concrete algorithm looks appealing However practice turned relatively simple MSOformulae lead state explosion FTA 2641 Hence stated 32 algorithms derived Courcelles Theorem useless practical applications The main beneﬁt Courcelles Theorem provides simple way recognize property linear time computable In words proving FPT problem showing MSO expressible starting point end point search eﬃcient algorithm In 30 proposed monadic datalog datalog intensional predicate symbols unary practical tool devising eﬃcient algorithms situations FPT established Courcelles Theorem Above proved property ﬁnite structures expressible MSO property expressed means monadic datalog program decomposed structure mean original structure augmented new elements new relations encode tree decompositions Moreover approach work designing eﬃcient algorithm PRIMALITY problem problem deciding attribute key given relational schema In paper monadic datalog approach applied diﬃcult knowledge representation reasoning tasks We present new algorithms logicbased abduction report experimental results implementation algorithms 11 Summary results The main contribution paper twofold First prove ﬁxedparameter tractability relevant decision problems arising abduction closed world reasoning circumscription disjunctive logic programming Second theoretical tractability results actually turned feasible computations We present new algorithms logicbased abduction However ideas underlying construction algorithms course applicable hard problems areas mentioned Hence FPTresults shown open grounds development new parameterized algorithms problems 12 Structure paper The rest paper organized follows After recalling basic deﬁnitions results Section 2 prove new ﬁxedparameter tractability results Courcelles Theorem Section 3 In Section 4 present new algorithms logicbased abduction Experimental results discussed Section 5 A conclusion given Section 6 Appendices A B provided order encapsulate lengthy technical details required understanding main body text 2 Preliminaries 21 Finite structures treewidth A Let τ R1 R K set predicate symbols A ﬁnite structure A τ τ structure short given Aαi αi denotes arity R τ All structures trees considered ﬁnite domain A domA relations R work assumed ﬁnite Hence sequel ﬁniteness usually explicitly mentioned A tree decomposition T τ structure A deﬁned pair cid5T At tT cid6 T rooted tree At subset A following properties 1 Every A contained At 2 For R τ tuple At 3 For A set t At induces a1 aαi R subtree T exists node t T a1 aαi Condition 3 usually referred connectedness condition The sets At called bags blocks T The width tree decomposition cid5T AttT cid6 deﬁned max At t T 1 The treewidth A minimal width tree decompositions A It denoted twA Note forests simple loopfree graphs treewidth 1 A For given w cid2 1 decided linear time structure treewidth w Moreover case positive answer tree decomposition width w computed linear time 8 Strictly speaking result 8 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 107 Fig 1 Tree decomposition T formula F refers tree decompositions graphs arbitrary structures However associate graph G socalled primal Gaifman graph structure A taking domain elements vertices graph Moreover vertices adjacent G corresponding domain elements jointly occur tuple A It easily shown G precisely tree decompositions A Unfortunately shown linear time algorithm mainly theoretical practical use fulness limited 39 Recently considerable progress developing heuristicbased tree decomposition algorithms handle graphs moderate size hundreds vertices 3994910 Moreover cases tree decomposition low width obtained given problem natural way For instance 48 shown treewidth controlﬂow graph gotofree C program A similar result shown Java programs 33 These results opened ground eﬃcient implementation compiler optimization tasks like register allocation problem In paper shall constantly deal propositional formulae CNF analogously clause sets A propositional formula F CNF respectively clause set F represented structure A alphabet τ cl var pos neg clz respectively varz means z clause respectively variable F posx c respectively negx c means x occurs unnegated respectively negated clause c We deﬁne treewidth F treewidth structure A twF twA Example 21 Consider propositional formula F F x1 x2 x3 x1 x4 x5 x2 x4 x6 The corresponding structure A identiﬁed following set ground atoms cid2 A varx1 varx2 varx3 varx4 varx5 varx6 clc1 clc2 clc3 posx1 c1 posx3 c1 posx4 c2 posx2 c3 posx6 c3 cid3 negx2 c1 negx1 c2 negx5 c2 negx4 c3 A tree decomposition T structure given Fig 1 Note maximal size bags T 3 Hence treewidth 2 On hand easy check treewidth T smaller 2 In order consider ground atoms posx1 c1 negx2 c1 posx2 c3 negx4 c3 posx4 c2 negx1 c2 A undirected edges graph Clearly edges form cycle However recalled forests simple loopfree graphs treewidth 1 This tree decomposition optimal twF twA 2 In 30 shown tree decomposition transformed following normal form linear time Deﬁnition 22 Let A structure tree decomposition T cid5T At tT cid6 width w We T normalized T rooted tree conditions 14 fulﬁlled 1 All bags consist pairwise distinct elements a0 ak 0 cid3 k cid3 w 2 Every internal node t T child nodes 3 If node t child node t bag At obtained Atcid9 removing element introducing new element 4 If node t child nodes child nodes identical bags t cid9 Example 23 Recall tree decomposition T Fig 1 Clearly T normalized sense However easily transformed normalized tree decomposition T cid9 Fig 2 Let A τ structure τ R1 R K domain A let w cid2 1 denote treewidth Then deﬁne extended signature τtd τtd τ root leaf child1 child2 bag 108 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 Fig 2 Normalized tree decomposition T cid9 formula F unary predicates root leaf binary predicates child1 child2 represent tree T normalized tree decomposition obvious way For instance write child1s1 s denote s1 ﬁrst child child s Finally bag arity k 2 k cid3 w bagt a0 ak means bag node t a0 ak By slight abuse notation tacitly assume bag overloaded values k Note possible values k bounded ﬁxed constant w For τ structure A tree decomposition T cid5T At tT cid6 width w write Atd denote decomposed structure structure decomposing A This structure obtained A following way The domain Atd union domA nodes T In addition relations R R τ structure Atd contains relations predicate root leaf child1 child2 bag representing tree decomposition T By combining results 8 30 compute Atd A linear time wrt size A Example 24 Recall propositional formula F x1 x2 x3 x1 x4 x5 x2 x4 x6 Example 21 We shown F represented structure A signature τ cl var pos neg In order represent tree decomposition T cid9 Fig 2 structure Atd add following ground atoms A roott1 child1t2 t1 child2t3 t1 child1t4 t2 leaf t16 leaf t19 leaf t20 bagt1 x1 x2 x4 bagt2 x1 x2 x4 bagt3 x1 x2 x4 bagt4 x1 x2 The numbering nodes t1 t2 t3 corresponds breadthﬁrst traversal T cid9 22 MSO monadic datalog Monadic Second Order logic MSO extends First Order logic FO use set variables usually denoted upper case letters range sets domain elements In contrast individual variables usually denoted lower case letters range single domain elements Atomic formulae MSOformula ϕ τ structure following forms atoms predicate symbol τ ii atoms predicate symbol monadic second order variable set variable iii equality atoms It convenient use symbols like obvious meaning abbreviations An MSOformula ϕx exactly free individual variable called unary query The importance MSOformulae context parameterized complexity comes following result Theorem 25 See 14 Let ϕ MSOsentence signature τ let A τ structure treewidth w Evaluating sentence ϕ structure A time O f ϕx w A function f In sequel shall simply structures bounded treewidth explicitly mentioning w Note ﬁxedparameter linearity according Theorem 25 applies data complexity formula ϕ ﬁxed There FPTresult consider combined complexity instead ϕ input Datalog programs functionfree logic programs Each unique minimal model Evaluating datalog pro gram P structure A comes computing minimal model P A This minimal model coincides set ground facts obtained ﬁxpoint immediate consequence operator details 1 In sequel shall refer program P structure A interpreted program A datalog program called ground contains variables Evaluating datalog program P structure A equivalent evaluating follow ing ground program P cid9 contains possible instances r instantiating variable r constant occurring P A set constants referred active domain In general P cid9 exponentially bigger P However cases small fraction set possible ground instances rule r necessary shall proof Theorem 42 A For clause r P P cid9 Predicates occurring body rules called extensional predicates occurring head rule called intensional G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 109 Let A τ structure domain A relations R Aαi αi denotes arity R τ In context datalog convenient think relations R sets ground atoms The set ground atoms structure A referred extensional database EDB A ground atom R ia EDB R A A 1 R A K R A A In 30 following connection unary MSO queries structures bounded treewidth monadic datalog established Theorem 26 Let τ signature let w cid2 1 Every unary MSOquery ϕx τ structures treewidth w deﬁnable monadic datalog program τtd Moreover τ structure A resulting program evaluated time O f ϕx w A function f A denotes size A Note connection logic programming functions tree automata studied earlier 4023 As far upper bound complexity concerned theorem special case Theorem 412 25 3 Fixedparameter tractability Courcelles Theorem In section ﬁxedparameter tractability wrt treewidth decision problems area disjunctive logic programming closed world reasoning circumscription abduction Fundamental problems evaluation propositional formula interpretation We start exposition SAT problem ﬁxedparameter tractability parameters including cliquewidth treewidth shown 15 31 SAT problem A propositional formula F built propositional variables denoted VarF logical connectives An interpretation F mapping assigns truth values true false variable occurring F It convenient identify interpretations subsets X VarF intended meaning variables X evaluate true variables evaluate false If F evaluates true X X called model F cid9 X We write F 1 cid14 F 2 formula Moreover X called minimal model exists model X F 1 F 2 valid F 1 F 2 true interpretation X VarF 1 VarF 2 Likewise F F 1 Fm set formulae F single formula write F cid14 F formula F 1 Fm F valid The following result folklore 544 F X cid9 Theorem 31 For propositional formula F exists formula F hold cid9 CNF VarF VarF cid9 st following properties 1 For interpretation X st X model F exists interpretation Y X Y Y X VarF cid9 VarF st Y model F 2 For interpretation Y st Y model F cid9 cid9 interpretation Y VarF model F Moreover F cid9 linear time size F cid9 linearly bounded size F cid9 Proof Given propositional formula F variables V ﬁrst compute parse tree T F This clearly feasible linear time This parse tree considered Boolean circuit node tree corresponds gate leaf nodes labeled variables input gates root node output gate edge parse tree oriented child parent The construction CNF follows wellknown reduction CIRCUIT SAT problem SAT problem 44 Example 83 In addition variables V CNF F contains additional variable internal node g parse tree T cid9 For leaf nodes simply use corresponding propositional variable x node The clauses F obtained internal node g T case distinction possible operations represented node 1 Suppose g corresponds NOToperation Then g precisely incoming arc node h Then add clauses g h g h F That clauses express condition g h cid9 2 Suppose g corresponds ANDoperation Then g incoming arcs nodes h1 h2 Then That clauses express condition add clauses g h1 g h2 h1 h2 g F g h1 h2 cid9 3 Suppose g corresponds ORoperation Then g incoming arcs nodes h1 h2 Then That clauses express condition add clauses g h1 g h2 h1 h2 g F g h1 h2 cid9 cid9 Clearly F cid9 CNF The desired properties Finally root node r T add oneliteral clause r F cid9 particular satequivalence F easily veriﬁed cid2 F 110 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 cid9 Note CNF F constructed proof Theorem 31 uniquely determined variable renaming canonical CNF F It represented parse tree F form F We shall refer F cid9 st var identify variables occurring τ structure AF τ var cl F cl usual way In Section 21 deﬁned treewidth propositional formula F CNF analogously clause set treewidth structure representing F Likewise deﬁne treewidth arbitrary propositional formula F treewidth canonical CNF F F equivalently treewidth τ structure AF cid9 represent CNF F cid9 neg cid9 neg cid9 pos cid9 pos var var cid9 cid9 cid9 cid9 cid9 The notion treewidth naturally extended formula CNF let F 1 F 2 propo sitional formulae CNF Then F 1 F 2 represented τ structure AF 1 F 2 τ cli vari posi negi 1 cid3 cid3 2 We deﬁne treewidth F 1 F 2 treewidth structure A We twF 1 F 2 twAF 1 F 2 twF 1 F 2 If F 1 F 2 CNF represent formulae structure cid9 A signature τ vari cl 1 cid3 cid3 2 vari identify variables cid9 cid9 pos occurring F cl usual way Again treewidth F 1 F 2 deﬁned treewidth structure A cid9 pos cid9 represent CNF F cid9 var cid9 neg cid9 neg cid9 var From results 15 following relationship CNFformulae MSO easily derived Theorem 32 Let F propositional formula CNF given τ structure A τ cl var pos neg Moreover let X denote set variables X VarF Then property X model F expressed MSOformula referred model X F signature τ Proof We deﬁne MSOformula model X F follows cid6 posz c z X modelX F c clc z cid4cid5 cid5 negz c z X cid6cid7 This MSOformula expresses following equivalence F true X clause F true X This turn case clause contains positive occurrence variable z X negative occurrence variable z X cid2 Clearly Theorem 32 Courcelles Theorem immediately yields ﬁxedparameter tractability SAT problem wrt treewidth τ structure A τ cl var pos neg representing propositional formula 15 Actually F CNF property X model F expressed terms MSO Theorem 33 Let F propositional formula canonical CNF F cid9 var cl cid9 expressed MSOformula referred model cid9 let F given τ structure A τ cid9 Moreover let X denote set variables X VarF Then property X model F X F signature τ cid9 neg cid9 pos var Proof We deﬁne MSOformula model cid9 X F follows cid9 Ext F X X cid9 model X X cid9 X F X cid4 cid9 z cid4 Ext F X X z X cid9 cid5 var cid6cid7 cid9 cid9 F cid9 z X cid5 modelX cid9 cid9 z varz cid6cid7 The auxiliary formula Ext F X X subformula model X cid9 F cid9 precisely CNFevaluation Theorem 32 cid2 cid9 means X extension interpretation X variables F cid9 Moreover Finally provide MSOformula expressing F 1 cid14 F 2 holds propositional formulae F 1 F 2 Theorem 34 Let F 1 F 2 propositional formulae canonical CNFs F τ vari cl MSOformula referred impliesF 1 F 2 signature τ cid9 neg cid9 pos cid9 var cid9 2 let F 1 F 2 given τ structure A cid9 1 cid3 cid3 2 Then property F 1 cid14 F 2 holds expressed means cid9 1 F Proof We deﬁne MSOformula impliesF 1 F 2 follows cid5 cid9 model X F 2 cid6cid7 cid4 X cid9 model X F 1 cid9 The subformulae model according Theorem 33 cid2 X F 1 2 MSOformulae expressing evaluation propositional formulae F 32 Disjunctive logic programming A disjunctive logic program DLP short P set DLP clauses a1 b1 bk bk1 bm Let I interpretation Then GelfondLifschitz reduct P I P wrt I contains precisely clauses a1 b1 bk G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 111 st k 1 m bi I An interpretation I called disjunctive stable model DSM short I minimal model P I 2745 Without restrictions following problems second level polynomial hierarchy 22 Consistency Does P DSM Brave Reasoning Is propositional formula F true DSM P written P cid14b F Cautious Reasoning Is propositional formula F true DSMs P written P cid14c F The intuition stable models follows Consider reduct program P respect interpretation I We think I making assumption true false Consequently delete rules program body deﬁnitely false assumption arriving reduct P I Now compute positive information derivable P I If result I I called stable model Negation stable model semantics received lot signiﬁcantly increases expressive power logic programs For instance making use disjunctions rule heads express classi cal NPcomplete 3colorability problem following program Let G V E graph vertices V v 1 vn edges E Then G represented logic program consisting following facts ei j 1 cid3 j cid3 n exists edge v v j The 3colorability G expressed adding following clauses program note commas righthand rules stand logical ri gi bi gi ri bi bi ri gi 1 cid3 cid3 n ei j ri r j ei j gi g j ei j bi b j 1 cid3 j cid3 n The stable models program correspond proper 3colorings graph G Intuitively ﬁrst collection clauses makes sure stable model exactly variables ri gi bi true 1 n The second collection clauses excludes colorings assign identical colors endpoints edge In particular question given graph proper 3coloring equivalent consistency problem described program program stable model Suppose want ask exists proper 3coloring vertices v 1 v 2 v 3 color This question corresponds brave reasoning problem P cid14b F P program F r1 r2 r3 g1 g2 g3 b1 b2 b3 Likewise question v 1 v 2 v 3 color proper 3coloring corresponds cautious reasoning problem P cid14c F P F Many ex amples disjunctive logic programs negation solving problems diverse application areas httpwwwkrtuwienacatresearchprojectsWASP Below treewidth programs P formulae F consideration bounded constant favorable complexity results general case Suppose DLP P given τ st var P clP encode variables clauses P structure τ var P clP H B x c means x occurs unnegated Moreover Hx c means x occurs head c B respectively negated body c Then x c respectively B B cid9 Theorem 33 The Theorem 35 Consider signatures τ1 var P clP H B Consistency problem DLPs expressed means MSOsentence signature τ1 Likewise Brave Reasoning Cautious Reasoning problem DLPs expressed means MSOsentences signature τ1 τ2 cid9 τ2 var cl cid9 neg cid9 pos B var cid9 Proof Recall Theorem 33 property X model F expressed MSOformula model signature τ2 We X F GLX Y cclP c z cid4 DSMX GLX X Z Hz c z X cid7 Z X GLZ X cid6 B z c z X cid6 cid5 B z c z Y cid6cid7 cid5 cid4cid5 Consistency XDSMX cid4 Brave Reasoning X cid4 Cautious Reasoning X DSMX model DSMX model cid9 cid7 X F cid9 cid7 X F The predicates deﬁned following meaning GL X Y X model GelfondLifschitz reduct program P wrt interpretation Y DSM X X disjunctive stable model P cid2 112 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 Fig 3 Tree decomposition structure AP Example 36 Example 36 Consider following DLP P c1 p q r c2 q p s c3 s t q Clearly P consistent instance p DSM The DLP P represented structure AP consists following ground atoms cid2 AP var P p var P q var P r var P s var P t clP c1 clP c2 clP c3 Hp c1 Hq c1 Hq c2 Hs c3 Ht c3 r c1 B p c2 B s c2 B cid3 q c3 B A tree decomposition T AP given Fig 3 The MSOformula GL X Y proof Theorem 35 clearly evaluates true AP X p Y p Moreover X Y p evaluates false Hence DSM X evaluates true X p consistency P correctly established MSOformula XDSM X The following complexity result immediate consequence Courcelles Theorem Theorem 35 cid9 Theorem 35 Let Theorem 37 Consider signatures τ1 var P clP H B instance Consistency problem DLPs given τ1structure A width w Then problem solved time O f w A function f cid9 τ2 var cl cid9 neg cid9 pos B var Likewise let instance Brave Reasoning problem Cautious Reasoning DLPs given τ1 τ2structure A width w Then problem solved time O f cid9w A function f cid9 33 Closed world reasoning circumscription Several forms closed world reasoning CWR short proposed literature CWA Closed World Assumption GCWA Generalized CWA EGCWA Extended GCWA CCWA Careful CWA ECWA Extended CWA They deﬁned terms following terminology Let T theory F propositional formulae let cid5P Q Z cid6 partition VarT Then write MT respectively MMT denote set models respectively minimal models T Moreover write MMT P Q Z denote set cid5P Q Z cid6minimal models T X MMT P Q Z X model T exists model Y T Y P X P Y Q X Q In 13 equivalent characterizations closure theory T CWR rules provided Below recall characterizations best suited purposes CWAT T K K positive literal st T cid19cid14 K GCWAT T K K positive literal X MMT K false X EGCWAT cid14 F X MMT X model F CCWAT P Q Z T K K positive literal P X MMT P Q Z K false X ECWAT P Q Z cid14 F X MMT P Q Z X model F The Deduction problem CWRrule C C CWA GCWA EGCWA CCWA ECWA follows Given T F possibly P Q Z CT cid14 F respectively CT P Q Z cid14 F hold In 20 problem shown Π p 2 complete harder rules C cid19 CWA In 28 shown propositional case Circumscription coincides ECWArule The formalisms closed world reasoning provide formal basis kinds inferences facts explicitly speciﬁed knowledge base They rise nonmonotonic reasoning sense new information invalidate previously derived conclusions In 13 classical Tweety example highlight differences formalisms Consider formula represents propositional version Tweety example cid5 cid6 b f b The intended meaning follows If Tweety bird b Tweety abnormal Tweety ﬂy f Moreover know Tweety bird We following closure CWRformalisms For G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 113 CCWA ECWArule assume P P minimized Q b Q ﬁxed Z f Z varies CWAT T f GCWAT T EGCWAT T f CCWAT P Q Z T ECWAT P Q Z T The CWArule rule lead inconsistency This case example Only CCWA ECWArule allow derive atom f Tweety ﬂy By EGCWArule formula f inferred Tweety abnormal Tweety ﬂy Again bounded treewidth better complexity results general case Let T F propo respectively Moreover suppose Deduction problem CWRrule sitional formulae canonical CNFs T C C CWA GCWA EGCWA CCWA ECWA given τ structure τ varT var F varT cid9 var F cid9 clT cid9 clF cid9 P Q Z The predicates varT var F identify variables original formulae T F The CNFs encoded usual means predicates varT cid9 var F cid9 clT cid9 clF cid9 Finally partition cid5P Q Z cid6 VarT encoded unary predicates P Q Z Of course CWRrules CWA GCWA EGCWA predicates P Q Z omitted Then F cid9 cid9 cid9 Theorem 38 Consider signature τ varT var F varT cid9 var F cid9 clT cid9 clF cid9 posT cid9 posF cid9 neg T cid9 F cid9 P Q Z described For CWRrules CWA GCWA EGCWA CCWA ECWA Deduction problem Circumscription expressed MSO sentences signature τ course CWA GCWA EGCWA predicates P Q Z needed Proof GCWA EGCWA special cases CCWA ECWA Q Z Moreover mentioned Circum scription equivalent ECWArule The remaining cases expressed following MSOsentences cid9 use formulae model X F impliesF 1 F 2 according Theorems 33 34 respectively Y P X P Y Q X Q model cid9 cid7 Y T cid9 cid4 X T Y MMX model varz varT z var F z clo1z varz impliesT z cid4 clo2z varz z P Y cid7 MMY z Y Deduction CWArule CCWArule cid4 X model cid9 cid5 X T z cid6 cloiz impliesX z model cid9 cid7 X F Deduction ECWArule cid4 X MMX model cid9 cid7 X F The predicates following meaning respectively MM X means X MMT P Q Z cid2 cloiz 1 2 means z closure T wrt CWArule 1 CCWArule 2 Analogously previous section immediately following complexity result Courcelles Theorem Theorem 35 cid9 Theorem 39 Consider signature τ varT var F varT cid9 var F cid9 clT cid9 clF cid9 posT cid9 posF cid9 neg T cid9 F cid9 P Q Z Theorem 38 Let instance Circumscription Deduction problem T cid14C F CWRrules C CWA GCWA EGCWA CCWA ECWA given τ structure A Then problems solved time O f w A function f 34 Propositional abduction A propositional abduction problem PAP short consists tuple cid5V H M Ccid6 V ﬁnite set propositional variables H V set hypotheses M V set manifestations C consistent theory form clause set A set S H solution P C S consistent C S cid14 M holds In abductive diagnosis problem manifestations M observed symptoms describing erroneous behavior clausal theory C constitutes description The solutions S H possible explanations observed symptoms Given PAP P basic problems propositional abduction following 114 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 Solvability Does exist solution P Relevance Given h H h contained solution P Necessity Given h H h contained solution P In 21 problems shown Σ p 2 complete Π p 2 complete The following example 34 help illustrate deﬁnitions Consider following football knowledge base C weak_defense weak_attack match_lost match_lost manager_sad press_angry star_injured manager_sad press_sad Moreover let set observed manifestations set hypotheses M manager_sad H star_injured weak_defense weak_attack This PAP following ﬁve abductive explanations solutions S1 star_injured S2 weak_defense weak_attack S3 weak_attack star_injured S4 weak_defense star_injured S5 weak_defense weak_attack star_injured For bounded treewidth C establish ﬁxedparameter tractability Solvability Relevance Necessity problem A PAP P represented τ structure τ cl var pos neg H M predi cates cl var pos neg represent clause set C unary predicates H M identify hypotheses man ifestations In order represent instance Relevance Necessity problem extend signature τ τ cid9 cl var pos neg H M Dist Dist unary relation distinguishing domain element ad dition τ predicates expressing PAP structure contains fact Disth express want test hypothesis h Relevance respectively necessity Then Theorem 310 Consider signature τ cid9 cl var pos neg H M Dist The problems Solvability Relevance Necessity propositional abduction expressed means MSO sentences signature τ cid9 course solvability predicate Dist Proof Recall Theorem 32 property X model clause set equivalently formula CNF C expressed MSOformula model X F predicates cl var pos neg We construct MSOsentences decision problems follows modelX C S X cid4 SolS S H X Solvability SSolS cid4 Relevance S SolS Dist S cid4 SolS Dist S Necessity S cid7 cid7 cid7 cid4cid5 Y modelY C S Y cid6 M Y cid7 The predicate SolS straightforward formulation property S solution PAP represented A S subset propositional variables H ii C S model X iii model Y C S model M cid2 Usually reﬁned version Relevance respectively Necessity problem considered Rather asking h contained respectively solution interested h contained respectively acceptable solution In context acceptable means minimal wrt preorder cid4 powerset 2H Consequently speaks cid4Relevance respectively cid4Necessity The treated basic abduction problems Relevance Necessity correspond special case cid4 equality The preorders studied following subsetminimality prioritization P ﬁxed number p priorities H partitioned priorities H 1 H p Then A P B A B exists k st A H B H k A Hk B Hk G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 115 minimum cardinality cid3 A cid3 B A cid3 B penalization cid21p referred weighted abduction To element h H weight wh attached Then cid8 cid8 A cid21p B h A wh cid3 hB wh To illustrate notions minimality abduction revisit football example 34 recalled S1 S2 minimal S1 cid3minimal Priorities represent qualitative version probability For instance suppose reason know speciﬁc team star_injured likely occur weak_defense weak_attack This judgment formalized assigning lower priority Then S2 minimal solution respect preorder P If numeric values available repair cost robustness component based data empirically collected mean time failure component age cid21p minimal solutions correspond cheapest repair respectively likely explanation In cases resulting cid4Relevance respectively cid4Necessity problem second level polynomial hierarchy 21 Again computational complexity decreases signiﬁcantly clausal theories C consideration bounded treewidth The cases turn bit tricky Below establish desired FPTresult ﬁrst ones Theorem 311 Consider signature τ cid9 cl var pos neg H M Dist For cid4 P cid4Relevance problem cid4Necessity problem expressed means MSO sentences signature τ cid9 Proof It suﬃces provide MSO encoding predicates AccS AccP S mean S acceptable solution preorders P respectively cid7 X S SolX cid4 AccS SolS X X P S X H1 S X H1 S X H2 S X H1 S X H2 S X H3 S cid7 cid4 X P S SolX AccP S SolS X By X P S mean X P S X cid19 S Note considering 3 priority levels H 1 H2 H3 The generalization arbitrary ﬁxed number p priority levels clear cid2 By Courcelles Theorem Theorems 310 311 immediately following FPTresult Theorem 312 Consider signature τ cid9 cl var pos neg H M Dist Let cid4 P let instance cid4Relevance cid9w A cid4Necessity problem given τ cid9 function f structure A width w Then problems solved time O f cid9 It remains consider cases cid4 cid3 cid21p Actually cid3 special case cid21p h H assigned weight Unfortunately MSO powerful express cardinalitycomparison cid3 cf discussion 3 Nevertheless cid4 cid3 cid21p possible establish FPTproperty case bounded treewidth extension Courcelles Theorem proved 316 To end recall deﬁnition extremum problems extension MSO deﬁnition 3 general deﬁnition purposes restricted form suﬃcient Deﬁnition 313 Let τ signature ϕ X1 Xm MSO formula signature τ free set variables X1 Xm Moreover let F Nm N linear function Then linear extended MSO extremum problem ϕ F deﬁned follows Instance A τ structure A functions g Question Find extremum min max cid10 cid9 cid10 cid11 F g A1 A 1 A m g Am A 1 g A m domA N tuples sets A1 Am domain A A cid14 ϕ A1 Am Theorem 314 See 3 Let linear extended MSO extremum problem given linear objective function F MSO formula ϕ X1 Xm signature τ Moreover let instance extremum problem given τ structure A treewidth A m domA N Assuming unit cost arithmetic operations extremum problem w functions g solved time O f ϕx F w A g A m function f A 1 g A 1 g This additional expressive power suﬃces expressing acceptability PAPsolutions wrt cid3 cid21p 116 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 Theorem 315 Consider signature τ cid9 cl var pos neg H M Dist Let cid4 cid3 cid21p let instance cid4Relevance cid4Necessity problem given τ cid9 structure A width w In case cid21p abduction problem instance additionally contains Assuming unit cost arithmetic operations problems solved time O f w A weight function g preorder cid3 respectively time O f w A g A preorder cid21p function f A Proof It suﬃces problems decided solving linear extended MSO extremum problems We consider case cid21p cid3 special case Let instance cid21p Relevance cid21p Necessity problem given τ cid9 structure A τ cid9 cl var pos neg H M Dist Moreover let SolS denote MSOformula proof Theorem 310 expressing S solution PAP represented A Clearly task computing minimal total weight solutions PAP corresponds linear extremum minimum problem deﬁned MSOformula SolS taking identity function A objective function F The instances extremum problem given τ cid9 weight function domain elements A structure A function g cid9 S deﬁned Sol cid9 S respec Now let Sol cid9cid9 S expresses property S solution containing h respectively containing h Then h relevant tively Sol following properties hold A cid14 SSol S minimal weight sets S fulﬁlling A cid14 SSolS Both minimumproblems expressed linear extended MSO extremum problems solvable desired time bound Likewise decision problem A cid14 SSol S minimal weight sets S fulﬁlling A cid14 SSol cid9cid9 S SolS Dist S Sol cid9 S SolS Dist cid19 S Sol S ﬁts time bound cid9cid9 S Sol Similarly h necessary following properties hold Either A cid19cid14 SSol cid9 conditions fulﬁlled A cid14 SSol strictly smaller minimal weight sets S A cid14 SSol contain h These decision problems minimumproblems solved desired time bound cid2 S minimal weight sets S A cid14 SSol S holds following S S solutions minimal weight actually S A cid14 SSol cid9cid9 cid9cid9 cid9cid9 cid9 cid9 cid9 cid9 4 New algorithms datalog In section monadic datalog approach 30 exploited order construct concrete eﬃcient algorithms problems ﬁxedparameter tractability established Section 3 We shall present new algorithms Solvability problem given PAP solution Relevance enumeration problem enumerate relevant hypotheses given PAP propositional abduction We believe approach applicable problems discussed Section 3 Indeed recently similar algorithms presented circumscription disjunctive logic programming 3637 It convenient consider PAP P given τ structure τ cl var pos neg hyp man Note contrast Section 34 denote unary predicates hypotheses manifestations hyp man H M This change notation help increase readability datalog programs conforming convention predicate names normally written lowercase letters As Section 3 start exposition SAT problem order illustrate basic ideas tackle harder problems area abduction Note eﬃcient algorithm exploiting bounded treewidth context SAT problem recently presented 24 The algorithm presented based recursive splitting In 24 authors outline method extended NPcomplete problems Pcomplete counting variants However goal tackle problems second level polynomial hierarchy like abduction 41 SAT problem Suppose clause set tree decomposition T width w given τtdstructure τtd cl var pos neg root leaf child1 child2 bag Of course need predicates hyp man SAT problem Without loss generality assume T normal form given Deﬁnition 22 Note domain elements variables clauses Consequently node t tree decomposition T called variable removal node clause removal node variable introduction node clause introduction node respectively depending kind element removed replaced comparing bag node t bag child node t Additionally Deﬁnition 22 node t branch node leaf node respectively child nodes In Fig 4 datalog program decides SAT problem Some words notation program order We lower case letters v c x possibly subscripts datalog variables single node T single clause single propositional variable respectively In contrast upper case letters datalog variables denoting sets variables case X P N sets clauses case C Note sets sets general sense cardinality restricted maximal size w 1 bags w ﬁxed constant Indeed implemented ﬁxedsize sets means ktuples k cid3 w 1 0 1 The SATprogram Fig 4 said quasimonadic variable head atoms bounded instantiations For instance atom solvev P N C sets P N C subsets bag v Hence combination P N C represented 3 subsets r1 r2 r3 0 w referring indices elements bag G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 117 Program SAT leaf node solvev P N C1 leaf v bagv X C P N X P N trueP N C1 C variable removal node solvev P N C1 bagv X C child1v 1 v bagv 1 X cid22 x C solvev 1 P cid22 x N C1 solvev P N C1 bagv X C child1v 1 v bagv 1 X cid22 x C solvev 1 P N cid22 x C1 clause removal node solvev P N C1 bagv X C child1v 1 v bagv 1 X C cid22 c solvev 1 P N C1 cid22 c variable introduction node solvev P cid22 x N C1 C2 bagv X cid22 x C child1v 1 v bagv 1 X C solvev 1 P N C1 truex C2 C solvev P N cid22 x C1 C2 bagv X cid22 x C child1v 1 v bagv 1 X C solvev 1 P N C1 true x C2 C clause introduction node solvev P N C1 C2 bagv X C cid22 c child1v 1 v bagv 1 X C solvev 1 P N C1 trueP N C2 c branch node solvev P N C1 C2 bagv X C child1v 1 v bagv 1 X C solvev 1 P N C1 child2v 2 v bagv 2 X C solvev 2 P N C2 result root node success rootv bagv X C solvev P N C Fig 4 SAT test v Since w considered ﬁxed constant solvev P N C simply succinct representation constantly monadic predicates form solvecid5r1r2r3cid6v For sake readability nondatalog expressions involving set operators cid22 disjoint union Of course easily replaced proper datalog expressions For instance P N X replaced union P N X In order facilitate discussion introduce following notation Let C denote input clause set variables V tree decomposition T For node v T write Tv denote subtree T rooted v By Clv denote set clauses bag v ClTv denotes set clauses occur bag Tv Analogously write Varv VarTv shorthand set variables occurring bag v respectively bag Tv Finally restriction clause c variables set U V denoted cU The SATprogram contains intensional predicates solve true success The crucial predicate solvev P N C following intended meaning v denotes node T P N form partition Varv representing truth value assignment Varv st variables P value true variables N value false C denotes subset Clv For values v P N C ground fact solvev P N C shall true minimal model interpreted program following condition holds Property A There exists extension J assignment P N VarTv st ClTv Clv C true J clauses c Clv C restriction cVarTv false J The main task program computation facts solvev P N C means bottomup traversal tree decomposition The predicates following meaning trueP N C1 C means C1 contains precisely clauses C true partial assignment given P N We specify implementation predicate It easily achieved extensional predicates pos neg The 0ary predicate success indicates input structure encoding satisﬁable clause set The SATprogram following properties Lemma 41 The solvepredicate intended meaning described values v P N C ground fact solvev P N C true minimal model interpreted SATprogram Property A holds Proof idea The lemma shown structural induction T The induction step goes case distinction possible types nodes The proof lengthy straightforward The details worked Appendix A cid2 118 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 Table 1 SAT example Node 7 13 19 6 5 4 3 1 2 0 solve facts solve7 x3 c1 solve7 x3 solve13 x5 c2 solve13 x5 c2 solve19 x6 c3 solve19 x3 solve6 x1 x3 c1 solve6 x1 x3 solve6 x1 x3 c1 solve6 x3 x1 c1 solve5 x1 c1 solve5 x1 solve5 x1 c1 solve4 x1 x2 c1 solve4 x1 x2 c1 solve4 x2 x1 solve4 x1 x2 c1 solve4 x2 x1 c1 solve3 x1 x2 solve3 x1 x2 solve3 x2 x1 solve3 x1 x2 solve1 x1 x2 x4 solve1 x1 x2 x4 solve1 x1 x4 x2 solve1 x1 x2 x4 solve1 x2 x4 x1 solve1 x2 x1 x4 solve1 x4 x1 x2 solve1 x1 x2 x4 solve2 x1 x2 x4 solve2 x1 x2 x4 solve2 x1 x4 x2 solve2 x1 x2 x4 solve2 x2 x4 x1 solve2 x2 x1 x4 solve2 x4 x1 x2 solve2 x1 x2 x4 solve0 x1 x2 x4 solve0 x1 x2 x4 solve0 x1 x4 x2 solve0 x1 x2 x4 solve0 x2 x4 x1 solve0 x2 x1 x4 solve0 x4 x1 x2 solve0 x1 x2 x4 Theorem 42 The datalog program Fig 4 decides SAT problem fact success true minimal model interpreted SATprogram input structure Atd encodes satisﬁable clause set C tree decomposition T C Moreover clause set C tree decomposition T width w program evaluated time O2w C Proof By Lemma 41 solvepredicate meaning according Property A Thus rule head success reads follows success true minimal model v denotes root T exists assignment P N variables Varv st extension J P N VarTv clauses ClTv ClTv Clv C true J But simply means J satisfying assignment C ClTv For upper bound time complexity observe facts solvev P N C derived program sets P N C disjoint subsets bag v contains w 1 elements Suppose bag node v consists k variables l clauses k l cid3 w 1 Then 2k 2l 2w1 possible instantiations arguments Hence datalog program P Fig 4 equivalent ground program P cid9 rule P replaced O2w C ground rules computed time O2w C In total evaluate program P Fig 4 input formula C CNF tree decomposition T given τtdstructure Atd size linear wrt size C follows ﬁrst compute equivalent ground program P cid9 O2w C rules evaluate P cid9 size Atd time O2w C Atd O2w C cid2 linear time 1842 wrt size P cid9 Example 43 Let F x1 x2 x3 x1 x4 x5 x2 x4 x6 propositional formula Example 21 consider normalized tree decomposition T Fig 2 We shall run SATprogram structure representing F T We process tree nodes bottomup manner The solvefacts derived tree node presented Table 1 We start leaf nodes 7 13 19 At node 7 variable x3 assigned value true false If x3 assigned value true P x3 N clause c1 true Hence obtain fact solve7 x3 c1 If x3 assigned value false P N x3 clause c1 restricted variable x3 evaluates false Thus obtain second fact solve7 x3 By analogous arguments obtain solvefacts leaf nodes 13 19 Node 6 variable introduction node introduces variable x1 present node 7 Again x1 set true false For assignments test c1 evaluates true Therefore node 6 obtain solvefacts possible truth assignments x1 x3 Node 5 variable removal node removes variable x3 present node 6 We remember effect truth assignment removed variable case x3 maintaining different sets clauses solve facts Thus node 5 exist facts truth assignment P N x1 C c1 C second solvefact Table 1 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 119 Program Solvability leaf node solvev S 0 P N C1 d leaf v bagv X C svarv S S P P N X P N checkP N C1 C d variable removal node auxv S 0 P N C1 d bagv X C child1v 1 v bagv 1 X cid22 x C solvev 1 S P cid22 x N C1 d x S auxv S 0 P N C1 d bagv X C child1v 1 v bagv 1 X cid22 x C solvev 1 S P N cid22 x C1 d auxv S 1 P N C1 d bagv X C child1v 1 v bagv 1 X cid22 x C solvev 1 S cid22 x P cid22 x N C1 d clause removal node solvev S P N C1 d bagv X C child1v 1 v bagv 1 X C cid22 c solvev 1 S P N C1 cid22 c d variable introduction node solvev S P cid22 x N C1 C2 d1 bagv X cid22 x C child1v 1 v bagv 1 X C solvev 1 S P N C1 d1 checkx C2 C d2 solvev S P N cid22 x C1 C2 d1 d2 bagv X cid22 x C child1v 1 v bagv 1 X C solvev 1 S P N C1 d1 check x C2 C d2 solvev S cid22 x P cid22 x N C1 C2 d1 bagv X cid22 x C child1v 1 v bagv 1 X C solvev 1 S P N C1 d1 checkx C2 C d2 hypx clause introduction node solvev S P N C1 C2 d1 bagv X C cid22 c child1v 1 v bagv 1 X C solvev 1 S P N C1 d1 checkP N C2 c d2 branch node auxv S i1 i2 P N C1 C2 d1 d2 bagv X C child1v 1 v bagv 1 X C child2v 2 v bagv 2 X C solvev 1 S i1 P N C1 d1 solvev 2 S i2 P N C2 d2 variable removal branch node aux solve solvev S P N C d auxv S i1 i2 P N C d reducev S i1 i2 result root node success rootv bagv X C solvev S P N C n solve cid9 v S cid9 solve v S bagv X C solvev S P N C y Fig 5 Solvability test The variable introduction node 4 follows principles node 6 Note number solvefacts doubled introduction variable x2 Indeed facts solve5 x1 solve5 x1 c1 rise fact solve4 x2 x1 c1 Hence 5 solvefacts node 4 Node 3 clause removal node clause c1 removed comparing bag node 3 node 4 Only truth assignments solvefacts node 4 survive clause c1 evaluates true Actually example fact solve4 x2 x1 violates condition However exists fact solve4 x2 x1 c1 node 4 The gives rise fact solve3 x2 x1 The traversal node 3 1 introduces new variable x4 trivial exist clause node 1 Thus truth assignments solvefact node 1 The traversal node 13 8 19 14 identical node 7 1 Hence illustrate solvefacts explicitly Finally root node 0 check truth assignment variables makes clauses root true This trivial example In fact obtain possible truth assignments variables x1 x2 x4 solutions extended models F choosing appropriate truth values x3 x5 x6 42 Solvability problem The SATprogram previous section extended Solvability program following idea Recall S H solution PAP P cid5V H M Ccid6 C S consistent C S cid14 M holds We think abduction problem combination SAT UNSAT problems C S satisﬁable formulae C S m m M unsatisﬁable Suppose construct set S bottomup traversal T Initially S In case C S C clearly satisﬁable abduction problem makes sense C S m satisﬁable M abduction problem trivial In words C S models models m M false The effect adding hypothesis h S restrict possible number models C S C S m sense eliminate models h 120 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 false Hence goal Solvability algorithm ﬁnd bottomup traversal tree decomposition T set S small model C S left models C S m m M eliminated The program Fig 5 realizes SATUNSATintuition For discussion program convenient introduce following additional notation We shall write Hv Mv HTv MTv denote restriction H M variables bag v bag Tv respectively Of course unary predicates hyp man contained τtd The predicate solvev S P N C d following intended meaning At node v consider choices S Hv P N denotes assignment variables Varv C Clv denotes clause set st ClTv Clv C true extension J P N VarTv But additionally consider chosen hypotheses HTv manifestations MTv decide J candidate SAT andor UNSAT problem As far H concerned careful S Hv extended S HTv For different extension S different assignments J VarTv excluded SATUNSAT problems track assignments J hypotheses S true Hence need counter 0 1 2 solvepredicate order distinguish different extensions S Hv S HTv As far M concerned argument d possible values y n indicating manifestation m MTv false J For UNSAT problem account assignments J m M false Then program following meaning For values v S extension S S S HTv Hv S deﬁne Property B Property B For values P N C u fact solvev S P N C u true minimal model interpreted program exists extension J assignment P N VarTv st ClTv Clv S C true J clauses c Clv C restriction cVarTv false J Moreover u y m MTv false J The predicate svar Fig 5 select sets hypotheses svarv S true subset S Hv The predicate check extends predicate true SATprogram additionally setting dbit checkP N C1 C d trueP N C1 C Moreover d y N contains manifestation Finally predicates aux reduce following purpose As mentioned solvev S P N C d different extensions S HTv S apart Without measures loose ﬁxedparameter tractability variable elimination nodes branch nodes lead exponen tial increase wrt number hypotheses HTv number extensions S The predicates aux reduce remedy problem follows In ﬁrst place compute facts auxv S i1 i2 P N C d different exten sions S S identiﬁed pairs indices i1 i2 Now let v S ﬁxed consider pair i1 i2 set F i1 i2 P N C d auxv S i1 i2 P N C d true minimal model The predicate reducev S i1 i2 maps pairs indices i1 i2 unique index However exists lexicographically smaller pair j1 j2 F i1 i2 F j1 j2 i1 i2 skipped In words extensions S index i1 i2 j1 j2 j1 j2 P N C d exactly distinguishable v rise facts auxv S i1 i2 P N C d auxv S sets values P N C d clearly suﬃcient track exactly representative The predicate reduce easily implemented datalog negation Appendix B However prefer consider builtin predicate implemented eﬃciently appropriate hash codes index Analogously Lemma 41 Theorem 42 Solvability program following properties Lemma 44 The solvepredicate intended meaning described values v S extension S S S HTv Hv S Property B holds Proof sketch The lemma shown structural induction T We restrict outlining ideas underlying rules Solvability program The induction obvious omitted 1 Leaf nodes The rule leaf node v realizes guesses speak subset S hypotheses Hv ii truth assignment P N variables Varv The values S P N fulﬁll conditions S P P N X P N The remaining variables rule fully determined In particular atom checkP N C1 C d compute set clauses C1 C true assignment P N dbit set depending manifestation set false assignment 2 Variable removal node The rules distinguish total 3 cases arise variable x removed bag child node v 1 v x set true false x solution Of course x solution truth value true The rules variable removal node treat cases order true solution false solution true solution The removal x effect solvefacts true minimal model values v S v S j identical different v 1 S v 2 S Hence rule variable removal nodes ﬁrst generates auxfacts The corresponding solvefacts generated duplicate elimination reducepredicate G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 121 Recall index solvefacts solvev S different extensions S HTv S apart Analogously auxfacts auxv S i1 i2 pair i1 i2 job Therefore auxfacts ﬁrst cases x S case x S different pairs indices 0 1 respectively 3 Clause removal node The rule clause removal node v checks clause c removed v evaluates true extension J P N This check carried connectedness condition removal c sure cVarTv identical c Hence c evaluates false extension J P N VarTv way turn truth value c true appropriate assignment variables tree decomposition 4 Variable introduction node Analogously variable removal node rules distinguish total 3 cases arise variable x introduced node v x set true false x solution Of course x solution truth value true The rules variable introduction node treat cases order true solution false solution true solution The rule additional atom hypx body sure x hypothesis added solution In cases checkpredicate rule body checks additional clauses C2 evaluate true chosen truth value x ii manifestation set false Of course check ii relevant x set false 5 Clause introduction node When new clause c introduced check c evaluates true assignment P N This atom checkP N C2 c d2 rule body The variable C2 values c Clearly connectedness condition variables occurring c occur VarTv Varv Hence plays role extension J P N VarTv considered 6 Branch node The rule branch node v combines solvefacts child nodes v 1 v 2 provided identical values S P N By connectedness condition sure variables clauses occurring Tv1 Tv2 occur bags v 1 v 2 v Hence extensions S1 S2 respectively J 1 J 2 consistent S1 Hv S S2 Hv holds respectively J 1 J 2 restricted Varv coincide P N Note happen combining solvefacts values v 1 S i1 v 2 S i2 yields values P N C d combine solvefacts values v 1 S j1 v 2 S j2 Hence rule branch nodes ﬁrst generates auxfacts The corresponding solvefacts generated duplicate elimination reduce predicate cid2 Theorem 45 The datalog program Fig 5 decides Solvability problem PAPs fact success true minimal model interpreted program Atd encodes solvable PAP P cid5V H M Ccid6 tree decomposition T clause set C Moreover PAP P cid5V H M Ccid6 tree decomposition T width w program evaluated time O253w2 P Proof sketch By Lemma 44 solvepredicate meaning according Property B Thus rule head success reads follows The PAP P solution S exists set S Hv S S Hv exists extension S S HTv S S extension identiﬁed index st following conditions hold 1 ClTv S model exists assignment P N Varv extended J VarTv st ClTv S true J 2 ClTv S model m M false exists assignment P N Varv extended J VarTv st ClTv S true J m M false J As proof Theorem 42 upper bound time complexity obtained upper bound possible ground instantiations rule Solvability program First consider solvev S P N C dpredicates Suppose bag node v consists k variables l clauses k l cid3 w 1 Then following upper bound possible value combinations For S P N 3k possibilities variable occur N set false S P set true added solution S P S set true added solution S For C upper bound 2l d 2 possible values In total number combinations S P N C d bounded 3k 2l 2 cid3 3k 3l 3 3w2 For possible values recall j distinct indices set facts solvev S set facts considerations pair solvev S j different Hence value v S 23w2 possible values In total upper bound O3w2 23w2 P possible ground instantiations solvev S P N C d predicate For remaining predicates program Fig 5 particular auxpredicate remaining auxiliary predicates like reducepredicate detailed Appendix B worst situation happen predicate contains indices j Hence program Fig 5 equivalent ground program O3w2 23w2 23w2 P O253w2 P rules The Solvability program evaluated ﬁrst computing equivalent ground program 122 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 Table 2 Solvability Example 1 Node 7 6 5 4 3 1 solve facts solve7 0 x3 c1 n solve7 0 x3 n solve6 0 x1 x3 c1 n solve6 0 x1 x3 c1 n solve6 0 x3 x1 c1 n solve6 0 x1 x3 n solve6 0 x1 x1 x3 c1 n solve6 0 x1 x1 x3 c1 n solve5 0 x1 c1 n solve5 0 x1 c1 n solve5 0 x1 n solve5 0 x1 x1 c1 n solve4 0 x1 x2 c1 n solve4 0 x1 x2 c1 n solve4 0 x2 x1 x2 c1 n solve4 0 x2 x1 c1 n solve4 0 x1 x2 c1 n solve4 0 x2 x2 x1 c1 n solve4 0 x2 x1 n solve4 0 x2 x2 x1 n solve4 0 x1 x1 x2 c1 n solve4 0 x1 x1 x2 c1 n solve4 0 x1 x2 x1 x2 c1 n solve3 0 x1 x2 n solve3 0 x1 x2 n solve3 0 x2 x1 x2 n solve3 0 x2 x1 n solve3 0 x1 x2 n solve3 0 x2 x2 x1 n solve3 0 x1 x1 x2 n solve3 0 x1 x1 x2 n solve3 0 x1 x2 x1 x2 n solve1 0 x1 x2 x4 n solve1 0 x1 x2 x4 n solve1 0 x1 x4 x2 n solve1 0 x1 x2 x4 n solve1 0 x2 x1 x2 x4 n solve1 0 x2 x1 x2 x4 n solve1 0 x2 x4 x1 n solve1 0 x2 x1 x4 n solve1 0 x4 x1 x2 n solve1 0 x1 x2 x4 n solve1 0 x2 x2 x4 x1 n solve1 0 x2 x2 x1 x4 n solve1 0 x1 x1 x2 x4 n solve1 0 x1 x1 x2 x4 n solve1 0 x1 x1 x4 x2 n solve1 0 x1 x1 x2 x4 n solve1 0 x1 x2 x1 x2 x4 n solve1 0 x1 x2 x1 x2 x4 n evaluating linear time 1842 wrt size ground program size Atd Analogously proof Theorem 42 feasible time bound O253w2 P cid2 Example 46 Consider PAP P cid5V H M Ccid6 C clause set corresponding CNFformula F Example 21 C x1 x2 x3 x1 x4 x5 x2 x4 x6 Additionally assume H x1 x2 M x5 x6 Finally V x1 x2 x3 x4 x5 x6 The tree decomposition T Fig 2 tree decomposition structure representing PAP We shall run Solvability program PAP Again process tree nodes T bottomup manner Table 2 shows solvefacts derived nodes 1 3 4 5 6 7 In principle processing similar SATprogram maintain additional parameters S d Below highlight differences compared run SATprogram discussed Example 43 The number solvefacts variable introduction node 6 times number solvefacts node 7 The reason 3 possibilities proceed new variable x1 assume hypothesis We set x1 false added N set true adding S added P set true add S added P S Node 4 variable introduction node new variable 4 Note 11 12 solvefacts node 4 The reason facts solve5 0 x1 c1 n solve5 0 x1 n rise fact solve4 0 x1 x2 c1 n When traversing node 4 node 3 number solvefacts decreases 11 9 solvefacts node 4 parameter C value particular C contain clause c1 node 3 clause removal node removal clause c1 Finally traversing node 3 node 1 number solvefacts multiplied 2 3 node 6 x4 hypothesis Hence possibilities proceed x4 We add P N At tree node 1 end 18 solvefacts The traversal node 13 9 illustrated Table 3 This time manifestation variable x5 taken care value parameter d We leave illustration traversal node 19 15 follows exactly pattern node 13 9 We present solvefacts node 15 similar node 9 We brieﬂy discuss derivation solvefacts nodes At node 13 dvalue indicates manifestation x5 set false d y d n The transition node 13 12 analogous transition node 7 6 Table 2 At variable removal node 11 number solvefacts decreased compared node 12 dvalue account At variable introduction node 10 double number solvefacts new variable x4 hypothesis When traversing node G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 123 Table 3 Solvability Example 2 Node 13 12 11 10 9 15 solve facts solve13 0 x5 c2 y solve13 0 x5 n solve12 0 x1 x5 c2 y solve12 0 x1 x5 c2 y solve12 0 x1 x1 x5 c2 y solve12 0 x1 x5 n solve12 0 x5 x1 c2 n solve12 0 x1 x1 x5 n solve11 0 x1 c2 y solve11 0 x1 c2 y solve11 0 x1 x1 c2 y solve11 0 x1 n solve11 0 x1 c2 n solve11 0 x1 x1 n solve10 0 x1 x4 c2 y solve10 0 x1 x4 c2 y solve10 0 x4 x1 c2 y solve10 0 x1 x4 c2 y solve10 0 x1 x1 x4 c2 y solve10 0 x1 x1 x4 c2 y solve10 0 x1 x4 c2 n solve10 0 x1 x4 n solve10 0 x4 x1 c2 n solve10 0 x1 x4 c2 n solve10 0 x1 x1 x4 c2 n solve10 0 x1 x1 x4 n solve9 0 x1 x4 y solve9 0 x1 x4 y solve9 0 x4 x1 y solve9 0 x1 x4 y solve9 0 x1 x1 x4 y solve9 0 x1 x1 x4 y solve9 0 x1 x4 n solve9 0 x4 x1 n solve9 0 x1 x4 n solve9 0 x1 x1 x4 n solve15 0 x2 x4 n solve15 0 x2 x4 n solve15 0 x4 x2 n solve15 0 x2 x4 n solve15 0 x2 x2 x4 n solve15 0 x2 x2 x4 n solve15 0 x2 x4 y solve15 0 x2 x4 y solve15 0 x2 x4 y solve15 0 x2 x2 x4 y solve15 0 x2 x2 x4 y 10 node 9 number solvefacts reduced 2 solvefacts node 10 parameter value C Node 15 similar node 9 role x6 x2 c3 path 19 15 essentially corresponds role x5 x1 c2 path 13 9 The signiﬁcant difference paths x1 x5 occur c2 negatively x2 x6 occur c3 positively By different sign x5 x6 dvalues y n swapped compare solvefacts node 9 solvefacts node 15 The different sign x1 x2 effect solvefacts node 15 node 9 The reason node 15 fact solve15 0 x4 x2 y missing x4 x6 set true x2 false c3 evaluates false On hand node 9 facts solve9 0 x1 x4 n solve9 0 x1 x1 x4 n missing x1 set true x4 x5 set false c2 evaluates false hypothesis x1 true added S The solvefacts node 8 14 presented Table 4 We obtain facts solve facts node 9 respec tively 19 allowing x2 respectively x1 possible cases new variable added P N N P S We explicitly present facts root node However easily veriﬁed predicate true value S Note 0 successfact derived solve solvefacts root hypotheses appear bag node 0 Hence value S node 0 exists predicate true exactly 1 extension hypotheses bags node 0 S Intuitively solve value S 0 S x1 x2 x1 x2 truth assignment x1 x2 x4 extended remaining variables setting x3 x6 true x5 false st clauses C true manifestation x5 false cid9 cid9 Formally property seen follows Note 18 facts node 8 dvalue y These 18 facts correspond possible values parameters S P N variables x1 x2 x4 The dvalue indicates considered extensions truth assignments manifestation x5 assigned truth value false At node 2 datalog rule branch nodes 18 facts possible assignments x1 x2 x4 dvalue y This set value combinations present solvefacts root node 0 But value S solve predicate true Thus successfact derived program conclude PAP P solution cid9 43 Relevance enumeration problem The problem computing relevant hypotheses clearly expressed unary MSOquery monadic datalog program Indeed straightforward extend Solvability program program Relevance 124 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 Table 4 Solvability Example 3 Node 8 14 solve facts solve8 0 x1 x2 x4 y solve8 0 x1 x4 x2 y solve8 0 x2 x1 x2 x4 y solve8 0 x1 x2 x4 y solve8 0 x1 x2 x4 y solve8 0 x2 x1 x2 x4 y solve8 0 x2 x4 x1 y solve8 0 x4 x1 x2 y solve8 0 x2 x2 x4 x1 y solve8 0 x2 x1 x4 y solve8 0 x1 x2 x4 y solve8 0 x2 x2 x1 x4 y solve8 0 x1 x1 x2 x4 y solve8 0 x1 x1 x4 x2 y solve8 0 x1 x2 x1 x2 x4 y solve8 0 x1 x1 x2 x4 y solve8 0 x1 x1 x2 x4 y solve8 0 x1 x2 x1 x2 x4 y solve8 0 x1 x2 x4 n solve8 0 x1 x4 x2 n solve8 0 x2 x1 x2 x4 n solve8 0 x2 x4 x1 n solve8 0 x4 x1 x2 n solve8 0 x2 x2 x4 x1 n solve8 0 x2 x1 x4 n solve8 0 x1 x2 x4 n solve8 0 x2 x2 x1 x4 n solve8 0 x1 x1 x2 x4 n solve8 0 x1 x1 x4 x2 n solve8 0 x1 x2 x1 x2 x4 n solve14 0 x1 x2 x4 n solve14 0 x2 x4 x1 n solve14 0 x1 x1 x2 x4 n solve14 0 x1 x2 x4 n solve14 0 x2 x1 x4 n solve14 0 x1 x1 x2 x4 n solve14 0 x1 x4 x2 n solve14 0 x4 x1 x2 n solve14 0 x1 x1 x4 x2 n solve14 0 x1 x2 x4 n solve14 0 x1 x2 x4 n solve14 0 x1 x1 x2 x4 n solve14 0 x2 x1 x2 x4 n solve14 0 x2 x2 x4 x1 n solve14 0 x1 x2 x1 x2 x4 n solve14 0 x2 x1 x2 x4 n solve14 0 x2 x2 x1 x4 n solve14 0 x1 x2 x1 x2 x4 n solve14 0 x1 x2 x4 y solve14 0 x2 x4 x1 y solve14 0 x1 x1 x2 x4 y solve14 0 x1 x2 x4 y solve14 0 x2 x1 x4 y solve14 0 x1 x1 x2 x4 y solve14 0 x1 x2 x4 y solve14 0 x1 x2 x4 y solve14 0 x1 x1 x2 x4 y solve14 0 x2 x1 x2 x4 y solve14 0 x2 x2 x1 x4 y solve14 0 x1 x2 x1 x2 x4 y solve14 0 x2 x1 x2 x4 y solve14 0 x2 x2 x4 x1 y solve14 0 x1 x2 x1 x2 x4 y enumeration problem Suppose hypothesis h occurs bag root r T Then h relevant exists subset S Hr index st h S S extended solution S HTr PAP P Naively compute relevant hypotheses considering tree decomposition T rooted nodes st h H contained bag root node Obviously method quadratic time complexity wrt data size However better computing solvefacts node v T simultaneously bottomup traversal T topdown traversal T means new predicate solve The tree decomposition course modiﬁed way hypothesis h H occurs leaf node T Moreover branch node v tree decomposition insert new node u new parent v st u v identical bags Hence child nodes v branch node surrounded neighboring nodes identical bags It guaranteed branch node child nodes identical bags matter T rooted Then relevant hypotheses obtained solve v facts true minimal model interpreted program leaf nodes v T facts correspond precisely solvev facts T rooted v The details additional datalog rules required compared Solvability test given Fig 6 Of course need new predicate aux plays analogous role deﬁnition solve predicate auxpredicate Fig 5 deﬁnition solve Further analogies deﬁnition solve solveconcern node types For topdown traversal root node plays role leaf node played The child node variable respectively clause introduction node plays topdown traversal role variable respectively clause removal node bottomup traversal bag node variable respectively clause bag previously visited node Likewise child node variable respectively clause removal node plays topdown traversal role variable respectively clause introduction node The tricky case branch node Note program Fig 6 derive solve facts branch nodes For deriving solve Dfacts child nodes branch node distinguish cases If topdown traversal continues ﬁrst child v branch node b parent b plays role v 1 second child b plays role v 2 Care taken solve predicate node v deﬁned terms solve predicate parent b terms solve predicate second child b Analogously solve predicate v deﬁned v second child branch node G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 125 Program Relevance root node solve v S 0 P N C1 d rootv bagv X C svarv S S P P N X P N checkP N C1 C d child variable introduction node aux v S 0 P N C1 d bagv X C child1v v 1 bagv 1 X cid22 x C solve v 1 S P cid22 x N C1 d x S aux v S 0 P N C1 d bagv X C child1v 1 v bagv 1 X cid22 x C solve v 1 S P N cid22 x C1 d aux v S 1 P N C1 d bagv X C child1v 1 v bagv 1 X cid22 x C solve v 1 S cid22 x P cid22 x N C1 d child clause introduction node solve v S P N C1 d bagv X C child1v v 1 bagv 1 X C cid22 c solve v 1 S P N C1 cid22 c d child variable removal node solve v S P cid22 x N C1 C2 d1 bagv X cid22 x C child1v v 1 bagv 1 X C solve v 1 S P N C1 d1 checkx C2 C d2 solve v S P N cid22 x C1 C2 d1 d2 bagv X cid22 x C child1v v 1 bagv 1 X C solve v 1 S P N C1 d1 check x C2 C d2 solve v S cid22 x P cid22 x N C1 C2 d1 bagv X cid22 x C child1v v 1 bagv 1 X C solve v 1 S P N C1 d1 checkx C2 C d2 hypx child clause removal node solve v S P N C1 C2 d1 bagv X C cid22 c child1v v 1 bagv 1 X C solve v 1 S P N C1 d1 checkP N C2 c d2 ﬁrst child branch node aux v S i1 i2 P N C1 C2 d1 d2 bagv X C child1v b child1b v 1 bagv 1 X C child2v 2 b bagv 2 X C solve v 1 S i1 P N C1 d1 solvev 2 S i2 P N C2 d2 second child branch node aux v S i1 i2 P N C1 C2 d1 d2 bagv X C child2v b child1b v 1 bagv 1 X C child1b v 2 bagv 2 X C solve v 1 S i1 P N C1 d1 solvev 2 S i2 P N C2 d2 child nodes variable introduction branch nodes aux solve solve v S P N C d aux v S i1 i2 P N C d reduce v S i1 i2 result leaf nodes relevanth leaf v bagv X C solve v S P N C n cid9 v S h S solve cid9 v S bagv X C solve v S P N C y solve Fig 6 Relevance enumeration program The resulting algorithm works linear time essentially doubles computational effort Solvability program In total following result Theorem 47 The datalog program Fig 6 solves Relevance enumeration problem PAPs Suppose program applied τtdstructure Atd encoding PAP P cid5V H M Ccid6 tree decomposition T clause set C Then h H fact relevanth true minimal model program input τtdstructure Atd hypothesis h relevant PAP P Moreover PAP P cid5V H M Ccid6 tree decomposition T width w program evaluated time O253w2 P Note programs presented Section 4 consider tree decomposition input It mentioned Section 21 theory given value w cid2 1 decided linear time wrt size input structure structure treewidth w Moreover case positive answer tree decomposition width w computed linear time 8 We mentioned Section 21 practical usefulness linearity limited excessively big constants 39 At rate improvement tree decomposition algorithms area active research considerable progress recently developing heuristicbased tree decomposition algorithms 3994910 126 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 Table 5 Processing time ms SAT problem tw 3 3 3 3 3 3 V 5 31 347 3955 32 765 337 859 Cl 9 48 522 5934 49 149 506 790 Table 6 Processing time ms Solvability problem tw 3 3 3 3 3 3 3 3 3 3 3 H 1 2 3 4 7 11 15 19 23 27 31 M 1 2 3 4 7 11 15 19 23 27 31 V 3 6 9 12 21 33 45 57 69 81 93 5 Implementation experimental results 51 Datalog approach tn 24 195 2157 23 793 207 438 2 120 361 Cl 1 2 3 4 7 11 15 19 23 27 31 MD ms MiniSat ms 004 02 08 81 655 6439 10 10 10 10 40 430 tn 3 12 21 34 69 105 141 193 229 265 301 MD 03 05 06 09 15 23 29 39 47 53 61 MONA 870 1710 12 160 To test performance particular scalability new algorithms implemented SAT Solvability programs C The SAT experiments conducted PC IntelR PentiumR D 300 GHz CPU 1 GB main memory 2 GB virtual memory running Linux Ubuntu kernel 262214generic The experiments Solvability program conducted Linux kernel 2617 160 GHz Intel PentiumM processor 512 MB memory We measured processing time different input parameters number variables clauses hypotheses manifestations The treewidth test cases 3 Due lack available test data generated balanced normalized tree decomposition test data sets increasing input parameters expanding tree breadthﬁrst style We ensured different kinds nodes occur evenly tree decomposition We compared performance program opensource SAT solver MiniSat httpminisatse The outcome tests SAT problem shown Table 5 In table V Cl tn represent number variables number clauses number tree nodes respectively Note time measurement MiniSat restricted unit seconds time consumption 10 ms obtained The results low treewidth underlying formulae performance method comparable uptodate SAT solver SAT solver faster factor approximately 15 cases Of course comparison account current SAT solvers evolved intensive research numerous competitions 20 years prototype implementation Moreover recently observed SAT solvers actually advantage low treewidth speciﬁcally tuned instances 4 The potential datalogbased approach seen competitor uptodate SAT solvers method applicable problems far SAT In particular method restricted NPproblems This illustrated application abduction paper circumscription disjunctive logic programming 3637 Without restriction bounded treewidth problems lie second level polynomial hierarchy The outcome tests Solvability problem shown Table 6 tw stands treewidth H M V Cl tn stand number hypotheses manifestations variables clauses tree nodes respectively The processing time ms obtained implementation monadic datalog approach displayed column labeled MD The measurements nicely reﬂect essentially linear increase processing time size input Moreover obviously hidden constant render linearity useless We wanted compare implementation standard MSOtoFTA approach 325 For purpose carried experiments prototype implementation MONA 38 MSO model checking The time measurements experiments shown column Table 6 Due problems discussed Section 52 MONA ensure linear data complexity Hence tests line 3 table failed outofmemory errors G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 127 General Generic MSOtoFTA approach Input MSOformula ϕ treewidth w structure A Output twA cid2 w output Yes No output twA w Transformation MSOformula ϕ I ϕ w compute MSOformula ϕ Computation colored binary tree T II compute tree decomposition T A width w twA w HALT result twA w III A T compute colored binary tree T MSOmodel checking IV check ϕ evaluates true T compute FTA equivalent ϕ b check FTA accepts tree T Fig 7 Generic MSOtoFTA approach Fig 8 System architecture MSOtoFTA approach Moreover cases exponential data complexity hurt datalog approach outperforms MSOtoFTA approach factor 100 52 MSOtoFTA approach Recipes devise concrete algorithms based Courcelles Theorem literature 3121125 The principal steps approaches described Fig 7 The problem evaluating MSOformula ϕ ﬁnite structure A treewidth w transformed equivalent problem evaluating MSOformula ϕ depends original formula ϕ ﬁxed treewidth w computed step I The computation colored binary tree T proceeds steps First tree decomposition T input structure A width w computed step II Then colored binary tree T tree structure T The ﬁnal step actual modelchecking step IV The problem evaluating MSOformula tree T reduced equivalent tree language recognition problem To end formula ϕ transformed equivalent FTA step IVa Then checked T corresponding A T computed step III In particular T To end formula ϕ colored binary trees T accepted FTA step IVb We implemented Solvability problem propositional abduction based MSOformula ϕ proof Theorem 310 This MSOformula transformed ϕ ad hoc manner depending chosen treewidth w Rather computing explicitly tree decomposition T simply considered tree decomposition additional input Our transformation T T essentially implements algorithm 25 apart simpliﬁcations possible fact predicates sets constants input database For step decided advantage existing MSO model checking tool MONA 38 To best knowledge MONA existing tool Experimental results prototype implementation instances Solvability problem reported column Table 6 The observed runtime sharp contrast linear time behavior according theoretical results shown Section 3 An analysis components prototype revealed way MONA evaluates MSOformula ϕ representation tree T single formula validity checked The correct way handling model checking problem according 25 depicted Fig 8 The steps I II III clear However crucial divide step IV substeps step IVa computes ﬁnite tree automaton MSOformula ϕ step IVb runs FTA tree T The important point notice steps I IVa depicted lefthand Fig 8 carried steps II III IVb shown righthand repeated single input structure Ai problematical combines MSOformula ϕ tree T 128 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 In contrast MONA considers ground atoms encoding T formula compiles resulting MSOformula consisting ϕ FTA In words size FTA grows exponen tially size T Consequently hand runtime needed MONA exponential On hand state explosion FTA led outofmemory error MONA small problem sizes In experiments described Table 6 negative effect happened problem instances 12 variables 4 clauses encoding T In fact algorithm transforming MSO formulae ground atoms ﬁnite structure ﬁnite tree automata Surprisingly transformation failed outofmemory error This counterintuitive formula clearly smaller formula ground atoms structure According test results worked instances small sizes The reason small set ground atoms optimization module MONA managed remove useless states transformation However MONA MSOformula optimization approach effect We attempt following MSOtoFTA approach implementing step IVa Fig 8 Alas attempt led failure able feed input data program The principal problem MSOtoFTA approach state explosion resulting FTA cf 2641 tends occur wants evaluate comparatively simple MSOformulae trees The situation gets worse consider MSO structures bounded treewidth original possibly simple MSOformula ϕ ﬁnite structure ﬁrst transformed equivalent MSOformula ϕ trees Hence transformation algorithm 25 leads complex formula general additional quantiﬁer alternations original formula In summary come conclusion Grohe 32 algorithms derived Courcelles Theorem useless practical applications main beneﬁt Courcelles Theorem provides simple way recognize property linear time computable 6 Conclusions future work In paper Courcelles Theorem prove ﬁxedparameter tractability range problems knowledge representation reasoning More precisely shown problems area abduction closed world reasoning circumscription disjunctive logic programming solvable linear time treewidth considered formulae programs bounded constant We experimented prototype implemen tation based standard MSOtoFTA approach 25 However accordance 32 come conclusion generic way turning MSO characterization problem algorithm feasible practice despite theoretical ﬁxedparameter linearity approach Thus second work investigated alternative method turning theoretical tractability sults obtained Courcelles Theorem feasible computations Based monadic datalog approach presented 30 constructed new algorithms logicbased abduction The experimental results obtained implementation algorithms underline feasibility approach The datalog programs presented paper obtained ad hoc construction generic trans formation MSO Nevertheless convinced idea bottomup propagation certain SAT UNSAT conditions generally applicable As step planning devise new algorithms based monadic datalog approach problems area knowledge representation reasoning In fact cir cumscription disjunctive logic programming related algorithms presented recently 3637 In paper monadic datalog approach 30 applied decision problems given PAP solvable enumeration problem unary query free individual variable given PAP compute relevant hypotheses In future planning extend approach kinds problems like counting problems solutions given PAP enumeration problems general queries given PAP compute solutions In fact ﬁrst steps direction 3637 Our notion treewidth problems considered corresponds treewidth primal graph derlying structures graph vertices domain elements occurring structure vertices adjacent primal graph corresponding domain elements jointly occur tuple structure Clearly mappings knowledge representation reasoning problems graphs particular directed graphs conceivable Moreover recently interesting notions decompositions width developed 764335 We planning investigate applicability problems studied Acknowledgements We grateful anonymous referees Michael Jakl Stefan Rümmele Stefan Woltran valuable comments previous versions article G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 129 Appendix A Proof Lemma 41 We solvepredicate computed SATprogram intended meaning For values v P N C ground fact solvev P N C true minimal model interpreted program following condition holds Property A There exists extension J assignment P N VarTv st ClTv Clv C true J clauses c Clv C restriction cVarTv false J The proof goes structural induction tree decomposition Base case For leaf node v exactly facts solvev P N C C Clv true minimal model following condition holds c C cVarv evaluates true assignment P N c Clv C cVarv evaluates false P N The extension J P N VarTv P N Hence solvev P N C true minimal model Property A holds Induction step ifdirection Suppose arbitrary values v P N C ground fact solvev P N C true minimal model interpreted program In order Property A holds distinguish ﬁve cases according ﬁve types internal nodes 1 Variable removal node removal variable x Let solvev P N C true minimal model let v 1 denote child v Then solvev 1 P cid22 x N C solvev 1 P N cid22 x C true minimal model We restrict ﬁrst case The treated analogously By induction hypothesis exists extension J assignment P cid22 x N VarTv1 VarTv st ClTv Clv C true J clauses c C restriction cVarTv false J Then J desired extension P N cid9 cid9 cid9 Hence cid9 c C 2 Clause removal node removal clause c Let solvev P N C true minimal model let v 1 denote cid9 true minimal child v By construction C form C cid9 model By induction hypothesis exists extension J P N VarTv VarTv1 st ClTv1 Clv 1 C true J clauses d Clv 1 C restriction dVarTv false J Note Clv c Clv 1 cid9 J desired extension P N node v ClTv Clv C ClTv1 Clv 1 C C c C true J Moreover d Clv C Clv 1 C cid9 Clv 1 st solvev 1 P N C restriction dVarTv false J 3 Variable introduction node introduction variable x Let solvev P cid22 x N C true minimal model let v 1 denote child v The case solvev P N cid22 x C treated analogously omitted There exist sets C1 C2 C C1 C2 st solvev 1 P N C1 truex C2 Clv true minimal model The condition means C2 contains exactly clauses Clv propositional variable x occurs unnegated form Of course ClTv1 ClTv VarTv1 VarTv x By induction hypothesis exists extension J 1 P N VarTv1 st ClTv1 Clv 1 C1 true J 1 clauses c Clv 1 C1 restriction cVarTv1 false J 1 Now consider extension J P cid22 x N VarTv obtained extending J 1 VarTv VarTv1 x J x true By construction clauses C C1 positive occurrence x true J Hence clauses ClTv Clv C true J On hand deﬁnition C clauses c Clv C restriction cVarTv false J Hence J desired extension assignment P cid22 x N 4 Clause introduction node introduction clause c We VarTv1 VarTv ClTv1 ClTv c By connectedness condition cVarTv cVarv Hence truth value cVarTv extension P N VarTv coincides truth value cVarv P N Now let solvev P N C true minimal model let v 1 denote child v By construction exist facts solvev 1 P N C1 trueP N C2 c C C1 C2 true minimal model Thus induction hypothesis exists extension J P N VarTv1 VarTv st ClTv1 Clv 1 C1 true J clauses d Clv 1 C1 restriction dVarTv false J We claim J desired extension P N v To ﬁrst consider case cVarv false P N Hence C2 C C1 Moreover ClTv Clv C ClTv1 Clv 1 C1 true J On hand clauses d Clv C Clv C1 d Clv 1 C1 d c In case restriction dVarTv false J It remains consider case cVarv true P N In case C2 c C form C C1 c We ClTv Clv C ClTv1 Clv 1 C1 c We considering case c true P N J Hence ClTv Clv C true J On hand clauses d Clv C Clv 1 C1 restriction dVarTv false J 5 Branch node Suppose solvev P N C true minimal model C C1 C2 st solvev 1 P N C1 solvev 2 P N C2 true minimal model By induction hypothesis 1 2 assignment P N extended interpretation J VarTv st ClTv Clv Ci true J clauses c Clv Ci restriction cVarTvi false J We fact Clv Clv holds Note deﬁnition normalized tree decompositions connectedness condition VarTv1 VarTv2 Varv Moreover 130 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 J 1 J 2 coincide Varv extend P N Hence deﬁne extension J P N VarTv follows J x P Nx J 1x J 2x x Varv x VarTv1 Varv x VarTv2 Varv We claim J desired property Every clause c ClTv Clv C contained sets ClTv Clv Ci 1 2 Hence clause c true J induction hypothesis Likewise clause c Clv C restrictions cVarTvi false J Hence cVarTv false J Induction step ifdirection Suppose arbitrary values v P N C Property A holds v denotes node T P N assignment variables Varv Moreover C arbitrary clause set C Clv exists extension J P N VarTv st ClTv Clv C true J clauses d Clv C restriction dVarTv false J We fact solvev P N C true minimal model interpreted program Again distinguish ﬁve cases according ﬁve types internal nodes 1 Variable removal node removal variable x Note ClTv ClTv1 Clv Clv 1 VarTv VarTv1 Varv Varv 1 x v 1 child v We distinguish cases depending J x true J x false We treat ﬁrst case The second goes analogously Since J x true J extension P cid22 x N By assumption ClTv Clv C ClTv1 Clv 1 C true J clauses d Clv C Clv 1 C restriction dVarTv dVarTv1 false J Hence induction hypothesis solvev 1 P cid22 x N C true minimal model solvev P N C true 2 Clause removal node removal clause c Note ClTv ClTv1 Clv Clv 1 c VarTv VarTv1 cid9 C c By assumption clauses ClTv Clv C restriction dVarTv cid9 true minimal model Varv Varv 1 v 1 child v Let C ClTv1 Clv 1 C dVarTv1 false J Hence induction hypothesis solvev 1 P N C solvev P N C true minimal model true J On hand clauses d Clv C Clv 1 C cid9 cid9 3 Variable introduction node introduction variable x In case ClTv1 ClTv Clv 1 Clv VarTv1 VarTv x Varv 1 Varv x v 1 child v We distinguish cases depending x P x N We treat ﬁrst case The second goes analogously Consider assignment J VarTv1 VarTv x We deﬁne P x N Varv 1 Varv x Moreover let J 1 denote restriction C1 c C cVarTv1 true J 1 By connectedness condition clauses ClTv1 Clv 1 ClTv Clv contain variable x Hence truth value J 1 J true Thus ClTv1 Clv 1 C1 true J 1 On hand d Clv 1 C1 restriction dVarTv1 false J 1 Thus induction hypothesis solvev 1 P x N C1 true minimal model Now let C2 deﬁned C2 c C x occurs unnegated c Then C C1 C2 holds This fact clauses C true J Hence true J 1 true J unnegated occurrence x Moreover deﬁnition truepredicate fact truex C2 C true minimal model Thus solvev P N C true minimal model 4 Clause introduction node introduction clause c In case ClTv1 ClTv c Clv 1 Clv c VarTv1 VarTv Varv 1 Varv v 1 child v By connectedness condition cVarTv cVarv holds Let C2 deﬁned C2 c cVarv In case fact trueP N C2 c true minimal model true P N C2 Now let C1 C C2 Clearly ClTv1 Clv 1 C1 ClTv Clv C holds By assumption ClTv Clv C true J Hence ClTv1 Clv 1 C1 true J Moreover clauses d Clv 1 C1 Clv C restriction dVarTv1 dVarTv false J Hence induction hypothesis solvev 1 P N C1 true minimal model Thus construction solvev P N C true minimal model 5 Branch node Let v 1 v 2 denote children v let 1 2 By deﬁnition branch nodes Clv Clv 1 Clv 2 Varv Varv 1 Varv 2 Let Ci deﬁned Ci c C cVarTvi true J By assumption c C restriction cVarTv true J Hence c C cVarTv1 cVarTv2 true J Thus C C1 C2 Let J denote restriction J VarTv By connectedness condition clause d ClTv Clv truth value dVarTvi J identical truth value d J true Hence ClTv Clv Ci true J Now consider arbitrary clause d Clv Ci Clv Ci Clv C If d Clv C dVarTv false J dVarTvi false J On hand d C Ci deﬁnition Ci dVarTvi false J Hence case restriction dVarTvi false J Thus induction hypothesis solvev P N Ci true minimal model 1 2 Thus solvev P N C C C1 C2 true minimal model G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 131 Auxiliary Predicates checkP N C1 C y trueP N C1 C x N manx checkP N C1 C n trueP N C1 C checkP N C1 C y deﬁnedv S i1 i2 auxv S i1 i2 P N C d equalv S i1 i2 j1 j2 deﬁnedv S i1 i2 deﬁnedv S j1 j2 diff v S i1 i2 j1 j2 diff v S i1 i2 j1 j2 deﬁnedv S i1 i2 deﬁnedv S j1 j2 auxv S i1 i2 P N C d auxv S j1 j2 P N C d diff v S i1 i2 j1 j2 deﬁnedv S i1 i2 deﬁnedv S j1 j2 auxv S j1 j2 P N C d auxv S i1 i2 P N C d j1 j2 i1 i2 j1 i1 j j2 j i2 j2 i2 reduced_smallerv S i1 i2 j1 j2 i1 i2 reducev S j1 j2 duplicatev S i1 i2 j1 j2 i1 i2 equalv S i1 i2 j1 j2 openv S i1 i2 j reduced_smallerv S j i1 i2 reducev S i1 i2 0 cid2 K deﬁnedv S i1 i2 reduced_smallerv S i1 i2 duplicatev S i1 i2 openv S i1 i2 Fig B1 reduce auxiliary predicates Appendix B Datalog deﬁnition reducepredicate As mentioned Section 42 ﬁnd preferable think reducepredicate builtin predicate implemented eﬃciently appropriate hash codes However necessity imple mented datalog negation A datalog implementation reducepredicate auxiliary predicates given Fig B1 The idea reducev S twofold 1 We want detect duplicates Two pairs i1 i2 j1 j2 duplicates values P N C d fact auxv S i1 i2 P N C d true minimal model auxv S j1 j2 P N C d true minimal model In situation lexicographically smallest pair i1 i2 delete pairs 2 We map pairs indices i1 i2 deleted 1 lexicographic order contiguous values The functionality reduce provided eﬃciently hash codes facts auxv S i1 i2 In Fig B1 deﬁnable datalog The rule head predicate reduce guarantees pair i1 i2 indices mapped single index following conditions fulﬁlled pair i1 i2 deﬁned exists auxfact combination v S i1 i2 ii lexicographically smaller pair j1 j2 mapped iii lexicographically smaller pair j1 j2 st i1 i2 j1 j2 rise exactly set ground atoms auxv S _ _ P N C d true minimal model interpreted program iv indices j j exists pair j1 j2 smaller i1 i2 mapped j The intended meaning predicates check reduce explained Section 42 The pred icates Fig B1 following meaning deﬁnedv S i1 i2 means exists auxfact combination v S i1 i2 equalv S i1 i2 j1 j2 true minimal model i1 i2 j1 j2 rise exactly set ground atoms auxv S _ _ P N C d true minimal model pro gram diff v S i1 i2 j1 j2 means i1 i2 j1 j2 rise different sets ground atoms auxv S _ j1 j2 lexicographically smaller i1 i2 With _ P N C d reduced_smallerv S i1 i2 check index pair j1 j2 lexicographically smaller i1 i2 mapped duplicatev S i1 i2 means exists lexicographically smaller pair j1 j2 st i1 i2 j1 j2 rise exactly set ground atoms auxv S _ _ P N C d true minimal model words i1 i2 duplicate Finally openv S i1 i2 means exists index j target mapping deﬁned reducepredicate exists index pair j1 j2 smaller i1 i2 st j1 j2 mapped j j1 j2 i1 i2 true minimal model References 1 S Abiteboul R Hull V Vianu Foundations Databases AddisonWesley 1995 2 S Arnborg Eﬃcient algorithms combinatorial problems bounded decomposabilityA survey BIT 25 1 1985 223 3 S Arnborg J Lagergren D Seese Easy problems treedecomposable graphs J Algorithms 12 2 1991 308340 4 A Atserias JK Fichte M Thurley Clauselearning algorithms restarts boundedwidth resolution Proc SAT09 Lecture Notes Computer Science vol 5584 Springer 2009 pp 114127 132 G Gottlob et al Artiﬁcial Intelligence 174 2010 105132 5 M Baaz U Egly A Leitsch Normal form transformations JA Robinson A Voronkov Eds Handbook Automated Reasoning vol 1 Elsevier Science 2001 pp 273333 Chapter 5 6 D Berwanger A Dawar P Hunter S Kreutzer DAGwidth parity games Proc STACS06 Lecture Notes Computer Science vol 3884 2006 pp 524536 7 D Berwanger E Grädel EntanglementA measure complexity directed graphs applications logic games Proc LPAR04 Lecture Notes Computer Science vol 3452 2005 pp 209223 8 HL Bodlaender A lineartime algorithm ﬁnding treedecompositions small treewidth SIAM J Comput 25 6 1996 13051317 9 HL Bodlaender AMCA Koster Safe separators treewidth Discrete Math 306 3 2006 337350 10 HL Bodlaender AMCA Koster Combinatorial optimization graphs bounded treewidth Comput J 51 3 2008 255269 11 RB Borie Generation polynomialtime algorithms optimization problems treedecomposable graphs Algorithmica 14 2 1995 123 137 12 RB Borie RG Parker CA Tovey Automatic generation lineartime algorithms predicate calculus descriptions problems recursively constructed graph families Algorithmica 7 56 1992 555581 13 M Cadoli M Lenzerini The complexity propositional closed world reasoning circumscription J Comput Syst Sci 48 2 1994 255310 14 B Courcelle Graph rewriting An algebraic logic approach J van Leeuwen Ed Handbook Theoretical Computer Science vol B Elsevier Science Publishers 1990 pp 193242 15 B Courcelle JA Makowsky U Rotics On ﬁxed parameter complexity graph enumeration problems deﬁnable monadic secondorder logic Discrete Appl Math 108 12 2001 2352 16 B Courcelle M Mosbah Monadic secondorder evaluations treedecomposable graphs Theor Comput Sci 109 12 1993 4982 17 J Doner Tree acceptors applications J Comput Syst Sci 4 5 1970 406451 18 WF Dowling JH Gallier Lineartime algorithms testing satisﬁability propositional Horn formulae J Log Program 1 3 1984 267284 19 RG Downey MR Fellows Parameterized Complexity Springer New York 1999 20 T Eiter G Gottlob Propositional circumscription extended closed world reasoning Π p 21 T Eiter G Gottlob The complexity logicbased abduction J ACM 42 1 1995 342 22 T Eiter G Gottlob On computational cost disjunctive logic programming Propositional case Ann Math Artif Intell 15 34 1995 289323 23 G Filé Tree automata logic programs Proc STACS85 Lecture Notes Computer Science vol 182 1985 pp 119130 24 E Fischer JA Makowsky EV Ravve Counting truth assignments formulas bounded treewidth cliquewidth Discrete Appl Math 156 4 2 complete Theor Comput Sci 114 1993 231245 2008 511529 25 J Flum M Frick M Grohe Query evaluation treedecompositions J ACM 49 6 2002 716752 26 M Frick M Grohe The complexity ﬁrstorder monadic secondorder logic revisited Ann Pure Appl Logic 130 13 2004 331 27 M Gelfond V Lifschitz The stable model semantics logic programming Proc ICLPSLP88 MIT Press 1988 pp 10701080 28 M Gelfond H Przymusinska TC Przymusinski On relationship circumscription negation failure Artif Intell 38 1 1989 7594 29 G Gottlob R Pichler F Wei Bounded treewidth key tractability knowledge representation reasoning Proc AAAI06 AAAI Press 2006 pp 250256 30 G Gottlob R Pichler F Wei Monadic datalog ﬁnite structures bounded treewidth Proc PODS07 ACM 2007 pp 165174 31 G Gottlob R Pichler F Wei Abduction bounded treewidth From theoretical tractability practically eﬃcient computation Proc AAAI08 AAAI Press 2008 pp 15411546 32 M Grohe Descriptive parameterized complexity Proc CSL99 Lecture Notes Computer Science vol 1683 1999 pp 1431 33 J Gustedt OA Mæhle JA Telle The treewidth Java programs Proc ALENEX02 4th International Workshop Algorithm Engineering Experiments Revised Papers Lecture Notes Computer Science vol 2409 Springer 2002 pp 8697 34 M Hermann R Pichler Counting complexity minimal cardinality minimal weight abduction Proc JELIA08 Lecture Notes Computer Science vol 5293 Springer 2008 pp 206218 35 P Hunter S Kreutzer Digraph measures Kelly decompositions games ordering Theor Comput Sci 399 2008 206219 36 M Jakl R Pichler S Rümmele S Woltran Fast counting bounded treewidth Proc LPAR08 Lecture Notes Computer Science vol 5330 2008 pp 436450 37 M Jakl R Pichler S Woltran Answerset programming bounded treewidth Proc IJCAI09 2009 pp 816822 38 N Klarlund A Møller MI Schwartzbach MONA implementation secrets Int J Found Comput Sci 13 4 2002 571586 39 AMCA Koster HL Bodlaender SPM van Hoesel Treewidth Computational experiments Electronic Notes Discrete Mathematics 8 2001 5457 40 G MarquePucheu Rational set trees algebraic semantics logic programming Acta Inf 20 1983 249260 41 H Maryns On implementation tree automata Limitations naive approach Proc TLT06 5th Int Treebanks Linguistic Theories Conference 2006 pp 235246 42 M Minoux LTUR A simpliﬁed lineartime unit resolution algorithm horn formulae implementation Inf Process Lett 29 1 1988 112 43 J Obdržálek DAGwidth Connectivity measure directed graphs Proc SODA06 ACM Press 2006 pp 814821 44 CH Papadimitriou Computational Complexity AddisonWesley 1994 45 TC Przymusinski Stable semantics disjunctive programs New Generation Comput 9 34 1991 401424 46 JW Thatcher JB Wright Generalized ﬁnite automata theory application decision problem secondorder logic Mathematical Systems Theory 2 1 1968 5781 47 W Thomas Languages automata logic Handbook Formal Languages vol III Springer New York 1997 pp 389455 48 M Thorup All structured programs small treewidth good register allocation Inf Comput 142 2 1998 159181 49 F van den Eijkhof HL Bodlaender AMCA Koster Safe reduction rules weighted treewidth Algorithmica 47 2 2007 139158