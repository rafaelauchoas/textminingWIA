Artiﬁcial Intelligence 193 2012 186216 Contents lists available SciVerse ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Concurrent forward bounding distributed constraint optimization problems Arnon Netzer Alon Grubshtein Amnon Meisels Dept Computer Science Ben Gurion University Negev PO Box 653 Beer Sheva 84105 Israel r t c l e n f o b s t r c t Article history Received 6 November 2011 Received revised form 28 August 2012 Accepted 4 September 2012 Available online 7 September 2012 Keywords Distributed constraint optimization problems Algorithms ConcFB A distributed search algorithm solving Distributed Constraints Optimization Problems DCOPs presented The new algorithm scans search space multiple search processes SPs run agents concurrently SPs search nonintersecting parts global search space perform Branch Bound search Each search process SP uses mechanism forward bounding FB prune eﬃciently global search space The Concurrent ForwardBounding ConcFB algorithm enables SPs share upper bound parts global search space The number concurrent SPs controlled dynamically ConcFB algorithm performing dynamic splitting Within SP dynamic variable ordering employed order help control balance computational load agents different SPs The ConcFB algorithm evaluated experimentally compared state art DCOP algorithms The number NonConcurrent Logical Operations NonConcurrent Steps total number messages sent CPU time performance metrics The evaluation procedure considers different DCOP problem types varying number agents different constraint graphs As problems larger denser ConcFB shown outperform evaluated algorithms 23 orders magnitude performance measures Further evaluations comparing different variants ConcFB provide important insights working algorithm reveals contribution different components 2012 Elsevier BV All rights reserved 1 Introduction The ﬁeld Distributed Constraint Reasoning provides widely accepted framework representing solving Multi Agent Systems MAS problems In distributed constraint problem agent holds set variables representing state These variables values ﬁnite domain subject constraints A distributed constraint algorithm deﬁnes interaction protocol coordinating joint assignment variables Optimally solving constraint problems NPHard general case 6 Distributed Constraint Reasoning provide elegant model everyday combinatorial problems dis tributed nature In problems independent computational entities agents partial knowledge problem The distributed setting assumes agents incapable disclosing private information reluctant 142 Distributed Constraint Optimization Problems DCOPs successfully applied MAS problems coordi nating mobile sensors 1425 meeting task scheduling 16 synchronization traﬃc lights 13 Recent years seen large number different interesting algorithms optimally solving DCOPs These include Synchronous Branch Bound SBB 12 NCBB4 ADOPT 21 ODPOP23 BnBADOPT 26 OptAPO 10 AFB 9 Corresponding author Tel 972 54 7706194 fax 972 8 6477650 Email addresses netzerarcsbguacil A Netzer alongrubcsbguacil A Grubshtein amcsbguacil A Meisels 00043702 matter 2012 Elsevier BV All rights reserved httpdxdoiorg101016jartint201209002 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 187 Some algorithms use pseudo trees 212326 introduced Section 22 attempt asynchronously prune search space 9 The OptAPO algorithm partially centralizes problem 10 DPOP uses Dynamic Programming 23 Despite differences algorithms share important properties attempt increase eﬃciency increasing computational concurrency attempt promptly obtain good bounds reduce number states visited search space The present paper presents new approach ﬁnding optimal solution DCOPs The proposed algorithm partitions search space nonintersecting subproblems somewhat similar described DCSPs 31 Each subproblem involves agents solved Synchronous Forward Bounding SFB algorithm This choice SFB stems synchronous nature powerful pruning abilities The agents solving independent subproblems concurrently assigning unique identiﬁers separate data structures subproblem In form information different areas search space achieve bounds faster The Concurrent Forward Bounding ConcFB algorithm following important properties High degree concurrency Much computational effort performed parallel algorithm terminates faster Moreover shown Section 3 ConcFB controls number running concurrent search processes dynamically splitting remaining parts problem Improves methods Forward Bounding sharing information disjoint parts search space Controls work load balancing employing dynamic ordering heuristics This useful computational effort costly slow weak mobile devices The eﬃciency ConcFB extensively evaluated state art algorithms number Non Concurrent Logical Operations NonConcurrent Steps total number messages sent CPU time performance metrics An additional concurrent algorithm combines multiple instances SBB introduced implementation evaluated provide insights impact concurrent algorithms The evaluation procedure considers different DCOP problem types varying number agents different straint graphs As problems larger denser ConcFB shown outperform evaluated algorithms 23 orders magnitude performance metrics Further evaluations comparing different variants ConcFB provide im portant insights working algorithm reveals contribution different components The remainder paper structured follows Section 2 formally deﬁnes DCOPs introduces leading DCOP algorithms Section 3 presents ConcFB Section 4 presents correctness completeness proof ConcFB Section 5 describes enhancements basic ConcFB algorithm The experimental evaluation discussion results Section 6 The conclusions summarized Section 7 2 Distributed constraint optimization 21 Distributed Constraint Optimization Problem DCOP Formally DCOP tuple cid3A X D Ccid4 1 A ﬁnite set agents A1 A2 An 2 X ﬁnite set variables X1 X2 Xm Each variable held single agent agent hold variable 3 D set domains D1 D2 Dm Each domain D contains ﬁnite set values assigned variable Xi 4 C set constraints Each constraint c C deﬁnes nonnegative cost possible value combination set variables form C D i1 D i2 D ik R A binary constraint constraint involving exactly variables takes following form Ci j D D j R A binary DCOP DCOP constraints binary We constraint c applicable joint partial assignment variables involved c value To facilitate understanding following assumptions structure DCOPs 1 Each agent holds single variable terms variable agent interchangeably 2 DCOPs assumed binary These common assumptions DCOP literature cf 2119326 188 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 Fig 1 A simple DCOP example agents Fig 2 The OR search tree DCOP depicted Fig 1 Relations interacting agents DCOP represented graphs Each node corresponds agent edge represents constraint agents The nature constraints speciﬁed set values corresponding agents joint assignments It worth noting explicitly stated common assume constraint structure DCOP limit communication agents 27 Thus agents communicate agents add links 2927 agree ordering 30 broadcast important information agents directly connected constraint 9 Fig 1 presents simple DCOP problem agents The cost value combination speciﬁed right hand ﬁgure A DCOP algorithm proceeds sending messages adding changing assignments variables An assignment cid3variable valuecid4 pair A set assignments variable appears called partial assignment The cost partial assignment PA aggregated constraint cost variables constituting assignment PA For example cost partial assignment cid3a1 3cid4cid3a2 2cid4 respect DCOP Fig 1 exactly 1 Afull assignment partial assignment includes variables solution assignment minimal cost The solution DCOP cid3a1 4cid4cid3a2 2cid4cid3a3 1cid4cid3a4 2cid4 cost 3 One explore Constraint Reasoning problems means underlying search space Fig 2 presents tree representation search space DCOP Fig 1 referred generateandtest tree In tree row corresponds exactly agent edges correspond assignments For convenience leaf search tree presents cost assignment The set leaf nodes present possible costs assignment combination Throughout paper refer tree representation DCOP search space search tree DCOP search tree use terms interchangeably A path root leaf search tree corresponds complete assignment For example highlighted path Fig 2 corresponds assignment cid3a1 2cid4 second possible edges cid3a2 2cid4 second cid3a3 1cid4cid3a4 2cid4 The cost assignment 7 higher optimal cost The search tree representation presented Fig 2 know OR search tree 17 constraint reasoning problem It useful understanding different properties constraint algorithms progress The search space represented ANDOR search tree 17 captures idea independent subproblems problems search space An ANDOR tree guided pseudo tree 7 A pseudo tree 8 spanning tree involving agents problem following important property nodes located separate branches tree share constraint That different branches pseudo tree A Netzer et al Artiﬁcial Intelligence 193 2012 186216 189 Fig 3 A pseudo tree arrangement ANDOR tree corresponding simple DCOP example Fig 1 represent independent DCOP subproblems The arrangement agents pseudo tree increase concurrency DCOP algorithms Fig 3 presents pseudo tree arrangement ANDOR tree DCOP Fig 1 General Cutset Conditioning 518 provides alternative decomposition independent subproblems This approach based identifying set nodes removed render constraint graph cyclefree That method enumerates possible instantiations cutset independently solve remaining singly connected network linear time The performance gain cutset conditioning highly related constraint graph given instance ﬁnding minimal NPcomplete 22 DCOP algorithms Recent years seen large number algorithms solving DCOPs These vary approach ﬁnding minimal cost solutions Successful DCOP algorithms characterized high degree concurrency methods quick bounding search space Synchronous Branch Bound SBB 1219 simplest DCOP algorithm Often baseline algorithm evaluation conveys general scheme diﬃculties DCOP algorithms simple manner SBB operates passing unique CPA message Current Partial Assignment agents An agent holding CPA attempts extend adding assignment lower cost current upper bound If suitable assignment added CPA CPA sent line agent If assignment CPA sent agent CPA At given moment agent holding CPA perform action This naive implementation produces algorithm agents idle time Recent algorithms signiﬁcantly outperform SBB cf 19 indepth introduction discussion DCOP algorithms Asynchronous Distributed Optimization ADOPT 21 ADOPT inherently asynchronous algorithm Agents running ADOPT prearranged pseudo tree structure execute preprocessing protocol results continuously search solutions space Best First manner At given moment agents maintain lower upper bound current search meet solution A powerful extension ADOPT recently introduced 26 Unlike predecessor BNBADOPT applies Depth First search shown greatly improve ADOPTs performance Both ADOPT BNBADOPT exhibit high degree concurrency attain good bounds employing strong heuristic functions Although experimental evaluation indicates algorithms signiﬁcantly improve terms computational effort base line SBB algorithm suffer rapid growth messages number neighbors agent constrained increases problems density Distributed Pseudotree Optimization Protocol DPOP 22 DPOP algorithm based Dynamic Programming instead standard Search approach inference algorithm search algorithm DPOP operates phases In ﬁrst phase agents rearranged pseudo tree structure In second phase UTIL agents propagate optimal aggregated utility subtrees leafs root pseudo tree bottomup phase Finally phase VALUE optimal assignments propagated root leafs topdown phase based aggregated calculation second phase Unlike ADOPT phase structure DPOP ensures low number messages linear number agents However DPOP message sizes exponential induced width underlying pseudo tree ODPOP 23 extension DPOP overcomes problem sending UTIL tuples instead complete optimal assignment combinations These tuples ordered quality sent time Thus ODPOP complete algorithm polynomial width tree sized messages Although initially designed handle open problems 23 ODPOP requires changes applied standard DCOPs The inherently different approach solving DCOPs makes evaluating computational effort DPOP ODPOP dif ﬁcult performance measure speciﬁed authors 2223 Our experimental evaluation Section 6 indicate number logical operations taken ODPOP higher SBB 190 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 NonCommitment Branch Bound NCBB 4 NCBB pseudo tree extension SBB employs non committing scheme improving concurrency level Taking advantage underlying tree structure NCBB capable searching different branches tree simultaneously This combined interesting ex ploration scheme agent inform children different assignment This noncommitment assignment increases algorithms concurrency level allows descendant continue search different context sibling pursuing previous In 26 NCBBs performance evaluated BnBADOPT shown slightly eﬃcient Asynchronous Forward Bounding AFB 9 AFB applies hybrid approach asynchronicity CPA passed tween agents proceeds synchronous steps solution bounds attained asynchronous manner AFB agents refrain sending large amounts volatile data synchronously extending CPA That agent receiving CPA attempt extend add assignment pass agent After agent passes CPA successor agent notiﬁes unassigned agents current assignment Each unassigned agent infers bound lowest cost partial assignment These values computed concurrently asynchronously responses sent originator request This results asynchronous process backwards costs propagation Whenever aggregated cost bound requests breaches best known upper bound requesting agent generates new CPA revised assignment backtracks The AFB algorithm synchronously assigns values variables asynchronously compute lower bounds solution costs shown produce better results terms network load computational effort ADOPT DPOP problem instances 9 3 Concurrent forward bounding Concurrent Forward Bounding ConcFB applies SFB Synchronous Forward Bounding means attain good lower bounds utilizing multiple concurrent search processes speed search ConcFB partitions original search space disjoint parts concurrently search SFB This means multiple instances SFB algorithms executed agents instance searches distinct search space Global information best upper bound shared instances improves algorithms pruning abilities The following features ConcFB noted It rely pseudo tree arrangement agents This simpliﬁes use agent reordering heuristics usually provide signiﬁcant performance boost DCSP algorithms 203334 Section 51 ConcFB partitions search space rely structure constraints The generated subproblems involve agents differ domain agents variable Section 32 Although search process subproblem proceeds synchronous steps Section 31 synchro nization ongoing processes different subproblems This means agents act asynchronously concurrently The components ConcFB ﬁrst described separately Section 31 discusses forward bounding search technique Section 32 discusses concurrent search distributed constraint reasoning problems Section 33 provides detailed overview ConcFB algorithm Section 34 presents ConcFB trace example DCOP problem Fig 1 31 Synchronous Forward Bounding SFB Synchronous Forward Bounding highly related AFB algorithm presented 9 Similar AFB SFB agents pass unique CPA message agent holding CPA assign new values SFB differs AFB agents proceed assignment prior receiving lower bounds unassigned agents This results synchronization algorithm help reduced propagation irrelevant data cost reduced concurrency Note ConcFB combines SFB Concurrent framework Section 32 increase concurrency level Fig 4 presents simplistic Forward Bounding assignment scheme1 SFB agents wait messages trigger different responses Whenever agent ai receives CPA ﬁrst attempts extend assigning value variable lines 14 It sends broadcasts message updated partial assignment unassigned agents This LB_Request message triggers calculation minimal cost agent sent ai lines 56 Unlike AFB progress blocked LB_Report messages received aggregated unassigned agents lines 78 This blocks execution result long periods idle waiting agents If sum aggregated cost current cost CPA lower current upper bound CPA extended agent proper message sent forward If cost 1 Important details specifying actions taken CPA ﬁlled content different message types relevant information omitted sake clarity A Netzer et al Artiﬁcial Intelligence 193 2012 186216 191 1 CPA mCPA 2 DomainisEmpty 3 CPAaddLocal_Assignment CPAcost CPAcost assignments cost j CPAunassigned senda j LB_Request Wait unassigned agents reply LB_Report message LB aggregated sum LB_Report CPAcost LB Upper_Bound sendNext_Agent CPA CPAremoveLocal_Assignment CPAcost CPAcost assignments cost Remove Local_Assignment domain assign_CPAm 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sendLast_Assigned_Agent Backtrack_CPA Fig 4 assign_CPAmsg A simplistic pseudocode assign method SFB This code executed reception message containing CPA Fig 5 Six disjoint partitions search space lower current upper bound new assignment attempted process repeats lines 915 When domain agent emptied backtrack triggered current CPA assignment ai sent assigning agent ai1 lines 1617 32 Concurrent search Concurrent search solving DCSPs presented 31 The basic idea concurrent search algorithms logically partition search space nonintersecting parts This allows set agents participate distinct constraint search processes Concurrent search powerful framework applied DCSP algorithm 31 In simplest partitioning scheme assignment initializing agent different Search Process2 This results number search processes exactly domain size initializing agent Concurrent search adapted DCOPs However unlike DCSPs seek single consistent solution concurrent DCOP framework minimal cost solution subproblems reported Fig 5 provides graphical repre sentation possible partition scheme problem Fig 1 The search space partitioned disjoint segments SP1SP6 induced different domain agent a1 split SP4 based domain agent a2 In subproblems a1 owns single value variable domain In SP1 domain a1 1 SP2 2 forth Having partitioned original problem complete DCOP algorithm applied solve subparts SP1 SP2 SP3 SP5 SP6 extract minimal cost solution The minimal cost solutions SP5 SP6 combined agent initiating split SP4 agent a2 It important point agents concurrent search participate single subproblem Fig 5 demonstrates idea agents participate multiple search processes This contrast subproblems resulting pseudo tree arrangement agents agent participate subproblem results merged higher priority agents 2 Represented OR node tree cf 17 192 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 Concurrent SBB b Pruning multiple SPs Concurrent SBB Colored nodes pruned CPA reaches agent 3 4 Fig 6 Snapshots Concurrent SBB run Information progress SP maintained Search Process SP data structure maintained agent SP An SP single search process remainder paper use terms interchangeably Each SP includes unique identiﬁer maintains data global ordering agents All relevant messages data structures underlying search algorithm stamped relevant SP identiﬁer agent holds designated data structure recording information SP In particular agent maintains information current domain respect SP value v j maybe pruned domain agent ai context SPx valid respect SP y Before presenting ConcFB consider example run Concurrent SBB DCOP Fig 1 In example search space partitioned SPs a1 holds single value domain shown Fig 5 ConcSBB begins generating different CPAs instead unique standard SBB In SP agent a1 assigns value CPAs sends agent a2 Fig 6a Upon receiving CPA message a2 examines identiﬁer SP ID code associates corresponding local SP If a2 unfamiliar ID code new local SP instantiated The agent proceeds extend CPAs continue SBB run At point time CPA SP1 holds assignment A assignment serves new upper bound prune search space This new bound relevant current SP SPs prune search space If agents 3 4 notiﬁed new bound proceeding assign values bound SP1 prune assignments SP2 SP3 SP4 Fig 6b 33 Concurrent Forward Bounding ConcFB The present work applies SFB individual search process resulting Concurrent Forward Bounding ConcFB The SFB algorithm important features suitable concurrent search powerful pruning abilities synchronous progress In particular feature facilitate introduction dynamic reordering agents dynamic splitting search space discussed Section 5 The ﬁrst agent ConcFB begins operation partitioning search space disjoint parts For assignment domain Search Process SP initiated These SPs represent partition search algorithm SFB executed When search algorithms conclude ﬁrst agent reports minimal cost solution subproblems It worth noting order improve pruning upper bounds shared search processes That new upper bound prune search SPs Since agent participate multiple SPs given time means identify manage execution search procedure carried SPs introduced A Netzer et al Artiﬁcial Intelligence 193 2012 186216 193 The following subsections provides detailed account ConcFB We ﬁrst introduce main data structures Next messages algorithm presented Finally Section 333 describes pseudocode ConcFBs functions 331 Data structures The main data structures ConcFB CPA LB_List Splits SP A CPA Current Partial Assignment maintains values currently assigned agents resulting cost joint assignment That contains set pairs form cid3Agent Valuecid4 integer value aggregated sum costs constraints applicable CPA Every CPA associated Search Process discussed shares unique identiﬁer The LB_List vector Lower Bounds LBs reported unassigned agents respect given CPA A list SPs diverging Search Process agent In basic implementation ConcFB splits data structure root search process The SP Search Process data structure lies heart ConcFB Each agent holds SP logical search process takes Fig 5 An SP instantiated new CPA received agent Every SP contains unique ID current assignment agent takes respect speciﬁc SP cost agents current domain respect speciﬁc SP Additionally SP holds CPA triggered creation list LBs LB_List splits diverging SP SP_List A list currently active SPs held agent 332 Messages ConcFB uses ﬁve types messages transfer information requests agents CPA A message containing CPA LB_List sent agent extending CPA given search process unassigned agent BT_CPA A backtrack message notifying agent CPA received needs backtracked LB_Request A message containing CPA sent agent asking calculate return Lower Bound given CPA LB_Report A message sent reply LB_Request reporting Lower Bound given agent given CPA UB A broadcast message informing agents newly reached Upper Bound These messages limited size contain message type SP identiﬁer CPA LB_List vector possibly integer values bounds 333 Pseudocode Fig 7 Main The pseudocode ConcFBs main procedure described Fig 7 It starts initializing agent creating Root_SP line 3 data structure hold search process created splitting domain initializing agent line 4 The initializing agent calls Init_SP function create search processes starts search line 5 The main loop line 6 continuously looks incoming messages line 7 dispatches according message type appropriate functions lines 819 Fig 8 Init_SP The Init_SP function described Fig 8 loops possible assignments domain line 1 Each value domain assigned different Search Process created unique SP_ID The generated SP contains single relevant value line 2 All SPs added list Root_SP data structure line 3 Assign_CPA function invoked multiple times SP Fig 9 Receive_CPA Upon receiving CPA message function Receive_CPA called In Receive_CPA agent creates new SP data structure SP_ID received CPA entire domain current agent line 1 A copy received CPA LB_List saved SP lines 23 current agents LB removed LB_List line 4 The removal agents LB LB_list crucial replaced later agents actual cost according assignment The newly created SP added list SPs maintained agent line 5 Assign_CPA called Fig 10 Receive_BT_CPA In Receive_BT_CPA agents need identify Search Process BT_CPA message sent This SP_List according ID retrieved message line 1 The current assignment agent speciﬁc Search Process removed domain lines 2 3 If domain SP exhausted Backtrack called Alternatively Assign_CPA called try assignment lines 47 cid2 Fig 11 Receive_LB_Request When agent responds LB_Request messages calculates lower bound respect CPA message line 1 Formally lower bound deﬁned LB mindDomain xi CPAvars d The lower bound minimum cost achieved summing constraints Costxa assignment agents domain given CPA This lower bound sent LB_Request message originator LB_Report message line 2 194 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 1 false 2 Initializing_Agent 3 4 5 Root_SP new SPSP_IDroot domain Root_SPsplits new Split_Set Init_SP 6 7 msg Get_Next_Msg switch msgtype 8 9 10 11 12 13 14 15 16 17 18 19 20 21 case CPA Receive_CPAmsg case BT_CPA Receive_BT_CPAmsg case LB_Request Receive_LB_Requestmsg case LB_Report Receive_LB_Reportmsg case Upper_Bound msgUB thisUB thisUB msgUB case Terminate true 22 return thisUB 1 1 domainsize 2 SPid new SPSP_IDi domaini Root_SPsplitsaddSPid Assign_CPASPid 3 4 Fig 7 Main Fig 8 Init_SP 1 SPid new SPmsgsp_id domain 2 SPidCPA msgCPA 3 SPidOrg_LB_List msgLB_List 4 SPidOrg_LB_ListremoveLB current agent 5 SP_listaddSPid 6 Assign_CPASPid Fig 9 Receive_CPAmsg 1 SPid SP_listgetmsgsp_id 2 ca SPidCurrent_Assignment 3 SPiddomainremoveca 4 SPiddomainisEmpty 5 6 7 BacktrackSPid Assign_CPASPid Fig 10 Receive_BT_CPAmsg A Netzer et al Artiﬁcial Intelligence 193 2012 186216 195 cid2 1 LB mindDomain 2 sendLB_Report msgorigin LB xi msgCPAvars Costxa d Fig 11 Receive_LB_Requestmsg 1 SPid SP_listgetmsgsp_id 2 SPidLB_Listmsgorigin msgLB 3 received LB_Report messages unassigned neighbors 4 SPidCPAcost SPidCurrent_Assignment_Cost CPA SPidCPA SPidCurrent_Assignment sendCPA Next_Agent CPA SPidLB_List cid2 SPidLB_Listi thisUB Receive_BT_CPAmsg Fig 12 Receive_LB_Reportmsg 5 6 7 8 Fig 12 Receive_LB_Report The Receive_LB_Report function collect LB_Report messages decide current assignment given Search Process violate UB When LB_Report messages received agent needs ﬁnd Search Process belongs line 1 The received LB entered LB_List appropriate SP new entry update previous LB agent line 2 If LB_Reports received speciﬁc SP unassigned neighbors line 3 Forward Bounding information received order decide current assignment extend CPA The cost CPA added current assignment Search Process sum Lower Bounds LB_List The CPA cost stands cost collected assigned agents current assignment cost cost added current agent sum LB_List lower bound cost added unassigned agents If sum costs smaller known Upper Bound line 4 CPA created adding current assignment Search Process CPA line 5 CPA message sent agent newly created CPA updated LB_List line 6 If hand calculated sum costs bigger known Upper Bound current assignment extend CPA solution Receive_BT_CPA called Fig 13 Assign_CPA The Assign_CPA function called agent tries assign new value given Search Process If domain speciﬁc Search Process value assign Backtrack called line 21 Otherwise best assignment picked domain lines 23 cost assignment calculated stored line 43 The cost assignment sum costs constraints assignment assignments CPA Formally Cost cid2 xi CPAvars Costxa assignment The cost CPA added current assignment cost sum LB_List compared known Upper Bound line 5 Note sum LB_List represents lower bounds unassigned agents respect CPA current agent assignment If sum costs larger equal Upper Bound assignment extend CPA better solution In case assignment removed domain speciﬁc Search Process line 6 If removal assignment exhausts domain Backtrack called line 8 Otherwise Assign_CPA called assign new value line 10 If sum costs smaller Upper Bound agent assignment assignment line 12 new Upper Bound In case new Upper Bound value broadcast agents line 14 Backtrack called If agent copy Org_Lb_List created line 17 request sent unassigned neighbors report Lower Bound CPA new assignment added lines 18 19 Note LB_Request needs sent unassigned neighbors unassigned agents unassigned agents neighbors current agent change Lower Bound current agent assignment Note LB_List initialized Org_LB_List Lower Bounds collected new assignment Lower Bound updates previous assignment current agent longer valid discarded Fig 14 Backtrack When agent decides backtrack Initializing Agent speciﬁc Search Process removed Root_SPsplits list line 2 If Search Processes ended line 3 search complete The current Upper Bound solution terminate message broadcast agents lines 36 If Initializing Agent BT_CPA message sent previous agent lines 8 9 3 Dynamic ordering assignments easily implemented calculating sorting storing assignments costs This requires minor additional computation improves performance 196 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 1 SPiddomainisEmpty 2 ca best assignment SPiddomain SPidCurrent_Assignment ca SPidCurrent_Assignment_Cost SPidCPAcost SPidCurrent_Assignment_Cost cid2 xi msgCPAvars Costxa cid2 ca SPidOrg_LB_Listi cid2 thisUB 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 SPiddomainremoveca SPiddomainisEmpty BacktrackSPid Assign_CPASPid current agent agent SPid thisUB SPidCPAcost SPidCurrent_Assignment_Cost BroadcastUpper_Bound thisUB BacktrackSPid SPidSP_List SPidOrg_SP_List foreach ai SPidCPAUnassigned_Neighbor sendLB_Request ai SPidCPA SPidCurrent_Assignment 20 21 BacktrackSPid Fig 13 Assign_CPASPid 1 Initializing_Agent 2 Root_SPsplitsremoveSPid Root_SPsplitsisEmpty Solution thisUB true BroadcastTerminate null 3 4 5 6 9 7 8 ai SPidCPALast_Assigned_Agent sendBT_CPA ai SPidsp_id Fig 14 BacktrackSPid 34 ConcFB run trace We present detailed trace ConcFB simple DCOP problem presented Fig 1 Agents begin setting upper bound value All agents ﬁrst agent a1 remain idle await incoming messages Agent a1 begins generating distinct search processes assigns different domain value These Search Processes carry unique identiﬁer SP1 SP4 example Fig 15a agents Agent a1 assigns value search process broadcasts LB_Request message agents a2 a4 total 12 messages message agent search process Note domain a1 includes single distinct value SP agent a1 distinct assignments assignment SP Agents receiving requests compute minimal cost assignment reply value LB Thus agent a2 respond 2 message ID SP1 respond 0 different message receiving a1s message ID SP4 In contrast agent a4 return 0 SPs constraint a1 It important note ConcFB proceeds synchronous steps guarantee timing messages computation agents In SPs a1 receive LB replies neighbors proceed onward bounds received SPs Let assume a1 received following ﬁve messages4 cid3SP1 cid3a2 L B 2cid4cid4 cid3SP2 cid3a2 LB 3cid4cid4 cid3SP2 cid3a3 LB 2cid4cid4 cid3SP2 cid3a4 LB 0cid4cid4 message cid3SP4 cid3a3 LB 0cid4cid4 depicted Fig 15b 4 We use following format messages cid3SPid cid3sender valuecid4cid4 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 197 Four SPs act nonintersecting parts search space Each SP executes instance SFB b An LB request agent SP At point agents a3 a4 received request context SP2 c When new upper bound value shared agents apply SPs Fig 15 Run trace ConcFB At point agent a1s SP2 computes sum lower bounds 5 lower initial upper bound sends SP2 CPA agent a2 Having received CPA SP2 agent a2 attempts extend Unlike previous case agent a2 2 domain value SP choose It assign second best 2 broadcast LB requests a3 a4 note background agents responding agent a1s LB request Speciﬁcally agent a2 respond requests SPs omitted sake clarity Agents a3 a4 respond a2s request sending cid3SP2 cid3a3 LB 3cid4cid4 cid3SP2 cid3a4 LB 1cid4cid4 As resulting cost lower initial upper bound CPA passed onward It easy point SP2 execution proceed new upper bound 7 reached agent a4 This information broadcast agents Fig 15c execution SP2 continues At point let focus progress SP1 assuming execution SPs agents continues Assume point a1 received following LB replies cid3SP1 cid3a2 LB 2cid4cid4 cid3SP1 cid3a3 LB 3cid4cid4 cid3SP1 cid3a4 LB 0cid4cid4 The resulting joint cost 5 lower current upper bound 7 a1 sends SP1 CPA agent a2 The agent choose best assignment 2 send LB request agents a3 a4 Their responses cid3SP1 cid3a3 LB 3cid4cid4 cid3SP1 cid3a4 LB 1cid4cid4 result cost equal bound combined constraint cost a1 a2s assignments Agent a2 attempts assignment a2 1 resend LB requests unassigned agents a3 a4 Again bound breached backtrack message generated agent a2 a1 Agent a1 receives backtrack message initializing agent terminates SP1 removing split set A similar interaction concurrently occurs SPs SP3s search space pruned agent a2 bound value 7 SP2 fails locate bound lower 7 SP4 ﬁnds optimal solution cost 3 198 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 4 Correctness ConcFB To prove correctness ConcFB ﬁrst prove terminates prove termination value upper bound UB cost optimal solution To prove ConcFB terminates needs prove endless loop To consider algorithms states s S S cid3S1 S2 Skcid4 Cartesian product SP states A state si S includes agents current assignment domain The following lemma proves state generated Lemma 1 Unique states A state S ConcFB repeated Proof Begin noting following simple observation Observation 1 Any states different SPs si S s j S j cid10 j identical Observation 1 stems fact partitioning scheme ConcFB discussed Section 32 generates disjoint search spaces assigned different SPs In words domain initializing agent divides different nonintersection parts single values domain line 2 Init_SP means assignment agent a1 si s j value The observation implies needs consider states individual SPs prove lemma That given SP SFB algorithm repeats states Consider speciﬁc search process SPid Assume negation ai highest priority agent ﬁrst agent order assignments acting repeats previously visited state Speciﬁcally repeating state means partial assignment CPA duplicated Any new assignment added CPA selected Assign_CPA function This function invoked following functions Init_SP This function invoked beginning ConcFBs run This means prior CPA existed SPid sibling SPs matter Hence conclude SPids CPA identical CPA generated search process SP j However Init_SP assigns single unique value SPs domain line 2 Init_SP new CPA values added based current domain line 2 Assign_CPA conclude CPA generated SPid different SP j contradiction false assumption Receive_CPA The Receive_CPA function invoked higher priority agent j j sends CPA message ai line 10 Main line 6 Receive_LB_Report A duplicated CPA generated ai includes assignments variables ﬁrst j assignments The fact Receive_LB_Report trigger forward sent CPA message turn triggered messages received following line 18 Assign_CPA implies agent j generate duplicate CPA Since Receive_CPA change domain value assignment value state sid contradicts assumption ai highest priority agent repeats state Receive_BT_CPA If Assign_CPA invoked following line 7 Receive_BT_CPA lines 14 executed Specif ically line 3 removes assignments current domain SPid adding new ones As result line 2 Assign_CPA generate duplicate CPA value returned domain SPid This occurs line 1 Receive_CPA contradicts assumption cid2 Theorem 1 Termination Every run ConcFB terminates Proof A DCOP search algorithm terminate following conditions hold The number states goes ﬁnite It examines state fall endless loops The algorithm maintains progress That moves state ﬁnite time The ﬁrst condition trivially met deﬁnition DCOP Section 21 second immediately follows Lemma 1 Following Observation 1 suﬃces examine progress single SP condition holds Consider state sa S This state proceed state sb S Assign_CPA Re ceive_BT_CPA functions executed assignment change domain value removal agent Let ai agent sa add assignment CPA If ai ﬁrst agent commenced run Init_SP main function turn invoke Assign_CPA Assign_CPA broadcast requests unassigned agents line 19 Assign_CPA A Netzer et al Artiﬁcial Intelligence 193 2012 186216 199 request arrive add assignment CPA line 5 Receive_LB_Report state sb execute Receive_BT_CPA line 8 Receive_BT_CPA remove offending value domain line 3 Receive_BT_CPA result SP state sb Otherwise ai assigns value SPi s partial assignment line 5 Receive_LB_Report It proceed send CPA agent j This message eventually received agent j Receive_CPA line 10 Main After updating relevant SP data structures Assign_CPA executed This result different outcomes 1 A new assignment examined j result breach upper bound line 5 Assign_CPA The agent remove offending value line 6 change current SPs state 2 If agent agent Backtrack function invoked line 15 A BT_CPA message sent agent ai line 9 Backtrack invoke Receive_BT_CPA line 12 Main As function remove assigned value ai domain line 3 Receive_BT_CPA SPs state change sb 3 The CPA potential assignment broadcast unassigned agents j resumes Main function Unas signed agent receive new LB_Request message calculate LB value send j removing value domain changing assignment That changing SPs state Agent j receive peers replies aggregated cost unassigned agents calculated agent update current assignment Receive_LB_Report line 5 execute Receive_BT_CPA remove potential assignment domain In case result new state cid2 Next needs prove value returned ConcFB completion optimal cost assign ment Theorem 2 Optimality Upon termination cost upper bound local variable UB equal minimal cost assignment Proof ConcFB termination initiated ﬁrst agent lines 56 Backtrack function The termination message broadcast SPs exhausted line 3 Backtrack types messages generated UB reset SPs exhausted To prove optimality verify new complete assignment minimal cost generated recorded valid assignments pruned search An upper bound cost valid corresponding assignment includes agents cost lower current upper bound This occur unassigned agent successfully assigns new value lower cost Lines 1114 Assign_CPA function manage functionality If condition lines 7 8 function hold new upper bound recorded agent agents notiﬁed consequently record value lines 1719 Main To prove valid values pruned examine cases agent changes CPA skips value A value skipped line 5 Assign_CPA result line 4 Receive_LB_Report In cases value skipped combined cost CPA current assignment minimal cost future unassigned agents greater current cost UB Clearly cost current assignment lead solution lower cost UB termination value skipped Let consider cases lead change value Assign_CPA invoked line 4 Init_SP Since initial assignment SP prior value existed risk prunes search space Receive_CPAs line 6 invokes Assign_CPA In case agent Ai receives new CPA higher priority agent change value predecessors Since Ai pick assignment point assignment lose potential solutions Assign_CPA called line 7 Receive_BT_CPA result lower priority agents message When BT_CPA sent lower priority agent conclude entire subspace originating current CPA fully explored result change value result lost solutions Assign_CPA called line 7 Receive_BT_CPA result message agent line 15 Assign_ CPA followed line 9 Backtrack This case occur agent reaches CPA examine cost assignments Since cost CPA examined recorded new UB value risk pruning solutions Note similar situation occur line 8 Receive_LB_Report However considered value skipping condition discussed Finally pay attention situations CPA discarded This occur SP fully explored exhausted line 2 Backtrack However CPA discarded SP belonged exhausted subspace skipped pruned 200 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 CPA assignments SP static lexicographic ordering b CPA assignments SP random ordering Fig 16 Work load distribution random ordering static lexicographic ordering In conclusion value skipped changed CPA discarded better solutions lost Therefore termination ConcFB reports lowest possible cost cid2 5 Enhancements This section describes enhancements basic ConcFB algorithm Dynamic variable orderings dynamic splitting introduced pseudocode incorporate enhancements presented 51 Variable ordering Dynamic reordering shown signiﬁcantly boost performance DCSP algorithms However limited number works discussing dynamic reordering DCOPs notable exception 24 focuses reordering pseudo tree based algorithms applied DCOPs The present paper presents dynamic variable ordering heuristics utilize synchronous search carried SP One heuristic aimed improving concurrency algorithm designed improve algorithms pruning ability use fail ﬁrst heuristic 511 Random ordering To illustrate motivation random variable ordering examine work load distribution agents ConcFB run Fig 16a shows histogram number CPA assignments agent run ConcFB Search Processes agents It clear assignments agents 510 The ﬁrst agents little work located higher levels search tree Agents 1012 little work effective pruning To achieve balanced work load distribution agent use random ordering scheme The order variables search process Initiating Agent randomly selected The change needed pseudocode Receive_LB_Report function random selection agent inserted line 6 Fig 17 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 201 1 SPid SP_listgetmsgsp_id 2 SPidLB_Listmsgorigin msgLB 3 received LB_Report messages unassigned neighbors 4 cid2 SPidCPAcost SPidCurrent_Assignment_Cost CPA SPidCPA SPidCurrent_Assignment Next_Agent random unassigned agent sendCPA Next_Agent CPA SPidLB_List SPidLB_Listi thisUB Receive_BT_CPAmsg Fig 17 Receive_LB_Reportmsg random ordering 5 6 7 8 9 Fig 16b shows setup run random variable ordering One clearly balanced distribution agents 512 Fail ﬁrst ordering A different approach dynamic ordering use reordering purpose improving concurrency order improve pruning One use fail ﬁrst heuristic aimed reaching Upper Bound soon possible A naive approach fail ﬁrst variable ordering set agent ordering agent reported LB value maximal However ordering agents fashion expected change performance The reason unassigned agents guaranteed receive LB values received agent selecting order Hence expected impact distinguished based information To asses possible impact future agents total cost consider unassigned agents average cost unassigned agents That let agent reporting LB calculate additional average cost assuming LB assignment Let Xi variable owned agent Ai received LB_Request message let Xlb assignment j assignment We write Dom X j produced current LB LB_Report message X j represents variable j X specify size complete domain variable j Agents precedence ordering based calculated heuristic value cid2 h Xi CPA cid3 X j CPA aDom X j CostX DomX j j Xlb h Xi CPA sums average costs unassigned variables respect Ai s LB assignment This value sent Lower Bound Note average cost agent agents calculated preprocess stage polynomial time Whenever agent receives LB_Report message registers h values lower bound When agent selects agent selects highest h value Figs 18 19 code updates needed fail ﬁrst heuristic dynamic ordering 513 Correctness ConcFB variable ordering Theorem 3 ConcFB variable ordering terminates complete Proof As initializing agent partitions search space disjoint parts As result needs consider correctness single SP Observation 1 We use induction number agents prove ConcFB variable ordering maintains correctness rely fact highest priority agent ordering remains initializing agent The base case induction includes single agent In case ordering static search complete terminates Next assume induction assumption true DCOP k n agents consider DCOP n agents Since initializing agent change position ordering assign value send unassigned agents The remaining DCOP n 1 agents initial order set initializing agents choice By induction assumption remaining DCOP complete terminate That new upper bound shared agents SPs termination result BT_CPA message sent initializing agent The initializing agent attempt different assignment invoke Assign_CPA line 7 Receive_BT_CPA backtrack end search SP lines 16 Backtrack Whenever new successful assignment initializing agent send unassigned agents As remaining DCOP n 1 agents applying search complete terminates This number times process repeats exactly based number values initializing agents domain process end ﬁnite 202 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 cid2 1 LB mindDomain xi msgCPAvars Costxa 2 dlb assignment produced LB d cid2 cid2 3 h X j CPA aDom X j Cost Xa Dom X j j Xlb 4 sendLB_Report msgorigin LB h Fig 18 Receive_LB_Requestmsg heuristic ordering 1 SPid SP_listgetmsgsp_id 2 SPidLB_Listmsgorigin msgLB 3 SPidh_Listmsgorigin msgh 4 received LB_Report messages unassigned neighbors 5 cid2 SPidCPAcost SPidCurrent_Assignment_Cost CPA SPidCPA SPidCurrent_Assignment Next_Agent agent highest h sendCPA Next_Agent CPA SPidLB_List 6 7 8 9 10 Receive_BT_CPAmsg Fig 19 Receive_LB_Reportmsg heuristic ordering SPidLB_Listi thisUB Total number assignments SP b Total number upper bounds reached SP Fig 20 Work load search process time Its correctness stems fact phase minimal cost solution includes agents broadcast agents cid2 52 Dynamic splitting Fig 20a presents assignments statistics 4 SPs created run time ConcFB It includes total number CPA assignments SPs There 14 variables example average 4 neighbors variable domain size 4 One distribution CPA assignments uniform search processes In example SP2 half number CPA assignments SP1 This result SP2 exhausting subspace earlier SPs lowering degree concurrency algorithm Spawning SPs search subspace SP1 balance work load search processes ensure SPs active time search To increase level concurrency dynamic split request passed agent spawned current SP turn partitions existing SP5 Such dynamic splitting heuristic DCSP case described 31 In 31 heuristic measures number assignments given SP value exceeds given threshold split requested However DCOP setting dynamic splitting focus search efforts promising sub spaces likely produce Upper Bounds Fig 20b presents distribution number Upper Bounds SP runtime example As seen number Upper Bounds vary signiﬁcantly SPs In case SP1 reaches upper bounds partitioning smaller subspaces expected improve overall pruning algorithm 5 This corresponds OR node represents split point original OR tree A Netzer et al Artiﬁcial Intelligence 193 2012 186216 203 Split depth n n 1 n 2 n 3 n 4 n 5 n 6 n 7 n 8 n 14 D 5 k 4 Max SPs 18 40 92 230 646 2049 6679 15 125 22 151 NCCC 474 936 471 936 453 880 453 907 459 084 474 936 483 030 491 874 495 933 n 10 D 10 k 4 Max SPs 21 42 88 228 785 1896 NCCC 201 010 202 593 199 194 195 304 202 718 210 025 Fig 21 The maximal number concurrent SPs number NCCC function split depth request averaged 50 executions n agents domain size D k neighbors agent While numerous partitioning heuristics propose dynamic split mechanism agents residing lower parts search tree send split requests search process reaches The split request sent agent originated search process asking resplit This heuristic aimed focusing search efforts promising parts SP implied Fig 16a Determining threshold depth sending split request signiﬁcant impact number search process In extreme cases splitting result thrashing increased memory load agents The impact split depths value maximal number concurrent SPs total number NCCCs presented Fig 21 We SPs concurrent given moment SPs active The table measures split depth relative total number agents split depth n means split request generated agent The table shows exponential increase maximal number concurrent SPs split depth decreases number NCCCs minimal split depths roughly n 3 To understand results ﬁrst consider split depth values greater n 3 An increase split depth decreases maximal number concurrent SPs concurrency general The number NCCCs increase work simultaneously In contrast lowering split depths value number concurrent SPs dramatically increases agent process requests multiple relatively shallow SPs These requests interfere agents progress new solutions lie search tree result number NCCCs increase 521 Integrating dynamic splitting ConcFB To identify originator Search Process track search processes unique SP_ID constructed list pairs That SP_ID cid3Agent Countercid4 Agent ID creating agent Counter incremented search process spawned agent The originator agent search process retrieved looking Agent ﬁeld SP_ID To request dynamic splitting new type message Split_Request A split request sent agent asking split speciﬁc Search Process The main function updated respond type message receiving Split_Request calls new function Receive_Split_Request lines 17 18 Fig 22 In Receive_Split_Request Fig 23 agent retrieves Search process needs split line 1 If relevant SP domain value assigned line 2 current search process split A new SP_ID created line 3 new SP created new SP_ID half splitting Search Process domain line 4 The new SP added father SP Splits list line 5 added agent SP_list line 6 Assign_CPA called new SP line 7 If current domain father SP small split current agent deep search tree line 9 Split_Request sent agent trying split SP deeper search tree line 10 In addition new Receive_LB_Report function Receive_CPA needs updated order support dynamic splitting The updated routine presented Fig 24 In line 5 newly created search process adds splits list In lines 7 8 depth search tree checked given depth reached Split_Request sent A good heuristic target depth experimentally quarter search tree The change required basic ConcFB pseudocode order support dynamic splitting crucial maintaining correctness The Backtrack routine updated sure Search Processes spawned given Father_SP ended search Father_SP backtrack Fig 25 The Father_SP backtracked SP located line 8 The backtracked SP removed father splits list line 9 list Father_SP backtracks 522 Correctness ConcFB dynamic splitting Theorem 4 ConcFB dynamic splits terminates complete 204 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 1 false 2 Initializing_Agent 3 5 4 Root_SP new SPSP_IDroot domain Root_SPsplits new Split_Set Init_SP 6 7 msg Get_Next_Msg switch msgtype case CPA Receive_CPAmsg case BT_CPA Receive_BT_CPAmsg case LB_Request Receive_LB_Requestmsg case LB_Report Receive_LB_Reportmsg case Split_Request Receive_Split_Requestmsg case Upper_Bound msgUB thisUB thisUB msgUB case Terminate true 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 4 5 6 7 24 return thisUB Fig 22 Main dynamic splitting 1 spcurrent SP_listgetmsgsp_id 2 spcurrentCurrent_DomainSize 1 3 SP_ID new SP_IDserial counter spnew new SPSP_ID spcurrent Current_DomainSplit_Domain spcurrentsplitsaddspnew SP_listaddspnew Assign_CPAspnew 8 9 Not agent 10 send Split agent Fig 23 Receive_Split_Requestmsg dynamic split 1 SPid new SPmsgsp_id domain 2 SPidCPA msgCPA 3 SPidOrg_LB_List msgLB_List 4 SPidOrg_LB_ListremoveLB current agent 5 SPidsplits msgsp_id 6 SP_listaddSPid 7 SPidCPANumber_Of _Assigned_Agents Split_Depth 8 9 Assign_CPASPid send Split msgsp_idoriginator Fig 24 Receive_CPAmsg dynamic split Proof Proving ConcFB dynamic splits maintains correctness requires proving union subparts equals entire SPs space search subparts SP complete terminate algorithm conclude search original SP subparts conclude It easy split request partitions search space disjoint parts include values splitting agents current domain line 4 Receive_Split_Request A Netzer et al Artiﬁcial Intelligence 193 2012 186216 205 1 Initializing_Agent 2 Root_SPsplitsremoveSPid Root_SPsplitsisEmpty solution thisUB true BroadcastTerminate null Father_SP father SP SPid Father_SPsplitsremoveSPid Father_SPsplitsisEmpty ai SPidCPALast_Assigned_Agent sendBT_CPA ai SPidsp_id 3 4 5 6 9 10 11 12 7 8 Fig 25 BacktrackSPid dynamic split To address second point generating subSPs different values domain original SP creates disjoint search subspaces cf Observation 1 Next following correctness SFB search individual subSPs complete terminates A complete search subSP insuﬃcient To maintain correctness ConcFB algorithm clude search SP subsearches conclude The dynamic split version ConcFB achieves requiring subSPs completed prior sending BT_CPA message assigned agent lines 1012 Fig 25 Thus agent executes Backtrack function Fig 25 removes current SP splits list contain existing SP agent receive split request earlier stage hold messages predecessor subSPs terminated This guarantees search process thoroughly examined report acknowledging fact sent cid2 6 Experimental evaluation The experimental evaluation divided subsections The ﬁrst subsection deals comparison ConcFB state art DCOP algorithms The second explores performance network environment cost communication signiﬁcantly higher cost computation An evaluation concurrent search approach detailed subsection compare ConcFB concurrent search version SBB Finally analyze ConcFB quantify impact component algorithm In experiments evaluated ConcFB variant included dynamic fail ﬁrst reordering dynamic splitting split depth heuristic set n 2 61 Algorithm performance Two performance measures routinely evaluate DCOP algorithms runtime form NonConcurrent Constraints Checks NCCCs 32 network load measured total number messages sent 1528 We focus present evaluation comparison ConcFB leading DCOP algorithms BnBADOPT 26 AFBCBJ 9 ODPOP 23 BnBADOPT 11 recent improvement BnBADOPT removes redundant messages note BnBADOPTs computational effort terms NCCCs exactly BnBADOPT Although DPOP solving DCOPs ﬁnd impractical problems experimented mainly exponential sized messages As discussed Section 22 ODPOP 23 provides remedy exponential sized message problem DPOP regular DCOPs The main computational operation ODPOP comparison combinations assignments sent computing agent offspring pseudo tree 23 This operation performed agent order ﬁnd assignment optimal respect assignments ancestors The introduction ODPOP requires run time experimental evaluations given terms nonconcurrent logical operations NCLO For ODPOP compatibility checks BnBADOPT ConcFB constraints checks In recent paper BnBADOPT shown superior ADOPT NCBB 26 The present evaluation uses BnBADOPT DP2 preprocessing phase h values 1 Synchronous branch bound algorithm SBB best value assignment reference algorithm The AFB variant evaluation best known AFBCBJ In AFBCBJ backjumps offending agent instead simple backtrack steps This provides potential speedup original algorithm 9 Following 26 applied Distributed DFS protocol pseudo tree based algorithms Communication overhead protocol added comparison 206 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 Our evaluation setup included problem types Graph Coloring Random DCOPs sensor networks In setup 50 instances generated set parameter conﬁguration reported results averaged runs Fig 26 A sensor network example Graph Coloring This setup reconstructs Graph Coloring tests presented 26 In setup vertex cor responds agent An edge vertices corresponds constraint Constraint costs randomly uniformly selected range 0 10 000 vertex degree set 3 randomly selected The evaluation included different setups number agents varied setups 5 15 Each agents domain include possible values colors All problems instances connected graphs Random problems Random DCOPs include set agents randomly constrained This setup includes unstructured problems denser Graph Coloring problems speciﬁed constraints costs uniformly sampled range 0 10 000 The number agents graph density agents domain sizes cost ranges varied assess algorithms robustness different setups As problems instances include connected graphs Sensor networks The sensor network setup models target tracking 2616 Sensors jointly attempt track targets taking account availability sensors number sensors required track target sensors spatial conﬁguration In setup agents targets domains time slots tracked constraint adjacent targets The cost assigning time slot target assigned adjacent target inﬁnity suﬃciently large number sensor track targets time slot Similar 26 cost tracking target range 0 100 cost target untracked time slot 100 Fig 26 depicts sensor network example In example 6 targets tracked grid 3 4 sensors Targets constrained adjacent targets In evaluation setup number targets varied range 5 14 grid 3 x sensors number sensors varied accommodate number targets Fig 27 presents performance measurements Graph Coloring setup One ConcFB outperforms algo rithms ODPOP metrics It twice eﬃcient terms NCLOs provides signiﬁcant improvement terms messages BnBADOPT BnBADOPT ConcFB outperforms AFBCBJ order magni tude metrics ODPOP hand trades high computational effort lower network load Thus uses messages run time terms NCLOs times slower The results Fig 27a accordance reported 26 BnBADOPT Since BnBADOPT messaging scheme similar ADOPT 21 resulting high number messages surprising 9 Our results reaﬃrms low number messages ODPOP It indicates high computational effort associ ated process combining assignments trade computational effort network load The initial experiments conducted Random DCOPs introduced dramatic increase NCLO count ODPOP As problems constrained ODPOPs performance rapidly degraded comparison algorithms Fig 28 presents small random problem 8 variables domain size 4 As number constrained neighbors agent increased 3 5 number NCLOs required ODPOP rapidly increased Applying ODPOP larger problems return reasonable time removed sized Random DCOP setup Fig 29 presents results random problems 12 agents domain size 5 The number constrained neighbors agent varied setups 3 7 In setup NCLO measure actually equivalent NCCC algorithms One ConcFB outperforms BnBADOPT 2 3 orders magnitude AFBCBJ BnB ADOPT 1 2 orders magnitudes metrics These experiments BnBADOPT BnBADOPT scale ConcFB AFBCBJ higher density problems To understand difference performance examine important aspects BnBADOPT A Netzer et al Artiﬁcial Intelligence 193 2012 186216 207 Fig 27 Experimental results Graph Coloring setup 5 15 agents domain size 3 density value 3 Fig 28 Experimental results small random problems 8 agents domain size 4 varying number neighbors Both rely pseudo tree arrangement agents As density value increases wide pseudo tree likely result concurrency level decreases BnBADOPTs inability reuse bounds In algorithms CPA change violate descendants assignment bounds valid As constraint density increases probability CPA change violate constraint decreases bounds recalculated The relative robustness ConcFB changes problem parameters demonstrated Figs 30 31 In experiments averaged performance ConcFB BnBADOPT AFB SBB compared problems 12 208 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 Fig 29 Experimental results random problems 12 agents domain size 5 varying number neighbors agents 4 neighbors varying domain sizes costs structure In ﬁrst setup domain size varied range 3 8 Fig 30 second set 5 costs uniformly selected range 0 x x 1 10 100 1000 10 000 Fig 31 The results clearly validate ConcFBs superiority state art algorithms ConcFBs signiﬁcant improvement algorithms NCLOs number messages maintained presence changes Fig 32 presents performance ConcFB SBB BnBADOPT AFB function number targets tracked sensor network problem These results consistent evaluation setups reaﬃrming advantage ConcFB holds algorithms All runtime measurements DCOP algorithms use nonconcurrent metric NCCCs NCLOs taking account concurrency agents computations However pure measures count steps nonconcurrent computation inﬂuenced details implementation In order provide insight cost agents actions common logical operation example operations complex data structures CPU runtime measured experiments Fig 33 presents total CPU run time ConcFB SBB BnBADOPT AFB Although experiments conducted platform 4 Cores Intel i5 29 GHz 4 GB RAM 64 bits Windows 7 measuring relative performance helps reduce potential effects hardware evaluation The results indicate total time required BnBADOPT relatively higher algorithms One possible explanation computational overhead involved processing messages priority merges measured NCLOs Pruning irrelevant messages BnBADOPT reduce computational overhead An alternative explanation results high concurrency level BnBADOPT versions results multiple computations carried time large thread management overhead increase CPU run time A Netzer et al Artiﬁcial Intelligence 193 2012 186216 209 Fig 30 Experimental results random problems 12 agents 4 neighbors domains sizes 62 Measuring performance high latency networks In realistic settings communication time dominant computation time In settings appropriate evaluation metric number nonconcurrent steps NCSteps This metric details length longest chain messages agents 926 Fig 34 presents number NCSteps performed SBB AFB BnBADOPT BnBADOPT ConcFB In graph coloring setting Fig 34a BnBADOPT ODPOP ConcFB number NCSteps comparable larger problems higher density values ConcFBs longest chain messages order magnitude shorter leading algorithms Fig 34b It noted problems ODPOP failed complete reasonable time omitted cf Fig 28 One BnBADOPT improvement BnBADOPT consistent improvement total number message Fig 27b Fig 29b In contrast despite SBBs signiﬁcantly lower number messages compared BnBADOPT BnBADOPT Fig 29v outperformed BnBADOPT terms NCSteps This fact SBB operates synchronous sequential manner BnBADOPT BnBADOPT capable sending messages concurrently 63 Evaluating concurrent search We proceeded evaluate concurrent search approach comparing ConcFB SBB concurrent search implementation We extended Synchronous Branch Bound algorithm multiple instances al gorithm executed search process Each search process applied different random static ordering resulting algorithm referred ConcSBB The performance evaluation SBB ConcFB ConcSBB split depth heuristic set n presented Fig 35 Each data point represents averaged results 50 random problems 12 agents domain size 5 varying number neighbors 210 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 Fig 31 Experimental results random problems 12 agents domain size 5 4 neighbors In problems integer cost ranges varied interval 0 x x 1 10 100 1000 10 000 Not surprisingly ConcFB outperforms ConcSBB measures roughly orders magnitude ConcSBBs perfor mance signiﬁcantly better SBB terms NCLOs terms network load This point large number messages generated ConcSBB inconsistent improvement SBB reveals intricate relation concurrent search underlying algorithm applied SP In setup majority messages extension CPA backtracking messages SBB ConcSBB These message types correlated covered parts search area An equal messages implies average ConcSBB covers percentage search space SBB The improvement ConcSBBs NCLO SBB demonstrates ability concurrently cover space Note despite introduction multiple upper bounds different search processes concurrent search algo rithm necessarily cover smaller parts search space This unknown distribution costs upper bounds search space It worth noting unlike ConcFB ConcSBB susceptible search process thrashing applying split depth heuristic presented Section 52 The limited pruning ability ConcSBB results signiﬁcantly assignments lower parts search tree As result number split requests ConcSBB expected substantially grow split depth decreased presented Fig 36 64 Analysis ConcFB Our analysis ConcFBs components contribution yielded variants algorithm FB A single synchronous forward bound search process No concurrent search static lexicographical ordering No dynamic splitting A Netzer et al Artiﬁcial Intelligence 193 2012 186216 211 Fig 32 Experimental results sensor network problem varying number tracked targets Fig 33 CPU run time random problems 12 agents domain size 5 varying number neighbors ConcFBLO A multiple search process forward bounding search algorithm lexicographical ordering No dynamic splitting variant FBDR Similar FB heuristic fail ﬁrst dynamic reordering agents ConcFBDR A multiple search process forward bounding search algorithm heuristic fail ﬁrst dynamic reorder ing No dynamic splitting variant ConcFBFull A fully featured ConcFB algorithm 212 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 Fig 34 The number NCSteps performed graph coloring random b problems These variants tested larger random problems 15 variables domain size 5 10 neighbors agent Constraint costs uniformly sampled range 0 10 000 50 instances generated set parameter conﬁguration reported results averaged runs Fig 37 presents difference performance ﬁve ConcFB variants One dynamic ordering improves NCCC count FB factor Adding additional concurrent search processes improves NCCC performance factor lexicographical ordering dynamic reordering 10 percent gained dynamic splitting Similar trends observed network load presented Fig 37b One total number messages sent FB decreases dynamic ordering introduced roughly factor NCCCs This indicates fail ﬁrst dynamic ordering heuristic improves algorithms performance increased pruning necessarily increased concurrency When comparing total number messages multiple search processes variants single search process little improvement despite improved NCCC count factor 2 This implies concurrent search ConcFB improves NCCC count increasing concurrency computation reduce total computation performed One dynamic reordering heuristic Section 512 introduces signiﬁcant improvement naive Synchronous Forward Bounding algorithm Fig 38 presents comparison SFB dynamic reordering FBDR SBB ConcFB BnBADOPT AFB As experimental setup included random problems 12 agents domain size 5 varying number agents FBDR provides signiﬁcant improvement state art algorithms In comparison ConcFB FBDR generates roughly number messages signiﬁcantly NCLOs This understood realizing ConcFB FBDR share powerful pruning abilities cover similar search space The introduction SP splitting ConcFB results greater concurrency fewer NCLOs comparison FBDR accordance difference SBB ConcSBB discussed Section 63 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 213 Fig 35 Experimental results random problems 12 agents domain size 5 varying number neighbors Split depth Max SPs n 1161 n 1 22 529 n 2 134 534 n 3 243 467 n 4 296 046 n 5 308 274 n 6 316 837 Fig 36 The maximal number concurrent SPs ConcSBB function split depth request 12 agents domain size 5 4 neighbors agent Fig 37 ConcFb analysis 214 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 Fig 38 Performance SFB dynamic reordering FBDR problems 12 agents domain size 5 varying number neighbors Fig 39 Performance ConcFB different ordering scheme problems 15 agents domain size 5 10 neighbors We analyzed empirical impact chosen dynamic ordering heuristic respect static lexi cographical ordering random dynamic ordering The evaluation included ConcFB static lexicographical ordering ConcFBLO dynamic fail ﬁrst ordering heuristic described Section 512 ConcFBDR dynamic random ordering ConcFBRR 50 instances random problems 15 agents domain size 5 10 neighbors agent examined results evaluation presented Fig 39 The results demonstrates impact dynamic ordering heuristics As demonstrated Fig 16b introduction random ordering balances load agents enables higher concurrency reduces number NCCCs A Netzer et al Artiﬁcial Intelligence 193 2012 186216 215 Nonetheless portion search space covered random ordering remains roughly covered lexicographical ordering version ConcFB number messages passed agents similar The proposed dynamic ordering attempts improve random ordering scheme guiding search promising parts search space This enables ConcFBDR better prune search results lower number NCCCs reduced network load 7 Conclusion The present paper presents ConcFB Concurrent Forward Bounding algorithm solving DCOPs ConcFB combines powerful techniques Concurrent search synchronized Forward Bounding The combined approach results algorithm characterized high degree concurrency capable rapid pruning search space Although DCOP algorithm applied individual search processes present work focuses SFB SFB important features suitable concurrent search powerful pruning abilities synchronous progress In particular feature guarantees split request received agent relevant systems overall state This necessarily case dealing asynchronous algorithms For example Asynchronous Forward Bounding BnBADOPT split request triggered agent holding invalid view current assignment In words partial assignment held agent requesting split outdated This raises signiﬁcant challenges application Concurrent Search asynchronous algorithms left open future research The present work demonstrates beneﬁts applying dynamic reordering DCOP algorithms Some work reordering pseudo tree based algorithms presented 24 However work specifying adapt asynchronous algorithms use time stamping mechanism AFB BnBADOPT This stems mechanisms reliance agents total order infer relation different time stamps point intend pursue future work To conclude beneﬁts proposed concurrent search approach threefold 1 The agents applying forward bounding disjoint parts problem share upper bound information multiple search processes 2 Each search process independent apply different search heuristics 3 Additional search processes easily added maintain preferred level concurrency Three enhancements basic ConcFB algorithm presented The ﬁrst enhancement introduces random ordering heuristic agents signiﬁcantly balances work load The second introduces fail ﬁrst heuristic DCOPs results signiﬁcant improvement algorithms pruning abilities Finally dynamic splitting ability spawn new search processes added shown improve ConcFBs performance ConcFB proved terminate optimal solution performance extensively evaluated An extensive set experiments structured unstructured problems evaluates ConcFBs performance state art DCOP algorithms Additionally new concurrent algorithm ConcSBB implemented provide insights workings concurrent search algorithm multiple Search Processes Measuring performance terms NCLOs NC Steps network load CPU time ConcFB shown outperform BnBADOPT BnBADOPT AFBCBJ ODPOP ConcSBB A second set experiments quantiﬁes gain different enhancements ConcFB algorithm pre sented It shown combination Fail First heuristic multiple search processes dynamic splitting scheme improve algorithms performance order magnitude References 1 Syed Muhammad Ali Sven Koenig Milind Tambe Preprocessing techniques accelerating DCOP algorithm ADOPT 4th International Joint Conference Autonomous Agents Multiagent Systems AAMAS05 Utrecht The Netherlands July 2005 pp 10411048 2 Ismel Brito Amnon Meisels Pedro Meseguer Roie Zivan Distributed constraint satisfaction partially known constraints Constraints 14 2008 199234 3 David A Burke Kenneth N Brown Using relaxations improve search distributed constraint optimisation Artiﬁcial Intelligence Review 28 2007 3550 4 Anton Chechetka Katia P Sycara Nocommitment branch bound search distributed constraint optimization 5th International Joint Confer ence Autonomous Agents Multiagent Systems AAMAS06 Hakodate Japan May 2006 pp 14271429 5 Rina Dechter Enhancement schemes constraint processing backjumping learning cutset decomposition Artiﬁcial Intelligence 41 3 1990 273312 6 Rina Dechter Constraint Processing Elsevier Morgan Kaufmann ISBN 9781558608900 2003 7 Rina Dechter Robert Mateescu ANDOR search spaces graphical models Artiﬁcial Intelligence 171 23 2007 73106 8 Eugene C Freuder Michael J Quinn Taking advantage stable sets variables constraint satisfaction problems 9th International Joint Confer ence Artiﬁcial Intelligence IJCAI85 Los Angeles USA 1985 pp 10761078 9 Amir Gershman Amnon Meisels Roie Zivan Asynchronous forward bounding Journal Artiﬁcial Intelligence Research 34 2009 2546 10 Tal Grinshpoun Amnon Meisels Completeness performance APO algorithm Journal Artiﬁcial Intelligence Research 33 2008 223258 11 Patricia Gutierrez Pedro Meseguer Saving redundant messages BnBADOPT 24th AAAI Conference Artiﬁcial Intelligence AAAI10 July 2010 pp 12591260 12 Katsutoshi Hirayama Makoto Yokoo Distributed partial constraint satisfaction problem 3rd International Conference Principles Practice Constraint Programming CP97 Linz Austria 1997 pp 222236 216 A Netzer et al Artiﬁcial Intelligence 193 2012 186216 13 Robert Junges Ana LC Bazzan Evaluating performance DCOP algorithms real world dynamic problem Proceedings 7th In ternational Conference Autonomous Agents Multiagent Systems AAMAS08 Estoril Portugal May 2008 ISBN 9780981738116 2008 pp 599606 14 Viliam Lisý Roie Zivan Katia P Sycara Michal Pechoucek Deception networks mobile sensing agents 9th International Conference Au tonomous Agents Multiagent Systems AAMAS10 Toronto Canada 2010 pp 10311038 15 Nancy A Lynch Distributed Algorithms Morgan Kaufmann ISBN 1558603484 1996 16 Rajiv T Maheswaran Milind Tambe Emma Bowring Jonathan P Pearce Pradeep Varakantham Taking DCOP real world Eﬃcient complete solutions distributed multievent scheduling 3rd International Joint Conference Autonomous Agents Multiagent Systems AAMAS04 New York NY USA 2004 pp 310317 17 Radu Marinescu Rina Dechter ANDOR branchandbound search combinatorial optimization graphical models Artiﬁcial Intelligence 173 1617 2009 14571491 18 Robert Mateescu Rina Dechter ANDOR cutset conditioning 19th International Joint Conference Artiﬁcial Intelligence IJCAI05 San Francisco CA USA 2005 pp 230235 19 Amnon Meisels Distributed Search Constrained Agents Algorithms Performance Communication SpringerVerlag ISBN 1848000391 2007 20 Amnon Meisels Igor Razgon Distributed forwardchecking conﬂictbased backjumping dynamic ordering Workshop Cooperative Solvers Constraint Programming CoSolv02 Ithaca NY USA 2002 21 Pragnesh Jay Modi WeiMin Shen Milind Tambe Makoto Yokoo ADOPT asynchronous distributed constraints optimization quality guarantees Artiﬁcial Intelligence 161 12 2005 149180 22 Adrian Petcu Boi Faltings A scalable method multiagent constraint optimization 19th International Joint Conference Artiﬁcial Intelligence IJCAI05 Edinburgh Scotland UK August 2005 pp 266271 23 Adrian Petcu Boi Faltings ODPOP An algorithm opendistributed constraint optimization 21st National Conference Artiﬁcial Intelligence 18th Innovative Applications Artiﬁcial Intelligence Conference AAAI06 Boston MA USA July 2006 pp 703708 24 MariusCalin Silaghi Makoto Yokoo Dynamic DFS tree ADOPTing 22nd AAAI Conference Artiﬁcial Intelligence AAAI07 Vancouver British Columbia Canada July 2007 pp 763769 25 Ruben Stranders Alessandro Farinelli Alex Rogers Nick R Jennings Decentralised coordination continuously valued control parameters maxsum algorithm Proceedings 8th International Joint Conference Autonomous Agents Multiagent Systems AAMAS09 Budapest Hungary May 2009 pp 601608 26 William Yeoh Ariel Felner Sven Koenig BnBADOPT An asynchronous branchandbound DCOP algorithm Journal Artiﬁcial Intelligence Research 38 2010 85133 27 Makoto Yokoo Distributed Constraint Satisfaction Foundations Cooperation Multiagent Systems SpringerVerlag ISBN 3540675965 2000 28 Makoto Yokoo Algorithms distributed constraint satisfaction problems A review Autonomous Agents MultiAgent Systems 3 2000 198212 29 Makoto Yokoo Edmund H Durfee Toru Ishida Kazuhiro Kuwabara Distributed constraint satisfaction problem Formalization algorithms IEEE Transactions Data Knowledge Engineering 10 1998 673685 30 Roie Zivan Amnon Meisels Dynamic ordering asynchronous backtracking DisCSPs 11th International Conference Principles Practice Constraint Programming CP05 Sitges Barcelona Spain October 2005 pp 3246 31 Roie Zivan Amnon Meisels Concurrent search distributed CSPs Artiﬁcial Intelligence 170 45 2006 440461 32 Roie Zivan Amnon Meisels Message delay DisCSP search algorithms Annals Mathematics Artiﬁcial Intelligence 46 2006 415439 33 Roie Zivan Amnon Meisels Dynamic ordering asynchronous backtracking DisCSPs Constraints 11 2006 179197 34 Roie Zivan Moshe Zazone Amnon Meisels Mindomain ordering asynchronous backtracking 13th International Conference Principles Practice Constraint Programming CP07 Rhode Island USA September 2007 pp 758772