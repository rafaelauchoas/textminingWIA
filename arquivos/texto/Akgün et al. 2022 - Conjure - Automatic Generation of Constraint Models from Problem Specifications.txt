Artiﬁcial Intelligence 310 2022 103751 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Conjure Automatic Generation Constraint Models Problem Speciﬁcations Özgür Akgün Ian Miguel Peter Nightingale b School Computer Science University St Andrews St Andrews Fife KY16 9SX UK b Department Computer Science University York Deramore Lane Heslington York YO10 5GH UK Alan M Frisch b Ian P Gent Christopher Jefferson r t c l e n f o b s t r c t Article history Received 22 November 2021 Received revised form 23 May 2022 Accepted 6 June 2022 Available online 9 June 2022 Keywords Constraint modelling Constraint programming Combinatorial optimization Constraint satisfaction problem When solving combinatorial problem formulation model problem critical eﬃciency solver Automating modelling process long expertise time required produce effective model given problem We method automatically produce constraint models problem speciﬁcation written abstract constraint speciﬁcation language Essence Our approach incrementally reﬁne speciﬁcation concrete model applying chosen reﬁnement rule step Any nontrivial speciﬁcation reﬁned multiple ways creating space models choose The handling symmetries particularly important aspect automated modelling Many combinatorial optimisation problems contain symmetry lead redundant search If partial assignment shown invalid wasting time consider symmetric equivalent A particularly important class symmetries introduced constraint modelling process modelling symmetries We modelling symmetries broken automatically enter model reﬁnement obviating need expensive symmetry detection step following model formulation Our approach implemented called Conjure We compare models produced Conjure constraint models literature known effective Our empirical results conﬁrm Conjure reproduce successfully kernels constraint models 42 benchmark problems literature 2022 The Authors Published Elsevier BV This open access article CC BY license httpcreativecommonsorglicensesby40 1 Introduction Eﬃcient decisionmaking central importance modern society It natural represent reason decisionmaking problems terms constraints For example scheduling football league constraints occur team play home away match assigned set oﬃcials oﬃcial team places team scheduled play consecutive away games Constraint programming 1 offers means solutions problems automatically Constraint Corresponding author caj21standrewsacuk C Jefferson ijmstandrewsacuk I Miguel peternightingaleyorkacuk P Nightingale Email addresses ozgurakgunstandrewsacuk Ö Akgün alanfrischyorkacuk AM Frisch iangentstandrewsacuk IP Gent httpsdoiorg101016jartint2022103751 00043702 2022 The Authors Published Elsevier BV This open access article CC BY license httpcreativecommonsorglicensesby40 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 1 2 3 4 5 6 7 8 9 language Essence 13 given w g s int1 letting Golfers new type size g s sched set size w partition regular numParts g partSize s Golfers forAll g1 g2 Golfers g1 g2 sum week sched toInttogetherg1 g2 week 1 Fig 1 An Essence problem speciﬁcation Social Golfers Problem Problem 10 CSPLiborg In golf club number golfers wish play g groups size s Find schedule play w weeks pair golfers play solving given problem proceeds phases First problem modelled set decision variables set constraints variables solution satisfy A decision variable represents choice order solve problem The domain potential values associated decision variable corresponds options choice In football league example decision variables match represent home away teams The second phase consists constraint solver ﬁnd solutions model assignments values decision variables satisfying constraints There typically possible models given problem model chosen dramatically affect eﬃciency constraint solving This presents obstacle nonexpert users diﬃculty formulating good correct model possible alternatives Modelling critical bottleneck process constraint solving considered key challenges facing constraints ﬁeld 2 It desirable automate constraint modelling far possible Several approaches taken automate aspects constraint modelling Some approaches learn models variously natural language 3 positive negative examples 46 membership queries equivalence queries partial queries 78 generalisation queries 9 ar guments 10 Other approaches include automated transformation mediumlevel solverindependent constraint models 1117 deriving implied constraints constraint model 1822 casebased reasoning 23 reﬁnement ab stract constraint speciﬁcations 24 languages ESRA 25 Essence 26 F 27 Zinc 2830 We focus reﬁnement approach user writes constraint speciﬁcation describing problem level abstrac tion modelling decisions In Section 8 discuss alternative approaches automated constraint modelling method This paper presents automated constraint modelling Conjure serves demonstrate eﬃcacy reﬁnementbased approach A problem input Conjure Essence abstract constraint speciﬁcation language Essences support abstract decision variables types set multiset relation function nested types set sets multiset relations allows problem speciﬁed committing constraint modelling decisions To illustrate consider fragment Essence speciﬁcation Social Golfers Problem 31 presented Fig 1 Given number weeks w number groups g group size s problem ﬁnd schedule play w weeks g s golfers divided g groups size s subject socialisation constraint golfers stipulates pair golfers play The Social Golfers Problem naturally conceived ﬁnding set partitions golfers subject constraints speciﬁed Essence single abstract decision variable presented ﬁgure variable sched Since abstract types supported directly constraint solvers1 Essence speciﬁcation transformed reﬁned constraint model Automating process presents considerable challenge contributions work meeting challenge Principal carefully designed rulebased architecture implemented Conjure reﬁne Essence speciﬁcation constraint model One key contribution Conjure reﬁne nested types resorting enumerating values inner type example reﬁning set sets integers enumerating possible values inner set This capability vital reﬁning Essence speciﬁcations use evaluation As demonstrate different rule application pathways produce different constraint models supporting automated model selection process possible alternatives This approach facilitates automated production channelled constraint models 32 single abstract decision variable reﬁned multiple ways Channelling constraints elegantly generated abstract decision variable A creating equality A A reﬁning different representations A ensuring representations abstract value solutions Channelled models previously created manually experts typically effort simplify statement problem constraints strengthen inference constraint solver reduce search A important contribution rulebased architecture treatment symmetry structurepreserving transformation In context constraint problem given solution problem instance obtain symmetric solution Symmetry lead redundant search constraint solver reaches dead end search 1 Set variables notable exception widely supported However solvers support set variables offer choice underlying representation set support nested sets 2 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 solution wasting time consider symmetric equivalent A particularly important class symmetries introduced constraint modelling process called modelling symmetries 3335 Modelling symmetries occur naturally abstract decision variables reﬁned constraint models As simple example consider representing set size n vector n variables constrained distinct values Without care introduce n symmetries set represented vector possible orders If elements set integers deep problem add model constraint integers appear vector increasing order However simple approach directly elements set example sets multisets As discuss rulebased architecture recognise modelling symmetries arise reﬁnement constraint model add symmetry breaking constraints deal complex symmetries type This obviates need expensive symmetry detection step following model formulation approaches 3638 When reﬁnement performed Conjure introduces symmetry symmetry broken consistently completely addition symmetrybreaking constraints In cases allows improved reﬁnement Essence expressions Furthermore symmetry breaking constraints added hold entire parameterised problem class captured Essence speciﬁcation single problem instance need employ theorem prover Our ﬁnal contribution empirical evaluation coverage model space provided Conjure In extensive set experiments wide variety problems substantial majority models crafted manually human experts automatically generated Conjure Essence speciﬁcations problems In addition present simple lightweight heuristic choosing models generated Conjure The CompactEP heuristic able select good model given problem speciﬁcation We evaluate accuracy CompactEP wide range problems Rather focusing runtime performance models particular solvers instance sets limited picture model quality performed qualitative comparison generated models previously published models Section 7 Our approach reﬁnement types expressions outsidein allows reﬁnement rules handle single layer type single operator time multiple types operators handled improve reﬁnement Quantiﬁed expressions handled generically way independent quantiﬁer separating gathering values quantiﬁed application quantifying operator Conjure designed extended types attributes operators future types including sequences added Essence ﬁrst release Conjure The work presented paper summarises extends ﬁfteen years work automated constraint modelling Our earliest work reﬁnementbased automated constraint modelling appeared 2002 2005 39 4224 We introduced Essence language 2005 4344 subject separate journal article 26 Following presentation initial prototypes 2445 ﬁrst version Conjure presented 2011 46 extended handle automated symmetry breaking 3435 presented Akguns thesis 47 Herein complete overview Conjure including recent advances 11 Contributions In summary main contributions follows Conjure unique reﬁning problem class speciﬁcations classlevel constraint models Multiple models generated Essence speciﬁcation following different rule application pathways Conjure able reﬁne nested abstract types example set sets integers enumerating possible values inner type example set integers Symmetry introduced reﬁnement broken consistently completely Conjure able generate channelled models representing abstract decision variable way elegant mechanism producing channelling constraints simple equality constraint Model selection achieved simple lightweight CompactEP heuristic shown select good models cases The evaluated comprehensively 42 problem classes CSPLib 48 demonstrating Conjure able generate models similar models literature produced experts 2 CONJURE Example This section illustrates operation Conjure simple problem speciﬁcation It exempliﬁes constructs input language Essence output language Essence Prime There large number reﬁnements applied transform Essence speciﬁcation concrete Essence Prime constraint model The goal example highlight important kinds reﬁnements generality We include forward references later sections appropriate 3 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 1 2 3 4 5 6 7 language Essence 13 given object new type enum given weight value function total object int1 given maxWeight int1 knapsack set object maximising sum knapsack valuei sum knapsack weighti maxWeight 21 The Knapsack Problem Essence Fig 2 An Essence speciﬁcation Knapsack Problem Fig 2 shows Essence speciﬁcation Knapsack Problem We chosen familiar problem illustrate basics reﬁnement The Knapsack speciﬁcation lack sophisticated features Essence nested types explain Conjure treats later sections Lines 23 specify problem class parameters enumerated type objects weight value item repre sented total functions maximum weight knapsack Line 5 speciﬁes single decision variable set objects placed knapsack Line 6 speciﬁes objective function maximise value collection items knapsack Finally line 7 speciﬁes capacity constraint Some features Essence function domains speciﬁcation supported conventional straint modelling languages Therefore need reﬁned use supported features like integer matrix domains Moreover problem constraints stated terms Essence domains need reﬁned accordingly Some reﬁnement steps simple replacing enumerated domains isomorphic integer domains Others complex choosing representation abstract decision variables reﬁning abstract constraint expressions In rest section focus set decision variable knapsack present multiple ways reﬁning 22 Choosing Representations Before applying modelling reﬁnements Conjure traverses entire model labels reference abstract decision variables Section 31 representation decision Section 41 In example knapsack variable abstract decision variable referenced places lines 6 7 We consider representations set domain section Explicit representation Occurrence rep resentation The Explicit representation uses matrix decision variables representing elements set single integer variable representing cardinality set Structural constraints Section 41 posted en sure variables represent valid set values The Occurrence representation uses Boolean matrix decision variables indexed domain possible elements set In representation true value certain index matrix indicates set membership Conjure use representations reference knapsack variable2 Choosing multiple representations abstract decision variable leads channelled models Section 43 23 The Explicit representation Choosing Explicit representation references knapsack variable leads addition new variable declarations structural constraints model shown Fig 3 The matrix knapsack_ Explicit represents elements set integer variable knapsack_Size represents cardinality set The ﬁrst structural constraint enforces distinctness achieves symmetry breaking sorting entries matrix The sorting enforced cardinality set entries point members set The second structural constraint assigns variables knapsack_Size marker arbitrarily chosen value domain described Section 413 The references knapsack reﬁned Explicit representation Fig 4 shows reﬁnement expressions expression reﬁned similarly The sum expression quantifying set decision variable reﬁned sum expression quantifying simple integer domain We use multiplication set membership condition inside quantiﬁed expression This allows exclude entries matrix represent members set 24 The Occurrence representation Similarly choosing Occurrence representation references knapsack variable leads addition new variable declaration model This shown Fig 5 The matrix knapsack_Occurrence represents set 2 These representations given examples representation options Conjure 4 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 1 2 3 4 5 6 7 8 9 10 knapsack_Explicit matrix indexed knapsack_Size int1object object int0object forAll int1object 1 knapsack_Size knapsack_Expliciti knapsack_Expliciti1 forAll int1object knapsack_Size dontCareknapsack_Expliciti Fig 3 The new declarations structural constraints choosing Explicit representation sum int1object toInti knapsack_Size weightknapsack_Expliciti maxWeight Fig 4 Expression reﬁnement choosing Explicit representation knapsack_Occurrence matrix indexed object bool Fig 5 The new declaration choosing Occurrence representation sum object toIntknapsack_Occurrencei weighti maxWeight Fig 6 Expression reﬁnement choosing Occurrence representation forAll object knapsack_Occurrencei exists j int1object j knapsack_Size knapsack_Explicitj forAll int1object knapsack_Size knapsack_Occurrenceknapsack_Expliciti Fig 7 Channelling constraints Explicit Occurrence representations A true assignment index matrix indicates value set This representation introduce symmetry require structural constraints posted This assignment Boolean matrix corresponds unique assignment original set variable The references knapsack variable reﬁned Occurrence representation Fig 6 shows reﬁne ment expressions reﬁned similarly The sum expression quantifying set decision variable reﬁned sum expression quantifying potential members set Once use multi plication exclude values members set 25 Channelled models Suppose chose representation single abstract decision variable Each representation generated need connected ensure representations represent value original decision variable Models representation called channelled models constraints connecting representations channelling constraints In channelled model representations sets decision variables structural constraints added model Each reference decision variable reﬁned chosen representation The channelling constraints generated posting equality constraint example knapsackknapsack tagging occurrences decision variable different representations The equality reﬁned reﬁnement procedures applied constraint For running example channelling constraints given Fig 7 The ﬁrst constraint ensures members Occurrence representation members Explicit representation second constraint ensures holds opposite direction 5 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 Table 1 Domains domain constructors parameterised domains Essence Arguments domain constructors denoted τ τ1 τ2 Domains domain constructors nested arbitrarily Domain Concrete domains Atomic bool int enumerated unnamed Handling Kept unchanged Kept unchanged Mapped integers Mapped integers Concrete domains Compound tuple τ1 τ2 record alice τ1 bob τ2 variant alice τ1 bob τ2 matrix τ1 τ2 τn τ Separated components Separated components Separated components Kept unchanged Abstract domains set τ mset τ sequence τ function τ1 τ2 relation τ1 τ2 partition τ Reﬁned Reﬁned Reﬁned Reﬁned Reﬁned Reﬁned 26 Summary In section illustrated Conjure generates multiple diverse models single speciﬁcation choos ing representations abstract decision variables In following sections Conjure input language Essence set reﬁnement rules representations allow generate diverse set models Section 33 presents Conjure context pipeline tools languages 3 Automated Modelling CONJURE In section set scene automated modelling describing Conjure toolchain sits languages produced consumed Conjure tools First summarise Essence language consumed Conjure highlight important features We summarise Essence Prime language produced Conjure tool Savile Row translates Essence Prime language target solver 31 Summary Essence Language This section provides summary current state Essence language suﬃcient operation Conjure For details reader referred original journal paper describing Essence 26 frequently updated documentation accompanying Conjure release 49 Conjure takes input abstract problem speciﬁcation written Essence automatically generates Essence Prime models output Essence highlevel problem speciﬁcation language providing rich set builtin domains domain constructors parameterised domains multisets functions partitions Decision variables domains precisely encode mean avoid need model complex domains multiple decision variables simpler domains Essence domains directly represented Essence Prime called abstract domains domains shared languages called concrete domains Boolean int matrices We characterise domains compound contain multiple elements tuple matrix Tuples records contain ﬁxed number ﬁelds Fields tuple domain identiﬁed position ﬁelds record domain identiﬁed ﬁeld Variants tagged unions contain single value components tagged component The set domains domain constructors Essence handling abstract concrete domains given Table 1 Domains domain constructors nested arbitrarily allowing rich domains partition sets integers Unnamed types 26 unfamiliar brieﬂy An unnamed type represents set objects indistinguishable golfers Social Golfers Problem Fig 1 The elements unnamed type named numbered individually referred directly speciﬁcation Unnamed types exist provide abstraction sets indistinguishable objects allowing sets speciﬁed introducing symme try However current implementation unnamed types Conjure mapping integers introduces symmetry An implementation challenging important area future work described Section 412 Domains speciﬁed adding attributes domain constructor set attributes Attributes restrict precise abstract domain user Essence need use constraints achieve desired effect For instance set variable minSize attribute attached 6 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 Table 2 All domain attributes Essence Domain set τ mset τ sequence τ function τ1 τ2 relation τ1 τ2 partition τ Attributes size minSize maxSize size minSize maxSize minOccur maxOccur size minSize maxSize injective surjective bijective size minSize maxSize injective surjective bijective total size minSize maxSize For binary relations reflexive irreflexive coreflexive symmetric antiSymmetric aSymmetric transitive total connex Euclidean serial equivalence partialOrder numParts minNumParts maxNumParts partSize minPartSize maxPartSize regular Table 3 Operators abstract types matrices Essence In addition equality disequality ordering operators provided types types generators comprehensions quantiﬁers shown Table 4 For list operators types deﬁnitions Conjure documentation 49 Domain matrix τ1 τ2 τn set τ mset τ sequence τ function τ1 τ2 relation τ1 partition τ Operators x indexing slicing lexicographic ordering sum product xor min max subset subsetEq supset supsetEq intersect union powerSet difference x cardinality sum product xor min max union intersect difference subset subseteq supset supseteq x cardinality freq hist sum product xor min max subsequence substring x cardinality defined range image preImage union intersect difference subset subseteq supset supseteq x cardinality defined range inverse image preImage union intersect difference subset subseteq supset supseteq x cardinality relation application relation projection x cardinality apart participants parts party ensures values decision variable sets containing given number elements The attributes domain constructor given Table 2 Essence statically typed Conjure completely typechecks speciﬁcation reﬁning Each decision variable parameter domain obtain corresponding type Conjure strips attributes domain replaces int type int replaces subsets enumerated types corresponding enumerated type Essence rich collection operators allow concise expressions written abstract types For example functions inverse operator ensures functions inverses For relations relation projection lets create relation smaller arity ﬁxing components speciﬁc value Excepting integer Boolean operators manual complete set operators Essence summarised Table 3 organised types applied Operators nested way respects type correctness Essence provides quantiﬁers comprehensions construct complex expressions diﬃcult impossible express operators Table 3 Quantiﬁers comprehensions introduce local variables values domain abstract decision variable For example knapsack speciﬁcation Section 2 contains following sum quantiﬁer knapsack decision variable type set int value function objects monetary value The quantiﬁer calculates total value objects knapsack sum knapsack valuei A quantiﬁer keyword forAll exists sum quantiﬁed variable domain abstract decision vari able deﬁnes set values quantiﬁed variable ﬁnally inner expression type int sum quantiﬁers bool A quantiﬁer evaluated binding quantiﬁed variable value turn evaluating inner expression value aggregating results conjunction disjunction addition quantiﬁers forAll exists sum respectively Table 4 summarises types expressions gen erate set values quantiﬁed variable corresponding type quantiﬁed variable case Mediumlevel constraint modelling languages Essence Prime OPL 13 typically quantiﬁers forAll exists sum cases product min max quantiﬁed variable type int values drawn domain type set int abstract domain abstract cision variable Quantiﬁers Essence substantially general Essence Prime abstract types Comprehensions Essence create onedimensional matrix list The list aggregated single value function xor sum product min max global constraints like allDifferent Lists gener ated comprehensions arguments operators contrast quantiﬁed expressions limited forAll exists sum In common quantiﬁed expressions comprehensions inner expression introduce local variables values drawn abstract domain abstract decision variable Comprehensions 7 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 Table 4 Types expressions act generators quantiﬁed expressions comprehensions The type quantiﬁed variables changes depending type collection quantiﬁed Type collection matrix τ set τ mset τ sequence τ function τ1 τ2 relation τ1 partition τ Type quantiﬁed variable τ τ τ tupleindex τ tupleτ1 τ2 tupleτ1 set τ Quantiﬁed variable represents Member Member Member Member sequence index Mapping function Member relation Part partition conditions Boolean expressions act ﬁlter The condition contain references decision variables possible comprehensions Essence Prime example Comprehensions aggregation func tions expressive quantiﬁers internally Conjure preference quantiﬁers The example expressed comprehension follows sum valuei knapsack As ﬁnal example quantiﬁers comprehensions suppose wished ﬁnd multiset integers elements 10 numbers In following Essence speciﬁcation constraint elements multiset M expressed quantiﬁer implication M mset maxSize 5 int120 forAll M 10 2 0 The constraint expressed comprehension condition follows 2 0 M 10 In quantiﬁed expressions comprehensions collection types generators The type quantiﬁed variable chosen based type generator 32 Summary Essence Prime Language Essence Prime 50 mediumlevel solverindependent constraint modelling language similarities modelling languages OPL 13 MiniZinc 12 Essence Prime originally conceived subset Essence abstract types For purposes paper Essence Prime considered subset Essence following restrictions 1 There abstract types sets multisets sequences functions relations partitions Essence Prime supports deci sion variables problem class parameters type int bool matrix int bool Matrices number dimensions indexed integer domain 2 Generators conditions comprehensions quantiﬁers allowed contain decision variables 33 The Pipeline Our modelling solving pipeline illustrated Fig 8 An Essence problem speciﬁcation given Conjure reﬁnes speciﬁcation set concrete models Essence Prime Both speciﬁcation model typically relate problem class problem class parameters need instantiated instances class solved Conjure separately translates problem class parameters expressed Essence Essence Prime representations selected reﬁning problem speciﬁcation This allows user solve multiple instances problem class performing reﬁnement Savile Row 16 second tool pipeline It takes input model problem class parameters Essence Prime produces output number different solvers Savile Row instantiates model performs optimisations translating instance input language solver Currently Savile Row translates CP solvers Minion 51 Gecode 52 learning CP solver Chuffed 53 SAT solvers Glucose 54 MaxSAT solvers Open WBO 55 SMT solvers Yices 56 Z3 57 Boolector 58 Once solution Savile Row translates solution Essence Prime Conjure translates Essence Prime solution Essence Thus user Conjure specify problem terms abstract types partition receive solutions terms types 8 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 Fig 8 Automated Constraint Modelling Pipeline 34 How Essence represented Conjure Problem speciﬁcations represented internally abstract syntax tree AST A complete speciﬁcation contains language declaration line list statements Each statement declaration parameters decision variables aliases constraint objective optimisation problems statement Decision variables ﬁnd parameters given aliases letting names declaration statement referred subsequent statements Constraints statements contain list Boolean expressions The objective statement contains single expression type int enumerated type A problem speciﬁcation objective statement There restriction order statements different kinds restriction declarations referred declared circular deﬁnitions disallowed Expressions Conjure AST composed references existing declarations operator applications literal values types Essence quantiﬁed expressions comprehensions Conjure implements 76 operators latest version We list operators available Conjure documentation 49 Quantiﬁed expressions comprehensions commonly modelling languages Internally comprehensions represented quantiﬁed expressions converted comprehensions directly parsing Conjure implements evaluator Essence validate solutions The evaluator able compute Boolean value constraint expressions long values declarations referenced expression fully deﬁned Typically values givens come parameter ﬁle values finds come solution ﬁles solution validation In addition evaluator partial evaluator implemented simplify expressions possible The partial evaluator applied similar way reﬁnement rules discussed Section 4 The partial evaluator highest precedence expressions evaluated reﬁned possible 4 Reﬁnement Rules CONJURE Conjure translates abstract problem speciﬁcation written Essence concrete model Essence Prime series transformations These transformations written rules Conjure There main kinds rules represen tation selection expression reﬁnement Applying representation selection rules abstract variable speciﬁcation corresponds choosing viewpoint problem A viewpoint selection variables associated domains suf ﬁcient characterise solutions problem Different viewpoints rise fundamentally different models problem 5960 Multiple representation selection rules applied abstract variable create channelled model 32 single abstract decision variable reﬁned multiple ways Expression reﬁnement rules rewrite expressions use selected representations abstract variable Thus types rules correspond modelling steps taken human modellers selection viewpoint viewpoints formulating constraints Reﬁnement rules Conjure encode known modelling transformations established literature known correct We formally prove correctness reﬁnement rules formal exposition rules proofs correctness scope paper 9 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 41 Representation Selection Rules Representation selection rules operate decision variables parameters abstract domains When representation selection rule applied domain removes outermost abstract type replaces concrete type matrix The output domain necessarily concrete concrete domain reached repeated application representation selection rules In cases output domain representation selection rule values domain correspond values input domain In case structural constraints needed rule values As example consider Occurrence representation set The original domain set size n T T represents Essence domain The new domain Boolean variable value set Boolean assigned true value set The rule represented inputdeclaration x set size n T outputdeclaration x_Occurrence matrix indexed T bool structuralconstraint sum T toIntx_Occurrencei n The inputdeclaration rule patternmatched abstract domains The output declaration gives resulting domain value T given inputdeclaration Finally structuralconstraint requires n Booleans true set required size n Whenever multiple representation selection rules match abstract domain representations selected way In Section 6 present simple heuristic able select good model Each representation selection rule associated mapping functions translate values input domain output domain The mapping functions translate parameter values Essence Essence Prime translate solutions expressed Essence Prime Essence Fig 8 Each representation encodes step translation Conjure applies successively convert Essence Essence Prime 411 Conditional Structural Constraints Structural constraints essential correctness representation selection rules However cases need condition application structural constraints parts model For example Occurrence representation set shown contained set cardinality 0 1 structural constraint required outer set cardinality 1 Occurrence representation unused structural constraint required For example Section 413 We introduce operator structuralConsX representing structural constraints chosen represen tation X Concrete types structural constraints default treated true constraint Structural constraints applied outermost type abstract domain declaration Representation selection rules responsible applying structural constraints abstract decision variables declare output declaration section Many representation selection rules simply apply structuralConsX X declare Section 412 Section 413 examples representation selection rules use structuralCons function 412 Modelling Symmetry Symmetry enters constraint models ways Some problems inherent symmetries example rotations chessboard broken reﬂected model Many symmetries introduced modelling process case single solution problem corresponds multiple assignments variables model For example Explicit representation set represented list reordering members list change set represented Frisch et al 33 representation selection rule Conjure extended generate description symmetries introduces generated descriptions composed form description symmetries introduced model However convert model symmetry descriptions symmetry breaking constraints Conjure takes different approach generate symmetry breaking constraints rules introduce symmetries generate constraint break symmetries excepting unnamed types discussed A modelling symmetry introduced application representation selection rule increases number solutions This occurs output domain constrained structural constraints values input domain Suppose deﬁne Explicit representation set follows inputdeclaration x set size n T outputdeclaration x_Explicit structuralconstraint allDifferentx_Explicit forAll int1n structuralConsx_Expliciti matrix indexed int1n T In rule allDifferent structural constraint prevents repeated values x_Explicit constrain order values matrix The structural constraint suﬃces correctness rule 10 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 introduce modelling symmetry turn degrade performance solver The second line structural constraint section applies structural constraints inner type elements set Each representation responsible applying structural constraints nested objects applied unconditionally In Section 413 example conditional application structural constraints elements To avoid modelling symmetry addition ensuring elements different impose order matrix As elements matrix type T introduce new operators written These operators provide total ordering strict version total ordering types Essence These orderings intended natural available Essence language As orderings break symmetries speciﬁc ordering change solutions speciﬁcation The arguments representation They reﬁnement rules generate effective symmetrybreaking constraints Using orderings Explicit rule sets modiﬁed break symmetries introduces follows inputdeclaration x set size n T outputdeclaration x_Explicit matrix indexed int1n T structuralconstraint forAll int1n1 x_Expliciti x_Expliciti1 forAll int1n structuralConsx_Expliciti Rather introducing chain constraints rule exploits fact elements set required different strengthens ordering constraint cid4 cid4 cid4 T As providing eﬃcient composable symmetry breaking breaking symmetry immediately way advantages Expression reﬁnement rules described exploit fact symmetry breaking performed immediately produce eﬃcient reﬁnements Consider reﬁning constraint S T representing sets S T ﬁxed size matrices S represent cid4 order elements set need check element S equal element T cid4 T matrices different However ordering reﬁne S T S assignment S cid4 This gives smaller simpler reﬁned expression provides corresponds exactly assignment S simpler constraint smaller search trees allDifferent structural constraint To check S Both entirely removed Conjure translating lexicographic lex ordering constraints 61 62 The ordering imposed allowed differ depending representation chosen variable allow Conjure use simple eﬃcient lex ordering constraints Removing operators achieved small set rewriting rules First references abstract decision variables replaced representation If representation multiple output declarations matrix size variable contained tuple Once arguments contain abstract types matrix ﬂattened onedimensional matrix flatten tuple concatenated single onedimensional matrix concatenate Finally A B replaced A lex B similarly single integer Boolean The flatten concatenate functions exist Essence Prime need translate T cid4 cid4 cid4 The representation selection rules Conjure designed avoid introducing modelling symmetry Many representa tion selection rules additional structural constraints prevent modelling symmetry arising In way maintain model free modelling symmetry reﬁnement process exception unnamed types Unnamed type symmetry handled way modelling symmetries introduced Conjure Unnamed type symmetries removed ﬁrst complete ordering unnamed type type contains unnamed type deﬁnition unnamed types ordered However breaking general unnamed type symmetry extremely diﬃcult Consider type set set size 2 U unnamed type U type represents undirected graph set vertices U checking graphs allowing reordering vertices famous Graph Isomorphism problem complexity unknown Extending unnamed types matrix indexed U1U2 bool produces matrix rows columns permuted known NPcomplete papers investigating best way partially deal symmetry group 6364 As ﬁnal example type matrix indexed int U value symmetry broken polynomial time problem classes 65 In future work look general methods dealing unnamed type symmetry cover different symmetries arise use unnamed types 413 Types Variable Size Many domains Essence values different sizes A simple example set domain attributes restricting size set If set decision variable deciding size set decision problem The Explicit representation selection rule works ﬁxed cardinality sets variable cardinality sets commonly combinatorial optimisation problems We deﬁne representation called ExplicitVariableSize uses single integer decision variable track cardinality set creates matrix suﬃcient entries type T represent largest possible set 11 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 inputdeclaration x set T outputdeclaration x_ExpVarSize matrix indexed outputdeclaration x_Card structuralconstraints int1Tsize T int0Tsize forAll int2Tsize x_Card x_ExpVarSizei1 x_ExpVarSizei forAll int1Tsize x_Card structuralConsx_ExpVarSizei In rule Tsize smallest size domain T calculated automatically maxsize annotation x given The structural constraint ExplicitVariableSize orders elements ﬁrst x_Card indices matrix breaking modelling symmetry elements However remaining elements ma trix free value T representation conditional symmetry 66 Solvers search possible assignments increasing size search producing solutions represent solution speciﬁcation Other abstract types nontrivial reﬁnement multiset function relation partition variable size issue unconstrained variables occurs representations In general dontCare constraints ﬁx values free variables introduced representations Another example free variables occur representation partial functions In cases value deﬁned function corresponding image variables free We introduce new operator named dontCare break conditional symmetry caused free variables For Essence decision variable x dontCarex assigns decision variables concrete representation x smallest value This prevents target solver searching decision variables concrete representation x All dontCare operators removed Essence Prime model produced need extend tools support Removing dontCare operators achieved small set rewriting rules A dontCare operator decision variable abstract domain rewritten dontCare representation decision variable When dontCare applied tuple matrix rewritten apply element tuple matrix separately When dontCare applied Boolean integer variable rewritten equality constraint ﬁxing variable smallest value These rules suﬃce remove dontCare completely Essence Prime model produced The assignment dontCarex correspond value abstract domain x For example abstract domain set minSize 2 int13 Occurrence representation Section 24 current implementation dontCarex assigns variables false produces set This conﬂict annotation minSize 2 Therefore structural constraints x conﬂict dontCarex ensure Conjure avoids asserting Representation rules required ensure abstract variable introduce exactly dontCare structuralCons placed assignment ensure removal symmetries correct answers The ExplicitVariableSize rule written follows forAll int1Tsize x_Card forAll int1Tsize x_Card dontCarex_Expliciti structuralConsx_Expliciti The dontCare constraint reﬁned standard expression reﬁnement processes Conjure reﬁnements abstract types In Section 5 evaluate impact breaking conditional symmetry dontCare 414 Consistent Symmetry Breaking A known issue constraints break multiple sets symmetries problem constraints conﬂict leading lost solutions 63 This problem occur Conjure breaks symmetries conditional symmetries introduced reﬁnement The reason simple symmetry broken soon introduced allowing handle introduced symmetry group isolation To elaborate important feature Conjure reﬁnement valid speciﬁcation ap plication reﬁnement rule partiallyreﬁned speciﬁcations include constructs internal Conjure Essence Therefore introduce symmetry conditional symmetry reﬁnement immediately addition new constraints point simultaneously model symmetries break consistently If hand delayed breaking symmetry reﬁnement complete break symmetries consistent manner The symmetry breaking constraints generated Conjure conﬂict constraints original speciﬁ cation Conjure breaks symmetry introduced representation selection rule For purpose posts symmetry breaking constraints concrete decision variables generates The concrete variables present original speciﬁcation impossible write conﬂicting constraints terms Reﬁning Essence speciﬁcation Conjure produces model identical number solutions speciﬁcation Therefore broken symmetries lead Essence solution mapping multiple 12 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 Essence Prime solutions We need ensure representation selection rule isolation preserves exactly signment solution application set representation selection rules preserve number solutions We focused paper breaking modelling symmetry While abstraction Essence language naturally lends writing Essence speciﬁcations symmetry expect Essence speciﬁcations contain symmetries conditional symmetries example representing reﬂections rotations chessboard Assuming symmetry speciﬁcation detected topic addressed paper broken consistently adding constraints speciﬁcation prior reﬁnement example lex leader method 61 consistency issue way Conjure breaks modelling symmetry 415 Viewpoint Selection Choosing representation selection rule apply decision variable corresponds human modeller selecting viewpoint It crucially important eﬃciency model affecting ease stating constraints propagation ultimately eﬃciency search solution Conjure makes representation choices pass separating choice representations actual applica tion representation selection rules It chooses representation decision variable speciﬁcation Every reference decision variable tagged representation guides application expression reﬁnement rules described Section 42 For simplicity assume decision variable representation However channelled model decision variable multiple representations Section 43 describes Conjure generates channelled models 416 Representation Selection Rules Conjure Table 5 gives brief description Conjures representation selection rules There 17 representations total spread 6 abstract domain constructors Three representations FunctionAsRelation RelationAsSet PartitionAsSet work converting abstract domain abstract domain converted concrete domain subsequent representation rule applications We brieﬂy explain remaining representations section A common method shared representations use marker ﬂag variables indicate relevant members matrix For example variable size set representation marker variable Conjure creates matrix suﬃcient entries represent maximum number elements set In addition marker variable indicate size set Decision variables matrix irrelevant ﬁnal value abstract variable These ﬁxed break symmetry dontCare constraints described Section 413 There main kinds representations sets Occurrence representation ﬂavours explicit represen tations The Occurrence representation creates Boolean variable potential member set This representation introduce modelling symmetry create prohibitively large number variables given large set domain The basic Explicit representation works ﬁxed cardinality set variables For set cardinality n creates matrix indexed 1n element matrix represents member set Symmetry breaking straints ensure matrix increasing order The ExplicitVariableSizeMarker ExplicitVariableSizeFlags representations work variable cardinality sets They matrix similar Explicit matrix element potential element set maximum cardinality set limit The uses single integer variable denote cardinality set uses Boolean variable element matrix indicate membership Appropriate symmetry breaking constraints added enforce increasing order elements set ﬁx irrelevant variables dontCare constraints ExplicitVariableSizeDummy similar Explicit adds dummy value domain elements matrix3 Representations multisets similar sets In contrast sets multisets allow repeated values In order accommodate multiset Occurrence representation introduces integer decision variable instead Boolean value set The domain variable ranges zero maximum number occurrences allowed value The ExplicitFlags representation uses decision variable distinct value corresponding decision variable number repetitions value The ExplicitRepetition representation uses matrix decision variables bounded maximum cardinality multiset Repeated values allowed matrix resulting symmetry broken placing nondecreasing order Sequences Essence ordered collections values variable length upper bound Sequences repre sented matrix length variable Elements matrix index greater length sequence ﬁxed dontCare constraints There representations functions FunctionAsMatrix represents total function τ1 τ2 matrix indexed τ1 containing τ2 The remaining representations partial functions The FunctionAsMatrixPartial FunctionAsMatrix representation plus Boolean variable corresponding value τ1 indicate value deﬁned function Undeﬁned values ﬁxed dontCare constraints FunctionAsMatrixDummy extends FunctionAsMatrix dummy value indicate undeﬁned values 3 Some solvers support decision variables set int domains In addition representation options presented Conjure trivially output variables converting matrices 13 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 Table 5 Representation selection rules Conjure Representation set τ Occurrence Explicit ExplicitVariableSizeMarker ExplicitVariableSizeFlags ExplicitVariableSizeDummy mset τ Occurrence ExplicitFlags ExplicitRepetition sequence τ ExplicitBounded function τ1 τ2 FunctionAsMatrix FunctionAsMatrixPartial FunctionAsMatrixDummy FunctionAsRelation Description Matrix Boolean ﬂags indicating presence value Fixed size matrix distinct values Explicit size variable Explicit Boolean ﬂags mark unused elements Explicit dummy value unused elements Matrix integers indicating frequency value Matrix distinct values counter Matrix values repetition allowed Matrix τ length variable Total functions Matrix indexed τ1 τ2 Matrix indexed τ1 τ2 matrix Boolean ﬂags mark unused elements Matrix indexed τ1 τ2 extended dummy value indicate missing values Relation element τ1 related element τ2 relation τ1 τi RelationAsMatrix RelationAsSet partition τ Occurrence PartitionAsSet For relations integers Booleans Matrix Boolean ﬂags indicating presence tuple relation Set tuples For partitions integers Cells numbered A matrix indexed τ contains cell number element The size ﬁrst element cell represented Set sets inner sets represent cells partition The RelationAsMatrix representation Boolean matrix indexed components relation true value indicates relation membership The partition τ Occurrence representation matrix indexed τ represent cell partition value belongs Cells identiﬁed integers The cardinality ﬁrst element cell represented eﬃciency reasons The modelling symmetry arising representation broken structural constraints 42 Expression Reﬁnement Rules Expression reﬁnement rules second kind rules Conjure They translate Essence expressions equivalent Essence Prime expressions They depend representations decision variables parameters Rules depend representations called horizontal rules called vertical rules Horizontal rules change representation decision variables merely translate Essence expressions Essence expressions Horizontal rules representation independent reduce need large number representationdependent vertical rules 421 Vertical Rules Vertical rules replace references abstract decision variables representations There exist vertical rules basic operations abstract types One important classes vertical rules comprehen sion generator rules allow comprehensions iterate elements contained abstract decision variable Suppose following comprehension containing abstract variable S type set int All items S odd In addition operator simplest binary operators sets S set size 3 int110 i2 1 S 5 S If Occurrence representation chosen S vertical rule replaces generator S int110 S Another vertical rule replaces S 5 S follows SOccurrence matrix indexed int110 bool sum SOccurrencei int110 3 i2 1 int110 SOccurrencei SOccurrence5 If Explicit representation chosen resulting model different A vertical rule replaces generator S q int13 references SExplicitq producing straightforward model ﬁrst 14 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 constraint For second constraint vertical rule horizontal rule applied ﬁrst producing orq 5 q S From vertical rule applied generator q S producing model To complete reﬁnement model fragment reﬁned described Section 412 SExplicit matrix indexed int13 int110 S_Explicitq S_Explicitq 1 q int12 SExplicitq2 1 q int13 SExplicitq 5 q int13 All comprehension generators T vertical rule possible representation T abstract types allowed generator Section 31 Other operators vertical rules representations In example S reﬁned vertical rule S took Occurrence representation Vertical rules priority horizontal rules 422 Horizontal Rules Horizontal rules entirely independent chosen representation abstract decision variables They allow Conjure reformulate expressions adding diversity models Conjure produce avoiding need huge number vertical rules When vertical rule available expression Conjure applies horizontal rule replace expression simpler expression decomposing operator Repeated application horizontal rules allows Conjure reach vertical rule For example suppose decision variables A B type set int constraint A B Reﬁne ment equality important channelling constraints described Section 43 cases equality larger expression A B set size 3 int110 A B Suppose Occurrence representation chosen A Explicit chosen B constraint A B There vertical rule equality distinct representations sets A horizontal rule applied decompose A B A subsetEq B B subsetEq A However subsetEq vertical rule Another horizontal rule applied subsetEq operators resulting following speciﬁcation A B set size 3 int110 A B int110 B A int110 To complete reﬁnement Conjure applies relevant vertical rules replacing A AOccur rencei B following exists q int13 BExplicitqi Thanks representationoblivious horizontal rules allow Conjure achieve coverage Essence language manageable number rules having repeat similar rules new representation 43 Channelling Multiple Representations Combining multiple representations abstract decision variable channelled model remarkably powerful 67 Constraints stated appropriate chosen representations allowing concise expression constraints cases improved propagation improve eﬃciency search solution However channelling introduces overheads form additional decision variables constraints outweigh potential beneﬁts Conjure chooses representation reference decision variable speciﬁcation choose multiple representations decision variable All representation choices pass reference decision variable tagged suitable representation In way choice representations separated actual application representation selection rules When decision variable represented way channelling constraints added ensure consistency representations A channelling constraint simply equality references decision variable references tagged different representations The equality reﬁned standard reﬁnement processes expressions described Section 42 A channelling constraint created pair distinct representations An example reﬁning channelling constraint knapsack problem given Section 25 By default Conjure produces multiple models enumerating possible ways selecting representations ways tagging reference decision variable AST possible ways generating constraint expressions representation selected Depending speciﬁcation large numbers models produced speciﬁcation shown Table 7 We discuss issue selecting effective model Section 6 Section 7 evaluate Conjure examining generate known good models literature wide range speciﬁcations 15 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 Table 6 Number solutions dontCare constraints A indicates number solutions 1 hour CPU timeout Inner Outer set multiset function relation partition set With 11 19 25 137 41 multiset function relation partition Without 38 58 64 632 310978 With 22 34 49 667 352 Without 87 129 144 3222 9092502 With 46 73 100 4042 10 Without 632 928 1024 174512 277220736 With 67 101 144 7382 88574 Without 297 441 484 36542 198611820 With 15 25 36 296 208 Without 845 1315 1444 318452 138135600 5 The Impact Breaking Modelling Symmetries In section evaluate impact breaking model symmetries automatically Throughout important bear mind symmetries broken Conjure problem class level beneﬁt symmetry breaking automatically obtained instance problem class reﬁned This approach substantially eﬃ cient analysing individual instance identify symmetries 68 At present mechanisms breaking modelling symmetries The ﬁrst breaks unconditional variable symmetries ordering constraints introduced Sec tion 412 In case number symmetries represented closedform expressions detailed example Section 51 The second mechanism breaks conditional symmetries arise parts representations unused solution introduced Section 413 Here number symmetries impact symmetry breaking constraints straightforward represent mathematically experiment Section 52 51 Breaking Unconditional Variable Symmetries In order illustrate importance symmetry breaking way high level abstraction Essence allows avoid expensive step detecting modelling symmetries consider reﬁnement Social Golfers Problem speciﬁcation presented Fig 1 The single abstract decision variable speciﬁcation set representing weeks partitions representing groups golfers A standard reﬁnement ﬁxedcardinality set particularly elements complex objects matrix number elements cardinality set Explicit representation Of course matrices indices sets immediately introduces symmetry permutation matrix represents set In case w symmetries However reﬁnement rule employed Conjure recognises modelling symmetry breaks enters model ordering elements matrix need costly symmetryidentiﬁcation process ﬁnal model The partition golfers thought set sets golfers subject additional constraints outer set contains exactly g sets size s intersection pair inner sets A natural reﬁnement nested object g s matrix introducing symmetry g possible arrangements groups s arrangements golfers groups Since group arranged independently results gsg symmetries partition Conjure identiﬁes breaks enter model Since partition forms weeks ﬁnal model derived wgsg symmetries total This vast number relatively small instances social golfers problem left model signiﬁcant adverse inﬂuence performance search Conjures ability deal symmetries automatically class level described Section 412 valuable 52 Breaking Conditional Symmetries Conditional symmetries arise reﬁning abstract domains values distinct sizes parts representation redundant solution depending chosen representation As described Section 413 dontCare constraints assign redundant variables order break conditional symmetry We ran experiment illustrate effectiveness automated conditional symmetry breaking Conjure counting number solutions Essence problem speciﬁcations dontCare constraints The experiment demonstrates arbitrary combinations nested types handled conditional symmetries In experiments Savile Row Minion run default settings 32core AMD Opteron 6272 21 GHz First generated 25 Essence speciﬁcations Each contains single decision variable 3level nested domain constraints The innermost domain integer domain generate combinations 5 Essence domain constructors layers The outer layers bounded size 2 size 1 meaning layers require conditional symmetry breaking dontCare constraints Moreover structural constraints inner layer need posted conditionally Conjure contains multiple reﬁnement options domains experiment In cases able generate thousands models problem However conditional symmetry breaking constraints needed models chose model problem CompactEP heuristic Section 6 16 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 Table 6 presents number solutions problem speciﬁcation conditional symmetry breaking constraints The results expected models dontCare constraints fewer solutions The extreme cases involve partitions produce hundreds millions solutions symmetrically distinct ones When dontCare constraints symmetric solutions avoided solver need waste effort searching 6 Model Selection COMPACTEP Heuristic Conjure able produce multiple models enumerating possible ways selecting representations If time limited sensible provide rapid model selection method avoiding generating models training instance data In earlier work proposed method based racing 34 select subset models perform given set training instances Racing methods allow comparing alternative algorithms necessarily having run algorithms instances Racing model selection computationally expensive The focus paper reﬁnement Conjure omit model selection methods essentially external Conjure racing Conjure contains greedy model selection heuristics making local decisions model generation These employed representation selection expression reﬁnement The default heuristic called CompactEP stands compact parameters combination Compact heuristic Sparse heuristic We deﬁne heuristics following The Compact heuristic favours transformations produce simpler types variables smaller expressions point reﬁnement multiple rules applicable We deﬁne compact ordering abstract types follows concrete domains bool matrix smaller abstract domains concrete domains bool smaller int int smaller matrix These rules applied recursively onedimensional matrix int smaller twodimensional matrix Abstract type constructors ordering set mset sequence function relation partition applied recursively At stage representation selection CompactEP heuristic select smallest domain according order As example setsize n int represented matrix indexed int bool Occurrence representation matrix indexed int int Explicit representation As bool smaller int ordering Compact pick Occurrence representation example During expression reﬁnement Compact chooses rule produces shallow abstract syntax tree AST directly following application For example expression like subsetEq shallower AST depth 1 forAll exists j b j depth 3 To break ties arbitrary total ordering deﬁned abstract syntax trees The Sparse heuristic intended enable small representations parameter values It employs builtin ordering representations gives priority advantage sparsity For example Explicit representation priority Occurrence representation ﬁxedcardinality set Explicit scales cardinality Occurrence scales number values potentially set Consider parameter domain lation int1100 int1100 A sparse member domain like relation12 34 require 10000 Booleans RelationAsMatrix representation 4 integers RelationAsSet repre sentation The default CompactEP heuristic combination heuristics representation selection Conjure uses Sparse heuristic representing problem class parameters Compact heuristic 7 Evaluation CONJURE Produces Kernels Good Models Conjure provides coverage Essence language It variable representation rule typically Table 5 abstract variable type horizontal vertical expression reﬁnement rules operators deﬁned In section test hypothesis kernels constraint models written experts au tomatically generated reﬁning problems abstract speciﬁcation For CP models model kernel need share viewpoint representation decision variables formulation problem constraints symmetry breaking Expert models additional features implied constraints dominance breaking 69 constraints considered kernel CP model evaluation Some expert models contain global constraints present Essence Prime In cases Conjure generates equivalent decomposition consider models kernel In order test hypothesis took diverse set 42 benchmark problems drawn literature reﬁned Conjure Our main source problems CSPLib 48 We cover entire CSPLib problem class collection time writing problems naturally represented matrices Booleans integers facilities Essence provides addition lower level constraint modelling languages In Table 7 present set problem classes abstract types decision variables Essence We cite papers contain kernel Conjure able generate We begin noting variety decision variable types involved benchmark problems representing evidence current collection rules rewrite 17 1 8 Table 7 Running Conjure 42 benchmark problems CSPLib We highlight features Essence problem speciﬁcation problem class include reference published model problem comparable models automatically generated Conjure In addition present estimated number models Conjure produce 6 conﬁgurations model selection heuristics 1 2 3 5 6 7 8 9 10 13 15 16 17 18 21 22 24 26 28 30 31 32 33 34 36 38 39 40 44 45 49 51 53 53 53 53 55 56 65 83 85 86 110 115 116 Problem Essence features Car Sequencing Template Design Quasigroup Existence Low Autocorrelation Binary Sequences Golomb Ruler AllInterval Series Vessel Loading Perfect Square Placement Social Golfers Problem Progressive Party Problem Schurs Lemma Traﬃc Lights Ramsey Numbers Water Bucket Problem Crossﬁgures Bus Driver Scheduling Langfords number problem Sports Tournament Scheduling Balanced Incomplete Block Designs Balanced Academic Curriculum Problem Rack Conﬁguration Problem Maximum Density Still Life Word Design DNA Computing Warehouse Location Problem Fixed Length Error Correcting Codes Steel Mill Slab Design The Rehearsal Problem WagnerWhitin Distribution Problem Steiner triple systems The Covering Array Problem Number Partitioning Tank Allocation Graceful Double Wheel Graphs Graceful Gears Graceful Helms Graceful Wheel Graphs Equidistant Freq Permutation Arrays Synchronous Optical Networking Optimal Financial Portfolio Design Transshipment Problem Van der Waerden Numbers Capacitated Vehicle Routing Problem Peaceably Coexisting Armies Queens Tail Assignment Vellinos Problem function 1 1D function 1 2D function 2D function function variable set variable 2 bijective functions 4 functions 2 functions set partition set partition partition function function 2 sequences sequence variant partition int sequence injective function relation enums set enums relation unnamed types binary relation function variable partial nested function set tuples set function function set functions partition orders 3 functions 1 bijection partial 2D function matrix set mset function 2 set variables set parameters injective functions injective functions injective functions injective functions set mset set set set 2 partial functions partition numbers set sequences 2 sets tuples relations sets nested functions partial function msets Refs 71 72 73 74 75 76 77 78 31 79 80 81 82 3583 84 85 8687 88 89 90 91 9294 95 27 64 9697 98 99 100 101 102 103 104 104 104 104 105 106 107 108 109110 111 112 113 114 Pruning NoCh 1 1 1 1 2 1 1 1 3 4 4 1 2 1 1 4 1 2 1 1 1 2 2 4 1 4 1 1 2 2 4 1 1 1 1 1 1 8 2 4 4 4 8 6 1 VarsCh 1 1 1 1 32 1 1 1 9 256 16 1 128 1 1 64 1 16 1 1 1 256 32 4 1 26 105 1 1 8 4 256 1 1 1 1 1 1 512 4 256 16 256 2048 3 1014 1 FullCh 1 1 1 1 32 1 4 1 9 256 32 1 512 32 1 256 1 16 1 1 1 256 32 4 2 26 105 1 4 8 8 256 32 1 1 1 1 1 1024 4 256 16 256 4096 3 1014 1 No Pruning NoCh 4 12 3 4 2 16 256 16 3 16 5 3 3 4 1 9 3 2 3 4 12 2 8 16 4 8 64 1 2 8 4 1 16 16 16 16 4 8 2 16 5 4 60 45 4 VarsCh 64 576 729 64 32 1024 18 1019 17 107 9 26 105 25 27 2187 11 109 1 729 243 16 243 16384 25 105 256 32768 1024 64 13 108 17 107 1 8 64 256 1 27 108 65536 42 106 65536 256 512 4 65536 25 256 15 1011 52 1030 64 FullCh 10368 5184 729 64 32 1024 48 1023 17 107 9 94 106 50 27 8748 11 1012 1 2916 243 16 243 29 105 54 108 256 32768 18432 192 36 109 12 109 4 8 320 256 32 27 108 65536 42 106 65536 256 1024 4 21 107 25 256 74 1012 42 1032 10368 Ö A k g ü n A M F r s c h I P G e n t e t l A r t ﬁ c l I n t e l l g e n c e 3 1 0 2 0 2 2 1 0 3 7 5 1 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 rule mechanism Conjure capable reﬁning wide variety abstract problem speciﬁcations concrete models The number models generated problem speciﬁcation depends number representation options decision variables 71 Conﬁgurations Conjure In Table 7 report lower bound number models generated Conjure conﬁgurations One source variation models selection different representations decision variables parameters quan tiﬁed variables We calculate exact number representations available examining domain A second source variation arises expression reﬁnement We calculate lower bound number attainable models taking product number representation options reference declaration model chan nelling enabled declaration For example decision variable channelled representations referred times model 23 8 ways tagging references representation The result calculation lower bound ignores potential multiple expression reﬁnement pathways selection representations The conﬁgurations represent different tradeoffs time taken ability generate diverse models One option prune set representations Pruning Use builtin heuristic ﬁlter list representations This heuristic allows use variable cardinality representation ExplicitVariableSizeMarker sets created RelationAsSet PartitionAsSet representa tions No Pruning Explore applicable representations decision variable parameter Pruning No Pruning combined following options channelling NoCh Decision variables parameters representation channelling VarsCh Channelling allowed decision variables parameters FullCh Channelling allowed decision variables parameters The number models Conjure generate problem class depends heavily abstract types problem speciﬁcation In particular decision variables parameters abstract domains present opportunity different representations When channelling enabled number models depends number times decision variable parameter mentioned constraints use decision variable presents opportunity new representation In addition choosing representation use decision variables allow addition extra representation mainly providing search order 70 In Table 7 present numbers models conﬁgurations In terms numbers models case NoCh VarsCh FullCh Pruning No Pruning In cases channelling dramatically increases number models Steel Mill Slab Design example similarly turning pruning dramatic impact example Water Bucket Problem 72 Comparing Generated Models Published Models In section brieﬂy compare models generated Conjure published models written expert modellers 42 problem classes CSPLib 1 For car sequencing problem default heuristic Conjure generates model uses integer matrix represent function variable This viewpoint model published 71 In addition Conjure generates 2dimensional Boolean representation function variable commonly developing MIP SAT models CSPLib 2 The template design problem function variables Essence speciﬁcation These variables repre sented integer matrices default heuristic total functions This model viewpoint 72 CSPLib 3 For variations quasigroup existence problem Zhang 73 2dimensional matrix represent integer square grid This model produced default model Conjure CSPLib 5 The low autocorrelation binary sequences problem contains function variable modelled similar way template design problem CSPLib 2 74 CSPLib 6 The golomb ruler problem naturally modelled set From set model Conjure generates explicit representation symmetry breaking Boolean occurrence representation In explicit model distinctness intertick distances modelled alldifferent constraint thanks Savile Row The explicit model given Section 2 75 occurrence model Section 7 paper CSPLib 7 The allinterval series problem modelled 2 bijective functions Essence Previous work model looks breaking symmetry 76 use 1dimensional arraybased representation function variable appropriate constraints enforce bijection property The default model generated Conjure model 19 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 CSPLib 8 The vessel loading problem described Brown 77 He array based model represent function variables Essence problem speciﬁcation Among representations Conjure generates viewpoint published model CSPLib 9 The perfect square placement problem speciﬁed function variables Essence The default model generated Conjure uses viewpoint model given 78 This published model uses cumulative global constraint generated Conjure currently instead Conjure generates equivalent decomposition CSPLib 10 The social golfers problem speciﬁed set partitions Essence The set represents weeks partition schedule week This abstract domain gives rise 3dimensional matrix model appropriate constraints posted enforce set partition structure This viewpoint default model generated Conjure corresponds model presented 31 CSPLib 13 Progressive party problem includes set partitions problem speciﬁcation This domain reﬁned representations viewpoint models presented 79 CSPLib 15 Schurs lemma 80 speciﬁed single partition variable Using quantiﬁcation sets triples potential members partition apart operator problem stated single level constraint The default model Conjure generates uses set sets includes automated symmetry breaking constraints CSPLib 16 The traﬃc lights problem example 81 demonstration higherarity constraints In Essence problem speciﬁed functions set membership CSPLib 17 The Ramsey numbers problem modelled function variable universal quantiﬁcation ﬁxed size subgraphs The default model generated Conjure uses variable represent edge graph colour corresponds model presented 82 CSPLib 18 The water bucket problem planning problem It modelled sequence states actions Essence The sequence type allows modelling list bounded ﬁxed length The default model generated problem represents states actions explicitly breaks conditional symmetry 35 arising variable length data structures A comparable model given 83 CSPLib 21 The crossﬁgures problem beneﬁts bounded length sequences similar way water bucket prob lem In addition uses variant type represent 8 different kinds clues succinctly The generated Essence Prime model comparable MiniZinc model published CSPLib page 84 CSPLib 22 The natural language speciﬁcation bus driver scheduling problem starts following sentence Bus driver scheduling formulated set partitioning problem The problem speciﬁcation Essence succinct single decision variable represents partition Starting problem speciﬁcation models generated Conjure uses core viewpoint model published 85 CSPLib 24 A channelled Essence model Langfords number problem presented 86 The output Conjure problem corresponds closely models presented Smith 87 CSPLib 26 The sports tournament scheduling problem speciﬁed arity 3 relation week period set teams Each entry relation indicates teams timetabled play game selected week period This abstract type relation projection operator allows succinct speciﬁcation problem Essence One generated CP models uses viewpoint similar published 88 CSPLib 28 The balanced incomplete design problem BIBD typically modelled CP 2dimensional array symmetrybreaking constraints 89 In Essence problem speciﬁed relation arity 2 unnamed types This domain allows break symmetry problem computationally eﬃcient approach produce commonly doublelex constraints CSPLib 30 The balanced academic curriculum problem BACP modelled relation represent prerequisites courses function variable represent assignment periods courses Using problem speciﬁcation Conjure generates model similar published 90 CSPLib 31 The rack conﬁguration problem modelled partial function represents rack solution model quantity card type rack This representation captures decision abstractly allows generation kernels models presented 91 CSPLib 32 For maximum density life problem obtain comparable model Bosch Trick 92 difference Conjure chooses explicit instead occurrence representation However obtain like dual model obtained Smith 93 supercells original grid variables example reformulation implemented generally remains outside scope paper Using advanced techniques complete solution problem n 94 CSPLib 33 The DNA word design problem succinctly speciﬁed Essence set functions It optimi sation problem objective minimise cardinality abstract set For problem Conjure produces model similar published 95 symmetry breaking constraints function members set CSPLib 34 The warehouse location problem typical network ﬂow problem Function variables Essence specify problem high level abstraction Conjure able generate main alternative viewpoints described 27 channelled versions viewpoints 20 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 CSPLib 36 The ﬁxed length error correcting codes problem uses partial function Essence problem speciﬁcation abstract decision variable domain set functions Thanks abstract type models produced Conjure include symmetry breaking constraints similar presented 64 CSPLib 38 For steel slab design problem Conjure obtains models set orders assigned slab set colours slab reﬁned occurrence explicit representations If occurrence model similar model 96 The later model 97 uses different viewpoint exploiting dominance generated Conjure CSPLib 39 The rehearsal problem uses 3 function variables bijection When deﬁning objective function problem speciﬁcation uses list comprehension feature Essence Smith 98 presents model similar models generated Conjure CSPLib 40 The distribution problem WagnerWhitin costs warehouse stock distribution problem warehouse order stock warehouse time step The speciﬁcation uses partial function variable represent orders Conjure generates conventional viewpoint Tarim Miguel 99 value 0 represent order variation additional Boolean variables indicate orders Conjure generate echelon model 99 CSPLib 41 The nfractions puzzle complex problem specify beneﬁts surjective attribute Essence Frisch et al 115 use problem explore implied constraints models generated Conjure present CSPLib 44 The Steiner triple systems problem special case balanced incomplete block design problem Its problem speciﬁcation uses set variables set intersection operator Conjure able generate explicit repre sentation set variables similar viewpoint 100 CSPLib 45 The covering array problem modelled 2dimensional matrix variable The statement straints uses quantiﬁed expression values ﬁxed length sequence The output models similar published 101 CSPLib 49 The set partitioning problem directly speciﬁed Essence 2 set variables constraint enforce main sum constraint problem Alternatively partition 2 parts In case output models use Explicit set representation based viewpoint Occurrence based set representation Depending instance size model likely better choice Both viewpoints explored previous work context mathematical programming 102 CSPLib 51 Schaus et al 103 present viewpoint tank allocation problem uses single integer variable representing product type tank The Essence problem speciﬁcation follows viewpoint closely beneﬁting Essence features represent parameters set sets representing incompatibilities stating straints There 4 variants graceful graphs problem CSPLib 53 Wheel Graphs Double Wheel Graphs Gears Helms Smith Puget 104 present viewpoints family problems primarily based nodes primarily based edges The Essence problem speciﬁcation gives rise viewpoints based nodes CSPLib 55 The equidistant frequency permutation arrays EFPA problem speciﬁed single set variable This allows Conjure generate alternative models symmetry breaking channelling representations The generated models include Boolean NonBoolean Channelled models presented 105 CSPLib 56 The synchronous optical networking SONET problem uses single variable nested domain multiset set nodes In addition declaration variable problem speciﬁcation single statement objective single statement problem constraint enforce demand met Starting high level problem speciﬁcation Conjure produces model comparable published 106 creates symmetry breaking constraints automatically CSPLib 65 The optimal ﬁnancial portfolio design problem speciﬁed Essence set set integers single level decision variable The main constraint written succinctly universal subset quantiﬁcation feature Essence Starting highlevel speciﬁcation Conjure generates model uses matrixbased viewpoint published 107 CSPLib 83 The transshipment problem 108 network ﬂow problem nodes warehouses transshipment points customers The model Essence uses partial function pairs nodes ﬂow corresponding edge model structure The default model generated Conjure uses 2dimensional Boolean matrix model edge existence 2dimensional integer matrix model ﬂow edge A second model uses list triples 2 nodes ﬂow generated The model likely good choice sparse networks CSPLib 85 There common model Van der Waerden numbers 2dimensional Boolean matrix viewpoint CP 109 SAT 110 This model models generated Conjure chosen default heuristic CSPLib 86 There main approaches modelling capacitated vehicle routing problem vehicle ﬂow formula tions set partitioning formulations 111 The ﬁrst integer variable edge representing ﬂow edge default model produced Conjure The second uses Boolean variables represent set partitioning Conjure generates model 21 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 CSPLib 110 The Essence problem speciﬁcation peaceable armies queens problem uses set variables represent location white black queens These sets represented Conjure ways including viewpoint given 112 symmetry breaking constraints presented CSPLib 115 The tail assignment problem deﬁned single function variable This function variable ﬁnds partial mapping ﬂights ﬂights representing route plane The basic model 113 uses 3 sets decision variables represent information Conjure generates comparable viewpoint automatically CSPLib 116 The Essence problem speciﬁcation Vellinos problem uses partial function multisets represent contents active bin Bins undeﬁned function The problem stated function operators deﬁned range quantiﬁcation A similar viewpoint default model generated Conjure published 114 In section demonstrated Conjure able generate models similar published models produced experts wide range problem classes drawn public repository Also abstract types Essence set multiset sequence function relation partition speciﬁcations 42 problem classes showing types necessary Essence Moreover 30 42 problem classes Conjures default heuristic able choose model equivalent published model problem class 8 Related Work Automated Constraint Modelling Reﬁnement This section primarily surveys languages systems employed reﬁnementbased approaches automated constraint modelling compares work Essence Conjure Beyond body work exists variety approaches automated modelling discuss brieﬂy proceeding One line work example driven OCasey 23 case based reasoning tool uses recordings previous problem solving episodes Problems paired problem instances form case The experience obtained cases mainly selection propagators search heuristics Conacq 116 SATbased version space algorithm acquire constraint networks Its inputs set decision variables collection positive negative examples Positive examples valid solutions problem negative examples nonsolutions It automatically generates constraints applying machine learning techniques The Constraint Seeker 117 focuses automated acquisition individual global constraints large collection positive negative examples The Model Seeker 7 uses positive examples learn complete models Another approach transform existing constraint model improve solver performance The CGrass 118 sys tem explores idea reformulating CP models collection rules order improve It limited integer variables arithmetic logical operators integer expressions change representations deci sion variables rearrange constraint expressions reduce domains decision variables Tailor 11 performs commonsubexpression elimination CSE successor Savile Row 16 extends CSE adds powerful transfor mations MiniZinc 12 mediumlevel constraint modelling language It contains features common CP modelling languages Boolean integer domains arrays collections variables MiniZinc problem class models perform reformulations class level When presented problem instance data class model instantiated instance model targeted solver backends MiniZinc uses solverdependent instance level language called FlatZinc interact solvers 81 Reﬁning Abstract Constraint Problems The NPSpec language 119 allows speciﬁcation NPcomplete problems subset existential second order logic It provides small number high level domains sets partitions integers automatically reﬁned decision variables simpler domains NPSpec provides way reﬁne highlevel domain operator Hence allow generation alternative models The ESRA language 25 particular focus decision variables relation domains It translated language OPL 11413 constraint modelling language similar facilities Essence Prime reﬁning relation domains operators Like NPSpec consider multiple alternative reﬁnement pathways Moreover abstract domains offered ESRA nested arbitrarily The F language 27 supports function variables Problems modelled F reﬁned OPL called Fiona F supports function attributes total bijective Function domains F nested arbitrarily function variable simply mapping nonnested domains like integers enumerations Fiona support multiple alternative reﬁnements function domains selects number heuristics Fiona generates single output model heuristics If function variable reﬁned multiple ways single model Fiona able generate channelling constraints automatically The constraint language closely resembling Essence Zinc 28 Both languages support type constructors nested arbitrary depth number type constructors common sets arrays tuples Essence supports abstract decision variables Zinc example multiset partition function relation type constructors Zinc modelled constrained collection variables primitive type 22 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 Quantiﬁcation decision variables Essence supports vital concision dealing variables nested domains Essence Zinc provide similar selection atomic types Zinc supports ﬂoats Essence unnamed types 120 unique Essence Zinc extensible userdeﬁned functions predicates feature Essence lacks Work reﬁning Zinc focused production models different solving paradigms mixed inte ger programming constraint programming local search 1212930 alternative reﬁnement pathways particular type solver De Koninck et al plans use annotations guide use alternative reﬁnements manually 29 Hernández 122 considers problem channelling different representations highlevel variables She produces similar results implementation Conjure produces channelling constraints reﬁning X X left right X different representations 82 Encoding Constraint Models Other Formalisms A related body work seeks encode given constraint model formalism mixed integer program ming MIP propositional satisﬁability SAT SAT modulo theories SMT In selecting variables constraints constraint model encoded approach shares concerns reﬁnement abstract speciﬁ cations described The substantial difference lower level abstraction input One popular method solving constraint problems encode SAT employ SAT solver The key considerations ﬁrst way CP variables variables constraint model encoded set SAT variables associated clauses second constraints encoded SAT clauses additional SAT variables necessary The simplest scheme introduces SAT variable domain value CP variable 123 adding clauses ensure CP variable takes exactly value An important alternative log encoding 124 represent variable domain size n cid7log2 ncid8 SAT variables Another alternative order encoding SAT variable indicates CP variable greater constant 125127 The order encoding useful inequality reasoning important There extensive literature encoding constraints SAT including generic encodings arbitrary constraints direct support encodings 123124128 Specialpurpose encod ings particular constraint types vastly outperform generic encodings example cardinality networks counting constraints 129 compact order encoding sums 130 Picat notable log encod ing 131 The availability encodings suggests automatic selection encodings important It complementary automatic generation selection models Proteus 132 meSAT 133 Satune 134 examples systems automatically select SAT encodings SMT solvers remarkable progress recent years making SMT attractive target encoding constraint models FZN2OMT 135 translates FlatZinc language SMT SRSMT 136 component Savile Row 16 outputs SMT Both systems able target multiple theories multiple SMT solvers Selection encodings similarly important encoding SMT SAT Encoding constraint modelling languages MIP linearization long history OPL early example 137 OPL able linearize entire OPL language More recently Rafeh Jaberi 30 presented LinZinc library linearize Zinc language entirety Belov et al 138 presented linearization MiniZinc For constraint types allDifferent linearization constraint requires 01 variable domain value CP variable scope similar direct SAT encoding In contrast SAT SMT issue selection multiple encodings discussed works 13730138 A related ﬁeld speciﬁcation languages extensively formalising computing systems Speciﬁ cation languages Z 139 VDMSL 140 describing general computing systems These languages typically allow lambda expressions set theoretic operators ﬁrstorder logic In comparison Essence problem spec iﬁcation language domain combinatorial problem solving offers speciﬁc features decision variables rich selection ﬁnite domains operators posting variety constraints decision variables Generic formal speciﬁcation languages typically encode decision problems instead encode properties required true enable formal proofs properties 9 Conclusions Future Work In paper presented automated constraint modelling Conjure It employs set reﬁnement rules transform speciﬁcation parameterised problem class abstract constraint speciﬁcation language Essence concrete constraint model By varying selection application rules Conjure produce set alternative models We demonstrated large set problem classes vast majority cases set produced includes formulated human experts literature Furthermore presented heuristic effective model selected A particular advantage approach treatment symmetry Much symmetry typically present constraint model arrives process modelling 33 Conjure recognises removes symmetry enters model removing need expensive symmetry detection step following model formulation 23 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 approaches 14137 Furthermore symmetry breaking constraints added model valid entire problem class single instance An important item future work treatment symmetry arising unnamed types Another important item future work informed method model selection complement datafree heuristic presented Following practice algorithm selection 142 set training instances problem class learn select effective model unseen instance problem class Declaration competing The authors declare known competing ﬁnancial interests personal relationships appeared inﬂuence work reported paper References 1 F Rossi P Van Beek T Walsh Handbook Constraint Programming Elsevier 2006 2 EC Freuder Progress holy grail Constraints 23 2 2018 158171 3 Z Kiziltan M Lippi P Torroni Constraint detection natural language problem descriptions IJCAI 2016 pp 744750 4 L De Raedt A Passerini S Teso Learning constraints examples Proceedings ThirtySecond AAAI Conference Artiﬁcial Intelligence AAAI New Orleans USA 2018 pp 0207 5 C Bessiere F Koriche N Lazaar B OSullivan Constraint acquisition Artif Intell 244 2017 315342 6 R Arcangioli C Bessiere N Lazaar Multiple constraint aquisition IJCAI International Joint Conference Artiﬁcial Intelligence 2016 pp 698704 7 N Beldiceanu H Simonis A model seeker extracting global constraint models positive examples 18th International Conference Principles Practice Constraint Programming 2012 pp 141157 8 C Bessiere R Coletta E Hebrard G Katsirelos N Lazaar N Narodytska CG Quimper T Walsh Constraint acquisition partial queries IJCAI2013 23rd International Joint Conference Artiﬁcial Intelligence 2013 p 7 9 C Bessiere R Coletta A Daoudi N Lazaar Boosting constraint acquisition generalization queries Proc 21st European Conference Artiﬁcial Intelligence 2014 pp 99104 pp 476482 10 K Shchekotykhin G Friedrich Argumentation based constraint acquisition 2009 Ninth IEEE International Conference Data Mining 2009 11 A Rendl Thesis Effective Compilation Constraint Models PhD thesis University St Andrews 2010 12 N Nethercote PJ Stuckey R Becket S Brand GJ Duck G Tack MiniZinc standard CP modelling language Proceedings 13th International Conference Principles Practice Constraint Programming CP2007 2007 pp 529543 13 P Van Hentenryck The OPL Optimization Programming Language MIT Press Cambridge MA USA 1999 14 P Mills EPK Tsang R Williams J Ford J Borrett EaCL 15 Easy Abstract Constraint Optimisation Programming Language Tech Rep University Essex Colchester UK dec 1999 15 P Nightingale Ö Akgün IP Gent C Jefferson I Miguel Automatically improving constraint models Savile Row associativecommutative common subexpression elimination 20th International Conference Principles Practice Constraint Programming CP 2014 Springer 2014 pp 590605 16 P Nightingale Ö Akgün IP Gent C Jefferson I Miguel P Spracklen Automatically improving constraint models Savile Row Artif Intell 251 17 P Nightingale P Spracklen I Miguel Automatically improving SAT encoding constraint problems common subexpression elimination Savile Row Proceedings 21st International Conference Principles Practice Constraint Programming CP 2015 Springer 2015 pp 330340 18 AM Frisch I Miguel T Walsh Cgrass transforming constraint satisfaction problems Recent Advances Constraints Springer 2003 19 S Colton I Miguel Constraint generation automated theory formation International Conference Principles Practice Constraint Programming Springer Berlin Heidelberg 2001 pp 575579 20 J Charnley S Colton I Miguel Automatic generation implied constraints ECAI Vol 141 2006 pp 7377 21 C Bessiere R Coletta T Petit et al Learning implied global constraints 20th International Joint Conference Artiﬁcial Intelligence 2007 2017 3561 pp 1530 pp 4449 22 K Leo C Mears G Tack MG De La Banda Globalizing constraint models International Conference Principles Practice Constraint Programming Springer 2013 pp 432447 23 J Little C Gebruers DG Bridge EC Freuder Using casebased reasoning write constraint programs Proceedings 9th International Confer ence Principles Practice Constraint Programming CP2003 2003 p 983 24 AM Frisch C Jefferson B MartinezHernandez I Miguel The rules constraint modelling LP Kaelbling A Saﬃotti Eds Proc IJCAI 2005 Professional Book Center 2005 pp 109116 httpwwwijcai org papers 1667pdf 25 P Flener J Pearson M Ågren Introducing esra relational language modelling combinatorial problems M Bruynooghe Ed LOPSTR 2003 Lecture Notes Computer Science vol 3018 Springer 2003 pp 214232 26 AM Frisch W Harvey C Jefferson B MartínezHernández I Miguel Essence constraint language specifying combinatorial problems Con straints 13 3 2008 268306 httplinkspringercom article 10 1007 s10601 008 9047 y 27 B Hnich Thesis function variables constraint programming AI Commun 16 2 2003 131132 28 K Marriott N Nethercote R Rafeh PJ Stuckey MG la Banda M Wallace The design zinc modelling language Constraints 13 3 2008 29 LD Koninck S Brand PJ Stuckey Data independent type reduction zinc Proceedings 9th International Workshop Reformulating 229267 httpsdoi org 10 1007 s10601 008 9041 4 Constraint Satisfaction Problems 2010 social golfer problem CPAIOR02 Citeseer 2002 Constraint Programming Springer 1996 pp 91103 Symmetry Conference 2007 30 R Rafeh N Jaberi LinZinc library linearizing zinc models Iran J Sci Technol Trans Electr Eng 40 1 2016 6373 31 M Sellmann W Harvey Heuristic constraint propagationusing local search incomplete pruning domain ﬁltering redundant constraints 32 B Cheng JHM Lee J Wu Speeding constraint propagation redundant modeling International Conference Principles Practice 33 AM Frisch C Jefferson B MartinezHernandez I Miguel Symmetry generation constraint models Proceedings International 24 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 mulation Approximation Springer 2005 pp 165181 Constraint Programming Springer 2011 pp 591605 2015 235273 34 O Akgun AM Frisch IP Gent BS Hussain C Jefferson L Kotthoff I Miguel P Nightingale Automated symmetry breaking model selection Conjure Proceedings 19th International Conference Principles Practice Constraint Programming CP 2013 2013 pp 107116 35 O Akgun IP Gent C Jefferson I Miguel P Nightingale Breaking conditional symmetry automated constraint modelling Conjure Pro ceedings 21st European Conference Artiﬁcial Intelligence ECAI 2014 pp 38 36 T Mancini M Cadoli Detecting breaking symmetries reasoning problem speciﬁcations International Symposium Abstraction Refor 37 C Mears T Niven M Jackson M Wallace Proving symmetries model transformation International Conference Principles Practice 38 C Mears MG la Banda M Wallace B Demoen A method detecting symmetries constraint models generalisation Constraints 20 2 39 AM Frisch B Hnich I Miguel BM Smith T Walsh Towards csp model reformulation multiple levels abstraction Proceedings International Workshop Reformulating Constraint Satisfaction Problems 2002 pp 4256 40 AM Frisch I Miguel T Walsh Reﬁning abstract speciﬁcations constraint satisfaction problems Proceedings Tenth Workshop Auto mated Reasoning 2003 pp 2931 41 A Bakewell AM Frisch I Miguel Towards automatic modelling constraint satisfaction problems based compositional reﬁnement Notes 2nd International Workshop Modelling Reformulating Constraint Satisfaction Problems CP03 PostConference Workshop 2003 42 AM Frisch B Hnich I Miguel BM Smith T Walsh Transforming reﬁning abstract constraint speciﬁcations 6th Symposium Abstraction 43 AM Frisch M Grum C Jefferson BM Hernández I Miguel The sssence Essence Proceedings 4th International Workshop Modelling Reformulation Approximation Springer 2005 pp 7691 Reformulating Constraint Satisfaction Problems 2005 pp 7388 44 AM Frisch M Grum C Jefferson BM Hernández I Miguel The design essence constraint language specifying combinatorial problems IJCAI Vol 7 2007 pp 8087 45 O Akgun AM Frisch B Hnich C Jefferson I Miguel Conjure revisited automated constraint modelling Proceedings 9th Interna tional Workshop Constraint Modelling Reformulation 2010 46 O Akgun I Miguel C Jefferson AM Frisch B Hnich Extensible automated constraint modelling W Burgard D Roth Eds AAAI 2011 Proceedings TwentyFifth AAAI Conference Artiﬁcial Intelligence AAAI 2011 San Francisco California USA August 711 2011 AAAI Press 2011 47 O Akgun Extensible automated constraint modelling reﬁnement abstract problem speciﬁcations PhD thesis University St Andrews 2014 48 IP Gent T Walsh CSPLib A Problem Library Constraints 2005 49 Özgür Akgün A Salamon Conjure documentation release 230 arXiv1910 00475 2019 50 P Nightingale A Rendl Essence description arXiv160102865 cs AI 51 IP Gent C Jefferson I Miguel Minion A fast scalable constraint solver Proceedings ECAI 2006 2006 pp 98102 52 Gecode Team Gecode generic constraint development environment available httpwwwgecode org 2006 53 G Chu PJ Stuckey A Schutt T Ehlers G Gange K Francis Chuffed available httpsgithub com chuffed chuffed 2018 54 G Audemard L Simon Predicting learnt clauses quality modern SAT solvers IJCAI 2009 pp 399404 55 R Martins V Manquinho I Lynce Openwbo A modular maxsat solver C Sinz U Egly Eds Theory Applications Satisﬁability Testing SAT 2014 Springer International Publishing Cham 2014 pp 438445 56 B Dutertre Yices 22 A Biere R Bloem Eds ComputerAided Veriﬁcation CAV2014 Lecture Notes Computer Science vol 8559 Springer 57 L De Moura N Bjørner Z3 eﬃcient smt solver International Conference Tools Algorithms Construction Analysis Systems 2014 pp 737744 Springer 2008 pp 337340 58 A Niemetz M Preiner A Biere Boolector 20 description J Satisf Boolean Model Comput 9 2014 5358 published 2015 59 YC Law JHM Lee Model induction new source CSP model redundancy Proceedings National Conference Artiﬁcial Intelligence AAAI Press MIT Press Menlo Park CA Cambridge MA London 1999 2002 pp 5461 60 BM Smith Handbook Constraint Programming Chapter Modelling 2006 61 J Crawford M Ginsberg E Luks A Roy Symmetrybreaking predicates search problems KR 96 1996 1996 148159 62 A Frisch B Hnich Z Kiziltan I Miguel T Walsh Global constraints lexicographic orderings International Conference Principles Practice Constraint Programming Springer 2002 pp 93108 63 P Flener AM Frisch B Hnich Z Kiziltan I Miguel J Pearson T Walsh Breaking row column symmetries matrix models Proceedings 8th International Conference Principles Practice Constraint Programming CP2002 2002 pp 462476 64 AM Frisch C Jefferson I Miguel Constraints breaking row column symmetries F Rossi Ed Proceedings 9th International Con ference Principles Practice Constraint Programming CP2003 Lecture Notes Computer Science vol 2833 Springer Berlin Heidelberg 2003 pp 318332 65 P van Hentenryck P Flener J Pearson M Agren Tractable symmetry breaking CSPs interchangeable values G Gottlob T Walsh Eds Proc IJCAI03 Morgan Kaufmann 2003 pp 277282 66 IP Gent T Kelsey S Linton I McDonald I Miguel BM Smith Conditional symmetry breaking P van Beek Ed Proceedings 11th Interna tional Conference Principles Practice Constraint Programming CP2005 Lecture Notes Computer Science vol 3709 Springer 2005 pp 256270 67 B Cheng KMF Choi JHM Lee J Wu Increasing constraint propagation redundant modeling experience report Constraints 4 2 1999 167192 faction Problems 2004 68 C Mears MG la Banda M Wallace On implementing symmetry detection Constraints 14 4 2009 443477 69 JC Beck SD Prestwich Exploiting dominance symmetric problems Fourth International Workshop Symmetry Constraint Satis 70 CW Choi JHM Lee PJ Stuckey Propagation redundancy redundant modelling International Conference Principles Practice Con straint Programming Springer 2003 pp 229243 71 M Dincbas H Simonis P Van Hentenryck Solving carsequencing problem constraint logic programming Proceedings 8th European Conference Artiﬁcial Intelligence ECAI 1988 1988 pp 290295 72 L Proll B Smith Integer linear programming constraint programming approaches template design problem INFORMS J Comput 10 3 1998 265275 pp 115146 73 H Zhang Specifying latin square problems propositional logic Automated Reasoning Its Applications Essays Honor Larry Wos 1997 74 I Dotú P Van Hentenryck A note low autocorrelation binary sequences International Conference Principles Practice Constraint Programming Springer 2006 pp 685689 75 BM Smith K Stergiou T Walsh Modelling Golomb Ruler problem Proc Workshop Non Binary Constraints IJCAI 99 1999 25 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 76 IP Gent I McDonald BM Smith Conditional Symmetry AllInterval Series Problem 2003 77 KN Brown Loading supply vessels forward checking unenforced guillotine cuts 17th Workshop UK Planning Scheduling SIG 78 H Simonis B OSullivan Search strategies rectangle packing International Conference Principles Practice Constraint Programming 79 BM Smith SC Brailsford PM Hubbard HP Williams The progressive party problem integer linear programming constraint programming 80 R Guy Unsolved Problems Number Theory Problem Books Mathematics Unsolved Problems Intuitive Mathematics Springer 2004 http 1998 Springer 2008 pp 5266 compared Constraints 1 12 1996 119138 books google uk books id 1AP2CEGxTkgC 81 W Hower Revisiting global constraint satisfaction Inf Process Lett 66 1 1998 4148 httpsdoi org 10 1016 S0020 019098 00023 4 82 IP Gent B Smith Symmetry Breaking During Search Constraint Programming Citeseer 1999 83 FA Azevedo A prototype general planning 2005 Portuguese Conference Artiﬁcial Intelligence IEEE 2005 pp 2432 84 T Walsh CSPLib problem 021 Crossﬁgures httpwwwcsplib org Problems prob021 85 SD Curtis BM Smith A Wren Constructing driver schedules iterative repair Proceedings Practical Application Constraint Logic 86 Ö Akgün I Miguel Modelling langfords problem viewpoint search Proceedings 17th International Workshop Reformulating 87 BM Smith Dual models permutation problems International Conference Principles Practice Constraint Programming Springer 2001 Programming PACLP Citeseer 2000 pp 5978 Constraint Satisfaction Problems 2018 pp 615619 88 A Schaerf Scheduling sport tournaments constraint logic programming Constraints 4 1 1999 4365 89 P Meseguer C Torras Exploiting symmetries constraint satisfaction search Artif Intell 129 12 2001 133163 90 B Hnich Z Kiziltan T Walsh Modelling balanced academic curriculum problem CPAIOR2002 2002 pp 121131 91 Z Kızıltan B Hnich Symmetry breaking rack conﬁguration problem Proceedings IJCAI2001 Workshop Modelling Solving Problems Constraints International Joint Conference Artiﬁcial Intelligence 2001 92 R Bosch M Trick Constraint programming hybrid formulations life designs Ann Oper Res 130 2004 4156 93 BM Smith A dual graph translation problem Life Proc 8th International Conference Principles Practice Constraint Pro gramming CP 2002 2002 pp 402414 94 G Chu PJ Stuckey A complete solution maximum density life problem Artif Intell 184185 2012 116 httpsdoi org 10 1016 j artint 2012 02 001 httpwwwsciencedirect com science article pii S0004370212000124 95 M Codish M Frank V Lagoon The DNA word design problem new constraint model new results C Sierra Ed Proceedings Twenty Sixth International Joint Conference Artiﬁcial Intelligence IJCAI 2017 Melbourne Australia August 1925 2017 ijcaiorg 2017 pp 585591 https doi org 10 24963 ijcai 2017 82 96 AM Frisch I Miguel T Walsh Symmetry implied constraints steel slab design problem Proc CP01 Wshop Modelling 97 A Gargani P Refalo An eﬃcient model strategy steel slab design problem International Conference Principles Practice Problem Formulation 2001 Constraint Programming 2007 pp 7789 98 BM Smith Constraint programming practice Scheduling rehearsal Research Report APES672003 APES group 2003 99 SA Tarim I Miguel Echelon stock formulation arborescent distribution systems application wagnerwhitin problem Interna tional Conference Integration Artiﬁcial Intelligence ai Operations Research Techniques Constraint Programming Springer 2004 pp 302318 100 CJ Colbourn Embedding partial steiner triple systems npcomplete J Comb Theory Ser A 35 1 1983 100105 101 B Hnich SD Prestwich E Selensky BM Smith Constraint models covering test problem Constraints 11 23 2006 199219 102 J Koji c Integer linear programming model multidimensional twoway number partitioning problem Comput Math Appl 60 8 2010 23022308 103 P Schaus JC Régin R Van Schaeren W Dullaert B Raa Cardinality reasoning binpacking constraint application tank allocation problem International Conference Principles Practice Constraint Programming Springer 2012 pp 815822 104 BM Smith JF Puget Constraint models graceful graphs Constraints 15 1 2010 6492 105 S Huczynska P McKay I Miguel P Nightingale Modelling equidistant frequency permutation arrays application constraints mathematics International Conference Principles Practice Constraint Programming Springer 2009 pp 5064 106 BM Smith Symmetry search network design problem International Conference Integration Artiﬁcial Intelligence AI Opera tions Research OR Techniques Constraint Programming Springer 2005 pp 336350 107 P Flener J Pearson LG Reyna Financial portfolio optimisation International Conference Principles Practice Constraint Programming Springer 2004 pp 227241 108 B Hoppe É Tardos The quickest transshipment problem Math Oper Res 25 1 2000 3662 109 M Heule T Walsh Symmetry solutions Proceedings AAAI Vol 10 2010 pp 7782 110 MR Dransﬁeld VW Marek M Truszczy nski Satisﬁability computing van der waerden numbers E Giunchiglia A Tacchella Eds Theory Applications Satisﬁability Testing Springer Berlin Heidelberg Berlin Heidelberg 2004 pp 113 111 P Toth D Vigo Models relaxations exact approaches capacitated vehicle routing problem Discrete Appl Math 123 13 2002 487512 112 BM Smith KE Petrie IP Gent Models symmetry breaking peaceable armies queens International Conference Integration Artiﬁcial Intelligence AI Operations Research OR Techniques Constraint Programming Springer 2004 pp 271286 113 M Grönkvist A constraint programming model tail assignment International Conference Integration Artiﬁcial Intelligence AI Operations Research OR Techniques Constraint Programming Springer 2004 pp 142156 114 P Van Hentenryck L Michel L Perron JC Régin Constraint programming opl Principles Practice Declarative Programming Springer 115 AM Frisch C Jefferson I Miguel Symmetry breaking prelude implied constraints constraint modelling pattern Proc ECAI 2004 2004 1999 pp 98116 pp 171175 116 C Bessiere R Coletta F Koriche B OSullivan Acquiring Constraint Networks Using SatBased Version Space Algorithm Proceedings National Conference Artiﬁcial Intelligence vol 21 AAAI Press MIT Press Menlo Park CA Cambridge MA London 1999 2006 p 1565 117 N Beldiceanu H Simonis A constraint seeker ﬁnding ranking global constraints examples Proceedings 17th International Conference Principles Practice Constraint Programming CP2011 Springer 2011 pp 1226 118 AM Frisch I Miguel T Walsh CGRASS transforming constraint satisfaction problems B OSullivan Ed International Workshop Constraint Solving Constraint Logic Programming Lecture Notes Computer Science vol 2627 Springer 2002 pp 1530 119 M Cadoli G Ianni L Palopoli A Schaerf D Vasile NPSPEC executable speciﬁcation language solving problems NP Comput Lang 26 2000 165195 httpciteseerist psu edu 71095 html 26 Ö Akgün AM Frisch IP Gent et al Artiﬁcial Intelligence 310 2022 103751 120 AM Frisch I Miguel The Concept Provenance Unnamed Indistinguishable Types sep 2006 121 R Becket S Brand M Brown GJ Duck T Feydy J Fischer J Huang K Marriott N Nethercote J Puchinger et al The roads leading rome solving zinc models solvers 7th International Workshop Constraint Modelling Reformulation 2008 122 B MartínezHernández B MartinezHernandez Thesis Systematic Generation Channelled Models Constraint Satisfaction PhD thesis Uni 123 J De Kleer A comparison atms csp techniques IJCAI Vol 89 Citeseer 1989 pp 290296 124 T Walsh Sat v csp Principles Practice Constraint ProgrammingCP 1894 2000 pp 441456 httplinkspringercom chapter 10 1007 versity York 2008 3 540 45349 0 _32 195221 httpsdoi org 10 1007 s10601 010 9105 0 Satisﬁability Testing Springer 2012 pp 456462 Programming Springer 2017 pp 671686 125 IP Gent P Nightingale A new encoding AllDifferent SAT Proc 3rd International Workshop Modelling Reformulating Constraint Satisfaction Problems CP2004 2004 pp 95110 126 C Ansótegui F Manyà Mapping problems ﬁnitedomain variables problems boolean variables SAT 2004 Seventh International Conference Theory Applications Satisﬁability Testing 1013 May 2004 Vancouver BC Canada Online Proceedings 2004 httpwww satisﬁabilityorg SAT04 programme 53 pdf 127 N Tamura A Taga S Kitagawa M Banbara Compiling ﬁnite linear CSP SAT Constraints An Int J 14 2 2009 254272 httpsdoi org 10 1007 s10601 008 9061 0 128 IP Gent Arc consistency SAT Proceedings 15th European Conference Artiﬁcial Intelligence ECAI 2002 2002 pp 121125 129 R Asín R Nieuwenhuis A Oliveras E RodríguezCarbonell Cardinality networks theoretical empirical study Constraints 16 2 2011 130 T Tanjo N Tamura M Banbara Azucar satbased csp solver compact order encoding International Conference Theory Applications 131 NF Zhou H Kjellerstrand Optimizing SAT encodings arithmetic constraints International Conference Principles Practice Constraint 132 B Hurley Exploiting machine learning combinatorial problem solving optimisation PhD thesis University College Cork 2016 133 M Stojadinovic F Maric meSAT multiple encodings CSP SAT Constraints 19 4 2014 380403 httpsdoi org 10 1007 s10601 014 9165 7 134 H Gorjiara GH Xu B Demsky Satune synthesizing eﬃcient sat encoders Proceedings ACM Programming Languages 4 OOPSLA 2020 135 F Contaldo P Trentin R Sebastiani From minizinc optimization modulo theories extended version CoRR arXiv1912 01476 abs pp 132 httparxivorg abs 1912 01476 136 E Davidson O Akgün J Espasa P Nightingale Effective encodings constraint programming models SMT Proceedings 26th Interna tional Conference Principles Practice Constraint Programming 2020 pp 143159 137 PV Hentenryck Constraint integer programming OPL INFORMS J Comput 14 4 2002 345372 138 G Belov PJ Stuckey G Tack M Wallace Improved linearization constraint programming models International Conference Principles Practice Constraint Programming Springer 2016 pp 4965 139 J Woodcock J Davies Z Using Speciﬁcation Reﬁnement Proof Prentice Hall International 1996 140 N Plat PG Larsen An overview ISOVDMSL standard ACM SIGPLAN Not 27 8 1992 7682 141 T Mancini M Cadoli Detecting breaking symmetries reasoning problem speciﬁcations Abstraction Reformulation Approximation Lecture Notes Computer Science vol 3607 Springer Berlin Heidelberg 2005 pp 165181 142 JR Rice The algorithm selection problem Adv Comput 15 1976 65118 27