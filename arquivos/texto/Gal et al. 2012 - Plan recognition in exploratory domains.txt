Artiﬁcial Intelligence 176 2012 22702290 Contents lists available SciVerse ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Plan recognition exploratory domains Yaakov Gal ab Swapna Reddy b Stuart M Shieber b Andee Rubin c Barbara J Grosz b Department Information Systems Engineering BenGurion University Negev Israel b School Engineering Applied Sciences Harvard University USA c TERC USA r t c l e n f o b s t r c t Article history Received 1 March 2010 Received revised form 8 August 2011 Accepted 11 September 2011 Available online 3 October 2011 Keywords Plan recognition User modeling This paper describes challenging plan recognition problem arises environments agents engage widely exploratory behavior presents new algorithms effective plan recognition settings In exploratory domains agents actions map logs behavior include switching activities extraneous actions mistakes Flexible pedagogical software application considered paper statistics education paradigmatic example domains settings exhibit similar characteristics The paper establishes task plan recognition exploratory domains NPhard compares approaches recognizing plans domains including new heuristic methods vary extent employ backtracking reduction constraintsatisfaction problems The algorithms empirically evaluated peoples interaction ﬂexible openended statistics education software schools Data collected adults software lab setting middle school students software classroom The constraint satisfaction approaches complete order magnitude slower heuristic approaches In addition heuristic approaches able perform 4 constraint satisfaction approaches student data classroom reﬂects intended user population software These results demonstrate heuristic approaches offer good balance performance computation time recognizing peoples activities pedagogical domain 2011 Published Elsevier BV 1 Introduction In paper report development evaluation algorithms recognizing users plans domains users engage exploratory errorprone behaviors The challenges presented domains evident work students openended software learning statistics arise human interaction broadly Indeed developing technology changing rote monolithic interaction styles computers users ﬂexible types interactions allow users explore interleave different activities Examples ﬂexible systems include interactive drawing tools 44 Integrated Development Environments IDEs collaborative writing assistants 4 games educational software 51 To effective partners systems need recognize activities users carrying use information provide support way guides users interactions effectively For example intelligent drawing tool Corresponding author School Engineering Applied Sciences Harvard University USA Email address galeecsharvardedu Y Gal 00043702 matter 2011 Published Elsevier BV doi101016jartint201109002 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 2271 infer objects canvas representatives class When user modiﬁes attribute forms identify duplicate change objects class Another beneﬁt recognizing users activities software provide assessments user performance Such capabilities educational pedagogical systems increase teachers abilities identify students having diﬃculty Classical approaches plan recognition assumed goaloriented agent activities consistent recognizers knowledge base forms single encompassing plan In contrast ﬂexible systems allow users follow multiple plans interleave actions different plans perform redundant actions tolerate user mistakes Thus inferring users plans systems gives rise complex sort plan recognition problem This paper presents new algorithms keyhole plan recognition exploratory domains1 The algorithms posthoc infer plans complete interaction sequences observed action online recognition 13 The algorithms present vary completeness plans guaranteed computational complexity We investigate tradeoff completeness complexity empirically comparing performance different plan recognition algorithms realworld data Our empirical analysis uses educational software statistics education Educational software increasingly designed openended ﬂexible order support types exploratory activities facilitate students learning experience This gives students resources explore concepts new ways interactions erratic unfocused making challenging recognize plans During chaos lab session impossible teachers track students progress As result diﬃcult adapt teaching students work Educational software provides important domain plan recognition A structured posthoc representation plans students activities enable teachers better pedagogical decisions classroom The research report commercial called TinkerPlots worldwide teach students grades 4 8 statistics mathematics 34 Using TinkerPlots students build stochastic models generate pseudo random samples analyze underlying probability distributions Our study different problems students interacted TinkerPlots model hypothetical situations determine probability events Students interactions TinkerPlots complex They pursue multiple plans interleave actions different plans They confused appropriate plan mistakes These behaviors create challenging domain plan recognition algorithms Any number extraneous actions interleaved successful plan In addition actions crucial successful plans occur order All algorithms presented paper compose possibly noncontiguous interaction sequences users teractions series interdependent tasks subtasks They infer students plans comparing interaction sequence ideal solutions recipes speciﬁed domain experts At end process algorithms output hierarchical plan explains students strategy session The algorithms separate actions contribute solving problem extraneous actions mistakes This paper integrates extends initial reports past studies 2343 makes contributions First formally deﬁnes task plan recognition exploratory domains provides proof NPcompleteness Second presents new greedy complete algorithms solving plan recognition problem domains providing formal com plexity analysis algorithms comparing existing methods Third ﬁrst work evaluate plan recognition algorithms realworld data domain ﬂexible pedagogical software We compared algorithmic approaches recognizing users interactions One approaches employed incom plete greedy algorithms attempt build plans bottomup The complexity algorithms polynomial size interaction sequence complexity algorithm exponential worst case size sequence The second approach converts recognition process Constraint Satisfaction Problem CSP methods One methods builds complete plan recognize entire interaction sequence The method works piecemeal way uses subsets activity sequence eliminate infeasible plans attempting recognize entire sequence This second method suggested Quilici et al 42 ﬁrst tested empirically In contrast greedy approach constraint satisfaction approach complete sense recipes solving given TinkerPlots problem exist student solved problem algorithm guaranteed ﬁnd plan explains students interaction The complexity complete methods exponential size interaction sequence data set containing ideal solutions We conducted number empirical studies evaluate ability algorithms recognize plans solve TinkerPlots problems The studies involved types settings adults TinkerPlots lab setting middle school students TinkerPlots classroom setting The results conﬁrmed complete algorithms able recognize plans relevant recipes TinkerPlots problems existed students able solve problems However systematic difference empirical settings effect plan recognition algorithms For adult data complete methods outperformed heuristic approaches 25 For student data reﬂects intended user population TinkerPlots difference 4 In addition heuristic approaches average order magnitude faster complete approaches data sets We 1 We use term keyhole plan recognition coined Cohen et al 17 refer fact acting agent signalling plan observer 2272 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 determinant runtime size interaction sequence heuristic approaches size plan database complete approaches Lastly interaction sequences obtained middle school students signiﬁcantly longer adults general students interactions corresponded complete solutions adults These results heuristic algorithms devised provide good balance performance time pedagogical software domain considered More generally demonstrate feasibility Artiﬁcial Intelli gence techniques support analysis users interaction ﬂexible openended software Although study uses type software techniques presented general support analysis users inter actions different types exploratory systems Our techniques value software designers researchers wish understand way people learn use software teachers After describing related work Section 11 introduce TinkerPlots software Section 2 highlighting properties characterize exploratory domain In Section 3 formal tools representing plans exploratory domains abstract problem recognizing plans relative idealized recipes achieving domain goals We Section 4 draw analogy plan recognition problem grammar recognition showing problem equivalent contextfree recognition variant interpretation grammars The analogy allows simple proof NPcompleteness plan recognition exploratory domains We present variety plan recognition algorithms problem Section 5 evaluate performance empirically data obtained users interactions TinkerPlots Section 6 demonstrating practicality best algorithms coverage speed 11 Related work Plan recognition cornerstone problem AI necessary component applications software help systems 737 story understanding 1650 natural language dialogue 1429 Early approaches assumed goal oriented agent activities consistent knowledge base formed single encompassing plan 33 36 A notable exception Pollack 39 allowed agents illformed plans achieving certain goals Brown Burton 12 allowed agents knowledge possibly incorrect We refer reader Carberry 15 detailed account approaches focus section recent works capture endemic qualities exploratory domains extraneous actions mistakes interleaving activities free order plan constituents We ﬁrst approaches considered temporal relationships actions agents plans Weida Litman 49 proposed method recognizing plans explicitly included ordering constraints plan library suggested criteria matching plans action sequences assuming action directed completing plans library AvrahamiZilberbrand Kaminka 3 encoded relationships action parameters plans tree structures provided methods plan recognition traverse tree manner temporally consis tent observations Another approach handling temporal relationships plans derives analogy plan recognition grammar recognition 4625 ImmediateDominanceLinearPrecedence IDLP grammars 24 languages allowed linear precedence free word ordering rule constituents Algorithms parsing IDLP grammars analogous recognizing plans times provide exponential savings compared considering possible order conﬁguration rule constituents 455 Pynadath Wellman 41 developed probabilistic grammar modeling agents plans included beliefs environment These techniques allow interleaving plans All reordering plan constituents works restricted local permutation constituent actions subplans Goldman et al 28 proposed probabilistic model plan recognition recognized interleaving actions output disjunction plansrather single hierarchyto explain action sequence It accounted missing observations seeing expected action candidate plan makes candidate plan likely The algorithm generative observation pending set possible hypotheses generated subsequently matched future observations Geib Goldman 26 augmented work allow recognize multiple instances plan addition interleaving actions This work provides bottomup algorithm maintains distribution set possible explanations matching users observations assuming agents toplevel goal known Our work distinct approach ways First settings studied Geib Goldman account agents extraneous actions endemic property exploratory domain consider paper Second probabilistic approach Geib Goldman complete considering observation sequences worstcase complexity exponential size grammar We provide heuristic algorithms exponentially eﬃcient complete approaches Our algorithms parameterfree designed ecologically realistic settings classrooms tuning learning parameters diﬃcult effort involved obtaining large amounts training data Third eﬃcacy approach realworld data obtained students adults pedagogical software Geib Goldman use synthetic data Several works probabilistic reasoning recognize students goals interacting pedagogical software Conati et al 18 Bayesian networks model students interactions intelligent tutor probabilistic infer ence recognize interleaving actions Albrecht et al 1 suggested probabilistic approach infer players goals future actions observation sequences They Dynamic Bayesian Networks compute posterior distribution Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 2273 Fig 1 Two sampler models rain possible goals given players actions game They able capture agents mistakes infer likelihood single goal action recognizing hierarchical plan representing entire action sequence Quilici et al 42 proposed algorithm implementing plan recognition constraint satisfaction problem evaluate real data We augment work ways First implementing algorithm ecologically realistic data adults middle school students pedagogical software Second describing alternative heuristic approaches complete algorithms exploratory domains provide balance completeness time comparing eﬃcacy algorithms complete CSP approach Lastly mention work intelligent tutoring systems community applied models students learning mathematics physics 198247 In domains tutor active participant students learning process ambiguities uncertainties students plan action resolved querying student By contrast TinkerPlots style educational software allows students learn exploratory openended manner explicit guidance software tutor Our approach addresses different problem nonintrusive recognition students activities given complete interaction histories software Past work recognition users goals systems focused ﬁxed strongly constrained settings UNIX command line syntax 9 applications medical diagnosis email notiﬁcations users tend adopt goals times 6 3135 In educational domains goals constantly evolving reﬂect new concepts diﬃcult collect studentspeciﬁc training data type goal 2 The TinkerPlots domain TinkerPlots educational software worldwide teach students grades 4 8 statistics mathematics 34 It provides students toolkit actively model stochastic events create investigate large number statistical models 30 As extremely ﬂexible application allowing data modeled generated analyzed ways openended interface To demonstrate approach recognizing activities TinkerPlots use following running example called rain rain The probability rain given day 75 Use TinkerPlots compute probability rain consecutive days This problem simple example drawn set problems posed students TinkerPlots schools subjects data collection procedure Two possible approaches modeling problem TinkerPlots shown Fig 1 One uses stochastic device multiple times uses multiple stochastic devices Fig 1a shows sampler object containing single spinner device Devices added sampler objects model distributions There types devices spinner devices recall distribution formed spinning dial The spinner device lefthand model contains possible events rain sun The likelihood rain times sun determined surface area events spinner Each draw sampler sample weather given day The number draws set making sampler stochastic model weather consecutive days 2274 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 Fig 2 Generating analyzing data rain problem Another possible approach modeling rain distribution presented Fig 1b shows sampler spinner devices Each devices stochastic model weather given day sampler set single draw draws device In approaches sampler contained devices model joint probability distribution weather consecutive days When sampler run generates data sampled according distribution deﬁned parameters model Fig 2a shows table object holding portion sample generated sampler models Fig 1 Each line table represents single repetition sampler consisting sun rain value days Fig 2b shows endresult process data plotted histogram purpose inferring likelihood consecutive days rain There approaches modeling rain distribution organizing resulting data As students interact TinkerPlots engaging direct manipulation interface create modify devices sample stochastic events graph results modify retry aspects ﬂuid manner kinds objects manipulated different orders false starts retries adding complexity exhibited behaviors The TinkerPlots metered log primitive direct manipulation actions user These logs constitute trace observable behavior user Our goal explain log terms problemsolving goal user engaged solving rain problem 3 Methods representation In section introduce representations algorithms describing TinkerPlots activities formal way 31 Actions recipes plans The nomenclature paper follows foundational planning terminology grounded philosophy 111020 The fundamental components deﬁne called basic actions atomic decomposed Complex actions higherlevel abstract activities decomposed subactions basic actions complex actions To emphasize distinction basic complex actions notate complex actions underline notation A recipe 40 complex action characterizes sequences actions result successful completion action The recipe complex action C set subactions S constraints R performing subactions constraints constitutes completing complex action We allow recursively deﬁned recipes recipe complex action C hereditarily include C subaction list S The set restrictions R constrains subactions completed expressing relationships parameters subactions hold Restrictions form Boolean relation subactions parameters includes mathematical equations inequalities A common type restriction uses inequalities pos position parameter actions limit order actions occur In absence ordering restrictions recipe completely freeordered Other restrictions enforce relationship object identiﬁers Tin kerPlots actions requiring example actions share parameter represent constraints imposed sampler object s To complete complex action C according recipe subactions S completed violating restrictions R We notate recipe complex action C subactions s1 sn restrictions R C s cid4 1 s cid4 n R Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 2275 ASis 11 pos 5 ADSis 11 id 2 td spinner pos 6 ALEis 11 id 2 1 le pos 7 ALEis 11 id 2 2 le b pos 8 ASis 9 pos 9 CELis 11 id 2 1 le rain pos 10 CELis 11 id 2 2 le sun pos 11 CPDis 11 id 2 ss 1 3 pos 12 ADSis 11 id 3 td mixer pos 13 Fig 3 A snippet action sequence taken users interaction TinkerPlots Basic actions ADS Add Device Sampler ALE Add Labelled Event AS Add Sampler CEL Change Event Label CPD Change Probability Device CSA Create Sampler Event A Complex actions AED Add Event Device CCD Create Correct Device Parameters id Device ID Event ID Sampler ID le Event Label td Device Type ss Subsection Size pos Temporal Position Fig 4 Action parameter abbreviation key cid4 s subaction si optional subscripts uniquely identify subactions The restrictions R use notation Ap refer value parameter p subaction A In case multiple subactions subscripts disambiguate Standard conventions notate multiple inequalities example b c2 A recipe library 11 contains complete set recipes complex actions domain Each complex action type multiple recipes library providing alternatives completion3 A plan hierarchical construction basic complex actions complete complex action called root action The plan completing root action C tree parametrized actions rooted C complex action decomposed subactions according recipe database 32 Representation TinkerPlots activities The nature questions rain teaching statistical skills TinkerPlots typically require students plan series activities derive answers Students interact TinkerPlots series operations create modify delete objects samplers plots tables Basic actions TinkerPlots refer rudimentary operations carried single keystroke mouse action It instances basic actions logged Examples basic actions TinkerPlots include creating new sampler generating random sample deleting plot Complex actions TinkerPlots activities adding spinner equally weighted events sampler ﬁtting sampler data plot solving rain problem We impute complex actions users software analysis users actions pursuing plans Users interactions TinkerPlots recorded ﬁnite chronological sequences basic actions performed users It action sequences constitute input plan recognition algorithm Fig 3 shows portion action sequence creating stochastic component called device sampler Fig 1a4 For example action ADSis 11 id 2 td spinner pos 6 Add Device Sampler refers action adding device identiﬁer id 2 type td spinner sampler identiﬁer 11 The pos parameter speciﬁes temporal position action action sequence case ADS sixth action performed user Fig 4 provides key abbreviations actions uppercase script parameters lowercase script paper In TinkerPlots domain recipe captures ideal sequence actions performing particular activity We repre sent basic complex action type TinkerPlots unique ADS basic action Add Device Sampler CCD complex action Create Correct Device parametrized features objects instance action refers We notate action parameters placing parameter values keyed 2 Our representations recipes restrictions similar classical planning formalisms Hierarchical Task Networks 27 allow recursion 3 Other works term plan library refer complete plan hierarchies agents root goal basic level actions example Nau et al 38 We use term recipe library refer set recipes 4 This sampler generate data Fig 2 2276 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 CCD ADS AED1 AED2 CPD ADSpos AED1pos AED2pos CPDpos ADSis AED1is AED2is CPDis ADSid AED1id AED2id CPDid CPDss 3 1 Fig 5 A recipe CCD Create Correct Device complex action AED ALE CEL ALEpos CELpos ALEis CELis ALEid CELid ALEie CELie Fig 6 A recipe AED Add Element Device complex action Fig 7 A possible plan CCD complex action parameter names brackets For example set subactions possible recipes solving rain includes creating sampler models weather consecutive days running sampler plotting results graph Examples samplers shown Figs 1a 1b An example graph shown Fig 2b Fig 5 shows recipe complex action CCD creates sampler shown Fig 1a It includes basic subactions ADS CPD complex AED Add Event Device actions This recipe contains restrictions The ﬁrst ordering restriction mandates device added sampler action ADS events added device action AED turn occur probability events changed action CPD The second restrictions require sampler device identiﬁers consistent actions fourth restriction requires surface area events resized 3 1 ratio The purpose giving TinkerPlots problems students test ability construct appropriate applicable models solving problem We treat recipes idealized descriptions use TinkerPlots solve problems construct ing plan achieving complex root action solving problem For example plan complex action CCD shown Fig 7 Here complex AED action decomposed subactions ALE CEL recipe shown Fig 6 The plan inferred students actions sequence shown Fig 3 results creation spinner device shown Fig 1a solving rain problem The ﬂexible nature TinkerPlots supports exploratory openended use software ways First students perform extraneous activities play salient solution problem For exam ple action ASis 9 pos 9 students action sequence Fig 3 plays role students plan Fig 7 Second students interleave subactions different complex actions For example plan Fig 7 ALEis 11 id 2 2 le b pos 8 action position 8 subaction complex action AEDis 11 id 2 2 le sun pos 11 temporally occurs actions ALEis 11 id 2 1 le pos 7 CELis 11 id 2 1 le rain pos 10 positions 7 10 subactions complex action AEDis 11 id 2 pos 10 Lastly stu dents mistakes solving problems succeed solving problem The combination different properties challenging recognize plans underlying students interactions TinkerPlots argue formally section Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 2277 4 Grammars complexity The general problem recognizing sequence basic actions embeds plan accords recipes database includes satisfying arbitrary set constraints This problem complex constraint satisfaction constraint language NPhard worse depending particular constraint language But solving restrictions plan recognition problem NPcomplete Geib Goldman 26 related plan recognition probleminvolving interleaving ordering restrictions extraneous actionsis NPhard simple reduction threedimensional matching grammar formalism plan tree grammars The extension context extraneous actions log allowed straightforward In section review extend Geib Goldman proof derive complexity result plan recognition exploratory domains For simplicity use simpler formal characterization plan tree grammars Geib Goldman We deﬁne grammar formalism like plan tree grammars allows interleaving unlike plan tree grammars temporal ordering restrictions This allows greatly simplify description formalism For concreteness formalism simple plan grammars A simple plan grammar structured exactly like contextfree grammar set terminal nonterminal symbols including speciﬁed start symbol plus set productions rewriting nonterminal symbol sequence terminals nonterminals As grammatical characterizations planning nonterminal symbols correspond complex actions terminal symbols basic actions Under analogy recipe corresponds grammatical production plan parse tree action sequence string parsed Reconstructing plan action sequence relative recipe library correspond parsing string relative grammar 48 Although simple plan grammars structured identically contextfree grammars language simple plan grammar deﬁned differently corresponding contextfree grammar manifest interleaving extrane ous actions Indeed think simple plan grammar alternate interpretation contextfree grammar notation The language simple plan grammar deﬁned steps First deﬁne base language simple plan grammar language corresponding contextfree grammar The language simple plan grammar set strings containing subsequence permutation string base language This simple deﬁnition captures exactly reordering interleaving extraneous action aspects plan recognition problem abstracting away temporal ordering constraints The reordering interleaving captured fact permutations base language strings language grammar The extraneous actions captured including supersequences language extra symbols constituting extraneous actions What captured simple plan grammars ordering restrictions It ordering restrictions greatly complicates deﬁnition plan tree grammars As ordering restrictions needed carry NPhardness proof simpler formalism suﬃcient showing plan recognition setting considering NPhard By way example consider following productions S M M M M b c M d e f M g h 1 If productions contextfree grammar grammar recognizes strings including strings abcdefghi abcabcabc However viewed simple plan grammar recognizes supersequences permutations strings including strings strings like adgbehcﬁ ihgfedcba aaaabcdefghiaa It easy problem string recognition simple plan grammars NPcomplete We extend proof Geib Goldman 26 uses reduction NPcomplete problem 3Dimensional Matching 3Dimensional Matching 3DM Given identically sized disjoint sets W w 1 wq X x1 xq Y cid4 M size q y1 yq set M W X Y exist matching consisting subset M elements M agree coordinate elements W X Y appear exactly M cid4 cid4 This problem shown NPcomplete Karp 32 We reduce instance 3DM simple plan grammar follows Given instance 3DM construct simple plan grammar nonterminals S start symbol M terminal symbols W X Y The productions grammar include element cid8w x ycid9 M M w x y production generating q instances nonterminal M q times cid2 cid3cid4 cid5 M M S 2 3 2278 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 Note base language grammar language productions viewed contextfree grammar comprises strings length 3q Thus string language includes elements W X Y occur exactly In addition construct string s w 1 wqx1 xq y1 yq containing elements W X Y exactly We ask string s admitted constructed grammar By way example simple plan grammar 1 exactly generated construction 3DM problem W d g X b e h Y c f M cid8a b ccid9 cid8d e f cid9 cid8g h icid9 The constructed string recognize adgbehcﬁ The construction property s admitted constructed simple plan grammar corre sponding 3DM instance solution In example constructed string adgbehcﬁ language simple plan grammar permutation abcdefghi base language The argument straightforward essentially Geib Goldman 26 variation lack ordering restrictions issue extraneous items If solution 3DM problem subset M M covers 3q elements W X Y By construction string base language includes elements The constructed string s permutation string language simple plan grammar cid4 If string s language simple plan grammar contextfree derivation permutation subset elements s Because strings base language length 3q length s base language string improper subset exactly elements s But case solution 3DM problem read contextfree derivation base language string The particular Mproductions derivation correspond M subset cid4 This proof differs Geib Goldman 26 ways First incorporate ordering constraints rule M w x y require w x x y These constraints necessary construction string recognized obeys constraints directly The true proof Geib Goldman 26 ordering constraints superﬂuous By observing superﬂuity ordering restrictions proof allow simpler grammar setup Second deﬁnition language simple plan grammar incorporates supersequences base language strings corresponding allowing extraneous actions logs plan recognition problem The original proof modiﬁed hold context forcing base language strings include exactly 3q elements constructed string recognized issue supersequences irrelevant Although simple plan grammar constructed admit strings longer 3q irrelevant argument string parsed length 3q Forcing string length 3q role S production analog Geib Goldman proof Along similar lines constructed grammar enforces condition elements M chosen distinct Mproduction reused constraint grammar necessary If duplication occur string generated repeated elements case derivation admit string recognized construction repeated elements We conclude simple plan grammar recognition NPhard The problem clearly NP constructed grammar polynomial size 3DM instance contextfree derivation base language permutation s serves polynomiallysized witness recognition problem Checking witness permutation s trivially polynomial time Thus plan recognition model recipes interleaved extraneous actions observed NPhard Indeed holds extraneous actions observed use proof Similarly use recursion grammar restriction nonrecursive recipes reduce complexity Finally use ordering restrictions proof satisfying restrictions makes recognition problem complex Given computational complexity plan recognition problem question arises solved practice problems scope confront realworld cases We turn heuristic plan recognition algorithms performance section 5 Plan recognition algorithms In section present plan recognition algorithms able handle interleaving extraneous actions endemic exploratory domains TinkerPlots All approaches use structure called plan tree representing reasoning recipes database essentially search tree capturing set possible plans consistent recipe database A plan tree types nodes nodes children represent actions carried complete recipe nodes children represent choice recipes completing action The root action C OR node For recipe C child node added root labeled subactions recipe The children node plan trees subaction A branch terminates basic action reached basic action recipe deﬁnition A partial plan tree CCD action shown Fig 8 The nodes contain set brackets nodes Triangles denote unﬁnished subtrees omitted expository convenience The plan creating spinner Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 2279 Fig 8 A partial plan tree CCD complex action t 0 P 0 X R C SortRecipesR 1 procedure BuildPlanR X 2 3 4 5 6 7 8 9 10 11 Pt1 OL Pt MC OL FindMatchR C OL MC null Add C Pt1 positioned MC MC Create branch C Pt1 Pt Remove Pt1 cid10 R recipe list X action sequence cid10 Pt list actions stage t cid10 R C recipe action C cid10 OL open list cid10 MC match cid10 action 12 13 MC OL FindMatchR C OL null t t 1 Fig 9 Bottomup plan recognition method object shown Fig 1a selecting leftmost child node This resulting plan mirrors plan shown Fig 7 51 Greedy algorithms We present greedy algorithms inferring users plans Informally speaking algorithms work bottomup start ing user log iteratively replacing set actions match subactions given recipe complex action recipe implements form new action list A bruteforce approach involve nondeterministically ﬁnding ways complex action imple mented action list For example recipe library rain problem includes recipes complex actions The different recipes rain problem form 167076 possible plans considering different orderings actions5 If consider possible orderings recipes 2109182681760 possible plans rain problem Naively considering possibilities infeasible6 The heuristic approaches presented section assumptions exploratory domains serve signiﬁcantly reduce complexity com pared bruteforce method However incomplete sense users construct valid plans algorithms fail infer At step t algorithms incrementally build plan maintaining ordered sequence actions denoted P t The action sequence P 0 representing ground level users plan denoted X During step algorithms attempt replace subsets actions P t complex actions represent Each complex actions P t partial plan explains activity users interaction Because recipe formalization allow recursion deﬁne ordering complex actions plan library reﬂects depth Speciﬁcally B constituent subaction complex action A recipes B appear recipes A ordering The heuristic algorithms consider recipes according order Both greedy algorithms based function BuildPlan shown Fig 9 constructing users plans bottomup BuildPlan takes inputs An action sequence X recipe library R The method calls SortRecipes topologically sort R depth lowest highest For recipe R C complex action C action list P t1 open list OL initialized actions P t The algorithm repeatedly tries ﬁnd match R C open list calling function FindMatchR C OL returns tuple MC OL representing actions MC match modiﬁed open list The methods shall 5 For example 16 possible ways complete CCD action possible recipes recipe library MS actions 6 While theoretically possible use string matching align recipes action sequences naive approach need consider prohibitive number possible orderings The complete approaches CSP algorithms session essentially perform matching eﬃciently 2280 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 Fig 10 Progression BuildPlan steps soon present FindMatch modify open list different ways If match exists BuildPlan removes actions MC P t1 replaces complex action C placed latest action match occurred In addition marks actions MC P t children action C P t1 Actions removed P t match according criteria deﬁned method FindMatch We provide possible types criteria algorithms Once matches R C algorithm moves recipe recipes considered Fig 10 shows stages BuildPlan procedure Edges shown complex actions step constituent actions previous step The ﬁrst stage titled P 0 contains basic user actions During second stage titled P 1 pairs noncontiguous basic ALE CEL actions matches complex AED actions This example interleaving actions P 0 ALE constituent second AED action positioned ALE CEL constituents ﬁrst AED action In stage match CCD action subactions consist ﬁrst ADS action complex AED actions CPD action Fig 10 deﬁnes structure similar ideal plan CCD action shown Fig 7 explicitly indicates interleaving action sequences AED actions includes redundant actions plan ASis 9 pos 8 BuildPlan greedy approach backtrack After chooses match C given recipe R C replaces actions P t1 complex action C looking ahead future stages As result algorithm fail ﬁnd match recipe necessary subaction committed match earlier stage The complexity BuildPlan algorithm dominated complexity FindMatch algorithm CFM discussed section Let R X number recipes R number actions action sequence X respectively Then BuildPlan calls FindMatch X times recipe yielding overall complexity O R X CFM BuildPlan 511 Matching algorithms We present possible matching algorithms implementing FindMatchR C OL process Both use Extends function Boolean function takes input action P partial match MC recipe R C It returns true P added MC 1 P corresponds constituent subactions R C MC 2 addition P MC violate recipe constraints R C For example basic action ADSis 11 id 2 td spinner pos 6 action sequence Fig 3 extends recipe CCD shown Fig 5 given MC The Boolean function FulﬁllsMC R C returns true MC complete match recipe R C We MC fulﬁlls R C Note MC include basic complex actions For example actions ADSis 11 id 2 td spinner pos 6 AEDis 11 id 2 td spinner pos 10 AEDis 11 id 2 td spinner pos 11 CPDis 11 id 2 pos 12 fulﬁll recipe CCD shown Fig 5 Both matching algorithms choose actions extend MC order allowed restrictions recipe R C In particular actions OL noncontiguous allows algorithms capture interleaving plans However methods differ way update action list OL build match The ﬁrst algorithm NoBktrkR C OL shown Fig 11 extension earlier algorithm proposed Gal et al 23 It receives input R C recipe complex action C open list OL initially equivalent action Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 2281 MC null P OL 1 procedure NoBktrkR C OL 2 3 4 5 6 Add P MC Remove P OL Extendsa P MC R C cid10 R C recipe OL open list cid10 P action cid10 MC partial match 7 8 9 10 11 12 FulﬁllsMC R C return MC OL MC null return null OL clear MC goto line 2 Fig 11 Algorithm ﬁnding match backtracking 6 7 8 9 10 11 12 13 14 15 1 procedure SomeBktrkR C OL return SomeBktrkRecR C OL null 2 3 procedure SomeBktrkRecR C OL MC 4 5 FulﬁllsMC R C return MC OL cid4 OL OL P OL cid4 remove P OL Extendsa P MC R C cid10 R C recipe OL open list cid10 MC partial match cid10 P action Add P MC MC OL FindMatchR C OL FulﬁllsMC R C return MC OL remove P MC cid4 MC return null OL Fig 12 Algorithm ﬁnding match depthﬁrst search CSA AS ADS ALE ASpos ADSpos ALEpos ASis ADSis ALEis ADSid ALEid ALEle A Fig 13 A recipe CSA Create Sampler event A complex action set P t1 NoBktrk removes actions open list places partial match MC Once removed open list actions reconsidered new recipe provided step t 27 The algorithm quadratic size action sequence X To consider worst case takes complete pass action list bounded size action sequence fulﬁll recipe Because recipes TinkerPlots nonrecursive number times recipe fulﬁlled bounded size action sequence Therefore complexity NoBktrk O X2 The second algorithm ﬁnding match called SomeBktrk Fig 12 performs complete depthﬁrst search given recipe R C open list OL It deﬁnes subfunction extends partial match MC single action makes recursive subfunction In contrast NoBktrk algorithm complete given recipe R C open list OL guaranteed ﬁnd match R C exists OL However SomeBktrk guarantee plan BuildPlan greedy Due BuildPlans lack forwardchecking backtracking time steps SomeBktrk assign action match early step permanently remove subaction open list SomeBktrk later unable fulﬁll crucial recipe requiring subaction match longer exists open list As example way algorithms differ consider recipe complex action CSA Create Sampler Event A creating sampler device single event labeled A shown Fig 13 Recall NoBktrk SomeBktrk algorithms extend current partial match choosing actions order interaction sequence meets recipe constraints Given action sequence shown Fig 3 SomeBktrk algorithm complete given recipe CSA action sequence ﬁnd following match includes sampler identiﬁer 11 device identiﬁer id 2 7 We hypothesized actions occur late interaction process salient actions occur earlier However practice traversing open list reverse order increasing order pos parameter yielded results 2282 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 ASis 11 pos 5 ADSis 11 id 2 td spinner pos 6 ALEis 11 id 2 1 le A pos 7 However NoBktrk decide add following actions partial match MC ADSis 11 id 3 td mixer pos 13 ASis 11 pos 5 The NoBktrk algorithm try ﬁnd ALEis 11 id 3 le A action relates device identiﬁer id 3 exist interaction sequence Therefore remove actions partial match consideration As result fail ﬁnd ASis 11 pos 5 action future calls able fulﬁll recipe To compute complexity SomeBktrk let S maximum number subactions recipe A ﬁrstdepth cid4 recursive X times Within recursive calls X 1 actions remain OL So X 1 seconddepth recursive calls ﬁrstdepth recursive yielding overall maximum XX 1 seconddepth recursive calls After S 1 recursive calls increasing depth match completed backtracking occur Within lowestdepth recursive X S 1 actions left consider So worstcase complexity SomeBktrk O X S 52 Complete algorithms In section present plan recognition algorithms complete Both algorithms work converting plan recognition problem constraint satisfaction problems standard techniques solution The conversion makes use Expand function shown Fig 15 convert plans ﬂat representations containing solely basic actions called expanded recipes Note like conventional counterparts expanded recipes include constraints deﬁned set actions The ﬁrst complete algorithm performs conversion naively second use cascade conversions signiﬁcantly reduce size expanded plans ExpandT A takes input plan tree T A complex action A returns set expanded recipes A Each node represents possible recipe parent node complex action For node Expand recursively generates expanded recipes subaction recipe This algorithms alternates subprocedures DirectSum Union Given recipe DirectSum procedure computes possible replacements complex subactions basic actions Each time complex action replaced DirectSum ensures restrictions involving complex action propagated subactions For example consider single recipe R A subactions B C D A B C D restrictions B D C D Suppose recursive calls Expand expanded recipes B E F expanded recipes C G H I J In case DirectSum return following expanded recipes A E G H D E I J D F G H D F I J D recipe including restriction E D F D place B D restriction including restriction G D H D I D J D place C D restriction Lastly Union subprocedure takes union expanded recipes generated recipe A An expanded recipe series basic actions associated restrictions user perform realize potential plan To create expanded recipe path traversed plan tree beginning root ending basic actions leaves This path provides trace plan corresponding expanded recipe For example expanded recipe achieved traversing plan tree Fig 8 choosing leftmost recipe node Notice path taken matches plan Fig 7 In expanded recipe complex AED action restrictions replaced basic actions ALE CEL corresponding restrictions shown Fig 14 The complexity Expand costly worst case Let S maximum number complex subactions recipe N maximum number recipes single complex action C number distinct complex actions A plan tree depth C 1 allow recursive recipes At lowest depth plan tree actions basic recipes At second lowest depth complex actions N expanded recipes N recipes contain complex subactions At lowest depth recipe complex action Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 2283 CCD ADS ALE1 CEL1 ALE2 CEL2 CPD ADS ALE1 ALE2 CPD CEL1 CEL2 CPD ADSis ALE1is CEL1is ALE2is CEL2is CPDis ADSid ALE1id CEL1id ALE2id CEL2id CPDid Fig 14 Expanded version CCD recipe 1 procedure ExpandT C ERsC 2 r j child C 3 4 5 6 ERsr j ai child r j ERsr j DirectSumExpandTai ERsr j cid10 T C plan tree action C cid10 ERsC expanded recipes C cid10 r j recipe cid10 ai action 7 8 9 ERsa UnionERsa ERsr j ERsa ERsa 10 return ERsa Fig 15 Algorithm generating expanded recipes 1 procedure ConvertToCSPEA S R X complex action A X action sequence 2 3 4 5 6 7 s S AddVariableAndDomains X r R AddRestrictionConstraintr s S AddRedundancyConstraints cid10 E A expanded recipe S restrictions R cid10 S set subactions cid10 R set restrictions Fig 16 Converting expanded recipe action sequence CSP contain S complex subactions subaction N recipes The DirectSum procedure creates N S expanded recipes recipe The Union procedure collects expanded recipes resulting recipe action resulting maximum NNS N S1 recipes At fourth lowest depth complex action N recipes S complex subactions Each S subactions contain NNS expanded recipes So DirectSum Union procedures create NNNS S N S 2S1 expanded recipes recipe Continuing reasoning toplevel action N recipes yielding overall complexity N O S C C1 i0 S cid6 521 Constraint satisfaction algorithms In section explain combine expanded recipe action sequence create constraint satisfaction problem CSP A solution resulting CSP plan representing users activities Formally CSP triple X Dom C X x1 xn ﬁnite set variables respective domains Dom D1 Dn set possible values corresponding variable D v set constraints C c1 cm limit 1 v values assigned set variables k The algorithm ConvertToCSP shown Fig 16 receives input expanded recipe E A action sequence X returns CSP If solution exists CSP subset actions X realize expanded recipe E A We ﬁrst create variables CSP use reference Fig 17 provides graphical representation CSP resulting action sequence Fig 3 expanded recipe Fig 14 We graphical layout suggested Dechter 21 Note parameters belonging actions pictured participate constraint Let S s1 sn R set subactions restrictions expanded recipe respectively Each action S unique variable CSP calling subroutine AddVariableAndDomains X Based expanded recipe variables added time ADS ALE1 CEL1 ALE2 CEL2 CPD These variables appear outlined graph Fig 17 Each variables domain derived actions action sequence For occurrence action s action sequence value added domain s CSP The righthand box Fig 17 gives resulting domain variable based action sequence Lastly add restrictions CSP For restriction r R actions s1 sm S constraint corresponding CSP variables added CSP AddRestrictionConstraintr subroutine At point strictions listed Fig 14 added including CPDss 3 1 Directed edges ﬁgure represent temporal constraints variables Undirected edges represent parametric constraints The edge ADS ALE1 expresses constraint ADS ALE1 constraint ADSis id ALE1is id 2284 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 Fig 17 CSP resulting action sequence expanded recipe 1 procedure CSPbruteT C X E ExpandT C 2 e E 3 4 5 6 7 8 C ConvertToCSPe X solution SolveC solution cid14 return solution return cid10 T C plan tree action C X action sequence cid10 E set expanded recipes cid10 C CSP Fig 18 Bruteforce algorithm T C CreateRecipeTreeC R Perform bottomup traversal T C OR node representing action A 1 procedure CSPpruneC R X 2 3 4 5 6 Cache solution A CSPbruteT A X A cached cid10 R recipe library X action sequence cid10 T C plan tree action C 7 8 9 solution A Prune parent A T A return solutionC Fig 19 Bottomup algorithm For variables corresponding action additional redundancy constraints added AddRedundan cyConstraint subroutine These constraints ensure variables assigned distinct values variables share domain An example constraint connecting ALE1 ALE2 variables requires variable assignments distinct pos parameters 522 Bruteforce algorithm A solution CSP provides match expanded recipe action sequence In section present algorithms use CSPs output plan action sequined X desired complex action C given set recipes R The ﬁrst algorithm shown Fig 18 takes bruteforce approach calling Expand generate expanded recipe C converting CSP solving CSP This algorithm returns ﬁrst solution CSP solution The complexity CSPbrute analyzed terms FindMatch2 Expand procedures Recall calling Expand results N O S C expanded recipes N maximum number recipes single complex action In worst case expanded recipes considered expanded recipe CSP solver run The complexity CSP solver bounded complexity complete backtracking search seen X S So overall worstcase complexity CSPbrute N O S C O X S 523 Pruning algorithm The second algorithm shown Fig 19 takes sophisticated approach traverses plan tree bottomup At node algorithm determines user completed corresponding subaction calling CSPbrute referring cached result earlier CSPbrute If user failed complete subaction algorithm prunes relevant recipe parent current node tree user complete recipe completing subaction recipe By eliminating branches plan tree desired complex action C pruning process narrows search space possible expanded recipes root action C This algorithm suggested Quilici et al 42 The CSPprune method calls CSPbrute algorithm distinct complex subaction Let C represent number distinct complex subactions recipe list Then worstcase complexity pruning method N O S C O CX S The worst case occurs user completed C complex actions causing poten Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 2285 Table 1 Number possible plans problem maximal number complex actions recipe S maximal number recipes single complex action N maximal number distinct complex actions C rosa rain earrings seatbelts possible plans O 26 O 217 O 211 O 212 S 4 4 4 4 N 2 2 2 4 C 13 6 6 6 tial expanded recipes eliminated However hypothesized users likely solve TinkerPlots problems complex actions plan trees matched action sequence 6 Evaluation The plan recognition problem inherent domains TinkerPlots agents engaged exploratory behavior false starts addition successful plan construction leads shown NPcomplete computation The algorithms presented previous section incomplete complete intended allow solution realworld problems practice despite complexity issue inherent problem To determine realworld performance collected actual logs TinkerPlots usage standard pedagogical problems compared algorithms coverage performance The results best algorithms excellent coverage practical performance 61 Experimental design We collected interaction sequences peoples interaction TinkerPlots different settings The ﬁrst setting included 12 adults wide variety educational backgrounds ranging high school postgraduate education The second setting included 12 eighth grade students middle school Cambridge MA8 Each adult subject received identical 30minute tutorial TinkerPlots asked complete problems succession problems detailed Appendix A Students given slightly longer 45 minute demonstration software asked solve problems User logs videos users screens recorded user sessions TinkerPlots equipped logging facility records basic actions users action sequences To evaluate plan recognition algorithms manually traced videos interaction TinkerPlots We noted problem solved constructed possibly multiple plans solve problem We deﬁne recognition algorithm correct plans outputs exactly corresponds plans constructed videos fails output plan student successfully complete problem determined expert9 If user solved problem different ways recognition algorithm deemed correct recognizes solutions We created set recipes TinkerPlots problems study serve input plan recognition algorithms Our purpose study evaluate algorithms matching ideal solutions appropriate basic level actions users interaction sequences Therefore recipes manually constructed created prior collection informed data peoples interactions TinkerPlots Rather represented perceived priori broad range possible solutions TinkerPlots problems Ultimately database contained recipes suﬃcient explain user interactions The lack inclusion recipes discussed Section 622 The recipe library run recognition algorithms problem consisted recipes constructed problem This corresponds knowing TinkerPlots problem students trying solve This assumption logical context pedagogical software10 62 Results discussion We compared performance recognition algorithms presented called NoBktrk SomeBktrk CSPbrute CSPprune techniques11 We analyzed user logs corresponding problems outlined Appendix A Table 1 lists features problem affect complexity analysis Section 511 The analyzed user logs ranged length 14 80 actions The average length interaction sequence prob lems collected adult subjects 35 actions Adults solved assigned problems 70 time In contrast 8 Appropriate IRB approval obtained settings parental consent obtained data collected eighth graders 9 The domain expert researcher educational technology worked TinkerPlots years For action sequence expert shown movie desktop user plan outputted algorithm 10 Dropping assumption corresponds running algorithms recipe data base contains complete set recipes problems This affect correctness greedy algorithms complete algorithms 11 We pythonconstraint package created Gustavo Niemeyer available httplabixorgpythonconstraint implement constraint satisfaction algorithms 2286 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 Table 2 Accuracy recognition algorithms percentage Parenthesized numbers number logs Data Problem Algorithm NoBktrk SomeBktrk CSPbrute CSPprune Adults Students Adults rosa rain seat belts earrings Overall 23 16 12 11 62 78 88 42 91 76 18 14 5 10 47 87 88 67 100 85 20 14 8 11 53 100 100 75 100 95 23 16 9 11 59 100 100 75 100 95 23 16 9 11 59 Fig 20 Performance data obtained students left adults right average length interaction sequence problems collected students 68 actions Students solved signed problems 60 time Also people engaged exploratory behavior software For example average 15 exogenous actions problem obtained adults Table 2 shows accuracy recognition algorithms data collected students adults As shown table heuristic algorithms NoBktrk SomeBktrk correct 47 62 76 53 62 85 interactions spectively The heuristic algorithms outperformed CSPbruteForce CSPprune algorithms performed correctly 59 62 95 interactions The incorrect inferences algorithms false negatives algo rithms unable ﬁnd solutions existing interaction sequence All solutions outputted algorithms matched experts opinion activities students The constraint satisfaction algorithms guaranteed ﬁnd users plans exist provided relevant recipes contained recipe database Each incorrect inferences algorithms traced recipes missing database In addition incorrect inferences missing recipes incomplete approaches suffered prematurely committing match able backtrack An example case occurred frequently seat belts problem Appendix A This problem required user construct conditional distribution representing fact people wearing seat belts likely hurt accident Some users created sampler wrong distribution parameters proceeded correct parameter settings The incomplete approaches tended match subrecipes creating sampler actions corresponding wrong parameters Consequently failed ﬁnd matches sampler construction recipe In contrast CSP algorithms able backtrack pick right match expanded sampler construction recipe 621 Performance algorithms ecologically realistic data There signiﬁcant difference performance heuristic algorithm data obtained adults data obtained middle school students Fig 20 shows average accuracy plan recognition algorithms student data left 19 instances adult data right 20 instances problems rosa rain12 The ﬁgure details performance algorithms correctly identifying successful solutions true positives correctly identifying failed solutions true negatives incorrectly identifying failed solutions false negatives As shown Fig 20 heuristic algorithms able recognize unsolved problems true negatives There 6 cases adult data 12 cases student data More generally student data accuracy heuristic algorithms averaged 96 4 lower accuracy complete CSP algorithms data However adult data average accuracy heuristic algorithms 75 signiﬁcantly lower average accuracy CSP algorithms This apparent Table 3 compares precision recall measures different approaches student adult data All algorithms achieved perfect precision 12 We performed analysis problems student adult data Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 2287 Table 3 Precision left recall right measures student adult data Data Student Adult Algorithm NoBktrk 1 086 1 057 SomeBktrk 1 086 1 071 CSP 1 1 1 1 false positive classiﬁcations described The complete CSP algorithms achieved perfect recall incur false negatives For heuristic approaches NoBktrk SomeBktrk algorithms achieved lower recall measures CSP approaches student adult data However average recall measure achieved heuristic approaches student data signiﬁcantly higher average recall achieved adult data To explain effect type setting plan recognition algorithms compared number times students adults able solve problems assigned As shown Fig 20 students able solve TinkerPlots problems adults students 12 data instances represented failures total 19 instances adults 6 data instances represented failures total 20 instances We attribute fact students likely engage exploratory behavior mistakes Tinker Plots attested longer interaction sequences Thus explanation success heuristic algorithms analyzing student data true negative classiﬁcations student data recognizable recognition algorithms However performance heuristic algorithms student data attributed solely fact true negative classiﬁcations student data Both heuristic algorithms achieved higher accuracy rates students adults data instances representing true positives As shown Fig 20 student data heuristic algorithms able recognize 6 7 true positive instances average accuracy 85 able recognize 8 10 14 true positive instances average accuracy 65 adult data Thus NoBktrk SomeBktrk algorithms better recognizing successful unsuccessful plans students adults These results provide additional support applicability algorithms showing particularly suitable data obtained ecologically realistic fashion lab setting 622 Limitations approaches A signiﬁcant hurdle accurate recognition diﬃculty expressing certain types user strategies recipes As previously mentioned greedy constraint satisfaction algorithms susceptible fact recipe database failed capture possible ways people solved problems Because allow recipes deﬁned recursively recipes specify ﬁxed variable number actions occur In rain problem instance possible samplers model probability rain 75 A natural solution Fig 1a unique events rain sun causing rain weighted times likely sun In actuality proportional number rain sun events suﬃce long rain times likely sun This limitation prevented library succinctly expressing inﬁnite number permissible strategiesthree studentsfor seat belts problem Although falsepositive classiﬁcations experimental sessions happen theory One reason recipe language express actions occur For example rosa problem requires user create device events labeled R O S A If ﬁfth event added sampler longer correct However recognition algorithms incorrectly match actions corresponding previous values recipe creating sampler It possible construct plans recipes happen practice disallowed software For example interleaved actions add delete preconditions Finally note recipes designed approximately correct user approaches For example problem required users add identically labeled events device specifying label One user failed complete task according recipe database event labels pierced sic piecred Despite oversight teacher likely consider strategy successful However algorithms unable distinguish mistake conceptual mistakes One way overcome diﬃculties search closest plan explaining users TinkerPlots activities terms recipes searching complete correct plans This ﬂexible CSP solvers search solutions minimize number violated constraints 623 Performance considerations In section compare performance incurred practice recognition algorithms presented measured runtime commodity By working recognize interleaving plans user logs containing incor rect strategies 80 actions test worstcase exponential complexity presents signiﬁcant barrier realworld plan recognition In Table 4 present runtimes algorithms organized increasing theoretical computational complexity These results averaged action sequences problem 2288 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 Table 4 Average runtime seconds recognition algorithms Problem rosa rain seat belts earrings Overall Algorithm NoBktrk 015 035 002 001 013 334 054 034 182 154 Table 5 Average number CSPs variables constraint satisfaction algorithms Problem rosa rain seat belts earrings Overall CSPbrute CSPs 19 9300 347 292 2490 Variables 18 29 23 21 23 SomeBktrk CSPbrute CSPprune 011 13154 607 692 3675 CSPprune CSPs 14 141 298 176 157 009 2188 842 399 802 Variables 4 9 11 14 10 As shown table average runtime heuristic approaches employed limited backtracking signiﬁcantly faster complete approaches Within complete approaches pruning algorithm signiﬁcantly faster bruteforce algorithm This deadends recipe tree pruning algorithm able exploit As seen table CSPprune outperformed CSPbruteForce algorithm reasonable time despite having greater worstcase complexity However cases pruning approach fails eliminate branches plantrees turn slower bruteforce approach For example shown table seat belts problem CSPbruteForce algorithm faster CSPprune algorithms To examine relationship runtime student interaction length measured correlation variables algorithm The heuristic algorithms NoBktrk SomeBktrk showed positive correlations runtime interaction length 752 508 respectively The CSPbruteForce algorithm showed negative correlation 333 CSPprune showed weak positive correlation 050 Also shown Table 4 complete approaches signiﬁcantly slower running rain running problem The number possible plans rain shown Table 1 signiﬁcantly higher number possible plans problems These results support complexity ﬁndings bottleneck incomplete algorithms size users interaction log bottleneck complete algorithms complexity recipe library These results demonstrate applicability algorithms actual classrooms As shown Table 1 number possible plans TinkerPlots problems large Despite fact almostperfect record heuristic approach short runtime complete approaches instances speaks overall performance Lastly compare performance constraint satisfaction algorithms Table 5 presents additional statistics average number CSPs built log average number variables contained CSP CSPprune outperforms CSPbruteForce category building fewer smaller CSPs average 7 Future work conclusion This paper investigated class plan recognition problems domains agents engage widely exploratory behavior We showed constraint satisfaction algorithms viable practical approach plan recognition domain educational software application These algorithms able correctly capture users plans realworld logs users sessions reasonable time despite theoretical worstcase behavior ﬂexible nature software The algorithms compared favorably faster greedier approaches This work ﬁrst step pedagogical agent truly collaborative sense provides useful machinegenerated support teachers students For teachers support consists information students formance class For example presenting teachers visualization students plans convey students solved particular problem quickly possible analyze snap shots Teachers beneﬁt fact algorithms capture false starts incorrect solutions alerting mistakes misconceptions students Existing systems assessing students performance pedagogical soft ware work highly constrained settings report simple statistics number correct answers solved 22 Our work extends systems exploratory domains students performance explained infer ring plans In recent user study conducted teachers TinkerPlots classroom teachers favored planbased presentation types visualizations seeing selected snapshots students work Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 2289 We currently extending results ways First developing methods presenting plan recognition output teachers order provide broad organized view students activities Second evalu ating ability algorithms generalize different pedagogical software teaching chemistry college students 51 This work raises new opportunities involving use plan recognition algorithms basis building intelligent tutors augment existing software tools mathematics education These collaborative tutors provide machinegenerated support decides intervene students based teachers feedback plans inferred They contribute thoughtful analysis probabilistic models students increased ability teachers identify students beneﬁt teacher advice Together abilities lead improvements teaching learning Acknowledgements This work supported NSF grant number REC0632544 We indebted Craig Miller developing Tinker Plots logging facility Thanks anonymous reviewers helpful comments Thanks Elif Yamangil assisting development greedy algorithm Cliff Konold helpful discussions A special thanks goes Ofra Amir reading commenting previous drafts work Appendix A Experimental problems We TinkerPlots questions posed subjects considered empirical evaluation algorithms rosa rain Jessica 4 letters printed cards R O S A After mixing blindly picks 4 letters time arranges line order chose Build TinkerPlots model use help estimate probability Jessica spelling word ROSA There 75 chance rain 4 days Build TinkerPlots model use help estimate probability getting rain 4 days seatbelts If accident likely injured wearing seat belt Build TinkerPlots model people 1 wearing seat belts 2 injured accident injured accident Design factory people wearing seat belts likely injured wearing In model probability people injured accident What probability injured accident wearing seatbelt earrings Build TinkerPlots factory 1 makes people girls boys 2 pierces ears According model probability 1 boy pierced ear 2 girl pierced ear According model approximately fraction people meet street pierced ears References 1 DW Albrecht I Zukerman AE Nicholson Bayesian models keyhole plan recognition adventure game User Modeling UserAdapted Interaction 8 1 1998 547 2 JR Anderson AT Corbett KR Koedinger R Pelletier Cognitive tutors Lessons learned The Journal Learning Sciences 4 2 1995 167207 3 D AvrahamiZilberbrand GA Kaminka Fast complete symbolic plan recognition Proceedings International Joint Conference Artiﬁcial Intelligence vol 14 2005 4 T Babaian BJ Grosz SM Shieber A writers collaborative assistant Intelligent User Interfaces Conference 2002 pp 714 5 GE Barton On complexity IDLP parsing Computational Linguistics ISSN 08912017 11 4 1985 205218 6 M Bauer Acquisition user preferences plan recognition Proceedings Fifth International Conference User Modeling 1996 pp 105 112 7 M Bauer S Biundo D Dengler J Koehler G Paul A logicbased tool intelligent help systems Proc 13th International Joint Conference Artiﬁcial Intelligence IJCAI 1993 8 JE Beck BP Woolf Using learning agent student model Proc 4th International Conference Intelligent Tutors 1998 9 N Blaylock J Allen Recognizing instantiated goals statistical methods Workshop Modeling Others Observations 2005 pp 7986 10 ME Bratman Intention Plans Practical Reason Harvard University Press Cambridge MA 1987 11 ME Bratman DJ Israel ME Pollack Plans resourcebounded practical reasoning Computational Intelligence 4 3 1988 349355 12 JS Brown RR Burton Diagnostic models procedural bugs basic mathematical skills Cognitive Science 2 2 1978 155192 13 HH Bui A general model online probabilistic plan recognition Proc 18th International Joint Conference Artiﬁcial Intelligence IJCAI 2003 14 S Carberry Plan Recognition Natural Language Dialogue MIT Press 1990 15 S Carberry Techniques plan recognition User Modeling UserAdapted Interaction 11 1 2001 3148 16 E Charniak RP Goldman A Bayesian model plan recognition Artiﬁcial Intelligence 64 1 1993 5379 2290 Y Gal et al Artiﬁcial Intelligence 176 2012 22702290 17 PR Cohen CR Perrault JF Allen Beyond questionanswering W Lehnert M Ringle Eds Strategies Natural Language Processing 1981 pp 245274 18 C Conati A Gertner K VanLehn Using Bayesian networks manage uncertainty student modeling Journal User Modeling UserAdapted Interaction 12 4 2002 371417 19 A Corbett M McLaughlin KC Scarpinatto Modeling student knowledge Cognitive tutors high school college User Modeling UserAdapted Interaction 10 2000 81108 20 D Davidson Intending Essays Actions Events Clarendon Press 1980 pp 83102 21 R Dechter Constraint Processing Morgan Kaufmann 2003 22 M Feng N Heffernan K Koedinger Addressing assessment challenge online tutors assesses User Modeling User Adapted Interaction ISSN 09241868 19 3 2009 243266 23 Y Gal E Yamangil A Rubin SM Shieber BJ Grosz Towards collaborative intelligent tutors Automated recognition users strategies Proceedings Ninth International Conference Intelligent Tutoring Systems ITS Montreal Quebec 2008 24 G Gazdar Generalized Phrase Structure Grammar Harvard Univ Press 1985 25 CW Geib M Steedman On natural language processing plan recognition Proceedings 20th International Joint Conference Artiﬁcial Intelligence IJCAI Morgan Kaufmann Publishers Inc San Francisco CA USA 2007 pp 16121617 26 CW Geib RP Goldman A probabilistic plan recognition algorithm based plan tree grammars Artiﬁcial Intelligence 173 11 2009 11011132 27 M Ghallab DS Nau P Traverso Automated Planning Theory Practice Morgan Kaufmann Publishers 2004 28 RP Goldman CW Geib CA Miller A new model plan recognition Proc 15th Conference Uncertainty Artiﬁcial Intelligence UAI 1999 29 BJ Grosz CL Sidner Plans discourse Intentions Communication 1990 417444 30 JK Hammerman A Rubin Strategies managing statistical complexity new software tools Statistics Education Research Journal 3 2 2004 1741 31 E Horvitz Principles mixedinitiative user interfaces Proc ACM SIGCHI Conference Human Factors Computing Systems 1999 32 RM Karp Reducibility combinatorial problems RE Miller JW Thatcher Eds Complexity Computer Computations Springer New York 1972 pp 85103 33 HA Kautz A formal theory plan recognition PhD thesis University Rochester 1987 34 C Konold C Miller TinkerPlots Dynamic Data Exploration 10 Key Curriculum Press 2004 httpwwwkeypresscomx5715xml 35 N Lesh Adaptive goal recognition Proceedings 15th International Joint Conference Artiﬁcial Intelligence 1997 pp 12081214 36 KE Lochbaum A collaborative planning model intentional structure Computational Linguistics 4 1998 525572 37 J Mayﬁeld Controlling inference plan recognition User Modeling UserAdapted Interaction 2 1 1992 5582 38 DS Nau SJJ Smith K Erol et al Control strategies HTN planning Theory versus practice Proceedings National Conference Artiﬁcial Intelligence 1998 pp 11271133 39 ME Pollack Some requirements model plan inference process conversation Communication Failure Dialogue Discourse Detection Repair Processes 1987 40 ME Pollack Plans complex mental attitudes Intentions communication 1990 41 DV Pynadath MP Wellman Probabilistic statedependent grammars plan recognition Proceedings 16th Conference Uncertainty Artiﬁcial Intelligence 2000 pp 507514 42 A Quilici Q Yang S Woods Applying plan recognition algorithms program understanding Automated Software Engineering 5 3 1998 347372 43 S Reddy Y Gal SM Shieber Recognition users activities constraint satisfaction Proceedings First Seventeenth International Conference User Modeling Adaptation Personalization 2009 44 K Ryall J Marks SM Shieber An interactive constraintbased drawing graphs Proceedings 10th Annual Symposium User Interface Software Technology UIST 1997 45 SM Shieber Direct parsing IDLP grammars Linguistics Philosophy 7 2 1984 135154 46 CL Sidner Plan parsing intended response recognition discourse Computational Intelligence 1 1 1985 110 47 K VanLehn C Lynch K Schulze JA Shapiro RH Shelby L Taylor DJ Treacy A Weinstein MC Wintersgill The Andes physics tutoring Lessons learned International Journal Artiﬁcial Intelligence Education 15 3 2005 48 MB Vilain Getting parsing plans A grammatical analysis plan recognition AAAI 1990 pp 190197 49 R Weida D Litman Terminological reasoning constraint networks application plan recognition Proc 3rd Int Conf Principles Knowledge Representation Reasoning KR92 Citeseer 1992 pp 282293 50 R Wilensky Why John married Mary Understanding stories involving recurring goals Cognitive Science 2 3 1978 235266 51 DJ Yaron M Karabinos A Borek B McLaren KL Evans G Leinhardt Tracking supporting learning openended activities involving virtual lab simulation The 238th American Chemical Society National Meeting Washington DC 2009