Artiﬁcial Intelligence 116 2000 1766 Proving theorems reuse Christoph Walther cid3 Thomas Kolbe 1 Fachbereich Informatik Technische Universität Darmstadt Alexanderstr 10 D64283 Darmstadt Germany Received 22 October 1997 received revised form 7 June 1999 Abstract We investigate improvement theorem proving reusing previously computed proofs We developed implemented PLAGIATOR proves theorems mathematical induction aid human advisor If base step formula submitted tries reuse proof previously veriﬁed formula If successful labour saved number required user interactions decreased Otherwise human advisor called providing hand crafted proof formula subsequentlyafter automated preparation stepsis stored systems memory stock future reasoning problems Besides potential savings resources performance overall improved necessary lemmata speculated result attempt reuse proof The success approach based techniques preparing given proofs methods retrieval adaptation reuse candidates promising future proof reuses We prove soundness approach illustrate performance examples cid211 2000 Elsevier Science BV All rights reserved Keywords Deduction theorem proving Machine learning Problem solving search Knowledge representation Analogy Abstraction Reuse 1 Introduction The improvement problem solvers reusing previously computed solutions active research area Artiﬁcial Intelligence emerging methodologies explanationbased learning EBL 222865 analogical reasoning AR 1439 68 In EBL problems solution analyzed yielding explanation solution succeeds After generalization explanation solving similar new problems cid3 Corresponding author Email chrwaltherinformatiktudarmstadtde This work supported grants Wa6524123 Deutsche Forschungsgemeinschaft focus program Deduktion 1 Email kolbeinformatiktudarmstadtde 0004370200 matter cid211 PII S 0 0 0 4 3 7 0 2 9 9 0 0 0 9 6 X 2000 Elsevier Science BV All rights reserved 18 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 In AR problems solution guides solution similar new problems suggesting corresponding inference steps We present approach reusing proofs combines ideas EBL AR ideas abstraction techniques 3669 We investigate reuse ﬁrstorder proofs domain automated mathemat ical induction 811444682 similar conjectures similar proofs 2 An induction theorem prover proves conjecture ﬁrstorder inferences associates conjecture ﬁnite set induction formulas truth entail truth conjecture means induction axiom An induction formula IH IC step formula base formula case IH equals TRUE Induction formulas form new conjectures serving input prover original conjecture proved eventually ﬁrstorder provable induction formulas valid formulas remain Such formulas proved modifying induction conclusion IC axioms induction hypothesis IH TRUE inferred Despite regularity search problem deciding apply axiom induction hypothesis IH applicable main challenge automated mathematical induction 164282 We component induction theorem prover checks validity induction formula simpliﬁer This component implemented ﬁrstorder theorem prover tailored proving induction formulas interface user case interactive ﬁrstorder In paper aim supplement simpliﬁer learning component following way Once simpliﬁer computed proof proof analyzed generalized certain sense reused subsequently Before simpliﬁer asked prove statement ﬁrst looks previously computed proof similar statement tries reuse If reuse fails simpliﬁer compute original proof new statement reuse facility Otherwise depending simpliﬁers implementation search proof user interactions saved 2 Reusing proofsAn example The success approach based techniques preparing given proofs proof analysis generalization techniques proof reuse retrieval adaptation methods We illustrate proposal example We assume functions deﬁned ﬁnite set EQ deﬁning equations interested verifying conjecture follows inductively EQ 2 ThindEQ inductive theory ThindEQ equation set EQ If inductive validity statement veriﬁed add set L lemmata subsequent proofs based set AX VD EQ L axioms Now 2 ThindAX shown new conjecture inductive consequence EQ ThindAX D ThindEQ inserted L 82 detailed account induction theorem proving 2 Throughout paper induction stands mathematical induction confused induction sense machine learning The reuse previously computed induction schemas generalizations subject proposal C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 19 For proving statement induction verify 2 ThindEQ suitable induction axiom ThindEQ selected wellknown automated methods cf 82 set induction formulas I computed I cid18 ThindAX entails 2 ThindEQ For instance let functions plus sum app deﬁned following equations 0 s respectively add constructors sort number respectively list 3 plus1 plus2 sum1 sum2 app1 app2 plus0 y cid17 y plussx y cid17 splusx y sumempty cid17 0 sumaddn x cid17 plusn sumx appempty y cid17 y appaddn x y cid17 addn appx y Now lemma lem1 plusplusx y z cid17 plusx plusy z easily proved induction axiom like deﬁning equation subsequent deductions We aim prove conjectures lem1 reusing previously computed proofs lemmata For instance consider statement Tx yU VD plussumx sumy cid17 sumappx y We prove conjecture induction listvariable x obtain induction formulas viz base formula b step formula s b VD Tempty yU s VD 8u Tx uU Taddn x yU The following proof step formula s conclusion Taddn x yU D obtained modifying induction plussumaddn x sumy cid17 sumappaddn x y IC 3 When presenting examples usually omit universal quantiﬁers level formulas sort information variables 20 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 cid8s VD 8u F Gx Gu cid17 GH x u F GDn x Gy cid17 GH Dn x y 9 8 1 GDn x cid17 F n Gx 2 H Dn x y cid17 Dn H x y 3 F F x y z cid17 F x F y z Cs VD Fig 1 The proof shell PSs proof s backward chaining style statement implied statement line terms underlined changed corresponding proof step plussumaddn x sumy cid17 sumappaddn x y plusplusn sumx sumy cid17 sumappaddn x y plusplusn sumx sumy cid17 sumaddn appx y plusplusn sumx sumy cid17 plusn sumappx y plusplusn sumx sumy cid17 plusn plussumx sumy plusn plussumx sumy cid17 plusn plussumx sumy TRUE IC sum2 app2 sum2 IH lem1 X cid17 X Given proof analyzed distinguish relevant features irrelevant parts Relevant features speciﬁc proof collected proof catch similar requirements satisﬁed proof reused later We consider features like positions equations applied induction conclusions hypotheses general laws X cid17 X irrelevant satisﬁed So catch proof subset set leaves corresponding proof tree Analysis proof yields sum2 app2 lem1 catch For example know plus proving s associativity semantics plus computed Next conjecture induction formula catch generalized 4 obtaining proof shell stores essentials proof serves base reusing proof subsequently Generalization performed replacing function symbols function variables denoted capital letters F G H yielding schematic conjecture cid8 VD F Gx Gy cid17 GH x y corresponding schematic induction formula cid8s schematic catch Cs example cf Fig 1 Here use generalization replacement plus 7 F sum 7 G app 7 H add 7 D Eq 1 Cs corresponds sum2 Eq 2 app2 Eq 3 lem1 4 Not confused generalization formula preprocessing proving induction C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 21 cid8b VD F GC Gy cid17 GH C y 8 Cb VD 4 GC cid17 E 5 F E y cid17 y 6 H C y cid17 y 9 Fig 2 The proof shell PSb obtained proof b The base formula b example proved plussumempty sumy cid17 sumappempty y b plus0 sumy cid17 sumappempty y sumy cid17 sumappempty y sumy cid17 sumy TRUE sum1 plus1 app1 X cid17 X Proof analysis yields catch cb VD fsum1 plus1 app1g plus 7 F sum 7 G app 7 H 7 C 0 7 E obtain proof shell PSb Fig 2 If new statement shall proved set induction formulas I computed Then proving induction formula 2 I reuse tested proof shell PS exists applies secondorder instance schematic induction formula PS If test succeeds obtained secondorder matcher applied schematic catch PS formulas instantiated schematic catch proved necessitate proof reuses veriﬁed reuse truth instantiated schematic catch implies truth correspondingly instantiated schematic induction formula For example assume new conjecture Tx yU VD timesprodx prody cid17 prodappx y shall proved times prod deﬁned equations times1 times2 prod1 prod2 times0 y cid17 0 timessx y cid17 plusy timesx y prodempty cid17 s0 prodaddn x cid17 timesn prodx The induction formulas computed b VD Tempty yU s VD 8u Tx uU Taddn x yU 22 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 instance cid8s respect matcher cid25s VD fF times Obviously s Gprod H app Daddg cf Fig 1 Hence reuse proof s instantiating schematic catch Cs subsequent veriﬁcation resulting proof obligations 8 cid25sCs D 7 prodaddn x cid17 timesn prodx 8 appaddn x y cid17 addn appx y 9 timestimesx y z cid17 timesx timesy z 9 Formulas 7 8 axioms viz prod2 app2 obviously true So remains prove associativity times 9 successful s proved Compared direct proof s saved user interactions respectively search necessary apply right axioms right place associativity times veriﬁed case 5 Note reuse speculates conjecture 9 lemma required proving conjecture This lemma veriﬁed directly calling reuse procedure recursively To complete proof base formula b D timesprodempty prody cid17 prodappempty y veriﬁed As formula instance cid8b respect matcher cid25b VD fF times Gprod H app Cemptyg cf Fig 2 schematic catch Cb instantiated 8 9 cid25bCb D 10 prodempty cid17 E timesE y cid17 y 11 12 appempty y cid17 y However schematic catch partially instantiated function variable E stemming function symbol 0 catch cb replaced matcher cid25b This function symbol 0 occur b consequently function variable E occur schematic base formula cid8b proof shell PSb We function variables proof shell free function variables bound function variables A formula free function variable F true iff function exists formula 0 obtained replacing F function true Thus true formula viz axiom prod1 obtained 10 E replaced s0 Formally replacements represented secondorder substitution like cid26b D fEs0g cid26b called solution free function variables formulas totally instantiated catch cid26bcid25bCb provable AX Here Eq 12 axiom app1 equation cid26b10 axiom prod1 cid26b11 simpliﬁes speculated lemma plusy 0 cid17 y remaining proof obligation 6 So generally ﬁnding proof shell PS D hcid8 Ci applies given conjecture matcher cid25 cid25cid8 D solution candidate cid26 computed 5 We choose simple example illustrate essentials proposal It obvious proof computed stateoftheart theorem prover search reuse offers real savings case 6 Simpliﬁed conjectures obtained symbolic evaluation cf 82 Section 73 For example st1 cid17 st2 simpliﬁed t1 cid17 t2 plusst1 t2 simpliﬁed splust1 t2 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 23 Fig 3 The phases reuse process partially instantiated catch cid25C subsequent adaptation step resulting proof obligations totally instantiated catch cid26cid25C subject veriﬁcations If interested proof presented user processed subsequently sufﬁcient instantiate schematic proof P cid8 obtained generalizing proof p computed substitution cid28 VD cid26 cid14 cid25 cid28 destroy structure P Therefore instantiated proof cid28 P patched succeeds removing void respectively inserting additional inference steps obtaining proof p0 We discuss proof patching paper refer 5357 details Fig 3 illustrates overall organization approach reusing proofs discuss steps procedure subsequent sections 3 Proof analysis generalization In section formal base proof analysis generalization developed We use ﬁrstorder language represent axioms formulas derived Deﬁnition 31 Symbols terms formulas Let SIG D SIGn n2N signature function symbols set SIGn holds function symbols arity n let VAR set variable symbols Then T SIG VAR denotes set formed terms SIG VAR An equation SIG VAR expression form t1 cid17 t2 t1 t2 2 T SIG VAR EQSIG VAR set wellformed equations F SIG VAR set wellformed formulas build equations predicate symbols TRUE FALSE atomic formulas usual connectives quantiﬁers 24 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 The ﬁrstorder language signature cid6 D f0 s add plus times sum prod app g write axioms conjectures called object language Deﬁnition 32 Object language Let cid6 ﬁxed signature function symbols let V ﬁxed set variable symbols Then cid6 called object signature T cid6 V set object terms F cid6 V object language 31 Simple proof analysis Since want investigate principles proof analysis reuse conﬁne unconditional equations conjectures proved Hence set AX axioms deﬁning equations lemmata inferences drawn set universally closed equations object language However proving conjecture consider induction formulas form IH IC cf Section 2 Such formulas H C called sequents H VD H1 cid1 cid1 cid1 Hn set hypotheses 7 form 8ucid3 t1 cid17 t2 conclusion C form s1 cid17 s2 free variables xcid3 H C implicitly assumed universally quantiﬁed 8 To formalize simple proof analysis deﬁne calculus prove base step formulas Each rule calculus built conventional inference rule stipulating addition formula remembered relevant feature particular inference rule proof Hence rules applied expressions form h Ai sequent A cid18 AX called accumulator holds catch collected far Deﬁnition 33 Simple analysis calculus The simple analysis calculus consists following inference rules operating pairs h Ai sequent accumulator A cid18 AX respect set equational axioms AX Here cid18 substitution p position equation C 9 cid15 Reﬂexivity h8xcid3 H t cid17 t Ai hTRUE Ai cid15 AXreplacement h8xcid3 H C Ai h8xcid3 H CTp cid18 rU A f8ucid3 l cid17 rgi 8ucid3 l cid17 r 2 AX l 2 ucid3 Cjp D cid18 l Vr cid18 Vl domcid18 D Vl 7 We distinguish formula H set H contains members conjunction H 8 Instead operating sequents H C calculus deﬁned operating equation C respect set additional local equational hypotheses H equations modiﬁed rules calculus However stick use sequents eases presentation 9 We assume familiarity standard notions equality reasoning like positions subterm replacement 24 Also symmetry cid17 implicitly assumed C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 25 cid15 HYPreplacement h8xcid3 H C Ai h8xcid3 H CTp cid18 rU Ai 8ucid3 l cid17 r 2 H l 2 ucid3 Cjp D cid18 l Vr n Vl ucid3 D domcid18 D Vl ucid3 A sequence hh1 A1i hn Anii pairs sequents accumulators Ai cid18 AX derivation analysis calculus set AX equational axioms iff hiC1 AiC1i results applying rules hi Aii 2 f1 n cid0 1g Derivability denoted h1 A1i AX hn Ani AX omitted appropriate The requirement domcid18 cid18 ucid3 guarantees free variables 8ucid3 l cid17 r instantiated applied equation hypothesis requirement void applied equation axiom universally closed Analogously requirements Vr n Vl ucid3 D respectively Vr cid18 Vl ensure new variables introduced sequent The additional requirement domcid18 cid18 Vl demanded substitution cid18 minimal variables replaced unnecessarily The replacement rules differ updating accumulator component If applied equation 8ucid3 l cid17 r axiom recorded A obtaining catch applied equation hypothesis irrelevant learning step A remains unchanged Example 34 Simple proof analysis Consider expression hH gf c hy cid17 f gi equation E VD 8x f c x cid17 hx If E 2 H expression hH ghhy cid17 f gi obtained HYPreplacement But E 2 AX AX replacement yields hH ghhy cid17 fE gi The calculus simple proof analysis yields ﬁnite subset axioms derivation sequent sound Theorem 35 Soundness equations let sequent F cid6 V h AX AX Let AX A cid26 F cid6 V sets universally closed hTRUE Ai Then A cid26 AX jAj 1 h A ii A jD iii AX jD hTRUE Ai Proof A cid18 AX obvious deﬁnition A rules calculus jAj 1 derivation ﬁnite Finally derivation AX derivation A axioms AX n A derivation ii inferred A cf A jD reﬂexivity rule replacement rules sound iii Follows ii monotonicity semantical entailment 2 Given formula set induction formulas f 0 ng try infer h AX hTRUE Aii calculus If successful AX cid19 A0 cid1 cid1 cid1 An jD f 0 ng jDind 26 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 proved accumulator Ai obtained holds catch proof 32 Generalization Given formula catch c proof AX reuse proof veriﬁcation formula consistent replacement function symbols c fg function symbols terms yielding set equations c0 formula 0 D AX jD c0 holds For example proof base formula plussumempty sumy cid17 sumappempty y reused proving base formula timesprodempty prody cid17 prodappempty y replacements plus 7 times sum 7 prod 0 7 s0 cf Section 2 However order ease presentation avoid formal clutter prefer indirect way formulating function symbol replacements In generalization step function variable symbols c fg consistently replaced symbols signature cid10 set U variable symbols yielding schematic catch C schematic conjecture cid8 These formulas members ﬁrstorder language viz schematic language F cid10 U If proof reused proving new conjecture symbols cid10 U replaced symbols cid6 V match schematic conjecture cid8 For example example use plus 7 F sum 7 G 7 C app 7 H 0 7 E y 7 u generalization step obtain schematic conjecture cid8 D F GC Gu cid17 GH C u F 7 times G 7 prod C 7 H 7 app E 7 s0 u 7 y reuse step cf Section 2 Deﬁnition 36 Schematic language Let cid10 signature function symbols let U set variable symbols cid6 cid10 D V U D Then T cid10 U set schematic terms EQcid10 U set schematic equations F cid10 U schematic language set schematic formulas Function symbols schematic signature cid10 denoted capital letters F G referred function variables subsequently indicates intended replacements function symbols object signature cid6 The variables U called schematic variables Variables function symbols formally replaced schematic variables function variables generalization functions Deﬁnition 37 Generalization functions A generalization function cid13 injective partial function cid13 cid6 V cid10 U ﬁnite domain domcid13 maps function symbols function variables arity maps variables schematic variables f 2 domcid13 cid6n implies cid13 f 2 cid10n x 2 domcid13 V implies cid13 x 2 U A generalization function cid13 homomorphically extended object formulas cid13 2 F cid10 U 2 F cid6 V cid6 V cid18 domcid13 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 27 A generalization function cid13 maps object formula schematic formula cid13 The inverse mapping mapping schematic formula cid8 object formula cid25cid8 called total instantiation cid8 achieved schematic substitutions variable renamings cf Section 4 We use schematic language F cid10 U represent proof ideas form proof shells Deﬁnition 38 Proof shells A pair PS D hcid8 Ci consisting schematic formula cid8 2 F cid10 U ﬁnite set C cid18 F cid10 U schematic formulas proof shell iff C jD cid8 Proof shells constitute elementary building blocks proof reuse They computed generalizing object formula proof catch c proof shell hcid8 Ci Theorem 39 Proof shells simple analysis Let A fg cid26 F cid6 V hTRUE Ai let cid13 generalization function cid13 A fg cid26 h A F cid10 U Then hcid13 cid13 Ai proof shell Proof A jD Theorem 35ii consequently cid13 A jD cid13 cid13 onetoone symbol renaming 2 By Theorem 39 proof object formula simple analysis calculus generalized proof shell schematic conjecture cid13 schematic catch cid13 A See Section 2 examples proof shells obtained according Theorem 39 4 Instantiating proof shells Proof analysis generalization deﬁne proofprepare phase reuse procedure cf Fig 3 transforms proof reusable data structure viz proof shell In following concerned retrievereuse phase cf Fig 3 aims selection instantiation proof shell given veriﬁcation task veriﬁable proof obligations obtained Before discuss retrieval adaptation steps Section 7 concept admissible total instantiations proof shells introduced A conjecture veriﬁed reuse proof shell hcid8 Ci certain substitution cid25 exists cid25C fcid8g cid18 F cid6 V cid25cid8 D AX jD cid25C Section 2 examples Such substitution cid25 computed iteratively cid25n cid14 cid1 cid1 cid1 cid14 cid251 cid14 cid250 computes substitution cid250 considering cid8 cid251 considering cid250C cid252 considering cid251cid250C eventually cid25n cid251cid250C fcid8g cid18 F cid6 V cid25n cid251cid250cid8 D Finally AX jD cid25n cid251cid250C veriﬁed successful AX jD proved We formulas intermediate steps formulas cid250C cid251cid250C mixed formulas belong schematic object language Deﬁnition 41 Mixed language T cid6 cid10 V U set mixed terms F cid6 cid10 V U mixed language set mixed formulas 28 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 Since F cid6 V F cid10 U cid18 F cid6 cid10 V U object formula schematic formula mixed formula In mixed schematic expression schematic variables successively replaced object variables function variables successively replaced composition function symbols application certain substitutions eventually expression object language obtained creating mixed expressions intermediate steps Deﬁnition 42 Schematic renamings schematic substitutions A schematic variable renaming injective mapping cid23 U V The application cid23 mixed term formula deﬁned homomorphical extension cid23 A schematic substitution cid25 cid10 T cid6 cid10 W partial function ﬁnite domain domcid25 cid25F 2 T cid6 cid10 WF F 2 domcid25 Here W VD WF set parameter variables WF VD fF1 F2 Fng F 2 cid10n WF WG D F 6D G T cid6 cid10 W called set functional terms The application cid25 mixed term M 2 T cid6 cid10 V U inductively deﬁned F 2cid10 S cid25z VD z cid25F M1 Mn VD F cid25M1 cid25Mn cid25F M1 Mn VD cid27 cid25F z 2 V U F 2 domcid25 F 2 domcid25 cid27 VD fF1cid25M1 Fncid25Mng replaces parameter variables Fi cid25F 2 T cid6 cid10 WF The application cid25 mixed formula deﬁned homomorphical extension cid25 A schematic substitution cid25 usually written ﬁnite set replacement pairs F M 2 cid25 iff F 2 domcid25 M D cid25F A functional term M 2 T cid6 cid10 WF corresponds cid21term cid21F1 FnM cid21calculus schematic substitution called pure closed secondorder substitution variables V U replaced introduced 10 We usually write wi instead Fi ith formal parameter functional term deﬁne schematic substitutions examples F obvious context F f F 2 cid10n f 2 cid6n abbreviation replacement pair F f w1 wn retains structure terms instantiations cid25F t1 tn D f cid25t1 cid25tn More complex instantiations like cid25 D fGplusw2 lenw1 H F w1 w1g G H 2 cid102 severely change structure terms subterms introduced multiplied deleted cid25GH x sumappk l sy D plussy lenF x x Now reuse proofs instantiation proof shells formulated Theorem 43 Reuse theorem Let hcid8 Ci proof shell cid23 schematic variable renaming cid25 schematic substitution cid23cid25C fcid8g cid18 F cid6 V Then cid23cid25C jD cid23cid25cid8 Proof C jD cid8 Deﬁnition 38 consequently cid23cid25C jD cid23cid25cid8 entailment invariant respect instantiations cf 50 2 10 The notation parameter variables borrowed 37 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 29 5 Sortal reasoning The domain discourse theorem proving manysorted induction theorem proving statements natural numbers linear lists trees considered Sortal reasoning incorporated logic assigning rangesort set S sort symbols S D fbool nat list g variable function symbols assigning domainsort S argument position function symbol Sorts assigned terms The sort term t rangesort t t variable rangesort f t D f A term t wellsorted iff subterm f t1 tn t sort ti coincides domainsort f position A substitution cid18 D fx1t1 xntng wellsorted iff sort ti coincides sort xi ti wellsorted Now manysorted logic demands 1 wellsorted terms 2 t1 t2 sort equation t1 cid17 t2 formula 3 wellsorted substitutions deduction Different nonﬂat sort hierarchies order relation imposed S representing inclusion sets cf 79 ﬂat manysorted framework inﬂuences deduction matchers uniﬁers computed variable replacement A term t formula replaced term cid18 r equation l cid17 r matcher cid18 l t cid18 wellsorted This guaranteed l variable terms wellsorted However sorts l t explicitly compared l variable Otherwise cid18 illsorted consequently illsorted terms formed deduction term plusa b replaced revrevplusa b equation x cid17 revrevx illsorted matcher replaces listvariable x natterm plus Now order guarantee sound reuse manysorted logic information sorts locally quantiﬁed variables l equations l cid17 r left right proof memorized proof catch properly considered subsequent reuse attempts provability statement reuse succeeds guaranteed fact Since involves awkward formal machinery rare case pure variable replacements proof cf 52 allow variable replacements analysis calculus Consequently proof catch independent sortal information However instantiating proof shell guaranteed intermediate mixed formulas wellsorted ground instance Consider instance partially instantiated catch containing mixed formulas 1 F Gk cid17 ssumk 2 F n cid17 H n k listvariable n variable sort nat The substitution cid251 VD fF s Gsumg solves 1 yields sn cid17 H n instantiation remaining catch formula 2 The substitution cid252 VD fF ssumw1 Gw1g solves 1 ssumn cid17 H n results 2 But ssumn illsorted n natvariable sum list nat cid252 considered solution substitution 1 Since selection wrong substitution recognized instantiation steps machine resources wasted reuse attempts backtracking mechanisms required 30 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 When forming totally instantiated catch backtracking avoided sorts assigned schematic variable symbols function variables Then set cid5 schematic variable renamings substitutions admissible set C mixed formulas sort assignment exists variable renaming substitution cid5 formula C wellsorted For instance F nat nat G list nat H nat nat sort assignment f1 2g cid251 wellsorted fcid251g admissible f1 2g But fcid252g admissible f1 2g wellsortedness f1 2g demands F nat nat wellsortedness cid252 demands F list nat Admissibility set cid5 substitutions set C mixed formulas easily tested computing equational Ecid5 C sort symbols cid5 C subsequent veriﬁcation different sorts nat list identiﬁed Ecid5 C 84 formal details For reuse proofs sorted logic Reuse Theorem 43 reformulated Corollary 51 Reuse theorem sorted logic Let hcid8 Ci proof shell cid23 schematic variable renaming cid25 schematic substitution 1 fcid25 cid23g admissible C fcid8g 2 cid23cid25C fcid8g cid18 F cid6 V Then cid23cid25C jDS cid23cid25cid8 jDS denotes semantical entailment sorted logic cf 29 Proof Follows Theorem 43 cf 50 2 6 Reﬁned proof analysis Corollary 51 provides logical base proposal reusing proofs For given conjecture proof shell hcid8 Ci renaming cid23 schematic substitution cid25 meet requirements 1 2 Reuse Theorem satisfy D cid23cid25cid8 Then AX jD cid23cid25 0 veriﬁed directly reuse 0 2 C successful AX jD proved Since proof shells obtained analyzed proofs cf Theorem 39 success proof reuse directly depends generality learned given proof Example 61 Limitations simple analysis Let AX D ffa cid17 ga cid17 b gb cid17 ag consider conjecture D ffa cid17 Then hffa cid17 hfa cid17 ffa cid17 agi ha cid17 ffa cid17 agi hTRUE ffa cid17 agi AX AX AX proof shell PS D hF F A cid17 A fF A cid17 Agi obtained proof But PS apply conjecture 1 D fgb cid17 function variable F C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 31 replaced f g function variable A replaced b reuse fails 1 PS applies conjecture 2 D gga cid17 instantiated catch computed fga cid17 ag But AX 6jD ga cid17 reuse fails 2 One possible reason failed reuses conjecture requires original proof differs structure proof But case learned simply reuse fails reason The true conjectures example improve technique reuse eventually successful The key idea improvement distinguish different occurrences function symbols conjecture catch conjectures proof replaced composition different function symbols spoiling soundness proof This yields general proof shell different occurrences function symbol object level generalized different function variables schematic level proof shell formed Example 62 Example 61 continued We recover reuse failures AX occurrences function symbols f separated different function symbols spoiling soundness derivation We use AXcid3 D ff 0g prove cid3 D ff 0a cid17 0a cid17 00 cid17 00 fa 0 0 0a cid17 hff 0 0 00 ff cid17 hfa 0a cid17 0 ff 0 cid17 ha 00 0 cid17 hTRUE ff cid17 00gi 00 fa 00 fa 00 cid17 0gi 0gi cid17 AX AX AX obtain proof shell PScid3 D hF F 0A cid17 A0 fF 0A cid17 A00 F A00 cid17 A0gi derivation PScid3 applies conjecture 1 matcher cid251 D fF f F 0g Ab A0ag partially instantiated catch C1 computed fgb cid17 A00 fA00 cid17 ag Since cid261 D fA00ag solution free function variable C1 cid261cid251C1 D fgb cid17 fa cid17 ag cid18 AX 1 proved reuse based proof shell PScid3 PScid3 applies 2 matcher cid252 D fF g F 0g Aa A0ag partially instantiated catch C2 computed fga cid17 A00 gA00 cid17 ag Since cid262 D fA00bg solution free function variable C2 cid262cid252C2 D fga cid17 b gb cid17 ag cid18 AX 2 proved reuse based proof shell PScid3 Since original derivation AX expose possible separation occurrences f occurrences f generalized function variable F occurrences generalized function variable A proof shell PS reuse fails 1 2 So remedy problem recognize different occurrences function symbols derivation generalized different function variables proof shell constructed 32 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 To effect distinguish ﬁrst step different occurrences function symbol conjecture supplying function symbols different superscripts N yielding 0 D f1f2a1 cid17 a2 We function symbols superscripts indexed function symbols f root index indexed function symbol f We supply function symbols axioms unique indices assume inﬁnitely differently indexed copies axiom indexed axiom set AX0 D ff3a3 cid17 a4 f4a5 cid17 a6 f5a7 cid17 a8 f6a9 cid17 a10 g obtained indexed function symbol occurrence indexed axiom set indexed conjecture In step function symbols derivation supplied corresponding indices demand indexed axiom applied derivation This restrict derivability inﬁnitely indexed copies disposal obtain hf1f2a1 cid17 a2 hf1a4 cid17 a2 ff3a3 cid17 a4gi ha6 cid17 a2 ff3a3 cid17 a4 f4a5 cid17 a6gi hTRUE ff3a3 cid17 a4 f4a5 cid17 a6gi Now test indexed derivation sound derivation AX0 identify indexed function symbols common root different indices necessary This succeed original derivation obtained indexed function symbol common root identiﬁed Here identiﬁcations f2 D f3 a1 D a3 f1 D f4 a4 D a5 a2 D a6 required obtaining sound derivation AX0 Note indexed function symbols derivation identiﬁed f1 f2 a1 a2 a4 identiﬁcation symbols necessary sound derivation Finally recognized identiﬁcations propagated conjecture 0 set axioms AX0 derivation yielding 00 D f1f2a1 cid17 a2 AX00 D ff2a1 cid17 a4 f1a4 cid17 a2 g derivation hf1f2a1 cid17 a2 AX00 hf1a4 cid17 a2 ff2a1 cid17 a4gi AX00 ha2 cid17 a2 ff2a1 cid17 a4 f1a4 cid17 a2gi AX00 hTRUE ff2a1 cid17 a4 f1a4 cid17 a2gi simple analysis calculus From derivation proof shell PScid3 Example 62 obtained generalizing 00 proof catch ff2a1 cid17 a4 f1a4 cid17 a2g Subsequently shall develop calculus reﬁned proof analysis yielding proof shells signiﬁcantly increased reusability general schematic conjectures catches obtained compared simple analysis approach Proof shells based results reﬁned analysis apply yield weaker prove obligations examples illustrate The calculus reﬁned proof analysis emerges simple analysis calculus derivation C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 33 1 indexed conjecture set indexed axioms 2 accumulator holding indexed axioms derivation 3 collision set bookkeeping identiﬁcations indexed symbols required sound derivation Deﬁnition 63 Indexed function symbols indexed language cid6 N n VD ff j f 2 cid6n 2 Ng set indexed function symbols object signature cid6 T cid6 N V called set indexed terms F cid6 N V set indexed formulas index T cid6 V F cid6 V T cid6 N V F cid6 N V mapping supplies occurrences function symbols term respectively formula fresh indices We demand index yield indices ascending order starting 1 unindex T cid6 N V F cid6 N V T cid6 V F cid6 V inverse mapping removes indices indexed function symbols indexed term respectively formula Strictly speaking index operation effect demand indices obtained index Thus indexgfgx y D g1f1g2x y result indexing started later indexgfgx y D g3f2g4x y obtained input term Consequently unindexindext D t t 2 T cid6 V indexunindext 6D t t 2 T cid6 N V Deﬁnition 64 Index collision set equivalence cid24K A pair hf f j 2 cid6 N cid2 cid6 N called index collision set K cid18 fhf f j j f 2 cid6 j 2 Ng cid18 cid6 N cid2cid6 N called index collision set We let cid24K denote reﬂexive transitive symmetrical closure K cid24K equivalence relation cid6 N df VD f k Krepresentative f 2 cid6 N iff K k VD minfj j f cid24K f j g Index collision sets represent identiﬁcations different occurrences function symbols earlier occurrences smaller indices Thus K representative indexed function symbol f ﬁrst occurrence f identiﬁed f satisfy identiﬁcations represented K Deﬁnition 65 Congruence cid25K minimal collision set DK For index collision set K equivalence relation cid24K cid6 N extended congruence relation cid25K T cid6 N V equivalence relation x cid25K y iff x D y x y 2 V f t1 tn cid25K f j s1 sn iff f cid24K f j t1 cid25K s1 tn cid25K sn We write t DK s iff t cid25K s minimal index collision set K t cid25L s implies cid24K cid18cid24L collision set L 34 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 Note indexed terms Kcongruent identical terms obtained indices removed For instance f1f2x cid25K f3f2x K VD fhf1 f3ig f1f2x 6cid25K 0 f3g1x index collision set K 0 Matching extended indexed terms ignoring indices clash test performed Deﬁnition 66 Matching indexed terms A substitution cid18 indexed matcher t s 2 T cid6 N V iff cid18 t cid25K s collision set K cid18 minimal indexed matcher t s 2 T cid6 N V iff collision set K cid18 t cid25K s cid24K cid18cid24L indexed matcher cid21 cid21t cid25L s collision set L This means fxa1g indexed matcher f 1x f 2a1 f 1x g1a1 nonmatchable indexed terms Further fxa1g fxa2g minimal indexed matchers h1x x h2a1 a2 fxa3g nonminimal indexed matcher Minimal indexed matchers introduce indices occur matched terms The simple analysis calculus Section 31 modiﬁed incorporate bookkeeping indices The modiﬁed calculus operates triples h8xcid3 H C A Ki nonvariable terms H C A indexed additional component viz index collision set K keeps track function symbols cid6 N identiﬁed proof The conjecturesequent D 8xcid3 H C proof going analyzed indexed derivation performed start sequent index The axioms AX freshly indexed application indexed function symbol occurrence indexed accumulator indexed conjecture Deﬁnition 67 Reﬁned analysis calculus The reﬁned analysis calculus consists following inference rules operating triples h A Ki indexed sequent indexed accumulator A unindexA cid18 AX index collision set K cid18 cid6 N cid2 cid6 N AX set axioms cid18 minimal indexed matcher p position C cid15 Reﬂexivity h8xcid3 H s cid17 t A Ki hTRUE A K K 0i s DK 0 t cid15 AXreplacement h8xcid3 H C A Ki h8xcid3H CTp cid18 r 0U A f8ucid3 l0 cid17 r 0g K K 0i 8ucid3 l cid17 r 2 AX l 2 ucid3 Vl domcid18 D Vl cid15 HYPreplacement l0 VD indexl r 0 VD indexr Cjp DK 0 cid18 l0 Vr cid18 h8xcid3 H C A Ki h8xcid3 H CTp cid18 rU A K K 0i 8ucid3 l cid17 r 2 H l 2 ucid3 Cjp DK 0 cid18 l Vr n Vl ucid3 D domcid18 D Vl ucid3 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 35 A sequence hh1 A1 K1i hn An Knii triples indexed sequents indexed accumulators Ai unindexAi cid18 AX index collision sets Ki cid18 cid6 N cid2 cid6 N derivation reﬁned analysis calculus set AX equational axioms iff 2 f1 ncid01g hiC1 AiC1 KiC1i results applying rules hi Ai Kii Derivability denoted h1 A1 K1i ak hn An Kni AX omitted AX appropriate In reﬁned analysis calculus replacement rules differ updating accumulator component simple analysis approach differ treatment function indices AXreplacement generates freshly indexed variant axiom application HYPreplacement applies indexed hypothesis index modiﬁcations The indexed function symbols identiﬁed replacement step recorded rules collision component Example 68 Reﬁned proof analysis We resume Example 34 Consider equation E VD T8x fc x cid17 hxU indexed expression cid10 cid11 H g2f2c2 h2y cid17 f g f g If indexed version E H T8x f1c1 x cid17 h1xU 2 H cid10 H g2h1h2y cid17 f g fhf2 f1i hc2 c1i g cid11 obtained HYPreplacement But E 2 AX indexE VD T8x f3c3 x cid17 h3xU AXreplacement yielding indexed expression cid10 H g2h3h2y cid17 f8x f3c3 x cid17 h3x g fhf2 f3i hc2 c3i g cid11 Note demand DK 0 use minimal indexed matchers deﬁnition inference rules This entails function symbols identiﬁed identiﬁed guarantees general schematic catch obtained subsequently Otherwise pair hh1 h2i inserted index collision sets Example 68 yielding identiﬁcation required inference steps For proving formula try establish hindex ak AX hTRUE A Ki reﬁned calculus The collision set K contains pairs hf f j indexed function symbols identiﬁed proof This information propagated accumulator A conjecture index building proof catch proof index based assumption f f j denote identical functions Either f f j identiﬁed syntactically replacing f f j vice versa equations A index ii f f j identiﬁed semantically insertion identiﬁcation axiom T8x1 xn f ix1 xn cid17 f j x1 xnU A 36 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 The kind identiﬁcation inﬂuences generality proof shell effort spent reusing proof Example 69 Syntactical semantical identiﬁcation Let AX D fa cid17 b cid17 c fx y cid17 gx y g consider conjecture D fa cid17 fb c Then hf1a1 a2 cid17 f2b1 c1 hf1b2 a2 cid17 f2b1 c1 fa3 cid17 b2g fa1 D a3gi hf1b2 c2 cid17 f2b1 c1 fa3 cid17 b2 a4 cid17 c2g fa1 D a3 a2 D a4gi hTRUE fa3 cid17 b2 a4 cid17 c2g fa1 D a3 a2 D a4 f1 D f2 b1 D b2 c1 D c2gi ak AX ak AX ak AX syntactical identiﬁcation yields proof catch fa1 cid17 b1 a2 cid17 c1g conjecture f1a1 a2 cid17 f1b1 c1 After generalization proof shell PSsyn D hF 1A1 A2 cid17 F 1B1 C1 fA1 cid17 B1 A2 cid17 C1gi obtained proof 11 Semantical identiﬁcation yields proof catch fa3 cid17 b2 a4 cid17 c2 a1 cid17 a3 a2 cid17 a4 f1x y cid17 f2x y b1 cid17 b2 c1 cid17 c2g conjecture f1a1 a2 cid17 f2b1 c1 generalized proof shell cid10 PSsem D F 1A1 A2 cid17 F 2B1 C1 fA1 cid17 B1 A2 cid17 C1 A3 cid17 B2 A4 cid17 C2 A1 cid17 A3 A2 cid17 A4 F 1u v cid17 F 2u v B1 cid17 B2 C1 cid17 C2g cid11 Obviously PSsem general PSsyn sense PSsem applies conjecture provable proof obligations obtained catch PSsem PSsyn applies provable proof obligations obtained catch PSsyn vice versa For instance PSsem applies conjecture D fa cid17 gb c matcher cid25 D fF 1f A1a A2a F 2g B1b C1cg partially instantiated catch cid25Csem computed fa cid17 b cid17 c A3 cid17 B2 A4 cid17 C2 cid17 A3 cid17 A4 fx y cid17 gx y b cid17 B2 c cid17 C2g Since cid26 D fA3a A4a B2b C2cg solution free function variables Csem AX jD cid26cid25Csem D fa cid17 b cid17 c cid17 fx y cid17 gx y b cid17 b c cid17 cg proved reuse based proof shell PSsem However PSsyn apply function variable F 1 replaced f g consequently reuse based PSsyn fails Example 69 illustrates semantical identiﬁcation yields general proof shells price larger schematic catches function variables 11 We use indexed function variables examples illustrational purposes sake presentation This means A1 A2 different function variables sharing common property A1 B1 property common C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 37 compared syntactical identiﬁcation Hence semantical identiﬁcation increases effort reuse bound function variables matched free function variables solved proof obligation veriﬁed Correspondingly syntactical identiﬁcation minimizes reuse effort price restricted applicability proof shell Consequently compromise extremes propose simple criterion decide forms identiﬁcation combines advantages alternatives proved sufﬁcient Bound function symbols function symbols stemming indexed conjecture identiﬁed semantically schematic conjecture proof shell general possible increasing applicability Free function symbols function symbols occurring proof catch identiﬁed syntactically number free function variables size schematic catch minimized decreasing reuse effort Deﬁnition 610 Identiﬁcation heuristic Let h ak AX collision set K deﬁnes mapping hTRUE A Ki Then idK 2 F cid6 NV 2 F cid6 NV formula 0 2 idK A obtained 2 A replacing free function symbol f Krepresentative df K cf Deﬁnition 64 We idK A syntactic catch proof The collision set K deﬁnes set indexed formulas IDK cid18 F cid6 N V K x1 xn cid17 f ix1 xn 2 IDK iff f bound function symbol K IDK called semantic catch proof member 8x1 xn df e f 6D df IDK identiﬁcation axiom Since assign indices ascending order starting conjecture free function symbol f replaced bound function symbol cid24K equivalence class f contains bound function symbol Thus function symbols conjecture propagated proof catch far possible necessary The union syntactic semantic catch form catch indexed conjectures proof generalized proof shell Lemma 611 Reﬁned versus simple analysis Let AX cid26 F cid6 V A cid26 F cid6 N V sets universally closed equations let K cid26 cid6 N cid2 cid6 N collision set let sequent F cid6 N V h ak AX hTRUE A Ki Then h idK AIDK hTRUE idK A IDK Proof Transforming derivation reﬁned calculus derivation simple analysis calculus succeeds index disagreements removed Each step derivation ak AXreplacementrule identiﬁcation axioms IDK adapting colliding indices bound function symbols necessary followed step rule ak AX transformed sequence replacement steps idK A IDK AX 2 38 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 AX Let AX cid26 F cid6 V A cid26 F cid6 N V sets Theorem 612 Soundness ak universally closed equations let K cid26 cid6 N cid2 cid6 N collision set let sequent F cid6 N V h ak AX hTRUE A Ki Then unindexA cid26 AX jAj 1 h ak ii idK A IDK jD iii AX jD unindex unindexA hTRUE A Ki Proof unindexA cid26 AX obvious deﬁnition A rules calculus jAj 1 derivation ﬁnite Finally derivation AX derivation unindexA axioms AXnunindexA derivation ii We ﬁnd h hTRUE idK A IDK idK AIDK Lemma 611 statement follows Theorem 35ii iii Since idK A IDK jD ii unindexidK A unindexIDK jD unindex With unindexidK A D unindexA jD unindexIDK obtain unindexA jD unindex With unindexA cid26 AX cf statement follows monotonicity semantical entailment 2 Corollary 613 Proof shells reﬁned analysis Let A fg cid26 F cid6 N V h ak unindexA hTRUE A Ki let cid13 generalization function cid13 A fg cid26 F cid10 U Then hcid13 cid13 idK A IDK proof shell Proof h follows Theorem 39 2 idK AIDK hTRUE idK A IDK Lemma 611 statement Example 614 Identiﬁcation heuristic We resume Example 69 apply identiﬁ cation heuristic conjecture f1a1 a2 cid17 f2b1 c1 catch A D fa3 cid17 b2 a4 cid17 c2g collision set K D fa1 D a3 a2 D a4 f1 D f2 b1 D b2 c1 D c2g Since function symbols A free syntactical identiﬁcation yields syntactic catch idK A D fa1 cid17 b1 a2 cid17 c1g semantic catch IDK computed ff1x y cid17 f2x yg f1 f2 bound Kequivalent From union catches proof shell PSheu D hF 1A1 A2 cid17 F 2B1 C1 fA1 cid17 B1 A2 cid17 C1 F 1u v cid17 F 2u vgi obtained general PSsyn general PSsem For instance PSheu applies D fa cid17 gb c matcher cid25 D fF 1f A1a A2a F 2g B1b C1cg totally instantiated catch cid25Cheu computed fa cid17 b cid17 c fx y cid17 gx yg cid18 AX proved reuse based PSheu Obviously proof shell PSheu applies proof shell PSsyn requires effort solving free variables yields proof obligations proof shell PSsem C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 39 Deﬁnition 610 formulates heuristic decision syntactical semantical identiﬁcation independent reasoning domain modiﬁcations heuristic useful particular domain consideration Here instance theorem proving induction considered indexing step formula like s yields 8z plus1sum1x sum2z cid17 sum3app1x z plus2sum4add1n x sum5y cid17 sum6app2add2n x y Since step formulas proved modifying induction conclusion induction hypothesis applicable function symbols induction conclusion identiﬁed corresponding function symbols induction hypothesis obtain plus1 cid24K plus2 sum1 cid24K sum4 sum2 cid24K sum5 sum3 cid24K sum6 app1 cid24K app2 add1 cid24K add2 All function symbols bound identiﬁed semantically Deﬁnition 610 demands yielding proof shell PS schematic conjecture 8w F 1G1u G2w cid17 G3H 1u w F 2G4D1m x G5v cid17 G6H 2D2m u v set I identiﬁcation axioms fF 1u v cid17 F 2u v G1u cid17 G4u G2u cid17 G5u G3u cid17 G6u H 1u v cid17 H 2u v D1u v cid17 D2u vg subset semantic catch Now PS applies step formula IH IC corresponding function variables schematic conjecture F 1 F 2 G1 G4 replaced functional terms function symbols induction conclusion IC correspond function symbols induction hypothesis IH For example PS applies D 8z timesprodx prodz cid17 prodappx z timesprodaddn x prody cid17 prodappaddn x y identiﬁcation axioms I instantiated tautologies like timesx y cid17 timesx y prodk cid17 prodk This example reveals identiﬁcation heuristic applied step formulas yields proof shell redundant schematic formulas catch schematic conjecture useless generality As obvious remedy problem supply induction conclusion step formula unique indices use indices induction hypothesis For instance 0 s D 8z plus1sum1x sum2z cid17 sum3app1x z plus1sum1add1n x sum2y cid17 sum3app1add1n x y indexed version s The corresponding schematic conjecture 8w F 1G1u G2w cid17 G3H 1u w F 1G1D1m x G2v cid17 G3H 1D1m u v applies redundant proof obligations avoided decreasing costs reuse 40 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 Example 615 Proof shells reﬁned proof analysis We resume proof step formula s Section 2 conjecture D plussumx sumy cid17 sumappx y reﬁned proof analysis For indexed step formula 0 s derivation h0 hTRUE A Ki obtained s ak AX plus1 cid24K plus4 cid24K plus7 add1 cid24K add2 cid24K add3 sum1 cid24K sum4 cid24K sum5 plus2 cid24K plus5 plus6 cid24K plus3 add4 cid24K add5 sum3 cid24K sum6 cid24K sum7 app1 cid24K app2 cid24K app3 The indexed accumulator A contains indexed copies applied axioms obtained 8 A VD indexsum2 indexapp2 indexsum2 indexlem1 sum4add2n x cid17 plus2n sum5x app2add3n x y cid17 add4n app3x y sum6add5n x cid17 plus3n sum7x plus4plus5x y z cid17 plus6x plus7y z Here IDK D collisions bound function symbols syntactical catch computed c VD idK A D 8 sum1add1n x cid17 plus2n sum1x 13 14 app1add1n x y cid17 add4n app1x y sum3add4n x cid17 plus3n sum3x 15 16 plus1plus2x y z cid17 plus3x plus1y z 9 9 Now equations indexed conjecture 0 s indexed catch c generalized cid13 VD fplus1F 1 plus2F 2 plus3F 3 sum1G1 sum2G2 sum3G3 app1H 1 add1D1 add4D4 g 12 obtain proof shell PS1 D hcid8 Ci Fig 4 We illustrate advantages reﬁned proof analysis examples induction domain comparing attempts reusing proofs simple analysis approach reﬁned approach Example 616 Proof shells simple reﬁned analysis For 3 VD plusx 0 cid17 x step formula 3s VD plusx 0 cid17 x plussx 0 cid17 sx computed proof shell PSs Fig 1 apply function variable G schematic conjecture replaced w1 0 Hence 3s proved reuse based PSs But PS1 Fig 4 applies matcher cid253 VD fF 1plus G13w1 G20 H 1w1 D1sw2g 13 12 Here assume appropriate generalizations object variables Since equations catch implicitly universally quantiﬁed occurrences n 13 14 Example 615 denote different variables generalized differently 13 We use expressions like G13w1 shorthand G1w1 G3w1 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 41 cid8 VD 8u F 1G1x G2u cid17 G3H 1x u F 1G1D1n x G2y cid17 G3H 1D1n x y 8 17 G1D1n x cid17 F 2n G1x 18 H 1D1n x y cid17 D4n H 1x y 19 G3D4n x cid17 F 3n G3x 20 F 1F 2x y z cid17 F 3x F 1y z 9 C VD Fig 4 The proof shell PS1 obtained proof s appropriate ﬁrstorder variable renaming cid233 With solution substitution cid263 VD fD4sw2 F 23sw2g free function variables totally instanti ated catch cid263cid253cid233C obtained cid263cid253cid233C VD 8 sx cid17 sx sx cid17 sx sx cid17 sx 21 22 23 24 plussy z cid17 splusy z 9 Since fcid253 cid263 cid233g admissible C fcid8g AX jD cid263cid253cid233C 3s proved reuse based PS1 cf Theorem 43 Here different instantiations G13w1 versus G20 essential success ii Let 4 VD pluslenx leny cid17 lenappx y function len given deﬁning equations len1 len2 lenempty cid17 0 lenaddn x cid17 slenx The step formula cid0 4s VD 8u pluslenx lenu cid17 lenappx u pluslenaddn x leny cid17 lenappaddn x y cid1 Fig 1 applies matcher cid254 VD computed 4 PSs fF plus Glen H app Daddg appropriate ﬁrstorder variable renaming cid234 Hence instantiate schematic catch Cs correspondingly obtain proof obligations 8 cid254cid234C VD lenaddn x cid17 plusn lenx 25 26 appaddn x y cid17 addn appx y 27 plusplusx y z cid17 plusx plusy z 9 But statement 25 obviously hold reuse based PSs fails 4s However PS1 Fig 4 applies 4s matcher cid25 0 VD 4 fF 1plus G123len H 1app D1addg appropriate ﬁrstorder variable 42 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 VD fD4add F 23sw2g 4cid25 0 4cid230 4C obtained 4 With solution substitution cid260 renaming cid230 free function variables totally instantiated catch cid260 8 4C VD 4cid25 0 cid260 4cid230 4 lenaddn x cid17 slenx lenaddn x cid17 slenx 28 29 appaddn x y cid17 addn appx y 30 31 plussy z cid17 splusy z 4cid25 0 4cid230 4 4 cid230 4 cid260 g admissible C fcid8g AX jD cid260 Since fcid25 0 4C 4s proved reuse based PS1 cf Theorem 43 Note different instantiations F 1plus versus F 23sw2 essential success reuse attempt proof shell PSs fails iii Let 5 VD minusplusdhalfx uhalfx x cid17 0 functions minus dhalf 9 uhalf given deﬁning equations minus1 minus0 y cid17 0 minus2 minussx 0 cid17 sx minus3 minussx sy cid17 minusx y dhalf1 dhalf2 uhalf1 uhalf2 dhalf0 cid17 0 dhalfsx cid17 uhalfx uhalf0 cid17 0 uhalfsx cid17 sdhalfx The step formula 5s VD minusplusdhalfx uhalfx x cid17 0 minusplusdhalfsx uhalfsx sx cid17 0 computed 5 lemma lem2 plusx y cid17 plusy x proof shell PS5s Fig 5 obtained proof 5s simple analysis cid85S VD F KH x Gx x cid17 A F KH Dx GDx Dx cid17 A 8 9 32 H Dx cid17 Gx 33 GDx cid17 DH x 34 Kx y cid17 Ky x 35 KDx y cid17 DKx y 36 F Dx Dy cid17 F x y C5S VD Fig 5 The proof shell PS5s obtained proof 5s simple analysis C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 43 cid85S0 VD F KH x Gx x cid17 A F KH Dx GDx Dx cid17 A 9 8 37 H Dx cid17 Gx 38 GDx cid17 D4H x 39 Kx y cid17 K 3y x 40 K 3D4x y cid17 D6Kx y 41 F D6x Dy cid17 F x y C5S0 VD Fig 6 The proof shell PS5s0 obtained proof 5s0 reﬁned analysis Now let 6 VD orevenx oddx cid17 true functions odd given deﬁning equations ortrue y cid17 true or1 orfalse y cid17 y or2 even1 even0 cid17 true even2 evensx cid17 oddx odd1 odd2 odd0 cid17 false oddsx cid17 evenx The step formula 6s VD orevenx oddx cid17 true orevensx oddsx cid17 true computed 6 proof shell PS5s Fig 5 applies matcher cid255 VD fF w1 Kor H Godd Ds Atrueg appropriate ﬁrstorder variable renaming cid235 However fcid255 cid235g admissible C5S fcid85Sg cid255 demands sort assignment viz H nat bool D nat nat Eq 33 cid17 DH x C5S illsorted By reﬁned analysis proof shell PS5s0 Fig 6 obtained This proof shell applies matcher cid255 appropriate ﬁrstorder variable renaming cid235 step formula 6s fcid255 cid235g admissible C5S0 fcid85S0g wellsortedness cid255 spoil wellsortedness Eq 38 cid17 D4H x C5S0 With solution substitution cid265 VD fD46w1 K 3orw2 w1g free function variables totally instantiated catch cid265cid255cid235C5S0 obtained cid265cid255cid235C VD 8 42 evensx cid17 oddx 43 oddsx cid17 evenx 44 orx y cid17 orx y 45 ory x cid17 orx y 46 x cid17 x 9 44 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 Since fcid255 cid265 cid235g admissible C5S0 fcid85S0g AX jD cid265cid255cid235C5S0 n f45g 6s proved reuse based PS5S0 provided speculated lemma 45 veriﬁed Note introduction free function variables D4 reﬁned analysis essential success reuse attempt proof shell PS5s fails 7 Automated proof reuse The developments preceding sections implemented following way An automated interactive ﬁrstorder theorem prover computes proofs reﬁned analysis calculus From analyzed proofs proof shells according Corollary 613 obtained collected proof dictionary PD collection proof ideas organized ﬁnite set proof shells Now theorem prover called verifying new conjecture proof dictionary PD searched proof shell PS D hcid8 Ci 1 D cid23 cid14 cid25cid8 2 cid23 cid14 cid25C cid26 F cid6 V 3 AX jDS cid23 cid14 cid25C schematic variable renaming cid23 schematic substitution cid25 admissible C fcid8g If successful AX jDS veriﬁed reuse cid23 cid14 cid25C jDS Reuse Theorem 51 We solve problem ﬁnding proof shell PS substitutions cid23 cid25 given conjecture given proof dictionary PD steps In retrieval step proof dictionary PD searched proof shell PS D hcid8 Ci D cid230 cid14 cid250cid8 schematic variable renaming cid230 schematic substitution cid250 admissible C fcid8g The composed substitution cid230 cid14 cid250 called retrieval matcher cid8 applied schematic catch C yielding partially instantiated catch C0 VD cid230 cid14 cid250C If C0 6cid26 F cid6 V cid81 2 C0nF cid6 V selected adaption step schematic variable renaming cid231 schematic substitution cid251 computed fcid230 cid250g fcid231 cid251g admissible C fcid8g cid231 cid14 cid251cid81 2 F cid6 V The composed substitution cid231 cid14 cid251 called partial adaption candidate C0 applied C0 yielding C1 VD cid231 cid14 cid251C0 If C1 6cid26 F cid6 V partial adaption candidates cid232 cid14 cid252 cid233 cid14 cid253 computed C1 C2 eventually totally instantiated catch Cn VD cid23n cid14 cid25n cid230 cid14 cid250C cid26 F cid6 V obtained Then cid23n cid14 cid25n cid14 cid1 cid1 cid1 cid14 cid231 cid14 cid251 total adaption candidate cid230 cid14 cid250C Finally recursively called veriﬁcation step proving AX jD 0 0 2 Cn If successful cid23n cid14 cid25n cid14 cid1 cid1 cid1 cid14 cid231 cid14 cid251 adaption matcher cid230 cid14 cid250C AX jD veriﬁed reuse The recursive calls necessitate recursive calls reuse members Cn 0 reuse fails proved directly theorem prover In case proof dictionary extended proof shell based analyzed proof 0 Also original conjecture proved directly theorem prover subsequent extension proof dictionary C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 45 attempt prove reuse fails veriﬁcation AX jD 0 fails 0 2 Cn proof shells retrieved 14 71 Secondorder matching Secondorder matching key concept computation retrieval adaption matchers Since secondorder matching decidable ﬁnitary cf 41 imagine algorithm matchp t solves solvable matching problem Tp C tU computes ﬁnite set fcid221 cid14 cid261 cid22n cid14 cid26ng secondorder substitutions pattern p 2 T cid6 cid10 V U target t 2 T cid6 V cid22i cid14 cid26i p D t 2 f1 ng cid22i schematic variable renaming cid26i schematic substitution We apply match patterns p 2 F cid6 cid10 V U targets t 2 F cid6 V treating quantiﬁers connectives like function symbols To incorporate sortal reasoning matching algorithm supplied arguments cid5 M hold context matchers computed cid5 ﬁnite set schematic variable renamings schematic substitutions M ﬁnite set mixed formulas demand addition fcid22i cid26ig cid5 admissible M cid22i cid14 cid26i 2 matchp t cid5 M See Appendix A deﬁnition matching procedure incorporating sorts 72 Retrieval proof shells Retrieval task selecting proof shell PS proof dictionary computing substitutions cid25 cid23 given conjecture PS applies cid25 cid23 Deﬁnition 71 Proof shell applies A proof shell PS D hcid8 Ci applies conjecture 2 F cid6 V schematic substitution cid25 cid10 T cid6 W ﬁrstorder variable renaming cid23 U V iff 1 cid23 cid14 cid25cid8 D 2 fcid25 cid23g admissible C fcid8g Here requirement 1 states cid23 cid14 cid25 syntactical schematic matcher cid8 cid25 pure closed substitution function variables cf Deﬁnition 42 cid23 renames ﬁrstorder variables Requirement 1 relaxed cid23 cid14 cid25cid8 allows equivalence preserving transformations like swapping sides equations reordering subformulas skolemizing universally quantiﬁed variables These extensions syntactical matching included matching algorithm cf 19 dealt preprocessing step cf 50 Applicability proof shell hcid8 Ci conjecture decided calling matchcid8 C fcid8g applicable proof shells recognized considering member proof dictionary 14 If simpliﬁer component induction prover cf Section 1 shall supported reuse Cn cid26 ThindAX tested instead AX jD Cn necessitate recursive calls reuse induction formulas computed members Cn 46 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 However selection process indeterminisms resolved suitable heuristics One proof shell apply conjecture matchers ii Several proof shells schematic conjecture apply conjecture iii Several proof shells different schematic conjectures apply conjecture Indeterminism based nonuniqueness secondorder matching matching problem TF Gx x C fgx xU solutions cid251 VD fF fw1 w2 Ggw1g cid253 VD fF fgw1 w1 Gw1g cid255 VD fF fgw2 w2 Gw1g cid252 VD fF fgw1 w2 Gw1g cid254 VD fF fgw2 w1 Gw1g cid256 VD fF w1 Gfgw1 w1g cid15 C0 n cid15 C1 n cid15 C2 n To resolve indeterminism propose heuristic rating selecting matchers according structural complexity For example cid251 considered complex matcher close replacing function variables function symbols solutions considered complex The underlying motivation select matcher preserves given structure proof reused far possible likely ﬁnd valid instance schematic catch cid18 T cid6 Wn functional case For rating matchers heuristically use hierarchy Ci n terms complexity increases based term structure experience occurrences functional terms matchers examples VD ff w1 wn j f 2 cid6ng Function variables replaced function symbols arity respecting order arguments VD ff wi1 win j f 2 cid6n fi1 ing D f1 ngg Function variables replaced function symbols arity possible rearrangement argument order VD ff wi1 wim j f 2 cid6m i1 im 2 f1 ngg Function variables replaced function symbols Here arguments function symbols rearranged multiplied omitted cid15 C3 n cid15 C4 n n This set additionally includes projections including identity VD Wn C2 VD ff1f2 fkw1 wn j f1 fkcid01 2 cid61 fk 2 cid6n k 1g This set includes compositions unary function symbols nary function VD ff1f2 fkwi1 wim j f1 fkcid01 2 cid61 fk 2 cid6m k 1 i1 cid15 C5 n im 2 f1 ngg This set combines features C2 VD T 0cid6 Wn recursively deﬁned cid15 C6 n Wn cid18 T 0cid6 Wn f wi1 wijcid01 t wijC1 wik 2 T 0cid6 Wn f 2 cid6k t 2 T 0cid6 Wn n C4 n i1 ij cid01 ij C1 ik 6 n This set includes combinations projections compositions argument orderings recursively argument position functional term occupied nonvariable term cid15 C7 n VD T cid6 Wn For ﬁxed n ﬁnd C0 n cid18 C1 n cid18 C2 n cid18 C3 n C4 n cid18 C5 n cid18 C6 n C0 n cid18 C4 n C2 n cid18 C5 n C3 n cid18 C6 n C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 47 classes form hierarchy decreasing simplicity For matcher cid25 let X ratecid25 VD rateminfi j F 2 cid10n cid25F 2 Ci n g cid25F F 2domcid25 measure complexity replacing functional terms ratei t heuristically determined function yielding natural number rating complexity functional term t 2 T cid6 W We use ratei t VD C cid6 t cid6 T cid6 W N yields number occurrences function symbols functional term deﬁnition proved useful experiments Now indeterminisms kind resolved selecting matcher cid25 minimal ratecid25 retrieval matchers For obtaining efﬁcient implementation selection matcher built matching algorithm selectable matcher computed Our approach reusing proofs based heuristical assumption similar conjectures similar proofs However heuristic fail certain statements happen proof shells share schematic conjecture renaming symbols schematic conjectures different schematic catches results indeterminisms kind ii For instance consider proof shells PS1 D h F A Gv w cid17 H KB v w fF A u cid17 u KB u cid17 u Gu u0 cid17 H u u0gi PS2 D h F A Gv w cid17 H KB v w 0 H B KB u cid17 B fF A u cid17 A 0 0 u cid17 A 0 gi stem analyzed proofs base case associativity plus times respectively Both proof shells apply exactly conjectures like min0 miny z cid17 minmin0 y z max0 maxy z cid17 maxmax0 y z heuristic selection applicable proof shells required To effect compare partially instantiated catches applicable proof shell estimating expected effort computing adaptation matcher We prefer catches minimal number function variables minimal number proof obligations maximal ratio previous reuse successes versus failures However choice point gives room backtracking human guidance sophisticated selection criteria The retrieval proof shells supported proof shells hcid8 C1i hcid8 Cni sharing conjecture cid8 grouped proof volume P V D hcid8 fC1 Cngi proof dictionary organized set proof volumes instead A proof volume represents different proof ideas statement retrieval supported proof dictionary based proof volumes schematic conjectures considered proof dictionary based proof shells cf 5457 48 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 Indeterminism iii results ﬂexibility secondorder matching structurally different patterns p1 VD F Gx y p2 VD H x z Ky match target t VD ay bx matchers cid251 VD fF aw2 w1 Gbw1g cid252 VD fH aw3 bw1 Kw1g While use heuristic developed select applicable proof volume complex retrieval matcher high reusability emphasized price efﬁcient retrieval propose restriction class useful matchers A matcher cid25 cid10 T cid6 W called simple iff F 2 domcid25 cid10n implies cid25F D f wcid111 wcid11n f 2 cid6n permutation cid11 f1 ng Hence simple matcher replaces function variables function symbols arity order arguments rearanged covering fairly large class useful matchers A proof volume simply applies sapplies conjecture iff applies simple matcher proof dictionary called sminimal iff conjecture proof volume sapplies Sminimal proof dictionaries obtained proof shells form proof volumes based results reﬁned analysis cf 54 Sminimal proof dictionaries sapplication reduces number retrieval matchers considerably price reduced reusability If retrieval matcher computed given conjecture ﬁnal selection based heuristic developed case 73 Adaptation proof shells After selection proof shell PS D hcid8 Ci proof dictionary computation retrieval matcher cid230 cid14 cid250 mixed formula cid81 2 F cid6 V selected partially instantiated catch cid230 cid14 cid250C partial adaption candidate cid231 cid14 cid251 computed cid81 Since aim compute adaption matcher cid81 matched object formula 2 F cid6 V satisfying AX jD means matching performed theory deﬁned set axioms AX However problem deciding adaption candidate adaption matcher undecidable semantical entailment Consequently heuristics required adaption step strongly depend domain consideration represented axioms AX Therefore useful develop adaption heuristics heuristics developed automated theorem proving domain consideration cases computed adaption candidates fact adaption matchers In induction theorem proving domain instance deﬁning equations applied terms induction formula guided heuristic symbolic evaluation cf 82 In domain function symbol constructor data structure deﬁned function symbol speciﬁed axioms For instance declaration structure addnumber list V list deﬁnes data structure linear lists natural numbers constructors add axioms len1 len2 Example 616 deﬁne function len computing length list A term t evaluated applying deﬁning equations C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 49 function symbols contained t Thus lenaddlenempty z evaluated lenadd0 z slenz applying deﬁning equations len This called symbolic evaluation term evaluated contain variables z evaluated Note deﬁning equations considered evaluation term splusplusx y z remains nonevaluable associativity plus given lemma Here assume symbolic evaluator implemented terminating operation eval computes normal form term evall 2 T cid6 V EQ jDS l cid17 evall 47 evalevall D evall holds l 2 T cid6 V set AX D EQ L axioms We use symbolic evaluator computation adaption candidates following way In ﬁrst step mixed equation l1 cid17 R1 R1 cid17 l1 selected partially instantiated catch C1 VD cid230 cid14 cid250C l1 2 T cid6 V equation exists compute cid51 VD R1 2 T cid6 V We matchR1 evall1 fcid230 cid250g C fcid8g If cid51 6D matching successful partial adaption candidate cid231 cid14 cid251 selected cid51 Otherwise deﬁne cid231 VD cid251 VD l1 cid17 R1 inserted socalled remainder set X Then continue C2 VD cid231 cid14 cid251C1nfl1 cid17 R1g equation l2 cid17 R2 selected C2 l2 2 T cid6 V R2 2 T cid6 V We equation exists C2 6D compute cid52 VD matchR2 evall2 fcid231 cid251 cid230 cid250g C fcid8g Adaption terminates set Cn contains mixed equation l cid17 R R cid17 l l 2 T cid6 V R 2 T cid6 V Adaption failed cid3 VD Cn cid23n cid14 cid25n cid231 cid14 cid251X 6cid18 F cid6 V C Otherwise cid23n cid14 cid25n cid14 cid1 cid1 cid1 cid14 cid231 cid14 cid251 computed total adaption candidate cid230 cid14 cid250C Ccid3 totally instantiated catch proved equations removed We principle computing adaption candidates matching modulo evaluation combines automated reasoning syntactical secondorder matching attempt solve matching problem TR C evallU instead TR C lU The procedure computing adaption candidates choice points require determination 1 The selection mixed equation li cid17 Ri Ci guided heuristic prefers mixed equation probably number matchers cid26 solving evalli D cid26Ri constrained equations function variables lhs chosen We consider equation high number function symbols low number function variables highly constrained criteria limit number possible matchers cf 55 2 The selection adaption candidate cid23i cid14 cid25i cid5i guided heuristic prefers simplest matcher solving chosen equation l cid17 R number function symbols introduced cid26 minimal cf 55 For example fF w2g preferred fF lenw1g equation lenx cid17 F x lenx The underlying motivation select matcher preserves given structure proof ing reused likely ﬁnd valid instance schematic proof case 50 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 Example 72 Matching modulo evaluation Reconsider conjecture 4 VD pluslenx leny cid17 lenappx y step formula 4s Example 616 Since proof shell PS1 D hcid8 Ci Fig 4 applies 4s matcher cid25 VD fF 1plus G123len H 1app D1addg appropriate ﬁrstorder variable renaming cid23 cf Example 616 partially instantiated catch Cp VD cid25C D 8 lenaddn x cid17 F 2n lenx 48 49 appaddn x y cid17 D4n appx y lenD4n x cid17 F 3n lenx 50 51 plusF 2x y z cid17 F 3x plusy z 9 computed step case We choose Eq 48 evaluate left hand lhs 48 deﬁning axiom len2 yielding slenx cid17 F 2n lenx Now lhs matches rhs unique matcher cid261 VD fF 2sw2g means 48 solved cid26148 D len2 We apply cid261 remaining mixed formulas obtain cid261Cp n f48g VD 8 49 appaddn x y cid17 D4n appx y lenD4n x cid17 F 3n lenx 50 52 plussy z cid17 F 3x plusy z 9 We continue mixed equation lhs contain function variables 49 52 Here choose 49 evaluating lhs deﬁning axiom app yields addn appx y matches rhs unique matcher cid262 VD fD4addg Now lhs cid26250 ﬁrstorder evaluated cid263 VD fF 3sw2g obtained matching free function variables instantiated adaptation candidate cid26 VD fF 2sw2 F 3sw2 D4addg Since remaining proof obligation cid2652 D plussy z cid17 splusy z deﬁning axiom plus cid26 adaptation matcher proof reuse completed successfully Note symbolic evaluation essential success adaptation For example example adaptation candidate computed unevaluated object terms equations targets matching problems See 55 detailed account matching modulo evaluation After totally instantiated catch computed retrieval adaption resulting proof obligations subject veriﬁcation necessitate recursive calls reuse While recursive reuse generally increases potential savings search costs introduces problem termination For instance partially instantiated catch fgb cid17 A00 fA00 cid17 ag computed proving fgb cid17 reuse based proof shell PScid3 Example 62 simplest solution fA00gbg matching C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 51 problem TA00 C gbU yields fgb cid17 remaining proof obligation Since exactly conjecture consideration recursive reuse terminate example A remedy problem impose restrictions adaption candidates avoids inﬁnite reuse attempts However restrictions depend reasoning domain consideration See 5658 restrictions guaranteeing termination recursive reuse domain induction theorem proving examples paper obey restrictions 8 Experiments reusing proofs We implemented prototype called PLAGIATOR 1351 consists device analyzing generalizing managing proofs based techniques discussed If statement veriﬁed reuse user support proof analyzed The creation hand crafted proof supported proof editor The proof editor checks inference rules legally applied offers support ﬁnding proof This means weak problem solving ability motivating systems namethe German word plagiaristas intended obtain exhibiting intelligent behavior able adapt solutions provided intelligent devices Thus apart initial proofs provided human advisor prove step steps implemented reuse procedure necessitates human support Hence proof shell Fig 4 automatically reused proving step formulas apparently different conjectures given Table 1 This table illustrates typical session PLAGIATOR At beginning session human advisor submits statement 0 ﬁrst row proof p 0 Then statements 1 2 presented PLAGIATOR proves step formula statement reuse p user interactions required The column shows subgoals speculated proving statement reuse proof obligations returned instiating schematic catch Here cid0 denotes proof obligations simpliﬁed tautologies evaluation statement proved reuse T U denotes heuristics different heuristics given Section 7 For example statement 17 speculated verifying 16 leads speculating 18 turn entails speculation conjecture 19 eventually 25 speculated For 5 instance conjecture 11 speculated viz formula cid27511 cid275 D fpm VV g The speculated conjectures 53 56 proved reusing proof 0 53 VD maxm maxn cid17 maxmaxm n 54 VD minm minn cid17 minminm n 55 VD ororeqm n b cid17 oreqm n ora b 56 VD ifeqm n k n VV l p cid17 ifeqm n k p n VV l p 52 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 Table 1 Conjectures proved lemmata speculated reuse 0 X X X 15 0 cid8 No 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 k C l cid17 k l 25 F 1G1x G2y cid17 G3H 1x y Conjectures proved reuse Y Y Y k cid2 l cid17 k l j k l j cid17 j l k j j revk j cid17 j k j revrevk cid17 k Subgoals 18 12 13 14 revl revk cid17 revk l cid27511 maxmaxlk maxll cid17 maxlk l minminln k minln l cid17 minln k l pluslm k pluslm l cid17 pluslm k l j k j C j l j cid17 j k l j ncutm ncutn k cid17 ncutplusm n k k l p cid17 k l p j k n VV l j cid17 sj k l j j k n VV j cid17 sj k j revk n VV cid17 n VV revk k cid17 k inm cid17 imcid2n im cid2 cid17 imCn m cid2 n cid2 cid17 m cid2 n cid2 m cid2 C n cid2 cid17 m C n cid2 m cid2 C n cid2 cid17 cid2 m C n m cid2 n cid17 n cid2 m m cid2 sn cid17 m C m cid2 n m C C n cid17 C m C n m C n cid17 n C m m C n C cid17 m C n C m C sn cid17 sm C n m C 0 cid17 m m cid2 0 cid17 0 m cid2 s0 cid17 m 2m C 2n cid17 2m C n ormemm k memm l cid17 memm k l rmm k rmm l cid17 rmm k l 53 54 cid0 cid0 cid0 cid0 cid0 cid0 cid0 cid0 T17U 18 T19U 25 T22 25U T22U T23U 26 26 cid0 cid0 cid0 Tcid0U Tcid0U cid0 55 56 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 53 If let cid25i denote matcher cid8 step formula matcher cid251 D fF 1cid2 D1add g replaces function variables function symbols cid2530 cid2530D1 D sw2 makes use functional terms This allows reuse proof step formula 0 involving data structure list conjecture concerning data structure number Similarly cid255F 1 D appw2 w1 swaps arguments F 1 cid2526G1 D w1 uses projection match schematic step formula The applicability proof shell increased freeze variables constants universally quantiﬁed variable z 2 V regarded new constant z 2 cid60 Freezing variables allows match function variable F 2 cid10n object term having n variables Thus conjecture 19 distributivity law cid2 C matches schematic conjecture cid8 cid2519G123 D cid2w1 2 T cid6 W matcher 16 In cases denoted T U retrieval heuristic Section 7 chooses unsuccessful matcher For alternative successful retrieval matcher provided user adaptation heuristic usually works cases 9 Related work The way proving theorems mathematical induction called explicit induction explicit computation application induction axioms Explicit induction implemented successfully induction theorem proving systems like NQTHM 1112 INKA 543 OYSTERCLAM 1517 partly based following techniques computation induction axioms 8081 wellfounded orderings obtained termination proofs algorithms 3583 ii guiding proof induction formulas rippling 1642 iii generalization lemma speculation 444582 In 70 method combining ii postponing commitment ﬁxed induction axiom presented When applying reuse method induction theorem proving assume induction axioms computed reuse ﬁrstorder proof provide alternative technique ii iii Note proofs statements examples obtained rippling 1642 This method attempts reduce syntactical differences induction conclusion induction hypotheses application lemmata deﬁning equations goal directed way To effect equations carry annotations denoting Q P 15 For sake readability use mathematical inﬁx symbols functions appropriate cid2 C cid0 j j VV denote times plus minus app len add sum prod respectively Further rev reverses list max respectively maxl min respectively minl computes maximum minimum numbers respectively list numbers plusl sums lists numbers pairwise ncut removes elements list mem decides list membership rm removes occurrences element list We use convention respect variable names j n m denote numbers k l p q denote lists x y z variables sort 16 This kind skolemization sound 8z TzU valid iff TzU valid Skolem constant z formula TzU free variable z 54 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 syntactical difference reduced equation applied Since rippling reuse proposal based different principles method fail succeeds certain proof problem For example proposal restricted induction domain rippling requires induction conclusion induction hypotheses compute differences reduced On hand statement easily proved rippling proved reuse appropriate proof shell available Rippling fails given equations annotated For example step formulas 5s 6s Example 616iii proved rippling mutual recursion annotation deﬁning equations dhalf2 uhalf2 even2 odd2 computed But step formula 6s easily proved reuse required adaption matcher easily computed matching modulo evaluation The utilization past problem solving experience attracted researchers right beginning AI considerably different methodologies proposed years We brieﬂy sketch proposals applied theorem proving discuss similarities signiﬁcant differences method 91 Reasoning analogy Analogical reasoning AR uses representational mapping map problems solutions source target domain cf 383948 Fig 8iv If new problem target domain represented image solved source problem representational mapping recognition tried map source problems solution target domain elaboration result serves candidate target problems solution veriﬁed repaired subsequently evaluation In present research applying analogical reasoning theorem proving 9101468 suitable source conjecture given selected matched target conjecture source proof mapped target domain step step guiding target proof Thus elaboration evaluation interleaved repairing proposed target proof adding removing intermediate inference steps necessary step suggested analogy applied This leads new problems concerning control repairing actions Viewed framework representational mapping initially given second order matching conjectures schematic conjectures retrieval cid24D recognition extended instantiating free function variables schematic catch adaptation cid24D elaboration subsequent veriﬁcation resulting equations prove cid24D evaluation Hence approach reuse based axioms proof source problem veriﬁed target domain new proof constructed uniform way patching instantiated schematic proof 53 17 The fact method reusing proofs considers conjecture axioms source problems solution constitutes main difference applications analogical reasoning theorem proving reuse based proof structure modiﬁed increasing reuse success Consequently 17 This required concerned provability existence proof C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 55 analogical reasoning demands proof replayed guarantee soundness analogical inferences Our method provides increased ﬂexibility reuses secondorder substitutions repair replay required cf Theorem 43 These beneﬁts hold development reasoning analogy resolution logic proposed 20 Here given refutation clause set generalized replacing ﬁrstorder terms secondorder terms subsequent application socalled generalization rules separate different occurrences function predicate symbols like proposal reﬁned analysis instantiate variables eliminate variable function symbols change arity function predicate symbols These rules aim generalize refutation possible avoid generalizations necessitate expensive computation retrieval matchers cause subsequent proofs analogy fail If new clause set S investigated unsatisﬁability S matched generalizations computed refutation S obtained applying second order matcher match succeeded generalization For instance given refutation cid8 S D fqx1 x2 px1 x3 px2 x3g fqa bg fpa pb bg fpb x4g cid9 refuation cid8 S1 D fqa pb rc dg fqag fpb dg frx dg cid9 obtained proposed analogy reasoning method However approach fails clause set S2 D cid8 fqx1 x2 px1 x3 rx2 x3g fqa bg fpa c sd fsd x4gfrb x5g cid9 generalization refutation S match S2 If apply reuse approach resolution schematic catch Fig 7 obtained refutation S reﬁned analysis Since clause sets considered schematic conjecture exists new clause set Snew matched CS test unsatisﬁability This test succeeds iff Snew jDsub cid25CS secondorder substitution cid25 jDsub denotes clause 8 1 2 3 4 5 fQu1 u2 P u1 u3 Ru2 u3 g fQA B g fP A C SD E g fSD u4 g fRB u5g 9 CS VD Fig 7 The schematic catch CS refutation S 56 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 set subsumption This reasoning sound CS unsatisﬁable cid25CS unsatisﬁable Snew unsatisﬁable The secondorder substitution cid25 VD cid8 Qqa P pb Rrc d Srw2 w1 Dd Ee cid9 satisﬁes requirement clause set S1 cid25CS D S1 ffrc dgg Hence S1 unsatisﬁable obviously unsatisﬁability S2 proved way S2 onetoone reformulation CS But increase reusability comes prize high search costs caused complexity matching clause sets computing retrieval matcher cid25 Therefore techniques tailored domain cf 21 appropriate approach While discussed transformational analogy paradigm far based mapping problems solutions derivational analogy paradigm 6187677 problem solving process considered mapping Hence reuse technique based past problem solving experiences cf 61 application theorem proving The ABALONE Melis Whittle 62 uses transformational derivational analogy domain inductive theorem proving Given source theorem proof plan computed execution yields proof theorem For target theorem proved function symbols source axioms proof mapped function symbols target conjectures required prove target Then proof plan replayed step step andif requiredmodiﬁed reformulated goal directed way Although similarities reuse proposal association source target secondorder substitutions indexing function symbols different occurrences explicit speculation lemmata proposals differ signiﬁcantly aspects 1 Whereas reuse method concerned ﬁrstorder reasoning proofs base step cases ABALONE covers computation induction schemas generalizations 2 Our reuse method based analysis proof ABALONEs analogy method based proof plan The feature particular requires rules proof plan reformulation corresponds adaption step matching modulo evaluation proposal As ﬁrstorder examples paper easily solved reuse method concluded paper increased effort proof plan replay reformulation increases success analogy fact On hand ABALONE fails examples viz 17 18 19 Table 1 reported 86 92 Explanationbased learning Our proposal viewed variant explanationbased learning EBL cf 22 3064657273 28 survey This paradigm aims improve problem solver generalizing concrete problem solution derived explaining solution example problem given background knowledge At ﬁrst given problem solved problem solution generalized technique goal regression cf Fig 8i If new problem instance generalized problem C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 57 iii ii iv Fig 8 Related machine learning paradigms Solve analyse ii Reuse iii Abstraction iv Analogy corresponding instance generalized solution obtained speciﬁc features remain require subsequent solution steps cf Fig 8ii In EBL generalized problem called nonoperational goal concept generalized solution corresponding operational specialization The background knowledge given domain theory In terminology schematic conjecture respectively schematic catch resembles goal concept respectively operational specialization domain theory given initial axioms lemmata However EBL merely provides reformulation solution level lacks incorporation abstractions sense 3663 Applied theorem proving goal regression computes EBLgeneralizations replace ﬁrstorder terms ﬁrst order variables far weak frequent reuse 27476775 We replace ﬁrstorder terms certain secondorder terms counts remarkable increase reusability compared standard EBL approach cf Section 8 examples The advantages higherorder concepts recognized particular Donat Wallen 27 Dietzen Pfenning 26 Donat Wallen generalized standard EBL higherorder resolution domain symbolic integration In domain rules symbolic integration represented conditional production rules R R R 1 2 3 XA dX 7 XAC1A C 1 constantA A 6D cid01 C cid3 A dX 7 C cid3 sinX dX 7 cid0cosX A dX constantC R R These rules applied integration problems sequence 4 x2 dx 7 3 cid3 x33 3 cid3 x2 dx 7 3 cid3 R R 3 cid3 x2 dx yielding solution 58 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 From solution sequence generalized rule computed higherorder resolvent production rules sequence example C cid3A dX 7 GZDC1D C1 constantD D 6D cid01 constantC 5 F R R R F C cid3 A dY D G ZD dZ obtained R Generalized rules applied new integration problems like given rules 2 cid3 x3 dx However 2 cid3 x44 obtained applying 5 integration problem generalized rule encodes rules particular solution sequence application fails integration problems need reorder applied rules replace rules cf 27 In particular function symbols like cid3 sin symbol exponentiation generalized instance 3 cid3 sinx dx computed 3 cid3 sinx dx The application generalized rule 5 fails 5 applied rule 3 instead 1 solve integral Applying reuse approach domain proof shell Fig 9 obtained 4 simple analysis R 3 cid3 sinx dx proof shell PSint applies Since 3 cid3 sinx dx matcher cid25 VD fF w1 cid3 w2 C3 Gsinw1 Xxg yielding F C GX A dX matches R R R R partially instantiated proof shell Fig 10 The partially instantiated catch Fig 10 solvable yielding simpliﬁcation step cid03 cid3 cosx result integration problem cid251 variant rule 2 Z cid8int VD F C GX A dX 7 F C H GX A C 1 A C 1 constantC constantA A 6D cid01 8 Z Z 1 F D Y dZ 7 F D Y dZ constantD Z 2 GU B dU 7 H GU B C 1 B C 1 constantB B 6D cid01 9 Cint VD Fig 9 The proof shell PSint solution sequence 4 Z cid25cid8int VD 3 cid3 sinx dx 7 3 cid3 H sinx A C 1 constantA A 6D cid01 8 Z Z cid251 D cid3 Y dZ 7 D cid3 Y dZ constantD Z cid252 sinU dU 7 H sinU B C 1 constantB B 6D cid01 9 cid25Cint VD Fig 10 The partially instantiated proof shell cid25PSint C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 59 R R 112g solves cid252 fH cid01 cid0 w2 sinU dU 7 cid0cosU rule 3 cosU D 1 cid0 sin2U 12 A similar observation proposal Dietzen Pfenning 26 For example generalized rule C cid3 XA dx 7 C cid3 XAC1A C 1 6 3 cid3 sinx dx solved 3 cid3 x2 dx computed solution 6 Our reuse proposal independent speciﬁc function symbols conjecture order rule applications catch set members considered order Therefore rules involved adaption step counts success reuse proposal example R R 93 Abstraction techniques Abstraction techniques distinguish basic abstract level problems solutions cf 43649 6978 methodology applied theorem proving A basic problem 1 mapped abstract problem abstraction mapping 2 abstract solution computed abstract problem ﬁnally 3 solution obtained given problem applying inverted abstraction mapping abstract solution cf Fig 8iii Our method differs solve basic problems generalize solutions instead solving generalized problems The reuse step 3 similar approaches cf Fig 8i ii The disadvantage abstraction sense depending abstract level problem solving abstract level difﬁcult basic level control information lost consider abstract level formulas secondorder variables simple basic solution obtained reuse step 3 incomplete large gaps closed subsequently expensive basic problem solving Therefore use abstract level representational purposes provides rigorous adaptable criteria relevant concepts viz similarity conjectures generalization instantiation 94 Casebased reasoning The rapidly growing ﬁeld casebased reasoning CBR 159606685 develops approaches store solutions data base rely purely effective retrieval large case bases adaptation techniques 732 74 The main difference method cases CBR consist set attributevalue pairs enriched information problem solving process Therefore CBR useful knowledgeintensive domains like theorem proving success domains statistical methods based similarity criteria nearest neighbor concepts apply The PRODIGY uses derivational analogy means integrate general problem solving CBR 77 Here derivational analogy exploit past cases solve similar problems problem solver successfully create case library The case base consists problems P D S G S G sets literals formed predicate constant 60 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 symbols representing initial state S goal state G P For new problem P 0 D S0 G0 case base searched similar problem S G S G similar S0 G0 literals S0 match members S goals G0 match members G Here matching means constant symbols P 0 replaced constant symbols P identical literals obtained replacement The quality matching rated number initial state literals goals match literals S G respectively The footprint similarity metric emphasizes goal oriented behaviour By application EBL techniques solution derivation problem S G member g G associated members S necessary achieving goal g Matching initial states constrained initial state literals S associated matched goals g 95 Learning theorem proving Some approaches learning theorem proving developed based learning heuristics problem solving For instance 23253334 merge experiences gained proofs learning specialized heuristic respectively instance parameterized heuristic considered domain genetic algorithms 33 adaptation weights 34 recognition useful facts 23 These methods based property applied proof calculus equational reasoning unfailing KnuthBendix completion 3 viz central decision instance selection critical pairs controlled heuristic This allows easy combination fromscratch theorem proving makes harder combine specialized heuristics different purposes teamwork approach 2 partial remedy The method 71 reusing proofs software veriﬁcation based replay inference rules failed proof attempt faulty conjecture subsequent modiﬁcation axiomsparts failed proof reused new proof attempt A similar approach generating tactics proofs interactive environment taken 31 10 Summary conclusion We presented approach verifying theorems reusing previously computed proofs A proof analyzed essentials proof represented certain data structure viz proof shell For new veriﬁcation task suitable proof shell selected heuristically guided retrieval step subsequently adapted heuristic guidance veriﬁcation problem consideration This yields new simpler proof obligations subject veriﬁcation directly theorem prover recursively reuse This paper deﬁnes formal framework proof analysis generalization retrieval adaptation discusses problems arise proposes solutions veriﬁes soundness proposals Our approach offers beneﬁts experiments C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 61 implementation learning component theorem prover viz PLAGIATOR 1351 reveal cf Section 8 57 1 User interactions saved 2 PLAGIATOR able speculate lemmata recognizing previously computed solutions helpful prove given conjecture The feature particularly important induction theorem proving lemmata yield relevant incomplete speculation useful improvement induction provers performance cf 445658 Although beneﬁts observed toy domain unconditional equational inductive theorem proving known authors method behaves ambitious domains course answer question required assess general usefulness proposal We believe postulated beneﬁts practical domains happen worst case problem determining search proof simply turned problem determining search retrieval adaptation matchers saved worse costs increased additional overhead First investigations encouraging 50 complete answer question subject research carried stage project Acknowledgements We like thank D Hutter T Walsh clarifying rippling anonymous referees constructive suggestions Appendix A An algorithm wellsorted secondorder matching Combining tests 1 2 Deﬁnition 71 demands sorted secondorder matching algorithm particular respect sort considerations partial match performed respect sort constraints imposed C matching cid8 This want exclude early possible syntactical matchers cid8 wellsorted total instantiation C To treat formulapair hcid8 algorithm match pairs terms developed subsequently algorithm Huet Lang 41 let hR cid23i VD decomposecid8 denote preprocessing step structurally comparing cid8 quantiﬁed variables terms equations For example R VD TF u C ax Gv C b H u v C f y D C cU cid23 VD fux vyg results decomposing 8u8v F u cid17 Gv H u v cid17 D 8x8y ax cid17 b f y cid17 c 18 Hence cid23 renaming R contains pairs p C t pattern terms p 2 T cid10 U target terms t 2 T cid6 V decompose succeeds R D T U denotes cid8 structurally different 18 We use PROLOGstyle list notation Ta1 anU respectively TajRU 62 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 Thus proof shell PS D hcid8 Ci applies conjecture cid25 cid23 iff hR cid23i VD decomposecid8 succeeds cid25 matcher matching problem cid23R VD Tp1 C t1 pn C tnU cid25pi D ti 2 f1 ng fcid25 cid23g admissible C fcid8g We present matching calculus computing cid25 invoked triple hcid23R fcid23g fgi operates respect ﬁxed set mixed formulas M VD C fcid8g Deﬁnition A1 Manysorted secondorder matching calculus The manysorted second order matching calculus consists rules operating triples hR cid5 cid25i input component R VD Tp1 C t1 pn C tnU matching problem respect ﬁxed set mixed formulas M input component cid5 set schematic substitutions variable renamings output component cid25 schematic substitution Let x 2 V f 2 cid6n p1 pn 2 T cid6 cid10 V U t1 tn tm t 2 T cid6 V F 2 cid10n g 2 cid6m cid15 Variable hTx C x j RU cid5 cid25i hR cid5 cid25i cid15 Decomposition hTf p1 pn C f t1 tn j RU cid5 cid25i hTp1 C t1 pn C tn j RU cid5 cid25i cid15 Projection hTF p1 pn C t j RU cid5 cid25i hTcid25i pi C t j cid25iRU cid5i cid25i cid14 cid25i cid5i VD cid5 fcid25ig admissible M cid25i VD fF wi g 2 f1 ng cid15 Imitation hTF p1 pn C gt1 tm j RU cid5 cid25i hTG1cid250p1 cid250pn C t1 Gmcid250p1 cid250pn C tm j cid250RU cid50 cid250 cid14 cid25i cid50 VD cid5 fcid250g admissible M cid250 VD fF gG1w1 wn Gmw1 wng new 19 function variables G1 Gm 2 cid10n A sequence hhR1 cid51 cid251i hRn cid5n cid25nii triples matching problems Ri sets schematic substitutions renamings cid5i schematic substitutions cid25i derivation sorted secondorder matching calculus respect ﬁxed set mixed formulas M 2 f1 n cid0 1g hRiC1 cid5iC1 cid25iC1i results applying rules hRi cid5i cid25ii A schematic substitution cid25 0 called solution matching problem R respect cid5 M iff derivation hhR cid5 fgi hT U cid5 0 cid25 0ii exists let matchR cid5 M VD cid8 cid25 j cid25 VD fF t 2 cid25 0 j F 2 cid10Rg cid25 cid9 0 solution R respect cid5 M denote set solutions R respect cid5 M domains obtained substitutions limited symbols occurring R excluding introduced function variables 19 Here new means particular cid5 M contain function variables Gj C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 63 Theorem A2 Matching proof shells Let R VD Tp1 C t1 pn C tnU matching problem respect ﬁxed set mixed formulas M let cid5 set schematic substitutions variable renamings admissible M Soundness If hhR cid5 hTU cid5 0 cid25 0ii derivation sorted matching calculus cid25 0pi D ti pi C ti 2 R cid5 cid25 0 admissible M ii Completness modulo Generality If cid25 00pi D ti pi C ti 2 R cid5 cid25 00 admissible M derivation hhR cid5 hTU cid5 0 cid25 0ii sorted matching calculus cid25 0 cid18 cid25 00 Proof Follows 41 respectively 40 adapted procedure Huet Lang notation restrictions Admissibility guaranteed tests rules calculus cid5 0 result derivation admissible M cid25 0 composed members cid5 0 2 Since matching calculus locally ﬁnite conﬁguration ﬁnitely successors derivation ﬁnite terminating sound complete matching algorithm obtained derivation solutions sorted matching problem References 1 A Aamodt E Plaza Casebased reasoning Foundational issues methodological variations approaches AI Communications 7 1 1994 3959 2 J Avenhaus J Denzinger M Fuchs DISCOUNT A distributed equational deduction Proc 6th International Conference Rewriting Techniques Applications RTA95 Kaiserslautern Germany Lecture Notes Computer Science Vol 914 Springer Berlin 1995 pp 397402 3 L Bachmair N Dershowitz DA Plaisted Completion failure Colloquium Resolution Equations Algebraic Structures Austin 1987 Academic Press New York 1989 4 R Bergmann W Wilke Learning abstract planning cases N Lavrac S Wrobel Eds Machine Learning ECML95 Proc European Conference Machine Learning 1995 Heraklion Greece Lecture Notes Artiﬁcial Intelligence Vol 914 Springer Berlin 1995 pp 5576 5 S Biundo B Hummel D Hutter C Walther The Karlsruhe induction theorem proving Proc 8th International Conference Automated Deduction CADE86 Oxford UK 1986 pp 672674 6 B Blumenthal BW Porter Analysis empirical studies derivational analogy Artiﬁcial Intelligence 67 1994 287327 7 K Börner CH Coulon E Pippig EC Tammer Structural similarity adaption I Smith B Faltings Eds Proc 3rd European Workshop CaseBased Reasoning EWCBR96 Springer Berlin 1996 pp 5875 8 A Bouhoula E Kounalis M Rusinowitch SPIKE An automatic theorem prover Proc Conference Logic Programming Automated Reasoning LPAR92 St Petersburg Russia Springer Berlin 1992 9 T Boy la Tour R Caferra Proof analogy interactive theorem proving A method express use second order pattern matching Proc AAAI87 Seattle WA 1987 pp 9599 10 T Boy la Tour C Kreitz Building proofs analogy CurryHoward isomorphism Proc Conference Logic Programming Automated Reasoning LPAR92 St Petersburg Russia Springer Berlin 1992 pp 202213 11 RS Boyer JS Moore A Computational Logic ACM Monograph Series Academic Press New York 1979 12 RS Boyer JS Moore A Computational Logic Handbook Perspectives Computing Vol 23 Academic Press New York 1988 64 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 13 J Brauburger PLAGIATORDesign implementation learning theorem prover Diploma Thesis German TH Darmstadt 1994 14 B Brock S Cooper W Pierce Analogical reasoning proof discovery Proc 9th International Conference Automated Deduction CADE88 Argonne IL 1988 pp 454468 15 A Bundy The use explicit plans guide inductive proofs Proc 9th International Conference Automated Deduction CADE88 Argonne IL Springer Berlin 1988 pp 111120 16 A Bundy A Stevens F van Harmelen A Ireland A Smaill Rippling A heuristic guiding inductive proofs Artiﬁcial Intelligence 62 1993 183253 17 A Bundy F van Harmelen C Horn A Smaill The OysterClam Proc 10th International Conference Automated Deduction CADE90 Kaiserslautern Germany 1990 pp 647648 18 JG Carbonell Derivational analogy A theory reconstructive problem solving expertise acquisition RS Michalski JG Carbonell TM Mitchell Eds Machine Learning An Artiﬁcial Intelligence Approach Vol 2 Morgan Kaufmann San Mateo CA 1986 Chapter 14 pp 371392 19 R Curien Second order Ematching tool automated theorem proving Progress Artiﬁcial Intelligence Proccedings EPIA 93 1993 pp 242257 20 G Defourneaux C Bourely N Peltier Semantic generalizations proving disproving conjectures analogy J Automat Reason 20 1998 2745 21 G Defourneaux N Peltier Partial matching analogy discovery proofs counterexamples Proc 14th International Conference Automated Deduction CADE97 Townsville Australia 1997 22 G DeJong R Mooney Explanationbased learning An alternative view Machine Learning 1 1986 145 176 23 J Denzinger S Schulz Learning domain knowledge improve theorem proving M McRobbie J Slaney Eds Proc 13th International Conference Automated Deduction CADE96 New Brunswick NJ Lecture Notes Artiﬁcial Intelligence Vol 1104 Springer Berlin 1996 pp 6276 24 N Dershowitz JP Jouannaud Rewrite systems J van Leeuwen Ed Handbook Theoretical Computer Science Formal Models Semantics Vol B Elsevier Science Amsterdam 1990 Chapter 6 pp 243320 25 RV Desimone Learning Control Knowledge ExplanationBased Learning Framework PhD Thesis Department Artiﬁcial Intelligence University Edinburgh 1989 26 S Dietzen F Pfenning Higherorder modal logic framework explanationbased generalization Machine Learning 9 1992 2355 27 MR Donat LA Wallen Learning applying generalised solutions higher order resolution Proc 9th International Conference Automated Deduction CADE88 Argonne IL 1988 pp 4160 28 T Ellman Explanationbased learning A survey programs perspectives ACM Computing Surveys 21 2 1989 163221 29 HB Enderton A Mathematical Introduction Logic Academic Press San Diego CA 1972 30 O Etzioni A structural theory explanationbased learning Artiﬁcial Intelligence 60 1993 93139 31 A Felty D Howe Generalization reuse tactic proofs F Pfenning Ed Proc 5th Conference Logic Programming Automated Reasoning LPAR94 Lecture Notes Artiﬁcial Intelligence Vol 822 Springer Berlin 1994 pp 115 32 AG Francis A Ram A domainindependent algorithm multiplan adaptation merging commitment planners DW Aha A Ram Eds Adaptation Knowledge Reuse Papers 1995 AAAI Fall Symposium Cambridge MA AAAI Press 1995 pp 1925 33 M Fuchs Learning proof heuristics adapting parameters Proc 12th International Conference Machine Learning Tahoe City CA 1995 34 M Fuchs Experiments heuristic use past proof experience M McRobbie J Slaney Eds Proc 13th International Conference Automated Deduction CADE96 New Brunswick NJ Lecture Notes Artiﬁcial Intelligence Vol 1104 Springer Berlin 1996 pp 523537 35 J Giesl Termination analysis functional programs term orderings Proc 2nd International Static Analysis Symposium SAS95 Glasgow Scotland Lecture Notes Computer Science Vol 983 Springer Berlin 1995 pp 154171 36 F Giunchiglia T Walsh A theory abstraction Artiﬁcial Intelligence 57 1992 323389 37 WD Goldfarb The undecidability secondorder uniﬁcation problem Theoret Comput Sci 13 1981 225230 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 65 38 R Greiner Learning understanding analogies Artiﬁcial Intelligence 35 1988 81125 39 RP Hall Computational approaches analogical reasoning A comparative analysis Artiﬁcial Intelli gence 39 1989 39120 40 G Huet A uniﬁcation algorithm typed cid21calculus Theoret Comput Sci 1 1975 2757 41 G Huet B Lang Proving applying program transformations expressed secondorder patterns Acta Informatica 11 1978 1131 42 D Hutter Colouring terms control equational reasoning J Automat Reason 18 1997 399442 43 D Hutter C Sengler INKA The generation M McRobbie J Slaney Eds Proc 13th International Conference Automated Deduction CADE96 New Brunswick NJ Lecture Notes Artiﬁcial Intelligence Vol 1104 Springer Berlin 1996 pp 288292 44 A Ireland A Bundy Productive use failure inductive proof J Automat Reason Special Issue Automation Proofs Mathematical Induction 16 12 1996 45 D Kapur M Subramaniam Lemma discovery automating induction M McRobbie J Slaney Eds Proc 13th International Conference Automated Deduction CADE96 New Brunswick NJ Lecture Notes Artiﬁcial Intelligence Vol 1104 Springer Berlin 1996 pp 538552 46 D Kapur H Zhang RRL A rewrite rule laboratory E Lusk R Overbeek Eds Proc 9th International Conference Automated Deduction CADE88 Argonne IL Lecture Notes Computer Science Vol 310 Springer Berlin 1988 pp 768769 47 ST KedarCabelli LT McCarty Explanationbased generalization resolution theorem proving Proc 4th International Workshop Machine Learning Irvine CA 1987 pp 93106 48 RE Kling A paradigm reasoning analogy Artiﬁcial Intelligence 2 1971 147178 49 CA Knoblock Automatically generating abstractions planning Artiﬁcial Intelligence 68 1994 243 302 50 T Kolbe Optimizing proof search machine learning techniques Doctoral Dissertation Technische Hochschule Darmstadt Shaker Aachen 1997 51 T Kolbe J Brauburger PLAGIATORA learning prover W McCune Ed Proc 14th International Conference Automated Deduction CADE97 Townsville Australia Lecture Notes Artiﬁcial Intelligence Vol 1249 Springer Berlin 1997 pp 256259 52 T Kolbe S Glesner Manysorted logic learning theorem prover G Brewka C Habel B Nebel Eds Proc 21st German Annual Conference Artiﬁcial Intelligence KI97 Freiburg Lecture Notes Artiﬁcial Intelligence Vol 1303 Springer Berlin 1997 pp 7586 53 T Kolbe C Walther Patching proofs reuse N Lavrac S Wrobel Eds Proc European Conference Machine Learning ECML95 Heraklion Greece Lecture Notes Artiﬁcial Intelligence Vol 912 Springer Berlin 1995 pp 303306 54 T Kolbe C Walther Proof management retrieval Proc IJCAI95 Workshop Formal Approaches Reuse Plans Proofs Programs Montreal Quebec 1995 pp 1620 55 T Kolbe C Walther Secondorder matching modulo evaluationA technique reusing proofs Proc IJCAI95 Montreal Quebec 1995 pp 190195 56 T Kolbe C Walther Termination theorem proving reuse M McRobbie J Slaney Eds Proc 13th International Conference Automated Deduction CADE96 New Brunswick NJ Lecture Notes Artiﬁcial Intelligence Vol 1104 Springer Berlin 1996 pp 106120 57 T Kolbe C Walther Proof analysis generalization reuse W Bibel PH Schmitt Eds Automated DeductionA Basis Applications Vol II Systems Implementation Techniques Applied Logic Series Vol 9 Kluwer Academic Dordrecht 1998 pp 189219 58 T Kolbe C Walther On terminating lemma speculations J Inform Comput 1999 appear 59 JL Kolodner CaseBased Reasoning Morgan Kaufmann San Mateo CA 1993 60 R Lopez Mantaras E Plaza CaseBased Reasoning MLnet News 1995 61 E Melis A model analogydriven proofplan construction Proc IJCAI95 Montreal Quebec Morgan Kaufmann San Mateo CA 1995 pp 182188 62 E Melis J Whittle Analogy inductive theorem proving J Automat Reason 22 1999 117147 63 RS Michalski Y Kodratoff Research machine learning Recent progress Classiﬁcation methods future directions Y Kodratoff RS Michalski Eds Machine Learning An Artiﬁcial Intelligence Approach Vol 3 Morgan Kaufmann San Mateo CA 1990 pp 330 66 C Walther T Kolbe Artiﬁcial Intelligence 116 2000 1766 64 S Minton Quantitative results concerning utility explanationbased learning Artiﬁcial Intelligence 42 1990 363391 65 TM Mitchell RM Keller ST KedarCabelli Explanationbased generalization A unifying view Machine Learning 1 1986 4780 66 G Nakhaeizadeh N Fuhr K Morik B BartschSpörl S Wess Zur Diskussion Künstliche Intelligenz 1 1996 3641 Themenheft Fallbasiertes Schließen 67 X Nie DA Plaisted Application explanationbased generalization resolution theorem proving Z Ras Ed Methodologies Intelligent Systems 4 NorthHolland New York 1989 pp 226233 68 S Owen Analogy Automated Reasoning Academic Press New York 1990 69 DA Plaisted Theorem proving abstraction Artiﬁcial Intelligence 16 1981 47108 70 M Protzen Lazy generation induction hypotheses Proc 12th International Conference Automated Deduction CADE94 Nancy France 1994 71 W Reif K Stenzel Reuse proofs software veriﬁcation R Shyamasundar Ed Foundation Software Technology Theoretical Computer Science Bombay India 1993 72 S Schrödl Explanationbased generalization negation failure multiple examples Proc 12th European Conference Artiﬁcial Intelligence ECAI96 Budapest Hungary Wiley New York 1996 pp 448452 73 A Segre C Elkan A highperformance explanationbased learning algorithm Artiﬁcial Intelligence 69 1994 150 74 B Smyth P Cunningham Deja Vu A hierarchical casebased reasoning software design Proc 10th European Conference Artiﬁcial Intelligence ECAI92 Vienna Austria 1992 75 F van Harmelen A Bundy Explanationbased generalisation D partial evaluation Artiﬁcial Intelligence 36 1988 401412 76 MM Veloso PRODIGYANALOGY Analogical reasoning general problem solving S Wess KD Althoff MM Richter Eds Topics CaseBased ReasoningProceedings 1st European Workshop CaseBased Reasoning Kaiserslautern Germany Lecture Notes Artiﬁcial Intelligence Vol 837 Springer Berlin 1993 pp 3350 77 MM Veloso JG Carbonell Derivational analogy PRODIGY Automating case acquisition storage utilization Machine Learning 10 1993 249278 78 A Villaﬁorita F Giunchiglia Inductive theorem proving abstraction Proc 4th International Symposium Artiﬁcial Intelligence Mathematics 1996 79 C Walther A ManySorted Calculus Based Resolution Paramodulation Research Notes Artiﬁcial Intelligence Pitman LondonMorgan Kaufmann Los Altos CA 1987 80 C Walther Computing induction axioms Proc Conference Logic Programming Automated Reasoning LPAR92 St Petersburg Russia 1992 81 C Walther Combining induction axioms machine Proc IJCAI93 Chambery France 1993 82 C Walther Mathematical induction DM Gabbay CJ Hogger JA Robinson Eds Handbook Logic Artiﬁcial Intelligence Logic Programming Vol 2 Oxford University Press Oxford 1994 pp 127227 83 C Walther On proving termination algorithms machine Artiﬁcial Intelligence 71 1 1994 101 157 84 C Walther T Kolbe Report proving theorems reuse Technical Report Technische Universität Darmstadt 1998 85 ID Watson An introduction casebased reasoning ID Watson Ed Progress CaseBased Reasoning Lecture Notes Artiﬁcial Intelligence Vol 1020 Springer Berlin 1995 pp 316 86 J Whittle Analogy CLAM Masters Thesis Department Artiﬁcial Intelligence University Edinburgh 1995