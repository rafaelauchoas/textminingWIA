ELSEVIER Artificial Intelligence 80 1996 197241 Artificial Intelligence A metatheory mechanized object theory Faust0 Giunchiglia ab Paolo Traverso Mechanized Reasoning Group IRST lstituto lo Ricerca Scientijica e Tecnologica 38050 Povo Trento Italy h Mechanized Reasoning Group DISA University Trento Imana 5 Trento Italy Received November 1992 revised July 1994 Abstract In paper propose metatheory MT represents computation implements object theory OT particular computation implements deduction OT To theory MT emphasize fact MT metutheory mechanized object unusual properties explicitly represents failure application inference rules fact large amounts code implementing OT partial work limited class inputs These properties allow use MT express prove tactics expressions specify compose possibly failing applications inference rules interpret procedurally assert theorems OT compile implementation code finally generate MT automatically code The definition MT larger project aims implementation selfreflective systems systems able introspect code reason possibly extend modify 1 A metatheory mechanized object theory 28 metareasoning seminal work Goedel topics philosophical formal reasoning Work mathematical Since studied research 153950 means exhaustive Our interests theorem proving metatheories Similar theory OT previous work logic 5 planning logic programming automated deduction mechanized subfields AI mathematical 47 These citations 48 11 programming logic object 11541 languages reasoning 41 Corresponding Email leaFirstitcit author Email faustoirstitcit 00043702961500 SSDlOOO47029500002X 1996 Elsevier Science BV All rights reserved 198 F Giunchilk F TucrverroArtificirrl Intelligence 80 1996 197241 metheory MT The mechanition theorem prover called GETFOL 171 Unlike previous work defined MT metatheory fact MT rnetatheory mechanized object intuitively described follows fact OT mechanized To emphasize theory This requirement takes account inside interactive performed l MT represents computation implements OT The words computation represent formally defined Section 96 In particular GETFOL function paper LISPlike representability discussion programming mean developed speaking formed recursive MT corresponding CONJ HGKM function CONJ A 1ct FALSE depending structure A conjunction symbol CONJ represented A A A conjunction false representing implementation MT predicate called HGKM 1949X5 Roughly language computation code implementing OT deduction formula vice versa Thus instance OT CONJ A e TRUE formula A recorded data HGKM Then symbol Conj hr ConjA computation br LmjA MT defined metatheory provability provable provable OT In perspective requirement o MT represents computation implements deduction OT fandi br Tz B recording T2 B implements introduction fandi represented fandirl A HGKM function rj F2 A A B OT Then fandi instance rule performing equality holds So far considered OT Section 5 GETFOL GAMMAI GAMMA B GAMMA1 GAMMA2 A AND B GAMMAl A GAMMAZ described 461 We f andi conjunction sequent version natural deduction Thus ference implements A B GAMMA1 GAMMAZ A AND B stand data structures rt A tion symbol r A r2 B r r2 A A B names theorems OT We requirement constant rule applications However certain preconditions tion elimination logic vents solved HGKM functions applied fail ment fandeltac elimination requirement implemented asserting nontheorems inside In implementation fail failure conclusion theorems MT func rl rz A A B MT rz A A B unique successftd functions applied apply conjunc definition paper It pre GETFOL defining new rules imple tactics failure For instance left conjunction disjunction This fact left implicit defined f aif Dually representability MT constant problem data structure applied Primitive returns fandel code theorem provers total version inference value returned fandel fail new function satisfy sym tactics return satisfied rules returning rules partial impossible called primitive implements explicit inference rt order E Giunti fl TraverArtjal lneliene 80 19961 191241 199 bols jandeltac MI fandeltac r A A B fandel r A A B fandeltac r A V B fail 2 Exploiting metatheory mechanized object theory Since MT metatheory deduction mechanized object theory main features 1 We construct ground wffs terms structure wffs stating respondence computation ticular structure correspondence computation object tree constructed provability object level proof steps prove theorem object cor level In par level theorem tree 2 The symbols occurring ground wffs terms corresponding bolls underlying HGKM mechanization representing symbols fandeltac sponds cability inference denoting rules primitive rprenting Conj corresponds predicates inference rules In particular tactics sym holds function fandeltac corre appli CONJ constants ronditions symbols language theorems OT A corresponds A content theorems object asserts rules Notice logic inference The firs feature makes tactics procedural procedural metalanguage use assert object CIT This process compilation previous tactics program tactics The second tactics programs written tv express prove tactics tactics possible tactics possibly mean formulas MT specify compose primitive paper word failing applications literature tactic different meaning 143 I 32441 feature makes ML 1341 We level possible possibly proofs This ways Tactics interpreted theorems given input OT proved interpreter theorem Tactics compiled HGKM code executed prove combination define process called lifting intuitively seen reverse flattening allows code implementing OT generate MT language axioms process metatheory tactics representing code As result derived like rest shorten subsequent proofs theory called fattening Finally possible second features makes lifted code prove theorems compiled possibly rules executed Logical manipulation Fig 1 figure presented efficiency nized object code writing metheoretic allows bridge advantages From computational theory allows compose level corresponds cycle iterated represented 4 This approach provides considerable point view metatheory mecha output theorem proving From intellectual point view gap inside real inning It possible inside unified environment define implement level This reasoning schematically transformation practice program interpreted interesting starting 200 F Ciunchilia P TraversoArtiftcial Intelligence 80 1996 197241 __________________________________________________________________________ GETFOL METATHEORY Metalevel Theorem Proving Safe System Extension I_________________________________________________________________________ GETFOL SYSTEM CODE Fig I The liftingreasoningflattening cycle computation systems deduction possibly extend modify correct way selfreflective implements systems able deduction This step reason deductively provably strategies reasoning underlying 3 The project structures structures attempt simulation mechanizable deduction code mechanized FOL described simulation 541 It described This project builds extends Richard Weyhrauchs work FOL analogue push idea point view GETFOL developed 271 GETFOL minor vari described allow particular work Meta reflection principles Weyhrauchs terminology notion model linking computation From implementational reimplementation ations functionalities metatheoretic Weyhrauchs work seen analyzing anization The code mechanizes OT construction The code CYT developed finite MT represents terpreted constants structures implements OT In fact described HGKM data implementing UT Thus instance A A B rl r2 A AB denote A A B theorem proving From conceptual point view close connection relation UT mech Fig 2 MT metatheory UT construction MT denote objects OT recorded Sections 6 91 amounts model MT achieves partial presentation computation FOL plus extensions MT shown facts First following requirement E Giunchiglia J TraverseArtificial Intelligence 80 1996 197241 201 MT Metatheory OT Code Model MT Code Mechanization OT Fig 2 OT MT code r r2 A A B recorded data structures A AND B GAMMA1 GAMMA2 A AND B respectively Second respond words HGKM functions finite presentations application HGKM evaluator fandeltac function predicate symbols MT cor In corresponding computed extension fundm settheoretic meaning MT Thus instance symbols compute interpretations HGKM function interpreted symbols object theory lifting However idea having metatheory mechanized new tactics point code flattening MT synthesizing version tactic interpreter ideas performing Indeed FOL preliminary 541 23 FOL developed directly metatheory Most examples literature ad hoc dedicated coding Finally unlike Weyhrauchs metatheories 55 proved machinery We flattening assert nontheorems discussion interpretation required minor 2654 structure lifting tactics executed correct implementation correctness MT use simulation fact shown hypothesis MT OT underlying mechanization Section 96 interpretation instance perform described processes tactic Starting complete reimplementation FOL described influencing strongly 271 CYI production code MT These computation project developed parallel subprojects The goal subproject mechanization implements OT time constitutes model MT The goal second project development projects influenced sense mapping deductimon vice versa consequence kind tactics written executed definition lifting flattening depends precise form axioms MT HGKM functions functions mechanizing OT The problem face times impossible map MT code vice versa This required multiple major recodings MT The GETFOL megabyte code redefinitions finite presentation 202 F Giunchiglia P TraverwArtijicial Intelligence 80 1996 197241 conjunction test theoremhood eiziently It committment prove theoremhood object level theorems synthesize The constraint MT usable effectively difficult question answer time happened interesting MT code modified The constraint code assert theorem supposed develop GETFOL compute toy implementation example tactics reason defining metatheory MT structure wffs Currently succeeded desired properties formulated code mechanizing OT We recoded GETFOL followed writing according process lead situation axioms MT contains tactics slowly converging large parts code GETFOL facts needed like look alike prove execute general schema This general schema necessary 4 Contents paper structured This material mechanization metatheory The goal paper MT sense GETFOL discussed follows goals described mechanized object theory extent achieves needed The details implementation In Section 5 OT understand MT The paper mechanization connection code mechanizing OT In Section 7 MT express prove tactics In Section 8 tactics given procedural code interpreting GETFOL In Section 9 technical correctness approach The tactics considered Section 10 discuss reasoning work aimed giving MT desired expressibility In Section 11 discuss guarantee paper simple In Section 6 MT theorems related work compiling interpretation capabilities results 5 OT mechanization set axioms set inference The object theory OT triple OT A_xR language order classical natural deduction A V I shown abbreviation rules contains rules monadic deciders results easily generalized ND calculus We consider L dx R rules OT respectively OT rules Fig 3 A B C formed formulas 1A OT GETFOL allows richer set inference rules connectives tautology checkers rewriter semantic simplifier Definitions rules equality derived inference A 3 I The implementation For reasons efficiency implementation dependencies theory GETFOL keeps GETFOL rules rules sequents introduction sequent Fig 4 describes sets formulas rules Fig 3 sequent notation rules interchange structural Notice locally formulas This allows elimination elegance proof post r A finite contraction E Giunchiglia F TraversdArtijicial Intelligence 80 1996 197241 203 AE A4 AAB A A AAB B 3 E A AB B VExt y f If 1 Vl 3 A B AAB Al B AB A VxA A 3 J1 L A 1 VI restriction occur assumption A depends Fig 3 OT inference rules presented ND form Al rdA AdB rAAAB I rA B rAB VI x rA r VxA AE 1 rAAB TA A rAAB TB 3 E rA AAB rAB VExt r VxA rA JC TA_L I rA VI restriction occur r Fig 4 OT inference rules presented sequent form sequent mean pair r A written needed sets weakening Technically formula sequent r sequems form A A We suppose I discharges A Fig 4 This easily generalized We notion deduction defined set dependencies cut derived 46 When inference rules r A A sequent Assumptions assumption talking OT deduction formula A depending possibly set r formulae tree sequent r A We r A theorem OT proof r A exists proof OT r A We provable write br 1 A mean r A provable OT OT 204 E Giunchiglia P TraversdArtificial intelligence 80 1996 197241 fails listenactrespond GETFOLs level implements rule produces error message proof built far proved 201 Here mention relevant loop It keeps internal theorems reason state proved The proof inspected manipulated user appropriate correctness preserving operations When action requested user inference rule application GETFOL applies current proof The details mechanization adds proved theorem following paper A somewhat detailed incomplete GETFOL given issues A issue description rest IO statistics separate possibly administration rules changing different appropriate consider code implementing consider As second example reasoning proofs wffs implemented pairs lists irrelevant More interestingly synthesizing wff Finally GETFOL lot state proved account code mechanizing issue facilities A second applications level abstraction Thus instance implementing Sections 6 7 clear means theorems taken logic MT subset natural deduction vice versa possible tactics require explicit axiomatization inside MT particular lifting MT inference possible decision procedures considering functionalities code details instance inessential rules Consider according idealized general sense implementation For goals paper sufficient reason generated However GETFOL implementation rules GETFOL including schema described inference AE reported Figs 5 6 7 All inference deciders developed Figs 5 6 7 This schema level lot low implementational failures faithful recording link MT HGKM code function names function calls parameter passing access state Let start consider fact code completely read access state The code kind called computation machinery AEl implemented primitive input takes theorem takes theorem failure failure fandel rules primitive types objects terminology output Thus fandel returns theorem f andeltac tactics uniformly produce returns theorem corresponding terminology tactic Inference Fig 5 All returns functional sense f andel code code fandeltac fact tat typed fail Fig 6 reports code modifying state tacfproof Code kind called update machinery update state keeps theorems failures generated far updates tactic update failures tacf proof processed current program addtat update tacfproofupdate updates current proof updates current proof function prints error message standard output function user defined standard fproofaddfact fproof updates function f proof stack theorems update fproof updates printerrormessage output E Giunchiglia P TraversoArtifcial Intelligence 80 1996 197241 205 DEFLAM f andeltac tat NOT FAIL tat IF f andel fail tat DEFLAM f andel fact CONJ fact IF f andel fail fact DEFLAM f andel fact f actmak lfaud f actgetdeplist f actgetwff fact fact Fig 5 Computation machinery left conjunction elimination DEFLAM tacfproof update tat SEQ tacfproof fproof addtat tat tat 1 update DEFLAM fproofupdate tat IF FAIL tat printerrormessage f proof addf act tat tat Fig 6 Update machinery proof state IO state The code implementing computation code implementing machinery prompt user interface FANDEL called update machinery called Fig 7 Code kind called level GETFOL following command typed GETFOL FANDEL factname GETFOL printed The user wants apply AEl activates FACT parses fact standard calls fandel called program theorem program data structure faudeltac tactic recording level parsed FANDEL understands routine FANDELK implementing input aborts possible FANDEL FACT returns failure Dually FANDEL interpreter TAC extracts current object failure objects processed tactic executed aborts possible 206 E Giunchi P TraverwArtijicial Intelligence 80 I 996 197241 DEFLAM FANDEL 0 tacfproof update fandeltac TAC DEFLAM FANDEL 0 fproofupdate fandel FACT Fig 7 Top level user controlled machinery left conjunction elimination 6 MT mechanization MT OT distinct theories Their implementation GETFOL exploits 171 MT triple MT ML Mdx MR rules set axioms set inference If LY formula MT In following MT theorem MT facilities MR GETFOLs multitheory ML Mdx language MT respectively MT order classical ND calculus br LY means section ML Mdx MR consider axiomatization complete definition ML Mdx Y provable inference given Appendix A In order paper shorter rules OT A VZ A 61 The language ML ML constant constants new individual variable x x string representing In MT possible Let start individual quotation mark individual formula VxA refer certain object quotation mark names objects OT 24 object double quotes Thus constant c c sequent VxA terms variables objects In paper use names sequents constants OT called generically objects OT We adding OT These constants written surrounding instance individual r A individual OT write s t x c respectively constant fail denotes fail constants MT corresponds mechanizing OT For inference symbol appropriate In ML Fig 5 code tactic OT quotation mark object CYT However analogously rule corresponding MT failure recorded data structure data structure manipulated r A parameters primitive function fail AEi fandelfandeltac arity 1 bfl fallifallitac arity 3 happens HGKM functions Analogously correspond predicate equality unary predicate Set holds sequents unary predicate T theoremhood unary predicate Fail holds fail predicate Tat holds fail theorems OT inference f andeltac rules fandel fandeltac Fig 5 ML fandel E Giunchiglia P TraverseArtificial Intelligence 80 1996 197241 207 lE Conj arity 1 VI Pur arity 1 VI K2r arity 1 VI NoFree arity 2 As al1 preconditions reified HGKM code Conj corresponds function CONJ Fail corresponds sentential constants T HGKM boolean FAIL Fig 5 Finally ML axiom I truth falsity contains respectively MC individual variables parameters written x XI x2 respectively The context makes clear talking aala term variables parameters OT MT Finally MC contains We write constructors boldface A t t2 A wff readability formulas tt t2 terms conditional increase Within GETFOL correspondence HGKM data structures functions analogue mechanizable functional predicative constants MT constructed 17541 As described allows commands ATTACH MATTACH 541 hinted structure machinery structure machinery particular user define use individual simulation Section 3 described simulation finite presemation model theory consideration ATTACH MATTACH function implement particular interpretation g 131 MATTACH takes pointer data structure m recording constant m MT pointer data structure o recording object o OT stores pair m o state The idea pair m o records fact gm o Thus m individual constant fact 0 quotation mark o symbol fm o Analgously pair f m f o f o HGKM function symbol records fact extensional fm Following Weyhrauchs settheoretic f o interpretation terminology pair m o attachment m attached pair simply attachment pair o o records m applicational abstractly defined abstractly defined characterization predicative model functional o 62 The axioms MAX The axioms MT devised lifted mechanization OT mechanization However work correctly sequents based implicit assumptions sequent equal fail theorems Vx Tsecx A Failx Vx Tx Secx 1 2 implemented FAIL argument definition Fail computes HGKM boolean function returns TRUE fail FALSE We lift following 208 E Giunchiglia P TraversnArtcial Intelligence 80 I 996 197241 Vx Failx x fail 3 roughly speaking partial Fig 5 f andel computation machinery sequents wff conjunction Consider called f andeltac implemented LISP CAR Thus return wrong value AVB left disjunct A abort time argument defined fandeltac f andel HGKM atom For inputs f andel This fact captured following axioms sequents wff conjunction correctness implementation HGKM CAR behaves returns returns In order guarantee In practice f andel applied function fandel fail fail Vx 7 fandel x fail Vx1Vx2Vx3 7 fallixl x2 x3 fail 4 5 All computation machinery pointed Section 5 functional following axioms basically lifted MT mapping This generates vx TaCXl fandeltacx ailxl A Conjx fan x1 fail vxvx2vx3 72Xx 3 fallitac XI x2 x3 ailxl A Varx2 AParx3 ANoFreex3x fafli XI x2 x3 fail 6 7 Notice defined fandeltac hand corresponding unfolded f andel functions think possible applications Notice fandeltac hypothesis 7x terms function lifting f andel symbol fandel MT Indeed definiendum An explicit definition fundel useless goals composed hard current goals returned TAC This generates fandel objects applied produce objects kind uniformly returns tat takes fact axioms fandel It update updates Consider tacfproof update machinery given state GETFOL stores theorems failures generated far Dually extracts objects TAC definition This state GETFOL state updated tacfproof set approximates set theorems OT union failure objects represented TAC Tat This form Section 91 This causes act addf lifting general For instance FACT lifted global variable stores current proof theorems proved far This global sense MT Tat update subset applies fproof lifting tacfproof T In fact fproof nonrecursive adds argument relevant contains addfact update 6 7 Fig 6 E Giunchiglia P TraverwArtijicial Intelligence 80 1996 19724I 209 presentation nonrecursive operations set theorems UI given set lifted mean f proof variable approximates T Section 91 The intuition state approximates representing set However finite finite presentation Tat In fact attached T Tat Section 61 The fact instance FACT aborts object It simply theorem mean proved Within possibilities Either printerrormessage failure called This generates f proof MT represented read update symbol act FACT TAC interpretation interpretation theorem update T tacfproofupdate following axiom tacfproof object addf act called update fproof addf vx Tczcx H Tx V Failx 8 level machinery Fig 7 Once understood lift update lifting level machinery mapping Thus FANDEL lifted following FANDEL lifted way lifted Consider machinery FANDEL FALL1 axioms reasons f andel defined analogously s dx kx TacfandeZtac x Vxvx2bx Tacxl TaccfafZitacxx23 9 10 Finally base case deductions Let A B wffs OT TA A T A A E Ax 11 12 following OT discussed performed basic inference The axioms deduction tactics However MT axioms describing Section 7 allow express synthesize rules In syntax OT syntactic manipulation lift principle generate axioms statements axioms This allow use prove universal formula OT However syntax OT means concerns main goal MT syntax OT able discriminate arguments Section 93 sufficient ground version axioms consequences Let x variable OT A B wffs OT r finite individual set formulas CYT c individual constant OT 5 object OT Then particular tactic applied methodology formed axioms MT reason In perspective fails succeeds following tactics parameter fandei r A A B r A falli r A 31 bGx_ cay ssr vxA occur r 13 14 210 I Giunchiglia F TraversnArtijicial Intelligence 80 1996 197241 Par TPar c c fail 5 5 individual parameter YT Var Varc c fail 5 5 individual variable OT 1 Cl c2 ci c distinct individual constants Conj r A A B Conj I A A conjunction NoFree r A appear r TNoFree I A appears r c r A ec c 5 sequent OT 15 16 17 18 19 20 21 22 23 24 25 ground consequences exploit value denoted structure machinery Conjfandel A A model MT This command SIMPLIFY SIMPLIFY takes input term wff 1 1 25 represent infinite set ground axioms This problem MT axioms asserted For concerns actual mechanization axioms 13 25 B A C idea use simulation fact code implementing OT finite presentation achieved step computes Section 61 In case term denoted value set attachments SIMPLIFY asserts element domain term In case wff denoted value quotation mark input FALSE TRUE case SIMPLIFY asserts 11 12 asserted SIMPLIFY second T reason seen Section 61 T attached attached order logic However lose termination SIMPLIFY want avoid They fact theorem s OT particular asserted exploiting case axiom assumption br T s This explained Section 93 theorem prover complete MT equality MT input wff defined model HGKM function negation Axioms constructed A Notice object level sequent A fandef A A II We set complex MT quotation mark denoted terms proved equal quotation mark terms provably equal quotation mark object CYT structural descriptive names object In particular object level theorem given structural descriptive proof proving 4A fact A obtained applying A A A B Another structural descriptive conjunction A B fandi builds A II expresses For instance fandelfandi fandel A I Giunchia F TraverdArtificial Intelligence 80 1996 197241 211 names possible object sequents Notice marks SIMPLIFY structural descriptive corresponding efficiently names taking To conclude writing quotation mark names quotation option GETFOL hardwired naming machinery Using MATTACH OT desired quotation mark structural descriptive names provably equal GETFOL table lookup case quotation mark case structural descriptive names MT represent code OT lift useful subset inference allows use code storage axioms extract selectively small reasons In particular simple time length quotation mark Finally notice GETFOL This feature rules implemented important possible naming amounting notice linear Let consider examples use simulation examples paper r shorthand shorthand assumption VxAx ABx VxAx s shorthand VxAx 3 Bx dVxAx structure machinery In Vx A x A Bx s ABx A shorthand 1 Bx VxAx Bx Example 61 Let consider following term fullijhdeffulle s x x u 26 From axiorns 13 14 axiom aboutfulle Appendix A prove fullifzndeZfalle Is x x u r VxA x 27 theorem proving MT The command SIMPLIFY executed 26 runs routine called simplify returns model result achieved SIMPLIFY The defined input expression term wff interpretation simplif yCfalliundelCfulle r Vx Ax A Bx x x GL simplifyCfandellle y x simplif y simplifyfalli simplif SimplifyCfalli simplifyx simplif yfulli SimplifyCfalle simplifyndel simplifyu simplif simplifyr yCfandel simplifyCfaUe simplif y x simplif VxAx y u simplif A BX y x simplify yfalli rVxAx simplif yfundel A Bx x simplifyx simplifyu simplifyfundel r Aa A BU y u r Au y x simplif fandel x simplifyu r dAu x TAu A BU simplifyx simplifyu simplif falle simplifylli simplif simplifylli simplify simplifyEli falli lVxAx 212 E Giunchigliu t TruverwArticial Intelligence 80 I 996 197241 SIMPLIFY computes case f dxAx MT case 27 quotation mark expression computed simplify asserts equality input term theorem Example 62 The functions occurring applied arguments functions defined To account failure SIMPLIFY executed terms containing primitive 26 partial As consequence SIMPLIFY tactics simplif simplif simplif fail yCfalfitucfundeltucfalletuc yCfullitucjundeltuc ycfallituccfuil x s x 2 x u A A Bu x u Therefore SIMPLIFY asserts following theorem MT fullitucfandeltucjXetac s x 2 x u fail Example 63 In MT prove following wff Xonjfalle s x u 28 We execute SIMPLIFY Conjvalle s x simplif y ConjCfaUe s x u simplifyConjAAu FALSE Ba Since simplify case 28 returns FALSE SIMPLIFY asserts negation input wff 63 The rules MR elimination The set rules MT MR consists rules OT described Fig set rules equality Fig 8 Rule states P A tl t2 A TA derive P tl A deduction fact A theory 3 language ML plus sound complete rules introduction E E P rz Rule Pt2 discharged conservative I states given deduction P tl A prove Pif A tl t2 A denotes set wffs conclusion depends The resulting extension MT I terms reported conditional 7 Expressing proving tactics Program tactics programs generate proofs They gramming Moreover complex program control construct conditionals tactics constructed loops calls defined program tacticals involve pro tactics I Giunchiglia P TraverdArtifcial Intelligence 80 1996 197241 213 Al TAI A Bif A tl t2 E Btl Btl Bk Bif A tl t2 I TA Bif A tl t2 E l Bt2 Fig 8 Conditional inference rules 143243 stance express finite composition proof steps We In paper focus limited class program tactics 1 exist wffs MT isomorphic correspondence 2 tactics program wffs proved building proofs proof step corresponds computation step program tactic We wffs tactics 71 Expressing tactics Program tactics build trees object level inference trees rules applicable rule program applicable defined follows rule applications program tactic fails Sequent called sequent tactic succeeds trees formally Definition 71 Sequent follows tree s A sequent tree sequent s defined inductively 1 Base For sequent s s sequent 2 Step We case inference tree s rule Let 171 Z7 sequent trees SI s respectively Let p nary inference rule Then n1 SI 17 sn sequent applicable I tree S s conclusion application p p We use leaf end sequent sequent tree usual meaning 71 p applicable add 1 The particular irrelevant We represent inference rule applications In item 2 form following uniform Definition sequent way 214 E Giunchiglia P TruversoArtijiciul Intelligence 80 1996 197241 We I7 sequent sr 171 We associate terms defined tree s built applying inference OT sequent tree I7 I71 tactic term r rule end sequent T Tactic inductively structure sequent trees Definition 72 Tactic defined inductively structure ZI term I7 The tactic term rn sequent tree I7 s I Base S fail r57 C s assumption axiom 2 Step b AE T fundeltuc T Vlxu T fullituc T x u following proof tree Ii axioms VE Example 73 Let consider Appendix A VE AEl VI l VxAx l Au A Bx A Ba I Au l VxAx r jiilfitucCfundeftucjMetuc s x u following sequent tree I7 notice X7 Example 74 Let consider proof tree VE A5 VI AVxAx AAu Bx Bu I vx I T fallitucCfandeltucCfulletuc s x x Tactic interested tactics terms contain constants denote leaves corresponding arguments instantiated tactic terms generalization time We tree failure Program sequent execution constants replaced variables represent proof structures leaves sequent termsrasrctcwherect term Each c cl fail quotation mark possible parameter rule application By rrx 77rCl tactic obtained follows We write tactic constant like variables MT c c variables xl x respectively We define notion fullituc s x u Let xl x mean c quotation mark sequent c individual constants appearing term obtained replacing x individual constants cl trees Technically independently E Ciunchiglia P TraversoArticial Intelligence 80 1996 X97241 215 Definition 75 Tactic Let cl c constants Let cl quotation mark names sequents fail Then tactic wff form cn m n constants term cn rct c tactic cl Vx vx Tacx AATaCx 3 TaCTXl x 29 Axioms 9 10 tactics In Section 6 explained precise correspondence primitive respondence function instance exists symbol following T xi x corresponds example general complex program tactics AEI MI The cor Indeed tactics tactic Consider primitive tactics Example 76 bxlx2q Tac XI TucCfalfitucCfandeltuctXetuc XI x2 XX x2 x3 30 30 corresponds f alletac f andeltac program fallitac tactic composes primitive tactics 72 Proving tactics Tactics correspond primitive tactics axioms MT From axioms prove tactics correspond compositions primitive tactics Example 77 Consider tactic 30 From following axiom MT Appendix A YIXVXVX Tucxl Tucfulletucxlx2x3 axiom 9 prove VxVxVx3 Tuc xl TucCfandeltucCfalletuc x1 x2 x3 31 32 32 Then wff 3 1 corresponds fullituc axiom 10 prove f alletac 30 Notice proof starts It introduces fundeltuc finally The proof Example 77 suggests possible general way prove tactics step corresponding computation tactics Intuitively proof Example 77 corresponds build proof step corresponds program object constructed type Tut theorem failure This similar tacticbased primitive theorems contain primitive theorem provers program tactics For instance composition tactics construct falletac fandeltac checking fallitac theorems applying assert happens tactics Nevertheless MT prove statements executed Vx Kzcx A Conj x II TucCfandelx 33 216 F Giunchiglia I TraversoArtifcial Intelligence 80 1996 197241 fatzdel corresponds safely proper conditions f andel theorem MT Intuitively conjunction argument 33 states fandel construct theorem Similarly following theorems MT Vx Tx A Conjx TCfandelx VxlVx2Vx3 TxI A Vurx2 A Parx3 ANoFreex3nl 2 Tvhllixl x2x3 VxlVx2Vx3 Txi A Varx2 A Termx3 A ralxl A Conjzlle xi x2 x3 A Vurx2 spar NoFreexfandelfallex1xx3 TCfallifandelfaZlexx2323 34 35 36 341 derived tactics 35 analogous way 34 fandeltac fallitac factoring conditions applicability 9 10 level rule applies VlE AEl VZ The proof 34 35 easily performed unfolding 36 proved rules rules AE V71 36 describes given order Notice applicability VE second line The rules composed applied failures nonmechanized rule In 36 preconditions VI fourth describes happens rule code dealing In sense closer usual paper metalevel descriptions term falliandelCfaZZe xl 2 x3 x2 x3 fifth line applied They account 35 36 explicitly corresponding preconditions pronditions 35 36 A object line derived derived rules line 34 Finally tactics theorems MT correspond program perform program 30 corresponds logical manipulation corresponds tactics For instance prove wff logically equivalent tests tactic avoids redundant code ansfoation program tactics optimizing Example 78 We prove MT VXVXVX Tacxl faIlitucJandeltacaIletuc XI x2 x3 x2 x3 Fail XI A Varx2 A Termx3 A Forall A Caej x2 x3 A Parx3 A NoFexsfundelCfallexl x2 x3 thenfallifandelullexl fail x2 x3 x2 x3 The proof performed rewriting according axioms assumption Tac XI We assume 6 faflitacandeLtacZietacx 7 axiom falletac Appendix A wff condition x2 x3 x2 x3 wff 37 negation tactic 37 E Giunchiglia R TraversoArtifcial Intelligence 80 1996 197241 217 This allows eliminate obtain conditional terms applying E E We fallitacfandeltacalletacx x7 x3 x2 x3 failiCfandelaZlexlxx32x3 depending conditions wff 37 Zhc x1 fallitacifandeltacalletac XI x2 x3 x2 x3 fail depending apply I discharging program corresponds program corresponds negation conditions assumptions tactic calls FAIL wff 37 I discharging Tac xt While twice Tac xt We 30 37 times Var tactic calls routines Example 78 simple The underlying intuition MT possibly extensions tactics Isabellelike optimize code significant ways discussion Section 10 8 Executing tactics Tactics given procedural content assert object level theorems program compiling flattening This interpreting tactics 81 Interpreting tactics Consider generic tactic Yx fx Tacxl A ATacx 3Tacxlxl By tactic asserts object level theorem fails This process performed steps interpretation mean process tactic fed interpreter following Step 1 Perform sequence forall eliminations obtain Tacci A A Tacc TcIcrct c cl operation set arguments cnl c constants naming objects OT This dual tactic procedural metalanguage program typing Step 2 If ci cl proved OT deduce c fail sequent theorem MT stop This dual operation testing swme arguments program theorems failure tactic right type 218 F Giunchiglia P TruversoArtificial Intelligence 80 1996 197241 Step 3 Run simplify implementing returns fail program object stop This tactic instantiated term TCI level sequent dual operation executing c I If returns data structure MT If body s deduce Ts arguments Step 4 From T s assert s theorem OT This dual operation asserting result execution program tactic Example 81 Let consider ing forall eliminations respectively We obtain following formula tactic perform In Step 1 instantiate replacing XI x2 x3 s x 30 7iic s TacfhllitacCfhndeltcuec s x x u In Step 2 exploit fact tor s TacallitucCfandeltacfalletac s x x 38 term The runs simplify r vxA x Then Example term sequent fullitucCfandeltucalletac s x x tactic tree 38 73 Step 3 returns Tr vxAx Step 4 asserts r vxAx theorem OT Example 82 Let consider execution Step 1 instantiate term Example 74 We perform Step 2 Example 81 obtain fails We tactic tactic obtain ground wff contains TacfallitacjiindeltacCfalletac s x x Step 3 runs simplify fail returns fallitacCfandeltacalletac s x x Example 62 Then process stops Step 4 performed statements Another possibility 35 36 Their interpret metalevel rules wffs 34 tactics The step Step 1 In second step wffs form T s s theorem OT factored ground wff The step applies simplify T If atomic ground wffs main predicate symbol returns TRUE term argument T Otherwise simplify process stops The step Step 4 interpretation interpretation applied similar derived Example 83 Consider wff 36 After steps Var x A Term u A Forall s AConjCfalle s x nVur x A Par A NoFree xfandelfulle s x u Tallijundeljalle s x u Ix 39 40 41 F Giunchiglia R TraverwArtijicial Intelligence 80 1996 197241 219 step applies simplify applied The turns TRUE simplify It returns r VxAx OT If xi gets ConjjCfalle s xl Example 63 Therefore instantiated s simplify Example 61 conjuncts For conjunct s x u A 39 fullizdelCfaZZe asserted theorem returns FALSE applied process stops 82 Flattening tactics By flattening mean process takes certain theorems MT generates implementing tactic composed parts computation machinery Section 5 code update machinery Flattening generate computation tactics program HGKM code As seen program primitive level machinery level machinery The update machinery In MT possible parts code generated split tactic wffs corresponding inference rules Vx Vx newtucxl x Tx xn vx dx Tacx A ATacx 3ticnewtucxlx x symbol newtac We obtain 40 definition new function 29 40 We generate corresponding rx1 tactic newtac 40 We flatten attachments flattening 40 41 consists simple syntactical following level machinery symbols newtac We flatten MT applicative 41 rewriting code new program 41 The flattening process exploits attachments HGKM functions Given translation Consider computation machinery example Example ft4 From tactic 30 prove Vxi VxzVxs distuc xl x2 x3 fullitacandeltuczfalletucxl x2 x3 x2 x3 VXlVx2VX3 7izcx Tacdistacxl X2 X3 42 43 distac corresponds universal quantifier conjunctions program tactic 42 gets flattened implements distributivity DEFLAM distac fallitac 1 2 3 fandeltac falletac xl x2 x3 x2 x3 translated function definition The universally arguments xl x2 x3 function Notice universal statement quantified variables xi x x3 definition The function distac tactic term obtain flattened distac attached distac obtain body definition distac 43 symbol distuc gets translated A simple syntactic translation HGKM symbol distac performed The level machinery DEFLAM 1s 0 220 E Giunchiglia I TraverseArtificial Intelligence 80 1996 197241 tacfproofupdate distac TAC TERM TERM level function DIS arbitrary Flattening builds functional update tactic The given composition program according argument gets extracted TAC TERM routine specific routine case distac hypotheses implication tacfproof type update The arguments distac constructed 43 Since Tacxt extraction terms We flatten logical manipulations tactics generate optimized code Consider following example Example 85 From 37 42 prove In Section 7 manipulated wff 30 obtained wff 37 vxvx2vx3 TaCXl 3 distuc x X2 x3 lFuil xl A Vur x2 A Purcq A ForuU XI A Conjfulle XI x2 x3 A NoFree 3fundelCfulle XI x2 x3 thenfuZZifundelfuZlex fail x2 x3 x2 x3 44 44 flatten computation machinery distac leave unchanged From level machinery The result DEFLAM distac xl x2 x3 AND NOT FAIL 1 VAR x2 PAR x3 FORALL xl CONJ falle xl x2 x3 NOFFlEE fandel falle falle xl x2 x3 xl x2 x3 x2 x3 f andel falli fail syntactic function predicate symbols according The flattening process performs translates conditional connectives A 7 AND NOT respectively Notice optimized version distac replace previous definition term conditional translations flattened attachments Example 84 translates tactic construct program Example 84 When flattened definition Once flattened program tactics executed tactic proper arguments program TAC body program gets affected update machinery Executing tactic gives result interpreting tactic MT standard way user type arguments type checked tactic gets executed state HGKM code obtained flattening E Giunchiglia P TraversdArtificial Intelligence 80 1996 19724I 221 program Finally notice tactics lifted inverse flattening For instance axioms MT process DIS Example 84 This code lifted wffs 42 43 Once MT lifted time involves computation machinery level machinery user handcode distac lifting flattening function definitions 9 Everything works technical results In section results guarantee correctness solutions Sections 6 7 8 The proofs theorems Appendix B The results Section 3 hard work OT framework technical completely proposed presented technically hard prove As described defining metatheory stating results proved They needed desired properties This section results discussed proposed goals paper mechanization relation mainly 91 MT consistent We define interpretation M Dg ML D domain interpre 2 includes special elements E F E handle partialness We use F tation g interpretation set called D objects OT The domain contains intuitively denotes interpret function The domain interpretation constant fail MT value undefined failure Definition 91 The interpretation M ML 51 set terms wffs sequents OT E F distinct element D g defined follows pair Vg 2 D U E U F 1 g s s s sequent OT 2 g Xv w w wff CYI 3 g t t t term OI 4 gil F 5 g Set 6 g identity 7 gPar 8 g Vur set individual variables OT 9 g Corzj set sequents OT formula set sequents OT relation D set individual parameters OT IO g NoFree individual r appear conjunction relation V2 dl d2 E gNoFree parameter OT d2 sequent r A OT dl iff dl I I gT TOT 70 set theorems OT 12 gfundel D ZJ d E V function ifdisrAAB 222 F Giunchiglia P TraversoArtcial Intelligence 80 1996 197241 13 gfalli function V3 V dl d2 d3 E V gfalli dt dg r bxA E dl f A appear r d2 d3 x 14 gfundeltac function V V d E V gCfand4 d gCfandeltac d F E d E TOT d E g Conj d E TOT U F d g Conj 15 gfullitac function V3 V dl d2 d3 E V gWidldds dl E TOT d2 E g Var d3 E gPar dndl E gNoFree gfallitac dl d2 d3 F E dl E TOT U F d2 g Vur ds gPar gNoFree dsdt Wffs terms interpreted according usual standard tarskian semantics The semantics conditional value tt A true value t2 terms follows The value A tl t2 Theorem 92 M model MT Theorem 92 proves consistency MT Moreover M model MT If hT Ts br S 45 sequent s OT We MT correct respect UT OT given sense OT f andel It clear code CYI developed jinite presentation model MT Compare Definition 91 M Section 5 The HGKM functions scription mechanization fi perform deduction nite presentations application lation structure machinery model M The commands ATTACH MATTACH implement analogue important In particular Tut T left uninterpreted gCfandel gCfandeltac g Conj We use simu analogous interpretation mechanizable It code CYT presentation partial model MT discussion relations assigned g defined g simplify notice tests truth wffs M CONJ implemented corresponding implements mechanizable Section 6 implement f andeltac symbols k F Giunchixlia I TraverwArtijicial Intelligence 80 1996 I97241 223 characteristic In Definition 91 introduced E interpret function f andel HGKM partial functions As noticed partial fulli correspond general running f andeltac corresponding implemented code implementing wffs terms Partialness test decide possible symbols f alli fundel Partialness large code GETFOL Definition 91 points 14 15 functions defined theorems failures case tacticals tactics destructors constructors logical syntactical categories allows achieve efficiency code GETFOL 251 defined program set TOT U F Do This f allitac inputs Extending domain E handle partial known standard 12421 One essential difference special elements E F From theoretical point view unique model metatheory E F collapsed OT finite presentation functions Isee instance mechanization technique distinct constructed element The problem model The distinction E F important MT model M code implementing Fig 2 E denoted symbol data structure paper MT implemented fail data structure failures witness observable fail language MT implemented model defined fact programs partial On contrary F denoted fail GETFOL code We GETFOL code It capture order define correspondence deduction OT shown 92 Tlze use SIMPLIFY correct In Section 6 use SIMPLIFY assert axioms 1325 use simulation ground structure machinery attached SIMPLIFY applied consequences We ground terms wffs sound First notice partial functions For instance MT MT symbols SIMPLIFY fandel A V B return wrong value SIMPLIFY Conj x x variable OT abort subset S terms MT called guarantee set set simplubfe terms simpliable wffs Roughly t M atomic ground wffs sorted In following write mean element D denoted term t MT terms subset S wffs MT called soundness apply SIMPLIFY sets contain Section 6 In order discussion ground speaking Definition 3 SimpliJuble terms 1 Let 17 constant MT Then c E S 2 If t 15 tM E gConj fundelt E S 3 If t19t2t3 E St fullitt2tg t3llMtlllM E S E gNoFme t211M E gVar 4 If t E S If tltztj 5 t M E TOT U F fundeltuc t E S Es tlM ETmUF thenfullituctlt2t3 ES 224 F Giunchigliu P TraversoArrificial Intelligence 80 1996 197241 Definition 94 Simplable wffs 1 If ti t2 E S tl t E SW 2 If t E S Sett E S 3 4 5 6 7 If t E S tM E gSec U F Failt E S If t E S tM E gSec If t E A Part E SW If t E S Var t E S If tl t2 E S tl E gPar t2 E gSec Conjt E S Nofreetltz E S Notice correct type denotes T Tat attached t E S Tt 6 S Tac t 6 SW case t theorems theorems failures respectively This The soundness operation performed SIMPLIFY obvious general subset set true formulas The following set provable theorem guarantees formulas case Theorem 95 Correctness kW wtMTlW simplify Let w E SW Then kM w j IMT w Notice limited purely set ground axioms theoretical point view minor modifications ground axioms Theorem 95 stated ground atomic wffs simplifiable wffs For instance contain T Tat extend include rjx kr Conj A But extension spirit metatheory fact mechanized data code structure evaluated simulation actual relation provability model object partial fact CONJ run successfully recording variable Definitions 93 94 capture exactly structure machinery Theorem 95 captures analogue account MT truth mechanizable FM Conjx expressions sense theory 93 MT correct complete respect provability OT We prove tactic terms right behaviour Theorem 96 MT correct complete wrt OT r tactic term Il Then Let I7 sequent tree s Let I 7 S 2 hr 7 fail II n proof s proof b b CT hT kT TT Part 1 Theorem 96 states tactic term corresponds proved equal sequent OT denote theorem OT 2b Notice iff proved equal proof lb Part 2 states tactic successful proof iff la denotes theorem tree iff tactic fails term corresponds sequent failure 2a fact program F Ciunchigiia I Trverrtciai fteiee 80 1996 197241 225 prove sequent imply sequent provable Analogously 2b Theorem 96 states tactic term denote theorem Tt7 state stronger fact s theorem JY This result different fact 17s provable MT iff s provable OT Theorem 96 makes statement single sequent tree Z7 provability 3 involve considering sequent trees s However 1 Theorem 96 notions collapse Tv Indeed corollary Theorem 96 s possible prove Ts provable MT We reflection provable OT Ts reflection 22231 Rdown hT Tts bT s hYrs 3 Rup EMT T s 46 correct inference rules theories multitheory MTOT axioms II 12 need explicitly priori stated They fact proved asserted needed application RUp 94 All tactics theorems MT We prove tactics theorems MT Theorem 97 Any tactic provable MI The fact tactics provable MT exactly expected In fact tactic corresponds program tactic defined code To tactic derived metatheo equivalent saying strategy implementing finite composition inference steps written HGKM In Section 7 proved theorems 34 35 36 They represent taking account failure derived object level inference rules We theorems kind proved general First need technical definitions The sequent tree term t preconditions P sequent tree 17 defined inductively structure sequent trees In base case sequent tree single sequent s If sequent proof axiom assumption sequent tree term s pronditions Ts If proof axiom assumption sequent tree term fail preconditions Tfai1 In step case t Pn sequent tree term preconditions nt L7 built ZIt applying AEI VI x end sequent ZIt fant P A Vurx A Paru A oreeu t sequent tree term preconditions ZI respectively For instance sequent tree built applying VE x axiom s AEl Vf x applied sequent tree given order corresponding sequent tree term yhlli tn x P A Conjt fa6liandellle s P x u 226 F Giunchigliu I TruverdArtiJciul Intelligence 80 1996 I97241 coesponding preconditions T s A Vur x A Term A Forall s Conjfdfe s x rVar 2 A Pat u A oFree x fele s x u tree wff c individual sequent c cl For OT TfCl quent We write 7nxtx placing XIX tree term preconditions Let xl x1 tnt constants et c ci c tct respectively We constants form Pcl c appearing 3 se xn individual variables MT wff term obtained c variables Theorem 98 Any w form vix Jx PTriIXll 3Ttlxixl 47 provable MT 95 Tactic execution correct Under hypothesis underlying implementation correct tactic interpreta c TcI Section 81 simplifiable Theorems 95 96 We compute tion described correct sequence steps provably correct Step 1 trivially correct The correctness Step 2 sequence Theorem 96 In fact ci isfail kr ci ci s tor s MT T s kkrr 7bc s The correctness Step y r cl c I 3 consequence ct c s simplifiable wff rct cn r true M 95 From Theorem 96 1 IMT TCl hr Ts wff rcr rem 95 From Theorem 96 2 r correspond 45 Therefore Theorem 96 guarantees wffs form 47 shown exactly simplifiable true M hr rct c fail Theo proof Step 4 correct The correctness interpretation way process stops correctly Finally property c s If simplifyract cl fail term If simplifyr interpretation c fuil Theorem simplif The correctness flattening argued reflecting OT assertion theorem terms function calls HGKM functions fproofupdate way main OT difference considered TAC Section 5 96 A remark The theoretical results presented needed correct hypothesis GETFOlL code supposed approach In fact E Giunchigiiu R TraversoArtificial Intelligence 80 1996 197241 227 SIMPLIFY correctly know MT lifted code consistent MT correct complete respect OT express prove tactics tactics executed correctly We guarantee derive theorems principle respect claimed In fact given results GETFOL code settheoretic code finite presentation implementation derive nontheorems model defined nonproofs incorrect Section 91 characterization proofs 11820 requires axiomatizing results To lift hypothesis underlying HGKM interpreter This reimplementing GETFOL Section 3 topic paper Briefly results start axiomatization work subproject Some preliminary forthcoming interpreter based work described shown similar described account GETFOL implementation modulo fact HGKM supposed HGKM property arise instance fact GETFOL state These results correctness modulo OT MT This property expressibility numeralwise HGKM implementation representability correctness HGKM interpreter 4956 Then representability notions numeralwise 391 Some complications hold account example 10 Current future work As hinted Section 3 implementation paper Within GETFOL mechanized OT MT procedures execute tactics tactics correspond work currently way overcome finite compositions current tactics However MT described limitations MT described synthesize far express limited class proof steps A lot A step extend MT expressive represent program tactics tacticals tacticbased 251 describes MT extended axiomatization follows orelse try progress repeat Consider interactive theorem provers 14324344 axiomatize interesting tacticals tactical repeat Its instance JxVt 7x ALTact 3 appiy repeat t x apply t x fail x apply repeM t apply t x 1 variables LTac unary predicate holding terms x t individual tactic called logic tactics Logic jhdeltuc tacticals repeat orefse jandeltac fallituc The function symbol apply express tactics litad terms constructed tactic application For instance primitive composing constant include tactics logic Vx c x upply jbzdeltuc x fandeltac x 228 F Giunclziliu P TraversoArrlcial Intelligence 80 1996 197241 tactical correspond finite composition repeat standard extended MT The recursive application tactical tactics proof steps This form general repeat powerful rules allow construction logic tactics preserve consistency At moment studying possibly provable write strategies based iteration necessarily recursion safely represented A problem hand introducing recursive general terminating synthesize Section 93 logic tactics preserve consistency We studying characterization results presented tacticals extending tactics containing recursive naturally conditions sufficient order Induction principles A second step provide MT induction principles synthesize prove 8371 Some preliminary correctness certain derived necessary rules instance extensions MT performed formulas containing proved extent induction principles ideas wffs proofs A step extend MT prove metarules inference 11 describes proof theorem stated lifted code 20 discusses stated 541 theorem investigate 31 A problem starting theorem proving equivalences experiments 441 similar preliminary work 52 describes case These rules characterized fact use wff constructors Thus statement formula A A B notation instance theorem possible A theorem propositional direction express described limited xl x2 range wffs Th unary predicate iff T A holds mkand wff constructor takes wffs builds conjunction Notice prove MT different A holds Vx Tx A Cunjx TCfandefx speaking proof constructor This x ranges sequents fandel intuitively represents extension allow extract given tactic explicitly new tactic proof step proofs steps corresponding tactic formula manipulation general faster execute An interesting open problem possible structure machinery explicitly adding axioms level This tactic corresponds extended version simulation program MT Finally started tactics effectively We started implemented MT similar kind reasoning investigate use MT synthesize functions develop set rewriting interesting similar 451 Our goal perform Cambridge LCF described performed proof planning IO E Giunchiglia P TraversoArtcial Intelligence 80 1996 197241 229 11 Related work simple research However use metalevel synthesize 163037 theorem proving 16374044 induction allow allow metatheories work described respects First 12291 promises metatheory previous limited fixed 25 Second particular described tactics As described new perspective Finally MT order unlike This provides advantages prevent performing 837 Third far topics Section 10 past investigated We actually hope techniques elaborated extent true interesting project trying code lead previous instance interesting Compared paper expressive control structures tacticals case instance instance currently largely apply MT extensions This investigation connection work work described discussions forms reasoning message paper theory metatheory correspondence code implementing object tactic interpretation None metatheories developed work FOL Section 3 features similar 321 NuPRL instance provers based logic programming logical reason metalanguage translate programming modify strategy strategy flattening past course MT This 29301 This consequences None systems LCF HOL NuPRL Isabelle provide straightforward way logical statements vice versa In area logic metainterpreters desired search metainterpreter executed Prolog builtin search underlying writing program metalevel orthogonal metatheory mechanized control That important describing lheory exploited user write metainterpreter main object Prolog search strategy 56163536 case 3 11 0BJ3 code Even 441 HOL frarneworks 143740 perform 2333 LCF Isabelle tactics issues lifting notion failure axiomatization past following needed facts extracted work described axiomatized structure machinery The fact MT metatheory mechanized object theory gives features features MT syntax code facts FAIL inference tactics notion tactic Some usual features predicates rules theories signatures somewhat unusual Thus instance explicitly simulation considered kept distinct rules primitive standard happens arguments multicontext machinery explicitly MT reason proofs instance form notion partialness MT makes distinction following 53 explicitly axiomatized fail instance happens 171 happens GETFOL solved syntax ground rules functions axiomatized instance notion 3531 inference inference 53 230 E Giunchigliu P TraversoArtcial Intelligence 80 1996 197241 lifting inference modulo 81 modulo In approach rules program code implementing code added MT derive new Boyer Moores work like axioms facts In perspective work similar metafunctions A difference allowing complex inference principles described beginning section extensions tacticals mainly considered compose simple tactics correctness derived tactics rules induction rules expressed composition simpler paper considering work described instead proving limitations emphasis inference spirit In 8 tactics Acl2 similar Our long This goal theorem prover development underlying term goal far achieved portion Boyer Moore develop CETFOL provably correct facilities code provably correct provides 9 development 71 reimplementation Acl2 logic Acl2 theorem prover One main difference logic language implementation language This possible Acl2 written applicatively On hand GETFOL lot state language far global theorems proofs constructed theory axioms decision procedures counters variables optimize This gives automatic generation different names skolem functions far advantages language logical computation machinery essentially fact functional discussions lifting 18201 Some hints Section 6 hide state specific case lifting implementing GETFOL proofs identical concerns Sections 5 6 Some preliminary like able showing update level machinery proof constructed relation implementation implementation complicates We share goal selfreflection lot work programming community ing introspection work 3lisp instance contributions 3857 47 The substantial difference instead computation approach performed deduction language area Finally minor remark difference lot related work MT distinct CYT Some motivations choice given relation commonalities employed noticeable exceptions 103655 advantages naming MT GGdel allow structural descriptive names One difference hardwired naming machinery names 22 In Gijdel 361 particular MT Roughly speaking GETFOL objects OT given arbitrary 12 Conclusion acknowledgements The work described build GETFOL selfreflective modify Department Edinburgh University paper long term project final goal reason extend author AI financial support author able introspect 1988 code This work started In Edinburgh E Giunchiglia R TraversdArtijicial Intelligence 80 1996 197241 231 simulation developed Mechanized Reasoning Groups Istituto Trentino di Cultura At moment DIST completely FOL rewriter Alessandro Armando IRST Luca Vigano second authors MRG IRST Communcation Computer System Sciences University structure reimplemented DIST Alessandro Cimatti DIST currently MaxPlanck providled SERC grant GRE44598 Currently research IRST funded ITC project DIST Department Genoa Paolo Pecchiari machinery IRST Michela Della Lucia Alessandro Zorer IRST worked project Institute Salarbruecken IRST goal design reimplementation work mechanized MT extended work people equally paper This work motivated described discussions Alan Bundy Richard strongly Weyhrauch David Basin Frank Van Harmelen John McCarthy Luciano Serafini Alex K Simpson Alan Smaill Carolyn Talcott Toby Walsh provided useful feedback paper We thank Toby Walsh carefully aspects work described proof reading paper Finally improve substantially feedback provided referees helped GETFOL Without feedback GETFOL Massimo Benerecetti quality presentation use tacticals collaboration important continuous infuenced allow Appendix A The metatheoxy MT MT triple MT ML Mdx MR ML Mdx MR language set axioms set inference rules MT respectively AI The language ML Individual constants The quotation mark names objects OT plus fail Function symbols AI fandifanditac arity 2 AEI fandelfandeltac arity 1 AE fander fandertac arity 1 3 I jimpijimpitac arity 2 E fimpeJimpetac arity 2 VI falli fallitac arity 3 VE fallefalletac arity 3 I falsefalsetac arity 2 232 F Giunchiglia I TraversdArtifcial Intelligence 80 I 996 197241 Predicate symbols Par Vat Term Set Wff arity 1 Conj Imp Forall False arity 1 T Fail Tat arity 1 NoFree Hp arity 2 arity 2 Sentential constants I T A2 The axioms MAX Basic axioms A Failx Vx lSecx Vx Tx Setx Vx Failx c1 x fail Inference rule axioms VXIVXZ fandixI x2 fail Vx 7 fandelx fail Vx 7 fander x fail Vx1 VXZ 1 jimpixl x2 fail Vxl Vx2 1 mpe x1 x2 fail Vxl Vx2Vx3 1 falli x1 x2 x3 fail VxjVx2Vx3 7 fallexl x3 fail Vx VXZ 1 false xl x2 fail x2 Computation machinery axioms Vx1Vx2 Tacxl A Tacx2 fanditacxlxz Failxl A TFailx2 fandi x1 x2 fail Vx Tatx fandeltac x lFail x A Conj x fandel x fat Vx Tatx fandertacx yFailx A Conjx fanderx fail Vx1Vx2 Tacx mpitac xl x2 lFail x2 A W XI mpi xl x2 fail E Giunchiglia TraverdArtifcial Intelligence 80 1996 197241 233 dxYx2 TaCXl Jiwetac A 7qQ XI x2 dzil XI A iuil x2 A Zmp x2 A Hp x1 x2 jmpe XI x2 fail vxvx2vx3 Tacx1 3 fullituc x 1 x2 x3 dGilx A Vurx2 APurx3 fulli x I x2 x3 fail ANoFreex3x vxIVxvx3 xzCXl II fulletuc xl x2 x3 lfil xl A Vur x2 A Termx3 A Fiindl x1 fulle xl x2 x3 fail VXIVX Tacx 3 fuketucxx2 4ilxl A Wflx2 AFalse fulse x I x2 fail Update machinery axioms Vx 7x t Tx V Failx Top level machinery axioms Tucxl A Tucx2 3 TucCnditucxx2 Vxlbxa Vx Ttrc x 2 TucCfundeltuc x TucCfundertuc x Vx kx VxlVx VxlVx VXIVQVX VXIQXVX TIC VxlVx2 TUCXI TucfulsetucxIxq Tucmpitucxl x2 Tucx2 Tucxl A Tucx2 3 Tucfimpetucxlx2 Tucxl Tuccfallitucx1x2x3 TucCfafletucxlxzx3 Let x t w individual parameter term wff OT Let A B C wffs OT Let r A finite sets formulas OT Let c cl c2 constants OT Let 5 object CT individual variable Ground axioms T TA A T A AEdx 234 E Giunchidiu p TraverwArtificial Intelligence 80 1996 197241 Ground axioms inference rules fandi P A A _ B P A A A B fandelP A A B r w A fanderP A A B r _ B jimpi A P B P A _ A B fimpeT A A A B rA falli P A x P VxAz falle P VxA fimpi r I A r A I A x Y r A B occur r Ground axioms syntax Par lPar c Var 2 Varc Term t TTermc Wsf W c fail f 5 individual parameter OT c fail r 6 individual variable OT c fail 5 5 term OT c fail 5 wff OT constants ct c2 distinct individual 4A P A Wsfc 3 7 Cl c2 Conj r A A B Xonj Imp P A 3 B npr HpP A A A B lHp r 4 A A C NoFreea P A TNoFree P A ForallT VxA TForallT A False P _L alser A Sec r A 6ec 5 A I 6 sequent OT A conjunction A implication C form A B appear r appears r A universally quantified Appendix B Proofs BI Proof Theorem 92 We gSec defines gfallidld2 wff Q ML tl g Fail 0 Axiom 2 b11 implies kM Y Axiom true gT C gSec Axiom true 3 4 5 true gfande1 d F 6 Let XI 1 f d dl d2ds E 23 Consider axiom 6 F predicate Fail Axioms I Giunchiglia P TravemoArtcial Intelligence 80 1996 197241 235 d E g Tut If d E g Conj conditional true The d E g Tut gfandeltuc d E g Tut The proof predicate Tut Axiom F Then axiom 6 term interpreted 8 defines 9 analogous Axiom 7 x assigned assigned gCfundel d If d g Conj interpreted proof axiom true axiom 10 analogous Axioms belong gT Axioms appear r gfulli r 4A trivially 1 l 13 true 14 true gzndelr4AB 12 true OT axioms assumptions Z4A 15 25 x r VxAz Axioms B2 Proof Theorem 95 We prove following lemma Lemma B1 Let t E S Let c E S u constant MT Zf kM t c MT t c Proof By induction structure t Base Obvious Step We case form simplifiable c c t tl t2 tg E St term Definition 93 Let 1 fundel t t denotes sequent form r AA B t E S Then k t r 4AA B From induction hypotheses tMr t r 4AA B A fundel t c implies r 4 A fundel r 4A A B axiom r A c denotes 13 2 faUi tl t2 t3 We tt denotes sequent form r A t2 denotes Individual variable x t3 denotes individual parameter appear free r From induction hypotheses ktr t I r 4 A falli kr 4 A x b7 t2 x br r VxAz t3 c denotes r 4VxA axiom 14 3 fundeltuc t The proof similar fundel t If t denotes proof use axioms 6 20 use axioms 6 21 If t denotes If t denotes conjunction conjunction sequent sequent F ihen use axioms 6 3 4 falrituc I t2 tg The proof similar proof fulli tl t2 tg Cl Now prove following theorem Theorem B2 Let w E S Then kM w 3 bT W Proof We case form simplifiable wff Definition 94 I ti t2 By induction t2 The base case Lemma Bl The step cases analogous step cases proof Lemma Bl 2 Seet t denotes sequent S From Lemma Bl tMr t s Sec 3 axiom 24 3 Failt t denotes F From Lemma Bl br t fail From definition 3 Mr Failcfail 236 F Giunchiglia t TraversoArtcial Intelligence 80 1996 197241 4 Conj t t denotes sequent s formula conjunction From Lemma B 1 ttrr t s Conjs axiom t denotes individual parameter From Lemma B1 br 20 5 Part t Par axiom 15 6 Var t t denotes individual variable x From Lemma Bl hr t x Var 2 axiom 7 Nofree tl t2 t2 denotes sequent 17 r A tl denotes individual param eter appear br tl Nofreea r A r From Lemma Bl hr axiom 22 0 t2 r A We prove following lemma Lemma B3 Let t E S Let c E S constant MT If p t c MT 1 t c Proof We case form simplifiable cl 2 cl c2 distinct simplifiable fadet FM 19 The proof cases similar sequent c implies terms form fandef s FM s c constants t From denotes fadet 0 93 term Definition 1 ct cp axiom If FM 19 Consider fact t E S MT fandel t s Theorem B2 1s c axiom br Finally prove following theorem Theorem B4 Let w E S Then pM w hT w Proof We case form simplifiable wff Definition 94 1 tt t2 By induction t2 The base case Lemma B3 The step cases analogous 2 Sec t Either step cases proof Lemma B3 t denotes object 5 OT sequent denotes F axiom t fail From axiom In case Theorem B2 hr 25 1 ltr Tsec t In case Theorem B2 hr t 5 Gece 3 Failt axiom t denotes sequent s From Theorem B2 ktrr t s From 1 lrr ail t 4 Canj t t denotes sequent s formula conjunction From Theorem B2 br t s Xonjs axiom 21 5 Part t denotes F object 5 OT parameter From Theorem B2 ktr t fail hr axiom 16 hr TParCfail br lPar individual t 5 From 6 Var t Proof analogous 7 Nofree tl t2 t2 denotes sequent proof Part eter appears hr tl TNofree TA axiom 23 q r A r From Theorem B2 br tl denotes individual param t2 r A R Giunchiglia P TraversdArtificial Intelligence 80 1996 197241 237 B3 Proof Theorem 96 In proofs II Theorem B5 proves parts la 1 b Theorem B6 proves 2a tree s built applying inference 2b tactic terms 171 rule sequent 1 end sequent nl We TV r trees We l7 respectively The proofs induction structure sequent lb x 2a 2b trivial corollaries Theorems B5 B6 Theorem 92 proofs contradiction proof VI conceptually A la sequent identical Theorem B5 Let II sequent proof s hen kMT rT kMT T s tree s Let r tactic term Il If II Proof Base If 17 s axiom assumption Then r s Ts r Step axiom ik fallitac T x From induction hypotheses MT 7 1 11 axiom 12 MT Tsl From hT Tsl hT Tacsl From axiom 7 hT faktac 7 x ail sl A Var 2 A Par A NoFree sl falli si x fail B1 From axiom 7 1 ground axioms hT r fak sl x hT 10 obtain kMT TaccfalZitacs x s From axiom tS From axiom 1 hT Ts 0 Theorem B6 Let 17 sequent tree s Let r tactic term IZ If I7 proof kMT r fail kMT T 7 Proof Base If L7 s axiom assumption Then 7 fail x We cases Step r 1 171 proof From Theorem B5 hT T 1 hT T I From axiom 7 Bl fallitacr implies hT Tac s From axiom 23 1 kMT r fail kMT 7T 7 axioms 1 2 2 171 proof From induction hypotheses hT 7 fail Therefore bT Tac T From axiom 7 hT 7v ailcfai A Var x A Par A NoFree afail falliail x fail Since hT Failcfail prove r fail hT 7T 7 0 238 F Giunchiglia t TraversoArtcial Intelligence 80 1996 197241 B4 Proof Theorem 97 Proof induction structure QX x Base In base case tactic Tutx Vx Tutx term s fail The corresponding tactic Step We consider case VI case A similar Induction hypotheses hT vxl Vx Tucxl A ATucx Tcxx prove hT vxl I v2 Tucx AATucx TacCfaflituc7XIXnlnxn2 B2 Let al a2 individual parameters MT From axiom 10 prove MT Tucal a11 TucCficlla12 B3 From induction hypotheses B3 prove Tuc A A Tada Tuccfallitucul uuIu B4 We apply tl B4 prove B2 B5 Proof Theorem 98 pV t defined inductively structure sequent trees In base case Tx Consider step case t 47 We write 47 following form Vx Tx Vx Vx TxI AATx APx I x Ttxl xlBS whereGxt B5 derive Tucxl A ATucxFrom We easily derive x contain occurrences T We assume hypotheses 29 weobtain TucxIx vx vx 7Xl I ail x1 A Addx tpxIx fail From assumption derive dil XI A x1 txl x1 V txI x1 Tuctxl x fail definition A dM x A P XI x There x 8 From axioms 5 easily prove x1 x fuiland thereforeTtxtx fore obtain rxt equivalent Ttxl 4 APGxx B6 F Giunchiglia P TraversoArtificial Intelligence 80 1996 197241 239 References 1 I I A Armando Architetture riflessive la deduzione automatica PhD Thesis DIST University Genoa Genoa 1993 121 A Avron E Honsell I Mason Using typed machine LFCS Report Series ECSLFCS8972 Computer Science Department University Edinburgh Edinburgh Laboratory 1989 lambda calculus implement formal systems Foundations Computer Science 13 1 D Basin R Constable Metalogical frameworks Proceedings Second Workshop Logical Frame uorks Edinburgh 14 I D Basin E Giunchiglia 199 1 P Traverse Automating metatheory 1991 2nd Conference Italian Association AIIA 4857 IRSTTechnical Report 910104 15 I KA Elowen RA Kowalski Amalgamating Artificial intelligence creation extension Springer Berlin 199 1 IRST Trento language metalanguage logic programming S Tarlund ed Logic Programming 16 I KA 13owen T Weiberhg A metalevel Academic Press New York 1982 153173 extension prolog IEEE Symposium Logic Progumming Boston MA 1985 669675 7 I RS Boyer JS Moore A Compufarional 18 1 RS Bayer JS Moore Metafunctions proof Iprocedures Academic Press New York 1981 103184 Logic proving RS Boyer JS Moore eds The Correctness Problem correct Academic Press New York 1979 efficiently new Compurer Science 19 I RS Boyer JS Moore A theorem prover computational logic Proceedings 10th Conference Auumafed Deduction Lecture Notes Computer Science 449 Springer Berlin 1990 I 101 A Bundy The use explicit plans Proceedings 9th Conference Automated Deduction available DA1 Research Paper No 349 Department Artificial IIS R Luck R Overbeek guide inductive proofs eds Springer Berlin 1988 11 I120 Longer version Intelligence Edinburgh selective application multiple rewrite rules Intell 16 198 I 1892 12 DA1 Research Paper 12 1 Department inference 1 I 1 A Bundy B Welham Using metalevel algebraic manipulation Arti Arlficial Intelligence Edinburgh I 12 I R Cartwright AIM324 J McCarthy Recursive programs functions 1979 CS Department Report STANCS79 17 order theory SAIL MEMO I 13 1 CC Chang JM Keisler Model Theory I 14 I RL Constable SF Allen HM Bromley et al Implementing Marhemafics NorthHolland Amsterdam 1973 NuPRL Proof Deveopmenr System PrenticeHall Englewood Cliffs NJ 1986 15 I S Feferman Transfinite recursive progressions axiomatic theories J Symbolic Logic 27 1962 259316 I 16 1 A Felty Implementing tactics tacticals higherorder logic programming language J Autom Retrsouing 11 1993 4381 I 17 I E Giunchiglia Geneva Genoa 1994 I I8 I F Giunchiglia Trento I 191 E Giunchiglia 1989 I20 I F Giunchiglia The GETFOL Manual 1992 CETFOL version 1 Tech Rept 920010 DIST University A Armando A conceptual architecture introspective systems Tech Rept IRST A Cimatti HGKM Manual revised version Tech Rept 890622 IRST Trento A Cimatti Introspective metatheoretic reasoning Proceedings META94 Workshop Mefaprogramming Logic Pisa 1994 Tech Rept 921 I21 IRST Trento L Serafini Multilanguage Intell 65 1994 2970 12 I I E Giunchiglia logics ArfiJ I22 I E Giimchiglia semantics Computer Science 649 Springer Berlin 1992 235249 A Smaill Reflection 23 I F Gilmchiglia constructive hierarchical Proceedings META92 Workshop Mefaprogramming L Serafini A Simpson Hierarchical metalogics intuitions theory Logic Uppsala Lecture Notes proof Tech Rept 910105 nonconstructive automated IRST Trento reasoning logics modal H Abramson MH Rogers eds Proceedings META88 Workshop Metaprogrumming IRST Trento DA1 MIT Press Cambridge MA 1988 123145 Tech Rept 890204 Logic Research Paper 375 University Edinburgh Edinburgh 240 F Ciunchiglia I TraverseArtificial Intelligence 80 1996 197241 I24 1 E Giunchiglia metatheories 1990 306322 P Traverse Plan formation execution uniform architecture M Bruynooghe ed Proceedings META90 Workshop Metaprogramming declarative Logic Tech Rept 900312 IRST Trento 25 I F Giunchiglia P Traverse Program tactics logic tactics Proceedings 5th International Conference Lqqic Programming Rept 930101 Mathematics Fort Lauderdale FL 1994 Automated Reasoning IRST Trento presented Third International Symposium Artificial LPAR94 Kiev 1994 Tech Intelligence I26 1 E Giunchiglia monotonicity Amsterdam I27 E Giunchiglia RW Weyhrauch A multicontext monotonic D Nardi P Maes eds MetaLevel Architectures axiomatization inessential non Reflection NorthHolland 1988 271285 Tech Rept 910502 DIST University Genova Genova RW Weyhrauch FOL User Manual FOL version 2 Manual 910908 IRST Trento 128 1 K Code Uber formal unentscheidbare I99 1 Tech Rept 9 I0006 DIST University Genova Genova Siitze der Principia Mathematics English Moncrtsh Matz Phys 38 1931 17398 translation 1291 J Goguen Higherorder functions considered unnecessary und verwandter Systeme I 151 I higherorder DA AddisonWesley Reading MA 1990 309 programming Turner ed Research Epics 351 Functional Programming I30 1 J Goguen A Stevens H Hilbrdink K Hobley 20BJ metalogical framework theorem prover based equational logic Phil Trans R Sot Land 339 1992 6986 I 3 1 1 MJ Gordon A proof generating higherorder logic G Birtwistle PA Subrahmanyam eds VLSl Speccation Synthesis Kluwer Dordrecht I32 1 MJ Gordon AJ Milner CP Wadsworth Edinburgh LCF A Mechanized Logic Computation 1987 Lecture Notes Computer Science 78 Springer Berlin 1979 I33 I R Harper E Home1 G Plotkin A framework defining logic Symposium Logic Computer Science I341 R Harper D McQueen 197 I 194204 Laboratory Edinburgh Edinburgh Foundations 1986 Robin Milner Standard ML LFCS report series ECSLFCS862 Computer Science Department Computer Science University 135 1 PM Hill JW Lloyd Analysis metaprograms J Lloyd ed Proceedings META88 Workshop Metaprogrumming Logic MIT Press Cambridge MA 1989 I361 PM Hill JW Lloyd The Giidel programming language Tech Rept CSTR 9227 Department Computer Science University Bristol Bristol 1992 37 I DJ Howe Computational metatheory I38 1 S Jagannathan G Agha A reflective model inheritance Nuprl R Lusk R Overbeek eds CADE9 1988 The Sixth European Conference Springer Berlin Computer Science Programming 1992 Lecture Notes ObjectOriented appear I 39 1 SC Kleene 1401 TB Knoblock Introduction Metamathematics NorthHolland Amsterdam 1952 RL Constable Formalized metatheory type theory Tech Rept TR 86742 Department Computer Science Cornell University Ithaca NY 1986 I41 I SA Kripke Outline theory truth University Press Oxford 1984 5382 Recent Essays Truth Liar Paradox Oxford Theory cti Computation McGrawHill New York 1974 Cambridge LCF Tech Rept 39 Computer Laboratory University I 42 1 Z Manna Mathematical I43 I L Paulson Tactics tacticals Cambridge Cambridge 1979 I44 I L Paulson The foundation generic 145 I LC Paulson A higherorder I46 I D Prawitz Natural Deduction I47 I BC Smith Reflection semantics I48 I MJ Stefik Planning metaplanning 1491 C Talcott The essence RUM theorem prover J Autom Reasoning 5 1989 363396 implementation rewriting Sci Comput Program 3 1983 119149 A Proof Theoretical Study Almquist Wiksell Stockholm 1965 LISP Proceedings llth ACM POPL 1983 2335 Art Intell 16 1981 141169 aspects LISPtype computation PhD Thesis Department Computer Science Stanford University Stanford CA 1985 report STANCS851060 extensional theory intensional 150 1 A Tarski Logic Semantics Mefumathematics Oxford University Press Oxford 1956 F Giunchiglia I TraversoArtijicial Intelligence 80 1996 197241 241 15 I 1 J Van Heijenoort From Frege Giidel A Source Book Mathematical Logic 18793931 Harvard University Press Cambridge MA 1967 152 1 L Vi8anb Sintesi ed esecuzione di strategie di prova nella metateoria formale di dimostratore interatrivo Thesis University Genoa Genoa 1994 153 1 J von Wright Representing higherorder logic proofs HOL Tech Rept jan1894 Abo Akademi University Turku 1994 154 I RW Weyhrauch Prolegomena 133I 76 theory mechanized formal reasoning Arti Intell 13 1980 155 1 RW Weyhrauch An example FOL metatheory Formalizing reasoning introducing derived inference rules Proceedings 6th Conference Automatic Deduction New York 1982 I56 I RW Weyhrauch C Talcott HGKM simple 157 1 A Yonezawa A reflective object oriented concurrent implementation FOL working paper 4 1985 language Lecrure Notes Computer Science 441 Springer Berlin 199 I 254256