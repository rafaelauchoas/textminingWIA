Artiﬁcial Intelligence 172 2008 204233 wwwelseviercomlocateartint A logical approach efﬁcient MaxSAT solving Javier Larrosa Federico Heras Simon Givry b Universitat Politecnica Catalunya Barcelona Spain b INRA Toulouse France Received 2 August 2006 received revised form 11 May 2007 accepted 15 May 2007 Available online 29 May 2007 Abstract Weighted MaxSAT optimization version SAT important problems naturally encoded Solving weighted MaxSAT important problem theoretical practical point view In recent years considerable ﬁnding efﬁcient solving techniques Most work focuses computation good quality lower bounds branch bound DPLLlike algorithm Most lower bounds described procedural way Because difﬁcult realize logic In paper introduce original framework MaxSAT stresses parallelism classical SAT Then extend basic SAT solving techniques search inference We algorithmic tricks stateoftheart MaxSAT solvers easily expressible logical terms uniﬁed manner framework We introduce original search algorithm performs restricted weighted resolution visited node We empirically compare algorithm variety solving alternatives benchmarks Our experiments constitute best knowledge comprehensive MaxSAT evaluation reported demonstrate practical usability approach 2007 Elsevier BV All rights reserved Keywords MaxSAT Search Inference 1 Introduction Weighted MaxSAT optimization version SAT problem important problems naturally expressed They include academic problems MaxCut MaxClique real problems domains like routing 3 bioinformatics 4 scheduling 5 probabilistic reasoning 6 electronic markets 7 In recent years considerable effort ﬁnding efﬁcient exact algorithms These works divided theoretical 810 empirical 1115 A common drawback algorithms spite close relationship SAT MaxSAT easily described logic terminology For instance This paper includes extends preliminary work J Larrosa F Heras Resolution MaxSAT relation local consistency weighted CSPs Proc 19th IJCAI Edinburgh UK 2005 pp 193198 J Larrosa F Heras New inference rules efﬁcient MaxSAT solving Proc AAAI06 Boston MA 2006 Corresponding author Email addresses larrosalsiupcedu J Larrosa fheraslsiupcedu F Heras degivrytoulouseinrafr S Givry 00043702 matter 2007 Elsevier BV All rights reserved doi101016jartint200705006 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 205 contributions 1114 good quality lower bounds incorporated depthﬁrst branch bound procedure These lower bounds deﬁned procedural way difﬁcult logic execution procedure This contrast SAT algorithms solving process easily decomposed atomic logical steps In paper introduce original framework weighted MaxSAT notions upper lower bound incorporated problem deﬁnition Under framework classical SAT particular case MaxSAT main SAT solving techniques naturally extended In particular extend basic simpliﬁcation rules example idempotency absorption unit clause reduction introduce new hardening sense SAT context We extend fundamental SAT algorithms DPLL based search DP based inference We complexity extension DP exponential formulas induced width hardly surprise case inference algorithms graphical models 1617 Interestingly resolution rule includes special cases techniques spread recent MaxSAT literature One merit framework allows techniques inference rules transform problem equivalent simpler customary SAT context The second contribution paper practical We introduce original search algorithm incorporates different forms resolution visited node neighborhood resolution chain resolution cycle resolution Our experimental results variety domains indicate algorithm generally efﬁcient competitors This especially true ratio number clauses number variables increases Note typically hardest instances MaxSAT Our experiments include random weighted unweighted MaxSAT MaxOne MaxCut MaxClique combinatorial auctions The structure paper follows In Section 2 review SAT terminology In Section 3 present Max SAT introduce framework In Section 4 extend essential solving techniques SAT MaxSAT Section 5 summarizes uniﬁed way specialized forms resolution simplify MaxSAT formula Section 6 describes solver Section 7 reports experimental work corroborate efﬁciency solver compared stateoftheart solving alternatives Section 8 discusses related work Finally Section 9 concludes points directions future work 2 Preliminaries SAT In sequel X x1 x2 xn set Boolean variables A literal variable xi negation xi The variable literal l refers noted varl varxi var xi xi If variable xi assigned true literal xi satisﬁed literal xi falsiﬁed Similarly variable xi instantiated false literal xi satisﬁed literal xi falsiﬁed An assignment complete gives values variables X partial A clause C l1 l2 lk disjunction literals 1cid2ij cid2k icid5j varli cid5 varlj It customary think clause set literals allows use usual set operations If x C resp x C x appears clause positive resp negative sign The size clause noted C number literals varC set variables appear C varC varl l C An assignment satisﬁes clause satisﬁes literals Consequently clause noted cid2 satisﬁed Conversely clause contains negation clause noted cid2 satisﬁed discarded Sometimes convenient think clause C equivalent C cid2 A logical formula F conjunctive normal form CNF conjunction different clauses normally expressed set A satisfying complete assignment called model formula Given CNF formula SAT problem consists determining model The formula noted trivially satisﬁable A formula containing clause trivially unsatisﬁable contains explicit contradiction 21 Graph concepts 18 The structure CNF formula F described interaction graph GF containing vertex associated Boolean variable There edge pair vertices correspond variables appearing clause Given graph G ordering vertices d parents node xi set vertices connected xi precede xi ordering The width xi d number parents The width graph d denoted wd maximum width vertices 206 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Fig 1 On left graph G On right induced graph G d d lexicographic order The induced graph GF d denoted G d F obtained follows The vertices G processed ﬁrst d When processing vertex xi connect pair unconnected parents The induced width G d denoted w d width induced graph The induced width known treewidth ktree number dimension graph measure far graph acyclicity fundamental structural parameter characterization combinatorial algorithms Computing ordering d provides minimum induced width NPhard problem 19 Example 1 Consider formula F x1 x4 x1 x4 x2 x3 x2 x4 x2 x5 x4 x5 Its interaction graph GF depicted Fig 1a The induced graph G d lexicographical order depicted Fig 1b Dotted edge x1 x2 new edge respect original graph When processing node x5 new edges added parents x2 x4 x5 connected When processing node x4 edge connecting x2 x1 added variables parents x4 connected When processing x3 x2 x1 new edges added The induced width w d 2 nodes x5 x4 width 2 parents induced graph 22 SAT algorithms CNF formulas simpliﬁed equivalences reductions Well known equivalences idempotency C C C absorption C C B C unit clause reduction l l C l C A known reduc tion pure literal rule says variable occurs positive negative form clauses mentioning discarded formula Simpliﬁcations reduction cascade effect applied quiescence The assignment true resp false variable x F noted Fx resp F x produces new formula clauses containing x resp x eliminated formula x resp x removed clauses appears Note Fl seen addition l formula repeated application unit clause reduction followed pure literal rule Algorithms SAT roughly divided search inference The popular search algorithm starting point stateoftheart SAT solvers proposed 20 usually called Davis Putnam Logemann Loveland DPLL Fig 2 provides recursive description First DPLL simpliﬁes input line 1 If resulting formula reports success line 2 If resulting formula contradiction reports failure line 3 Else selects literal l line 4 sequentially assigns formula l l line 5 We clauses x A x B F clash A B tautology absorbed F More formally deﬁne Clash function cid2 Clashx A x B lA true false l B CF C cid5 A B The resolution rule x A x B x A x B A B applied clashing clauses central inference algorithms Variable x called clashing variable A B called resolvent Resolution sound complete adds formula makes explicit implicit relation A B Note unit clause reduction particular case resolution Two years DPLL Davis Putnam proved restricted resolution performed ordering variables sufﬁcient deciding satisﬁability The corresponding algorithm noted DP 1821 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 207 function DPLLF return Boolean 1 F SimplifyF F return true 2 F cid2 return false 3 l SelectLiteralF 4 5 return DPLLF l DPLLF l endfunction Fig 2 DPLL search algorithm It returns true iff F satisﬁable xi A PopClauseB xi BB st Clashxi A xi B endwhile F F A B function VarElimF xi return CNF formula 1 B C F xi varC 2 F F B 3 xi A B 4 5 6 7 8 endwhile 9 return F endfunction function DPF return Boolean 10 F SimplifyF 11 F return true 12 F cid2 return false 13 xi SelectVarF 14 return DPVarElimF xi endfunction Fig 3 DP pure inference algorithm It returns true iff F satisﬁable Fig 3 provides recursive description It eliminates variables onebyone obtains formula achieves contradiction The heart DP Function VarElim It eliminates variable xi formula F preserving solvability First computes socalled bucket xi noted B contains set clauses mentioning variable line 1 All clauses bucket removed formula line 2 Next applies resolution restricted clauses bucket pairs clashing clauses exist Resolvents added formula line 6 The correctness DP based fact clauses added line 6 essential information contained clauses removed line 2 Observe pure literal rule special case variable elimination pair clashing clauses exist inner loop iterates The following lemma shows complexity eliminating variable depends number variables interacts Lemma 2 See 18 Let F CNF formula xi variables Let ni number variables sharing clause xi F The space time complexity VarElimF xi O3ni O9ni respectively The following lemma shows induced graph G d F captures evolution interaction graph GF variables eliminated Lemma 3 See 18 Let d denote reverse order DPF eliminates variables The width xi d induced graph GF d bounds number variables sharing clause xi time elimination Thus induced width captures expensive variable elimination The following theorem follows previous lemmas characterizes complexity DP terms induced width 208 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Theorem 4 See 18 Let d denote reverse order DPF eliminates variables Let w induced width GF d The space time complexity DPF On 3w d On 9w d denote d respectively A consequence previous theorem order DP eliminates variables crucial algorithms complexity As example consider formula interaction graph tree depth 1 If variables eliminated topdown order cost exponential n If variables eliminated bottomup order cost linear In general ﬁnding optimal elimination orderings NPhard problem approximate algorithms In practical applications DP generally space consuming 18 Nevertheless resolution plays important practical role combination search addition restricted forms resolution search node anticipates detection deadends improves performance 18 2224 As use resolution relevant MaxSAT context 3 Weighted MaxSAT When Boolean formula model interested ﬁnding complete assignment minimum number falsiﬁed clauses This problem known unweighted MaxSAT Note repetition clauses allowed clauses equally important The complexity MaxSAT P NPlog n meaning solved logarithmic number calls SAT oracle 25 Weighted MaxSAT extension MaxSAT A weighted clause pair C w C classical clause w natural number indicating cost falsiﬁcation A weighted formula conjunctive normal form set weighted clauses The cost assignment sum weights clauses falsiﬁes Given weighted formula weighted MaxSAT problem ﬁnding complete assignment minimal cost We assume clauses formula different C u C w replaced C u w Note clauses cost 0 effect discarded Weighted MaxSAT expressive unweighted MaxSAT complexity P NP higher 25 require linear number calls SAT oracle Since MaxSAT applications require expressiveness weights paper focus weighted MaxSAT In following MaxSAT referring weighted MaxSAT Example 5 Given graph G V E vertex covering set U V edge vi vj vi U vj U The size vertex covering U The minimum vertex covering problem wellknown NP hard problem It consists ﬁnding covering minimal size It naturally formulated weighted MaxSAT We associate variable xi graph vertex Value true respectively false indicates vertex xi belongs U respectively V U There binary weighted clause xi xj u edge vi vj E u number larger equal V It speciﬁes vertices covering edge connecting There unary clause xi 1 variable xi order specify preferred add vertices U Note different weights unary binary clauses required express relative importance type clauses Consider minimum vertex covering graph Fig 1a The MaxSAT encoding F x1 1 x2 1 x3 1 x4 1 x5 1 x1 x4 5 x2 x3 5 x2 x4 5 x2 x5 5 x4 x5 5 The optimal assignment x2 x4 true x1 x3 x5 false cost 2 equal size minimum vertex covering Next propose alternative equivalent deﬁnition weighted MaxSAT convenient purposes Given weighted CNF formula assume existence known upper bound cid13 cost optimal solution cid13 strictly positive natural number This loss generality tight upper bound known cid13 set number higher sum weights clauses A model formula complete assignment cost cid13 An optimal model model minimal cost Then Max SAT reformulated problem ﬁnding optimal model Observe weight w cid2 cid13 indicates associated clause necessarily satisﬁed Thus replace w cid13 changing problem Thus loss generality assume costs interval 0cid13 deﬁne sum costs b mina b cid13 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 209 order result interval 0cid13 A clause cost cid13 called mandatory hard A clause cost cid13 called nonmandatory soft Deﬁnition 6 A MaxSAT instance pair F cid13 cid13 natural number F set weighted clauses weights interval 0cid13 The task ﬁnd optimal model The following example shows cid13 express interested assignments certain quality Example 7 Consider minimum vertex covering problem graph Fig 1a With new notation associated formula F cid3 cid4 x1 1 x2 1 x3 1 x4 1 x5 1 x1 x4 cid13 x2 x3 cid13 x2 x4 cid13 x2 x5 cid13 x4 x5 cid13 shows clearly clauses truly weighted ones mandatory In lack additional information cid13 set sum weights cid13 5 meaning assignment satisﬁes mandatory clauses taken consideration Suppose example local search algorithm ﬁnd covering size 3 We set cid13 3 assignment cost 3 higher anymore The resulting MaxSAT problem tighter easier partial assignments identiﬁed unfeasible The adding cid13 problem formulation twofold On hand makes explicit mandatory nature mandatory clauses Besides later allows discover mandatory clauses disguised weighted clauses On hand allows SAT particular case MaxSAT Remark 8 A MaxSAT instance cid13 1 essentially SAT instance weight cid13 Consequently clause formula mandatory A weighted CNF formula contain cid2 w clauses Since cid2 satisﬁed w necessary cost model Therefore w explicit lower bound cost optimal model When lower bound upper bound value cid2 cid13 F formula trivially unsatisﬁable situation explicit contradiction 4 Extending SAT solving techniques MaxSAT 41 Extending simpliﬁcation rules clause negation We MaxSAT formulas equivalent F F cid15 cost optimal assignment model The following equivalence rules simplify CNF weighted formulas Aggregation A w A u A w u Absorption A cid13 A B w A cid13 Unit clause reduction l cid13 l A w l cid13 A w Hardening If cid3 cid4 Ci ui cid5 k i1 ui cid13 1cid2ikCi Ck cid4 cid3 cid3 k1 Ck cid13 i1 cid4 Ck uk cid4 Ci ui k1 i1 cid3 Aggregation generalizes MaxSAT idempotency conjunction classical SAT The Absorption rule dicates MaxSAT context absorbing clause mandatory Similarly unit clause reduction requires unit clause mandatory The correctness equivalences direct omit proof The Hardening rule allows identify weighted clauses mandatory It holds violation Ck implies violation Ci k Therefore assignment violates Ck cost cid5 k i1 ui cid13 210 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 It easy deﬁnitions pure literal rule assignment formula Fl Section 22 directly applied MaxSAT As SAT Fl seen addition l cid13 formula allows sequence unit clause reductions followed application pure literal rule Example 9 Consider following formula x cid13 x 3 y 8 x y 3 cid13 10 We apply unit clause reduction ﬁrst second clauses produces x cid13 cid2 3 y 8 x y 3 We apply ﬁrst fourth clauses producing x cid13 cid2 3 y 8 y 3 The pure literal rule allows remove ﬁrst clause producing cid2 3 y 8 y 3 We harden second clause 3 8 cid13 Thus obtain cid2 3 y cid13 y 3 Unit clause reduction produces cid2 3 y cid13 cid2 3 Aggregation yields cid2 6 y cid13 pure literal rule produces formula cid2 6 trivially optimal model cost 6 Proposition 10 The algorithm applies previous simpliﬁcations quiescence terminates polynomial time Observe explicit contradiction achieved cid2 cid13 F clauses subsequently absorbed formula immediately collapses cid2 cid13 The negation weighted clause C w noted C w means satisfaction C cost w falsiﬁcation costfree Note C clausal form C 1 In classical SAT De Morgan rule recover CNF syntax following example shows applied weighted clauses Example 11 Consider weighted clause x y 1 cid13 1 The truth table negation x y 1 truth table x 1 y 1 given ignore column moment Note equivalent x y x y 1 f f f t t f t t 0 1 1 1 x 1 y 1 0 0 0 1 0 1 0 1 1 1 1 2 x y 1 x y 1 x y 1 0 0 0 0 0 1 0 1 1 0 0 1 0 0 1 1 The following recursive transformation rule allows compute clausal form totally partially negated clauses Let A B arbitrary disjunctions clauses CNFA l B u A l u A l B u CNFA l B u CNFA l B u case B 0 case B 0 The column truth table previous example shows proper CNF encoding clause x y 1 The main drawback rule generates exponential number new clauses respect arity negated clause We Section 43 possible transform linear number clauses Theorem 12 CNFA l B u returns equivalent CNF expression Proof It clear CNFA l B u generates CNF expression negation applied smaller subexpression recursive Eventually applied literals expression clause We prove CNFA l B u returns equivalent expression induction B The B 0 trivial lefthand righthand sides Regarding B 0 case ways falsify A l B Each elements righthand corresponds The assumed correct induction hypothesis cid2 Remark 13 The weighted expression A C C B u A B C disjunctions literals equiv alent A C B u falsiﬁed circumstances J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 211 function MaxDPLLF cid13 return N 1 F SimplifyF cid13 F return 0 2 F cid2 w return w 3 l SelectLiteralF 4 5 cid13 MaxDPLLF l cid13 6 cid13 MaxDPLLF l cid13 7 return cid13 endfunction Fig 4 If F cid13 models MaxDPLL returns optimal cost Else returns cid13 42 Extending DPLL In Fig 4 present MaxDPLL extension DPLL MaxSAT MaxDPLLF cid13 returns cost optimal model returns cid13 First input formula simpliﬁed rules previous subsection line 1 If resulting formula 0 cost model line 2 If resulting formula contains clause algorithm returns cost line 3 Else selects literal l line 4 makes recursive calls lines 5 6 In formula instantiated l l Observe ﬁrst recursive cid13 inherited parent second uses output ﬁrst This implements typical upper bound updating depthﬁrst branch bound Finally best value recursive calls returned line 7 Observe search goes value cid13 decrease Consequently clauses originally soft hard turn strengthen potential simpliﬁcation rules The parallelism DPLL Fig 2 obvious The following statement shows MaxDPLL true extension classical DPLL Remark 14 The execution MaxDPLL SAT instance F cid13 cid13 1 behaves like classical DPLL It easy time complexity MaxDPLL exponential number variables n space complexity polynomial F Therefore DPLL MaxDPLL complexity 43 Extending resolution rule Consider subtraction costs cid17 deﬁned 26 Let u w 0 cid13 weights u cid2 w cid2 u cid17 w u w u cid5 cid13 u cid13 cid13 Essentially cid17 behaves like usual subtraction cid13 absorbing element The resolution rule extended SAT MaxSAT cid4 cid3 x A u x B w A B m x A u cid17 m x B w cid17 m x A B m x A B m m minu w In rule MaxRES A B m called resolvent x A u cid17 m x B w cid17 m called posterior clashing clauses x A B m x A B m called compensa tion clauses The effect MaxRES classical resolution infer explicit connection A B However important difference classical resolution MaxRES While classical res olution yields addition new clause MaxRES transformation rule Namely requires replacement lefthand clauses righthand clauses The reason cost prior clashing clauses subtracted order compensate new inferred information Consequently MaxRES better understood movement knowledge 212 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Example 15 If apply MaxRES following clauses x y 3 x y z 4 cid13 4 obtain y y z 3 x y 3 cid17 3 x y z 4 cid17 3 x y y z 3 x y y z 3 The ﬁrst fourth clauses simpliﬁed Remark 13 The second clause omitted weight zero The ﬁfth clause omitted tautology Therefore obtain equivalent formula y z 3 x y z 1 x y z 3 The previous example shows certain conditions righthand clauses removed Clause x A u cid17 m symmetrically x B w cid17 m omitted B A m cid13 u m cid13 The ﬁrst case holds clause absorbed resolvent A cid13 The second case holds u cid17 m 0 Regarding clause x A B m symmetrically x A B m omitted B A u cid13 The ﬁrst case holds clause tautology The second case holds clause absorbed posterior clashing clause x A cid13 cid17 m cid13 Remark 16 The application MaxRES mandatory clauses equivalent classical resolution Proof Clashing clauses mandatory means u w cid13 Clearly m minu w cid13 u cid17 m cid13 w cid17 m cid13 Consequently righthand clauses mandatory Therefore prior posterior clashing clauses equal Furthermore compensation clauses absorbed clashing clauses previously noted Thus MaxRES effect adding A B cid13 formula equivalent classical resolution cid2 Theorem 17 MaxRES sound Proof The following table contains ﬁrst column truth assignments second column cost assignment according clauses lefthand MaxRES rule column cost assignment according clauses righthand MaxRES rule As observed costs resulting problem equivalent x A B Left f f f f f t f t f f t t t f f t f t t t f t t t u u 0 0 w 0 w 0 Right m u cid17 m m u cid17 m 0 0 m w cid17 m 0 m w cid17 m 0 Observe compensation clauses x A B m x A B m clausal form A 1 B 1 In following assume transformed clausal forms needed In Section 41 introduced recursive rule computes clausal form totally partially negated clauses We noted produces exponentially large number new clauses Interestingly insights MaxRES rule redeﬁne way linear number clauses generated cid2 CNFlinearA l B u A l A l B u CNFlinearA B u The new rule correct recursive calls CNF Section 41 CNFA l B u CNFA l B u resolved literal l obtain equivalent CNFA B u For example application B 0 B 0 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 213 xi A u PopMinSizeClauseB u 0 xi BwB st Clashxi A xi B m minu w u u cid17 m B B xi B w xi B w cid17 m B B xi A B m xi A B m F F A B m function MaxVarElimF cid13 xi return weighted CNF formula 1 B C u F xi varC 2 F F B 3 xi A u B 4 5 6 7 8 9 10 11 12 endwhile 13 return F endfunction function MaxDPF cid13 return N 14 F SimplifyF cid13 15 F return 0 16 F cid2 u return u 17 xi SelectVarF 18 return MaxDPVarElimF cid13 xi cid13 endfunction endwhile Fig 5 If F cid13 models MaxDP returns optimal cost Else returns cid13 CNFlinear x y 1 Example 11 produces equivalent x y 1 y 1 Observe output CNFlinear depends literals ordered clause cid2 44 Extending DP The following example shows unlike classical resolution unrestricted application MaxRES guarantee termination Example 18 Consider following formula x y 1 x z 1 cid13 3 If apply MaxRES obtain y z 1 x y z 1 x y z 1 If apply MaxRES ﬁrst second clauses obtain x y 1 x y z 1 x y z 1 If apply MaxRES second clauses obtain x y 1 x z 1 initial formula Nevertheless Bonet et al 27 recently proved clauses nonmandatory directional appli cation MaxRES solves MaxSAT problem If proof combined proof correctness DP 21 clauses mandatory extension DP MaxSAT produces correct algorithm MaxDP depicted Fig 5 extension DP MaxSAT Both algorithms essentially equivalent main difference MaxDP performs MaxRES instead classical resolution Observe parallelism Function VarElim Fig 3 Function MaxVarElim Fig 5 Both charge elimination variable xi formula As SAT case MaxVarElim computes bucket B line 1 removes clauses formula line 2 Then selects clause x A u resolves clashing clauses The function Clash similar SAT deﬁnition Section 22 A B tautology absorbed F based MaxSAT deﬁnition absorption In VarElim clause x A resolved clashing clauses exist In MaxVarElim clause x A u resolved weight u decreases 0 clashing clauses exist A difference worth noting respect SAT case MaxVarElim selects line 4 minimal size clause This required correctness algorithm achieve complexity stated Theorem 23 The following lemma shows MaxVarElim transforms input formula preserving optimality 214 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Lemma 19 Consider MaxVarElim function Let F cid13 denote input formula let F cid15 cid13 denote output formula It true F cid13 models F cid15 cid13 models Besides F cid13 models cost optimal cost optimal model F cid15 cid13 Proof See Appendix A cid2 Theorem 20 Algorithm MaxDP correct Proof MaxDP sequence variable eliminations variablefree formula obtained Lemma 19 shows transformation preserves cost optimal model Therefore cost ﬁnal variablefree formula cid2 u cost optimal model original formula cid2 The following lemma shows complexity eliminating variable classical SAT Max SAT Lemma 21 Let F cid13 MaxSAT instance xi variables Let ni denote number variables sharing clause xi F The space time complexity MaxVarElimF cid13 xi O3ni O9ni respectively Proof See Appendix A cid2 The lemma shows induced graph plays role DP MaxDP Lemma 22 Let d denote reverse order MaxDPF cid13 eliminates variables The width xi d induced graph GF d bounds number variables sharing clause xi time elimination Proof Same SAT case Lemma 3 cid2 The following theorem trivially follows previous lemmas bounds complexity MaxDP Theorem 23 Let F cid13 arbitrary MaxSAT instance Let d denote reverse order MaxDPF cid13 eliminates variables The space time complexity DPF On 3w d respectively w d induced width interaction graph GF d d On 9w Observe complexities DP MaxDP MaxSAT complexity higher SAT The following remark shows MaxDP true extension DP Remark 24 The execution MaxDP SAT instance F cid13 cid13 1 behaves like classical DP 5 Efﬁcient inference The complexity results previous section solving MaxSAT pure resolution methods general space consuming practice formulas small induced width 30 current computers A natural alternative use restricted forms resolution simplify formula use search In Section summarize simpliﬁcation rules proposed recent MaxSAT literature naturally explained framework We introduce original ones solver introduce Section 6 We classify simpliﬁcation rules categories single applications resolution multiple applications resolution hyperresolution variable elimination The following rules presented general form In Section 6 use subset rules restricted form J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 215 51 Single resolution Proposition 25 Unit clause reduction called upper bound rule 13 cid4 cid3 l cid13 l A w cid3 cid4 l cid13 A w particular case MaxRES Proof If w cid13 classical SAT case trivial If w cid13 application MaxRES l cid2 cid13 l A w produces A w l cid13 cid17 w l A w cid17 w l cid2 A w l cid2 A w The clause removed w cid17 w 0 The fourth clause removed absorbed second The ﬁfth clause removed tautology cid2 Proposition 26 Neighborhood resolution 1 called replacement common clauses 8 cid4 cid3 l A u l A w cid4 cid3 A w l A u cid17 w loss generality w cid3 u particular case MaxRES Proof Resolving lefthand clauses obtain A w l A u cid17 w l A w cid17 w l A A w l A A w The clause omitted weight 0 w cid13 absorbed resolvent w cid13 The fourth ﬁfth clauses omitted tautologies cid2 The simpliﬁcation potential neighborhood resolution shown following example Example 27 Consider formula y z 1 y z 1 z 1 The application neighborhood resolution yields z 1 z 1 allows new application neighborhood resolution producing trivial formula cid2 1 The term neighborhood resolution coined 28 SAT context The MaxSAT extension ﬁrst proposed 8 The practical efﬁciency A 0 1 2 cases assessed 2930 14 1 respectively 52 Variable elimination Proposition 28 The pure literal rule ﬁrst proposed MaxSAT context 8 special case Max VarElim Proof Consider formula F literal l negation appear formula Let x varl Function MaxVarElimF cid13 x effect pure literal rule pair clauses clashing x Thus resolution performed clauses containing l removed formula cid2 Proposition 29 The elimination rule 8 called resolution 910 says F l A u l B w F cid15 varl occur F cid15 A B minu w F F cid15 cid3cid13 cid14cid4 special case MaxVarElim Proof Let x clashing variable x varl We need prove Function MaxVarElim x elimination variable replaces l A u l B w A B minu w There possibilities If l A u l B w clash resolved AB minu w added formula All clauses bucket resolution step clash x MaxVarElim discard If l A u l B w clash MaxVarElim directly discard In case A B tautology absorbed effect righthand elimination rule cid2 216 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Fig 6 Graphical representation MaxRES Proposition 30 Let x denote x x The small subformula rule 9 says F x y A u x y B w x y C v F cid15 x y occur F cid15 F F cid15 special case MaxVarElim Proof We need prove eliminate x y x y A u x y B w x y C v function MaxVarElim obtain formula If occurrences x y sign rule holds pure literal rule applied If occurrences different sign cases consider cases symmetric If x y A u x y B v x y C w clauses clashing x y MaxVarElim discard clauses If x y A u x y B v x y C w ﬁrst second clauses clash MaxRES produces cid3 y A B m x y A u cid17 m x y B v cid17 m x y A y B m x y A y B m x y C w cid4 m minu v equivalent cid3 y A B m x y A u cid17 m x y B v cid17 m x y A B m cid4 x A y B m x y C w There clauses clashing x Note second clauses clash u cid13 v cid13 clauses zero weight discarded u v cid13 resolvent formula ﬁrst clause clauses clash deﬁnition absorption So MaxVarElim discard clauses mention producing equivalent y A B m The pure literal rule eliminate clause producing formula cid2 53 Hyperresolution Hyperresolution known SAT concept refers compression resolution steps single step In following introduce hyperresolution inference rules The ﬁrst star rule dominating unitclause formal descriptions published rules The rules cycle chain resolution original We prove correctness rules developing resolution tree allows transform lefthand rule righthand Fig 6 shows graphical representation Max RES On prior clashing clauses We write bold face emphasize removed formula The resolvent linked prior clashing clauses At left resolvent write posterior clashing clauses compensation clashing clauses added preserve equivalence J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 217 Fig 7 Resolution tree star rule 531 Star rule The star rule 914 identiﬁes clause length k literals appears negated unit clause Then clauses falsiﬁed Formally cid2 l1 l2 lk w li ui1cid2icid2k cid15 l1 l2 lk w cid17 m li li1 li2 lk m1cid2ik li ui cid17 m1cid2icid2k cid2 m m minw u1 u2 uk This rule proved k resolution steps Assume loss generality 1cid2ik ui cid3 ui1 Assume uk cid13 unit clause reduction previously triggered Let m minw u1 Fig 7 shows corresponding resolution tree Recall bold clauses resolved removed formula Essentially unit clause eliminate literal length k clause At end derive clause 532 Dominating unitclause The dominating unitclause rule 9 called UP3 13 says weight unit clause l u higher sum weights l appears safely assign l formula Formally u cid2 F cid16 F kcid15 i1 cid4 cid3 l Ai ui cid4 cid3 l u j 1 wj F cid15 contain occurrence l l cid3 cid4 Bj wj cid4 cid3 l Bj wj k j 1 F cid15 F cid15 k k j 1 This rule proved k resolution steps plus application pure literal rule Fig 8 shows corresponding resolution tree As previous case assume weight u cid13 unit clause 218 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Fig 8 Resolution tree dominating unit clause rule reduction triggered At step unit clause l resolved l Bj wj Since deﬁnition weight l larger equal wj clause l Bj replaced Bj At end process clause mentioning l pure literal rule applied proves correctness rule 533 Chain resolution Our original chain resolution rule identiﬁes subset chained binary clauses unit clauses associated ends When pattern exists sequence unit resolution steps sufﬁces derive clause The rule following l1 u1 li li1 ui11cid2ik lk uk1 li mi cid17 mi11cid2icid2k li li1 ui1 cid17 mi11cid2ik li li1 mi11cid2ik lk uk1 cid17 mk1 cid2 mk1 mi minu1 u2 ui 1cid2ij cid2k varli cid5 varlj This rule proved k steps resolution Fig 9 shows corresponding resolution tree Starting unit clause l1 resolution step unit clause li resolved li li1 ui1 produces unit clause li1 following resolution step The unit clause obtained lk resolved lk uk1 derives clause Example 31 Consider following formula x 2 x y 1 y z cid13 z 2 If resolve x 2 x y 1 obtain x 1 y 1 x y 1 y z cid13 z 2 If resolve y 1 y z cid13 obtain x 1 x y 1 z 1 y z 1 y z cid13 z 2 Next resolve z 1 z 2 obtain x 1 x y 1 y z 1 y z cid13 z 1 cid2 1 Observe chain resolution k 1 reduces simple neighborhood resolution k 2 reduces star rule limited binary clauses k 3 3RES rule proposed 2 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 219 Fig 9 Resolution tree chain resolution rule 534 Cycle resolution Our original cycle resolution rule identiﬁes subset binary clauses cyclic structure When pattern exists sequence resolution steps binary clauses sufﬁces derive new unit clause The rule following cid2 li li1 ui1cid2ik l1 lk uk cid15 l1 li mi1 cid17 mi2cid2icid2k li li1 ui cid17 mi2cid2ik l1 li li1 mi2cid2ik l1 li li1 mi2cid2ik l1 lk uk cid17 mk l1 mk mi minu1 u2 ui 1cid2ij cid2k varli cid5 varlj This rule proved k 1 steps resolution Fig 10 shows corresponding resolution tree The use cycle rule derive new unit clauses turn chain resolution increase weight clause Example 32 Consider formula x1 x2 1 x1 x3 1 x2 x3 1 x3 x4 1 x4 x5 1 x5 1 We apply cycle rule ﬁrst clauses obtaining x3 1 x1 x2 x3 1 x1 x2 x3 1 x3 x4 1 x4 x5 1 x5 1 Chain resolution applied unary binary clauses producing x1 x2 x3 1 x1 x2 x3 1 x3 x4 1 x4 x5 1 cid2 1 6 An efﬁcient MaxSAT solver In previous section presented set simpliﬁcation rules Some previously proposed researchers original We showed viewed special cases resolution hyperresolution variable elimination In section consider incorporation MaxDPLL algorithm introduced Section 42 The idea use rules simplify current MaxSAT formula 220 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Fig 10 Resolution tree cycle resolution rule letting MaxDPLL branch variables Our experimental work indicates cost effective apply general basis We observed rules useful general neighborhood resolution chain resolution cycle resolution Besides pays apply rules clauses small size 2 The reason quadratic number bounds overhead detection situations triggered Regarding cycle resolution effective apply k 3 case considering triplets variables Note fact solver incorporates rules prevent rules effective particular class problems experiment A highlevel description solver appears Fig 11 It MaxDPLL augmented simpliﬁcation rules function Simplify This function iteratively simpliﬁes formula It stops explicit contradiction derived simpliﬁcation line 10 Simpliﬁcation rules arranged ordered manner means rules R Rcid15 applied rule R higher priority rule Rcid15 algorithm chose R The rules highest priority unit clause reduction absorption grouped assignment Fl operation line 3 Next aggregation line 4 hardening line 5 neighborhood resolution line 6 chain resolution line 7 cycle resolution restricted cycles length 3 line 8 All rules restricted unary binary clauses We apply variable elimination rule Although actual implementation conceptually equivalent pseudocode Fig 11 noted code aims clarity simplicity Thus direct translation programming language highly inefﬁcient The main source inefﬁciency time spent searching clauses match lefthand simpliﬁcation rules This overhead depends number clauses takes place iteration loop As mentioned current implementation takes account clauses arity equal Another way decrease overhead identify events potentially transformation applicable For instance clause mandatory line 5 weight weight clause increases Then implementation reacts events triggers corresponding rules Such approach wellknown constraint satisfaction ﬁeld usually implemented streams pending events 3132 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 221 stop false function SimplifyF cid13 1 2 l cid13 F apply F l 3 elseif C u C w F apply Aggregation 4 elseif cid2 u C w F u w cid13 apply Hardening 5 elseif x A u x A w F apply Neighborhood Res 6 elseif l1 u1 li li1 ui11cid2ik lk uk1 F apply Chain Res 7 elseif l h u l q v h q w F apply Cycle Res 8 stop true 9 10 cid2 cid13 F stop 11 return F endfunction function MaxDPLLF cid13 return N 12 F SimplifyF cid13 13 F return 0 14 F cid2 w return w 15 l SelectLiteralF 16 cid13 MaxDPLLF l cid13 17 cid13 MaxDPLLF l cid13 18 return cid13 endfunction Fig 11 MaxDPLL enhanced inference Function SimplifyF cid13 converts input formula simpler Note imple mentation efﬁciency reasons consider A cid3 1 C cid3 2 case The way detect chain resolution pattern deserves special consideration At search node consider set binary unary clauses compute corresponding implication graph deﬁned follows variable xi graph vertices xi xi binary clause li lj u graph arcs li lj lj li We arcs complementary formula contains unit clause l u vertex l starting vertex vertex l ending vertex It easy path l1 l2 lk l1 lk starting ending vertices respectively path cross pair complementary arcs chain resolution applied path tells order resolution applied In implementation select arbitrary starting vertex compute shortest paths ending vertices Dijkstras algorithm If paths cross complementary arcs trigger rule Else starting vertex selected process repeated Note method necessarily detect potential applications chain resolution takes consideration path pair starting ending vertices shortest path given Dijkstra The fact path crosses complementary arcs prevent existence paths cross complementary arcs We believe better approach use ﬂow algorithm studied possibility 7 Experimental results We divide experiments parts The purpose ﬁrst assess importance differ ent inference rules solver incorporates These experiments include random MaxSAT instances random MaxClique problems The purpose second evaluate performance solver comparison available solving techniques These experiments include random weighted unweighted MaxSAT instances random structured MaxOne problems random MaxCut problems random structured real MaxClique problems combinatorial auctions 222 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Our solver written C available TOOLBAR software1 version 30 Benchmarks available TOOLBAR repository In experiments random instances samples 30 instances plots report mean CPU time seconds Executions 32 GHz Pentium 4 Linux Unless indicated executions aborted reached time limit 1200 seconds In plots legend order items reﬂects relative performance order different competitors Default options competitors solvers No initial upper bounds given reported CPU time time ﬁnd optimal solution prove optimality 71 Adding inference MaxDPLL We consider following versions solver 1 Basic MaxDPLL Namely Algorithm 11 lines 68 Function Simplify commented We denote algorithm MaxDPLL1 2 The previous algorithm enhanced neighborhood resolution lines 78 Simplify commented We denote algorithm MaxDPLL2 3 The previous algorithm enhanced chain resolution line 8 Simplify commented We denote algorithm MaxDPLL3 4 The previous algorithm enhanced cycle resolution lines Simplify considered We denote algorithm MaxDPLL4 For ﬁrst experiment consider random MaxkSAT instances A random kSAT formula deﬁned parameters cid18k n mcid19 k ﬁxed size clauses n number variables m number clauses Each clause randomly generated selecting k distinct variables uniform probability distribution The sign variable clause randomly chosen In following experiments generate instances number clauses sufﬁciently high formula unsatisﬁable solved corresponding MaxSAT problem We Cnfgen2 generator Note allows repeated clauses v repetitions clause C grouped weighted clause C v Fig 12 topleft reports results random Max2SAT instances 100 variables varying number clauses It seen MaxDPLL1 performs poorly solve instances 200 clauses The addition neighborhood resolution MaxDPLL2 improves performance 2 orders magnitude allows solve instances 300 clauses The addition chain resolution provides spectacular improvement allows solve instances 750 clauses Finally addition cycle resolution allows solve 100 seconds instances 1000 clauses The improvements observed random Max3SAT instances Fig 12 topright The MaxClique problem problem ﬁnding clique maximum size embedded given graph It known solving maximum clique problem graph G V E equivalent solving minimum vertex covering problem graph Gcid15 V Ecid15 Ecid15 complementary E u v Ecid15 u v E Therefore solved MaxClique instances encoding MaxSAT corresponding minimum vertex covering problem described Example 5 Section 3 A random graph deﬁned parameters cid18n ecid19 n number nodes e number edges Edges randomly chosen uniform probability distribution Fig 12 reports results solving MaxClique problem random graphs 150 nodes varying number edges It observed instances connectivity lower 50 percent trivially solved algorithms Note instances small connectivity associated MaxSAT encoding containing large number hard clauses Hence unit clause reduction rule applied frequently instances This reason easily solved However connectivity increases differences versions increases We noticed slight improvement MaxDPLL2 MaxDPLL1 For connectivities 76 99 greatest differences 1 httpcarlittoulouseinrafrcgibinawkicgiToolBarIntro 2 ftpdimacsrutgersedupubchallengesatisﬁabilitycontributedUCSCinstances J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 223 Fig 12 Experimental results different algorithms random MaxkSAT MaxClique instances While MaxDPLL1 MaxDPLL2 unable solve instances MaxDPLL3 Max DPLL4 perform With connectivity near 90 observed cycle resolution reports noticeable improvement From experiments conclude synergy inference rules MaxDPLL4 produces efﬁcient algorithm 72 MaxDPLL versus alternative solvers In following experiments evaluate performance MaxDPLL4 refer MAXDPLL For purpose compare MAXDPLL following stateoftheart MaxSAT solvers MAXSOLVER Sep tember 2004 second release 13 LAZY version 20 14 UP version 15 33 LB4A 12 MAXSATZ July 2006 release 34 They suffer following limitations The available version MAXSOLVER restricted instances 200 variables 1000 clauses For implementation reasons UP MAXSATZ deal instances having clauses high weights Therefore deal instances combine mandatory weighted clauses LB4A solve unweighted Max2SAT problems restricted binary clauses unit weights repeated clauses Consequently experiments execute solver possible according limitations It known MaxSAT problems solved pseudoBoolean SAT solvers For sake comprehensive comparison consider PUEBLO version 14 35 MINISAT 2005 release 36 best pseudoBoolean SAT solvers respectively In Appendix B trans lated MaxSAT instances frameworks Note pseudoBoolean formulas equivalent 01 224 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Fig 13 Random Max2SAT Max3SAT Max2SAT instances plot left contain repeated clauses integer linear programs ILP Thus solved stateoftheart ILP solver CPLEX We considered alternative 11 showed generally ineffective MaxSAT instances Max SAT problems solved WCSP solvers 11 We consider type solver study reference WCSP solver MEDAC 32 uses techniques similar MaxDPLL roughly described nonBoolean restricted version MaxDPLL3 721 Random MaxkSAT For following experiment generated random 2SAT instances 60 variables 3SAT instances 40 variables varying number clauses Cnfgen generator We generated random 2SAT instances 140 variables 2SAT generator 12 allow repeated clauses Fig 13 topleft presents results Max2SAT repeated clauses It observed MAX DPLL MAXSATZ algorithms solve problems 1000 clauses MAXSATZ roughly 3 times faster MAXDPLL A surprising observation LB4A solver speciﬁcally designed Max2SAT repetitions performs worse MaxSAT solvers random unweighted Max2 SAT Fig 13 topright presents results Max2SAT repeated clauses MAXDPLL MAXSATZ best algorithms similar performance The best solver UP nearly 100 times slower hardest instances Fig 13 presents results Max3SAT MAXSATZ provides best performance The second best option MAXDPLL requires twice time The best option LAZY 20 times slower MAXSATZ An observation worth noting alternative encodings pseudoBoolean SAT effective random instances We conclude experiment MAXSATZ best solver type problems random weighted The second best option MAXDPLL We explain Section 8 MAXSATZ roughly described UP enhanced inference rules similar MAXDPLL Therefore importance inference rules based weighted resolution corroborated J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 225 Fig 14 Random MaxOne instances 722 MaxOne Given satisﬁable CNF formula MaxOne problem ﬁnding model maximum number variables set true This problem encoded MaxSAT considering clauses original formula mandatory adding weighted unary clause xi 1 variable formula Note solving problem harder solving usual SAT problem search stop soon model The optimal model optimality proved Fig 14 shows results random 3SAT instances 150 variables Note MAXSATZ executed benchmark deal mandatory clauses The ﬁrst thing observed LAZY MINISAT perform Regarding solvers PUEBLO best number clauses small relative efﬁciency decreases number clauses grows MAXSOLVER opposite behavior MAXDPLL lay middle The performance solvers converges number clauses approaches phase transition peak The reason number models decreases optimization MaxOne problem loses relevance number models chose decreases Fig 15 reports results MaxOne problem selected satisﬁable SAT instances DIMACS chal lenge 373 The ﬁrst column indicates problem classes The second column indicates number instances class The columns indicate performance solver indicating number stances solved time limit If instances solved number parenthesis mean time seconds The symbol MAXSOLVER column indicates instances executed limitation solver maximum number variables clauses As observed MAX SOLVER LAZY succeed benchmark means MAXDPLL MaxSAT solver deal Its performance comparable good performance MINISAT PUEBLO However par16c instances MAXDPLL performs badly par8 instances performs better 723 MaxCut Given graph G V E cut deﬁned subset vertices U V The size cut number edges vi vj vi U vj V U The MaxCut problem consists ﬁnding cut maximum size It encoded MaxSAT associating variable xi graph vertex Value t respectively f indicates vertex vi belongs U respectively V U For edge vi vj clauses xi xj xi xj Given complete assignment number falsiﬁed clauses E S S size cut associated assignment Note encoding produces unweighted Max2SAT formula LB4A solver 3 ftpdimacsrutgersedupubchallengesatisﬁabilitybenchmarkscnf 226 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Problem aim50 aim100 aim200 jnh ii8 ii32 par8 par16 c n inst MaxDPLL MaxSolver Lazy MiniSat Pueblo 16 16 16 16 14 17 10 5 16059 16267 9 16149 5 11 10092 578414 16012 16492 4 162825 0 0 6 1 0 5 0 16001 16002 16003 16008 10 16 101639 5093 16000 16000 16000 16010 3 15 102652 5093 Fig 15 Results MaxOne problem selected DIMACS SAT instances Fig 16 Random MaxCut instances Random MaxCut instances extracted random graphs Section 71 generation We considered graphs 60 nodes varying number edges Fig 16 reports results benchmark It observed solvers MAXSATZ MAXDPLL problems harder number edges increases However MAXSATZ MAXDPLL solve instances 500 edges instantly The best solver LB4A MAXSATZ 30 times faster PUEBLO MINISAT perform poorly easiest instances included comparison 724 MaxClique The MaxClique problem problem ﬁnding clique maximum size embedded given graph Its Max SAT encoding described Section 71 MAXSATZ UP MAXSOLVER LB4A solvers executed domain limitations Our ﬁrst MaxClique experiment random graphs 150 nodes varying number edges Fig 17 reports results Again MAXDPLL clearly better competitor All competitors 2 orders magnitude slower MAXDPLL We considered 66 MaxClique instances DIMACS challenge 374 MAXSOLVER executed benchmark number variables clauses instances exceed capacity Thus MaxSAT solvers executed MAXDPLL LAZY Within time limit solved 32 23 instances respectively MINISAT PUEBLO solve 22 16 instances respectively Therefore MAXDPLL provided best performance benchmark 4 ftpdimacsrutgersedupubchallengegraphbenchmarksclique J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 227 Fig 17 Random MaxClique instances Problem 1bpi1knt 1bpi2knt 1bpi5pti 1knt1bpi 1knt2knt 1knt5pti 1vii1cph 2knt5pti 3ebx1era 3ebx6ebx 6ebx1era V 2279 2436 3016 2494 1806 2236 171 2184 2548 1768 1666 C Opt MaxDPLL Lazy MiniSat 2213051 2521619 3851441 2649173 1391200 2122357 13125 2021705 2769706 1338035 1189537 31 29 42 30 39 28 6 28 31 28 20 3854 6891 6601 904 4749 027 3911 9332 1636 1428 12379 032 16581 14651 25303 11502 24607 19310 5710 31535 046 10239 52434 19482 19367 4 19 182 30 110 0 46 0 95 236 6 101 Fig 18 Protein structure alignment problem transformed MaxClique These instances previously evaluate dedicated maximum clique algorithms Performing proper comparison MAXDPLL difﬁcult codes available need program algorithms However following approach 38 overcome problem normalizing reported times Of course simplistic approach disregards relevant parameters memory processor model In consequence following results taken indicative information Giving time limit 25 hours instance 32 GHz MAXDPLL able solve 37 instances In equivalent normalization time 39 solves 38 40 solves 36 41 solves 45 38 solves 52 Finally considered 11 MaxClique real instances provided JS Sokol corresponding protein structure alignment problem transformed maximum clique problem described 4 instances taken preprocessing described paper In problem goal compute score similarity proteins based particular knowledge respective threedimensional structure Due size instances presence mandatory weighted clauses solvers executed MAXDPLL LAZY MINISAT The results shown Fig 18 gives instance 4 number Boolean variables number clauses maximum clique size CPU time seconds time limit 10 hours MAXDPLL run 3 GHz Intel Xeon 64bit 16 GB LAZY MINISAT run 3 GHz Intel Xeon 4 GB specialized algorithm introduced 4 run 200 MHz SGI 228 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Fig 19 Combinatorial auctions Topleft Paths distribution Topright Regions distribution Bottom Scheduling distribution LAZY MINISAT require memory MAXDPLL solve 1bpi5pti memory reasons LAZY solve 4 instances 10 hours Although MINISAT solves instances approxi mately 5 times slower MAXDPLL 10 instances The dedicated algorithm 4 solves instances orders magnitude faster MAXDPLL showing gap generic specialized algorithms 725 Combinatorial auctions Combinatorial auction allows bidders bid indivisible subsets goods Consider set G goods n bids Bid deﬁned subset requested goods Gi G money offered The bidtaker wants maximize revenue decide bids accepted Note bids request good jointly accepted 7 In MaxSAT encoding variable xi associated bid There unit clauses xi ui indicating bid accepted loss proﬁt ui Besides pair j conﬂicting bids add mandatory clause xi xj cid13 We CATS generator 42 allows generate random instances inspired realworld scenarios In particular generated instances Regions Paths Scheduling distributions The number goods ﬁxed 60 varied number bids By increasing number bids instances constrained conﬂicting pairs bids harder solve MAXSATZ UP MAXSOLVER LB4A executed limitations The LAZY solver included Regions comparison overﬂow problems Fig 19 topleft presents results Paths distribution MAXDPLL produces best results 22 times faster second best option LAZY Fig 19 topright presents results Regions distribution MAXDPLL best algorithm It 26 times faster second best solver PUEBLO Finally results Scheduling distribution shown Fig 19 In benchmark performance MAXDPLL MINISAT similar solvers 4 times slower J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 229 8 Related work 81 Relation weighted constraint satisfaction problems A weighted constraint satisfaction problem WCSP 43 similar MaxSAT instance variables multivalued bivalued costs given arbitrary cost functions clauses It known WCSP translated MaxSAT instance viceversa 11 Some ideas presented paper strong connections different techniques recently developed WCSP ﬁeld In following summarize connections The idea adding lower bound cid2 w upper bound cid13 problem formulation borrowed 44 The concept equivalencepreserving problem transformation moving costs comes 26 DP MaxDP seen instantiations bucket elimination 45 metaalgorithm based variable elimination principle wellknown WCSP context 4647 Neighborhood resolution related notion projection enforce node arcconsistency 2648 The application Chain resolution k 2 similar enforcement existential arc consistency 32 Cycle resolution k 3 related particular case socalled highorder consistencies proposed 49 More precisely weighted version restricted Boolean variables path inverse consistency 50 82 Relation MaxSAT solvers In years algorithms MaxSAT proposed 1115303351 Most common basic branch bound structure mainly differ lower bound use When lower bound reach upper bound search continues current node new lower bounds computed The problem lower bound computation methods transform formula lower bound explicit problem Consequently lower bound needs computed scratch visited node inconsistencies discovered In approach lower bound computed simpliﬁcation process current problem When lower bound reach upper bound simpliﬁed formula passed descendant nodes actually inherit lower bound Interestingly Li et al detected common pitfall In work 34 independently parallel introduce MaxSAT solver similarities MaxDPLL The main contribution paper 6 MaxSAT simpliﬁcation rules called Rules 16 They conclude paper small set simpliﬁcation rules essential efﬁciency MaxSAT solver Besides set fundamental simpliﬁcation rules similar Their solver called MAXSATZ build previous solver 3351 The novelty MAXSATZ incorporates neighborhood resolution restricted unary binary clauses Rules 1 2 terminology chain resolution Rules 3 4 special case cycle resolution restricted triplets variables immediate lower bound increment guaranteed Rule 5 ﬁnally sequence chain resolution followed cycle resolution lower bound increment guaranteed Rule 6 Besides MAXSATZ identiﬁes certain variable necessarily truth values exactly hardening rule A signiﬁcant difference MAXSATZ MaxDPLL type MaxSAT instances assumed solved MAXSATZ assumes unweighted clauses weighted clauses low weights As consequence Max SAT instances represented multisets clauses w repetitions clause C equivalent C w notation The main advantage simpliﬁcation inherit modern SAT solver SATz 52 efﬁcient data structures efﬁcient implementation propagation procedures This explain MAXSATZ better MaxDPLL unweighted instances The main disadvantage assumption MAXSATZ applied instances having mandatory clauses clauses high weights As shown Section 7 limits severely scope applicability 9 Conclusion future work This paper introduces novel MaxSAT framework highlights relationship SAT MaxSAT solving techniques Most remarkably extends concept resolution Our resolution rule ﬁrst proposed 1 proved complete 27 There beneﬁcial consequences approach 230 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 It allows talk MaxSAT solving usual SAT terminology It allows naturally extend basic algorithms DPLL DP It allows express solving techniques spread MaxSAT literature common formalism logical interpretation connection similar SAT CSP WCSP techniques From practical point view proposed hybrid algorithm combines search restricted forms inference It follows typical search strategy visited node attempts simplify current subproblem special cases resolution problem transformed simpler equivalent Our experiments variety domains algorithm orders magnitude faster competitors Our current solver lacks features considered relevant SAT context example clause learning restarts Since framework makes connection SAT MaxSAT obvious features easily incorporated future Additionally ideas presented paper bor rowed weighted CSP ﬁeld 43 Therefore possible incorporate new weighted constraint processing techniques Finally want note recent work 33 51 good lower bounds obtained temporarily setting cid13 1 simulating unit propagation Since hyperresolution rules presented Section 52 special cases general algorithm want explore approach fully described resolution rule Appendix A Correctness complexity MaxVarElim In appendix prove Lemmas 19 21 establish correctness MaxVarElim function Fig 5 time space complexity In proofs borrow ideas 182127 adapt framework In following write C F mean C u F weight u ambiguity F cid15 denote application resolution step formula F clauses F different We use symbol F cid20xi resulting formula F cid15 clashing variable xi Consider elimination variable xi Function MaxVarElim First formula partitioned sets clauses B F Then clauses form xi A u fetched B resolved clashing clauses quiescence disappearance ﬁnally discarded Suppose discarded clauses stored set D Formally execution MaxVarElim sequence resolution steps B1 F1 D1 cid20xi Bo Fo Do cid20xi Bq Fq Dq Do For 0 cid3 k cid3 q Bk set clauses contain xi xi Fk set clauses contain xi xi Dk set clauses contain xi Besides Bq clause xi The output MaxVarElim Fq prove essentially equivalent original formula Let Ni denote set variables sharing clauses xi starting B Bo cid20xi Ni cid4 cid3 xj cid5 xi CBo xj varC let ni Ni cardinality In remaining appendix number new clauses generated sequence resolution steps bounded O3ni space complexity number resolution steps bounded O9ni time complexity optimal model Fq trivially generate optimal model original formula Bo Fo correctness Observe variables different xi appearing clauses generated resolution process belong Ni resolution add new variables Therefore clauses Bk form l A varl xi varA Ni Variable xi appear clause positive negative literal 2 options xj Ni appear A appears positive negative form 3 options Consequently size Bk bounded 2 3ni For similar reasons clause C added F resolution process satisﬁes varC Ni Every xj Ni appear C appears positive negative 3 options Consequently number nonoriginal clauses Fk bounded 3ni Therefore number clauses added B F execution MaxVarElim bounded 2 3ni 3ni As result space complexity O3ni J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 231 Next analyze time complexity Recall clauses xi A u xi B w F clash A B l B A B F absorbed Ccid13F C cid5 A B We clause tautology lA xi A u saturated clause F clashing The following lemma shows resolving clause removes clause formula reduces number clauses clashing Lemma 33 Consider resolution step P cid20xi xi A P cid15 number clauses clashing xi A decreases P cid15 xi A u xi B w clashing clauses Then Proof We reason cases 1 If u w u w cid13 posterior xi A weight 0 disappears formula 2 If u w cid13 effect resolution add resolvent formula P cid15 P A B cid13 Then xi B clash xi A anymore 3 If u w xi B replaced xi B A formula The new clause clash xi A A B A tautology cid2 Consider inner loop MaxVarElim It selects clause xi A resolves disappears saturates If xi A saturates removed B added D We sequence resolution steps processing xi A use symbol cid20 xi A represent A consequence previous lemma number resolution steps required process xi A bounded number clauses clashing Note number clauses clashing xi A u bounded 3ni clashing clauses belong B variable xi occur negated Therefore iteration outer loop inner loop MaxVarElim iterates 3ni times Consider outer loop MaxVarElim It selects sequence clauses xi A1 xi A2 xi As processes We process Bk1 Bo Fo Do cid20 Dk1 Fk1 cid20 cid20 Bks Fks Dks xi A1 xi A2 xi As Recall algorithm selects processing clause xi Aj minimal size line 4 Observe size compensation clause xi A B added B line 9 larger clause processed As consequence clause processed appear B means 1cid2j j cid15cid2sAj cid5 Aj cid15 A direct consequence 3ni distinct Aj outer loop iterates 3ni Therefore maximum number iterations inner loop 3ni 3ni 9ni means time complexity function O9ni Finally prove correctness MaxVarElim Lemma 34 A saturated clause remains saturated sequence resolution steps cid20xi F cid15 Let xi A xi B clashing clauses let xi C saturated Proof Consider resolution step F cid20xi clause F We need prove xi C remains saturated F cid15 Since xi C saturated F C B tautology absorbed F The new clause F cid15 clash xi C xi B A However C B tautology C B A If C B absorbed F C B A F cid15 cid2 A consequence previous lemma end sequence resolution steps performed Max VarElim formula Bks Fks Dks clauses saturated To prove correctness MaxVarElim need prove assignment I Fks extended variable xi cost freemanner taking account clauses xi B Bks clauses xi A Dks means ﬁnding optimal assignment Fks equivalent ﬁnding optimal assignment Bks Dks turn equivalent ﬁnding optimal assignment original formula Fks If Bks resp Dks variable xi set true resp false Else consider clause xi A Dks I satisfy A similarly xi B Bks Variable xi set true We I satisﬁes xi B Bks Clause xi A saturated A B tautology clause C Fks C A B In ﬁrst case I satisfy A A B tautology means I satisﬁes B In second case I satisﬁes C satisfy A satisfy B 232 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 Appendix B Solving MaxSAT pseudoBoolean SAT solvers In linear pseudoBoolean LPB problems Boolean variables x1 xn values true false replaced numbers 1 0 respectively Literal li represents xi negation 1 xi A LPB problem deﬁned LPB objective function minimized ncid17 i1 aili ai Z set LPB constraints ncid17 i1 aij li cid2 bj aij bj Z xi 0 1 A MaxSAT formula encoded LPB problem 11 partitioning set clauses sets H contains mandatory clauses C cid13 W contains nonunary nonmandatory clauses C u cid13 U contains unary nonmandatory clauses l u For hard clause Cj cid13 H LPB constraint Ccid15 cid2 1 j Ccid15 j obtained Cj replacing negated variables x 1 x For nonunary weighted clause Cj uj W LPB constraint Ccid15 j computed rj new variable j set 1 trivially satisﬁes constraint Finally objective function rj cid2 1 Ccid15 cid17 cid17 uj rj uj lj cid3 cid13 Cj uj W lj uj U A LPB problem solved native LPB solver PUEBLO SAT solver In case LPB constraint converted logic circuit There different possible conversions BDDs adders sorters In experiments MINISAT 53 translating tool converts LPB constraint presumably convenient circuit solves corresponding SAT formula MINISAT MINISAT converts objective function LPB problem LPB constraint setting upper bound The LPB problem solved decreasing value upper bound infeasible SAT formula References 1 J Larrosa F Heras Resolution MaxSAT relation local consistency weighted CSPs Proc 19th IJCAI Edinburgh UK 2005 pp 193198 2 J Larrosa F Heras New Inference Rules Efﬁcient MaxSAT Solving Proc AAAI06 Boston MA 2006 3 H Xu R Rutenbar K Sakallah subSAT A formulation relaxed boolean satisﬁability applications routing Proc Int Symp Physical Design San Diego CA 2002 pp 182187 4 D Strickland E Barnes J Sokol Optimal protein structure alignment maximum cliques Operations Research 53 3 2005 389402 5 M Vasquez J Hao A logicconstrained knapsack formulation tabu algorithm daily photograph scheduling earth observation satellite Journal Computational Optimization Applications 20 2 2001 137157 6 JD Park Using weighted MAXSAT engines solve MPE Proc AAAI02 Edmonton Alberta Canada 2002 pp 682687 7 T Sandholm An algorithm optimal winner determination combinatorial auctions Proc 16th IJCAI 1999 pp 542547 8 N Bansal V Raman Upper Bounds MaxSat Further improved ISAAC 1999 pp 247258 9 R Niedermeier P Rossmanith New upper bounds maximum satisﬁability J Algorithms 36 1 2000 6388 10 J Chen I Kanj Improved exact algorithms MaxSAT Proc 5th Latin American Symposium Theoretical Informatics 2002 pp 341355 11 S Givry J Larrosa P Meseguer T Schiex Solving MaxSAT weighted CSP Proc CP03 Cork Ireland 2003 pp 363376 12 H Shen H Zhang Study lower bounds Max2SAT Proc AAAI04 San Jose CA 2004 pp 185190 13 Z Xing W Zhang MaxSolver An efﬁcient exact algorithm weighted maximum satisﬁability Artiﬁcial Intelligence 164 12 2005 4780 14 T Alsinet F Manya J Planes Improved exact solver weighted MaxSAT Proc SAT05 St Andrews Scotland 2005 pp 371377 15 R Nieuwenhuis A Oliveras On SAT modulo theories optimization problems Proc SAT06 Seattle WA 2006 pp 156169 16 U Bertele F Brioschi Nonserial Dynamic Programming Academic Press New York 1972 17 R Dechter Constraint Processing Morgan Kaufmann San Francisco CA 2003 18 I Rish R Dechter Resolution vs inference Two approaches SAT Journal Automated Reasoning 24 1 2000 225275 19 S Arnborg Efﬁcient algorithms combinatorial problems graphs bounded decomposabilitya survey BIT 25 1985 223 20 M Davis G Logemann G Loveland A machine program theorem proving Communications ACM 5 1962 394397 J Larrosa et al Artiﬁcial Intelligence 172 2008 204233 233 21 M Davis H Putnam A computing procedure quantiﬁcation theory Journal ACM 3 1960 22 AV Gelder Satisﬁability testing reasoning guessing Cliques Coloring Satisﬁability Second DIMACS Imple mentation Challenge American Mathematical Society Providence RI 1995 pp 01 23 F Bacchus Enhancing Davis Putnam extended binary clause reasoning Proc AAAI02 Edmonton Alberta Canada 2002 pp 613619 24 L Drake A Frisch T Walsh Adding resolution DPLL procedure Boolean satisﬁability Proc SAT02 Cincinnati OH 2002 pp 122129 25 C Papadimitriou Computational Complexity AddisonWesley Reading MA 1994 26 T Schiex Arc Consistency soft constraints Proc CP00 Singapore 2000 pp 411424 27 M Bonet J Levy F Manya A complete calculus MaxSAT Proc SAT06 Seattle WA 2006 pp 240251 28 B Cha K Iwama Adding new clauses faster local search Proc AAAI96 Portland OR 1996 pp 332337 29 R Wallace E Freuder Comparative studies constraint satisfaction DavisPutnam algorithms MaxSAT problems Cliques Coloring Satisﬁability 1996 pp 587615 30 T Alsinet F Manya J Planes Improved branch bound algorithms MaxSAT Proc SAT03 Portoﬁno Italy 2003 pp 408415 31 C Bessière Arcconsistency arcconsistency Artiﬁcial Intelligence 65 1 1994 179190 32 S Givry F Heras J Larrosa M Zytnicki Existential arc consistency getting closer arc consistency weighted CSPs Proc 19th IJCAI Edinburgh UK 2005 pp 8489 33 CM Li F Manya J Planes Exploiting unit propagation compute lower bounds branch bound MaxSAT solvers Proc CP05 Sitges Spain 2005 pp 403414 34 CM Li F Manyà J Planes New inference rules MaxSAT Journal Artiﬁcial Intelligence Research press 35 HM Sheini KA Sakallah Pueblo A hybrid pseudoBoolean SAT solver Journal Satisﬁability Boolean Modeling Computation 2 2006 165189 36 N Eén N Sörensson An Extensible SATsolver Proc SAT03 Portoﬁno Italy 2003 pp 502518 37 DS Johnson M Trick Cliques Coloring Satisﬁability Second DIMACS Implementation Challenge DIMACS Series Discrete Mathematics Theoretical Computer Science vol 26 AMS 1993 38 JC Régin Using constraint programming solve maximum clique problem Proc CP03 Cork Ireland 2003 pp 634648 39 D Wood An algorithm ﬁnding maximum cliques graph Operations Research Letters 21 1997 211217 40 PRJ Ostergard A fast algorithm maximum clique problem Discrete Applied Mathematics 120 2002 197207 41 T Fahle Simple fast Improving branchandbound algorithm maximum clique Proc ESA 2002 pp 485498 42 K LeytonBrown M Pearson Y Shoham Towards universal test suite combinatorial auction algorithms ACM ECommerce 2000 6676 43 P Meseguer F Rossi T Schiex Soft constraints F Rossi P van Beek T Walsh Eds Handbook Constraint Programming Elsevier Amsterdam 2006 Ch 9 44 J Larrosa T Schiex Solving weighted CSP maintaining arcconsistency Artiﬁcial Intelligence 159 12 2004 126 45 R Dechter Bucket elimination A unifying framework reasoning Artiﬁcial Intelligence 113 12 1999 4185 46 J Larrosa R Dechter Boosting search variable elimination constraint optimization constraint satisfaction problems Con straints 8 3 2003 303326 47 J Larrosa E Morancho D Niso On practical applicability Bucket Elimination Stilllife case study Journal Artiﬁcial Intelli gence Research 23 2005 421440 48 J Larrosa Node arc consistency weighted CSP Proc AAAI02 Edmonton Alberta Canada 2002 pp 4853 49 M Cooper Highorder consistency valued constraint satisfaction Constraints 10 3 2005 283305 50 E Freuder C Elfe Neighborhood inverse consistency preprocessing Proc AAAI96 Portland OR 1996 pp 202208 51 CM Li F Manyà J Planes Detecting disjoint inconsistent subformulas computing lower bounds MaxSAT Proc AAAI06 Boston MA 2006 52 CM Li Anbulagan Heuristics based unit propagation satisﬁability problems Proc 15th IJCAI Nagoya Japan 1997 pp 366371 53 N Eén N Sörensson Translating pseudoBoolean constraints SAT Journal Satisﬁability Boolean Modeling Computation 2 2006 126