Artificial Intelligence 95 1997 l65 Artificial Intelligence Engineering compiling planning domain models promote validity efficiency TL McCluskey JM Porteous The School Computing Mathematics The University Huddersjield Queensgate Huddersjield HDI 3DH United Kingdom Received July 1996 revised May 1997 Abstract This paper postulates rigorous method construction classical planning domain models We help nontrivial example toolsupported method encoding models The method results objectcentred specification domain lifts representation level literal level object Thus example operators defined terms change state objects planning states defined amalgams objects states The method features classes tools initial capture validation domain model operationalising domain model process compilation later planning Here focus compilation tools generate macros goal orders utilised plan generation time We depth evaluate empirically combined benefits plan generation speedup The methods main benefit helping modeller produce tight valid operational domain model It potential benefits forcing change emphasis classical planning research encompass knowledgebased aspects target planning domains atic manner ii helping bridge gap research area theoretical unrealistic planning hand scruffy realworld planning iii commitment knowledge representation form allows powerful techniques planning domain model validation planning algorithm speedup bound toolsupported environment 1997 Elsevier Science BV Keywords Planning Knowledge compilation Domain modelling Corresponding author Email Email juliezeushudacuk leezeushudacuk 00043702971700 PII SOOO4370297000349 1997 Elsevier Science BV All rights reserved 2 ZL McCluskey JM PorteousArtiJicial Intelligence 95 I 997 165 1 Introduction 11 The problems knowledge sparse planning Intelligence frameworks Artificial structure containing relative performance decades concentrated classical planning issues planning algorithms Recent work concentrated planners totalorder versus partialorder 7231 extending complexity plan generation 25 general research dominated level representation ex 34457 expres planning theoretical use literal propo actions formulae literals Although en action little commitment Research theoretical ample inherent computational siveness classical model 311 This engines sition basic basic knowledge vironmental assumptions closed world characterise elaborate knowledge structure In paper argue research issues edge acquisition syntactic object Several issues ners isolation knowl away level classical planning representation representational lines argument facilitate primitive literal lead believe account making claims Planning default persistence considered classical approach semantic knowledge representational operators instantaneous taken deterministic representing general Plan causal planners planners linear planners Firstly consider link partialorder recent trend AI Planning number different planning research analyse classical generative planner linear partialorder suggested computational compare results Initial efficient redundancy strategies wildly vary In similar total partialorder concentrate match different planners hybrid planners different problem properties different variations efficiency tradeoffs systematic result reducing results called question fixed planning ing relative performance vein researchers concluded ponder preferable research 32 different domainindependent mains choice optimal frameworks encodings range domains open classical planning need advantage domain strategy appears domaindependent focus control strategies wrong question asking strategy So 551 We conclude use particular mechanisms 339 But classification planning domain best heuristics domains research Secondly need gap clean 26421 Researchers exploring theoretically planning practical applications features planning necessarily use simple domains intensive acquisition research scenario HCI user reliability issues On hand realworld planning planning software expertsa nonfunctional considered issues training In making hardware software constraints facilitate research abstract reasoning search requires teams knowledge completely different ball game user factors time response bridging requirements steps TL McCluskes JM PorteousArGjicial lnrelligence 95 1997 l65 3 gap careful modelling planning step forward moving away knowledge spectrum clean AI Hence systematic domains standard broad representational sparse stance approach framework Thirdly work shown performance strategy domain model Some researchers testified insignificant performance vary fixed planning seemingly result domain encoding An example given performance 24 p 9161 Even results favouring planner domain encoding flawed particular encoding domain Guidelines planner encoding domains encoding problem intrinsic different encodings large differences changes PRODIGYEBL favouring frameworks context 12 Implications introducing knowledge representation issues In introducing representational issues phenomena consider ii reality software model conform supposed supposed validating language encode reality imagined relational testing Using debugging planning capture piece reality block theoretical model outline algorithm unlike software purposes acceptance respect Whereas planning stacking machine criteria correctness iii framework levels cohesion selfconsistency relational real client need guidelines applications kind construction This apparently case AI planning specification domain symbolic domain model ii representation iii creating Initially hard debugging software domain model shop scheduling inappropriate devise guidelines domain models databases metrics models appear sparse underdeveloped 2 For example 591 Weld equates domain specification set pre post condition operators form definition leaves questions unanswered domain More generally conditions valid state Also way domain models constructed purposes research evaluation given particularly sufficient appears ad hoc reasons encoding rarely tests capture like concept process normalisation reasonably closed world assumption expect domain models include necessary valid initial state constitutes dominated literaturethey incorporating languages involving In Fig 1 typical concerns modeller model validation expressive issues language interaction language ease maintenance Validation representation power specification understandability linked There work developing realistic planner representation languages 1 lo realms Al planning despite expressive languages ADL 461 4 TL McCluskey JM PorteousArtiul Intelligence 95 1997 I65 s MODELLER concerns include validat expressive power maintenance model planning algorithm SHARED concerns include plan quality Fig I Views domain model Modeller INITIAL DOMAIN MODEL Tools syntax type consistency checking COMPILABLE DOMAIN MODEL Tools goal order macro abstraction hierarchy generators RUNNABLE DOMAIN MODEL Tools random task generator planner I PROVEN DOMAIN MODEL maintenance Fig 2 The development domain model tool support input model planner concern cited 291 From planning algorithms point view typical lead efficient effective plan requirements generation This generally entails separated planning standard simple format processing input task line Issues understandability important On hand isolation separate plan quality planner types requirements example relies accurate model effective planner issues considered precompiled planners difficult possible TL McCluskey JM PorteousArtijicial Intelligence 95 1997 l65 5 Tool support associated activities development tools feature revised tools reapplied provide measure insulation final planning form model compilation model At stage changed model In particular essential Fig 2 domain model tools domain model valid making use tool support making efJicient In paper emphasise tables systems language Within planning instances planning idea domain engineering use knowledge knowledge The OPlan features operators causal tackle search problems solve Rubics Cube problems producing macros form domain engineering unwinds 371 Also prune search 171 rich domain new For example Korfs use macro features compilation macros structure original domain encoding relied mainly handcoding specification typing 17 p 581 This problem difficult cal planners designer problem appropriate initial domain model features domain specific heuristics encapsulated descriptions This coding maintenance lack standard operators actual coding operators hierarchi engineer largely black art 36 p 11 In words operator search plan generation apparent space manually exacerbated form tool support developing admitted authors informationprecondition difficult problem abstractions certainly useful operators representational reducing job 13 A way forward This paper contains language It shows rigorous method capturing steps standard classical planning domains backed set standards requirements toolsupported method functional model respect domains domain model fit domain efficiency opportunities leads representation encodings classical planning improve plan time 78 theoretical 361 complexity rely concerned relied formulations level literal classes rely 12381 The restrictions In past classical planning proposition Abstraction mechanisms extent attraction apparent generality approach syntactic having domains manipulated Further domains behaviours scheduling domains contain drills shelves cranes To involve objects process plan execution contain groups objects share common properties rooms doors boxes jobshop trucks classical planners lathes components warehouse worlds contain example STRIPS domains contain free terms propositional aimed invariably state function change terms tend To date attempts example objectoriented largely aimed architectural level For approach robot planning Chang et al object view planning conceptual 6 TL McCluskey JM PorteousArtificial Intelligence 95 1997 l65 information knowledge bases objects ones knowledge base These approaches utilising objectoriented exploiting object structure 331 objects represented 11 I Green Todd 281 In systems abstract objects match unfamiliar concentrate generation planning quence objects objects This objectoriented junction reactive planner Again objectcentred stractions hierarchies work exploit domain modelling 00 paradigm knowledge base families pattern carrying plan reactive se specialised associated plan generation restrict use creation ab knowledge base In contrast central aims level approach knowledge base plan fragments work incorporate results adopting object In Kazis proposed objectoriented problem plan generation hierarchy plan fragments classical planning increasingly inheritance regularity tackling approach Overall approach summed providing toolsupported method domain modellers tools operationalise subsequent planning engineer capture domain models use compilation model In summary translate form potential benefits method efficient l allows domain models l tools naturally provided l ensures production created systematic fashion support step method tight domain model modeller define property valid state given domain check example action representations operational consistency l forces domain modeller focus attention semantic level object literal l tools help maintenance updated model model rerun steps standard objectcentred represen classical planning domains promises provide analysis impact variations domain model representation language represents l method tational framework different plan generation In addition empirical strategies evidence method capable producing general benefit method stem crossfertilisation areas computingour capture model compilation large speedups 41 formal methods software engineering approach 561 tools associated plan generation Finally research influenced work requirements domain model This paper communicated Section 2 Section 3 formalises follows The use method method method operationalising concepts domain models captured method This category tools produces macros goal orders In Section 5 evaluate method speedup number planning Section 2 We present review related work organised nontrivial classical planning underlying properties range tool support subject Sections 41 42 respectively evidence plan generation showing empirical domains introduced including Section 6 extensions work Section 8 produces Section 4 discusses Section 7 summarising approach TL McChskey JM PorteousArttjicial Intelligence 95 I 997 I65 7 2 A toolsupported method encoding classical planning domains In overview method propose encoding domain models given Steps ners produces runnable model l6 produce compilable Fig 2 classical plan domain model whilst step 7 I Initial requirements domain described natural language diagram matic form 2 The domain modeller identifies object hierarchy domain appear appropriate reflects natural group knowledge elicitation ings objects validation The hierarchy based object classes sorts 3 A set predicate descriptions denoting properties relationships domain defined 4 For sort domain state changed effect action actual objects sort called dynamic sort occupy specified Transition diagrams constructed dynamic range states sorts 5 A set state invariants model based constructed These state invariants software specifications formal invariant validation domain promotes compilation development analogous VDM effectiveness domain 56 The availability tools model 6 Operators model support affect states object class The consistency operators effect actions specified terms way checked 7 Compilation tools provide degree validation produce efficient planning application requirements different divisions loose step process loop earlier step At step tools help It step Note new uncovered construction planning domain ready attach planner plan generation dynamic testing involving initial domain steps fairly discovered crosschecking consistency encoding bugs Each steps explained elaborate form muchquoted help nontrivial multirobot 51 reader We actual STRIPSworlds terminology familiar example The domain basic imagined reality DR symbolic model create R 21 Initial domain description step I For domain captured initial requirements kind problems central abstractions brought A attempt natural A diagram purposes representing Fig 3 shown particular configuration outline main features solved ways language description DR given domain chosen illustrative 8 lL McCluskey JM PorteousArtcial Intelligence 95 I 997 I65 Legend H P e e robot harry blue key red key Light q Light oft3 m bluedoor m B reddoor door closed locked door closed unlocked q boxS Fig 3 DR3 example configuration multirobot domain model doors domain consists configuration rooms connected DR multirobot n robots exist Each robot arm doors pushing carrying Robots capable opening doors pushing doors objects Doors locked objects unlocked key keys carried locked doors lock unlocked doors Each room light turned robot objects doors open Changes actions robots The planner robots contribute initial running keys colour coded determine domain brought generate sequential controlling plans desired state world overall state Robots contribute costs producing unlock order plans fairly An important issue focus use model analyse level respect modelled appropriate reality model For example robots world interested involve moving boxes robots locations moving strategy stage PRODIGY planning descriptions perform plans typically colour coded keys rooms doors locked unlocked opened closed A useful modelling domains 49 try formulate example problems teach solutions consider supplied possible guidelines task portion use ZL McCluskey JM PorteousArtijicial Intelligence 95 1997 l65 9 Translating questions encoded domain model outline requirements precise model reveal model need answered explicitly specification operators invariants 22 Sort object identification step 2 Nouns natural language description indicate sorts domain model identifying methods collecting objects captured We regard sorts similar software engineering identifying Sorts sorts primitive models central abstractions classes objects objectoriented grouped hierarchically design supersort From DR identified following sorts sorts Room Door Box Robot Arm Key Light Colour Movableobj Physical_obj The sorts primitive sorts supersorts Movable_obj Box U Robot U Key Physical_obj Door U Arm U Movabledbj identified identifiers belonging object example boxl key2 door23 By convention sort sort names sort letter object identifiers start lower case primitive After sorts recorded variables start capital letter The set object sorts Primitive objects deemed Room Colour static All objects dynamic static objects identifiers belonging union contained supersort sorts described dynamic static depending In R chose sort called dynamic state effects actions change static sort local state changed actions The main characteristic sorts methodology object dynamic domain To distinguish local states substates A complete valid planning identifiers object set invariants appropriate described step 5 described substates local state sort planning based state refer state mapping step 4 conforms 23 Identcation relationships properties step 3 natural properties The verbs verb phrases relationships suggest effected At stage domain modeller specifies predicate descriptors verb phrases relevant problem language description indication states different sorts way changes state verbs appear terms planning problem planner asked solve describable necessary condition language captured domain model domain properties relationships IO TL McCluskey JM PorteousArtciul Intelligence 95 1997 l65 relationships following properties suggested properties Considering example domain R sort Door open closed locked unlocked predicate form following predicate descriptors predicates symbols single argument sort Door use sort type slots open Door closed Door locked Door unlocked Door Likewise following predicates positional information movable objects on_jloor Movableobj Room Movableobj Movableobj near_door Movable_obj Door Room typed slots values object truth value change Predicates strongly specified sort We binary distinction remaining sentences nonessential Backstroms opposed sentences distinction irreversible called static This predicates reversible sorts static course planning idea similar distinction identifiers types predicates called dynamic Lifschitzs essential Jonsson 301 atoms 381 It similar Which slots included predicate kinds goals degree determined objects solved required goal getting box1 box2 specified related predicate planner For example box1 box2 specific room boxes objects On hand goal predicate neardoor box1 door23 room2 includes door room specific placed The choice granularity target planning requirements predicate appears box dependent 24 Substates substate transitions step 4 The state space planning domain set valid combinations model occupy In nontrivial model situations size state choosing natural effective state decomposition complexity brought size managed effectively objects space astronomical ensure heart method Whereas classical planner state modelled predicate formula written set asserted predicates closed world assumption example TL McCluskey JM PorteousArtciul Intelligence 95 1997 l65 II onJEoor boxl room2 neardoor boxl door23 room2 closeddoor23 locked door23 onfloor harry room3 harry key3 objectcentred object identifiers substates A substate describes formulation planning state modelled mapping set ground dynamic predicates 3 situation dynamic object mapped For example partial state represented box1 H onJloor boxl room2 neardoor box1 door23 room2 door23 closed door23 locked door23 harry H onJloorharry room3 nextharry key3 I Hence state space described space mappings dynamic object identifiers valid substates Determination substate classes An object identifier mapped object member substate classes identified substate objects sort A substate class defined collection predicate expressions substate belongs The method class satisfies expressions arbitrary set ground predicates valid substate classes primitive sort follows designing represent 2 Each node susbstate classes abstract states 1 A substate class transition diagram nodes arcs drawn typical sort Nodes object arcs nodes represent ways abstract states sort change The choice nodes arcs determined examining verbs verb phrases natural sample diagrams domain configurations diagram substate class To modeller write conjunction true object occupies exclusively Consider necessary state object substate No dynamic predicates primarily ii resulting predicate expression Add static predicates valid consider typical object object Fig 3 annotated predicate objects dynamic expression corresponds language domain description ensure instantiation sort included domain predicates instantiations expression defining The principal role substate classes behave way state transition brought action They provide means checking validity state later provide basis generation useful macrooperators group substates help planning speedup 3 In Section 7 explain representation objects substate information naturally extended handle incomplete 12 TL McCluskey 04 PorteousArtijiciaI Intelligence 95 1997 I65 Fig 4 Substate class transition diagram sort Door Examples The substate class transition diagram annotating nodes expressions Fig 4 define sort Door R shown Fig 4 The substate classes fact door closed locked door represents predicate door object reflecting closed unlocked open unlocked implicitly open locked time Each nodes annotation necessary condition state wellformed substate satisfying transitions open unlocked state closed unlocked state model object sort Door exactly predicate expressions The arcs record state direct way change substate Door directly intermediate satisfied objects sort Door wellformed closed locked route recording For sort Box objects deemed floor Room Box Key near Door floor Room Door Box Key floor Room Box near Door Key floor Room Key Box near Door This gives nodes Box sort Fig 5 The cyclic arcs indicate change substate bindings predicate expressions box moved door room diagram write object Bx sort Box Rm Rml variables sort Room Bxl sort Box Dr sort Door The is_sort predicate sort subsort sort restrict variable nonprimitive substate class definitions transition diagram example indicate change From onJEoorBx Rm onoor Bx Rm near_door Bx Dr Rnz connect Rm Rml Dr onoor Bx Rm Bx KY Ky is_ofsort Key onJloorBx Rm Bx BAT Bxl isofsort Box Bx Bxl ZL McCluskey JM PorteousArtijicial Intelligence 95 I 997 165 13 We assume local closed world assumption dynamic predicates chosen box substate class definitions For example set asserted Bx object substate Here modeller following restrict values dynamic false box object occupying assumed static predicates sorts connect Room Room Door Obj Obj Obj ixofsort Sort An objects substate satisfies substate class definition dynamic predicates definition true unders caused match bindings static predicates substate matches definition evaluate 25 State invariant construction step 5 The stage engineering domain invariants axioms rigorously define state Invariants Informally true planning WARPLAN engineering ticular assumptions automatically They fall following classes 58 compilation tool construction modeller Using method consistency checking invariants exploited invariants specify conditions planning logical state invariants example aspects domain model In par validation maintenance explicitly acquired manually record expressions invariants set atomic l Positive includes definitions wellformed objects sorts substate classes fact positive invariants true planning instances true In context planning substates invariants necessary condition state This static predicates substate class state planning object identifier maps substate belonging false expressions includes true Explicitlydeclared negative instances static predicates planning state This invariants termed incon l Negative invariants implicitly category declared sistency constraints Examples invariants Positive atomic invariants given primarily list predicate instances change planning example connect room6 room5 door56 position light4 room4 door45 colour door47 blue instances static predicates guished static predicates true We met distin f is_ofsort obvious meaning For example negative invariant consider R valid state describing situation robot harry 14 TL McCluskey JM PorteousArtcial Intelligence 95 I 997 165 harry H onor h arty room3 nextharry box1 Hence substate box1 instantiation sets bindings object following static predicates Ky Bx satisfies associated dynamic predicates identifiers sort variables Dr Rml onJEoor buxl room3 onJEoor boxl room3 neardoorbox1 Dr room3 connects room3 Rml Dr onJEoor box1 room3 box1 KY Ky is_ofsort Key on_uor boxl ruom3 box1 Bx box1 Bx Bx isofsort Box words box1 substate robot hurry This summed generalised negative Room invariant 3A B E Movable_obj 3Rt R2 E Room onJloorARnextABon_fZoorBR2R R2 andor expressed positive invariant follows VA B E MovableiobjVR E Room A B onJEoor A R on_Joor B R Maintaining separate sets invariants positive negative way required tools use work efficiently As example invariant consider substate class sort Arm given expression arm_usedArm Robot Key part_ofRobot Arm DR possible If assumed planning allowed For example state containing invalid key held robot arm state different arms hold key substates following harrysarm H arm_used harryatm hurry key3 dicksarm armuseddicksarm dick key3 1 A negative key invariant sort Arm constraint arms hold 3A1 A2 E Arm 3R1 R2 E Robot 3K E Key arm_used Al RI K arm_used AZ R2 K Al AZ In concrete syntax later constraint written inconsistentxonstraintarm_used Al _ K arm_used AZ _ K Al Z AT TL McCluskey JM PorteousArtifcial Intelligence 95 1997 165 15 on_floorBxRm Node B on_floorBxRmnear_doorBxDrRm connectRmRmlDr on_floorBxRmnextBxBxl on_floorBxRmnextBxKy Fig 5 Substate class transition diagram sort BOX question important information domain modeller know specifying invariant An substate classes contains straightforward invariant specify abstracted states objects sort occupy However know criteria reached invariants tools described check compile level security model errors sort identified dynamic For positive negative invariants 26 Operator specification step 6 In natural properties domain possible language description DR verbs verb phrases suggest states sorts ways includes text Robots capable pushing objects doors state affect relationships states changed For example following doors objects suggesting movable objects dynamic possible ways changing sort We actions planning domain sorts model description domain transitions sorts The need operators step The node description Within framework actions represented schema called operators classical planning operators specified identified pre operator arc leads node suitable operator Fig 5 pushtodoor pre postconditions contrast terms substate transition diagrams postconditions selected label arc Node A Node B Clearly operators change diagram operator affect objects affected transition appear domain modeller needs consider objects involved prevail We operator arc Node B Node A pushthrudoor label label arc example sort substates objects object conditions initiate 16 TL McCluskey JM PorteousArcial Intelligence 95 1997 165 action pushing box door constructed representing sort Boxs transition diagram shown Fig 5 Each node represents substate class recorded Section 24 arc abstracted state transition Each operator designed recording 1 Prevail conditions conditions substates execute unchanged need true action 2 Necessary effects conditions substates need true action execute necessarily changed 3 Conditional efects conditions substates true action executes term condition changed The operator components predicate expression matches substate classes In operators definition expression sort applicable Hence precede conditional condition refers Box onJZoorBox Room21 hand satisfied box object nodes shown On Conditional equivalently wellformed transition diagram Necessary new substate affected object given unique substate class operator produces identifying ensure node output state Effects slots interpreted transition diagram Construction prevail conditions The operator Door called Doorl conditions transforms node A node B Fig 5 requires object sort open arm object robot called Arm pushing domain robot carry changed operator These conditions Door open Door unlocked Door Arm arm_emptyArml Robot part_ofRobotl Arml They specified effects preconditions operator appear Construction necessary effects The operator pushes Box Door changes substate Box satisfying near_door Box Dooq Room onoor Box Room connect Room Room2 Door1 substate onJloorBoxl Roomz TL McCluskey JM PorteousArtcial Intelligence 95 1997 165 17 Now actions affect objects door satisfying operator changes onJloor Robot Room1 nextRobotl Box substate certain ways Robot push Box substate Robot on_jloor Robot Roomz Robot Box Box is_ofsort Box Although scope sort variables global expressions examined restriction expression individually operator substate is_ofsort place needed 27 Construction conditional eflects There objects context change depending movable objects box pushed For object Obj current substate satisfies Obj Box1 onJloor Obj Room1 changes substate onoor Obj Room1 To systematically check conditional effects affected change objects objects This searching refer necessarily modeller decide substates constraints consulted effect modeller decides necessary recorded affected objects substate coexist substate necessarily transition graphs considering modeller considers dynamic affected nodes Boq Robot1 At state inconsistency planning prevail conditions help If possible object change substate Operator integrity The operator design encoded lists purpose input design reason properties concrete syntax add delete engine We use target planning particular ask operator state 1 consistentif resulting operator state wellformed applied wellformed planning operator applied wellformed planning state 2 deterministicif resulting properties state unique Both operator consistency consistency follow In section formally defining operators semantics operator states modeller prove way constructed wellformedness trivially fairly pushthrudoor operator 18 ZL McCluskey JM PorteousArtifcicrl Intelligence 95 I 997 l65 3 A formalisation objectcentred framework The result method section model M domain V composed sets production specification Sorts identifiers Objs l object l sort definitions l predicate definitions Prds l substate class expressions Exps l positive negative domain 0 operators Ops In section formalise invariants Znvs Invs previous described section precise useful properties domain models notation later sections introduced framework Some definitions objectcentred 31 Loosely SortAbstracted LSA models Our starting point declare mean sort Definition 1 A sort set object identifiers behaviours common set characteristics M denoting objects 2 share Objs union sorts M The characteristics behaviours operators associated sort Unless mean object word object sort modelled invariants identifier follows stated Definition 2 Sorts primitive nonprimitive Nonprimitive union objects defined sorts A sort primitive terms sorts sorts defined Each object member exactly primitive member sorts st s si supersort s2 viceversa Each argument element Prds predicates argument referring objects sort primitive nonprimitive sort object predefined M predicates A binding object Let Bindings denote sequences legal bindings object variables arguments predicates definition A object belongs grounding predicate formulae objects We define set possible ground predicates Prdso set legal groundings sort variable according binding sort variables predicate definition variable predicate identifiers legal Definition 3 The Positive Atomic taken Prdsc interpreted true M Invariant subset Invs members TL McCluskey JM PorteousArtijicial Intelligence 95 1997 165 19 All instances predicates appearing Positive Atomic interpreted example false R static ground predicate M form negative atomic connect rooml room6 doorl6 Invariant For invariant appear predicates Invariant positive kofsort invariants assumed member Invs Static Atomic defined explicitly The following definitions split model objects predicates affected operators unaffected Definition 4 A predicate Atomic Invariant Otherwise static instances declared considered dynamic predicate true Definition 5 A primitive M Otherwise static dynamic sort called static Objects dynamic objects deemed static change state sort called sort dynamic Below let SortsD Objs denote dynamic respectively We use phrase deemed objects sorts considered example declared Room dynamic depending atomic good candidates static sorts invariants dynamic objects Sorts objects cases sort names dynamic Definition 5 decision straightforward We R state room changing feature frequently basic terminology objects s E Sortso assume reviewed Having formalise substate chooses exclusive terminology object state refer given theirfirst argument For example members Prds chosen sorts predicates idea First modeller set dynamic predicate definitions Prds c Prds syntax elements Prds local state objects s earlier publications s owns Prds Further restrict sort Box primitive on_jloor Movubleobj Room neur_door Movableobj Door Room Movubleobj Movubfeobj argument predicate restricted members sort Box Definition 6 Let Prdsg set groundings o E Objs sort s set W c Prds describing o Prds A valid substute 2 referent situation predicate b predicate W deemed W Prds given 0 false interpretation true interpretation argument equal o deemed given D 20 ZL McCluskey JM PorteousArtijiciuI Intelligence 95 I 997 l65 Let Cjn denote conjunctions Prds They property follows predicates members satisfied subset Prdsc Definition 7 If W c Prdsc C E Cjn W satisfies C grounding C given LY E Bindings C WInvs C An important property member Cjn satisfy negative invariant Definition 8 For C E Cjn inconsistentC groundings C A E Invs C satisfies A true cy E Bindings In practice defines set possible class expressions Exps Elements substate composed dynamic predicates subclass Cjn called Cjrz This members important conjunctions static predicates interpreted local closed world assumption describing object o This means included Prds As constraint instances predicate expression substate false Exps substates dynamic object implicitly sort s defined taken Prds zero apply substate class expressions substate Prds describing o The models substate class expressions Exps segregated groups associated sort defined follows Definition 9 Exps valid set substate class expressions sort s valid substate objects sort s satisfies exactly member Exps b expression C Exps C grounding C bindings static predicates predicates form valid substate object sort s Y formulaes dynamic C true M remaining Adequacy substate descriptions sort formally requirements validity sets substate class expressions domain validated checked We process designing planning models state following abstraction We turn operators model sort substate classes main abstractions method sort employed Definition 10 An operator 0 0E 0P xC E Cjn 0E 0E xs E SortsoxCJ E Cjr schema having set pairs pair x components components OP 0 El xs E SortsD components sets member x having xC E Cjn In later sections simply liberty referring collection objects object variables names parameters These parameters preconditions set instantiation smallest operator operator chosen grounds 7X McCluske JM PorteousArtificial Intelligence 95 1997 l65 21 Drawing definitions important necessary condition model wellformedness Definition 11 LSA property A model M domain 2 loosely sort abstracted following restrictions components M true For Objs For object V needs represented exists unique object identifier b For Sorts Every object sort All sorts static Objs refers identifier objects Objs member exactly primitive dynamic deemed c For Prds Prds defined predicates argument refer exactly primitive nonprimitive identifier object sort d For Exps A set valid substate class expressions Exps constructed Definition 9 All dynamic predicates dynamic sort s according Prds appear substate class description define e For Invs The invariant truth values static predicates is_ofsort domain objects assumed distinguished f For Ops A set operators defined according Definition 10 The LSA model normally contain invariants specification Given somewhat open ended realistic application LSA property following central definition planning states represent changeable domain model Definition 12 Let Cjn represent set wellformed states LSA model M members CH grounded Then set total maps state I o sort s Io E Cjn satisfies exactly member Vo E Objs Exp conjunction rangeI I satisfies negative b range elements object domain invariants M 32 Operator complete models The operational semantics operator 0 given definitions Definition 13 0 applicable wellformed variables 0P 0E state I exists binding cx Vx E OP 30 E Objs sort xs Zo satisfies xX b Vx E OE 30 E Objs sort xs Io satisfies xCi operator applicable different objects depending chosen given binding state I objects necessarily affected Note binding determined 22 TL McCluskey JM PorteousArtificial Intelligetw 95 1997 l65 Definition 14 If 0 applicable new state OI b equal wellformed I following state 1 M binding given substate replacements member OE know Definition Iu 0 I xC xP satisfies XX Replace maplet 13 object o 0 H I o maplet set xCz static predicates removed b Let Objs dynamic objects unaffected Then Vx E OECVo E maplet set xC satisfies xCi binding maplet 3 replace XJ o I xP Io Objs CI I Iu static predicates removed These definitions operators Although defined operator applicability use explicit set preconditions useful function returns sequential extend naturally sequence appiicarion Definition 15 precons P XC x E 0E conjunction Ops Cjn function xC x E OP Q conjunction precons 0 P Q precans returns preconditions operator 0 follows 0 applicable state I mngeZ satisfies precons0 The applicative semantics operators wellformedness property states allows define notion consistency operators Definition 16 An operator 0 LSA model consistent false OS application state transforms members wellformed wellformed state assuming inclslstentprecons0 applicable state An operator set consistent Example The pushthrudoar operator defined Section 3 consistent The consistency definition operator applied case straightforward check state verify inconsistent openDoorl unlockedDoorl arm_emptyAnnl Robot partRobot1 Arm neardoor Box Door Room1 onoor Boxl Ruoml connect Room Room Door2 onx Robatl Room1 Roboti Box fulx The second generally struction check step process established systematic form check expression collection stated CHANGES TO specification substate class defini predicates possible output states resulting operation set negative invariants sure remain unsatisfied contains tions b check TL McCluskey JM PorteousArtcial Intelligence 95 1997 165 23 Name pushthrudoor Prevail conditions Door openDoorl Arm arm_empArm Necessary state changes unlockedDoorl Robot part_ofRobotj Arml Box near_door Box Door Room onoor Box Room connect Room 1 Room Door CHANGES TO onJloor Box Roomz Robot onoor Robot Room Robot Box CHANGES TO onJloor Robot Roomz Robot Box1 Box1 is_ofsort Box Conditional state changes Movableobj Obj Box onJloor Obj Room1 CHANGES TO onjloor Obj Rooml Fig 6 The operator pushthrudoor The expressions CHANGES TO onJIoorBoxl Roomz ooor Robot Roomg Robot Box Box isofsort Box on_Joor Obj Room1 The definition M straightforward verify equivalent exactly substate class definitions automated manner invariants From introduction new substates potentially definition operator application necessary zero changed substates depending conditional b We check satisfy negative output state changed condition effect Since selfconsistent Box1 Obj changed contain predicates appearing remain unsatisfied output state Assume left substate change input state wellformed know unaffected shows Robot inconsistency states Finally check invariants verify The definition operator application substates f Obf arising negative new substates conjunction possible substates resulting onoor Obj Room A search invariants reveal inconsistent_constraint onJZoor Obj Rm Obj Objl onJIoor Objl Rml Rm Rml 24 TL McCluskey JM PorteousArtificicl Intelligence 95 1997 165 constraint predicates satisfied operation pushthrudoor Fig 6 added shown affected operation To prevent relevant conditional effect Putting Definitions 11 16 gives standard planning models operator complete Definition 17 A domain model M operator complete LSA property M satisfies b c operator set M operator set M transitions dynamic predicate appears transition consistent complete relative dynamic sorts required operators diagrams represented effects operator The concept weakest precondition plan important knowledge compilation planning need following definition later sections Definition 18 Let Opsc define predicates weakest precondition function represent sequences ground operators sequence respect conjunction M We goal WP OpsG x Cjn CinG If OS sequentially smallest conjunction OS applicable wp OS G false wellformed applicable given state I rangeI state wp OS G satisfies wpOS G I produce new state range satisfies G Otherwise 33 Goal conditions Engineering domain models operator complete set literalbased model consisting pleteness gives level wellformedness allow conditions underspecific mentioned decomposed follows instantiated end Section 23 A tighter property objectcentred operators preconditions significant step away operators While operator com domain models allow substates predicates goal unique substate Definition 19 TSA property A domain model tightly sort abstracted operator complete b substate class expression consists exactly predicate The apparent advantage creating TSA model efficiencyhere conjunction domain ground predicates equivalent TSA goal predicates specify disjunctiue conjunction objects substates If goal terms TL McCluskey JM PorteousArtijicial Intelligence 95 I 997 165 25 object states On hand refining loose formulation flexibility TSA model loses original goal conjunctions map objects sets ofsubstates expressed sets literals explicitly disjunctive following nature goals literal set representing planning goal In classical expressiveness formulation We interpret goal conjunction showing conjunctive For example LSA model R consider neardoor tom door45 room4 box1 box2 open door1 2 onfloor tom room4 This tom boxl door12 translated substate expressions interpreted describing objects goal consisting conjunction substates dynamic slots predicates objects objects tom H onoor tom room4 neardoor tom door45 room4 door12 H closeddoorl2 unlockeddoorl2 closeddoorl2lockeddoorl2 box1 H on_oor b ox 1 roomlnextboxlbox2 onoor boxl room2 box1 box2 The negated goal evaluates negation This explicit single predicate disjunction box1 s goal state In follows assume literal sets use following LSA models set goal substates formulation literal goal correspond effect making contain implicit set object states planning goals input logical definition goal conditions Definition 20 The set wellformed goal conditions maps LSA model M set G Objs Cjnset member Cjnset wellformed state I E M tc E dom G Ic E Gc set substates sort exists Note goal G damG G damZ goals posed known objects We end section defining useful function achieve returns true goal condition met state Definition 21 For wellformed dc E damG achievelG w state I goal condition G LSA model M Zc E Gc 26 iL McCluske JM PorteousArtificial Intelligence 95 1997 l65 4 Tool support particular class architectures In section examine ability support major benefit formalising domain process tools Their use inter cycle Tools help degree crucial aspect main model classify planning verijcation 1 Tools use model construction maintenance modelsthe spersed validation categories Cutego clude dy Syntax sort crosschecking b Static analysis operators checking models components operators consistent namic goal predicates achievable MVP example planning tools test certain goals unachievable featuring c Graphical diagrams development consistency editing example operators The SOCAP transition features range knowledge type graphical operator editor performs 141 substate class checking operators construction tools including 191 d Partial construction operators tools software engineering diagrams similar 53 For example editor diagrams tool automatically kind methods modeller enter operator store featuring nodelink integration use graphical pre postconditions input format planner negative e Generating invariants operator definitions An early version features predicates positive negative effects operator work Dawson Siklossy incompatible deemed 181 sets assertions inconsistent appear planning random planning random wellformed f Generating defined amalgams substates satisfying domly generating problems Category 2 Tools primarily include form These problems operational systematic manner compiling planning states invariants obvious states sets goal formulation potential literals ran domain model efficient Section 41 macro generation b generation c abstraction hierarchy generation At present environment types goal orderings Section 42 example ALPINE 35361 contains number tools Category 1 b e f follows l A tool uses substate class definitions syntax domain achievable achievable check operator set check substates operator action help check operator set consistent l A tool identifies goals unachievable described type iii blocking given current operator set l A tool generates information domain ensure state invariants random planning problems substates descriptions generated problems valid particular domain states wellformed TL McCluskey JM PorteousArtijicid Intelligence 95 1997 l65 21 l A tool fects generates negative invariants static analysis operator ef automation I tools performed hand The function remaining Category In remainder section concentrate amenable category In Section 41 tools fall Category 2 planningspecific planning model introduce generating macro operators analysis Section 42 introduce method generating goal orderings The effectiveness tools dependent input operator complete model constructed systematic Section 2 method The premise form written operational naturalness readability twofold planning solutions b approach described tools compile domain models language designed presentation The function model improve engine marked adverse effect quality input model satisfy criteria compilation efficiency representation validate verify model 41 Macros planning compilation complete The overall effect macro creation produce stage set S partial solutions building blocks context solutions planning problems There obvious extremes l S In case planner macros uses basic operators building blocks l S set macros representing In kind problems mind generation solution planning problem set macros intractable A good set macros maintenance satisfies extremes Given domain model macro set performance exhaustive falls planner technique macro generation predicted consideration 1 likelihood following factors planning problem processing cost searching cost terms solution nonoptimality cost generating maintaining search like set macros selection 2 3 4 5 We set means cost related I processing points minimised extreme S exhaustive applicable total Unfortunately prohibitive As example assume planner previously Then high 4 5 Unless problem generation factors l5 trivial domain models strategy storing solutions 2 low 3 1 likely easy macro macro set technique terms search space cut For example probability scored highly taking macro cost 3 5 solve random problems solved problems initially receives strong bias low Finding good tradeoff macro cuts applicable macro planning macro usable step solving given 28 TL McCluskey JM PorteousArtijiciaI Intelligence 95 I 997 165 Work macro creation pioneered Korf encodings number macros work cited assumed propositional feature vectors propositions Korf gave explicit properties display time required problem subgoals l5 instance worst case solution length problem problem optimal macros generate times 371 domains states modelled macro sets order solving solution These criteria implicit equal number small fraction number possible states The regularity Korfs domains operator decomposabilityhis state If replace operators expressed dissimilar phrase component 37 p 591 The regularity effects individual operator complete encoding component state independent mean slot feature vector substate effect operator state domains decomposed relied macro components state technique Korfs work sense claim terms effect substate classes Further operator posed planning domain expressed LSA implies terms initial state goal condition require manipulation instances dynamic objects change substates objects Now planning domain model engineered LSA predefined This means problem substates class classes substates object dynamic sort features substate initial state goal grounding defined problem objects sort occupy domain manipulation decomposable planning refers For pair substate classes object sort produce macro problem generalised performed dynamic space possible pairs generalised given description generalised represents abstract plan solving represented generalised pair This macro production start end situation sort domain model way spans In summary objects substate ground instance sorts substate classes aim generate macro set exhaustive respect transition providing subtasks involving solutions start end situations object 411 Macro generation techniques Let consider substate classes sort Box explore possible macros generation techniques onoorBx Rml onoor Bx Rmz Bx Bxl Bxl is_ofsort Box Such pair substate classes macro abstract plan initial substate second transporting generalised goal room putting box room spans substates abstract problem box assuming called task conjiguration Generating TL McCluskey JM PorieousArtijicial Intelligence 95 1997 165 29 sort abstracted task R model consist room A solution series operators Robot Rbl successively series Rooms Rml Rm2 connected doors Drl Dr2 operators pushes Box Box Bx pushtodoor pushthrudoor follows operator pushnext This represented Box Bx pushes pushtodoor Rbl Bx Drl Rml pushthrudoor Rbl Bx Drl Rmz pushnext Rbl Bx BXI 1 abstract solution consists sequence pushthrudoor denoted notation pushtodoor pushnext There number conditions abstract macros chiefly join preconditions object sequence effective operator satisfy change postconditions 0 1 applications followed application sort abstracted state successor specified 48 401 concentrated initial work applicable Our macrosthat task configuration The diagrams Being general relatively small On hand adding processing overhead endangered iterative property arose cycles total number generated compile macros unwound utility generating fully generalised instantiations iterative sort parameters transition time plantime The opposite end scale generate macros pair substates configurationthat abstract interested ground task configuration abstract 4 plans ground task classes sort This possible plans substates sort An example generated R generating macro on_oor box1 room 1 g nextbox1 box3 on_jioor box1 room4 pushtodoor harry box1 door1 2 room1 pushthrudoor harry box1 door1 2 room2 pushtodoor harry box1 door24 room2 pushthrudoorf harry box1 door24 room4 pushnextharry box1 box3 Both approaches disadvantages macros plantime consumes online prove prohibitive interested generation predicates fully generalised resources compilation fully ground macros storage maintenance Hence macro basis came difference static dynamic define planning domain model terms computation useful mid point use abstraction unwinding finding We observed domains planning repeated sequences operators literature solution plans iterated static relationships tend By abstract mean suppresses details dynamic sorts 30 TL McCluskey JM PorteousAriiiciaI Intelligence 95 I 997 l65 relationship require moving In R planning problems adjacent doors rooms connected explore binding variables determined domain Box Key series Room Door Rooms Doors unchangingly Our strategy substates value variables generalised Then runtime intuitive example processing consider set paths abstraction compile pushed instance sort Robot These paths unchanging appropriate instances sort Robot different slots leave input planning problem For R level instance sort Box doors rooms runtime need looked instantiated interconnected values dependent actual uniquely static relationships variables instantiated instances Box Robot generalised operator situation The idea embodied second successful macro generation algorithm described Section 5 operator complete index substates shown macro I initialises set Ops operators Fig 7 experiments accepts input components The algorithm Generatemacros model builds macro iterates dynamic pairs generalised produce set sort abstracted operatorsthe affect objects sort s The resulting operators components prefixed sort s Step 5 iterates task configuration producing generalised task configuration In step 6 planner table Step table Step 2 sort model Step 3 calls procedure returns going reduced gathers removed task configurations macros Step 4 calls procedure produce abstract static predicates dynamic predicates owned sort necessary described abstract plans task configuration step 61 searches plan space containing s b grounds Step 62 generalises technique instances sorts unified variables variables execution carefully generalised task configuration typical abstract plan similar operators preconditions final plan table step 7 indexed lines standard explanationbased 45 weakest precondition reduced removing abstract plan step 6 storing instances sorts Section 54 assembled plans Returning example generalised task configuration onoorBx rooml nextBx Bxz onJloorBxl room4 Bxl Bxz explanationbased generalisation solution pushtodoorRbBxdoorl2rooml pushthrudoor Rbl Bxl door12 room2 pushtodoor Rbl Bx door24 room2 pushthrudoor Rbl Bxl door24 room4 pushnext Rbl Bxl Bx2 TL McCluskey JM PorteousArtijicial Intelligence 95 1997 I65 31 algorithm Generatemacros In Operator complete model M Sorts Objs Prds Exps Invs Ops Out MT macro table s Sortso generate_task_configs Exps TC abstract s Ops 0s pair ig Tc 1 MT 2 3 4 5 6 produce_generalisedplansi g 09 GP MTMTu igGP end end 7 8 9 end procedure generate_task_corgs 31 in9 j 1 j E Exps inconsistent j Exps outTC false Y binding static variables j 32 TC g 1 E end procedure g E f g procedure abstract s Ops 0s 41 Ops_reduced 0 42 0s 0 E Ops 3x E 0E 0 E Ops_reduced 0 0 components referring xs s sort s removed end procedure procedure produce_generalisedplans 61 P p 1 p E Opsk fixed grounding p optimal solution g initial state g Ops GP cy g 62 GP Gp wppg end procedure 1 p E P G EBG operator Fig 7 Outline algorithm macro generation 42 Generation goal orders The main function goal ordering stage produce range goal5 choices planner step planning goal ordering domain encoding thesis useful shall later The work originates 48 influenced work 131836 techniques spotting possible problems rules cut algorithm Porteouss 5 Although goal potentially mean literal substate section discussion general level literals 32 TL McCluskey JM PorteousArtijicial Intelligence 95 1997 l65 pq_ pq ___ __ pq t 0 P2 I I I P5 0 I I p6 0 I I I v 0 PI ti t I I I t P3 0 pq ____I 0 P4 Fig 8 The goal establishment diagram ground literals goals individual establish conjunctive Static analysis inherent goai structure models reveal heuristic definite goal planning goal structure model analysing pairs literals map set possible ways goal pair formulate lead blocks nodes order goals planning tool called section ends outline algorithm illustrative orders problems We examine approach established general conditions Some conditions PRECEDE examples identified implemented goal establishment diagram This diagram 421 Goal establishment In addition notation introduced Section 3 assume existence following functions Definition 22 establishes A p unique general binding A makes pa true true operator A establishes literal p For example R establishespushnext Rbl xl Bx 60x1 box3 True cy boxf Bx box3Bx Definition 23 For operator A literal 4 clobbers A q clobbers qa makes LY E Bindings false true A Note assume possible true assignment evaluate ground operator A ground predicate p Definitions 15 18 22 derive establishesAp A p If establishes Ap clobbersAp TL McCluskey JM PorreousArtijicial Intelligence 95 1997 l65 33 preconsA wp Ap As framework static analysis literals x y assume A node marked xy identifies ground P6 nodes represent states identified separate nodes We define valid link follows goal establishment set wellformed set nonempty valid links sequences diagram Fig 8 states satisfy labelled Pl links operators nodes Definition 24 A valid link X lishment diagram sequence grounded operators distinct nodes Nt N2 goal estab l operator X changes truth value literals Nt l inconsistent wp X NzNf false The effect condition goal establishment nodes viable plan follows sequentially If sequence X forms valid link wellformed produce state asserts N2 diagram The second ensures sure valid link link form goal sets Nt N2 state contains NI X applied There possible acyclic paths state asserting asserting p q The defined node sequences p 4 state 1 2 Ip PV P41 P43 P41 PY sequence p established involving operator affects truth values p q q The odd paths 3 4 5 pv LP 4 PW P41 P4 PV P 4 p 4 p 41 P41 For example problem solution path 3 consider filling fixed container q container identified movable sequence actions corresponds problem jug equal volume Letting p jug path 3 lfill jug tapJill container jugJill jug tap 422 Identifying blocked links For goal sets certain paths unavailable blocked nodes satisfy establishment We define path diagram operator set provide way changing states use goal blocked paths goal sets thrust analysis reason necessarily link nodes The main nodes NI N2 necessarily blocked follows 34 TL McCluskey JM PrrteousArtifcial Intelligence 95 1997 165 Definition 25 A path necessarily blocked nodes Nt N2 goal establishment iff exists valid sequence operators diagram linking Nt Nz From Fig 8 identify distinct types blocking wq p q including l type link blocked PI equivalently P4 l type ii link blocked P2 equivalently P3 sequences valid links l type iii joining q pq example P 1 P4 P5 blocked P2 P3 P5 blocked PI P2 blocked We formulate type ii rules ordering goals planning type iii debugging consolidating domain models Type A computable condition operator A E Ops establishes p precondition formalised Definitions blocked path Pl q E Prds A changes follows given truth value p This condition A inconsistent conjoined 8 15 22 23 follows Let cz E Bindings VA E Ops establishes A q clobbers A p V inconsistentprecons A p il Theorem necessav szcient condition Pl blocked selfevidentif nodes Nt p wq N2 pq Proof Sketch That sufficient condition possible p true q false To prove link false obtain contradiction false case execute establisher A establish q state necessary condition assume blocked condition Y preconsAp Given substitution clobber p Let choose A form sequence I We forms valid link Nt N2 follows operator X changes case exists establisher A q A necessarily grounding firstly Nt Secondly value literals X A consistent JPXNNI vWlnWv Now observation Definition 23 fact establishesApq preconsA wpAnpllq wpAplpqpqpreconsAnppNq Now given preconsAp consistent follows preconsAppNq IYL McCluskey JM PorteousArtcial Intelligence 95 I 997 l65 35 A establisher 9 Hence wpX N2 Ni valid grounded sequence connecting Nt N2 This gives consistent required consistent A61 contradiction Type ii This arises block condition P3 functions defined Y 3 E Bindings follows In case form necessary path blocked position P2 similarly sufficient VA E Ops establishesAp establishes Ap q V inconsistentprecons A q Condition corresponds corresponds ii seen dual il The disjunctive taking block P2 path P5 straight main goal ii clause second possible Type iii This arises goal problem initial state example Pl P4 P5 blocked We major help pair p q operationally domain debugging way specification The pair added form lead bugs discovered software rerun addition inconsistency inconsistent We specifications solve conjunctive compilation pairs discovered consolidating constraints 423 Lifting analysis So far analysed domain model assuming nodes identified ground dynamic predicate instances regularity brought objectcentred approachthat literals In R3 1000 contingent lo6 pairs Using objects sort behave level ground dynamic predicate structures literal waywe shall lift level sort variable resulting 400 comparisons analysis In R3 20 Definition 24 extended defining node xy x y lifted pred sense join identified original satisfies xy wellformed states I rangeI states Blocked paths defined Y E Bindings Valid links remain unchanged When p q sorts common lifted nodes valid icates identifying grounding links way p q sorts common 6 conditions ii useful distinction prevented STATIC possible codesignation SO example Bxj variables sort Box Rmi Rmi sort Room Dr sort Door considered sorts instance following sort variables codesignate codesignating As observed 47 comparing series experiments p onjloor Bxi Rmi q near_doorBxj Dr Rmj pairs predicates means different predicates considered relations codesignation uninstantiated BXi constraints h Two liter sort common liter argument sort 36 ZL McCluskey JM PorteousArtificial Intelligence 95 I 997 165 Bxi Bxj A Rmi Rmj Bxi Bx A Rmi Rm Bxi Bxj A Rmi Rm Bxi f Bi A Rmi f Rmj The number constraints large slots shared theoretical limit pairs ground predicates experiments total number 424 Use goal orders The results goal analysis different ways depending type Here examples use planning totalorder goal directed planner architecture Use type orders establish goal set containing false type block planning When totalorder goal directed planner goal p q state conjunctive PI shown Fig 8 gives rule Rule Establish q establish p advanced state containing q conditions effort looking This saves planning line use goal analysis compilation solutions use rule forms empirically 40481 domains possibility achieving q avoids inconsistent executed phase We rule helps optimality type backbone earlier work PRECEDE speed different Section 5 supplies empirical evidence validated producing planning Determination Use type ii orders block P2 Fig 8 rule guiding planning false follows planning When wff ii true type ii establish p q state Rule ii Establish p goal directed fashion plan achieving p establish q Consider goals p Bxl Bxz q Rb Bx R example domain robot binding Bxl Bx3 These predicates display type ii relationship point making q true binding constraint To establish predicates RI form plan aimed nextBxl Bx2 impossible establish p sufficient constraint 425 Outline algorithm Fig 9 shows outline algorithm components input definitions binding constraints It outputs appropriate generating goal orders generating operator complete domain model goal orders The algorithm refer takes Section 3 orders sets orders pairs predicates resulting type ZL h4cCluskey JM PorteousArtijicial Intelligence 95 1997 l65 37 algorithm OrderGoals In Operator complete model M Sorts Objs Prds Exps Invs Ops Out ODS Goal Orders CYC Cyclic Goal Orders CYC 1 E PrdsD 1 E Prdso codesignation 1 I B C B 1 ODS 2 3 4 5 6 7 8 9 10 11 12 13 14 15 end end end end end Ops 0 VA E Ops clobbers A 1 constraints C 0 E Ops establishes O 1 inconsistentprecons A 1 C order I 1 C ODS ODSODSuZlC CYCCYCUllC end ODSODSllC Fig 9 Outline algorithm generating goal orders step 4 For different dynamic predicate type iii blocks The algorithm steps dynamic steps 23 This pair constraints If variables set codesignation cyclical orders representing predicate compares lifted step set codesignation variables sort predicates sort common constraints C steps 610 constraints literal operationalise check operators clobber 1 1 constructed inconsistent I context constraints C If case preconditions order 1 I C establishers In step 9 orders added output ODS appropriate identified Type iii orders generated discovering 1 l C I 1 C This cycle added CYC order I 1 C removed ODS 1 clobber 1 inconsistent il Firstly set operators orders predicates set codesignation establish preconditions condition 426 Possible goal orderings The analysis goal establishment diagram extended natural way techniques based possible orderings model based possible orderings pairs literals p q follows establishment goal directed affect truth value q given risk possibly q established p planner search 481 These techniques p ABGEN 38 iL McCluskey JM PorteousArtcial Intelligence 95 1997 l65 goal violation This kind heuristic originally Knoblock planningq establishment 361 abstraction Consider space space valid paths generated hierarchical p p safely left lower level higher level abstraction case appear state containing states satisfying establish p q paths traverse assert heuristic violated p established We return Section 533 pq q established p P4 goal directed search Fig 8 If nolze diagram risk nodes use possible orderings 5 Evaluation method similar test domain PRODIGY specifications include R introduced The method construct objectcentred familiar novel These 501 STRIPSworlds planning domains paper Russells Tyre World world tools presented models explored present models planning results activities demonstrate number planning domains Not surprisingly devote space results dynamic tests compiled domain models account benefits use development method small set test domains range earlier scheduling Section 4 help acquire validate compile engines The purpose section benefits use method effect planner performance 341 We domain 491 warehouse world tends anecdotal operationalised 5 11 jobshop As guide organisation In Section 54 evaluate domains methods use initially encoding goal orders results random planning finally software implemented CPU measures taken configuration Section 55 summarise tests compiled section testing models compiling follows In Sections 52 53 evaluate Section 51 introduce produce macros configurations analysing method empirically uncompiled benefits method Note Quintus Prolog running Sun IPX workstation 51 The test domains The complex test domain illustrated Fig 3 The complex domain DR3 World domain described domain interactions Tyre World 50 concerns automobile The central problem domain typically orders permit goal remaining goals established These domains contrast respect interactions terms structure number distinct actions Section 2 n 3 state terms goal ordering repair actions wheel changing 31 goal R3 Tyre World abounds potential goal interactions termed laboriously serialisable preserved whilst established formulated TL McCluskey JM PorteousArtijicial Intelligence 95 1997 I65 39 relatively structure goals interacting familiar STRIPSworld low significant Tyre World static predicates R3 In World probability respect contrast variant Sacerdotis STRIPSworld 10 doors robot boxes The example domain test PRODIGY complications moved robot unlock 5 11 consists 7 rooms connected capable opening doors moving 3 different elaboration 6 room STRIPSworld adapted number domain doors locked unlocked keys lie domains Extended STRIPSworld 9 It introduces extremes invariants locked doors The 52 Initial construction qf domain models Construction steps described partial description engineering simple conditional state dynamic syntactic testing operator Section 2 complete models involved looping times Old literalbased domains extent encoding specifications resembled methods gave reverse omission task The tool support revealed errors initial encoding errors shown predicate crosschecking effects shown checking input consistent operators produce consistent state Often errors hard spot For example R3 carrying step 5 help tool e category 1 cf constraints Use goal order generation led discovery new constraints Section 4 resulted 55 inconsistency tool step 7 method subsequently production cyclic orders encoding operator set Inclusion new constraints appropriate model settled final figure 80 end step 7 led cyclic orders output goal order generation debugged operators indicated lack constraint omission tooland inconsistent tests described impossible goal sets Nevertheless invariants built step 5 eliminated Analysis random domain models showed potentially dynamic tasks randomly invariants 54 impossible problems initially tasks generated tool f category 1 cf Section 4 great invariants 100 hardest 12 In batch 100 generated use later section incomplete R set called RDM7 Tyre World 15 inconsistency impossible example As problems generated supplied constraints The following constraints immediately apparent inconsistentzonstraint loose Nuts Hub tight Nuts Hub inconsistentLonstraint wheel_in Wheel Hub wheel_on Wheel Hub constraints pair given inconsistent_constraint havenuts Nuts tight Nuts Hub inconsistent_constraintCfree Hub loose Nuts Hub 40 ZL McCluskey JM PorteousArtciai Intelligence 95 1997 I65 Table 1 Size domain models sort abstracted components Model Objs Sorts Prds fiPS hVS OPS RY Tyre Extended STRIPS STRIPS 41 8 19 21 8 7 6 4 27 22 22 II 20 20 18 8 204 36 150 106 25 17 19 8 obvious revealed help type iii blocks identified goal order generation constraints cf Section 42 In final model 27 inconsistency To feel size domain model indicate number elements model Table 1 As tool support available components use sort hierarchy Thus time models built tested sorts primitive predicates slots restricted primitive sort Use sort hierarchy mechanism components number ground elements components compact affecting number ground elements table approximate instances For R3 especially larger figures region 1000 operator conditional variations dependent 1700 The total size state space large difficult 87 distinct number possible component size PrdsG 4500 fact consider substates sort Box given box 6 boxes states box objects order 876 presence state invariants Consider effects number distinct calculate accurately domain substates 53 Compilation domain models sense The size sets set macros necessary times shown Table 3 As predicted All domain models compiled possible goal orders generated approximate generation tools beneficial indicating results choice models components dynamic One design choices based example utility macro set generated detecting bugs domain encodings sorts predicates Section 54 Additionally stage useful plan generation new invariants delivering speedup evaluating demonstrated utility static number use compilation tightening encodings 531 Construction macro tables Using notation introduced algorithm Fig 7 number entries macro table bounded following formulae T insj TL McCluskey JM PorreousArrifcial Intelligence 95 1997 l65 41 Table 2 An indication space complexity macro table K constant Model feature increases Number dynamic objects Number dynamic Number substate classes Number static objects sorts Table 3 Compilation results Generation Macros Necessary orders Possible orders Effect size macro table stays constant increases bounded K x lSortsol increases bounded K x IJJs increases polynomially Model R Tyre Extended STRIPS STRIPS R3 Tyre Extended STRIPS STRIPS Rj Tyre Extended STRIPS STRIPS Number 2385 32 1926 824 98 30 105 18 56 23 65 19 CPU time hours minutes seconds partially instantiating circumvents number entries result point critique Universal Plans built sort macros indexed according planning derived algorithmic description order square number elements substate classes static objects The crucial Ginsbergs bottleneck noticed table substates object state The theoretical growth macros model size exponential approach leads separate macro summarised Table 2 271 sample worlds summarised total number macros generated facts wheell The results macro compilation Table 3 The number given model The Tyre World static predicates apart standard potential macro generation choice substate classes Where solution validate problem fails macro generation process goal throws doubt choice substate class expressions use planning domains speedup is_of_sort wheel macro set small Tyre World helps clarify goal structure low It stressed sortabstracted planning uncovers unreachable typing information time taken The maximum macro generation phase R3 took hours This figure acceptable seen context overall need performed time changed involves On hand potential complexity problems macro generation domain model compilation taken domain occasionally domain model captured create 42 ZL McCluskey JM PorteousArtificial Intelligence 95 1997 l65 exponential The central point search details space suppresses search consequently occurs dynamic sortabstracted sorts Another potential problem inherently planning store generalised distinct macros intractable task configuration allowed shortest solutions Recognising allow planner possible plan recourse indexed task configuration Given solution including tests revealed question algorithm offers heuristic coverage fail fit rest macro generation nonoptimal macros macro retrieved produce required original operator set locally nonoptimal macro 532 Generation necessav goal orderings Of compilation computational Fig 9 number goal orders compiled assessment potential utility goal orders planning performance complexity algorithm Let N number dynamic predicates grounded dynamic predicates Then c number comparisons Fig 9 bounded follows domain model M number algorithm NN 1 c MM 1 In practice c turns nearer N2 M2 This illustrated Section 423 gives 4 comparisons number constraints grounded comparisons 600 example number The dominating component comparison inconsistency implementation tent function Checking general form examples tool PRECEDE bedded check operator consistency The tractability executing paper In practice state invariants specified constraints inconsistent limited function inconsistency firstorder em evaluation inconsis theory course undecidable inconsistentprecons A operator A model operator consistency domain model On hand suggest execution evaluate modeller time indicate established condition false If computationally prohibitive early stage need redesign execution time acceptable inconsistentprecons A p heart PRECEDE acceptable test results The summarised generated order minutes Table 3 The number phase tool generate necessary goal orders total number goal orders taken note difference generation number time maximum It interesting PRECEDE 7IL McCluskey JM PorteousArtcial Intelligence 95 1997 l65 Fig 10 Graph type goal orders Tyre World necessary goal orders models For extended STRIPSworld higher degree interaction number goal orders domain increases 3 robots greatly possible ground establishers goal explains goal orderings In R3 introduction model identified reflects relatively large goals average number lower number necessary As predicted utility PRECEDE goal orders expect impact size extended orders generated goal orderings domain model Hence expect STRIPSworld domain R3 effect planning performance number orders identified orders generated related relative Example The declarative specification main problem conjunction set representing predicate goals following Tyre World posed closed boot jack_injack boot1 pumpinpump boot wheel_in wheel boot wrench4 wrench 1 boot1 wheel_on wheelz hub tighf nutsI hub inJated wheel2 paraphrased initial state asserts boot appropriate tools boot The operators wheel changed jacking wheel unbolting replace jat tyre car tools away wheel1 flat tyre hubl applications mode1 allow wheel nuts The PRECEDE pairs predicates bindings shown abstractly Fig 10 Each arrow corresponds Section 42 details variable type order Type orders tool generated 30 type orders defined 44 7 L McCluskey JM PorteousArtijiciul Inteliigence 95 I 997 l65 If goal 6 c solve goal u c subgoal solved strictly associative case sequence set predicates subset established subset resulting predicates Using orders reduce sense b b c necessarily solution total When applied solution complement clobber solved goals order subsequent advanced set subset predicates state necessarily ordering diagram orders reduce wheel_in wheel boot1 wheel_on wheel hub1 injkzted wheez The necessary orders planning node order goal establishment fashion The diagram provides opportunity check goal structure validity operators tion inflating tyre putting valid constraint orders generated For example precondi hub operators 533 Generation possible goal orderings ABGEN implementation Section 42 We included based ALPINE algorithm presented 35361 interactions goals ABGEN generates goal orders basis possible described necessary orders choosing goal establish planning given set goal predicates necessary orders reduce goal choice removing goals establishment undone goals establishment shown Tyre World example Possible orders reduced goal set limit choice Any predicates establishment possibly clobber goal reduced conjunction goal set The number possible orders produced ABGEN removed tool tests domain models shown Table 3 tests complements 54 Using domain models planning 541 The FMD planner The planner constructed planner use goal orderings macros sort information goal conjunctions dynamically test domain models goal directed FMD solve planning FMD reason test models Our rationale relative plan speed solution construction performance main serialisable dynamically called FMD Assuming trading optimality good planning totalorder synthesises problem By effectively planner demonstrates selected generation planner performance viz planner overlong solution model We equally selected planning examples discussed difficulty interacting Further predicted efficiency provide good test effect domain compilation totalorder produce sequences ameliorated use processed domain test platform disadvantages tendency goals solving algorithms Section 75 FMD works goals independently advancing plan state partial solutions For simplicity start describing outline version FMD shown TL McCluskey JM PorteousArtijicial Intelligence 95 1997 165 45 workings planner Fig 11 To illustrate benefits combined use goal ordering typical planning node input compiled operator complete domain model initial wellformed represented partial mapping object identifiers rules macros consider FMDs behaviour state goal condition sets substates searches The algorithm space open nodes node form nodeNAIGOSP fields N identifier A parents condition OS partial solution P nodes purpose preconditions The partial solution slot contains initial state produce nodes operator sequence nodes current state I node established solve invariably identifier I current state G current goal macro operator purpose node applied planners Step 1 initialises matching process set open closed nodes sorting predefined partial order The predicates orderings goal predicates generated solved process substate gs picked Using ODS step 5 Fig 1 I compilation member set substates mapped range goal condition G This process gss selection corresponds ground table operation linear lead increase instantiated member M applicable establish steps 8 et al If node time complexity complexity ground macros picked current state solves index matches I gs object c search space gs cheap In step 6 entry macro lookup way way set M according goal node If I new nodes created fashion member M backchaining retrieved This process weakest preconditions order A macro operator applied straightforward computationally matching rangeG simple retrieved goal G steps 19 20 Ns parents current state followed purpose open macro Then parent node reasserted solution OS applied nodes existence typically node step 21 ancestors closed outline design In addition algorithm elaborated important extensions l Firstly contained loops admissible heuristic loop detection planner able check developing plan OS node checking ancestry new node appropriate head tail plan checking action l In step 6 FMD uses Ops MT resorts normal operator backchain uncompiled ii substates ing cases Gc Z gs range c disjunction MT case M l In step 20 combined application P OS fail goal violationsa problem deal solution developed acute FMD input uncompiled model detect solutions benefit goal orders The planner equipped clobbered protected goals allowing sequences different orderings conjunctive goals 46 TL McCluskey JM PorteousArtificial Intelligence 95 1997 l65 algorithm FMD state M In Operator complete model M Sorts Objs Prds Exps Invs Ops hit wellformed Goal wellformed MT macro ODS set goal orders M Out SOLN Operator sequence goal condition table M M 1 ONodes node root null Init Goal 1 null CNodes 2 Remove node N A I G OS P ONodes 3 4 5 substate gs ODS gs E Gc root yachieve I G lachieve I G Determine N f 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 c E Objs Ic Gc Pick m MT fc CY E Bindings gs satisfies index m M mp 1 j3 E Bindings grounding m exists m E M applicable ladvanced Apply mR I ONodes I ONodes U node N Aladvanced G OS m P CNodes mK E M CNodes U node N A I G OS P Wp weakest precondition Oflodes O_Nodes U nodeNew N I Wp 1 m component m end end Retrieve node A Ap Ip Gp OSp Pp CNodes IpAdvanced Apply P Apply OS Zp ONodes ONodes u node A Ap IpAdvanced Gp OSp OS P Pp Move nodes ancestor A OiVodes CNodes end Choose remove node N A I G OS P OYVodes 22 23 24 25 end 26 SOLN OS end Fig I I Outline algorithm FMD TL McCluskey JM PorteousArtijicial Intelligence 95 I 997 l65 47 Finally variations FMD created adjusting choice strategy step 24 The variations called HS DS BS defined follows l HS heuristic following heuristic planning candidate expand single goal partial solution nodes breadthfirst expansion search favour search strategy nodes evaluate open nodes default l DS depthfirst l BS breadthfirst search strategy search strategy Example Assume use FMD compiled condition G sets possible substates Assuming G input literalbased goal form R3 consider objects box2 tom harry door45 form follows mapping onoor harry rooml on_joor box2 room5 tom key2 neardoor box2 door56 room5 lockeddoor45 goal orders ODS identify onfloor predicate c box2 domain element G That solved Gbox2 oor _ji b 2 ox room5 near_door box2 door56 room5 gs onoor box2 room5 neardoor box2 door56 room5 As Gc singleton step retrieve entry macro table index matches I box2 8s Assuming Ibox2 on_JEoorbox2rooml entry retrieved macro table instantiated instance box2 pushtodoor Robot box2 door12 room1 pushthrudoor Robot box2 door12 rooml room2 pushtodoor Robot box2 door25 room2 pushthrudoor Robot box2 door25 room2 room5 pushtodoor Robot box2 door56 room5 If macros preconditions applied new nodes created satisfied I value parameter Robot recursively establish search space Overall FMDs use goal ordering reduced use macros cutting search sets goal operator backchaining main goal macros preconditions Use macros predicates cheap size macro tables goal orderings node computationally goal ordering sets grow unmanageable rise numbers sorts dynamic objects Hence speedup suffer utility problem described rules linearising 431 48 TL McCluskey JM PorteousArtcial Intelligence 95 1997 165 compiled HS compiled DS compiled BS ________ uncompiled HS _______N_ uncompiled DS ___ uncompiled BS Fig 12 Legend results graphs 542 Planning conjiguration Twentyfour planning configurations constructed bolting domain compiled uncompiled R3 Tyre STRIPS extended STRIPS models form different variations FMD planner BS The compiled necessary possible goal orders HS DS forms use previously generated macros random problems split To test configurations generated thousand problems follows l For R3 extended STRIPSworld STRIPSworld generated divisions problems called RDM3 RDMS RDM7 RDM7 model contained generated 7 randomly consisting positive ground likewise goal literal sets size 5 3 respectively For example problem goal set 36 RDM7 R3 state goal set containing literals RDM5 RDM3 formed initial key_onJoorkeyl room7statuslight3 room3on unlockeddoor35 robotin tom room3 key_being_held key3 harry room4 keynext_key key1 key5 boxnear_door box1 door23 room3 corresponds achieving goal states objects keyl light3door35 tom key3 boxl As previously mentioned names arc elaborate previous examples R tests encoded use sort hierarchy predicate TL McCluskey JM PorteousArtijicial Intelligence 95 1997 165 49 Table 4 Solution STRIPS Extended STRIPS RT Tyre length Len averaged number successes WC set resource limit DS BS HS camp uncmp camp uncmp camp uncmp len 19 32 42 22 34 49 32 49 61 21 sue len sue len sue len WC len WC len sue 100 100 100 100 91 96 9s 74 51 100 36 64 76 36 55 76 41 64 85 33 99 100 94 99 92 86 38 13 s 100 19 29 36 20 31 42 22 33 46 21 100 100 100 100 98 98 91 61 46 100 21 28 3s 22 32 44 II 21 29 31 100 88 82 9s 81 72 35 9 3 100 19 29 35 20 35 42 23 36 46 21 100 100 100 100 99 98 92 66 49 100 20 31 38 23 34 46 18 29 34 31 100 100 97 98 88 81 57 17 8 100 RDM3 RDMS RDMI RDM3 RDMS RDMI RDM3 RDMS RDM7 l referred door35 locked wellformed literal set unlock problem impossible light3 key3 boxl particular doors allowed goal set unique goal substate tom satisfied range models initial states randomly generated reduced door This tasks example key Some objects keyl substates Initial states goal sets generated state invariants Further state space goals corresponding attempt overcome locked away room required inaccessibly For Tyre World test file generated consisting 100 random permutations 8 goal predicates described Section 53 The initial state flat tyre case kept fixed The results experimental separate figure representing seconds plans created steps 13l 6 FMD algorithm world extended STRIPSworld represent results different Tyre World graph contains tigure problem consisting 100 random permutations lines plot continuous versions domain model shown legend Figs 1320 For domain terms CPU number nodes number new partial Fig 11 For STRIPS R3 worlds figure contains 3 graphs labelled RDM3 RDMS RDM7 For sample called RDM8 problem given Within graph different terms CPU nodes shown legend taken generate correct solution results Fig 12 tests summarised results measured random problem dashed samples Table 4 summarises average solution limit 60 CPU seconds 120 CPU seconds R3 Note number average problems actually solved tend shorter solution Thus R 100 effect reducing length problems uncompiled length solutions significantly solved configurations solution resource problems solved length average small simpler problems solved TL McCluskey JM PorreousArtcial Intelligence 95 1997 l65 RDM3 RDM5 1 3 CPU limit R seconds7 9 1 3 CPU limit b seconds7 9 RDM7 1 CPU limit seconds Fig 13 CPU STRIPSworld 543 Discussion results goals virtually solution conjunctions poorest compiled configuration domain model measured terms CPU Figs 13 14 These results trivial Out solved 85 batch 3 seconds Even hardest best solving STRIPSworld The results number nodes expanded shown compiled models 300 problems generated problem 15 solved 16 CPU seconds Compiled HS performed 300 problems seconds solution The uncompiled seconds CPU time The results uncompiled choice search strategy predictably poorer plan generation poorest solutions varied appreciably search 7 seconds average CPU expenditure 17 time space usage depthfirst search producing solve 3 300 problems 60 configurations contrast graphs breadthfirst best configuration successful configurations depthfirst search failing HS An interesting observation ation compiled planning quarters problems number nodes expanded plan gener low For example average number sample RDM7 consistently configurations TL McCluskey JM PorteousArtiJicial Intelligence 95 1997 165 51 RDM3 RDM5 Node limit Node limit RDM7 __a 20 100 Node limit 140 180 Fig 14 NODES STRIPSworld seen comparing nodes expanded planning problem graphs compiled breadthfirst 90 nodes 100 problems uncompiled length resulting average solution solution lengths given Table 4 use space search solved 100 RDM7 problems space limit solve problem managed configuration Fig 14 The striking contrast space limit One expect solutions macros produce provablyoptimal attempted laboriously compared eral model potentially handvalidated line average solution ble generated overly solutions believe solutions optimal ii solutions long Although PMD close optimal tasks hand lit solution operator sequence 20 length ta set solutions optimal shown sizes problem tests average 7 8 operators This Extended STRIPSworld As results STRIPSworld overall effect domain model compilation solution problem results hardest problem sample Consider dramatic improvement results 52 TL McCluskey JM PorteousArticial Intelligence 95 1997 I65 ADM5 1 3 CPU limit R seconds7 9 ADM7 CPU limit seconds Fig 15 CPU Extended STRIPSworld problems sample RDM7 Fig 15 seconds problems For problem improvements Comparison time impressive results number nodes expanded ble 4 reveals piled planning 3 problem plans samples average length goal sets size seven The results thirds RDh47 sample problems solved 5 20 best uncompiled configurations solved samples RDMS RDM3 performance average Fig 16 plots planning performance Ta number nodes expanded plan generation com domain configurations solution terms number operators number nodes expanded 80 problems length solution plans planning consistently lowacross measured shown domain represented graphically World The results The additional complexity harder STRIPSworlds Also model problems set impossible tests static invariants As mentioned RDM7 multirobot world means problems considerably contain 12 impossible problems solve despite passing Figs 17 18 TL McCluske JM PorteousArtijicial Intelligence 95 1997 l65 RDM3 RDMS Node limit Node limit RDM7 60 Node limit Fig 16 NODES Extended STRIPSworld marked difference Again configurations uncompiled levels offmuch successes uncompiled configuration resource given rate solution compiled planning harder problems configurations particularly poor gradient graph clearly going lead problems solutions Although compiled planning configurations fair better fact R3 CPU limit suggests poorer compilation performance techniques useful Also thirds problems solved HS DS problem samples domain models configurations problems BS consistently domain This interesting compiled planning impact model compilation method The reason lie extended STRIPSworlds macro usage 80 reverted generated MD R3 world macro usage dropped starting worst search macro usage In STRIPS 20 nodes original operator set establish goal compiled configuration R3 configuration BS faring performance result suggests particular 40 Thus uncompiled extent similara behaviour independent exhibit 54 TL McCluskey JM PorteousArtiJiciul Intelligence 95 1997 I65 RDM3 I RDM5 RDM7 Fig 17 CPU R world length summarised Figs 19 remarkably Tyre World The results tests domain shown graphically Table 4 Performance 20 average solution similar compiled planning configurations different configurations superimposed average solution identical 21 operators problem Somewhat surprisingly given Russells encoding domain 501 uncompiled problems uncompiled planning generated optimal contain 19 operators planning uncompiled planning 33 operators explained fact totalorder algorithm FMD produce suboptimal plans Russells planner length plans problem sample RDM8 length solution plans generated compiled length plans generated 31 plots lengths results configuration BS solves 100 average 2 seconds problem The relatively good performance configurations average 50 cent longer configurations 21 operators solution plans Optimal configurations average planning Barrett Weld 6 hours solution combination Our results time early experiments domain fairly difficult quote figure 3 p 991 The best domain solution reach optimal takes 123 seconds compiled configurations algorithms problems trivial TL McCluskey JM PurteousArtijicial Intelligence 95 1997 165 55 RDMS 250 Node limit 250 Node limit RDM7 Node limit Fig 18 NODES R world time problem 1 second solution rules produced useful goal ordering supporting contention planning On hand point achieve substate class guarantee optimality introduction virtually variation CPU orderings results create domain model invariants expressions planner Section 552 model c sacrifice types ordering devices produced optimal solution problemsee b compile PMD 55 Evaluation summary 551 Evidence dynamic testing The results indicate compiled configurations relatively superior producing shorter solutions CPU time space compared generally uncompiled ment problems uncompiled compared configurations It impossible distill overall factor improve solved compiled configuration solved configurations Also results Tyre World impressive results given literature 56 TL McCluskey JM PorteousArtijicial Intelligence 95 1997 I65 RDM8 c I 1 3 CPU limit Fn seconds7 9 Fig 19 CPU Tyre World 100 n Q 80 z 0 4 RDM8 _______ I 3 I J I 20 60 100 Node limit 140 180 Fig 20 NODES Tyre World configurations The compiled rate sense Firstly average number nodes expanded successful plan generation com resulting piled planning average results point required length solution plan Also distinctive effect different search strategies majority tests contrast rising exponentially respect configurations consistently number nodes low length solutions theoretical fundamental TL McCluskey JM PorteousArtijicial Intelligence 95 1997 l65 51 domain models dampened tent feel results This suggests extent rithm independent giving consis effect compilation impact compiled domain model algo planning search method particular 552 Effectiveness FMD goal orders lead FMD In general goal orders goal orders allowed PMD totalorder planner produces average suboptimal times This conclusion world negligible produce shorter solutions supported Tyre World shorten plan tests use effect Although PRECEDEs generation obtain sensible ordering Tyre World solution 21 working level goal sub Investigation p q establish p generation macros type goals 19 operators The cause wheel_in wheel boot lack ordering constraint goals p unfasteaed Hub q jackedup Hub Jack shows impossible state contains wq establishers valid sequence operators consider p q unfastened Hub combination type lead optimal order problem preconditions Type ii rules force planner type ii block 553 Effectiveness FMD macros We use factors introduced testing set light dynamic Section 41 judge effectiveness macro 1 The likelihood macro usable step solving given macro table spans set task configurations problem Given TSA domains As test models likelihood certainty TSA PMD reverted operator backchaining unique substate object described chosen goal predicate Across ranged results R3 40 85 As predicted macro usage averaging 40 use macros percentage nodes processed result obtained poorest sorts provides means decomposing 2 The processing search macro cuts The method engineer sup obtain trivial goal ordering ing domain models useful subproblems ported observations solutions lack static structure Tyre World form described makes significant difference dominant small amounts nodes required In models substate factors search This use macros factor planning results speedup transitions problems 3 Cost searching applicable macro planning As index cost searching macro search macro ground pair substates table subject exponential matching problems 4 Cost terms solution nonoptimay macro Our experiments suggest combined cost low argued We believe use goal ordering techniques order goal sets linked 58 TL McCluskey 04 PorteousArtificial Intelligence 95 1997 I65 establishment self paraphrasing Banerji satisfied subgoals goal undo As Korf states 37 p 451 leave previously 21 macros intact satisfying useful additional subgoal 5 The cost generating maintaining macro set The average cost fraction average cost solving generally macro generating problem sorts question The parameters size detailed Table 2 domain model macro generation abstracts dynamic macro tables determined 554 Summary benets objectcentred approach postulate appears The objectcentred approach help solve planning problems associated process b planning approach focuses enriching domain models Both problems tools complexity integrates method management verification engineering tematic way leads compiled easier ties checking understanding model Yet time model knowledge solutions representation problems creates opportuni domain accuracy resultant enrichment form glue attacked sys validation 6 Related work object plan generation utilising objectcentred Up little research process plan generation A recent exception similar representation PLANRIK algorithm manage 201 This level framework object states basis plan generation Linear plans formed object domain ignoring objects merging current global alternative interesting use plan produce partiallyordered merging operation introduce totalorder planner processing objects overhead framework precedence object states decided online planning object compilation object class sort PLANRIK differs stage level planning plans plan An interesting types planning able advantage improve inherent 30 point planners structure exploits transition graph induced operators Although planning representation problems studying propositioncentred tractable objectcentred problem highly structured work Jonsson Backstrom efficiency Their work state authors exploit domain structure issues restrictions structural work aimed domain engineering There increasing l produce model modelling planning domains For example planning awareness need structured approaches associated KADS method control knowledge use knowledge base development independent tools support ology KADS proven methodology level comparison IL McCluskey JM PorteousArtijicial Intelligence 95 1997 l65 59 use hierarchical impact modelling inference structure different Pryor result includingfilter sharply planningoriented contrasts work cited KADS portance understanding Collins demonstrated incompleteness In deductive planning Biundo Stephan domains taking formal view proving engage software engineering model reuse An integral 5 They use temporal feature method systematically recognise custombuilt method The output model produced skeletal plan refinement The im particular ways domains potential problems operator preconditions need modelling planning 161 They showed conditions logic formal framework consistency models concepts abstract data types invariants emphasis use tool support stages domain model capture validation inspired work 4156 The need tool support requirements formal specification capture reflected domain engineering example Des increasingly literature need tools help capture domain models Jardins work SOCAP emphasised 191 Chien showed planning domain model Multimission VICAR planner tools reveal appear straightforward painful 151 takes manually work planning 14 p 261 In recent publication static analysis 141 As Chien states errors importance tools validate track introducing catch tools analyse achievability goals reasoning Intelligence captured automated declarative tools transform search needed simple domains use compilation general For example common Another key aspect approach domain model efficient operationalise areas Artificial rule bases initial model domain modeller s compiled amenable procedural example work COLAB Work macro generation pioneered Korf 37 macro form This reflects trends feature knowledge form best suited form 6 tables Rubics Cube discussed tool improve planning macros perceived advantage hierarchical non primitive operators solve problems efficiency Section 4 The macros generated compilation required task reduction planning sup planners HTN framework plied domain modeller tradition NOAH partial 52 recently formalised order planners Erol et al 221 Barrett Weld 41 example We argue flavour task macros serve function unlike examples macro reduction use heavily macro selection instantiation factor planning current state goal conditions STATIC linked macro generation sort abstracted increase time This similar schemas remove search planning hierarchical contain plan fragments plan fragments A related work 24 method compared task reduction branching construct technique schemas acquiring compilation objectcentred control rules operator binding tool important difference domain theories STATIC analyses selection STATIC viewed reasons technique static interactions 60 LL McCluskey JM PorteousArtcial Intelligence 95 I 997 I65 literal In addition output method domain generated stack cycles work Poet Smith transition partialorder sets sort abstracted macros process sort abstracted planning STATIC analyses goal carried 541 They operator graphs similar generate control rules Static analyses operators graphs Section 2 generated analyse planning threats There number systems appear forms technique PRECEDE For instance Dawson 181 compiled pairs predicates concerned literature simultaneously generation goal orders planning The identification interactions goal ordering Siklbssys REFLECT assertions domain Drummond work temporal negative partial plans similar work invariants identify goal interactions stage problemindependent compilation coherent outstanding true consistent state invariant preconditions temporally invariants manner Currie 21 state invariants coherence Both sets researchers invariants similar uses compile goal orders key difference form goal orders PRECEDE incompatible state planning fly speed planner performance similar selecting 7 Future work 71 Extensions sorts More research development needed expressive dependent STRIPStype integrate usefully sort aggregation sorts example ideas objectoriented introduce aggregation modelthat framework current assumptions Also useful software design areas For example defining object Box box Boxid Shape Colour Further introduce recursive sort definitions example Stack Box Stack U BOX Two object instances sort Stack box box1 small green box boxl small green box box2 medium green box box3 large red For recursive theforms structure data type define type operation constructor forms type 561 sorts substate class expressions way equational include enumeration specification abstract different terms rewrites TL McCluskey JM PortenusArtijicial Intelligence 95 1997 I65 61 p q I pqr x pqr ___ pqr pqr pqr x p q r pqr Fig 2 I Goal establishment diagram 3 literals 72 Improvements goal order generation use resulting techniques The goal ordering analysis need implemented presented interactions progressing paper generated goal order pairs lifted predicates ways Firstly results based solely type necessary orders possible tests interactions pairs analysis consider diagram exam ings based analysis necessary domain model We development dering procedures experimental ders Secondly extend technique substates consider goal establishment assert 3 ground diagram ple p kq 3diagram sort domain model Thirdly extend larger groups predicates shown goal ordering As illustration Fig 21 This shows valid states literals p q r The relationship Fig 8 p q single block following blocks 2diagram 2 literals equivalent tested finding diagram pwqwpqr PNqrpqrl So finding block rules 3diagram lead increased number finer grained identified rdes widely applicable 73 Improvements macro generation use The regularity objectcentred approach crucial creation use Macro Table We exploited procedure Currently planner makes use macros goal We experiment use Macro Tables disjunctive chosen goal predicate defines unique substate limited manner effectiveness idea fully case context current substate 62 TL McCluskey JM PorreousArtificial Intelligence 95 I 997 I6S situation applications form macro producing macros tables partiallyordered 74 Incomplete information involving TSA models More development required table The size flexibility tables optimised filling primitive sorts supersorts linear macros operators A promising nondeterministic unknown To remove substates information range possible constraints set possible substate When operator The attraction range states specified object situations area exploration use sorts substates domains exact substate object constraint wellformed vector sets substates cleanly capture state kind vector Incomplete instead state generalised object means represented domain model operators loosened effect causes object states This example allowing change match operators rules executed objectcentred leave representation uncertainty bounded range possible set substatesthat Likewise righthand sides substate class set substates extension substates object 75 More powel sort abstracted planners To date main platform tools conventional planner fully sort engineered literalbased empirical evaluation sort engineering compi planners Our future work involve reasons solely level level literal platform current platform reasoning planner rep merits theory performs sort engineered sort engineered It anticipated help evaluate afforded extending domain This contrast lation construction object future experimentation accepting level literal efficient resentation approach level current continuity Part development new planner involve experimentation sort compiled domain models plan generation algorithms HTN 521 recently formalised tradition NOAH tools seen storing abstract planning planners Erol et al 221 Barrett Weld 141 macros generated solutions engineered hierarchical planner compared partialorder This appears promising area investigation compilation provide solutions Alternatively provide advanced constraints required temporal constraints initial goals Any use goal orderings establishment appropriate hierarchical planner levels organised sort abstraction tools initial partial plan use partialorder planner temporal advanced partial plan goals likewise augmented output compilation conjunction temporal point TL McCluskey JM PorreousIArtificial Intelligence 95 1997 l65 63 8 Conclusions In paper argued change emphasis classical planning aspects domains This creating independence objectcentred measure domain properties formalised account knowledgebased retaining example helps validation refinement model The method supported model description In particular detailed form model showed research cleanly model We detailed rigorous method nontrivial acquisition set definitions tool support required compilation use compiling conjunction totalorder planner Using compiled knowledge search recent effective cut knowledge improvement techniques Finally work step way evidently planning tools capitalised knowledgebased improves plan generation performance step models lifecycle powerful generally machine domain model techniques applicable algorithm speedup learning planning providing theoretical planning bridge research b models research groups properties models uni planning planning domain encodings clean realistic applicationoriented providing exchanged versally understood set standards easily Acknowledgements Our thanks Diane Kitchin Blaga Iordanova Steve Scott Malcolm Roome Colin Pink Iain Anderson reading earlier drafts document help production results graphs References I 1 JS Aitken N Shadbolt Knowledge Trends AI Planning 10s Press Amsterdam level planning 1994 C Bkkstriim E Sandewall eds Current 12 1 R Banerji GPS psychology Rubik cubist A Elithom R Banerji eds Artificial Human Inrelligence NorthHolland Amsterdam planning DS Weld Partialorder 131 A Barrett 1983 evaluating possible efficiency gains Artijicial Inrelligence 61 1994 I4 I A Barrett DS Weld Taskdecomposition plan parsing Proceedings AAAI94 Seattle WA 1994 IS I S Biundo W Stephan Modeling planning domains systematically Proceedings fZth European Conference Artificial Intelligence ECAI96 1996 61 H Boley P Hanschke K Hinkelmann M Meyer COLAB hybrid knowledge compilation 1993 laboratory Tech Rept RR9308 The German Research Centre Artificial representation Intelligence I7 1 T Bylander Complexity I81 T Bylander Complexity results planning Proceedings IJCAI91 Sydney Australia I99 1 results extended planning Artificial InreUigence Planning Systems Proceedings 1st International Conference 1992 19 I JG CarbonelI CA Knoblock planning K Van Lehn ed Architectures Intelligence Morgan Kaufman Los Altos CA 1991 S Minton PRODIGY integrated architecture learning Planning nnd AAAl 64 TL McCluskey JM PorteousArticial Intelligence 95 1997 165 I IO1 A Cesta A Oddi DDL I formal description constraint physical M Ghallab A Milani eds New Directions Al Planning 10s press Amsterdam representation domains language 1996 341352 I I l I A Chang I Kannan B Wong Design objectoriented manufacturing planning control Manufacturing Troy NY I99 I Proceedings Rensselaerr 2nd Internutional Conference Computer Integrated 121 D Chapman Planning 131 J Cheng KB Irani Ordering problem subgoals 1141 SA Chien Towards intelligent planning knowledge base development environment conjunctive goals Artificial Intelligence 32 1987 333377 Proceedings IJCAI89 Detroit MI 1989 Learning On Real Applications Paperfntm 1994 AAAI Fail Symposium No FS9401 Press 1995 I IS SA Chien Static completion analysis Proceedings Artijicial Intelligence Planning Systems AAAI Press 1996 16 G Collins L Pryor On misuse filter conditions critical analysis Sandewall eds Current Trends AI Planning 10s Press Amsterdam C Backstrom E 1993 105I 16 planning knowledge base development verification I71 K Currie A Tate OPlan I 181 C Dawson L Siklossy The role preprocessing open planning architecture Artijicial fntelligence S2 1991 4986 Proceedings problem systems solving IJCAI77 Cambridge MA 1977 I9 1 M Des Jardins Knowledge development methods planning systems Planning Learning On Real Applications Papers 1994 AAAI Fall Symposium No FS9401 AAAI Press 1995 nonlinear planner based object PLANRIK hierarchical C ZozayaGorostiza 1201 E DiazInfante states Proceedings FLAIRS The Florida Al Research Symposium 1996 1211 M Drummond K Currie Goal ordering partially ordered plans Proceedings NCAI89 Detroit MI 1989 221 K Erol J Hendler DS Nau UMCP sound complete procedure task network Proceedings Artificial Intelligence Planning Systems Morgan Kaufman Los Altos CA hierarchical planning 1994 1231 K Erol DS Nau VS Subrahmanian On complexity domainindependent planning Proceedings AAAI92 San Jose CA 1992 1241 0 Etzioni Why PRODIGYEBL works 25 0 Etzioni K Golden DS Weld Tractable closed world reasoning updates Proceedings Fourth International Conference OR Principles Knowledge Representation Reasoning Bonn 1994 Proceedings AAAI90 Boston MA 1990 26 Y Gil M Veloso SA Chien D McDermott Planning Learning On Real Applications Papers 1994 AAAI Fall Symposium No FS9401 AAAI Press 1995 D Nau Symposium Preface 1271 M Ginsberg Universal planning universally bad idea Al Mag 10 4 1989 4044 28 DG Green M Todd Objectoriented robotic motion IEEE SOUTHEASTCON approach 1993 29 J Hertzberg On building planning Al Planning 10s Press Amsterdam 301 P Jonsson C Backstrom tool box M Ghallab A Milani eds New Directions 1996 318 Incremental planning M Ghallab A Milani eds New Directions Al Planning 10s Press Amsterdam 1996 7990 3 I S Kambhampati CA Knoblock Q Yang Planning refinement search unified framework evaluating design 32 S Kambhampati planspace 1996 6175 tradeoffs B Srivastava Universal classical planner algorithm partial order planning Artijicial Intelligence 76 1995 167238 unifying statespace M Ghallab A Milani eds New Directions AI Planning 10s Press Amsterdam 331 Z Kazi Integrating humancomputer Computer Proposal Department 1994 341 DE Kitchin Use objectcentred interaction reactive planning PhD Information Sciences University Delaware Newark DE telerobotic approach creation validation warehouse planning domain model Tech Rept preparation Huddersfield 1997 School Computing Mathematics The University 7YL McCluskey JM PorteousArtificial Intelligence 95 1997 l65 65 135 1 CA Knoblock Learning abstraction hierarchies problem solving Proceedings AAAI90 Boston MA 1990 I36 1 CA Knoblock Automatically generating abstractions problem solving PhD Thesis School Computer Science Carnegie Mellon University Pittsburgh PA 1991 37 1 RE Korf Macrooperators I38 1 V Lifschitz On semantics STRIPS weak method learning Arttcial Intelligence 26 1985 3577 Proceedings 1986 Workshop Reasoning Actions Plans 1986 I39 1 D McAllester D Rosenblitt Systematic nonlinear planning Proceedings AAAI91 Anaheim CA 1991 1401 TL McCluskey planning JM Porteous Two complementary Proceedings 3rd International Workshop Knowledge Compilation Speedup Learning knowledge compilation techniques 1993 41 I TL McCluskey JM Porteous Y Naik CN Taylor S Jones A requirements capture method use air traffic control application SoftwarePractice Experience 25 1995 142 D McDermott J Hendler Planning What What An introduction Special lssue Planning Scheduling Artificial Intelligence 76 1995 116 utility explanationbased results concerning 43 S Minton Quantitative learning Proceedings AAAI88 St Paul MN 1988 564569 I44 I S Minton J Bresina M Drummond Commitment strategies planning comparative analysis Proceedings IJCAI91 Sydney Australia 1991 145 1 TM Mitchell R Keller ST KedarCabelli Explanationbased learning unifying view Machine Learning 1 1986 1461 EPD Pednault Generalising dependent effects nonlinear planning Proceedings IJCAI91 Sydney Australia 199 1 handle complex goals actions context 147 I MA Perez 0 Ezioni DYNAMIC new role training problems EBL Tech Rept CMU CS92 124 School Computer Science Carnegie Mellon University Pittsburgh PA 1992 48 I JM Porteous Compilationbased performance improvement generative planners PhD Thesis Department Computer Science The City University 1993 149 I The PRODIGY Research Group PRODIGY 40 The Manual Tutorial Tech Rept CMUCS92150 School Computer Science Carnegie Mellon University Pittsburgh PA 1992 SO S Russell Efficient memorybounded search algorithms Proceedings ECAI92 Vienna Austria 1992 5 I I ED Sacerdoti Planning 521 ED Sacerdoti The nonlinear nature plans 53 I LT Semmens RBFrance TWG Docker hierarchy abstraction spaces Artificial lnrelligence 5 1974 115I 35 Proceedings IJCAI75 Tblisi Georgia 1975 Integrating structured analysis formal specification techniques Cornput J 36 1992 1541 DE Smith MA Poet Postponing Washington DC 1993 threats partial order planning Proceedings AAAI93 I55 I P Stone M Veloso J Blythe The need different domain Proceedings 2nd International Conference Artificial Intelligence Planning Systems Morgan Kaufman Los Altos CA 1994 JG Turner TL McCluskey The Construction Formal Specijications An Introduction ModelBased Algebraic Approaches McGrawHill New York 1994 independent heuristics Software Engineering McGrawHill Series 56l ISI I M Veloso J Blythe Linkability examining causal link commitments partial order planning I581 DHD Warren WARPLAN Proceedings Artcial Intelligence Planning Systems Morgan Kaufman Los Altos CA 1994 generating 1977 commitment planning AI Mug 1994 Logic University Edinburgh plans Tech Rept Memo 76 Department Computational 159 I DS Weld An introduction