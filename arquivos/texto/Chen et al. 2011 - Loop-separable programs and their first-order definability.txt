Artiﬁcial Intelligence 175 2011 890913 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Loopseparable programs ﬁrstorder deﬁnability Yin Chen Fangzhen Lin b Yan Zhang c Yi Zhou c Department Computer Science South China Normal University Guangzhou Guangdong China b Department Computer Science Hong Kong University Science Technology Clear Water Bay Kowloon Hong Kong c Intelligent Systems Lab School Computing Mathematics University Western Sydney Penrith South DC NSW 1797 Australia r t c l e n f o b s t r c t An answer set program variables ﬁrstorder deﬁnable ﬁnite structures set ﬁnite answer sets captured ﬁrstorder sentence Characterizing classes programs ﬁrstorder deﬁnable ﬁnite structures theoretically challenging practical relevance answer set programming In paper identify non trivial class answer set programs called loopseparable programs ﬁrstorder deﬁnable ﬁnite structures 2010 Elsevier BV All rights reserved Article history Received 23 December 2009 Received revised form 18 December 2010 Accepted 18 December 2010 Available online 22 December 2010 Keywords Answer set programming Firstorder deﬁnability Knowledge representation Nonmonotonic reasoning 1 Introduction This work answer set programming ASP constraintbased programming paradigm applications wide range areas including bioinformatics 91229 semantic web 1127 Currently ASP applications program normally parts ﬁnite set rules variables ﬁnite set ground facts The represents general domain knowledge speciﬁc instance problem wants solve Since current ASP solvers deal rules variables 14202228 ground set propositional rules given ASP solver Recently work extending answer set semantics programs variables 4132325 consider possibility constructing ASP solver deal rules variables 4 Against backdrop paper consider problem ﬁrstorder deﬁnability answer set programs variables This problem general answer sets program variables correspond secondorder sentence 1323 inﬁnite set ﬁrstorder sentences 4 The study nongrounding based method computing answer setsstable models carried researchers 1016 The motivation developing approach avoid large sets facts grounding program containing variables By introducing concepts constrained nonground stables 10 coversanticovers 16 approach derive kind compact representations stable models original program stable models partially precomputed compiletime Although approach mentioned ﬁrstorder deﬁnability logic programs address nongrounding logic programs foundation topics actually different In paper study based ﬁrstorder stable model semantics identify class programs ﬁrstorder deﬁnable ﬁnite structures nonground approach provided alternative method compute stable models propositional logic program Corresponding author Email addresses ychenscnueducn Y Chen ﬂincseusthk F Lin yanscmuwseduau Y Zhang yzhouscmuwseduau Y Zhou 00043702 matter 2010 Elsevier BV All rights reserved doi101016jartint201012001 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 891 While work presented paper ﬁrst indeep study ﬁrstorder deﬁnability answer set programs variables mention related problem addressed propositional case In particular Dung Kanchanasut shown propositional logic program Π transformed propositional theory T Π set stable models Π exactly set models T Π 8 More recently Lin Zhao proved similar result loopformulas 22 Studying ﬁrstorder deﬁnability answer set programs theoretical practical values Firstly semantics ﬁrstorder answer set programs deﬁned based secondorder logic immediate issue understand expressive power ﬁrstorder answer set programs Results ﬁrstorder deﬁnability provide partial answers issue help achieve better understanding difference ﬁrstorder answer set programs classical ﬁrstorder logic Results aspect provide important theoretical foundation ﬁrstorder answer set programming Secondly evident work Datalog ﬁnite model theory proving ﬁrstorder deﬁnability results usually highly challenging Very new proof techniques developed useful problem solving For instance shown paper order prove ﬁrstorder deﬁnability result extend expansion tree concept Datalog 3 ASP apply loopseparable programs We believe notion loopseparable programs new expansion tree concept proposed paper useful related studies ﬁrstorder answer set programming Finally knowing program ﬁrstorder deﬁnable certainly helpful wants construct ASP solver ﬁrstorder answer set programs It initiates possibility exploiting ﬁrstorder inference tools model generators theorem provers reason programs ﬁrstorder reducible Also helpful SATbased propositional ASP solvers This current SATbased ASP solvers compute loop formulas incrementally needed If know given program captured ﬁrstorder sentence effective bypass loop formulas instantiate ﬁrstorder sentence given instance directly In paper program socalled loopseparable ﬁrstorder deﬁnable ﬁnite structures Furthermore decidable program loopseparable As shall notion loopseparable programs depends careful study rules interacts ﬁrstorder loops introduced 4 It includes ﬁrstorder deﬁnable classes programs knew like class program ﬁnite set complete loops The rest paper organized follows Section 2 presents basic logic concepts notions following study Section 3 introduces notion ﬁrstorder deﬁnability Section 4 deﬁnes class programs called loopseparable program Section 5 contains detailed proof loopseparable programs ﬁrstorder deﬁnable Section 6 considers special subclasses loopseparable programs discusses related work Finally Section 7 concludes paper discussions 2 Firstorder answer set programs extensional databases 21 Preliminaries We consider secondorder language equality function symbols A vocabulary consists ﬁnite set constant symbols ﬁnite nonempty set relation symbols including equality Given vocabulary τ denote Cτ sets constant symbols τ Pτ set relation symbols The notions term atom ﬁrstorder secondorder formula ﬁrstorder secondorder sentence deﬁned usual An atom called equality atom atom form t1 t2 proper atom We use VarO denote set variables occurring O term atom formula sentence expressions Given vocabulary τ unique assumption UNA short τ denoted Σunaτ Σuna τ obvious context conjunction ci cid3 c j different constant ci c j Cτ xQ x P x For given tuples relation symbols P P 1 P k P cid7 P 1 cid2 cid2 k arity use P P cid7 Let P Q relation symbols variables arity P Q stands formula xP x Q x cid7 cid7 cid7 1 P k P P cid2 k i1 cid2 k i1 A A A n A ﬁnite set called domain A A ﬁnite structure A vocabulary τ tuple A c m R 1 c A A interpretation kary relation symbol R 1 cid2 cid2 n A interpretation constant ci 1 cid2 cid2 m R c kary relation A In following use DomA denote domain structure A Unless stated domains structures assumed ﬁnite paper cid7 ix P ix denote formula Given tuples s s1 sn t t1 tn length use s t denote formula i1 si ti s cid3 t formula s t A binding expression form xt x variable t term substitution set bindings containing binding variable If ϕ ﬁrstorder formula term tuple terms θ substitution denote ϕθ result replacing free variable ϕ according θ xP ix P cid7 ix A 1 R xP Given set variables relation variables V structure A assignment σ V A function assigns variable V domain element DomA nary relation variable V nary relation DomA We write A σ cid9 ϕx mean ϕ true A assignment σ cid2 n 892 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 22 Syntax semantics We introduce syntax semantics ﬁrstorder answer set programs extensional databases section A rule form b1 bk c1 cl 1 proper atom b1 bk c1 cl k l cid3 0 atoms A rule called constraint Given rule r form 1 head r denoted Headr b1 bk c1 cl body r denoted Bodyr b1 bk positive body r c1 cl negative body r We use Posr Negr denote set atoms b1 bk set atoms c1 cl A variable x rule r called local variable occurs body r head r A ﬁrstorder answer set program extensional database simply called program ﬁnite set rules Given pro gram Π use τ Π denote vocabulary containing relation symbols constants Π A relation symbol P τ Π called intensional predicate occurs head rules Π extensional predicates We use τextΠ denote vocabulary containing extensional predicates constants Π τintΠ vocabulary containing intensional predicates Π We use PΠ PintΠ PextΠ denote sets tuples clear context predicates intensional predicates extensional predicates Π respectively A proper atom P t extensional intensional P extensional intensional Now present semantics ﬁrstorder answer set programs extensional databases For rule r form 1 y tuple local variables r x rest variables cid2 Bodyr use cid3r denote sentence x y r cid2 Bodyr formula b1 bk c1 cl By cid3Π denote sentence cid7 1 P Let P P 1 P k P cid7 P cid7 1 cid2 cid2 k arity Given rule r form 1 cid3r PP cid7 mean formula obtained cid3r replacing relation symbol P occurring head positive body r corresponding relation symbol cid3r PP cid7 For instance r rule P x Rx Q x P cid7 cid7x Note replace relation symbol Q cid3r P Q P negative body r cid7 k tuples relation symbols relation variables P P We use cid3ΠPP cid7 denote formula cid7 sentence xRx Q x P cid7 Q rΠ cid2 cid2 cid3r rΠ Deﬁnition 1 Answer set Let Π program A structure A τ Π answer set Π A model cid4 cid3Π P P PintΠ cid3Π cid5 PintΠP cid6cid7 2 Example 1 We consider program Π1 consisting following rules T x y Ex y Ex x E y y T x z T x y T y z A b b c PextΠ1 E PintΠ1 T Let A A E A b c c d b d According Deﬁnition 1 A answer set Π If view E graph T c d T computed program Π1 transitive closure induced subgraph E set nodes edge going A structure τ Π E A T Note Deﬁnition 1 minimization applies intensional predicates extensional predicates viewed initial input program This different previous ﬁrstorder answer set semantics Ferraris et al 13 Lin Zhous semantics 23 There theoretical practical advantages separating program vocabulary intensional extensional Firstly separating intensional extensional predicates program program viewed generic description certain agents behaviors extensional pred icates provide instantiations agents initial inputs Consequently class programs contain rules different extensional predicate inputs share essential properties study properties ﬁrstorder deﬁnability complexity simpliﬁed Secondly practical viewpoint separation simplify underlying implementation problem solving domains This current practice ASP For instance easily write generic program computing Hamiltonian cycles ﬁnite graph considering speciﬁc input graph represented extensional predicate values In fact semantics presented new simpliﬁcation answer set stable model semantics recently presented Ferraris et al 13 Lin Zhou 23 The main differences twofold First distinguish extensional intensional predicates discussed Second consider normal logic programs constraints programs functions disjunctions nested expressions arbitrary ﬁrstorder sentence Also deﬁnition goes early work Lin 21 relating normal logic program stable model semantics circumscription As context ﬁnite structures standard GelfondLifschitz transformation semantics program grounded ﬁnite domains Y Chen et al Artiﬁcial Intelligence 175 2011 890913 893 23 Relation answer set semantics Given program Π structure A τextΠ shall deﬁne instantiation Π A propositional program following propositional language LA LA cid8 P cid9 cid9 P PintΠ DomAn cid10 We begin notation Let α atom σ assignment A We denote ασ result replacing constant c α domain element c variable x α σ x A Let r Π rule form 1 We deﬁne instantiation r A written rA set propositional rules obtained R cid8 aσ b1σ bkσ c1σ clσ cid9 cid10 cid9 σ assignment Varr A following transformations body rule R contains b distinct elements b DomA element body rule R contains P extensional predicate P P A P extensional DomA delete rule predicate P P A delete rule delete b elements b DomA bodies remaining rules delete P P bodies remaining rules P extensional predicate The instantiation program Π A written ΠA union instantiations rules Π A We recall deﬁnitions answer set semantics propositional program 15 Given propositional language L propositional program π ﬁnite set propositional rules form pa pb1 pbk pc1 pcl 3 pa propositional atom L pb1 pbk pc1 pcl k l cid3 0 propositional atoms A propo sitional program π called positive l 0 rules form 3 π Given set propositional atoms M L propositional program π use GLM π denote propositional program obtained π following transfor mations rule form 3 π pci M 1 cid2 cid2 l delete rule delete pci 1 cid2 cid2 l bodies remaining rules A set propositional atoms M L answer set propositional program π minimal set propositional atoms satisﬁes rule GLM π M satisﬁes rule form 3 pa pb1 pbk cid3 M pc1 pcl M cid3 pa propositional atom pa M pb1 pbk M pc1 pcl M Proposition 1 Given program Π ﬁnite structure A τextΠ let Acid7 Acid7 c c MAcid7 answer set ΠA MAcid7 P P PintΠ P constant c P P Acid7 A A Acid7 extensional predicate P Acid7 structure τ Π DomAcid7 DomA answer set Π Proof Assume PintΠ P 1 Pn let P P 1 cid2 cid2 n arity 1 P n set relation variables P P Acid7 answer set Π By Deﬁnition 1 Acid7 model 2 model cid3Π By deﬁnition ΠA MAcid7 MAcid7 satisﬁes rules ΠA GLMAcid7 ΠA We MAcid7 minimal set satisﬁes rules GLMAcid7 ΠA Otherwise set M cid7cid7 MAcid7 satisﬁes rules GLMAcid7 ΠA We M cid7cid7 P ia M cid7cid7 satisﬁes intensional rules ΠA Let σ assignment P σ P predicate P 1 cid2 cid2 n We Acid7 σ cid9 cid3Π PintΠP Let r Π rule form 1 σ cid7 cid5 σ cid7 cid6 bk b1 cid6 c1 cid5 σ cid7 cid5 σ cid7 cid7 cid6 r cid5 σ cid7 cid6 cl cid5 σ cid7 cid6 assignment Varr Consider propositional rule b distinct elements b DomA element DomA r P extensional predicate P P P extensional predicate P P A cid7 A 894 cid7cid7 M satisﬁes propositional rule r body r cid7 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 cid7cid7 r cid7cid7 obtained removing equality atoms extensional atoms By considering cases Acid7 σ cid9cid3r PintΠP Acid7 σ cid9 cid3Π PintΠP So Acid7 σ cid9 P PintΠ cid3r PintΠP noticing M model 2 model cid3Π It suﬃcient MAcid7 answer set ΠA By deﬁnitions ΠA MAcid7 Acid7 cid7cid7 MAcid7 contradiction fact Acid7 exist assignment σ P Acid7 σ cid9 P PintΠ cid3r PintΠP Otherwise let σ assignment P cid7cid7 σ P LA P ia M satisﬁes rules ΠA Acid7 σ cid9 P PintΠ cid3r PintΠP Let M subset cid7cid7 intensional predicate P 1 cid2 cid2 n We M cid7cid7 Let r cid7cid7 ΠA propositional rule obtained propositional rule cid6 cid5 cid7 cid5 cid5 σ cid7 σ cid7 rule r form 1 Π σ cid7 cid6 bk cid6 c1 b1 cid5 σ cid7 σ cid7 r cid6 cl cid5 σ cid7 cid6 assignment Varr By deﬁnition ΠA equality atom body r P Posr P Negr A cid7 P cid7 P A extensional predicate P extensional predicate P cid7 form b b distinct elements DomA We Acid7 σ cid9cid3r PintΠP So deﬁnition M Acid7 σ cid9 P PintΠ M MAcid7 satisﬁes rules ΠA This contradiction fact MAcid7 answer set ΠA cid2 Furthermore satisﬁes rules GLMAcid7 ΠA noticing cid7cid7 MAcid7 M M satisﬁes rule r cid7cid7 cid7cid7 cid7cid7 cid7cid7 Proposition 1 indicates Deﬁnition 1 coincides standard GelfondLifschitz semantics lifted arbitrary ﬁnite structures considering Herbrand structure 15 As consequence Deﬁnition 1 coincides Ferraris et als recent semantics 13 restricted normal logic programs constraints ﬁnite structures Corollary 2 Let Π program predicates Π intensional A structure A stable model cid3Π Ferraris et als deﬁnition 13 iff answer set Π Deﬁnition 1 Another issue distinguish intensional predicates extensional predicates paper In fact main purpose conceptual technical Also followed Proposition 1 following properties programs extensional predicates simply transformed More precisely programs extensional predicates add identity rules form P x P x predicate P Π For way add choice rules form cid7 x P x P P x P cid7 x extensional predicate P P cid7 new predicate arity P Corollary 3 Let Π program A structure A stable model cid3Π Ferraris et als deﬁnition 13 iff answer set Π IDΠ Deﬁnition 1 IDΠ set identity rules predicates Π Corollary 4 Let Π program A structure A answer set Π Deﬁnition 1 iff Acid7 Ferraris et als deﬁnition 13 Acid7 P τ Π set choice rules extensional predicates Π conservative extension A cid2 stable model cid3Π cid4 xP x P ChoiceΠ cid7x ChoiceΠ Recently Pelov Denecker Bruynooghe introduced alternative ﬁrstorder extension logic programs aggregates stable semantics 26 In formalism program possibly inﬁnite set aggregate rules form A ϕ A atom ϕ ﬁrstorder formula potentially including aggregate expressions By deﬁning threevalue immediate consequence operator aggregate program deﬁned extended stable semantics aggregate programs Nevertheless ignoring issue aggregates diﬃcult observe ﬁxpoint based extended stable semantics actually coincides GelfondLifschitzs original stable model semantics grounded programs 15 cid11 1cid2icid2k xθ t Y Chen et al Artiﬁcial Intelligence 175 2011 890913 895 24 Loops loop formulas For ﬁnite domains answer set semantics ﬁrstorder logic program captured loop formulas 4 In following review results loops loop formulas deﬁning class ﬁrstorder deﬁnable programs1 Given program Π positive dependency graph Π denoted GΠ inﬁnite graph V E V set atoms τintΠ α β edge E rule r Π substitution θ α Headrθ β Posrθ A ﬁnite nonempty subset L V said loop Π exists cycle GΠ goes nodes L In particular atom α V treat α special loop singleton A rule r said involved loop loop L atoms α β L α Headr β Posr Let r rule form 1 suppose P t1 tn predicate P tuple t1 tn terms If x x1 xn tuple variables r normal form r x following rule P x1 xn x1 t1 xn tn b1 bk c1 cl Given loop L program Π atom P t L external support formula P t Π respect L denoted ESP t L Π following formula cid12 yi cid4 Bodyri θ cid13 Q tcid7L Q tPosri θ cid14 t cid3 t cid7 4 r1 rk normal forms x rules Π head mention predicate P x tuple variables Π t t1 tn x x1 xn θ x1t1 xntn yi 1 cid2 cid2 k tuple local variables ri The loop formula L Π denoted LFL Π universal closure cid11 cid11 α ESα L Π 5 αL αL We use LFΠ denote set loop formulas Π Theorem 1 See 4 Let Π program2 A ﬁnite structure τ Π A model Σuna A answer set Π A model cid3Π LFΠ In general case program inﬁnite loops LFΠ inﬁnite set sentences programs Π4 Π5 illustrated section However programs loop formulas captured ﬁnite set formulas A complete set loops S program Π set loops loop L Π loop L cid2 cid7 S cid7θ If program Π ﬁnite complete set loops S ﬁnite structure A answer substitution θ L L set Π A model sentence cid3Π LS LFL Π Example 2 Consider following program Π2 r1 P x Q x R1x r2 Q x P x R2x r3 P x R3x r4 Q x R4x cid4 One complete set loops Π2 P y Q y P y Q y structure A answer set Π2 model conjunction cid15Π2 following loop formulas cid7 R3 y cid7 R4 y cid7 R3 y R4 y P y Q y cid4cid4 cid7 P y Q y cid7 Q y R1 y cid7 cid4 P y R2 y y y y cid4 cid4 1 Some notions little bit different 4 ﬁt context 2 The theorem 4 consider programs constraint straightforward extend arbitrary programs 896 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 3 Firstorder deﬁnable programs Now present formal deﬁnition ﬁrstorder deﬁnability answer set programs Deﬁnition 2 A program Π called ﬁrstorder deﬁnable ﬁnite structures answer set semantics ﬁrst order sentence ψ vocabulary τ Π ﬁnite structure A τ Π A model ψ A answer set Π In case Π deﬁned ψ This notion ﬁrstorder deﬁnability answer set programs closely related wellstudied deﬁnability problem datalog queries deductive database 16 A datalog rule rule negation datalog program ﬁnite set datalog rules program negation For datalog program Π shown given database structure extensional predicates unique answer set Π based database This unique answer set computed datalog program given database extensional predicates A datalog query Q Π Q PintΠ represents intended value Q given extensional database A Π denoted Q A Q Π explicitly ﬁrstorder deﬁnable exists ﬁrstorder formula φx τextΠ extensional database A Π Q A relation represented φx A Q Π implicitly ﬁrstorder deﬁnable ﬁrstorder sentence φ τextΠ Q extensional database A Π relation R A φ satisﬁed extension A R R Q A 17 It shown explicit deﬁnability implies implicit deﬁnability converse true general ﬁnite structures 1 Our deﬁnition ﬁrstorder deﬁnability similar implicit ﬁrstorder deﬁnability Datalog One main difference ﬁrstorder deﬁnability issue considered ASP program query Another difference deﬁnition require ﬁrstorder sentence capture answer sets intensional predicates single intensional predicate mentioned query Example 3 Consider following program Π3 P x Q x R1x Q x R2x Π3 intensional predicates P Q According Deﬁnition 2 Π3 deﬁned sentence cid4 x P x cid4 Q x R1x cid7cid7 cid4 x cid7 Q x R2x From remarks end section program ﬁnite complete set loops ﬁrstorder deﬁnable However converse true general As following examples Example 4 Consider program Π4 r1 r2 P x Rx P x P y Sx u T y v 6 7 For program P intensional predicate Clearly Π4 ﬁnite complete set loops n 0 P x1 P xn loop Now consider P x1 derived There rules P x1 Rx1 P x1 P x2 Sx1 u1 T x2 v 1 8 9 The ﬁrst base rule rule called base rule predicates body rule extensional The second recursive P x2 Expanding recursive second rule produces new rules P x1 P x1 Rx2 Sx1 u1 T x2 v 1 P x1 P x3 Sx2 u2 T x3 v 2 Sx1 u1 T x2 v 1 10 11 Again ﬁrst base rule second recursive P x3 expanded produce rules P x1 However new rules redundant For instance expanding P x3 11 rule 6 produces following rule P x1 Rx3 Sx2 u2 T x3 v 2 Sx1 u1 T x2 v 1 12 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 897 But rule subsumed 10 In fact program equivalent program Π cid7 rules 8 10 Π cid7 4 loops deﬁned conjunction 4 cid15 Π cid7 4 contains cid4 x P x Rx yuv R y Sx u T y v cid4 cid7cid7 This example recursive expansion terminates step As shall reason body r2 separated parts Bh Sx u Bb P y T y v Bh head rule r2 share variables Bb Example 5 Consider program Π5 r1 P x R1x r2 Q x y R2x y r3 r4 Q x y P x Sx u P x Q x y T y v For program intensional predicates P Q We Π5 ﬁnite complete set loops n 0 P x Q x y1 Q x yn loop Notice loop atoms share common variable x Just like Example 4 recursive rules r3 r4 need expanded ﬁnite number times For r3 expanding Q x y body produces base rule recursive rule form P x P x discarded For r4 expanding P x body produces base rule following recursive rule Q x y Q x y1 Sx u T y1 v Expanding Q x y1 13 r2 produces base rule Q x y R2x y1 Sx u T y1 v Expanding Q x y1 13 r4 produces recursive rule Q x y P x Sx u1 Sx u T y1 v 13 14 14 subsumed r4 It redundant need expanded On examination makes program ﬁrstorder deﬁnable loop uses recursive rule r3 similarly r4 body rule separated parts Bh Bb Q x y T y v variables Bh Headr3 Bb variables atoms loop 4 Loopseparable programs We seen examples ﬁnite complete sets loops nonetheless ﬁrstorder deﬁnable They loopseparable programs Our main result paper showing programs ﬁrstorder deﬁnable To deﬁne programs need ﬁrst introduce additional notions loops 41 Loop patterns The examples suggest variables rules involved loops program patterns loop formulas wellbehaved sense grow inﬁnitely long However loops sets atoms variables loop variables occurring rules involved loop This motivates following deﬁnition derivation paths extends notion path dependency graph program Deﬁnition 3 A derivation path S program Π ﬁnite sequence pairs atom rule α1 ρ1 αn ρn 15 1 cid2 cid2 n rule ri Π substitution xi yi ρi rixi yi xi tuple variables ri local variable xi j ri yi j new variable αk ρk 1 cid2 k 1 cid2 cid2 n αi Headρi 1 cid2 n αi1 Posρi 898 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 If path starting atom ending atom loop For derivation path need know cycle In following deﬁne relation pairs atom rule Let t1 t11 t1n t2 t21 t2n tuples terms length We deﬁne t1 t2 1 cid2 cid2 n constant c t1i c t2i c 1 cid2 cid2 n variable x x t1 x t2 t1i x t2i x 1 cid2 cid2 n variable x x t1 x t2 variable y y t2 y t1 1 cid2 cid2 n variable x x t2 x t1 variable y y t1 y t2 t1i x t2i y t2i x t1i y We use t1 cid5 t2 case t1 t2 For example x y x z x u x w x y z cid5 y x u Intuitively t1 t2 represents special mutual substitution relation t1 t2 variables cor responding positions occurring t1 t2 mixed Precisely properties presented following proposition Proposition 5 Let t1 t2 tuples terms length n t1 t2 Then substitution x y x1 y1 xk yk xi yi 1 cid2 cid2 k variables 1 cid2 j cid2 k xi x j different variables 1 cid2 j cid2 k yi y j different variables x1 xk Vart2 y1 yk Vart1 t1x y t2 t2 yx t1 Proof Let x1 xk variables t1 y1 yk variables t2 t1i x j t2i y j 1 cid2 j cid2 k cid2 In following substitution x y shown Proposition 5 witness t1 t2 For example yu zw witness x y x z x u x w We extend relation atoms rules pairs atom rule For atoms α1 α2 α1 P t1 α2 P t2 use α1 α2 t1 t2 For rules ρ1 ρ2 ρ1 rx y1 ρ2 rx y2 x tuple variables r use ρ1 ρ2 y1 y2 For pairs α1 ρ1 α2 ρ2 α1 α2 atoms ρ1 ρ2 rules use α1 ρ1 α2 ρ2 α1 α2 ρ1 ρ2 We use O1 cid5 O2 case O1 O2 O1 O2 atoms rules pairs atom rule Now deﬁnition loop pattern Deﬁnition 4 A derivation path form 15 called loop pattern n 1 ρ1 ρn ρi cid5 ρ j 1 cid2 j cid2 n j Example 6 We continue program Π4 Example 4 Π5 Example 5 For program Π4 loop patterns form lp1 cid4 cid4 cid4 cid7 P x1 r2xx1 yx2 uu1 vv 1 cid7 P x2 r2xx2 yx3 uu2 vv 2 cid7 P x3 r2xx3 yx4 uu3 vv 3 Note r2xx1 yx2 uu1 vv 1 r2xx3 yx4 uu3 vv 3 r2xx1 yx2 uu1 vv 1 cid5 r2xx2 yx3 uu2 vv 2 r2xx2 yx3 uu2 vv 2 cid5 r2xx3 yx4 uu3 vv 3 For program Π5 forms loop patterns 16 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 lp1 lp2 cid4 cid4 cid4 cid4 cid4 cid4 cid7 P x1 r3xx1 yx2 vv 1 cid7 Q x1 x2 r4xx1 yx2 uu1 cid7 P x1 r3xx1 yx3 vv 2 cid7 Q x1 x2 r4xx1 yx2 uu1 cid7 P x1 r3xx1 yx3 vv 1 cid7 Q x1 x3 r4xx1 yx3 uu2 899 17 18 The following proposition shows relationship loop patterns loops Proposition 6 If S loop pattern form 15 program Π α1 yx αn yx loop Π x y witness α1 αn Proof There path α1 yx αn yx α1 yx αn yx cid2 There programs ﬁnite complete set loops following proposition shows program ﬁnite complete set loop patterns Proposition 7 For program Π ﬁnite set loop patterns Sl loop pattern S Π loop pattern S cid7θ θ x y substitution variables y different cid7 Sl S S Proof Please Section 51 cid2 42 Loopseparable program Now present main result Deﬁnition 5 Loopseparable programs A program Π loopseparable loop pattern form 15 following cases holds Case 1 pair αi ρi 1 cid2 n Bodyρi separated parts Bh Bb Bh Bb Bh Bb Bodyρi αi1 Bb Varαi Bh VarBb Case 2 pair αi ρi 1 cid2 n Bodyρi separated parts Bh Bb Bh Bb Bh Bb Bodyρi αi1 Bb Varαi Bh VarBb cid16 n j1 Varα j Example 7 Consider loop pattern lp1 program Π4 pair P x1 r cid7 2 r cid7 2 r2xx1 yx2 uu1 vv 1 P x1 P x2 Sx1 u1 T x2 v 1 We separate Bodyr case 1 Deﬁnition 5 program Π4 loopseparable cid7 parts Bh Sx1 u1 Bb P x2 T x2 v 1 So lp1 satisﬁes condition Consider loop patterns lp1 lp2 program Π5 We satisfy condition case 2 Deﬁnition 5 program Π5 loopseparable Note cases Deﬁnition 5 exclusive There loop patterns satisfy conditions j1 Varα j Furthermore given cases For instance loop pattern form 15 case 1 case 2 program possible loop patterns case 1 case 2 cid16 n Example 8 Consider program Π6 r1 P x R1x r2 Q x R2x r3 P x Q x R3 y 900 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 r4 Q x P x R4 y P x P y R5 y r5 There forms loop patterns lp1 lp2 lp3 lp4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid7 P x1 r5xx1 yx2 cid7 P x2 r5xx2 yx3 cid7 P x3 r5xx3 yx4 cid7 P x1 r3xx1 y y1 cid7 Q x1 r4xx1 y y1 cid7 P x1 r3xx1 y y1 cid7 Q x1 r4xx1 y y1 cid7 P x1 r3xx1 y y1 cid7 Q x1 r4xx1 y y1 cid7 Q x1 r4xx1 y y1 cid7 P x1 r3xx1 yx2 cid7 P x2 r3xx2 y y2 cid7 Q x2 r4xx2 y y2 19 20 21 22 As lp4 loop pattern case 1 lp2 lp3 loop patterns case 2 lp1 loop pattern case 1 case 2 Theorem 2 If program loopseparable ﬁrstorder deﬁnable According Theorem 2 programs Π4 Π5 Π6 ﬁrstorder deﬁnable Furthermore problem checking given program loopseparable decidable indicated fol lowing theorem Theorem 3 It decidable check program loopseparable 5 Proofs main theorems The proofs main theorems Theorems 2 3 technical tedious However underlying ideas simple For Theorem 2 ﬁrst prove holds restriction UNA extend result general case The ﬁrst step technically challenging For purpose need relate answer set semantics socalled expansion tree extended technique Datalog Then loop separable program pick ﬁnite set expansion trees capture answer sets Based ﬁnite number expansion trees explicitly deﬁne ﬁrstorder sentence exactly captures original program Theorem 3 direct consequence Proposition 7 proven showing operator bound length loop patterns given program 51 Proofs Proposition 7 Theorem 3 We ﬁrst prove Proposition 7 Theorem 3 proof techniques needed proving Theorem 2 We need following lemma length derivation path Lemma 1 Let Π program There exists natural number N derivation path form 15 n N exists j 1 cid2 j cid2 n αi ρi α j ρ j Proof Note Π ﬁnite rules original statement follows immediately following Let k natural number There exists natural number Nk set t1 tn tuples length k n Nk exists j 1 cid2 j cid2 n ti t j In words exists bound set term tuples ﬁxed length similar term tuples Y Chen et al Artiﬁcial Intelligence 175 2011 890913 901 cid7 cid7 t We ﬁrst ignore constants Now divide set term tuples categories category partition k terms That term tuples t t j 1 cid2 cid3 j cid2 k ti t j cid7 j The number categories ﬁnite k ﬁxed number More speciﬁcally number t categories exactly Bk kth Bell number understood number equivalence relations set k members Clearly term tuples different categories similar We prove exists bound categories similar term tuples Without loss generality consider case terms term tuple distinct The cases obtained similar way category pair In category term tuple t exist ti t j ti t j Let Tk maximal number term tuples length k category similar term tuples Clearly T 1 1 Now consider calculate Tk k 1 Suppose term tuples similar category Let t x1 xk similar t exist 1 cid2 cid2 k term tuple xi cid3 x j 1 cid2 cid3 j cid2 k If tuple t xi t Then consider term tuples category x1 kth position The number term tuples equal Tk1 Otherwise exist term tuples similar Thus Without loss generality assume x1 kth position t xi ith position t cid7 cid7 cid7 cid7 T 1 1 Tk cid2 kk 1Tk1 1 k 1 Here k kk 1Tk1 means k terms k 1 means variables different position Tk1 means discussed Tk1 term tuples ﬁxing term particular position Hence Tk bounded In fact Tk cid2 kk 1 cid17 1cid2icid2k 1 ii 1 The proof shows exists bound ignoring constants When considering constants statement holds set constants ﬁnite In fact divide set term tuples m groups contain m different constants 0 cid2 m cid2 C C number constants Then group bound exist substations similar The case m 0 The proof easily extended arbitrary m cid2 Proof Proposition 7 By Lemma 1 given program Π natural numbers N1 N2 loop pattern S Π length S N1 number variables S N2 Let v 1 v N2 N2 variables Π Sl possible loop patterns Π variables We Sl ﬁnite loop pattern S Π loop pattern S cid7 S S S cid7θ θ x y substitution variables y different cid2 Proof Theorem 3 The set loop patterns Sl deﬁned Proposition 7 ﬁnite suﬃcient check condition Deﬁnition 5 holds loop pattern Sl cid2 52 Correspondence answer set expansion tree Now extend notion expansion tree introduced Datalog 3 ﬁrstorder answer set program exten sional database related answer set semantics More precisely structure A answer set given program Π A supported set expansion trees Π In subsection stated assume structures considered models Σuna Deﬁnition 6 An expansion tree T program Π ﬁnite tree nodes T pairs form α ρ α atom ρ rθ r Π rule θ substitution α Headρ node α ρ let β1 βi intensional atoms Posρ α ρ children labeled atom β1 βi In particular node α ρ expansion tree T leaf T atoms Posρ equality extensional atoms Let T expansion tree program Π w node T We use αw ρw denote atom rule w T w subtree T root w Let θ substitution We use wθ denote pair αw θ ρw θ T θ expansion tree obtained T replace node w T wθ We use depT denote depth expansion tree T treeΠ inﬁnite set expansion trees Π 902 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 Given expansion tree T program Π loss generality assume variables T variables Π disjoint node w variables body ρw occur head ρw occur nodes T T w Note path T derivation path Π Given expansion tree T use rT denote rule head atom root T positive body negative body deﬁned cid18cid8 cid18cid8 PosrT Posρw NegrT Negρw cid10 cid9 cid9 w leaf T cid9 cid9 w node T cid10 Given expansion trees T 1 T 2 T 1 subsumed T 2 T 2 subsumes T 1 roots T 1 T 2 labeled atom BodyrT 2 BodyrT 1 Deﬁnition 7 Let Π program A structure τ Π T possibly inﬁnite set expansion trees We A supported T intensional predicate P P expansion tree T T assignment σ VarT A σ t A σ cid9 cid4 BodyrT P t atom root T A The following lemmas relationship answer sets expansion trees Lemma 2 Let Π program A structure τ Π model cid3Π If A answer set Π A supported treeΠ Proof Assume A answer set Π Let Ae structure τextΠ DomAe DomA P A extensional predicate P PextΠ Also let M P P PintΠ P P answer set propositional program ΠAe ΠAe instantiation Π Ae Ae A By Proposition 1 M By Deﬁnition 7 suﬃcient P M expansion tree T treeΠ assignment σ VarT A P ασ A σ cid9 cid4 BodyrT α atom root T From deﬁnition answer set propositional program M minimal set satisﬁes rules GLM ΠAe We deﬁne M0 Mi TPMi1 0 TP map subset LA subset LA deﬁned following cid9 cid9 rule pa pb1 pbk GLM ΠAe pb1 pbk S TPS pa cid8 cid10 GLM ΠAe positive exists n Mn Mn1 M 30 We induction P Mi 0 cid2 cid2 n expansion tree T treeΠ assignment σ VarT A P ασ A σ cid9 cid4 BodyrT α atom root T For 0 statement holds trivially We assume statement holds j holds j Let P M j By deﬁnition TPM j rule P pb1 pbk GLM ΠAe pb1 pbk M j1 By deﬁnitions ΠAe GLM ΠAe rule P pb1 pbk pc1 pcl ΠAe rule r P t b1 bk bk1 bkcid7 c1 cl cl1 clcid7 Π assignment σr Varr A P tσr P b1 bk intensional atoms bmσr pbm 1 cid2 m cid2 k bk1 bkcid7 extensional atoms equality atoms A σr cid9 bm k m cid2 k c1 cl intensional atoms cmσr pcm 1 cid2 m cid2 l cl1 clcid7 extensional atoms equality atoms A σr cid3cid9 cm 1 m cid2 l cid7 cid7 By assumption 1 cid2 m cid2 k expansion tree Tm treeΠ assignment σm VarTm A αm atom root Tm Without loss generality pbm αmσm A σm cid9 cid4 BodyrTm assume VarTm1 VarTm2 1 cid2 m1 cid3 m2 cid2 k Y Chen et al Artiﬁcial Intelligence 175 2011 890913 903 We introduce new variable vc domain element c DomA deﬁne substitution θm Tm 1 cid2 m cid2 k following cid9 cid9 x VarTm x assigned c σm θm xvc cid8 cid10 We pbm αmσm αmθmσ cid7 root Tm σ cid7 element c αm m assignment VarTmθm A assign variable form vc domain A σm cid9 cid4 BodyrTm A σ cid7 m cid9 cid4 BodyrTm θm m Let θ substitution cid8 θ xvc cid9 cid9 x Varr x assigned c σr cid10 We deﬁne expansion tree T following root T P tθ rθ P tθ rθ k subtree T 1θ1 Tkθk We b1θ bkθ intensional atoms Posrθ For 1 cid2 m cid2 k atom root Tmθm αmθm pbm pbm bmσr bmθσ cid7 αmθm bmθ noticing αmθmσ cid7 So T deﬁned m m All variables T form vc c domain element A Let σ variable form vc VarT domain element c We assignment VarT assign T θ expansion tree noticing T 1θ1 Tkθk expansion trees P tθ rθ k children labeled atoms b1θ bkθ root T θ labeled atom P tθ P P tθσ noticing P P tσr A σ cid9 cid4 1 cid2 m cid2 k A σ cid9 bm k m cid2 k BodyrT θ noticing A σm cid9 cid4 BodyrTm θm 1 cid2 m cid2 l cid7 cid7 A σ cid3cid9 cm This completes proof cid2 Lemma 3 Let Π program A structure τ Π model cid3Π If A supported set expansion trees T A answer set Π Proof Assume A model cid3Π supported set expansion trees T By Theorem 1 suﬃcient A model LFΠ Let L loop Π The loop formula L universal closure cid11 cid11 α αL αL ESα L Π Let σ arbitrary assignment VarL A If A σ cid3cid9 wise exists P case αL α A σ cid9 P t L σ t We A σ cid9 A cid19 cid19 cid19 cid19 αL α αL ESα L Π Other αL ESα L Π holds By assumption A supported T So exists expansion tree T T assignment δ VarT atom root T We induction P t A A δ cid9 cid4 BodyrT δt structure expansion tree T node w P cid7 ρ T cid7t A δ cid9 P loop L cid7 cid7 cid7t cid19 A σ cid7 cid9 αLcid7 ESα L atom P cid7 cid7 Π Without loss generality assume VarL assignment σ cid7 cid7cid7 L cid7t cid7 VarT VarL cid7 A σ cid7t cid7cid7 δt cid7 cid7t cid7 ρ leaf Bodyρ BodyrT We A δ cid9 cid4 Bodyρ A δ cid9 P cid7t cid7 noticing A loop x tuple variables L σ cid7t cid7 Let σ cid7 cid7 Also let y tuple local variables ρ σ cid7cid7 assignment x A atom assignment x y A cid7cid7 δt cid7 1 If w P model cid3Π cid7 Let L cid7t cid7cid7 L P σ cid7cid7x σ cid7x σ cid7cid7 y δ y We cid4 A σ cid7cid7 cid7 cid9 cid4 Bodyρ cid13 s cid3 scid7 Q sLcid7 Q scid7Posρ 904 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 cid7 positive ρ extensional atoms So noticing intensional atoms L cid7 A σ cid7 cid9 y cid12 cid4 Bodyρ cid14 cid13 s cid3 scid7 Q sLcid7 Q scid7Posρ cid4 cid4 cid7 cid9 A σ cid7 cid11 cid4 ES cid7 α L cid7 Π αLcid7 cid7 ρ leaf let w 1 wn children w Assume child w Q iti ρi cid7t 2 If w P w 1 cid2 cid2 n A δ cid9 Q iti cid7cid7 loop L cid7cid7 Π αLcid7cid7 ESα L cid19 atom Q cid7 L cid7cid7 assignment σ cid7cid7 σ cid7cid7t cid7 δti A σ cid7cid7 cid9 cid7 By deﬁnition rT Negρ NegrT We Posρ Q 1t1 Q ntn A δ cid9 Q iti atom 1 cid2 cid2 n So A δ cid9 cid4 cid7t cid7cid7 L VarL P If child w Q iti ρi w atom Q αLcid7 ESα L cid7 Π induction hypotheses Otherwise atoms Q s L cid7 We need loop L cid7 cid7 Π δti A σ cid7 cid9 Q scid7 Posρ σ cid7s cid3 assignment x y A cid7 A σ cid7 cid9 cid7 L αLcid7 ESα L σ cid7t cid7 Bodyρ A δ cid9 P assignment σ cid7 cid7 σ cid7t cid7cid7 δt cid7t cid19 cid19 cid7 cid7 δscid7 Similarly 1 let y tuple local variables ρ σ cid7cid7 σ cid7cid7x σ cid7x σ cid7cid7 y δ y We cid9 cid4 cid13 cid4 cid7 s cid3 scid7 A σ cid7cid7 Bodyρ So cid4 cid4 Q sLcid7 Q scid7Posρ cid7 A σ cid7 cid9 y cid12 cid4 Bodyρ cid13 cid14 s cid3 scid7 Q sLcid7 Q scid7Posρ cid7 cid9 A σ cid7 cid11 αLcid7 cid4 ES cid7 α L cid7 Π cid2 53 Finite set expansion trees loopseparable program From Lemmas 2 3 program Π deﬁned cid3Π expansion trees However exist inﬁnite number expansion trees general considering equivalence substitution Fortunately loopseparable programs ﬁnd ﬁnite set expansion trees equivalent treeΠ The key idea loopseparable programs depth expansion trees bounded extent That loopseparable program exists natural number k expansion tree program depth greater k construct expansion tree subsumes original depth k Roughly speaking large expansion tree loopseparable program unfolded smaller For purpose need propositions derivation paths loop patterns A derivation path form 15 called base pattern atoms Posρn equality extensional atoms ρi cid5 ρ j 1 cid2 j cid2 n In following deﬁne derivation path extended loop pattern relationship loop patterns derivation paths expansion trees Deﬁnition 8 Let S w 1 wn derivation path S cid7 S extended S pairs node w 1 cid2 cid2 n w w cid7 w cid7 1 w cid7 m loop pattern VarS VarS cid7 1 An extension S S cid7 cid7 We sequence w 1 w i1 w cid7 1θ1 w cid7 mθ1 w i1θ2 wnθ2 23 xxcid7 witness w w y1 ym witness w cid7 1 w cid7 1 cid7 m Y Chen et al Artiﬁcial Intelligence 175 2011 890913 905 θ1 x cid7x z cid7z z cid7 tuple variables VarS cid7 x cid7 z tuple new variables VarS VarS cid7 variables z different θ2 uv variable v cid7 uv cid7 xxcid7 v cid7v cid7cid7 y1 ym v cid7cid7v θ1 Proposition 8 Let S w 1 wn derivation path S If S S extension S S derivation path VarS cid7 cid7 w cid7 1 w VarS cid7 m loop pattern VarS VarS cid7 length S n m 1 cid7 Proof Let S S derivation path extension S S cid7 form 23 By Deﬁnition 8 w w cid7 1xcid7x w cid7 1θ1 w cid7 mθ1 w iθ2 Consider substitution θ1 All variables S substitute distinct new variables VarS cid7 VarS cid7 It obvious length S n m 1 cid2 Given derivation path S loop patterns S1 Sn We derivation path S exist derivation paths S cid7 0 S S cid7 1 S cid7 n S cid7 1 cid2 cid2 n S cid7 cid7 extension S extension S S1 Sn cid7 i1 S Proposition 9 Let Π program T expansion tree Π Also let Sl set loop patterns mentioned Proposition 7 assume VarT VarSl If S w 1 wn path T w 1 root T wn leaf S base pattern extension S0 S1 Sm S0 base pattern S1 Sm loop patterns S Sl 1 cid2 cid2 m Proof If w cid5 w j 1 cid2 j cid2 n S base pattern Otherwise exists w w j 1 cid2 j cid2 n S w w j By Proposition 7 exists base pattern S0 loop patterns S cid7 m S extension S0 cid7 m exist loop patterns S1 Sm S Sl 1 cid2 cid2 m S extension S0 1 loop cid7 1 S S S1 Sm In following S base pattern exists derivation path S pattern S 1 length S S extension S 2 length S Without loss generality assume w icid7 cid5 w jcid7 w 1 w w j1 y1x1 wn y1x1 x1 y1 witness w w j Also w ix2 y2 w jx2 y2 x2 tuple variables w w j y2 tuple new variables T vari ables y2 different 1 S 2 cid7 cid7 cid2 j cid2 1 derivation path noticing w w j y1x1 variables x1 occur w j1 wn S 2 2 noticing y2 tuple new variables Furthermore Deﬁnition 8 1 VarS j j cid7 1 S cid7 j Let S let S 1 2 S cid7 loop pattern VarS Proposition 8 S extension S 1 S 2 length S 1 length S cid2 In following properties derivation path unchanged extended We introduce notion Given derivation path S form 15 use NSS denote number pair αi ρi 1 cid2 n Bodyρi separated parts Bh Bb Bh Bb Bh Bb Bodyρi αi1 Bb Varαi Bh VarBb Proposition 10 Let S w 1 wn derivation path S form 23 extension S S cid7 cid7 w cid7 1 w cid7 m loop pattern VarS VarS cid7 Let S 1 w cid7 1 w cid7 m loop pattern case 1 Deﬁnition 5 w cid7 j αcid7 j ρcid7 j pair Bodyρcid7 j separated Bb Bh VarBb parts Bh Bb Bh Bb Bh Bb Bodyρcid7 j αcid7 j1 Varαcid7 j cid7 w 1θ1 w Bhθ1 Bbθ1 Bhθ1 Bbθ1 Bodyρ jθ1 αcid7 Varαcid7 cid7 cid7 1 w m loop pattern case 2 Deﬁnition 5 w NSS NSS cid7 mθ1 loop pattern case 1 Bodyw jθ1 Bhθ1 VarBbθ1 j1θ1 Bbθ1 cid7 2 w 3 NSS cid7 jθ1 separated parts Bhθ1 Bbθ1 cid7 1θ1 w cid7 mθ1 loop pattern case 2 Deﬁnition 5 Proof Statements 1 2 hold noticing variable replaced distinct new substitutions θ1 θ2 906 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 For statement 3 w w NSS NS NS NS cid4cid4 cid4 cid7 w 1 w cid4cid4 w 1 w i1 w w 1 w i1 w cid7 mθ1 w iθ2 So cid7 1xcid7x w cid4 cid7 1θ1 w cid7 w wn cid7cid7 NS NS cid7cid7 w cid7 cid4 w iθ2 wnθ2 cid4cid4 cid7 mθ1 wnθ2 NS cid7 1θ1 cid7 1θ1 cid7cid7 cid7cid7 cid4 cid7 cid7 S θ1 NS cid7 1θ1 cid4cid4 NS w cid7 mθ1 wnθ2 cid7cid7 cid4 NS S cid7 w 1 w i1 w cid4 cid7 cid7 cid4cid4 NS NSS NS NSS NS cid4 S cid7 S θ1 cid7 cid2 In following propositions large expansion tree T ﬁnd smaller T T subsumed T depth T T Proposition 11 Given program Π expansion tree T Π let S w 1 wn path T w 1 root T wn leaf If S extension base pattern S0 loop patterns S1 Sm exists loop pattern S case 1 occurs S1 Sm expansion tree T Deﬁnition 5 S T subsumed T loop pattern case 1 Deﬁnition 5 Let w αk ρk pair S Bodyρk separated Proof S parts Bh Bb Bh Bb Bh Bb Bodyρk αk1 Bb Varαk Bh VarBb From 3 Proposition 10 exist nodes w w j S w αi ρkθi w j α j ρkθ j different variables x1 x2 x1 y1 θi x2 y2 θi y1 y2 different variables different variables x1 x2 x1 y1 θ j x2 y2 θ j y1 y2 different variables So Bodyρkθi separated parts Bhθi Bbθi Bhθi Bbθi Bhθi Bbθi Bodyρkθi αi1θi Bbθi Varαiθi Bhθi VarBbθi Let θ substitution cid8 θ cid9 cid9 x V xt θ j xt set variables Bb Consider rule ρkθ xt xt θi cid10 cid8 cid9 cid9 x V cid10 V Headρkθ αi literal l Bodyρk lθi Bhθi lθ lθi Bodyρkθi literal l Bodyρk lθi Bbθi lθ lθ j Bodyρkθ j We construct T shown Fig 1 Let T expansion tree obtained T nodes subtree w T replace node w w intensional atom β Bodyρkθ β Bodyρk atom βθi β Bhθi αw ρkθ αi ρkθ child labeled atom β copy node subtree βθi T w T intensional atom β Bodyrθ β Bodyρk atom βθi Bbθi βθ j β αw ρkθ child labeled atom β copy node subtree βθ j T w j T From construction T T subsumed T cid2 roots T T labeled atom BodyrT BodyrT Y Chen et al Artiﬁcial Intelligence 175 2011 890913 907 Fig 1 The proof Proposition 11 Proposition 12 Given program Π expansion tree T Π let S w 1 wn path T w 1 root T wn leaf If exist w w j S w w j loop pattern case 2 Deﬁnition 5 expansion tree T T subsumed T Proof w w j loop pattern case 2 Deﬁnition 5 Let w αi rxti w j α j rxt j From case 2 Deﬁnition 5 rxti separated parts Bh Bb Bh Bb Bh Bb Bodyrxti αi1 Bb Varαi Bh VarBb ki Varαwk cid16 j Let θ substitution θ cid8 xt cid9 cid9 x V xt xt j cid10 cid8 xt V Consider rule rθ set variables Bb cid9 cid9 x V cid16 xt xti cid10 j ki Varαwk Headrθ αw literal l Bodyr lxti Bh lθ lxti Bodyrxti literal l Bodyr lxti Bb lθ lxt j Bodyrxt j We construct T shown Fig 2 Let T expansion tree obtained T nodes subtree w T replace node w αw rθ intensional atom β Bodyrθ β Bodyr atom βxti β Bh αw rθ child labeled atom β copy node subtree βxti T w T intensional atom β Bodyrθ β Bodyr atom βx yi Bb βxt j β αw rθ child labeled atom β copy node subtree βxt j T w j T From construction T T subsumed T cid2 roots T T labeled atom BodyrT BodyrT To end section draw conclusion loopseparable program captured ﬁnite set expansion trees Lemma 4 Given loopseparable program Π exists ﬁnite set expansion trees T structure A τ Π model cid3Π A supported treeΠ A supported T 908 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 Fig 2 The proof Proposition 12 Proof Let Sl set loop patterns mentioned Proposition 7 Let Sl Sl1 Sl2 Sl1 set loop patterns case 1 Deﬁnition 5 Sl2 set loop patterns case 2 case 1 Deﬁnition 5 Let N1 numns maxbn 1 N 1 maxbl cid20 SSl1 numns NSS N number mentioned Lemma 1 maxbl maximum length base patterns Π maxbn maximum NSSb Sb base pattern By Lemma 1 maxbl maxbn exist Let N2 maximum number variables expansion tree depth equal N1 Let v 1 v N2 N2 variables Π T set expansion trees variables depth equal N1 expansion tree T It obvious T ﬁnite expansion trees T T share variables T depT cid2 N1 cid7 Let T treeΠ expansion tree depT N1 It suﬃcient exists expansion tree T cid7x y x tuple variables T cid7 T substitution x y T T cid7 T subsumed T cid7 depT cid7 cid2 N1 Let S w 1 wn path T w 1 root T wn leaf T n depT We 1 NSS numns maxbn 2 wk1 wk2 S k2 k1 N NSwk11 wk2 0 We cases exists expansion tree T T subsumed T 1 By Proposition 9 assume S extension S0 S1 Sm S0 base pattern S1 Sm m k0 NSSk We NSS occurs loop patterns S Sl 1 cid2 cid2 m By Proposition 10 NSS numns maxbn So exists loop pattern S S1 Sm By Proposition 11 construct expansion tree T loop pattern case 1 Deﬁnition 5 S T subsumed T 2 From Lemma 1 nodes w w j S k1 j cid2 k2 w w j NSw w j 0 We w w j T Without loss generality assume w icid7 cid5 w jcid7 cid2 loop pattern case 2 Deﬁnition 5 By Proposition 12 construct expansion tree T subsumed T cid7 cid2 j j j S cid7 j cid20 cid7 cid7 cid7 T subsumed T cid7 depT cid7 cid2 N1 cid2 Repeat construction We ﬁnd expansion tree T 54 Proof Theorem 2 Now face proof main theorem Theorem 2 We ﬁrst consider case restriction UNA release condition general case Y Chen et al Artiﬁcial Intelligence 175 2011 890913 909 Lemma 5 If program Π loopseparable Π ﬁrstorder deﬁnable UNA That exists ﬁrstorder sentence ψ vocabulary τ Π structure A τ Π model Σuna answer set Π A model ψ Proof Let T set expansion trees mentioned Lemma 4 From Lemmas 2 3 4 Π deﬁned conjunction cid3Π following sentences cid12 x P x cid11 cid14 cid4 BodyrT x t T T predicate P PintΠ T form P t cid2 set expansion trees T root labeled atom Clearly program ﬁrstorder deﬁnable ﬁrstorder deﬁnable UNA However converse hold general Example 9 We consider program Π7 consisting following rules T x y Ex y Ex x E y y T x z T x y T y z P b b P b P b 24 25 Cτ Π7 b PextΠ7 E PintΠ T P For structure A model Σuna A answer set Π noticing rule 24 triggered rule 25 contradiction Π answer set model Σuna deﬁned UNA If consider structures b mapped domain element Π ﬁrstorder deﬁnable Otherwise program Π1 Example 1 ﬁrstorder deﬁnable3 Fortunately loopseparable programs ﬁrstorder deﬁnable restriction UNA Given vocabulary τ let Fτ set functions f domain f c Cτ range f f c c Cτ range f subset Cτ Given program Π f Fτ Π function let Π f program obtained replace occurrence c Π f c c Cτ Π Note difference vocabularies τ Π τ Π f set constants The set constants τ Π f subset τ Π Proposition 13 Let Π program f Fτ Π function If Π loopseparable program Π f program loopseparable Proof Directly deﬁnition loopseparable program cid2 The following proposition explicitly deﬁnes sentence captures loopseparable program restriction UNA Proposition 14 Let Π loopseparable program Π deﬁned cid12 cid11 f Fτ Π ψΠ f Σuna cid4 cid7 τ Π f cid13 cid4 f c c cCτ Π cid14 cid7 26 Π f deﬁned ψΠ f UNA Proof Let A A c A 1 c A m R A 1 R A n structure τ Π It suﬃcient 3 For proof indeﬁnability Π1 refer Example 3 Proposition 2 5 The basic ideas examples similar 910 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 A answer set Π function f Fτ Π A model ψΠ f cid2 Σunaτ Π f ii function f Fτ Π A model ψΠ f Σunaτ Π f cid2 cCτ Π f c c A cCτ Π f c c answer set Π Acid7 mcid7 R A 1 R Let Acid7 A c Acid7 f Acid7 Let f Fτ Π function f c1 f c2 c A n structure τ Π f c Acid7 1 c model Σunaτ Π f If A answer set Π Acid7 ψ f UNA Acid7 cid2 Σunaτ Π f ψΠ f cid2 cτ Π fAc c f Fτ Π function A model ψΠ f ii Let Acid7 Acid7 A A c mcid7 R 1 c 1 R We Acid7 A n structure τ Π f c answer set Π f Π f model ψΠ f Acid7 Σunaτ Π f noticing Acid7 cτ Π f c c formula vocabulary τ Π A model ψΠ f loopseparable program deﬁned model Σunaτ Π f Notice Σunaτ Π f cτ Π f c c Let Acid7 constant ci vocabulary τ Π f model ΣunaΠ f ψΠ f answer set Π f A answer set Π cid2 Σunaτ Π f f ciAcid7 cid2 A 1 Acid7 A c 2 c1 c2 constants τ Π f ciA From deﬁnition 1 cid2 cid2 m cid7 Finally Theorem 2 follows Lemma 5 Proposition 14 Proof Theorem 2 Lemma 5 shows loopseparable program ﬁrstorder deﬁnable UNA Proposition 14 shows ﬁrstorder deﬁnable restriction Σuna cid2 6 Subclasses related results We identify interesting subclasses loopseparable program related results 61 Programs ﬁnite complete set loops We set programs ﬁnite complete set loops subset loopseparable programs Proposition 15 If program Π ﬁnite complete set loops Π loopseparable program Proof By Theorem 2 4 program Π ﬁnite complete set loops loop L atoms α β L Varα Varβ Let α1 ρ1 αm ρm loop pattern We ﬁrst 1 cid2 j cid2 m Varαi Varα j Otherwise assume Varαi cid3 Varα j 1 cid2 j cid2 m Let x y witness α1 ρ1 αm ρm θ x y yx L α1 αm set atoms We L Lθ loop Π noticing αm α1θ α1 αmθ We αi α j L Lθ Varαi cid3 Varα j contradicts Theorem 2 4 Thus rule ρi 1 cid2 cid2 m ρi separated parts Bh Bb Bodyρi cid2 Example 10 We continue program Π2 Example 2 Now consider Π2 loopseparable program For intensional predicate P need consider following expansion trees cid4 cid4 cid7 P y r3x y cid7 P y r1x y T 1 T 2 cid4 cid7 Q y r4x y Q following expansion trees cid4 cid4 cid7 Q y r4x y cid7 Q y r2x y T 3 T 4 cid4 cid7 P y r3x y Thus Π2 deﬁned conjunction cid15Π2 cid7cid7cid7 cid4 cid4 cid4 y y cid4 P y Q y R3 y cid4 R4 y R2 y R4 y cid4 R1 y R3 y cid7cid7cid7 As program ﬁnite complete set loops deﬁned loop formulas expansion trees formulas obtained ways different 62 Separable rules Y Chen et al Artiﬁcial Intelligence 175 2011 890913 911 It obvious loopseparable modular property Program Π Π cid7 possibly loopseparable program loopseparable programs However consider separable property rule programs Π Π cid7 program specify subclass loopseparable programs A program Π ruleseparable rule r Π Bodyr separated parts Bh Bb VarBh VarHeadr VarBb VarHeadr Proposition 16 A ruleseparable program loopseparable Proof Let Π ruleseparable program S α1 ρ1 αn ρn loop pattern Π ρi 1 cid2 cid2 n Bodyρi separated parts Bhi Bbi VarBhi VarHeadρi VarBbi VarHeadρi If exists 1 cid2 n αi1 Bbi S loop pattern case 1 Deﬁnition 5 Otherwise 1 cid2 n αi1 Bhi By deﬁnition ruleseparable program Varαi1 Varαi 1 cid2 n By deﬁnition loop pattern α1 αn Varα1 Varαn So S loop pattern case 2 Deﬁnition 5 cid2 We Π Π cid7 A program called unary program unary predicates equality The program Π6 Example 8 ruleseparable programs Π Π cid7 ruleseparable program unary program Proposition 17 If Π unary program Π ruleseparable Proof For rule r Π body r separated parts Bh Bb cid4 cid8 cid9 cid9 α Bodyr Varα Var Headr cid7cid10 Bh α cid8 α cid9 cid9 α Bodyr Varα cid3 Var cid4 Bb cid7cid10 Headr cid2 By Proposition 17 unary program ﬁrstorder deﬁnable If consider deﬁnition answer set secondorder formula result special case Theorem 8 7 24 shows secondorder sentence contains unary predicates ﬁrstorder deﬁnable 63 Separable loops If replace loop patterns loops Deﬁnition 5 subclass loopseparable program shown following proposition Proposition 18 Let Π program If loop L Π following holds cycle α1 αn α1 α1 αn L αi 1 cid2 n rule r Π substitu tion θ αi Headrθ αi1 Bodyrθ Bodyrθ separated parts Bh Bb Bh Bb Bh Bb Bodyrθ αi1 Bb Varαi Bh VarBb b atoms α β L rule r Π substitution θ α Headrθ β Bodyrθ Bodyrθ separated parts Bh Bb Bh Bb Bh Bb Bodyrθ β Bb Varα Bh VarBb αcid7L Varαcid7 cid16 Π loopseparable program Proof We contradiction Let Π loopseparable program α1 ρ1 αn ρn loop pattern case 1 case 2 Deﬁnition 5 Let y ycid7 witness α1 αn x tuple variables Varα1 V arαn We i1 Varαi x noticing use new variables local variables rule derivation path Let θ y ycid7 ycid7 y zzcid7 z tuple variables α1 ρ1 αn ρn variables x y ycid7 zcid7 tuple new variables cid16 n 912 Y Chen et al Artiﬁcial Intelligence 175 2011 890913 We α1θ ρ1θ αnθ ρnθ loop pattern case 1 case 2 Deﬁnition 5 Consider set atoms L α1 αn α1θ αnθ L loop noticing α1θ αn αnθ α1 αcid7L Varαcid7 x α1 αn α1θ αnθ α1 cycle case case b We Proposition 18 contradicts assumption Π cid2 cid16 However loopseparable programs covered conditions Proposition 18 Example 11 Let Π7 program P x y Q u v Q x y P u v There loop patterns Π7 lp1 lp2 cid4 cid4 cid4 cid4 cid4 cid4 cid7 P x1 x2 P x1 x2 Q x3 x4 cid7 Q x3 x4 Q x3 x4 P x5 x6 cid7 P x5 x6 P x5 x6 Q x7 x8 cid7 Q x1 x2 Q x1 x2 P x3 x4 cid7 P x3 x4 P x3 x4 Q x5 x6 cid7 Q x5 x6 Q x5 x6 P x7 x8 Both lp1 lp2 loop patterns case 1 Deﬁnition 5 consider loop cid10 P x1 x2 Q x1 x2 P x1 x3 L cid8 program Π7 L loop b Proposition 18 Example 11 shows reason need notion loop pattern deﬁne loopseparable program 64 Safe programs Lee Meng recently identiﬁed subclass ﬁrstorder deﬁnable programs named safe programs 19 By restricting deﬁnition program program Π safe rule r Π variable occurring rule occurs Posr However extensional databases taken account safe program necessarily ﬁrstorder deﬁnable For instance program Π1 Example 1 safe program proved ﬁrstorder deﬁnable context 5 7 Concluding remarks In paper studied notion ﬁrstorder deﬁnability ﬁrstorder answer set program extensional database Our main contribution identifying nontrivial class programs ﬁrstorder deﬁnable ﬁnite structures This class called loopseparable programs deﬁned based detailed analysis ﬁrstorder loops contains interesting classes ﬁrstorder deﬁnable programs As mentioned Section 1 study ﬁrstorder deﬁnability answer set programs important appli cation value In recent paper 2 proposed approach implement ﬁrstorder ASP solver shown ﬁnite structures normal logic program translated ﬁrstorder sentence larger signature By developing proper ﬁrstorder grounder implement SAT based ASP solver What makes results presented paper useful loopseparable programs translation program ﬁrstorder sentence simpler One future work discover classes ﬁrstorder deﬁnable programs especially generalize class loopseparable programs The notion loops loop formulas extended disjunctive programs 1819 It interesting consider result extended disjunctive programs Another important future work study computational properties loopseparable programs We proved class loopseparable programs decidable However general deciding program loopseparable expensive It interesting nontrivial tractable subclass identiﬁed Y Chen et al Artiﬁcial Intelligence 175 2011 890913 913 Acknowledgements We thank reviewers valuable comments helped improve paper The ﬁrst author supported China NSFC 60703095 Guangdong GDSF 07300237 The second author supported China NSFC 60573009 60963009 Hongkong RGC GRF 616909 The fourth authors supported Australian Research Council Discovery Grant DP0988396 References 1 M Ajtai Y Gurevich Datalog vs ﬁrstorder logic Journal Computer Systems Science 49 1994 562588 2 V Asuncion F Lin Y Zhang Y Zhou Ordered completion ﬁrstorder logic programs ﬁnite structures Proceedings AAAI2010 2010 pp 249254 3 S Chaudhuri MY Vardi On equivalence recursive nonrecursive datalog programs Proceedings 11th ACM SIGACTSIGMODSIGART Symposium PODS 1992 pp 5566 4 Y Chen F Lin Y Wang M Zhang Firstorder loop formulas normal logic programs Proceedings 10th International Conference Principles Knowledge Representation Reasoning KR2006 2006 pp 298307 5 Y Chen Y Zhang Y Zhou Firstorder indeﬁnability answer set programs ﬁnite structures Proceedings 24th AAAI Conference Artiﬁcial Intelligence AAAI2010 2010 pp 285290 6 SS Cosmadakis On ﬁrstorder expressibility recursive queries Proceedings 8th ACM SIGACTSIGMODSIGART Symposium PODS 1989 pp 311323 7 P Doherty W Lukaszewicz A Szalas Computing circumscription revisited A reduction algorithm Journal Automated Reasoning 18 1997 297336 8 PM Dung K Kanchanasut On generalized predicate completion nonHorn programs Proceedings NACLP89 1989 pp 604625 9 S Dworschak S Grell VJ Nikiforova T Schaub J Selbig Modeling biological networks action languages answer set programming Constraints 13 2008 2165 10 T Eiter J Lu VS Subrahmanian Computing nonground representations stable models Proceedings 4th International Conference Logic Programming Nonmonotonic Reasoning LPNMR1997 1997 pp 198217 11 T Eiter G Ianni T Lukasiewicz R Schindlauer H Tompits Combining answer set programming description logics semantic web Artiﬁcial Intelligence 172 2008 14951539 12 E Erdem O Erdem F Türe HAPLOASP Haplotype inference answer set programming Proceedings 10th International Conference Logic Programming Nonmonotonic Reasoning LPNMR2009 2009 pp 573578 13 P Ferraris J Lee V Lifschitz A new perspective stable models Proceedings 20th International Joint Conference Artiﬁcial Intelligence IJCAI2007 2007 pp 372379 14 M Gebser B Kaufmann A Neumann T Schaub Conﬂictdriven answer set solving Proceedings 20th International Joint Conference Artiﬁcial Intelligence IJCAI2007 2007 pp 386392 15 M Gelfond V Lifschitz The stable model semantics logic programming Proceedings 5th International Conference Symposium Logic Programming 1988 pp 10701080 16 G Gottlob S Marcus A Nerode G Salzer VS Subrahmanian A nonground realization stable wellfounded semantics Theoretical Com puter Science 166 1996 221262 17 PG Kolaitis Implicit deﬁnability ﬁnite structures unambiguous computations preliminary report Proceedings 5th Annual IEEE Symposium Logic Computer Science LICS90 1990 pp 168180 18 J Lee V Lifschitz Loop formulas disjunctive logic programs Proceedings 19th International Conference Logic Programming ICLP 2003 2003 pp 451465 19 J Lee Y Meng On loop formulas variables Proceedings 11th International Conference Principles Knowledge Representation Reasoning KR2008 2008 pp 444453 20 N Leone G Pfeifer W Faber T Eiter G Gottlob S Perri F Scarcello The DLV knowledge representation reasoning ACM Transactions Computational Logic 7 2006 499562 21 F Lin A study nonmonotonic reasoning PhD thesis Stanford University 1991 22 F Lin Y Zhao ASSAT Computing answer sets logic program SAT solvers Artiﬁcial Intelligence 157 2004 115137 23 F Lin Y Zhou From answer set logic programming circumscription logic GK Proceedings 20th International Joint Conference Artiﬁcial Intelligence IJCAI2007 2007 pp 441446 24 L Löwenheim Über Möglichkeiten im Relativekalkül Mathematische Annalen 1915 137148 25 D Pearce A Valverde Quantiﬁed equilibrium logic foundations answer set programs Proceedings 24th International Conference Logic Programming ICLP2008 2008 pp 546560 26 N Pelov M Denecker M Bruynooghe Wellfounded stable semantics logic programs aggregates Theory Practice Logic Program ming 7 2007 301353 27 A Polleres From SPARQL rules Proceedings 16th International Conference World Wide Web WWW2007 2007 pp 787796 28 T Syrjänen I Niemelä The smodels Proceedings 6th International Conference Logic Programming Nonmonotonic Reasoning LPNMR2001 2001 pp 434438 29 N Tran C Baral Hypothesizing signaling networks Journal Applied Logic 7 2009 253274 30 MH van Emden RA Kowalski The semantics predicate logic programming language Journal ACM 23 1976 733742