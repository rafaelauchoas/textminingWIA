Artiﬁcial Intelligence 175 2011 193219 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Firstorder logical ﬁltering Afsaneh Shirazi Eyal Amir University Illinois UrbanaChampaign Department Computer Science Urbana IL 61801 USA r t c l e n f o b s t r c t Article history Available online 3 April 2010 Keywords Filtering Firstorder logic Belief update Situation calculus 1 Introduction Logical ﬁltering process updating belief state set possible world states sequence executed actions perceived observations In general intractable dynamic domains include objects relationships Still potential applications domains semantic web autonomous agents partialknowledge games encourage research intractability results In paper present polynomialtime algorithms ﬁltering belief states encoded FirstOrder Logic FOL formulas Our algorithms exact cases They accept belief states FOL functions permitting arbitrary arity predicates inﬁnite universes elements equality They enable natural representation explicit references unidentiﬁed objects partially known relationships maintaining tractable computation Previous results focus general cases intractable permit imprecise ﬁltering Our algorithms guarantee beliefstate representation remains compact STRIPS actions unboundedsize domains This guarantees tractable exact ﬁltering indeﬁnitely domains The rest results apply expressive modeling languages partial databases belief revision FOL 2010 Elsevier BV All rights reserved Many everyday scenarios dynamic partially observable robot room state room camera overlooking bookshelf detect title book obscured readily observe money agent Many applications domains compute information current world state belief state set possible states distribution set performing actions perceiving observations This computation called ﬁltering state estimation belief update database progression They use information decisions increase asking price car answer questions calculus book explore room 2 sense state circuit break Filtering intractable general discrete domains 17 research dedicated approximation stochastic domains 61520 Still approximations introduce unbounded errors times unbounded computation time usable deterministic domains Recent progress logical methods ﬁltering propositional belief states sets states 3 actions obser vations shown exact ﬁltering tractable belief states represented propositional formulas certain natural assumptions met Still domains propositional encodings large In domains propo sitional representation possible This includes domains large numbers objects unknown numbers Corresponding author Email addresses hajiamincsuiucedu A Shirazi eyalcsuiucedu E Amir 00043702 matter 2010 Elsevier BV All rights reserved doi101016jartint201004015 194 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 Algorithm Assumptions Time 1 step Space Deduction ﬁlter Section 32 Factored ﬁlter Section 4 Unitcase ﬁlter Section 51 STRIPS ﬁlter Section 52 STRIPS ﬁlter Section 52 11 actions Finite FOL ﬁltering atoms precompilation stage 11 UnitCases actions UNAa STRIPS actions known success UNA ϕ clausal formb cases fully instantiated STRIPS actions known success UNA ϕ 2clausalc form unbounded lazy computation precompilation unbounded O ϕ C O Rll ϕ p O lψ2e O m2R n2R unbounded O ϕ C C depends pre compilation O Rll ϕ p O lψ2e O m2R n2R t 0 time steps Legend ϕ input initial belief state m number predicate symbols R maximum arity predicates n number constant symbols objects inﬁnitely l total number cases action successorstate axioms p number distinct atoms precondition e number distinct affected literals UNA UniqueNames Assumption b Clausal form Conjunction disjunctions c 2clausal Every clause cid2 2 literals fragment FOL Fig 1 The algorithms presented paper properties assumptions correct ﬁltering All algorithms assume function symbols No algorithm assumes ﬁnite domain requires closedworld assumption CWA The CWA planning domains It assumes objects domain mentioned explicitly objects observations partial knowledge identity objects Propositional methods ineﬃcient domains representations typically large cumbersome In paper present tractable algorithms theoretical results ﬁltering belief states represented First Order Logic FOL These representations permit belief states inﬁnite sizes uncertainty number objects identity observations distinguish objects It enables compact representations propositional logic More speciﬁcally detailed results table presented Fig 1 present following algorithms complexity bounds performance First actions partial functions map states 11 ﬁlter arbitrary FOL beliefstate formulas time O ψ C ψ input belief state representation precompilation stage domain including ψ The output size O ψ C C constant possibly large depends actions deﬁnitions input sequence actions initial belief state Second examine action representations permit faster compact ﬁltering precompilation domain Both classes domains represent effects actions cases For ﬁrst class actions ﬁltering takes time O Rl ψ l p R arity predicate ﬂuents l total number cases ﬁltered actions break p number distinct atoms appearing preconditions action cases The belief state returned representation size O Rl ψ l p To obtain results assume actions 11 broken cases conditioned unit clauses deﬁned formally Section 51 different constant symbols refer different elements domain Unique Names Assumption UNA We present different result second class action representations STRIPS actions 18 different scenarios In ﬁrst scenario assume action case instantiates variables affected predicate making proposition Also assume UNA actions executable ﬁltered Given ﬁltering takes time O lψ2e action e number affected literals action Also resulting belief state formula represented space bounded O lψ2e ψ size input belief state Focusing ﬁltering sequences length T 0 assuming input belief states clauses cid2 2 literals ﬁnal better result Assuming UNA STRIPS actions assuming fullinstantiation cases cases instantiate subsets variables algorithm STRIPS actions takes time O m2R n2R action m predicates arity R n constant symbols The output beliefstate space representation bounded O m2R n2R regardless number ﬁltering steps Thus ﬁltering sequence t 0 actions observations takes time tm2R n2R Notice domain large inﬁnite R m n small result enables tractable ﬁltering large domains This result guarantees tractable ﬁltering arbitrary sequence lengths domains It applies standard STRIPS actions These results support growing belief FOL eﬃciently representing updating partial knowledge 4066534165 En route contributions relate deterministic Situation Calculus 53 FOL transition model 4 In transition model belief state set FOL structures FOL language state We encode set structures FOL formulas We restate results 4064 showing ﬁltering belief states captured exactly deduction FOL deduction carried time step time wish answer queries particular future past state This forms foundations rest results eﬃcient polynomialtime exact algorithm computing deduction common conditions mentioned The rest paper organized follows Section 2 describes semantics use FOL ﬁltering In Section 3 provide naive algorithm ﬁltering prove correctness Section 4 offers polynomial time algorithm FOL A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 195 ﬁltering requires domain precompilation exact 11 actions Correctness algorithm relies distribution properties ﬁltering FOL KBs logical connectives prove section Section 5 presents eﬃcient algorithms kinds casebased actions Some results paper appeared previously 56 In particular basic algorithms Sections 4 5 appear The complexity results correctness examples new manuscript perspective relating work early recent research progression FOL databases 2 Semantics ﬁrstorder ﬁltering In section study logical ﬁltering FOL structures Logical ﬁltering process updating set possible world states sequence executed actions perceived observations In paper world state represented FOL structure Before explaining details logical ﬁltering semantics present languages consider 21 Firstorder languages A ﬁrstorder language speciﬁed sets symbols 1 Logical symbols Logical connectives b Quantiﬁers c Equality 2 Nonlogical symbols Variables inﬁnitely x y z b Function symbols For n set symbols called nary function symbols A 0ary function symbol called constant We use strings English characters starting capital letters constants c Predicate symbols For n set symbols called nary predicate symbols Note equality symbol treated binary predicate symbol We deﬁne terms formulas following generalized inductive deﬁnition Variables functions terms Predicates atomic formulas We deﬁne literals atomic formulas negation atomic formulas Concepts free bound occurrences variable formula deﬁned usual A closed formula formula free variable A FOL language language symbols formulas described It completely determined nonlogical symbols We turn description semantics FOL languages A structure S FOL language consists 1 S nonempty universe domain structure S The elements S called individuals S 2 For nary predicate symbol p p S Sn These tuples universe tuples p true structure 3 For nary function symbol f f S Sn S In particular constant e e S individual S When sentence ψ true structure S denote cid9S ψ To deﬁne need general notion truth formula Suppose 1 φ formula given FOL language 2 S structure language 3 σ V S function called variable assignment set V variables language universe S We deﬁne cid9S φσ meaning formula φ true structure S free variables given values speciﬁed σ universe S follows function σ set terms language universe 1 Terms Deﬁne extension σ cid10 For variable v σ cid10v σ v b If t1 tn terms f cid2 cid3 f t1 tn σ cid10 2 Atomic formulas For term t1 t2 nary function symbol cid2 f S σ cid10 t1 σ cid10 cid3 tn cid9S t1 t2σ iff σ cid10 t1 σ cid10 t2 196 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 b For nary predicate symbol p cid9S pt1 tnσ iff cid4 σ cid10 t1 σ cid10 cid5 tn p S 3 Wellformed formulas cid9S φσ iff cid9S φσ b cid9S φ ϕσ iff cid9S φσ cid9S ϕσ c cid9S xφσ iff d S cid9S φσ xd σ xd function exactly like σ variable x assigns value d Deﬁnition 1 The language set formulas D LD set ﬁrstorder formulas predicate function symbols appear D As example suppose structure S S B R binary predicate inS cid13B Rcid14 constant Oﬃce OﬃceS R constant C CS B This world predicate indicates book room book C room Oﬃce By deﬁnition sentence inC Oﬃce true S We deﬁne logical ﬁltering situation calculus 44 way compatible basic action theories 53 In following section discuss basics situation calculus needed work 22 Situation calculus In section specify language axiomatization situation calculus use paper The situation calculus language specifying properties actions The formal language adopted secondorder language equality It disjoint sorts action actions situation situations object depending domain application This language following alphabet deﬁnition similar situation calculus Reiter 53 A constant symbol S0 denoting initial situation A binary function symbol action situation situation The intended interpretation situations ﬁnite sequences actions doa s denotes sequence formed adding action sequence s A binary predicate symbol Poss action situation The intended interpretation Possa s possibility performing action situation s A binary predicate symbol cid2 situation situation deﬁning ordering relation situations The intended interpreta cid10 tion situations action histories case s cid2 s means s proper subhistory s cid10 We want able certain sequence actions subsequence To formalize adopt following foundational axioms presented 33 1 doa1 s1 doa2 s2 a1 a2 s1 s2 2 P P S0 sP s P doa s sP s 3 s cid2 S0 4 s cid2 doa s cid10 s cid16 s cid10 Axiom 1 uniquenames axiom situations stating situations iff sequence actions Axiom 2 secondorder induction situations The importance induction situation calculus described Reiter 52 This axiom secondorder axiom action theory However Reiter 33 showed secondorder axiom needed projection purposes In rest paper use ﬁrstorder situation calculus axiom This subset situation calculus suﬃcient ﬁltering shown Reiter The axioms domain independent We refer Σ Combination axioms speciﬁcation axioms holding initial situation successor state axioms action precondition axioms uniquenames axioms actions called basic theory actions Generally speaking truth value predicate value function dynamic world vary time time In FOL intrinsic notion time Hence situation calculus includes relational functional ﬂuents capture dynamic behavior world Predicates truth values vary situation situation called relational ﬂuents They denoted predicate symbols taking situation term argument Functional ﬂuents deﬁned similarly A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 197 The situation calculus use typed For simplicity assume predicates functions ﬂuents Thus predicates truth values change situation situation handled axioms enforce constraints Deﬁnition 2 Uniform formulas Let s term sort situation Inductive deﬁnition term uniform s follows 1 Any term mention term sort situation uniform s 2 If f nary functional ﬂuent t1 tn terms uniform s f t1 tn s uniform s The formulas uniform s inductively deﬁned 1 Any formula mention term sort situation uniform s 2 If p nary relational ﬂuent Poss t1 tn terms uniform s pt1 tn s formula uniform s 3 If ϕ1 ϕ2 formulas uniform s ϕ1 ϕ1 ϕ2 v ϕ1 provided v variable sort situation Thus formula uniform s iff mention Poss quantify variables sort situation mention equality situations mentions term sort situation situation argument position ﬂuent term s We deﬁne precondition axioms successor state axioms basic action theory follows From point formulas letter refers ground action letter A refers corresponding action symbol A function symbol arguments sort object value sort action Deﬁnition 3 Action precondition axioms An action precondition axiom sentence form cid2 cid3 Poss Ax1 xn s precond Ax1 xn s A nary action symbol precond Ax1 xn s formula uniform s free variables x1 xn s Deﬁnition 4 Successor state axioms A Successor state axiom deﬁned relational ﬂuent functional ﬂuent A successor state axiom nary relational ﬂuent p sentence form cid2 cid3 Poss cid2 Ax1 xn s cid2 cid2 y1 ym p y1 ym Ax1 xn s cid3cid3 cid3 succp Ax1 xn y1 ym s A action symbol succp Ax1 xn y1 ym s formula uniform s free variables x1 xn y1 ym s We deﬁne successor state axiom functional ﬂuent similarly follows cid2 cid3 Poss cid2 Ax1 xn s cid2 cid2 y1 ym z f y1 ym Ax1 xn s cid3cid3 cid3 z succ f Ax1 xn y1 ym z s The basic action theory form D Σ Dss Dap Duna DS0 Σ foundational axioms situations Dss set successor state axioms Dap set action precondition axioms Duna set uniquenames axioms actions Acid19x cid20 A cid10cid19y Acid19x Acid19y cid19x cid19y A A cid10 action symbols DS0 initial database ﬁnite set FOL sentences uniform S 0 DS0 function initial theory world start action executed All changes world result named actions An action parameterized For example moveB R 1 R2 stands action moving object B room R1 room R2 We use situation calculus foundations semantics Later Section 3 onwards focus closely belief states situation calculus proofs theorems 198 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 221 Example Bookkeeper robot Consider bookkeeper robot lives world consisting rooms When robot room observations books room It book room return book library arbitrary room borrowed book room So possible actions moveb r1 r2 returnb r borrowb r The actions executable world state change value different relational functional ﬂuents Relational ﬂuents roomr s bookb s inb r s There functional ﬂuents constants We deﬁne precondition axiom successor state axiom action omit Precondition Axiom Successor State Axiom Possmoveb r1 r2 s bookb s roomr1 s roomr2 s inb r1 s r1 cid20 r2 cid2 Poss cid3 cid3 moveb r1 r2 s cid2cid2cid2 cid10 b b cid2cid2 cid10 b b cid2 cid10 r1 r cid2 cid10 r1 r cid3 cid2 b cid3cid3 cid10 cid10r FALSE cid2cid2 cid10 b b cid3cid3 cid2 cid10 cid10 cid2 b cid2cid2 b cid3 cid2 cid3cid3 r cid3 cid10 b cid2 r moveb r1 r2 s cid10 r2 cid10 r2 cid2 r cid3cid3cid3 cid2 b r cid3cid3 TRUE cid3cid3cid3 cid10 cid10 s We write successorstate axiom way help usage Section 5 Indeed successorstate axiom simpliﬁed logically 23 Filtering semantics For ﬁltering interested answering queries values ﬂuents actions observations occur time 0 Stated language situation calculus concerned queries uniform s ground situation term s Thus ﬁltering language predicate corresponding relational ﬂuent situation calculus language Those predicates arguments sort situation Roughly speaking truth value predicate changes situation We represent predicates reusing symbols relational ﬂuents different arity corresponding relational ﬂuent Thus following deﬁnition drop situation terms The values predicates functions considered situation Transition situation s doa s performing action changes values predicates functions The following formal deﬁnition transition relations ﬁltering FOL structures The generality demands attention speciﬁc details cardinality sets relationship FOL formulas classes structures characterized formulas We bring details ﬁrst Let κ ﬁxed inﬁnite cardinality κ cid3 ℵ0 cardinality unspeciﬁed emphasize generality following development The vocabulary describing state cid13P F Ccid14 P set predicate symbols F set function symbols C set constant symbols Let S set FOL structures S cid13P F Ccid14 cardinality cid22Scid22 κ Progression ﬁltering semantics follows Deﬁnition 5 Transition relation FOL structures For action theory D structure S ground action deﬁne transition relation RD follows RD cid6cid4 cid10 cid5 cid7 cid7 cid9S preconda S S cid10 S S S cid7 cid8 cid7 cid9S succpav 1 vm cid10 cid13v 1 vmcid14 Sm cid6 cid13v 1 vm vm1cid14 Sm1 cid7 cid7 cid9S succ f av 1 vm vm1 S S cid6 cid10 cid10 p S f S cid8cid8 In deﬁnition v individual S Note action parameterized action The parameters constants moveC Oﬃce Lounge For Au1 preconda equal precond Au1 deﬁned precondition axiom action symbol A Now deﬁne ﬁltering semantics transition relation FOL structures Deﬁnition 6 Firstorder logical ﬁltering semantics Let cid8 set FOL structures The ﬁltering sequence actions observations cid13a1 o1 otcid14 deﬁned follows cid9 refers sequence 1 Filtercid9cid8 cid8 2 Filteracid8 S 3 Filterocid8 S cid8 cid9S o 4 Filtercid13ai oi otcid14cid8 Filtercid13ai1 oi1 otcid14FilteroiFilteraicid8 cid10 S cid8 cid13S S cid10cid14 RD We Step 2 progression Step 3 ﬁltering o A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 199 In deﬁnition ﬁltering applied set FOL structures A belief state formula FOL formula vocab ulary cid13P F Ccid14 P F C predicate function constant symbols correspond relational ﬂuents functional ﬂuents constants essentially situation argument For example predicate inb r corresponds relational ﬂuent inb r s situation calculus Every belief state formula ψ corresponding belief state σψ S S cid9S ψ In opposite direction belief state σ belief state formulas corresponds distinguish formula theory σ The theory σ Thσ set ﬁrstorder sentences vocabulary cid13P F Ccid14 structures σ satisfy Thσ φ φ vocabulary cid13P F Ccid14 S σ cid9S φ Several delicate points worth mentioning First choice κ affects S rest sets discussed Nonetheless taking σψ κ cid10 κ change Thσψ Speciﬁcally Thσ κ ψ This results LowenheimSkolem theorem Thus choice κ important long countable ℵ0 large number symbols vocabulary vocabulary inﬁnitely large ψ Thσ κ cid10 3 Filtering FOL formulas Approaches ﬁltering actions observations stage enumerate structures belief state impractical belief states inﬁnite sizes Even ﬁnite enumeration approach scale large domains An alternative approach perform logical progression form similar described 4046 In work wish eﬃciently context nondeterministic actions observations In section present naive algorithm ﬁlters belief state formulas directly This algorithm serves starting point Sections 4 5 propose eﬃcient algorithms We present distribution properties ﬁltering logical connectives examine theoretical limitations formula ﬁltering These guide Section 5 allow present classes systems subject limitations tracked polynomial time compact representation indeﬁnitely From forth assume ﬁrstorder language functional symbols constants This assumption help present results concisely restrict applicability results 31 Filtering consequence ﬁnding In section progress initial database represented logical formula applying single action observation The result progression new database progression algorithm use cid10 r cid10 1 grg Suppose P g1 gr set constants predicates ﬁrstorder language We deﬁne new set y1 yn gi y1 ynPP cid10 PP cid10 shorthand We view P set constants predicates situation s P cid10 cid10 set symbols P cid10 g 1 g constants predicates situation doa s Thus g g1g We ﬁlter beliefstate formula follows We reuse notation Filter ﬁltering beliefstate formula set formulas Let ψ belief state formula formula represent possible structures current state world ground action CnΨ set FOL consequences Ψ formulas φ FOL Ψ cid9 φ LΨ set logical consequences Ψ language L We write CnLΨ L set symbols mean Cn LLΨ Cn cid10 r cid10 1 Filteraψ cid9 cid9 ψ preconda P cid10 Cn cid10 cid10 y1 ym p cid10 y1 ym succpi y1 ym cid11cid11 z f cid10 z succ f az P cid10P 2 Filteroψ ψ o 1 When ﬁlter action assert precondition held world state If action executable belief state new belief state formula FALSE indicates set structures meaning structure current belief state action executable We deﬁne ﬁltering set formulas enabling recursive use previous equations For set formulas Γ cid9 cid9 P cid10 Cn Γ preconda y1 ym p cid8 cid10 y1 ym succpi y1 ym 1 FilteraΓ cid12 cid6 200 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 z f cid10 cid8 z succ f az cid11cid11 cid12 cid6 P cid10P 2 FilteroΓ Γ o 2 We prove following theorem deﬁnition ﬁltering approximates semantics Deﬁnition 6 Theorem 7 Let ψ belief state formula let ground action cid2 Filtera S cid9S ψ cid3 cid6 cid10 S cid7 cid8 cid7 cid9Scid10 Filteraψ Proof See Appendix A1 cid3 40 showed progression ﬁrstorder deﬁnable They showed progression exists set secondorder sentences ﬁnite initial databases Therefore sides Theorem 7 equivalent formula 1 FOL In words FOL strong model progression initial database However following corollary shows sides Theorem 7 equal progression database FOL deﬁnable Corollary 8 Let ψ ﬁrstorder belief state formula If progression ψ ﬁrstorder deﬁnable cid2 Filtera S cid9S ψ cid3 cid6 cid10 S cid7 cid8 cid7 cid9Scid10 Filteraψ Proof See Appendix A2 cid3 32 Deductionbased algorithm ﬁltering Our baseline algorithm computes Filtercid13a1 o1 otcid14ψ iteratively applying ﬁltering beliefstate formula action observation It practical presented reference contrast later meth ods Since step generate inﬁnite set sentences reformulate intuition following algorithm 1 Set ψ0 ψ ψi oi 0 cid2 t 2 Concurrently 0 cid2 t Apply ﬁrstorder consequence ﬁnder resolution 32 generate sentences Filteraiψi1 mula 1 b When sentence generated add ψi This algorithm correct ﬁltering shown We discuss methods consequence ﬁnding Section 422 In Sections 4 5 provide algorithms generating formula result ﬁltering 33 Sequences actions observations This section shows iterative application formulaﬁltering steps loses information respect answering queries outcome sequence actions observations It shows discard previous database ﬁltering action start database obtain performing progression step action To use ﬁrstorder situation calculus described It follows treatment situation calculus Reiter 53 The development section seen follow immediately following general results 4064 Theorem 9 See 40 Prop 410 Let φs formula uniform s let cid19a cid13a1 atcid14 sequence ground action terms docid19a s shorthand doat doat1 doa1 s Then DSα secondorder ﬁltering Sα FSα ﬁrst order ﬁltering Sα D DS0 DSα cid9 Sα cid2 docid19a Sα φ cid3 cid2 docid19a Sα iff D DS0 FSα cid9 Sα cid2 docid19a Sα φ cid2 cid3 docid19a Sα We bring complete development help explain foundations algorithm Section 32 results follow Sections 4 5 We divide action theory D parts initial database DS0 rest Dg Therefore D Dg DS0 We deﬁne language action theory follows A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 201 We use Cnst Ψ set logical consequences Ψ uniform st doat doat1 doa1 S0 Suppose want progress initial database DS0 action a1 Recall D Σ Dss Dap Duna DS0 To progress D action a1 axioms required 33 Instead including successor state precondition axioms action theory need precondition successor state axioms related action a1 action symbol To retrieve axioms successor state precondition axioms action symbol a1 replace parameters constants appearing ground action a1 We refer subset successor state axioms Dss01 The subset precondition axioms corresponding action a1 Dap01 For example ﬁrst action moveC Lounge Oﬃce axiom cid2 movex1 x2 x3 s cid2 cid2 cid3 Poss cid2 y1 ym p y1 ym movex1 x2 x3 s replaced cid3cid3 cid3 succpmovex1 x2 x3 y1 ym s Poss cid2 cid2 moveC Lounge Oﬃce S0 cid2 cid3 y1 ym doa1 S0 p cid3 y1 ym cid3 succpmoveC Lounge Oﬃce y1 ym S0 All axioms needed progression a1 For ground action term a1 looking set sen tences D1 uniform doa1 S0 serve new initial database Deﬁne Ds1 ﬁrstorder progression DS0 set sentences uniform doa1 S0 entailed D cid10 cid9 ψ iff D cid9 ψ ﬁrstorder sentence ψ uniform situation s If Dg Ds1 doa1 S0 cid16 s Ds1 new initial database ﬁltering The following theorem states result twostep progression cid10 Theorem 10 Similar 40 Prop 410 Let DS0 initial database action theory D D Dg DS0 Deﬁne Dst t cid3 1 follows Dst Cnst Dsst1t Dapt1t Dst1 Then ψ uniform doat doat1 doa1 S0 Dg Dst cid9 ψ iff Dg DS0 cid9 ψ Proof See Appendix A4 cid3 Theorem 10 different derivation Lin Reiters result applies ﬁltering 40 Proposition 410 showed ﬁrstorder progression consequences speciﬁc future ground situation term Filtering interested answering queries given ground situation terms theorem implies ﬁrstorder progression answers ﬁltering queries correctly For example bookkeeper example DS0 cid6 cid8 bookB S0 roomR S0 inB R S0 ﬁrst action returnB R Ds1 logically equivalent cid2 cid6 cid2 cid2 cid3 B doa1 S0 room cid3 R doa1 S0 B R doa1 S0 book cid3cid8 4 Factored ﬁltering In section present main contributions paper polynomialtime algorithm com putes logical ﬁltering exactly signiﬁcant class transition systems For systems fall class algorithm gives approximation ﬁltering Our algorithm section decompose ﬁltering FOL formulas ﬁltering atomic subformulas Recall FOL formula atomic atom predicate applied wellfounded terms includes quantiﬁers connectives In follows prove decomposition properties ﬁltering FOL formulas Our algorithm uses properties ﬁlters subformulas formula later combining results 202 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 41 Distribution properties Several distribution properties hold logical ﬁltering We decompose ﬁltering formula ϕ logical connectives Theorem 11 Let action ϕ ψ FOL formulas Assume ﬁltering deﬁnable FOL Then 1 Filteraϕ ψ Filteraϕ Filteraψ 2 cid9 Filteraϕ ψ Filteraϕ Filteraψ 3 cid9 Filteraϕ Filteraϕ FilteraTRUE 4 Filteraxϕx xFilteraϕ XXx X new constant symbol Proof See Appendix A6 cid3 Thus ﬁltering ϕ ψ ﬁltering ϕ ψ separately combining results Also ﬁltering ϕ ψ approximated ﬁltering ϕ ψ separately combining results The formula conjunction ﬁltering ϕ ψ separately logically weaker formula ﬁltering ϕ ψ Thus entailed combination true structure original ﬁltering Filtering ϕ approximated direction The formula negation ﬁltering ϕ stronger formula ﬁltering ϕ Thus follows ﬁltering ϕ necessarily holds negation ﬁltering ϕ TRUE Also ﬁltering xϕx ﬁltering ϕ X X new constant symbol replacing X resulted formula variable x having existential quantiﬁer x While 2 3 approximations according Theorem 11 exact answer domains Our following Theorem 13 gives stronger statement actions act 11 partial functions structures executable Deﬁnition 12 11 actions Action 11 structure S cid10 S RDS S cid10 Recall example Section 221 There action moveC Oﬃce Lounge onetoone mapping FOL structures Assume deﬁne action movetoC Lounge moves book C room Lounge regardless book moving This new action 11 maps different FOL structures maps structures book C locations different identical structure In domains action onetoone moveto replaced easily 11 action loss expressivity domain turning light replaced ﬂipping light switch Domains include 11 actions called 11 domains The theorem presents distributionoverconnectives properties 11 domains Theorem 13 Distribution properties 11 domains Let 11 action ϕ ψ formulas Assume ﬁltering deﬁnable FOL Then 1 Filteraϕ ψ Filteraϕ Filteraψ 2 Filteraϕ ψ Filteraϕ Filteraψ 3 Filteraϕ Filteraϕ FilteraTRUE 4 Filteraxϕx xFilteraϕLLx Proof See Appendix A8 cid3 The decomposition strategy offered theorem approximation exact computation 11 domains These distribution properties decomposing ﬁltering FOL formula ﬁltering atomic subformulas We decompose ﬁltering FOL formula ﬁltering atomic formulas distribution properties proved As example universally quantiﬁed formulas decomposed follows Universal quantiﬁer formula rule 3 rule 4 cid2 Filtera cid3 xϕx cid2 cid3 xϕx Filtera cid3 cid2 3 Filtera xϕx cid2 4 xFiltera cid3 ϕL FilteraTRUE FilteraTRUE Lx A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 203 PROCEDURE FFcid13ai oi cid140icid2t ψ ai action oi observation ψ beliefstate formula 1 t 0 return ψ 2 return ot FFStepat precondat FFcid13ai oi cid140icid2t1 ψ PROCEDURE FFStepa ψ action ψ beliefstate formula 1 ψ atomic formula return SingleLiteralFilteringa ψ 2 use distribution properties follows 3 4 5 6 ψ φ ϕ return FFStepa φ FFStepa ϕ elseif ψ φ ϕ return FFStepa φ FFStepa ϕ elseif ψ φ return FFStepa φ FFStepa TRUE elseif ψ x φx return x FFStepa φLLx Fig 2 Factored ﬁltering FOL formula 11 domain Universal quantiﬁer conjunction rule 2 cid2 Filtera xϕx ψx cid2 cid3 2 Filtera cid3 x ϕx cid2 Filtera cid3 xψx Universal quantiﬁer negation rule 3 rule 4 cid2 Filtera cid3 xϕx cid2 cid3 x ϕx Filtera cid3 cid2 34 xFiltera ϕL Lx FilteraTRUE Universal quantiﬁer disjunction rule 2 rule 3 rule 4 cid2 Filtera cid3 xϕx ψx 42 Factored ﬁltering cid2 Filtera cid2 34 xFiltera cid3 x ϕx ψx cid3 ϕL ψL Lx FilteraTRUE Our Factored Filtering FF algorithm 11 domains presented Fig 2 It relies Theorems 8 11 13 The number closed atomic subformulas domain ﬁnite number constants ﬁnite Therefore ﬁnite domains calculate ﬁltering atomic formulas preprocessing step retrieve later Note arguments atomic formulas constants associated existential quantiﬁers constants mentioned initial belief state set axioms observations We discuss preprocessing step Theorem 14 Let D basic action theory ψ initial belief state Algorithm FF Fig 2 returns formula logically equivalent Filteraψ 11 D precompilation D respect ﬁnite representation It runs time ψ F ﬁltering atomic formulas given ﬁnite representation F time needed O preconda retrieve ﬁltering atomic formula Proof See Appendix A9 cid3 421 Example computation FF First consider pushbutton action permutes states locks d e follows d e d e d e d e d e Successorstate axioms domain cid2 d cid2 e cid3 doa s cid3 doa s push es cid20 push ds push ds cid20 push es Precompilation progression literals A push yields Filter Ad e Filter Ad e Filter Ae d Filter Ae d 3 4 204 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 A second example assume action precondition w upw action changes world cid10 push2 Successorstate axioms w upw world stays We new action A domain cid2 cid2cid2 cid3 doa s cid3 doa s d cid2 e push2 ds cid2 cid20 push2 cid2cid2 push2 cid3 cid3 es w upw cid2 cid2 push2 cid3 cid3 ds w upw cid2 cid2 push2 cid2 cid20 push2 Successorstate axioms form F cid19x doa s γ es w upw w upw cid3cid3cid3 cid3cid3cid3 F cid19x F cid19x s γ F cid19x dis junctions formulas form cid19za Acid19y φcid19y φ quantiﬁer free uniform s cid19y exclusive union cid19x cid19z cid10 push2 yields Precompilation progression atomic formulas A cid3 F cid19x γ F cid19x γ cid3 cid2 cid13 5 Filter Filter Filter A A A cid13 cid13 cid13 cid10 cid10 cid10 cid10 cid2cid2 cid2cid2 cid14 e cid14 d cid14cid2 cid3 w upw cid3 w upw cid3 upw upw cid14 TRUE TRUE d cid3 e cid2 cid2 cid2 cid3 w upw cid3 w upw e cid3 d Filter A Filter A cid10e Filter A cid10TRUE F itler A cid10d Filter A 6 cid10ϕ cid10ϕ This precompilation results returned subroutine SingleLiteral cid10upw computed noticing A Filter A 11 cid10 Filter A Filtering 422 Precompilation Algorithm FF uses subroutine ﬁltering atoms recall atoms predicate symbols applied wellfounded terms including quantiﬁers logical connectives Such ﬁltering atomic formulas compilation prepro cessing stage domain FilteraP x1 xl ﬁnitely axiomatizable FOL action predicate P Corollary 15 Let action term P t1 tl atom t1 tl constant symbols Let X1 Xl new constant sym bols If FilteraP X1 Xl ﬁnite axiomatization FOL ϕ axiomatization FilteraP t1 tl ϕX1t1 Xltl Proof Follows proof equivalence 4 Theorem 11 cid3 Thus domain description language includes function symbols language ﬁnite assume compilation needs occur predicateandaction pair Notice assumptions related size domain inﬁnite Our assumptions permit FOL theories time step 0 inﬁnite models For example consider example Section 421 An example belief state time step 0 cid2 cid3 upw upx wx afterw x w x afterw x x cid20 w x y z afterx y y z afterx z Here predicate strict order relation element subsequent element This forces universe model inﬁnite size The ﬁltering action push2 holds change Thus ﬁltering atoms compilation preprocessing stage Such compilation domain ﬁltering needs domain For n actions m predicates precompilation n m pairs Every compilation atom P cid19X action cid19Y applying FOL consequence ﬁnding 325758422 sentences uniform docid19y s P cid19x s Σ Dss Dap Duna If action theory D conforms restrictions strictly local actions 65 precompilation polynomialsize directly 6564 size resulting formula compilation step Ω2pck representation possible result precompilation undermine eﬃciency outputcompactness FF Thus methods implement SingleLiteralFiltering Fig 2 precompute compilation stage table SLF size O n m storing compilation literal ground action term Then computation FF progression ψ action acid19y uses SingleLiteralFiltering table lookup takes time output size O SLF ψ A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 205 5 Filtering cases Our naive ﬁltering algorithm Section 3 uses consequence ﬁnding tools scale large domains Theo rem 17 suggests different reasoning procedure updates broken smaller local updates Before need deﬁne set derivedformulas set predicates Deﬁnition 16 Derivedformulas Let p1 pn n closed predicates DFp1 pn set derivedformulas p1 pn deﬁned inductively follows 1 p1 pn DFp1 pn 2 φ DFp1 pn φ DFp1 pn 3 φ ψ DFp1 pn φ ψ DFp1 pn 4 x φ y1 ym y1x1 ymxm φ y1 ym DFp1 pn For example x y bookx room y inx y DF cid3 bookx1 roomx2 inx3 x4 bookx1 roomx2 inx3 x4 derivedformula perform rule 4 formula substitute x1 x3 x x2 x4 y cid2 Theorem 17 Let ground action ψ belief state formula p1 pn n closed predicates action theory Then cid7 cid7 ψ preconda Φp1 pn DFp1 pn cid9 Φp1 pnp1succp1apnsuccpna Filteraψ cid6 cid8 7 Proof See Appendix A10 cid3 In formula Φ DFp1 pn entailed belief state action precondition ﬁltering Generally generating Φs impossible practice inﬁnitely Φs In following sections provide simpler closedform solutions special cases dynamic domains1 These rise practical polynomial algorithms 51 Unitcase successor state axioms By deﬁnition successor state axioms pair actions predicates exactly successor state axiom provided The successor state axiom action Ax1 xn predicate p rewritten following form y1 ym p cid3 px1 xn y1 ym s cid2 Poss cid3 Ax1 xn s cid2 case1 p cid2 φ1 case l p p φ cid2 case1 p l p case p cid3 l p p x1 xn y1 ym s l p1 p φ cid3 cid3 x1 xn y1 ym s cid2 cid2 cid3 y1 ym doa s j p form y jk p variable x case argument predicate p variable assignment satisﬁes cases Note set variables case subset variables p argument action variable y j1 p y x x j1 p j1 p j1 p jk p Notice algorithms presented section following require Unique Names Axioms objects This like determine case ground predicate corresponds checking constants equal pB case p y doa s y A TRUE A B constants Also like able instantiated predicates uniﬁable adding equality preconditions p A y uniﬁable pB C unique assumption However assumption predicates predicate symbols uniﬁable B A pB C p A y uniﬁable A successor state axiom called unitcase successor state axiom rewritten form φ j px1 xn y1 ym s 1 cid2 j cid2 l p 1 unit clause Our bookcarrying robot example Section 221 written form The term precondition assures cases mutually exclusive We divide unitcase successor state axiom multiple instantiated axioms 1 Those domains shown independently ﬁnite strong progression FOL 65 206 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 PROCEDURE UCF cid13ai oi cid140icid2t ψ ai action oi observation ψ beliefstate formula 1 t 0 return ψ 2 ψt1 UCFcid13ai oi cid140icid2t1 ψ 3 return ot FilterTrueat UCStepat precondat ψt1 case uniﬁableφpz1 zmn φpcid10 z1 zmn Poss Ax1 xn s condp pz1 zm doa s φpz1 zmn s successor state axiom casea φpz1 zmn true S S condp pz1 zm elseif φp z1 zmn false S S condp pz1 zm cid10 PROCEDURE FilterTrue Ax1 xn Done cashed Ax1 xn action 1 S 2 predicate symbol p case p 3 4 5 6 7 predicate symbol pair p p 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 return S S condp condpcid10 pz1 zm cid10z1 zmmguφp φp cid10 p elseif uniﬁableφpz1 zmn φpcid10 z1 zmn S S condp condpcid10 pz1 zm cid10z1 zmmguφp φp p elseif φp z1 zmn x qx φpcid10 z1 zmn qT S S condp condpcid10 pz1 zm p elseif φp z1 zmn x qx φpcid10 z1 zmn qT S S condp condpcid10 pz1 zm p elseif φp z1 zmn x qx φpcid10 z1 zmn qT S S condp condpcid10 pz1 zm p elseif φp z1 zmn x qx φpcid10 z1 zmn qT S S condp condpcid10 pz1 zm p cid10 cid15 ϕS ϕ cid10z1 zm cid10z1 zm cid10z1 zm cid10z1 zm condp TRUE case1 p case l p p Deﬁnition 18 Fig 3 Unitcase ﬁltering Deﬁnition 18 Instantiated successor state axioms predicate p Poss Ax1 xn s p y1 ym doa s φ j Poss Ax1 xn s y1 ymcase1 p px1 xn y1 ym s y j p x j p 1 cid2 j cid2 l p lp p p y1 ym doa s φ case lp 1 p x1 xn y1 ym s j p j px substitution corresponding case y cases Note instantiated successor state axioms form cid2 j p x j p y cid2 cid3 cid2 cid2 Poss Ax1 xn s condp p cid3 z1 zm doa s φpz1 zmn s cid3cid3 j p sequences variables This process called breaking condp TRUE enumeration instantiated successor state axioms action In formula zp variable universally quantiﬁed parameters action Ax1 xn The parameters action Ax1 xn free variables Figs 3 4 UnitCase Filtering UCF algorithm This algorithm applicable 11 domains successor state axioms unitcase Algorithm UCF actually way compute Φp1 pn formula 7 Here p1 pn predicates instantiated successor state axioms breaking cases Therefore arguments predicates constant symbols appear ground action In 11 domains head entailment formula 7 atomic formula use distribution properties Theorem 13 ψ preconda The distribution properties discussed break conjunction belief state precondition atomic subformulas Consequently Φp1 pnp1succp1apnsuccpn equivalent atomic formula tautology The size tautology unitcase successor state axioms Therefore compute desired Φs ﬁnite number steps Theorem 19 Let progression ﬁrstorder deﬁnable l number successor state axioms breaking cases ψ belief state formula Algorithm UCF returns ﬁltering ψ o time O Rll ψ preconda R maximum arity predicates The length returned formula O Rll ψ preconda Proof See Appendix A11 cid3 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 207 S predicate symbol p case p Poss Ax1 xn s condp pz1 zm doa s φpz1 zmn s successor state axiom casea uniﬁableφp z1 zmn ψ S S condp pz1 zmmguφp ψ elseif uniﬁableφpz1 zmn ψ cid15 S S condp pz1 zmmguφp ψ PROCEDURE UCStep Ax1 xn ψ Ax1 xn action ψ beliefstate formula 1 ψ atomic formula 2 3 4 5 6 7 8 9 10 11 use distribution properties follows 12 13 14 15 16 17 18 19 elseif ψ φ ϕ elseif ψ φ ψ φ ϕ ϕS ϕ return return UCStep Ax1 xn φ return UCStep Ax1 xn φ UCStep Ax1 xn ϕ return UCStep Ax1 xn φ UCStep Ax1 xn ϕ UCStep Ax1 xn TRUE elseif ψ x φx return x UCStep Ax1 xns φLLx condp TRUE case1 p case l p p Deﬁnition 18 Fig 4 One step unitcase ﬁltering 511 Example Consider bookkeeping robot example Section 221 Suppose rooms oﬃce lounge books C Java belief state formula inC Oﬃce inJava Lounge Assume students studying lounge need C tutorial book keeper robot decides book lounge The action moveC Oﬃce Lounge It unitcase successor state axioms Our algorithm UCF works follows First add precondition belief state formula The new belief state Oﬃce cid20 Lounge term precondition true inC Oﬃce inJava Lounge bookC roomOﬃce roomLounge We calculate ﬁltering atomic formulas belief state formula separately compute result distribution properties What follows formula atomic formulas based algorithm presented cid13 moveC Oﬃce Lounge cid14cid2 cid3 inJava Lounge Filter inC Lounge inC Oﬃce inJava Lounge Now suppose ﬁlter belief state receiving following observation The robot enters oﬃce observes book room A perfect ﬁltering algorithm guarantees cases book book robot room Assume belief state formula inC OﬃceinJava Lounge The observation x inx Oﬃce x TheBook Filteroψ cid9 TheBook C replace instance TheBook new belief state formula C 52 STRIPS domains In STRIPS domains 1837 actions conditional effects It means value predicate changes true changes FALSE remains STRIPS actions necessarily 11 Consequently STRIPS successor state axioms treated algorithm UCF unitcase Successor state axioms STRIPS domains form Possa s y1 ym l p p cid3 l p p y1 ym s φ case cid2 cid2 cid2 cid2 p cid3 y1 ym doa s cid2 case1 p case1 p l p case p φ1 cid3 p y1 ym s cid3 p y1 ym s cid3 8 φ j p previous section case p y1 ym s j cid2 l p TRUE FALSE Notice case j1 p y x j p assign equality subset parameters jk argument p jk p variable x x j1 p j1 p action variable y j p form y j1 p argument predicate p We instantiate action constants c1 cn An instantiated action equal Ac1 cn A case instantiation action casex1xnc1cn omit p j case Denote casea case Ac1 cn casex1xnc1cn j p simplicity 208 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 PROCEDURE FOSFcid13ai oi cid140icid2t ψ ai action oi observation ψ belief state formula oi ψ EAFOL form φ 1 t 0 return ψ 2 return MoveQuanaot FOSTRIPSStepat 3 FOSFcid13ai oi cid140icid2t1 ψ MoveQuanprecondat Moves quantiﬁers fresh variable names cid15 ci beliefstate formula ψsplit split clause ψ casesa E ϕ ϕ ψsplit l atomϕ l PROCEDURE FOSTRIPSStepa ψ action ψ 1 ψ x φx return x FOSTRIPSStepa φLLx 2 L fresh constant appear language 3 elseif ψ x φx return x FOSTRIPSStepa φx 4 5 6 7 8 9 10 11 12 13 14 literals affected TRUE literals affected FALSE E resolveoutl Eb cES c φ Eff Eff return φ S ψsplit E For l Effa l instance l pv cid15 cid15 cid15 cid10 pv pvEff pvEff cid10 Effa The deﬁnition splitting appears Eq 9 b Resolveout uses resolution instances l E After resolu tions select clauses mention instance l negation Fig 5 Firstorder STRIPS ﬁltering A STRIPS action affects truth value instantiated predicates keeps value An instantiated predicate predicate symbol arguments constants variables We refer set affected instantiated predicates Effa Effa p deﬁned follows cid6 Effa p p y1 ym yi1 v i1 cid7 cid7 case j pa cid2 yi1 ci1 cid3 case j p cid8 Effa Effa cid12 pPred Effa p number elements set Effa Therefore Effa p number elements set Effa p exactly number cases l p Effa Effa p total number cases stated predicate ﬂuent An affected literal atomic formula negation atom Effa negation atom literal pPred cid16 instantiation replacing variables terms negation Effa Our FirstOrder STRIPS Filtering FOSF algorithm presented Fig 5 A FOL formula EAFOL existential quantiﬁer appears scope universal quantiﬁer The input FOSF assumed belief state formula φ EAFOL refers number cid3 0 existential quantiﬁcations variables refers number cid3 0 universal quantiﬁcations variables equality observation formulas φ provided clausal form Step 5 algorithm splits clause clausal form φ cases It allow treating instances predicates affected differently affected We step splitting cases We split clause ϕ algorithm described Let pcid19v atom ϕ cid19v vector variables constants Then let cid19v j instantiation cid19v case deﬁned follows cid19v cid13w 1 wmcid14 w constant variable j pa w constant yi c j casea 1 cid19v cid13w 1 wmcid14 2 For 1 n 3 4 5 6 7 8 9 return pu1 um If w cid20 c j return TRUE Else set ui c j Else w variable If yi c j casea set ui c j Else set ui w A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 209 Fig 6 STRIPS example boxed literals affected ﬁlled ones We split clause ϕ ϕcid19v cid19v1 ϕcid19v cid19vlp cid2 case1 p l p case p ϕ cid3 9 Note treat case1 p require UniqueNames Axioms objects lp case p ϕ single literal affected action Also mentioned Example Let case cases The result p 1 x1 A case p 2 x1 cid20 A Let ϕ px1 B qx1 We split respect predicate p p A B q A cid2 cid3 x1 cid20 A px1 B qx1 10 The new clausal form φ divided parts clauses affected literals clauses affected literal The algorithm directly copies ﬁrst new belief state formula It adds consequences second affected literal exists new belief state formula The literals affected ones stay new belief state Then predicates Effa added new belief state formula positive negative literals depending change TRUE FALSE An example FOSF algorithm works shown Fig 6 The action moveJava Lounge Oﬃce You ﬁnd successor state axioms action Section 221 Based axiom cid2 Eff cid3 moveJava Lounge Oﬃce cid6 cid8 inJava Lounge inJava Oﬃce The line ﬁgure current belief state Some instances ﬁrst literal belief state affected inJava Lounge affected book inb Lounge affected We split clause clauses There literal clauses affected unaffected instances The middle line ﬁgure shows belief state splitting cases In ﬁrst clause literals affected try resolve clauses knowledge base clauses discarded The second clause affected literal We copy directly new belief state At end predicates EffmoveJava Lounge Oﬃce added positive negative literals Theorem 20 Let action observation o belief state formula ψ EAFOL given FOSF input Assume progression ﬁrst order deﬁnable let l maximum number cases successor state axioms Assume case instantiates variables Then algorithm FOSF returns ﬁltering ψ o time O l ψ2Effa Proof See Appendix A12 cid3 Theorem 21 Let progression ﬁrstorder deﬁnable let C number constant symbols appearing domain description Let R maximum arity predicates m number predicates If ψ 2FOCNF2 length formula ﬁltering t actions a1 bounded O m2 R C2R term independent t The time taken ﬁltering action O m2 R C2R 2 An EAFOL kFOCNF clausal CNF size clause k 210 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 Proof See Appendix A13 cid3 Thus theorems polynomial time space guarantees ﬁltering polynomial number predicates length action sequence Importantly Theorem 21 gives bound size belief state representation ψ maintained T 0 steps This bound important ensuring tractable polynomial time ﬁltering indeﬁnitely inference time step polynomial ψ Notice result possible step ﬁltering results belief states size O ψ2 compounding T steps belief state size O ψ2T 6 Related works Several research streams AI concern problems relevant work We divide work relevant parts works logical AI Databases focus reasoning actions works stochastic ﬁltering state estimation Markov Chains works Philosophy Linguistics AI focus Belief Revision Update We choose cover learning dynamic systems scope related 1 details 61 Reasoning actions Our work closest works reasoning actions In general form Logical Filtering generalization Database Progression 663940 formal veriﬁcation Symbolic Model Checking 710 Belief Update 275528 Those works closest examine progression FOL theories In context work ﬁltering database progression stochastic ﬁltering While applying similar fundamental techniques progression ﬁlterings goals different types sought results It aims procedures process sequence actions tractably indeﬁnitely In series papers 513840 Lin Reiter deﬁned progression FOL theories showed ﬁltered belief state representation FOL They showed FOL progression set possibly inﬁnite FOL consequences uniform situation characterize progression correct answers queries FOL pertaining speciﬁed future ground situation term 6364 extended work showed FOL progression answer correctly entailment form α property φ true Those works compatible establish correctness FOL progression classes queries contain They concern tractability focus Somewhat closer works ﬁnd classes action theories progression tractable eﬃcient general 21 studied cases progression exploit correspondence situation calculus relational databases build systems reasoning actions It focuses tractability results based standard relational database technology assumes initial knowledge base complete initial belief state includes exactly state Following line research 4165 developed algorithms incomplete initial knowledge bases 41 developed algorithms applied proper initial knowledge roughly consistent local actions successor state axioms form F cid19x doa s γ F cid19x F cid19x s γ F cid19x disjunctions formulas form cid19za Acid19y φcid19y φ quantiﬁer free uniform s cid19y exclusive union cid19x cid19z However progression algorithm complete applied contextcomplete knowledge knowledge complete φ successorstate actions need applied This differs results effectively restrict form successorstate axioms assumptions completeness initial intermediate knowledge 65 extended work actions local effects showed progression ﬁrstorder deﬁnable They progression ﬁnite φ quantiﬁers includes variables appear cid19y strictly local effects Their ﬁniteness result important formulas grow exponentially progression step Theorem 2 65 computes projection results disjunction l disjuncts l number J models omit deﬁnition progression number worstcase exponential number ground atoms F cid19x γ F cid19x γ In contrast results focus progression grows linearly step Our results Sections 4 5 focus progression output size O f ψ ψ input databases f constant depends form action theory D Our ﬁnal result Theorem 21 gives stronger result bounding size progression T time steps T actions observations polynomial O T ψ2 input grows linearly T Such results critical practical ﬁltering long sequences actions observations A ﬁnal contrast previous results scope action domains apply Speciﬁcally results cid10 push2 shown Eq 6 Section 5 assume domain strictly local For example example action Section 421 strictly local effect action processed procedure 65 FF process linear time linear growth beliefstate representation progression step Finally related line work ones investigates Fluent Calculus 6061 computationally eﬃcient means updating belief states 60 introduces dual representation basic action theories based state update axioms explicitly deﬁne direct effects action It starts Situation Calculus successor state axioms A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 211 solve frame problem shows Fluent Calculus viewed result gradually improving logic improve inferential aspects 61 presents implementation technique progression based state update axioms use constraint solver Another work 24 extends ﬂuent calculus method belief change allows agents revise internal model making observations contradict model The main difference draw work update framework trades accuracy eﬃciency While updates generally eﬃcient results guaranteed precise representation FOL progression ones belief state These results useful purposes subroutines compute progression compilation Section 4 However computational analysis time space given author comparison hard 62 Propositional progression ﬁltering Previous works address tractable algorithms exact ﬁltering focus propositional cases intractability results general case 3 present eﬃcient logical ﬁltering algorithms maintain compact belief state representation indeﬁnitely broad range environment classes including nondeterministic partially observable successfulSTRIPS environments successfailure action known environments actions act 11 mapping states That work restricted propositional case Earlier research hardness belief revision update 1735 focused properties different update semantics showing ﬁnding query follows updated belief state coNPhard 8 showed many3 semantics discussed literature lead exponential growth representation size beliefstate representation scheme polynomial hierarchy collapse Our contribution focus different earlier work emphasis FOL tractable scalable ﬁltering techniques indeﬁnite online processing updates These computation time depends linearly number time steps We focus tractable cases apply belief update semantics easier analysis com putation Our approach focuses AI applications partially observable domains closer spirit dataintensive controltheory approaches tracking dynamic systems 63 Stochastic ﬁltering Early work beginning Gauss assumed stochastic models For example Kalman ﬁlter 26 ubiquitous device maintains multivariate Gaussian belief state n variables assuming linearGaussian transition sensor model Crucially O n3 update cost O n2 space requirement depend length observation sequence This type tractability permits Kalman ﬁlter run indeﬁnitely enables wellknown applications 5943 This type recursive estimation motivates term logical ﬁltering Stochastic ﬁltering reasoning probabilistic dynamic models area vast literature common everyday applications 45 Progress research divided Statistics 30 Artiﬁcial Intelligence 4716 Control Theory 4312 Research stochastic ﬁltering focuses Hidden Markov Models 5019 Dynamic Bayesian Networks 132348 Reasoning estimation models hard systems dynamics sensor model Gaussianlinear number state features modest size features cid3 2100 states The diﬃculty stochastic ﬁltering led early modern research focus reasoning techniques approximate model 59473066231 approximate inference model sampling 1516 Unfortunately require exponentialtime computations produce poor approximations cases approximations work practice applications especially transition model includes states deﬁned discrete variables 485 This diﬃculty second motivation work ﬁrst immediate applications 9 Logical Filtering close stochastic ﬁltering probabilities belief state transition model sensor model The ﬁlters ﬁrst input representation belief state σ0 S S PowP systems set states deﬁned propositional ﬂuents P ﬂuents state features change time The ﬁlters second input representation transition relation R S S cid13s s time t 1 t cid3 0 The ﬁlters ﬁnal input sequence representations observations o0T ot S given online fashion time step t cid2 T The ﬁlters task update belief state representation recursively σt returning σt requested accounts exactly states consistent σ0 R o0t cid10cid14 R iff state s time t transition state s cid10 An inquiry logical ﬁltering typical inference logical knowledge bases satisﬁability checking possible A B entailment A B checking feasibility state state inHandB onTable A possible 3 They WIDTIO When In Doubt Throw It Out semantics compact representation This discard information achieve compact representation 212 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 64 Belief revision update FOL Important research related usage FOL belief update holder belief formula supplying semantics involved different revision tasks Examples ﬁrst 1114 ﬁrstorder AGM belief revision 66 belief update revision simple subclasses FOL An important difference draw works provides eﬃcient inference procedures lines work focus use generalpurpose theorem provers provide intractability results 34 presents approach incorporating new piece knowledge knowledge bases actions change Their approach different belief revision operations consider criterion A possible cause explaining new fact effects possible cause added causeeffect relations maintained This called possible cause approach PCA Interestingly set works examined question belief update progression related 36 shows different semantics belief update expressed single framework reasoning actions That framework considered common core update formalisms In direction 29 shows belief update speciﬁc case feedbackfree action progression It presented reverse update regression update progression Similarly works iterated belief revision 5425 examine belief change associated performing actions They assume theory action represented situation calculus extended deal belief Their belief revision corresponds observations belief update corresponds update actions 7 Conclusions We presented semantics methodology eﬃcient ﬁltering domains include objects Some algorithms allow objects identity certain We generalized problem ﬁltering FOL formulas ground actions FOL observations Previous results guarantee FOL representations suﬃcient ﬁltering We showed ﬁltering solvable polynomial time actions map states 11 precompilation domain actions casebased representation includes STRIPS actions success failure observed We showed 11 actions allow ﬁlter FOL belief state formulas linear time time step size beliefstate representation given algorithm computing progression atomic formulas assuming algorithm compiles domain terminates ﬁltering commences When actions successfulSTRIPS UnitCase ﬁlter arbitrary belief state formulas eﬃciently pre compilation We showed class actions belief states roughly corresponding conjunctions ﬁrstorder clauses size 2 belief state formulas guaranteed remain represented compactly polynomial size initial belief state representation number time steps T arbitrary actionobservation sequence lengths T Those cases mit ﬁltering actions observations indeﬁnitely polynomial time number predicates constants domain Tractable ﬁltering important practical everyday life applications Technologies ones presented paper important practical naturallanguage processing NLP autonomous agents robotics WWW domains 9 game playing 49 state estimation generally 22 In applications crucial processing eﬃcient large numbers states large domains The eﬃcient processing algorithms reported paper hope derived future key new applications domains We expect uses algorithms domains hope help introducing FOLbased tractable applications mainstream AI including NLP autonomous agents robot motion planning worldstate estimation partial knowledge games Acknowledgements We wish thank Megan Nance Adam Vogel useful discussions related topics We thank diligent reviewers editors Artiﬁcial Intelligence Journal helping improve manuscript signiﬁcantly Finally wish acknowledge support DAF Air Force Research Laboratory Award FA87500420222 DARPA REAL program National Science Foundation CAREER grant 0546663 Appendix A Proofs A1 Proof Theorem 7 Filtering algorithm We lefthand contained righthand cid3 cid2 Filtera cid10 FilteraS cid9S ψ From Deﬁnition 6 S S S cid9S ψ cid13S S cid7 cid8 cid7 cid9Scid10 Filteraψ S cid9S ψ cid6 S cid10 Take S S cid9S ψ cid13S S cid10cid14 RD cid10cid14 RD In words A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 213 To prove theorem need cid9Scid10 Filteraψ S restricted ﬁrstorder language L Let P set constants predicates L For element P g P deﬁne new symbol g S The set new symbols called P cid10 We deﬁne structure S g righthand Note S S cid10cid10 g S g language L P cid10 new symbol g cid10cid10 g S cid10 P cid10 g cid10S cid10cid10 cid10 cid10 cid10 cid10 cid10 cid10cid10 S g P g S We claim cid9Scid10cid10 ξ ξ ψ preconda y1 ym p cid10 y1 ym succpi y1 ym cid10 cid10 z f cid10 z succ f az cid10cid10 model ξ conjuncts falsiﬁed This case ψ preconda choice S S cid10 y1 ym succpi y1 ym hold From Assume contradiction case p cid10 way deﬁned RD case The way deﬁne p S based structure S guarantees cid10 y1 ym succpi y1 ym equivalent This contradicts assumption Thus cid9Scid10cid10 ξ Therefore cid9Scid10cid10 p P cid10 ξ models Cn Cn If replace symbols P cid10 Therefore cid9Scid10 Filteraψ ξ LP cid10 restriction S corresponding symbols P S LP cid10 refer S cid10cid10cid10 equal S ξ Since language Cn P cid10 P cid10 cid10cid10cid10 cid10cid10 cid10 A2 Proof Corollary 8 We sets structures elements By Theorem 7 know lefthand equality contained righthand cid2 Filtera S cid9S ψ cid3 cid6 cid10 S cid7 cid8 cid7 cid9Scid10 Filteraψ For opposite direction showing righthand contained lefthand suppose encode lefthand ﬁrstorder formula ϕ Formula ϕ holds members lefthand To prove opposite direction need Filteraψ cid9 ϕ Every model Filteraψ righthand equation model ϕ lefthand equation In words righthand subset lefthand To prove statement use following lemma Lemma 22 Let ϕcid10 formula computed replacing predicate p y1 ym ϕ succpa y1 ym We prove ψ preconda cid9 ϕcid10 Proof See Section A3 cid3 We know ϕcid10 ϕpi y1 ymsuccpi y1 ym use lemma ψ preconda cid10 cid10 ψ preconda y1 ym p cid10 y1 ym succpi y1 ym cid9 ϕcid10 Therefore y1 ymz f cid10 z succ f az cid9 ϕPP cid10 proof Filteraψ cid9 ϕ A3 Proof Lemma 22 By contradiction assume case There structure S cid9S ψ preconda S model cid10cid14 RD Since cid9S ψ cid9S preconda observing way RD deﬁned S ϕcid10 cid10 FilteraS cid9S ψ We encode FilteraS cid9S ψ formula ϕ So cid9Scid10 ϕ S cid13S S cid10 Since replaced predicate p ϕ succpa getting ϕcid10 cid9Scid10 ϕ cid13S S cid10cid14 RD conclude cid9S ϕcid10 This contradicts assumption A4 Proof Theorem 10 Progression possibility We want prove Dg Ds2 cid9 ψ iff Dg Ds0 cid9 ψ Proving forward direction easy We assume Dg Ds2 cid9 ψ prove Dg Ds0 cid9 ψ By deﬁnition 214 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 Ds2 Ds1 Cns2 Dss12 Cns1 Dss01 Dap12 Dap01 Ds1 Ds0 Therefore Dg Dss12 We conclude Dap12 Ds1 cid9 ψ consequence ﬁnding procedure sound Now replace Ds1 deﬁnition Dg Dss12 Dap01 Dsst1t Dapt1t Dg conclude Dg Ds0 Dap12 Dss01 Ds0 cid9 ψ cid9 ψ For opposite direction formula ψ uniform doa2 doa1 s0 Dg Ds0 cid9 ψ Dg Ds2 cid9 ψ We rewrite Dg formula cid9 ψ Dg Ds0 Dg Dss01 Dap01 Dss12 Dap12 Ds0 cid9 ψ From deduction theorem Dss01 Dap01 Ds0 cid9 Dg Dss12 Dap12 ψ We use following lemma Lemma 23 Let ϕ ψ ﬁrstorder formulas f T ground function Lϕ Lψ Let ϕ f T R formula obtained replacing x φ f x φ x x cid20 T φ φxT replacing instance f T R Then ϕ cid9 ψ ϕ f T R cid9 ψ f T R R new constant symbol Using lemma replace doa1 s0 s1 doa2 s1 s2 equation note a1 a2 s0 s1 s2 constants After replacement intersection language sides cid9 include s0 s2 function Now applying Craigs interpolation theorem FOL ϕ LDss01 Dap01 Ds0 LDg Dss12 Dap12 ψ Dap01 Dss01 ϕ cid9 Dg Dss12 Ds0 cid9 ϕ Dap12 ψ Next replace s1 s2 doa1 s0 doa2 doa1 s0 respectively result previous lemma know replacement affect entailment Since ϕ include term sort situation doa1 s0 uniform doa1 s0 From deﬁnition Ds1 infer ϕ Ds1 Therefore Ds1 Dss12 cid9 Dg Dss12 Ds1 Dap12 Dap12 ψ cid9 Dg ψ With argument prove Ds2 cid9 Dg ψ opposite direction A5 Proof Lemma 23 By contradiction assume ϕ cid9 ψ ϕ f T R cid20cid9 ψ f T R There structure M cid9M ϕ f T R M constant symbol R With equal M f T M cid10 R M M cid10 cid10 model ψ f T R Deﬁne M cid10 deﬁnition M We deﬁne M equal M clear cid9Mcid10 ϕ Given assumption cid9Mcid10 ψ cid10cid10 cid10 new constant symbol R R M We conclude M differ interpretation f T ψ f T R cid10cid10 cid10cid10 f T M cid10 cid10cid10 model ψ f T R M new M evaluation f T Therefore cid9M ψ f T R The direction proved similarly A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 215 A6 Proof Theorem 11 Distribution connectives The proof ﬁrst parts similar proof given 3 propositional ﬁltering We use result stated Corollary 8 proof 1 Take structure S cid10 satisﬁes Filteraϕ ψ Then structure S satisﬁes ϕ ψ RDS S 2 Take structure S cid10 Thus S satisﬁes ϕ ψ S complete setting ﬂuents Therefore S Filteraψ It follows Filteraϕ ψ Filteraϕ Filteraψ For direction S Thus structure S RDS S Filteraϕ ψ It follows Filteraϕ ψ Filteraϕ Filteraψ satisﬁes Filteraϕ Filteraψ Then satisﬁes Filteraϕ Filteraψ satisﬁes cid10 S satisﬁes ϕ ψ Thus S satisﬁes ϕ ψ S satisﬁes Filteraϕ ψ Then structure S satisﬁes ϕ ψ RDS S cid10 Thus S satisﬁes ϕ ψ Thus S satisﬁes Filteraϕ ψ satisﬁes Filteraϕ Filteraψ It follows cid9 Filteraϕ ψ Filteraϕ Filteraψ cid10 S satisﬁes ϕ satisﬁes FilteraTRUE structure S satisﬁes Filteraϕ It follows cid9 Filteraϕ Filteraϕ satisﬁes Filteraϕ FilteraTRUE Then structure S RDS S Filteraϕ Filteraψ We conclude S cid10 This S satisﬁes ϕ S cid10 S satisﬁes ϕ Since S Thus structure S RDS S R D S S FilteraTRUE cid10 cid10 cid10 cid10 cid10 cid10 cid10 3 Take S cid10 Filteraϕ cid10 4 We Skolemization We sets world structures equal We ﬁrst lefthand equation contained righthand cid2 Filtera cid3 x ϕx cid2 x Filtera cid3 ϕL Lx Take structure M cid9M F ilterax ϕx We cid9M x FilteraϕLLx Based Theorem 7 cid9M Filterax ϕx iff M Filtera cid2cid6 cid7 cid7 cid9S x ϕx cid3cid8 S Based Deﬁnition 6 cid6 cid7 cid7 cid9S x ϕx Based Deﬁnition 5 exists S RD S S M S cid8 cid4 cid5 cid10 cid10 cid9S x ϕx cid9S preconda S M p M f M cid6 cid7 cid8 cid7 cid9S succpav 1 vm cid13v 1 vmcid14 cid7 cid8 cid6 cid7 cid9S succ f av 1 vr cid13v 1 vrcid14 We deﬁne S Lϕ equal S additional mapping new constant symbol L v S cid9S ϕv In case cid9S Lϕ ϕL We progress S Lϕ action cid3 S Lϕ iff M cid7 cid7M p M cid2 cid10 Filtera cid7 cid7 S Lϕ cid10 cid6 cid10 cid10 f M cid7 cid8 cid7 cid9S Lϕ succpav 1 vm cid13v 1 vmcid14 cid7 cid8 cid6 cid7 cid9S Lϕ succ f av 1 vr cid13v 1 vrcid14 We conclude cid9Mcid10 F ilteraϕL Deﬁne DL equal D extra constant symbol L We M restriction M behaves like M element domain symbol L cid10 cid10 symbols D We use following lemma complete proof Lemma 24 Take ψ LDL prove cid9M x ψLx iff M cid10 cid9Mcid10 ψ M restriction M cid10 LψL 216 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 Proof See Section A7 cid3 With lemma proof complete The All conclusions proved A7 Proof Lemma 24 Suppose lefthand true righthand cid10 cid9Mcid10 ψ M restriction M cid9M x ψ Xx iff M cid10 LψL cid10 It means structure M existential quantiﬁer true Add constant X M X v new structure M restriction M Lψ X We conclude lefthand implies righthand models ψ M restriction M Assume v M x makes cid10cid10 cid9Mcid10cid10 ψ M cid10cid10 cid10 Now suppose righthand true lefthand The element domain associated X satisfy existential quantiﬁer proof A8 Proof Theorem 13 cid10 Theorem 11 supplies proof 1 direction 2 direction 3 proof 4 We left prove direction 2 direction 3 similar propositional case 3 For 2 let S Filteraψ For Filteraϕ structure S RDS S structure S1 RDS1 S structures structure maps S Filteraϕ ψ It follows cid9 Filteraϕ ψ Filteraϕ Filteraψ structure satisﬁes Filteraϕ Filteraψ Then satisﬁes Filteraϕ cid10 S satisﬁes ϕ Similarly Filteraψ cid10 S1 satisﬁes ψ However acts onetoone mapping satisﬁes Thus S S1 S satisﬁes ψ S satisﬁes ϕ ψ S For 3 let S structure satisﬁes Filteraϕ Then structure S satisﬁes ϕ cid10 Thus S satisﬁes ϕ Since acts onetoone mapping structure maps cid10 So S There structure S1 satisﬁes ϕ RDS1 S satisfy Filteraϕ cid10 satisﬁes Filteraϕ FilteraTRUE It satisﬁes FilteraTRUE So S RDS S cid10 S satisﬁes Filteraϕ Clearly S follows cid9 Filteraϕ Filteraϕ FilteraTRUE cid10 cid10 cid10 cid10 cid10 A9 Proof Theorem 14 By Theorem 13 know algorithm FF correct It decomposes ψ preconda atomic subformulas distribution properties Since assume ﬁltering atomic formulas precomputed table retrieve time F combine results Therefore time complexity algorithm O ψ preconda F A10 Proof Theorem 17 Using formula 1 clause formula 1 set 7 Φ 7 consequence formula 1 We repeat formula 1 1 Filteraψ P cid10 Cn cid9 cid9 ψ preconda cid10 cid10 y1 ym p cid10 y1 ym succpi y1 ym cid11cid11 z f cid10 z succ f az P cid10P 2 Filteroψ ψ o cid10 n consequence formula 1 applying P cid10P We want ψ preconda cid9 Suppose Φp Φsuccp1a succpna By deﬁnition cid10 cid10 1 p ψ preconda y1 ym p cid10 y1 ym succpi y1 ym z f cid10 z succ f az cid9 Φ cid2 cid3 cid10 1 p cid10 n p cid10 We refer lefthand ξ Therefore structure M cid9M ξ cid9M Φp p cid10 1 p cid10 equivalent succpi M conclude cid9M Φsuccp1a succpna As result ξ cid9 Φsuccp1a succpna cid10 n value A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 217 Since p consists equivalence formulas p cid10 appear Φsuccp1a succpna conclude ψ preconda cid10 One direction proof cid9 Φsuccp1a succpna rest ξ Now direction Φp1 pn set 7 ξ cid9 Φp cid10 1 p cid10 n Since ψ preconda cid9 Φsuccp1a succpna trivial A11 Proof Theorem 19 Correctness To prove algorithm UCF returns ﬁltering ψ correctly use result Theorem 17 We want ﬁnd Φp1 pns ψ preconda cid9 Φsuccp1a succpna The algorithm FilterTrue ﬁnds Φs true cid9 Φsuccp1a succpna In words Φsuccp1a succpna tautology Since φp s unit clauses size tautologies 2 The algorithm checks uniﬁability pair φp φpcid10 ﬁnds tautologies size 2 Next need ﬁnd Φs ψ preconda cid9 Φsuccp1a succpna With Theorem 13 divide ψ preconda atomic formulas Let q atomic formula want ﬁnd Φs q cid9 Φsuccp1a succpna We rewrite true cid9 q Φsuccp1a succpna Therefore q Φsuccp1a succpna tautology 6 UCStep ﬁnds Φs Complexity Suppose t successor state axioms divide k instantiated successor state axioms form cid2 Poss Ax1 xn s cid3 cid2 condp cid2 cid2 cid3 z1 zm doa s p p φpz1 zmn s cid3cid3 l l1 1 lt 1 The ﬁrst successor state axiom breaking instantiated successor state axioms results l1 1 new axioms We easily verify size ﬁrst l1 axioms 2 size l1 1th axiom O Rl1 Therefore total size instantiated successor state axioms 2l1 Rl1 2lt Rlt O Rl Since ψ preconda atomic formulas atomic formula size resulted formula ﬁltering In addition size successor state axioms size returned formula O Rlψ preconda constant formula ﬁltering TRUE add resulted formula Suppose size instantiated successor state axioms x1 xl The size ﬁltering TRUE ΣiΣ jxi x j Σilxi Σ j x j O Rl2 The size formula O Rl2 Rlψ preconda For computing time complexity run FilterTrue takes O l2 run UCStep single literal takes O l time Therefore time complexity space complexity O Rl2 Rlψ preconda A12 Proof Theorem 20 Correctness To prove algorithm FOSF returns ﬁltering ψ correctly use result Theorem 17 We want ﬁnd Φp1 pns ψ preconda FOSTRIPSStep ﬁnds Φs ψ preconda cid9 Φsuccp1a succpna cid9 Φsuccp1a succpna resolution φp s TRUE FALSE literal We refer set Φs returns ξ We need ψ preconda cid9 c cid10succp1a succpna c cid10 clause clause ξ subsumes cid10p1 pn c cid10 c succp1a succpna t1 tm ti TRUE FALSE subsumed terms 14 FOSTRIPSStep ti Effa resolution complete c computed 11 Complexity Suppose length belief state formula ψ The ﬁrst lines recursive calls algorithm O ψ time Splitting pure literal clauses takes O E ψ time size resulted formula E S S cid2 ψ clause original belief state broken multiple clauses case number ones added E number ones added S broken added directly E S number clauses ψ cid10 After splitting cases literal instance member Effa resolved E This process terminate general assume theorem cases leave variable uninstantiated This reduces resolution variables propositional resolution guaranteed terminate More speciﬁcally l different literals instantiated way affected literal Effa Thus size E resolution cid2 l ψ After resolution Es size increases l ψ2Effa The time complexity resolution depends size resulting set algorithm takes O l ψ2Effa resulting belief state size 218 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 A13 Proof Theorem 21 The number different literals possible m predicates maximum arity R C constants bounded 2m R CR m predicates Thus total number 2clauses possible m predicates arity R C constants unbounded number variables bounded 2m R CR 2 Since clauses algorithm 2clauses number clauses maintained belief state time t size O m2 R C2R The time complexity follows bound size resulting formula noticing majority time spent procedure resolution deriving resolvents bound References 1 Eyal Amir Allen Chang Learning partially observable deterministic action models Journal Artiﬁcial Intelligence Research 33 2008 349402 2 Eyal Amir Sheila McIlraith Partitionbased logical reasoning ﬁrstorder propositional theories Artiﬁcial Intelligence 162 12 2005 4988 3 Eyal Amir Stuart Russell Logical ﬁltering Proc Eighteenth International Joint Conference Artiﬁcial Intelligence IJCAI 03 Morgan Kaufmann 2003 pp 7582 4 A Blass Y Gurevich Background reserve Gandy machines P Clote H Schwichtenberg Eds Computer Science Logic Proceedings CSL 2000 LNCS vol 1862 Springer 2000 pp 117 5 Georg Böker Jan Lunze Stability performance switching Kalman ﬁlters International Journal Control 75 1617 2002 12691281 6 Xavier Boyen Daphne Koller Tractable inference complex stochastic processes Proc Fourteenth Conference Uncertainty Artiﬁcial Intelli gence UAI 98 Morgan Kaufmann 1998 pp 3342 7 Jerry R Burch EdM Clarke Ken L McMillan David L Dill LJ Hwang Symbolic model checking 1020 states Proceedings Fifth Annual IEEE Symposium Logic Computer Science IEEE Computer Society Press Washington DC 1990 pp 133 8 Marco Cadoli Francesco M Donini Paolo Liberatore Marco Schaerf The size revised knowledge base Artiﬁcial Intelligence 115 1 1999 2564 9 Allen Chang Eyal Amir Goal achievement partially known partially observable domains Proceedings 16th Intl Conf Automated Planning Scheduling ICAPS 06 AAAI Press 2006 10 Edmund M Clarke Armin Biere Richard Raimi Yunshan Zhu Bounded model checking satisﬁability solving Formal Methods System De sign 19 1 2001 734 11 Maria R Cravo João P Cachopo Ana C Cachopo João P Martins Permissive belief revision EPIA 2001 pp 335348 12 Jon H Davis Foundations Deterministic Stochastic Control Birkhäuser Boston 2002 13 Tom Dean Keiji Kanazawa A model reasoning persistence causation Computational Intelligence 5 3 1989 142150 14 Simon Dixon Wayne Wobcke The implementation ﬁrstorder logic AGM belief revision ICTAI 1993 pp 4047 15 Arnaud Doucet Nando Freitas Kevin Murphy Stuart Russell RaoBlackwellised particle ﬁltering dynamic Bayesian networks Proc Sixteenth Conference Uncertainty Artiﬁcial Intelligence UAI 00 Morgan Kaufmann 2000 pp 176183 16 Arnaud Doucet Nando De Freitas Neil Gordon Eds Sequential Monte Carlo Methods Practice Statistics Engineering Information Science SpringerVerlag 2001 17 Thomas Eiter Georg Gottlob On complexity propositional knowledge base revision updates counterfactuals Artiﬁcial Intelligence 57 23 October 1992 227270 18 Richard Fikes Peter Hart Nils Nilsson Learning executing generalized robot plans Bonnie Webber Nils Nilsson Eds Readings Artiﬁcial Intelligence Morgan Kaufmann 1981 pp 231249 19 Zoubin Ghahramani Michael I Jordan Factorial hidden Markov models Machine Learning 29 1997 245275 20 Zoubin Ghahramani An introduction Hidden Markov Models Bayesian networks International Journal Pattern Recognition Artiﬁcial Intelligence 15 1 2001 942 21 G De Giacomo T Mancini Scaling reasoning actions relational database technology Proc National Conference Artiﬁcial Intelli gence AAAI 04 2004 pp 245250 22 Hannaneh Hajishirzi Eyal Amir Sampling ﬁrstorder logical particles Proc Twenty Fourth Conference Uncertainty Artiﬁcial Intelligence UAI 08 2008 23 Finn V Jensen Steffen L Lauritzen Kristian G Olesen Bayesian updating recursive graphical models local computation Computational Statistics Quarterly 4 1990 269282 24 Yi Jin Michael Thielscher Representing beliefs ﬂuent calculus ECAI 2004 pp 823827 25 Yi Jin Michael Thielscher Actions belief revision A computational approach Belief Change Rational Agents 2005 26 Emil Kalman Rudolph A new approach linear ﬁltering prediction problems Transactions ASME Journal Basic Engineering Series D 5 1960 3545 27 Hirofumi Katsuno Ken Satoh A uniﬁed view consequence relation belief revision conditional logic John Mylopoulos Ray Reiter Eds Principles Knowledge Representation Reasoning Proc Second International Conference KR 91 Morgan Kaufmann Sydney Australia August 1991 pp 406412 28 Jérôme Lang Belief update revisited Proc Twentieth International Joint Conference Artiﬁcial Intelligence IJCAI 07 2007 29 Jérôme Lang Belief update revisited IJCAI 2007 pp 25172522 30 Steffen L Lauritzen Propagation probabilities means variances mixed graphical association models Journal American Statistical Association 87 1992 10981108 31 Joseph LaViola A comparison unscented extended Kalman ﬁltering estimating quaternion motion Proceedings American Control Conference vol 3 IEEE 2003 pp 24352440 32 Richard CharTung Lee A completeness theorem program ﬁnding theorems derivable given axioms PhD thesis University California Berkeley 1967 33 Hector J Levesque Fiora Pirri Ray Reiter Foundations situation calculus Electronic Transactions Artiﬁcial Intelligence 3 18 December 1998 httpwwwetaijorg 34 Renwei Li Luis Moniz Pereira What believed explained Proc AAAI 96 1996 pp 550555 35 Paolo Liberatore The complexity belief update Proc Fifteenth International Joint Conference Artiﬁcial Intelligence IJCAI 97 1997 pp 6873 36 Paolo Liberatore A framework belief update JELIA 00 Proceedings European Workshop Logics Artiﬁcial Intelligence Springer Verlag London UK 2000 pp 361375 37 Vladimir Lifschitz On semantics strips Michael P Georgeff Amy Lansky Eds Reasoning About Actions Plans Morgan Kaufmann Los Altos California 1986 pp 19 38 Fangzhen Lin Raymond Reiter State constraints revisited Journal Logic Computation 4 5 1994 655678 A Shirazi E Amir Artiﬁcial Intelligence 175 2011 193219 219 39 Fangzhen Lin Raymond Reiter How progress database II The STRIPS connection Proc Fourteenth International Joint Conference Artiﬁcial Intelligence IJCAI 95 Montreal Canada 1995 pp 20012007 40 Fangzhen Lin Ray Reiter How progress database Artiﬁcial Intelligence 92 12 1997 131167 41 Yongmei Liu Hector J Levesque Tractable reasoning incomplete ﬁrstorder knowledge dynamic systems contextdependent actions Proc Nineteenth International Joint Conference Artiﬁcial Intelligence IJCAI 05 2005 pp 522527 42 Bill MacCartney Sheila McIlraith Eyal Amir Tomas Uribe Practical partitionbased theorem proving large knowledge bases Proc Eighteenth International Joint Conference Artiﬁcial Intelligence IJCAI 03 Morgan Kaufmann 2003 pp 8996 43 Peter S Maybeck Stochastic Models Estimation Control Mathematics Science Engineering vol 141 Academic Press 1979 44 John McCarthy Patrick J Hayes Some philosophical problems standpoint artiﬁcial intelligence B Meltzer D Michie Eds Machine Intelligence vol 4 Edinburgh University Press 1969 pp 463502 45 Leonard A McGee Stanley F Schmidt Discovery Kalman ﬁlter practical tool aerospace industry Technical Memorandum 86847 NASA 1985 46 Sheila McIlraith Explanatory diagnosis Conjecturing actions explain observations Anthony G Cohn Lenhart Schubert Stuart C Shapiro Eds Principles Knowledge Representation Reasoning Proc Sixth Intl Conference KR 98 Morgan Kaufmann San Francisco California 1998 pp 167177 47 Thomas Minka A family algorithms approximate Bayesian inference PhD thesis MIT 2001 48 Kevin Murphy Dynamic Bayesian networks Representation inference learning PhD thesis University California Berkeley 2002 49 Megan Nance Adam Vogel Eyal Amir Reasoning partially observed actions Proc National Conference Artiﬁcial Intelligence AAAI 06 AAAI Press 2006 50 Lawrence R Rabiner A tutorial hidden Markov models selected applications speech recognition Proceedings IEEE 77 2 February 1989 257285 51 Raymond Reiter The frame problem situation calculus A simple solution completeness result goal regression V Lifs chitz Ed Artiﬁcial Intelligence Mathematical Theory Computation Papers Honor John McCarthy Academic Press 1991 pp 359380 52 Raymond Reiter Proving properties states situation calculus Artiﬁcial Intelligence 64 2 1993 337351 53 Raymod Reiter Knowledge Action Logical Foundations Describing Implementing Dynamical Systems MIT Press 2001 54 Steven Shapiro Maurice Pagnucco Iterated belief change exogeneous actions situation calculus ECAI 2004 pp 878882 55 Steven Shapiro Maurice Pagnucco Yves Lespérance Hector J Levesque Iterated belief change situation calculus Principles Knowledge Representation Reasoning Proc Seventh Intl Conference KR 2000 Morgan Kaufmann 2000 56 Afsaneh Shirazi Eyal Amir First order logical ﬁltering Proc Nineteenth International Joint Conference Artiﬁcial Intelligence IJCAI 05 Interna tional Joint Conferences Artiﬁcial Intelligence 2005 pp 589595 57 James R Slagle ChinLiang Chang Richard CT Lee Completeness theorems semantic resolution consequenceﬁnding Proc First International Joint Conference Artiﬁcial Intelligence IJCAI 69 1969 pp 281285 58 James R Slagle Interpolation theorems resolution lower predicate calculus Journal ACM 17 3 July 1970 535542 59 Gerald L Smith Stanley F Schmidt The application statistical ﬁlter theory optimal trajectory determination onboard circular vehicle American Astronautical Society Meeting 1961 pp 6192 60 Michael Thielscher From situation calculus ﬂuent calculus State update axioms solution inferential frame problem Artiﬁcial Intelli gence 111 1999 277299 61 Michael Thielscher Flux A logic programming method reasoning agents Theory Pract Log Program 5 45 2005 533565 62 Rudolph van der Merwe Eric A Wan The squareroot unscented Kalman ﬁlter state parameterestimation Proceedings IEEE International Conference Acoustics Speech Signal Processing ICASSP 2001 vol 6 2001 pp 34613464 63 Stavros Vassos Hector Levesque Progression situation calculus action theories incomplete information Proc Twentieth International Joint Conference Artiﬁcial Intelligence IJCAI 07 2007 64 Stavros Vassos Hector Levesque On progression situation calculus basic action theories Resolving 10yearold conjecture Proc National Conference Artiﬁcial Intelligence AAAI 08 2008 65 Stavros Vassos Gerhard Lakemeyer Hector J Levesque Firstorder strong progression localeffect basic action theories 11th International Conference Principles Knowledge Representation Reasoning AAAI Press 2008 66 MaryAnne Winslett Updating Logical Databases Cambridge University Press 1990