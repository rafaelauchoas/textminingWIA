Artiﬁcial Intelligence 170 2006 803834 wwwelseviercomlocateartint Propagation algorithms lexicographic ordering constraints Alan M Frisch Brahim Hnich b Zeynep Kiziltan c Ian Miguel d Toby Walsh e Department Computer Science University York UK b Faculty Computer Science Izmir University Economics Turkey c DEIS University Bologna Italy d School Computer Science University St Andrews UK e National ICT Australia Department CS E UNSW Australia Received 12 April 2005 received revised form 24 March 2006 accepted 27 March 2006 Abstract Finitedomain constraint programming great success tackle wide variety combinatorial problems industry academia To apply ﬁnitedomain constraint programming problem modelled set constraints set decision variables A common modelling pattern use matrices decision variables The rows andor columns matrices symmetric leading redundancy systematic search solutions An effective method breaking symmetry constrain assignments affected rows columns ordered lexicographically This paper develops incremental propagation algorithm GACLexLeq establishes generalised arc consistency constraint On operations n length vectors Furthermore paper shows decomposing GACLexLeq primitive constraints available current ﬁnitedomain constraint toolkits reduces strength increases cost constraint propagation Also presented extensions modiﬁcations algorithm handle strict lexicographic ordering detection entailment vectors unequal length Experimental results number domains demonstrate value GACLexLeq 2006 Elsevier BV All rights reserved Keywords Artiﬁcial intelligence Constraints Constraint programming Constraint propagation Lexicographic ordering Symmetry Symmetry breaking Generalized arc consistency Matrix models 1 Introduction Constraints natural means knowledge representation For instance maths class timetabled 9 11am Monday helicopter carry passengers sum variables equal 100 This generality underpins success ﬁnitedomain constraint programming applied wide variety disciplines 27 To apply ﬁnitedomain constraint programming given domain problem ﬁrst characterised modelled set constraints set decision variables solutions satisfy A common pattern arising modelling process use matrices decision variables socalled matrix models 9 For example simple represent types functions relations way 15 Corresponding author Email addresses frischcsyorkacuk AM Frisch brahimhnichieuedutr B Hnich zkiziltandeisuniboit Z Kiziltan ianmdcsstandacuk I Miguel twcseunsweduau T Walsh 00043702 matter 2006 Elsevier BV All rights reserved doi101016jartint200603002 804 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 Concomitant selection matrix model possibility rows andor columns matrix symmetric Consider instance matrix model constraint problem requires ﬁnding relation R A B A B nelement melement sets interchangeable objects respectively The matrix M n columns m rows represent elements A B Each decision variable Mab assigned 1 0 indicate cid3a bcid4 A B R Symmetry introduced matrix columns rows indexed A B distinguishes position elements sets A B Given nonsolution problem instance nonsolution obtained permuting columns assignments andor permuting rows assignments This known row column symmetry 8 Since similar behaviour multidimensional matrices decision variables known generally index symmetry As documented symmetry lead great deal redundancy systematic search 8 As reviewed Section 25 paper lexicographic ordering constraints shown effective method breaking index symmetry This paper describes constraint propagation algorithm GACLexLeq en forces constraint Given lexicographic ordering constraint c propagation algorithm removes values domains constrained variables solution c This paper shows GACLexLeq establishes property called generalised arc consistencythat removes infeasible valueswhile quiring number operations linear number variables constrained The GACLexLeq algorithm incremental domain variable reduced algorithm reestablish generalised arc consistency working scratch Although examples experiments paper employ lexicographic ordering constraint break index symmetry note lexicographic ordering break symmetry operates variables instance The lexleader method 5 breaks symmetry identifying representative elements equivalence class symmetries instance adding lexicographic ordering constraint element equivalence class ensure representative allowed The paper organised follows Section 2 introduces necessary background Section 3 describes num ber applications evaluate approach Section 4 presents propagation algorithm lexicographic ordering constraint Then Section 5 discusses complexity algorithm proves algorithm sound complete Section 6 extends algorithm propagate strict ordering constraint detect entailment handle vectors different lengths Alternative approaches propagating lexicographic ordering constraint discussed Section 7 Section 8 demonstrates decomposing chain lexicographic ordering constraints lexicographic ordering constraints adjacent pairs vectors hinders constraint propagation Computa tional results presented Section 9 Finally conclude outline future directions Section 10 2 Background An instance ﬁnitedomain constraint satisfaction problem CSP consists ﬁnite set variables X variable X X ﬁnite set DX values domain ﬁnite set C constraints variables constraint cX1 Xn C deﬁned variables X1 Xn subset DX1 DXn giving set allowed combinations values That c nary relation A variable assignment maps variable given instance CSP member domain A variable assignment A said satisfy constraint cX1 Xn cid3AX1 AXncid4 relation denoted c A solution instance CSP variable assignment satisﬁes constraints An instance said satisﬁable solution unsatisﬁable Typically interested ﬁnding solutions optimal solution given objective function In presence objective function CSP instance instance constraint optimisation problem To impose total ordering constraints variables vectors variables underlying total ordering domains If domain totally ordered total order imposed And domains ﬁnite domain isomorphic ﬁnite set integers So shall simplify presentation considering domains ﬁnite sets integers AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 805 The minimum element domain variable X minX maximum maxX Throughout varsc denote set variables constrained constraint c If variable X singleton domain v v assigned X simply X assigned If Xcid6 If v Xcid6 write X variables X Xcid6 assigned value write X assigned X vcid6 assigned Xcid6 v vcid6 write X cid2 Xcid6 A constraint c entailed assignments values varsc satisfy c If constraint shown entailed running potentially expensive propagation algorithm avoided Similarly constraint c disentailed assignments values varsc violate c Observe constraint CSP instance shown disentailed instance solution 21 Generalised arc consistency This paper focuses solving CSP searching solution space assignments subsets variables Solution methods type use propagation algorithms inferences based domains constrained variables assignments satisfy constraint These inferences typically recorded reductions variable domains elements removed form assignment satisfying constraint solution At node search constraint propagation algorithms establish local consistency property A common example generalised arc consistency 19 Deﬁnition 1 Generalised arc consistency A constraint c generalised arc consistent GAC written GACc X varsc v DX assignment varsc assigns v X satisﬁes c Values variables X participating assignments known support assignment v X Generalised arc consistency established constraint c removing elements domains variables varsc GAC property holds For binary constraints GAC equivalent arc consistency AC 18 22 Vectors lexicographic ordering A onedimensional matrix vector ordered list elements We denote vector n variables cid7X cid3X0 Xn1cid4 denote vector n integers cid7x cid3x0 xn1cid4 In case subvector index index b inclusive denoted subscript ab cid7xab We deﬁne mincid3X0 Xn1cid4 cid3minX0 minXn1cid4 similarly maxcid3X0 Xn1cid4 cid3maxX0 maxXn1cid4 We ﬁne cid3x0 xn1cid4 cid3X0 Xn1cid4 true xi DXi 0 n 1 Finally deﬁne cid3X0 Xn1cid4 cid3Y0 Yn1cid4 true Xi Yi 1 n A vector distinct variables displayed vector domains corresponding variables For stance cid7X cid31 3 4 1 2 3 4 5 1 2cid4 denotes vector distinct variables domains 1 3 4 1 2 3 4 5 1 2 respectively Lexicographic ordering total ordering vectors instance order words dictionary Lexicographic ordering deﬁned equalsized vectors follows Deﬁnition 2 Strict lexicographic ordering cid7x lex cid7y length n vectors integers cid7x cid7y holds k 0 n case cid7x0k1 cid7y0k1 xk yk This ordering weakened include equality Deﬁnition 3 Two equallength vectors integers cid7x cid7y lexicographically ordered cid7x cid2lex cid7y cid7x lex cid7y cid7x cid7y Given equallength vectors variables cid7X cid7Y write lexicographic ordering constraint cid7X cid2lex cid7Y cid7Y These constraints satisﬁed assignment vectors strict lexicographic ordering constraint cid7X lex cid7x cid7y assigned cid7X cid7Y ordered according Deﬁnitions 3 2 respectively 806 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 23 Variable symmetry Various types symmetries arise instances CSP All symmetries considered paper variable symmetries A variable symmetry instance I CSP bijection σ variables I total variable assignment A solution I A σ functional composition A σ This obvious consequence identity function variable symmetry It means variable X domain σ X assignment mapped assignment As usual practice consider set symmetries problem instance set forms group This means inverse symmetry symmetry composition symmetries Such set symmetries called symmetry group Two assignments A Acid6 said symmetric symmetry σ symmetry group A σ Acid6 A symmetry group partitions set total assignments CSP instance equivalence classes called symmetry classes members equivalence class pairwise symmetric Notice members symmetry class solutions Symmetry CSP instance introduces symmetry search space partial assignments The subtrees rooted symmetric partial assignments symmetric other1 solutions subtree symmetric subtree Since symmetric subtrees contain symmetric solutions need search solutions transformed solutions simply applying relevant symmetry It important note search space contain symmetric subtrees contain solutions Thus cases instance solutions searching single solution subtrees symmetric encountered The search space partial assignments sped employing method avoids searching parts space symmetric parts searched Such method referred symmetry breaking Symmetry broken statically transforming problem instance fewer symmetries This achieved adding instance constraint called symmetrybreaking constraint true symmetric assignments 22 For example consider CSP instance variable symmetry swaps X Y Adding constraint X cid2 Y instance breaks symmetrythat resulting instance symmetry We talk set symmetrybreaking constraints considered constraint consisting conjunction members set We symmetrybreaking constraint c consistent CSP instance symmetry group c satisﬁed assignment symmetry class The constraint c complete satisﬁed assignment symmetry class Crawford et al 5 showed method generating set lexicographic ordering constraints consis tent complete breaking group variable symmetries It starts enumeration cid7X variables instance The set symmetrybreaking constraints contains constraint form cid3X0 Xn1cid4 cid2lex cid3σ X0 σ Xn1cid4 symmetry σ group Since set constraints large use practice subset andor simpliﬁcation constraints gives consistent incomplete set symmetrybreaking constraints For reason lexicographic ordering constraints widely breaking variable symmetries 24 Matrix models index symmetry A matrix model formulation CSP matrices decision variables 9 Matrix models natural way represent problems involve ﬁnding function relation For example warehouse location problem prob034 CSPLib 13 need ﬁnd function stores warehouses determines warehouse supplies store As second example steel slab design problem prob038 CSPLib need ﬁnd function orders slabs determines slab satisfy order Other examples encountered later paper Matrix models long integer linear programming 23 commonly constraint programming Of ﬁrst 38 problems CSPLib 33 matrix models published proved successful 9 1 For purposes paper precise deﬁnitions symmetric partial assignments symmetric search trees necessary AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 807 Matrices number dimensions examples paper dimensions If matrix X variables n dimensions denote elements Xi1in In twodimensional matrix refer ﬁrst dimension columns matrix second dimension rows In general values index matrix drawn ﬁnite set Without loss generality shall assume dimension n index values uses 0 n 1 index values Many matrix models variable symmetries variables matrix matrices A common pattern symmetry rows andor columns assignment 2D matrix swapped affecting assignment solution 9 These called row symmetry column symmetry general term index symmetry Deﬁnition 4 Let I CSP instance containing twodimensional matrix X variables A column symmetry I variable symmetry σ I bijection ρ column indices X σ Xij Xρij variable Xij matrix X σ Y Y variable matrix X A row symmetry column symmetry operates second index matrix ﬁrst Thus particular index matrix index symmetry σ corresponds unique bijection ρi values index We identify index symmetry ρ index operates Again interested groups index symmetries particularly groups kinds If bijec tion values index index symmetry index total symmetry If ﬁrst resp second index 2D matrix total symmetry matrix total column symmetry resp total row symmetry We columns resp rows matrix interchangeable In matrix models subset rows columns interchangeable Let I nonsingleton non subset values index matrix Let S set containing bijection ρ values index ρv v v I If member S index symmetry matrix partial index symmetry If ﬁrst resp second index 2D matrix partial symmetry matrix partial column symmetry resp partial row symmetry We columns resp rows I matrix interchangeable There ﬁnal case consider index partial index symmetry multiple subsets values For example CSP instance 2D matrix rows 1 2 3 interchangeable rows 5 6 7 interchangeable This occur indices Section 3 paper gives examples CSPs index symmetry An n m matrix total row total column symmetry nm symmetries Consequently costly visit symmetric branches tree search The subsection explains break symmetries 25 Lexicographic ordering constraints breaking index symmetry The application lexicographic ordering constraints considered paper breaking symmetries CSP instances matrices index symmetry This section summarises major results Flener et al 8 Shlyakhter 25 breaking index symmetries lexicographic ordering constraints If matrix CSP instance total column resp row symmetry symmetry broken completely symmetrybreaking constraint imposes total ordering rows resp columns The total ordering lexicographic ordering In particular constrain columns resp rows nondecreasing value index increases One way achieve experiments presented paper imposing constraint adjacent columns resp rows If X n m matrix decision variables break column symmetry imposing constraints cid3Xi0 Ximcid4 cid2lex cid3Xi10 Xi1mcid4 0 n 2 808 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 break row symmetry imposing constraints cid3X0j Xnj cid4 cid2lex cid3X0j 1 Xnj 1cid4 j 0 m 2 Though lexicographic ordering constraints consistent complete total row total column symmetry individually complete matrix kinds symmetry They consistent shown effective removing symmetries search spaces problems Care taken specifying constraints column constraints Xi0 signiﬁcant position column row constraints Xnj signiﬁcant position row conjunction constraints inconsistent symmetrybreaking constraint If matrix partial column resp partial row symmetry symmetry broken constraining interchangeable columns resp rows lexicographically nondecreasing order This achieved manner similar described The method extends matrices partial total column symmetry partial total row symmetry Finally columns andor rows matrix multiple partial symmetries broken manner described Though arise paper lexicographic ordering constraints similar manner break symmetry multidimensional matrices partial total index symmetry number dimensions 3 Applications This section presents matrix models combinatorial problems lexicographic ordering constraints break index symmetry These models experiments presented Section 9 31 Progressive party problem The progressive party problem arises context organising social programme yachting rally prob013 wwwcspliborg Given set boats number crew members capacity terms number guests accommodate problem designate minimal subset boats hosts schedule remaining boats visit hosts number halfhour periods All members particular guest crew remain crew host boats remain board boat A guest boat revisit host guest crews meet A simpliﬁed version problem studied Smith et al 24 removes objective function pre designating host boats asking schedule We study version problem Let Periods set time periods Guests set guest boats Hosts set host boats Each host boat k capacity ck taking crew consideration guest boat j crew size sj Smith et als matrix model problem given Fig 1 It comprises matrices H indexed Periods Guests B indexed Periods Guests Hosts If Hij k equivalently Bijk 1 period guest j visits host k Although B redundant given H allows capacity constraints speciﬁed concisely Constraint 1 ensures pair guest crews meet Note constraint subexpression Hij2 reiﬁed 1 0 value depending satisﬁed Hence summation counts Hij1 number periods guest crews j1 j2 assigned host value Constraint 2 disallows guest crew revisiting host boat course schedule Here sake presentation periods considered integers 0 p 1 Constraint 3 ensures capacity host boat exceeded Finally Constraint 4 channelling constraint 3 maintains consistency H B matrices The time periods interchangeable total symmetry ﬁrst index H ﬁrst index B2 Guests equal crew size interchangeable means partial symmetry second index H second index B Finally hosts equal capacity interchangeable partial symmetry index B 2 Observe symmetry matrices broken independently matrices This issue arises concision readdress AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 809 Given Periods Guests Hosts matrix ck indexed k Hosts matrix sj indexed j Guests Decision Variables matrix Hij domain Hosts indexed Periods j Guests matrix Bijk domain 0 1 indexed Periods j Guests k Hosts iPeriodsHij1 Constraints cid2 Hij2 cid2 1 1 2 alldifferentcid3H0j H1j Hp1j cid4 j Guests 3 4 Hij k Bijk 1 j Guests sj Bijk cid2 ck cid2 j1 j2 Guests j1 j2 Periods k Hosts Periods j Guests k Hosts Fig 1 Matrix model progressive party problem 24 Given T emplates Variations s matrix dj indexed j Variations Decision Variables matrix Runi domain 0 maxdj indexed T emplates matrix Tij domain 0 s indexed T emplates j Variations Constraints cid2 1 cid2 2 j Variations Tij s T emplates iT emplates Runi Tij cid3 dj j Variations Objective minimize cid2 iT emplates Runi Fig 2 Matrix model template design problem 21 32 Template design problem The template design problem prob002 CSPLib involves conﬁguring set printing templates design variations need printed meet speciﬁed demand Given set variations design common shape size number required pressings variation known The problem design set templates common capacity ﬁlled assigning zero instances variation template A design chosen minimises total number runs templates required satisfy number pressings required variation As example variations cartons different ﬂavours cat food ﬁsh chicken thousand ﬁsh cartons thousand chicken cartons need printed The problem design set templates assigning number ﬁsh andor chicken designs template minimal number runs templates required print thirty thousand cartons Proll Smith address problem ﬁxing number templates minimising total number press ings 21 We adopt model Let T emplates ﬁxedsize set templates capacity s variations assigned Let Variations set variations Each variation j described demand dj speciﬁes minimum number pressings required Proll Smiths model given Fig 2 It comprises matrices Run indexed T emplates T indexed T emplates Variations If Runi j template printed j times j ranges 0 maximum number pressings required single variation Similarly Tij k template assigned k instances variation j 0 cid2 k cid2 s 810 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 Given v b r k λ Let B 0 b 1 V 0 v 1 Decision Variables matrix Xij domain 0 1 indexed B j V Constraints cid2 1 cid2 2 cid2 3 iB Xij r j V Xij k iB Xij1 Xij2 j V B λ j1 j2 V j1 j2 Fig 3 Matrix model BIBD problem 20 Constraint 1 ensures template s slots occupied constraint 2 speciﬁes total production variation demand The objective minimise total number pressings In model templates interchangeable Run total symmetry index T total symmetry ﬁrst index Variations equal demand interchangeable total symmetry second index T 33 Balanced incomplete block design problem The balanced incomplete block design BIBD problem standard combinatorial problem design theory 4 applications experimental design cryptography prob028 CSPLib Given tuple natural numbers cid3v b r k λcid4 problem arrange v distinct objects b blocks block contains exactly k distinct objects object occurs exactly r different blocks distinct objects occur exactly λ blocks Meseguer Torras model 20 adopt paper given Fig 3 It comprises matrix X indexed B V B 0 b 1 set blocks V 0 v 1 set objects Xij 1 block contains object j Constraints 1 2 ensure respectively object appears r blocks block contains k objects Constraint 3 scalar product constraint requires pair objects meet exactly λ blocks Since objects blocks interchangeable matrix X total row total column symmetry 4 A propagation algorithm We present propagation algorithm lexicographic ordering constraint detects disentailment cid7X cid2lex cid7Y prunes inconsistent values establish GAC cid7X cid2lex cid7Y In order simplify presentation entire paper consider case cid7X cid7Y variabledistinct following sense Deﬁnition 5 A pair vectors variabledistinct contains CSP variables contains repeated variables variables common vectors Note majority applications described previous section involve ordering variable distinct vectors Kiziltan 17 gives algorithm similar presented caters cases variables repeated In presence repeated variables algorithms given following simple expedient Consider constraint c occurrences variable X We replace c ccid6 X Xcid6 Xcid6 domain X ccid6 results replacing occurrence X c Xcid6 This step repeated remove repeated occurrences single variable This approach preserves soundness completeness The key algorithm signiﬁcant indices cid7X cid7Y The index α index cid7X cid7Y ground equal If index α n The index β index α n AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 811 cid7Xβn1 lex regions cid7X cid7Y indices α β cid7Yβn1 entailed If index β n 1 The algorithm needs consider 41 A worked example We illustrate GACLexLeq algorithm considering operation lexicographic ordering constraint cid7X cid2lex cid7Y cid7X cid7Y variabledistinct domains cid7X cid7Y cid4 1 3 4 1 2 3 4 5 1 2 3 4 5 cid4 0 1 2 3 4 0 1 0 1 2 cid3 1 2 cid3 1 2 0 1 2 2 1 The program variables alpha beta record values α β When domains cid7X cid7Y reduced alpha beta longer contain values α β algorithm needs update program variables We traverse vectors order initialise alpha beta Starting index 0 ﬁrst index Y1 We stop 2 set alpha 2 α Y2 assigned 1 index 2 X0 cid3 1 2 cid3 1 2 0 1 2 alpha cid7X cid7Y 2 Y0 X1 1 3 4 1 2 3 4 5 1 2 3 4 5 0 1 2 3 4 0 1 0 1 2 1 cid4 cid4 We initialise beta traversing vectors starting alpha At index 2 minX2 maxY2 X2 cid3 Y2 entailed Hence β equal 2 determined examining variables greater indices At index 3 minX3 maxY3 This precludes conﬁrms β 2 At index 4 possible satisfy X4 cid2 Y4 Hence determined β cid11 2 At index 5 minX5 maxY5 X5 cid3 Y5 entailed Similarly β equal 5 determined examining variables greater indices At index 6 minX6 maxY6 X6 Y6 entailed Hence cid7X56 lex cid7Y56 entailed β 5 beta initialised cid3 cid7X 1 2 cid3 cid7Y 1 2 0 1 2 alpha 1 3 4 1 2 3 4 5 0 1 2 3 4 1 2 0 1 beta cid4 3 4 5 cid4 0 1 2 1 2 The algorithm restricts domain pruning index alpha As values removed domains variables value alpha monotonically increases value beta monotonically decreases The constraint disentailed values alpha beta equal Consider vectors As vectors assigned equal indices alpha support value DYalpha minXalpha We remove 0 1 DYalpha increment alpha 3 α cid3 1 2 2 1 3 4 1 2 3 4 5 1 2 cid3 0 1 2 3 4 0 1 1 2 2 beta Similarly support value DXalpha greater maxYalpha We remove 3 4 DXalpha increment alpha 4 α cid4 3 4 5 cid4 0 1 2 1 alpha cid7X cid7Y cid7X cid7Y cid3 1 2 2 1 1 2 3 4 5 1 2 cid3 1 2 2 1 0 1 2 3 4 0 1 alpha beta cid4 cid4 3 4 5 0 1 2 Since alpha beta 1 support value DXalpha greater equal maxYalpha Similarly support value DYalpha equal minXalpha We establish arc consistency Xalpha Yalpha Doing removes 4 5 DXalpha 0 1 DYalpha cid7X cid7Y cid3 1 2 2 1 1 2 3 cid3 1 2 2 1 2 3 4 3 4 5 0 1 2 cid4 cid4 1 2 0 1 alpha beta 812 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 The constraint cid7X cid2lex cid7Y GAC 42 Theoretical background This section formally deﬁnes α β presents theorems signiﬁcance propagating constraint cid7X cid2lex cid7Y Deﬁnition 6 Given length n variabledistinct vectors cid7X cid7Y α index 0 n Xα index exists n Yα Deﬁnition 7 Given length n variabledistinct vectors cid7X cid7Y β index α n k β n cid5 cid6 minXk maxYk min cid7Xβk1 max cid7Yβk1 index exists n 1 The relative values α β provide important information constraint cid7X cid2lex cid7Y By deﬁnition β strictly α The following theorems turn address cases α β α β The ﬁrst theorem states α β constraint disentailed Theorem 1 Let cid7X cid7Y pair length n variabledistinct vectors α β cid7X cid2lex cid7Y disentailed If cid7X cid2lex cid7Y0α1 Deﬁnition 7 cid7Xβn1 lex Proof By Deﬁnition 6 cid7X0α1 assignment satisfy cid7X cid2lex cid7Y disentailed cid7X lex cid7Y cid7Y entailed From deﬁnition strict lexicographic ordering index minXi maxYi Let j index If j 0 Deﬁnitions 6 cid7Y0j 1 7 α j β Otherwise observe minXh cid2 maxXh h 0 j 1 If cid7X0j 1 Yg Then Deﬁnition 6 α j Deﬁnition 7 β j Otherwise let g j index Xg Deﬁnition 6 g α Deﬁnition 7 g β cid2 cid7Yβn1 entailed Since β α The second theorem states β α constraint GAC α n values index α support Theorem 2 Let cid7X cid7Y pair length n variabledistinct vectors β α GAC cid7X cid2lex cid7Y 1 β α 1 ACXα Yα 2 β α 1 ACXα cid2 Yα Proof Assume cid7X cid2lex cid7Y GAC Xα Yα AC β α 1 Xα cid2 Yα AC β α 1 Then exists value DYα greater equal value DXα exists value DXα equal value b DYα Since variables assigned pairwise equal indices α b lacks support variables vectors This contradicts cid7X cid2lex cid7Y GAC All variables indices α assigned pairwise equal Therefore assignment Xα cid2 Yα provides support values indices greater α Hence given β α 1 ACXα Yα constraint GAC Similarly β α 1 ACXα cid2 Yα Xα cid2 Yα supports values indices greater α It Yα If β n 1 deﬁnition minXi cid2 maxYi remains consider assignments set Xα α n constraint GAC Otherwise deﬁnition β minXi cid2 maxYi α β Yα supported combination Xβ1 cid2 Yβ1 Xβ1 cid7Xα1β2 Yβ1 Since cid7X cid7Y variabledistinct Xα cid7Yα1β2 Hence constraint GAC cid2 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 813 Algorithm GACLexLeq Yalpha alpha alpha 1 minXi maxYi beta 1 beta beta 1 1 alpha 0 alpha n Xalpha alpha n beta n 1 return alpha beta 1 cid11 n minXi cid2 maxYi EstablishGAC A1 A2 A3 A4 A5 A6 A61 A62 A63 A7 A8 A9 A10 ReEstablishGACi 0 n Triggered minXi maxYi changes A11 A12 A121 A122 A13 A131 A132 alpha 1 beta EstablishACXi Yi alpha 1 beta EstablishACXi cid2 Yi Yi UpdateAlpha Xi n beta n 1 beta 1 beta alpha beta disentailed ReEstablishGACalpha alpha beta UpdateBetai 1 beta 1 minXi maxYi minXi maxYi UpdateAlpha A14 A15 A16 A17 A18 alpha alpha 1 alpha n return alpha beta disentailed Xalpha UpdateAlpha Yalpha ReEstablishGACalpha UpdateBetai 0 n A19 A20 A21 A211 A22 beta 1 alpha beta disentailed minXi maxYi UpdateBetai 1 alpha EstablishACXi Yi Fig 4 Constituent procedures GACLexLeq algorithm 43 Algorithm GACLexLeq Based Theorems 1 2 designed efﬁcient lineartime propagation algorithm GACLexLeq cid7Y It cid7Y prunes inconsistent values establish GAC cid7X cid2lex detects disentailment cid7X cid2lex presented Fig 4 Throughout paper assume propagation algorithms certain manner common practice constraint programming If searching solution set constraints contains constraint form cid7X cid2leq cid7Y constraint imposed EstablishGAC In searching path search space ReEstablishGAC called domain variable cid7X cid7Y reduced certain manner As domain reductions destroy GAC property algorithms specify conditions ReEstablishGAC triggered Finally assume solver detects domain variable reduced set interrupts execution propagation algorithm signals disentailment Thus algorithms test domains When conditions lead algorithms detect constraint disentailed algorithms signal return We assume propagation algorithms called constraint disentailment detected 814 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 Let discuss GACLexLeq beginning EstablishGAC Throughout paper refer lines A1A9 initialisation step lines initialise program variables alpha beta α β deﬁned Deﬁnitions 6 7 Following initialisation step ReEstablishGAC called line A10 establish generalised arc consistency Line A2 traverses cid7X cid7Y starting index 0 reaches end vectors pairs variables assigned equal ﬁnds index pair variables assigned equal In ﬁrst case cid7Y entailed In second case alpha set smallest index algorithm returns line A3 cid7X cid2lex pair variables assigned equal The vectors traversed line A6 starting index alpha end vectors reached pairs variables minXi maxYi index minXi maxYi In ﬁrst case beta set n 1 line A7 In second case beta guaranteed line A8 If exists h 0 1 min cid7Xhi1 max cid7Yhi1 beta revised h line A61 If alpha beta disentailment detected EstablishGAC terminates signalling case line A9 Otherwise sufﬁcient ReEstablishGAC index alpha line A10 establish generalised arc consistency We consider ReEstablishGAC Apart EstablishGAC procedure triggered lower bound variables cid7X upper bound variables cid7Y modiﬁed The justiﬁcation lexicographic ordering monotonic constraint If value Xi support supported maximum value Yi likewise value Yi support supported minimum value Xi Hence new support needs sought bounds changed ReEstablishGAC consists mutuallyexclusive branches turn Line A11 estab lishes AC Xi Yi accordance Theorem 2 Again monotonicity simple step First check ensure upper bound Xi supported upper bound Yi If upper bound Xi revised accordingly Similarly lower bound Yi compared lower bound Xi revised necessary Lines A12122 cater case alpha beta adjacent Again exploiting monotonicity line A121 establishes AC Xi cid2 Yi accordance Theorem 2 If following step Xi Yi assigned equal alpha longer reﬂects α updated UpdateAlpha In lines A14 A18 UpdateAlpha vectors traversed α reached If α n procedure returns line A15 GAC established If α β disentailment signalled line A16 accordance Theorem 1 Otherwise ReEstablishGAC called line A17 Finally lines A13A132 deal ReEstablishGAC index alpha beta In case case beta reﬂect β updated The condition updating beta derived Deﬁnition 7 minXi maxYi beta 1 minXi maxYi The program variable beta updated calling UpdateBetai 1 In lines A19 A22 vectors traversed β reached Again α β disentailment signalled line A20 accordance Theorem 1 Otherwise line A211 establishes AC Xi cid2 Yi α adjacent β 5 Theoretical properties We begin analysing worstcase time complexity GACLexLeq establishing soundness completeness 51 Time complexity This section considers time complexity GACLexLeq establish reestablish GAC total time complexity establishing repeatedly reestablishing GAC moving single branch search space The GACLexLeq algorithm updates domains variables establishing arcconsistency constraints form X cid2 Y X Y modify domains tightening bounds Depending domains implemented time taken perform tightening operation constant function cardinality domain function structure domain In order abstract away issue AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 815 shall measure run time algorithms pair functions cid3f1 f2cid4 f1 gives total number operations performed counting domain bounds modiﬁcation single operation f2 gives total number domain bounds modiﬁcations We assume minX maxX computed constant time Thus cost establishing AC X cid2 Y X Y cid3O1 0cid4 constraint AC cid3O1 1cid4 Our approach complexity analysis ﬁrst Lemma 2 characterise computation performed function Mαβ total number times alpha beta modiﬁed obtain complexity result establishing Mαβ bounded vector length plus Lemma 1 Every execution UpdateAlpha increments alpha execution UpdateBeta creases beta During execution ReEstablishGAC value alpha decreases value beta increases Proof Each execution UpdateAlpha increments alpha Line A14 modiﬁes alpha Each execution UpdateBeta assigns value beta line A19 modiﬁed Let conﬁrm line A19 decreases beta On initial UpdateBeta line 132 value passed greater beta 2 subsequent calls line A22 decremented Hence immediately line A19 executed 1 strictly beta An execution ReEstablishGAC modiﬁes alpha beta calls UpdateAlpha UpdateBeta decreases alpha increases beta cid2 Lemma 2 Given pair equallength variabledistinct vectors time complexity ReEstablishGAC cid3OMαβ OMαβ cid4 Mαβ total number times alpha beta variables modiﬁed execution Proof With execution e ReEstablishGAC associate string se symbols r b indicates sequence invocations ReEstablishGAC UpdateAlpha UpdateBeta respectively place execution e It useful observe structure algorithm set strings raarb Consider arbitrary execution e ReEstablishGAC We start proof ﬁrst showing execution e Mαβ cid7se From Lemma 1 know execution UpdateAlpha increments alpha execution UpdateBeta decreases beta Each execution ReEstablishGAC ﬁrst preceded execution UpdateAlpha execution incremented alpha Therefore Mαβ cid7se Ob serving ReEstablishGAC UpdateAlpha UpdateBeta perform O1 total operations conclude total number operations performed execution e OMαβ Observing ReEstablish GAC UpdateAlpha UpdateBeta perform domain bounds modiﬁcation conclude total number modiﬁcations performed execution e OMαβ cid2 Theorem 3 Given pair length n variabledistinct vectors time complexity ReEstablishGAC EstablishGAC cid3On Oncid4 Proof First consider ReEstablishGAC Observe ReEstablishGAC called line A10 alpha 0 beta n 1 From Lemma 1 follows true subsequent ReEstablishGAC line A17 outside algorithm Observe value alpha exceeds beta From Lemma 1 observations follows execution ReEstab lishGAC Mαβ cid2 n 1 Therefore follows Lemma 2 complexity ReEstablishGAC EstablishGAC cid3On Oncid4 Now consider EstablishGAC Observe complexity initialisation step lines A1 A9 cid3On 0cid4 Adding execution time ReEstablishGAC line A10 gives total complexity cid3On Oncid4 cid2 As explained beginning Section 43 searching solution set constraints contains cid7Y constraint imposed EstablishGAC constraint form cid7X cid2lex branch search space ReEstablishGAC time lower bound Xi increased upper bound Yi decreased Direct application Theorem 3 tell sequence 816 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 k 1 calls total execution time cid3Okn Okncid4 However algorithms incremental actual execution time Theorem 4 Given pair equallength variabledistinct vectors time complexity executing EstablishGAC followed sequence k executions ReEstablishGAC cid3On k On kcid4 Proof From Lemma 1 arguments forward previous proof know entire sequence operations Mαβ exceed n 1 Hence Lemma 2 number operations performed related moves alpha beta On But k executions sequence perform constant number operations alpha beta moved takes Ok total operations Thus total number operations executed sequence On k By similar argument number domain bounds modiﬁcations performed sequence executions On k cid2 52 Soundness completeness We turn attention soundness completeness GACLexLeq By soundness propagation algorithm mean algorithm removes domain elements participate satisfying assignment constrained variables signals disentailment constraint disentailed By completeness mean algorithm signals disentailment constraint disentailed removes domain elements participate satisfying assignment We begin initialisation EstablishGAC Lemma 3 Let cid7X cid7Y pair length n variabledistinct vectors The initialisation step EstablishGAC cid7Y disentailed cid7X cid7Y sets alpha beta α β respectively It signals cid7X cid2lex case Proof Line A2 EstablishGAC traverses cid7X cid7Y starting index 0 reaches end vectors pairs variables assigned equal ﬁnds index pair variables assigned cid7Y holds algorithm returns alpha beta set Deﬁnitions 6 equal In ﬁrst case GAC cid7X cid2lex 7 line A3 In second case alpha set smallest index pair variables assigned equal Deﬁnition 6 The vectors traversed line A6 starting index alpha end vectors reached pairs variables minXi maxYi index minXi maxYi In ﬁrst case beta set n 1 line A7 Deﬁnition 7 In second case beta guaranteed line A8 If exists h 0 1 min cid7Xhi1 max cid7Yhi1 beta cid7Y disentailed revised h line A61 Deﬁnition 7 If alpha beta cid7X cid2lex Theorem 1 EstablishGAC terminates signalling case line A9 cid2 Having established alpha beta correctly initialised lines A1 A9 EstablishGAC variables correctly updated UpdateAlpha UpdateBeta respectively Note procedures trigger pruning We pruning sound complete Lemma 4 Let cid7X cid7Y pair length n variabledistinct vectors alpha α beta cid3 β UpdateAlpha cid7Y disentailed UpdateAlpha terminates sound If α β beta β UpdateAlpha complete If cid7X cid2lex α alpha Proof Induction k n α Base case k 0 α n By deﬁnition cid7Xalphaα1 cid7Yalphaα1 At line A14 alpha incremented If alpha equal α updateAlpha terminates line A15 complete Otherwise α n β n 1 condition line A16 met Similarly condition line A17 met There fore UpdateAlpha called recursively line A18 This process repeats alpha n UpdateAlpha terminates correctly Inductive case We assume theorem true 0 cid2 k j We prove true k j equivalently cid7Yalphaα1 deﬁnition As alpha updated set correctly α n j Again cid7Xalphaα1 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 817 α line A14 The condition line A15 met assumption If alpha beta possible beta β disentailment signalled line A16 This sound required completeness Since alpha α condition line A17 met ReEstablishGACalpha called Consider ﬁrst case α β 1 From Theorem 2 establishing AC Xalpha Yalpha sound required completeness Since condition line A16 met alpha α condition line A11 met beta β second completeness condition AC established line A11 algorithm terminates required Consider case α β 1 From Theorem 2 establishing AC Xalpha cid2 Yalpha sound required completeness Since alpha α β cid2 beta condition line A12 met AC established line A121 required If Yalpha UpdateAlpha called k j α greater index This results Xalpha sound complete induction assumption Since alpha branch entered cid2 Lemma 5 Let cid7X cid7Y pair length n variabledistinct vectors 0 cid2 alpha cid2 α h β 1 minXh cid3 maxXh In addition assume α β β 1 cid2 n α β alpha 1 cid2 n UpdateBetai sound complete Furthermore cid7X cid2lex cid7Y disentailed UpdateBetai terminates β beta Proof We divide proof cases Case 1 α β From Theorem 1 sound signal disentailment completeness requires disentailment signalled We assume initial UpdateBeta α An initial cid2 α simple sub case clear By assumption index h β 1 minXh cid3 maxYh Hence condition line A21 met UpdateBeta called recursively β beta By assumption alpha cid2 α If α alpha condition line A20 met disentailment signalled required If alpha α cid7Y alphaα1 At point recursion continues alpha 1 Deﬁnition 6 cid7Xalphaα1 condition line A20 met disentailment signalled required Case 2 α β 1 From Theorem 2 sound establish ACXα Yα completeness requires AC established As UpdateBeta traverses vectors condition line A20 line A21 met However condition line A20 met assumption alpha cid2 α β Deﬁnition 7 minXβ1 maxYβ1 By assumption index h β 1 minXh cid3 maxYh Hence recursion end reaches α β 1 At point conditions lines A21 A211 met AC established required If cause disentailment algorithm returns beta β Case 3 α β 1 Similarly beta updated β point condition line A21 met Clearly condition line A211 met algorithm terminates correctly cid2 In context constraint solver intended GACLexLeq guarantee ReEstablishGAC invoked immediately following individual change vectors variables constrains Hence ReEstablishGAC sound complete following number changes We EstablishGAC ReEstablishGAC ensure alpha beta set correctly termination This turn ensures successive applications ReEstablishGAC following sequence changes remains sound complete Theorem 5 Let cid7X cid7Y pair length n variabledistinct vectors GAC cid7X cid2lex cid7Y let alpha α cid11 β beta Let domain reductions variables cid7X cid7Y indices form set I Let P process executing order ReEstablishGACi I meets trigger conditions P sound complete If cid7X cid2lex cid7Y disentailed P terminates α alpha β beta Proof Soundness The algorithm prunes values directly lines A11 A121 result invoking Up dateAlpha UpdateBeta lines A122 A132 We consider case turn The condition line A11 met 1 alpha α beta β case propagation performed sound Theorem 2 2 α β alpha α beta α Here propagation result domain disentailment signalled sound Theorem 1 If alpha α propagation line A121 effect UpdateAlpha invoked If alpha α propagation line A121 sound Theorem 2 If results 818 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 Yi UpdateAlpha invoked In case soundness conditions UpdateAlpha met Xi sumption If conditions lines A13 A131 met UpdateBetai 1 invoked The soundness conditions UpdateBeta met assumption Completeness We divide completeness cases according relative values α β Case 1 α β 1 From Theorem 2 sufﬁces ACXα cid2 Yα established If α remains equal alpha possibilities Xα Yα unchanged ACXα cid2 Yα holds sequence domain reductions b Domain reductions α affected lower bound Xα upper bound Yα From monotonicity ACXα cid2 Yα holds c The lower bound Xα andor upper bound Yα revised case α I propagation performed line A121 required If alpha α domain Xalpha andor Yalpha reduced single value Since ACXalpha cid2 Yalpha held sequence domain reductions means lower bound Xalpha andor upper bound Yalpha reduced Hence UpdateAlpha invoked line A122 complete Lemma 4 Case 2 α β 1 If α n propagation necessary Otherwise sufﬁces ACXα Yα established Theorem 2 If α remains equal alpha possibilities beta β If Xα Yα unchanged domain reductions α affected lower bound Xα upper bound Yα monotonicity ACXα Yα holds sequence domain reductions If lower bound Xα andor upper bound Yα revised α I ACXα Yα established line A11 required b β beta For index j β beta lower bound Xj upper bound Yj revised h β j minXh cid3 maxXh Hence j I UpdateBetaj 1 called line A132 It complete Lemma 5 If alpha α alpha updated α If point beta β AC established line A11 required If beta β UpdateBeta called completeness conditions met Case 3 α β From Theorem 1 completeness requires disentailment signalled By assumption case alpha α beta β By similar arguments UpdateAlpha invoked complete Lemma 4 UpdateBeta invoked complete Lemma 5 Accuracy α β termination assuming cid7X cid2lex cid7Y disentailed If alpha α argued domain Xalpha andor Yalpha reduced single value Hence UpdateAlpha invoked line A122 terminates α alpha Lemma 4 If β beta argued index j β cid2 j beta lower bound Xj upper bound Yj revised h β j minXh cid3 maxXh Hence j I UpdateBetaj 1 called line A132 From Lemma 5 terminates beta β cid2 Theorem 6 Let cid7X cid7Y pair length n variabledistinct vectors EstablishGAC cid7X cid7Y sound complete If cid7X cid2lex cid7Y disentailed EstablishGAC terminates α alpha β beta Proof From Lemma 3 line A9 EstablishGAC executed alpha beta set α β If disentailment detected line A10 invokes ReEstablishGACalpha From Theorem 2 GAC cid7X cid2lex cid7Y ReEstablishGACalpha effect complete Otherwise ACXalpha cid2 Xbeta ACXalpha Xbeta hold If alpha adjacent beta ACXalpha Xbeta established line A11 sound complete If alpha beta adjacent ACXalpha cid2 Xbeta established Yalpha UpdateAlpha called line A122 From Lemma 4 UpdateAlpha line A121 If Xalpha sound complete cid7X cid2lex cid7Y disentailed terminates α alpha β beta cid2 6 Extensions 61 Strict lexicographic ordering constraint With little effort GACLexLeq adapted obtain propagation algorithm GACLexLess detects disentailment cid7X lex cid7Y The reason algorithms similar soon β takes value n 1 GACLexLeq enforces strict lexicographic ordering vectors cid7Y prunes inconsistent values establish GAC cid7X lex AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 819 Before showing modify GACLexLeq necessary theoretical background We deﬁne index cid7Yβn1 α vectors cid7X cid7Y Deﬁnition 6 However β index cid7Xβn1 lex disentailed n index exists Deﬁnition 8 Given length n variabledistinct vectors cid7X cid7Y β index α n cid5 k β n cid5 minXk maxYk min cid7Xβk1 max cid7Yβk1 min cid7Xβn1 max cid7Yβn1 cid6cid6 index exists n We use α β detect disentailment prune inconsistent values Theorem 7 Let cid7X cid7Y pair length n variabledistinct vectors β α cid7X lex cid7Y disentailed Proof Identical proof Theorem 1 If cid7X lex cid7Y disentailed cid7X cid3lex substituting Deﬁnition 8 Deﬁnition 7 Otherwise cid7X cid3lex 0 n minXi cid3 maxYi Hence Deﬁnition 6 α index Xα Deﬁnition 8 β α cid2 cid7Y entailed proof follows Theorem 1 cid7Y entailed Since vectors variabledistinct Yα Thus cid7Y entailed If cid7X lex The conditions GAC hold similar Theorem 8 Given pair length n variabledistinct vectors cid7X cid7Y β α GAC cid7X lex following conditions holds cid7Y 1 β α 1 ACXα Yα 2 β α 1 ACXα cid2 Yα Proof Similar proof Theorem 2 Since cid7X0α1 cid7Y0α1 assignment Xα cid2 Yα supports values domains cid7Xα1n1 cid7Yα1n1 Hence given β α 1 ACXα Yα constraint GAC Similarly β α 1 ACXα cid2 Yα Xα cid2 Yα supports values domains cid7Xα1n1 cid7Yα1n1 It remains consider Yβ1 minXi cid2 maxYi Xα Yα supports supported combination Xβ1 cid2 Yβ1 α β Since cid7X cid7Y variabledistinct Xα cid7Xα1β2 Yα Irrespective β n deﬁnition β Xβ1 cid7Yα1β2 Hence constraint GAC cid2 We consider simple modiﬁcations GACLexLeq necessary obtain propagation algorithm GACLexLess presented Fig 5 First initialisation step EstablishGAC lines B1B8 reﬂect new deﬁnition β From Deﬁnition 8 Theorem 7 constraint disentailed α n Line B3 deals case A change initialisation step line B7 Line A7 GACLexLeq removed beta assigned n correctly index tail vectors guaranteed ordered lexicographically equal decreasing The second modiﬁcation UpdateAlpha indicated ﬁgure Again alpha reaches n constraint disentailed No modiﬁcations necessary 62 Entailment Even GACLexLeq sound complete propagation algorithm detect entailment This section extends GACLexLeq algorithm new algorithm GACLexLeqEntailed detect entailment Mimicking treatment disentailment entailment detected algorithm signals returns Once constraint entailed remains GAC domains constrained variables later reduced need reestablish GAC It hard cid7X cid2lex cid7Y entailed 820 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 Algorithm GACLexLess Yalpha alpha alpha 1 alpha 0 alpha n Xalpha alpha n disentailed alpha beta 1 cid11 n minXi cid2 maxYi EstablishGAC B1 B2 cid4cid4 B3 B4 B5 B6 B61 B62 B63 minXi maxYi beta 1 beta beta 1 1 beta 1 beta alpha beta disentailed ReEstablishGACalpha cid4cid4 B7 B8 B9 ReEstablishGACi 0 n Triggered minXi maxYi changes Identical GACLexLeq UpdateAlpha B14 cid4cid4 B15 B16 B17 B18 alpha alpha 1 alpha n disentailed alpha beta disentailed Xalpha UpdateAlpha Yalpha ReEstablishGACalpha UpdateBetai 0 n Identical GACLexLeq Fig 5 Constituent procedures GACLexLess algorithm Modiﬁcations GACLexLeq indicated cid4cid4 Theorem 9 Given pair length n variabledistinct vectors cid7X cid7Y cid7X cid2lex max cid7X cid2lex min cid7Y cid7Y entailed Proof Since cid7X cid2lex max cid7Y cid7Y entailed combination assignments satisﬁes cid7X cid2lex cid7Y Hence min cid7X cid2lex Any cid7x cid7X lexicographically equal cid7y cid7Y Hence cid7X cid2lex cid7Y entailed cid2 To exploit fact introduce γ index α n cid7Xγ n1 cid2lex cid7Yγ n1 entailed n index exists Deﬁnition 9 Given pair length n variabledistinct vectors cid7X cid7Y γ index α n max cid7Xγ n1 min cid7Yγ n1 cid6 cid5 maxXk minYk max cid7Xγ k1 min cid7Yγ k1 k γ n index exists n Theorem 10 Given pair length n variabledistinct vectors cid7X cid7Y cid7X cid2lex cid7Y entailed γ α Proof If cid7X cid2lex cid7Y entailed deﬁnition lexicographic ordering fact vectors variable distinct exists index maxXi minYi max cid7X0i1 min cid7Y0i1 b max cid7X0n1 min cid7Y0n1 First consider Let k index variables assigned equal By Deﬁnition 6 α k Clearly k lies 0 From ﬁrst Deﬁnition 9 γ k Now consider b If vectors assigned equal α n γ Deﬁnitions 6 9 Otherwise let k deﬁned From second Deﬁnition 9 γ k By Deﬁnition 6 cid7X0α1 cid7Y0α1 entailed Deﬁnition 9 cid7Xαn1 cid2lex cid7Yαn1 entailed Hence cid7X cid2lex cid7Y entailed cid2 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 821 We consider modiﬁcations necessary GACLexLeq obtain GACLexLeqEntailed pre sented Fig 6 Clearly alpha reaches n constraint entailed This case dealt lines C3 C21 Otherwise entailment detected considering γ We introduce program variable gamma track γ line C10 initialise lines C11C12 way beta Two procedures required maintain gamma correctly First γ change following update maxXi minYi opposite conditions trigger ReEstablishGAC Hence Check Entailment triggered events line C19 calls UpdateGamma procedure necessary UpdateGamma works similarly Update procedures signalling entailment alpha gamma meet line C28 Algorithm GACLexLeqEntailed Yalpha alpha alpha 1 minXi maxYi beta 1 beta beta 1 1 alpha 0 alpha n Xalpha alpha n entailed alpha beta 1 cid11 n minXi cid2 maxYi EstablishGAC C1 C2 cid4cid4 C3 C4 C5 C6 C61 C62 C63 C7 C8 C9 cid4cid4 C10 cid4cid4 C11 cid4cid4 C111 cid4cid4 C112 cid4cid4 C113 cid4cid4 C114 cid4cid4 C12 cid4cid4 C13 C14 ReEstablishGACi 0 n Triggered minXi maxYi changes Identical GACLexLeq CheckEntailmenti 0 n Triggered maxXi minYi changes n beta n 1 beta 1 beta alpha beta disentailed gamma 1 cid11 n maxXi cid3 minYi maxXi minYi gamma 1 gamma alpha gamma entailed ReEstablishGACalpha gamma 1 1 gamma 1 gamma alpha cid4cid4 cid4cid4 C19 gamma 1 maxXi minYi maxXi minYi UpdateGammai 1 UpdateAlpha C20 cid4cid4 C21 C22 C23 C24 alpha alpha 1 alpha n entailed alpha beta disentailed Xalpha UpdateAlpha Yalpha ReEstablishGACalpha UpdateBetai 0 n Identical GACLexLeq cid4cid4 cid4cid4 C28 cid4cid4 C29 cid4cid4 C30 UpdateGammai 0 n 1 alpha entailed maxXi minYi gamma 1 maxXi minYi UpdateGammai 1 Fig 6 Constituent procedures GACLexLeqEntailed algorithm Modiﬁcations GACLexLeq indicated cid4cid4 822 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 Section 51 analyzed complexity GACLexLeq considering modiﬁcations alpha beta As arguments modiﬁcations gamma results given Theorems 3 4 apply GACLexLeqEntailed 63 Vectors different length This section considers vectors different length Since vectors different length equal consider imposing strict lexicographic ordering constraint Considering vectors equal length Deﬁnition 2 deﬁned strict lexicographic ordering vectors integers Theorem 8 stated necessary conditions GAC strict lexicographic ordering constraint pair vectors variables It straightforward generalise deﬁnition theorem vectors necessarily equal length Deﬁnition 10 Strict lexicographic ordering cid7x lex cid7y vectors integers cid7x cid3x0 x1 xm1cid4 cid7y cid3y0 y1 yn1cid4 holds following conditions hold 1 m n cid7x cid2lex cid7y0m1 2 m cid3 n cid7x0n1 lex cid7y In words truncate length shortest vector compare Either cid7x shorter cid7y ﬁrst m elements vectors lexicographically ordered cid7x long cid7y ﬁrst n elements strict lexicographically ordered An example cid30 1 2 1 5cid4 lex cid30 1 2 3 4cid4 lex cid30 1 2 3 4 5 5 5cid4 lex cid30 1 2 4 3cid4 Based general deﬁnition GAC cid7X lex cid7Y GAC lexicographic ordering constraint GAC strict lexicographic ordering constraint Proposition 1 Given pair variabledistinct vectors cid7X length m cid7Y length n cid7X lex following conditions hold cid7Y GAC 1 m n GAC cid7X cid2lex 2 m cid3 n GAC cid7X0n1 lex cid7Y0m1 cid7Y We easily generalise propagation algorithm GACLexLess based theorem If m n cid7Y0m1 If m cid3 n consider ﬁrst m variables cid7Y use GACLexLeq enforce GAC cid7X cid2lex consider ﬁrst n variables cid7X use GACLexLess enforce GAC cid7X0n1 lex cid7Y 7 Alternative approaches Various alternative methods exist enforcing lexicographic ordering constraint ranging enforcing collection simpler constraints alternative propagation algorithms This section summarises discusses alternative approaches 71 Arithmetic constraints To ensure cid7X cid2lex cid7Y post following arithmetic inequality constraint vectors cid7X cid7Y variables range subset 0 d 1 d n1 X0 d n2 X1 d 0 Xn1 cid2 d n1 Y0 d n2 Y1 d 0 Yn1 This equivalent converting vectors numbers posting ordering numbers In order enforce cid7Y post strict inequality constraint strict lexicographic ordering cid7X lex d n1 X0 d n2 X1 d 0 Xn1 d n1 Y0 d n2 Y1 d 0 Yn1 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 823 These arithmetic constraints logically equivalent corresponding lexicographic ordering constraint Since constraints monotonicany unsupported domain values greatest ones cid7X ones cid7Y constraint toolkits establish GAC constraints Unfortunately n d large d n1 word size establishing GAC expensive Hence method feasible vectors domain sizes small Inspired 10 Warwick Harvey suggested alternative arithmetic constraint 14 To ensure cid7X cid2lex cid7Y posts following logically equivalent constraint cid5 X0 Y0 cid5 X1 Y1 cid5 Xn1 Yn1 1 cid6cid6cid6 1 A constraint form Xi Yi B reiﬁed 01 variable interpreted Xi Yi B Strict ordering achieved posting cid5 X0 Y0 1 cid5 Xn1 Yn1 0 cid5 X1 Y1 Yn1 case vectors assigned equal index Many toolkits support cid6cid6cid6 disallows Xn1 reiﬁcation maintain GAC constraints Henceforth shall refer Harveys reiﬁcation approach purely arithmetic constraint simply arithmetic constraint 72 Logical decompositions The ﬁrst decomposition decomposition conjunction n 1 constraints X0 cid2 Y0 X0 Y0 X1 cid2 Y1 X0 Y0 X1 Y1 X2 cid2 Y2 X0 Y0 X1 Y1 Xn2 Yn2 Xn1 cid2 Yn1 That enforce signiﬁcant bits vectors ordered signiﬁcant bits equal rest vectors lexicographically ordered In order decompose strict lexicographic ordering constraint cid7X lex cid7Y need change conjunction X0 Y0 X1 Y1 Xn2 Yn2 Xn1 Yn1 The second decomposition decomposition disjunction n 1 constraints X0 Y0 X0 Y0 X1 Y1 X0 Y0 X1 Y1 X2 Y2 X0 Y0 X1 Y1 Xn2 Yn2 Xn1 cid2 Yn1 That enforce signiﬁcant bits vectors strictly ordered signiﬁcant bits equal rest vectors lexicographically ordered For strict lexicographic ordering sufﬁces change disjunction X0 Y0 X1 Y1 Xn2 Yn2 Xn1 Yn1 Constraints logical connectives imposed following manner C1 C2 Both C1 C2 imposed C1 C2 If C1 C2 disentailed constraint imposed If C1 C2 entailed C1 C2 entailed C1 C2 If C1 entailed C2 imposed If C2 disentailed C1 imposed If C1 disentailed C2 entailed C1 C2 entailed 824 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 C1 If C1 entailed C1 disentailed If C1 disentailed C1 entailed We consider propagation algorithm decompositions treat logical connectives manner establish AC binary constraint imposed We algorithms guaranteed establish GAC algorithms prune values Theorem 11 For cid7X cid2lex cid7Y decomposition decomposition sound complete Moreover constraints decomposition algorithms incomparable prune values viceversa cid7Y cid7X lex cid7Y proof works cid7X lex Proof We consider cid7X cid2lex cid7Y GAC Thus value support The vectors cid7x cid7y supporting value lexicographically ordered cid7x cid2lex cid7y By De ﬁnition 3 cid7x cid7y index k 0 n xk yk cid7x0k1 cid7y0k1 In case constraints posted decompositions satisﬁed That binary constraint imposed decompositions AC Hence decomposition decomposition sound cid7X cid2lex cid7Y Suppose cid7X cid2lex Consider cid7X cid30 1 1cid4 cid7Y cid30 1 0cid4 cid7X cid2lex cid7Y GAC The decomposition imposes X0 cid2 Y0 X0 Y0 X1 cid2 Y1 We ACX0 cid2 Y0 Since X1 cid2 Y1 disentailed X0 cid11 Y0 imposed We ACX0 cid11 Y0 pruning possible The decomposition imposes X0 Y0 X0 Y0 X1 cid2 Y1 disentailed This removes 1 DX0 0 DY0 Now consider cid7X cid30 1 2 0 1cid4 cid7Y cid30 1 0 1cid4 cid7X cid2lex cid7Y GAC The decomposition removes 2 DX0 ACX0 cid2 Y0 The decomposition leaves vectors unchanged X0 Y0 X0 Y0 X1 cid2 Y1 disentailed cid7Y Since decomposition prunes value pruned complete cid2 Together decompositions behave similarly propagation algorithm lexicographic ordering constraint prove cid7X cid2lex cid7Y However requires posting cid7Y disentailed establish GAC cid7X cid2lex propagating constraints likely inefﬁcient Our experimental results Section 91 conﬁrm expectation Theorem 12 Given pair length n variabledistinct vectors cid7X cid7Y decomposition cid7X cid2lex prove cid7X cid2lex cid7Y disentailed establish GAC cid7X cid2lex cid7Y cid7Y Proof Consider decomposition If α β minXα maxYα exists index k α n minXk maxYk min cid7Xαk1 max cid7Yαk1 In ﬁrst case constraint X0 Y0 X1 Y1 Xα1 Yα1 Xα cid2 Yα disentailed In second case constraint X0 Y0 X1 Y1 Xk1 cid7Yαk1 constraint X0 Y0 X1 Y1 Xi1 Yk1 Xk cid2 Yk disentailed cid7Xαk1 Yi1 Xi cid2 Yi In case cid7X cid2lex cid7Y disentailed This correct Theorem 1 If α β constraint X0 Y0 X1 Y1 Xα1 Yα1 Xα cid2 Yα makes sure ACXα cid2 Yα Now consider decomposition If β α disjuncts decomposition disentailed cid7X cid2lex cid7Y disentailed This correct Theorem 1 If β α 1 disjunct X0 Y0 X1 Y1 Xα1 Yα1 Xα Yα disentailed This makes sure ACXα Yα Given β α β α 1 ACXα Yα β α 1 ACXα cid2 Yα By Theorem 2 GAC cid7X cid2lex cid7Y cid2 Theorem 13 Given pair length n variabledistinct vectors cid7X cid7Y decomposition cid7X lex prove cid7X lex cid7Y disentailed establish GAC cid7X lex cid7Y cid7Y AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 825 Proof We need consider cases β n β n min cid7Xβn1 max cid7Yβn1 remaining cases covered proof Theorem 12 Assume β n Consider decomposition We α 1 β n α 1 β n In ﬁrst case constraint X0 Y0 X1 Y1 Xn2 Yn2 Xn1 Yn1 constraint conjunction makes sure ACXα Yα In second case constraint X0 Y0 X1 Y1 Xα1 Yα1 Xα cid2 Yα makes sure ACXα cid2 Yα Now assume β n min cid7Xβn1 max cid7Yβn1 Consider decomposition If α β constraint X0 cid7Yi Y0 X1 Y1 Xn2 Yn2 Xn1 Yn1 disentailed α n 1 cid7Xi constraint X0 Y0 X1 Y1 Xi1 Yi1 Xi cid2 Yi Hence cid7X cid2lex cid7Y disentailed This correct Theorem 1 If α β constraint X0 Y0 X1 Y1 Xα1 Yα1 Xα cid2 Yα makes sure ACXα cid2 Yα Now consider decomposition If β α disjuncts decomposition cid7Y disentailed This correct Theorem 1 If β α 1 disjuncts disentailed cid7X cid2lex X0 Y0 X1 Y1 Xα1 Yα1 Xα Yα disentailed This makes sure ACXα Yα Given β α β n β n 1 β α 1 ACXα Yα 2 β α 1 ACXα cid2 Yα By Theorem 8 GAC cid7X lex cid7Y cid2 73 Alternative propagation algorithms The ECLiPSe constraint solver 29 provides global constraint called lexico_le lexicographic ordering vectors The manual 6 reveal propagation performed constraint Our tests cid7Y leaves complete cid7X cid30 1 0 1 1cid4 cid7Y cid30 1 0 0cid4 executing lexico_le cid7X cid2lex cid7Y GAC Our tests lexico_le prune values vectors unchanged cid7X cid2lex pruned decompositions discussed Section 72 For instance cid7X cid30 1 1cid4 cid7Y cid7Y gives cid7X cid30 1cid4 cid7Y cid31 0cid4 decomposition cid30 1 0cid4 executing lexico_le cid7X cid2lex leaves vectors unchanged Likewise cid7X cid30 1 2 0 1cid4 cid7Y cid30 1 0 1cid4 executing lexico_le cid7Y gives cid7X cid30 1 0 1cid4 cid7Y cid30 1 01cid4 decomposition leaves vectors unchanged cid7X cid2lex We examples decompositions prunes values pruned lexico_le Subsequent ﬁrst publication GACLexLeq algorithm 10 Carlsson Beldiceanu developed complete propagation algorithm lexicographic ordering constraint ﬁnite automaton 2 The algorithm maintains generalised arc consistency detects disentailment runs linear time posting plus amortised constant time propagation event Their algorithm records position α counterpart beta variable 74 Encoding GACLexLeq An alternative way propagating global constraint post set constraints simulate special purpose propagation algorithm The success approach demonstrated 11 showing arc consistency CSP representation stable marriage problem gives reduced domains equivalent GSlists produced Extended GaleShapley algorithm Inspired 10 Gent et al developed encoding lexicographic ordering constraint 12 The encoding introduces new vector cid7α 01 variables indexed 1 n 1 The intended meaning cid7α αi 1 cid7X0i cid7Y0i αi1 0 αi 1 Xi1 Yi1 They post following constraints α1 1 αi 0 αi1 0 αi 1 Xi Yi αi 1 αi1 0 Xi1 Yi1 αi 1 Xi1 cid2 Yi1 0 n 2 0 n 1 1 n 2 1 n 2 826 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 For strict lexicographic ordering sufﬁces add αn1 0 The advantage encoding obviates need implement specialpurpose propagation algo rithm instead relying existing general propagation algorithms On hand experimental results Section 9 introduction extra variables constraints efﬁcient 8 Multiple vectors Chains lexicographic ordering constraints arise practice posting lexicographic ordering constraints rows columns matrix decision variables We treat chain single global ordering constraint matrix Alternatively decompose lexicographic ordering constraints adjacent rowscolumns pairs rowscolumns This section demonstrates decompo sitions hinder constraint propagation As section considers sequences vectors useful subscript individual vectors vector sequence cid7X0 cid7Xn1 Notice vector accent cid7Xi indicates referring vector sequence vectors opposed Xi refers element vector X Theorem 14 Let cid7X0 cid7Xn1 variabledistinct vectors Then GAC cid7Xi cid2lex imply GAC cid7Xi cid2lex cid7Xj j 0 n j cid7Xi1 0 n 1 cid3 cid3 cid3 cid3 cid3 cid3 Proof Consider following vectors cid4 cid4 cid4 cid7X0 0 1 1 0 1 cid7X1 0 1 0 1 0 1 cid7X2 0 0 1 0 1 Observe cid7X0 cid2lex cid7X1 cid7X1 cid2lex initial element cid7X0 assigned 1 cid2 cid7X2 GAC But cid7X0 cid2lex cid7X2 GAC constraint solution Theorem 15 Let cid7X0 cid7Xn1 variabledistinct vectors Then GAC cid7Xi lex imply GAC cid7Xi lex cid7Xj j 0 n j cid7Xi1 0 n 1 Proof This shown example proof Theorem 14 cid2 Theorem 16 Let cid7X0 cid7Xn1 variabledistinct vectors Then GAC cid7Xi cid2lex j imply GAC cid7X0 cid2lex cid7X1 cid2lex cid2lex cid7Xn1 cid7Xj j 0 n Proof Consider following vectors cid4 cid7X0 cid7X1 cid7X2 Observe cid7X0 cid2lex constraint solution initial element cid7X0 assigned 1 cid2 0 1 0 1 1 0 1 cid4 1 0 1 0 1 0 cid4 0 0 1 0 1 0 cid7X2 cid7X1 cid2lex cid7X1 cid7X0 cid2lex cid7X2 GAC But X0 cid2lex cid7X1 cid2lex X2 GAC The proof Theorem 16 shows theorem holds attention restricted 01 variables demonstrating incorrectness previous claim 10 contrary Theorem 17 Let cid7X0 cid7Xn1 variabledistinct vectors Then GAC cid7Xi lex j imply GAC cid7X0 lex cid7X1 lex lex cid7Xn1 cid7Xj j 0 n Proof This shown example proof Theorem 16 cid2 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 827 Subsequent 10 Carlsson Beldiceanu 1 introduced propagation algorithm called lex_chain establish GAC constraint form cid7X0 cid2lex cid7Xn1 Every time constraint propagated cid7X1 cid2lex cid2lex feasible upper lower bounds computed vector chain vectors pruned respect bounds Given m vectors length n algorithm maintains generalised arcconsistency detects disentailment performs Onm operations 9 Experimental results We implemented algorithms C ILOG Solver 53 16 performed experiments compare alternatives presented Section 7 lex_chain algorithm mentioned Section 8 We experimented matrix models given Section 3 adding lexicographic ordering constraints break partial total index symmetry The results experiments shown tables means result obtained 1 hour The number fails gives number incorrect decisions choice points search tree The best result entry table typeset bold Lexicographic ordering rows enforced technique Tech write Tech R Similarly write Tech C Tech constrain columns lexicographically ordered Tech RC Tech constrain dimensions In theory posting lexicographic ordering constraints pair rows similarly columns leads pruning posting adjacent rows Section 8 However observe beneﬁt practice Therefore posted lexicographic ordering constraints adjacent rows The experiments conducted ILOG Solver 53 1 Ghz Pentium III processor 256 Mb RAM Windows XP We propagate arithmetic constraint IloScalProd maintains GAC We look solution optimal solution optimisation problems 91 Comparison alternative approaches We designed experiments test goals First propagation algorithms inference practice decompositions Similarly algorithm efﬁcient practice decompo sitions Second algorithm compare alternatives maintain GAC arithmetic constraint combined logical decompositions Gent et als encoding We experiment lexico_le exclusive ECLiPSe Recall shown Section 73 lexico_le maintain GAC Furthermore experiment Carlsson Beldiceanus pairwise propagation algorithm exclusive SICStus prolog As noted Section 73 algorithm shown behave similarly We consider problem domains turn Progressive party problem We use matrix model introduced Section 3 The H matrix model partial row total column symmetry break posting lexicographic ordering constraints propagation algorithm GACLexLess alternative approaches Due problem constraints pair rowscolumns equal Given set interchangeable guests gi gi1 gj break partial row symmetry H constraining corresponding rows cid7Ri cid7Ri1 cid7Rj strictly lexicographically ordered follows cid7Rj lex cid7Ri As column symmetry H constrain columns cid7C0 cid7C1 cid7Cp1 corresponding p time periods strictly lexicographically ordered follows cid7Cp1 lex cid7C1 We consider instances progressive party problem drawn data CSPLib We randomly select 13 host boats way total spare capacity host boats sufﬁcient accommodate guests The data presented Table 1 The column gives percentage total capacity measure constrainedness 28 cid7Cp2 lex cid7Ri1 lex We branch variables H matrix As 24 priority largest crews guest boats ordered descending order size Also assigning host guest ﬁrst try value likely succeed We order host boats descending order spare capacity In terms variable ordering use smallestdomain ﬁrst heuristic 828 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 Table 1 Instance speciﬁcation progressive party problem Instance 1 2 3 4 5 6 7 8 9 Host boats 212 14 16 314 16 312 14 15 16 312 14 16 25 312 14 16 23 312 15 16 25 1 312 14 16 312 16 25 26 312 14 16 30 Total host spare capacity Total guest size capacity 102 100 101 101 99 100 100 100 98 92 90 91 92 90 91 92 92 90 90 90 90 91 91 91 92 92 92 Table 2 Performance different propagation algorithms progressive party problem All times given seconds Inst 1 2 3 4 5 6 7 8 9 GACLexLess RC Fails Time 446 445 2380 459 443 8481 782 33849 211075 086 098 217 086 098 614 113 1679 11725 RC Fails 445 3651 443 604 773 213568 Time 141 300 112 136 131 15033 RC Fails Time RC Time 111 125 295 115 118 810 150 2162 15684 Gent et al Time Harvey Time 098 111 247 098 116 662 121 1840 13027 092 104 244 095 098 682 122 1793 13111 Table 2 summarises results experiments Note problem instances solved 6 time periods One exception instance indicated approaches solve instance hour time limit 6 time periods We report results 5 time periods instance problem In set experiments clearly GACLexLess superior decomposition instances solved hour decomposition However difﬁcult judge GACLexLess decomposition superior GACLexLess solves instances 1 4 7 quickly decomposition fails return answer hour Also instances 3 9 solved fewer failures GACLexLess On hand decomposition superior GACLexLess instances 6 8 No difference size search cid7Y establish tree observed instances 2 5 Note decomposition cid7X lex GAC enforcing decomposition choice point lead smaller search tree maintaining GAC choice point dynamic variable ordering employed We turn attention alternatives maintain GAC Note posting arithmetic constraint feasible problem largest coefﬁcient necessary 1328 greater 231 maximum integer size allowed Solver 53 In cases tree explored identical focus runtime Versus combined decomposition GACLexLess clearly efﬁcient especially difﬁcult instances Compared Gent et als encoding Harveys arithmetic constraint GACLexLess holds small consistent advantage scales difﬁculty instance In cases advantage fact GACLexLess encapsulates lexicographic ordering single compact constraint The alternatives incur overhead constraints andor additional variables note reiﬁcation performed Harveys arithmetic constraint makes use hidden Boolean variables Template design problem We use model 21 adds symmetrybreaking constraints implied straints matrix model introduced Section 3 The T matrix partial row partial column symmetry Again break partial row symmetry posting lexicographic ordering constraints Given set interchangeable vari ations vi vi1 vj break partial row symmetry T insisting rows corresponding AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 829 variations cid7Ri cid7Ri1 cid7Rj lexicographically ordered follows cid7Ri cid2lex interchangeable templates broken constraints 0 t 1 Runi cid2 Runi1 cid7Ri1 cid2lex cid7Rj The symmetries We post additional constraints proposed 21 In presenting constraints consider T emplates 0 t Variations 0 v Surplus s j Variations dj To ease presentation constraints assume variations ordered nondecreasing demand j di cid2 dj The additional constraints iT emplates Runi cid2 cid2 T0j T0j 1 T1j T1j 1 cid7 cid7 Runi Tij cid2 Runi Tij 1 j 0 v 1 dj dj 1 j 0 v 1 dj dj 1 iT emplates cid7 iT emplates Runi Tij dj cid2 Surplus j Variations iT emplates cid7 cid8 cid7 cid9 Runi Tij dj cid2 Surplus k 1 v 1 1 2 3 4 0cid2j cid2k iT emplates The constraints 1 break symmetries variations equal demand t 2 2 pseudosymmetry breaking constraints The constraints 3 4 implied constraints provide upper bound cost function Proll Smith 21 post implied constraints Run variables omit shown propagation redundant We use static variable ordering proposed Proll Smith 21 ﬁrst label variables T variables Run The T matrix labelled row row starting variation 0 row labeled order starting template 0 The Run variables labelled order starting Run0 Our experiments conducted instance template design problem known herbs problem 21 labels variety herbs printed templates The data instance shown Table 3 As 21 ﬁrst specify overproduction variation 10 With constraint solution 2 templates trivially proven approaches GACLexLeq 36 fails 01 seconds Removing restriction makes problem difﬁcult A solution cost 89 109683 fails 23 seconds GACLexLeq decomposition arithmetic constraint fail prove optimality hour Changing labeling heuristic assigning Run variables T variables helps ﬁnd prove solution 2 templates cost 87 help ﬁnd solution 3 templates hour restricted overproduction 10 An alternative way solving problem allow 10 underproduction We relax constraint variations minimum produced meets demand According 21 meets problem owners speciﬁcation The results tackling problem way t 2 3 4 5 templates shown Table 4 We observe Table 4 number templates increase search effort time required ﬁnd solution prove optimality dramatically increase decompositions On hand GACLexLeq ﬁnds proves solutions quickly effort In particular 4 5 template problems solved GACLexLeq On approaches maintain GAC focus run time search trees explored identical In cases little difference time taken This vectors constrained relatively short variable having relatively small domain size Hence advantage having single compact constraint visible Table 3 The data herbs problem 21 Slots template Number variations Demand thousands 42 30 60 60 70 70 70 70 70 70 70 80 80 80 80 90 90 90 90 90 90 100 100 100 100 150 230 230 230 230 280 280 830 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 Table 4 Performance different propagation algorithms herbs problem 10 underproduction All times given seconds R GACLexLeq R R Goal t R Time Arth R Time Gent et al Time Harvey Time Fails Time Fails Time Fails Time 2 3 4 5 ﬁnd prove ﬁnd prove ﬁnd prove ﬁnd prove 22 49 5 52 6 70 4 77 002 002 002 002 002 002 002 002 22 49 18341 18341 002 002 767 767 22 49 18842 18842 002 002 930 930 008 008 008 008 008 008 008 008 008 008 008 008 008 008 008 008 002 002 002 002 002 002 002 002 002 002 002 002 002 002 002 002 Fig 7 BIBD GACLexLeqGACLexLess vs decompositions terms fails Balanced incomplete block design problem We use matrix model introduced Section 3 Due straints rows pair rows X equal r λ To break row symmetry enforce rows cid7R0 cid7R1 cid7Rv1 X corresponding v elements strictly lexicographically ordered follows cid7R0 As column symmetry enforce columns cid7C0 cid7C1 cid7Cb1 X cor cid7Rv1 lex cid7C0 We post responding b subsets V lexicographically ordered follows cid7Cb1 cid2lex lexicographic ordering constraints GACLexLess GACLexLeq corresponding alternative approaches cid7Rv2 lex cid7Cb2 cid2lex Large benchmark instances selected experiment 4 For labelling heuristic adopted static variable ordering instantiating matrix X rows exploring domain variable ascending order Figs 79 note logarithmic scale summarise results Again begin comparing propagation algorithm decompositions individually Given choice variable ordering algorithm explores search tree decomposition instances explores slightly smaller tree The decomposition solve ﬁrst 3 instances hour limit failures In terms run time observe substantial gain efﬁciency algorithms preference approaches Even decomposition algorithms explore search tree efﬁciency algorithms dramatically reduces run times We turn attention alternatives maintain GAC Note instances require ordering relatively long vectors posting arithmetic constraint feasible The combined decomposition performs better decomposition signiﬁcantly efﬁcient GACLexLeq We observe Fig 9 instances solved quicker algorithm note logarithmic scale difference difference algorithms decomposition Fig 8 In comparison Gent et als encoding Harveys arithmetic constraint GACLexLeq maintains small consistent advantage To summarise sets experiments section GACLexLeq provides efﬁcient lightweight means enforcing lexicographic ordering provides consistent improvement alternatives AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 831 Fig 8 BIBD GACLexLeqGACLexLess vs decompositions terms run times Fig 9 BIBD GACLexLeqGACLexLess vs Gent et als encoding Harveys arithmetic constraint terms run times ﬁxed search strategy We observed weaker propagation algorithm combined dynamic variable ordering perform better unsurprising choosing right variable assign known crucial reducing search On occasion dynamic variable led chance better selection weaker propagation The alternatives maintain GAC disadvantage requiring introduction auxiliary variables constraints To illustrate point consider Figs 10 11 present total numbers variables memory GACLexLeq Gent et als encoding Harveys decomposition BIBD problem 92 Comparison lex_chain As Theorem 16 shows lex_chain algorithm 1 pruning lexicographic ordering straints adjacent pairs vectors We performed set experiments determine value additional pruning practice We focus BIBD problem challenging domain considered Table 5 summarises results solving BIBDs SICStus Prolog constraint solver 3101 26 Note different instances previous experiments earlier instances proved long solve SICStus We constrained columns rows lexicographically ordered nondecreasing non increasing assigned variables matrix exploring domains ascending order The lexicographic ordering constraints posted lex_chain This constraint posted symmetric rowscolumns adjacent symmetric rowscolumns In cases observed beneﬁts combining chain lexicographic ordering constraints By posting constraints adjacent rowscolumns obtain search trees similar run times posting 832 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 Fig 10 BIBD GACLexLeqGACLexLess vs Gent et als encoding Harveys arithmetic constraint terms number variables Fig 11 BIBD GACLexLeqGACLexLess vs Gent et als encoding Harveys arithmetic constraint terms memory usage Table 5 BIBD lex_chaincid3X0 Xm1cid4 vs lex_chaincid3Xi Xi1cid4 0 m 1 rowwise labeling v b r k λ No symmetry breaking Backtracks lex R cid2lex C lex_chain cid3X0 Xm1cid4 Backtracks 6201034 721933 6301536 7281234 924832 6402038 7351535 7421836 5201 1488 540039 23160 9429447 5975823 84 130 217 216 1472 449 326 460 cid3Xi Xi1cid4 Backtracks 84 130 217 216 1472 449 326 460 lex R cid3lex C lex_chain cid3X0 Xm1cid4 Backtracks 706 72 9216 183 79 51576 395 756 cid3Xi Xi1cid4 Backtracks 706 72 9216 183 79 51576 395 756 constraint rowscolumns This result agreement previous experiments comparing posting lexicographic ordering constraints adjacent rowscolumns matrix pairs rowscolumns 10 approximation lex_chain 10 Conclusion This paper introduced new algorithms propagating lexicographic ordering constraints vectors decision variables Such constraints useful breaking row column symmetries matrix models We demonstrated decomposing constraints carries penalty cost constraint propagation AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 833 We developed efﬁcient propagation algorithms ensure constraints GAC detect disentailment These algorithms require On operations vector contains n variables execute sequence k updates On k operations Experimental results number domains demonstrate value new algorithms A number interesting questions remain First total orderings vectors post break row column symmetry For example use Gray code ordering Second design labeling strategies work synergy symmetry breaking constraints like Third global constraints useful multicriteria optimization problems objective function consists features ranked 7 Acknowledgements We thank Chris Jefferson useful discussions Ian Miguel supported UK Royal Academy Engi neeringEPSRC Research Fellowship Brahim Hnich received support Science Foundation Ireland Grant No 00PI1C075 The majority work Brahim Hnich Zeynep Kiziltan Uppsala University Ian Miguel University York References 1 M Carlsson N Beldiceanu Arcconsistency chain lexicographic ordering constraints Technical Report T200218 Swedish Institute Computer Science 2002 2 M Carlsson N Beldiceanu Revisiting lexicographic ordering constraint Technical Report T200217 Swedish Institute Computer Science 2002 3 BMW Cheng KMF Choi JHM Lee JCK Wu Increasing constraint propagation redundant modeling An experience report Con straints 4 1999 167192 4 CH Colbourn JH Dinitz The CRC Handbook Combinatorial Designs CRC Press 1996 5 J Crawford G Luks M Ginsberg A Roy Symmetry breaking predicates search problems Proceedings 5th International Conference Knowledge Representation Reasoning KR 96 1996 pp 148159 6 P Brisset H El Sakkout T Frühwirth C Gervet W Harvey M Meier S Novello T Le Provost J Schimpf K Shen MG Wallace ECLiPSe Constraint Library Manual Release 56 2003 7 M Ehrgott X Gandibleux A survey annotated bibliography multiobjective combinatorial optimization OR Spektrum 22 2000 425460 8 P Flener AM Frisch B Hnich Z Kiziltan I Miguel J Pearson T Walsh Breaking row column symmetry matrix models P van Hentenryck Ed Proceedings 8th International Conference Principles Practice Constraint programming CP02 Lecture Notes Computer Science vol 2470 Springer 2002 pp 462476 9 P Flener AM Frisch B Hnich Z Kiziltan I Miguel T Walsh Matrix modelling Exploiting common patterns constraint programming Proceedings International Workshop Reformulating Constraint Satisfaction Problems 2002 pp 2741 10 AM Frisch B Hnich Z Kiziltan I Miguel T Walsh Global constraints lexicographic orderings P van Hentenryck Ed Pro ceedings 8th International Conference Principles Practice Constraint Programming CP02 Lecture Notes Computer Science vol 2470 Springer 2002 pp 93108 11 IP Gent RW Irving D Manlove P Prosser BM Smith A constraint programming approach stable marriage problem T Walsh Ed Proceedings 7th International Conference Principles Practice Constraint Programming CP01 Lecture Notes Computer Science vol 2239 Springer 2001 pp 462476 12 IP Gent P Prosser BM Smith A 01 encoding gaclex constraint pairs vectors Notes ECAI02 Workshop W9 Modelling Solving Problems Constraints 2002 13 IP Gent T Walsh CSPLib A benchmark library constraints Technical Report APES091999 1999 14 W Harvey Personal email communication 2002 15 B Hnich Function variables constraint programming PhD thesis Department Information Science Uppsala University 2003 16 ILOG SA ILOG Solver 53 Reference User Manual 2002 17 Z Kiziltan Symmetry breaking ordering constraints PhD thesis Uppsala University 2004 18 AK Mackworth Consistency networks relations Artiﬁcial Intelligence 8 1977 99118 19 AK Mackworth On reading sketch maps Proceedings 5th International Joint Conference Artiﬁcial Intelligence 1977 pp 598 606 20 P Meseguer C Torras Solving strategies highly symmetric CSPs T Dean Ed Proceedings 16th International Joint Conference Artiﬁcial Intelligence IJCAI99 Morgan Kaufmann 1999 pp 400405 21 L Proll BM Smith Integer linear programming constraint programming approaches template design problem INFORMS Journal Computing 10 3 1998 265275 22 JF Puget On satisﬁability symmetrical constrained satisfaction problems HJ Komorowski ZW Ras Eds Proceedings 7th International Symposium Methodologies Intelligent Systems ISMIS93 Lecture Notes Computer Science vol 689 Springer 1993 pp 350361 834 AM Frisch et al Artiﬁcial Intelligence 170 2006 803834 23 A Schrijver Theory Linear Integer Programming John Wiley Sons 1986 24 BM Smith SC Brailsford PM Hubbard HP Williams The progressive party problem Integer linear programming constraint pro gramming compared Constraints 1 1996 119138 25 I Shlyakhter Generating effective symmetrybreaking predicates search problems Electronic Notes Discrete Mathematics 9 2001 26 Swedish Institute Computer Science SICStus Prolog Users Manual Release 3101 April 2003 27 M Wallace Practical applications constraint programming Constraints 1 12 1996 139168 28 JP Walser Integer Optimization Local SearchA DomainIndependent Approach Lecture Notes Artiﬁcial Intelligence vol 1637 Springer 1999 29 MG Wallace S Novello J Schimpf ECLiPSe A platform constraint logic programming ICL Systems Journal 12 1 1997 159200