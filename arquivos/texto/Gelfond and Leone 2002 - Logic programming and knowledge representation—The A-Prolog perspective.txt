Artiﬁcial Intelligence 138 2002 338 wwwelseviercomlocateartint Logic programming knowledge representationThe AProlog perspective Michael Gelfond Nicola Leone b Department Computer Science Texas Tech University Lubbock TX 794093104 USA b Department Mathematics University Calabria 87030 Rende CS Italy Abstract In paper short introduction logic programming approach knowledge representation reasoning The intention help reader develop feel ﬁelds history recent developments The discussion mainly limited logic programs answer set semantics For understanding approaches logic programming built wellfounded semantics general theories argumentation abductive reasoning reader referred publications 2002 Elsevier Science BV All rights reserved Keywords Logic programming Nonmonotonic reasoning Default reasoning Answer set programming 1 Introduction If want design entity machine program capable behaving intelligently environment need supply entity sufﬁcient knowledge environment To need unambiguous language capable expressing knowledge precise understood way manipulating sets sentences language allow draw inferences answer queries update knowledge base desired program behavior A good knowledge representation language allow construction elaboration tolerant knowledge bases bases small modiﬁcations informal body knowledge correspond small modiﬁcations formal base representing knowledge Around The work Michael Gelfond partially supported NASA contract ncc9143 The work Nicola Leone partially supported European Commission project ICONS project IST200132429 Corresponding author Email addresses mgelfondcsttuedu M Gelfond leoneunicalit N Leone 0004370202 matter 2002 Elsevier Science BV All rights reserved PII S 0 0 0 4 3 7 0 2 0 2 0 0 2 0 7 2 4 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 1960 McCarthy 8384 proposed use logical formulas basis knowledge representation language type It soon suggested tool adequate 94 This especially true modeling commonsense behavior agents additions agents knowledge frequent inferences based absence knowledge It reasoning better modeled logical languages nonmonotonic consequence relations allow new knowledge invalidate previous conclusions In precise terms consequence relation language L called nonmonotonic formulas A B set formulas T T B T A cid4 B Obviously consequence relation classical logic satisfy property monotonic The observation led development investigation new logical formalisms nonmonotonic logics The best known circumscription 8586 default logic 111 nonmonotonic modal logics 888995 All logics superclassical viewed extension classical predicate propositional logic Another direction research started Green 55 Hayes 56 Kowalski 61 continued combined idea logic representation language theory automated deduction constructive logic This led Kowalski Colmerauer creation logic programming 6162124 development logic programming language Prolog 23 Even logic programming nonmonotonic logic share common goals techniques time strong ties research communities Originally Prolog deﬁned small subset predicate calculus This dialect Prolog called Pure Prolog The restricted syntax Pure Prolog makes possible efﬁciently organize process inference semantics relies heavily classical modeltheoretic notion logical entailment Unlike nonmonotonic logics emphasis expressiveness efﬁciency development programming methodology main concern logic programming community With time Prolog evolved incorporate nonclassical nonmonotonic features closer spirit nonmonotonic logics mentioned The important nonmonotonic feature modern Prolog negation failure The initial deﬁnition construct incorporated original Prolog interpreter purely procedural inhibited use knowledge representation software engineering investigation relationship logic programming nonmonotonic formalisms Work started Clark Reiter late 1970s 30110 aimed development declarative semantics logic programs negation failure Further work direction proved fruitful logic programming artiﬁcial intelligence databases The results uncovered deep similarities seemingly different approaches formalization nonmonotonic reasoning shed new light nature rules negation failure operator Prolog Among things led development knowledge representation reasoning language AProlog discussed paper logic programming based languages nonmonotonic semantics 116212457127 Unlike Prolog languages welldeﬁned declarative semantics independent particular inference mechanism Unlike original nonmonotonic logics M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 5 superclassical Instead use collection new connectives believe suitable representing forms nonmathematical knowledge classical counterparts Papers published issue selected presented LPNMR9915th International Conference Logic Programming NonMonotonic Reasoning held 1999 El Paso Texas These papers signiﬁcant extensions respective versions presented conference They deal different aspects LPNMR knowledge representation reasoning 72 computational complexity 54 systems 118 updates 2 revision 76 applications 31 The research work presented 54 received best paper award LPNMR99 This introductory paper aimed providing potential readers background information This survey ﬁeld small collection ideas results help reader develop feel ﬁelds history recent developments There substantial number books surveys closely related logic programming nonmonotonic reasoning Accurate mathematical exposition related formalisms 1771737482 For applications aspects knowledge representation look 1910283239455152 98100102115116122 Issues related reasoning methods Prolog discussed 397101 Additional information important historical perspective obtained 79192 An indepth coverage aspects knowledge representation reasoning AProlog forthcoming book 8 logicbased works artiﬁcial intelligence collected 93 The rest paper organized follows Section 2 presents syntax semantics AProlog deﬁnes couple relevant syntactic fragments Section 3 addresses computational aspects describes algorithms reasoning associated AProlog programs Section 4 treats knowledge representation illustrates basic methodology representing knowledge AProlog examples Section 5 highlights relationship AProlog nonmonotonic formalisms Section 6 discusses treatment negation logic programming Section 7 analyzes computational complexity AProlog fragments paying special attention impact syntactic restrictions negation disjunction Section 8 comments general properties entailment operators Finally Section 9 draws conclusions 2 The AProlog language We start description syntax semantics AProlog called Answer Set Programming 81a logic programming language based answer setsstable model semantics 4950 1 The ﬁrst LPNMR organized 1991 Anil Nerode Since time conference served main meeting place people interested subjects 6 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 21 Syntax The syntax AProlog determined signature σ consisting types typesσ τ0 τm object constants objτ σ c0 cm type τ typed function predicate constants funcσ f0 fk predσ p0 pn We assume signature contains symbols integers standard functions relations arithmetic Terms built typed ﬁrstorder languages positive literals atoms form pt1 tn ts terms proper types p predicate symbol arity n negative literals form pt1 tn The symbol called classical strong negation2 Literals form pt1 tn pt1 tn called contrary By l denote literal contrary l Literals terms containing variables called ground The sets ground terms atoms literals σ denoted termsσ atomsσ litσ respectively For set P predicate symbols σ atomsP σ litP σ denote sets ground atoms literals σ formed predicate symbols P Consistent sets ground literals signature σ containing arithmetic literals true standard interpretation symbols called states σ denoted statesσ A rule AProlog expression form l0 lk lk1 lm lm1 ln 1 li s literals logical connective called negation failure default negation called epistemic disjunction The following notation useful discussion A set li lik denoted notli lik If r rule type 1 headr l0 lk posr lk1 lm negr lm1 ln bodyr posr negr A rule headr called constraint written lk1 lm lm1 ln If k 0 write l0 l1 lm lm1 ln 2 3 Default negation interpreted new logical connective Intuitively l says reason believe l Notice use symbol instead classical The meaning differs A formula A B says A true B true rule A B interpreted epistemically means A believed true B believed true This approach viewed generalization 2 Logic programs negations appeared 50 strongly inﬂuenced epistemic interpretation logic programs given Under view p interpreted believe p false explains term classical negation authors A different view advocated 104126 authors considered logic programs negation failure They demonstrated context logic programs viewed theories variant intuitionistic logic strong negation 96 For recent work subject 105106 We believe views proved fruitful continue play important role understanding AProlog A somewhat different view semantics programs negations 1 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 7 early work J Minker 90 A rule r bodyr called fact written l0 lk 4 Deﬁnition 21 A program AProlog pair σ Π σ signature Π collection rules form 1 In paper refer programs AProlog logic program denote second element Π The corresponding signature denoted σ Π 22 Semantics In deﬁnition semantics AProlog assume ls rule 1 ground Rules variables denoted capital letters shorthand sets ground instantiations This approach justiﬁed called closed domains domains satisfying domain closure assumption 110 asserts objects domain discourse names language Π Even assumption undoubtedly useful broad range applications cases properly reﬂect properties domain discourse Semantics AProlog open domains 958 The answer set semantics logic program Π assigns Π collection answer setsconsistent sets ground literals signature σ Π corresponding beliefs built rational reasoner basis rules Π In construction beliefs reasoner assumed guided following informal principles He satisfy rules Π understood constraints form If believes body rule believe literals rules head He adhere rationality principle says shall believe forced believe The precise deﬁnition answer sets ﬁrst given programs rules contain negation failure Let Π program let S state σ Π We S closed Π rule l0 lk lk1 lm 5 Π lk1 lm S l0 lk S cid4 Notice constraint condition means body contained S Deﬁnition 22 Answer setpart A state S σ Π answer set Π S minimal sense settheoretic inclusion sets closed Π It shown program epistemic disjunction answer set To extend deﬁnition arbitrary programs program Π let S state σ Π The reduct Π S Π relative S set rules l0 lk lk1 lm 8 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 rules 1 Π lm1 ln S Thus Π S program negation failure Deﬁnition 23 Answer setpart A state S σ Π answer set Π S answer set Π S The deﬁnition differs slightly original deﬁnition 50 allowed inconsistent answer set litσ Answer sets deﬁned paper correspond consistent answer sets original version Knowledge represented programs AProlog frequently different reasoning tasks associated entailment relations deﬁned Deﬁnition 24 Entailment relations 1 A program Π cautiously entails literal l Π l l belongs answer sets Π 2 A program Π bravely entails literal l Π b l l belongs answer sets Π Obviously programs having precisely answer set brave cautious entailment coincide Some query answering systems AProlog based notion cautious entailment use brave Given query l program Π cautious systems ﬁrst check Π l If case cautious answer l yes Π l cautious answer unknown In contrast brave systems attempt ﬁnd answer set Π containing l If answer set brave answer l yes Example 21 Consider instance logic program Π0 pa qa pb qb qa Using deﬁnition answer sets easily S0 qa pb answer set program In section introduce simple techniques allow answer set Π0 Thus Π0 qa Π0 cid4 qb Π0 cid4 qb Π0s cautious answers queries qa qb yes unknown respectively The corresponding brave answers yes If expand Π0 rule qX qX resulting program Π1 Π0 6 6 answer set S qa qb pb cautious answer query qb The brave answer qb change Notice brave answer query qb change yes M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 9 Rule 6 read reason believe X satisﬁes q called closed world assumption relation q 110 It guarantees reasoners beliefs q complete ground term t answer set S corresponding program qt S qt S It worthwhile noting brave inference operator b entail literal l contrary l Example 22 Consider following program cid4 pa pa pa pa It easy program answer sets pa pa Thus pa pa brave consequences program program cautious consequence The cautious inference operator entail time literal l contrary l program answer set 23 Program properties In section discuss useful properties logic programs We hope help readers better understand notion answer set provide insight comparatively rich mathematical theory AProlog 231 The basics The following simple propositions 96677 frequently establish basic properties logic programs Proposition 21 For answer set S logic program Π For rule 1 Π lk1 lm S lm1 ln S exists 0 cid1 cid1 k li S b If l S l supported Π exists rule r Π type 1 lk1 lm S lm1 ln S l0 lk S l Proposition 22 For program Π S0 S1 answer sets Π S0 S1 S0 S1 Let use propositions S0 qa pb answer set program Π0 Example 21 Suppose S1 answer set Π0 By Proposition 21 qa S1 qb S1 pb S1 S0 S1 By Proposition 22 S0 S1 Programs AProlog zero answer sets One use propositions deﬁnition answer sets programs Π2 pa pa M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 10 Π3 pa pa answer sets program Π4 Π4 e0 essX eX psX eX pX pX eX psX inﬁnite collection Finally let look examples containing connectives It easy minimality condition deﬁnition answer set program Π5 pa pb answer sets S1 pa S2 pb However wrong view epistemic disjunction exclusive We conjunction Q l1 ln literals true set S l1 ln S Q true S li S Q undeﬁned S Obviously pa pb pa pb holds S1 S2 Π5s answer query Q unknown It instructive contrast Π5 program Π6 Π5 pa pb answer sets S3 pa pb S4 pb pa clearly contains pa pb consequences The notion answer set extension earlier notion stable model deﬁned 49 normal logic programs nlp Syntactically nlp simply logic program consisting rules type 3 ls atoms But stable models nlp Π identical answer sets meaning Π stable model semantics different answer set semantics The difference caused closed world assumption hardwired deﬁnition stable entailment s nlp Π s pa iff stable model S Π pa S In words absence reason believing pa sufﬁcient conclude falsity To match stable model semantics Π terms answer sets need expand Π explicit closed world assumption CWAΠ Π pX pX predicate symbol p Π Now easily shown ground literal l Π s l iff CWAΠ l The proposition 950 shows programs AProlog reduced programs We need following notation For predicate p occurring Π let pcid20 new predicate arity The atom pcid20t1 tn called positive form negative literal pt1 tn Every positive literal deﬁnition positive form The positive form literal l denoted l Π called positive form Π stands normal logic program obtained Π replacing rule 1 l m1 l n l 0 l k k1 l m l M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 11 adding rules pt1 tn pcid20t1 tn atom pt1 tn σ Π For set S literals S stands set positive forms elements S Proposition 23 A set S litσ Π answer set Π S answer set Π It worthwhile noting answer set ﬁnders including DLV 2742 SMODELS 99118 use rewriting technique implement strong negation 232 Some syntactic properties programs In section introduce syntactically deﬁned classes logic programs number useful interesting properties These similar properties proving correctness AProlog based knowledge reasoning systems First need following Deﬁnition 25 Functions ground atoms σ Π ordinals called level mappings Π Level mappings useful technique describing classes programs Deﬁnition 26 A logic program Π called locally stratiﬁed 4107 level mapping s Π rule r Π 1 l posr lcid20 headr ls cid1 lcid20s 2 l negr lcid20 headr ls lcid20s It easy program Π0 Section 2 stratiﬁed programs Π2 Π4 Theorem 21 A locally stratiﬁed normal program exactly answer set The theorem easy consequence results 4107 establish existence uniqueness intended perfect model locally stratiﬁed logic program results showing perfect models programs coincide stable models It worthwhile noting statement holds normal logic programs presence epistemic disjunction presence strong negation invalidates theorem For instance locally stratiﬁed program b answer sets b program locally stratiﬁed answer sets Theorem 21 example collection results establishing existence uniqueness answer sets 12 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 Another interesting class consists headcycle free programs Deﬁnition 27 A logic program Π called headcycle free hcf 11 level mapping h Π rule r Π 1 l posr lcid20 headr lh cid1 lcid20h 2 pair l lcid20 headr lh cid4 lcid20h Example 23 Consider following program Π7 cid4 b b Π7 It easy Π7 headcycle free Consider program Π8 Π7 b Program Π8 headcycle free b belong level condition 1 condition 2 Among things headcycle free programs interesting epistemic disjunction safely eliminated shifting head atoms bodies rules More precisely shΠ denote disjunctionfree program obtained Π substituting rule form a1 ak b1 bm c1 cn following k rules ai b1 bm c1 cn a1 ai1 ai1 ak ranges interval 1 k Theorem 22 11 If Π headcycle free program Π shΠ exactly answer sets It easy headcycle free condition essential program Π8 answer set b shΠ8 Later general epistemic disjunction eliminated AProlog loss expressive power language 3 Reasoning algorithms AProlog There different systems reasoning programs AProlog The choice normally depends form program type queries wants answered Suppose instance program Π inﬁnite Herbrand universe belongs class called acyclic programs 5 A program called acyclic level mapping atom l occurring body M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 13 rule head l0 l0 l A normal acyclic logic program Π stratiﬁed unique answer set It shown queries Π answered variety bottomup evaluation algorithm instance 5 Moreover acyclicity R0 results 6120 guarantee SLDNF resolution based interpreter Prolog terminate atomic queries produce intended answers Similar approximation AProlog entailment larger classes programs unique answer sets obtained called XSB 21 implementing wellfounded semantics 125 Of course traditional logic programming inference algorithms work programs multiple answer sets Some algorithms addressing reasoning programs based close relationship answer sets truth maintenance systems 373847 In recent years number substantially efﬁcient algorithms developed reason programs ﬁnite Herbrand universes number modern AProlog systems available Two best known systems DLV 2742 SMODELS 118 systems support AProlog extent including CCALC 87 DCS 33 QUIP 34 DeRes 22 In section brieﬂy sketch algorithmsthe procedure underlying computational engine DLV 2742 Similar computational schemes answer set ﬁnding systems SMODELS 118 The ﬁrst subsection illustrates procedure computation answer set AProlog program Π The second subsection describes procedure answering queries 31 Computing answer set In subsection method computing answer set program Π contain strong negation In ﬁrst step computation AProlog replaces program Π normally contains variables ground instantiation groundΠ It worthwhile noting groundΠ set syntactically constructible instances rules Π smaller subset having precisely answer sets Π The ability grounding procedure construct small ground instantiation program dramatically affect performance entire As shown 40 adoption database rewriting techniques proved useful reducing size ground instantiation Once variables eliminated Π hard computation performed Π0 groundΠ The heart computation performed Model Generator sketched Fig 1 Roughly Model Generator produces candidate answer sets Π0 The stability subsequently checked function IsAnswerSetI veriﬁes given candidate I minimal model reduct Π I 0 Π0 relative I The function IsAnswerSetI returns true interpretation I hand answer set false 60 details function 14 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 Function ModelGeneratorI Interpretation Boolean var inconsistency Boolean begin I DetConsI I litσ return false inconsistency atom undeﬁned I return IsAnswerSetI Select undeﬁned ground atom l according heuristic ModelGeneratorI l return true return ModelGeneratorI l end Fig 1 Computation answer sets The Model Generator ﬁrst called parameter I set interpretation3 If program Π answer set function returns true setting I computed answer set returns false The Model Generator similar DavisPutnam procedure employed SAT solvers It ﬁrst calls function DetCons returns extension I literals deterministically inferred I set literals litσ inconsistency This function 1941 details similar unit propagation procedure employed SAT solvers exploits peculiarities AProlog making inferences exploits knowledge answer set minimal model supported If DetCons detect inconsistency atom l selected according heuristic criterion ModelGenerator recursively called I l I l explore I extended answer set Π If calls succeeds function stops returning true answer set Π Upon failure calls function returns false I extended answer set It worthwhile remarking importance criterion choosing atom l The atom l plays role branching variable SAT solver And like SAT solvers selection good atom l crucial performance AProlog The adopted heuristic major differences existing AProlog systems causes relevant performance gaps An experimental analysis number heuristics AProlog systems 42 32 Query answering The method computing answer sets AProlog programs illustrated previous section implement brave cautious reasoning general AProlog programs 3 An interpretation set ground literals representing 3valued state σ Π An atom l true l I false l I undeﬁned respect interpretation I During computation undeﬁnedness eliminated eventually converge 2valued state M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 15 Let L ground literal possibly preceded default negation By ΠL denote program Π addition following constraint l L l ii l L l The answer sets ΠL exactly answer sets Π L happens true Let Π AProlog program possibly containing l ground literal To answer query l Π brave cautious entailments proceed follows Build positive form Πl Πl4 Evaluate program Πl Brave reasoning described previous subsection If Πl answer set l brave consequence Π Π b l Build positive form Πnot l Πnot l Πnot l Cautious reasoning Πnot l respectively Evaluate programs Πnot l Πnot l described previous subsection If Πnot l answer set l cautious consequence Π Π l If Πnot l answer set l cautious consequence Π Π l 4 A simple knowledge base To illustrate basic methodology representing knowledge AProlog let consider following example Example 41 Let cs small science department located college science cos university u The department described list members catalog courses stages creating summer teaching schedule In example outline construction simple AProlog knowledge base K containing information department For simplicity assume openended signature containing names courses departments The list catalog naturally correspond collections atoms membersam cs memberbob cs membertom cs coursejava cs coursec cs courseai cs courselogic cs closed world assumptions expressed rules memberP cs memberP cs courseC cs courseC cs 7 8 The assumptions justiﬁed completeness corresponding information The preliminary schedule described list teachessam java teachesbob ai 9 Since schedule incomplete use CWA teaches appropriate The corresponding program correctly answers query membermary cs unknown query teachesmary c 4 See Section 23 deﬁnition positive form properties 16 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 Let expand knowledge base K statement Normally science courses taught science professors The logic course exception rule It taught faculty math department This typical default weak exception5 represented AProlog rules teachesP C memberP cs courseC cs abd1P C teachesP C abP logic memberP math 10 Here d1P C default rule abd1P C says default d1P C applicable pair cid26P Ccid27 The second rule stops application default P math professor Assuming membermary math 11 K Ks answer query teachesmary c answer query teachesmary logic remain unknown It worth noting information persons membership departments complete second rule 10 replaced simpler rule abP logic memberP math 12 It difﬁcult resulting programs answer sets To complete deﬁnition teaches let expand K rule says Normally class taught person This easily rule teachesP1 C teachesP2 C P1 cid4 P2 abd2C teachesP1 C 13 Now learn logic taught Bob able conclude taught Mary The knowledge base K constructed far elaboration tolerant respect simple updates We easily modify departments membership lists course catalogs Our representation allows strong exceptions defaults statements like teachesjohn ai 14 defeats corresponding conclusion default 10 As expected strong exceptions inserted K causing contradiction 5 An exception default called weak stops application default defeating conclusion M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 17 Let switch attention deﬁning place department university This expanding K rules partcs cos partcos u partE1 E2 partE1 E partE E2 partE1 E2 partE1 E2 memberP E1 partE2 E1 memberP E2 15 16 The ﬁrst facts form hierarchy university organizational chart The rule expresses transitivity relation The rule 15 closed world assumption justiﬁed K contains complete organizational chart university If case closed world assumption member expanded rules memberP Y memberP Y 17 Let closer look program theory AProlog allows discover interesting properties First let K exactly answer set A0 Let K positive form K It easy locally stratiﬁed Theorem 21 unique answer set S By Proposition 21 conclude atom l l l S This implies S consistent Proposition 23 answer set K This fact Proposition 21 allows K correctly entail sam member university u u The answer set K computed DLV directly minor modiﬁcations needed run K SMODELS enforce domain restrictedness 118 To check sam member university form query membersam u 18 Asking DLV answer membersam u program K cautious entailment6 precisely response query DLV provides simple means displaying terms satisfying relations deﬁned program use list members CS faculty Readers knowledge Prolog undoubtedly noticed K suitable use Prolog interpreter The program problem left recursion rule 15 In addition Prolog interpreter ﬂounder7 large number queries K 6 In practice adding membersam u ﬁle containing program K running DLV option FC specify cautious entailment required 7 Prolog interpreter said ﬂounder execution arrives negative query containing variables In Prolog ﬂoundering constitutes programming error 18 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 Fortunately ﬂoundering eliminated use type predicates A standard left recursion elimination applied K replace recursive rules 15 part_of E1 E2 partE1 E2 part_of E1 E2 partE1 E part_of E1 E2 part_of E1 E2 part_of E E2 19 Using termination soundness completeness results Prolog type inference instance 56 difﬁcult transitive closure relation irreﬂexive Prolog interpreter terminates returns correct answer queries formed predicates part_of member Let expand K new relation offeredC D deﬁned following self explanatory rules offeredC D courseC D teachesP C offeredC D courseC D offeredC D 20 Suppose Tom Bob scheduled teach class logic A natural representation fact requires disjunction expressed teachestom logic teachesbob logic 21 It easy resulting program answer sets answer set contains offeredlogic cs The corresponding reasoning automatically DLV The example shows AProlog disjunction allows natural form reasoning casesa mode reasoning easily modeled Reiters default logic It worth noting program headcycle free Theorem 22 disjunctive rule 21 replaced nondisjunctive rules teachestom logic teachesbob logic teachesbob logic teachestom logic 22 resulting program equivalent original Now SMODELS DLV reason resulting knowledge base It important notice development executable program series transformation preserving initial possibly nonexecutable speciﬁcation standard programming methodology The example shows declarativeness AProlog development new reasoning algorithms allowed shorten transformation process programming easier Even example disjunction eliminated simple transforma tion complexity results 29 possible Consider instance following example 18 Example 42 Suppose holding owns companies producing set prod ucts Each product produced companies We use relation produced_byP C1 C2 holds product P produced companies C1 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 19 C2 The holding consists companies producing products represented follows produced_byp1 b s produced_byp2 f b produced_byp3 b b produced_byp4 s p This slightly artiﬁcial representation requires company producing unique product repeated twice case p3 simplify presentation Suppose given relation controlled_byC1 C2 C3 C4 holds companies C2 C3 C4 control company C1 In holding b s control f represented controlled_byf b s s Suppose holding needs sell companies policy situations maintain ownership called strategic companies companies belonging minimal respect set theoretic inclusion set S satisfying following conditions 1 Companies S produce products 2 S closed relation controlled_by companies C2 C3 C4 belong S C1 It easy holding set b s strategic set b s f Suppose like write program given holding form computes sets strategic companies In AProlog follows Consider rules 1 stratC1 stratC2 produced_byP C1 C2 2 stratC1 controlled_byC1 C2 C3 C4 stratC2 stratC3 stratC4 deﬁning relation stratC C strategic Let Π program consisting rules 1 2 input database X type described The ﬁrst rule guarantees answer set A Π product p company c producing p atom stratc A The second rule ensures answer set Π set atoms form stratc belonging set closed relation controlled_by Minimality set follows minimality condition deﬁnition answer set It difﬁcult check answer sets Π correspond onetoone strategic sets holding described input database The DLV reasoning asked ﬁnd answer set Π display atoms form strat It worthwhile noting disjunction plays crucial role example essential encode problem The program headcycle free transforming disjunction unstratiﬁed negation alter semantics program Moreover design AProlog program encoding Strategic Companies disjunction Indeed Strategic Companies problem P 2 hard 18 20 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 normal logic programs express problems NP Section 7 derive Strategic Companies expressed ﬁxed normal logic program uniformly collections facts produced_byp c1 c2 controlled_byc c1 c2 c3 NP P 2 unlikely event 18 5 Logic programming nonmonotonic formalisms Even afﬁnity logic programs nonmonotonic logics recognized early 67112 intensive work investigating phenomenon started 1987 discovery model theoretic semantics stratiﬁed logic programs 4 Almost immediately notion introduced stratiﬁed logic programs mapped major nonmonotonic formalisms investigated time circumscription 68107 autoepistemic logic 48 default theories 1278 Further work direction proved fruitful logic programming artiﬁcial intelligence The results uncovered deep similarities seemingly different approaches formalization nonmonotonic reasoning shed new light nature rules negation failure operator Prolog One results direction research development AProlog knowledge representation languages nonmonotonic semantics In section results establishing relationship AProlog nonmonotonic logics 51 AProlog autoepistemic logic We start autoepistemic logic 95 formulas built proposi tional atoms propositional connectives modal operator B Deﬁnition 51 For sets T E autoepistemic formulas E said stable expansion T iff E CnT Bφ φ EBψ ψ E Cn propositional consequence operator Intuitively T set axioms E possible collection reasoners beliefs determined T A formula F said true T F belongs stable expansions T If T contain modal operator B T unique stable expansion 79 We denote expansion ThT Let consider class G programs AProlog consists rules form p0 p1 pm pm1 pn ii p p atom p 23 0 cid1 m cid1 n Let α mapping maps rules ii autoepistemic formulas p1 pm B pm1 B pn p0 ii B p p let αΠ αr r Π 24 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 21 Proposition 51 For program Π G set A literals language Π A answer set Π iff ThA stable expansion αΠ Moreover stable expansion αΠ represented form Mapping α simple generalization mapping 48 shown declarative semantics stratiﬁed logic programs characterized terms autoepistemic theory obtained transformation negation failure understood epistemic operator The stronger result establishes toone correspondence stable models arbitrary normal logic program Π stable expansions αΠ There interesting mappings programs AProlog autoepistemic logic variants instance 207080117 Even results substantially increase understanding situation suggested mappings provide good explanation meaning connectives AProlog terms autoepistemic logic 52 AProlog Reiters default theories A Reiters default expression form p M j1 M jn f 25 p f j s quantiﬁerfree ﬁrstorder formulas8 f called consequent default p prerequisite j s justiﬁcations An expression M j interpreted consistent believe j A pair cid26D W cid27 D set defaults W set ﬁrstorder sentences called Reiters default theory Deﬁnition 52 Let cid26D W cid27 default theory E set ﬁrstorder sentences Consider E0 W cid2 0 let Di set defaults form 25 D p Ei j1 E jn E Finally let Ei1 ThEi conseqδ δ Di ThEi set classical consequences Ei conseqδ denotes δs consequent The set E called extension cid26D W cid27 E cid6 0 Ei Extensions default theory D play role similar stable expansions autoepistemic theories The simple mapping α programs AProlog disjunction default theories identiﬁes rule r l0 l1 lm lm1 ln default αr l1 lm M lm1 M ln l0 26 8 We limit quantiﬁerfree case For interesting discussion defaults quantiﬁers 69 59 22 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 recall l stands literal complementary l Proposition 52 For nondisjunctive program Π AProlog S answer set Π ThS extension αΠ ii extension E αΠ exactly answer set S Π E ThS Thus class nondisjunctive AProlog programs identiﬁed class default theories W defaults form 26 This proposition 50 simple extension results 12 78 authors considered relationship normal logic programs Perhaps somewhat surprisingly easily generalized program disjunction One problems ﬁnding natural translation arbitrary AProlog programs default theories related inability use defaults justiﬁcations reasoning cases The default theory cid4 cid7 q p r p D W q r extension containing p entail p The correspond ing logic program p q p r q r answer sets p q p r entails p 6 AProlog negation logic programs In section brieﬂy discuss treatment negation logic programming Let start deﬁnite programs programs consisting rules l0 l1 lm 27 ls atoms Traditionally programs viewed complete deﬁnitions objects relations domain lack information truth pa interpreter evidence falsity This familiar closed world assumption theoretically formalized inference rule form Π cid4 l l equivalently l MΠ l 28 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 23 MΠ minimal Herbrand model Π Of course statements qualify inference rules First premises logical formulas statements meta language Second nonprovability deﬁnite programs undecidable possible determine rule applicable As result somewhat weaker version CWA implemented Prolog l derivable Π goal l ﬁnitely failed SLD tree respect Π For deﬁnition SLD trees related concepts 3 101 l ﬁnitely failed SLD tree l 29 To better understand difference let consider program Π p p It easy 28 entails p 29 The Prolog interpreter answering query p Π inﬁnite loop The difference divide work semantics negation Prolog parts One approach attempts formalize systems based rule 28 interested generalizations rule 29 For simplicity limit discussion semantics normal logic programs programs consisting rules form l0 l1 lm lm1 ln ls necessarily ground atoms 61 Clarks completion 30 The research ﬁnding declarative semantics nlp negation started pioneering work Clark 30 Given nlp Π view bodies rules predicate p heads sufﬁciency conditions inferring p program Clark suggested bodies rules taken necessary conditions result negative information p assumed conditions met More precisely let consider following step transformation nlp Π collection ﬁrstorder formula Step 1 Let r Π headr pt1 tk Y1 Ys list variable appearing r By α1r denote formula Y1 Ys X1 t1 Xk tk l1 lm lm1 ln pX1 Xk X1 Xk variables appearing r 31 α1Π α1r r Π Step 2 For predicate p E1 pX1 Xk Ej pX1 Xk 24 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 implications α1Π p conclusions replace formulas X1 Xk pX1 Xk E1 Ej j cid2 1 X1 Xk qX1 Xk j 0 Deﬁnition 61 The resulting ﬁrstorder theory combined free equality axioms 30 called Clarks completion Π denoted CompΠ A literal l entailed Π l ThCompΠ The following theorem 4 establishes relationship models Clarks completion Π notion supported model A set S atoms supported Π l S rule 30 l1 lm S lm1 ln S Theorem 61 A set S atoms model Clarks completion Π iff S supported closed rules Π Models Clarks completion obviously differ answer sets Π Program p p Clarks models p answer set This shall surprisingthe completion semantics intends capture notion ﬁnite failure particular inference mechanism SLDNF resolution answer sets semantics formalizes general notion default negation It important note theorem immediately implies literal entailed Π respect Clarks semantics entailed Π respect answer set semantics The existence Clarks declarative semantics facilitated development theory logic programs It possible ﬁrst proofs correctness inference mechanism based SLDNF resolution certain transformations logic programs foldunfold 121 proofs equivalence properties programs It widely successfully logic programming applications Unfortunately situations Clarks semantics appears weak Consider instance following example Example 61 Suppose given graph edgea b edgec d edged c want vertices graph reachable given vertex The natural solution introduce rules reachablea reachableX edgeY X reachableY M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 25 We clearly expect vertices c d reachable However Clarks completion predicate reachable gives reachableX cid8 X Y reachableY edgeY X cid9 conclusion derived The difﬁculty recognized prompted development logic programming semantics including AProlog Even comparatively knowledge representation languages use Clarks completion basis semantics notion didnt loose importance As illustration let consider use computing answer sets logic programs We need following terminology Deﬁnition 62 A nlp Π called tight level mapping Π rule 30 Π l0 l1 lm 32 Theorem 62 If Π tight S model CompΠ iff S answer set Π The theorem F Fages 43 There recent results extending notions Clarks completion tightness discovering general conditions equivalence semantics Note semantics Π equivalent Π s answer sets computed satisﬁability solver cases efﬁcient direct use SMODELS DLV More work 14 62 Threevalued approaches There important modiﬁcations Clarks semantics based use threevalued logic The ﬁrst modiﬁcation 446364 aimed capturing ﬁnite failure respect SLDNF resolution uses threevalued completion program The following example illustrates difference twovalued valued completions Example 62 Consider program Π9 p p q It easy COMPΠ9 inconsistent threevalued completion consistent unique model p undeﬁned q true This corresponds behavior SLDNF resolution answers yes q goes loop query p SLDNF resolution sound respect valued completion Unfortunately incomplete shown 26 sources incompleteness 26 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 ﬂoundering unfair selection literals SLDNF derivation Since multiple sufﬁcient conditions avoiding ﬂoundering threevalued completion SLDNF resolution good match The wellfounded semantics 125 formalizes negation viewed necessarily ﬁnite failure To precise deﬁnition need following terminology For nlp Π function sets literals sets literals deﬁned equation γΠ X A 33 A answer set reduct Π X Deﬁnition 23 answer set It clear answer sets Π characterized ﬁxpoints γΠ It difﬁcult X Y γΠ Y γΠ X This implies function γ 2 Π monotone ﬁxpoint Atoms belonging ﬁxpoint called wellfounded relative Π Atoms belonging complement greatest ﬁxpoint γ 2 Π called unfounded relative Π Deﬁnition 63 A threevalued interpretation assigns 1 true atoms wellfounded relative Π 0 false atoms unfounded relative Π 12 undeﬁned remaining atoms called wellfounded model Π A literal l wellfounded consequence Π true Π s wellfounded model From deﬁnition easily nlp wellfounded model wellfounded consequence Π Π s consequence respect stable model semantics To better understand difference semantics let look examples Example 63 Consider program Π9 Example 62 It stable model Π9s set stable consequences consists p p q q In contrast wellfounded consequence Π9 q The set unfounded atoms undeﬁned atom p Example 64 Consider following program Π10 p p b b b Π10 stable models p p b The wellfounded model Π10 sets wellfounded unfounded atoms Therefore p consequence Π3 stable model semantics answer p wellfounded semantics undeﬁned M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 27 Finally let look following example 25 Example 65 Consider Π11 consisting rules b b c c This program answer set c c consequences The founded model Π11 wellfounded atoms Its unfounded atoms b c according wellfounded semantics atoms b c undeﬁned There large classes programs wellfounded stable model semantics coincide See instance 13109 The SLDNF resolution sound respect wellfounded semantics complete Several attempts deﬁne variants SLDNF resolution compute answers goals according wellfounded entailment One interesting approach SLS resolution 108 113 SLS resolution based type oracle viewed algorithm There algorithms systems viewed SLS based approximations wellfounded semantics 1521 One powerful systems XSB wwwcssunysbedu sbprologxsbpagehtml expands SLDNF tabling loop checking Its use allows avoid loop related problems Prolog For instance XSBs answer query reachablec program Example 61 Prolog interpreters loop query 7 Computational complexity In section short overview results computational complexity AProlog programs 71 Motivations One wonder interested analyzing complexity AProlog This question addressed clearly Gottlob 53 pointed main reasons interested studying worst case complexity logic programming formalisms We report reasons First worst case complexity good indicator sources structural complexity inherent problem For example problem NPcomplete contains basically source intractability related choice exponentially candidates If problem P 2 complete usually intermingled sources complexity For instance problem checking AProlog program answer set P 2 complete The sources complexity 1 choice suitable interpretation model reduct program 2 proof model minimal 28 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 Secondly sources complexity identiﬁed develop smart algorithms sources account In addition easier discover tractable polynomial subcases considering syntactic restrictions eliminate sources intractability Finally precise complexity classiﬁcation gives valuable information algorithmic similarity intertranslatability different problems For instance brave reasoning normal orfree AProlog programs brave reasoning headcycle free AProlog programs NPcomplete Table 2 Therefore simple polynomial translations reasoning tasks In particular means implemented reasoning engine theorem prover formalisms easily adapted reasoning engine formalism In cases translations decision problems complete complexity class easily deduced respective completeness proofs At underlying intuitions proofs help ﬁnd suitable translation scheme On hand known problems complete different complexity classes polynomial hierarchy existence polynomial translation harder easier problem unlikely For example brave reasoning normal nondisjunctive AProlog programs NPcomplete Table 2 Therefore polynomial hierarchy collapses polynomial translation AProlog programs normal programs exist In summary complexity analysis problem gives merely quantitative statement tractability intractability worst case Rather locating problem right level polynomial hierarchy gives deep qualitative knowledge problem Moreover complexity analysis precious tools develop efﬁcient implementations AProlog systems For instance consider problem checking given set literals answer set This problem coNPcomplete general AProlog programs polynomial headcycle free programs Table 1 Consequently smart implementation function IsAnswerSet Fig 1 able efﬁciently check property program headcycle free Indeed AProlog DLV function devoted answer set checking recognizes input program headcycle free An efﬁcient polynomial time method applied headcycle free programs backtracking procedure employed general non headcycle free AProlog programs Similar considerations apply syntactic fragments having lower complexity general case For instance reasoning normal stratiﬁed programs performed polynomial time procedure Table 3 efﬁcient AProlog 72 Preliminaries complexity polynomial hierarchy We assume reader aquaintance concepts NPcompleteness complexity theory book 103 excellent source deepening knowledge ﬁeld The classes P k 8P k Polynomial Hierarchy PH cf 119 deﬁned follows P 0 8P 0 P k cid2 1 P k NPP k1 8P k coP k M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 29 In particular NP P 1 NPC denotes class problems solvable polynomial time nondeterministic Turing machine oracle problem π class C 1 coNP 8P The oracle replies query unit time roughly speaking models subroutine π evaluated unit time If C complete problems instances problem π cid20 C solved polynomial time oracle Ccomplete problem π transforming instances π refer stating oracle C Notice classes C considered complete problems Observe k cid2 1 P k P k1 PSPACE 8P k 8P k1 PSPACE inclusion widely conjectured strict Note rightmost inclusions classes contain problems solvable polynomial space They allow ﬁner grained distinction NPhard problems PSPACE 73 Main problems considered We study complexity following important decision problems arising AProlog Answer Set Checking Given AProlog program Π set M ground literals input decide M answer set Π Brave reasoning Given AProlog program Π ground literal l decide l true answer sets Π Π b l Cautious reasoning Given AProlog program Π ground literal l decide l true answer sets Π Π l 74 Complexity results We analyze computational complexity decision problems mentioned ground propositional AProlog programs An interesting issue impact syntactical restrictions logic program Π In particular comparing power disjunction power negation intriguing 29 Starting normal positive programs negation disjunction consider effect allowing combined use following constructs strong negation stratiﬁed nonmonotonic negation arbitrary negation headcycle free disjunction arbitrary disjunction The complexity results Answer Set Checking Brave Reasoning Cautious Rea soning AProlog programs summarized Table 1 Table 2 Table 3 respec 30 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 Table 1 The complexity answer set checking syntactic fragments AProlog P P coNP P P coNP nots P P coNP nots P P coNP P P coNP P P coNP h Table 2 The complexity brave reasoning syntactic fragments AProlog nots P NP P 2 nots P NP P 2 h NP NP P 2 P NP P 2 P NP P 2 NP NP P 2 Table 3 The complexity cautious reasoning syntactic fragments AProlog P coNP coNPa P coNP coNPa h nots P coNP 8P 2 nots P coNP 8P 2 coNP coNP 8P 2 coNP coNP 8P 2 Note consider complexity deciding Π L L atom atom negated strong negation Deciding Π L answer set contain L harder precisely problem 8P 2 complete 35 tively Therein column refers speciﬁc form negation negation strong negation nots stratiﬁed negation unrestricted possibly unstratiﬁed negation The lines tables specify allowance disjunction particular disjunction orh headcycle free disjunction unrestricted possibly head cycle free disjunction Each entry table provides complexity class corre sponding fragment language For instance entry orh nots deﬁnes fragment AProlog allowing headcycle free disjunction stratiﬁed negation The cor responding entry Table 2 NP expresses brave reasoning fragment NPcomplete The results reported tables represent completeness logspace reductions taken 29353653 As expected results brave cautious reasoning symmetric cases complexity fragment C brave reasoning complexity coC cautious reasoning recall coP P Strong negation affect complexity reasoning column containing strong negation equal corresponding column Limiting forms disjunction nonmonotonic negation reduces respective powers For disjunction free programs brave reasoning polynomial stratiﬁed negation NPcomplete allow unrestricted nonmonotonic negation Brave reasoning NPcomplete headcycle free programs form negation allowed The M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 31 complexity jumps level higher polynomial hierarchy P 2 complexity disjunction allowed Thus disjunction harder negation complexity reached positive programs kind negation The picture bit different cautious reasoning Full disjunction sufﬁcient complexity cautious reasoning AProlog 8P 2 remains coNP default negation disallowed Intuitively disprove literal l cautious consequence program Π sufﬁcient ﬁnd model need answer set minimal model contain l Indeed free programs existence model guarantees exists answer set Π contain l Therefore cautious inference positive programs easier evaluate programs default negation true brave inference modality The complexity results Answer Set Checking reported Table 1 help understand complexity reasoning Whenever Answer Set Checking coNP complete fragment F complexity brave reasoning jumps second level polynomial hierarchy P 2 Indeed brave reasoning AProlog suffers orthogonal sources complexity exponential number answer set candidates ii difﬁculty checking candidate M answer set minimality M disproved exponential number subsets M Now disjunction unrestricted headcycle free unrestricted negation preserve existence source source ii exists disjunction allowed Table 1 As consequence reasoning lies second level polynomial hierarchy P 2 AProlog fragments complexity sources present goes ﬁrst level PH source present unrestricted negation headcycle free disjunction falling level zero P sources eliminated 8 Further programs properties In previous sections discussed properties logic programs syntactic conditions guaranteeing existence uniqueness answer sets relationship entailment different semantics soundness completeness properties inference systems algorithms In section wed like brieﬂy comment results establishing general properties logic programming entailment relations Let consider AProlog program Π11 Example 65 Its answer set c c consequences Π11 When augmented fact c program gains second answer set b c loses consequence The example demonstrates answer set entailment relation satisfy property Π Π b Π b 34 called cautious monotonicity The absence cautious monotonicity unpleasant property answer set entailment Among things prohibits development general inference algorithms AProlog proven lemmas simply 32 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 added program We class programs cautiously monotonic programs class satisfy condition 34 To example class let consider syntactic condition programs known orderconsistency 114 Deﬁnition 81 For nlp Π atom Π Π rule r Π Π smallest sets atoms headr Π headr Π posr Π posr Π negr Π negr Π Intuitively Π set atoms atom depends positively Π Π set atoms atom depends negatively Π A program Π order consistent level mapping b b Π Π That depends positively negatively b b mapped lower stratum It easy program Π3 Example 64 orderconsistent program Π4 Example 65 The following important theorem H Turner 123 Theorem 81 If Π orderconsistent program atom belongs answer set Π answer set Π answer set Π This immediately implies condition 34 orderconsistent programs A simpler observation guarantees nlps answer set semantics called cut property If atom belongs answer set X Π X answer set Π Both results imply nice property called cumulativity augmenting program consequences alter consequences More precisely Theorem 82 If atom belongs answer set orderconsistent program Π Π Π answer sets Semantic properties cummulativity cut cautious monotonicity originally formulated analysis nonmonotonic consequence relations 4665 Makinsons 75 handbook article includes survey properties nonmonotonic logics AI 9 Conclusion In paper described important themes related research logic programming knowledge representation AProlog The papers volume expand foundations They selected presented LPNMR995th International Conference Logic Programming NonMonotonic Reasoning held 1999 El Paso Texas These papers signiﬁcant extensions respective versions presented conference M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 33 Lifschitzs paper 72 illustrates application declarative programming methodology AProlog planning domain The work Gottlob et al 54 addresses important ﬁxedparameter complexity questions artiﬁcial intelligence nonmonotonic reasoning The paper Alferes et al 2 deals issue updates logic programming introducing language called LUPS specifying dynamic changes knowledge bases Cui Swift 31 report successful application preference logic grammars problem data standardization Marek et al 76 deﬁne annotated version revision programs Marek Truszczynski While revision programs update essentially classical propositional interpretations complete databases annotated revision programs powerful allowing update general Tvaluations Finally Simons Niemelä 118 interesting linguistic extension AProlog allows express cardinality constraints weight constraints naturally illustrates popular AProlog systems SMODELS There number logical languages reasoning methods viewed alternatives AProlog They developed approximately time frame AProlog share roots number basic ideas The relationship mutual fertilization approaches fascinated subject addressed For information interested reader look 116212457127 Acknowledgements The authors grateful Georg Gottlob contribution complexity issues References 1 JJ Alferes LM Pereira Reasoning Logic Programming Springer Berlin 1996 2 JJ Alferes LM Pereira H Przymusinska TC Przymusinski LUPSA language updating logic programs Artiﬁcial Intelligence 138 2002 87116 issue 3 K Apt From Logic Programming Prolog CAR Hoare Series Prentice Hall Englewood Cliffs NJ 1997 4 K Apt H Blair A Walker Towards theory declarative knowledge J Minker Ed Foundations Deductive Databases Logic Programming Morgan Kaufmann San Mateo CA 1988 pp 89148 5 K Apt D Pedreschi Proving termination general prolog programs Proc Internat Conference Theoretical Aspects Computer Software Lecture Notes Computer Science Vol 526 Springer Berlin 1991 pp 265289 6 K Apt A Pellegrini On occurcheck free logic programs ACM Trans Program Language Systems 16 3 1994 687726 7 K Apt R Bol Logic Programming negation A survey J Logic Programming 1920 1994 971 8 C Baral Knowledge representation reasoning declarative problem solving answer sets Unpublished manuscript wwwpublicasueducbaralbahi 9 C Baral M Gelfond Logic programming knowledge representation J Logic Programming 1920 1994 73148 10 C Baral M Gelfond Reasoning agents dynamic domains J Minker Ed Logic Based AI Kluwer Dordrecht 2000 pp 257279 11 R BenEliyahu R Dechter Propositional semantics disjunctive logic programs Ann Math Artiﬁcial Intelligence 12 1994 5387 34 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 12 N Bidoit C Froidevaux General logical databases programs Default logic semantics stratiﬁcation J Inform Comput 91 1 1991 1554 13 N Bidoit C Froidevaux Negation default unstratiﬁable logic programs Theoret Comput Sci 79 1 1991 86112 14 Yu Babovich E Erdem V Lifschitz Fages theorem answer set programming Proc 8th International Workshop NonMonotonic Reasoning Breckeridge CO 2000 15 R Bol L Degerstedt Tabulated resolution wellfounded semantics J Logic Programming 34 2 1998 67110 16 A Bondarenko PM Dung R Kowalski F Toni An abstract argumentationtheoretic approach default reasoning Artiﬁcial Intelligence 93 12 1997 63101 17 G Brewka J Dix K Konolige Nonmonotonic Reasoning An Overview CSLI Publications Stanford 1997 18 M Cadoli T Eiter G Gottlob Default logic query language IEEE Trans Knowledge Data Engrg 9 3 448463 19 F Calimeri W Faber N Leone G Pfeifer Pruning operators answer set programming systems DBAI TR0110 Institut für Informationssysteme Technische Universität Wien Austria April 2001 20 J Chen Minimal knowledge negation failure knowing Proc Second Internat Workshop Logic Programming Nonmonotonic Reasoning Lisbon 1993 pp 132150 21 W Chen T Swift D Warren Efﬁcient topdown computation queries wellfounded semantics J Logic Programming 24 3 1995 161201 22 P Cholewinski W Marek M Truszczynski Default reasoning DeReSe Proc Internat Conference Principles Knowledge Representation Reasoning Morgan Kauffman San Mateo CA 1996 pp 518528 23 A Colmerauer H Kanoui R Pasero P Roussel Un systeme communication hommemachine en Francais Technical Report Groupe Intelligence Artiﬁcielle Université AixMarseilles II Marseilles 1973 24 D De Schreye M Bruynooghe B Demoen M Denecker G Janssens B Martens Project report LP A second generation logic programming language AI Comm 13 1 2000 1318 25 J Dix Classifying semantics logic programs Proc International Workshop Logic Programming NonMonotonic Reasoning Washington DC 1991 pp 166180 26 W Drabent Completeness SLDNFresolution nonﬂoundering queries J Logic Programming 27 2 1996 89106 27 T Eiter N Leone C Mateis G Pfeifer F Scarcello A deductive nonmonotonic reasoning Proc 4th Logic Programming NonMonotonic Reasoning Conference LPNMR97 Lecture Notes Artiﬁcial Intelligence Vol 1265 Springer Dagstuhl 1997 pp 363374 28 T Eiter W Faber N Leone G Pfeifer Declarative problem solving DLV J Minker Ed Logic Based AI Kluwer Academic Dordrecht 2000 pp 79103 29 T Eiter G Gottlob H Mannila Disjunctive Datalog ACM Trans Database Systems 22 3 1997 364 418 30 K Clark Negation failure H Gallaire J Minker Eds Logic Data Bases Plenum Press New York 1978 pp 293322 31 B Cui T Swift Preference Logic grammars Semantics standardization application data standardization Artiﬁcial Intelligence 138 2002 117147 issue 32 Y Dimopoulos B Nebel J Koehler Encoding planning problems nonmonotonic logic programs Recent Advances AI Planning Proc 4th European Conference Planning ECP97 Lecture Notes Artiﬁcial Intelligence Vol 1348 Springer Berlin 1997 pp 169181 33 D East M Truszczynski dcs An implementation DATALOG Constraints Proc 8th International Workshop Nonmonotonic Reasoning NMR2000 Breckenridge CO 2000 34 U Egly T Eiter H Tompits S Woltran Solving advanced reasoning tasks quantiﬁed boolean formulas Proc AAAI00 2000 Austin TX AAAI PressMIT Press Cambridge MA 2000 pp 417 422 35 T Eiter G Gottlob On computational cost disjunctive logic programming Propositional case Ann Math Artiﬁcial Intelligence 15 34 1995 289323 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 35 36 T Eiter N Leone D Saccá Expressive power complexity partial models disjunctive deductive databases Theoret Comput Sci 206 12 1998 181218 37 C Elkan A rational reconstruction nonmonotonic truth maintenance systems Artiﬁcial Intelligence 43 1990 219234 38 K Esghi Computing stable models ATMS Proc AAAI90 Boston MA 1990 pp 272 277 39 E Erdem V Lifschitz M Wong Wire routing satisﬁability planning Proc CL2000 2000 pp 822836 40 W Faber N Leone C Mateis G Pfeifer Using database optimization techniques nonmonotonic reasoning Proc 7th International Workshop Deductive Databases Logic Programming DDLP 99 Japan 1999 pp 135139 41 W Faber N Leone G Pfeifer Pushing goal derivation DLP computations Proc 5th International Conference Logic Programming NonMonotonic Reasoning LPNMR99 El Paso TX Lecture Notes Artiﬁcial Intelligence Vol 1730 Springer Berlin 1999 pp 177191 42 W Faber N Leone G Pfeifer Experimenting heuristics answer set programming Proc IJCAI 01 Seattle WA Morgan Kaufmann San Mateo CA 2001 pp 635640 43 F Fages Consistency Clarks completion existence stable models J Methods Logic Comput Sci 1 1 1994 5160 44 M Fitting A KripkeKleene semantics logic programs J Logic Programming 2 4 1985 295312 45 E Franconi A Laureti Palma N Leone S Perri F Scarcello Census data repair A challenging application disjunctive logic programming Proc LPAR01 Cuba Springer Berlin 2001 46 D Gabbay Theoretical foundations nonmonotonic reasoning expert systems KR Apt Ed Proc NATO Advanced Study Institute Logics Models Concurrent Systems La CollesurLoup France Springer Berlin 1985 pp 439457 47 L Giordano A Martelli Generalized stable models truth maintenance conﬂict resolution D Warren P Szeredi Eds Logic Programming Proc Seventh International Conference MIT Press Cambridge MA 1990 pp 427441 48 M Gelfond On stratiﬁed autoepistemic theories Proc AAAI87 Seattle WA 1987 pp 207211 49 M Gelfond V Lifschitz The stable model semantics logic programming R Kowalski K Bowen Eds Logic Programming Proc Fifth Internat Conference Symposium 1988 pp 10701080 50 M Gelfond V Lifschitz Classical negation logic programs disjunctive databases New Generation Comput 1991 365387 51 M Gelfond V Lifschitz Representing actions change logic programs J Logic Programming 17 301323 52 M Gelfond T Son Reasoning prioritized defaults J Dix LM Pereira T Przymusinski Eds Lecture Notes Artiﬁcial Intelligence Vol 1471 Springer Berlin 1998 pp 164224 53 G Gottlob Complexity expressive power disjunctive logic programming Proc International Logic Programming Symposium ILPS94 Ithaca NY MIT Press Cambridge MA 1994 pp 2342 54 G Gottlob F Scarcello M Sideri Fixedparameter complexity AI nonmonotonic reasoning Artiﬁcial Intelligence 130 2002 5586 issue 55 C Green Theorem proving resolution basis questionAnswering systems B Meltzer D Michie Eds Machine Intelligence Vol 4 Edinburgh University Press Edinburgh 1969 pp 183205 56 P Hayes Computation deduction Proc Second Symposium Mathematical Foundations Computer Science Czechoslovakian Academy Sciences Czechoslovakia 1973 pp 105118 57 AC Kakas R Kowalski F Toni The role abduction logic programming DM Gabbay CJ Hogger JA Robinson Eds Handbook Logic Artiﬁcial Intelligence Logic Programming Vol 5 Oxford University Press Oxford 1998 pp 235324 58 M Kaminski A note stable model semantics logic programs Artiﬁcial Intelligence 96 2 1997 467479 59 M Kaminski A comparative study open default theories Artiﬁcial Intelligence 77 2 1995 285319 60 C Koch N Leone Stable model checking easy Proc IJCAI99 Stockholm Sweden Morgan Kaufmann San Mateo CA 1999 pp 7075 61 R Kowalski Predicate logic programming language JL Rosenfeld Ed Information Processing 74 Proceedings IFIP Congress 74 Stockholm Sweden NorthHolland Amsterdam 1974 pp 569574 36 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 62 R Kowalski Logic Problem Solving NorthHolland Amsterdam 1979 63 K Kunen Negation logic programming J Logic Programming 4 4 1987 289308 64 K Kunen Signed data dependencies logic programs J Logic Programming 7 3 1989 231245 65 D Lehmann What conditional knowledge base entail Proc KR89 Toronto ON 1989 pp 212221 66 N Leone P Rullo F Scarcello Disjunctive stable models Unfounded sets ﬁxpoint semantics computation Inform Comput 135 2 1997 69112 67 V Lifschitz Closedworld databases circumscription Artiﬁcial Intelligence 27 1985 229235 68 V Lifschitz On declarative semantics logic programs negation J Minker Ed Foundations Deductive Databases Logic Programming Morgan Kaufmann San Mateo CA 1988 pp 177192 69 V Lifschitz On open defaults J Lloyd Ed Computational Logic Symposium Proceedings Springer Berlin 1990 pp 8095 70 V Lifschitz G Schwarz Extended logic programs autoepistemic theories Proc Second Internat Workshop Logic Programming NonMonotonic Reasoning Lisbon 1993 pp 101114 71 V Lifschitz Foundations logic programming G Brewka Ed Principles Knowledge Represen tation CSLI Publications 1996 pp 69128 72 V Lifschitz Answer set programming plan generation Artiﬁcial Intelligence 138 2002 3954 issue 73 V Lifschitz Circumscription DM Gabbay CJ Hogger JA Robinson Eds The Handbook Logic AI Logic Programming Vol 3 Oxford University Press Oxford 1994 pp 298352 74 J Lobo J Minker A Rajasekar Foundations Disjunctive Logic Programming MIT Press Cambridge MA 1992 75 D Makinson General patterns nonmonotonic reasoning DM Gabbay CJ Hogger JA Robinson Eds The Handbook Logic AI Logic Programming Vol 3 Oxford University Press Oxford 1993 pp 35110 76 V Marek I Pivkina M Truszczynski Annotated revision programs Artiﬁcial Intelligence 138 2002 149180 issue 77 W Marek VS Subrahmanian The relationship logic program semantics nonmonotonic reasoning G Levi M Martelli Eds Proc Sixth Internat Conference Logic Programming Lisbon Portugal 1989 pp 600617 78 W Marek M Truszczynski Stable semantics logic programs default reasoning E Lusk R Overbeek Eds Proc North American Conference Logic Programming Cleveland OH 1989 pp 243257 79 W Marek M Truszczynski Autoepistemic logic J ACM 3 38 1991 588619 80 W Marek M Truszczynski Reﬂexive autoepistemic logic logic programming Proc Second In ternat Workshop Logic Programming NonMonotonic Reasoning Lisbon MIT Press Cambridge MA 1993 pp 115131 81 W Marek M Truszczynski Stable models alternative logic programming paradigm The Logic Programming Paradigm A 25Year Perspective Springer Berlin 1999 pp 375398 82 W Marek M Truszczynski Nonmonotonic Logic Springer Berlin 1993 83 J McCarthy Programs common sense Proc Teddington Conference Mechanization Thought Processes Her Majestys Stationery Ofﬁce London 1959 pp 7591 84 J McCarthy P Hayes Some philosophical problems standpoint artiﬁcial intelligence B Meltzer D Michie Eds Machine Intelligence Vol 4 Edinburgh University Press Edinburgh 1969 pp 463502 85 J McCarthy CircumscriptionA form nonmonotonic reasoning Artiﬁcial Intelligence 13 12 1980 2739 86 J McCarthy Applications circumscription formalizing common sense knowledge Artiﬁcial Intelligence 26 3 1986 89116 87 N McCain H Turner Satisﬁability planning causal theories Proc Sixth International Conference Principles Knowledge Representation Reasoning KR98 Trento Italy Morgan Kaufmann San Mateo CA 1998 pp 212223 88 D McDermott Nonmonotonic logic II Nonmonotonic modal theories J ACM 29 1 1982 3357 89 D McDermott J Doyle Nonmonotonic logic I Artiﬁcial Intelligence 13 12 1980 4172 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 37 90 J Minker On indeﬁnite data bases closed world assumption Proc CADE82 New York 1982 pp 292308 91 J Minker Overview disjunctive logic programming Ann Math Artiﬁcial Intelligence 12 1994 124 H Levesque F Pirri Eds Logical 92 J Minker Logic Databases A 20 year retrospective Foundations Cognitive Agents Contributions Honor Ray Reiter Springer Berlin 1999 pp 234 299 93 J Minker Ed LogicBased Artiﬁcial Intelligence Kluwer Academic Dordrecht 2000 94 M Minsky A framework representing knowledge P Winston Ed The Psychology Computer Vision McGrawHill New York pp 211277 95 R Moore Semantical considerations nonmonotonic logic Artiﬁcial Intelligence 25 1 1985 7594 96 D Nelson Constructible falsity J Symbolic Logic 14 1949 1626 97 A Nerode R Shore Logic Applications Springer Berlin 1997 98 I Niemelä Logic programs stable model semantics constraint programming paradigm Ann Math Artiﬁcial Intelligence 25 34 1999 241273 99 I Niemelä P Simons SmodelsAn implementation stable model wellfounded semantics normal logic programs Proc 4th International Conference Logic Programming NonMonotonic Reasoning Dagstuhl Germany 1997 pp 421430 100 T Soininen I Niemelä Developing declarative rule language applications program conﬁguration Practical Aspects Declarative Languages Lecture Notes Conputer Science Vol 1551 Springer Berlin 1999 pp 305319 101 U Nilsson J Maluszynski Logic Programming Prolog wwwidaliuseulfnilpp 102 M Nogueira M Balduccini M Gelfond R Watson M Barry AProlog decision support Space Shuttle Proc Third International Symposium Practical Aspects Declarative Languages Lecture Notes Computer Science Vol 1990 Springer Berlin 2001 pp 169183 103 CH Papadimitriou Computational Complexity AddisonWesley Reading MA 1994 104 D Pearce G Wagner Reasoning negative information 1Strong negation logic programming Technical Report Gruppe fur Logic Wissentheorie Information Freie Universität Berlin 1989 105 D Pearce A new logical characterization stable models answer sets J Dix L Pereira T Przymusinski Eds Nonmonotonic Extensions Logic Programming Lecture Notes Artiﬁcial Intelligence Vol 1216 Springer Berlin 1997 pp 5770 106 D Pearce From Stable negation logic programming D Gabbay H Wansing Eds What Negation Kluwer Dordrecht 1999 107 T Przymusinski On declarative semantics deductive databases logic programs J Minker Ed Foundations Deductive Databases Logic Programming Morgan Kaufmann San Mateo CA 1988 pp 193216 108 T Przymusinski Every logic program natural stratiﬁcation iterated ﬁxed point model Proc 8th Symposium Principles Database Systems Philadelphia PA 1989 pp 1121 109 H Przymusinska T Przymusinski Weakly perfect model semantics logic programs RA Kowalski KA Bowen Eds Proc 5th International Conference Symposium Logic Programming Seattle WA 1988 pp 11061120 110 R Reiter On closed world data bases H Gallaire J Minker Eds Logic Data Bases Plenum Press New York 1978 pp 119140 111 R Reiter A logic default reasoning Artiﬁcial Intelligence 13 12 1980 81132 112 R Reiter Circumscription implies predicate completion Proc AAAI82 Pittsburgh PA 1982 pp 418420 113 K Ross A procedural semantics wellfounded negation logic programs J Logic Programming 13 1992 122 114 T Sato Completed logic programs consistency J Logic Programming 9 1990 3344 115 C Sakama K Inoue Prioritized logic programming application commonsense reasoning Artiﬁcial Intelligence 123 12 2000 185222 116 M Shanahan Solving Frame Problem A Mathematical Investigation Commonsense Law Inertia MIT Press Cambridge MA 1997 117 G Schwarz Autoepistemic logic knowledge A Nerode V Marek VS Subrahmanian Eds Logic Programming Nonmonotonic Reasoning Proc First Internat Workshop 1991 pp 260274 38 M Gelfond N Leone Artiﬁcial Intelligence 138 2002 338 118 P Simons I Niemelä T Soininen Extending implementing stable model semantics Artiﬁcial Intelligence 138 2002 181234 issue 119 L Stockmeyer Classifying computational complexity problems J Symbolic Logic 52 1 1987 143 120 K Stroetman A completeness result SLDNFresolution J Logic Programming 15 1993 337355 121 H Tamaki T Sato Unfoldfold transformation logic programs S Tarnlund Ed Proc 2nd International Logic Programming Conference Uppsala Sweden 1984 pp 127138 122 H Turner Representing actions logic programs default theories J Logic Programming 31 13 1997 245298 123 H Turner Orderconsistent programs cautiously monotonic Theory Practice Logic Program ming 1 4 2001 487495 124 M van Emden R Kowalski The semantics predicate logic programming language J ACM 23 4 1976 733742 125 A Van Gelder K Ross J Schlipf The wellfounded semantics general logic programs J ACM 38 3 1991 620650 126 G Wagner Logic programming strong negation inexact predicates J Logic Comput 1 6 1991 835861 127 JH You L Yuan A threevalued semantics deductive databases logic programs J Comput System Sci 49 1994 334361