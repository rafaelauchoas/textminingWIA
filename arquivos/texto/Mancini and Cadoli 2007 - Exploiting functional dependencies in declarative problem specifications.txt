Artiﬁcial Intelligence 171 2007 9851010 wwwelseviercomlocateartint Exploiting functional dependencies declarative problem speciﬁcations Toni Mancini Marco Cadoli Dipartimento di Informatica e Sistemistica Università di Roma La Sapienza Via Salaria 113 I00198 Roma Italy Received 4 June 2006 received revised form 15 March 2007 accepted 30 April 2007 Available online 22 May 2007 Abstract In paper tackle issue automatic recognition functional dependencies guessed predicates constraint problem speciﬁcations Functional dependencies arise frequently pure declarative speciﬁcations intermediate results need computed order express constraints precise modeling choices provide multiple viewpoints search space order increase constraint propagation In way recognition dependen cies greatly helps solvers allowing avoid spending search unfruitful branches maintaining highest degree declarativeness By modeling constraint problem speciﬁcations secondorder formulae provide characterization func tional dependencies terms semantic properties ﬁrstorder ones prove undecidability problem recognition Despite negative result advocate cases effective possibility automated tools mechanize task Additionally suitable search procedures automatically synthesized order exploit recognized dependen cies We present OPL examples problems taken bioinformatics planning resource allocation cases OPL greatly beneﬁts addition search procedures Moreover evidence writing sophisticated adhoc search procedures handle dependencies exploiting peculiarities particular problem difﬁcult errorprone task cases payoff 2007 Elsevier BV All rights reserved Keywords Modeling Reformulation Secondorder logic Constraint satisfaction problems 1 Introduction Declarative programming speciﬁcally constraint programming attractive solve different classes problems main advantages approach fast prototyping high declarativeness exhibited problem models called speciﬁcations Current systems constraint solving AMPL 19 OPL 43 DLV 31 SMODELS 36 NPSPEC 8 allow programmer model problem This paper extended revised version M Cadoli T Mancini Exploiting functional dependencies declarative problem speciﬁcations Proceedings Ninth European Conference Logics Artiﬁcial Intelligence JELIA 2004 Lecture Notes Artiﬁcial Intelligence vol 3229 Lisbon Portugal Springer 2004 pp 628640 Corresponding author Email addresses tmancinidisuniroma1it T Mancini cadolidisuniroma1it M Cadoli 00043702 matter 2007 Elsevier BV All rights reserved doi101016jartint200704017 986 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 7 8 7 7 9 7 0 6 13 18 12 4 0 49 56 49 63 72 63 49 56 49 6 2 7 2 3 9 c7 c6 z6 c4 c3 c5 x2 y2 x3 y3 x1 y1 c2 c1 x3y1 x2y1 x1y1 x3y2 x2y2 x1y2 x3y3 x2y3 x1y3 z1 z3 z4 z5 z2 Fig 1 Factoring instance 627239 n 6 b 10 highly declarative way supporting neat separation speciﬁcation instances Such possibility allows programmer focus structural combinatorial aspects problem hand committing actual input data permits problem modeling higher level provided CSP framework However wellknown problem model obtained way efﬁcient reasoning required order reformulate speedup solving process To end different approaches proposed literature like symmetry detection breaking cf 512 addition implied constraints cf 41 deletion abstraction constraints 3162023 use redundant models multiple viewpoints search space synchronized channeling constraints order increase constraint propagation 11182544 However approaches designed speciﬁc constraint problem act instance level little work level problem speciﬁcation Indeed properties constraint problems amenable optimizations strongly depend problem structure Hence recognition naturally ﬁts symbolic level speciﬁcation methodological efﬁciency point view Our research explicitly focuses speciﬁcationlevel reasoning goal reformulating declarative problem model submitted programmer equivalent efﬁciently evaluable solvers In partic ular 6 constraints speciﬁcation ignored ﬁrst step efﬁciently reinforced performing additional search socalled safe delay constraints provide sufﬁcient semantic criterion speciﬁcation order recognize constraints Moreover 34 tackle issue detecting structural problemdependent symmetries breaking adding symmetry breaking constraints problem speciﬁcation In paper focus interesting property constraint problems expected beneﬁt reformulation functional dependencies hold variables declarative problem speciﬁcations Informally given speciﬁcation variable said functional dependent solution instance value determined assigned Functional dependencies common problem speciﬁcations different reasons example allow modeler multiple views search space order able express constraints convenient viewpoint maintain aggregate intermediate results needed constraints The following examples use dependent variables aforementioned circumstances Example 1 Factoring 3040 This problem simpliﬁed version wellknown problem publickey cryptog raphy Given large positive integer Z known product different prime numbers different 1 aims ﬁnding factors X Y An intuitive formulation factoring constraint problem order deal arbitrarily large numbers amounts encode combinatorial circuit integer multiplication In particular assuming input integer Z having n digits base b z1 zn consider 2n variables x1 xn y1 yn digit base b factors X Y z1 x1 y1 signiﬁcant digits Z X Y respectively The domain variables 0 b 1 In order maintain information carries n 1 additional variables c1 cn1 considered domain 0 b 12nb As constraints cf Fig 1 intuition x4 x5 x6 y4 y5 y6 equal 0 omitted readability following1 1 Since integer Z assumed product prime numbers constraints ensuring X Y prime needed T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 987 Fig 2 HP 2DProtein folding problem A possible conformation protein PHHPHPPHP contacts overall energy 2 1 Constraints factors Factors different 1 equivalently X cid3 Z Y cid3 Z b For digit 1 n zi ci jk1n j ki1 xj yk mod b cid2 2 Constraints carries Carry signiﬁcant digit 0 c1 0 b Carries digits 2 n 1 ci ci1 c Carry signiﬁcant digit 0 cn1 0 cid2 jk1n j ki xj ykb integer division It worth noting guess factors X Y variables x1 xn y1 yn values variables c1 cn1 completely determined follow semantics multiplication We denote situation saying variables c1 cn1 functional dependent x1 xn y1 yn Example 2 HP 2DProtein folding 29 This speciﬁcation models simpliﬁed version wellknown problem computational biology It consists ﬁnding spatial conformation protein sequence aminoacids minimal energy The simpliﬁcations respect real problem twofold ﬁrstly 20letter alphabet aminoacids reduced twoletter alphabet H P H represents hydrophobic aminoacids P represents polar hydrophilic aminoacids Secondly conformation protein limited bidimensional discrete space Nonetheless limitations proven useful attacking protein conformation prediction problem The simpliﬁed version known NPcomplete 13 hard solve practice Given sequence aminoacids protein string H P length n problem aims ﬁnd connected shape 2D grid coordinates n 1 n 1 starting predetermined position 0 0 noncrossing number contacts number nonsequential pairs Hs Euclidean distance positions 1 maximized overall energy opposite number contacts Fig 2 shows possible conformation protein PHHPHPPHP overall energy 2 Various alternatives search space exist example guess position grid amino acid force shape connected noncrossing minimal energy However preferred approach reduces size search space 4n points versus 2n2n guess shape protein connected path starting 0 0 guessing index 1 n 1 direction 1th aminoacid assumes respect ith directions North South East West2 The sequence directions shape Fig 2 N N N E E S W S However choosing model completely satisfactory In fact express noncrossing constraint compute number contacts objective function absolute coordinates aminoacid sequence computed maintained It easy values completely deﬁned functionally dependent sequence directions taken protein 2 Actually possible directions aminoacid respect previous noncrossing constraint We opt simpler model enhance readability 988 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 Appendix B shows speciﬁcations problems stateoftheart declarative constraint modeling language OPL However discussed forthcoming sections Given problem like Factoring HP 2DProtein folding writing procedural program C solve possibly available libraries constraint programming smart programmer avoid variables encoding partial multiplications absolute coordinates aminoacids search space Values variables instead computed starting On hand declarative formalism CSPs declarative constraint modeling languages like OPL programmer loses power distinguish variables values true search computed starting nature Hence search space actually explored ineffectively larger additional information required programmer distinguish greatly reducing declarativeness speciﬁcation To end ability automatically recognize variable functionally dependent deﬁned great importance efﬁciency point view lead signiﬁcant reductions search space The technique avoiding branches dependent variables successfully applied solving SAT instances As example shown 22 modify DavisPutnam procedure SAT avoids branches variables added clausiﬁcation nonCNF formulae values assigned variables depend assignments ones Moreover SAT solvers EQSATZ 32 developed order appropriately handle means socalled equivalence reasoning equivalence clauses recognized common structure SAT encoding hard realworld problems major obstacle DavisPutnam procedure We believe looking dependencies speciﬁcation level instantiation natural issues strongly depend structure problem To end approach formal characterization functional dependencies problem speciﬁcations suitable checked tools ultimately transform original speciﬁcation automatically suggesting explicit search strategy exploits dependencies avoiding reducing branches dependent predicates We experimentally strategies general simple cases greatly enhance performance stateofthe art constraint programming solvers like Ilog SOLVER3 able compete procedures written adhoc given problem deeply exploit structural peculiarities This good evidence automated reasoning problem speciﬁcations effective order improve performance maintaining highest level declarativeness constraint model The outline paper follows Section 2 introduce justify use existential secondorder logic abstract modeling language problem speciﬁcations Section 3 formally deﬁne functional dependencies speciﬁcations characterize terms semantic properties ﬁrstorder formulae problem checking dependence holds undecidable However despite negative result argue current Automated Theorem Proving technology successfully order mechanize task recognizing dependencies Then Section 4 examples bioinformatics planning resource allocation exhibit dependencies present Appendix B formulations wellknown constraint modeling language OPL In Section 5 approach exploiting detected dependencies consists automatic synthesis suitable search procedure delays branches dependent predicates experimen tally cases evaluation OPL beneﬁts addition Moreover elaboration adhoc complex search procedures strongly rely structure particular problem ing difﬁcult errorprone task general cases improve performance Finally Section 7 devoted concluding discussions description future work 2 Preliminaries When dealing problem speciﬁcations ﬁrst choice modeling language Current systems languages declarative constraint modeling listed Section 1 syntax 3 Ilog SOLVER highly optimized backtrackingbased Constraint Programming engine OPL T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 989 describing constraint problems AMPL OPL XPRESSMP ESRA GAMS allow representation constraints algebraic expressions DLV SMODELS NPSPEC rulebased languages specif ically extensions datalog However languages richer syntax complex constructs abstract point view regarded extensions existential secondorder logic ESO ﬁnite databases existential secondorder quantiﬁers ﬁrstorder formula represent respectively guess check phases constraint modeling paradigm In particular possible embed ESO queries opposite encoding possible long ﬁnite domains considered Hence section ESO considered formal logical basis virtually available languages constraint modeling able represent search problems complexity class NP 1738 Intuitively relation ship ESO available modeling languages similar holding assembler highlevel programming languages Moreover Section 3 problem detecting functional dependencies ESO speciﬁca tions reduces checking semantic properties ﬁrstorder formulae possible use known results techniques order mechanize tasks In particular advocated related work 7 brieﬂy discussed end forthcoming Section 3 gives promising new area application Automated Theorem Proving technology undoubtedly important results achieved Artiﬁcial Intelligence Existential secondorder logic modeling language Formally ESO speciﬁcation describing search problem π formula cid7S φ cid7S cid7R ψ 1 1 The set predicates cid7R RarR1 input relational schema ﬁxed set relations given arities denoting schema input instances π An instance cid7I problem given happens current systems relational database schema cid7R extension relations cid7R All constants occurring database uninterpreted dont speciﬁc meaning RarRk k Existentially quantiﬁed predicates set cid7S SarS1 called guessed possible exten sions tuples domain given constants occurring cid7I plus occurring φ called Herbrand universe encode points search space problem π instance cid7I φ closed ﬁrstorder formula relational vocabulary cid7S cid7R interpreted identity encodes constraints extension predicates cid7S satisfy solution π instance cid7I SarSn n 1 An instance cid7I π encoded relational database having schema cid7R satisﬁable exists list relations Σ1 Σn matching list guessed predicates cid7S S1 Sn cid7I satisﬁes ﬁrstorder formula 1 Σ1 Σn cid7I φ In words semantics ESO formula kind 1 ﬁnd extension guessed predicates satisﬁes constraints φ given input instance cid7I Since Fagins theorem 1738 decision problem NP exists ESO formula expresses fragment secondorder logic deﬁnitively considered abstract modeling language constraint problems An example clarify ESO formalism Example 3 Notallequal Sat 21 Prob LO3 In NPcomplete problem input propositional formula CNF question possible assign truth value variables way input formula satisﬁed clause contains literal truth value false We assume input formula encoded following relations inclause tuple cid9l ccid10 inclause iff literal l clause c l tuple cid9l vcid10 l iff l positive literal relative propositional variable v v 990 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 l tuple cid9l vcid10 l iff l negative literal relative propositional variable v v var containing set propositional variables occurring formula clause containing set clauses formula As example CNF formula x y z x y z satisﬁable instance problem interpretation x true y false z true model formula leaves false literal clause Such instance encoded following set relations cid7I l lit xt yt zt var x y z l lit xf zf var x z var x y z clause c1 c2 inclause lit xt yt zf xf yt zt clause c1 c1 c1 c2 c2 c2 enhance readability constants denoting positive negative literals associated variable v called vt vf respectively An ESO speciﬁcation problem follows cid3 MX T cid3 varX T true T false cid4cid4 M 2 X T cid4 cid3 varX T MX T T T cid4 cid14 cid4 cid14 cid14 cid3cid3 X X T T C clauseC cid3 l C clauseC V MX T MX T cid5 L inclauseL C cid4 L V MV true cid5 L inclauseL C cid4 L V MV false cid3 l cid3 l cid3 l L V MV false cid4cid6 cid4cid6 2 3 4 5 V L V MV true 6 The set guessed predicates cid7S single binary predicate M extensions expected encode possible assignments truth values variables To satisfy requirement appropriate constraints 24 needed In particular constraint 2 forces extensions M sets variabletruthvalue pairs 34 constrain M assign exactly truth value variable The need constraints 24 directly follows semantics ESO declaring M binary guessed predicate implies extensions values Herbrand domain set constants occurring formula example true false plus occurring problem instance given From description given set includes symbols variables additional symbols literals clauses forbidden legal extensions M Finally constraints 5 forces assignment M model formula 6 leaves clause literal truth value false The following extension guessed predicate M solution instance cid7I described M value true false true var x y z It straightforward extension M satisﬁes constraints T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 991 In order facilitate writing speciﬁcations additional builtin constructs provided current languages particular aimed represent typed relations functions arrays bounded integers arithmetics Such enrichments actually added basic ESO framework This eases expressions makes ESO speciﬁcations compact close counterparts stateoftheart languages In particular syntactic sugar deﬁned order let ESO able handle typed guessed predicates functions bounded integers arithmetics Support typed guessed predicates functions added straightforward way realized additional ﬁrstorder constraints A good example given speciﬁcation shown Example 3 constraints 24 force extensions guessed predicate M total functions set variables set true false As numbers instead simply handled assuming special relations cid7R exist represent preinterpreted bounded integers operations As example assume distinguishedﬁniterelation number cid7R exists predicates operations needed correctly express problem speciﬁcation binary relation ltx y cid7R contains tuples cid9x ycid10with x y numbers x y 3ary relation sum cid7R containing tuples cid9x y zcid10 x y z Alternatively order avoid preinterpretation constants relations handle numbers arithmetics guess additional relations permit regard constants Herbrand domain H tuples Hk suitable large k integers ﬁnding total order This technique requires guess additional predicates cf 33 We dont details extensions observe change expressive power ESO In constraint problems domains variables usually ﬁnite Furthermore domains small independent particular instance As example set possible directions aminoacid assume respect previous Protein folding problem described Example 2 N S E W independent instance The happens truth values assigned variables Notall equal SAT problem Example 3 true false In cases exist alternative equivalent ESO speciﬁcations In general given nary guessed predicate P arguments domain size m independent instance replace m n 1ary guessed predicates P1 Pm value The remainder speciﬁcation rewritten accordingly Such process called unfolding P according given argument As example following unfolded ESO speciﬁcation Notallequal SAT problem Example 4 Notallequal SAT unfolded Example 3 continued This speciﬁcation obtained Example 3 unfolding guessed predicate M according second argument having domain true false obtaining 2 monadic guessed predicates T F instead Mtrue Mfalse enhance read ability Extensions predicates forced contain set variables assigned true false respectively T F X varX T X F X cid4 cid3 T X F X X C clauseC cid5 L inclauseL C cid3 l cid3 l C clauseC cid4 L V T V cid5 L inclauseL C cid3 l cid4 L V F V V V cid3 l L V F V L V T V cid4cid6 cid4cid6 7 8 9 10 The following extensions guessed predicates T F encode solution instance cid7I described Example 3 992 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 F y T x z ESO vs CSP As shown ESO formula model structure decision problem speciﬁcation independently input data instance As discussed Section 1 current systems constraint programming support declarative modeling clearly separate problem speciﬁcation instances offering speciﬁcation languages essentially ESO cf Appendix B short description OPL language However input data given ﬁxing extension predicate symbols set cid7R classical Constraint Satisfaction Problem CSP sense 14 obtained triple cid9 cid7X cid7D cid7Ccid10 cid7X linearly ordered set variables cid7D linearly ordered set domain values variable cid7C set constraints deﬁned linearly ordered subset variables constraint scope encoded subset Cartesian product respective domains constraint relation This process usually called grounding Of course general ways ground speciﬁcation different ways choose variables values following example shows Example 5 Notallequal SAT CSP Let consider speciﬁcation Notallequal SAT problem shown Example 3 instance cid7I A straightforward grounding speciﬁcation instance cid7I follows cid7X x y z CSP variable variable CNF cid7D Dx Dy Dz Dx Dy Dz true false As set constraints cid7C following ones For clause ci 1 2 constraint C5 deﬁned variables occur ci Such straints encode denoted 5 speciﬁcation Hence C5 deﬁned x y z 1 relation contain 3tuples components true false encode assignments variables satisfy clause c1 C5 2 x y z 1 true false3 cid9true false falsecid10 true false3 cid9false false truecid10 Analogously C5 Similarly clause ci 1 2 constraint C6 deﬁned variables occur ci Such constraints encode denoted 6 speciﬁcation In particular C6 2 contain 1 3tuples components true false encode assignments variables literal clauses c1 c2 respectively false C6 1 x y z true false3 cid9true true falsecid10 C6 2 x y z true false3 cid9false true truecid10 C6 Of course optimizations possible encoding example constraints C5 1 2 C6 merged Finally observe presented CSP encoding correct constraints 34 ESO speciﬁca tion force M total function total monovalued relation set variables CNF true false If case deﬁne CSP boolean variable CNFvariabletruthvalue pair account possibilities 3 Deﬁnitions formal results In Section 2 presented ESO explained regarded abstract modeling language problem speciﬁcations relates CSP framework In section formally discuss mean func tional dependencies ESO speciﬁcation provide logical characterization problem checking dependence holds reduces verifying semantic properties ﬁrstorder formulae T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 993 In Section 1 gave instances functional dependencies constraint problem speciﬁcations As example Factoring problem cf Example 1 guess factors X Y variables carries determined semantics integer multiplication Similarly Protein folding cf Example 2 absolute positions aminoacids determined guess protein shape To start simpler example let consider Notallequal SAT problem unfolded version Example 4 Example 6 Notallequal Sat Example 4 continued Guessed predicate F dependent T guess extension exists single extension leading solution This implied constraints 78 logically follows X F X varX T X 11 CNF variables assigned false exactly assigned true The reverse dependence obviously hold guessed predicate dependent mutually dependent Example 6 shows functional dependencies distinct guessed predicates However consider ﬁrst speciﬁcation problem given Example 3 dependencies hold tuples guessed predicate M However unfolding speciﬁcations guessed predicates exhibit dependencies tuples reduce case For reason follows restrict dependencies distinct guessed predicates4 To simplify notation given list predicates cid7T write cid7T cid14 represent list predicates size respectively arities fresh occur context hand Also cid7T cid7T cid14 shorthand formula cid7 cid7X T cid7X T cid14 cid7X T cid7T T T cid14 corresponding predicates cid7T cid7T cid14 respectively cid7X list variables appropriate arity The following deﬁnition formally characterizes functional dependencies guessed predicates ESO speciﬁcation Deﬁnition 1 Functional dependence set predicates speciﬁcation Given problem speciﬁcation input schema cid7R cid7S cid7P φ cid7S cid7P cid7R ψ set guessed predicates partitioned cid7S cid7P predicates cid7P functionally depend cid7S instance cid7I cid7R pair interpretations cid9 cid7Σ cid7Πcid10 cid9 cid7Σ cid14 cid7Π cid14cid10 cid7S cid7P holds 1 cid9 cid7Σ cid7Π cid10 cid3 cid9 cid7Σ cid14 cid7Π cid14cid10 2 cid7Σ cid7Π cid7I φ 3 cid7Σ cid14 cid7Π cid14 cid7I φ cid7Σ cid3 cid7Σ cid14 The deﬁnition states cid7P functionally depends cid7S cid7S functionally determines cid7P case regardless instance pair distinct solutions ψ differ predicates cid7S equivalent different solutions ψ exist coincide extension predicates cid7S 4 We observe unfolding formal step let speciﬁcation suit formal framework going deﬁne need performed practice Hence handle cases number guessed predicates obtained unfolding instance dependent 994 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 It worth noting Deﬁnition 1 strictly related concept Beth implicit deﬁnability wellknown logic follows given ﬁrstorder logical formula φ cid7P set predicates cid7P φ said implicitly deﬁne predicate P cid7P cid7P P structure expansion cid7Pstructure satisfying φ cf 10 We discuss relationship Section 5 In follows problem checking subset guessed predicates speciﬁcation functionally dependent remaining ones reduces checking semantic properties ﬁrstorder formula proofs Appendix A cid7S cid7P φ cid7S cid7P cid7R problem speciﬁcation input schema cid7R Guessed predicates set cid7P Theorem 1 Let ψ functionally depend cid7S following ﬁrstorder formula tautology cid6 cid5 φ cid7S cid7P cid7R φ cid7Scid14 cid7P cid14 cid7R cid7S cid7P cid3 cid7Scid14 cid7P cid14 cid7S cid3 cid7Scid14 12 Unfortunately problem checking set predicates cid7P functionally dependent set cid7S undecidable following result shows Theorem 2 Given ESO speciﬁcation input schema cid7R partition cid7S cid7P guessed predicates problem checking cid7P functionally depends cid7S decidable This undecidability result shows possible mechanize task establishing given dependence holds This major problem way providing automated techniques perform symbolic problem reformulation order optimize declarative speciﬁcations given user ones efﬁciently solvable However despite negative theoretical result related work 7 shows practical circumstances task detecting functional dependencies effectively efﬁciently performed automated tools We dont details Fig 3 example Theorem 1 exploited order let ﬁrstorder theorem prover OTTER 35 check predicate F functional dependent T Notallequal SAT speciﬁcation Example 4 The OTTER encoding formula 12 strictly follows structure easily derived automatically speciﬁcation given implemented modeling language OPL despite syntactic sugar actually similar ESO cf Appendix B In particular parts 1 2 encoding given Fig 3 deﬁne φ cid7S cid7P cid7R φ cid7Scid14 cid7P cid14 cid7R coherently constraints ESO speciﬁcation auxiliary propositional variables single constraints explained 7 parts 3 4 encode cid7S cid7P cid7Scid14 cid7P cid14 cid7S cid7Scid14 respectively Finally 5 checks negation formula 12 contradiction OTTER able prove encoded formula negation 12 contradiction existence functional dependence hundreds seconds We address reader 7 exhaustive discussion experimental evaluation problems highlights tools effective practice perform task checking structural properties constraint speciﬁcations functional dependencies 4 Further examples In section present problem speciﬁcations exhibit functional dependencies guessed predicates Since elaborated constraints dont formulations ESO formulae Appendix B speciﬁcations known language constraint modeling OPL Example 7 Factoring Example 1 continued An OPL speciﬁcation problem presented Appendix B1 The input schema set guessed predicates deﬁning search space follows Input schema array integers Z denoting input integer indices denoting signiﬁcant digits integer variables base digitsZ denoting base number digits respectively Guessed predicates arrays X Y digits base base denoting factors array carries carry Further guessed variables needed technical reasons cf speciﬁcation Appendix B1 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 995 setauto formula_listusable 1 Encoding phiTF x varx Tx Fx cov disj x Fx Tx sat c exists l v clausec inclauselc litPlv Tv litNlv Fv nae c exists l v clausec inclauselc phi cov disj sat nae litPlv Fv litNlv Tv 2 Encoding phi_primeT_primeF_prime x varx T_primex F_primex cov_prime disj_prime x F_primex T_primex sat_prime c exists l v clausec inclauselc litPlv T_primev litNlv F_primev nae_prime c exists l v clausec inclauselc litPlv F_primev litNlv T_primev phi_prime cov_prime disj_prime sat_prime nae_prime 3 Encoding TF T_prime F_prime equivTF x Tx T_primex Fx F_primex 4 Encoding T T_prime equivT x Tx T_primex 5 It true F dependent T phi phi_prime equivTF equivT end_of_list Fig 3 OTTER input ﬁle checks predicate F dependent T Notallequal problem speciﬁcation Example 4 As constraints OPL encodings described Example 1 As observed array carry functionally dependent X Y Example 8 The HP 2DProtein folding problem Example 2 continued As stated Example 2 guessing position grid aminoacid sequence chose represent shape protein giving position t direction aminoacid tth position sequence assumes respect previous sequence starts 0 0 However order express noncrossing constraint compute value objective function absolute coordinates aminoacid sequence calculated maintained An OPL speciﬁcation problem shown Appendix B2 The input schema set guessed predicates given follows Input schema Array seq aminoacids set HP integer variable n encoding string length Guessed predicates Array Moves n1 components set N S E W encoding moves string head plus integer arrays X Y length n representing absolute positions aminoacid As constraints force protein shape start 00 noncrossing constraints expressed terms X Y variables linked Moves appropriate channeling straints As observed guessed predicates X Y functionally dependent Moves Finally objective function maximizes number nonsequential pairs H aminoacids Euclidean distance positions 1 A note noncrossing constraint order The natural formulation constraint uses On2 binary inequalities forbidding existence different elements t t cid14 Xt Xt Yt Yt However considered second formulation HP 2DProtein folding noncrossing constraint modeled differently In particular new guessed predicate Hits order maintain position grid number aminoacids protein placed point 996 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 construction shape For position number greater 1 implies string cross In speciﬁcation OPL code presented Appendix B2 guessed predicate Hits dependent Moves Example 9 The Sailco inventory problem 43 Section 94 This problem speciﬁcation OPLSTUDIO distribution package ﬁle sailcomod models simple inventory application question decide sailboats Sailco company produce given number time periods order satisfy demand minimize production costs The demand periods known addition inventory boats available initially In period Sailco produce maximum number boats capacity given unitary cost regularCost Additional boats produced higher cost extraCost Storing boats inventory cost period inventoryCost boat Appendix B3 shows OPL model problem In particular instance schema set guessed predicates follows Instance schema The number periods nbPeriod integer array demand stating demand period plus integers regularCost extraCost inventoryCost capacity inventory Guessed predicates Arrays regulBoats extraBoats guess period number regu lar extra boats produced plus array inv maintaining number boats stored inventory period As constraints force inventory contain inventory boats initially impose period maximum capacity regular boats produced deﬁne number boats stored inventory period Finally objective function minimizes overall production cost From speciﬁcation observed number boats stored period t 0 invt deﬁned terms number regular extra boats produced period t following relation ship invt regulBoatst extraBoatst demandt invt1 Such relationship makes guessed predicate inv functionally dependent regulBoats extraBoats Example 10 The Blocks world problem 3745 In Blocks world problem input consists set blocks arranged stacks table Every block table block Given initial desired conﬁgurations blocks problem amounts ﬁnd minimal sequence moves achieves desired conﬁguration starting initial Every performed single clear block block blocks moves clear block table accommodate arbitrary number blocks It worth noting plan length equal twice number blocks exists original stacks ﬂattened table building desired conﬁguration In formulation given Appendix B4 instance schema set guessed predicates deﬁned follows Instance schema input given integer nblocks number blocks arrays OnAtStart OnAtGoal encoding respectively initial desired conﬁgurations Guessed predicates Arrays MoveBlock MoveTo respectively state time point t block moved time point t1 new position time t Moreover arrays On states position block table given block given time point Clear states given block clear time point As constraints state time point performed selects clear block puts table clear block rest conﬁguration remaining identical socalled frame axiom Moreover impose starting ﬁnal conﬁgurations deﬁned OnAtStart OnAtGoal Finally channeling constraints deﬁne guessed predicates On Clear given The constraints evidence guessed arrays On Clear functionally dependent MoveBlock MoveTo Finally objective function minimizes number moves needed reach ﬁnal conﬁguration T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 997 5 Exploiting functional dependencies In previous sections discussed functional dependencies arise declarative constraint problem speciﬁcations negatively affect solvers performance By ESO modeling language formally characterized dependencies terms ﬁrstorder logic leading possibility making use automated tools order mechanize task recognition Despite undecidability general problem cf Theorem 2 related work 7 experimentally approach feasible practical cases suggesting brand new promising application area new challenges Automated Theorem Proving technology Now able recognize given problem speciﬁcation subset cid7P guessed predicates functionally dependent opportunity exploiting dependence arises ultimate goal improving solvers performance Different approaches adopted principle aiming excluding search space predicates cid7P In section comment present simple general technique successfully applied constraint programming systems order automate second task The natural technique handle dependent predicate P cid7P arguably substitute occurrences P occurring speciﬁcation deﬁnition formula deﬁnes terms cf formula 11 Example 6 However approach unfeasible general In fact observed Section 3 concept functional dependence guessed predicates expressed Deﬁnition 1 strictly related cid7S cid7P φ cid7S cid7P cid7R guessed Beth implicit deﬁnability cf 10 In particular given problem speciﬁcation ψ predicates set cid7P functionally depend cid7S ﬁrstorder formula φ cid7S cid7P cid7R implicitly deﬁnes predicates cid7P cid9 cid7S cid7Rcid10structure expansion cid9 cid7S cid7P cid7Rcid10structure satisfying φ cid7S cid7P cid7R It worth remarking interested ﬁnite extensions guessed predicates Beth implicit deﬁn ability intended ﬁnite Now question arises possible derive functional dependence equivalently implicit deﬁnition established formula explicitly deﬁnes depen dent predicates terms This formula place occurrences predicates problem speciﬁcation Although formula exists unrestricted ﬁrstorder logic case ﬁnite models allowed This ﬁrstorder logic Beth property ﬁnite cf 15 intrinsically inductive deﬁnition guessed function inv Example 9 On hand secondorder explicit deﬁnition dependent predicate adequate new quantiﬁed predicates added speciﬁcation obtained speciﬁcation ESO Although approach feasible general cases ﬁrstorder formulae explicitly deﬁne depen dent predicates terms exist cf Example 6 However cases replacing occurrences predicates cid7P formulae likely lead longer complex constraints worsen performance The second general approach deal dependencies exploit paper instructing search engine consider dependent predicates search space instead compute given extension predicates cid7S corresponding extension predicates cid7P To end assume language allows deﬁne explicit search strategy In particular description depend particular language remaining paper use syntax constraint language OPL OPL require search strategy provided programmer automatically uses default strategies based highly optimized versions dynamic value ordering heuristics cf 12839 explicitly deﬁned On hand provides designer possibility explicitly programming branch variables split domains means optional problem model called search procedure Appendix B shows brief description speciﬁcation OPL looks like similarities ESO speciﬁcations examples discussed Section 4 The approach adding search procedure problem model order exploit dependencies powerful costly terms human effort algorithm needed compute extension dependent predicates corresponding cid7S strongly depends peculiarities given problem needs designed implemented modeler consequence great lowering declarativeness process Nonetheless approach likely efﬁcient practice 998 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 intrinsically errorprone procedural aspects taken account easily lead unsound procedures terminate exploring problem search space Example 11 The HP 2DProtein folding problem One intuitive search procedures added speciﬁcation problem order exploit dependence guessed predicates X Y Moves labels variables Moves ascending order Moves0 ﬁrst Moves1 having guessed Movest computes Xt1 Yt1 starting Xt Yt X0 Y0 0 according following rules If Movest N Xt1 Xt Yt1 Yt1 If Movest S Xt1 Xt Yt1 Yt1 If Movest E Xt1 Xt1 Yt1 Yt If Movest W Xt1 Xt1 Yt1 Yt An OPL formulation search procedure given Appendix B2 Of course adding search procedure channeling constraints speciﬁcation deﬁne guessed variables X Y terms Moves safely removed synchronization view points search space guaranteed search procedure However practice dangerous methodological standpoint strong coupling introduced declarative procedural parts problem model This constraints conceptually problem speciﬁcation speciﬁcation incorrect programmer later chooses change search procedure add channeling constraints handle synchronization issue way On hand clear leaving constraints speciﬁcation introduce appreciable costs solving process behavior search procedure guarantees satisﬁed It immediate observe search procedure effective maximally reduces size search space actually excluding X Y guesses directions protein head ﬁrst aminoacid However procedure unlikely output mechanized task functional dependence X Y Moves detected relies deep analysis problem model provided programmer On hand goal automate synthesis suitable search procedures exploit functional dependencies effective written modeler To end simple general schemas followed rely structural peculiarities given problem The idea going easier automate It aims enforce preference order variables branch way corresponding dependent predicates delayed long possible As example HP 2DProtein folding problem algorithm ﬁrst branch variables Moves array X Y In way dependent predicates excluded search space constraint propagation typically effectively efﬁciently reduce active domains associated dependent variables guess deﬁning ones performed especially tight channeling constraints available problem model case Such technique implemented OPL language simple way highlevel gen erate construct receives guessed predicate input forces algorithm generate possible extensions leaving policy generation ordering variables branch values assigned defaults Of course multiple occurrences generate different guessed predicates arguments allowed Hence given problem speciﬁcation set cid7P P1 Pn guessed predicates functionally dependent set cid7S S1 Sm search procedure forces OPL ﬁrst branch predicates cid7S following DDP Delay branches Dependent Predicates search generateS1 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 999 generateSm generateP1 generatePn additionally leaves policies generation extensions predicates cid7S cid7P defaults actually OPL generate construct accepts single predicate input effect ﬁx preference orders S1 Sn P1 Pm orders chosen course affect performance In following refer schema DDP Delay branches Dependent Predicates Such schema simple general easy automate Interestingly shown Section 6 good performance able compete cases complex approaches like shown Example 11 Some observations structure DDP schema order wondered cases appropriate channeling constraints exist speciﬁcation constraint propagation sufﬁcient isolate guess predicates cid7S unique correct extension predicates cid7P This case Protein folding cf OPL speciﬁcation Appendix B2 In circumstances generateP1 generatePn safely removed search procedure However observed deﬁnition functional dependence cf Deﬁnition 1 follows problem isolating correct extension dependent predicates guess deﬁning ones general subproblem NP guaranteed exactly solution Since problems believed complex arbitrary NP problems cf 93842 constraint propagation polynomialtime algorithm sufﬁce On hand worth observing cases constraint propagation sufﬁcient isolate correct value dependent predicates generating extensions add considerable overhead search sets possible extensions active domains corresponding CSP variables obtained grounding reduced propagation singletons step constant time Finally speciﬁcations sets cid7S cid7P interchangeable This intuitively happens modeler adopts multiple viewpoints search space cf Example 8 set X Y depends Moves vice versa In cases ﬁrst choice deciding set regarded deﬁning cid7S involve size associated search space smarter approaches like amenability constraints propagation cf 25 6 Experiments To test effectiveness adding DDP search procedure presented Section 5 experimented OPL problems described above5 HP 2DProtein folding cf Example 8 benchmark instances taken 24 Blocks world cf Example 10 structured instances benchmarks 26 Factoring cf Example 1 instances denoted numbers 1314 digits For solved instances search procedure relying OPL default strategy general DDP search procedure suggested Section 5 instructs search engine ﬁrst branch deﬁning variables dependent ones The ﬁrst result experiments cases adding DDP search procedure signiﬁcantly speedups computation This evidence reasoning problem model promising approach boost performance 5 All speciﬁcations instances available httpwwwdisuniroma1it tmanciniindexphpcurrItemresearchpublicationswebappendices mancinicadoli06dependencies 1000 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 Table 1 OPL solving times benchmark instances HP 2DProtein folding problem model binary inequalities noncrossing constraint search procedures Length max contacts No search proc default strategy 14 14 16 16 17 17 18 Total time 2 5 6 7 6 6 4 3385 4502 12416 2413 32366 281851 57685 394618 With search procedure DDP 3340 3923 11403 2217 28822 214971 48768 313444 Saving 1 Saving 2 133 1286 816 812 1095 2373 1546 2057 3813 4574 13073 2535 32661 240181 55250 352087 1264 160 529 506 091 1478 422 1078 3555 4164 11790 2291 30033 222018 50959 324810 Saving 502 751 504 506 721 2123 1166 1769 The second important result experiments surprising cases sophisticated search procedure adhoc written programmer signiﬁcant effort great lowering declarativeness risk unsound improve performance performs worse DDP All experiments Ilog SOLVER v 53 invoked OPLSTUDIO 361 2 CPU Intel Xeon 24 GHz 25 GB RAM Linux v 241864GBSMP Results shown Tables 14 HP 2DProtein folding Factoring Blocks world brieﬂy com mented follows HP 2DProtein folding We experiments speciﬁcation shown Appendix B2 uses binary equalities model noncrossing constraint As search procedures added order exploit dependence X Y Moves general DDP schema following additional ones adhoc built relying structural peculiarities problem 1 The procedure described Example 11 2 A simpliﬁcation t increasing order having guessed Movest explicitly compute values Xt1 Yt1 leaves engine free search suitable values channeling constraints OPL defaults search strategy It interesting observe search procedures exploiting structure particular problem model better DDP course cost additional programming effort worse performance Such behavior common interesting exceptions problems analyzed end section As mentioned Example 8 wrote second formulation problem noncrossing constraint deﬁned terms additional ternary guessed predicate Hits In case predicate dependent Moves However alternative formulation turned low quality efﬁcient previous Interestingly case beneﬁts adding DDP search procedure impressive Detailed results given Table 2 This good example reasoning task problem speciﬁcation able recover inaccuracies designers writing bad models Blocks world Also results Blocks world problem delaying branches dependent predicates greatly speedups computation Besides DDP following search procedures 1 A procedure similar denoted 2 Protein folding experiments generates moves allowing engine ﬁnd thanks channeling constraints correct values dependent variables belonging On Clear time step 2 An enrichment generate moves rejected unfeasible constraints try block clear try block clear T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 1001 Table 2 OPL solving times benchmark instances HP 2DProtein folding problem model additional Hits dependent predicate search procedure means OPL terminate hour Length max contacts No search proc default strategy 5 6 6 6 6 7 7 7 7 8 8 8 8 0 0 2 0 1 0 0 2 2 0 1 2 3 2512 10318 39359 18198 14464 Total time 2964851 With search procedure DDP 009 010 014 010 017 009 016 023 042 012 028 058 185 480 Saving 9964 9990 9996 9995 9988 10000 10000 9999 9999 10000 9999 9998 9995 9998 Table 3 OPL solving times benchmark instances Blocks world problem search procedures means OPL terminate hour Instance Blocks Min plan length 12 4 3 6 5 18 bwlargea bwreversal4 bwsussman bw12step bwreversal5 bwlargeb Total time 9 4 3 7 5 11 No search proc default strategy 082 1195 With search procedure DDP Saving 1 Saving 2 Saving 2307 9936 9146 007 9941 007 076 9998 10000 009 000 000 9024 008 9916 01 000 066 9998 000 39671 8898 9146 007 9950 006 657 9982 10000 010 000 1441277 362406 7486 1080084 2506 400351 7222 The performance DDP impressive case leading savings 999 On hand adding complex procedures 1 2 improve performance Results shown Table 3 Factoring The behavior OPL Factoring slightly different observed problems We experiments speciﬁcation shown Appendix B1 added different adhoc built search procedures DDP order exploit functional dependence guessed predicate carry X Y 1 A procedure similar denoted 1 Protein folding experiments generating digits factors signiﬁcant ones computes carry values ﬂy 2 A simpliﬁcation instead computing carry values leaves engine free search suitable values OPL defaults 3 An enrichment procedure 1 starts generating equally long factors 4 An enrichment 2 starts generating equally long factors The intuition 3 4 nontrivial instances problem likely solutions factors comparable sizes search procedures exploit properties related data problem model As Table 4 shows OPL beneﬁts adding DDP saving 19 average adding complex 1 2 improve performance However worth noting adding 3 4 greatly boosts OPL leading savings 53 respect speciﬁcation search procedure However procedures strongly related speciﬁc problem considered properties instances unlikely synthesized automatically Table 4 OPL solving times benchmark instances Factoring problem search procedures Z No search proc default strategy 63233712858073 8107676847961 66117128225483 71444640648611 3457419019907 37836417723859 17337128879149 Total time 92973 35166 111198 130351 19344 112577 59663 561272 With search procedure DDP 100218 779 4263 20174 104 110039 2921 92278 3339 12885 3905 68619 1525 50565 Saving 1 Saving 2 Saving 3 Saving 4 Saving DDP eq long Saving 104975 1291 3786 21852 852 101726 2938 92048 3005 13532 68827 3886 62335 448 100773 839 4318 19983 988 100212 3444 85458 3394 12778 64203 4297 60082 070 63423 12634 57558 5055 7819 38230 34281 3178 6407 4824 6122 5958 6604 4254 57917 11305 56375 51001 6783 43556 33725 3771 6785 4930 6087 6493 6131 4347 6598 1057 71409 59489 3440 43020 30983 2903 6994 3578 5436 8222 6179 4807 4924 454778 1897 465295 1710 443489 2099 264495 5288 260662 5356 284891 1 0 0 2 T M n c n M C d o l A r t ﬁ c l I n t e l l g e n c e 1 7 1 2 0 0 7 9 8 5 1 0 1 0 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 1003 The question arises DDP performs behavior enhanced exploiting heuristic Table 4 shows additional results obtained adding general DDP schema rule forces engine ﬁrst generate equally long factors Savings higher comparable obtained adding 3 4 50 average This good evidence DDP considered good default schema search procedure dependencies guessed predicates exist possibly enhanced programmer exploiting problem peculiarities hard automated writing complex adhoc search procedures order compute carries unlikely payoff 7 Discussion future research directions In paper discussed semantic logical characterization functional dependencies guessed predicates declarative constraint problem speciﬁcations Functional dependencies easily introduced declar ative modeling intermediate results maintained order express constraints precise choices redundant modeling However dependencies negatively affect efﬁciency solver search space larger additional information programmer currently needed order efﬁciently cope We described framework functional dependencies checked lead automated synthesis simple efﬁcient search strategies DDP avoid spending search unfruitful branches Several examples constraint problems exhibit dependencies presented bioinformatics planning resource allocation experimental results discussed showing cur rent systems constraint programming greatly beneﬁt addition search strategies Moreover experimental analysis spending greater effort manually writing complex search procedures strongly exploit peculiarities particular problem solved improve performance Even cases cf Factoring good intuitions trying generate ﬁrst equally long factors boost solvers exploitation easily added DDP order produce results As claimed Section 1 related work address forms reformulations declarative constraint problem speciﬁcations detection breaking structural symmetries 34 elimination constraints called safedelay 6 provide semantic criteria speciﬁcation order automatically perform reasoning tasks Despite undecidability 7 practical circumstances tools like ﬁrstorder theorem provers ﬁnite model ﬁnders effectively efﬁciently order mechanize requested forms reasoning This suggests sideeffect brand new application area technology undoubtedly important results achieved Artiﬁcial Intelligence date goes direction building bridge constraint programming deduction In fact relations areas observed years cf 227 work symbolic level speciﬁcation available systems constraint programming currently perform kind reasoning problem model Acknowledgements Authors like thank Marco Schaerf useful discussions anonymous reviewers comments suggestions Appendix A Proofs results cid7S cid7P φ cid7S cid7P cid7R problem speciﬁcation input schema cid7R Guessed predicates set cid7P Theorem 1 Let ψ functionally depend cid7S following ﬁrstorder formula tautology cid6 cid5 φ cid7S cid7P cid7R φ cid7Scid14 cid7P cid14 cid7R cid7S cid7P cid3 cid7Scid14 cid7P cid14 cid7S cid3 cid7Scid14 A1 Proof If We formula A1 valid cid7P functionally depends cid7S Actually prove cid7P functionally depend cid7S formula A1 valid extension cid7S cid7P cid7Scid14 cid7P cid14 cid7R falsiﬁes Let assume cid7P functionally depend cid7S means according Deﬁnition 1 1004 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 exists instance cid7I cid7R interpretations cid9 cid7Σ cid7Π cid10 cid9 cid7Σ cid14 cid7Π cid14cid10 predicates cid7S cid7P cid9 cid7Σ cid7Πcid10 cid3 cid9 cid7Σ cid14 cid7Π cid14cid10 cid7Σ cid7Π cid7I φ cid7Σ cid14 cid7Π cid14 cid7I φ cid7Σ cid7Σ cid14 models φ differ extension predicates cid7P The interpretation cid7Σ cid7Π cid7Σ cid14 cid7Π cid14 cid7I makes left implication A1 true right false Thus interpretation model formula A1 Only Here cid7P functionally depends cid7S formula A1 valid Actually prove formula A1 valid extension cid7S cid7Scid14 cid7P cid7P cid14 cid7R falsiﬁes cid7P functionally depend cid7S Let assume interpretation cid7Σ cid7Π cid7Σ cid14 cid7Π cid14 cid7I predicates cid7S cid7P cid7Scid14 cid7P cid14 cid7R exists falsiﬁes formula A1 This means interpretation makes left implication A1 true right false Thus 1 cid7Σ cid7Π cid7I φ cid7S cid7P cid7R 2 cid7Σ cid14 cid7Π cid14 cid7I φ cid7Scid14 cid7P cid14 cid7R 3 cid7Π cid3 cid7Π cid14 4 cid7Σ cid7Σ From points 14 Deﬁnition 1 follows cid7P functionally depend cid7S cid9 cid7Σ cid7Πcid10 cid9 cid7Σ cid14 cid7Π cid14cid10 models φ differ extension predicates cid7P cid2 Theorem 2 Given ESO speciﬁcation input schema cid7R partition cid7S cid7P guessed predicates problem checking cid7P functionally depends cid7S decidable Proof We prove statement reducing problem checking arbitrary closed ﬁrstorder formula contradiction cid7S cid7P φ cid7S cid7P cid7R ﬁxed problem speciﬁcation input schema cid7R cid7P functionally Let ψ dependent cid7S Theorem 1 φ cid7S cid7P cid7R φ cid7Scid14 cid7P cid14 cid5 cid7R cid7S cid7P cid3 cid7Scid14 cid7P cid14 cid6 cid7S cid3 cid7Scid14 valid formula Let γ cid7R arbitrary closed ﬁrstorder formula relational vocabulary cid7R Consider new speciﬁcation ψ cid14 cid7S cid7P φcid14 cid7S cid7P cid7R φcid14 cid7S cid7P cid7R deﬁned φ cid7S cid7P cid7R γ cid7R From Theorem 1 cid7P functionally depends cid7S respect speciﬁcation ψ cid14 cid5 cid14 cid7S cid7P cid7R φ cid14 cid7Scid14 cid7P cid14 cid7R cid7S cid7P cid3 cid7Scid14 cid7P cid14 φ cid7S cid3 cid7Scid14 cid6 valid formula equivalently cid4 φ cid7S cid7P cid7R γ cid7R cid3 φ cid7Scid14 cid5cid3 cid4 cid7R γ cid7R cid7P cid14 cid7S cid7P cid3 cid7Scid14 cid7P cid14 cid7S cid3 cid7Scid14 cid6 A2 valid formula Since hypothesis cid7P functionally depends cid7S respect speciﬁcation ψ follows γ cid7R contradiction cid7P functionally depends cid7S respect ψ cid14 On hand let assume interpretation cid7I cid7R exists γ cid7I true Consider pair inter pretations cid7Σ cid7Π cid7Σ cid14 cid7Π cid14 cid7S cid7P cid7Σ cid7Π cid3 cid7Σ cid14 cid7Π cid14 cid7Σ cid7Σ cid14 Thus interpretation cid7Σ cid7Π cid7Σ cid14 cid7Π cid14 cid7I predicates cid7S cid7P cid7Scid14 cid7P cid14 cid7R model formula A2 Since interpretation cid7I cid7R nonempty universe pair interpretations cid7Σ cid7Π cid7Σ cid14 cid7Π cid14 kind built formula A2 valid cid7P functionally depends cid7S respect ψ cid14 γ cid7R contradiction Since problem decidable cf 4 decidable cid2 Appendix B Opl code examples In appendix speciﬁcations problems described paper declarative constraint mod eling language OPL 43 provided stateoftheart CP Ilog OPLSTUDIO6 An OPL speciﬁcation essentially ﬁve parts optional 6 Cf httpwwwilogcom T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 1005 Declaration instance schema type parameters relation symbols actual values para meters extensions relations instance given separate ﬁle denoted declaration Declaration guessed predicates encode search space means keyword var OPL allows guessed predicates typed supports functions means arrays Optional deﬁnition objective function means keyword maximize minimize Speciﬁcation constraints language similar ﬁrstorder logic plus syntactic sugar like bounded integers arithmetics Optional deﬁnition search procedure instructs search engine search strategy follow variable value branching orders case search procedure given default strategy applied It observed cf Section 2 OPL similar ESO In particular keyword var plays exactly role secondorder existential quantiﬁer ESO constraints correspond ﬁrstorder ESO speciﬁcation After commitment instance grounding OPLSTUDIO invokes wellknown commercial solvers Ilog CPLEX Ilog SOLVER depending speciﬁcation syntactically linear B1 Factoring Examples 1 7 int base int digitsZ range digit 0base1 range positions 1digitsZ digit Zpositions var digit Xpositions var digit Ypositions var positions digitsX var positions digitsY range digitCarry 0base1base1 digitsZbase var digitCarry carry1digitsZ1 solve digitsX digitsY 1 digitsZ digitsX digitsY X Y digitsX digitsY significant digits respectively XdigitsX 0 forall positions idigitsX Xi 0 YdigitsY 0 forall positions idigitsY Yi 0 Some symmetrybreaking digitsX digitsY Smallest factor different 1 digitsY 1 Y1 1 carry significant digit carry1 0 forall positions 1006 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 Zi carryi sum jk positions jki1 Xj Yk mod base forall 2digitsZ1 carryi carryi1 sum jk positions jki Xj Yk base overflow carry signif dgt 0 carrydigitsZ1 0 B2 HP 2DProtein folding Examples 2 8 Model binary inequalities int n enum Aminoacid HP range Pos 0n1 range PosButLast 0n2 Instance schema string length Aminoacid seqPos seq aminoacids enum Dir NESW range Coord n1n1 Guessed predicates var Dir MovesPosButLast var Coord XPos YPos var Pos contactsNumber maximize contactsNumber subject Protein shape Abs coordinates contactsNumber sumt1t2 Pos t11 t2 seqt1 H seqt2 H absXt1Xt2 absYt1Yt21 X0 0 Y0 0 Pos elem forallt Pos t0 Channeling constrs Movest1 N X Y Xt Xt1 Yt Yt1 1 Movest1 S Xt Xt1 Yt Yt1 1 Movest1 E Xt Xt1 1 Yt Yt1 Movest1 W Xt Xt1 1 Yt Yt1 Noncrossing constraint forallt1 t2 Pos t2 t1 Xt1 Xt2 Yt1 Yt2 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 1007 Model additional guessed predicate Hits We write differences respect previous model range Hit 0n2 hits cell Guessed predicates var Hit HitsCoordCoordPos times cell hit maximize contactsNumber subject contactsNumber Pos elem X0 0 Y0 0 forallt Pos t0 Channeling constrs X Y Noncrossing Initially cell hit forall xy Coord x0 y0 Hitsxy0 0 Hits000 1 origin Noncrossing Channeling constrs Hits forall t Pos xy Coord t0 xXt yYt HitsxytHitsxyt11 notxXt yYt HitsxytHitsxyt1 Noncrossing Each cell hit 0 1 times string cross forall xy Coord t Pos Hitsxyt 1 Search procedure Example 11 search X00 Y00 forallt PosButLast ordered increasing t generateMovest Movest N try Xt1 Xt Yt1 Yt1 endtry endif Movest S try Xt1 Xt Yt1 Yt1 endtry endif Movest E try Xt1 Xt1 Yt1 Yt endtry endif Movest W try Xt1 Xt1 Yt1 Yt endtry endif 1008 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 B3 Sailco inventory Example 9 taken wwwilogcom int nbPeriods range Periods 1nbPeriods float demandPeriods float regularCost float extraCost float capacity float inventory float inventoryCost var float regulBoatsPeriods var float extraBoatsPeriods var float inv0nbPeriods minimize Objective function omitted subject inv0 inventory forallt Periods regulBoatst capacity forallt Periods regulBoatst extraBoatst invt1 invt demandt B4 Blocks world Example 10 int nblocks range Block 1nblocks range BlockOrTable 0nblocks BlockOrTable TABLE 0 range Time 12nblocks range TimeWithZero 02nblocks range bool 01 BlockOrTable OnAtStartBlock BlockOrTable OnAtGoalBlock MoveBlockt MoveTot refer moves performed time t1 time t var Block MoveBlockTime var BlockOrTable MoveToTime var BlockOrTable OnBlock TimeWithZero var bool ClearBlockOrTable TimeWithZero var TimeWithZero schLen minimize schLen subject forall b Block Initial state Onb0 OnAtStartb time 0 Channeling constraints Clear forall b Block t TimeWithZero sumb_up Block Onb_uptb 0 Clearbt 0 forall t TimeWithZero ClearTABLEt 1 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 1009 Constraints moves forall t Time MoveBlockt MoveTot No useless moves MoveTot OnMoveBlocktt1 t schLen Moving block clear ClearMoveBlockt t1 1 Target position clear ClearMoveTot t1 1 Channeling constraints On OnMoveBlockt t MoveTot forall b Block Chann constrs On frame conds t schLen bMoveBlockt OnbtOnbt1 forall b Block Final state OnbschLen OnAtGoalb References 1 F Bacchus P van Run Dynamic variable ordering CSPs Proceedings First International Conference Principles Practice Constraint Programming CP95 Cassis France Lecture Notes Computer Science vol 976 Springer 1995 pp 258275 2 W Bibel Constraint satisfaction deductive viewpoint Artiﬁcial Intelligence 35 1988 401413 3 S Bistarelli P Codognet F Rossi An abstraction framework soft constraints relationship constraint propagation Proceed ings Fourth International Symposium Abstraction Reformulation Approximation SARA 2000 Horseshoe Bay TX USA Lecture Notes Computer Science vol 1864 Springer 2000 pp 7186 4 E Börger E Gräedel Y Gurevich The Classical Decision Problem Perspectives Mathematical Logic Springer 1997 5 CA Brown L Finkelstein PW Purdom Backtrack searching presence symmetry T Mora Ed Proceedings Sixth International Conference Applied Algebra Algebraic Algorithms Error Correcting codes Rome Italy Lecture Notes Computer Science vol 357 Springer 1988 pp 99110 6 M Cadoli T Mancini Automated reformulation speciﬁcations safe delay constraints Artiﬁcial Intelligence 170 89 2006 779 801 7 M Cadoli T Mancini Using theorem prover reasoning constraint problems Applied Artiﬁcial Intelligence 21 3 2007 Special issue Best papers AIIA 2005 press 8 M Cadoli A Schaerf Compiling problem speciﬁcations SAT Artiﬁcial Intelligence 162 2005 89120 9 C Calabro R Impagliazzo V Kabanets R Paturi The complexity Unique kSAT An isolation lemma kCNFs Proceedings Eighteenth IEEE Conference Computational Complexity CCC 2003 Aarhus Denmark IEEE Computer Society Press 2003 p 135 ff 10 CC Chang HJ Keisler Model Theory ed NorthHolland 1990 11 BMW Cheng KMF Choi JHM Lee JCK Wu Increasing constraint propagation redundant modeling experience report Con straints 4 2 1999 167192 12 JM Crawford ML Ginsberg EM Luks A Roy Symmetrybreaking predicates search problems Proceedings Fifth Interna tional Conference Principles Knowledge Representation Reasoning KR96 Cambridge MA USA Morgan Kaufmann Los Altos CA 1996 pp 148159 13 P Crescenzi D Goldman CH Papadimitriou A Piccolboni M Yannakakis On complexity protein folding Journal Computational Biology 5 3 1998 423466 14 R Dechter Constraint networks survey Encyclopedia Artiﬁcial Intelligence second ed John Wiley Sons 1992 pp 276285 15 HD Ebbinghaus J Flum Finite Model Theory Springer 1999 16 T Ellman Abstraction approximate symmetry Proceedings Thirteenth International Joint Conference Artiﬁcial Intelligence IJCAI93 Chambéry France Morgan Kaufmann Los Altos CA 1993 pp 916921 17 R Fagin Generalized ﬁrstorder spectra polynomialtime recognizable sets RM Karp Ed Complexity Computation American Mathematical Society 1974 pp 4374 1010 T Mancini M Cadoli Artiﬁcial Intelligence 171 2007 9851010 18 P Flener Towards relational modelling combinatorial optimisation problems C Bessière Ed Proceedings International Work shop Modelling Solving Problems Constraints conjunction Seventeenth International Joint Conference Artiﬁcial Intelligence IJCAI 2001 Seattle WA USA 2001 19 R Fourer DM Gay BW Kernigham AMPL A Modeling Language Mathematical Programming International Thomson Publishing 1993 20 EC Freuder Eliminating interchangeable values Constraint Satisfaction Problems Proceedings Ninth National Conference Artiﬁcial Intelligence AAAI91 Anaheim CA USA AAAI PressThe MIT Press 1991 pp 227233 21 MR Garey DS Johnson Computers Intractability A Guide Theory NPCompleteness WH Freeman Company San Francisco CA USA 1979 22 E Giunchiglia R Sebastiani Applying DavisPutnam procedure nonclausal formulas Proceedings Sixth Conference Italian Association Artiﬁcial Intelligence AIIA99 Bologna Italy Lecture Notes Artiﬁcial Intelligence vol 1792 Springer 2000 pp 8494 23 F Giunchiglia T Walsh A theory abstraction Artiﬁcial Intelligence 57 1992 323389 24 W Hart S Istrail HP benchmarks Available httpwwwcssandiagovtech_reportscompbiotortillahpbenchmarkshtml accessed end 2004 25 T Hnich T Walsh Why Channel Multiple viewpoints branching heuristics Proceedings Second International Workshop Modelling Reformulating CSPs Towards Systematisation Automation conjunction Ninth International Conference Principles Practice Constraint Programming CP 2003 Kinsale Ireland 2003 26 H Kautz B Selman Pushing envelope Planning propositional logic stochastic search Proceedings Thirteenth National Conference Artiﬁcial Intelligence AAAI96 Portland OR USA AAAI PressThe MIT Press 1996 pp 11941201 27 PG Kolaitis Constraint satisfaction databases logic Proceedings Eighteenth International Joint Conference Artiﬁcial Intelligence IJCAI 2003 Acapulco Mexico Morgan Kaufmann Los Altos CA 2003 pp 15871595 28 V Kumar Algorithms constraintsatisfaction problems A survey AI Magazine 13 1 1992 3244 29 KF Lau KA Dill A lattice statistical mechanics model conformational sequence spaces proteins Macromolecules 22 1989 39863997 30 A Lenstra HW Lenstra Algorithms number theory J van Leeuwen Ed The Handbook Theoretical Computer Science vol 1 Algorithms Complexity The MIT Press 1990 31 N Leone G Pfeifer W Faber T Eiter G Gottlob S Perri F Scarcello The DLV knowledge representation reasoning ACM Transactions Computational Logic 7 3 2006 499562 32 CM Li Integrating equivalency reasoning DavisPutnam procedure Proceedings Seventeenth National Conference Artiﬁcial Intelligence AAAI 2000 1 pp 291296 33 T Mancini Declarative constraint modelling speciﬁcationlevel reasoning PhD thesis Università degli Studi di Roma La Sapienza Roma Italy March 2005 34 T Mancini M Cadoli Detecting breaking symmetries reasoning problem speciﬁcations Proceedings Sixth International Symposium Abstraction Reformulation Approximation SARA 2005 Airth Castle Scotland UK Lecture Notes Artiﬁcial Intelligence vol 3607 Springer 2005 pp 165181 35 W McCune Otter 33 reference manual Technical Report ANLMCSTM263 Argonne National Laboratory Mathematics Computer Science Division August 2003 Available httpwwwunixmcsanlgovARotter 36 I Niemelä Logic programs stable model semantics constraint programming paradigm Annals Mathematics Artiﬁcial Intel ligence 25 34 1999 241273 37 NJ Nilsson Principles Artiﬁcial Intelligence Tioga Publishing Co 1980 38 CH Papadimitriou Computational Complexity Addison Wesley Publishing Company Reading MA 1994 39 P Prosser The dynamics dynamic variable ordering heuristics Proceedings Fourth International Conference Principles Practice Constraint Programming CP98 Pisa Italy Lecture Notes Computer Science vol 1520 Springer 1998 pp 1723 40 T Pyhälä Factoring benchmarks SAT solvers Technical report Helsinki University Technology 2004 41 BM Smith K Stergiou T Walsh Using auxiliary variables implied constraints model nonbinary problems Proceedings Seventeenth National Conference Artiﬁcial Intelligence AAAI 2000 1 pp 182187 42 LG Valiant VV Vijay V Vazirani NP easy detecting unique solutions Theoretical Computer Science 47 3 1986 8593 43 P Van Hentenryck The OPL Optimization Programming Language The MIT Press 1999 44 T Walsh Permutation problems channelling constraints R Nieuwenhuis A Voronkov Eds Proceedings Eighth International Conference Logic Programming Automated Reasoning LPAR 2001 Havana Cuba Lecture Notes Computer Science vol 2250 Springer 2001 pp 377391 45 DHD Warren Extract Kluzniak Szapowicz APIC studies data processing 24 1974 Readings Planning Morgan Kaufmann Los Altos CA 1990 pp 140153