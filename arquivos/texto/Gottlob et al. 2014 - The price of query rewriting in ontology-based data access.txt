Artiﬁcial Intelligence 213 2014 4259 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint The price query rewriting ontologybased data access Georg Gottlob Stanislav Kikot b Roman Kontchakov b Vladimir Podolskii c Thomas Schwentick d Michael Zakharyaschev b Department Computer Science University Oxford UK b Department Computer Science Information Systems Birkbeck University London UK c Steklov Mathematical Institute Moscow Russia d Fakultät für Informatik TU Dortmund Germany r t c l e n f o b s t r c t Article history Received 7 July 2013 Received revised form 13 March 2014 Accepted 26 April 2014 Available online 5 May 2014 Keywords Ontology Datalog Conjunctive query Query rewriting Succinctness Boolean circuit Monotone complexity 1 Introduction linear Datalog sticky Datalog We solution succinctness problem size ﬁrstorder rewritings conjunctive queries ontologybased data access ontology languages We positive existential OWL 2 QL nonrecursive datalog rewritings use extra nonlogical symbols intensional predicates case datalog rewritings suffer exponential blowup worst case ﬁrstorder rewritings grow superpolynomially NP Ppoly We prove nonrecursive datalog rewritings general exponentially succinct positive existential rewritings ﬁrstorder rewritings superpolynomially succinct positive existential rewritings On hand construct polynomialsize positive existential nonrecursive datalog rewritings assumption data instance contains ﬁxed constants 2014 Elsevier BV All rights reserved Our aim article solution succinctness problem types conjunctive query rewriting ontologybased data access OBDA basic ontology languages OWL 2 QL fragments Datalog The idea OBDA 2005 14192847 In OBDA paradigm ontology deﬁnes high level global schema provides vocabulary user queries An OBDA rewrites queries vocabulary data delegates actual query evaluation data sources relational databases triple stores datalog engines OBDA regarded important ingredient new generation information sys tems gives highlevel conceptual view data ii provides users convenient vocabulary queries isolating details structure data sources iii allows enrich incomplete data background knowledge iv supports queries multiple possibly heterogeneous data sources A key concept OBDA ﬁrstorder FO rewritability An ontology language L said enjoy FOrewritability conjunctive query CQ q ontology Σ formulated L rewritten FOquery q data instance D answers original CQ q knowledge base Σ D computed evaluating rewriting cid4 Corresponding author Email addresses georggottlobcsoxacuk G Gottlob staskikotxgmailcom S Kikot romandcsbbkacuk R Kontchakov podolskiimirasru V Podolskii thomasschwentickudoedu T Schwentick michaeldcsbbkacuk M Zakharyaschev httpdxdoiorg101016jartint201404004 00043702 2014 Elsevier BV All rights reserved G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 43 cid4 cid4 cid4 D As q FOquery answers q q obtained standard relational database management RDBMS Ontology languages property include OWL 2 QL proﬁle Web Ontology Language OWL 2 based description logics DLLite family 164 fragments Datalog linear tgds 11 known atomicbody existential rules 6 sticky tgds 1213 To illustrate consider OWL 2 QLontology Σ consisting following tuplegenerating dependencies tgds cid2 x cid2 x x y x y cid2 RAx y Projectx y cid2 worksOnx y Project y cid3cid3 cid2 cid2 isManagedByx y Professor y cid3 worksOnx y involves y x cid3 isManagedByx y involvesx y cid3cid3 CQ qx asking ﬁnd work professors qx y z cid2 cid3 worksOnx y involves y z Professorz A moments thought convince reader positive existential query cid4 q x y z cid4 worksOnx y cid2 cid3 worksOnz y isManagedBy y z involves y z cid5 Professorz cid5 worksOnx y Project y cid4 y 1 2 3 4 5 RAx FOrewriting qx Σ sense set D ground atoms constant D Σ D cid10 qa D cid10 q cid4 In Section 2 shall consider example A number different rewriting techniques proposed implemented OWL 2 QL PerfectRef 47 PrestoPrexto 5554 Rapid 18 combined approach 37 Ontop 5133 extensions RequiemBlackout 4546 Nyaya 2543 Clipper 20 35 However FOrewritings constructed far worst case exponential size query q Thus despite fact data complexity CQ answering ontologies FOrewritability complex standard database query evaluation AC0 rewritings large RDBMSs cope It apparent theory experiments OBDA paradigm work practice restrict attention ontologies CQs ensure polynomial FOrewritability The major open question going attack article standard ontology languages OBDA particular OWL 2 QL enjoy polynomial FOrewritability Naturally answer depends means use q Σ use nonlogical symbols rewritings For example rewriting q occurred q Σ Such rewritings containing equality described pure possible databases cf 16 Note known rewritings apart combined approach 37 pure sense Other important parameters available logical means connectives quantiﬁers rewritings way represent Apart class arbitrary FOqueries shall consider positive existential PE queries nonrecursive datalog NDL queries possible formalisms rewritings needless pure NDLrewritings contain new intensional predicates cid4 At ﬁrst sight results obtain article divided negative positive The bad news sequence CQs qn OWL 2 QL ontologies Σn size O n pure PE NDLrewriting qn Σn exponential size n pure FOrewriting superpolynomial size NP Ppoly We obtain negative result ﬁrst showing OBDA OWL 2 QL powerful compute monotone Boolean functions NP PErewritings correspond monotone Boolean formulas NDLrewritings monotone Boolean circuits FOrewritings arbitrary Boolean formulas Then use celebrated exponential lower bounds size monotone circuits formulas computing NPcomplete Boolean function Cliquenk graph n nodes contains kclique 5049 superpolynomial lower bound size arbitrary necessarily monotone Boolean formulas computing Cliquenk consequence assumption NP cid11 Ppoly We use known separation results 4948 monotone Boolean functions bipartite graph n vertices perfect matching given vertex accessible path accessibility n vertices pure NDLrewritings general exponen tially succinct pure PErewritings pure FOrewritings superpolynomially succinct pure PErewritings On hand good news assuming data instance contains ﬁxed distinct individual constants construct polynomialsize impure PE NDLrewritings CQ ontology polynomial witness property particular ontology OWL 2 QL linear Datalog bounded arity In essence rewriting guesses polynomial number ground atoms database individuals labelled nulls encoded tuples ﬁxed constants checks atoms satisfy given CQ form sequence chase steps We ﬁrst construct polynomialsize impure PErewriting disjunctions encoded polynomialsize NDLrewriting intensional predicates small arity As bounded arity sticky Datalog 44 G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 constants impure PErewriting replaced fresh existentially quantiﬁed variables x y x cid11 y obtain polynomialsize pure FOrewriting data instances domain elements How reconcile seemingly contradictory results To establish exponential superpolynomial lower bounds size pure rewritings computing monotone Boolean functions NP polynomially reducible answering CQs OWL 2 QLontologies data instances single individual As evaluating queries data instances tractable pure rewritings CQs ontologies computing NPcomplete monotone Boolean functions Cliquenk constructed polynomial timeunless P NP Our argument Section 3 bit subtler prove pure polynomial rewritings CQs ontologies computing NPcomplete monotone Boolean functions actually exist In fact standard pure rewritings represent explicitly distinct homomorphisms given CQ labelled nulls possible chases given ontology construction shows exponentiallymany homomorphisms On hand impure rewritings employ polynomiallymany additional existential quanti ﬁers ﬁxed distinct domain elements order guess homomorphisms Thus additional NPoverhead OBDA compared CQ evaluation plain databases represented succinct way The exponen tial succinctness impure rewritings compared pure ones kind succinctness nondeterministic ﬁnite automata QBFs compared deterministic automata 42 respectively SAT cf 5 The plan article follows In Section 2 introduce OWL 2 QL linear sticky Datalog fragments language tuplegenerating dependencies illustrate construction FOrewriting OWL 2 QLontologies We introduce nonrecursive datalog rewritings formulate succinctness separation problems The exponential superpolynomial lower bounds size pure rewritings obtained Section 3 The polynomialsize impure PE NDLrewritings families ontologies polynomial witness property constructed Section 4 We prove separation results mentioned Section 5 Open problems directions future research discussed Section 6 Some results article ﬁrst appeared conference proceedings 2632 2 Firstorder rewritability size rewritings matters Let R relational schema Given data instance D R denote cid3D set individual constants D We regard D ﬁnite set ground atoms A conjunctive query CQ short qx formula form y ϕx y ϕ conjunction atoms P t R extended equality t t term individual constant variable x y The size q CQ q number symbols q Let Σ set ﬁrstorder sentences R The pair Σ D called knowledge base KB short A tuple elements cid3D said certain answer qx KB Σ D M cid10 qa model M Σ D case write Σ D cid10 qa If tuple x answer variables certain answer q Σ D yes case M cid10 q model M Σ D CQs answer variables called Boolean CQs For purposes OBDA interested ontologies theories Σ problem ﬁnding certain cid4x called ﬁrstorder swers reduced standard database query evaluation More precisely ﬁrstorder formula q rewriting q Σ FOrewriting short data instance D tuple elements cid3D certain answer cid4x D We Σ enjoys ﬁrstorder rewritability CQ qx Σ D case answer q qx exists FOrewriting q Σ There types recognised ontology languages guarantee ﬁrstorder rewritability The languages ﬁrst type introduced description logic community based DLLite family description logics 164 include OWL 2 QL proﬁle Web Ontology Language OWL 21 The languages second type designed datalog community belong Datalog family 1211 known existential rules 7 All ontology languages formulated terms tuplegenerating dependencies We remind reader 1 tuplegenerating dependency tgd short ﬁrstorder sentence form cid2 x cid3 ϕx yψx y 6 ϕx body ψx y head tgd conjunctions atoms variables x actually occur ϕx note ϕx ψx y contain individual constants Following description logic tradition consider negative constraints form cid3 ϕx cid2 x Finite sets tgds negative constraints called ontologies Note ontologies inconsistent Given ontology Σ denote Σ size number symbols Σ An important property tgds wellknown fact 1 ontology Σ consistent KB Σ D exists possibly inﬁnite model CΣD Σ D known universal canonical model Σ D CQ qx tuple cid3D Σ D cid10 qa CΣD cid10 qa Such universal model repairs D respect Σ constructed following oblivious chase procedure intuitively 1 wwww3orgTRowl2overview G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 45 Fig 1 The chase CΣD Σ 1 4 D RAck worksOnck e Projecte isManagedBye gg ΣD economical way We require following deﬁnitions chase procedure formally Let C set ground atoms ϕx conjunction atoms body tgd negative constraint We map h x individual constants C homomorphism ϕx C hϕx C hϕx denotes set atoms P ht P t ϕx usual assume ha individual constant We C consistent Σ negative constraint xϕx Σ homomorphism h ϕx C D Suppose Ck1 The chase algorithm initially sets C0 ΣD h h homomorphism ϕx Ck1 ΣD deﬁned A tgd τ form xϕx yψx y said applicable Ck1 ΣD k 1 hϕx cid11 Ck2 cid4 y c y y y ΣD Deﬁne extension h c y fresh individual constant labelled null different constants construction An application τ h Ck1 ΣD consistent Σ ΣD follows takes enumeration distinct pairs τi hi n τi Σ algorithm constructs Ck applicable Ck1 ΣD The chase CΣD Σ D union Ck ΣD result applying τi hi Ck1 ΣD consistent Σ ΣD If Ck1 ΣD k ω provided Ck cid4x hx x x h ΣD adds ground atoms h ΣD hi sets Ck cid4ψx y Ck1 h taking h For example Fig 1 shows chase CΣD ontology Σ consisting tgds 14 introduction data instance D RAck worksOnck e Projecte isManagedBye gg note general chase necessarily ﬁnite cid4 The model CΣD called universal model M Σ D homomorphism CΣD M It property universal models makes sure certain answers CQs Σ D contained CΣD Furthermore ontology bounded derivation depth property BDDP short function d N N CQ qx data instance D tuplea cid3D certain answer q Σ D Cdq cid10 qa Note dq depend D depend Σ The following theorem gives ΣD characterisation ontologies enjoying FOrewritability Theorem 1 An ontology BDDP enjoys FOrewritability Proof For proof 11 Theorem 9 To use 9 Proposition 4 based 56 according yiϕix yi FOrewriting qx Σ rewriting form q yi ϕix yi CQ Let k maximum number atoms CQs yi ϕix yi depends q cid4 k It ﬁxed Σ Clearly answer q cid4 k Observe number pairwise follows CΣD cid10 qa CΣDcid4 cid10 qa D nonisomorphic D D k ﬁnite depends q ﬁxed Σ Thus dq number d Cd cid10 qa CΣD cid10 qa D D k cid2 cid4x D answer q cid4x subset D cid4 D D cid4 D D cid4x cid6 ΣD Disjunctions CQs proof Theorem 1 known unions conjunctive queries UCQs short An FOrewriting q Σ form UCQ called UCQrewriting q Σ That BDDP Σ equivalent existence UCQrewritings CQs Σ shown earlier result graph databases 57 fact minimal UCQrewritings unique isomorphism 36 ontology UCQrewritings CQs called ﬁnite uniﬁcation set Baget et al 6 The following ontology languages ensure BDDP linear tgds 11 tgds single atom body O WL 2 QLtgds linear tgds atoms arity 2 individual constants sticky sets tgds 13 sets tgds variables appear body tgd join variables propagated stick chase inferred atoms examples include stickyjoin sets tgds 13 domainrestricted rules 7 Each ontology languages include negative constraints affect chase procedure knowledge base inconsis tent 11 46 G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 Fig 2 Three homomorphisms qx hypothetical CΣD Remark 2 It hard standard OWL 2 QL proﬁle Web Ontology Language OWL 2 represented terms OWL 2 QLtgds negative constraints way round example tgd xRx x Ax expressed OWL 2 QL However OWL 2 QLtgds negative constraints use article express ible OWL 2 QL Thus linear tgd form cid2 x cid2 cid3cid3 Ax y Rx y B y 1 2 construction Section 3 encoded concept inclusion A cid18 RB OWL 2 QL description logic syntax A B concept names R role following set concept role inclusions syntax DLLite H core 4 A cid18 R B R B cid18 B R B cid18 R R B fresh role Because slightly abuse terminology ontologies OWL 2 QLtgds simply OWL 2 QLontologies We example showing construct FOrewritings CQs OWL 2 QLontologies Example 3 Consider OWL 2 QLontology Σ 1 4 CQ 5 introduction Suppose cid3D certain answer qx Σ D data instance D This means CΣD cid10 qa cid4x qx Σ analysing possible homomorphism h qx CΣD hx We construct FOrewriting q locations h y hz CΣD To begin belong cid3D To account homomorphism cid4x disjunct include y z worksOnx y worksOnz y isManagedBy y z involves y z Professorz q Another possible homomorphism h1 h1 y cid3D h1z labelled nulls happen h1 y instance Project Fig 2 middle To homomorphism account include disjunct y worksOnx y Project y q Then homomorphism h2 h2 y h2z labelled nulls happen h2x instance RA Fig 2 left This gives disjunct RAx cid4x Finally homomorphism h3 h3 y labelled null h3z cid3D happen q h3z h3x instance RA Professor Fig 2 right This homomorphism gives disjunct RAx Professorz x z subsumed disjunct RAx redundant Thus obtain FOrewriting q cid4x qx Σ given introduction cid4 Our example gives ontology BDDP Example 4 Consider ontology Σ x yRx y A y Ax single tgd linear OWL 2 QL atoms body sticky variable y Given data instance D construct universal model Σ D chase procedure However derive Aa cid3D ﬁnd Rchain b Ab D The number chase steps producing chains kind clearly depend D Ontologies Σ allowed OWL 2 EL proﬁle OWL 2 CQ answering OWL 2 ELontologies known Pcomplete data complexity 15 means general enjoy FOrewritability A different approach OBDA OWL 2 EL suggested Lutz et al 40 On hand CQs ontologies G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 47 formulated OWL 2 EL description logics HornSHIQ HornSROIQ rewritten recursive datalog queries 534420 datalog engines OBDA FOrewritability based empirical assumption query evaluation RDBMSs eﬃcient practice However assumption works reasonably small CQs evaluation large CQs hard problem RDBMSs 41 come surprise CQ evaluation W 1complete2 21 Recall CQs bounded treewidth evaluated polynomial time q cid3D 60341727 Since CQs occur practice result serve theoretical justiﬁcation empirical assumption But size existing FOrewritings CQs ontologies languages consideration The following theorem summarises known results Theorem 5 See 1611251324 For set Σ tgds let KΣ number predicates Σ let LΣ maximum arity predicates Σ There exist CQs q sets Σ OWL 2 QLtgds UCQrewritings ΩK ii Any CQ q set Σ linear tgds constants UCQrewriting O KΣ LΣ qLΣ q CQs q Σ CQs number atoms CQ exceed number atoms q In particular OWL 2 QLtgds Σ LΣ 2 UCQrewriting O KΣ 2q2q CQs iii Any CQ q sticky set Σ tgds constants UCQrewriting 2O KΣ LΣ qLΣ CQs O KΣ LΣ qLΣ atoms Proof Let Σ x Aix A0x 1 n q x1 xk A0x1 A0xk It clear UCQrewriting q Σ contain CQs possible combinations A0x j A1x j Anx j 1 j k For ii iii brieﬂy comment UCQrewritings constructed 1611251324 backward chaining ii Since tgds single atom body number atoms CQs resulting UCQrewriting larger number atoms q Thus CQs contains LΣ q terms assume use names existentially quantiﬁed variables The total number atoms form terms exceed KΣ LΣ qLΣ Given CQ UCQrewriting q atoms total number possible component CQs bounded KΣ LΣ qLΣ q iii Observe new variables arising UCQrewriting existentially quantiﬁed Due stickiness condition new variable occur body tgd rewriting This variable interact variable use unique special symbol corresponds dont care underscore symbol Prolog Then term atom rewritten query variable q special underscore symbol end underscore symbol replaced fresh existentially quantiﬁed variable There LΣ q 1 terms It follows KΣ LΣ q 1LΣ O KΣ LΣ qLΣ atoms CQ UCQrewriting Each atoms included CQ included gives 2O KΣ LΣ qLΣ possible CQs UCQrewriting cid2 Thus weakest ontology language OWL 2 QL available UCQ rewritings exponential size worst case The chief problem analyse article exist shorter rewritings Together FO UCQrewritings deﬁned consider positive existential nonrecursive datalog rewritings A positive existential rewriting PErewriting short CQ qx ontology Σ FOrewriting q cid4x form zψx z ψ built atoms Every PErewriting obviously transformed equivalent UCQrewriting expense exponential blowup To deﬁne nonrecursive datalog rewritings remind reader 1 datalog program Π ﬁnite set Horn clauses A0 A1 Am Ai atom form P t term t t universally quantiﬁed variable individual constant A0 called head clause A1 Am body All variables occurring head A0 occur body A1 Am A predicate P depends predicate Q Π contains clause heads predicate P body contains atom predicate Q A datalog program Π called nonrecursive dependence relation acyclic A nonrecursive datalog query consists nonrecursive datalog program Π goal Gx atom Given data instance D tuple elements cid3D called certain answer Π Gx D Π D cid10 Ga A nonrecursive datalog query Π Gx called nonrecursive datalog rewriting CQ qx ontology Σ NDLrewriting short data instance D tuple elements cid3D Σ D cid10 qa Π D cid10 Ga So far speciﬁed means allowed use rewritings The ﬁrst FOrewritings 1645 formulated signature contained constant predicate symbols q Σ equality As 2 More precisely evaluation Boolean CQ q D time O q cid3D q time f q cid3D O 1 computable function f FPT W 1 48 G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 argued Calvanese et al 16 FOrewritings dataindependent applicable possible data instances We start adopting deﬁnition FO PErewritings NDLrewritings course use new deﬁnable intensional predicates constants occur q We interested major questions Do exist polynomialsize FO PE NDLrewritings CQs OWL 2 QLontologies ii Can rewritings type substantially shorter rewritings types iii What extra means rewritings substantially shorter 3 Exponential superpolynomial lower bounds size rewritings In section answer question To end problem constructing circuits compute monotone Boolean functions NP reduced problem ﬁnding rewritings CQs OWL 2 QLontologies This reduction coupled known lower bounds size monotone Boolean circuits formulas provide similar lower bounds size rewritings We begin reminding reader basic deﬁnitions theory circuit complexity details 329 By nary Boolean function n 1 mean function 0 1n 0 1 A Boolean function f monotone f α f β α β componentwise vectors 0 1 An ninput Boolean circuit C directed acyclic graph n sources inputs sink output Every nonsource node C called gate labelled case incoming edges case incoming edge A circuit monotone contains gates Boolean formulas thought circuits gate outgoing edge For input α 0 1n output C α denoted Cα C said compute Cα f α α 0 1n The size C denoted C number nodes C nary Boolean function f number inputs gates A family Boolean functions sequence f 1 f 2 f n nary Boolean function A family f 1 f 2 complexity class NP language α 0 1n f nα 1 NP For family exist polynomials p q Boolean circuits C1 C2 Cn n pn inputs Cn qn α 0 1n f nα 1 Cnα β 1 β 0 1pn We additional pn inputs β Cn nondeterministic inputs β known certiﬁcate 3 A family f 1 f 2 NPcomplete corresponding language α 0 1n f nα 1 NPcomplete The class languages decidable families polynomialsize circuits denoted Ppoly It known P cid2 Ppoly Thus obtain P cid11 NP NP cid11 Ppoly By KarpLipton theorem 3 NP Ppoly implies PH Σ p 2 In section given family monotone Boolean functions f n NP ﬁrst encode themvia Tseitin transfor mation 59by means polynomialsize CNFs construct sequence OWL 2 QLontologies Σ f n Boolean CQs q f n Σ f n Dα cid10 q f n α 0 1n f nα 1 database instance Dα determined α Then fact Dα single domain element PErewritings q f n Σ f n rewritings essence monotone Boolean formulas propositional PEformulas known results circuit complexity polynomial example case family Boolean functions check given graph encoded arguments functions contains clique speciﬁed size Suppose given family Boolean functions f n NP corresponding family Boolean circuits Cn We consider inputs including nondeterministic ones circuits Cn Boolean variables Each gate Cn thought Boolean variable value coincides output gate given input Let g g1 gCn Boolean variables nodes Cn We assume Boolean circuit Cn contains gates regarded set equations form gi gicid4 gi gicid4 gicid4cid4 gicid4 gicid4cid4 variables inputs gate gi We assume gi depend g1 gi1 g1 gn inputs Cn gn1 gnpn nondeterministic inputs Cn gCn output Now Cn associate following Boolean formula CNF variables h h1 hn g ψnh g ncid7 gi hi gCn cid7 cid4 cid5 gicid4 gi gicid4 gi i1 cid7 cid4 gi gi cid4 gi cid4cid4 Cn gi gi cid4 Cn cid5 gicid4 gi gicid4cid4 gi gicid4 gicid4cid4 gi The clauses conjuncts encode correct computation circuit equivalent gi gicid4 gi gicid4 gicid4cid4 respectively In follows denote ψnα g result replacing variables h respective truthvalues vector α 0 1n g variables formula G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 49 Lemma 6 For family monotone Boolean functions f n NP α 0 1n f nα 1 ψnα g satisﬁable f nα 1 thenC nα β 1 β Consider ψnα γ γi γ given output Proof If values respective nodes gi Cn input α β output value input nondeterministic input Cn respective value By deﬁnition conjuncts ψnα γ true assignment The ﬁrst conjunct trivially true second conjunct true γCn Cnα β Conversely suppose ψnα γ 1 γ Let αcid4 values inputs Cn γ By ﬁrst conjunct αcid4 α f n monotone obtain f nαcid4 f nα So suﬃces f nαcid4 1 To end prove induction structure Cn values variables ψnα γ equal output values corre sponding nodes Cn αcid4 β β values nondeterministic inputs γ inputs including nondeterministic ones immediate deﬁnition gates claim easily follows conjuncts ψn Then second conjunct γCn 1 Cnαcid4 β 1 f nαcid4 1 cid2 The second step reduction encode satisﬁability ψnα g means CQ answering problem OWL 2 QL The CNF ψnh g contains d 3Cn 1 clauses C1 Cd n variables h1 hn m Cn variables g1 gm Recall g1 gn correspond inputs C1 Cn clauses form gi hi We binary predicate P x y unary predicates A0x Aix X 0 x X 1 x variable gi Z 0 jx Zm jx clause C j ψnh g P y x X cid11 cid2 x cid2 x Ai1x y cid2 Consider OWL 2 QLontology Σ f n following tgds 1 m 1 j d cid11 0 1 cid2 x cid3 x Aix X cid11 cid2 cid3 x Z jx x X 0 cid2 cid3 x x Z jx X 1 It hard check Σ f n O Cn2 chase Σ f n ﬁnite data Consider following treeshaped Boolean CQ gi C j gi C j P x y Z i1 j y Z jx y y cid3cid3 cid3cid3 cid2 cid8 q f n yz A0 y0 cid9 mcid7 i1 dcid7 P yi yi1 P ym zm1 j m1cid7 i1 j1 cid10cid11 P zi j zi1 j Z 0 jz0 j y y0 ym z z01 zm11 z0d zm1d It clear q f n O Cn2 For α α1 αn 0 1n data instance cid14 cid14 1 n αi 1 cid13 A0a Z 0ia Dα cid12 cid13 cid12 We explain intuition Σ f n q f n Dα example Fig 3 chase CΣ f n Dα Σ f n Dα depicted particular f n α To answer q f n Σ f n Dα check q f n homomorphically mapped CΣ f n Dα The variables yi clearly mapped main branches model point A3 leftmost corresponds valuation variables g ψnα g making false Consider example variables z23 z13 z03 correspond clause C3 g1 g3 ψnα g Since Z 03a Dα order map z23 z13 z03 choose literals g1 g3 true assignment z23 z13 z03 sent points respective hanging branch resulting z03 cid11cid22 On hand possible ways depending α1 mapping variables z21 z11 z01 clause C1 g1 h ψnα g 1 If α1 0 C1 ψnα g equivalent g1 Z 01a Dα able send z21 z11 z01 points hanging branch resulting z01 cid11cid22 2 If α1 1 clause C1 true Z 01a Dα z21 z11 z01 sent branch A2 A0 z01 cid22 Thus arrive following Lemma 7 For family Boolean functions f n NP α 0 1n Σ f n Dα cid10 q f n ψnα g satisﬁable Proof Consider homomorphism h q f n chase CΣ f n Dα Σ f n Dα Clearly h y0 Aih yi P h yi h yi1 CΣ f n Dα 1 m So variable gi g set γi 1 X 1 h yi CΣ f n Dα γi 0 case X 0 h yi CΣ f n Dα We claim ψnα γ 1 Take clause C j ψnα g consider cases hz0 j If hz0 j 1 j n Z 0 ja Dα α j 1 clause C j g j h j true Otherwise hz0 j cid11 means Z jh yi CΣ f n Dα 1 m clause C j contains gi X 1 h yi CΣ f n Dα The claim follows h yi CΣ f n Dα gi X 0 Suppose ψnα γ 1 γ 0 1m We construct homomorphism h q f n chase CΣ f n Dα Σ f n Dα Observe CΣ f n Dα contains path u0 um u0 um P ui ui1 CΣ f n Dα 50 G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 Fig 3 The chase CΣ f n Dα CQ q f n α 1 function f n input nondeterministic input gate Thus n 1 m 3 d 5 ψnh g1 g2 g3 g1 h g3 g1 g3 g2 g3 g1 g2 g3 Only groups hanging Z j branches shown CΣ f n Dα j 1 j 3 C1 g1 h C3 g1 g3 ui CΣ f n Dα 1 m path corresponds γ following sense X 1 So 0 m set h yi ui For 1 j d deﬁne hzm1 j hz0 j recursively starting hzm1 j assuming zm j ym let hzi j ui Z i1 jhzi1 j CΣ f n Dα let hzi j labelled null chosen y applying xZ i1 jx y P x y Z jx hzi1 j It easy check h homomorphism q f n CΣ f n Dα cid2 ui CΣ f n Dα γi 1 X 0 We use reduction close correspondence PErewritings monotone Boolean formulas FOrewritings necessarily monotone Boolean formulas NDLrewritings monotone Boolean circuits Lemma 8 Suppose f 1 f 2 family monotone Boolean functions NP If q cid4 f n FOrewriting q f n Σ f n Boolean formula ϕn computing f n ϕn q cid4 f n PErewriting q f n Σ f n monotone Boolean formula ϕn computing f n ϕn q ii If q iii If Π f n G NDLrewriting q f n Σ f n monotone Boolean circuit Bn computing f n Bn Π f n cid4 f n cid4 f n Proof By Lemmas 6 7 FOrewriting q cid4 f n q f n Σ f n Dα cid10 q cid4 f n f nα 1 α 0 1n cid4 Since cid3Dα singleton remove quantiﬁers replace individual variables q f n The cid4 resulting Boolean FOquery q f n Then observe ground atoms A0a Z 0 ja 1 j n false Dα replace A0a cid23 cid4cid4 atoms different A0a Z 0 ja 1 j n affecting truthvalue q f n Dα The resulting quantiﬁerfree query regarded Boolean formula ϕn propositional variables Z 01a Z 0na But ϕnα f nα α 0 1n ϕn computes f n Clearly ϕn q cid4cid4 f n truthvalue Dα q ii In way transform PErewriting q cid4 f n q f n Σ f n monotone Boolean formula ϕn connectives propositional variables Z 01a Z 0na ϕn computes f n ϕn q cid4 f n iii Suppose Π f n G NDLrewriting q f n Σ f n α 0 1n Again cid3Dα singleton variable head clause occurs body Π f n contain constants q f n replace individual variables Π f n resulting NDLquery Π cid4 f n G truthvalue Dα Π f n G Then Π cid4 f n remove A0a true remove clauses containing atoms different A0a Z 0 ja 1 j n atoms false Dα occur heads clauses Denote resulting propositional NDLprogram Π cid4cid4 f n Dα cid10 G f nα 1 We regard Π cid4cid4 f n G NDLquery Z 01a Z 0na propositional variables heads clauses arguments propositional variables Such program Π cid4cid4 f n transformed f n It follows Π cid4cid4 cid4 f n G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 51 monotone Boolean circuit computing f n propositional variable p occurring head clause Π cid4cid4 f n introduce gate output p inputs bodies clauses head p body introduce cascade gates inputs propositional variables body The resulting monotone Boolean circuit inputs Z 01a Z 0na output G denoted Bn Clearly Bn Π f n cid2 We position prove avoid exponential blowup PE NDLrewritings FOrewritings blowup superpolynomially assumption NP cid11 Ppoly This function Cliquemk mm 12 variables ei j 1 j m returns 1 graph vertices 1 m edges j ei j 1 contains kclique One Boolean circuit m nondetermin istic inputs O m2 gates computes Cliquemk As Cliquemk NPcomplete question Cliquemk computed polynomialsize circuits nondeterministic inputs equivalent open NP Ppoly problem Further series papers started Razborov 50 gave exponential lower bound size monotone circuits 4 m log m23 2 For monotone formulas better lower bound known computing Cliquemk 2Ω 2Ωk k 2m3 49 k k 1 Theorem 9 There sequence CQs qn size O n OWL 2 QLontologies Σn size O n PErewritings qn Σn size 2Ωn14 ii NDLrewritings qn Σn size 2Ωnlog n112 iii polynomialsize FOrewritings qn Σn NP Ppoly PH Σ p 2 Proof Consider family Boolean functions f n Cliquemk m cid25n14cid26 k cid252m3cid26 Ωn14 As size q f n Σn Σ f n O n So claim follows circuits Cn nondeterministic inputs O m2 size qn Lemma 8 ii lower bound size monotone formulas computing Cliquemk Then family f n redeﬁne elements f n n f n Cliquemk m k cid25m log m23cid26 Ωn log n16 Claim ii follows Lemma 8 iii lower bound size monotone circuits computing Cliquemk If assume NP cid3 Ppoly polynomialsize circuit Cliquemk iii follows constructed f n Lemma 8 cid2 Using similar argument prove following Theorem 10 Suppose f 1 f 2 NPcomplete family monotone Boolean functions If NP cid11 Ppoly q f n Σ f n polynomialsize FO NDLrewritings Proof Suppose contrary polynomialsize FO NDLrewritings q f n Σ f n Then Lemma 8 iii family polynomialsize circuits computing f 1 f 2 Since family f n NPcomplete follows families Boolean functions NP computed polynomialsize circuits NP Ppoly cid2 The construction section reveals overhead CQ answering OWL 2 QLontologies compared CQ swering plain databases complexitytheoretic terms Indeed Boolean CQs q f n treeshaped problem Dα cid10 q f n P combined complexity 60 problem Σ f n Dα cid10 q f n NPhard On hand problems AC0 data complexity We observe quantiﬁer elimination proof Lemma 8 relies fact cid3Dα 1 As shall sections restrict attention data instances individuals Theorem 9 hold longer 4 Polynomial rewritings constants To prove exponential superpolynomial lower bounds size rewritings previous section estab lished connection monotone circuits Boolean functions rewritings certain CQs OWL 2 QLontologies In fact connection suggests way making rewritings substantially shorter Indeed recall Section 3 family monotone Boolean circuits polynomial size compute Cliquemk exists family polynomialsize circuits nondeterministic inputs computing Cliquemk Nondeterministic inputs Boolean circuits exponentially succinctin way nondeterministic automata exponentially succinct deter ministic ones 42 To introduce corresponding nondeterministic guesses query rewritings use additional existentially quantiﬁed variablesprovided domain quantiﬁcation contains elements cf 5 For purpose extend signature PE FO NDLrewritings set X constant symbols assuming occur relevant data instance case talking PE X FO X NDL X rewritings In section allowing additional constants rewritings makes exponentially succinct 52 G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 We family ontologies polynomial witness property PWP short polynomial dm n ontology Σ family CQ qx data instance D Σ D cid10 qa tuple cid3D sequence dq Σ applications tgds Σ D entails qa sense homomorphism qa set atoms generated tgd applications Clearly PWP implies BDDP way round The following examples ontology languages PWP linear tgds predicates bounded arity 26 particular OWL 2 QL 16 sticky sets tgds predicates bounded arity 23 note degree polynomial depends maximum arity predicates Theorem 11 Let qx CQ Σ ontology family PWP There PE01rewriting q Σ size polynomial q Σ ii There NDL01rewriting q Σ size polynomial q Σ Proof Without loss generality assume predicates Σ q arity L tgds Σ precisely m atoms body atom head head contains existentially quantiﬁed variable In words tgds form cid2 x cid3 P 1t1 P mtm z P 0t 0 7 term t ti1 tiL 1 m universally quantiﬁed variable x constant term t0 t01 t0L belongs x case universally quantiﬁed constant coincides z case existentially quantiﬁed To simplify notation assume q Boolean CQ q y Mcid7 k1 Rk yk1 ykL We assume Σ contains negative constraints reduction general case 11 In view PWP number dq Σ polynomial q Σ data instance D Σ D cid10 q sequence dq Σ applications tgds Σ D entails q Let N m 1 dq Σ Denote μ maxK M N S K number predicates q Σ S number tgds Σ Let Q set natural numbers 0 μ F irst PEQ rewriting q q Σ assuming constants Q occur predicate data instances interpreted distinct elements model equality builtin predicate Then rewriting transformed proper PE01rewriting condition 0 1 apart occur relevant data instances cid4 In essence PEQ rewriting guesses sequence N ground atoms A1 A N checks atoms positive answer q sequence obtained series applications tgds Σ D data atoms required applications Ai To encode atoms A1 A N associate predicate P unique number denoted P Ai represented number predicate values arguments range domain cid3D D labelled nulls nulli 1 N labelled nulls numbers Q use notation readability Thus atom Ai sequence 1 N need following variables ri number predicate Ai ui1 uiL arguments Ai w i1 w icid11 cid11 maximum number universally quantiﬁed variables x tgds cid11 m L arguments predicates body tgd obtain Ai Note ri range Q ui j w il range domain cid3D labelled nulls cid3D Q The PEQ rewriting q Σ deﬁned taking cid9 Mcid7 Γk k1 Ncid7 i1 cid10 Φi cid4 yurw q The ﬁrst conjunct q cid4 Γk Ncid15 i1 cid8 cid2 cid3 ri Rk Lcid7 j1 cid11 ui j ykj chooses atom query match A1 A N G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 53 The second conjunct guesses ground atom A1 A N taken data instance obtained tgd application Φi cid15 cid2cid2 cid3 ri P cid3 P ui1 uiL cid15 cid8 cid2 cid3 ri P 0 P predicate q Σ cid7 ui j cid7 cid7 ui j w il ui j nulli t0 j t0 j xl t0 j z cid11 Ψτ ik mcid7 k1 τ xP 1t1Pmtmz P 0t0Σ The ﬁrst group disjuncts case Ai taken data instance ri P ui1 uiL appears data instance predicate P number ri The second group disjuncts models chase rule application tgd τ Σ Informally Ai obtained application τ ri number P 0 head predicate P 0 existential variable z head gets unique labelled null value nulli fourth conjunct Then conjunct m atoms body choose number predicate Aicid4 predicate body atom arguments match cid4 Ψτ ik cid16 i1cid15 icid41 cid2 cid3 ricid4 P k cid7 tkj xl uicid4 j w il cid17 uicid4 j cid7 tkj variables w il ensure universally quantiﬁed variable τ gets value body atoms head occurs second conjunct group Φi We assume disjunction Ψτ 1k τ k cid4 O q Σ N 2 L Σ D cid10 q true model D extended constants Q distinct belong constructed polynomial time q cid4 It hard check q cid4 q interpretation predicate We replace natural numbers Q distinct constants 0 1 provided present data instance obtaining polynomial PE01rewriting q Σ Recall variables ui j ranges domain cid3D numbers Q precisely labelled nulls null1 nullN Thus variable ui j modelled means tuple ˆui j u j p cid28log Q cid29 range 0 1 represent natural number 0 μ binary More precisely ui j value j zeros ui j labelled null nullk ˆui j d cid3D ˆui j interpreted d u j represent k binary note 0 labelled null Similarly model w il ﬁxed value 0 u cid4 ri simpler model ˆri component The equality atoms rewriting q replaced componentwise equalities P ui1 uiL replaced P ˆui1 ˆuiL 0 j variables ˆui j ranges domain cid3D u j u0 j u0 j u0 j u0 cid18 cid18 p p p p p L j1 k0uk j ii We construct polynomialsize NDLQ rewriting Π G q Σ Its transformation NDL01rewriting similarly PEQ rewritings The program Π main rule similar query q uses disjunction allowed datalog rule The elimination disjunction exponential blowup small arity predicates based equivalence previous construction However q cid4 cid4 cid15 cid15 cid7 ρi v cid2 v ρi cid3 8 iΥ iΥ iΥ Υ Q To end Π uses additional rules intensional predicates OneOf x y z hold x natural number Q interval y z predicate replace disjunction v 8 OneOf j k 0 j k μ Domz hold z appears data instance D labelled nulls nullk Dom y j P y1 y L Domnullk predicates P q Σ 1 j L 1 k N If x1 x2 z1 z2 hold x1 x2 z1 z2 true x1 x2 natural numbers Q predicate replace implication 8 If z z Domz If j z1 z2 Domz1 Domz2 0 μ 0 cid11 j μ IfAndx1 x2 y1 y2 z1 z2 hold x1 x2 y1 y2 z1 z2 true x1 x2 y1 y2 natural numbers Q rules IfAnd similar If 54 G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 DBx z y hold x 0 z number P predicate P q Σ P y D cid2 cid3 DB 0 P y P y predicates P q Σ Now construction main rule Π mimics q cid4 G Mcid7 k1 Γk Ncid7 i1 Φi G 0ary goal predicate The components Γk Φi deﬁned follows In deﬁnitions use quantiﬁed variables y u r w intended meaning previous construction meaning additional quantiﬁed variables explained For 1 k M let cid9 Γk OneOf sk 1 N Ncid7 i1 cid2 cid3 sk ri Rk If Lcid7 j1 cid10 If sk ui j ykj sk fresh variable meant number atom Ai Rk yk1 ykL mapped variable sk encodes choice disjunct Γk previous construction cf 8 For 1 N let Φi OneOf v 0 K DBv ri ui1 uiL cid7 cid9 cid2 cid3 v τ ri P 0 If cid7 cid2 If t0 j v τ ui j cid7 cid3 cid2 If t0 j xl τ xP 1t1Pmtmz P 0t0Σ cid2 cid7 cid3 v τ ui j w il v τ ui j nulli If t0 j z cid10 Ψτ ik mcid7 cid3 k1 v meant number τ tgd 1 τ S derives atom Ai 0 Ai data instance second conjunct accounts case Ai atom data instance group conjuncts case Ai obtained application tgd Σ Finally 1 Ψτ ik OneOf pik 1 1 cid2 IfAnd v τ pik cid4 cid3 ricid4 P k cid16 i1cid7 icid41 cid7 cid2 IfAnd tkj xl v τ pik cid4 uicid4 j w il cid7 cid3 cid2 IfAnd tkj v τ pik cid4 uicid4 j cid17 cid3 1 N 1 k m pik meant number ith chase step We Ψτ 1k OneOf v 1 0 0 ensures v 1 0 cid4 It straightforward verify Π G equivalent q cid4 establishing ii cid2 chase step derives kth atom As sets linear tgds bounded arity sets sticky tgds bounded arity enjoy PWP obtain Corollary 12 Any CQ set linear tgds bounded arity particular OWL 2 QLontology polynomialsize PE01 NDL01rewritings Any CQ set sticky tgds bounded arity polynomialsize PE01 NDL01rewritings The following result immediate consequence proof Theorem 11 shall use prove Lemma 15 section Corollary 13 Let qx CQ Σ ontology family PWP There polynomialsize PEformula γ x y0 y1 γ x 0 1 PE01rewriting q Σ ii There polynomialsize NDLquery Π Gx y0 y1 Π Gx 0 1 NDL01rewriting q Σ By taking formula y0 y1 y0 cid11 y1 γ x y0 y1 γ given Corollary 13 obtain following result polynomial FOrewritability databases individuals Corollary 14 For CQ qx ontology Σ family PWP FOformula q polynomial q Σ Σ D cid10 qa D cid10 q elements cid3D cid4x size cid4a data instance D cid3D 2 tuple G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 55 Note compact representation FOrewriting corollary achievedcompared FOrewritings CQs OWL 2 QLontologies known farwith help polynomiallymany new existentially quantiﬁed variables guessing derivation given CQ chase 5 Separation results In section consider pure rewritings additional constants prove separation results saying NDLrewritings exponentially succinct PErewritings FOrewritings superpolynomi ally succinct PErewritings To end need construction transforming Boolean formulas circuits rewritings Consider family f 1 f 2 monotone Boolean functions NP corresponding family C1 C2 polynomial size Boolean circuits nondeterministic inputs Recall Section 3 constructed family ψn CNFs encoding Cn The CNF ψn contains d 3Cn 1 clauses m Cn Boolean variables transformed set Σ f n OWL 2 QLtgds Boolean CQ q f n Σ f n Dα cid10 q f n f nα 1 α 0 1n Consider OWL 2 QLontology Σ f n extends Σ f n negative constraints cid2 x cid3 A0x Bx Bx Θ Θ set comprising following formulas y P x y Aix X 0 Z jx x X 1 x 1 m 0 m 1 j d j cid12 cid13 0 1 0 n We observe Σ query q f n ontology Σ f n Σ negative constraints f n O Cn2 claims Lemma 8 equally applicable Σ f n proof requires f n correct answers data Dα deﬁnition consistent Lemma 15 Let f 1 f 2 family monotone Boolean functions NP C1 C2 corresponding family polynomialsize Boolean circuits nondeterministic inputs If f n computed Boolean formulas ϕn polynomial p FOrewritings q cid4 f n q f n Σ f n ii If f n computed monotone Boolean circuits Bn polynomial p NDLrewritings Π f n G q f n q cid4 f n ϕn pCn Σ f n Π f n 2Bn pCn Proof Let γn0 1 polynomialsize PE01rewriting q f n Σ f n given Corollary 13 We denote ϕnx result replacing propositional variable p j ϕn atom Z 0 jx 1 j n consider FOquery cid19 cid4 f n x q cid16 A0x ϕnx y cid2 cid3 P y x γnx y cid15 cid17cid20 Bx BxΘ Suppose Σ f n D cid10 q f n If Σ Clearly q PE01rewriting turn polynomial size It remains q cid4 f n ϕn pCn polynomial p note size q f n Σ f n quadratic Cn f n FOrewriting q f n Σ f n f n D inconsistent negative constraints Σ f n case cid3D Bx Θ D cid10 A0a Ba D cid10 q f n D coincides chase Σ f n D homomorphism h q f n chase Σ f n D Let h y0 a0 cid3D recall y0 root query q f n Clearly Aa0 D Two cases possible If a1 cid3D a0 cid4 P a1 a0 D γn0 1 PE01rewriting q f n Σ f n obtain D cid10 γna0 a1 D cid10 q f n Otherwise f n Otherwise chase Σ cid4 cid4 56 G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 D cid11cid10 y P y a0 Z ja0 D 0 1 j n Consider α deﬁned taking α j 1 iff Z 0 ja0 D 1 j n We obtain Σ f n Dα cid10 q f n Lemma 7 f nα 1 So Dα cid10 ϕna0 D cid10 q cid4 f n Then a0 cid3D A0a0 D If disjunct q Conversely suppose D cid10 q f n D inconsistent Σ f n D cid10 q f n So assume disjunct hold cid3D A0a0 D Σ f n D consistent chase coincides chase Σ f n D Two cases possible If second disjunct holds a1 cid3D a0 P a1 a0 D note a0 a1 P a0 a0 D Σ f n D inconsistent contrary assumption Then γn0 1 PE01rewriting q f n Σ f n obtain Σ f n D cid10 q f n Otherwise ﬁrst disjunct ϕnx holds a0 D cid11cid10 y P y a0 Z ja0 D 0 1 j n Consider α deﬁned taking α j 1 iff Z 0 ja0 D 1 j n As ϕn computes f n f nα 1 Lemma 7 Σ f n D cid10 q f n In case Σ cid4 f n f n holds a0 Σ f n D cid10 q f n cid4 ii L etΦn F 0 1 polynomialsize NDL01rewriting q f n Σ f n given Corollary 13 ii We denote Ξn NDLprogram built Bn replacing input respective unary predicate atom Z 0 jx 1 j n More precisely gate gi inputs gicid4 gicid4cid4 monotone Boolean circuit Bn unary predicate Q ix include following rules Ξn Q ix Q icid4 x Q icid4cid4 x gi gicid4 gicid4cid4 Q ix Q icid4 x Q ix Q icid4cid4 x gi gicid4 gicid4cid4 gicid4 jth input Bn Q icid4 x denotes Z 0 jx similarly gicid4cid4 Consider NDLquery Π f n G goal G fresh 0ary predicate Π f n comprises rules Φn Ξn following rules G A0x Q Bnx G A0x P y x F x y G A0x Bx Bx Θ recall Q Bn corresponds output gate Bn Clearly Π f n 2Bn pCn polynomial p note size q f n Σ f n quadratic Cn NDL01rewriting turn polynomial size We claim Π f n G NDLrewriting q f n Σ f n proof case cid2 We position NDLrewritings exponentially succinct PErewritings To m3 m3 variables xi jk 1 j k m deﬁned follows We 1 generates end use Boolean function Gen k m k 1 xi jk 1 j 1 generates j Gen m3 x111 xmmm returns 1 1 generates m This monotone function known Path System Accessibility 22 computable polynomialsize monotone circuits 58 On hand monotone formula computing Gen ε 0 48 m3 size 2mε Theorem 16 There sequence CQs qn size O n OWL 2 QLontologies Σn size O n polynomialsize NDL rewritings PErewritings qn Σn size 2nε ε 0 Proof It known Gen m3 computed monotone Boolean circuits size pm polynomial p So n choose suitable m Θnδ ﬁxed δ 0 family functions f n Gen m3 gives rise f n size O n By Lemma 15 ii NDLrewritings qn Σn queries qn size polynomial n However Lemma 8 ii PErewritings qn Σn size 2mε0 ε0 0 Then ε 0 PErewritings qn Σn size 2nε q f n OWL 2 QLontologies Σn Σ cid2 FOrewritings substantially shorter PErewritings To need function Matching2m m2 variables ei j 1 j m returns 1 perfect matching bipartite graph G m vertices contains edge j ei j 1 returns 1 subset E edges G ev ery node G occurs exactly E It hard Matching2m computed Boolean circuit m2 nondeterministic inputs O m2 gates On hand monotone Boolean formulas computing Matching2m ex ponential 2Ωm 49 nonmonotone Boolean formulas computing function having size m O log m 10 So use standard padding trick circuit complexity 3 p 57 FOrewritings superpoly nomially succinct PErewritings Theorem 17 There sequence CQs qn size O n OWL 2 QLontologies Σn size O n polynomialsize FO rewritings PErewritings qn Σn size 2Ω2log12 n Proof We deﬁne f n slightly modiﬁed Matching2m m cid252log12 ncid26 f n maxcid25n14cid26 m2 variables m2 proper variables Matching2m rest dummy variables padding note G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 57 cid25n14cid26 m2 suﬃciently large n Using Lemma 15 observing m O log m n O 1 obtain polyno mial upper bound size FOrewritings The required superpolynomial lower bound PErewritings follows Lemma 8 ii cid2 Unfortunately separation results FO NDLrewritings known moment As follows connec tion rewritings computation models monotone Boolean functions established article results imply corresponding separation results formulas monotone circuits giving solutions major open problems Boolean circuit complexity 29 6 Conclusions We shown article FOrewritability conjunctive queries OWL 2 QLontologies mean database systems evaluate rewritings eﬃciently usually standard SQL queries Indeed rewritings prohibitively large andor complex compared user queries We seen size rewritings depends logical nonlogical means want allowed use These results clearly indicate theoretical experimental research needed OBDA paradigm successful Here brieﬂy outline important directions future research related article On theoretical hand obviously need conditions ensuring eﬃcient OBDA ﬁrst promising steps having For example suﬃcient semanticbased condition CQs OWL 2 QLontologies guarantees polynomial PErewritability obtained 33 It demonstrated 3031 exist polynomialsize NDLrewritings CQs OWL 2 QLontologies depth 1 chases contain labelled nulls involved relation polynomialsize PErewritings treeshaped CQs arbi trary ones For treeshaped Boolean CQs q problem Σ D cid10 q turns ﬁxedparameter tractable parameter q 31 Moreover treeshaped CQ OWL 2 QL ontology polynomiallymany treewitnesses polynomialsize NDLrewriting 8 A kind preservation result obtained 8 CQs class evaluated polynomial time plain databases answering CQs class OWL 2 QLontologies role inclusion axioms tgds form x y P x y Rx y tractable polynomialtime NDL rewriting algorithm given acyclic CQs These initial results open way comprehensive description classes queries ontologies polynomial rewritability To fully understand complexity OBDA OWL 2 QLontologies plan investigate size rewritings ﬁxed ontology size rewritings treeshaped CQs ontologies bounded depth On practical hand study structure queries ontologies typically OBDA systems The recent experiments 203546545251 indicate rewritings available realworld CQs ontologies acceptable size optimised techniques However ontologies experiments suﬃciently representative It interesting evaluate performance database systems rewritings additional quantiﬁers special constants encode nondeterministic guesses compact way Section 4 rewriting 33 employs single special constant guess existentially quantiﬁed variable query matched cid3D labelled nulls Additional constants combined approach OBDA 403739 represent labelled nulls database Acknowledgements This research partially funded EPSRC joint grants EPH051511 EPH05099X ExODA Integrating Description Logics Database Technologies Expressive OntologyBased Data Access Russian Foundation Basic Research programme Leading Scientiﬁc Schools References 1 S Abiteboul R Hull V Vianu Foundations Databases AddisonWesley 1995 2 N Alon R Boppana The monotone circuit complexity Boolean functions Combinatorica 7 1 1987 122 3 S Arora B Barak Computational Complexity A Modern Approach 1st Ed Cambridge University Press New York NY USA 2009 4 A Artale D Calvanese R Kontchakov M Zakharyaschev The DLLite family relations J Artif Intell Res 36 2009 169 5 J Avigad Eliminating deﬁnitions Skolem functions ﬁrstorder logic ACM Trans Comput Log 4 3 2003 402415 6 JF Baget M Leclère ML Mugnier E Salvat Extending decidable cases rules existential variables Proc 21st Int Joint Conf Artiﬁcial Intelligence IJCAI 2009 IJCAI 2009 pp 677682 7 JF Baget M Leclère ML Mugnier E Salvat On rules existential variables walking decidability line Artif Intell 175 910 2011 16201654 8 M Bienvenu M Ortiz M Simkus G Xiao Tractable queries lightweight description logics Proc 23rd Int Joint Conf Artiﬁcial Intelligence IJCAI 2013 AAAI PressIJCAI 2013 pp 768774 9 M Bienvenu B Cate C Lutz F Wolter Ontologybased data access study disjunctive datalog CSP MMSNP Proc 32nd ACM SIGMODSIGACTSIGART Symposium Principles Database Systems PODS 2013 ACM 2013 pp 213224 10 A Borodin J von zur Gathen JE Hopcroft Fast parallel matrix gcd computations Proc 23rd Annual Symposium Foundations Computer Science FOCS82 IEEE Computer Society 1982 pp 6571 11 A Calì G Gottlob T Lukasiewicz A general datalogbased framework tractable query answering ontologies J Web Semant 14 2012 5783 58 G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 12 A Calì G Gottlob A Pieris Advanced processing ontological queries Proc VLDB Endow 3 1 2010 554565 13 A Calì G Gottlob A Pieris Towards expressive ontology languages query answering problem Artif Intell 193 2012 87128 14 D Calvanese G De Giacomo D Lembo M Lenzerini R Rosati DLLite tractable description logics ontologies Proc 20th Nat Conf Artiﬁcial Intelligence AAAI 2005 AAAI Press 2005 pp 602607 15 D Calvanese G De Giacomo D Lembo M Lenzerini R Rosati Data complexity query answering description logics Proc 10th Int Conf Principles Knowledge Representation Reasoning KR 2006 AAAI Press 2006 pp 260270 16 D Calvanese G De Giacomo D Lembo M Lenzerini R Rosati Tractable reasoning eﬃcient query answering description logics DLLite family J Autom Reason 39 3 2007 385429 17 C Chekuri A Rajaraman Conjunctive query containment revisited Theor Comput Sci 239 2 2000 211229 18 A Chortaras D Trivela G Stamou Optimized query rewriting OWL 2 QL Proc 23rd Int Conf Automated Deduction CADE23 Lecture Notes Computer Science vol 6803 Springer 2011 pp 192206 19 J Dolby A Fokoue A Kalyanpur L Ma E Schonberg K Srinivas X Sun Scalable grounded conjunctive query evaluation large expres sive knowledge bases Proc 7th Int Semantic Web Conf ISWC 2008 Lecture Notes Computer Science vol 5318 Springer 2008 pp 403418 20 T Eiter M Ortiz M Šimkus TK Tran G Xiao Query rewriting HornSHIQ plus rules Proc 26th AAAI Conf Artiﬁcial Intelligence AAAI 2012 AAAI Press 2012 21 J Flum M Grohe Parameterized Complexity Theory Texts Theoretical Computer Science An EATCS Series Springer 2006 22 M Garey D Johnson Computers Intractability A Guide Theory NPCompleteness W H Freeman Co New York NY USA 1979 23 G Gottlob M Manna A Pieris Polynomial combined rewritings existential rules Proc 14th Int Conf Principles Knowledge Representation Reasoning KR 2014 AAAI Press 2014 24 G Gottlob G Orsi A Pieris Query rewriting optimization ontological databases arXiv14052848 csDB 12 May 2014 25 G Gottlob G Orsi A Pieris Ontological queries rewriting optimization Proc 27th Int Conf Data Engineering ICDE 2011 IEEE Computer Society 2011 pp 213 26 G Gottlob T Schwentick Rewriting ontological queries small nonrecursive datalog programs Proc 13th Int Conf Principles Knowledge Representation Reasoning KR 2012 AAAI Press 2012 pp 254263 27 M Grohe T Schwentick L Segouﬁn When evaluation conjunctive queries tractable Proc 33rd ACM SIGACT Symposium Theory Computing STOC01 ACM 2001 pp 657666 28 S Heymans L Ma D Anicic Z Ma N Steinmetz Y Pan J Mei A Fokoue A Kalyanpur A Kershenbaum E Schonberg K Srinivas C Feier G Hench B Wetzstein U Keller Ontology reasoning large data repositories Ontology Management Semantic Web Semantic Web Services Business Applications Semantic Web Beyond vol 7 Springer 2008 pp 89128 29 S Jukna Boolean Function Complexity Advances Frontiers Springer 2012 30 S Kikot R Kontchakov V Podolskii M Zakharyaschev Query rewriting shallow ontologies Proc 26th Int Workshop Description Logics DL 2013 vol 1014 CEURWS 2013 pp 316327 31 S Kikot R Kontchakov V Podolskii M Zakharyaschev On succinctness query rewriting OWL 2 QL ontologies shallow chases CoRR arXiv14014420 abs 2014 32 S Kikot R Kontchakov VV Podolskii M Zakharyaschev Exponential lower bounds separation query rewriting Proc 39th Int Collo quium Automata Languages Programming Part II ICALP 2012 Lecture Notes Computer Science vol 7392 Springer 2012 pp 263274 33 S Kikot R Kontchakov M Zakharyaschev Conjunctive query answering OWL 2 QL Proc 13th Int Conf Principles Knowledge Representation Reasoning KR 2012 AAAI Press 2012 pp 275285 34 PG Kolaitis MY Vardi Conjunctivequery containment constraint satisfaction Proc 17th ACM SIGACTSIGMODSIGART Symposium Principles Database Systems PODS98 ACM Press 1998 pp 205213 35 M König M Leclère ML Mugnier M Thomazo A sound complete backward chaining algorithm existential rules Proc 6th Int Conf Web Reasoning Rule Systems RR 2012 Lecture Notes Computer Science vol 7497 Springer 2012 pp 122138 36 M König M Leclère ML Mugnier M Thomazo On exploration query rewriting space existential rules Proc 7th Int Conf Web Reasoning Rule Systems RR 2013 Lecture Notes Computer Science vol 7994 Springer 2013 pp 123137 37 R Kontchakov C Lutz D Toman F Wolter M Zakharyaschev The combined approach query answering DLLite Proc 10th Int Conf Principles Knowledge Representation Reasoning KR 2010 AAAI Press 2010 38 R Kontchakov C Lutz D Toman F Wolter M Zakharyaschev The combined approach ontologybased data access Proc 22nd Int Joint Conf Artiﬁcial Intelligence IJCAI 2011 AAAI Press 2011 pp 26562661 39 C Lutz I Seylan D Toman F Wolter The combined approach OBDA taming role hierarchies ﬁlters Proc 12th Int Semantic Web Conf ISWC 2013 Lecture Notes Computer Science vol 8218 Springer 2013 pp 314330 40 C Lutz D Toman F Wolter Conjunctive query answering description logic EL relational database Proc 21st Int Joint Conf Artiﬁcial Intelligence IJCAI 2009 IJCAI 2009 pp 20702075 41 BJ McMahan G Pan P Porter MY Vardi Projection pushing revisited Proc 9th Int Conf Extending Database Technology EDBT Lecture Notes Computer Science vol 2992 Springer 2004 pp 441458 42 AR Meyer MJ Fischer Economy description automata grammars formal systems Proc 12th Annual Symposium Switching Automata Theory SWATFOCS71 IEEE Computer Society 1971 pp 188191 43 G Orsi A Pieris Optimizing query answering ontological constraints Proc VLDB Endow 4 11 2011 10041015 44 M Ortiz S Rudolph M Simkus Query answering Horn fragments description logics SHOIQ SROIQ Proc 22nd Int Joint Conf Artiﬁcial Intelligence IJCAI 2011 IJCAIAAAI 2011 pp 10391044 45 H PérezUrbina B Motik I Horrocks A comparison query rewriting techniques DLLite Proc 22nd Int Workshop Description Logics DL 2009 vol 477 CEURWS 2009 46 H PérezUrbina E RodríguezDíaz M Grove G Konstantinidis E Sirin Evaluation query rewriting approaches OWL 2 Proc SSWSHPCSW 2012 vol 943 CEURWS 2012 47 A Poggi D Lembo D Calvanese G De Giacomo M Lenzerini R Rosati Linking data ontologies J Data Semant X 2008 133173 48 R Raz P McKenzie Separation monotone NC hierarchy Proc 38th Annual Symposium Foundations Computer Science FOCS97 IEEE Computer Society 1997 pp 234243 49 R Raz A Wigderson Monotone circuits matching require linear depth J ACM 39 3 1992 736744 50 A Razborov Lower bounds monotone complexity Boolean functions Dokl Akad Nauk SSSR 281 4 1985 798801 51 M RodríguezMuro R Kontchakov M Zakharyaschev Ontologybased data access ontop databases Proc 12th Int Semantic Web Conf ISWC 2013 Lecture Notes Computer Science vol 8218 Springer 2013 pp 558573 52 M RodríguezMuro R Kontchakov M Zakharyaschev Ontop work Proc 10th Int Workshop OWL Experiences Directions OWLED 2013 vol 1080 CEURWS 2013 53 R Rosati On conjunctive query answering EL Proc 2007 Int Workshop Description Logics DL 2007 vol 250 CEURWS 2007 G Gottlob et al Artiﬁcial Intelligence 213 2014 4259 59 54 R Rosati Prexto query rewriting extensional constraints DLLite Proc 9th Extended Semantic Web Conf EWSC 2012 Lecture Notes Computer Science vol 7295 Springer 2012 pp 360374 55 R Rosati A Almatelli Improving query answering DLLite ontologies Proc 10th Int Conf Principles Knowledge Representation Reasoning KR 2010 AAAI Press 2010 pp 290300 56 B Rossman Homomorphism preservation theorems J ACM 55 2008 3 57 E Salvat ML Mugnier Sound complete forward backward chaining graph rules Proc 4th Int Conf Conceptual Structures ICCS96 Lecture Notes Computer Science vol 1115 Springer 1996 pp 248262 58 IA Stewart Logical description monotone NP problems J Log Comput 4 4 1994 337357 59 G Tseitin On complexity derivation propositional calculus Automation Reasoning 2 Classical Papers Computational Logic 19671970 Springer 1983 pp 466483 60 M Yannakakis Algorithms acyclic database schemes Proc 7th Int Conf Very Large Data Bases VLDB81 IEEE Computer Society 1981 pp 8294