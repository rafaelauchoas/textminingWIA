Artiﬁcial Intelligence 173 2009 503535 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Concise ﬁnitedomain representations PDDL planning tasks Malte Helmert Institut für Informatik AlbertLudwigsUniversität Freiburg GeorgesKöhlerAllee 052 79110 Freiburg Germany r t c l e n f o b s t r c t Article history Received 16 November 2007 Received revised form 22 October 2008 Accepted 29 October 2008 Available online 25 November 2008 Keywords Automated planning Problem reformulation PDDL SAS We introduce eﬃcient method translating planning tasks speciﬁed standard PDDL formalism concise grounded representation uses ﬁnitedomain state variables instead straightforward propositional encoding Translation performed stages Firstly transform input task equivalent normal form expressed restricted fragment PDDL Secondly synthesize invariants planning task identify groups mutually exclusive propositions represented single ﬁnitedomain variable Thirdly perform eﬃcient relaxed reachability analysis logic programming techniques obtain grounded representation input Finally combine results fourth stage generate ﬁnal grounded ﬁnitedomain representation The presented approach originally implemented Fast Downward planning 4th International Planning Competition IPC4 Since number contexts considerable success use concise ﬁnitedomain representations common feature stateoftheart planners 2008 Elsevier BV All rights reserved 1 Introduction Consider transportation planning task illustrated Fig 1 There cars train parcels located cities comprising locations The cars network roads respective city origin train moves single railway link connects cities Parcels loaded vehicle present location parcels carried vehicle unloaded current location vehicle time The objective parcel designated goal location 11 PDDL representations In order ﬁnd plan example task generalpurpose planning ﬁrst represent way reason Since inception 1998 38 Planning Domain Deﬁnition Language PDDL defacto standard language representing classical planning tasks The original PDDL formalism ﬁrst International Planning Competitions purely logicbased considered syntactic variant earlier ADL language 39 excluding support functional ﬂuents present ADL Since language extended easily express additional aspects realworld planning tasks numbers durations 21 state variables values derived values state variables 18 recently plan constraints preferences 24 This work partly supported German Research Council DFG Transregional Collaborative Research Center Automatic Veriﬁcation Analysis Complex Systems SFBTR 14 AVACS See wwwavacsorg information Email address helmertinformatikunifreiburgde 00043702 matter 2008 Elsevier BV All rights reserved doi101016jartint200810013 504 M Helmert Artiﬁcial Intelligence 173 2009 503535 Fig 1 A transportation planning task Deliver parcel p1 C G parcel p2 F E cars c1 c2 c3 train t The cars use roads edges train use railway edge In PDDL planning tasks described terms objects world cars locations parcels predicates static dynamic relations hold objects given locations connected road given parcel currently inside given vehicle operators manipulate relations moving car location unloading parcel initial state describes situation plan execution goal speciﬁcation describing objectives solution plans achieve While PDDL restricted ﬁrstorder formalism stateoftheart planning systems compile input speciﬁ cation propositional representation early stage grounding predicates operators goal speciﬁcations Many planners transform grounded task particularly simple syntactic form called propositional STRIPS states world represented sets satisﬁed atomic propositions operators represented terms propositions true operator applicable preconditions propositions op erator makes true add effects propositions makes false delete effects The example task naturally modelled propositional STRIPS representation shown Fig 2 PDDL STRIPSbased representations planning tasks number desirable features Due close rela tionship ﬁrstorder logic ungrounded PDDL propositional logic grounded PDDL semantics easy understand researchers practitioners background formal logics Moreover representing properties world state terms truth values appeal simplicity There certain mathematical elegance formalism clearly achieves language designers maxim describing planning tasks terms physics advice 38 12 Finitedomain representations The absence form advice PDDL representation appropriate language designed general problem solvers comes price paid planning algorithms reason represented task In particular state space induced propositional representation shown Fig 2 unstructured A priori proposition like atp1a stating ﬁrst parcel location A bears closer relationship atp1b stating ﬁrst parcel location B inp2t stating second parcel currently inside train However account intended meaning propositions represent potential locations parcel clearly closely related ones encode properties parcel In particular propositions form atp1x true time feasible world state To planner appear 235 34 1010 feasible world states example task corresponding valuations 35 propositional state variables truth number relevant states 11616 12 104 valuations reachable given initial state An alternative representation example task shown Fig 3 This representation uses general ﬁnitedomain variables binary ones represent state world For example single variable p1 domain 11 values completely encodes state ﬁrst parcel subsuming information propositions atp1x inp1 y STRIPS encoding Using representation set feasible world states coincides set syntactically legal ones In article present eﬃcient algorithm translating planning tasks speciﬁed PDDL 22 compact ﬁnitedomain representation The algorithm implemented Fast Downward planner 29 number planning algorithms 327314849 It extends earlier algorithm Edelkamp Helmert 15 translates PDDL tasks ﬁnitedomain representations limited smaller language fragment STRIPS typing domain constants operator deﬁnitions As far know algorithms problem described literature main contribution article ﬁrst description method generate concise ﬁnitedomain representations arbitrary non M Helmert Artiﬁcial Intelligence 173 2009 503535 505 Fig 2 Propositional STRIPS representation transportation planning task numeric nontemporal PDDL tasks From highlevel perspective approach follows similar ideas algorithm Edelkamp Helmert generalization STRIPS requires signiﬁcant extensions core components translation algorithm invariant synthesis Section 5 grounding Section 6 Indeed emphasis article overall goal transforming PDDL tasks concise ﬁnitedomain representation believe invariant synthesis grounding algorithms present useful planning algorithms work traditional PDDL representations algorithms presented Sections 5 6 seen additional contributions paper 13 Why ﬁnitedomain representations Before diving technical matters let brieﬂy discuss compact ﬁnitedomain representations desirable We noted STRIPS representation unlike ﬁnitedomain representation vastly larger number syntactically valid states feasible reachable states planning task This necessarily problematic example planning algorithm based forward search Hoffmann Nebels FF 33 encounter infeasible states obvious advantage ﬁnitedomain representation However number planning approaches beneﬁt signiﬁcantly changed representation Planning algorithms based SATsolving 3536 use SAT representations disallow exploring partial valuations assign inconsistent values single ﬁnitedomain variable This example general notion mutex constraints critical performance SAT planners 43 A naive SAT encoding need search 506 M Helmert Artiﬁcial Intelligence 173 2009 503535 Fig 3 Finitedomain representation transportation planning task space syntactically valid STRIPS states variable layer In addition use mutexes recently successful MaxPlan planner 7 uses ﬁnitedomain representation derive socalled londex constraints reported key innovation planner Londex constraints need ﬁnitedomain representations effective binary state variables offer additional pruning power mutex constraints Planners perform symbolic exploration state space binary decision diagrams BDDs use ﬁnitedomain representation reduce number variables required BDD encoding compared naive encoding Moreover ﬁnitedomain representation leads variable ordering closely related propositions grouped critical good performance BDD exploration 17 Heuristic planning approaches pattern databases homomorphism abstractions 142731 beneﬁt concise ﬁnitedomain encoding larger subtasks solved stored memory abstraction heuristic Moreover BDDs ﬁnitedomain representation groups related propositions considered abstractions Planners based constraint programming 1147 build eﬃcient CSP representations ﬁnitedomain representations direct encoding state variables PDDL representation As case point CPlan van Beek Chen 47 uses handtailored CSP encodings standard planning domains In cases state representations identical ﬁnitedomain representations generated algorithm presented article Compilations integer programming IP use ﬁnitedomain representation concise IP represen tations By modelling value changes single ﬁnitedomain variable network ﬂow problem naturally expressible linear integer program possible use richer notion plan steps traditional Graphplanlike encodings This helps reduce IP size translates better performance 49 Planning approaches based problem decomposition causal graph heuristic 28 Fast Down ward planner 29 beneﬁt simpler causal structure ﬁnitedomain representation To illustrate M Helmert Artiﬁcial Intelligence 173 2009 503535 507 Fig 4 Causal graph example task STRIPS representation Fig 5 Causal graph example task ﬁnitedomain representation compare causal graph STRIPS encoding example problem Fig 4 causal graph ﬁnite domain counterpart Fig 5 Indeed recently shown causal graph heuristic degenerates inferior variant additive heuristic binary representations 30 This concludes discussion potential advantages concise ﬁnitedomain representations In section formally introduce PDDL ﬁnitedomain representations begin describing translation algorithm Section 3 2 Deﬁnitions As remarked introduction PDDL language planning tasks commonly expressed In par ticular planning tasks international planning competitions IPC expressed PDDL planning able deal language order participate In work consider nonnumerical nontemporal fragment PDDL 22 level 1 language level 2 introduces numerical state variables level 3 intro duces temporal planning features We consider recent additions language capabilities expressing plan constraints preferences PDDL 3 24 However features orthogonal issue binary vs ﬁnitedomain encoding extending work direction conceptually easy Our deﬁnition PDDL tasks uses common notations ﬁrstorder logic assume known refer literature 13 formal deﬁnitions Throughout section assume logical formulae ﬁrst order language L consists suﬃciently constant symbols objects PDDL terminology relation symbols predicates variable symbols There function symbols considers constants 0ary functions We use notation freeϕ refer set free variables ﬁrstorder formula ϕ Deﬁnition 1 PDDL operators A PDDL operator pair cid3χ ecid4 consists possibly open ﬁrstorder formula χ called precondition PDDL effect e PDDL effects recursively deﬁned ﬁnite application following rules A ﬁrstorder literal l PDDL effect called simple effect If e1 en PDDL effects e1 en PDDL effect called conjunctive effect If χ ﬁrstorder formula e PDDL effect χ cid2 e PDDL effect called conditional effect 508 M Helmert Artiﬁcial Intelligence 173 2009 503535 If v 1 vk variable symbols e PDDL effect v 1 vk e PDDL effect called universally quan tiﬁed effect universal effect Free variables simple effects deﬁned literals ﬁrstorder logic Free variables effects deﬁned structural induction freee1 en freee1 freeen freeχ cid2 e freeχ freee freev 1 vk e freee v 1 vk The set free variables PDDL operator deﬁned freecid3χ ecid4 freeχ freee Free variables called parameters operator PDDL operators deﬁne ways planning algorithm world state If current state satisﬁes precondition operator operator applied leading new state like old modiﬁed certain ways speciﬁed effect operator An operator parameters applied directly ﬁrst grounded substituting concrete objects parameters Deﬁnition 2 PDDL axioms A PDDL axiom pair cid3ϕ ψcid4 ϕ ﬁrstorder atom ψ ﬁrstorder formula freeψ freeϕ We write axiom cid3ϕ ψcid4 ϕ ψ ϕ head ψ body axiom A set A PDDL axioms called stratiﬁable iff exists total preorder cid10 predicate symbols A axiom predicate Q occurs head P cid10 Q predicates P occurring body P Q predicates P occurring negative literal translation body negation normal form Axioms provide way deﬁning certain predicates based basic predicates For example given ontop predicate deﬁne transitive closure axioms abovex y ontopx y abovex z yontopx y y z Stratiﬁability set axioms necessary ensuring outcome axiom evaluation welldeﬁned Without condition possible specify rules form P x true P x false Intuitively P Q means truth value atoms P determined truth value atoms Q Deﬁnition 3 PDDL tasks A PDDL task given 4tuple cid5 cid3χ0 χcid6 A Ocid4 following components χ0 ﬁnite set ground atoms called initial state χcid6 closed formula called goal formula A ﬁnite stratiﬁed set PDDL axioms O ﬁnite set PDDL operators Predicates occurring head axiom A called derived predicates Predicates occurring initial state simple effects operators O called ﬂuent predicates The sets derived ﬂuent predicates required disjoint We assume reader familiar PDDL semantics point language deﬁnition 1821 information Apart syntactic differences aspects nonnumerical nontemporal PDDL 22 captured deﬁnition There operator names Our translation algorithm maps grounded PDDL operator unique ﬁnitedomain representation operator implementation need propagate operator names plans generated translated task need undergo form postprocessing apply original task There distinction domain constants objects problem instance domain problem instance speciﬁcation general At level individual problem instances translation algorithm works need distinction There types Our translation algorithm compiles away types unary predicates ﬁrst processing step Section 41 assume untyped representations following stages With PDDL starting point let introduce kinds planning tasks translation algorithm gener planning formalism 234 ates FDR ﬁnitedomain representation tasks FDR tasks based SAS extended axioms conditional effects The deﬁnition exhibits number similarities differences PDDL tasks planning model FDR tasks allow simple conjunctions goals axioms operators conditional effects nested Moreover M Helmert Artiﬁcial Intelligence 173 2009 503535 509 PDDL tasks use ﬁrstorder concepts schematic operators variables instantiated different ways FDR tasks grounded These differences PDDL particular use grounded representation desire FDR formalism simple reduce burden planners use Indeed planning approaches ﬁnitedomain representations listed previous section introduced cases require grounded representations We believe translation ideas introduced article adapted schematic ﬁnitedomain representations representations appear desirable Deﬁnition 4 Planning tasks ﬁnitedomain representation FDR tasks A planning task ﬁnitedomain representation FDR task given 5tuple cid5 cid3V s0 scid6 A Ocid4 following components V ﬁnite set state variables variable v V associated ﬁnite domain Dv State variables partitioned ﬂuents affected operators derived variables computed evaluating axioms The domains derived variables contain default value A partial variable assignment V function s subset V sv Dv sv deﬁned A partial variable assignment called state deﬁned ﬂuents derived variables V It called extended state deﬁned variables V In context partial variable assignments write v d variablevalue pairing cid3v dcid4 v cid15 d s0 state V called initial state scid6 partial variable assignment V called goal A ﬁnite set FDR axioms V Axioms triples cid3cond v dcid4 cond partial variable assignment called condition body axiom v derived variable called affected variable d Dv called derived value v The pair cid3v dcid4 called head axiom The axiom set A partitioned totally ordered set axiom layers A1 Ak layer affected variable appear unique value axiom heads bodies In words layer axioms affected variable different derived values forbidden variable appears axiom head appear different value body This called layering property O ﬁnite set FDR operators V An operator cid3pre eff cid4 consists partial variable assignment pre V called precondition ﬁnite set effects eff Effects triples cid3cond v dcid4 cond possibly partial variable assignment called effect condition v ﬂuent called affected variable d Dv called new value v For axioms effects commonly write cond v d place cid3cond v dcid4 To provide formal semantics planning FDR tasks ﬁrst need formalize semantics axioms Deﬁnition 5 Extended states deﬁned state Let s state FDR task cid5 axioms A layered A1 Ak The extended state deﬁned s written As result s following algorithm cid17 algorithm evaluateaxiomsA1 Ak s variable v cid2 cid17 s v sv v ﬂuent variable v derived variable 1 k exists axiom cond v d Ai cond s s Choose axiom cond v d cid17v d s cid17v cid18 d cid17 In words axioms evaluated layerbylayer fashion ﬁxed point computations similar semantics stratiﬁed logic programs It easy layering property Deﬁnition 4 guarantees algorithm terminates produces deterministic result Having deﬁned semantics axioms deﬁne state space FDR task Deﬁnition 6 FDR state spaces The state space FDR task cid5 cid3V s0 scid6 A Ocid4 denoted Scid5 directed graph Its vertex set set states V contains arc cid3s s cid17cid4 iff exists operator cid3pre eff cid4 O pre As s s cid17v d effects cond v d eff cond As cid17v sv ﬂuents v effect exists 510 M Helmert Artiﬁcial Intelligence 173 2009 503535 Finally deﬁne FDR planning problem Fig 6 Overview translation algorithm Deﬁnition 7 FDR planning FDRPlan following search problem Given FDR task cid5 initial state s0 goal scid6 axioms A compute path Scid5 s0 state s cid17 FDRPlanEx following decision problem Given FDR task cid5 initial state s0 goal scid6 axioms A cid17 prove exists scid6 As Scid5 contain path s0 state s cid17 scid6 As cid17 The FDRPlanEx problem easily shown PSPACEhard generalizes plan existence problem propositional STRIPS known PSPACEcomplete 6 It easy addition nonbinary domains axioms conditional effects increase theoretical complexity FDR planning propositional STRIPS Thus conclude formal introduction FDR planning stating FDRPlanEx PSPACEcomplete In following section turn problem generating concise ﬁnitedomain representations PDDL representations 3 Translation overview Translation performed stages Starting PDDL speciﬁcation ﬁrst apply wellknown logical equivalences compile away types simplify conditions effects normalization stage Section 4 Next invariant synthesis stage computes mutual exclusion relations atoms later synthesizing FDR variables Section 5 The grounding stage performs relaxed reachability analysis compute set ground atoms axioms operators considered relevant planning task computes grounded PDDL representation Section 6 Invariant synthesis grounding related performed opposite order Finally FDR task generation stage chooses ﬁnal set state variables information invariants grounding produces FDR output Section 7 The complete translation process outlined Fig 6 Before begin detailed discussion stages following sections point stages necessary convert PDDL task FDR task invariant synthesis stage omitted However use invariants 11 correspondence relevant ground atoms PDDL task state variables FDR task particular state variables generated FDR task binary Therefore invariants important obtaining concise ﬁnite domain representation 4 Normalization The normalization stage responsibilities compiling away types simplifying conditions simplifying effects Its result normalized PDDL 22 task PDDL task number strong syntactical restrictions Deﬁnition 8 Normalized PDDL tasks A normalized PDDL task PDDL task satisﬁes following structural restric tions M Helmert Artiﬁcial Intelligence 173 2009 503535 511 The goal formula conjunction literals All axiom bodies conjunctions literals possible implicit existential quantiﬁcation free variables occurring axiom head All operator preconditions conjunctions literals All effect conditions conjunctions literals All operator effects conjunctions universally quantiﬁed conditional simple effects 41 Compiling away types As suggested earlier types compiled away ﬁrst processing step For type occurring input type object introduce new unary predicate Typed constructs occur PDDL 22 speciﬁcations semantically meaningful way places 1 Deﬁnition domain constants objects task typed objects 2 Deﬁnition formal parameters schematic operators typed operators 3 Deﬁnition quantiﬁed variables existential universal conditions universal effects typed quantiﬁers Typed objects translated new atoms initial state For example speciﬁcation someobj sometype leads new initial atom sometype someobj plus additional atom supertype someobj supertype sometype including universal supertype object Typed operators transformed introducing new preconditions For example operator parameter speciﬁ cation parameters par1 type1 par2 type2 precondition ϕ parameter speciﬁcation replaced parameters par1 par2 precondition replaced type1 par1 type2 par2 ϕ Typed quantiﬁers conditions compiled away usual logic idioms turning exists v type ϕ exists v type v ϕ forall v type ϕ forall v imply type v ϕ Finally typed universal effects compiled universal conditional effects forall v type e forall v type v e After types eliminated left PDDL task sense Deﬁnition 3 We use concise logical notation deﬁnition following lengthy PDDL syntax For example write ϕ ψ instead ϕ ψ ϕ cid2 e instead ϕ e 42 Simplifying conditions In PDDL tasks general ﬁrstorder formulae occur places goal formula axiom bodies operator preconditions conditions conditional effects Our aim replace simple conjunctions literals Towards goal ﬁrst eliminate implications equivalence ϕ ψ ϕ ψ translate resulting conditions ﬁrstorder negation normal form Morgans laws ﬁrstorder logic The step slightly tricky If universally quantiﬁed conditions rewrite outermost universal quantiﬁcation conditions equivalence xϕ xϕ This somewhat counterproductive transformation destroys negation normal form rewrite introduce new axiom subformula violates normal form property xϕ Formally freexϕ v 1 vk introduce new derived predicate newpred arity k deﬁned axiom newpredv 1 vk ψ ψ translation xϕ negation normal form We replace original condition xϕ newpredv 1 vk If variables universally quantiﬁed expression transform introducing new derived predicate quantiﬁer group We repeat step universally quantiﬁed conditions Note universally quantiﬁed conditions translated universal effects use notation Universal effects compiled away easily deal separately later stage If elimination universal quantiﬁers goal condition simple conjunction contains disjunctions existential quantiﬁers replace new axiom following transformations require splitting conditions easy axiom bodies operator preconditions effect conditions possible formalism goal conditions So example goal ϕ ψ introduce new parameterless derived predicate goalpred new axiom goalpred ϕ ψ replacing original goal atom goalpred The step elimination disjunctions We disjunctions roots conditions applying equiv alences xϕ ψ xϕ xψ ϕ ψ ψ cid17 ϕ ψ ϕ ψ cid17 laws associativity commutativity In theory moving disjunctions conjunctions lead exponential increase formula size avoid introducing new axioms component formulae In practice conditions encountered actual planning domains problematic regard axioms necessary For intended applications ﬁnitedomain represen tations mentioned Section 13 believe identical representations uses fewer state 512 M Helmert Artiﬁcial Intelligence 173 2009 503535 variables usually preferable attempt avoid introducing new state variables compelling reason After disjunctions moved root formulae eliminate splitting surrounding structures If disjunction ϕ ψ axiom body generate axioms identical head body ϕ body ψ If disjunction operator precondition replace operator copies original precondition ϕ precondition ψ Finally disjunction effect condition replace conditional effect ϕ ψ cid2 e ϕ cid2 e ψ cid2 e Next existential quantiﬁers conjunctions applying equivalence xϕ ψ xϕ ψ The equiv alence holds x freeψ avoid trouble later ﬁrst rename variables bound quantiﬁers unique Having moved existential quantiﬁers root conditions eliminate For axioms simply drop following logic programming convention free variables body head implicitly existentially quantiﬁed For operator preconditions drop adding existentially quantiﬁed variables parameter list schematic operator For effect conditions replace xϕ cid2 e x ϕ cid2 e 43 Simplifying effects After somewhat laborious simpliﬁcation conditions effect simpliﬁcation conceptually simple First universal cid17 ϕ cid2 e conditional effects moved conjunctive effects equivalences x e e cid17 Second conditional effects moved universal effects equivalence ϕ cid2 x e x cid17 ϕ cid2 e ϕ cid2 e e ϕ cid2 e Finally nested effects type ﬂattened conjunctive effects containing conjunctive effects collapsed single conjunctive effects conjuncts universal effects containing universal effects collapsed single universal effect quantifying variables nested conditional effects type ϕ cid2 ψ cid2 e transformed ϕ ψ cid2 e Note modiﬁcation preserves previously generated normal form effect conditions cid17 x e x e After transformations possible nesting effects restricted simple chain conjunctive effect cid21 universal effect cid21 conditional effect cid21 simple effect However effect types necessarily present example universal effect need contain conditional effect To enforce regular effect structure replace simple effects e surrounded conditional effects cid22 cid2 e cid22 seen conjunction condition normal form conditional effects e surrounded universal effects e quantifying zero variables universal effects e surrounded conjunctive effects conjunctive effect containing singleton e As result normalization operator conjunctive effect conjunct simple effect associated set universal quantiﬁers associated condition trivial Thus necessary store normalized operator effects tree structure ﬂat vector suﬃcient This concludes normalization stage For sake following discussion brieﬂy recapitulate structural restrictions normalized PDDL tasks Deﬁnition 8 The representation untyped All formulas goal preconditions effect conditions axiom bodies conjunctions literals The effect operator conjunctive effect parts form v 1 vk ϕ cid2 e e simple effect In following refer individual simple effects operator normalized PDDL task arranged effect list For simple effect e occurring universal conditional effect v 1 vk ϕ cid2 e refer v 1 vk set bound variables e ϕ condition e If e positive literal add effect delete effect 5 Invariant synthesis An invariant planning task property satisﬁed world states reachable initial state Many invariants uninteresting example property At ﬁve state variables true invariant propositional STRIPS planning tasks entail useful exploitable piece information planner Other invariants useful know diﬃcult verify For example The goal satisﬁed invariant iff planning task solvable conﬁrming invariance state property PSPACEhard propositional STRIPS task Nevertheless invariants useful tool planning systems studied researchers variety contexts 20254142 Section 55 discusses related work invariants introduce new invariant synthesis algorithm following instead applying algorithms literature The short answer algorithms literature limited STRIPS domains Moreover prohibitively expensive largest planning tasks IPC benchmark suite M Helmert Artiﬁcial Intelligence 173 2009 503535 513 For purposes translating planning tasks ﬁnitedomain representation mutual exclusion mutex invariants especially interesting A mutex invariant states certain propositions true time This affects translation set propositions pairwise mutually exclusive easily encoded single state variable value speciﬁes propositions true true number state variables encoding truth value proposition individually Invariance usually proven inductively First shows hypothesized property true initial state Then shows property true state true successor states Together implies property true reachable states invariant As mentioned automatic discovery invariants hard problem general relevant types state properties suﬃcient conditions exist checked quickly Still synthesizing invariants costly reason interested algorithms working directly ﬁrstorder PDDL description planning task grounded representation Indeed algorithm goes requirement relying information task PDDL input solely exploiting information present domain This valuable feature rules possibility directly proving mutex conditions mutex established checking initial state Instead consider slight generalization mutexes Deﬁnition 9 Monotonicity invariant candidates A monotonicity invariant candidate PDDL task cid5 given pair I cid3V cid7cid4 V set ﬁrstorder variables called parameters candidate cid7 set atoms Variables occurring freely cid7 parameters called counted variables candidate For V v 1 vm cid7 ϕ1 ϕk write I v 1 vm ϕ1 ϕk In special case V write ϕ1 ϕk In following refer monotonicity invariant candidates invariant candidates simply candidates consider kinds invariant candidates The preceding deﬁnition deﬁnes syntax invariant candidates provide semantics This involved provide example Logistics domain ﬁrst Consider candidate cid3p atp l inp vcid4 p l v variable symbols We write p atp l inp v read For packages p number locations l atp l true plus number vehicles v inp v true nonincreasing In terminology p parameter candidate l v counted variables This invariant candidate actual invariant hold reachable states invariants algorithm Logistics Let formalize means candidate invariant Deﬁnition 10 Monotonicity invariants Let I cid3V cid7cid4 monotonicity invariant candidate PDDL task cid5 An instance I function α mapping variables V objects cid5 The set covered facts instance α I set ground atoms planning task cid5 unify ϕ cid7 α set ground atoms ϕ0 cid5 exists variable map β α βϕ ϕ0 ϕ cid7 The weight instance α I state s number covered facts α true s The monotonicity invariant candidate I called monotonicity invariant iff instances α I states s cid17 greater weight s weight α s cid17 reachable initial state cid5 successor states s α s Similar convention invariant candidates usually refer monotonicity invariants simply invariants The deﬁnition probably best understood considering previously discussed example invariant To instance candidate p atp l inp v map p particular object α p cid15 package1 The set covered facts α given state s consists atoms form atpackage1 l inpackage1 v satisﬁed s In reachable state typically atom example given mapping β α l cid15 location1 weight α s 1 But consider strange states α greater weight 1 easy weight α successor state s greater weight α s This true instances candidate invariant As hinted monotonicity invariants useful grouping number related propositions single ﬁnite domain variable invariant planning task given instance invariant weight 1 initial state facts covered instance pairwise mutually exclusive This synthesized invariants utilized later stages translation So generate invariants Since feasible candidates enumerate exhaustively follow guided guess check repair approach Starting set simple initial candidates try prove given candidate invariant Whenever case invariant consider However proof fails try detect case reﬁne candidate generate candidates fail reason fail reasons From highlevel perspective search problem solve standard breadthﬁrst search closed list avoid exploring 514 M Helmert Artiﬁcial Intelligence 173 2009 503535 invariant candidate twice This guarantees termination algorithm To fully specify invariant synthesis algorithm suﬃces discuss search space Initial states What initial candidates Termination test How prove candidate invariant Successor set How reﬁne candidate proof fails In following deal questions sequence 51 Initial candidates Before starting actual invariant synthesis check predicates affected operators predicates including limited representing types constant sense atoms predicates truth values states Such predicates longer needed grounding need consider invariant candidates Of course constant predicate trivially satisﬁes monotonicity invariant useful Therefore limit set interesting predicates modiﬁable ﬂuent predicates predicates occur operator effects simple effect merely effect condition Note excludes derived predicates In theory reason monotonicity invariants involving derived predicates practice seen examples detecting require global reasoning proof methods use ﬂuent predicates We come issue derived predicates discussing method proving invariance The set initial invariant candidates consists candidates isomorphism renaming variables contain counted variable exactly atom modiﬁable ﬂuent predicate parameters distinct variables In experience mutexes based invariants counted variables atom exceedingly rare fact seen example practice To illustrate initialization invariant candidates candidates generated binary predicate Logistics domain x atx l l atx l x l atx l 1 2 3 Similar candidates introduced predicate Intuitively ﬁrst candidate states object locations successor state current state second candidate states location occupied objects successor state current state candidate states given object occupy given location successor state case current state Candidates 2 3 obviously invariants Candidate 1 invariant object currently inside vehicle location successor state location current state However reﬁne 1 invariant 52 Proving invariance In order prove given invariant candidate invariant operator increase weight instances An operator increases weight instance invariant candidate iff number covered facts makes true greater number covered facts makes false If operator increase weight instance balanced regard invariant Ultimately interested instances monotonicity invariants rise mutexes instances weight 1 relevant For reason use following condition slightly stronger balance Deﬁnition 11 Threatened invariant candidates An invariant candidate I threatened schematic operator iff following conditions holds The operator add effect increase weight instance I state delete effect guaranteed decrease weight instance state In case operator unbalanced regard I When ignoring delete effects operator increase weight instance I state 2 In case operator heavy I Clearly threatened schematic operator suﬃcient condition monotonicity invariant Note showing operator unbalanced sense deﬁnition suﬃcient invariance M Helmert Artiﬁcial Intelligence 173 2009 503535 515 balance test considers different add effects isolation For example operator add effects individually balanced delete effect However operator cause net increase weight invariant instance balancing delete effects identical This obvious example consider incorrectly modelled operator moving currently locations l1 l2 locations l3 l4 Precondition atx l1 atx l2 Add effects atx l3 atx l4 Delete effects atx l1 atx l2 At ﬁrst glance operator problematic monotonicity invariant candidate x atx l actually case l1 l2 l3 cid18 l4 increases number locations x currently Attempting capture subtleties balance test makes test complicated presence universally quantiﬁed effects add arbitrary number facts We avoid complications adding heaviness test reject invariant candidate operator increase weight instances Clearly heaviness test stricter necessary If operator extended precondition l1 cid18 l2 x atx l invariant rejected operator heavy In context translation ﬁnite domain representation appear problematic interested invariants purpose generating mutex groups In setting weight interesting invariant instances operators add fact exist applicable typical PDDL models contain schematic operators applicable Deﬁnition 11 gives rise algorithm shown Fig 7 Most actual work unifying operator parameters quantiﬁed variables universal conditions algorithm simpliﬁes signiﬁcantly STRIPS domains We discuss algorithm instead focusing points require explanation satisﬁability entailment tests occur end functions isoperatortooheavy isaddeffectunbalanced cid17 precond true s triggering conditions add effects satisﬁed econd e For heaviness test add effects lead operator heavy states s operator actually applicable o cond true s add effects actually add propositions true previously eatom e atom false s An operator considered heavy isoperatortooheavy conditions hold conjunction satisﬁable Even conjunction satisﬁable course possible satisfying states reachable initial state overly conservative cid17 cid17 For imbalance test add effect leads imbalance default However balanced operator actually applied state s requires o precond true state s add effect triggers econd true s actually adds eatom false s deleted time atom means delete effect triggers e true s Function isaddeffectunbalanced conducts logical entailment tests check balancing delete effect guaranteed exist Again overly conservative states balance violated reachable cond true s deletes previously true e cid17 cid17 cid17 Coming earlier Logistics example initial candidates threatened operator unloadtruck Precondition packagex truckt locationl att l inx t Add effects atx l Delete effects inx t The operator unbalanced regard invariant candidates add effect atx l Thus indicated 13 invariant We discuss possible reﬁnements candidates shortly There subtleties algorithm want point brieﬂy We duplicate universal effects beginning isoperatortooheavy detect different stantiations universal effect simultaneously increase weight instance invariant candidate Where Fig 7 contains statements like Let o copy o variables renamed ques tion arises renaming uniquely determined Indeed renamings unique easy compute long atoms candidate refer different predicates usually case However algorithm generalizes invariant candidates occurrences predicate like x atx y y x This requires possible nonisomorphic renamings considered o cid17 cid17 516 M Helmert Artiﬁcial Intelligence 173 2009 503535 Fig 7 Algorithm proving invariant candidate cid3V cid7cid4 invariant function isaddeffectunbalanced In experience invariants type useful implementation support We noted consider invariants involving derived predicates This axioms corre spond operators single add effect delete effect Invariant candidates including derived predicates balanced sense Deﬁnition 11 axiom body entails head interesting case Because operator preconditions effect conditions normal form conjunctions literals satisﬁabil ity test function isoperatortooheavy performed conjunction literals possible linear time Just check literals conjunction complementary Similarly function isaddeffectunbalanced tests entailment conjunctions literals possible linear time One ﬁnal subtlety concerns semantics PDDL operators conﬂicting effects Note balance test requires eatom equal e atom atom added different deleted The reason PDDL semantics mandate atom added deleted simultaneously actually added atom balance cid17 M Helmert Artiﬁcial Intelligence 173 2009 503535 517 Fig 8 Algorithm reﬁning unbalanced invariant candidate cid3V cid7cid4 53 Reﬁning failed candidates As indicated overview invariant synthesis algorithm immediately prove given candidate invariant Instead try reﬁne adding atoms restore balance In algorithmic terms reject invariant candidate cid3V cid7cid4 try generate set new candidates form cid3V cid7 ϕcid17cid4 Whether promising depends reason candidate rejected If rejected operator heavy possible reﬁnement adds atom candidate change fact candidate completely If rejected unbalanced operators hope deal ﬂaw adding atom match delete effect threatening operator balancing unbalanced add effect The basic reﬁnement algorithm shown Fig 8 The actual implementation generate possible reﬁning naively uses information set delete effects threatening operator o failed chance new balance check succeed atoms ϕcid17 isaddeffectunbalanced consider atoms ϕcid17 Since conceptually straightforward technique Instead let return Logistics example Recall invariant candidate 1 x atx l threatened op erator unloadtruck add effect atx l unbalanced The operator delete effect inx t Indeed inx t suitable reﬁnement atom ϕcid17 variable renaming unloadtruck operator balanced regard reﬁned candidate x atx l inx t So add candidate set currently considered candidates At later stage considered proveinvariant invari ant In contrast candidates suitably reﬁned For 3 consider drivetruck operator Precondition truckt locationl locationl cid17 cityc incityl c incityl cid17 c att l cid17 Add effects att l Delete effects att l cid17 cid17 cid17 In order reﬁne 3 x l atx l balance operator need add atom atx l delete effect operator t uniﬁes x However atom covers original atom atx l note cid17 parameter l converse true l unnecessary simpliﬁes x atx l cid17 This candidate isomorphic 1 considered counted variable leading candidate x l atx l cid17 att l Considering candidate 2 drivetruck operator possible reﬁnement atx l cid17 The total number propositions nonincreasing counted variable considered cid17 reﬁnecandidate Supposing removed restriction candidates counted variable atx l cid17 cid17 inx l turn violated unloadtruck operator reﬁned atx l The total number propositions nonincreasing This candidate actually monotonicity invariant However instance clearly weight greater 1 initial state nontrivial Logistics task useful providing mutex information Of course monotonicity invariant output algorithm restriction counted variable removed To derive mutex information monotonicity invariants consider initial state information happens Variable selection stage translation algorithm described Section 71 518 M Helmert Artiﬁcial Intelligence 173 2009 503535 54 Examples Fig 9 Invariants standard benchmark domains This concludes description invariant synthesis algorithm To impression kind invariants generates Fig 9 shows results obtained IPC domains The invariants Grid domain interesting include monotonicity information covered mutexes Grid invariant states total number open locked doors increases fourth invariant states number locked doors increases sixth invariant states door locked locked 55 Related work Before moving translation stage point algorithm described section approach invariant synthesis proposed literature We provide brief comparison approaches sorted decreasing order relatedness Edelkamp Helmerts algorithm 15 proposed MIPS planner 1617 Scholzs algorithm ﬁnding cconstraints 44 Gerevini Schuberts DISCOPLAN 2526 Rintanens invariant synthesis algorithm 42 Bonet Geffners algorithm generating mutexes 5 Fox Longs TIM 920 Apart ﬁrst algorithm list developed independently follow similar ideas Edelkamp Helmerts algorithm closely related approach In fact algorithm considered extension MIPS algorithm nonSTRIPS domains Compared original algorithm method incorporates cosmetic performance improvements main difference coverage universal conditional effects Note small difference easier reason STRIPS operators general class operators occurring normalized PDDL tasks On STRIPS domains algorithms generate set invariants Scholzs algorithm similar Edelkamp Helmerts slight differences way failed invariant candidates reﬁned generate new invariant candidates It shares weakness limited STRIPS domains DISCOPLAN uses similar guess check repair approach However method reﬁning invariant candi dates different In particular algorithm immediately reﬁnes invariant soon threatening operator discovered DISCOPLAN ﬁrst collects threats invariant operators Only generate reﬁnements attempt address threats time On hand collecting threats operators allows making informed choices invariant reﬁnement On hand appears approach incurs formance penalty For example algorithm terminates second IPC benchmark tasks DISCOPLAN exceeds 30 minute timeout large instances IPC4 Airport domain It noted DISCOPLAN generates classes invariants mutexes designed general invariant synthesis tool ﬁnitedomain representations mind This difference purpose taken account compar ing runtime results likely better runtime results obtained DISCOPLAN considering mutual exclusion invariants Modifying DISCOPLANs algorithm derive specialization appears feasible appropriate modiﬁcation available implementation appears practically nontrivial task Apart eﬃciency concerns consideration DISCOPLAN limited STRIPS deal subset ADL fea tures suﬃciently rich IPC benchmarks Finally STRIPS domains invariants important concise ﬁnitedomain encoding algorithm discovers missed DISCOPLAN For example M Helmert Artiﬁcial Intelligence 173 2009 503535 519 Driverlog domain approach prove given driver place inside truck time allows encoding driver location single variable An encoding based invariants DISCOPLAN need introduce separate state variable driverlocation drivertruck pair After discussing point DISCOPLAN authors algorithm amended recent version DISCOPLAN ﬁnds invariant Rintanens algorithm follows guesscheckrepair structure algorithm DISCOPLAN One main dif ference advantage Rintanens algorithm check step uses information current invariant candidates currently considered strengthen induction hypothesis An interesting dif ference opposite algorithm proceeds stronger invariant candidates weaker ones Note inductive proofs strengthening weakening invariant candidate promising reﬁnement strategy In particular weaker statements necessarily easier prove stronger ones induction hypothesis weaker A problem Rintanens algorithm limited propositional STRIPS suﬃciently eﬃcient IPC benchmarks For reason detailed comparison kinds invariants ﬁnd limited experience believe approaches comparable respect mutexes interested Like DISCOPLAN Rintanens approach ﬁnd general classes invariants mutexes Bonet Geffners algorithm generating mutexes seen special case Rintanens algorithm starts different weaker set invariant candidates immediately rejects failed candidates instead trying reﬁne Like Rintanens algorithm limited STRIPS works grounded representation makes expensive compute large IPC benchmarks ﬁrstorder algorithm To runtime manageable algorithm puts severe restrictions potential mutex pairs consider For example atx set propositions encodes location object graph algorithm fails prove mutual exclusion diameter graph greater 2 Examples arise Airport Driverlog Grid MPrime Mystery TPP domains Finally Fox Longs TIM type inference module interpreted invariant synthesis algorithm follows conceptually different approach algorithms described based notion property spaces generated type structure task turn derived type inference technique gives TIM originally 20 limited STRIPS directly usable It extended handle ADL constructs 9 independently development invariant synthesis algorithm 6 Grounding After computing monotonicity invariants translation stage generates variablefree representation malized PDDL task process called grounding Deﬁnition 12 Grounded PDDL tasks A grounded PDDL task PDDL task literals occurring goal formula axioms operators ground literals contain variables Grounding conceptually simple operation If O set objects task variable x parameterized structure operator axiom universally quantiﬁed effect eliminated replacing original structure O copies object o O x substituted o respective copy If PDDL task normal form quantiﬁers conditions similarly eliminated replacing xϕ disjunction oO ϕxo xϕ conjunction cid4 cid3 oO ϕxo In general grounded task exponentially larger original example operator k pa rameters gives rise O k ground instances k grow linearly task size However practice number parameters k usually low particular ﬁxed given planning domain Moreover exponential blowup grounding computationally unavoidable planning grounded representations exponentially easier planning schematic representations 19 In practice majority common planning domains grounding timecritical operation simple ground ing schemes like outlined suﬃce However exceptions rule naive grounding algorithm computationally feasible spectrum IPC planning domains To illustrate grounding chal lenging tested grounding algorithm implemented FF planner 33 IPC benchmark suite imposing runtime limit 30 minutes memory limit 2 GB FF directly support derived predicates pur poses grounding derived predicates treated operators single effect experiment FF particularly suited comparison planners support ADL subset PDDL language grounded tasks follow similar normal form article The signiﬁcant difference compiles away negative literals conditions Moreover uses fairly sophisticated grounding procedure originally introduced Koehler Hoffmann IPP planner 37 Our experiment showed grounding FF blazingly fast vast majority benchmarks scaling issues domains In particular grounding procedure failed 57 tasks 28 OptTelegraph domain 2 Pathways 27 PSRLarge exhausting memory limit Being unable ground planning task signiﬁcant problem tasks reach current planners For 520 M Helmert Artiﬁcial Intelligence 173 2009 503535 Fig 10 Schematic operators Logistics domain Fig 11 Number ground operator generated different grounding algorithms task Logistics 28 IPC1 example results reported Richter et al 40 landmarkbased planner solve planner conﬁgurations described paper tasks 16 largest PSRLarge instances similar time memory constraints Furthermore signiﬁcantly increasing memory limit grounding procedure eliminate bottleneck grounding procedure 28 GB memory limit grounding FF fails 26 tasks 11 OptTelegraph 15 PSRLarge 16 solved planner Richter et al 3 GB memory bound 61 Improving naive grounding algorithm How perform grounding eﬃciently naive algorithm instantiates variable possible object The key observation ground operators produced naive algorithm applicable reachable state task safely omitted grounded representation We illustrate point operators Logistics domain shown Fig 10 instance 28 IPC1 38 running example There 490 objects task naive algorithm generates 490k ground instances operator k parameters There 5 operators 3 parameters operator 4 parameters end 5 4903 4904 582 1010 operators cf ﬁrst row Fig 11 clearly infeasible We discuss number increasingly sophisticated techniques reduce number leading ideas underlying new grounding method introduced article discussed remainder section 611 Exploiting type information A brief look output naive algorithm shows vast majority operators useless For example loadtruckcity1 truck4 airport1 requires packagecity1 true case reachable state Indeed Logistics domain IPC1 untyped easy unary predicates airplane M Helmert Artiﬁcial Intelligence 173 2009 503535 521 airport city location package truck implicit types static appear operator effects serve restrict possible instantiations operator parameters As ﬁrst enhancement implicit explicit typing information account The example task 42 packages 83 trucks 5 airplanes 20 cities 340 locations 17 city One location city airport 20 airports Exploiting information need generate 42 83 340 ground instances loadtruck unloadtruck 83 340 340 20 ground instances drivetruck 42 5 340 ground instances loadairplane unloadairplane 5 20 20 ground instances flyairplane total 194 108 ground operators second row Fig 11 Despite improvement orders magnitude infeasibly large 2 GB memory limit 612 Checking static preconditions The vast majority generated ground operators instances drivetruck useful preconditions incity predicate true Like type predicates previously considered incity static predicate natural second enhancement avoid generating operators violate precondition static predicate unary ones This reduces number ground instances drivetruck 83 340 17 1 parameters t l instantiated arbitrarily 17 valid options parameter l valid option parameter c The operators mention nonunary static predicates number ground instances remains total 300 106 ground operators row Fig 11 improvement roughly orders magnitude cid17 An important caveat unlike naive grounding algorithm algorithm takes type information account grounding algorithm ﬁlters static preconditions implemented way guaranteed run linear time size output P NP To consider planning task single operator precondition conjunction atoms static predicates Such operator deﬁnes straint satisfaction problem CSP 10 domains variables given objects task constraint schemas given facts static predicates initial state preconditions operator correspond constraints Deciding operator valid instantiation akin deciding CSP solvability NPcomplete The problem NPhard case planning terminology instead CSP ter minology objects predicates binary reduction 3COLORABILITY 22 problem GT4 case objects predicates ternary reduction 3SAT 22 problem LO2 The actual problem need solve ﬁnding valid instantiations operator corresponds ﬁnding solutions CSP This harder objects binary predicates case deciding solution existence easy counting number solutions Pcomplete 8 For reason grounding algorithm checks static preconditions general wasteful work One approach enumerate operators satisfy type constraints reject violate static precondi tion This approach faster algorithm generates typecorrect operators checking nonunary static predicates generates fewer operators requires space infeasible ground operators immediately removed A elaborate idea reject partially instantiated operator soon static preconditions longer true given current partial assignment This approach taken IPP grounding algorithm 37 closely related technique called forward checking CSP literature 10 generalized constraints variables The pruning power forward checking approach depends order variables operator instan tiated To let return Logistics example The operator potentially obtain beneﬁt simpler typechecking algorithm drivetruck If parameters instantiated order shown Fig 10 forward checking technique offers beneﬁt simpler approach typecorrect choices truck t locations l l exists feasible value city c static precondition In cases exists value c satisﬁes incity preconditions simultaneously detected forwardchecking algorithm cid17 However variables instantiated opposite order partial instantiations l c rejected immediately The total number partial instantiations consider limited 1 20 20 340 20 17 340 20 17 17 83 602161 counting sequence instantiations 0 1 4 variables This 26 larger number ground operators satisfy static preconditions 479740 In contrast simpler algorithm needs test 192 108 instances operator factor 400 larger number surviving instantiations c l l cid17 cid17 The price improvement offered forward checking algorithm large indexing structures needed eﬃciently checking given partial instantiation static predicate extended instantiation We believe space requirements indexing structures large degree responsible failures IPPFF grounding algorithm IPC tasks We remark size index structures grows exponentially arity predicates domains observe failures domains IPC suite predicate arity bounded 2 maximal arity 3 Pathways 4 OptTelegraph PSR 522 M Helmert Artiﬁcial Intelligence 173 2009 503535 613 Checking relaxed reachability In practice Logistics example grounding algorithm ﬁlters static preconditions fast allow grounding reasonable time use forward checking idea instantiate variables favourable order However signiﬁcant enhancements possible worthwhile reducing number ground operators beneﬁcial inﬂuence planning algorithms For example perstate overhead search algorithm tends increase number ground operators test applicability In Logistics example 90 generated operators unreachable The reason operators infeasible preconditions involving nonstatic predicate In particular truck location belong initial city airplane nonairport location By respecting constraints restrict number ground instances 42 83 17 loadtruck unloadtruck 83 17 17 drivetruck 42 5 20 loadairplane unloadairplane The number instantiations flyairplane reduced This results total 152911 153 105 ground operators improvement order magnitude fourth row Fig 11 It desirable rule ground operators infeasible preconditions nonstatic predicates However problem checking given atom satisﬁed reachable state hard planning Thus practice need compute approximation set reachable facts time conservative includes reachable facts tight excludes facts possible One approximation method use delete relaxations 33 Instead computing set reachable facts normalized PDDL task cid5 compute reachable facts relaxed planning task Rcid5 differs cid5 follows Negative literals axiom bodies operator preconditions effect conditions goal condition assumed true Delete effects operators ignored The set reachable atoms Rcid5 superset set reachable atoms cid5 This follows fact socalled h heuristic completenesspreserving Hoffmanns article 32 details In practical cases superset relationship tight For example Logistics domain sets reachable atoms Rcid5 cid5 identical In words restrict grounded representation Logistics task operators preconditions reachable delete relaxation pruning possible removing operators actually reachable However remark cases safely remove reachable operators In example grounded task contains 1 noop operators movements vehicle location l l The row Fig 11 shows number remaining operators noop pruning Our grounding procedure detect noops ﬁltered ﬁnal postprocessing stage ﬁnitedomain representation generated Computing reachable atoms relaxed planning task easier general planning tasks In particular relaxed planning task grounded reachable atoms computed linear time marking algo rithm propositional Horn logic 12 Indeed grounding algorithm FF proceeds ﬁrst applying IPP grounding algorithm forward checking algorithm described computing reachable atoms operators delete relaxation reduce grounded representation While leads tight representation drawback approach time space requirements IPP algorithm generates IPP output intermediate result As discussed introduction section number planning tasks approach fails For reason designed new grounding algorithm generates set facts operators axioms reachable relaxed task directly considering facts relaxed reachable We turn description algorithm 62 Overview Datalog exploration The basic idea new grounding algorithm Datalog exploration encode atom reachability problem relaxed planning tasks set logical facts rules logic program This allows eﬃciently compute set reachable atoms computing canonical model logic program consists set ground atoms logically implies The algorithm consists steps generating logic program translating normal form supports eﬃcient evaluation computing canonical model Before going steps let formally deﬁne mean logic program As parts paper assume logical vocabulary contain function symbols nonzero arity Deﬁnition 13 Datalog programs A Datalog rule called positive Horn clause ﬁrstorder formula form ϕ1 ϕk ψ k cid2 0 ϕi ψ usually ground atoms It written ψ ϕ1 ϕk Using notation ψ called head ϕ1 ϕk called body rule Datalog rules usually assumed universally quantiﬁed given Datalog rule χ freeχ v 1 vk deﬁne χ v 1 vk χ Similarly set Datalog rules R deﬁne R χ χ R M Helmert Artiﬁcial Intelligence 173 2009 503535 523 A Datalog program pair cid3F Rcid4 F set ground atoms called set facts R set Datalog rules called set rules The canonical model Datalog program cid3F Rcid4 set ground atoms ϕ F R cid26 ϕ Next translate relaxed reachability problem Datalog program Afterwards demonstrate translate logic program particularly simple form compute canonical model simpli ﬁed logic program eﬃciently 63 Generating logic program Reachability relaxed normalized PDDL task straightforward represent logic program A ground atom reachable relaxed task iff true initial state exists reachable axiom operator relaxed task true Therefore set facts logic program formed atoms initial state planning task set rules derived axiom operator deﬁnitions Additionally introduce rule goal planning task detect relaxed task solvable original task unsolvable report immediately stop translation process early Recall Section 4 stage conditions occurring PDDL task conjunctions literals For conjunctions ϕ denote conjunction positive literals ϕ ϕ In context logic programs follow PROLOG convention uppercase letters ﬁrstorder variables lowercase letters constants predicates The exploration rules normalized PDDL task generated follows Axioms For schematic axioms ϕ ψ ψ ψ axiom applicability rule aapplicable X1 Xk ψ 1 ψ m axiom effect rule ϕ aapplicable X1 Xk 1 ψ m freeϕ freeψ X1 Xk generate Operators For schematic operators o parameters X1 Xk precondition ϕ ϕ ϕ ϕ m 1 generate operator applicability rule oapplicable X1 Xk ϕ 1 ϕ m add effect e o adding atom ψ bound variables Y 1 Yl effect condition χ χ χ n generate effect trigger rule χ 1 etriggered X1 Xk Y 1 Yl oapplicable X1 Xk χ 1 χ n effect rule ψ etriggered X1 Xk Y 1 Yl Goal For goal ϕ ϕ ϕ goalreachable ϕ 1 1 ϕ m ϕ m generate goal rule The correctness rules evident literal translations PDDL semantics laxed planning task The reader wonder introduce new predicates necessary computing set reachable facts For example axiom applicability rules axiom effect rules combined single rule introducing auxiliary predicate aapplicable The purpose auxiliary predicates track axioms operators instantiated grounding PDDL task For example Logistics domain generate ground operator flyairplaneplane1 loc1 loc3 loc3 airport location case canonical model logic program include atom flyairplaneapplicable plane1 loc1 loc3 The operator applicability predicates serve additional purpose factoring common subex pressions Without operator preconditions need repeated effect trigger rule effect rule effect trigger rules similarly eliminated 64 Translating logic program normal form Having generated logic program representation need ﬁnd way eﬃciently generate canonical model Returning Logistics example generated rules 524 M Helmert Artiﬁcial Intelligence 173 2009 503535 drivetruckapplicableT L L cid17 C truckT locationL locationL cid17 cityC incityL C incityL cid17 C atT L Given set reachable facts need determine possible instantiations rule conditions body reachable We systematically trying possible instantiations gained naive instantiation method Moreover prefer evaluate rule incrementally new instantiation predicate body derived fact attruck1 loc5 want derive new consequences rule regenerating previously derived facts In order achieve objectives consider particular class Datalog programs Deﬁnition 14 Datalog programs normal form A ﬁrstorder logic atom called variableunique contain occurrences variable For example atom like P X Y X variableunique variable X occurs twice Repetition constants allowed A Datalog rule called variableunique head atoms body variableunique A Datalog rule called projection rule variableunique form ϕ ϕ1 freeϕ freeϕ1 In words projection rules unary rules variables head occur body A Datalog rule called join rule variableunique form ϕ ϕ1 ϕ2 freeϕ1 freeϕ2 freeϕ freeϕ1 freeϕ2 In words join rules binary rules variables occurring head occur body variables occurring body head occur atoms body A Datalog program normal form rules projection join rules The names rule types Deﬁnition 14 reminiscent related databasetheoretic operations relational algebra 45 projection rules correspond projection operator π join rules correspond natural join operator cid3 strictly speaking combination natural join projection The advantage Datalog programs normal form rule incrementally evaluated eﬃciently We algorithm later Note true general rules discussed Section 612 deciding general Datalog rule valid instantiation equivalent CSP solvability We convert Datalog programs normal form Firstly eliminate duplicate variable occurrences follows rule contains atoms duplicate occurrences variable X change occurrence X cid17 rule body We repeat atom new variable X transformations possible If transformation necessary add fact equalso o logic program object o planning task add atom equals X X cid17 Secondly variable X occurs head body rule add atom object X rule body Remember Section 41 objecto true object o planning task Thirdly rules body converted facts Their heads ground atoms variables occurring head occur case body previous transformation After transformations remaining unary rules projection rules need normalize rules atoms body This essentially conjunctive query optimization problem commonly studied database theory 46 As ﬁrst step normalizing rule determine atom body contains variables occur atom rule body head If case variables projected away following general principle query optimization projections performed early possible In assume given rule ϕ ϕ1 ϕm freeϕi X1 Xk contains variables present atoms X j1 Xk Then introduce new predicate p replace original rule rules ϕ ϕ1 ϕi1 p X1 X j ϕi1 ϕm p X1 X j ϕi After transformation binary rules valid join rules rules m 2 atoms correspond mary joins need decomposed binary joins How exactly decomposition performed general greatly affect performance To consider rule drivetruckapplicablet l l cid17 c incityl c incityl cid17 c att l Logistics For brevity omit additional conditions body actual rule relevant discussion One possible decomposition binary join rules results following rules drivetruckapplicablet l l cid17 c temp1t l c incityl cid17 c temp1t l c incityl c att l Another possible decomposition results rules temp2t l l drivetruckapplicablet l l cid17 cid17 cid17 c incityl c temp2t l l c att l cid17 c incityl c M Helmert Artiﬁcial Intelligence 173 2009 503535 525 Fig 12 The greedy join algorithm decomposing rule join rules Of possibilities ﬁrst vastly preferable number reachable instances temp1 large number reachable instances reachable fact att l exactly city c satisfy incityl c The number reachable instances temp2 hand product number reach able instances total number locations larger number reachable instances drivetruckapplicable Finding good decomposition key good performance Unfortunately ﬁnding best possible ordering gen erally easy Indeed closely related problem join ordering central problems query optimization databases typical query optimizers address exhaustively considering exponentially large space possibilities 46 Chap 11 The fact sets deal planning tasks large relations considered database systems normalization procedure lengths Instead exhaustive search ﬁnds globally op timal decomposition applies sequence greedy locally optimal according simple heuristics transformations backtracking choices makes The algorithm called greedyjoin shown Fig 12 To decompose rule iteratively picks atoms ϕ ϕcid17 rule body joins introducing new predicate p result join replacing atoms rule body instance new predicate This process repeated body rule longer contains atoms In step algorithm atoms ϕ ϕcid17 join picked order minimize estimated effort computing join according following rules loss generality ϕ variables ϕcid17 1 Prefer joins arity p minus number variables ϕ smallest 2 If ties need broken prefer joins arity p minus number variables ϕcid17 3 If ties need broken prefer joins arity p lowest smallest The net effect rules algorithm prefers joining atoms large number common variables In Logistics example heuristic steers clear second decomposition sets variables joined atoms disjoint 65 Computing canonical model Once Datalog program converted normal form ready compute canonical model We use incremental approach shown Fig 13 526 M Helmert Artiﬁcial Intelligence 173 2009 503535 Fig 13 Computing canonical model Datalog program cid3F Rcid4 normal form The algorithm maintains variables track reachable facts Variable canonicalmodel records set atoms algorithm determined reachable far It grows monotonically execution algo rithm contains result termination Variable queue keeps track atoms currently open determined reachable considered matching conditions rule bodies We atom closed contained canonicalmodel reached open In addition canonicalmodel queue algorithm uses following data structures Rule matcher A rule matcher indexing structure supports eﬃcient uniﬁcation queries bodies Datalog programs When given ground atom rule matcher determines projection rules ϕ ϕ1 join rules ϕ ϕ1 ϕ2 ϕ1 ϕ2 uniﬁes possible substitute objects variables ϕ1 ϕ2 way obtained The rule matcher reports matched rules ϕ1 ϕ2 matched unify matches generated Note matching ground atoms rules trigger simple rules contain constants body Unfortunately IPC benchmarks contain huge number operator schemas involving constants importantly STRIPS formulation Airport domain eﬃcient indexing structure important Rule matchers implemented decisiontree like data structures similar successor generators 29 Join rule indices Each join rule r ϕ ϕ1 ϕ2 maintains hash tables rindex1 rindex2 map instantiations common variables ϕ1 ϕ2 instantiations variables ϕ1 ϕ2 respectively At time updates assignment key common variables ϕ1 ϕ2 rindex1key contains variable mappings α key variables ϕ1 αϕ1 belongs closed set Similarly rindex2key contains variable mappings β key variables ϕ2 βϕ2 belongs closed set We property index invariant The index information exploited quickly determining possible instantiations ϕ2 match given instantiation ϕ1 vice versa algorithm Note variable assignment α β considered algorithm welldeﬁned function α β agree variables deﬁned The algorithm clearly terminates loop iteration produces new closed atom removing open atom queue happen ﬁnite number times To motivate correctness state important invariant loop atoms derived step rules R closed atoms contained canonicalmodel set M Helmert Artiﬁcial Intelligence 173 2009 503535 527 This property true loop ﬁrst entered closed atoms stage atoms derived R set atoms It hard prove property preserved single iteration loop iteration causes single new atom currentfact closed need consider onestep derivations use atom possibly atoms closed The processing currentfact causes precisely atoms generated derivations enqueued adding canonicalmodel present Thus property loop invariant A formal proof need establish invariant simultaneously index invariant The loop invariant implies termination algorithm atoms canonicalmodel set closed set closed application R Because contains facts F contains facts derived F contains exactly canonical model cid3F Rcid4 66 Axiom operator instantiation With help canonical model instantiating axioms operators straightforward To compute grounded representation scan set ground atoms canonical model order generated creating axiom operator instances follows When encountering atoms form aapplicablex1 xk schematic axiom generate ground instance parameters substituted x1 xk When encountering atoms form oapplicablex1 xk o schematic operator generate ground instance o effects Like case axioms parameters operator substituted x1 xk precondition instantiated accordingly When encountering atoms form etriggeredx1 xk y1 yl e effect operator o look set generated ground operators ﬁnd operator ox1 xk This operator generated previously etriggered atom derived corresponding oapplicable atom Having ground operator attach effect obtained instantiating variables e y1 yl After single pass canonical model procedure produced grounded representation normal ized PDDL task 67 Performance We conclude discussion Datalog exploration algorithm remarks performance In practice performancecritical grounding algorithm computecanonicalmodel processing happens generally negligible lineartime ﬁxed domain processing happens negligible absolute terms requires linear time combined size input output asymptotically optimal How costly computing canonical model To simplify analysis consider case planning domain ﬁxed In case rules Datalog program ﬁxed facts differ instance instance Under assumption runtime computecanonicalmodel linear number attempts enqueue fact Fig 13 In best case number identical number facts canonical model initial Datalog program normalization overall grounding algorithm runs linear time combined input output size asymptotically optimal However case possible sources ineﬃciency Duplicates There attempts enqueue fact projection rules project different facts fact fact generated different rules For given run algorithm deﬁne duplicate ratio total number attempts enqueue fact divided size canonical model completion Irrelevant facts Facts correspond temporary predicates introduced normalization Datalog program irrelevant ﬁnal instantiation stage For given run algorithm deﬁne irrelevance ratio size canonical model divided number facts canonical model relevant refer predicates introduced normalization The overhead calculatecanonicalmodel compared idealized algorithm generate set relevant facts linear time size product duplicate ratio irrelevance ratio In perfect case numbers equal 1 However saw Section 64 different decompositions drivetruckapplicable rule binary joins irrelevance ratio particular considerably larger especially greedy join algorithm makes poor choices Indeed existence grounding algorithm polynomial overhead general case Datalog rules ﬁxed prove P NP It natural ask large ratios practice To answer question applied grounding al gorithm tasks IPC15 benchmark suite measuring duplicate ratio irrelevance ratio The results 528 M Helmert Artiﬁcial Intelligence 173 2009 503535 Fig 14 Duplicate ratios DR irrelevance ratios IR IPC benchmarks For domain report range ratios observed instances summarized Fig 14 shows minimal maximal duplicate irrelevance ratios observed domain The results duplicate ratios generally benign staying value 4 The irrele vance ratios usually low consistently staying value 5 domains MiconicFull Rovers For MiconicFull irrelevance ratios large 648 ratios actually inversely correlated problem size lower problem sizes increase Only 20 smallest instances irrelevance ratios 3 instances average size irrelevance ratios 2 Thus scalability issues domain The domain produces somewhat worrying results Rovers irrelevance ratios large 2796 signiﬁcantly domains Moreover ratios tend increase scaling problem size Closer inspection reveals unfortunate choice greedy join algorithm blame subpar performance In normalizing rule predicate communicaterockdataapplicabler l p x y 11 conditions body following conditions remain 7 join steps temp1r p waypointp haverockanalysisr p temp2r x roverr availabler waypointx atr x temp3l y landerl chanfreel waypoint y atlanderl y visiblex y At point possible joins greedy join algorithm considers optimal joining temp1 temp2 joining temp2 visible joining temp3 visible Of possibilities implementation arbi trarily picks second happens worst possible choice large number reachable instantiations temp2r x visiblex y extended feasible assignments conditions The reason value y temp3l y reachable lander mobile atlander reachable instance To determine impact unfortunate tie breaking decision instrumented greedy join algorithm override default choice instead join temp3 visible choice point similarly equivalent choice point isomorphic communicatesoildataapplicable predicate With modiﬁcation worst case irrelevance ratio Rovers domain reduces 2796 483 By additionally overriding subsequent join decision prevent algorithm joining temp1 temp2 worstcase irrelevance ratio reduced 197 In terms overall runtime grounding algorithm reduced irrelevance ratio translates orderof magnitude improvement This small case study illustrates things hand clearly join ordering choices signiﬁcant impact performance grounding algorithm require attention On hand essentially linear scaling behaviour domains Rovers indicates heuristic decisions greedy join algorithm usually solid M Helmert Artiﬁcial Intelligence 173 2009 503535 529 Fig 15 Computing mutex groups set monotonicity invariants invariants set reachable atoms P f initial state s0 Fig 16 Mutex groups Blocksworld task blocks Some atoms ona reachable relaxed task true real task 7 Generating ﬁnitedomain representation Together invariants synthesized earlier grounded PDDL task generated previous stage provides information need producing ﬁnitedomain representation ﬁnal translation stage Recall Deﬁnition 4 FDR task given set ﬁnitedomain variables V initial state s0 goal scid6 axioms A operators O We start deﬁning suitable variables variable domains falls place 71 Variable selection Each variable generated FDR task corresponds reachable ground atoms STRIPS task We start extracting set P atoms canonical model partitioning atoms P f instances modiﬁable ﬂuent predicates derived predicates atoms Pc instances constant predicates cf Section 51 We want represent ground atoms single state variable possible To achieve ﬁrst determine set mutex groups induced computed invariants Mutex groups computed straightforward manner instantiating monotonicity invariants possible ways checking instance weight 1 initial state atoms P f covers The algorithm shown Fig 15 The actual implementation uses indexing structure eﬃciently determine set reachable atoms covered given invariant instance Normally mutex group correspond FDR state variable atom mutex groups course needs encoded As example phenomenon consider Fig 16 shows mutex groups Blocksworld task blocks If example decide encode mutex groups 1 4 ﬁnitedomain state variables need encode atom groups holding atoms represented Therefore translator ﬁrst generate state variables domains consisting seven values holdingx clearx ona x onb x onc x ond x seventh option true Of seven values block x atoms true actually impossible Afterwards encode truth values remaining atoms ontablex handempty binary state variables In case atom mutex group unique particular group resulting encoding better encoding simply takes mutex groups introduces state variable However cases group completely covered examples Airport domain In case prefer covering set reachable atoms state variables possible Unfortunately set cover problems kind NPcomplete 22 problem SP5 approximable constantfactor approximation ratio 1 limit covering efforts greedy algorithm shown Fig 17 best approximation algorithms known problem achieving O log napproximation 1 It eratively pick mutex group P maximal cardinality introduce new FDR state variable domain P stands elements P true We remove covered elements mutex groups removing groups longer contain element This process repeated mutex groups removed At stage remaining uncovered atoms p represented binary variables domain p 530 M Helmert Artiﬁcial Intelligence 173 2009 503535 Fig 17 Greedy algorithm computing FDR variables variable domains After execution algorithm reachable atom p P f exactly FDR variable domain includes p The translation ensure variable denote varp following assumes value p FDR state iff p true corresponding state PDDL task With information converting rest PDDL task ﬁnitedomain representation 72 Converting initial state We start converting initial state easiest step For atom p P f initial state set initial value varp p FDR variables initial state atom p varp p initialized Note different initial state atoms p p represented FDR variable mutually exclusive implies initial state Therefore converted initial state welldeﬁned cid17 P f satisfy varp cid18 varp cid17 p p cid17 73 Converting operator effects Translating state changes incurred operator effects requires care For add effects setting atom p true conversion easy effect translated FDR effect setting varp p know p true operator application effect ﬁres However delete effects setting atom p false correct translation clear We simply set varp variables represented varp true unconditionally correct case effect operator triggers simultaneously adds atom represented variable p true operator applied atom represented varp Therefore correct behaviour set varp know p previously true effect adding atom represented varp triggers simultaneously In situations delete effect cause change value varp If effects operator add atoms represented varp effect conditions χ1 χk achieved adding p χ1 χk effect condition translated effect If formulae χi proper conjunctions constant true singleton literals results effect condition conjunction literals In case introduce new derived variable v evaluates true χi true use v effect condition instead All things considered conversion delete effects looks complicated cases simpler transla tions possible For purpose detect common special cases deal differently If delete effect triggers add effect affecting variable trigger general effect condition need represent delete effect ﬁnitedomain representation The add effect care value change affected variable On hand add effect affecting variable trigger time effect exists effect conditions inconsistent condition delete effect convert delete effect effect setting varp If p operator precondition effect condition add effect condition sure varp cleared previously set p In cases translating delete effects straightforward simpler cases far common general case In particular unconditional effects special cases applies 74 Converting conditions The major translation step conversion conditions grounded PDDL task Conditions occur goal speciﬁcation operator preconditions conditional effects axiom bodies M Helmert Artiﬁcial Intelligence 173 2009 503535 531 To translate grounded condition ﬁrst check contains atoms P f These constant truth values condition simpliﬁed accordingly If leads constant false condition react accordingly goal report task unsolvable axiom bodies operator preconditions effect conditions remove axiom operator effect If condition trivially false translate positive literals p pairing varp p Translating negative literals p slightly tricky Recall Blocksworld example discussed earlier generated FDR state variable v Dv holdinga cleara ona onb onc ond consider condition including atom onc If condition contains positive literal represented variable v example atom cleara need encode onc implied condition v cleara However simple way represent onc FDR condition We need write like v cid18 onc conditions form supported representation Therefore situations like similar translating nonconjunctive effect conditions arise certain delete effects introduce new derived variable notp domain cid22 generate axiom v d notp cid22 value d Dv p The pairing notp cid22 serve translation literal p If wanted avoid introducing new axioms normalize PDDL task negative literals occur conditions There wellknown compilation methods achieve normal form 23 However transfor mation method introduce state variables necessary runs counter objective concise ﬁnitedomain representation If avoided little point having ﬁnitedomain variables rep resentation property value function value As compromise consider use compilation method propositions appear negative literals translation method introduce new axiom In practice IPC domains negative conditions commonly choice mechanism dealing makes little difference 75 Computing axiom layers As ﬁnal translation step compute axiom layers ﬁnitedomain representation way semantics stratiﬁed logic programs matched cf Deﬁnitions 2 5 This follows body axiom affected variable v includes condition v cid17 cid17 computed value v introduce ordering constraint cid17 d derived variable v d cid18 introduce cid17 cid17 derived variable v cid17 v Similarly axiom affecting v includes condition v v ordering constraint v value v cid17 cid10 v Axiom layers derived ordering constraints stages In ﬁrst stage compute strongly connected components graph induced cid10 relation All axioms affect variables strongly nected component belong axiom layer To compute ordering axiom layers topologically sort graph vertices axiom layers cid17 v The ith axiom affects v arc layer L layer appears ith position computed topological order If axioms original PDDL task stratiﬁable topological sort possible axiom L affects v v layer L iff axiom L cid17 cid17 cid17 76 Postprocessing With axioms partitioned layers translation complete Before generating output apply post processing techniques simplify generated task possible Most importantly axioms head cond v d cid17 cond cond domains axioms encode transitive closures dominates triggered triggered cid17 cid17 cid17 cid17 v d unnecessary In case occurs frequently cid17 cond remove representation cid17 8 Discussion Having ﬁnished presentation translation algorithm question arises evaluate There important criteria consider Performance How quickly representation computed Quality How good generated ﬁnitedomain representation 81 Notes performance We discussion performance short stateoftheart translation algorithm suﬃciently eﬃcient generate ﬁnitedomain representations IPC15 benchmark tasks reasonable time In particular different planning systems use translator including Helmert Richters Fast Downward 29 van den Briel et 532 M Helmert Artiﬁcial Intelligence 173 2009 503535 Fig 18 Absolute runtime IPC15 tasks als Integer Programming planner 49 Helmert et als ﬂexible abstraction heuristics 31 conversion FDR main bottleneck overall planning algorithm translation time negligible compared search time vast majority cases Some exceptions exist structurally simple domains like Satellite Logistics A summary translation time IPC15 benchmark suite shown Fig 18 All experiments conducted machine 266 GHz Intel Xeon CPU 2 GB memory limit The algorithm implemented Python language estimate speed improvement factor 10100 easily achievable C implementation Even 654 instances translated second 934 seconds Fewer 2 require minute fewer 1 require minutes The instances longest translate PSRLarge Satellite domains large example largest Satellite instance 989250 operators largest PSRLarge instance 544209 state variables backchaining analysis reveals 60467 relevant goal In addition overall runtime interesting identify different stages algorithm form main bottlenecks varies domain domain To address question produced detailed runtime results tasks required overall runtime 1 s ﬁrst experiment For domain report minimal maximal percentage overall runtime spent stage algorithm Fig 19 For example entry column FDR Logistics domain indicates Logistics tasks required overall runtime second 21 63 instances 21 30 overall runtime spent ﬁnal stage algorithm generating ﬁnitedomain representation The results normalization invariant synthesis time critical In absolute numbers normalization requires 074 s invariant synthesis requires 038 s In typical domain 70 time required grounding 25 FDR generation There domains grounding require 85 runtime MiconicFull PSRLarge PSRMiddle Rovers Relating observation earlier anal ysis Datalog grounding algorithm Fig 14 precisely domains highest average irrelevance ratio For completeness mention grounding stage vast majority time spent computing canonical model Section 65 performing ﬁnal operator axiom instantiation Section 66 The initial steps algorithm generating Section 63 normalizing Section 64 logic program require 188 s task PSRSmall 25 require 1 s 82 Notes quality So quality representation In planning domains considered including IPC15 domains algorithm generates ﬁnitedomain representations close identical designed manually However encouraging quality representation measured Ultimately ﬁnitedomain representation useful depends serves intended purpose In Section 13 discussed number possible uses ﬁnitedomain representations including SAT planning sym bolic state space exploration BDDs heuristic planning pattern databases homomorphism abstractions planning integer programming compilations heuristic planning based causal graph decompositions For SAT planning MaxPlan 7 joint winner optimal propositional track IPC5 clearly established usefulness ﬁnitedomain representations Although exact details FDR translation method MaxPlan published directly inspired techniques presented article follows similar overall strategy personal communications As Chen et al report ﬁnitedomain representations play critical role planner performance 7 binary state variable case londex constraints key innovation MaxPlan reduce M Helmert Artiﬁcial Intelligence 173 2009 503535 533 Fig 19 Distribution runtimes different stages translation algorithm domain Only tasks overall runtime 1 s taken account The second column shows number tasks domain number total tasks domain The following columns order percentage time spent inputoutput including parsing normalization Section 4 invariant synthesis Section 5 grounding Section 6 FDR generation Section 7 Ranges denote minimum maximum percentage considered tasks domain usual mutex constraints stateoftheart SAT planners londex constraints require nontrivial FDR encodings For planning BDDs ﬁnitedomain representations critical performance point compilations use direct propositional encoding lead prohibitively bad performance Indeed reason Edelkamp Helmerts algorithm devising concise ﬁnitedomain representations 15 originally developed We remark domains algorithm handle STRIPS domains constants operator deﬁnitions encodings generated algorithm presented generally equivalent Edelkamp Helmert algorithm For planning homomorphism abstractions situation similar For example ﬂexible abstraction heuristics Helmert et al 31 critically rely ﬁnitedomain representation generated method presented degrading orders magnitude solving signiﬁcantly fewer tasks direct propositional encoding instead The performance degradation observed heuristic planning based causal graph decompositions 29 concise FDR translation causal graph heuristic competitive approaches Finally van den Briel et al 49 use FDR translation algorithm Integer Programming compilation ap proach report signiﬁcant performance advantages earlier approaches based propositional encodings In summary wide spectrum planning techniques signiﬁcantly beneﬁt automatically derived concise ﬁnitedomain representations techniques presented work Acknowledgements Many thanks Silvia Richter Sylvie Thiébaux anonymous reviewers helpful feedback earlier drafts paper References 1 G Ausiello P Crescenzi G Gambosi V Kann A MarchettiSpaccamela M Protasi Complexity Approximation SpringerVerlag 1999 2 C Bäckström B Nebel Complexity results SAS 3 J Benton M van den Briel S Kambhampati A hybrid linear programming relaxed plan heuristic partial satisfaction planning problems planning Computational Intelligence 11 4 1995 625655 Boddy et al 4 pp 3441 534 M Helmert Artiﬁcial Intelligence 173 2009 503535 4 M Boddy M Fox S Thiébaux Eds Proceedings Seventeenth International Conference Automated Planning Scheduling ICAPS 2007 AAAI Press 2007 5 B Bonet H Geffner Planning heuristic search Artiﬁcial Intelligence 129 1 2001 533 6 T Bylander The computational complexity propositional STRIPS planning Artiﬁcial Intelligence 69 12 1994 165204 7 Y Chen X Zhao W Zhang Longdistance mutual exclusion propositional planning MM Veloso Ed Proceedings 20th International Joint Conference Artiﬁcial Intelligence IJCAI 2007 2007 8 N Creignou S Khanna M Sudan Complexity Classiﬁcations Boolean Constraint Satisfaction Problems SIAM Monographs Discrete Mathematics Applications vol 7 SIAM 2001 9 S Cresswell M Fox D Long Extending TIM domain analysis handle ADL constructs AIPS 02 Workshop Knowledge Engineering Tools Techniques AI Planning 2002 10 R Dechter Constraint Processing Morgan Kaufmann 2003 11 MB Do S Kambhampati Planning constraint satisfaction Solving planning graph compiling CSP Artiﬁcial Intelligence 132 2 2001 151182 12 WF Dowling JH Gallier Lineartime algorithms testing satisﬁability propositional Horn formulae Journal Logic Programming 1 3 1984 367383 13 HD Ebbinghaus J Flum W Thomas Mathematical Logic 2nd ed SpringerVerlag 1994 14 S Edelkamp Planning pattern databases A Cesta D Borrajo Eds Preproceedings Sixth European Conference Planning ECP01 Toledo Spain 2001 15 S Edelkamp M Helmert Exhibiting knowledge planning problems minimize state encoding length S Biundo M Fox Eds Recent Advances AI Planning 5th European Conference Planning ECP99 Lecture Notes Artiﬁcial Intelligence vol 1809 SpringerVerlag Heidelberg 1999 16 S Edelkamp M Helmert On implementation MIPS P Traverso M Veloso F Giunchiglia Eds Proceedings AIPS2000 Workshop ModelTheoretic Approaches Planning 2000 17 S Edelkamp M Helmert The model checking integrated planning MIPS AI Magazine 22 3 2001 6771 18 S Edelkamp J Hoffmann PDDL22 The language classical 4th International Planning Competition Tech Rep 195 AlbertLudwigs Universität Freiburg Institut für Informatik 2004 19 K Erol DS Nau VS Subrahmanian Complexity decidability undecidability results domainindependent planning Artiﬁcial Intelligence 76 1 2 1995 6588 20 M Fox D Long The automatic inference state invariants TIM Journal Artiﬁcial Intelligence Research 9 1998 367421 21 M Fox D Long PDDL21 An extension PDDL expressing temporal planning domains Journal Artiﬁcial Intelligence Research 20 2003 61124 22 MR Garey DS Johnson Computers Intractability A Guide Theory NPCompleteness Freeman 1979 23 BC Gazen CA Knoblock Combining expressivity UCPOP eﬃciency Graphplan S Steel R Alami Eds Recent Advances AI Planning 4th European Conference Planning ECP97 Lecture Notes Artiﬁcial Intelligence vol 1348 SpringerVerlag 1997 24 A Gerevini D Long Plan constraints preferences PDDL3 Tech Rep R T 20050847 Dipartimento di Elettronica lAutomazione Università degli Studi di Brescia 2005 25 A Gerevini L Schubert Inferring state constraints domainindependent planning C Rich J Mostow Eds Proceedings Fifteenth National Conference Artiﬁcial Intelligence AAAI98 AAAI Press 1998 26 A Gerevini L Schubert Discovering state constraints planning DISCOPLAN Tech Rep 20050948 Department Electronics Automation University Brescia 2005 27 P Haslum A Botea M Helmert B Bonet S Koenig Domainindependent construction pattern database heuristics costoptimal planning Proceedings TwentySecond AAAI Conference Artiﬁcial Intelligence AAAI2007 AAAI Press 2007 28 M Helmert A planning heuristic based causal graph analysis S Zilberstein J Koehler S Koenig Eds Proceedings Fourteenth Interna tional Conference Automated Planning Scheduling ICAPS 2004 AAAI Press 2004 29 M Helmert The Fast Downward planning Journal Artiﬁcial Intelligence Research 26 2006 191246 30 M Helmert H Geffner Unifying causal graph additive heuristics Proceedings Eighteenth International Conference Automated Planning Scheduling ICAPS 2008 2008 31 M Helmert P Haslum J Hoffmann Flexible abstraction heuristics optimal sequential planning Boddy et al 4 pp 176183 32 J Hoffmann Where ignoring delete lists works Local search topology planning benchmarks Journal Artiﬁcial Intelligence Research 24 2005 685758 33 J Hoffmann B Nebel The FF planning Fast plan generation heuristic search Journal Artiﬁcial Intelligence Research 14 2001 253302 34 P Jonsson C Bäckström Statevariable planning structural restrictions Algorithms complexity Artiﬁcial Intelligence 100 12 1998 125 176 35 H Kautz B Selman Planning satisﬁability B Neumann Ed Proceedings 10th European Conference Artiﬁcial Intelligence ECAI 92 John Wiley Sons 1992 36 H Kautz B Selman Pushing envelope Planning propositional logic stochastic search Proceedings Thirteenth National Conference Artiﬁcial Intelligence AAAI96 AAAI Press 1996 37 J Koehler J Hoffmann Handling inertia planning Tech Rep 122 AlbertLudwigsUniversität Freiburg Institut für Informatik 1999 38 D McDermott The 1998 AI Planning Systems competition AI Magazine 21 2 2000 3555 39 EPD Pednault ADL Exploring middle ground STRIPS situation calculus RJ Brachman HJ Levesque R Reiter Eds Pro ceedings First International Conference Principles Knowledge Representation Reasoning KR89 Morgan Kaufmann 1989 40 S Richter M Helmert M Westphal Landmarks revisited Proceedings TwentyThird AAAI Conference Artiﬁcial Intelligence AAAI2008 AAAI Press 2008 41 J Rintanen A planning algorithm based directional search AG Cohn L Schubert SC Shapiro Eds Proceedings Sixth International Conference Principles Knowledge Representation Reasoning KR98 Morgan Kaufmann 1998 42 J Rintanen An iterative algorithm synthesizing invariants H Kautz B Porter Eds Proceedings Seventeenth National Conference Artiﬁcial Intelligence AAAI2000 AAAI Press 2000 43 J Rintanen Compact representation sets binary constraints Proceedings 17th European Conference Artiﬁcial Intelligence ECAI 2006 2006 44 U Scholz Extracting state constraints PDDLlike planning domains AIPS2000 Workshop Analyzing Exploiting Domain Knowledge Eﬃcient Planning 2000 45 JD Ullman Principles Database KnowledgeBase Systems vol I Classical Database Systems Computer Science Press 1988 46 JD Ullman Principles Database KnowledgeBase Systems vol II The New Technologies Computer Science Press 1989 47 P van Beek X Chen CPlan A constraint programming approach planning Proceedings Sixteenth National Conference Artiﬁcial Intelli gence AAAI99 AAAI Press 1999 M Helmert Artiﬁcial Intelligence 173 2009 503535 535 48 M van den Briel J Benton S Kambhampati T Vossen An LPbased heuristic optimal planning C Bessiere Ed Proceedings Thirteenth International Conference Principles Practice Constraint Programming CP 2007 Lecture Notes Computer Science vol 4741 Springer Verlag 2007 49 M van den Briel T Vossen S Kambhampati Reviving integer programming approaches AI planning A branchandcut framework S Biundo K Myers K Rajan Eds Proceedings Fifteenth International Conference Automated Planning Scheduling ICAPS 2005 AAAI Press 2005