Artiﬁcial Intelligence 220 2015 127 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint STR3 A pathoptimal ﬁltering algorithm table constraints Christophe Lecoutre Chavalit Likitvivatanavong b CRILCNRS UMR 8188 Université dArtois F62307 Lens France b School Computing National University Singapore 13 Computing Drive Singapore 117417 Singapore Roland HC Yap b r t c l e n f o b s t r c t Article history Received 27 August 2014 Received revised form 3 December 2014 Accepted 9 December 2014 Available online 16 December 2014 Keywords Constraint satisfaction problems Generalized arc consistency Nonbinary constraints Backtracking search Constraint propagation key success Constraint Programming CP The principle ﬁltering algorithms associated constraints executed sequence quiescence reached Many algorithms proposed years enforce property called Generalized Arc Consistency GAC types constraints including table constraints deﬁned extensionally Recent advances GAC algorithms extensional constraints rely directly manipulating tables search This case simple approach called Simple Tabular Reduction STR systematically maintains tables constraints relevant lists tuples In particular STR2 reﬁned STR variant eﬃcient GAC algorithms positive table constraints In paper revisit approach proposing new GAC algorithm called STR3 speciﬁcally designed enforce GAC backtrack search By indexing tables reasoning deleted values STR3 avoid systematically iterating set current tuples contrary STR2 An important property STR3 completely avoid unnecessary traversal tables making optimal path search tree We study variant STR3 based optimal circular way traversing tables discuss relationship STR3 optimal GAC algorithms introduced literature GAC4 AC5TCTr Finally demonstrate experimentally STR3 competitive stateofthe art In particular extensive experiments STR3 generally faster STR2 average size tables reduced drastically search making STR3 complementary STR2 2014 Elsevier BV All rights reserved 1 Introduction Algorithms establish Generalized Arc Consistency GAC constraint problems networks ﬁlter inconsistent values variable domains order reduce combinatorial search spaces problems They staple Constraint Programming CP origin ﬁeld Artiﬁcial Intelligence AI seventies example introduction algorithms GAC3 2 GAC4 34 Typically GAC enforced step complete backtrack This expansion article previously appeared ECAI12 1 Corresponding author Email addresses lecoutrecrilfr C Lecoutre likitchavgmailcom C Likitvivatanavong ryapcompnusedusg RHC Yap httpdxdoiorg101016jartint201412002 00043702 2014 Elsevier BV All rights reserved 2 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 Fig 1 Standard dual representations relation ternary constraint C scope X Y Z search leading socalled MAC Maintaining generalized Arc Consistency algorithm 5 This paper introduces new GAC algorithm called STR3 works positive table constraints Furthermore unlike GAC algorithms STR3 speciﬁcally conceived MAC standalone A table relation classical relational database positive table constraint contains table permit ted combinations values subset variables negative table constraint contains forbidden combinations values Table constraints studied artiﬁcial intelligence literature arise naturally ap plication areas For example conﬁguration databases introduced model problem matter domain Besides table constraints viewed universal mechanism representing constraints provided space requirements controlled The importance table constraints makes commonly implemented major constraint solvers aware Choco GeCode JaCoP ORTools For table constraints classical ﬁltering algorithms reduce search inference 69 work constraints stay unaltered running However recent developments suggested reducing traversal discarding irrelevant tuples tables lead faster algorithms Simple Tabular Reduction STR improvements 1011 fall category shown best GAC algorithms positive table constraints The main idea simple tabular reduction remove invalid tuples tables soon possible systematic fashion STR3 based principle STR1 10 STR2 11 employs different representation table constraints Similarly algorithms GACallowed 6 GACva 8 STR3 provides index constraint table enabling tuple sought respect domain value visiting irrelevant tuples reducing time complexity Fig 1 shows example ternary constraint Importantly constraint relation STR3 maintains speciﬁc data structures designed constraint tuple processed path search tree going root leaf Most GAC algorithms table constraints previously introduced literature suffer repeatedly traversing tables related data structures search 1112 In contrast STR3 avoids repetition pathoptimal element table examined path search tree An important feature STR3 designed speciﬁcally interleaved backtracking search main goal maintain consistency minimizing cost backtracking As unlike GAC algorithms STR3 applicable context search STR3 maintains GAC commencement search GAC enforced algorithm STR2 example We investigated promising circular manner traversing tables STR3 Although attractive ﬁrst circular approach described 13 optimal run time branch amortized search tree experiments effective STR3 practice To conclude theoretical analysis discuss relationships STR3 optimal GAC algorithms table constraints GAC4 4 AC5TCTr 14 We present extensive experimental study demonstrates STR3 competitive stateoftheart algorithms In particular experiments STR3 complementary STR2 STR2 faster STR3 simple tab ular reduction eliminate tuples tables largely STR3 contrast outperforms STR2 constraint relations shrink search STR2 costly Hence STR3 complementary STR2 This paper organized follows Technical background provided Section 2 In Section 3 concept STR3 explained algorithm A detailed example STR3s stepbystep execution given Section 4 Sec tion 5 analyzes relationships STRs data structures greater Theoretical analysis STR3 carried Sections 6 7 A variant STR3 studied Section 8 Previous works related STR3 discussed Section 9 Experimental results reported Section 10 The paper concludes Section 11 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 3 2 Preliminaries In section introduce technical background concerning constraint satisfaction problem recall operation data structure called sparse set key STR3s optimality 21 Constraint satisfaction problem A ﬁnite constraint network P pair X C X ﬁnite set n variables C ﬁnite set e constraints Each variable X X initial domain denoted D X set values assigned X Each constraint C C involves ordered subset variables X denoted scpC called scope C The arity constraint C number variables involved C scpC A binary constraint involves variables nonbinary constraint involves strictly variables The semantics constraint C given relation cid2 denoted relC scpC X1 Xr relC r i1 D Xi represents set satisfying combinations values called allowed tuples variables scpC A solution constraint network assignment value variable constraint satisﬁed A constraint network satisﬁable iff solution exists The Constraint Satisfaction Problem CSP NPcomplete task determining given constraint network satisﬁable Thus CSP instance deﬁned constraint network solved ﬁnding solution proving solution exists Solving CSP instance usually involves complete backtrack search interleaved inference processes reduce search space In paper shall focus MAC Maintaining Arc Consistency 15 considered eﬃcient generic search algorithms CSP MAC explores search space depthﬁrst backtracks deadends occur enforces property called generalized arc consistency decision variable assignment value refutation taken search Below introduce notations deﬁnitions useful rest paper During search Dc X denotes current domain variable X X Dc X D X If value Dc X currently present absent We use X denote value D X simply context clear use τ Xi denote value ai rtuple τ a1 ar associated rary constraint C scpC X1 Xr A tuple τ relC valid iff τ X Dc X X scpC τ invalid A tuple τ relC support X C iff τ valid τ X We deﬁne Generalized Arc Consistency GAC follows A value X generalized arcconsistent GAC constraint C involving X iff exists support X C A constraint C GAC iff X scpC Dc X X GAC C A constraint network GAC iff constraints GAC When relC speciﬁed enumerating elements list C called positive table constraint Alternatively relC denote set forbidden combinations values variables scpC case extensional form called negative table constraint A positive table constraint converted negative table constraint vice versa In paper deal positive table constraints For constraint C assume total ordering relC deﬁne posC τ position tuple τ ordering called tuple identiﬁer database literature tid short 1617 tupC k denotes kth tuple relC Thus τ tupC posC τ tuple τ relC k posC tupC k k 1 t t relC 22 Sparse sets The sparse set data structure ﬁrst proposed 18 motivation provide fast operations sets objects These operations clearset insertion deletion membership test iteration Sparse sets played crucial role recent CP algorithms 121920 In context backtracking search concerned speed basic operations insertion membership test deletion A sparse set S abstract structure composed arrays traditionally called dense sparse integer variable called members Both arrays equal size n index ranging 1 n possible elements drawn universe 1 n The array dense acts like normal array container elements packed left array sparse carries element present set location dense The value members indicates number elements S Arrays dense sparse adhere following property cid3 v S Ssparsev Smembers Sdense cid4 Ssparsev v 1 An illustration given Fig 2a sparse set representation set currently containing 4 values 8 possible ones shown Note arrays dense sparse require initialization1 Pseudocode insertion membership test given Fig 3 Deletion LIFO Last In First Out order achieved decreasing value members 1 Actually true provided sparse contains strictly positive values In 18 assumed indexing starts 0 sparse array unsigned integers 4 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 Fig 2 A sparse set S 4 elements S 2 4 6 8 Fig 3 Original sparse set operations Fig 4 Sparse set operations optimized membership testing In practice membership tests occur frequently insertions In case tradeoff cost testing membership value v sparse set S reduced simply checking Ssparsev Smembers expense expensive insertion 20 The idea array dense containing permutation n values Operations set maintain permutation swapping elements S Because arrays dense sparse initially ﬁlled values 1 n single copy value dense time The condition SdenseSsparsev v unnecessary The pseudocode modiﬁed addMember isMember given Fig 4 In addition note enumeration elements present S simple iterating members 1 n dense An illustration given Fig 2b 3 STR3 This section introduces STR3 algorithm based simple tabular reduction enforcing GAC positive table straints GAC algorithms normally follow pattern domain value proved consistent producing valid tuple containing value case positive table constraints producing evidence auxiliary struc tures path case BDDs Boolean Decision Diagrams MDDs Multivalued Decision Diagrams tries 122122 This usually traversing structures running tests substructure Reducing traver sal long focus works For table constraints optimization techniques include skipping irrelevant rows columns 78 compressing tables 122122 Simple Tabular Reduction STR 10 called STR1 paper GAC algorithm dynamically revises tables search While GAC algorithms treat tables like ﬁxed structures resort tackling comparable structures created tables STR1 shows handling tables directly backtracking search expensive thought STR1 works scanning tuple If tuple invalid removed table contracted row C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 5 result Otherwise tuple valid components domain values proved support STR1 considers tuple collect values designated sets called gacValues X deﬁned variable X scope constraint When STR1 ﬁnished going table value present sets support removed domain STR2 11 provides improvements STR1 When tuple τ inspected validity need check τ X Dc X change domain X time STR2 called constraint In addition case τ valid algorithm goes component τ τ X skipped known gacValues X Dc X single value Dc X supported The ﬁrst improvement involves additional data structures maintained order deliver optimization beneﬁt STR2 data structures maintained called STR2 11 Throughout paper especially experiments section refer STR2 mean STR2 STR2w 49 improves lower bound STR2 redesign incorporation watched tuples Like STR1 STR2 STR3 longer examines tuple recognized invalid Unlike STR1 STR2 STR3 immediately discard invalid tuples tables Indeed STR3 process tables directly instead employs indexes allowing rapid identiﬁcation tuples containing given value given variable STR3 keeps separate data structure enables validity checks constant time revising indexes dynamically search 31 Structures features The main data structures STR3 following For C C X scpC D X introduce tableC X called subtable C X set tids allowed tuples C involving X posC τ τ relC τ X We implement tableC X simple array indexing starting 1 ith element tableC X denoted tableC X ai We use integer tableC X asep value lies 1 tableC X sep arator tableC X The separator tableC X atableC X asep position known support X C For sake brevity use tableC X instead tableC X atableC X asep The value sep maintained search subject save restore operations For C C introduce invC set tids allowed invalid tuples C posC τ τ relC τ invalid We implement invC sparse set The value invCmembers subject saverestore operations search For C C k 1 relC introduce depC k dependency list associated kth tuple relC If X depC k means tuple τ tupC k provides justiﬁcation present Dc X X depends τ We implement depC k simple array indexing starting 1 sequential iterations basic transfers required The dependency lists altered search maintained subject saverestore operations We introduce stacks denoted stackS S stands Separator stackI I stands Invalid allow store values form tableC X asep invCmembers different levels search Whenever node search tree visited ﬁrst time assumed container placed stackS stackI STR3 ﬁnegrained ﬁltering algorithm meaning ﬁltering process called propagation guided events corresponding deleted values socalled propagation queue Here important attributes STR3 When value X deleted propagation queue This value picked queue later main constraint propagation procedure detailed paper STR3 invoked constraint C X scpC This invocation merges tableC X invC tableC X contains tids tuples involve deleted value X Subsequently STR3 recognizes value Y b GAC C tableC Y b invC The separator tableC X asep useful distinguish regions explored region contains tids tuples relC involving X known invalid unexplored region contain tids tuples examined Each separator moves sequentially end tableC X ﬁxed direction As search progresses explored region expands encompasses set point X proved GAC C To check k tid tuple invalid STR3 tests k invC form isMemberinvC k Whenever tuple tid k invalid STR3 look new support value dependency list depC k 6 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 32 Algorithm Fig 5 Algorithm STR3 We emphasize STR3s sole purpose maintain GAC search 2324 It designed establish GAC standalone For role separate GAC algorithm able enforce GAC scratch required invoked search commences usually preprocessing stage Pseudocode STR3 given Figs 5 6 GACInit lines 19 called ﬁrst remove invalid tuples calling GAC algorithm line 2 initialize data structures In beginning invCmembers set zero remaining tuples valid line 3 separator tableC X set possible index recall start indexing 1 We value X arbitrary dependency list During search STR3 lines 1033 called constraint C time value removed domain variable X involved C Note instantiation variable X effectively invokes STR3C X value present domain X time assignment value assigned X For removed value X tuple tid tableC X invalid STR3 merges tids invC present lines 1215 Values need new supports later processed lines 1932 shall discuss algorithm details Section 5 Upon backtracking functions restoreS restoreI called restore elements tableC X asep invCmembers use stacks stackS stackI Values stored stacks lines 18 30 calling function save 4 Illustration In section trace execution STR3 ternary positive table constraint C scope X Y Z depicted Fig 1a For value table index subtable given Fig 1b After GAC preprocessing separators dependency lists initialized shown Fig 7 The symbol cid9p p number points value position C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 7 Fig 6 Auxiliary functions Algorithm STR3 Fig 7 Status right GAC preprocessing node η1 Subtables dependency lists displayed vertically ﬁgure respectively assigned sep node ηp We denote fact invCmembers assigned value k node ηp placing p column k row titled invCmembers For instance node η1 invCmembers 0 tableC X asep 3 tableC X 3 value separator ranges 1 3 We observe example tableC X 1 4 6 tableC X a3 6 true subtables directly modiﬁed separators change Assume values h o eliminated The result STR3s propagation converges shown Fig 8 In ﬁgures mark domain value deleted putting inside box STR3 eventually merges tids tuples involve values tableC Y h tableC Y tableC Z o invC making invCdense 6 7 8 5 Values depend tuples tids need new supports They 5k8 depC k h o g d b n values h o absent stay positions according condition line 21 STR3 Let look ﬁrst happens g STR3 locates new valid support g tupC 3 The value tableC Y gsep changed 1 0 g transferred depC 5 depC 3 Similar operations performed respect b Now concerning values d n clear support exists Consequently values deleted respective domains continuing exist depC 7 depC 8 cid5 Now suppose search backtracks η1 The result shown Fig 9 The dependency lists depC k unaf fected remain η2 note different initially η1 Fig 7 comparison This example unsynchronized supports discussed section On hand separators invCmembers rolled previous values initially η1 From point suppose e n eliminated Fig 10 shows results STR3 called The tids values indexes 3 8 ﬁrst added invC Values STR3 needs produce new supports cid5 k38 depC k e n g Value removed support Value g stays present 8 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 Fig 8 Status η2 Fig 9 After backtracking η1 Fig 10 Status η3 cause tupC tableC Y g2 tupC 5 support g STR3 moves g depC 3 depC 5 Notice value tableC Y gsep remains unchanged Fig 9 Finally true invalidation tableC X b 8 deprives b support b depC 8 STR3 try ﬁnd new support b As matter fact b depC 2 As result STR3 start seeking new support b tupC 2 invalid 2 Again tableC X refers tableC X atableC X asep C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 9 Fig 11 Transition diagram depicting relationship supports value X STR3 triggered dep fails Both supports X synchronized result 5 Synchronized vs unsynchronized supports cid10 cid10 cid10 Central STR3 relationship separators dependency lists A present value X GAC C cid10 invC Only 1 X depC k k invC 2 tableC X k conditions suﬃcient X proved GAC conditions true STR3 necessarily force expected This ﬂexibility allows STR3 maximum different tid k equal tid k supports value virtually effort doubling chance STR3 avoid seeking new support later This section studies happens k When k k dependency lists separators synchronized X supports X synchronized GACInit initializes separators dependency lists synchronized beginning lines 69 In case role dependency lists straightforward mirrors happens separators As soon tuple tupC k invalid STR3 looks new support value dependency list indexed k depC k line 21 Potential supports value Y b subtable tableC Y b tested invC starting separator subtable lines 2224 If support value removed line 26 STR3 immediately fails value left domain line 27 If new support value current separator recorded backtrack purposes line 30 replaced position new support line 31 Dependency lists updated accordingly line 32 The separators dependency lists remain synchronized backtracking occurs Given X depC k tid k search backtracks depC k remains unperturbed tableC X asep revert previous state possible For reason separators dependency lists longer synchronized X In cases tuples tupC tableC X tupC k diverge distinct supports X C We consider details different circumstances STR3s execution validity tuples later change including cases STR3 reports inconsistency These relationships portrayed Fig 11 We assume tableC X 1 X claim distinct supports trivially unfeasible The diagram explained details follows We consider X depC k tid k invC tableC X k tid k cid10 invC In Fig 11 dep sep failing means k k cid10 cid10 invC respectively There possible transitions cid10 Supports synchronized beginning means k k 1 tupC k invalid STR3 seek new support case Consequently supports remain synchronized albeit tid different k 2 tableC X asep restored previous value This caused backtracking The supports X unsynchronized Suppose distinct supports X point There possible transitions 3 6 7 3 tupC k cid10 invalid tupC k remains valid Because STR3 seeks new valid support X tupC k invalid line 21 needs This happens value b Fig 10 There possible choices state 4 tupC k invalid The search new valid support proceeds usual The dependency lists separators synchronized X newly acquired support exists 5 tableC X asep restored previous value Again caused backtracking X end distinct supports case 2 10 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 6 tupC k cid10 remains valid tupC k invalid X simply shifted dependency list cid10 line 32 Because tupC k cid10 valid second condition line 23 fail depC k depC k cid10 separator pointing k The dependency lists separators synchronized X result In effect remaining support copied fails This happens value g Fig 10 7 tableC X asep restored previous value Same 2 5 Even trigger STR3 seek new support set dependency lists diagram clear cid10 fact provide different sources supports X fails STR3 tupC k tupC k draw support equally fail STR3 start seeking new support In interesting scenario support dependency list fail replaced support successively STR3 having explicitly seek new support The reason STR3 cycle synchronized unsynchronized state repeatedly cases 2 6 limit depth search tree While STR3 starts synchronized supports unsynchronized supports possible Indeed STR3 quires form preprocessing order remove invalid tuples ones remain supports Consider Fig 1 instance After GAC preprocessing tuples tupC 2 tupC 3 tupC 4 recognized supports Z m In line 7 tableC Z msep assigned value 3 ordinary STR3 starts synchronized supports add Z m depC tableC Z m3 depC 4 However tuples tupC 2 tupC 3 tupC 4 supports Z m choose adding Z m depC tableC Z m1 depC 2 depC tableC Z m2 depC 3 Since separator moves cell 1 choosing 1 furthest cell away opposite end natural choice Line 8 changed k tableC X a1 In experiments use variant STR3 starts unsynchronized supports beneﬁting initially supports value Observe separators dependency lists somewhat comparable watched literals 25 introduced SAT However signiﬁcant differences follows To begin given value relevant dependency list activation point working primary support separator serves possible backup separator points tuple valid In contrast watched literals SAT equivalent way For STR3 separators rigid maintain values times dependency lists maintained like watched literals SAT Separators dependency lists synchronized unsynchronized depending circumstances effect providing single support distinct supports SAT watched literals distinct possible 6 Correctness This section proves properties crucial STR3s correctness An invariant taken property remains true search points STR3 enforced necessarily STR3 running For simplicity arrays perceived mathematical sets follows The ﬁrst invariant states dependency lists associated constraint C represent disjoint collection domain values variables scope C Invariant 1 For constraint C C collection sets S depC 1 relC represents partition D cid5 XscpC D X element D set S Proof The invariant holds initially GACInit called Line 32 contains statement affects dependency lists moves element list preserving invariant cid2 The second invariant states invC contains tids invalid tuples relC Invariant 2 For constraint C C invC cid5 XscpCa Dc X tableC X Proof This obvious fact STR3 merges tableC X invC soon X invalid worth emphasizing exactly scpC copies tid distributed different subtables Fig 1b example Line 14 ensures invC include duplicates conforms prerequisite sparse sets The invariant holds backtracking righthand equation cid5 XscpCa Dc X tableC X conditioned domain values lefthand invC controlled invCmembers maintained STR3 cid2 The invariant guarantees support resides explored regions separators We use tableC X aexplored denote tableC X asep 1 size sep tableC X asep size tableC X C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 11 Invariant 3 For C C X scpC Dc X tid support X C exists tableC X aexplored Proof This invariant holds search starts GACInit initially eliminates invalid tuples assigns separators maximum values Afterwards tuple tupC tableC X invalid STR3 scans tableC X new valid support case separator set new value invariant holds If valid support removed separator remains unchanged The invariant holds conditioned present domain When backtrack occurs present invariant holds separator maintained cid2 Finally fourth invariant states values stored dependency lists correspond supports present values Invariant 4 For C C X scpC Dc X X depC k tupC k support X C Proof The invariant holds right GACInit From code tupC k invalid X depC k moved depC k line 32 The invariants associated cid10 preserved If valid tid X invalid The invariant remains true depC k depC k deals present values cid10 different valid tid k cid10 cid10 We look relationship tableC X asep dependency lists backtrack involved If X switches absent present backtrack invariant remains true 1 X removed consequence instantiation X value b cid12 case invariant unaffected 2 chronological backtracking ensures tuple X depended recently restored rolling separators invCmembers An interesting situation happens X present backtracking In case tableC X asep reverted Assume value tableC X k backtrack k This means course X depC k backtrack cid10 backtrack Because backtracking invalidates tuples tuple tupC k Now consider depC k depC k valid backtrack dependency lists maintained X remains depC k For reason invariant depC k true tableC X longer k The invariants involving values depC k backtrack k k cid10 unaffected Next consider happens search moves forward distinct supports That X cid10 cid12 k If tupC k invalid need ﬁnd new support X If cid10cid10 The invari cid10cid10 hold afterward If valid support X remains depC k cid10cid10 valid STR3 merely moves X depC k depC k depC k tableC X k cid10cid10 k exists 1 k ants depC k depC k absent making invariant trivially true cid2 tupC k cid10 cid10 We prove STR3 maintain GAC backtrack search Theorem 1 STR3 maintains GAC Sketch proof We assume standard valuebased propagation framework network GAC fore STR3 called ﬁrst time Two key observations completion proof follows First value deleted propagation queue soon STR3 exhausts possibilities supports Invariant 3 tableC X aexplored tableC X line 26 Second present value valid support This Invariants 1 4 fact present value depends exactly tuple table constraint cid2 7 Complexity Many algorithms repeatedly compute new value old small modiﬁcation computation context An algorithm incremental compute new value scratch exploits old value modiﬁcations environment STR3 designed incremental avoiding repeated domain checks path going root leaf search tree In following analysis consider worstcase accumulated cost single path length m search tree It assumed 1 variable domain size d 2 positive table constraint arity r contains t tuples 3 tables contain invalid tuples STR3 starts Also consider d t value D X initially appear tables involving variable X Theorem 2 The worstcase space complexity STR3 O rt mrd constraint Proof There main data structures STR3 table inv dep According Invariant 1 space complexity dep O rd For inv O t O rt table For managing restoration data structures stackI O m stackS O mrd assuming need record information m levels The total cost O rd t t rt m mrd O rt mrd cid2 12 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 Theorem 3 The worstcase time complexity STR3 single path length m search tree O rt m constraint Proof STR3s operations seen point view main data structures table inv dep We consider order For value stays present path cost STR3 tableC X O tableC X aexplored If absent extra cost merging rest tableC X invC line 12 O tableC X a1 sep O In tableC X O rt O tableC X The cases The maximum size invC t Because invC implemented sparse set adding member takes O 1 time XscpCaD X total cost cost cid6 The size invC grow path cost STR3 dealing invC O t Lastly consider cost associated dependency lists When tuple tupC k invalid el ement depC k processed shifted necessary For value X shifted tableC X times Because dependency list depC k processed sequentially path total cost O tableC X O rt cid6 XscpCaD X The worstcase time complexity STR3 single path O rt t rt m O rt m statements ﬁxed costs O 1 node cid2 As case disjoint set union operations 26 cascading series transfers dependency lists num ber elements moved keeps growing conceivable This bearing complexity cost associated dependency lists O rt argument noted cascading cost small limited size list depC k holds r elements It follows worst r1 k1 k O r2 Incidentally practical upper bound case cost monotonically increasing series transfers O operations involving dependency lists closer O rd lower bound O rt absent values dependency lists touched line 21 cid6 Property 1 The worstcase time complexity single path length m search tree O rtm STR2 constraint Reasoning Recall STR2 improves standard STR1 major ways First X disregarded Dc X fully supported Second validity check necessary X known change domain X time STR2 called Because STR2 sensitive ordering build table constraint search path 1 STR2 involves domain reduction exactly value domain second improvement useless 2 STR2 eliminates exactly tuple end table As result cost O i1 rt O rtm m cid13 t cid2 It shown similar fashion MDDc 12 tries 21 pathoptimal On hand backtrack cid6 m costs O rd worstcase STR3 O r STR2 8 STR3 circular seek Gent 13 reported seeking element array circular fashion backtracking search proved optimal cost amortized In words theoretical difference traditional optimal procedure cursors position saved restored backtrack The circular approach factor slower worst case experiments SAT solvers faster practice 13 Because STR3 based incremental scans subtables cursors separators circularly The question STR3 circular seek remains optimal This section addresses variation STR3 respect correctness optimality performance Pseudocode STR3 circular seek STR3circ given Fig 12 Differences ordinary STR3 d1 The search supports performed line 22 24 Fig 5 modiﬁed accommodate circular seek line 13 21 Fig 12 The routine restoreS trailing separators line 30 Algorithm STR3 Fig 5 longer needed d2 The condition forloop line 12 Algorithm STR3 Fig 5 changed The result shown line 3 Fig 12 Theorem 4 STR3circ maintains GAC Sketch proof STR3circs correctness derived STR3s differences accounted follows Case d1 The circular guarantees variable X assigned value b cid12 condition value removed absence support subtable involving X Because separators maintained C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 13 Fig 12 STR3 circular seek Only main procedure STR3circ shown true X depC k tableC X asep k That separators dependency lists synchronized Invariant 4 holds result Case d2 In STR3 subarray tableC X aexplored contains tids invalid tuples sepa rators maintained In STR3circ longer true Every tid table checked invC effect invC STR3s cid2 Theorem 5 The worst case time complexity STR3circ single path length m search tree O rt m constraint Proof We need look operations involving table ones involving dep inv unchanged STR3 For value X stays present single path cost circular scan tableC X O tableC X according Theorem 13 13 If absent extra cost merging tableC X invC line 3 Fig 12 The cost O tableC X tableC X O tableC X case Summing X makes ﬁnal complexity O rt m factor m includes O 1 costs node cid2 Proposition 14 13 indicates overheads circular constant factor larger trailing separators For STR3circ cost merging tableC X absent value mentioned proof O rt total Thus time complexity STR3circ hides constant factor larger STR3s Our experiments STR3circ slower STR2 STR3 problem instance tested 9 Related works A number ﬁnegrained GAC algorithms proposed literature example AC5 27 AC6 28 AC7 29 GAC4 4 AC5TCTr 14 In section discuss connections existing GAC4 AC5TCTr STR3 optimal closely related algorithms 14 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 Fig 13 Algorithm GAC4 Fig 14 Data structures GAC4 constraint C scpC X Y Z 91 GAC4 GAC4 4 generalized version AC4 3 nonbinary constraints The pseudocode propagation portion GAC4 given Fig 13 GAC4s approach propagation based incremental reduction support lists list supports value X constraint C denoted supC X When value X absent tuple τ involving value invalid Because support values supC Y τ Y Y cid12 X updated A value X longer support constraint C supC X It removed Dc X queue Q processing In order time complexity optimal proposed 4 list supports implemented doubly linked list Removing element support list takes O 1 time The use additional data structure containing pointers elements support lists suggested elements accessed O 1 time speciﬁcally twodimensional array ptrC size relC scpC For tuple tupC k 1 k relC ptrCk onedimensional array size r scpC X1 Xr 1 r tupC k Xi ptrCki points node supC Xi value k Fig 14 illustrates ternary constraint C scpC X Y Z Although attractive admitting optimal time complexity GAC4 remains basically standalone GAC algorithm Indeed provision ﬁltering step backtracking search simple adaptation trailing relevant data structures sup ptr case This incurs overheads unclear costly maintenance practice MGAC4 reported experiment far aware However note GAC4 remains useful precaching supports considered worthwhile For instance extension GAC4 employed ﬁnd form interchangeable values interactive conﬁguration problems 30 92 AC5TCTr Several optimal GAC algorithms table constraints described 1431 As representative example focus attention AC5TCTr 14 31 comprehensive treatment GAC algorithms table constraints based AC5 structure 27 We provide pseudocode key procedure AC5TCTr Fig 15 explain function follows C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 15 Fig 15 Algorithm AC5TCTr In AC5TCTr support list C value X dynamically maintained doubly linked list headed FSC X ﬁrst support elements connected pointers nextTr predTr Both pointers satisfy following invariants variable X scpC tuple tupC 1 t relC cid7 nextTrC X min cid8 j j tupC jX tupC iX cid9 tupC DX Q C cid10 tupC j DX Q C cid8 predTr cid9 C X nextTrC X D X Q C denotes local view domain D X respect propagation queue Q deﬁned D X Q C D X C X Q For V X DV Q C V X DV Q C Furthermore FSC X satisfy following invariant value cid17 largest value smallest FSC X tupC iX cid12 cid17 tupC D j tupC jX tupC j D scpC Q C cid8 scpC Q C cid9 cid9 cid2 cid8 valRemoveTCTr primary function AC5TCTr deals consequences removal value X respect constraint C When X absent function goes tuple τ support list X updates support list value Y b contains τ The idea fundamentally MGAC4 operations doubly linked lists spelled One important difference data structure ptr Indeed use ptr forward 4 actually necessary tuples grouped domain values given variable That assuming total order relC nextTrC X predTrC X return unique tuples row positions Thus previous tuples referred directly pieces information row X column valRemoveTCTr STR3 AC5TCTr achieve pathoptimality different routes Both algorithms based concept support lists STR3 works exclusively row indexes Traversals lists analogous doubly linked lists AC5TCTr table STR3 We discuss differences rest section Indicators ﬁrst valid supports The data structure FS plays role AC5TCTr sep STR3 Both mark earliest valid support according ordering relC Due representation STR3 needs dep reverse pointer addition sep Because dep need trailing STR3 able sidestep AC5TCTrs efforts However notion replicated AC5TCTr adding similar data structure case serves purely residues 32 Overheads doubly linked lists Besides obvious extra traversal cost doubly linked lists important concern maintenance overheads backtracks AC5TCTr track positions removed elements depth search removals happen Should backtracks occur AC5TCTr use information order restore elements original positions These removals consecutive restorations expensive simple STR3s trailing mechanism Centralization invalid tuples STR3 takes lazy approach partitioning support list contiguous parts explored region known valid support unexplored region The regions separated cursor As result tuple proved invalid remembered fact recalled later unknown region examined To end STR3 channels handling invalid tuples centralized 16 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 facility inv By contrast AC5TCTr actively maintains support lists tuple invalid immediately removed involving support lists encountered future Local views granularity invariants AC5TCTr derived AC5 framework correctness stems turn invariants data structures These invariants differ STR3s respects First AC5 deal local views instead current domains Invariants hold values absent remain local views instance invariant FS maintained absent values By contrast STR3 suspends operations value absent Second AC5s invariants hold point value X dequeued processed STR3s invariants hand coarser During search hold point STR3 completely executed execution ﬁltering converged ﬁxed point Finally STR3 regarded improved version AC5TCSparse previously called AC5TCCutoff 14 additional data structure introduced recording supports avoids restoring checking operations extent 10 Experimental results In order practical STR3 conducted experimentation solver AbsCon cluster biquad cores Xeon processors 266 GHz 16 GB RAM Linux We compared STR3 ﬁrst classical STR variants related GAC algorithms developed table constraints For experiments backtrack search algorithm called MAC maintains GAC search equipped variable ordering heuristic domddeg 5 value ordering heuristic lexico For tested problem instance searched ﬁnd solution prove solution exists 1200 seconds It important note chosen heuristics guarantee explore search tree regardless ﬁltering algorithm contrary example domwdeg 33 101 STR3 versus STR2 comparison problem series Because shown STR2 stateoftheart series instances 11 compared respec tive behavior STR3 STR2 Also included baseline results obtained original STR algorithm proposed Ullmann 10 referred STR1 First considered classical series instances3 involving positive table constraints arity greater 2 We brief description series The Crossword puzzle involves ﬁlling blank grid words speciﬁed dictionary We series instances called crosswordslex crosswordsuk crosswordswords crosswordsogd generated set grids black square called Vg dictionaries called lex uk words ogd Dictionaries lex words small uk ogd large The arity constraints given size grids example crosswordsogd56 involves table constraints arity 5 6 grid 5 6 A Renault Megane conﬁguration problem converted symbolic domains numeric ones introduced 34 The series renaultmod contains instances generated original introducing form perturbation Such instances involve domains containing 42 values constraints large arity 8 10 largest table contains 50 000 6tuples A Nonogram built rectangular grid requires ﬁlling squares unique feasible way according clues given row column Such clues modeled table constraints Constraint typically large arities grid size r c r constraints arity c c constraints arity r The size tables vary accordingly size grids speciﬁed clues tables contain tuples largest ones usually contain tens hundreds thousands tuples The series nonogram corresponds instances introduced 35 Table constraints naturally derived BDDs MDDs Series bdd1521 bdd1821 introduced 22 contains instances table constraints arity 15 size 2713 contain instances table constraints arity 18 size 133 Series mdd72505 mdd72509 contain instances constraints arity 7 derived MDDs built postorder manner speciﬁed probability p controls likely previously created subMDD reused 12 For ﬁrst series called mddhalf probability p 05 09 second Series denoted randrn stand random instances instance involves n variables constraints arity r The series rand320 rand512 rand820 rand1060 permit experiment random instances arity arity 3 10 3 Available wwwcrilunivartoisfrCSC09 wwwcrilfrlecoutrebenchmarkshtml C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 17 Table 1 Mean CPU time seconds solve instances different series timeout 1200 seconds set instance MAC Series crosswordslex avgP 102 avgS 328 crosswordsogd avgP 232 avgS 6070 crosswordsuk avgP 189 avgS 1500 crosswordswords avgP 119 avgS 637 renaultmod avgP 278 avgS 139 nonogram avgP 97 avgS 767 bdd1521 avgP 67 avgS 466 bdd1821 avgP 61 avgS 3547 mdd72505 avgP 08 avgS 348 mdd72509 avgP 59 avgS 2351 rand320 avgP 76 avgS 221 rand512 avgP 244 avgS 3048 rand820 avgP 02 avgS 191 rand1060 avgP 230 avgS 11 750 18 18 25 23 27 44 35 35 5 9 50 50 18 19 CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem STR1 199 137M 974 123M 985 126M 628 138M 311 153M 187 361M 640 219M 239 181M 222 264M 1540 266M 122 143M 598 259M 252 221M 352 248M STR2 128 137M 400 145M 453 141M 374 138M 234 153M 94 386M 198 224M 72 182M 130 265M 100 267M 93 143M 389 259M 147 221M 191 248M STR3 126 144M 250 236M 431 183M 365 150M 206 179M 182 734M 607 2049M 142 1043M 621 500M 105 508M 79 159M 151 485M 248 379M 917 457M The results shall present include following metrics CPU time seconds note CPU time STR3 includes preprocessing step STR2 employed memory mem usage MB avgP average proportion ratio size current table size initial table averaged table constraints nodes search tree relative value avgS average size size current table averaged table constraints nodes search tree absolute value In order avoid noise generated easy instances decided discard results instances systematically solved 3 seconds embedding ﬁltering algorithm Table 1 shows mean results series Following series number tested instances corre sponds number instances easy mentioned diﬃcult solved MAC 1200 seconds algorithms A ﬁrst observation STR3 requires average times memory STR2 memory expected better worstcase complexity suggests A second observation results vary widely STR2 STR3 respectively best approaches dif ferent series nonogram bdd1521 bdd1821 mdd72505 rand820 STR2 crosswordsogd rand320 rand512 rand1060 STR3 On series gap STR2 STR3 signiﬁcant Table 2 gives details representative instances What interesting note looking Tables 1 2 appears correlation values avgP avgS ranking STR2 STR3 higher values avgP avgS competitive STR3 Note instances Table 2 ranked according values avgP 05 512 structured instances 02 25 6 random instances order transition apparent Intuitively higher values avgP avgS imply fewer chances solver reach deeper levels search tree turn suggests connection unsatisﬁability To conﬁrm hypothesis Table 3 divides crossword instances series taken according satisﬁability avgP threshold pragmatically set 10 avgS threshold pragmat ically set 1000 Clearly appears STR3 best approach tables reduced proportion andor size average contrary STR2 For example 46 Crossword instances avgS 1000 STR2 20 speedier STR3 39 Crossword instances avgS 1000 STR3 40 speedier STR2 18 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 Table 2 Detailed results selected instances sorted avgP The symbol indicates timeout STR1 STR2 STR3 Structured instances crosswordsogd69 sat avgP 05 avgS 227 mdd725052 sat avgP 12 avgS 467 bdd15217 unsat avgP 36 avgS 254 nonogram143 sat avgP 54 avgS 320 crosswordsogd1113 unsat avgP 107 avgS 5144 nonogram65 sat avgP 194 avgS 453 crosswordsogd1414 unsat avgP 318 avgS 7491 renault27 unsat avgP 512 avgS 223 Random instances rand8208 sat avgP 02 avgS 175 rand3201 sat avgP 46 avgS 136 rand32026 sat avgP 71 avgS 205 rand32018 unsat avgP 125 avgS 349 rand51226 unsat avgP 254 avgS 3167 rand10605 unsat avgP 256 avgS 13 141 CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem 132 148M 228 264M 821 220M 117 413M 646 159M 537 144M 214 151M 862 222M 227 144M 243 144M 635 143M 552 259M 319 248M 79 148M 123 264M 245 225M 76 422M 1086 157M 173 163M 210 145M 156 151M 468 222M 173 144M 178 144M 511 143M 317 259M 114 248M 257 202M 532 500M 114 2063M 185 875M 762 294M 109 205M 12 236M 113 178M 565 380M 171 161M 135 159M 382 158M 133 486M 576 457M Table 3 Mean CPU time seconds solve Crossword instances timeout 1200 seconds set instance MAC sat unsat avgP 10 avgP 10 avgS 1000 avgP 1000 14 71 34 51 46 39 STR1 189 152 939 154 443 231 STR2 115 689 508 652 267 980 STR3 310 528 567 443 321 695 Next tried push limit Crossword benchmarks new dictionary crosswordsogd08 twice larger ogd largest dictionaries mentioned previously There 807 624 words ogd08 versus 435 705 ogd Most instances extreme cases 45 instances timedout algorithms tested 12 trivially solved ﬁnished STR2 STR3 3 seconds The remaining instances shown Table 4 order grid size arity Here clearly transition satisﬁable instances low avgP avgS values unsatisﬁable instances high avgP avgS values STR2 faster 4 ﬁrst instances STR3 faster 4 instances While immediately clear factors involved concerning table reduction thing certain know time variable X assigned value tuples involving removed table constraint involving X making avgP constraint low result We seen surprising number benchmarks tables virtually wiped simple tabular reduction percent initial tuples remained average variable instantiation play outsized role regard We introduce benchmark instantiation localized minimal effect overall table reduction A pigeonhole problem size k composed k variables 0 k 1 domain variables connected binary inequality constraint making problem unsatisﬁable Unlike benchmarks pigeonhole problem allows tables reduced gradually search variable directly involved instantiated An augmented pigeonhole phk j adds extra jary table j new variables k variables chain The extra variables larger domains prevent variable ordering heuristic picking prematurely heuristics involving domain size extra tables C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 19 Table 4 Results crossword puzzles ogd08 dictionary The symbol indicates timing crosswordsogd0868 sat avgP 02 avgS 143 crosswordsogd0869 sat avgP 02 avgS 157 crosswordsogd0877 sat avgP 04 avgS 238 crosswordsogd0878 sat avgP 03 avgS 187 crosswordsogd081517 unsat avgP 200 avgS 3657 crosswordsogd081519 unsat avgP 249 avgS 3908 crosswordsogd081619 unsat avgP 144 avgS 1361 crosswordsogd081620 unsat avgP 192 avgS 1712 Table 5 Results augmented pigeonhole problems ph69 unsat avgP 652 avgS 1273K ph77 unsat avgP 547 avgS 153K ph78 unsat avgP 547 avgS 919K ph86 unsat avgP 470 avgS 55 293 ph87 unsat avgP 470 avgS 387K ph95 unsat avgP 411 avgS 13 479 ph96 unsat avgP 411 avgS 108K ph104 unsat avgP 366 avgS 2399 ph113 unsat avgP 329 avgS 329 CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem CPU mem STR1 214 349M 128 341M 241 273M 414 273M 778 273M 226 273M STR1 203 551M 117 65M 739 422 251 33M 1956 207M 443 18M 389 32M 628 15M 864 10M STR2 178 349M 851 341M 187 273M 888 409M 1174 341M 152 273M 346 273M 964 273M STR2 106 547M 62 62M 376 422M 126 33M 993 207M 234 18M 201 32M 339 15M 638 10M STR3 559 409M 518 477M 494 341M 735 477M 103 417M 287 409M 902 409M STR3 84 1751M 48 290M 268 1146M 51 126M 711 631M 79 40M 149 227M 173 21M 395 21M loose Variable heuristics steered picking variables unsatisﬁable core ﬁrst priority Results shown Table 5 clear STR3 eﬃcient high values avgP avgS 102 STR3 versus STR2 overall comparison We present scatter plots provide overall insight respective behaviors STR2 STR3 We use large set 2005 instances including series introduced earlier series instances introduced 31 http becool info ucl ac resources series instances introduced 36 series instances introduced 35 problem kakuro In plot dot represents instance coordinates deﬁned horizontal axis CPU time required solve instance STR2 vertical axis CPU time required solve instance STR3 Thus dot line x y corresponds instance solved eﬃciently STR3 dot line x y corresponds instance solved eﬃciently STR2 Fig 16 depicts ﬁrst scatter plot results obtained STR2 STR3 MAC set 2005 instances This scatter plot conﬁrms STR2 STR3 complementary evidently seriesinstances STR2 faster STR3 ones STR3 faster STR2 Figs 17 18 19 compare performance STR2 vs STR3 respect satisﬁability value avgP value avgS Finally Fig 20 plots relative eﬃciency STR2 STR3 respect value avgS considering 2005 instances experimental study On cases tables remain large 1000 STR3 36 faster STR2 20 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 Fig 16 Pairwise comparison CPU time 2005 instances series involving table constraints The timeout solve instance 1200 seconds 103 STR3 versus STR2 comparison classes random problems In following set experiments focus classes random problems starting phase transition We generated different classes instances Model RD 37 Each generated class r 60 2 20 t contains instances involving 60 Boolean variables 20 rary constraints tightness t Provided arity r constraints greater equal 8 Theorem 2 37 holds asymptotic phase transition guaranteed threshold point tcr 0875 It means hardest instances generated tightness t close tcr Fig 21a shows mean CPU time required MAC solve 20 instances class 13 60 2 20 t t ranges 08 096 On instances intermediate diﬃculty observe STR3 worse STR1 Results different classes r follow pattern Closer inspection reveals avgP class low especially phase transition avgP 4 For random problems metric avgP higher instances generated lie phase transition area theoretical guarantee hardness So generated classes underconstrained instances Each generated class 5 12 12 200 t contains instances involving 12 variables 12 possible values 200 constraints arity 5 tightness t Fig 21b shows mean CPU time required MAC solve 10 instances class 5 12 12 200 t t ranges 051 099 size tables ranges 121 928 t 051 2488 t 099 On instances diﬃculty decreases tightness observe STR3 far better STR2 Indeed values avgS avgP large avgS ranges 1093 8170 avgP reach 43 104 Comparison GAC algorithms As mentioned Section 9 STR3 GAC4 optimal ﬁltering algorithms However overhead maintaining data structures GAC4 search signiﬁcant To conﬁrm implemented GAC4 MAC simply trailing relevant data structures Fig 22 depicts scatter plot results obtained STR3 GAC4 MAC set 2005 instances involving table constraints This scatter plot clearly shows GAC4 largely outperformed STR3 Note crosses appear right ﬁgure x 1200 They correspond instances timed GAC4 AC5TC proposed recently 31 optimal algorithm However solver AbsCon use permit current shape implement easily type algorithms This reason present Table 6 excerpt kind permission authors results obtained Mairy Van Hentenryck Deville solver Comet As mentioned paper observed Table 6 STR2 STR3 MDDc outperform AC5TC table constraints large arity greater 4 However constraints arity 3 4 AC5TC shown fast details 31 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 21 Fig 17 Comparison CPU time STR2 STR3 instances respectively satisﬁable unsatisﬁable The reader aware compressionbased ﬁltering algorithms remain appropriate compression highly effective This shown 3822391236 Typically compression ratio high algorithm MDDc outperforms STR algorithms There wellknown binary encodings nonbinary constraint networks called dual encoding 40 hidden variable encoding 41 double encoding 42 One wonder classical generic AC algorithm applied encodings competitive simple tabular reduction Actually studied 11 22 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 Fig 18 Comparison CPU time STR2 STR3 instances avgP respectively greater 10 respect STR2 shown paper dual double encodings rapidly run memory STR2 usually times faster AC3bitrm 43 HAC 42 hidden variable encoding Finally like ﬁnish presentation experimental results binary problems Most recent works ﬁltering table constraints concentrate solely nonbinary constraints binary constraints extensional form tables Only 31 published clear compressionbased STR methods competitive generic binary AC algorithms AC3rm 44 AC3bitrm 43 We conﬁrm ﬁndings results Table 7 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 23 Fig 19 Comparison CPU time STR2 STR3 instances avgS respectively greater 1000 11 Conclusions We introduced STR3 new GAC algorithm positive table constraints competitive complementary STR2 stateoftheart algorithm STR3 able completely avoid unnecessary traversal tables Along AC5TC 31 STR3 pathoptimal GAC algorithms reported far Unlike AC5TCs performance declines arity increases STR3s consistent wide range arity Indeed shown corre lates average proportion avgP number avgS tuples remaining tables search Compared STR2 24 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 Fig 20 The ratio cpu STR2 cpu STR3 plotted avgS average size tables search Dots correspond instances solved algorithms MAC set 2005 instances benchmark Table 6 Results obtained AC5TC version OptSparse MDDc classical se ries instances involving table constraints large arity Values correspond CPU times given percentage best This table excerpt Table 10 31 AC5TC MDDc STR2 STR3 crosswordslex crosswordsogd crosswordsuk crosswordswords renaultmod 116 249 247 155 141 293 704 713 328 332 121 162 135 138 100 100 100 100 100 193 Table 7 Mean CPU time seconds solve selected binary problems blackhole44 bqwh18141 composed driver ehi85 frb4521r geom5020 qcp10 qwh15 rand240 10 100 14 7 90 10 100 10 10 698 AC3bitrm 091 179 47 7 477 91 363 131 206 542 AC3rm 110 206 623 85 637 168 67 158 252 74 MDDc 124 335 105 227 72 290 123 293 394 219 STR2 142 458 119 565 127 300 126 43 549 189 STR3 181 711 164 211 340 317 141 725 141 188 STR3 faster problems avgP avgS low Interestingly advantage STR2 appears depend largely excessively high rates table reduction low avgP As soon reduction rate drops 90 STR2 effective Another dividing line satisﬁability STR3 stronger unsatisﬁable problems weaker satisﬁable problems STR2 opposite STR3 instance ﬁnegrained algorithms propagation guided deleted values Both STR2 STR3 extended handle compressed tuples ctuples 36 While STR3 complex STR2 implemented algorithm easier extend based notion checking tuples validity result routine C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 25 Fig 21 Mean search cost solving instances random classes MAC involving validity test needs modiﬁcation By contrast STR2 process tuple twice different manners testing validity collecting values components Extending STR2 cope ctuples twice complicated conceptually This true ﬁnegrained vs coarsegrained propagation general In recent years STR2 incorporated algorithms 4548 remains seen STR3 adopted similar fashion The work extends STR2 STR3 ctuples 36 start direction 26 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 Fig 22 Pairwise comparison CPU time 2005 instances series involving table constraints The timeout solve instance 1200 seconds Acknowledgements We thank Julian Ullmann reading manuscript providing useful critical comments This work sup ported grant MOE2012T21155 The ﬁrst author beneﬁts ﬁnancial support CNRS OSEO BPI France ISI project Pajero References 1 C Lecoutre C Likitvivatanavong RHC Yap A pathoptimal GAC algorithm table constraints Proceedings ECAI12 Montpellier France 2012 pp 510515 2 AK Mackworth Consistency networks relations Artif Intell 8 1 1977 99118 3 R Mohr TC Henderson Arc path consistency revisited Artif Intell 28 2 1986 225233 4 R Mohr G Masini Good old discrete relaxation Proceedings ECAI88 Munich Germany 1988 pp 651656 5 D Sabin EC Freuder Contradicting conventional wisdom constraint satisfaction Proceedings CP94 Orcas Island USA 1994 pp 1020 6 C Bessière JC Régin Arc consistency general constraint networks preliminary results Proceedings IJCAI97 Nagoya Japan 1997 pp 398404 7 O Lhomme JC Régin A fast arc consistency algorithm nary constraints Proceedings AAAI05 Pittsburgh Pennsylvania 2005 pp 405410 8 C Lecoutre R Szymanek Generalized arc consistency positive table constraints Proceedings CP06 Nantes France 2006 pp 284298 9 C Bessière JC Régin RHC Yap Y Zhang An optimal coarsegrained arc consistency algorithm Artif Intell 165 2 2005 165185 10 JR Ullmann Partition search nonbinary constraint satisfaction Inf Sci 177 18 2007 36393678 11 C Lecoutre STR2 optimized simple tabular reduction table constraints Constraints 16 4 2011 341371 12 KCK Cheng RHC Yap An MDDbased generalized arc consistency algorithm positive negative table constraints global constraints Constraints 15 2 2010 265304 13 IP Gent Optimal implementation watched literals general techniques J Artif Intell Res 48 2013 231252 14 JB Mairy PV Hentenryck Y Deville An optimal ﬁltering algorithm table constraints Proceedings CP12 Quebec City Canada 2012 pp 496511 15 D Sabin EC Freuder Contradicting conventional wisdom constraint satisfaction Proceedings ECAI94 Amsterdam The Netherlands 1994 pp 125129 16 M Stonebraker G Held E Wong P Kreps The design implementation INGRES ACM Trans Database Syst 1 3 1976 189222 17 MM Astrahan MW Blasgen DD Chamberlin KP Eswaran JN Gray PP Griﬃths WF King RA Lorie PR McJones JW Mehl GR Putzolu IL Traiger BW Wade V Watson System R relational approach database management ACM Trans Database Syst 1 2 1976 97137 18 P Briggs L Torczon An eﬃcient representation sparse sets ACM Lett Program Lang Syst 2 14 1993 5969 19 V le Clément SaintMarcq P Schauss C Solnon C Lecoutre Sparsesets domain implementation Proceedings CP13 Workshop Techniques Implementing Constraint Programming Systems TRICS13 Uppsala Sweden 2013 20 G Gange PJ Stuckey V Lagoon Fast set bounds propagation BDDSAT hybrid J Artif Intell Res 38 2010 307338 21 IP Gent C Jefferson I Miguel P Nightingale Data structures generalised arc consistency extensional constraints Proceedings AAAI07 Vancouver Canada 2007 pp 191197 22 KCK Cheng RHC Yap Maintaining generalized arc consistency ad hoc nary boolean constraints Proceedings ECAI06 Trento Italy 2006 pp 7882 23 C Likitvivatanavong Y Zhang S Shannon J Bowen EC Freuder Arc consistency search Proceedings IJCAI07 Hyderabad India 2007 pp 137142 2008 319 pp 146150 2002 199234 173210 2007 514534 C Lecoutre et al Artiﬁcial Intelligence 220 2015 127 27 24 C Likitvivatanavong Y Zhang J Bowen EC Freuder Arc consistency MAC new perspective Proceedings CP04 Workshop Constraint Propagation Implementation CPAI04 Toronto Canada 2004 pp 93108 25 MW Moskewisz CF Madigan Y Zhao L Zhang S Malik Chaff engineering eﬃcient SAT solver Proceedings DAC2001 Las Vegas NV 2001 pp 530535 26 TH Cormen CE Leiserson RL Rivest C Stein Introduction Algorithms edition The MIT Press 2009 27 PV Hentenryck Y Deville C Teng A generic arcconsistency algorithm specializations Artif Intell 57 23 1992 291321 28 C Bessière MO Cordier Arcconsistency arcconsistency Proceedings AAAI93 Washington DC 1993 pp 108113 29 C Bessière EC Freuder JC Régin Using constraint metaknowledge reduce arc consistency computation Artif Intell 107 1 1999 125148 30 C Becker H Fargier Maintaining alternative values constraintbased conﬁguration Proceedings IJCAI13 Beijing China 2013 pp 454460 31 JB Mairy PV Hentenryck Y Deville Optimal eﬃcient ﬁltering algorithms table constraints Constraints 19 1 2014 77120 32 C Lecoutre C Likitvivatanavong SG Shannon RHC Yap Y Zhang Maintaining arc consistency multiple residues Constraint Program Lett 2 33 F Boussemart F Hemery C Lecoutre L Sais Boosting systematic search weighting constraints Proceedings ECAI04 Valencia Spain 2004 34 J Amilhastre H Fargier P Marquis Consistency restoration explanations dynamic CSPs application conﬁguration Artif Intell 135 12 35 G Pesant CG Quimper A Zanarini Countingbased search branching heuristics constraint satisfaction problems J Artif Intell Res 43 2012 36 W Xia RHC Yap Optimizing STR algorithm tuple compression Proceedings CP13 Uppsala Sweden 2013 pp 724732 37 K Xu F Boussemart F Hemery C Lecoutre Random constraint satisfaction easy generation hard satisﬁable instances Artif Intell 171 89 38 G Katsirelos T Walsh A compression algorithm large arity extensional constraints Proceedings CP07 Providence Rhode Island 2007 pp 379393 39 KCK Cheng RHC Yap Maintaining generalized arc consistency ad hoc rary constraints Proceedings CP08 Sydney Australia 2008 pp 509523 40 R Dechter J Pearl Tree clustering constraint networks Artif Intell 38 3 1989 353366 41 F Rossi C Petrie V Dhar On equivalence constraint satisfaction problems Proceedings ECAI90 Stockholm Sweden 1990 pp 550556 42 K Stergiou T Walsh Encodings nonbinary constraint satisfaction problems Proceedings AAAI99 Orlando Florida 1999 pp 163168 43 C Lecoutre J Vion Enforcing arc consistency bitwise operations Constraint Program Lett 2 2008 2135 44 C Lecoutre F Hemery A study residual supports arc consistency Proceedings IJCAI07 Hyderabad India 2007 pp 125130 45 C Lecoutre A Paparrizou K Stergiou Extending STR higherorder consistency Proceedings AAAI13 Washington US 2013 pp 576582 46 C Jefferson P Nightingale Extending simple tabular reduction short supports Proceedings IJCAI13 Beijing China 2013 pp 573579 47 C Bessière H Fargier C Lecoutre Global inverse consistency interactive constraint satisfaction Proceedings CP13 Uppsala Sweden 2013 48 N Gharbi F Hemery C Lecoutre O Roussel Sliced table constraints combining compression tabular reduction Proceedings CPAIOR14 pp 159174 Cork Ireland 2014 pp 120135 49 C Lecoutre C Likitvivatanavong RHC Yap Improving lower bound simple tabular reduction Constraints 2015