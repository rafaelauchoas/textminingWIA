ELSEVIER Artificial Intelligence 74 1995 5581 Artificial Intelligence Inductive functional programming incremental program transformation Roland Olsson Department Computer Science fold College OS Alle 9 1777 Halden Norway Received April 1993 revised March 1994 Abstract The paper presents ADATE automatic functional programming ADATE uses specifications contain constraints programs synthesized allow wide range correct programs ADATE generate novel unexpected recursive programs automatic invention recursive auxiliary functions Successively better programs developed incremental program transformations A key success ADATE exact design transformations systematically search appropriate transformation sequences 1 Introduction This paper reports ADATE synthesizes recursive Standard ML programs specification consisting sample inputs output evaluation function The ADATE Automatic Design Algorithms Through Evolution dicates goal research automatic invention new algorithms automatic implementation algorithms ADATE user knows One major dimension differentiate inductive inference systems information specifications employ At extreme 11 At end spectrum systems use traces computations systems requiring specifications consist inputoutput pairs 28 lo positive In systems negative examples inductive logic programming 67912 inputoutput pairs examples structure corresponds specific algorithm Email RolandOlssonhiofno 00043702950950 1995 Elsevier Science BV All rights reserved SSDIOOO4370294000425 56 R OlssonArtifcial Intelligence 74 1995 5581 ratio At end spectrum genetic algorithm 51 ADAm use specifications difficulty writing desirable program difficulty specification enormous An important difference recursive ADATE GA systems search programs program space poor inferring use primitive program unsystematic GA systems transformations syntactic complexity space Section 3 presents search program Section 2 explains specify programs gives measures program quality time complexity These measures correctness subset Standard guide ML inferred programs written Programs synthesized incremental transformations replace ment function type embedding The overall strategy program space given Section 5 This strategy based iterative searching details experimental deepening results The section discusses related ADATE The final section contains merits drawbacks ADATE directions 41 Sections 6 7 list implementation systems Section 4 These transformations discussed abstraction future research casedistribution expression inference inductive 2 Specification selection programs A specification wants program chosen specification implicitly defines set C correct programs The specification writer set D desirable programs Some requirements 1 The specification easy possible write preferably simpler desirable program 2 The specification 3 All desirable programs facilitate efficient inference correct according specification D C C 4 A correct reasonably quickly able decide given program 1 2 conflict One main goal research presented simple possible The efficiency possible computers inferences Requirements paper allow specifications goal generally available A specification interesting 1993 satisfies requirement eliminate requirement contain constraints loose Even comparison programs simple wellknown NPhard problems construct employ sample inputs output evaluation 4 satisfied satisfy function 3 said loose A loose specification desirable programs ADATE specifications specifications For example specifications Example 21 Assume specification writer knows minimum I It easy construct nodes Here simple specification program P I large instance traveling salesman problem cycle time On n total number length ii Hamiltonian instance R OlssonArtijicial Intelligence 74 1995 5581 57 Given input I P required output Hamiltonian cycle C length n2106 CPU seconds Note takes time On check C Hamiltonian cycle length Lt The correctness P decidable time 0n2106 On 0n2 P extremely difficult The Journal Algorithms maintains list hundreds NPcomplete problems construct similar specifications 21 Specijcation form Assume specification check synthesized ML program P P definition function f approximation desirable function An ADAm specification consists 1 set types 2 3 4 set sample inputs It 12 Z I evaluation 5 output primitive functions inferred programs type f function oe uses set Zt f II ZYIZYI torate P The sample inputs need chosen incremental inference facilitated This means inputs contain sufficiently special cases The sample inputs specification list sorting program example include list singleton list sorted list random lists One interesting progression difficult sample inputs problems mathematics textbooks rang ing grade elementary school university level Even specification writer need pedagogical authors textbooks sample inputs need carefully chosen It important specifications required based inputoutput pairs We identified following problems inputoutput pair specifications Problems 1 The choice output reflects particular algorithm construct The specification writer needs know algorithm able provide output An inference naturally useful writer required know algorithm inferred 2 Looseness lost pairs include possible outputs given input 3 An inputoutput pair specification grades output correct wrong It desirable use grades For example grades real numbers interval 4 It difficult user provide optimal outputs Here examples example number illustrates problem number 58 Examples R OlwmArticial Intelligence 74 1995 5581 1 Consider specification function split list list list splits list Xs pair lists Ys Zs lengths Ys Zs differ The split useful implementing merge sort The inputoutput function pair 123456781 ll234lC5678l reflects particular algorithm obviously Zs second half However faster chooses Ys half Xs simpler following split algorithm fun split nil nilnil I split XlXsl case split Xsl YsZs XlZSYS An inputoutput pair reflects algorithm 123456781 C1357124681 Instead giving outputs function Assume means output evaluation Bs permutation function function computes better provide output evaluation isperm As Given defined is_permAsBs Ys Zs input Xs output is_permXsYsQZs andalso abslength Ys length Zs 1 Q ML operator list concatenation 2 Problem 2 exemplified ification allowed programs length Lmin program regarded incorrect The specification tour exists produces TSP specification produce particular predetermined If spec tour tour length Lh loose 3 This example illustrates intersects usefulness grades Consider navigation poly function output evaluation obstacle compute given path represented series points angles length curvature path gon polygonal obstacles When computing check rotation rotation path safety margin In order consider choosing difficult specification writer provide optimal outputs Hamiltonian cycles minimum provide optimal outputs It random graphs inputs TSP specification problematic obstacles illustrate length 4 22 The output evaluation function Since output evaluation ADATE exact form oe described An inferred program contain special considered defining oe A constant means dont constant needs function oe fundamental importance R OlssonArtificial Intelligence 74 1995 5581 59 know A correct wrong oe Let better f dontknow inputtype better The domain inputtype exec_result list execzesult datatype exec_result I too_many_calls I The outcome computation fZi 0 constant evaluated l too_many_calls exceeded count l Oi limit discussed Section 6 ADATF calls oe argument Executeresult CZlRl The range I 1 RN 1 I Ri outcome computation list cwd defined type oe cwd list real list form f Zi datatype cwd correct I wrong I dent_know returns Zir Ri Executezesult If oe Executeresult sponds minimized example form Gradel Grade21 Grade1 Grade2 Cs corre list floating point numbers ordering lists Grades important element number lexicographic usual CsGrades according Grades program Example 22 Consider specification simplifies polynomials As polynomial Xs 3X2 4X 8X2 5X 4 X2 8 sume simplification yields polynomial Ys 12 10X X For given polynomial Xs user need determine good output Ys knowing optimal output defined way computing eval_pol variable easier define function Grade eval_pol polynomial Pol integer Z substituted eval_pol X3 X2 13 37 Note evalpol simplifies polynomials Grades Pol Z evaluates polynomial function Grade Assume singleton list M N different degrees A polynomial oe checks Xs Ys equivalent sum lengths correct output polynomials Xs Ys respectively Ys X integers X 1 it4 N This check XsYs contain list auxiliary comparison pairs The complete definition oe including looks complicated structure oedefinitions shown Fig 1 This definition program However complicated programs represented simplification Xs X evalpol ensure suffices evalpol obviously terms coefficientexponent evalpol polynomial basically specified definition If M N number terms specifications 60 R OlssonArtcial Intelligence 74 1995 5581 PO1 Z fun eval_pol case Pol nil 0 I CoeffExponentPol Coeff int_powZExponent eval_polPolZ handle _ 0 fun oeExecute_result cwd list real inputtype list let val Zs mapfnXsR case R dont_knowO outputtype exec_result list I too_many_calls I Ys let wrongO val M length Xs val N length Ys Nl orelse NM andalso forallfn X eval_polXsXeval_polYsX fromtolMN correct N wrong01 end Executeresult maplZs Crealint_snmmap2Zsl end Fig 1 The output evaluation function polynomial simplification 23 The program evaluation functions ADATE uses sample inputs II I 1 output evaluation function oe compute program evaluation functions pel pe pe3 supplement pro gram rating provided oe measures syntactic complexity time complexity The syntactic complexity defined follows Let Nt N N nodes tree representations number symbols simplicity defined Cyf log mi expressions occur speed type constraints ignored computing syntactic complexity program Due scoping constraints node Ni limited number mi For The function f letfunctions f It f I I The defined time complexity measure program P called P total computation number calls Let l NC number correct outputs l NW number wrong outputs l S syntactic complexity R OlssodArtificial Intelligence 74 1995 5581 61 Table 1 The definitions pet pa2 pe3 Value returned pai 1 2 3 Grades Q NSTI Grades CNTSI NC NC CNNJ Grades D STl l 7z total count The program evaluation functions defined Table 1 A program P better program Q according pei peiP considered comes poiQ lexicographic ordering lists For example program evaluation function pei prefers correctness small syntactic complexity turn preferred low count 3 The functional language inferred programs written Inferred programs written subset Standard ML currying boolean references All functions viewed having single fun operators ifexpressions argument tuple The ML subset consists datatypedefinitions definitions caseexpressions letexpressions int int fully restricted The pattern B lefthand fundefinition sin gle tuple pattern A tuple pattern required layered names introduced means possible parts tuple pattern For example int type like int C D E F Requiring tuple patterns fully layered leads A introduction superfluous names This problem aesthetic practical required exactly correspond al type expression analyzed addition tuple ternatives datatypedefinition The constructor allowed pattern casealternative constructors single occurrence corresponding constructor datatype definition caseexpressions instead letexpressions arity zero Thus caseexpression letexpression introduce functions case Et V E2 instead The alternatives caseexpression let val V El pattern Ez end corresponds In ML expression El applied expression E2 provided type E2 matches domain type El ADATE produces applications EI function symbol 4 The program transformations A compound transformation composition sequence atomic transforma tions The program evaluation functions pei pe2 pes determine program kept discarded applied programs resulting compound transformations Assume program Pi1 produced program 62 R OlssonArrijicial Intelligence 74 1995 5581 Pi atomic PI written tr t2 t transformation ti A compound transformation produces P t The initial program consists single gives dontknow output sequence evolved initial program inputs The final program compound transformations 41 Expression synthesis The synthesis new expressions fundamental synthesis containing form expression transformation order increasing exhaustive production enumerative fixed set function size The size expression A simple type correct expressions synthesized tree representation size 1 expressions number expressions size 2 Since normally grows exponentially size great care taken size small expressions The mere thought heuristically hard overcome exponential trying expression ADATE synthesizes acts mental barrier program number nodes expressions symbols Expressions growth undoubtedly promising ADATE identify understand ADATE employs I Assume limitations following heuristics case E Match Unknown I I Match Unknown partially constant synthesized caseexpression later replaced synthesized The program transformed contains replaced finished synthesized expression caseexpression discarded Sub replaced expression Unknowni expression dummy subexpression In order check incomplete Sub case E Match Unknown1 I I Match Unknown Sub sample executed The resulting program said activated The entire caseexpression finished caseexpression synthesized inputs An expression execution Unknowni activated produced replacing activated Unknowni nonactivated Unknowni synthesis recursive g A A2 A occurring corresponding Matchi contain evaluated variable Otherwise discarded expression 2 Consider V At Ai required v A smaller x Ai occurs dec smaller ghV larationfun corresponding RHSk caseexpression case L Match RHS I I Match RHS Ai proper subexpression b Matchk contains variable W Ai smaller Matchk W R OlssodArrijicial helligence 74 1995 5581 63 42 The atomic transformations There atomic transformations replacement abstraction casedistri bution embedding 421 Replacement Replacement program A replacement Sub program During subexpressions replacement atomic substitutes transformation synthesized synthesis Synt subexpressions Synt When Sub subexpression viewed insertion synthesized expression semantics change expression Synt subexpression Sub reused Sub reused inference list sorting program Assume Example 41 Consider inputs I1 Cl 12 CIOI Z3 C102030401 15 IO 2050401 transformation fun In possible consists single sort Xs Z4 50206020401 sample inferences sort replacement The initial program compound 1 Replacing synthesized expression case Xs nil Xs I XlXsl compound transformation gives fun sort Xs case Xs nil Xs I XlXsl 2 The compound transformation replacement yields fun sort Xs case Xs nil I XlXsl Xs case Xsl nil Xs I X2Xs2 3 The compound transformation replacement gives fun sort Xs case Xs nil I XlXsl case Xsl nil I X2Xs2 Xs Xs case X2xX1 true I false Xs 4 The program gives correct output inputs improved expression wrong output replacing Xsl synthesized IS The program II 12 Z3 output output sort Xsl yields 14 ZS fun sort Xs case Xs nil I XlXsl case I X2Xs2 Xs sort Xsl nil Xs case X2XI true I false Xs The final compound transformation shown Section 422 64 R OlssonArtifcial Intelligence 74 1995 5581 returns In order discriminate function peREu peREo value denoted REQ ordinary replacements ADATE employs special program NC Grades Q NW A replacement replace contains replacements evaluation increase ment denoted R If compound ADATB usually requires trying Rs selecting ones increase small fraction Rs meet requirement The REQs sorted according best REQs REQs REQs value Normally replacements value preference transformation peREQ peREQ 422 Abstraction An abstraction E program introduces transformed The transformation definition based subexpression letfunction schema HEIE let fun gVlV2 f V HViV2 V gErEz E end g new function Matching E H El E2 E viewed higherorder unification finds values variables H El E2 E Example 42 One possible unifier H El E2 abcd cd E2 fx H fnXlX2 abXle X2 o f x El An abstraction choosing El E disjoint subexpressions E Example 43 The compound ABSTR REQ REQ R ABSTR denotes abstraction sort transformation program given The ABSTR n 1 El sort Xsl inference sort form transformation Consider HEI case I X2Xs2 sort Xsl nil Xs case X2X1 true I false Xs The program produced ABSTR Xs fun sort Xs case X5 nil I XlXsl let fun g Vi case Vl nil I X2Xs2 gsort Xsl end The REQ replaces Xs case X2Xl true I false Xs fourth occurrence labeled Xs Xs The program written occurrences Xs Assume pedagogical occurrence Xs The second REQ replaces reasons R OlssordArtificial Intelligence 74 1995 5581 65 fun sort xs case Xs nil Xs I XlXsl let fun g Vl case VI nil Xs I X2Xs2 case X2X1 true I false X9 gsort Xsl end The REQ replaces Xs synthesized expression Xl nil This preserves equivalence Xs singleton The second REQ replaces Xs synthesized expression Xl Vi Equivalence preserved Xs sorted The R finally replaces synthesized expression X2 g Xs2 yields correct sorting program fun sort Xs case Xs nil Xs I XlXsl let fun g Vl case Vl nil X1nil I X2Xs2 case X2Xl true X2g Xs2 I false XlVl gbort Xsl end 423 casedistribution This transformation symbol based following schema h denotes function hAr Ai case E Match1 El I I Match EAilA case E Match1 hAl AiElAil A I Match hAlAiEAilA A casedistribution Note schema lefttoright righttoleft If schema USE lefttoright Ek h Al Ai Ek Ail A changed transformation consists applications schema Each application marks h case In general case application use h case h parent child case Subsequent applications allowed use hs cases marked marked child parent expression tree The purpose marking allow related applications schema 66 R OlssonArtijicial Intelligence 74 1995 S581 424 Embedding An embedding generalizes type letfunction Two examples embeddings add argument list Assume type function change argument type letfunction embedded definition let fun gVl V2 V RHS Exp end In general form embedding inserts synthesized g When type g changes change Changing types functions occurring types types Since types change simplified chain reaction makes form embedding type expression necessary bit difficult avoids chain type expression RHS Exp need change choose reactions described The data type definitions provided specification writer embedding The allowed data type definitions following form subset ML data type definitions datatype a2 Typeconstructor CI TIJ TI 717 c2 T21 T22 T2Tz 1 C c T CI T c2 T c TN Each ai type variable C constructor Tjk type argument number k constructor Ci A given datatypedefinition Tk The types T Tjk considered Tjk applied object type T according typing rules ML embed type T T matches type match function domain Example 44 The datatypedefinition lists datatype list nil I list Since T21 type variable embed type For example embedding bintree list matches type definition type b bintree yields type b Tuple types predefined given special treatment A tuple type T T embedded ways 1 The new type TI 2 An index described T fresh type variable chosen type T embedded datatypedefinition The embedding structor bintree int restriction corresponding list proper subtree Ti allowed Using tuple type int list bintree boo1 int simplifies translation type boo1 example embedded bool This type expression old bintree list expression new type described R OlssodArtiJicial Intelligence 74 1995 5581 67 tuple The types Note embeddings reactions The following synthesized embedded range g avoid chain schemas use special constant _emb denote expression given preserve semantics domain completely embedding transformation Embedding Assume domain g domain The ways embedding type g Tl T datatypedefinition tuple types given lists follows 1 T T g El 2 TqT Each Tl T Each form g El E changed E _emb toTTilistT gElEi E changed gE1 Ei _emb I b IS replaced case K nil smb I X Xs RHS X substituted K X XS fresh variables Embedding Assume range g range lists The ways embedding follows 1 Tl T toTI Ta Each g changed type g Tl T datatypedefinition tuple types given case g X Xl XnXnt Xl X b The RHS changed casedistribution caseexpression case assumed E _emb El form El E If n 1 El caseexpression _emb downwards smb sibling This illustrated delrmin example 2 T c T Tl K list Ifn 1 g changed T case g nil _emb 1 X XS X If n 2 g I changed case g X Xl Xi Xn case Xi nil _emb I Y YS Xl Xi_tIXit 9X b The RHS case El changed E expression _emb caseexpression casedistribution employed sibling assumed 9 Ei emb En Ei El If Ei case _emb downwards form 68 R OlssodArtijicial Intelligence 74 1995 5581 2 case embedding constructor The datatypedefinition lists order presentation domain In general In case range types Tjk match T For Tjk Ei translated argument number abstract embedding type Ti expression type Ti list contain Cj_emb straightforward lists The j k translations restriction case 2 b embedding domain case 2 embedding range 2 b expression Ei k It course embedding This use translation translate datatypedefinition knows casealternative Ei _emb datatypedefinitions generalize caseanalysis ensures program del_min smallest integer natural finds smallest element delrmin element inference deletes occurrence Example 45 Consider list list smallest If ADATE given function min function deleteone ference trivial An important point functions means tionality The sample 13 C594546283111030231 delmin The initial program fun delmin required deletes occurrence element ADATE invent corresponding inputs Ii CIOI 12 123456789101 Here possible Xs nil list int int list Since evaluate list given func auxiliary list inferences 1 The compound transformation single R gives fun del_min Xs case Xs nil 1 XlXsl case Xsi nil nil I X2Xs2 2 The second compound transformation form ABSTR EMB REQ R The ABSTR gives fun del_min let Xs fun g Ys case Ys nil I XlXsl case Xsl nil g Xs end nil I X2Xs2 range g embedded list int list int list int type g changed list int Application 1 embedding range accompanying casedistribution The int schema gives R OlssonArtcial Intelligence 74 1995 S81 69 fun del_min Xs fun g Ys let case Ys nil I XIXsl case Xsl nil nil_emb case g Xs V ZsZ Zs end I X2Xs2 Note casedistribution changes occurrences smb turn immediately replaced The type occurrences naturally changes int int The EMB finished replacing single occurrence _emb Xl Note program NC 1 N 0 The REQ yields program NC 2 NW 0 int list list fun del_min Xs fun g Ys let case Ys nil I XlXsl case Xsl nil nilXl case g Xsl V case XlW WsW true XslXl I X2Xs2 I false case g Xs V ZsZ Zs end Note REQ facilitated input Z2 The R produces final program replacing Xl Ws W The final program N 3 NO This inference unusually short consists compound transforma tions 43 Synthesis compound transformations Recall compound transformation sequence tl t atomic transformation ti following l R Replacement l REQ Replacement program worse l ABSTR Abstraction l CASEDIST casedistribution l EMB Embedding 411 Compound transformations forms The choice atomic transformation ti 3 2 depends previously chosen transformations tl ti 1 No transformation chosen freely The 70 R Olsson Artciul Intelligence 74 1995 5581 dependency possible compound specified socalled coupling transformation forms rules employed produce Example 46 Consider presented REQs R coupled The form compound compound transformation inference sort transformation ABSTR REQ REQ R ABSTR described Assume rule t rule t f t means ti ti1 chosen far ti chosen A t t E t tI t chosen t t t_l When tk transformation production form forms These forms computed weak coupling A strong coupling rule t r t If t followed mark coupling coupled means immediately t chosen t t equal rk ti said coupled finite number possible start remain unchanged I No rule rule subsequent r means Transformation tr chosen R REQ ABSTR CASEDIST t t R t R t Each transformation required chosen coupling applicability requirement rules Each t coupling listed rule expression introduced REQ 1 REQ R The R applied 2 REQ ABSTR The ABSTR occurs H El 3 ABSTR R The R applied expression En ABSTR entirely H VI righthand introduced REQ H V entire execution EMB A form ti 2 2 rule constrained introduced ABSTR 3 REQ b ABSTR REQ REQ The REQs applied V 5 ABSTR EMB The letfunction 6 CASEDIST ABSTR The ABSTR introduced ABSTR embedded root HEI E marked CASEDIST 7 CASEDIST 3 R The R root expression Sub replaced R marked CASEDIST 8 EMB R The R applied righthand definition embedded function Combining 8 rules possible ways yields 22 forms For example ABSTR REQ REQ R produced choosing coupling extended rules 4b 3 The rule set empirically form ti ABSTR applying need important focus compound rules normally particularly Since coupling program programs For example assume ABSTR form ABSTR REQ REQ R Each transformations subexpression Without coupling N NiHs 2 choices coupling means important transformation small large needs choose N42 choices V contains NRHS subexpressions Consider small NRHSN ratios The denominator program contains N subexpressions coupling 2 particularly REQ applied H 6 transformation 4 letdefinition ABSTR HVl R OlssonArtijcial Intelligence 74 1995 5581 71 second REQ interchanged changing transformation The actual number choices REQs small fraction Nws result compound smaller N N2 subexpressions 432 The algorithm uses forms produce programs The algorithm operates concepts work combinatorial produced compound transformation cost The work current program The cost For choice algorithm cost multiplied number alternatives approximate number programs measure complexity algorithm chosen Let W total work goal Let NformS number forms compound The number programs produced specific form WNf W uniformly distributed forms transformations chosen Given current program P specific form F cost limit C assume comp_syntF formC realP programEmit programunit unit form F cost makes P ML function duced sis algorithm makes calls compsynt compsyntF27OPEmit cost ing F Thus 3 It possible relationship F 30 P Emit Emit Pi program Pi pro C For form F synthe F 90 P Emit WtotNforms programs produced factor costwork 4 branching iteratively compsynt use final cost limit forms varies form form limit C deepened 5 The overall search appropriate program Using compound transformation forms described previous section ex pansion parent program P produces children programs Pt Pz Pw The overall search uses population programs The population consists single The population single program programs partitioning counts expanded programs high case counts maintain diversity ensure class contain number caseexpressions partitioned initialized classes The purpose programs low case Each class contains programs Program number far according program c caseexpressions far judged pei ADATE programs case count Assume program evaluation cbeSti case tries avoid futile expansions exceed class number c best function pei contains exactly count best program expanding max 1 zCbest v 1 2Cbest3 l The Case Count Cbestz omitted complexity If arguments preference lead big programs unfold function calls pe2 prefers low count max function included sequences Rtransformations small syntactic l2cbeStz 72 R OlssonArtificiul Intelligence 74 I 995 5581 The search run second iteration number A program iteration 9 eligible iteratively W lo4 iteration 3 lo4 IO4 iteration forth W 3 lo4 pei expanded terminates program minimum case count chosen expanded expansion better ancestors according iteration eligible Out eligible programs program far current 6 Additional implementation details replacement In order reduce run times implementation The implementation transformations sions old expression Sub reused Subsub subexpression reused represent Subsub special variable x pression Rawsyrzt finished synthesized x Assuming substituted chooses Rawsynt according uses additional restrictions atomic 0 1 subexpres expression Synt When algorithm uses ex expression Synt Rawsynt Subsub synthesized expression algorithm produces synthesis If synthesis A E contains case implementation following expression forms 1 E 2 case A Match El 3 case A Match El I I Match E 1 Matchi case A Match Ei I I Match EL I Match E Thus Rawsynt contains 0 1 2 cases root child root Rawsynt N3 Rawsynts chosen according according form 3 case occurrence If N expressions synthesized form 2 N3 form l N3 according uses following types replacements reuse Sub reuses Sub The implementation 1 pure replacement 2 insertion 3 replacement If N replacements reuses subexpression 40 type 1 40 type 2 20 Sub Sub type 3 Abstraction transformations restricted introduce letfunctions arities 1 2 If N abstractions N2 arity 1 N2 arity 2 Since inferred program P bad time complexity number calls P needs limited The current version ADATE uses functions defined count f Ii The upper limit total number calls 200 1 The fixed 200 limit somewhat arbitrary future need replaced iterativedeepening limit 200 computing scheme R OlssonArtQicial Intelligence 74 1995 5581 13 7 Sample specifications inferred programs run times Polynomial simplification This problem discussed Section 22 The specification consisted 1 The type int type declaration datatype list nil I list 2 The primitives int int 3 The type function inferred intint boo1 int int list int intint list Recall polynomial represented list coefficientexponent pairs 4 The following sample inputs ZI Cl 12 C321 Z3 C32 Z4 C570 310 52 122 11211 714 531 373 673 1171 8741 132 194 5 The output evaluation function shown Fig 1 Note sample inputs chosen facilitate incremental inference It polynomial Z2 consists term All terms 13 degree Z4 random polynomial Thus It Z2 13 special cases advantageous learn simplify trying simplify general polynomials z4 With specification ADAm inferred polynomial simplification program shown exactly printed fun f V3_0 case V3_0 nil V3_0 I V4996_0 let V4997_0 V4998_0 V4999_0 fun g5011724_0 V5011725_0 case V5011725_0 nil V4996_0 nil I V5000_0 case V5002_0 V4998_0 V5001_0 V5002_0 V5003_0 true V4997_0 V5001_0 V4998_0 V5003_0 I false v5000_0 g5011724_0v5003_0 g5011724_0f V4999_0 end This program equivalent identifiers generated replaced readable identifiers 74 R OlssonAriijicial Intelligence 74 I 995 5581 Bph BpZy Fig 2 Two nonintersecting rectangles coordinates fun simplify Xs case Xs nil nil I let fun g Ys XlcXle Xl Xsl case Ys nil Xinil I Yl YlcYie Ysl case Yle Xle I false Yi g Ysl true XlcYlc Xle Ysl gsimplify Xsl end The auxiliary function g invented g Ys tries merge Xl term Ys intersection This problems adequate The rectangles viewed windows occurring Rectangle pair specification graphical user interface The overlap foreground window background window needs entirely visible Each rectangle represented pair points turn pairs integers specifying coordinates lower left upper right corners Fig 2 shows representation rectangles A B inputoutput updated foreground moved The specification 1 The type int contained type declaration datatype option I 2 The primitive int 3 The type function bool int inferred The type int int intint int int int int int option int int int 4 A set 50 sample inputs consisting pair rectangles second big rectangle rectangle Fig 3 25 small rectangles 5 An output evaluation function knows correct output sample input The value returned correct rectangle input rectangles intersect C intersection program intersection rectangle C R OlssodArtQicial Intelligence 74 1995 5581 Fig 3 The set input rectangles After renaming inferred program follows fun rect_isI A Apl Ap2 B Bpl Bp2 AplxAply Ap2xAp2y BplxBply Bp2xBp2y case AplxCBp2x true case AplZxBplx true I false case AplyCBp2y true case Ap2yCBply true I false somecase BplxAplx true Aplx I false Bplx case AplycBply I false Aply true Bply case BpZxKAp2x true Bp2x I false Ap2x case ApZycBp2y true Ap2y I false Bp2y I false I false If input rectangles A B intersect output program somemaxApixBplx maxAplyBply minAp2xBp2xminAp2yBp2y This algorithm obvious algorithm specification simple BST deletion The problem delete element binary search tree integers nodes The specification contained 1 The type int type declaration datatype bintree bintree bt_cons 2 The primitive int int bool bintree btnil I 76 R OlssonArtcial Intelligence 74 I 995 5581 3 4 The type function inferred bintree Eight sample inputs Assume element X deleted BST Xs bt_consXLs subtree Xs The inputs cover following cases int bintree Rs int int Ls Rs btnil btnil bt_cons_ bt_cons_ btnil bt_cons_ _ btnil _ _ bt_cons _ _ _ 51 An output evaluation function uses inorder listing deletion lists check correct element deleted Note possible define function knowing good way delete element BST The output evaluation function oe uses following auxiliary definitions fun inorder bt_nil nil I inorderbt_consRoXsLeXsRiXs inorder LeXs Q RoXsinorder RiXs fun depth bt_nil 0 I depthbt_cons_LeXsRiXs lmaxdepth LeXsdepth RiXs fun delete_one_nil nil I delete_oneXYYs XY Ys Ydelete_oneXYs Given input XXs output Ys oe checks inorder Ys delete_oneXinorder depth Ys depth Xs Xs andalso If depth requirement depth Ys depth Xs omitted ADATE infers BST deletion program produces unbalanced outputs With depth requirement following program inferred true bt_consRoXsLeXsbst_delXRiXs true bt_consRoXsbst_delXLeXsRiXs fun bst_delI XXs Xs case Xs bt_nil I bt_consRoXsLeXsRiXs case RoXsX I false case XRoXs I false let fun g Ys case Ys bt_nil I bt_consRoYsLeYsRiYs case LeYs bt_nil I bt_consRoLeYsLeLeYsRiLeYs LeXs bt_consRoYsLeXsbst_delRoYsRiXs g LeYs R OlssodArtificial Intelligence 74 1995 5581 II g RiXs end The innovative program letexpression determines element deleted BST insertion This problem insert integer binary search tree In addition binary trees specification contained relation datatypedefinition integers No auxiliary function needed List reversal The specification contained datatypedefinition function inserts element list inferred lists An auxiliary intersection The problem compute intersection lists integers Lit The specification contained datatypedefinition lists relation integers An auxiliary function checks element occurs list inferred List delete min The problem delete exactly occurrence minimum element list The specification contained datatypedefinition lists relation integers The sample inputs inferred program presented Section 42 generation The problem compute permutations list Permutation integers The specification contained datatypedefinition lists function Q concatenates lists The output evaluation function measured number different permutations occurring output checked output consisted permutations The inferred program contains auxiliary functions lists List sorting The specification contained datatypedefinition lation integers The sample inputs inferred program presented Section 42 List splitting The specification contained datatypedefinition evaluation function described Section 21 lists The output The run times shown Table 2 obtained Standard ML New Jersey compiler SUN SparcStation 10 Note table shows times required correct programs In general guarantee correct program small efficient 8 Related work The inference LISP programs inputoutput pairs surveyed DR Smith insight 81 Smith writes methods survey stem Summers lo 78 R Olsson Artijicial Intelligence 74 I 995 5581 Table 2 Run times Problem Run time dayshours simplification intersection Polynomial Rectangle BST deletion BST insertion List reversal List intersection List delete min Permutation generation List sorting List splitting 07 I18 712 3s 0lO 63 88 9s I12 07 semitrace computation pairs Summers THESYS uses semitrace LISP program constructed chosen construct inputoutput corresponding Example 81 Assume I 23 3 Standard ML notation If input inputoutput I Xs output Yi described pairs II I21 follows 2 YI hd Xsl Y hdtl Xs Y3 hdtltl Xs THESYS notes Y equals Y_l tl XSi substituted Xsi1 This recurrence relation employed infer function finds element list The inference method THESYS highly specialized requires structure inputoutput pairs directly corresponds specific program ILP specifications A particularly Unfortunately holds inductive socalled problems inputoutput apply invention new predicates introduced When executing functional program replacing corresponding abstraction However abstraction work including predicate instantiation instance lefthand Intuitively logic programming ILP pair specifications presented development interesting reviewed Irene Stahl systems The Section 21 ILP 91 A new predicate resolution based inverse inverse resolution corresponds righthand As described step corresponds function function inverse function definition Section 422 invention previous independently predicate transformation developed invention intraconstruction logic program resolution transformation analogous One major difference abstraction predicate invention ILP systems need determine Many ask user usefulness confirm employed initial definition invented predicate invention CIGOL usefulness invented predicate Another size resulting program Irene Stahl concludes choices function predicate 121 criteria 71 SIERES R OlssodArtijicial Intelligence 74 1995 5581 19 Additionally experimental evaluation systems performing predicate invention ILP lacking The specifications GA systems 5 similar ADATE specifications The main program transformation crossover random exchange subexpressions programs This primitive program transformation Crossover effective schema theorem 3 applicable In general means large expression E inferred primarily composed higherorder subexpressions El E2 E fitness advantage Ei measured independently Ej j Unfortunately practically recursive programs consist coupled EiS Example 82 Consider following ML list concatenation program written selectors instead case order resemble Kozas LISP style 51 fun OXsYs null Xs Ys hd XsQtl XsYs The righthand written ElEz fn As null Xs Ys As E2 hd XsQtl XsYs The fitness advantage E2 obviously measured base case recursion properly handled Thus E2 positive effect fitness appears conjunction El equivalent expression This socalled subexpression coupling problem means crossover extremely inefficient program transformation recursive programs inferred Therefore natural Kozas book list inferred programs contain explicit recursive calls The inability infer recursive programs unfortunate recursion fundamental importance LISP functional programming In general equally difficult Kozas produce iterative programs This means current form unlikely effective tool general purpose programming 9 Conclusions future work The main advantages ADATE 1 The abstraction transformation invent auxiliary functions user unaware 2 The embedding transformation change type function order function general 3 Specifications loose 80 R OlssonArtijiciul Intelligence 74 1995 5581 automatically invent nontrivial 4 The ability The main disadvantage reviewed programs knowledge run long Section 8 users algorithms times The systems faster However induction need logic acquire ADATE thorough combination finds good programs optimal according ADATE guaranteed syntactic complexity There guarantee program evaluation testing ADATE function poi For syntactic run times general grow exponentially complexity The ability little practical value Fortunately small fast tempted minimization program example complexity guarantee users satisfied program necessarily NPhard problems solution 1 optimum polynomial finding optimal solution smallest fastest This situation correct program minimum worst case time complexity correct reasonably time high probability analogous exponential arbitrary higherorder insertions improvements embedding abstraction Some possible 1 generalize generalize 2 add heuristics 3 pound significantly mance massively parallel transformations improve 4 type expressions functions invented algorithms synthesize expressions com run times implementing ADATE high perfor future work All programs inferred far small The important inference large programs Recall node Ni expression mi number symbols tree A potential problem inferencein mi grows number ancestor let casenodes needed determine introduce new symbols More experimentation rules Standard ML suffice techniques required A related question functions onthefly invention toolbox construction mi small additional use library specialized inferenceinthelarge tools needed likely combinatorially use tools sym func rely In compar rely expen study occur thelarge nodes scoping bol selection tions versus general ison human programmers general sive tools Acknowledgements I indebted Olaf Owe University comments draft paper The important programming paper comes teaching constructive influence work presented community This work foresight shown Ake Wikstrijm Chalmers I1 freshmen I fortune functional providing programming functional Oslo R OlssonArtifcial Intelligence 74 1995 5581 81 References 1 AW Biermann R Krishnaswamy Constructing programs example computations IEEE Trans Sojiw Eng 2 1976 141153 2 AW Biermann The inference regular LlSP programs examples IEEE Trans Syst Man Cybernet 8 1978 585600 3 1 JH Holland Adaptation Natural Artificial Systems University Michigan Press Ann Arbor Ml 1976 4 RE Korf Depthfirst iterativedeepening optimal admissible tree search Artij Infell 27 1985 97109 5 JR Koza Genetic Programming MIT Press Cambridge MA 1992 6 SH Muggleton Inductive logic programming S Muggleton ed Inductive Logic Programming Academic Press London 1992 421 71 SH Muggleton W Buntine Machine invention firstorder predicates inverting resolution Proceedings Fifh International Conference Machine Learning Ann Arbor MI 1988 339352 8 1 DR Smith A survey synthesis LISP programs examples AW Biermann G Guiho Y Kodratoff eds Aufomatic Program Construction Techniques Macmillan New York 1982 307324 9 I Stahl Predicate invention ILPan overview Proceedings European Conference Machine Learning Springer Verlag Berlin 1993 313322 lo PD Summers A methodology LISP program construction examples J ACM 24 1977 161175 1111 A Wikstram Functional Programming Using Standard ML Prentice Hall Englewood Cliffs NJ 1987 121 R Wirth P DRorke Constraints predicate invention S Muggleton ed Inductive Logic Programming Academic Press London 1992 2993 18