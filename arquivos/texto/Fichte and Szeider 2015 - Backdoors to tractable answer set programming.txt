Artiﬁcial Intelligence 220 2015 64103 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Backdoors tractable answer set programming Johannes Klaus Fichte ab Stefan Szeider Vienna University Technology Favoritenstrasse 911 1040 Vienna Austria b University Potsdam AugustBebelStrasse 89 14482 Potsdam Germany r t c l e n f o b s t r c t Article history Received 7 March 2014 Received revised form 1 December 2014 Accepted 6 December 2014 Available online 15 December 2014 Keywords Answer set programming Backdoors Computational complexity Parameterized complexity Kernelization Answer Set Programming ASP increasingly popular framework declarative programming admits description problems means rules constraints form disjunctive logic program In particular AI problems reasoning nonmonotonic setting directly formulated ASP Although main problems ASP high computational complexity complete second level Polynomial Hierarchy restrictions ASP identiﬁed literature ASP problems tractable In paper use concept backdoors identify new restrictions ASP problems tractable Small backdoors sets atoms represent clever reasoning shortcuts search space represent hidden structure problem input The concept backdoors widely theoretical investigations areas propositional satisﬁability constraint satisfaction We fruitfully adapted ASP We demonstrate backdoors serve unifying framework accommodates tractable restrictions ASP known literature Furthermore backdoors allow deploy recent algorithmic results parameterized complexity theory domain answer set programming 2015 Elsevier BV All rights reserved 1 Introduction Answer Set Programming ASP increasingly popular framework declarative programming 115122 ASP admits description problems means rules constraints form disjunctive logic program Solutions program socalled stable models answer sets Many important problems AI reasoning succinctly repre sented successfully solved ASP framework It applied large industrial applications social networks 97 match making 74 planning seaport 129 optimization packaging Linux distributions 69 general game playing 145 The main computational problems ASP deciding program solution certain atom contained solutions complete second level Polynomial Hierarchy 41 ASP problems harder NP higher worstcase complexity CSP SAT In literature restrictions identiﬁed ASP tractable prominently Horn fragment stratiﬁed fragment 782 detailed trichotomy tractable ﬁrst level second level PH 148 Fichte Szeiders research supported European Research Council grant reference 239962 COMPLEX REASON Fichtes research partially supported Austrian Science Fund FWF project Y698 Corresponding author Email addresses ﬁchtekrtuwienacat JK Fichte stefanszeidernet S Szeider httpdxdoiorg101016jartint201412001 00043702 2015 Elsevier BV All rights reserved JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 65 11 Contribution In paper use concept backdoors identify new restrictions propositional ASP problems tractable Small backdoors sets atoms represent clever reasoning shortcuts search space represent hidden structure problem input Backdoors originally introduced Williams Gomes Selman 152153 tool analyze behavior DPLLbased SAT solvers Backdoors widely theoretical investigations area propositional satisﬁability 152135138103 constraint satisfaction 84 abductive reasoning 125 argumentation 40 quantiﬁed Boolean formulas 137 A backdoor deﬁned respect ﬁxed target class computational problem consideration polynomialtime tractable The size backdoor seen distance measure indicates far instance target class In paper develop rigorous theory backdoors answer set programming We concept backdoors fruitfully adapted setting backdoors serve unifying framework accommodates tractable restrictions propositional ASP known literature For worstcase complexity analysis problems involving backdoors ﬁnding small backdoor solve problem crucial investigate running time depends size backdoor running time scales backdoor size Parameterized Complexity 355585 provides suitable theoretical framework analysis It provides key notion ﬁxedparameter tractability context means polynomialtime tractability ﬁxed backdoor size order polynomial depend backdoor size We backdoors allow deploy recent algorithmic results parameterized complexity theory domain answer set programming Parameterized complexity provides tools rigorous analysis polynomialtime preprocessing terms kerneliza tion 758 A kernelization polynomialtime selfreduction parameterized decision problem outputs decision equivalent problem instance size bounded function f parameter kernel size It known decidable ﬁxedparameter tractable problem admits kernelization problems admit small kernels size polynomial parameter We provide upper lower bounds kernel size prob lems backdoor evaluation backdoor detection disjunctive answer set programs These bounds provide worst case guarantees limits polynomialtime preprocessing considered problems Several algorithms literature deﬁned disjunctionfree normal programs We introduce general method lifting parameters disjunctive programs preserving ﬁxedparameter tractability certain conditions Although main focus theoretical evaluation present experimental results consider backdoor size structured programs random programs varied density 12 Background related work Complexity ASP problems Answer set programming based stablemodel semantics logic programs 7879 The computational complexity problems arising answer set programming subject extensive studies Eiter Gottlob 41 established main decision problems disjunctive ASP complete second level Polynomial Hierarchy Σ P 2 complete respectively Moreover Bidoít Froidevaux 5 Marek Truszczy nski 114 shown problems NPcomplete coNPcomplete respectively disjunctionfree called normal programs Several fragments programs main reasoning problems polynomialtime tractable identiﬁed Horn programs 78 stratiﬁed programs 2 programs cycles 156 Dantsin et al 27 survey classical complexity main reasoning problems semantics logic programming including fragments answer set programming 2 Π P ASP solvers Various ASP solvers developed recent years Many utilize SAT solvers black boxes search techniques SAT There solvers deal fragments disjunctive programs normal tight headcyclefree Smodels 141 Assat 111 Cmodels2 82 Clasp2 71 There solvers deal set disjunctive programs Clasp3 37 Cmodels3 108 DLV 107 GnT 92 Compilations problem domains respective solvers considered normal programs propositional satisﬁability 91 mixed integer programming 112 satisﬁability modulo theories 9376 We like point solvers use heuristics nontrivial worstcase performance guarantees In contrast provide main reasoning problems answer set programming theoretical worstcase time bounds certain hidden structures disjunctive programs account Preprocessing techniques unit propagation solvers considered wider sense implicitly exploit ing Horn fragments Grounders like Gringo 64 solve Horn programs simply propagating atoms trivially belong minimal model atoms occur head rules body atoms occur head rules atoms positive body belong minimal model atoms belong minimal model according constraint atoms belong minimal model occur head Moreover SATbased solvers like Clasp 62 transform program propositional formula Clarks completion 73 resulting formula characterizes classical models necessary conditions atoms belong model If program contains cycles positive dependency graph unit propagation 66 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 DPLLbased algorithm solves Horn fragments Otherwise loop formulas added prevent solver assigning true atoms occur cycle atom outside set true If atom outside assigned true atoms cycle set true unit propagation forth Parameterizations ASP So far rigorous study disjunctive ASP framework parameterized complexity However results known literature stated terms parameterized complexity provide ﬁxedparameter tractability The considered parameters include number atoms normal program appear negative rule bodies 4 number nonHorn rules normal program 4 size smallest feedback vertex set dependency digraph normal program 85 number cycles length dependency digraph normal program 110 treewidth incidence graph normal program 90119 combination parameters length longest cycle dependency digraph treewidth interaction graph headcyclefree programs 3 Very recently established 48 fptreduction reduces disjunctive ASP normal ASP words reduction second level Polynomial Hierarchy ﬁrst level However results provide ﬁxedparameter tractability ASP reasoning problems directly comparable results presented paper A general theoretical framework classify parameterized problems admit fptreduction SAT lately introduced 28 Similar result 48 provide ﬁxedparameter tractability ASP reasoning problems certain cases ﬁxedparameter tractability reduction SAT Backdoors The concept backdoor originates SATCSP introduced Williams et al 152153 Since backdoors frequently literature theoretical investigations The study parameterized com plexity backdoor detection initiated Nishimura et al 123 considered satisﬁability backdoors base classes Horn 2CNF Since study extended base classes including clustering formu las 124 renamable Horn formulas 128 QHorn formulas 59 Nested formulas 56 acyclic formulas 54 formulas bounded incidence treewidth 57 survey 55 Several results extend concept backdoors problems backdoor sets constraint satisfaction problems 152 quantiﬁed Boolean formulas 137 abstract argumentation 40 abductive reasoning 125 Samer Szeider 136 introduced backdoor trees propositional satisﬁability provide reﬁned concept backdoor evaluation interaction variables form backdoor ac count Dilkina et al 3132 considered strong backdoors clause detection clauses trivially yield satisﬁability Empty clause detection present modern SAT solvers leads smaller backdoors practice However established backdoor detection base classes Horn 2CNF harder NP clause detection added Moreover Szeider 144 shown strong backdoor detection W1hard base classes clause detection added unlikely ﬁxedparameter tractable 13 Prior work paper organization This paper extended updated version papers appeared proceedings 22nd International Joint Conference Artiﬁcial Intelligence 47 selected papers proceedings Student Session 23rd European Summer School Logic Language Information 49 The present paper provides higher level particular proofs examples Furthermore paper extends previous versions following way additional attention payed minimality check Lemma 37 Theorem 513 extended entail recent results parameterized complexity theory A completely new section Section 6 devoted rigorous analysis pre processing methods problems backdoor detection backdoor evaluation We present general method lift parameters rules normal programs disjunctive programs Section 7 We extend section theoretical comparison parameters Section 8 additional comparisons parameters weak feedback width inter action graph treewidth classes programs headcyclefree tight programs Additionally provide empirical data backdoor detection discuss evaluation backdoors practical setting Section 41 2 Preliminaries 21 Answer set programming We consider universe U propositional atoms A literal atom U negation A disjunctive logic program simply program P set rules following form x1 xl y1 ym z1 zn x1 xl y1 ym z1 zn atoms l m n nonnegative integers Let r rule We write x1 xl r negative body r We Hr head r y1 ym B denote sets atoms occurring rule r program P atr Hr B rP atr r positive body r z1 zn B r atP r B cid2 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 67 r normal Hr 1 constraint Hr 0 constraintfree Hr 0 respectively A rule r negationfree B r Hr Horn normal negationfree constraint positive Horn constraintfree tautological B r cid10 nontautological tautological We program certain property rules B property Horn refers class Horn programs We denote class normal programs Normal Let cid11 P rule r cid11 P P r We class C programs hereditary P C rule r P Hr subprograms P C Note natural classes programs classes considered paper hereditary subprogram P symbols P r B cid11 programs We P cid11 B cid11 Hr B A set M atoms satisﬁes rule r Hr B r M cid10 M model P satisﬁes rules P The GelfondLifschitz GL reduct program P set M atoms program P M obtained P ﬁrst r remaining rules r 79 M removing rules r B answer set stable model program P M minimal model P M We denote ASP set answer sets P r M cid10 second removing z z B r M cid10 B cid11 B cid11 P r r cid11 Example 21 Consider program P consisting following rules d e f d c b c d b c c f e b f e c f c d The set M b c f answer set P P M d e f d c b c e c f c d f minimal models P M b c f e f In paper generally assume programs contain tautological rules simply remove tautological cid11 rules program effecting answer sets ASP ASP removing tautological rules 13 The 55 42 In case allow tautological rules state explicitly r cid10 Proposition 510 Moreover generally assume programs contain rules r Hr B cid11 simply remove rules head atoms Hr B P r effecting answer sets ASP ASP r rule r Hr B program obtained P program obtained P setting Hr Hr B r cid10 42 cid11 P cid11 cid11 cid11 It known normal Horn programs unique answer set answer set set linear time Van Emden Kowalski 149 shown constraintfree Horn program unique minimal model Dowling Gallier 33 established lineartime algorithm testing satisﬁability propositional Horn formulas easily extends Horn programs In following state wellknown lineartime result Lemma 21 Every Horn program minimal model linear time 22 ASP problems We consider following fundamental ASP problems Checking Given A program P set M atP Task Decide M answer set P Consistency Given A program P Task Decide P answer set Brave Reasoning Given A program P atom atP Task Decide belongs answer set P Skeptical Reasoning Given A program P atom atP Task Decide belongs answer sets P Counting Given A program P Task Compute number answer sets P JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 68 Enum Given A program P Task List answer sets P We denote AspReason family reasoning problems Checking Consistency Brave Reasoning Skeptical Reasoning We denote AspFull family problems deﬁned The family AspReason consists decision problems AspFull adds counting enumeration problem In sequel occasionally write LNormal denote problem L AspFull restricted input programs Normal 2 complete Skeptical Reasoning Π P Checking coNPcomplete general 41 CheckingNormal polynomial 14 Consistency Brave Reasoning Σ P 2 complete 41 Both reasoning problems NPcomplete coNPcomplete normal programs 113 polynomialtime solvable Horn programs 78 Counting easily seen P hard1 entails problem SAT 23 Parameterized complexity Problem instances originate practical applications structured certain way facilitates obtain solution relatively fast Such instances harder theory worstcase running times given terms input size bits practice The framework parameterized complexity introduced Downey Fellows 34 takes structural properties problem instances form parameter account In consequence offers framework detailed theoretical analysis closer practical hardness problems In recent years parameterized complexity theory active research area Since ways deﬁning cap turing structure problem instance ways parameterize problem A main concept parameterized complexity theory ﬁxedparameter tractability relaxes classical polynomialtime tractability way nonpolynomial parts depend size parameter size input We brieﬂy background parameterized complexity For detailed information refer sources 34355084120 An instance parameterized problem L pair I k Σ N ﬁnite alphabet Σ For instance I k Σ N I main k parameter cid13Icid13 denotes size I L ﬁxedparameter tractable exist computable function f constant c decide I k L time O f kcid13Icid13c Such algorithm called fptalgorithm If L decision problem identify L set yesinstances I k FPT class ﬁxedparameter tractable decision problems Let L Σ N L An I k L fptreduction r L L cid11 gk ﬁxed computable function g N N computable rI k I function f constant c r computable time O f kcid13Icid13c Thus fptreduction particular fptalgorithm It easy class FPT closed fptreductions It clear parameterized problems L1 L2 L1 FPT fptreduction L2 L1 L2 FPT cid11 Σ N parameterized decision problems ﬁnite alphabets Σ Σ cid11 cid11 manytoone reduction Σ N Σ cid11 N I Σ cid11 L cid11 k The Weft Hierarchy consists parameterized complexity classes W1 W2 deﬁned closure certain parameterized problems parameterized reductions There strong theoretical evidence parameter ized problems hard classes Wi ﬁxedparameter tractable A prominent W2complete problem Hitting Set 3435 deﬁned follows k cid11 Hitting Set A family sets S k S S1 Sm integer k Given Parameter The integer k Task Decide exists set H size k intersects S H hitting set S The class XP nonuniform tractable problems consists parameterized decision problems solved polynomial time parameter considered constant That I k L decided time Ocid13Icid13 f k computable function f The parameterized complexity class paraNP contains parameterized decision problems L I k L decided nondeterministically time O f kcid13Icid13c computable function f constant c A parameterized decision problem paraNPcomplete NP NPcomplete restricted ﬁnitely pa rameter values 50 By coparaNP denote class parameterized decision problems complement yes instances swapped paraNP Using concepts terminology Flum Grohe 50 coparaNP paracoNP 24 Graphs We recall notations graph theory We consider undirected directed graphs An undirected graph simply graph pair G V E V cid10 set vertices E u v V u cid10 v set edges We denote 1 P complexity class consisting counting problems associated decision problems NP JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 69 cid11 cid11 V cid11 E cid11 uv E uv E cid11 subgraph G V cid11 E induced subgraph addition edge v w uv vu A graph G ally u v V A path length k graph k 1 pairwise distinct vertices v 1 vk1 k distinct edges v v i1 1 k possibly k 0 A cycle length k graph consists k distinct ver tices v 1 v 2 vk k distinct edges v 1 v 2 vk1 vk vk v 1 Let G V E graph G bipartite set V vertices divided disjoint sets U W edge uv E u v U u v W cid11 V induced sub G complete vertices u v V edge uv E G contains clique V cid11 G complete graph A connected component C G inclusionmaximal subgraph C V C E C G graph V vertices u v V C path C u v cid11 V E A directed graph simply digraph pair G V E V cid10 set vertices E u v V V u cid10 v cid11 E induced subdigraph cid11 subdigraph G V set directed edges A digraph G cid11 additionally u v V A directed path length k digraph k 1 pairwise distinct vertices v 1 vk1 k distinct edges v v i1 1 k possibly k 0 A directed cycle length k digraph consists k distinct vertices v 1 v 2 vk k distinct edges v 1 v 2 vk1 vk vk v 1 cid11 E u v E u v E cid11 V E cid11 V cid11 E cid11 We denote directed path directed cycle sequence vertices Please observe according deﬁnitions length undirected cycle 3 length directed cycle 2 A strongly connected component C digraph G V E inclusionmaximal directed subgraph C V C E C G vertices u v V C paths C u v v u The strongly connected components G form partition set V vertices denote partition SCCG For basic terminology graphs digraphs refer standard text 3011 25 Satisﬁability backdoors We need notions propositional satisﬁability A literal atom negation clause ﬁnite set literals A CNF formula ﬁnite set clauses A truth assignment mapping τ X 0 1 deﬁned set X U atoms For x X τ x 1 τ x By 2 X denote set truth assignments τ X 0 1 The truth assignment reduct CNF formula F respect τ 2 X CNF formula Fτ obtained F ﬁrst removing clauses c contain literal set 1 τ second removing remaining clauses literals set 0 τ τ satisﬁes F Fτ F satisﬁable satisﬁed τ The following obvious deﬁnitions Observation 22 Let F CNF formula X set atoms F satisﬁable Fτ satisﬁable truth assignment τ 2 X This leads deﬁnition strong backdoor relative class C polynomially solvable CNF formulas set X atoms strong Cbackdoor CNF formula F Fτ C truth assignments τ 2 X Assume satisﬁability formulas F C size cid13F cid13 n decided time Onc Then decide satisﬁability arbitrary formula F know strong Cbackdoor size k time O2knc eﬃcient long k remains small A variant backdoors deletion backdoors deﬁned removing literals CNF formula F X denotes formula obtained F removing literals x x x X clauses F Then set X atoms deletion Cbackdoor F F X C In general deletion Cbackdoors necessarily strong Cbackdoors If subsets formula C belong C C clauseinduced deletion Cbackdoors strong Cbackdoors Before use backdoor need ﬁnd ﬁrst What backdoor approach process consisting following phases ﬁnding backdoor backdoor detection backdoor solve problem backdoor evaluation For reasonable target classes C detection strong Cbackdoor size k NPhard k input However interested ﬁnding small backdoors makes sense parameterize backdoor search k consider parameterized complexity backdoor detection Indeed respect classes Horn CNF formulas 2CNF formulas detection strong backdoors size k ﬁxedparameter tractable 123 The parameterized complexity backdoor detection target classes investigated 55 The purpose paper develop backdoor approach answer set programming It turns evaluation problem complicated propositional satisﬁability Section 33 target classes answer set programming require new algorithms backdoor detection Section 5 70 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 3 Answer set backdoors 31 Strong backdoors In order translate notion backdoors domain ASP ﬁrst need come suitable concept reduction respect truth assignment The following natural deﬁnition generalizes concept Gottlob et al 85 Deﬁnition 31 Let P program X set atoms τ 2 X The truth assignment reduct P τ logic program P τ obtained P 1 removing rules r Hr τ 11 cid10 Hr X 2 removing rules r B 3 removing rules r B 4 removing heads bodies remaining rules literals X r τ 10 cid10 r τ 11 cid10 Deﬁnition 32 Let C class programs A set X atoms strong Cbackdoor program P P τ C truth assignments τ 2 X By minimal strong Cbackdoor program P mean strong Cbackdoor P properly contain smaller strong Cbackdoor P smallest strong Cbackdoor P smallest cardinality Example 31 We consider program Example 21 The set b c strong Hornbackdoor truth assign d e f d f P bc d e e f f ment reducts P bc P bc d e f d f class Horn P b0c0 d e d e f f P bc 32 Deletion backdoors Next deﬁne variant answer set backdoors similar satisﬁability deletion backdoors For program P set X atoms deﬁne P X program obtained P deleting X rules P The deﬁnition gives rise deletion backdoors We ﬁnding deletion backdoors cases easier ﬁnding strong backdoors Deﬁnition 33 Let C class programs A set X atoms deletion Cbackdoor program P P X C In general strong Cbackdoor deletion Cbackdoor deletion Cbackdoor strong Cbackdoor But strengthen direction requiring base class satisfy mild condition hered itary Section 2 holds base classes considered paper Lemma 34 If C hereditary deletion Cbackdoor strong Cbackdoor Proof Let P program X atP τ 2 X Let r r P deleting X head body r Consequently r establishes proposition cid2 cid11 P τ It follows Deﬁnition 31 r cid11 obtained cid11 P X Hence P τ P X 33 Backdoor evaluation An analogue Observation 22 hold ASP consider basic problem Consistency Take example program P x y y x x z x set X x Both reducts P x0 z P x1 y answer sets P answer set However somewhat weaker asymmetric variant Observation 22 map answer set P answer set P τ τ 2 X This precise following deﬁnition lemma key backdoor approach answer set programming Deﬁnition 35 Let P program X set atoms We deﬁne ASP X cid3 cid4 M τ 11 τ 2 XatP M ASP τ In words sets ASP X answer sets P τ truth assignments τ X atP extended atoms set true τ In following lemma elements ASP X answer set candidates original program P Lemma 36 ASP ASP X holds program P set X atoms JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 71 cid11 cid11 cid11 model P M τ arbitrarily By construction P M τ cid11 P M τ cid11 Proof Let M ASP chosen arbitrarily We X0 X M atP X1 X M deﬁne truth assignment τ cid11 ASP τ implies M ASP X M 2XatP setting τ 1i Xi 0 1 Let M cid11 ASP τ We M M model P M cid11 τ 11 deﬁnition Hence establish lemma suﬃces M cid11 M X1 Observe M τ proper subset M cid11 cid11 cid11 cid11 cid11 cid11 r cid11 M M model P M In order M τ follows B cid11 Hr X0 B τ choose r cid11 B cid11cid11 P τ turn r r M r M Thus r gives rise rule r Since M ASP M satisﬁes r r rule r P Hr cid11 PM τ Since B r deleted forming P M r B r B r M B B r X1 gives rise rule r r X1 r deleted forming P τ B corresponding gives rise cid11 r cid11cid11 P M Hr Hr cid11 M cid11 cid11 model P M τ cid11 Let N In order proper subset M cid11 M X1 X1 M follows N cid2 M Since M minimal model P M N model cid11 X1 Since M N r M r deleted forming P M B r N P M Consequently rule r P B r N M Hr M cid10 Thus r constraint Moreover Hr N However M satisﬁes P M B Hr M cid10 M X0 follows Hr X0 cid10 Thus Hr X1 Hr X cid10 We conclude τ giving r deleted forming P τ giving rise rule r Hr rise rule r cid11 model P M τ cid11 P τ turn deleted forming P M r τ chosen arbitrarily conclude M r M cid10 However Hr M Hr choose arbitrarily proper subset N Hr M cid10 B cid11cid11 Hr X0 B model P M τ r X1 B cid11cid11 Since B cid11cid11 N N Since r cid11 satisﬁes r Hr cid11cid11 N cid11cid11 B cid11 P M cid11 cid2 M r r cid11cid11 cid11cid11 cid11 cid11 cid11 cid11 cid11 cid11 cid11 cid11 cid11 Thus established M cid11 stable model P τ lemma follows cid2 In view Lemma 36 shall refer elements ASP X answer set candidates Example 32 We consider program P Example 21 strong Hornbackdoor X b c Example 31 The answer sets P τ ASP bc e f ASP bc f ASP bc e f ASP bc f τ 2 We obtain set ASP X e f c f b e f b c f bc In view Lemma 36 compute ASP computing ASP τ τ 2 X produces set ASP X candidates ASP ii checking M ASP X answer set P The check ii entails iia checking M ASP X model P iib M ASP X minimal model P M We like note particular constraint contained P removed truth assignment reduct P τ considered check iia Clearly check iia carried polynomial time M Check iib coNPcomplete general 113 polynomial normal programs 14 Fortunately considerations suﬃces perform check iib programs close Normal check ﬁxedparameter tractable size given backdoor More precisely consider following parameterized problem establish ﬁxedparameter tractability lemma Strong CBackdoor Asp Check A program P strong Cbackdoor X P set M atP Given Parameter The size X backdoor Task Decide M answer set P Lemma 37 Let C class normal programs The problem Strong CBackdoor Asp Check ﬁxedparameter tractable Proof Let C class normal programs P program X strong Cbackdoor X P X k We check polynomial time M model P M model P M If reject M Hence assume M model P M In order check M ASP need decide M minimal model P M Recall P contains tautological rules Let X1 M X We construct P M program P M X1 X removing rules r Hr X1 cid10 ii replacing remaining rules r head Hr Hr X positive body B r B r X1 Claim P M X1 X Horn cid11 P M X1 X By construction rule r P gives raise To claim consider rule r cid11 Let τ 2 X assignment sets atoms X Hr 0 rule P M turn gives raise r atoms X Hr 1 Since r tautological follows r deleted obtain P τ gives rise rule r normal Hence 1 Hr Hr X However C class normal programs r cid11 claim follows Hr X Hr P τ Hr To test M minimal model P M run following procedure set X1 M X 72 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 Fig 1 Exploit pattern ASP backdoors target class C normal enumerable n denotes input size P X1 X model stop return True If P M Otherwise compute unique minimal model L Horn program P M model P M return False Otherwise return True X1 X If L M X L X1 cid2 M L X1 For set X1 M X procedure runs linear time Lemma 21 As O2k sets X1 consider total running time O2kn n denotes input size P k X It remains establish correctness procedure terms following claim Claim M minimal model P M algorithm returns True X1 M X Assume M minimal model P M suppose contrary X1 M X X1 X unique minimal model L L M X L X1 cid2 M algorithm returns False Consequently P M L X1 model P M This contradicts assumption M minimal model P M Hence onlyif direction claim shown Assume algorithm returns True X1 M X We M minimal model P M Suppose contrary P M model M We run algorithm X1 M cid11 cid2 M model ii P M M X iib L X1 proper subset M iic L X1 model P M cid11 X By assumption algorithm returns True There possibilities P M X1 X X1 X model unique minimal model L following holds iia L subset We case possible showing M To consider rule r cid11 P M cid11 r Since M X1 X let r P M r model P M B cid11 B removing X1 B r X1 X1 M r B Hr X1 b implies cid10 Hr M cid11 Hence M cid11 X satisﬁes r Since r cid11 X implies cid10 B cid11 Hr M cid11 B r M cid11 X1 Hr M cid11 X model P M cid11 X1 X cid11 cid10 b Hr M cid11 B r obtained r removing X Hr cid11 cid10 Moreover r M cid11 X r r X1 M cid11 X Hr cid11 X X1 X cid11 X Hr X M cid11 M cid11 M cid11 M cid11 B cid11 P M cid11 X model P M X1 X chosen arbitrarily conclude M cid11 X M X Case iib Further L X1 cid2 M L X1 M Case ii possible follows Assume P M X1 X shown L M cid11 X model P M X1 X model let L unique minimal cid11 X cid11 X Case iia We L M X L M model Since M cid11 cid2 M M Case iic And ﬁnally L X1 model P M seen follows Consider rule r P M If X1 Hr cid10 L X1 cid11 Hr X satisﬁes r remains consider case X1 Hr In case rule r cid11 L cid10 Since cid11 L cid10 b Hr B cid11 Hr b implies Hr L X1 cid10 Thus r B L X1 satisﬁes r Since r P M chosen arbitrarily conclude L X1 model P M cid11 B r X1 implies B r X1 Since L model P M r L X1 cid10 Hr X1 X L satisﬁes r cid11 X X1 M X1 X Hr r cid11 B Hence B cid11 X M cid11 X M cid11 P M r cid11 Since case case ii possible contradiction conclude M minimal model P M Hence second direction claim established lemma follows cid2 Fig 1 illustrates exploit strong Cbackdoor ﬁnd answer sets For given program P strong Cbackdoor X P consider 2 X truth assignments atoms backdoor X For truth assign ment τ 2 X reduce program P program P τ compute set ASP τ Finally obtain set ASP checking M ASP τ gives rise answer set P JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 73 Example 33 We consider set ASP X e f c f b e f b c f answer set candidates Example 32 check candidate L e f M c f N b e f O b c f answer set P Therefore solve problem Strong HornBackdoor Asp Check means Lemma 37 First test sets L M N O models P We easily observe N O models P But L M models P satisfy rule c e f b b c respectively drop candidates Then positively answer question N O models GLreducts P N P O respectively Next consider minimality apply algorithm Lemma 37 subset backdoor X b c We d e e GLreduct P N d e e c f f d c c d b c f For X1 obtain P N X1 X f f d c d c f The set L e f unique minimal model P N X1 X Since L N X L X1 cid2 N L X1 model P N algorithm returns False We conclude N minimal model P N N answer set P We obtain GLreduct P O d e e c f f d c c d b c f For X1 P O d X1 X Since L X1 cid2 O e e f f d e d c f The set L e f unique minimal model P O d e e f f d e d f unique minimal model algorithm returns True For X2 b P O d e f d f L e f Since L O X algorithm returns True For X3 c obtain P O X3 X minimal model Thus algorithm returns True For X4 b c P O d e f d f unique minimal model L f Since L X1 cid2 O algorithm returns True Since b c f ASP X answer set P obtain ASP b c f X2 X X4 X X1 X In view Lemmas 36 37 computation ASP ﬁxedparameter tractable parameter k know strong Cbackdoor X size k P program C normal stable sets computed polynomial time This consideration leads following deﬁnition result Deﬁnition 38 A class C programs enumerable P C compute ASP polynomial time If ASP computed linear time class C lineartime enumerable Please note stronger property enumerable polynomialtime delay usually context enumeration problems mentioned Section 84 certain parameter Theorem 39 Let C enumerable class normal programs The problems AspFull ﬁxedparameter tractable parameterized size strong Cbackdoor assuming backdoor given input Proof Let X given backdoor k X n input size P Since P τ C C enumerable compute ASP τ polynomial time τ 2 X time Onc constant c Observe ASP τ Onc τ 2 X Thus obtain ASP X time O2knc ASP X O2knc By Lemma 36 ASP ASP X By means Lemma 37 decide M ASP time O2kn M ASP X Thus determine ASP X set answer sets P time O2k nc 2k n 2k nc O22knc1 Once know ASP solve problems AspFull polynomial time cid2 Theorem 39 identiﬁes conditions small backdoor reduces search space main ASP reasoning problems exponential backdoor size size entire instance Hence conditions small backdoor considered clever reasoning shortcut search space Remark If know program C answer set P strong Cbackdoor size k conclude P 2k answer sets Thus obtain upper bound number answer sets P computing small strong Cbackdoor P 34 Backdoor detection Theorem 39 draws attention enumerable classes normal programs Given class C detection Cbackdoors ﬁxedparameter tractable If answer aﬃrmative drop Theorem 39 assumption backdoor given input class Each class C programs gives rise following parameterized decision problems Strong CBackdoor Detection A program P integer k Given Parameter The integer k Task Decide P strong Cbackdoor X size k 74 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 Fig 2 Negation dependency graph N P program P Example 21 Deletion CBackdoor Detection A program P integer k Given Parameter The integer k Task Decide P deletion Cbackdoor X size k By standard construction known selfreduction selftransformation 1393435 use decision algorithm Deletion CBackdoor Detection actually ﬁnd backdoor We require base class hereditary Lemma 310 Let C hereditary class programs If Deletion CBackdoor Detection ﬁxedparameter tractable ﬁnding deletion Cbackdoor given program P size k ﬁxedparameter tractable parameter k Proof We proceed induction k If k 0 statement clearly true Let k 0 Given P k check x atP P x deletion Cbackdoor size k 1 If answer NO x P deletion Cbackdoor size k If answer YES x induction hypothesis compute deletion Cbackdoor X size k 1 P x X x deletion Cbackdoor P cid2 Remark One consider target classes rules detected analogy clause detection 31 32 SAT setting yield smaller backdoors However backdoor detection W1hard base classes including Horn SAT setting clause detection added 144 These W1hardness results carry ASP setting rule detection added 4 Target class Horn In section consider important case Horn target class backdoors As consequence Lemma 21 Horn lineartime enumerable The following lemma shows strong deletion Hornbackdoors coincide Lemma 41 A set X strong Hornbackdoor program P deletion Hornbackdoor P Proof Since Horn hereditary Lemma 34 establishes ifdirection For onlyif direction assume sake cid11 contradiction X strong Hornbackdoor P deletion Hornbackdoor P Hence rule r obtained forming P X We deﬁne P X tautological Horn Let r P rule r r 1 remaining atoms X atr τ 2X setting atoms X Hr B cid11 P τ contradicting arbitrarily 0 1 Since r tautological deﬁnition τ sound It follows r assumption X strong Hornbackdoor P cid2 r 0 atoms X B cid11 Deﬁnition 42 Let P program The negation dependency graph N P graph deﬁned set atoms given program P distinct atoms x y joined edge xy rule r P x Hr y Hr B r Example 41 Fig 2 visualizes negation dependency graph N P program P Example 21 The following lemma states use recent results vertex cover problem ﬁnd deletion backdoors target class Horn A vertex cover graph G V E set S V edge uv E u v S cid10 Lemma 43 Let P program A set X atP deletion Hornbackdoor P X vertex cover negation dependency graph N P Proof Let X atP deletion Hornbackdoor P Consider edge uv N P By construction N P r Since X deletion Hornbackdoor corresponding rule r P u v Hr u cid10 v ii u Hr v B JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 75 Hr X 1 B conclude X vertex cover N P r X Thus case applies u v X cid10 If case ii applies u v X cid10 We Conversely assume X vertex cover N P Consider rule r P X proof contradiction assume r Horn particular r constraint If Hr 2 variables u v Hr edge uv r cid10 N P u v X contradicting assumption X vertex cover Similarly B r variable v Hr v exists r constraint Thus N P contains edge uv variable u B u v X contradicting assumption X vertex cover Hence claim holds cid2 Example 42 For instance negation dependency graph N P program P Example 21 consists trian gle b c path c e Then b c vertex cover N P We observe easily exists vertex cover size 1 Thus b c smallest strong Hornbackdoor P Remark Note unparameterized version2 Strong HornBackdoor Detection NPhard Since reduction pre sented proof Lemma 43 straightforward reduction unparameterized version vertex cover problem Strong HornBackdoor Detection Theorem 44 Strong HornBackdoor Detection ﬁxedparameter tractable In fact given program n atoms ﬁnd strong Hornbackdoor size k time O12738k kn decide backdoor exists Proof Let P given program Let N P negation dependency graph P According Lemma 43 set X atP vertex cover N P X deletion Hornbackdoor P Then vertex cover size k exists time O12738k kn Chen et al 22 By Lemma 41 vertex cover strong Hornbackdoor P cid2 Now use Theorem 44 strengthen ﬁxedparameter tractability result Theorem 39 dropping assumption backdoor given Corollary 45 All problems AspFull ﬁxedparameter tractable parameterized size smallest strong Hornbackdoor given program 41 Hornbackdoors benchmark instances The underlying idea ﬁxedparameter tractability problem instances parameter small solved eﬃciently It natural ask values parameter distributed problem instances Hence investigate size backdoors benchmark programs focusing target class Horn As expected structured programs originating application domains smaller backdoors random instances Since direct implementation backdoorbased algorithms impracticable We determined strong Hornbackdoors benchmark programs means encodings answer set programming integer linear programming ILP local search LS propositional satisﬁability SAT We use nection stated Lemma 43 compile problem ﬁnding minimum vertex cover kvertex cover respective domain The encodings straightforward Let P program constraints tautological rules let N p V E negation dependency graph For ASP encoding proceed follows Among atoms ASP program atoms eu w u w E atoms C c v v V The truth values atoms C represent subset S atP c v true v S vertex cover We introduce edge v w E straint e v w c v c w choice rule 1cu c v euv Moreover add statement minimize number atoms C belong answer set 14173 choice rules minimize statements For ILP encoding proceed follows We introduce vertex v V binary variable bv add edge v w E straint bv bw 1 minimize sum vV bv For LS ran designated local search based vertex cover solvers 15 1716 graph N p For SAT encoding encoding similar encoding presented 53 We introduce edge uv E binary clause add sequential unary counter 142 express k vertices belong vertex cover cid5 The answer set program solves backdoor detection generated means ASP meta programming 70 solved Clasp 7172 version 305 unsatisﬁablecore based optimization strategy command line parame ter optstrategy5 yields behavior 1 The integer linear program generated open source mathematics framework Sage 44 Python 150 solved ILOG CPLEX 12 89 Gurobi 87 2 Given parameterized problem L ﬁnite alphabet Σ The unparameterized version L classical problem Iuk I k L u denotes arbitrary symbol Σ new symbol Σ 76 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 Table 1 Size smallest strong Hornbackdoors bd benchmark sets given total number atoms atoms mean instances Domain AI Graph Planning Cryptography Puzzle Random Instance set Disj instances HanoiTower StrategicCompanies MinimalDiagnosis GraphColoring MSSMUS ConformantPlanning Factoring Labyrinth KnightTour Solitaire RandomQBF RLP RandomNonTight 60 15 551 60 38 24 10 261 10 25 15 282 220 atoms 32 9567 20020 111 8565 35444 49 4023 13782 33368 55 6049 23 1569 11 4868 1601 2000 2000 Horn bd stdev 428 603 1074 1947 380 843 2576 342 3308 3888 4969 6726 8985 008 004 171 079 070 212 130 082 020 020 000 542 024 ConformantPlanning secure planning incomplete initial states 147 instances provided Gebser Kaminski 60 Factoring factoriza tion number eﬃcient algorithm yield cryptographic attack Gebser 38 instances 61 HanoiTower classic Towers Hanoi puzzle Truszczynski Smith Westlund instances 18 GraphColoring classic graph coloring problem Lierler Balduccini instances 18 KnightTour ﬁnding tour knight piece traveling square following rules chess Zhou Calimeri Santoro instances 18 Labyrinth classical Ravensburgers Labyrinth puzzle Gebser instances 18 MinimalDiagnosis application systems biology 67 instances 18 MSSMUS problem clause belongs minimal unsatisﬁable subset 94 instances provided Gebser Kaminski 60 Solitaire classical Peg Solitaire puzzle Lierler Balduccini instances 18 StrategicCompanies encoding Σ P 2 complete problem producing owning companies strategic sets companies 63 RandomQBF translations randomly generated 2QBF instances method Chen Interian 20 instances 63 RLP Randomly generated normal programs density number rules divided number atoms 155 instances 63 RandomNonTight Randomly generated normal programs 61 n 40 50 60 variables respectively 40 instances step instances The results obtained ILP methods modern solvers like CPLEX Gurobi come certain inaccuracy 2524140 Therefore ran Clasp structured instances encoding kvertex cover problem described obtain optimality Table 1 illustrates results size small strong Hornbackdoors considered benchmark instances We mainly benchmark sets ﬁrst Answer Set Programming Competitions 182963 instances contain normal andor disjunctive rules extended rules cardinalityweightconstraints3 We reference caption Table 1 instances taken indicate table number instances benchmark set The structured instances expected signiﬁcantly smaller strong Hornbackdoors random instances We like mention random programs ASP competitions contain small number atoms So far good evidence particular sets KnightTour Solitaire large strong Hornbackdoors compared structured instances 5 Target classes based acyclicity There causes program large number answer sets disjunctions heads rules ii certain cyclic dependencies rules Disallowing yields enumerable classes In order deﬁne acyclicity associate disjunctive program P dependency digraph D P undirected dependency graph U P The dependency digraph deﬁned Apt et al 2 slight differs notion additional edges head atoms introduced The following deﬁnition closely related notion suggested Gottlob et al 85 Deﬁnition 51 Let P program The dependency digraph digraph D P vertices atoms P r directed edge x y distinct atoms x y rule r P x Hr y B x y Hr We edge x y negative rule r P x Hr y B r x y Hr r B Deﬁnition 52 Let P program The undirected dependency graph graph U P obtained dependency digraph D p 1 replacing negative edge e x y edges xve ve y ve new negative vertex 2 replacing remaining directed edge u v edge uv 3 We aware preprocess extended rules compile normal rules Even recent versions solver Clasp provide option 66 compilations blow instances signiﬁcantly Hence omitted pragmatic reasons JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 77 Fig 3 Dependency digraph D P left dependency graph U P right program P Example 21 Example 51 Fig 3 visualizes dependency digraph D P dependency graph U p program P Example 21 Deﬁnition 53 Let P program 1 A directed cycle P directed cycle dependency digraph D P 2 A directed cycle bad contains negative edge good 3 A directed cycle contains number negative edges odd 4 A cycle P cycle dependency graph U P 5 A cycle bad contains negative vertex good 6 A cycle contains number negative vertices odd Deﬁnition 54 The following classes programs deﬁned terms absence certain kinds cycles noC contains programs cycles noBC contains programs bad cycles noDC contains programs directed cycles noDC2 contains programs directed cycles length 3 directed bad cycles noDBC contains programs directed bad cycles noEC contains programs cycles noBEC contains programs bad cycles noDEC contains programs directed cycles noDBEC contains programs directed bad cycles We let Acyc denote family classes deﬁned We write DAcyc denote subfamily noDC noDC2 noDBC noDEC noDBEC Acyc Example 52 Consider dependency graphs program P Example 21 depicted Fig 3 For instance sequence d e f cycle d directed cycle length 2 d e f c e f directed cycles length 3 vac c d bad cycle b c directed bad cycle The sequence d e f cycle directed cycle c e directed bad cycle The set X c strong noDBECbackdoor truth assignment reducts P c0 P 0 d e d b e f f P 1 d e f d b f target class noDBEC X strong noBECbackdoor P 0 noBEC P 1 noBEC The answer sets P τ ASP c e f ASP c b f Thus ASP X e f b c f b c f answer set P obtain ASP b c f The dependency dependency digraphs contain bad cycles head atoms nonsingleton heads This following consequence Observation 55 C Normal holds C Acyc If programs P P cid11 clearly dependency digraph P subdigraph dependency digraph P This following consequence cid11 Observation 56 All C Acyc hereditary 78 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 Fig 4 Relationship classes programs respect generality A directed path class C class Ccid11 path classes C Ccid11 Ccid11 C C Ccid11 C Ccid11 incomparable indicates C Ccid11 If The following direct consequence deﬁnitions classes Acyc Observation 57 If C Ccid11 Acyc Horn digraph Fig 4 contains directed path class C class Ccid11 C Ccid11 If inclusion classes indicated classes fact incomparable Proof We ﬁrst consider acyclicitybased target classes By deﬁnition noDC cid2 noDBC noC cid2 noBC cid2 noDBC easy inclusions proper However contrary expects noC cid3 noDC seen considering program P 1 x y y x But class noDC2 requires program directed cycles directed good cycles length 2 P 1 generalizes classes noC noDC By deﬁnition noDBC cid2 noDBEC noDEC cid2 noDBEC noEC cid2 noBEC noC cid2 noEC noDC cid2 noDEC Next consider target class Horn Let C noC noDC noDC2 noEC We easily observe Horn cid3 C considering program P 2 b b c c obviously Horn belong C Conversely observe C cid3 Horn considering program P 3 b belongs C obviously Horn Thus C Horn incomparable We observe Horn cid2 noBC considering program P 3 belongs noBC r obviously Horn considering fact rules r Horn program P satisfy Hr 1 B yields dependency graph U P contains bad vertices gives U P contains bad cycles cid2 The class noDBC coincides wellknown class stratiﬁed programs 27719 A normal program P stratiﬁed mapping str atP N called stratiﬁcation rule r P following holds x Hr y B r strx str y ii x Hr y B r strx str y Lemma 58 See Apt et al 2 Strat noDBC The class noDBEC largest class Acyc studied Zhao Lin 156110 showed program noDBEC answer set answer set polynomial time For noDBC unique answer set linear time 121 In context following important consequence Proposition 59 All classes Acyc enumerable classes C Acyc C noDBC lineartime enumerable In view Observation 55 Proposition 59 classes Acyc satisfy requirement Theorem 39 fore principle suitable target classes backdoor approach Therefore study parameterized complexity Strong CBackdoor Detection Deletion CBackdoor Detection C Acyc As shall subsec tions results Strong CBackdoor Detection negative Deletion CBackdoor Detection ﬁxedparameter tractable cases 51 Strong backdoor detection Proposition 510 Assume input program contain tautological rules Then target class C Acyc problem Strong CBackdoor Detection W2hard unlikely ﬁxedparameter tractable JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 79 j j j j j j j j j j cid2 r s B B B Proof We fptreduction W2complete problem Hitting Set Section 23 Strong CBackdoor Detection Let S k instance problem S S1 Sm We construct program P follows As atoms 1 m 1 j k 1 For 1 m elements U b r 1 j k 1 rules r S tautological rule B s j Hs j b We S hitting set size k P strong Cbackdoor size k Let H hitting set S size k We choose arbitrary truth assignment τ 2H P τ C j removed forming P τ Hence rules left P τ rules s m i1 S new atoms j j s Hr Since H hitting set rule r P τ noDC noC C Thus H strong Cbackdoor P S b Let X strong Cbackdoor P size k We H X U hitting set S Choose 1 m consider S We ﬁrst consider case noDC C For 1 j k 1 program P contains bad directed In order destroy cycles X contain atom S X need contain cycle 1 j k 1 atoms cycle X k 1 contradicting assumption size X Hence H hitting set S Now consider case noC C For 1 j k 1 program P contains bad cycle In order destroy cycles X contain atom S X need contain atom cycle contradiction Hence H hitting set S Consequently W2hardness Strong CBackdoor Detection follows cid2 v v b j b j b j j b j j j j j For target classes DAcyc avoid use tautological rules reduction strengthen Propo sition 510 follows interesting know possible remaining classes mentioned Proposition 510 Theorem 511 For target class C DAcyc problem Strong CBackdoor Detection W2hard unlikely ﬁxedparameter tractable Proof In order Strong CBackdoor Detection W2hard C DAcyc forbid tautological rules j input modify reduction proof Proposition 510 Hitting Set redeﬁning rules r j U By argument b We Hr proof Proposition 510 S hitting set size k P strong Cbackdoor size k We like mention reduction work undirected cases yields undirected cycles b cid11 u u Hs S b cid11 U cid2 B B B B s s s r r j j j j j j j j j j j j cid11 u b icid11 u For class noDBEC strengthen result detecting strong noDBECbackdoor coNPhard backdoor size 0 problem coparaNPhard Section 23 Theorem 512 The problem Strong noDBECBackdoor Detection coparaNPhard ﬁxedparameter tractable P coNP Proof Recall path visit vertex twice We reduce following problem NP complete 52104 Directed Path Node Given A digraph G s m t V distinct vertices Task Decide G contains directed path s t m Let G V E digraph s m t V distinct vertices We deﬁne program P follows For edge e v w E w cid10 m rule w v For edge e v m rule m v Finally add rule rst s t We observe dependency digraph P exactly digraph obtain G adding reverse edge t s present marking t s incoming edges m negative We G path s t m P noDBEC Assume G path Then path contain exactly incoming edge m contains exactly negative edge The path negative edge t s forms directed bad cycle P P noDBEC Conversely assume P noDBEC Hence dependency digraph P contains directed bad cycle cycle contains negative edges As contain incoming edge m cycle contains exactly incoming edge m reverse edge t s Consequently cycle induces G directed path s t m cid2 80 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 Fig 5 Known complexity problem Strong CBackdoor Detection When allow tautologies input program Theorem 511 Fig 5 illustrates known complexity results problem Strong CBackdoor Detection An arrow C Ccid11 backdoor size proper subset C size smallest strong Ccid11 indicates Ccid11 smallest strong Cbackdoor Remark Note unparameterized version Strong CBackdoor Detection acyclicitybased target classes C NPhard W2hardness implies NPhardness coparaNPhardness implies coNPhardness Moreover reduction presented proof Proposition 510 Theorems 511 512 straightforward reduction unparameterized version Hitting Set Directed Path Node respectively Strong CBackdoor Detection 52 Deletion backdoor detection The W2hardness results Theorems 511 512 suggest relax problem look deletion backdoors instead strong backdoors In view Lemma 34 Observation 56 deletion backdoor strong backdoor considered acyclicitybased target classes backdoor approach Theorem 39 works Fortunately results section relaxation gives ﬁxedparameter tractability backdoor detection considered classes Fig 6 illustrates results obtain making use recent progress ﬁxedparameter algorithmics variants feedback vertex set cycle transversal problems Consider graph G V E set W V A cycle G W cycle contains vertex W A set T V W cycle transversal G W cycle G T cycle A set T V evenlength W cycle transversal G W cycle G length T cycle A V cycle transversal called feedback vertex set We analog deﬁnitions digraph G V E W V A directed cycle G directed W cycle contains vertex W A set T V directed W cycle transversal G directed W cycle G directed T cycle A set T V directed evenlength W cycle transversal G directed W cycle G length directed T cycle A directed V cycle transversal called directed feedback vertex set Theorem 513 The problem Deletion CBackdoor Detection ﬁxedparameter tractable C Acyc noDEC noDBEC Proof Let P program k 0 Let U p dependency graph D p dependency digraph P respectively Next consider target classes C mentioned statement theorem decide P deletion Cbackdoor size k First consider undirected target classes Downey Fellows 3435 shown ﬁnding feedback vertex set size k ﬁxedparameter tractable We apply algorithm dependency graph U p If algo rithm produces feedback vertex set S size k form deletion noCbackdoor P size k replacing negative vertex S neighbors gives rise atom P If U p feedback vertex set size k P deletion noCbackdoor size k Hence Deletion noCBackdoor Detection ﬁxedparameter tractable Similarly Deletion noBCBackdoor Detection ﬁxed parameter tractable ﬁnding W feedback vertex set U p taking W set bad vertices U p Cygan et al 26 Kawarabayashi Kobayashi 102 showed ﬁnding W feedback vertex set ﬁxedparameter tractable Deletion noBCBackdoor Detection JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 81 Fig 6 Relationship classes programs known complexity problem Deletion CBackdoor Detection An arrow C Ccid11 deletion Cbackdoors smaller deletion Ccid11 Theorem 515 The coparaNPhardness result established Theorem 516 indicates backdoors The FPTresults established Theorems 44 513 The XPresult established In order extend approach Deletion noECBackdoor Detection like use ﬁxedparameter tractabil ity ﬁnding W cycle transversal established Misra et al 116 W V Kakimura et al 98 general W In order use following trick Aracena Gajardo Montalva 117 turns cy cid11 cles containing number bad vertices cycles length From D p obtain graph U p replacing negative edge e x y edges xue ue ve ve y ue ve new negative vertices replacing remaining directed edge u v edges u v new nonnegative vertex We observe cid11 p seen obtained D p subdividing edges Hence natural 1to1 correspondence U cid11 p Moreover cycle U p containing number negative vertices corresponds tween cycles U p cycles U cid11 cycle U p Thus cycle cid11 p obtain deletion noECbackdoor replacing negative vertex v S nonnegative neigh transversal S U bor Hence Deletion noECBackdoor Detection ﬁxedparameter tractable For Deletion noBECBackdoor Detection proceed similarly W cycle transversal U cid11 p length bad cycle U p corresponds bad cycle U cid11 p letting W set negative vertices U We proceed remaining directed target classes noDC noDC2 noDBC Let G V E digraph Evidently directed feedback vertex sets D p exactly deletion noDCbackdoors P Hence ﬁxedparameter algorithm Chen et al 21 ﬁnding directed feedback vertex sets obtain ﬁxedparameter tractability Deletion noDCBackdoor Detection To work Deletion noDC2Backdoor Detection consider instead D p digraph D cid11 p obtained D p replacing negative edge e u v nonnegative edges u v new vertex The cid11 directed cycles D p D p correspond good cycles length 2 D p Bonsma Lokshtanov 12 showed ﬁnding directed feedback vertex set needs cid11 p replacing vertex cut cycles length 3 ﬁxedparameter tractable Applying algorithm D solution neighbors yields ﬁxedparameter tractability Deletion noDC2Backdoor Detection cid11 p 1to1 correspondence However directed cycles length 2 D cid11 p The approach Deletion noDCBackdoor Detection extends Deletion noDBCBackdoor Detection consider cid11 ing directed W feedback vertex sets digraph D p obtained D p simple construction mentioned Cygan et al 26 replace negative edge e u v nonnegative edges u v cid11 W e negative edge The directed W cycles D p directed bad cycles D p obviously 1to1 cid11 correspondence Thus directed W feedback vertex set S D p obtain deletion noDBCbackdoor replacing vertex v S W neighbor The ﬁxedparameter tractability ﬁnding directed W feedback vertex set shown Chitnis et al 23 cid2 According Observation 56 classes mentioned Theorem 513 hereditary Hence Theorem 513 drop assumption Theorem 39 backdoor given We obtain directly following results Theorem 514 For C Acyc noDEC noDBEC problems AspFull ﬁxedparameter tractable parameterized size smallest deletion Cbackdoor Let turn classes noDEC noDBEC excluded Theorem 513 We establish Deletion noDECBackdoor Detection ﬁxedparameter tractable underlying cycle transversal problem currently reach solved However Theorem 515 constant k 82 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 decide polynomial time strong noDECbackdoor size k exists problem XP For Deletion noDBECBackdoor Detection situation different rule ﬁxedparameter tractability complexity theoretical assumption P cid10 coNP Theorem 516 Theorem 515 The problem Deletion noDECBackdoor Detection XP Proof Let P program n input size P k constant We interested deletion noDECbackdoor P size k We loop possible sets X atP size k Since k constant polynomial number Onk sets X To decide X deletion noDECbackdoor P need check P X noDEC For membership check P X noDEC decide D P X contains bad cycle We use directed variant trick proof Theorem 513 fact directed version slightly simpler Let D P X cid11 dependency digraph P X From D P X obtain new digraph D P X subdividing nonnegative edge replace nonnegative edge e x y nonnegative edges x ue ue y ue new vertex Obviously cid11 directed cycles D P X 1to1 correspondence directed cycles length D P X Whether digraph contains directed cycle length checked polynomial time means following results Vazirani Yannakakis 151 shown ﬁnding cycle length digraph equivalent ﬁnding socalled Pfaﬃan orientation graph Robertson Seymour Thomas 133 shown Pfaﬃan orientation polynomial time test works polynomial time cid2 Theorem 516 The problem Deletion noDBECBackdoor Detection coparaNPhard ﬁxedparameter tractable P coNP Proof The theorem follows reduction proof Theorem 512 cid2 Remark We note unparameterized version Deletion CBackdoor Detection acyclicitybased target classes C NPhard coNPhard respectively reduction presented proof Theorems 513 515 straightforward reduction unparameterized version variants minimal feedback vertex set problem Directed Path Node respectively Deletion CBackdoor Detection 53 Backdoors benchmark instances For acyclicity based target classes C Acyc computed small deletion Cbackdoors selected instances moderate size currently available algorithms deal small instances reasonable computation time The size small deletion noCbackdoors selected instances Solitaire half size small strong Hornbackdoors 6 Kernelization If want solve hard problem settings beneﬁcial ﬁrst apply polynomial preprocessing given problem instance In particular polynomialtime preprocessing techniques developed ASP solving 456568 However polynomialtime preprocessing NPhard problems mainly subject empirical studies provable performance guarantees missing mainly fact duce polynomialtime problem instance bit iterating reduction solve instances polynomial time In contrast framework parameterized complexity offers notion kernelization useful mathematical framework admits rigorous theoretical analysis polynomialtime preprocessing NPhard prob lems A kernelization polynomialtime reduction replaces input smaller input called kernel size bounded computable function parameter A known result parameterized complexity theory decidable problem ﬁxedparameter tractable admits kernelization 36 The result leads question problem kernelization reduces instances size polynomially bounded parameter socalled polynomial kernels Indeed NPhard optimization problems admit polynomial kernels parameterized size solution 134 In following consider kernelizations backdoor detection backdoor evaluation context ASP We establish target classes backdoor detection admits polyno mial kernel We provide strong theoretical evidence target classes considered backdoor evaluation admit polynomial kernel We later use following problem Vertex Cover A graph G V E integer k Given Parameter The integer k Task Decide vertex cover S V Section 4 size k JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 83 Next formal deﬁnition kernelization Let L L cid11 Σ N parameterized problems A bikernelization polynomialtime manytoone reduction problem L problem L size output bounded computable function parameter That bikernelization algorithm given instance I k Σ N cid11 k outputs constant c time Ocid13Icid13 kc pair I cid11 L reduction ii cid13I called kernelization reduced instance kernel If g polynomial L admits polynomial bikernel polynomial kernel addition L L For instance problem Vertex Cover kernel 2k vertices admits polynomial kernel 22 L called compressible admits polynomial bikernel cid11 gk g arbitrary computable function called size kernel If L cid11 Σ N I k L I cid11cid13 k cid11 L cid11 k cid11 cid11 cid11 The following proposition states connection ﬁxedparameter tractable problems kernels observed Downey Fellows Stege 36 Proposition 61 See Downey et al 36 Flum Grohe 50 A parameterized problem ﬁxedparameter tractable decidable kernelization Thus ﬁxedparameter tractability results Theorems 39 44 513 immediately provide mentioned problems admit kernelization In following investigate problems admit polynomial kernels 61 Backdoor detection The ﬁrst result section positive Theorem 62 For C Horn noC problem Deletion CBackdoor Detection admits polynomial kernel For C Horn kernel linear number atoms C noC kernel quadratic number atoms cid11 Proof First consider case C Horn Let P k instance Deletion HornBackdoor Detection We obtain polynomial time negation dependency graph N p P Deﬁnition 42 consider N p k instance Vertex Cover We use kernelization algorithm Chen et al 22 Vertex Cover reduce polynomial time cid11 G V E 2k vertices It remains translate G N p k Vertex Cover instance G k cid11 polynomial kernel linear program P number atoms N pcid11 G taking edge xy E rule x y Now P Second consider case C noC Let P k instance Deletion noCBackdoor Detection We obtain poly nomial time dependency graph U p P consider U p k instance Feedback Vertex Set Section 52 We use kernelization algorithm Thomassé 146 Feedback Vertex Set reduce polynomial time U p k cid11 k Feedback Vertex Set instance G cid11 polynomial kernel quadratic number U pcid11 G taking edge xy E rule x y Now P atoms cid2 cid11 4k2 vertices As translate G V E program P cid11 k cid11 k cid11 Similar construction proof Theorem 513 reduce remaining classes backdoor detection problem variants feedback vertex set However variants feedback vertex set polynomial kernels known We like point kernels obtained proof Theorem 62 equivalent input program respect existence backdoor kernels ﬁnd backdoor However obtained kernels equivalent respect decision problems AspReason consequence kernel backdoor evaluation In subsection consider kernels respect problems AspReason 62 Backdoor evaluation Next consider problems AspReason We admits polynomial kernel pa rameterized size strong Cbackdoor considered target classes subject standard complexity theoretical assumptions Our superpolynomial lower bounds kernel size based result Fortnow Santhanam 51 satisﬁability parameterized number variables SatVars A CNF formula F Given Parameter The number k variables F Decide F satisﬁable Task Proposition 63 See Fortnow Santhanam 51 If SatVars compressible NP coNPpoly 84 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 The complexity class NPpoly consists problems solved nondeterministically nonuniform poly nomial time nondeterministic polynomialtime Turing machine additional polynomialbounded input depends length input input advice function details 100 It wellknown Yaps Theorem 154 NP coNPpoly Polynomial Hierarchy collapses level Σ P 3 The following theorem extends result normal programs 58 We need different line argument technique 3 considered unlikely standard complexity theoretical assumptions Π p 58 applies problems NP coNP Theorem 64 Let C Acyc Horn Then problem AspReason admits polynomial kernel parameterized size smallest strong Cbackdoor deletion Cbackdoor NP coNPpoly Proof We existence polynomial kernel problems implies SatVars com pressible Proposition 63 collapse follow First consider problem Consistency From CNF formula F k variables use reduction Niemelä 122 construct program P 1 follows Among atoms program P 1 atoms ax ax variable x varF atom bC clause C F We add rules ax ax ax ax variable x varF For clause C F add x C rule bC ax x C rule bC ax Additionally clause C F add rule bC Now easy formula F satisﬁable program P 1 answer set We observe X ax x varF X ax ax x varF smallest deletion smallest strong Cbackdoor P 1 C Acyc C Horn Hence P 1 k P 1 2k respectively instance Consistency parameterized size smallest strong Cbackdoor deletion Cbackdoor problem admit polynomial kernel imply SatVars compressible For problem Brave Reasoning modify reduction We create program P 2 consists r atoms rules P 1 Additionally program P 2 contains atom t rule r Hr t B r We observe formula F satisﬁable atom t contained answer set P 2 B Since X backdoor size k 2k polynomial kernel Brave Reasoning yield SatVars compressible Let UnSatVars denote problem deﬁned exactly like SatVars yes answers swapped A bi kernelization UnSatVars bikernelization SatVars yes answers swapped Hence SatVars compressible UnSatVars compressible An argument dual previous Brave Reasoning shows polynomial kernel Skeptical Reasoning parameterized backdoor size yield UnSatVars compressible argued yield SatVars compressible cid2 7 Lifting parameters In section introduce general method lift ASPparameters deﬁned normal programs disjunctive programs Thereby extend algorithms suggested normal programs disjunctive programs The lifting method gives alternative approach obtain results Section 5 The following deﬁnition allows speak parameters programs abstract way cid11 pP holds P Deﬁnition 71 An ASPparameter function p assigns program P nonnegative integer pP obtained P deleting rules deleting atoms rules If p deﬁned pP normal programs normal ASPparameter For ASP parameter p write p denote ASPparameter obtained restricting p normal programs cid11 We impose condition pP cid11 pP technical reasons This limitation reasonable parameters parameters considered paper satisfy condition There natural ASPparameters associated backdoors Deﬁnition 72 For class C programs program P let sbCP denote size smallest strong Cbackdoor dbCP denote size smallest deletion Cbackdoor P We lift normal ASPparameters general disjunctive programs follows Deﬁnition 73 For normal ASPparameter p deﬁne ASPparameter p P minimum X pP X inclusionminimal deletion Normalbackdoors X P p setting disjunctive program P The lemma shows deﬁnition compatible deletion Cbackdoors C Normal In words C class normal programs divide task ﬁnding deletion Cbackdoor program P parts ﬁnd deletion Normalbackdoor X ii ﬁnd deletion Cbackdoor P X Lemma 74 Selflifting Let C class normal programs Then dbCP db CP program P JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 85 Proof Let C class normal programs P program Let X deletion Cbackdoor P size dbCP Thus P X C Normal Hence X deletion Normalbackdoor P We select inclusionminimal subset X X cid11 X looping elements x X deletion Normalbackdoor P starting X cid11 x What end inclusionminimal cid11 X cid11 x deletion Cbackdoor setting X X cid11 normal program Since deletion Normalbackdoor X C P db cid11cid11 X X deletion Cbackdoor P Thus deﬁnition db P size dbCP Let P cid11cid11 C Hence X cid11cid11 P X follows P cid11 X cid11cid11 dbCP cid11 P X cid11 X CP X CP k Hence deletion Normalbackdoor X Conversely let db cid11 P X cid11 dbCP X X cid11 X P cid11 k X cid11 X cid11 follows P size k X cid11cid11 C Hence X deletion Cbackdoor P Since dbCP X X deletion Cbackdoor X cid11 We X X cid11 X cid11cid11 db cid11 k Let cid11 X cid11cid11 CP k cid11cid11 cid11cid11 cid11 cid11 cid11 cid11 cid11 cid11 cid11 P X Since dbCP P observe P X P lemma follows cid2 We determine neg Example 71 Consider program P Example 21 let negP denote number atoms appear negative rule bodies normal program discuss parameter Section 82 P 2 following observations The set X1 c deletion Normalbackdoor P P X1 d e d b e f f d f e b d b f belongs class Normal The set X2 e deletion Normalbackdoor P P X2 d d b c c f f d c c f b c d b c f belongs class Normal Observe X1 X2 inclusionminimal deletion Normalbackdoors P X2 3 negP X2 2 Thus program P We obtain neg neg P X1 2 negP X1 1 We neg P 2 For ASPparameter p consider following problem Boundp A program P integer k Given Parameter The integer k Task Decide pP k holds For problem L AspFull ASPparameter p write Lp denote problem L parameterized p That instance problem augmented integer k parameter input program P holds pP k Moreover write LpN denote restriction Lp instances restricted normal programs P Similarly BoundpN restriction Boundp normal programs For problems LpN p needs normal ASPparameter Next state main result section Theorem 75 Lifting Let p normal ASPparameter BoundpN EnumpN ﬁxedparameter tractable Then L AspFull problem Lp ﬁxedparameter tractable We need deﬁnitions auxiliary results establish theorem Deﬁnition 76 Let P disjunctive program The head dependency graph H P program P graph vertices atoms P edge distinct atoms appear head rule P Lemma 77 Let P disjunctive program A set X atP deletion Normalbackdoor P X vertex cover head dependency graph H P Proof Let X deletion Normalbackdoor P Consider edge uv H P rule r P u v Hr u cid10 v Since X deletion Normalbackdoor P u v X cid10 We conclude X vertex cover H P Conversely assume X vertex cover H P We X deletion Normalbackdoor P Assume contrary P X contains rule r head contains variables u v Consequently edge uv H P u v X contradicting assumption X vertex cover cid2 Lemma 78 Let G V E graph n E let k nonnegative integer G 2k inclusionminimal vertex covers size k list vertex covers time O2kn 86 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 Proof We build binary search tree T depth k node t T labeled set St We build tree recursively starting root r label Sr If St vertex cover G stop current branch t success leaf T If t distance k root St vertex cover G stop current branch t failure leaf T It remains consider case St vertex cover t distance smaller k root We pick edge uv E u v St edge exists St t labels Stcid11 St u Stcid11cid11 St v It easy vertex cover add children t inclusionminimal vertex cover S G size k success leaf t St S Since T O2k nodes lemma follows cid2 cid11 t cid11cid11 From Lemmas 77 78 immediately obtain result Proposition 79 Every disjunctive program input size n 2k inclusionminimal deletion Normalbackdoors size k backdoors enumerated time O2kn Proof Theorem 75 Let p normal ASPparameter EnumpN BoundpN ﬁxedparameter tractable P k In following Let P given disjunctive program input size n k integer p task solvable fpttime mean solved time O f knc computable function f constant c By Proposition 79 enumerate inclusionminimal deletion Normalbackdoors size k time O2kn We check pP X k X backdoor X fpttime BoundpN ﬁxedparameter tractable assumption Since p P k set X check succeeds We pick set X compute ASP X fpttime That possible seen follows Obviously truth assignment τ 2 X program P τ normal P X normal clearly pP τ pP X k Deﬁnition 71 We compute ASP τ fpttime EnumpN ﬁxedparameter tractable assumption Since 2k programs P τ compute set ASP X fpttime By Lemma 36 ASP ASP X remains check M ASP X gives rise answer set P Since X deletion Normalbackdoor P easily observes Normal hereditary follows Lemma 34 X strong Normalbackdoor P Hence Lemma 37 applies decide M ASP time O2kn Hence determine set ASP fpttime Once know set ASP obtain problem L AspFull Lp ﬁxedparameter tractable cid2 Example 72 Consider program P Example 21 deletion Normalbackdoor X1 c Example 71 We want enumerate answer sets P We obtain BenEliyahus algorithm 4 sets ASP c e f ASP c b f set ASP X e f b c f answer set candidates By means algorithm solves problem Strong CBackdoor Asp Check Lemma 37 observe b c f answer set P Remark Please note Deﬁnitions 42 51 introduce additional edges certain cycles respectively head atoms nonsingleton heads constructed graphs This construction effect size smallest deletion backdoors Horn acyclicitybased target classes lifting corresponding parameters normal disjunctive programs 8 Theoretical comparison ASPparameters In section compare ASPparameters terms generality Fig 7 illustrates results terms lattice Let p q ASPparameters We p dominates q symbols p cid20 q function f pP f qP holds programs P The parameters p q similar symbols p q p cid20 q q cid20 p The parameter p strictly dominates q symbols p q p cid20 q q cid20 p p q incomparable symbols p cid23cid24 q p cid20 q q cid20 p Observation 81 Let p q ASPparameters L AspFull If p dominates q Lp FPT Lq FPT Observation 82 Let p q normal ASPparameters cid20 cid23cid24 Then p q p q Proof Let p q normal ASPparameters We p cid20 shows claimed observation cid20 q iff p cid20 q Since cid23cid24 deﬁned terms Assume p cid20 q Hence function f programs P p P f q P In particular P normal Deﬁnition 73 pP p P qP q P pP qP p cid20 q Now assume p cid20 q Hence function f normal programs P pP f qP Let f monotonic functions nonnegative integers deﬁned f cid11n max0in f n f cid11cid11n f cid11cid11 cid11n n Let P cid11 f JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 87 Fig 7 Domination Lattice relationship ASPparameters restricted normal programs An arrow p p strictly dominates p Please recall deptw yield tractability Proposition 836 When restrict parameters normal programs apply lifting Observation 860 parameter headCycles strictly general A label edge indicates Proposition establishes result indicates p cid11 cid11 program X minimal deletion Normalbackdoor P We X pP X X f qP X X qP X cid11qP X X qP X f f cid11cid11 X qP X Hence p follows Deﬁnition 73 cid2 cid11 X qP X f cid20 q Let C class programs In following omit Deﬁnition 71 parameters dbC sbC clear context compare dbC sbC normal ASPparameter In following deﬁne auxiliary programs use examples separate parameters establish incomparability strictness results Example 81 Let m n large integers We deﬁne following programs P n 1 P n 2 P n 31 P n 32 P n 33 P n 34 P n 35 P n 4 P n 51 P n 52 P n 53 P n 54 P n 6 P n 7 d1 di di1 1 n ci bi di ci di bi 1 n di bi 1 n bi bi 1 n a0 bi a0 1 n b1 bn ai b 1 n bi bi 1 n bi bi 1 n P n 31 P n 33 P n 33 ci ai ci bi bi ai ai ei ei di di ai 1 n bi ai ai bi 1 n bi ai ai bi 1 n bi ai ai bi 1 n bi ai ci bi ai ci 1 n b1 bn ci 1 n j ai 1 j n 88 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 P mn 8 P n 9 P n 11 b a1 ci ci1 1 n cn1 c1 a2 a1 a3 a2 bi a3 a1 bi 1 n ai b c c b b ai 1 n 81 ASPparameters based backdoor size Backdoorbased ASPparameters related terms underlying base classes We need weak assumption stated following holds target classes considered paper Therefore need following deﬁnition A class C programs closed union disjoint copies P C disjoint copies P 1 P P P P 1 P C We program P isomorphic P atP atP disjoint copy P P cid11 cid11 cid11 Proposition 83 Let C Ccid11 dbCcid11 cid20 dbC sbCcid11 cid20 sbC dbCcid11 P dbCP sbCcid11 P sbCP program P If Ccid11 C contains program atom C Ccid11 classes programs closed union disjoint copies If C Ccid11 implies dbCcid11 dbC sbCcid11 sbC Proof The ﬁrst statement obvious For second statement let P Ccid11 C atP 1 We construct program P n consisting n disjoint copies P observe P n Ccid11 dbCP n sbCP n n cid2 Hence relationships target classes stated Observation 57 carry corresponding backdoor backdoor size smallest strong smallest strong deletion Ccid11 based ASPparameters C Ccid11 deletion Cbackdoor According Lemma 34 deletion Cbackdoor strong Cbackdoor C hereditary holds smallest backdoors immediately deﬁnitions Observation 84 If C hereditary sbC dominates dbC According Lemma 41 strong Hornbackdoor program deletion Hornbackdoor vice versa Hence obtain following statement Observation 85 sbHorn dbHorn Observation 86 We following observations programs Example 81 2 Consider program P n dbnoDCP n noBEC DAcyc 3 Consider program P n 4 Consider program P n 1 Consider program P n 32 dbHornP 1 dbnoCP 1 dbnoDCP 1 According Observation 83 dbCP n C Horn Acyc Since P Horn contains cycle directed cycle obtain 32 1 31 1 dbCP n 32 let P P n 31 P n 31 P n 33 Since P n 33 33 1 dbnoBCP n Horn contains directed cycle bad cycle obtain dbHornP n 33 1 According Observation 83 dbCP n 33 0 33 1 C Horn noBC 34 Since P n 4 The negation dependency graph P n contains cycle dbnoECP n 34 34 1 tion Hornbackdoor size n P n n directed cycles Hence smallest deletion Cbackdoors size n dbCP n Horn noC noBC noDC noDC2 noEC noBEC noDEC 4 contains 2n disjoint paths aibi aici Thus smallest dele 4 contains n disjoint bad cycles n directed cycles length 3 4 n C 51 contains n disjoint paths dbHornP n 51 n According Observation 83 obtain dbCP n 51 n P n 51 contains 51 n 5 Consider program P n 51 The negation dependency graph P n n disjoint directed bad cycles dbnoDBECP n C Horn Acyc 6 Consider program P n 7 Consider program P n 52 Since P n 54 Since P n directed cycles obtain Observation 83 dbCP n 52 contains n disjoint directed bad cycles dbnoDBCP n 54 contains n disjoint cycles n disjoint directed cycles length 3 n disjoint 52 n 54 n C noC noDC noDC2 noEC noDEC 8 Consider program P n 6 Since P n According Observation 83 dbCP n 6 Horn contains cycle directed cycle dbHornP n 6 0 C Horn Acyc 6 dbnoCP n 6 dbnoDCP n 6 0 9 Consider program P n 7 Since P n 7 Horn contains bad cycle directed cycle dbHornP n 7 0 According Observation 83 dbCP n 7 0 C Horn noBC noBEC DAcyc dbnoDCP n 7 dbnoBCP n 7 Horn P mn c1 contains cycle directed cycle obtain dbHornP mn 0 8 1 According Observation 83 dbCP mn a2 Horn P n 9 9 1 According Observation 83 dbCP n 8 a1 contains cycle directed cycle dbHornP n 9 1 9 1 C Horn Acyc 8 1 C Horn Acyc 10 Consider program P mn Since P mn 1 dbnoDCP mn 8 8 8 dbnoCP mn 8 11 Consider program P n 9 Since P n 9 dbnoCP n 9 1 dbnoDCP n JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 89 12 Consider program P n X deletion Hornbackdoor P n cycle dbCP n 11 11 let X b Since P n X Horn X 1 Since P n X contains cycle cycle directed 11 X 1 C Horn Normal Acyc X 1 C Acyc Consequently dbCP n 11 X normal X deletion Normalbackdoor P n 11 dbHornP n 11 Since P n 11 11 11 82 ASPparameters based distance Horn Our backdoorbased ASPparameter dbHorn considered parameter measures distance program Horn program In literature normal ASPparameters proposed considered distance measures Horn In section compare dbHorn Since ASPparameters considered literature normal compare parameters normal programs However view Observation 82 results hold lifted parameters disjunctive programs Deﬁnition 87 See BenEliyahu 4 Let P normal program Then cid6 cid6 cid3 atP B negP nonHornP cid6 cid6r P r Horn r rule r P cid6 cid6 cid4cid6 cid6 Proposition 88 See BenEliyahu 4 For L AspFull LnegN FPT LnonHornN FPT Since BoundpN p neg nonHorn clearly solvable polynomial time ﬁxedparameter tractable use Lifting Theorem Theorem 75 obtain following result Corollary 89 For L AspFull Lneg FPT LnonHorn FPT Observation 810 We following observations programs Example 81 1 Consider program P n 1 contains n atoms occur B negP n 1 n nonHornP n 1 1 r rule r P exactly nonHorn rule Thus 2 Consider program P n 2 contains atom b occurs B r rule r P n 2 n nonHorn rules Thus negP n 2 1 nonHornP n 2 n 3 Consider program P n rules bi bi Hence negP n 4 Consider program P n 5 Consider program P n So negP n 35 nonHornP n 35 1 31 contains 1 n atoms bi occur B 31 2n 31 n 1 nonHornP n 32 nonHornP n 32 Horn Thus negP n 35 contains atom occurs B 32 0 r rule r P n 6 Consider program P n 4 contains 1 n atoms ai occur B rules bi ai ci ai Thus negP n 4 n nonHornP n 4 2n 7 Consider program P n 51 contains 1 n atoms ai bi occur B rules bi ai ai bi Hence negP n 51 nonHornP n 52 contains atoms bi occur B 8 Consider program P n 51 2n r rule r P n Hence negP n 9 Consider programs P n 52 nonHornP n 52 n 6 P n 7 nonHornP n 54 P n 7 P mn 7 negP mn 8 Horn Thus negP n nonHornP mn 0 8 8 negP n 10 Consider program P n rules a2 a1 a3 a2 Hence negP n 9 contains atoms a1 a2 occur B 9 nonHornP n 11 The set X b deletion Normalbackdoor P n 11 X negP n X 0 Thus neg 9 2 P n 11 11 Consider program P n negP n 11 X nonHornP n 11 X nonHornP n 11 X 1 r rule r P n 31 nonHorn 35 exactly nonHorn rule r rule r P n 4 nonHorn r rule r P nonHorn 52 nonHorn rules ai bi 54 nonHornP n 54 negP n 6 nonHornP n 6 r rule r P n 9 nonHorn 11 Since P n X 1 nonHorn X Horn 11 P n 11 Proposition 811 neg nonHorn incomparable Proof The proposition directly follows considering P n 2 n Observation 810 cid2 negP n 2 1 nonHornP n 1 P n 2 negP n 1 n nonHornP n 1 1 However easy dbHorn dominates parameters Proposition 812 dbHorn strictly dominates neg nonHorn dbC neg dbC nonHorn incomparable C noC noDC noDC2 noEC noDEC 90 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 Proof For normal program P deﬁne sets B Hr r P r Horn We observe B negP dbHornP nonHornP To dbHorn strictly dominates parameters consider P n dbHornP n r rule r P HP P HP deletion Hornbackdoors P dbHornP 31 P atP B 31 2n Observations 86 810 31 n 1 nonHornP n The second statement follows considering programs P n dbCP n 810 Hence dbC cid23cid24 neg dbC cid23cid24 nonHorn C noC noDC noDC2 noEC noDEC cid2 31 n 1 31 P n 54 0 C noC noDC noDC2 noEC noDEC p neg nonHorn Observations 86 31 1 negP n 31 1 pP n 54 n pP n 54 dbCP n 83 ASPparameters based distance stratiﬁed BenEliyahu 4 Gottlob et al 85 considered ASPparameters measure certain sense far away program stratiﬁed In section investigate parameters ﬁt landscape ASPparameters Similar section parameters considered normal programs compare parameters normal programs Again view Observation 82 results hold lifted parameters disjunctive programs Recall Section 24 SCCG denotes partition vertex set digraph strongly connected compo nents Deﬁnition 813 See BenEliyahu 4 Let P normal program D P dependency digraph A atP P A denotes program obtained P deleting rules r program P Hr A ii removing bodies remaining rules literals A corresponds wellknown concept reduct Then lstrP cid7 cid3 min cid4 negP C nonHornP C CSCCD P lstrP called level stratiﬁability P Proposition 814 See BenEliyahu 4 For L AspFull LlstrN FPT Since BoundlstrN clearly solvable polynomial time ﬁxedparameter tractable use Lifting Theorem Theorem 75 obtain following result Corollary 815 For L AspFull Llstr FPT Observation 816 We following observations programs Example 81 1 Consider program P n 31 let P P n 31 The partition SCCD P contains set C atP P C P By Observa tion 810 negP n 1 nonHornP 2n lstrP n 31 n 1 2 Consider program P n 32 let P P n Observation 810 lstrP n 35 let P P n 3 Consider program P n 32 The partition SCCD P contains set C atP P C P Since negP 0 32 0 35 The partition SCCD P contains set C atP Thus P P C Since negP n 35 4 let P P n 4 We SCCD P contains exactly sets Ai ai ei di B bi Ci ci ci ci bi Since negP C 0 ai ei ei di di ai P Bi bi P Ci 1 Observation 810 conclude lstrP n 35 1 4 Consider program P n 1 n Hence P Ai C SCCD P lstrP n 4 0 52 let P P n 5 Consider program P n 51 P n 1 n P Ci nonHornP Ci 2 respectively negP Ci nonHornP Ci 1 n components obtain lstrP n lstrP n The partition SCCD P contains exactly sets Ci ai bi bi ai ai bi 1 n respectively Since negP Ci 51 2n bi ai ai bi P Ci 51 P n 52 52 n 6 Consider program P n 6 let P P n 1 n Hence P A b1 bn ci 1 n P Bi SCCD P lstrP n 6 The partition SCCD P contains exactly sets A B bi Ci ci 1 n Since negP C 0 C P Ci 7 Consider program P n 7 The partition SCCD P contains exactly sets Ci ai 1 n Thus P Ci ai j 1 j Hence negP Ci 0 C SCCD P We obtain lstrP n 7 0 8 Consider program P mn C ci 1 n Hence P Ai c1 Since negP Ai 0 1 m negP B 0 negP C 0 obtain lstrP mn The partition SCCD P contains exactly sets Ai ai 1 m B b 1 m P B b a1 P C ci ci1 1 n cn1 let P P mn 0 8 8 9 Consider program P n 9 let P P n nonHornP 2 lstrP n 9 The partition SCCD P contains set C atP Hence P C P Since negP 9 2 8 6 0 7 let P P n JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 91 10 Consider program P n 11 The set X b deletion Normalbackdoor P n 11 Observation 86 We P P n 11 c c ai 1 n The partition SCCD P contains sets Ai ai 1 n C c Hence P Ai 1 n P C c Since negP C 0 C SCCD P obtain lstrP 0 Consequently lstr X lstrP n 11 X 1 X ai ai c 11 P n Observation 817 lstr strictly dominates neg nonHorn cid5 r rule r P By deﬁnition B P Proof Let P normal program We ﬁrst P C atP B cid11 deﬁ P Let C C B CSCCD P negP C nition B cid5 negP A similar argument shows CSCCD P minnegP C nonHornP C lstrP negP lstrP nonHornP To lstr strictly dom 4 2n inates parameters consider program P n Observations 810 816 Hence observation true cid2 By deﬁnition strongly connected component C C P C cid11 C cid5 P A atP cid5 CSCCD P nonHornP C non HornP Since lstrP CSCCD P negP C negP Deﬁne set B cid11 SCCD P C cid10 C cid11 P C C B 4 n non HornP n P C cid11 Consequently 4 0 negP n 4 lstrP n P A B P C B CSCCD P B Hence B cid2 cid11 Proposition 818 dbnoDBC strictly dominates lstr Moreover dbC lstr incomparable remaining target classes C Acyc noDBC noDBEC Horn Proof We ﬁrst dbnoDBC dominates lstr For normal program P deﬁne sets B r rule r P HP Hr r P r Horn Let C SCCD P deﬁne B cid8 XC P C B HP C P C HP C B P atP cid11 X XC C SCCD P We X deletion noDBCbackdoor P By deﬁnition directed bad cid11 SCCD P vertices c belong strongly cycle c x1 xl D P atom xi C connected component Moreover deﬁnition negative edge xi x j D P dependency digraph D P P C HP C corresponding rule r P x j Hr xi B atoms xi x j belongs XC Thus directed bad cycle c program P atom cycle belongs X Hence P X noDBC X deletion noDBCbackdoor P We obtain dbnoDBCP lstrP To 31 n 1 Observations 86 dbnoDBC strictly dominates lstr consider program P n 816 Hence dbnoDBC lstr r Since XC consists B 31 dbnoDBCP n 31 1 lstrP n 1 l C Then parameters dbC lstr incomparable Consider programs P n 31 1 4 n C Horn noC noBC noDC noDC2 noEC noBEC noDEC 4 dbCP n 3 P n lstrP n Observations 86 816 We conclude dbC cid23cid24 lstr cid2 31 n 1 lstrP n 4 0 dbCP n Deﬁnition 819 See Gottlob et al 85 Let P normal program D P dependency digraph U P dependency graph A atP ˆP A denotes program obtained P A removing bodies rule literals P denotes maximal set W atP bad W cycle dependency graph U P A words set atoms lie bad cycle P Then cid3 fwP min wfwP fw S S feedback vertex set U P cid9cid3 r ˆP C ˆP C C SCCD P ˆP C noDBC cid4cid10 cid4 fwP called feedbackwidth P wfwP called weakfeedbackwidth P Observation 820 Let P normal program D P dependency digraph Then fwP dbnoCP wfwP dbnoC cid9cid3 r ˆP C ˆP C C SCCD P ˆP C noDBC cid4cid10 Proposition 821 See Gottlob et al 85 For L AspFull LfwN FPT LwfwN FPT Since BoundfwN BoundwfwN ﬁxedparameter tractable use Lifting Theorem Theorem 75 obtain following result Corollary 822 For L AspFull Lfw FPT Lwfw FPT Observation 823 We following observations programs Example 81 92 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 31 1 1 Consider program P n 31 let P P n 31 The partition SCCD P contains set C atP For atom C ˆP C ˆP C P As P noDBC ˆP C Consequently ˆP C ˆP C C SCCD P ˆP C noDBC P We dbnoCP 1 Observation 86 according Observa program P contains bad acycle r ˆP C tion 820 obtain wfwP n 2 Consider program P n 32 let P P n ˆP C noDBC r ˆP C 32 The partition SCCD P contains set C atP ˆP C P For atom C ˆP C C SCCD P ˆP C noDBC Consequently wfwP n 32 0 33 P n 34 P n 3 Consider programs P n We ﬁrst observe dependency digraph P contains 34 P n strongly connected component Hence partition SCCD P contains set C atP For atom C ˆP C ˆP C P Since P noDBC program P contains bad acycle obtain r ˆP C ˆP C C SCCD P ˆP C noDBC P We dbnoCP n P contains n disjoint bicycles According Observation 820 conclude wfwP n ˆP C Consequently ˆP C 35 let P P n 33 P n 35 4 Consider program P n 4 let P P n 1 n Hence ˆP Ai noDBC Consequently r ˆP C 51 let P P n 5 Consider program P n ai ei ei di di ai ˆP Bi 34 wfwP n 33 wfwP n 35 n 4 The partition SCCD P contains exactly sets Ai ai di ei B bi Ci ci ci For C SCCD P program ˆP C bi ˆP Ci ˆP C C SCCD P ˆP C noDBC obtain wfwP n 51 The partition SCCD P contains exactly sets Ci ai bi 1 n 4 0 ˆP Ci ai bi bi ai Since dbnoC ˆP Ci 1 n components obtain wfwP n 51 n 6 Consider program P n 52 let P P n atom Ci 1 n bad acycle dependency graph ˆP Ci ˆP Ci dbnoCP n according Observation 820 obtain wfwP n 52 We observe partition SCCD P contains exactly sets Ci ai bi For ˆP Ci Consequently ˆP C C SCCD P ˆP C noDBC P We observe ˆP Ci ˆP Ci Since ˆP Ci noDBC r ˆP C 52 n 6 The partition SCCD P contains exactly sets A B bi Ci ci 1 n Since dbnoC ˆP C 0 C SCCD P obtain ˆP Ci 7 Consider program P n 6 let P P n 1 n Hence ˆP A ˆP Bi wfwP n 6 0 8 Consider program P n 7 let P P n wfw ˆP ai 0 We obtain wfwP n 7 0 7 Since partition SCCD P contains exactly sets ai 1 n ˆP ai ai 9 Consider program P mn let P P mn C ci 1 n Hence ˆP Ai programs ˆP Ai ˆP B ˆP C belong class noDBC 1 m Consequently r ˆP C noDBC Hence conclude wfwP mn The partition SCCD P contains exactly sets Ai ai 1 m B b 1 m ˆP B ˆP C ci ci1 1 n cn1 c1 The ˆP C C SCCD P ˆP C 0 8 8 8 9 let P P n 9 The partition SCCD P contains set C atP For atom C bad ˆP C ˆP C P Since P noDBC ˆP C Consequently ˆP C ˆP C C SCCD P ˆP C noDBC P By Observation 86 dbnoCP 1 according Observation 820 10 Consider program P n acycle dependency graph P r ˆP C obtain wfwP n 11 Consider program P n 9 1 11 let P P n 11 The set X b deletion Normalbackdoor P n X ai c c ai 1 n The partition SCCD P contains exactly sets ai 1 n c Hence ˆP ai ai 1 n ˆP c c We observe dbnoC ˆP C 0 C SCCD P according Observation 820 obtain wfwP 0 Consequently wfw 11 Observation 86 P P n X 1 P n 11 11 X wfwP n 11 In following proposition state relationship parameter wfw backdoorbased ASP param eters The ﬁrst result dbnoDBC strictly dominates wfw anticipated Gottlob et al 85 Proposition 824 wfw strictly dominates dbnoC dbnoDBC strictly dominates wfw Moreover dbC wfw incomparable remaining target classes C Horn noBC noDC noDC2 noEC noBEC noDEC Next dbnoDBC strictly dominates wfw Let P normal program ˆP ˆP C Proof We ﬁrst wfw strictly dominates dbnoC Let P normal program X deletion noCbackdoor P Deﬁne ˆP ˆP C ˆP C C SCCD P ˆP C noDBC Since ˆP P noC hereditary Observation 56 ˆP X noC X deletion noCbackdoor ˆP Consequently wfwP dbnoC ˆP To wfw 4 n Hence wfw dbnoC strictly general dbnoC consider program P n Observations 83 823 ˆP C C SCCD P ˆP C noDBC According Observation 820 wfwP dbnoC ˆP suﬃcient dbnoDBCP dbnoC ˆP Let X arbitrary deletion noCbackdoor ˆP Since noC noDBC Observation 83 yields X deletion noDBCbackdoor ˆP Let c arbitrary directed bad cycle D P As vertices c belong induced subdigraph D P ˆP C obtain c directed partition C SCCD P ˆP C C D ˆP C ˆP C cycle Since ˆP ˆP C bad cycle D ˆP C Since X deletion U P directed bad ˆP C C SCCD P ˆP C noDBC deﬁnition ˆP C cycle D P c directed bad cycle D ˆP C 4 0 dbnoCP n 4 wfwP n JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 93 Fig 8 Incidence graph I P program P Example 21 noDBCbackdoor D ˆP C X deletion noDBCbackdoor P Consequently dbnoDBCP dbnoC ˆP wfwP To dbnoDBC strictly general parameter wfw consider program P n c directed bad X cycle D ˆP C 33 n Observations 86 823 Hence dbnoDBC lstr 33 dbnoDBCP n 33 1 wfwP n The statement follows considering programs P n 34 1 wfwP n noDC noDC2 noBEC noDEC dbnoECP n Observations 86 823 Hence dbC cid23cid24 wfw C Horn noBC noDC noDC2 noEC noBEC noDEC cid2 33 P n 34 P n 33 wfwP n 4 dbCP n 34 n wfwP n 33 1 C Horn noBC 4 n 4 0 dbCP n Observation 825 If p neg nonHorn lstr p wfw incomparable Proof To p wfw incomparable consider programs P n wfwP n 35 n Observations 810 816 823 cid2 35 1 wfwP n 31 1 pP n 31 P n 35 pP n 31 n 1 84 Incidence treewidth Treewidth graph parameter introduced Robertson Seymour 130132 measures certain sense treelikeness graph See 81086 background examples treewidth Treewidth widely applied knowledge representation reasoning artiﬁcial intelligence 398690118126 Deﬁnition 826 Let G V E graph T N E T tree χ labeling maps node t T subset χ t V We sets χ bags denote vertices T nodes The pair T χ tree decomposition G following conditions hold 1 vertex v V node t N v χ t vertices covered 2 edge v w E node t N v w χ t edges covered 3 nodes t1 t2 t3 N t2 lies unique path t1 t3 χ t1 χ t3 χ t2 connectivity The width tree decomposition T χ maxχ t 1 t V T The treewidth G denoted twG minimum taken widths possible tree decompositions G We use following basic properties treewidth Lemma 827 Folklore 132 Let G graph C1 Cl connected components twG maxtwC j 1 l Lemma 828 Folklore 6 Let G graph If G feedback vertex set size k twG k 1 Treewidth applied programs means graph representations Deﬁnition 829 See Jakl et al 90 Let P normal program The incidence graph I P P bipartite graph vertices atoms rules P rule atom joined edge atom occurs rule Then inctwP twI P The parameter inctwP called incidence treewidth P Fig 8 illustrates incidence graph I P program P Example 21 Proposition 830 See Jakl et al 90 For L AspFull Enum LinctwN FPT EnuminctwN solutions enumerated ﬁxedparameter linear delay consecutive solutions 94 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 Observation 831 We following observations programs Example 81 1 Consider programs P n incidence graph P n according Lemma 827 inctwP n 32 P n 32 consists cycles ri bi r2i 1 n 51 consists cycles ai ri bi r2i 1 n According Lemma 828 cycle treewidth 2 51 We observe incidence graph P n 51 2 7 Its incidence graph contains clique n vertices Thus deﬁnition inctwP n 32 2 inctwP n 2 Consider programs P n 6 n 1 6 P n 3 Consider program P mn The incidence graph consists tree vertices r0 b a1 cycle r1 c1 rn cn rn1 cn1 rn2 By deﬁnition tree treewidth 1 according Lemma 828 cycle treewidth 2 according Lemma 827 obtain inctwP mn 2 8 8 inctwP n 7 n 1 The following observation states apply lifting theorem extend parameter treewidth normal disjunctive programs Observation 832 EnuminctwN FPT 51 2 Let M atP ai M bi M According Proof Consider program P n deﬁnitions obtain GLreduct P M ai ai M bi bi M Since M minimal model P M M answer set P Thus program P 2n answer sets Consequently enumerating answer sets P takes time Ω2n cid2 51 inctwP n Proposition 833 If C Horn Acyc p dbC neg nonHorn lstr wfw p inctw incomparable Proof We observe incomparability programs P n inctwP n 6 n 1 Observations 86 810 816 823 831 cid2 51 P n 6 pP n 51 n inctwP n 51 2 pP n 6 1 85 Dependency treewidth One ask makes sense consider restrictions treewidth dependency graph In section dependency treewidth strictly dominates incidence treewidth backdoors respect target class noC unfortunately parameterizing main ASP problems dependency treewidth yield ﬁxedparameter tractability Deﬁnition 834 Let P program deptwP twU P We deptwP dependency treewidth P Observation 835 We following observations programs Example 81 1 Consider programs P n 2 Consider program P n 32 P n 51 We observe dependency graph consists n disjoint cycles bi vbi ai ai vai bi 1 n Accord 6 dependency graph tree Thus deptwP n 32 deptwP n 6 1 ing Lemma 828 cycle treewidth 2 according Lemma 827 obtain deptwP n 3 Consider program P n 7 Its dependency graph contains clique n vertices subgraph Hence deptwP n 7 n 1 51 2 Proposition 836 deptw strictly dominates inctw dbnoC Let C Horn Acyc noC noEC p dbC neg nonHorn lstr wfw p deptw incomparable Proof Let P normal program I P incidence graph Let T χ arbitrary tree decomposition I P We create tree decomposition T χ cid11 U P follows For r P let vr corresponding vertex I P We replace occurrence vr χ t Hr nodes t V T Then pair T χ cid11 satisﬁes Conditions 1 2 tree decomposition U P Since edges I P covered T χ r P t V T vr χ T h χ T Hr h Because vr connected bags tree decomposition T χ corresponding elements h connected T χ Condition 3 holds T χ cid11 Thus T χ cid11 tree decomposition dependency graph U P Since width T χ cid11 equal width T χ follows twU P twI P normal 6 n program P To deptw strictly dominates inctw consider program P n Hence deptw inctw 6 1 inctwP n 6 deptwP n Let P normal program X deletion noCbackdoor P Thus X feedback vertex set dependency graph U P According Lemma 828 twU P k 1 Hence deptw cid20 dbnoC To deptw strictly dominates dbnoC 51 n Consequently deptw dbnoC proposition consider program P n sustains 51 2 dbnoCP n 51 deptwP n To statement consider programs P n deptwP n 7 n 1 pP n 7 0 Observations 86 816 823 835 cid2 51 P n 7 deptwP n 51 2 pP n 51 n JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 95 Proposition 837 For L AspReason LN NPhard programs dependency treewidth 2 Proof First consider problem Consistency From 3CNF formula F k variables construct program P follows Among atoms program P atoms ax ax variable x varF new atom f We add rules ax ax ax ax variable x varF For clause l1 l2 l3 F add rule f hl1 hl2 hl3 f hx ax hx ax Now easy formula F satisﬁable program P answer set Let U P undirected dependency graph P We construct fol lowing tree decomposition T χ U P tree T consists node t f x varF nodes t f x txx t xx edges t f t f x t f xtxx txxt xx We label nodes χ t f f v f x varF We observe pair T χ satisﬁes Condi χ t f x ax ax f χ txx ax ax vax ax χ t xx ax ax v axax ax U P covered ax ax v axax v axax tion 1 The rules ax ax ax ax yield edges ax vax ax vax ax χ txx χ t xx The rule f hl1 hl2 hl3 f yields edge f v f covered χ t f yields edges f ax f ax covered χ t f x Thus Condition 2 satisﬁed We easily observe Condition 3 holds pair T χ Hence T χ tree decomposition dependency graph U P Since maxχ t 1 t V T 2 tree decomposition T χ width 2 deptwP 2 Hence problem ConsistencydeptwN NPhard programs dependency treewidth 2 We observe hardness problems Brave Reasoning Skeptical Reasoning argument proof Theorem 64 proposition holds cid2 86 Interaction treewidth In section consider parameters investigated BenEliyahu Dechter 3 interaction treewidth troduced term clique width4 feedback width interaction graph introduced term cyclecutset size The interaction graph represents interactions head atoms related body atoms similar Gaifman graph The interaction treewidth measures certain sense treelikeness interaction graph feedback width distance interaction graph acyclic Both parameters considered length longest cycle positive dependency digraph states dependencies atoms head atoms positive body Deﬁnition 838 See BenEliyahu Dechter 3 Let P normal program The interaction graph graph A P cid11 P vertices atoms P edge xy distinct atoms x y rules r r x atr y atr cid11 Hr Hr cid11 cid10 5 Deﬁnition 839 See Kanchanasut Stuckey 99 BenEliyahu Dechter 3 Let P program The positive depen P P vertices atoms atP directed edge x y atoms x y atP dency digraph D rule r P x Hr y B r6 Let G V E graph c v 1 vl cycle length l G A chord c edge v v j E v v j connected edge c nonconsecutive vertices G chordal triangulated cycle G length 4 chord Deﬁnition 840 See BenEliyahu Dechter 3 Let G digraph G cid11 graph Then cid3 cid3 2 cid11 lcG max cid10 cid3 cid9 cs cid11 G cid9 cid11 cid10 w G cid3 c c cycle G cid4cid4 fw G min S S feedback vertex set G subgraph chordal graph cliques size w cid4 cid11 cid4 lc length longest cycle cs clique size7 Let P normal program A P interaction graph D clusterP cs A P log lc D P cid9 cyclecutP fw A P log lc D cid10 P cid9 cid10 P positive dependency digraph Then clusterP called size tree clustering cyclecutP called size cycle cutset decomposition 4 Today term cliquewidth predominately refer different graph parameter 83 5 This deﬁnition equivalent original deﬁnition 3 given terms cliques interaction graph graph atom associated vertex atom set literals appear rules heads connected clique 6 BenEliyahu Dechter 3 term dependency graph term positive dependency graph ﬁrst Kanchanasut Stuckey 99 popular Erdem Lifschitz 43 7 The original deﬁnition based length longest acyclic path component G instead length longest cycle term clique width instead clique size 96 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 In fact deﬁnition csG related treewidth Lemma 841 See Robertson Seymour 132 Let G graph Then twG csG 1 Corollary 842 Let P normal program A P interaction graph D clusterP cid9 tw A P 1 cid10 log lc cid9 cid10 D P P dependency digraph Then Proposition 843 See BenEliyahu Dechter 3 For L AspFull LclusterN FPT LcyclecutN FPT Observation 844 We following observations programs Example 81 53 51 P n 1 Consider programs P n The interaction graph A p contains n disjoint paths ai bi 1 m Hence A P contains cycles fw A P 0 according Lemma 828 obtain tw A P 1 Moreover positive P 2 Consequently dependency digraph D P contains edges n disjoint cycles length exactly 2 respectively Thus lcD clusterP n 53 let P P n 51 P n 51 1 cyclecutP n 51 1 clusterP n 53 1 cyclecutP n 2 Consider program P mn let P P mn The interaction graph A P contains clique m vertices tw A P m 1 According Lemma 841 obtain cs A P m 2 According Lemma 828 fw A P m 2 Moreover positive m 2 log n dependency digraph D cyclecutP mn P contains cycle c1 c2 cn cn1 Thus lcD P n Consequently clusterP mn m 2 log n 53 1 8 8 8 8 Observation 845 cluster strictly dominates cyclecut Proof Let P normal program A P interaction graph According Lemma 828 obtain tw A P fw A P 1 Hence clusterP cyclecutP cid2 Proposition 846 inctw strictly dominates cluster If C Horn Acyc p dbC neg nonHorn lstr wfw p cluster incomparable p cyclecut incomparable Proof We ﬁrst inctw dominates cluster Let P normal program I P incidence graph A P interaction graph Let T χ arbitrary tree decomposition A P We create tree decomposition T χ cid11 I P follows For r P let vr corresponding vertex I P By deﬁnition r P bag χ t t V T atr χ t We set χ cid11t χ t vr Then pair T χ cid11 clearly satisﬁes Conditions 1 2 tree decomposition I P deﬁnition Since vr occurs exactly bag Condition 3 holds T χ cid11 Thus T χ cid11 tree decomposition interaction graph A P Since width T χ cid11 equal width T χ plus follows twI P tw A P 1 To inctw strictly dominates cluster consider program P mn 8 inctwP mn m 2 log n Observations 831 844 Hence inctw cluster 2 clusterP mn Let p dbC neg nonHorn lstr wfw C Horn Acyc We incomparability parameter p P P respectively lcI P arbitrarily large programs converse sustains Therefore 1 m 2 log n Observations 86 810 816 823 844 Consequently cyclecut In fact stronger programs P p constant size twD fwD consider programs P n cyclecutP mn second statement holds cid2 51 P mn m 2 log n clusterP mn 51 1 cyclecutP n 51 n clusterP n 51 1 pP mn 8 pP n 8 8 8 8 8 87 Number bad cycles Lin Zhao 110 considered number directed bad cycles given program parameter measures certain sense distance program acyclic respect bad cycles This parameter relates notion deletion noDECbackdoors deletion noDBECbackdoors Deﬁnition 847 See Lin Zhao 110 Let P normal program Then badEvenCyclesP cid6 cid6c c directed bad cycle P cid6 cid6 Proposition 848 For L AspFull LbadEvenCyclesN FPT Observation 849 We following observations programs Example 81 1 Consider program P n 4 contains directed bad cycle Hence badEvenCyclesP n 4 0 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 97 2 Consider program P n 3 Consider programs P n badEvenCyclesP n 4 Consider program P n 7 P mn 51 contains n disjoint directed bad cycles Thus badEvenCyclesP n 52 P n 7 badEvenCyclesP mn 9 contains directed bad cycles a1 a2 a3 bi 1 n Since n directed 8 contain directed bad cycle Consequently obtain badEvenCyclesP n 52 0 8 51 n bad cycles obtain badEvenCyclesP n 9 n Proposition 850 dbnoDBEC strictly dominates badEvenCycles Moreover dbC badEvenCycles incomparable maining target classes C Acyc noDBEC Horn If p neg nonHorn lstr wfw inctw deptw cluster cyclecut p badEvenCycles incomparable Proof To dbnoDBEC strictly dominates badEvenCycles Let P normal program If P k directed bad cycles construct deletion noDBECbackdoor X P taking element directed bad cycle X Thus dbnoDBECP badEvenCyclesP If program P deletion noDBECbackdoor size 1 9 1 arbitrarily cycles run atom backdoor program P n 9 n Observations 86 849 It follows dbnoDBEC badEvenCycles proposition badEvenCyclesP n holds 9 dbnoDBECP n To second statement consider programs P n badEvenCyclesP n dbnoDBCP n noDBEC Horn Observations 86 849 52 n badEvenCyclesP n 9 n conversely dbCP n 9 1 C Acyc Horn 9 dbCP n 4 n C Horn noC noBC noDC noDC2 noEC noDEC noBEC 52 0 Hence dbC cid23cid24 badEvenCycles C Acyc 4 badEvenCyclesP n 52 P n 4 P n 7 n 1 pP n To statement consider programs P n deptwP n m 2 log n badEvenCyclesP n p inctw deptw cluster cyclecut pP n badEvenCyclesP n p neg nonHorn lstr wfw inctw deptw cluster cyclecut cid2 P n 52 n p neg nonHorn lstr wfw cyclecutP mn 8 badEvenCyclesP n 7 n 1 51 2 51 9 n Observations 86 810 816 823 831 835 844 849 Hence p cid23cid24 badEvenCycles 9 2 p neg nonHorn lstr wfw badEvenCyclesP n 9 inctwP n m 2 log n clusterP mn 7 badEvenCyclesP mn 52 0 conversely pP n 7 P mn 52 P n 51 P n 8 8 8 88 Number positive cycles loop formulas Fages 46 Lin Zhao 109 Lee Lifschitz 105 introduced compilations normal programs dis junctive programs SAT respectively Fages 46 established notion acyclic respect positive dependency digraph given program socalled tight programs Lin Zhao 109 extended nontight pro grams adding additional formulas prevent cycles positive dependency graph socalled loop formulas We like mention loop formulas ASP solvers Clasp3 37 Cmodels3 108 The concept loop formulas based observation cycles positive dependency digraph yield additional models SAT formula fact answer sets eliminated forbidding circular justiﬁcation atoms having justiﬁcation outside The number loop formulas depends number cycles positive dependency digraph yields following parameter measures certain sense distance program tight Deﬁnition 851 See Fages 46 Let P normal program D posCycles cid6 cid3 cid6 c c directed cycle D cid4cid6 cid6 P The program P called tight posCycles 08 P positive dependency digraph Then The parameter generalized disjunctive programs Lee Lifschitz 105 Proposition 852 See Fages 46 For L AspReason LposCyclesN NPhard coNPhard tight programs Observation 853 We following observations programs Example 81 posCyclesP n 1 Consider programs P n 53 n 2 Consider program P n 7 0 3 Consider program P mn posCyclesP n 32 P n 53 positive dependency digraphs contain n directed cycles Hence posCyclesP n 51 P n 7 positive dependency digraphs contain cycle Hence posCyclesP n 32 51 Its positive dependency digraph contains cycle c1 c2 cn cn1 posCyclesP n 8 1 8 8 Fages 46 term positiveorder consistent instead tight 98 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 Proposition 854 If C Horn Acyc p dbC neg nonHorn lstr wfw inctw deptw cluster cyclecut badEven Cycles p posCycles incomparable Proof We observe incomparability programs P n neg nonHorn lstr wfw badEvenCycles inctwP n clusterP nm p dbC neg nonHorn lstr wfw inctw deptw pP n posCyclesP n proposition holds cid2 51 n p dbC m 2 log n 1 conversely 53 2 53 n Observations 86 810 816 823 831 835 844 849 853 Consequently We pP n 7 n 1 cyclecutP nm 7 0 posCyclesP mn 32 2 p cluster cyclecut pP n 51 P n 7 n 1 deptwP n m 2 log n posCyclesP n 51 posCyclesP n 32 posCyclesP n 7 P nm 53 P n 32 P n 8 8 8 8 89 Headcycles BenEliyahu Dechter 3 considered programs contain certain cycles positive dependency digraph socalled headcyclefree programs Headcyclefree programs compiled normal programs polynomial time We like mention connections headcyclefree programs exploited implementation ASP solvers 106 In following consider number head cycles parameter measures certain sense distance program headcyclefree Deﬁnition 855 See BenEliyahu Dechter 3 Let P program D cycle D headcycle P x ycycle9 x y Hr rule r P The program P headcyclefree D P positive dependency digraph A head P contains One consider number headcycles parameter tractability Deﬁnition 856 Let P program D P positive dependency digraph Then headCycles cid6 cid3 cid6 c c headcycle D cid4cid6 cid6 P But following proposition states ASPreasoning problems NPcomplete headcyclefree programs Proposition 857 See BenEliyahu Dechter 3 Each L AspReason NPhard coNPhard headcyclefree programs Observation 858 We following observations programs Example 81 1 Consider program P n 2 Consider program P n 11 n headCyclesP n 51 Since positive dependency digraph P n 11 The positive dependency digraph P n 51 contains cycle headCyclesP n 11 contains head cycles aibc 1 n Thus 51 0 Even parameter headCycles yield tractability ASPreasoning problems interested relationship lifted parameters parameter headCycles We ﬁrst restrict input programs normal programs Observation 859 consider disjunctive programs Observation 860 Observation 859 If C Horn Acyc badEvenCycles posCycles headCycles strictly dominates p p dbC neg nonHorn lstr wfw inctw deptw cluster cyclecut Proof By deﬁnition normal program headcyclefree headCycles strictly dominates p cid2 Observation 860 If C Horn Acyc dbC headCycles incomparable Moreover p neg nonHorn lstr wfw p headCycles incomparable Proof To parameters incomparable consider programs P n headCyclesP n 11 1 headCyclesP n 51 0 pP n 51 P n 11 dbC n pP n 51 n 11 n Observations 86 810 816 823 858 cid2 9 See Section 52 deﬁnition W cycle JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 99 9 Summary future work We introduced backdoor approach domain propositional answer set programming In certain sense backdoor approach allows augment known tractable classes makes eﬃcient solving methods tractable classes generally applicable Our approach makes recent progress ﬁxedparameter algorithmics applicable answer set programming establishes unifying approach accommodates parameters literature This frame work gives rise detailed comparison parameters terms generality We introduce general method lifting parameters normal disjunctive programs establish basic properties method We studied preprocessing limits ASP rules terms kernelization taking backdoor size parameter The results concepts paper rise research questions For instance interesting consider backdoors target classes contain programs exponential number answer sets set answer sets succinctly represented A simple example class programs consist independent components bounded size It interesting enhance backdoor approach extended rules particular weight constraints An interesting research direction study backdoors control modern heuris tics ASP solvers obtain speedup We expect practically competitive heuristic purely based backdoors aspects ASP solving account Therefore conclusive evaluation requires rig orous experimental setup takes interaction heuristic methods account interaction solver techniques 101 tuning parameter values 88 modifying branching heuristic caching truth values atoms reusing 127 modifying atom score initially learning conﬂict clauses certain depth search So far studies theoretical considerations effect restricting decision heuristics subset variables based structural properties carried context SAT ASP positive 8081 14375 negative effects 9695 observed References 1 Benjamin Andres Benjamin Kaufmann Oliver Mattheis Torsten Schaub Unsatisﬁabilitybased optimization clasp A Dovier V Santos Costa Eds Technical Communications 28th International Conference Logic Programming ICLP12 Leibniz International Proceedings Infor matics LIPIcs vol 17 2012 pp 212221 2 Krzysztof R Apt Howard A Blair Adrian Walker Towards theory declarative knowledge Foundations Deductive Databases Logic Programming 1988 pp 89148 3 Rachel BenEliyahu Rina Dechter Propositional semantics disjunctive logic programs Ann Math Artif Intell 12 1 1994 5387 4 Rachel BenEliyahu A hierarchy tractable subsets computing stable models J Artif Intell Res 5 1996 2752 5 Nicole Bidoít Christine Froidevaux Negation default unstratiﬁable logic programs Theor Comput Sci 78 1 1991 85112 6 Hans L Bodlaender Arie MCA Koster Combinatorial optimization graphs bounded treewidth Comput J 51 3 2008 255269 7 Hans L Bodlaender Rodney G Downey Michael R Fellows Danny Hermelin On problems polynomial kernels J Comput Syst Sci 75 8 2009 423434 8 Hans L Bodlaender A tourist guide treewidth Acta Cybern 11 12 1993 122 9 Hans L Bodlaender Treewidth algorithmic techniques results Igor Prívara Peter Ružiˇcka Eds Proceedings 22nd International Sympo sium Mathematical Foundations Computer Science MFCS97 Lecture Notes Computer Science vol 1295 Springer Verlag 1997 pp 1936 10 Hans L Bodlaender Discovering treewidth Peter Vojtáš Mária Bieliková Bernadette CharronBost Ondrej Sýkora Eds Proceedings 31st Conference Current Trends Theory Practice Computer Science SOFSEM05 Lecture Notes Computer Science vol 3381 Springer Verlag 2005 pp 116 11 John A Bondy USR Murty Graph Theory Graduate Texts Mathematics vol 244 Springer Verlag New York 2008 12 Paul Bonsma Daniel Lokshtanov Feedback vertex set mixed graphs Frank Dehne John Iacono JörgRüdiger Sack Eds Proceedings 12th International Symposium Algorithms Data Structures WADS11 Lecture Notes Computer Science vol 6844 Springer Verlag 2011 pp 122133 13 Stefan Brass Jürgen Dix Characterizations disjunctive wellfounded semantics conﬂuent calculi iterated GCWA J Autom Reason 20 14 Marco Cadoli Maurizio Lenzerini The complexity propositional closed world reasoning circumscription J Comput Syst Sci 48 2 1994 15 Shaowei Cai Kaile Su Qingliang Chen Ewls new local search minimum vertex cover Nestor Rychtyckyj Daniel G Shapiro Eds Proceedings 24th AAAI Conference Artiﬁcial Intelligence AAAI10 Atlanta GA USA July 2010 pp 4550 16 Shaowei Cai Kaile Su Chuan Luo Abdul Sattar Numvc eﬃcient local search algorithm minimum vertex cover J Artif Intell Res 46 2013 17 Shaowei Cai Kaile Su Abdul Sattar Local search edge weighting conﬁguration checking heuristics minimum vertex cover Artif Intell 1998 143165 255310 687716 175 2011 16721696 18 Francesco Calimeri Giovambattista Ianni Francesco Ricca Mario Alviano Annamaria Bria Gelsomina Catalano Susanna Cozza Wolfgang Faber Onofrio Febbraro Nicola Leone Marco Manna Alessandra Martello Claudio Panetta Simona Perri Kristian Reale Maria Santoro Marco Siri anni Giorgio Terracina Pierfrancesco Veltri The answer set programming competition preliminary report competition track James Delgrande Wolfgang Faber Eds Proceedings 11th International Conference Logic Programming Nonmonotonic Rea soning LPNMR11 Vancouver Canada Lecture Notes Computer Science vol 6645 Springer Verlag 2011 pp 388403 httpswww matunicalitaspcomp2011OﬃcialProblemSuite 19 Ashok K Chandra David Harel Horn clause queries generalizations J Log Program 2 1 1985 115 20 Hubie Chen Yannet Interian A model generating random quantiﬁed Boolean formulas Leslie Pack Kaelbling Alessandro Saﬃotti Eds Pro ceedings 19th International Joint Conference Artiﬁcial Intelligence IJCAI05 Edinburgh Scotland UK Professional Book Center August 2005 pp 6671 21 Jianer Chen Yang Liu Songjian Lu Barry OSullivan Igor Razgon A ﬁxedparameter algorithm directed feedback vertex set problem J ACM 55 5 2008 119 100 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 2001 374425 22 Jianer Chen Iyad A Kanj Ge Xia Improved upper bounds vertex cover Theor Comput Sci 411 4042 September 2010 37363756 23 Rajesh Chitnis Marek Cygan Mohammadtaghi Hajiaghayi Dániel Marx Directed subset feedback vertex set ﬁxedparameter tractable Artur Czumaj Kurt Mehlhorn Andrew Pitts Roger Wattenhofer Eds Proceedings 39th International Colloquium Automata Languages Programming ICALP12 Warwick UK Lecture Notes Computer Science vol 7391 Springer Verlag July 2012 pp 230241 24 Vasek Chvatal Linear Programming Series Books Mathematical Sciences WH Freeman Company New York 1983 25 William Cook Thorsten Koch Daniel E Steffy Kati Wolter A hybrid branchandbound approach exact rational mixedinteger programming Math Program Comput 5 3 2013 305344 26 Marek Cygan Marcin Pilipczuk Michał Pilipczuk Jakub Onufry Wojtaszczyk Subset feedback vertex set ﬁxedparameter tractable Luca Aceto Monika Henzinger Jiˇrí Sgall Eds Proceedings 38th International Colloquium Automata Languages Programming ICALP11 Lecture Notes Computer Science vol 6755 Springer Verlag 2011 pp 449461 27 Evgeny Dantsin Thomas Eiter Georg Gottlob Andrei Voronkov Complexity expressive power logic programming ACM Comput Surv 33 3 28 Ronald DeHaan Stefan Szeider The parameterized complexity reasoning problems NP Chitta Baral Giuseppe De Giacomo Thomas Eiter Eds Proceedings 14th International Conference Principles Knowledge Representation Reasoning KR14 Vienna Austria The AAAI Press 2014 Full version available arXiv13121672 29 Marc Denecker Joost Vennekens Stephen Bond Martin Gebser Mirosław Truszczy nski The second answer set programming competition Esra Erdem Fangzhen Lin Torsten Schaub Eds Proceedings 10th International Conference Logic Programming Nonmonotonic Reasoning LPNMR09 Potsdam Germany Lecture Notes Computer Science vol 5753 Springer Verlag September 2009 pp 637654 30 Reinhard Diestel Graph Theory 2nd edition Graduate Texts Mathematics vol 173 Springer Verlag New York 2000 31 Bistra N Dilkina Carla P Gomes Ashish Sabharwal Tradeoffs complexity backdoor detection Proceedings 13th International Conference Principles Practice Constraint Programming CP07 Lecture Notes Computer Science vol 4741 Springer Verlag 2007 pp 256270 32 Bistra N Dilkina Carla P Gomes Ashish Sabharwal Tradeoffs backdoor detection Sat Unsat formulas Proceedings 10th Interna tional Symposium Artiﬁcial Intelligence Mathematics ISAIM08 Fort Lauderdale FL USA January 2008 pp 256270 33 William F Dowling Jean H Gallier Lineartime algorithms testing satisﬁability propositional Horn formulae J Log Program 1 3 1984 267284 34 Rodney G Downey Michael R Fellows Parameterized Complexity Monographs Computer Science Springer Verlag New York 1999 35 Rodney G Downey Michael R Fellows Fundamentals Parameterized Complexity Texts Computer Science Springer Verlag London UK 2013 36 Rodney G Downey Michael R Fellows Ulrike Stege Parameterized complexity framework systematically confronting computational intractabil ity Contemporary Trends Discrete Mathematics DIMACS DIMATIA Future AMSDIMACS vol 49 American Mathematical Society 1999 pp 4999 37 Christian Drescher Martin Gebser Torsten Grote Benjamin Kaufmann Arne König Max Ostrowski Torsten Schaub Conﬂictdriven disjunctive answer set solving Gerhard Brewka Jérôme Lang Eds Proceedings 11th International Conference Principles Knowledge Representation Reasoning KR08 Sydney NSW Australia The AAAI Press September 2008 pp 422432 38 Christian Drescher Martin Gebser Benjamin Kaufmann Torsten Schaub Heuristics conﬂict resolution Maurice Pagnucco Michael Thielscher Eds Proceedings 12th International Workshop Nonmonotonic Reasoning NMR08 vol UNSWCSETR0819 The University New South Wales 2008 pp 141149 39 Paul E Dunne Computational properties argument systems satisfying graphtheoretic constraints Artif Intell 171 1015 2007 701729 40 Wolfgang Dvoˇrák Sebastian Ordyniak Stefan Szeider Augmenting tractable fragments abstract argumentation Artif Intell 186 2012 157173 41 Thomas Eiter Georg Gottlob On computational cost disjunctive logic programming propositional case Ann Math Artif Intell 15 34 1995 289323 42 T Eiter M Fink H Tompits S Woltran Simplifying logic programs uniform strong equivalence Ilkka Niemelä Vladimir Lifschitz Eds Proceedings 7th International Conference Logic Programming Nonmonotonic Reasoning LPNMR07 Tempe AZ USA Lecture Notes Computer Science vol 2923 Springer Verlag May 2004 pp 8799 43 Esra Erdem Vladimir Lifschitz Tight logic programs Theory Pract Log Program 3 July 2003 499518 44 William A Stein et al Sage mathematics software version 51rc0 Sage development team httpwwwsagemathorg 2012 45 Wolfgang Faber Nicola Leone Cristinel Mateis Gerald Pfeifer Using database optimization techniques nonmonotonic reasoning IO Committee Ed Proceedings 7th International Workshop Deductive Databases Logic Programming DDLP99 Prolog Association Japan 1999 pp 135139 46 Francois Fages Consistency Clarks completion existence stable models Log Methods Comput Sci 1 1 1994 5160 47 Johannes K Fichte Stefan Szeider Backdoors tractable answerset programming Toby Walsh Ed Proceedings 22nd International Joint Conference Artiﬁcial Intelligence IJCAI11 Barcelona Catalonia Spain AAAI PressIJCAI July 2011 pp 863868 48 Johannes K Fichte Stefan Szeider Backdoors normality disjunctive logic programs Marie des Jardins Michael Littman Eds Proceedings 27th AAAI Conference Artiﬁcial Intelligence AAAI13 Bellevue WA USA The AAAI Press July 2013 pp 320327 A preliminary version paper presented Workshop Answer Set Programming Other Computing Paradigms ASPOCP12 49 Johannes K Fichte The good bad odd cycles answerset programs Daniel Lassiter Marija Slavkovik Eds Proceedings 23rd European Summer School Logic Language Information ESSLLI11 New Directions Logic Language Computation ESSLLI10 ESSLLI11 Student Sessions Selected Papers Series Lecture Notes Computer Science vol 7415 Springer Verlag 2012 pp 7890 50 Jörg Flum Martin Grohe Parameterized Complexity Theory Theor Comput Sci vol XIV Springer Verlag Berlin 2006 51 Lance Fortnow Rahul Santhanam Infeasibility instance compression succinct PCPs NP J Comput Syst Sci 77 1 2011 91106 52 Steven Fortune John Hopcroft James Wyllie The directed subgraph homeomorphism problem Theor Comput Sci 10 2 1980 111121 53 Marco Gario Horn backdoor detection vertex cover benchmark description Adrian Balint Anton Belov Daniel Diepold Simon Gerber Matti Järvisalo Carsten Sinz Eds Proceedings SAT Challenge 2012 Solver Benchmark Descriptions 2012 54 Serge Gaspers Stefan Szeider Backdoors acyclic SAT Artur Czumaj Kurt Mehlhorn Andrew M Pitts Roger Wattenhofer Eds Proceedings 39th International Colloquium Automata Languages Programming ICALP12 Warwick UK Lecture Notes Computer Science vol 7391 Springer Verlag July 2012 pp 363374 55 Serge Gaspers Stefan Szeider Backdoors satisfaction Hans Bodlaender Rod Downey Fedor Fomin Dániel Marx Eds The Multivariate Algo rithmic Revolution Beyond Lecture Notes Computer Science vol 7370 Springer Verlag Heidelberg Germany 2012 pp 287317 56 Serge Gaspers Stefan Szeider Strong backdoors nested satisﬁability Alessandro Cimatti Roberto Sebastiani Eds Proceedings 15th International Conference Theory Applications Satisﬁability Testing SAT12 Trento Italy Lecture Notes Computer Science vol 7317 Springer Verlag June 2012 pp 7285 57 Serge Gaspers Stefan Szeider Strong backdoors bounded treewidth SAT Omer Reingold Ed Proceedings 54th Annual IEEE Symposium Foundations Computer Science FOCS13 Berkeley California USA October 2729 IEEE Computer Soc 2013 pp 489498 58 Serge Gaspers Stefan Szeider Guarantees limits preprocessing constraint satisfaction reasoning Artif Intell 216 2014 119 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 101 59 Serge Gaspers Sebastian Ordyniak MS Ramanujan Saket Saurabh Stefan Szeider Backdoors qHorn Natacha Portier Thomas Wilke Eds Proceedings 30th International Symposium Theoretical Aspects Computer Science STACS13 San Francisco CA Leibniz International Proceedings Informatics LIPIcs vol 20 Schloss Dagstuhl 2013 pp 6779 60 Martin Gebser Roland Kaminski Personal communication 2012 61 Martin Gebser Torsten Schaub Asparagus httpasparaguscsunipotsdamde 2009 62 M Gebser B Kaufmann A Neumann T Schaub Conﬂictdriven answer set solving Manuela M Veloso Ed Proceedings 20th International Joint Conference Artiﬁcial Intelligence IJCAI07 Hyderabad India IJCAI January 2007 pp 386392 63 Martin Gebser Lengning Liu Gayathri Namasivayam André Neumann Torsten Schaub Mirosław Truszczy nski The ﬁrst answer set programming competition Chitta Baral Gerhard Brewka John Schlipf Eds Proceedings 9th Conference Logic Programming Nonmonotonic Reasoning LPNMR07 Tempe AZ USA Lecture Notes Computer Science vol 4483 Springer Verlag May 2007 pp 317 64 Martin Gebser Torsten Schaub Sven Thiele Gringo new grounder answer set programming Chitta Baral Gerhard Brewka John Schlipf Eds Proceedings 9th International Conference Logic Programming Nonmonotonic Reasoning LPNMR07 Tempe AZ USA Lecture Notes Computer Science vol 4483 Springer Verlag May 2007 pp 266271 65 Martin Gebser Benjamin Kaufmann André Neumann Torsten Schaub Advanced preprocessing answer set solving Malik Ghallab Constantine D Spyropoulos Nikos Fakotakis Nikolaos M Avouris Eds Proceedings 18th European Conference Artiﬁcial Intelligence ECAI08 Patras Greece Front Artif Intell Appl vol 178 IOS Press July 2008 pp 1519 66 Martin Gebser Roland Kaminski Benjamin Kaufmann Max Ostrowski Torsten Schaub Sven Thiele A users guide gringo clasp clingo iclingo 67 M Gebser T Schaub S Thiele P Veber Detecting inconsistencies large biological networks answer set programming Theory Pract Log Technical report University Potsdam 2010 Program 11 23 2011 323360 68 Martin Gebser Roland Kaminski Benjamin Kaufmann Torsten Schaub Challenges answer set solving Marcello Balduccini TranCao Son Eds Logic Programming Knowledge Representation Nonmonotonic Reasoning Essays Dedicated Michael Gelfond Occasion His 65th Birthday Lecture Notes Artiﬁcial Intelligence vol 6565 Springer Verlag 2011 pp 7490 69 Martin Gebser Roland Kaminski Benjamin Kaufmann Torsten Schaub Multicriteria optimization answer set programming John Gallagher Michael Gelfond Eds Technical Communications 27th International Conference Logic Programming ICLP11 Dagstuhl Germany Leibniz International Proceedings Informatics LIPIcs vol 11 Dagstuhl Publishing 2011 pp 110 70 Martin Gebser Roland Kaminski Torsten Schaub Complex optimization answer set programming Theory Pract Log Program 11 45 2011 71 Martin Gebser Benjamin Kaufmann Roland Kaminski Max Ostrowski Torsten Schaub Marius Schneider Potassco Potsdam answer set solving 821839 collection AI Commun 24 2 2011 107124 72 M Gebser B Kaufmann T Schaub Conﬂictdriven answer set solving theory practice Artif Intell 187 188 2012 5289 73 Martin Gebser Roland Kaminski Benjamin Kaufmann Torsten Schaub Answer Set Solving Practice Morgan Claypool 2012 74 Martin Gebser Thomas Glase Orkunt Sabuncu Torsten Schaub Matchmaking answer set programming Pedro Cabalar Tran Cao Son Eds Proceedings 12th International Conference Logic Programming Nonmonotonic Reasoning LPNMR13 Corunna Spain Lecture Notes Computer Science vol 8148 Springer Verlag 2013 pp 342347 75 Martin Gebser Benjamin Kaufmann Ramon P Otero Javier Romero Torsten Schaub Philipp Wanko Domainspeciﬁc heuristics answer set pro gramming Marie des Jardins Michael Littman Eds Proceedings 27th AAAI Conference Artiﬁcial Intelligence AAAI13 Bellevue WA USA The AAAI Press July 2013 pp 350356 76 Martin Gebser Tomi Janhunen Jussi Rintanen Answer set programming SAT modulo acyclicity Torsten Schaub Gerhard Friedrich Barry OSullivan Eds Proceedings 21st European Conference Artiﬁcial Intelligence ECAI14 Prague Czech Republic Front Artif Intell Appl vol 263 IOS Press August 2014 pp 351356 77 Allen Van Gelder Negation failure tight derivations general logic programs J Log Program 6 12 1989 109133 78 Michael Gelfond Vladimir Lifschitz The stable model semantics logic programming Robert A Kowalski Kenneth A Bowen Eds Proceedings 5th International Conference Symposium ICLPSLP88 Seattle Washington vol 2 MIT Press August 1988 pp 10701080 79 Michael Gelfond Vladimir Lifschitz Classical negation logic programs disjunctive databases New Gener Comput 9 34 1991 365386 80 E Giunchiglia A Massarotto R Sebastiani Act rest follow exploiting determinism planning satisﬁability Jack Mostow Charles Rich Eds Proceedings 15th National Conference Artiﬁcial Intelligence AAAI98 Madison WI USA The AAAI Press 1998 pp 948953 81 E Giunchiglia M Maratea A Tacchella Dependent independent variables propositional satisﬁability Logics Artiﬁcial Intelligence 2002 pp 296307 82 Enrico Giunchiglia Yuliya Lierler Marco Maratea Answer set programming based propositional satisﬁability J Autom Reason 36 4 2006 345377 83 Georg Gottlob Reinhard Pichler Hypergraphs model checking acyclicity hypertreewidth versus cliquewidth SIAM J Comput 33 2 2004 84 Georg Gottlob Stefan Szeider Fixedparameter algorithms artiﬁcial intelligence constraint satisfaction database problems Comput J 51 3 85 Georg Gottlob Francesco Scarcello Martha Sideri Fixedparameter complexity AI nonmonotonic reasoning Artif Intell 138 12 2002 86 Georg Gottlob Reinhard Pichler Fang Wei Bounded treewidth key tractability knowledge representation reasoning Artif Intell 174 1 87 Inc Gurobi Optimization Gurobi optimizer reference manual Version 502 2014 88 Holger H Hoos Automated algorithm conﬁguration parameter tuning Youssef Hamadi Eric Monfroy Frédéric Saubion Eds Autonomous Search Springer Verlag 2012 pp 3771 89 IBM IBM ILOG CPLEX optimization studio CPLEX users manual version 12 release 4 edition 2011 90 Michael Jakl Reinhard Pichler Stefan Woltran Answerset programming bounded treewidth Craig Boutilier Ed Proceedings 21st International Joint Conference Artiﬁcial Intelligence IJCAI09 Pasadena CA USA vol 2 Elsevier Science Publishers NorthHolland July 2009 pp 816822 91 Tomi Janhunen Ilkka Niemelä Compact translations nondisjunctive answer set programs propositional clauses Marcello Balduccini Tran Son Eds Logic Programming Knowledge Representation Nonmonotonic Reasoning Essays Dedicated Michael Gelfond Occasion His 65th Birthday Lecture Notes Artiﬁcial Intelligence vol 6565 Springer Verlag 2011 pp 111130 92 Tomi Janhunen Ilkka Niemelä Dietmar Seipel Patrik Simons JiaHuai You Unfolding partiality disjunctions stable model semantics ACM Trans Comput Log 7 1 2006 137 93 Tomi Janhunen Ilkka Niemelä Mark Sevalnev Computing stable models reductions difference logic Esra Erdem Fangzhen Lin Torsten Schaub Eds Proceedings 10th International Conference Logic Programming Nonmonotonic Reasoning LPNMR09 Potsdam Germany Lecture Notes Computer Science vol 5753 Springer Verlag September 2009 pp 142154 351378 2008 303325 5586 2010 105132 102 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 1997 69112 94 Mikoláš Janota Joao MarquesSilva A tool circumscriptionbased MUS membership testing James P Delgrande Wolfgang Faber Eds Pro ceedings 11th International Conference Logic Programming Nonmonotonic Reasoning LPNMR11 Vancouver Canada Lecture Notes Computer Science vol 6645 Springer Verlag May 2011 pp 266271 95 Matti Järvisalo Tommi Junttila Limitations restricted branching clause learning Constraints 14 3 2009 325356 96 M Järvisalo Ilkka Niemelä The effect structural branching eﬃciency clause learning SAT solving experimental study J Algorithms 63 13 2008 90113 97 Holger Jost Orkunt Sabuncu Torsten Schaub Suggesting new interactions related events social network elderly Proceedings 26th BCS Conference Human Computer Interaction HCI12 Birmingham UK British Computer Society Swinton September 2012 98 Naonori Kakimura Kenichi Kawarabayashi Yusuke Kobayashi ErdösPósa property algorithmic applications parity constraints subset feed set subset packing Dana Randall Ed Proceedings 23rd Annual ACMSIAM Symposium Discrete Algorithms SODA12 San Francisco CA USA Society Industrial Applied Mathematics SIAM 2012 pp 17261736 99 Kanchana Kanchanasut Peter J Stuckey Transforming normal logic programs constraint logic programs Theor Comput Sci 105 1 1992 2756 100 Richard M Karp Richard J Lipton Some connections nonuniform uniform complexity classes Proceedings 12th Annual ACM Symposium Theory Computing STOC80 Los Angeles CA USA April 1980 pp 302309 101 Hadi Katebi Karem A Sakallah João P MarquesSilva Empirical study anatomy modern Sat solvers Karem A Sakallah Laurent Simon Eds Proceedings 14th International Conference Theory Applications Satisﬁability Testing SAT11 Ann Arbor MI USA Lecture Notes Computer Science vol 6695 Springer Verlag June 2011 pp 343356 102 Kenichi Kawarabayashi Yusuke Kobayashi Fixedparameter tractability subset feedback set problem scycle packing problem Technical report University Tokyo Japan 2010 103 Stephan Kottler Michael Kaufmann Carsten Sinz A new bound NPhard subclass 3SAT backdoors Hans Kleine Büning Xishun Zhao Eds Proceedings 11th International Conference Theory Applications Satisﬁability Testing SAT08 Guangzhou China Lecture Notes Computer Science vol 4996 Springer Verlag May 2008 pp 161167 104 Andrea S Lapaugh Christos H Papadimitriou The evenpath problem graphs digraphs Networks 14 4 1984 507513 105 Joohyung Lee Vladimir Lifschitz Loop formulas disjunctive logic programs Catuscia Palamidessi Ed Logic Programming Mumbai India Lecture Notes Computer Science vol 2916 Springer Verlag 2003 pp 451465 106 Nicola Leone Pasquale Rullo Francesco Scarcello Disjunctive stable models unfounded sets ﬁxpoint semantics computation Inf Comput 135 2 107 Nicola Leone Gerald Pfeifer Wolfgang Faber Thomas Eiter Georg Gottlob Simona Perri Francesco Scarcello The DLV knowledge repre sentation reasoning ACM Trans Comput Log 7 3 2006 499562 108 Yuliya Lierler CMODELS SATbased disjunctive answer set solver Chitta Baral Gianluigi Greco Nicola Leone Giorgio Terracina Eds Proceedings 8th International Conference Logic Programming Nonmonotonic Reasoning LPNMR05 Diamante Italy Lecture Notes Computer Science vol 3662 Springer Verlag 2005 pp 447451 109 Fangzhen Lin Jicheng Zhao On tight logic programs translation normal logic programs propositional logic Georg Gottlob Toby Walsh Eds Proceedings 18th International Joint Conference Artiﬁcial Intelligence IJCAI03 Acapulco Mexico Morgan Kaufmann August 2003 pp 853858 110 Fangzhen Lin Xishun Zhao On odd cycles normal logic programs Anthony G Cohn Ed Proceedings 19th National Conference Artiﬁcial Intelligence AAAI04 San Jose CA USA The AAAI Press July 2004 pp 8085 111 Fangzhen Lin Yuting Zhao ASSAT computing answer sets logic program SAT solvers Artif Intell 157 12 2004 115137 112 Guohua Liu Tomi Janhunen Ilkka Niemelä Answer set programming mixed integer programming Sheila McIlraith Thomas Eiter Eds Proceedings 13th International Conference Principles Knowledge Representation Reasoning KR12 Rome Italy The AAAI Press 2012 pp 3242 113 Wiktor Marek Mirosław Truszczy nski Autoepistemic logic J ACM 38 3 1991 588619 114 Wiktor Marek Mirosław Truszczy nski Computing intersection autoepistemic expansions V Wiktor Marek VS Subrahmanian Anil Nerode Eds Proceedings 1st International Conference Logic Programming Nonmonotonic Reasoning LPNMR91 Washington DC USA MIT Press July 1991 pp 3750 115 Victor W Marek Mirosław Truszczy nski Stable models alternative logic programming paradigm Krzysztof R Apt Victor W Marek Mirosław Truszczy nski David S Warren Eds The Logic Programming Paradigm A 25Year Perspective Artiﬁcial Intelligence Springer Verlag Berlin Germany September 1999 pp 375398 116 Pranabendu Misra Venkatesh Raman MS Ramanujan Saket Saurabh Parameterized algorithms cycle transversal Martin Charles Golumbic Michal Stern Avivit Levy Gila Morgenstern Eds Proceedings 38th International Workshop GraphTheoretic Concepts Com puter Science WG12 Lecture Notes Computer Science vol 7551 Springer Verlag 2012 pp 172183 117 Marco Montalva Julio Aracena Anahí Gajardo On complexity feedback set problems signed digraphs Electron Notes Discrete Math 30 118 Michael Morak Stefan Woltran Preprocessing complex nonground rules answer set programming Agostino Dovier Vítor Santos Costa Eds Technical Communications 28th International Conference Logic Programming ICLP12 Dagstuhl Germany Leibniz International Proceedings Informatics LIPIcs vol 17 Dagstuhl Publishing 2012 pp 247258 119 Michael Morak Reinhard Pichler Stefan Rümmele Stefan Woltran A dynamicprogramming based ASPsolver Tomi Janhunen Ilkka Niemelä Eds Proceedings 12th European Conference Logics Artiﬁcial Intelligence JELIA10 Helsinki Finland Lecture Notes Computer Science vol 6341 Springer Verlag September 2010 pp 369372 120 Rolf Niedermeier Invitation FixedParameter Algorithms Oxford Lecture Series Mathematics Its Applications vol 31 Oxford University Press New York NY USA 2006 121 Ilkka Niemelä Jussi Rintanen On impact stratiﬁcation complexity nonmonotonic reasoning J Appl NonClass Log 4 2 1994 141179 122 Ilkka Niemelä Logic programs stable model semantics constraint programming paradigm Ann Math Artif Intell 25 3 1999 241273 123 Naomi Nishimura Prabhakar Ragde Stefan Szeider Detecting backdoor sets respect Horn binary clauses Holger H Hoos David G Mitchell Eds Proceedings 7th International Conference Theory Applications Satisﬁability Testing SAT04 Vancouver BC Canada Lecture Notes Computer Science vol 3542 Springer Verlag May 2004 pp 96103 124 Naomi Nishimura Prabhakar Ragde Stefan Szeider Solving SAT vertex covers Acta Inform 44 78 2007 509523 125 Andreas Pfandler Stefan Rümmele Stefan Szeider Backdoors abduction Francesca Rossi Ed Proceedings 23rd International Joint Conference Artiﬁcial Intelligence IJCAI13 Beijing China The AAAI Press August 2013 pp 10461052 126 Reinhard Pichler Stefan Rümmele Stefan Woltran Belief revision bounded treewidth Esra Erdem Fangzhen Lin Torsten Schaub Eds Proceedings 10th International Conference Logic Programming Nonmonotonic Reasoning LPNMR09 Potsdam Germany Lecture Notes Computer Science vol 5753 Springer Verlag 2009 pp 250263 2008 249254 JK Fichte S Szeider Artiﬁcial Intelligence 220 2015 64103 103 127 Knot Pipatsrisawat Adnan Darwiche A lightweight component caching scheme satisﬁability solvers João P MarquesSilva Karem A Sakallah Eds Proceedings 10th International Conference Theory Applications Satisﬁability Testing SAT07 Lisbon Portugal Lecture Notes Computer Science vol 4501 Springer Verlag May 2007 pp 294299 128 Igor Razgon Barry OSullivan Almost 2SAT ﬁxed parameter tractable J Comput Syst Sci 75 8 2009 435450 129 Francesco Ricca G Grasso Mario Alviano Marco Manna V Lio S Iiritano Nicola Leone Teambuilding answer set programming GioiaTauro seaport Theory Pract Log Program 12 2012 361381 130 Neil Robertson PD Seymour Graph minors III Planar treewidth J Comb Theory Ser B 36 1 1984 4964 131 Neil Robertson PD Seymour Graph minors survey Surveys Combinatorics 1985 Invited Papers 10th British Combinatorial Confer ence London Mathematical Society Lecture Note Series Cambridge University Press Cambridge 1985 pp 153171 132 Neil Robertson PD Seymour Graph minors II Algorithmic aspects treewidth J Algorithms 7 3 1986 309322 133 Neil Robertson PD Seymour Robin Thomas Permanents Pfaﬃan orientations directed circuits Ann Math 150 3 1999 929975 134 Frances Rosamond Table races Parameterized Complexity Newsletter 2010 pp 45 httpfptwikidotcom 135 Yongshao Ruan Henry A Kautz Eric Horvitz The backdoor key path understanding problem hardness Deborah L McGuinness George Fergu son Eds Proceedings 19th National Conference Artiﬁcial Intelligence AAAI04 San Jose CA USA The AAAI Press July 2004 pp 124130 136 Marko Samer Stefan Szeider Backdoor trees Robert C Holte Adele E Howe Eds Proceedings 23rd Conference Artiﬁcial Intelligence AAAI08 Vancouver BC Canada The AAAI Press July 2008 pp 363368 137 Marko Samer Stefan Szeider Backdoor sets quantiﬁed Boolean formulas J Autom Reason 42 1 2009 7797 138 Marko Samer Stefan Szeider Fixedparameter tractability Armin Biere Marijn Heule Hans van Maaren Toby Walsh Eds Handbook Satisﬁa bility IOS Press 2009 pp 425454 chapter 13 139 CP Schnorr On selftransformable combinatorial problems H König B Korte K Ritter Eds Mathematical Programming Oberwolfach Mathematical Programming Studies vol 14 Springer Verlag 1981 pp 225243 140 Alexander Schrijver Theory Linear Integer Programming John Wiley Sons 1998 141 Patrik Simons Ilkka Niemelä Timo Soininen Extending implementing stable model semantics Knowledge Representation Logic Programming Artif Intell 138 12 2002 181234 142 Sinz Carsten Towards optimal CNF encoding boolean cardinality constraints Peter van Beek Ed Proceedings 11th International Conference Principles Practice Constraint Programming CP05 Sitges Barcelona Spain Lecture Notes Computer Science vol 3709 Springer Verlag 2005 pp 827831 143 Ofer Strichman Tuning SAT checkers bounded model checking E Allen Emerson Aravinda Prasad Sistla Eds Proceedings 12th International Conference Computer Aided Veriﬁcation CAV00 Chicago IL USA Lecture Notes Computer Science vol 1855 Springer Verlag July 2000 pp 480494 144 Stefan Szeider Matched formulas backdoor sets J Satisf Boolean Model Comput 6 2008 112 145 Michael Thielscher Answer set programming singleplayer games general game playing Patricia M Hill David S Warren Eds Proceedings 25th International Conference Logic Programming ICLP09 Pasadena CA USA July 1417 Lecture Notes Computer Science vol 5649 Springer Verlag 2009 pp 327341 146 Stéphan Thomassé A quadratic kernel feedback vertex set Claire Mathieu Ed Proceedings 29th Annual ACMSIAM Symposium Discrete Algorithms SODA09 New York NY USA Society Industrial Applied Mathematics SIAM January 2009 pp 115119 147 Son Thanh To Enrico Pontelli Tran Cao Son A conformant planner explicit disjunctive representation belief states Alfonso Gerevini Adele E Howe Amedeo Cesta Ioannis Refanidis Eds Proceedings 19th International Conference Automated Planning Scheduling ICAPS09 Thessaloniki Greece The AAAI Press September 2009 pp 305312 148 Mirosław Truszczy nski Trichotomy dichotomy results complexity reasoning disjunctive logic programs Theory Pract Log Program 149 MH Van Emden Robert A Kowalski The semantics predicate logic programming language J ACM 23 October 1976 733742 150 Guido van Rossum Python tutorial Technical Report CSR9526 Centrum voor Wiskunde en Informatica CWI Amsterdam May 1995 151 Vijay Vazirani Mihalis Yannakakis Pfaﬃan orientations 01 permanents cycles directed graphs Timo Lepistö Arto Salomaa Eds Proceedings 15th International Colloquium Automata Languages Programming ICALP88 Tampere Finland Lecture Notes Com puter Science vol 317 Springer Verlag 1988 pp 667681 152 Ryan Williams Carla Gomes Bart Selman Backdoors typical case complexity Georg Gottlob Toby Walsh Eds Proceedings 18th International Joint Conference Artiﬁcial Intelligence IJCAI03 Acapulco Mexico Morgan Kaufmann August 2003 pp 11731178 153 Ryan Williams Carla Gomes Bart Selman On connections backdoors restarts heavytailedness combinatorial search Informal Proceedings 6th International Conference Theory Applications Satisﬁability Testing SAT03 Portoﬁno Italy May 2003 pp 222230 154 CheeK Yap Some consequences nonuniform conditions uniform classes Theor Comput Sci 26 3 1983 287300 155 Yuting Zhao Fangzhen Lin Answer set programming phase transition study randomly generated programs Catuscia Palamidessi Ed Proceedings 19th International Conference Logic Programming ICLP03 Mumbai India December 913 2003 Lecture Notes Computer Science vol 2916 Springer Verlag 2003 pp 239253 156 Jicheng Zhao A study answer set programming Mphil thesis The Hong Kong University Science Technology Dept Computer Science 11 2011 881904 2002