Artiﬁcial Intelligence 235 2016 125 Contents lists available ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint A formalization programs ﬁrstorder logic discrete linear order Fangzhen Lin Department Computer Science The Hong Kong University Science Technology Clear Water Bay Kowloon Hong Kong r t c l e n f o b s t r c t Article history Received 17 December 2014 Received revised form 23 August 2015 Accepted 28 January 2016 Available online 11 February 2016 Keywords Program semantics Reasoning programs Firstorder logic We consider problem representing reasoning programs propose translation core procedural iterative programming language ﬁrst order logic quantiﬁcation domain natural numbers includes usual successor function linear order essentially ﬁrstorder logic discrete linear order Unlike Hoares logic approach rely loop invariants Unlike typical temporal logic speciﬁcation program translation require transition model program compositional structures program Some nontrivial examples given effectiveness translation proving properties programs 2016 Elsevier BV All rights reserved 1 Introduction In science represent reason programs effectively major concern beginning For imperative nonconcurrent programs considering notable approaches include Dijkstras calculus weakest preconditions 12 Hoares logic 3 dynamic logic 4 separation logic 5 For logics provide rules proving assertions programs In particular proving assertions iterative loops logics rely known Hoares loop invariants In paper propose way translate program ﬁrstorder theory quantiﬁcation natural numbers The properties need natural numbers smallest element zero linearly ordered successor plus Thus essentially ﬁrstorder logic predeﬁned discrete linear order This logic closely related linear temporal logic main formalism specifying concurrent programs 6 Given program translate ﬁrstorder theory captures relationship input output values program variables independent want prove program For instance trivially following assignment X XY captured following axioms cid2 X Y cid2 Y X Y Email address ﬂincsusthk httpdxdoiorg101016jartint201601014 00043702 2016 Elsevier BV All rights reserved 2 F Lin Artiﬁcial Intelligence 235 2016 125 X Y denote initial values corresponding program variables X values statement performed Obviously question loops This quantiﬁcation natural numbers comes Consider following loop Y cid2 cid2 X M X X1 It captured following set axioms cid2 X cid2 XN cid2 M M X M X X M X X0 X nXn 1 Xn 1 XN M nn N Xn M N natural number constant denoting total number iterations loop runs termination Xn value X nth iteration Thus axiom says program enters loop output value program variable X denoted X XN value X loop exits The purpose paper set axioms systematically generated examples reasoning set axioms Without going details unlike Hoares logic axiomatization use loop invariants One unlike typical temporal logic speciﬁcation program need transition model program need track program execution traces We discuss related work later cid2 2 Preliminaries We use typed ﬁrstorder language We assume type natural numbers nonnegative integers Depending programs types integers For natural numbers use constant 0 linear ordering relation successor function n 1 predecessor function n 1 We follow convention logic use lower case letters possibly subscripts logical variables In particular use m n natural number variables x y z generic variables The variables program treated functions logic written upper case letters strings letters We use following shorthands The conditional expression e1 ϕ e2 e3 shorthand conjunction following sentences cid7xϕ e1 e2 cid7xϕ e1 e3 cid7x free variables ϕ ei 1 2 3 Typically free variables ϕ occur e1 Our important shorthand following expression says e smallest natural number satisﬁes ϕn smalleste n ϕ shorthand following formula ϕne mm e ϕnm n natural number variable ϕ m new natural number variable e ϕ ϕne result replacing n ϕ e similarly ϕnm For example smallestM k k N foundk says M smallest natural number M N foundM M N foundM nn M n N foundn Finally use convention free variables displayed sentence implicitly universally quantiﬁed outside For instance following displayed formula n M n N foundn F Lin Artiﬁcial Intelligence 235 2016 125 3 stands nn M n N foundn universal quantiﬁcation domain natural numbers n natural number variable Notice macro smallestM k k N foundk k free variable The following useful properties smallest macro Proposition 1 Let cid7x free variables n ϕn m variable ϕn We cid7xnϕn msmallestm n ϕn Proposition 2 Let cid7x free variables n ϕn m variable ϕn We cid7x msmallestm n ϕn m 0 ϕm ϕm 1 Furthermore cid7xnkk n ϕk kk n ϕk msmallestm n ϕn ϕm ϕm 1 k variable ϕn Proof For given cid7x m suppose smallestm n ϕn m 0 Then ϕm kk m ϕk Since m 0 ϕm 1 Now suppose ϕm ϕm 1 M kk M ϕk kk M ϕk This means M m 1 smallestm n ϕn cid2 To motivate proposition consider following loop X M X X1 Given input M number NM iterations loop exit captured formula smallestNM n Xn M It seen NM 1 NM 1 number iterations loop exits input M 1 input M This proved following proposition Proposition 3 Let cid7x free variables n ϕ1n ϕ2n m1 m2 k t variables ϕ1 ϕ2 We cid7x t m1 m2kϕ1k ϕ2k t kk t ϕ2k smallestm1 n ϕ1n smallestm2 n ϕ2n m2 m1 t 3 A simple class programs Consider following simple class programs P constructed set array identiﬁers array set functions operator set Boolean operators booleanop E arrayEE operatorEE B E E booleanopBB P arrayEE E B P P P P B P Here E denotes expressions B boolean expressions P programs Notice instead example arrayij commonly programming languages refer array element use notation arrayij com monly mathematics logic As programs constructed assignments sequences ifthenelse loops Other structs ifthen forloop deﬁned constructs For instance B P deﬁned B P X X We assume base ﬁrstorder language L contains functions predicates static sense semantics ﬁxed changed programs They include functions correspond operator predicates 4 F Lin Artiﬁcial Intelligence 235 2016 125 correspond booleanop possibly functions predicates formalizing domain knowledge In following L base language Given program P extend base language L functions represent program variables program These functions dynamic values changed execution program We assume program variables new L We assume overloading different program variables different arities Thus use program variables functions ﬁrstorder language Speciﬁcally V program variable nary array add V V new nary cid2x1 xn denote values x1 xnth cell V input output functions L V x1 xn V respectively program P For values execution P introduce temporary function symbols denote These temporary function symbols systematically named statement labels Section 6 useful interested properties hold execution program For assume interested program outputs Given program P set cid7X program variables including variables P deﬁne inductively set cid2 axioms P cid7X written cid3 cid7X P follows If P VE1Ek E cid3 cid7X P consists following axioms value VE1Ek possibly changed cid2 V cid7x x1 E 1 xk Ek E V cid7x cid2 cid7y Xcid7y X cid7X X different V X cid7x x1 xk k arity program variable array V We assume program expression E corresponding term E ﬁrstorder language Recall convention variables universally quantiﬁed The domains variables depend type program variable V If P B P1 P2 cid3 cid3 cid7X P 2 follows cid7X cid7X P constructed cid3 P 1 cid7X P 1 cid7X B ϕ ϕ cid3 P 2 B ϕ ϕ cid3 We assume boolean expression B corresponding formula B ﬁrstorder language If P P1 P2 cid3 cid3 cid7X cid7X P constructed cid3 P 1 cid7X ϕ cid7X cid2 cid7Y ϕ cid3 P 1 cid7X ϕ cid7X cid7Y ϕ cid3 P 2 cid7X P 2 connecting outputs P 1 inputs P 2 follows cid2 cid7Y Y 1 Yk tuple new function symbols Y arity Xi cid7X ϕ cid7X cid2 cid7Y Y similarly ϕ cid7X cid7Y The new function symbols cid7Y result replacing ϕ occurrence X called temporary functions denote values program variables execution program By inductive construction cid3 temporary function symbols introduced way Furthermore P 1 andor P 2 loops new natural number constants axioms constructed loops By renaming necessary assume cid3 common symbols share temporary symbols In words assume cid3 L cid7X cid7X cid3 cid3 cid3 cid7X P 2 cid7X P 1 cid7X P 2 cid7X P 1 cid7X P 2 cid7X P 1 cid2 If P B P1 F Lin Artiﬁcial Intelligence 235 2016 125 5 cid7X P constructed adding index parameter n dynamic functions cid3 Then cid3 body P 1 executed n times Formally consists following axioms cid7X P 1 record values cid7X P 1 ϕn ϕ cid3 Xicid7x Xicid7x 0 Xi cid7X smallestN n Bn icid7x Xicid7x N Xi cid7X X cid2 cid7X P 1 n new natural number variable ϕ N new natural number constant formula term α αn denotes value α body P 1 executed n times cid3 obtained α follows 1 xαn xαn α1 α2n α1n α2n αn αn 2 F e1 ekn F e1n ekn F predicate function base ﬁrstorder language L In particular cid2 e1 e2n e1n e2n ie1 ekn Xie1n ekn n 1 Xi cid7X 3 X 4 V e1 ekn V e1n ekn n V nonprimed function L While cid3 cid7X P denote set axioms P cid7X construction yield unique set axioms temporary functions introduced constructing axioms program sequences whileloops cid7X unique However cid3 P unique renaming new functions In particular different sets axioms logically equivalent considering program variables cid7X temporary functions forgotten More precisely given theories cid51 cid52 equivalent considering subset cid6 vocabularies model M1 cid51 modiﬁed model M2 cid52 M1 M2 agree cid6 conversely model cid52 similarly modiﬁed model cid51 cid7X P operational semantics In following simple prop Appendix A proves correctness cid3 erties axiomatization The following proposition says program local effects variables Proposition 4 Let cid7Y tuple program variables P cid3 equivalent union cid3 cid7X P set following frame axioms cid7X P Then considering cid7X cid7Y cid3 cid7X cid7Y P cid2 cid7y Y cid7y Y cid7Y Y The construction rule sequence P Q modiﬁed temporary functions need introduced occur P Q Proposition 5 Let cid7X tuple program variables including P Q cid7V V 1 V k tuple program variables P Q subset cid7X When considering cid7X cid3 cid7X P Q equivalent set following axioms cid7X ϕ cid7V cid2 cid7Y ϕ cid3 P cid7X ϕ cid7V cid7Y ϕ cid3 Q cid7Y Y 1 Yk tuple temporary functions Y arity V cid7V Again assume renaming necessary cid3 cid7X Q common function symbols cid7X base language L cid7X P cid3 The following important property axiomatization says need wait set axioms simpliﬁcation During construction axioms program simplify ﬁrst axioms subprograms This greatly simpliﬁes recursive procedure constructing axioms program Proposition 6 Let cid7X tuple program variables including occur program P For subprogram P cid7X P cid2 considering cid7X use T instead cid3 equivalent cid3 considering cid7X cid7X P resulting theory equivalent cid3 cid7X P cid2 computing cid3 T cid7X P cid2 Notice proposition use T instead cid3 cid7X P assume rename temporary function symbols necessary avoid conﬂicts For example P P 1 P 2 theory equivalent cid3 computing cid3 cid7X P cid2 cid7X P 1 cid2 Y Y X 1 X 1 6 F Lin Artiﬁcial Intelligence 235 2016 125 uses temporary function symbol Y need rename Y 1 Y cid3 cid7X P 2 cid7X P 2 If cid3 constructing cid3 cid7X P Before consider interesting examples illustrate construction cid3 31 A simple sequence cid7X P simple programs Consider following program P program variables X1 X2 notice X1 P X2 X1 1 X1 X11 cid3 X1 X2 X11 set following sentences cid2 1 cid2 2 X X 1 X2 cid3 X1 X2 X1 X11 set following sentences cid2 1 cid2 2 X X X1 1 X2 Thus cid3 X1 X2 P Y 1 1 Y 2 X2 cid2 1 cid2 2 X X Y 1 1 Y 2 Eliminating temporary constants Y 1 Y 2 X cid2 1 2 X cid2 2 X2 32 A simple loop Consider following program P simple loop I N X AI X AI I I1 Notice program variables X A I N Among A unary list rest 0ary constants equivalent set following sentences choice temporary Let P 1 body loop cid3 X AIN P 1 names Y 1 Y 2 Y 3 Y 4 Y 1 X AI AI X Y 2x X AI Ax Ax Y 3 X AI I I Y 4 X AI N N cid2 Y 1 cid2 x Y 2x A cid2 Y 3 1 cid2 Y 4 N X I Instead set compute cid3 X AIN following equivalent set axioms P Proposition 6 simplify ﬁrst eliminating Y 1 Y 2 Y 3 Y 4 F Lin Artiﬁcial Intelligence 235 2016 125 7 X cid2 X AI AI X cid2 x Ax A cid2 I 1 cid2 N N Thus cid3 X AIN P I X0 X Ax 0 Ax I0 I N0 N Xn 1 Xn AIn n AIn n Xn Ax n 1 Ax n In 1 In 1 Nn 1 Nn smallestM n In Nn X cid2 XM cid2 x Ax M A cid2 IM cid2 NM N I Clearly Ax N change Ax n Ax Nn N So following sentences expanding smallest macro X0 X I0 I Xn 1 Xn AIn AIn Xn In 1 In 1 IM N n M In N X cid2 XM cid2 x Ax A cid2 IM cid2 N N I Now suppose initially I 0 Solving recurrence I0 0 In 1 In 1 In n Thus M N n M n N imply M N So eliminate In M following axioms 8 F Lin Artiﬁcial Intelligence 235 2016 125 X0 X Xn 1 Xn An An Xn X cid2 XN cid2 x Ax A cid2 N cid2 N N I An example assertion prove program following 0 n N X cid2 An equivalent 0 n N XN An 2 proved induction N The base case N 0 trivial For inductive case suppose result holds N K Let N K 1 There cases consider XK AK XK AK We ﬁrst case The second case similar In ﬁrst case XK 1 AK need 0 n K 1 AK An Two cases 0 n K 1 0 n K n K The second case trivial For ﬁrst case AK An follows inductive assumption XK AK 33 Partial total correctness A program partially correct wrt speciﬁcation program satisﬁes speciﬁcation terminates It totally correct partially correct terminates cid2 cid3 In framework program P variables cid7X represented set sentences cid3 cid7X P Whatever properties wants P proved set sentences A partial correctness result corresponds proving sentence cid7X cid7X cid7X P An example assertion 2 simple loop On hand termination program proved showing new natural number constants introduced loops smallest cid7X macro expressions welldeﬁned logic means resulting theory cid3 P consistent model new constants mapped natural numbers For instance simple loop smallest macro smallestM n In Nn By Proposition 1 fact IN N holds veriﬁed theory consistent natural number M satisﬁes macro expression If loop terminate smallest macro cause contradiction For instance consider following loop I M I0 I I1 If initially I 0 M 0 loop forever Our axioms loop cid2 IN M cid2 M I I0 I In 1 In 0 In 1 In n N In M IN M If add I 0 0 M axioms conclude nIn M contradicts axiom IN M Of course logic means axioms loops entail I 0 0 M taken precondition loop F Lin Artiﬁcial Intelligence 235 2016 125 9 4 Related work Our formalization simple loop illustrates difference approach Hoares logic ar guably dominant approach reasoning nonparallel imperative programs To begin assertion like 2 represented triple like I 0P m0 m N X Am Hoares logic To prove assertion need ﬁnd suitable loop invariant formula true initially continue true iteration In general inﬁnite number loop invariants The key ﬁnd conjunction negation loop condition entail postcondition assertion For simple loop following loop invariant mI0 m I X Am Finding suitable loop invariants heart Hoares logic surprising work discovering loop invariants 711 In comparison proof 2 uses ordinary mathematical induction recurrences In Xn See Appendix B details Another difference approach Hoares logic Hoares logic set general rules program assertions provide translation programs ﬁrstorder theories quantiﬁcation natural numbers Once translation assertions proved respect translated ﬁrstorder theory ref erence original program This similar Pnuelis temporal logic approach program semantics 6 According common classiﬁcation formal methods community cf 1213 approaches like Hoares logic dynamic logic exogenous programs explicitly language temporal logic approach program semantics typically endogenous ﬁxed program assumed program execution counter speciﬁcation language Our approach certainly exogenous It little endogenous use natural numbers track loop iterations endogenous typical temporal logic speciﬁcations requires program counters states In particular mapping programs theories compositional built structure program Barringer et al 14 proposed compositional approach temporal logic style Hoares logic Hoare triples However caveat far temporal logic approach program semantics mainly concurrent programs proposed nonparallel programs Given close relationship temporal logics ﬁrstorder logic linear order nested loops translation reformulated temporal logic It hard nested loops lead nested time lines modeled predicates multiple natural number arguments Of course construct transition graph program model temporal logic But structure original program lost We certainly ﬁrst use ﬁrstorder logic linear order model dynamic systems For instance model Turing machines proof Trakhtenbrots theorem ﬁnite model theory 15 A closely related work Charguérauds characteristic formulas functional programs 1617 However formulas higherorder formulas reformulate Hoares rules quantifying preconditions postconditions Our use natural numbers indices model iterations similar Wallaces use natural numbers model rule applications semantics logic programs 18 While use natural numbers formalize loops Levesque et al 19 secondorder logic capture Golog programs loops situation calculus Recently Lin 20 showed foundational axioms situation calculus Golog programs deﬁned ﬁrstorder logic However crucial difference work work situation calculus Golog axioms try capture changes states terms values program variables semantics Golog programs deﬁning legal sequences executions To illustrate difference consider program consists assignments change nil actions For program nontrivial deﬁne sequences legal executions matter sequences legal change values program variables Another difference consider assignments deterministic programs Golog programs allow actions axiomatized successor state axioms nondeterministic choices 5 Cohens integer division algorithm For complex example consider following program P implements wellknown Cohens integer division algorithm 21 program adapted 11 It loops nested inside The program variables A B Q R X Y X Y inputs Q output Let cid7X A B Q R X Y There cid7X loops Lets inner loop Inner outer loop Outer When computing cid3 P consider equivalence cid7X use Proposition 6 simplify process 10 F Lin Artiﬁcial Intelligence 235 2016 125 X Y input integers Y 0 Q0 quotient RX remainder R Y A1 A B time BY n A2n B2nY R 2B A 2A B 2B R RB Q QA return Q XY It easy cid3 cid7X P equivalent cid3 cid7X Outer Q 0 R X To compute cid3 cid7X Outer compute ﬁrst cid3 cid7X Inner equivalent set following sentences An 1 2 An Bn 1 2Bn Q n 1 Q n Rn 1 Rn Xn 1 Xn Y n 1 Y n A0 A B0 B Q 0 Q R0 R X0 X Y 0 Y B A smallestN n Rn 2Bn cid2 AN cid2 BN cid2 Q N Q cid2 RN cid2 XN cid2 Y N X R Y Solving recurrences An 2n A Bn 2n B Q n Q Rn R Xn X Y n Y smallestN n R 2n1 B cid2 2N A A cid2 2N B B F Lin Artiﬁcial Intelligence 235 2016 125 11 R cid2 Q Q cid2 R cid2 X cid2 Y X Y We eliminate terms like An Bn expand smallest macro expression obtain cid3 following sentences cid7X Inner set R 2N1 B m N R 2m1 B B A cid2 2N A cid2 2N B cid2 Q Q cid2 R cid2 X cid2 Y X R Y Thus set sentences body loop Outer equivalent set following sentences R 2N1Y m N R 2m1Y cid2 B A cid2 2N cid2 2N Y cid2 Q A Q cid2 cid2 R B cid2 X cid2 Y X R Y cid7X Outer Thus cid3 Q 0 R X equivalent Rn 2Nn1Y n m Nn Rn 2m1Y n An 1 2Nn Bn 1 2NnY n Q n 1 Q n 2Nn Rn 1 Rn 2NnY n Xn 1 Xn Y n 1 Y n A0 A B0 B Q 0 0 R0 X X0 X Y 0 Y smallestM n Rn Y n cid2 AM A 12 F Lin Artiﬁcial Intelligence 235 2016 125 B cid2 BM cid2 Q M Q cid2 RM cid2 XM cid2 Y M X R Y Now rid Xn Y n change Xn X Y n Y rid A B irrelevant expand smallest macro expression obtain cid3 cid7X P set following sentences Rn 2Nn1Y m Nn Rn 2m1Y Q n 1 Q n 2Nn Rn 1 Rn 2NnY Q 0 0 R0 X RM Y m M Rm Y cid2 Q M Q cid2 RM R From axioms partial correctness Cohens algorithm proving following properties precondition X 0 Y 1 cid2 0 R X Q Y cid2 Y R cid2 For ﬁrst property R RM 1 2NM1Y By axiom m Nn Rn 2m1Y cid2 Y trivially follows condition Outer loop For R cid2 0 R cid2 RM let n M 1 m NM 1 1 RM 1 2NM111Y 2NM1Y Thus R cid2 0 For second property cid2 Y R cid2 Q Q MY RM Q M 1 2NM1Y RM 1 2NM1Y Q M 1Y RM 1 Q 0Y R0 X Again partial correctness To prove termination need new terms introduced smallest macro expressions welldeﬁned For program means M outer loop counter bounded n Nn inner loop counter outer loop iteration bounded By Proposition 1 proved showing following properties mRm Y nmRn 2m1Y Notice properties proved axioms M Nn Since Rn 1 inductively deﬁned terms Nn prove second property induction n showing Nn welldeﬁned Since R0 X Y 1 mR0 2m1Y easy let m X Thus N0 welldeﬁned Inductively suppose Nk deﬁned mRk 2m1Y Since Rk 1 Rk mRk 1 2m1Y Thus Nk 1 welldeﬁned Now ﬁrst property mRm Y observe Rm X mY mRm 0 Y F Lin Artiﬁcial Intelligence 235 2016 125 13 It obvious properties like proved general As mentioned logical consistency meant terms like Nn welldeﬁned Thus needs set axioms consistent assumption Y 0 X 0 Using Proposition 1 way showing axioms mention N consistent entail nϕn adding smallestN n ϕn axioms consistent Again remark relied mathematical induction proof use loop invariants Notice proof actually shows integer division program following form correct X Y input integers Y 0 Q0 quotient RX remainder R Y A1 BY R kB A kA B kB R RB Q QA return Q XY k 1 constant 6 Properties programs execution As mentioned proposed translation ﬁrst order logic tailored program behaviors terms input output conditions Sometimes interested properties program execution We temporary function symbols denote values program variables execution program So reason properties program execution need temporary functions explicit names One way label program statements use labels point reference Consider following class labeled programs E arrayEE operatorEE B E E booleanopBB P L arrayEE E L B P P L B P P P Here L label typically natural number Notice label sequence In general program P sequence statements L1 P 1 L2 P 2 Lk P k P assignment conditional loop We P k statement P output P output P k Again assume program variable names unique base language L Now given program P program variable V label L add functions V V L L Again V cid7x denotes value input cid7x indices corresponding array The value end statement L denoted V Lcid7x Of course V V L L label statement program cid2 Given program P set cid7X program variables including variables P use cid3 cid7X P denote set axioms P cid7X If P L VE1Ek E cid3 cid7X P consists following axioms 14 F Lin Artiﬁcial Intelligence 235 2016 125 V Lcid7x x1 E 1 xk Ek E V cid7x X Lcid7y Xcid7y X cid7X X different V If P L B P1 P2 cid3 cid3 cid7X P union cid3 cid7X P 1 B X Lcid7x X L1 cid7x B X Lcid7x X L2 cid7x cid7X P 2 set following axioms X cid7X L1 L2 labels statements P 1 P 2 respectively If P P1 P2 cid3 cid7X P union cid3 ϕ cid7X cid7 X L1 ϕ cid3 cid7X P 2 cid7X P 1 set following axioms L1 label statement P 1 If P L B P1 Then cid3 cid7X P constructed cid3 cid7X P 1 follows cid7X P 1 ϕn ϕ cid3 cid7x 0 Xicid7x Xi cid7X X L cid7x n 1 X L1 X L smallestN n Bn cid7x X L X L cid7x N Xi cid7X cid7x n L1 label statement loop body P 1 n new natural number variable formula term α αn deﬁned ϕ N new natural number constant cid3 similarly 1 xαn xαn α1 α2n α1n α2n αn αn 2 F e1 ekn F e1n ekn F predicate function base ﬁrstorder language L 3 Xe1 ekn X Le1n ekn n X cid7X 4 label t P 1 X te1 ekn X t e1n ekn n X cid7X cid7X P 1 As example consider simple loop Section 32 labels added 1 2 3 4 I N X AI X AI I I1 The axioms body loop ignore Ax N change X 4 X 2 I 4 I 2 1 X 2 X AI X 3 X I 2 X AI I 3 I X 3 AI I 3 I Thus axioms program F Lin Artiﬁcial Intelligence 235 2016 125 15 X 4n X 2n I 4n I 2n 1 X 2n X 1n AI 1n X 3n X 1n I 2n X 1n AI 1n I 3n I 1n X 3n AI 1n I 3n I 1n X 10 X I 10 I X 1n 1 X 4n I 1n 1 I 4n n M I 1n N I 1M N X 1 X 4M I 1 I 4M This set axioms looks complicated natural information One query values program variables point execution program For instance statement 2 change value I execution write nI 2n I 1n Notice I 1n denotes value I beginning nth iteration loop 7 Functions One ask general proposed approach Can programs complex structures like pointers functions classes concurrency We believe We extended pointers functions Classes present problem basically user deﬁned types We currently working extending handle Java like threads In section approach axiomatize programs user deﬁned functions We consider pointers section In practice program consists set functions To illustrate handle functions including recursive functions consider following class programs E arrayEE operatorEE functionEE B E E booleanopBB Body arrayEE E B P P P P B P return E F functionvariablevariable Body P F P P Thus program collection functions Presumably main function executed ﬁrst program run In programming languages functions communicate sharing global variables To simplify things assume global variables program variables body function occur parameter list function If P F 1 Fk set axioms P union sets axioms F 1 k renaming program variables needed avoid conﬂict names Given function deﬁnition f cid7XBody ﬁrst capture return value function input cid7X special keyword Result Then function deﬁned universally quantifying cid7X More precisely set sentences f written cid3 f consists following ones cid7xϕ cid7Xcid7xResult cid2 f cid7x ϕ cid3 cid7XResult Body 16 F Lin Artiﬁcial Intelligence 235 2016 125 cid2 ϕ cid7Xcid7xResult f cid7x result replacing ϕ Xi cid7X xi X f cid7x We assume Result reserved word denote value function Notice replace cid2 Xi variable xi X value Xi function exits longer relevant Here replace dummy new function g new function gcid7x Result cid2 cid2 cid3 cid7XResult Body deﬁned Body return E axioms cid2 E Result cid2 icid7x Xicid7x Xi program variable X Notice according axiomatization body function execute return statement multiple times time matters For example given foo return 1 return 2 cid2 second return statement meaningful Result ﬁrst return statement replaced temporary variable constructing axioms sequence discarded So function captured axiom foo 2 One argue sense instance return statement executed programmers responsibility sure happen Alternatively assume soon return statement executed function exits This modeled introducing special ﬂag Exit replace return statement Exit return E Exit true For meaningful example consider following mutually deﬁned functions isEven isOdd isEvenN N0 return true return isOddN1 isOddN N0 return false return isEvenN1 Suppose denote body isEvenN Body1 isOddN Body2 Then cid3NResult following axioms Body1 consists cid2 N N Result cid2 N 0 true isOddN 1 similarly cid3NResult cid2 N Body2 N cid2 N 0 false isEvenN 1 Result Thus cid3isOdd cid3isEven f x x isEvenx x 0 true isOddx 1 gx x isOddx x 0 false isEvenx 1 f g new functions denote values x functions isEvenx isOddx respectively return They irrelevant corresponding axioms deleted By induction n easy prove following hold n 0 isEven2n true isOdd2n false isEven2n 1 false isOdd2n 1 true Now consider following program type deﬁnition F Lin Artiﬁcial Intelligence 235 2016 125 17 List aList lengthXList X return 0 return lengthtailX1 tailXList X return XaX1 return X1 appendXList YList X return Y XaX1 return aappendX1Y aList list concatenation new list obtained adding List ﬁrst element To model data type List introduce corresponding List sort ﬁrstorder language write x List mean x sort List In ﬁrstorder terms deﬁnition List yields following axioms x Listx y Listx y bx y Lista x b y b x y ax List cid14 x functions yield following axioms x Listlengthx x 0 lengthtailx 1 x Listtailx x y Listx y y x y Listappendx y x y ax1 Listx x1 appendx1 y With axioms prove example lengtha b 2 However suﬃcient proving general properties like following simple x y Listlengthappendx y lengthx length y To prove properties like need induction lists This secondorder axiom sort List similar natural numbers However natural numbers necessary We introduce lists n elements deﬁne list list n elements n This way use mathematical induction natural numbers prove inductive properties lists We We introduce binary predicate Listx n meaning x list exactly n elements x ListnListx n Listx 0 x Listx n 1 y Listx y List y n We ﬁrst x list unique n Listx n holds Listx n Listx m m n 3 Suppose x list Listx m Listx n true We simultaneous induction n m If n 0 x If m cid14 0 k m k 1 x y list y contradiction axioms lists Thus m 0 Similarly m 0 n 0 Suppose n k1 1 m k2 1 suppose inductively j maxm n List y List y j j list y We x y1 z1 list z1 Listz1 k1 holds x y2 z2 list z2 Listz2 k2 holds From y1 z1 y2 z2 z1 z2 inductive assumption k1 k2 So m n This concludes inductive step proof 3 18 F Lin Artiﬁcial Intelligence 235 2016 125 Using 3 prove induction schema lists formula ϕx ϕ ax Listϕx ϕa x x Listϕx Suppose premise true list x ϕx By 3 unique n Listx n Suppose x shortest list list y List y m m n ϕ y holds If n 0 x satisﬁes ϕ contradiction Suppose n m 1 y x y List y m By assumption x ϕ y holds By premise ϕa y holds contradiction The idea axiomatize ﬁrstorder logic inductively deﬁned data structures trees For recursive functions challenge distinguish cycles undeﬁned values Consider following exam ple fooX X0 return fooX x1 return 1 With axiomatization set axioms foox equivalent single fact foo1 1 It leaves completely open possible values foox x cid14 1 One argue right formalization But operationally difference function calls foo0 foo2 calling foo0 cause cycle calling foo2 terminate value returned The causes stack overﬂow abnormal exit In following provide axiomatization functions differentiate cases The key idea counter number times recursive function called Let f 1 f 2 fk functions mutually deﬁned recursively f X1 XmB Extend functions argument f iX1 Xm M M 0 B i0 B i1 B i0 result replacing function f jT 1 Tm B Cycle B i1 result replacing function f jT 1 Tm B f jT 1 Tm M 1 M natural number Cycle new constant The set cid3 f axioms f f icid7x y nm n f icid7x m y This axiomatization similar iterated version ﬁxedpoint semantics recursive functions B i0 base case B i1 inductive case Consider function foo deﬁned We fooXM M0 X0 return Cycle X1 return 1 X0 return fooXM1 X1 return 1 following axioms foo X foo X M foox y mn mfoox n y foo0 0 Cycle foo1 0 1 foo0 n 1 foo0 n foo1 n 1 1 Thus nfoo0 n Cycle nfoo1 n 1 So foo0 Cycle foo1 1 The axioms leave open possible values foox x equal 0 1 8 Pointers To illustrate approach handle pointers reference variables consider language simple pointer operations similar C In particular program variable X use X refer address memory location assigned X pointer variable L use L refer value location pointed L Thus variable X X X return value evaluated expression F Lin Artiﬁcial Intelligence 235 2016 125 19 E IE PE B IE id operatorEE PE PE pointer id pointeropEE B E E booleanopEE P id IE pointer PE PE E B P P P P B P Here id integer program variable pointer pointer program variable For simplicity consider arrays operator function returns integer value pointerop pointer value booleanop truth value Our axiomatization class programs model directly compiler works We assume set storage locations hold value integer location storage cell A program variable assigned location compiler beginning changed execution program The value program variable value stored location Thus assume location sort language In axiomatization represent program variable V function language The value function denotes value program variable program Here going conceptual shift going represent program variable function location sort value function denotes location assigned program variable compiler So program variable V corresponding function V ﬁrstorder language dynamic value changes execution program V static location assigned program variable compiler change What changing program execution values stored memory locations modeled dynamic function val val location int location Thus V integer variable valV integer If V pointer valV location To summarize given program program variable V instead V V denote values input output program respectively use V denote memory location valV val V denote values respectively We need similar translation expression E program term valE similarly val E ﬁrstorder language cid2 cid2 cid2 1 valid id id integer program variable 2 valPE valvalPE PE pointer expression 3 val f E 1 Ek f valE 1 valEk f operator pointerop booleanop assuming corresponding function f language Given program P axioms denoted cid3P terms val val cid2 If P V E V integer pointer program variable E integer pointer expression following axiom cid2 val x x V valE valx x ranges locations If P PE E PE pointer expression axioms follows cid2 val x x valPE valE valx 20 F Lin Artiﬁcial Intelligence 235 2016 125 If P P1P2 cid3P constructed cid3P 1 cid3P 2 follows cid2 tmp ϕ cid3P 1 ϕval ϕvaltmp ϕ cid3P 2 tmp new function arity val val The cases conditionals loops similar cid2 cid3P 1 cid3P 2 Consider program L V L 1 V integer variable L pointer Given valV V following axioms tmpx x L V valx cid2 val x x tmpL 1 tmpx Assuming L cid14 V assigned different locations compiler val cid2 cid2 V 1 val L V x cid14 V x cid14 L val cid2 x valx Now consider following program X Y Max nextAX Max nextAX X X1 A pointer variable nextAX pointer pointing X th location pointed A In C notation nextAX AX addition pointer arithmetic We use order distinguish normal addition operator arithmetic We assume following unique names axioms locations nX cid14 Y cid14 Max cid14 A n Again compute axioms body loop ﬁrst simpliﬁed following axioms unique names axioms cid2 X valX 1 val valMax valvalnext A X cid2 val Max valvalnext A X x cid14 X x cid14 Max valMax valvalnext A X cid2 val x valx Thus axioms program valx 0 valx valX n 1 valX n 1 valMax n valvalnext A X n n valMax n 1 valvalnext A X n n x cid14 X x cid14 Max valMax valvalnext A X n n valx n 1 valx n n M valX n valY n valX M valY M x valx M val cid2 F Lin Artiﬁcial Intelligence 235 2016 125 21 From axioms deduce valX n valX 0 n valY n valY 0 Thus assume val X 0 0 valY 0 N natural number N M N valx 0 valx valMax n valvalnext A X n n valMax n 1 valvalnext A X n n x cid14 X x cid14 Max valMax valvalnext A X n n valx n 1 valx n x valx N cid2 val Compared formalization Section 3 looks compact quantiﬁes program variables locations This representation low level For instance axioms function needed infer interesting program For details 22 9 Concluding remarks Our goal construct translator programming language like C Java ﬁrstorder logic Once reasoning programs logic techniques including limited induction loop invariants In paper possible core procedural programming language loops functions simple pointers We extended complex mutable data structures including lists trees working extending threadbased concurrency The complexity translated ﬁrstorder theory given program depends program If program variables propositional resulting ﬁrstorder theory decidable proving partial total correctness program respect given propositional speciﬁcation If program natural numbers involves addition multiplication need arithmetic reason If program predicting trajectory planet theory physics needed order prove interesting How integrate logical reasoning domain theory long challenge AI science Acknowledgements I thank Yin Chen ShingChi Cheung Yongmei Liu Pritom Prajkhowa Yidong Shen Bo Yang Charles Zhang Mingyi Zhang Yan Zhang Yi Zhou useful discussions related subject paper I thank anonymous reviewers KR2014 journal sharing insights topic paper valuable comments earlier versions paper This work supported HK RGC GRF 616013 Appendix A Correctness operational semantics In appendix provide operational semantics language Section 3 correctness axiomatization respect semantics Given program deﬁne models sequences states executions We represent states ﬁrstorder structures As assume base language contains functions predicates corresponding buildin functions operators Given program P tuple cid7X functions includes program variables P extend base language new language L cid7X adding functions cid7X Notice means V program variable P nary array assume V cid7X nary function Again assume program variable names unique overloading names For class programs consider executing program state terminate yields ﬁnite sequence assignments This deﬁned standard way Now ﬁnite sequence M1 Mn L cid7X structures model P executed M1 P terminates sequence assignments α1 αn1 1 n Mi1 result executing αi result executing assignment Mi given structure M M V t1 tk e M M M domains interpretation predicates interpretation functions V V value M deﬁned follows cid2 cid2 cid2 cid2 cid2 V M u1 uk eM V M u1 uk u1 uk t M 1 t M k 22 F Lin Artiﬁcial Intelligence 235 2016 125 Now consider translation cid3 cid7X P It uses language extension L cid7X In particular variable V cid7X P project L cid7X usual Furthermore new primed function V cid7X structure I L cid7X primedprojection M symbol τ L cid7X τ primed version cid3 P interpretation I M τ primed version interpretation I according τ cid2 M We Given model M cid3 cid2 Proposition 7 If M model cid3 cid7X P model M1 Mk P M1 projection M L cid7X Mk primedprojection M L cid7X A1 A2 Conversely M1 Mk model P model M cid3 cid7X P A1 A2 hold Proof We prove ﬁrst half proposition The second half similar easier We prove induction P The base case P assignment VE1Ek E Recall cid3 cid7X P consists following axioms cid7x x1 E 1 xk Ek E cid2 V V cid7x cid2 cid7y Xcid7y X cid7X X different V X It easy M model cid3 model P cid7X P M1 M2 projection primed projection M L cid7X respectively Inductively suppose result holds subprograms P There cases conditional statements sequences loops Suppose P B P1 P2 sequence M1 Mk states model P iff B true M1 M1 Mk model P 1 B false M1 M1 Mk model P 2 Recall cid3 cid7X P constructed cid3 cid7X P 1 cid3 follows cid7X P 2 B ϕ ϕ cid3 cid7X P 1 cid7X B ϕ ϕ cid3 P 2 cid7X P satisﬁes B iff projection M L cid7X M cid7X satisﬁes B Thus M model cid3 cid7X P iff Observe model M cid3 By inductive assumption B true M cid7X M model cid3 cid7X P Then B true M cid7X Mi M cid7X M1 Mk M cid7X cid2 model P 1 suppose M model cid3 B false M cid7X Mi M cid7X M1 Mk M cid7X cid2 model P 2 M cid7X cid2 primed projection M L cid7X In case Mi M cid7X M1 Mk M cid7X cid2 model P B false M cid7X M model cid3 cid7X P 2 cid7X P 1 Suppose P P1 P2 sequence states M1 Mk model P iff 1 k M1 Mi model P 1 Mi Mk model P 2 cid7X P constructed cid3 Recall cid3 connecting outputs P 1 inputs P 2 follows cid3 cid7X P 2 cid7X P 1 cid7X ϕ cid7X cid2 cid7Y ϕ cid3 P 1 cid7X ϕ cid7X cid7Y ϕ cid3 P 2 cid7Y Y 1 Yk tuple new function symbols Y arity Xi cid7X Now suppose cid2 M model cid3 interpretation M1 interpretation Y M M2 M Xi cid7X P Construct models M1 M2 M follows M1 M X F Lin Artiﬁcial Intelligence 235 2016 125 23 interpretation M2 interpretation Y M Then M model cid3 cid7Y tuple new functions cid3 P 1 2 M 1 Thus M1 M1 1 M1 k1 k1 temporary variables This assumption needed needed second half proposition projection primed projection M respectively By construction share 1 2 By inductive assumption model M model P Notice assume cid3 1 2 Notice 1 M ko 2 M2 M2 k2 1 M ki cid3 M2 cid7X P 2 cid7X P 1 cid7X P cid7X P Our case loops Suppose P B P1 Then M1 Mk model P iff Q 0 1 k0 k1 k Q k model P 1 0 Q Mki Mki1 Mki Mk Q B 0 Q B Recall cid3 cid7X P consists following axioms cid7X P 1 ϕn ϕ cid3 Xicid7x Xicid7x 0 Xi cid7X smallestN n Bn icid7x Xicid7x N Xi cid7X X cid2 n new natural number variable ϕ N new natural number constant cid3 cid7X P 1 Notice symbol LP 1 base language Let LP language cid3 cid7X P LP 1 language cid3 cid7X P 1 LP extended natural number argument described construction ϕn Suppose M model cid3 cid7X P Let Q value N M notice N constant language Q natural number domain For 0 Q M Bi M BQ For natural number let M constructed M follows M M symbol X cid3 extended natural number parameter interpretation X M interpretation Xi M interpretation X M interpretation Xi 1 M Notice M structure language LP M structure LP 1 It seen M model cid3 states model P 1 M M ki 1 M ki projection primed projection M L cid7X Observe model P cid2 By inductive assumption sequence M hard sequence M0 cid7X P 1 1 M ki M Q 1 k Q 1 M Q 1 1 M0 k0 2 M1 k1 M i1 M1 cid7X P 1 2 1 cid2 Appendix B Loop invariants Our approach translates programs ﬁrstorder theories Once translation properties programs proved methods valid ﬁrstorder logic In particular programs loops use loop invariants Consider loop form C P A condition ϕ loop invariant ϕ C true initially ϕ continue hold P performed In notation means theory corresponding program entails following sentence nCn ϕn ϕn 1 Now postcondition Q proved invariant ϕ C ϕ Q prove theory Q cid2 holds Q cid2 Q N N satisﬁes smallestN n Cn Consider simple example following loop computing factorials F1 I0 IX II1 F IF 24 F Lin Artiﬁcial Intelligence 235 2016 125 Given nonnegative integer input X output value F factorial X F cid2 fact X To prove correctness program ﬁrst need assume deﬁnition factorial deﬁned induc tively fact0 1 nfactn 1 n factn One following loop invariant I X F factI Given condition true loop initiates loop terminates I X I X F factI implies I X F fact X B1 We implemented translator1 programs Section 3 The direct translation program simpli ﬁcation gives following axioms F 1 1 I1 I X1 X I2 0 F 2 F 1 X2 X1 F 0 F 2 I0 I2 X0 X2 n N1 In Xn IN1 XN1 I4n In 1 F 4n F n X4n Xn F n 1 I4n F 4n In 1 I4n Xn 1 X4n cid2 F N1 F cid2 IN1 cid2 XN1 X I From set equations easy verify loop invariant In Xn In Xn F n factIn In 1 Xn 1 F n 1 factIn 1 Thus n N1 In 1 Xn 1 F n 1 factIn 1 Instantiate n N1 1 equation IN1 XN1 Thus IN1 XN1 So F fact XN1 fact X cid2 cid2 F N1 factIN1 Our translator simpliﬁes translated theory possible getting rid temporary variables making use Mathematica2 solve recurrences possible For factorial program generates following set cid3 formulas 1 This implemented Pritom Prajkhowa available request 2 http wwwwolfram com mathematica F Lin Artiﬁcial Intelligence 235 2016 125 25 F 0 1 n N1 In Xn IN1 XN1 F n 1 n 1 F n cid2 N1 cid2 F N1 cid2 X X F I Notice In eliminated recurrences I0 0 In 1 In 1 Mathematica computes closed form solution In n Thus loop invariant B1 anymore Looking formulas cid3 clear F n factn veriﬁed Mathematica Thus F cid2 fact X comes proving N1 X proves program terminates By deﬁnition smallest macro prove N1 X need prove following assertions n X 1 n X X X obvious easily veriﬁed Mathematica References 1 E Dijkstra A Discipline Programming Prentice Hall Englewood Cliffs NJ 1976 2 EW Dijkstra CS Scholten Predicate Calculus Program Semantics SpringerVerlag New York 1990 3 C Hoare An axiomatic basis programming Commun ACM 1969 576580 4 D Harel FirstOrder Dynamic Logic Lecture Notes Computer Science vol 68 SpringerVerlag New York 1979 5 JC Reynolds Separation logic logic shared mutable data structures Proceedings 17th Annual IEEE Symposium Logic Computer Science IEEE 2002 pp 5574 6 A Pnueli The temporal semantics concurrent programs Theor Comput Sci 13 1981 4560 7 B Wegbreit The synthesis loop predicates Commun ACM 17 2 1974 102113 8 N Bjørner A Browne Z Manna Automatic generation invariants intermediate assertions Theor Comput Sci 173 1 1997 4987 httpdx 9 MD Ernst J Cockrell WG Griswold D Notkin Dynamically discovering likely program invariants support program evolution IEEE Trans Softw 10 MD Ernst JH Perkins PJ Guo S McCamant C Pacheco MS Tschantz C Xiao The daikon dynamic detection likely invariants Sci 11 T Nguyen D Kapur W Weimer S Forrest Using dynamic analysis discover polynomial array invariants Proceedings 34th International Conference Software Engineering ICSE 2012 IEEE 2012 pp 683693 12 D Kozen J Tiuryn Logics programs Handbook Theoretical Computer Science Volume B Formal Models Semantics B Elsevier 1990 pp 789840 13 EA Emerson Temporal modal logic Handbook Theoretical Computer Science Volume B Formal Models Semantics B Elsevier 1990 pp 9951072 14 H Barringer R Kuiper A Pnueli Now compose temporal logic speciﬁcations STOC 1984 pp 5163 15 L Libkin Elements Finite Model Theory Springer 2004 16 A Charguéraud Program veriﬁcation characteristic formulae ACM SIGPLAN Not 45 9 2010 321332 17 A Charguéraud Characteristic formulae veriﬁcation imperative programs ACM SIGPLAN Not 46 9 2011 418430 18 MG Wallace Tight consistent computable completions unrestricted logic programs J Log Program 15 1993 243273 19 H Levesque R Reiter Y Lespérance F Lin R Scherl GOLOG logic programming language dynamic domains J Logic Program 31 1997 5984 special issue Reasoning Action Change 20 F Lin A ﬁrstorder semantics Golog ConGolog secondorder induction axiom situations Proceedings KR 2014 2014 21 E Cohen Programming 1990s An Introduction Calculation Programs SpringerVerlag 1990 22 F Lin B Yang Reasoning mutable data structures ﬁrstorder logic arithmetic lists binary trees Technical report Department Computer Science Hong Kong University Science Technology httpwwwcsusthkfacultyﬂinpapersdsw2015pdf doiorg101016S0304397596001910 Eng 27 2 2001 99123 Comput Program 69 1 2007 3545