Artiﬁcial Intelligence 170 2006 779801 wwwelseviercomlocateartint Automated reformulation speciﬁcations safe delay constraints Marco Cadoli Toni Mancini Dipartimento di Informatica e Sistemistica Università di Roma La Sapienza Via Salaria 113 I00198 Roma Italy Received 14 September 2004 received revised form 25 January 2006 accepted 25 January 2006 Abstract In paper propose form reasoning speciﬁcations combinatorial problems goal reformulating efﬁciently solvable The reformulation technique highlights constraints safely delayed solved Our main contribution characterization soundness proof safedelay constraints respect criterion speciﬁcation obtaining mechanism automated reformulation speciﬁcations applicable great variety problems graph coloring binpacking jobshop scheduling This advancement respect forms reasoning stateoftheartsystems typically detect linearity speciﬁcations Another contribution experimentation effectiveness proposed technique different solvers reveals promising time savings 2006 Elsevier BV All rights reserved Keywords Modelling Reformulation Secondorder logic Propositional satisﬁability Constraint satisfaction problems 1 Introduction Current stateoftheart languages systems constraint modelling programming AMPL 22 OPL 48 XPRESSMP1 GAMS 9 DLV 31 SMODELS 39 ESRA 21 PS 18 NPSPEC 8 exhibit strong separation problem speciﬁcation Graph 3coloring instance graph usually adopting twolevel architecture ﬁnding solutions speciﬁcation ﬁrstly instantiated grounded instance appropriate solver invoked cf Fig 1 Such separation leads advantages obviously declar ativeness increases solver completely decoupled speciﬁcation Ideally programmer focus combinatorial aspects problem speciﬁcation committing priori speciﬁc solver In This paper extended revised version M Cadoli T Mancini Automated reformulation speciﬁcations safe delay constraints Proceedings Ninth International Conference Principles Knowledge Representation Reasoning KR 2004 Whistler BC Canada AAAI PressThe MIT Press 2004 pp 388398 Corresponding author Email addresses cadolidisuniroma1it M Cadoli tmancinidisuniroma1it T Mancini 1 Cf httpwwwdashoptimizationcom 00043702 matter 2006 Elsevier BV All rights reserved doi101016jartint200601008 780 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 Fig 1 Twolevel architecture current problem solving systems fact systems AMPL able translateat request usera speciﬁcation formats suitable different solvers CPLEX MINOS2 LANCELOT3 Nonetheless existing techniques proposed literature optimizing solution constraint satisfac tion problems apply commitment instance notable examples symmetry detection breaking cf 41637 development techniques imposing local consistency notions heuristics search cf 17 development algorithms deal dependent variables added SAT instances clausiﬁcation nonCNF formulae 27 socalled equivalence clauses 32 However cases properties amenable optimized derive problem structure particular instance considered Optimization techniques act problem structure proposed They include addition implied constraints cf 47 deletion abstraction constraints cf 28 use redundant models multiple viewpoints synchronized channelling constraints order increase constraint propagation 122029 Our research follows approach aim systematize process ﬁnding useful reformulations performing symbolic reasoning speciﬁcation In general properties symbolic reasoning natural effective making structural aspects emerge instantiation structure problem hidden An example performs sort reasoning speciﬁcation OPL able automatically choose appropriate solver problem However kind reasoning offered primitive OPL checks syntactically speciﬁcation linear case invoking lineartypically efﬁcientsolver general constraint programming Conversely research aims following longterm goal automated reformulation declarative straint problem speciﬁcation form efﬁciently evaluable solver hand The ultimate goal handle properties suitable optimization derive problem structure speciﬁcation level leaving subsequent instance level handling remaining ones truly depend instance In fact worthwhile note focusing speciﬁcation rule possibility additionally applying existing optimization techniques instance level The approach follow similar sense database research community attacking query optimization problem relational databases A query planner task reformulate query posed user order improve efﬁciency evaluation takes account query database schema current content instance cf 1 In general reformulating constraint problem speciﬁcation difﬁcult task speciﬁcation essentially formula secondorder logic known equivalence problem undecidable ﬁrstorder case 3 For reason research focus controlled restricted forms reformulation Moreover effectiveness particular reformulation technique expected depend problem solver possible principle ﬁnd reformulations good solvers solvers certain class linear SATbased ones To end related work cf Section 6 present different reformulation strategies proposed order speedup process solving constraint problem 2 Cf httpwwwsbsisoloptimizecom 3 Cf httpwwwcseclrcacuknaglancelotlancelotshtml M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 781 Fig 2 Delaying disjointness constraint 3coloring 1st stage covering good coloring b 2nd stage disjointness b In paper propose technique allows select constraints problem speciﬁcation ignored ﬁrst step regardless instance efﬁciently reinforced solution simpliﬁed problem We constraints safedelay Moreover experimentally reformulating problem speciﬁcations safedelay improves performances different solvers On hand gives evidence problem reformulation effective cases conﬁrms intuition single reformulation technique positive effects classes solvers negative ones portfolio different complementary reformulation strategies considered general cf Section 6 related work The NPcomplete graph kcoloring problem offers simple example safedelay constraint The problem amounts ﬁnd assignment nodes k colors Each node color covering Each node color disjointness Adjacent nodes different colors good coloring For instance problem obtain solution neglecting disjointness constraint choose node colors arbitrary way later stage cf Fig 2 It interesting note deletion disjointness constraints graph kcoloring proposed adhoc technique 46 cf 42 implemented standard DIMACS formulation SAT kcoloring Of course constraints safedelay example covering good coloring constraints Intuitively identifying set constraints speciﬁcation safedelay lead advantages The instantiation phase cf Fig 1 typically faster safedelay constraints taken account As example lets assume want use instantiation SAT solver solution kcoloring graph n nodes e edges The SAT instance encoding kcoloring instancein obvious way cf 25has n k propositional variables number clauses n n k k 12 e k covering disjointness good coloring respectively If delay disjointness n k k 12 clauses need generated Solving simpliﬁed problem disjointness easier original formulation classes solvers removing constraints makes set solutions larger For instance holds solutions original problem solutions simpliﬁed problem In experiments different solvers including SAT integer linear programming constraint pro gramming ones obtained fairly consistent cases order magnitude speedups hard instances problems graph coloring jobshop scheduling On implicitly obtain good solutions Results experimentation given Section 5 Ad hoc efﬁcient methods solving delayed constraints exist As example kcoloring problem choosing color nodes color On The architecture propose illustrated Fig 3 applied separates instance speciﬁcation It sense similar wellknown divide conquer technique cf 14 782 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 Fig 3 Reformulation architecture dividing instance divide constraints In general ﬁrst stage computationally expensive second proposal doable polynomial time The goal paper understand cases constraint safedelay Our main contribution characterization safedelay constraints respect semantic criterion speciﬁcation This allows obtain mechanism automated reformulation speciﬁcation applied great variety problems including socalled functional ones search space total function ﬁnite domain ﬁnite codomain The outline paper follows recalling preliminaries Section 2 present reformulation technique Section 3 discussion adopted methodology Section 4 Afterwards experimentation effectiveness approach described Section 5 benchmark randomly generated instances SAT stateoftheart linear constraint programming solvers Finally conclusions future related work presented Section 6 2 Preliminaries The style speciﬁcation combinatorial problem varies lot different languages constraint programming In paper considering procedural encodings obtained libraries C PROLOG focus highly declarative languages Again syntax varies lot languages AMPL OPL XPRESSMP GAMS allow representation constraints algebraic expressions DLV SMODELS NPSPEC rulebased languages Anyway abstract point view languages extensions existential secondorder logic ESO ﬁnite databases existential secondorder quantiﬁers ﬁrstorder formula represent respectively guess check phases constraint modelling paradigm In particular languages possible embed ESO queries way possible long ﬁnite domains considered To end paper use ESO speciﬁcation problems mainly simplicity allows represent search problems complexity class NP 1940 In particular remainder section ESO considered formal basis virtually available languages constraint modelling Intuitively relationship ESO real modelling languages similar holding Turing machines assembler highlevel programming languages We claim studying simpliﬁed scenario mandatory starting point complex investigations results serve basis reformulating speciﬁcations written higherlevel languages In Section 4 discuss choice showing reformulation technique easily lifted order deal problem speciﬁcations written richer languages AMPL Coherently stateoftheart systems represent instance problem means relational data base All constants appearing database uninterpreted dont speciﬁc meaning M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 783 An ESO speciﬁcation describing search problem π formula cid5S φ cid5S cid5R ψπ 1 cid5R R1 Rk input relational schema ﬁxed set relations given arities denoting schema input instances π φ closed ﬁrstorder formula relational vocabulary cid5S cid5R interpreted identity function symbols An instance I problem given relational database schema cid5R extension relations cid5R Predicates given arities set cid5S S1 Sn called guessed possible extensions tuples domain given constants occurring I plus occurring φ called Herbrand universe encode points search space problem π instance I Formula ψπ correctly encodes problem π input instance I bijective mapping exists solu tions πI extensions predicates cid5S verify φ cid5S I More formally following hold For instance I Σ solution πI Σ I φ It worthwhile note speciﬁcation instantiated input database constraint satisfaction problem sense 17 obtained Example 1 Graph 3Coloring 26 Prob GT4 In NPcomplete decision problem input graph question possible nodes colors red green blue way adjacent nodes including selfloops colored way The question easily speciﬁed ESO formula ψ binary relation edge RGB X RX GX BX X RX GX X RX BX X BX GX XY X cid13 Y RX RY edgeX Y XY X cid13 Y GX GY edgeX Y XY X cid13 Y BX BY edgeX Y 2 3 4 5 6 7 8 clauses 2 35 68 represent covering disjointness good coloring constraints respectively Referring graph Fig 2 Herbrand universe set b c d e input database relation edge ﬁve tuples edge In follows set tuples Herbrand universe taken guessed predicates called extension denoted ext By referring previous example formula ψ satisﬁed extR d extG e extB b c cf Fig 2b The symbol ext ﬁrstorder formula free variable An interpretation denoted aggregate extensions Finally observe paper consider basic ESO Nonetheless known cf 35 syntactic sugar added ESO order handle types functions bounded integers arithmetics altering expressing power In Section 33 examples enriched language 3 Reformulation In section sufﬁcient conditions constraints speciﬁcation safedelay We refer architecture Fig 3 general assumptions Assumption 1 As shown Fig 2 output ﬁrst stage computation mayimplicitlycontain solutions As example node c assigned green blue node e red green In second stage want compute arbitrarily select In words focus search problems objective function optimized 784 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 b c Fig 4 A solution ﬁrst second b stage graph 3coloring instance c An alternative view showing extension R shrinks moving ﬁrst dashed area second stage Assumption 2 The second stage computation shrink extension guessed predicate Fig 4 represents solution ﬁrst second b stage graph 3coloring instance Fig 2 Fig 4c gives evidence extension predicate R shrinks moving ﬁrst extR second stage extR extB extG unchanged This assumption coherent way algorithms constraint satisfaction operate variable associated ﬁnite domain values progressively eliminated satisfying assignment Nonetheless Section 34 examples problem speciﬁcations amenable safedelay second stage different nature Identiﬁcation safedelay constraints requires reasoning speciﬁcation taking account relations guessed database predicates For sake simplicity Section 31 initially focus attention single monadic guessed predicate trying ﬁgure constraints concerning delayed Afterwards Section 32 extend results sets monadic guessed predicates Section 33 binary predicates 31 Single monadic predicate We refer 3coloring speciﬁcation Example 1 focusing guessed predicates R trying ﬁnd intuitive explanation fact clauses 34 delayed We immediately note clauses speciﬁcation partitioned subsets NOR NEGR POSR withrespectivelyno negative positive occurrences R Neither NOR NEGR clauses violated shrinking extension R Such constraints called safeforget R decide process satisfy ﬁrst stage safely ignored second Assumption 2 shrink extension R We note possibility obliged example clauses 34 evaluated ﬁrst stage Although general POSR clauses safeforgetbecause shrinking extension R violate clause 2 safeforget In fact equivalently rewrite clauses 2 34 respectively follows RX BX GX X BX GX RX X cid14 2 cid14 34 note clause 2cid14 sets lower bound extension R clauses 34cid14 set upper bound lower upper bound extBX GX If usein ﬁrst stageclauses 2 58 computing extR place extR thenin second stagewe safely deﬁne extR extR extBX GX constraint violated cf Fig 4 The theorem proofs delayed Appendix A shows chance antecedent 2cid14 semantically related consequence 34cid14 Theorem 1 Let ψ ESO formula form S1 Sh S Ξ X αX SX X SX βX S monadic guessed predicates Ξ conjunction clauses α β arbitrary formulae S occur X free variable following hypotheses hold M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 785 Fig 5 Extensions Hyp 2 Hyp 1 S occur occurs negatively Ξ Hyp 2 X αX βX Let ψ s S1 Sh S X αX S Ξ X S new monadic predicate symbol Ξ Ξ occurrences S replaced S let ψ d X SX S X βX For input instance I extension M predicates S1 Sh S M I ψ s holds cid2cid2 M extS extS I extS extension S deﬁned M ψ d ψ cid3 cid3 A comment relevance theorem order Referring Fig 3 ψ speciﬁcation I instance ψ s simpliﬁed speciﬁcation X SX βX delayed constraint belonging NEGS Solving ψ s I producesif instance satisﬁablea list extensions M output Evaluating ψ d M corresponds PostProcessing phase second stage The structure delayed constraint ψ d clearly reﬂects Assumption 2 extensions guessed predicates shrunk second stage Moreover stage amounts evaluation ﬁrstorder formula ﬁxed database logarithmic space cf 1 polynomial time In words Theorem 1 says satisﬁable instance I simpliﬁed speciﬁcation ψ s solution M ψ s translated ψ d solution original speciﬁcation ψ Ξ X αX SX safeforget X SX βX safedelay Referring speciﬁcation Example 1 distinguished guessed predicate R Ξ conjunction clauses 58 αX βX BX GX cf clauses 34cid14 Fig 4 represents possible extensions red predicate ﬁrst R second R stages instance Fig 2 Fig 5 left gives evidence Hyp 2 holds constraint X αX SX violated second stage We guaranteed twostage process preserves solution ψ following theorem Theorem 2 Let I ψ ψ s ψ d Theorem 1 For instance I ψ satisﬁable ψ s ψ d satisﬁable To substantiate reasonableness hypotheses Theorem 1 play devils advocate consider following example Example 2 Graph 3Coloring red selfloops Example 1 continued In problem variation Example 1 input graph 3Coloring question possible ﬁnd coloring graph additional constraint selfloops insist red nodes A speciﬁcation problem easily derived Example 1 adding following constraint X edgeX X RX 9 786 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 Fig 6 An instance graph 3coloring red selfloops problem solution ﬁrst stage obtained delaying disjointness constraints We immediately notice clauses 34 safedelay intuitively ﬁrst stage nodes red 2 9 34 set correct color node Now ifon 58Ξ contains constraint 9 Hyp 1 clearly satisﬁed Analogously 9 build αX αX edgeX X BX GX Hyp 2 satisﬁed Fig 5 right gives evidence constraint X αX SX violated extS computed ψ d extα subset extβ An instance graph 3coloring red selfloops problem given Fig 6 solution ﬁrst stage case Ξ contains constraint 9 It observed constraints 34 set correct color node e Summing constraint positive occurrence distinguished guessed predicate S safely forgot evaluated ﬁrst stage safedelay constraint justiﬁes Some comments Theorem 1 order As observed cf Appendix A theorem proof formally require Ξ conjunction clauses actually formula structure M M Ξ shrinking extS keeping ﬁxed obtain model Ξ As example Ξ contain conjunct X SX γ X γ X ﬁrstorder formula S occur Secondly Hyp 2 calls tautology checkwhich decidable generalwe follows speciﬁcations satisfy design 32 Set monadic predicates Theorem 1 states delay constraints speciﬁcation ψ focusing monadic guessed predicates obtaining new speciﬁcation ψ s set delayed constraints ψ d Of course theorem applied speciﬁcation ψ s focusing different guessed predicate order obtain new simpliﬁed speciﬁcation ψ ss new delayed constraints ψ sd Since Theorem 2 satisﬁability formulae preserved possible translate ψ sd solution ψ ss solution ψ s ψ d solution ψ The procedure REFORMULATE Fig 7 deals general case set guessed predicates input speciﬁcation ψ satisﬁable returns simpliﬁed speciﬁcation ψ s list delayed constraints ψ d Algorithm SOLVEBYDELAYING gets solution ψ s translates evaluation formulae list ψ d LIFO policyto solution ψ As example evaluating procedure REFORMULATE speciﬁcation Example 1 focusing guessed predicates order R G B obtain output following simpliﬁed speciﬁcation ψ s omits disjointness constraints clauses 35 R G B X R X G X BX Y edgeX Y X R XY X cid13 Y R Y edgeX Y X G XY X cid13 Y G XY X cid13 Y BX BY edgeX Y following list ψ d delayed constraints X RX R X GX BX X BX X GX G 10 11 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 787 Algorithm SOLVEBYDELAYING Input Output solution cid17D Φcid18 satisﬁable unsatisﬁable speciﬁcation Φ database D begin cid17Φs Φd cid18 REFORMULATEΦ cid17Φs Dcid18 satisﬁable begin let M solution cid17Φs Dcid18 Φd begin Constraint d Φd pop M M solution d cf Theorem 1 end return M end return unsatisﬁable end Procedure REFORMULATE Input speciﬁcation Φ Output pair cid17Φs Φd cid18 Φs simpliﬁed speciﬁcation Φd stack delayed constraints begin Stack Φd stack Φs Φ monadic guessed pred S Φs begin partition constraints Φs according Thm 1 cid17Ξ X αX SX X SX βXcid18 previous step possible X βX cid13 TRUE begin Φd pushX SX SX βX Φs Ξ X αX SX end end return cid17Φs Φd cid18 end Fig 7 Algorithm safedelay case set monadic predicates It worth noting check X βX tautology prevents useless delayed constraint X BX BX pushed ψ d From solution ψ s solution ψ obtained reconstructing ﬁrst extension G mula 11 extension R formula 10 synthesized respectively second ﬁrst iteration algorithm Since delayed constraint ﬁrstorder second stage doable logarithmic space polynomial time size instance We observe procedure REFORMULATE intrinsically nondeterministic partition applied constraints 33 Binary predicates In subsection reformulation technique extended order deal speciﬁcations binary general nary guessed predicates This formally unfolding nonmonadic guessed predicates monadic ones exploiting ﬁniteness Herbrand domain To illustrate point consider speciﬁcation kcoloring problem binary predicate Colthe ﬁrst argument node second color follows input schema case given 788 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 cid5R node color edge encoding set nodes colors graph edges respectively constraints force Col correctly typed satisfy conditions covering disjointness good coloring Col XY ColX Y nodeX colorY X Y nodeX ColX Y XY Z ColX Y ColX Z Y Z XY Z X cid13 Y ColX Z ColY Z edgeX Y Since number colors ﬁnite possible unfold constraints respect second argument Col As example k 3 replace binary predicate Col monadic guessed predicates Col1 Col2 Col3 value second argument color meaning tuple cid17n ccid18 belongs Col cid17ncid18 belongs Colc Constraints speciﬁcation unfolded accordingly The output unfolding process k 3up appropriate renaming Col1 Col2 Col3 R G Bis exactly speciﬁcation Example 1 The considerations imply use architecture Fig 3 large class speciﬁcations cluding called functional speciﬁcations search space total function ﬁnite domain ﬁnite codomain A safedelay functional speciﬁcation ESO formula form P Ξ X Y P X Y XY Z P X Y P X Z Y Z Ξ conjunction clauses P occur occurs negatively In particular dis jointness constraints safedelay covering remaining ones Ξ safeforget Formally soundness architecture safedelay functional formulae guaranteed Theorem 1 Safedelay functional speciﬁcations common apart graph coloring notable examples Jobshop scheduling Bin packing consider Example 3 Jobshop scheduling 26 Prob SS18 In Jobshop scheduling problem sets sorts J jobs K tasks P processors Jobs ordered collections tasks task integervalued length encoded binary relation L processor requested order perform binary relation Proc Each processor perform task time tasks belonging job performed order Finally global deadline D met jobs An ESO speciﬁcation problem follows For simplicity assume relation Aft contains pairs tasks cid17kcid14 kcid14cid14cid18 job kcid14 comes kcid14cid14 given order encodes transitive closure relation Time encodes time points deadline D contains exactly D tuples Moreover assume predicate cid2 function correctly deﬁned constants Time It worth noting assumptions add expressive power ESO formalism encoded ESO standard techniques S k t Sk t Kk T t cid14cid14 cid14cid14 cid14cid14 cid14 t t j Jobk cid14 cid14 j cid14cid14 cid14cid14 t Sk t Sk cid14 cid14 l cid14 k t Sk t cid14 cid14cid14 k t cid14 k Sk t cid14cid14 cid14 t cid14cid14 k j t l t k cid14cid14 Aftk cid14 cid13 k cid14 cid14 t Lk l cid14cid14 cid14 cid14cid14 cid14 k k Sk t cid14 cid14 Jobk cid14 cid14cid14 k cid14cid14 cid2 t cid14cid14 cid14 l l p Prock cid14cid14 Sk cid14cid14 t t cid14 cid2 t t cid14cid14 cid14 cid14 Prock cid14cid14 p t cid14 cid14 cid13 k p k cid14cid14 cid14cid14 cid14 cid3 t Lk cid4 t l cid14 cid2 t Sk cid14cid14 cid2 t cid14cid14 cid14cid14 l k t l T k Sk t Lk l Timet l t t cid14cid14 t cid14 cid14 l cid5 cid14cid14 Lk cid14 cid14 l 12 13 14 15 16 17 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 789 Constraints 1214 force solution contain tuple cid17k tcid18 t time point task k encode assignment exactly starting time task particular 14 assigns starting time task Moreover constraint 15 forces tasks belong job executed order overlapping 16 avoids processor perform task time point Finally 17 forces scheduling terminate deadline D It worth noting additional syntactic sugar added ESO order better deal scheduling problems As example constructs like commonly richer modelling languages problems cf OPL concerning scheduling available However enhancements scope paper taken account cid2 As example Fig 8a b respectively instance possible solution Jobshop scheduling problem The instance consists 3 jobs J1 J2 J3 respectively 4 3 5 tasks The order tasks belonging job performed given letter parentheses b c d e Tasks executed 3 processors P1 P2 P3 denoted different borderlines Hence processor needed perform given task given task borderline To reformulate Jobshop scheduling problem unfolding speciﬁcation way monadic guessed predicate St time point t focus time point t partition clauses speciﬁcation St occur occurs positively negatively order build Ξ αk βk The output phase follows αk βk cid6 cid6 tcid13t tcid13t St k obtained unfolding 13 St k obtained unfolding 14 α β clearly satisfy Hyp 2 Theorem 1 Moreover according algorithm Fig 7 iteratively focusing predicates St delay unfolded constraints It worth noting unfolding guessed predicates needed formally characterize reformulation respect Theorem 1 performed practice Intuitively constraint delay 14 forces task starting time delaying allow task multiple starting times task overlap task start times Again second stage arbitrarily choose We observe similar approach 15 optimized adhoc translation problem SAT propositional variables represent encoding earliest starting times latest ending times tasks exact scheduled times As example Fig 8c shows solution ﬁrst stage reformulated problem instance Fig 8a subsumes solution Fig 8b Example 4 Bin packing 26 Prob SR1 In Bin packing problem cf 36 asked pack set I items having given size set B bins having given capacity Under assumption input instances given extensions relations I S B C I encodes set items B set bins S size items tuple cid17i scid18 item C capacity bins tuple cid17b ccid18 bin b ESO speciﬁcation problem follows P b P b I Bb b I P b P b P b b b cid2cid7 b c Cb c sum cid14 cid14 b b cid14 s P b Si s cid3 c 18 19 20 21 cid8cid3 simplify notations assume bounded integers encode size items capacity bins existence function sum returns sum elements belong set given argument We remind bounded integers arithmetic operations add expressive power ESO In speciﬁcation solution total mapping P items bins Constraints force mapping respectively right relations 18 total 19 monovalued 20 satisfying capacity constraint bin 21 790 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 b c Fig 8 An instance Jobshop scheduling problem consisting 3 jobs respectively 4 3 5 tasks executed 3 processors b A possible solution problem instance c A solution ﬁrst stage reformulated problem subsumes b Shades indicate multiple good starting times tasks In particular unfolding guessed predicate P I monadic predicates Pi item coher ently speciﬁcation constraints delayed unfolding 20 force item packed exactly bin Thus iteratively applying Theorem 1 focusing unfolded guessed predicates intuitively allow item assigned bins In second stage arbitrarily choose bin obtain solution original problem Other problems reformulated safedelay exist Some examples Schurs Lemma wwwcspliborg Prob 15 Ramsey problem wwwcspliborg Prob 17 A short discussion reformulations addressed given 7 As showed previous examples worth noting arithmetic constraints interfere refor mulation technique As instance example cid3 predicate leads clauses remain satisﬁed extension selected guessed predicate shrunk keeping ﬁxed 34 Nonshrink second stages As speciﬁed beginning Section 3 paper focused second stages extension selected guessed predicate shrunk ones remain ﬁxed Actually speciﬁcations amenable reformulated safedelay different kind second stages As example speciﬁcation Golomb ruler problem Example 5 Golomb ruler wwwcspliborg Prob 6 In problem asked m marks M1 Mm different points ruler length l way M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 791 1 Mark left mark j j 2 The mm 12 distances pairs distinct marks different By assuming input instances given extensions unary relations M encoding set marks P encoding l points ruler function predicate correctly deﬁned tuples M P speciﬁcation problem follows cid14 cid14 G m Gm Mm P m Mm P m cid14 Gm Gm m cid14 m m cid14 m m cid14 cid14 Gm Gm j j n n cid14 cid14 Gm Gm cid14 n n m m cid14 cid13 j cid14 cid14 cid14 cid14 cid14 Gn j Gn j cid14 m n m n m cid14 n cid14 j cid14 m m cid14 cid14 cid14 22 23 24 25 26 A solution extension guessed predicate G mapping 2224 assigning point ruler mark order marks respected 25 distances different marks different 26 Here constraint delayed 25 forces ascending ordering marks By neglecting extend set solutions original problem permutations In second stage correct ordering marks enforced polynomial time By unfolding binary guessed predicate G obtain M monadic predicates Gm mark m Once solution simpliﬁed speciﬁcation computed focusing order reinforce mm 12 unfolded constraints derived 25 possibly exchange tuples pairs predicates Gm Gmcid14 m cid13 mcid14 shrink extensions single guessed predicates Hence Theorem 1 apply Furthermore modiﬁcation constraints needed ensure correctness reformulation In particular constraint 26 differences replaced absolute values As effectiveness reformulation objected constraints delayed actually break permutation symmetry removing likely good choice However likely true CP solvers like based backtracking obvious SAT ones In 7 delaying constraints signiﬁcantly drops instantiation time needed NPSPEC SAT compiler major variations solving times best SAT solver ZCHAFF Another class problems amenable reformulated safedelay important subclass mutation problems includes Hamiltonian path HP Permutation ﬂowshop Tiling Some preliminary results problems reformulated appear 34 As example HP reformulated looking small cliques graph viewing single nodes If ﬁnd HP reduced graph polynomial time obtain valid solution original problem cliques traversed order We currently investigating formal aspects generalization class solvers kind reformulations effective practice 4 Methodological discussion In section discussion methodology adopted work particular use ESO modelling language choice solvers experimentation As claimed Section 1 previous examples ESO specifying problems wipes aspects stateoftheart languages difﬁcult account numbers arithmetics constructs functions simplifying task ﬁnding criteria reformulating problem speciﬁcations However observed ESO somewhat limited far away mod elling languages provided commercial systems 792 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 A good example language AMPL 22 admits linear constraints case reformu lation technique described Theorem 1 straightforwardly applied instance speciﬁcation kcoloring problem language follows param n_nodes param n_colors integer 0 set NODES 1n_nodes set EDGES NODES cross NODES set COLORS 1n_colors Coloring nodes 2ary predicate var Coloring NODESCOLORS binary st CoveringAndDisjointness x NODES nodes exactly color sum c COLORS Coloringxc 1 st GoodColoring xy EDGES c COLORS nodes linked edge diff colors Coloringxc Coloringyc 1 The reformulated speciﬁcation obtained simply replacing CoveringAndDisjointness constraint following st Covering x NODES sum c COLORS Coloringxc 1 leading exactly reformulated speciﬁcation Example 1 As languages admit nonlinear constraints OPL possible write different speciﬁcation integer variables colors inequality colors adjacent nodes In case possible separate disjointness constraint ones implicit deﬁnition domains Of course study safedelay constraints relevant languages specify OPL problems Example 5 constraints want write linear speciﬁcation given problem order use linear solver efﬁcient cases cf Section 5 For concerns experimentation observed speciﬁcation written ESO naturally leads translation SAT instance For reason chosen use SAT solvers experimentation proposed technique Moreover considered impressive improving performances recently shown stateofthe art SAT solvers As claimed Section 1 effectiveness reformulation technique expected strongly depend particular solver To end solved set instances SAT solvers different nature cf Section 5 Finally wellknown stateoftheart linear constraint programming systems perform better SAT problems repeated experimentation commercial systems CPLEX linear SOLVER nonlinear invoked OPLSTUDIO4 5 Experimental results We experimentation reformulation technique 3coloring randomly generated instances k coloring benchmark instances DIMACS repository5 jobshop scheduling benchmark instances OR library6 SATbased solvers NPSPEC SAT compiler 8 instantiation stage constraint linear programming OPL 48 obviously pure modelling language omitting search procedures 4 Cf httpwwwilogcom 5 Cf ftpdimacsrutgersedupubchallenge 6 Cf httpwwwmsicacukinfohtml M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 793 Table 1 Experimental results 3coloring random instances 500 nodes 100 instances ﬁxed number edges Solving times seconds timeout 1 hour relative set 100 instances Und edges en ZCHAFF cid9 No delay cid9 Delay sav WALKSAT cid9 No delay cid9 Delay sav BGWALKSAT cid9 cid9 No delay Delay sav SATZ cid9 No delay cid9 Delay sav 500 600 700 800 900 1000 1100 1200 1300 1400 1500 026 20 013 24 022 28 02 32 018 36 016 40 44 1125 48 8053781 149769 52 604 56 1877 60 000 026 092 022 6923 222 4545 012 848 5000 01 933 014 2222 1818 4877 5625 007 1207 729 11970 8684341 783 12935 377 13450 144124 5977 104 14532 241 2840 14768 060 182 758 858 1652 4282 10550 11205 11580 11993 12525 3455 243 1805 363 1061 992 804 1095 917 1988 4862 1220 1186 11947 1337 12975 1390 13837 1747 14553 1519 15282 185 300 860 982 1787 4297 10547 11378 11758 12468 12897 1017 2397 897 1743 721096 1328 1035 720819 1014 144083 1162 187874 1172 1182544 1231 1668621 70014 1502 9509 1433 3156 1561 717 508 2950 4337 1080402 4983 724053 045 1440353 003 2160345 1499 2581 877281 2641 1227919 2225 54435 1769 7827 1461 2695 As SATbased experimentation solvers different nature DPLLbased complete systems ZCHAFF 38 SATZ 33 localsearch based incomplete solvers WALKSAT 45 BGWALKSAT 51 guided backbones We solved instances delaying constraints As OPL wrote linear nonlinear speciﬁcation problems applied reformulation technique linear cf Section 4 All solvers default parameters heuristic tuning possibly alter performances This coherent declarative approach adopted paper Experiments executed Intel 24 GHz Xeon biprocessor The size instances chosen machine able solve seconds hour In way instantiation postprocessing evaluation delayed constraints times negligible comparison solving time In follows refer saving percentage deﬁned ratio time_no_delay time_delaytime_no_delay 3coloring We solved problem 1500 randomly generated graph instances 500 nodes The number edges varies covers phase transition region 11 ratio directed edges nodes varies 20 60 In particular considered sets 100 instances ﬁxed number edges solved set delaying disjointness constraints timeout set 1 hour Table 1 shows overall solving times set instances SAT solvers consideration As observed saving percentage depends edgesnodes ratio solver However consistent time savings classes instances In particular ZCHAFF positively affected safedelay classes instances 1500 edges negatively affected 2840 On hand localsearch based SAT solvers WALKSAT BGWALKSAT consistent improvement reformulation technique saving 13 17 hard instances This behavior consistent observation enlarging set solutions proﬁtable kind solvers discussed end section observed experiments Even incomplete solvers able ﬁnd solution satisﬁable instances class input graphs 1100 edges case solution 40 WALKSAT 50 BGWALKSAT positive instances Delaying disjointness constraints alter percentage signiﬁcant way Also SATZ beneﬁts safedelay savings 22 26 hard instances underconstrained instances 700 edges highlight poorer performances 4983 It worth noting experiments described effectiveness reformulation depend instancedependent parameters like edgesnodes ratio However exclude classes solvers beneﬁt technique In particular interesting note best technology local search improved 794 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 For concerns CPLEX instead experimental results highlight signiﬁcant variations performances cases set 1500 instances solving times negligible timeout occurred disjointness constraints Finally solving linear speciﬁcation SOLVER observed following mixed evidence About 15 instances solved regardless safedelay ii Another 15 instances successfully solved original speciﬁcation performing safedelay prevented terminate time limit iii As remaining instances average savings time appreciable kcoloring We solved kcoloring problem benchmark instances classes DIMACS repository k close optimum order nontrivial instances positive negative Results SATbased experiments shown Table 2 As observed effectiveness reformulation technique varies different solvers In particular ZCHAFF beneﬁts safedelay instances positive negative On hand local search solvers WALKSAT BGWALKSAT delaying disjointness constraints cases speedsup computation usually 2030 The happens SATZ higher savings solver timeouts instances As OPL instead mixed evidence case linear speciﬁcation solved CPLEX efﬁcient nonlinear solved SOLVER vice versa Indeed linear spec iﬁcation solved CPLEX beneﬁts safedelay Table 3 shows results obtained graphs classes benchmark set Differently Table 2 case higher number instances solved opted showing aggregate results grouping instances class In partic Table 2 Solving times seconds kcoloring SAT solvers Instance Colors Sol ZCHAFF WALKSAT BGWALKSAT SATZ vable No delay Delay sav No delay Delay sav No delay Delay sav No delay Delay sav 10 anna 11 anna 10 david 11 david 8 DSJC1255 10 DSJC2505 5 DSJC5001 5 le450_5a 5 le450_5b 5 le450_5c 9 le450_5c 5 le450_5d 9 miles500 20 miles500 30 mulsoli2 31 mulsoli2 30 mulsoli3 31 mulsoli3 30 mulsoli4 31 mulsoli4 30 mulsoli5 31 mulsoli5 5 myciel5 6 myciel5 9 queen8_8 10 queen9_9 queen11_11 13 queen14_14 17 12 queen8_12 N Y N Y N N N Y Y Y Y Y N Y N Y N Y N Y N Y N Y Y Y Y Y Y 2487 001 1515 01 4142 1114 1723 2777 002 1120 009 8019 001 001 001 001 001 3961 1502 000 001 1393 1304 000 01 9025 404 9854 5269 8609 155 9472 091 9510 136 000 002 8384 181 120 123333 3197 5455 000 001 000 001 000 001 000 001 000 001 41399 171426 31408 000 001 5350 139723 214476 5595 86314 11414 54304 178 126923 55346 1775 013 001 1183 571 648 4000 005 008 1433 478 558 2500 007 005 mem mem mem mem mem mem 923 491 542 1730 510 617 1333 867 1000 000 120 120 431 815 852 624 851 908 3125 036 053 2075 2883 2285 4431 236 2112 2920 2303 4111 248 1978 2940 2358 4091 238 1991 2670 2138 4532 253 1250 116 000 002 2452 395 1095 822 731 1513 3579 971 827 1182 4294 1108 468 527 463 133 002 523 425 422 403 40 62 006 01 466 552 005 007 mem mem mem mem mem mem 551 497 615 548 965 923 135 147 840 842 738 970 046 063 3018 2416 280 421 3147 2438 305 460 3093 2481 276 498 2848 2263 288 542 115 133 001 001 413 525 843 761 1447 1163 457 3333 1541 2500 997 1084 432 795 020 2392 2632 1993 3360 2251 3370 1977 4448 2054 4677 1375 000 2127 968 1959 908 2275 525 571 740 603 029 063 009 008 15867 14533 7716 9683 9333 10462 2002 2245 520 600 376 836 267 510 270 504 273 508 274 514 3925 5289 004 010 022 027 4551 5691 20566 17562 94330 70892 025 035 6897 8730 841 2031 1079 1082 1333 5502 4765 4643 4626 4669 2579 6000 1852 2003 1461 2486 2857 means solver terminate hour mem outofmemory error occurred A means local search solver ﬁnd solution M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 795 Table 3 Aggregate results sum solving times seconds kcoloring CPLEX Class Leighton le graphs Random DSJC graphs Reg alloc fpsol mulsol zeroin graphs SGB book anna david huck jean graphs SGB miles SGB games SGB queen Mycielsky All Instances Solvable Number Y N Total Y N Total Y N Total Y N Total Y N Total Y N Total Y N Total Y N Total Y N Total 3 6 9 1 4 5 9 1 10 4 4 8 3 2 5 1 1 2 11 4 15 5 2 7 37 24 61 CPLEX No delay 477652 11064 488716 1922 502608 504530 1242385 2279 1244664 216 191 407 13824 298 14122 097 097 194 1180653 893 1181546 708 608 1316 2917457 518038 3435495 Delay 666007 4042 670049 1815 411210 413025 1117964 1424 1119388 227 171 398 19723 207 19930 088 105 193 631920 933 632853 497 557 1054 2438241 418649 2856890 Saving 188355 7022 181333 107 91398 91505 124421 855 125276 011 020 009 5899 091 5808 009 008 001 548733 040 548693 211 051 262 479216 99389 578605 Saving 3943 6347 3710 557 1818 1814 1001 3752 1007 509 1047 221 4267 3054 4113 928 825 052 4648 448 4644 2980 839 1991 1643 1919 1684 ular class write number instances solved time needed CPLEX positive negative ones safedelay instances solved hour speciﬁcations removed It observed reformulated speciﬁcation efﬁcient average especially negative instances Actually safedelay deleterious cases positive instances Leighton SGB miles classes Job shop scheduling We considered 40 benchmark instances known LA01 LA40 number tasks ranging 50 225 number jobs 10 15 number processors ranging 5 15 However order solvers especially SAT ones able deal large instances reduced rounded task lengths global deadline factor 20 original lengths 100 In way obtained instances good approximations original ones smaller time horizons fewer propositional variables need generated SAT solving times listed Table 4 different values deadline Again mixed evidence concerns ZCHAFF beneﬁts safedelay instances savings time positive local search solvers WALKSAT BGWALKSAT able ﬁnd solution positive instances delaying constraints makes terminate earlier As SATZ savings performances high solver able solve small portion instance set Interestingly blow number clauses safedelay cases makes solver able handle large instances cf Table 4 instance LA06 deadline 50 preventing running memory cases outofmemory error changes timeout 796 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 Table 4 Solving times seconds job shop scheduling Instance Proc Tasks Jobs Dead line Sol vable ZCHAFF WALKSAT BGWALKSAT SATZ No delay Delay sav No delay Delay sav No delay Delay sav No delay Delay sav la01 la01 la02 la02 la03 la03 la04 la04 la05 la05 la06 la06 la07 la07 la08 la08 la09 la09 la10 la10 la16 la16 la17 la17 la18 la18 la19 la19 la20 la20 la22 la22 la23 la23 la24 la24 la25 la25 la29 la29 la36 la36 la38 la38 la39 la39 la40 la40 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 15 15 15 15 15 15 15 15 50 50 50 50 50 50 50 50 50 50 75 75 75 75 75 75 75 75 75 75 100 100 100 100 100 100 100 100 100 100 150 150 150 150 150 150 150 150 200 200 225 225 225 225 225 225 225 225 10 10 10 10 10 10 10 10 10 10 15 15 15 15 15 15 15 15 15 15 10 10 10 10 10 10 10 10 10 10 15 15 15 15 15 15 15 15 20 20 15 15 15 15 15 15 15 15 33 34 32 33 31 32 29 30 28 29 46 50 43 50 42 43 46 50 46 50 47 48 39 40 41 42 42 43 44 45 48 50 50 53 46 48 48 50 50 75 62 65 58 75 61 62 59 75 N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y N Y 069 013 175 234 277 192 111 405 133 029 044 127 085 2319 124 85385 800 161 5427 107 2419 210 8385 031 450 106 3012 283 099 2556 057 9655 189 32955 2283 3083 098 26244 18153 031 576 223 1544 15526 4158 9071 15164 8766 1871 542 372 3137 419 1386 368 631 3328 421 575 327 4313 3387 3309 5004 12068 15467 2817 1175 533 3332 1391 4719 6195 93479 4807 4286 102856 1070 13815 12337 108331 3982 352 35656 34402 43827 51021 1641 6926 70509 21674 138773 2290 3684 52786 7067 84458 5308 3536 132974 119376 177300 4852 78754 91824 1660 2798 98998 71296 887 115418 125654 604 2086 117304 123804 782 3983 3113 2184 4077 3142 2294 3663 2863 2184 3737 2880 2293 3278 2537 2262 3285 2553 2227 3322 2610 2142 3325 2622 2115 2892 2283 2104 2642 1840 3035 7810 6292 1944 7732 6020 2214 7835 6221 2059 7862 6078 2268 7702 6072 2116 7683 6202 1928 8658 6720 2239 8573 6540 2372 8080 6486 1972 8010 6190 2272 6933 5173 2538 6987 5155 2622 5703 4446 2203 5782 4420 2355 6230 4753 2370 6372 4750 2545 6328 4717 2547 6483 4853 2514 6652 5068 2380 6887 5060 2652 mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem 3955 3121 2107 4072 3195 2153 3795 2992 2117 3823 2910 2389 3292 2511 2370 3267 2631 1944 3348 2606 2215 3447 2602 2452 2925 2310 2103 2773 1946 2981 7998 6300 2123 7877 6037 2336 8010 6255 2191 7808 5940 2393 7618 6017 2102 7725 6107 2095 8657 6715 2243 8365 6330 2433 8142 6307 2254 8097 6105 2460 6747 5111 2423 7070 5153 2711 5623 4378 2214 5880 4371 2565 6112 4548 2558 6217 4685 2464 474 2590 6397 6352 4758 2509 6622 4953 2520 6747 4940 2678 mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem 15449 176 9886 90438 18944 7905 69977 29512 5783 089 058 3483 mem mem 487 10000 mem mem mem 310810 10000 mem mem mem mem 352402 211 mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem mem means solver terminate hour mem outofmemory error occurred A means local search solver ﬁnd solution For concerns experiments OPL instead CPLEX SOLVER run linear speciﬁcation affected delaying constraints affected negatively typically slower SAT For reason detailed results omitted Summing solved thousands instances On average delaying constraints useful SAT solver In particular local search solvers like WALKSAT BGWALKSAT beneﬁt M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 797 reformulation The happens SATZ As ZCHAFF mixed evidence cases affected safedelay cf results Table 1 affected negatively beneﬁts reformulation cf Tables 2 4 The behavior SAT solvers explained considering phenomena safedelay produces The reduction number clauses ii The enlargement set solutions The phenomenon particularly beneﬁcial dealing local search observed 4143 symmetrybreaking technique reduces solution density experimentally proven obstacle algorithms Of course reduced number clauses general helps solver Nonetheless worth noting clauses derived disjointness constraints short intuitively explains efﬁcient complete solver ZCHAFF powerful algorithms efﬁciently deal short clauses respect SATZ beneﬁts safedelay As far CPLEX SOLVER concerned mixed evidence First observed case linear speciﬁcation solved CPLEX faster nonlinear solved SOLVER vice versa However cases CPLEX faster delaying constraints speedsup computation This consistent observation theoretical point view ﬁnding partitioning harder ﬁnding covering practice holds presence additional constraints Moreover beneﬁcial behavior highlighted negative instances deeper analyses number iterations branches More iterations needed average simplex algorithm invoked speciﬁcation delay ii The number branches unaffected performing safedelay In particular issue suggests branchandbound subproblem solved efﬁciently speciﬁcation safedelay Unfortunately CPLEX opensource hard analyze explain behavior greater Finally SOLVER invoked linear speciﬁcation observed safedelay negative effect behavior line common observation cf literature symmetrybreaking addition implied constraints restricting set solutions adding tighter constraints helps dealing solvers based backtracking signiﬁcantly increase propagation consequently leads better pruning search space 6 Conclusions related future work In paper shown simple reformulation architecture proven soundness large class problems The reformulation allows delay solution constraints results faster solving In way shown reasoning speciﬁcation effective classes solvers Although Theorem 1 calls tautology checking cf Hyp 2 shown different speciﬁcations test immediate Furthermore believe practice automated theorem prover ATP reason speciﬁcations making possible automatically perform task choosing constraints delay Actually paper 6 shown stateoftheart ATPs usually perform similar tasks detecting breaking symmetries detecting functional dependencies problem speciﬁcations Related work Several researchers addressed issue reformulation problem instantiation phase example 50 shown translate instantiated CSP Boolean form useful ﬁnding different reformulations 13 proposed approach generate conjunctive decomposition instantiated CSP localizing independent subproblems Furthermore 24 CGRASS presented allowing automated breaking symmetries generation useful implied constraints CSP Finally 23 shown abstracting problems simplifying constraints useful ﬁnding efﬁcient reformula tions original problem abstraction require backtracking ﬁnding solutions original problem In work focus reformulation speciﬁcation regardless instance differently techniques approach backtrackingfree ﬁrst stage completed solution surely evaluating delayed constraints Other papers investigate best way encode instance problem format adequate speciﬁc solver As example different ways encoding graph coloring permutation problems SAT ﬁgured cf 2549 In particular idea looking multivalued functions implemented adhoc techniques encoding problems SAT like Graph coloring 4246 Job shop scheduling 15 Conversely work speciﬁcationoriented approach giving formal justiﬁcation 798 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 constraints safely delayed presenting sufﬁcient conditions effectively order isolate constraints Finally point logicbased approach successfully adopted 80s study query optimization problem relational DBs Analogously approach query optimization problem attacked relying query speciﬁcation considering database instance ﬁrstly studied formal way ﬁrstorder logic cf 2103044 In later stage theoretical framework translated rules automated rewriting queries expressed real world languages systems Since effectiveness particular reformulation technique expected depend problem solver rule principle possibility ﬁnd reformulations good solvers solvers certain class research investigates reformulation problem different complementary directions particular related work study detect symmetries 35 functional dependencies 5 predicates speciﬁcations speciﬁcations rewritten exploiting properties symmetries broken appropriate symmetrybreaking constraints added problem speciﬁcation dependencies exploited automatically synthesizing suitable search strategies Experimental analysis shows approaches effective practice different classes solvers We shown 6 automatic tools ﬁrstorder theorem provers ﬁnite model ﬁnders exploited practical circumstances kind reasoning Future work In paper focused form reformulation partitions ﬁrstorder speciﬁcation This basic idea generalized example evaluating stages computation constraint 9 allow nonshrink second stages cf speciﬁcation Golomb ruler problem Example 5 order allow reformulation larger class speciﬁcations Even generally sec ond stage evaluation secondorder formula In future planwith extensive experimentationto check generalizations effective practice Another important issue understand relationships delaying constraints techniques symmetry breaking In fact case delaying constraints making set solutions larger improves solving process Adding symmetrybreaking implied constraints known techniques reach goal opposite strategy reducing set solutions Currently completely clear cases removing constraints results better performances respect adding constraints speciﬁcation important role played nature constraints remove add amenability propagation search tree nature solver backtracking linear based local search As class solvers known enlarging set solutions signiﬁcantly speedup performances cf 4143 Our experiments WALKSAT BGWALKSAT conﬁrm thesis Finally goal rephrase theoretical results rules automatically reformulating problem speciﬁ cations given complex languages AMPL OPL higherlevel builtin constructs Acknowledgements This research supported MIUR Italian Ministry Instruction University Research FIRB project ASTRO Automazione dellIngegneria del Software basata su Conoscenza COFIN project Design development software speciﬁcation efﬁcient solution combinatorial problems based highlevel language techniques intensional reasoning local search The authors grateful Carlo Mannino Stefano Smriglio useful discussions CPLEX anonymous reviewers comments suggestions Appendix A Proofs results Proof Theorem 1 Let I instance M list extensions S1 Sh S M I ψ s extS extension S M extS I ψ d From deﬁnition ψ d follows cid2 cid3 M extS I X SX S X 799 A1 A2 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 clauses Ξ contain negative occurrences S cid3 extS I Ξ cid2 M cid2 M cid2 M cid2 M Furthermore deﬁnition ψ s follows cid3 I X αX S X Hyp 2 M I X αX S X βX This implies deﬁnition ψ d cid3 extS I X αX SX Moreover deﬁnition true cid3 extS I X SX βX A3 From A1A3 observation S occur right parts thesis fol lows cid2 Proof Theorem 2 Let I input instance M list extensions S1 Sh S M I ψ Let S deﬁned way extS extS Since solutions ψ solutions ψ s extS extS follows M extS extS solution ψ s As ψ d observe M solution speciﬁcation ψ solution constraints X SX βX delayed constraint extS extS particular fact X SX SX holds follows M extS X SX SX βX Conversely extS extS particular fact X SX SX holds follows M extS X SX βX SX Hence thesis follows cid2 References 1 S Abiteboul R Hull V Vianu Foundations Databases Addison Wesley Publishing Company Reading MA 1995 2 AV Aho Y Sagiv JD Ullman Equivalences relational expressions SIAM Journal Computing 2 8 1979 218246 3 E Börger E Gräedel Y Gurevich The Classical Decision Problem Perspectives Mathematical Logic Springer Berlin 1997 4 CA Brown L Finkelstein PW Purdom Backtrack searching presence symmetry T Mora Ed Proceedings Sixth International Conference Applied Algebra Algebraic Algorithms Error Correcting Codes Rome Italy Lecture Notes Computer Science vol 357 Springer Berlin 1988 pp 99110 5 M Cadoli T Mancini Exploiting functional dependencies declarative problem speciﬁcations Proceedings Ninth European Conference Logics Artiﬁcial Intelligence JELIA 2004 Lisbon Portugal Lecture Notes Artiﬁcial Intelligence vol 3229 Springer Berlin 2004 6 M Cadoli T Mancini Using theorem prover reasoning constraint problems Proceedings Ninth Conference Italian Association Artiﬁcial Intelligence AIIA 2005 Milano Italy Lecture Notes Artiﬁcial Intelligence vol 3673 Springer Berlin 2005 pp 3849 7 M Cadoli T Mancini F Patrizi SAT effective solving technology constraint problems Proceedings Twentieth Convegno Italiano di Logica Computazionale CILC 2005 Roma Italy 2005 8 M Cadoli A Schaerf Compiling problem speciﬁcations SAT Artiﬁcial Intelligence 162 2005 89120 9 E Castillo AJ Conejo P Pedregal R García N Alguacil Building Solving Mathematical Programming Models Engineering Science John Wiley Sons 2001 10 AK Chandra PM Merlin Optimal implementation conjunctive queries relational databases Proceedings Ninth ACM Sym posium Theory Computing STOC77 Boulder CO ACM Press 1977 pp 7790 11 P Cheeseman B Kanefski WM Taylor Where hard problem Proceedings Twelfth International Joint Conference Artiﬁcial Intelligence IJCAI91 Sydney Australia Morgan Kaufmann Los Altos CA 1991 pp 163169 12 BMW Cheng KMF Choi JHM Lee JCK Wu Increasing constraint propagation redundant modeling experience report Con straints 4 2 1999 167192 13 BY Choueiry G Noubir On computation local interchangeability discrete constraint satisfaction problems Proceedings Fifteenth National Conference Artiﬁcial Intelligence AAAI98 Madison WI AAAI PressThe MIT Press 1998 pp 326333 800 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 14 TH Cormen CE Leiserson RL Rivest Introduction Algorithms The MIT Press 1990 15 JM Crawford AB Baker Experimental results application satisﬁability algorithms scheduling problems Proceedings Twelfth National Conference Artiﬁcial Intelligence AAAI94 Seattle WA AAAI PressThe MIT Press 1994 pp 10921097 16 JM Crawford ML Ginsberg EM Luks A Roy Symmetrybreaking predicates search problems Proceedings Fifth Interna tional Conference Principles Knowledge Representation Reasoning KR96 Cambridge MA Morgan Kaufmann Los Altos CA 1996 pp 148159 17 R Dechter Constraint networks survey Encyclopedia Artiﬁcial Intelligence second ed John Wiley Sons 1992 pp 276285 18 D East M Truszczynski Predicatecalculus based logics modeling solving search problems ACM Transactions Computational Logic 2004 submitted publication 19 R Fagin Generalized ﬁrstorder spectra polynomialtime recognizable sets RM Karp Ed Complexity Computation American Mathematical Society Providence RI 1974 pp 4374 20 P Flener Towards relational modelling combinatorial optimisation problems C Bessière Ed Proceedings International Work shop Modelling Solving Problems Constraints conjunction Seventeenth International Joint Conference Artiﬁcial Intelligence IJCAI 2001 Seattle WA 2001 21 P Flener J Pearson M Ågren Introducing ESRA relational language modelling combinatorial problems Proceedings Eigh teenth IEEE Symposium Logic Computer Science LICS 2004 Uppsala Sweden Springer Berlin 2003 pp 214232 22 R Fourer DM Gay BW Kernigham AMPL A Modeling Language Mathematical Programming International Thomson Publishing 1993 23 EC Freuder D Sabin Interchangeability supports abstraction reformulation multidimensional constraint satisfaction Pro ceedings Fourteenth National Conference Artiﬁcial Intelligence AAAI97 Providence RI AAAI PressThe MIT Press 1997 pp 191196 24 A Frisch I Miguel T Walsh CGRASS A transforming constraint satisfaction problems Proceedings Joint Workshop ERCIM Working Group Constraints CologNet area Constraint Logic Programming Constraint Solving Constraint Logic Programming ERCIM 2002 Cork Ireland Lecture Notes Artiﬁcial Intelligence vol 2627 Springer Berlin 2002 pp 1530 25 AM Frisch TJ Peugniez Solving nonboolean satisﬁability problems stochastic local search Proceedings Seventeenth International Joint Conference Artiﬁcial Intelligence IJCAI 2001 Seattle WA Morgan Kaufmann Los Altos CA 2001 pp 282290 26 MR Garey DS Johnson Computers Intractability A Guide Theory NPCompleteness WH Freeman Company San Francisco CA 1979 27 E Giunchiglia R Sebastiani Applying DavisPutnam procedure nonclausal formulas Proceedings Sixth Conference Italian Association Artiﬁcial Intelligence AIIA99 Bologna Italy Lecture Notes Artiﬁcial Intelligence vol 1792 Springer Berlin 2000 pp 8494 28 F Giunchiglia T Walsh A theory abstraction Artiﬁcial Intelligence 57 1992 323389 29 T Hnich T Walsh Why Channel Multiple viewpoints branching heuristics Proceedings Second International Workshop Modelling Reformulating CSPs Towards Systematisation Automation conjunction Ninth International Conference Principles Practice Constraint Programming CP 2003 Kinsale Ireland 2003 30 A Klug On conjunctive queries containing inequalities Journal ACM 1 35 1988 146160 31 N Leone G Pfeifer W Faber T Eiter G Gottlob S Perri F Scarcello The DLV System knowledge representation reasoning ACM Transactions Computational Logic submitted publication 32 CM Li Integrating equivalency reasoning DavisPutnam procedure Proceedings Seventeenth National Conference Artiﬁcial Intelligence AAAI 2000 Austin TX AAAI PressThe MIT Press 2000 pp 291296 33 CM Li Anbulagan Heuristics based unit propagation satisﬁability problems Proceedings Fifteenth International Joint Conference Artiﬁcial Intelligence IJCAI97 Nagoya Japan Morgan Kaufmann Los Altos CA 1997 pp 366371 34 T Mancini Reformulation techniques class permutation problems Proceedings Ninth International Conference Principles Practice Constraint Programming CP 2003 Kinsale Ireland Lecture Notes Computer Science vol 2833 Springer Berlin 2003 p 984 35 T Mancini M Cadoli Detecting breaking symmetries reasoning problem speciﬁcations Proceedings Sixth International Symposium Abstraction Reformulation Approximation SARA 2005 Airth Castle Scotland UK Lecture Notes Artiﬁcial Intelligence vol 3607 Springer Berlin 2005 pp 165181 36 S Martello P Toth Knapsack Problems Algorithms Computer Implementation John Wiley Sons 1990 37 BD McKay Nauty users guide version 22 Available httpcsanueduaubdmnautynugpdf 2003 38 MW Moskewicz CF Madigan Y Zhao L Zhang S Malik Chaff Engineering Efﬁcient SAT Solver Proceedings Thirty Eighth Conference Design Automation DAC 2001 Las Vegas NV ACM Press 2001 pp 530535 39 I Niemelä Logic programs stable model semantics constraint programming paradigm Annals Mathematics Artiﬁcial Intel ligence 25 34 1999 241273 40 CH Papadimitriou Computational Complexity Addison Wesley Publishing Company Reading MA 1994 41 SD Prestwich Supersymmetric modeling local search Proceedings Second International Workshop Symmetry Con straint Satisfaction Problems conjunction Eighth International Conference Principles Practice Constraint Programming CP 2002 Ithaca NY 2002 42 SD Prestwich Local search SATencoded colouring problems Proceedings Sixth International Conference Theory Applications Satisﬁability Testing SAT 2003 Santa Margherita Ligure Genova Italy Lecture Notes Computer Science vol 2919 Springer Berlin 2004 pp 105119 M Cadoli T Mancini Artiﬁcial Intelligence 170 2006 779801 801 43 SD Prestwich A Roli Symmetry breaking local search spaces R Barták M Milano Eds Proceedings Second International Conference Integration AI OR Techniques Constraint Programming Combinatorial Optimization Problems CPAIOR 2005 Prague CZ Lecture Notes Computer Science vol 3524 Springer Berlin 2005 pp 273287 44 Y Sagiv M Yannakakis Equivalence relational expressions union difference operations Journal ACM 4 27 1980 633655 45 B Selman HA Kautz B Cohen Local search strategies satisﬁability testing M Trick DS Johnson Eds Proceedings Second DIMACS Challenge Cliques Coloring Satisﬁability Providence RI 1993 46 B Selman H Levesque D Mitchell A new method solving hard satisﬁability instances Proceedings Tenth National Conference Artiﬁcial Intelligence AAAI92 San Jose CA AAAI PressThe MIT Press 1992 47 BM Smith K Stergiou T Walsh Using auxiliary variables implied constraints model nonbinary problems Proceedings Seventeenth National Conference Artiﬁcial Intelligence AAAI 2000 Austin TX AAAI PressThe MIT Press 2000 pp 182187 48 P Van Hentenryck The OPL Optimization Programming Language The MIT Press 1999 49 T Walsh Permutation problems channelling constraints R Nieuwenhuis A Voronkov Eds Proceedings Eighth International Conference Logic Programming Automated Reasoning LPAR 2001 Havana Cuba Lecture Notes Computer Science vol 2250 Springer Berlin 2001 pp 377391 50 R Weigel C Bliek On reformulation constraint satisfaction problems Proceedings Thirteenth European Conference Artiﬁcial Intelligence ECAI98 Brighton UK John Wiley Sons 1998 pp 254258 51 W Zhang A Rangan M Looks Backbone guided local search maximum satisﬁability Proceedings Eighteenth International Joint Conference Artiﬁcial Intelligence IJCAI 2003 Acapulco Mexico Morgan Kaufmann Los Altos CA 2003 pp 11791186