Artiﬁcial Intelligence 121 2000 109169 ConGolog concurrent programming language based situation calculus Giuseppe De Giacomo acid3 Yves Lespérance b Hector J Levesque c Dipartimento di Informatica e Sistemistica Università di Roma La Sapienza Via Salaria 113 00198 Roma Italy b Department Computer Science York University Toronto ON Canada M3J 1P3 c Department Computer Science University Toronto Toronto ON Canada M5S 3H5 Received 16 September 1999 Abstract As alternative planning approach highlevel agent control based concurrent program execution considered A formal deﬁnition situation calculus programming language presented illustrated examples The language includes facilities prioritizing execution concurrent processes interrupting execution certain conditions true dealing exogenous actions The language differs procedural formalisms concurrency initial state incompletely speciﬁed primitive actions userdeﬁned axioms situation calculus Some mathematical properties language proven instance proposed semantics equivalent given earlier portion language concurrency cid211 2000 Elsevier Science BV All rights reserved Keywords Cognitive robotics Reasoning actions Situation calculus Semantics programs Concurrency 1 Introduction When comes providing highlevel control robots agents dynamic incompletely known worlds approaches based plan synthesis end demanding computationally simple settings An alternative approach showing promise highlevel program execution 20 The idea roughly cid3 Corresponding author Email addresses degiacomodisuniroma1it G De Giacomo lesperancsyorkuca Y Lespérance hectorcstorontoedu HJ Levesque 0004370200 matter cid211 PII S 0 0 0 4 3 7 0 2 0 0 0 0 0 3 1 X 2000 Elsevier Science BV All rights reserved 110 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 instead searching sequence actions agent initial state goal state task ﬁnd sequence actions constitutes legal execution highlevel nondeterministic program As planning ﬁnd sequence constitutes legal execution highlevel program necessary reason preconditions effects actions body program However program happens deterministic little searching required nondeterminism included search task begins resemble traditional planning Thus formulating highlevel program user gets control search effort required The hope domains agent needs conveniently expressed suitably rich highlevel programming language time ﬁnding legal execution program feasible computationally corresponding planning task Previous work Golog language 20 considered reason actions programs containing conditionals iteration recursion nondeterministic operators primitive actions ﬂuents characterized axioms situation calculus In paper explore execute programs incorporating rich account concurrency The execution task remains changes programming language ConGolog Concurrent Golog 6 considerably expressive One nice features language allows conveniently formulate agent controllers pursue goaloriented tasks concurrently monitoring reacting conditions environment deﬁned precisely language situation calculus But kind expressiveness requires considerable mathematical machinery need encode ConGolog programs terms situation calculus things requires encoding certain formulas terms need use secondorder quantiﬁcation deal iteration recursive procedures It obvious complex deﬁnitions wellbehaved consistent Of course ﬁrst formal model concurrency In fact developed approaches available 4172539 1 work inherits intuitions However distinguished fundamental ways First allows incomplete information environment surrounding program In contrast typical programs initial state ConGolog program need partially speciﬁed collection axioms Second allows primitive actions elementary instructions affect environment complex way changes environment affect execution remainder program In contrast typical programs elementary instructions simple predeﬁned statements variable assignments primitive actions ConGolog program determined separate domaindependent action theory speciﬁes action preconditions effects deals frame problem Finally noted interaction prioritized concurrency recursive procedures presents level procedural complexity far know dealt previous formal model 1 In 528 direct use approaches model concurrent complex actions AI investigated G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 111 The rest paper organized follows Section 2 brieﬂy review situation calculus formulate planning task In Section 3 review Golog programming language following section present variant original speciﬁcation highlevel execution task In Section 5 explain informally sort concurrency concerned related notions priorities interrupts The section concludes changes Golog speciﬁcation required handle concurrency In Section 6 illustrate use ConGolog going example programs Then Section 7 extend speciﬁcation handle procedures recursion Handling interaction general form prioritized concurrency allowed ConGolog recursive procedures require sophisticated approach In Section 8 general sufﬁcient conditions allow use simpliﬁed semantics loss generality In Section 9 present Prolog interpreter ConGolog prove correctness In Section 10 conclude discussing properties ConGolog implementation topics future research 2 The situation calculus As mentioned earlier highlevel programs contain primitive actions tests domain dependent An interpreter programs reason preconditions effects actions program ﬁnd legal executions So need language specify domain theories For use situation calculus 24 ﬁrstorder language secondorder features representing dynamic domains In formalism changes world result named actions A possible world history simply sequence actions represented ﬁrstorder term called situation The constant S0 denote initial situation situation actions occurred There distinguished binary function symbol term doa s denotes situation resulting action performed situation s Actions parameterized For example putx y stand action putting object x object y case doputA B s denotes situation resulting putting A B world situation s Notice situation calculus actions denoted function symbols situations world histories ﬁrstorder terms For example doputDownA dowalkP dopickUpA S0 situation denoting world history consisting sequence actions TpickUpA walkP putDownAU Relations truth values vary situation situation called relational ﬂuents denoted predicate symbols taking situation term argument For example Holdingr x s mean robot r holding object x situation s Functions denotations vary situation situation called functional ﬂuents They denoted function symbols additional situation argument positionr s position robot r situation s 112 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 The actions domain speciﬁed providing certain types axioms First state conditions physically possible perform action providing action precondition axiom For use special predicate Possa s represents fact primitive action physically possible executable situation s So example Posspickupx s cid17 8xHoldingx s NextTox s Heavyx says action pickupx agent picking object x possible situation s agent holding situation s positioned x s x heavy Secondly specify action affects state world providing effect axioms For example Fragilex s cid27 Brokenx dodropx s says dropping object x causes broken provided x fragile Effect axioms provide causal laws domain application These types axioms usually insufﬁcient wants reason change One add frame axioms specify ﬂuents remain unchanged actions For example dropping object affect color things coloury s D c cid27 coloury dodropx s D c The frame problem arises number frame axioms large general order 2 cid2 A cid2 F A number actions F number ﬂuents This complicates task axiomatizing domain theorem proving extremely inefﬁcient To deal frame problem use approach Reiter 31 The basic idea collect effect axioms given ﬂuent completeness assumption assume specify ways value ﬂuent change A syntactic transformation applied obtain successor state axiom ﬂuent example Brokenx doa s cid17 D dropx Fragilex s _ 9ba D explodeb NextTob x s _ Brokenx s 6D repairx This says object x broken situation resulting action performed s dropping x x fragile involves bomb exploding x x broken situation s prior action action repairing x This approach yields solution frame problema parsimonious representation effects actions Note relies quantiﬁcation actions This discussion ignores ramiﬁcation qualiﬁcation problems treatment compatible approach described proposed Lin Reiter 21 So following approach domain application speciﬁed theory following form G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 113 cid15 Axioms describing initial situation S0 cid15 Action precondition axioms primitive action characterizing Possa s cid15 Successor state axioms ﬂuent F stating conditions F Ex doa s holds function holds situation s cid15 Unique names axioms primitive actions cid15 Some foundational domain independent axioms The foundational axioms include unique names axioms situations induction axiom They introduce relation situations s s0 holds s0 result sequence actions performed s action sequence possible situation performed s 6 s0 stands s s0 _ s D s0 Since foundational axioms play special role paper omit For details metamathematical properties Lin Reiter 21 Reiter 32 For domain theory sort described clean speciﬁcation planning task dates work Green 13 Classical Planning Given domain theory D goal formula cid30s single freevariable s planning task ﬁnd sequence actions Ea D jD LegalEa S0 cid30doEa S0 doTa1 anU s abbreviation doan doancid01 doa1 s LegalTa1 anU s stands Possa1 s cid1 cid1 cid1 Possan doTa1 ancid01U s In words task ﬁnd sequence actions executable action executed context precondition satisﬁed achieves goal goal formula cid30 holds ﬁnal state results performing actions sequence 3 Golog As presented 20 Golog logicprogramming language primitive actions background domain theory It includes following constructs cid14 possibly subscripted ranges Golog programs cid30 cid141I cid142 cid141 j cid142 cid25vcid14 primitive action wait condition 2 sequence nondeterministic choice actions nondeterministic choice arguments 2 Because exogenous actions concurrent processes Golog waiting cid30 amounts testing cid30 holds current state 114 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 cid14cid3 fproc P1Ev1 cid141 endI proc PnEvn cid14n endI cid14g nondeterministic iteration procedures In ﬁrst line stands situation calculus action special situation constant refer current situation executed Similarly line cid30 stands situation calculus formula refer current situation example OnTableblock aTsU cid30TsU denote action formula obtained substituting situation variable s occurrences functional ﬂuents appearing functional predicate ﬂuents appearing cid30 Moreover confusion arise leave argument ﬂuents altogether example write OnTableblock instead OnTableblock In cases situation suppressed version action formula understood abbreviation version Lets examine simple example features language Heres Golog program clear table blocks world cid25b TOnTableb nowI pickUpbI putAwaybU cid8 proc removeAblock endI removeAblock 9b OnTableb cid3I cid9 Here ﬁrst deﬁne procedure remove block table nondeter ministic choice argument operator cid25 cid25x Tcid14xU executed nondeterministically picking individual x x performing program cid14x The wait action OnTableb succeeds individual chosen b block table current situation The main program uses nondeterministic iteration operator simply says execute removeAblock zero times table clear Note Gologs nondeterministic construct cid141 j cid142 allows choice actions program form executed performing cid141 cid142 In basic form highlevel program execution task special case planning task Program Execution Given domain theory D program cid14 execution task ﬁnd sequence actions Ea D jD Docid14 S0 doEa S0 Docid14 s s0 means program cid14 executed starting situation s s0 legal terminating situation Note Golog programs nondeterministic terminating situations program starting situation In 20 Docid14 s s0 simply viewed abbreviation formula situation calculus The following inductive deﬁnition Do provided 1 Primitive actions Doa s s0 defD PossaTsU s s0 D doaTsU s G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 115 2 Waittest actions Docid30 s s 0 defD cid30TsU s D s 0 3 Sequence Docid141I cid142 s s0 defD 9s00 Docid141 s s00 Docid142 s00 s0 4 Nondeterministic branch Docid141 j cid142 s s0 defD Docid141 s s0 _ Docid142 s s0 5 Nondeterministic choice argument Docid25xcid14x s s0 defD 9x Docid14x s s0 6 Nondeterministic iteration Docid14 cid3 s s 0 defD 8P cid8 cid9 8s1 P s1 s1 8s1 s2 s3TP s1 s2 Docid14 s2 s3 cid27 P s1 s3U cid27 P s s 0 In words action cid14 zero times takes s s0 s s0 set smallest set s1 s1 set situations s1 b Whenever s1 s2 set cid14 situation s2 takes situation s3 s1 s3 set The deﬁnition nondeterministic iteration standard secondorder way expressing set Some appeal secondorder logic appears necessary transitive closure ﬁrstorder deﬁnable nondeterministic iteration appeals closure We left expansion procedures somewhat complex 20 details 4 A transition semantics By Do programs assigned semantics terms relation denoted formulas Docid14 s s0 given program cid14 situation s returns situation s0 resulting executing program starting situation s Semantics form called evaluation semantics 1526 based complete evaluation program When concurrency taken account convenient adopt semantics different form socalled transition semantics computation semantics 15 26 Transition semantics based deﬁning single steps computation contrast directly deﬁning complete computations In present case going deﬁne relation denoted predicate Transcid14 s cid140 s0 associates given program cid14 situation s new situation 116 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 s0 results executing primitive action test action new program cid140 represents remains program having performed action In words Trans denotes transition relation conﬁgurations A conﬁguration pair formed program initial program left perform situation representing current situation We going introduce predicate Finalcid14 s meaning conﬁguration cid14 s ﬁnal computation considered completed program remains executed The ﬁnal situations reached ﬁnite number transitions starting situation coincide satisfying Do relation Complete computations deﬁned repeatedly composing single transitions ﬁnal conﬁguration reached It worth noting program terminate ﬁnal situation satisfy Do relation evaluation semantics typically terminating programs track transitions performed means Trans Indeed nonterminating programs need special treatment transition semantics typically remain undeﬁned evaluation semantics In general evaluation semantics transition semantics belong family structural operational semantics introduced Plotkin 27 Both forms semantics operational assign meaning directly programs denotational semantics instead programs simply speciﬁcations computations better syntactic objects specify control ﬂow computation They abstract semantics contrast concrete operational semantics deﬁne speciﬁc machine operations performed instead deﬁne abstract relation Do Trans denotes possible computations complete computations evaluation semantics single steps computations transition semantics In addition form semantics structural deﬁned structure programs 41 Encoding programs ﬁrstorder terms In simple semantics Do possible avoid introducing programs explicitly logical language Docid14 s s0 abbreviation formula cid8s s0 mention program cid14 programs This possible essentially necessary quantify programs Basing semantics Trans require quantiﬁcation programs To allow develop encoding programs ﬁrstorder terms logical language observe programs general ﬁrstorder terms hand mention formulas tests operator cid25 cid25xcid14 quantiﬁer Encoding programs ﬁrstorder terms requires care introducing constants denoting variables deﬁning substitution explicitly language pose major problem 3 In following abstract details encoding 3 Observe assume formulas occur tests mention programs impossible build selfreferential sentences G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 117 possible essentially use programs formulas ﬁrstorder terms The encoding given Appendix A 42 Trans Final Let formally deﬁne Trans Final intuitively specify possible transitions conﬁgurations Trans conﬁguration considered ﬁnal Final It convenient introduce special program nil called program denote fact remains performed legal termination For example consider program consisting solely primitive action If executed action possible current situation execution action remains program In case program remaining execution action nil Transcid14 s cid140 s0 holds transition conﬁguration cid14 s conﬁguration cid140 s0 running program cid14 starting situation s situation s0 elementary step program cid140 remaining executed As mentioned elementary step execution atomic action changes current situation execution test As program nondeterministic transitions possible conﬁguration To simplify discussion postpone introduction procedures Section 7 The predicate Trans programs procedures characterized following set axioms T rest paper free variables assumed universally quantiﬁed 1 Empty program Transnil s cid140 s0 cid17 False 2 Primitive actions Transa s cid140 s0 cid17 PossaTsU s cid140 D nil s0 D doaTsU s 3 Waittest actions Transcid30 s cid140 s0 cid17 cid30TsU cid140 D nil s0 D s 4 Sequence Transcid141I cid142 s cid140 s0 cid17 9cid13 cid140 D cid13 I cid142 Transcid141 s cid13 s0 _ Finalcid141 s Transcid142 s cid14 s 0 0 5 Nondeterministic branch Transcid141 j cid142 s cid14 0 cid17 Transcid141 s cid140 s0 _ Transcid142 s cid140 s0 s 0 118 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 6 Nondeterministic choice argument Transcid25vcid14 s cid140 s0 cid17 9xTranscid14v x s cid140 s0 7 Iteration Transcid14cid3 s cid140 s0 cid17 9cid13 cid140 D cid13 I cid14cid3 Transcid14 s cid13 s0 The assertions characterize conﬁguration cid14 s evolve single step conﬁguration cid140 s0 Intuitively read follows 1 nil s evolve conﬁguration 2 s evolves nil doaTsU s provided aTsU possible s After having performed remains performed nil returned Note Transa s cid140 s0 stands program term encoding corresponding situation calculus action Poss argument function cid1Tcid1U mapping program term corresponding situation calculus action aTsU replacing situation s The details function deﬁned Appendix A 3 cid30 s evolves nil s provided cid30TsU holds proceed Note situation remains unchanged Analogously previous case function cid1Tcid1U mapping program term condition cid30 corresponding situation calculus formulas cid30TsU replacing situation s Appendix A details 4 cid141I cid142 s evolve cid140 1 Moreover evolve cid140 2 s0 cid142 s evolve cid140 I cid142 s0 provided cid141 s evolve cid140 1 s0 2 s0 provided cid141 s ﬁnal conﬁguration 5 cid141jcid142 s evolve cid140 s0 provided cid141 s cid142 s 6 cid25vcid14 s evolve cid140 s0 provided exists x cid14v x s x program resulting cid14 substituting v evolve cid140 s0 Here cid14v variable x 4 7 cid14cid3 s evolve cid140I cid14cid3 s0 provided cid14 s evolve cid140 s0 Observe cid14cid3 s evolve cid14cid3 s ﬁnal deﬁnition Finalcid14 s tells program cid14 considered ﬁnal state legally terminated situation s Obviously Finalnil s Finalcid14cid3 s cid14cid3 requires 0 repetitions cid14 possible execute cid14 program completing immediately The predicate Final programs procedures characterized set axioms F 1 Empty program Finalnil s cid17 True 2 Primitive action Finala s cid17 False 4 To precise v substituted term form nameOfx nameOf convert situation calculus objectsactions program terms corresponding sort Appendix A G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 119 3 Waittest action Finalcid30 s cid17 False 4 Sequence Finalcid141I cid142 s cid17 Finalcid141 s Finalcid142 s 5 Nondeterministic branch Finalcid141 j cid142 s cid17 Finalcid141 s _ Finalcid142 s 6 Nondeterministic choice argument Finalcid25vcid14 s cid17 9xFinalcid14v x s 7 Iteration Finalcid14cid3 s cid17 True The assertions read follows 1 nil s ﬁnal conﬁguration 2 s ﬁnal program consisting primitive action considered completed performed 3 cid30 s ﬁnal program consisting test action cid30 considered completed performed test cid30 4 cid141I cid142 s considered completed cid141 s cid142 s ﬁnal 5 cid141jcid142 s considered completed cid141 s cid142 s ﬁnal 6 cid25vcid14 s considered completed provided exists x cid14v x s ﬁnal cid14v x obtained cid14 substituting v x 7 cid14cid3 s ﬁnal conﬁguration cid14cid3 allowed execute 0 times In following denote C set axioms Trans Final plus needed encoding programs ﬁrstorder terms 43 Transcid3 Do The possible conﬁgurations reached program cid14 starting situation s obtained repeatedly following transition relation denoted Trans starting cid14 s reﬂexive transitive closure transition relation Such relation denoted Transcid3 deﬁned secondorder situation calculus formula Trans cid3cid14 s cid140 s0 defD 8T T cid27 T cid14 s cid140 s0U stands conjunction universal closure following implications True cid27 T cid14 s cid14 s Transcid14 s cid14 00 00 T cid14 00 00 0 0 s cid14 s s cid27 T cid14 s cid14 0 0 s 120 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 Using Transcid3 Final new deﬁnition Do Docid14 s s0 defD 9cid140Trans cid3cid14 s cid140 s0 Finalcid140 s0 In words Docid14 s s0 holds possible repeatedly singlestep program cid14 obtaining program cid140 situation s0 cid140 legally terminate s0 For Golog programs deﬁnition Do coincides given 20 Formally state following result Theorem 1 Let Do1 original deﬁnition Do 20 presented Section 3 Do2 new given Then Golog program cid14 C jD 8s s0 Do1cid14 s s0 cid17 Do2cid14 s s0 Proof See Appendix B 2 The theorem holds Golog programs involving procedures treatment Section 7 Let note Transstep brings state computation conﬁgura tion cid14 s cid140 s0 need change situation conﬁguration s D s0 In particular test actions property If want abstract computation steps change state program easily deﬁne new relation TransSit skips transitions change situation TransSitcid14 s cid140 s defD 8T 0T cid27 T 0cid14 s cid140 s0U stands conjunction universal closure following implications Transcid14 s cid140 s0 s0 6D s cid27 T 0cid14 s cid140 s0 Transcid14 s cid1400 s T 0cid1400 s cid140 s0 cid27 T 0cid14 s cid140 s0 5 Concurrency We ready deﬁne ConGolog extended version Golog incorporates rich account concurrency We rich handles cid15 concurrent processes possibly different priorities cid15 highlevel interrupts cid15 arbitrary exogenous actions As commonly areas science model concurrent processes interleavings primitive actions component processes A concurrent execution processes primitive actions processes occur interleaved fashion So fact primitive action happening given time This assumption appear problematic domain involves actions extended duration ﬁlling bathtub In Section 64 return issue argue fact straightforward way handle cases G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 121 An important concept understanding concurrent execution process blocked If deterministic process cid14 executing reaches point primitive action situation s Possa s false wait action cid30 cid30TsU false overall execution need fail Golog In ConGolog current interleaving continue successfully provided process cid14 executes The net effect cid14 suspended blocked execution continue 5 The ConGolog language exactly like Golog following additional constructs cid30 cid141 cid142 cid30 cid14 cid141 k cid142 cid141 ii cid142 cid14jj hcid30 cid14i synchronized conditional synchronized loop concurrent execution concurrency different priorities concurrent iteration interrupt The constructs cid30 cid141 cid142 cid30 cid14 synchronized versions usual ifthenelse whileloop They synchronized sense testing condition cid30 involve transition se evaluation condition ﬁrst action branch chosen executed atomic unit So constructs behave similar way testandset atomic instructions build semaphores concurrent programming 1 6 The construct cid141 k cid142 denotes concurrent execution actions cid141 cid142 cid141 ii cid142 denotes concurrent execution actions cid141 cid142 cid141 having higher priority cid142 This restricts possible interleavings processes cid142 executes cid141 blocked The construct cid14jj like nondeterministic iteration instances cid14 executed concurrently sequence Just cid14cid3 executes respect Do like nil j cid14 j cid14I cid14 j cid14I cid14I cid14 j program cid14jj executes respect Do like nil j cid14 j cid14 k cid14 j cid14 k cid14 k cid14 j See Section 63 example use Finally hcid30 cid14i interrupt It parts trigger condition cid30 body cid14 The idea body cid14 execute number times If cid30 true cid14 execute If interrupt gets control higher priority processes cid30 true cid14 execute Once completed execution interrupt ready triggered This means high priority interrupt complete control execution For example hTrue ringBelli highest priority ring bell With interrupts easily write controllers stop 5 Just actions Golog external internal variable assignment ConGolog blocking unblocking happen externally Poss wait actions Internal synchronization primitives easily added 6 In 20 nonsynchronized versions ifthenelse whileloops introduced deﬁning defD Tcid30I cid14cid3I cid30U The synchronized cid30 cid141 cid142 versions constructs introduced behave essentially nonsynchronized ones absence currency However difference striking concurrency allowed defD Tcid30I cid141 j cid30I cid142U cid30 cid14 122 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 task handle concerns arise They dare reactive We Trans Final need extended handle constructs We handle interrupts separately Trans Final synchronized conditionals loops deﬁned follows Transif cid30 cid141 cid142 s cid140 s0 cid17 cid30TsU Transcid141 s cid140 s0 _ cid30TsU Transcid142 s cid140 s0 cid17 0 D cid13 I cid30 cid14 cid30TsU Transcid14 s cid13 s Transwhile cid30 cid14 s cid14 9cid13 cid14 s 0 0 0 Finalif cid30 cid141 cid142 s cid17 cid30TsU Finalcid141 s _ cid30TsU Finalcid142 s Finalwhile cid30 cid14 s cid17 cid30TsU _ Finalcid14 s That cid30 cid141 cid142 s evolve cid140 s0 cid30TsU holds cid141 s cid30TsU holds cid142 s Similarly cid30 cid14 s evolve cid140I cid30 cid14 s0 cid30TsU holds cid14 s evolve cid140 s0 cid30 cid141 cid142 s considered completed cid30TsU holds cid141 s ﬁnal cid30TsU holds cid142 s ﬁnal Similarly cid30 cid14 s considered completed cid30TsU holds cid14 s ﬁnal For constructs concurrency extension Final straightforward Finalcid141 k cid142 s cid17 Finalcid141 s Finalcid142 s Finalcid141 ii cid142 s cid17 Finalcid141 s Finalcid142 s Finalcid14jj s cid17 True Observe clause says legal execute cid14 cid14jj zero times For Trans following Transcid141 k cid142 s cid140 s0 cid17 0 9cid13 cid14 9cid13 cid14 0 D cid13 k cid142 Transcid141 s cid13 s 0 D cid141 k cid13 Transcid142 s cid13 s 0 cid17 9cid13 cid140 D cid13 ii cid142 Transcid141 s cid13 s0 _ 9cid13 cid140 D cid141 ii cid13 Transcid142 s cid13 s0 9cid16 s00 Transcid141 s cid16 s00 _ Transcid141 ii cid142 s cid14 s 0 0 Transcid14jj s cid140 s0 cid17 9cid13 cid140 D cid13 k cid14jj Transcid14 s cid13 s0 In words single step cid141 k cid142 single stepping cid141 cid142 leaving process unchanged The cid141 ii cid142 construct identical allowed single step cid142 legal step cid141 This ensures cid141 execute long possible Finally single step cid14jj single stepping cid14 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 123 left remainder cid14 cid14jj This allows unbounded number instances cid14 running Observe cid141 k cid142 cid141 cid142 able execute interleaving left completely open It legal execute completely starting legal switch forth primitive wait action It hard deﬁne new concurrency constructs kmin kmax require interleaving minimized maximized respectively We omit details Regarding interrupts turns explained constructs ConGolog hcid30 cid14i defD Interrupts_running cid30 cid14 False To works ﬁrst assume special ﬂuent Interrupts_running identically True When interrupt hcid30 cid14i gets control repeatedly executes cid14 cid30 false point blocks releasing control able execute Note according deﬁnition Trans transition occurs test condition whileloop ifthenelse body In effect cid30 false process blocks right beginning loop action makes cid30 true resumes loop To actually terminate loop use special primitive action stop_interrupts effect Interrupts_running false Thus imagine execute program cid14 containing interrupts actually execute program fstart_interrupts I cid14 ii stop_interruptsg effect stopping blocked interrupt loops cid14 lowest priority actions cid14 executed Finally let consider exogenous actions These primitive actions occur userspeciﬁed program We assume background theory user declares predicate Exo actions occur exogenously We deﬁne special program exogenous events cid14EXO defD cid25 ExoaI acid3 Executing program involves performing zero nondeterministically chosen exogenous events 7 Then userspeciﬁed program cid14 run concurrently cid14EXO cid14 k cid14EXO In way allow exogenous actions preconditions satisﬁed asynchro nously occur outside control cid14 execution cid14 7 Observe use cid25 program nondeterministically chooses action tests exogenous event executes 124 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 51 Formal properties Trans Final procedures We going axioms Trans Final ConGolog deﬁnitional sense completely characterize Trans Final programs procedures Lemma 1 For ConGolog program term cid14Ex containing variables Ex sort object action exist formulas cid8Ex s cid14 s0 cid9 Ex s Ex s cid140 s0 Ex s free variables cid8 cid9 respectively mention Final Trans C jD 8Ex s cid140 s0 Transcid14Ex s cid140 s0 cid17 cid8Ex s cid140 s0 C jD 8Ex s Finalcid14Ex s cid17 cid9 Ex s 1 2 Proof For 1 2 proof similar induction program structure considering base cases programs form nil cid30 Base cases thesis immediate consequence axioms Trans Final righthand equivalences mention Trans Final Inductive cases inspection axioms righthand simpler program terms contain variables sort object action ﬁrst argument Trans Final thesis straightforward consequence inductive hypothesis 2 It follows lemma axioms T F axioms encoding programs ﬁrstorder terms completely determine interpretation predicates Trans Final basis interpretation predicates That T F implicitly deﬁne predicates Trans Final Formally following theorem Theorem 2 There pair models C differ interpretation predicates Trans Final Proof By contradiction Suppose models M1 M2 C agree interpretation nonlogical symbols constant function predicates Trans Final Lets disagree Trans tuple domain values Ocid14 Os Ocid140 Os0 Ocid14 Os Ocid140 Os0 2 TransM1 Ocid14 Os Ocid140 Os0 2 TransM2 Considering structure sort programs Appendix A value domain sort programs Ocid14 program term cid14Ex containing variables Ex sort object action assignment cid27 Ex cid14M1cid27 D cid14M2cid27 D Ocid14 Now let consider variables s cid140 s0 assignment cid27 0 cid27 0Ex D cid27 Ex cid27 0s D Os cid27 0cid140 D Ocid140 cid27 0s0 D Os0 By Lemma 1 exists formula cid8 Trans Final occurs cid8 Mi cid27 0 jD Transcid14 s cid140 s0 iff Mi cid27 0 jD cid8Ex s cid140 s0 D 1 2 Since M1 cid27 0 jD cid8Ex s cid140 s0 iff M2 cid27 0 jD cid8Ex s cid140 s0 contradiction 2 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 125 6 Some examples 61 Two robots lifting table Our ﬁrst example involves simple case concurrency robots jointly lift table Test actions synchronize robots actions table tip objects fall Two instances program control robots cid15 Objects Two agents 8r Robotr cid17 r D Rob1 _ r D Rob2 Two table ends 8e TableEnde cid17 e D End1 _ e D End2 cid15 Primitive actions grabrob end releaserob end vmoverob z robot arm z units cid15 Primitive ﬂuents Holdingrob end s vposend s D z height table end cid15 Initial state 8r e Holdingr e S0 8e vpose S0 D 0 cid15 Precondition axioms 0 Possgrabr e s cid17 8r Possreleaser e s cid17 Holdingr e s Possvmover z s cid17 True Holdingr 0 e s 8e 0 Holdingr e 0 s cid15 Successor state axioms Holdingr e doa s cid17 D grabr e _ Holdingr e s 6D releaser e vpose doa s D p cid17 9r za D vmover z Holdingr e s p D vpose s C z _ 9r D releaser e p D 0 _ p D vpose s 9r za D vmover z Holdingr e s 9r D releaser e 126 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 The goal table sufﬁciently level falls We deﬁne follows defD vposEnd1 s H vposEnd2 s H TableUps ends table higher threshold H defD jvposEnd1 s cid0 vposEnd2 sj 6 Tol Levels ends height threshold Tol So goal Goals defD TableUps 8s0s0 6 s cid27 Levels0 claim goal achieved having Rob1 Rob2 concurrently execute procedure ctrl deﬁned proc ctrlrob cid25eTTableEndeI grabrob eUI TableUpnow SafeToLiftrob nowI vmoverob Amount end Amount constant 0 Amount Tol SafeToLift deﬁned SafeToLiftrob s defD 9e e0 e 6D e0 TableEnde TableEnde0 Holdingrob e s vpose 6 vpose0 C Tol cid0 Amount Here use procedures simply convenience reader abbreviations A formal treatment procedures provided Section 7 So formally claim 8 C D jD 8sDoctrlRob1kctrlRob2 S0 s cid27 Goals Here informal sketch proof Do holds ﬁnite sequence transitions initial conﬁguration ctrlRob1kctrlRob2 S0 conﬁguration Final A program involving concurrent processes Final conﬁguration reaching conﬁguration Final processes The processes program involve whileloops reach ﬁnal conﬁguration loop condition false So table high ﬁnal situation It remains shown table stayed level Let vi stand action vmoverobi Amount Suppose contrary table went high End1 held Rob1 consider ﬁrst conﬁguration true This situation conﬁguration form dov1 s vposEnd1 dov1 s vposEnd2 dov1 s C Tol 8 Actually proper termination program guaranteed However stating condition formally case concurrency requires additional machinery 9sDoctrlRob1kctrlRob2 S0 s weak G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 127 However earlier conﬁguration SafeToLiftRob1 s0 intervening actions Rob1 v1 executed This means vposEnd1 s0 6 vposEnd2 s0 C Tol cid0 Amount However actions s0 s Rob2 Rob2 increase value vposEnd2 follows vposEnd1 s 6 vposEnd2 s C Tol cid0 Amount SafeToLift true ﬁnal v1 action This contradicts assumption v1 adds Amount value vposEnd1 62 A reactive multielevator controller Our example involves reactive controller bank elevators illustrates use interrupts prioritized concurrency The example use following terms e stands elevator cid15 Ordinary primitive actions goDowne goUpe buttonResetn toggleFane ringAlarm cid15 Exogenous primitive actions reqElevatorn changeTempe detectSmoke resetAlarm cid15 Primitive ﬂuents ﬂoore s D n tempe s D t FanOne s ButtonOnn s Smokes cid15 Deﬁned ﬂuents elevator ﬂoor elevator ﬂoor turn button ﬂoor n change state elevator fan ring smoke alarm button ﬂoor n pushed elevator temperature changes smoke detector ﬁrst senses smoke smoke alarm reset elevator ﬂoor n 1 6 n 6 6 elevator temperature t elevator fan button ﬂoor n smoke detected TooHote s TooColde s defD tempe s 1 defD tempe s cid01 We begin following basic action theory primitive actions ﬂuents cid15 Initial state ﬂoore S0 D 1 FanOnS0 tempe S0 D 0 ButtonOn3 S0 ButtonOn6 S0 128 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 cid15 Exogenous actions 8aExoa cid17 D detectSmoke _ D resetAlarm _ D changeTempe _ 9na D reqElevatorn cid15 Precondition axioms PossgoDowne s cid17 ﬂoore s 6D 1 PossgoUpe s cid17 ﬂoore s 6D 6 PossbuttonResetn s cid17 True PosstoggleFane s cid17 True PossringAlarm cid17 True PossreqElevatorn s cid17 1 6 n 6 6 ButtonOnn s PosschangeTemp s cid17 True PossdetectSmoke s cid17 Smokes PossresetAlarm s cid17 Smokes cid15 Successor state axioms ﬂoore doa s D n cid17 D goDowne n D ﬂoore s cid0 1 _ D goUpe n D ﬂoore s C 1 _ n D ﬂoore s 6D goDowne 6D goUpe tempe doa s D t cid17 D changeTempe FanOne s t D tempe s cid0 1 _ D changeTempe FanOne s t D tempe s C 1 _ t D tempe s 6D changeTempe FanOne doa s cid17 D toggleFane FanOne s _ FanOne s 6D toggleFane ButtonOnn doa s cid17 D reqElevatorn _ ButtonOnn s 6D buttonResetn Smokedoa s cid17 D detectSmoke _ Smokes 6D resetAlarm Note ﬂuents affected exogenous programmed actions For instance ﬂuent ButtonOn true exogenous action reqElevator calls elevator false programmed action buttonReset elevator serves ﬂoor G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 129 Now ready consider basic elevator controller elevator e It deﬁned like 9nButtonOnn cid25nfBestButtonnI serveFloore ng ﬂoore 6D 1 goDowne The ﬂuent BestButton deﬁned select buttons currently served For example choose button longest For purposes ButtonOn The procedure serveFloore n consist actions elevator serve request ﬂoor n For purposes use proc serveFloore n ﬂoore n goUpe ﬂoore n goDowne buttonResetn end We bothered formalizing opening closing doors nasty complications like passengers As Golog try prove existential look bindings s They form doEa S0 Ea actions perform In particular controller program cid14 execution traces like C D jD Docid14 k cid14EXO S0 doTu u b3 u u u b6 d d d d dU S0 C D jD Docid14 k cid14EXO S0 doTu r4 u b3 u b4 u u r2 b6 d d d d b2 dU S0 u D goUpe d D goDowne bn D buttonResetn rn D reqElevatorn D basic action theory speciﬁed In ﬁrst run exogenous actions second elevator requests This controller big drawback buttons ﬁrst loop terminates elevator returns ﬁrst ﬂoor stops buttons pushed way It better structure interrupts h9nButtonOnn cid25nfBestButtonnI serveFloore ngi h ﬂoore 6D 1 goDownei second lower priority So buttons youre ﬁrst ﬂoor ﬂoor reconsider point buttons pushed exogenously pick serve ﬂoor checking Thus elevator quits ﬁrst ﬂoor buttons 130 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 With scheme easy handle emergency highpriority requests We add h9nEButtonOnn cid25nfEButtonOnnI serveEFloore ngi interrupt higher priority assuming suitable additional actions ﬂuents To deal fan add new interrupts hTooHote FanOne toggleFanei hTooColde FanOne toggleFanei These executed highest priority In case serving ﬂoor amounts temperature hot fan turned continuing similarly cold Note check state fan interrupt loop repeatedly releasing control lower priority processes Finally imagine like ring bell smoke detected disrupt normal service smoke alarm reset exogenously To add interrupt hSmoke ringAlarmi priority emergency button higher normal service Once interrupt triggered elevator stop ring bell repeatedly It handle fan serve emergency requests Putting following controller hTooHote FanOne toggleFanei k hTooColde FanOne toggleFanei ii h9nEButtonOnn cid25nfEButtonOnnI serveEFloore ngi ii hSmoke ringAlarmi ii h9nButtonOnn cid25nfBestButtonnI serveFloore ngi ii h ﬂoore 6D 1 goDownei Using controller cid14r execution traces like C D jD Docid14r k cid14EXO S0 doTu u b3 u u u b6 d d d d r5 u u u b5 d d d dU S0 C D jD Docid14r k cid14EXO S0 doTu u b3 u z h u u b6 d d d d dU S0 C D jD Docid14r k cid14EXO S0 doTu t u b3 u t f u t t u t b6 d t f d t d d dU S0 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 131 z D detectSmoke D ringAlarm h D resetAlarm t D changeTemp f D toggleFan In ﬁrst run controller handle requests come elevator way retire ﬂoor The second run illustrates controller reacts smoke detected ringing alarm The run shows controller reacts immediately temperature changes serving ﬂoors Note elevator controller uses 5 different levels priority It programmed Golog interrupts code lot messier Now let suppose like write controller handles independent elevators In ConGolog elegantly cid141 k cid142 cid141 program e replaced Elevator1 cid142 program e replaced Elevator2 This allows processes work completely independently terms priorities 9 For n elevators use cid141 k cid1 cid1 cid1 k cid14n 63 A clientserver In applications useful unbounded number instances process running concurrently For example FTP server want instance manager process active FTP session This programmed cid14jj concurrent iteration construct Let highlevel sketch Suppose exogenous action newClientcid occurs new client ID cid ﬁrst requests service Also assume procedure servecid deﬁned implements behavior required server given client To set run program Tcid25 cid acquirecidI servecidUjjI 9cid ClientWaitingcid Here assume exogenous action newClientcid occurs makes ﬂuent ClientWaitingcid true Then way computation completed generating new process ﬁrst acquires client acquirecid serves We formalize follows Possacquirecid s cid17 ClientWaitingcid ClientWaitingcid doa s cid17 D newClientcid _ ClientWaitingcid s 6D acquirecidU Then single process acquire given client acquire possible ClientWaitingcid true performing makes ﬂuent false The program reach ﬁnal conﬁguration forks exactly right number server processes client server acquire client client servers activated acquire client 9 Of course elevator requested ﬂoor elevators decide serve It easy program better strategy coordinates elevators elevator decides serve ﬂoor immediately makes ﬂuent true ﬂoor elevator serve ﬂoor ﬂuent true 132 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 64 Actions extended duration One possible criticism approach concurrency work consider actions extended duration Consider singing ﬁlling bathtub water example If actions involved ﬁlling bathtub actions singing singing singing mi exactly possible interleavings Tﬁlling I I I miU Tdo I ﬁlling I I miU Tdo I I ﬁlling I miU Tdo I I mi I ﬁllingU capture idea singing ﬁlling tub time Moreover prospect replacing ﬁlling action large number component actions interleaved singing ones appealing To deal type case recommend following approach 33 detailed presentation instead thinking ﬁlling bathtub action group actions think state agent extending possibly situations The idea agent states simultaneously including listening radio walking chewing gum For state need primitive actions ﬂuent bathtub startFilling puts agent state endFilling terminates ﬂuent FillingTub holds situations agent ﬁlling tub Formally express successor state axiom follows FillingTubdoa s cid17 D startFilling _ FillingTubs 6D endFilling Since startFilling endFilling actions taken instantaneous interleaving account plausible If deﬁne complex action FillTheTub defD TstartFilling I endFillingU run concurrently singing possible interleavings TstartFilling I endFilling I I I miU TstartFilling I I endFilling I I miU TstartFilling I I I endFilling I miU TstartFilling I I I mi I endFillingU Tdo I startFilling I endFilling I I miU Tdo I startFilling I I endFilling I miU Tdo I startFilling I I mi I endFillingU G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 133 Tdo I I startFilling I endFilling I miU Tdo I I startFilling I mi I endFillingU Tdo I I mi I startFilling I endFillingU A better model like FillTheTub defD TstartFilling I waterLevel H I endFillingU rule interleavings ﬁlling stops soon The natural way modeling water level continuous function time l D L0 C R cid2 t L0 initial level R rate ﬁlling taken constant t elapsed time One simple way accommodate idea situation calculus assume action duration dura dependent situation action performed Actions startFilling duration 0 action timePasses non0 duration We waterLevel functional ﬂuent waterLeveldoa s D waterLevels C waterRates cid2 dura waterRatedoa s D FillingTubs R 0 So long situation ﬁllingthetub state water level rises according equation In terms concurrency result allowable interleavings actions sufﬁcient duration occur startFilling stopFilling Of course model continuous process water entering bathtub allow predict eventual outcome example water overﬂowing tap turned A complex program typically involving interrupts required suitable trajectory altering actions triggered appropriate conditions 7 Extending transition semantics procedures We extend transition semantics introduced deal procedures Because recursive procedure arbitrary number procedure calls performs primitive action test procedure calls viewed transitions use secondorder deﬁnition Trans Final In great care understanding interaction recursive procedures general form prioritized concurrency allowed ConGolog Let proc P1Ev1cid141 endI I proc PnEvncid14n end collection procedure deﬁnitions We collection environment denote Env In procedure deﬁnition proc Pi Evi cid14i end Pi ith procedure Env Evi formal parameters cid14i procedure body ConGolog program possibly including procedure calls new procedure deﬁnitions We use callbyvalue parameter passing mechanism lexical static scope scoping rule 134 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 Formally introduce program constructs cid15 P Et P procedure Et actual parameters associated procedure P usual replace situation argument terms constituting Et P Et denotes procedure invokes procedure P actual parameters Et evaluated current situation cid15 fEnvI cid14g Env environment cid14 program extended procedures calls fEnvI cid14g binds procedures calls cid14 deﬁnitions given Env The usual notion free bound apply fproc P1 endI P2I P1g P1 bound P2 free cid15 TEnv V P Et U Env environment P procedure Et actual parameters associated procedure P TEnv V P Et U denotes procedure contextualized environment deﬁnition P looked Env We deﬁne semantics ConGolog programs procedures deﬁning Trans Final secondorder formula instead set axioms 10 Trans deﬁned follows Transcid14 s cid140 s0 cid17 8T T cid27 T cid14 s cid140 s0U T set axioms T modulo textual stands conjunction T Trans substitution Trans T universal closure following assertions cid0 cid14Pi Et TEnvVPi EtU s cid140 s0 cid0 fEnvI cid14P T fEnvI cid14g s cid140 s0 cid17 T T TEnv V P Et U s cid140 s0 cid17 T cid1 g s cid140 s0 cid1 EvP Et TsU cid14Pi Et TEnvVPi EtU denotes program cid14 procedures bound Env free cid14 EvP replaced contextualized version gives lexical scope cid14P EtTsU denotes body procedure P Env formal parameters Ev substituted actual parameters Et evaluated current situation Similarly Final deﬁned follows Finalcid14 s cid17 8FT cid27 F cid14 sU stands conjunction F Final substitution Final F universal closure following assertions cid1 F set axioms F modulo textual F fEnvI cid14g s cid17 F F TEnv V P EtU s cid17 F cid0 cid14Pi Et TEnvVPi EtU s cid0 fEnvI cid14P EvP Et TsU g s cid1 Note assertions uncontextualized procedure calls present deﬁnitions Trans Final Indeed procedure bound procedure deﬁnition transitions considered successfully completed 10 For compatibility formalization Section 4 treat Trans Final predicates clear understood abbreviations secondorder formulas G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 135 Observe uses substitution deal procedure calls When program associated environment executed procedure calls bound Env simultaneously substitute corresponding procedure calls contextualized environment procedure order deal procedure calls according static scope rules Then contextualized procedure actually executed actual parameters ﬁrst evaluated current situation substituted formal parameters procedure bodies 11 yielding callbyvalue parameter passing The following example program cid14StSc illustrates ConGologs static scoping f proc P1 endI proc P2 P1 endI proc P3 f proc P1 b endI P2I P1 g endI P3 g One program sequence atomic actions performed followed b assuming b possible 8sTPossa s Possb sU cid27 8s s TDocid14StSc s s cid17 s 0 0 0 D dob doa sU To consider following Let Env1 defD proc P1 end proc P2 P1 end proc P3 fEnv2I P2I P1g end Env2 defD proc P1 b end Then easy Transcid14StSc s cid140 s0 cid17 TransfEnv1I P3g s cid140 s0 11 To precise formal parameter v substituted term form nameOftTsU nameOf convert situation calculus objectsactions program terms corresponding sort Appendix A 136 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 cid17 TransTEnv1 V P3U s cid140 s0 cid17 TransfEnv1I fEnv2I P2I P1gg s cid140 s0 0 cid17 TransfEnv2I TEnv1 V P2UI P1g s cid14 s cid17 TransTEnv1 V P2UI TEnv2 V P1U s cid140 s0 cid17 TransfEnv1I P1gI TEnv2 V P1U s cid140 s0 cid17 TransTEnv1 V P1UI TEnv2 V P1U s cid140 s0 cid17 TransaI TEnv2 V P1U s cid140 s0 0 D doa s cid14 cid17 Possa s s 0 0 D nilI TEnv2 V P1U Similarly TransTEnv2 V P1U doa s nil dob doa s Finalnil dob doa s yields thesis Our example illustrates ConGologs callbyvalue parameter passing f proc P n n D 1 nil goDownI P n cid0 1 endI P ﬂoor g Intuitively program intended bring elevator ﬂoor building If run program starting situation S0 procedure P ﬂoor invokes P value functional ﬂuent ﬂoor S0 P called ﬂoorTS0U ﬂoor elevator S0 actual parameter If ConGolog callbyname parameter passing P invoked term ﬂoor actual parameter elevator halfway ﬂoor Indeed iteration procedure P n cid0 1 evaluated textually replacing n ﬂoor moment decreased 1 As mentioned earlier need secondorder deﬁnition Transcid14 s cid140 s0 Finalcid14 s procedures introduced comes recursive procedures The second order deﬁnition allows assign formal semantics procedure including viciously circular ones The deﬁnition Trans disallows execution ill formed procedures At time deﬁnition Final considers completed nonﬁnal For example program fproc P P endI P g transitions ﬁnal situation s 12 71 Formal properties Trans Final procedures We observe secondorder deﬁnitions Trans Final easily following form Transcid14 s cid14 s 0 0 cid17 cid27 T cid14 s cid140 s0 8T T8cid141 s1 cid142 s2 cid8TransT cid141 s1 cid142 s2 cid17 T cid141 s1 cid142 s2U 12 Note Golog ConGolog allow Boolean procedures tests Introducing kind procedures requires particular care avoid counterintuitive implications G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 137 Finalcid14 s cid140 s0 cid17 8FT8cid141 s1 cid8FinalF cid141 s1 cid17 F cid141 s1U cid27 F cid14 s cid8Trans cid8Final obtained rewriting assertions deﬁnition Trans Final variables appear lefthand equations T cid14 s cid140 s0 cid17 cid30t T cid14 s cid140 s0 F cid14 s cid17 cid30f F cid14 s getting disjunction righthand sides mutually exclusive deals programs speciﬁc form From deﬁnitions natural induction principles emerge cf discussion extracting induction principles inductive deﬁnitions 34 These principles saying prove property P holds instances Trans Final sufﬁces prove property P closed assertions deﬁnition Trans Final cid8TransP cid141 s1 cid142 s2 cid17 P cid141 s1 cid142 s2 cid8FinalP cid141 s1 cid17 P cid141 s1 Formally state following theorem Theorem 3 The following sentences consequences secondorder deﬁnitions Trans Final respectively 8P T8cid141 s1 cid142 s2 cid8TransP cid141 s1 cid142 s2 cid17 P cid141 s1 cid142 s2U cid27 8cid14 s cid140 s0 Transcid14 s cid140 s0 cid27 P cid14 s cid140 s0 8P T8cid141 s1 cid8FinalP cid141 s1 cid17 P cid141 s1U cid27 0 0 s 8cid14 s Finalcid14 s cid14 cid27 P cid14 s Proof We prove ﬁrst sentence The proof second sentence analogous By deﬁnition 0 0 0 0 8cid14 s cid14 0 s Transcid14 s cid14 s 0 cid17 8P T8cid141 s1 cid142 s2 cid8TransP cid141 s1 cid142 s2 cid17 P cid141 s1 cid142 s2U cid27 P cid14 s cid140 s0 By considering onlyif equivalence 8cid14 s cid14 0 s Transcid14 s cid14 s 0 8P T8cid141 s1 cid142 s2 cid8TransP cid141 s1 cid142 s2 cid17 P cid141 s1 cid142 s2U cid27 P cid14 s cid140 s0 So moving quantiﬁers 8P T8cid141 s1 cid142 s2 cid8TransP cid141 s1 cid142 s2 cid17 P cid141 s1 cid142 s2U 8cid14 s cid140 s0 Transcid14 s cid140 s0 cid27 P cid14 s cid140 s0 thesis 2 138 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 These induction principles allow prove Trans Final programs procedures considered extension programs procedures Theorem 4 With respect ConGolog programs procedures Trans Final introduced equivalent versions introduced Section 4 Proof Let denote Trans deﬁned secondorder sentence TransSOL Trans implicitly deﬁned axioms Section 4 TransFOL Since procedures considered drop loss generality assertions fEnvI cid14g TEnv V P EtU deﬁnition TransSOL Then cid15 TransSOLcid14 s cid140 s0 cid27 TransFOLcid14 s cid140 s0 proven simply noting TransFOL satisﬁes closed assertions deﬁnition TransSOL Theorem 3 cid15 TransFOLcid14 s cid140 s0 cid27 TransSOLcid14 s cid140 s0 proven induction structure cid14 considering base cases nil cid30 applying induction argument Similarly Final 2 It interesting examine Trans Final introduced closed assertions deﬁnitions For Final positive answer established Theorem 5 The following sentence consequence secondorder deﬁnition Final cid8FinalFinalcid14 s cid14 s cid17 Finalcid14 s Proof Observe cid8Final monotonic 13 8Z1 Z2T8cid14 sZ1cid14 s cid27 Z2cid14 sU cid27 T8cid14 scid8FinalZ1 cid14 s cid27 cid8FinalZ2 cid14 sU Hence thesis direct consequence TarskiKnaster ﬁxpoint theorem 40 2 For Trans analogous result hold general Indeed consider following program cid14q f proc Q Q ii endI Q g Observe deﬁnition Trans implies Transcid14q s cid140 s0 cid17 False Hence Trans closed cid8Trans Transcid14q ii s cid140 s0 cid17 Transa s cid140 s0 imply Transcid14q s cid140 s0 cid17 Transa s cid140 s0 Contradiction 13 In fact syntactically monotonic G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 139 Obviously classes ConGolog programs closed cid8Trans For instance disallow prioritized concurrency procedures class Another class obtained allowing prioritized concurrency appear nonrecursive procedures Yet general class immediately obtainable discussed 8 Firstorder Trans Final procedures In section investigate conditions allow replace secondorder deﬁnitions Trans Final programs procedures ﬁrstorder deﬁnitions case procedures allowed 81 Guarded conﬁgurations We deﬁne general condition conﬁgurations pairs programs situations guarantees possibility ﬁrstorder axioms Trans Final procedures To end introduce notion conﬁguration rank Intuitively conﬁguration rank n makes n recursive procedure calls trying actual program step atomic action test We deﬁne rank conﬁguration inductively A conﬁguration rank n denoted Rankn cid14 s Rankn nil s cid17 True Rankn s cid17 True Rankn cid30 s cid17 True Rankn cid141I cid142 s cid17 Rankn cid141 s Finalcid141 s cid27 Rankn cid142 s Rankn cid141 j cid142 s cid17 Rankn cid141 s Rankn cid142 s Rankn cid25vcid14 s cid17 8xRankn cid14v Rankn cid14cid3 s cid17 Rankn cid14 s Rankn cid30 cid141 cid142 s cid17 cid30TsU Rankn cid141 s _ cid30TsU Rankn cid142 s x s Rankn cid30 cid14 s cid17 cid30TsU cid27 Rankn cid14 s Rankn cid141 k cid142 s cid17 Rankn cid141 s Rankn cid142 s Rankn cid141 ii cid142 s cid17 Rankn cid141 s Rankn cid14jj s cid17 Rankn cid14 s cid0 n cid14Pi Et Rankn fEnvI cid14g s cid17 Rank TEnvVPi EtU s cid0 Rankn TEnv V P EtU s cid17 Rank n cid0 1 fEnvI cid14P cid1 cid1 EvP Et TsU g s 9cid140 1 s0Transcid141 s cid140 1 s0 cid27 Rankn cid142 s 140 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 A conﬁguration cid14 s guarded rank n n Guardedcid14 s defD 9n Rankn cid14 s 82 Firstorder Trans Final procedures For guarded conﬁgurations need use secondorder deﬁnitions Trans Final dealing procedures Instead use ﬁrstorder axioms Section 4 following 14 cid0 cid14Pi Et TransfEnvI cid14g s cid140 s0 cid17 Trans TEnvVPi EtU s cid140 s0 cid0 TransTEnv V P EtU s cid140 s0 cid17 Trans fEnvI cid14P cid1 g s cid140 s0 cid1 EvP EtTsU cid0 cid14Pi Et FinalfEnvI cid14g s cid17 Final TEnvVPi EtU s cid0 FinalTEnv V P EtU s cid17 Final fEnvI cid14P cid1 EvP EtTsU g s cid1 Let TransFOL FinalFOL predicates determined ﬁrstorder axioms TransSOL FinalSOL original predicates determined secondorder deﬁnition procedures We prove following result Theorem 6 Guardedcid14 s cid27 8cid140 s0TransSOLcid14 s cid140 s0 cid17 TransFOLcid14 s cid140 s0 Guardedcid14 s cid27 FinalSOLcid14 s cid17 FinalFOLcid14 s Proof Outline By induction rank conﬁguration cid14 s For rank 0 thesis trivial For rank n C 1 assume thesis holds conﬁgurations rank n thesis induction structure program considering nil cid30 TEnv V P Et U base cases 2 A conﬁguration cid14 s guarded evolution GuardedEvolcid14 s cid3 8cid140 s0Trans defD SOLcid14 s cid140 s0 cid27 Guardedcid140 s0 For conﬁgurations guarded evolution following easy consequences 0 0 8cid14 GuardedEvolcid14 s cid27 cid3 SOLcid14 s cid14 Trans GuardedEvolcid14 s cid27 s 8s0DoSOLcid14 s s0 cid17 DoFOLcid14 s s0 0 s 0 cid3 cid17 Trans FOLcid14 s cid14 0 0 s 14 The form axioms exactly conditions predicate variables T F second order deﬁnitions G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 141 83 Sufﬁcient condition guarded evolutions Theorem 7 If procedures P environment Env program cid14 8Et sGuardedTEnv V P EtU s 8sGuardedEvolcid14 s Proof Outline By induction number transitions For 0 transitions thesis induction structure program considering nil cid30 TEnv V P Et U base cases For k C 1 transitions assume thesis holds k transitions prove induction structure program considering nil cid30 TEnv V P Et U base cases making transition program resulting k transitions preserves thesis 2 It easy verify nonrecursive procedures procedures body starts atomic action wait action trivially satisfy hypothesis theorem Observe procedures 20 satisfy hypothesis procedure d p 9 deﬁnition reported n natural number proc dn n D 0 j dn cid0 1I goDown end However variants proc dn n D 0 j goDownI dn cid0 1 end proc dn n D 0 j n 0I dn cid0 1I goDown end proc dn n D 0 nil dn cid0 1I goDown end satisfy hypothesis 9 Implementation Despite fact deﬁning semantics ConGolog resorted ﬁrst secondorder logic possible come simple implementation ConGolog language Prolog In section present ConGolog interpreter Prolog lifted directly deﬁnition Final Trans Do introduced 15 This interpreter requires programs precondition axioms successor state axioms axioms initial situation expressible Prolog clauses In particular usual closed world assumption CWA initial situation Note limitation particular implementation theory 15 Exogenous actions generated simulating probabilistically asking user runtime occur monitoring environment program running 142 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 Prolog terms representing ConGolog programs follows cid15 nil program cid15 acta atomic action action term situation arguments replaced constant cid15 testc waittest c condition described cid15 seqp1 p2 sequence cid15 choicep1 p2 nondeterministic branch cid15 pickv p nondeterministic choice argument v Prolog constant atom standing ConGolog variable p programterm uses v cid15 iterp nondeterministic iteration cid15 ifc p1 p2 ifthenelse p1 thenbranch p2 elsebranch cid15 whilec p whiledo cid15 concp1 p2 concurrency cid15 prconcp1 p2 prioritized concurrency cid15 iterconcp iterated concurrency cid15 pcallpArgs procedure pArgs procedure arguments A condition c Prologterm representing atomic formulaﬂuent situation arguments replaced expression form andc1 c2 orc1 c2 negc allv c somev c obvious intended meaning In allv c somev c v Prolog constant standing logical variable c condition v The Prolog predicate trans4 final2 transcid34 do3 implement respec tively predicate Trans Final Transcid3 Do The Prolog predicate holds2 evaluate conditions tests whileloops ifthenelses ConGolog programs As Prolog predicate sub4 implements substitution subx y t t 0 means t 0 D t x y The deﬁnition Prolog predicates taken 2034 The following Prolog code Transbased ConGolog Interpreter transProgSitProg_rSit_r transactASnildoASS subnowSAAS possASS transtestCSnilS holdsCS transseqP1P2SP2rSr finalP1StransP2SP2rSr transseqP1P2SseqP1rP2Sr transP1SP1rSr transchoiceP1P2SPrSr transP1SPrSr transP2SPrSr transpickVPSPrSr subV_PPP transPPSPrSr G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 143 transiterPSseqPPiterPSr transPSPPSr transifCP1P2SPrSr holdsCS transP1SPrSr holdsnegCS transP2SPrSr transwhileCPSseqPPwhileCPSr holdsCS transPSPPSr transconcP1P2SconcP1rP2Sr transP1SP1rSr transconcP1P2SconcP1P2rSr transP2SP2rSr transprconcP1P2SprconcP1rP2Sr transP1SP1rSr transprconcP1P2SprconcP1P2rSr transP1S__ transP2SP2rSr transiterconcPSconcPPiterconcPSr transPSPPSr transpcallP_ArgsSPrSr subnowSP_ArgsP_ArgsS procP_ArgsSP transPSPrSr finalProgSit finalnilS finalseqP1P2S finalP1S finalP2S finalchoiceP1P2S finalP1S finalP2S finalpickVPS subV_PPP finalPPS finaliterPS finalifCP1P2S holdsCSfinalP1S holdsnegCSfinalP2S finalwhileCPS holdsnegCS finalPS finalconcP1P2S finalP1S finalP2S finalprconcP1P2S finalP1S finalP2S finaliterconcPS finalpcallP_Args subnowSP_ArgsP_ArgsS procP_ArgsSPfinalPS 144 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 transProgSitProg_rSit_r transPSPS transPSPrSr transPSPPSS transPPSSPrSr doProgSitSit_r doPSSr transPSPrSr finalPrSr holdsCondSit defined 34 holdsandF1F2S holdsF1S holdsF2S holdsorF1F2S holdsF1S holdsF2S holdsallVFS holdsnegsomeVnegFS holdssomeVFS subV_FFr holdsFrS holdsnegnegFS holdsFS holdsnegandF1F2S holdsornegF1negF2S holdsnegorF1F2S holdsandnegF1negF2S holdsnegallVFS holdssomeVnegFS holdsnegsomeVFS holdssomeVFS Negation failure holdsP_XsS P_Xsand__P_Xsor__P_Xsneg_P_Xsall__ P_Xssome__subnowSP_XsP_XsS P_XsS holdsnegP_XsS P_Xsand__P_Xsor__P_Xsneg_P_Xsall__ P_Xssome__subnowSP_XsP_XsS P_XsS Negation failure subConstVarTerm1Term2 defined 34 subXYTTr varT TrT subXYTTr varT TX TrY subXYTTr TX TFTs sub_listXYTsTrs TrFTrs sub_listXY sub_listXYTTsTrTrs subXYTTr sub_listXYTsTrs In implementation ConGolog application expected following parts 1 A collection clauses deﬁne ﬂuents true initial situation s0 The clauses need atomic involve arbitrary amounts computation determining entailments initial database 2 A collection clauses deﬁne predicate Possa s action situation s Typically requires clause action variable range situations G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 145 3 A collection clauses deﬁne successor state axioms ﬂuent Typically requires clause ﬂuent variables actions situations 4 A collection facts deﬁning ConGolog procedures In particular procedure p occurring program fact form procpX1 Xn body In facts formal parameters represented Prolog variables use Prolog built uniﬁcation mechanism instead substitution procedure ii body body variables occur representing formal parameters X1 Xn For simplicity consider nested procedures implementation Expressing action theories Prolog clauses places number restrictions action theories representable These restrictions force closed world assumption Prolog CWA initial situation unique assumption UNA actions objects For indepth study action theories expressible Prolog clauses refer 34 91 Example Below implementation Prolog robots lifting table sce nario discussed Section 61 The code written close speciﬁcation possi ble The inability Prolog deﬁne directly functional ﬂuent vpose s resolved introducing predicate val2 valvpose s v stands vpose s D v Two Robots Lifting Table Example Precondition axioms possgrabRobES holding_ES holdingRob_S possreleaseRobES holdingRobES possvmoveRobAmountS true Succ state axioms valvposEdoASV AvmoveRobAmount holdingRobES valvposESV1 V V1Amount 146 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 AreleaseRobE V0 valvposESV notAvmoveRobAmount holdingRobES AreleaseRobE holdingRobEdoAS AgrabRobE holdingRobES AreleaseRobE Defined Fluents tableUpS valvposend1SV1 V13 valvposend2SV2 V23 safeToLiftRobAmountTolS tableEndE1 tableEndE2 E2E1 holdingRobE1S valvposE1SV1 valvposE2SV2 V1V2TolAmount Initial state valvposend1s00 valvposend2s00 tableEndend1 tableEndend2 plus CWA holdingrob1_s0 holdingrob2_s0 Control procedures procctrlRobAmountTol seqpickeseqtesttableEndeactgrabRobe whilenegtableUpnow seqtestsafeToLiftRobAmountTolnow actvmoveRobAmount procjointLiftTable concpcallctrlrob112 pcallctrlrob212 Below ﬁnal situations returned interpreter example note interpreter ﬁlter identical situations dopcalljointLiftTables0S S dovmoverob21 dovmoverob11 dovmoverob21 dovmoverob11 dovmoverob21 dograbrob2end2 dovmoverob11 dovmoverob11 dograbrob1end1 s0 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 147 S dovmoverob21 dovmoverob11 dovmoverob21 dovmoverob11 dovmoverob21 dograbrob2end2 dovmoverob11 dovmoverob11 dograbrob1end1 s0 S dovmoverob11 dovmoverob21 dovmoverob21 dovmoverob11 dovmoverob21 dograbrob2end2 dovmoverob11 dovmoverob11 dograbrob1end1 s0 Yes 92 Correctness Prolog implementation In section prove correctness interpreter presented suitable assumptions Let C set axioms Trans Final Do plus needed encoding programs ﬁrstorder terms D domain theory To notation simple denote condition corresponding situation calculus formula cid30 situation argument replaced simply cid30 Similarly Prolog terms corresponding actions programs Our proof correctness relies following assumptions cid15 The domain theory D enforces unique assumption UNA actions objects 16 cid15 The predicate sub4 correctly implements substitution programs formulas cid15 The predicate holds2 satisﬁes following properties 1 If goal holdscid30 s free variables object terms action terms succeeds computed answer cid18 D jD 8cid30TsUcid18 8 mean universal closure 2 If goal holdscid30 s free variables object terms action terms ﬁnitely fails D jD 8cid30TsU cid15 The predicate poss2 satisﬁes following properties 1 If goal possa s free variables object terms action terms succeeds computed answer cid18 D jD 8Possa scid18 2 If goal possa s free variables object terms action terms ﬁnitely fails D jD 8Possa s cid15 The Prolog interpreter ﬂounders return goals form transcid14 s _ _ 17 nonground cid14 s 18 16 UNA enforced programs Appendix A 17 From formal point view transcid14 s _ _ shorthand auxcid14 s aux2 deﬁned auxcid14 s Vcid0 transcid14 s _ _ 18 This form ﬂoundering arises example expand cid25 programs form cid25 zcid141z ii cid142z Notably arise variants cid25 zcid30zI cid141z ii cid142z 148 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 Observe hypotheses required sub4 holds2 poss2 hold predicates deﬁned run interpreter ﬂounders nonground negative goals 34 Theorem 8 Under hypotheses following holds 1 If goal docid14 s s0 cid14 s contain variables object terms action terms succeeds computed answer cid18 C D jD 8Docid14 s s0cid18 s0cid18 contain free variables object terms action terms 2 If goal docid14 s s0 cid14 s contain variables object terms action terms ﬁnitely fails C D jD 8Docid14 s s0 To arguments apparent ﬁrst prove theorem considering procedures Then introducing procedures affects proof Without procedures Theorem 8 easy consequence Lemmas 2 3 Lemma 2 Under hypotheses following holds cid15 The predicate trans4 satisﬁes following properties 1 If goal transcid14 s cid140 s0 cid14 s contain variables object terms action terms succeeds computed answer cid18 C D jD 8Transcid14 s cid140 s0cid18 cid140cid18 s0cid18 contain free variables object terms action terms 2 If goal transcid14 s cid140 s0 cid14 s contain variables object terms action terms ﬁnitely fails C D jD 8Transcid14 s cid140 s0 cid15 The predicate final2 satisﬁes following properties 1 If goal finalcid14 s cid14 s contain variables object terms action terms succeeds computed answer cid18 C D jD 8Finalcid14 scid18 2 If goal finalcid14 s cid14 s contain variables object terms action terms ﬁnitely fails C D jD 8Finalcid14 s Proof First observe considering procedures Trans Final satisfy axioms T F Sections 4 5 We prove simultaneously 1 2 trans4 final2 induction program cid14 Here case cid14 D cid141 ii cid142 trans4 ii transcid141 s _ _ ﬁnitely fails transcid142 s cid140 ii cid142 general uniﬁer 23 cid140 cid140 1 Success If transcid141 ii cid142 s cid140 s0 succeeds computed answer cid18 transcid141 s cid140 mgucid140 cid140 1 1 s0 succeeds computed answer cid181 cid18 D cid18 0cid181 cid18 0 D 2 s0 succeeds computed 1 s0cid181 s0cid181 cid140 In case induction hypothesis C D jD 8Transcid141 s cid140 1cid181 contain free variables object terms action terms In case ii 2 s0cid182 1 s0 induction hypothesis C D jD 8Transcid141 s cid140 s0cid182 cid140 2cid182 contain free variables object terms action terms Considering answer cid182 cid18 D mgucid140 cid141 ii cid140 1 C D jD 8Transcid142 s cid140 ii cid142 2cid182 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 149 Transcid141 ii cid142 s cid140 s0 cid17 9cid13 cid140 D cid13 ii cid142 Transcid141 s cid13 s0 _ 9cid13 cid140 D cid141 ii cid13 Transcid142 s cid13 s0 9cid16 s00Transcid141 s cid16 s00 3 cid18 deﬁned cases thesis Failure If transcid141 ii cid142 s cid140 s0 ﬁnitely fails 1 cid140 uniﬁes cid140 cid140 1 s0 ﬁnitely fails 1 s0 cid140 D cid140 induction hypothesis C D jD 8Transcid141 s cid140 ii transcid141 s _ _ succeeds C D jD 9cid140 1Transcid141 s cid140 1 s0 1 2 s0 ﬁnitely fails 2 transcid142 s cid140 2 s0 cid140 D cid141 ii cid140 cid140 induction hypothesis C D jD 8Transcid142 s cid140 2 cid140 uniﬁes cid141 ii cid140 ii cid142 transcid141 s cid140 ii cid142 1 s0 Considering 3 UNA object actions program terms thesis 2 2 1 1 Lemma 3 Under hypotheses following holds 1 If goal transcid3cid14 s cid140 s0 cid14 s contain variables object terms action terms succeeds computed answer cid18 C D jD 8Transcid3cid14 s cid140 s0cid18 cid140cid18 s0cid18 contain free variables object terms action terms 2 If goal transcid3cid14 s cid140 s0 cid14 s contain variables object terms action terms ﬁnitely fails C D jD 8Transcid3cid14 s cid140 s0 Proof Using Lemma 2 Success Then exists successful SLDNFderivation 23 Such derivation contain ﬁnite number k selected literals form transcid3cid141 s1 cid142 s2 The thesis proven induction number k Failure Then exists ﬁnitely failed SLDNFtree 23 formed failed SLDNF derivations contains ﬁnite number selected literals form transcid3cid141 s1 cid142 s2 The thesis proven induction maximal number selected literals form transcid3cid141 s1 cid142 s2 contained SLDNFderivations forming tree 2 With procedures Since nested procedures Prolog implementation avoid carrying procedure environment Hence simplify constraints procedures deﬁnition Trans Final Section 7 respectively 0 0 T P Et s cid14 F P Et s cid17 F s cid17 T cid0 EvP EtTsU s cid14P cid0 EvP cid14P EtTsU s cid14 cid1 cid1 0 0 s To prove soundness interpreter presence procedures need redo proof Lemma 2 We prove Lemma 2 follows Assume moment Trans Final satisfy axioms T F Sections 4 5 plus following ones cid0 TransP Et s cid140 s0 cid17 Trans cid0 EvP FinalP Et s cid17 Final Et TsU s cid14P EvP EtTsU s cid140 s0 cid14P cid1 cid1 150 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 Then follow line proof given However need deal additional complication procedure expansions program simpler anymore To end observe terminating SLDNF derivation contains ﬁnite number selected literals form transP Et s1 cid142 s2 finalP Et s1 Hence prove lemma following nested inductions cid15 Induction rank successful SLDNFderivationsﬁnitely failed SLDNFtrees depth nesting auxiliary ﬁnitely failed SLDNFtrees 23 cid15 Induction number selected literals form transP Et s1 cid142 s2 finalP Et s1 occurring successful SLDNFderivation success Induc tion maximal number selected literals form transP Et s1 cid142 s2 finalP Et s1 contained SLDNFderivations forming ﬁnitely failed SLDNFtree failure cid15 Induction structure program Now come assumption Trans Final In fact Final closed constraints F deﬁnition actually satisfy axioms F Sections 4 5 However Trans closed constraints T deﬁnition satisfy assumption general However desired result noticing equivalences assumed Trans form conservative extension 37 domain theory D plus axioms needed encoding programs ﬁrstorder terms appealing following general result Proposition 1 Let cid0 consistent theory cid0 fcid8g conservative extension cid0 cid8 closed ﬁrstorder formula P predicate occurring cid8 cid0 Then tuple terms Et 1 cid0 fcid8g jD 8P Et implies cid0 jD 88ZTcid8P Z 2 cid0 fcid8g jD 8P Et implies cid0 jD 88ZTcid8P Z cid27 ZEtU cid27 ZEtU Proof 1 contradiction Suppose exists model M cid0 variable assignment Z M cid27 6jD ZEt Now cid27 cid27 Z D R relation R M cid27 jD cid8P consider model M 0 cid0 obtained M changing interpretation P P M0 D R Then M 0 jD cid8 M 0 cid27 6jD P Et contradicts cid0 fcid8g jD 8P Et 2 contradiction Suppose exists model M cid0 variable assignment cid27 cid27 ZEtU Then variable assignment cid27 0 obtained cid27 Z M cid27 0 jD ZEt Let M 0 expansion M M cid27 0 jD ZEt M 0 cid27 jD P Et M cid27 jD 8ZTcid8P Z putting cid27 Z D Q M cid27 0 jD cid8P M 0 jD cid8 Then Q D P M0 contradicts cid0 fcid8g jD 8P Et 2 Intuitively Proposition 1 says constrain relation P ﬁrstorder statement tuple forced relation similarly relation obtained secondorder version statement Thus Transcid14 s cid140 s0 holds ﬁrstorder version Trans hold secondorder version G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 151 10 Discussion With procedural richness nondeterminism concurrency recursive procedures priorities important lose sight logical framework ConGolog programming language execution like planning depends reasoning actions Thus crucial ConGolog program declarative precondition axioms successor state axioms axioms characterizing initial state This central language differs superﬁcially similar procedural languages A ConGolog program deﬁnition Do foundational axioms situation calculus formal logical theory possible behaviors agent given environment And theory explicitly ConGolog interpreter In contrast interpreter ordinary procedural language use semantics explicitly Standard semantic accounts programming languages require initial state completely speciﬁed account agent act knowing environment Our account accommodates domaindependent primitive actions allows interactions agent environment modeledactions change environment way affects actions later occur 8 As mentioned important motivation development ConGolog need tools implement intelligent agent programs reactive sense reconsider plans response signiﬁcant changes environment Thus work related earlier research resourcebounded deliberative architectures 2 IRMA 30 PRS agent programming languages extent based kind architectures AGENT0 38 AgentSpeakL 29 3APL 16 One difference ConGolog domain dynamics speciﬁed declaratively speciﬁcation automatically program execution need program updating world model actions performed On hand plan selection generation speciﬁed rules coded program produces complex programs overhead Finally agents programmed ConGolog understood executing programs albeit smart way simple operational semantics architectures like IRMA PRS languages like AGENT0 AgentSpeakL 3APL complex execution models Other programming languages share features ConGolog The agent programming language Concurrent MetateM 11 supports concurrency uses temporal logic specify behavior agents Bonner Kifer 3 proposed logical formalism specify concurrent database transactions Also related concurrent constraint languages CCP 35 HCC 14 support incompletely speciﬁed information states concurrency But unlike ConGolog languages generally restrict kinds constraints allowed order entailment easy compute In ConGolog action theory determines states updated Also constraint languages control somewhat deemphasized van Eijk et al 10 proposed agent language partly inspired CCP 152 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 Fig 1 The ConGolog toolkits graphical viewer The simple Prolog implementation ConGolog interpreter described Section 8 core toolkit developed implementing ConGolog applications The interpreter toolkit similar described uses convenient syntax performs error detection tracing facilities debugging The toolkit includes module progressing initial state database To understand role component ﬁrst note basic method implementation action theories determining condition holds given situation evaluate holdscid30 doa1 doan S0 perform regression condition obtain new condition mentions initial situation query initial situation database determine new condition holds But regressing condition way initial situation inefﬁcient program running actions performed If program willing commit particular sequence actions possible progress initial situation theory new initial situation theory representing state affairs sequence actions 19 Subsequent queries efﬁciently evaluated respect new initial situation database The progression module performs updating initial situation database The toolkit includes graphical viewer Fig 1 debugging ConGolog programs delivering process modeling applications The tool implemented TclTk displays sequence actions performed ConGolog program value ﬂuents resulting situation situation path The 19 In general progression initial situation database ﬁrstorder representable initial situation completely known assuming implementation progression ﬁrstorder representable computed efﬁciently 22 details G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 153 program stepped exogenous events generated manually random according given distribution The manner state information displayed speciﬁed easily customized required Finally highlevel Golog Domain Speciﬁcation language GDL similar Gelfond Lifschitzs A 12 developed The toolkit includes GDL compiler takes domain speciﬁcation GDL generates successor state axioms produces Prolog implementation resulting domain theory ConGolog applications Lespérance et al 19 implemented reactive highlevel control module mobile robot ConGolog The robot performs maildelivery task The ConGolog control program involves set prioritized interrupts react events robot arriving customers mailbox failing mailbox obstacles new shipment orders varying degrees urgency received The ConGolog controller interfaced navigation software successfully tested RWI B12 mobile robot Work ConGolog model multiagent systems 36 In case domain theory includes ﬂuents model beliefs goals systems agents adapting possibleworld semantics mental states situation calculus A ConGolog program specify complex behavior agents A simple multiagent meeting scheduling example speciﬁed 36 ConGologbased tools specifying verifying complex multiagent systems investigated Finally 7 transition semantics developed paper adapted execution interleaved program interpretation order accommodate sensing actions actions effect change world provide information agent runtime In summary seen given basic action theory describing initial state preconditions effects collection primitive actions possible combine complex actions highlevel agent control The semantics resulting language end deriving directly underlying primitive actions In sense solution frame problem provided successor state axioms primitive actions extended cover complex actions ConGolog So ConGolog viewed action theory supports complex actions speciﬁcation language implementation language ways There areas future research Among mention handling nontermination developing accounts program correctness fairness liveness appropriate controllers expected operate indeﬁnitely 9 giving agents control nondeterministic choices characterizes Dobased semantics terminating programs incorporating utilities nondeterministic choices execution maximize expected beneﬁt Acknowledgements This research funded National Science Engineering Research Council Canada We thank Koen Hindriks interesting discussions work 154 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 pointing error earlier version situations appearing primitive actions tests We thank David Tremaine alerting problem earlier way handling exogenous events semantics We thank David McAllester pointing subtleties arise extending Golog ConGolog boolean procedures Finally thank referees comments Appendix A Programs terms In section develop encoding programs ﬁrstorder terms Although care required introducing constants denoting variables deﬁning substitution explicitly language pose major problem 18 introduction problems techniques area We add sorts Sit Obj Act Situation Calculus following new sorts Idx PseudoSit PseudoAct PseudoObj PseudoForm ENV PROG Intuitively elements Idx denote natural numbers building indexing functions Elements PseudoAct PseudoObj PseudoSit PseudoForm syntactic devices denote respectively actions objects situations formulas programs Elements ENV denote environments sets procedure deﬁnitions And ﬁnally elements PROG denote programs considered simply syntactic objects A1 Sort Idx We introduce constant 0 sort Idx function succ Idx Idx For enforce following unique axioms succi 6D 0 succi D succi0 cid27 D i0 We deﬁne predicate Idx V Idx Idxi cid17 8XT cid27 XiU stands conjunction universal closure X0 Xi cid27 Xsucci Finally assume following domain closure axiom sort Idx 8iIdxi A2 Sorts PseudoSit PseudoObj PseudoAct The languages PseudoSit PseudoObj PseudoAct follows cid15 A constant Now V PseudoSit cid15 A function nameOfSort Sort PseudoSort Sort D Obj Act We use notation TTxUU denote nameOfSortx leaving Sort implicit G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 155 cid15 A function varSort Idx PseudoSort Sort D Obj Act We terms form varSorti pseudovariables use notation zi x y z denote varSorti leaving Sort implicit cid15 A function f PseudoSort1 cid2 cid1 cid1 cid1 cid2 PseudoSortn PseudoSortnC1 ﬂuent nonﬂuent function f sort Sort1 cid2 cid1 cid1 cid1 cid2 Sortn SortnC1 Sorti D Obj Act Sit original language note n D 0 f constant We deﬁne predicates PseudoSit V PseudoSit PseudoObj V PseudoObj PseudoAct V PseudoAct respectively PseudoSitx cid17 8PSit PObj PActT cid27 PSitxU PseudoObjx cid17 8PSit PObj PActT cid27 PObjxU PseudoActx cid17 8PSit PObj PActT cid27 PActxU stands conjunction universal closure PSitNow PSortnameOfSortx Sort D Obj Act Sort D Obj Act PSortx1 cid1 cid1 cid1 PSortxn cid27 PSortfx1 xn PSortzi f We assume following domain closure axioms sorts PseudoSit PseudoObj PseudoAct 8xPseudoSitx 8xPseudoObjx 8xPseudoActx We enforce unique axioms functions g g0 arity including constants introduced gx1 xn 6D g0y1 ym gx1 xn D gy1 yn cid27 x1 D y1 cid1 cid1 cid1 xn D yn Observe unique axioms impose nameOfx D nameOfy cid27 x D y domain elements denoted x y elements Act Obj Next want relate pseudosituations pseudoobjects pseudoactions real situations object actions In fact want relate terms sort PseudoObj PseudoAct real object actions closed ones 156 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 pseudo variable zi occur To formalize notion closedness introduce predicate Closed V PseudoSort Sort D Sit Obj Act characterized following assertions 20 ClosedNow ClosednameOfx Closedzi Closedfx1 xn cid17 Closedx1 cid1 cid1 cid1 Closedxn f Closed terms sort PseudoObj PseudoAct related real objects actions means function decode V PseudoSort cid2 Sit Sort Sort D Sit Obj Act We use notation xTsU denote decodex s Such function characterized following assertions decodeNow s D s decodenameOfx s D x decodefx1 xn s D f decodex1 s decodexn s f A3 Sort PseudoForm Next introduce pseudoformulas tests Speciﬁcally introduce cid15 A function p PseudoSort1 cid2 cid1 cid1 cid1 cid2 PseudoSortn PseudoForm nonﬂu entﬂuent predicate p original language including new predicates introduced section cid15 A function PseudoForm cid2 PseudoForm PseudoForm We use notation cid15 A function PseudoForm PseudoForm We use notation cid26 denote cid261 cid262 denote andcid261 cid262 notcid26 cid15 A function someSort PseudoSort cid2 PseudoForm PseudoForm PseudoSort D PseudoObj PseudoAct We use notation 9zi cid26 denote somevarSorti cid26 leaving Sort implicit We deﬁne predicate PseudoForm V PseudoForm PseudoFormcid26 cid17 8PFormT cid27 PFormcid26U stands conjunction universal closure PFormpx1 xn p PFormcid261 PFormcid262 cid27 PFormcid261 cid262 PFormcid26 cid27 PFormcid26 PFormcid26 cid27 PForm9zi cid26 20 We following theory characterizing complete sense partitions elements PseudoSort closed G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 157 We assume following domain closure axiom sort PseudoForm 8cid26PseudoFormcid26 We enforce unique axioms pseudoformulas functions g g0 arity introduced gx1 xn 6D g0y1 ym gx1 xn D gy1 yn cid27 x1 D y1 cid1 cid1 cid1 xn D yn Next formalize notion substitution We introduce function sub PseudoSort cid2 PseudoSort cid2 PseudoSort 0 PseudoSort 0 Sort D Obj Act Sort 0 D Sit Obj Act We use notation t x y denote subx y t Such function character ized following assertions D nameOft Nowx D Now y nameOftx y D y zi x x 6D zi cid27 zi y ft1 tnx y zi y D zi D ft1 x y tn x y f We extend function sub pseudoformulas argument follows x y p x y tn cid262x y D pt1 pt1 tnx y D cid261x cid261 cid262x y y cid26x D cid26x y y D 9zi cid26 9zi cid26zi y x 6D zi cid27 9zi cid26x y D 9zi cid26x y Next extend predicate Closed pseudoformulas natural way Closedpx1 xn cid17 Closedx1 cid1 cid1 cid1 Closedxn Closedcid261 cid262 cid17 Closedcid261 Closedcid262 Closedcid26 cid17 Closedcid261 Closed9zi cid26 cid17 8yClosedcid26zi nameOfy p We relate closed pseudoformulas real formulas introducing predicate Holds V PseudoForm cid2 Sit characterized following assertions Holdspx1 xn s cid17 pdecodex1 s decodexn s p Holdscid261 cid262 s cid17 Holdscid261 s Holdscid262 s Holdscid26 s cid17 Holdscid26 s Holds9zcid26 s cid17 9yHoldscid26z nameOfy s y equation variable appear cid26 We use notation cid30TsU denote Holdscid30 s 158 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 A4 Sorts PROG ENV Now ready introduce programs Speciﬁcally introduce cid15 A constant nil V PROG cid15 A function act PseudoAct PROG As notation write simply denote acta confusion arise cid15 A function test PseudoForm PROG We use notation cid26 denote testcid26 cid15 A function seq PROG cid2 PROG PROG We use notation cid141I cid142 denote seqcid141 cid142 cid15 A function choice PROG cid2 PROG PROG We use notation cid141 j cid142 denote choicecid141 cid142 cid15 A function iter PROG PROG We use notation cid14cid3 denote itercid14 cid15 Two functions pickSort PseudoSort cid2 PROG PROG PseudoSort PseudoObj PseudoAct We use notation cid25 zicid14 denote pickSortvarSorti cid14 leaving Sort implicit cid15 A function PseudoForm cid2 PROG cid2 PROG PROG We use notation cid26 cid141 cid142 denote ifcid26 cid141 cid142 cid15 A function PseudoForm cid2 PROG PROG We use notation cid26 cid14 denote whilecid26 cid14 cid15 A function conc PROG cid2 PROG PROG We use notation cid141 k cid142 denote conccid141 cid142 cid15 A function prconc PROGcid2PROG PROG We use notation cid141 ii cid142 denote prconccid141 cid142 cid15 A function iterconc PROG PROG We use notation cid14jj denote iterconccid14 To deal procedures need introduce notion environment program We introduce cid15 A ﬁnite number functions P PseudoSort1 cid2 cid1 cid1 cid1 cid2 PseudoSortn PROG PseudoSorti PseudoObj PseudoAct These functions going procedure calls cid15 A function proc PROGcid2 PROG PROG This function build procedure deﬁnitions force ﬁrst argument form Pzi1 zin z1 zn denote formal parameters deﬁned procedure We use notation proc Pz1 zn cid14 end denote procPz1 zn cid14 cid15 A constant V ENV denoting environment cid15 A function addproc ENV cid2 PROG ENV We restrict programs allowed appear second argument procedure deﬁnitions We use notation EI proc PEz cid14 end denote addprocE proc PEz cid14 end cid15 A function pblock ENV cid2 PROG PROG We use notation fEI cid14g denote pblockE cid14 cid15 A function c_call ENV cid2 PROG PROG We restrict programs allowed appear second argument procedure calls We use notation TE V PEtU denote c_callE PEt G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 159 We introduce predicate defined V PROG cid2 ENV meaning procedure deﬁned environment It speciﬁed definedc E cid17 8DT cid27 Dc EU stands conjunction universal closure DPEx I proc PEy cid14 end Dc E 0 cid27 Dc E 0I d Observe procedures P deﬁned environment E parameters procedure applied play role determining procedure deﬁned Now deﬁne predicate Prog V PROG predicate Env V ENV Progcid14 cid17 8PPROG PENV T cid27 PPROGcid14U EnvE cid17 8PPROG PENV T cid27 PENV EU stands universal closure PPROGnil PPROGacta pseudoaction PPROGcid26 cid26 pseudoformula PPROGcid141 PPROGcid142 cid27 PPROGcid141I cid142 PPROGcid141 PPROGcid142 cid27 PPROGcid141 j cid142 PPROGcid14 cid27 PPROGcid14cid3 PPROGcid14 cid27 PPROGcid25 zicid14 PPROGcid141 PPROGcid142 cid27 PPROGif cid26 cid141 cid142 PPROGcid14 cid27 PPROGwhile cid26 cid14 PPROGcid141 PPROGcid142 cid27 PPROGcid141 k cid142 PPROGcid141 PPROGcid142 cid27 PPROGcid141 ii cid142 PPROGcid14 cid27 PPROGcid14jj P PPROGPx1 xn PENV E PPROGcid14 cid27 PPROGfEI cid14g PENV E definedPEz E cid27 PPROGTE V Px1 xnU PENV PENV E PPROGcid14 definedPEz E zih 6D zik cid27 n hkD1 PENV EI proc Pzi1 zin cid14 end 160 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 We assume following domain closure axioms sorts PROG ENV 8cid14Progcid14 8EEnvE We enforce unique axioms programs environments functions g g0 arity introduced gx1 xn 6D g0y1 ym gx1 xn D gy1 yn cid27 x1 D y1 cid1 cid1 cid1 xn D yn We extend predicate Closed PROG induction structure program terms obvious way consider closed programs occurrences pseudovariables zi bound cid25 formal parameter procedure Only closed programs considered legal We introduce function resolve ENV cid2 PROG cid2 PROG PROG associate procedure calls environment resolve Namely given procedure P deﬁned environment E resolveE PEt cid14 denoted cid14PEt TEVPEtU suitably replaces PEt c_callE PEt order obtain static scope procedures It obvious function extended resolve sets procedure calls procedures deﬁned environment E Formally function satisﬁes following assertions nilPEx TEVPExU D nil aPEx TEVPExU D cid26PEx TEVPExU D cid26 TEVPExU TEVPExU cid141I cid142PEx cid141 j cid142PEx cid25 zi cid14PEx TEVPExUI cid142PEx TEVPExU j cid142PEx TEVPExU D cid141PEx TEVPExU D cid141PEx TEVPExU D cid25 zicid14PEx TEVPExU cid0 cid1cid3 cid14PEx cid14cid3PEx TEVPExU D TEVPExU cid26 cid141 cid142PEx TEVPExU D cid26 cid141PEx TEVPExU cid142PEx TEVPExU cid26 cid14PEx cid141 k cid142PEx TEVPExU TEVPExU D cid26 cid14PEx TEVPExU k cid142PEx TEVPExU ii cid142PEx TEVPExU D cid141PEx TEVPExU D cid141PEx TEVPExU TEVPExU cid141 ii cid142PEx PEx TEVPExU D cid14PEx cid14 jj TEVPExU jj G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 161 PExPEx QEtPEx TEVPExU D TE V PExU TEVPExU D QEt 8 fE 0I cid14gPEx TEVPExU D procedure QEt different PEx fE 0I cid14g cid8 E 0I cid14PEx TEVPExU procedure P redeﬁned E 0 cid9 TE 0 V QEtUPEx TEVPExU D TE 0 V QEtU procedure QEt environment E 0 Finally extend function sub PROG argument induction structure program terms natural way considering cid25 binding construct pseudovariables substitutions environments sub substituting formal parameters actual parameters contextualized procedure calls deal cid25 We introduce function c_body PROG cid2 ENV PROG return body procedures Namely c_bodyPEx E returns body procedure P E formal parameters substituted actual parameters Ex Formally function satisﬁes following assertions c_bodyPEx EI proc PEy cid14 end D cid14 c_bodyPEx EI proc QEy cid14 end D c_bodyPEx E Ey Ex Q 6D P A5 Consistency preservation The encoding presented preserves consistency stated following theorem Theorem A1 Let H axioms deﬁning encoding Then model action theory D involving sorts Sit Act Obj extended model H D involving additional sorts Idx PseudoSit PseudoAct PseudoObj PseudoForm ENV PROG Proof It sufﬁces observe new sort Idx PROG H contains cid15 A secondorder axiom explicitly deﬁnes predicate inductively character izes elements sort cid15 An axiom closes domain new sort respect characterizing predicate cid15 Unique axioms extend interpretation D new sort induction structure elements imposed characterizing axiom cid15 Axioms characterize predicates functions Closed decode sub Holds induction structure elements sort Hence given model M action theory D straightforward introduce domains new sorts satisfy characterizing predicate domain closure axioms unique axioms sort proceeding induction structure elements forced characterizing predicate establishing extension newly deﬁned predicatesfunctions sort 2 162 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 Appendix B Proof Theorem 1Equivalence Dos Golog programs In section prove Theorem 1 equivalence original deﬁnition Do new given paper general language includes procedures To simplify presentation proof use symbols denote terms elements domain interpretation meaning clear context B1 Alternative deﬁnitions Trans Final For proving following results convenient reformulate deﬁnitions Trans Final cid15 Transcid14 s cid140 s0 cid17 8T T cid27 T cid14 s cid140 s0U stands conjunction universal closure following implications PossaTsU s cid27 T s nil doaTsU s cid30TsU cid27 T cid30 s nil s 0I cid13 s 0 cid27 T cid14I cid13 s cid14 s Finalcid13 s T cid14 s cid140 s0 cid27 T cid13 I cid14 s cid140 s0 0 0 0 T cid14 s cid14 0 0 0 s s cid27 T cid14 j cid13 s cid14 T cid14 s cid14 T cid14 s cid140 s0 cid27 T cid13 j cid14 s cid140 s0 x s cid140 s0 cid27 T cid25vcid14 s cid140 s0 T cid14v T cid14 s cid140 s0 cid27 T cid14cid3 s cid140I cid14cid3 s0 cid0 cid14Pi Et TEnvVPi EtU s cid140 s0 T cid0 EvP g s cid140 s0 fEnvI cid14P EtTsU cid1 cid1 T cid27 T fEnvI cid14g s cid140 s0 cid27 T TEnv V P EtU s cid140 s0 cid15 Finalcid14 s cid17 8FT cid27 F cid14 sU stands conjunction universal closure following implications True cid27 F nil s F cid14 s F cid13 s cid27 F cid14I cid13 s F cid14 s cid27 F cid14 j cid13 s F cid14 s cid27 F cid13 j cid14 s F cid14v x s cid27 F cid25vcid14 s True cid27 F cid14 cid3 cid0 cid14Pi Et TEnvVPi EtU s F cid0 EvP fEnvI cid14P Et TsU s F cid1 cid1 s cid27 F fEnvI cid14g s cid27 F TEnv V P EtU s G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 163 Theorem B1 With respect Golog programs deﬁnitions equivalent ones given Section 7 paper Proof To prove equivalence consider ﬁrst following general results direct consequence TarskiKnaster ﬁxpoint theorem 40 If SEx cid17 8ZTT8Eycid8Z Ey cid27 ZEyU cid27 ZExU cid8Z Ey monotonic 8Z1 Z2T8EyZ1Ey cid27 Z2EyU cid27 T8Eycid8Z1 Ey cid27 cid8Z2 EyU following consequences 21 SEx cid17 cid8S Ex SEx cid17 8ZTT8EyZEy cid17 cid8Z EyU cid27 ZExU B1 B2 B3 Now easy deﬁnition Trans Final rewritten B1 resulting cid8 monotonic particular syntactically monotonic predicate variables T F occur scope negation Thus TarskiKnaster ﬁxpoint theorem deﬁnitions rewritten form B3 Once form easy Golog programs equivalent introduced Section 7 2 B2 Do1 equivalent Do2 Let Do1 original deﬁnition Do 20 extended Do1nil s s0 defD s0 D s defD DofEnvI P Etg s s0 Do2 new deﬁnition DoTEnv V P Et U s s0 terms Trans Final Also allow procedure calls procedure deﬁnitions given Lemma B1 For model M C exist cid141 s1 cid14n sn M jD Transcid14i si cid14iC1 siC1 D 1 n cid0 1 M jD Transcid3cid141 s1 cid14n sn Proof By induction n If n D 1 M jD Transcid3cid141 s1 cid141 s1 deﬁnition Transcid3 If n 1 induction hypothesis M jD Transcid3cid142 s2 cid14n sn M jD Transcid141 s1 cid142 s2 M jD Transcid3cid141 s1 cid14n sn deﬁnition Transcid3 Let R relation formed tuples cid141 s1 cid14n sn exist cid141 s1 cid14n sn M jD Transcid14i si cid14iC1 siC1 D 1 n cid0 1 It easy verify cid14 s cid14 s cid14 s 2 R ii cid14 s cid140 s0 cid1400 s00 M jD Transcid14 s cid140 s0 cid140 s0 cid1400 s00 2 R implies cid14 s cid1400 s00 2 R 2 21 In fact B2 mentioned passing proof 164 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 Lemma B2 For model M C M jD Do1cid14 s s0 implies exist cid141 s1 cid14n sn cid141 D cid14 s1 D s sn D s0 M jD Finalcid14n sn M jD Transcid14i si cid14iC1 siC1 D 1 n cid0 1 Proof We prove lemma induction structure program We details signiﬁcant cases 1 atomic action M jD Do1a s s0 iff M jD PossaTsU s s0 D doaTsU s Then M jD Transa s nil doaTsU s thesis 2 cid14I cid13 sequence M jD Do1cid14I cid13 s s0 iff M jD Do1cid14 s s00 M jD Do1cid13 s00 s0 Then induction hypothesis exist cid141 s1 cid14k sk cid141 D cid14 s1 D s sk D s00 M jD Finalcid14k sk M jD Transcid14i si cid14iC1 si D 1 k cid0 1 ii exist cid13k sk cid13n sn cid131 D cid13 sk D s00 sn D s0 M jD Finalcid13n sn M jD Transcid13i si cid13iC1 si D k n cid0 1 Since Trans closed assertions deﬁnition M jD Transcid14i si cid14iC1 siC1 implies M jD Transcid14iI cid13 si cid14iC1I cid13 siC1 Moreover M jD Finalcid14k sk M jD Transcid13k sk cid13kC1 skC1 implies M jD Transcid14kI cid13k sk cid13kC1 skC1 Similarly case k D n Final closed assertions deﬁnition M jD Finalcid14k sk M jD Finalcid13k sk implies M jD Finalcid14kI cid13k sk Hence thesis 3 cid14cid3 iteration M jD Do1cid14cid3 s s0 iff M jD 8P T cid27 P s s0U stand following assertions 8sP s s ii 8s s0 s00Do1cid14 s s00 P s00 s0 cid27 P s s0 Consider relation Q deﬁned set pairs s s0 exist cid141 s1 cid14n sn cid141 D cid14cid3 s1 D s sn D s0 M jD Finalcid14n sn M jD Transcid14i si cid14iC1 si D 1 n cid0 1 To prove thesis sufﬁcient Q satisﬁes assertions ii Let cid141 D cid14n D cid14cid3 s1 D sn D s M jD Finalcid14cid3 s follows s s s 2 Q ii By ﬁrst induction hypothesis induction structure program M jD Do1cid14 s s00 implies exist cid141 s1 cid14k sk cid141 D cid14 s1 D s sk D s00 M jD Finalcid14k sk M jD Transcid14i si cid14iC1 siC1 D 1 k cid0 1 This implies M jD Transcid14iI cid14cid3 si cid14iC1I cid14cid3 siC1 V 2 k cid0 1 Moreover M jD Transcid14cid3 s1 cid142I cid14cid3 s2 By second induction hypothesis rule induction P assume exist cid13k sk cid13n sn cid13k D cid14cid3 sk D s00 sn D s0 M jD Finalcid13n sn M jD Transcid13i si cid13iC1 siC1 D k n cid0 1 Now observe Finalcid14k sk Transcid13k sk cid13kC1 skC1 implies Transcid14kI cid13k sk cid13kC1 skC1 Thus ii holds Q Hence thesis 4 fEnvI cid14g procedures M jD Do1fEnvI cid14g s s0 iff M jD 8P1 Pn Tcid8 cid27 Do1cid14 s s0U G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 165 cid8 D n iD1 8Ex s s 0 Do1cid14i 0 Evi Ex s s cid27 Pi Ex s s 0 To thesis sufﬁces prove case M jD 8P1 Pn Tcid8 cid27 Pi Ex s s0U B4 B5 apply induction argument structure program considering base cases nil cid30 P Et Consider relations Qi deﬁned set tuples Ex s s0 exist cid141 s1 cid14n sn cid141 D fEnvI PiExg 22 s1 D s sn D s0 M jD Finalcid14n sn M jD Transcid14i si cid14iC1 si D 1 n cid0 1 To prove thesis sufﬁcient Qi satisﬁes closed assertion B4 defD Pi Ex s s0 Pi free predicate variable Recall Do1Pi Ex s s0 jD Do1Pi Ex s s0 This means variable assignment cid27 M cid27 P1Pn Q1Qn implies Ex s s0 2 Qi exist cid141 s1 cid14n sn cid141 D fEnvI PiExg s1 D s sn D s0 M jD Finalcid14n sn M jD Transcid14i si cid14iC1 si D 1 n cid0 1 Hence induction structure program considering base cases nil Evi Ex s s0 implies cid30 P Et M cid27 P1Pn Q1Qn Evi g s1 D s sn D s0 M jD Finalcid14n sn exist cid141 s1 cid14n sn cid141 D fEnvI cid14i Ex M jD Transcid14i si cid14iC1 si D 1 n cid0 1 Now considering M jD g s1 cid142 s2 implies M jD TransTEnv V Pi ExU s1 cid142 s2 implies TransfEnvI cid14i M jD TransfEnvI PiExg s1 cid142 s2 Ex s s0 2 Qi 2 jD Do1cid14i Evi Ex Lemma B3 For Golog programs cid14 situations s Finalcid14 s cid27 Do1cid14 s s Proof It easy Do1cid14 s s closed respect implications inductive deﬁnition Final 2 Lemma B4 For Golog programs cid14 cid140 situations s s0 Transcid14 s cid140 s0 Do1cid140 s0 s00 cid27 Do1cid14 s s00 Proof The property want prove rewritten follows Transcid14 s cid140 s0 cid27 cid8cid14 s cid140 s0 cid8cid14 s cid140 s0 defD 8s00Do1cid140 s0 s00 cid27 Do1cid14 s s00 22 To precise variables xi Pi Ex read nameOfxi converting situation calculus objectsactions variables suitable program terms Appendix A 166 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 Hence sufﬁcient cid8 closed implications inductively deﬁne Trans Again details signiﬁcant cases 1 Implication primitive actions We PossaTsU s cid27 cid8aTsU s nil doaTsU s PossaTsU s cid27 8s00Do1nil doaTsU s s00 cid27 Do1a s s00 Since Do1nil s s0 holds deﬁnition Do1 defD s0 D s reduces PossaTsU s cid27 Do1a s doa s 2 First implication sequences We cid8cid14 s cid140 s0 cid27 cid8cid14I cid13 s cid140 s0 8s00TDo1cid140 s0 s00 cid27 Do1cid14 s s00U cid27 8s00Do1cid140I cid13 s0 s00 cid27 Do1cid14I cid13 s s00 By contradiction Suppose model M M jD 8s00Do1cid140 s0 s00 cid27 Do1cid14 s s00 M jD Do1cid140I cid13 s0 sc M jD Do1cid14I cid13 s sc sc This means M jD Do1cid140 s0 st Do1cid13 st sc st M jD 8tDo1cid14 s t _ Do1cid13 t sc Since M jD Do1cid140 s0 st implies M jD Do1cid14 s st contradiction 3 Second implication sequences We Finalcid14 s cid8cid13 s cid13 0 s0 cid27 cid8cid14I cid13 s cid13 0 s0 Finalcid14 s 8s00TDo1cid13 0 s0 s00 cid27 Do1cid13 s s00U cid27 00 8s Do1cid13 0 0 s s 00 cid27 Do1cid14I cid13 s s 00 By contradiction Suppose model M M jD Finalcid14 s M jD 8s00Do1cid13 0 s0 s00 cid27 Do1cid13 s s00 M jD Do1cid13 0 s0 scthus M jD Do1cid13 s scand M jD Do1cid14I cid13 s sc sc The means M jD 8tDo1cid14 s t _ Do1cid13 t sc Since M jD Finalcid14 s implies M jD Do1cid14 s s Lemma B3 M jD Do1cid13 s sc contradiction 0 0 00 00 8s Do1cid14 4 Implication iteration We cid8cid14 s cid140 s0 cid27 cid8cid14cid3 s cid140I cid14cid3 s0 00 s s cid3 0I cid14 TDo1cid14 00 8s cid27 Do1cid14 s s 0 cid27 Do1cid14 s U cid27 cid3 s s By contradiction Suppose model M M jD 8s00Do1cid140 s0 s00 cid27 Do1cid14 s s00 M jD Do1cid140I cid14cid3 s0 sc M jD Do1cid14cid3 s sc sc Since M jD Do1cid140I cid14cid3 s0 sc implies M jD Do1cid140 s0 st M jD Do1cid14 s st M jD Do1cid14cid3 st sc M jD Do1cid14 s st M jD Do1cid14cid3 st sc imply M jD Do1cid14cid3 s sc contradiction s 00 00 5 Implication contextualized procedure calls We cid0cid8 cid8 EnvI cid14i cid9 s cid14 0 0 s cid1 Evi EtTsU cid27 cid8TEnv V Pi EtU s cid14 0 0 s It sufﬁces prove cid9 cid0cid8 s s0 EnvI cid14i Do1 Evi EtTsU cid1 cid27 Do1TEnv V Pi EtU s s0 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 167 We proceed contradiction Suppose exists model M g s s0 M jD Do1TEnvI PiEtU s s0 Et s M jD Do1fEnvI cid14i s0 That Evi EtTsU Evi Et TsU s s0 M jD 8P1 Pn M jD 9P1 Pn Tcid9 Pi EtTsU s s cid2 cid9 cid27 Do1 cid0 cid14i cid1cid3 U 0 V n iD1 B7 s s0 cid27 Pi Exi s s0U Then B7 cid9 D T exists variable assignment M cid27 jD cid9 M cid27 jD Pi EtTsU s s0 Evi EtTsU s s0 contradicts B6 implies M cid27 jD Do1cid14 8Exi s s0Do1cid14i Evi Exi 6 Implication programs environment We B6 cid0 cid8 cid14Pi Et TEnvVPi EtU s cid140 s0 cid1 cid27 cid8fEnvI cid14g s cid140 s0 It sufﬁces prove cid0 Do1 cid14Pi Et TEnvVPi EtU s s0 cid1 cid27 Do1fEnvI cid14g s s0 This induction structure program cid14 considering nil cid30 TEnv0 V P EtU base cases programs use Env 2 Lemma B5 For model M C exist cid141 s1 cid14n sn cid141 D cid14 s1 D s sn D s0 M jD Finalcid14n sn M jD Transcid14i si cid14iC1 siC1 D 1 n cid0 1 M jD Do1cid14 s s0 Proof By induction n If n D 1 Finalcid14 s cid27 Do1cid14 s s Lemma B3 If n 1 induction hypothesis M jD Do1cid142 s2 s0 applying Lemma B4 thesis 2 With lemmas place ﬁnally prove wanted result Theorem 1 For Golog program cid14 C jD 8s s0Do1cid14 s s0 cid17 Do2cid14 s s0 Proof Lemmas B2 B1 Lemmas B1 B5 2 References 1 GR Andrews FB Schneider Concepts notations concurrent programming ACM Comput Surveys 15 1 1983 343 2 ME Bratman DJ Israel ME Pollack Plans resourcebounded practical reasoning Comput Intelligence 4 1988 349355 3 AJ Bonner M Kifer Concurrency communication transaction logic Proc Joint International Conference Symposium Logic Programming JICSLP Bonn Germany 1996 pp 142156 4 J De Bakker E De Vink Control Flow Semantics MIT Press Cambridge MA 1996 5 XJ Chen G De Giacomo Reasoning nondeterministic concurrent actions A process algebra approach Artiﬁcial Intelligence 107 1 1999 6398 168 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 6 G De Giacomo Y Lespérance HJ Levesque Reasoning concurrent execution prioritized interrupts exogenous actions situation calculus Proc IJCAI97 Nagoya Japan 1997 pp 12211226 7 G De Giacomo HJ Levesque An incremental interpreter highlevel programs sensing Cognitive RoboticsPapers 1998 AAAI Fall Symposium Orlando FL Technical Report FS 9802 AAAI Press Menlo Park CA 1998 pp 2834 8 M Dixon Embedded computation semantics programs PhD Thesis Department Computer Science Stanford University Stanford CA 1991 Also appeared Xerox PARC Technical Report SSL 911 9 G De Giacomo E Ternovskaia R Reiter Nonterminating processes situation calculus Proc AAAI97 Workshop Robots Softbots Immobots Theories Action Planning Control Providence RI 1997 10 RM van Eijk FS Boer W van der Hoek JJCh Meyer Informationpassing belief revision multiagent systems JP Müller MP Singh AS Rao Eds Proc ATAL98 Paris 1998 pp 7589 11 M Fisher A survey Concurrent MetateMThe language applications DM Gabbay HJ Ohlbach Eds Temporal LogicProc First International Conference Lecture Notes Artiﬁcial Intelligence Vol 827 Springer Berlin 1994 pp 480505 12 M Gelfond V Lifschitz Representing action change logic programs J Logic Programming 17 1993 301327 13 CC Green Theorem proving resolution basis questionanswering systems Machine Intelligence Vol 4 Edinburgh University Press Edinburgh 1969 pp 183205 14 V Gupta R Jagadeesan VA Saraswat Computing continuous change Sci Comput Programming 30 1998 350 15 M Hennessy The Semantics Programming Languages Wiley New York 1990 16 KV Hindriks FS Boer W van der Hoek JJCh Meyer A formal semantics abstract agent programming language MP Singh A Rao MJ Wooldridge Eds Proc ATAL97 Lecture Notes Artiﬁcial Intelligence Vol 1365 Springer Berlin 1998 pp 215229 17 CAR Hoare Communicating Sequential Processes Prentice Hall Englewood Cliffs NJ 1985 18 D Leivant Higher order logic Handbook Logic Artiﬁcial Intelligence Logic Programming Vol 2 Clarendon Press Oxford 1994 pp 229321 19 Y Lespérance M Jenkin K Tam Reactivity logicbased robot programming framework Cognitive RoboticsPapers 1998 AAAI Fall Symposium Orlando FL Technical Report FS9802 AAAI Press Menlo Park CA 1998 pp 98105 20 HJ Levesque R Reiter Y Lespérance F Lin RB Scherl GOLOG A logic programming language dynamic domains J Logic Programming 31 1997 5984 21 F Lin R Reiter State constraints revisited J Logic Comput 4 5 1994 655678 22 F Lin R Reiter How progress database Artiﬁcial Intelligence 92 1997 131167 23 JW Lloyd Foundations Logic Programming 2nd edn Springer Berlin 1987 24 J McCarthy P Hayes Some philosophical problems standpoint artiﬁcial intelligence Machine Intelligence Vol 4 Edinburgh University Press Edinburgh 1969 25 R Milner Communication Concurrency Prentice Hall Englewood Cliffs NJ 1989 26 HR Nielson F Nielson Semantics Applications A Formal Introduction Wiley New York 1992 27 G Plotkin A structural approach operational semantics Technical Report DAIMIFN19 Computer Science Department Aarhus University Denmark 1981 28 D Pym L Pryor D Murphy Processes planexecution Proc 14th Workshop UK Planning Scheduling Special Interest Group 1995 29 AS Rao AgentSpeakL BDI agents speak logical computable language W van der Velde JW Perram Eds Agents Breaking Away Lecture Notes Artiﬁcial Intelligence Vol 1038 Springer Berlin 1996 pp 4255 30 AS Rao MP Georgeff An abstract architecture rational agents B Nebel C Rich W Swartout Eds Proc 3rd International Conference Principles Knowledge Representation Reasoning KR 92 Cambridge MA Morgan Kaufmann San Mateo CA 1992 pp 439449 31 R Reiter The frame problem situation calculus A simple solution completeness result goal regression Artiﬁcial Intelligence Mathematical Theory Computation Papers Honor John McCarthy Academic Press New York 1991 pp 359380 G De Giacomo et al Artiﬁcial Intelligence 121 2000 109169 169 32 R Reiter Proving properties states situation calculus Artiﬁcial Intelligence 64 1993 337351 33 R Reiter Natural actions concurrency continuous time situation calculus Proc 5th International Conference Principles Knowledge Representation Reasoning KR96 Cambridge MA Morgan Kaufmann San Mateo CA 1996 pp 213 34 R Reiter Knowledge action Logical foundation describing implementing dynamical systems In preparation 35 VA Saraswat M Rinard Concurrent constraint programming Proc 17th ACM Symposium Principles Programming Languages 1990 pp 232245 36 S Shapiro Y Lespérance HJ Levesque Specifying communicative multiagent systems W Wobcke M Pagnucco C Zhang Eds Agents MultiAgent SystemsFormalisms Methodologies Applications Lecture Notes Artiﬁcial Intelligence Vol 1441 Springer Berlin 1998 pp 114 37 JR Shoenﬁeld Mathematical Logic AddisonWesley Reading MA 1967 38 Y Shoham Agentoriented programming Artiﬁcial Intelligence 60 1993 5192 39 C Stirling Modal temporal logics processes Logics Concurrency Structure versus Automata Lecture Notes Computer Science Vol 1043 Springer Berlin 1996 pp 149237 40 A Tarski A latticetheoretical ﬁxpoint theorem applications Paciﬁc J Math 5 1955 285309