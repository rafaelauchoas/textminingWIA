Artiﬁcial Intelligence 172 2008 591632 wwwelseviercomlocateartint The model evolution calculus ﬁrstorder DPLL method Peter Baumgartner Cesare Tinelli b1 NICTA Canberra ACT Australia b Department Computer Science The University Iowa Iowa City IA USA Received 31 January 2007 received revised form 14 September 2007 accepted 19 September 2007 Available online 26 September 2007 Abstract The DPLL procedure basis successful propositional satisﬁability solvers date Although originally devised proofprocedure ﬁrstorder logic exclusively propositional logic far highly inefﬁcient treatment quantiﬁers based instantiation ground formulas The FDPLL calculus Baumgartner ﬁrst successful attempt lift procedure ﬁrstorder level resorting ground instantiations FDPLL lifts ﬁrstorder case core DPLL procedure splitting rule ignores aspects procedure necessary completeness crucial effectiveness practice In paper present new calculus loosely based FDPLL lifts aspects In addition faithful lifting DPLL procedure new calculus contains systematic treatment universal literals crucial achieve efﬁciency practice The new calculus implemented successfully Darwin described The main results paper theoretical showing soundness completeness new calculus In addition paper provides highlevel description proof procedure calculus comparison calculi 2007 Elsevier BV All rights reserved Keywords DPLL procedure Firstorder logic Sequent calculi Model generation 1 Introduction In propositional satisﬁability DPLL procedure named authors Davis Putnam Logemann Love land 1314 dominant method building complete SAT solvers Its popularity simplicity polynomial space requirements fact search procedure amenable powerful relatively inexpensive heuristics reducing search space Thanks heuristics careful engineering best SAT solvers today successfully attack realworld problems hundreds thousands variables clauses 2837 These solvers powerful developers automated reasoningbased tools starting use backends solve ﬁrstorder satisﬁability problems albeit incomplete way means ingenious domain speciﬁc translations propositional logic 303145 Corresponding author Email addresses PeterBaumgartnernictacomau P Baumgartner tinellicsuiowaedu C Tinelli 1 Partially supported Grant No 237422 National Science Foundation 00043702 matter 2007 Elsevier BV All rights reserved doi101016jartint200709005 592 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 Interestingly DPLL procedure actually devised origin proofprocedure ﬁrstorder logic Its treatment quantiﬁers highly inefﬁcient based enumerating possible ground instances input formulas clause form checking propositional satisﬁability ground instances time Because primitive treatment quantiﬁers DPLL procedure predates Robinsons resolution calculus years quickly overshadowed resolution method choice automated ﬁrstorder reasoning use conﬁned propositional satisﬁability since2 Given great success DPLLbased SAT solvers today natural research questions arise One DPLL procedure properly lifted ﬁrstorder levelin sense ﬁrstorder resolution lifts propositional resolution The powerful search heuristics DPLL effective propositional level successfully adapted ﬁrstorder case We answer ﬁrst questions afﬁrmatively paper providing complete lifting DPLL procedure ﬁrstorder clausal logic means new sequentstyle calculus Model Evolution calculus ME short The ME calculus answer second question afﬁrmatively companion paper 5 describing recent implementation calculus The FDPLL calculus Baumgartner 4 ﬁrst successful attempt lift DPLL procedure ﬁrst order level resorting ground instantiations FDPLL lifts ﬁrstorder case core DPLL procedure splitting rule ignores major aspect unit propagation 50 necessary completeness absolutely crucial effectiveness practice The calculus described paper lifts aspect While ME calculus borrows fundamental ideas FDPLL generalizes extension FDPLL proper DPLL 47 simple propositional calculus modeling main features DPLL procedure As Model Evolution calculus direct lifting DPLL sense consists appropriate ﬁrstorder versions DPLLs rules plus additional rule speciﬁc ﬁrstorder case A useful feature DPLL procedureand propositional proof procedures matteris able provide Herbrand model input formula formula satisﬁable The procedure extension DPLL calculus generates model incrementally derivation The Model Evolution calculus seen lifting model generation process ﬁrstorder level We purpose Model Evolution calculus like DPLL calculus construct Herbrand model given set cid2 clauses model exists At step derivation calculus maintains context cid3 ﬁnite set possibly nonground literals The context cid3 ﬁniteand compactrepresentation Herbrand interpretation Icid3 serving candidate model cid2 The induced interpretation Icid3 model cid2 satisfy clauses cid2 The purpose main rules calculus detect situation repair Icid3 modifying cid3 model cid2 recognize Icid3 unrepairable fail In addition rules calculus contains number simpliﬁcation rules purpose like DPLL simplify clause set consequence speed computation We calculus Model Evolution calculus starts default candidate model satisﬁes positive literals evolves needed actual model input clause set cid2 clear cid2 models Note DPLL calculus seen exactly thing ground formulas The Model Evolution calculus simply extends behavior nonground formulas An important byproduct model evolution process terminating derivation satisﬁable clause set cid2 produces context induced interpretation model cid2 This makes calculus suited applications important provide counterexamples invalid statements opposed simply proving invalidity The Model Evolution calculus refutationally sound complete input clause set cid2 unsatisﬁable calculus ﬁnitely fails ﬁnd model cid2 The calculus obviously nonterminating arbitrary satisﬁable input sets With clause sets calculus repairing candidate model forever turning actual model The calculus terminating class ground clauses course class clauses resulting translation conjunctions BernaysSchönﬁnkel formulas clause form3 The termination ground clause sets direct consequence fact inputs 2 But Section 6 brief overview ﬁrstorder reasoning systems use procedure help focus search 3 Such clauses contain function symbols restrictions apply P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 593 Model Evolution calculus reduces DPLL calculus The reasons termination Bernays Schönﬁnkel formulas similar given 4 FDPLL As mentioned Model Evolution calculus signiﬁcant improvement FDPLL faithful lifting DPLL procedure having additional rules simplifying current clause set current context Another advantage FPDLL contains systematic general treatment universal literals FDPLLs optimizations As adding literals universal variables context imposes stronger restrictions future modiﬁcation context This consequence greatly reducing non determinism calculus potential leading faster implementations The paper organized follows After formal preliminaries given brieﬂy Section 2 DPLL procedure deﬁne DPLL calculus declarative version procedure We deﬁne discuss Model Evolution calculus Section 3 showing extends DPLL We prove calculus correctness Section 4 In Section 5 brieﬂy proof procedure calculus implemented Darwin theorem prover 5 Then discuss Section 6 calculus compares calculi related work We conclude paper Section 7 directions research The technical results needed Section 4 proved appendix 11 Formal preliminaries In paper use disjoint inﬁnite sets variables set X universal variables refer variables set V refer parameters The reason having types variables explained later We use possibly subscripts u v denote elements V x y denote elements X w denote elements V X We ﬁx signature cid4 paper We denote cid4sko expansion cid4 obtained adding cid4 inﬁnite number Skolem constants cid4 By cid4term cid4skoterm mean term signature cid4 cid4sko V X In following simply term mean cid4skoterm If t term denote Vart set ts variables Part set ts parameters A term t ground iff Vart Part Two terms variabledisjoint parameterdisjoint iff variables parameters common They disjoint iff variable parameterdisjoint We extend notation terminology literals clauses obvious way We adopt usual notion substitution cid4skoexpressions sets thereof We use standard notion uniﬁer general uniﬁer We denote w1 cid5 t1 wn cid5 tn substitution σ wiσ ti 1 n wσ w w X V w1 wn Also denote Domσ set w1 wn Ranσ set w1σ wnσ If σ substitution W subset X V restriction σ W denoted σW substitution maps w W wσ w V X W A substitution ρ renaming W V X iff ρW bijection W W For instance ρ x cid5 u v cid5 u u cid5 v renaming V Note ρ renaming V X maps x v u We substitution simply renaming renaming V X We substitution σ parameterpreserving ppreserving short renaming V Similarly σ variablepreserving renaming X Note renaming parameterpreserving iff variable preserving For example renaming x cid5 y y cid5 x u cid5 v v cid5 u variable parameterpreserving wheres renaming x cid5 v v cid5 x variablepreserving parameterpreserving If s t terms s general t write s cid2 t iff substitution σ sσ t4 We s variant t write s t iff s cid2 t t cid2 s equivalently iff renaming ρ sρ t We write s cid2 t s cid2 t s cid10 t We s parameterpreserving general t write s cid3 t iff parameterpreserving substitution σ sσ t When s cid3 t t pinstance s Since substitution parameterpreserving composition parameterpreserving substitutions parameter preserving immediate relation cid3 like cid2 reﬂexive transitive We s parameterpreserving variant pvariant t write s cid11 t iff s cid3 t t cid3 s equivalently iff parameterpreserving renaming ρ sρ t We write s cid3 t s cid3 t s cid10cid11 t Note cid11 equivalence relations 4 The uniﬁcation literature write s cid4 t case 594 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 All substitutions extended terms literals atomic formulas negated atomic formulas obvious way We denote literals general letters K L We denote L complement literal L As usual clause disjunction L1 Ln zero literals We denote clauses letters C D clause cid2 We write L C denote clause obtained disjunction possibly clause C literal L When convenient treat clauses set literals A Skolemizing substitution substitution θ Domθ X replaces variable Domθ fresh Skolem constant remaining element X V A Skolemizing substitution literal L clause C Skolemizing substitution θ Domθ VarL Domθ VarC We write Lsko Csko denote result applying L C Skolemizing substitution L C A Herbrand interpretation I signature cid8 set ground cid8literals contains L L ground cid8literal L Satisﬁability cid8literals cid8clauses I deﬁned follows The interpretation I satisﬁes model ground literal L written I L iff L I I satisﬁes ground clause C iff I L L C I satisﬁes clause C iff I Ccid13 ground instances Ccid13 C I satisﬁes clause set cid2 iff I C C cid2 C The interpretation I falsiﬁes literal L clause C satisfy L C Sometimes clause C valid I mean I C 2 The DPLL calculus The DPLL procedure decide satisﬁability ground propositional formulas conjunctive normal form precisely satisﬁability ﬁnite sets ground clauses The essential operations procedure unit resolution backward subsumption ii unit subsumption iii recursive reduction smaller problems The procedure roughly described follows5 Given input clause set cid2 satisﬁability checked apply unit propagation close cid2 unit resolution backward subsumption eliminate process nonunit clauses subsumed unit clause set b unit clauses atom occurs set If closure cid2 cid2 contains clause fail If cid2 set succeed Otherwise choose arbitrary literal L cid2 check recursively separately satisﬁability cid2 L cid2 L succeeding subsets satisﬁable The essence procedure captured sequentstyle calculus DPLL calculus ﬁrst described 47 consisting derivation rules Fig 1 The calculus manipulates sequents form cid3 cid14 cid2 cid3 context sequent ﬁnite set ground literals cid2 ﬁnite multiset ground clauses6 The intended goal calculus derive sequent form cid3 cid14 initial sequent cid14 cid20 cid20 clause set checked satisﬁability If possible cid20 satisﬁable cid20 unsatisﬁable Informally purpose context cid3 store incrementally set asserted literals set literals cid20 true cid20 satisﬁable When cid3 cid14 derivable cid14 cid20 context cid3 witness cid20s satisﬁability describes Herbrand model cid20 satisﬁes atom p cid20 iff p occurs positively cid3 The context grown Assert Split rules The Assert rule models fact literal occurring unit clause current clause set satisﬁed clause set satisﬁed The Split rule corresponds decomposition smaller subproblems DPLL procedure This rule dontknow nondeterministic rule calculus It guess truth value undetermined literal L clause set cid2 current sequent cid3 cid14 cid2 undetermined mean L L context cid3 The guess allows continuation derivation sequent cid3 L cid14 cid2 sequent cid3 L cid14 cid2 The main operations DPLL procedure unit resolution backward subsumption unit sub sumption modeled respectively Resolve Subsume rule The Resolve rule removes clause 5 See original papers 1314 complete description 6 As customary write cid3 L cid14 cid2 C denote sequent cid3 L cid14 cid2 C P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 595 Fig 1 The DPLL calculus literals complement assertedwhich corresponds generating simpliﬁed clause unit resolu tion discarding old clause backward subsumption The Subsume rule removes clauses contain asserted literalbecause clauses satisﬁed model asserted literal true The DPLL calculus easily proven sound complete terminating It shown 47 calculus main tains completeness constrains Split rule split positive literals7 In words loss completeness Split replaced rule Split cid3 cid14 cid2 L C cid3 L cid14 cid2 L C cid3 L cid14 cid2 L C L positive C cid10 cid2 L cid3 L cid3 Another change alter calculus fundamental way replacement Assert Empty rules following powerful versions Assert cid3 cid14 cid2 L1 Ln L cid3 L cid14 cid2 L1 Ln L Close cid3 cid14 cid2 L1 Ln cid3 cid14 cid2 cid6 n cid3 0 L1 Ln cid3 L cid3 L cid3 cid2 cid10 n 0 L1 Ln cid3 Note Assert Close reduce respectively Assert Empty given earlier L1 Ln literals n 0 The reason Assert Close change calculus application Assert respectively Close simulated n applications Resolve followed application Assert respectively Empty We point Close Resolve rule superﬂuous completeness We mention Split Assert Close rules facilitate comparison Model Evolution calculus DPLL 3 The model evolution calculus The Model Evolution calculus direct lifting DPLL calculus ﬁrstorder level The lifting achieved suitable ﬁrstorder version rules Split Assert Subsume Resolve Close DPLL addition extra rule Compact simpliﬁcation rule speciﬁc ﬁrstorder case Similarly DPLL derivation rules Model Evolution calculus apply produce sequents form cid3 cid14 cid2 This time cid3 ﬁnite set literals possibly variables parameters called context cid2 set clauses possibly variables 7 This fact known SAT literature optimization DPLLbased SAT solvers 596 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 As mentioned introduction context cid3 sequent cid3 cid14 cid2 determines interpretation Icid3 meant model cid2 The purpose main rules calculus recognize Icid3 model cid2 repair The repairs localized incremental based computation general uniﬁers The progressive repair process evolution candidate model starts default interpretation continues actual model repairs possible The calculus nondeterministic cases current interpretation repaired alternative ways ruled priori With initial sequent cid30 cid14 cid20 gives rise search space possible evolution sequences Icid30 initial candidate model cid20 To ease technical presentation comes handy work pseudoliteral v v parameter ranges atoms The intention v stand default negative literals We cid20 unsatisﬁable cid30 v possible evolution sequences ﬁnitely failedmaking calculus complete We conversely evolution sequences Iv ﬁnitely failed cid20 guaranteed unsatisﬁablemaking calculus sound In process nonfailed ﬁnite sequences grown end context candidate model model cid20 31 Contexts interpretations The deﬁning aspect calculus modeled FDPLL way contexts extended ﬁrstorder case rôle play driving derivation model generation process Therefore start description calculus Deﬁnition 31 Context A context set form v S v V S ﬁnite set literals Where L literal cid3 context write L cid3 L variant literal cid3 L cid11 cid3 L pvariant literal cid3 L cid2 cid3 L pinstance literal cid3 The calculus works noncontradictory contexts Deﬁnition 32 Contradictory A literal L contradictory context cid3 iff Lσ Kσ K cid11 cid3 ppreserving substitution σ A context cid3 contradictory iff contains literal contradictory cid3 Example 33 Let cid3 v px1 y1 qv1 Then phx u pv u qy contradictory cid3 However qf v rx Recall x x1 y1 variables v v1 u parameters A noncontradictory context induces unique Herbrand interpretation means notions Deﬁnition 34 Shields Let K L literals K cid2 L A literal K cid13 strongly shields L K iff K cid2 K cid13 cid2 L K cid13 shields L K iff K cid2 K cid13cid13 cid2 L literal K cid13cid13 K cid13 cid3 K cid13cid13 A context cid3 strongly shields L K iff contains literal strongly shields L K Equivalently cid3 shields L K iff K cid2 K cid13cid13 cid2 L K cid13cid13 cid2 cid3 Deﬁnition 35 Covers Let L literal cid3 context A literal K strongly covers L cid3 iff K cid2 L cid3 shield L K K covers L cid3 iff K cid2 L cid3 strongly shield L K Deﬁnition 36 Productivity Let L literal C clause cid3 context A literal K produces L cid3 iff 1 K covers L cid3 2 K cid13 cid3 strongly covers L cid3 b shields L K P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 597 Fig 2 Illustrations notions shields covers produces See Deﬁnitions 34 35 36 notation The context cid3 produces L iff contains literal K produces L cid3 The context cid3 produces C iff produces Cs literals From deﬁnition follows noncontradictory context containing parameterfree literal K produces instances K produce instance K This special case general result saying literal K produces pinstances context produce pinstance K cf Lemma A6 To help clarify relationship concepts shielding covering producing illustrated Fig 2 Example 37 Consider context cid3 v px u pv x Now pu u w produces pa cid3 pu u w covers pa cid3 K cid13 cid3 strongly covers pa cid3 shields pa pu u w In fact candidate literal K cid13 px u That literal shield 598 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 pa pu u wwhich means pu u w strongly cover pa cid3 strongly cover pa pa cid3 pv x cid3 shields pa px u The context cid3 produces pa b pv x cid2 pa b cid3 shield pa pv x But cid3 produce pv Although px u cid2 pv holds literal cid3 pv x strongly covers pv cid3 shields pv px u A consequence presence pseudoliteral v context cid3 cid3 produces L L literal L We use fact associate cid3 unique Herbrand interpretation Deﬁnition 38 Induced interpretation Let cid3 noncontradictory context signature cid4sko The interpretation induced cid3 denoted Icid3 Herbrand cid4interpretation satisﬁes positive ground cid4literal L iff L produced cid3 For simplicity context satisﬁesfalsiﬁes literal clause induced interpretation Note context contain literals Skolem constants respect original signature cid4 induced interpretation original signature Also note possible context cid3 produce positive ground literal L complement L deﬁnition asymmetric case Icid3 chooses satisfy L L Contrapositively means Icid3 satisﬁes ground literal L L positive L possibly L produced cid3 If hand L negative L L produced cid3 It clear purpose pseudoliteral v context cid3 provide default truthvalue ground literals value determined rest context In fact consider ground cid4literal L L L produced cid3 v If L positive false Icid3 produced cid3 If L negative true Icid3 produced v At point clariﬁcation complexity deﬁnition productivity order One think intuitive deﬁnition stating K produces L cid3 iff K strongly covers L cid3 good support Deﬁnition 38 While simpler deﬁnition adequate purposes The reason exist somewhat complicated contexts cid3 ground literals L cid3 produces L L according simpler deﬁnition above8 Now requirement context cid3 produce L L ground literal L fundamental calculus identify context literals cause ground clause instances falsiﬁed current induced interpretation later This requirement satisﬁed given Deﬁnition 36 candidate literal K cid3 cover L cid3 produce L cid3 literal K cid13 cid3 shields L K produces L cid3 cf Fig 2e We refer reader 19 study complexity basic reasoning tasks contexts9 relation model representation formalisms For given sequent cid3 cid14 cid2 interpretation induced context cid3 falsify clause cid2 This situation detectable computation context uniﬁers Deﬁnition 39 Context uniﬁer Let cid3 context C L1 Lm Lm1 Ln parameterfree clause 0 cid5 m cid5 n A substitution σ context uniﬁer C cid3 remainder Lm1σ Lnσ iff fresh pvariants K1 Kn cid11 cid3 8 In essence possible context literals shield cyclic way preventing producing L L 9 However note context literals 19 variablefree parameterfree The mixed setting context literals contain variables parameters introduced paper P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 599 1 σ general simultaneous uniﬁer K1 L1 Kn Ln 2 1 m ParKiσ V 3 m 1 n ParKiσ cid4 V We addition σ productive iff Ki produces Liσ cid3 1 n For 1 n Ki context literal σ A context uniﬁer σ C cid3 remainder Lm1σ Lnσ admissible Split iff distinct j m 1 n VarLiσ VarLj σ Note context uniﬁer unique remainder If σ context uniﬁer clause C remainder D literal D remainder literal σ Example 310 Let cid3 v pv1 u1 px1 gx1 qv2 gv2 C1 rx px y Then substitu tions σ1 v cid5 rx v1 cid5 x u1 cid5 y σ2 v cid5 rv1 x cid5 v1 u1 cid5 y context uniﬁers C1 cid3 respective remainders rx px y rv1 pv1 y While σ1 σ2 productive σ2 admissible The context uniﬁer σ1 admissible remainder literals variabledisjoint By contrast substitution σ3 cid7 v cid5 rv1 x cid5 v1 y cid5 u1 cid8 context uniﬁer C1 cid3 time remainder rv1 productive admissible Consider clause C2 px y qx y The substitution σ4 cid8 cid7 v1 cid5 v2 u1 cid5 gv2 x cid5 v2 y cid5 gv2 context uniﬁer C2 cid3 remainder pv2 gv2 This context uniﬁer admissible pro ductive literal pv1 u1 cid3 chosen unify px y produce px yσ4 pv2 gv2 We point later comparisons DPLL calculus Deﬁnition 39 C ground v nonground literal cid3 substitution σ context uniﬁer C cid3 remainder Lm1σ Lnσ Lm1 Ln iff 1 1 m Ki Li 2 m 1 n Li positive literal Ki pvariant v Admissible context uniﬁers fundamental Model Evolution calculus In fact context cid3 clause C existence admissible context uniﬁer C cid3 sign Icid3 model C This possible compute admissible context uniﬁer C cid3 cid3 noncontradictory Icid3 falsiﬁes C The discovery calculus admissible context uniﬁer σ C current context cid3 prompts modiﬁcation cid3 involves adding literal Cσ goal making C valid new Icid3 This literal chosen remainder literals σ reason essentially nonremainder literals ignored loss completeness Note existence admissible context uniﬁer σ C cid3 necessary unsatisﬁability C Icid3 sufﬁcient σ productive As matter fact completeness calculus needs add context remainder literals admissible uniﬁers productive For greater ﬂexibility allow add remainder literals nonproductive admissible uniﬁers The reason practical twofold ﬁrst implementing calculus insisting computing productive context uniﬁers considerably expensive computing context uniﬁers usually productive second repairing candidate models remainder literals nonproductive context uniﬁers produce constrained contexts illustrated example follows 600 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 Example 311 Consider context cid3 v pu qgy clause C px qx The substitution σ v cid5 pgy x cid5 gy context uniﬁer C cid3 remainder pgy productive As matter fact Icid3 satisﬁes C Cσ cid3 produces ground instance px This means need repair Icid3 addition pgy cid3 However explain Section 32 having universal literal pgy cid3 pu considerably constrains repairs involving instances pu corresponding reduction search space Productivity issues aside point context uniﬁers given clause C context cid3 easily computable simultaneous general uniﬁers unique admissible Nevertheless calculus need search admissible context uniﬁers For completeness purposes admissible context uniﬁer C cid3 Furthermore important admissible context uniﬁers easily derived nonadmissible ones In fact let σ context uniﬁer C cid3 remainder D If σ remainder literal L shares variables remainder literal compose σ substitution moves variables L fresh parameters ﬁxes It easy repeated application process leads admissible context uniﬁer σρ C remainder included Dρ For instance nonadmissible context uniﬁers σ1 Example 310 turned admissible σ3 kind process Now choice admissible context uniﬁer irrelevant completeness context uniﬁers better efﬁciency purposes A context uniﬁer remainder instance preferable nonempty remainder lets calculus stop derivation right away In general context uniﬁers smaller remainder preferable context uniﬁers longer remainder offer choices repairing current model Also context uniﬁers parameterfree remainder literals preferable context uniﬁers variablefree remainder literals As explain later addition parameterfree literal context imposes constraints later additions addition variablefree literal leading principle shorter derivations 32 Parameters vs variables Before moving rules Model Evolution calculus important clarify respective rôles parameters variables play We said calculus manipulates sequents form cid3 cid14 cid2 cid2 clause set cid3 context pro viding candidate model cid2 Each derivation calculus starts sequent form v cid14 cid20 cid20 contains standard clauses clauses parametersbut possibly variables Similarly sequents generated derivation clause sets consisting standard clauses Variables appear clause sets contexts Parameters instead appear contexts The rôle variables clause usual stand ground terms In contrast rôle variables parameters context constrain different ways candidate model repaired The current context cid3 needs repairing falsiﬁes clause C cid2 As observed earlier case admissible context uniﬁer σ C cid3 cid3 falsiﬁes Cσ To satisfy C necessary modify cid3 satisﬁes Cσ One way pick Cσ literal Lσ noncontradictory cid3 add cid3 When Lσ contains parameters universal literal FDPLL terminology addition Lσ ground instances Lσ satisﬁed new context Moreover instances permanently satisﬁed sense additions literals context contradictory preserve satisﬁability instances In contrast Lσ contains parameters assertion ground cid4instances Lσ provisional retracted later With addition Lσ context calculus essence making assumption model C satisﬁes ground instances Lσ This assumption working hypothesis subject revised evidence That happens calculus satisfy P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 601 clause later adds current context cid3cid13 literal K cid13 proper instance Lσ 10 After addition new context satisﬁes instances Lσ instance Lσ cid13 We observe parameters context literal instances parameter preservingwith extreme cases variablefree literals having pinstances pvariants parameterfree literals having pinstances This means parameters context literal difﬁcult change truth value instances extending context That seen following simple example Example 312 Consider signature cid4 containing constant symbol contexts cid31 v L1 cid32 v L2 cid33 v L3 L1 pu v L2 px v L3 px y All ground cid4instances Li true Icid3i 1 3 In ﬁrst context pu v variablefree possible change truth literals form pa t pt t ground term adding cid31 literals pa v pu In second context possible literal pa v contradictory px v Nevertheless possible change truth value instances px v form pt addition pu In context pa v pu contradictory px y Because stronger restrictions impose possible evolutions context variables effect help prune search space derivations However added indiscriminately place parameters context literals making calculus incomplete By admissible context uniﬁers ME calculus able introduce fair variables contexts loss completeness 33 Derivation rules The ME calculus consists basic derivation rules Split Assert Close optional rules Resolve Subsume Compact We deﬁne discuss following In process We compare rules DPLL calculus modulo technicality ME reduces DPLL input clause set ground11 The technicality simply contrary DPLL contexts calculus contain pseudo literal v Except calculi operate kind sequents ground case stepwise simulate The Splitrule Split sko cid14 cid2 C L cid3 cid14 cid2 C L cid3 Lσ cid14 cid2 C L cid3 Lσ C cid10 cid2 σ admissible context uniﬁer C L cid3 remainder literal Lσ Lσ Lσ sko contradictory cid3 We clause C L selected clause literal L selected literal σ context uniﬁer Split The Split rule analog Split rule DPLL As DPLL dontknow nondeterministic rule calculus drives search model input clause set Split rule discovers current candidate model falsiﬁes clauses current clause set It computing context uniﬁer σ nonempty remainder clause literals The rule attempts repair candidate model selecting remainder literal Lσ adding Lσ complement context The nonparameterpreserving instance Lσ new context contradictory permitted 10 More generally happens calculus adds literal K ppreserving instances Kcid13 Kcid13 11 More precisely reduces version DPLL described end Section 2 uses rules Split Assert Close place Split Assert Empty respectively instance Lσ Note case 602 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 reason adding complement Lσ alternative Lσ course current clause set models satisfy Lσ Obviously addition Lσ s complement context selected clause C L valid new candidate model But sure context uniﬁer C L Lσ remainder forcing calculus select remainder literals C L valid Note Split exactly add complement Lσ current context suitably Skolemized version replaces variable Lσ fresh Skolem constant12 This accordance treatment context literals universally quantiﬁed wrt variables essentially existentially quantiﬁed negation leading fresh Skolem constants Example 313 If P x f x y v w selected literal Split inference context uniﬁer literal P x f x y v w added context left sequent literal P c f c d v w added context right sequent c d fresh constants We point Split inference followed branch Split inference literal Lσ pvariant Lσ Lσ contradictory context Since Split rule introduces Skolemized literals contexts implies particular context contain Skolemized version literal It difﬁcult check properties hold presence Compact rule removes literals context sko In ground casethat cid3 v cid2 C L groundthe Split rule reduces exactly Split rule DPLL Section 2 To recall ground case Lσ L remainder literal context uniﬁer σ C L cid3 L uniﬁed σ variant sko L contradictory cid3 sense v implies L positive Moreover L respectively Lσ Deﬁnition 32 iff L cid3 respectively L cid3 The Assertrule Assert cid3 cid14 cid2 C L cid3 Lσ cid14 cid2 C L σ context uniﬁer C cid3 remainder Lσ parameterfree noncontradictory cid3 K cid3 st K cid3 Lσ We clause C L selected clause L selected literal Assert As DPLL Assert rule extremely useful reducing nondeterminism calculus When ﬁrst conditions holds candidate model induced extension cid3 Lσ valid model cid2 C L The Assert rule achieves adding Lσ context Note Lσ parameterfree addition context retractable Also note rule apply permanent validity Lσ established This case cid3 contains anecessarily parameterfreeliteral K K cid3 Lσ The rule apply Lσ contradictory cid3 In case candidate model unrepairable The Close rule described later detect cause calculus stop working cid3 cid14 cid2 L C When C cid2 selected clause Assert unit clause L substitution context uniﬁer C cid3 remainder In case effect rule simply add L context For greater ﬂexibility Assert rule deﬁned clauses arbitrary number literals As Section 43 completeness purposes restrict applications unit clauses In ground case Assert reduces exactly Assert DPLL The reason ground case σ context uniﬁer C cid3 remainder iff σ substitution cid3 contains complement literal C ii Lσ trivially parameterfree iii K cid3 st K cid3 Lσ iff L cid3 iv Lσ contradictory cid3 iff L cid3 12 More precisely occur current context P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 603 The Closerule cid9 Close cid3 cid14 cid2 C cid3 cid14 cid2 cid2 cid10 C cid10 cid2 context uniﬁer σ C cid3 remainder We clause C selected clause Close σ context uniﬁer Close The idea Close precondition holds way repair current candidate model satisfy C The replacement current close set clause signals calculus given candidate model Note Resolve possible calculus generate sequent containing clause The Close rule recognizes sequents applies To observe context cid3 substitution context uniﬁer cid2 cid3 remainder In ground case Close rule reduces namesake DPLL C context uniﬁer cid3 remainder iff L cid3 literal L C The Subsumerule Subsume cid3 K cid14 cid2 L C cid3 K cid14 cid2 K cid3 L We clause L C selected clause Subsume The purpose Subsume DPLL rid clauses valid current candidate model guaranteed stay so13 These exactly clauses literals pinstance literal current context Although Subsume needed completeness potentially useful practice reduces size current clause set In ground case Subsume rule reduces namesake DPLL K cid3 L iff K L The Resolverule cid9 Resolve cid3 cid14 cid2 L C cid3 cid14 cid2 C context uniﬁer σ L cid3 remainder Cσ C We clause L C selected clause L selected literal Resolve This rule similar Subsume needed completeness useful reduce complexity current clause set Since Resolve sense dual Subsume reasonable expect precondition simply literal K cid3 K cid3 L This precondition special case provided The given precondition makes Resolve widely applicable allowing frequent simpliﬁcations Observe Resolve special case unit resolution backward subsumption resolvent unit clause K clause L C exactly Cas opposed proper instance C In ground case Resolve rule reduces namesake DPLL To observe case Resolves precondition holds iff σ substitution L cid3 The Compactrule Compact cid3 K L cid14 cid2 cid3 K cid14 cid2 K cid3 L We literal L selected literal literal K subsuming literal Compact14 The Compact rule simpliﬁcation rule needed completeness useful practice Its intended application addition literal K parameterpreserving general literals context After addition literals superﬂuous replaced K purposes Hence Compact allows elimination There rule DPLL corresponding Compact However easy Compact applies ground case 13 Note L parameterfree necessary condition K cid3 L K parameterfree implies instances false subsequent contexts 14 The literals K L meant distinct 604 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 34 Derivation examples For better idea rules calculus apply informally couple examples derivationsa formal deﬁnition derivation given section In ﬁrst example consider satisﬁable clause set BernaysSchönﬁnkel class showing cal culus computes model clause set In second example consider unsatisﬁable set unsatisﬁability proven calculus deterministicallythat applying Split thanks Assert rule Example 314 Consider following initial sequent v cid14 px qx py qy pc pz qz One rule fact rule applies sequent Split selected clause px qx In fact fresh variants v1 v2 context literal v substitution σ v1 cid5 px v2 cid5 qx context uniﬁer px qx remainder px qx While context uniﬁer admissible remainder literals share variable generate admissible composition substitution x cid5 u The new context uniﬁer σ cid13 σ x cid5 u remainder pu qu Since remainder literal pu complement noncontradictory context add pu context left conclusion application Split obtaining v pu cid14 px qx py qy pc pz qz Note σ cid13 context uniﬁer px qx new context pu qu remainder literals σ cid13 However Split apply selected literal px anymore complement pu pxσ cid13 contradictory context The Split rule apply selected literal qx sense application useless px qx satisﬁed current context makes ground instance pu true The uselessness applying Split selected literal qx witnessed fact σ cid13 non productive context uniﬁer In fact literal v1 context literal variant paired px uniﬁer produce px anymore presence pu context We point fresh variant pu1 context literal pu context uniﬁers subclause pz1 pz qz Hence think applying Assert selected clause pz qz selected literal qz However possible uniﬁers nonempty remainder like instance uniﬁer u1 cid5 z instantiate qz nonparameterfree literal like instance uniﬁer z cid5 u1 Now context literal variants pu1 v1 pu2 substitution σ y cid5 u1 v1 cid5 qu1 u2 cid5 c admissible context uniﬁer py qy pc remainder qu1 pc Since qu1 complement contradictory context apply Split selected clauses py qy pc literal qy15 Choosing left conclusion Split adds qyσ context obtain qu1 cid14 px qx py qy pc pz qz v pu Now Close rule applies selected clause pz qz In fact context literal variants pu2 qu3 substitution σ z cid5 u2 u3 cid5 u2 context uniﬁer pz qz remainder Lets consider right conclusion Split application With conclusion sequent v pu qu1 cid14 px qx py qy pc pz qz 15 The substitution u1 cid5 y v1 cid5 qy u2 cid5 c context uniﬁer py qy pc admissible remainder py qy pc P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 605 Using context literal variants pu2 qu3 substitution σ y cid5 u2 u3 cid5 u2 context uniﬁer remainder subclause py qy py qy pc Moreover pc pcσ parameterfree noncontradictory context Finally context literal K K cid3 pc16 Hence Assert applies selected clause py qy pc literal pc yielding sequent v pu qu1 pc cid14 px qx py qy pc pz qz Subsume immediately applies selected clause py qy pc yielding sequent v pu qu1 pc cid14 px qx pz qz At point context literal pc apply Assert selected clause px qx obtaining v pu qu1 pc qc cid14 px qx pz qz It easy rules apply sequent For Split particular reason possible remainder literal contradictory context literals complementsfor Assert argument similar For signature cid4 includes symbols original clause set ﬁnal context induces Herbrand cid4 interpretation ground instances pu pc true ground instances qu1 qc false For illustration purposes cid4 contains symbols original clause set induced interpretation simply qc If cid4 contains functions symbols f arity 1 induced interpretation qc pf ncn 0 We leave reader verify interpretations model original clause set Example 315 Now consider following initial sequent use usual mathematical notation greater clarity v cid14 x cid3 y y cid3 z x cid3 z x cid3 0 0 cid3 x x cid3 0 0 cid3 x x cid3 0 x cid3 x 0 cid3 x x cid3 x c cid3 c c cid3 c Recalling earlier observation applicability Assert unit clauses immediately add unit clause clause set context means Assert remove set means Subsume This results sequent v x cid3 0 0 cid3 x cid14 x cid3 y y cid3 z x cid3 z x cid3 0 0 cid3 x x cid3 0 x cid3 x 0 cid3 x x cid3 x c cid3 c c cid3 c Now consider clause x cid3 y y cid3 z x cid3 z subclause x cid3 y y cid3 z With context literal variants x1 cid3 0 0 cid3 x2 substitution σ x cid5 x1 y cid5 0 z cid5 x2 admissible context uniﬁer x cid3 y y cid3 z remainder Moreover literal x1 cid3 x2 x cid3 zσ parameterfree noncontradictory cid3 Finally context literal K K cid3 x1 cid3 x2 Hence add x1 cid3 x2 context application Assert With new literal simplify c cid3 c c cid3 c c cid3 c Resolve obtaining v x cid3 0 0 cid3 x x1 cid3 x2 cid14 x cid3 y y cid3 z x cid3 z x cid3 0 0 cid3 x x cid3 0 x cid3 x 0 cid3 x x cid3 x c cid3 c We c cid3 c context means Assert Subsume obtaining v x cid3 0 0 cid3 x x1 cid3 x2 c cid3 c cid14 x cid3 y y cid3 z x cid3 z x cid3 0 0 cid3 x x cid3 0 x cid3 x 0 cid3 x x cid3 x 16 The literal pc instance context literal v pinstance v 606 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 With c cid3 c context apply Assert selected clause x cid3 0 x cid3 x substitution σ1 x cid5 c adding c cid3 0 context Similarly apply Assert selected clause 0 cid3 x x cid3 x add 0 cid3 c obtaining c cid3 0 0 cid3 c cid14 x cid3 0 0 cid3 x With c cid3 0 context substitution σ2 x cid5 c context uniﬁer x cid3 0 remainder Note apply Resolve selected clause x cid3 0 0 cid3 x substitution σ2 0 cid3 xσ cid10 0 cid3 x Similarly apply Assert selected clause x cid3 0 0 cid3 x substitution σ2 0 cid3 xσ contradictory context literal 0 cid3 c However apply Close selected clause x cid3 0 0 cid3 x substitution σ2 obtaining sequent cid14 cid2 This thanks context literals c cid3 0 0 cid3 c σ2 context uniﬁer x cid3 0 0 cid3 x remainder Note sequences rule applications possible given clause set However prove Section 4 described contained applications Split sequences guaranteed lead application Close But prove Section 4 conclude original clause set unsatisﬁable 35 Derivations We provide formal deﬁnition derivation Model Evolution calculus As customary sequent style calculi derivations ME deﬁned terms derivation trees node corresponds particular application derivation rule nodes children corresponds conclusions rule Deﬁnition 316 Derivation tree A derivation tree ME labeled tree inductively deﬁned follows 1 onenode tree derivation tree iff root labeled sequent form cid3 cid14 cid2 cid3 context cid2 clause set 2 A tree Tcid13 derivation tree iff obtained derivation tree T adding leaf node N T new children nodes N1 Nm sequents labeling N1 Nm derived applying rule calculus sequent labeling N In case Tcid13 derived T We derivation tree T derivation tree clause set cid2 iff root node tree labeled v cid14 cid2 Let nonleaf node derivation tree Split node sequents labeling children obtained applying Split rule sequent labeling node Similarly nodes rules applied Observe nonleaf node derivation tree child Split node case children When convenient cause confusion identify nodes derivation tree labels Deﬁnition 317 Open closed A branch derivation tree closed leaf labeled sequent form cid3 cid14 cid2 branch open A derivation tree closed branches closed open We derivation tree clause set cid2 refutation tree cid2 iff closed In rest paper letters n denote ﬁnite ordinal numbers letter κ denote ordinal smaller equal ﬁrst inﬁnite ordinal For κ denote possibly inﬁnite sequence a0 a1 a2 κ elements aiiκ Deﬁnition 318 Derivation A derivation ME possibly inﬁnite sequence derivation trees Tiiκ 0 κ Ti derived Ti1 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 607 We derivation D Tiiκ derivation clause set cid2 iff T0 onenode tree label v cid14 cid2 We D refutation cid2 iff D ﬁnite ends refutation tree cid2 We sections Model Evolution calculus sound complete following sense sets cid20 cid4clauses parameters cid20 unsatisﬁable iff cid20 refutation calculus To prove calculus completeness introduce notion exhausted branch derivation tree branch extended calculus A byproduct completeness proof interpretation induced context leaf open exhausted branch model clause set branchs root This means derivation clause set cid20 produces tree open exhausted branch possible state cid20 satisﬁable provide ﬁnite description model cid20 4 Correctness calculus In section prove soundness completeness Model Evolution calculus 41 Soundness To prove calculus sound ﬁrst prove derivation rules preserves particular notion satisﬁability asatisﬁability 4 Let ﬁx constant signature cid4skocid4 consider substitution α v cid5 av V mapping parameter a17 Given literal L denote La literal Lα Note La ground L variablefree Similarly given context cid3 denote cid3a set unit clauses obtained cid3 removing pseudoliteral v replacing literal L cid3 La considering unit clause Finally σ substitution denote σ composed substitution σ α We point later literals L substitutions σ ParLσ V includes parameterpreserving substitutions Lσ Laσ We sequent cid3 cid14 cid2 aunsatisﬁable iff clause set cid3a cid2 unsatisﬁable standard sense Herbrand models Lemma 41 For rule ME calculus premise rule asatisﬁable conclusions asatisﬁable Proof We prove claim rules Split Assert Resolve Close For rules claim holds trivially Split The premise Split form cid3 cid14 cid11 conclusions respectively form cid3 K cid14 cid11 sko cid14 cid11 Suppose cid3 cid14 cid11 asatisﬁable Now let cid16x x1 xn enumeration variables cid3 K K note K K exactly variables Then consider unit clause K explicitly cid16xK negation cid16xK Clearly sets S1 cid3a K cid11 S2 cid3a cid16xK cid11 satisﬁable If S1 satisﬁable immediately cid3 K cid14 cid11 asatisﬁable If S2 satisﬁable Skolemized form cid3a K easily cid3 K sko cid11 satisﬁable Since K sko cid14 cid11 asatisﬁable sko K sko Assert The premise Assert form cid3 cid14 cid2 L1 Ln L conclusion form cid3 Lσ cid14 cid2 L1 Ln L Lσ parameterfree contradictory cid3 n cid3 0 σ context uniﬁer L1 Ln cid3 remainder This means fresh K1 Kn cid11 cid3 σ simultaneous uniﬁer K1 L1 Kn Ln ParKiσ V 1 n Suppose cid3 cid14 cid2 L1 Ln L asatisﬁable cid3a cid2 L1 Ln L satisﬁable Observing ParKiσ V Li parameterfree easy σ simultaneous uniﬁer K1 L1 Kn Ln 17 Strictly speaking α substitution standard sense Domα ﬁnite But cause problems 608 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 Since Ki cid11 cid3a follows soundness resolution cid3a cid2 L1 Ln L Lσ satisﬁable Noting Lσ Lσ conclude cid3 Lσ cid14 cid2 L1 Ln L asatisﬁable Resolve The premise Resolve form cid3 cid14 cid2 L C conclusion form cid3 cid14 cid2 C general uniﬁer σ K L K cid11 cid3 ParKσ V ii Cσ C Suppose cid3 cid14 cid2 L C asatisﬁable means cid3a cid2 L C satisﬁable It easy point fact L parameterfree σ uniﬁer K L Observing K cid11 cid3a follows soundness standard resolution cid3a cid2 L C Cσ satisﬁable By point ii fact C parameterfree Cσ Cσ Ca C But entails cid3a cid2 C satisﬁable cid3 cid14 cid2 C asatisﬁable Close The premise Close form cid3 cid14 cid2 C conclusion form cid3 cid14 cid2 context uniﬁer σ C cid3 remainder As cid3 cid14 cid2 aunsatisﬁable cid3 cid14 cid2 C aunsatisﬁable We proving cid3a C unsatisﬁable Let C L1 Ln n cid3 0 Since σ context uniﬁer σ C cid3 remain der know fresh variants K1 Kn cid11 cid3 σ general simultaneous uniﬁer K1 L1 Kn Ln ParKiσ V 1 n Let ﬁx literals K1 Kn Clearly σ simultaneous uniﬁer K1 L1 Kn Ln By earlier observation know Kiσ aσ 1 n It follows σ simultaneous uniﬁer Ki K1 L2 Kn L1 K2 This entails K1 Kn mediately follows cid3a C unsatisﬁable cid2 Ln L1 Ln unsatisﬁable From fact K1 Kn cid11 cid3a im Proposition 42 Soundness For sets cid20 parameterfree cid4clauses cid20 refutation tree cid20 unsatisﬁable Proof Let T0 refutation tree cid20 We prove structural induction root subtree refutation tree aunsatisﬁable This entail particular v cid14 cid20 root T0 aunsatisﬁable The claim follow immediate fact sequent v cid14 cid20 aunsatisﬁable iff cid20 unsatisﬁable Let T subtree refutation tree let N root If T onenode tree N form cid3 cid14 cid2 trivially aunsatisﬁable If T node assume induction children nodes N aunsatisﬁable But conclude N aunsatisﬁable contrapositive Lemma 41 cid2 42 Fairness As customary prove completeness calculus respect fair derivations The speciﬁc notion fairness adopt deﬁned formally following For convenient tree T pair N E N set nodes T E set edges T Each derivation D Model Evolution calculus determines limit tree respect derivation trees D Deﬁnition 43 Limit tree Let D Tiiκ derivation Ti Ni Ei κ We cid10 cid11 cid12 cid11 Ni Ei T iκ iκ limit tree D It easy limit tree derivation D tree But note derivation tree D ﬁnite Deﬁnition 44 Persistency Let T limit tree derivation let B Niiκ branch T κ nodes Let cid3i cid14 cid2i sequent labeling node Ni κ We deﬁne following sets persistent context literals persistent clauses respectively P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 609 cid11 cid13 cid3B cid3j cid2B cid11 cid13 cid2j iκ icid2j κ iκ icid2j κ In words context literal persistent considered branch B iff appears context node context nodes descendants similarly persistent clauses Where cid4 signature ﬁrst clause set derivation consider set cid3cid4 B cid4literals cid3B excludes literal Skolem constants Although strictly speaking cid3B cid3cid4 B contexts inﬁnite purposes completeness proof treat We note deﬁnitions introduced Section 31 applied change cid3B cid3cid4 Fair derivations ME calculus deﬁned terms exhausted branches B Deﬁnition 45 Exhausted branch Let T limit tree let B Niiκ branch T κ nodes For κ let cid3i cid14 cid2i sequent labeling node Ni The branch B exhausted iff κ following hold For C cid2B Split applicable cid3i cid14 cid2i selected clause C productive context uniﬁer σ B context literal K σ remainder literal L σ j cid5 j κ K cid11 cid3cid4 cid3j produces L produce L ii For unit clauses L cid2B Assert applicable cid3i cid14 cid2i selected clause L selected literal L context uniﬁer j cid5 j κ literal K L cid3 K cid3j produces K produce K iii For C cid2B Close applicable cid3i cid14 cid2i selected clause C context uniﬁer σ K cid11 cid3B context literal K σ iv cid2i cid10 cid2 It worth noticing Point Deﬁnition 45 require Split eventually applied selected clause C context uniﬁer σ branch exhausted It requires intended effect applying Split selected clause C context uniﬁer σ achieved literal L Cσ permanently produced L produced Only property guaranteed interpretation induced limit context assigns true ground cid4instance L ground cid4instance Cσ A similar observation Point ii effect applying Assert selected unit clause L cid4instances L cid4instance L produced To Point ii operational Lemma A6 provide sufﬁcient condition According lemma add L context achieve desired effect Furthermore stated Point Deﬁnition 45 concerning context uniﬁer σ mentioned sufﬁces consider persistent clause C context literals σ persistent context cid4literals similarly Point iii Deﬁnition 45 That cid4literals cid3B need considered justiﬁed intuitively fact order determine satisﬁability input clause built signature cid4 ﬁnd Herbrand cid4model it18 That persistent literals cid3B need considered results important consequence design proof procedures completeness purposes clauses contexts need stored time instead sufﬁces maintain current context current clause setin addition backtracking information recovering Split applications led closed branch See 5 proof procedure lines Deﬁnition 46 Fairness A limit tree derivation fair iff refutation tree exhausted branch A derivation fair iff limit tree fair We point fair derivations deﬁned exist computable set parameterfree cid4clauses A proof fact given adapting technique 4 computability fair derivations FDPLL Moreover similarly FDPLL fair derivations need searched As 18 Notice Close restricted work cid4literals context 610 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 calculus proof convergent set cid2 cid4clauses unsatisﬁable fair derivation cid2 refutation 43 Completeness Our proof Model Evolution calculus complete based showing set cid3cid4 B persistent context cid4literals exhausted branch B limit tree denotes model clause set root tree We provide sketch completeness proof proving main results A complete proof auxiliary results properties contexts derivation rules stated appendix 431 Properties contexts We start general properties contexts use following Lemma 47 Let cid3 noncontradictory context Then literal L cid3 produces L cid3 produces L This lemma needed proof following proposition Proposition 48 Let cid3 noncontradictory context L ground literal If Icid3 satisﬁes L cid3 produces L Observe converse proposition hold general This seen considering context v P u P v b While context produces P b P b induced interpretation satisﬁes P b The converse Proposition 48 hold positive literals Proof If L positive literal claim follows trivially Deﬁnition 38 Hence suppose L negative literal It impossible cid3 produces L positive literal Deﬁnition 38 inter pretation Icid3 satisfy L satisfy L Now cid3 produce L follows Lemma 47 cid3 produces L cid2 432 Properties inference rules The following lemmas provide sufﬁcient conditions applicability main rules calculus given context We refer conditions prove completeness calculus We need characterize conditions Split applicable Their proof facilitated general lemmas The ﬁrst shows uniﬁcation identify clause instances false interpretation induced current context Lemma 49 Lifting lemma Let cid3 noncontradictory context Let C L1 Ln cid4clause Cγ ground cid4instance If cid3 produces L1γ Lnγ fresh variants K1 Kn cid11 cid3cid4 substitution σ 1 σ general simultaneous uniﬁer K1 L1 Kn Ln 2 1 n Li cid2 Liσ cid2 Liγ 3 1 n Ki produces Liσ cid3 In Section 3 mentioned calculus need search admissible context uniﬁers context uniﬁer composed renaming substitution obtained deterministically resulting context uniﬁer admissible This fact expressed following lemma Lemma 410 Existence admissible context uniﬁers Let cid3 context C clause σ context uniﬁer C cid3 Then renaming ρ σ cid13 σρ admissible context uniﬁer C cid3 context literals σ P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 611 It mentioned purpose lemma existence admissible context uniﬁer based possibly nonadmissible context uniﬁer A realistic implementation compute clever renaming tries maximize parameterfree literals resulting remainder19 For completeness purposes renaming yields admissible context uniﬁer clear proof Proposition 416 Now turn lemma stating conditions Split rule applicable Roughly Split applica ble selected clause admits context uniﬁer overlap Assert Close applicable selected clause Lemma 411 Split applicability Let cid3 cid14 cid11 C sequent noncontradictory context cid3 C contains literals If context uniﬁers C cid3 nonempty remainder σ admissible context uniﬁer C cid3 cid3 produces L remainder literal L σ Split applicable cid3 cid14 cid11 C selected clause C context uniﬁer σ The lemma provides sufﬁcient conditions applicability Assert unit clauses completeness Lemma 412 Assert applicability Let cid3 cid14 cid11 L sequent noncontradictory context cid3 If context uniﬁers L cid3 nonempty remainder instance Lσ L cid3 produces Lσ Assert applicable cid3 cid14 cid11 L selected clause L selected literal L substitution context uniﬁer 433 Main result In section let cid2 set parameterfree cid4clauses assume D fair derivation cid2 refutation Observe Ds limit tree exhausted branch We denote branch B Niiκ Then cid3i cid14 cid2i mean sequent labeling node Ni B κ As consequence cid30 v cid20 cid2 Quite appeal following compactness property cid3B By deﬁnition L cid3B holds iff κ L cid3j j cid3 j κ Similarly L cid11 cid3B meaning deﬁnition L cid11 K literal K cid3B κ K cid3j j cid3 j κ entails L cid11 cid3j j cid3 j κ More generally L1 Ln cid3B L1 Ln cid11 cid3B n cid3 0 κ L1 Ln cid3j L1 Ln cid11 cid3j j cid3 j κ20 Being noncontradictory fundamental property contexts manipulated calculus Essentially cause derivation rules produce noncontradictory contexts noncontradictory contexts obtain following result Lemma 413 cid3B contradictory The following lemma reduces productivity limit given branch productivity contexts branch Lemma 414 Let K L literals K cid3B If K produces L cid3B j cid3 j κ K cid3j K produces L cid3j Lemma 415 Close applicability Let C cid2B κ Close applicable cid3i cid14 cid2i selected clause C Then j cid5 j κ Close applicable cid3j cid14 cid2j selected clause C context uniﬁer σ K cid11 cid3B context literal K σ 19 See 21 discussion compute renaming 20 It easy index determined taking maximum iindices associated individually literals L1 Ln described 612 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 The following proposition fundamental states calculus computes model limit persistent clause set containing clause Proposition 416 If cid2 cid2B Icid3B model cid2B Proof Suppose ad absurdum cid2B contain clause Icid3B model cid2B This means ground cid4instance Cγ clause C L1 Ln n cid3 1 cid2B satisﬁed Icid3B Since Cγ satisﬁed Icid3B literals L1γ Lnγ satisﬁed Icid3B By Lemma 413 cid3B non contradictory Proposition 48 follows cid3B produces L1γ Lnγ We distinguish complementary cases depending n 1 n 1 lead contradiction In cases need fact Close applicable cid3i cid14 cid2i selected clause C κ This follows immediately Lemma 415 Close applicable cid3i selected clause C κ Close applicable cid3j j cid3 j cid5 κ K cid11 cid3B context literal K context uniﬁer This contradict Deﬁnition 45iii n 1 In case C consists single literal L1 For cid3B produce L1γ contain literal K produces L1γ cid3B By Lemma 414 j cid3 j κ K cid3j K produces L1γ cid3j 1 Since L1 unit clause cid2B icid13 L1 cid2j cid13 j cid13 cid3 icid13 Without loss generality assume cid3 icid13 icid13 instead sequel As shown Close particular applicable cid3i cid14 cid2i selected clause L1 Since L1 cid2i context uniﬁers L1 cid3i nonempty remainder Together 1 implies Lemma 412 Assert applicable cid3i cid14 cid2i selected clause L1 selected literal L1 context uniﬁer According Deﬁnition 45ii j cid3 j κ literal L L1 cid3 L cid3j produces L produce L Recall clauses sequents parameterfree implies L1 cid3 L1γ But taking L L1γ contradiction assertion 1 implies cid3j produces L1γ n 1 By Lifting Lemma Lemma 49 fresh pvariants K1 Kn cid11 cid3cid4 B substitution σ 1 σ general simultaneous uniﬁer K1 L1 Kn Ln 2 k 1 n Lk cid2 Lkσ cid2 Lkγ 3 k 1 n Kk produces Lkσ cid3B By Deﬁnition 39 σ productive context uniﬁer C cid3B By Lemma 410 admissible context uniﬁer C cid3B obtained σ cid13 σρ renaming ρthat context literals K1 Kn σ Let k 1 n observe literal K produces literal L context cid3 iff K produces variant L cid3 From fact Kk produces Lkσ cid3B Kk produces Lkσ cid13 cid3B By applying Lemma 414 Kk Lkσ cid13 individually k 1 n taking maximum indices mentioned lemmas statement conclude j cid3 j κ Kk cid11 cid3cid4 2 By assumption C clause cid2B Hence icid13 C cid2j cid13 j cid13 cid3 icid13 Without loss generality suppose cid3 icid13 icid13 instead sequel j Kk produces Lkσ cid13 cid3j As shown Close particular applicable cid3i cid14 cid2i selected clause C Therefore context uniﬁers C cid3i nonempty remainder By 2 generality k Kk cid11 cid3cid4 produces Lkσ cid13 cid3i k 1 n particular cid3i produces remainder literals σ cid13 By Lemma 411 Split applicable cid3i cid14 cid2i selected clause C productive context uniﬁer σ cid13 Recall literal Kk pvariant cid3cid4 B 2 cid3i Because Deﬁnition 45i remainder literal L σ cid13 j cid3 cid3j produces L j produces L cid2 cid3j produce L However contradicts conclusion 2 entails cid3cid4 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 613 The completeness calculus consequence Proposition 416 We state contrapositive form underline model computation abilities ME Theorem 417 Completeness Let cid2 parameterfree cid4clause set let D fair derivation cid2 limit tree T If T refutation tree cid2 satisﬁable speciﬁcally exhausted branch B T Icid3B model cid2 Let cid18 universally true clause For clause C cid2 deﬁne C0 C 0 Ci D cid18 Ci1 form L D Resolve applied selected clause Ci1 selected literal L cid3i1 cid14 cid2i1 obtain cid3i cid14 cid2i Ci1 form L D Subsume applied selected clause Ci1 selected literal L cid3i1 cid14 cid2i1 obtain cid3i cid14 cid2i Ci1 Observe cid3 0 Ci C cid2 cid2i cid18 Proof Let C clause cid2 B exhausted branch T It Icid3B model C Now easy smallest j Ci Ci1 j κ means Cj cid18 persistent clause B Let ﬁx j We induction Icid3B model Ci cid5 j immediately follow Icid3B model C C0 j If Ci cid18 Icid3B trivially model Ci Hence assume Ci persistent clause B Ci cid2B By Proposition 416 cid2B contain clause Assume contradiction cid2B cid2cid13 cid2 clause set cid2cid13 That cid2B contains clause entails trivially cid2k contains clause k cid3 0 k k cid2 That cid2cid13 holds impossible cid10 But substitution certainly context uniﬁer k cid2 selected clause cid2 impossible κ That k cid3k cid14 cid2k form cid3k cid14 cid2cid13 Deﬁnition 45iv Hence suppose cid2cid13 k cid2 cid3k remainder Close applicable cid3k cid14 cid2cid13 Deﬁnition 45iii It follows Icid3B model Cj j Assume induction hypothesis Icid3B model Ci1 consider following cases k depending deﬁnition Ci1 If Ci Ci1 conclude immediately Icid3B model Ci ii If Ci form L D Resolve applied selected literal L cid3i cid14 cid2i obtain cid3i1 cid14 cid2i1 Ci1 D It follows immediately Icid3B model Ci iii If Ci form L D Subsume applied selected clause Ci cid3i cid14 cid2i obtain cid3i1 cid14 cid2i1 Ci1 cid18 By deﬁnition Subsume K cid3i K cid3 L By Lemma A15 K cid13 cid3B K cid13 cid3 K It follows K cid13 cid3B K cid13 cid3 L Recalling C cid2 parameterfree cid4clause deﬁnition Ci subclause C Ci parameterfree cid4clause L parameterfree cid4literal From fact K cid13 cid3 L follows K cid13 parameterfree K cid13 cid3 Lγ grounding substitution γ Let Lγ ground cid4instance Now K cid13 cid3B K cid13 cid3 Lγ Lemma A6 cid3B produces Lγ produce Lγ It follows deﬁnition Icid3B Icid3B satisﬁes Lγ Because Lγ arbitrary ground cid4instance L deduce Icid3B model L Ci cid2 When branch B Theorem 417 ﬁnite cid3B coincides context cid3n Bs leaf From model computation perspective crucial point means model original clause setor ﬁnite representation cid3nis readily available end derivation computed branch model generation calculi 614 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 The calculus proof conﬂuent 10 derivation unsatisﬁable clause set extends refutation In fact strong completeness result Theorem 417 calculus satisﬁes stronger property refer proof convergence Corollary 418 Proof convergence Let cid2 parameterfree clause set signature cid4 If cid2 unsatisﬁable fair derivation cid2 refutation In practical terms corollary implies long derivation strategy guarantees fairness order application rules calculus irrelevant proving input clause set unsatisﬁable giving ME calculus kind ﬂexibility enjoyed DPLL calculus propositional level 5 Implementation At theoretical level development ME calculus motivated desire close existing gap theorem proving landscape provide proper lifting ﬁrstorder logic popular refutation method propositional logic DPLL At practical level calculus motivated conjecture successful improvements developed SAT community DPLL lifted suitable ﬁrstorder version prove similarly effective To verify conjecture devised proof procedure ME calculus turned implementation Darwin theorem prover21 We evaluated Darwin experimentally TPTP problem library 46 comparing stateoftheart theorem provers based calculi ﬁrstorder logic Our experiments shown ME calculus lends competitive implementations ﬁrstorder logic equality In particular Darwin currently competitive input problems large percentage nonHorn clauses Furthermore best prover functionfree clause sets correspond problems belonging BernaySchönﬁnkel class Darwin fact decision procedure In section main aspects Darwins proof procedure implementation For detailed account Darwins general architecture proof procedure heuristics implementation details detailed experimental evaluation refer reader 5 Iterative deepening proof procedure Similarly DPLL procedure Darwins proof procedure seen exploring depthﬁrst fashion limit tree derivation calculus Since ME calculus refutationally complete fair derivations proof procedure sure gives rise fair derivations This achieved performing sort iterative deepening search depth search tree term depth certain literals complexity measure based depth terms tree representation Speciﬁcally moment Darwin maintains current context clause set corresponding node derivation tree current set candidate literals literals added context Assert Split application The proof procedure chooses addition context candidate literals term depth exceed current term depth bound Since design inference rules impossible context contain pvariants literal selection strategy implies termination exhaustive sequence inference rule applications term depth bound22 After applying exhaustively inferences rules respect current bound able close current branch derivation tree Darwins proof procedure checks branch incomplete This case generation branch candidate literal computed exceeded current depth bound If current branch incomplete denotes model input set proof procedure reports Otherwise procedure behaves according strategies initially speciﬁed user With simplest strategies procedure restarts derivation scratch increased depth bound 21 This work collaboration Alexander Fuchs Darwins main developer 22 This termination property immediately obvious inﬁnite supply Skolem constants Split inferences Referring Example 313 argued branch contain Skolemized version literal Split inferences problematic regard P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 615 Backtracking In exploring derivation tree Darwins proof procedure generates choice point left application Split rule The depthﬁrst exploration term depth bound derivation tree achieved backtracking previous choice point time branch closed Instead going recent choice point Darwin implements backjumping effective form chronological backtracking takes account dependencies choice points The idea backjumping best explained terms calculus suppose derivation subtree left node introduced Split rule application closed literal added left conclusion application needed establish subtree closed Then Split rule application viewed carried The proof procedure skip corresponding choice point backtracking proceed previous Backjumping known effective improvements DPLLbased SAT solvers Its imple mentation ME difﬁcult relies keeping track context literals clauses involved particular Assert Close rule applications Backjumping example successful propositional technique directly lifts proof procedure Darwin Darwin features dynamic backtracking 26 sophisticated form nonchronological backtracking See 5 details Conﬂictbased learning Another major conceptual improvement DPLLbased solvers years lemma learning mech anism generating new propositional clauses prevent later search combinations split decisions led closed subtrees derivation Something similar ME based prover analyzing sequence rule applications closed branch The analysis determines Split inferences branch relevant allowing application Close saves information split choices similar choices lead conﬂict avoided later search As DPLL SAT solvers convenient way save information form clause added clause set applications Assert clause block prevent repetition later Split inference caused conﬂict In contrast backjumping adapting DPLL learning methods ME based prover immediate ﬁrst cause needs lift properly ﬁrstorder level lemma generation process generates lemmas prune search space second process carried ﬁrstorder level bound add signiﬁcant computational overhead offset practice advantages pruning On hand working ﬁrstorder level offers enticing possibility achieving learning proper sense word lemmas helping prune areas search space duplicate previously explored ones Darwin successfully implements variants learning mechanism lifts main features learning methods DPLL procedures In variants lemmas generated guided resolution process starts selected clause Close inference closing branch uses selected number clauses involved Assert inference branch A description variants positive effects Darwins performance given 6 Context uniﬁers selection heuristics The central operation Darwins proof procedure computation possible context uniﬁers current clauses current context The computes context uniﬁers current clauses identify literals added context Split rule Split candidates context uniﬁers subsets input clauses identify literals added Assert rule Assert candidates The set context uniﬁers built incrementally exhaustively context grows With technique possible Assert candidates ea gerly added context correspond eager unit propagation mechanism DPLL Also theoretically necessary Split candidates point available inspection allowing implementation heuristic selec tion mechanisms choosing best literals split The current selection heuristics Darwin based considerations candidate contains variables adding cause proper branching derivation tree Darwin uses special data structures dynamic programming techniques compute store context uniﬁers goal limiting runtime memory requirements In addition uses term indexing techniques 616 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 context support fast checking preconditions Split Assert Subsume rules23 More details context uniﬁcation Darwin 5 6 Related work Approaches features common ME come following categories ﬁrstorder DPLL methods instancebased methods Resolution methods Tableau methods 61 Firstorder DPLL methods A lifted version DPLL method described early textbook automated reasoning Chang Lee 12 It uses device pseudosemantic trees like ME realize splits nonground level Nevertheless pseudosemantic tree method different approach sharp contrast ME variable treated rigidly placeholder notyetknown term24 Section 64 discusses rigid variable methods said applies method 12 A recent attempt incorporate ﬁrstorder reasoning DPLL 2739 Instead instan tiating input clauses ground ones applying DPLL method modiﬁed DPLL method 2739 directly takes advantage ﬁrstorder clauses input clause set More speciﬁcally clauses unit propagation basis current partial propositional model candidate In terms corresponds working ground contexts Assert rule similarly ME adding ground instance Assert literal context In 2739 proven unit propagation kind includes NPcomplete search problem course applies ME However argued time compact representations enabled ﬁrstorder logic pay A fundamental difference approach 2739 restricted checking satisﬁability quantiﬁer formulas ﬁnite models ME works ﬁrstorder logic The closest relative ME calculus FDPLL calculus developed 4 As mentioned introduction ME loosely based FDPLL More precisely ME calculus specialized core FDPLL calculus 1 removing Subsume Resolve Compact inference rules optional ME 2 restricting Split use admissible context uniﬁers variablefree remainder25 In terms present paper core calculus FDPLL simpliﬁcation rules deal variablesit uses parameters However 4 extension core FDPLL calculus include reasoning variables sketched Contrary ME mixed literals allowed literals splits typevariablefree parameterfree Even ignoring aspect ME stronger version FDPLL Expressed ME terms rules mentioned 1 available FDPLL Furthermore admissible context uniﬁers deﬁned satisfy restriction 2 unit remainder use parameterfree context literals In resolution terminology FDPLL mimics unitresulting resolution roughly Horn clause subset input clause set The impact limited capabilities FDPLL seen looking examples For instance current context cid3 v given clause P x Qy Rz FDPLL consider clause instance P u Qv Rw split based literals contain parameters In contrast ME essence carry case analysis according literals P x Qy Rz advantage containing variables instead parameters26 23 These preconditions require essence search context literals unify subsume subsumed given literal 24 However term rigid introduced time book 12 written 25 Using admissible context uniﬁers preserves completeness ME 26 As discussed Section 3 variables context literal place parameters constraints imposes derivation P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 617 As example consider context cid3 v P u1 u2 Qx z clause Ry z P x x Qx y z Based admissible context uniﬁer σ v cid5 Ra z u1 cid5 u2 x cid5 u2 y cid5 a27 sole remainder literal Ra z Split rule applicable ME A comparable inference step possible FDPLL involved context literals P u1 u2 parameterfree In conclusion presence simpliﬁcation inference rules Subsume Resolve Compact better treatment variables ME calculus improves signiﬁcantly FDPLL 62 Instancebased methods Besides FDPLL calculus ME related family instancebased methods Proof search instancebased methods relies maintaining set instances input clauses analyzing satisﬁability completion We point ME instancebased method sense clause instances temporarily Split inference rule forgotten split carried The contemporary stream research instancebased methods initiated Hyperlinking calculus HL 32 This calculus based idea steadily growing set instances input clauses intelligent way regularly testing propositional unsatisﬁability integrated DPLL procedure An important conceptual difference ME HL includes DPLL procedure directly extend ﬁrstorder clause logic The current successor HL Ordered Semantic Hyperlinking calculus OSHL 4142 OSHL interesting features instance semantical guidance assuming procedural representation inter pretation capable decide given ground literal true interpretation As ME main operation OSHL detect instance clause false current interpretation repair interpretation sense given However unlike ME repairs carried ground literals Some instancebased calculi formulated clausal tableau framework Similar ME unlike HL successors extend propositional methodthis time propositional clausal tableauxto ﬁrst order level resorting separate propositional solver The initial work direction Billons disconnection method 11 followed calculus described 3 relates disconnection method pretty way hyperresolution calculus relates resolution calculus The disconnection method picked Letz Stenz improvements efﬁciently imple mented competitive prover 43 The disconnection calculus uses clausal tableau primary data structure The tableau structure represents exhaustive search possible connections literals clauses single inference rule extends current tableau clause instances connection branch Thus disconnection calculus conceptually different ME main derivation rule based resolving pairs complementary literals clauses ME s splitting rule based evaluating literals single clause candidate model In 34 improvements disconnection calculus discussed Among dedicated inference rule deriving unit clauses Interestingly variables derived unit clause identiﬁed sound ness reasons Still inference rule represents limited local form lemma learning direct counterpart ME calculus Directly comparable ME recent developments introduced 44 The disconnection calculus works kinds variables shared local ones The shared variables correspond parameterswhich present form instancebased methods A variable qualiﬁes local variable occurs literal clause instance considered tableau expansion There roughly corresponding requirement admissible context uniﬁers variable occurring remainder literal occur remainder literal The correspondence perfect clause instances tableau expansion derived differently ME 44 Nevertheless concepts comparable use subsumption tests similar Two variants instancebased method described Hooker et al 29 One Primal Approach similar disconnection method unfortunately relation method 27 For simplicity loss generality case taking fresh variants context literals computing context uniﬁers 618 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 explicit 29 The variant Dual Approach differs presence auxiliary clauses form K L generated proof search K L connection literals occurring current clause set No simpliﬁcation mechanisms described instance based unit propagation rules Both methods compare ME way disconnection method discussed Finally abstract framework instancebased calculi admits simpliﬁcation techniques scribed 22 The underlying idea work propositional abstraction candidate model input clause set That abstraction guide search refutation ﬂexible way As Hyper linking calculi signiﬁcant difference ME disconnection calculus matter framework 22 relies execution propositional satisﬁability tests This advantage offtheshelf SAT solvers readily tests On hand unclear exploit ﬁrstorder features like variables local variables disconnection calculus relying propositional solver However shown 22 treating certain variable occurrences special way times possible replace SAT solver decision procedure fragment ﬁrstorder logic This way decision procedure lifted work input formulas outside fragment 63 Resolution methods Resolution calculi conceptually different ME calculus makes comparison difﬁcult A common feature model generation Modern completeness proofs resolution calculi provide method structing model saturated clause set containing clause 2 However conceptual construction nontrivial postprocessing necessary extract model practice failed refutation 23 Typically model computed enumerating true ground literals interleaving enumeration calls resolution procedure order determine ground literal 1617 64 Tableau methods Apart clausal tableau methods instancebased methods discussed clausal tableau calculi general related ME encoding like ME model given clause set exhausted open branch For comparison purposes useful classify calculi according treat variables rigidly instantiate ground terms In tableau calculi rigid variables variable tableau placeholder notyetknown term 20 basic version The meaning rigid variables captured constraints 244048 Although tableau calculi proof conﬂuent practically usable fair strategies achieve proof convergence cf Corollary 418 hard devise 9 Another drawback rigid variables difﬁcult ﬁnd useful redundancy mechanisms instance general prevent unbounded number variants literal branch More concretely given unit clause P x simple justiﬁcation enumerating variants P x P xcid13 P xcid13cid13 P x branch In fact general contrary ME variant completeness difﬁcult automatically determine sharp bounds numbera discussion options design rigid tableau calculi including constraintbased approaches 25 Groundlevel tableau calculi avoid problems rigid variables resorting propositional level While analytic tableau classical γ rule suitable basis build competitive theorem provers structural reﬁnements clause logic related hyper resolution 736 Ordered Semantic Hyper Tableaux 49 However methods suffer generally unavoidable dontknow nondeterminism lead enumeration Herbrand base branch Finally contrast ME tableau calculi includes disconnection calculus branch subformulas literals clause clausal case opposed complementary literals For propositional case easy branching complementary literals ME general branching clauses In fact branching clause n literals simulated n splits complementary literals Furthermore improvements like factoring 33 automatically realized branching complementary literals approach A systematic investigation fact exactly carries ﬁrstorder caseie ME vs certain clausal tableau calculiis left future work P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 619 7 Conclusions In paper introduced Model Evolution ME calculus refutation calculus ﬁrstorder clausal logic The ME calculus extends wellknown propositional DPLL procedure ﬁrstorder logic means uniﬁcationbased ﬁrstorder versions DPLLs main inference rules In fact calculus lifting DPLL ﬁrstorder level reduces DPLL case ground clause sets Compared immediate predecessor FDPLL 4 ME faithful lifting DPLL lifts DPLLs inference rules unit propagation Except termination unachievable general ﬁrstorder case calculus enjoys theoretical properties DPLL sound complete fair derivations proof convergent The property particular implies fair proof procedure ME guaranteed produce refutation unsatisﬁable input clause sets Also like DPLL calculus terminating derivations satisﬁable clause set effectively compute model set Our experience implementing ME calculus conﬁrms validity idea lifting DPLL im provements ﬁrstorder level The performance Darwin theorem prover ME compares favorably mature stateoftheart provers class TPTP problems equality supe rior selected nontrivial subclasses Furthermore potential lifted DPLL idea untapped given moment Darwin implements major improvements developed DPLL In general room research properly lift adapt DPLL improvements ﬁrstorder logic devising new improvements directly ﬁrstorder level 71 Further research We envision directions future theoretical work ME calculus implementations A listed Semantical guidance As presented ME calculus starts interpretation assigns false ground atoms By simply replacing pseudoliteral v v possible calculus start instead complementary initial interpretation The kind semantic guidance achieved OSHL 42 means userdeﬁned initial terpretation trivially achievable ME interpretation denotable context simply starts derivation context More work needed allow ME start arbitrary interpretations particular ones encoded ﬁnite context Equational theories equality In theorem proving applications explicit treatment equality mandatory To knowledge instancebased methods extended dedicated equality inference rules equational clausal logic One disconnection calculus 35 instancebased method 22 Both extended calculi based superpositionstyle inference rules 1 second including powerful redundancy criteria Our initial results extension ME inference rules equality reasoning presented 8 Further work concentrate building efﬁcient competitive implementation new calculus ME decision procedure A deduction capable deciding relevant classes formulas usually greater practical mere refutation disprove false theorems software veriﬁcation context The ME calculus guaranteed terminate clauses resulting translation clausal form junctions BernaysSchönﬁnkel formulas28 gives decision procedure29 The holds instancebased methods Section 62 interestingly known reﬁnement resolution calculus 28 Such clauses contain function symbols restrictions apply 29 This easy consequence fact pvariants literal sequent derivable ME cf Lemma A14 620 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 On hand reﬁnements resolution calculus decide 18 classes formulas obvi ously decidable ME instance based methods It interesting investigate ways reﬁne ME decide classes classes currently decided resolution methods Acknowledgements We thank Alexander Fuchs helpful comments paper outstanding work Darwin prover We thankful Thomas Hillenbrand Yevgeny Kazakov Konstantin Korovin open discussions ME Appendix A This appendix contains auxiliary lemmas proofs proofs results stated main paper It structured parts Section A1 collection results contexts general necessarily contexts evolve derivations The subject Section A2 The subsequent Section A3 contains lemmas stating conditions mandatory inference rules ME applicable The results collected employed Section 43 prove main theorem completeness ME A1 Properties contexts The ﬁrst lemma concerned contexts needed proofs Lemma A1 For literal L sets K K cid3 L cid11 K K cid2 L cid11 ﬁnite That given literal L ﬁnitely general literals wrt cid3 L modulo pvariantship similarly cid2 A similar result formulated terms cid2 proven 15 Proof Since K cid2 L K cid3 L set K K cid2 L cid11 ﬁnite In following argumentation prove claim tree representation literals L literal tree representation ordered tree root labeled predicate symbol literal inner nodes labeled function symbols leaf nodes labeled constant variable symbols obvious way Recall K cid3 L means ppreserving substitution σ Kσ L This means tree L obtained replacing variable leaf node x tree K tree xσ similarly parameters Clearly number nodes K equal number nodes L Now let x1 xn X u1 V ﬁnite sets n pairwise different variables n pairwise different parameters respectivelywhere n number nodes tree representation L Let K literal K cid2 L K contains variables parameters ﬁnite sets mentioned Because number nodes K equal number nodes L follows assumed ﬁnite sets variables parameters ﬁnitely literals K cid2 L exist Let K ﬁnite set literals Notice K ﬁnite signature consideration contains inﬁnitely function symbols This holds K contain function symbol occurring L K instantiated L occur ﬁnitely function symbols L Clearly literal K K cid2 L cid11variant literal K Therefore K ﬁnite K K cid2 L cid11 cid2 Lemma A2 Let cid3 context let K L literals If K cid3 L L cid2 cid3 K contradictory cid3 In words complement literal cid3 K admit common pinstance K contradictory cid3 Most times lemma weaker form K L P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 621 Since calculus works noncontradictory contexts lemma implies context contains literal complement pinstances Proof Suppose K cid13 cid3 K cid13 cid3 L K cid3 L Let K cid13cid13 cid11 K cid13 fresh pvariant K cid13 With K cid13 cid3 L follows K cid13cid13 cid3 L Let σ ppreserving substitution K cid13cid13σ L Since K cid13cid13 fresh σ assumed variables parameters K cid13cid13 Therefore σ modify L L Lσ follows Altogether K cid13cid13σ Lσ Because K cid3 L ppreserving substitution σ cid13 Kσ cid13 L This implies Kσ cid13σ Lσ Since K cid13cid13 fresh σ cid13 assumed modify K cid13cid13 K cid13cid13 K cid13cid13σ cid13 follows With K cid13cid13σ Lσ follows K cid13cid13σ cid13σ Lσ Together Kσ cid13σ Lσ follows K cid13cid13σ cid13σ Kσ cid13σ But σ cid13 σ ppreserving K cid13cid13 cid11 cid3 K contradictory cid3 cid2 Lemma A3 Let cid3 context K cid3 K cid13 L literals If K cid3 L K cid13 shields L K K cid13 contradictory cid3 The previous lemma implies literal context produced ME calculus shield pinstance literal context This fact easily entails results Proof Suppose K cid3 L K cid13 shields L K This means literal K cid13cid13 K cid13 cid3 K cid13cid13 K cid2 K cid13cid13 cid2 L Let σ σ cid13 ppreserving substitutions Kσ L K cid13σ cid13 K cid13cid13 Without loss generality assume K cid13cid13 contain single variable If case let ρ ppreserving substitution maps K cid13cid13s variables fresh parameter observe K cid13 cid3 K cid13cid13ρ K cid2 K cid13cid13ρ cid2 L hold sequel K cid13cid13 denote K cid13cid13ρ We distinguish exhaustive cases ﬁrst case directly lead proof conclusion second case shown impossible If K cid3 K cid13cid13 implies K cid13cid13 cid2 cid3 K cid13 cid3 K cid13cid13 follows immediately Lemma A2 K cid13 contradictory cid3 If K cid10cid3 K cid13cid13 K cid2 K cid13cid13 K cid13cid13 cid2 L conclude substitutions δ δcid13 Kδ K cid13cid13 K cid13cid13δcid13 L δ ppreserving For later use note Kδδcid13 L Let U u1 ParK pairwise different parameters K parameters u1 n cid3 0 With Kσ L σ ppreserving subset v1 vn Ls parameters σ maps U parameters v1 vn Without loss generality assume uiσ vi 1 n Of course parameters v1 vn pairwise different From Kδδcid13 L Kσ L follows uiδδcid13 vi Clearly uiδ variable parameter uiδδcid13 vi impossible However K cid13cid13 assumed contain single variable With Kδ K cid13cid13 follows stronger result uiδ parameter Now impossible bijection U U δ exists U set parameters K substitution δU substitution δX combined ppreserving substitution δU δX KδU δX K cid13cid13 follow contradicting current case K cid10cid3 K cid13cid13 This implies δ identiﬁes parameters U u1 u2 But u1δ u2δ impossible u1δδcid13 v1 u2δδcid13 v2 v1 cid10 v2 Hence case K cid10cid3 K cid13cid13 impossible remained shown cid2 Lemma A4 Let cid3 noncontradictory context K cid3 Then literal L K cid3 L K strongly covers L cid3 Proof Let L literal K cid3 L It follows immediately K cid2 L If K strongly cover L cid3 literal K cid13 cid3 shields L K cid3 But Lemma A3 K cid13 contradictory cid3 Since cid3 given noncontradictory literal K cid13 cid3 K strongly covers L cid3 cid2 Lemma A5 Let cid3 noncontradictory context K L literals If K strongly covers L cid3 K produces L cid3 622 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 This lemma states strongly covers relation stronger produces relation That converse lemma hold seen Example 37 Proof Suppose K strongly covers L cid3 It follows K covers L cid3 If K cid13 cid3 shields L K Lemma A3 K cid13 contradictory cid3 Since cid3 given noncontradictory literal K cid13 cid3 K produces L cid3 cid2 Lemma A6 Let cid3 noncontradictory context K cid3 Then literal L K cid3 L K produces L cid3 ii cid3 produce L Proof Let L literal K cid3 L That K produces L cid3 follows immediately Lemmas A4 A5 To cid3 produce L let K cid13 cid3 literal K cid13 cid2 L30 We K cid13 produce L cid3 From given assumption K cid3 L follows Lemma A4 K strongly covers L cid3 b K shields L K cid13 Together K cid13 cid3 implies K cid13 produce L cid3 cid2 Lemma 47 Let cid3 noncontradictory context Then literal L cid3 produces L cid3 produces L Proof Let L literal We directly prove cid3 produces L cid3 produces L Due presence pseudoliteral v cid3 cid3 covers L case v covers L cid3 possible More precisely K cid3 literal K cid13cid13 cid3 K cid2 K cid13cid13 cid2 L K cid2 K cid13cid13 cid2 L This possible ﬁnitely literals K cid13cid13 modulo renaming K cid13cid13 cid2 L K cid13cid13 cid2 L cf Lemma A1 relation cid2 strict partial ordering admit cycles For reasons symmetry consider sequel case K cid2 L K cid13cid13 cid3 K cid2 K cid13cid13 cid2 L Observe means K covers L cid3 By condition 2 Deﬁnition 36 K cid13 cid3 strongly covers L cid3 shields L K K produces L cid3 Otherwise K cid13 cid3 Lemma A5 K cid13 produces L cid3 Together shown cid3 produces L cid3 produces L cid2 Lemma A8 Let cid3 context K K cid13 L literals If K produces L cid3 K cid2 K cid13 cid2 L K produces K cid13 cid3 Proof Suppose K produces L cid3 K cid2 K cid13 cid2 L We K produces K cid13 cid3 Clearly K cover K cid13 cid3 K cover L cid3 contradicting K produces L cid3 Now K produce K cid13 cid3 K cid13cid13 cid2 cid3 K cid2 K cid13cid13 cid2 K cid13 But K cid13 cid2 L follow K cid2 K cid13cid13 cid2 L K produce L cid3 cid2 The lemmas complement Their prerequisites mean L contradictory cid3 witnessed literal K cid11 cid3 The ﬁrst lemma considers case L parameterfree second lemma considers case L variablefree Both lemmas express literal K cid13 cid11 K rôle K A2 Evolving contexts Derivations stepwise modiﬁcations sequents This subsection contains lemmas mainly describing constraints contexts sequents evolve derivation One constraint instance impossible derive sequent context contains pvariants literal For rest section assumptions stated beginning Section 433 In particular let cid2 set parameterfree cid4clauses assume D fair derivation cid2 refutation 30 If literal exist cid3 produce L P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 623 Furthermore let B Niiκ exhausted branch Ds limit tree let cid3i cid14 cid2i denote sequent labeling node Ni B κ Lemma A9 For κ cid3i contradictory Being noncontradictory fundamental property contexts manipulated calculus Lemma A9 essen tially says rule applications produce noncontradictory contexts noncontradictory contexts Proof The proof induction For base cid30 v set trivially contradictory For induction step induction hypothesis claim lemma Observe inference rule extends context includes applicability condition resulting contexts contradictory With observation induction step follows immediately cid2 The lemma extends previous limit case Lemma 413 cid3B contradictory Proof Suppose cid3B contradictory Then literals L cid3B K cid11 cid3B ppreserving substitution σ Lσ Kσ By compactness property j L cid3j K cid11 cid3j By virtue substitution σ cid3j contradictory However impossible Lemma A9 cid2 Lemma A11 The sequent cid3 L cid14 cid11 derivable sequent cid3 cid14 cid11 B L cid2 cid3 L cid2 cid3 Lemma A11 states inference rules ME calculus add literal context presence general wrt cid3 One fact expresses kind loop check Proof It sufﬁces consider potential applications Split Assert inference rule cid3 rules extend context By applicability conditions Split Assert inference rules context cid3 extended literal L L contradictory L Now L cid2 cid3 Lemma A2 L contradictory cid3 case Split Assert applicable Hence remains shown sequent cid3 L cid14 cid11 derivable cid3 cid14 cid11 L cid2 cid3 Split Recall Split rule applicable K K contradictory cid3 K remainder literal split We consider cases corresponding case literal L lemma statement K K contradictory cid3 In cases Split applicable showing K K In ﬁrst case literal L lemma statement K That K cid2 cid3 holds means literal K cid13 cid3 sko sko sko ppreserving substitution σ K cid13σ K Let μ Skolemizing substitution substitution μ Kμ K sko From K cid13σ K follows trivially K cid13σ μ Kμ Since σ μ ppreserving K cid13 cid3 Kμ With Kμ K sko K cid13 cid3 K sko equivalently K cid13 cid3 K contradictory cid3 This completes proof ﬁrst case In second case literal L lemma statement K Since K cid13 cid3 means words K sko cid2 cid3 holds means literal sko cid2 cid3 But Lemma A2 K That K sko sko sko K cid13 cid3 ppreserving substitution σ K cid13σ K sko Let μ Skolemizing substitution substitution μ Kμ K sko It written μ x1 cid5 a1 xn cid5 x1 xn variables occurring K a1 fresh constants Now constants a1 fresh occur K This means consider substitution μcid13 a1 cid5 x1 cid5 xn K Kμμcid13 K skoμcid13 From K cid13σ K follows trivially K cid13σ μcid13 K μcid13 sko sko 624 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 Recall substitution σ ppreserving We assume variables moved σ variables K cid13 variable K cid13 moved σ Skolem constant ai K cid13σ K holds It follows substitution σ μcid13 renaming V variable K cid13 moved variable xi necessarily injective way More formally K cid13 cid3 K cid13σ μcid13 holds sko Now K cid13σ μcid13 K sko μcid13 K K skoμcid13 easily K cid13σ μcid13 K Since K cid13 cid3 means words K cid2 cid3 But Lemma A2 K contradictory cid3 This completes proof second case contradictory cid3 remained shown Together K K Assert The proof immediate applicability condition Assert explicitly demands sko K cid3 K cid3 L cid2 In course development branch literal sequents context deleted means Compact rule Such deletion possible presence psubsuming literal takes rôle deleted literal This process continue formalized following deﬁnition Deﬁnition A12 Let K literal For κ L cid3i trace L cid3i sequence Lj icid2j κ Lj L j j Lj K Lj 1 Compact applied selected literal Lj 1 subsuming literal K cid3j 1 cid14 cid2j 1 obtain cid3j cid14 cid2j Lemma A13 Let κ L cid3i For j cid5 j κ K cid3j K cid3 L While growing branch ME calculus delete literal current context means Compact rule Such deletion possible addition psubsuming literal takes rôle deleted literal The psubsuming literal deleted later similar way Lemma A13 formal statement process Proof Consider trace Lj icid2j κ L cid3i Each literal Lj trace cid5 j κ contained cid3j Lj cid3 L holds construction trace cid2 Lemma A14 For distinct literals K L cid14 iκ cid3i holds K cid10cid11 L Lemma A14 states context branch B contains literal K context contain pvariant L K This holds K deleted point branch cid14 Proof Assume way contradiction K cid11 L different literals K L iκ cid3i Notice ﬁrst K L pseudoliterals form v context cid30 contains exactly pseudo literal calculus inference rules add delete If K L pseudoliteral lemma holds trivially Hence assume K L pseudoliteral There ﬁnite ordinals j k L cid3j K cid3k Wlog assume j cid3 k Furthermore j k chosen minimal L cid3j 1 K cid3k1 This means inference rule applied node Nj 1 extends context cid3j 1 L obtain cid3j similarly K Observe inference rules ME extend given context literal In particular K added cid3j 1 considered inference rule application Thus j cid3 k j k hold But Lemma A13 literal K cid13 cid3j 1 K cid13 cid3 K Together K cid11 L follows imme diately K cid13 cid3 L However according Lemma A11 considered inference rule application extends cid3j 1 L possible A plain contradiction Thus K cid10cid11 L cid2 Lemma A15 For κ L cid3i K cid3B K cid3 L P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 625 Lemma A15 essentially states set persistent context literals branch B contains generalizations context literals B Proof Consider trace Lj icid2j κ L cid3i All consecutive different elements Lj Lj 1 Compact rule applied sequent cid3j cid14 cid2j labeling node Nj That Compact applied means Lj 1 cid3 Lj Of course Lj 1 cid3j Lj cid3j hold By Lemma A14 conclude Lj 1 cid10cid11 Lj Together Lj 1 cid3 Lj entails Lj 1 cid3 Lj In words considered consecutive different elements trace determine sequence increasing literals wrt cid3 With Lemma A1 follows immediately sequence ﬁnite If sequence nonempty let K element Otherwise let K L In cases easy K cid3B K cid3 L cid2 Lemma A16 If L cid3B L cid3i κ L cid3j j cid3 j κ This means persistent literal context present time present time This trivial follow deﬁnition persistency deﬁnition consistent having L cid3i L cid3i1 L cid3j 2 j cid3 The result instead expresses property ME calculus Proof Suppose L cid3B L cid3i stated Suppose contrary lemma conclusion j cid3 L cid3j By Lemma A13 K cid3j K cid3 L By induction L cid3k k cid3 j k κ Once shown completes proof results contradicts given assumption L cid3B We invariant k stated literal K cid3k K cid3 L k j Trivial L cid3j K cid3j K cid3 L assumed k cid5 k 1 We consider possible inference rule applications derive cid3k1 cid14 cid2k1 cid3k cid14 cid2k concentrating nontrivial cases If Compact applied cid3k cid14 cid2k selected literal K cid3k cid3k1 contain literal K cid13 cid3 K By invariant know K cid3 L K cid13 cid3 L follows Therefore chose K K cid13 preserve invariant If inference rule applied extend cid3k cid3k1 Lcid13 literal Lcid13 Lemma A11 follows K cid10cid3 L This implies L cid3k1 The invariant trivially preserved This completes induction proof cid2 Lemma A17 Let K L literals If K strongly cover L cid3B κ j cid5 j κ K strongly cover L cid3j Proof Suppose K strongly cover L cid3B We directly prove conclusion If K cid10cid2 L lemma holds trivially 0 Hence assume K cid2 L That K strongly cover L cid3B implies cid3B shields L K This means K cid13 cid3B ppreserving substitution σ K cid2 K cid13σ cid2 L Since K cid13 cid3B k κ K cid13 cid3k By Lemma A15 K cid13cid13 cid3B K cid13cid13 cid3 K cid13 Since K cid13cid13 cid3B κ K cid13cid13 cid3j j cid3 j κ Let σ cid13 ppreserving substitution K cid13cid13σ cid13 K cid13 From K cid2 K cid13cid13σ cid13σ cid2 L follows immediately Because σ cid13 σ ppreserving σ cid13σ ppreserving Thus K cid13cid13 shields L K Since K cid13cid13 cid3j j cid5 j κ cid3j shields L K K strongly cover L cid3j cid2 Lemma 414 Let K L literals K cid3B If K produces L cid3B κ j cid3 j κ K cid3j K produces L cid3j Proof Assume K produces L cid3B We directly prove conclusion Since K cid3B k κ K cid3k j cid3 k However guarantee k index looking Informally case literal K cid13 shielding L K strongly covering L present cid3k successor context While way preventing context shield L K necessarily ﬁnitely literals K cid13 shielding L K strongly cover L timepoint Lemma A17 More formally let 626 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 M K cid13 m cid3 k m κ K cid13 cid2 cid3m K cid2 K cid13 cid2 L literals cid3m shield L K m cid3 k cid14 Since K cid13 cid2 L K cid13 M set M cid11 ﬁnite Lemma A1 Moreover M trivially subset iκ cid3i Therefore Lemma A14 applicable gives K cid13 M This means element M cid11 singleton In sum M cid11 ﬁnite set singleton equivalence classes Therefore M ﬁnite 2 different literals K cid13 1 K cid13 cid10cid11 K cid13 2 1 Let M cid13 M cid3B set persistent literals cid3B M shield L K Clearly M ﬁnite set M cid13 Let kcid13 κ smallest index M cid13 cid3j cid13 j cid13 cid3 kcid13 kcid13 exist compactness property It impossible cid3kcid13 extended later new literal shields L K More formally j cid13 cid3 kcid13 literal K cid13cid13 cid3j cid13 shields L K contained M cid13 This literal K cid13cid13 Lemma A15 K cid13 cid3B K cid13 cid3 K cid13cid13 It easy K cid13 shields L K K cid13 contained M cid13 contained cid3kcid13 Because property literal cid3j cid13 j cid13 cid3 kcid13 shields L K contained M cid13 prove claim sufﬁces deﬁnition productivity timepoint equal later kcid13 literals M cid13 strongly produces L contexts More precisely literal K cid13 M cid13 K cid13 cid3B fact K cid13 shields L K assumption K produces L cid3B conclude deﬁnition productivity K cid13 strongly cover L cid3B Then applying Lemma A17 literal K cid13 M cid13 conclude ﬁniteness M cid13 index cid3 kcid13 j cid3 K cid13 M cid13 K cid13 strongly cover L cid3j Together conclusion literal cid3j cid13 j cid13 cid3 kcid13 shields L K contained M cid13 implies K produces L cid3j j cid3 To complete proof recall K cid3j j cid3 k j κ cid3 kcid13 cid3 k cid2 A3 Properties inference rules The following lemmas provide sufﬁcient conditions applicability main rules calculus given context Lemma 49 Lifting Lemma Let cid3 noncontradictory context Let C L1 Ln cid4clause Cγ ground cid4instance If cid3 produces L1γ Lnγ fresh variants K1 Kn cid11 cid3cid4 substitution σ 1 σ general simultaneous uniﬁer K1 L1 Kn Ln 2 1 n Li cid2 Liσ cid2 Liγ 3 1 n Ki produces Liσ cid3 Proof Let 1 n assume cid3 produces Liγ Then literals K cid13 produces Liγ cid3 Let Ki cid11 K cid13 It easy Ki cid11 cid3 produces Liγ cid3 Because Ki s fresh pairwise disjoint Ki disjoint C Furthermore Ki cid4literal cid4skoliteral Ki contains Skolem constant Ki cid2 Liγ hold recall Liγ ground cid4literal Ki produce Liγ cid3 fresh variants K cid13 cid3 K cid13 By deﬁnition productivity Ki cid2 Liγ substitution πi Kiπi Liγ Since Ki variable disjoint C assume πi moves variables parameters Ki Now Ki disjoint Kj j 1 n distinct πi ground substitution Ki Kiπi Kiπ π π1 πi πn Since Liγ ground follows immediately Liγ Liγ π We assume variables moved γ occur C restrict γ respectively Together assumptions follows Ki Kiγ implies trivially Kiπ Kiγ π P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 627 Putting results obtained far Kiγ π Liγ π 1 n In words γ π simultaneous uniﬁer K1 L1 Kn Ln It follows K1 L1 Kn Ln admits simultaneous mgu σ proves item 1 statement lemma Now prove item 2 observe Liγ ground Liγ π Liγ Since σ general substitution γ π know γ π σ δ substitution δ It follows Liσ δ Liγ π Liγ In words Liσ cid2 Liγ But L cid2 Liσ cid2 Liγ desired To prove item 3 ﬁrst observe Ki cid2 Liσ Kiσ Liσ By item 2 Ki cid2 Liσ cid2 Liγ Recalling literal Ki produces Liγ cid3 follows Lemma A8 Ki produces Liσ cid3 cid2 Lemma 410 Existence admissible context uniﬁers Let cid3 context C clause σ context uniﬁer C cid3 Then renaming ρ σ cid13 σρ admissible context uniﬁer C cid3 context literals σ Proof Let C L1 Ln n cid3 0 By Deﬁnition 39 context uniﬁer 1 n Ki cid11 cid3 Kiσ Liσ Moreover m 1 n ParKiσ V 1 m ParKiσ cid4 V m 1 n We going construct renaming substitution ρ stated Let x1 xk variables x1 xk VarLm1σ Lnσ variables occurring remainder Deﬁne ρ x1 cid5 u1 xk cid5 uk u1 cid5 x1 uk cid5 xk u1 uk pairwise different fresh parameters31 Clearly ρ renaming It remains σρ admissible Split Recall ParKiσ V holds 1 m By construction parameters moved ρ fresh parameters occur Ki In words ParKiρ ParKi holds entails ParKiσρ ParKiσ However ParKiσρ cid4 V m 1 n general hold Therefore mcid13 m cid5 mcid13 cid5 n ParKiσρ V 1 mcid13 ParKiσρ cid4 V mcid13 1 n None remainder literals Kiσρ m 1 n contains single variable Hence disjointness requirement deﬁnition admissible context uniﬁer trivially satisﬁed This concludes proof existence renaming ρ claimed cid2 The following lemma applies particular remainders admissible context uniﬁers The lemma implies clause admissible context uniﬁer given context remainder literals indi vidually contradictory context clause context uniﬁer remainder Lemma A21 Let cid3 context L1 Ln clause n cid3 0 possibly containing mixed literals distinct j 1 n VarLi VarLj If 1 n Li contradictory cid3 fresh literals K1 Kn cid11 cid3 substitution δ following holds 1 δ simultaneous uniﬁer K1 L1 Kn Ln 2 1 n Domδ ParLi δ single parameter given clause 3 1 n ParKiδ V Proof Let cid3 L1 Ln stated condition lemma result satisﬁed The conclu sions items 13 proven induction n Base If n 0 result follows trivially choosing δ substitution Step Suppose n 0 consider clause L1 Ln1 Clearly distinct j 1 n 1 VarLi VarLj holds Therefore induction hypothesis fresh literals K1 Kn1 cid11 cid3 substitution δcid13 31 That variable remainder renamed ρ parameter From practical point view absurd better compute renaming keeps variables remainder possible For purpose completeness proof renaming ρ constructed 628 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 1 δcid13 simultaneous uniﬁer K1 L1 Kn1 Ln1 2 1 n 1 Domδcid13 ParLi 3 1 n 1 ParKiδcid13 V Now let σ cid13cid13 σ cid13 Since Ln contradictory cid3 literal K cid11 cid3 ppreserving substitution σ Lnσ Kσ Let Kn fresh pvariant K Let ρ renaming substitution Knρ K Let ρcid13 ρVarKnParKn It follows easily Knρcid13 K Since Kn fresh ρcid13 variables parameters Ln Ln Lnρcid13 holds From Lnσ Kσ follows Lnρcid13σ Kσ Knρcid13σ Since σ ppreserving σV renaming parameters σV 1 exists This implies trivially ParLnσ σV 1 ParLn σ σV 1 parameter Ln With Ln Lnρcid13 follows substitution σ cid13 ρcid13σ σV 1 parameter Ln From Lnρcid13σ Knρcid13σ follows trivially Lnρcid13σ σV 1 Kρcid13σ σV 1 Lnσ cid13 Knσ cid13 VarLnVarKnParKn From Lnσ cid13 Knσ cid13 follows Lnσ cid13cid13 Knσ cid13cid13 recall σ cid13 parameter Ln ParLn need included domain restriction σ cid13 deﬁning σ cid13cid13 Let δ σ cid13cid13δcid13 substitution prove induction step We items 1 3 hold Since variables moved σ cid13cid13 occur Ln Kn Kn fresh Ln variable disjoint Li 1 n 1 σ cid13cid13 variable Li Ki Since Kn fresh parameters moved σ cid13cid13 occur Kn σ cid13cid13 parameter Li Ki Ln concluded This implies Liσ cid13cid13 Li Kiσ cid13cid13 Ki 1 n 1 With Kiδcid13 Liδcid13 induction hypothesis conclude Kiσ cid13cid13δcid13 Liσ cid13cid13δcid13 Above concluded Lnσ cid13cid13 Knσ cid13cid13 implies trivially Lnσ cid13cid13δcid13 Knσ cid13cid13δcid13 Together identity δ σ cid13cid13δcid13 gives proof item 1 induction step That item 2 proven carries induction hypothesis induction step follows immediately deﬁnition σ cid13cid13 recall parameters moved σ cid13cid13 subset ParKn It difﬁcult parameters moved σ cid13cid13 moved parameters σ cid13cid13 obtained σ cid13 restricting domain σ cid13 sufﬁces consider σ cid13 Recall σ cid13 ρcid13σ σV 1 parameters moved ρcid13 moved parameters The substitution σ cid13 ppreserving Together implies parameters moved σ cid13 moved parameters But item 3 proven immediately carries induction hypothesis induction step cid2 Lemma 411 Split applicability Let cid3 cid14 cid11 C sequent noncontradictory context cid3 C contains literals If context uniﬁers C cid3 nonempty remainder σ admissible context uniﬁer C cid3 cid3 produces L remainder literal L σ Split applicable cid3 cid14 cid11 C selected clause C context uniﬁer σ sko Proof Suppose condition lemma statement holds The proof conclusion consists parts ﬁrst remainder literal contradictory cid3 Then second remainder literal L L contradictory cid3 This immediately proof Split applicable cid3 cid14 cid11 C selected clause C context uniﬁer σ mentioned remainder literal Let C L1 Lm Lm1 Lm 0 cid5 m cid5 n n cid3 2 remainder D Lm1 Lmσ Suppose contrary statement ﬁrst literal Lj σ j m 1 n contradictory cid3 Since σ admissible prerequisites apply Lemma A21 D satisﬁed By lemma fresh literals Km1 Kn cid11 cid3 simultaneous uniﬁer δ Km1 Lm1σ Kn Lnσ Lemma A21 item 1 j m 1 n holds Domδ ParLj item 2 ParKj δ V item 3 We assume δ restricted parameter moved occurs literal Kj m 1 cid5 j cid5 n Otherwise restrict δ respectively excluding domain parameters occur Kj items 13 hold In particular δ simultaneous uniﬁer stated item 1 unrestricted δ parameters Lj In sequel let index j ranges m 1 n Since literal Kj fresh assume σ modify Kj Kj Kj σ holds Therefore δ simultaneous uniﬁer Km1σ Lm1σ Knσ Lnσ Equivalently σ δ simultaneous uniﬁer Km1 Lm1 Kn Ln Furthermore ParKj δ V Kj Kj σ follows ParKj σ δ V P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 629 We given σ admissible context uniﬁer This means particular σ simultaneous uniﬁer K1 L1 Km Lm Trivially σ δ simultaneous uniﬁer literals Above assumed δ restricted parameter moved occurs literal Kj m 1 cid5 j cid5 n Since literal Kj fresh δ parameter literal Kiσ 1 m Since σ context uniﬁer know ParKiσ V 1 m Together implies ParKiσ δ V Summing simultaneous uniﬁer σ δ K1 L1 Kn Ln omit sequel men tioning pairs meant ParKiσ δ V 1 n However guarantee σ δ simultaneous general uniﬁer We simultaneous general uniﬁer exists context uniﬁer C cid3 remainder contradicting lemma statement Since σ δ simultaneous uniﬁer general simultaneous uniﬁer σ cid13 substitution δcid13 σ cid13δcid13 σ δ The arguments proof Lifting lemma Lemma 49 applied However guarantee ParKiσ cid13 V 1 n But hold ParKiσ cid13 X V 1 n parameter u literal Ki 1 cid5 cid5 n moved term uσ cid13 X V implies uσ cid13δcid13 V However know uσ cid13δcid13 uσ δ V Let x1 xk variables ParK1σ cid13 ParKnσ cid13 deﬁne renaming ρ x1 cid5 u1 xk cid5 uk u1 cid5 x1 uk cid5 xk u1 uk fresh parameters By construction variable ParKiσ cid13 moved parameter u1 uk fresh parameter ParKiσ cid13 moved 1 n This proves ParKiσ cid13ρ V 1 n Furthermore σ cid13 general simultaneous uniﬁer ρ renaming σ cid13ρ general simultaneous uniﬁer In words σ cid13ρ context uniﬁer C cid3 remainder Since plainly contradicts given lemma statement assumption literal Lj σ j m 1 n contradictory cid3 withdrawn Hence claimed remainder literal Lσ contradictory cid3 This completes ﬁrst proof For second let L D remainder literal We L contradictory cid3 contradictory cid3 Then K cid11 cid3 ppreserving substitution σ sko sko Suppose contrary L L σ Kσ sko Since σ ppreserving σV exists renaming V Therefore ρ σV 1 exists u uσρ sko σρ variablefree This implies L parameter u follows Because Skolemization L L sko σ Kσ follows easily L Let μ x1 cid5 a1 xn cid5 Skolemizing substitution n cid3 0 Now constants a1 fresh occur L This means consider substitution μcid13 a1 cid5 x1 cid5 xn hold L Lskoμcid13 sko Kσρ sko L sko The substitution σρ ppreserving σ ρ We assume variables moved σρ sko Kσρ variables K variable K moved σρ Skolem constant ai L holds It follows substitution σρμcid13 renaming V variable K moved variable xi sko Kσρ follows trivially necessarily injective way More formally K cid3 Kσρμcid13 holds Now L μcid13 Kσρμcid13 L Lskoμcid13 L Kσρμcid13 With K cid3 Kσρμcid13 follows K cid3 L With K cid11 cid3 L Lemma A6 K produces L cid3 cid3 produce L This contradicts lemma statement according contradictory cid3 false remainder literal cid3 produce L Therefore assumption L contradictory cid3 Since remained proven proof complete cid2 sko sko Lemma 412 Assert applicability Let cid3 cid14 cid11 L sequent noncontradictory context cid3 If context uniﬁers L cid3 nonempty remainder instance Lσ L cid3 produces Lσ Assert applicable cid3 cid14 cid11 L selected clause L selected literal substitution context uniﬁer Proof Suppose context uniﬁers L cid3 nonempty remainder instance Lσ L cid3 produces Lσ To Assert applicable stated ﬁrst literal K cid3 K cid3 L Suppose literal K Recall clauses sequents parameter 630 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 free With L parameterfree follows easily L cid3 Lσ Together K cid3 L conclude K cid3 Lσ But Lemma A6 applied conclude cid3 produces Lσ cid3 produce Lσ plainly contradicting supposed Therefore literal K cid3 K cid3 L Next L contradictory cid3 Suppose contrary literal K cid11 cid3 ppreserving substitution δ Lδ Kδ Since δ uniﬁer L K general uniﬁer σ cid13 substitution δcid13 σ cid13δcid13 δ The arguments proof Lifting lemma Lemma 49 applied However guarantee ParKσ cid13 V But hold ParKσ cid13 X V parameter u K moved term uσ cid13 X V implies uσ cid13δcid13 V However know uσ cid13δcid13 uδ V δ ppreserving Let x1 xk variables ParKσ cid13 deﬁne renaming ρ x1 cid5 u1 xk cid5 uk u1 cid5 x1 uk cid5 xk u1 uk fresh parameters By construction variable ParKσ cid13 moved parameter u1 uk fresh parameter ParKσ cid13 moved This proves ParKσ cid13ρ V Furthermore σ cid13 general uniﬁer ρ renaming σ cid13ρ general uniﬁer In words σ cid13ρ context uniﬁer L cid3 remainder This plainly contradicts supposed Finally reference deﬁnition Assert inference rule clause L selected written cid2 L Because trivially substitution context uniﬁer cid2 context remainder concludes proof Assert applicable stated cid2 Lemma 415 Close applicability Let C cid2B κ Close applicable cid3i cid14 cid2i selected clause C Then j cid3 j cid5 κ Close applicable cid3j cid14 cid2j selected clause C context uniﬁer σ K cid11 cid3B context literal K σ Proof Assume Close applicable cid3i cid14 cid2i selected clause C We directly prove conclusion Suppose C form L1 Ln Let σ cid13 context uniﬁer considered Close rule application cid11 cid3i context literals σ cid13 With Lemma A15 follows literals K1 Kn cid11 k k 1 n With C cid2B K1 Kn cid3B follows easily compactness let K cid13 cid3B Kk cid3 K cid13 property j cid3 j κ C cid2j Kk cid11 cid3j k 1 n 1 K cid13 n With context uniﬁer σ C cid3j remainder context literals K1 Kn Without loss generality assume K1 Kn chosen fresh pvariants literals cid3j In sequel let index k ranges 1 n From existence context uniﬁer σ cid13 fact Kk cid3 K cid13 k follows general simultaneous uniﬁer σ cid13cid13 K1 L1 Kn Ln The arguments proof Lifting lemma Lemma 49 applied However guarantee ParKkσ cid13cid13 V Using construction proof Lemma 411 shown renaming substitution ρ ParKkσ cid13cid13ρ V Setting σ σ cid13cid13ρ gives desired substitution cid2 References 1 L Bachmair H Ganzinger Equational reasoning saturationbased theorem proving W Bibel PH Schmitt Eds Automated Deduc tion A Basis Applications vol I Foundations Calculi Reﬁnements Kluwer Academic Publishers 1998 pp 353398 Chapter 11 2 L Bachmair H Ganzinger Resolution theorem proving A Robinson A Voronkov Eds Handbook Automated Reasoning North Holland 2001 3 P Baumgartner Hyper tableauxThe generation H Swaart Ed Automated Reasoning Analytic Tableaux Related Methods Lecture Notes Artiﬁcial Intelligence vol 1397 Springer Verlag Berlin Heidelberg New York 1998 pp 6076 4 P Baumgartner FDPLLA firstorder DavisPutnamLogemanLoveland procedure D McAllester Ed CADE17The 17th Inter national Conference Automated Deduction Lecture Notes Artiﬁcial Intelligence vol 1831 Springer Verlag Berlin Heidelberg New York 2000 pp 200219 5 P Baumgartner A Fuchs C Tinelli Implementing model evolution calculus International Journal Artiﬁcial Intelligence Tools 15 1 2006 2152 6 P Baumgartner A Fuchs C Tinelli Lemma learning model evolution calculus M Hermann A Voronkov Eds Proceedings 13th International Conference Logic Programming Artiﬁcial Intelligence Reasoning LPAR06 Phnom Penh Cambodia Lecture Notes Computer Science vol 4246 Springer 2006 pp 572586 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 631 7 P Baumgartner U Furbach I Niemelä Hyper tableaux Proc JELIA 96 European Workshop Logic AI Lecture Notes Artiﬁcial Intelligence vol 1126 Springer 1996 8 P Baumgartner C Tinelli The model evolution calculus equality 38 2005 pp 392408 9 B Beckert Depthﬁrst proof search backtracking freevariable clausal tableaux Journal Symbolic Computation 36 2003 117138 10 W Bibel Automated Theorem Proving Vieweg 1982 11 JP Billon The Disconnection Method P Miglioli U Moscato D Mundici M Ornaghi Eds Theorem Proving Analytic Tableaux Related Methods Lecture Notes Artiﬁcial Intelligence vol 1071 Springer Verlag Berlin Heidelberg New York 1996 pp 110 126 12 C Chang R Lee Symbolic Logic Mechanical Theorem Proving Academic Press 1973 13 M Davis G Logemann D Loveland A machine program theorem proving Communications ACM 5 7 Jul 1962 394397 14 M Davis H Putnam A computing procedure quantiﬁcation theory Journal ACM 7 3 Jul 1960 201215 15 E Eder Properties substitutions uniﬁcations Journal Symbolic Computation 1 1 March 1985 16 C Fermüller A Leitsch Model building resolution E Börger G Jäger H KleineBüning S Martini M Richter Eds Computer Science LogicCSL92 Lecture Notes Computer Science vol 702 Springer Verlag Berlin Heidelberg New York 1993 pp 134148 17 C Fermüller A Leitsch Hyperresolution automated model building Journal Logic Computation 6 2 1996 173230 18 C Fermüller A Leitsch U Hustadt T Tammet Resolution Decision Procedures Elsevier MIT Press 2001 pp 17911850 19 C Fermüller R Pichler Model representation contexts implicit generalizations 38 2005 pp 409423 20 M Fitting First Order Logic Automated Theorem Proving Texts Monographs Computer Science Springer 1990 21 A Fuchs Darwin A theorem prover model evolution calculus Masters thesis University KoblenzLandau 2004 22 H Ganzinger K Korovin New directions instancebased theorem proving LICSLogics Computer Science 2003 23 H Ganzinger C Meyer C Weidenbach Soft typing ordered resolution W McCune Ed Automated DeductionCADE 14 Lecture Notes Artiﬁcial Intelligence vol 1249 SpringerVerlag Townsville North Queensland Australia 1997 pp 321335 24 M Giese Incremental closure free variable tableaux Proc International Joint Conference Automated Reasoning Lecture Notes Artiﬁcial Intelligence vol 2083 Springer Verlag Berlin Heidelberg New York 2001 25 M Giese A model generation style completeness proof constraint tableaux superposition U Egly CG Fermüller Eds Proc Intl Conf Automated Reasoning Analytic Tableaux Related Methods Copenhagen Denmark Lecture Notes Computer Science vol 2381 Springer Verlag 2002 26 ML Ginsberg Dynamic backtracking Journal Artiﬁcial Intelligence Research 1 1993 2546 27 ML Ginsberg AJ Parkes Satisﬁability algorithms ﬁnite quantiﬁcation AG Cohn F Giunchiglia B Selman Eds Principles Knowledge Representation Reasoning Proceedings Seventh International Conference KR2000 Morgan Kauffman 2000 pp 690701 28 E Goldberg Y Novikov Berkmin A fast robust sat solver 2002 29 J Hooker G Rago V Chandru A Shrivastava Partial instantiation methods inference ﬁrst order logic Journal Automated Reason ing 28 4 2002 371396 30 D Jackson Automating ﬁrstorder relational logic Proceedings ACM SIGSOFT Conference Foundations Software Engineer ing 2000 pp 130139 31 R Joshi G Nelson K Randall Denali A goaldirected superoptimizer Tech rep Compaq SRC July 2001 32 SJ Lee D Plaisted Eliminating Duplicates HyperLinking Strategy Journal Automated Reasoning 9 1992 2542 33 R Letz K Mayr C Goller Controlled integrations cut rule connection tableau calculi Journal Automated Reasoning 13 1994 34 R Letz G Stenz Proof model generation disconnection tableaux R Nieuwenhuis A Voronkov Eds Logic Programming Artiﬁcial Intelligence Reasoning 8th International Conference LPAR 2001 Havana Cuba Lecture Notes Computer Science vol 2250 Springer Verlag Berlin Heidelberg New York 2001 35 R Letz G Stenz Integration equality reasoning disconnection calculus U Egly CG Fermüller Eds TABLEAUX Lecture Notes Computer Science vol 2381 Springer Verlag Berlin Heidelberg New York 2002 pp 176190 36 R Manthey F Bry SATCHMO A theorem prover implemented Prolog E Lusk R Overbeek Eds Proceedings 9th Conference Automated Deduction Argonne Illinois May 1988 Lecture Notes Computer Science vol 310 Springer Verlag Berlin Heidelberg New York 1988 pp 415434 37 MW Moskewicz CF Madigan Y Zhao L Zhang S Malik Chaff Engineering efﬁcient SAT solver Proceedings 38th Design Automation Conference DAC01 Jun 2001 38 R Nieuwenhuis Ed Automated DeductionCADE20 Lecture Notes Artiﬁcial Intelligence vol 3632 Springer 2005 39 AJ Parkes Lifted search engines satisﬁability PhD thesis University Oregon June 1999 40 N Peltier Pruning search space extracting models tableaux Logic Journal IGPL 7 2 1999 217251 41 DA Plaisted Y Zhu Ordered semantic hyper linking Proceedings Fourteenth National Conference Artiﬁcial Intelligence AAAI 97 1997 42 DA Plaisted Y Zhu Ordered semantic hyper linking Journal Automated Reasoning 25 3 2000 167217 43 G Stenz DCTP 12System abstract U Egly CG Fermüller Eds Automated Reasoning Analytic Tableaux Related Methods International Conference TABLEAUX 2002 Copenhagen Denmark July 30August 1 2002 Proceedings Lecture Notes Computer Science vol 2381 Springer Verlag Berlin Heidelberg New York 2002 pp 335340 44 G Stenz R Letz Generalized handling variables disconnection tableaux Proc International Joint Conference Automated Rea soning Lecture Notes Artiﬁcial Intelligence vol 3097 Springer Verlag Berlin Heidelberg New York 2004 pp 289306 45 O Strichman S Seshia R Bryant Deciding separation formulas sat Proceedings Computer Aided Veriﬁcation Conference CAV02 2002 632 P Baumgartner C Tinelli Artiﬁcial Intelligence 172 2008 591632 46 G Sutcliffe C Suttner The TPTP problem library CNF release v121 Journal Automated Reasoning 21 2 1998 177203 47 C Tinelli A DPLLbased calculus ground satisﬁability modulo theories G Ianni S Flesca Eds Proceedings 8th European Conference Logics Artiﬁcial Intelligence Cosenza Italy Lecture Notes Artiﬁcial Intelligence vol 2424 Springer Verlag Berlin Heidelberg New York 2002 48 J van Eijck Constrained hyper tableaux L Fribourg Ed Computer Science Logic 15th International Workshop CSL 2001 Lecture Notes Computer Science vol 2142 Springer 2001 pp 232246 49 A Yahya D Plaisted Ordered semantic hypertableaux Journal Automated Reasoning 29 1 2002 1757 50 H Zhang ME Stickel An efﬁcient algorithm unit propagation Proceedings Fourth International Symposium Artiﬁcial Intelligence Mathematics AIMATH96 Fort Lauderdale Florida USA 1996