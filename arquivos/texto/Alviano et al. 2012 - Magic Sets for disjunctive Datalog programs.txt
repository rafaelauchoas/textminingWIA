Artiﬁcial Intelligence 187188 2012 156192 Contents lists available SciVerse ScienceDirect Artiﬁcial Intelligence wwwelseviercomlocateartint Magic Sets disjunctive Datalog programs Mario Alviano Wolfgang Faber Gianluigi Greco Nicola Leone Department Mathematics University Calabria 87036 Rende Italy r t c l e n f o b s t r c t Article history Received 13 January 2011 Received revised form 20 April 2012 Accepted 24 April 2012 Available online 26 April 2012 Keywords Logic programming Stable models Magic Sets Answer set programming Data integration In paper new technique optimization partially bound queries disjunctive Datalog programs stratiﬁed negation presented The technique exploits propagation query bindings extends Magic Set optimization technique originally deﬁned nondisjunctive programs An important feature disjunctive Datalog programs nonmonotonicity calls nondeterministic implementations backtracking search A distinguishing characteristic new method optimization exploited nondeterministic phase In particular assumptions computation parts program irrelevant query assumptions This allows dynamic pruning search space In contrast effect previously deﬁned Magic Set methods disjunctive Datalog limited deterministic portion process In way potential performance gain proposed method exponential observed empirically The correctness method established proved formal way thanks strong relationship Magic Sets unfounded sets studied literature This knowledge allows extending method correctness proof programs stratiﬁed negation natural way The proposed method implemented DLV experiments synthetic realworld data conducted The experimental results synthetic data conﬁrm utility Magic Sets disjunctive Datalog highlight computational gain obtained new method respect previously proposed Magic Set method disjunctive Datalog programs Further experiments data taken reallife application beneﬁts Magic Set method application scenario received considerable attention recent years problem answering user queries possibly inconsistent databases originating integration autonomous sources information 2012 Elsevier BV All rights reserved 1 Introduction Disjunctive Datalog language proposed modeling incomplete data 48 Together light version negation paper stratiﬁed negation language fact express query complexity class 2 NPNP 22 stable model semantics It turns disjunctive Datalog stratiﬁed negation Σ P strictly expressive polynomial hierarchy collapses ﬁrst level normal logic programming nondisjunctive Datalog unstratiﬁed negation express queries NP As shown 22 Preliminary portions paper appeared proceedings 20th International Conference Logic Programming ICLP04 Corresponding author Email addresses alvianomatunicalit M Alviano fabermatunicalit W Faber ggrecomatunicalit G Greco leonematunicalit N Leone 00043702 matter 2012 Elsevier BV All rights reserved httpdxdoiorg101016jartint201204008 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 157 high expressive power disjunctive Datalog positive practical implications terms modeling knowledge problems NP represented simply naturally stratiﬁed disjunctive Datalog normal logic programming For reason surprising disjunctive Datalog realworld applications 4249505758 encouraged availability eﬃcient inference engines DLV 43 GnT 37 Cmodels 46 ClaspD 21 As matter fact systems continuously enhanced support novel optimization strategies enabling effective increasingly larger application domains In paper contribute development providing novel optimization technique inspired deductive database optimization techniques particular Magic Set method 6963 The goal original Magic Set method deﬁned nondisjunctive Datalog programs exploit presence constants query restricting possible search space considering subset hypothetical program instantiation suﬃcient answer query question In order topdown computation answering query simulated abstract way This topdown simulation encoded means rules deﬁning new Magic Set predicates The extensions predicates sets ground atoms contain tuples calculated topdown computation These predicates inserted original program rules bottomup computations narrow computation needed answering query Extending ideas disjunctive Datalog faces major challenge While nondisjunctive Datalog programs deter ministic terms stable model semantics means nondisjunctive Datalog program exactly stable model disjunctive Datalog programs nondeterministic sense multiple stable models Of course main goal isolating subset hypothetical program instantiation considered query evaluated equivalent way There basic possibilities nondeterminism dealt context Magic Sets The ﬁrst consider static Magic Sets sense deﬁnition Magic Sets deterministic extension Magic Set predicates equal stable model This static behavior automatic Magic Sets nondisjunctive Datalog programs The second possibility allow dynamic Magic Sets introduce nondeterministic deﬁnitions Magic Sets This means extension Magic Set predicates differ stable models viewed specialized stable model While nature dynamic Magic Sets intuitively ﬁtting disjunctive Datalog static Magic Sets considering architecture modern reasoning systems disjunctive Datalog substantiates intuition These systems work phases considered deterministic grounding nondeterministic model search The interface means ground program produced deterministic phase Static Magic Sets exclusively impact grounding phase dynamic Magic Sets possibility inﬂuence model search phase In particular assumptions model search render parts program irrelevant query captured dynamic Magic Sets speciﬁc circumstances static Magic Sets In literature apart work 20 previous attempt deﬁning Magic Set method disjunctive Datalog reported 3233 referred Static Magic Sets SMS work The basic idea SMS bindings need propagated rule heads rule bodies traditional Magic Sets head predicate head predicates In addition producing deﬁnitions predicates deﬁning Magic Sets method introduces additional auxiliary predicates called collecting predicates These collecting predicates peculiar effect Their use keeps Magic Sets static Indeed magic collecting predicates guaranteed deterministic deﬁnitions implies disjunctive Datalog systems exploit Magic Sets grounding phase Most systems actually produce ground program contain magic collecting predicates In article propose dynamic Magic Set method disjunctive Datalog stratiﬁed negation stable model semantics provide implementation dlv report extensive experimental evaluation In contributions cid2 cid2 cid2 cid2 We present dynamic Magic Set method disjunctive Datalog programs stratiﬁed negation referred Dynamic Magic Sets DMS Different previously proposed static method SMS existing systems exploit information provided Magic Sets nondeterministic model search phase This feature allows potentially exponential performance gains respect previously proposed static method We formally establish correctness DMS In particular prove program obtained transfor mation DMS queryequivalent original program This result holds brave cautious reasoning We highlight strong relationship Magic Sets unfounded sets characterize stable models We atoms relevant answering query true form unfounded set eventually allows prove queryequivalence results Our results hold disjunctive Datalog language stratiﬁed negation stable model semantics In literature works deal nondisjunctive Datalog stratiﬁed negation wellfounded perfect model semantics special cases language For static method SMS extension disjunctive Datalog stratiﬁed negation previously sketched 33 158 cid2 cid2 cid2 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 We implemented DMS optimization module inside DLV 43 In way exploit internal datastructures DLV embed DMS core DLV As result technique completely transparent end user The available httpwwwdlvsystemcommagic We conducted extensive experiments synthetic domains highlight potential DMS We compared performance DLV Magic Set optimization SMS DMS The results cases Magic Set methods yield signiﬁcant performance beneﬁt Moreover dynamic method DMS yield drastically better performance static SMS Importantly cases DMS beneﬁcial instantiated program relevant answering query overhead incurred light We report experiments evaluate impact DMS industrial application scenario real world data The application involves data integration builds results literature example 5714161731 transform problem query answering inconsistent databases context stemming integrating autonomous data sources query answering disjunctive Datalog programs By leveraging results DMS viewed query optimization method inconsistent databases data integration systems The results DMS yield signiﬁcant performance gains queries application Organization The main body article organized follows In Section 2 preliminaries disjunctive Datalog Magic Set method nondisjunctive Datalog queries introduced Subsequently Section 3 extension DMS case disjunctive Datalog programs presented correctness In Section 4 discuss imple mentation integration Magic Set method DLV Experimental results synthetic benchmarks reported Section 5 application data integration experimental evaluation discussed Section 6 Finally related work discussed Section 7 Section 8 draw conclusions 2 Preliminaries In section disjunctive Datalog programs stratiﬁed negation brieﬂy described standard Magic Set method presented notion sideways information passing strategy SIPS Datalog rules 21 Disjunctive Datalog programs stratiﬁed negation In paper adopt standard Datalog convention Alphanumeric strings starting lowercase character predicate constant symbols alphanumeric strings starting uppercase character variable symbols allow use positive integer constant symbols Each predicate symbol associated nonnegative integer referred arity An atom pt composed predicate symbol p list t t1 tk k cid3 0 terms constant variable A literal atom pt negated atom pt ﬁrst case literal positive second negative A disjunctive Datalog rule negation short Datalog rule r form p1t1 pntn q1s1 q js j q j1s j1 qmsm p1t1 pntn q1s1 qmsm atoms n cid3 1 m cid3 j cid3 0 The disjunction p1t1 pntn head r conjunction q1s1 q js j q j1s j1 qmsm body r Moreover Hr denotes r denoting sets set head atoms Br denotes set body literals We use B atoms appearing positive negative body literals respectively If r disjunctionfree n 1 negationfree r addition r fact B A disjunctive Datalog program P ﬁnite set rules rules disjunction negationfree P standard Datalog program r r Datalog rule B r B Given Datalog program P predicate belongs Intensional Database IDB head rule nonempty body head disjunctive rule belongs Extensional Database EDB The set rules having IDB predicates heads denoted IDBP EDBP denotes remaining rules EDBP P IDBP For simplicity assume predicates type EDB IDB program The set constants appearing program P universe P denoted U P 1 set ground atoms constructable predicates P constants U P base P denoted BP We atom rule program ground contain variables A substitution ϑ function variables elements U P For expression S atom literal rule Sϑ denote expression obtained S substituting occurrences variable X S ϑ X A ground atom pt resp ground rule r g instance atom pt cid4 resp rule r 1 If P constants arbitrary constant added U P M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 159 cid4 resp r U P pt pt cid4ϑ resp r g rϑ Given program P substitution ϑ variables pt GroundP denotes set possible instances rules P Given atom pt set ground atoms A A pt denote set ground instances pt belonging pt set ground atoms obtained applying pt possible substitutions A For example BP variables pt U P set instances pt Abusing notation B set atoms AB denote union A pt pt B r A Datalog programs safety A Datalog A desirable property Datalog rule r safe variable appearing r appears atom B program safe rules safe Moreover programs recursion programs Without going details predicate p negated literals constitute interesting class Datalog r p head rule r depends predicates q body r p depends q positively q appears B r A program recursion negation cycle dependencies depends q negatively q appears B negative dependency exists If program recursion negation program stratiﬁed short Datalog s In work safe programs recursion negation considered An interpretation program P subset I BP A positive ground literal pt true respect interpre tation I pt I false A negative ground literal pt true respect I pt false respect I pt I The body ground rule r true respect I r I An interpretation I body literals r true respect I B satisﬁes ground rule r GroundP atom Hr true respect I body r true program P I satisﬁes rules GroundP Since respect I An interpretation I model Datalog interpretation set atoms I interpretation program P P cid4 program IBPcid4 denote restriction I base P cid4 r I B Given interpretation I program P reduct P respect I denoted GroundPI obtained r g I cid9 removing negative literals deleting GroundP rules r g B remaining rules The semantics Datalog program P given set SMP stable models P interpretation M stable model P M subsetminimal model GroundPM It wellknown exactly s program P stable model Datalog program presence stratiﬁed negation However Datalog SMP cid3 1 holds Datalog programs instead stable model Given ground atom pt Datalog program P pt cautious certain consequence P denoted P cid10c pt pt M M SMP pt brave possible consequence P denoted P cid10b pt pt M M SMP Note brave cautious consequences coincide Datalog programs programs s program P brave consequences unique stable model Moreover cautious consequences Datalog P SMP cid3 1 holds case Given query Q gt atom2 AnscQ P denotes set substitutions ϑ variables gt P cid10c gtϑ AnsbQ P denotes set substitutions ϑ variables gt P cid10b gtϑ Let P P cid4 braveequivalent respect Q AnsbQ P F AnsbQ P cid4 F guaranteed set facts F deﬁned predicates Q P cid4 denoted P b EDB predicates P P cid4 Q P cid4 AnscQ P F AnscQ P cid4 F guaranteed set facts F deﬁned predicates EDB predicates P P cid4 cautiousequivalent respect Q denoted P c programs Q query Then P P cid4 similarly P P cid4 Datalog 22 Bottomup disjunctive Datalog computation Many Datalog systems implement twophase computation The ﬁrst phase referred program instantiation grounding bottomup For input program P produces ground program equivalent GroundP signiﬁcantly smaller Most techniques phase stem bottomup methods developed classic deductive databases example 1 2843 details Essentially predicate instances known true known false identiﬁed knowledge deriving instances kind Eventually truth values obtained way produce rule instances satisﬁed It important note phase behaves deterministic way respect stable models No assumptions truth falsity atoms deﬁnite knowledge derived hold stable models For reason programs multiple stable models solved grounding The second phase referred stable model search takes care nondeterministic computation Es sentially undeﬁned atom selected truth falsity assumed The assumption imply truth falsity undeﬁned atoms Hence process repeated inconsistency derived atoms interpreted In case additional check performed ensure stability model Details process 2 Note complex queries expressed appropriate rules We assume constant appearing Q appears P case add P fact pt p predicate occurring P t arguments Q Question marks usually omitted referring queries text 160 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 example 23 Query answering typically handled storing admissible answer substitutions stable models computed For brave reasoning stable model contribute substitutions set answers In case set answers initially For cautious reasoning instead stable model eliminate substitu tions set admissible answers Therefore case possible substitutions input query initially contained set answers 23 Sideways information passing Datalog rules The Magic Set method aims simulate topdown evaluation query Q like instance adopted Prolog According kind evaluation rules r pt Hr Hrϑ Qϑ cid4 substitution ϑ variables r substitution ϑ cid4 variables Q considered ﬁrst step Then atoms rϑ taken subqueries recall standard Datalog rules negative body procedure B iterated Note according process subquery argument bound constant value information passed atoms body Moreover body considered processed certain sequence processing body atom bind arguments subsequently considered body atoms generating passing bindings body Whenever body atom processed argument considered bound free We illustrate mechanism means example Example 21 Let path1 5 query program having following inference rules r1 pathX Y edgeX Y r2 pathX Y edgeX Z pathZ Y Since Datalog program brave cautious consequences coincide Moreover let F1 edge1 3 edge2 4 edge3 5 EDB program A topdown evaluation scheme considers r1 r2 X Y bound 1 5 respectively In particular considering r1 information binding variables passed edgeX Y query atom occurring r1 Thus evaluation fails edge1 5 occur F1 When considering r2 instead binding information passed pathZ Y edgeX Z Suppose atoms evaluated according ordering rule left right edgeX Z considered pathZ Y In particular F1 contains atom edge1 3 leads map Z 3 Eventually inferred binding information propagated remaining body atom pathZ Y path3 5 The process repeated looking answer path3 5 Again rule r1 considered conclude query true edge3 5 occurs F1 Thus path1 5 holds r2 Note example degrees freedom speciﬁcation topdown evaluation scheme The ﬁrst concerns ordering processing body atoms While Prolog systems usually required follow ordering program written Datalog purely declarative semantics independent body ordering allowing arbitrary ordering adopted The second degree freedom slightly subtle concerns selection terms considered bound constants previous evaluations Indeed considered propagation binding information originates previously processed body atoms general possible restrict topdown evaluation partially propagate information For instance desire propagate information generated evaluation EDB predicates information passed head atom The speciﬁc propagation strategy adopted topdown evaluation scheme called sideways information passing strat egy SIPS way formalizing partial ordering atoms rule speciﬁcation bindings originated propagate 933 To formalize concept follows IDB atom pt shall denote associated binding information originated certain step topdown evaluation means string α built letters b f denoting bound free respectively argument pt Deﬁnition 22 SIPS Datalog rules A SIPS Datalog rule r respect binding α atom pt Hr pair α r f α r strict partial order atoms Hr B function assigning atom qs Hr B 1 α r 2 f α r processing qs r pt α r subset variables sintuitively bound r qs atoms qs B r Intuitively atom qs occurring r strict partial order α processing atom qs Eventually argument X qs bound constant exists atom q q cid4 Note head atom pt precedes atoms α r r qs X f α cid4 α r q cid4s cid4s r speciﬁes atoms processed cid4 cid4s M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 161 Example 23 The SIPS adopted Example 21 r1 respect binding bb originating query path1 5 formalized pair bb pathX Y X Y r1 f bb edgeX Y Instead SIPS adopted r2 respect binding bb formalized r1 pair bb pathZ Y f bb edgeX Z Z r2 r2 f bb r2 f bb r2 pathZ Y pathX Y X Y f bb r2 pathX Y bb r1 pathX Y bb r2 edgeX Z bb r2 edgeX Y f bb r1 f bb r1 All algorithms techniques shall develop paper orthogonal respect underlying SIPSes topdown evaluation Thus Section 24 shall assume Datalog programs provided input arbitrarily deﬁned SIPS α r rule r possible adornment α head atom Hr r f α 24 Magic Sets Datalog programs The Magic Set method strategy simulating topdown evaluation query modifying original program means additional rules narrow computation relevant answering query We provide brief informal description Magic Set rewriting technique The reader referred 63 detailed presentation The method structured main phases informally illustrated means Example 21 1 Adornment The key idea materialize binding information IDB predicates propagated topdown computation In particular fact IDB predicate pt associated binding information α string letters b f term t denoted atom obtained adorning predicate symbol binding hand pαt In follows predicate pα said adorned predicate First adornments created query predicates argument occurring query adorned letter variable For instance adorned version query atom path1 5 b constant letter f pathbb1 5 gives rise adorned predicate pathbb Each adorned predicate eventually propagate information body rules deﬁning according SIPS simulating topdown evaluation In particular assume binding α propagated rule r head pt Thus associated SIPS α r determines variables bound evaluation body atoms Indeed variable X atom qs r bound r f α 1 X f α 2 X f α r qs qs pt r bz atom bz B r bz α r qs holds Adorning rule r respect adorned predicate pα means propagating binding information α starting head predicate pt Hr creating novel adorned rule IDB predicates r substituted adorned predicates originating binding according 1 2 Example 24 Adorning query path1 5 generates pathbb1 5 Then propagating binding information bb rule r1 adorning r1 pathbb produces following adorned rule recall adornments apply IDB predicates edge EDB predicate 1 pathbbX Y edgeX Y ra Instead propagating bb rule r2 according SIPS bb r2 following adorned rule f bb r2 deﬁned Example 23 obtain 2 pathbbX Y edgeX Z pathbbZ Y ra While adorning rules novel binding information form unseen adorned predicates generated adorning rules In fact adornment step repeated bindings processed yielding adorned program set adorned rules created computation For instance 2 adorned predicate different pathbb gener example adorned program consists ra ated 1 ra 2 Generation In second step Magic Set method adorned program generate magic rules simulate topdown evaluation scheme single atoms relevant answer input query For adorned atom pαt let magicpαt magic version deﬁned atom magic_pαt obtained t eliminating arguments corresponding f label α magic_pα new predicate symbol simplicity denoted attaching preﬁx magic_ predicate symbol pα Intuitively magic_pαt cid4ϑ ϑ substitution inferred rules rewritten program topdown evaluation original program process subquery form pαt obtained t applying ϑ terms t cid4cid4 t cid4 t cid4cid4 cid4 cid4 162 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 Thus q head magic rule r si adorned atom βi string body adorned rule ra having pαt βi union magicpαt βi si ii Br generated Hr set atoms q β j j s j B r q js j α magicq r qisi Example 25 In running example magic rule generated 2 magic_pathbbZ Y magic_pathbbX Y edgeX Z r In fact adorned rule ra 1 produce magic rule adorned predicate B ra 1 3 Modiﬁcation The adorned rules subsequently modiﬁed adding magic atoms bodies These magic atoms limit range head variables avoiding inference facts contribute derivation query In particular adorned rule ra head atom pαt modiﬁed adding atom magicpαt body The resulting rules called modiﬁed rules Example 26 In running example following modiﬁed rules generated cid4 1 pathbbX Y magic_pathbbX Y edgeX Y cid4 2 pathbbX Y magic_pathbbX Y edgeX Z pathbbZ Y r r 4 Processing Query Finally given adorned predicate gα obtained adorning query gt 1 magic seed magicgαt fact 2 rule gt gαt produced In example magic_pathbb1 5 pathX Y pathbbX Y generated The complete rewritten program according Magic Set method consists magic modiﬁed query rules wellknown original EDB Given Datalog program P query Q rewritten program P cid4 P P cid4 equivalent respect Q P b P c hold 63 Q P cid4 Q P cid4 Example 27 The complete rewriting running example follows3 magic_pathbb1 5 pathX Y pathbbX Y 2 magic_pathbbZ Y magic_pathbbX Y edgeX Z cid4 1 pathbbX Y magic_pathbbX Y edgeX Y cid4 2 pathbbX Y magic_pathbbX Y edgeX Z pathbbZ Y r r r In rewriting magic_pathbbX Y represents potential subpath paths 1 5 Therefore answering query subpaths actually considered bottomup computation One check rewriting fact equivalent original program respect query path1 5 3 Magic Set method Datalog s programs In section present Dynamic Magic Set algorithm DMS optimization disjunctive programs stratiﬁed negation Before discussing details algorithm informally present main ideas exploited enabling Magic Set method work disjunctive programs negation 31 Overview binding propagation Datalog programs As ﬁrst observed 33 nondisjunctive programs bindings propagated headtobody Magic Set transformation disjunctive programs propagate bindings headtohead order preserve soundness Roughly suppose predicate p relevant query disjunctive rule r contains p X head Then propagating binding p X body r nondisjunctive case binding propagated p X head atoms r The reason atom true stable model needs supporting rule rule true body atom question true head atom Therefore r yield support truth p X head atoms false implicit minimality criterion semantics 3 The Magic Set rewriting program P affects IDBP usually omit EDBP examples M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 163 s program P query Q gt Algorithm DMSQ P Input A Datalog Output The rewritten program DMSQ P var S D set adorned predicates modiﬁedRulesQP magicRulesQP set rules begin pα element S remove pα S add pα D rule r P atom pt Hr 1 S D modiﬁedRulesQP magicRulesQP BuildQuerySeedQ S 2 S cid9 3 4 5 6 7 8 end 9 end 10 DMSQ P magicRulesQP modiﬁedRulesQP EDBP 11 return DMSQ P ra Adornr pα t S D magicRulesQP magicRulesQP Generater pα t ra modiﬁedRulesQP modiﬁedRulesQP Modifyr ra end Fig 1 Dynamic Magic Set algorithm DMS Datalog s programs Consider instance Datalog program P consisting rule pX qY aX Y bX query p1 Even query propagates binding predicate p order correctly answer query need evaluate truth value qY indirectly receives binding body predicate aX Y For instance suppose program contains facts a1 2 b1 atom q2 relevant query p1 belong Magic Set query truth q2 invalidate derivation p1 rule minimality semantics It follows propagating binding head atoms disjunctive rules adorned However adornment head disjunctive rule r rise multiple rules having different adorn ments head predicates This process seen splitting r multiple rules While problem nondisjunctive case semantics disjunctive program affected Consider instance pro gram consisting rule pX Y qY X aX Y p q mutually exclusive minimality appear rule head Assuming adornments pbf qbf propagated obtain rules heads form pbfX Y qfbY X derived propagating pbf pfbX Y qbfY X derived propagating qbf These rules support atoms pbfm n qbfn m original program pm n pn m hold simultaneously semantic minimality changing original semantics The method proposed 33 circumvents problem auxiliary predicates collect facts coming different adornments For instance example rules form collect_pX Y pfbX Y collect_pX Y pbfX Y added predicate p The main deﬁciency approach collecting predicates store sizable superset atoms relevant answer given query An important observation collecting predicates deﬁned deterministic way Since predicates restricting computation 33 consequence assumptions computation exploited determining relevant program In terms bottomup systems implies optimiza tion affects grounding portion solver Intuitively beneﬁcial form conditional relevance exploiting relevance assumptions In fact Section 5 provide experimental evidence intu ition In following propose novel Magic Set method guarantees query equivalence allows exploitation conditional dynamic relevance overcoming major drawback SMS 32 DMS algorithm Our proposal enhance Magic Set method disjunctive Datalog programs crucial features compared 33 1 First semantics program preserved stripping adornments nonmagic predicates modiﬁed rules introducing collecting predicates introduce overhead grounding process discussed Section 31 2 Second proposed Magic Set technique way cut irrelevant rules ground program fact allows dynamic determination relevance optimizing nondeterministic computation disabling parts programs relevant extension current computation state The algorithm DMS implementing strategies reported Fig 1 pseudocode We assume variables passed functions reference particular variable S modiﬁed inside BuildQuerySeed Adorn Its input 164 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 Function BuildQuerySeedQ S Input Q query S set adorned predicates Output The query seed magic atom var α adornment string begin 1 Let pt atom Q 2 α cid6 3 argument t t 4 5 end 6 add pα S 7 return magicpα t t constant α αb α α f end end Fig 2 BuildQuerySeed function s program4 P query Q The algorithm uses sets S D store adorned predicates Datalog propagated processed respectively After adorned predicates processed method outputs rewritten program DMSQ P consisting set modiﬁed magic rules stored means sets modiﬁedRulesQP magicRulesQP respectively original EDB The main steps algorithm illustrated means following running example Example 31 Strategic Companies 15 Let C c1 cm collection companies producing goods set G cid4 C company ci C controlled set companies O C A subset companies C produce goods strategic set minimal set companies satisfying following conditions Companies C G O C 1 m implies ci C cid4 cid4 cid4 We assume product produced companies company controlled companies It known problem retains hardness second level polynomial hierar chy 15 restrictions We assume production goods represented EDB containing fact produced_byp c1 c2 product p produced companies c1 c2 control represented facts controlled_byc c1 c2 c3 company c controlled companies c1 c2 c35 This problem modeled following disjunctive program Psc r3 scC1 scC2 produced_byP C1 C2 r4 scC controlled_byC C1 C2 C3 scC1 scC2 scC3 Moreover given company c C consider query Qsc scc asking c belongs strategic set C The computation starts step 1 initializing S D modiﬁedRulesQP set Then function Build QuerySeedQ S storing magicRulesQP magic seed inserting set S adorned predicate Q Note generate query rules standard atoms transformed program contain adornments Details BuildQuerySeedQ S reported Fig 2 Example 32 Given query Qsc scc program Psc magic_scbc inserts scb S function BuildQuerySeedQsc S creates fact The core algorithm steps 38 repeated set S adorned predicate propagated In particular adorned predicate pα moved S D step 3 binding propagated disjunctive rule r P form r pt p1t1 pntn q1s1 q js j q j1s j1 qmsm n cid3 0 having atom pt head note rule r processed number times equals number head atoms predicate p steps 48 1 Adornment Step 5 Fig 1 implements adornment rule Different case nondisjunctive positive programs binding predicate pα needs propagated atoms p1t1 pntn head Therefore binding propagation extended head atoms different pt adorned according 4 Note algorithm nondisjunctive andor positive programs special case 5 If product produced company c2 c1 similarly companies controlled fewer companies M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 165 Function Adornr pα t S D Input r rule pα t adorned atom S D set adorned predicates Output adorned rule var ra adorned rule αi adornment string begin SIPS associated r pα t f pα t r Let pα t r ra r IDB atom pi ti Hr B αi cid6 argument t t t constant r B r αi αib Argument t variable Let X variable X f pt qs B qs pα t pα t r r pi ti X f r αi αib αi αi f end pα t r qs end end substitute pi ti ra p αi set D contain p αi ti add p αi S end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 end 21 end return ra Fig 3 Adorn function SIPS speciﬁcally conceived disjunctive programs Notation gets slightly involved Since nondisjunctive rules single head atom suﬃcient specify order function adornments omitting head atom notation With disjunctive rules order function need speciﬁed adorned head atom longer suﬃcient include adornment notation include adorned atom Deﬁnition 33 SIPS Datalog pair pα t pα t r f r s rules A SIPS Datalog s rule r respect binding α atom pt Hr 1 pα t r strict partial order atoms Hr B r B qs atoms qs Hr B pt pα t b pair atoms qs Hr pt B r r B r r different pt r bz Hr B r B r qs pα t r bz hold 2 f pα t r bound processing qs function assigning atom qs Hr B r B r subset variables sintuitively As Datalog rules atom qs occurring r strict partial order pα t speciﬁes atoms cid4 cid4s processed processing atom qs argument X qs bound constant exists atom q cid4 The difference respect SIPSes Datalog rules cid4s occurring r q precisely dependency pt addition α condition 1b stating head atoms different pt negative body literals provide bindings variables atoms qs X f cid4 pα t pα t r cid4s q r r The underlying idea rule prove truth atom topdown method rule supports atom This implies head atoms rule false body true Head atoms atoms occurring negative body create bindings restrict values variables atoms relevant query leads restrictions Deﬁnition 33 Note deﬁnition considers rule isolation independent interrule structure program In particular important SIPS deﬁnition program cyclic contains head cycles In following shall assume Datalog s program provided input arbitrarily adornment carried deﬁned SIPS Datalog precisely discussed Datalog programs particular recall variable X atom qs r bound In fact armed pα t s rules pα t pα t r pα t r f f r r 166 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 1 X f 2 X f pα t r pα t r qs qs pt bz atom bz B r bz pα t r qs holds The function Adornr pαt S D produces adorned disjunctive rule ra adorned atom pαt suit able unadorned rule r according bindings deﬁned points 1 2 inserting newly adorned predicates S Hence step 5 rule ra form ra pαt p α1 1 t1 p αn n tn q β1 1 s1 q β j j s j q β j1 j1 s j1 q βm m sm Details Adornr pαt S D reported Fig 3 Example 34 Let resume Example 32 We supposing adopted SIPS passing bindings produced_by controlled_by variables sc atoms particular scC1 scbC1 scC1 scbC1 produced_byP C1 C2 scbC1 produced_byP C1 C2 scC2 scC2 r3 r3 r3 scC2 scbC2 scC2 scbC2 produced_byP C1 C2 scbC2 r3 r3 r3 r4 r4 scC scbC scC scbC scC scbC scC scbC controlled_byC C1 C2 C3 scbC controlled_byC C1 C2 C3 scbC controlled_byC C1 C2 C3 scbC r4 r4 r4 r4 r4 produced_byP C1 C2 scC1 scC1 controlled_byC C1 C2 C3 scC1 scC2 scC3 scC1 scC2 scC3 C1 cid2 cid3 scC1 cid2 cid3 produced_byP C1 C2 cid2 cid3 scC2 cid2 cid3 scC2 cid2 cid3 produced_byP C1 C2 cid2 cid3 scC1 cid3 scC C2 C P C2 P C1 scbC1 r3 scbC1 r3 scbC1 r3 scbC2 r3 scbC2 r3 scbC2 r3 cid2 scbC r4 scbC r4 scbC r4 f f f f f f f f f cid2 cid3 controlled_byC C1 C2 C3 C1 C2 C3 cid2 scC1 cid3 f scbC r4 cid2 cid3 scC2 f scbC r4 cid2 cid3 scC3 When scb removed set S ﬁrst select rule r3 head predicate scC1 Then adorned version 31 scbC1 scbC2 produced_byP C1 C2 ra M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 167 Function Generater pα t ra Input r rule pα t adorned atom ra adorned rule Output set magic rules rule var R set rules r begin Let pα t f pα t r SIPS associated r pα t 1 r 2 R 3 4 5 αi ti Hra B αi ti magicpα t atom p αi cid9 cid6 magicp r atom p j t j B add atom p j t j B r r p j t j pα t r pi ti ra B ra different pα t end R R r 6 7 8 9 end 10 11 end 12 end return R Fig 4 Generate function Next r3 processed time head predicate scC2 producing 32 scbC2 scbC1 produced_byP C1 C2 ra Finally processing r4 obtain 4 scbC controlled_byC C1 C2 C3 scbC1 scbC2 scbC3 ra 2 Generation The algorithm uses adorned rule ra generating collecting magic rules step 6 Fig 1 αi More speciﬁcally Generater pαt ra produces magic rules according following schema p ti adorned atom αi string occurring ra different pαt magic rule r generated r Hr q js j α union magicpαt set atoms q r piti Details Generater pαt ra reported Fig 4 αi ti ii Br magicp β j j s j B Example 35 Continuing running example invoking Generater3 scbC1 ra produced 31 following magic rule 31 magic_scbC2 magic_scbC1 produced_byP C1 C2 r Similarly invoking Generater3 scbC2 ra 32 following magic rule produced 32 magic_scbC1 magic_scbC2 produced_byP C1 C2 r Finally following magic rules produced Generater4 scbC ra 4 41 magic_scbC1 magic_scbC controlled_byC C1 C2 C3 42 magic_scbC2 magic_scbC controlled_byC C1 C2 C3 43 magic_scbC3 magic_scbC controlled_byC C1 C2 C3 r r r 3 Modiﬁcation In step 7 modiﬁed rules generated collected The difference respect Datalog case adornments stripped original atoms Speciﬁcally given adorned rule ra associated rule obtained r adding body atom magicpαt atom pαt occurring Hra r modiﬁed rule r cid4 Hence function Modifyr ra reported Fig 5 constructs rule r cid4 cid4 r pt p1t1 pntn magic cid2 form cid3 cid3 α1 αn n tn 1 t1 q1s1 q js j q j1s j1 qmsm cid3 pαt magic magic p p cid2 cid2 Finally adorned predicates processed algorithm outputs program DMSQ P 168 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 cid4 rule Function Modifyr ra Input r rule ra adorned rule Output modiﬁed rule var r begin 1 2 3 4 end return r 5 end add magicpα t B cid4 cid4 r r atom pα t Hra r cid4 Fig 5 Modify function Example 36 In running example derive following set modiﬁed rules r r cid4 31 scC1 scC2 magic_scbC1 magic_scbC2 produced_byP C1 C2 cid4 32 scC2 scC1 magic_scbC2 magic_scbC1 produced_byP C1 C2 cid4 4 scC magic_scbC controlled_byC C1 C2 C3 scC1 scC2 scC3 r cid4 31 resp r 32 ra Here r 4 Thus optimized program DMSQsc Psc comprises modiﬁed rules magic rules Example 35 magic seed magic_scbc original EDB cid4 4 derived adding magic predicates stripping adornments rule ra 31 resp ra cid4 32 r Before establishing correctness technique brieﬂy present example application DMS program containing disjunction stratiﬁed negation Example 37 Let consider slight variant Strategic Companies problem described Example 31 determine given company c belong strategic set We consider query nscc program Pnsc obtained adding Psc following rule rnsc nscC companyC scC company EDB predicate Company c belong strategic set query cautiously false In case processing query produces query seed magic_nscbc fact adorned predicate nscb added set S After nscb moved S D rule rnsc considered Assuming following SIP nscC nscbC nscbC rnsc rnsc nscC C f companyC nscC nscbC rnsc companyP f scC nscbC rnsc invoking Adornrnsc nscbC S D obtain following adorned rule nscbC rnsc f scC nsc nscbC companyC scbC ra The new adorned predicate scb added S Then Generaternsc nscbC ra ing magic modiﬁed rules nsc Modifyrnsc ra nsc produce follow nsc magic_scbC magic_nscbC cid4 nsc nscC magic_nscbC companyC scC r r The algorithm processes adorned atom scb Hence SIPS presented Example 34 assumed rewritten nsc r program comprises following rules r cid4 nsc r 42 r cid4 31 r 31 r 41 r 32 r cid4 32 r cid4 4 r 43 33 Query equivalence result We conclude presentation DMS algorithm formally proving correctness We like point results hold kind SIPS long conforms Deﬁnition 33 Therefore remainder section assume program comes associated SIPS In proofs use established notion unfounded set disjunctive Datalog programs possibly negation deﬁned 44 Before introducing founded sets deﬁne partial interpretations interpretations atoms undeﬁned M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 169 Deﬁnition 38 Partial interpretation Let P Datalog program A partial interpretation P pair cid14T Ncid15 T N BP The atoms T interpreted true atoms N false N T undeﬁned All atoms false Note total interpretations special case T N We formalize notion unfounded set program P X BP set Deﬁnition 39 Unfounded sets Let cid14T Ncid15 partial interpretation Datalog atoms Then X unfounded set P respect cid14T Ncid15 ground rule r g GroundP X Hr g cid9 following conditions holds r g cid2 N 1a B r g T cid9 1b B r g X cid9 2 B 3 Hr g T X cid9 Intuitively conditions 1a 1b 3 check rule satisﬁed cid14T Ncid15 regardless atoms X condition 2 checks rule satisﬁed taking atoms X false Example 310 Consider program Psc Example 31 assume EDBPsc produced_byp c c1 Then GroundPsc consists rule rsc scc scc1 produced_byp c c1 facts rules having ground instance EDB predicate occurring EDBPsc omitted sim plicity Consider partial interpretation cid14Msc BPsc cid15 Msc produced_byp c c1 scc Thus scc1 unfounded set P respect cid14Msc BPsc cid15 rsc satisﬁes condition 3 Deﬁnition 39 scc scc1 rsc violates conditions The following adaptation Theorem 46 44 notation Theorem 311 See 44 Let cid14T Ncid15 partial interpretation Datalog T M N unfounded set X P respect cid14T Ncid15 M X holds program P Then stable model M P Example 312 In Example 310 shown scc1 unfounded set P respect cid14Msc BPsc total interpretation Msc stable model Psc unfounded set scc1 disjoint Msc cid15 Note cid4 Equipped notions Theorem 311 proceed prove correctness DMS strategy In particular shall ﬁrst method sound stable model M DMSQ P sta cid4Q MQ models coincide restricted query Then prove ble model M P stable model M DMSQ P method complete stable model M M cid4Q MQ In parts proof shall exploit following syntactic relationship original program P M cid4 transformed Lemma 313 Let P Datalog transformed program Then ground rule s program Q query let magicpαt ground atom6 BDMSQP base r g pt p1t1 pntn q1s1 q js j q j1s j1 qmsm belongs GroundP ground rule cid4 g r pt p1t1 pntn magic cid2 cid2 cid3 pαt cid3 cid3 α1 αn n tn 1 t1 q1s1 q js j q j1s j1 qmsm magic magic p p cid2 belongs GroundDMSQ P 6 Note way lemma refers rules contain head atom magic predicate generated transforma tion 170 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 Proof Consider following rule r P r g rϑ substitution ϑ cid3 cid2 t cid4 p cid3 cid2 cid4 t 1 p1 r pn cid3 cid2 cid4 t n q1 cid3 cid2 s cid4 1 q j cid2 s cid4 j cid3 q j1 cid2 s cid4 j1 cid3 qms cid4 m Since magicpαt ground atom BDMSQP pα inserted set S point Magic Set cid4 DMSQ P transformation eventually adorn modify r producing following rule r cid2 t magic cid2 t pα pn p1 cid3cid3 cid3cid3 cid3cid3 p p p cid3 cid3 cid2 cid2 cid3 cid2 r cid4 cid4 cid4 cid2 cid4 t n cid2 cid4 t 1 magic cid3 cid4 1 q1 s cid2 magic cid3 cid2 s cid4 j α1 1 cid2 cid4 t 1 cid2 s cid3 cid4 j1 q j q j1 qm αn n cid2 cid2 cid4 t n cid3 cid4 s m Clearly substitution ϑ mapping r r g map r cid4 r cid4 g magic atoms added cid4 positive body r deﬁned subset variables occurring head atoms Let r cid4 r p cid4 DMSQ P rule r cid2 t pn p1 cid2 cid4 t n cid2 cid4 t 1 cid3 cid3 cid3 cid4 cid4 g r cid2 pα cid4ϑ substitution ϑ cid2 cid2 t cid3cid3 cid3cid3 p cid4 magic magic cid3 cid2 s cid4 j α1 1 cid2 cid4 t 1 cid2 s cid3 cid4 j1 cid2 p αn n cid2 cid2 cid4 t n cid3 cid4 s m cid3cid3 q j q j1 qm magic cid3 cid4 1 q1 s cid2 By construction DMSQ P r cid4 modiﬁed rule produced adding magic atom positive body rule r P form cid2 cid2 cid4 t t 1 p1 r p cid3 cid4 cid3 pn cid3 cid2 cid4 t n q1 cid3 cid2 s cid4 1 q j cid2 s cid4 j cid3 q j1 cid2 s cid4 j1 cid3 qm cid2 cid3 cid4 s m Thus substitution ϑ mapping r cid4 r cid4 g map r r g r r cid4 variables cid2 331 Soundness Magic Set method Let start ﬁrst proof particular stating deﬁnitions notations Given deﬁne set atoms relevant DMSQ P model N GroundDMSQ PM cid4 M cid4 cid4 cid4 model M Q false respect N cid4 cid4 cid4 cid4 killed atoms respect M Deﬁnition 314 Killed atoms Given model M killedM QP N cid4 kt BP N cid4 cid5 cid5 k EDB predicate binding α magic cid2 cid3 kαt cid6 cid4 N DMSQ P model N cid4 deﬁned N cid4 cid4 M cid4 GroundDMSQ PM cid4 set Example 315 We consider program DMSQsc Psc presented Section 32 recall Qsc scc EDB produced_byp c c1 introduced Example 310 stable model M produced_byp c c1 scc magic_scbc magic_scbc1 DMSQsc Psc Thus GroundDMSQsc PscMsc consists following rules cid4 sc magic_scbc scc scc1 magic_scbc magic_scbc1 produced_byp c c1 magic_scbc1 magic_scbc cid4 sc model program compute killed Since M magic_scbc1 M produced_byp c1 c controlled_byc c1 c1 c1 belong killed belongs set cid4 sc check scc1 belongs cid4 sc Note deﬁnition false ground instances EDB predicates like cid4 sc Moreover note atom cid4 M sc QscPsc M M cid4 M sc QscPsc The intuition underlying deﬁnition killed atoms false ground instances EDB predicate cid4 N expect atoms false stable model P false atoms relevant respect Q exists associated magic atom model N model GroundDMSQ PM containing M restricted atoms originally occurring P cid4BP recall model M contained M cid4 cid4 cid4 cid4 produced_byp c c1 scc coin Example 316 Let resume Example 315 We M cides model Msc Example 310 Hence know scc1 unfounded set Psc respect cid4 cid14Msc BPsc sc k EDB predicate M cid15 Therefore consequence Theorem 311 M killed stable model M Psc Msc M BPsc case Msc disjoint killed cid15 Since atom kt killed cid4 sc unfounded set Psc respect cid14Msc BPsc cid4 M sc QscPsc cid4 M sc QscPsc Psc M cid4 sc cid4 M sc QscPsc cid4 sc M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 171 This intuition formalized Proposition 317 Let M unfounded set P respect cid14M model DMSQ P N cid4BP BP cid15 cid4 cid4 M cid4 model GroundDMSQ PM cid4 Then killedM QP N cid4 cid4 Proof According Deﬁnition 39 unfounded sets P respect cid14M form cid4BP BP cid15 given rule r g GroundP r g kt p1t1 pntn q1s1 q js j q j1s j1 qmsm cid4 Hr g following conditions holds 1a B r g cid2 BP kt killedM 1b B QP N r g killedM cid4 cid4 r g M cid4BP cid9 2 B cid4 cid9 3 Hr g M Note properties refer original program P However hypothesis formulated trans formed DMSQ P instance know M model DMSQ P The line proof analyze DMSQ P light syntactic relationships P established Lemma 313 In particular recall ﬁrst magickαt ground atom BDMSQP Deﬁnition 314 binding α magickα t N Thus apply Lemma 313 conclude existence ground rule r GroundDMSQ P cid4BP killedM cid4 cid9 QP N QP N cid4 cid4 cid4 cid4 g kt p1t1 pntn magic cid2 cid2 cid3 kαt cid3 cid3 α1 αn n tn 1 t1 q1s1 q js j q j1s j1 qmsm magic magic p p cid2 cid4 g r cid4 model DMSQ P proof based analyzing following scenarios exhaustively cover Since M possibilities concerning fact rule r cid4 g satisﬁed M cid4 S1 B S2 B S3 B cid4 g M cid4 g cid2 M cid4 g M r r r r true respect M cid4 cid9 negative body r cid4 positive body r cid4 B cid4 g M Hr cid4 cid4 cid4 g false respect M cid4 cid4 g false respect M cid4 g M cid4 cid4 cid9 previous cases holds head r cid4 g In remaining shall S1 implies condition 1b S2 implies condition 2 S3 implies 2 3 In fact note condition 1a hold S1 Assume B B r g M S2 Assume B cid2 t k r cid4 r cid4 g M cid4 cid9 Since B cid4BP cid9 1b holds cid4 let r r cid3 cid4 g cid2 M cid3 cid2 cid4 t 1 p1 cid4 pn r g B r cid4 g B r g BP B r cid4 g M cid4 cid9 immediately conclude cid4 DMSQ P modiﬁed rule r cid3cid3 cid2 cid4 t n cid2 kα cid2 t cid3cid3 p cid2 cid3 cid4 cid2 cid4 t 1 cid2 magic cid3 cid2 s α1 1 q j1 cid4 j cid3 s cid4 j1 magic cid3 cid4 1 q1 s cid2 q j magic p qm αn n cid2 cid2 cid4 t n cid4 s m cid3 cid4 g r cid4ϑ substitution ϑ cid2 cid3cid3 cid4 cid4 cid4 r r r r αi t magic rule r Hr hold case To prove claim observe Generation cid4 magicp cid4 j produced 1 cid4 cid4 n recall magic rules negative bodies cid4 obtain ig magickαt q1s1 q js j magickαt model containing magickαt cid4 cid4 cid4 g cid2 M magic rules N applying substitution ϑ r However impossible N magickαt αi ti B cid4 B cid4 gBP N cid4 g N cid4 M cid4 1 q js We ﬁrst claim B cid4 gBP Thus B cid4 gBP cid2 N cid4 step preceding production r q1s Hence variables r subset variables r ig magicp ig Hr ground rule r cid4 r r B assumption conclude B imply B Now B In particular assume wlog qs B cid4 r rule P modiﬁed rule r r B Otherwise qi IDB predicate In case magic rule r magicq implies existence atom qisi B cid4 r g cid2 N cid4 r gBP cid2 N Hr cid4 gBP N cid4 gBP qs If qi EDB predicate atom qisi belongs killedM cid4 gBP qisi N cid4 kα t r generated kα t qisi BP N case qs N minimum element cid4 deﬁnition killed atoms produced Generation step preceding cid4 r qs holds magickαt belongs N cid4 cid4 βi si belongs N cid4 follows deﬁnition killed atoms Thus independently type EDB magickαt cid4 Br r ϑ belongs GroundDMSQ P In particular B ig N model GroundDMSQ PM cid4 qs cid4 kα t magicq QP N cid4 B production r Thus r properties qisi Therefore N qisi killedM IDB qi 2 holds QP N βi s B qis qis r r r ig cid4 cid4 cid4 r r r cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 172 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 S3 Assume B r cid4 g M cid4 B r cid4 g M cid4 Hr cid4 g M obtained r cid4 cid9 First observe B cid4 cid4 g removing negative body literals Consider cid4 g M r cid4 ig produced Generation step 1 cid4 cid4 n S2 We distinguish cases conclude B r implies magicp model GroundDMSQ PM cid4 g M cid4BP killedM QP N cid4 cid4 g contains standard atoms Hr cid4 Deﬁnition 314 N cid4 cid4 cid4 ig N αi ti N 1 cid4 cid4 n Moreover 1 cid4 cid4 n Then We observe cid4 cid9 Moreover equiv cid4 g Hr g In addition cid4 holds Hence cid4 killedM cid4 QP N cid4 cid4 cid4 cid4 cid4 cid4 B cid4 g N cid4BP killedM holds Hr magickαt N model GroundDMSQ PM conclude rule GroundDMSQ PM rules r If q1s1 q js j N N cid4 r g N cid4 g M Hr alent Hr g M cid4 M N cid4 killedM Hr g M Otherwise q1s1 q js j cid2 N qis predicate atom qisi belongs killedM magic rule r cid4 cid9 N cid4 cid9 equivalent Hr cid4 cid9 Hr QP N cid4 Hr g M cid4 conclude Hr g N cid4 Hr g N cid4 implies qs N QP N cid4 killedM QP N QP N cid4 cid4 cid4 cid4 cid4 cid4 cid4 condition 3 holds Let 1 j qisi N r rule P modiﬁed rule r cid4 qs B cid4 kα t generated If qi EDB cid4 deﬁnition killed atoms Otherwise qi IDB predicate cid4 ig N cid4 follows deﬁnition killed atoms βi si head B cid4 gBP qs r r cid4 r cid4 Therefore magicq Thus independently type EDB IDB qi 2 holds cid2 βi si belongs N GroundDMSQ P having atom magicq qisi killedM QP N cid4 cid4 ig We complete ﬁrst proof Lemma 318 For stable model M cid4 DMSQ P stable model M P M M cid4BP Proof Let M stable model P M shall M fact stable model P M M So line proof M stable possible build model N N contradicting minimality M models GroundDMSQ PM cid4BP program obtained adding P fact atom M cid4BP Of course M model P M M cid4BP We cid4BP GroundDMSQ PM cid4 M cid4 cid4 cid4 cid4 cid4 Assume sake contradiction M stable let N M model GroundPM Deﬁne N cid4 cid4BP M cid4 cid4 M cid4 BP By construction note N N M interpretation N M fact case N model GroundPM model GroundP M cid4BP So N holds However impossible M stable model P M proof contradiction remains N rules GroundDMSQ PM cid4 M cid4BP N M cid4 cid4 cid4 M To end consider following kinds rules actually model GroundDMSQ PM cid4 cid4BP M coincides M cid4BP M cid4 BP In cid4 BP disjoint Hence N cid4BP M hand N M cid4 M hold Hence complete satisﬁes cid4 cid4 GroundDMSQ PM 1 Consider ground magic rule r g r B cid4 cid4 M g Since N g 1 magicpαt M atom Hr Hr atom magicpαt contained M implies B hold recall B let magicpαt B r model DMSQ P g M r g Moreover BP contain magic cid4 cid9 cid4 BP Thus construction N GroundDMSQ P r g N In fact M 2 Consider rule obtained removing negative literals ground modiﬁed rule r conclude Hr g N g N cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 g cid4 g r pt p1t1 pntn magic cid2 cid2 magic cid3 pαt cid3 α1 1 t1 q1s1 q js j q j1s j1 qmsm cid4 g M cid3 αn n tn magic p p cid2 r B GroundP associated r cid4 g N cid4 cid4 g according Lemma 313 Observe B r cid4 holds deﬁnition reduct Moreover let r g rule r g pt p1t1 pntn q1s1 q js j q j1s j1 qmsm We Hr cid4 g N cid4 cid9 The proof based establishing following properties r cid4 g r g cid2 cid3 M cid4 cid3 cid2 cid3 M cid4 M killedM QP cid3 cid4 cid4 M H g cid4 M B g cid2 cid3 cid2 cid4 H M H r r Hr g N cid9 cid2 r cid2 r cid4 g cid3 cid4 g M cid4BP H cid3 cid2 r cid4 g M 1 2 3 4 5 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 173 In particular shall directly prove 1 following implications 1 2 3 2 4 3 5 cid4 cid9 easily derived follows Since Hr g BP cid4BP Moreover coincides turn Hr g N Hr g M Then recall N M Eventually based 4 5 fact Hr deﬁnition N 4 fact Hr g Hr Thus Hr g N conclude Hr g N cid4 g Hr g N cid4 Hr g N 5 cid4BP Hr g N Hr g M cid4 Hr g N M cid4 cid4 g N cid4 In order complete proof equations actually hold cid4BP BP cid15 In fact notice killedM Proof 1 We recall Proposition 317 know killedM respect cid14M cid14M Deﬁnition 314 Thus M M cid4 conclude M killedM cid4BP BP cid15 rules added P facts corresponding atoms M cid4BP M stable model P M QP M cid4 unfounded set P M cid4 unfounded set P cid4BP respect cid4 QP M cid4BP apply Theorem 311 order cid4BP killedM cid4BP M QP M cid4 cid4 cid4 QP M cid4 Proof 2 After 1 Hr implies B r cid4 g M cid4 Thus Hr cid4 g M cid4 killedM cid4 QP M cid4 g M cid4 killedM cid4 QP M cid4 In fact N cid4 M cid4 cid4 follows Deﬁnition 314 form rule r note B cid4 g r cid4 g N cid4 Proof 3 After 1 B belong killedM QP M To end consider modiﬁed rule r cid4 EDB atoms B r cid4 cid4 r cid3 cid2 t cid4 p cid3 cid2 cid4 t 1 p1 pn cid2 cid4 t n r cid4 g killedM QP M cid4 cid4 g clearly belong killedM cid4 DMSQ P r cid2 cid3 cid3cid3 cid4 g cid2 t cid4 pα magic cid3 cid4 1 q1 s cid2 magic cid3 cid2 s cid4 j q j q j1 cid4 r QP M cid4 g cid4 assumption cid4 B cid4 Actually IDB atoms B r cid4 g M cid4ϑ substitution ϑ cid3cid3 cid2 cid4 t 1 cid2 s magic qm cid2 cid4 t n cid3 cid4 s m αn n cid2 cid4 j1 cid3cid3 p cid3 cid2 r cid2 p α1 1 cid4 cid4 produced j 1 cid4 cid4 m qi IDB predicate Hence variables r magicq Hr magic rule r cid4 B βi s During Generation step preceding production r r B variables r r ig B ig true respect M substitution ϑ map r cid4 g N cid4 cid4 g Now B cid4 M r r B cid4 r holds j 1 cid4 cid4 m qi IDB predicate Moreover B βi si B q cid4 g Thus Deﬁnition 314 q βi si killedM QP M r cid4 cid4 cid4 ground rule r conclude B r recall magic rules negative bodies That magicq r cid4 implies q ϑ Hr ig turn contained M ig magicq r ig cid4 cid4 g M r subset βi si Thus head cid4 βi si M cid4 βi si BP M Proof 4 The property immediately follows 2 fact Hr cid4 g BP M M cid4BP Proof 5 Note B atoms B r g N speciﬁcally B B Hr g N cid9 cid2 r r g B cid4 g 3 implies rule GroundPM obtained r g removing r cid4 r g Note B cid4 g N Thus deﬁnition N cid4BP Moreover N model GroundPM entails r g B r g N M cid4 BP B cid4 g BP N r cid4 Theorem 319 Let Q query Datalog M P M cid4Q MQ s program P Then stable model M cid4 DMSQ P stable model Proof Because Lemma 318 stable model M M cid4BP Thus trivially MQ M In fact deﬁnition DMSQ P magic seed associated ground instance Q Then BP Q cid4 Deﬁnition 314 recall BP Q denotes ground instances Q By Proposition 317 cid4 killedM cid4BP BP cid15 Hence Theorem 311 M QP M cid4Q implies QP M QP M cid4 unfounded set P respect cid14M cid4 It follows M BP Q M cid4Q holds We inclusion proper cid4Q combined MQ M cid4 Thus MQ M DMSQ P stable model M P M cid4 cid4 cid4 M killedM killedM MQ M cid4 cid4Q cid2 332 Completeness Magic Set method For second proof construct interpretation DMSQ P based P 174 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 Deﬁnition 320 Magic variant Let I interpretation P We deﬁne interpretation variant called magic variant I respect Q P limit following sequence QP I DMSQ P variant0 varianti1 cid4 QP I EDBP QP I varianti QP I cid5 cid5 binding α cid6 cid3 pαt QP I magic cid3 cid5 cid3 cid5 r DMSQ P g cid2 cid3 pαt H r g Ground cid3 g varianti cid2 B cid2 r cid3 cid2 pαt cid2 pt I cid4 cid2 magic magic cid6 QP I varianti cid3 0 Example 321 Consider program DMSQsc Psc presented Section 32 EDB produced_byp c c1 terpretation Msc produced_byp c c1 scc We compute magic variant variant Msc Msc respect Qsc Psc We start sequence original EDB variant0 Msc produced_byp c c1 For variant1 Msc add scc Msc magic_scbc1 magic_scbc1 magic_scbc scc Msc magic_scbc variant0 rule GroundDMSQsc Psc magic_scbc variant0 Msc Any element sequence coincides variant2 Msc variant QscPsc Msc add magic_scbc query seed variant2 QscPsc Msc QscPsc QscPsc QscPsc QscPsc QscPsc QscPsc By deﬁnition magic variant variant QP I interpretation I respect Q P variant holds More interestingly magic variant stable model P turn stable model DMSQ P QP IBP I Example 322 The magic variant Msc respect Qsc Psc Example 321 coincides interpretation cid4 M sc stable model DMSQsc Psc cid4 sc introduced Example 315 From previous examples know Msc stable model Psc M The following lemmas formalize intuition counterpart Lemma 318 Lemma 323 For stable model M P magic variant M M M cid4BP cid4 variant QP M M model GroundDMSQ PM cid4 cid4 magic variant stable model M trivially M M Proof As M model GroundDMSQ PM rule obtained removing negative body literals rule r r B hold We Hr cid4 cid4 cid4 g cid4 g M To end consider rule GroundDMSQ PM GroundDMSQ P B cid4 cid4BP holds We M having body true cid4 cid4 g M r cid4 In case r cid4 g magic rule B cid4 g belongs M cid4 tion 320 The remaining slightly involved case analyzed r g modiﬁed rule form cid2 cid3 cid3 α1 αn n tn 1 t1 q1s1 q js j q j1s j1 qmsm pt p1t1 pntn magic implies atom Hr cid3 pαt magic magic cid4 g p p cid2 cid2 r cid4 cid4 Deﬁni cid4 cid9 cid4 g M cid4 r g M In case ﬁrst apply usual Lemma 313 order conclude existence rule r g GroundP form r g pt p1t1 pntn q1s1 q js j q j1s j1 qmsm Then claim following properties hold B B r g M r g M 6 7 These properties fact need establish result Indeed M model GroundPM 6 7 cid4 g M imply Hr g M cid9 So recall Hr g Hr cid4 r r g magicp M Deﬁnition 320 That Hr g let piti atom Hr g M Hr cid4 g cid6 1 n cid6 string Since B cid4 hypothesis piti M conclude piti M cid4 g M Let ﬁnalize proof showing properties actually hold αi ti corresponding magic atom B cid4 cid9 cid4 cid4 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 175 cid4 DMSQ P r Proof 6 Consider modiﬁed rule r cid3 cid3cid3 cid3 cid3 cid2 cid4 g cid2 cid4 r p cid2 t cid4 cid2 cid4 t 1 p1 pn cid2 cid4 t n cid2 t cid4 r p α1 1 cid3cid3 cid4ϑ substitution ϑ cid2 cid2 cid4 cid4 t t n 1 cid3 cid2 cid4 s s m qm magic cid4 j1 αn n cid2 p cid3 cid2 cid3cid3 q j1 rule r P r cid3 cid3 cid4 cid2 t cid4 cid2 cid4 t 1 p1 r p pn cid2 cid4 t n q1 s cid4 1 q j q j1 s cid4 j cid3 cid2 s cid4 j1 qm cid2 cid3 cid4 s m pα cid2 magic cid3 cid4 1 produced r g rϑ cid3 magic cid3 cid2 s q j q1 cid4 j s cid2 cid3 cid2 cid3 cid4 B magic rule r IDB predicate Hence variables r ig ground rule r cid4 substitution ϑ map r r During Generation step preceding production r produced j 1 cid4 cid4 m qi variables r r ig B r ig turn contained M magicq belongs M Deﬁnition 320 conclude qisi M r g B recall B EDB predicates B cid4 g This proves IDB predicates B cid4 g M r r g M ti M βi cid4 M cid4 g recall magic rules negative body Now B Thus construction M head r ig true respect M holds j 1 cid4 cid4 m qi IDB predicate So IDB atom qisi B cid4 g M r g cid4 r g occur M The trivially holds contradicts assumption B cid4 subset ti βi conclude ig magicq cid4 cid4 EDBP deﬁnition magic variant ϑ Hr r cid4 g M Hr magicq cid4 B βi s r r r B cid4 cid4 cid4 cid4 cid4 Proof 7 The equation straightforwardly follows fact B r B hold construction M initial hypothesis choice r cid4 cid4 cid4 g M r g B r cid4 gBP M M cid4 g respectively cid2 cid4BP Lemma 324 For stable model M P stable model M M M cid4BP cid4 DMSQ P magic variant M cid4 Let N Proof After Lemma 323 M PM variant M contains EDB facts Suppose varianti turn contained N cid4 M cid4 cid4 minimal model GroundDMSQ PM cid4 cid4 variant QP M minimal models GroundDMSQ We prove induction deﬁnition magic QP M QP M N cid4 clearly true variant0 QP M N holds cid4 The base case variant0 cid4 order prove varianti1 cid4 While considering atom varianti1 QP M distinguish cases QP M N QP M varianti cid4 g g magicpαt B For magic atom magicpαt varianti1 GroundDMSQ P having Hr negative body r hypothesis magicpαt N b For standard atom pt varianti1 QP M varianti QP M Deﬁnition 320 rule r r g varianti holds We conclude B cid4 model GroundDMSQ PM QP M recall magic rules cid4 holds induction GroundDMSQ PM cid4 cid4 N QP M varianti r QP M Deﬁnition 320 binding α QP M atom pt belongs M Assume sake contradiction pt N cid4 cid4 compute set killedM QP N cid4 holds deﬁnition Moreover cid4BP holds cid4BP apply Theorem 311 cid4 pt M magicpαt varianti Since M introduced Section 331 note particular pt killedM Proposition 317 killedM Deﬁnition 320 Thus M stable model P M M order conclude M killedM Hence pt N cid2 cid4 The contradiction pt killedM cid4 unfounded set P respect cid14M model GroundDMSQ PM cid4BP BP cid15 In addition M M model DMSQ P N g N QP N QP N QP N QP N g cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 cid4 We prove correspondence stable models respect queries Theorem 325 Let Q query Datalog DMSQ P magic variant M M cid4Q MQ s program P Then stable model M P stable model M cid4 Proof Let M stable model P M model DMSQ P M M inclusion cid4 variant cid4BP Thus trivially MQ M QP M magic variant Because Lemma 324 M cid4 stable cid4Q holds We reverse Since M cid4 stable model DMSQ P determine set killedM Deﬁnition 314 conclude BP Q M recall BP Q denotes ground instances Q Moreover M stable model P M M QP M cid4 M cid4 killedM cid4 cid4 QP M cid4 cid4 deﬁned Section 331 Hence contains magic seed construction cid4BP 176 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 cid4 killedM M killedM equivalent MQ M QP M QP M cid4 cid4Q cid2 cid4 unfounded set P respect cid14M cid4 Theorem 311 Thus combining b obtain BP Q M cid4BP BP cid15 Proposition 317 conclude b cid4 M Finally correctness Magic Set method respect query answering prove original rewritten programs provide answers input query possible EDBs Theorem 326 Let P Datalog s program let Q query Then DMSQ P b Q P DMSQ P c Q P hold facts F deﬁned EDB predicates P DMSQ P Proof We want AnsbQ DMSQ P F AnsbQ P F AnscQ DMSQ P F AnscQ P F hold We ﬁrst observe Magic Set rewriting depend EDB facts DMSQ P F DMSQ P F holds Moreover note s programs stable models Therefore direct consequence Theorem 319 Theorem 325 Datalog conclude AnsbQ DMSQ P F AnsbQ P F AnscQ DMSQ P F AnscQ P F cid2 set 34 Magic Sets stratiﬁed Datalog programs disjunction Stratiﬁed Datalog programs disjunction exactly stable model 29 However Magic Set transfor mation introduce new dependencies predicates possibly resulting unstratiﬁed programs refer analysis 38 Clearly original rewritten programs agree query proved previous section question rewritten program admits unique stable model important In fact programs having unique stable model property brave cautious reasoning coincide solver immediately answer query ﬁrst unique stable model The following theorem states rewritten program stratiﬁed program unique stable model Theorem 327 Let P disjunctionfree Datalog program stratiﬁed negation Q query Then DMSQ P unique stable model Proof Let M unique stable model P M By Lemma 324 know M DMSQ P contains M variant0 Thus considering atom varianti1 QP M contains EDB facts Suppose varianti induction structure M cid4 cid4 stable model DMSQ P We stable model N QP M magic variant presented Deﬁnition 320 clearly true QP M N order prove varianti1 QP M N The base case variant0 holds cid4 cid4 cid4 cid4 cid4 QP M N QP M varianti QP M cases possible cid4 variant 1 For magic atom magicpαt varianti1 GroundDMSQ P having Hr negative bodies r hypothesis magicpαt N 2 For standard atom pt varianti1 GroundDMSQ PN cid4 cid4 N QP M varianti g magicpαt B g cid4 QP M varianti QP M Deﬁnition 320 rule r r g varianti holds We conclude B cid4 model GroundDMSQ PN QP M recall magic rules cid4 holds induction r g N g cid4 stable model DMSQ P compute set killedN QP M Deﬁnition 320 binding α QP M atom pt belongs M Assume sake contradiction pt N magicpαt varianti cid4 cid4 introduced Section 331 note Since N particular pt killedN cid4 unfounded QP N cid4BP set P respect cid14N mean pt N holds Hence conclude N M different stable models P obtaining contradiction P unique stable model QP N cid4BP BP cid15 In addition Lemma 325 stable model N P N N cid4 holds deﬁnition Moreover Proposition 317 killedN QP N cid4 cid4 cid4 Since stable models incomparable respect containment M stable model DMSQ P cid2 cid4 N cid4 implies M cid4 N cid4 Hence M cid4 unique 4 Implementation The Dynamic Magic Set method DMS implemented integrated core DLV 43 In section shall ﬁrst brieﬂy architecture usage We brieﬂy present optimization eliminating redundant rules introduced Magic Set rewriting M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 177 Fig 6 Prototype architecture 41 System architecture usage We created prototype implementing Magic Set technique described Section 3 inside DLV shown architecture reported Fig 6 DLV supports brave cautious reasoning completely ground query computing stable models query true DLV performs brave reasoning invoked commandline option FB FC indicates cautious reasoning In prototype DMS algorithm applied automatically default user invokes DLV FB FC partially bound query Magic Sets applied default query contain constant The user modify default behavior specifying commandline options ODMS applying Magic Sets ODMS disabling Magic Sets If completely bound query speciﬁed DLV print magic variant stable model displaying magic predicates witnesses truth brave reasoning falsity cautious reasoning query specifying commandline option printmodel Within DLV DMS applied immediately parsing program query Magic Set Rewriter module The rewritten optimized described Section 42 program processed Intelligent Grounding module Model Generator module implementation DLV The modiﬁcation output ﬁltering For ground queries witnessing stable model longer printed default printmodel speciﬁed case magic predicates omitted output The SIPS schema7 implemented prototype follows For rule r head atom pt binding α pα t satisﬁes conditions Deﬁnition 33 particular pt pα t bz holds head negative body atoms qs cid9 pt atom bz r Moreover positive body literals r form chain pα t This chain constructed iteratively inserting atoms containing bound arguments considering α chain Among atoms bindings arbitrary processing partially formed chain f qs X holds qs pα t r pα t order usually order appearing original rule body Furthermore r belongs positive body r bound argument X occurs s qs holds qs cid9 pt r qs pα t f r r r r 7 Since technically SIPS deﬁnition single rule implementations use schema creating SIPS given rule 178 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 This means apart head atom rule adorned positive body atoms yield variable bindings arguments bound atoms EDB IDB predicates Moreover atoms bound arguments processed fewer bound arguments Note work study impact trying different SIPS schemes wanted focus showing impact technique ﬁnetuning parameters While believe SIPS schema employed wellmotivated probably bit room improvement leave future work An executable DLV supporting Magic Set optimization available httpwwwdlvsystemcommagic 42 Dealing redundant rules Even rewriting algorithm keeps generated rules low happen redundant rules generated adorning disjunctive rules somewhat deteriorating optimization effort For instance Example 36 ﬁrst modiﬁed rules semantically equivalent happen head predicates differ In general duplicated rules created rules logically subsumed rules program Let ﬁrst deﬁnition subsumption Datalog s rules cid4 Deﬁnition 41 Let P Datalog r cid25 r exists rule r exists substitution ϑ variables r r cid25 r program let r r cid4 cid4 cid4 cid4 rules P Then r subsumed r cid4 denoted cid4ϑ Br A rule r redundant Hr cid4ϑ Hr Br Ideally Magic Set rewriting algorithm capable identifying possible redundant rules removing output Unfortunately approach unlikely feasible polynomial time given subsumption checking ﬁrstorder expressions NPcomplete problem LO18 27 Thus order identify rule r produced Magic Set transformation redundant pragmati cally apply greedy subsumption algorithm implementation checking r cid25 r In particular employed heuristics aims building substitution ϑ Deﬁnition 41 iteratively choosing atom pt processed r matching possible atom r The greedy approach prefers atoms r maximum number variables matched holds rule r cid4 cid4 cid4 cid4 To turn subsumption checking applied Magic Set rewriting DLV invoked command line option ODMS 5 Experiments standard benchmarks We performed experiments assessing effectiveness proposed technique In section present results obtained standard benchmarks directly adopted literature Further experiments application scenario realworld data discussed Section 6 We refer 4554 contain performance evaluations involving DMS 45 DLV DMS tested Semantic Web reasoning tasks confronted heterogeneous set systems 54 KAON2 includes version DMS confronted ontology systems In publications impact Magic Sets stated explicitly 51 Compared methods benchmark problems data In order evaluate impact proposed method compared DMS SIPS deﬁned outlined Section 4 traditional DLV evaluation Magic Sets SMS method proposed 33 Concerning SMS able obtain implementation performed rewriting manually As consequence runtime measures obtained SMS contain time needed rewriting included DMS For comparison consider following benchmark problems The ﬁrst assess SMS 33 refer details Simple Path Given directed graph G nodes b exist unique path connecting b G The instances encoded facts edgev1 v2 arc v 1 v 2 G problem encoded program8 spX X not_ spX X edgeX Y spX Y not_ spX Y spX Z edgeZ Y 8 The ﬁrst rule program models node X G unique path connecting X exist M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 179 Fig 7 Instances structure Simple Path Related left Conformant Plan Checking right pathX Y spX Y pathX Y not_ spX Y not_ spX Z pathX Y1 pathX Y2 Y1 Y2 edgeY1 Z edgeY2 Z query spa b The structure graph reported 33 consists square matrix nodes connected shown Fig 7 instances generated varying number nodes Related Given genealogy graph storing information relationships fatherbrother people given people p1 p2 p1 ancestor p2 The instances encoded facts relatedp1 p2 p1 known related p2 p1 father brother p2 The problem encoded program fatherX Y brotherX Y relatedX Y ancestorX Y fatherX Y ancestorX Y fatherX Z ancestorZ Y query ancestorp1 p2 The structure genealogy graph presented 33 coincides testing Simple Path Also case instances generated varying number nodes number persons genealogy graph cid4 1 m ci C Strategic Companies This slight variant problem domain running example The description problem posed Third ASP Competition We consider collection C companies com pany produces goods set G company ci C controlled set owner companies O C cid4 C strategic set minimal set companies producing goods G A subset companies C O C hold As Second Answer Set Competition9 assume product produced companies company controlled companies complexity problem restrictions hard Given dis tinct companies ci c j C strategic set C contains ci c j The instances encoded facts produced_byp c1 c2 c3 c4 product p produced companies c1 c2 c3 c4 p produced fewer companies c1 c2 c3 c4 contains repetitions companies Moreover facts controlled_byc c1 c2 c3 c4 represent company c controlled companies c1 c2 c3 c4 c controlled fewer companies c1 c2 c3 c4 contains repetitions The problem encoded program cid4 stC1 stC2 stC3 stC4 produced_byP C1 C2 C3 C4 stC controlled_byC C1 C2 C3 C4 stC1 stC2 stC3 stC4 query stci stcj While language presented previous sections allowed atom query simplicity implementation DLV allows conjunction query easy conjunctive query emulated rule conjunction body atom new predicate head contains body arguments ﬁnally replacing query conjunction atom In case mean adding rule qci cj stci stcj replacing query qci cj For benchmark instances submitted Second Answer Set Competition 9 httpwwwcskuleuvenbedtaieventsASPcompetitionindexshtml 180 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 Fig 8 Simple Path Average execution time Conformant Plan Checking In addition included benchmark problem highlights fact Magic Set technique yield improvements grounding model generation phase discussed Section 7 This problem inspired setting planning particular testing given plan conformant respect state transition diagram 30 Such diagram essentially directed graph formed nodes repre senting states arcs labeled actions meaning executing action source state lead target state In considered setting nondeterminism allowed executing action state lead nondeterministically successor states A plan sequence actions conformant respect given initial state goal state possible execution action sequence leads goal state In benchmark assume action selection process having reduced state transition diagram transitions actually occur executing given plan Furthermore assume exactly possible nongoal successor states given state This viewed outgoing paths node directed graph reach particular conﬂuence node We encoded instances facts ptranss0 s1 s2 meaning states s1 s2 reached plan execution starting s0 The problem encoded transX Y transX Z ptransX Y Z reachX Y transX Y reachX Y reachX Z transZ Y query reach0 1 0 initial state 1 goal state If query cautiously true plan conformant The transition graphs experiments shape binary tree rooted state 0 leaf arc state 1 depicted Fig 7 In addition performed experiments application scenario modeled realworld data swering user queries data integration setting These experiments discussed Section 6 52 Results discussion The experiments performed 3 GHz Intel Xeon processor 4 GB RAM Debian 40 operating GNULinux 2623 kernel The DLV prototype compiled GCC 433 For instance allowed maximum running time 600 seconds 10 minutes maximum memory usage 3 GB On considered problems DMS outperformed SMS SMS include rewriting time discussed Section 51 Let analyze results problem The results Simple Path reported Fig 8 DLV Magic Sets solves smallest instances steep increase execution time SMS better DLV scales worse DMS The difference SMS DMS grounding additional predicates SMS introduces Fig 9 reports results Related Compared Simple Path DLV Magic Sets exhibits steeper increase runtime contrast SMS DMS scale better Simple Path Comparing SMS DMS note DMS appears exponential speedup SMS In case computational gain DMS SMS dynamic optimization model search phase resulting Magic Sets deﬁnition This aspect better highlighted Conformant Plan Checking benchmark discussed later section For Strategic Companies report results Fig 10 bar diagram instances uniform structure The instances ordered size Also DLV Magic Sets clearly eﬃcient M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 181 Fig 9 Related Average execution time Fig 10 Strategic Companies Average execution time tested systems resolving smallest instances allotted time 600 seconds Concerning systems SMS DMS essentially equal performance In fact situation different Simple Path Related grounding program produced Magic Set rewriting takes negligible time SMS DMS For benchmark important feature reducing ground program relevant query verify ground programs produced SMS DMS precisely Finally results Conformant Plan Checking shown Fig 11 While DLV shows similar behavior Simple Path Related SMS scale fact DMS appears exponential speedup SMS There precise reason While Magic Set rewriting SMS creates deterministic program deﬁn ing magic predicates true DMS As consequence magic predicates completely evaluated grounding phase DLV SMS DMS case At ﬁrst glance like disadvan tage DMS believe ground program larger However actually big advantage DMS offers precise identiﬁcation relevant program Roughly speaking SMS identiﬁes relevant query identiﬁed relevant DMS DMS include nondeterministic relevance formation SMS This means DMS Magic Sets exploited nondeterministic search phase DLV dynamically disabling parts ground program In particular having choices parts program longer relevant query choices magic atoms present ground program render parts satisﬁed means longer considered search SMS induce behavior like effect limited grounding phase DLV huge difference evidenced Conformant Plan Checking 53 Experimenting DMS disjunctive Datalog systems In order assess effectiveness DMS systems DLV tested grounder Gringo 28 following solvers ClaspD 21 Cmodels 46 GnT1 GnT2 37 ClaspD based advanced Boolean constraint solving techniques featuring backjumping conﬂictdriven learning Cmodels based deﬁnition program completion loop formula disjunctive programs 4047 uses SAT solver generating candidate solutions testing 182 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 Fig 11 Conformant Plan Checking Average execution time Fig 12 Simple Path Average execution time systems GnT1 based Smodels 61 handling Datalog programs unstratiﬁed negation normal programs A disjunctive program translated normal program stable models computed Smodels represent stable model candidates original program Each candidates checked stable model original program invoking Smodels second normal program GnT2 variant GnT1 number candidates produced ﬁrst normal program reduced means additional rules discard unsupported models models containing atom rule r Br true true atom Hr All benchmarks presented previous section tested systems Since DMS implemented systems rewritten programs produced DLV preparation experiment We recall DMS depend EDB relations point DLV computes rewritten programs considered encodings 12 hundredths second The results experiment reported Figs 1216 In general tried use consistent scales graphs order ease comparability However graphs chose different scale order readable main purpose comparing performances DMS mention explicitly accompanying text Concerning Simple Path advantages DMS unoptimized encoding evident tested systems In fact shown Fig 12 DMS tested systems answered allotted time 600 seconds instances 400 nodes 900 Cmodels On hand instances considered benchmark 40 thousands nodes solved tested solvers DMS encoding We observe DMS tested systems faster DLV benchmark clear indication optimization potential provided systems Magic Set technique M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 183 Fig 13 Related Average execution time systems For Related obtained similar result reported Fig 13 different scale yaxis Cmodels readability Without DMS smallest instances solved allotted time 2025 nodes ClaspD Cmodels 625 nodes GnT1 GnT2 With DMS instead tested systems solved biggest instances benchmark 10 thousands nodes In particular DMS Cmodels performant dlv benchmark The effectiveness DMS evident Strategic Companies benchmark Figs 1415 In fact observed sensible performance gains systems tested instances GnT1 faster tested systems benchmark draws particular advantage DMS solving instances seconds We evidence optimization potential provided DMS systems comparing number solved instances Of total 60 tests counted 37 timeouts unoptimized encoding 10 ClaspD 14 Cmodels 3 GnT1 10 GnT2 encoding obtained applying DMS We point timeout rewritten program obtained Cmodels collected 14 timeouts unoptimized encoding performant benchmark Finally consider results Conformant Plan Checking reported Fig 16 different scale yaxis ClaspD readability note ClaspD GnT2 solved smallest instances benchmark different scale xaxes The performance ClaspD poor benchmark nonetheless observed slight improvement execution time DMS applied encoding reported Section 51 Cmodels performs better ClaspD case optimization potential DMS emerges exponential improvement performance A similar result observed GnT1 GnT2 benchmark outlier experiment Its performance deteriorates original program processed DMS However benchmark GnT2 performs worse GnT1 original encoding In fact GnT1 solved biggest instance 65 thousands states 20974 seconds 1228 seconds DMS encoding execution GnT2 terminate allotted time 600 seconds instances containing 10 thousands states We ﬁnally note DMS GnT1 Cmodels faster DLV benchmark In fact biggest instance benchmark GnT1 Cmodels required 1228 1913 seconds respectively DLV terminated 27941 seconds The signiﬁcant performance gain GnT1 Cmodels DMS conﬁrmation potential optimization technique 6 Application data integration In section brief account case study evidences impact Magic Set method programs realize data integration systems We ﬁrst overview data integration systems s ﬁnally assess impact Magic Sets data integration involving implemented Datalog realworld data 61 Data integration systems nutshell The main goal data integration systems offer transparent access heterogeneous sources providing users global schema users query having know sources data come In fact task data integration identify access data sources relevant ﬁnding answer 184 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 Fig 14 Strategic Companies Average execution time systems 1 query global schema followed combination data obtained The data integration uses set mapping assertions specify relationship data sources global schema Following 41 formalize data integration I triple cid14G S Mcid15 1 G global relational schema pair cid14Ψ Σcid15 Ψ ﬁnite set relation symbols associated positive arity Σ ﬁnite set integrity constraints ICs expressed symbols Ψ ICs ﬁrstorder assertions intended satisﬁed database instances 2 S source schema constituted schemes sources data integration We assume S relational schema form S cid14Ψ cid4 cid15 means integrity constraints sources This assumption implies data stored sources locally consistent common assumption data integration sources general external integration charge analyzing restoring consistency 3 M mapping establishes relationship G S In framework mapping follows GAV approach global relation associated viewa Datalog s query sources The main semantic issue data integration systems integrated sources originally autonomous data transformed mapping assertions satisfy constraints global schema An approach remedy problem lately received lot literature 311121416192526 based notion repair inconsistent database introduced 4 Roughly speaking repair database new database satisﬁes constraints schema minimally differs original Since inconsistent database possess multiple repairs standard approach answering user queries return answers true possible repair These called consistent answers literature 62 Consistent query answering Datalog s queries There intuitive relation consistent answers queries data integration systems queries s s programs Indeed ﬁnd translation data sources mapping query Datalog Datalog M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 185 Fig 15 Strategic Companies Average execution time systems 2 Fig 16 Conformant Plan Checking Average execution time systems 186 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 program possesses stable model possible repair query consistent answers data integration correspond cautious consequences obtained Datalog s setting In fact authors 5714161731 considered idea encoding constraints global schema G kinds logic programs stable models program yield repairs database retrieved sources Some approaches use logic programs unstratiﬁed negation 16 disjunctive Datalog programs unstratiﬁed negation considered 1351 It realized earlier Magic Sets crucial optimization technique context availability transformational approach stable logic programming core language main motivation research presented article way Magic Set method stable logic programs immediately yields optimization technique data integration systems Indeed beneﬁts Magic Sets context optimizing logic programs unstratiﬁed negation disjunction discussed 24 The Magic Set technique deﬁned 24 different deﬁned article consider disjunctive rules works programs consistent stable model In 51 preliminary work reported 20 eventually led present article expanded adhoc way particular kinds Datalog programs disjunction unstratiﬁed negation It adhoc sense tailored programs created transformation described 51 The experimental results reported 51 huge computational advantages Magic Sets We report alternative transformation produces Datalog s programs different 51 unstratiﬁed occurrences negation This rewriting devised INFOMIX data integration 42 Let I cid14G S Mcid15 data integration G cid14Ψ Σcid15 let D database G represented set facts relational predicates G We assume constraints global schema key exclusion dependencies In particular recall set attributes x key relation r cid2 cid3 rx y rx z y z cid6 cid4 rx y rx z D exclusion dependency holds set attributes x relation r set attributes w relation s cid2 cid3 rx y s w z y cid9 z cid6 cid4 rx y s w z D Then disjunctive rewriting query q respect I Datalog s program ΠI ΠKD ΠED ΠM Πcoll For relation r G key deﬁned set attributes x ΠKD contains rules routx y routx z rDx y rDx z Y 1 cid9 Z1 routx y routx z rDx y rDx z Ym cid9 Zm y Y 1 Ym z Z1 Zm For exclusion dependency set attributes x relation r set attributes w relation s ΠED contains following rule routx y sout w z rDx y sD w z X1 W 1 Xm W m x X1 Xm w W 1 W m In implementation following equivalent rule routx y soutx z rDx y sDx z For relation r G Πcoll contains rule r w rD w rout w For Datalog rule r M kt q1s1 qmsm k relation G qi 1 cid4 cid4 m relation S ΠM contains rule kDt q1s1 qmsm M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 187 Fig 17 Average execution time query evaluation INFOMIX Demo Scenario It shown user query Q G source database F S consistent query answers Q precisely coincide set AnscQ Π I F Actually INFOMIX project inclusion dependencies considered according rewriting discussed 16 details omit clarity Since rewriting inclusion dependencies modiﬁes queries INFOMIX project queries limited conjunctive queries s It important notice program ΠI contains stratiﬁed negation Datalog program making Magic Set method deﬁned article applicable 63 Experimental results The effectiveness Magic Set method crucial application context assessed number experiments carried demonstration scenario INFOMIX project refers information University La Sapienza Rome The global schema consists 14 global relations 29 constraints data sources include 29 relations 3 legacy databases 12 wrappers generating relational data web pages This amounts 24 MB data students professors exams faculties university For detailed description INFOMIX project httpswwwmatunicalitinfomix On schema tested ﬁve typical queries different characteristics model different use cases For sake completeness encodings tested queries reported Appendix A In particular measured average execution time DLV computing AnscQ Π I F AnscQ DMSQ Π I F datasets increasing size The experiments performed running INFOMIX prototype 3 GHz Intel Xeon processor 4 GB RAM Debian 40 operating GNULinux 2623 kernel The DLV prototype computational core INFOMIX compiled GCC 433 For instance allowed maximum running time 10 minutes maximum memory usage 3 GB The results reported Fig 17 conﬁrm typical queries performance considerably improved Magic Sets On Queries 1 4 Fig 17 response time scales better Magic Sets appearing essentially linear tested instance sizes Magic Sets behavior decidedly nonlinear appearance We observe basically improvement Query 5 We analyzed query use case data 188 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 relevant query means Magic Sets positive effect It important observe Magic Set rewriting incur signiﬁcant overhead 7 Related work In section ﬁrst discuss main body work related DMS technique developed paper query answering optimization In particular discuss Magic Set techniques Datalog languages The discussion structured paragraphs grouping techniques cover language After discuss applications DMS exploited All applications refer preliminary work published 20 Magic Sets Datalog In order optimize query evaluation bottomup systems like deductive database systems works proposed simulation topdown strategies means suitable transformations introducing new predicates rewriting clauses Among Magic Sets Datalog queries bestknown logical optimization techniques database systems The method ﬁrst developed 6 analyzed reﬁned authors instance 9556263 These works form foundations DMS s Many authors addressed issue extending Magic Set technique order deal Magic Sets Datalog s Datalog queries involving stratiﬁed negation The main problem related extension technique Datalog s programs natural programs assign semantics rewritten programs Indeed Datalog accepted semantics perfect model semantics 264 application Magic Sets introduce unstratiﬁed negation rewritten programs A solution presented 10383959 In particular 3859 rewritten pro programs grams evaluated according wellfounded semantics threevalued semantics Datalog twovalued stratiﬁed programs 1039 adhoc semantics deﬁned All methods exploit s present disjunctive Datalog uniqueness intended model This property turn property Datalog implies query answering consists establishing truth value atoms intended model Using terminology brave cautious reasoning coincide programs Therefore methods different DMS technique developed paper Extending Magic Set technique Datalog programs face major diﬃculties First Magic Sets Datalog program uniqueness intended model guaranteed query answering setting Datalog involves set stable models general The second diﬃculty parts Datalog program act constraints programs impeding relevant interpretation stable model In 24 Magic Set method Datalog deﬁned proved correct coherent programs programs admitting stable model This method takes special precautions relevant parts program act constraints called dangerous rules 24 We observe s programs allows simpler DMS algorithm work correctly dangerous rules occur Datalog class programs The ﬁrst extension Magic Set technique disjunctive Datalog 3233 Magic Sets Datalog SMS method presented proved correct Datalog programs We point main drawback method introduction collecting predicates Indeed magic collecting predicates SMS deterministic deﬁnitions As consequence extension completely computed program instantiation means optimization provided subsequent stable model search Moreover correctness DMS s programs formally established Datalog outlined 3233 s programs general applicability SMS Datalog Applications Magic Sets applied contexts In particular 13365153 proﬁtably exploited optimization provided DMS In particular 1351 data integration presented The based disjunctive Datalog exploits DMS fast query answering In 3653 instead algorithm answering queries description logic knowledge bases presented More speciﬁcally algorithm reduces SHIQ knowledge base disjunctive Datalog program DMS exploited query answering optimization 8 Conclusion The Magic Set method bestknown techniques optimization positive recursive Datalog programs eﬃciency generality Just focused methods supplementary Magic Set special techniques linear chain queries gained similar visibility 345663 After seminal papers 69 viability approach demonstrated 3555 Later extensions reﬁnements proposed addressing query constraints 62 wellfounded semantics 38 integration costbased query optimiza tion 60 The research variations Magic Set method going For instance 24 extension Magic Set method discussed class unstratiﬁed logic programs disjunction In 10 technique class softstratiﬁable programs given Finally 33 ﬁrst variant technique disjunctive programs SMS described M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 189 In paper elaborated issues addressed 3233 Our approach similar SMS differs respects DMS dynamic optimization query answering sense addition optimization grounding process optimization performed SMS DMS drive model generation phase dynamically disabling parts program irrelevant considered partial interpretations DMS strong relationship unfounded sets allowing clean application disjunctive Datalog programs presence stratiﬁed negation DMS improved performing subsequent subsumption check DMS integrated DLV 43 proﬁtably exploiting DLV internal datastructures ability controlling grounding module We conducted experiments benchmarks taken literature The results experimentation evidence implementation outperforms SMS general exponential factor This mainly optimization model generation phase speciﬁc Magic Set technique In addition conducted experiments real application scenario Magic Sets play crucial role optimizing consistent query answering inconsistent databases Importantly authors recognized beneﬁts optimization strategies respect important application domain 51 conﬁrming validity robustness work discussed paper We conclude observing noted literature 38 nondisjunctive case memoing techniques lead similar computations evaluations Magic Set transformations Also disjunctive case techniques proposed Hyper Tableaux 8 similar relations hold While 38 evidenced advantage Magic Sets methods easily combined optimization techniques believe achieving deeper comprehension relationships techniques constitutes interesting avenue research Another issue leave future work study impact changing parameters DMS method particular impact different SIPSes Appendix A Queries INFOMIX demo scenario INFOMIX project funded European Commission Information Society Technologies track Sixth Framework Programme providing advanced information integration A detailed description courseDX1 X2 esame_ X1 X2 _ courseDX1 X2 esame_diplomaX1 X2 exam_recordDX1 X2 Z W X4 X5 Y affidamenti_ing_informaticaX2 X3 Y dati_esamiX1 _ X2 X5 X4 _ Y dati_professoriX3 Z W exam_recordoutX1 X2 X3 X4 Y5 Y6 Y7 exam_recordoutX1 X2 X3 X4 Z5 Z6 Z7 exam_recordDX1 X2 X3 X4 Y5 Y6 Y7 exam_recordDX1 X2 X3 X4 Z5 Z6 Z7 Y5 cid9 Z5 exam_recordoutX1 X2 X3 X4 Y5 Y6 Y7 exam_recordoutX1 X2 X3 X4 Z5 Z6 Z7 exam_recordDX1 X2 X3 X4 Y5 Y6 Y7 exam_recordDX1 X2 X3 X4 Z5 Z6 Z7 Y6 cid9 Z6 exam_recordoutX1 X2 X3 X4 Y5 Y6 Y7 exam_recordoutX1 X2 X3 X4 Z5 Z6 Z7 exam_recordDX1 X2 X3 X4 Y5 Y6 Y7 exam_recordDX1 X2 X3 X4 Z5 Z6 Z7 Y7 cid9 Z7 courseX1 X2 courseDX1 X2 courseoutX1 X2 exam_recordX1 X2 X3 X4 X5 X6 X7 exam_recordDX1 X2 X3 X4 X5 X6 X7 exam_recordoutX1 X2 X3 X4 X5 X6 X7 query1CD courseC CD exam_record09089903 C _ _ _ _ _ query1CD studentDX1 X2 X3 X4 X5 X6 X7 diploma_maturitaY X7 studenteX1 X3 X2 _ _ _ _ _ _ _ _ _ X6 X5 _ _ X4 _ _ _ _ Y _ studentX1 X2 X3 X4 X5 X6 X7 studentDX1 X2 X3 X4 X5 X6 X7 studentoutX1 X2 X3 X4 X5 X6 X7 query2SFN SLN COR ADD TEL HSS student09089903 SFN SLN COR ADD TEL HSS query2SFN SLN COR ADD TEL HSS studentDX1 X2 X3 X4 X5 X6 X7 diploma_maturitaY X7 studenteX1 X3 X2 _ _ _ _ _ _ _ _ _ X6 X5 _ _ X4 _ _ _ _ Y _ student_course_planDX1 X2 X3 X4 X5 orientamentoY1 X3 piano_studiX1 X2 Y1 X4 Y2 _ _ _ _ _ statoY2 X5 studentX1 X2 X3 X4 X5 X6 X7 studentDX1 X2 X3 X4 X5 X6 X7 studentoutX1 X2 X3 X4 X5 X6 X7 student_course_planX1 X2 X3 X4 X5 student_course_planDX1 X2 X3 X4 X5 student_course_planoutX1 X2 X3 X4 X5 query3SID SLN R studentSID ZNEPB SLN _ _ _ _ student_course_plan_ SID _ R APPROVATO SENZA MODIFICHE query3SID SLN R Fig A1 INFOMIX Queries 13 190 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 studentDX1 X2 X3 X4 X5 X6 X7 diploma_maturitaY X7 studenteX1 X3 X2 _ _ _ _ _ _ _ _ _ X6 X5 _ _ X4 _ _ _ _ Y _ courseDX1 X2 esame_ X1 X2 _ courseDX1 X2 esame_diplomaX1 X2 student_course_planDX1 X2 X3 X4 X5 orientamentoY1 X3 piano_studiX1 X2 Y1 X4 Y2 _ _ _ _ _ statoY2 X5 plan_dataDX1 X2 X3 dati_piano_studiX1 X2 _ esame_ingegneriaX2 Y3 Y2 _ tipo_esameY2 X3 studentX1 X2 X3 X4 X5 X6 X7 studentDX1 X2 X3 X4 X5 X6 X7 studentoutX1 X2 X3 X4 X5 X6 X7 student_course_planX1 X2 X3 X4 X5 student_course_planDX1 X2 X3 X4 X5 student_course_planoutX1 X2 X3 X4 X5 plan_dataX1 X2 X3 plan_dataDX1 X2 X3 plan_dataoutX1 X2 X3 courseX1 X2 courseDX1 X2 courseoutX1 X2 query4F S courseCID RETILOGICHE plan_dataSCID CID _ studentSID F S ROMA _ _ _ student_course_planSCID SID _ _ _ query4F S courseDX1 X2 esame_ X1 X2 _ courseDX1 X2 esame_diplomaX1 X2 student_course_planDX1 X2 X3 X4 X5 orientamentoY1 X3 piano_studiX1 X2 Y1 X4 Y2 _ _ _ _ _ statoY2 X5 plan_dataDX1 X2 X3 dati_piano_studiX1 X2 _ esame_ingegneriaX2 Y3 Y2 _ tipo_esameY2 X3 student_course_planX1 X2 X3 X4 X5 student_course_planDX1 X2 X3 X4 X5 student_course_planoutX1 X2 X3 X4 X5 plan_dataX1 X2 X3 plan_dataDX1 X2 X3 plan_dataoutX1 X2 X3 courseX1 X2 courseDX1 X2 courseoutX1 X2 query5D courseE D plan_dataC E _ student_course_planC 09089903 _ _ _ query5D Fig A2 INFOMIX Queries 45 project including references literature httpswwwmatunicalitinfomix Five typical queries INFOMIX demo scenario considered assessing Dynamic Magic Sets The encodings tested queries reported Figs A1A2 Note encodings include transformation described Section 6 underlined predicates denote source relations References 1 Serge Abiteboul Richard Hull Victor Vianu Foundations Databases AddisonWesley 1995 2 Krzysztof R Apt Howard A Blair Adrian Walker Towards Theory Declarative Knowledge Minker 52 pp 89148 3 Marcelo Arenas Leopoldo Bertossi Jan Chomicki Scalar aggregation fdinconsistent databases International Conference Database Theory ICDT2001 SpringerVerlag 2001 pp 3953 4 Marcelo Arenas Leopoldo E Bertossi Jan Chomicki Consistent query answers inconsistent databases Proc 18th ACM SIGACT SIGMOD SIGART Symp Principles Database Systems PODS99 1999 pp 6879 5 Marcelo Arenas Leopoldo E Bertossi Jan Chomicki Specifying querying database repairs logic programs exceptions Proc 4th Int Conf Flexible Query Answering Systems FQAS 2000 Springer 2000 pp 2741 6 François Bancilhon David Maier Yehoshua Sagiv Jeffrey D Ullman Magic sets strange ways implement logic programs Proc Int Symposium Principles Database Systems 1986 pp 116 7 Pablo Barceló Leopoldo Bertossi Repairing databases annotated predicate logic Proc 10th Int Workshop NonMonotonic Reasoning NMR 2002 2002 pp 160170 8 Peter Baumgartner Ulrich Furbach Ilkka Niemelä Hyper tableaux Proceedings European Workshop Logics Artiﬁcial Intelligence JELIA96 LNCS vol 1126 Springer 1996 pp 117 9 Catriel Beeri Raghu Ramakrishnan On power magic Journal Logic Programming 10 14 1991 255259 10 Andreas Behrend Soft stratiﬁcation magic set based query evaluation deductive databases PODS03 Proceedings TwentySecond ACM SIGMODSIGACTSIGART Symposium Principles Database Systems ACM New York NY USA 2003 pp 102110 11 Leo Bertossi Jan Chomicki Query answering inconsistent databases J Chomicki R van der Meyden G Saake Eds Logics Emerging Appli cations Databases SpringerVerlag 2003 pp 4383 Chapter 2 12 Leopoldo Bertossi Jan Chomicki Alvaro Cortes Claudio Gutierrez Consistent answers integrated data sources Proc 6th Int Conf Flexible Query Answering Systems FQAS 2002 2002 pp 7185 13 Leopoldo E Bertossi Loreto Bravo Consistent query answers virtual data integration systems Inconsistency Tolerance LNCS vol 3300 Springer 2005 pp 4283 14 Loreto Bravo Leopoldo Bertossi Logic programming consistently querying data integration systems Proc 18th Int Joint Conf Artiﬁcial Intelligence IJCAI 2003 2003 pp 1015 15 Marco Cadoli Thomas Eiter Georg Gottlob Default logic query language IEEE Transactions Knowledge Data Engineering 9 3 MayJune 1997 448463 16 Andrea Calì Domenico Lembo Riccardo Rosati Query rewriting answering constraints data integration systems Proc 18th Int Joint Conf Artiﬁcial Intelligence IJCAI 2003 2003 pp 1621 17 Jan Chomicki Jerzy Marcinkowski Minimalchange integrity maintenance tuple deletions Information Computation 197 12 2005 90 121 18 Jan Chomicki Jerzy Marcinkowski Slawomir Staworko Computing consistent query answers conﬂict hypergraphs Proc 13th ACM Conference Information Knowledge Management CIKM2004 ACM Press 2004 pp 417426 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 191 19 Jan Chomicki Jerzy Marcinkowski Slawomir Staworko Hippo A computing consistent answers class SQL queries Elisa Bertino Stavros Christodoulakis Dimitris Plexousakis Vassilis Christophides Manolis Koubarakis Klemens Böhm Elena Ferrari Eds 9th International Confer ence Extending Database Technology EDBT2004 Lecture Notes Computer Science vol 2992 Springer 2004 pp 841844 20 Chiara Cumbo Wolfgang Faber Gianluigi Greco Nicola Leone Enhancing magicset method disjunctive datalog programs Proceedings 20th International Conference Logic Programming ICLP04 Lecture Notes Computer Science vol 3132 2004 pp 371385 21 Christian Drescher Martin Gebser Torsten Grote Benjamin Kaufmann Arne König Max Ostrowski Torsten Schaub Conﬂictdriven disjunctive answer set solving Gerhard Brewka Jérôme Lang Eds Proceedings Eleventh International Conference Principles Knowledge Representation Reasoning KR 2008 AAAI Press Sydney Australia 2008 pp 422432 22 Thomas Eiter Georg Gottlob Heikki Mannila Disjunctive Datalog ACM Transactions Database Systems 22 3 September 1997 364418 23 Wolfgang Faber Enhancing eﬃciency expressiveness answer set programming systems PhD thesis Institut für Informationssysteme Technische Universität Wien 2002 24 Wolfgang Faber Gianluigi Greco Nicola Leone Magic sets application data integration Journal Computer System Sciences 73 4 2007 584609 25 Ariel Fuxman Elham Fazli Renée J Miller Conquer Eﬃcient management inconsistent databases SIGMOD Conference 2005 26 Ariel Fuxman Renée J Miller Firstorder query rewriting inconsistent databases Thomas Eiter Leonid Libkin Eds Proceedings 10th International Conference Database Theory ICDT 2005 LNCS vol 3363 Springer 2005 pp 337351 27 Michael R Garey David S Johnson Computers Intractability A Guide Theory NPCompleteness WH Freeman Company 1979 28 Martin Gebser Torsten Schaub Sven Thiele Gringo A new grounder answer set programming Chitta Baral Gerhard Brewka John Schlipf Eds Logic Programming Nonmonotonic Reasoning 9th International Conference LPNMR07 Lecture Notes Computer Science vol 4483 SpringerVerlag Tempe Arizona May 2007 pp 266271 29 M Gelfond V Lifschitz The stable model semantics logic programming Logic Programming Proceedings Fifth Int Conference Symposium MIT Press Cambridge MA 1988 pp 10701080 30 R Goldman M Boddy Expressive planning explicit knowledge Proceedings AIPS96 AAAI Press 1996 pp 110117 31 Gianluigi Greco Sergio Greco Ester Zumpano A logic programming approach integration repairing querying inconsistent databases Proc 17th Int Conf Logic Programming ICLP01 Lecture Notes Artiﬁcial Intelligence vol 2237 Springer 2001 pp 348364 32 Sergio Greco Optimization Disjunction Queries Danny De Schreye Ed Proceedings 16th International Conference Logic Programming ICLP99 The MIT Press Las Cruces New Mexico USA November 1999 pp 441455 33 Sergio Greco Binding propagation techniques optimization bound disjunctive queries IEEE Transactions Knowledge Data Engineer ing 15 2 MarchApril 2003 368385 34 Sergio Greco Domenico Saccà Carlo Zaniolo The PushDown method optimize chain logic programs Proc Int Colloquim Automata Languages Programming 1995 pp 523534 extended abstract 35 Ashish Gupta Inderpal Singh Mumick Magicsets transformation nonrecursive systems Proceedings Thirteenth ACM SIGACT SIGMOD SIGART Symposium Principles Database Systems PODS92 1992 pp 354367 36 Ullrich Hustadt Boris Motik Ulrike Sattler Reasoning description logics reduction disjunctive datalog Journal Automated Reasoning 39 3 2007 351384 37 Tomi Janhunen Ilkka Niemelä Dietmar Seipel Patrik Simons JiaHuai You Unfolding partiality disjunctions stable model semantics ACM Transactions Computational Logic 7 1 January 2006 137 38 David B Kemp Divesh Srivastava Peter J Stuckey Bottomup evaluation query optimization wellfounded models Theoretical Computer Sci ence 146 July 1995 145184 39 JeanMarc Kerisit JeanMarc Pugin Eﬃcient query answering stratiﬁed databases FGCS 1988 pp 719726 40 Joohyung Lee Vladimir Lifschitz Loop formulas disjunctive logic programs Proceedings Nineteenth International Conference Logic Programming ICLP03 SpringerVerlag December 2003 41 Maurizio Lenzerini Data integration A theoretical perspective Proc 21st ACM SIGACT SIGMOD SIGART Symp Principles Database Systems PODS 2002 2002 pp 233246 42 Nicola Leone Georg Gottlob Riccardo Rosati Thomas Eiter Wolfgang Faber Michael Fink Gianluigi Greco Giovambattista Ianni Edyta Kałka Domenico Lembo Maurizio Lenzerini Vincenzino Lio Bartosz Nowicki Marco Ruzzi Witold Staniszkis Giorgio Terracina The INFOMIX advanced integration incomplete inconsistent data Proceedings 24th ACM SIGMOD International Conference Management Data SIGMOD 2005 ACM Press Baltimore Maryland USA June 2005 pp 915917 43 Nicola Leone Gerald Pfeifer Wolfgang Faber Thomas Eiter Georg Gottlob Simona Perri Francesco Scarcello The DLV knowledge represen tation reasoning ACM Transactions Computational Logic 7 3 July 2006 499562 44 Nicola Leone Pasquale Rullo Francesco Scarcello Disjunctive stable models Unfounded sets ﬁxpoint semantics computation Information Computation 135 2 June 1997 69112 45 Senlin Liang Paul Fodor Hui Wan Michael Kifer OpenRuleBench An analysis performance rule engines Juan Quemada Gonzalo León Yoëlle S Maarek Wolfgang Nejdl Eds Proceedings 18th International Conference World Wide Web WWW 2009 ACM 2009 pp 601610 46 Yuliya Lierler Disjunctive answer set programming satisﬁability Chitta Baral Gianluigi Greco Nicola Leone Giorgio Terracina Eds Logic Programming Nonmonotonic Reasoning 8th International Conference LPNMR05 Diamante Italy September 2005 Proceedings Lecture Notes Computer Science vol 3662 SpringerVerlag September 2005 pp 447451 47 Fangzhen Lin Yuting Zhao ASSAT Computing answer sets logic program SAT solvers Proceedings Eighteenth National Conference Artiﬁcial Intelligence AAAI2002 AAAI PressMIT Press Edmonton Alberta Canada 2002 48 Jorge Lobo Jack Minker Arcot Rajasekar Foundations Disjunctive Logic Programming The MIT Press Cambridge MA 1992 49 Marco Manna Massimo Ruffolo Ermelinda Oro Mario Alviano Nicola Leone The HiLeX semantic information extraction Transactions LargeScale Data KnowledgeCentered Systems Lecture Notes Computer Science vol 7100 Springer BerlinHeidelberg 2012 pp 91125 50 Marco Manna Francesco Scarcello Nicola Leone On complexity regulargrammars integer attributes Journal Computer System Sciences JCSS 77 2 2011 393421 51 Mónica Caniupán Marileo Leopoldo E Bertossi The consistency extractor Querying inconsistent databases answer set programs SUM 2007 2007 pp 7488 52 Jack Minker Ed Foundations Deductive Databases Logic Programming Morgan Kaufmann Publishers Inc Washington DC 1988 53 Boris Motik Reasoning description logics resolution deductive databases PhD thesis Fakultät für Wirtschaftswissenschaften Universität Fridericiana zu Karlsruhe 2006 54 Boris Motik Ulrike Sattler A comparison reasoning techniques querying large description logic aboxes Miki Hermann Andrei Voronkov Eds Logic Programming Artiﬁcial Intelligence Reasoning 13th International Conference LPAR 2006 Lecture Notes Computer Science vol 4246 Springer 2006 pp 227241 55 Inderpal Singh Mumick Sheldon J Finkelstein Hamid Pirahesh Raghu Ramakrishnan Magic relevant Proceedings 1990 ACM SIGMOD International Conference Management Data 1990 pp 247258 192 M Alviano et al Artiﬁcial Intelligence 187188 2012 156192 56 Raghu Ramakrishnan Yehoshua Sagiv Jeffrey D Ullman Moshe Y Vardi Logical query optimization prooftree transformation Journal Computer System Sciences 47 1 1993 222248 57 Francesco Ricca Mario Alviano Antonella Dimasi Giovanni Grasso Salvatore Maria Ielpa Salvatore Iiritano Marco Manna Nicola Leone A logicbased etourism Fundamenta Informaticae 105 12 2010 3555 58 Francesco Ricca Giovanni Grasso Mario Alviano Marco Manna Vincenzino Lio Salvatore Iiritano Nicola Leone Teambuilding answer set pro gramming GioiaTauro seaport Theory Practice Logic Programming 2012 httpdxdoiorg101017S147106841100007X press 59 KA Ross Modular stratiﬁcation magic sets datalog programs negation Journal ACM 41 6 1994 12161266 60 Praveen Seshadri Joseph M Hellerstein Hamid Pirahesh TY Cliff Leung Raghu Ramakrishnan Divesh Srivastava Peter J Stuckey S Sudarshan Cost based optimization magic Algebra implementation HV Jagadish Inderpal Singh Mumick Eds Proceedings 1996 ACM SIGMOD International Conference Management Data ACM Press June 1996 pp 435446 61 Patrik Simons Ilkka Niemelä Timo Soininen Extending implementing stable model semantics Artiﬁcial Intelligence 138 June 2002 181234 62 Peter J Stuckey S Sudarshan Compiling query constraints Proceedings Thirteenth Symposium Principles Database Systems PODS94 ACM Press May 1994 pp 5667 63 Jeffrey D Ullman Principles Database KnowledgeBase Systems vol II Computer Science Press 1989 64 A van Gelder Negation failure tight derivations general logic programs Minker 52 pp 11491176