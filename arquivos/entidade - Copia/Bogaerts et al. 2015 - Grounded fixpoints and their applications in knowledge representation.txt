Artiﬁcial Intelligence 224 (2015) 51–71

Contents lists available at ScienceDirect

Artiﬁcial  Intelligence

www.elsevier.com/locate/artint

Grounded  ﬁxpoints  and  their  applications  in  knowledge 
representation ✩
Bart Bogaerts a,∗
a Department of Computer Science, KU Leuven, 3001 Heverlee, Belgium
b Department of Computer Science, Campus De Nayer, KU Leuven, 2860 Sint-Katelijne-Waver, Belgium

,  Joost Vennekens a,b,  Marc Denecker a

a  r  t  i  c  l  e 

i  n  f  o

a  b  s  t  r  a  c  t

Article history:
Received 21 December 2014
Received in revised form 19 March 2015
Accepted 21 March 2015
Available online 25 March 2015

Keywords:
Approximation ﬁxpoint theory
Lattice operator
Stable semantics
Well-founded semantics
Groundedness
Logic programming
Autoepistemic logic
Abstract argumentation
Abstract dialectical frameworks

1.  Introduction

In various domains of logic, researchers have made use of a similar intuition: that facts 
(or  models)  can  be  derived  from the ground up.  They  typically  phrase  this  intuition  by 
saying,  e.g.,  that  the  facts  should  be  grounded,  or  that  they  should  not  be  unfounded, 
or  that  they  should  be  supported  by  cycle-free arguments,  et  cetera.  In  this  paper,  we 
formalise  this  intuition  in  the  context  of  algebraical  ﬁxpoint  theory.  We  deﬁne  when  a 
lattice element x ∈ L is grounded for lattice operator O : L → L. On the algebraical level, we 
investigate the relationship between grounded ﬁxpoints and the various classes of ﬁxpoints 
of approximation ﬁxpoint theory, including supported, minimal, Kripke–Kleene, stable and 
well-founded  ﬁxpoints.  On  the  logical  level,  we  investigate  groundedness  in  the  context 
of  logic  programming,  autoepistemic  logic,  default  logic  and  argumentation  frameworks. 
We explain what grounded points and ﬁxpoints mean in these logics and show that this 
concept  indeed  formalises  intuitions  that  existed  in  these  ﬁelds.  We  investigate  which 
existing  semantics  are  grounded.  We  study  the  novel  semantics  for  these  logics  that  is 
induced by grounded ﬁxpoints, which has some very appealing properties, not in the least 
its mathematical simplicity and generality. Our results unveil a remarkable uniformity in 
intuitions and mathematics in these ﬁelds.

© 2015 Elsevier B.V. All rights reserved.

Motivated by structural analogies in the semantics of several non-monotonic logics, Denecker, Marek and Truszczy ´nski 
(from now on abbreviated as DMT) [10] developed an algebraic ﬁxpoint theory that deﬁnes different types of ﬁxpoints for a 
so-called approximating bilattice operator, called supported, Kripke–Kleene, stable and well-founded ﬁxpoints. In the context 
of logic programming, they found that Fitting’s (three- or four-valued) immediate consequence operator is an approximating 
operator of the two-valued immediate consequence operator and that its four different types of ﬁxpoints correspond exactly 
to the four major, equally named semantics of logic programs. They also identiﬁed approximating operators for default logic 
(DL) and autoepistemic logic (AEL) and showed that the ﬁxpoint theory induces all main and some new semantics in these 
ﬁelds [11]. Moreover, by showing that Konolige’s mapping from DL to AEL [26] preserves the approximating operator, they 

A short version of this paper is accepted for publication in the proceedings of the AAAI’15 conference [5]. This paper extends the previous work with 

✩
proofs of all propositions and applications of the theory to abstract dialectical frameworks, autoepistemic logic and default logic.
* Corresponding author.

E-mail addresses: bart.bogaerts@cs.kuleuven.be (B. Bogaerts), joost.vennekens@cs.kuleuven.be (J. Vennekens), marc.denecker@cs.kuleuven.be

(M. Denecker).

http://dx.doi.org/10.1016/j.artint.2015.03.006
0004-3702/© 2015 Elsevier B.V. All rights reserved.

52

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

resolved an old research question regarding the nature of these two logics: AEL and DL were essentially uniﬁed in the sense 
that for each semantics covered by AFT, a DL theory is equivalent with its Konolige mapping in AEL. However, the original 
DL  and  AEL  semantics  occupy  different  positions  in  this  family  and  do  not  correspond.  As  such  AEL  and  DL  under  their 
original semantics, are “just” two different dialects of autoepistemic reasoning [11,13].

The study of these approximating operators called approximation ﬁxpoint theory (AFT) was later used to deﬁne semantics 
of extensions of logic programs, such as logic programs with aggregates [35] and HEX logic programs [2]. Vennekens et al. 
[42] used  AFT  in  an  algebraical  modularity  study  for  logic  programming,  AEL  and  DL.  Recently,  Strass  [38] showed  that 
many semantics from Dung’s argumentation frameworks (AFs) and abstract dialectical frameworks (ADFs) can be obtained 
by  direct  applications  of  AFT.  Bi  et  al.  [4] extended  AFT  with  approximators  allowing  for  inconsistencies  and  used  it  to 
integrate description logics with logic programs. Bogaerts et al. [6] deﬁned the causal logic FO(C) as an instantiation of AFT. 
This suggests that ﬁxpoint theory, in ways that are diﬃcult to explain due to its high level of abstraction, captures certain 
fundamental  intuitions  in  a  range  of  logics  and  sorts  of  human  knowledge.  It  is  this  observation  that  provides  the  basic 
motivation for the present study.

In  this  paper,  we  formally  use  ﬁxpoint  theory  to  investigate  an  intuition  that  is  found  in  all  aforementioned  logic  do-
mains. There, researchers have made use of a similar intuition: that facts (or models) can be derived from the ground up. They 
typically phrase this intuition by saying that, e.g., the facts should be grounded, or that they should not be unfounded, or 
that they should be supported by cycle-free arguments, or by arguments that contain no vicious circles, et cetera. In several 
cases,  great  efforts  were  done  to  reﬁne  semantics  which  did  allow  ungrounded  models  or  facts.  For  example,  it  is  well-
known that the completion semantics of logic programs allows ungrounded models, e.g., for the transitive closure program. 
The efforts to avoid these led to the development of perfect, stable and well-founded semantics. Also for AEL, it was known 
that Moore’s expansion semantics accepted ungrounded models, e.g., for the theory {KP ⇒ P } which has the ungrounded 
model in which  P is known but this knowledge is self-supported. Examples like this motivated several attempts to reﬁne 
Moore’s semantics, among others by Halpern and Moses [24] and Konolige [26].

We formalise the intuition of groundedness in the context of algebraical ﬁxpoint theory. We call a lattice element x ∈ L
grounded for lattice operator  O  : L → L if for all v ∈ L such that  O (x ∧ v) ≤ v, it holds that x ≤ v. We investigate this notion 
on  the  algebraical  level  in  AFT  and  on  the  logical  level  in  the  context  of  logic  programming,  autoepistemic  logic,  default 
logic  and  abstract  argumentation  frameworks.  We  explain  what  grounded  points  and  ﬁxpoints  mean  in  these  logics  and 
show  that  this  concept  indeed  formalises  intuitions  that  existed  in  these  ﬁelds.  We  investigate  which  existing  semantics 
are  grounded,  where  we  call  a  semantics  grounded  if  all  its  models  are  grounded,  and  investigate  a  novel  semantics  for 
these logics that is based on grounded ﬁxpoints. Our results unveil a remarkable uniformity in intuition and mathematics in 
these ﬁelds and lead to a new candidate semantics with some very appealing properties, not in the least the mathematical 
simplicity and generality to deﬁne it in the context of operator-based logics and logic constructs.

We  can  summarise  the  main  contributions  of  this  paper  as  follows.  We  extend  AFT  with  the  notion  of  a  grounded 
ﬁxpoint,  a  ﬁxpoint  closely  related  to  stable  and  well-founded  ﬁxpoints.  We  show  that  if  the  Kripke–Kleene  ﬁxpoint  is 
exact,  then  it  is  grounded.  If  the  well-founded  ﬁxpoint  is  exact,  then  it  is  the  unique  grounded  and  the  unique  stable 
ﬁxpoint. Otherwise, stable ﬁxpoints are grounded but not necessarily the other way around. A useful feature of grounded 
ﬁxpoints  that  distinguishes  them  from  stable  and  well-founded  ﬁxpoints  is  that  they  are  determined  by  O and  do  not 
require  the  choice  of  an  approximator.  We  then  apply  this  theory  to  different  logical  research  domains.  In  all  domains, 
we explain the meaning of grounded ﬁxpoints, relate them to attempts to formalise groundedness, study which semantics 
are grounded and ﬁnally, we explore the semantics induced by grounded ﬁxpoints. More speciﬁcally, (i) in the context of 
logic programming, our theory yields an intuitive, purely two-valued, semantics that is easily extensible and that formalises 
well-known intuitions related to unfounded sets. (ii) We show that two of the main semantics of AFs can be characterised 
as grounded ﬁxpoints of previously deﬁned operators and discuss grounded ﬁxpoints in the context of ADFs. (iii) Applied 
to  autoepistemic  logic  and  default  logic,  groundedness  turns  out  to  provide  an  alternative  and  improved  formalisation  of 
intuitions described by Konolige [26].

2.  Preliminaries

2.1.  Lattices and operators

A partially ordered set (poset) (cid:8)L, ≤(cid:9) is a set  L equipped with a partial order ≤, i.e., a reﬂexive, antisymmetric, transitive 
relation. As usual, we write x < y as abbreviation for x ≤ y ∧ x (cid:10)= y. If S is a subset of L, then x is an upper bound, respectively 
a lower bound of  S if for every s ∈ S, it holds that s ≤ x respectively x ≤ s. An element x is a least upper bound, respectively 
greatest lower bound of  S if it is an upper bound that is smaller than every other upper bound, respectively a lower bound 
that is greater than every other lower bound. If  S has a least upper bound, respectively a greatest lower bound, we denote 
it  lub(S), respectively  glb(S). As is custom, we sometimes call a greatest lower bound a meet, and a least upper bound a 
S = lub(S) and  x ∨ y = lub({x, y}). We call (cid:8)L, ≤(cid:9) a 
join and use the related notations 
complete lattice if every subset of L has a least upper bound and a greatest lower bound. A complete lattice has both a least 
element ⊥ and a greatest element (cid:13).

S = glb(S),  x ∧ y = glb({x, y}), 

An operator  O  : L → L is monotone if  x ≤ y implies that  O (x) ≤ O ( y) and anti-monotone if  x ≤ y implies that  O ( y) ≤
O (x).  An  element  x ∈ L is  a  preﬁxpoint,  a  ﬁxpoint,  a  postﬁxpoint of  O if  O (x) ≤ x,  respectively  O (x) = x,  x ≤ O (x).  Every 

(cid:2)

(cid:3)

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

53

monotone operator  O in a complete lattice has a least ﬁxpoint, denoted lfp(O ), which is also  O ’s least preﬁxpoint and the 
limit (the least upper bound) of the increasing sequence (xi )i≥0 deﬁned by

• x0 = ⊥,
• xi+1 = O (xi), for successor ordinals i + 1,
• xλ = lub({xi | i < λ}), for limit ordinals λ.

2.2.  Logic programming

In  the  following  sections,  we  illustrate  our  abstract  results  in  the  context  of  logic  programming.  We  recall  some  pre-
liminaries. We restrict ourselves to propositional logic programs, but allow arbitrary propositional formulas in rule bodies. 
However, our results basically apply to all extensions of logic programming that admit an immediate consequence operator 
(non-propositional ones, aggregates in the body, etc.).

Let (cid:3) be an alphabet, i.e., a collection of symbols which are called atoms. A literal is an atom  p or the negation ¬q of 
an  atom  q.  A  logic  program  P is  a  set  of  rules r of  the  form  h ← ϕ,  where  h is  an  atom  called  the  head of  r,  denoted 
head(r), and ϕ is a propositional formula called the body of r, denoted body(r). An interpretation  I of the alphabet (cid:3) is an 
element of 2(cid:3) , i.e., a subset of (cid:3). The set of interpretations 2(cid:3) forms a lattice equipped with the order ⊆. The truth value 
(t or f) of a propositional formula ϕ in a structure  I , denoted ϕ I is deﬁned as usual. With a logic program P , we associate 
an immediate consequence operator [40] T P that maps a structure  I to

T P (I) = {p | ∃r ∈ P : head(r) = p ∧ body(r)I = t}.

3.  Grounded ﬁxpoints

Let (cid:8)L, ≤(cid:9) be a complete lattice and  O  : L → L a lattice operator, ﬁxed throughout this entire section. We start by giving 

the most central deﬁnition of this text, namely the notion of groundedness.

Deﬁnition 3.1 (Grounded). We call x ∈ L grounded for  O if for each v ∈ L such that  O (x ∧ v) ≤ v, it holds that x ≤ v. We call 
x a grounded ﬁxpoint of  O if it is a ﬁxpoint of  O and it is grounded for  O .

This concept is strongly related to the following.

Deﬁnition 3.2 (Strictly grounded). We call x ∈ L strictly grounded for O if there is no  y ∈ L such that  y < x and (O ( y) ∧ x) ≤ y.

The intuition behind these concepts is very similar and is easy to explain if we assume that the elements of  L are sets 
of “facts” of some kind and the ≤ relation is the subset relation between such sets. In this case, ∧ is the intersection and 
∨ the union of sets. Intuitively, a set of facts x is (strictly) grounded if it can be “built from the ground up” by  O . Such sets 
are built in several stages. Facts that are derived in later stages depend on those of earlier stages. This means that x has a 
stratiﬁed internal structure. If we remove multiple strata from x, we cannot expect that applying  O will reconstruct all of 
the removed facts, but we should expect that at least some of the removed facts of  x reappear, in particular those in the 
lowest stratum from where facts were deleted. This idea is formalised in slightly different ways in the two deﬁnitions.

If  L is  a  powerset  lattice,  this  intuition  directly  translates  to  ∀u (cid:10)= ∅ : u ⊆ x ⇒ O (x \ u) ∩ u (cid:10)= ∅,  i.e.,  whenever  a  set  of 
elements u is removed from x, at least one of these elements returns. To express it in the context of lattices in general, the 
statement needs to be reformulated without using set subtraction. There are two ways to do this.

In the deﬁnition of strictly grounded point, removing strata from x corresponds to taking  y < x ( y represents x \ u in this 
case). The condition that some elements of x should come back corresponds to (O ( y) ∧ x) (cid:2) y (at least one element of O ( y)
is in x but not in  y; thus, at least one is in u).

In the deﬁnition of grounded point, a slightly different but equivalent set-theoretic expression is formalised: ∀u : u ∩ x (cid:10)=
∅ ⇒ O (x \ u) ∩ u (cid:10)= ∅.  Removing  strata  from  x corresponds  to  selecting  a  v ∈ L and  taking  x ∧ v (v corresponds  to  the 
complement  of  u,  hence  x \ u to  x ∧ v and  the  fact  that  u ∩ x (cid:10)= ∅ corresponds  to  x (cid:2) v).  The  condition  that  O (x ∧ v)
reintroduces an element of u corresponds to  O (x ∧ v) (cid:2) v.

In what follows, we study some properties of (strictly) grounded (ﬁx)points. We start by showing the tight relationship 
between the two concepts. In general, every strictly grounded point is grounded but not necessarily the other way around. 
Unsurprisingly, in the context of powerset lattices — the context in which we explained the intuitions — the two notions 
coincide.

Proposition 3.3. If x is strictly grounded for O , then x is grounded for O .

Proof. Assume  x is strictly grounded and  v ∈ L is such that  O (x ∧ v) ≤ v. Let  y denote  x ∧ v. Then  O ( y) ≤ v, and hence 
(O ( y) ∧ x) ≤ (x ∧ v) = y. Since (O ( y) ∧ v) ≤ y and x is strictly grounded, it cannot be the case that  y < x. Since (x ∧ v) =
y ≤ x, equality holds, i.e. (x ∧ v) = x and x ≤ v. This shows that x is indeed grounded. (cid:2)

54

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

Example 3.4.  The  converse  of  Proposition 3.3 does  not  hold.  Consider  lattice  and  operator  represented  by  the  following 
graph, where full edges express the order relation (to be precise, the ≤ relation is the reﬂexive transitive closure of these 
edges) and the dotted edges represent the operator:

a

(cid:13)

⊥

b1

b2

In this case, b1 is grounded but not strictly grounded, as can be seen by taking  y = b2.

Proposition 3.5. Let L be a powerset lattice (cid:8)2

(cid:13), ⊆(cid:9). Then a point x ∈ L is grounded if and only if it is strictly grounded.

Proof. We recall that in the context of powerset lattices the greatest lower bound is the intersection and least upper bound 
is the union.

Proposition 3.3 guarantees  that  we  only  need  to  show  that  all  grounded  points  are  strictly  grounded.  Hence,  suppose 
x is grounded. Assume towards contradiction that  x is not strictly grounded, i.e., that for some  y (cid:3) x,  O ( y) ∩ x ⊆ y. Take 
v = y ∪ ((cid:13) \ x). It holds that v ∩ x = y. We have that x (cid:4) v. Also, it holds that O ( y) ⊆ v if and only if O ( y) ∩ x ⊆ y. Since we 
assumed the latter, it holds that  O (v ∩ x) = O ( y) ⊆ v. Hence, we obtain a contradiction with the groundedness of x, which 
proves our claim. (cid:2)

Proposition 3.6. Let O be a monotone operator. If x is grounded for O then x is a postﬁxpoint of O that is less than or equal to lfp(O ), 
i.e., x ≤ O (x) and x ≤ lfp(O ).

Proof. First, we show that x ≤ lfp(O ). Since  O is monotone, we have  O (lfp(O ) ∧ x) ≤ O (lfp(O )) = lfp(O ). Hence, grounded-
ness of x with v = lfp(O ) indeed yields that x ≤ lfp(O ).

In  order  to  show  that  x is  a  postﬁxpoint  of  O ,  take  v = O (x).  Again  using  monotonicity  of  O ,  we  ﬁnd  O (v ∧ x) ≤

O (x) = v. Hence, groundedness yields that x ≤ v = O (x), and indeed x is a postﬁxpoint of  O . (cid:2)

Example 3.7. The converse of Proposition 3.6 does not hold. Consider the following logic program P :

(cid:5)

(cid:4)

p.
q ← p ∨ q.

Its immediate consequence operator T P is represented by the following graph:

(cid:13) = {p, q}

{p}

{q}

⊥ = ∅

T P is a monotone operator with least ﬁxpoint (cid:13). Also, {q} is a postﬁxpoint of T P since T P ({q}) = (cid:13) ≥ {q}. However, {q} is 
not grounded since T P ({q} ∧ {p}) = T P (⊥) = {p}, while {q} (cid:2) {p}.

Proposition 3.8. All grounded ﬁxpoints of O are minimal ﬁxpoints of O .

Proof. Suppose  x is  grounded  and  y and  x are  ﬁxpoints  of  O with  y ≤ x.  In  this  case,  O (x ∧ y) = O ( y) = y ≤ y.  Thus, 
since  x is grounded, we conclude that  x ≤ y, which yields  x = y. We ﬁnd that indeed, all grounded ﬁxpoints are minimal 
ﬁxpoints. (cid:2)

Example 3.9. The converse of Proposition 3.8 does not hold. Consider the logic program P :

(cid:5)

(cid:4)

p ← p.
q ← ¬p ∨ q.

This logic program has as immediate consequence operator T P :

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

55

(cid:13) = {p, q}

{p}

{q}

⊥ = ∅

In this case, {p} is a minimal ﬁxpoint of T P , but {p} is not grounded since T P ({p} ∧ {q}) = T P (⊥) = {q}, while {p} (cid:2) {q}.

Proposition 3.10. A monotone operator has exactly one grounded (and strictly grounded) ﬁxpoint, namely its least ﬁxpoint.

Proof. Proposition 3.8 guarantees that grounded ﬁxpoints are minimal, hence a monotone operator O can have at most one 
grounded ﬁxpoint lfp(O ). Now we show that lfp(O ) is indeed strictly grounded. Since  O is monotone, for every  y ≤ lfp(O ), 
it  holds  that  O ( y) ≤ O (lfp(O )) = lfp(O ) and  hence  that  O ( y) ∧ lfp(O ) = O ( y).  Now  suppose  that  for  some  y ≤ lfp(O ), 
O ( y) ∧ lfp(O ) ≤ y. Then by the previous also O ( y) ≤ y. Thus  y is a preﬁxpoint of O . However, lfp(O ) is the least preﬁxpoint 
of  O , hence lfp(O ) ≤ y, and thus  y = lfp(O ). We conclude that lfp(O ) is indeed strictly grounded. From Proposition 3.3, it 
then follows that x is grounded as well. (cid:2)

Proposition 3.11. Every postﬁxpoint of an anti-monotone operator is strictly grounded.

Proof. Suppose  x is  a  postﬁxpoint  of  an  anti-monotone  operator  O ,  i.e.,  x ≤ O (x) and  that  y ≤ x.  In  that  case  O ( y) ≥
O (x) ≥ x. If  O ( y) ∧ x ≤ y, then it follows that x ≤ y. Thus indeed x = y and x is strictly grounded. (cid:2)

Example 3.12. The converse of Proposition 3.11 does not hold. Consider the logic program P :

(cid:4)

(cid:5)

p ← ¬p.
q ← ¬q.

This logic program has as immediate consequence operator T P :

(cid:13) = {p, q}

{p}

{q}

⊥ = ∅

The operator T P is anti-monotone, and {p} is strictly grounded for T P . However, {p} is not a postﬁxpoint of T P .

4.  Grounded ﬁxpoints and approximation ﬁxpoint theory

4.1.  Preliminaries: AFT

Given  a  lattice  L,  approximation  ﬁxpoint  theory  makes  use  of  the  bilattice  L2.  We  deﬁne  two  projection functions  for 
pairs as usual: (x, y)1 = x and (x, y)2 = y. Pairs (x, y) ∈ L2 are used to approximate all elements in the interval [x, y] = {z |
x ≤ z ∧ z ≤ y}. We call (x, y) ∈ L2 consistent if x ≤ y, that is, if [x, y] is non-empty. We use Lc to denote the set of consistent 
elements. Elements (x, x) ∈ Lc are called exact; they constitute the embedding of L in L2. We sometimes abuse notation and 
use the tuple (x, y) and the interval [x, y] interchangeably. The precision ordering on L2 is deﬁned as (x, y) ≤p (u, v) if x ≤ u
and v ≤ y. In case (u, v) is consistent, this means that (x, y) approximates all elements approximated by (u, v), or in other 
words that [u, v] ⊆ [x, y]. If L is a complete lattice, then (cid:8)L2, ≤p (cid:9) is also a complete lattice.

AFT studies ﬁxpoints of lattice operators  O  : L → L through operators approximating  O . An operator  A : L2 → L2 is an 
approximator of  O if it is  ≤p -monotone, and has the property that for all x,  O (x) ∈ A(x, x). Approximators are internal in 
Lc (i.e., map Lc into Lc ). As usual, we restrict our attention to symmetric approximators: approximators  A such that for all x
and  y,  A(x, y)1 = A( y, x)2. DMT [12] showed that the consistent ﬁxpoints of interest (supported, stable, well-founded) are 
uniquely determined by an approximator’s restriction to Lc , hence, sometimes we only deﬁne approximators on Lc .

AFT studies ﬁxpoints of  O using ﬁxpoints of  A.

• The  A-Kripke–Kleene ﬁxpoint is the  ≤p -least ﬁxpoint of  A and has the property that it approximates all ﬁxpoints of  O .
• A  partial  A-stable ﬁxpoint is  a  pair  (x, y) such  that  x = lfp( A(·, y)1) and  y = lfp( A(x, ·)2),  where  A(·, y)1 denotes  the 

operator L → L : x (cid:22)→ A(x, y)1 and analogously for  A(x, ·)2.

• The  A-well-founded ﬁxpoint is the least precise partial  A-stable ﬁxpoint.
• An  A-stable ﬁxpoint of  O is a ﬁxpoint x of  O such that (x, x) is a partial  A-stable ﬁxpoint. This is equivalent with the 

condition that x = lfp( A(·, x)1).

56

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

Fig. 1. The Kleene truth tables [25].

The  A-Kripke–Kleene ﬁxpoint of  O can be constructed by iteratively applying  A, starting from (⊥, (cid:13)). For the  A-well-

founded ﬁxpoint, a similar constructive characterisation has been worked out by Denecker and Vennekens [15]:

Deﬁnition 4.1. An  A-reﬁnement of (x, y) is a pair (x

(cid:23), y

(cid:23)) ∈ L2 satisfying one of the following two conditions:

• (x, y) ≤p (x
• x

(cid:23) = x and  A(x, y

(cid:23)) ≤p A(x, y), or
(cid:23) ≤ y.
(cid:23))2 ≤ y

(cid:23), y

An  A-reﬁnement is strict if (x, y) (cid:10)= (x

(cid:23), y

(cid:23)).

Deﬁnition 4.2. A well-founded induction of  A is a sequence (xi, yi)i≤β with β an ordinal such that

• (x0, y0) = (⊥, (cid:13));
• (xi+1, yi+1) is an A-reﬁnement of (xi, yi), for all i < β;
• (xλ, yλ) = lub ≤p

{(xi, yi) | i < λ} for each limit ordinal λ ≤ β.

A well-founded induction is terminal if its limit (xβ , yβ ) has no strict  A-reﬁnements.

A well-founded induction is an algebraical generalisation of the well-founded model construction deﬁned by Vam Gelder 
et al. [41]. The ﬁrst type of reﬁnements correspond to making a partial structure more precise by applying Fitting’s imme-
diate consequence operator; the second type of reﬁnement corresponds to making a structure more precise by eliminating 
an unfounded set.

For a given approximator  A, there are many different terminal well-founded inductions of  A. Denecker and Vennekens 
[15] showed that they all have the same limit, which equals the  A-well-founded ﬁxpoint of O . Furthermore, if  A is symmet-
ric, the  A-well-founded ﬁxpoint of O (and in fact, every tuple in a well-founded induction of  A) is consistent. Well-founded 
inductions that only use the ﬁrst sort of reﬁnement converge to the  A-Kripke–Kleene ﬁxpoint.

The precision order can be pointwise extended to the family of approximators of  O . It then follows that more precise 
approximators have a more precise well-founded ﬁxpoint and more precise approximators have more stable ﬁxpoints. DMT 
[12] showed  that  there  exists  a  most  precise  approximator,  U O ,  called  the  ultimate  approximator  of  O .  This  operator  is 
deﬁned by

U O : Lc → Lc : (x, y) (cid:22)→ (

O ([x, y]),

O ([x, y])).

(cid:6)

(cid:7)

Here, we used the notation O ( X) = {O (x) | x ∈ X} for a set  X ⊆ L. It then follows that for every approximator  A, all  A-stable 
ﬁxpoints  are  U O -stable  ﬁxpoints,  and  the  U O -well-founded  ﬁxpoint  is  always  more  precise  than  the  A-well-founded  ﬁx-
point. We refer to U O -stable ﬁxpoints as ultimate stable ﬁxpoints of O and to the U O -well-founded ﬁxpoint as the ultimate 
well-founded ﬁxpoint of  O . Semantics deﬁned using the ultimate approximator have as advantage that they only depend 
on  O since the approximator can be derived from  O .

(cid:8)
2(cid:3)
are 
Approximation ﬁxpoint theory and logic programming. In the context of logic programming, elements of the bilattice 
(cid:23)
four-valued  interpretations,  pairs  I = (I1, I2) of  interpretations.  The  pair  (I1, I2) approximates  all  interpretations  I
with 
(cid:23) ⊆ I2. We often identify an interpretation  I with the four-valued interpretation (I, I). If I = (I1, I2) is a (four-valued) 
I1 ⊆ I
interpretation, and U ⊆ (cid:3), we write I[U : f] for the (four-valued) interpretation that equals I on all elements not in U and 
that interprets all elements in U as f, i.e., the interpretation (I1 \ U , I2 \ U ). We are mostly concerned with consistent (also 
called partial or three-valued) interpretations: tuples I = (I1, I2) with  I1 ⊆ I2. For such an interpretation, the atoms in  I1
are true (t) in I, the atoms in  I2 \ I1 are unknown (u) in I and the other atoms are false (f) in I. If I is a three-valued 
interpretation,  and  ϕ a  formula,  we  write  ϕI
for  the  standard  three-valued  valuation  based  on  the  Kleene  truth  tables 
(see Fig. 1). An alternative valuation is the supervaluation; with this valuation, the value of a formula ϕ is t (respectively f) 
in  partial  interpretation  I if  and  only  if  it  is  t (respectively f)  in  all  interpretations  approximated  by  I;  it  is  unknown 
otherwise.

(cid:9)
2

We call two formulas 3-equivalent if they have the same truth value in all three-valued interpretations and 2-equivalent
if  they  have  the  same  truth  value  in  all  (two-valued)  interpretations.  Several  approximators  have  been  deﬁned  for  logic 

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

57

programs. The most common is Fitting’s immediate consequence operator (cid:6)P [20], a direct generalisation of T P to partial 
interpretations. DMT [10] showed that the well-founded ﬁxpoint of (cid:6)P is the well-founded model of P as deﬁned by Van 
Gelder et al. [41] and that (cid:6)P -stable ﬁxpoints are exactly the stable models of P as deﬁned by Gelfond and Lifschitz [21]. 
In this case, the operator (cid:6)P (·, y)1 coincides with the immediate consequence operator of the Gelfond–Lifschitz reduct [21]. 
The most precise approximator is the ultimate approximator U P .

Replacing  the  body  of  a  rule  by  a  3-equivalent  formula  obviously  preserves  (cid:6)P ;  replacing  the  body  of  a  rule  by  a 
2-equivalent  formula  preserves  T P and  hence  also  U P .  Thus,  transformations  that  preserve  3-equivalence,  preserve  stan-
dard Kripke–Kleene, stable and well-founded semantics, and transformations preserving 2-equivalence preserve all ultimate 
semantics (ultimate Kripke–Kleene, ultimate stable, ultimate well-founded). The ease with which this can be proven demon-
strates the power of AFT.

Preserving 2-equivalence is not enough to preserve standard semantics. For example, consider programs P = {p ← p ∨
¬p} and P (cid:23) = {p.}. Even though the body of the rule deﬁning  p in P is a tautology, {p} is not a stable model of P while it 
is a stable model of P (cid:23)
. But ultimate semantics treat these two programs identically. For instance, {p} is the unique ultimate 
stable model of both programs.

While substituting formulas for 2-equivalent formulas in rule bodies preserves the ultimate but not necessarily the stan-
dard versions of semantics, a weaker equivalence property can still be guaranteed. It holds that the standard Kripke–Kleene 
and  well-founded  models  of  both  programs  are  compatible  with  each  other:  no  atom  is  true  in  the  model  of  one  and 
false in the model of the other program. This follows from the fact that both the ultimate Kripke–Kleene and the ultimate 
well-founded model are preserved by these substitutions and that they are consistent and more precise than the standard 
Kripke–Kleene and well-founded model respectively.

The nice property that ultimate semantics only depend on the operator comes at a cost. DMT [12] showed that deciding 
2 -complete,  while  that  same  task  is  only  NP-complete  for  classical  stable 

whether  P has  an  ultimate  stable  model  is  (cid:3) P
models.

4.2.  Grounded ﬁxpoints and approximation ﬁxpoint theory

In this section, we discuss how groundedness relates to AFT. More concretely, we show that all (ultimate) stable ﬁxpoints 

are grounded and that all grounded ﬁxpoints are approximated by the (ultimate) well-founded ﬁxpoint.

Proposition 4.3.  All ultimate stable ﬁxpoints of O are (strictly) grounded ﬁxpoints.

(cid:2)

Proof. Let x be an ultimate stable ﬁxpoint of  O . Thus, (x, x) is a ﬁxpoint of the ultimate stable operator, i.e., x = U O (x)1 =
O ([x, x]), it follows that x is also a ﬁxpoint of O . Now suppose for some y ≤ x, O ( y) ∧ x ≤ y; 
O ([·, x])). Since O (x) =
lfp(
we show that x = y. We know that

(cid:2)

(cid:6)

O ([ y, x]) ≤ O ( y) ∧ O (x) = O ( y) ∧ x ≤ y.
(cid:2)

Thus,  y is a preﬁxpoint of the monotone operator 
that same operator, we ﬁnd that x ≤ y, and thus x = y, which shows that x is strictly grounded indeed. (cid:2)

O ([·, x]). Since x is the least ﬁxpoint (and also the least preﬁxpoint) of 

Example 4.4. The converse of Proposition 4.3 does not always hold. Consider the logic program P :

(cid:5)

(cid:4)

p ← ¬p ∨ q.
q ← ¬q ∨ p.

This logic program has as immediate consequence operator T P :

(cid:13) = {p, q}

{p}

{q}

⊥ = ∅

(cid:13) is grounded for  T P , since the only  v with  T P ((cid:13) ∧ v) = T P (v) ≤ v is (cid:13) itself. However, since  T P ([⊥, (cid:13)]) = L \ {⊥} and 
{p} ∧ {q} = ⊥, it follows that 
T P ([·, (cid:13)])) = ⊥. Therefore, (cid:13) is not an ultimate stable ﬁxpoint 
of T P .

(T P [⊥, (cid:13)]) = ⊥. Thus, lfp(

(cid:2)

(cid:2)

The fact that all  A-stable ﬁxpoints are ultimate stable ﬁxpoints yields:

Corollary 4.5. If A is an approximator of O , then all A-stable ﬁxpoints are (strictly) grounded ﬁxpoints of O .

58

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

Theorem 4.6. The well-founded ﬁxpoint (u, v) of a symmetric approximator A of O approximates all grounded ﬁxpoints of O .

Proof. Let (ai, bi)i≤β be a well-founded induction of  A and let x be a grounded ﬁxpoint of  O . We show by induction that 
for  every  i ≤ β, ai ≤ x ≤ bi .  The  result  trivially  holds  for  i = 0 since  (a0, b0) = (⊥, (cid:13)).  It  is  also  clear  that  the  property  is 
(cid:23), b
(cid:23))
preserved in limit ordinals. Hence, all we need to show is that the property is preserved by  A-reﬁnements. Suppose (a
(cid:23)
(cid:23) ≤ x ≤ b
is an  A-reﬁnement of (a, b) and (a, b) approximates x. We show that also (a
. We 
distinguish two cases.

(cid:23)) approximates x, i.e., that a

(cid:23)) ≤p A(a, b).  Since  x is  a  ﬁxpoint  of  O and  A an  approximator  of  O ,  we  ﬁnd  that 
(cid:23), b
First,  assume  that  (a, b) ≤p (a
(cid:23)).
(cid:23), b
x = O (x) ∈ A(x, x) ⊆ A(a, b) ⊆ (a
(cid:23) = a and  A(a, b
Second,  assume  that  a
proximator  is  consistent,  we  know  that  b
(cid:23)) ∈ A(a, b
O (x ∧ b
that also in this case x ∈ [a

(cid:23) ≤ b.  Since  every  tuple  in  a  well-founded  induction  of  a  symmetric  ap-
(cid:23) ∈ [a, b
(cid:23)],  thus 
.  Hence  x ∧ b
(cid:23)
. Since  x is grounded, this implies that  x ≤ b
; we conclude 

(cid:23))2 ≤ b
(cid:23) ≥ a.  Since  also  x ≥ a,  we  see  that  a ≤ x ∧ b

(cid:23)), and we see that  O (x ∧ b
(cid:23)].

(cid:23)) ≤ A(a, b

(cid:23))2 ≤ b

(cid:23) ≤ b

(cid:23), b

(cid:23), b

(cid:23)

(cid:23)

We have thus shown that every step in a well-founded induction of  A preserves all grounded ﬁxpoints. (cid:2)

Corollary 4.7. If the well-founded ﬁxpoint of a symmetric approximator A of O is exact, then this point is the unique (strictly) grounded 
ﬁxpoint of O .

Since the Kripke–Kleene ﬁxpoint approximates the well-founded ﬁxpoint, we also get the following property.

Corollary 4.8. If the Kripke–Kleene ﬁxpoint of a symmetric approximator A of O is exact, then it is the unique ﬁxpoint of O and it is 
(strictly) grounded.

5.  Grounded ﬁxpoints of logic programs

In  this  section,  we  discuss  grounded  ﬁxpoints  in  the  context  of  logic  programming.  It  follows  immediately  from  the 
algebraical results (Corollary 4.5 and Theorem 4.6) that stable models are grounded ﬁxpoints of the immediate consequence 
operator  and  that  all  grounded  ﬁxpoints  are  minimal  ﬁxpoints  approximated  by  the  well-founded  model.  Furthermore,  if 
the Kripke–Kleene or well-founded model is exact, then it is the unique grounded ﬁxpoint of T P .

Grounded ﬁxpoints can be explained in terms of unfounded sets, a notion that was ﬁrst deﬁned by Van Gelder, Ross and 
Schlipf [41] in their seminal paper introducing the well-founded semantics. Unfounded sets of three-valued interpretations 
are a key concept in the construction of the well-founded model. Intuitively, an unfounded set is a set of atoms that might 
circularly support themselves, but have no support from outside. Stated differently, an unfounded set of a logic program P
with respect to a (partial) interpretation I is a set U of atoms such that P does not provide support for any atom in U if 
the atoms in U are assumed false.

Below, we deﬁne the concept of unfounded set in the context of two-valued interpretations. For clarity, we refer to our 
unfounded  sets  as  “2-unfounded  sets”  and  to  the  original  deﬁnition  by  Van  Gelder,  Ross  and  Schlipf  as  “GRS-unfounded 
sets”.

Deﬁnition 5.1 (2-Unfounded set). Let P be a logic program and  I ⊆ (cid:3) an interpretation.

A set  U ⊆ (cid:3) is a 2-unfounded set of  I (with respect to P ) if for each rule r ∈ P with head(r) ∈ U , body(r)I[U :f]

is false. 

A 2-unfounded set U of  I is called proper if U is a nonempty subset of  I .

Thus, U is a 2-unfounded set of  I if after revising  I by setting atoms of U to false, no atom in U can be derived.
All interpretations  I admit 2-unfounded sets, in particular the empty set ∅ and every set  U consisting of atoms  p that 
are  false  in  I and  for  which  every  rule  r ∈ P with  head(r) = p has  a  false  body  in  I .  Indeed,  for  such  sets,  it  holds  that 
I[U : f] = I and no rule derives an element of U . However, not every interpretation  I admits a proper 2-unfounded set. If  I
has a proper 2-unfounded set, then this means that  I cannot be built up from the ground.

In  Section 5.1,  we  investigate  the  relationship  between  this  formalisation  of  unfounded  sets  and  the  original  one.  In 
particular, we extend the above deﬁnition to three-valued interpretations and show that the different notions of unfounded 
set are equivalent in the context of the well-founded model construction. First, we show how unfounded sets are related to 
the algebraical notion of groundedness.

The  deﬁnition  of  2-unfounded  set  can  be  easily  rephrased  in  terms  of  the  operator  T P ,  as  shown  in  the  following 

proposition.

Proposition 5.2. U is a 2-unfounded set of I with respect to P if and only if T P (I[U : f]) ∩ U = ∅.

Proof. Follows immediately from the fact that  p ∈ T P (I[U : f]) if and only if for some rule r ∈ P with head(r) = p, it holds 
that body(r)I[U :f] = t. (cid:2)

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

59

Example 5.3. Let P be the following program:

⎧
⎨

⎩

p ← q.
q ← p.
r ← ¬p.

⎫
⎬

⎭

Let  I be the interpretation {p, q}. Then U 1 = {p, q} is a 2-unfounded set of  I since  I[U 1 : f] = {r} and in this structure, the 
bodies of rules deﬁning  p and q are false. Alternatively, we notice that T P (I[U 1 : f]) ∩ U 1 = ∅ ∩ U 1 = ∅.

The set U 2 = {p} is not a 2-unfounded set of  I since the rule body for  p evaluates to true in  I[U 2 : f].

In what follows, we use U for the set complement of U , i.e., U = (cid:3) \ U .

Proposition 5.4. Let P be a logic program, I ∈ 2(cid:3) an interpretation, U ⊆ (cid:3). The following statements are equivalent:

• U is a 2-unfounded set of I ,
• T P (I ∩ U ) ⊆ U , and
• T P (I \ U ) ∩ I ⊆ I \ U .

Proof. The equivalence of the ﬁrst two follows immediately from Proposition 5.2 since I[U : f] = I \ U = I ∩ U and for every 
set  X ,  X ⊆ U if and only if  X ∩ U = ∅. The equivalence of the second and third follows from the fact that  I \ U = I ∩ U and 
for all subsets  X, Y and  Z of (cid:3) it holds that  X ∩ Y ⊆ Y \ Z if and only if  X ⊆ ((cid:3) \ Z ). (cid:2)

Proposition 5.4 shows that U is a 2-unfounded set if and only if its complement satisﬁes the condition on  v in Deﬁni-
tion 3.1 if and only if  I \ U satisﬁes the condition on  y in Deﬁnition 3.2. This allows us to reformulate the condition that  I
is grounded as follows.

Proposition 5.5. A structure I is (strictly) grounded for T P if and only if I does not contain atoms that belong to a 2-unfounded set U
of I with respect to P .

Proof. First, suppose  I is grounded for  T P and  U is a 2-unfounded set of  I . Let  V = U denote the set complement of  U . 
Since U is a 2-unfounded set, T P (I ∩ V ) ⊆ V . Thus, the deﬁnition of groundedness yields  I ⊆ V , and hence that U ∩ I = ∅. 
We conclude that  I is indeed disjoint from any 2-unfounded set.

The reverse direction is analogous. Suppose every 2-unfounded set is disjoint from  I . Let  V be such that T P (I ∩ V ) ⊆ V

and let U = V denote the complement of V . Then again  I[U : f] = I ∩ V and the result follows.

We already established in Proposition 3.5 that groundedness is equivalent with strict groundedness in this context. (cid:2)

Corollary 5.6. A structure I is a grounded ﬁxpoint of T P if and only if it is a ﬁxpoint of T P and it has no proper 2-unfounded sets.

We call grounded ﬁxpoints of T P grounded models of P . Similarly to ultimate semantics, grounded models are insensitive 
are  such  that  T P = T P (cid:23) ,  then  the  grounded 

to  2-equivalence-preserving  rewritings  in  the  bodies  of  rules:  if  P and  P (cid:23)
models of P and P (cid:23)

coincide. Also similar to ultimate semantics, the above property comes at a cost.

Theorem 5.7. The problem “given a ﬁnite propositional logic program P , decide whether P has a grounded model” is (cid:3) P

2 -complete.

The proof of this theorem is heavily inspired by the proof of a similar property for ultimate stable models (Theorem 6.12) 
2 -hard problem to our problem.

by DMT [12]; we use the same reduction of a (cid:3) P

We now show (cid:3) P

Proof. Given an interpretation  I , the task of verifying that  I is a grounded model can be done by calculating  T P (I[U : f])
for all candidate proper 2-unfounded sets, i.e., non-empty sets U with U ⊆ I . Hence this task is in co-NP. Thus the task of 
deciding whether there exists grounded model certainly is in the class (cid:3) P
2 .

2 -hardness of the problem of existence of a grounded model of a program P . Let ϕ be a propositional 
formula in DNF over propositional symbols x1, . . . , xm, y1, . . . , yn. For an interpretation I ⊆ {x1, . . . , xm}, we deﬁne ϕI as the 
formula obtained from ϕ by replacing all atoms  xi ∈ I by  t and all atoms  xi /∈ I by  f. Recall that the problem of deciding 
whether there exists an interpretation I ⊆ {x1, . . . , xm} such that ϕI is a tautology is (cid:3) P
2 -hard. We now reduce this problem 
(cid:23)
(cid:23)
to our problem. For each  xi , we introduce a new variable  x
be the 
i ; we will use  x
(cid:23)
i . We deﬁne a program P(ϕ) consisting of the following clauses
formula obtained from ϕ by replacing all literals ¬xi by x

i to represent the negation of  xi . Let ϕ(cid:23)

(cid:23)
(cid:23)
1. xi ← ¬x
i and x
i
2. yi ← ϕ(cid:23)
for each i ∈ {1, . . . , n},

← ¬xi for each i ∈ {1, . . . , m},

60

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

3. p ← ϕ(cid:23)
4. q ← ¬p ∧ ¬q.

,

We now show that there is an  I ⊆ {x1, . . . , xm} such that ϕI is a tautology if and only if P(ϕ) has a grounded model. It is 
easy to see that in each ﬁxpoint M of T P(ϕ) the following properties hold:

1. q is false in M (if q is true T P(ϕ) does not derive q),
2. p is true in M (otherwise T P(ϕ) derives q),
3. y1, . . . , yn are true in M (since their rules have the same body as  p),
(cid:23)
4. for each i ∈ {1, . . . , m}, exactly one of xi and x
i is true in M.

Given a set  I ⊆ {x1, . . . , xm}, we deﬁne  ˇI = I ∪ {x
(cid:23)
i
T P(ϕ), there exists an  I such that

M = ˇI ∪ {p, y1, . . . , yn}.

| xi /∈ I}. It follows from the above properties that for each ﬁxpoint  M of 

Thus it suﬃces to show that if  I ⊆ {x1, . . . , xm}, then  M = ˇI ∪ {p, y1, . . . , yn} is a grounded model of P(ϕ) if and only 

if ϕI is a tautology.

In order to prove this, we ﬁx  I and  M = ˇI ∪ {p, y1, . . . , yn}. Now,  M is not a grounded model if and only if there exists 
(cid:23)
a non-empty U ⊆ M such that  T P (M \ U ) ∩ U = ∅. Since  T P is anti-monotone when restricted to the xi and x
i , each such 
(cid:23)
i /∈ U . Hence U ⊆ {p, y1, . . . , yn}. Hence, such a U has the property that ϕ(cid:23)
U has the property that xi /∈ U and x
is false in 
M \ U . But ϕ(cid:23)
is false in  M \ U if and only if ϕI is false in { y1, . . . , yn} \ U . Thus, we conclude that  M is not a grounded 
model if and only if there exists a truth assignment to  J ⊆ { y1, . . . , yn} such that ϕI is false in  J . Thus, M is not a grounded 
model if and only if ϕI is not a tautology, which is exactly what we needed to show. (cid:2)

Let us brieﬂy compare grounded model semantics with the two most frequently used semantics of logic programming: 
well-founded  and  stable  semantics.  Firstly,  we  observe  that  these  three  semantics  tend  to  prefer  a  subclass  of  the  mini-
mal  models.  We  called  this  criterion  groundedness  and  indeed  found  that  stable  semantics  and  two-valued  well-founded 
semantics have the property that they only accept grounded interpretations.

Secondly, since these three semantics are closely related, it is to be expected that they often coincide. We established that 
for  programs  with  a  two-valued  Kripke–Kleene  model,  the  Kripke–Kleene  semantics  coincides  with  the  supported  model 
semantics and with the three semantics mentioned above. Also for programs with a two-valued well-founded model, the 
three semantics coincide. This sort of programs is common in applications for deductive databases (Datalog and extensions 
[1]) and for representing inductive deﬁnitions [14,16]. In contrast, well-founded semantics only rarely coincides with stable 
semantics in the context of answer set programming (ASP). In the context where the well-founded model is three-valued, 
the question arises when stable and grounded models coincide. We illustrated in Example 4.4 that in this case, stable and 
grounded model semantics may disagree (since {p, q} is not an ultimate stable model, it certainly is no stable model either). 
However,  we  observe  that  this  example  is  quite  extraordinary,  and  this  is  the  case  for  all  such  programs  that  we  found. 
It  leads  us  to  expect  that  both  semantics  coincide  for  large  classes  of  ASP  programs.  It  is  therefore  an  interesting  topic 
for  future  research  to  search  for  characteristics  of  programs  that  guarantee  that  both  semantics  agree.  If  such  properties 
can be identiﬁed, then within those classes the grounded model semantics gives an equivalent reformulation of the stable 
semantics. If these classes cover the pragmatically important classes of ASP programs (that is, if the ASP programs written 
for practical problems fall inside them), then the grounded model semantics is an elegant, intuitive and concise variant of 
the standard stable semantics, which in practice coincides with it. And if pragmatically important classes of programs are 
discovered for which both semantics disagree, the question then is if other properties than groundedness can be identiﬁed 
that are possessed by stable but not by grounded models.

Grounded model semantics is, to the best of our knowledge, the ﬁrst purely two-valued and algebraical semantics for logic 
programs  that  satisﬁes  the  desirable  property  of  groundedness.  The  well-founded  semantics  explicitly  uses  three-valued 
interpretations  in  the  well-founded  model  construction.  Stable  semantics  uses  three-valued  logic  implicitly  in  the  sense 
that, as we showed, the Gelfond–Lifschitz reduct corresponds to an evaluation in a partial interpretation. One of the main 
advantages of grounded model semantics is that it is so easily deﬁnable for language extensions. All it takes is to deﬁne the 
(two-valued) immediate consequence operator. Typically this is quite easy (see the next paragraph). Note that the ultimate 
versions of the well-founded and stable semantics are purely algebraical as well but they are mathematically more involved 
since they still refer to three-valued interpretations (replacing Kleene valuation by supervaluation).

Grounded ﬁxpoints for logic programs with abstract constraint atoms.  The  fact  that  grounded  model  semantics  is  two-valued 
and  algebraical  makes  it  not  only  easier  to  understand,  but  also  to  extend the  semantics.  To  illustrate  this,  we  consider 
logic programs with abstract constraint atoms as deﬁned by Marek et al. [29]. An abstract constraint is a collection C ⊆ 2(cid:3) . 
A constraint atom is an expression of the form C( X), where  X ⊆ (cid:3) and C is an abstract constraint. The goal of such an atom 
is to model constraints on subsets of  X . The truth value of C( X) in interpretation I is t if I ∩ X ∈ C and f otherwise. Abstract 

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

61

constraints  are  a  generalisation  of  pseudo-Boolean  constraints,  cardinality  constraints,  containment  constraints,  and  much 
more. A deterministic logic program with abstract constraint atoms [29] is a set of rules of the form1

p ← a1 ∧ · · · ∧ an ∧ ¬b1 ∧ · · · ∧ ¬bm,

where  p is an atom and the ai and bi are constraint atoms. Having deﬁned the truth value of a constraint atom C( X) in an 
interpretation  I , an immediate consequence operator can be deﬁned in the standard way:

T P (I) = {p | ∃r ∈ P : head(r) = p ∧ body(r)I = t}.

Grounded  models  of  this  operator  still  represent  the  same  intuitions:  an  interpretation  I is  grounded  if  it  admits  no  un-
founded  sets,  or  said  differently,  if  it  contains  no  atoms  without  external  support.  Thus,  I is  grounded  if  it  contains  no 
non-empty set U of atoms such that body(r)I[U :f]

for each rule r with head(r) ∈ U .

Example 5.8. Let (cid:3) be the alphabet {a, b, c, d}. For every i, let C≥i be the cardinality constraint { X ⊆ (cid:3) | | X| ≥ i}. Consider 
the following logic program P over (cid:3):
b ← C≥1((cid:3)).
a.
c ← ¬C≥4((cid:3)). d ← C≥4((cid:3)).

(cid:5)

(cid:4)

Any interpretation in which d holds is not grounded since, taking U = {d} yields for every  I that C≥4((cid:3))I[U :f] = f and thus 
d /∈ T P (I[U : f]). It can easily be veriﬁed that {a, b, c} is the only grounded model of P .

This example illustrates that even for complex, abstract extensions of logic programs, groundedness is an intuitive prop-
erty. Groundedness easily extends to these rich formalisms: the lattice always is the space of interpretations, the immediate 
consequence  is  deﬁned  in  the  standard  way  and  deﬁning  grounded  models  takes  only  one  line  given  this  immediate 
consequence  operator.  This  is  in  sharp  contrast  with  more  common  semantics  of  logic  programming  (such  as  stable  and 
well-founded semantics) which are often hard(er) to extend to richer formalisms, as can be observed by the many different 
versions of those semantics that exist for logic programs with aggregates [19,37,35,18,22].

Furthermore, groundedness is closely related to one of the most popular semantics for logic programs with aggregates, 
namely the FLP-stable semantics deﬁned by Faber et al. [18]. Given an interpretation I , Faber, Pfeifer and Leone [18] deﬁned 
the  reduct  of  P with  respect  to  I as  the  program  P I = {r | r ∈ P ∧ I |(cid:24) body(r)}.  I is  an  FLP-stable model of  P if  it  is  a 
subset-minimal model of  T P I . For a large class of programs, this semantics is equivalent with qrounded model semantics, 
as the following theorem shows.

Theorem 5.9. Let P be a logic program with abstract constraint atoms. If for each  p ∈ (cid:3), there is at most one rule r ∈ P with 
head(r) = p, then I is an FLP-stable model of P if and only if I is a grounded model of P .

Proof. In this case, for all  I and  J ,  T P I ( J ) = T P ( J ) ∩ T P (I) since P I is obtained from P by removing all rules with body 
false in I and there is at most one rule deﬁning each atom. If I is a supported model, we ﬁnd that T P I ( J ) = T P ( J ) ∩ I . It is 
easy to see that FLP-stable models are supported models, i.e., ﬁxpoints of  T P . Assume  I is a supported model. In this case 
I is FLP-stable if and only if there is no  J (cid:3) I with T P ( J ) ∩ I = T P I ( J ) ⊆ J , i.e., if and only if I is strictly grounded. Now, we 
know from Proposition 3.5 that in the context of logic programming, groundedness and strict groundedness are equivalent, 
which proves our claim. (cid:2)

5.1.  Discussion

Unfounded sets.  Unfounded  sets  were  ﬁrst  deﬁned  by  Van  Gelder  et  al.  [41] in  their  seminal  paper  introducing  the  well-
founded semantics. Their deﬁnition slightly differs from Deﬁnition 5.1.

Deﬁnition 5.10 (GRS-unfounded set). Let P be a logic program and I a three-valued interpretation. A set  U ⊆ (cid:3) is a GRS-
unfounded set of I (with respect to P ) if for each rule r with head(r) ∈ U , body(r)I = f or body(r)I[U :f] = f.

The ﬁrst difference between 2-unfounded sets and GRS-unfounded sets is that GRS-unfounded sets are deﬁned for three-
valued interpretations, while we restricted our attention to (two-valued) interpretations. Our deﬁnition easily generalises to 
three-valued interpretations as well.

Deﬁnition  5.11  (3-Unfounded  set).  Let  P be  a  logic  program  and  I a  three-valued  interpretation.  A  set  U ⊆ (cid:3) is  a 
3-unfounded set of I (with respect to P ) if for each rule r with head(r) ∈ U , body(r)I[U :f] = f.

1 The approach by Marek et al. [29] also includes nondeterministic programs. We come back to this issue in Section 5.1.

62

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

Lemma 5.12. Let P be a logic program and I an interpretation. A set U ⊆ (cid:3) is a 2-unfounded set of I with respect to P if and only if 
it is a 3-unfounded set of I with respect to P .

Proof. Follows immediately from the deﬁnitions. (cid:2)

This deﬁnition formalises the same intuitions as Deﬁnition 5.1: U is a 3-unfounded set if making all atoms in U false in 

I results in a state where none of them can be derived. This deﬁnition easily translates to algebra as well.

Proposition 5.13. Let P be a logic program, (cid:6)P Fitting’s immediate consequence operator and I a three-valued interpretation. A set 
U ⊆ (cid:3) is a 3-unfounded set if and only if (cid:6)P (I[U : f])2 ∩ U = ∅.

Proof. Recall that Fitting’s operator is deﬁned by

(cid:6)P (I)1 = {a ∈ (cid:3) | body(r)I = t for some rule r ∈ P with head(r) = a}
(cid:6)P (I)2 = {a ∈ (cid:3) | body(r)I (cid:10)= f for some rule r ∈ P with head(r) = a}

The claim now follows immediately from the deﬁnition of (cid:6)P (I)2. (cid:2)

The following proposition relates the two notions of unfounded sets.

Proposition 5.14. Let P be a logic program, I a three-valued interpretation and U ⊆ (cid:3). The following properties hold.

• If U is a 3-unfounded set, then U is a GRS-unfounded set.
• If I[U : f] is more precise than I, then U is a GRS-unfounded set if and only if U is a 3-unfounded set.

Proof. The ﬁrst claim follows directly from the deﬁnitions.

If I and U are chosen such that I[U : f] is more precise than I, for every formula ϕ, the condition ϕI = f or ϕI[U :f] = f
is equivalent with ϕI[U :f] = f. Thus we conclude that in this case the notions of 3-unfounded set and GRS-unfounded set 
are indeed equivalent, which proves the second claim. (cid:2)

Thus,  for  a  certain  class  of  interpretations,  the  two  notions  of  unfounded  sets  coincide.  Furthermore,  Van  Gelder  et 
al. only use unfounded sets to deﬁne the well-founded model construction. It follows immediately from Lemma 3.4 by Van 
Gelder et al. [41] that every partial interpretation I in that construction with GRS-unfounded set U satisﬁes the condition 
in the second claim in Proposition 5.14. This means that  3-unfounded sets and GRS-unfounded sets are equivalent for all 
interpretations that are relevant in the original work! Essentially, we provided a new formalisation of unfounded sets that 
coincides with the old deﬁnition on all interpretations used in the original work.

Corollary 5.6,  which  states  that  grounded  models  of  P are  ﬁxpoints  of  T P that  permit  no  proper  2-unfounded  sets, 
might sound familiar. Indeed, it has been shown that an interpretation is a stable model of a logic program if and only if it 
is a ﬁxpoint of T P and it permits no proper GRS-unfounded sets [28].

Groundedness and nondeterminism. In Section 5, we restricted our attention to logic programs with abstract constraint atoms 
in the bodies of rules, and we did not allow them in heads of rules. As argued by Marek et al. [29], allowing them as well in 
heads gives rise to a nondeterministic generalisation of the immediate consequence operator. A consistent nondeterministic 
operator maps every point x ∈ L to a non-empty set O (x) ⊆ L. Extending the notion of groundedness to this nondeterministic 
setting is out of the scope of this paper.

6.  Grounded ﬁxpoints in Dung’s argumentation frameworks and abstract dialectical frameworks

Abstract argumentation frameworks (AFs) [17] are simple and abstract systems to deal with contentious information and 
draw  conclusions  from  it.  An  AF  is  a  directed  graph  where  the  nodes  are  arguments  and  the  edges  encode  a  notion  of 
attack between arguments. In AFs, we are not interested in the actual content of arguments; this information is abstracted 
away.  In  spite  of  their  conceptual  simplicity,  there  exist  many  different  semantics  with  different  properties  in  terms  of 
characterisation, existence and uniqueness.

Abstract dialectical frameworks (ADFs) [8,7] are a generalisation of AFs in which not only attack, but also support, joint 

attack and joint support can be expressed.

Recently, Strass [38] has showed that many of the existing semantics of AFs and ADFs can be obtained by direct applica-
tions of AFT. In this section we use the aforementioned study to relate grounded ﬁxpoints to AFs and ADFs. We ﬁrst do so 
for the case of AFs and afterwards generalise to ADFs.

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

63

6.1.  Abstract argumentation frameworks

An  abstract argumentation framework (cid:7) is  a  directed  graph  ( A, R) in  which  the  nodes  A represent  arguments  and  the 
edges in  R represent attacks between arguments. We say that a attacks b if (a, b) ∈ R. A set  S ⊆ A attacks a if some s ∈ S
attacks a. A set  S ⊆ A defends a if it attacks all attackers of a. An interpretation of an AF (cid:7) = ( A, R) is a subset S of  A. The 
intended meaning of such an interpretation is that all arguments in S are accepted (or believed) and all arguments not in S
are rejected. Interpretations are ordered according to the acceptance relation:  S 1 ≤ S2 iff  S1 ⊆ S2, i.e., if  S2 accepts more 
arguments than  S1. There exist many different semantics of AFs which each deﬁne different sets of acceptable arguments 
according to different standards or intuitions. The major semantics for argumentation frameworks can be formulated using 
two operators: the characteristic function F (cid:7), which maps an interpretation  S to

F (cid:7)(S) = {a ∈ A | S defends a}

and the operator U (cid:7) (U stands for unattacked), which maps an interpretation  S to

U (cid:7)(S) = {a ∈ A | a is not attacked by S}.

An  interpretation  S is  conﬂict-free if  it  is  a  postﬁxpoint  of  U (cid:7) (S ≤ U (cid:7)(S)),  i.e.,  if  no  argument  in  S is  attacked  by  S. 
The  characteristic  function  is  a  monotone  operator;  its  least  ﬁxpoint  is  called  the  grounded extension of  (cid:7).  The  operator 
U (cid:7) is an anti-monotone operator; its ﬁxpoints are called stable extensions of (cid:7). Many more semantics, such as admissible 
interpretations, complete extensions, semi-stable extensions, stage extensions and preferred extensions can be characterised using 
the above operators as well [17].

The following proposition shows that grounded extensions as deﬁned in argumentation theory are indeed grounded in 

the sense deﬁned in this paper.

Proposition 6.1. The grounded extension of (cid:7) is the unique grounded ﬁxpoint of F (cid:7).

Proof. Follows immediately from Proposition 3.10 which states that a monotone operator has exactly one grounded ﬁxpoint, 
namely its least ﬁxpoint. (cid:2)

The grounded extension  S consists of all arguments a that should deﬁnitely be accepted: all arguments that are glob-
ally  unattacked,  defended  by  globally  unattacked  arguments,  and  so  on  (recursively).  As  such,  the  intuition  regarding  the 
grounded  extension  is  similar  to  intuitions  regarding  grounded  ﬁxpoints:  we  only  accept  arguments  with  a  good,  non-
self-supporting defence.

Example 6.2. Consider the following framework:

e

a

c

b

d

In this example a is unattacked, hence should be accepted; b is attacked by a, hence should not be accepted. The argument e
is defended by a, hence can safely be accepted. c and d mutually attack each other and hence, defend themselves. Since we 
have already established that b is rejected, the only remaining argument that defends c is c itself. The grounded extension 
rejects self-defending arguments (i.e., rejects both c and d) and hence is {a, e}.

Proposition 6.3. An interpretation S is a stable extension of (cid:7) if and only if it is a grounded ﬁxpoint of U (cid:7).

Proof. Follows  immediately  from  Proposition 3.11 which  states  that  all  postﬁxpoints  of  an  antimonotone  operator  are 
grounded. Indeed, U (cid:7) is anti-monotone and stable extensions are exactly the ﬁxpoints of U (cid:7). (cid:2)

Example 6.4 (Example 6.2 continued). Stable extensions are more liberal in accepting arguments than the grounded exten-
sion.  In  stable  extensions,  arguments  are  “by  default”  accepted,  unless  another  accepted  argument  contradicts  them.  The 
framework considered in this example has two stable extensions: {a, e, c} and {a, e, d}.

6.2.  Abstract dialectical frameworks

We now extend our theory to the more general case of ADFs. In the context of AFs, grounded ﬁxpoints characterise two 
existing semantics, when applied to two previously deﬁned operators. In the context of ADFs, however, this does not hold. 
Here, grounded ﬁxpoints yield a new semantics.

64

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

An abstract dialectical framework is a triple (cid:8) = (S, L, C), where

• S is a set of arguments,
• L ⊆ S × S is a set of links; we deﬁne the parents of s ∈ S as par(s) = {r ∈ S | (r, s) ∈ L},
• C = {C in
s

}s∈S is a collection of sets C in

s where for every s, C in
s

⊆ 2par(s).

Intuitively, for every  s,  par(s) is the set of arguments that inﬂuence whether or not  S should be accepted. This inﬂuence 
can  be  positive  (support),  negative  (attack)  or  a  combination  of  both.  An  argument  s should  be  accepted  if  for  some  set 
s , all arguments in  A are accepted and all arguments in par(s) \ A are not. An argumentation framework (cid:7) = ( A, R) is 
A ∈ C in
an ADF in which all links are attack relations, i.e., for every s, par(s) = {s
= {∅} (the only way to accept 
an argument is if none of its attackers is accepted).

(cid:23), s) ∈ R} and C in
s

(cid:23) | (s

Example 6.5. Let  S be the set of arguments {a, b, c, d} and L the following graph

a

d

c

b

Furthermore,  C in
a
reading of the ADF (cid:8) = (S, L, C).

= {∅},  C in
b

= {{b}},  C in
c

= {∅, {a}, {b}} and  C in
d

= {{a, b}}.  The  following  observations  provide  an  intuitive 

• a is a valid argument since it has trivial support.
• b supports itself: the only “reason” to believe b is b itself.
• a and b jointly attack c: since C in
c
• a and b jointly support d: d is only acceptable if a and b both hold.

= {∅, {a}, {b}}, c is only rejected if a and b are both present.

Intuitively, we should accept a. Whether or not to accept b, depends on which semantics for ADFs is used. Argument c can 
only be accepted in case we reject b, d should be accepted if we accept b.

With an ADF (cid:8), we associate an operator G(cid:8) on the lattice (cid:8)2S , ⊆(cid:9) as follows [38]:

G(cid:8)(X) = {s ∈ S | X ∩ par(s) ∈ C in
s

}.

This operator generalises the operator U (cid:7) for AFs.

Strass [38] showed that many of the existing semantics for ADFs can be characterised with AFT. For example, models of 
(cid:8) are ﬁxpoints of  G(cid:8), stable models [7] of (cid:8) are ultimate stable ﬁxpoints of  G(cid:8), etcetera. He also showed that there is a 
one to one correspondence between ultimate semantics for ADFs and for logic programs, in the sense that every ADF (cid:8) can 
be transformed to a logic program P such that G(cid:8) and  T P coincide and vice versa. It is out of the scope of this paper to 
discuss all of the different semantics for ADFs. Here, we restrict ourselves to discussing the intuitions regarding grounded 
ﬁxpoints. The intuitions underlying grounded ﬁxpoints of ADFs are of course similar to those in other domains where AFT 
is applied. Groundedness serves to eliminate “ungrounded” reasoning: if the only reason for accepting an argument is that 
the argument itself holds, then this argument should be rejected.

Example 6.6 (Example 6.5 continued). The operator  G(cid:8) from this example has two ﬁxpoints: {a, b, d} and {a, c}. The ﬁrst of 
the two is not a grounded ﬁxpoint because b itself is the only reason to accept b. Formally

G(cid:8)({a, b, d} ∧ {a, c, d}) = G(cid:8)({a, d}) = {a, c} ≤ {a, c, d}

thus indeed {a, b, d} is ungrounded. On the other hand, {a, c} is grounded; it is the unique grounded ﬁxpoint of G(cid:8).

We now study groundedness in the context of ADFs.

Deﬁnition 6.7 (Support). Let (cid:8) = (S, L, C) be an ADF and  X ⊆ S. We say that s ∈ S has support in  X if  X ∩ par(s) ∈ C in
s .

Deﬁnition 6.8 (Grounded model). Let (cid:8) = (S, L, C) be an ADF and  X ⊆ L a model of (cid:8). We say that  X is a grounded model
of (cid:8) if for every set U with ∅ (cid:3) U ⊆ X , at least one u ∈ U has support in  X \ U .

Thus, a grounded model is one without self-supporting arguments, i.e., without arguments that no longer have support 

once they are removed.

Below, U denotes the set complement of U , i.e., U = S \ U .

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

65

Proposition 6.9. Let (cid:8) = (S, L, C) be an ADF. Then X ⊆ S is a grounded ﬁxpoint of G(cid:8) if and only if X is a grounded model of (cid:8).

Proof. The proof is analogous to the proof of Proposition 5.5.

First, suppose  X is a grounded ﬁxpoint of G(cid:8). Since  X is a ﬁxpoint of G(cid:8), by deﬁnition it is a model of (cid:8). If U is a set 
∅ (cid:3) U ⊆ X , we need to show that at least one u ∈ U has support in  X \ U . Suppose this condition is not satisﬁed, i.e., that no 
u has support in  X \ U . This means that G(cid:8)( X \ U ) ∩ U = ∅. Let V = U ; the previous equation translates to G(cid:8)( X ∧ V ) ≤ V . 
Thus, the deﬁnition of groundedness yields  X ≤ V , and hence that U ∩ X = ∅, which contradicts with the assumption that 
∅ (cid:3) U ⊆ X , hence  X is indeed a grounded model of (cid:8).

The  reverse  direction  is  analogous.  Suppose  X is  a  grounded  model  of  (cid:8).  Let  V be  such  that  G(cid:8)( X ∧ V ) ≤ V and  let 
U = V ∩ X . Thus U ⊆ X and (since  X \ U = X ∧ V ) G(cid:8)( X \ U ) ∩ U = ∅. Thus, by our assumption, U is empty, i.e.,  X ≤ V and 
we conclude that  X is indeed a grounded ﬁxpoint in this case. (cid:2)

It is worth noting that the set U in Deﬁnition 6.8 corresponds to a proper unfounded set in the case of logic program-

ming.

Many  semantics  have  been  deﬁned  for  ADFs.  Most  of  these  semantics  are  three-valued.  The  only  two-valued  seman-
tics  are  conﬂict-free sets,  supported models and  two-valued stable models.  Our  algebraic  results  immediately  yield  that  the 
two-valued stable semantics has the property that it only accepts grounded interpretations. Grounded ﬁxpoints are a new 
element in the family of two-valued semantics of ADFs. We believe that this is an interesting new member: as illustrated 
above,  it  formalises  simple  and  clear  intuitions.  Two-valued  stable  semantics  and  grounded  ﬁxpoint  semantics  formalise 
related ideas. As with logic programs, we conjecture that for large classes of ADFs these two semantics coincide; it remains 
an open research question to deﬁne those classes (or classes on which they differ). Since Strass [38] deﬁned transformations 
between logic programs and ADFs that preserve the operator, solving this research question will also solve the related open 
question from Section 5 and vice versa.

6.3.  Discussion

Complexity. Strass has showed that there is a one to one correspondence between ultimate semantics for ADFs and for logic 
programs, in the sense that every ADF (cid:8) can be transformed to a logic program P such that G(cid:8) and T P coincide and vice 
versa. These results allow us to port complexity results from the ﬁeld of logic programming to ADFs and vice versa. Hence, 
Theorem 5.7 yields that checking existence of a grounded ﬁxpoint of an ADF is (cid:3) P

In  the  context  of  ADFs,  one  is  often  also  interested  in  other  forms  of  reasoning  such  as  credulous or  sceptical reason-

2 -complete.

ing [39]. Analysing complexity of grounded ﬁxpoint semantics for more forms of reasoning is a topic for future work.

7.  Grounded ﬁxpoints of autoepistemic and default theories

In this section, we study groundedness in the context of Moore’s autoepistemic logic (AEL) [34] and Reiter’s default logic 

(DL) [36].

In the late seventies, the ﬁeld of knowledge representation and more particularly, the ﬁeld of non-monotonic reasoning, 
increasingly became concerned with the representation of and reasoning on default statements “most  P ’s are  Q ’s”. The idea 
grew  to  interpret  such  statements  as  defeasible  inference  rules  “if  x is  a  P and  it  is  not  known  that  x is  not  a  Q then 
(derive that) x is a  Q ”. This idea was developed independently in default logic by Reiter [36] and nonmonotonic logic I and 
II  [32,31].  Not  much  later,  Moore  [34] identiﬁed  the  latter  sort  of  statements  as  autoepistemic statements  and  developed 
autoepistemic logic (AEL) for it.

In Moore’s view, an autoepistemic theory T is the representation of the knowledge of a perfect, rational, introspective 
agent. The agent is introspective in the sense that propositions in its theory may refer to its own knowledge, through the 
modal operator K . The informal interpretation of this operator is “I (the agent) know that . . . ”. The agent is a perfect reasoner 
in  the  sense  that  its  knowledge  is  closed  under  entailment.  It  is  rational in  the  sense  that  it  only  believes  propositions 
contained in or entailed by its knowledge base T . Thus, T expresses, directly or indirectly, all the agent knows. Levesque 
[27] called this assumption about T the “All I Know Assumption”. It is this assumption that distinguishes autoepistemic logic 
from the standard modal logic of knowledge S5. The challenge in deﬁning such a logic lies in the fact that autoepistemic 
theories are self-referential: what is known by T is made up from what is expressed by its statements, but what is expressed 
by a statement depends on what is known by T .

Moore [34] formalised these ideas as follows. Let L be the language of propositional logic based on the vocabulary (cid:3). 
Extending  this  language  with  a  modal  operator  K ,  yields  the  language  LK of  modal  propositional  logic.  An  autoepistemic 
theory (over (cid:3)) is a set of formulas in LK . A modal formula is a formula of the form  K ψ , with ψ a formula. An objective 
formula is a formula without modal subformulas.

AEL  uses  the  semantical  concepts  of  standard  modal  logic.  As  before,  an  interpretation I is  a  subset  of  (cid:3).  It  formally 
represents a potential state of affairs of the world. A possible world structure is a set of interpretations. It can be seen as a 
Kripke structure with the total accessibility relation. The set of all possible world structures, W(cid:3) , is thus 2(2(cid:3) ). It forms a 
complete  lattice  under  ⊆ as  well  as  under  ⊇.  A  possible  world  structure  Q formally  expresses  a  potential  belief  state  of 

66

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

an agent by providing all the states of the world that the agent considers to be possible. Interpretations  I ∈ Q are formal 
representations of possible states of affairs and satisfy the propositions known by the agent. Interpretations I /∈ Q represent 
impossible states of affairs in the sense that they violate some of the agent’s propositions.

The semantics of AEL is based on the standard S5 truth assignment. For arbitrary formula ϕ in LK ,  Q a possible world 
structure and I an interpretation, we deﬁne that ϕ is satisﬁed with respect to  Q and I (denoted  Q , I |(cid:24) ϕ) by the standard 
recursive rules of propositional satisfaction, augmented with one additional rule:

Q , I |(cid:24) K ϕ if Q , I

(cid:23) |(cid:24) ϕ for every I

(cid:23) ∈ Q .

For objective formulas ϕ, it holds that  Q , I |(cid:24) ϕ if and only if  I |(cid:24) ϕ. We deﬁne  Q |(cid:24) K ϕ (ϕ is known in  Q ) if  Q , I |(cid:24) ϕ for 
every  I ∈ Q . As can be seen from the deﬁnition of satisfaction, modal formulas are evaluated with respect to the possible 
world structure  Q , while objective formulas are evaluated with respect to the world  I .

Example 7.1. Consider a formula ϕ = ¬p ∧ ¬Kp. Let  Q be the possible world structure {{p}, ∅} and let I = ∅. Then,  Q , I (cid:10)|(cid:24) p, 
and  Q , I (cid:10)|(cid:24) Kp, hence  Q , I |(cid:24) ϕ.

(cid:23)

if it has more possible worlds. Formally we deﬁne Q ≤k Q

The  class  W(cid:3) of  possible  world  structures  exhibits  a  natural  knowledge  order.  Intuitively  Q contains  less  knowledge 
. The intuition underlying this order is clariﬁed 
than Q
by considering the concept of the objective theory of a possible world structure  Q . This is the set of objective formulas that 
are known in  Q . Formally, it is deﬁned as T hobj(Q ) = {ϕ ∈ L | Q |(cid:24) K ϕ} = {ϕ ∈ L | ∀I ∈ Q : I |(cid:24) ϕ}. Moore [33] proved that 
the function  T hobj induces a one-to-one correspondence between possible world structures and sets of objective formulas 
(cid:23)
closed under logical consequence. An obvious property is that  Q ≤k Q
then indeed  Q possesses less knowledge than  Q

if and only  T hobj(Q ) ⊆ T hobj(Q

(cid:23)). Thus, if  Q ≤k Q

if Q ⊇ Q

.

(cid:23)

(cid:23)

(cid:23)

(cid:23)

With the order  ≤k , W(cid:3) forms a complete lattice. For example, if (cid:3) = {p}, the associated lattice is:

Moore proposed to formalise the intuition that an AEL theory T expresses “all the agent knows” in semantical terms, as 
a condition on the possible world structure  Q representing the agent’s belief state. The condition is as follows: a world I is 
possible according to  Q if and only if I satisﬁes T given  Q , that is if  Q , I |(cid:24) T . Equivalently,  I is impossible if and only if 
I violates T given  Q , or  Q , I (cid:10)|(cid:24) T . Formally, Moore deﬁnes that  Q is an autoepistemic expansion of T if for every world  I , 
it holds that  I ∈ Q if and only if  Q , I |(cid:24) T .

The above deﬁnition is essentially a ﬁxpoint characterisation. The underlying operator  DT is:

DT (Q ) = {I | Q , I |(cid:24) T }.

Clearly,  Q is an autoepistemic expansion of T if and only if  Q is a ﬁxpoint of  DT . These autoepistemic expansions are the 
possible world structures that, according to [34] express candidate belief states of an autoepistemic agent with knowledge 
base T . Moore called such structures grounded.

Soon, researchers such as Halpern and Moses [24] and Konolige [26] pointed out certain “anomalies” in the expansion 
semantics. The simplest example is the theory T = {Kp ⇒ p}. One of its expansions is  Q 2 = {{p}}. The problem with  Q 2
is  that  it  is  self-supporting:  Q 2’s  assumption  that  p is  known  to  be  true,  is  essential  for  deriving  p.  Even  from  Moore’s 
perspective there might be a problem with such self-supporting belief states. In the ﬁrst part of his work [34], he argues 
that sets of inference rules such as the theories that arise in nonmonotonic reasoning, correspond to autoepistemic theories. 
Viewed from this perspective, T is the singleton set consisting of one inference rule:

(cid:27) p
p

Surely, such an inference rule should be of no value, as it can only derive something that has been derived before! Therefore, 
the only acceptable belief state for T seems to be  Q 1, the state of total ignorance.

Several attempts were done to strengthen Moore’s semantics. Halpern and Moses [24] proposed an alternative possible 
world semantics in which the model of an AEL theory T is the  ≤p -least preﬁxpoint of DT , if it exists. Unfortunately, many 
simple and natural AEL theories have no model in this semantics. An example is {¬Kp ⇔ q} for which several preﬁxpoints 
of  DT exist  but  no  least  one.  Here,  Moore’s  semantics  makes  sense.  The  unique  expansion  {{q}, {p, q}} captures  the  idea 
that there is no objective information about  p, hence  p is unknown; therefore, q holds.

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

67

Also Konolige [26] attempted to reﬁne Moore’s semantics. He called expansions weakly grounded and proposed alternative 
deﬁnitions  for  so  called  moderately grounded and  strongly grounded expansions.  Intuitively,  a  possible  world  structure  is 
moderately  grounded  if  all  the  information  it  contains  can  be  derived  from  T using  only  ignorance  statements  from  Q . 
Thus,  Q is moderately grounded if all knowledge in  Q follows from T augmented with all statements of the form ¬K ϕ
such that  Q (cid:10)|(cid:24) K ϕ. Konolige proved that moderate grounded expansions are exactly the minimal ﬁxpoints of DT . However, 
he pointed out that even moderately grounded expansions can give rise to ungrounded reasoning. He illustrated this with 
the following example.

Example 7.2. Consider the following theory

T = {¬Kp ⇒ q, Kp ⇒ p}.

This theory has two moderately grounded possible world structures, namely  Q 1 = {{p}, {p, q}} and  Q 2 = {{q}, {q, p}}.  Q 1 is 
the possible world structure in which  p is known (Kp, ¬K ¬p) and q is not known (¬Kq, ¬K ¬q).

Again, Konolige argued that  Q 1 from Example 7.2 should not be grounded. Indeed, in  Q 1, the knowledge of  p is self-

supported. The intended model here is  Q 2 = {{q}, {q, p}}.

This motivated him to propose the strengthened notion of strongly grounded expansion. The disadvantage of this notion, 

as recognised by Konolige, is that it is only deﬁned for theories in a normal form where every sentence is of the form

K α ∧ ¬K β1 ∧ · · · ∧ ¬K βn ⇒ γ ,

where α, γ and the βi are objective. Furthermore, whether or not a possible world structure is strongly grounded depends 
on which transformation to the normal form is used. In other words, strong groundedness is syntactically deﬁned and may 
hold for one theory and not for an equivalent theory.

Example 7.3. Consider theories T1 = {p} and T2 = {K p ⇒ p, ¬Kp ⇒ p}. These theories are equivalent in the modal logic S5. 
However, {{p}} is a strongly grounded expansion of T1, while it is not a strongly grounded expansion of T2.

We now investigate how the algebraical concept of grounded ﬁxpoint translates to the setting of AEL and how it relates 

to the above ideas.

Deﬁnition 7.4 (Unfounded set of impossible worlds). Let T be an AEL theory and  Q a possible world structure. A non-empty 
set U of worlds is an unfounded set of impossible worlds of  Q if U ∩ Q = ∅ and for all  I ∈ U : (Q ∪ U ), I |(cid:24) T .

If Q admits such a U , it contains unsupported knowledge. In particular, the knowledge that the worlds in U are impossi-
ble is unsupported, since if we weaken Q by accepting U as possible worlds, then none of the worlds of U can be dismissed 
as impossible. All of them satisfy T in the revised belief state  Q ∪ U . The desired property that an agent’s knowledge will 
satisfy is thus that  Q does not admit such a U .

Deﬁnition 7.5 (Grounded expansion). Let T be an AEL theory. A possible world structure  Q is grounded for T if  Q does not 
admit an unfounded set of impossible worlds.

A possible world structure  Q is a grounded expansion if it is an expansion and grounded.

As it turns out, this notion is again equivalent with the algebraical notion of groundedness.

Proposition 7.6. A possible world structure Q is grounded for T if and only if Q is (strictly) grounded for DT in the lattice (cid:8)W(cid:3), ≤k (cid:9).

(cid:23) (cid:4) DT (Q

(cid:23) (cid:5) Q such  that 
Proof. The  deﬁnition  can  be  rephrased  by  focussing  on  Q
and ⊆ = ≥k in the lattice 
Q
(cid:8)W(cid:3), ≤k (cid:9).  Then  Deﬁnition 7.5 equals  the  deﬁnition  of  a  strictly  grounded  lattice  element.  Furthermore,  Proposition 3.5
guarantees that the notion of strict groundedness coincides with groundedness in powerset lattices. (cid:2)

(cid:23)) ∪ Q . Then the proposition follows immediately from the fact that (cid:5) is <k, ∪ is 

(cid:23) = Q ∪ U .  Q is  grounded  if  there  is  no  Q

(cid:2)

The  intuitions  expressed  above  correspond  closely  to  those  written  down  by  Konolige  [26].  On  all  the  examples  he 
gave, groundedness as we deﬁned it, achieves the desired result. Furthermore, since grounded ﬁxpoints are always minimal 
in  ≤k ,  our  notion  of  groundedness  is  indeed  stronger  than  the  notion  of  moderate  groundedness.  We  show  below  (in 
Corollary 7.10)  that  our  notion  of  groundedness  is  slightly  weaker  than  strong  groundedness.  Furthermore,  groundedness 
is  deﬁned  for  every  AEL  theory  (not  just  for  a  given  normal  form)  and  it  is  deﬁned  purely  semantically:  two  equivalent 
theories have the same grounded expansions.

68

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

Example 7.7. Consider the following autoepistemic theory:

T = {p, ¬Kp ⇒ q, Kq ⇒ q}.

The intended possible world structure is clear here: p follows from T using the ﬁrst sentence, hence p is known. The second 
sentence cannot be used to derive q, since Kp holds. Furthermore, the last sentence cannot be used to derive q since it ﬁrst 
requires  Kq.  This  theory  has  two  autoepistemic  expansions,  namely  Q 1 = {{p}, {p, q}} (which  corresponds  to  knowing  p, 
and not knowing whether q holds or not) and  Q 2 = {{p, q}} (knowing both  p and q). The ﬁrst one is grounded, while the 
second is not (it is not even a minimal ﬁxpoint since  Q 1 ≤k Q 2). Indeed, if we remove the knowledge that q holds from  Q 2
(i.e., we turn the previously impossible world {p} into a possible world by adding it to  Q 2), then {p} remains possible; that 
is, the belief that {p} is impossible is not derived anymore. Hence  Q 2 is not grounded.

7.1.  Groundedness of the AFT family of semantics for AEL

As we saw, the problem of ungrounded expansions remained unsolved for several years. A new take at it was obtained 

when DMT applied AFT to AEL. We explain this approach.

The bilattice of W(cid:3) consists of pairs (P , C) of possible worlds. Intuitively, such pairs approximate possible world struc-
tures  Q such that C ⊆ Q ⊆ P , i.e.,  P ≤k Q ≤k C : therefore, C is to be understood as a set of certainly possible worlds and  P
as a set of possibly possible worlds.

For  such  pairs,  the  standard  3- and  4-valued  Kleene  truth  valuation  of  propositional  logic  can  be  extended  to  a  truth 

function ϕ(P ,C),I by adding the following rules for modal formulas:

• K ϕ(P ,C),I = t if for all  I
• K ϕ(P ,C),I = f if for some  I
• Otherwise,  K ϕ(P ,C),I = u.

(cid:23) ∈ P , ϕ(P ,C),I

(cid:23) = t.

(cid:23) ∈ C , ϕ(P ,C),I

(cid:23) = f.

That  is,  ϕ is  known  in  (P , C) if  it  holds  in  all  possibly  possible  worlds,  it  is  not  known  if  does  not  hold  in  at  least  one 
certainly possible world. Otherwise, it cannot be determined if ϕ is known.

This truth valuation induces a bilattice operator  AT that maps pairs (P , C) to (P

(cid:23) = {I | T (P ,C),I = t} and
(cid:23) = {I | T (P ,C),I (cid:10)= f}

C

P

(cid:23), C

(cid:23)) where

Intuitively, the derived certainly possible worlds are those in which T evaluates to true, and the derived possibly possible 
worlds are those in which T does not evaluate to false.

DMT  showed  that  AT is  an  approximator  of  DT .  Hence,  it  induces  a  class  of  existing  and  new  semantics  for  AEL: 
Moore’s expansion semantics (supported ﬁxpoints), Kripke–Kleene expansion semantics [9] (Kripke–Kleene ﬁxpoints), stable 
extension semantics (stable ﬁxpoints) and well-founded extension semantics (well-founded ﬁxpoints) [11]. The latter two 
were new semantics induced by AFT. As a corollary of Theorem 4.6 and Proposition 4.3, we obtain the following analysis of 
groundedness.

Corollary 7.8. Stable and two-valued well-founded extensions of T are grounded (in the sense of Deﬁnition 7.5). If the well-founded 
extension is two-valued, it is the unique stable extension and the unique grounded expansion. If the Kripke–Kleene expansion is two-
valued, it is the well-founded extension, the unique expansion, the unique stable extension and it is grounded.

For the AEL theory {Kp ⇒ p}, the possible world structure {∅, {p}} is the well-founded and the unique stable extension. 

It is also the unique grounded expansion.

An example of an AEL theory with a grounded expansion that is not a stable extension is {Kp ⇒ p, ¬Kp ⇒ p}. Its unique 

grounded expansion is {{p}} but it has no stable extensions and the well-founded extension is three-valued.

7.2.  Default logic

Similar to McDermott and Doyle [32], Reiter [36] proposed to implement defaults “most  P ’s are  Q ’s” by their defeasible 
inference rule “If x is known to be a  P and it is consistent to believe that it is a  Q , then (infer that) x is a  Q ”. Note that, 
through  the  standard  duality  of  modal  logic,  the  second  condition  is  equivalent  to  “it  is  not  known  that  x is  not  a  Q ”. 
A default logic theory consists of sentences of propositional calculus and default expressions of the form:

α : Mβ1, . . . , Mβn
γ

where  α, β1, . . . , βn, γ are  expressions  of  propositional  logic.  The  informal  semantics  of  such  an  expression  is  “if  α is 
known, and it is consistent to believe β1, . . . , and βn, then γ holds”. For this logic, Reiter developed his extension semantics 

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

69

(see below). It soon became clear that Reiter’s extension semantics had some exquisite features. For example, consider the 
following default theory:
(cid:5)

(cid:4)

p :
p

It has one extension, namely the theory Thobj({∅, {p}}). Clearly, in this example default logic avoids the ungrounded model 
that the related AEL theory {Kp ⇒ p} has. The sort of ungrounded models that existed for AEL were never discovered in DL.
There is an obvious correspondence on the informal level between default expressions and AEL formulas. This connection 
was explicated by Konolige [26] who proposed to translate a default theory T to the AEL theory Kon(T ) consisting of AEL 
formulas:

K α ∧ ¬K ¬β1 ∧ · · · ∧ ¬K ¬βn ⇒ γ

(cid:16)

(cid:17)

p:
p

is a counterexample, as it translates to the AEL theory {Kp ⇒ p}
However Kon is not equivalence preserving. Indeed, 
which  under  Moore’s  expansion  semantics  is  not  equivalent.  In  fact,  Gottlob [23] showed  that  no  modular  translations 
exist  from  DL  to  AEL  (but  non-modular  transformations  exist).  For  a  while,  it  was  believed  that  AEL  and  DL  were  quite 
different logics. Later, DMT [11] showed that, similar as for AEL, also with a default theory T it is possible to associate an 
approximator  AT . This induced again the family of AFT semantics for DL which, just like for AEL, included several existing 
and  some  new  semantics  for  DL:  weak  extensions  [30] (supported  ﬁxpoints),  Kripke–Kleene  extensions  (Kripke–Kleene 
ﬁxpoints), Reiter’s extensions [36] (stable ﬁxpoints) and well-founded extension semantics [3] (well-founded ﬁxpoint). Only 
Kripke–Kleene extensions were a new semantics induced by AFT.

Interestingly, it then appeared that  AT = AKon(T ) for every default logic theory T . Thus, a default theory and Konolige’s 
(modular) translation to AEL have identical approximators. Therefore, they induce the same family of semantics. For exam-
ple, the extensions of a default theory correspond to the stable extensions of its AEL translation. DMT [13] argued that the 
different semantics of AEL and DL induced by AFT correspond to different dialects of autoepistemic reasoning. The mismatch 
found between AEL and DL was due to the fact that Reiter’s and Moore’s semantics formalised different dialects of autoepis-
temic reasoning. However, Konolige’s translation is correct on a deeper level: it preserves equivalence under every dialect 
of autoepistemic reasoning!

The above exposition not only tells the story of the link between AEL and DL but also provides the formal material for 
an analysis of groundedness in the context of DL. Deﬁnition 7.5 also deﬁnes groundedness in DL and using the fact that AFT 
characterises all main semantics of DL we obtain the following corollary of Theorem 4.6 and Proposition 4.3.

Corollary 7.9. Reiter’s extensions are grounded. If the well-founded extension of a DL theory is two-valued then it is the unique exten-
sion and the unique grounded weak extension. If the Kripke–Kleene extension of a DL theory is two-valued then it is grounded (and 
also the well-founded extension, the unique weak extension, the unique Reiter extension).

An example of a DL theory that has no Reiter extensions but has a grounded weak extension is:

(cid:4)

p :
p

,

: M¬p
p

(cid:5)

,

which corresponds to the AEL theory {Kp ⇒ p, ¬Kp ⇒ p}. Its unique grounded weak extension is Thobj({{p}}).

To end the discussion of groundedness in AEL and DL, we return to AEL and the strongly grounded expansions deﬁned 

by Konolige. He deﬁned them for AEL theories consisting of formulas in the following canonical form:

K α ∧ ¬K ¬β1 ∧ · · · ∧ ¬K ¬βn ⇒ γ

Such formulas are exactly the AEL formulas in the range of Kon. Hence, every AEL theory in this canonical form is Kon(T )
for some DL theory T . Konolige showed that the strongly grounded expansions of Kon(T ) are exactly the Reiter extensions 
of T . Combining this result with the previous corollary yields the following.

Corollary 7.10. If Q is a strongly grounded AEL expansion of T , then Q is a grounded expansion of T .

8.  Conclusion

The  concept  of  groundedness  is  widespread  in  various  logic  and  knowledge  representation  domains.  In  this  paper,  we 
formalised  this  as  a  property  of  ﬁxpoints  of  a  lattice  operator.  In  a  ﬁrst  step,  we  analysed  grounded  ﬁxpoints  and  their 
relation to other notions of ﬁxpoints, in particular minimal ﬁxpoints and the different sorts of ﬁxpoints classiﬁed in approx-
imation ﬁxpoint theory. The main results here are: given an operator  O and an approximator  A of  O , all  A-stable ﬁxpoints 
are grounded for  O and all grounded ﬁxpoints of  O are minimal ﬁxpoints approximated by the  A-well-founded ﬁxpoint.

We then investigated groundedness in logic programming, abstract argumentation frameworks, autoepistemic logic and 
default  logic.  In  each  of  these  ﬁelds,  the  concept  of  groundedness  had  appeared  before,  although  not  always  under  the 

70

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

same  name.  We  showed  links  with  the  notion  of  unfounded  set  in  logic  programming,  with  groundedness  in  Dung’s  ar-
gumentation  frameworks  and  various  notions  of  groundedness  in  autoepistemic  logic  and  default  logic.  In  each  logic,  we 
investigated  groundedness  of  the  existing  semantics  and  the  new  semantics  induced  by  grounded  ﬁxpoints.  For  example, 
in the context of argumentation frameworks, we discovered that grounded ﬁxpoints recover two existing semantics. In the 
more  general  abstract  dialectical  frameworks,  grounded  ﬁxpoint  yield  a  new  semantics  with  a  clear  informal  semantics: 
a ﬁxpoint is grounded if it contains no self-supporting arguments. In autoepistemic logic and default logic, groundedness 
captures intuitions written down by Konolige.

In summary, the main contributions of the presented work are: we presented a generic formalisation of the concept of 
groundedness, an analysis of groundedness of existing semantics in a range of logics, and last but not least, the deﬁnition 
of the new semantics for operator based logics induced by grounded ﬁxpoints. In comparison with approximation ﬁxpoint 
theory, grounded ﬁxpoints are deﬁned directly in terms of the original lattice operator and do not require the invention of 
an approximator. Grounded ﬁxpoint semantics is compact, intuitive and applicable to all operator based logics. Moreover, it 
is easily extensible. When adding new language constructs, it suﬃces to extend the operator for them.

Acknowledgements

We  would  like  to  thank  the  anonymous  reviewers,  Maurice  Bruynooghe  and  Hannes  Strass  for  their  feedback  on  this 
work.  This  work  was  supported  by  the  KU  Leuven  under  project  GOA  13/010  and  by  the  Research  Foundation  Flanders
(FWO-Vlaanderen) under projects G.0489.10, G.0357.12 and G.0922.13.

References

[1] S. Abiteboul, V. Vianu, Datalog extensions for database queries and updates, J. Comput. Syst. Sci. 43 (1) (1991) 62–124, http://dx.doi.org/10.1016/

0022-0000(91)90032-Z.

[2] C. Antic, T. Eiter, M. Fink, Hex semantics via approximation ﬁxpoint theory, in: P. Cabalar, T.C. Son (Eds.), LPNMR, in: Lect. Notes Comput. Sci., vol. 8148, 

Springer, 2013, pp. 102–115, http://dx.doi.org/10.1007/978-3-642-40564-8_11.

[3] C. Baral, V. Subrahmanian, Dualities between alternative semantics for logic programming and nonmonotonic reasoning, J. Autom. Reason. 10 (3) (1993) 

399–420, http://dx.doi.org/10.1007/BF00881799.

[4] Y. Bi, J.-H. You, Z. Feng, A generalization of approximation ﬁxpoint theory and application, in: R. Kontchakov, M.-L. Mugnier (Eds.), Web Reasoning and 
Rule Systems, in: Lect. Notes Comput. Sci., vol. 8741, Springer International Publishing, 2014, pp. 45–59, http://dx.doi.org/10.1007/978-3-319-11113-1_4.
[5] B.  Bogaerts,  J.  Vennekens,  M.  Denecker,  Grounded  ﬁxpoints,  in:  B.  Bonet,  S.  Koenig  (Eds.),  AAAI  2015,  Proceedings  of  the  Twenty-Ninth  AAAI 
Conference  on  Artiﬁcial  Intelligence,  Austin,  Texas,  USA,  January  25–29,  2015,  AAAI  Press,  2015,  pp. 1453–1459,  https://lirias.kuleuven.be/handle/
123456789/471671.

[6] B. Bogaerts, J. Vennekens, M. Denecker, J. Van den Bussche, FO(C): a knowledge representation language of causality, Theory Pract. Log. Program. 

14 (4–5 Online Suppl.) (2014) 60–69, https://lirias.kuleuven.be/handle/123456789/459436.

[7] G. Brewka, H. Strass, S. Ellmauthaler, J.P. Wallner, S. Woltran, Abstract dialectical frameworks revisited, in: F. Rossi (Ed.), IJCAI 2013, Proceedings 
of  the  23rd  International  Joint  Conference  on  Artiﬁcial  Intelligence,  Beijing,  China,  August  3–9,  2013,  IJCAI/AAAI,  2013,  http://www.aaai.org/ocs/
index.php/IJCAI/IJCAI13/paper/view/6551.

[8] G. Brewka, S. Woltran, Abstract dialectical frameworks, in: F. Lin, U. Sattler, M. Truszczy ´nski (Eds.), Principles of Knowledge Representation and Rea-
soning: Proceedings of the Twelfth International Conference, KR 2010, Toronto, Ontario, Canada, May 9–13, 2010, AAAI Press, 2010, pp. 102–111, 
http://aaai.org/ocs/index.php/KR/KR2010/paper/view/1294.

[9] M. Denecker, V. Marek, M. Truszczy ´nski, Fixpoint 3-valued semantics for autoepistemic logic, in: AAAI’98, Madison, Wisconsin, July 26–30, 1998, MIT 

Press, 1998, pp. 840–845, http://www.aaai.org/Papers/AAAI/1998/AAAI98-119.pdf.

[10] M. Denecker, V. Marek, M. Truszczy ´nski, Approximations, stable operators, well-founded ﬁxpoints and applications in nonmonotonic reasoning, in: 
J. Minker (Ed.), Logic-Based Artiﬁcial Intelligence, in: Springer International Series in Engineering and Computer Science, vol. 597, Springer US, 2000, 
pp. 127–144, http://dx.doi.org/10.1007/978-1-4615-1567-8_6.

[11] M.  Denecker,  V.  Marek,  M.  Truszczy ´nski,  Uniform  semantic  treatment  of  default  and  autoepistemic  logics,  Artif.  Intell.  143 (1)  (2003)  79–122, 

http://dx.doi.org/10.1016/S0004-3702(02)00293-X.

[12] M. Denecker, V. Marek, M. Truszczy ´nski, Ultimate approximation and its application in nonmonotonic knowledge representation systems, Inf. Comput. 

192 (1) (Jul. 2004) 84–121, https://lirias.kuleuven.be/handle/123456789/124562.

[13] M.  Denecker,  V.  Marek,  M.  Truszczy ´nski,  Reiter’s  default  logic  is  a  logic  of  autoepistemic  reasoning  and  a  good  one,  too,  in:  G.  Brewka,  V. 
Marek,  M.  Truszczy ´nski  (Eds.),  Nonmonotonic  Reasoning  –  Essays  Celebrating  Its  30th  Anniversary,  College  Publications,  2011,  pp. 111–144, 
http://arxiv.org/abs/1108.3278.

[14] M. Denecker, E. Ternovska, A logic of nonmonotone inductive deﬁnitions, ACM Trans. Comput. Log. 9 (2) (Apr. 2008) 14:1–14:52, http://dx.doi.org/

10.1145/1342991.1342998.

[15] M. Denecker, J. Vennekens, Well-founded semantics and the algebraic theory of non-monotone inductive deﬁnitions, in: C. Baral, G. Brewka, J.S. Schlipf 

(Eds.), LPNMR, in: Lect. Notes Comput. Sci., vol. 4483, Springer, 2007, pp. 84–96, http://dx.doi.org/10.1007/978-3-540-72200-7_9.

[16] M. Denecker, J. Vennekens, The well-founded semantics is the principle of inductive deﬁnition, revisited, in: C. Baral, G. De Giacomo, T. Eiter (Eds.), 
Principles of Knowledge Representation and Reasoning: Proceedings of the Fourteenth International Conference, KR 2014, July 20–24, 2014, Vienna, 
Austria, AAAI Press, 2014, pp. 22–31, https://lirias.kuleuven.be/handle/123456789/448356.

[17] P.M. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games, Artif. 

Intell. 77 (2) (1995) 321–357, http://dx.doi.org/10.1016/0004-3702(94)00041-X.

[18] W. Faber, G. Pfeifer, N. Leone, Semantics and complexity of recursive aggregates in answer set programming, Artif. Intell. 175 (1) (2011) 278–298, 

http://dx.doi.org/10.1016/j.artint.2010.04.002.

[19] P. Ferraris, Answer sets for propositional theories, in: Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning 

(LPNMR), 2005, pp. 119–131, http://dx.doi.org/10.1007/11546207_10.

[20] M.  Fitting,  Fixpoint  semantics  for  logic  programming  —  a  survey,  Theor.  Comput.  Sci.  278 (1–2)  (2002)  25–51,  http://dx.doi.org/10.1016/S0304-

3975(00)00330-3.

[21] M.  Gelfond,  V.  Lifschitz,  The  stable  model  semantics  for  logic  programming,  in:  R.A.  Kowalski,  K.A.  Bowen  (Eds.),  ICLP/SLP,  MIT  Press,  1988, 

pp. 1070–1080, http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.6050.

[22] M.  Gelfond,  Y.  Zhang,  Vicious  circle  principle  and  logic  programs  with  aggregates,  Theory  Pract.  Log.  Program.  14 (4–5)  (2014)  587–601,  http://

B. Bogaerts et al. / Artiﬁcial Intelligence 224 (2015) 51–71

71

dx.doi.org/10.1017/S1471068414000222.

[23] G. Gottlob, Translating default logic into standard autoepistemic logic, J. ACM 42 (4) (1995) 711–740, http://dx.doi.org/10.1145/210332.210334.
[24] J.Y. Halpern, Y. Moses, Towards a theory of knowledge and ignorance: preliminary report, in: K.R. Apt (Ed.), Logics and Models of Concurrent Systems, 

in: NATO ASI Ser., vol. 13, Springer, Berlin, Heidelberg, 1985, pp. 459–476, http://dx.doi.org/10.1007/978-3-642-82453-1_16.

[25] S.C. Kleene, On notation for ordinal numbers, J. Symb. Log. 3 (4) (1938) 150–155, http://www.jstor.org/stable/2267778.
[26] K. Konolige, On the relation between default and autoepistemic logic, Artif. Intell. 35 (1988) 343–382, http://dx.doi.org/10.1016/0004-3702(88)90021-5.
[27] H.J. Levesque, All I know: a study in autoepistemic logic, Artif. Intell. 42 (2–3) (1990) 263–309, http://dx.doi.org/10.1016/0004-3702(90)90056-6.
[28] V. Lifschitz, Twelve deﬁnitions of a stable model, in: M. García de la Banda, E. Pontelli (Eds.), ICLP, in: Lect. Notes Comput. Sci., vol. 5366, Springer, 

2008, pp. 37–51, http://dx.doi.org/10.1007/978-3-540-89982-2_8.

[29] V. Marek, I. Niemelä, M. Truszczy ´nski, Logic programs with monotone abstract constraint atoms, Theory Pract. Log. Program. 8 (2) (2008) 167–199, 

http://dx.doi.org/10.1017/S147106840700302X.

[30] V. Marek, M. Truszczynski, Relating autoepistemic and default logics, in: R.J. Brachman, H.J. Levesque, R. Reiter (Eds.), Proceedings of the 1st Inter-
national Conference on Principles of Knowledge Representation and Reasoning, KR’89, Toronto, Canada, May 15–18, 1989, Morgan Kaufmann, 1989, 
pp. 276–288, http://dl.acm.org/citation.cfm?id=112950.

[31] D. McDermott, Nonmonotonic logic II: nonmonotonic modal theories, J. ACM 29 (1) (1982) 33–57, http://dl.acm.org/citation.cfm?id=322293.
[32] D. McDermott, J. Doyle, Nonmonotonic logic I, Artif. Intell. 13 (1–2) (1980) 41–72, http://hdl.handle.net/1721.1/6303.
[33] R.C. Moore, Possible-world semantics for autoepistemic logic, in: M. Ginsberg (Ed.), Proceedings of the Workshop on Non-Monotonic Reasoning, 1984, 
pp. 344–354,  reprinted  in:  M.  Ginsberg  (Ed.),  Readings  on  Nonmonotonic  Reasoning,  Morgan  Kaufmann,  1990,  pp. 137–142,  http://www.sri.com/
sites/default/ﬁles/uploads/publications/pdf/616.pdf.

[34] R.C. Moore, Semantical considerations on nonmonotonic logic, Artif. Intell. 25 (1) (1985) 75–94, http://dx.doi.org/10.1016/0004-3702(85)90042-6.
[35] N. Pelov, M. Denecker, M. Bruynooghe, Well-founded and stable semantics of logic programs with aggregates, Theory Pract. Log. Program. 7 (3) (2007) 

301–353, http://dx.doi.org/10.1017/S1471068406002973.

[36] R. Reiter, A logic for default reasoning, Artif. Intell. 13 (1–2) (1980) 81–132, http://dx.doi.org/10.1016/0004-3702(80)90014-4.
[37] T.C. Son, E. Pontelli, I. Elkabani, An unfolding-based semantics for logic programming with aggregates, 2006, http://arxiv.org/abs/cs/0605038.
[38] H.  Strass,  Approximating  operators  and  semantics  for  abstract  dialectical  frameworks,  Artif.  Intell.  205  (2013)  39–70,  http://dx.doi.org/10.1016/

j.artint.2013.09.004.

[39] H. Strass, J.P. Wallner, Analyzing the computational complexity of abstract dialectical frameworks via approximation ﬁxpoint theory, in: C. Baral, G. 
De Giacomo, T. Eiter (Eds.), Principles of Knowledge Representation and Reasoning: Proceedings of the Fourteenth International Conference, KR 2014, 
Vienna, Austria, July 20–24, 2014, AAAI Press, 2014, pp. 101–110, http://www.aaai.org/ocs/index.php/KR/KR14/paper/view/7917.

[40] M.H. van Emden, R.A. Kowalski, The semantics of predicate logic as a programming language, J. ACM 23 (4) (1976) 733–742, http://dx.doi.org/10.1145/

321978.321991.

[41] A. Van Gelder, K.A. Ross, J.S. Schlipf, The well-founded semantics for general logic programs, J. ACM 38 (3) (1991) 620–650, http://dx.doi.org/10.1145/

116825.116838.

[42] J. Vennekens, D. Gilis, M. Denecker, Splitting an operator: algebraic modularity results for logics with ﬁxpoint semantics, ACM Trans. Comput. Log. 7 (4) 

(2006) 765–797, http://dx.doi.org/10.1145/1182613.1189735.

