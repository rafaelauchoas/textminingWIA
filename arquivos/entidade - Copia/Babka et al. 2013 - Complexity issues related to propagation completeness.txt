Artiﬁcial Intelligence 203 (2013) 19–34

Contents lists available at ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Complexity issues related to propagation completeness

Martin Babka, Tomáš Balyo, Ondˇrej ˇCepek, Štefan Gurský, Petr Kuˇcera
Václav Vlˇcek

∗

,

Department of Theoretical Computer Science and Mathematical Logic, Faculty of Mathematics and Physics, Charles University in Prague,
Malostranské nám. 25, 118 00 Praha 1, Czech Republic

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 10 July 2012
Received in revised form 14 June 2013
Accepted 30 July 2013
Available online 7 August 2013

Keywords:
Boolean functions
Satisﬁability
Knowledge compilation
Empowering implicates
Unit propagation
Propagation completeness

Knowledge compilation is a process of adding more information to a knowledge base in
order to make it easier to deduce facts from the compiled base than from the original one.
One type of knowledge compilation occurs when the knowledge in question is represented
by a Boolean formula in conjunctive normal form (CNF). The goal of knowledge compilation
in this case is to add clauses to the input CNF until a logically equivalent propagation
complete CNF is obtained. A CNF is called propagation complete if after any partial
substitution of truth values all logically entailed literals can be inferred from the resulting
CNF formula by unit propagation. The key to this type of knowledge compilation is the
ability to generate so-called empowering clauses. A clause is empowering for a CNF if it is
an implicate and for some partial substitution of truth values it enlarges the set of entailed
literals inferable by unit propagation.
In this paper we study several complexity issues related to empowering implicates,
propagation completeness, and its relation to resolution proofs. We show several results:
(a) given a CNF and a clause it is co-NP complete to decide whether the clause is an
empowering implicate of the CNF, (b) given a CNF it is NP-complete to decide whether
there exists an empowering implicate for it and thus it is co-NP complete to decide
whether a CNF is propagation complete, and (c) there exist CNFs to which an exponential
number of clauses must be added to make them propagation complete.

© 2013 Published by Elsevier B.V.

1. Introduction

One of the most studied problems in computer science, both theoretical and applied, is the satisﬁability problem for CNF
formulas (SAT). The diﬃculty of SAT depends on the class of CNF formulas to which the input formula belongs. There are
various techniques and algorithms for SAT for different classes of CNF formulas ranging from linear algorithms for Horn,
quadratic (2-CNF) and SLUR formulas [1,2] to the very complex variants of the exponential DPLL [3,4] and CDCL [5–8]
procedures implemented in general purpose SAT solvers. Even the most complicated SAT solvers usually perform a task
called unit propagation [3]. The goal of unit propagation is to infer as many logically entailed literals as possible from a
partial truth assignment and the input formula. Although in general unit propagation is not a complete method (it does not
infer all logically entailed literals), it is complete for the class of propagation complete (PC) CNF formulas [9].

PC formulas play an important role also in constraint programming, or more speciﬁcally, in CNF encodings of global
constraints. There is a strong connection between propagation completeness of the CNF encoding and domain consistency

* Corresponding author. Tel.: +420 221 914 138; fax: +420 221 914 323.

E-mail addresses: babkys@gmail.com (M. Babka), biotomas@gmail.com (T. Balyo), ondrej.cepek@mff.cuni.cz (O. ˇCepek), stevko@mail.ru (Š. Gurský),

kucerap@ktiml.mff.cuni.cz (P. Kuˇcera), vlcek@ktiml.mff.cuni.cz (V. Vlˇcek).

0004-3702/$ – see front matter © 2013 Published by Elsevier B.V.
http://dx.doi.org/10.1016/j.artint.2013.07.006

20

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

of the encoded constraint [10,11]. It has been studied for several concrete global constraints such as the AllDifferent
constraint [12], the Sequence constraint [13], Regular, Among, and Generalized Sequence [10], or theGrammar con-
straints [14].

Some SAT solvers try to avoid searching in the state subspaces with no solution by learning from conﬂicts, i.e. by
performing conﬂict driven clause learning (CDCL) [5–8], the name CDCL is also used for the complete algorithm solving SAT
problem. It is useful to learn clauses (called empowering implicates [9,15]) that allow unit propagation to infer more logically
entailed literals after such a clause is added to the CNF formula than it was possible to infer before the addition. Therefore,
to speed up the CDCL SAT solver search for a satisfying assignment, it is often very useful to learn (generate) empowering
implicates and add them to the input CNF formula. Let us mention that today’s most successful SAT solvers for real-world
applications are the ones using CDCL procedure.

This process of adding empowering implicates to a CNF formula can be viewed as a special type of knowledge com-
pilation where both the input and the output representation of the knowledge is a CNF formula. In general, knowledge
compilation is a process of adding more information to a given knowledge representation in order to make it computa-
tionally easier to infer facts from the compiled representation [16,17], or a process of transforming a given knowledge
representation into another knowledge representation which is more tractable with respect to fact deduction, such as trans-
forming a CNF into a BDD [18]. Nevertheless, in this paper we are interested only in the very limited case of knowledge
compilation that rests in adding empowering implicates to a CNF.

It has been shown in [9], along with other properties of PC formulas, that a formula ϕ is PC if and only if there is
no empowering implicate for ϕ. However, several complexity issues directly connected to propagation completeness and
empowering implicates are left open in [9]. A short list of such questions is the following:

1. Given a CNF formula ϕ and a clause C , what is the complexity of deciding whether C is an empowering implicate

for ϕ?

2. Given a CNF formula ϕ that is not PC, how diﬃcult is it to generate an empowering implicate for ϕ by resolution,

where the “level of diﬃculty” is measured by the length of the resolution proof?

3. Given a CNF formula ϕ, what is the complexity of deciding whether there exists an empowering implicate for ϕ?
4. Given a CNF formula ϕ that is not PC, how many empowering implicates is it necessary to add to ϕ in order to make

it PC?

In this paper we tackle all of the above listed problems. After reviewing basic deﬁnitions and notation in Section 2, we
derive several simple properties of empowering implicates in Section 3. We address the following four questions as follows:

1. In Section 3 we show that the ﬁrst problem is co-NP complete. This is not a very diﬃcult result, however, to the best

of our knowledge, it was not stated in the related literature yet.

2. In Section 4 we tackle the second problem. We prove that for a non-PC CNF formula with s occurrences of literals
there always exists a resolution proof of length O (s) of some empowering implicate. On the other hand, we construct
examples of CNF formulas where a resolution proof of length Ω(s) is needed for any empowering implicate, which
means that Θ(s) is an asymptotically tight bound for this problem. It is important to note that the upper bound
result does not require the derived empowering implicate to be prime. We show (by a simple modiﬁcation of results
concerning refutation proofs [19,20]) that there exist CNF formulas such that in order to derive any prime empowering
implicate of such CNF a resolution proof of an exponential length is needed.

3. Section 5 contains the main results of this paper which are connected to the third problem. It was proved in [9] that
deciding about an existence of an empowering implicate is in (cid:5) p
2 . Using the results from Section 4 we strengthen this
result by showing that the problem belongs to (cid:5) p
= NP. Given the equivalence between propagation completeness and
1
non-existence of empowering implicates proved in [9], this immediately implies that testing propagation completeness
belongs to co-NP. Then we proceed with the hardness proof for this problem. We present a reduction from a well-known
NP-complete 3-dimensional matching problem which proves that deciding for a CNF formula whether there exists an
empowering implicate for it is NP-hard (and thus testing propagation completeness is coNP-hard).

4. The fourth question is answered in Section 5 as well by showing that there exist CNF formulas where an exponential
number (both with respect to the number of variables and the number of clauses) of empowering implicates must be
added in order to arrive at a PC formula. This strengthens the superpolynomial bound which follows from a combination
of results in [9] and [21] using a superpolynomial lower bound for certain monotone circuits from [22]. The connection
is discussed in detail in Section 2.5.

We close the paper by giving few concluding remarks in Section 6.

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

21

2. Deﬁnitions

2.1. Basic deﬁnitions

A Boolean function of n variables is a mapping f : {0, 1}n → {0, 1}. We say that a Boolean function f

is satisﬁable if there
is a vector (cid:4)x ∈ {0, 1}n such that f ((cid:4)x) = 1. A literal is either a variable (x, called positive literal) or its negation (¬x or x, called
negative literal). A clause is a disjunction of literals. We assume that no clause contains both positive and negative literals
of the same variable. A clause which contains just one literal is called a unit clause. Formula ϕ is in conjunctive normal form
(CNF) if it is a conjunction of clauses (we also say that ϕ is a CNF formula). We shall often treat a clause as a set of its
literals and a CNF formula as a set of its clauses. It is a well-known fact that every Boolean function can be represented by
a CNF formula (see e.g. [23]). A CNF formula ϕ is called a Horn formula if every clause in ϕ has at most one positive literal.
A quadratic CNF formula (also called 2-CNF formula) is a CNF formula where each clause contains at most two literals. If two
CNF formulas ϕ1 and ϕ2 deﬁne the same function, we say that they are equivalent and we denote this fact with ϕ1 ≡ ϕ2.

Clause C is called an implicate of f if every assignment (cid:4)x ∈ {0, 1}n satisfying f (i.e. f ((cid:4)x) = 1) also satisﬁes C (i.e. C((cid:4)x) = 1).
We use notation f |(cid:7) C to denote that C is an implicate of
f . We also say that C is logically entailed by f . Since every
CNF formula ϕ represents a function, we shall often use ϕ |(cid:7) C to denote the fact that C is an implicate of the function
represented by ϕ. We shall also say that C is an implicate of ϕ or that it is logically entailed by ϕ. A clause is a special case
of a CNF formula and thus for two clauses C1 and C2 we can also use C1 |(cid:7) C2. This is possible only if literals contained
in C1 are also contained in C2. In this case we say that clause C1 subsumes clause C2. C is a prime implicate of a function f
(cid:8)
of f subsuming C . We say that CNF formula ϕ is prime if it
if it is an implicate of f and there is no other implicate C
contains only prime implicates. A special case of prime CNF formula is the canonical CNF formula of f (also called a canonical
representation of f ), which consists of all the prime implicates of f .

Given a CNF formula ϕ and a clause C we deﬁne IsImplicate(ϕ, C ) as the problem of deciding whether C is an implicate
of ϕ. It is well known that this problem is co-NP complete (co-SAT is a special case of IsImplicate(ϕ, C ) in which C is an
empty clause).

2.2. Resolution

We say that two clauses have a conﬂict in variable x if there is a positive occurrence of x in one clause and a negative
occurrence in the other. Two clauses C1 = ( (cid:2)C1 ∨ x) and C2 = ( (cid:2)C2 ∨ x) are resolvable over x if (cid:2)C1 and (cid:2)C2 do not have a conﬂict
in any variable. We write R(C1, C2) = (cid:2)C1 ∨ (cid:2)C2 and this disjunction is called a resolvent of the parent clauses C1 and C2.
A resolution in which one of the parent clauses is a unit clause is called a unit resolution. A resolution in which the parent
clauses have no common literal is called a non-merge resolution, otherwise it is a merge resolution.

Let ϕ be a CNF formula representing a Boolean function f , we say that C can be derived from ϕ by a series of resolutions
if there is a sequence of clauses C1, . . . , Ck = C such that every Ci , 1 (cid:2) i (cid:2) k, either belongs to ϕ, or Ci = R(C j1 , C j2 ), where
j1, j2 < i. Such a series of resolutions is also called a resolution proof of C from ϕ. Resolution proof of a contradiction (i.e. an
empty clause ⊥) from formula ϕ is also called a resolution refutation. A resolution proof in which every resolution is unit
is called a unit resolution proof , a unit resolution proof of a contradiction ⊥ from ϕ is called a unit refutation and if such a
proof exists for ϕ, then this formula is called unit refutable. This fact is denoted by ϕ (cid:11)1 ⊥. If a unit clause (literal) x can be
derived by unit resolutions then we write ϕ (cid:11)1 x. Thelength of a resolution proof is the number of clauses in the sequence.
It is a well known fact that for any Boolean function the resolvent of two implicates is again an implicate (see e.g. [24]).
Another well known fact is that every prime implicate of f can be derived from ϕ by a series of resolutions (see e.g. [24]).

2.3. Unit propagation and refutation

Unit propagation is an iterative procedure which in each step selects a unit clause (a literal), removes each clause con-
taining this literal, and removes the complementary literal from the remaining clauses (i.e. satisﬁes the selected literal). This
process iterates until an empty clause (a contradiction) is derived or there is no unit clause in the formula. Unit propa-
gation can be performed in linear time [25]. It is a well-known fact that if ϕ (cid:11)1 x (where x is an arbitrary literal), then
unit propagation on ϕ satisﬁes x or derives contradiction. On the other hand, if x is satisﬁed during unit propagation, then
ϕ (cid:11)1 x.

We say that a literal x is logically entailed from ϕ by a partial assignment l1, . . . , lk (by setting literals l1, . . . , lk to true)
if any assignment that extends l1, . . . , lk and satisﬁes ϕ sets x to true. Note that this is equivalent to ϕ ∧ l1 ∧ · · · ∧ lk |(cid:7) x.
Clearly, literals that form unit clauses in ϕ are logically entailed from ϕ. Also note that given clause C = l1 ∨ l2 ∨ · · · ∨ lk,
formula ϕ ∧
¬l j is by De Morgan’s laws equivalent to ϕ ∧ ¬C . In the subsequent text we shall use these notations
interchangeably.

(cid:3)
k
j=1

A clause C is called 1-provable with respect to a CNF formula ϕ, if ϕ ∧ ¬C (cid:11)1 ⊥. A clause C is thus 1-provable if it is
an implicate of C and the fact that C is an implicate can be proved using unit propagation. The notion of 1-provability
was introduced in [15]. A formula ϕ is called unit refutation complete if every implicate C of ϕ is 1-provable with respect
to ϕ. The notion of unit refutation completeness was introduced in [26] and later inspired the deﬁnition of propagation
completeness in [9], which we give in the following subsection.

22

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

2.4. Propagation completeness and empowerement

Deﬁnition 2.1 (Propagation Completeness (PC) [9]). We call a CNF formula ϕ propagation complete (PC) if for any partial
assignment l1, . . . , lk and any literal d the following holds. If d is logically entailed from ϕ by l1, . . . , lk, then d can be
derived from ϕ by unit propagation after ﬁxing values of l1, . . . , lk, i.e., if ϕ ∧ l1 ∧ · · · ∧ lk |(cid:7) d, then ϕ ∧ l1 ∧ · · · ∧ lk (cid:11)1 d. The
class PC is the class of all PC formulas.

Deﬁnition 2.2 (Empowering implicate [15,9], Absorption [27,9]). A clause C = l1 ∨ l2 ∨ l3 ∨ · · · ∨ lk is called an empowering
implicate for a formula ϕ if it contains a literal li called an empowered literal such that ϕ ∧
¬l j (cid:2)1 ⊥ and ϕ ∧
(cid:3)

j∈1...k, j(cid:13)=i

(cid:3)

(cid:3)

j∈1...k, j(cid:13)=i

¬l j |(cid:7) li but ϕ ∧

j∈1...k, j(cid:13)=i

¬l j (cid:2)1 li . An implicate C is called absorbed by ϕ if it has no empowered literal.

It is known that a formula is propagation complete if and only if it has no empowering implicates [9]. Thus, any formula

can be extended to a propagation complete one by repeatedly adding empowering implicates.

The notion of empowering clauses is closely related to CDCL SAT solvers, see [15] and [26]. It is important to note that
each asserting clause is empowering as observed in [15]. Since most CDCL SAT solvers learn only asserting clauses the
notion of propagation completeness is important also in the context of CDCL SAT solvers.

Example 2.3. Consider the following formula

ϕ = (a ∨ b ∨ x) ∧ (a ∨ c ∨ ¬x).

Formula ϕ is not propagation complete, because ϕ ∧ ¬b ∧ ¬c |(cid:7) a but ϕ ∧ ¬b ∧ ¬c (cid:2)1 a. Indeed, by falsifying b and c we get
(a ∨ x) ∧ (a ∨ ¬x) and thus literal a can be obtained by resolution, but not by unit propagation.

It follows that (a ∨ b ∨ c) is an empowering implicate for ϕ with a being its empowered literal. By adding this implicate

to ϕ we get a propagation complete formula

ϕ(cid:8) = (a ∨ b ∨ x) ∧ (a ∨ c ∨ ¬x) ∧ (a ∨ b ∨ c).

The fact that ϕ(cid:8)
is propagation complete follows from the fact that it consists of all prime implicates of ϕ. Consider for
example a non-prime implicate C = (a ∨ b ∨ c ∨ x), this implicate is absorbed by ϕ(cid:8)
because by falsifying any three literals
from C we either get an unsatisﬁable formula (such as if a, b, and x are falsiﬁed) or we obtain the remaining literal by unit
propagation (such as if a, c, and x are falsiﬁed, b is obtained from the ﬁrst clause of ϕ(cid:8)
). We can observe that in fact, C is
already absorbed by ϕ.

2.5. Relation of propagation completeness to constraint propagation

Propagation complete formulas play an important role in constraint propagation (for general reading on constraint
propagation see Chapter 3 of [28]), where the notion appeared implicitly in earlier literature [10–14,29] concentrated
on CNF encodings of constraints both in general [10,11], and for particular constraints (the sequence constraint [13], the
grammar constraint [14], the Regular, the Among, and the Generalized sequence constraints [11], or the AllDifferent con-
straint [12]). A general idea which appeared in all these papers is to take a constraint C , encode it using a CNF and then use
unit propagation to maintain some kind of domain consistency (e.g. generalized arc consistency (GAC) in [10], or (relational)
(i, j)-consistency in [29]). In general, these encodings are polynomial in table representation of a constraint, however in the
case of a particular global constraint we can sometimes use its special properties to get a CNF representation of polynomial
size with respect to the arity of a constraint with suitable properties, such as in [11] in case of the Regular constraint, the
Among constraint, or the Generalized sequence constraint. On the other hand in some cases this is not possible as it is
shown in [12] for the AllDifferent constraint.

The idea of using unit propagation to maintain domain consistencies was formalized in [12], let us recall some of the
results and the notation from [12] here. A constraint C is deﬁned over a set of variables X = { X1, . . . , Xn}, each of which has
a ﬁnite domain D( Xi). An assignment to a variable Xi is a mapping of Xi to a value j ∈ D( Xi), called a literal and written
Xi = j. D(X) denotes the set of literals, i.e. D(X) = { Xi = j | Xi ∈ X ∧ j ∈ D( Xi)}. P(D(X)) then denotes the set of all possible
sets of literals. A constraint C is deﬁned over a set of variables denoted as scope(C) ⊆ X (scope of C ) and it allows a subset
of the possible assignments to the variables in scope(C).

Following [12,30,28] a propagator for a constraint C is an algorithm which takes as input the domains of variables in
scope(C) and returns restrictions of these domains. Formally a propagator for a constraint C can be deﬁned as follows
(deﬁnition is taken from [12], where they followed [30], see also Chapter 3 of [28]):

Deﬁnition 2.4. (See Deﬁnition 1 in [12].) A propagator f
f : P(D(X)) (cid:15)→ P(D(X)), such that f
and idempotent, i.e. f (D(X)) = f ( f (D(X))). If f detects that C has no solutions under D(X) then f (D(X)) = ∅.

for a constraint C is a polynomial time computable function
(cid:8)(X)) ⊆ f (D(X)), contracting, i.e.
f (D(X)) ⊆ D(X),

(cid:8)(X) ⊆ D(X) ⇒ f (D

is monotone, i.e. D

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

23

We say that a propagator detects dis-entailment if f (D(X)) = ∅ whenever C has no solution. A propagator enforces domain
consistency (DC) when Xi = j ∈ f (D(X)) implies that there exists a solution of C that contains Xi = j. Other consistencies
(such as GAC [10] which is equivalent to DC, or (i, j)-consistency [29]) can be considered as well, we mention domain
consistency here because later on we shall recall the results of [12] on domain consistency propagators.

Let us recall a deﬁnition of a CNF decomposition of a propagator as it appeared in [12]. Before that let us recall a general
way how a constraint satisfaction program (CSP) variables with multiple valued domains are usually encoded within a CNF.
Given a variable Xi ∈ X with domain D( Xi) we encode it with a set of boolean variables xi, j , Xi ∈ X,
j ∈ D( Xi) such that
Xi (cid:13)= j ⇔ xi, j . The property that a CSP variable Xi has at most one value is enforced by the set of AMO (i.e. at most one)
j, k ∈ D( Xi), k (cid:13)= j, and the property that it has at least one value is enforced by the ALO (i.e. at
clauses (xi, j ∨ xi,k) for all
j∈D( Xi ) xi, j . Following [12] we call the above described propositional representation of D(( X)) (i.e. set of
least one) clause
all AMO and ALO clauses over all CSP variables) a direct encoding and denote it as Dsat(X).

(cid:4)

Deﬁnition 2.5. (See Deﬁnition 4 in [12].) A CNF decomposition of a propagation algorithm (propagator) f P is a formula in
CNF ϕP over variables x ∪ y such that

• The input variables x are the propositional representation Dsat(X) of D(X) and y is a set of auxiliary variables whose size

is polynomial in |x|.

• xi, j is set to 0 by a unit propagation if and only if Xi = j /∈ f P (D(X)).
• Unit propagation on ϕP produces the empty clause when f P (D(X)) = ∅.

Before further discussion, let us look at an example from [12].

Example 2.6. (See Example 1 in [12].) Consider a Table constraint over the variables X1, X2 with D( X1) = D( X2) = {a, b}
and the satisfying assignments: {(cid:20)a, a(cid:21), (cid:20)b, b(cid:21), (cid:20)a, b(cid:21)}. Using encoding introduced in [10] we can decompose a Table constraint
into the following CNF ϕT :

ϕT = (x1a ∨ y1 ∨ y3) ∧ (x2a ∨ y1) ∧ ( y1 ∨ x1a) ∧ ( y1 ∨ x2a)

∧ (x1b ∨ y2) ∧ (x2b ∨ y2 ∨ y3) ∧ ( y2 ∨ x1b) ∧ ( y2 ∨ x2b)
∧ ( y3 ∨ x1a) ∧ ( y3 ∨ x2b) ∧ ( y1 ∨ y2 ∨ y3).

Here y = { y1, y2, y3} consists of auxiliary variables corresponding to the three possible solutions to the Table constraint ( y1
corresponds to (cid:20)a, a(cid:21), y2 to (cid:20)b, b(cid:21), and y3 to (cid:20)a, b(cid:21)). Suppose the value a is removed from the domain of X1. The assignment
x1a = 0 forces the variable y1 to 0, which in turn causes the variable x2a to 0, removing the value a from the domain of X2
as well.

Now let us generalize the ideas presented in the above example. Let us consider a constraint C , its consistency propagator

f P , and a CNF decomposition of f P via a CNF ϕP .

• By deﬁnition, if f P detects dis-entailment, then f P (D(X)) = ∅ whenever C restricted to D(X) admits no solution. Passing
D(X) to f P corresponds to setting all values xi, j = 0 for Xi = j /∈ D(X). The third condition of Deﬁnition 2.5 thus requires
that after this partial assignment ϕP is not only unsatisﬁable but this fact can be detected by unit propagation. In
particular we require that for any D(X):

(cid:5)

ϕP ∧

i, j: Xi = j /∈ D(X)

¬xi, j |(cid:7) ⊥ ⇔ ϕP ∧

(cid:5)

¬xi, j (cid:11)1 ⊥.

i, j: Xi = j /∈ D(X)

What we in fact require here is that ϕP is unit refutation complete with respect to the partial assignments to the input
variables x. Although we admit here only assignments to 0, the direct encoding clauses Dsat(X) allow us to use 1 as
well (assigning xi, j = 1 forces xi,k = 0 for any k (cid:13)= j, k ∈ D( Xi) by unit propagation on Dsat(X)).

• If f P is a domain consistency propagator then there is no solution to C containing Xi = j if and only if Xi = j /∈ f (D(X)).
Using the second condition from Deﬁnition 2.5 it corresponds to the fact that xi, j is a unit implicate of ϕP under partial
assignment given by D(X) if and only if xi, j is forced to 0 by unit propagation on ϕP under this partial assignment. In
particular we require that for any D(X) and any xi, j :

(cid:5)

ϕP ∧

i(cid:8), j(cid:8): Xi

(cid:8) = j(cid:8) /∈ D(X)

¬xi(cid:8), j(cid:8) |(cid:7) ¬xi, j ⇔ ϕP ∧

(cid:5)

i(cid:8), j(cid:8): Xi

(cid:8) = j(cid:8) /∈ D(X)

¬xi(cid:8), j(cid:8) (cid:11)1 ¬xi, j.

What we in fact require here is the fact that ϕP is propagation complete with respect to partial assignments and literals
on the input variables in x. In the above equation it is enough to consider only negative literals xi, j due to presence of
clauses of direct encoding Dsat(X).

24

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

The author of [10] suggests that a canonical CNF decomposition (i.e. CNF consisting of all prime implicates) is suﬃcient
to encode both dis-entailment detecting propagator and domain consistency propagator. The above discussion shows that a
shorter CNF is suﬃcient, in particular unit refutation completeness is suﬃcient for detecting dis-entailment and propagation
completeness is suﬃcient for domain consistency propagator. This can be naturally generalized to other consistencies such
as (i, j)-consistency [29].

It was shown in [21] that a polynomial sized decomposition of a consistency propagator f P exists if and only if it can

by computed by a monotone circuit of polynomial size. This result was used to derive the following corollary:

Corollary 2.7. (See Corollary 4 in [21].) There is no polynomial sized CNF decomposition of any AllDifferent domain consistency
propagator.

On the other hand we can get a polynomial sized CNF encoding of the AllDifferent constraint. Using such an encoding
and Corollary 2.7 it follows that no propagation complete encoding of the AllDifferent constraint can have polynomial
size. There are thus formulas such that any equivalent propagation complete formula has superpolynomial size. Let us
have a more detailed look at the proof of Corollary 2.7 in [21]. It was shown in [31] that AllDifferent constraint has a
solution if and only if the corresponding bipartite value graph has a perfect matching. From the aformentioned connection to
monotone circuits proved in [21] it follows that based on an AllDifferent domain consistency propagator we can construct
a monotone circuit that computes whether a bipartite graph has a perfect matching and such a circuit has a polynomial size
with respect to the domain consistency propagator we start with. The proof is ﬁnished using an older result of Razborov [22]
according to which the size of monotone circuit computing whether there is a perfect matching in a bipartite graph G on
n vertices has size at least nΩ(log n), which is a superpolynomial (in some literature called quasi-polynomial) but not an
exponential bound. In Section 5 we strengthen the result of Corollary 2.7 for propagation complete formulas by showing
that there are in fact formulas to which an exponential number of implicates have to be added in order to make them
propagation complete.

3. Properties of empowering implicates

Let us start this section with a discussion on connection between unit refutation completeness introduced in [26] and
propagation completeness introduced in [9]. First let us recall that a formula ϕ is unit refutation complete if for every
implicate C of ϕ we have that ϕ ∧ ¬C (cid:11)1 ⊥. This means that the fact that C is an implicate of ϕ can be proved using
just unit resolution. It is not hard to see that if a formula ϕ is propagation complete, then it is unit refutation complete as
¬li (cid:11)1 lk which implies
well. Indeed, if C = (l1 ∨ · · · ∨ lk) is an implicate of ϕ, then either ϕ ∧
ϕ ∧
¬li (cid:11)1 ⊥. On the other hand, it is not true that every unit refutation complete formula is also propagation complete.
Consider the following formula ϕ:

¬li (cid:11)1 ⊥, or ϕ ∧

(cid:3)
k
i=1

k−1
i=1

k−1
i=1

(cid:3)

(cid:3)

ϕ = (x ∨ a ∨ b ∨ c) ∧ (x ∨ a ∨ b ∨ d).

This is a prime CNF which has only one more prime implicate C = (a ∨ b ∨ c ∨ d) produced by resolving the two clauses in
ϕ. We can observe that ϕ is unit refutation complete. If we add negation of C to ϕ, then unit resolution of x and x gives us
the empty clause. However ϕ is not propagation complete and C is an empowering implicate of ϕ with empowered literal
a (or b). Indeed, if we set b, c, and d to false in ϕ, we get CNF (x ∨ a) ∧ (x ∨ a) from which it is not possible to derive a just
using unit resolution.

It follows from the above discussion that the set of propagation complete CNFs is a proper subset of unit refutation
complete CNFs. The aim of this section is to recall several results about the class of unit refutation complete CNFs from [26]
and observe that some of these results are in fact true already for the set of propagation complete formulas.

We shall start with showing that adding a literal to a non-empowering implicate cannot make it empowering with

respect to any of the original literals.

Lemma 3.1. Let ϕ be a CNF formula and let C = l1 ∨ · · · ∨ lk be an implicate of ϕ which is not empowering. Let A be a clause and let
li ∈ C be an arbitrary literal. Then C ∨ A is not empowering implicate of ϕ with empowered literal li .

(cid:3)

Proof. Let us assume without loss of generality that i = k (if not, then we can achieve this by renaming the variables).
By deﬁnition, the fact that C is not empowering with empowered literal lk implies that either ϕ ∧
¬l j (cid:11)1 ⊥, or
k−1
ϕ ∧
¬l j
is a subformula of
j=1
ϕ ∧
¬a, what we can derive by unit propagation from the former formula, can be derived from latter one
¬a (cid:11)1 lk. This means that by deﬁnition,
¬a (cid:11)1 ⊥ or ϕ ∧
as well. Thus we have that ϕ ∧
C ∨ A is not empowering implicate with empowered literal lk. (cid:2)

¬l j (cid:11)1 lk because C is an implicate of ϕ and thus ϕ ∧
¬l j ∧

¬l j |(cid:7) lk. Since ϕ ∧

k−1
j=1
k−1
j=1

¬l j ∧

¬l j ∧

k−1
j=1

k−1
j=1

k−1
j=1

k−1
j=1

a∈ A

a∈ A

a∈ A

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

Note that in the previous proposition we cannot argue that A ∨ C is not empowering because it could be empowering
with an empowered literal from A, e.g. if A would itself be an empowering clause. That is why we consider only literals

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

25

in C . Using Lemma 3.1, we can easily show that among empowering implicates the prime implicates are the only ones we
need to consider.

Lemma 3.2. Let ϕ be a nonempty satisﬁable CNF formula (i.e. it has at least one nonempty clause) and let C be an empowering
implicate for ϕ. Then any implicate C

of ϕ subsuming C is empowering for ϕ (this in particular includes the case when C

is prime).

(cid:8)

(cid:8)

(cid:8)

be an arbitrary implicate subsuming C and let us assume that C

(cid:8) (cid:13)= C . If C
(cid:8)
Proof. Let C
⊥ and thus C cannot be empowering with respect to a literal a, which is not in C
empowering with respect to a literal in C

as well due to Lemma 3.1. (cid:2)

(cid:8)

(cid:8) (cid:11)1
is not empowering, then ϕ ∧ ¬C
. On the other hand, C cannot be

(cid:8)

As an easy corollary we now get that a canonical CNF formula is always propagation complete, although this can be

easily deduced from properties of canonical CNFs as well.

Now let us consider the problem of generating an empowering implicate for a given CNF formula. A natural method to
consider is to generate an empowering implicate by the resolution procedure. In [26] it is shown that non-merge resolution
cannot produce an empowering implicate with respect to unit refutation completeness. In case of propagation completeness
the same is true. It follows from discussion at the beginning of Section 5 in [9]. We shall formulate this proposition as a
lemma to be able to reference to it later.

Lemma 3.3. Let ϕ be a CNF formula and let C be produced from ϕ by a series of non-merge resolutions. Then C is not an empowering
implicate of ϕ.

Keeping in mind that a canonical formula is propagation complete, it follows that a CNF formula ϕ satisfying that every
prime implicate of ϕ is either present in it or it can be derived from ϕ by a series of non-merge resolutions is always
propagation complete. This property was already shown in form of Theorem 1 in [26] for unit refutation completeness and
it is an easy corollary of arguments about non-merge resolution in [9] (here stated as Lemma 3.3) that it is true also for PC
formulas.

Since PC formulas allow easy inference, it is interesting to investigate classes which are contained in the class of PC CNF
formulas. One such example is given by the following theorem which shows the desired property for the class of prime
quadratic CNF formulas.

Theorem 3.4. If ϕ is a prime quadratic CNF formula, then it is propagation complete.

Proof. If ϕ is not satisﬁable, then the proposition of the theorem is trivial. Let us assume that ϕ is a satisﬁable prime
quadratic CNF formula.

By Lemma 3.2 it is enough to consider prime implicates as candidates for empowering implicates. Because ϕ is a prime
CNF formula, it must contain all the unit prime implicates. Hence, if any other prime implicate should be added to ϕ to
make it propagation complete, it must be a quadratic clause which is produced by resolving two other quadratic clauses. It
is a simple observation that these resolutions have to be non-merge. Thus by Lemma 3.3 we have that ϕ must already be
propagation complete. (cid:2)

The following lemma shows that the primeness assumption in the statement of Theorem 3.4 is necessary.

Lemma 3.5. There is a (non-prime) quadratic CNF formula which is not PC.

Proof. Let us consider the following CNF formula:

ϕ = (a ∨ b) ∧ (a ∨ b).

ϕ is clearly a quadratic CNF formula. On the other hand, ϕ is not PC because ϕ |(cid:7) a, but ϕ (cid:2)1 a. (cid:2)

Now let us turn our attention to the complexity of testing if a given clause C is an empowering implicate of a CNF
formula ϕ. We shall denote this problem as IsEmpowering(ϕ, C ). Note that co-NP completeness of IsEmpowering(ϕ, C )
comes as no surprise since it is in essence very similar to another co-NP complete problem IsImplicate(ϕ, C ). The hard part
of checking whether given clause C is an empowering implicate of ϕ is in fact checking whether C is an implicate of ϕ at
all. Thus the co-NP completeness of IsEmpowering(ϕ, C ) is a direct consequence of co-NP completeness of IsImplicate(ϕ, C ).
The proof of the following theorem only formalizes this idea.

Theorem 3.6. The problem IsEmpowering(ϕ, C ) is co-NP complete.

26

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

Proof. To show that a problem is in co-NP it suﬃces to have for every negative instance of the problem a polynomially
veriﬁable certiﬁcate which allows to verify that the answer is no. We can distinguish two cases when a pair (ϕ, C) forms a
negative instance of IsEmpowering. In the ﬁrst case C is not even an implicate of ϕ and the desired certiﬁcate is then an
assignment of truth values to the variables which satisﬁes ϕ and falsiﬁes C . The second case is when C is an implicate of ϕ
but not an empowering one. In this case an empty certiﬁcate is good enough because one needs no additional information
to be able to check in polynomial time that no literal in C is empowered. This can be done by running unit propagation
and checking for every literal (cid:6) in C that ϕ ∧

¬(cid:6)(cid:8) (cid:11)1 ⊥ or ϕ ∧
For the co-NP hardness we reduce the co-NP complete problem IsImplicate to IsEmpowering. Let (ϕ, C) be an arbitrary
instance of IsImplicate. We start by a simple preprocessing step in which we run unit propagation to test whether ϕ ∧
(cid:3)
¬(cid:6) (cid:11)1 ⊥. If yes, then C is an implicate of ϕ (in fact a 1-provable implicate), i.e. (ϕ, C) is a positive instance of
IsImplicate, and the reduction algorithm can terminate by answering yes. Note that this case includes the situation when C
(cid:8)) of IsEmpowering by ϕ(cid:8) = ϕ ∧ (x ∨ y) ∧ (x ∨ y)
is a clause in ϕ. If no, i.e. if ϕ ∧
(cid:8) = C ∨ x, where x and y are two new variables not appearing in (ϕ, C). We shall show that C is an implicate of ϕ if
and C
and only if C
with x as the empowered literal.

¬(cid:6) (cid:2)1 ⊥, we deﬁne an instance (ϕ(cid:8), C

is an empowering implicate of ϕ(cid:8)

¬(cid:6)(cid:8) (cid:11)1 (cid:6).

(cid:6)(cid:8)∈C, (cid:6)(cid:8)(cid:13)=(cid:6)

(cid:6)(cid:8)∈C, (cid:6)(cid:8)(cid:13)=(cid:6)

(cid:6)∈C

(cid:6)∈C

(cid:3)

(cid:3)

(cid:3)

(cid:8)

Let C be an implicate of ϕ. C is clearly an implicate of ϕ(cid:8)
is empowering with x as the empowered literal recall that ϕ ∧
propagation does nothing on (x ∨ y) ∧ (x ∨ y) and neither x nor y appear in ϕ and C .

(cid:8)
¬(cid:6) (cid:2)1 ⊥ and thus ϕ(cid:8) ∧

, and hence also C

(cid:6)∈C

(cid:3)

is an implicate of ϕ(cid:8)
(cid:3)

(cid:6)∈C

(cid:8)
. To see that C
¬(cid:6) (cid:2)1 x because unit

Let C

(cid:8)

be an empowering implicate of ϕ(cid:8)

with x as the empowered literal. The fact that C

that any assignment that falsiﬁes C
and satisﬁes (x ∨ y) ∧ (x ∨ y) regardless of the value of y. Thus, to falsify ϕ(cid:8)
which falsiﬁes C must also falsify ϕ, which means that C is an implicate of ϕ. (cid:2)

(cid:8)

must also falsify ϕ(cid:8)

. However, any assignment which falsiﬁes C

(cid:8)

is an implicate of ϕ(cid:8)

means
sets x to 1, falsiﬁes C
it must falsify ϕ. Therefore any assignment

(cid:8)

Let us recall the notion of a tied chain in a CNF formula used in [26] in case of unit refutation completeness.

Deﬁnition 3.7. (See [26], introduced in [32].) A tied chain in a CNF formula ϕ is a sequence of triples (x1, C1, y1), (x2, C2, y2),
. . . , (xn, Cn, yn) such that:

• For 1 (cid:2) i (cid:2) n, Ci is a clause in ϕ and xi, yi are two different literals in Ci (i.e. xi (cid:13)= yi ).
• For 1 (cid:2) i (cid:2) n − 1, we have that yi and xi+1 are complementary literal (called link literals of the chain).
• x1 = yn is called the tied literal of the chain.

For example CNF formula ϕ = (p ∨ q ∨ r) ∧ (r ∨ s) ∧ (s ∨ p) contains a tied chain with p as tied literal. In [32] it is shown
that the absence of tied chains is a suﬃcient condition for unit refutation completeness. The following lemma was shown
in [26] as Lemma 6.

Lemma 3.8. (See Lemma 6 of [26].) Let C be an implicate of a CNF formula ϕ which is produced from ϕ by a resolution proof D in
which the last resolution made is a merge resolution. Let us assume that the parent clauses of C in D are C1 and C2, where M denotes
the set of common literals in C1 and C2. M (cid:13)= ∅ since the last step in D is a merge resolution and every literal of M is contained in C .
Then ϕ contains, for each literal (cid:6) ∈ M, a tied chain T (cid:6) with (cid:6) as its tied literal. Furthermore, each link literal in T (cid:6) has a clause in D
which is produced from its parent clauses by resolution upon (cid:6).

It is argued in [26] that if there are no tied chains in a CNF formula ϕ, there can be no merge resolutions and thus the
formula ϕ has to be unit refutation complete. The same argument can be used for propagation completeness. We can argue
in the same way using Lemma 3.3 that absence of tied chains in a CNF formula ϕ implies that ϕ is propagation complete.
We shall use this property in proofs in the text and thus we shall formulate it as a lemma to be able to reference to it.

Lemma 3.9. If a CNF formula ϕ does not contain tied chains, then it is propagation complete.

4. Resolution derivations of empowering implicates

We have seen in Theorem 3.6 that it is hard to check whether a given clause C is an empowering implicate of a given
formula ϕ. The hard part of this test is to check whether C is in the set S of all implicates of ϕ. The core of the proof of
(cid:8) ⊆ S of all empowering implicates of ϕ does not make this test easier.
Theorem 3.6 shows that considering a smaller set S
We shall show now that the hard part of the test can be in some sense avoided by considering a suitable enlargement
of the tested clause. In particular, we shall show that if a clause C is an empowering implicate of a CNF formula ϕ, we can
(cid:8)
always extend C by adding suitable literals to obtain clause C
which is still empowering and moreover we can check that
is an implicate of ϕ simply by unit resolution. Let us recall that such a clause is called 1-provable (which is a notion
C
introduced in [15]).

(cid:8)

Proof of Theorem 4.2 is signiﬁcantly based on Proposition 2. The proposition is given in [15] and may be restated as

follows.

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

27

Proposition 4.1. (See Proposition 2 of [15].) Let ψ be an unsatisﬁable CNF such that ψ (cid:2)1 ⊥ and Π be its resolution refutation. Then
there exists a clause Cψ ∈ Π which is both empowering and 1-provable.

Let C be an empowering implicate of a formula ϕ which is not 1-provable. This means that if we falsify all the literals in
C and add them to ϕ, thus producing ψ = ϕ ∧ ¬C , then we get a contradiction which is not provable by unit resolution. By
using the previous proposition we show that we may add the clause C to the obtained clause Cψ to obtain a clause which
is both 1-provable and empowering.

The following Theorem 4.2 is a consequence of Proposition 4.1. For readers familiar with CDCL SAT solvers, the idea re-
mains the same as in the previous paragraph. By falsifying the literals in C any CDCL SAT solver must derive a contradiction.
We add the solver’s decisions to the input clause C , i.e. we add ¬C and the conjunction of literals corresponding to each
assigned variable to the input formula. After such an addition, we obtain the desired 1-provable and empowering clause.
As we shall show later in Proposition 4.3 we can even derive such a clause C using only linear number of resolution steps
with respect to the number of literal occurrences in ϕ.

Theorem 4.2. Assume that C is an empowering implicate of a formula ϕ which is not 1-provable. Then there is an implicate C
such that C ⊂ C

and C is both 1-provable and empowering.

(cid:8)

(cid:8)

of ϕ

Proof. Let ψ = ϕ ∧ ¬C and Π be a resolution refutation of ψ . Because C is not 1-provable for ϕ it holds that ψ (cid:2)1 ⊥. Then
according to the proposition there is a clause Cψ ∈ Π which is both empowering and 1-provable with respect to ψ . We
consider a clause Cϕ = Cψ ∨ C .

First, Cϕ is 1-provable for ϕ because Cψ is 1-provable for ψ and all the possibly required literals were added to Cϕ . It

follows from the following obvious chain of equivalence:

Cψ is 1-provable for ψ ⇔ ψ ∧ ¬Cψ (cid:11)1 ⊥ ⇔ ϕ ∧ ¬C ∧ ¬Cψ (cid:11)1 ⊥

⇔ ϕ ∧ ¬Cϕ (cid:11)1 ⊥ ⇔ Cϕ is 1-provable for ϕ.

(1)

Let (cid:6) be an empowering literal of Cψ for ψ . Then (cid:6) is trivially also an empowered literal of Cϕ for ϕ. The required
properties for unit resolution and entailment come from the deﬁnitions of Cϕ and ψ using similar chain of equivalences as
in 1.

Thus Cϕ is the desired clause since it is both empowering and 1-provable with respect to ϕ. (cid:2)

The following proposition shows that not only can we ﬁnd a 1-provable and empowering implicate as in Theorem 4.2
but we can also derive some empowering implicate by a resolution derivation of linear length with respect to the number
of literals occurring in given formula. The proof is based on ideas presented in [15] and [33–35] in the context of CDCL SAT
solvers. More detailed discussion about this connection is presented just after the proof of the proposition.

Proposition 4.3. Let ϕ be a formula on n variables which is not propagation complete and s be the size of the CNF representation of ϕ
(i.e. s is the total number of occurrences of literals in ϕ). Then there is an empowering implicate C of ϕ which can be derived by a series
of resolutions of length at most s from ϕ.

Proof. From Theorem 4.2 it follows that there is an empowering 1-provable implicate Cϕ of ϕ with an empowered literal (cid:6).
Let ϕ(cid:8)
denote the formula which originates from ϕ after adding unit clauses formed by negated literals from Cϕ , i.e.
ϕ(cid:8) ≡ ϕ ∧ ¬Cϕ . Since Cϕ is 1-provable it follows that ϕ(cid:8) (cid:11)1 ⊥, i.e. we can derive contradiction from ϕ(cid:8)
by using only unit
resolution.

Due to the nature of unit resolutions, we can assume that the unit refutation proceeds in two phases.

1. In the ﬁrst phase we take all unit clauses from ¬Cϕ and perform unit resolutions only over the variables from Cϕ .
2. In the second phase we continue with refutation proof without using unit clauses from ¬Cϕ and we do not resolve

over variables from Cϕ at all.

In case of unit resolutions if we already have some unit clauses it does not matter in which order we make unit resolutions
over them. Thus we may assume without loss of generality that unit clauses from ¬Cϕ are used ﬁrst. The ﬁrst phase thus
corresponds to performing partial assignment to variables of ϕ which falsiﬁes literals in Cϕ .

Let us now assume that D

= ⊥ is a unit refutation proof which proceeds in the above two phases. Since it is a
(cid:8)
unit refutation proof, it can be observed that m (cid:2) s. Let us assume that the ﬁrst phase is formed by clauses D
k(cid:8)−1
and the second phase is formed by clauses D
or
(cid:8)
it originates from two preceding clauses by unit resolution over variable from Cϕ . Similarly each clause among D
m
is either an original clause from ϕ or it originates from two preceding clauses by unit resolution over a variable which
is not in Cϕ . Observe that if the resolution proof is irredundant, i.e. no clause can be dropped from it, no clause among

(cid:8)
1, . . . , D
k(cid:8)−1 is therefore either a clause in ϕ(cid:8)
(cid:8)
k(cid:8) , . . . , D

(cid:8)
m. Each clause among D

(cid:8)
k(cid:8) , . . . , D

(cid:8)
1, . . . , D

(cid:8)
1, . . . , D

(cid:8)
m

(cid:8)

28

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

(cid:8)
k(cid:8) , . . . , D

D
remove a variable from Cϕ in the second phase.

(cid:8)
m contains a variable from Cϕ . This is because in the end we arrive at an empty clause and there is no way to

(cid:8)

Let us now consider the situation in which we do not proceed with the ﬁrst phase, in particular if we replace the ﬁrst
phase only with a list of corresponding clauses from ϕ. In this case the second phase can proceed as before (except that
unit resolution steps are replaced by general resolution steps) only now the input clauses of phase 2 may contain some
literals from Cϕ as these were not removed in missing phase 1. These literals propagate down to the end of the proof and
(cid:8) ⊆ Cϕ . Note that (cid:6) will be
⊥ now becomes a subclause of Cϕ . In this way we shall obtain a resolution proof of a clause C
because otherwise the original unit refutation would actually prove that ϕ ∧ ¬(Cϕ \ {(cid:6)}) (cid:11)1 ⊥ which would be
present in C
in contradiction with the fact that Cϕ is an empowering implicate with empowered literal (cid:6). Thus C
will be empowering
by Lemma 3.1.

Let us now formalize the above idea. If D
from ¬Cϕ or there is a clause D j ∈ ϕ, such that D
used in the second phase of the unit refutation proof, the latter is the case and then D
by falsifying all literals of Cϕ which appear in D j .
(cid:8)
k(cid:8) , . . . , D

(cid:8)
m then we shall deﬁne clause D j as follows. If D

(cid:8)
j is a clause among the clauses D

(cid:8)
1, . . . , D
(cid:8)
j originates from D j by falsifying some literals from Cϕ . If D

(cid:8)
k(cid:8)−1, then it is either a unit literal
(cid:8)
j is later
(cid:8)
j originates from some clause D j ∈ ϕ

(cid:8)

If D
(cid:8)
j

(cid:8)
j is among D
(cid:8)
a, D

= R(D

(cid:8)
b) where 1 (cid:2) a, b < j, then we deﬁne D j = R(Da, Db). Note that if D

if D
then the same is true about Da and Db. This is because if Da contains more literals than D
the same is true for Db and D

(cid:8)
b.

(cid:8)
(cid:8)
j is an original clause from ϕ, then D j = D
j ,
(cid:8)
(cid:8)
a and D
b were two resolvable clauses,
(cid:8)
a these literals are from Cϕ and

In the end we get a resolution derivation of length at most m (cid:2) s of clause C = Dm which is a subclause of Cϕ . As we
have already mentioned (cid:6) must be present in C . Otherwise we would get that it was not necessary to use (cid:6) to derive ⊥
from ϕ(cid:8)
which would be in contradiction with the fact that Cϕ is an empowering implicate. According to Lemma 3.1 C is
an empowering implicate. In particular, if C would not be empowering, then by Lemma 3.1 Cϕ would not be empowering
with empowered literal (cid:6). (cid:2)

It is also possible to prove Proposition 4.3 by analyzing a run of a CDCL SAT solver. Let us describe the sketch of such
proof, the precise deﬁnitions of the below mentioned properties can be found in [33–35]. Consider the situation during
the run of a CDCL SAT solver solving ϕ when the partial assignment satisﬁes ¬Cϕ . Clearly then unit propagation is able to
derive a conﬂict. By Proposition 3 of [34] each conﬂict clause can be derived by a trivial resolution derivation of length at
most s. From Proposition 2 of [33] it follows that each asserting clause is also empowering. Since for each conﬂict there is
at least one asserting clause, e.g. 1-UIP [35], then we have found an empowering clause with a short resolution proof from
ϕ.

As the example in the following proposition shows, the linear upper bound on the length of resolution derivation of an

empowering implicate is tight up to a multiplicative constant.

Theorem 4.4. For each n there is a formula on 2n + 1 variables with size O (n) such that it is not propagation complete, but resolution
derivation of length n is needed to ﬁnd an empowering implicate.

Proof. This is actually a very simple corollary to Lemma 3.9. It is enough to construct a tied chain of length n. The following
formula (for given n) contains such a chain:

ϕn = (z ∨ A1 ∨ a1) ∧ (a1 ∨ A2 ∨ a2) ∧ · · · ∧ (an−3 ∨ An−2 ∨ an−2)

∧ (an−2 ∨ An−1 ∨ an−1) ∧ (an−1 ∨ An ∨ z).

Clearly both the number of variables and the number of clauses are linear in n. First, let us observe that ( A1 ∨ A2 ∨ · · · ∨
An ∨ z) is an empowering implicate with empowered literal z. This is because by falsifying all literals A1, . . . , An we get
a quadratic formula which has z as a unit implicate, but unit resolution cannot derive this fact. Since the only tied chain
in ϕn is composed by all the n clauses in ϕn, byLemma 3.9 we need all these clauses in order to derive an empowering
implicate. (cid:2)

Note also that formula ϕn is anti-Horn (i.e. every clause contains at most one negative literal) and thus Theorem 4.4

holds also when restricted to anti-Horn or Horn formulas as we observe in the following corollary.

Corollary 4.5. For each n there is a Horn formula on 2n + 1 variables with n clauses that it is not propagation complete but resolution
derivation of length n is needed to ﬁnd an empowering implicate.

Proof. The formula ϕn in the previous theorem had at most one negative literal in each clause. Therefore, switching all
literals to their complement in ϕn creates a Horn CNF formula with the desired property. (cid:2)

The ﬁrst idea which comes to mind when trying to ﬁnd an empowering implicate of a CNF formula ϕ is to run resolution
until one such implicate is generated. Of course, if ϕ already is propagation complete, it might be necessary to ﬁnd all prime

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

29

implicates before we can claim ϕ is propagation complete. On the other hand, Proposition 4.3 suggests that in some cases,
we can ﬁnd an empowering implicate relatively quickly in this way. However, the obtained empowering implicate is not
guaranteed to be prime. So it is natural to ask what is the necessary length of resolution derivations of prime empowering
implicates. As the following observation shows, when seeking to ﬁnd a prime empowering implicate all the hardness results
about resolution refutations apply in this case.

Lemma 4.6. Let ϕ be a CNF formula and let x be a new variable not appearing in ϕ. Then ϕ |(cid:7) ⊥ if and only if ϕ (cid:11)1 ⊥ or x is the
only prime empowering implicate of (ϕ ∨ x). Moreover, if ϕ (cid:2)1 ⊥, then there is a one-to-one correspondence between the resolution
refutations of ϕ and resolution derivations of x from (ϕ ∨ x).

Proof. Let us denote ϕ(cid:8)
every clause.

the CNF formula equivalent to ϕ ∨ x. Note that ϕ(cid:8)

can be obtained from ϕ by adding literal x to

Let us at ﬁrst suppose that ϕ |(cid:7) ⊥. In this case ϕ(cid:8) ≡ x and thus x is the only prime implicate of ϕ(cid:8)

. Let us assume that x
. Let us now
(cid:8)
i with literal x removed. It is clear that D1, . . . , Dk is now a unit resolution refutation of ϕ and

k be a unit resolution derivation of x from ϕ(cid:8)

, thus ϕ(cid:8) (cid:11)1 x. Let D

(cid:8)
1, . . . , D

(cid:8)

is not an empowering implicate of ϕ(cid:8)
denote by D i the clause D
thus ϕ (cid:11)1 ⊥.

Now let us assume that ϕ (cid:11)1 ⊥ or x is the only prime empowering implicate of ϕ(cid:8)

the latter case observe that ϕ is equivalent to ϕ(cid:8)
Moreover, the resolution proof of x from ϕ(cid:8)

with x assigned to 0. Since x is an implicate of ϕ(cid:8)

immediately gives resolution proof of ⊥ from ϕ.

. In the former case trivially ϕ |(cid:7) ⊥. In
it implies that ϕ |(cid:7) ⊥.

The one-to-one correspondence is immediately seen from the above arguments. (cid:2)

Lemma 4.6 is an easy observation which shows that all results about complexity of resolution refutations of CNF formulas
can be repeated for resolution derivations of prime empowering implicates as well. There are many results that can be used
in this context, let us mention at least some of them. In [19] (and in many papers and books that followed) it was shown
that pigeon hole principle formulas on n(n + 1) variables and O (n3) clauses (PHPn) have minimal resolution refutation of
size cn for some c > 0. If a formula PHPn is used with Lemma 4.6, we get immediately that every resolution derivation of
the single prime empowering implicate x from (PHPn ∨ x) must have superpolynomial length as well. This is in contrast
with Proposition 4.3 in which we showed that for a formula which is not propagation complete there always exists some
empowering implicate that can be generated using only number of resolutions that is linear in the length of the formula
i.e. O (n4) for (PHPn ∨ x). Of course, in case of (PHPn ∨ x) such an implicate would not be prime.

Note that in [9] the formula (PHPn ∨ x) was used in Section 4.2 as an example of a formula in which we can gener-
ate superpolynomially many empowering implicates while the only meaningful empowering implicate is x. In this sense
Lemma 4.6 can be viewed as a simple generalization of their example, where by meaningful implicates we now consider
prime implicates.

The lower bound on the length of a resolution refutation of a PHPn formula is only superpolynomial with respect to the
length of the formula. Examples of formulas on Θ(n) variables consisting of Θ(n) clauses were given in [20] for which the
lower bound on the length of a minimal resolution refutation is truly exponential.

Although we used Lemma 4.6 for general resolution in our example, it is more general than that, it shows that in
fact any hardness result about resolution refutations can be used for similar results about resolution derivations of a prime
empowering implicate. Thus we can consider formulas which require exponential tree resolution refutations though shortest
general resolution refutations have only polynomial number of steps [36]. There are other resolution reﬁnements inbetween
tree and general resolution we can take into account as well [37]. Similarly, we can use results of [38] which show formulas
with resolution refutations requiring almost linear depth, it can be observed that these formulas are even Horn. There are
many other results about resolution refutations which we have omitted but all of them could be used for claims about
resolution derivations of prime empowering implicates as well.

5. Hardness of generating an empowering implicate

In this section we prove that testing whether a given CNF formula has an empowering implicate is an NP-complete

problem. We start by showing that it is in NP.

Lemma 5.1. The problem of testing whether a given CNF formula ϕ has an empowering implicate is in NP.

Proof. It follows from Theorem 4.2 that ϕ has an empowering implicate if and only if it has an empowering and 1-provable
implicate. Thus the certiﬁcate for ϕ having an empowering implicate is a clause C which is both empowering and 1-provable.
These properties can be checked in polynomial time using unit propagation. It follows that the problem is in NP. (cid:2)

Now we shall show that the problem is NP-hard by a reduction from 3D Matching (3DM), which is a well-known
NP-complete problem [39,40]. In 3DM we are given three pairwise disjoint sets X , Y , Z of the same size | X| = |Y | = | Z | = q
and a set of triples W ⊆ X × Y × Z . The question we seek to answer is whether W contains a matching of size q, i.e.

30

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

whether there is a subset M ⊆ W of size |M| = q such that each element of X , Y , and Z is contained in exactly one triple
in M (i.e. the triples in M are pairwise disjoint).

Next, we present a reduction of a 3DM problem into the problem of testing the existence of an empowering implicate.
The reduction is a slight modiﬁcation of the proof of coNP-hardness of recognizing whether a given CNF formula is an SLUR
formula [41]. Unfortunately, the reduction from [41] cannot be used directly and we have to modify it. This is because the
SLUR class coincides with the class of unit refutation complete formulas (see [42]), and the class of propagation complete
formulas forms a strict subclass of unit refutation formulas as we have argued at the beginning of Section 3. In [41] we have
associated a formula ϕW to an instance of 3DM for which it was true that it was SLUR (or unit refutation complete) if and
only if W contained a perfect matching. In case W does not contain a perfect matching ϕW is not unit refutation complete
and thus it is not propagation complete as well. Unfortunately, the opposite implication was not true for formula ϕW
constructed in [41], i.e. if W contains a perfect matching, then ϕW is unit refutation complete, but it still not propagation
complete. Thus we have to modify the original reduction in order to get the opposite implication as well.

Deﬁnition 5.2. With every instance X, Y , Z , W of 3DM we associate a CNF formula ϕW as follows. We assume that
X = {x1, . . . , xq}, Y = { y1, . . . , yq}, Z = {z1, . . . , zq}, and W = {E 1, . . . , E w } where w = |W |. We also assume that E j =
(x f ( j), y g( j), zh( j)) where f , g, and h are functions determining which elements of X , Y , and Z belong to E j (i.e. given j
with E j = [xi1 , yi2 , zi3
], function f returns the index of the x member of triple E j , thus f ( j) = i1, similarly g( j) = i2, and
h( j) = i3).

• For every i ∈ {1, . . . , q − 1} let us denote Ai = (ai ∨ ai+1) where a1, . . . , aq are new variables, and let Aq = (aq ∨ a1).
• For every i ∈ {1, . . . , q} and j ∈ {1, . . . , w} let us denote B

∨ · · · ∨ bw

∨ b

∨ b

j−1
i

j
i

j+1
i

i ), i.e. B

j
i denotes a

j
i

= (b1
i

clause on variables b1

i , . . . , bw

i
• For every i ∈ {1, . . . , q} and j ∈ {1, . . . , w} let us denote C

in which every literal is negative except b

j
i

= (c1
i

clause on variables c1

i , . . . , c w

i

• Given a triple E j ∈ W , let D j = ( A f ( j) ∨ B
(cid:3)
• Finally, let ϕW =
w
j=1 D j .

in which every literal is negative except c
j
h( j)).

j
g( j)

∨ C

∨ · · · ∨ b
j
i .
∨ · · · ∨ c
j
i .

j−1
i

∨ c

j
i

∨ c

j+1
i

∨ · · · ∨ c w

i ), i.e. C

j
i denotes a

Example 5.3. Let X = {x1, x2, x3}, Y = { y1, y2, y3}, Z = {z1, z2, z3}, and W = {[x1, y1, z1], [x2, y3, z2], [x3, y2, z3], [x1, y2, z3],
[x3, y1, z1]}. Then there are two possible matchings M1 = {[x1, y1, z1], [x2, y3, z2], [x3, y2, z3]} and M2 = {[x1, y2, z3],
[x2, y3, z2], [x3, y1, z1]}.

The formula ϕW for this 3DM instance would be

ϕW =

(cid:6)
a1 ∨ a2 ∨ b1
1
(cid:6)
a2 ∨ a3 ∨ b1
3
(cid:6)
a3 ∨ a1 ∨ b1
2
(cid:6)
a1 ∨ a2 ∨ b1
2
(cid:6)
a3 ∨ a1 ∨ b1
1

∨ b2
1
∨ b2
3
∨ b2
2
∨ b2
2
∨ b2
1

∨ b3
1
∨ b3
3
∨ b3
2
∨ b3
2
∨ b3
1

∨ b4
1
∨ b4
3
∨ b4
2
∨ b4
2
∨ b4
1

∨ b5
1
∨ b5
3
∨ b5
2
∨ b5
2
∨ b5
1

∨ c1
1
∨ c1
2
∨ c1
3
∨ c1
3
∨ c1
1

∨ c2
1
∨ c2
2
∨ c2
3
∨ c2
3
∨ c2
1

∨ c3
1
∨ c3
2
∨ c3
3
∨ c3
3
∨ c3
1

∨ c4
1
∨ c4
2
∨ c4
3
∨ c4
3
∨ c4
1

∨ c5
1
∨ c5
2
∨ c5
3
∨ c5
3
∨ c5
1

(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7)

∧

∧

∧

∧

.

In the following, we shall show that the empowering implicates of ϕW correspond to perfect matchings of W . In partic-
ular, given ϕW in this example we shall have two possible empowering implicates corresponding to matchings M1 and M2
respectively.

H1 =

and

H2 =

(cid:6)
a1 ∨ b1
∨ b2
∨ b3
∨ b4
1
1
1
1
∨ c1
∨ b5
∨ b4
∨ b3
∨ b2
3
2
3
3
3
∨ c1
∨ b5
∨ b4
∨ b3
∨ b2
2
3
2
2
2

b1
3
b1
2

∨ b5
1
∨ c2
2
∨ c2
3

∨ c1
1
∨ c3
2
∨ c3
3

∨ c2
1
∨ c4
2
∨ c4
3

∨ c3
1
∨ c5
2
∨ c5
3

∨ c4
1
∨
(cid:7)

∨ c5
1

(cid:6)
a1 ∨ b1
∨ b2
∨ b3
∨ b4
2
2
2
2
∨ c1
∨ b5
∨ b4
∨ b3
∨ b2
3
2
3
3
3
∨ c1
∨ b5
∨ b4
∨ b3
∨ b2
1
1
1
1
1

b1
3
b1
1

∨ b5
2
∨ c2
2
∨ c2
1

∨ c1
3
∨ c3
2
∨ c3
1

∨ c2
3
∨ c4
2
∨ c4
1

∨ c3
3
∨ c5
2
∨ c5
1

∨ c4
3
∨
(cid:7)

.

∨ c5
3

∨

∨

We claim that ϕW admits an empowering implicate if and only if the input 3DM instance has a perfect matching. The

proof of this claim is split into the following two lemmas.

Lemma 5.4. Using the notation from Deﬁnition 5.2 let M ⊆ {1, . . . , w} be a perfect matching and let G =
a clause. Then G is an empowering implicate of ϕW with a1 being the empowered literal.

(cid:4)

j∈M B

j
g( j)

∨ C

j
h( j)

∨ a1 be

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

31

Proof. Let us renumber the triples in W so that M = {1, . . . , q} and that f (i) = i, i.e. xi ∈ E i , for i = 1, . . . , q. Now, let us
consider the following chain of resolutions:

G 1 = D1, G 2 = R(G 1, D2), . . . , G i = R(G i−1, D i), . . . , Gq = R(Gq−1, Dq).

j

One can check that Gq = G and thus G is an implicate of ϕW . All clauses in this chain are resolvable because the triples in
the matching are disjoint.

It remains to prove that G is empowering. Let ϕ(cid:8)

denote the formula originating from ϕW by falsifying (substituting the
∨

j ∈ M, then we have falsiﬁed all literals in D j except A f ( j). If

(cid:8)) = g( j). Such an index exists because M as a matching covers element y g( j). It follows that B

value false for) all literals in G except a1. We are going to show that ϕ(cid:8) ≡ A1 ∧ · · · ∧ Aq. To this end, let D j = ( A f ( j) ∨ B
h( j)) be an arbitrary clause in ϕW and let us have a look on what happens with D j after falsifying the aformentioned
C
(cid:8) ∈ M be an index for which
literals. If
j
g( j(cid:8)) has two conﬂict
j
g( j) (note that j (cid:13)= j
g( j(cid:8)) we necessarily satisfy the clause D j . By
variables with B
these considerations only clauses A1, . . . , Aq remain in ϕ(cid:8)
. Note that none of these clauses is missing since M is a matching.
The CNF formula ϕ(cid:8) = A1 ∧ · · · ∧ Aq has no unit clauses and thus unit propagation will not derive anything from it. It follows
that G is an empowering implicate. (cid:2)

) and thus by falsifying all literals in B

j /∈ M, then let j

j
g( j)

g( j

(cid:8)

j

(cid:8)

(cid:8)

Example 5.5. Let us consider implicate H 1 from Example 5.3 and let us show how it can be derived by resolutions from
formula ϕW . Implicate H1 corresponds to matching M1 = {[x1, y1, z1], [x2, y3, z2], [x3, y2, z3]}. The clauses of ϕW corre-
sponding to triples in M1 are:

D1 =
D2 =
D3 =

(cid:6)
a1 ∨ a2 ∨ b1
1
(cid:6)
a2 ∨ a3 ∨ b1
3
(cid:6)
a3 ∨ a1 ∨ b1
2

∨ b2
1
∨ b2
3
∨ b2
2

∨ b3
1
∨ b3
3
∨ b3
2

∨ b4
1
∨ b4
3
∨ b4
2

∨ b5
1
∨ b5
3
∨ b5
2

∨ c1
1
∨ c1
2
∨ c1
3

∨ c2
1
∨ c2
2
∨ c2
3

∨ c3
1
∨ c3
2
∨ c3
3

∨ c4
1
∨ c4
2
∨ c4
3

∨ c5
1
∨ c5
2
∨ c5
3

(cid:7)

(cid:7)

(cid:7)

,

,

.

By resolving D1 with D2 we get clause

G 1 =

(cid:6)
a1 ∨ a3 ∨ b1
∨ b2
∨ b3
1
1
1
∨ c1
∨ b5
∨ b4
∨ b3
2
3
3
3

∨ b2
3

b1
3

∨ b4
1
∨ c2
2

∨ b5
1
∨ c3
2

∨ c1
1
∨ c4
2

∨ c2
1
∨ c5
2

∨ c3
1
(cid:7)

.

∨ c4
1

∨ c5
1

∨

By further resolving G 1 with D3 we get desired implicate H1. Observe that G 1 was produced by non-merge resolution
and thus by Lemma 3.3 it is not an empowering implicate. On the other hand H 1 = R(G 1, D3) is produced using a merge
resolution and it is hence a good candidate for an empowering implicate of ϕW . If we falsify all literals in H 1 except a1, we
(cid:8)
= (a3 ∨ a1) from clauses D1, D2, and D3 respectively. The remaining two
get clauses D
3
clauses in ϕW are satisﬁed by this assignment. Thus H 1 is indeed an empowering implicate of ϕW .

= (a2 ∨ a3), and D

= (a1 ∨ a2), D

(cid:8)
2

(cid:8)
1

Lemma 5.6. Let G = G
determines perfect matching in the same way as G in Lemma 5.4.

(cid:8) ∨ u be a prime empowering implicate of ϕW with u being the empowered literal. Then u must be a1 and G

(cid:8)

(cid:8) ∨ u. By Lemma 3.8
Proof. The proof heavily relies on Lemma 3.8 and Lemma 3.9. Let us consider a resolution derivation of G
and Lemma 3.9 this derivation contains a tied chain in which every link literal is resolved upon. Consider how such a tied
chain in ϕW may look like. The only possible tied literal is a1, and the link literals are among a2, . . . , aq. This is because,
as we can observe, the c and b variables cannot be resolved upon (if two clauses have a conﬂict in a c or b variable, they
are not resolvable as they have at least two conﬂicts). Thus a tied chain in ϕW has to look as follows: D i1 , . . . , D iq , where
f (i j) = j, i.e. D i1 contains (a1 ∨ a2), D iq contains (aq ∨ a1) or vice versa if we look at the tied chain in the opposite direction.
We shall assume without loss generality that the former is the case (i.e. D i1 contains (a1 ∨ a2) and D iq contains (aq ∨ a1)).
For 1 < j < q clause D i j contains (a j ∨ a j+1). The chain has to have the length q as this is necessary to get from a1 back
to a1 through link literals among a2, . . . , aq. Now, if we look at how clauses D i1 , . . . , D iq can be resolved upon, we get that
triples E i1 , . . . , E iq must be disjoint to have each consecutive pair in the sequence D i1 , . . . , D iq resolvable. This is because
if D i j , D i j+1 are resolvable, then they cannot have a conﬂict in any b or c variable, which implies that E i j and E i j+1 are
disjoint. We can also observe that the b and c variables cannot be cancelled out by resolution and they are therefore all
itself contains all the B and C parts from D i1 , . . . , D iq and thus
present in the resolvent. Thus, the only possibility is that G
G

itself determines the matching. (cid:2)

(cid:8)

(cid:8)

Theorem 5.7. The problem of testing whether a given CNF formula has an empowering implicate is an NP-complete problem.

32

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

Proof. The NP membership is proved in Lemma 5.1. The NP-hardness follows from the reduction deﬁned by Deﬁnition 5.2
using Lemma 5.4 and Lemma 5.6. Note that by Lemma 3.2 it is enough to consider prime empowering implicates and thus
the assumption that G is a prime implicate in Lemma 5.6 is not restrictive. (cid:2)

Using the reduction from Deﬁnition 5.2, we can also show that when trying to make a CNF formula propagation com-
plete, we can in general observe an exponential blow up of the number of clauses. In particular we can show that there
is a uniform and size increasing family of CNF formulas in which an exponential number of implicates has to be added to
a member of this family in order to make it propagation complete. Here by “uniform” we mean that we have a uniform
construction which constructs a formula on n variables from this family based only on a parameter n.

Theorem 5.8. There is a uniform and size increasing family of CNF formulas parameterized with the number of variables n and where
the number of clauses is O (n), such that the number of implicates that needs to be added to a CNF formula ϕ on n variables from this
family to make it propagation complete is exponential in n (and thus in the size of the formula, too).

Proof. Let us consider an instance of 3DM where | X| = |Y | = | Z | = q and W = X × Y × Z . We claim that at least (q!)2
implicates have to be added to ϕW to make it propagation complete. First, let us observe that we can ﬁnd (q!)2 pairwise
different perfect matchings in W . This is because each perfect matching in W can be viewed as a pair of perfect matchings
in a complete bipartite graph with partities X and Y and a perfect matching in a complete bipartite graph with partities Y
and Z . We have q! perfect matchings in each of these bipartite graphs and thus we have (q!)2 possible pairs of them. Note,
on the other hand, that w = |W | = q3.

Let M = {mr1 , mr2 , . . . , mrq

}, M ⊆ W be a perfect matching. Let us denote the clause

H M = a1 ∨

Bri

g(ri )

∨ C ri

h(ri )

(cid:7)
.

q(cid:8)

(cid:6)

i=1

(cid:8)

(cid:8)

is a different matching than M. Since M and M

, we have that g(r(cid:6)) is covered by a different triple r

(cid:8) \ M (cid:13)= ∅. Let r(cid:6) be an index of a triple such that mr(cid:6)

From Lemma 5.4 it follows that H M is an empowering implicate. We claim that if we add H M to ϕW , then H M(cid:8) remains
(cid:8)|, we have that
are different and |M| = |M
empowering provided M
(cid:8) (cid:13)= ∅ and M
(cid:8)
. Thus Br(cid:6)
M \ M
g(r(cid:6)) forms a subclause of H M . Since
(cid:8)
(cid:8)
(cid:6)) = g(r(cid:6)),
. Thus B

mr(cid:6) does not belong to M
forms a subclause of H M(cid:8) . If we falsify all literals in H M(cid:8) except a1, we get that H M is satisﬁed, because Br(cid:6)
(cid:8)
(cid:6))
have a conﬂict variable. Hence H M plays no role in unit propagation used to possibly derive a1. Whether a1 can or cannot
be derived by unit resolution from ϕW ∧ H M after falsifying the literals in H M(cid:8) except a1 is thus equivalent to whether a1
can be derived by unit resolution from ϕW after falsifying the literals in H M(cid:8) except a1. Note that the above observation
can be generalized to the case when we add more than one of these matching clauses to ϕW and thus it is necessary to
add all the clauses corresponding to perfect matchings to ϕW to make it propagation complete.

(cid:8)
∈ M \ M

g(r(cid:6)) and B

It follows that the number of implicates needed to be added to ϕW to make it propagation complete is at least (q!)2
which is exponential in the size of formula ϕW consisting of q3 clauses build on q + qw + qw = Θ(q4) variables. Family of
the formulas deﬁned in this, with n = Θ(q4), satisﬁes the proposition of the theorem. (cid:2)

, where g(r

(cid:8)
(cid:6) in M

(cid:8)
r
(cid:6)
g(r

(cid:8)
r
(cid:6)
g(r

(cid:8)
(cid:6))

As we have already discussed in Section 2.5, the result contained in Theorem 5.8 is in tight connection to the results
in [21] where the authors show in Corollary 4 that there is no polynomial sized CNF decomposition of any AllDifferent
domain consistency propagator. As we have mentioned in Section 2.5, the quasi-polynomial shown in [12] is based on a
quasi-polynomial lower bound of Razborov [22] on the size of a monotone circuit computing whether there is a perfect
matching in a given graph. Quite interestingly, to the best of our knowledge, there is no stronger lower bound on the
size of monotone circuit computing whether a bipartite graph contains perfect matching than the quasi-polynomial shown
in [22]. It is thus an interesting question whether a stronger lower bound could not be shown using the connection between
domain consistency propagators and monotone circuits shown in [21]. Note that in the proof of Theorem 5.8 we could use
a bipartite matching instead of 3DM for constructing the family of CNF formulas with required properties (we used 3DM
mainly to take advantage of Lemma 5.4). Thus, it might be possible to construct a domain consistency propagator for the
AllDifferent constraint which contains such a modiﬁed family of CNF formulas. On the other hand, it would still be only
one example of a domain consistency propagator which is not enough to argue about any domain consistency propagator
for the AllDifferent constraint.

6. Conclusions

We derived several properties of propagation complete formulas and empowering implicates. Let us now recollect the

answers to the four questions we posed in the introduction.

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

33

1. We showed that given a clause C , the problem of deciding whether C is an empowering implicate of a CNF formula
ϕ is co-NP complete. This result comes as no big surprise as the hard part of this decision is answering the question
whether C is even an implicate of ϕ and the new information brought here is that restricting the attention to the
subset of empowering implicates does not make this problem easier.

2. On the other hand, if there is an empowering implicate of ϕ, there is always a 1-provable empowering implicate of ϕ
as stated in Theorem 4.2 which follows from Proposition 2 of [15]. It means that in this case there is always a clause
for which it is easy to show that it is an implicate of ϕ simply by unit propagation. Extending this reasoning further,
we can even ﬁnd an empowering implicate C , such that it can be derived by a series of resolutions of linear length
with respect to the number of literals occurring in a given formula (Proposition 4.3 which relates to Proposition 4 of
[15] and other results in [33–35]). We also showed that this bound is tight, in some cases linear length of resolution
proof is necessary. It is important that in this case we consider a general implicate C since we also showed that if we
want to derive a prime empowering implicate C , an exponential length of resolution proof might be necessary.

3. We showed that the problem in which we ask whether there is an empowering implicate for given CNF formula ϕ
is NP-complete, which means that checking whether given CNF formula ϕ is propagation complete is co-NP complete.
Note that this strenghtens the results of [9] where the authors showed that the decision problem whether ϕ has an
empowering implicate belongs to (cid:5) p
2 . At a ﬁrst sight we might see a slight contrast between the fact that checking
whether given clause C is an empowering implicate of given CNF formula ϕ is co-NP complete while checking whether
there exists an empowering implicate for a given CNF formula ϕ is NP-complete. The difference is that in the former
problem we are given a particular clause C and it is already co-NP complete to decide whether C is an implicate of
ϕ checking the empowering property is then easy. In the latter case we are given only a CNF formula ϕ and thus we
may look for special empowering implicates, in particular the 1-provable ones. Checking whether a given clause C is
1-provable empowering implicate of ϕ is then polynomial and the hard part is to ﬁnd one.

4. Finally, we showed that there is a uniform and size increasing family of CNF formulas such that given CNF formula ϕ
from this family we have to add an exponential number of empowering implicates to make it propagation complete.
This result strenghtens a quasi-polynomial bound which follows from the results of [21] and the connection between
CNF decompositions of domain consistency propagators in CSP.
It remains an interesting question whether a similar result can be obtained for different representations of proposi-
tional formulas, such as ZBDD (zero-suppressed binary decision diagrams [43,44], see e.g. [45] for use in propositional
formula representation). In particular it may be interesting to investigate, whether the family of formulas deﬁned in
Theorem 5.8 requires an exponentially sized ZBDD to represent its propagation complete counterpart. We leave this
question for further research. We can consider other representations as well, see e.g. [17] for a comprehensive list of
various representations used in knowledge compilation.

Acknowledgements

The authors thank four anonymous referees for their valuable comments that helped to improve the paper. The ﬁrst,
the second, the fourth, and the sixth author gratefully acknowledge the support of the Charles University Grant Agency
(grant Nos. 266111, 265511, and 600112). The third and ﬁfth author thankfully acknowledge a support by the Czech Science
Foundation (grant P202/10/1188).

References

[1] J. Franco, A. Van Gelder, A perspective on certain polynomial-time solvable classes of satisﬁability, Discrete Appl. Math. 125 (2–3) (2003) 177–214.
[2] J.S. Schlipf, F.S. Annexstein, J.V. Franco, R.P. Swaminathan, On ﬁnding solutions for extended horn formulas, Inform. Process. Lett. 54 (3) (1995) 133–137.
[3] M. Davis, G. Logemann, D. Loveland, A machine program for theorem-proving, Commun. ACM 5 (7) (1962) 394–397.
[4] A. Darwiche, K. Pipatsrisawat, Complete algorithms, in: A. Biere, M. Heule, H. van Maaren, T. Walsh (Eds.), Handbook of Satisﬁability, in: Frontiers in

Artiﬁcial Intelligence and Applications, vol. 185, IOS Press, 2009, pp. 99–130.

[5] J.P. Marques-Silva, K.A. Sakallah, Grasp: A search algorithm for propositional satisﬁability, IEEE Trans. Comput. 48 (5) (1999) 506–521.
[6] M.W. Moskewicz, C.F. Madigan, Y. Zhao, L. Zhang, S. Malik, Chaff: Engineering an eﬃcient sat solver, in: Proceedings of the 38th Annual Design

Automation Conference, ACM, 2001, pp. 530–535.

[7] J.P. Marques-Silva, A.K. Sakallah, GRASP — a new search algorithm for satisﬁability, in: Proceedings of the 1996 IEEE/ACM International Conference on

Computer-Aided Design, ICCAD ’96, IEEE Computer Society, Washington, DC, USA, 1996, pp. 220–227.

[8] J.P.M. Silva, I. Lynce, S. Malik, Conﬂict-driven clause learning sat solvers, in: A. Biere, M. Heule, H. van Maaren, T. Walsh (Eds.), Handbook of Satisﬁability,

in: Frontiers in Artiﬁcial Intelligence and Applications, vol. 185, IOS Press, 2009, pp. 131–153.

[9] L. Bordeaux, J. Marques-Silva, Knowledge compilation with empowerment, in: M. Bieliková, G. Friedrich, G. Gottlob, S. Katzenbeisser, G. Turán (Eds.),
SOFSEM 2012: Theory and Practice of Computer Science, in: Lecture Notes in Computer Science, vol. 7147, Springer-Verlag, Berlin, Heidelberg, 2012,
pp. 612–624.

[10] F. Bacchus, GAC via unit propagation, in: C. Bessière (Ed.), Principles and Practice of Constraint Programming – CP 2007, in: Lecture Notes in Computer

Science, vol. 4741, Springer-Verlag, Berlin, Heidelberg, 2007, pp. 133–147.

[11] J. Huang, Universal booleanization of constraint models, in: P.J. Stuckey (Ed.), Principles and Practice of Constraint Programming, in: Lecture Notes in

Computer Science, vol. 5202, Springer-Verlag, Berlin, Heidelberg, 2008, pp. 144–158.

[12] C. Bessiere, G. Katsirelos, N. Narodytska, C.-G. Quimper, T. Walsh, Decompositions of all different, global cardinality and related constraints, in: Pro-
ceedings of the 21st International Joint Conference on Artiﬁcial Intelligence, IJCAI’09, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2009,
pp. 419–424.

[13] S. Brand, N. Narodytska, C.-G. Quimper, P. Stuckey, T. Walsh, Encodings of the sequence constraint, in: Proceedings of the 13th International Conference

on Principles and Practice of Constraint Programming, CP’07, Springer-Verlag, Berlin, Heidelberg, 2007, pp. 210–224.

34

M. Babka et al. / Artiﬁcial Intelligence 203 (2013) 19–34

[14] C.-G. Quimper, T. Walsh, Decompositions of grammar constraints, in: Proceedings of the 23rd National Conference on Artiﬁcial Intelligence, vol. 3,

AAAI’08, AAAI Press, 2008, pp. 1567–1570.

[15] K. Pipatsrisawat, A. Darwiche, On the power of clause-learning sat solvers as resolution engines, Artiﬁcial Intelligence 175 (2) (2011) 512–525.
[16] P. Marquis, Knowledge compilation using theory prime implicates, in: Proceedings of the 14th International Joint Conference on Artiﬁcial Intelligence,

vol. 1, IJCAI’95, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1995, pp. 837–843.

[17] A. Darwiche, P. Marquis, A knowledge compilation map, J. Artiﬁcial Intelligence Res. 17 (1) (2002) 229–264.
[18] P. Marquis, S. Sadaoui, A new algorithm for computing theory prime implicates compilations, in: Proceedings of the Thirteenth National Conference on

Artiﬁcial Intelligence, vol. 1, AAAI’96, AAAI Press, 1996, pp. 504–509.

[19] A. Haken, The intractability of resolution, Theoret. Comput. Sci. 39 (0) (1985) 297–308.
[20] A. Urquhart, Hard examples for resolution, J. ACM 34 (1) (1987) 209–219.
[21] C. Bessiere, G. Katsirelos, N. Narodytska, T. Walsh, Circuit complexity and decompositions of global constraints, in: Proceedings of the 21st International

Joint Conference on Artiﬁcial Intelligence, IJCAI’09, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2009, pp. 412–418.

[22] A.A. Razborov, Lower bounds on monotone complexity of some boolean functions, Dokl. Akad. Nauk SSSR 281 (4) (1985) 789–801.
[23] M.R. Genesereth, N.J. Nilsson, Logical Foundations of Artiﬁcial Intelligence, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1987.
[24] H.K. Büning, T. Lettmann, Propositional Logic: Deduction and Algorithms, Cambridge University Press, New York, NY, USA, 1999.
[25] M. Dalal, D.W. Etherington, A hierarchy of tractable satisﬁability problems, Inform. Process. Lett. 44 (4) (1992) 173–180.
[26] A. del Val, Tractable databases: How to make propositional unit resolution complete through compilation, in: J. Doyle, E. Sandewall, P. Torassi (Eds.),
Proceedings of Fourth International Conference on Principles of Knowledge Representation and Reasoning, KR’94, Morgan Kaufmann, 1994, pp. 551–561.
[27] A. Atserias, J.K. Fichte, M. Thurley, Clause-learning algorithms with many restarts and bounded-width resolution, in: Proceedings of the 12th Interna-

tional Conference on Theory and Applications of Satisﬁability Testing, SAT’09, Springer-Verlag, Berlin, Heidelberg, 2009, pp. 114–127.

[28] F. Rossi, P.v. Beek, T. Walsh, Handbook of Constraint Programming, Foundations of Artiﬁcial Intelligence, Elsevier Science Inc., New York, NY, USA, 2006.
[29] C. Bessière, E. Hebrard, T. Walsh, Local consistencies in SAT, in: E. Giunchiglia, A. Tacchella (Eds.), Theory and Applications of Satisﬁability Testing, in:
Lecture Notes in Computer Science, vol. 2919, Springer, Berlin, Heidelberg, 2004, pp. 299–314, http://dx.doi.org/10.1007/978-3-540-24605-3_23.
[30] C. Schulte, P. Stuckey, Speeding up constraint propagation, in: M. Wallace (Ed.), Principles and Practice of Constraint Programming – CP 2004, in:
Lecture Notes in Computer Science, vol. 3258, Springer, Berlin, Heidelberg, 2004, pp. 619–633, http://dx.doi.org/10.1007/978-3-540-30201-8_45.
[31] J.-C. Régin, A ﬁltering algorithm for constraints of difference in CSPs, in: Proceedings of the Twelfth National Conference on Artiﬁcial Intelligence, vol. 1,

AAAI ’94, American Association for Artiﬁcial Intelligence, Menlo Park, CA, USA, 1994, pp. 362–367.

[32] K. Eshghi, A tractable class of abduction problems, in: Proceedings of the 13th International Joint Conference on Artiﬁcial intelligence, vol. 1, IJCAI’93,

Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1993, pp. 3–8.

[33] K. Pipatsrisawat, A. Darwiche, A new clause learning scheme for eﬃcient unsatisﬁability proofs, in: Proceedings of the 23rd National Conference on

Artiﬁcial Intelligence, vol. 3, AAAI’08, AAAI Press, 2008, pp. 1481–1484.

[34] P. Beanie, H. Kautz, A. Sabharwal, Understanding the power of clause learning, in: Proceedings of the 18th International Joint Conference on Artiﬁcial

Intelligence, IJCAI’03, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2003, pp. 1194–1201.

[35] L. Zhang, C.F. Madigan, M.H. Moskewicz, S. Malik, Eﬃcient conﬂict driven learning in a boolean satisﬁability solver, in: Proceedings of the 2001

IEEE/ACM International Conference on Computer-Aided Design, ICCAD ’01, IEEE Press, Piscataway, NJ, USA, 2001, pp. 279–285.

[36] E. Ben-Sasson, R. Impagliazzo, A. Wigderson, Near optimal separation of tree-like and general resolution, Combinatorica 24 (4) (2004) 585–603.
[37] J. Buresh-Oppenheim, T. Pitassi, The complexity of resolution reﬁnements, in: Proceedings of the 18th Annual IEEE Symposium, Logic in Computer

Science, 2003, 2003, pp. 138–147, http://dx.doi.org/10.1109/LICS.2003.1210053.

[38] A. Urquhart, The depth of resolution proofs, Stud. Log. 99 (1–3) (2011) 349–364.
[39] R.M. Karp, Reducibility among combinatorial problems, in: R.E. Miller, J.W. Thatcher (Eds.), Complexity of Computer Computations, Plenum Press, 1972,

pp. 85–103.

[40] M. Garey, D. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W.H. Freeman and Company, San Francisco, 1979.
[41] O. ˇCepek, P. Kuˇcera, V. Vlˇcek, Properties of SLUR formulae, in: M. Bieliková, G. Friedrich, G. Gottlob, S. Katzenbeisser, G. Turán (Eds.), SOFSEM 2012:
Theory and Practice of Computer Science, in: Lecture Notes in Computer Science, vol. 7147, Springer-Verlag, Berlin, Heidelberg, 2012, pp. 177–189.

[42] M. Gwynne, O. Kullmann, Generalising unit-refutation completeness and SLUR via nested input resolution, http://arxiv.org/abs/1204.6529.
[43] S. Minato, Zero-suppressed BDDs for set manipulation in combinatorial problems, in: 30th Conference on Design Automation, 1993, 1993, pp. 272–277.
[44] S.-i. Minato, Zero-suppressed BDDs and their applications, Int. J. Softw. Tools Technol. Transf. (STTT) 3 (2) (2001) 156–170.
[45] P. Chatalic, L.S. Zres, The old Davis–Putnam procedure meets ZBDD, in: D. McAllester (Ed.), Automated Deduction – CADE-17, in: Lecture Notes in

Computer Science, vol. 1831, Springer, Berlin, Heidelberg, 2000, pp. 449–454, http://dx.doi.org/10.1007/10721959_35.

