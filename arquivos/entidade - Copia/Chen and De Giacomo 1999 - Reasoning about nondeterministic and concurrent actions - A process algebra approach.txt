Artificial  Intelligence  107  (1999)  63-98 

Artificial 
Intelligence 

Reasoning  about  nondeterministic  and  concurrent 
actions:  A process  algebra  approach  * 

Xiao  Jun  Chen  a,1 , Giuseppe  De  Giacomo  b,* 
a School of Computer Science, University of Windsor, 401 Sunset Avenue, Windsos Ontario, Canada N9B 3S7 
b Dipartimento di  Informatica  e Sistemistica,  Vniversitci  di Roma  “L.a Sapienza”, via Salaria 113, 
00198 Roma,  Italy 

Received  10  December  1996;  received 

in  revised  form  12 May  1998 

Abstract 

actions) 

We  present 

about  processes 

activities 

(complex 

concurrent 

a  framework 

for  reasoning 

that  are  constituted 

performed  by  various 

by 
interacting  agents.  The  framework 
is  based  on 
several 
formalism,  which  is  a CCS-like  process  algebra  associated 
two  distinct  formalisms:  a representation 
is  an  extension  of  modal  mu- 
with  an  explicit  global  store;  and  a  reasoning 
logics  such  as  PDL  and  APDL,  and 
logic  of  programs 
calculus,  a  powerful 
branching 
logics  such  as  CTL  and  CTL*.  The  reasoning  service  of  interest  in  this  setting  is 
temporal 
model  checking  in  contrast  to  logical  implication.  This  framework,  although  directly  applicable  only 
when  complete  information  on  the  system  behavior  is  available,  has  several  interesting  features  for 
reasoning  about  actions  in  Artificial  Intelligence. 
tools  from 
in  Computer  Science,  to  deal  with  complex  actions,  treating  suitably  aspects 
the  area  of  Concurrency 
like  nonterminating 
and  interruptions.  0  1999  Published 
by  Elsevier  Science  B.V.  All  rights  reserved. 

executions,  parallelism,  communications, 

it  inherits  formal  and  practical 

that  subsumes  dynamic 

formalism,  which 

Indeed, 

Keywords: Process algebra;  Modal  mu-calculus;  Reasoning  about  actions;  Concurrency;  Model  checking; 
Logical 

implication 

1.  Introduction 

In  this  paper,  we  present  a  piece  of  research 
in  Artificial 

the  area  of  Reasoning  about  Actions 
in  Computer  Science. 

that  can  be  regarded  as  a  bridge  between 
and  the  area  of  Concurrency 
Intelligence 

* A  shorter  version  of  this  paper  appeared 

in the  Proceeding  of  the  Thirteenth  National  Conference  on  Artificial 

Intelligence 

(AAAI-96). 

* Corresponding 
1 Email:  xjchen@cs.uwindsor.ca. 

author.  Email:  degiacomo@dis.uniromal 

.it. 

0004-3702/99/$ 
PII:  SOOO4-3702(98)00104-O 

-  see  front  matter  0  1999  Published  by  Elsevier  Science  B.V.  All  rights  reserved. 

On  the  one  hand,  we  follow  a  methodology 

that  is  typical  of  Reasoning  about  Actions 
for  specifying  and  reasoning  about  dynamic  systems  (e.g.,  see  the 
a  set  of  facts  whose  value  changes  as  the  system 
e#ect.s  of  (atomic)  actions  on  such  a  set  of  facts 
resulting 
axioms  in  [49]).  We  also 
axioms  in 
to  change  during  the  evolution  of  the  system 
to  this  general  picture,  we  allow 
that  will  become  clear  later 

in  Artificial  Intelligence 
situation  calculus 
in  [49]):  introducing 
evolves  (cf.  &YZ~.F in  [49]);  specifying 
(cf.  effect  axioms  in  [49]);  devising  a suitable  means  to  obtain  the  successor-state 
from  executing  an  action  in  the  current  state  (cf.  successor-state 
introduce  a  specification  of preconditions 
[49]).  However,  we  allow  such  a specification 
(differently 
from  precondition 
for  multiple  atomic  actions 
to  occur  together 
on.  we  call  the  resulting  actions  synchmni~ed  actions  instead  of  concurrent 
actions  as,  e.g.,  in  [2.5,24,42,50]), 
control  structures 
by  introducing 

(elementary) 
actions  within  suitable 
recursion,  etc.) 

an  explicit  notion  of process  in  describing 

for  executing  actions  (cf.  precondition 

and  we  allow  for  organizing 

axioms  in  [49]).  In  addition 

(sequential  composition, 

parallel  composition, 

(for  reasons 

iteration, 

On  the  other  hand,  we  make  use  of  modeling 

in  Computer  Science  to  formalize  concurrent  processes, 

of Concurrency 
typically  used  in  Reasoning  about  Action  in  Artificial 
in  order  to  make  use  of  such  tools,  we  need  to  describe 
concrete 

level  of  abstraction 

Intelligence 

the  dynamic 

In  general,  we  may  choose  among  several 

than  the  one  typically  adopted  in  Reasoning  about  Actions. 
levels  of  abstraction  when  describing 

in  the  area 
instead  of  the  ones 
(i.e.,  logics).  However, 
system  on  a  more 

the  system. 
tools  that  have  been  developed 

dynamic  system,  depending  on  the  information  we  assume  available.  We  distinguish 
following 

three  levels: 

a 
the 

(1)  At  a  very  concrete 

evolution,  which  can  be  represented 
we  assume  complete 
action  will  be  performed  next. 

level,  we  may  characterize 

the  system  by  its  unique  actual 
as  a  sequence  of  states/actions.  At  this  level, 
information  on  each  state,  and  we  assume  knowledge  of  which 

(2)  At  a  more  abstract 

system, 

the  system 

In  this  case, 

as  a  transition 

that  can  be  performed 

level,  we  may  characterize 

as  a  p&h  on  such  a  graph.  One  of  these  paths  is  going 

is  represented 
instead  of  a  single  sequence.  The  single  evolution 

the  system  by  all  its  possible 
graph,  called 
evolutions. 
at  level  1 
transition 
is  represented 
to  be  the 
actual  evolution  of  the  system,  yet  we  do  not  have  the  knowledge  on  which  one 
a  state)  has  several  labeled  out-arcs  which  represent 
it  is.  Each  node  (representing 
the  transition 
the  actions 
of  the  system  from  the  current  state  to  a  possible  successor-state.  We  remark 
different  out-arcs  may  be  labeled  by  the  same  action. 
has  several  alternative  outcomes: 
assume  complete 
is  completely  known. 
action 
action  is  going  to  be  performed  next.  Moreover, 
not  known  which  of  the  alternative 

that 
the  action 
In  this  case, 
is  nondeterministic.  At  this  level,  we 
on  the  possible  evolutions  of  the  system:  each  state 
to  be  performed,  and  each 
leads  to  some  completely  known  state.  However,  we  do  not  know  which 
it  is 

actions, 
resulting  states  is  going  to  be  the  next  one. 

in  that  state.  Each  action  causes 

including  which  actions  enabled 

for  nondeterministic 

information 

the  action 

(3)  At  the  third  level,  we  model 

the  system  by  selecting  a  set  of  transition 

instead  of  a  unique  one.  Each  of  such  transition 
possible  behavior.  At  this  level,  we  assume  partial 

systems 
systems  represents  an  alternative 
on  the  possible 

information 

X.J. Chen, G. De Giacomo /Artz$cial Intelligence 107 (1999) 63-98 

h5 

evolutions  of  the  system:  each  state  is  only  partially  known,  and  so  are  the  states 
resulting 

from  performing  an  action  in  it. 
too  concrete: 

Generally, 

level  1  is  considered 

to  obtain  such  complete 
in  order  to  single  out  a unique  system  run.  2  Levels  2 and  3 instead,  have  been 

it  is  unrealistic 

information 
both  used  in  modeling  dynamic  systems. 

In  particular, 

level  3  is  the  one  usually  adopted  by  research 

logic  (situation  calculus,  dynamic 

in  reasoning  about  actions 
logic,  etc.)  is 

[24,37,38,41,42,49,51], 
used  both  to  represent  and  to  reason  about  the  dynamic 
problem  of  interest  in  this  case  is  logic&  implication 

where  a  certain 

systems.  The  typical  reasoning 

(validity) 

in  the  form 

where  l-’ are  axioms  used  to  select  the  set  of  transition 
the  dynamic 
system;  Sinit is  a formula,  which  is  a (partial)  description  of  the  initial  state;  @ is  a formula, 
which  is  the  property  we  want  to  prove,  e.g.,  the  reachability  of  a  state  where  a  certain 
property  (the  goal)  holds. 

systems  that  represent 

In  this  paper,  we  adopt 

of  level  2.  Following 

the  viewpoint 
in  [27],  we  use  a  representation 
the  possible  evolutions 

formalism 

to  define 

the  model  checking 
the  transition 
formalism 

of  the  system,  and  a  reasoning 

reactive 

and 
tool  for  describing  concurrent  and  multiprocess 

systems.  3  Process 

algebras 

properties  we  want 

to  check.  This  framework 

is  the 
(e.g.,  CCS  [45],  CSP  [30],  ACP  [3])  to  model 
as  a 
are  generally 
systems.  They  provide  us  with  a 

recognized 

for  specifying 

approach  proposed 
system  representing 
(a  suitable 
logic) 
one  typically  used  in  process  algebras 
concurrent 
convenient 
clean  way  to  express  parallelism, 
synchronizations/asynchronizations, 
that  can  be  interpreted  on  finite 
developed  and  implemented 
satisfied  by  the  process  (e.g.,  [6,10,11,44]). 

reactivity,  communications, 

interruptions, 

etc.  Moreover, 

for  finite  state  processes 

transition 

systems),  various  practical 
to  verify  whether  a  given  modal/temporal 

coordinations, 
(processes 
tools  have  been 
is 
logic  formula 

The  reasoning  problem  of  interest 

in  this  case  is  model  checking  in  the  form 

where  7  is  a transition  system  representing 
the  possible  evolutions  of  our  dynamic  system; 
sinit  is  the  initial  state  of  7;  Q, is  a  formula,  which  is  the  property  we  want  to  prove,  e.g., 
the  reachability  of  a  state  where  a certain  property  (the  goal)  holds. 

In  our  work,  the  state  of  the  system  called  conjigurution, 
called  process  and  a  passive  component 

the  activities  of  all 

component 
describes 
subroutines, 
a set  of  primitive  propositions,  describes 
are  going  on.  The  configuration 
in  fact  make  the  system  evolve. 

environment, 

the  agents 

is  composed  of  an  active 
called  global  store.  The  process 
robots,  persons,  pieces  of  software, 
etc.)  in  the  system.  The  global  store,  which  is  characterized  by 
that 
in  the  process,  which 

the  state  of  the  world  except  for  the  activities 

can  only  be  changed  by  the  activities 

(e.g., 

2 However,  one  can  describe  a dynamic  system  by  specifying 

its  properties  using  Linear-time  Temporal  Logics 

that  are  interpreted  over  system  runs  (see,  e.g.,  [18]). 

3 In  Artificial 

research 
be  considered  at  this  level.  In  contrast, 

Intelligence, 

in  search-based  planning, 
research 

in  deductive  planning 

including  much  work  on  STRIPS  (e.g.,  [8])  can 

is  typically  carried  out  at  level  3. 

66 

X.J.  Chen,  G.  De  Gincomo 

/Artificial 

lntvlli~ence 

107  (1999)  63-98 

Making  use  of  a  global  store  associated 
in  terms  of  the  difference  between 

the  effects  of  an 
action 
the  current  global  store  and  the  resulting  one. 
Properties  not  mentioned  among  such  effects  are  kept  unchanged.  4  Note  that  this  treatment 
[34],  where 
is different  from  most  of  the  approaches 
all  properties  of  the  state  resulting 

in  the  literature  on  logics  of  programs 
from  an  action  must  be  specified  explicitly. 

to  a  process,  we  specify 

In  order  to  reason  about  the  properties  of  such  modeled  dynamic 

a  suitable  extension  of  modal  mu-calculus 
subsumes  dynamic 
CTL”  [ 181. We  show  that  model  checking 
checking 
efficiently 
our  setting. 

the  existing  verification 

logics  such  as  PDL,  APDL  [34],  and  temporal 

in  our  logic  can  be  linearly 

in  standard  modal  mu-calculus.  By  means  of  this  reduction, 

[32],  a  powerful 

systems,  we  develop 
logic  of  programs  which 
logics  such  as  CTL, 
to  model 
to  reuse 
in 

reduced 
it  is  possible 

tools  mentioned 

above,  for  reasoning  about  actions 

We  also  discuss 

two  important  additional 

issues:  (1)  the  relationship 

checking  and  logical  implication 
a  dynamic 
[53],  which  is  a  logical  formula 
a  transition 
latter,  we  introduce  a  suitable  notion  of  equivalence  based  on  bisimulation 

system.  For  the  former,  we  device  a  suitable  notion  of  characteristic 

in  our  setting;  (2)  how  to  identify 

that  completely  characterizes 

two  representations 

between  model 
of 
jkwmulu 
system.  For  the 
[45]. 

the  main 

its  ability 

illustrating 

several  examples. 

In  Section  3,  we  discuss 

in  detail. 
by 
and  show 

The  rest  of  the  paper  is  organized  as  follows.  In  Section  2,  we  present  our  representation 
feature  of  the  representation 
the  reasoning 
properties. 
for  reasoning 
reasoning 
setting. 

formalism 
formalism 
formalism 
Section  5, we  show  by  means  of examples, 
framework. 
about  actions 
technique 
in  our  setting,  by  reducing 
Section  7,  we  discuss  the  relationship  between  model  checking  and  logical  implication, 
the  issue  of  equivalent  descriptions. 
some  possible  future  research  directions. 

In  Section  4,  we  present 
to  express  a  wide  variety  of  dynamic 
the  use  of the  reasoning 

In  Section  6,  we  devise  a  suitable 
it  to  a  standard 

in  the  proposed 
for  model  checking 

In  Section  8,  we  draw  some  conclusions 

In 
and 
and  sketch 

formalism 

In 

2.  Representation 

formalism:  A  process  algebra  with  global  store 

We  represent  dynamic  systems 

in  terms  of  possible  evolutions  of  the  system  caused  by 

actions.  We  call  conj?gurution 
A  configuration 

is  represented  as  a pair: 

the  state  of  the  system  at  a  point  of  its  possible  evolutions. 

that  are  being  performed  by  the  agents 

where  p  is  called  process  and  o  is  called  global  store.  Intuitively, 
all  the  activities 
the  status  of  such  activities 
properties  characterizing 
performed.  As  the  activities 
process  evolve,  and  hence  the  configuration  of  the  system  changes. 

the  process  describes 
to  be  precise, 
the 
that  do  not  involve  activities  being 
in  the  process  are  performed,  both  the  global  store  and  the 

in  the  current  configuration.  The  global  store  describes 

the  current  configuration 

in  the  system-or 

’  In  this  way  we  address 

the  simplified  variant  of  the  frame  problem 

that  arises  in  our  setting. 

X.J.  Chen,  G. De  Giacomo /Artificial  Intelligence  107  (1999)  63-98 

67 

We  formalize  possible  global  stores  simply  as  propositional 

interpretations.  Let  Prop  be 
logic  (ranged  over  by  A,  B,  . . . , possibly  with 
a  finite  set  of  propositions  of  propositional 
a  subscript).  A  global  store  u  is  a  propositional 
over  Prop.  Given  a  global 
store  o  and  a  proposition  A  E Prop,  a(A)  =  tt  if  the  fact  denoted  by  A  is  true  in  o  and 
cr (A)  =ff 
Before 

elementary  actions. 

interpretation 

to  introduce 

if  the  fact  denoted  by  A  is  false  in  o  . 
formalizing 
process  carries  the  information 
each  of  such  actions,  “what  is  the  process 

processes,  we  need 

Indeed,  a 
actions  are  possible  next”,  and  for 

left  to  be petiormed 

afterwards”. 

on  “which  elementary 

two  kinds  of  elementary 
We  consider 
-  Atomic  actions  which  are  basic  uninterruptible 

actions: 

actions  executed  by  an  agent.  We 

assume  the  set  of  all  possible  atomic  actions  to  be  finite. 

-  Synchronized  actions  which  are  constituted  by  any  nonempty 
together  by  various  agents.  Intuitively, 

to  execute  a  synchronized 

to  execute  a  set  of  atomic  actions 

performed 
means 
execution  of  each  atomic  action 
feedback  of  the  executions  of  the  others. 

simultaneously 

in  a  synchronized 

action, 

set  of  atomic  actions 
action 
as  a  unity.  That  is,  the 
relies  on  the 
implicitly 

Each  action  has  some  effects  on  the  global  store.  The  specification 

of  such  effects  is 

supplied  separately 
from  the  process  by  defining  an  effect  function.  The  effect  function 
specifies  the  effects  of  each  atomic  action  with  respect  to  different  conditions  on  the  global 
store.  On  the  base  of  such  an  effect  function,  a  successor-state 
is  defined  which, 
action,  returns  the  set 5  of  possible  next 
given  a global  store  and  an  atomic  or  synchronized 
global  stores.  6 

function 

Besides  effects,  each  action  has  typically  some  associated  preconditions, 

i.e.,  conditions 
are  specified 
under  which  an  action  can  be  performed. 
action 
the  process.  This  treatment  provides  us  with  the  capability  of  describing 
within 
preconditions  which  depend  not  only  on  the  status  of  the  global  store  but  also  on  the 
status  of  the  process.  So  a  process  can,  for  instance,  dynamically 
the  possibility 
of  executing  an  action  in  some  configurations  when  certain  activities  are  being  performed. 

In  our  setting,  action  preconditions 

block 

2. I.  Atomic  actions 

Let  Act  be  the  finite  set  of  all  possible  atomic  actions  (ranged  over  by  a,  b,  . . . , possibly 

with  a  subscript). 

We  define  an  effect  function  effct  that  associates 

to  each  action  a  E Act,  a  finite  set  of 

pairs  of premise  and  effect: 

e@fW =  { (1cI1, El),  . . . , (1cr,, En)] 

where  for  each  pair  (@i , Ei): 

-  The  premise 

I+$ is  a  propositional 
global  store  must  satisfy  so  that  the  corresponding 

formula  over  Prop  describing 

the  properties 

the 

effect  Ei  can  be  applied. 

5 Recall 
global  stores. 

that  actions  are  generally  nondeterministic, 

so  we  have  a  set  of  (rather 

than  a  single)  possible  next 

6 Such  an  approach 

for  specifying  effects  is  quite  similar  to  that  of  the  A-family  action  languages 

[23,39]. 

68 

X.J.  Chew,  G.  Lk  Giucomo  /Artjficiul 

fmllipm~r 

IO7 (1999)  63-98 

propositions  or  their  negations-over 

-  The  effect  Ei  is  a  set  of  literals-atomic 

Prop 
that  describes  a  possible  effect  of  the  execution  of  action  a  under  premise  $i.  The 
literals  in  Ei  are  required 
in  @et(a). 

that  if  the 
Each  pair  (+i,  E;) 
premise  $r;  is  true  in  the  current  global  store,  then  there  is  a  possible  execution  of  a  that 
causes  the  literals  in  Ei  to  be  true  in  the  resulting  global  store.  In  other  words,  the  action  a 
under  the  premise  @i has  E,  as  possible  effect. 

to  be  true  in  the  successive  global  store. 

can  be  intuitively 

as  an  assertion 

interpreted 

Next,  we  introduce  a  simple  update  operator  o  that,  given  an  interpretation 

(T and  a  set 

of  non-contradictory 

literals  G,  returns  a  new  interpretation  0’. 

Definition  2.1.  Let  rr  be  an  interpretation 
literals  over  Prop.  We  detine  the  update  operator  o  (infix)  as  follows:  VA  E Prop, 

over  Prop  and  L  a  set  of  non-contradictory 

tt A  EC. 
I 

-AEC, 

fl 

I a(A) 

AgLand-A$C. 

(a  o L)(A)  = 

Intuitively, 

the  operator  returns  an  interpretation 

that  satisfies  the  literals  in  L,  and  retains 

the  value  of  the  original 

interpretation  o  for  those  literals  not  occurring 

in  C. 

Making  use  of  the  above  update  operator,  we  define  a  successor-state 

function 

that 

specifies  how  an  atomic  action  affects  the  global  store. 

Definition  2.2.  Let  a  be  an  atomic  action,  and  c  a global  store  (i.e.,  an  interpretation  over 
Prop).  The  set  of  possible  global  stores  obtained  by  executing  u  in  0,  denoted  by  ala, 
is 
the  set  of  all  interpretations: 

COL: 

such  that 

-c= 

1 

E 

if  3$  s.t.  (+.  E)  E &,t(a) 

and  a($)  =  tt. 

ti  otherwise. 

-  C  does  not  contain  contradictory 

literals. 

Intuitively, 

the  set  D/U  of  alternative  global  stores  resulting 

from  executing  action  a  on 
r~ is  formed  by  one  alternative  updated  global  store  for  each  effect  E  of  a  whose  premise 
in  u.  For  each  E,  the  resulting  global  store  is  equal  to  cr o  E,  that  is,  it  is 
+  is  satisfied 
identical 
in  E  are changed 
so  as  to  make  E  true. 

to  cr except  that  the  values  of  the  atomic  propositions  occurring 

Observe  that  action  a  is  nondeterministic 

is  not  singleton-if 

(with  respect  to  the  effects  on  the  global  store) 
It  is 

in  @@t(a)  is  satisfied. 

more  then  one  premise 

(with  respect  to  the  effects  on  the  global  store)-i.e., 

a/a 

is  singleton  ’ -if 

a/u 

in  a-i.e., 
deterministic 
just  one  premise 

is  satisfied. 

’  Note  that  even  if  a/u 

is  singleton, 
pmcrss  may  evolve  in  several  possible  ways  by  performing  (1. 

there  may  still  he  more  than  one  rewlting  configurations 

since  the  current 

X.J.  Chen,  G. De  Giacomo /Artificial  Intelligence  107  (1999)  63-98 

69 

By  definition, 

if  no  premise 

in  e@%(a)  is  satisfied  then  a/a  =  6,  i.e.,  the  action  has  no 

effect  (though  it  may  still  be  performed). 

Finally, 

if  an  effect  E  in  &ct(a) 

is  contradictory, 

it  will  not  generate  a possible  resulting 

store 
global 
contradictory, 
performing  a).  ’ 

in  a/a. 

In  particular, 

then  action  a  cannot  be  executed 

if  every  effect  E  that  has  its  premise 
(thus  influencing 

the  preconditions 

satisfied 

is 
for 

2.2.  Synchronized  actions 

For  synchronized 

actions 

their  obvious  meanings. 

notations  with 
synchronized 
have  the  synchronized 
atomic  action  is  vacuously  a  synchronized 

action  [a}  which  is  in  fact  simply 
action  as  well. 

action  composed  by  al,  . . . , an  E Act.  Observe 

(ranged  over  by  CX, possibly  with  a  subscript),  we  use  set 
the 
that  as  a  special  case,  we 
the  atomic  action  a,  i.e.,  every 

In  particular,  we  denote  by  {al,  . . . , a,} 

We  extend 

the  previously  defined  successor-state 

function 

so  as  to  cope  with  synchro- 

nized  actions  as  follows. 

Definition  2.3.  Let  a  =  {al,. 
store  (i.e.,  an  interpretation 
obtained  by  executing  o,  denoted  by  a/o, 

of  the  propositions 

. . , a,},  with  n  2  1, be  a synchronized 

action,  and  u  a global 
in  Prop).  The  set  of  possible  global  stores 

is  the  set  of  all  interpretations: 

ao(~tU...UC,) 

suchthat,fori=l,..., 

n, 

-  Li  = 

I 

-  L,U... 

E 

if  3$  s.t.  (@, E)  E e#ct(ai)  and  a($)  =  tt, 

0  otherwise. 

U L,  does  not  contain  contradictory 

literals. 

Observe 

Intuitively, 

that  a/{~}  =  a/a. 

the  effects  of  a  synchronized 

atomic  actions.  For  example, 

action  are  the  sum 
of  the  effects  of  the  participating 
let  a  and  b  be  two  atomic 
o  are  {A),  (B)  for  a  and  {C,  D} 
actions  whose  applicable  effects  in  a  given  configuration 
for  b.  That  is,  a  is  nondeterministic 
and  its  effect  is  either  to  set  A  to  true,  or  to  set  B 
to  true  in  the  resulting  global  store,  while  b  is  deterministic 
and  its  unique  effect  is  to 
to  set 
set  both  C  and  D  to  true.  The  effect  of  the  synchronized 
A,  C,  D  to  true  in  the  resulting  global  store,  or  to  set  B,  C,  D  to  true.  In  other  words, 
leads  to  a  global  store,  where  either  A,  C,  D  is  true  and  all 
{a,  b}  nondeterministically 
other  atomic  propositions, 
including  B,  remain  unaffected,  or  B,  C,  D  is  true,  and  all  other 
atomic  propositions, 

including  A,  remain  unaffected. 

action  {a,  b)  is  either 

For  actions  a,  al,  ~2,  with  efit(u)  =  e@t(ul)  =  efSct(u2),  it  is  easy  to  check  that, 
if  a 
executing  {al,  a2)  may  have 
of  (al,  ~2) 

in  a-i.e., 
if  a  is  deterministic 
is  nondeterministic 
in  a-i.e., 
different  effects  with  respect 

is  singleton-then 
is  not  singleton-then 
to  executing  a.  Generally 

a/a  =  a/{ul,  a~].  However, 

the  nondeterminism 

a/u 
a/a 

If In  fact,  it  has  often  been  noticed 

that  state  change’s 

laws  may  influence  preconditions 

of  actions,  see,  for 

example, 

[40]. 

70 

X.J.  Chen,  G.  De  Giucotno  /Art~jificiul  Intelligence  107 (1999)  63-98 

increases  with  respect  to  that  of  a:  (at,  uz]  still  has  all  the  effects  a  has,  but  furthermore 
it  allows  to  combine  such  effects  in  pairs.  For  example,  consider  some  resources  and  two 
consumers  each  consuming  one  resource  at  a  time.  Their  actions  have  the  same  effect:  to 
then  two 
consume  one  of  the  resource. 
resources  will  be  taken  out,  while  if  only  one  consumer 
takes  the  action,  there  will  be  only 
one  resource 

take  the  action  simultaneously, 

If  two  consumers 

taken  out. 

(a,  h}  is  empty:  cr/(~,  h]  =  M. This  means 

Let  us  now  consider  action  (a.  h},  where  the  only  applicable  effect  of  u  is  (A}  and  the 
from 
(a,  h} 

only  applicable  effect  of  b  is  (-A  ). Then  the  set  of  alternative  global  stores  resulting 
action 
executing 
In  general, 
cannot  be  executed, 
action  must 
in  our  setting,  the  effects  of  the  atomic  actions 
is  this: 
be  compatible 
them  at  the  same  time,  but  also 
synchronizing 
to  perform  each  of  them  taking 
from  the  others.  Actions  with 
conflict  effects  cannot  be  synchronized.  For  example,  pushing  and  pulling  a handle  cannot 
be  synchronized. 

i.e.,  the  atomic  actions  u  and  h  cannot  be  synchronized. 
that  constitute  a  synchronized 

in  order  to  perform 
two  actions  means  not  only  to  perform 

action.  The  intuition  behind 

that  the  synchronized 

the  synchronized 

the  feedback 

into  account 

to  assume 

it  is  reasonable 

together  a  and  b  when 

the  difference  between  performing 

in  synchronized 
independent. 

the  feedback  of  each  other  (as  we  assume 
they  are  fully 

together  actions  a  and  b  when  they  take 
(a,  b)) 
If  a  and  b  are 
together  even  though 
into  nondeterminism. 

Observe 
into  account 
and  performing 
independent, 
they  have  contradictory 
For  example, 
and  b  try  to  set  the  proposition  A  to  the  desired  value  independently.  Nondeterministically, 
one  of  the  two  actions  has  “the  last  word’  and  succeeds.  Hence,  two  resulting 
are  possible:  one  in  which  A  is  true,  and  another 
formulated 
as  in  CCS  (see  below). 

let  {A]  and  (-A]  be  the  only  applicable  effect  of  u  and  b,  respectively.  Both  u 

that  they  can  be  performed 
can  be  resolved 

is 
for  concurrent  processes 

in  our  setting  by  adopting  an  interleaving 

in  which  A  is  false.  This  intuition 

effects.  ’  The  contradiction 

semantics 

situations 

action 

actions.  This  is  sufficient 

that  the  effects  of  synchronized 

Finally,  note  that  we  have  assumed 

actions  are  the  sum 
for  most  of  the  purposes,  especially 
of  those  of  the  component 
the  additional  modeling  power  that  processes  give  us.  Several  alternative 
when  we  consider 
proposals 
actions”  have  been  considered 
in  the  literature,  e.g.,  [2,5,24,42,50].  Many  of  these  proposals  are  compatible  with  our 
languages  1251).  In  general,  our 
framework 
function  from  global 
framework  applies  whenever 
stores  to  sets  of  global  stores. 

it  is  possible  to provide  a successor-state 

for  specifying  effects  of  “compound 

those  based  on  A-family 

elementary 

(especially 

action 

2.3.  Processes 

We  adopt  CCS-style  constructs 

to  combine  elementary  actions  into  processes.  CCS,  i.e., 

Calculus  of  Communicating 
processes,  which  includes  processes  constructs 
and  restriction 
synchronization 

Systems,  is  a well-known 

[45].  We  suitably  extend  CCS  in  order  to  deal  with  global  stores  and 
of  multiple  actions. 

formalism 

for  expressing  concurrent 
for  sequence,  choice,  parallel  composition, 

’  Discussions  on  this  issue  may  be  found  in,  e.g..  [S] 

X.J.  Chen,  G.  De  Giacomo  /Artificial 

Intelligence  107  (1999)  63-98 

71 

Due  to  the  appearances 

of  recursions, 
processes.  Here  P  is  a  process  name  and  p  is  a  process  expression 
Each  process  name 
denote  the  set  of  process  names. 

process  equations  P  A  p  are  used  to  define 
(or  simply  process). 
is  associated  with  a  unique  process  definition.  We  will  use  Proc  to 

Processes  follow  the  syntax  below: 

where  nil  denotes  a  predefined 
4  denotes  a  propositional 
denotes  a  set  of  expressions  of  the  form  4  +  e  with  4  a propositional 
and  @ a propositional 

formula  over  Prop,  a  denotes  an  atomic  action 

atomic  process,  P  is  a  process  name  defined 

in  Pmc, 
in  Act,  and  y 
formula  over  Prop 

is  capable  of 
the  action  a,  and  then  behaves  as  the  process  p.  This  term  can  be  viewed 

the  “precondition” 

4, 

the  termination  of  a process. 
is  the  process  which,  under 

formula  over  Act. 
Intuitively,  process  constructs  have  the  following  meaning: 
(1) 
(2) 

nil  represents 
(4  +  a).p 
performing 
as  an  extension  of  CCS-term  a .p  where  no  preconditions 
p1  +  p2  represents 
p1  1) p2, 
any  interleaving  or  synchronizations 
p\y 
the  constraints 

is the  process  obtained  from  p  restricting 

(3) 
(4) 

(5) 

in  v,  i.e.: 

the  alternative  composition  of  p1  and  ~2. 

of  the  actions  of  p1  and  ~2. 

are  specified. 

the  parallel  composition  of  p1  and  ~2,  is  the  process  which  can  perform 

the  allowed  actions  to  those  satisfying 

{u  I V(d  + 

,o) E y.(o($)  =  tt  implies  o(e)  =  tt)} 

where  a(4)  denotes  the  truth-value  of  @ in  5, and  a(q)  denotes  the  truth-value  of  e 
the  value  tt  to  the  atomic  actions 
in  the  interpretation  over  Act  obtained  by  assigning 
in  o  and ff  to  those  in  Act  -  a.  The  restriction  construct  can  be  used  to  dynamically 
restrict 
group  of  actions  can  be  synchronized 
extension  of  the  CCS  construct 
are  not  allowed. 

thus  specifying  “which 
is  an 
that 

.\r,  where  y  is  simply  a  set  of  atomic  actions 

at  what  time”.  Note  that  this  construct 

the  possibility 

synchronized 

of  executing 

actions, 

The  semantics  of  a  dynamic 

system 

is  given  in  terms  of  the  transition 

relation  _+ 

_ 

defined  as  the  least  relation  satisfying 
rules  have  the  following 

schema: 

the  set  of  structural  rules  in  Table  1. Such  structural 

ANTECEDENT 

CONSEQUENT 

SIDE-CONDITION 

which  is  to  be  interpreted 

logically  as: 

V(ANTECEDENT  A SIDE-CONDITION  =k  CONSEQUENT) 

where  V(. . .)  stands  for  the  universal  closure  of  all  free  variables  occurring 
case  either  the  ANTECEDENT  or  the  SIDE-CONDITION  is  missing, 
true. 

in  (. . .).  lo  In 
they  are  interpreted  as 

lo Observethat,typically, 

ANTECEDENT,  SIDE-CONDITION  and  CONSEQUENT  sharefreevtiables. 

Table  I 
Strucmral 

rules 

Det 

(P.  0)  %,“.  0’) 

(P.n):(p’.a’l 

P  =  p 

Res 

(p. 

fr)  L(,“.  CT’) 

(p\y.n)~(p’\y.n’) 

where  V(I$  --t  Q)  E  y.  (n(b)  =  tt  implies  cy(e)  =  tt) 

The  rules  in  Table  1 have  the  following 
Act: 

intuitive  meaning: 

Def: 

Sum 

Int: 

Syn: 

Res: 

(p’,  u’) 

by  executing 

that  (p,  O)  can. 

the  (synchronized) 

action  (Y, provided 

to  the  configuration 

that  the  precondition 

((~5 +  u).p,  u)  can  evolve 

the  action  {u ),  provided 

(~1  +  ~2.  a)  can  evolve  to  a  configuration 

(p,  (T’)  by 
4  is  true  in  6,  and  O’ 

the 
action  (Y, provided  that  either  (p 1, a)  or  (~2,  cr )  can  evolve  to  that 

The  configuration 
executing 
is  a possible  global  store  obtained  by  executing  {a)  in  0,  i.e.,  (T’ E a/{~). 
(P.  a),  where  P  =i= p,  can  evolve  to  the  configuration 
The  configuration 
by  executing 
The  configuration 
(synchronized) 
configuration. 
The  configuration 
by  executing 
(~;,a’) 
executing  CX, provided 
The  configuration 
executing 
(p’, , a’)  by  executing  CXI and  (pz,  a)  can  evolve  to  (p;,  a’)  by  executing  ~2. 
by 
The  configuration 
executing 
to 
action  U,  provided 
(p’,  a’)  by  executing  CY’, and  u  is  allowed  by  y,  i.e.,  V(q5 +  e)  E  y.  (~(4)  = 
tr implies  a(e)  =  tt). 

II ~2, a’) 
that  (~1,  a)  can  evolve 
to 
can  evolve  to  (~1  (1 ~$,a’)  by 

the  (synchronized) 
by  executing  cy. Similarly, 

(pi  II pi,  a’)  by 
that  (~1,  a)  can  evolve  to 

that  (~2,  n)  can  evolve  to  (pi,  G’)  by  executing  CX. 

(~1  11 ~2, a)  can  evolve  to  the  configuration 

the  configuration 
that 

action  LX* U (~2, provided 

(PI  (I /j?,  a)  can  evolve 

(p\v,  a)  can  evolve 

to  the  configuration 

(p,  a)  can  evolve 

action  a,  provided 

the  (synchronized) 

the  (synchronized) 

(/>i  (( p2,a) 

($\~,a’) 

(pi 

to 

74 

X.J.  Chen,  G.  De  Giacomo 

/Art@zl 

Intelligence 

107  (1999) 

63-9X 

We  formalize 

the  scenario  by  introducing 

a  set  of  propositions 

to  model 

the  relevant 

facts,  and  a set  of  atomic  actions  that  change  the  values  of  these  facts: 

Prop  =  (Loaded,  Alive} 

Act  =  {load, 

shoot. 

spin,  wait] 

The  effects  of  the  actions  are: 

ej%ct( load) 

=  { (tt,  (Loaded])} 

rfSct(shoot) 

=  {(Loaded, 

(-Alive. 

-Loaded))) 

e@(  spin) 

=  {(Loaded, 

[Loaded]). 

(Loaded, 

(-Loaded))} 

e#ct(wait_) 

=  {) 

under 

shoot, 

load 
the  premise  of  having 

which  can  be  read  as  follows.  Performing 
Performing 
turkey  killed  and  the  gun  unloaded. 
effect.  Performing 
having  the  gun  still  loaded,  or  having  it  unloaded. 
has  no  effect.  Finally  performing  wait 

under 

spin, 

If  the  gun  is  unloaded,  performing 

shoot 
the  gun  loaded,  results 

the  premise  of  having 

If  the  gun  is  unloaded,  performing 

has  no  effect  in  any  cases. 

results 

in  having 

the  gun 

the  gun  loaded,  results 

in  having 

loaded. 
the 
has  no 
in  either 
spin 

In  this  scenario,  at  any  moment,  we  can  (I)  load  the  gun  if  it  is  not  already 

shoot  the  turkey; 
action  load, 
preconditions 
requirements  by  means  of  the  following  process: 

(3)  spin  the  cylinder; 
-Loaded 

the  precondition 
are  required 

(i.e.,  their  preconditions 

(4)  wait.  That  is,  at  any  moment, 

loaded;  (2) 
the 
must  be  satisfied,  while  for  the  other  actions,  no 
these 

tt).  We  formulate 

are  vacuously 

to  perform 

P k  (-Loaded 

-+  load).P 

+  (It  +  shoot).P 

+  (tt  -+  spin).P 

+  (tt  -+  wait).P 

that  process  P  is  very  simple: 

is 
Observe 
satisfied,  and  becomes 
the 
effects  of  the  actions  change  the  status  of  the  global  store,  the  process  remains  always  in 
the  same  status.  Obviously, 
depends 
only  on  the  number  of  possible  global  stores,  which  is  at  most  21pr0”‘. 

it  performs  an  action,  whose  precondition 
evolves  since 

in  this  case,  the  number  of  possible  configurations 

itself.  In  other  words,  while  the  configuration 

The  form  of  the  above  process  is  typical  of  those  formalisms 

for  reasoning  about  actions 

that  concentrate  only  on  the  specification  of  elementary 
actions,  specifying  preconditions 
and  effects  for  them,  and  do  not  specify  explicitly  any  process.  In  these  cases,  the  following 
process  is,  in  fact,  implicitly  assumed  (note  that  it  has  exactly  the  form  of  the  one  above): 

P  A  C($j 

+  LZi). P 

where  ui  are  the  actions  and  4i  are  their  preconditions. 

Once  we  have  specified 

initial  global  store,  it  is  possible 
example, 
ainit  =  {Alive. 

let  the  initial  configuration 

-Loaded]. 

the  process  and  how  actions  change  the  global  store,  for  every 
to  compute  all  possible  evolutions  of  the  system.  For 
be  described  by  (Pinit,  Dinit)  with  Pinit  =  P  and 
rules  in  Table  1,  we 

From  (Pinit,  Dinit),  using  the  structural 

X.J.  Chen,  G.  De  Giacomo  /Artijicial 

Intelligence  107  (1999)  63-98 

15 

p  Alive 

r-loaded 

1 

-Alive 
'Loaded 

(P 

1 

shoot 

Fig. l.Trausition 

systemfortheRussiauTurkey 

Shoot. 

the  transition 
generate 
evolutions  of  the  configurations 

system  7 

in  Fig.  1,  which  summarizes 

in  a  graph  all  possible 

of  the  system.  For  example,  a possible  evolution 

is: 

(P,(Alive,-Loaded))+ load (P,(Alive,Loaded])walt‘(P,(Alive,Loaded]) 

that  results  in  having  killed  the  turkey.  Another  example 

is: 

s(P,{-Alive,-Loaded}) 

(P,(Alive,-Loaded)) load 

+(P,(Alive,Loaded])+  "In  (P,(Alive,-Loaded}) 

that  results  in  not  having  killed  the  turkey.  Another  one  is: 

s(P,{Alive,-Loaded)) 

(P,{Alive,-Loaded))+ load (P,(Alive,Loaded])~(P,{Alive,Loaded]) 

-(P,(-Alive,-Loaded]) 

that  results  in  having  killed  the  turkey. 

What  about  if  we  do  not  have  complete 

information 

on  the  initial  situation?  A  straight- 

to  deal  with  this  is  to  trade  the  lack  of  information  with  nondeterminism. 

forward  technique 
For  example,  we  may  prefix  the  actual  process  with  a  sequence  of  dummy  atomic  actions 
that  nondeterministically 
informa- 
lead  to  several  global  stores  according 
two  dummy  actions 
tion  on  the  initial  situation. 
initAlive  and initloaded.  Assuming 
is 
that  the  turkey 
alive  but  it  is  not  known  whether  the  gun  is  loaded: 

In  the  above  scenario,  we  may  introduce 

to  incomplete 

that  initially 

it  is  known 

_  we  specify 

efSct(initAlive)= {(tt,(Alive))} 

efScct(initLoaded)= ((tt,(Loaded)),(tt,{-Loaded])} 

_ we prefix the above  process  P by  an  initialization 
actions  can  be  arbitrary)  getting  the  new  process 

sequence 

(the  order  of  the  dummy 

Q  A  (tt+  initAlive).(tt+ initLoaded).P 

- we arbitrarily 

settbeinitial global  storea,  =  {-Alive,-Loaded}. 

76 

X.J.  Chen.  G.  De  Gicrcomo /Artifcid 

Intelligence  107  (1995)) 63-98 

Observe  that  the  new  initial  configuration 
initialization 
the  initialization 
taken  into  account. 

(Q,  a(,) 
sequence,  and  then  evolve  according 

is  forced  to  evolve  by  first  executing 
the 
to  the  original  process  P. After  executing 
sequence,  our  partial  knowledge  on  the  initial  situation  will  be  correctly 

3.2.  Lifting  a  tuhk 

In  this  example,  we  illustrate 

a  process  denoting 

the  concurrent 

activities  of  more 
semantics)  and 

agents,  showing  parallel  execution  of  processes  (interpreted  by  interleaving 
synchronization 

of  atomic  actions.  Interrupts  are  also  briefly  discussed. 
is  the  following.  A  vase  is  on  top  of  a  table. 

If  just  one  side  of  the 
table  is  lifted  then  the  vase  falls  onto  the  floor.  While  if  both  sides  of  the  table  are  lifted 
simultaneously, 

the  vase  does  not  fall. 

The  scenario 

We  formalize 

the  scenario  by  introducing 

the  following  primitive  propositions 

and 

atomic  actions: 

Prop  =  (VaseOnTable,DownLeftSide.DownRightSide] 

Act  =  (vaseFalls.downLeft,downRight.upLeft.upRight} 

The  effects  of  the  atomic  actions  are  the  obvious  ones: 

eflcl(vaseFalls)=((~.(-VaseOnTable])) 

eflct(downLeft)=((-DownLeftSide.(DownLeftSide})} 

@ct(downRight)  =((-DownRightSide.(DownRightSide})] 

Q$ct(upLeft)=((DownLeftSide.(-DownLeftSide})) 

@ct(upRight) =((DownRightSide,(-DownRightSide})) 

4  =  ((DownLeftSide  A  -DownRightSide)  V  (YDownLeftSide  A 

where 
DownRightSide))AVaseOnTable. 

In  this  scenario,  we  have  three  processes  going  on  concurrently: 

agent  Al who  may 
either  raise  or  put  down  the  left  side  of  the  table;  agent  A, who  is  in  control  of  right  side  of 
the  table;  the  environment  Env that  makes  the  vase  fall  off  the  table  as  soon  as  one  of  the 
sides  of  the  table  is  risen  while  the  other  side  is  not.  We  model  these  concurrent  activities 
by  a  process  LT defined  as  follows: 

AlA(-DownLeftSide+downLeft).Ai 

+(DownLeftSide+upLeft).Al 

A,-(-DownRightSide-+ 

downRight).A, 

+(DownRightSide-+upRight).A, 

Env-(4+vaseFalls).Env 

LT-(Al  IIA, I/ Env)\(4-+vaseFallsA-others] 

where  others  denotes  the  disjunction  of  all  atomic  actions  other  than  vaseFalls 

X.J.  Chen,  G. De  Giacomo /ArtQicial  Intelligence  107  (1999)  63-98 

71 

(L-4 tv, L, -a)) 

(IT, IV, L  a)) 

(LT, {V, +.,  +) 

(LT, i?f, -L,  a)) 

Fig.  2.  Transition  system  for  the  Lifting  a Table. 

ur 

dr 

Observe 

that  the  vase  can  fall  only  when  the  precondition 

4  is  satisfied.  Furthermore, 

because  of  the  restriction 
the  possibility 

.\{$  -+  vaseFalls 

A -others) 

in  LT,  whenever 

the  vase  has 

to  fall,  it  is  forced  to  do  so,  while  all  other  atomic  actions  are  blocked.  I2 

Let  the  initial  configuration  be:  I3 

(pinit,  qinit)  =  (LT,  (VaseOnTable, 

DownLef 

tSide,  DownRightSide)). 

By  making  use  of  the  structural  rules  in  Table  1, it  is  possible 

to  build  the  corresponding 

transition 
propositions 
Side 
downRight, 
initial  configuration 
It  is  possible 

system,  as  shown 

in  Fig.  2.  The  figure  uses  obvious  abbreviations 

to  denote 

and  actions:  propositions  VaseOnTable, 

DownLef 

tSide,  DownRight 

are  denoted  by  V,  L,  R,  respectively, 
t,  upRight 

and  actions  vaseFalls, 
are  denoted  by  vf,  dl,  dr,  ul,  ur, 

upLef 

downleft, 
respectively.  The 

(Pinit,  ginit)  is  denoted  by  the  node  labeled  by  (LT,  (V, L,  R}). 
to  check  that  the  behavior  of  the  system  is  the  expected  one.  For  instance, 
Instead  both  A1  and  A, 
t 

respectively.  However,  unless  upLef 

in  (Pinit,  Dinit), the  subprocess  Env  cannot  execute  since  a(@)  =#. 
can  proceed  performing  upLef 
and  upRight 
and  hence  the  vase  will  be  forced  to  fall.  If  the  synchronized 
is  performed, 

then  C$ will  not  be  true  and  hence  the  vase  won’t  fall. 

t  and  upRight, 

synchronize, 

the  condition  C$ will  be  true  in  the  successive  configuration 

action  {upRight, 

upLef 

t) 

Note  that,  the  process  Env  in  LT  can  be  seen  as  a process  which,  when  certain  conditions 
and  allows  for  the  further 
(the  action  vaseFalls) 
processes 
is 
terminates).  More  generally,  an  interrupt  will  set  the 
of  other  actions, 

are  met  (c#J), performs  an  interrupt 
execution  of  the  other  concurrent 
completed 
truth-value  of  certain  flags  that  are  in  the  preconditions 
their  executions. 
the  other  processes,  execute  without  interferences 
the  interrupt  has  been  fully  handled  allowing 

that  block  the  execution  of 
from  them,  and  reset  the  flags  only  when 
to  be  resumed  and 

In  this  way,  we  can  build  interrupting  processes 

(A1  and  A,)  only  when 

for  the  other  processes 

(the  action  vaseFal 

thus  disallowing 

the  interrupt 

Is 

‘* Note  that,  if we  weaken  the  restriction 

in  LT  to be  .\(@  +  vaseFalls),then 

wewill  StillforcevaseFalls 

to  be  executed  whenever  0  is  true,  but  the  action  to  make  the  vase  fall  will  be  allowed 
actions. 

to  synchronize  with  other 

I3 Note  that  LT  behaves  correctly  under  any  other  initial  global  store.  And  it  is  easy  to  verify  that  it  generates 

the  same  transition  system  from  every  initial  global  stores  (obviously  modulo  the  initial  configuration). 

78 

X.J.  Chen.  G.  De  Giacomo  /Artl$cial 

Intelligence  107  (lYY9)  63-98 

continue.Similarly,wecan 
without  ever  allowing 

them  to  regain  the  control.  I4 

also buildprocessesthat 

blocktheexecutionofotherprocesses, 

3.3. Relq 

ruce 

In  this example, we show a more complex process  constituted  by  various  subprocesses 

in 
plays  a key  role.  The  example  also  illustrates  a simple  but  effective 
(see  [48,50, 

but  have  a  duration 

which  synchronization 
technique 
to  deal  with  actions  that  are  not  instantaneous, 
591).  Namely,  an  action  that  has  a duration  of  “running” 

is  modeled  by: 

(1)  an  (instantaneous) 
(2)  a  proposition  Running 
not  yet  completed; 

atomic  action  st  artRun  denoting the initiation of the action; 

in  the  global  store  denoting 

that  the  action  has  started  but 

(3)  an  (instantaneous) 
The  scenario  is  a “relay  race”  with  two  competing 

atomic  action  endRun 

denoting 

the  termination  of  the  action. 

teams,  each  composed  of  two  runners. 

The  rules  of  the  race  are  the  following: 

( I )  when  the  “go”  signal  is  given,  the  first  runner  of  each  team  may  start  running; 
(2)  when  the  first  runner 

the  “100  meters  line”, 

the  second  runner  may  start 

reaches 

running; 

(3)  when  the  two  runners  of  the  same  team  are  both  running, 

the  first  runner  may  pass 

the  baton  along  to  the  second  runner; 

(4)  the  team,  whose  second  runner  arrives  first  to  the  “finish  line”  with  the  baton,  wins. 
and 
We  formalize 

the  following  primitive  propositions 

the  scenario  by  introducing 

atomic  actions  (i  =  I.  2 denotes  the  team,  j  =  I,2  denotes 

the  runner): 

Prop 

=  {Running;,j,lOOmLinePassed;,1,Baton;,,;. 

FinishLinePassed,.2,Won, ) i.j  =  1,2} 

Act  =  (startRun;.i,endRuni,j.passlOOmLinei,I.passFinishLine;,2. 

giveBaton;,,,getBaton;,l.winsi.go 1 i,,j  =  1,2) 

The effects of  the  atomic actions are the obvious ones: 

e&(startRun,.;))=  ((-Running,.,. (Runningi.j])} 

efSct(endRun;,,;))= ((Runningi,j, (7Runningi,,j])] 

e$?ct(passlOOmLine;,~)=((-lOOmLinePasse&.l, 

(lOOmLinePassed;,~})) 

efSc?(passFinishLinei,z)=((-FinishLinePassedi,z, 

(FinishLinePassed;.z))) 

efScct(giveBaton;.I)= {(Baton;,l,(-Baton;,!])} 

f$ct(getBatoni,2)= ((1Batoni.?, {Batoni,z})} 

I4 Priorities  among  processes  can  also  be  easily  modeled,  by  inserting  suitable  flags  in  the  preconditions  of  their 
actions. 

X.J.  Chen,  G. De  Giacomo /Artificial  Intelligence  107  (1999)  63-98 

79 

efSct(winsi)= {(-(Won1 VWorq),{WOni})} 

e%f(go) = 0 

The  various  activities 

involved 

in  the  scenario  are  described  by  the  following  processes 

(we  abbreviate 

(tt  -+  a).p  by  a.p  and  tt  +  Q by  Q): 

Runneri,] A startRuni,l.passlOOmLinei,l.giveBatoni,l.endRuni,l.nil 

Runneri. -(lOOmLinePassed,l -+ startRuni,2).getBatoni,2. 

Teami -(Runneri,l )I Runneri,2)\((giveBatoni,1 

=getBatoni~)) 

CheckWinner-wins1  .nil+  winsz.nil 

RR-((Ready+ go).(Teaml 11 Team;! 11 CheckWinner)\ 

((passFinishLinel,2 =winsl)A(passFinishLine2,2=wins2)) 

where 

Ready=  Ai(AjlRunningi,j A-lOOmLinePassed,l  A 

-FinishLinePassed,lABatoni,l A-Batoni,~A-Woni). 

Let  us  explain 

the  above  processes.  The  process  Runneri, describes 

the  first  runner  of  the  team  i:  the  first  runner  starts  running,  passes  the  100  meters 
passes  the  baton  along  to  the  second  runner,  and  ends  running. 
describes 

The  process  Runneri, 

second  runner  starts  running  provided 
meters  line,  gets  the  baton  from  the  first  runner,  passes  the  Finish  line,  and  ends  running. 

the  activities  of  the  second  runner  of  the  team  i:  the 
the  100 

that  the  first  process  has  already  reached 

The  process  Tern 

describes 

the  activities  of  the  team  i.  It  consists  of  the  concurrent 

composition  of  the  two  processes  Runneri, 
actions  giveBatoni, 1 and  getBatoni.2 must be  performed  synchronously. 

1 and  Runneri, 

with  the  restriction 

that  the 

The  process  CheckWinner describes 

the  activity 

that  establishes 

if  the  first  or  the 

the  activities  of 
line, 

second  team  wins. 

The  process  RR describes all the  activities 

of  the  system. 

of  the  three  processes  Teamt,  Team2  and  CheckWinner 

rent  composition 
by  the  action  go  that  starts  the  race  under  suitable  preconditions, 
tion  that  the  actions  passFinishLinet,2 
passFinishLine2,z 
tivity  described  by  CheckWinner 

and  winsz,  must  be  executed  synchronously, 

and  winst, 

and,  respectively, 

As  in  the  previous  examples,  by  using 

to  declare  the  true  winner. 
the  structural 

It  consists  of  the  concur- 
prefixed 
and  with  the  restric- 
the  actions 
thus  forcing  the  ac- 

rules  in  Table  1,  it  is  possible 

to 
to  make  explicit  all 

build  the  transition 
possible  evolutions  of  the  scenario. 

system  generated  by  the  given  initial  configuration 

3.4.  Translating  whi 1 e programs 

As  the  last  example,  we  show  that  the  process  description 
traditional  programming 

can  easily  represent 

formalism  presented  here 
In 

like  “while”  and  “if-then-else”. 

constructs 

particular,  we  show  how  programs  of  a  simple  sequential  programming 
While,  can  be  translated 

into  processes.  While  programs  have  the  following  syntax: 

language,  called 

where  CI is  a  generic  atomic  action  whose  effects  are  specified  by  the  effect  function 
as  before,  and  the  other  constructs 
and  while. 
are  sequential 
respectively. 
To  define 

the  translation,  we  first  introduce 

composition, 

if-then-else, 

inductively 

rr  detined 

function 

on  the 

structure  of  Whi le programs.  For  every  process  17: 

fr(u.  p)  =  (tt  +  a).p 

tr(61:  62. p)  =  tr(8l.  tr(S2.  p)) 

tr(if $ then  61 else&, 

p)=  (4 +  nop).tr(Sl. p)+  C-q5 --t  nop).tr(&.p) 

tr(while 4 do 6. p) =  Q where  Q  is  a  new  process  name  dehned  as: 

Q  A  (4  +  nop).tr(J. Q)  +  (-4 

-  nap)./' 

where  nop  is  a  special  atomic  action  which  has  no  effects  on  the  global  store.  It  is  used  to 
reflect  the  fact  that  tests  are  assumed  to  make  a transition.  ”  Then,  we  define  the  translation 
of  a While  program  6  as  the  process  ~(6.  nil). 

Observe  that  the  intuitive  meaning  of  the  constructs 

is  correctly  captured  by  the  resulting 
that  behave  as  follows: 
process.  For  example,  while-loops 
into  processes 
first.  the  entering  condition  of  the  while  is  tested;  if  such  condition 
is  true  then  the  process 
behaves  as  the  body  of  the  while  followed  by  the  whole  while-loop  again;  if  the  condition 
is  false  then  it  exits  the  loop.  I6 

are  translated 

For  example, 

the  following 

fragment  of  control  code  of  an  elevator: 

6 =  while 

~GroundFloor 

do  goDownOneFloor: 

openDoor 

is  translated 

into: 

Q + ~~GroundFloor-  -  nop).(tt ---f goL)o~~tlOrleFloor).  Q  $ 

(GroundFloor 

---, nop).(tt +  openDoor).nil 

4.  Reasoning 

formalism: 

the  logic  M,, 

Once  we  have  had  a  representation 

of  a  dynamic 

system,  we  can  use  such  a 

to  infer  properties  of  the  system,  like  the  possibility 

representation 
to  reach  a configuration 
where  a  certain  property  holds  (i.e.,  where  a  certain  “goal”  is  satisfied),  or  the  invariance 
of  certain  statements,  etc. 

”  If  such assumption  i\ not made. the translation  can be modified  accordingly. 

”  One could  define  derived  structural  rule<  for  the  various  comtructa  of  While 

on  the  bahi? of  the asociated 

processes,  and verify  that  such  rules  correspond  to  those  usually  associated to  such  constructs  (see, e.g..  1261). 

A  thorough  discussion  on this  is  out  of  the hope  of  the paper. 

X.J.  Chen,  G.  De  Giacomo 

/Art$cial 

Intelligence  107  (1999)  63-98 

81 

Among 

the  various 

for  verifying  properties  of  concurrent 

temporal  and  modal  logics  that  have  been  proposed 

logics  of  programs  which  is  called  modal  mu-calculus 

in  the  process 
[17,28,43],  we  focus  on 
algebra 
literature 
([ 19,32, 
one  of  the  most  powerful 
is  a  logic  of  programs,  which  is  strictly  more  expressive 
33X573).  Modal  mu-calculus 
than  logics  like  PDL,  APDL,  CTL  and  CTL*.  It  has  been  proposed  as  a logic  for  expressing 
“temporal”  properties  of  reactive  and  parallel  processes 
the  excellent 
use  in  the  context  of  concurrent  processes. 

in  [9,12,36,54,55,62].  We  refer  to 
and  its 

introduction  on  modal  mu-calculus 

tutorial  article  [55]  for  a thorough 

systems 

In  this  paper,  we  introduce 

an  extension  of  standard  modal  mu-calculus, 

called  M,, 

which  allows  for  boolean  combinations 
suitable 

to  verify  properties  of  systems  specified 

of  atomic  actions  in  the  modalities,  and  thus,  it  is 

in  our  representation 

formalism. 

4.1.  The  logic  M, 

The  logic  M, 
_  Propositions 
-  Modalities 

is  basically  constituted  by  three  kinds  of  components: 
to  denote  properties  of  the  global  store  in  a  given  configuration. 
to  denote 

of  performing 

the  capability 

actions 

certain 

in  a  given 

configuration. 

-  Least  and  greatestfixpoint 

constructs 

to  denote  “temporal”  properties  of  the  system, 

typically  defined  by  induction  and  coinduction. 

The  formulae  of  M, 
following  abstract  syntax: 

are  defined  on  the  base  of  action  formulae 

generated  by  the 

e::=aIanyInoneI-elel~ezIe1Ve2 

where  a  E A for  some  fixed  set  A of  atomic  actions,  any  is  a special  atomic  action  denoting 
the  empty 
the  union  of  all  actions 
action. 
(nonexecutable) 

in  A, and  none  is  a  special  atomic  action  denoting 

The  meaning  of  a  generic  action  formula 

is  given  by  the  satisfaction 

relation  below, 

where  a! is  a  set  of  atomic  actions  (denoting  a  synchronized 

action  in  general): 

ob=a 

o  +any 

iffaEcr 

(always) 

(Y +  none 

(never) 

ah--e 

iffnot 

a! +Q 

o  !=el  ne2 

iffo 

l=e~  anda 

be2 

(11 keel  Ve2 

iffa 

keel 

ora 

be2 

Note  that  not  all  constructs 
none  =  a  A  -a,  any  =  -none,  QI V ~2 =  -(-@I  A -4. 

in  action  formulae  are  independent. 

In  particular,  we  have: 

Formulae  of  M,  are formed  inductively 

from  action  formulae,  primitive  propositions 

some  fixed  set  ‘P,  and  variable  symbols 
abstract  syntax: 

in  some  fixed  set  kr, 

according 

in 
to  the  following 

82 

X.J.  Chen,  G.  De  Giucorno  /Art$ciul 

Intelligence  107  (1999)  63-98 

where  A  is  a  primitive  proposition 
formula  over  A. 

in  P,  X  is  a  variable  symbol 

in  Vat-, and  Q is  an  action 

The  symbols  F  and  v  can  be  considered 

and  in  the  sequel,  we  make 
use  of  notions  of  scope,  bound  and  free  occurrences  of  variables,  closed  formulas,  etc. 
The  definitions  of  these  notions  are  the  same  as  in  first-order 
logic,  treating  k  and  u  as 
quantifiers. 

as  quantifiers, 

As  usual  in  mu-calculus, 

the 
for  formulae  of  the  form  bX.0 
s_wrractic monotonicity  of  @J with  respect  to  X:  every  occurrence  of  the  variable  X  in  @ 
must  be  within  the  scope  of  an  even  number  of  negation  signs.  This  requirement  guarantees 
the  existence  of  the  least  and  the  greatest  fixpoints  associated  with  <p (see  below). 

and  uX.0,  we  require 

The  semantics  of  M, 

a transition  system  7.  a valuation  V  on  ‘7  is  a  mapping  from  variables 
the  states  in  7. 

is  based  on  the  notions  of  transition  system  and  valuation.  Given 
in  Var to  subsets  of 

Given  a  valuation  V,  we  denote  by  V[X/&], 

the  valuation 

identical 

to  V  except  for 

IJ[X/&](X)  =  E,  i.e.,  for  every  variable  Y. 

wxlay) 

=  y(y) 

1 & 

if  Y =  x, 
if y _# .f. 

Let  7  =  (S,  (R,  1 a  E 2A},  I7)  be  a  transition 

system  with  I7  mapping  propositions 

in  P  to  subsets  of  S,  and  V  a  valuation  on  7.  We  assign  meaning 
(.)c,  which  maps  M, 
associating 

to  7  and  V  an  extension  ,finction 

to  M,, 
formulae 

formulae  by 
to  subsets 

of  S.  The  extension 

function 

(.); 

is  defined  inductively  as  follows: 

(A);  =  U(A)  c  S 
(tt);  =  s 
Wgi=M 
(-a$  = s -  (a$ 

(@I 

v  @2)v 

‘T 

= 

(@)I) 

1  u 

(@2) 

; 

c 

C(Q)@); 

= 

{s  E  S 

I  3x, 

s’. 

(Y  k  Q  and  (s.  .s’) E R,  and  s’  E  (@)c) 

([Q]@);  =  (s  ES  1 Vcz. s’.  cy +  Q and  (.c, .s’) E R, 

implies  s’  E  (@)$} 

(llX.@); 

=  n 

(E  E  s  I w$!& 

c  q 

ww; 

=  u 

{E  s  s  I f  c  (@&q} 

cx,;  =  V(X)  c: s 

Intuitively, 
following  meanings: 

the  extension 

function 

(.)c  assigns 

to  the  various  constructs 

of  M,, 

the 

-  The  boolean  connectives  have  the  expected  meaning. 

X.J.  Chen,  G. De  Giacomo /Artificial  Intelligence  107  (1999)  63-98 

83 

-  The  extension  of  (e)@  includes 

execution  of  some  action  satisfying  e  that  leads  to  a successive  state  S’ included 
extension  of  0. 

the  states  s  E S  such  that  starting  from  S, there  is  an 
in  the 

-  The  extension  of  [e]@  includes 

of  an  action  satisfying  e  leads  to  some  successive 
of@. 

the  states  s  such  that  starting  from  S, each  execution 
in  the  extension 

state  s’  included 

-  The  extension  of  pX.@ 

is  the  smallest  subset  EP  of  S  such  that,  assigning 

extension  EP,  the  resulting  extension  of  @ is  contained 

is  the  leastfipoint 

pX.@ 
of  @  with  respect  to  X  guarantees 
the  Tarski-Knaster 

Theorem 

of  the  operator  I&.(@)c,x,E 

the  monotonicity 

[SS],  the  unique  existence  of  the  least  fixpoint. 

to  X  the 
in  E*.  That  is,  the  extension  of 

. The  syntactic  monotonicity 
o I? such  operator  and  hence,  by 

-  Similarly, 

the  extension  of  uX.Q,  is  the  greatest  subset  E,  of  S  such  that,  assigning 

to  X  the  extension  Ev,  the  resulting 
extension  of  uX.@  is  the  greutestfipoint 
monotonicity 
of  @  with  respect 
and  hence,  by  the  Tarski-Knaster 
fixpoint. 

of  @  contains  E,.  That 

extension 
of  the  operator  M.(Q)&,,, 
the  monotonicity 

is,  the 
. The  syntactic 
o 1 such  operator 
[58],  the  unique  existence  of  the  greatest 

to  X  guarantees 
Theorem 

Note  that  not  all  the  M, 

constructs 

tt  =  -8;  @1  v  02  =  -(+i+ 

where  @[X/-X] 

of  X  by  the  formula 

are  independent. 
A  -@2); 

is  the  formula  obtained  by  substituting 
-X.  We  also  use  @t  +  @2  as  an  abbreviation 

[e]@  =  -(e)-@; 

In  particular,  we  have:  8  = 
and  vX.@  = 
all  free 
for 

A  A  -A; 
-@X.-@[X/-X], 
occurrences 
-@r  v  #2. 

Let  us  consider  some  interesting 

examples  of  M, 
of  /-L and  v  extends  to  the  right  as  much  as  possible): 

formulae 

(we  assume  that  the  scope 

( 1)  (e) tt  expresses 
(2)  [e]fS  states  the  inability  of  executing  any  action  satisfying  e. 
(3)  (any)tt  A  [-elf 

the  capability  of  executing  some  action  satisfying  e. 

the  inevitability/necessity 

of  executing 

indicates 

some  action 

(4) 

state  that  is  in  8,. 

satisfying  e . 
that  there  exists  an  evolution  of  the  system  such  that  @ 
,uX.@  v  (any)X  expresses 
(1)  the 
eventually  holds.  Indeed, 
its  extension  E/1 is  the  smallest  set  that  includes 
leading 
states  in  the  extension  of  @;  and  (2)  the  states  that  can  execute  an  action 
In  other  words,  the  extension  &P includes  each 
to  a  successive 
state  s  such  that  there  exists  a run  from  s  leading  eventually 
(i.e.,  in  a  finite  number 
of  steps)  to  a  state  in  the  extension  of  @.  Note  the  inductive  nature  of  this  property 
which  is  typical  of  properties  defined  by  least  fixpoint. 
-(@X.-Q 

the  invariance  of  @ under 
all  of  the  evolutions  of  the  system.  Indeed,  its  extension  E,  is  the  largest  set  of  states 
in  the  extension  of  @ from  which  every  executable  action  leads  to  a  successive  state 
which  is  still  in  E,.  In  other  words,  the  extension 
includes  each  state  s  such  that 
every  state  along  every  run  from  s  is  in  the  extension  of  @.  Note  the  coinductive 
nature  of  this  property  which  is  typical  of  properties  defined  by  greatest  fixpoint. 

v  (any)X)-expresses 

I, 

(5)  uX.@  A [any]X-i.e., 

(6)  pX.0 

v  ((any)tt  A  [any]X) 
holds.  Indeed, 

that  for  all  evolutions  of  the  system,  0 
eventudly 
(1)  the 
states  in  the  extension  of  @;  and  (2)  the  states  that  can  execute  an  action  and  such 
that  every  executable  action  leads  to  a  state  in  EP.  In  other  words,  the  extension  EP 

its  extension  EP  is  the  smallest  set  that  includes 

expresses 

includes  each  state  s  such  that  every  run  from  s  leads  eventually 
number  of  steps)  to  a  state  in  the  extension  of  @. 

(i.e.,  in  a  finite 

In  general,  M, 
such  as  forms  of  liweness,  sufet,v,  and  also  fairness 
uX.~Y.[u](( 
throughout  any  inlinite 

allows  for  expressing  very  sophisticated  properties  of  dynamic  systems, 
the  formula 
infinitely  often 

(h)tt  A  X)  v  Y)  expresses  a  fairness  constraint:  h  is  possible 
length  run  consisting  wholly  of  a  actions. 

[55].  For  example, 

Finally,  note  that  if  @ is  closed  (no  free  variables  are  present 

in  4),  as  in  the  examples 

above,  then  the  extension  of  (@),I  is  in  fact  independent  of  the  valuation  V.  It  is  usual  to 

say  that  u  closed  @  is  true  irz u  stute  .F qf’the  trunsition 
valuation  V  (the  extension  of  @  is  in  fact  independent  of  V  with  CD closed). 

.system  I 

iff  s  E  (@)c 

for  any 

4.2.  Model  checking 

In  the  setting  proposed  in  this  paper,  the  reasoning  problem  of  interest  is  model  checking: 

given  a  transition 
true  in  such  a  state.  The  formal  definition  of  model  checking 
following  one. 

system  and  one  of  its  states,  verify  whether  a  certain  closed  formula 

in  our  setting 

is 
is  then  the 

Definition  4.1.  Let  7  =  (S.  (R,  1 a  E 2A}.  L7)  be  a  transition 
propositions 
free  variables  are  present)  M,, 
whether 

system  with  n  mapping 
in  P  to  subsets  of  S,  let  s  E S  be  one  of  its  states,  and  let  Q, be  a  closed  (no 
is  to  verify 

formula.  The  related  model  checking  problem 

where  V  is  any  valuation.  since  @ is  closed. 

In  the  following  we  abbreviate 

s  E  (0,); 

by  7.  s  /=  @  or  simply  by  .s t=  @  referring 

to  I  only  implicitly. 

5.  Reasoning  about  actions 

Having  presented  both  the  representation 

can  discuss  how  reasoning  about  actions 
model  checking. 

formalism 

formalism,  we 
is  done  in  this  setting.  The  basic  idea  is  to  use 

and  the  reasoning 

Specilically,  given  an  initial  configuration 

( p,,,;!.  q,?;,) and  a M, 

formulae  @, we  verify: 

(P~,it.  flinit) k  @ 

where 
transition 

the  transition 
system. 

system  we  are  implicitly 

referring 

to  is  the  (pin{,. ai,,;,)-generated 

Let  us  consider  some  examples.  First,  consider 

the  Russian  Turkey  scenario 

in  Section  3 

with  plnlt  =  P  and  o,,,ir =  (Alive. 

-Loaded).  We  can  verify  that: 

(yi,?;j,(Ti,l;r)  +  ((load)(wait)(shoot)tt) 

A ([load][wait][shoot]-Alive) 

that  is.  the  sequence  of  actions 
load.  wait, 
results  in  having  killed  the  turkey.  Observe 

shoot 

can  be  performed  and  (necessarily) 

that,  this  is  a  typical 

instance  of  the  so  called 

X.J. Chen, G. De  Giacomo /Art$cial  Intelligence  107 (1999)  63-98 

projection  problem:  given  an  initial  configuration 
truth-value  of  a  certain  fact  in  the  resulting  configuration. 

and  a  sequence  of  actions,  determine 

The  nondeterminism 

of  the  action  spin 

is  reflected  in  the  following  property: 

85 

the 

(pinir,qnit) 

b  ((load)(spin)(shoot)Alive) 

A 

((load)(spin)(shoot)-Alive) 

that is,  the  sequence  of  actions 
turkey  or  not.  However  it  (necessarily) 

load, 

spin, 
results  in  having  unloaded 

shoot  may  result  either  in  having  killed  the 

the  gun,  since 

(pinit,  Oinir) b  ((load)(spin)(shoot)tt) 

A ([load][spin][shoot]-Loaded). 

Consider now the following  instance of model checking: 

(Pinit,  Dinit)  I=  PX.& 

V  (w)X. 

the  existence  of  a  (not  yet  determined) 

It  expresses 
the  initial  configuration, 
If  only  deterministic 
of  the  planning  problem: 
starting  from  the  initial  configuration.  Thus,  we  may  do  planning  by  using  model  checking 
techniques. 

can  reach  a configuration  where  &  is  true. 
atomic  actions  are  allowed, 

then  the  one  above  is  a  formalization 

it  asks  for  a  sequence  of  actions-a 

sequence  of  actions  that,  starting  from 

reach  the  goal  C& 

plan-to 

If  nondeterministic 

atomic  actions  are  allowed, 

too  weak  since  it  expresses  only  the  possibility 
the  goal.  For  example, 

in  the  Russian  Turkey  scenario 

the  above  formalization 

is 
that  a certain  sequence  of  actions  achieves 

of  planning 

(Pinit, oiinit) b  hX.-Alive 

V  (any)X 

is  verified  by 
load, 
as  shown  in  Section  3.1. 

shoot 

spin, 

the  sequence 

of  actions 
does  not  necessarily 

load, 
achieves 

spin, 

shoot, 

yet 

the  execution 

the  goal  of  having  killed 

of 
the  turkey, 

However,  we  can  still  formalize 

the  planning  problem  as  follows: 

(Pinit,  Dinit)  k  FX.#g 

v  V 

(Q)tt  A  [alX 

OEACf 

which  expresses 
from  the  initial  configuration, 
example, 

in  the  Russian  Turkey  scenario 

the  existence  of  a  (not  yet  determined) 
necessarily 

that,  starting 
sequence  of  actions 
reaches  a  configuration  where  C& is  true.  For 

(Pinif 7 Qinit )  +  ,xX.-Alive 

V  V 

(a)ttr\  [a]X 

LlEACf 

is  verified  by  the  sequence  of  actions 
shoot. 

I7 

load,  wait, 

shoot, 

but  not  by  load, 

spin, 

”  If  concurrency 

is taken  into  account, 

the  planning  problem  become  more  involved,  since  issues  such  as  which 
to  execute  a  given  plan  (or  part  of  a  plan), 
agent  is  in  control  of  a  given  atomic  action,  which  agent  is  supposed 
etc.,  become  relevant.  Moreover,  other  forms  of  planning,  which  are  closer  to  the  synthesis  of  a  control  process 
than  to  the  generation  of  a  sequence  of  actions,  may  be  more  appropriate 
in  this  context.  Although  some  of  these 
issues  can  be  tackled  within  the  proposed  setting,  we  do  not  discuss 

them  further  here. 

86 

X. J.  Chm,  G.  Lk  Giawno 

/  Artijid 

Intdligencu 

107  (I  999)  63-98 

Next,  consider 

the  case  discussed  at  the  end  of  Section  3.1  where  we  have  incomplete 

on  the  initial  situation 

information 
loaded).  Checking  whether  a property  @ holds  in  the  initial  situation 
whether 

(in  particular,  we  do  not  know  whether 

the  gun  is 

is  reduced  to  checking 

(Q..sy)b  [initAlivej[initLoaded]@ 

that  is,  checking  whether  @  is  true  in  every  configuration 
sequence. 
verify  that  there  exists  a  plan  to  kill  the  turkey: 

‘s  For  example,  even  if  we  do  not  know  whether 

right  after  the  initialization 

the  gun  is  loaded,  we  can 

(Q,s,)b [initAlive][initLoaded] 

I-LX.1AliveV V  (u)tr A [a]X 
> 

treilct 

( 

It  is  easy  to  see  that  a  possible  plan  is:  load followed  by  shoot. 
the  Lifting  a  Table  scenario  as  formalized 

Let  us  now  consider 

in  Section  3.  Let  the 

initial  configuration  be  (Pini,,  oinir)  with: 

Pinit  =  LT  and  oinlt  =  (VaseOnTable. 

DownLef 

tSide,  DownRightSide]. 

We  can  verify  that  if  agents  Al and  Ar raise  the  table  synchronously, 

then  the  vase  won’t 

fall  on  the  floor. 

(Pinit.Crinit)  /=  [upLeft A upRight][vaseFalls]#. 

Instead, 

if  they  do  not  synchronize, 

the  vase  falls  off  the  table: 

(Pinit,fliait)  b  [(upLeft A-upRight)V  (1upLeftA  upRight)] 

(any]-VaseOnTable. 

We  can  also  prove  that  whenever 

the  vase  can  fall,  it  does  fall:  “) 

(Pinit,o;nir)  b  YX.((vaseFalls)tt=+ (any)ttA  [-vaseFalls]ff) A  [any]X. 

Finally,  consider 

the  Relay  Race  scenario  as  formalized 

configuration 
verify  that  at the  beginning, 

be  (Pinit,  ginit)  with  Pi,lir  =  RR  and  o;rlit  such  that  Ready 
the  action  go  must  be  executed: 

in  Section  3.  Let  the  initial 
is  true.  We  can 

(Yii*it~ 

oiinit) 

k 

(!7o)ft 

A 

[lSOl.,f 

is,  in  the  initial  configuration 

That 
including  go  are  not  executable. 
is  executable. 

go 

is  executable, 

actions  not 
In  fact,  it  is  easy  to  verify  that  no  other  atomic  action 

and  (synchronized) 

We  can  also  verify  that  both  teams  may  win: 

(Pinitr 

ai.nit) 

I=  WX.Wonl 

V 

(any)W 

A  WX.Won2 

V 

(any)X) 

That  is,  from  the  initial  configuration, 
there  exists  an  execution  where  team  2 wins.  Moreover,  for  all  executions,  either  team  1 or 
team  2  wins: 

there  exists  an  execution  where  team  1  wins  and 

(Pinit, 

~init) 

k  M.(Wonl 

V  Won21 

V  bwlX 

I8 Note  that,  it  is always  possible  to  execute  the  initialization 
“Even  when  we  weaken  the  restriction 

in  LT to  be  .\[@  +  vaseFalls] 

sequence. 

X.J.  Chen,  G.  De  Giacomo  /Artijicial 

Intelligence  107  (1999)  63-98 

87 

Furthermore, 

it  is  impossible 

that  both  teams  win.  Indeed,  we  can  verify  that  as  soon  as 

one  of  the  team  wins,  the  other  cannot  win  anymore. 

(Pinit,ainit) 

/=  uX.((Wonl *  uY.7Won:! A [any]Y>  A 

(Won2 =+ uY.-Won1 A [any]Y))  A[any]X 

That  is,  in  every  configuration, 

if  Won1 (Won2) is  true,  then  Won2  (Won])  is  false  from 

then  on  along  all  possible  configuration’s 

evolutions. 

6.  Reasoning  techniques 

In  this  section,  we  derive  a  technique 

to  perform  model  checking  within 

the  proposed 

setting.  We  do  so,  by  devising 

two  transformation 

functions: 

-  A  transformation 

F  from 

transition 

systems  whose  arcs  represent 

systems  whose  arcs  represent 

sets  of  atomic 
single 

(synchronized 

actions 
atomic  actions. 

actions) 

to  transition 

-  A  transformation  H  from  M, 

formulae,  which  allow  for  boolean  combinations 

to  standard  modal  mu-calculus 

in  the  modalities, 

atomic  actions 
allow  only  for  single  atomic  actions  in  the  modalities. 
from  applying 
techniques  have  been  developed 

The  setting  resulting 
various  model  checking 
means  of  the  transformations 
techniques. 

such  transformations 

is  a  standard  one  for  which 
(see,  e.g.,  [19,55]).  Hence,  by 
F  and  H,  we  can  make  use  of  such  model  checking 

of 
formulae,  which 

The  idea  at  the  base  of  the  transformations 

F  and  H  is  to  reify  transitions, 

is  transformed 

i.e.,  to 
into 

introduce  a  new  state  for  each  transition, 
a formula  on  the  new  state.  Fig.  3 illustrates 

so  that  the  action  formula 

the  reification: 

_  Fig.  3(a)  illustrates 

the  original 

transition 

that  (s,  t)  E 72,  and  a, 
(f).  It  assigns 

is  the  propositional 
to  each  primitive  proposition  A  E  P  the  truth-value 

interpretation 

(aI) 

from  the  state  s  to  the  state  t.  We  have 
associated  with  s 
tt  iff  s  E  n(A) 

(t  E n(A)). 

-  Fig.  3(b)  illustrates 

the  resulting 
introduced 

reified  transition 
constituted  by  the  transition 
state,  denoted  by  (s,  cx, t),  and  the  transition 

from 
the  state  s  to  a  newly 
from 
(s,  01, t)  to  the  state  t.  We  require  that  (1)  (s,  (s,  CX, t))  E R,,  and  ((s,  a,  t),  t)  E Rw2; 
(2) CT, and  at  be  the  propositional 
(the  same  as  in  the  original 
transition); 
associated  with  (s,  cx!, t),  which  assigns 

associated  with  s  and  t , respectively 
interpretation 
to  each  atomic  action  a  E  A  the truth-value 

(3)  Us  be  the  propositional 

interpretations 

ttiffaEa. 

Fig.  3.  Transition 

reification: 

(a)  the  original  one;  (b)  the  transformed  one. 

88 

X.J.  Chen, G. De Giucomo /Artificid 

ht&wwe 

IO7 (1999)  63-98 

Definition  6.1.  Let  A  be  a  set  of  actions  and  P  a  set  of  propositions.  Given 
system  7  =  (S,  {‘I&  1 a  E 2d}.  I7)  with  I7  mapping  propositions 
define: 

in  P  to  subsets  of  S,  we 

transition 

F(7)  =  (ST  {R;, 

, R&l.  q 

where 

SF=Su((s.~,t)/~~AA,(s.t)~R,} 

r,;,  =  ((.I.. (s,  (Y, t))  I a  c  A.  (.s. f)  E R,} 

R;,  =  {(s.  a.  t),  t)  Icy c  A.  (s.  t)  E R,} 

nF(p) 

=  (s  I s E l7(p)] 

foreach  p  E P 

nF(~)={(~.~,t)I(~..s’)~Rol. 

USA) 

foreachaEd. 

In  addition,  given  a  valuation  V  on  I,  we  define: 

F(V)(X)  =  (s  / s  E V(X)) 

for  each  X  E  Var. 

Observe  that,  arcs  in  the  transition 

system  F(7) 

can  only  be  labeled  by  either  WI or  ~2. 

Definition  6.2.  Given  a  M, 

formula  @, we  define  H  (@)  inductively 

as  follows: 

H(A)  =  A 

H  (tt)  =  tt 

Hcfs)  =.f 

H(-CD)  =  -H(Q) 

H((Q)@)  =  (u~~)(e  A  (~,2)ff(@)) 

H([el@) 

=  lwll(e  =+ [wzlH(@)) 

H(pX.@) 

=  FX.H(@) 

H(uX.@) 

=  uX.H(@) 

H(Ql  A  ~32) =  H(q) 

A  H(@z) 

H(X)  =  X 

H(@1v@2)=H(@~)vH(@2) 

Observe  that,  H  (0) 

is  a  standard  modal  mu-calculus 

formula,  since  only  single  actions 

(W 1 or  ~2)  may  appear  in  the  modalities. 

Theorem  6.3.  Let  transition 
linearly  bounded  by  the  size  of 7. 

system  7  =  (S,  (I?,, 

/ a!  E  2d),  I7).  The  size  of  F(7) 

is 

Proof.  For  any  transition  system  T,  let  state-no.(l) 
of  the  states  in  7  and  the  number  of  the  edges  in  I, 
F,  we  have  that  state_no.(F(I)) 
2  x  edge-no.(l). 

=  state-no.(l) 

q 

and  edge-no.(l) 

denote  the  number 
respectively.  By  the  definition  of 

+  edge-no.(I), 

and  edge_no.(F(I)) 

= 

Theorem  6.4.  Let  0  be  u  M, 
Of@. 

jtirmula.  The  size  of  H (@)  is  linearly  bounded  by  the  size 

X.J.  Chen,  G. De  Giacomo /Artijicial  Intelligence  107  (I999)  63-98 

89 

Proof.  Let  size(@)  denote  the  size  of  formula  @.  It  is  easy  to  verify  by  induction  on  the 
structure  of  the  formula  @, that  size(H(0)) 

-C c.  size(@).  q 

Theorem  6.5.  Let  transition 
system 
Then for  every  valuation V  on  7  and for  every  s  E S,  we have: 

7  = 

{7& 

(S, 

) (Y E 2*},  A’) and  @  a  M, 

formula. 

Proof.  First,  we  show  by  induction  on  the  structure  of  Q that: 

((s,  s’)  E R,  and  a! +  Q) 

iff 

(s,  (Y, s’)  E  (p)$i. 

Indeed,  for  Q =  a:  if  (s,  s’)  E R,  and  a! b  a-i.e., 
by  definition  of  F(I),  we 
then,  again  by  definition  of 
have  (s,  U, s’)  E LfF(a);  on  the  converse, 
F(I),  we  have  (s,  s’)  E R,  and  a  E (Y, i.e.,  (Y b  a.  For  the  other  cases,  the  result  follows 
immediately  by  the  induction  hypothesis. 

a  E a-then, 
if  (s,  CY, s’)  E nF(a) 

Now,  we  are  ready  to  prove  the  thesis  of  the  theorem.  Without 
to  formulae  @ of  the  form: 

restrict  our  attention 

loss  of  generality,  we 

@ ::=  A  ] -4 

1 @t  A  02  ] (Q)@  ] pX.0 

] X. 

The  proof  is  given  by  the  induction  on  the  number  of  nested  fixpoints  constructs 

I-LX.@. 

Base  case.  If  no  fixpoint  constructs  are  present 

in  @,  then  we  can  verify  that  the  thesis 

holds  by  the  induction  of  the  structure  of  @ . All  cases  are  immediate  except  the  case: 

s  E  ((@P); 

iff 

s  E  ((~4  )(e  A  (u~)H(p)))$i 

that  we  prove  below. 

(=+)  By  definition  of  $, 

s  E  ((Q) P); 

implies 

that  there  exist  (Y and  s’  such  that 

o  +  Q,  and  s’  E  PT.  By  induction 

iff 
(s,  s’)  E  R,, 
s’  E  (H(@)),(v). W-J  By  the  definition  of  F(I),  we  have  ((s,  CZ, s’),  s’)  E R& , so  we  have 
(s,  a,  s’)  E  ((~2vw’))F(1/)~  F(7)  Moreover  since  (s,  s’)  E Rcr  and  a  b  Q, we  have  (s,  o,  s’)  + 

hypothesis,  we  have  s’  E  !PT 

(e)  F$i.  Finally,  by  definition  of  F(I),  we  have  (s, 

(s,  CZ, s’))  E  R$,  .  Hence,  we  can 

concludes  E  ((wt)(e  A  (uJ~)H(!P)))$~. 

(‘_)  By  definition  of  .:I;;, 

s  E  ((wt)(e  A  (w~)H(~P)))F$ 

implies 

that  there  exist 

o  and  s’  such  that  (s,  (s,  CY, s’))  E R&, 

((s, a,  s’),  s’)  E Ri,, 

(s, a, s’)  E (p)~$~  and  s’  E 

(H(ly));;;;. 

By  induction  hypothesis,  we  have  s’  E  i&T  iff  s’  E  (H(q))::;;. 

Moreover, 

since 

(sj  o?;(‘&+ 

F(I) 

(@)F(V)3  we  have  (s,  s’)  E  R, 

and  u  k  Q.  Hence,  we  can  conclude 

s  E ((e)@)F(V). 

Inductive  case.  Let  us  assume 

that  the  thesis  holds  for  the  formula  @  with  k  nested 
fixpoint  constructs.  We  prove  it  for  @J =  pX.  P  with  k  +  1. We  recall  that,  by  the  Tarski- 
t  such  that 
Knaster  Theorem  on  fixpoints 

iff  there  exists  an  ordinal 

[%I,  s  E  (PX.P)~ 

s  E  (~6  X. iP)$,  where  (J.L~ X. iP); 

is  defined  by  transfinite 

induction  as: 

- 

(pu~X.ly)c  =  &(l(tX.P)i, 

if  h  is  a  limit  ordinal. 

We  proceed  by  transfinite 

induction  on  ordinals  6. 

Base  case  of  the  tramfinite 

induction.  p0X.q 

is  defined  as,fJ‘,  thus  trivially  we  have 

s  E (peX.U)c 

iff  s  E  (~(jX.H(P))~j~~. 

Successor  cuse  of’ the  transjinite 

itzduction.  We  want  to  show  that  s  E  &+I  X.S)c 

iff 

s  E  (CL<+IX.H(*),:;;;. 

which,  by  definition, 

reduces  to: 

Since  P  contains  k  fixpoint  constructs,  by  inductive  hypothesis  on  k,  we  have: 

So  it  remains 

to  prove  that: 

Notice  that  the  two  valuations  above  may  differ  only  on  the  value  of  X.  If  it  holds  that: 

(1) 

(3) 

then  by  straightforward 
well.  Let  us  prove  (3),  which  can  be  written  as: 

induction  on  the  formation  of  H(P),  we  have  that  (2)  holds  as 

.s E F(“[XIw~X.w;])(X) 

iff 

s  E  ~(U)[X/(~~X.H(~))~~~~](X). 

By  definition  of  F  on  valuations, 

this  reduces  to: 

s  E  (weX.V); 

iff 

.Y E  (IL~X.H(~))::~( 

which  indeed  holds  by  transfinite 

inductive  hypothesis. 

Hence,  considering 

(1)  and  (2),  we  can  conclude 

that  s  E  (P~+IX.@)~ 

iff  s  E 

(M+,X.H~‘J’));~;)‘. 

Limit  case  of  the  transfinitr 

induction.  Let  i,  be  a  limit  ordinal, 

then  s  E  (phX.P)c 

iff 

there  exists  an  ordinal  6  <  h  such  that  s  E  (~ugX.9);.  By  transfinite 

induction  hypothesis, 

it  holds  that  s  E  &X.*)5 

iff  s  E (~~X.H(*))~:~~. 

and  thus 

s  E  (j&x.*)‘; 

iff 

,s E  (p~.X.H(+))ric;. 

This  completes 

the  transfinite 

induction.  So  for  all  ordinals  6  it  holds  that 

s  E  (kcX.P)c 

iff 

s  E  (pcX.H(@))F$:. 

The  induction  on  the  nesting  of  fixpoint  constructs 
proven  the  theorem.  q 

is  completed  as  well,  hence  we  have 

X.J.  Chen,  G.  De  Giacomo  /Art$cial 

Intelligence  107  (1999)  63-98 

91 

Theorem  6.5  gives  us  a  sound  and  complete 

technique 

to  do  model  checking 

in  the 

setting  proposed 

in  this  paper.  To  check  if 

7,sb@ 

check  if 

F(7),  s b  H(Q). 

Theorems  6.3  and  6.4  which  state  that  F(7) 

respectively,  allow  us  to  conclude 

that  such  a  technique 

and  H (@)  are  linearly  related  to  7  and  @, 
is,  in  fact,  quite  efficient. 

, 

formula 

The  problem  of  model  checking  a  standard  mu-calculus 

in  a  finite  transition 
to  be  in  NP  fl  coNP  [21].  Model  checking  algorithms  are  known  that  run 
system  is  known 
in  (171  . PI)  Ock) [22]  where  171  is  the  size  of  the  transition 
(@I  is  the  size 
least  and  greatest  fixpoints  whose 
of  the  formula  @,  and  k  is  the  number  of  “alternating” 
that 
variables  are  one  within 
are  typically  of  interest  can  be  expressed  with  a very  small  number  of  alternating 
fixpoints 
(one  or  two),  and  hence  typically  model  checking  can  be  performed  within  a  low  order 
polynomial 
to  our 
setting.  *O 

time.  By  Theorems  6.3  and  6.4,  such  results  can  be  applied  immediately 

the  scope  of  the  other  (see  [19]).  Moreover, 

the  properties 

system  7, 

the  section  by  observing 
allow  us  to  use  the  software 

that,  from  a  practical  point  of  view,  the  above 

tools  such  as  the  Edinburgh  Concurrency 

[lo]  *’  or  the  Concurrency  Workbench  of  North  Carolina 

[ 111, **  that  have 

implemented 

for  the  automated  model  checking  of  standard  modal  mu-calculus 

We  conclude 
transformations 
Workbench 
been 
formulae. 

7.  Further 

issues  on  reasoning  about  dynamic  systems 

In  this  section,  we  discuss 
reasoning  on  dynamic  systems. 

two  important 

issues  related 

to  the  representation 

of  and 

First,  we  relate  model  checking 

that  the 
is  a  special  case  of  the  latter.  We  get  this  special  case  when  we  have  enough 
to  the  simple 

to  isolate  a  single  model,  hence  reducing 

in  our  setting 

former 
information 
verification  of  the  truth-value  of  a  formula. 

implication, 

implication 

to  logical 

showing 

logical 

Second,  we  discuss 

the  issue  of  equivalent 

In  the  context  of  process 
the  equivalence  of  two  descriptions  of  the  same  system  has  been  well  investigated 
for  verifying 

tools  have  been  implemented 

descriptions. 

the  equivalences.  Here  we  show 
of 

coincides  with  a  natural  extension 

relation  deduced  by  M, 

bisimulation 

equivalence  which  has  been  proved  of  an  experimental 

algebras, 
and  various 
that  the  equivalence 
the  well-known 
impact. 

2o Note that the transformation  H  does not change  the number of  alternating  fixpoints. 
2’Availableathttp://www.cs.bris.ac.uk/”neil/ExternalLinks/comms94/cwb/cwb.htm 

22Availableathttp://www.csc.ncsu.edu/eos/users/r/rance/WWW/cwb-nc.html. 

92 

X.J.  Chm,  G.  De 

tiiacomo 

/Artijriai 

Intelligence 

107  (1999) 

63-98 

7. I.  Relating  model  checking  to  logical  implication 

In  this  subsection,  we  relate  model  checking 

in  [25,27,52,53].  Given  a  finite  transition 

to  logical  implication, 

following 
system  ‘7,  it  is  not  difficult 

the  line  of 
to  build  a 

reasoning 
set  of  formulae  07 

that  encode  7. 
Let  ‘7  =  (S.  [R,  1 a  E zA].  n)  be  a  transition 

system, 
for  each  s  E S.  a  formula  of  the  form: 

obtained  by  including, 

the  set  of  formulae  DI 

is 

The  set  of  formulae  DI  encodes 

the  transition 

system  7, 

in  the  sense  given  by  the 

following  proposition. 

Proposition  7.1.  Given  finite 
s  E S  urzd every  M,,  formulae  @.  we  have: 

transition 

system  7  =  (S,  {I& 

/ (;Y E  2A},  II),  for  every 

I.s+@ 

i#  D~f=O,,+@. 

This  proposition 

531,  by  applying 

follows  directly 
the  transformations 

from  the  work  on  churucteristic 
formulae 
F  and  H  defined  in  the  previous  section. 

in  [25,52, 

The  above  result  shows  that  model  checking  can  be  seen  as  a  special  case  of  logical 
to 
to  the 
to  model 

implication.  The  set  of  formulae  DT  can  be  seen  as  providing 
essentially 
verification  of  the  truth-value  of  a  formula 
checking. 

single  out  a  unique  model,  and  thus  logical 

i.e.,  it  is  reduced 

in  such  a  model, 

information 

is  reduced 

implication 

enough 

Note  that,  from  the  practical  point  of  view,  using  a  generic 

in  DI 

do  logical  implication 
inefficient. 
is  EXPTIME-complete, 
completeness  of  standard  mu-calculus 

Indeed  DT  has  essentially 

according 

[ 19,201. 

instead  of  model  checking 

to 
is  highly 
for  M, 
to  the  linearity  of  transformation  H  and  the  EXFTIME- 

in  7,  although  possible, 
the  same  size  as  7,  and  logical  implication 

theorem  prover  for  M, 

7.2.  Equivalent  descriptions 

A  question 

that  naturally  arises  is  when  two  descriptions  of  a  dynamic 

considered 
descriptions  which  is  not  necessarily 

equivalent.  Observe 

system  can  be 
that  in  this  case  we  are  asking  about  a  property  of  the 
related  to  properties  of  the  modeled  dynamic  system. 

X.J.  Chen,  G.  De  Giacomo  /Art$cial 

Inrelligence  107  (1999)  63-98 

93 

approach 

Adopting 

an  algebraic 

for  such  descriptions 

classes  on  processes, 

from  the 
Two 
trace 
identifies  systems 
on  the  other 
two  systems  if  during  every  run  whenever  one  system  can  perform  a certain 

allows  us  to  benefit 
equivalent  descriptions.23 
literature: 

study  of  equivalence 
main  notions  of  equivalences 
equivalence 
that  have  the  same  set  of  possible 
hand,  identifies 
action,  then  the  other  system  can  perform 

the  same  action  matching  such  a move. 

[30],  and  bisimulation  equivalence 

runs  (traces).  Bisimulation 

[45].  Trace  equivalence 

in  the  process  algebra 

have  been  proposed 

equivalence, 

to  identify 

Here  we  focus  on  bisimulation 

two 
systems  not  only  on  the  base  of  their  “traces”  (trace  equivalence)  but  also  on  the  base  of 
their  “branching  behaviors”. 

since  we  are  interested 

in  identifying 

equivalence, 

We  introduce  a  natural  extension  of  the  bisimulation 

formalism.  We  say  state  ~1 of  the  transition 

representation 
of  72,  if  the  truth-value  of  each  primitive  proposition 
whenever  sl  can  evolve  into  si  by  a  (synchronized) 
arriving  at  a  state  s;  which  is  equivalent 

equivalence 

studied  in  [45]  to  our 
system  71  is  equivalent 
to  s2 
is  the  same  in  both  ~1 and  ~2,  and 
action  CY, s:!  can  also  do  the  action  a! 

to  si,  and  vice  versa.  Formally: 

Definition  7.2.  Let  7  =  (S,  (%& 1 a  E 2d},  l7)  and  7’  =  (S’,  {R&  I a! E 2d),  n’)  be  two 
transition 

systems. 

(1)  YI s  S  x  S’  is  a bisimulation 

if  for  all  (r,  r’)  E ‘8,  cx E A, 

implies  3t’  :  (r’,  t’)  E R&  and  (t,  t’)  E 8;  and 

(a)  {A  ) r  E n(A)}  =  (A  I I-’ E n’(A)]; 
(b)  (r,  t)  E R, 
(c)  (r’,  t’)  E ‘Rk  implies  3  :  (r,  t)  E Ra  and  (t,  t’)  E 8. 
s’  E  S’,  s  and  s’  are  equivalent,  written 
!R such  that  (s,  s’)  E 8. 

(2)  for  s  E  s, 
bisimulation 

s  Xl,, s’,  if  there  exists  a 

The  bisimulation 

equivalence 

logic  with  fixpoints  (first-order  mu-calculus) 
bisimulation 
time  with  respect  to  the  size  of  the  systems  (see,  e.g.,  [l]). 

equivalence  xb  on  finite  transition 

xb  can  be  expressed  as  a  simple  formula  of  first-order 
the  verification  of 
in  polynomial 

systems  can  be  performed 

[46,47].  As  a consequence, 

We  also  remark 

that  some  investigations 

equiva- 
lence  directly  on  process  descriptions. 
time 
with  respect  to  the  size  of  process  descriptions  have  been  devised  for  some  typical  forms 
of  processes 

have  been  done  to  check  bisimulation 

In  particular,  algorithms 

that  run  in  polynomial 

[29]. 

An  alternative  way  to  define  equivalence  of  descriptions 

is  to  make  use  of  logic: 

systems  are  considered  as  the  same  iff  no  logical  formula  can  distinguish 

two 
them  (see  [28]). 

Definition  7.3.  Let  7  =  (S,  [FL  1 a  E 2d},  l7)  and  7’  =  (S’,  {R&  I (Y E 2d},  n’)  be  two 
systems.  For  s  E S,  s’  E S’,  s  and  s’  are  equivalent  with  respect  to  M,,  written 
transition 

S  %MM, 

S’, 

iff 

{CD  E  M, 

( 7,  s  +  @} =  {Q, E M, 

I I’,  s’  b  @}. 

In  fact,  the  two  forms  of  equivalence 

xb  and  x+ 

coincide  under 

the  very  loose 

condition  of  imagejniteness. 

A  configuration 

(p,  a)  is  lmage$nite, 

if  Vo  E A.  {(p’,  a’) 

I 

23 Good  comparisons  of  various  notions  of  systems  equivalences  can  be  found  in  [16,60,61]. 

((p.  CF), (p’,  0’))  E K&J  is  finite.  A  system  is  imagefinite 
are  image  finite. 

if  all  its  reachable  configurations 

Proposition7.4.  Let  7  =  (S,  (R, 
two  imagejinite 

transition  systems,  and  s  E  S, 

.s’ E S’. 

/ a  6  2A},  l7)  and  7’  = 

(S’,  {‘FL& ) a  E 2A],  l7’)  be 

This  proposition 

follows  from  the  analogous 

We  remark 

[4.5]  and  standard  mu-calculus, 

equivalence 
defined  in  the  previous  section. 
that  Proposition 
properties  of  our  descriptions, 
if  and  only  if  they  are  not  equivalent  according 
other  words,  it  implies 
distinguishability  with  respect  to  the  logic  M,, 

that  the  bisimulation 

7.4  implies 

theorem  24  (see,  e.g.,  [55])  on  bisimulation 
the  transformations 

by  applying 

F  and  H 

that  M,, 
in  the  sense  that,  M,  distinguishes 
to  the  bisimulation 

is  well  dimensioned 

for  verifying 
two  transition 
systems 
zt,.  Or,  in 
equivalence 
“b  captures  exactly  the  notion  of 

equivalence 

8.  Conclusion 

The  research  presented 

in  this  paper  can  be  regarded  as  a  bridge  between 

and  the  area  of  Concurrency 

the  area 
in 

of  Reasoning 
Computer  Science. 

about  Actions 

in  Artificial 

Intelligence 

Specifically,  we  have  presented  a model  checking  based  framework 

for  reasoning  about 
that  are  constituted  by  several  concurrent  activities  performed 

complex  actions  (processes) 
by  various  interacting  agents. 

We  have  shown 
in  Computer  Science, 
Intelligence, 
state  of  the  world. 

that  this  framework, 
is  well-suited 

arisen  originally 

for  reasoning 

about  complex  actions 

in  the  area  of  Concurrency 
in  Artificial 
on  the 

information 

in  the  simplified  but  significant  case  of  having  complete 

The  strong  connection  with  the  area  of  Concurrency 

in  Computer  Science  has  allowed 
us  to  make  use  of  the  body  of  results  devised  in  that  area  in  the  last  decade,  and  to  address 
issues  like  nonterminating 
and  interrupts, 
which  have  been  hardly  tacked  so  far  in  Artificial 

synchronizations, 

communications 

Intelligence. 

executions, 

Besides 
understanding 
about  Actions 

the 

technical 

results, 

of  the  issues  involved 
in  Artificial 

Intelligence. 

this  work  gives 

for  better 
some  conceptual 
in  integrating  concurrent  processes  within  Reasoning 

tools 

In  particular,  we  are  referring 

to: 

-  The  possibility  of  specifying  preconditions 

-  The  separation  of  the  specification  of  how  atomic  actions  affect  the  state  of  the  world 
from  the  specification  of  the  process,  as  noticed  in  general  for  complex  actions  in  [37]. 
for  actions  (i.e.,  establishing  when  a given 
action  can  be  executed)  within  the  process  in  order  to  have  them  under  the  control  of 
the  process.  This  is  the  choice  we  have  made  in  our  proposal. 

-  The  need 

to  maintain, 

together  with 

the  information 

about 

the  world  (the  global  store, 

in  our  case), 

the  information 

about 

*’  Such  a theorem 

is  NI turn  an  extension  of  the  Hennessy-Milner 

Theorem 

[28 1 

the  current 

state  of 
the  current  state 

X.J.  Chen,  G.  De  Giacomo  /ArtiJcial 

Intelligence  107  (1999)  63-98 

95 

of  the  activities 
executed). 

that  are  going  on  (the  part  of  the  process 

that  remains 

to  be 

to  the  above  point,  the  use  of  a  “single-step” 

together  with  the  new  state  of  the  world  what  remains 

-  Related 
return 
process.  In  general,  this  allows  for  a simple  and  elegant  treatment  of both  concurrency 
and  nonterminating 
transitions  within 
the  situation  calculus). 

that 
to  be  executed  of  the 

(see  [ 14,151 for  a use  of  “single-step” 

i.e.,  transitions 

transitions, 

behaviors 

Further 

technical  extensions  of  the  present  work  are  possible  along  several  directions. 

We  outline  some  of  them  below. 
The  first  extension  concerns 

the  only  essential 

a,}  and  cr.  It  follows 

2.1  and  2.2).  However, 

a  very  simple  form  of  the  update 

we  have  introduced 
of  the  possible  global  store  resulting  by  performing 
Definitions 
proposed  setting  is  to  have  some  function 

the  form  of  the  update  on  the  global  store.  In  Section  2, 
the  set  a/{at , . . . , a,} 
to  compute 
the  action  {at,  . . . , a,)  on  o  (see 
to  retain  precisely 
the 
. . . , a,}  from  the  inputs 
that  we  may  adopt  a  more  complex  form  of  update,  based, 
bl,..., 
for  example,  on  some  notion  of  distance  among  global  stores,  and  specify  effects  of  actions 
as  general 
in  this  case,  we  can  also 
that  must  hold  in  each  global 
address 
and  thus  is 
store.  Observe 
to  interpretations, 
action 
much  simpler  than  update  of  theories  discussed,  e.g.,  in  [31].  Research  on  d-family 
languages,  whose  semantics 
(which  is  essentially 
a  successor-state 

formulae  over  Prop  instead  of  literals.  Moreover 

indirect  effects  by  specifying  domain  constrains 

that  the  update  we  are  interested 

is  based  on  defining  a transition 

point 
the  set  a/{at, 

in  our  terms),  e.g.,  [2,5,23,39], 

function 
is  relevant. 

in  applies 

returning 

function 
Another  possible  extension  concerns 

the  state  of  the  world  at  a  given  point  by  a  set  of  atomic  propositions 

the  form  of  the  global  store.  In  the  present  work, 
in  the 
we  describe 
global  store.  That  is,  the  global  store  can  be  thought  of  as  a  set  of  boolean  variables, 
one  for  each  atomic  proposition.  A  possible  extension 
a  set  of  multi-valued 
domain.  Such  an  extension 
way  transition 
verification  needs  to  be  extended 
expressed 
order  logic  plus  fixpoints 
relevant. 

the  global  store  as 
over  some  fixed 
the 
Indeed, 
the  logic  used  for 
the  new  kind  of  properties 
in  Databases  on  query  languages  based  on  first- 
e.g.,  [4],  are 

systems  are  built  remains  essentially 

(see,  e.g.,  [l])  and  that  on  complex 

variables,  or  even  as  a  first-order 

can  be  easily  accommodated 

in  the  global  store.  Research 

in  order  to  take  into  account 

the  same,  while 

in  our  setting. 

is  to  consider 

interpretation 

transactions 

Finally, 

introduced 

incomplete 

let  us  consider  again 

the  levels  of  abstractions 

in  Section  1.  We 
believe  that  it  is  of  great  interest  mixing  representations 
at  level  2  and  at  level  3, by  mixing 
the  process  algebra  approach  presented  here  with  the  usual  logical  approach.  This  would 
allow  us  to  introduce 
in  a  better  controlled  way.  For  example,  we 
could  specify  agents  whose  behavior 
presented  here,  and  agents  whose  behavior 
for  the  environment) 
in  process  algebras 
logics 
description  of  a  transition 

is  completely  known  by  means  of  process  description 
typically 
is  only  partially  known  (as  happens 
by  logical  axioms.  To  this  end,  the  research  on  “loose  specification” 
on  description 
as  a  partial 

[7,35],  as  well  as  research 

(which  can  be  interpreted 

system)  [ 131, is  relevant. 

that  include  assertions 

about  “individuals” 

representation 

in  knowledge 

information 

96 

X.J.  Chen.  6.  De  Giucomo  /Artificial 

Intelligence  107  (1999)  63-98 

Acknowledgements 

We  are  deeply 

for  invaluable  discussions 
to  Rocco  De  Nicola 
algebra  and  modal  mu-calculus.  Also  we  would  like  to  thank  the  anonymous 
their  remarks  which  have  improved  both  the  style  and  the  content  of  the  paper. 

indebted 

on  process 
referees  for 

References 

( I]  S.  Abiteboul.  R.  Hull,  V. Vianu,  Foundations  of  Databases.  Addison  Wesley,  Reading,  MA,  1995. 
[2]  C.  Baral,  M.  Gelfond,  Representing 

in  extended 

concurrent 

actions 

International 

Joint  Conference  on  Artificial 

Intelligence 

131 J.  Bergstra.  J.  Klop,  Process  algebra  for  synchronous 

communication, 

137. 

logic  programming, 
(IJCAI-93),  ChambCry,  France,  1993,  pp.  86687 

in:  Proc.  13th 
I. 
Inform.  and  Control  60  (1984)  109- 

[4]  A.J.  Bonner,  M.  Kifer.  Concurrency 

and  communicauon 

in  transaction 

logic, 

in:  Proc.  5th  International 

Conference  on  Database  Theory  (ICDT-95),  1995. 

[5]  S.-E.  Bomscheuer,  M.  Thielscher,  Representing 

concurrent 
in  Pure  and  Applied  Logics  (IGPL)  (Special 

Interest  Group 
(1996)  3.55-368. 

actions  and  solving  conflicts. 
Journal  of  the 
issue  of  the  ESPRIT  project  MEDLAR)  4  (3) 

[6]  G.  Boudol,  R.  de  Simone,  V. Roy.  D.  Vergamini,  Process  calculi,  from  theory  to  practice:  Verification 

tools, 
in:  Proc.  Workshop  on  Automatic  Verification  Methods  for  Finite  State  Systems,  Lecture  Notes  in Computer 
Science,  Vol.  407,  Springer,  Berlin.  1990. 

171 G.  Boudol,  K.  Larsen,  Graphical  versus  logical  specifications,  Theoret.  Comput.  Sci.  106  (1992)  3-20. 
[8]  T.  Bylander,  Complexity 

in:  Proc.  12th  International 

results  for  planning, 

Joint  Conference  on  Artificial 

Intelligence 

(IJCAI-9  I),  Sydney,  Australia, 

I99  1, pp.  274-279. 

[9]  R. Cleaveland,  Tableaux-based  model  checking 

in the  propositional  mu-calculus,  Acta  Informatica  27  (1990) 

725-747. 

[IO] R. Cleaveland,  J.  Parrow,  B.  Steffen,  The  concurrency  workbench:  A semantics-based 

tool  for  the  verification 

of  concurrent 

systems,  ACM  Trans.  Programming  Languages  Syst.  15 (1993)  36-72. 

) 1 l]  R.  Cleaveland,  S.  Sims,  The  NCSU  concurrency  workbench, 

in:  Computer-Aided  Verification 

(CAV-9h), 

Lecture  Notes  in  Computer  Science,  Vol.  1102, Springer.  Berlin,  1996,  pp.  394-397. 

[ 121 M.  Dam,  CTL*  and  ECTL*  as  fragments  of  the  modal  mu-calculus, 

in:  Proc.  Colloquium  on  Trees  and 
in  Programming,  Lecture  Notes  in  Computer  Science,  Vol.  581,  Springer,  Berlin.  1992,  pp.  14% 

Algebra 
164. 

[ 131 G.  De  Giacomo,  M.  Lenzerini,  Boosting 

the  correspondence 

between  description 

logics  and  propositional 

logics. 

dynamic 
pp.  205-2  12. 

in:  Proc.  12th  National  Conference  on  Artificial  Intelligence 

(AAAI-94),  Seattle,  WA.  1994, 

[14]  G.  De  Giacomo.  H.J.  Levesque.  Y.  Lesperance.  Reasoning 
interrupts,  and  exogenous  action  in  the  situation  calculus, 
Artificial  Intelligence 

(IJCAI-97),  Nagoya,  Japan,  1997. 

abour  concurrent 

executions. 

prioritized 

in:  Proc.  15th  International 

Joint  Conference  on 

[IS]  G.  De  Giacomo,  R.  Reiter,  M.  Soutchanski.  Execution  monitoring  of  high-level 

robot  programs, 

in:  Proc. 

6th  International  Conference  on  Principles  of  Knowledge  Representation 

and  Reasoning 

(KR’98).  1998. 

[ 161  R.  De  Nicola,  Extentional  equivalences 
[ 171 E.  Emerson, 
J.  HaIpem,  “Sometimes” 
temporal 

logic,  J.  ACM  33  (1)  (1986)  151-178. 

for  transition  system,  Acta  Informatica  24  (1987)  2 I l-237. 
and  “not  never”  revisited:  On  branching 

time  versus 

linear 

time 

[ 181 E.A.  Emerson,  Handbook  of  Theoretical  Computer  Science,  Vol. B,  Elsevier,  Amsterdam,  1990,  Chapter  16. 
in:  Logics  for  Concurrency:  Structure 
1191 E.A.  Emerson.  Automated 

temporal  reasoning  about  reactive  systems, 

versus  Automata,  Lecture  Notes  in  Computer  Science,  Vol.  1043,  Springer,  Berlin,  1996,  pp.  41-101. 

[ZO] E.A.  Emerson,  C.S.  Jutla,  The  complexity  of  tree  automata  and  logics  of  programs, 

in:  Proc.  20th  Annual 

Symposium  on  the  Foundations  of  Computer  Science,  1988,  pp.  328-337. 

(211  E.A.  Emerson,  C.S.  Jutla,  A.P.  Sistla,  On  model  checking 

in:  Proc.  5th 
International  Conference  of  Computer-Aided  Verification,  Lecture  Notes  in  Computer  Science,  Vol.  697, 
Springer,  Berlin.  1993,  pp.  38.5-396. 

for  fragments  of  the  mu-calculus, 

X.J.  Chen,  G.  De  Giacomo 

/Artificial 

Intelligence  107  (1999)  63-98 

91 

[22]  E.A.  Emerson,  C.-L.  Iei,  Efficient  model  checking 

in  fragments  of  the  mu-calculus, 

in:  Proc.  1st  IEEE 

Symposium  on  Logics 

in  Computer  Science  (LICS’86),  1986,  pp.  267-278. 

[23]  M.  Gelfond,  V.  Lifschitz,  Representing 

action  and  change  by  logic  programs, 

J.  Logic  Programming 

17 

(1993)  301-322. 

[24]  M.  Gelfond,  V. Lifschitz,  A.  Rabinov,  What  are  the  limitations  of  the  situation  calculus? 

in:  R.  Boyer  (Ed.), 

Automated  Reasoning:  Essays  in  Honor  of  Woody  Bledsoe,  Kluwer,  Dordrecht,  1991,  pp.  167-179. 

[25]  S.  Graf,  J.  Sifakis,  A  model  characterization 

of  observational 

congruence  on  finite  terms  of  CCS,  Inform. 

and  Control  68  (1986)  125-145. 

1261 F.N.H.R.  Nielson,  Semantics  with  Applications,  Wiley,  New  York,  1992. 
[27]  J.Y.  Halpem,  M.Y.  Vardi,  Model  checking  vs.  theorem  proving:  A  manifesto, 

Intelligence 
Press,  New  York,  1991,  pp.  151-176. 

and  Mathematical  Theory  of  Computation-Papers 

in:  V  Lifschitz  (Ed.),  Artificial 
in  Honor  of  John  McCarthy,  Academic 

[28]  M.  Hennessy,  R.  Milner,  Algebraic 

laws  for  nondeterminism 

and  concurrency, 

J.  ACM  32  (1)  (1985)  137- 

161. 

[29]  Y.  Hirishfeld,  F.  Moller,  Decidability 

results 

in  automata  and  process 

theory, 

in:  Logics  for  Concurrency: 

Structure  versus  Automata,  Lecture  Notes  in  Computer  Science,  Vol.  1043,  Springer,  Berlin,  1996,  pp.  102- 
148. 

[30]  C.  Hoare,  Communicating 
[31]  H.  Katsuno,  A.  Mendelzon,  On  the  difference  between  updating  a  knowledge 

Sequential  Processes,  Prentice  Hall,  London,  1985. 

Proc.  2nd  International  Conference  on  the  Principles  of  Knowledge  Representation 
91),  Cambridge,  MA,  1991,  pp.  387-394. 

base  and  revising 
and  Reasoning 

it,  in: 
(KR- 

[32]  D.  Kozen,  Results  on  the  propositional  mu-calculus,  Theoret.  Comput.  Sci.  27  (1983)  333-355. 
[33]  D.  Kozen,  R.  Pa&h,  A  decision  procedure 

for  the  propositional  mu-calculus, 

in:  Proc.  2nd  Workshop  on 

Logic  of  Programs,  Lecture  Notes  in  Computer  Science,  Vol.  164,  Springer,  Berlin,  1983,  pp.  3 13-325. 

[34]  D.  Kozen,  J.  Tiuryn,  Logics  of  programs, 

in:  J.  van  Leeuwen 

(Ed.),  Handbook  of  Theoretical  Computer 

Science,  Elsevier,  Amsterdam, 

1990,  pp.  790-840. 

[35]  K.G.  Larsen,  L.  XinXin,  Compositionality 

through  an  operational 

semantics  of  contexts,  J.  Logic  Comput. 

1 (6)  (1991)  761-795. 

[36]  K.J.  Larsen,  Proof  systems  for  satisfiability 

in  Hennessy-Milner 

logic  with  recursion,  Theoret.  Comput.  Sci. 

72  (1990)  265-288. 

[37]  H.  Levesque,  R.  Reiter,  Y.  Lesperance,  F.  Lin,  R.  Scherl,  GOLOG:  A  logic  programming 

language 

for 

dynamic  domains,  J.  Logic  Programming 

3 1 (1997)  59-84. 

[38]  V. Lifschitz,  Frames  in  the  space  of  situations,  Artificial 
effects 
[39]  V.  Lifshitz,  G.  Karta,  Actions  with 

indirect 

Intelligence  46  (1990)  365-376. 
(preliminary 

report), 

in:  Proc.  4th  International 

Conference  on  the  Principles  of  Knowledge  Representation 
pp.  341-350. 

and  Reasoning 

(KR-94),  Bonn,  Germany,  1994, 

[40]  F. Lin,  R.  Reiter,  State  constraints 

revisited,  J.  Logic  Comput. 

(Special  Issue  on  Action  and  Processes)  4  (5) 

(1994)  655678. 

[41]  F. Lin,  Y. Shoham,  Provably  correct  theories  of  action  (preliminary 

report),  in:  Proc.  9th  National  Conference 

on  Artificial 

Intelligence 

(AAAI-91),  Anaheim,  CA,  1991,  pp.  349-354. 

[42]  F.  Lin,  Y.  Shoham,  Concurrent 

actions 

in  the  situation  calculus, 

in:  Proc.  10th  National  Conference  on 

Artificial 

(AAAI-92) 
[43]  Z.  Manna,  A.  Pnueli,  The  anchored  version  of  the  temporal 

San  Jose,  CA,  1992,  pp.  59@595. 

Intelligence 

in:  J.  de  Bakker,  P.  de  Roever, 
(Eds.),  Linear  Time,  Branching  Time  and  Partial  Order  in Logics  and  Models  for  Concurrency, 

G.  Rozenberg 
Lecture  Notes  in  Computer  Science,  Vol.  354,  Springer,  Berlin,  1989,  pp.  201-284. 

framework, 

[44]  K.L.  McMillan,  Symbolic  Model  Checking,  Kluwer,  Dordrecht,  1993. 
[45]  R.  Mimer,  Communication 
[46]  Y.N.  Moschovakis,  Elementary 
[47]  D.  Park,  Fixpoint 

induction  and  proofs  of  program  properties, 

and  Concurrency,  Prentice  Hall,  London,  1989. 

Induction  on  Abstract  Structures,  North-Holland,  Amsterdam, 

1974. 

in:  B.  Meltzer  and  D.  Michie  (Eds.),  Machine 

Intelligence,  Vol.  5,  Edinburgh  University  Press,  1970,  pp.  59-78. 

[48]  J.A.  Pinto,  Temporal 

reasoning 

in  situation  calculus,  Ph.D.  Thesis,  Department 

of  Computer  Science, 

University  of  Toronto,  1994. 
[49]  R.  Reiter,  The  frame  problem 

result 
Computation:  Papers  in  Honor  of  John  McCarthy,  Academic  Press,  New  York,  1991,  pp.  359-380. 

in:  V  Lifschitz 

(Ed.),  Artificial 

in  the  situation  calculus:  A  simple  solution  (sometimes)  and  a  completeness 
Intelligence 

and  Mathematical 

regression, 

for  goal 

Theory  of 

98 

X. J.  Chcn,  G.  De  Giacomo  /  Artijiciul  tntdli~ence  107  (I 999)  63-98 

[50]  R.  Reiter,  Natural  actions,  concurrency 

and  continuous 

time 

International  Conference  on  Principles  of  Knowledge  Representation 
Z-13. 

in  the  situation  calculus, 
and  Reasoning 

in:  Proc.  5th 
(KR’96),  1996,  pp. 

(5 I]  S. Rosenschein,  Plan  synthesis:  A  logical  approach, 

in:  Proc.  8th  International 

Joint  Conference  on  Artificial 

Intelligence 

(IJCAI-81),  Vancouver,  BC,  1981. 

[52]  B.  Steffen,  Characteristic 

formulae,  Proc.  ICALP,  Lecture  Notes  in  Computer  Science,  Vol.  372,  Springer, 

Berlin,  1989,  pp.  723-732. 

[53]  B.  St&en,  A.  Ingolfsdottir,  Characteristic 

formulae  for  processes  with  divergence, 

Inform.  and  Comput.  110 

(I)  (1994)  149-163. 

[54]  C.  Stirling,  Modal  and  temporal 

logic,  in:  S.  Abramsky,  D.M.  Gabbay,  T.S.E.  Maibaum 

(Eds.),  Handbook 

of  Logic  in  Computer  Science,  Clarendon  Press,  Oxford,  1992,  pp.  477-563. 

1551 C.  Stirling,  Modal  and  temporal 

logics  for  processes, 
Lecture  Notes  in  Computer  Science,  Vol.  1043,  Springer,  Berlin,  1996,  pp.  149-237. 

in:  Logics  for  Concurrency:  Structure  versus  Automata, 

[56]  R.S.  Streett,  E.A.  Emerson,  The  propositional  mu-calculus 

is  elementary, 

in:  Proc.  6th  International 

and  Programming, 

Lecture  Notes  in  Computer  Science,  Vol.  172, 

Colloquium  on  Automata,  Languages 
Springer,  Berlin,  1984,  pp.  465472. 
[S7]  R.S.  Streett,  E.A.  Emerson,  An  automata 

Inform.  and  Control  81  (1989)  249-264. 

theoretic  decision  procedure 

for  the  propositional  mu-calculus, 

[58]  A.  Tarski,  A  lattice-theoretical 
[59]  E.  Temovskaia, 
153-164. 

Iixpoint  theorem  and  its  applications,  Pacific  .I. Math.  5  (1955)  285-309. 

Interval  situation  calculus, 

in:  Proc.  ECAI’94  Workshop  on  Logic  and  Change,  1994,  pp. 

[60]  J.  van  Benthem,  J.  van  Eijck,  V  Stebletsova,  Modal  logic,  transition  systems  and  processes,  J.  Logic  Comput. 

4  (5)  (1994)  81 l-855. 

1611 R.  van  Glabbeek,  The  linear  time-branching 

time  spectrum,  CONCUR’90,  Lecture  Notes  in  Computer 

Science,  Vol.  458,  Springer,  Berlin,  1990.  pp.  278-297. 

]62]  G.  Winskel,  A  note  on  model  checking 

in:  Proc.  11 th  International  Colloquium  on 
and  Programming,  Lecture  Notes  in  Computer  Science,  Vol.  372,  Springer,  Berlin, 

il-calculus, 

the  modal 

Automata,  Languages 
1989,  pp.  761-772. 

