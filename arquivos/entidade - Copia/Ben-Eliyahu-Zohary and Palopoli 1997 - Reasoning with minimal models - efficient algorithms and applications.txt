Artificial  Intelligence 96 ( 1997) 42 l-449 

Artificial 
Intelligence 

Reasoning  with  minimal  models: 
efficient  algorithms  and  applications 

1 

Rachel  Ben-Eliyahu-Zohary  a**, Luigi  Palopoli  b*2 
a Mathematics  and  Computer  Science  Department,  Ben-Gurion  University of  the Negev, 
Beer-Sheva  84105,  Israel 
b DEIS,  Universitd della  Calabria,  87030  Rende  (CS),  Italy 

Received September 1996 

Abstract 

Reasoning  with  minimal  models  is  at  the  heart  of  many  knowledge-representation  systems.  Yet 
it  turns  out  that  this  task  is  formidable,  even  when  very  simple  theories  are  considered.  In  this 
paper,  we  introduce  the  elimination  algorithm,  which  performs,  in  linear  time,  minimal  model 
finding  and  minimal  model  checking  for  a  significant  subclass  of positive  CNF  theories  which  we 
call  positive  head-cycle-free  (HCF)  theories.  We  also  prove  that  the  task  of  minimal  entailment 
is  easier  for  positive  HCF  theories  than  it  is  for  the  class  of  all  positive  CNF  theories.  Finally, 
we  show  how  variations  of  the  elimination  algorithm  can  be  applied  to  allow  queries  posed  on 
disjunctive  deductive  databases  and  disjunctive  default  theories  to be  answered  in  an  efficient  way. 
@  1997  Published  by  Elsevier  Science  B.V. 

Keywords:  Minimal  models;  Disjunctive  databases;  Disjunctive  default  logic;  Disjunctive  logic  programs; 
Stable  model  semantics;  Linear 

time  algorithms 

1.  Introduction 

Computing  minimal  models 

is  an  essential 

ficial  intelligence, 

including 

circumscription 

[ 29-3  11,  default 

logic 

task  in  many  reasoning 

systems 

in  arti- 
[ 391,  and  minimal 

* Corresponding author. Email: rachel@cs.bgu.ac.il. 
’ Part  of  this work was done  while  the  first  author  was  visiting 

the  Cognitive  Systems  Laboratory,  Computer 
Science  Department,  University  of  California,  Los  Angeles,  CA,  USA,  and  the  second  author  was  a  visiting 
scholar  at  the  Computer  Science  Department,  University  of  California,  Los  Angeles,  CA,  USA.  This  is  an 
on  Principles  of 
extended  and  revised  version  of  a  paper  presented  at  the  Fourth 
and  Reasoning,  Bonn,  Germany,  1994. 
Knowledge  Representation 

International  Conference 

* Email: 

luigi@si.deis.unical.it. 

0004-3702/97/$17.00 
PIISOOO4-3702(97)00060-X 

@  1997  Published  by  Elsevier  Science  B.V.  All  rights  reserved. 

422 

R.  Ben-Eliyahu-Zohary,  L.  PalopoWArtficial  Intelligence  96  (1997)  421-449 

diagnosis 
semantics 
sumption 
or  plausible 
gorithms 
systems. 

[ 121,  and  in  answering  queries  posed  on  logic  programs 
[4,21]) 
[32]). 

and  deductive  databases 
systems, 

the  generalized 
the  goal  is  to  produce  plausible 

In  such  reasoning 

(under 

(under  stable  model 
as- 
closed-world 

inferences 

explanations, 

not 

to  compute  minimal  models.  Nonetheless, 

for  computing  minimal  models  can  substantially 

speed  up  inference 

efficient 

al- 
in  these 

Surprisingly, 

and  perhaps  due  to  its  inherent  difficulty,  reasoning  with  minimal  models 
Given  a  propositional 
tasks  (and  others)  have  been  consid- 

[ 6,9-l  1,18,26,34]. 

has  received  a  formal  analysis  only  recently 
CNF  theory  T  and  a  literal  L  in  T,  the  following 
ered:  3 

is  a  minimal  model  for  T. 

l Model  finding.  Find  a  minimal  model 
l Model  checking.  Check  whether  a  given  interpretation 
l Minimal  entailment. 
l Minimal  membership. 
Unfortunately, 

for  T. 

the  results  of  the  formal  work  on  the  complexities 

Is  L  true  in  all  the  minimal  models  of  T? 

Is  L  true  in  at  least  one  minimal  model  of  T? 

minimal  models  are  discouraging. 
is,  when  the  theory  has  no  clause 
are  very  hard  to  answer:  model  finding 
always  have  a  minimal  model!)  4,  model  checking 
and  minimal  membership 
entailment 

is  II;-complete, 

is  P NP[o(lo@)]-hard 

(and  positive 

[lo] 
is  co-NP-complete 
is  X;-complete 

[ 181. 

It  turns  out  that  even  when  the  theory  is  positive, 
in  which  all  the  literals  are  negative, 

of  reasoning  with 
that 
these  questions 
theories 
[9],  minimal 

to  the  positive 

that  turns  out  to  characterize 

In  this  paper,  we  exploit  a  basic  property 

is  head-cycle-freeness 
the  negative 

a  subclass  of 
all  CNF  theories  for  which  the  above  and  related  problems  can  be  solved  efficiently.  The 
[ 71.  The  idea  is  simple.  A  clause  5  is  viewed  as  having  a 
property 
direction-from 
is  made  explicit 
in  the  way  clauses  are  represented 
in  logic  programs.  We  then  associate  a  dependency 
graph  with  each 
an  arc  directed 
and  there  is  an  arc  directed 
positive 
dependency 
appear  positive 
in  the  size  of  the  theory. 

is 
in  S, 
if  A  appears 
if  and  only  if  in  its 
that 
in  time  linear 

graph  there  is  no  directed  cycle  that  goes  through 

in  6.  A  CNF  theory  will  be  called  head-cycle-free 

from  a  clause  S  to  an  atom  A  if  and  only 

from  an  atom  A  to  a  clause  6  if  and  only 

in  the  same  clause.  Head-cycle-freeness 

theory:  each  atom  and  each  clause 

if  A  appears  negative 

two  different  atoms 

can  be  checked 

in  the  graph; 

this  direction 

literals-and 

is  a  node 

(HCF) 

there 

We  show 

that  for  positive  HCF 

theories, 

the  above  problems 

are  more  manageable 

time  in  the  size  of  the  theory,  minimal 

than  they  are  in  the  general  case:  model 
linear 
minimal  membership 
are  summarized 
in  this  paper. 

is  NP-complete.  The  complexity 

in  Fig.  1.  Entries  without  a  reference  number 

entailment 

is  co-NP-complete 
results  for  propositional 
indicate 

in 
[20],  and 
theories 
results  presented 

finding  and  model  checking  can  be  done 

3 See  the  next  section  for  formal  definitions  of  minimal model,  interpretation,  and  IiteraZ. 
4 We  recall 

that  PNP[o(las  n)l  is  the  class  of  decision  problems 

that  are  solved  by  polynomial-time 

deterministic  Turing  machines  making  at  most  a  logarithmic  number  of  calls  to  an  oracle 
characterization 

of  model  finding,  given  in  terms  of  complexity 

of  the  complexity 

bounded 
in  NR  For  a  precise 
see 

classes  of  functions, 

[ill. 
5 In  this  section,  a  clause 

is  a  disjunction  of  literals. 

In  the  following 

sections  we  use  a  different  syntax. 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Ar@cial 

Intelligence  96  (1997)  421-449 

423 

Language 

CNF 

Model 
checking 

co-NP- 
complete 

Model 
finding 

NPMVllOptP[O(logn)]- 
complete 

[ 111 

[ 91 

Minimal 
entailment 

Minimal 
membership 

$-complete 

[ 181 

8;-complete 

[ 181 

positive  HCF 

O(n) 

O(n) 

co-NP-complete 

[ 201 

NP-complete 

Fig.  1.  Complexity  of  computational 

tasks  with  minimal  models. 

Our  algorithms  can  be  generalized 

to  allow  efficient  computation  of  minimal  Herbrand 

for  a  significant 

subclass  of  positive 

models 
apply  our  results  on  CNF  theories 
disjunctive 
[ 441  that  computes  a  stable  model  for  a  stratified  HCF  disjunctive  deductive  database  6 . 
This  algorithm  also  can  be  used  to  answer  queries  posed  on  disjunctive  default 
in  that  seemingly 

In  addition,  we 
that  use 
algorithm 

rules.  Specifically,  we  provide  a  polynomial-time 

to  answering  queries  on  deductive  databases 

first-order  CNF  theories. 

data  complexity 

form  a  relevant 
knowledge 

fragment  of  CNF  theories 
the  world 
about 

[ 16,19,27]. 

HCF  theories 
represent  meaningful 
theories 

is  formally  confirmed 

in  [ 271,  where  their  expressive  power  is  precisely 

The  rest  of  this  paper  is  organized  as  follows. 

In  Section  2,  we  present 

theories. 
they  can 
The  relevance  of  HCF 
stated. 
the  elimina- 
positive  HCF 

finding 

for  propositional 

tion  algorithm  which  performs  minimal  model 
theories,  and  consider 
entailment 
and  minirnal 
rithm  for  the  class  of  function-free 
demonstrate 
systems.  Related  work  is  discussed 
tion  6. 

some  applications 

of  the  elimination 

the  other  tasks  of  minimal  model  checking,  minimal  membership, 

for  this  class.  In  Section  3,  we  generalize 

first-order  positive  HCF  theories. 
algorithm 

in  Section  5,  and  conclusions 

in  knowledge-representation 
are  presented 

in  Sec- 

the  elimination 

algo- 
In  Section  4,  we 

2.  The  elimination  algorithm 

for  positive  HCF  theories 

In  this  section,  we  introduce 

the  elimination  algorithm 

perform  minimal  model 
We  will  also  establish 
and  minimal  membership 

finding  on  a  propositional 

positive  HCF  theory 

the  complexity  of  minimal  model  checking,  minimal 

(EA),  which  can  be  used  to 
time. 
entailment, 

in  linear 

for  propositional 

positive  HCF  theories. 

We  defilne  a  theory  T  to  be  a  set  of  clauses  of  the  form 

(1) 

the  body  of  the  clause,  while 

where  IZ, m  >  0  and  all  the  A’s  and  the  C’s  are  atoms.  7  The  expression 
-+  is  called 
the  head  of  the  clause.  We  assume 
positive 
we  state  otherwise. 

to  the  left  of 
to  the  right  of  --f  is  called 
that  all  of  the  Cs  are  distinct.  A  theory  T  is  called 
theories,  unless 

if,  for  every  clause,  n  >  0.  In  this  section,  we  deal  with  positive 

the  expression 

6 Stable  models  and  srra@ied  disjunctive  deductive  databases  will  be  defined  in  the  following 
the  equivalent  notation 
’  Note  that  the  syntax  of  (1) 

for  a  clause;  usually, 

is  a  bit  unusual 

sections. 
-Al  V  -A2  V 

. .  V  -A,,,  \I Cl  V  C2  V  . . . V  C,  is  used. 

424 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Artijicial  Intelligence  96  (1997)  421-449 

A  set  of  atoms  satisfies  the  body  of  a  clause  if  and  only  if  all  the  atoms  in  the  body 
to  this  set.  A  set  of  atoms  violates  a  clause  if  and  only  if  the  set 
of  the  clause  belong 
the  body  of  the  clause  but  none  of  the  atoms  in  the  head  of  the  clause  belongs 
satisfies 
to  the  set.  A  set  of  atoms  X  is  a  model  of  a  theory  T  if  none  of  its  clauses 
is  violated 
by  X.  A  model  X  of  a  theory  T  is  minimal  if  there  is  no  Y c  X  that  is  also  a  model  of 
in  T. 
T.  An  interpretation  for  a  theory  T  is  an  assignment 
Interpretations 
the 
value  true.  A  literal is  an  atom  (“positive” 

and  models  will  be  represented  by  the  set  of  atoms  being  assigned 

literal)  or  a  negated  atom  (“negative” 

of  truth  values 

to  the  atoms 

literal). 

With  every  theory  T  we  associate  a  directed  graph  Gr,  called  the  dependency  graph * 
of  T,  in  which 
(a)  each  atom  A  and  each  clause  6  in  T  is  a  node  and  (b) 
there  is  an 
arc  from  A  to  S  if  and  only  if  A  is  in  the  body  of  6  and  an  arc  from  S  to  A  if  and  only 
if  A  is  in  the  head  of  6. 

As  mentioned 

before,  model  finding 
is  co-NP-complete,  model  entailment 

for  positive 

theories 
is  II;-complete, 

is  PNPto(losn)l-hard,  model 
and  minimal  membership 

checking 
is  Z;-complete. 
problems 
only 
directed  cycle  involving  Ci  and  Cj.  So,  for  example, 
is  not  HCF,  while  the  theory  A  -+ B,  B  +  A,  A  V  C  is  HCF. 

From  the  work  of  [ 71  and  the  results  presented  here  it  follows  that  these 
are  easier  for  the  class  of  positive  HCF  theories.  A  theory  T  is  HCF  if  and 
a 
the  theory  A  +  B,  B  4  A,  A  V  B 

in  T  such  that  for  some  Ci  and  Cj,  i  #  j,  GT  contains 

is  no  clause 

if  there 

Proposition  1.  Head-cycle-freeness  of a propositional  theory T of size n can be  checked 
in  time  O(n).  9 

Proof.  The  algorithm 

for  checking  head-cycle-freeness 

consists  of  three  steps: 

the  strongly  connected  components.  This  can  be  done  in  time  linear  in  the 

1.  Construct  Gr,  the  dependency 
2.  Identify 

size  of  Gr  [43]. 

3.  For  every  clause,  check  whether 

graph  of  the  theory. 

the  same  component.  This  can  be  done  by  assigning 
its  component 
head. 
Since  each  step 
0 
time. 

and  then  checking  whether 

in  linear 

is  done 

time, 

there  are  two  atoms 

to 
in  its  head  that  belong 
to  each  atom  the  number  of 
the  same  number  appears  twice  in  some 

the  whole  algorithm 

can  be  done 

in  linear 

2.1.  Model finding 

Clearly, 

just  any  model 

for  a  positive 
the  set  of  all  atoms  in  the  theory.  What  is  difficult 

example, 
for  the  theory.  Roughly  speaking, 
the  idea  behind 
we  pick  a  model  of  the  theory  and  then  eliminate  from  this  model  all  the  atoms 

for 
is  finding  a  minimal  model 
the  EA,  shown  in  Fig.  2,  is  as  follows: 
that 

theory  can  be  found  very  easily-take, 

8 In  [ 71  a  different definition of  dependency graph is  given, hut the two  definitions are equivalent when 
defining HCF  theories.  The  dependency  graph  as defined  here  has  the  advantage  that  it  can  be  constructed  in 
linear  time. 

9 Throughout  the  paper,  the  size  of  a theory  is  the  number  of  symbols  (characters)  it  contains. 

R.  Ben-Eliyahu-Zohary  L.  Palopoli/Arti@ial  Intelligence  96  (1997)  421-449 

425 

EMT) 

Input:  A  positive  HCF  theory  T. 
Output:  A  minimal  model  for  T. 

1.  M  :=a model  of  T,  M’  :=  0. 
2.  Let A  be  the  set  of  all  clauses  6 in  T  violated  by  M’  such  that  1 head( 8, M)  1 = 1. 

If  A =  8,  go  to  Step  3. 
Else,  let  X  := n,,, 
repeat  Step  2. 

head(&M);M’:=M’nX;M:=M-X; 

3.  Let  A  be  the  set  of  all  clauses  6  in  T  violated  by  M’  such  that  for each  6 E  A,  Ihead(8,  M)I  >  2. 

If  A =  0,  return  M’. 
Else,  let  H  :=  (I,,, 

head(S,  M)  and  let  X be  a source  of  H  in  &; 

let  M  :=  M  -  X;  go  to  Step  2. 

Fig.  2.  The  elimination  algorithm  for  positive  HCF theories. 

we  know  will  not  be  part  of  one  of  the  minimal  models 
(hence, 

the  name  of  the  algorithm). 

that  are  subsets  of  this  model 

component 

in  X.  Intuitively, 

(b)  all  the  nodes 

in  G,  a  set  X  of  nodes 

Given  a  directed  graph  G  and  a  set  Y  of  nodes 

in  G  will  be 
in  X  are 
called  a  source  of  Y  if  and  only  if  (a)  X  fl  Y is  not  empty, 
in  G,  lo  and  (c)  for  each  node  A  in  Y -  X, 
in  the  same  strongly  connected 
there  is  no  directed  path  in  G  from  A  to  any  of  the  nodes 
if  X  is  a 
source  of  Y in  a  dependency  graph  of  some  theory,  then  none  of  the  atoms  in  Y -  X  can 
be  used  to  derive  any  of  the  atoms  in  X.  At  the  generic  step  of  the  execution  of  the  EA, 
we  have  a  “current” 
theory.  Then  we  eliminate 
model  M  of  the  input 
that  turn  out  to 
subsets  of  atoms  from  M  in  a  way  that  prevents  elimination 
be  part  of  a  minimal  model.  To  this  end,  if  S  is  the  set  of  atoms  that  are  candidates 
for 
elimination,  we  delete  a  source  of  S.  At  Step  3  of  the  EA,  we  delete  a  source  of  the 
in  the  heads  of  clauses  violated  by  M’.  Since  each  such  clause  has  at 
set  of  all  atoms 
the  case  that  each 
least  two  atoms  in  its  head,  and  since  the  theory  is  HCF,  it  is  always 
that  belong 
clause 
strongly 
graph  of  the  theory.  Therefore,  we  can  always 
connected.  components 
find  a  nonempty 

in  this  set  has  in  its  head  atoms 
in  the  dependency 

two  different 

(non-minimal) 

to  at  least 

of  atoms 

source 

Given  a  set  X,  1x1  denotes 

of  X.  The  EA  uses  the  function  head(  ), 
which  is  defined  as  follows:  given  a  clause  6  and  a  set  of  atoms  M,  he&(&  M)  is  the 
to  the  head  of  6. 
set  of  all  atoms  in  M  that  belong 
The  proof  of  the  following 

and  therefore  appears 

involved 

theorem 

is  quite 

in  the 

Appendix. 

Theorem  2  (The  EA  is  correct). 
generates  a  minimal  model  of  T. 

Given  a  positive  HCF 

theory  T  as  input, 

the  EA 

The  choice  of  the  model  to  start  with  (Step  1)  can  be  looked  at  as  a  nondeterministic 

step.  Indeed, 

for  different 

initial  models, 

the  EA  may  output  different  minimal  models. 

lo A  strongly  connected  component  C  of  a  directed  graph  G is  a  maximal  subgraph  of  G  such  that  for  each 
pair  of  nodes  ~1 and  v2 in  C,  C  contains  both  a directed  path from  01 to  ~2 and  a directed  path  from  ~2 to  q. 

in  Step  3  of  the  EA. 
the  cardinality 

426 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Arti$cial  Intelligence  96  (1997)  421-449 

In  fact,  the  EA  is  able  to  generate  any  of  the  minimal  models  of  the  input  theory.  Before 
proving 

to  state  the  following 

it  is  useful 

this  result, 

lemma. 

Lemma  3. 
the  input  positive  HCF  theory  T, the  EA  will  output  this  minimal  model. 

In  any  execution  of  the  EA,  if  M  is  initialized  to  some  minimal  model  of 

in  M  has  a  proof  with  respect 

j@. By 
Proof.  Suppose  we  begin  execu$ng  EA(T)  with  M  set  to  some  minimg  model 
to  T  and  M.  Let  k  be  the 
Theorem  A. 1,  every  atom 
proof  of  an  atom  from  G.  It 
maximum  number  of  clauses  used  in  any  minimal-length 
that  EA(T)  will  run  as  follows:  Step  2  will  be  executed  at  most  k 
is  easy  to  verify 
to  M’  all  the  atoms  having  a  proof  of  1engtJh at  most  i  by  the 
times 
i-th  iteration,  and  then  M’  will  be  returned  at  Step  3.  Hence,  M’ = M  will  be  generated 
by  the  EA. 

in  a  row,  adding 

0 

Proposition  4  (Nondeterministic 
HCF  theory  T, then  there  is an  execution  of  the  EA  that  outputs  M. 

completeness). 

If  M  is a minimal  model  of a positive 

Proof.  Suppose  M  is  a  minimal  model  of  T.  There  is  an  execution  of  EA(T) 
that  picks 
the  model  M  in  Step  1.  By  Lemma  3,  if  the  EA  starts  with  a  minimal  model  M,  it  will 
output 

this  model.  Hence, 

the  result  follows. 

0 

The  following 

example  demonstrates 

how  the  EA  works. 

Example  5.  Suppose  we  have  the  theory 

1.  aVb 

2.  b-+a 

3.  aVc 

and  suppose  we  start  the  EA  with  M  =  {a,  b, c}.  At  Step  1  of  the  EA,  M’  =  8.  At 
the  clauses  violated  by  M’  are  the  first  and  third 
Step  2,  we  get  that  A  = 8,  because 
to  M.  Since  A  is  empty,  we  go  to  Step  3, 
clauses  but  both  atoms  in  their  heads  belong 
and  in  Step  3,  we  get  A  := {a  V  b, a  V  c}.  Since  {b}  is  a  source  of  {a,  b, c}  (note 
that  {c}  is  also  a  source;  we  will  describe  shortly  what  happens  when  we  choose  {c}), 
we  delete  {b}  from  M  and  are  left  with  M  = {a,~},  and  we  go  to  Step  2.  In  Step  2, 
we  now  get  A  = {a  V  b},  so  we  add  {a}  to  M’  and  delete  {a}  from  M,  which 
leaves 
us  with  M’  =  {a}  and  M  = {c}.  We  then  repeat  Step  2,  but  this  time  we  get  A  = 0 
is  violated  by  M’),  and  so  we  go  to  Step  3.  In  Step  3  we 
(because  none  of  the  clauses 
also  have  A = 0,  so  the  EA  in  this  case  returns  {a}.  Indeed,  {a}  is  a  minimal  model  for 
the  theory. 

Let  us  now  follow  the  option  of  choosing  {c}  instead  of  {b}  as the  source  of  {a,  b, c} 
the  first  time  Step  3  is  executed.  We  delete  {c}  from  M  and  are  left  with  M  = {a,  b}, 
and  we  go  to  Step  2.  In  Step  2,  we  now  get  A = {aV  c},  so we  add  {a}  to  M’  and  delete 
leaves  us  with  M’  = {a}  and  M  = {b}.  We  then  repeat  Step  2,  but 
{a}  from  M,  which 
is  violated  by  M’),  and  so  we  go 
this  time  we  get  A = 0  (because  none  of  the  clauses 

R.  Ben-Eliyahu-Zohary,  L.  PalopoWArtijcial  Intelligence  96  (1997)  421-449 

427 

to  Step  3.  In  Step  3,  we  also  have  d  =  0,  so  the  EA  in  this  case  too  returns  {u}.  Indeed, 
{u}  is  the  only  minimal  model  for  the  theory. 

The 

theory  of  Example  5  has  only  one  minimal  model. 

In  the  next  example, 

the 

theory  has  several. 

Example  6.  Suppose  we  have  the  theory 

1. 

,aVb 

3.  <aVc 

and  suppose  we  start  the  EA  with  M  =  {a,  b,  c}.  At  Step  1 of  the  EA,  M’  = 8.  At  Step  2, 
we  get  thiat  d  =  0,  because  although  all  the  clauses  are  violated  by  M’,  all  the  atoms 
in  their  heads  belong 
to  M.  Since  A  is  empty,  we  go  to  Step  3,  and  in  Step  3  we  get 
A  :=  {all  the  clauses}.  Since  {a},  {b},  and  {c}  are  each  a  source  of  {a,  b, c},  we  can 
delete  from  M  any  one  of  them.  Suppose  we  delete  {b}.  We  are  left  with  M  =  {a,  c}, 
and  we  go  to  Step  2.  In  Step  2,  we  now  get  A  =  {a  V b,  b  V c},  so  we  add  {a,  c}  to  M’ 
and  delete  {a,  c}  from  M,  which  leaves  us  with  M’  = {a,  c}  and  M  = 8.  We  then  repeat 
Step  2,  but  this  time  we  get  A  = 8,  so  we  go  to  Step  3.  In  Step  3,  we  also  have  A  = 8, 
so  the  EA  in  this  case  returns  {a,  c}.  Indeed,  {a,  c}  is  a  minimal  model  for  the  theory. 
It  is  easy  to  see  that  the  EA  would  return  {a,  b}  or  {b,  c}  had  we  selected,  respectively, 
{c}  or  {a}  as  a  source. 

We  next  prove  that  the  EA’s  time  complexity 

is  linear. 

Theorem  7  (Complexity). 
where  n  is  the  size  of  the  input  theory. 

For  positive  HCF 

theories, 

the  EA  runs 

in  time  O(n), 

Proof.  We  describe  briefly  how  the  EA  can  be  implemented 
[ 331,  we  assume 
data  structure  with  constant  access  time  can  be  used  for  storing 
variable. 

that  each  propositional 

variable 

in  linear 

time.  Following 

is  assigned  a  unique  number  so  that  a 
to  each 

the  data  related 

We  use  the  following  data  structures: 
l SCC  array:  An  array  indexed  by  the  strongly  connected  components 

entry  in  this  array  consists  of  the  set  of  atoms  that  belongs 
by  the  entry. 

( SCCs).  Each 
to  the  SCC  represented 

l AtomH  array:  An  array 

that  stores  for  each  atom  a  list  of  clauses 

in  which 

the 

atom  appears 

in  the  head. 

l AtomB  array:  An  array  that  stores  for  each  atom  a  list  of  clauses  in  which  the  atom 

appears 

in  the  body. 

l Rules  array:  An  array  that  stores  for  each  clause 
itself  as  a  linked 

( 1)  the  clause 

head  and  body  will  be  done 
atom  we  want  to  delete),  and 

list  (so  that  deletions  of  atoms  from  the  clause’s 
to  the 

time  once  we  have  a  pointer 

in  constant 

428 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Artifcial  Intelligence  96  (1997)  421-449 

(2) 

two  counters: 
Head-number 
Body-number 

of  atoms 
of  atoms  in  the  body. 

in  the  head,  and 

l  Unsat2clauses:  The  set  of  clauses  having  an  empty  body  and  a  head  of  size  >  2. 
l  Unsatlclauses: 
l MinSCC:  The  lowest  SCC  not  visited  yet. 
All  these  data  structures  can  be  initialized 
At  the  end  of  Step  2  of  the  EA,  we  set  Unsatlclauses 

The  set  of  clauses  having  an  empty  body  and  a  head  of  size  1. 

to  8.  Then,  for  each  atom  A  in 

in  linear 

time. 

X  (X  as  in  Step  2)  we  do  the  following: 

the  array  AtomB,  delete  A  from  the  body  of  each  clause 

Using 
in  which  A  ap- 
pears,  and  update  the  counter  Body  for  this  clause  (namely,  do  Body  := Body-  1) . 
If  Body  becomes  0,  then  add  the  clause  to  either  Unsat2clauses  or  Unsatlclauses, 
depending  on  the  number  of  atoms  in  the  head. 

Step  3  is  done  as  follows. 
that  appears 

may  be  an  atom 
atom  A  that  belongs 

to  MinSCC,  we  do  the  following: 

In  MinSCC  we  have  the  minimum  SCC  in  which 
in  the  head  of  some  clause 

there 
in  Unsat2cZauses.  For  each 

Delete  A  from  the  head  of  each  clause,  using 
Move  clauses 

from  Unsat2clauses 

to  Unsatlclauses 

the  appropriate  pointer 
if  necessary. 

in  AtomH. 

At  the  end  of  Step  3,  we  increase 

added 
to  Unsat2clauses 
an  SCC  that  is  lower 
than  MinSCC,  because  we  have  removed 
heads.  Also,  any  clause  added  to  Unsat2clauses  or  Unsatlclauses 
not  originally  have  had  an  atom  in  its  head  that  belongs 
of  how  the  dependency 

the  counter  MinSCC  by  one.  Note  that  any  clause 
to 
in  the  future  cannot  have  an  atom  in  its  head  that  belongs 
such  atoms  from 
the 
at  a  later  step  could 
to  the  current  MinSCC  because 

graph  is  built. 

In  this  way,  each  clause 

is  visited  at  most  k  times,  where  k  is  the  number  of  atoms 
is  a 

is  visited,  we  spend  an  amount  of  time  which 

in  the  clause.  Each  time  a  clause 
constant.  Hence, 

the  algorithm 

is  linear. 

0 

2.2.  Other  computational 

tasks 

We  will  now  consider  other  computational 

tasks  needed 

for  reasoning  with  minimal 

models. 

Model  checking 

for  a  positive  HCF  theory  can  also  be  done  in  time  linear 

in  the  size 

of  the  theory.  This  is  due  to  the  fact  that  if  we  start  executing 
to  some  minimal  model, 

this  will  be  the  model 

that  it  outputs.  Hence, 

the  EA  with  M  initialized 

Theorem  8  (Model  checking). 
HCF  theories 

in  time  O(n)  ,  where  n  is  the  size  of  the  theory. 

The  EA  solves  model  checking  for  the  class  of positive 

Proof.  By  Lemma  3,  when  at  Step  1  of  the  EA,  M  is  initialized 
model  of  T,  the  EA  will  output  M.  Therefore, 
given  interpretation 
$ 
step  checks  whether  6 

to  be  some  minimal 
for  checking  whether  a 
the  algorithm 
is  a  minimal  model  for  a  theory  T  consists  of  two  steps.  The  first 
time).  The  second  step 
is  a  model  for  T  (can  be  done  in  linear 

R.  Ben-Eliyahu-Zohary,  L.  PalopolVArtijcial  Intelligence  96  (1997)  421-449 

429 

runs  EA(T)  with  M  initialized 
in  the  size  of  T.  Hence, 

the  result  follows. 

0 

to  i@.  By  Theorem  7,  the  second  step  takes  linear 

time 

Likewise,  minimal 

entailment 

and  minimal  membership 

are  easier  for  positive  HCF 

theories 

than  they  are  in  general. 

the 
Theorem  9  (Minimal 
class  of positive  HCF  theories  is co-PIP-complete.  Minimal  membership for  the  class  of 
positive  HCF  theories  is  PIP-complete. 

entailment,  minimal  membership).  Minimal  entailment  for 

entailment 

Proof.  That  minimal 
sults  already 
the  NE-hardness  of  minimal  membership, 
problem  POSITIVE-ONE-IN-THREE 

is  in  CO-NE and  minimal  membership 

and  we  do  so  by  showing  a  reduction 

3SAT,  which  is  known 

is  in  NP  are  re- 
[ 71.  We  begin  by  showing 
from  the 
[ 411: 

to  be  HP-complete 

implied  by  the  work  of  Ben-Eliyahu 

and  Dechter 

Instance:  Sets  St,  . . . , Sk having 
Question:  Return  YES when  there  is  a  set  of  elements 

three  elements  Xi,  Xi’, X:  each,  1 Q  i 6  k. 

that  contains  exactly  one  element 

from  e,ach  set. 

Consider 

the  positive  HCF  theory  T  where  for  each  set  Si  we  have  the  set  of  clauses 

and  we  also  have  the  clause  YES V NO.  YES  is  in  some  minimal  model  of  T  if  and  only 
if  there 
from  each  set.  Hence, 
minimal  membership 

exactly  one  element 

i;s  a  set  of  elements 

that  contains 

is  HP-hard. 

To  sha’w  the  co-NE-hardness 

that  a  minimal 
model  of  the  theory  T  above  contains  YES  if  and  only  if  it  does  not  contain  NO.  Thus, 
minimal 

entailment,  we  just  note 

is  co-HE-hard. 

of  minimal 

entailment 

0 

Before  closing 

this  section,  we  would 

like  to  address  an  important 

issue  raised  by 
a  theory  as  a  set  of  clauses  of  the  form  ( 1))  we 

Dechter 
could  have  represented 

[ 141.  Instead  of  representing 

a  theory  as  a  set  of  clauses  of  the  form 

A,/\AZ~... 

A A,,, A XI  A X2  A . . . A X”__,  -+ c,,, 

(2) 

in  a  way  that  is  parallel 

where  all  the  As  and  the  Cs  are  atoms.  We  could  then  identify 

theories 
programs  are  defined. 
model,  called 
time  [ 33:].  Therefore, 
can  be  found 

l1  It  is  well  known  that  if  a  logic  program 

the  class  of  stratijied 
to  the  way  stratified  deductive  databases  and  logic 
its  intended 
the  perfect  model,  is  one  of  its  minimal  models  and  can  be  found  in  linear 
theories 
(or, 

that  a  minimal  model  for  stratified 

research  has  explored 

it  is  quite  immediate 

relating  CNF 

time.  Recent 

is  stratified, 

in  linear 

theories 

*I For  a  formal  definition  of  stratification,  see  the  next  section. 

430 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Art@cial  Intelligence  96  (1997)  421-449 

shifting 

negation-free 

logic  programs 

that  can  be  obtained 

to  the  set  of  stratified 

that  is  based  on  considering 

theory  T  to  be  a  causaE  theory 

disjunctive 
from  them  through  shifting. 
deductive  databases 
normal 

analogously, 
obtainable 
for  disjunctive 
the  unstratified 
by  applying 
CNF 
can  be  obtained 
the  set  of  causal  models  of  T  to  be  the  set  of  perfect  models  of  the  stratified 
shifting.  But  what 
obtainable 
theories,  causal 
obvious 
HCF 
following 

theories 
logic  programs) 
In  particular,  Schaerf  [ 421  advocates  a  semantics 
both  the  stratified  and 
the  given  database 
in  all  possible  ways.  Following  Dix  et  al.  [ 161,  we  can  define  a 
that 
for  any  CNF  theory  T,  we  can  define 
theories 
is  the  relation  between  positive  HCF 
there  is  no 
from 
to  HCF  theories,  as  the 

shifting  atoms  from  head  to  body  or  vice  versa) 
theories 

theories,  and  stratified 
(namely, 

if  there  exists  at  least  one  stratified 

from  T  through  shifting.  Then, 

theories  or  from  stratified 

theories?  We  note 

from  T  through 

that,  apparently, 

transformation 

to  stratified 

illustrates. 

example 

theories 

theory 

from 

Example  10.  On  the  one  hand,  consider 

the  positive  HCF  theory  T: 

a  V  b, 

a  +  c, 

bvc 

Theory  T’  is  obtained  by  shifting  all  but  one  of  the  atoms  from  the  head  of  the  clause 
to  the  body: 

Tb+a, 

a--tc, 

~c-+  b 

Theory  T’  is  not  stratified,  however.  On  the  other  hand,  consider 

the  stratified 

theory  T: 

b  +  a, 

a  +  b, 

TaATb--+c 

Theory  T’  is  obtained  by  shifting  negative  body  literals 

to  the  heads  of  clauses: 

b  --+ a, 

a  +  b, 

aVbVc 

Theory  T’  is  positive  but  not  HCF. 

However, 

it  is  easy  to  see  that  a  simple  variant  of  the  EA  can  be  used  to  find  for 
each  positive  HCF  theory  T,  a  stratified 
theory  T,  that  is  obtained  by  shifting  all  but  one 
of  the  atoms  from  the  head  to  the  body  and  such  that  the  perfect  mode1  of  T,  is  also  a 
it  is  clear  that 
minimal  model  of  T.  Thus,  any  positive  HCF  theory  is  causal.  Moreover, 
the  set  of  causal  models  of  T  is  strictly  contained 
in  the  set  of  minimal  models  of  T. 
That  such  a  containment 

is  strict  is  shown  by  the  next  example. 

Example  11.  Consider 

the  positive  HCF  theory  T: 

a  V  c, 

bAc+a 

This  theory  has  two  minimal  models,  namely,  {u}  and  {c}.  The  only  stratified 
obtainable 

from  T  by  shifting  operations 

is 

theory 

7c  --+ a, 

bAc+a 

whose  perfect  model 

is  {u}.  Thus, 

the  minimal  model  {c}  is  not  a  causal  model  for  T. 

R.  Ben-Eliyahu-Zohary.  L.  PalopoWArtijicial  Intelligence  96  (1997)  421-449 

431 

By  a  similar 

line  of  reasoning 

it  is  clearly  possible 

it  into  a  stratified 

to  compute  one  minimal  model 
theory  and  then  computing 

linear 
it  is  not  complete, 
(the  EA  is  complete; 

of  a  positive  HCF  theory  by  transforming 
its  perfect  model 
(in 
disadvantages: 
are  minimal 
be  as  efficient  as  the  EA.  For  example, 
discover 
into  a  stratified 

theory  before  computing 

this  fact  at  an  early  stage,  whereas 

since 

time).  When  compared 

see  Proposition 

it  cannot  generate  some  models  although 

to  the  EA,  this  procedure  has  two 
they 
4)  ;  and  in  many  cases  it  will  not 
the  EA  will 
the  theory 

if  the  theory  has  an  empty  model, 

the  procedure  always  transforms 

any  model. 

We  would  also  like  to  note  that  the  class  of  Horn  theories,  for  which  a  unique  minimal 
model  can  be  found  in  linear  time  [ 17,251,  intersects 
the  class  of  HCF  theories,  although 
these  classes  are  distinct.  Consider, 
and 
T3 =  {u  V b}.  Tl  is  both  Horn  and  positive  HCF,  T2  is  Horn  but  not  positive  HCF,  and 
Ts  is  positive  HCF  but  not  Horn. 

the  theories  Ti  =  {a},  T2 =  {la}, 

for  example, 

3.  The  elimination  algorithm 

for  nonground  positive  HCF  theories 

In  this  section,  we  generalize 

the  EA  so  that  it  can  be  used  to  efficiently  perform 

(Herbrand)  model  finding  on  a  nonground  positive  HCF  theory. 

the  EA  algorithm 

as  distinct  propositional 

this  problem  by  computing 

the  ground 
(where  distinct  ground 

We  could  approach 
theory  and  then  applying 
are  handled 
cases,  since  computing 
Therefore, 
input 
variant  of  the  algorithm  has  the  further  advantage 
an  arbitrary  model  before  finding  a  minimal  one. 

of  the  input 
instances  of  atoms 
in  many 
of  the  input  theory  could  be  expensive. 
the 
first  in  order  to  compute  one  of  its  minimal  models.  This 
that  it  does  not  require  us  to  construct 

in  this  section,  we  present  a  variation  of  the  EA  that  does  not  require 

letters).  This  method 

is  not  convenient 

to  be  grounded 

instantiation 

instantiation 

the  ground 

theory 

We  will  now  refer  to  a  nonground 

theory  as  a  set  of  clauses  of  the  form 

v’(x1,. 

..,X,,)Al 

AA:!A...AA,~C~VC~V...VC, 

(3) 

where  all  the  As  and  the  Cs  are  atoms  in  a$rst-order 
and  Xl,... 
simply  as 

, X,  are  all  the  variables 

language  with  no  function  symbols, 
that  appear  in  the  clause.  We  will  often  write  (3) 

A1 /\ A2 A  . . . A A,,,  +  Cl  v  C2 v  . . . v  C,, 

(4) 

for  nonground 

are  universally 

quantified.  The  definitions 

that  all  the  variables 
theories 
theories.  Throughout 

of 
theories  are  the  same  as  they  were  for 
In 
. . . , X,),  p  is  called  a  predicate  name.  The  set  of  all  constants 
in  a  given  theory  T  is  called  the  Her-brand universe  of  T.  If  no  constants  occur 
in  its  Herbrand  universe. 

keeping 
in  mind 
head,  body,  and  positive 
propositional 
the  expression  p (Xi, 
appearing 
in  T,  then  an  arbitrary  constant 
The  set  of  all  atoms  constructed  using  predicate  names 
Herbrantl  universe 
of  T  is  formed  by  consistently 

from  its 
the  Herbrund  base  of  T.  A  ground  instance  of  a  clause  6 
from  the  Herbrand  universe  of  T 

that  theories  are  positive. 

this  section,  we  assume 

from  T  and  constants 

to  be  contained 

is  assumed 

substituting 

constants 

is  called 

432 

R.  Ben-Eliyahu-Zohary,  L.  PalopoWArtijicial  Intelligence  96  (1997)  421-449 

Input: A  nonground positive HCF  theory  T. 
Output:  A  minimal  Herbrand  model  for  T. 

1.  M  :=  fi;  M’  := ‘8. 
2.  Let A  be  the  set  of  all  ground  instances  6 of  rules  in  T violated  by  M 

such  that  Iatom-head-out(&S)M’I  =  1. 

If  A =  0,  go  to  Step  3. 
Else,  let  X  := n,,, 

atom-head-out( 6, S) M’; 

M  :=  M  n  X; 
repeat  Step  2. 

3.  Let  A  be  the  set  of  all  ground  instances  6 of  rules  in  T violated  by  M 

such  that  (atom-head-out(&  S)M’(  2  2. 

If  A =  0,  return  M. 
Else,  let  H  :=  n,,, 
the  predicate  names  in  H  in  GT; let  M’  := M’ fl  N;  go  to  Step  2. 

name-head-out(8,  S) M’,  and  let  N be  a  source  of  all 

Fig.  3.  The  elimination  algorithm  for  nonground  positive  HCF  theories. 

in  S.  The  grounded  version  of  T,  denoted  gr(T), 

for  variables 
is  the  set  of  all  ground 
instances  of  all  the  clauses  of  T.  A  Herbrand  model  of  T  is  a  subset  of  the  Herbrand 
base  that  satisfies  gr(T).  A  Herbrand  model  M  of  T  is  minimal 
if  it  does  not  properly 
contain  any  Herbrand  model  of  T. 
As  we  did  in  the  propositional 

case,  with  every  theory  T  we  associate  a  directed  graph 
GT,  called  the  predicate-name  dependency  graph  of  T,  in  which  (a)  each  predicate  name 
from  a  node  p  to  a 
and  each  clause 
clause  6  if  and  only 
is  an  arc 
directed 

from  6  to  p  if  and  only  if  p  is  a  predicate  name  in  the  head  of  S. 

in  the  body  of  6,  and  there 

if  p  is  a  predicate  name 

in  T  is  a  node  and  (b) 

there  is  an  arc  directed 

A  theory  T  is  HCF  if  and  only 

if  there  is  no  clause  of  the  form  (3) 

for  some  Ci  and  Cj,  i  #  j,  GT  contains  a  directed  cycle  involving 
of  Ci  and  the  predicate  name  of  Cj.  Specifically, 
in  HCF  theories 
same  predicate  name  cannot  be  in  the  head  of  the  same  clause. 

in  T  such  that 
the  predicate  name 
two  atoms  with  the 

Proposition  12.  The  head-cycle-freeness  of  a  nonground  theory  T  of  size  n  can  be 
checked  in  time  O(n). 

Proof.  The  algorithm 
propositional 

theory 

for  checking  head-cycle-freeness 

here  is  similar 

to  the  one  for  a 

(see  Proposition 

1) . 

(cid:144)! 

In  Fig.  3,  we  present  a  variation  of  the  EA,  called  EAF  (3  for  “first-order”), 

that  com- 
putes  a minimal  Herbrand  model  for  a  positive  nonground  HCF  theory.  The  EAF  uses  the 
functions  atom-head-out(  )  and  name-head-out(  ).  Given  a  rule  S  and  a  set  of  predicate 
names  S,  atom-head-out(  6, S) S  will  return 
but  whose  predicate  names  do  not  belong 
set  of  predicate  names  that  appear  in  the  head  of  S  but  do  not  belong 
ample, 
-+  a(X)  V  b(X)  and  S  =  {a}, 
and  name-head-out(  8, S)S  =  {b}.  The  algorithm 

the  set  of  atoms  that  appear  in  the  head  of  S 
to  S,  and  name-head-out(  6, S) S  will  return  the 
to  S.  Thus,  for  ex- 

then  atom-head-o&(&  S)S  =  {b(X)} 
also  employs  a  set  M’  of  predicate 

if  S  =  c(X) 

R.  Ben-Eliyahu-Zohwy,  L.  PalopoWArtificial  Intelligence  96  (1997)  421-449 

433 

names.  A.fter  a  predicate  name  is  added  to  M’,  no  ground  atom  with  this  predicate  name 
will  be  added  to  the  output  minimal  model. 

The  proof  of  the  following 

theorem  appears 

in  the  Appendix. 

Theorem  13  (The  EAF 
of  the  input  theory. 

is  correct). 

The  EAF  generates  a  minimal  Herbrand  model 

The  following 

example  shows  how  the  EAF  works. 

Example  14.  Suppose  we  have  the  theory 

1.  a(s)  V  b(s) 

2.  b(Y)  *a(Y) 

3. 

a(s)  V  c(s) 

4.  a(Y) 

-+  d(Y) 

At  Step  1  of  the  EA3,  M  =  0  and  M’  =  8.  At  Step  2,  we  get  that  A  =  8,  because 
although  clauses  1  and  3  are  violated  by  M,  each  has  two  predicate  names 
in  its  head 
that  do  not  belong 
to  M’.  Since  A  is  empty,  we  go  to  Step  3,  and  in  Step  3,  we  get 
A  =  {a(x)  V  b(s),  a(s)  V  c(s)}.  As  M’  is  still  empty,  we  get  H  = {a,  b, c}.  Since  {b} 
that  {c}  is  also  a  source),  we  set  M’  equal  to  {b}  and  go 
is  a  sourIce  of  {a,  b, c}  (note 
to  Step  :!.  In  Step  2,  we  now  get  A  =  {a(s)  V  b(s)}.  Therefore  X,  and,  consequently, 
and  Step  2  is  repeated.  Since  now  M  =  {a(s)}, 
M  are  both  set  equal 
the  clause  violated  by  M  for  which 
S)M’l  =  1  is  a(s)  +  d(s) 
(which  we  get  by  instantiating  Y  to  s  in  clause  4).  So  we  add  d(s) 
there  are  no  more 
M  =  {a(s),d(s)}. 
algorithm 
stops  and  returns  M.  Indeed,  {a(s) 
the  theory. 

to  M  and  get 
instances  of  clauses  violated  by  M,  the 
is  a  minimal  Herbrand  model  for 
, d(s)} 

[atom-head-out(S, 

to  {a(s)}, 

Since 

The  complexity 

theories  can  be  analyzed 
the  principles  by  which  the  data  complexity  of  a  query  language  over  a  relational 

positive  HCF 

for  nonground 

of  the  EA3 

using 
database  under  some  fixed  semantics 

is  defined 

[ 441. 

the  reasoning 

Any  nonground 

component,  which 

theory  can  be  divided 

represents 
component,  which  represents 
the  extensional 

the  intentional 
and  the  other  set  the  extensional 
in  the  theory.  For  our  purposes, 
HCF  theory  T,  denoted  TE,  is  the  set  of  all  the  clauses 
grounded 
T  -  TE.  For 
the  extensional 
component, 
analyze  how  the  complexity 
the  following. 

into  two  disjoint  sets  [ 381:  One  set  comprises 
of  the  theory, 
the  collection  of  facts 
positive 
that  have  an  empty  body  and 
part  of  T,  denoted  TI,  is  simply 
14,  clauses  1  and  3  form 
and  clauses  2  and  4  form  the  intentional 
If  we 
component. 
of  EA3  changes  when  we  fix  TI  and  vary  TE,  we  discover 

in  the  head,  and  the  intentional 
in  the  theory  presented 

atoms  only 
instance, 

part  of  a  given  nonground 

in  Example 

component 

Theorem  15.  Using  the  algorithm  EA3,  a  minimal  model  of  a  nonground  positive  HCF 
theory  71 n TE  can  be  found 

in  time  polynomial 

in  the  size  of  TE. 

434 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Arti$cial  Intelligence  96  (1997)  421-449 

Proof.  Let  n  be  the  size  of  TE, m  be  the  number  of  distinct  predicate  names  occurring 
in  T,  and  k  be  the  maximum 
fixed,  it  is  immediate 
on  T  is  0(  nkm) . Note,  moreover, 

in  T.  Since  by  assumption  T,  is 
from  running  EAF 

size  for  M’  is  O(m).  We  have: 

size  of  any  model  resulting 

arity  of  any  predicate 

that  the  maximum 

that  the  maximum 

( 1)  Step  1  of  the  EA3 
(2)  Step  2  (construction 
(3)  Step  3  (construction 

takes  0(  1)  time. 

of  A  and  X,  and  update  of  M)  takes  0(  n”m). 
of  A  and  N,  and  update  of  M’)  takes  0(  nkm) . 

The  statement 

then  follows,  because: 

( 1)  Each  time  Step  2  is  executed,  EA3  either  adds  (at  least)  one  new  atom  to  M  or 

jumps 
(2)  Each 
name 

to  Step  3. 
time  Step  3  is  executed,  EA 3  either  adds  (at  least)  one  new  predicate 
to  M’  or  stops  and  returns  M. 

(3)  The  size  of  m  is  O(n). 

the  EA3  presents 

theory  nor  construction 

grounding  of  the  input 

As  we  have  pointed  out,  using  EA3 

theory.  However, 
complete, 

instead  of  EA  has  two  advantages:  EA3  requires 
of  a  starting  model 
neither  preliminary 
that  it  is  not  nondeter- 
of  the  input 
that  cannot  be  generated 
ministically 
by  this  algorithm.  Consider 
the  theory  T  =  {u  V  c,  b  A  c  +  a}  of 
Example  11.  Clearly,  both  {u}  and  {c}  are  minimal  models  of  T,  but  since  {c}  is  a 
source  of  {a) 
ministic  completeness 
algorithm. 

in  G r,  the  model  {c}  will  never  be  generated  by  the  EA3.  Nondeter- 
the  EA 

that  is,  there  are  some  minimal  models 

can  be  achieved  by  grounding 

the  theory  and  then  using 

again,  for  instance, 

the  drawback 

4.  Applications  of  the  elimination  algorithm 

4. I.  Disjunctive  deductive  databases 

A  variation 

of  the  EA  can  be  used 

to  construct 

a  stable  model  of  a  disjunctive 

deductive  database.  We  define  a  disjunctive  deductive  database 
of  rules  of  the  form 

(DDB) 

as  a  finite  set 

C,  1 C2  1 . . .  1 C,+Al,..., 

A,,notB~ 

,...,  notBk 

(5) 

loss  of  generality,  we  assume 

symbols.  Without 
the  symbol  “I”  instead  of  the  classical  symbol  “V”,  we  mean  to  emphasize 

where  all  the  As,  the  Bs,  and  the  Cs  are  atoms  over  a  first-order 
function 
By  using 
here  disjunction 
call  the  Bs  negative  predicates, 
if  and  only 
DB,  denoted  Gas, 
head-cycle-free  DDBs  (HDDB) 

language  with  no 
that  all  of  the  Cs  are  distinct. 
that 
logic.  We 
the  As  positive  predicates.  A  DDB  is  a  positive  DDB 
dependency  graph  of  a  DDB 
the  Bis  in  form  (5).  A 

if,  for  each  rule,  k  =  0.  The  predicate-name 

is  used  in  a  slightly  different  manner 

is  defined  as  for  theories  by  simply 

than  it  is  in  classical 

to  HCF  theories. 

is  also  defined 

in  analogy 

ignoring 

Proposition  16.  The  head-cycle-freeness 
O(n). 

of  a  DDB  of  size  n  can  be  checked 

in  time 

R.  Ben-Eliyahu-Zohary, 

L.  PalopoWArtijcial 

Intelligence  96  (1997)  421449 

435 

Proof.  The  algorithm 
propositional 

theory 

for  checking  head-cycle-freeness 

here  is  similar 

to  the  one  for  a 

(see  Proposition 

1). 

0 

[ 361,  we  define  a  stratified  DDB  (SDDB) 

Following 
to  partition 
that  for  each  rule  S  of  the  form  (5), 

the  set  S  of  predicate  names 

to  be  a DDB  where  it  is  possible 
into  subsets  {So,.  . . , S,},  called  strata,  such 

( 1)  all  the  predicate  names  of  the  Cs  (that  appear  in  the  head  of  8)  have  the  same 

(2) 

(3) 

index  c, 

stratum 
thme strata  indexes  associated  with  the  predicate  names  of  the  As  are  smaller 
or  equal  to  c,  and 
the  strata 
indexes 
smaller 

associated  with 

the  predicate  names  of  the  Bs  are  strictly 

than  c. 

than 

So,  each  SDDB  DB  is  associated  with  at  least  one  partition  of  its  predicate  names 
into  strata.  For  every  stratification 
(r  >  1))  we 
subsets  {DBI  , . . . , DB,}  such  that  DBi 
can  partition 
that  are  in  the  stratum  Si.  (We 
contains 
in  the 
assume  without 
head  of  any  rule.) 

{So,  . . . , ST}  of  DB’s  predicate  names 

the  rules  of  DB  into  corresponding 

that  have  in  their  heads  predicates 

the  predicates  not  appearing 

loss  of  generality 

that  So  contains 

lthe  rules 

Several  different  semantics  have  been  proposed 

all  these  #semantics  use  the  set  of  the  minimal  models  of  a  positive  DDB  to  define 
intended  meaning  of  the  DDB.  The  same  holds  for  SDDBs:  all  the  semantics 
SDDBs  agree  on  identifying 
the  SDDI). 

Notably, 
the 
that  handle 
the  stable  models  of  a  SDDB  as  the  intended  meaning  of 

for  DDBs  [ 3,15,21,36,37]. 

Definition  17  (Stable  model 
occurrence 
models. 

of  “not”, 

[ 2 1 ] ).  Suppose  DB  is  a  variable-free  DDB.  If  DB  has  no 
then  the  set  of  all  its  stable  models  is  the  set  of  all  its  minimal 

If  “not”  occurs 

in  DB,  then  its  stable  models  are  defined  as  follows.  For  any  subset  S 

of  the  atoms 

in  DB,  define  DB’  to  be  the  DDB  obtained 

from  DB  by  deleting 

( 1)  all  formulas  of  the  form  “not  B”  where  B  4  S  from  the  body  of  each  rule  and 
(2)  eafch  rule  that  has  in  its  body  a  formula 

‘%zotB”  for  some  B  E  S. 

If  S  is  one  of  the  minimal  models  of  DB’  (DB’  has  no  “got”), 
stable  model  of  DB.  To  apply 
replace  each  rule  with  its  grounded 

the  definition 

instances. 

then  we  say  that  S  is  a 
to  a  DDB  with  variables,  we  first  have  to 

A  DDB  may  have  no,  one,  or  several  stable  models.  We  claim,  as  do  others  [ 1,23,40], 

that  sometimes 
of  a  DDB.  Two  examples 

follow. 

a  problem  can  be  solved  by  computing  only  one  arbitrary  stable  model 

Example  18.  Consider 
This  problem  has  applications 
including  diagnosis 
is  as  follows:  given  a  bipartite  digraph  G  =  (VI,  V2, E),  a  solution 
covering  problem 
there  exists  a  node  s  E  S  such  that  the  edge  (s,  x)  is  in  E.  Consider 
that  includes, 

the  well-known  graph-theoretic  problem  of  minimal  set  covering. 
[ 351.  The  problem 
set- 
to  the  minimal 
subset  S  of  VI  such  that  for  each  node  x  E  V2 
the  HDDB  DB 

for  each  node  x  E  V2, the  rules 

for  G  is  a  minimal 

in  many  domains, 

436 

R.  Ben-Eliyahu-Zohmy,  L.  Palopoli/Artificial  Intelligence  96  (1997)  421-449 

EAs(DB) 

Input:  A  propositional  SHDDB DB. 
Output:  A  stable  model  for  DB. 

1.  Partition  DB  into  strata  DB1,. 
2.  M  :=  0. 
3.  For  i:=l  to  I-, do: 

. . , DB,. 

(a)  Eliminate  from  DBi  each  clause  having  in  its  body  a negative  literal  “notD”  with  D  E  M; 
(b)  Eliminate  a11 the  negative  literals  from  the  remaining  clauses  in  DBi; 
(c)  M  :=  EA(DBi  U (P  +-I  P  E  M}). 

Fig.  4. The  elimination  algorithm  for  SHDDBs. 

S]  ~s*~...)sn+x 

X+ 

, s,,  are  all  the  nodes  belonging 

to  VI  such 
in  E.  Each  stable  model  of  DB  encodes  a  solution 

that  (st  , x),  . . . , ( sn,  x)  are 
where  st,... 
edges 
set  covering 
to  the  minimal 
problem.  Therefore,  we  can  pick  an  arbitrary  stable  model  of  DB  to  find  a  set  covering 
for  the  graph  G. 

Example  19.  Assume  we  have  a  pictorial  database  and  want 
a  tool  that 
when  given  the  type  of  an  object  in  a  scene  (say  tree  or  river)  suggests  a  default  coloring 
in  a  scene  should 
for  the  object,  under 
be  distinguishable 
the  following 
HDDB: 

and,  as  such,  should  have  different  colors.  Consider 

that  objects  close  to  one  another 

the  constraint 

to  construct 

blue(X) 

1 green(X) 

1 softsreen(  X)  +-  tree(X) 

green(X) 

1 brown(X)  c-  mountuin( X) 

blue(X)  t  river(X) 

green(X)  1 sofgreen(  X)  t  tree(X)  , river(Y)  , 

pcZase(  x,  Y) 

softgreen(  X)  +-- tree(X) 

, mounruin( Y)  , 

green(Y),pcZose(X,Y) 

that  the  classification 

Assume 
encoding  of  a  particular 
a  and  b  will  be  painted  close 
HDDB  encodes  a  feasible  coloring  of  the  objects 

to  one  another 

of  the  objects 

scene,  along  with  facts  like  pclose(  a,  b),  meaning 

is  stored 

to  be  painted 

in  the  database 
that  objects 
in  the  scene.  Each  stable  model  of  the 

in  the  scene. 

In  Fig.  4  we  show  algorithm  EAs,  a  variation  of  the  EA  which  computes  one  arbitrary 
stratified  head-cycle-free  DDB  (SHDDB)  _ The  basic  idea 
and  then  call  the  EA  on  each 

stable  model  of  a propositional 
is  to  partition 
subset 

the  SHDDB  according 
in  the  order  implied  by  the  stratification. 

to  its  stratification 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Art@ial 

Intelligence  96  (1997)  421-449 

431 

Note  that  when 

the  algorithm 

is  run  on  a  DDB  with  variables, 

the  grounded  version 

of  the  D:DB  must  be  used. 
Proofs  of  the  following 

two  theorems  are  given  in  the  Appendix. 

Theorem  20  (The  EAs 
SHDDB. 

is  correct). 

The  EAs  generates  a  stable  model  of  the  input 

Theorem  21 
DB,  then  there  is  an  execution  of  the  EAs  that outputs  M. 

If  M  is  a  stable  model  of  a  SHDDB 

The  EAs  can  also  be  used  for  computing 

the  (unique) 

stable  model  of  a  stratified 

(nondisjunctive) 

deductive  database. 

Corollary  22.  Let  DB  be  a  strati$ed 
EAs  (Dtl)  coincides  with the  (unique)  stable  model for  DB. 

(nondisjunctive)  deductive  database.  Then 

Theorem  23  (Complexity). 
size  of  the  grounded  version  of  the  input DDB. 

The  E& 

for  SHDDBs  runs  in  time  O(n)  , where  n  is  the 

Proof.  Assume 
runs  in  time  O(CL, 
we  get  linear 

time  complexity. 

0 

that  the  input  DDB  has  k strata.  It  follows  from  Theorem  7  that  the  EAs 
the  size  of  the  ith  stratum.  Since  C%,  ni =  n, 

ni),  where  ni  denotes 

We  illustrate  how  the  EAs  works  with  the  next  example. 

Example  24.  Suppose  we  have  the  following  SHDDB  DB: 

1.  albt 

2. 

ccnota 

3.  diet-c 

that  we  adopt  a  stratification 

such  that  So =  8, 
Note  that,  for  this  DDB,  So =  8.  Assume 
of 
Si  =  {a., b},  S2  =  {c,  d,  e}.  At  Step  1  of  the  E&,  we  compute 
the  rules. 
In  this  case,  DBI  consists  of  the  first  rule,  and  DB;!  consists  of  the  other 
two  rules.  After  setting  M  =  8  (Step  2),  we  start  the  for  loop  at  Step  3.  Steps  3a 
that 
and  3b  do  not  modify 
EA(DBt  )  =  {b}, 
stratum  DB2. 
to  M,  and  we  consider 
Step  3a  does  not  modify  DB2.  At  Step  3b,  the  literal  “not a”  is  eliminated 
from  the  body 
to  the  DDB: 
of  rule  number  2.  Therefore,  at  Step  3c,  the  EA  is  applied 

the  rule  in  DB1.  So,  we  apply  the  EA  to  DBl.  If  we  assume 

is  the  value  assigned 

the  stratification 

then  {b} 

2’. 

c  +- 

3. 

4. 

dle+c 

bc 

last  application  may  yield, 

This 
to  M  and  returned 
{b,  c,  d}  is  indeed  a  stable  model  for  DB. 

as  the  result  of  EAs(DB). 

for  instance, 

the  set  {b,  c,  d},  which 
It  is  easily  seen 

is  then  assigned 
set 

that  the  returned 

438 

R. Ben-Eliyahu-Zohmy, L.  Palopoli/Ar@cial Intelligence 96 (1997) 421-449 

4.2.  Disjunctive  default  logic 

Disjunctive  default  logic  is  a  generalization 

Gelfond  et  al.  [22] 
logic  has  when  dealing  with  disjunctive 
propositional  disjunctive  default 
A  as  a  set  of  disjunctive  defaults.  A  disjunctive  default  is  an  expression  of  the  form 

logic 
introduced  by 
that  Reiter’s  default 
In  this  section,  we  will  focus  on 
logic.  Gelfond  et  al.  define  a  disjunctive  default  theory 

of  Reiter’s  default 
some  of  the  difficulties 

in  order  to  overcome 

information. 

ff:  Pl,...,Pn 

YII...IY”, 

(6) 

. . , /3,,, and  ~1,.  . . , y,,,  are  formulas 

language.  Gel- 
where  a,  PI,. 
fond  et  al.  define  an  extension  for  a  disjunctive  default  theory  A to  be  one  of  the  minimal 
‘*  that,  for  any  disjunctive 
deductively 
default  from  A,  if  cy E  E’  and  +1,. 

. . , -&,  $  E,  then  for  some  1 <  i  6  m,  yi  E  E’. 

closed  set  of  sentences  E’  satisfying 

in  some  propositional 

the  condition 

Let  us  now  consider 

the  subset  of  disjunctive  default 

theories 

that  we  call  disjunctive 

default  programs 

(DDPs)  . A  DDP  is  a  set  of  defaults  of  the  form 

A1 A...AA,,,: 

+l,...,+ 

Cll...IG 

(7) 

in  which  each  of  the  As,  the  Bs,  and  the  Cs  is  an  atom  and  n  >  0.  Each  such  DDP  A 
can  be  associated  with  a  DDB  DBd  by  replacing  each  default  of  the  form  (7)  with  the 
rule 

ClI.../C,tAl,..., 

A,,notBl,..., 

notBk 

The  following 

theorem 

implies 

that  all  of  the 

techniques 

and  complexity 

results 

established  with  respect 

to  DDBs  also  apply  to  DDPs. 

Theorem  25  (Gelfond 
et  al.  [ 221). 
extension  of  A  if  and  only  if  E  is  a  stable  model  of  DBd. 

Let  A  be  a  DDR  The  logical  closure  of  E  is  an 

So,  in  particular,  we  can  conclude 

that  for  the  class  of  DDPs,  computing 

is  PNP[o(losn)]-hard,  checking  whether  a  set  of  atoms  is  an  extension 
deciding  whether  an  atom  belongs 

to  some  extension 
Let  us  call  a DDP  completely  ordered  if  and  only  if  its  corresponding  DDB  is  stratified 
subclasses  of 

sections,  we  can  identify 

is  co-NP-hard, 

in  previous 

the  results 

is  8;-hard. 

and  HCF.  Then,  using 
DDPs  that  are  more  manageable 

than  the  class  of  DDPs  in  general. 

an  extension 
and 

Theorem  26.  Let  A be  a  completely  ordered  DDP,  and  let n be  its size. I3  An  extension 
for  A  can  be found  in  time  O(n). 

Proof.  Follows 

from  Theorems  25  and  23. 

0 

‘* Note  the  appearance 
I3 We  measure 

of  E  in  the  condition. 

the  size  of  a  DDP  by  the  number  of  symbols 

it  contains. 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Ar@cial 

Intelligence  96  (1997)  421-449 

439 

These  results  can  be  extended 

to  deal  with  first-order  disjunctive  default 

theories,  by 
the  EA  for  propositional  HCF 

the  same  principles 

that  were  used  to  generalize 

using 
theories 

to  first-order  HCF  theories. 

5.  Related  work 

The  class  of  HDDBs  was  introduced  by  Ben-Eliyahu 

and  Dechter 

[ 7,8].  They  have 
the  satisfiability 

theories 

into  classes 

logic.  Cadoli 

from  classical 

for  which  model 

[9,10]  has  described  a  partitioning 

tractable  or  NE-hard.  His  partition 

shown  that  queries  on  propositional  HDDBs  can  be  answered  by  solving 
problem 
and  model  checking 
all  propositional 
the  set  of  logical 
are  either 
the  tractable  classes 
relations 
[ 61  have  developed  other  efficient 
can  be  identified  effectively.  Ben-Eliyahu 
algorithms 
for  finding  minimal  models  of  propositional  CNF  theories.  Their  algorithms 
are  efficient  either  when  the  theory  is  almost  Horn,  that  is,  when  there  are  few  non-Horn 
clauses  and  the  set  of  all  positive 
theory  can  be  represented 

finding 
considering 
to  the  theory,  and  it  is  not  clear  whether 
and  Dechter 

as  an  acyclic  network  of  low-a&y 

in  any  non-Horn 

that  corresponds 

is  small,  or  when  the 

of  the  set  of 

relations. 

invlolves 

literals 

clause 

Tasks  related 

to  minimal  model  computation 

[ 12,131  and,  more  recently, 

the  logic  programming 

[ 12,131  are  highly  complex 

have  been  studied  also  in  the  diagnosis 
[4,5].  Many 
literature 
in  the  worst 
of  a 
implicates.  The  first  task  is  out- 
literature, 

in  the  diagnosis 

all  the  prime 

implicates 

systems 
they  first  compute 

cover  of  the  prime 

is  NE-hard.  Therefore, 

completeness 

by  using  heuristic  approaches.  The  work  in 

literature  has  focused  on  using  efficient  optimization 

for  computing  minimal  models 

(e.g., 

is  that  it  does  not  address 

the  issue  of  worst-case 

techniques, 
[4]  ).  One  limitation 
and  average-case 

then  find  a  minimal 

literature 
of  the  algorithms  used  in  diagnosis 
diagnosis, 
case.  To  find  a  minimal 
theory  and 
put  exponential,  while 
researchers  often  compromise 
the  logic  programming 
such  as  linear  programming, 
of  this  approach 
complexities. 

the  second 

databases. 

In  particular, 

[ 191  have  studied 

Eiter,  Leone,  and  Sac& 

the  expressive  power  of  various  subsets  of 
disjunctive 
that  SHDDBs  are  able  to  express 
they  have  shown 
all  the  qu’eries  in  NP  under  brave  semantics  and  in  co-NP  under  cautious  semantics.  To 
semantics,  we  check 
compute 
reported 
minimal  membership 
in  [ 191  confirm 

to  queries  under  brave  semantics 

the  relevance  of  HCF  theories. 

respectively.  Hence, 

and  cautious 

and  minimal 

the  results 

entailment, 

answers 

6.  Conclusion 

The  task  of  computing  minimal  models 

and  logic  programming.  Whether  we  are  looking  at  circumscription, 

is  of  interest 

to  researchers 

in- 
default 
in  general,  computing  minimal  models  has 

in  artificial 

reasoning 

telligence 
logic,  diagnosis,  or  commonsense 
been  crucial 

to  speeding  up  the  reasoning  process. 

In  this  paper,  we  have  introduced 

the  algorithm  EA,  which  performs, 

minimal 

rnodel 

finding  and  minimal  model  checking 

for  a  significant 

in  linear 

time, 
subclass  of  CNF 

440 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/ArtiJicial  Intelligence  96  (1997)  421-449 

theories,  namely,  positive  HCF  theories.  We  have  also  shown  that  minimal  entailment 
easier  for  the  class  of  positive  HCF  theories  than  it  is  in  the  general  case.  Our  complexity 
results  are  included 

in  Fig.  1. 

is 

deductive  databases  and  disjunctive  default 

how  the  EA  can  be  modified  so  that  it  can  be  used  to  answer 
We  have  demonstrated 
in  an 
queries  posed  on  disjunctive 
algorithm  EAs,  which  computes  a  stable  model  of  a 
efficient  way.  We  have  presented 
in  linear  time,  and  identified  a  class  of  disjunctive  default  theories 
propositional 
SHDDB 
that  the  class  of  SHDDBs 
can  be  found 
for  which  extensions 
deductive  databases. 
is  a  strict  superclass  of  the  class  of  all  stratified  nondisjunctive 
This  observation,  when  coupled  with  the  results  of  Eiter,  Leone,  and  Sac&i  [ 191  (see 
the  claim  that  our  algorithms  deal  with  quite  expressive  subclasses. 
Section  5),  supports 

time.  Note 

in  linear 

theories 

rapidly 

Levesque 

in  which 

that  deductions 

form  of  a  theory 

is  used,  where  a  vivid 

can  sometimes  be  performed 

is  stored  in  a  way  that  enables 

[28]  has  argued 
form  of  the  knowledge 

if 
a  “vivid” 
is  some 
data  structure 
the  information 
to 
[ 341,  and  others  have 
common  queries.  Thus,  Halpern  and  Vardi  [24  1,  Papadimitriou 
fielded 
the  appealing 
idea  that  a  vivid  form  of  a  theory  need  only  be  a  model  of  the 
theory.  In  this  case,  deduction 
the 
much  easier 
number  of  models,  only 
the  models 
that  are  the  “closest” 
to  the  real  world,  should  be  selected.  One  approach, 
for 
example, 
the  minimal  models  of  a  theory  as  its  vivid  form.  We  argue,  as 
can  be  done  with  only  one 
have  others 
arbitrary  minimal  model  of  a  theory.  The  work  presented  here  is  a  step  toward  efficient 
implementation 

task.  Since  a  theory  might  have  an  exponential 

can  be  replaced  by  model  checking,  which 

is  to  select 
[ 1,23,40], 

the  models 
adopted 

fast  query  answering 

the  theory,  namely, 

in  circumscription, 

that  sometimes 

of  such  ideas. 

fast  answers 

that  “best” 

represent 

is  often 

Appendix  A.  Proofs 

A.1.  Useful  theorems  and  dejnitions 

Theorems  A. 1  and  A.2  are  taken  from 

[ 71.  These  theorems  will  be  used  to  prove  the 

correctness  of  the  EA. 

Following 

[ 71,  we  define  a  proof  of  an  atom 

to  be  a  sequence  of  clauses  which 
the  atom  from  the  theory.  Formally,  an  atom  A  has  a  proof  with 
to  a  set  of  atoms  M  and  a  theory  T  if  and  only  if  there  is  a  sequence  of  clauses 

can  be  used  to  derive 
respect 
61,.  . . , 8,  from  T  such  that 

( 1)  for  each  clause  Si,  one  and  only  one  of  the  atoms  that  appear  in  its  head  belongs 

to  M  (this  atom  will  be  denoted  hu  (&)  ) , 

(2)  A  =  hd&), 
(3) 
(4)  Si  has  an  empty  body  and,  for  each  i  >  1,  each  atom  in  the  body  of  Si  is  equal 

the  body  of  each  Si  is  satisfied  by  M,  and 

to  hM( Sj)  for  some  1  <  j  <  i. 

Theorem  A.1  (Ben-Eliyahu 
of  an  HCF  theory  T  if  and  only  if 

and  Dechter 

[ 71).  A  set  of  atoms  M  is  a  minimal  model 

R. Ben-Eliyahu-Zohary, L. PalopolUArtifcial Intelligence 96 (1997) 421-449 

441 

( 1)  MI sati@es  each  clause  in  T,  and 
(2)  for  each  atom  A  in  M,  there  is a proof  of  A  with respect  to T  and  M. 

The  results 

for  positive  HCF  theories  hold  for  propositional  DDB  as  well.  Say  that 
if 

to  a  set  of  atoms  M  and  a  DDB  DB  if  and  only 

an  atom  A  has  a proof  with  respect 
there  is  al sequence  of  rules  61,.  . . , S,, from  DB  such  that 

( 1)  for  each  clause  Si,  one  and  only  one  of  the  atoms  that  appear  in  its  head  belongs 

to  M  (this  atom  will  be  denoted  hw (Si)  ) , 

(2)  A  =  h&an), 
(3) 
(4)  61  has  an  empty  body  and,  for  each  i >  1,  each  atom  in  the  body  of  Si  is  equal 

thLe body  of  each  Si  is  satisfied  by  M,  and 

to  hM(6j) 

for  some  1  < j <  i. 

Theorem  A.2  (Ben-Eliyahu 
an  HDDB  DB  if and  only  if 

and  Dechter 

[ 71).  A  set  of  atoms  M  is a  stable  model  of 

( 1)  M  satisjes  each  rule  in DB,  and 
(2)  fx 

each  atom  A  in  M,  there  is a proof  of  A  with respect  to DB  and  M. 

The  following 

lemma 

is  probably  known.  We  include  a  proof  for  the  sake  of  com- 

pleteness. 

Lemma  A.3.  Let  DB  be  a  propositional  SHDDB,  and  let  S1, . . . , S,  be  a  partition  of 
its atoms  into  strata.  The following  hold. 

( 1)  u  M  is  a  stable  model  of  DB  and,  for  each  n  <  r,  M,  is  the  restriction  of  M  to 

the atoms  belonging  to Sl U.  . US,,  then  M,  is a stable  model for  DB1 U. . UDB,. 

(2)  If  M’  is  a  stable  model  of  DB1  U  . . . U DB,  for  some  n  <  r,  then  every  stable 

model  of  DB,+l  U . - * U DB,  U  {P  +---I P  E  M’}  is a  stable  model  of  DB. 

( 1)  By  Theorem  A.2,  each  atom  in  M  has  a  proof  with  respect 

Proof. 
and  every  rule  in  DB  is  satisfied  by  M.  Because  DB  is  stratified, 
that  each  atom  in  M,  has  a  proof  with  respect 
rule  in  DB,  U  . . . U DB,  is  satisfied  by  M,.  Hence, 

to  M  and  DB, 
follows 
to  DB1  U  . . . U DB,  and  M,,  and  every 

the  lemma  follows. 

it  immediately 

(2)  The  proof  is  by  induction  on  r  -  n. 
Case  r  -  n  = 0:  trivial. 
Case  r-n  >  0:  By  the  induction  hypothesis, 

if  M’  is  a  stable  model  of  DB1 U.  . UDB,, 

then  every  stable  model  of  DB”+l  U.  . . U DB,_,  U {P  cl  P  E  M’}  is  a  stable  model  of 
DB,  U..-  U DB,_l  .  Let  DB”  be  DB,+l  U  . . . U DB,_I  U  {P  t(  P  E  M’},  and  let  DB* 
. U  DB,_l  .  Let  M  be  a  stable  model  of  DB”  U DB,.  Using  Theorem  A.2, 
be  DBI  IJ.. 
we  will  show  that  M  is  a  stable  model  of  DB*  U DB,.  Let  6  be  a  rule  in  DB*  U DB,. 
that  6  is  in  DB*.  Let  M*  be  the 
If  S  is  in  DB,,  clearly 
restrictian 
in  DB*.  By  part  ( 1)  of  this  lemma,  M*  is  a 
stable  model  of  DB*,  and  so  M*  satisfies  8.  It  cannot  be  the  case  that  the  body  of  a 
rule  that  belongs 
to 
true,  and  hence  S  must  be  satisfied  by  M  as  well.  Next,  we  show  that 
a  higher  strata 
to  M  and  DB*  U DB,.  If  an  atom  A  belongs 
every  atom  in  M  has  a  proof  with  respect 

it  is  satisfied  by  M.  Suppose 

satisfied  by  making  atoms 

to  a  lower  strata  becomes 

of  M  to  the  atoms 

that  appear 

that  belong 

442 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/ArtQicial  Intelligence  96  (1997)  421-449 

Long-EA(  T) 

Input: A  positive  HCF  theory  T. 
Output: A  minimal  model  for  T. 

begin 
1.  M  :=  a  model  of  T;  M’  :=  8;  i :=  0;  j  :=  0. 
2. Deleted(i) 

:=  0;  iteration  :=  (i, j). 

Let A be  the  set  of  all  clauses  6  in  T  violated  by  M’  such  that  for  each  6  E  d,  Ihead(d,  M)  1 = 1. 
If  d  =  0, go to  Step  3. 
Else,  let  X  :=  n,,, 

head( 6, M); 

M’:=M’flX; 
M  :=  M  -  X; 
For  each  A  E  X,  stage(A) 
j:=j+l; 
repeat  Step  2. 

:=  (i,  j); 

in  T  violated  by  M’  such  that  for  each  6  E  A,  Ihead(8,  M)I  >  2. 

3.  Let  d  be  the  set  of  all  clauses 
If  A =  0,  return  M’. 
Else,  let  H  :=  n,,, 
let  M  :=  M  -  X;  Deleted(i) 
Let A’  be  the  set  of  all  clauses  6  in  T  such that the  body  of  6  is  satisfied  by  M’  and  Ihead( 8, M)I=  1. 
If  A’  =  0,  repeat  Step  3. 
Else,  j  :=  0;  i  :=  i +  1;  go  to  Step  2. 

head(  8, M),  and  let  X  be  a  source  of  H; 

:=  Deleted(i)  n  X; 

end. 

Fig.  A.l.  The  elimination 

algorithm:  Proof  version. 

to  M  and  DB*  U DB,.  Suppose 

to  M*,  the  proof  of  A  with  respect 
respect 
A  has  a  proof  with  respect 
respect 
to  DB”  U DB,  and  M.  LY is  composed 
and  from  rules  from  DB,.  We  have  already  shown 
a  proof  with  respect 
respect 

to  M*  and  DB*  must  be  also  a  proof  of  A  with 
to  strata  I-.  We  show  next  that 
to  M  and  DB*  U DB,.  We  take  the  proof  (Y that  A  has  with 
to  M* 
to  M*  have 
to  M  and  DB*  U DB,.  Hence,  we  can  construct  a  proof  of  A  with 

from  proofs  of  atoms  that  belong 

to  M  and  DB*  U DB,. 

that  A  belongs 

that  belong 

that  atoms 

0 

A.2.  Proofs  of  theorems 

Theorem  2  (The  EA 
generates  a  minimal  model  of  T. 

is  correct).  Given  a  positive  HCF 

theory  T  as  input, 

the  EA 

The  proof  is  done  using  algorithm  Long-EA 
the  EA  does,  except  that  it  uses  some  indexes 

in  Fig.  A.l.  Long-EA  does  exactly  what 
that  will  be  employed 

in  the  proof. 

Lemma  A.4. 
stage(A)  =  (i,  c) ,  then: 

Let  T  be  a  theory,  and 

let  EA(  T)  =  M.  For  any  atom  A  in  M, 

if 

( 1)  There  is  an  atom  B  in  M  such  that  stage(B)  =  (i,  0)  ,  and  there  is  a  path  from 

B  to  A  in  GT. 

(2)  For  each  atom  B  such  that  stage(B)  =  (i,  0)  and  for  each  atom  C  such  that 

C  E  DeZeted(  j)  for  some  0  <  j  <  i,  there  is  no  path  from  B  to  C. 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Art@ial 

Intelligence  96  (1997)  421-449 

443 

Proof.  By  induction  on  stuge(  A)  (assuming 

a  lexicographic 

order). 

Case  smge(  A)  = (0,  c) . Condition  2  holds  trivially.  Condition 

1  is  proved  by  induc- 

tion  on  c: 

1  clearly  holds  (take  B  = A). 

Case  sruge(  A)  = (0,O)  : Condition 
Case  sl’uge(  A)  = (0,  k) ,  where  k  >  0:  Consider 

j  =  k  (j  as  in  Step  2  of  the  EA). 

the  execution  of  Step  2  in  the  time 
when 
It  must  be  the  case  that  there  is  a  clause  S 
in  A  such1 that  he&(  6, M)  =  {A}  and  there  is  an  atom  D  in  the  body  of  6  such  that 
stuge(  D)  = (0,  k -  1)  (otherwise  A  would  belong 
to  a  lower  stage).  By  the  induction 
hypothesis, 

then,  Condition 

1  holds. 

Case stage(A)  = (n,  c) , fir  some  n  > 0.  Condition  2  holds:  Assume  by  contradiction 
that  it  does  not  hold.  In  this  case,  there  is  an  atom  B  such  that  stage(B)  = (n,  O),  and 
there  is  m  atom  C  E  Deleted(j),  0  <  j  <  n,  such  that  there  is  a  path  in  GT  from  B  to 
C.  Note  that,  since  stuge(  B)  = (n, 0),  it  must  be  the  case  that  B  is  in  the  head  of  some 
clause  6  of  the  form 

A,  A  . . . A A,  +  B  v  B1 V  . . . v  B, 

such  that  for  each  At,  1  <  t  <  I,  stuge(A,)  = (u,  u)  for  some  u  <  n.  Let  (w,  z)  be  the 
. . ,A,,  and  assume  D  is  the  one  Al,.  . . ,A,  having  stage 
highest  stage  of  any  of  Al,. 
(w,  z ).  Since  stuge( B)  = (n, 0)  and  w  <  n,  it  must  be  the  case  that  for  some  k  2  z, 
the  body  of  6  is  satisfied  by  M’  at  Step  3  when  iteration  =  (w,  k).  Since 
there  is  a 
path  from  B  to  C  in  GT,  and  since  the  X  chosen 
in  Step  3  is  a  source  of  H,  it  cannot 
to  one  of  Deleted(w)  , DeZeted( w +  1) , . . . , DeZeted( n -  1) . 
be  the  case  that  C  belongs 
Suppose 
on  Condition 
is  a  path  from  B’  to  D.  So  there  is  a  path  from  B’  to  C.  But  C  is  in  Deleted(t), 
contradiction 
Condition 
Case  skzge(  A)  = (n,  0) :  Condition 
Case  stage(A)  = (n,  k) , for  some  k  >  0:  In  this  case,  there  must  be  a  clause 

for  some  0  <  t  <  w.  By  the  induction  hypothesis 
1,  there  must  be  an  atom  B’  in  A4 such  that  stuge( B’)  = (w,  0)  and  there 
a 

to  the  induction  hypothesis  on  Condition  2. 
1  is  proved  by  induction  on  c: 

1  clearly  holds  (take  B  = A). 

to  Deleted(t) 

that  C  belongs 

in  the 

program 

A,  A  . . . A A,  +  A  V  B1 V  . +. V  B, 

such  that  for  some  1  <  j  6  r,  stuge( Aj)  = (n,  k -  1).  Using 
1  holds. 
we  observe 

that  Condition 

cl 

the  induction  hypothesis, 

Corollary  AS.  For  each  atom  D  such  that  stage(D)  =  (i, j)  for  some  i, j,  and  for 
for  some  0  <  t  <  i,  there  is  no path  from  D 
each  atom  C  such  that  C  E  Deleted(t) 
to  c. 

Proof.  Suppose  stuge( D)  = (i, j).  By  Condition 
in  M  =  KA(T) 
By  Condition 
0  < 
(otherwise  we  could  get  from  B  to  C  via  D).  q 

1  of  Lemma  A.4  there  is  an  atom  B 
such  that  stuge( B)  =  (i, 0)  and  there  is  a  path  from  B  to  D  in  GT. 
for  some 
is  no  path  from  B  to  C.  So  there  cannot  be  a  path  from  D  to  C 

2  of  Lemma  A.4,  for  each  atom  C  such  that  C  E  Deleted(t) 

t  <  i,  there 

444 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Artijicial  Intelligence  96  (1997)  421-449 

Lemma  A.6.  The  following 

invariants  hold  throughout 

the  execution  of  the  EA: 

( 1)  Every  atom  in  M’  has  a  proof  with  respect  to  M’  and  T. 
(2)  For  each  clause  violated  by  Mt,  there  is  an  atom  in  its  head  that  belongs 

to  M. 

that 

to  observe 

the  first  claim  holds.  We  start  the  algorithm  with 
Proof.  It  is  easy 
M’  =  8,  and  whenever  we  add  an  atom  A  to  M’,  it  is  the  case  that  there  is  a  clause  6 
to  M’  and  A  is  the  only  atom  in 
in  T  such  that  all  the  atoms  in  the  body  of  S  belong 
the  head  of  S  which  belongs 
to 
to  T 
M.  Therefore,  we  conclude 
and  Mt. 

to  M  n Mt.  Atoms  are  added  to  M’  only  if  they  belong 
that  for  each  atom  in  M’,  there  is  a  proof  with  respect 

commands 

that  add  atoms 

The  second  claim  holds  when  we  finish  Step  1 of  the  algorithm,  because  M’  is  empty 
false  after 
from  M.  The  algorithm 

and  the  initial  M  is  a  model  of  T.  Hypothetically, 
executing 
contains 
and  3.  We  will  show  that  if  the  claim  holds  just  before  we  execute 
also  holds  after  we  execute 
that  belong 
holds  before  doing 

two  such  commands:  “MI  := M’  fl  X”  in  Step  2  and  “M  := M  -  x”  in  Steps  2 
it 
In  Step  3,  we  delete  from  M  only  atoms 
if  the  claim 

to  a  source  of  all  the  atoms  in  heads  of  violated  clauses;  hence, 

this  claim  may  become 

to  M’  or  delete  atoms 

it  holds  after  as  well. 

these  commands. 

these  commands, 

this  command, 

It  is  left  to  show  that  if  the  second  claim  holds  before  we  execute  the  two  consecutive 

the  commands, 

the  commands  when  iteration 

the  two  commands.  Further,  assume  by  contradiction 

that  for  each  A  E  X,  we  have  stage(A)  =  (i,  j).  Suppose 

“Ml  :=  M’  I-  X;  M  :=  M  -  X”  in  Step  2,  it  holds  after  we  execute 

commands 
these 
is  set  to  (i,  j)  for  some 
commands.  Suppose  we  execute 
i, j.  Note 
the  claim  was 
valid  just  before  executing 
that 
after  executing 
is  violated  by  M’ 
to  M.  It  must  be  the  case  that  there  is  some 
and  no  atom  in  this  clause’s  head  belongs 
the  claim  would  not  hold 
to  X  (otherwise 
atom  A  in  the  body  of  S  which  belongs 
iteration  =  (i,  j),  all  atoms 
just  before  executing  M’  :=  M’  n  X;  M  := M  -  X).  Since 
for  some  t  <  i. 
deleted  so  far  from  M  which  are  not  in  M’  must  belong 
By  Corollary  AS,  none  of  the  atoms  in  the  head  of  6  were  deleted 
M  so  far.  Hence, 
0 
contradiction. 

in  the  head  of  S  which  belongs 

is  some  clause  6  in  T  which 

there  must  be  an  atom 

from  (the  initial) 

to  Deleted(t) 

to  M,  a 

there 

Proof  of  Theorem  2.  It  is  easy  to  see  that  the  EA  always 
a  propositional 
theory  T.  Clearly,  M’  satisfies  each  clause 
with  respect 

terminates  when  the  input  is 
theory.  Let  M’  be  the  model  returned  by  EA  when  it  is  given  the  input 
in  T.  By  Lemma  A.6,  each  atom  has  a  proof 

to  T  and  Mt.  By  Theorem  A.l,  M’  is  a  minimal  model  for  T. 

0 

Theorem  13  (The  EA3 
the  input  theory. 

is  correct).  The  EA3  generates  a  minimal  Herbrand  model  of 

Before  proving  Theorem  13,  we  prove  the  following 

lemma. 

Lemma  A.7.  The  following 
EA3: 

invariants  hold  throughout 

the  execution  of  the  algorithm 

( 1)  Every  atom  in  M  has  a  proof  with  respect  to  M  and  gr(  T). 

R.  Ben-Eliyahu-Zohqx  L.  Palopoli/Art$cial 

Intelligence  96  (1997)  421-449 

445 

(2)  For  each  ground  instance  of any  rule  violated by  M,  there  is an  atom  in  its head 

whose  predicate  name  does  not  belong  to  M’. 

Proof.  First  we  show  that  the  first  claim  holds.  We  start  the  algorithm  with  M  =  0,  and 
whenever  we  add  an  atom  A  to  M,  it  is  the  case  that  there  is  an  instance  6  of  a  rule  in 
to  M  and  A  is  the  only  ground 
T  such  that  all  the  ground  atoms  in  the  body  of  S  belong 
atom  in  the  head  of  S  whose  predicate  name  does  not  belong 
to  M’.  Ground  atoms  are 
to  M’.  Since  no  predicate  name 
added  to  M  only  if  their  predicate  names  do  not  belong 
to  M. 
can  be  deleted 
Consequently,  we  conclude 
to 
gr(T) 

from  M’,  no  other  ground  atom  in  the  head  of  6  will  be  added 

in  M,  there  is  a  proof  with  respect 

that  for  each  atom 

and  M. 

The  second  claim  holds  trivially  when  we  finish  Step  1 of  the  algorithm,  because  M’ 
that  add  atoms  to  M 
is  empty.  The  claim  could  become 
or  predicate  names 
“M  :=  M  f~ X”  in 
Step  2,  and  “M’  :=  M’  f! N”  in  Step  3.  We  will  show  that  if  the  claim  holds  just  before 
we  execute 
the  command  “M  :=  M  rl X”  in  Step  2  and  the  command  “MI  :=  M’  II N” 
in  Step  3,  it  holds  after  we  execute 

false  after  executing  commands 

to  M’.  EA3  contains  only 

two  such  commands: 

these  commands. 

Suppose  we  execute 

the  command  “M  :=  M  n X” in  Step  2  and  let  d’  be  the  set  of 

of  rules 

all  instances 
Assume  by  contradiction 
predicate  names 
added  to  M’  sometime 
the  body  of  8.  It  follows 
T.  By  induction 
M’,  we  will  show  that  there 
assumption. 

that  some  instance  6  E  d’  contains 

in  T  that  become  violated  after  the  execution  of  this  command. 
in  its  head  only  atoms  with 
from  M’.  Let  p  be  a  predicate  name  of  an  atom  from  the  head  of  S 
in  Step  3,  and  let  q  be  a  predicate  name  of  an  atom  from  X  in 
graph  of 
to 
to  our 

that  there  is  a  path  from  q  to  p  in  the  dependency 
on  i,  the  number  of  times  Step  2  was  executed  after  p  was  added 

is  no  path  from  q  to  p,  which 

is  a  contradiction 

Basis,  .for  i =  0.  We  execute  Step  2  immediately 

after  adding  p  to  M’  in  Step  3.  Let 
A be  the  set  of  all  rules  violated  by  M  before  executing  Step  2.  Clearly,  q  is  in  the  head 
of  a  rule  in  A,  and  q  was  not  added  to  M’  in  Step  3  (because  q  E  X),  so  q  does  not 
the  last 
belong 
time  that  we  executed  Step  3,  so  p  does  belong 
in  Step  3.  This 
means 
th,at  there  is  no  path  from  q  to  p  in  the  dependency  graph  of  T,  by  our  definition 
of  source. 

in  Step  3.  However,  p  was  added  to  M’  during 

tcl  the  source  we  found 

to  the  source  we  found 

Induction  step.  Assume 

that  Step  2  was  executed  k  >  0  times  after  we  added  p  to 

M’  in  Step  3.  Let  Y  be  a  set  of  predicate  names  of  atoms  added  to  M  when  executing 
to  M  when 
Step  2  the  k  -  1  time  after  we  added  p  to  M’  in  Step  3.  Y  was  added 
executing  Step  2  the  k  -  1  time,  and  the  atom  with  predicate  name  q  was  added 
to 
there  must  exist  some  atom  C  whose 
M  when  executing  Step  2  the  k  time.  Therefore, 
an  atom  with  predicate  name  q  in  the  head 
predicate  name  is  in  Y and  a  rule  containing 
that  there  is  a  path  from  the  predicate  name 
and  the  atom  C  in  the  body.  This  means 
of  C  to  q.  By  the  induction  hypothesis, 
there  is  no  path  from  the  predicate  name  of  C 
there  cannot  be  a  path  from  q  to  p  (otherwise  we  could  reach  p  from  the 
to  p.  Hence, 
predicate  name  of  C  via  q). 

Suppolse  now  that  we  execute 
this  command, 

the  command  M’  :=  M’ fl N  in  Step  3.  Note  that  before 
in  A,  the  set  of 

it  is  the  case  that  the  heads  of  all  the  instances 

executing 

446 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Art#cial  Intelligence  96  (1997)  421-449 

all  instances  violated  by  M,  contain  at  least  two  ground  atoms  whose  predicate  names 
to  M’.  Now,  it  cannot  be  the  case  that  there  are  two  ground  atoms  from 
do  not  belong 
the  head  of  the  same  instance  such  that  their  predicate  names  belong 
to  N,  because  T  is 
HCF  and  the  predicate  names  of  all  the  atoms  in  N  are  in  the  same  strongly  connected 
graph  of  T.  Thus,  it  must  be  the  case  that  after  executing 
component 
the  command  M’  :=  M’  n  N  in  Step  3  the  second  claim  holds. 

in  the  dependency 

0 

terminates.  Suppose 

positive  HCF  theory  T.  Let  ‘FI denote 

Proof  of  Theorem  13.  First  we  show  that  the  EA7 
is  a  nonground 
end  of  Step  2,  either  at  least  one  atom  from  IFI is  added  to  M  or  we  jump 
Step  3,  the  EAF  either  adds  at  least  one  predicate  name  to  M’  or  stops.  Since  M  C  3-1, 
stops  when  there  is  no  predicate  name  from 
‘FI is  finite,  M’  is  finite,  and  the  algorithm 
It  is  left  to  show  that  when  the  algorithm 
T  that  is  not  in  M’,  the  EA7  must  terminate. 
terminates,  M  is  a  minimal  model  of  T.  Note  that  M  is  a  minimal  model  of  T  if  and 
only 
to  show  that 
when  the  EA3 

that  the  input 
the  Herbrand  base  of  T.  At  the 
to  Step  3.  At 

if  it  is  a  minimal  model  of  gr(  T)  .  By  Theorem  A.l, 

it  is  enough 

terminates, 

( 1)  M  is  a  model  of  gr(  T)  , and 
(2)  every  atom  in  M  has  a  proof  with  respect 

to  M  and  gr(  T)  . 

We  proved 
show  that  ( 1)  holds  as  well.  Hence,  M  is  a  minimal  model  of  T.  Cl 

in  Lemma  A.7  that  (2)  holds.  Using  Condition  2  of  Lemma  A.7,  we  can 

Theorem  20  (The  EAs 
SHDDB. 

is  correct).  The  EAs  generates  a  stable  model  of  the  input 

Proof.  First  note  that  since 
input  SHDDB 
and  the  correctness 
EAs 

the  EA  terminates 
the  EAs 
in  Step  3c  of  EAs), 
indeed  generates  a  stable  model  of  the  input  SHDDB. 

is  finite  by  definition, 
of  the  EA  (used 

and  since  the  number  r  of  strata  of  any 
terminates.  By  part  (2)  of  Lemma  A.3 
it  is  easy  to  show  that  the 

0 

Theorem  21.  If  M  is  a  stable  model  of  an  SHDDB  DB,  then  there  is  an  execution  of 
the  EAs 

that  outputs  M. 

{So,..., 

S,.}  be  a  stratification 

let 
Proof.  Let 
partition  of  DB’s  rules,  r  3  1.  Let  M  be  a  stable 
{DB,,... 
model  of  DB.  We  want  to  show  that  M  is  generated  by  EAs.  We  proceed  by  induction 
on  r. 

, DB,}  be  the  corresponding 

of  the  predicate 

in  DB,  and 

symbols 

Basis,  for  r  =  1.  In  this  case,  it  is  sufficient 

for 
if  M  is  a  minimal  model  of  DBO. Indeed,  by  definition,  M  is  a  stable 
DB  if  and  only 
model  of  DB  if  and  only  if  M  is  a  minimal  model  of  DB”.  Because  r  =  1,  the  predicate 
name  of  each  negative 
to  SO. Therefore, 
DBM = DB”.  The  claim 

literal  appearing 
then  follows  from  Theorem  4. 

to  show  that  M  is  a  stable  model 

in  any  rule  of  DB  belongs 

Induction,  assume  the  algorithm  is  complete  for  r  strata.  Consider 

a  SHDDB  DB 
with  r  +  1  strata.  Let  M,  be  the  restriction  of  M  to  the  predicate  names  belonging 
to 
s,  u  . . . U  S,.  By  part  ( 1)  of  Lemma  A.3,  M,  is  a  stable  model  for  DB1  U  * . + U DB,. 
that 
By  induction, 

there  exists  an  execution  of  the  EAs  with  input  DB1  U  . . . U DB, 

R.  Ben-Eliyahu-Zohary,  L.  Palopoli/Arttficial  Intelligence  96  (1997)  421-449 

447 

generates  M,.  It  is  then  immediate 
DB  that  generates  M, as the result  associated 
it  is  therefore  sufficient 
model  of  G  =  DB)I;, U {A  +I  A E M,}. Note 
M = M, C7 M', for  some  M' which 
M' is  a  minimal  model  of  DB2,. Hence,  M must  be  a  minimal  model  of  $. 

that  there  exists  an  execution  of  the  EAs  with  input 
to  the  first  r  strata  of  DB. By  Theorem  4, 
to  show  that  if  M is  a  stable  model  of  DB, then  M is  a  minimal 
that  M is  a  stable  model  of  DB if 
is  a  stable  model  of  DB%,. Since  DB%, is  positive, 

0 

Acknowkdgments 

We  thank  Victoria  Zemlyanker 

in  !Section  3  of  this  paper.  We  also  gratefully 

EAF 
anonymous 
thank  Marco  Cadoli,  Rina  Dechter,  Thomas  Eiter,  and  Georg 
useful 
Bonnice 

(some 
for  editing  on  parts  of  this  paper. 

for  allowing  us  to  include  her  version  of  algorithm 
raised  by  the 
the  quality  of  this  paper.  We 
for 
to  Michelle 

their  remarks  helped  us  improve 

through  e-mail).  Thanks  also 

(Giorgio)  Gottlob 

and  discussions 

acknowledge 

suggestions 

referees; 

points 

The  work  of  the  first  author  was  supported 
AFOSR  90-0136,  and  in  part  by  an  infrastructure 
the  Israeli  Ministry  of  Science.  The  second  author  is  supported 
the  EU-US  project  “DEUS  EX  MACHINA:  Non-determinism 
and  by  a  MURST  grant  (40%  share)  under 
basi  di  dati  evolute”. 

the  project  “Sistemi 

in  part  by  grants  NSF  IRI-88-21444 
technology 

grant  for  data-mining 

and 
from 
in  part  by  the  ECC  under 
for  deductive  databases” 
formali  e  strumenti  per 

References 

[ I]  S.  Abiteboul,  E.  Simon  and  V.  Vianu,  Non-deterministic 

to  express  deterministic 
transformations,  in:  Proceedings  Ninth ACM  Symposium  on  Principles  of  Database  Systems,  Nashville, 
TN  (1990)  218-229. 

languages 

[2]  K.R.  Apt,  H.A.  Blair  and  A.  Walker,  Towards  a  theory  of  declarative  knowledge,  in:  J.  Minker,  ed., 
Foundations  of  Deductive  Databases  and  Logic  Programming  (Morgan  Kaufmann,  Los  Altos,  CA, 
1988:1 89-148. 

[ 31 C. Baral, J. Lobo  and J. Minker,  WP3:  a semantics  for  negation in normal disjunctive  logic  programs,  in: 
Z.W. Ras and M. Zemankova,  eds.,  Methodologiesfor  Intelligent Systems:  Proceedings  6th International 
Symposium,  ISMIS’91  ( 1991)  459-468. 

[4]  C.  Bell,  A. Nerode,  R.T. Ng and V.S. Subrahmanian,  Mixed integer programming  methods  for computing 

non-monotonic  deductive  databases,  J.  ACM  41  (6)  ( 1994)  1178-1215. 

[5]  R.  Ben-Eliyahu,  A  hierarchy  of  tractable  subsets  for  computing  stable  models,  J.  Art@  Intell.  Res.  5 

( 1996)  27-52. 

[6]  R. Ben-Eliyahu  and  R. Dechter,  On computing  minimal  models,  Ann.  Math. Artif  Intell.  18  ( 1)  ( 1996) 

3-27;  short  version  in:  Proceedings  AAAI-93,  Washington,  DC  ( 1993) 2-8. 

[7]  R.  Ben-Eliyahu  and  R.  Dechter,  Propositional  semantics  for  disjunctive  logic  programs,  Ann.  Math. 
Artif  Intell.  12  (1994)  53-87;  short  version  in:  Proceedings  1992  Joint  International  Conference  and 
Symposium  on  Logic  Programming  (JICSLP-92),  Washington,  DC  ( 1992). 

[ 81 R.  Be.n-Eliyahu and  R.  Dechter,  Default  reasoning  using  classical  logic, Artificial Intelligence  84  ( l-2) 

( 1996)  113-150. 

[9]  M.  Cadoli,  The  complexity  of  model  checking  for  circumscriptive  formulae,  Inform.  Process.  Lett.  44 

(3) 

(1992)  113-118. 

R.  Ben-Eliyahu-Zohary.  L.  PalopoWArtijicial  Intelligence  96  (1997)  421-449 

448 

[lOI 

1111 

[I21 

in:  A.  Marchetti 
M.  Cadoli,  On  the  complexity  of  model  finding  for  nonmonotonic 
Spaccamela,  P  Mentrasti  and  M.  Venturini  Zilli,  eds.,  Proceedings  4th Italian  Conference  on  Theoretical 
Computer  Science  (1992)  125-139. 
Z.  Chen  and  S.  Toda,  The  complexity 
(1995)  313-325. 
J.  de  Kleer,  A.K.  Mackwotth 

solutions,  btform.  and  Comput.  119  (2) 

diagnoses  and  systems,  Artijicial Intelligence 

and  R.  Reiter,  Characterizing 

of  selecting  maximal 

propositional 

logics, 

[I31 
[I41 

I151 

1161 

[I71 

1181 

1191 

r201 

[211 

1221 

]23 

~24 1 

56  (2-3)(1992) 
J.  de  Kleer  and  B.C.  Williams,  Diagnosing  multiple 
R.  Dechter,  Personal  communication 

197-222. 

(October  1993). 

faults,  ArttJiciul Intelligence  32  ( 1)  ( 1987)  97-130. 

in:  Proceedings  1992  Joint  International 

logic  programs, 

(1996)  87-100. 

to  non-disjunctive 

semantics  of  disjunctive 

J.  Dix,  Classifying 
Conference  and  Symposium  on  Logic  Programming  (JXSLP-92),  Washington,  DC  ( 1992)  798-812. 
J.  Dix,  G.  Gottlob  and  V.  Marek,  Reducing  disjunctive 
Fund.  Inform.  28  (l-2) 
W.P.  Dowling  and  J.H.  Gallier,  Linear-time  algorithms 
formulae, 
J.  Logic  Programming  1  (3) 
T.  Eiter  and  G.  Gottlob,  Propositional 
complete,  Theoret.  Comput.  Sci.  114  (2) 
T.  Eiter,  N.  Leone  and  D.  Sac&,  The  expressive  power  of  partial  models 
databases, 
T.  Eiter,  Personal  communication 
M.  Gelfond 

(October  1993). 
and  V.  Lifschitz,  Classical  negation 

in:  Proceedings  LID-96,  San  Miniato, 

( 1984)  267-284. 
circumscription 

and  extended  closed-world 

also:  Theoret.  Comput.  Sci.,  to  appear. 

semantics  by  shift-operations, 

in  logic  programs 

(1993)  231-245. 

and  disjunctive 

for  disjunctive 

Italy  (1996); 

the  satisfiability  of  propositional  Horn 

databases,  New 

for  testing 

deductive 

reasoning 

are  Hz- 

(1991)  365-385. 

Generation  Comput.  9  (3-4) 
M.  Gelfond,  H.  Przymusinska,  V.  Lifschitz  and  M.  Truszczyriski,  Disjunctive  defaults, 

in:  Proceedings 
2nd  International  Conference  on  Principles  of  Knowledge  Representation  and  Reasoning  (KR-91), 
Cambridge,  MA  (1991)  230-237. 
E  Giannotti,  D.  Pedreschi,  D.  Sacca  and  C.  Zaniolo,  Non-determinism 
Proceedings  2nd  International  Conference  on  Deductive  and  Object  Oriented  Databases  (1991). 
J.  Halpem  and  M.  Vardi,  Model  checking  vs.  theorem  proving:  A  manifesto, 
in:  Proceedingsbtternational 
Conference  on Principles  of Knowledge  Representation  and Reasoning  (KR-91)  , Cambridge,  MA  ( 1991) 
325-334. 

in  deductive  databases, 

in: 

~25  A.  Itai  and  J.A.  Makowsky,  Unification 

as  a  complexity  measure 

for  logic  programming, 

J.  Logic 

Programming  4  (2) 

(1987)  105-117. 

[26]  PG.  Kolaitis  and  C.H.  Papadimitriou, 

Some  computational 

aspects  of  circumscription, 

J.  ACM  37  ( 1) 

(1990) 

l-14. 

[27]  N.  Leone, 

computation, 

f?  Rullo  and  E  Scarcello,  Disjunctive 
btform.  and  Comput.  135  (2) 

(1997)  69-l  12. 

stable  models:  unfounded 

sets,  fixpoint  semantics  and 

[28]  H.  Levesque,  Making  believers  out  of  computers,  Artijcial  Intelligence  30  ( 1)  (1986)  81-108. 
[29  ]  V.  Lifschitz,  Computing 
[30]  J.  McCarthy,  Circumscription-a 

in:  Proceedings  IJCAI-85,  Las  Angeles,  CA  (1985)  121-127. 
reasoning,  Arttficiaf  Intelligence  13  (l-2) 

form  of  non-monotonic 

circumscription, 

(1980)  27-39. 

13 1 ]  J.  McCarthy,  Applications 
Intelligence  28  (1) 

(19860  89-116. 

of  circumscription 

to  formalizing 

common-sense 

knowledge,  Artijicial 

[ 321  J.  Minker,  On  indefinite  databases  and  the  closed-world 

assumption, 

in:  Proceedings  6th  Conference  on 

Automated  Deduction,  Lecture  Notes  in  Computer  Science,  Vol.  138  (Springer,  Berlin,  1982)  292-308. 
reasoning, 

[ 331  I. Niemela  and  J.  Rintanen,  On  the  impact  of  stratification  on  the  complexity  of  non-monotonic 

J.  Appl.  Non-Classical  Logics  2  (1994)  141-179. 

[34]  C.H.  Papadimitriou,  On  selecting 

a  satisfying 

truth  assignment, 

in:  Proceedings  32nd  Annual  ACM 

Symposium  on  Foundations  of  Computer  Science 

(1991)  163-169. 

[35]  Y.  Peng  and  J.  Reggia,  Plausibility 

of  diagnostic 

hypothesis:  The  nature  of  simplicity, 

IEEE  Trans. 

Systems  Man  Cybernet.  17  (1987)  146-162. 

[ 361  T.  Przymusinski,  On  the  declarative 

in:  J.  Minker, 
ed.,  Foundations  of  Deductive  Databases  and  Logic  Programming  (Morgan  Kaufmann,  Los  Altos,  CA, 
1988)  193-216. 

semantics  of  deductive  databases  and  logic  programs, 

R.  Ben-Eliyahu-Zohary,  L.  PalopoWArttficial  Intelligence  96  (1997)  421-449 

449 

[37]  T.C. Przymusinski,  Stable  semantics  for  disjunctive  programs,  New Generation  Comput.  9  (1991)  401- 

424. 

[ 381  R. Reiter, On  closed-world  databases,  in:  H. Gallaire and J. Minker, eds.,  Logic and Data  Bases  (Plenum 

Press,  New  York,  1978)  55-76. 

[39]  R.  Reiter,  A  logic  for  default  reasoning,  Arttjicial Intelligence  13  (l-2) 
[40]  D.  Sad 

and  C.  Zaniolo,  Stable  models  and  nondeterminism  in  logic  programs  with  negation,  in: 

(1980)  81-132. 

Proceedings  Ninth ACM  Symposium  on  Principles  of Database  Systems,  Nashville,  TN  (1990). 

[41]  T.J. Schaefer,  The  complexity  of  satisfiability  problems,  in:  Proceedings  IOrh Annual  ACM  Symposium 

on  Theory  of  Computing  (1978)  216-226. 

[42]  M.  Schaerf,  Negation  and  minimality  in  disjunctive  databases,  J.  Logic  Programming  23  (1)  (1995) 

63-86. 

[43]  R. Tarjan, Depth-first  search  and  linear  graph  algorithms,  SIAM  J.  Comput.  1 (2)  (1972)  146-160. 
[44]  M.Y. Vardi, The complexity  of relational  query languages,  in: Proceedings  14rh Annual ACM  Symposium 

on  Theory  of  Computing  (STOC-82) 

(1982)  137-145. 

