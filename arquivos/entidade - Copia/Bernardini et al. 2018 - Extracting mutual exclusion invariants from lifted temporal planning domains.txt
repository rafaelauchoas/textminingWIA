Artiﬁcial Intelligence 258 (2018) 1–65

Contents lists available at ScienceDirect

Artiﬁcial  Intelligence

www.elsevier.com/locate/artint

Extracting  mutual  exclusion  invariants  from  lifted  temporal 
planning  domains
Sara Bernardini a,∗
a Department of Computer Science, Royal Holloway University of London, Egham, Surrey, TW20 0EX, UK
b Department of Mathematical Sciences “G. L. Lagrange”, Politecnico di Torino, Corso Duca degli Abruzzi, 24, 10129 Torino, Italy
c Intelligent Systems Division, NASA Ames Research Center, Moffett Field, CA 94035, United States

,  Fabio Fagnani b,  David  E. Smith c

a  r  t  i  c  l  e 

i  n  f  o

a  b  s  t  r  a  c  t

Article history:
Received 6 January 2017
Received in revised form 24 January 2018
Accepted 27 January 2018
Available online 6 February 2018

Keywords:
Automated planning
Temporal planning
Mutual exclusion invariants
Automatic domain analysis

We  present  a  technique  for  automatically  extracting  mutual  exclusion  invariants  from 
temporal  planning  instances.  It  ﬁrst  identiﬁes  a  set  of  invariant  templates  by  inspecting 
the lifted representation of the domain and then checks these templates against properties 
that  assure  invariance.  Our  technique  builds  on  other  approaches  to  invariant  synthesis 
presented in the literature but departs from their limited focus on instantaneous actions 
by  addressing  temporal  domains.  To  deal  with  time,  we  formulate  invariance  conditions 
that account for the entire temporal structure of the actions and the possible concurrent 
interactions between them. As a result, we construct a more comprehensive technique than 
previous methods, which is able to ﬁnd not only invariants for temporal domains but also a 
broader set of invariants for sequential domains. Our experimental results provide evidence 
that our domain analysis is effective at identifying a more extensive set of invariants, which 
results in the generation of fewer multi-valued state variables. We show that, in turn, this 
reduction in the number of variables reﬂects positively on the performance of the temporal 
planners that use a variable/value representation.

© 2018 The Authors. Published by Elsevier B.V. This is an open access article under the 
CC BY license (http://creativecommons.org/licenses/by/4.0/).

1.  Introduction

This paper presents a technique for synthesising mutual exclusion invariants from temporal planning domains expressed 
in PDDL2.1 [21]. A mutual exclusion invariant over a set of ground atoms means that at most one atom in the set is true 
at  any  given  moment.  Mutual  exclusion  invariants  can  be  expressed  as  multi-valued  state  variables  by  adding  a  special 
“null”  value  so  that,  at  all  moments,  precisely  one  value  holds.  For  instance,  consider  the  Floortile domain  from  the  8th 
International Planning Competition (IPC’14 – see Appendix A). A mutual exclusion invariant for this domain states that two 
ground atoms that indicate the position of a robot can never be true at the same time. Intuitively, this means that a robot 
cannot be at two different locations simultaneously. To give a concrete case, consider a planning problem for the Floortile
domain with one robot r1 and three locations, t1, t2 and t3. We can create a state variable that indicates the position of 
r1 with a domain of three values: robotAt_r1_t1, robotAt_r1_t2 and robotAt_r1_t3.

Although  a  number  of  approaches  to  invariant  synthesis  have  been  proposed  so  far  [27,45,46,20,33],  they  are  limited 
in  scope  because  they  deal  with  sequential  domains  only.  Recently,  Rintanen  [47] has  proposed  a  technique  for  temporal 
domains,  but  this  technique  does  not  scale  to  complex  problems  because  it  requires  grounding  the  domain.  We  address 

* Corresponding author.

E-mail addresses: sara.bernardini@rhul.ac.uk (S. Bernardini), fabio.fagnani@polito.it (F. Fagnani), david.smith@PSresearch.xyz (D.E. Smith).

https://doi.org/10.1016/j.artint.2018.01.004
0004-3702/© 2018 The Authors. Published by Elsevier B.V. This is an open access article under the CC BY license 
(http://creativecommons.org/licenses/by/4.0/).

2

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Table 1
Examples of planners and their classiﬁcation based on whether they treat time explicitly or 
implicitly and whether they use a Boolean propositional representation or a multi-valued state 
variable representation.

Propositional

Variable/value

Classical
Temporal

HSP [9] FF [35] YAHSP [49]
LPG [25] POPF [12]

FD [32] LAMA [44]
TFD [18] EUROPA2 [23]

both  limitations.  We  ﬁnd  invariants  for  temporal  domains  by  applying  an  algorithm  that  works  at  the  lifted  level  of  the 
representation and, in consequence, is very eﬃcient and scales to large instances.

Our  invariant  synthesis  builds  on  Helmert  [33],  which  presents  a  technique  to  translate  the  non-temporal  subset  of 
PDDL2.2  [17] into  the  Finite  Domain  Representation  (FDR),  a  multi-valued  planning  task  formalism  used  by  Fast  Down-
ward [32].  Since  ﬁnding  invariants  for  temporal  tasks  is  much  more  complex  than  for  tasks  with  instantaneous  actions, 
a simple generalisation of Helmert’s technique to temporal settings does not work. In the temporal case, simultaneity and 
interference between concurrent actions can occur, hence our algorithm cannot check actions individually against the invari-
ance conditions, but needs to consider the entire set of actions and their possible intertwinements over time. In capturing 
the temporal case, we formulate invariance conditions that take into account the entire structure of the action schemas as 
well as the possible interactions between them. As a result, we construct a signiﬁcantly more comprehensive technique that 
is able to ﬁnd not only invariants for temporal domains, but also a broader set of invariants for sequential domains.

We describe our approach in two major steps. First, we provide a general theory at the ground level and offer results 
that insure invariance under two types of properties: safety conditions for individual instantaneous and durative actions as 
well as collective conditions that prevent dangerous intertwinements between durative actions. Then, we lift these results 
to  the  level  of  schemas  so  that  all  checks  needed  for  verifying  invariance  can  be  performed  at  this  higher  level,  without 
the need for grounding the domain. The complexity of these checks are of linear or low polynomial order in terms of the 
number of schemas and literals appearing in the domain.

1.1.  Motivations

Automated planning is a well-established ﬁeld of artiﬁcial intelligence and, in the more than ﬁfty years since its appear-
ance,  several  paradigms  have  emerged.  One  fundamental  difference  between  these  paradigms  is  whether  time  is  treated 
implicitly or explicitly. While classical planning focuses on the causal evolution of the world, temporal planning is concerned 
with the temporal properties of the world. In classical planning, actions are considered to be instantaneous, whereas in tem-
poral  planning  actions  have  durations  and  can  be  executed  concurrently.  Another  important  difference  between  planning 
paradigms relates to whether the world is modelled by adopting a Boolean propositional representation or a representation 
based  on  multi-valued  state  variables.  The  majority  of  the  work  in  planning  has  been  devoted  to  classical  planning  with 
domains expressed using propositional languages, and in particular PDDL [41] and its successors [21], the language of the 
International  Planning  Competition  (IPC).  However,  in  parallel  with  the  development  of  classical  propositional  planning,  a 
number of temporal planning systems have been proposed for coping with practical problems, especially space mission op-
erations [23,11,28,42,24]. Typically, these systems use variable/value representations. Table 1 shows a classiﬁcation of several 
well-known planners based on these different characteristics.

Recently, a few techniques have been proposed for translating propositional representations into variable/value represen-
tations [32,5,47]. A central task of all these techniques is the generation of state variables from propositions and actions. The 
basic procedure to do this (which we use as the baseline in our experiments) relies on generating one state variable with 
two  values,  true  and  false,  for  each  proposition.  Naturally,  such  translation  produces  no  performance  advantage.  A more 
sophisticated strategy, which produces more compact and optimised encodings, rests on extracting mutual exclusion invari-
ants from propositional domains and using such invariants to generate multi-valued state variables. This is the focus of our 
work.

These  translation  techniques  are  important  as  they  allow  fair  testing  of  planners  developed  for  variable/value  repre-
sentations  on  PDDL  benchmarks  (which  are  propositional).  The  practical  issue  is  that  planners  that  permit  variable/value 
representation need this feature to be thoroughly exploited and perform competitively. Since translation between the two 
different representations can be cheaply automated, there is no reason to avoid providing the richer representations to those 
planners that accept them (if the translation was expensive, one might reasonably argue about the fairness of this process). 
As a consequence, these translation techniques are extremely useful for comparing alternative planning paradigms and for 
promoting cross-fertilisation of ideas between different planning communities, which is our primary motivation.

However,  the  importance  of  these  translation  techniques  goes  beyond  the  engineering  of  a  bridge  between  different 
input languages. In transforming propositional representations into state variable representations, they generate new domain 
knowledge,  where  new means  accessible in  this  context.  Effectively,  these  techniques  are  internal  mini  theorem  provers 
since,  rather  than  merely  translating,  they  ﬁrstly  selectively  explore  the  deductive  closure  of  the  original  theory  to  ﬁnd 
theorems that permit optimising the representation, and secondly execute those optimisations. We will show that the cost 
of performing these optimisations is worth it because it is very fast and can be amortised over many problems.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

3

Mutual exclusion invariants are also beneﬁcial in pruning the search space for search methods such as symbolic tech-
niques  based  on  SAT  [39,37] and  backward  chaining  search  [8].  In  addition,  as  invariants  help  to  reduce  the  number  of 
variables required to encode a domain, they are used in planning systems based on binary decision diagrams (BDDs) [16], 
constraint programming [14], causal graph heuristics [32] and pattern databases [31].

Finally,  from  a  knowledge  engineering  perspective,  the  invariant  synthesis  presented  in  this  paper  can  be  used  as  a 
powerful  tool  for  debugging  temporal  planning  domains.  We  do  not  focus  on  this  speciﬁcally  in  this  paper,  but  present 
a  case  study  in  Example  19.  As  shown  in  Cushing  et  al.  [13],  several  temporal  planning  tasks  developed  for  the  various 
IPC  competitions  are  buggy,  with  the  consequence  that  the  planners  take  a  long  time  to  solve  them,  when  they  actually 
manage  to  do  so.  As  invariants  capture  intuitive  properties  of  the  physical  systems  described  in  the  domains,  it  is  easy 
for a domain expert to identify modelling mistakes by inspecting them. Discrepancies between the invariants found by the 
automatic technique and those that the expert expects to see for a given domain indicate that the domain does not encode 
the physical system correctly. In consequence, the expert can revise the domain and repair it. For example, considering the 
Rover domain, we expect that a store could be either full or empty at any time point. However, the invariant synthesis 
does not produce an invariant with the atoms full and empty. It can be shown that this is because the action drop is 
not properly modelled. Our technique not only alerts the expert that the system is not properly modelled, but also refers 
the expert to the action that is not encoded correctly. This is a useful feature to ﬁx modelling errors quickly and safely.

1.2.  Contributions of the paper

In brief, the contributions of this paper are the following.
From a theoretical point of view:

• We give the ﬁrst formal account of a mutual exclusion invariant synthesis for temporal domains that works at the lifted 
level of the representation. Our presentation of this topic is rigorous and comprehensive and our theory is general.
• Our technique is based on inferring general properties of the state space by studying the structure of the action schemas 
and  the  lifted  relations  in  the  domain,  without  the  need  to  ground  it.  This  is  generally  a  hard  task.  Our  theoretical 
framework is sophisticated, but it results in practical tools that have high eﬃciency and low computational cost.

From a practical point of view:

• We provide a domain analysis tool for optimising the generation of state variables from propositions and actions (both 
instantaneous  and  durative).  This  results  in  more  compact  encodings  than  related  techniques  (see  Sections 10.1 and 
10.2). Succinct domain representations often beneﬁt the performance of planners (see Section 10.3).

• We offer a technique that can be used as a debugging tool for temporal planning domains. As these types of domains 
are  particularly  challenging  to  encode,  especially  when  large  and  complex,  a  rigorous  debugging  process  is  crucial  in 
producing correct representations of the systems under consideration (see Example 19).

1.3.  Organisation of the paper

This paper is organised as follows. After presenting PDDL2.1, our input language, in Section 2, we formally introduce the 

notion of invariance in Section 3.

Sections 4, 5 and 6 are devoted to a detailed analysis of actions at the ground level. In particular, Section 4 focuses on 
instantaneous actions: the fundamental concept of strong safety is introduced and analysed and a ﬁrst suﬃcient result for 
invariance, Corollary 23, is established. Section 5 analyses sequences of actions and, in particular, durative actions (seen as a 
sequence of three instantaneous actions) for which two new concepts of safety are formulated and investigated: individual
and simple safety. Our main technical results are presented in Section 6 and consist of Theorems 51 and 53 and Corollary 58: 
these results ensure invariance under milder safety requirements on the durative actions than Corollary 23. This is obtained 
by adding requirements that prevent the intertwinement of durative actions that are not strongly safe.

Sections 7 and  8 lift the  concepts  and  results  obtained  in  the  previous  sections  to  the  level  of  action  schemas.  In  par-
ticular, Section 7 deals with the problem of lifting the concept of strong safety for instantaneous schemas, while Section 8
considers durative action schemas and presents the lifted version of our main results, Corollaries 92, 97 and 98.

These  results  are  the  basic  ingredients  of  our  algorithm  to  ﬁnd  invariants,  which  we  present  in  Section 9.  Section 10
reports an extensive experimental evaluation of our approach against the domains of all the temporal IPCs. Sections 11 and 
12 conclude the paper with a description of related works and closing remarks. There are four appendices, A–D, that contain 
the speciﬁcations of the planning domains used as the running examples in the paper.

2.  Canonical form of planning tasks

In this work, we consider planning instances that are expressed in PDDL2.1 [21]. However, before applying our algorithm 
to ﬁnd invariants, we manipulate the domain to enforce a regular structure in the speciﬁcation of the action schemas. In 

4

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Section 2.1, we give a detailed account of this canonical form that we use and then, in Section 2.2, we describe how such a 
form can be obtained starting from a domain expressed in PDDL2.1.

2.1.  PDDL canonical form

Let us consider a ﬁrst order language L with a denumerable set of individual variable symbols V = {v 1, v 2, . . .} and a 
signature that has a denumerable set of constants K = {k1, k2, . . .} and a denumerable set of relation symbols Z , where each 
r ∈ Z is associated with a positive integer called arity and indicated as arit y(r).

Given  the  language  L,  a  planning  instance is  a  tuple  I = (D, P),  where  D is  a  planning  domain and  P a  planning 
problem. The domain D = (R, Ai, Ad) is a 3-tuple consisting of ﬁnite sets of relation symbols R ⊆ Z , instantaneous and 
durative actions. The problem P = (O, Init, G) is a triple consisting of the objects O ⊆ K, the initial logical state and the 
logical goal speciﬁcation.

The ground atoms of the planning instance, Atms, are the (ﬁnitely many) atomic formulas formed by applying the relations 
in R to the objects in O (respecting arities). A logical state is any subset of Atms. Considering a logical state  s, we denote 
with  sc its  complement:  sc = Atms \ s.  S = 2Atms denotes  the  set  of  logical  states.  The  initial  logical  state  can  be  chosen 
arbitrarily:  Init ∈ S. A logical goal speciﬁcation is any choice of a desired set of ﬁnal logical states: G ⊆ S. It is typical to 
restrict to considering goals only of the form G = {S | C ⊆ S ∈ S} for some conjunction of atoms C ⊆ Atms.

A state is a tuple in R × S, where the ﬁrst value is the time of the state and the second value (logical state) is a subset 
of Atms. The initial state for the planning instance I is, implicitly, of the form (t0, Init) where t0, the beginning of the plan 
execution time, will always take the value t0 = 0 in this paper, which is also the convention used in the IPC benchmarks.1
The set Ai is a collection of instantaneous action schemas. An instantaneous action schema α is composed of the follow-

ing sets:

• V α ⊆ V , the distinct schema’s variables;
+
• Pre
α , the positive preconditions;
−
• Pre
α , the negative preconditions;
+
• Eff
α , the add effects;
−
• Eff
α , the delete effects.

If the schema α is clear in context we drop the subscript. For convenience, we also deﬁne:

+
• Preα = Pre
α
+
• Effα = Eff
α

−
∪ Pre
α ;
−
∪ Eff
α

Preconditions and effects are sets of formulas l of the form: (∀v 1, . . . , vk : q) where:

• q is an atomic formula: q = r(v
• {v 1, . . . , vk} ⊆ {v
(cid:7)
• {v
1, . . . , v

(cid:7)
1, . . . , v

} ⊆ V are the quantiﬁed variables in l;
} \ {v 1, . . . , vk} ⊆ V α are the schema’s variables in l.

(cid:7)
n) with r ∈ R and arity(r) = n ≥ k;

(cid:7)
1, . . . , v

(cid:7)
n

(cid:7)
n

The universal quantiﬁcation can be trivial (i.e. quantiﬁcation over zero variables) and, in this case, it is omitted. Note that 
we do not allow repeated arguments in the speciﬁcation of a schema and all the formulas that appear in the preconditions 
and effects are positive. The representation is untyped.

Given  a  formula  l of  the  form  (∀v 1, . . . , vk : q),  we  indicate  the  sets  of  the  positions  of  its  free  and  quantiﬁed 
variables  (starting  with  zero  and  in  the  order  they  appear  in  q)  respectively  as  VarF[l] and  VarQ[l].  For  example,  if 
l = (∀x, z : f (x, y, z, k)),  we  have:  VarQ[l] = {0, 2} and  VarF[l] = {1, 3}.  Let  Rel[l] = (cid:9)r/k(cid:10) denote  the  relation  symbol  r of 
arity k that appears in the atomic formula q. In our example, Rel[l] = f /4. Considering a position i ∈ VarF[l] , we indicate 
the corresponding variable as Var[i, l]. For instance, Var[2, l] = z.

The set Ad is a collection of durative action schemas. A durative action schema  Dα is a triple of instantaneous action 
schemas  Dα = (αst, αinv, αend) with a common set of variables  V Dα (i.e.  V Dα = V αst = V αinv = V αend ) and with αinv having 
no effects (i.e. Effαinv = ∅). We indicate as {Dα} the set {αst, αinv, αend}.

We call A the set of all the instantaneous action schemas in the domain, including those induced by durative actions: 
{Dα}. Consider any two action schemas α1 and α2 in A such that there does not exist a durative action Dα

A = Ai ∪

(cid:2)

Dα∈Ad

with both α1 and α2 in {Dα}. We assume that the variables of α1 and α2 are disjoint sets,2 i.e. V α1

∩ V α2

= ∅.

1 We write t0 to emphasise that the choice of a starting time is theoretically unimportant.
2 Our implementation forces this assumption true by performing a preprocessing step that appropriately renames all variables of unrelated action schemas 
apart.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

5

Given an action schema α ∈ Ai with variables  V α , consider a grounding function  gr : V α → O that maps the schema’s 
variables in α to the problem’s objects O. The function gr induces a function on the formulas in α as follows. Take a formula 
l that appears in α. We call  (cid:3)gr(l) the formula that is obtained from l by substituting the schema’s variables in l with objects 
in  O according  to  gr.  We  call  gr(l) the  set  of  ground  atoms  obtained  from  (cid:3)gr(l) by  substituting  each  quantiﬁed  variable 
in l with objects in O in all possible ways. Note that, when there are no quantiﬁed variables, { (cid:3)gr(l)} = gr(l) and they are 
singletons. For a set L containing formulas l1, . . . , ln, we call  (cid:3)gr(L) = { (cid:3)gr(l1), . . . , (cid:3)gr(ln)} and  gr(L) = gr(l1) ∪ . . . ∪ gr(ln). We 
call  (cid:3)gr(α) the action schema obtained from α by grounding each formula l that appears in α according to  gr and  gr(α)
the ground action that is obtained from  (cid:3)gr(α) by replacing the quantiﬁed variables with the set of ground atoms formed 
by substituting objects in O for the quantiﬁed variables in all possible ways.

Considering  a  durative  action  schema  Dα ∈ Ad and  a  grounding  function  gr,  the  ground  durative  action  gr(Dα) is 
obtained  by  applying  gr to  the  instantaneous  fragments  of  Dα,  i.e.  gr(Dα) = (gr(αst), gr(αinv), gr(αend)).  Note  that  we 
cannot apply different grounding functions to different parts of a durative action schema.

±
+
a .  We  also  put  Prea = Pre
a

We indicate the positive and negative preconditions of an instantaneous ground action a as Pre

±
a and its add and delete 
−
= Eff
effects  as  Eff
a .  Ground  actions  obtained  by  grounding  different 
action schema are always assumed to be distinct even in the case they might have the same preconditions and effects. In 
particular, two different durative actions always have distinct start and end fragments. Such fragments are also distinct from 
any other instantaneous action. We call GAi and GAd, respectively, the set of instantaneous and durative ground actions. 
Finally, we call GA the set of all ground actions in I (obtained from grounding all schemas in A).

−
∪ Pre
a and  Effa

∪ Eff

+
a

For the sake of simplicity, from now on we will call a ground action simply an action, while at the lifted level we will 
use the term action schema. Moreover, the term instantaneous will be dropped, whenever this does not cause any ambiguity, 
assuming that actions and action schemas without the appellative durative are always instantaneous.

+
An action a is applicable in a logical state s if Pre
a
is applicable. The result of applying a in s is the state s
(cid:7) = ξ(s, a).
s

−
⊆ s and Pre
a
(cid:7)
such that s

∩ s = ∅. We denote by  Sa the set of states on which a
+
(cid:7) = (s \ Eff
a . We call ξ this transition function: 

−
a ) ∪ Eff

The  transition  function  ξ can  be  generalised  to  a  ﬁnite  set  of  actions  A to  be  executed  simultaneously:  s

(cid:7) = ξ(s, A). 
However, in order to handle simultaneous actions, we need to introduce the so-called no moving targets rule: no two actions 
can simultaneously make use of a value if one of the two is accessing the value to update it. The value is a moving target
for  the  other  action  to  access.  This  rule  avoids  conﬂicting  effects,  but  also  applies  to  the  preconditions  of  an  action:  no 
concurrent actions can affect the parts of the state relevant to the precondition tests of other actions in the set (regardless 
of whether those effects might be harmful or not). In formula, two actions a and b are non-interfering if:

= Preb ∩ Effa
Prea ∩ Effb
+
−
+
∩ Eff
= Eff
∩ Eff
Eff
a
b
b

= ∅

−
a

= ∅

If two actions are not non-interfering, they are mutex.

In this work, whenever we consider a set of simultaneous actions  A, we implicitly assume that the component actions 

are pairwise non-interfering. Moreover, we deﬁne

Pre

=

±
A

(cid:4)

a∈ A

Pre

±
a ,

Eff

=

±
A

(cid:4)

a∈ A

Eff

±
a

(1)

We say that  A is applicable in a state s if each component a ∈ A is applicable in s. The set of states on which  A is applicable 
is thus S A = {s | P re

⊆ sc}. Given s ∈ S A , the transition function s

(cid:7) = ξ(s, A) is deﬁned as follows:

⊆ s, P re

+
A

−
A

s

(cid:7) = (s \ Eff

+
A
We say that  A is executable if S A (cid:14)= ∅ or, equivalently, if

−
A ) ∪ Eff

Pre

+
A

−
∩ Pre
A

= ∅

(2)

Sets of actions that are not executable do not play any role in our analysis as they will never appear in executable plans 
(see below for the exact deﬁnition). For this reason, in our analysis, we always restrict consideration to executable sets of 
+
actions. This implies, in particular, that each single action a that we consider satisﬁes the condition Pre
a

−
∩ Pre
a

= ∅.

The following result shows that the application of a set of actions can always be serialised.

Proposition 1 (Serialisability). Consider a set of pairwise non-interfering actions A and a logical state s ∈ S A . Let σ : {1, . . . , n} → A
be any permutation of A and consider the sequence of states recursively deﬁned as s0 = s and sk = ξ(sk−1, σ (k)) for k = 1, . . . , n. 
Then,

+
(i) Each σ (k) is applicable in sk−1 (so each sk is well-deﬁned): Pre
σ (k)
(ii) The ﬁnal logical state coincides with the state that is obtained by applying the set A, namely sn = ξ(s0, A).

−
⊆ sk−1 and Pre
σ (k)

∩ sk−1 = ∅.

6

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Proof. The  action  σ (1) is  applicable  in  s0 by  deﬁnition.  Assuming  that  σ ( j) is  applicable  in  s j−1 for  j = 1, . . . , k,  we 
now  show  that σ (k + 1) is  applicable  in  sk.  Note  that  from  the  deﬁnition  of  transition  function  ξ for  single  actions  sk =
∩ s0 = ∅ by assumption and σ (k + 1) is not interfering with 
(s0 \

⊆ s0 and Pre

+
+
σ ( j). Since Pre
σ (k+1)

−
σ ( j)) ∪

−
σ (k+1)

Eff

Eff

k(cid:2)

k(cid:2)

j=1

j=1

σ (1), σ (2), . . . , σ (k), we have that Pre

+
σ (k+1)

⊆ sk and Pre

−
σ (k+1)

∩ sk = ∅. Also, note that: sn = (s0 \

ξ(s, A). (cid:2)

n(cid:2)

j=1

Eff

−
σ ( j)) ∪

n(cid:2)

j=1

Eff

+
σ ( j)

=

An instantaneous timed action has the following syntactic form: (t, a), where t is a positive rational number in ﬂoating 
(cid:7)]), where t is a rational 
is a non-negative rational-valued duration. It is possible for multiple timed 

point syntax and a is an action.  A durative timed action has the following syntactic form:  (t, Da[t
valued time point, Da is a durative action and t
actions to be given the same time stamp, indicating that they should be executed concurrently.

(cid:7)

Given a planning instance I, a plan (cid:5) consists of a ﬁnite set of (instantaneous and durative) timed actions. The happening 

time sequence {ti}

(cid:7)]) ∈ (cid:5)}.
The simple plan π induced by a plan (cid:5) is the set of instantaneous timed actions such that:

i=0,...,¯k for a plan (cid:5) is: {t | (t, a) ∈ (cid:5) or (t, Da[t

(cid:7)]) ∈ (cid:5) or (t − t

(cid:7), Da[t

(i) (t, a) ∈ π for each (t, a) ∈ (cid:5), where a is an action;
(ii) (t, ast) ∈ π and (t + t
(iii) ((ti + ti+1)/2, ainv) ∈ π for each (t, Da[t

(cid:7), aend) ∈ π for all (t, Da[t

(cid:7)]) ∈ (cid:5), where  Da is a durative action;

(cid:7)]) ∈ (cid:5) and for each  i such that t ≤ ti < (t + t

(cid:7)), where ti and ti+1 are in the 

happening time sequence for (cid:5).

For  each  durative  action  (t, Da[t

(cid:7)]) in  (cid:5),  the  simple  plan  π contains  the  instantaneous  timed  actions  (t, ast) and 
(cid:7), aend) as well as, midway between them, the instantaneous timed action ((ti + ti+1)/2, ainv). A plan (cid:5) and its corre-
(t + t
sponding induced simple plan π is admissible if concurrent instantaneous actions are non-interfering between each other 
and actions happening inside a durative action  Da = (ast, ainv, aend) are non-interfering with the action ainv. More precisely, 
if

• (t, a), (t, b) ∈ π imply that a and b are non-interfering.
(cid:7)]) ∈ (cid:5) and (s, b) ∈ π for some time s ∈ (t, t + t
• (t, Da[t

(cid:7)) imply that ainv and b are non-interfering.

The  happening time sequence {ti}

i=0,...,¯k for  a  plan π is:  {t0} ∪ {t | (t, a) ∈ π }.  The  happening at  time t of  the  plan π is 
deﬁned  as  At = {a ∈ GA | (t, a) ∈ π }.  Clearly,  At (cid:14)= ∅ iff t is  in  the  happening  time  sequence.  The  sequence  of  action  sets 
Aπ = ( At0 , . . . , At ¯k

) is called the happening sequence of π .

An  admissible  simple  plan  π for  a  planning  instance  I is  executable if,  given  its  happening  time  sequence  {ti}

i=0...¯k, 
there  is  a  sequence  of  logical  states  {si}
i=0...¯k such  that  s0 = Init and  for  each  i = 0, . . . , k,  si+1 is  the  result  of  executing 
the happening at time ti in π . Formally, we have that  Ati+1 is applicable in si and si+1 = ξ(si, Ati+1 ). The state s¯k is called 
the ﬁnal logical state produced by π . The sequence of times and states {S i = (ti, si)i=0...k} is called the (unique) trace of π , 
trace(π ).  Two  simple  plans  are  said  to  be  equivalent if  they  give  rise  to  the  same  trace.  We  call  Plans all  the  executable 
simple plans for I and we call Sr the union of all the logical states that appear in the traces associated with the plans in 
Plans: Sr = {s | π ∈ Plans, (t, s) ∈ trace(π )}. Note that Sr ⊆ S. We call the states in Sr reachable states. Finally, an executable 
simple plan for a planning instance I is valid if it produces a ﬁnal state s¯k

Note  that  in  the  passage  from  the  original  plan  (cid:5) to  the  simple  plan  π we  have  formally  lost  the  coupling  among 
the start and end fragments of durative actions. Since in certain cases this information is necessary, we set a deﬁnition: a 
(cid:7)] whenever this holds true in the original plan (cid:5), 
durative action  Da is said to happen in π in the time interval [t, t + t
(cid:7)]) ∈ (cid:5). It will also be convenient to make the following assumption. Whenever two durative timed 
namely when (t, Da[t
(cid:7)
(cid:7)
actions  (t1, Da1[t
2,  in  a 
1
(cid:7)
2, the constituent durative actions are different:  Da1 (cid:14)= Da2. This entails no loss 
plan (cid:5), but have different durations t
of generality. In fact, if  Da1 and  Da2 are different, this is obvious. If not, we can always create multiple copies of the same 
durative action with different labels: they have the same preconditions and effects in each fragment but have a different 
name. Durative actions of this type are called equivalent. Note, ﬁnally, that if two equivalent durative actions  Da1 and  Da2
(cid:7)]) ∈ (cid:5), we can get rid of one of them and 
appear in a plan with the same starting point and duration, (t, Da1[t
obtain  an  equivalent  simple  plan.  For  this  reason,  we  assume  from  now  on  that  the  plans  considered  are  free  from  such 
simultaneous happening of equivalent durative actions.

]) either  start  at  the  same  point  t1 = t2 or  end  at  the  same  point  t1 + t

(cid:7)]), (t, Da2[t

]) (t2, Da2[t

= t2 + t

∈ G.

(cid:14)= t

(cid:7)(cid:7)
2

(cid:7)
1

(cid:7)
1

All concepts and results presented in this paper will not take into consideration the goal G. They will be concerned with 
the  family  Plans of  all  executable  plans  and  not  just  the  valid  ones.  Moreover,  it  will  be  convenient  to  think  of  Init as  a 
parameter taking all possible values in S, as our results will be universally quantiﬁed with respect to it. Whenever in this 
paper we ﬁx an instance I, we think of a family of instances parameterised by all possible Init and G.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

7

2.2.  From PDDL2.1 to canonical PDDL

We build the canonical form described above starting from PDDL2.1 instances, which are characterised by numeric and 
temporal  information  [21].  We  do  not  consider  numeric  expressions  in  our  canonical  form.  We  could  potentially  exploit 
metric information to ﬁnd additional invariants, but currently we do not do that. Instead, we ignore the numeric expres-
sions  in  the  domain  and  focus  only  on  its  logical  and  temporal  structure.  Setting  numeric  expressions  aside  has  several 
consequences:  we  eliminate  numeric  constraints  from  the  actions’  speciﬁcation,  the  actions’  preconditions  and  effects  do 
not  depend  on  the  duration  and  actions’  durations  become  the  interval  (0, +∞) in  the  rational  numbers.  Note  that,  cru-
cially,  the  invariants  that  we  ﬁnd  for  the  domain  without  numeric  constraints  are  also  invariants  for  the  original  domain 
since, in removing them, we are only expanding the set of possible valid plans.

Temporal information is handled in PDDL2.1 by means of durative actions. They can be either discretised or continuous, 
but  we  focus  on  discretised  durative  actions  here.  They  have  a  duration  ﬁeld  and  temporally  annotated  conditions  and 
effects.

The duration ﬁeld contains temporal constraints involving terms composed of arithmetic expressions and the dedicated 
variable duration.  As  already  mentioned  above,  we  ignore  numeric  constraints  and  consequently  the  speciﬁc  durations  of 
the actions, which we substitute with the interval (0, +∞). Such precise durations are irrelevant to our technique. We care 
about the possible intertwinement between durative actions, which can be studied without considering the exact durations.
The annotation of a condition makes explicit whether the associated proposition must hold at the start of the interval 
(the point at which the action is applied), the end of the interval (the point at which the ﬁnal effects are asserted) or over all
the interval (open at both ends) from the start to the end (invariant over the duration of the action). The annotation of an 
effect makes explicit whether the effect is immediate (it happens at the start of the interval) or delayed (it happens at the 
end of the interval). No other time points are accessible. Logical changes are considered to be instantaneous and can only 
happen  at  the  accessible  points.  To  build  our  canonical  form,  we  transform  durative  actions  into  triples  of  instantaneous 
actions. We do this in such a way that we do not change the set of plans that can be obtained for any goal speciﬁcation. 
Plans  with  durative  actions,  in  fact,  are  always  assigned  a  semantics  in  terms  of  the  semantics  of  simple  plans  [21],  as 
explained in the previous section.

Let  us  see  now  in  more  detail  how  we  obtain  the  PDDL  canonical  form  from  PDDL2.1  instances.  PDDL2.1  is  a  typed 
representation. We compile away types: for each type that occurs in the domain, we introduce a new unary relation with 
the same name. For example, the Floortile domain contains the type robot, tile and color and so we introduce three 
new unary relations: (cid:9)robot, 1(cid:10), (cid:9)tile, 1(cid:10), and (cid:9)color, 1(cid:10). We use such relations in the speciﬁcation of the initial state, 
where  we  list  the  objects  of  the  planning  instance,  and  in  the  speciﬁcation  of  the  actions.  For  each  typed  variable  that 
appears  in  an  action,  we  specify  it  without  giving  its  type,  but  then  we  introduce  a  new  precondition  in  the  action  that 
associates the variable to its corresponding unary relation. We follow the same procedure described in Helmert [33], which 
can be consulted for further details.

In  a  PDDL2.1  domain,  instead  of  Ai and  Ad,  we  ﬁnd  a  set  Aa that  contains  both  instantaneous  and  durative  action 
schemas, which have the following characteristics. Durative action schemas have temporally annotated conditions and ef-
fects,  which  we  indicate  as  Prepx and  Effpy ,  where  p ∈ {+, −},  x ∈ {st, inv, end},  and  y ∈ {st, end}.  For  an  action  schema 
in Aa (durative or not), the condition formula can be a relation, a negation, a conjunction or disjunction of relations or a 
quantiﬁed formula on relations. The effect formula can be a relation, a negation or a conjunction of relations, a universally 
quantiﬁed formula on relations or a conditional effect formula, which is a tuple formed by a precondition formula and effect 
formula. We manipulate the action schemas in Aa to obtain Ai and Ad, where each action schema in these sets has the 
canonical form described in Section 2.1.

First, we eliminate conditional effects and existentially quantiﬁed formulae through an operation referred to as ﬂattening
(see Fox and Long [21] for details). These features can be eliminated by applying syntactic transformations with the resulting 
schemas being equivalent to the original ones. This procedure can potentially lead to an exponential blow-up of the task 
description.

Given  a  ﬂattened  action  schema  α,  we  take  the  formulas  (temporally  annotated  or  not)  in  its  conditions  and  effects 
and  normalise them  by  using  the  algorithm  introduced  by  Helmert  [33].  (We  refer  the  interested  reader  to  this  paper 
for  a  full  description  of  the  normalisation  process.)  Our  normalisation  differs  from  Helmert  [33] only  in  that  we  initially 
eliminate conditional effects by applying the ﬂattening operation before normalisation and we keep universal quantiﬁcation 
in  the  preconditions. We  also  apply  normalisation  not  only  to  formulas  appearing  in  instantaneous  actions  as  in  Helmert 
[33],  but  also  to  temporally  annotated  formulas  in  durative  actions.  We  normalise  the  formulas  and  leave  the  temporal 
annotation unchanged. After normalisation, all action schema conditions and effects become sets of formulas l of the form 
+
∀v 1, . . . , vk : q,  where  q is  an  atomic  formula  and  the  quantiﬁcation  can  be  trivial.  We  indicate  by  Pre
α the  set 
−
α the  set  of  positive  formulas  that  appear  negative 
of  positive  formulas  that  appear  positive  in  α and  by  Pre
in α.

−
α and  Eff

+
α and  Eff

After ﬂattening and normalisation, we transform the durative action schemas in Aa into triples of instantaneous action 
schemas. For each durative action  Dα ∈ Aa, we create two instantaneous action schemas that correspond to the end points 
of  Dα, αst and αend, and one that corresponds to the invariant conditions that must hold over that duration of  Dα, αinv. 
More formally, for a durative action schema  Dα, we create αst, αinv and αend as indicated in Table 2.

8

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Table 2
Transformation of durative action schemas into triples of instantaneous action schemas.

αst

Pre

Pre

Eff

Eff

+
αst
−
αst
+
αst
−
αst

= Pre

= Pre

= Eff

= Eff

+st
Dα
−st
Dα
+st
Dα
−st
Dα

Pre

Pre

αinv
+
αinv
−
αinv
+
αinv
−
αinv

Eff

Eff

= Pre

= Pre

+inv
Dα
−inv
Dα

= ∅

= ∅

Pre

Pre

αend
+
αend
−
αend
+
αend
−
αend

Eff

Eff

= Pre

= Pre

= Eff

= Eff

+end
Dα
−end
Dα
+end
Dα
−end
Dα

Table 3
Durative action schema paintUp seen as a triple of instantaneous action schemas.

α

V α

Pre

+
α

Pre

Eff

Eff

−
α
+
α
−
α

paintUpst
{r, y, x, c}
{robotAt(r, x), clear(y),
robot(r), tile(y),
tile(x), color(c)}
∅

∅

{clear(y)}

paintUpinv
{r, y, x, c}
{robotHas(r, c), up(y, x)
robot(r), tile(y),
tile(x), color(c)}
∅

∅

∅

paintUpend
{r, y, x, c}
{robot(r), tile(y),
tile(x), color(c)}

∅

{painted(y, c)}
∅

At this point, we are ready to construct Ai and Ad from Aa. We add each ﬂattened and normalised instantaneous action 
in  Aa to  Ai .  For  each  durative  action  Dα ∈ Aa,  after  applying  ﬂattening  and  normalisation,  we  create  the  corresponding 
tuple (αst, αinv, αend) and add it to Ad.

Consider a planning instance I in canonical form obtained from a PDDL2.1 instance I(cid:7)

and a valid plan (cid:5) for I. (cid:5) can 

be converted into an equivalent valid plan (cid:5)(cid:7)

for I(cid:7)

.

2.3.  Running example: the Floortiledomain

We use the Floortile domain as our running example. It has been introduced in the IPC’14 and then reused in 2015. The 
full PDDL2.1 speciﬁcation is available in Appendix A. The domain describes a set of robots that use different colours to paint 
patterns in ﬂoor tiles. The robots can move around the ﬂoor tiles in four directions (up, down, left and right). Robots paint 
with one color at a time, but can change their spray guns to any available color. Robots can only paint the tile that is in 
above (up) and below (down) them, and once a tile has been painted no robot can stand on it.

We  have  the  following  relations  in  this  domain:  R = {up, down, right, left, robotAt, robotHas, painted,
clear, availableColor}.  They  have  arity  two,  except  for  the  last  two,  which  have  arity  one. availableColor in-
dicates  whether  a  colour  gun  is  available  to  be  picked  by  a  robot  and  up,  down,  right,  left indicate  the  respective 
positions of two tiles. As we will automatically infer via our invariant synthesis (see Example 1), the relation clear in this 
context means not only that a tile is still unpainted, but also that it is not being painted and is unoccupied.

The  set  of  instantaneous  action  schemas  Ai

is  empty,  while  the  set  of  durative  action  schemas  Ad is:  Ad =

{changeColor, paintUp, paintDown, up, down, right, left}.

As  an  example,  the  durative  action  schema paintUp corresponds  to  the  following  triple:  (paintUpst,  paintUpinv, 

paintUpend), where the single instantaneous action schemas have the speciﬁcations as shown in Table 3.

Note  that  the  triple  of  single  instantaneous  action  schemas  in  canonical  form  is  obtained  from  the  following  PDDL2.1 

speciﬁcation:

( : durative− action paintUp

: parameters (? r − robot ?y − t i l e ?x − t i l e ?c − c o l o r )
: duration (= ? duration 2)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t
( over a l l
( a t s t a r t

( robot−has ? r ?c ) )
( robotAt ? r ?x ) )
( up ?y ?x ) )
( c l e a r ?y ) ) )
( not ( c l e a r ?y ) ) )

: e f f e c t

( and ( a t s t a r t

( a t end ( painted ?y ?c ) ) ) )

3.  Mutual exclusion invariants and templates

In this section, we formally introduce the concept of mutual exclusion invariant and give examples of them.
In the PDDL2.1 language, an invariant of a planning instance is a property of the world states such that when it is satisﬁed 
in the initial state Init, it is satisﬁed in all reachable states Sr. For example, for the Floortile domain, a trivial invariant says 

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

9

that for each object x, if x is a robot, then x is not a tile. Similar invariants hold for each type deﬁned in the original PDDL 
domain. A more interesting invariant says that, for any two objects x and  y, if up(x,y) holds, then down(y,x) holds too, 
but down(x,y) does not. It is possible to identify several invariants for the Floortile domain, ranging from trivial invariants 
such as those involving type predicates to very complex invariants.

In this paper, we focus on mutual exclusion invariants, which state that a set of ground atoms can never be true at the 

same time. From now on we assume we have ﬁxed a planning instance I in PDDL canonical form.

Deﬁnition 2 (Mutual exclusion invariant). A set of ground atoms  Z ∈ S is a mutual exclusion invariant set when, if at most one 
element of  Z is true in the initial state, then at most one element of  Z is true in any reachable state, namely

| Z ∩ Init| ≤ 1 ⇒ | Z ∩ s| ≤ 1, ∀s ∈ Sr

We abuse the distinction between the set  Z and a formula such as 
directly and, for brevity, an invariant.

(cid:5)

x, y∈ Z

¬x ∨ ¬ y and call  Z a mutual exclusion invariant

Example 1  (Floortile domain).  A  mutual  exclusion  invariant  for  this  domain  states  that  two  ground  atoms  indicating  the 
position  of  a  robot  identiﬁed  as  rbt1,  such  as robotAt(rbt1,tile1) and  robotAt(rbt1,tile2),  can  never  be 
true at the same time. Intuitively, this means that rbt1 cannot be in two different positions simultaneously. Another more 
complex invariant states that, given a tile tile1, a robot rbt1 and a colour clr1, atoms of the form clear(tile1), 
robotAt(rbt1, tile1) and painted(tile1,clr1) can never be true at the same time. This means that a tile can 
be in one of four possible states: not yet painted (clear), already painted, occupied by a robot that is painting an adjacent 
tile or none of the preceding (which can only be because the tile is being painted).

Although  we  aim  to  ﬁnd  sets  of  mutually  exclusive  ground  atoms,  we  often  work  with  relations  and  action  schemas 
to control complexity. A convenient and compact way for indicating several invariant sets at the same time involves using 
invariant templates, which are deﬁned below, after introducing a few preliminary deﬁnitions.

Deﬁnition 3  (Component).  A  component c is  a  tuple  (cid:9)r/k, p(cid:10),  where  r is  a  relation  symbol  in  R of  arity  k = arit y(r) and 
p ∈ {0, . . . , k}.

Take a component c = (cid:9)r/k, p(cid:10) and a set of variables  v 0, . . . , vk−1 and consider the atomic formula m = r(v 0, . . . , vk−1). 
When p ≤ k − 1, the number p in c represents the position of one of the variables of m, which we call the counted variable. 
When  p = k,  there  are  no  counted  variables.  The  set  of  the  ﬁxed variables  of  c is  formally  deﬁned  as  F c = {(c, i) | i =
0, . . . , k − 1; i (cid:14)= p}. We deﬁne the set of ﬁxed variables of a set of components C = {c1, c2, . . . , cn} as  FC =

F c .

(cid:2)

c∈C

Deﬁnition 4 (Admissible partition). Given a set of components C and corresponding set of ﬁxed variables  FC , an admissible 
partition of  FC is a partition FC = {G 1, . . . , G s} such that |G j ∩ F c| = 1 for each c ∈ C.

If  two  elements  (c1, i) and  (c2, j) of  FC belong  to  the  same  set  of  the  partition  FC ,  we  use  the  notation:  (c1, i) ∼FC

(c2, j).

Remark 5.  Note  that  the  existence  of  an  admissible  partition  of  FC implies  that  all  the  components  in  C have  the  same 
number of ﬁxed variables, which is also the number of the sets in the partition. In the special case in which the number of 
ﬁxed variables in each component is equal to one, there is just one admissible (trivial) partition FC = {FC}.

Deﬁnition 6 (Template). A template T is a pair (C, FC) such that C is a set of components and FC is an admissible partition 
of  FC . We simply write T = (C) when the partition is trivial, i.e. FC = {FC}.

Deﬁnition 7  (Template instance).  Given  objects  O and  template  T = (C, FC),  an  instance γ : FC → O of  T maps  (all  the 
elements of) each part of its partition to the same object, that is γ (ca, i) = γ (cb, j) if and only if (ca, i) ∼FC (cb, j) for all 
(ca, i), (cb, j) ∈ C.

Deﬁnition 8  (Template instantiation).  The  instantiation of  T according  to  instance  γ ,  γ (T ),  is  the  set  of  ground  atoms  in 
2Atms obtained  as  follows:  for  each  component  c = (cid:9)r/k, p(cid:10) of  T ,  take  the  relation  symbol  r,  for  each  element  (c, i) ∈ F c
bind the variable in position i according to γ (c, i) and the counted variable in position  p to all the objects O. In formula,

γ (T ) =

(cid:4)

(cid:6)
r(x0, . . . , xk−1) | xp ∈ O, xi = γ (c, i) ∀i (cid:14)= p

(cid:7)

c=(cid:9)r/k,p(cid:10)∈T

(3)

10

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Instances are interesting because they can be used to reason about their (exponentially larger) instantiations without, in 

fact, constructing those instantiations.

Considering a template T and an instance γ , if the ground atoms in the instantiation of T according to γ are mutually 
exclusive in the initial state Init and remain so in any reachable state s ∈ Sr, then γ (T ) is (by deﬁnition) a mutual exclusion 
invariant set. A template with this property for each possible instantiation γ is called an invariant template.

Deﬁnition 9 (Invariant template). A template T is an invariant template if, for each instance γ , the instantiation of T accord-
ing to γ is a mutual exclusion invariant set.

Given an invariant template T , we can create one state variable for each of its instances. The domains of these variables 
are the corresponding mutual exclusion invariant sets with an additional null value, which is used when no element in the 
mutual exclusion invariant set is true.

Before describing in what situations we can feasibly prove that a template is invariant, we introduce a ﬁnal concept:

Deﬁnition 10 (Template instance’s weight). Take an instance γ of template T with instantiation γ (T ). The weight w(γ , s) of 
γ in state s is the number of ground atoms of its instantiation true in s:

w(γ , s) =

(cid:8)
(cid:8)γ (T ) ∩ s

(cid:8)
(cid:8) .

Proposition 11. A template T is invariant if and only if, for each instance γ of T with instantiation γ (T ), if w(γ , Init) ≤ 1, then 
w(γ , s) ≤ 1 for each state s ∈ Sr.

Proof. It follows from Deﬁnitions 9 and 10. (cid:2)

Example 2 (Floortiledomain). A template for this domain is T f t = ({c1, c2, c3}), where:

• c1 = (cid:9)robotAt/2, 0(cid:10) is the ﬁrst component. It includes the relation robotAt that has an arity of two (i.e. the relation 
robotAt(robot, tile) has two variables) and the variable in position zero, i.e. robot, is the counted variable. The 
remaining variable, tile, which is in position one, is the ﬁxed variable:  F c1

= {(c1, 1)}.

• c2 = (cid:9)painted/2, 1(cid:10) is the second component with  F c2
• c3 = (cid:9)clear/1, 1(cid:10) is the last component with  F c3

= {(c3, 0)}.

= {(c2, 0)}.

For  this  example,  because  each  component  has  only  one  ﬁxed  argument,  there  is  only  one  admissible  partition  –  the 

trivial one – that places all components together:

FC = {{(c1, 1), (c2, 0), (c3, 0)}}

Assume that we have a problem P with two robots rbt1 and rbt2, three tiles, tile1, tile2 and tile3 and one 
colour  black.  Consider  one  possible  instance  γ1 such  that  γ1(c1, 1) = γ1(c2, 0) = γ1(c3, 0) = tile1.  The  instantiation 
of  the  template  T f t according  to  γ1 is:  γ1(T f t) = {clear(tile1), robotAt(rbt1, tile1), robotAt(rbt2,tile1),
painted(tile1,black)}.  The  weight  of  the  instance  γ1 in  some  state  s is  how  many  of  the  atoms  in  γ1(T f t ) are 
true  in  s.  For  example,  w(γ1, s0) = 1 for  the  plausible  initial  state  s0 = {clear(tile1), robotAt(rbt1,tile2),
robotAt(rbt2,tile3)},  because  the  intersection  of  the  state  s0 and  the  instantiation  γ1(T f t) contains  just
clear(tile1).

We  will  see  that  we  can  actually  prove  that  T f t is  an  invariant,  which  states  that  any  given  tile  (e.g.,  tile1  for  the 
instance/instantiation  γ1)  satisﬁes  at  most  one  of:  (1)  clear,  (2)  painted  a  colour,  or  (3)  occupied  by  a  robot.  Hence,  for 
the  problem  P ,  we  can  create  three  state  variables  that  represent  each  of  the  three  tiles.  The  domains  of  these  vari-
ables  are  the  three  possible  conﬁgurations  of  the  tiles  and  the  null  value.  As  it  happens,  there  is  only  one  situation 
in  which  none  of  the  above-mentioned  three  values  can  be  true,  and  that  is  when  some  robot  in  some  adjacent  tile 
is  painting  the  tile  in  question.  The  special  null  value  of  the  state  variable  has  that  meaning.  For  example,  SVtile1 =
{robotAt(rbt1,tile1), robotAt(rbt2,tile1), painted(tile1,black), clear(tile1), null}
and  simi-
larly for SVtile2 and SVtile3.

4.  Safe instantaneous ground actions

In  this  and  in  the  following  sections,  we  ﬁx  a  planning  instance  I = (D, P) recalling  that  we  consider  a  family  of 
planning instances parameterised by the initial state Init and G. We then consider a template T and discuss the conditions 
for T to be invariant. More precisely, we determine a few suﬃcient conditions on the families of instantaneous and durative 
actions in D that ensure that if, for some instance γ ,  w(γ , Init) ≤ 1, then  w(γ , s) ≤ 1 for all other reachable states s ∈ Sr.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

11

4.1.  Strong safety

We assume a template T to be ﬁxed as well as an instance γ . In the following,  A ⊆ GA always denotes a set of pairwise 

non-interfering actions and is assumed to be executable.

Deﬁnition 12 (Strongly safe actions). The set of actions A is strongly γ -safe if, for each s ∈ S A where w(γ , s) ≤ 1, the successor 
state s

(cid:7) = ξ(s, A) also satisﬁes  w(γ , s

(cid:7)) ≤ 1.

The following result shows that strong γ -safety can always be checked at the level of single actions.

Proposition 13. Let A be a set of actions. Then, A is strongly γ -safe if a is strongly γ -safe for all a ∈ A.

Proof. Write  A = {a1, . . . , an} and  let  s ∈ S A .  Note  that  from  Proposition 1,  the  actions  in  A can  be  serialised  and  the 
(cid:7) = sn. By assumption, it 
successor state s
follows that  w(γ , si) ≤ 1 for every i. In particular,  w(γ , s

(cid:7) = ξ(s, A) can be recursively obtained as s0 = s, sk = ξ(sk−1, ak), k = 2, . . . , n and s

(cid:7)) ≤ 1. (cid:2)

The converse of the above result does not hold. A counterexample will be shown later (see Example 3).
In order to tease apart the property of strong γ -safety, we will need several more formal deﬁnitions, which we will give 
here and in the following subsections. Firstly, consider restricting an action to a particular instantiation and its complement.

Deﬁnition 14. Given an action a ∈ GA, aγ and a¬γ are the actions, respectively, speciﬁed by

Pre

Pre

±
aγ
±
a¬γ

±
∩ γ (T ),
= Pre
Eff
a
±
∩ γ (T )c, Eff
= Pre
a

±
aγ
±
a¬γ

±
= Eff
a
= Eff

∩ γ (T )
±
∩ γ (T )c
a

(where  Ac denotes the set complement of  A).

Given an action set  A, we deﬁne the action sets  Aγ = {aγ | a ∈ A} and  A¬γ = {a¬γ | a ∈ A}.
We also split the states in a similar way: take s ∈ S, put sγ = s ∩ γ (T ) and s¬γ = s ∩ γ (T )c .

Remark 15. For a state s and an action set  A, we have that s ∈ S A if and only if sγ ∈ S Aγ and s¬γ ∈ S A¬γ and it holds that:

(cid:7) = ξ(s, A) ⇔

s

(cid:9)

(cid:7)
s
γ
(cid:7)
¬γ

s

= ξ(sγ , Aγ )
= ξ(s¬γ , A¬γ )

This leads to the following simple but useful result.

(4)

Proposition 16. For a set of actions A, the following conditions are equivalent:

(i) A is strongly γ -safe;
(ii) Aγ is strongly γ -safe;
(iii) For every s ∈ S Aγ such that s ⊆ γ (T ) and w(γ , s) ≤ 1, it holds that the successor state s

(cid:7) = ξ(s, Aγ ) is such that w(γ , s

(cid:7)) ≤ 1.

Proof. (ii) ⇒ (iii) is trivial and (iii) ⇒ (i) is an immediate consequence of (4) and of the fact that  w(γ , s) = w(γ , sγ ) and 
w(γ , s

(cid:7)) = w(γ , s

Finally, (i) ⇒ (ii) follows from the following argument. Take any s ∈ S Aγ such that w(γ , s) ≤ 1. Consider s
∗ ∈ S A . If we consider the successor states s

∈ S A¬γ , it follows that s

∗ = sγ ∪ Pre
. 
(cid:7) = ξ(s, Aγ ) and 

+
A¬γ

(cid:7)
γ ).

∗
Since s
γ
(cid:7) ∗ = ξ(s
s

+
= sγ ∈ S Aγ and s
= Pre
A¬γ
∗, Aγ ), it follows from (4) that

∗
¬γ

(cid:7)
γ

s

= ξ(sγ , Aγ ) = ξ(s

∗
γ , Aγ ) = s

(cid:7) ∗
γ

Therefore,

w(γ , s

(cid:7)

) = w(γ , s

(cid:7)
γ ) = w(γ , s

(cid:7) ∗
γ ) = w(γ , s

(cid:7) ∗

) ≤ 1

where the last equality follows from the assumption that  A is strongly γ -safe. (cid:2)

12

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

4.2.  Characterisation of ground actions with respect to strong safety

Based on the structure of the preconditions and effects, we classify actions in four classes and then relate each class to 

the notion of strong safety.

Deﬁnition 17 (Classiﬁcation of ground actions). A set of actions  A is:

| ≥ 2;

+
• γ -unreachable if |Pre
Aγ
+
+
• γ -heavy if |Pre
| ≤ 1 and |Eff
Aγ
Aγ
+
• γ -irrelevant if |Pre
| ≤ 1 and |Eff
Aγ
+
+
| ≤ 1 and |Eff
• γ -relevant if |Pre
Aγ
Aγ

| ≥ 2;
+
| = 0;
Aγ
| = 1.

Each  A ⊆ GA belongs to one and only one of the above four disjoint classes. The following result clariﬁes their relation 

with strong safety.

Proposition 18. Let A be a set of actions. Then,

1. if A is γ -unreachable or γ -irrelevant, A is strongly γ -safe;
2. if A is γ -heavy, A is not strongly γ -safe.

Proof. If  A is γ -unreachable and  A is applicable in the state s, it follows that Pre
shows that the condition  w(γ , s) ≤ 1 is never veriﬁed and thus  A is strongly γ -safe.

+
A

+
⊆ s and thus w(γ , s) ≥ |Pre
Aγ

)| ≥ 2. This 

If  A is  γ -irrelevant  and  A is  applicable  in  the  state  s,  we  have  that  the  successor  state  s

(cid:7) = ξ(s, a) ⊆ s.  This  yields 

w(γ , s

(cid:7)) ≤ w(γ , s). This implies that  A is strongly γ -safe.

Suppose  that  A is  γ -heavy  and  consider  the  state  s = Pre

| ≤ 1. After applying  A in  s, the successor state  s

| ≥ 2 and proves that  A is not strongly γ -safe. (cid:2)

+
w(γ , s) = |Pre
Aγ
|Eff

+
α

+
A .  A is  applicable  in  s (because  of  assumption  (2))  and 
(cid:7)) ≥
(cid:7) ⊇ Eff

(cid:7) = ξ(s, A) is such that  s

This yields  w(γ , s

+
Aγ

The following example shows how the converse of Proposition 13 does not hold.

Example 3. Consider a template T and an instance γ such that γ (T ) = {q, q
as well as q

are actions such that:

(cid:7)}, where a and a

. Let  A = {a, a

(cid:7)(cid:7)(cid:7)

(cid:7)

(cid:7), q

(cid:7)(cid:7)}, where q, q

(cid:7)

, q

(cid:7)(cid:7)

are distinct ground atoms 

+
Pre
a

= {q, q

(cid:7)}, Effa

= ∅, Prea(cid:7) = ∅, Eff

+
a(cid:7) = {q

(cid:7)(cid:7)

(cid:7)(cid:7)(cid:7)}

, q

Then, a is γ -unreachable and thus strongly γ -safe, while a
A is γ -unreachable and thus strongly γ -safe.

(cid:7)

is γ -heavy and not strongly γ -safe. However, the set of actions 

As the next example shows, γ -relevant action sets may be strongly γ -safe or not.

Example 4.  Consider  a  template  T and  an  instance  γ such  that  γ (T ) = {q, q
+
= {q}. Since |Eff
ground atoms, and a is an action such that |Pre
a

| ≤ 1 and Eff

+
a

(cid:7), q
+
a

(cid:7)(cid:7)},  where  q,  q
(cid:7)
∩ γ (T )| = 1, a is γ -relevant.

and  q

(cid:7)(cid:7)

are  three  distinct 

+
• Suppose  that  Pre
a

= {q

is  such  that  w(γ , s) ≤ 1,  q
w(γ , s

(cid:7)) = 1.

• Suppose that Prea = ∅ and Eff

In  fact,  consider  the  starting  state  s = {q
w(γ , s

(cid:7)) = 2.

(cid:7)} and  Eff

(cid:7) ∈ s and  in  consequence  w(γ , s) = 1.  Given  s

(cid:7)} as  shown  in  Fig. 1,  left.  In  this  case,  a is  strongly  γ -safe.  In  fact,  if  s ∈ Sa
and  therefore 

(cid:7) = ξ(s, a),  q

,  but  q ∈ s

(cid:7) /∈ s

= {q

(cid:7)

(cid:7)

−
a

−
a

= {q

(cid:7)} as shown in Fig. 1, right. In this case, a is γ -relevant, but is not strongly γ -safe. 
(cid:7) = ξ(s, a) is  such  that 

(cid:7)(cid:7)} so  that  w(γ , s) = 1.  Since q

(cid:7)(cid:7) /∈ Eff

−
a and q ∈ Eff

+
a ,  s

Proposition 18 classiﬁes all but relevant actions. Let us now consider relevance. We split it in four categories and then 

analyse the strong safety of each case.

Deﬁnition 19 (Classiﬁcation of relevant actions). A γ -relevant set of actions A has at most one relevant precondition (|Pre
1).  A is γ -weighty, at  p, when that is the single relevant precondition: Pre

+
= {p}.  A is γ -weightless if |Pre
Aγ

| = 0.

+
Aγ

+
Aγ

| ≤

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

13

Fig. 1. Relevant actions can be either safe (left) or unsafe (right). See Example 3. (Empty action parts are not shown.)

A γ -weighty at  p action set  A is either:

• γ -balanced if the precondition is an effect:  p ∈ Eff Aγ ; or
• γ -unbalanced if otherwise:  p /∈ Eff Aγ .

A γ -weightless action set  A is either:

• γ -bounded if the entire instantiation is accessed: Pre Aγ
• γ -unbounded if otherwise: Pre Aγ

(cid:14)= γ (T ).

∪ Eff Aγ

∪ Eff Aγ

= γ (T ); or

Every  relevant  set  of  actions  A belongs  to  one  and  only  one  of  the  above  four  disjoint  classes.  The  balanced  and  un-
bounded cases are discussed in Example 4. To understand the bounded case better, recall that a relevant action set has just 
= {l}. When  A is bounded, then the rest of the instantiation γ (T ) \ {l} is accessed 
one relevant positive effect l, as in Eff
+
−
negatively: γ (T ) = Pre Aγ
∪ Eff Aγ , Pre
A . So the weight after 
Aγ
executing a bounded set will be exactly one, regardless of what it was before. In other words, bounded is even safer than 
balanced. Formally:

−
= {l} together imply that γ (T ) \ {l} = Pre
A

+
Aγ
= ∅ and Eff

∪ Eff

+
Aγ

Proposition 20. Let A be a γ -relevant set of actions. Then,

1. if A is γ -balanced or γ -bounded, A is strongly γ -safe;
2. if A is γ -unbalanced or γ -unbounded, A is not strongly γ -safe.

Proof. We will prove the corresponding property for  Aγ making use of Condition (iii) of Proposition 16. We ﬁrst analyse 
= {q2}.  Suppose  now  that  A is  γ -balanced  and  ﬁx  a  state 
the  case  when  A is  γ -weighty.  Let  Pre
s ∈ γ (T ) such  that  w(γ , s) ≤ 1 and  Aγ is  applicable  in  s.  Since  q1 ⊆ s,  necessarily,  s = {q1} and  w(γ , s) = 1.  Consider 
the  subsequent  state  s
,  we  have 
(cid:7)) = 1. Suppose that  A is unbalanced and consider the state  s = {q1}. The 
that  s
subsequent state s

(cid:7) = (s \ {q1}) ∪ {q2} = {q2} and thus  w(γ , s

(cid:7) = ξ(s, Aγ ).  If  q1 = q2,  we  have  that  s

(cid:7)) = 1.  If  instead  q1 ∈ Eff

(cid:7) = s so  that  w(γ , s

= {q1} and  Eff

−
Aγ

+
Aγ

+
Aγ

(cid:7)) = 2.
We now consider the case when  A is γ -weightless, i.e. Pre

(cid:7) = ξ(s, Aγ ) = {q1, q2} so that  w(γ , s

∪ Eff Aγ

= ∅. Let Eff

= {q2}. Suppose that  A is γ -bounded and ﬁx 
(cid:7) = ξ(s, Aγ ) is 
(cid:7)) ≤ w(γ , s) + 1. The only case we need to consider is thus when w(γ , s) = 1. Suppose that s = {q1}. Since, 
(otherwise  Aγ would not 
. In the ﬁrst case, we have that q1 = q2
(cid:7)) = 1. Finally, if  A is γ -unbounded, we consider 
+
= ∅ and 
Aγ
(cid:7) = ξ(s, Aγ ) = {q1, q2}

a state s ∈ γ (T ) such that w(γ , s) ≤ 1 and  Aγ is applicable in s. Since  A is γ -relevant, the subsequent state s
such that w(γ , s
by assumption Pre Aγ
be applicable on the state  s). Therefore, necessarily, either q1 ∈ Eff
and thus s
any ground atom q1 ∈ γ (T ) \ (Pre Aγ
−
q1 /∈ Pre
Aγ
and  w(γ , s

, and  w(γ , s) = 1. Since it also holds that q1 /∈ Eff
(cid:7)) = 2. (cid:2)

∪ Eff Aγ ) and we set s = {q1}. We have that  Aγ is applicable in q1 since Pre

−
∪ Eff Aγ . We have that q1 /∈ Pre
Aγ

= T (γ ), it follows that q1 ∈ Pre Aγ

(cid:7) = s = {q1}. In the second case, s

, we have that the subsequent state  s

(cid:7) = {q2}. In both cases,  w(γ , s

or q1 ∈ Eff

−
Aγ

−
Aγ

+
Aγ

+
Aγ

+
Aγ

Putting the Propositions 18 and 20 together, we get the following result:

Theorem 21. Let A be a set of actions. Then,

1. if A is either γ -unreachable, γ -irrelevant, γ -balanced, or γ -bounded, A is strongly γ -safe;
2. if A is either γ -heavy, γ -unbalanced, or γ -unbounded, A is not strongly γ -safe.

14

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Any  state  in  which  a  γ -heavy  or  γ -unbalanced  action  can  be  executed  will  immediately  have  weight  2  (or  more).  In 
contrast, it is possible for a γ -unbounded action to execute without violating the weight bound, and it is conceivable that 
all reachable states are such that γ -unbounded actions end up being safe. In that sense, Theorem 21 is arguably less of a 
complete classiﬁcation than it may appear.

A possibly interesting way to approach knowledge generated by a stronger prover would be to augment the descriptions 
of actions with derived preconditions, i.e. properties that hold in all reachable states and could be freely added as a precon-
dition on all actions. That could convert γ -unbounded actions into γ -balanced or γ -bounded actions (if negative conditions 
are added).

Example 5 (Floortiledomain). Take the schema α = paintUpend with variables V α = {r, y, x, c} (see Table 3) and grounding 
gr such that  gr(r) = rbt1,  gr(y) = tile1,  gr(x) = tile3,  gr(c) = red. Let c = (cid:9)painted/2, 1(cid:10) be the component that 
counts  the  colour  argument  of painted and  T = ({c}, {{(c, 0)}}) be  the  template  on  just  that  component.  Consider  the 
safety  of a = gr(α) with  respect  to  T .  Let  γ1(c, 0) = tile1 be  the  instance  for  the  tile  the  robot  is  painting,  γ2(c, 0) =
tile2 be  the  instance  for  an  unrelated  tile,  and  γ3(c, 0) = tile3 be  the  instance  for  the  tile  the  robot  is  standing  on. 
Each instantiation is the set of all possible colours per tile.

The action a is γ2-irrelevant (as expected), meaning none of γ2(T ) are preconditions or effects, so also a is (trivially) 

strongly γ2-safe.

While tile3 is relevant to the action as a whole, a does not access painted at tile3 so a is likewise irrelevant and 

thus safe with respect to γ3.

The  action  a is  γ1-relevant,  because  it  adds  painted(tile1,red) ∈ γ1(T ).  It  is  not  strongly  γ1-safe,  be-
cause  if  executed  in  a  state  where  the  tile  was  already  black,  the  tile  would  end  up  being  painted  both  colours: 
ξ({painted(tile1,black), aγ1 ) = {painted(tile1,red), painted(tile1,black)}.  In  particular,  a is  γ1-un-
bounded.  If  we  altered  it  by  adding  negative  preconditions  on  all  the  other  colours,  it  would  become  both  bounded  and 
safe.

If we added clear to the template, then instead a would be balanced (and thus safe) at the instantiation for tile1.

4.3.  Template safety

This concluding section presents a deﬁnition of strong safety with respect to a template, and presents a ﬁrst result that 

expresses a suﬃcient condition for a template to be invariant.

Deﬁnition 22. For a template T , a set of actions  A ⊆ GA is strongly safe if it is strongly γ -safe for every instance γ .

We have the following result:

Corollary 23. For a template T , T is invariant if for each a ∈ GA, a is strongly safe.

Proof. We proceed as follows. We ﬁx any instance γ of T and we show that if  w(γ , Init) ≤ 1, then  w(γ , s) ≤ 1 for every 
s ∈ Sr. This, by Proposition 11, yields the result. By deﬁnition of the set of reachable states Sr, any s ∈ Sr can be obtained 
by  the  initial  state  Init by  recursively  applying  a  sequence  of  action  sets.  Precisely,  there  exists  a  sequence  of  sets  (each 
consisting of pairwise non-interfering actions)  A1, A2, . . . , Ak and a sequence of states {si}i=0...k such that  s0 = Init,  sk = s
and for each i = 0, . . . , k − 1, si+1 = ξ(si, Ai+1). We prove that w(γ , s) ≤ 1 by induction on k. Notice that the case k = 0 boils 
down to s = s0 = Init and w(γ , Init) ≤ 1 is our standing assumption. Assume it to be true for k − 1 and let us prove it for k. 
Notice  that,  we  can  write  s = sk = ξ(sk−1, Ak) and  the  induction  assumption  implies  that  w(γ , sk−1) ≤ 1.  By  assumption 
every a ∈ GA is strongly safe and thus, by Deﬁnition 22, strongly γ -safe. Using Proposition 13 we obtain in particular that 
Ak is strongly γ -safe. Consequently, also  w(γ , sk) ≤ 1. (cid:2)

The condition expressed in Corollary 23 cannot be inverted in general. Indeed, a template can be invariant even if not 

all actions are strongly safe. We will see when this happens in the following section.

5.  Safe action sequences and safe durative actions

A  template  can  be  invariant  even  if  not  all  actions  are  strongly  safe.  This  happens  for  two  reasons.  On  the  one  hand, 
since the set of reachable states Sr is in general smaller than S, it may be that all the states that are responsible for the 
lack  of  strong  safety  are  unreachable,  i.e.  they  are  not  in  Sr.  On  the  other  hand,  in  domains  with  durative  actions,  some 
instantaneous  actions  are  temporally  coupled  because  they  are  the  start  and  end  fragments  of  the  same  durative  action. 
This coupling imposes constraints on the states where the end part can be applied, which might prove helpful to establish 
that  a  template  is  invariant. While  in  this  paper  we  will  not  analyse  the  ﬁrst  case  as  it  would  require  an  analysis  of  the 
set  of  reachable  states  Sr,  which  is  infeasible,  we  now  elaborate  suitable  simple  concepts  of  safety  for  durative  actions, 
which are weaker than strong safety. These extensions are important in many real-world temporal planning domains. In our 

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

15

experience, these domains often present end-fragments of durative actions that are unsafe as written, often, γ -unbalanced. 
Nonetheless, every use in an executable plan preserves the weight condition, typically because the associated start-fragments 
force  the  weight  to  zero  and  the  invariant-fragments  keep  it  there.  (A  γ -unbalanced  action  is  safe  if  it  only  executes  in 
weight zero states.) We give a deﬁnition of safety for durative actions that captures this case. However, since in a plan a 
durative  action  may  intertwine  with  other  actions  that  happen  between  its  start  and  end  points,  we  need  to  work  out  a 
concept of safety for more general sequences of actions than just durative ones.

Below, we consider general sequences of action sets A = ( A1, A2, . . . , An). Any simple plan π generates such an object. 
i=0,...,¯k is  the  related  happening  time  sequence  and  Ati are  the  relative  happenings,  we  can  consider  the 
) that contains all the information on the plan π except the time values at which 

Indeed,  if  {ti}
happening sequence  Aπ = ( At0 , . . . , At ¯k
the various actions happen.

To study the invariance of a template, we break the happening sequence of each plan into subsequences determined by 
the  happenings  of  durative  actions.  More  precisely,  we  consider  sequences  A = ( A1, A2, . . . , An) where,  for  some  durative 
action  Da = (ast, ainv, aend),  we  have  that  ast ∈ A1 and  aend ∈ An.  The  sets  A2, . . . , An−1,  as  well  as  A1 and  An,  possibly 
contain other actions that are executed over the duration of  Da. However, it is convenient to consider general sequences of 
actions A = ( A1, A2, . . . , An) without referring to plans or durative actions. Hence, in this section, we ﬁrst give a deﬁnition 
of safety for A such that, when A is executed serially in any executable plan π , if the weight constraint is not violated in 
the state where the sequence is initially applied, it is not violated in any intermediate step and at the end of the sequence. 
For single action sets (sequences of length n = 1), this concept coincides with the notion of strong safety.

We then consider a slightly stronger notion of safety which is robust to the insertion, between elements of the sequence, 
of  other  actions  whose  positive  effects  have  no  intersection  with  the  template.  To  do  this,  it  is  necessary  to  introduce  a 
number of auxiliary concepts relating to the state dynamics induced by the execution of A. This general theory will then be 
applied to sequences constructed from durative actions.

We recall our standing assumption that any considered subset of actions,  Ai , consists of pairwise non-interfering actions 

and is assumed to be executable.

5.1.  Safe ground action sequences

For a sequence of action sets A = ( A1, A2, . . . , An), we denote with SA the set of state sequences (s0, . . . , sn) ∈ Sn+1 such 

that

si = ξ(si−1, Ai) and Ai is applicable in si−1 for all i ∈ {1, . . . , n}

If  (s0, . . . , sn) ∈ SA,  we  say  that  (s0, . . . , sn) is  a  state  sequence  compatible with  A.  Given  an  instance  γ ,  we  also  deﬁne 
SA(γ ) = {(s0, . . . , sn) ∈ SA | w(γ , s0) ≤ 1}. We use the following notation for subsequences of A: Ak
h

= ( Ah, Ah+1, . . . , Ak).

We now ﬁx a template T and an instance γ and give the following natural deﬁnition of safety for a sequence.

Deﬁnition 24  (Individually safe actions).  A  sequence  of  action  sets  A = ( A1, A2, . . . , An) is  individually γ -safe if  for  every 
sequence of states (s0, . . . , sn) ∈ SA we have that

w(γ , s0) ≤ 1 ⇒ w(γ , si) ≤ 1 ∀i = 1, . . . , n

The invariance of a template can now be expressed in terms of individual safety for the happening sequences.

Proposition 25. Let T be a template. Suppose that for every executable simple plan π , the happening sequence Aπ is individually 
γ -safe for every instance γ . Then, T is invariant.

Proof. Take any instance γ and assume that  w(γ , Init) ≤ 1. We need to show that  w(γ , s) ≤ 1 for every  s ∈ Sr . For each 
s ∈ Sr ,  there  exists  an  executable  simple  plan  π having  trace(π ) = {S i = (ti, si)i=0,...,¯k
= s,  and  with 
happening sequence Aπ . We have that the state sequence (s0, . . . , s¯k) ∈ SAπ . Since by assumption w(γ , s0) ≤ 1 the individual 
γ -safety of Aπ implies that  w(γ , s j) ≤ 1 for every  j = 1, . . . , ¯k. In particular,  w(γ , s) ≤ 1. (cid:2)

} with  s0 = Init,  s¯k

Below are elementary properties of individual γ -safety for subsequences of A.

Proposition 26. Consider a sequence of action sets A = ( A1, A2, . . . , An). The following properties hold:

(i) if, for some k and h such that k ≥ h − 1, Ak
1

= ( A1, A2, . . . , Ak) and An
h

= ( Ah, . . . , An) are both individually γ -safe, then A is 

also individually γ -safe;

(ii) if A is individually γ -safe and Ak and Ak+1 are non-interfering, then A
(iii) if A is individually γ -safe and B j , for  j = 1, . . . , n are action sets such that Eff B j = ∅, then, A
individually γ -safe. If, in addition,  A j and B j are non-interfering for every  j = 1, . . . , n, also A
individually γ -safe.

(cid:7) = ( A1, A2, . . . , Ak ∪ Ak+1, . . . , An) is individually γ -safe;
(cid:7) = ( A1, B1, A2, . . . , Bn, An) is 
(cid:7)(cid:7) = ( A1 ∪ B1, . . . , An ∪ Bn) is 

16

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Fig. 2. The insertion of the γ -irrelevant action b fails the individual γ -safety of the sequence A. See Example 6.

Proof. (i): If (s0, s1, . . . , sn) ∈ SA, we have that

(s0, s1, . . . , sk) ∈ SAk

1

,

(sh−1, s1, . . . , sn) ∈ SAn

h

.

Therefore, if  w(γ , s0) ≤ 1, from the fact that  Ak
In particular, since k ≥ h − 1, we have that  w(γ , sh−1) ≤ 1. From the fact that An
that  w(γ , s j) ≤ 1 for every  j = h, . . . , n. This implies that  w(γ , s j) ≤ 1 for every  j = 1, . . . , n and proves property (i).

1 is individually γ -safe, it follows that  w(γ , s j) ≤ 1 for every  j = 1, . . . , k. 
h is also individually γ -safe, it now follows 

(ii): Suppose (s0, s1, . . . , sk−1, sk+1, . . . , sn) ∈ SA(cid:7) where  sk+1 = ξ( Ak ∪ Ak+1, sk−1). Put  sk = ξ( Ak, sk−1) and note that, by 
serialisability  (see  Proposition 1),  sk+1 = ξ( Ak+1, sk),  and  therefore  (s0, s1, . . . , sk−1, sk, sk+1, . . . , sn) ∈ SA.  This  implies  that 
w(γ , s j) ≤ 1 for every  j = 1, . . . , n and proves property (ii).

(cid:7) k−1 = sk for every k = 1, . . . , n and (s0, s1, . . . , sn) ∈ SA. Individual γ -safety 
(cid:7) n−1, sn) ∈ SA(cid:7) , then, s
(cid:7)(cid:7)
is individually γ -safe and case 
of A now establishes property (iii). Regarding A
(ii). (cid:2)

the property follows from the fact that A

(cid:7) 0, s1, . . . , s

(iii): If (s0, s

(cid:7)

The  following  is  a  useful  consequence  of  the  previous  results:  it  asserts  that  if  individual  safety  holds  locally  in  a  se-

quence, then it also holds globally.

Corollary 27. For a sequence of action sets A = ( A1, A2, . . . , An), the following conditions are equivalent:

(i) the sequence A is individually γ -safe;
(ii) for each j = 1, . . . , n, there exists a subsequence A

j+s
j−r , with r, s ≥ 0, that is individually γ -safe.

Proof. (i) ⇒ (ii) is trivial and (ii) ⇒ (i) follows from an iterative use of (i) of Proposition 26. (cid:2)

Individual safety is a weak property since it is not robust with respect to the insertion of other actions, even when these 
actions  are  irrelevant  but  possess  delete  effects.  This  is  connected  to  the  fact  that,  while  individual  safety  has  this  nice 
local to global feature illustrated in Corollary 27, it does not possess the opposite feature: subsequences of individually safe 
sequences may not be individually safe. The following example shows both these phenomena.

Example 6. Consider a template T and an instance γ such that γ (T ) = {q, q
A = (a1, a2) (Fig. 2 – top diagram) is: SA = {(s0, s1, s2)|q /∈ s0, s1 = s0 ∪ {q
a2 is applicable in s1 and s1 = s0 ∪ {q
that a1 is γ -unbounded and thus not strongly γ -safe and that A1
1

(cid:7)}. The set of state sequences compatible with 
(cid:7)}, s2 = s1}. Note that q /∈ s0 because, by hypothesis, 
(cid:7)}. A is individually γ -safe since w(γ , si) ≤ 1 for every state si that appears in SA. Note 

= (a1) is not individually γ -safe as well.

Now consider the sequence  ˜A = (a1, b, a2) (Fig. 2 – bottom diagram) where a γ -irrelevant action b is inserted between 
a1 and  a2.  The  new  set  of  state  sequences  compatible  with  ˜A is:  S ˜A
(cid:7)}, s2 = s1 \ {q}, s3 = s2}. 
Note that now q can be in  s0 since it is the action b that ensures the applicability of a2. If q ∈ s0, since a1 adds q
to  s0, 
w(γ , s1) = 2. This new sequence is not individually γ -safe. The insertion of a γ -irrelevant action has failed the individual 
γ -safety of the sequence A.

= {(s0, s1, s2, s3)|s1 = s0 ∪ {q

(cid:7)

For proving some of our results, the concept of individual safety is not suﬃcient. Below we present a stronger deﬁnition 
of safety for an action sequence that is robust with respect to the insertion of irrelevant actions in it. First, we deﬁne the 
simple concepts of executable and reachable sequences.

Deﬁnition 28 (Executable and reachable actions). The sequence A = ( A1, A2, . . . , An) is called:

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

17

• executable if SA (cid:14)= ∅;
• γ -(un)reachable if SA(γ ) (cid:14)= ∅ (SA(γ ) = ∅).

Remark 29. Note the following chain of implications:

non-executable ⇒ γ -unreachable ⇒ individually γ -safe

Note  that  if  π is  an  executable  simple  plan,  γ is  an  instance  and  w(γ , Init) ≤ 1,  then  the  happening  sequence  Aπ is 
γ -reachable. Moreover, every subsequence  A of  Aπ is executable. If a subsequence  A of  Aπ is γ -unreachable, the weight 
will surely exceed 1 at some point of the plan π and thus the template T will not be invariant.

In  the  special  case  of  a  sequence  of  length  2,  executability  and  reachability  admit  very  simple  characterisations.  We 

report them below as we will need them later. First deﬁne, for a generic set of actions  A, the postconditions:

(cid:8)

+
A

−
+
A ) ∪ Eff
= (Pre
A
We have the following result:

\ Eff

−
+
A , (cid:8)
A

= (Pre

−
A

∪ Eff

−
A ) \ Eff

+
A

(5)

Proposition 30. For a sequence of two action sets A = ( A1, A2), the following conditions are equivalent:

(i) A is executable;
∩ Pre
(ii) (cid:8)

= ∅ = (cid:8)

+
A1

−
A2

−
A1

+
∩ Pre
A2 .

+
Proof. (i) ⇒ (ii): Note that if (s0, s1, s2) ∈ SA, it follows that Pre
⊆ s0. Since s1 = (s0 \ Eff
⊆ s1. 
A1 ) ∪ Eff
A1
−
A1 )c ⊇ s1. Since  A2 must be applicable on s1, condition (ii) 
A1 )c ⊇ s0, it follows that ((cid:8)
Analogously, using the fact that (Pre
immediately follows.

+
A1 it follows that (cid:8)

+
A1

−

−

+
(ii) ⇒ (i): Consider s0 = Pre
A1

∪ (Pre

+
A2

\ Eff

+
A1 ). Straightforward set theoretic computation, using conditions (ii), show that 

A1 can be applied on s0 and that  A2 can be applied on s1 = ξ( A1, s0). This proves (i). (cid:2)

Proposition 31. For a sequence of two action sets A = ( A1, A2), the following conditions are equivalent:

(i) A is γ -reachable;
+
(ii) A is executable and |Pre
A1
γ

+
∪ (Pre
A2
γ

\ Eff

+
A1
γ

)| ≤ 1.

Proof. (ii)  ⇒ (i):  It  follows  from  the  proof  of  (ii)  ⇒ (i)  in  Proposition 30 that  there  exists  (s0, s1, s2) ∈ SA with  s0 =
Pre

+
∪ (Pre
A2

+
A1 ). By the assumption,  w(γ , s0) ≤ 1 and this proves (i).
A1
+
(i) ⇒ (ii): it follows from the fact that if (s0, s1, s2) ∈ SA, necessarily Pre
A1

∪ (Pre

+
A2

\ Eff

+

A1 ) ⊆ s0. (cid:2)

\ Eff

+

The following result shows how executability and γ -reachability are robust with respect to some speciﬁc modiﬁcations 

of a sequence, notably, the deletion of actions containing no effects, and serialisation.

Proposition 32. Consider a sequence A = ( A1, A2, . . . , An) that is executable or γ -reachable. Then,

(i) if B j ⊆ A j are such that Eff B j = ∅ for every  j = 1, . . . , n − 1,3 then also A

(cid:7) = ( A1 \ B1, A2 \ B2, . . . , An \ Bn) is, respectively, 

executable or γ -reachable.
(cid:7) j ∪ A

(ii) if A j = A

(cid:7)(cid:7) j for some j = 1, . . . , n, then also A

(cid:7) = ( A1, A2, . . . , A

(cid:7) j, A

(cid:7)(cid:7) j, . . . , An) is, respectively, executable or γ -reachable.

Proof. (i): If (s0, s1, . . . , sn−1, sn) ∈ SA, we have that (s0, s1, . . . , sn−1, s
from the deﬁnition of executability and γ -reachability.

(ii): This follows immediately from serialisability (see Proposition 1). (cid:2)

(cid:7) n) ∈ SA(cid:7) for a suitable state s

(cid:7) n. The result then follows 

Here is our stronger notion of safety:

Deﬁnition 33 (Safe actions). A sequence of action sets A = ( A1, A2, . . . An) is γ -safe if it is executable and the subsequences 
1 are individually γ -safe for every k = 1, . . . , n.
Ak

3 Bn is not constrained; removing effects at the end of the sequence does not alter its executability or reachability.

18

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Fig. 3. Lack of robustness for individually γ -safe actions. See Example 7.

Example 6 illustrates why individual safety is too fragile a concept by itself. We would like to infer that A in Example 6
is unsafe for some appropriate notion of safety, but, as the example shows, that concept cannot be individual safety. Deﬁ-
nition 33 accomplishes that aim. Indeed, note how the sequence A = (a1, a2) considered in Example 6 is not γ -safe, since 
(a1) is not individually γ -safe.

The deﬁnition of safety asks for executability – in addition to asking for every preﬁx to be individually safe – because, 
without executability, individual safety is a vacuous condition. In particular, we would like to conclude that the happening 
sequence in Example 7 considered next is unsafe, for the reason shown. By having Deﬁnition 33 require executability, we 
attain that judgment.

Example 7  (Motivating executability in safety).  Consider  the  non-executable  sequence  A = (a1, a2) depicted  in  Fig. 3 –  top 
(cid:7)(cid:7)
is  required  to  be  false  by  a2,  but  it  is  asserted  by  a1).  Consider  a  template  T and  an  instance  γ such  that 
diagram  (q
(cid:7)(cid:7)}. As it happens, A is individually safe: vacuously, since it is non-executable. However, this is not really a 
(cid:7), q
γ (T ) = {q, q
safe arrangement: we would like to say that inserting γ -irrelevant actions preserves safety, but consider inserting such an 
,  as  in  ˜A = (a1, b, a2) and  depicted  in  Fig. 3 –  bottom  diagram.  Then  the  weight  bound,  which  held 
action  b,  deleting  q
(vacuously) for A, is violated in  ˜A (both q and q
end up true), and so we can conclude that individually safe is too weak 
for our purposes. Observe that, by requiring executability, the deﬁnition of safety rules out this (counter-)example: A is not
γ -safe, as desired. (Note that, unlike Example 6, here all the preﬁxes are individually safe.)

(cid:7)(cid:7)

(cid:7)

Remark 34. If A = ( A1, A2, . . . An) is γ -safe, the ﬁrst action set A1 must necessarily be strongly γ -safe. In the other direction, 
note that if A is executable and every  A j for  j = 1, . . . , n is strongly γ -safe then, A is γ -safe.

This motivates the following deﬁnition.

Deﬁnition 35 (Strongly and weakly safe actions). A sequence of action sets A = ( A1, A2, . . . , An) is:

• strongly γ -safe if it is executable and every  A j for  j = 1, . . . , n is strongly γ -safe;
• weakly γ -safe if it is γ -safe but not strongly γ -safe.

With  this,  we  are  ﬁnished  with  upgrading  our  notion  of  safety,  but  there  is  one  last  point  to  consider:  having  safety 
alone still does not let us prove anything, because safety only preserves a weight bound, it does not force it true initially. 
So in general we need to consider sequences that are both γ -safe and γ -reachable. We keep those notions separate, rather 
than  combine  them  in  another  deﬁnition,  for  technical  reasons:  e.g. γ -safe  can  be  shown  for  an  entire  planning  domain, 
and then γ -reachable can be checked per problem. The ﬁrst things that can be said of sequences that are both γ -safe and 
γ -reachable is that they exclude γ -heavy and γ -unbalanced actions (cf., Propositions 16 and 18).

(cid:7)}. 
Example 8 (Motivating reachability in Proposition 36). Consider the template T and an instance γ such that γ (T ) = {q, q
Now  consider  the  executable,  but  γ -unreachable  sequence  A = (a1, a2) depicted  in  Fig. 4,  consisting  of  a  γ -unreachable 
action a1 and a γ -heavy action a2. In general, we want to quickly exclude any sequence containing a γ -heavy action; but 
insisting on safety alone is not enough, as this example demonstrates. Action a1 requires both q and q
to be true and so the 
weight has to be 2 initially for A to execute (consequently, A is not γ -reachable). Perhaps counterintuitively, for the same 
reason, A is γ -safe: its two preﬁxes (a1) and (a1, a2) are both individually safe since all executions begin with the weight 
bound violated, and then all the implications comprising “safety” just hold vacuously.

(cid:7)

What the example illustrates is that, in general, undesirables such as γ -heavy actions can be hidden in nominally safe 
sequences only by failing reachability. Formally, by insisting on safety and reachability together, we can rule out heavy and 
unbalanced actions everywhere:

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

19

Fig. 4. Safety alone does not rule out heavy actions: A is safe, but a2 is heavy. See Example 8.

Proposition 36. Let A = ( A1, A2, . . . , An) be a sequence of action sets. If A is γ -safe and γ -reachable, then, for every j = 1, . . . , n, A j
is neither:

• γ -heavy, nor
• γ -unbalanced.

Proof. Since  A is  γ -reachable,  the  set  SA(γ ) is  not  empty.  Fix  any  (s0, . . . , sn) ∈ SA(γ ) and  note  that,  since  A is  γ -safe, 
+
w(γ , si) ≤ 1 for every i = 1, . . . , n. For any  j = 1, . . . , n, we have that s j = (s j−1 \ Eff
A j . This 
implies that

A j ) ∪ Eff

]) ∪ Eff

⊇ (Pre

\ Eff

+
A j

+
A j

−
A j

−

|(Pre

+

A

j
γ

\ Eff

−

A

j
γ

) ∪ Eff

| ≤ 1

+

A

j
γ

+

j
A
γ
+
⊆ Eff

As  a  consequence,  |Eff

| ≤ 1,  which  says  that  A j can  not  be  γ -heavy.  If  we  now  assume  that  |Eff

implies that Pre

+

A

j
γ

∩ Eff

−

A

j
γ

. Hence  A j cannot be γ -unbalanced. (cid:2)

A

j
γ

(6)

| = 1,  Relation  (6)

+

A

j
γ

In studying the two safety properties for a sequence A introduced so far, we can essentially restrict ourselves to study the 
state dynamics on the template instantiation γ (T ) as we did for strong γ -safety of instantaneous actions (see Remark 15).
¬γ ) the 

Considering the sequence  A = ( A1, A2, . . . An), we denote by  Aγ = ( A1

γ ) and  A¬γ = ( A1

¬γ , . . . An

γ , . . . An

¬γ , A2

γ , A2

corresponding restricted sequences. We have the following result.

Proposition 37. Given the sequence A = ( A1, A2, . . . An),

(i) A is executable if and only if Aγ and A¬γ are both executable;
(ii) A is γ -reachable if and only if Aγ is γ -reachable and A¬γ is executable;
(iii) A is individually γ -safe if and only if Aγ is individually γ -safe.
(iv) A is γ -safe if and only if Aγ is γ -safe and A¬γ is executable.

Proof. (i): It follows from (4) that, for any sequence of states (s0, . . . , sn) ∈ Sn+1, we have that

(cid:10)

(s0, . . . , sn) ∈ SA ⇔

(s0
γ , . . . , sn
¬γ , . . . , sn

γ ) ∈ SAγ
¬γ ) ∈ SA¬γ

(s0

(7)

This immediately proves the ‘only if’ implication. On the other hand, if  s
(cid:7)(cid:7)
s
¬γ

∈ SA¬γ and thus s = s
Statement (ii) can be proven analogously to (i), and statement (iii) follows by a straightforward extension of the argument 
used to prove Proposition 16. Finally, statement (iv) follows from the deﬁnition of strong γ -safety together with the previous 
statements, (i) and (iii). (cid:2)

∈ SA by (7).

(cid:7)(cid:7) ∈ SA¬γ , we have that  s

(cid:7) ∈ SAγ and  s

∈ SAγ and 

(cid:7)(cid:7)
¬γ

∪ s

(cid:7)
γ

(cid:7)
γ

We are now ready to state and prove the following fundamental result, which ensures that the concept of safe sequence 

is robust to the insertion of irrelevant actions.

Theorem  38.  Consider  a  γ -safe  sequence  A = ( A1, A2) and  γ -irrelevant  action  sets  B 1, B2, . . . , Bn.  Then,  the  sequence  ˜A =
( A1, B1, . . . , Bn, A2) is either non executable or γ -safe.

Proof. Consider the sequences restricted on the instantiation γ (T ) and its complement: Aγ , A¬γ and, respectively,  ˜Aγ , ˜A¬γ . 
By virtue of Proposition 37, we have that Aγ is γ -safe and to prove the result it is suﬃcient to show that  ˜Aγ is either non 
executable or γ -safe.

20

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Assume that  ˜Aγ is executable and let (s0, s1, s2, . . . , sn+1, sn+2) ∈ S ˜Aγ
γ is strongly safe, it follows that  w(γ , s1) ≤ 1. Note now that s j = s j−1 \ Eff
A1
implies that

j−1
γ

B

be such that  w(γ , s0) ≤ 1. Since (s0, s1) ∈ S A1

and 
for  j = 2, . . . , n + 1 and this immediately 

−

γ

w(γ , sn+1) ≤ w(γ , sn) ≤ · · · ≤ w(γ , s1) ≤ 1

What  remains  to  be  shown  is  that  also  w(γ , sn+2) ≤ 1.  To  accomplish  this,  we  introduce  the  set  F = ∪n
+
consider the new initial state  ˜s0 = s0 \ (F \ Pre
A1
γ
+
A1
γ

−
). Since  ˜s0 ⊆ s0, we know that Pre
A1
γ
γ can be applied to the state ˜s0 and we obtain the next state:

we also have that Pre

⊆ ˜s0. Thus  A1

and  we 
∩ ˜s0 = ∅. Moreover, by construction, 

i=1Eff

−
Bi
γ

−
A1
γ

) ∪ Eff

˜s1 := (˜s0 \ Eff

+
A1
γ
+
Note  that  sn+1 = s1 \ F ⊆ ˜s1,  which  implies  that  Pre
A2
γ
−
A2
γ

γ is  applicable  in  the 
⊆ sn+1 = ∅.  The  fact  that  Aγ ,  being  γ -safe,  is  executable  implies,  by  Proposition 30, 
state  sn+1,  it  follows  that  Pre
−
+
γ is  thus  applicable  in  the  state  ˜s1 and  there  exists  ˜s2 ∈ S such  that 
that  (cid:8)
A1
A2
γ
γ
(˜s1, ˜s2) ∈ S A2
. Therefore, we can conclude that (˜s0, ˜s1, ˜s2) ∈ SAγ . Since Aγ is γ -safe and  w(γ , ˜s0) ≤ w(γ , s0) ≤ 1, we have 
that  w(γ , ˜s2) ≤ 1. At the same time, since sn+1 ⊆ ˜s1, we also have that sn+2 ⊆ ˜s2 and thus  w(γ , sn+2) ≤ 1. This completes 
the proof. (cid:2)

−
= ∅.  Therefore  Pre
A2
γ

⊆ ˜s1 = ∅.  A2

.  Since  A2

⊆ ˜s1.  Also,  ˜s1 ⊆ sn+1 ∪ (cid:8)

∩ Pre

+
A1
γ

γ

Remark 39. We conjecture that Theorem 38 could be generalised to sequences of actions of length longer than two, but the 
proof is much more complex. Since this extension is not needed in this paper, we do not present such a proof here.

For  future  use,  it  will  be  convenient  to  have  a  deﬁnition  of  safeness  that  does  not  depend  on  the  particular  chosen 

instance.

Deﬁnition 40. A sequence of action sets A is safe for a template T if it is γ -safe for every instance γ of T . A sequence of 
action sets A is strongly safe for a template T if it is strongly γ -safe for every instance γ of T . It is weakly safe if it is safe 
but not strongly safe.

5.2.  Safe ground durative actions

We now restrict our attention to durative actions  Da = (ast, ainv, aend). If we interpret  Da as a sequence of three actions, 
we  can  treat  it  using  the  properties  deﬁned  for  general  sequences  such  as  γ -safety  and  strong  γ -safety.  Before  studying 
these  properties,  it  is  convenient  to  make  some  considerations  on  the  way  durative  actions  appear  in  admissible  simple 
plans.  Indeed,  several  constraints  emerge  as  a  direct  consequence  of  the  deﬁnition  of  an  induced  simple  plan  as  well  as 
from the concept of admissibility explained in Section 2.1. Consider an admissible simple plan π with happening sequence 
Aπ = ( At0 , . . . , At ¯k
). If a durative action  Da happens in π in the time interval [ti+1, t j], we have that ast ∈ Ati+1 and aend ∈
At j .  Moreover,  j − i is  necessarily  odd  and  for  every  even h = 2, 4, . . . , j − i − 1,  Ati+h consists  of ainv and,  possibly,  over 
all  conditions  of  other  durative  actions  happening  in  the  original  plan  (cid:5) simultaneously  or  intertwined  with  Da.  Finally, 
for h = 1, 3, . . . , n − 2,  Ati+h consists of actions that appear in simple admissible plans and that, consequently, inherit such 
constraints.

Deﬁnition 41 (Admissible actions). A sequence A = ( A1, A2, . . . , An) is:

• admissible if  there  exists  an  admissible  simple  plan  π with  happening  sequence  Aπ = ( At0 , . . . , At ¯k

) such  that 

( A1, A2, . . . , An) = ( Ati+1 , . . . , Ati+n ) for some i = 0, . . . , ¯k − n.

• Da-admissible, for some durative action  Da, if it is admissible and  Da happens in the corresponding simple plan π as 

above in [ti+1, ti+n]. In particular, ast ∈ A1 and aend ∈ An.

The existence of  Da-admissible sequences that are executable imposes speciﬁc conditions on the durative action  Da:

Proposition 42. Consider a durative action Da = (ast, ainv, aend) and assume that there exists an executable Da-admissible sequence. 
Then, the following conditions are satisﬁed:

(cid:8)

+
ast
Pre

∩ Pre
+
aend

−
−
= ∅, (cid:8)
ast
ainv
−
= ∅,
∩ Pre
ainv

∩ Pre
+
aend

= ∅

+
ainv
−
∩ Pre
ainv

Pre

= ∅

(8)

(9)

where the postconditions (cid:8)±

have been deﬁned in (5).

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

21

Proof. Suppose  that  A = ( A1, A2, . . . , An) is  Da-admissible  and  executable.  Since  ( A1, A2) is  executable,  Proposition 30
implies that

(cid:8)

+
A1

∩ Pre

−
A2

−
= ∅ = (cid:8)
A1

+
∩ Pre
A2

Since ast ∈ A1 and  A1 consists of pairwise non-interfering actions, we have that

(cid:8)

+
ast

−
+
⊆ (cid:8)
A1 , (cid:8)
ast

−
⊆ (cid:8)
A1

(10)

(11)

Finally, equations (10) and (11), together with the fact that ainv ∈ A2, yield conditions (8). Conditions (9) can be similarly 
proven. (cid:2)

Durative  actions  not  satisfying  any  of  the  conditions  expressed  in  the  previous  result,  can  be  ignored  in  our  analysis. 

From now on we thus assume that all durative actions satisfy conditions (8) and (9) above.

To study the safety of a  Da-admissible sequence, we can, in many cases, reduce the analysis of the durative action  Da

to the analysis of an auxiliary sequence of just two actions  Da∗ = (ast

∗ , aend
∗

), where ast

∗ and aend

∗

are actions such that:

Eff

Eff

±
ast∗
±
aend∗

= Eff

= Eff

Pre

±
ast ,
±
aend , Pre

±
ast∗
±
aend∗

= Pre

±
ast
±
= Pre
aend

∪ (Pre

±
ainv
±
∪ Pre
ainv

\ Eff

±
ast )

Remark 43. The executability assumption (2) automatically extends from ast and aend to the auxiliary actions ast
as a consequence of condition (9).

∗ and aend

∗

, 

The  relation  between  the  two  sequences  Da and  Da∗ is  clariﬁed  by  the  following  result.  Assume,  as  always,  that  a 

template T and an instance γ have been ﬁxed.

Proposition 44. The following facts hold:

(i) (s0, s1, s2) ∈ S(ast,ainv) if and only if s1 = s2 and (s0, s1) ∈ Sast∗ ;
(ii) (s0, s1, s2) ∈ S(ainv,aend) if and only if s0 = s1 and (s1, s2) ∈ Saend∗
;
(iii) (s0, s1, s2, s3) ∈ SDa if and only if s1 = s2 and (s0, s1, s3) ∈ SDa∗ ;
(iv) (ast, ainv) is individually γ -safe if and only if ast
∗ is strongly γ -safe;
(v) (ainv, aend) is individually γ -safe if and only if aend
(vi) Da is individually γ -safe if and only if Da∗ is individually γ -safe.

∗

is strongly γ -safe;

+

+
ainv

ast ) \ Eff

−
ast must  satisfy  the  conditions  Pre

Proof. (i): Suppose (s0, s1, s2) ∈ S(ast,ainv). Since ainv only contains preconditions, we have that s1 = s2. Note now that s1 =
+
+
−
ξ(ast, s0) = (s0 ∪ Eff
ainv )c .  This  yields  Pre
ast and  thus 
ainv
ainv )c ,  we  obtain  that  s0 ⊆ (Pre
\ Eff
\ Eff
∗ is 
Pre
∗ have  the  same  effects.  If  instead  (s0, s1) ∈ Sast∗ ,  we  have  that  ast is 
applicable  on  s0 and  s1 = ξ(ast
∗ , s0) = ξ(ast, s0).  (ii)  is  proven 
applicable  on  s0 (since  the  preconditions  of ast are  also  preconditions  of ast
similarly to (i). (iii) follows from (i) and (ii) and, ﬁnally, (iv), (v), and (vi) follow, respectively, from (i), (ii), and (iii). (cid:2)

⊆ s0 ∪ Eff
−
ast )c .  This  implies  that  also  ast

−
ast
∗ , s0) since  ast and  ast

⊆ s0.  Similarly,  from  s0 \ Eff

∗ )  and  s1 = ξ(ast

⊆ s1 ⊆ (Pre

−
⊆ (Pre

−
ainv

+
ainv

+
ast

The  next  result  studies  the  effect  of  exchanging  the  start  and  end  of  a  durative  action  Da with  those  of  the  auxiliary 

sequence  Da∗ in a  Da-admissible sequence.

Proposition 45. Consider a durative action Da = (ast, ainv, aend) and a Da-admissible sequence of actions A = ({ast}, A2, . . . , An−1,
{aend}). Let A∗ = ({ast
∗ }). Then SA = SA∗ . In particular, A is individually γ -safe if and only if A∗ is individually 
γ -safe.

∗ }, A2, . . . , An−1, {aend

Proof. Since  A∗ differs  from  A only  for  having  more  preconditions,  it  holds  that  SA ⊇ SA∗ .  Conversely,  suppose 
(s0, . . . , sn) ∈ SA. Then, (s0, s1, s1) ∈ S(ast,ainv). Therefore, by (i) of Proposition 44, we have that (s0, s1) ∈ Sast∗ . Similarly, using 
(ii) of Proposition 44, we obtain that (sn−1, sn) ∈ Saend∗
. These two facts together with (s1, s2, . . . , sn−1) ∈ S( A2,..., An−1), yield 
(s0, . . . , sn) ∈ SA∗ . (cid:2)

The  last  proposition  implies  that,  in  analysing  the  state  dynamics  in  an  executable  plan,  we  can  replace  the  start  and 
end of each durative action Da with the corresponding ones of the auxiliary sequence Da∗, if the start and end are isolated 
from other actions. This is useful for two reasons. On the one hand, there are cases in which  Da∗ is strongly safe even if 
Da is not. On the other hand, we can directly apply Theorem 38 to  Da∗ since it is of length 2.

22

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

∗ , aend
∗

As we shall see later, our suﬃcient results for the invariance of a template always require safety (strong or simple) of 
the  auxiliary  actions  Da∗ = (ast
).  The  check  for  strong  safety  can  be  done  by  considering  the  single  components  of 
Da∗ and referring back to the analysis that we carried out in the previous section. Below, we give a full characterisation of 
simple safety for auxiliary actions.
Note ﬁrst that if  Da∗ = (ast
∗ , aend
∗

∗ is strongly γ -safe 
and aend
is not strongly γ -safe. If, besides these three properties, Da∗ is γ -unreachable, then Da∗ is weakly γ -safe because 
of Remark 29. If we instead assume that  Da∗ is weakly γ -safe and γ -reachable, then, because of Proposition 36, we have 
that aend

is γ -unbounded. The following result completely characterises simple γ -safety for such actions.

) is weakly γ -safe (Deﬁnition 35), necessarily  Da∗ is executable, ast

∗

∗

Proposition 46. Let Da∗ = (ast
is weakly γ -safe if and only if one of the following mutually exclusive conditions are satisﬁed:

∗ ) be a γ -reachable sequence such that ast

∗ , aend

∗ is strongly γ -safe and aend

∗

is γ -unbounded. Then, Da∗

(a) ast

(b) ast

(c) ast

(d) ast

+
+
∗ is γ -irrelevant, |Pre
| = 1, Pre
ast∗γ
ast∗γ
+
+
∗ is γ -irrelevant, |Pre
| = 1, Pre
ast∗γ
ast∗γ
+
−
∗ is γ -irrelevant, |Pre
| = 0, Pre
ast∗γ
ast∗γ
+
⊆ Effaend∗γ
∗ is γ -relevant, Eff
ast∗γ

.

−
⊆ Eff
ast∗γ
−
(cid:2) Eff
ast∗γ
∪ Effast∗γ

;

+
, Pre
ast∗γ
∪ Effaend∗γ

⊆ Effaend∗γ
;
= γ (T );

Proof. Note that Da∗ is γ -reachable and ast
∗ strongly γ -safe. Hence, Da∗ is weakly γ -safe if and only if Da∗γ is individually 
γ -safe.  This  last  fact  is  equivalent  to  showing  that,  given  any  state  sequence  (s0, s1, s2) ∈ SDa∗γ such  that  s0 ∈ γ (T ) and 
w(γ , s0) ≤ 1, it holds that  w(γ , si) ≤ 1 for i = 2 (since for i = 1 that follows from the strong safety of ast

∗ ). Let

Wγ = {s1 ∈ γ (T ) | ∃s0, s2 ∈ γ (T ), w(γ , s0) ≤ 1, (s0, s1, s2) ∈ SDa∗γ
We need to show that, for every s1 ∈ Wγ , we have that  w(γ , s2) ≤ 1, where

}

s2 = ξ(aend

∗γ , s1) = (s1 \ Eff

−
aend∗γ

) ∪ Eff

+
aend∗γ

Since aend

∗

is γ -unbounded, the condition  w(γ , s2) ≤ 1 is equivalent to

s1 ⊆ Effaend∗γ

(12)

Since ast

∗ is γ -reachable and strongly γ -safe, it follows from Theorem 18 that it is either γ -irrelevant or γ -relevant. If 
−
}. Combining this with (12), we thus have that in this 
ast∗γ

+
| = 1, we have that Wγ = {Pre
ast∗γ

\ Eff

+
∗ is γ -irrelevant and |Pre
ast
ast∗γ
case  Da∗ is γ -safe if and only if

+
ast∗γ

+
ast∗γ

Pre

\ Eff

⊆ Effaend∗γ
This leads to the two possible cases (a) and (b).
+
∗ is γ -irrelevant and |Pre
ast∗γ

Suppose now that ast

| = 0. In this case,

Wγ = {s1 ⊆ γ (T ) | w(γ , s1) ≤ 1, s1 ∩ (Pre

−
ast∗γ

∪ Eff

−
ast∗γ

) = ∅}

Combining this with (12), we thus have that in this case  Da∗ is γ -safe if and only if

Pre

−
ast∗γ

∪ Eff

−
ast∗γ

∪ Effaend∗γ

= γ (T )

This leads to case (c).
Finally, if αst

∗γ is relevant we have that Wγ = {Eff

if and only if condition (d) is veriﬁed. (cid:2)

+
ast∗γ

}. Combining this with (12), we obtain that in this case Da∗ is γ -safe 

Remark 47.  If  Condition  (a)  of  Proposition 46 holds,  this  implies  that  the  same  conditions  need  to  be  satisﬁed  by  ast: 
+
|Pre
ast
γ

+
| = 1, Pre
ast
γ

⊆ Eff

−
ast
γ

.

Deﬁnition 48  (Weakly safe durative actions).  We  say  that  Da∗ is  weakly γ -safe of type (x) where  x ∈ {a, b, c, d} if  it  is 
γ -reachable, ast

is γ -unbounded, and, ﬁnally,  Da∗ satisﬁes the condition (x) of Proposition 46.

∗ is strongly γ -safe, aend

∗

Example 9. Consider a template T and an instance γ such that γ (T ) = {q, q
types (a)–(d).

(cid:7)}. Fig. 5 shows possible instances of actions of 

(13)

(14)

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

23

Fig. 5. Examples of weakly γ -safe actions of types (a)–(d). See Example 9.

Fig. 6. The sequence A is not individually γ -safe. See Example 10.

When the start or the end of a durative action  Da happens simultaneously with other actions, the reduction of  Da to 

Da∗ cannot be performed in general as shown in the following example.

(cid:7)

and a

Example 10. Consider a template T and an instance γ such that γ (T ) = {q, q
are considered in isolation, both ast
actions  Da and  Da
(cid:7) end
aend
∗
∗
γ -safe.  However,  if  we  now  consider  the  case  in  which  Da and  Da
A = ( A1 = {ast, a
we have that s1 = ξ(s0, A1) = {q, q

are γ -irrelevant,  Da∗ and  Da

(cid:7) st}, A2 = {ainv, a

(cid:7)(cid:7)}. Fig. 6 shows that, when the durative 
are strongly γ -safe since they are γ -unreachable.  Since 
are individually 
happen  simultaneously,  giving  rise  to  the  sequence 
(cid:7)(cid:7)} with w(γ , s0) = 1, 

(cid:7)(cid:7)(cid:7)} with  w(γ , s1) = 3, which violates the deﬁnition of individual γ -safety.

(cid:7) inv}), we see that A is not individually γ -safe. In fact, if we set s0 = {q

(cid:7)
∗ are strongly γ -safe and thus (by Proposition 44)  Da and  Da

∗ and a

(cid:7)(cid:7), q

(cid:7), q

(cid:7) st
∗

(cid:7)

(cid:7)

Note  that,  in  the  previous  example,  the  two  durative  actions  are γ -unreachable.  The  following  result  shows  that  such 

pathological phenomena can only happen in that case and will be instrumental for the results of the next section.

Proposition 49. Let Da be a γ -reachable durative action such that ast is not strongly γ -safe, while ast

∗ is strongly γ -safe. Then,

∗ is γ -bounded;

(i) ast
(ii) for every action set A1 such that ({ast} ∪ A1, ainv) is executable, ({ast} ∪ A1, ainv) is individually γ -safe.

Proof. Since  Da is  γ -reachable,  it  follows  from  Proposition 36,  that  ast must  necessarily  be  γ -unbounded.  In  particular, 
∗ cannot be 
this yields Pre
∗ must be 

γ -balanced. Since it also cannot be γ -unreachable (since  Da is γ -reachable), it follows from Corollary 21 that ast
γ -bounded. This proves (i).

cannot have any intersection with Eff ast
γ

+
= ∅. Therefore, Pre
ast∗γ

. This says that ast

+
= Pre
ainv
γ

\ Eff

+
ast
γ

+
ast
γ

24

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Fig. 7. The sequence A is not individually γ -safe. See Example 11.

Suppose now that the sequence ({ast} ∪ A1, ainv) is executable and let q ∈ Eff
−
ast
γ

Note that q cannot belong to either  Eff

or  Pre

−
ast
γ

, since ast and the actions in  A1 must be non-interfering. On the other 

+
A1
γ

. By (i), it follows that q ∈ Effast

γ

−
∪ Pre
ast∗γ

. 

−
ainv
γ

+
ast
γ

hand,  q cannot  belong  to  Pre

.  As  a  result  we  have  that  Eff

,  otherwise  the  sequence  would  not  be  executable.  Therefore  the  only  possibility  is  that 
.  Consider  now  ˜A1 the  action  set  obtained  from  A1 by  eliminating  all 
q ∈ Eff
positive effects belonging to γ (T ). We have that {ast} ∪ A1 = {ast} ∪ ˜A1. Consider now the sequence ( ˜A1, ast, ainv) and note 
that  ˜A1 is γ -irrelevant, and (ast, ainv) is individually γ -safe because of (iv) of Proposition 44. Therefore, by Proposition 26, 
( ˜A1, ast, ainv) is also individually γ -safe, and thus also ({ast} ∪ A1, ainv). (cid:2)

⊆ Eff

+
A1
γ

+
ast
γ

No similar results hold for the end parts of durative actions as next example shows.

are  γ -irrelevant,  Da∗ and  Da

Example 11.  Consider  a  template  T and  an  instance  γ such  that  γ (T ) = {q, q
(Fig. 7)  are  considered  in  isolation,  both  aend
(cid:7) st
a
∗
Moreover,  Da and  Da
A = ( A1 = {ainv, a
s1 = ξ(s0, A1) = ∅ and s2 = ξ(s1, A2) = {q, q

(cid:7)}.  When  the  durative  actions  Da and  Da
∗ and 
are  individually  γ -safe. 
happen simultaneously, giving rise to the sequence 
(cid:7) end}),  A is  not  individually  γ -safe.  If  we  put  s0 = ∅ with  w(γ , s0) = 0,  we  have  that 
(cid:7)} with  w(γ , s2) = 2, which violates the deﬁnition of individual γ -safety.

(cid:7)
∗ are  strongly  γ -safe  and  thus  (by  Proposition 44)  Da and  Da

are  strongly  γ -safe  since  they  are  γ -bounded.  Since  ast

are both γ -reachable. However, if  Da and  Da

(cid:7) inv}, A2 = {aend, a

and  a

(cid:7) end
∗

∗

(cid:7)

(cid:7)

(cid:7)

(cid:7)

6.  Conditions for the invariance of a template

Any  plan  π where  all  actions  are  strongly  safe  and  all  durative  actions  are  safe  and  take  place  in  isolation,  i.e.  with 
no other actions happening in between them, yields a safe happening sequence Aπ , as a consequence of Corollary 27. The 
diﬃculty, in general, is that durative actions can in principle start or end together and be intertwined with other instan-
taneous or durative actions. Safety of durative actions must therefore be accompanied by suitable hypotheses guaranteeing 
that  dangerous  intertwinements  or  simultaneous  happenings  cannot  take  place  in  executable  plans.  In  this  way,  we  can 
work out suﬃcient conditions for the invariance of a template, which will be useful in analysing concrete examples.

In this section, we present two results that give suﬃcient conditions for the invariance of a template. The ﬁrst deals with 
the particular case when all instantaneous actions are strongly safe and all durative actions Da are such that Da∗ is strongly 
safe.  The  second  result  considers  a  more  general  case  when  there  are  durative  actions  Da for  which  Da∗ is  only  weakly 
safe.

Considering a template T and an instance γ , we denote by GAd(wk, γ ) the collection of durative actions that are not 
strongly γ -safe and with GAst(wk, γ ) and GAend(wk, γ ) the collection of their start and end fragments, respectively. The 
following property prevents the simultaneous end of durative actions that could yield unsafe phenomena.

Deﬁnition 50 (Relevant right isolated actions). For a template T , the set of durative actions GAd is said to be relevant right 
isolated if, for every instance γ and for every  Da1, Da2 ∈ GAd(wk, γ ), one of the following conditions is satisﬁed:

(i) |Eff

+
a1end
γ

∪ Eff

+
a2end
γ

| ≤ 1;

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

25

(ii) at least one of the two pairs {a1end, a2end}, {a1inv , a2inv } is either mutex or non executable;
(iii) the sequence ({a1inv , a2inv }, {a1end, a2end}) is γ -unreachable.

Theorem 51. Consider a template T and suppose that the set of instantaneous actions GAi and that of durative actions GAd satisfy 
the following properties:

(i) every a ∈ GAi is strongly safe;
(ii) for every instance γ and every Da ∈ GAd(wk, γ ), Da∗ is γ -reachable and strongly γ -safe;
(iii) GAd is relevant right isolated.

Then, T is invariant.

Proof. Consider an executable simple plan π with happening sequence Aπ = ( At0 , . . . , At ¯k
that Aπ is individually γ -safe.

We split happenings as follows:  Ati

= Ast
ti

∪ As
ti

∪ Aend
ti

where

) and any instance γ . We prove 

is either empty or consists of the start fragments in GAd(wk, γ );

is either empty or consists of the ending fragments in GAd(wk, γ );

• Ast
ti
• Aend
ti
• As
ti

= At \ ( Ast
ti

∪ Aend
ti
durative actions in GAd \ GAd(wk, γ )).

) consists of strongly γ -safe actions (either instantaneous or possibly the starting and ending of 

ti

, Ast
ti

\ Ast
ti

\ {ainv}) and thus also of ( Ast
ti

(cid:14)= ∅, it either consists of all strongly γ -safe actions and is thus strongly γ -safe, or there exists a durative 
Note that if  Ast
ti
action  Da ∈ GAd(wk, γ ) such that ast is not strongly safe and ast ∈ Ast
. Considering the second case, note that  Ati+1 simply 
ti
consists of {ainv} possibly together with other over all fragments of durative actions. The executability of ( Ati , Ati+1 ) yields, 
, ainv). By hypothesis, Da is 
, ainv, Ati+1
by (ii) of Proposition 32, the executability of ( Ati
, ainv) is individually 
γ -reachable and ast
γ -safe.  Using  (iii)  of  Proposition 26,  we  obtain  that  ( Ast
, Ati+1 ) is 
ti
individually γ -safe.
Similarly,  if  Aend

∗ is strongly γ -safe, so we can therefore apply Proposition 49 and conclude that ( Ast
ti
, Ati+1 ) is  individually  γ -safe.  Therefore,  if  Ast
ti

(cid:14)= ∅,  it  either  consists  of  all  strongly  γ -safe  actions  and  is  thus  strongly  γ -safe,  or  there  exists  a 
durative action  Da ∈ GAd(wk, γ ) such that aend is not strongly γ -safe and aend ∈ Aend
. Suppose that there exists another 
(cid:7) end}
and {aend, a
durative action Da
are  necessarily  composed  of  non-interfering  actions  and  each  of  them  is  executable.  Since  GAd is  right  relevant  isolated, 
(cid:7) end}) is  γ -unreachable.  Since  Ati−1 only  consists  of  actions  with  no 
this  implies  that  the  sequence  ({ainv, a
effects,  it  then  follows  from  Proposition 32 that  the  sequence  ( Ati−1 , Aend
) is  also  γ -unreachable  and  thus  individually 
+
\
to be the action set obtained from  Aend
γ -safe. The other possibility is that  Eff
Aend
ti γ
= {aend} ∪ ˜Aend
{aend} by  eliminating  all  positive  effects  belonging  to  γ (T ).  We  have  that  Aend
\ {ainv} only contains preconditions and  ˜Aend
individually γ -safe by (v) of Proposition 44. Considering that  Ati−1
γ -safe, applying, in order, items (iii), (i) and (ii) of Proposition 26, we obtain that ( Ati−1 , aend), ( Ati−1 , aend, ˜Aend
( Ati−1 , Aend

.  Note  now  that  (ainv, ) is 
is strongly 
), and ﬁnally 

(cid:7) end} is γ -heavy. The two pairs {ainv, a

. Consider in this case  ˜Aend

(cid:7) ∈ GAd(wk, γ ) such that a

) are individually γ -safe.

(cid:7) inv}, {aend, a

(cid:7) inv}, {aend, a

(cid:7) end ∈ Aend

(cid:14)= ∅,  ( Ast
ti

+
aend
γ

= Eff

ti

ti

ti

ti

ti

ti

ti

ti

ti

ti

Note that, for each happening time ti , there are four possibilities:

• Ast
ti
• Ast
ti

ti

ti

= As
= ∅: in this case  Ati
ti
= ∅: in this case, since  As
ti

= ∅,  Aend
(cid:14)= ∅,  Aend
obtain that ( As
ti
(cid:14)= ∅: arguing analogously to the case above we obtain that ( Ati−1 , Ati ) is individually γ -safe.
= ∅,  Aend
(cid:14)= ∅: arguing analogously to the case above we obtain that ( Ati−1 , Ati , Ati+1 ) is individually γ -safe.
(cid:14)= ∅,  Aend

is strongly γ -safe by deﬁnition;
and ( Ast
ti
, Ati+1 ) and ( Ati , Ati+1 ) = ( As
ti

, Ati+1 ) are individually γ -safe, using (i) and (ii) of Proposition 26, we 
∪ Ast
ti

, Ati+1 ) are also individually γ -safe.

, Ast
ti

ti

• Ast
ti
• Ast
ti

ti

Using Corollary 27 we obtain that Aπ is individually γ -safe. (cid:2)

Note  that  assumption  (iii)  in  the  statement  of  Theorem 51 excludes  the  simultaneous  end  of  durative  actions;  if  such 

phenomena can be excluded a-priori, the hypothesis can be removed.4

4 It seems more believable to synchronise the beginning of two actions than the ends; we can imagine deﬁning a temporal planning language that a 
priori excludes simultaneous endings from having any other effect than if sequenced. We can also imagine imposing the same restriction for beginnings. It 

26

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Fig. 8. Action schemas Da and Da

(cid:7)

can intertwine in such a way that they give rise to a sequence that is not individually γ -safe. See Example 12.

When  there  are  durative  actions  Da for  which  Da∗ is  not  strongly  γ -safe,  further  hypotheses  are  needed  in  order  to 
guarantee that the template T is invariant. In this case, simultaneity can be harmful, but also any intertwinement between 
such a durative action and other actions. The following examples show the type of phenomena that can happen and that 
any theorem extending Theorem 51 needs to prevent.

(cid:7)(cid:7)}. Both the durative actions  Da and  Da
Example 12. Consider a template T and an instance γ such that γ (T ) = {q, q
(Fig. 8) are γ -safe. However, they can intertwine in such a way that they give rise to a sequence that is not individually 
(cid:7) end}).  If  we  put  s0 = {q} with  w(γ , s0) = 1,  we  have  that  s4 =
γ -safe:  A = ( A1 = {ast}, A2 = {a
(cid:7)(cid:7)} with  w(γ , s4) = 2.
{q

(cid:7) st}, A3 = {aend}, A4 = {a

(cid:7), q

(cid:7), q

(cid:7)

The  following  deﬁnition  describes  a  set  of  durative  actions  for  which  such  phenomena  cannot  take  place.  It  consists 
of  three  requirements  acting,  for  each  instantiation γ ,  on  a  subset  GAd(γ ) of  durative  actions  containing  the  potentially 
dangerous  actions  GAd(wk, γ ).  The  ﬁrst  prevents  the  simultaneous  happening  of  two  start  fragments  of  such  durative 
actions. The second requirement states instead that between the happening of two such start fragments there must be the 
end  of  a  third  durative  action  in  GAd(γ ).  This  fact,  because  of  the  ﬁniteness  of  the  plans,  will  lead  to  the  impossibility 
of intertwining between durative actions in the family GAd(γ ). Finally, the third requirement prevents the possibility that 
other γ -relevant actions might happen in the middle of a durative action in GAd(γ ).

Before stating the exact deﬁnition, we set the following notation. Given an instance γ and a GAd(γ ) subset of durative 

actions, we denote by GAst(γ ) and GAend(γ ), respectively, the set of its start and end fragments.

Deﬁnition 52 (Relevant non intertwining actions). Given a template T , the set of durative actions GAd is said to be relevant 
non intertwining if,  for  every  instance  γ ,  we  can  ﬁnd  a  subset  of  durative  actions  GAd(γ ) ⊇ GAd(wk, γ ) such  that  the 
following property is satisﬁed. For every  Da ∈ GAd(γ ) and for every γ -reachable  Da-admissible sequence of actions

A = ( A1, A2, . . . , An−1, An)

with  A1 ⊆ GAst(γ ), the following conditions are satisﬁed:

(15)

(i) A1 = {ast};
(ii) If b ∈ A j ∩ GAst(γ ) for 1 < j < n, then there exists b
(iii) If  A j ∩ (GAst(γ ) ∪ GAend(γ )) = ∅ for every  j = 2, . . . , n − 1, then each  A j is γ -irrelevant for  j = 2, . . . , n − 1.

(cid:7) ∩ GAend(γ ) for some 1 < j

(cid:7) ∈ A j

(cid:7) ≤ j;

Considering,  in  this  deﬁnition,  subsets  of  durative  actions  possibly  larger  than  GAd(wk, γ ) leads  to  a  more  ﬂexible 

theory. An instance of this ﬂexibility is later shown in Example 13.

seems that PDDL2.1 tries to do so (for both beginnings and endings with its no-moving-targets rule), but in fact PDDL2.1 permits precise synchronisation 
to have a different result (as seen in Example 10). In any case, in such scenarios, condition (iii) – which is costly to check – can be omitted.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

27

The following is the main technical result of this section: it expresses a suﬃcient condition for a template to be invariant 
under  the  assumptions  that  instantaneous  and  durative  actions  are  safe  and  that  the  relevant-non-intertwining  property 
holds. Later on, we will look for more easy-to-check conditions that guarantee the relevant non intertwining property.

Theorem 53. Consider a template T and suppose that the set of instantaneous actions GAi and durative actions GAd satisfy the 
following properties:

(i) every a ∈ GAi is strongly safe;
(ii) for every Da ∈ GAd, Da∗ is safe;
(iii) the set GAd is relevant non intertwining.

Then, T is invariant.

Proof. Fix  any  executable  simple  plan  π with  happening  sequence  Aπ = ( At0 , . . . , At ¯k
w(γ , Init) ≤ 1. We prove that Aπ is individually γ -safe.

) and  any  instance  γ .  Assume  that 

Consider the set of durative actions GAd(γ ) as in Deﬁnition 52. Suppose that we can prove that if Da ∈ GAd(γ ) appears 
in  π at  the  time  window  [th, tk] (namely,  ast ∈ Ath and  aend ∈ Atk ),  the  corresponding  action  sequence  A = ( Ath , . . . , Atk )
satisﬁes the following conditions:

(a) for every i ∈ (h, k),  Ati consists exclusively of γ -irrelevant actions;
(b) for every i ∈ [h, k),  Ati does not contain actions in GAst(γ ) except ast ∈ Ath .

Note that if (b) holds true for every  Da ∈ GAd(γ ), we automatically have this,

(c) for every i ∈ (h, k],  Ati does not contain actions in GAend(γ ) except aend ∈ Atk .

Assuming this to hold, we now proceed as in the proof of Theorem 51 and we split each happening  Ati
way. We let  Ati

where:

= Ast
ti

∪ As
ti

∪ Aend
ti

in the following 

• Ast
ti
• Aend
ti
• As
ti

is either empty or consists of a start fragment in GAst(γ );

is either empty or consists of an ending fragment in GAend(γ );

= At \ ( Ast
ti

∪ Aend
ti

) only consists of strongly γ -safe actions.

We now consider the new plan  ˜π :

˜π = {(t, a) ∈ π | a ∈ As
t

} ∪ {(t − (cid:9), a) ∈ π | a ∈ Aend

t

} ∪ {(t + (cid:9), a) ∈ π | a ∈ Ast
t

}

where (cid:9) > 0 is chosen in such a way that (cid:9) < ti+1 − ti for every i = 0, . . . , ¯k − 1.

It  follows  from  Proposition 1 on  serializability  that  plan  ˜π is  also  executable.  We  denote  its  happening  sequence  as 
A ˜π = ( ˜At0 , . . . , ˜At ¯k
).  For  the  sake  of  notational  simplicity,  happening  times  are  denoted  as  those  in  π even  if  in  general 
they differ and form a larger set. Note now that the happening times in  ˜π can be split into singletons ti such that  ˜Ati only 
consists of strongly γ -safe actions, and intervals [ti+1, t j] such that there exists a durative action Da ∈ GAd(γ ) happening in 
that interval. In this case, we have that the subsequence A = ( ˜Ati+1 , . . . , ˜At j ) is Da-admissible. Let A∗ = ( ˜Ati
∪
{ainv}).  Note  that,  since  A is  executable  (since  it  appears  in  an  executable  plan),  A∗ is  also  executable  by  Proposition 45. 
Since, by assumption (ii),  Da∗ is γ -safe, it follows from Theorem 38, that A∗ is also γ -safe. Using again Proposition 45 we 
ﬁnally obtain that A is individually γ -safe.

∪ {ainv}, . . . , At j

We  have  thus  proven  that  each  happening  time  ti

in  the  new  plan  ˜π stays  inside  an  individually  γ -safe  sequence 
(possibly of length 1) (see Fig. 9). By Corollary 27 this implies that A ˜π is individually γ -safe. A repetitive use of statement 
(ii) of Proposition 26 now yields that Aπ is also individually γ -safe.

We are thus left with proving that every durative action  Da ∈ GAd(γ ) in π satisﬁes properties (a) and (b) stated above. 
Suppose  this  is  not  true  and  let  Da be  the  ﬁrst  action  to  start  in  π (in  the  time  window  [th, tk])  and  to  violate  either 
condition  (a)  or  (b).  Note  that  all  durative  actions  in  GAd(γ ) happening  in  π and  starting  strictly  before  time  th,  will 
necessarily end at a time t ≤ th by the way  Da has been chosen. Moreover, all such durative actions will satisfy properties 
for every i ≤ h (note that in th
(a) and (b). We can then proceed as before and consider the splitting  Ati

= Ast
ti

∪ As
ti

∪ Aend
ti

28

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Fig. 9. Structure of a plan  ˜π as constructed in Theorem 53. Strongly safe actions are indicated in green, relevant in red and irrelevant in grey. (For 
interpretation of the references to colour in this ﬁgure legend, the reader is referred to the web version of this article.)

th

). Consider now the auxiliary plan  ˜π constructed exactly 
there could be, in principle, more than one starting action in  Ast
th
like before for t ≤ th and coinciding with π for t > th. As before, we denote its happening sequence as A ˜π = ( ˜At0 , . . . , ˜At ¯k
)
using the same notation for the happening times as in π and we assume that  ˜Ath
= Ast
(this is for simplicity of notation 
th
considering that it would be instead  ˜Ath+(cid:9) = Ast
). Note that since π is executable and  w(γ , Init) ≤ 1, the sequence Aπ is 
γ -reachable and consequently, because of (ii) of Proposition 32, A ˜π is also γ -reachable. Arguing as above, we obtain that 
( ˜At0 , . . . , ˜Ath−1 ) is individually γ -safe. If we take any (˜s0, . . . , ˜s¯k) ∈ SA ˜π (γ ), we thus have that  w(γ , ˜sh−1) ≤ 1. Consider now 
A = ( ˜Ath , ˜Ath+1 , . . . , ˜Atk ) = ( Ast
, Ath+1 , . . . , Atk ) and note that, (˜sh−1, . . . , ˜sk) ∈ SA(γ ) so that A is γ -reachable. It then follows 
= {ast}.  Suppose  now  that  property  (b)  stated 
from  the  relevant  non  intertwining  property  ((i)  of  Deﬁnition 52)  that  Ast
th
∩ GAst(γ ) (cid:14)= ∅.  By  (ii)  of  Deﬁnition 52,  it  follows 
above  is  not  satisﬁed  and  let  l ∈ (h, k) be  the  ﬁrst  index  such  that  Atl
(cid:7) ∈ (h, l].  Note  that  such  a  durative 
that  there  must  exist  a  durative  action  Da
action cannot start, in the plan π and thus also in the plan  ˜π , before time th for the way  Da was chosen, it cannot either 
start at time th by previous considerations or in the interval (th, tl(cid:7) ) because of the way l
has been chosen. This proves that 
property (b) must be satisﬁed. Note that this also shows that  Ati does not contain actions in GAend(γ ) for any i ∈ (h, k) (as 
the corresponding start fragment cannot happen either before or after time th ). Finally,  Ati is γ -irrelevant for every i ∈ (h, k)
because of (iii) of Deﬁnition 52. Therefore A satisﬁes properties (a) and (b) contrarily to the assumptions made on  Da. The 
proof is now complete. (cid:2)

(cid:7) ∈ GAd(γ ) such  that a

(cid:7) end ∈ Atl

(cid:7) for  some l

th

(cid:7)

The properties that the set of durative actions GAd needs to satisfy to be relevant non intertwining, which are expressed 
in  Deﬁnition 52,  are  in  general  diﬃcult  to  check  as  they  require  considering  sequences  of  actions  of  possibly  any  length. 
Below we give a suﬃcient condition that guarantees these properties hold but only involves pairs of durative and instanta-
neous actions. It is computationally much simpler and suitable to be later analysed at the lifted level of action schemas.

We start with a property for pairs of actions a, a

that, when veriﬁed, prevents the happening of the action a followed 
,  in  any  executable  plan,  where  only  irrelevant  actions  in  a  certain  family  happen  in  between.  See  (5) to  recall  the 

(cid:7)

(cid:7)

by  a
deﬁnition of the postconditions (cid:8)+

a and (cid:8)−

a of an action a.

Deﬁnition  54  (M(γ )-unreachable  actions).  Consider  a  template  T ,  an  instantiation  γ and  a  subset  M(γ ) ⊆ GA of 
γ -irrelevant actions. A pair of actions (a, a
(i) there exists q ∈ (cid:8)+
a
(ii) there exists q ∈ (cid:8)−
a
+
\ Eff
(iii) |Pre
aγ

−
∩ Pre
a(cid:7) such that, for every a
+
∩ Pre
a(cid:7) such that, for every a
+
aγ )| > 1.

(cid:7)) is M(γ )-unreachable if any of the following conditions are satisﬁed:

(cid:7)(cid:7) ∈ M(γ ), q /∈ Eff
(cid:7)(cid:7) ∈ M(γ ), q /∈ Eff

−
a(cid:7)(cid:7) ;
+
a(cid:7)(cid:7) ;

+
∪ (Pre
(cid:7)
a
γ

The ﬁrst condition essentially says that the application of the action a leads to a state containing a ground atom q that 
needs to be false in order to then apply a
and that there is no action in  M(γ ) that can make this atom false. The second 
condition is analogous to the ﬁrst, but exchanges the role of true and false atoms. Finally, the third condition requires that 
(cid:7)) be a γ -unreachable pair, assuming that it is executable. The following result explains the name that we have chosen 
(a, a
for these properties.

(cid:7)

Proposition 55. If a pair of actions (a, a

(cid:7)) is M(γ )-unreachable, any sequence of actions

A = ({a}, A2, . . . , An−1, {a

(cid:7)})

such that, for i = 2, . . . , n − 1, Ai ⊆ M(γ ), is γ -unreachable.

Proof. Assume that, by contradiction, there exists a γ -reachable sequence

A = ({a}, A2, . . . , An−1, {a

(cid:7)})

such that  A j ⊆ M(γ ) for each  j. Consider (s0, . . . , sn) ∈ SA(γ ).

Suppose condition (i) is satisﬁed. We have that q ∈ s1 and, because of the assumption made, it follows that q /∈ Eff

−
every  j = 2, . . . , n − 1. Therefore, q ∈ sn−1. Since q ∈ Pre
a(cid:7) , this is a contradiction.

A similar argument can be used when condition (ii) is satisﬁed.

−
A j for 

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

29

+
Finally, assume that condition (iii) is satisﬁed. Note that, since  A2, . . . , An−1 are γ -irrelevant, Pre
aγ

and this contradicts the fact that (s0, . . . , sn) ∈ SA(γ ). (cid:2)

+
∪ (Pre
(cid:7)
a
γ

\ Eff

+

aγ ) ⊆ s0

The following is a stronger version of the relevant non intertwining property that is completely formulated at the level of 
pairs of actions, without referring to sequences. It consists of three points that correspond to the three properties required 
in  Deﬁnition 52.  It  will  be  convenient  to  ﬁrst  introduce  some  additional  notation.  Given  an  instance  γ and  a  GAd(γ )
subset of durative actions, we denote by GA(γ )irr and GA(γ )rel the set of actions in GA \ (GAst(γ ) ∪ GAend(γ )) that are, 
respectively, γ -irrelevant and γ -relevant.

Deﬁnition 56  (Pairwise relevant non-overlapping actions).  For  a  template  T ,  the  set  of  durative  actions  GAd is  said  to  be 
pairwise relevant non-overlapping if,  for  every  instance  γ ,  we  can  ﬁnd  a  subset  of  durative  actions  GAd(γ ) ⊇ GAd(wk, γ )
such that the following properties are satisﬁed:

(A) for every  Da1, Da2 ∈ GAd(γ ), one of the following conditions holds true:

(Ai) at least one of the two pairs {a1st, a2st}, {a1inv, a2inv} is either mutex or non executable;
(Aii) the sequence ({a1st, a2st}, {a1inv, a2inv}) is γ -unreachable;
(Aiii) the pairs {a1inv, a2end}, {a1end, a2inv} are mutex and, if  Da1 and  Da2 are not equivalent, the pair {a1end, a2end} is 

either mutex or non executable.

(B) for every  Da1, Da2 ∈ GAd(γ ), one of the following conditions holds true:

(Bi) {a1inv, a2st} is mutex;
(Bii) (a1st, a2st) is GA(γ )irr-unreachable;
(Biii) the pairs {a1inv, a2end}, {a1end, a2inv} are mutex and the pair {a1end, a2end} is either mutex or non executable.

(C) for every  Da1 ∈ GAd(γ ), a2 ∈ GA(γ )rel, one of the following conditions is satisﬁed:

(Ci) {a1inv, a2} is mutex;
(Cii) (a1st, a2) is GA(γ )irr-unreachable;

The next result expresses a suﬃcient condition for the set GAd to be relevant non intertwining.

Proposition 57. Consider a template T . The set GAd is relevant non intertwining if the following conditions are satisﬁed:

(i) for every Da ∈ GAd, ast is strongly safe;
(ii) GAd is pairwise relevant non-overlapping

Proof. For  a  ﬁxed  γ ,  consider  the  set  of  durative  actions  GAd(γ ) as  in  Deﬁnition 56.  Let  Da ∈ GAd(γ ) and  consider  a 
γ -reachable  Da-admissible sequence

A = ( A1, A2, . . . , An−1, An)

(cid:7) st} and  {ainv, a

(cid:7) st ∈ A1.  We  now  show  that  Da and  Da

(cid:7) inv} are  non-interfering  and  executable.  We  now  show  that  ({ast, a

(cid:7) (cid:14)=
such that  A1 ⊆ GAst(γ ). We ﬁrst show that property (i) in Deﬁnition 52 holds true. Assume, by contradiction, that  Da
(cid:7)
violate  property  A  in  the  above  deﬁnition.  Indeed,  since  A
Da is  such  that  a
(cid:7) inv}) is 
(cid:7) st}, {ainv, a
is  admissible,  {ast, a
γ -reachable. Note ﬁrst that ( A1, A2) is clearly γ -reachable. By assumption (ii),  ˜A1 = A1 \ {ast, a
(cid:7) st} only consists of strongly 
γ -safe actions. Consider  ˜A = ( ˜A1, {ast, a
(cid:7) st}, A2). Notice that if (s0, s1, s2) ∈ S( A1, A2)(γ ), then (s0, ˜s1, s1, s2) ∈ S ˜A(γ ) for some 
(cid:7) st}, A2) is also γ -reachable since (˜s1, s1, s2) ∈ SB. Considering that 
˜s1 such that  w(γ , ˜s1) ≤ 1. This implies that B = ({ast, a
(cid:7) inv}) is γ -reachable. Finally, note that 
A2 only consists of invariants, by (i) of Proposition 32, we have that ({ast, a
can either appear in  Ak for some k < n, or appear in  An, or not appear in the 
the end fragment of the durative action  Da
ends (in the plan of which  A is a subsequence) after the end of  Da. In the ﬁrst and 
sequence as the durative action  Da
(cid:7) end}, is 
the third case we have, respectively, that {ainv , a
either  mutex  or  non  executable.  Note  that  this  second  case  can  only  happen  when  Da and  Da
are  not  equivalent  (they 
must differ in at least a fragment by the standing assumption made on simple plans). This shows that also (Aiii) does not 
hold. Therefore GAst(γ ) = {ast}. This proves (i) in Deﬁnition 52.

(cid:7) inv } is non-interfering. In the second case, {aend, a

(cid:7) end} or {aend, a

(cid:7) st}, {ainv, a

(cid:7)

(cid:7)

(cid:7)

(cid:7) ∈ GAd(γ ) such that a

Suppose now that (ii) in Deﬁnition 52 does not hold true for  A. Let  j > 1 be the ﬁrst index for which (ii) is violated, 
(cid:7) < j. The pair 
(cid:7) st ∈ A j while  A j
(cid:7) st} is non-interfering by Deﬁnition 41 of an admissible sequence. Moreover, arguing as in the previous case above 
, we conclude that either one of the pairs {a1inv , a2end}, {a1end, a2inv }
(cid:7) st})
(cid:7) (cid:2) GA(γ )irr. Let 
(cid:7) < j such that  A j
(cid:7) ∩ (GAst(γ ) ∪ GAend(γ )) = ∅, there must exist b ∈
(cid:7)−1, {b}) is γ -reachable and by construction 
(cid:7) − 1, property (C) in Deﬁnition 56 is violated. Therefore this proves (ii) in Deﬁnition 52.

namely for which we can ﬁnd  Da
{ainv, a
regarding the timing of the end fragments of Da and Da
must be non-interfering or the pair {a1end, a2end} must be non-interfering and executable. Since ({ast}, A2, . . . , A j−1, {a
is γ -reachable, it follows from assumption B in Deﬁnition 56 that there must exist 0 < j
(cid:7)
j
A j
Ah ⊆ GA(γ )irr for every h = 2, . . . , j

be the ﬁrst index for which this happens. Since, by construction,  A j
(cid:7) ∩ ∈ GA(γ )rel. Clearly, {ainv, b} is non interfering and since ({ast}, A2, . . . , A j

(cid:7) ∩ GAend(γ ) = ∅ for every  0 < j

(cid:7)

30

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Suppose now that  A j ∩ (GAst(γ ) ∪ GAend(γ )) = ∅ for every  j = 2, . . . , n − 1. If (iii) in Deﬁnition 52 does not hold true 
is  not  γ -irrelevant,  and  let  b ∈ A j be 
for A,  consider  j > 1 to  be  the  ﬁrst  index  for  which  (iii)  is  violated,  namely  A j
any action which is not γ -irrelevant. Clearly, b ∈ GA(γ )rel and, arguing as above, we deduce that  Da and b again violate 
property (C). The proof is thus complete. (cid:2)

Based on the previous results, we conclude with a simple suﬃcient condition for the invariance, which is very useful in 

analysing concrete cases.

Corollary 58. Consider a template T and suppose that, for every instance γ ,

• every Da ∈ GAd(wk, γ ) is such that Da∗ is weakly γ -safe of type (a);
• every a ∈ GA \ (GAst(wk, γ ) ∪ GAend(wk, γ )) is either γ -irrelevant or γ -balanced.

Then, T is invariant.

Proof. It is clear that condition (i) and (ii) of Theorem 53 are satisﬁed. In order to check that GAd is relevant non intertwin-
ing, we show that the properties (i) and (ii) of Proposition 57 are satisﬁed. Fix any instance γ . Note that the assumption that 
∗st and ast are irrelevant and thus strongly γ -safe. Therefore 
Da∗ is weakly γ -safe of type (a) implies, in particular, that a
property  (i)  is  satisﬁed.  We  now  show  that,  choosing  GAd(γ ) = GAd(wk, γ ),  properties  (A),  (B),  and  (C)  of  the  pairwise 
relevant non overlapping property are satisﬁed

Consider  Da1, Da2 ∈ GAd(wk, γ ).  It  follows  from  the  fact  that  Da1

∗ and  Da2

∗ are  both  weakly  γ -safe  of  type  (a)  (see 

Remark 47) that

Pre

+
ai st
γ

= {qi} ⊆ Eff

−
ai st
γ

, i = 1, 2

(16)

If  a1 st and  a2 st are  non-interfering,  it  follows  that  q1 (cid:14)= q2 and,  in  this  case,  {a1 st, a2 st} is  γ -unreachable.  This  proves 
property  (A).  In  order  to  prove  (B),  we  go  back  to  (16) and  we  consider  two  possible  cases.  If  q1 = q2 we  have  that 
+
q1 ∈ (cid:8)
that is γ -irrelevant. This implies that condition (ii) of 
a(cid:7)(cid:7) for any a
Deﬁnition 54 is satisﬁed. If instead q1 (cid:14)= q2, we have that condition (iii) of Deﬁnition 54 is instead satisﬁed. In any case this 
says that the pair (a1 st, a2 st) is GA(wk, γ )irr-unreachable. This proves (B). Finally (C) can be proven exactly like (B). (cid:2)

a2 st and, since q1 ∈ γ (T ), for sure q1 /∈ Eff

+
∩ Pre

−
a1 st

(cid:7)(cid:7)

Our results have a broader application than the case in Corollary 58 as shown in the following example.

Example 13. Consider a domain with two durative actions  Da1 and  Da2 (shown in Fig. 10) and a template T with just an 
(cid:7)}.  Da1 is strongly γ -safe, while  Da2 is weakly γ -safe of type (a). Note that Corollary 58
instance γ such that γ (T ) = {q, q
cannot be applied since a1end is γ -bounded. Indeed, the template is not invariant: Fig. 10 shows a triple intertwinement of 
two copies of  Da1 and  Da2 that leads to a sequence that is not individually γ -safe. This sequence can certainly be thought 
of as the happening sequence of an executable simple plan. Consequently, T is not invariant.

If  we  modify  the  durative  action  Da1 adding  an  over  all  condition  Prea1inv = {q},  the  intertwining  proposed  would  no 
longer be an admissible sequence. Even if Corollary 58 can still not be applied, we now show that, with this modiﬁcation, 
the set GAd = {Da1, Da2} is pairwise relevant non overlapping. To show this, we ﬁx GAd(γ ) = {Da1, Da2} in Deﬁnition 56. 
Conditions (A) and (B) must be checked for any ordered pair of durative actions.  In our case, there are four possibilities: 
two  identical  copies  of  Da1 or  of  Da2,  the  pair  Da1, Da2 or  the  pair  Da2, Da1.  Note  that  if  we  pick  two  copies  of  Da1, 
conditions (Aiii) and (Biii) hold true because of the over all condition. If we pick two copies of Da2 , (Ai) holds true. Moreover, 
considering that GA(γ )irr = ∅, it follows that the pair (a2st, a2st) is GA(γ )irr-unreachable (condition (ii) in Deﬁnition 54 is 
satisﬁed).  Therefore  two  copies  of  Da2 satisfy  condition  (Bii).  Finally,  if  we  consider  the  pair  Da1, Da2 or  Da2, Da1,  we 
(cid:7)} so  that  {a1st, a2st} is  γ -unreachable  and  thus  (Aii)  is  satisﬁed.  Using  again  condition  (ii)  in 
have  that  Pre
Deﬁnition 54 we  can  check  that  both  pairs  (a1st, a2st) and  (a2st, a1st) are  GA(γ )irr-unreachable,  so  that  (Bii)  holds  true. 
Finally,  note  that  condition  (C)  is  empty  in  our  case  since  GA(γ )rel = ∅.  Thanks  to  Proposition 57 and  Theorem 53,  we 
conclude that T is invariant.

+
a1st,a2st

= {q, q

7.  Safety of action schemas for a template

In Section 6, we presented results that guaranteed the invariance of a template: Theorems 51 and 53 and Corollary 58. 
To be applied, we need to check that all instantaneous and durative actions satisfy a safety condition as well as other extra 
properties, which prevent potentially dangerous simultaneous happenings or intertwinements among actions. Since we aim 
to ﬁnd invariants off-line quickly and eﬃciently, our algorithm does not work at the level of actions. Instead, it reasons at 
the lifted level and uses the structure of the action schemas, i.e. their conditions and effects, to decide whether the ground 
instantiations of these schemas are safe or not. Our main goal in this section is to obtain lifted versions of Theorems 51 and 
53 and Corollary 58.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

31

Fig. 10. A triple intertwinement of two copies of the action schemas Da1 and Da2 leads to a sequence that is not individually γ -safe. See Example 13.

In  this  section  and  in  the  following  sections,  we  make  an  important  assumption  about  the  groundings  of  the  action 
schemas. Precisely, for any action schema α, instantaneous or durative, we always assume that the grounding functions we 
consider  gr : V α → O are injective. This restriction plays a crucial role in the formulations of our results and, on the other 
hand, does not essentially entail any loss of generality, if we allow a suitable modiﬁcation of the domain’s action schemas. 
First, we observe that, for many domains, injectivity follows automatically from type restrictions and explicit constraints (i.e. 
given two variables x1 and x2 of an action α, the preconditions of α contain the requirement x1 (cid:14)= x2). If there are variables 
that can be bound to the same value, we can proceed as follows. Given a subset of variables  W ⊆ V , we deﬁne the action 
schema α W by substituting any variable w ∈ W with an amalgamated symbol [W ] in all the formulas of α. For example, if 
we have an action schema move(rbt, loc1, loc2), we create an additional schema moveSame(rbt, loc). The set of free 
variables of the new action schema α W is thus  V α W = (V α \ W ) ∪ {[W ]}. Note how an injective grounding for α W corre-
sponds to a grounding  gr of α such that  gr(w 1) = gr(w 2) for every  w 1, w 2 ∈ W while injectivity is otherwise maintained, 
namely,  gr(v 1) (cid:14)= gr(v 2) if {v 1, v 2} (cid:2) W . Adding all action schemas α W , as  W varies among all possible subsets of  V α , is 
equivalent to considering all possible grounding functions for the original action schema α. This procedure potentially leads 
to an exponential increase (in the cardinality |V α|) of the number of action schemas. However, in practical applications, the 
possibility of non-injectivity is typically limited to a few variables, and so the procedure leads to a controlled growth of the 
number of schemas and, consequently, of the computation complexity.

Following assumption (2) concerning singleton actions and sets of actions, we assume that any action schema satisﬁes 

the condition:

Pre

+
α

−
∩ Pre
α

= ∅

(17)

Note  that  conditions  (17) together  with  the  injectivity  constraint  for  groundings  automatically  imply  that  any  grounded 
action a = gr(α) satisﬁes the condition (2).

∗ = gr
In general, we call liftable a property P of ground actions if, given an action schema α, if one instantiation a
satisﬁes P, then all instantiations a = gr(α) satisfy P. In this case, we say that the action schema α satisﬁes property P.

∗(α)

The  results  presented  in  this  and  the  next  sections  achieve  two  main  goals.  On  the  one  hand,  they  show  that  the 
properties  of  safety  introduced  for  instantaneous  and  durative  actions  in  Sections 4 and  5 are  liftable  as  well  as  the  non 
intertwining properties, even if in a weaker sense, behind the formulation of Theorems 51 and 53. On the other hand, they 
will give eﬃcient characterisations of such properties at the lifted level, which we use in our algorithmic implementation 
(see Section 9).

In the remaining part of this section, we analyse action schemas and their ground instantiations. We show that strong 
safety is liftable and work out a complete characterisation of this property at the lifted level. The next section is devoted to 
lifting properties for durative actions.

32

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

7.1.  Structure and properties of action schemas

We  start  with  the  following  deﬁnition  that  introduces  the  key  concept  of  matching.  It  couples  an  action  schema  to  a 
template and allows us to understand if, in the ground world, a ground formula appearing in an action schema is or is not 
in γ (T ).

Deﬁnition 59 (Matching). Consider a template T = (C, FC) and an action schema α ∈ A. A formula l that appears in α is 
said to match T via the template’s component c = (cid:9)r/k, p(cid:10) ∈ C if:

(i) Rel[l] = (cid:9)r/k(cid:10); and
(ii) if l is universally quantiﬁed, VarQ[l] = {p}.

Given two formulas l and l

(cid:7)

in α, we say that they are T -coupled (and we write l ∼T l

(cid:7)

) if:

(cid:7)
(a) l and l
(b) if (c, i) ∼FC (c

(cid:7), j), Var[l, i] = Var[l

(cid:7), j].

individually match T via the components c and c

(cid:7)

; and

We now ﬁx a template T and an action schema α and study the properties of the relation ∼T on the literals of α that 

match T , introduced above. First, we have the following simple result.

Proposition 60. For a template T = (C, FC) and an action schema α, ∼T is an equivalence relation.

Proof. Reﬂexivity  and  symmetry  are  obvious  from  the  deﬁnition.  Regarding  transitivity,  assume  that  l1, l2, l3 are  three 
formulas  in α matching  T through  the  components  c1, c2, c3 respectively,  such  that l1 ∼T l2 and l2 ∼T l3.  Suppose  that 
(c1, i) ∈ F c1 and  (c3, j) ∈ F c3 are  such  that  (c1, i) ∼FC (c3, j).  The  fact  that  FC is  an  admissible  partition  implies  that 
there  exists  (c2, h) ∈ F c2 such  that  (c1, i) ∼FC (c2, h) ∼FC (c3, j).  The  assumptions l1 ∼T l2 and l2 ∼T l3 yield  Var[l1, i] =
Var[l2, h] = Var[l3, j]. This shows that l1 ∼T l3. (cid:2)

Deﬁnition 61 (T -class). For a template T = (C, FC) and an action schema α, an equivalence class of literals with respect to 
∼T is called a T -class.

We now derive a more concrete description of the concept of matching.

Remark 62. Suppose that l is a formula in the action schema α that matches the template T via the component c = (cid:9)r/k, p(cid:10). 
The possible structure of l is shown below:

p = k, l = r(v 0, . . . , vk−1), ∀i v i ∈ V α
p < k, l = r(v 0, . . . , vk−1), ∀i v i ∈ V α
p < k, l = (∀v p : r(v 0, . . . , vk−1)), ∀i (cid:14)= p v i ∈ V α

(18)

Suppose now that l1 and l2 are two formulas in the action schema α that match the template T via c1 = (cid:9)r1/k1, p1(cid:10) and 
c2 = (cid:9)r2/k2, p2(cid:10), respectively. We can represent, for i = 1, 2, li = ri(v i
)) if  pi < ki ). 
The T coupling condition l1 ∼T l2 is equivalent to requiring that for any pair of ﬁxed variables (c1, j) ∈ F c1 and (c2, h) ∈ F c2 , 
the following holds:

) (or li = (∀v pi : ri(v i

0, . . . v i

0, . . . v i

ki −1

ki −1

(c1, j) ∼FC (c2, h) ⇒ v 1
j

= v 2
h

(19)

We now consider a grounding function  gr for α and an instance γ for T . If l is a formula in α that matches T via the 

component c = (cid:9)r/k, p(cid:10), depending on the structure of l, as illustrated in (18), we have that

l = r(v 0, . . . , vk−1),
l = (∀v p : r(v 0, . . . , vk−1)), gr(l) = {r(x0, . . . , xk−1) | xp ∈ O, xi = gr(v i) ∀i (cid:14)= p}

gr(l) = {r(x0, . . . , xk−1) | xi = gr(v i) ∀i}

(20)

Considering the deﬁnition of γ (T ) in (3) and the fact that the quantiﬁed case above can only appear when p < k, it follows 
that  gr(l) is either a subset of γ (T ) or it must have empty intersection with γ (T ). This motivates the following deﬁnition:

Deﬁnition 63 (Coherence).  gr and γ are coherent over l if  gr(l) ⊆ γ (T ).

Referring to the representation (20), coherence can be equivalently expressed as

gr(v j) = γ (c, j), ∀ j (cid:14)= p

(21)

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

33

The following result is immediate from the conditions (21):

Proposition 64. Consider a template T = (C, FC) and an action schema α. Let l be a formula in the action schema α that matches 
T . Then, for every grounding function gr of α, it is possible to ﬁnd an instance γ of T such that gr and γ are coherent over l and vice 
versa.

The following result explains how coherence interacts with the equivalence relation ∼T .

Lemma 65. Consider a template T = (C, FC) with an instance γ and an action schema α with a grounding gr. Assume that gr and 
γ are coherent over a formula l1 in α and let l2 be another formula in α that matches T . Then, gr and γ are coherent over l2 if and 
only if l2 ∼T l1.

Proof. We  assume  that  for  i = 1, 2,  li matches  T through  components  ci = (cid:9)ri/ki, pi(cid:10).  We  now  represent  each  li as  in 
Remark 62:

li = ri(v i

0, . . . v i

ki −1

) or li = (∀v pi : ri(v i

0, . . . v i

ki −1

))

The fact that  gr and γ are coherent over l1 yields

gr(v 1

j ) = γ (c1, j), ∀ j (cid:14)= p1

(22)

Suppose now that l2 ∼T l1 and consider any ﬁxed variable (c2, h) of  c2 for some h ∈ {0, . . . , k2 − 1} \ {p2}. From the fact 
that FC is an admissible partition, it follows that we can ﬁnd a ﬁxed variable (c1, j) of c1 such that (c1, j) ∼FC (c2, h). The 
T coupling condition (19) implies that v 1
j

h. This yields, using (22) and the fact that γ is an instance

= v 2

gr(v 2

h) = gr(v 1

j ) = γ (c1, j) = γ (c2, h)

We have thus proven that

gr(v 2

h) = γ (c2, h), ∀h (cid:14)= p2

(23)

On  the  other  hand,  assume  now  that  gr and  γ are  coherent  over  l2 and  pick  any  ﬁxed  variables  (c1, j) and  (c2, h)
of c1 and c2 respectively such that (c1, j) ∼FC (c2, h). Using the deﬁnition of an instance and equations (22) and (23), we 
h. This shows that the T coupling 
obtain that  gr(v 2
condition (19) expressed in Remark 62 holds true. Therefore, l2 ∼T l1. (cid:2)

j ). The standing assumption that  gr is injective yields  v 1

h) = gr(v 1

= v 2

j

The following result immediately follows from the deﬁnition of coherence and Lemma 65.

Proposition 66. Suppose that M is a subset of formulas appearing in α. Then, gr(M) ∩ γ (T ) = gr(M ∩ L) where L is the T -class of 
formulas of α on which gr and γ are coherent.

Proposition 66 has  an  important  practical  consequence.  Once  gr and  γ have  been  ﬁxed,  only  the  part  of  α made  of 
formulas in the class L where gr and γ are coherent affect the part of state dynamics concerning the set γ (T ). Precisely, if 
a = gr(α), it follows from the deﬁnition of aγ (see Remark 15) that:

Pre

±
aγ

±
= gr(Pre
α

∩ L),

Eff

±
aγ

= gr(Eff

±
α

∩ L)

Considering that, by Proposition 16, a is strongly γ -safe if and only if aγ is also strongly γ -safe, the property of strong safety 
of an action schema α does not depend on the formulas in α that do not match T . Hence, in principle, such a property 
should be analysed by studying the restrictions of α to the different T -classes L of matching formulas. This intuition leads 
to the following deﬁnition.

Deﬁnition 67 (Pure action schemas). Considering a template T , an action schema α and a T -class  L of formulas in α, we 
deﬁne αL to be the action schema where we only consider formulas belonging to L. More precisely, αL is the action schema 
such that

Pre

±
αL

= Pre

±
αL
We call αL a pure action schema.

∩ L,

±
α

Eff

= Eff

±
α

∩ L

34

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Example 14  (Floortile domain).  Consider  the  template  T f t
{robotAt(r,x), clear(y)}, Eff

= {clear(y)}.

−
α

+
in  Example 2 and  the  action  schema  α = paintUpst:  Pre
α

=

Note  that  both  formulas robotAt(r,x) and clear(y) in  α match  T f t and  form  two  different  T -classes  because 

they do not satisfy condition (ii) in Deﬁnition 59: L1 = {robotAt(r,x)} and L2 = {clear(y)}.

Consider the instance γ1 that associates tile1 to each ﬁxed variable in the components of T f t and grounding function 

gr(r) = rbt1,  gr(x) = tile1 and  gr(y) = tile2. In this case,  gr and γ1 are coherent on the T -class L1.

+
We  have  two  pure  action  schemas  corresponding  to  α:  αL1 and  αL2 .  αL1 has  the  following  speciﬁcation:  Pre
αL1

=

+
{robotAt(r, x)} and αL2 : Pre
αL2

−
= {clear(y)}, Eff
αL2

= {clear(y)}.

7.2.  Pure action schema classiﬁcation

We now carry on a detailed analysis of pure action schemas, showing in particular how the check for strong safety for 

an action a = gr(α) can be eﬃciently performed at the lifted level working with the different pure action schemas αL .

We  ﬁx  an  action  schema  α and  a  T -class  L of  its  formulas.  First,  we  introduce  a  concept  of  weight  at  the  level  of 
formulas  in  L that  allows  us  to  distinguish  between  simple  and  universally  quantiﬁed  formulas.  Precisely,  given l ∈ L,  we 
deﬁne  wl = 1 if  l is  simple,  and  wl = ω if  l is  universally  quantiﬁed,  where  ω = |O|.  For  a  subset  A ⊆ L,  we  deﬁne 
l∈ A wl. Note that w(·) is simply cardinality when all formulas in L are simple. If we consider a grounding function 
w( A) =
gr for α, then for every subset  A ⊆ L, the following holds:

(cid:11)

|gr( A)| = w( A)

(24)
Similarly, if c is a component of T , we deﬁne wc equal to 1 or to ω if c, respectively, does not have or does have a counted 
variable.

We also need one additional concept:

Deﬁnition 68 (Coverage). Consider a component c ∈ T . We let  Lc be the subset of formulas in  L that match T through the 
component c. A subset of formulas  M ⊆ L is said to cover the component c, if  w(M ∩ Lc) = wc .  M is said to cover T , if  M
covers every component c ∈ T .

Remark 69. If we consider a component c ∈ T , all ground atoms generated by c are in  gr(M) if and only if  M covers c. In 
particular, γ (T ) = gr(M) if and only if M covers T .

We  now  give  a  classiﬁcation  of  the  pure  action  schemas  αL ,  formally  analogous  to  that  introduced  for  action  sets  in 
Deﬁnitions 17 and 19: we simply replace preconditions and effects of aγ with those of αL and the concept of cardinality 
with that of weight.

Deﬁnition 70 (Classiﬁcation of pure action schemas). The pure action schema αL is:

+
• unreachable for T if  w(Pre
) ≥ 2;
αL
+
• heavy for T if  w(Pre
) ≤ 1 and  w(Eff
αL
+
• irrelevant for T if  w(Pre
) ≤ 1 and  w(Eff
αL
+
+
• relevant for T if  w(Pre
) ≤ 1 and  w(Eff
αL
αL

+
αL

) ≥ 2;
+
) = 0;
αL
) = 1.

Deﬁnition 71 (Classiﬁcation of relevant action schemas). The pure relevant action schema αL is weighty when it has a single 
+
relevant precondition:  w(Pre
αL

) = 1. A is weightless if  w(Pre

) = 0.

+
αL

A weighty action schema αL is either:

+
• balanced for T if Pre
⊆ Eff
αL
+
• unbalanced for T if Pre
αL

+
αL
∩ (Eff

−
;
αL
∪ Eff

∪ Eff
+
αL

−
αL

) = ∅;

A weightless action schema αL is either:

• bounded for T if L covers T ;
• unbounded for T if L does not cover T .

The following result clariﬁes the relation with the corresponding grounded actions.

Proposition 72. Consider an action schema α, a T -class L of its formulas, a grounding function gr and an instance γ coherent over L. 
Let a = gr(α). Then, αL satisﬁes a property expressed in Deﬁnitions 70 and 71 if and only if a satisﬁes the corresponding γ -property 
as deﬁned in Deﬁnitions 17 and 19.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

35

Proof. An immediate consequence of the fact that aγ = gr(αL), of Equation (24), and of Remark 69. (cid:2)

We are now ready to give the following ﬁnal result concerning strong safety of general action schemas. It shows how 

strong safety can be seen as a property of an action schema and can be interpreted by analysing its pure parts.

Corollary 73. Strong safety is a liftable property. Moreover, an action schema α is strongly safe if and only if, for every T -class of 
formulas L of α, αL is unreachable, irrelevant, balanced or bounded.

Proof. Suppose that a = gr(α) for some  gr and let γ be an instance. Then, aγ = gr(αL) where  L is the T -class on which 
gr and γ are coherent. The result is now a straightforward consequence of Proposition 72 and Corollary 21. (cid:2)

Example 15 (Floortile domain). Consider the template T f t and the action schema α = paintUpst in Example 14. The two 
pure action schemas αL1 and αL2 are both irrelevant and hence strongly safe. Hence, α is strongly safe.

Now consider the action schema α(cid:7) = paintUpend with speciﬁcation: Eff

+

α(cid:7) = {painted(y, c)}. This is a pure action 

schema. It is unbounded and thus not strongly safe.

An immediate consequence of Corollary 23 is:

Corollary 74. Given a template T , T is invariant if for each α ∈ A, α is strongly safe.

8.  Durative action schemas

Our  goal  now  is  to  work  out  proper  lifted  versions  of  the  properties  of  durative  actions  presented  in  Section 5,  in 
particular those involved in the statement of our main results, Theorems 51 and 53. Some of these properties concern just 
one  durative  action  (e.g.  safety),  while  others  involve  more  actions  (e.g.  non-interfering,  irrelevant-unreachable).  We  start 
analysing the ﬁrst type of properties, presenting, in particular, an explicit characterisation of safety for durative actions at 
the lifted level.

We use the following notation. Take a durative action schema Dα = (αst, αinv, αend) and a grounding function gr for Dα. 

We let  Da = gr(Dα), where  Da = (ast, ainv, aend) with ast = gr(αst), ainv = gr(αinv), and aend = gr(αend).

Our ﬁrst goal is to lift the assumptions (8) and (9) on durative actions. First deﬁne, for a generic action schema α, the 

subsets of postconditions:

+
(cid:8)
α

+
= (Pre
α

\ Eff

−
α ) ∪ Eff

+
−
α , (cid:8)
α

= (Pre

−
α

\ Eff

+
α ) ∪ Eff

−
α

We will make the standing assumption that every durative action schema  Dα = (αst, αinv, αend) satisﬁes the relations

(cid:8)

∩ Pre

+
αst
+
αend

−
−
= ∅, (cid:8)
αst
αinv
−
∩ Pre
αinv

= ∅,

+
∩ Pre
αinv
+
∩ Pre
αend

Pre

Pre

= ∅

−
α+inv

= ∅

(25)

(26)

Since,  we  recall,  grounding  functions  must  be  injective,  (25) and  (26) are  equivalent  to  requiring  that  any  grounding 

function  Da = gr(Dα) satisﬁes conditions (8) and (9).

Also, we deﬁne the auxiliary durative action schema  Dα∗ = (αst

∗ , αend
∗

) where αst

∗ and αend

∗

are the action schema such 

that:

Eff

Eff

±
αst∗
±
αend∗

= Eff

= Eff

Pre

±
αst ,
±
αend , Pre

±
αst∗
±
αend∗

= Pre

±
αst
±
= Pre
αend

∪ (Pre

±
αinv
±
∪ Pre
αinv

\ Eff

±
αst )

Da∗ = gr(Dα∗) is the corresponding auxiliary action previously deﬁned in Section 5.2.

8.1.  Safety of durative action schemas

We  now  ﬁx  a  template  T and  start  to  analyse  safety.  We  consider  a  durative  action  schema  Dα,  its  auxiliary  action 
schema  Dα∗ and  its  groundings  Da = gr(Dα) and  Da∗ = gr(Dα∗).  Strong  safety  for  durative  actions  reduces  to  strong 
safety of its components and it is thus a liftable property. As a consequence, we can talk about the strong safety of  Dα or 
Dα∗:  this  is  equivalent  to  the  strong  safety  of  all  its  groundings,  Da = gr(Dα) or,  respectively,  Da∗ = gr(Dα∗).  Checking 
such a property at the lifted level can be done by applying Corollary 73 to the start and end fragments.

We now want to characterise simple safety of the auxiliary durative action  Da∗ = gr(Dα∗) at the lifted level. First we 

consider executability.

36

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Proposition 75. Executability of auxiliary durative actions is a lifted property. Precisely, Dα∗ is executable if and only if

(cid:8)

+
αst∗

−
∩ Pre
αend∗

−
= ∅ = (cid:8)
αst∗

∩ Pre

+
αend∗

Proof. An immediate consequence of Proposition 30. (cid:2)

(27)

Assume  now  that  Dα∗ is  executable.  Fix  a  grounding  gr and  let  Da∗ = gr(Dα∗).  Consider  an  instance  γ and  let  L
be  the  T -class  of  formulas  in  Dα on  which  gr and  γ are  coherent.  Let  DαL = (αst
∗L, αend
∗L ). 
Note that  Da∗γ = gr(Dα∗L). Therefore, since simple γ -safety of  Da∗ only depends on  Da∗γ (since executability has already 
been assumed), we expect that such a property can be formulated in terms of the pure auxiliary durative action schema 
Dα∗L . To this aim, we now give, for such durative action schemas, the same classiﬁcation introduced for durative actions in 
Deﬁnition 48. First, we need a further concept:

) and  Dα∗L = (αst

L , αinv

, αend
L

L

Deﬁnition 76 (Reachable action schemas).  Dα∗L is said to be reachable if it is executable and

w(Pre

+
αst
∗L

∪ (Pre

+
αend
∗L

\ Eff

+
αst
∗L

)) ≤ 1

Proposition 77. If  gr and γ are coherent over L and  Da∗ = gr(Dα∗), we have that  Da∗γ is γ -reachable if and only if  Dα∗L is 
reachable.

Proof. An immediate consequence of Propositions 31 and 66 and of equation (24). (cid:2)

Deﬁnition 78 (Safe durative action schemas). When  Dα∗L is such that

(i) Dα∗L is reachable;
(ii) αst
∗L is strongly safe;
(iii) αend
is unbounded;
∗L
(iv) Dα∗L satisﬁes any of the conditions below:

(a) αst
(b) αst
(c) αst
(d) αst

+
∗L irrelevant,  w(Pre
αst
∗L
+
∗L irrelevant,  w(Pre
αst
∗L
+
∗L irrelevant,  w(Pre
αst
∗L
⊆ Effαend
∗L relevant, Eff

+
) = 1, Pre
αst
∗L
+
) = 1, Pre
αst
∗L
−
) = 0, Pre
αst
∗L

.

L

+
αst
L

−
⊆ Eff
αst
∗L
−
(cid:2) Eff
αst
∗L
−
∪ Eff
αst
∗L

;

+
, Pre
αst
∗L
∪ Effαend

L

;

⊆ Effαend
covers T ;

L

We say that  Dα∗L is weakly safe of type (x) where x ∈ {a, b, c, d}.

Corollary 79. Safety for durative auxiliary actions is a liftable property. Da∗ = gr(Dα∗) is safe if and only if:

• Dα∗ is executable;
• For every T -class L of formulas in Dα, one of the following conditions hold:

– Dα∗L is strongly safe;
– αst
∗L is strongly safe and Dα∗L is unreachable;
– Dα∗L is weakly safe of type (x) where x ∈ {a, b, c, d}.

Proof. An immediate consequence of previous deﬁnitions and Proposition 46. (cid:2)

Example 16 (Floortiledomain). Consider our usual template:

T f t = ({(cid:9)robotAt/2, 0(cid:10), (cid:9)painted/2, 1(cid:10), (cid:9)clear/1, 1(cid:10)}

and the action schema:

Dα = paintUp : (paintUpst, paintUpinv, paintUpend)

where the single instantaneous action schemas have the speciﬁcations shown in Table 4.

In this action schema, we have three formulas that match T f t : robotAt(r,x), clear(y) and painted(y,c). They 
is 

form two T -classes: L1 = {robotAt(r,x)} and L2 = {clear(y), painted(y,c)}. Note that in this case paintUpst
Li
equal to paintUpst
∗Li

for i = 1, 2 and the same holds for paintUpend

Li

.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

37

Table 4
Durative action schema paintUp (abbreviated speciﬁcation). See Example 16.

α

Pre

+
α

Eff
Eff

+
α
−
α

paintUpst
{robotAt(r, x)
clear(y)}
∅
{clear(y)}

paintUpinv
{robot − has(r, c)
up(y, x)}
∅
∅

paintUpend

∅

{painted(y, c)}
∅

The pure action schemas paintUpst
L1
is unbounded.

pure schema paintUpend
L2

, paintUpst
L2

and paintUpend
L1

are strongly safe because they are irrelevant. The 

The  pure  durative  action  schema  paintUpL1 is  strongly  safe  because  paintUpst
L1

and  paintUpend
L1

are  strongly  safe 

since they are irrelevant.

The pure schema paintUpL2 is weakly safe of type (a) since:

• paintUpL2 is reachable because paintUpst
L2
• paintUpst
L2
• paintUpend
L2
+
• w(Pre
paintUpst
L2
⊆ Eff

is strongly safe since it is irrelevant;
is unbounded;

+
• Pre
paintUpst
L2

−
paintUpst
L2

) = 1 because the preconditions at start consist of clear(y);

because the delete effects at start also contain clear(y).

is reachable and paintUpend
L2

does not contain preconditions;

8.2.  Lifting properties of multiple actions

In  this  section,  we  study  how  properties  that  involve  more  than  one  action  (e.g.  mutex)  can  be  lifted.  This  requires 

working simultaneously with different groundings and, for this reason, additional concepts are needed.

Consider  two  action  schemas  α1 and  α2 (instantaneous  or  durative)  with  sets  of  variables  V α1 and  V α2 ,  respectively. 
Whenever we consider two groundings  gr1 and  gr2 for α1 and α2, respectively, the pairwise properties of the two actions 
ai = gri(αi) (e.g.  properties  regarding  the  sequence  (a1, a2) or  the  set  {a1, a2})  are  non  liftable,  as  in  general  they  may 
depend  on  the  speciﬁc  groundings  chosen.  A  key  aspect  is  the  possible  presence,  in  the  two  action  schemas,  of  pairs  of 
variables  v i ∈ V i f such that  gr1(v 1) = gr2(v 2): this may cause the same ground atom to appear in the two actions a1 and 
a2, which in principle can affect the validity of certain properties, such as non-interference. To cope with this complexity 
at the lifted level, we introduce a concept of reduced union of the two sets  V α1 and  V α2 to be used as a common set of 
variables for the two schemas.

We deﬁne a matching between α1 and α2 as any subset M ⊆ V α1 × V α2 such that:

• If (v 1, v 2), (w 1, v 2) ∈ M, then v 1 = w 1;
• If (v 1, v 2), (v 1, w 2) ∈ M, then v 2 = w 2.

We now deﬁne the set  V α1 (cid:23)M V α2 obtained by  V α1 ∪ V α2 by reducing each pair of variables  v 1 ∈ V α1 and  v 2 ∈ V α2 such 
that (v 1, v 2) ∈ M to a new variable, denoted as  v 1 v 2. Note that in the case when M = ∅, no reduction takes place and 
V α1 (cid:23)∅ V α2 = V α1 ∪ V α2 .

For a matching M, we have natural maps π i

M : V i f → V α1 (cid:23)M V α2 associating to each variable v i , v i itself or the new 
reduced  variable  v i v j in  case  (v i, v j) ∈ M.  The  two  schemas  α1 and  α2 can  thus  be  rewritten  in  this  new  alphabet  by 
formally substituting each variable  v i ∈ V i f
M(li)
the formula obtained with this substitution. Similarly, if  Ai is a set of formulas of αi , we put π i

M(v i). If li is a formula of αi , we denote by π i

in their formulas with π i

For  the  formulas  of  the  two  schemas,  expressed  in  the  common  variable  set  V α1 (cid:23)M V α2 ,  we  can  jointly  apply  set 
theoretic operators. If li is a formula of αi and  Ai is a set of formulas of αi , for i = 1, 2, we will use the notation l1 =M l2
M( A2) where ∗ ∈
for π 1
{∪, ∩, \}.

M( A2). Similarly, we put  A1 ∗M A2 = π 1

M(l2) and l1 ∈M A2 for π 1

M( A1) ∗ π 2

M(l1) = π 2

M(l1) ∈ π 2

M(li) | li ∈ Ai}.

M( Ai) = {π i

We now investigate the relation between matchings and speciﬁc groundings of the two schemas.

Deﬁnition 80  (Coherent grounding functions).  Consider  two  action  schemas  α1 and  α2 and  a  matching M between  them. 
Two grounding functions  gr1 and  gr2 for α1 and α2, respectively, are said to be M-adapted if given v i ∈ V i f for i = 1, 2, it 
holds that  gr1(v 1) = gr2(v 2) if and only if (v 1, v 2) ∈ M.

Remark 81. Note that, for two groundings  gr1 and  gr2, if we consider M = {(v 1, v 2) | gr1(v 1) = gr2(v 2)} we have that M
is a matching (recall that maps  gri are injective) and  gr1 and  gr2 are M-adapted.

Coherent groundings can be factored through the reduced set V α1 (cid:23)M V α2 :

38

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Proposition 82. Consider two action schemas α1 and α2, a matching M between them, and grounding functions gri for αi , i = 1, 2. 
The following conditions are equivalent:

(i) gr1 and gr2 are M-adapted;
(ii) there exists an injective function gr : V α1 (cid:23)M V α2 → O such that, gri = gr ◦ π i

M for i = 1, 2.

Suppose  that  gr1 and  gr2 are  two  M-adapted  groundings  of  α1 and  α2 and  let  gr be  the  function  as  in  (ii)  of  the 

previous proposition. If  Ai is a set of formulas of αi , for i = 1, 2, for any set theoretic operation ∗ ∈ {∪, ∩, \} it holds that:

M( A1)) ∗ gr(π 2

gr1( A1) ∗ gr2( A2) = gr(π 1

M( A2)) = gr( A1 ∗M A2)
This  follows  from  Proposition 82 and  the  fact  that  gr is  injective.  An  iterative  use  of  (28) shows  that  any  set  theoretic 
expression  on  the  two  grounded  actions  gri(αi) is  in  bijection  (through  gr)  with  a  corresponding  expression  on  the  two 
action  schemas  αi expressed  in  the  common  reduced  set  V α1 (cid:23)M V α2 .  As  a  consequence,  any  property  of  actions  (with 
the  standing  assumption  of M-adapted  groundings)  that  can  be  expressed  by  set  theoretic  operations  on  their  formulas 
can be reformulated by rewriting these formulas in the new alphabet  V α1 (cid:23)M V α2 . This is the key observation in order to 
lift properties of pairs of actions. To be more concrete, we consider the example of non-interfering actions, which will be 
needed in what follows.

(28)

Deﬁnition 83 (Mutex simple action schemas). We say that two action schemas α1 and α2 are M non-interfering if for i (cid:14)= j

−

+

(αi) ∩M Eff
Eff
Pre(αi) ∩M Eff(α j) = ∅

(α j) = ∅

If α1 and α2 are not M non-interfering, they are called M-mutex.

Deﬁnition  84  (Executable  action  schemas).  We  say  that  a  set  of  two  M non-interfering action  schemas  {α1, α2} is 
M-executable if for i (cid:14)= j

+

Pre

(αi) ∩M Pre

−

(α j) = ∅ .

Proposition 85. Consider two action schemas α1 and α2, a matching M between them and grounding functions gr1 and gr2 for, 
respectively, α1 and α2, that are M-adapted. Put ai = gri(αi) for i = 1, 2. Then,

(i) α1 and α2 are M-mutex if and only if a1 and a2 are mutex;
(ii) {α1, α2} is M-executable if and only if {a1, a2} is executable.

Proof. An immediate consequence of Deﬁnitions 88 and 84 and of equation (28). (cid:2)

Remark 86. Note that certain properties that depend on the matching M have a monotonic behaviour, i.e. if they are true 
for a matching M, they remain true for a larger matching M(cid:7) ⊇ M. This is the case, for instance, of properties that can be 
expressed in terms of identities between formulas of type l1 =M l2, such as the M-mutex property.

To cope with properties related to a template and its instantiations, it is useful to introduce a family of matchings induced 
by the presence of formulas in the two schemas matching in a template. Precisely, consider now a template T = (C, FC)
and two action schemas α1 and α2. Consider T -classes Li of formulas of αi for i = 1, 2. There is a natural way to associate 
a matching to  L1 and  L2 as follows. Pick formulas li ∈ Li for i = 1, 2 and consider components ci ∈ C such that li matches 
T through ci . Let:

M

L1,L2 = {(Var[l1, j], Var[l2, h]) | (c1, j) ∼FC (c2, h)}

It immediately follows from the deﬁnition of T -coupled pairs of formulas (Deﬁnition 59) that M
the particular formulas li chosen, but only on the T -classes Li .

Essentially, in M

L1,L2 , we are rewriting variables in the formulas of L1 and L2 that correspond to FC -equivalent variables 

in the template T . The next proposition shows the role played by such a matching.

(29)

L1,L2 does not depend on 

Proposition 87. Consider two groundings gr1 and gr2 for α1 and α2, respectively, which are M-adapted. Then the following facts 
hold:

(i) for an instance γ for T , if Li are the T -classes of formulas of αi on which gri and γ are coherent. Then, M
(ii) for T -classes of formulas Li of αi , if M

L1,L2 ⊆ M, there exists just one instance γ of T such that gri and γ are coherent on Li .

L1,L2 ⊆ M;

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

39

Proof. Fix,  for  i = 1, 2,  li ∈ Li .  Assume  that  li matches  T through  components  ci = (cid:9)ri/ki, pi(cid:10) and  represent  li as  in  Re-
mark 62:

li = ri(v i

0, . . . v i

ki −1

) or li = (∀v pi : ri(v i

0, . . . v i

ki −1

))

(i): Let  j (cid:14)= p1 and h (cid:14)= p2 be such that (c1, j) ∼FC (c2, h). The fact that  gri and γ are coherent yields:

gr1(v 1

j ) = γ (c1, j) = γ (c2, h) = gr2(v 2
h)

This implies, by Deﬁnition 80, that (v 1

j , v 2

h) ∈ M. By deﬁnition (29), we thus have M

L1,L2 ⊆ M.

(ii):  Choose  γ in  such  a  way  that  gr1 and  γ are  coherent:  γ (c1, j) = gr1(v 1

j ) for  every  j (cid:14)= p1.  Now  ﬁx  h (cid:14)= p2 and 

choose  j (cid:14)= p1 such that (c1, j) ∼FC (c2, h). Then, since M

L1,L2 ⊆ M,

γ (c2, h) = γ (c1, j) = gr1(v 1

j ) = gr2(v 2
h)

This implies that  gr2 is also coherent with γ . (cid:2)

We are now ready to lift the properties used in Section 6. We start with unreachability for fragments of durative action 

schemas.

Deﬁnition 88  (Unreachable durative action schemas).  Take  two  durative  action  schemas  Dα1,  Dα2 and  the  corresponding 
T -classes of formulas L1 and L2.

1. We say that ({α1inv, α2inv}, {α1end, α2end}) is (L1, L2)-unreachable if at least one of the following conditions is satisﬁed:

2. We say that ({α1st, α2st}, {α1inv, α2inv}) is (L1, L2)-unreachable if at least one of the following conditions is satisﬁed:

∩M
∩M

(i) Pre

(ii) Pre

+
α1inv
−
α1inv
+
(iii) w(Pre
α1end
∗L1

−
L1,L2 Pre
α2end
+
L1,L2 Pre
α2end
+
∪M Pre
α2end
∗L2

(cid:14)= ∅;
(cid:14)= ∅;
) ≥ 2 for every matching M ⊇ M

L1,L2 .

(i) (cid:8)

(ii) (cid:8)

+
α1st
−
α1st

(iii) w(Pre

∩M
∩M
+
α1st
∗L1

−
L1,L2 Pre
α2inv
+
L1,L2 Pre
α2inv
+
∪M Pre
α2st
∗L2

(cid:14)= ∅;
(cid:14)= ∅;
) ≥ 2 for every matching M ⊇ M

L1,L2 .

Note  that  the  check  of  property  (iii)  of  the  above  deﬁnition  in  principle  involves  all  possible  matchings  containing 
L1,L2 . In Section 9.2, we propose an eﬃcient check of this condition that exhibits a computational complexity of polyno-

M
mial order in the number of variables and formulas of the domain.

Proposition 89. Suppose that Dα1, Dα2 are two durative action schemas and gr1, gr2 two corresponding grounding functions. Let 
Dai = gr(Dαi) and consider an instance γ . Let Li be the T -class of formulas of Dαi on which gri and γ are coherent.

• If ({α1inv , α2inv }, {α1end, α2end}) is (L1, L2)-unreachable, then ({a1st, a2st}, {a1inv , a2inv }) is γ -unreachable.
• If ({α1st, α2st}, {α1inv , α2inv }) is (L1, L2)-unreachable, then ({a1st, a2st}, {a1inv , a2inv }) is γ -unreachable.

Proof. We  only  prove  the  ﬁrst  point,  the  second  being  analogous.  Let  M be  the  matching  such  that  gr1 and  gr2 are 
M-adapted. It follows from Proposition 87 that M ⊇ M
L1,L2 . Note that the conditions (i) and (ii) expressed in Deﬁnition 88, 
if true for M
L1,L2 , are also true for the matching M, because of Remark 86. Consequently we know that at least one of the 
conditions (i), (ii), or (iii) expressed in Deﬁnition 88 holds true for such M. It then follows from (28) that at least one of 
the following conditions holds:

(ib) Pre

+
a1inv
−
(iib) Pre
a1inv
+
(iiib) |Pre
a1inv
γ

−
∩ Pre
a2end
+
∩ Pre
a2end
+
∪ Pre
a1end
γ

(cid:14)= ∅;
(cid:14)= ∅;
+
∪ Pre
a2inv
γ

+
∪ Pre
a2end
γ

| ≥ 2.

By virtue of Propositions 30 and 31 this implies that ({a1inv, a2inv}, {a1end, a2end}) is γ -unreachable. (cid:2)

We now give the lifted version of relevant right isolated.

40

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Deﬁnition 90 (Relevant right isolated schemas). For a template T , the set of durative action schemas Ad is said to be relevant 
right isolated if, for every  Dα1, Dα2 ∈ Ad, corresponding T -classes  L1, L2 of formulas of each of them such that  Dαi
Li are 
both not strongly safe, one of the following conditions is satisﬁed (we use the notation M = M

L1,L2 ):

(i) |Eff

∪M Eff

| ≤ 1;

+
α1end
L1

+
α2end
L2

(ii) at least one of the two pairs {α1end, α2end}, {α1inv , α2inv } is either M-mutex or non M-executable;
(iii) ({α1inv , α2inv }, {α1end, α2end}) is (L1, L2)-unreachable.

Proposition 91. For a template T , suppose that the set of durative action schemas Ad is relevant right isolated. Then GAd is also 
relevant right isolated.

Proof. Fix  any  instance  γ and  consider  Da1, Da2 ∈ GAd(wk, γ ).  Let  Dαi and  gri ,  for  i = 1, 2,  be  durative  schemas  and 
groundings  such  that  Dai = gri(Dαi).  Let  Li be  the  T -class  of  formulas  of  each  schema  Dαi such  that  gri and  γ are 
coherent  over  Li for  i = 1, 2.  Therefore,  Dα1 and  Dα2 must  satisfy  one  of  the  conditions  (i)  to  (iii)  in  the  Deﬁnition 90. 
Let  M be  the  matching  to  which  gr1 and  gr2 are  adapted  (in  the  sense  of  Remark 81).  We  know  from  Proposition 87
that  M ⊇ M
L1,L2.  Note  now  that  if  condition  (i)  holds  true,  it  also  holds  true  for  such  larger  M (Remark 86)  and  this 
yields condition (i) of Deﬁnition 50. Similarly, condition (ii) yields the same condition with this new M (Remark 86) from 
which condition (ii) in Deﬁnition 90 follows using Proposition 85. Finally, if condition (iii) holds true, then condition (iii) 
in Deﬁnition 90 follows by using Proposition 89. Therefore, by Deﬁnition 90 we have that the two durative action schemas 
Dα1 and Dα2 must satisfy one of the conditions (i) to (iii) in the deﬁnition. From the fact that gr1 and gr2 are M-adapted, 
it  follows  that  conditions  (i)  of  Deﬁnition 90 yields  condition  (i)  of  Deﬁnition 50.  Condition  (ii)  and  (iii)  in  Deﬁnition 50
ﬁnally follow conditions (ii) and (iii) in Deﬁnition 90 using Propositions 85 and 89. (cid:2)

We are now ready to propose the lifted version of our ﬁrst invariant result Theorem 51.

Corollary 92. Consider a template T and suppose that the set of instantaneous action schemas Ai and that of durative action schemas 
Ad satisfy the following properties:

(i) every α ∈ Ai is strongly safe;
(ii) for every Dα ∈ Ad and every T -class L such that DαL is not strongly safe, Dα∗L is reachable and strongly safe;
(iii) Ad is relevant right isolated.

Then, T is invariant.

In order to lift the remaining results on the invariance of a template, a key point is to lift the fundamental Deﬁnition 56
of pairwise relevant non overlapping. To do this it will be convenient to introduce some compact notation concerning sets 
of action schemas and relative classes. We deﬁne

AdC(T ) = {(Dα, L) | Dα ∈ Ad, L T -class of Dα}
AdC(wk, T ) = {(Dα, L) ∈ AdC(T ), DαL weakly safe}
AC(T ) = {(α, L) | α ∈ A, L T -class of α}

(α, L) and (Dα, L) are called, respectively, schema-class and durative schema-class pairs.
We now propose a lifted version of the property of unreachability expressed in Deﬁnition 54.

Deﬁnition 93 (MC -unreachable schemas). Consider a template T and a subset MC ⊆ AC(T ) such that for every (α, L) ∈ MC , 
αL is  irrelevant.  Consider  a  pair  of  action  schemas  α1, α2 ∈ A and  relative  classes  L1 and  L2,  respectively.  (α1, α2) is 
(MC; L1, L2)-unreachable if any of the following conditions is satisﬁed:

+

−

(i) there exist l1 ∈ (cid:8)

α2 with l1 =M
α1 , l2 ∈ Pre
M between α1 and α for which M ⊇ M
α2 with l1 =M
α1 , l2 ∈ Pre
M between α1 and α for which M ⊇ M

(ii) there exist l1 ∈ (cid:8)

+

−

L1,L2 l2 such that, for every schema-class (α, L) ∈ MC and for every matching 
L1,L , we have that l1 /∈M Eff
L1,L2 l2 such that, for every schema-class (α, L) ∈ MC and for every matching 
L1,L , we have that l1 /∈M Eff
L1,L2 .

+
α ;

−
α ;

(iii) w(Pre

+
α1
L1

+
∪M (Pre
α2
L2

+
α1
L1

\M Eff

)) ≥ 2 for every matching M ⊇ M

Note that the check of all these properties in principle involve all possible matchings containing M

L1,L2 . In Section 9.2, 
we propose an eﬃcient check of this condition that exhibits a computational complexity of polynomial order in the number 
of variables and formulas of the domain.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

41

The following result shows how the notion of unreachability in Deﬁnition 93 is the lifted version of the one expressed 

in Deﬁnition 54.

Proposition 94. Consider a template T and a subset MC ⊆ AC(T ) such that for every (α, L) ∈ MC , αL is irrelevant. Consider a pair 
of action schemas α1, α2 ∈ A and relative groundings gr1 and gr2. Let ai = gr(αi) and consider an instance γ . Let Li be the T -class 
of formulas of αi on which gri and γ are coherent. If (α1, α2) is (MC; L1, L2)-unreachable, then (a1, a2) is M-unreachable where 
M is the set of actions a so obtained. For every (α, L) ∈ MC and grounding gr of α such that gr and γ are coherent over L, we let 
a = gr(α).

L1,L2 . Suppose (i) holds and put q = gr1(l1) = gr2(l2) ∈ (cid:8)1+

Proof. Let M be the matching such that the two groundings  gr1 and  gr2 are M-adapted. By Proposition 87, we have that 
M ⊇ M
a . Consider now any action a ∈ M and let α be 
an action schema such that a = gr(α) for some grounding  gr. Let  L be the T -class of formulas of α on which  gr and γ
˜M between  α1 and  α such  that 
are  coherent.  By  construction,  it  follows  that  (α, L) ∈ MC .  Consider  now  the  matching 
gr1 and  gr are  ˜M-adapted. We have that 
−
+
α , which implies that q /∈ Eff
a . 
This shows that condition (i) of Deﬁnition 54 is satisﬁed. Similarly, one can prove that condition (ii) of Deﬁnition 93 yields 
condition (ii) of Deﬁnition 54. Finally the fact that (iii) of Deﬁnition 93 yields condition (iii) of Deﬁnition 54 follows from a 
repeated application of relation (28). (cid:2)

L1,L . Then, by (i) we have that l1 /∈ ˜M Eff

˜M ⊇ M

∩ Pre2−

a

We are now ready to lift Deﬁnition 56. Given a set of durative actions and classes AdC(T )∗ ⊆ AdC(T ), we put

AstC(T )∗ = {(αst, L) ∈ AC(T ) | (Dα, L) ∈ AdC(T )∗},
AendC(T )∗ = {(αend, L) ∈ AC(T ) | (Dα, L) ∈ AdC(T )∗}
AC(T )∗
irr
AC(T )∗
rel

= {(α, L) ∈ AC(T ) \ (AstC(T )∗ ∪ AendC(T )∗) | αL irrelevant},
= {(α, L) ∈ AC(T ) \ (AstC(T )∗ ∪ AendC(T )∗) | αL relevant}

Deﬁnition 95  (Pairwise relevant non-overlapping action schemas).  For  a  template  T ,  the  set  of  durative  action  schemas  Ad
is said to be pairwise relevant non-overlapping if we can ﬁnd a set of durative schema-class pairs AdC(T )∗ ⊆ AdC(T ) with 
AdC(T )∗ ⊇ AdC(wk, T ) such that the following properties are satisﬁed:

(A) for every (Dα1, L1), (Dα2, L2) ∈ AdC(T )∗

, denoted M = M

L1,L2 , one of the following conditions holds true:

(Ai) at least one of the two pairs {α1st , α2st}, {α1inv , α2inv } is either M-mutex or non M-executable;
(Aii) ({α1st, α2st}, {α1inv , α2inv }) is (L1, L2)-unreachable.
(Aiii) the  pairs  {α1inv , α2end},  {α1end, α2inv } are  M-mutex  and  the  pair  {α1end, α2end} is  either  M-mutex  or  non 

M-executable.

(B) for every (Dα1, L1), (Dα2, L2) ∈ AdC(T )∗

, denoted M = M

L1,L2 , one of the following conditions holds true:

(Bi) {α1inv, α2st} is M-mutex;
(Bii) (α1st, α2st) is (AC(T )∗
(Biii) the  pairs  {α1inv , α2end},  {α1end, α2inv } are  M-mutex  and  the  pair  {α1end, α2end} is  either  M-mutex  or  non 

irr, L1, L2)-unreachable;

, (α2, L2) ∈ AC(T )∗

rel, denoted M = M

L1,L2 , one of the following conditions is satisﬁed:

M-executable.
(C) for every (Dα1, L1) ∈ AdC(T )∗
(Ci) {α1inv, α2} is M-mutex;
(Cii) (α1st, α2) is (AC(T )∗

irr, L1, L2)-unreachable.

Proposition 96. Consider a template T . If the set of durative action schemas Ad is pairwise  relevant  non-overlapping, then the 
corresponding set of durative actions GAd is pairwise relevant non-overlapping.

Proof. Consider  the  set  of durative  action  schemas  and  classes  AdC(T )∗
in  Deﬁnition 95.  Fix  any  instance  γ and  deﬁne 
GAd(γ ) as  the  set  of  durative  actions  Da obtained  as  follows:  for  every  (Dα, L) ∈ AdC(T )∗
consider  the  grounding  gr
of  Dα such  that  gr and  γ are  coherent  over  L and  put  Da = gr(Dα).  We  now  show  that  properties  (A),  (B),  and  (C)  of 
Deﬁnition 56 hold with respect to this choice of GAd(γ ).

To prove (A) and (B) we ﬁx  Da1, Da2 ∈ GAd(γ ). Let  Dαi and  gri , for i = 1, 2, be durative schemas and groundings such 
that  Dai = gr(Dαi). Let  Li be the T -class of formulas of each schema  Dαi such that  gri and γ are coherent over  Li for 
i = 1, 2. By the way GAd(γ ) has been deﬁned above, we have that (Dαi , Li) ∈ AdC(T )∗
. Let M be the matching such that 
gr1 and  gr2 are adapted (in the sense of Remark 81). We know from Proposition 87 that M ⊇ M

L1,L2.

We  know  that  the  two  pairs  (Dαi, Li) satisfy  one  of  the  conditions  (Ai)  to  (Aiii).  Notice  now  that  if  (Ai)  or  (Aiii)  is 
satisﬁed, (Ai) or (Aiii) is also satisﬁed with respect to the larger matching M (Remark 86). Using Proposition 85 we then 
conclude that  Da1, Da2 satisfy the corresponding condition (Ai) or (Aiii) in Deﬁnition 56. Finally, If instead (Dαi, Li) satisfy 
(Aii), then condition (Aii) in Deﬁnition 56 follows for  Da1, Da2 by using Proposition 89. Condition (A) for the pair  Da1, Da2
is thus satisﬁed.

42

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

We now come to condition (B). We know that the pair (Dαi, Li) satisfy one of the conditions (Bi) to (Biii). Arguing as in 
the previous point, we get that if they satisfy either (Bi) or (Biii), then  Da1, Da2 satisfy the corresponding (Bi) or (Biii) in 
Deﬁnition 56. Alternatively, (Bii) for (Dαi, Li) yields (Bii) for  Da1, Da2 as a consequence of Proposition 94.

We ﬁnally consider condition (C). To this aim, we ﬁx  Da1 ∈ GAd(γ ) and a2 ∈ GA(γ )rel. Consider action schema  Dα1 ∈
Ad and α2 ∈ A and corresponding groundings  gri , for i = 1, 2, such that  Da1 = gr1(Dα1) and a2 = gr2(α2). Let  Li be the 
T -class  of  formulas  of  each  schema  such  that  gri and γ are  coherent  over  Li for  i = 1, 2.  By  the  way  GAd(γ ) has  been 
deﬁned above, we have that (Dα1, L1) ∈ AdC(T )∗
rel. We thus have that  Dα1 and α2 must satisfy 
one  of  the  two  properties  (Ci)  or  (Cii).  Arguing  as  in  the  previous  points  we  obtain  that  these  two  properties  imply  the 
corresponding one (Ci) or (Cii) for  Da1 and a2.

while (α2, L2) ∈ AC(T )∗

The proof is therefore complete. (cid:2)

We are now ready to give the lifted versions of our main results: Theorem 53 and Corollary 58. Proofs are straightforward 

consequences of our previous deﬁnitions and results.

Corollary 97. Consider a template T and suppose that the set of instantaneous action schemas Ai and that of durative action schemas 
Ad satisfy the following properties:

(i) every α ∈ Ai is strongly safe;
(ii) for every Dα ∈ Ad, Dαst is strongly safe and Dα∗ is safe;
(iii) Ad is pairwise relevant non-overlapping.

Then, T is invariant.

Corollary 98. Consider a template T and suppose that the set of instantaneous action schemas Ai and that of durative action schemas 
Ad satisfy the following properties:

(i) for every (Dα, L) ∈ AdC(wk, T ), then Dα∗L is weakly safe of type (a);
(ii) for every (α, L) ∈ AC(T ) \ (AstC(wk, T ) ∪ AendC(wk, T )), then, αL is either irrelevant or balanced.

Then, T is invariant.

We end this section by presenting two examples from the IPCs in which we apply Corollaries 98 and 92 to demonstrate 
the invariance of the templates under consideration. Corollary 97 is the most general one and can be used in more complex 
cases.

Example 17 (Floortiledomain). Consider our usual template:

T f t = ({(cid:9)robotAt/2, 0(cid:10), (cid:9)painted/2, 1(cid:10), (cid:9)clear/1, 1(cid:10)}

The  action  schemas  in  the  domains  are:  Ad = {changeColor, paintUp, paintDown, up, down, right, left}.  The 
schemas paintUp and paintDown are  symmetrical  and  differ  only  on  formulas  not  matching  T f t .  They  have  the 
same  T -classes  L1 = {robotAt(r,x)} and  L2 = {clear(y), painted(y,c)}.  As  seen  in  Example 16,  the  pure 
schemas  paintUpst
and  paintUpend
are  irrelevant  and  paintUp∗L2 is  weakly  safe  of  type  (a).  The  same  holds  for 
∗L1
∗L1
paint-down∗L1 and paint-down∗L2 .

The schemas up, down, right, left are also symmetrical and differ only on formulas not in the components of T f t . 
They have the same T -classes  L3 = {robotAt(r,x), clear(x)} and  L4 = {robotAt(r,y), clear(y)}. The schemas 
up∗Li , down∗Li , right∗Li and left∗Li , with i = 3, 4, are all weakly safe of type (a).

The schema changeColor has no formula matching the template, hence its start and end fragments are both irrelevant.
By Corollary 98, the template T f t is invariant.

Example 18 (Depotdomain). Consider the domain Depot (see Appendix B) and the template:

Tdp = ({(cid:9)lifting/2, 1(cid:10), (cid:9)available/1, 1(cid:10)}

Invariants of this template mean that a hoist can be in two possible states: lifting a crate or available. The action schemas 
in the domains are all durative:

Ad = {drive, lift, drop, load, unload}

We indicate them as  Dα1, . . . , Dα5 respectively and, given  Dαi , its variables as xi, yi, . . ..

To demonstrate that Tdp is invariant, we want to apply Corollary 92. We start with condition (ii) since Ai is empty.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

43

The  action  Dα1 = drive has  no  formulas  that  match  the  template  so  it  is  strongly  safe.  The  other  schemas  have 
respectively T -classes  Li = {lifting(xi, yi), available(xi)}. There are only two fragments of the durative actions that 
are not strongly safe as they are unbounded: α3end
are strongly 
safe since they are balanced (when the over all condition lifting(x3, y3) is added to the end effects, it matches the delete 
effect lifting(x3, y3) and balances the add effect available(x3); similar considerations hold for Dα4). Reachability for 
α3end
∗L3

is a straightforward check. In consequence, condition (ii) holds.

. However, their auxiliary versions α3end
∗L3

and α4end
∗L4

and α4end
∗L4

and α4end

We  now  need  to  verify  condition  (iii)  of  Corollary 92,  i.e.  Ad is  relevant  right  isolated.  Under  the  re-writing  ML3 L4 , 
= {available(x3) = available(x4)}.  Hence 
∪ML3 L4

Eff

L4

L3

+
α4end
L4

we  have  that  x3 = x4 and  y3 = y4 and  therefore  Eff
condition (i) of Deﬁnition 90 is satisﬁed.

We can conclude that Tdp is an invariant template.

+
α3end
L3

Example 19 (Roversdomain). Consider the domain Rovers (see Appendix C) and the template:

Tr v = ({(cid:9)full/1, 0(cid:10), (cid:9)empty/1, 0(cid:10)}

Invariants of this template would mean that the store of a rover can be in two possible states: empty or full. Since rovers’ 
stores can only contain one object, this seems a promising template.

To verify that it is invariant, we now analyse the safety of each schema in the domain. The schemas in the domain are 

all durative:

Ad = {navigate, sample_soil, sample_rock, drop, calibrate, take_image,

communicate_soil_data, communicate_rock_data, communicate_image_data}

We indicate them as  Dα1, . . . , Dα9 respectively and, given  Dαi , its variables as xi, yi, . . ..

The  actions  Dα1 and  Dα5 through  Dα9 have  no  formulas  that  match  the  template  so  they  are  irrelevant  and,  conse-
quently, strongly safe. We are left with: Dα2 = sample_soil, Dα3 = sample_rock and Dα4 = drop. Each of them has 
just one T -class Li = {empty(xi), full(xi)} for i = 2, 3, 4. Note that Dα2
L2
is strongly safe: α4st
L4

are both weakly safe of type (a). Dα4
L4

Note  that  we  cannot  conclude  invariance  by  using  either  Corollary 92 (as  not  all  schemas  are  strongly  safe)  or  Corol-
that is relevant bounded). We now directly show that, surprisingly, Tr v is not invariant. If γ is any 
lary 98 (because of α4end
instance of T , we consider groundings gri for i = 2, 4 such that gri and γ are coherent over Li and we put Dai = gri(Dαi). 
Now  we  are  essentially  in  the  case  analysed  in  Example 13:  intertwining  two  copies  of  Da4 and  one  of  Da2 leads  to  an 
admissible not individually γ -safe sequence.

is irrelevant and α4end

is relevant bounded.

and Dα3
L3

If we modify the durative action schema  Dα4 adding an over all condition Preα4inv = {full(x4)}, by arguing similarly 
to Example 13, we can prove that Ad is pairwise relevant non overlapping and thus conclude, using Corollary 97, that T is 
now invariant.

L4

L4

This  example  shows  how  our  invariant  synthesis  can  be  used  as  a  debugging  tool  and  as  a  method  to  improve  the 
modelling of planning domains. In this case, the addition of an over all condition is suﬃcient to prevent erroneous physical 
phenomena as a store being full and empty at the same time.

9.  Guess, check and repair algorithm

As  with  related  techniques  [26,27,45,33],  our  algorithm  for  ﬁnding  invariants  implements  a  guess, check and repair ap-
proach. It starts by generating a set of initial simple templates. For each template T , it then applies the results stated in 
the previous sections to check its invariance. If T is invariant, the algorithm outputs it. However, if the algorithm does not 
manage  to  prove  the  invariance  of  T ,  it  discards  it.  Before  rejection,  however,  the  algorithm  tries  to  ﬁx  the  template  by 
generating a set of new templates that are guaranteed not to fail for the same reasons as T . In turn, these new templates 
need to be checked against the invariance conditions as they might fail for other reasons.

9.1.  Guessing initial templates

When  we  create  the  set  of  initial  templates,  we  ignore  constant  relations,  i.e.  relations  whose  ground  atoms  have  the 
same truth value in all the states (for example, type predicates). In fact, they are trivially invariants and so are typically not 
interesting.

For each modiﬁable relation r with arity k, we generate k + 1 initial templates. They all have one component and zero 
or  one  counted  variable  (which  can  be  in  any  position  from  0 to k − 1):  (cid:9)r/k, k(cid:10) (no  counted  variable)  and  (cid:9)r/k, p(cid:10) with 
p ∈ {0, . . . , k − 1}. Since the templates have one component, there is only one possible admissible partition FC , with C = {c}. 
Hence, we construct the template T = (C, FC).

44

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Example 20 (Floortiledomain). Consider the components c1 = (cid:9)robotAt, 2, 1(cid:10). Let FC = {F 1} where F 1 = {(c1, 0)}. An initial 
template is T1 = ({c1}, {F 1}). Intuitively, invariants of T1 mean that a robot can occupy only one position at any time and our 
algorithm validates it as an invariant. Another initial template is built by considering the component c2 = (cid:9)robotAt, 2, 0(cid:10)
and the partition FC = {F 2} where F 2 = {(c2, 1)}. We have another initial template: T2 = ({c2}, {F 2}). Invariants of this tem-
plate mean that a tile cannot be occupied by more than one robot, which is not true in general, and our algorithm correctly 
discards it. Finally, consider the component c3 = (cid:9)robotAt, 2, 2(cid:10) and the partition FC = {F 3} where  F 3 = {(c3, 0), (c3, 1)}. 
Another initial template is T3 = ({c3}, {F 3}). This is also not an invariant and is rejected.

If we repeat this process with every modiﬁable relation r in the Floortile domain, we obtain the full set of initial tem-

plates.

9.2.  Checking conditions for invariance

We apply the results stated in the previous sections to check the invariance of a template. In particular, we apply our 

most operative results: Corollaries 74, 92, 97, 98. All these results work at the level of action schemas, not ground actions.

We ﬁrst need to verify if all the instantaneous action schemas A in the domain, both the native ones and those obtained 
from  the  fragmentation  of  durative  actions,  respect  the  strong  safety  conditions.  We  then  check  safety  conditions  that 
only  involve  durative  action  schemas  that  are  not  strongly  safe.  Finally,  we  validate  additional  conditions  that  avoid  the 
intertwinement of potentially dangerous durative actions. Given the different computational complexity of our results (see 
considerations  below),  our  algorithm  checks  the  applicability  of  them  in  the  following  order:  ﬁrst,  Corollary 74,  which 
involves  only  conditions  for  instantaneous  schemas,  then  Corollary 98,  which  considers  safety  conditions  for  individual 
action schemas, and ﬁnally Corollaries 92 and 97, which need to verify conditions involving pairs of durative action schemas. 
To  implement  this  procedure,  we  apply  the  decision  tree  shown  in  Fig. 11 to  the  set  of  action  schemas  A.  The  leaves 
labelled as Possibly Not Invariant arise when our suﬃcient results do not apply. In this case, we cannot assert anything about 
the invariance of the template.

Our  checks  involve  the  analysis  of  all  T -classes  in  each  action  schema  α in  the  domain.  Since  the  T -classes  form  a 
partition of the set of formulas in the schema that match the template, the maximum number of T -classes is equal to the 
number of such formulas. We can estimate this term with the product ω · |C| where ω is the maximum number of formulas 
in any schema that shares the same relation and |C| is the cardinality of the template’s component set C. We deduce that 
all safety checks for individual schemas (both the instantaneous and the durative ones) have a computational complexity of 
the order of  M · |A| · ω · |C|, where  M is the maximum number of formulas appearing in any schema and |A| is the total 
number  of  schemas.  Consequently,  this  is  the  computational  complexity  of  Corollaries 74 and  98 that  only  involve  safety 
checks.

The  check  of  the  right  relevant  isolated  property  of  Deﬁnition 90,  which  is  needed  in  Corollary 92,  and  the  check  of 
the pairwise relevant non overlapping property of Deﬁnition 95, which is used in Corollary 97, instead involve schema-class 
pairs and possibly families of matchings. When the condition to be checked only involves a ﬁxed matching, its computational 
complexity is of the order of  M2 · |A|2 · ω2 · |C|2. This leaves out all the checks of the unreachability conditions for pairs 
of schemas, namely, (iii) of Deﬁnition 90 and (Aii), (Bii), (Cii) of Deﬁnition 95 that need to verify the conditions expressed 
in  Deﬁnitions 88 and  93.  Below,  we  provide  some  details  on  how  these  conditions  can  also  be  eﬃciently  checked  at  the 
algorithmic level.

+
αiend
∗Li

• Check of Deﬁnition 88: The  two  instances  of  conditions  (i)  and  (ii)  involve  a  ﬁxed  matching.  The  two  instances  of 
L1,L2 .  Consider  the  ﬁrst  case  (the 
) ≥ 2 for i = 1 or for i = 2: if this is the case, then condition (iii) 

condition (iii)  instead  are  quantiﬁed  over  the  all  possible  matchings  containing  M
second one being analogous). We ﬁrst check if w(Pre

+
αiend
∗Li

+
αiend
∗Li

is  veriﬁed.  If  Pre

= {li} and  the  formulas li are  such  that  Rel[l1] (cid:14)= Rel[l2] then,  again,  condition (iii)  is  veriﬁed.  If, 

instead,  Rel[l1] = Rel[l2],  we  show  that  condition  (iii)  is  never  satisﬁed.  Indeed,  in  this  case,  the  two  formulas  match 
k−1) for  i = 1, 2 and  we  note  that 
the  template  through  the  same  component  c = (cid:9)r/k, p(cid:10).  We  write  li = r(v i
(v 1
L1,L2 l2. 
If  instead  p < k,  then  l1 =M l2 when  we  consider  M = M
p)}.  Finally,  condition  (iii)  is  certainly  not 
veriﬁed if Pre

L1,L2 for every  j (cid:14)= p. Therefore, if p = k (all variables are ﬁxed in the component), necessarily, l1 =M

= ∅ for i = 1 or i = 2. For two given schema-class pairs, this check therefore has complexity M2.

L1,L2 ∪ {(v 1

0, . . . , v i

j ) ∈ M

p, v 2

j , v 2

L1,L2 . We ﬁrst consider (i). Suppose that we ﬁnd l1 and l2 that satisfy l1 =M

• Check of Deﬁnition 93: All three properties in this deﬁnition, in principle, involve checking a condition over all possible 
L1,L2 l2. Now ﬁx 
−
α such  that 
k−1) and l = r(v 0, . . . , vk−1)
L1,L
j , v j) /∈ M for  any  matching 
j , v j) | j =
∪ {(v 1

matchings containing M
(α, L) ∈ MC .  If  for  every  l ∈ Eff
Rel[l] = Rel[l1] = (cid:9)r/k(cid:10), for each of them we proceed as follows. We write l1 = r(v 1
and for each  j = 0, . . . , k − 1 we consider the two variables v 1
for  some  w ∈ V α \ {v j},  or  (w 1, v j) ∈ M
M ⊇ M
1, . . . , k} is a matching such that l1 =M l.

L1,L and  (i)  is  veriﬁed.  Now  consider  the  case  in  which  (i)  is  not  veriﬁed.  Now M = M

−
α we  have  that  Rel[l] (cid:14)= Rel[l1],  then  (i)  holds.  If  instead  there  are  l ∈ Eff

j and v j . If there exists  j such that either (v 1

L1,L for  some  w 1 ∈ V α1 \ {v 1

},  then  for  sure  (v 1

j , w) ∈ M

0, . . . , v 1

L1,L

j

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

45

Fig. 11. Decision Tree for deciding the invariance of a template T .

Checking condition (ii) is analogous to (i). As far as condition (iii) is concerned, note that when we need to check this 
= {li}
property, the schemas involved will be reachable and not heavy. For property (iii) to hold, we must have Pre

for i = 1, 2. Following the same argument as in the previous item, if Rel[l1] = Rel[l2], then (iii) is not veriﬁed. If instead 
= {l} and  Rel[l] (cid:14)= Rel[l2],  then  (iii)  is  veriﬁed. 
Rel[l1] (cid:14)= Rel[l2],  we  consider  the  set  Eff

.  If  it  is  empty  or  if  Eff

+
α1
L1

+
α1
L1

Otherwise, it is not. We conclude that for two given schema-class pairs, this check has complexity  M3 · |A| · ω · |C| · N
where N is the maximum number of variables in any formula in the domain.

+
αi
Li

The  above  considerations  allow  us  to  conclude  that  the  check  of  the  right  relevant  isolated  property  has  complexity 
M2 · |A|2 · ω2 · |C|2, while the check of the pairwise relevant non overlapping property has complexity M3 · |A|3 · ω3 · |C|3 · N. 
There are also the complexities of checking the properties of Corollaries 92 and 97, respectively.

46

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Example 21 (Floortiledomain). The variables for the computational complexity analysis are as follows:

|A| = 14, M = 4, ω = 1, |C| = 3, N = 2

9.3.  Repairing templates

In analysing an action schema α, when we reach a failure node in our decision tree, we discard the template T under 
consideration since we cannot prove its invariance. This might be because of two reasons: either T is not an invariant or 
our suﬃcient conditions are not powerful enough to capture it. Before discarding the template, however, we try to ﬁx it in 
such a way as to obtain new templates for which it might be possible to prove invariance under our conditions. In particular, 
based on the schema α, we enlarge the set of components of the template by adding suitable formulas that appear in the 
preconditions and negative effects of α since they can be useful to prove that α is weakly or strongly safe.

If the algorithm rejects T because it ﬁnds an instantaneous schema that is heavy or unbalanced (ﬁrst step in the decision 
tree),  no  ﬁxes  are  possible  for  T .  Since α leads  to  a  weight  greater  than  or  equal  to  two  for  at  least  one  instance  of  T , 
enlarging the set of components of T cannot help in repairing the template. Similarly, if there are durative schemas that 
are non-executable or unreachable, no ﬁxes are possible since these properties cannot be changed by adding components. 
However, when a failure node is reached in the presence of unbounded schemas, enlarging the set of components might 
prove useful in making them weakly or strongly safe schemas. We operate as follows: for each unbounded schema α, we 
try  to  turn  it  into  a  balanced  action  schema  and,  when  α is  the  end  fragment  of  a  durative  action  Dα,  we  alternatively 
attempt to make  Dα a weakly safe schema, as deﬁned in Deﬁnition 78.

Take a template T = (C, FC) that has been rejected by the algorithm. Let k be the number of ﬁxed variables for T and 
let m be  the  number  of  its  components.  Consider  an  unbounded  schema α with  relevant  formula l.  We  look  for  another 
formula l

(cid:7)

in α with the following characteristics:
(cid:7) = (k + 1);

(cid:7)(cid:10), where a

(cid:7) = k or a

(cid:7)/a

(cid:7)] = (cid:9)r

(i) Rel[l
(ii) There exists a bijection β from the variables of l to the variables of l
(iii) l

∩ Eff

+
(cid:7) ∈ Pre
α

−
α .

(cid:7)

such that  Arg[i, l] = Arg[β(i), l

(cid:7)] for every i ∈ I ;

If  α is  the  end  fragment  of  a  durative  action  Dα,  then  condition  (iii)  can  be  substituted  with  one  of  the  alternative 

following conditions:

(iv) l

(v) l

+
(cid:7) ∈ Pre
αst∗
+
(cid:7) ∈ Pre
αst∗

∩ Eff
∩ Eff

−
αst∗
−
αend∗

(cid:7)

(cid:7)/k

(cid:7), p

For each formula l

that satisﬁes conditions (i), (ii) and one of conditions (iii), (iv) and (v), we create a new component 
(cid:7) ∈ {0, . . . , k
(cid:7) = (cid:9)r
C is  an  admissible 
c
partition of  FC(cid:7) such that for each c1, c2 ∈ C, we have that (c1, i) ∼F C(cid:7) (c2, j) if and only if (c1, i) ∼F C (c2, j) and (c, i) ∼F C(cid:7)
(c

(cid:7)},  and  one  new  template  T (cid:7) = (C(cid:7), F (cid:7)

(cid:7)] (or, equivalently,  j = β(i)).

C),  where  C(cid:7) = C ∪ {c

(cid:7)(cid:10),  where  p

(cid:7)} and  F (cid:7)

that satisﬁes condition (iii), the schema α is guaranteed to be balanced for T (cid:7)

; if the formula l

(cid:7)

(cid:7), j) if and only if  Arg[i, l] = Arg[ j, l
If we ﬁnd a formula l

(cid:7)

satisﬁes condition (iv), α is guaranteed to be weakly safe of type (a) for T (cid:7)
α is guaranteed to be weakly safe of type (b) for T (cid:7)

.

; ﬁnally, if the formula l

satisﬁes condition (v), 

(cid:7)

+
α

Example 22 (Floortiledomain). Consider the template T2 = ({c2}, {F 2}) as indicated in Example 21 and the action schema α =
= {robotAt(r,y), clear(x)}. The formula robotAt(r,y) matches T2 and forms a T -class L1 =
upend: Preα = ∅, Eff
{robotAt(r,y)}. The pure action schema αL1 is unbounded as well as the end parts of the other schemas that indicate 
movements. If we apply our decision tree to T2 and the set of actions A, we cannot prove that T2 is an invariant since the 
unbounded schemas are not weakly safe. Before discarding T2, we try to ﬁx it. In particular, the formula clear(y) satisﬁes 
conditions (i), (ii) and (iv) above. If we add it to T2, we obtain a new template T (cid:7)
= (cid:9)clear, 1, 1(cid:10)
(cid:7)
with  F c
2 is 
an invariant since Corollary 98 can be successfully applied (all schemas are either strongly safe or weakly safe of type (a)). 
Intuitively, invariants of this template mean that a tile is either clear or occupied by a robot.

2, 0)}. If we apply our decision tree to this new template, we can prove that T (cid:7)

(cid:7)
2, 0)} and  F

= {(c2, 1), (c

}) where c

= ({c2, c

= {(c

}, {F

(cid:7)
2

(cid:7)
2

(cid:7)
2

(cid:7)
2

(cid:7)
2

2

10.  Experimental results

To evaluate the performance of our Temporal Invariant Synthesis, referred as TIS in what follows, we have performed a 
number of experiments on the IPC benchmarks. We implemented the TIS algorithm, reported in Section 9, in the Python 
language and conducted the experiments by using a Quad Core 2.6 GHz Intel i5 processor with 4 GB memory.

Since our paper proposes a domain analysis, the core measure of success is whether this analysis can ﬁnd invariants that 
previous methods cannot. We carry out this evaluation in Sections 10.1 and 10.2. In particular, in Section 10.1, we focus on 
the number and quality of the invariants found by TIS. In Section 10.2, we present a comparison between our TIS and the 
invariant synthesis that is used within the planner TFD [18], both in terms of the invariants found and of the state variables 
that can be synthesised based on such invariants. The experimental results (in particular, Fig. 13 and Table 6) show that TIS

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

47

Table 5
Number of invariants (# Inv) obtained by using the Simple Invariant Synthesis (SIS) and the Temporal Invariant Synthesis (TIS) against the temporal domains 
of the IPC’08, IPC’11 and IPC’14, TIS run time (RT) for generating invariants and number of invariants obtained by TIS via repairing failed templates (# Fix).

Domains

IPC’08
CrewPlanning
Elevators-Num
Elevators-Str
Modeltrain
Openstacks-Adl
Openstacks-Num
Openstacks-Num-Adl
Openstacks-Str
Parcprinter
Pegsol
Sokoban
Transport
Woodworking

IPC’11
Floortile
Matchcellar
Parking
Storage
TMS
TurnAndOpen

IPC’14
Driverlog
Mapanalyser
RTAM
Satellite

# Inv SIS

# Inv TIS

TIS RT

# Fix TIS

0
0
0
3
2
4
2
4
5
0
0
0
2

0
3
0
0
0
2

0
3
6
0

2
2
3
7
7
8
5
9
5
2
3
2
5

5
3
3
3
0
5

2
5
15
2

0.29
0.02
0.02
0.23
0.01
0.06
0.01
0.09
0.59
0.002
0.01
0.01
0.20

0.05
0.003
0.03
0.05
0.02
0.03

0.03
0.04
0.20
0.01

0
1
1
2
4
6
4
6
2
1
1
1
3

2
2
3
2
0
2

2
4
8
1

ﬁnds more invariants than related techniques, which in turn results in a more compact representation using a smaller set 
of state variables.

To enrich our experimental analysis, we also test the hypothesis that more compact encodings beneﬁt the performance 
of the planners that use state variables. In Section 10.3, we present experiments that show the impact of using TIS, which 
results  in  a  smaller  set  of  state  variables,  on  the  performance  of  two  state-of-the-art  planners  that  use  a  variable/value 
representation.

10.1.  Quality of the representation

In this section, we discuss the number and quality of the invariants found by TIS, and the eﬃciency of our algorithm.
Fig. 12 shows the invariants that our technique ﬁnds for all the IPC temporal domains (from IPC’02 to IPC’14). Each set in 
Fig. 12 corresponds to a set C of components, which are separated by a comma and indicated with the relation name (arity 
is omitted here for brevity), the positions of the ﬁxed variables (not enclosed in square brackets) and the position of the 
counted variable (enclosed in square brackets). For example, {at 0 [1], in 0 [1]} indicates the invariant with the components 
c1 = (cid:9)at/2, 1(cid:10) and  c2 = (cid:9)in/2, 1(cid:10).  The  admissible  partitions  are  not  shown  for  brevity,  however  in  most  of  the  cases  the 
only admissible partition is the trivial one.

For  comparison  purposes  only,  we  have  devised  a  variant  of  our  invariant  synthesis  technique,  which  we  refer  to  as 
Simple Invariant Synthesis (SIS). SIS is the simplest possible extension of Helmert’s original technique to temporal domains. 
It fragments each durative schema into three instantaneous schemas and then applies Helmert’s original technique, i.e. it 
judges  safe  only  instantaneous  schemas  that  in  our  classiﬁcation  are  irrelevant  or  balanced.  We  use  the  SIS  technique  to 
explore the impact on runtime of the sophisticated checks that we need to perform to make sure that the durative actions 
that are not balanced are indeed safe.

The second and the third columns of Table 5 compare the number of invariants found by SIS to those found by TIS for 
the temporal domains of the last three competitions: IPC’08, IPC’11, and IPC’14. The fourth column reports the TIS runtime 
(RT)  for  generating  the  invariants.  The  numbers  tell  us  that  the TIS computation  time  to  calculate  invariants  is  negligible 
and  that  there  is  no  signiﬁcant  delay  associated  with  the  checks  required  by  our  algorithm,  in  particular  the  complex 
checks involving pairs of schemas. While these checks do not impact the computational time, they allow us to ﬁnd a more 
comprehensive set of invariants than a simpler technique such as SIS.

The  last  column  in  Table 5 (# Fix)  reports  the  number  of  invariants  obtained  by  repairing  failed  templates  in  our TIS

algorithm and provides an indication of the importance of the repair step in our algorithm.

10.2.  Comparison with the temporal fast downward invariant synthesis

Currently,  it  is  diﬃcult  to  compare  our  technique  for  generating  temporal  invariants  from  lifted  domains  to  related 
techniques  since  they  either  handle  non  temporal  domains  only  [20,27,45,46,33] or  work  at  the  ground  level  of  the  rep-

48

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Fig. 12. Invariants found for the temporal domains of all the IPCs. Each invariant is enclosed in braces where the relation names indicate the components of 
the invariant, the numbers not enclosed in square brackets indicate the positions of the ﬁxed variables in the list of variables of the corresponding relation 
and numbers enclosed in square brackets indicate the position of the counted variables.

resentation  [47,48].  The  approach  that  appears  most  similar  to  ours  is  the  invariant  synthesis  implemented  within  the 
Temporal Fast Downward (TFD) planner [18], which we refer to as TFD-IS (simply TFD in the tables and ﬁgures). This tech-
nique also works on lifted domains, but it reﬁnes the results obtained at this level by using information on reachable ground 
atoms. In this section, we present a comparison between our TIS and TFD-IS with respect to: (i) the invariants found by the 
two approaches; and (ii) the state variables that can be synthesised based on such invariants. In comparing invariants, we 
consider the temporal domains of all IPCs, while in comparing state variables we focus on those domains in which TFD-IS
and TIS output different invariants. We start with a brief description of TFD-IS.

Our knowledge of TFD-IS is based on examination of the code5 and an analysis of the results that the code produces, 
since  there  is  no  formal  account  of  the  technique. TFD-IS is  an  extension  of  Helmert’s  original  synthesis  (described  in 
Section 11.2) devised to deal with temporal and numeric domains. As with the original technique, TFD-IS employs a guess, 
check and repair approach to ﬁnd invariants. The algorithm analyses the temporal schemas directly, without splitting them 
into their start, over all and end fragments. Only two types of relevant durative action schemas are evaluated as safe: those 

5 TFD-0.4 code is available at http :/ /gki .informatik.uni-freiburg .de /tools /tfd /index .html. We used the so-called “Safe” version of the invariant synthesis.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

49

Fig. 13. Examples of the different invariants produced by TIS and TFD-IS taking one domain from each IPC competition.

Table 6
Number of invariants (# Inv) found by using TIS and TFD-IS on all the IPC temporal domains.

Domains

IPC’02
Depots
DriverLog
ZenoTravel
Rover
Satellite

IPC’04
Airport
Pipesworld – no tankage
Pipesworld – tankage
UMTS

IPC’06
Openstack
Pathways
Storage
TPP
Trucks

# Inv TFD

# Inv TIS

Domains

# Inv TFD

# Inv TIS

0
2
1
5
2

1
0
1
2

6
0
1
1
2

5
2
1
8
2

10
2
6
2

6
0
3
1
2

IPC’08
CrewPlanning
Elevators-Num
Elevators-Str
Modeltrain
Openstacks-Num
Openstacks-Num-Adl
Openstacks-Str
Parcprinter
Pegsol
Sokoban
Transport
Woodworking

IPC’11
Floortile
Matchcellar
Parking
TMS
TurnAndOpen

IPC’14
Mapanalyser
RTAM

2
2
3
6
8
5
9
5
1
1
2
5

3
3
3
0
5

3
11

2
2
3
7
8
5
9
5
2
3
2
5

5
3
3
0
5

5
15

that in our classiﬁcation are balanced at start and irrelevant at end and those that are weakly safe of type (a). In all the 
other cases, the action schemas are labelled as unsafe and the candidate invariant is dismissed.

Fig. 13 shows a few examples of the different sets of invariants found by the TFD-IS and our TIS, taking one temporal 

domain from each IPC competition.

Table 6 shows  the  number  of  invariants  found  by  the  two  techniques  in  all  the  domains  of  the  IPC  competitions.  In 
12  out  of  33  cases  the TIS outperforms  the  TFD  synthesis,  and  in  all  the  other  cases  the  two  synthesis  output  the  same 
invariants. In several cases, the difference in the number of invariants is signiﬁcant (e.g. for Depots, TIS ﬁnds ﬁve invariants 
against zero for TFD-IS; for Airport, TIS ﬁnds ten invariants against one for TFD-IS).

We next investigate how the different number of invariants reﬂects on the number of state variables that are generated 
based  on  them.  In  this  context,  together  with TIS and TFD-IS,  we  also  consider  the  case  in  which  no  invariants  are  used 
to synthesise state variables, referred to as NIS (No Invariant Synthesis). In this case, a state variable with two truth values 
(true and false) is produced for each atom in the domain. We use NIS as a baseline for our experiments. Table 7 reports 
the comparison for those IPC temporal domains in which TIS and TFD-IS produce different invariants and, for brevity, shows 

50

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Table 7
Number of state variables (# SV) that are obtained by instantiating invariants coming from: (1) No Invariant Synthesis (NIS); (2) TFD Invariant Synthesis 
(TFD); and (3) Temporal Invariant Synthesis (TIS). We focus on the temporal IPC domains in which TIS and TFD ﬁnd different invariants. We consider three 
problems for each domain (ﬁrst, intermediate, and last instance of the benchmark).

Domains

Depots – p1
Depots – p10
Depots – p20
Rover – p1
Rover – p10
Rover – p20
Airport – p10
Airport – p30
Airport – p50
Pipes – NoTank – p10
Pipes – NoTank – p30
Pipes – NoTank – p50
Pipes – Tank – p10
Pipes – Tank – p30
Pipes – Tank – p50
Storage – p10
Storage – p20
Storage – p30

# SV

NIS

46
198
758
35
125
480
218
7068
18071
100
527
1225
148
647
1385
98
546
1930

TFD

46
198
758
32
105
289
218
7068
18071
100
527
1225
122
590
1240
86
456
1630

TIS

14
32
67
25
77
204
172
3828
9145
98
522
1216
96
525
1151
38
136
350

Domains

Pegsol – p10
Pegsol – p20
Pegsol – p30
Modeltrain – p10
Modeltrain – p20
Modeltrain – p30
Sokoban – p10
Sokoban – p20
Sokoban – p30
Floortile – p1
Floortile – p10
Floortile – p19
MapAnalyser – p1
MapAnalyser – p10
MapAnalyser – p20
RTAM – p1
RTAM – p10
RTAM – p20

# SV

NIS

67
67
67
589
588
1270
490
127
1131
64
126
186
215
752
854
1279
1498
3114

TFD

67
67
67
383
380
750
490
127
1131
40
67
97
179
677
729
341
407
677

TIS

34
34
34
191
188
390
72
37
75
16
26
36
174
670
722
311
374
614

three  problems  for  each  domain.  The  table shows  that,  by  increasing  the  number  of  invariants  found, TIS gives  rise  to  a 
more  compact  representation  than NIS or TFD-IS.  In  all  the  domains TIS produces  a  signiﬁcant  reduction  in  the  number 
of  state  variables  in  comparison  to NIS and TFD-IS.  In  Sokoban,  for  example,  the  reduction  is  greater  than  one  order  of 
magnitude.

10.3.  Performance in temporal planners

We  have  performed  a  number  of  additional  experiments  in  order  to  evaluate  the  impact  of  using  the  state  variables 
generated by TIS on the performance of those planners that use a variable/value representation. In particular, we focus here 
on the performance of two planners: Temporal Fast Downward (TFD) [18] and POPF-SV, a version of POPF [12] that makes 
use of multi-valued state variables.6

10.3.1.  TFD: temporal fast downward

+

+

TFD  is  a  planning  system  for  temporal  and  numeric  problems  based  on  Fast  Downward  (FD)  [32],  which  is  limited  to 
” 
non temporal and non numeric domains. TFD uses a multi-valued variable representation called “Temporal Numeric SAS
),  which  is  a  direct  extension  of  the  “Finite  Domain  Representation”  (FDR)  used  within  FD  to  handle  tasks  with 
(TN-SAS
time  and  numeric  ﬂuents.  TN-SAS
captures  all  the  features  of  PDDL  –  Level  3  and  represents  planning  tasks  by  using: 
i) a set of state variables, which are divided into logical and numeric state variables; ii) a set of axioms, which are used to 
represent logical dependencies and arithmetic sub-terms; and iii) a set of durative actions, which comprise: a) a duration 
variable; b) start, persistent and end conditions; and c) start and end effects.

+

+

+

TFD translates PDDL2.1 tasks into TN-SAS

tasks ﬁrst and then performs a heuristic search in the space of time-stamped 
states  by  using  a  context-enhanced  additive  heuristic  [34] extended  to  handle  time  and  numeric  ﬂuents.  The  translation 
from PDDL2.1 to TN-SAS
works in four steps. First, the PDDL instance is normalised, i.e. types are removed and conditions 
and effects are simpliﬁed. Then, an instance where all the formulas are ground is produced through a grounding step and 
the invariant synthesis (which we have previously indicated as TFD-IS) is applied to generate invariants (the grounding and 
the invariant synthesis can be performed in parallel). Starting from the invariants provided by the invariant synthesis and 
the ground domain, a set of multi-valued state variables is generated. Finally, a set of actions is obtained starting from PDDL 
actions, which describe how the state variables change over time.

In  Figs. 14–16,  we  compare  TFD  with  two  alternative  versions,  one  in  which  we  substitute our  technique, TIS,  for  the 
original TFD-IS, and one in which we substitute the baseline technique, NIS (No Invariant Synthesis), for TFD-IS. We focus 
on the IPC domains in which TFD-IS and TIS produce different invariants (see Table 6). The search time (ST) is in seconds 
and, following the conventions of the IPCs, the timeout has been set to 1800 seconds. Problems for which a plan could not 
be found within the timeout by all three techniques do not appear in the table.

In several cases, the lower number of state variables produced by TIS speeds up the TFD planner, for example in the do-
mains Modeltrain, Sokoban and Storage, and, for some problems, the gain is very high, for example Storage–p12,p14,p15
and  Sokoban–p03,p05,p07,p16.  In  domains  such  as  Rover,  Mapanalyser and  Floortile,  when  TFD  manages  to  solve 

6 This version of POPF has been made available to us by the authors, Andrew and Amanda Coles.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

51

Fig. 14. Search time (ST) in seconds for the planner TFD on IPC temporal domains. Three versions of the invariant synthesis are used: (1) No Invariant 
Synthesis (NIS); (2) the original TFD synthesis; and (3) our Temporal Invariant Synthesis (TIS). We focus on the domains in which TIS and TFD synthesis 
produce different invariants. The timeout used is 1800 seconds. Problems for which all the techniques do not ﬁnd a plan within the timeout do not appear 
in the tables.

the  problems,  it  is  so  fast  that  the  impact  of  the  number  of  state  variables  is  negligible.  There  are  also  a  few  cases 
where  the  results  are  mixed,  see  for  example  Depots as  well  as  both  versions  of  Pipesworld (tankage  and  no  tank-
age).  The  reduction  in  the  number  of  variables  sometimes  constitutes  an  advantage  for  the  planner  (see  for  exam-
ple  Depots–p16,  PipesworldNoTankage–p13,p20,p25,  p30,p31,p35,p37,  PipesworldTankage–p09,p29,p30),  while  other 
times  it  seems  to  be  detrimental  for  the  search  (see  Depots–p21,  PipesworldNoTankage–p27,p28,p39,  PipesworldTank
age–p36,p37,p39,p45,p49). It should be noted that in Depots and PipesworldNoTankage, TFD-IS does not ﬁnd any invari-
ants  so  we  are  effectively  comparing  the  binary  encoding  based  on NIS against  the  multi-value  state  variables  encoding 
based on TIS. It is interesting to see that in PipesworldTankage there are several instances (for example, p36, p39, p49) in 
which the binary encoding performs best.

In  terms  of  problem  coverage,  the  two  techniques  perform  similarly.  In  some  cases,  ﬁnding  more  invariants  helps  in 
solving diﬃcult problems, see for example PipesworldNoTankage–p25, p35,p37, Storage–p15, and Sokoban–p07. However, 
there are also cases in which the opposite is true, for example in PipesworldNoTankage–p39, PipesworldTankage–p36, p37, 
p45, p49. Note that there are also problems in which the binary representation works best: PipesworldTank age–p39, p49.
The  intuition  of  the  inﬂuence  of  the  number  of  state  variables  on  planning  performance  comes  from  the  observation 
that TFD uses  graph  structures  for  the  computation  of  the  heuristic  estimates  whose  complexity  is  strongly  inﬂuenced 
by  this  number.  Our  results  indicate  that,  while  this  intuition  is  probably  correct,  there  are  other  details  in  the  heuristic 
computation that need to be considered and the connection between the number of state variables and the graphs’ structure 
must be analysed in greater depth. The experiments show that TIS has the potential to speed up search and to improve the 
coverage of planners, but more research is needed to understand how a more compact representation can be exploited at 
its full potential across all the domains and problems. For example, it would be interesting to analyse the performance of 
TFD when different subsets of the invariants are used to generate state variables. We did not perform such experiments as 
this analysis is beyond the scope of this work.

52

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Fig. 15. Search time (ST) in seconds for the planner TFD on IPC temporal domains. Three versions of the invariant synthesis are used: (1) No Invariant 
Synthesis (NIS); (2) the original TFD synthesis; and (3) our Temporal Invariant Synthesis (TIS). We focus on the domains in which TIS and TFD synthesis 
produce different invariants. The timeout used is 1800 seconds. Problems for which all the techniques do not ﬁnd a plan within the timeout do not appear 
in the tables.

10.3.2.  POPF-SV: forward-chaining partial-order planner with state variables

POPF-SV  is  a  version  of  the  forward-chaining  temporal  planner  POPF  [12] that  reads  a  variable/value  representation 
of  the  domain  and  uses  it  for  performing  an  inference  step  in  a  pre-processing  phase  and  for  reducing  the  size  of  the 
states during search. In particular, POPF-SV reads a standard PDDL task along with its corresponding TN-SAS
translation. 
This translation is the same as in TFD, so the invariant synthesis used in POPF-SV is TFD-IS, as described in the previous 
version of the domain. 
section. However, unlike TFD, POPF-SV reasons with both the original PDDL domain and the TN-SAS
The multi-valued state variable representation of the task is not used in the heuristic computation, but it is employed for 
two different purposes. An inference step based on the state variables is performed to support temporal preferences. This 
step  extracts  rules  that  are  then  used  during  search  (for  example,  is  it  possible  to  have  action a within  10  time  units  of 
action b). The second use of the invariant analysis aims to make the state representation more eﬃcient. Only one value for 
each multi-valued state variable needs to be stored within a state since if one is true then the others must necessarily be 
false.  This  property  results  in  massive  savings  in  memory.  This  is  particularly  beneﬁcial  for  POPF  as  memory  is  generally 
what causes the planner to fail (rather than time).

+

+

In  Figs. 17–19,  we  compare  POPF-SV  with  two  alternative  versions,  one  in  which  we  replace  the  original TFD-IS used 
within POPF-SV with our technique, TIS, and one in which we replace TFD-IS with NIS, which we use as a baseline for our 
experiments. We focus on the IPC domains in which TFD-IS and TIS produce different invariants (see Table 6). The search 
time (ST) is in seconds and, following the conventions of the IPCs, the timeout has been set to 1800 seconds. Problems for 
which a plan could not be found within the timeout by all three techniques do not appear in the table.

The tables clearly show that for POPF-SV dealing with fewer state variables is beneﬁcial to the algorithm across all the 
domains. In the domains that are more challenging for the planner, such as Depots, PipesworldTankage, PipesworldNoTankage
Sokoban, and Floortile, the gain is signiﬁcant. These results are in line with our intuition that a larger set of invariants help 
to  obtain  more  compact  representations,  which  in  turn  have  a  positive  impact  on  the  planners’  performance.  The  three 
versions work similarly in terms of coverage.

10.4.  Beyond the IPC

The generality of our approach for synthesising invariants from lifted temporal domains cannot be fully appreciated by 
considering  IPC  domains  only.  This  is  because  the  durative  actions  of  such  domains  present  a  rather  uniform  structure: 
most of the actions are either balanced or weakly safe of type (a). However, in domains that describe practical applications, 
other types of actions are often used. For example, in data processing, web services composition, production and software 

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

53

Fig. 16. Search time (ST) in seconds for the planner TFD on IPC temporal domains. Three versions of the invariant synthesis are used: (1) No Invariant 
Synthesis (NIS); (2) the original TFD synthesis; and (3) our Temporal Invariant Synthesis (TIS). We focus on the domains in which TIS and TFD synthesis 
produce different invariants. The timeout used is 1800 seconds. Problems for which all the techniques do not ﬁnd a plan within the timeout do not appear 
in the tables.

domains [2,29,40,30], the creation of new objects from an empty set is often required. Typically, the actions that create the 
new objects are bounded or weakly safe of type (c). TFD-IS fails to identify invariants in such situations as it regards such 
actions as unsafe.

As an example, consider the following case.

Example 23 (DataProcessingdomain). Consider the domain DataProcessing (see Appendix D) and the template:

Tdl = ({(cid:9)at/2, 1(cid:10)})

Assuming that each ﬁle has a unique identiﬁcation in the ﬁle system, an invariant of this template is that a ﬁle can be in 
only one location at any point in time. The action schemas in the domains are all durative:

Ad = {create, remove, compress, uncompress, move}

We indicate them as  Dα1, . . . , Dα5 respectively and, given  Dαi , its variables as xi, yi, . . ..

54

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Fig. 17. Search time (ST) in seconds for the planner POPF-SV on IPC temporal domains. Three versions of the invariant synthesis are used: (1) No Invariant 
Synthesis (NIS); (2) the original POPF-SV synthesis (i.e. TFD-IS); and (3) our Temporal Invariant Synthesis (TIS). We focus on the domains in which TIS and
TFD-IS produce different invariants. The timeout used is 1800 seconds. Problems for which all the techniques do not ﬁnd a plan within the timeout do not 
appear in the tables.

(cid:7)
i

For  i = 2, 5,  Dαi has just one equivalence class  Li = {at(xi, yi), at(xi, zi)}. Instead for  i = 1, 3, 4,  Dαi has two equiva-
(cid:7)
i, w i)}. We set AdC(Tdl)1 = {(Dαi, Li) | i = 2, 5}, AdC(Tdl)2 =
lence classes  Li = {(∀ yi : at(xi, yi)), at(xi, zi)} and  L
= {at(x
(cid:7)
i) | i = 1, 3, 4}.  We  then  note  that  for  each  (Dα, L) ∈ AdC(Tdl)1,  DαL
{(Dαi, Li) | i = 1, 3, 4},  and  AdC(Tdl)3 = {(Dαi, L
is  weakly  safe  of  type  (b),  while  for  every  (Dα, L) ∈ AdC(Tdl)2,  DαL is  weakly  safe  of  type  (c).  Moreover,  for  every 
(Dα, L) ∈ AdC(Tdl)3,  DαL is irrelevant. In particular, AdC(wk, Tdl) = AdC(Tdl)1 ∪ AdC(Tdl)2.

We  want  to  use  Corollary 97 to  prove  the  invariance  of  this  template.  Assumptions  (i)  and  (ii)  are  evident.  We  need 
to  show  property  (iii),  i.e.  Ad is  pairwise  relevant  non-overlapping  (see  Deﬁnition 95).  To  this  aim,  we  ﬁx  AdC(T )∗ =
AdC(wk, T ) and we check that properties A, B, and C hold true.

We note that if (Dαi, Li), (Dα j, L j) ∈ AdC(Tdl)1, properties (Ai) and (Bi) hold true. Indeed, idle(xi = x j) ∈ Preαi st ∩MLi ,L j
Eff α j st so  that  {αi st, α j st} and  {αi inv , α j st} are  both  MLi ,L j -mutex.  Instead, 
Eff α j st and  idle(xi = x j) ∈ Preαi inv ∩MLi ,L j
if  (Dαi, Li), (Dα j, L j) ∈ AdC(Tdl)2,  properties  (Aiii)  and  (Biii)  hold  true.  Indeed,  at(xi = x j, y j) ∈ Preαi inv ∩MLi ,L j
Eff α j end
Eff α j end so that {αi inv , α j end} and {αi end, α j end} are MLi ,L j -mutex. We now consider 
and at(xi = x j, y j) ∈ Preαi end ∩MLi ,L j
+
(Dαi, Li) ∈ AdC(Tdl)1 and  (Dα j, L j) ∈ AdC(Tdl)2.  We  have  that at(xi = x j, yi) ∈ Pre
α j st so  that  {αi st, α j st }
αi st
is  non MLi ,L j -executable.  This  yields  property  (Ai).  We  now  prove  property  (Bii)  for  this  pair.  To  this  end,  we  note  that 
AC(T )∗
= Ast C(Tdl)3 ∪ AendC(Tdl)3 and  we  show  that  property  (i)  of  Deﬁnition 93 holds  true  for  (αi st, α j st ).  Indeed, 
irr
irr ,  L ∩ Eff α = ∅ so that at(xi = x j, yi) /∈M
at(xi = x j, yi) ∈ (cid:8)
irr, Li, L j)-unreachable.  Finally,  following  an 
Eff
analogous  argument,  we  can  show  that  {α j inv , αi st} is  non  MLi ,L j -executable  so  that  property  (Bi)  holds  for  the  pair 
(Dα j, L j), (Dαi, Li). Finally, the properties (C) are trivially veriﬁed since AC(T )∗

α j st and, on the other hand, if (α, L) ∈ AC(T )∗
α for  every  matching M ⊇ MLi ,L .  This  tells  us  that  (αi st, α j st) is  (AC(T )∗

∩MLi ,L j

∩MLi ,L j

+
αi st

= ∅.

Pre

Pre

−

−

−

rel

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

55

Fig. 18. Search time (ST) in seconds for the planner POPF-SV on IPC temporal domains. Three versions of the invariant synthesis are used: (1) No Invariant 
Synthesis (NIS); (2) the original POPF-SV synthesis (i.e. TFD-IS); and (3) our Temporal Invariant Synthesis (TIS). We focus on the domains in which TIS and
TFD-IS produce different invariants. The timeout used is 1800 seconds. Problems for which all the techniques do not ﬁnd a plan within the timeout do not 
appear in the tables.

TFD-IS does not reason about weakly safe actions of type (b) and (c) and, in consequence, does not produce the invari-

ant Tdl. The FD invariant synthesis would have a similar behaviour for the corresponding sequential domain.

11.  Related work

Several approaches to invariant synthesis are available in the literature. In what follows, we present these approaches in 

depth by highlighting similarities and differences with our technique.

11.1.  Previous work on synthesising temporal invariants

The invariant synthesis presented in Bernardini and Smith [6] represents a preliminary version of the technique described 
in this paper. Bernardini and Smith [6] lacks a rigorous presentation of the theoretical framework behind the synthesis of 
invariants.  In  addition,  the  algorithm  does  not  capture  all  the  cases  in  which  unsafe  intertwinements  between  durative 
actions can happen, which results in the generation of unsafe invariants that could be violated under some circumstances. 
For  example,  for  the  domain  ZenoTravel (IPC’02),  the  algorithm  classiﬁes  Tzt = ({(cid:9)fuel-level/2, 1(cid:10)}) as  an  invariant. 
However, it can be shown that Tzt is not an invariant because the schema refuel is weakly safe of type (b) and can give 
rise to dangerous intertwinements that can invalidate the invariant conditions.

11.2.  Fast downward and temporal fast downward

Helmert [33] presents a translation from a subset of PDDL2.2 into FDR (Finite Domain Representation), a multi-valued 
planning  task  formalism  used  within  the  planner  Fast  Downward  [32].  The  translation  only  handles  non-temporal  and 

56

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

Fig. 19. Search time (ST) in seconds for the planner POPF-SV on IPC temporal domains. Three versions of the invariant synthesis are used: (1) No Invariant 
Synthesis (NIS); (2) the original POPF-SV synthesis (i.e. TFD-IS); and (3) our Temporal Invariant Synthesis (TIS). We focus on the domains in which TIS and
TFD-IS produce different invariants. The timeout used is 1800 seconds. Problems for which all the techniques do not ﬁnd a plan within the timeout do not 
appear in the tables.

non-numeric PDDL2.2 domains, the so-called “PDDL Level 1” (equivalent to STRIPS [19] with the extensions known as ADL 
[43].  One  of  the  steps  of  this  translation  is  the  identiﬁcation  of  mutual  exclusion  invariants  and  it  is  an  extension  of  the 
technique presented in Edelkamp and Helmert [15] developed for STRIPS.

When considering sequential domains, the invariant synthesis presented in this paper works similarly to Helmert’s tech-
nique. In particular, both work at the lifted level, while all the other related techniques discussed below work at the ground 
level. Both techniques start from simple invariant candidates and check them against conditions that ensure invariance by 
analysing  the  structure  of  the  action  schemas  in  the  domain.  When  a  candidate  is  rejected,  they  both  try  to  reﬁne  it  to 
create a new stronger candidate, which is then checked from scratch.

However, in contrast with our technique, Helmert’s method considers a schema safe only when the weight transitions 
from one, to zero and back to one. Potentially safe transitions from zero to one are ignored. This simpliﬁed analysis results 
in  the  identiﬁcation  of  a  smaller  set  of  invariants  compared  to  our  technique.  For  example,  Helmert’s  invariant  synthesis 
labels as unsafe all the action schemas that add a relevant formula without deleting that formula or another relevant one, 
even  when  the  preconditions  impose  that  the  weight  is  zero  when  the  action  schema  is  applied.  In  this  way,  Helmert’s 
invariant synthesis misses invariants that our technique is able to ﬁnd (see Example 23).

Chen  et  al.  [10] builds  on  Helmert’s  invariant  synthesis  and  his  multi-valued  domain  formulation  to  synthesise  long-
distance mutual  exclusions  (londex),  which  capture  constraints  over  actions  and  facts  not  only  at  the  same  time  step  but 
also across multiple steps. The londex has been successfully used in SAT-based planners to improve their performance. It is 
worth considering how the concept of londex can be extended to temporal domains.

Within the context of Temporal Fast Downward (TFD) [18], a simple extension of Helmert’s invariant synthesis is used 

to deal with temporal and numeric domains of the ICPs. See Section 10.2 for a description of this technique.

11.3.  Rintanen’s invariant synthesis

An  algorithm  for  inferring  invariants  in  propositional  STRIPS  domains  is  proposed  by  Rintanen  [45,46].  It  synthesises 
not  only  mutual-exclusion  invariants,  but  also  other  types  of  invariants.  The  algorithm  works  on  a  ground  representation 
of the domain and, starting from an inductive deﬁnition of invariants as formulae that are true in the initial state and are 

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

57

preserved  by  the  application  of  every  action,  the  algorithm  is  based  on  an  iterative  computation  of  a  ﬁx-point,  which  is 
useful for reasoning about all the invariants of a domain at the same time rather than inferring some invariants ﬁrst and 
then using them for inferring others.

Rintanen’s algorithm uses a guess, check and repair approach but, unlike our technique, it starts from stronger invariant 
candidates and then progressively weakens them if they are not preserved by the actions. Thus, the repair phase starts by 
considering a less general invariant instead of a more general one. For example, let us consider the schema σ = x (cid:14)= y →
P (x, y) ∨ Q ( y, z) as a potential invariant (all the invariants considered have this implicative form). One of the weakening 
operation  consists  of  identifying  two  variables.  In  this  case,  if  z is  set  equal  to  x,  the  weaker  candidate  σ = x (cid:14)= y →
P (x, y) ∨ Q ( y, x) is obtained and checked.

This technique has been successfully used within both Graphplan based planners [8], where it helps to identify unreach-
able subgoals, and SAT-based planners [39], where it can be useful to reduce the amount of search required. However, even 
though its implementation is limited to invariants involving two formulas at the most, it incurs a high performance penalty 
on large instances.

Rintanen  [47] extends  the  original  algorithm  presented  in  Rintanen  [45,46] in  order  to  handle  temporal  domains.  As 
in the original algorithm, the temporal one works on ground domains, not using a lifted representation at any stage. The 
format of the invariants found is l1 V (r) l2, where l1 and l2 are positive or negative ground facts, r is a ﬂoating point number, 
and the formula says that either l1 is true or l2 is true over the interval [0..r] relative to the current time point. If r = inf , 
the formula means that if l1 is false, then l2 will remain true forever. Since Rintanen’s invariant synthesis exploits the initial 
conditions and the ground representation of the domain, it usually ﬁnds a broader range of invariants than our technique. 
However,  this  makes  the  invariant  synthesis  computationally  costly.  Reachability  analysis  on  a  ground  representation  of 
the  planning  instances  is  computationally  very  expensive,  so  while  our  algorithm  takes  a  few  seconds  to  run,  Rintanen’s 
synthesis  requires  tens  of  minutes  to  ﬁnd  invariants  in  several  domains  (see  Table 1  in  Rintanen  [47]).  In  recent  work, 
Rintanen [48] has proposed a hybrid algorithm that performs the basic invariance tests with a ground method, but grounds 
the actions and formulas only with respect to a smaller number of objects in order to reduce complexity.

We do not directly compare our technique against Rintanen’s algorithm in Section 10 because the two techniques aim 
to ﬁnd different types of invariants (our focuses on mutual exclusion invariants, while Rintanen’s tackles a broad range of 
invariant types) and they work on different representations of the problem (lifted versus ground). However, in what follows, 
we give examples of the output of Rintanen’s technique for completeness.

Consider  the  Crewplanning domain  (IPC’08  and  IPC’11).  For  each  crew  member  ci ,  Rintanen’s  algorithm  ﬁnds  ground 

invariants of the type:

not current_day − ci − d j V (inf ) not current_day − ci − dk

which  means  that  if  it  is  day d j for  the  crew  member  ci ,  it  cannot  be  day dk at  the  same  time.  If  there  are k days,  this 
results in k2 invariants for each crew member. All these invariants correspond to the single lifted invariant current_day 0 [1]
that is found by our invariant synthesis. For the same domain, however, Rintanen’s algorithm ﬁnds additional invariants that 
express temporal relations between atoms. Our technique does not aim to ﬁnd this type of invariant. For example, Rintanen’s 
method ﬁnds temporal invariants of the form:

done_sleep − ci − dk V (255) not done_meal − ci − d(k+2)

which means that, for the crew member ci , the atom done_meal in day k + 1 becomes true 255 time units after the atom 
done_sleep was true in day k. In fact, in day k, done_sleep is made true by the end effects of the action sleep. From this time 
point, in order to make done_meal true the day after k + 1, two actions need to be executed:  post_sleep, with duration 195, 
and have_meal with duration 60, for a total time separation of 255 time units. For the Crewplanning domain, the run time of 
our algorithm is 0.29 seconds, while Rintanen’s algorithm has a runtime of 1 minute and 23.24 seconds for hard instances. 
This  is  actually  one  of  the  best  run  times,  since  for  problems  such  as  Parcprinter,  Elevators,  Sokoban,  Transport-numeric
and others, the algorithm has a run time of more than 4 hours. Given these run times, it does not seem plausible to use 
Rintanen’s algorithm as a pre-processing step to improve search in planning, which is one of the most important uses of 
invariant synthesis algorithms.

11.4.  DISCOPLAN

DISCOPLAN (DIScovering State COnstraints for PLANning) [26] is a technique for generating invariants from the non-temporal 
PDDL Level 1 tasks. DISCOPLAN supports conditional effects without compiling them. DISCOPLAN discovers not only mutual 
exclusion invariants, but also other types of invariants: static predicates, simple implicative, (strict) single valuedness and 
n-valuedness, anti-simmetry, OR and XOR invariants.

For mutual exclusion invariants, DISCOPLAN uses a guess, check and repair approach similar to our approach: a hypo-
thetical invariant is generated by simultaneously analysing the preconditions and the effects of each action to see whether 
an instantiation of a literal is deleted whenever another instantiation of the same literal is added. Then, this candidate is 
checked against all the other actions and the initial conditions. If the hypothetical invariant is not found to be valid, then all 
the unsafe actions are collected together and a set of possible reﬁnements are generated. However, whereas our technique 

58

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

tries to reﬁne a candidate as soon as an unsafe action is found, DISCOPLAN tries to address all the unsafe causes at the same 
time while generating reﬁnements. This approach leads to more informed choices on how to reﬁne hypothetical invariants 
and can result in the identiﬁcation of more invariants. However, it is more expensive from a computational point of view, 
which is why DISCOPLAN is often ineﬃcient on big instances.

DISCOPLAN can be used not only for ﬁnding invariants, but also for inferring action-variable domains. An action-variable 
domain is a set that includes all the objects that can be used to instantiate the variables of an action. Such sets of possible 
tuples of variables are found by forward propagation of ground atoms from the initial state. This technique is related to the 
reachability analysis performed by Graphplan [8], but does not implement mutual exclusion calculation.

DISCOPLAN is usually used in combination with SAT encodings of planning problems. In particular, a pre-processing step 
is performed over the domain under consideration in order to ﬁnd invariants and variable domains, then the domain as well 
as the invariants and the variable domains are translated into SAT. Finally, a SAT-based planner is used to solve the resulting 
translated domain. SAT-based planners [39,37] show signiﬁcant speed-up when invariants and action-variable domains are 
used.

11.5.  Type inference module

TIM (Type Inference Module) [20] uses a different approach for ﬁnding invariants in non-temporal PDDL Level 1 domains. 
More  precisely,  TIM  is  a  pre-preprocessing  technique  for  inferring  object  types  on  the  basis  of  the  actions  and  the  initial 
state. Data obtained from this computation is then used for inferring invariants. TIM recognises four kinds of invariants:

1. Identity invariants (for example, considering the domain Blockworld, two objects cannot be at the same place at the same 

time);

2. Unique state invariants (for example, every object must be in at most one place at any time point);
3. State membership invariants (for example, every object must be in at least one place at any time point); and
4. Resource invariants (for example, in a 3-blocks world, there are 4 surfaces).

Invariants of types 1 and 2 correspond to mutual exclusion invariants. The invariants found by TIM have been exploited to 
improve the performance of the STAN planner [22].

11.6.  Knowledge representation and engineering

In  addition  to  works  that  address  the  creation  of  invariants  directly,  there  are  works  in  the  literature  that  highlight 
the  importance  of  multi-valued  state  variables  for  debugging  domain  descriptions  and  for  assisting  the  domain  designer 
in  building  correctly  encoded  domains  [20,7,13].  In  particular,  Cushing  et  al.  [13] analyse  well-studied  IPC  temporal  and 
numeric  domains  and  reveal  several  modelling  errors  that  affect  such  domains.  This  analysis  lead  the  authors  to  suggest 
better ways of describing temporal domains. They identify the direct speciﬁcation of multi-valued state variables as a key 
feature for doing this, and show how this can help domain experts to write correct models.

Other works in the literature use the creation of invariants and state variables as an intermediate step in the translation 
from PDDL to other languages. In particular, Huang et al. [37] introduce SASE, a novel SAT encoding scheme based on the 
SAS+  formalism  [1].  The  state  variables  (extracted  from  invariants)  used  by  SASE  play  a  key  role  in  improving  eﬃciency. 
Since our technique generates a broader set of invariants than related techniques, it results in SAS+ tasks with smaller sets 
of state variables. We speculate that this positively impact SAT-based planners that use an SASE encoding. Testing of this 
hypothesis is future work.

12.  Conclusions and future work

In this paper, we present a technique for automatically ﬁnding mutual exclusion invariants in lifted temporal planning 
domains expressed in PDDL2.1. Our technique builds on Helmert’s invariant synthesis [33], but generalises it and extends it 
to temporal domains. Synthesising invariants for temporal tasks is much more complex than for tasks with instantaneous 
actions because actions can occur simultaneously or concurrently and interfere with each other. For this reason, a simple 
generalisation of Helmert’s approach does not work in temporal settings. In extending the theory to capture the temporal 
case,  we  have  had  to  formulate  invariance  conditions  that  take  into  account  the  full  temporal  structure  of  the  actions  as 
well  as  the  possible  interactions  between  them.  As  a  result,  we  have  constructed  a  technique  that  is  signiﬁcantly  more 
comprehensive  than  related  techniques.  Our  technique  is  presented  here  formally  and  proofs  are  offered  that  support  its 
soundness.

In  contrast  to  the  majority  of  related  approaches,  our  technique  works  at  the  lifted  level  of  the  representation,  so  it 
is  very  eﬃcient.  The  experimental  results  show  that  its  run  time  is  negligible,  while  it  allows  us  to  ﬁnd  a  wider  set  of 
invariants, which in turn results in synthesising a smaller number of state variables to represent a domain. The experiments 
also  indicate  that  the  temporal  planners  that  use  state  variables  to  represent  the  world  may  beneﬁt  from  dealing  with  a 
smaller number of state variables.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

59

Our approach to ﬁnding invariants can be incorporated in any translation from PDDL2.1 to a language based on multi-
valued  state  variables.  For  example,  we  have  used  (a  simpliﬁed  version  of)  the  temporal  invariant  synthesis  described  in 
this paper in our translator from PDDL2.1 to NDDL [5], which is the domain speciﬁcation language of the EUROPA2 planner 
[38]. EUROPA2 has been the core planning technology for several NASA space mission operations. It uses a language based 
on multi-valued state variables that departs from PDDL2.1 in several ways. The use of our translator from PDDL2.1 to NDDL 
has  facilitated  the  testing  of  EUROPA2  against  domains  of  the  IPCs  originally  expressed  in  PDDL2.1  [3,4].  This  originally 
motivated our work on temporal invariant synthesis.

In future work, we plan to extend our experimental evaluation by incorporating our invariant synthesis in other plan-
ners  that  use  a  multi-valued  variable  representation  and  that  are  not  currently  publicly  available.  This  will  allow  us  to 
assess more exhaustively the impact that handling fewer state variables has on the performance of temporal planners. The 
experimental results shown in this paper provide evidence that more research on this is needed.

In addition, we plan to exploit the metric information encoded in planning domains to ﬁnd a broader range of invariants. 
Invariants for domains with metric ﬂuents are interesting and challenging. We envisage that there are two kinds of situations 
to be considered: those in which it can be shown that a linear combination of ﬂuents is invariant (relevant to domains with 
linear  effects  on  variables)  and  those  in  which  metric  ﬂuents  interact  with  propositional  ﬂuents  in  a  more  complex  way. 
For example, one might think of a domain encoding the act of juggling in which the number of balls in the air plus the 
number in the hands is a constant, but the balls in the hand might be encoded propositionally (for example, by a literal
holding_left and  so  on),  while  those  in  the  air  might  be  encoded  as  a  count.  Finding  the  invariant  in  this  case  is  a 
challenging problem since it crosses the propositional and metric ﬂuent spaces.

Finally,  as  shown  in  Example  19,  our  technique  can  be  a  valuable  tool  for  debugging  temporal  planning  domains.  We 

intend to work in this direction by incorporating our technique in validation tools such as VAL [36].

Acknowledgements

We thank Malte Helmert, Gabriele Röger and Jussi Rintanen for making their code for synthesising invariants available, 
William  Cushing  for  helpful  discussions  about  the  conﬁgurations  of  temporal  actions  and  Maria  Fox  and  Derek  Long  for 
insightful discussions on the semantics of PDDL2.1. We also thank the anonymous reviewers for their detailed and rigorous 
reviews. They have greatly contributed in improving our paper. This work has been supported by EPSRC, grant EP/J012157/1, 
Royal Holloway University of London, King’s College London, Politecnico di Torino and NASA Ames Research Center. All the 
research data is included within the paper.

Appendix A.  PDDL2.1 speciﬁcation of the Floortile domain

( d e f i n e ( domain f l o o r − t i l e )
( : requirements : typing : durative− actions )
( : types robot

t i l e c o l o r − o b j e c t )

( : p r e d i c a t e s

( robotAt ? r − robot ?x − t i l e )
( up ?x − t i l e ?y − t i l e )
(down ?x − t i l e ?y − t i l e )
( r i g h t ?x − t i l e ?y − t i l e )
( l e f t ?x − t i l e ?y − t i l e )
( c l e a r ?x − t i l e )
( painted ?x − t i l e ?c − c o l o r )
( robot−has ? r − robot ?c − c o l o r )
( a v a i l a b l e C o l o r ?c − c o l o r )
( free− color ? r − robot ) )

( : durative− action change−color

: parameters (? r − robot ?c − c o l o r ?c2 − c o l o r )
: duration (= ? duration 5)
: c o n d i t i o n ( and ( a t s t a r t
( over a l l

( robot−has ? r ?c ) )
( a v a i l a b l e C o l o r ?c2 ) ) )
( not ( robot−has ? r ?c ) ) )

: e f f e c t

( and ( a t s t a r t

( a t end ( robot−has ? r ?c2 ) ) ) )

( : durative− action paintUp

: parameters (? r − robot ?y − t i l e ?x − t i l e ?c − c o l o r )
: duration (= ? duration 2)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t
( over a l l
( a t s t a r t

( robot−has ? r ?c ) )
( robotAt ? r ?x ) )
( up ?y ?x ) )
( c l e a r ?y ) ) )
( not ( c l e a r ?y ) ) )

: e f f e c t

( and ( a t s t a r t

( a t end ( painted ?y ?c ) ) ) )

60

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

( : durative− action paint−down

: parameters (? r − robot ?y − t i l e ?x − t i l e ?c − c o l o r )
: duration (= ? duration 2)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t
( over a l l
( a t s t a r t

( robot−has ? r ?c ) )
( robotAt ? r ?x ) )
(down ?y ?x ) )
( c l e a r ?y ) ) )
( not ( c l e a r ?y ) ) )

: e f f e c t

( and ( a t s t a r t

( a t end ( painted ?y ?c ) ) ) )

( : durative− action up

: parameters (? r − robot ?x − t i l e ?y − t i l e )
: duration (= ? duration 3)
: c o n d i t i o n ( and ( a t s t a r t
( over a l l
( a t s t a r t

( robotAt ? r ?x ) )
( up ?y ?x ) )
( c l e a r ?y ) ) )

: e f f e c t

( and

( not ( robotAt ? r ?x ) ) )

( a t s t a r t
( a t end ( robotAt ? r ?y ) )
( a t s t a r t
( a t end ( c l e a r ?x ) ) ) )

( not ( c l e a r ?y ) ) )

( : durative− action down

: parameters (? r − robot ?x − t i l e ?y − t i l e )
: duration (= ? duration 1)
: c o n d i t i o n ( and ( a t s t a r t
( over a l l
( a t s t a r t

( robotAt ? r ?x ) )
(down ?y ?x ) )
( c l e a r ?y ) ) )

: e f f e c t

( and ( a t s t a r t

( not ( robotAt ? r ?x ) ) )

( a t end ( robotAt ? r ?y ) )
( a t s t a r t
( a t end ( c l e a r ?x ) ) ) )

( not ( c l e a r ?y ) ) )

( : durative− action r i g h t

: parameters (? r − robot ?x − t i l e ?y − t i l e )
: duration (= ? duration 1)
: c o n d i t i o n ( and ( a t s t a r t
( over a l l
( a t s t a r t

( robotAt ? r ?x ) )
( r i g h t ?y ?x ) )
( c l e a r ?y ) ) )

: e f f e c t

( and ( a t s t a r t

( not ( robotAt ? r ?x ) ) )

( a t end ( robotAt ? r ?y ) )
( a t s t a r t
( a t end ( c l e a r ?x ) ) ) )

( not ( c l e a r ?y ) ) )

( : durative− action l e f t

: parameters (? r − robot ?x − t i l e ?y − t i l e )
: duration (= ? duration 1)
: c o n d i t i o n ( and ( a t s t a r t
( over a l l
( a t s t a r t

( robotAt ? r ?x ) )
( l e f t ?y ?x ) )
( c l e a r ?y ) ) )

: e f f e c t

( and ( a t s t a r t

( not ( robotAt ? r ?x ) ) )

( a t end ( robotAt ? r ?y ) )
( a t s t a r t
( a t end ( c l e a r ?x ) ) ) )

( not ( c l e a r ?y ) ) )

)

Appendix B.  PDDL2.1 speciﬁcation of the Depot domain

( d e f i n e ( domain Depot )
( : requirements : typing : durative− actions )
( : types place l o c a t a b l e − o b j e c t
depot d i s t r i b u t o r − place
truck h o i s t s u r f a c e − l o c a t a b l e
p a l l e t c r a t e − s u r f a c e )

( : p r e d i c a t e s ( a t ?x − l o c a t a b l e ?y − place )

( on ?x − c r a t e ?y − s u r f a c e )
( in ?x − c r a t e ?y − truck )
( l i f t i n g ?x − h o i s t ?y − c r a t e )
( a v a i l a b l e ?x − h o i s t )
( c l e a r ?x − s u r f a c e ) )

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

61

( : durative− action Drive
: parameters (? x − truck ?y − place ?z − place )
: duration (= ? duration 10)
: c o n d i t i o n ( and ( a t s t a r t
: e f f e c t

( a t ?x ?y ) ) )
( not ( a t ?x ?y ) ) )

( and ( a t s t a r t

( a t end ( a t ?x ?z ) ) ) )

( : durative− action L i f t
: parameters (? x − h o i s t ?y − c r a t e ?z − s u r f a c e ?p − place )
: duration (= ? duration 1)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t
( a t s t a r t

( a t s t a r t
( a t s t a r t

( a v a i l a b l e ?x ) )
( on ?y ?z ) )

( a t ?x ?p ) )
( a t ?y ?p ) )
( c l e a r ?y ) ) )
( not ( a t ?y ?p ) ) )
( not ( c l e a r ?y ) ) ) ( a t s t a r t
( c l e a r ?z ) )

( a t s t a r t

( a t s t a r t

: e f f e c t

( and ( a t s t a r t
( a t s t a r t
( a t s t a r t

( l i f t i n g ?x ?y ) )

( not ( a v a i l a b l e ?x ) ) )

( not ( on ?y ?z ) ) ) ) )

( : durative− action Drop
: parameters (? x − h o i s t ?y − c r a t e ?z − s u r f a c e ?p − place )
: duration (= ? duration 1)
: c o n d i t i o n ( and ( over a l l
( over a l l

( a t ?x ?p ) )
( c l e a r ?z ) )

( over a l l
( over a l l

( a t ?z ?p ) )
( l i f t i n g ?x ?y ) ) )

: e f f e c t

( and ( a t end ( a v a i l a b l e ?x ) )
( a t end ( a t ?y ?p ) )
( a t end ( c l e a r ?y ) ) ( a t end ( on ?y ?z ) ) ) )

( a t end ( not ( c l e a r ?z ) ) )

( a t end ( not ( l i f t i n g ?x ?y ) ) )

( : durative− action Load
: parameters (? x − h o i s t ?y − c r a t e ?z − truck ?p − place )
: duration (= ? duration 3)
: c o n d i t i o n ( and ( over a l l
( over a l l

( a t ?x ?p ) )
( l i f t i n g ?x ?y ) ) )
( and ( a t end ( not ( l i f t i n g ?x ?y ) ) )
( a t end ( a v a i l a b l e ?x ) ) ) )

( over a l l

: e f f e c t

( a t ?z ?p ) )

( a t end ( in ?y ?z ) )

( : durative− action Unload
: parameters (? x − h o i s t ?y − c r a t e ?z − truck ?p − place )
: duration (= ? duration 4)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t

( a t ?x ?p ) )
( a v a i l a b l e ?x ) )

( a t s t a r t

( over a l l

( a t ?z ?p ) )

( in ?y ?z ) ) )

: e f f e c t

( and ( a t s t a r t
( a t s t a r t

( not ( in ?y ?z ) ) )
( l i f t i n g ?x ?y ) ) ) )

( a t s t a r t

( not ( a v a i l a b l e ?x ) ) )

)

Appendix C.  PDDL2.1 speciﬁcation of the Rovers domain

( d e f i n e ( domain Rover )
( : requirements : typing : durative− actions )
( : types rover waypoint s t o r e camera mode lander o b j e c t i v e )

( : p r e d i c a t e s ( a t ?x − rover ?y − waypoint )

( a t _ l a n d e r ?x − lander ?y − waypoint )
( c a n _ t r a v e r s e ? r − rover ?x − waypoint ?y − waypoint )
( e q u i p p e d _ f o r _ s o i l _ a n a l y s i s ? r − rover )
( e q u i p p e d _ f o r _ r o c k _ a n a l y s i s ? r − rover )
( equipped_for_imaging ? r − rover )
( empty ? s − s t o r e )
( h a v e _ r o c k _ a n a l y s i s ? r − rover ?w − waypoint )
( h a v e _ s o i l _ a n a l y s i s ? r − rover ?w − waypoint )
( f u l l ? s − s t o r e )
( c a l i b r a t e d ?c − camera ? r − rover )
( supports ?c − camera ?m − mode)
( a v a i l a b l e ? r − rover )
( v i s i b l e ?w − waypoint ?p − waypoint )
( have_image ? r − rover ?o − o b j e c t i v e ?m − mode)
( communicated_soil_data ?w − waypoint )
( communicated_rock_data ?w − waypoint )
( communicated_image_data ?o − o b j e c t i v e ?m − mode)
( a t _ s o i l _ s a m p l e ?w − waypoint )
( at_rock_sample ?w − waypoint )
( v i s i b l e _ f r o m ?o − o b j e c t i v e ?w − waypoint )
( s t o r e _ o f ? s − s t o r e ? r − rover )

62

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

( c a l i b r a t i o n _ t a r g e t ? i − camera ?o − o b j e c t i v e )
( on_board ? i − camera ? r − rover )
( channel_free ? l − lander ) )

( : durative− action navigate
: parameters (? x − rover ?y − waypoint ?z − waypoint )
: duration (= ? duration 5)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t

( c a n _ t r a v e r s e ?x ?y ?z ) )
( a t ?x ?y ) )
( not ( a t ?x ?y ) ) )

: e f f e c t

( and ( a t s t a r t

( over a l l

( a t s t a r t

( a v a i l a b l e ?x ) )

( v i s i b l e ?y ?z ) ) )

( a t end ( a t ?x ?z ) ) ) )

( : durative− action sampl e_ soil
: parameters (? x − rover ? s − s t o r e ?p − waypoint )
: duration (= ? duration 10)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t
( a t s t a r t
( a t s t a r t

( a t ?x ?p ) )
( a t _ s o i l _ s a m p l e ?p ) )
( e q u i p p e d _ f o r _ s o i l _ a n a l y s i s ?x ) )
( s t o r e _ o f ? s ?x ) )

( a t s t a r t

( a t s t a r t

( a t ?x ?p ) )

( empty ? s ) ) )

: e f f e c t

( and ( a t s t a r t

( not ( empty ? s ) ) )

( a t end ( f u l l ? s ) )

( a t end ( h a v e _ s o i l _ a n a l y s i s ?x ?p ) )
( a t end ( not ( a t _ s o i l _ s a m p l e ?p ) ) ) ) )

( : durative− action sample_rock
: parameters (? x − rover ? s − s t o r e ?p − waypoint )
: duration (= ? duration 8)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t
( a t s t a r t
( a t s t a r t
( a t s t a r t

( a t ?x ?p ) )
( at_rock_sample ?p ) )
( e q u i p p e d _ f o r _ r o c k _ a n a l y s i s ?x ) )
( s t o r e _ o f ? s ?x ) )
( empty ? s ) ) )
( not ( empty ? s ) ) )

: e f f e c t

( and ( a t s t a r t

( a t s t a r t

( a t end ( f u l l ? s ) )

( a t ?x ?p ) )

( a t end ( h a v e _ r o c k _ a n a l y s i s ?x ?p ) )
( a t end ( not ( at_rock_sample ?p ) ) ) ) )

( : durative− action drop
: parameters (? x − rover ? s − s t o r e )
: duration (= ? duration 1)
: c o n d i t i o n ( and ( a t s t a r t
: e f f e c t

( and ( a t end ( not ( f u l l ? s ) ) )

( s t o r e _ o f ? s ?x ) )

( a t s t a r t
( a t end ( empty ? s ) ) ) )

( f u l l ? s ) ) )

( : durative− action c a l i b r a t e
: parameters (? r − rover ? i − camera ? t − o b j e c t i v e ?w − waypoint )
: duration (= ? duration 5)
: c o n d i t i o n ( and ( a t s t a r t
( a t s t a r t
( a t s t a r t

( equipped_for_imaging ? r ) )
( c a l i b r a t i o n _ t a r g e t ? i ? t ) )
( v i s i b l e _ f r o m ? t ?w) )
)

( a t end ( c a l i b r a t e d ? i ? r ) )

( a t s t a r t

( over a l l

: e f f e c t

( a t ? r ?w) )

( on_board ? i ? r ) ) )

( : durative− action take_image
: parameters (? r − rover ?p − waypoint ?o − o b j e c t i v e ? i − camera ?m − mode)
: duration (= ? duration 7)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t
( over a l l
( over a l l
( over a l l
( over a l l

( c a l i b r a t e d ? i ? r ) )
( on_board ? i ? r ) )
( equipped_for_imaging ? r ) )
( supports ? i ?m)
( v i s i b l e _ f r o m ?o ?p ) )
( a t ? r ?p ) ) )

)

: e f f e c t

( and ( a t end ( have_image ? r ?o ?m) )

( a t end ( not ( c a l i b r a t e d ? i ? r ) ) ) ) )

( : durative− action communicate_soil_data
: parameters (? r − rover ? l − lander ?p − waypoint ?x − waypoint ?y − waypoint )
: duration (= ? duration 10)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t
( a t s t a r t
( a t s t a r t

( a t ? r ?x ) )
( h a v e _ s o i l _ a n a l y s i s ? r ?p ) )
( v i s i b l e ?x ?y ) )
( channel_free ? l ) ) )

( a t _ l a n d e r ? l ?y ) )

( a v a i l a b l e ? r ) )

( a t s t a r t

( over a l l

: e f f e c t

( and ( a t s t a r t

( not ( a v a i l a b l e ? r ) ) )

( a t s t a r t

( not ( channel_free ? l ) ) )

( a t end ( channel_free ? l ) )
( a t end ( communicated_soil_data ?p ) ) ( a t end ( a v a i l a b l e ? r ) ) ) )

( : durative− action communicate_rock_data
: parameters (? r − rover ? l − lander ?p − waypoint ?x − waypoint ?y − waypoint )
: duration (= ? duration 10)
: c o n d i t i o n ( and ( over a l l

( a t _ l a n d e r ? l ?y ) )

( a t ? r ?x ) )

( over a l l

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

63

( a t s t a r t
( a t s t a r t
( a t s t a r t

( h a v e _ r o c k _ a n a l y s i s ? r ?p ) )
( v i s i b l e ?x ?y ) )
( channel_free ? l ) ) )

( a t s t a r t

( a v a i l a b l e ? r ) )

: e f f e c t

( and ( a t s t a r t

( not ( a v a i l a b l e ? r ) ) )

( a t s t a r t

( not ( channel_free ? l ) ) )

( a t end ( channel_free ? l ) )
( a t end ( communicated_rock_data ?p ) ) ( a t end ( a v a i l a b l e ? r ) ) ) )

( : durative− action communicate_image_data
: parameters (? r − rover ? l − lander ?o − o b j e c t i v e ?m − mode ?x − waypoint

?y − waypoint )
: duration (= ? duration 15)
: c o n d i t i o n ( and ( over a l l
( a t s t a r t
( a t s t a r t
( a t s t a r t

( over a l l

( a t ? r ?x ) )
( have_image ? r ?o ?m) )
( v i s i b l e ?x ?y ) )
( channel_free ? l ) ) )

( a t _ l a n d e r ? l ?y ) )

( a t s t a r t

( a v a i l a b l e ? r ) )

: e f f e c t

( and ( a t s t a r t

( not ( a v a i l a b l e ? r ) ) )

( a t s t a r t

( not ( channel_free ? l ) ) )

( a t end ( channel_free ? l ) )
( a t end ( communicated_image_data ?o ?m) )

( a t end ( a v a i l a b l e ? r ) ) ) ) )

Appendix D.  PDDL2.1 speciﬁcation of the DataProcessing domain

( d e f i n e ( domain DataProcessing )
( : requirements : typing : durative− actions : negative− preconditions )
( : types reg d i r − f i l e )
( : constants t r a s h − d i r )

( : p r e d i c a t e s ( i d l e ? f − f i l e )

( compressed ? f − f i l e )
( uncompressed ? f − f i l e )
( a t ? f − f i l e ?d − d i r ) )

( : durative− action Create
: parameters (? f − f i l e ?d − d i r )
: duration (= ? duration 1)
: c o n d i t i o n ( and ( a t s t a r t
( over a l l
( a t end ( f o r a l l
( and ( a t end ( i d l e ? f ) )

( f o r a l l
( f o r a l l

: e f f e c t

(? x − d i r )
(? x − d i r )

( not ( a t ? f ?x ) ) ) )
( not ( a t ? f ?x ) ) ) )

(? x − d i r )
( a t end ( a t ? f ?d ) ) ) )

( not ( a t ? f ?x ) ) ) ) )

( : durative− action Remove
: parameters (? f − f i l e ?d − d i r )
: duration (= ? duration 1)
: c o n d i t i o n ( and ( a t s t a r t
( over a l l

( i d l e ? f ) ) ( a t s t a r t
( not ( i d l e ? f ) ) ) )

( a t ? f ?d ) )

: e f f e c t

( and ( a t s t a r t

( not ( i d l e ? f ) ) )

( a t end ( not ( a t ? f ?d ) ) )

( a t end ( a t ? f

t r a s h ) ) ( a t end ( i d l e ? f ) ) ) )

( : durative− action Compress
: parameters (? f s − f i l e ? f t − f i l e ?d − d i r )
: duration (= ? duration 5)
: c o n d i t i o n ( and ( a t s t a r t
( a t s t a r t
( over a l l
( over a l l
( a t end ( f o r a l l

( i d l e ? f s ) ) ( a t s t a r t
( f o r a l l
( f o r a l l
( not ( i d l e ? f s ) ) )

( a t ? f s ?d ) )

(? x − d i r ) ( not ( a t ? f t ?x ) ) ) )
(? x − d i r ) ( not ( a t ? f t ?x ) ) ) )

: e f f e c t

( and ( a t s t a r t

( not ( i d l e ? f s ) ) )

( a t end ( i d l e ? f t ) )

( a t end ( compressed ? f t ) )

(? x − d i r ) ( not ( a t ? f t ?x ) ) ) ) )

( a t end ( i d l e ? f s ) )
( a t end ( a t ? f t ?d ) ) ) )

( : durative− action Uncompress
: parameters (? f s − f i l e ? f t − f i l e ?d − d i r )
: duration (= ? duration 5)
: c o n d i t i o n ( and ( a t s t a r t
( a t s t a r t
( over a l l
( over a l l
( a t end ( f o r a l l

( i d l e ? f s ) ) ( a t s t a r t
( f o r a l l
( f o r a l l
( not ( i d l e ? f s ) ) )

( a t ? f s ?d ) )

(? x − d i r ) ( not ( a t ? f t ?x ) ) ) )
(? x − d i r ) ( not ( a t ? f t ?x ) ) ) )

(? x − d i r ) ( not ( a t ? f t ?x ) ) ) ) )

: e f f e c t

( and ( a t s t a r t

( not ( i d l e ? f s ) ) )
( a t end ( uncompressed ? f t ) )

( a t end ( i d l e ? f s ) )
( a t end ( a t ? f t ?d ) ) ) )

( a t end ( i d l e ? f t ) )

( : durative− action Move
: parameters (? f − f i l e ?ds − d i r ? dt − d i r )
: duration (= ? duration 3)

151–182.

Planning (ECP’99), 1999, pp. 135–147.

Universität Freiburg, 2004.

64

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

: c o n d i t i o n ( and ( a t s t a r t
( over a l l

( i d l e ? f ) ) ( a t s t a r t
( not ( i d l e ? f ) ) ) )

( a t ? f ?ds ) )

: e f f e c t

( and ( a t s t a r t

( not ( i d l e ? f ) ) )

( a t end ( not ( a t ? f ?ds ) ) )

( a t end ( a t ? f ? dt ) )

( a t end ( i d l e ? f ) ) ) ) )

References

[1] C. Bäckström, B. Nebel, Complexity results for SAS+ planning, Comput. Intell. 11 (4) (1995) 625–655.
[2] J.M. Barnes, A. Pandey, D. Garlan, Automated planning for software architecture evolution, in: 2013 28th IEEE/ACM International Conference on Auto-

mated Software Engineering (ASE), 2013, pp. 213–223.

[3] S. Bernardini, D.E. Smith, Developing domain-independent search control for EUROPA2, in: Proc. of the Workshop on Heuristics for Domain-independent 

Planning: Progress, Ideas, Limitations, Challenges, 17th International Conference on Automated Planning and Scheduling, ICAPS’07, 2007.

[4] S. Bernardini, D.E. Smith, Automatically generated heuristic guidance for EUROPA2, in: Proc. of the 9th International Symposium on Artiﬁcial Intelli-

gence, Robotics, and Automation for Space, iSAIRAS’08, 2008.

[5] S. Bernardini, D.E. Smith, Translating pddl2.2. into a constraint-based variable/value language, in: Proc. of the Workshop on Knowledge Engineering for 

Planning and Scheduling, 18th International Conference on Automated Planning and Scheduling, ICAPS’08, 2008.

[6] S. Bernardini, D.E. Smith, Automatic synthesis of temporal invariants, in: Proc. of the Ninth Symposium on Abstraction, Reformulation and Approxima-

tion (SARA-11), Parador de Cardona, Spain, 2011, pp. 10–17.

[7] S. Bernardini, D.E. Smith, Finding mutual exclusion invariants in temporal planning domains, in: Proc. of the Seventh International Workshop on 

Planning and Scheduling for Space (IWPSS-11), Darmstadt, Germany, 2011.

[8] A. Blum, M. Furst, Fast planning through planning graph analysis, Artif. Intell. 90 (1997) 281–300.
[9] B. Bonet, H. Geffner, Planning as heuristic search, Artif. Intell. 129 (2001) 5–33.
[10] Y. Chen, R. Huang, Z. Xing, W. Zhang, Long-distance mutual exclusion for planning, Artif. Intell. 173 (2) (2009) 365–391.
[11] S. Chien, G. Rabideau, R. Knight, R. Sherwood, B. Engelhardt, D. Mutz, T. Estlin, B. Smith, F. Fisher, T. Barret, G. Stebbins, D. Tran, ASPEN – automated 

planning and scheduling for space missions operations, in: 6th International Conference on Space Operations, 2000.

[12] A.J. Coles, A.I. Coles, M. Fox, D. Long, Forward-chaining partial-order planning, in: Proceedings of the Twentieth International Conference on Automated 

Planning and Scheduling (ICAPS-10), 2010, pp. 42–49.

[13] W. Cushing, D. Weld, S. Kambhampati, Mausam, K. Talamadupula, Evaluating temporal planning domains, in: Proc. of the Seventeenth International 

Conference on Automated Planning and Scheduling (ICAPS-07), 2007, pp. 105–112.

[14] M.B. Do, S. Kambhampati, Planning as constraint satisfaction: solving the planning graph by compiling it into CSP, J. Artif. Intell. Res. 132 (2001) 

[15] S. Edelkamp, M. Helmert, Exhibiting knowledge in planning problems to minimize state encoding length, in: Proc. of the Fifth European Conference on 

[16] S. Edelkamp, M. Helmert, The model checking integrated planning system (MIPS), AI Mag. 22 (3) (2001) 67–71.
[17] S. Edelkamp, J. Hoffmann, PDDL2.2: The Language for the Classical Part of the 4th International Planning Competition, Tech. Rep. 195, Albert-Ludwigs-

(2006) 187–231.

ligence (AAAI-98), 1998, pp. 905–912.

(AAAI-2000), 2000, pp. 761–767.

[18] P. Eyerich, R. Mattmüller, G. Röger, Using the context-enhanced additive heuristic for temporal and numeric planning, in: Proc. of the Nineteenth 

International Conference on Automated Planning and Scheduling (ICAPS-09), 2009, pp. 49–64.

[19] R. Fikes, N. Nilsson, STRIPS: a new approach to the application of theorem proving to problem solving, Artif. Intell. 2 (3–4) (1971) 189–208.
[20] M. Fox, D. Long, The automatic inference of state invariants in TIM, J. Artif. Intell. Res. 9 (1998) 367–421.
[21] M. Fox, D. Long, PDDL 2.1: an extension to PDDL for expressing temporal planning domains, J. Artif. Intell. Res. 20 (2003) 61–124.
[22] M. Fox, D. Long, Eﬃcient implementation of the plan graph in STAN, J. Artif. Intell. Res. 10 (2011) 87–115.
[23] J. Frank, A. Jónsson, Constraint based attribute and interval planning, Constraints 8 (4) (2003) 339–364, Special Issue on Planning.
[24] S. Fratini, F. Pecora, A. Cesta, Unifying planning and scheduling as timelines in a component-based perspective, Arch. Control Sci. 18 (2) (2008) 5–45.
[25] A. Gerevini, A. Saetti, I. Serina, An approach to temporal planning and scheduling in domains with predictable exogenous events, J. Artif. Intell. Res. 25 

[26] A. Gerevini, L. Schubert, Inferring state constraints for domain-independent planning, in: Proc. of the Fifteenth National Conference on Artiﬁcial Intel-

[27] A. Gerevini, L. Schubert, Discovering state constraints in discoplan: some new results, in: Proc. of the 17th National Conference on Artiﬁcial Intelligence 

[28] M. Ghallab, H. Laruelle, Representation and control in IxTeT, temporal planner, in: Proc. of the Second International Conference on Artiﬁcial Intelligence 

Planning Systems (AIPS-94), AAAI Press, 1994, pp. 61–67.

[29] N. Ghosh, S.K. Ghosh, An intelligent approach for security management of an enterprise network using planner, in: D.K. Pratihar, L.C. Jain (Eds.), 

Intelligent Autonomous Systems: Foundations and Applications, Springer-Verlag, 2010, pp. 187–214, Ch. 9.

[30] K. Golden, A domain description language for data processing, in: Proceedings of the ICAPS’03 Workshop on PDDL, 2003.
[31] P. Haslum, A. Botea, M. Helmert, B. Bonet, S. Koenig, Domain-independent construction of pattern database heuristics for cost-optimal planning, in: 

Proc. of the Twenty-Second National Conference on Artiﬁcial Intelligence (AAAI-07), 2007, pp. 1007–1012.

[32] M. Helmert, The Fast Downward planning system, J. Artif. Intell. Res. 26 (2006) 191–246.
[33] M. Helmert, Concise ﬁnite-domain representations for PDDL planning tasks, Artif. Intell. 3 (17) (2009) 503–535.
[34] M. Helmert, H. Geffner, Unifying the causal graph and additive heuristics, in: Proc. of the Eighteenth International Conference on Automated Planning 

and Scheduling (ICAPS-08), 2008, pp. 140–147.

[35] J. Hoffmann, B. Nebel, The FF planning system: fast plan generation through heuristic search, J. Artif. Intell. Res. 14 (2001) 253–302.
[36] R. Howey, D. Long, M. Fox, Val: automatic plan validation, continuous effects and mixed initiative planning using pddl, in: 16th IEEE International 

Conference on Tools with Artiﬁcial Intelligence, 2004, pp. 294–301.

[37] R. Huang, Y. Chen, W. Zhang, A novel transition based encoding scheme for planning as satisﬁability, in: Proc. of the Twenty-Forth National Conference 

on Artiﬁcial Intelligence (AAAI-10), vol. 2, AAAI Press, 2010, pp. 89–94.
[38] M. Iatauro, EUROPA main wiki page, http://github.com/nasa/europa/wiki, 2017.
[39] H. Kautz, B. Selman, Unifying SAT-based and graph-based planning, in: Proc. of the Sixteenth International Joint Conference on Artiﬁcial Intelligence 

(IJCAI-99), Morgan Kaufmann Publishers Inc., 1999, pp. 318–325.

[40] Z. Liu, A. Ranganathan, A. Riabov, A planning approach for message-oriented semantic web service composition, in: Proceedings of the 22nd National 

Conference on Artiﬁcial Intelligence – Volume 2, AAAI’07, AAAI Press, 2007, pp. 1389–1394.

[41] D. McDermott, The 1998 AI planning systems competition, AI Mag. 21 (2) (2000) 35–55.
[42] N. Muscettola, HSTS: integrating planning and scheduling, in: M. Zweben, M. Fox (Eds.), Intelligent Scheduling, Morgan Kauffmann, 1994, pp. 451–469.

S. Bernardini et al. / Artiﬁcial Intelligence 258 (2018) 1–65

65

[43] E. Pednault, Toward a Mathematical Theory of Plan Synthesis, Ph.D. thesis, Stanford University, Department of Electrical Engineering, 1986.
[44] S. Richter, M. Westphal, The LAMA planner: guiding cost-based anytime planning with landmarks, J. Artif. Intell. Res. 39 (1) (Sep. 2010) 127–177.
[45] J. Rintanen, An iterative algorithm for synthesizing invariants, in: Proc. of the Seventeenth National Conference on Artiﬁcial Intelligence (AAAI-00), 

[46] J. Rintanen, Regression for classical and nondeterministic planning, in: Proc. of the 18th European Conference on Artiﬁcial Intelligence (ECAI-08), IOS 

[47] J. Rintanen, Constraint-based algorithm for computing temporal invariants, in: Proc. of the European Conference on Logic in Artiﬁcial Intelligence 

2000, pp. 806–811.

Press, 2008, pp. 568–571.

(JELIA-14), Springer-Verlag, 2014, pp. 665–673.

17), AAAI Press, 2017, pp. 3644–3650.

[48] J. Rintanen, Schematic invariants by reduction to ground invariants, in: Proceedings of the Thirty-First AAAI Conference on Artiﬁcial Intelligence (AAAI-

[49] V. Vidal, The YAHSP planning system: forward heuristic search with lookahead plans analysis, in: Proceedings of the 4th International Planning Com-

petition (IPC-2004), Whistler, BC, Canada, Jun. 2004, pp. 59–60.

