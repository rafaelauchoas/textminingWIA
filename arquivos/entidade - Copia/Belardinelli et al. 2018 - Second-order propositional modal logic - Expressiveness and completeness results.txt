Artiﬁcial Intelligence 263 (2018) 3–45

Contents lists available at ScienceDirect

Artiﬁcial  Intelligence

www.elsevier.com/locate/artint

Second-order  propositional  modal  logic:  Expressiveness  and 
completeness  results
Francesco Belardinelli a,∗
a Laboratoire IBISC, UEVE & IRIT Toulouse, France
b Department of Computer Science, University of Liverpool, UK
c LORIA, CNRS/Université de Lorraine, France

, Wiebe van der Hoek b,  Louwe  B. Kuijer b,c

a  r  t  i  c  l  e 

i  n  f  o

a  b  s  t  r  a  c  t

Article history:
Received 16 July 2016
Received in revised form 14 February 2018
Accepted 14 July 2018
Available online 18 July 2018

Keywords:
Modal logic
Knowledge representation
Second-order propositional modal logic
Epistemic logic
Local properties

In this paper we advance the state-of-the-art on the application of second-order propo-
sitional  modal  logic  (SOPML)  in  the  representation  of  individual  and  group  knowledge, 
as well as temporal and spatial reasoning. The main theoretical contributions of the pa-
per  can  be  summarised as  follows.  Firstly,  we  introduce  the  language  of  (multi-modal) 
SOPML and interpret it on a variety of different classes of Kripke frames according to the 
features  of  the  accessibility  relations  and  of  the  algebraic  structure  of  the  quantiﬁcation 
domain of propositions. We provide axiomatisations for some of these classes, and show 
that  SOPML  is  unaxiomatisable  on  the  remaining  classes.  Secondly,  we  introduce  novel 
notions of (bi)simulations and prove that they indeed preserve the interpretation of formu-
las in (the universal fragment of) SOPML. Then, we apply this formal machinery to study 
the expressiveness of Second-order Propositional Epistemic Logic (SOPEL) in representing 
higher-order  knowledge,  i.e.,  the  knowledge  agents  have  about  other  agents’  knowledge, 
as well as graph-theoretic notions (e.g., 3-colorability, Hamiltonian paths, etc.). The ﬁnal 
outcome is a rich formalism to represent and reason about relevant concepts in artiﬁcial 
intelligence, while still having a model checking problem that is no more computationally 
expensive than that of the less expressive quantiﬁed boolean logic.

© 2018 Elsevier B.V. All rights reserved.

1.  Introduction

Modal logic is nowadays a well-established area in mathematical logic, which has also become one of the most popular 
formal frameworks in artiﬁcial intelligence for knowledge representation and reasoning [7,26]. This success is due to several 
reasons, including an expressive and ﬂexible formal language, which enjoys nice computational properties. In particular, at 
the core of the semantics of modal logic lies the notion of world, or state. Indeed, this concept is very natural when studying 
computational notions (a system evolving over time from a previous to a successive state), accounts of agency (states that 
are preferred, desired, or epistemically possible), and of interaction (states that can be winning, losing, terminal, initial, etc.). 
Indeed, distributed computing [25], reactive systems [43], multi-agent systems [32], and game theory [31] have all beneﬁted 
from the application of tools and techniques from modal logic, and this list is by no means exhaustive. Most importantly, 
the worlds in the models for modal logic are connected by means of indexed relations  Ra , for some index a, which model 
(program) transitions, epistemic or desired alternatives, or the effect of possible moves, where index a can assume a number 

* Corresponding author.

E-mail addresses: belardinelli@ibisc.fr (F. Belardinelli), wiebe@liverpool.ac.uk (W. van der Hoek), louwe.kuijer@liverpool.ac.uk (L.B. Kuijer).

https://doi.org/10.1016/j.artint.2018.07.004
0004-3702/© 2018 Elsevier B.V. All rights reserved.

4

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

of readings: a speciﬁc program, a dimension of time, say, future or past, an agent, a move, etc. Each accessibility relation Ra
in the semantics is then paired with a necessity operator (cid:2)a in the modal language, where a formula (cid:2)aϕ is then true in 
a world  w of a model, if ϕ is true in every world  v that is a-accessible from  w (see Deﬁnition 8 for a formal deﬁnition). 
Informally, this may be read as: after every execution of a, in each future time along dimension a, in every world considered 
possible or desired by agent a, or in every world that is the result of performing move a, formula ϕ holds.

The language of modal logic provides a crisp, variable-free way of expressing a variety of properties of interest. It is also 
important to realise that there is not just one modal logic: although the well-known normal axiomatisation K characterises 
the class of validities on all models for modal logic, this does not mean that all logics for, say, agency, are the same and 
correspond  to  K.  It  only  means  that  they  are  typically  extensions  of  K.  As  a  simple  example,  the  property  (i) (cid:2)aϕ → ϕ
appears  reasonable  when  (cid:2)a denotes  ‘agent  a knows  that  . . . ’,  but  is  perhaps  less  desirable  when  it  is  read  as  ‘agent  a
believes  that  . . . ’,  as  philosophically  knowledge  is  analysed  as  truthful  belief  [28].  One  of  the  reasons  for  the  success  of 
modal logic is that in many relevant cases a syntactic scheme corresponds to an additional constraint on the accessibility 
relation  Ra: in the case of (i), reﬂexivity of  Ra is, in a precise sense, suﬃcient and necessary for its validity.

To appreciate this point, we use a little bit more detail (we assume some familiarity with modal logic, precise deﬁnitions 
are given in Section 2). As already mentioned, central in the semantics of modal logic is the notion of (Kripke) frame F , 
which  comprises  of  a  set  W of  worlds  and  accessibility  relations  Ra,  for  indices  a ∈ I .  We  can  then  deﬁne  a  notion  of 
validity |= on frames and formulate the result mentioned above as follows:

Ra is reﬂexive iff F |= (cid:2)aϕ → ϕ, for all formulas ϕ

(1)

Characterisations  such  as  (1) are  referred  to  as  correspondence results [6],  because  they  establish  a  correspondence  be-
tween a ﬁrst-order property on frames (i.e., reﬂexivity) and a modal validity (i.e., (i)). Another example of correspondence 
is that between the ﬁrst-order formula ∀x∀ y(Ra(x, y) → Rb(x, y)) and modal schema (cid:2)bϕ → (cid:2)aϕ, which intuitively says 
that, e.g., whatever is achieved by program b, is also achieved by a, or that a knows at least as much as b.

Mathematically elegant and powerful as correspondence theory may be, it also has shortcomings. Firstly, note that in the 
case of (1), correspondence is deﬁned globally, i.e., (i) has to be valid throughout the frame. This means that for instance 
(using a doxastic reading of (i)), we cannot model situations in which a’s beliefs are true, but b does not know that. Indeed, 
if the truthfulness of agent a’s beliefs is tantamount to the validity of (i), then (ii) Kb((cid:2)aϕ → ϕ) is also a validity, enforcing 
agent b’s knowledge.

Secondly,  in  (1) quantiﬁcation  appears  at  the  meta-,  and  therefore  the  outermost,  level.  It  is  therefore  impossible  to 
distinguish  (and  to  express  in  the  language  of  modal  logic)  the  following  two  situations:  in  the  ﬁrst, b knows  that a has 
perfect  information  and  is  a  perfect  reasoner,  and  therefore,  b knows  a priori that  whatever  a believes  must  be  correct. 
Informally,  this  would  be  represented  as  Kb( for all φ ((cid:2)aφ → φ)),  which  is  not  a  well-formed  formula  however.  In  the 
second  situation  b has  veriﬁed,  for  every  ϕ that  a happens  to  believe,  that  ϕ is  in  fact  true.  Informally,  this  would  be 
represented as (for all φ,  Kb((cid:2)aφ → φ)).

that differs from  V in at most the set  V (p) (i.e.,  V

As observed in [3], by allowing for quantiﬁcation over propositions – and thus obtaining the language of second-order 
propositional modal logic (sopml) – both issues mentioned above can be addressed. The formal deﬁnition of ∀pψ is given 
in Deﬁnition 8, but informally, given a valuation  V which tells us in which worlds  V (p) the atom  p is true, ∀pψ holds if 
(cid:6)(q) = V (q) for all q (cid:7)= p), the formula ψ holds. As regards 
for every  V
the ﬁrst example, the sopml formula ∀p((cid:2)a p → p) ∧ ¬Kb∀p((cid:2)a p → p) intuitively expresses that all beliefs of agent a are 
correct, but b does not know this fact. Moreover, the two different readings in the second example can be represented by 
formulas  Kb∀p((cid:2)a p → p) and  ∀p Kb((cid:2)a p → p),  respectively.  Readers  familiar  with  the  philosophy  literature  on  the  topic 
may recognize the difference between  Kb∀p((cid:2)a p → p) and ∀p Kb((cid:2)a p → p) as the distinction between de dicto and de re
quantiﬁcation.

Importantly, the truth of ∀p((cid:2)a p → p) at world w enforces the truthfulness of agent a’s beliefs in w only, therefore this 
is a local property of the frame, as opposed to the global validity of (i). This fact allows agent b to consider (epistemically) 
possible a different world  w

in which (i) does not hold.

(cid:6)

(cid:6)

The aim of this paper is to further the applications of propositional quantiﬁcation and second-order propositional modal 
logic in knowledge representation and reasoning, through exploring and securing their theoretical foundations. In particular, 
the original contributions of the paper can be summarised as follows.

Firstly, in Section 2 we introduce the language of multi-agent second-order propositional modal logic, and provide it with 
a semantics in terms of Kripke frames extended with a domain  D of sets of worlds for the interpretation of quantiﬁcation. 
The differences between our deﬁnition and the existing deﬁnitions of sopml (e.g. [11,21,37]) are that (i) in addition to the 
full, boolean and unrestricted domains of quantiﬁcation that were studied before, we also consider modal domains, and (ii) 
we  use  a  multi-agent  language,  which  allows  us  to  express  higher-order  properties  of  knowledge,  i.e.,  knowledge  about 
other agents’ knowledge, including truthfulness of knowledge, inclusion of one agent’s knowledge in that of another.

In Section 3 we illustrate the richness of the formal framework, particularly to express local properties in modal logic 
(lpml) [16,17]. We compare and contrast our approach with [18], and show that the latter can be subsumed in the account 
here put forward. This validates our endeavour from the viewpoint of applications. However, we maintain that for sopml to 
be adopted as a speciﬁcation language in artiﬁcial intelligence and knowledge representation, appropriate theoretical results 
and formal tools need to be developed.

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

5

To  this  end,  in  Section 4 we  present  a  number  of  results  about  the  axiomatisation  of  several  classes  of  validities.  The 
key  ﬁndings  are  that  (i)  with  the  exception  of  single-agent S5, sopml is  unaxiomatisable  over  all  of  the  commonly  used 
classes of frames, when a full domain of quantiﬁcation is considered; (ii) on frames with a coarser domain of quantiﬁcation,
sopml without a common knowledge operator is axiomatisable, but sopml* with common knowledge is unaxiomatisable in 
general. As a by-product we obtain several undecidability results.

Furthermore, in Section 5 we develop original truth-preserving bisimulations for sopml. Bisimulations bring to the fore 
when two models can be considered the same, and they can be used to test the limits of what can be expressed: when two 
models for a language L are bisimilar but disagree on some property (cid:5) ∈ L(cid:6)
, it shows that (cid:5) is not expressible in L. We 
provide several instances of such occurrences. To conclude, our main aim in this paper is to provide formal tools so as to 
facilitate the use of sopml as a language for knowledge representation, as well as temporal and spatial reasoning in artiﬁcial 
intelligence.

1.1.  Related work

This  contribution  is  inspired  by  a  series  of  papers  on lpml,  an  extension  of  propositional  modal  logic  to  express  local 
properties [16–18]. Here, instead of introducing an ad hoc language (with an adjustment for each local property one has in 
mind), we make use of the general framework of second-order propositional multi-modal logic. In Section 3 we provide a 
detailed comparison of the two approaches.

Mono-modal sopml was ﬁrst considered in [11,21,37], mainly in relation with axiomatisability and (un)decidability ques-
tions.  In  particular,  [21] provided  several  axiomatisations  for  normal  modal  logics  interpreted  on  a  variety  of  classes  of 
frames.  However,  it  considered  only  mono-modal  languages,  whereas  here  we  adopt  a  multi-modal  perspective.  Then, 
[37] proved  decidability  and  independence  results  pertaining  to  second-order  extensions  of  the  mono-modal  logic  S5. 
Notwithstanding these early, signiﬁcant results, the high computational complexity of sopml and some undecidability and 
unaxiomatisability results might partially explain why sopml has been studied far less than propositional modal logic, and 
it has been virtually unexplored as a speciﬁcation language for knowledge representation and reasoning. For instance, only 
recently sopml has been proved complete w.r.t. the algebraic semantics in which quantiﬁcation is interpreted on arbitrary 
meets and joints [33]. Here we consider a multi-modal version of sopml, and its epistemic counterpart: second-order propo-
sitional epistemic logic (sopel).

Among the more recent contributions, [36] shows that there is a validity-preserving translation from second-order logic 
to sopml, for modalities weaker than or equal to S4.2, implying that for these modalities sopml is unaxiomatisable. Here-
after we add to the picture and show that multi-modal S5 is unaxiomatisable as well. Further, [12] provided sopml with 
analogues  of  the  van  Benthem–Rosen  and  Goldblatt–Thomason  theorems,  while  in  [22] propositional  quantiﬁcation  and 
bisimulations are analysed in the context of modal logic. However, the kind of quantiﬁcation considered in [22] is preserved 
by  standard  bisimulations,  and  therefore  the  resulting  logic  is  provably  as  expressive  as  epistemic  logic,  strictly  weaker 
than sopml.  In  [39,40] the  author  proves  that  the  quantiﬁer  alternation  hierarchy  of sopml formulas  induces  an  inﬁnite 
corresponding semantic hierarchy over the class of ﬁnite directed graphs. As a by-product, he obtains that, for this class of 
structures, sopml with the universal modality and Monadic Second-Order Logic are equally expressive.

Propositional quantiﬁcation has also been considered in the context of richer modal languages, namely the temporal log-
ics ltl and ctl. A quantiﬁed version of ltl, called qltl, has been introduced and analysed in [49,48], mainly in relation with 
the  veriﬁcation  of  reactive  systems.  In  particular,  the  model-checking  problem  for  the k-alternation  fragment  was  proved 
to be k-EXPSPACE-complete. More recently, [41] discusses qctl, a quantiﬁed version of the branching-time temporal logic
ctl. The authors prove several complexity and expressivity results for a logic that has more modal operators than sopml. 
They also consider two different kinds of semantics for their logic: the former is comparable to sopml on full frames, while 
the latter is based on tree-unwindings. To our knowledge, no results are known about the relative expressivity of qctl and
sopml. It is also outside the scope of this paper to ﬁnd such results, although it is an interesting question for future research.
More  directly  related  to  the  present  contribution  are  [3,4] by  some  of  the  authors.  In  [3] we  introduced  epistemic 
quantiﬁed  boolean  logic  (eqbl),  an  epistemic  variant  of sopml,  and  provided  axiomatisability  and  model-checking  results. 
Differently from the reference, here we tackle general sopml, deﬁned also on modalities strictly weaker than S5. Indeed, in 
this paper we analyse all normal modalities. Moreover, we provide novel unaxiomatisability and undecidability results, as 
well as give full details on the construction of the canonical models to prove completeness. As regards [4], we deﬁne a novel 
notion of (bi)simulation that generalises the one given therein. Finally, we apply these results to analyse the expressivity of
sopml in capturing relevant properties in temporal and spatial reasoning.

These  investigations  have  been  extended  to  public  announcement  logic  (pal).  Speciﬁcally,  in  [5] the  authors  applied 
propositional quantiﬁcation to pal to analyses arbitrary public announcements and to formalise notions such as preservation, 
successfulness, and knowability. Hereafter we do not consider such extensions and keep on a purely epistemic setting.

2.  Preliminaries

In this section we introduce the formal machinery that will be used throughout the rest of the paper, and we prove some 
preliminary results. First, we present the language of second-order propositional modal logic (sopml), some of its fragments, 
and their interpretation on Kripke frames and models.

6

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

2.1.  The formal languages

To introduce the language of second-order propositional modal logic, we ﬁx a set  A P of atomic propositions and a ﬁnite 

set  I of indices. Any language L built upon  A P (using connectives and modal operators) is said to be a language over A P .

Deﬁnition 1 (SOPML). The language Lsopml contains formulas ψ as deﬁned by the following BNF:

ψ ::= p | ¬ψ | (ψ → ψ) | (cid:2)aψ | ∀pψ

where  p ∈ A P and a ∈ I .

For  this  language  and  those  to  be  introduced  shortly,  we  will  omit  parenthesis  if  doing  so  causes  no  confusion.  The 
language  Lsopml contains  modal  formulas  (cid:2)aψ ,  for  every  index  a ∈ I .  A  general  reading  of  this  would  be  ‘according  to 
the aspect or dimension a, formula ψ holds’. The box can have more concrete interpretations, for instance dynamic (after 
execution of program or action a, ψ holds), temporal or spatial (along dimensions a, ψ ), or deontic (in all situations that 
abide to norm a, ψ is true). Indices may also denote agents, in which case (cid:2)aψ can represent attitudes that relate to goals 
(‘agent a desires  ψ ’,  or  ‘has  ψ as  a  goal’),  that  are  intentional  (agent a intends  to  achieve  ψ ),  or  informational  (‘agent a
believes ψ ’ or ‘a knows that ψ ’). The latter, epistemic interpretation of (cid:2)a will obtain some special attention in this paper, 
and we will write  Kaψ rather than (cid:2)aψ .

Further, the quantiﬁed formula ∀pψ informally says that ‘for all interpretations of  p, ψ obtains’. As usual, the quantiﬁer 

∃ is dual to ∀: ∃pψ ::= ¬∀p¬ψ . Analogously, in Lsopml, (cid:3)aφ is a shorthand for ¬(cid:2)a¬φ, and Ma is dual to  Ka.

Hereafter  we  consider  also  the  extension  L∗

sopml of  Lsopml obtained  by  adding  the  following  clause:  if  ψ is  a  formula, 
then (cid:2)∗ψ is also a formula. Instead of (cid:2)∗ψ , in the epistemic interpretation we will write Cψ (it is common knowledge that 
ψ ). To give a hint of what this operator means in epistemic logic, deﬁne  Eψ (everybody knows that ψ ) as 
a∈I Kaψ . Then, 
formula Cψ intuitively captures the inﬁnite conjunction ψ ∧ Eψ ∧ E Eψ ∧ E E Eψ ∧ . . . (the usual deﬁnitions for (cid:10), ⊥, ∨, ∧, 
and ↔ apply). To sum up, whenever we consider the epistemic interpretation of modal operators, we write  Ka and C , and 
deﬁne formulas ψ in the language L∗
sopel of second-order propositional epistemic logic (sopel) according to the following 
BNF:

(cid:2)

ψ ::= p | ¬ψ | (ψ → ψ) | Kaψ | Cψ | ∀pψ

for  p ∈ A P and a ∈ I . Standard references for modal logic are [7,9], while for epistemic logic we refer to [20,45].

We  write sopml for  the  family  of  logics  that  are  based  on  the  languages  Lsopml and  L∗
paper, it is not very important whether we are considering a language with or without operator (cid:2)∗
interpretation). In the places where the difference between Lsopml and L∗
based on L∗

sompl is important, we write sopml∗

sopml.  Throughout  most  of  the 
(see Deﬁnition 8 for its 
for the logic 

The name ‘second-order propositional modal (epistemic) logic’ is related to second-order quantiﬁcation, as will become 
apparent in Section 3. In particular, this formalism has been studied in relation to monadic second-order logic – mso, see 
[12,36] and also Section 3.

sopml.

Example 2. To give a ﬂavour of the expressivity of L∗
sopml, we present some speciﬁcations written in this language. We use 
variants of (cid:2)a in our notation: their meaning will be clear from the context. Using L∗
sopml one can for instance express that 
agent a believes that agent b always has some unfulﬁlled desires: Ba(cid:2)∗∃p(Db p ∧ ¬p), where operators Ba and Db are used 
to represent the doxastic and desire dimensions for agent a and b respectively, whereas (cid:2)∗
is interpreted on the reachability 
relation w.r.t. all agents’ moves.

As  a  further  example,  formula  (i) ∀p((cid:2)a p → (cid:2)b p) expresses,  in  a  dynamic  context,  that  every  result  guaranteed  by 
program  a is  also  guaranteed  by  program  b,  or,  provided  a  doxastic  interpretation  of  the  box  operator,  agent  b believes 
everything that agent a believes. Deontically, the formula ∃p(O p ∧ ¬p) expresses that the current world is not ideal: there 
are facts that ought to hold, but they do not. Finally, the doxastic-epistemic formula (ii) Kb∃p(Ba p ∧¬p) intuitively expresses 
that agent b knows that agent a’s beliefs are incorrect, while (iii) ∀p(Ba p → p) ∧ (cid:2)α∃q(Baq ∧ ¬q)) denotes that currently, 
agent a’s beliefs are correct, but after executing program α, this ceases to be the case. We remark that by using propositional 
quantiﬁcation  we  can  reason  about  general  properties  of  knowledge,  e.g.,  truthfulness,  inclusion,  equivalence,  of  agents’ 
knowledge and beliefs, as in speciﬁcations (i), (ii), and (iii).

In  this  paper  we  consider  various  fragments  of  L∗
sopml and  Lsopml.  To  begin  with,  the  languages  Lml of  (propositional) 
modal  logic  and  Lel of  (propositional)  epistemic  logic  (L∗
el,  respectively)  are  obtained  by  removing  clause  ∀pψ
from the deﬁnitions of Lsopml and Lsopel (L∗
sopel, respectively). Likewise, the language Lqbf of quantiﬁed boolean 
formulas  omits  clauses  (cid:2)aψ from  Lsopml,  while  propositional  logic  Lpl is  deﬁned  in  a  standard  way  by  considering  only 
propositional connectives. Moreover, the universal fragment L∗

sopml and L∗

sopml is deﬁned by the following BNF:

a−sopml of L∗

ml and  L∗

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

7

Lsopml

Lqbf

L∗
ml

Lml

L∗

sopml

L∗

a−sopml

La−sopml

Lpl

Lap

ψ ::= p | ¬p | (ψ ∧ ψ) | (ψ ∨ ψ) | (cid:2)aψ | (cid:2)∗

ψ | ∀pψ

Fig. 1. Scheme of inclusions among the different languages.

Notice  that  in  L∗

a−sopml negation  applies  to  atoms  only.  Hence,  L∗

a−sopml contains  no  formula  of  the  form  ∃pψ ,  (cid:3)aψ , 
or (cid:3)∗ψ . For convenience, we will also denote the set of atoms  A P by Lap. A special role in this paper will be played by 
the  languages  Lx of  sort  x,  the  set  of  sort  symbols  being  {ap, pl, ml, sopml}.  We  will  shortly  see  that  for  each  sort  x,  the 
language Lx is linked to an interesting class of frames (deﬁned in terms of types  y: see the paragraph above Deﬁnition 8). 
This connection is made precise in Lemma 11, item 2. We summarise the main inclusions between languages in Fig. 1. We 
observe that languages L∗

x are deﬁned only for x ∈ {ml, a − sopml, sopml}.

We now introduce some syntactic notions that will be used throughout the paper. Hereafter we use (cid:7) as a placeholder 

for any unary operator ¬, (cid:2)a, (cid:2)∗

, and  Q for any quantiﬁer ∀, ∃.

Deﬁnition 3 (Subformula and free atoms). The sets Sub(φ) and fr(φ), for the subformulas and free atoms of formula φ ∈ L∗
respectively, are recursively deﬁned as follows:

sopml, 

= {p}
Sub(p)
= {(cid:7)φ} ∪ Sub(φ)
Sub((cid:7)φ)
Sub(φ → φ(cid:6)) = {φ → φ(cid:6)} ∪ Sub(φ) ∪ Sub(φ(cid:6))
Sub(∀pφ) = {∀pφ} ∪ Sub(φ)

= {p}
= fr(φ)

fr(p)
fr((cid:7)φ)
fr(φ → φ(cid:6)) = fr(φ) ∪ fr(φ(cid:6))
fr(∀pφ)

= fr(φ) \ {p}

A sentence is a formula φ with an empty set of free atoms, i.e., fr(φ) = ∅. The set bnd(φ) of bound atoms in φ is deﬁned 
as usual as the set of all atoms q appearing in the scope of any quantiﬁer  Q q. We assume that for each formula φ ∈ L∗
sopml, 
fr(φ) and bnd(φ) are  disjoint.  Actually,  we  impose  that  each  quantiﬁer  binds  a  different  variable.  Both  constraints  can  be 
enforced without loss of generality by renaming bound variables.

We now deﬁne when a formula ψ can substitute an atom  p within a formula. In particular, such a substitution should 

not create any new binding.

Deﬁnition 4 (Free for . . . ). Given an atom p ∈ fr(φ), a formula ψ is free for p in φ iff p does not appear in φ within the scope 
of any quantiﬁer  Q q for q ∈ fr(ψ). Alternatively, we can deﬁne whether ψ is free for p in φ by induction on the structure of 
φ as follows:

for φ atomic,
for φ = (cid:7)φ(cid:6)
for φ = φ(cid:6) → φ(cid:6)(cid:6)
for φ = ∀qφ(cid:6)

,

,

ψ is free for p in φ
ψ is free for p in φ iff it is in φ(cid:6)
, ψ is free for p in φ iff it is in φ(cid:6)

and φ(cid:6)(cid:6)

ψ is free for p in φ iff q /∈ fr(ψ) and ψ is free for p in φ(cid:6)

We ﬁnally introduce a notion of substitution for free formulas.

8

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

Deﬁnition 5 (Substitution). Whenever ψ is free for  p ∈ fr(φ), the substitution φ[p/ψ] is inductively deﬁned as follows:

q[p/ψ]

=

(cid:3)
q
ψ otherwise

for q different from p

((cid:7)φ(cid:6))[p/ψ]
=
(φ(cid:6) → φ(cid:6)(cid:6))[p/ψ] =
(∀rφ(cid:6))[p/ψ]
=

(cid:7)(φ(cid:6)[p/ψ])
(φ(cid:6)[p/ψ]) → (φ(cid:6)(cid:6)[p/ψ])
∀r(φ(cid:6)[p/ψ]), where r is assumed different from p as p ∈ fr(φ)

Intuitively, ψ being free for  p in φ means that a substitution of  p by ψ in φ does not create any new binding. As an 
example, ¬q is free for  p in ∃r(r → p) but not in φ = ∃q(p ↔ q). After we have introduced our semantics, it will be clear 
that, while ∃q(p ↔ q) is actually a validity, if we were to blindly substitute  p with ¬q in φ, we would obtain ∃q(¬q ↔ q), 
which  is  tantamount  to  a  contradiction.  But  note  that,  since  ¬q is  not  free  for  p in  φ,  by  Deﬁnition 5,  φ[p/¬q] is  not 
well-deﬁned. Also note that the procedure above does not guarantee that after a substitution a variable r only occurs in the 
scope of a single quantiﬁer  Q r. For instance, ∀r(r → p)[p/∀r(q → r)] = ∀r(r → ∀r(q → r)). However, reading the semantics, 
it will become clear that the latter formula is equivalent to ∀r(r → ∀s(q → s)): bounded variables can always be renamed 
(so that, in particular, every formula is equivalent to one in which every formula is bound at most once).

Example 6. As  a  further  example  of  the  expressive  power  of sopel,  consider  the  following  speciﬁcation:  agent  b knows 
everything that a knows, and agent c knows this fact, but d does not. This epistemic situation can be recast in Lsopel as the 
following formula:

∀p(Ka p → Kb p) ∧ Kc∀p(Ka p → Kb p) ∧ ¬Kd∀p(Ka p → Kb p)

In  particular,  we  can  reason  further  about  agent d’s  knowledge.  Indeed,  agent d might  know  that a knows  something 
ignored by b, without being able to explicitly point out the content of a’s extra knowledge. This can be recast in Lsopel by 
the following formula:

Kd∃p(Ka p ∧ ¬Kb p)

(2)

However, d could actually know about a speciﬁc fact that a knows, but b ignores, as expressed in the following formula:

∃p Kd(Ka p ∧ ¬Kb p)

(3)

We remark that (3) corresponds to the de re reading of our speciﬁcation, while (2) is its de dicto formalisation. Here we 
do not discuss in detail the de re/de dicto distinction, as it is beyond the scope of the present contribution, and refer instead 
to the seminal paper [46]. In particular, according to our semantics (to be introduced next), (3) is strictly stronger than (and 
entails) (2). Indeed, the implication (3) ⇒ (2) is a validity, but the converse implication (2) ⇒ (3) does not hold in general. 
Thus, among other things, sopel allows us to distinguish the two readings – de re and de dicto – of individual knowledge.

2.2.  Kripke frames and models

To  provide  a  meaning  to  formulas  of  second-order  propositional  modal  logic,  we  consider  multi-modal  Kripke  frames 

and models, extended with a domain for the interpretation of quantiﬁers.

Deﬁnition 7 (Kripke frame). A Kripke frame is a tuple F = (cid:17)W , D, R(cid:18) where

• W is a set of possible worlds;
• D is the domain of propositions, i.e., a subset of 2W ;
• R : I → 2W ×W assigns a binary relation on W to each index in  I .

As is common in propositional modal logic (pml), for every index a ∈ I ,  Ra is an accessibility relation between worlds 
in  W [7].  Differently  from  standard  Kripke  frames,  Deﬁnition 7 includes  a  set  D ⊆ 2W of  “admissible”  propositions  for 
the  interpretation  of  atoms  and  quantiﬁers.  Clearly,  the  Kripke  frames  in  Deﬁnition 7 are  related  to  general frames [7,44]. 
However, there are some notable differences. Firstly, in general frames the domain  D of propositions is a boolean algebra 
with  operators,  whereas  no  such  assumption  is  made  in  the  present  case.  Secondly,  the  language  interpreted  on  general 
frames  is  usually  a  plain  modal  logic,  while  here  we  address  quantiﬁcation  as  well.  Indeed,  propositional  quantiﬁcation 
makes our language strictly more expressive than propositional modal logic interpreted on general frames, as will become 
apparent later on (see for instance Example 10 and recall that pml interpreted on general frames is as expressive as pml
interpreted on Kripke frames).

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

9

The  accessibility  relations  can  satisfy  various  properties,  e.g.,  seriality,  symmetry,  transitivity,  reﬂexivity,  etc.  When 
interpreting  the  language  L∗
sopel we  assume  that  each  Ra is  an  equivalence  relation  (i.e.,  symmetric,  transitive  and  re-
ﬂexive), in line with the epistemic reading of modal operators [45]. Finally, for each agent index a ∈ I and  w ∈ W , we let 
Ra(w) = {w

(cid:6))}. If  Ra is an equivalence relation, then  Ra(w) is the equivalence class of  w according to  Ra.

sopml on Kripke frames, we introduce assignments as functions V : A P → D. Also, for U ∈ D, the 
p
U assigns U to  p and coincides with V on all other atoms. Hence, atoms can only be assigned propositions in 

(cid:6) | Ra(w, w
To interpret formulas in L∗

assignment V
D ⊆ 2W . A Kripke model over F is then deﬁned as a pair M = (cid:17)F , V (cid:18).

We now deﬁne the notion of satisfaction for formulas in L∗

sopml.

Deﬁnition 8 (Semantics). We deﬁne whether Kripke model M = (cid:17)F , V (cid:18) satisﬁes formula ϕ ∈ L∗
ϕ, as follows:

sopml at world w, or (M, w) |=

(M, w) |= p
(M, w) |= ¬ψ
(M, w) |= ψ → ψ (cid:6)
(M, w) |= (cid:2)aψ
(M, w) |= (cid:2)∗ψ
(M, w) |= ∀pψ
(cid:4)

where  R C = (

iff w ∈ V (p)
iff
iff
iff
iff
iff

(M, w) (cid:7)|= ψ
(M, w) (cid:7)|= ψ or (M, w) |= ψ (cid:6)
for all w
for all w
for all U ∈ D, (Mp

(cid:6) ∈ Ra(w), (M, w
(cid:6) ∈ R C (w), (M, w
U , w) |= ψ

(cid:6)) |= ψ
(cid:6)) |= ψ

a∈I Ra)∗

is the reﬂexive transitive closure of 

(cid:4)

a∈I Ra, and Mp

U

= (cid:17)F , V

(cid:18).

p
U

(cid:4)

Given Deﬁnition 8, we say that (cid:2)a is the necessity operator for Ra and that (cid:2)∗

is the necessity operator for the transitive 
a∈I Ra.  By  the  deﬁnition,  a  quantiﬁed  formula  ∀pψ (respectively,  ∃pψ )  is  true  at  world  w iff  for 
reﬂexive  closure  of 
every  (respectively,  some)  assignment  of  propositions  in  D to  atom  p,  ψ is  true.  Further,  as  is  the  case  for  the  common 
knowledge operator  C , (M, w) |= (cid:2)∗ψ iff (M, w
(cid:6)) |= ψ for every world  w
such that 
reachable from  w, i.e., for every  w
, and (iii) for every i < k,  w i = w i+1 or  Ra(w i, w i+1) for 
for some sequence  w 0, . . . , wk of worlds, (i) w 0 = w, (ii) wk = w
some a ∈ I . Hence, in non-epistemic contexts, (cid:2)∗
can be interpreted as a reachability operator, analogous to the common 
knowledge operator C .

The satisfaction set (cid:2)ϕ(cid:3)M of formula ϕ in model M is deﬁned as {w ∈ W | (M, w) |= ϕ}. We omit the subscript M
whenever clear by the context. We now introduce various notions of truth and validity. First, we write (F , V , w) |= φ as a 
shorthand for ((cid:17)F , V (cid:18), w) |= φ. Then, we say that φ is true at  w, or (F , w) |= φ, iff (F , V , w) |= φ for every assignment V ; 
φ is valid in a frame F , or F |= φ, iff (F , w) |= φ for every world  w in F ; φ is valid in a class K of frames, or K |= φ, iff 
F |= φ for every F ∈ K. Also, φ is true in a model M, or M |= φ, iff (M, w) |= φ for every world w. Finally, φ is satisﬁable
iff for some model M and world  w, (M, w) |= φ.

(cid:6)

(cid:6)

(cid:6)

In  the  rest  of  the  paper  we  consider  speciﬁc  classes  of  Kripke  frames  and  models,  which  feature  pre-eminently  in 
the  literature  on sopml [21,44].  To  introduce  them,  we  ﬁrst  deﬁne  operators  [a] : 2W → 2W ,  for  every  a ∈ I ,  such  that 
[a](U ) = {w ∈ W | Ra(w) ⊆ U } while  operator  [  ]∗ : 2W → 2W is  introduced  so  that  [  ]∗(U ) = {w ∈ W | for every n ∈
N,  for every sequence w 0, . . . , wn,  if w 0 = w and for every i < n, w i = w i+1 or Ra(w i, w i+1) for some a ∈ I,  then wn ∈
U }.  Notice  that  for  R C deﬁned  as  the  reﬂexive  transitive  closure  of  ∪a∈I Ra,  we  have  [C](U ) = {w ∈ W | R C (w) ⊆ U } =
[ ]∗(U ).

Deﬁnition 9. A Kripke frame F is
iff

boolean

D is a boolean algebra, i.e., it is closed under intersection, union
and complement
D is a boolean algebra closed under operators [a], for every a ∈ I,
and [ ]∗
D = 2W

modal

full

iff

iff

A Kripke model M = (cid:17)F , V (cid:18) is boolean (modal, full, respectively) whenever the underlying frame F is. We distinguish 
the  class  Kall of  all  Kripke  frames,  the  class  Kbool of  all  boolean  frames,  the  class  Kmodal of  all  modal  frames,  and  the 
class  Kfull of  all  full  frames.  Observe  that,  by  using  an  analogy  with  monadic  second-order  logic,  the  class  of  full  frames 
corresponds to the basic interpretation of sopml, where any frame is uniquely identiﬁed by ﬁxing the set W of worlds and 
accessibility relations, as the domain  D is equal to  2W . On the other hand, the other classes of frames are related to the 
Henkin interpretation of mso, where  D can be a possibly strict subset of  2W (cf. [51]). Hereafter, we often refer to Kall-, 
Kbool-, and Kmodal-frames as non-full frames, even though they do contain full frames.

Furthermore,  within  each  of  the  classes  in  Deﬁnition 9,  we  will  consider  further  conditions  on  the  accessibility  re-
lations Ra:  reﬂexivity  r,  transitivity  t,  and  symmetry  s.  Hereafter,  given  type  y ∈ Y = {all, bool, modal, full} and  subset 
τ ⊆ {r, t, s},  Kτ
y denotes  the  corresponding  class  of  frames  satisfying  the  properties  in τ .  For  simplicity,  Ke
y denotes  class 
K{r,t,s}
y )  of  frames  in  which  all  accessibility  relations  are  equivalences,  that  is,  the  class  of 
y

(which  we  also  write  as  Krts

10

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

epistemic frames for the interpretation of sopel. We deﬁne a function (cid:5): X → Y from language sort symbols to type sym-
bols as follows:  (cid:5)ap = all;  (cid:5)pl = bool;  (cid:5)ml = modal; and (cid:2)sopml = full. In total, we obtain 32 classes Kτ
y of frames. However, we 
only consider 20 of them: the subsets τ ⊆ {r, t, s} corresponding to the 5 normal modalities K, T, S4, B, and S5, combined 
with the 4 types all, bool, modal, and full. Further classes of frames could be introduced, for instance the class where every 
formula  in  L∗
sopml deﬁnes  a  proposition  in  D.  However,  such  a  class  is  not  directly  relevant  for  the  results  below  and  its 
introduction requires a non-trivial generalisation of Kripke frames [44]. Thus, such extensions are beyond the scope of the 
present paper.

Observe that if we deﬁne Th(K) = {φ ∈ L∗

| K |= φ}, then clearly

sopml

Th(Kall) ⊆ Th(Kbool) ⊆ Th(Kmodal) ⊆ Th(Kfull)

(4)

In  Section 4.1 we  show  that  these  inclusions  are  strict,  but  ﬁrst  we  illustrate  some  applications  of sopel in  reasoning 

about knowledge.

Example 10. To  assess  the  expressivity  of sopel in  knowledge  representation,  we  contrast  it  with  comparative  epistemic 
logic – cel [18]. cel extends propositional modal logic with formulas a (cid:3) b, the intuitive interpretation of which is: agent b
knows at least as much as agent a. Semantically, the clause for satisfaction of such formulas at world  w in model M is given 
as

(M, w) |= a (cid:3) b iff Ra(w) ⊇ Rb(w)

In this sense a (cid:3) b also expresses a local property of frame F , namely the inclusion  Rb(w) ⊆ Ra(w).
We show that the comparison between agent a’s and agent b’s knowledge can be recast in sopel as

∀p(Ka p → Kb p)

(5)

(6)

In particular, the RHS of (5) is tantamount to the satisfaction of (6) at  w, whenever model M is full. More precisely, for 

an arbitrary model M we have

(M, w) |= a (cid:3) b ⇒ (M, w) |= ∀p(Ka p → Kb p)

The  converse  also  holds  for  full  M,  but  has  counterexamples  in  the  classes  of  boolean  and  modal  models.  As  a  result, 
formulas a (cid:3) b and (6) have the same meaning in the class of full models, and therefore cel can indeed be mimicked in
sopel. We discuss this fact in more detail in Section 3.

Moreover, in sopel we can make distinctions that are not expressible in epistemic logic. Related to Example 2, in Lsopel

we can state that b knows that a’s beliefs are not truthful by using formula

Kb∃p(Ba p ∧ ¬p)

(7)

Notice that (7) expresses that b knows that there exists some fact believed by a, which is false, possibly without being 
able  to  explicitly  point  out  the  actual  content  of  a’s  false  belief.  On  the  other  hand,  it  could  be  the  case  that  for  some 
proposition  p, agent b knows that a wrongly believes it, as expressed in the following:

∃p Kb(Ba p ∧ ¬p)

(8)

The  formula  displayed  at  (7) is  usually  referred  to  as  a  de dicto reading  of  the  statement  above,  where  quantiﬁer  ∃p
appears within the scope of modal operator  Ka, while (8) corresponds to the de re reading of the same statement, in which 
∃p appears outside the scope of Ka (we refer the interested reader in the two different readings to [46]). We remark that (7)
and (8) are not equivalent in general, (8) being strictly stronger than (7). Speciﬁcally, to account for the difference between 
(7) and  (8),  consider  frame  G in  Fig. 2(a),  where  the  W - and  R-components  are  as  depicted,  and  D = {{w} | w ∈ W }. 
(cid:6)(p) = {u2}.  Hence,  (G, w) |=
Clearly,  (G, V , w 1) |= Ba p ∧ ¬p for  V (p) = {u1},  and  similarly  (G, V
p
(7) for  w ∈ {w 1, w 2}. On the other hand, for no U ∈ D, (G, V
U , w) |= Ba p ∧ ¬p. Therefore, (G, w) (cid:7)|= (8) for  w ∈ {w 1, w 2}. 
Finally, we observe that ∃p Kaφ → Ka∃pφ is a validity in every class of frames. As a result, in sopel (8) is strictly stronger 
than (7), and we can distinguish the de dicto and de re readings of agent b’s higher-level knowledge.

(cid:6), w 2) |= Ba p ∧ ¬p for  V

Finally, consider frame G(cid:6)

in Fig. 2(b) with  D
respec-
(cid:6)
, and similarly for u1, u2 and 
tively, in such a way that assignments V and V
(cid:6)), satisfy the same formulas in Lml
u
(indeed, the two models are bisimilar), implying that the de re formula (8) cannot be expressed in pml. We return to this 
example in Section 5.

(cid:6) = {{w
make the same atoms true in w 1, w 2, and w

(cid:6)) |= (8) (and (7) as well). However, (M, w 2) and (M(cid:6), w

be models based on G and G(cid:6)

. One can check that (M(cid:6), w

(cid:6)}. Let M and M(cid:6)

(cid:6) ∈ W

(cid:6)} | w

(cid:6)

(cid:6)

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

11

b

w 1

b

b

w 2

a

a

u1

u2

(a) frame G

b

(cid:6)

w

a

(cid:6)

u

(b) frame G(cid:6)

2.3.  Preliminary results

Fig. 2. Frames G and G(cid:6)

in Example 10.

In this section we prove some preliminary results on the model-theory of second-order propositional modal logic, that 
will be frequently used in the rest of the paper. To start with, in Lemma 11 we extend some basic but useful results in the 
theory of quantiﬁcation. In particular, in ﬁrst-order logic item 1 of Lemma 11 is known as the coincidence lemma, and item 
b as the substitution lemma (cf. [19]).

Lemma 11.

1. Let φ be a formula in L∗

sopml and F a frame in Kall. If assignments V and V

(cid:6)

coincide on fr(φ), then

(F, V , w) |= φ iff (F, V

(cid:6)

, w) |= φ

2. Recall that X = {ap, pl, ml, sopml} and (cid:5)= {(ap, all), (pl, bool), (ml, modal), (sopml, full)}. Let x ∈ X . Then,

(a) For every ψ ∈ L∗
(b) If F ∈ K(cid:5)x and ψ ∈ L∗

x and model M over F ∈ K(cid:5)x, we have (cid:2)ψ(cid:3)M ∈ D.

x is free for p in φ, then

(F, V

p
(cid:2)ψ(cid:3)(cid:17)F ,V (cid:18)

, w) |= φ iff (F, V , w) |= φ[p/ψ]

The proof of this lemma is immediate, so we include it only in the appendix. These results show that quantiﬁcation in
sopml is  “well-behaved”:  by  item 1  of  Lemma 11,  models  built  over  the  same  frame  and  agreeing  on  the  interpretation 
of free atoms, satisfy the same formulas. It follows in particular that a sentence φ is either satisﬁed by any assignment or 
none,  that  is,  (F , w) |= φ iff  for  every  model M over  F ,  (M, w) |= φ,  iff  for  some  model M over  F ,  (M, w) |= φ.  As 
a consequence of Lemma 11, item a, the domain of quantiﬁcation in a model includes the set of denotations of formulas 
in  that  model,  according  to  the  various  fragments  of  L∗
sopml.  Moreover,  by  Lemma 11,  item 2b,  the  syntactic  operation  of 
substitution φ[p/ψ] corresponds to the semantic notion of reinterpretation Mp

(cid:2)ψ(cid:3).

In Section 4 we will make use of generated submodels, a concept that is commonly used in modal logic.

Deﬁnition 12 (Generated submodel). Given model M = (cid:17)W , D, R, V (cid:18) and world  w ∈ W , the submodel generated by w is the 
model Mw = (cid:17)W w , D w , R w , V w (cid:18) such that

• W w is the set of worlds reachable from  w, i.e., W w = (
• D w = {U w ⊆ W w | U w = U ∩ W w for some U ∈ D};
• for every a ∈ I ,  R w,a = Ra ∩ W 2
w ;
• for every  p ∈ A P,  V w (p) = V (p) ∩ W w .

(cid:4)

a∈I Ra)∗(w);

The  subframe generated by w is  then  deﬁned  as  Fw = (cid:17)W w , D w , R w (cid:18).  The  relevant  property  of  a  generated  submodel 
(cid:6) ∈ W w . It is also important to note that if M is full, 

(cid:6)) |= φ for every  w

Mw is that (M, w) |= (cid:2)∗φ if and only if (Mw , w
modal or boolean, then so is Mw .

Proposition 13. For y ∈ {all, bool, modal, full} and τ ⊆ {r, t, s}, if a frame F belongs to Kτ

y then also Fw ∈ Kτ
y .

The proof is immediate, so we omit it.

2.3.1.  Model checking

In order to explore the computational properties of sopml, we consider the complexity of its model checking problem. 
Then, in the next section we analyse the (lack of) ﬁnite model property for sopml. Before we can determine – or even deﬁne 
– the complexity of model checking, however, we ﬁrst need to deﬁne the size of formulas and models. Our deﬁnition of the 
former is entirely as usual.

12

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

Deﬁnition 14 (Formula size). Let φ ∈ L∗
ψ2| = |ψ1| + |ψ2| + 1, and |(cid:7)ψ| = |∀pψ| = |ψ| + 1.

sopml be a formula. The size of φ, denoted |φ|, is given recursively by: |p| = 1, |ψ1 →

Similarly, the size of a model M can be deﬁned in a straightforward way.

Deﬁnition  15  (Model  size). The  size |M| of  model  M = (cid:17)W , D, R, V (cid:18) is  given  by  |M| = |W | + |D| +
(cid:6)

|V (p)|.

p∈ A P
A model M is ﬁnite if |M| < ∞.

(cid:6)

a∈I

|Ra| +

Now that we have deﬁned the sizes of formulas and models, we can deﬁne the model checking problem and determine 

its complexity.

Deﬁnition 16 (Model checking for SOPML). Given a formula φ ∈ L∗
checking problem for sopml is to determine whether (M, w) |= φ.

sopml, a ﬁnite model M and a world  w of M, the model 

Then, we are able to prove the following complexity result.

Theorem 17 (Model checking complexity). The model checking problem for sopml is PSPACE-complete with respect to |φ| + |M|.

Proof. As regards hardness, we reduce satisﬁability of quantiﬁed boolean formulas to sopml model checking. Given a for-
mula  φ ∈ Lqbf ,  consider  the  frame  F = (cid:17){w}, (w, w), {{w}, ∅}(cid:18) and  an  arbitrary  assignment  V ,  and  deﬁne  M = (cid:17)F , V (cid:18). 
Then, we have that φ is satisﬁable iff (M, w) |= ∃(cid:23)pφ, where  (cid:23)p are all the atoms in φ. Because the satisﬁability problem for 
quantiﬁed boolean formulas is PSPACE-hard, it follows that model checking sopml is PSPACE-hard as well.

As  regards  being  in  PSPACE,  an  algorithm  in  PSPACE  for  model  checking sopml is  shown  as  Algorithm 1.1 It  is  based 
on  standard  model  checking  algorithms  for  modal  logic  [8],  which  run  in  polynomial  time.  The  difference  between  these 
standard algorithms for modal logic and Algorithm 1 is that we need an extra case for the ∀p operator. This extra case is 
why Algorithm 1 takes polynomial space as opposed to polynomial time.

Algorithm 1 recursively calls itself. The depth of this recursion is bounded by |φ|. Furthermore, at each stage we need to 
(cid:6) ∈ D we can ﬁrst compute 
.  It  follows  that  the 

keep only one of these recursive calls in memory at a time. For example, in the ∀pψ step, if U , U
X ∩ (cid:2)ψ(cid:3)Mp
space requirement of Algorithm 1 is polynomial with respect to |φ| + |M|. (cid:2)

and  then  ﬂush  the  memory  dedicated  to  computing  (cid:2)ψ(cid:3)Mp

before  computing  (cid:2)ψ(cid:3)Mp

U

U

U

(cid:6)

Algorithm 1 Computation of the satisfaction set (cid:2)φ(cid:3)M.

switch (φ):
case p:

return V (p);

case ¬ψ :

return W \ (cid:2)ψ(cid:3)M;
:

case ψ ∧ ψ (cid:6)

return (cid:2)ψ(cid:3)M ∩ (cid:2)ψ (cid:6)(cid:3)M;

case (cid:2)aψ :

case (cid:2)∗ψ :

case ∀pψ :

return {w ∈ W | Ra(w) ⊆ (cid:2)ψ(cid:3)M};

return {w ∈ W | (

a∈ Ag Ra)∗(w) ⊆ (cid:2)ψ(cid:3)M};

(cid:4)

initialise X = W
for U ∈ D do

set X = X ∩ (cid:2)ψ(cid:3)Mp

U

end for
return X

As a result, model checking sopml is no more computationally complex than the corresponding problem for quantiﬁed 
boolean formulas. Thus, the enhanced expressiveness comes at no extra computational cost, when compared with qbf. With 
respect  to  propositional  modal  logic,  the  complexity  increases  from  PTIME  to  PSPACE.  However,  this  is  something  to  be 
expected given the extra expressive power of propositional quantiﬁcation.

We  should  also  note  that  the  complexity  of  the  model  checking  problem  depends  more  strongly  on  |φ| than  on  |M|. 
The recursion in Algorithm 1 can be seen as a tree with depth bounded by |φ| and branching factor bounded by |M|. So 

1 Strictly speaking, the algorithm computes (cid:2)φ(cid:3)M, but we can easily determine whether M, w |= φ from that.

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

13

the algorithm is called at most |M||φ|
|φ| and |M|, its time complexity is exponential in |φ| and polynomial in |M|.

times. As a result, while the space complexity of the algorithm is polynomial in both 

a∈I

(cid:6)

(cid:6)

Furthermore, we can obtain the same PSPACE result when using a more concise representation of M. So far, we have 
deﬁned the size of M as |M| = |W | + |D| +
|V (p)|. This means that, among other things, we simply 
p∈ A P
count  the  number  of  elements  in  D as  one  of  the  components  of M.  So,  in  effect,  we  are  treating  D as  a  list.  In  some 
cases, however, there are other natural representations of D that are much more concise. Suppose, for example, that M has 
a full domain, so  D = 2W . Then instead of representing  D as a list of sets we could represent it symbolically as 2W . More 
generally, we can assume that D is given by some membership function  f , so D = {Y ⊆ W | f (Y , W )}. The only requirement 
we place upon it is that  f should not be too hard to compute; we assume that determining whether  f (Y , W ) can be done 
in polynomial space with respect to |W |.

|Ra| +

Then the model checking problem for sopml is PSPACE-complete not just in |φ| + |M| but also in |φ| + |W | + |R| + |V |, 
which can be exponentially smaller. With regard to hardness, note that the hardness part of the proof of Theorem 17 uses 
a ﬁxed model, so in that regard the deﬁnition of model size is irrelevant. It follows that the model checking problem is also 
PSPACE-hard  with  respect  to  |φ| + |W | + |R| + |V |.  With  regard  to  being  in  PSPACE,  a  slight  modiﬁcation  to  Algorithm 1
suﬃces. Suppose that we replace the ∀pψ case of that algorithm with

case ∀pψ :

initialise X = W
for U ∈ 2W do
if U ∈ D then

set X = X ∩ (cid:2)ψ(cid:3)Mp

U

end if
end for
return X

The proof that this amended algorithm runs in PSPACE with respect to |φ| + |W | + |R| + |V | can be done in the same way 
as the proof of Theorem 17, so we omit it here.

2.3.2.  Finite model property

We now brieﬂy argue why sopml does not have the ﬁnal model property. Consider the following set of formulas:

(cid:9) = {(cid:3)a(cid:10), (cid:2)a(cid:3)a(cid:10), ∀p((cid:2)a p → (cid:2)a(cid:2)a p), (cid:2)a∃p(p ∧ (cid:2)a¬p)}

Now suppose that (cid:9) holds at some pointed model (M, w). Then the ﬁrst two formulas of (cid:9) require  Ra to be serial on 
{w} ∪ Ra(w), and the third enforces transitivity of  Ra (also at  w). Finally, if world  w satisﬁes (cid:2)a∃p(p ∧ (cid:2)a¬p), then, by 
Example 24 item 1, we know that ¬Ra(v, v) for all v ∈ Ra(w), which implies that ¬Ra(w, w), so that  Ra is irreﬂexive over 
{w} ∪ Ra(w). But it is easy to verify that a transitive, serial, and irreﬂexive relation on  Ra(w) requires  Ra(w) to be inﬁnite. 
In other words, we found a ﬁnite set (cid:9) of formulas in sopml that only has inﬁnite models.

Theorem 18. The logic sopml does not have the ﬁnite model property.

Theorem 18 is a generalisation of a result presented in [40, Section 3]. As the name of that section (‘SOPMLE = MSO’) 
suggests, it demonstrates that sopmle, which is sopml with a universal modality, has the same expressive power as mso. 
And  obviously, mso can  force  a  model  to  be  inﬁnite  (use  the  relational  properties  of  our  example  above),  and  therefore
sopmle can. Note that in our example, we don’t assume a universal modality in our language, though.

3.  Local properties in modal logic

In  the  introduction  we  discussed  the  difference  between  a  global  property  as  expressed  by  the  modal  schema  (i)
(cid:2)aϕ → ϕ,  whose  validity  entails  that  the  accessibility  relation  in  a  given  frame  is  reﬂexive,  and  a  local  property  such 
as the one represented by the sopml formula ∀p((cid:2)a p → p) that, as we shall see, on full frames holds exactly in reﬂexive 
worlds. Along this line, in [16–18] a sophisticated account was put forward to express local properties, by adding dedicated 
modal operators to a basic propositional modal logic. To present the language of local properties in modal logic, or lpml, 
to  compare  the  two  approaches,  and  more  generally  to  discuss  the  expressive  power  of sopml,  we  consider  a  monadic 
second-order logic and a ﬁrst-order fragment interpreted on Kripke frames.

Given a frame F = (cid:17)W , D, R(cid:18) and a set  A P of atoms, we deﬁne an mso alphabet containing binary predicate constants 
Ra for  every  agent  index a ∈ I ,  a  unary  predicate  variable  P for  every  atom  p ∈ A P,   and  a  set  X of  individual  variables. 
Then, mso formulas (cid:10) in Lmso are deﬁned in BNF as follows:

(cid:10) ::= P (x) | x = y | Ra(x, y) | ¬(cid:10) | (cid:10) → (cid:10) | ∀x(cid:10) | ∀P (cid:10)

where a ∈ I and x, y ∈ X .

14

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

We also consider the ﬁrst-order fragment Lfo of msoobtain by removing clause ∀P (cid:10) from the BNF above. This is indeed 
the  ﬁrst-order  language  considered  in  [18].  Moreover,  we  denote  as  L1
fo the  fragment  of  Lfo containing  formulas  with  at 
most one free individual variable. This fragment is well-known to be rich enough to express properties of frames such as 
reﬂexivity, symmetry, and transitivity (note that more than one variable is needed for e.g. transitivity, but at most one is 
free).

As regards the interpretation of mso and fo (First-Order) formulas, an assignment ρ now is a function associating a world 
w ∈ W to every individual variable x, and a set U ∈ D to every predicate variable  P . For w ∈ W and U ∈ D, the variants ρ x
w
and ρ P

U are deﬁned similarly to sopml.

Deﬁnition 19 (Semantics of MSO). We deﬁne whether frame F = (cid:17)W , D, R(cid:18) satisﬁes formula (cid:10) ∈ Lmso for an assignment ρ, 
or (F , ρ) |= (cid:10), as follows:

(F , ρ) |= P (x)
(F , ρ) |= x = y
(F , ρ) |= Ra(x, y)
(F , ρ) |= ¬(cid:10)
(F , ρ) |= (cid:10) → (cid:10)(cid:6)
(F , ρ) |= ∀x(cid:10)
(F , ρ) |= ∀P (cid:10)

iff
iff
iff
iff
iff
iff
iff

ρ(x) ∈ ρ(P )
ρ(x) = ρ( y)
Ra(ρ(x), ρ( y))
(F , ρ) (cid:7)|= (cid:10)
(F , ρ) (cid:7)|= (cid:10) or (F , ρ) |= (cid:10)(cid:6)
for all w ∈ W , (F , ρ x
w ) |= (cid:10)
for all U ∈ D, (F , ρ P
U ) |= (cid:10)

Obviously  Deﬁnition 19 induces  an  interpretation  of  formulas  in  Lfo as  well.  In  particular,  for  a  formula  (cid:10)(x) ∈ L1
fo, 
we  write  (F , w) |= (cid:10) to  denote  that  (F , ρ) |= (cid:10) for  ρ(x) = w,  and  F |= (cid:10) if  (F , w) |= (cid:10) for  all  w ∈ W .  The  different 
interpretation of the satisfaction relation |= for sopml and mso respectively will be clear from the context. Note that the 
transitive closure  R

of  R can be easily deﬁned in mso.

∗

We  illustrate  the  relationship  between  second-order  propositional  modal  logic  and  monadic  second-order  logic  (mso) 

through translation  S T that extends the standard translation between modal and ﬁrst-order logic [7]:

S T x(p)
S T x(¬φ)
S T x(φ → φ(cid:6))
S T x((cid:2)aφ)
S T x((cid:2)∗φ)
S T x(∀pφ)

=
=
=
=
=
=

P (x)
¬S T x(φ)
S T x(φ) → S T x(φ(cid:6))
∀ y(Ra(x, y) → S T y(φ))
∗(x, y) → S T y(φ))
∀ y(R
∀P (S T x(φ))

Clearly, for every formula φ ∈ L∗

sopml,  S T x(φ) ∈ Lmso is a formula where x is the only free individual variable. If ψ ∈ Lml
is a purely propositional modal formula, then S T x(ψ) ∈ Lfo is a ﬁrst-order formula, as obtained via the standard translation. 
In particular,  S T x(ψ) belongs to L1
fo.

We now get the following preservation result for the standard translation, that will be used in the completeness proof.

Lemma 20. For every model M = (cid:17)F , V (cid:18), world w ∈ W , and formula ψ ∈ L∗

sopml,

(M, w) |= ψ iff (F, ρ) |= S T x(ψ)

whenever ρ(x) = w and ρ(P i) = V (pi).

The proof is mostly standard, and can be found in Appendix A. As a consequence of Lemma 20, there is a one-to-one 
correspondence  between  formulas  in sopml and  their  standard  translations  in mso in  the  following  sense:  a  frame  F
sopml iff property ∀ (cid:23)P S T x(ψ) ∈ Lmso holds in F , where  (cid:23)P are all the 
validates the universal closure ∀(cid:23)pψ of a formula ψ ∈ L∗
unary predicates appearing in  S T x(ψ).

We now brieﬂy recall some basic modal theory on local deﬁnability: we refer the interested reader to [7,9] for further 
details. We use θ (or θ((cid:23)a, (cid:23)p) to emphasise sequences  (cid:23)a of indices and  (cid:23)p of atoms) for formulas in Lml. Likewise, we use 
fo for ﬁrst-order formulas with at most one free variable interpreted over states (or (cid:10)((cid:23)a, x) to denote that (cid:10) mentions 
(cid:10) ∈ L1
(cid:23)a as indices and has x as the free variable).

Deﬁnition 21. Let θ ∈ Lml and (cid:10) ∈ L1
fo,

1. θ deﬁnes frame property (cid:10) iff for all frames F , F |= θ iff F |= (cid:10).
2. θ locally deﬁnes (cid:10) iff for all F and all  w ∈ F , (F , w) |= θ iff (F , w) |= (cid:10).

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

15

Table 1
As in [18, Table 1], (cid:10)((cid:23)a, x) is a property of state x, and (cid:4)((cid:23)a) is a name in the object language such that (cid:4)((cid:23)a) holds at  w iff (cid:10)((cid:23)a, x) holds in M for 
ρ(x) = w.
θ((cid:23)a, (cid:23)p)
(cid:2)a p → (cid:2)b p
(cid:2)c p → (cid:2)a(cid:2)b p
¬(cid:2)a⊥
(cid:2)a p → p
¬(cid:2)a p → (cid:2)b¬(cid:2)c p
¬(cid:2)a p → ¬(cid:2)b(cid:2)c p
(¬(cid:2)a p ∧ ¬(cid:2)bq) → ¬(cid:2)c (p ∨ q)

(cid:10)((cid:23)a, x)
∀ y(Rb(x, y) → Ra(x, y))
∀ y, z(Ra(x, y) ∧ Rb( y, z) → Rc (x, z))
∃ y Ra(x, y)
Ra(x, x)
∀ y, z(Ra(x, y) ∧ Rb(x, z) → Rc ( y, z))
∀z(Ra(x, z) → ∃ y Rb(x, y) ∧ Rc ( y, z))
∀ y, z((Ra(x, y) ∧ Rb(x, z)) → ( y = z ∧ Rc (x, y)))

(cid:4)((cid:23)a)
Sup(a, b)
Trans(a, b, c)
Ser(a)
Reﬂ(a)
Eucl(a, b, c)
Dens(a, b, c)
Func(a, b, c)

As examples of Deﬁnition 21, consider the well-known schemes T (cid:2)aϕ → ϕ, 4 (cid:2)aϕ → (cid:2)a(cid:2)aϕ, and B ϕ → (cid:2)a(cid:3)aϕ, that 
(locally) deﬁne the properties of reﬂexivity, transitivity, and symmetry on frames. Furthermore, by Lemma 20 it is clear that 
every θ ∈ Lml (locally) deﬁnes ∀ (cid:23)P S T x(θ) ∈ Lmso, whenever ∀ (cid:23)P S T x(θ) is equivalent to some (cid:10) ∈ L1
fo.

In the theory of pml, when formula θ locally deﬁnes (cid:10) and some other mild conditions hold, one obtains the following 
connection  between  axiomatisation  and  completeness:  if  an  axiomatisation  Ax is  complete  for  a  class  K of  frames,  then 
Ax + θ is complete for class {F ∈ K | F |= ∀x(cid:10)} of frames satisfying condition (cid:10). So for instance, taking the basic modal 
logic K, which is sound and complete with respect to the class K of all frames, the logic K + T is sound and complete with 
respect  to  class  {F ∈ K | F |= ∀xRa(x, x) for all a ∈ I},  that  is,  the  class  of  reﬂexive  frames.  As  further  examples,  whereas 
S5 = K + T + 4 + B is sound and complete with respect to class S5 = {F ∈ K | for all a ∈ I, Ra is an equivalence relation}, 
the logic S5 + {(cid:2)bϕ → (cid:2)cϕ | b, c ∈ I} is sound and complete with respect to {F ∈ S5 | F |= ∀x(Rc(x) ⊆ Rb(x)) for all b, c ∈ I}.
This  is  an  appealing  modular  feature  of  modal  logic.  Yet,  as  also  remarked  by  van  Ditmarsch  et  al.  ([16–18])  this  can 
only be applied if one adds formula θ as a global property: assuming θ as an axiom implies that it becomes a validity. For 
instance, adding formula  Baϕ → ϕ to an axiom system, in order to model that agent a’s beliefs are correct, implies that in 
the resulting logic, it is common knowledge that a’s beliefs are correct, and this fact will always remain true.

To compare our approach based on sopml to van Ditmarsch et al.’s lpml, we ﬁrst provide a brief account of the latter.

3.1.  Local properties and lpml

This section on lpml is based on [16–18]: we refer the reader to these references for a more extensive exposition. The 
term ‘logic’ is maybe not appropriate for lpml; rather, it is a speciﬁc approach to ‘connect’, in a modal object language, a 
fo through  the  introduction  of  a  relational  atom  (cid:4) (or  (cid:4)((cid:23)a)),  in 
modal  formula  θ ∈ Lml and  a  ﬁrst-order  property  (cid:10) ∈ L1
such  a  way  that  on  Kripke  models  (cid:4) is  interpreted  as  (cid:10) locally.  More  precisely,  the  language  of lpml extends  Lml with 
formulas of type (cid:4)((cid:23)a), whose interpretation is provided by an associated formula (cid:10)(cid:4)((cid:23)a, x) ∈ L1
fo, according to the following 
satisfaction clause:

(M, w) |= (cid:4)((cid:23)a) iff (F, w) |= (cid:10)(cid:4)((cid:23)a, x)

(9)

By clause (9) we say that formula (cid:4)((cid:23)a) expresses locally ﬁrst-order property (cid:10)(cid:4) (at  w).
Then, lpml investigates how operator (cid:4) can help us, in the object language, to build a bridge between modal formulas 
θ(cid:4) and  ﬁrst-order  properties  (cid:10)(cid:4) that  θ(cid:4) locally  deﬁnes.  So,  for  instance,  we  can  have  (cid:4)(a) = Reﬂ(a) for  (cid:10)(cid:4)(a, x) =
Ra(x, x), or (cid:4)(b, c) = Sup(b, c) for (cid:10)(cid:4)(b, c, x) = ∀ y(Rc(x, y) → Rb(x, y)) (for more examples, see Table 1).

Recalling that operator (cid:4) is part of the object language of lpml, [18] then adds to the basic modal logic K, for speciﬁc 
formulas  θ(cid:4) ∈ Lml,  an  axiom  Ax(cid:4) and  an  inference  rule  R(cid:4).  Further,  [18,  Theorem  2] provides  a  suﬃcient  condition 
on  the  relationship  between  θ(cid:4), (cid:4) and  (cid:10)(cid:4),  called  local harmony,  under  which  K + Ax(cid:4) + R(cid:4) is  a  sound  and  complete 
axiomatisation for the class of models that satisfy (cid:10)(cid:4).

Deﬁnition 22 (Local harmony). Formulas θ((cid:23)a, (cid:23)p) ∈ Lml, (cid:10)((cid:23)a, x) ∈ L1
deﬁnes (cid:10), and (ii) (cid:4) expresses (cid:10) locally.

fo, and (cid:4)((cid:23)a) in lpml are in local harmony iff (i) θ (locally) 

A  model  M for lpml is  a  tuple  (cid:17)W , R, I, V (cid:18) where  W , R and  V are  as  for pml and  I assigns  a  ﬁrst  order  property 
to each relational atom (cid:4). We follow [18] in assuming that for each symbol (cid:4)θ ((cid:23)a), there is a Lml-formula θ((cid:23)a, (cid:23)p) and a 
fo-formula (cid:10)((cid:23)a, x) such that the three are in local harmony and I((cid:4)θ ((cid:23)a)) = (cid:10)((cid:23)a, x). To be explicit about this, we call such 
L1
a model M an intended model for lpml.

One  could  say  that lpml as  a  language  can  express  every  formula  in  L1

fo,  as  there  are  no  restrictions,  in  the  object 
language,  on  the  relational  atoms  (cid:4) that  can  be  added  to  standard pml (i.e.,  Table 1 can  in  principle  be  extended  with 
an atom (cid:4)((cid:23)a) for any property (cid:10)((cid:23)a, x)). However, the aim of lpml is not to express arbitrary ﬁrst-order properties (cid:10), but 
to reason locally about properties like truthfulness of agent a’s beliefs, or an agent c knowing more than b. In particular, 
there has to exist a modal formula θ that (locally) deﬁnes (cid:10), that is, (cid:10) has to be equivalent to ∀ (cid:23)P S T x(θ). lpml expresses 
such  ﬁrst-order  properties  by  adding  atoms  like  Reﬂ(a) and  Sup(b, c),  respectively.  We  reckon  that sopml,  allowing  for 

16

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

quantiﬁcation  over  propositions  as  in  ∀p(Ba p → p) and  ∀p(Kb p → Ka p),  is  an  alternative  way  to  study  local  properties 
which is at least as natural as lpml and provably as expressive, in a sense we explain below.

3.2.  Local properties, lpml and sopml on full frames

We ﬁrst compare lpml to sopml on full frames. On the other classes of frames there are some notable differences that 
we  discuss  in  Section 3.3.  Here  we  show  that  if  formulas  (cid:10)(cid:4)((cid:23)a, x) and  θ(cid:4)((cid:23)a, (cid:23)p) are  in  local  harmony  with  some  atom 
(cid:4)((cid:23)a),  then  formula  (cid:4)((cid:23)a) is  equivalent  to  ∀(cid:23)pθ((cid:23)a, (cid:23)p) ∈ L∗
sopml,  within  the  class  of  full  frames.  Hence, sopml is  at  least  as 
expressive  as lpml.  To  make  this  more  precise,  note  that lpml is  only  able  to  reason  about  local  properties  if  all  triples 
θ((cid:23)a, (cid:23)p), (cid:4)((cid:23)a), and (cid:10)((cid:23)a) are in local harmony. Recall that a lpml model M that guarantees this is an intended model. We 
will  also  interpret  such  an  intended  model M as  a  model  for sopml:  one  just  discards  the lpml information  connecting 
(cid:4)((cid:23)a) and (cid:10)(cid:4)((cid:23)a, x), and then adds the constraint that the model is full. Now, consider the translation t from lpml formulas 
to sopml formulas that distributes over all connectives and modal operators, and moreover says

t((cid:4)((cid:23)a)) = ∀(cid:23)pθ((cid:23)a, (cid:23)p)

We then obtain the following equivalence result.

Theorem 23. For every intended lpml model M, w ∈ M, and formula ϕ in lpml, we have

(M, w) |= ϕ iff (M, w) |= t(ϕ)

A proof of Theorem 23 is given in Appendix A. This theorem implies, in a sense, that what can be done in lpml, can also 
be done in sopml: if θ((cid:23)a, (cid:23)p), (cid:4)((cid:23)a) and (cid:10)((cid:23)a) are in local harmony, then, to reason locally about a scheme θ , one can either 
use the universal closure ∀(cid:23)pθ in sopml, or atom (cid:4)((cid:23)a) in lpml. The result also suggests ways in which sopml may be more 
appropriate to reason about local properties, namely cases where (cid:10) is not locally deﬁned by any formula θ ∈ Lml (i.e., there 
is no θ such that ∀ (cid:23)P S T x(θ) is equivalent to (cid:10)), or, conversely, when θ does not deﬁne a ﬁrst-order property (cid:10) locally (i.e., 
there is no (cid:10) such that ∀ (cid:23)P S T x(θ) is equivalent to (cid:10)). Hereafter we consider some similar cases.

Example 24. Consider the following ﬁrst-order formulas:

(cid:2)

• (cid:10)1 = ¬Ra(x, x) (irreﬂexivity)
• (cid:10)2 = ∃x1, . . . , xn
i≤n(Ra(x, xi) ∧
• (cid:10)3 = ∀ y((Ra(x, y) ∧ Ra( y, x)) → x = y) (anti-symmetry)
• (cid:10)4 = ∀ y(Rb(x, y) → ¬Ra(x, y)) (Ra and  Rb have empty intersection)
• (cid:10)5 = ∀ y((Ra(x, y) ∧ Rb(x, y)) → Rc(x, y)) (Rc contains the intersection of  Ra and  Rb).

i(cid:7)= j≤n xi (cid:7)= x j) (having at least n a-successors)

(cid:2)

It is well-known that these ﬁrst-order properties are not deﬁnable in modal logic [7,9]. However, consider the following 

formulas in sopml:

• ϕ1 = ∃p((cid:2)a p ∧ ¬p)
(cid:2)
• ϕ2 = ∃p1, . . . , pn(
• ϕ3 = ∃p(p ∧ ∀q((cid:3)a(q ∧ (cid:3)a p) → q))
• ϕ4 = ∃p((cid:2)a p ∧ (cid:2)b¬p)
• ϕ5 = ∀p((cid:2)c p → ∃q((cid:2)aq ∧ (cid:2)b(q → p)))

(cid:3)a(pi ∧

i≤n

(cid:2)

j≤n, j(cid:7)=i

¬p j))

which are such that each ϕi locally deﬁnes (cid:10)i (1 ≤ i ≤ 5). We formalise this result in the following lemma.

Lemma 25. Consider formulas ϕi ∈ Lsopml and (cid:10)i ∈ L1
assume ρ(x) = w. Assume F is a full frame, then,

fo in Example 24, for i = 1, . . . , 5. Let x be the only free variable in (cid:10)i and 

(F, w) |= ϕi iff (F, ρ) |= (cid:10)i

The proof of some items of the lemma is to be found in Appendix A. In particular, sopml can express properties that are 

not deﬁnable in standard modal logic.

Example 26 (Distributed knowledge). To  come  back  to  an  example  from  epistemic  logic,  an  interesting  notion  in  collective 
knowledge is that of distributed knowledge Dϕ. The intuition here is that distributed knowledge is the knowledge of a ‘wise 
man’ (cf. [20]) with whom all agents have shared their knowledge. The typical example is a situation where, for instance, 
one agent knows ϕ, another knows that ϕ → ψ , implying distributed knowledge of ψ . A more concrete example goes as 

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

17

follows: it is distributed knowledge in every group of agents (provided everybody knows their own birthday) whether two 
agents  share  their  birthday.  The  notion  of  distributed knowledge Dϕ for n agents  has  an  axiomatisation  that  is  sound  and 
complete with respect to models where the corresponding relation R D is the intersection of all the individual agents’ acces-
sibility relations. However, intersection is not locally deﬁnable in modal logic (for more on modal properties of distributed 
knowledge, or implicit knowledge as it is sometimes called, see for instance [30,47]). However, in sopml, using Example 24.5 
we can express that agent c knows exactly what the distributed knowledge of agents a and b is:

∀p(Ka p → Kc p) ∧ ∀p(Kb p → Kc p) ∧ ∀p(Kc p → ∃q(Kaq ∧ Kb(q → p)))

(10)

Notice  that  (10) uses  exactly  the  idea  of  the  typical  example  of  distributed  knowledge  between  two  agents  discussed 
above: if agent c knows some fact  p, i.e.,  p is distributed knowledge between a and b, then there exists some fact q such 
that a knows q and b knows q → p. So, they are able to derive  p by pooling together their knowledge.

Can we generalise this to n agents? Indeed we can, as follows. Deﬁne

(cid:7)

ϕ = ∀p(Dp → ∃q1 . . . ∃qn−1(K1q1 ∧ · · · ∧ Kn−1qn−1 ∧ Kn(

qi → p))

i<n

and let

(cid:10) = ∀ y((R1(x, y) ∧ · · · ∧ Rn(x, y)) → R D (x, y))

Then, we can prove the following result.

Proposition 27. For every full frame F , (F , w) |= ϕ iff (F , w) |= (cid:10)(x).

The proof is a generalisation of the proof of Lemma 25 for (cid:10)5. It follows that operator D locally expresses the distributed 

knowledge of ψ among agents 1, . . . , n:

(cid:7)

∀p(K i p → Dp) ∧ ϕ ∧ Dψ

i≤n

Discussion. From Examples 24 and 26 it follows that sopml is strictly more expressive than propositional modal logic, 
and  it  can  also  express  local  properties  that  cannot  be  dealt  with  in lpml.  Example 24 also  indicates  when sopml can 
axiomatise frames that cannot be characterised in pml: for instance, formula ∃p((cid:2)p ∧ ¬p) characterises irreﬂexive frames, 
in the same way as ∃p((cid:2)p ∧ (cid:3)(cid:3)¬p) characterises intransitive frames. Venema [52] calls such characterisations negatively 
deﬁnable. The idea here is the following: suppose that formula θ ∈ Lml locally deﬁnes some property (cid:10); is there a formula 
that  locally  deﬁnes  ¬(cid:10)?  As  an  example,  whereas  Ra(x, x) is  (locally)  deﬁned  by  (cid:2)a p → p,  the  negation  ¬R(x, x) is  not 
(locally) deﬁned by ¬((cid:2)p → p), or equivalently, (cid:2)a p ∧ ¬p, since this would require that on frames for this formula, atom p
were  false.  Gabbay  [23] came  up  with  a  derivation  rule,  rather  than  an  axiom,  to  characterise  irreﬂexivity,  while  [52]
analyses more generally when a negative characterisation of some class of frames also leads to an axiomatisation of such 
class.  For  our  discussion,  it  is  important  to  realise  that  reﬂexivity  is  actually  characterised  by  a  modal  scheme (cid:2)aϕ → ϕ, 
and, in contrast, by formula ∀p((cid:2)a p → p) in sopml. But then, irreﬂexivity is characterised by the negation of that sopml
formula:  ∃p((cid:2)p ∧ ¬p).  Moreover,  notice  that sopml allows  us  to  interpret  such  formulas  locally,  so  that  we  can  reason 
about models that have both reﬂexive and irreﬂexive points.

From Example 24 we also learn that there are ﬁrst-order properties (cid:10) that cannot be characterised by any modal formula 
θ ∈ Lml, while we do have a formula in sopml characterising it. It is also possible to come up with formulas in sopml that 
do not correspond to any ﬁrst-order formula (hence, in sopml one could reason locally about them, but not in lpml). A ﬁrst 
example  of  such  formulas  is  ∃p¬δ for  δ = ((cid:3)p ∧ (cid:3)(cid:2)¬p) → (cid:3)((cid:2)−1(cid:3)p ∧ (cid:2)¬p) (here  (cid:2)−1 is  interpreted  as  the  converse 
of relation  R for (cid:2)). As argued in [52], although δ as a scheme characterises Dedekind-complete frames among the linear 
orderings,  the  frames  for  ¬δ are  not  elementary,  that  is,  not  ﬁrst-order  deﬁnable.  A  further  example  is  the  Löb  formula 
∀p((cid:2)((cid:2)p → p) → (cid:2)p): this formula characterises frames with  R being transitive and its converse well-founded [52, p. 8].

To conclude our comparison between sopml and lpml, we observe that the (cid:4) operators act in fact as a sort of linguistic 
black boxes, bringing the metalanguage of the theory of ﬁrst-order logic into the object language of modal logic. In contrast,
sopml is more transparent, as everything is done in the object language. In addition, for the ﬁrst-order conditions in [18]
there must always be a suitable modal counterpart. Indeed, the axioms Ax(cid:4) : (cid:4)((cid:23)a) → θ(cid:4)((cid:23)a, (cid:23)p) in [18] make sense only as 
long as there is a propositional modal formula θ(cid:4) related to (cid:4), and this is not always the case as discussed above. We will 
see later that none of this has to be assumed to axiomatise sopml.

Revisiting Example 24, it is no surprise that the sopml formulas in this example all use existential quantiﬁcation, because 

we have the following.

Lemma 28. For a ﬁnite set {p1, . . . , pn} of atoms, deﬁne ∀(cid:23)p as ∀p1 . . . ∀pn (this is well-deﬁned because ∀p∀qφ is equivalent to 
∀q∀pφ). Then for all frames F , worlds w, assignments V , and formulas φ in SOPML we have

18

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

1. (F , w) |= φ iff (F , w) |= ∀(cid:23)pφ
2. (F , w) |= ∀ (cid:23)fr(φ) φ iff (F , V , w) |= ∀ (cid:23)fr(φ) φ
3. (F , w) |= φ iff (F , V , w) |= φ, where φ is a sentence (i.e., fr(φ) = ∅).

3.3.  Local properties and sopml on non-full frames

So far, we have only looked at how SOPML can represent local properties on full frames. Here, we consider local proper-

ties on frames with a coarser domain of quantiﬁcation. Let us return to formula

∀p(Ka p → p),

(11)

which is intended to express that everything a knows is true. Looking at the semantics of sopml, we can see that (11) holds 
in (M, w) if and only if

for all U ∈ D, Ra(w) ⊆ U implies w ∈ U .

(12)

If the domain  D is equal to the power set 2W , then (12) is equivalent to  w ∈ Ra(w), so to  Ra being locally reﬂexive. In 
general, however, there is no guarantee that  D is equal to 2W . So on non-full frames, (11) does not characterise reﬂexivity. 
In fact, on such frames, there is no sopml formula that characterises reﬂexivity.

Whether this is an important downside of sopml depends on the object of study. If one is after a logic that can reason 
about graph-theoretic properties like reﬂexivity, then one should consider sopml only on full frames, since on other frames
sopml cannot  express  these  properties.  If,  on  the  other  hand,  the  goal  is  to  reason  about  a  particular  subject  (such  as 
knowledge)  and  only  use  graphs  to  represent  that  subject,  then sopml is  useful  even  on  non-full  frames.  After  all,  even 
though  (11) does  not,  in  general,  correspond  to  reﬂexivity,  it  does  still  express  the  fact  that  everything  known  by  a is 
true—with one caveat.

The  quantiﬁer  ∀p quantiﬁes  only  over  those  valuations  of  p that  are  part  of  the  domain  D.  So,  strictly  speaking,  (11)

means that “for every element U ∈ D, if a knows U then U is true.” There are three main ways to interpret this.

1. We  could  explicitly  retain  the  reference  to  D,  and  interpret  (11) as  “every  atomic  (resp. boolean,  modal)  proposition 

that a knows is true” if  D is any (resp. boolean, modal) domain of quantiﬁcation.

2. We  could  consider  D to  be  the  set  of  properties  that  are  relevant  for  the  problem  that  we  are  modelling.  In  this 
interpretation, the formula ∀p(Ka p → p) might hold even if there is some proposition  T ∈ 2W \ D such that  T is false 
but known by a. However, because T /∈ D it is not a relevant property, we don’t care whether a is wrong about it.
3. We could interpret  D as the set of propositions that can be conceptualized. This allows us to interpret (11) as “every-
thing that a knows is true”, where it is understood that being able to conceptualize a proposition is a precondition for 
knowing that proposition.

As an example of the latter situation, suppose that Alice is looking at a blue object. However, due to a trick of the light, 
the object seems green to her. She forms the belief that the object is green. This belief is false, so ∀p(Ka p → p) does not
hold. Now, suppose that Bob is looking at the same object, but that Bob is from a culture that does not distinguish between 
green  and  blue.  Instead,  Bob’s  culture  uses  a  single  concept  for  these  colours  that  we  will  translate  as  “green/blue”.  Bob 
makes the same observation as Alice, but based on that observation he forms the belief that the object is green/blue. This 
belief is correct, so, assuming that b’s other beliefs are correct as well, ∀p(Kb p → p) holds.2 The difference between Alice 
and Bob does not lie in their accessibility relations. Instead, it is caused by the different ways in which they divide the set 
of possible worlds into concepts.

The conditions on  D then place restrictions on the conceptual space that we assume the agents to have. If  D is boolean, 
then the concepts “green” and “blue” need to be accompanied by concepts “not green” and “green or blue”. If  D is modal, 
then the concept “green” needs to be accompanied by a concept “knowing to be green”, and if  D is full then every set of 
worlds corresponds to some concept.

Regardless  of  the  interpretation  that  we  choose,  every  formula  discussed  in  Table 1 expresses  a  property  of sopml
models. The properties that are expressed by these formulas can be found in Table 2. Note that the properties in Table 2
are  generalisations  of  those  in  Table 1,  and  that  they  are  equivalent  to  their  counterparts  when  D is  full.  The  properties 
in  question  require  some  slightly  awkward  notation,  but  conceptually  they  are  not  very  hard  to  grasp:  they  correspond 
to  the  properties  in  Table 1,  except  we  consider  only  those  sets  of  worlds  that  are  in  the  domain  D.  Take,  for  example, 
∀p((cid:2)a p → p). On full frames, this corresponds to w ∈ Ra(w), which is equivalent to every superset of Ra(w) containing w, 
so to ∀U ∈ 2W (Ra(w) ⊆ U → w ∈ U ). The corresponding property for non-full frames is obtained by replacing 2W by the 
domain  D.

2 We are somewhat over-simplifying here. Bob is probably capable of conceptualizing several different subsets of green/blue, such as dark green/blue and 
light green/blue. Regardless, it is quite possible for Bob to have no conceptual distinction between the actual and perceived colours of the object while 
Alice does have such a distinction.

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

19

Table 2
The model properties expressed by several sopml formulas.

sopml formula
∀p((cid:2)a p → (cid:2)b p)
∀p((cid:2)c p → (cid:2)a(cid:2)b p)
∀p(¬(cid:2)a⊥)
∀p((cid:2)a p → p)
∀p(¬(cid:2)a p → (cid:2)b¬(cid:2)c p)
∀p(¬(cid:2)a p → ¬(cid:2)b(cid:2)c p)
∀p((¬(cid:2)a p ∧ ¬(cid:2)bq) → ¬(cid:2)c (p ∨ q))

Model property
∀U ∈ D(Ra(w) ⊆ U → Rb(w) ⊆ U )
∀U ∈ D(Rc (w) ⊆ U → (Rb ◦ Ra)(w) ⊆ U )
∃v Ra(w, v)
∀U ∈ D(Ra(w) ⊆ U → w ∈ U )
∀U ∈ D(Rb(w) (cid:2) U → ∀v(Ra(w, v) → Rc (v) (cid:2) U ))
∀U ∈ D(Ra(w) (cid:2) U → (Rc ◦ Rb)(w) (cid:2) U )
∀U 1 ∈ D∀U 2 ∈ D((Ra(w) (cid:2) U 1 ∧ Rb(w) (cid:2) U 2) → (Rc (w) (cid:2) U 1 ∪ U 2))

Table 3
Axiomatisation results for languages L without common knowledge.

S5 (|I| = 1)
Axiomatisable [21]

S5 (|I| ≥ 2)
Unaxiomatisable (Theorem 50)

K

Unaxiomatisable [21]

Axiomatisable (Theorem 43)

Full

Modal

Boolean

Axiomatisable [21]

Axiomatisable (Theorem 43)

All

Axiomatisable (Theorem 43)

Table 4
Axiomatisation results for languages L∗
S5 (|I| = 1)
Axiomatisable [21]

Full

with common knowledge.
S5 (|I| ≥ 2)
Unaxiomatisable (Theorem 50)

K

Unaxiomatisable [21]

Modal

Axiomatisable (Theorem 43)

Unaxiomatisable (Theorem 62)

Unaxiomatisable (Theorem 57)

Boolean
All

Axiomatisable [21]
Axiomatisable (Theorem 43)

Unaxiomatisable (Corollary 63)

Unaxiomatisable (Corollary 60)

4.  (In)completeness

One well-established way to understand a logic is to introduce an axiomatisation for it. After all, since there is an inﬁnite 
number of valid formulas, we cannot explicitly enumerate all of them. But if we have a complete axiomatisation, then we 
can at least implicitly know the valid formulas and understand why they are valid.

It  turns  out  that  not  all  variants  of  SOPML  are  axiomatisable.  Still,  even  if  a  logic  is  unaxiomatisable  it  is  worthwhile 
to  prove  that  it  is  so,  for  two  reasons.  Firstly,  of  course,  if  we  have  a  proof  that  no  axiomatisation  exists,  then  we  can 
stop  trying  to  ﬁnd  an  axiomatisation.  Secondly,  even  though  an  unaxiomatisability  result  arguably  provides  less  insight 
regarding the theorems of the logic than an axiomatisation, it does still tell us something about the logic, particularly about 
its computational complexity.

In  this  paper  we  discuss  many  different  variants  of sopml,  which  differ  on  the  domain  of  quantiﬁcation  (full,  modal, 
boolean, any), restrictions on the accessibility relations (reﬂexive, transitive, symmetric), availability of common knowledge, 
and the number of indices. For some of these variants, axiomatisability and unaxiomatisability results are known from [21,
36,37].  In  particular,  [21] provides  axiomatisations  for  all  single  agent  normal  logics  interpreted  on  boolean  and  generic 
frames, as well as an axiomatisation for epistemic full frames. Here we extend several of these results to the multi-modal 
case  for  the  ﬁrst  time.  Tables 3 and  4 give  an  overview  of  these  results.  In  summary,  the  results  are  that sopml without 
common  knowledge  is  unaxiomatisable  on  full  frames  (with  the  exception  of  the  special  case  of  single-agent S5),  but 
axiomatisable  on  modal,  boolean  and  the  class  of  all  frames,  while sopml with  common  knowledge  is  unaxiomatisable 
regardless of the domain of quantiﬁcation.3 Note that, if |I| = 1 then (cid:2)∗
reduces to (cid:2) on S5 frames, so the entries in the 
ﬁrst column of Table 4 follow immediately from the results in the ﬁrst column of Table 3.

So in most cases, adding common knowledge makes the validity problem harder. This is in contrast to the model checking 
problem,  where  adding  common  knowledge  is  “free”,  in  the  sense  that  model  checking  for sopml is  PSPACE-complete, 
whether or not we have a common knowledge operator (see Theorem 17).

We  restrict  ourselves  to  the  classes  of  models  for  logics S5 and K in  these  tables.  This  is  because  these  two  classes 
are the most relevant for our analysis. Our axiomatisability results are slightly more general, see Theorem 43 for the exact 
statement. Our unaxiomatisability results are stated for logics S5 and K, but with a few minor modiﬁcations these proofs 
could easily be adapted to other normal modalities, including KD45 and S4.2. Such results give us useful insights into the 
computational properties of sopml, as well as its amenability for knowledge representation and reasoning.

Remark 29. In most of this paper, we use different notation for sopml ((cid:2)a, ♦a, (cid:2)∗
discuss both sopml and sopel, so for the sake of readability we only use the sopml notation.

) and sopel (Ka, Ma, C ). In this section we 

3 Again, with the exception of the single agent S5 case.

20

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

Also,  we  write sopml to  denote  generically  logics  without  operator  (cid:2)∗

,  while sopml∗

refers  to  logics  with  (cid:2)∗

.  The 

distinction will be clear from the context.

4.1.  Complete axiomatisations

This section is devoted to axiomatise several classes of validities on Kripke frames built on sets  I of agent indices and 
A P of atomic propositions. We ﬁrst present a class of logics  Kx, one for each  x ∈ {ap, pl, ml}. In this section all logics are 
deﬁned on languages without common knowledge.

Deﬁnition 30 (Logics Kx). For each x ∈ {ap, pl, ml}, the axioms and inference rules of Kx are as follows:

Prop
K
Exx
BF
MP
Nec
Gen

all instances of propositional tautologies
(cid:2)a(φ → ψ) → ((cid:2)aφ → (cid:2)aψ)
∀pφ → φ[p/ψ], where ψ ∈ Lx
∀p(cid:2)aφ → (cid:2)a∀pφ
from φ → ψ and φ infer ψ
from φ infer (cid:2)aφ
from φ → ψ infer φ → ∀pψ, for p not free in φ

The axioms Prop and K are standard of any modal logic, as are the rules Modus Ponens (MP) and Necessitation (Nec). 
Note how axiom Exx is parameterised by x ∈ {ap, pl, ml}. The axiom speciﬁes the language Lx which acts as the domain of 
quantiﬁcation, or, more precisely, what kind of formulas can be substituted as an instance for the universal quantiﬁer. Axiom
BF is known as the Barcan formula and it says the following. In our models M = (cid:17)W , D, R, V (cid:18) the domain of quantiﬁcation 
D is deﬁned globally, and does not depend on the world w of evaluation. To give an example where the dependence of D on 
world  w would cease BF to hold, consider a structure N = (cid:17)W , {D w }w∈W , R, V (cid:18), with W = {x, y, z} and  R = {(x, y), ( y, z)}. 
Also, suppose  D x = {{x}, { y, z}} and  D y = 2W (cid:7)= D x. Then, by restricting the clause for quantiﬁcation in Deﬁnition 8 to each 
D w , we have (N , x) |= ∀p(cid:2)(p → (cid:2)p) but not (N , x) |= (cid:2)∀p(p → (cid:2)p). In Example 31 we prove that the converse of BF is 
derivable in all Kx.

The  scheme  of  axioms Exx and  the  Generalisation  rule Gen are  typical  principles  of  quantiﬁcation.  Axiom Exx is  the 
elimination axiom for ∀: if something holds for all allowed valuations, then it also holds for each instance from the domain 
(which can be the set of all atoms, boolean formulas, or modal formulas.) The rule of Generalisation is the introduction rule 
for ∀: if ψ follows from φ for an arbitrary  p, we infer that ∀pψ follows from φ.

As customary in pml, by considering a suitable combination of axioms

T (cid:2)aφ → φ
φ → (cid:2)a (cid:27)a φ
B
4 (cid:2)aφ → (cid:2)a(cid:2)aφ

we can introduce the following normal extensions of Kx, also for x ∈ {ap, pl, ml}:

Tx
S4x
Bx
S5x

:= Kx + T
:= Kx + T + 4
:= Kx + T + B
:= Kx + T + B + 4

This gives us 15 logics, 5 for each type x ∈ X .
The notions of proof and theoremhood are deﬁned as usual. A formula φ is derivable in logic L from a set (cid:14) of formulas, 

(cid:2)

(cid:2)

or (cid:14) (cid:28)L φ, iff for some φ0, . . . , φm ∈ (cid:14), formula 

i≤m φi → φ is a theorem in L, or (cid:28)L

i≤m φi → φ.

Example 31. As an example, we provide proofs in logic  Kap of the following theorems and derived inference rules, which 
will be routinely used in the rest of the section, often without explicit mention:

• converse of the Barcan formula CBF (cid:2)∀pφ → ∀p(cid:2)φ:

1. ∀pφ → φ
2. (cid:2)a(∀pφ → φ) → ((cid:2)a∀pφ → (cid:2)aφ)
3. (cid:2)a(∀pφ → φ)
4. (cid:2)a∀pφ → (cid:2)aφ
5. (cid:2)a∀pφ → ∀p(cid:2)aφ

by axiom Exap
by axiom K
from (1) by rule Nec
from (2), (3) by rule MP
from (4) by rule Gen, as p is not free in (cid:2)a∀pφ

• vacuous quantiﬁcation φ → ∀pφ, whenever  p does not appear in φ:

1. φ → φ
2. φ → ∀pφ

propositional tautology
by axiom Gen

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

21

By axiom Exap we then obtain φ ↔ ∀pφ, whenever  p does not appear in φ.

• distribution of quantiﬁcation ∀p(φ → ψ) → (∀pφ → ∀pψ):

1. ∀p(φ → ψ) → (φ → ψ)
2. ∀pφ → φ
3. φ → (∀p(φ → ψ) → ψ)
4. ∀pφ → (∀p(φ → ψ) → ψ))
5. ∀p(φ → ψ) → (∀pφ → ψ)
6. (∀p(φ → ψ) ∧ ∀pφ) → ψ
7. (∀p(φ → ψ) ∧ ∀pφ) → ∀pψ from (6) by Gen
8. ∀p(φ → ψ) → (∀pφ → ∀pψ) from (7) by tautology ( A → (B → C)) ↔ (( A ∧ B) → C)

by axiom Exap
by axiom Exap
from (1) by tautology ( A → (B → C)) ↔ (B → ( A → C))
from (2), (3) by transitivity of implication
from (4) by tautology ( A → (B → C)) ↔ (B → ( A → C))
from (5) by tautology ( A → (B → C)) ↔ (( A ∧ B) → C)

Since CBF, vacuous quantiﬁcation and distribution of quantiﬁcation are provable in Kap , they are theorems in all the other 
14 logics above. We also recall that inferring (cid:2)aφ → (cid:2)aψ from φ → ψ is a derivable rule in modal logic, and whenever  p
does not appear free in φ, formula ∀p(φ → ψ) → (φ → ∀pψ) is a theorem in all our logics.

We now prove the soundness and completeness results for logics Lx w.r.t. the corresponding class K of Kripke frames, 
starting with soundness. In the rest of the paper  L ranges over  {K, T, S4, B, S5}. Given a logic  Lx, let τ (Lx) be a subset of 
{r, t, s}, such that Lx includes axiom T iff τ contains r (for reﬂexivity), Lx includes axiom 4 iff τ contains t (for transitivity), 
and Lx includes axiom B iff τ contains s (for symmetry).

Theorem 32 (Soundness). For x ∈ {ap, pl, ml}, for every logic Lx and formula φ ∈ Lsopml,

(cid:28)Lx φ implies Kτ (Lx)

(cid:5)x

|= φ

(cid:5)x

Proof. As customary, the axioms of each logic Lx are shown to be valid in the corresponding class Kτ (Lx)
of frames, and the 
inference rules are shown to preserve validity in Kτ (Lx)
. Speciﬁcally, axioms Prop, K, MP, and Nec are valid in any frame. 
The  validity  of  axioms T, 4,  and B in  speciﬁc  classes  of  frames  follows  as  in  standard  propositional  modal  logics  [7].  The 
validity  of  axioms Exx in  each  corresponding  class  of  frames  follows  by  Lemma 11.(2),  while  the  validity  of Gen follows 
by  Lemma 11.(1).  We  provide  a  proof  for  Exap:  suppose  that  (M, w) |= ∀pφ,  that  is,  for  every  U ∈ D,  (Mp
U , w) |= φ.  By 
Lemma 11.(a), (cid:2)ψ(cid:3) ∈ D, hence in particular (Mp
(cid:2)ψ(cid:3), w) |= φ. Then, by Lemma 11.(b), (M, w) |= φ[p/ψ]. As regards Gen, 
p
suppose  that  (M, w) |= φ and  p /∈ fr(φ).  In  particular,  for  every  U ∈ D,  V (fr(φ)) = V
U (fr(φ)),  and  by  Lemma 11.(1),  we 
have (Mp
U , w) |= ψ , and since U is arbitrary, (M, w) |= ∀pψ . Moreover, the 
Barcan  formula BF is  valid  as  in  any  frame  all  worlds  have  the  same  domain  of  quantiﬁcation,  namely  D ⊆ 2W .  Indeed, 
(cid:6)) |= φ. But this means that for every 
(M, w) |= ∀p(cid:2)aφ iff for all U ∈ D, (Mp
w

U , w) |= φ as well. By MP we obtain that (Mp

(cid:6)) |= ∀pφ, that is, (M, w) |= (cid:2)a∀pφ. (cid:2)

U , w) |= (cid:2)aφ, iff for every  w

(cid:6) ∈ Ra(w), (M, w

(cid:6) ∈ Ra(w), (Mp

U , w

(cid:5)x

As a consequence of Theorem 32, all our 15 logics are sound w.r.t. the corresponding classes of frames. Moreover, as a 

by-product of soundness, we obtain that the inclusions (4) between theories put forward in Section 2.2 are all strict:

Th(Kall) ⊂ Th(Kbool) ⊂ Th(Kmodal) ⊂ Th(Kfull)

(13)

To prove this, observe that each axiom Exx holds in K(cid:5)x, but in no more general class of frames. Finally, let Exsopml be 

the scheme ∀pφ → φ[p/ψ], for ψ ∈ Lsopml. It is easy to check that Exsopml ∈ Th(Kfull), but Exsopml /∈ Th(Kmodal).

Next we state the completeness result. Here we use the notation of Theorem 32.

Theorem 33 (Completeness). For x ∈ {ap, pl, ml}, and every formula φ ∈ Lsopml,

Kτ (Lx)
(cid:5)x

|= φ implies (cid:28)Lx φ

Theorem 33 guarantees completeness of a logic of sort x, with respect to models of type (cid:5)x, for the sorts of atomic propo-
sitions and propositional and modal formulas. Completeness also holds if we add properties such as reﬂexivity, transitivity, 
and symmetry to the frames, as long as we add the corresponding axioms from {T, 4, B} to the logic. To our knowledge this 
is the ﬁrst completeness result for sopml in a multi-agent setting.

To prove Theorem 33 for x ∈ {ap, pl, ml}, we show that if a formula φ is Lx-consistent, then we can construct an appro-
priate  model MLx that  satisﬁes  φ.  For  logic Lap (respectively, Lpl, Lml)  this  amounts  to  ﬁnding  models  whose  underlying 
frame is any frame (respectively, a boolean algebra or a boolean algebra with operators). We begin with the cases for Lap
for clarity’s sake.

22

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

4.1.1.  Completeness of Lap

In this section we show that if a formula φ is Lap-consistent, that is, (cid:3)Lap

¬φ, then we can construct a (canonical) model 
= (cid:17)F , V (cid:18) that satisﬁes φ. Moreover, F is shown to belong to the class Kall of all frames. This implies that Kall (cid:7)|= ¬φ.

MLap

Deﬁnition 34. Let (cid:15) ⊆ Lsopml be sets of formulas over set  A P of atoms, and Y a denumerable set of atoms. We say that (cid:15)
is

Lap-consistent
complete
maximal
Y -rich
saturated

iff
iff
iff
iff
iff

⊥

(cid:15) (cid:3)Lap
for every formula φ ∈ Lsopml, φ ∈ (cid:15) or ¬φ ∈ (cid:15)
(cid:15) is consistent and complete
for every φ ∈ Lsopml, if ∃pφ ∈ (cid:15) then φ[p/q] ∈ (cid:15) for some q ∈ Y
(cid:15) is maximal and Y -rich for some Y ⊆ A P

We omit the subscript Lap whenever clear by the context.

We  remark  that,  by  the  deﬁnition  of  derivability,  a  set  (cid:15) is  inconsistent  iff  for  some  φ0, . . . , φm ∈ (cid:15),  (cid:28)

(cid:2)

that is, (cid:28)

i≤m φi → ¬ψ for every ψ ∈ (cid:15).

We now prove that every consistent set can be saturated.

(cid:2)

i≤m φi → ⊥, 

Lemma 35 (Saturation). Let (cid:14) be a maximal set of formulas over A P . Then there exists a saturated set of formulas (cid:5) over A P ∪ Y , 
such that (cid:14) ⊂ (cid:5), where Y is an inﬁnite set of new atoms (i.e., disjoint from A P ).

Proof. Let  θ0, θ1, . . . be  an  enumeration  of  the  formulas  over  A P ∪ Y ,  and  q0, q1, . . . an  enumeration  of  atoms  in  Y .  We 
deﬁne by induction a sequence (cid:5)0, (cid:5)1, . . . of sets of formulas over  A P ∪ Y as follows:

(cid:5)0 = (cid:14)
⎧
⎪⎪⎪⎨
⎪⎪⎪⎩

(cid:5)n+1 =

(cid:5)n ∪ {θn}
(cid:5)n ∪ {θn, χ [p/q]}

(cid:5)n ∪ {¬θn}

if (cid:5)n ∪ {θn} is consistent and θn is not of the form ∃pχ ;
if (cid:5)n ∪ {θn} is consistent, θn is of the form ∃pχ ,
and q ∈ Y is the ﬁrst atom not appearing in (cid:5)n ∪ {θn};
otherwise.

Notice that, since Y is an inﬁnite set of new atoms and ﬁnitely many θ appear in (cid:5)n \ (cid:5)0, for each n ∈ N, we can always 
ﬁnd an atom q ∈ Y that does not appear in (cid:5)n ∪ {θn}. Now we prove by induction on n that every (cid:5)n is consistent. First 
of all, (cid:5)0 = (cid:14) is consistent by hypothesis. As to the inductive step, suppose that (cid:5)n is consistent, we consider the various 
cases.  If  (cid:5)n+1 = (cid:5)n ∪ {θn} and  θn is  not  of  the  form  ∃pχ ,  then  (cid:5)n ∪ {θn} = (cid:5)n+1 has  to  be  consistent,  by  construction. 
Further,  (cid:5)n+1 = (cid:5)n ∪ {θn, χ [p/q]} if  (cid:5)n ∪ {θn} is  consistent,  θn is  of  the  form  ∃pχ ,  and q is  the  ﬁrst  atom  that  does  not 
appear in (cid:5)n ∪ {θn}. To obtain a contradiction, suppose that (cid:5)n+1 is inconsistent. In particular, for some ϕ0, . . . , ϕm ∈ (cid:5)n,

Since q is assumed not to appear in (cid:5)n nor in θn, by an application of Gen we obtain

ϕi ∧ θn) → ∀p¬χ

i≤m
i≤m ϕi ∧θn) → ¬θn, and, since (cid:28) (

(cid:2)

i.e., (cid:28) (
is not consistent, against hypothesis. Hence, (cid:5)n+1 = (cid:5)n ∪ {θn, χ [p/q]} is indeed consistent.

i≤m ϕi ∧θn) → θn trivially, we obtain that (cid:28) (

Finally, (cid:5)n+1 = (cid:5)n ∪ {¬θn} only if (cid:5)n ∪ {θn} is not consistent. Indeed, if (cid:5)n is consistent, (cid:5)n ∪ {θn} and (cid:5)n ∪ {¬θn} cannot 
0, . . . , ϕ(cid:6)

be both inconsistent, since otherwise for some ϕ0, . . . , ϕm, ϕ(cid:6)

m(cid:6) ∈ (cid:5)n,

(cid:2)

i≤m ϕi ∧θn) → ⊥, that is, (cid:5)n ∪{θn}

(cid:28) (

ϕi ∧ θn) → ¬χ [p/q]

(cid:7)

i≤m

(cid:7)

(cid:28) (

(cid:2)

(cid:7)

(cid:28)

(cid:28)

ϕi → ¬θn

i≤m
(cid:7)

i≤m(cid:6)

ϕ(cid:6)

i

→ ¬¬θn

and by propositional reasoning,

(cid:7)

(cid:28)

ϕi ∧

(cid:7)

ϕ(cid:6)

i

→ (¬θn ∧ θn)

i≤m

i≤m(cid:6)

and therefore (cid:5)n itself is inconsistent, a contradiction. Hence, (cid:5)n ∪ {¬θn} = (cid:5)n+1 is indeed consistent.

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

23

(cid:4)

Now let (cid:5) =
n∈N (cid:5)n: (cid:5) is consistent as each (cid:5)n is. If that were not the case, there would be ϕ0, . . . , ϕm ∈ (cid:5) such that 
(cid:2)
i≤m ϕi → ⊥. Then suppose that k is the smallest index such that all φi appear in (cid:5)k. It follows that (cid:5)k is inconsistent 

(cid:28)
as well, against hypothesis. Moreover, (cid:5) extends (cid:14) and it is maximal and Y -rich by construction. (cid:2)

We now describe informally the construction of the canonical model for a formula φ such that (cid:3) ¬φ. First, deﬁne W as 
the set of all saturated sets w of formulas over  A P ∪ Y as obtained in Lemma 35. Notice that W is non-empty as the set {φ}
(cid:6) ∈ W and a ∈ I , 
is consistent by hypothesis, and by Lemma 35 there exists a saturated set (cid:5) ⊇ {φ} in W . Further, for  w, w
. Finally, for every atom  p ∈ A P ∪ Y , we consider set  U p = {w ∈ W | p ∈ w} ⊆ W
deﬁne  Ra(w, w
and deﬁne the domain  D of propositions as {U p | p ∈ A P ∪ Y }.

(cid:6)) iff {ψ | (cid:2)aψ ∈ w} ⊆ w

(cid:6)

Deﬁnition 36 (Canonical model). The canonical model L is a tuple ML = (cid:17)W ,  D,  R, V (cid:18) where (i) W ,  D and  R are deﬁned as 
above; and (ii) V is the assignment such that V (p) = U p .

Note  that  every  consistent  formula  φ must  be  contained  in  some  (cid:5) ∈ W .  Next  we  prove  that  the  canonical  model 
(recall that  (cid:5)ap = all and that Lap represents 5 different logics: 

w.r.t. any Lap is indeed a model based on a frame in Kτ (Lap)
Kap, Tap, S4ap, Bap, and S5ap).

all

Lemma 37. The canonical model MLap in Deﬁnition 36 is a Kripke model based on a frame in Kτ (Lap)

all

.

Proof. By the remarks above, W is a non-empty set of saturated sets, D is a subset of 2W , and V is a function from  A P ∪ Y
to  D. Moreover, axiom T (respectively, 4, B) enforces relation  Ra on  W to be reﬂexive (respectively, transitive, symmetric), 
as  it  is  the  case  for  propositional  modal  logic.  As  an  illustrative  example,  we  consider  the  case  for T:  by  maximality,  for 
every  w ∈ W , (cid:2)aψ → ψ ∈ w for every formula ψ ∈ Lsopml, and by closure under MP we have {ψ ∈ Lsopml | (cid:2)ψ ∈ w} ⊆ w, 
that is,  Ra(w, w) by deﬁnition. (cid:2)

We can ﬁnally prove the truth lemma for logics Lap. Here we adapt the proof in [20] for propositional epistemic languages 

without common knowledge.

Lemma 38 (Truth lemma). For every logic Lap, in the canonical model MLap , for every w ∈ W and every formula ψ over A P ∪ Y ,

(MLap , w) |= ψ iff ψ ∈ w

iff ψ ∈ w.

Proof. The  proof  is  by  induction  on  the  length  of  ψ .  As  to  the  base  of  induction  for  ψ = p,  by  deﬁnition  of  satisfaction, 
(MLap , w) |= p iff  w ∈ V (p) iff  p ∈ w.

For ψ = ¬χ , (MLap , w) |= ψ iff (MLap , w) (cid:7)|= χ , iff by induction hypothesis χ /∈ w. Since  w is maximal, this is the case 

For  ψ = χ → χ (cid:6)

,  (MLap , w) |= ψ iff  (MLap , w) (cid:7)|= χ or  (MLap , w) |= χ (cid:6)

χ /∈ w or χ (cid:6) ∈ w; in both cases we have that ψ ∈ w, as  w is maximal.

.  By  induction  hypothesis  this  is  the  case  iff 

p
U q

Suppose  that  ψ = ∀pχ .  ⇐ Let  ψ ∈ w.  By  axiom Exap we  have  that  χ [p/q] ∈ w for  every  q ∈ A P ∪ Y .  By  induction 
hypothesis (MLap , w) |= χ [p/q] for every q. Now, take an arbitrary U q = {w ∈ W | q ∈ w} in the domain  D of the canonical 
model. By Lemma 11.(2b), ((MLap )p
was chosen arbitrarily, we obtain that (MLap , w) |= ψ . 
U q
⇒ Assume that ψ /∈ w. Since  w is maximal, ∃p¬χ ∈ w, and  w is  Y -rich, so ¬χ [p/q] ∈ w for some atom q ∈ Y . Then, by 
induction hypothesis, (MLap , w) (cid:7)|= χ [p/q], and by Lemma 11.(2b), ((MLap )p
V (q), w) (cid:7)|= χ . In particular, for  U q = V (q) ∈ D, 
((MLap )p
U q

, w) (cid:7)|= χ , i.e., (MLap , w) (cid:7)|= ψ .

, w) |= χ , and since variant V

Suppose  that  ψ = (cid:2)aχ .  ⇐ Assume  that  ψ ∈ w and  v ∈ Ra(w).  By  deﬁnition  of  Ra,  χ ∈ v;  therefore  by  induction 
hypothesis (MLap , v) |= χ . Thus, (MLap , w) |= ψ . ⇒ Assume that ψ /∈ w and consider set {φ | (cid:2)aφ ∈ w} ∪ {¬χ }. This set is 
(cid:2)aφ → (cid:2)aχ and since 
consistent, for if not, then for some φ1, . . . , φn ∈ {φ | (cid:2)aφ ∈ w}, (cid:28)
(cid:2)
(cid:2)aφ ∈ w, also (cid:2)aχ ∈ w against hypothesis. Now we want to saturate (cid:14) = {φ | (cid:2)aφ ∈ w} ∪ {¬χ } to obtain  v ∈ W such 
that  Ra(w, v) and ¬χ ∈ v. However, we cannot directly apply Lemma 35 to (cid:14), as it is a set of formulas over  A P ∪ Y . We 
prove that (cid:14) can nonetheless be extended to a saturated set (cid:5) of formulas over  A P ∪ Y . The proof structure is similar to 
the one for Lemma 35, namely, we deﬁne a sequence (cid:5)0, (cid:5)1, . . . of sets of formulas over  A P ∪ Y as follows:

φ → χ . Then, by axiom K, (cid:28)

(cid:2)

(cid:2)

(cid:5)0 = (cid:14)
⎧
(cid:5)n ∪ {θn}
⎪⎪⎪⎪⎪⎨
(cid:5)n ∪ {θn, ζ [p/q]}
⎪⎪⎪⎪⎪⎩
(cid:5)n ∪ {¬θn}

(cid:5)n+1 =

if (cid:5)n ∪ {θn} is consistent and θn is not of the form ∃pζ ;
if (cid:5)n ∪ {θn} is consistent, θn is of the form ∃pζ ,
and q ∈ A P ∪ Y is the ﬁrst atom such that
(cid:5)n ∪ {θn, ζ [p/q]} is consistent;
otherwise.

24

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

We prove by induction on n that every (cid:5)n is consistent (and well-deﬁned). First of all, (cid:5)0 = (cid:14) is consistent as shown 
above. As to the inductive step, suppose that (cid:5)n is consistent. We only consider the case where (cid:5)n ∪ {θn} is consistent and 
θn is of the form ∃pζ , and show that (cid:5)n+1 is well-deﬁned, that is, there exists q ∈ A P ∪ Y such that (cid:5)n ∪ {θn, ζ [p/q]} is 
consistent as well. To obtain a contradiction, suppose that for every q ∈ A P ∪ Y , there exist (cid:2)aϕ0, . . . , (cid:2)aϕm in  w such that

(cid:7)

(cid:28)

(cid:7)

ϕi → (

ψi ∧ θn → ¬ζ [p/q])

i≤m

i≤n

where ψ0, . . . , ψn are all the formulas in (cid:5)n \ (cid:14).

By axiom K we obtain

(cid:7)

(cid:7)

(cid:28)

(cid:2)aϕi → (cid:2)a(

ψi ∧ θn → ¬ζ [p/q])

i≤m

i≤k

(cid:2)

and  since  all  (cid:2)aϕi belong  to  w,  by  maximality  we  derive  that  (cid:2)a(
(cid:2)
Take an atom q not occurring in 
(cid:2)
formula is a member of  w, because, if not, by maximality, ∃q(cid:3)a(
(cid:6) ∈ A P ∪ Y , we have (cid:3)a(
q

(cid:6)]) ∈ w, contradicting (*).

i≤k ψi ∧ θn and consider the formula ∀q(cid:2)a(

(cid:2)

(cid:2)

(cid:2)

i≤k ψi ∧ θn → ¬ζ [p/q]) ∈ w for  all  q ∈ A P ∪ Y (*). 
i≤k ψi ∧ θn → ¬ζ [p/q]). We claim that this 
i≤k ψi ∧ θn ∧ ζ [p/q]) ∈ w, and, by saturation, for some 

Since ∀q(cid:2)a(

i≤k ψi ∧ θn → ¬ζ [p/q]) ∈ w as well, and 
i≤k ψi ∧θn →
since q is assumed not to appear in 
∀q¬ζ [p/q] ∈ (cid:14). Further, since ψ0, . . . , ψn belong to (cid:5)n, we obtain that (cid:5)n ∪ {θn} (cid:28) ∀q¬ζ [p/q]. But this contradicts the fact 
that (cid:5)n ∪ {θn} is consistent (recall that θn = ∃pζ ). As a result, (cid:5)n ∪ {θn, ζ [p/q]} is indeed consistent for some q ∈ A P ∪ Y .

i≤k ψi ∧ θn → ¬ζ [p/q]) ∈ w by axiom BF we obtain that (cid:2)a∀q(
i≤k ψi ∧θn we derive (cid:2)a(

i≤k ψi ∧θn → ∀q¬ζ [p/q]) ∈ w, and therefore 

The other inductive cases of the construction go as in Lemma 35. Finally, (cid:5) =

n∈N (cid:5)n is consistent as each (cid:5)n is so. In 
particular, (cid:5) is a saturated set in W such that (cid:5) ∈ Ra(w) by construction. By induction hypothesis (MLap , (cid:5)) (cid:7)|= χ , that is, 
(MLap , w) (cid:7)|= ψ . (cid:2)

(cid:4)

(cid:2)

(cid:2)

i≤k ψi ∧ θn ∧ ζ [p/q
(cid:2)

(cid:2)

By  Lemma 38,  if  (cid:3)Lap

¬φ then  there  exists  a  saturated  set  w ⊇ {φ} such  that  in  the  canonical  model MLap ,  we  have 
(MLap , w) |= φ. Moreover, MLap is based on a frame F ∈ Kall. Thus, Kall (cid:7)|= ¬φ. This concludes the completeness proof for
Lap.

4.1.2.  Completeness of Lpl and Lml

In this section we discuss how to adapt the completeness proof for Lap in the previous section to logics Lpl and Lml. As 
regards Lpl, we need to modify the deﬁnition of the canonical model and the proof of the truth lemma, starting with the 
former.

Deﬁnition 39 (Canonical model). The canonical model for Lpl is a tuple MLpl

= (cid:17)W , D, R, V (cid:18) where

• W ,  R and V are given as in Deﬁnition 36;
• D is the domain of sets U ψ = {w ∈ W | ψ ∈ w} ⊆ W , for every propositional formula ψ ∈ Lpl over  A P ∪ Y .

Given Deﬁnition 39 of canonical model, we can show that it is indeed based on a boolean frame.

Lemma 40. The canonical model MLpl is boolean.

Proof. We have to prove that domain  D is closed under boolean operations. Let  U φ and  U φ(cid:6) be sets in  D, we show that 
U φ ∩ U φ(cid:6) = U φ∧φ(cid:6) ∈ D. Clearly, w ∈ U φ ∩ U φ(cid:6) iff φ ∈ w and φ(cid:6) ∈ w, and by maximality, this is the case iff φ ∧ φ(cid:6) ∈ w as well. 
Closure under disjunction is proved similarly. As to taking complement, we show that W \ U φ = U ¬φ ∈ D. Again, w /∈ U φ iff 
φ /∈ w, and by maximality, this is the case iff ¬φ ∈ w. (cid:2)

As a consequence of Lemma 40, MLpl is based on a frame in Kbool. Moreover, we are able to prove the following version 

of the truth lemma.

Lemma 41 (Truth lemma). For every logic Lpl, in the canonical model MLpl , for every w ∈ W and every formula ψ over A P ∪ Y ,

(MLpl , w) |= ψ iff ψ ∈ w

Proof. To  prove  the  truth  lemma  for  Lpl we  have  to  modify  the  proof  of  Lemma 38.  Speciﬁcally,  we  can  ﬁrst  prove  that 
for  every  ψ ∈ Lpl,  (MLpl , w) |= ψ iff  ψ ∈ w,  as  in  Lemma 38.  In  particular,  we  obtain  that  U ϕ = (cid:2)ϕ(cid:3)MLpl
= {w ∈ W |
(MLpl , w) |= ϕ} ∈ D. Then, the proof for any ψ ∈ Lsopml is given by induction on the length of ψ , similarly as in Lemma 38, 
the only case of interest being quantiﬁed formulas. For ψ = ∀pχ , if ψ ∈ w then by axiom Expl we have that χ [p/ϕ] ∈ w, 

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

25

for any φ ∈ Lpl. By induction hypothesis, (MLpl , w) |= χ [p/ϕ]. Now consider the set U ϕ = (cid:2)ϕ(cid:3)MLpl
∈ D. By Lemma 11.(2b), 
it is the case that ((MLpl )p
, w) |= χ , and since the choice of ϕ (and therefore of variant  V
) is arbitrary, we obtain that 
Uϕ
(MLpl , w) |= ∀pχ . As to the implication from left to right, the proof is the same as in Lemma 38, as each w is maximal and 
rich. (cid:2)

p
Uϕ

As  a  consequence  of  Lemma 41,  the  truth  lemma  also  holds  for  boolean  frames  and  we  obtain  a  completeness  proof 

for Lpl.

We now discuss how to modify the procedure above to obtain completeness results for the logics Lml. Firstly, the canon-
ical model for Lml is now deﬁned as a tuple MLml
= (cid:17)W , D, R, V (cid:18) where (i) W ,  R and V are given as in Deﬁnition 36; and 
(ii) D is the domain of sets U ψ = {w ∈ W | ψ ∈ w} ⊆ W , for every modal formula ψ ∈ Lml over  A P ∪ Y . In particular, it is 
easy to check that the domain D in MLml is a boolean algebra with operators. Secondly, by adapting the proof of Lemma 41, 
we can prove the truth lemma for MLml :

Lemma 42 (Truth lemma). For every logic Lml, in the canonical model MLml , for every w ∈ W and every formula ψ over A P ∪ Y ,

(MLml , w) |= ψ iff ψ ∈ w

This completes the completeness proof for the logics Lml.
We conclude the section by summarising the soundness and completeness results for our logics w.r.t. the relevant classes 

of frames.

Theorem 43 (Soundness and completeness). For x ∈ {ap, pl, ml}, each logic Lx is sound and complete w.r.t. the class Kτ (Lx)
that are reﬂexive (respectively, transitive, symmetric), whenever Lx includes axiom T (respectively, 4, B).

(cid:5)x

of frames 

As  a  result,  for  types  ap,  pl,  and  ml we  are  able  to  prove  soundness  and  completeness  for  all  normal  modalities  (i.e., 

K, T, S4, B, and S5) in a multi-modal setting.

4.1.3.  Generalised completeness

We now extend the completeness results in the previous section by considering extra axioms expressing properties of 
frames. Speciﬁcally, let L be any axiomatisation mentioned in Theorem 43. Then, if we extend L with the universal closure 
∀(cid:23)pψ of a formula ψ ∈ Lsopml, the resulting calculus L + ∀(cid:23)pψ is sound and complete w.r.t. the class of frames satisfying the
mso condition ∀x∀ (cid:23)P S T x(ψ), where  (cid:23)P are all the unary predicates appearing in  S T x(ψ).

Theorem 44. Let ψ be a formula in sopml, then the logic L + ∀(cid:23)pψ is sound and complete w.r.t. the corresponding class K of frames 
satisfying ∀x∀ (cid:23)P S T x(ψ).

Proof. Soundness  follows  immediately  by  Lemma 20,  as  every  frame  that  satisﬁes  condition  ∀x∀ (cid:23)P S T x(ψ) = ∀xS T x(∀(cid:23)pψ), 
also validates ∀(cid:23)pψ . As to completeness, if ∀(cid:23)pψ is an axiom, then it appears in every state of the canonical model M, and 
by the truth lemma, M validates ∀(cid:23)pψ . Finally, by another application of Lemma 20, F validates ∀x∀ (cid:23)P S T x(ψ). (cid:2)

By the result above we immediately obtain that for every formula θ((cid:23)a, (cid:23)p) appearing in Table 1, L + ∀pθ((cid:23)a, (cid:23)p) is sound 
and  complete  w.r.t. the  class  of  frames  satisfying  ∀x∀ (cid:23)P (cid:10)((cid:23)a, x).  For  instance,  K + ∃p((cid:2)a p ∧ ¬p) is  a  sound  and  complete 
axiomatisation of the class of irreﬂexive frames (notice that, since ∃p((cid:2)a p ∧ ¬p) is a sentence, its universal closure is equal 
to  the  formula  itself.)  More  generally,  there  is  a  one-to-one  correspondence  between  a sopml axiom  ∀(cid:23)pθ and  the mso
condition ∀x∀ (cid:23)P S T x(θ) on the corresponding class of sound and complete frames.

4.2.  Incompleteness

In  Section 4.1 we  provided  complete  axiomatisations  for  languages  without  common  knowledge,  in  the  classes  of 
all,  boolean,  and  modal  frames.  In  this  section  we  prove  our  main  unaxiomatisability  results  for sopml.  Speciﬁcally,  in 
Section 4.2.1 we show that the set of validities in sopel (without common knowledge) interpreted on full frames is unax-
iomatisable whenever we assume at least two agents in our frames. Further, in Section 4.2.2 we prove that, with common 
knowledge, sopml is  unaxiomatisable  on  modal  frames  already  when  considering  a  single  agent.  We  then  demonstrate 
(Corollaries 58,  61 and 63 as  well  as  Theorem 62)  how  this  proof  can  be  extended  to  the  other  classes  of  frames.  These 
results complete Tables 3 and 4.

4.2.1.  2-agent sopel on full frames is unaxiomatisable

Recall  that,  as  discussed  at  the  beginning  of  Section 4,  an  axiomatisation  for  single-agent sopel on  full  frames  was 
introduced in [21]. Here we show that, this result cannot be generalised to the multi-agent case, i.e., we demonstrate that 
multi-agent sopel is not recursively axiomatisable on full frames.

26

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

We prove this unaxiomatisability result by reducing the validity problem of diadic second order logic (dso) to the validity 
problem  of sopel.  Since  the  former  is  known  not  to  be  recursively  enumerable,  this  implies  that  the  latter  is  also  not 
recursively  enumerable,  and  therefore  in  particular  not  axiomatisable.  The  reduction  that  we  use  is  somewhat  similar  to 
the one used in [36] to prove the unaxiomatisability of single-agent sopml on full frames with S4.2 or weaker modalities. 
Speciﬁcally, both the proof from [36] and the proof presented here represent a second order domain D in a Kripke model 
by  taking  D ⊆ W and  (D × D) ⊆ W .  Quantiﬁcation  over  diadic  relations  on  Dom then  corresponds  to  propositional  (i.e., 
monadic)  quantiﬁcation  over  (D × D).  The  difference  between  the  two  proofs  lies  in  how  they  characterise the  models 
where  D ⊆ W and  D × D ⊆ W ,  and  in  how  second  order  formulas  are  translated  once  such  a  characterisation  has  been 
established.

Since the reduction is from the validity problem of diadic second order logic, let us ﬁrst brieﬂy deﬁne this logic.
Let a set X of ﬁrst-order variables and a set R of second order variables be given. Then the language of diadic second 

order logic is given by the following normal form:

θ ::= R(x, y) | x = y | ¬θ | θ → θ | ∀xθ | ∀Rθ

where x, x ∈ X and  R ∈ R.

The formulas of dso can be evaluated on models (Dom, ρ) that consist of a domain Dom and an assignment function ρ
that  assigns  to  each  ﬁrst-order  variable  x an  element ρ(x) ∈ Dom and  to  each  second-order  variable  R a  relation ρ(R) ⊆
Dom × Dom. Given a model (Dom, ρ) an element d ∈ Dom and a relation  E ⊆ Dom × Dom, the assignments ρ[x (cid:31)→ d] and 
ρ[R (cid:31)→ E] are the modiﬁcations of ρ that map x ∈ X to d ∈ Dom and  R ∈ R to  E ⊆ Dom × Dom, respectively.

Given these preliminaries, we can deﬁne the semantics of dso in the usual way.

Deﬁnition 45. We deﬁne whether a model (Dom, ρ) satisﬁes a formula θ of dso recursively as follows:

(Dom, ρ) |= R(x, y)
(Dom, ρ) |= x = y
(Dom, ρ) |= ¬θ
(Dom, ρ) |= θ → θ (cid:6)
(Dom, ρ) |= ∀xθ
(Dom, ρ) |= ∀Rθ

iff
iff
iff
iff
iff
iff

(ρ(x), ρ( y)) ∈ ρ(R)
ρ(x) = ρ( y)
(Dom, ρ) (cid:7)|= θ
(Dom, ρ) (cid:7)|= θ or (Dom, ρ) |= θ (cid:6)
for every d ∈ Dom, (Dom, ρ[x (cid:31)→ d]) |= θ
for every E ⊆ Dom × Dom, (D, ρ[R (cid:31)→ E]) |= θ

A formula θ of dso is valid, denoted |= θ , if (Dom, ρ) |= θ for every model (Dom, ρ).

In general, a formula of dso can contain free ﬁrst- and second-order variables. Our goal is to make a reduction from the 
validity problem of dso, however, so we only care about whether a formula is valid. If θ is a dso formula with a free ﬁrst-
order variable x (a free second-order variable  R, respectively), then θ is valid if and only if ∀xθ (∀Rθ , respectively) is valid. 
As a result, it suﬃces for us to consider only the sentences of dso, i.e., the formulas without free variables. Furthermore, if 
θ is a sentence then whether (Dom, ρ) |= θ depends only on Dom. As such, we can consider our models to be given by the 
domain Dom only, where we say that Dom |= θ if and only if (Dom, ρ) |= θ for every assignment ρ.

Now, let us introduce the reduction from the validity problem of dso to sopel’s. This reduction has two parts: ﬁrstly, we 
deﬁne a formula ψmodel of sopel and use it to characterise a speciﬁc class of pointed models. Then, we deﬁne a translation 
f from the formulas of dso to the formulas of sopel, with the property that

for every formula θ in dso, there is a model Dom such that Dom |= θ iff there is a pointed model (M, w) of sopml such 
that (M, w) |= ψmodel ∧ f (θ).

Before deﬁning ψmodel and  f (φ), however, let us present an auxiliary formula ψunique(a, χ ) that will be useful in several 

places. This formula is very similar to a uniqueness formula introduced in [12].

Deﬁnition 46. Let a ∈ I be an index and χ ∈ Lsopml a formula. Then

ψunique(a, χ ) := ♦aχ ∧ ∀q(♦a(q ∧ χ ) → (cid:2)a(χ → q)).

Lemma 47. Let a be an index in I , χ ∈ Lsopml any formula, M any full epistemic model, and w any world in M. Then (M, w) |=
ψunique(a, χ ) if and only if there is exactly one a-successor w

of w such that (M, w

(cid:6)) |= χ .

(cid:6)

Proof. Suppose  (M, w) |= ψunique(a, χ ).  Then,  in  particular,  (M, w) |= ♦aχ ,  so  there  is  at  least  one a-successor  w
(cid:6)(cid:6)
such that (M, w
and  w
such that χ holds on both  w
w

of  w
of  w
. Then, since M is a full model, there is some assignment for q such that q holds in 
. As a result, for this choice of q, we have (M, w) |= ♦a(q ∧ χ ) ∧ ¬(cid:2)a(χ → q), contradicting the fact that 

(cid:6)) |= χ . Suppose now, towards a contradiction, that there are two different a-successors  w

but not in  w

and  w

(cid:6)(cid:6)

(cid:6)(cid:6)

(cid:6)

(cid:6)

(cid:6)

(cid:6)

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

27

(M, w) |= ∀q(♦a(q ∧ χ ) → (cid:2)a(χ → q)). It follows that the assumption of such  w
of  w such that (M, w
is at most one a-successor  w

(cid:6)

(cid:6)) |= χ .
(cid:6)

Suppose  then  that  there  is  exactly  one  a-successor  w

(cid:6)) |= χ .  Then  there  is  at  least  one  such 
(cid:6)) |= q ∧ χ , in 
successor, so (M, w) |= ♦aχ . Furthermore, for every assignment of q, we have ♦a(q ∧ χ ) if and only if (M, w
which case we also have (cid:2)a(χ → q). It follows that (M, w) |= ∀q(♦a(q ∧ χ ) → (cid:2)a(χ → q)). Together with the previously 
established (M, w) |= ♦aχ , this implies that (M, w) |= ψunique(a, χ ). (cid:2)

of  w such  that  (M, w

(cid:6)

and  w

(cid:6)(cid:6)

existing must be false, so there 

Now we can use ψunique to deﬁne ψmodel and  f .

Deﬁnition 48. The formula ψmodel is given by

ψmodel := (cid:2)a(ψD ∧ ψexcl ∧ ψconnect ∧ ψ≥1 ∧ ψ≤1)

where

ψD := p D ∧ ψunique(b, p D )

ψexlc :=(cid:2)b¬(p D ∧ (start ∨ end)) ∧ (cid:2)b¬(start ∧ end) ∧ (cid:2)b(p D ∨ start ∨ end)

ψconnect :=(cid:2)b(¬p D → ((cid:2)a(start ∨ end) ∧ ψunique(a, start) ∧ ψunique(a, end)))

ψ≥1 :=∀p(♦a p → ♦b(pstart ∧ ♦a(pend ∧ ♦b p))

ψ≤1 :=∀p(ψunique(a, p) → ψunique(b, start ∧ ♦a(end ∧ ♦b(p ∧ p D )))

The meaning of the named subformulas (ψD , ψexcl, ψconnect, ψ≥1 and ψ≤1) is discussed in the proof of Theorem 50.

Deﬁnition 49. Let translation function  f

is recursively deﬁned as follows.

f (x = y) = ♦a(px ∧ p y)

f (R(x, y)) = ♦a(px ∧ ♦b(p R ∧ start ∧ ♦a(end ∧ ♦b p y)))

f (¬θ) = ¬ f (θ)

f (θ1 → θ2) = f (θ1) → f (θ2)

f (∀xθ) = ∀px(ψunique(a, px) → f (θ))

f (∀Rθ) = ∀p R f (θ)

We can now prove the main result of this section.

Theorem 50. For every dso sentence θ ,

|= θ iff Ke

full

|= ψmodel → f (θ)

Proof. First,  let  us  consider  the  models  that  satisfy  ψmodel.  Let  (M, w 0) be  any  full  epistemic  pointed  model  such  that 
(M, w 0) |= ψmodel, and let Dom := Ra(w 0). The primary connective of ψmodel is (cid:2)a, so let us consider any  w ∈ Dom.

The conjunct ψD holds at w if and only if (i) w satisﬁes p D and (ii) w has only one b-successor that satisﬁes p D (and by 
(i) this unique successor has to be  w itself). We refer to the b-successors of  w as the cone on  w, as drawn in the following 
(cid:6) ∈ Dom cannot overlap, since by the fact that M is an epistemic model, 
ﬁgure. Note that cones of any two different  w, w
this would imply that  Rb(w, w

(cid:6)), contradicting the uniqueness of the  p D -world.

28

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

w 0

p D

w

p D

a

(cid:6)

w

p D

b

b

b

The  conjunct  ψexcl holds  if  and  only  if  every  state  in  a  cone  satisﬁes  exactly  one  of  p D ,  start and  end.  Now,  consider 
ψconnect. It holds if and only if every ¬p D state in a cone is connected by the relation a to exactly one state that satisﬁes 
start, to exactly one state that satisﬁes end, and only to states that satisfy either start or end. We had already established 
that no world in a cone can satisfy both start and end, so it follows that every such ¬p D state is either a start state paired 
by a with an end state, or an end state paired by a with a start state. Note that if a start or end state is in the cone of  w, 
then the state that it is paired up with could be in the cone of w, in the cone of some different state w
or it might not be 
in any cone at all.

(cid:6)

Now, consider formula ψ≥1. It states that for every choice of  p, if w has an a-successor w

a(cid:31)−→ e2
a path  w  b(cid:31)−→ e1
(cid:6) ∈ D, there is at least one such path  w  b(cid:31)−→ e1
if for every  w, w
schematic illustration can therefore be extended to the following:

b(cid:31)−→ w

(cid:6)(cid:6)

such that e1 satisﬁes start, e2 satisﬁes end and  w

a(cid:31)−→ e2

(cid:6)

(cid:6)(cid:6)

that satisﬁes  p, then there is 
satisﬁes  p. This is the case if and only 
. Our 

. Note that this also applies for  w = w

(cid:6)

b(cid:31)−→ w

(cid:6)

a

a

w

p D

start

end

end

start

a

a

start

end

a

b

a

(cid:6)

w

p D

end
a

start
start

end

start

end

b

a
a

a

w 0

p D

end

start

end

a

start

end

end

start

b

a

start

(cid:6)

(cid:6)(cid:6)

b(cid:31)−→ w

a(cid:31)−→ e2

Finally,  formula  ψ≤1 states  that  for  any  choice  of  p,  if  w has  a  unique  a-successor  w

that  satisﬁes  p,  then  w also 
has  a  unique  b-successor  e1 such  that  (i)  e1 satisﬁes  start,  (ii)  e1 has  an  a-successor  e2 that  satisﬁes  end,  and  (iii)  e2
(cid:6) ∈ D there  is  at  most  one  path 
has  a  b-successor  w
w  b(cid:31)−→ e1

that  satisﬁes  p ∧ p D .  This  is  the  case  if  and  only  if  for  every  w, w
(cid:6)

where e1 satisﬁes start and e2 satisﬁes end.
All in all, the conjunction of ψ≥1 and ψ≤1 means that there is exactly one path w  b(cid:31)−→ e1
(cid:6) ∈ D.

start and (M, e2) |= end between each  w, w

a(cid:31)−→ e2

b(cid:31)−→ w

(cid:6)

with (M, e1) |=

The pointed model (M, w 0) is then used in the following way. The suggestively named set Dom can be treated as the 
domain  of  a dso model.  First-order  quantiﬁcation  is  then  interpreted  on  selecting  exactly  one  world  w ∈ Dom.  Note  that 
this is precisely what translation function  f does: ﬁrst-order quantiﬁcation ∀xθ is translated as ∀px(ψunique(a, px) → f (θ)). 
On  the  other  hand,  second-order  quantiﬁcation  is  interpreted  on  selecting  exactly  those  start worlds  that  are  on  a  path 
w  b(cid:31)−→ e1
(cid:6)) is in the chosen relation. Again, this is exactly what translation  f does: ∀Rθ is 

, where pair (w, w

a(cid:31)−→ e2

b(cid:31)−→ w

(cid:6)

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

29

translated as ∀p R f (θ), and the relational atom R(x, y) is then translated as ♦a(px ∧ ♦b(p R ∧ start ∧ ♦a(end ∧ ♦b p y))), which 
means exactly that  R(x, y) holds iff  p R is true in the start-world in between the unique  px- and  p y -worlds.

It  follows  that  Dom |= θ if  and  only  if  (M, w 0) |= f (θ).  Since  all  we  assumed  about  M is  that  it  is  a  full  epistemic 

model and that (M, w 0) |= ψmodel, it follows that |= θ if and only if Ke
full

|= ψmodel → f (θ). (cid:2)

As  a  consequence  of  the  fact  that  validity  in dso is  not  recursively  enumerable,  we  immediately  obtain  the  following 

corollary.

Corollary 51. Multi-agent sopml on full epistemic frames is unaxiomatisable.

Remark 52. We used only two indices for modalities in our reduction, so the unaxiomatisability result holds whenever the 
set of indices contains at least two elements.

4.2.2.  Single-agent sopml∗

is unaxiomatisable on modal frames

In Section 4.1.3 we introduced sound and complete axiomatisations for sopml on the classes of modal, boolean, and all
frames. The version of sopml that we considered there does not contain common knowledge, however. This is a fundamental 
restriction; the variant sopml∗
, which is obtained by adding common knowledge to sopml, is not axiomatisable on any class 
of frames. Here, we show that sopml∗
is not axiomatisable with respect to general or epistemic models that have modal, 
boolean or arbitrary domain of quantiﬁcation. It can also be shown that sopml∗
is unaxiomatisable on intermediate classes 
of models, such as those for logics KD45 (i.e., serial, transitive and symmetric models) or S4.2 (i.e., reﬂexive, transitive and 
convergent models). We do not include proofs for these classes, however, since they are very similar to the proofs for the 
cases we treat.

We prove the unaxiomatisability of sopml∗

on modal models by a reduction from the non-halting problem to the validity 
problem  of sopml∗
.  Since  the  non-halting  Turing  machines  are  not  recursively  enumerable,  neither  are  the  validities  of
sopml∗
with  respect  to  modal models.  The  proof  that  we  use  here  is  inspired  by  a  similar  proof  from  [38],  in  which  the 
non-halting problem is reduced to the validity problem of a logic called Arbitrary Arrow Update Logic with Common Knowledge.
Before deﬁning our reduction, let us ﬁrst deﬁne the non-halting problem for Turing machines. A Turing machine, ﬁrst 
deﬁned in [50], is an abstract model of computation that consists of (i) an inﬁnite tape, with Z cells that can each contain 
a symbol, but that initially contain a “null” symbol α0; (ii) a read/write head that can read the symbol in a cell or write a 
symbol to it; (iii) a method to keep track of what state the machine is currently in; and (iv) a set of instructions that, based 
on the current state and the current symbol under the read/write head, determines what symbol is to be written, what the 
next state of the machine should be, and whether the read/write head should move to the left, to the right or remain in 
place. The Turing machines that we consider here are deterministic so for each combination of state and symbol there is 
exactly one instruction. Formally, a Turing machine T can be deﬁned as follows.

Deﬁnition 53. A  Turing  machine  T is  a  triple  T = ((cid:15), S, (cid:14)),  where  (cid:15) is  a  ﬁnite  alphabet  containing  the  symbol α0,  S is 
a ﬁnite set of states containing the distinct states  s0 and  send, and (cid:14) : (cid:15) × S → (cid:15) × S × {left, right, remain} is a transition 
function.

The functions (cid:14)1, (cid:14)2 and (cid:14)3 are the projections of (cid:14) to its ﬁrst, second and third coordinate, respectively.

We can assume without loss of generality that (cid:14)2(α, s) (cid:7)= s0 for all α ∈ (cid:15) and s ∈ S, so that the machine never returns 
to its initial state.4 The execution of such a machine T can be represented as a function E T : Z × N → (cid:15) × S × {yes, no}. The 
horizontal direction Z represents positions on the tape. The vertical direction N represents time. So  E T (n, m) = (α, s, yes)
indicates  that  at  time  m,  the  n-th  position  on  the  tape  contains  symbol  α,  the  machine  is  in  state  s and  the  read/write 
head is in position n. Likewise,  E T (n, m) = (α, s, no) indicates that at time m the read/write head is not at position n. Note 
that  E T contains some redundant information: the state is a property of the machine, not of any particular position on the 
tape. Furthermore, the read/write head is in exactly one position at a time. So, for example, if  E T (n, m) = (α, s, yes), then 
we must have  E T (n + 1, m) = (β, s, no) for some symbol β.

A Turing machine T has a designated end state send. We say that T halts if the machine ever reaches this end state, so if 

for any (n, m) and any α ∈ (cid:15), we have  E T (n, m) = (α, send, yes).

Deﬁnition 54 (Halting problem). The  halting problem is  to  determine,  for  a  given  Turing  machine  T ,  whether  T halts.  The 
non-halting problem is the complement of the halting problem, i.e., to determine whether a given Turing machine doesn’t 
halt.

Although  neither  of  them  used  this  terminology,  Church  [13] and  Turing  [50] independently  showed  that  the  halting 
problem is undecidable. More precisely, the halting Turing machines are recursively enumerable, but the non-halting Turing 
machines are not.

4 Where necessary, an extra copy scopy

0

of s0 can be added; whenever the system would go to state s0 we can then let it go to scopy

0

instead.

30

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

Remark 55. The  intuition  behind  the  end  state  is  that  the  machine  stops  when  it  reaches  send,  so  no  more  computation 
happens after that point. Here, however, in order to avoid special cases it is more convenient to assume that every Turing 
machine keeps going forever, whether or not it reaches send. So, whether or not a machine formally halts (reaches the end 
state), it never informally halts (stops).

When reducing the non-halting problem to validity in sopml∗

, it is useful to represent time not by the naturals N but by 
the integers Z, since this allows us to avoid special cases at time t = 0. For every time t < 0 we then say that the machine 
is in a dummy state svoid /∈ S, which can be read as “the computation has not started yet.”

on  modal frames.  This  reduction  has  three  parts.  Firstly,  we  deﬁne  a sopml∗

Now  that  the  necessary  concepts  are  deﬁned,  we  can  give  our  reduction  of  the  non-halting  problem  to  the  validity 
problem  of sopml∗
formula  ψgrid that  holds 
in  a  pointed  model  (M, w) if  and  only  if  M represents  a  Z × Z grid.  Then,  we  deﬁne  a  formula  ψsane that  enforces  a 
few sanity constraints that are necessary in order for us to interpret the grid as representing the execution of some Turing 
machine. Finally, we deﬁne a formula ψT that holds if and only if the Turing machine encoded by the grid is the speciﬁc 
machine  T .  Before  deﬁning  these  formulas,  however,  let  us  explain  a  “trick”  that  we  will  use.  Typically,  if  we  wanted  to 
have a Z × Z grid in a modal logic, we would use four accessibility relations  R right, Rleft, Rup and  Rdown. However, we also 
want to show that even single-agent sopml∗

is unaxiomatisable. So we will use only a single relation  R.

We still need to represent the four possible directions, however. We do this by “coloring” the worlds of our model with 

propositional atoms {1, · · · , 9}, in a repeating pattern

7 8 9
4 5 6
1 2 3

So if a world satisﬁes 5, then the world above it satisﬁes 8, and if a world satisﬁes 6 then the world to its right satisﬁes 4. 
For ever direction x ∈ dir := {left, right, up, down}, let  f x : {1, · · · , 9} → {1, · · · , 9} be the function that gives the next number 
in  direction  x,  e.g.  f up(8) = 2.  Further,  since  we  use  only  one  agent  a,  we  write  (cid:2) for  (cid:2)a.  This  operator,  together  with 
functions  f x, can then be used to deﬁne (cid:2)x and ♦x for x ∈ dir as abbreviations:

(cid:2)xφ :=

♦xφ :=

(cid:12)

(i ∧ (cid:2)( f x(i) → φ))

1≤i≤9
(cid:12)

(i ∧ ♦( f x(i) ∧ φ))

1≤i≤9

These abbreviations are then used in formulas ψgrid, ψsane and ψT deﬁned as follows.

Deﬁnition 56. Let  S, (cid:15), {pos, rpos, rpos} ⊆ A P,  and let T = ((cid:15), S, (cid:14)) be a Turing machine. The formula χT is given as χT :=
ψgrid ∧ ψsane ∧ ψT ∧ s0 ∧ pos, where formulas ψgrid, ψsane and ψT are as shown in Tables 5–7.

The formulas ψgrid, ψsane and ψT may look complex, but that it slightly misleading. While these formulas are certainly 

long, every named subformula encodes a property of either a grid or a Turing machine in a rather straightforward way.

We start by considering the formula ψgrid which, as the name implies, encodes a grid. Speciﬁcally, let (M, w 0) be any 
pointed model (based on a modal frame) such that (M, w 0) |= ψgrid. We use the worlds of M to represent the points of 
Z × Z, in the following way: (i) the world w 0 represents (0, 0); (ii) if a world w represents (n, m), then every right-successor 
of  w represents (n + 1, m); and (iii) similarly for the other three directions.

We  show  that  every  point  (n, m) is  represented  by  at  least  one  world,  that  every  world  in  the  generated  submodel 
represents at least one point, and that all the worlds that represent a single point (n, m) are modally indistinguishable. Let 
w be any world in the generated submodel of (M, w 0). The main connective of ψgrid is (cid:2)∗
, so labels, direction, uniquex for 
every x ∈ dir, inversexy for every (x, y) ∈ inv_dir and commutexy for all (x, y) ∈ perp_dir hold at  w.

• By labels, the world  w satisﬁes exactly one label i ∈ {1, · · · , 9}.
• By the ﬁrst conjunct of direction, the world  w has at least one x-successor for every x ∈ dir. It follows that every point 
in Z × Z is represented by at least one world. Furthermore, by the second conjunct of direction, every successor of  w
satisﬁes one of the labels that allow us to identify it as an x-successor for some x ∈ dir. It follows that every world in 
the generated submodel represents at least one point.

• The formula  uniquex implies that,  for every  U in the domain of quantiﬁcation  D,  either every  x-successor of  w is in 
U , or no x-successor is in U . Since M is based on a modal frame, this implies that all x-successors of  w are modally 
indistinguishable from one another.

• The formula inversexy implies that, for every  U ∈ D, if  w ∈ U then every  xy-successor of  w is also in  U . Again, since 
M is based on a modal frame, this implies that  w is modally indistinguishable from its  xy-successors. Note that this 
formula holds for all (x, y) ∈ inv_dir.

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

31

Table 5
The formula ψgrid.

ψgrid := (cid:2)∗

(labels ∧ direction ∧
(cid:7)

inversexy ∧

(cid:7)

uniquex

∧

x∈dir

(cid:7)

commutexy)

labels :=

(x, y)∈inv_dir
(cid:12)

(cid:7)

i ∧

direction :=

1≤ j≤9
(cid:7)

i(cid:7)= j
♦x(cid:10) ∧

¬(i ∧ j)
(cid:12)

(i ∧ (cid:2)

x∈dir

1≤i≤9
:= ∀p(♦x p → (cid:2)x p))
uniquex
inversexy := ∀p(p → (cid:2)x(cid:2) y p)

commutexy := ∀p(♦x♦ y p → (cid:2) y(cid:2)x p)

dir := {left, right, up, down}

(x, y)∈perp_dir

(cid:12)

x∈dir

f x(i))

inv_dir := {(left, right), (right, left), (up, down), (down, up)}
perp_dir := {(left, up), (left, down), (right, up), (right, down),
(up, left), (up, right), (down, left), (down, right)}

Table 6
The formula ψsane.

ψsane := (cid:2)∗

(position1

∧ position2
void_state ∧ initial_symbol ∧ unchangedi )
:= ¬(pos ∧ lpos) ∧ ¬(pos ∧ rpos) ∧ ¬(rpos ∧ lpos)
:= ((pos ∨ rpos) → (cid:2)rightrpos) ∧ ((pos ∨ lpos) → (cid:2)leftlpos))

∧ one_state ∧ same_state ∧ one_symbol∧

(cid:12)

(cid:7)

(s ∧

(cid:6)

¬s

)

position1
position2
one_state :=

same_state :=

s∈states
(cid:7)

s(cid:6)∈states\{s}

(s → ((cid:2)right s ∧ (cid:2)left s))

one_symbol

:=

(cid:12)
s∈states

(α ∧

(cid:7)

¬β)

α∈(cid:15)

β∈(cid:15)\{α}

void_state := (s0 ∨ svoid) → (cid:2)downsvoid

initial_symbol

:= s0 → α0
(cid:7)

unchanged :=

((¬pos ∧ α) → (cid:2)upα))

α∈(cid:15)

• The formula commutexy implies that, for every U ∈ D, if there is an xy-successor  w

(cid:6) ∈ U , then every 
yx-successor of w is in U . This implies that the xy-successors of w are modally indistinguishable from its yx-successors.
• Taken  together,  uniquex (for  every  x ∈ dir),  inversexy (for  every  (x, y) ∈ inv_dir)  and  commutexy (for  every  (x, y) ∈

of  w such that  w

(cid:6)

perp_dir) imply that all worlds representing a single point (n, m) are modally indistinguishable from one another.

We say that tape position n at time m contains the symbol α if the worlds representing (n, m) satisfy the propositional 
atom α. Likewise, if the worlds representing (n, m) satisfy the propositional atom s, then the machine is in state s at time 
m. Finally, if the worlds representing (n, m) satisfy the atom pos, then the read/write head is in position n at time m, if they 
satisfy rpos then position n is to the right of the read/write head at time m and if they satisfy lpos then position n is to the 
left of the head.

Note that, because all worlds representing (n, m) are modally indistinguishable, it does not matter at which world we 
check  whether  these  atoms  are  true;  if  s holds  in  any  world  representing  (n, m) then  s holds  on  all  worlds  representing 
(n, m).  In  particular,  since  we  use  propositional  atoms  to  represent  the  state  of  the  Turing  machine,  the  symbols  on  the 
tape, as well as the position of the read/write head, the modal indistinguishability of all worlds representing (n, m) means 
that all those worlds agree on the symbol, state, and on whether the read/write head is in that position. If a modal formula 
φ holds on the worlds that represent (n, m), we abuse notation by writing (M, (n, m)) |= φ.5

The formula ψsane imposes a number of sanity constraints: if (M, w) satisﬁes both ψgrid and ψsane, then M can almost
be seen as the execution of a Turing machine. We will ﬁrst discuss the subformulas of ψsane in detail, and explain which 
sanity constraints they represent. After that, we will brieﬂy discuss why ψsane only guarantees that M can almost be seen 
as the execution of a Turing machine.

As with ψgrid, the main connective of ψsane is (cid:2)∗

. So suppose (M, w 0) |= ψgrid ∧ ψsane, and let  w be any world in the 

generated submodel of (M, w 0).

• The formula position1 implies that the grid points represented by w being (i) the location of the read/write head, (ii) to 

the right of the head, and (iii) to the left of the head, are mutually exclusive.

5 Note that we have not shown that  w represents a unique point (n, m). It is, in fact, true that if (M, w0) |= χT then every world in the generated 
submodel represents exactly one point, but we do not need this fact so we will not prove it here.

32

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

Table 7
The formula ψT .

:= (cid:2)∗

ψT

(cid:7)

(position_change ∧ state_change ∧ symbol_change)

position_change :=

1≤i≤9
(cid:7)

((pos ∧ s ∧ α) → (cid:2)up(cid:2)leftpos)∧

{(s,α)|(cid:14)3(s,α)=left}
(cid:7)

{(s,α)|(cid:14)3(s,α)=right}
(cid:7)

((pos ∧ s ∧ α) → (cid:2)up(cid:2)rightpos)∧

((pos ∧ s ∧ α) → (cid:2)uppos)

state_change :=

symbol_change :=

{(s,α)|(cid:14)3(s,α)=remain}

(cid:7)

(cid:7)

((pos ∧ s ∧ α) → (cid:2)ups

(cid:6)

)

s(cid:6)∈states
(cid:7)

{(s,α)|(cid:14)2(s,α)=s(cid:6)}

(cid:7)

((pos ∧ s ∧ α) → (cid:2)upβ)

β∈(cid:15)

{(s,α)|(cid:14)1(s,α)=β}

• The formula position2 implies that if the point represented by  w is either at the read/write head or to its right, then 
w’s right-successor is to the right of the read/write head, and similarly for the left side. Together with  position1, this 
implies that for every m ∈ Z, there is at most one n such that (M, (n, m)) |= pos.
• The formula one_state implies that there is exactly one state s such that (M, w) |= s.
• The  formula  same_state implies  that  w satisﬁes  the  same  state  as  its  left- and  right-successors.  So  for  every  time m, 

there is exactly one state s such that (M, (n, m)) |= s for all n.

• The formula one_symbol implies that there is exactly one symbol α such that (M, w) |= α.
• Recall  that  we  use  svoid as  a  dummy  state  which  indicates  that  the  execution  of  T has  not  started  yet.  The  formula 
void_state implies that svoid holds on all worlds below worlds that satisfy either s0 or svoid, so svoid does indeed hold in 
all worlds that represent points before the execution of T started in s0.

• The formula initial_symbol guarantees that, in the initial state, the entire tape contains the symbol α0.
• The formula symbol_unchanged guarantees that whenever the read/write head is not at a particular position of the tape, 

then the symbol at that position remains unchanged.

The above is almost suﬃcient to show that M represents the execution of some Turing machine, except for the follow-
ing:  (i)  there  is  no  guarantee  that  s0 is  satisﬁed  anywhere,  so  the  execution  might  never  start;  (ii)  while  the  read/write 
head is guaranteed to be in at most one position, it is not guaranteed to be in at least position at all times; and (iii) the 
symbols  that  are  written,  the  state  changes,  and  the  movement  of  the  read/write  head  could  be  random,  as  opposed  to 
fully determined by a set of rules. Whereas ψsane almost guarantees that M can be seen as the execution of some Turing 
machine, the formula ψT narrows this down to the speciﬁc machine  T . In the process, it also solves one of the problems 
that remained after considering ψsane.

Suppose  that  (M, w 0) |= χT ,  so  in  addition  to  (M, w 0) |= ψgrid ∧ ψsane we  also  have  (M, w 0) |= ψT ∧ s0 ∧ pos.  Then, 
the subformula  position_change in ψT guarantees that the read/write head moves in accordance with (cid:14)3, the subformula 
state_change guarantees that the state changes in accordance with (cid:14)2, and the subformula symbol_change guarantees that 
the symbol that is written on the tape by the read/write head is in accordance with (cid:14)1. Note that this solves problem (iii) 
of  ψsane:  the  movement,  state  changes,  and  written  symbols  are  in  accordance  with  the  deterministic  set  of  rules  that  is 
represented by (cid:14).

Finally,  consider  the  conjuncts  s0 and  pos in χT .  These  solve  the  other  two  problems  of  ψsane:  the  execution  starts  at 
state s0 in the point represented by w 0, which represent point (0, 0). Furthermore, the read/write head starts there as well, 
so the read/write head is initially in at least one position. From the fact that the head moves deterministically, and that this 
is encoded in ψT , it then follows that the read/write head is also in at least one position at every time after m = 0.

To  conclude,  the  above  shows  that  if  (M, w 0) |= χT ,  then  the  generated  submodel  of  (M, w 0) represents  a  grid,  and 

this grid contains the encoding of an execution of T .

Theorem 57. A Turing machine T is halting if and only if Kmodal |= χT → ♦∗
(cid:2)∗¬send.

send, and non-halting if and only Kmodal |= χT →

Proof. Let (M, w 0) be any pointed model such that (M, w 0) |= χT . Then, as shown above, every world in the generated 
submodel represents some point (n, m) in a Z × Z grid and, furthermore, the worlds representing a point (n, m) satisfy s ∈ S
if and only if the system is in state s at time m. It follows that the generated submodel contains a send world if and only if 
T is halting, from which the theorem follows immediately. (cid:2)

As an immediate consequence of Theorem 57, we obtain the following result.

Corollary 58. sopml∗

is not axiomatisable on modal frames for any number of agents.

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

33

This  unaxiomatisability  result  can  be  extended  to  the  classes  of  boolean and  all frames,  since  the  modal  frames  can 
be  characterised inside  boolean or  any frame.  Let  φ¬ := ∀p∃q(cid:2)∗(¬p ↔ q),  φ∨ := ∀p∀q∃r(cid:2)∗((p ∨ q) ↔ r) and  φ(cid:2) :=
(cid:2)

∀p∃q(cid:2)∗((cid:2)a p ↔ q). The following lemma is entirely straightforward, so we state it without proof.

a∈Ag

Lemma 59. Let (M, w) be a pointed model based on any frame. Then, the generated submodel of (M, w) is based on a modal frame 
if and only if (M, w) |= φ¬ ∧ φ∨ ∧ φ(cid:2).

Hence, the following corollary follows immediately from Lemma 59.

Corollary 60. A formula φ ∈ Lsopml is valid on modal frames if and only if (φ¬ ∧ φ∨ ∧ φ(cid:2)) → φ is valid on all or boolean frames.

As a result of the unaxiomatisability of sopml∗

on modal frames, we ﬁnally obtain unaxiomatisability for all classes of 

frames.

Corollary 61. sopml∗
agents.

is not axiomatisable neither on the class of all frames nor on the class of boolean frames, for any number of 

So far, we have shown that sopml∗

is unaxiomatisable for modal, boolean, and all frames. This result can be extended to 
the corresponding classes of epistemic frames as well. The proofs for epistemic frames is very similar to the proofs above 
however, so we include them in the appendix only.

Theorem 62. If |I| ≥ 2, then the validities in sopml∗

over modal epistemic frames are not recursively enumerable.

In particular, sopml∗

is not axiomatisable on the class of modal epistemic frames.

The  same  characterisation  of  boolean  and  all  frames  also  applies  to  epistemic  frames.  So  we  also  have  the  following 

corollary.

Corollary 63. sopml∗

is not axiomatisable on the class of all or boolean epistemic frames, for any number of agents.

5.  Simulations and bisimulation

In  this  section  we  investigate  the  expressive  power  of  second-order  propositional  modal  logic  by  introducing  truth-
preserving  (bi)simulation  relations  for sopml.  Bisimulations  are  an  essential  tool  for  the  model  theory  of  propositional 
modal  logic,  as  they  provide  non-trivial  suﬃcient  conditions  under  which  two  models  satisfy  the  same  formulas  in pml
[7,27]. Moreover, propositional modal logic is characterised by the well-known van Benthem theorem as the bisimulation-
invariant fragment of ﬁrst-order logic [6]. Hereafter we introduce simulations and bisimulations for sopml and prove that 
they  are  indeed  truth-preserving.  Further,  in  Section 5.2 we  present  a  notion  of  abstraction  for  frames  and  show  that  an 
abstraction of a frame simulates that frame. Finally, in Section 5.3 we provide examples of the application of (bi)simulations 
to the analysis of the expressive power of sopml in spatial and temporal reasoning.

We should note that SOPML (bi)simulations are somewhat less well behaved than PML bisimulations. In particular, given 
two  PML  models  there  is  a  unique  greatest  bisimulation  between  the  two.  Furthermore,  this  greatest  bisimulation  is  the 
bisimilarity relation, and can also be characterised as the greatest ﬁxed point of a partition reﬁnement operator. In contrast, 
between two SOPML models there need not be a unique greatest bisimulation, see Example 72. While we could deﬁne a 
partition reﬁnement operator like in the PML case, and any bisimulation would be a ﬁxed point of this operator, it would 
not have a unique greatest ﬁxed point. The SOPML bisimilarity relation, meanwhile, is not guaranteed to be a bisimulation 
itself.

5.1.  Simulations and bisimulations

We deﬁne the notion of (bi)simulations on frames, although it is immediate to extend this deﬁnition to models. In the 
(cid:6)(cid:18) deﬁned 

(cid:6)(cid:18), and models M = (cid:17)F , V (cid:18), M(cid:6) = (cid:17)F (cid:6), V

rest of the section we consider frames F = (cid:17)W , D, R(cid:18), F (cid:6) = (cid:17)W
on F and F (cid:6)

respectively. In the following, (cid:19) denotes a relation (cid:19) ⊆ D × D.

(cid:6), D

(cid:6), R

Deﬁnition 64 (Frame simulation). Given frames F and F (cid:6)
(cid:6)) for some U
D × D

such that (i) for every U ∈ D, (cid:19)(U , U

(cid:6)

, a simulation is a pair (σ , (cid:19)) of relations ∅ (cid:7)= σ ⊆ W × W
(cid:6)) implies
(cid:6) ∈ D

; and (ii) σ (w, w

(cid:6)

(cid:6)

, (cid:19) ⊆

1. for every v ∈ W , a ∈ I , if  Ra(w, v) then σ (v, v
(cid:6) ∈ D
2. for every U ∈ D, U

(cid:6)) implies  w ∈ U iff  w

(cid:6)) for some v
(cid:6) ∈ U

, (cid:19)(U , U

(cid:6)

(cid:6)
a(w

(cid:6));

(cid:6) ∈ R
(cid:6)
.

34

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

w 1

b

a

· · ·

b

u121

w 2

w 3

c
(a) frame G

a

c

· · ·

.
.
.

u1

b

a

b

u12

c

u123

a

.
.
.

(b) frame G(cid:6)

u13

c

u132

b

.
.
.

a

u131

a

· · ·

c

b

· · ·

.
.
.

Fig. 3. frames G and G(cid:6)

in Example 65. D components are omitted for clarity.

Notice  that  condition 1 in  Deﬁnition 64 expresses  the  standard  notion  of  simulation  in pml.  Hence,  simulations  for
sopml extend  the  corresponding  deﬁnition  for pml (we  devote  more  discussion  to  this  point  later  on).  The  deﬁnition  of 
simulation above differs from a similar notion put forward in [4]. Speciﬁcally, in [4] only a relation on states is considered, 
thus obtaining a strictly weaker notion.

We  say  that  state  w

(cid:6)

simulates w,  or  w   w

,  iff  σ (w, w

(cid:6)

(cid:6)) holds  for  some  simulation  pair  (σ , (cid:19)).  Similarly,  a  set  U

(cid:6)

, iff (cid:19)(U , U
(cid:6)

(cid:6)
simulates U , or U   U
holds because 
of (σ1, (cid:19)1) and U ≺ U
holds because of (σ2, (cid:19)2), while (σ1, (cid:19)2) is not a simulation pair. To see this, consider the frames 
G1 = (cid:17){w 1, w 2}, {{w 1}, {w 2}}, {(w 1, w 2), (w 2, w 1)}(cid:18) and G2 = (cid:17){x1, x2}, {{x1}, {x2}}, {(x1, x2), (x2, x1)}(cid:18). Clearly,  w 1   x1 and 
{w 1}   {x2}. However, it is not the case that  w 1 ∈ {w 1} iff x1 ∈ {x2}. Nonetheless, each   is a preorder, i.e., a reﬂexive and 
transitive relation. Finally, a frame F (cid:6)

(cid:6)) holds for some simulation pair (σ , (cid:19)). Note that it may be that  w ≺ w

, iff for every  w ∈ W ,  w   w

simulates F , or F   F (cid:6)

for some  w

(cid:6) ∈ W

.

(cid:6)

(cid:6)

(cid:6)

Observe that for pml (that is, whenever we ignore the quantiﬁcation domain D), the notion of simulation given on frames 
is  vacuous,  as  we  discard  the  evaluation  of  propositional  atoms  in  the  various  states.  Then,  for  instance,  all  serial  frames 
simulate  each  other.  However,  this  remark  does  not  apply  to sopml,  as  we  also  have  to  take  into  account  propositional 
quantiﬁcation.

We illustrate the newly introduced notion by an example.

Example 65. Consider frames G = (cid:17)W , R, D(cid:18) and G(cid:6) = (cid:17)W

(cid:6), R

(cid:6), D

(cid:6)(cid:18) over set  I = {a, b, c} of indices, depicted in Fig. 3, with

• W = {w 1, w 2, w 3};
• Ra = {(w 1, w 3), (w 3, w 1)},  Rb = {(w 1, w 2), (w 2, w 1)},  Rc = {(w 2, w 3), (w 3, w 2)};
• D = {{w 1}, {w 2}, {w 3}};
• W
• for every i ∈ I ,  R
• let U

(cid:6) = {us | s is a ﬁnite sequence on {1, 2, 3} starting with 1, with no adjacent repetition};
(cid:6) = s · m and R i(wlast(s), wm)};
(cid:6)
(cid:6) = {U
3

= {(us, us(cid:6) ) | s
= {us | last(s) = n}, then  D

(cid:6)
2, U

(cid:6)
1, U

}.

(cid:6)
n

(cid:6)
i

Intuitively, frame G can be thought of as a scenario where robots a, b, and c move around locations  w 1,  w 2,  w 3 (robot 
a moves between  w 1 and  w 3, etc.) Frame G(cid:6)
then captures the same scenario but with the additional possibility to reason 
about some notion of history, or time (one might for instance add an atom  pi which is true exactly at nodes at level i. To 
(cid:6)
do this, one needs to make appropriate assumptions about D
, like requiring that the frame is full. We do not consider 
these matters further.)

in G(cid:6)

Now  consider  the  pair  (σ , (cid:19)) of  relations σ ⊆ W × W

(cid:6)
(cid:19)({wn}, U
m) holds iff n = m. We check that (σ , (cid:19)) is indeed a simulation. Firstly, for every {wn} ∈ D, we have (cid:19)({wn}, U
(cid:6)
for  Un ∈ D
σ (wn, us) and (cid:19)({wk}, U

(cid:6)
m), then last(s) = n and k = m. Therefore,  wn ∈ {wk} iff n = k, iff last(s) = m, iff us ∈ U

.  Secondly,  if  σ (wn, us) and  R i(wn, wm),  then  s

such  that σ (wn, us) holds  iff last(s) = n and 
(cid:6)
n)
(cid:6)
i(us, us(cid:6) ) and  σ (wm, us(cid:6) ).  Thirdly,  if 

(cid:6) = s · m is  such  that  R

and  (cid:19) ⊆ D × D

(cid:6)
m.

(cid:6)

(cid:6)

Finally, we observe that for every  wn ∈ W , σ (wn, us) for last(s) = n. Thus, frame G(cid:6)

simulates G.

Lemma 66. We have the following regarding the relation between simulations and properties of frames.

1. It can be checked in NPTIME whether there exists a simulation relation between two frames.
2. If a frame F (cid:6)
simulates a boolean (respectively modal, full) frame F , then F (cid:6)
does F (cid:6)
being boolean (modal, full) imply that F is also boolean (modal, full).

need not to be boolean (respectively modal, full). Nor 

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

35

Proof. As regards the ﬁrst point, observe that we can guess a pair (σ , (cid:19)) of relations on states and sets respectively, and 
then check in polynomial time whether it is actually a frame simulation.
As  to  the  second  point,  consider  that  a  simulating  frame  F (cid:6)

may  contain  sets  of  states  that  do  not  simu-
late  any  state  in  F ,  which  are  not  closed  under  set-theoretic  operations.  As  an  example,  consider  frames  F =
{w1,w2}} and  F (cid:6) = {{u1, u2, u3, u4}, {(u1, u2),  (u1, u3), (u1, u4)}, {{u1}, {u2, u3}, {u1, u2, u3}, {u4}, ∅}}. 
{{w 1, w 2}, {(w 1, w 2)}, 2
In particular, F (cid:6)
is a simulation of F with relations σ and (cid:19) such that σ (w 1, u1), σ (w 2, u2), σ (w 2, u3), and (cid:19)({w 1}, {u1}), 
(cid:19)({w 2}, {u2, u3}), (cid:19)({w 1, w 2}, {u1, u2, u3}), (cid:19)(∅, ∅). But F is a full frame, while F (cid:6)

is not even boolean.

The other implication can be proved by a similar line of reasoning. Speciﬁcally, consider frame F (cid:6)(cid:6) = {{v 1, v 2}, {(v 1, v 2)},
is  simulated  by  F with  relations  σ and  (cid:19) such  that  σ (v 1, w 1),  σ (v 2, w 2),  and  (cid:19)({v 1}, {w 1}), 

Thus, similar frames do not necessarily belong to the same class. Below we compare these results with those available 

{{w 1}, {w 2}}}.  Now  F (cid:6)(cid:6)
(cid:19)({v 2}, {w 2}). But F (cid:6)(cid:6)

for bisimulations. (cid:2)

is not even boolean.

We now state the following preservation result for the universal fragment of sopml.

Theorem 67. If w   w

(cid:6)

, then for every ϕ ∈ L∗

a−sopml,

(F (cid:6)

, w

(cid:6)

) |= ϕ implies (F, w) |= ϕ

(cid:6)

,  there  is  a  simulation  pair  (σ , (cid:19)) such  that σ (w, w

Proof. Since  w   w
that  if  (F , V , w) (cid:7)|= ϕ for  some  assignment  V ,  then  (F (cid:6), (cid:19)(V ), w
every  p ∈ A P , (cid:19)(V (p), V
Deﬁnition 64, (cid:19)(V )(p) ∈ D

(cid:6)).  Fix  this σ .  One  can  prove  by  induction  on ϕ
such  that  for 
(cid:6)(p)). We only show the step for the quantiﬁer. We write (cid:19)(V )(p) for ((cid:19)(V ))(p). By clause (i) of 

(cid:6)) (cid:7)|= ϕ,  where  (cid:19)(V ) is  any  assignment  V

.

(cid:6)

(cid:6)

For  ϕ = ∀pψ ,  (F , V , w) (cid:7)|= ϕ iff  for  some  U ∈ D,  (F , V

condition (i) in Deﬁnition 64, for U ∈ D, (cid:19)(U , U
(cid:19)(U , U

(cid:6)), and therefore (F (cid:6), (cid:19)(V )p

(cid:6)) (cid:7)|= ψ for U

U (cid:6) , w

p
(cid:6)) for some U
(cid:6) ∈ D

U , w) (cid:7)|= ψ .  By  induction  hypothesis,  (F (cid:6), (cid:19)(V
(cid:6) ∈ D
. In particular, we have that (cid:19)(V
(cid:6)) (cid:7)|= ϕ. (cid:2)

(cid:6)
, that is, (F (cid:6), (cid:19)(V ), w

p
U ), w
U ) = (cid:19)(V )p

p

(cid:6)

(cid:6)) (cid:7)|= ψ .  By 
U (cid:6) whenever 

As an immediate consequence of Theorem 67 we obtain the following corollary.

Corollary 68. If F   F (cid:6)

, then for every ϕ ∈ L∗

a−sopml,

F (cid:6) |= ϕ implies F |= ϕ

Thus,  the  notion  of  simulation  introduced  in  Deﬁnition 64 preserves  the  universal  fragment  of sopml,  similarly  to  the 

case for standard simulations and pml.

Example 69. Consider again frames G and G(cid:6)
that G(cid:6)

validates the following formula in sopml

in Example 65. We showed that G(cid:6)

simulates G. Moreover, we can easily check 

(cid:13)

∀p

p →

(cid:14)

(cid:7)

i∈I

(cid:2)i¬p

(14)

which intuitively says that the agents can only move to a different position (so they cannot choose to remain in the same 
state). By Corollary 68 we deduce that (14) is valid in G as well.

Simulations  can  naturally  be  extended  to  bisimulations.  Also  in  this  case,  our  focus  is  at  the  level  of  frames.  In  the 
−1 = {(u, v) | R(v, u)}.

following the converse of a relation  R is the relation  R

Deﬁnition 70 (Frame bisimulation). Given  frames  F and  F (cid:6)
(cid:22) ⊆ D × D
and for every U

such that both (ω, (cid:22)) and (ω−1, (cid:22)−1) are simulations. That is, (i) for every U ∈ D, (cid:22)(U , U
; and (ii) ω(w, w

,  a  bisimulation is  a  pair  (ω, (cid:22)) of  relations  ∅ (cid:7)= ω ⊆ W × W
(cid:6) ∈ D

(cid:6)) for some U ∈ D

(cid:6)) for some U

(cid:6)) implies

, (cid:22)(U , U

(cid:6) ∈ D

(cid:6)

(cid:6)

(cid:6)

(cid:6)

(cid:6)

, 
, 

1. for every v ∈ W , a ∈ I , if  Ra(w, v) then ω(v, v
(cid:6)
, a ∈ I , if  R
2. for every v
(cid:6)
(cid:6) ∈ D
3. for every U ∈ D, U

(cid:6), v
(cid:6)) implies  w ∈ U iff  w

(cid:6)
a(w
, (cid:22)(U , U

(cid:6)) then ω(v, v

(cid:6));
(cid:6) ∈ R
(cid:6)) for some v ∈ Ra(w);
(cid:6)
.

(cid:6)) for some v

(cid:6) ∈ W

(cid:6) ∈ U

(cid:6)
a(w

(cid:6)

and U
States  w and  w
(cid:6)) holds for some bisimulation pair (ω, (cid:22)). Again, similarly to the case for simulations, 
are bisimilar, or  U ≈ U
the pair (≈, ≈) is not necessarily a bisimulation (see Example 72), but each ≈ is an equivalence relation. This is in contrast 

(cid:6)) holds for some bisimulation pair (ω, (cid:22)). Similarly, sets U

are bisimilar, or  w ≈ w

, iff ω(w, w

, iff (cid:22)(U , U

(cid:6)

(cid:6)

(cid:6)

36

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

w 3

x2

w 1

w 2

x1

(a) frame H

(b) frame H(cid:6)

Fig. 4. Frames H and H(cid:6)

in Example 72. D components are omitted for clarity.

to  the  situation  in pml,  where  the  bisimilarity  relation  is  itself  a  bisimulation.  Finally,  frames  F and  F (cid:6)
F ≈ F (cid:6)

, iff (i) for every  w ∈ W ,  w ≈ w

; and (ii) for every  w

for some  w

,  w ≈ w

(cid:6) ∈ W

(cid:6) ∈ W

for some  w ∈ W .

(cid:6)

(cid:6)

(cid:6)

(cid:6)

are  bisimilar,  or 

Example 71. Notice that frames G and G(cid:6)
relations σ −1 ⊆ W
that  (cid:19)(U , U
Hence, σ −1(us(cid:6) , wm). As to (3), the proof is identical as for simulations.

(cid:6) × W and (cid:19)−1 ⊆ D
(cid:6)).  Secondly,  if σ −1(us, wn) and  R

in Example 65 are actually bisimilar. To prove this fact, we show that the converse 
, the set U = {wn} ∈ D is such 
(cid:6) = s · m for  wm ∈ W such  that  R i(wn, wm). 

(cid:6) × D form a simulation pair. Firstly, for every U
(cid:6)
i(us, us(cid:6) ) then last(s) = n and  s

∈ D

(cid:6)
n

(cid:6)

Example 72. Let frames H and H(cid:6)
main of H(cid:6)
is given by D
ω2 = {(w 2, x1), (w 3, x2)} and (cid:22)2 = {({w 1, w 3}, {x2}), ({w 2, w 3}, {x1, x2})}.

be as in Fig. 4, where the domain of H is given by D = {{w 1, w 3}, {w 2, w 3}} and the do-
(cid:6) = {{x1, x2}, {x2}}. Now, take ω1 = {(w 1, x1), (w 3, x3)}, (cid:22)1 = {({w 1, w 3}, {x1, x2}), ({w 2, w 3}, {x2})}, 

The  pairs  (ω1, (cid:22)1) and  (ω2, (cid:22)2) are  both  bisimulations.  Furthermore,  it  is  easy  to  verify  that  for  every  i ∈ {1, 2} and 
every bisimulation (ω, (cid:22)), if ωi ⊆ ω and (cid:22)i ⊆ (cid:22), then (ω, (cid:22)) = (ωi, (cid:22)i). In other words, (ω1, (cid:22)1) and (ω2, (cid:22)2) are maximal 
bisimulations.

So, there is no unique greatest bisimulation. Furthermore, note that  w 1 ≈ x1 and  w 2 ≈ x1, yet there is no bisimulation 

that relates both  w 1 and  w 2 with x1. In particular, (≈, ≈) is not a bisimulation.

We now state the following adaptation of Lemma 66.

Lemma 73.

1. It can be checked in NPTIME whether there exists a bisimulation relation between two frames.
2. Let F and F (cid:6)
, respectively, such that w ≈ w
modal) iff F (cid:6)
Moreover, if Fw and F (cid:6)

be frames and let w and w
w(cid:6) is. However, if Fw is full, then F (cid:6)

w(cid:6) are full, then they are isomorphic.

be worlds of F and F (cid:6)

w(cid:6) need not be full.

(cid:6)

(cid:6)

. Then Fw is boolean (respectively 

With regard to point 1, note that, as with simulations, we can simply guess a pair (ω, (cid:22)) and check in polynomial time 

whether it is a bisimulation. A proof of point 2 is included in the appendix

Compare  the  situation  for  bisimulations  with  the  weaker  results  available  in  Lemma 66 for  simulations.  Speciﬁcally, 
bisimulations preserve the class of boolean and modal frames. Moreover, in the case of full frames, bisimulations collapse 
into isomorphisms.

We  now  state  the  main  preservation  result  of  this  section.  Its  proof  is  similar  to  that  of  Theorem 67,  and  it  is  in  the 

appendix.

Theorem 74. If w ≈ w

(cid:6)

, then for every formula ϕ ∈ L∗

sopml,

(F, w) |= ϕ iff (F (cid:6)

, w

(cid:6)

) |= ϕ.

As an immediate consequence of Theorem 74 we obtain the following.

Corollary 75. If F ≈ F (cid:6)

, then for every ϕ ∈ L∗

sopml,

F |= ϕ iff F (cid:6) |= ϕ

We can now infer that bisimulations in sopml are ‘stronger’ than the corresponding notion for pml: whereas we noticed 
that the frames of Fig. 2 are bisimilar in pml, as a consequence of Theorem 74, and Example 10, which says that the frames 
do not agree on formula (8), we conclude that they are not bisimilar in the sopml sense.

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

37

Example 76. We now consider two graph-theoretic properties. First, the notion of 3-colorability, as formalised by the follow-
ing sopml formula, where operator (cid:2) is interpreted as the necessity operator for the edges  E ⊆ W 2 of a graph G = (cid:17)W , E(cid:18), 
while (cid:2)∗

is, as usual, the necessity operator for the reﬂexive and transitive closure of  E:

⎛

⎞

∃p1, p2, p3

⎝(cid:2)∗

(p1 ∨ p2 ∨ p3) ∧ (cid:2)∗

(cid:7)

¬(pi ∧ p j) ∧

(cid:7)

(cid:2)∗

(pi → ¬(cid:3)pi)

⎠

(15)

i(cid:7)= j

1,2,3
The truth of (15) in a vertex  v ∈ G implies that (i) all vertices in the subgraph generated by  v are coloured by either 
p1,  p2, or  p3; (ii) each vertex has at most one colour; and (iii) no two adjacent vertices have the same colour. Thus, the 
subgraph generated by  v is 3-colorable. Observe that frame  G in Fig. 3(a) is indeed 3-colorable, and since states  w 1 and 
u1 are  bisimilar,  as  an  immediate  consequence  of  Theorem 74,  also  frame  G(cid:6)
is  3-colorable.  Notice  that  the  truth  of  (15)
implies that the graph is 3-colorable, while the converse holds only for full frames.

To illustrate further the (in)expressivity of sopml through simulations, we consider one more graph-theoretic property: 
the existence of a Hamiltonian path, i.e., a path that visits all vertices in a graph exactly once. Again, frame G in Fig. 3(a) 
has a Hamiltonian path w 1, w 2, w 3. Now consider the ﬁnite graph G(cid:6)(cid:6)
in Fig. 3 as follows. 
In G(cid:6)
replace the worlds u12 and u13 by a copy of w 2 and w 3 from G respectively, and remove all the worlds different from 
u1. It is not diﬃcult to see that G(cid:6)(cid:6)
is bisimilar with G, but does not allow a Hamiltonian path.

which is obtained from G and G(cid:6)

Proposition 77. The property of having a Hamiltonian path is not expressible in sopml.

Proposition 77 follows directly from the second part of Example 76 and it implies that such paths are not expressible 
under the general semantics. Proposition 77 also follows from [42, Corollary 7.24], which says that it is impossible to test 
in mso whether  a  graph  is  Hamiltonian.  Indeed,  it  is  known  that  such  property  is  expressible  in  the  language mso2,  an 
extension of mso, which is strictly more expressive than sopml [15, Prop. 5.13].

Discussion. We now compare our deﬁnition of (bi)simulation for sopml, with the standard notion of (bi)simulation for
pml [7]. Observe that if a frame F (cid:6)
simulates F in sopml, with simulation pair (σ , (cid:19)), then for every model M = (cid:17)F , V (cid:18)
(cid:6)) then  for  every  v ∈ W ,  a ∈ I , 
based  on  F ,  model  M(cid:6) = (cid:17)F (cid:6), (cid:19)(V )(cid:18) on  F (cid:6) pml-simulates  M.  In  particular,  if  σ (w, w
(cid:6) ∈
(cid:6) ∈ R
Ra(w, v) implies that σ (v, v
(cid:19)(V )(p) ∈ D
satisﬁes  any  universal  formula  φ in pml,  then  φ also  holds  in 
M.  Hence,  Deﬁnition 64 of  simulation  for  frames  in sopml is  indeed  a  generalisation  of  the  model-theoretic  notion  in
pml. Furthermore, if frames F (cid:6)
and F are bisimilar in sopml, with bisimulation pair (ω, (cid:22)), then models M = (cid:17)F , V (cid:18) and 
(cid:6)(cid:18) and  M = (cid:17)F , (cid:22)−1(V )(cid:18) are pml-bisimilar  as 
M(cid:6) = (cid:17)F (cid:6), (cid:22)(V )(cid:18) are  also  bisimilar  in pml.  Likewise,  models  M(cid:6) = (cid:17)F (cid:6), V
well. So in this case too, sopml bisimulations on frames generalise pml bisimulations on models.

(cid:6)) for some  v
by  conditions  (i) and  (ii).2.  Therefore,  if M(cid:6)

(cid:6)) by condition (ii).1 in Deﬁnition 64. Moreover,  w ∈ V (p) ∈ D iff  w

(cid:6)
a(w

(cid:6)

5.2.  Abstraction

This section is devoted to the deﬁnition of a notion of abstraction for Kripke frames. Abstractions are deemed useful for 
system veriﬁcation, as they allow to ignore some selected features of the system, thus focusing only on the properties rele-
vant for the veriﬁcation task [14]. Indeed, a key fact about abstractions is that they simulate the original system. Hereafter 
we prove such a result for sopml, starting with a family of equivalence relations on states.

Deﬁnition 78 (Equivalence). Given a frame F , let ∼ be the equivalence relation on  W such that for every state  w, w
w ∼ w
implies that for every U ∈ D,  w ∈ U iff  w
of  w in F , and for a set U ⊆ W , let [U ] be {[w] | w ∈ U }.

(cid:6) ∈ U . Further, denote by [w] = {w

(cid:6) ∈ W , 
(cid:6) ∼ w} the equivalence class 

(cid:6) ∈ W | w

(cid:6)

Clearly, if we replace ‘implies’ in Deﬁnition 78 by ‘iff’, we obtain the coarsest equivalence relation satisfying the condi-

tions in Deﬁnition 78.

Deﬁnition 79 (Abstraction). Given a frame F , the abstraction F A = (cid:17)W A, D A, R A(cid:18) of F (according to equivalence relation ∼
as in Deﬁnition 78) is the frame such that

• W A = {[w] | w ∈ W };
• D A = {[U ] | U ∈ D};
• for every a ∈ I ,  R A

a ([w], [w

(cid:6)]) iff  Ra(v, v

(cid:6)) for some v ∈ [w], v

(cid:6) ∈ [w

(cid:6)].

Notice  that  the  coarsest  abstraction  F A is  ﬁnite  whenever  the  interpretation  domain  D in  F is,  and  of  size  |W A| =

O(2D ) at most.

Example 80. To  illustrate  abstractions,  we  show  that  the  frame  G in  Example 65 is  (isomorphic  to)  the  coarsest  abstrac-
tion  G(cid:6) A of  G(cid:6)
.  First  of  all,  two  worlds  us and  us(cid:6) are  equivalent  according  to  the  coarsest  equivalence  ∼ iff  for  all 

38

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

(cid:6)

(cid:6)
n

∈ D

,  us ∈ U

(cid:6)
n iff  us(cid:6) ∈ U

(cid:6)
n,  iff  last(s) = last(s

U
and [ut·3], for sequences t ∈ {1, 2, 3}+
(cid:6)
in  W
i(ut·n, ut(cid:6)·m),  that  is,  t
(cid:6) A
∈ D
a ([ut·3], [ut(cid:6)·1]), as required. Finally,  D
R
is isomorphic to G, with mapping  w i (cid:31)→ [ut·i] for i = 1, 2, 3.

beginning with 1. As to the accessibility relations,  R

(cid:6) = t · n and  R i(wn, wm).  Hence,  for  instance,  for  agent  a,  we  have  R

(cid:6)).  So,  in  abstraction  G(cid:6) A we  have  three  equivalence  classes  [ut·1],  [ut·2], 
(cid:6) A
i ([ut·n], [ut(cid:6)·m]) iff for ut·n, ut(cid:6)·m
(cid:6) A
a ([ut·1], [ut(cid:6)·3]) and 
(cid:6)} = {{[ut·1]}, {[ut·2]}, {[ut·3]}}. Clearly, the abstraction G(cid:6) A of G(cid:6)

(cid:6) A = {[U

] | U

,  R

(cid:6)
n

(cid:6)
n

(cid:6)

We now extend a standard result in modal logic, namely that abstractions are indeed simulations, to sopml.

Lemma 81. Given a frame F with abstraction F A , the pair of mappings w (cid:31)→ [w] and U (cid:31)→ [U ] is a simulation.

Proof. We show that the pair ((cid:31)→, (cid:31)→) of mappings satisﬁes Deﬁnition 64. As to condition (i), if  U ∈ D then  U (cid:31)→ [U ] for 
[U ] ∈ D A . Next, for (i).1 suppose that  Ra(w, v). Then, for [v] ∈ W A we have that  R A
a ([w], [v]) and  v (cid:31)→ [v]. Finally, as to 
(ii).2, if w (cid:31)→ [w] and w ∈ U , then clearly [w] ∈ [U ]. On the other hand, if [w] ∈ [U ] then for some v ∈ [w], v ∈ U . However, 
v ∈ [w] implies that v ∼ w. In particular,  w ∈ U by the constraint on ∼. (cid:2)

We remark that the abstraction F A of a full frame F is isomorphic to F . In fact, for every  w ∈ W , the set {w} belongs 
(cid:6)
(cid:6) ∈ U ,  w ∼ w
to  D,  and  since  w ∼ w
. 
As a consequence,  w (cid:31)→ {w} is the only simulation on states between F and F A , and it is also an isomorphism. Further, 
in Example 80 we observed that frame G is (isomorphic to) the coarsest abstraction of G(cid:6)
. Hence, Lemma 81 provides an 
alternative proof of the fact that G simulates G(cid:6)

implies  in  particular  that  w ∈ {w

, that we discussed in Example 71.

iff  for  all  U ∈ D,  w ∈ U iff  w

(cid:6)},  that  is,  w = w

(cid:6)

(cid:6)

The following corollary follows immediately from Lemmas 67 and 81.

Corollary 82. Let F be a frame with abstraction F A . For every universal formula ϕ ∈ L∗

a−sopml,

(F A, [w]) |= ϕ implies (F, w) |= ϕ

The results presented above have an impact that goes beyond their theoretical interest. As an example, we observed that 
relevant properties  P of frames (such as reﬂexivity, transitivity, symmetry, etc.) are deﬁnable in propositional modal logic in 
the sense that for some formula φ in pml, a frame F validates φ iff F satisﬁes property P . In sopml more properties become 
frame-deﬁnable within the class of full frames. For instance, in Section 3 we showed that a full frame F is irreﬂexive iff 
F |= ∃p((cid:2)p ∧ ¬p). On the other hand, whenever we consider the class of all frames, several properties are non-deﬁnable 
(even where they might be deﬁnable in pml). For instance, the frame G in Example 65 is symmetric, while G(cid:6)
is not. Since, 
G and G(cid:6)
are bisimilar, and therefore satisfy the same formulas in sopml, we conclude that symmetry is not deﬁnable in 
the  class  of  all  frames.  Likewise,  irreﬂexivity  nor  reﬂexivity  are  deﬁnable  on  the  class  of  all  frames:  take  F consisting  of 
(cid:6)
(cid:6)
only  one  reﬂexive  world  w with  D = {{w}, ∅},  and  F (cid:6)
1)}
2 with  R
(cid:6)
(cid:6)
1) are bisimilar, but F is reﬂexive (hence reﬂexivity cannot 
and  D
2
be expressed on all frames) while F (cid:6)
is irreﬂexive (hence irreﬂexivity cannot be expressed). Such results provide us with 
further knowledge on the expressive power of sopml.

}, ∅}. The pointed frames (F , w) and (F (cid:6), w

consisting  of  two  worlds  w

(cid:6) = {(w

(cid:6) = {{w

(cid:6)
2), (w

(cid:6)
2, w

(cid:6)
1, w

(cid:6)
1, w

(cid:6)
1, w

5.3.  Bisimulations and expressivity

In this section we explore the expressivity of sopml, also by using the (bi)simulations introduced in Section 5.1. We focus 
on some temporal and spatial properties typically used in artiﬁcial intelligence. In what follows we say that a property  P is 
expressible in a language L and class K of frames iff for some formula φ ∈ L, we have that for all F ∈ K, F |= φ iff F has 
property  P . Sometimes we omit either L or K, whenever these are clear from the context.

First of all, consider Dedekind-completeness of a total order ≤, i.e., a total, transitive, and antisymmetric binary relation: 
a totally ordered set is Dedekind-complete if every non-empty subset that has an upper bound, has a least upper bound. We 
recall that the Dedekind-completeness of the real numbers is not expressible in pml: the proof makes use of a propositional 
bisimulation between the structure (R, ≤) of reals and the rationals (Q, ≤) [1]. Thus, by using simulations we immediately 
obtain the following inexpressibility result.

Lemma 83. Dedekind-completeness is not expressible in the universal fragment La−sopml in the class of full frames.

Proof. Clearly, the identity relation is a simulation between structures (Q, ≤) and (R, ≤) seen as full frames, i.e., (Q, ≤)  
(R, ≤), and if Dedekind-completeness were expressible as a formula φ in a-sopml, (R, ≤) |= φ would imply (Q, ≤) |= φ, a 
contradiction. (cid:2)

Recall  that  formula  δ = ((cid:3)p ∧ (cid:3)(cid:2)¬p) → (cid:3)((cid:2)−1(cid:3)p ∧ (cid:2)¬p) has  been  introduced  in  Section 3.2 to  express  Dedekind-
2} is non-empty and upper bounded, and 

completeness. Intuitively, δ fails in (Q, ≤) since, for instance, the set {q ∈ Q | q <
therefore satisﬁes the antecedent. However, it has no least upper bound to satisfy the consequent.

√

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

39

0

1

2

. . .

(cid:6)

w

Fig. 5. Frames G1 and G2. The D-components are omitted for clarity.

As  a  further  example,  we  prove  that  neither  ﬁniteness  nor  inﬁnity  of  the  state  space  W are  expressible  in  boolean 

frames. This is in line with the situation in pml.

Lemma 84. In language L∗

sopml neither ﬁniteness nor inﬁnity are expressible in the class of boolean frames.

(cid:6)}, {(w

Proof. Consider frame G1 = (cid:17)N, succ, {N, ∅}(cid:18) of the naturals with the successor relation and the reﬂexive-point frame G2 =
(cid:6)}, ∅}(cid:18) in Fig. 5, which are boolean by deﬁnition of  D1 and  D2. In particular, the relations ω mapping 
(cid:6), w
(cid:17){w
(cid:6)} and the empty set ∅ to itself, form a bisimulation pair. Thus, G1 and 
every natural n ∈ N to  w
G2 validate the same formulas in sopml. However, G1 is inﬁnite while G2 is ﬁnite.  (cid:2)

, and (cid:22) mapping N to {w

(cid:6))}, {{w

(cid:6)

To conclude our brief review of expressivity results in sopml, we show that for the sublanguage of Lsopml without the 
reﬂexive and transitive closure operator  (cid:2)∗
,  ﬁniteness is not even expressible in full frames.  For n ∈ N,  let  [n] be the set 
N(cid:18) the frame isomorphic to the structure of natural numbers 
{0, . . . , n}, Gn the frame (cid:17)[n], succ, 2
endowed  with  the  successor  relation.  Both  GN and  each  Gn are  full.  Let  G be  the  class  of  all  frames  Gn,  for  n ∈ N,  and 
consider the following result.

[n](cid:18), and GN = (cid:17)N, succ, 2

Lemma 85. In language Lsopml the theory Th(G) is a subset of Th(GN).

(cid:6)

(cid:6), 0) (cid:7)|= φ, where assignment V

Proof. Consider φ /∈ Th(GN) with ﬁnite modal depth k ∈ N, where the modal depth is deﬁned as in the propositional case, 
as the maximum nesting of modal operators [7]. We can assume without loss of generality that  (GN, V , 0) (cid:7)|= φ for some 
(cid:6)(p) = V (p) ∩ [k] for every  p ∈ A P (since 
assignment V . We prove that (Gk, V
our frames are full, V (p) ∩ [k] is admissible in Gk). More precisely we prove, using induction on n, that if ψ is a subformula 
of φ of modal depth n ≤ k, then for all (cid:23) with 0 ≤ (cid:23) ≤ k − n, it holds that (GN, V , (cid:23)) |= ψ iff (Gk, V
We start with the case for n = 0. If ψ is an atom p, then (GN, V , (cid:23)) |= ψ iff (cid:23) ∈ V (p), iff (cid:23) ∈ V

(cid:6), (cid:23)) |= ψ , for 
all 0 ≤ (cid:23) ≤ k. The cases for propositional connectives are immediate. Finally, suppose ψ = ∃pχ , and that (∗) (GN, V , (cid:23)) |= χ
(cid:6) =
iff  (Gk, V
U ∩ [k] ∈ D

(cid:6), (cid:23)) |= χ for  all  0 ≤ (cid:23) ≤ k.  Then  (GN, V , (cid:23)) |= ψ implies  that  for  some  U ∈ D,  (GN, V
(cid:6) p
U (cid:6) , (cid:23)) |= χ , that is, (Gk, V

Now suppose that ψ is a subformula of φ of modal depth n + 1 ≤ k, and let 0 ≤ (cid:23) ≤ k − (n + 1). Assume that ψ = (cid:3)χ . 
(cid:6), (cid:23) + 1) |= χ , that 
(cid:6), (cid:23)) to (GN, V , (cid:23)) is similar, and the cases for the propositional connectives and 

Then, (GN, V , (cid:23)) |= ψ implies that (GN, V , (cid:23) + 1) |= χ for 1 ≤ (cid:23) + 1 ≤ k − n. By induction hypothesis (Gk, V
is, (Gk, V
the quantiﬁer go as before. (cid:2)

(cid:6), (cid:23)) |= ψ . The direction from (Gk, V

(cid:6), (cid:23)) |= ψ .
(cid:6)(p), iff (Gk, V

U , (cid:23)) |= ψ .  Consider  U

(cid:6) p
U (cid:6) . By (∗), (Gk, V

. In particular, (V

is such that V

(cid:6), (cid:23)) |= ψ .

U )(cid:6) = V

p

p

(cid:6)

Corollary 86. In language Lsopml ﬁniteness is not expressible on full frames.

(cid:6), 0) (cid:7)|= φ for some k ∈ N, i.e., φ /∈ Th(G). Hence, if φ
Proof. As a consequence of Lemma 85, (GN, V , 0) (cid:7)|= φ implies (Gk, V
expressed ‘being ﬁnite’, then it would be valid in G, and hence also in GN, a contradiction. Thus, ﬁniteness is not expressible 
even in the class of full frames. (cid:2)

In this section we made use of (bi)simulations to show that sopml can express notions, such as Dedekind-completeness, 
that are not expressible in pml; whereas other properties, such as ﬁniteness, cannot even be expressed in sopml. Together 
with the remarks in Section 5.1 on 3-colorability and the existence of Hamiltonian paths, these results provide us with some 
interesting insight into the application of model-theoretic techniques to the analysis of the expressivity of sopml.

In  our  opinion  bisimulations  for sopml raise  a  number  of  interesting  questions.  We  believe  that  one  in  particular  de-
serves more attention. The Van Benthem theorem is a well-known result in model theory, stating that modal logic is the 
bisimulation-invariant fragment of ﬁrst-order logic [6]. In the light of the notion of bisimulation provided above, it makes 
sense  to  ask  the  same  question  in  the  present  context:  is sopml the  bisimulation-invariant  fragment  of  monadic  second-
order logic, possibly when interpreted on a particular class of frames? In [35] it is proved that the modal μ-calculus is the 
bisimulation-invariant  fragment  of mso,  but  according  to  the  standard  notion  of  bisimulation  for pml.  Presently  it  is  not 
clear how this result relates to the current setting. We leave this problem open for future work.

6.  Conclusion

In this paper we motivated and studied (the use of) second-order propositional modal logic as a speciﬁcation language 
for reasoning about knowledge as well as spatial and temporal properties in artiﬁcial intelligence. Speciﬁcally, we aimed at 
developing proof- and model-theoretic techniques, notably complete axiomatisations and truth-preserving (bi)simulations, 

40

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

to  support  the  use  of sopml in  applications.  In  Section 2 we  introduced  20  different  classes  of  Kripke  frames,  according 
to the structure of the domain  D of quantiﬁcation and the features of the accessibility relations. In Section 4 we provided 
complete axiomatisations for some of these classes, while proving that other classes are unaxiomatisable.

Further,  we  introduced  suitable  notions  of  (bi)simulation  and  proved  that  they  preserve  the  satisfaction  of  (universal)
sopml.  Finally,  we  made  use  of  (bi)simulations  to  obtain  some  inexpressibility  results.  Speciﬁcally,  we  showed  that  being 
ﬁnite and having a Hamiltonian path are not expressible in sopml, while other properties, viz. topological completeness and 
3-colorability,  are  indeed  expressible.  We  conclude  that sopml can  indeed  be  used  as  a  modelling  language  for  artiﬁcial 
intelligence, particularly for temporal and spatial reasoning, as well as to describe higher-level knowledge of agents, that is, 
the  knowledge  agents  have  about  other  agents’  knowledge  and  beliefs,  as  shown  in  Section 3.  In  this  respect,  we  reckon 
that the development of model-theoretic techniques is key for applications.

6.1.  Future research

We have presented several results about sopml, but there are of course also a number of remaining questions for future 

research.

One such question is the relative expressivity of sopml and qctl. As mentioned in Section 1.1, the variant of sopml with 
full domain of quantiﬁcation is similar to one of the variants of qctl presented in [41], with the main difference being that
qctl is  based  on ctl,  while sopml is  based  on  basic  modal  logic.  The  temporal  logic ctl has  more  operators  than  modal 
logic, and it is strictly more expressive. It is not currently clear whether qctl is also strictly more expressive than sopml, 
however.

Another direction for future research is to ﬁnd fragments of sopml that are “well-behaved”. As discussed in Section 4, 
most  of sopml variants  are  unaxiomatisable  on  full  frames,  and  variants  that  include  the  reachability  operator  (cid:2)∗
are 
unaxiomatisable even on frames with coarser domains of quantiﬁcation. It would be interesting to ﬁnd fragments of sopml
that are large enough to be interesting, but that are axiomatisable or even decidable. In this respect the monodic fragment 
of  ﬁrst-order  modal  logic,  that  restrict  the  number  of  free  variables in  the  scope  of  any  modal  operator,  looks  promising 
[2,29,53]. We leave this direction for future work.

At the end of Section 5 we mentioned the interest of checking whether sopml is the bisimulation-invariant fragment of
mso, according to the newly introduced notion of bisimulation. Such a result would provide us with a precise characteri-
sation of the expressive power of sopml (with respect to mso), in the spirit of van Benthem’s result for modal logic [6]. It 
would also be of interest to deﬁne games in the style of Ehrenfeucht–Fraïssé to have a more ﬁne-grained approach to the 
analysis of the expressivity of sopml, similarly to the case for ﬁrst-order and modal logic [34].

Finally,  here  we  considered  a  unique  domain  D of  quantiﬁcation  in  any  of  our  frames.  But  more  elaborate  forms  of 
quantiﬁcation can be taken into account, for instance, we might consider a different quantiﬁcation domain for each state in 
the frame. Then, we might also consider state-dependent assignments. These variants have been studied extensively in the 
realm of ﬁrst-order modal logic [10,24], but never addressed in sopml. They might be of interest for speciﬁc applications.

Acknowledgements

The  authors  would  like  to  thank  the  anonymous  reviewers  for  valuable  comments  and  input  that  has  signiﬁcantly 
improved  a  previous  version  of  the  paper.  F. Belardinelli  acknowledges  the  support  of  the  ANR  JCJC  Project  SVeDaS 
(ANR-16-CE40-0021). L. Kuijer acknowledges support from ERC project EPS 313360.

Appendix A.  Selected proofs

Lemma 11.

1. Let φ be a formula in L∗

sopml and F a frame in Kall. If assignments V and V

(cid:6)

coincide on fr(φ), then

(F, V , w) |= φ iff (F, V

(cid:6)

, w) |= φ

2. Recall that X = {ap, pl, ml, sopml} and (cid:5)= {(ap, all), (pl, bool), (ml, modal), (sopml, full)}. Let x ∈ X . Then,

(a) For every ψ ∈ L∗
(b) If F ∈ K(cid:5)x and ψ ∈ L∗

x and model M over F ∈ K(cid:5)x, we have (cid:2)ψ(cid:3)M ∈ D.

x is free for p in φ, then

(F, V

p
(cid:2)ψ(cid:3)(cid:17)F ,V (cid:18)

, w) |= φ iff (F, V , w) |= φ[p/ψ]

Proof. The proofs are by induction on the structure of φ ∈ L∗

sopml.

1. If φ = p, then fr(φ) = {p} and (M, w) |= φ iff  w ∈ V (p) = V

(cid:6)(p), iff (M(cid:6), w) |= φ. The inductive cases for the proposi-

tional connectives are immediate.

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

41

If φ = (cid:2)aψ , then (M, w) |= φ iff for all  w
well, and by induction hypothesis for all w
If φ = ∀pψ , then (M, w) |= φ iff for any U ∈ D, (Mp
and by induction hypothesis (M(cid:6) p

(cid:6) ∈ Ra(w), (M, w
(cid:6) ∈ Ra(w), (M(cid:6), w

(cid:6)) |= ψ . Since fr(φ) = fr(ψ),  V and  V
coincide on fr(ψ) as 
(cid:6)) |= ψ , i.e., (M(cid:6), w) |= φ. The case for φ = (cid:2)∗ψ is similar.
(cid:6) p
p
U coincide on fr(ψ), 
U and V

U , w) |= ψ . Since fr(φ) = fr(ψ) \ {p}, V

(cid:6)

U , w) |= ψ . Since U has been chosen arbitrarily, this is the case iff (M(cid:6), w) |= φ.

2a The case for x = ap is immediate, as assignments are functions in  D. Hence, V (p) ∈ D for every  p ∈ A P .

The case for x = pl, follows from equalities (cid:2)¬ψ(cid:3) = W \ (cid:2)ψ(cid:3), (cid:2)ψ ∧ ψ (cid:6)(cid:3) = (cid:2)ψ(cid:3) ∩ (cid:2)ψ (cid:6)(cid:3), (cid:2)ψ ∨ ψ (cid:6)(cid:3) = (cid:2)ψ(cid:3) ∪ (cid:2)ψ (cid:6)(cid:3) and the 
fact that  D is a boolean algebra.
As for x = ml, notice that (cid:2)(cid:2)aψ(cid:3) = [a]((cid:2)ψ(cid:3)), (cid:2)(cid:2)∗ψ(cid:3) = [ ]∗((cid:2)ψ(cid:3)), and D is a boolean algebra closed under operators [a]
and [ ]∗
The case for x = sopml, is immediate, as (cid:2)ψ(cid:3) ⊆ W for every ψ ∈ L∗

.

2b Let us ﬁrst consider x = ap. If φ is an atom r, (Mp

V (q)(r), iff w ∈ V (r) whenever r (cid:7)= p or w ∈ V (q)

V (q), w) |= φ iff for every U ∈ D, ((Mp

U )p
U (q). As a consequence, we obtain ((Mr
V r
U , w) |= ϕ[p/q] by induction hypothesis. But this means that (M, w) |= ∀r(ϕ[p/q]) = (∀rϕ)[p/q].

for r = p. In both cases (M, w) |= φ[p/q].
The inductive cases for propositional connectives and modal operators are immediate, as these simply commute with 
substitution.
If φ = ∀rϕ for r (cid:7)= p, then (Mp
we have q (cid:7)= r and assignment (V
(Mr
As  regards  cases  x = pl, ml, sopml,  we  make  use  of  item 1.  We  only  prove  the  inductive  step  for  φ = ∀rϕ,  with 
r (cid:7)= p,  the  other  cases  being  similar  to  the  case  for  x = ap above.  Observe  that  (Mp
(cid:2)ψ(cid:3), w) |= φ iff  for  every  U ∈ D, 
((Mp
U , w) |= ϕ. Since r (cid:7)= p and ψ is free for  p in φ, we have r /∈ fr(ψ), and by item 1 above, (cid:2)ψ(cid:3)M = (cid:2)ψ(cid:3)Mr
. 
U , w) |=
Therefore  assignment  (V
ϕ[p/ψ] by induction hypothesis. But this means that (M, w) |= ∀r(ϕ[p/ψ]) = (∀rϕ)[p/ψ]. (cid:2)

U , w) |= ϕ. Since r (cid:7)= p and q is free for  p in φ, 
U (q), w) |= ϕ, i.e., 

.  Hence,  we  obtain  ((Mr

U is  equal  to  (V r

, w) |= ϕ,  i.e.,  (Mr

U is equal to (V r

(cid:2)ψ(cid:3)Mr
U

(cid:2)ψ(cid:3)Mr
U

(cid:2)ψ(cid:3))r

(cid:2)ψ(cid:3))r

V (q))r

V (q))r

U )p
V r

U )p

U )p

p

p

U

sopml.
p
V (q), w) |= φ iff w ∈ V

Lemma 20. For every model M = (cid:17)F , V (cid:18), world w ∈ W , and formula ψ ∈ L∗

sopml,

(M, w) |= ψ iff (F, ρ) |= S T x(ψ)

whenever ρ(x) = w and ρ(P i) = V (pi).

Proof. The  proof  is  by  induction  on  the  structure  of  ψ .  Since  the  steps  for  modal  logic  formulas  is  common,  we  only 
U , w) |= φ,  that  is,  (F , ρ(cid:6)) |= S T x(φ)
show  the  case  for  the  quantiﬁer.  For  ψ = ∀pφ,  (M, w) |= ψ iff  for  all  U ∈ D,  (Mp
by  induction  hypothesis,  for  ρ(cid:6)
U ) |= S T x(φ),  i.e., 
(F , ρ) |= ∀P (S T x(φ)) = S T x(ψ). (cid:2)

that  coincides  with  ρ but  ρ(cid:6)(P ) = U .  However,  this  means  that  (F , ρ P

Theorem 23. For every intended lpml model M, w ∈ M, and formula ϕ in lpml, we have

(M, w) |= ϕ iff (M, w) |= t(ϕ)

Proof. We will only prove the crucial clause

(M, w) |= ∀(cid:23)pθ((cid:23)a, (cid:23)p) iff (M, w) |= (cid:4)((cid:23)a)

Before  doing  that,  let  us  ﬁrst  show  what  it  means  for  the  following  speciﬁc  case:  θ(a, b, p) = (cid:2)a p → (cid:2)b p,  (cid:4)(a, b) =
Sup(a, b), and (cid:10)(a, b, x) = ∀ y(Rb(x, y) → Ra(x, y)), also written as  Rb(x) ⊆ Ra(x).

⇐ Since  (M, w) |= Sup(a, b),  we  have  that  Rb(x) ⊆ Ra(x) holds  in  (M, w),  and  hence  in  (F , w).  Since  (cid:2)a p → (cid:2)b p
locally  deﬁnes  Rb(x) ⊆ Ra(x),  we  have  (F , w) |= ((cid:2)a p → (cid:2)b p),  and  in  particular  (F , w) |= ∀p((cid:2)a p → (cid:2)b p).  Since 
∀p((cid:2)a p → (cid:2)b p) is  a  sentence,  we  obtain  (M, w) |= ∀p((cid:2)a p → (cid:2)b p).  ⇒ Now  suppose  that  (M, w) (cid:7)|= Sup(a, b).  Then 
(F , w) (cid:7)|= Sup(a, b). Since (cid:2)a p → (cid:2)b p locally deﬁnes  Rb(x) ⊆ Ra(x), we know that (F , w) (cid:7)|= (cid:2)a p → (cid:2)b p, and since F is 
full, for some assignment V

(cid:6), w) (cid:7)|= (cid:2)a p → (cid:2)b p, that is, (M, w) (cid:7)|= ∀p((cid:2)a p → (cid:2)b p).

As  for  the  general  case:  ⇐ Since  (M, w) |= (cid:4)((cid:23)a),  we  have  that  (cid:10)((cid:23)a, x) holds  in  (M, w),  and  hence  in  (F , w) (note 
fo only talks about what is accessible from what). Since θ((cid:23)a, (cid:23)p) locally deﬁnes (cid:10)((cid:23)a, x), we have (F , w) |= θ((cid:23)a, (cid:23)p), 
that (cid:10) ∈ L1
and in particular (F , w) |= ∀(cid:23)pθ((cid:23)a, (cid:23)p). Since ∀(cid:23)pθ((cid:23)a, (cid:23)p) is a sentence, (M, w) |= ∀pθ((cid:23)a, (cid:23)p). ⇒ Suppose that (M, w) (cid:7)|= (cid:4)((cid:23)a). 
Then, (F , w) (cid:7)|= (cid:4)((cid:23)a), and therefore (F , w) (cid:7)|= (cid:10)((cid:23)a, x). Since θ((cid:23)a, (cid:23)p) locally deﬁnes (cid:10)((cid:23)a, x), we know that (F , w) (cid:7)|= θ((cid:23)a, (cid:23)p), 
and since F is full, for some assignment V

(cid:6), w) (cid:7)|= θ((cid:23)a, (cid:23)p), that is, (M, w) (cid:7)|= ∀(cid:23)pθ((cid:23)a, (cid:23)p). (cid:2)

, we have (F , V

, we have (F , V

(cid:6)

(cid:6)

Lemma 25. Consider formulas ϕi ∈ Lsopml and (cid:10)i ∈ L1
assume ρ(x) = w. Assume F is a full frame, then,

fo in Example 24, for i = 1, . . . , 5. Let x be the only free variable in (cid:10)i and 

(F, w) |= ϕi iff (F, ρ) |= (cid:10)i

42

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

Proof. All items are relatively immediate. We only proved the ﬁrst and the last ones. Rather than (F , ρ) |= (cid:10), we will also 
write F |= (cid:10)(w), and say that (cid:10) holds for  w in F .

1. Suppose  F is  full  and  irreﬂexive  at  w,  that  is,  ¬Ra(w, w),  then  clearly  (F , w) |= ∃p((cid:2)a p ∧ ¬p),  by  considering  the 
assignment  V (p) = Ra(w) for  which  w /∈ V (p).  As  to  the  converse,  suppose  that  F , w |= ∃p((cid:2)a p ∧ ¬p).  Hence,  for 
every model M on F , (M, w) |= ∃p((cid:2)a p ∧ ¬p), i.e., (M, w) (cid:7)|= ∀p((cid:2)a p → p). However, by Lemma 20 below, this is 
the case iff  Ra(w, w) does not hold. Hence, (cid:10)1(w) holds in F .

2. Suppose  that  (cid:10)5(w) holds  in  F and  let  V be  such  that  (F , V , w) |= (cid:2)c p.  It  is  easy  to  check  that  (F , V

Ra(w), w) |=
(cid:2)aq ∧ (cid:2)b(q → p). In words, if we modify  V in such a way that q becomes true in exactly  w’s a-successors, then for 
every  b-successor  of  w that  satisﬁes  q (note  that  this  successor  must  then  also  be  an  a-successor),  p must  be  true. 
Conversely, suppose that (cid:10)5(w) does not hold, i.e., for some v ∈ W , we have Ra(w, v) and Rb(w, v), but not Rc(w, v). 
We now show that (F , w) |= ¬ϕ5 = ∃p((cid:2)c p ∧ ∀q((cid:2)aq → (cid:3)b(q ∧ ¬p))). The assignment V such that V (p) = Rc(w) is a 
witness for this: if  p is exactly true in the c-successors of  w, then it is false in  v, so whenever (cid:2)aq is true in  w, we 
have that q ∧ ¬p holds in v, and hence (cid:3)b(q ∧ ¬p) holds in  w. (cid:2)

q

Recall that in Section 4.2, we stated the following theorem without proof:

Theorem 62. If |I| ≥ 2, then the validities in sopml∗

over modal epistemic frames are not recursively enumerable.

In particular, sopml∗

is not axiomatisable on the class of modal epistemic frames.

Here, we provide the proof. The proof strategy that we use is very similar to the one used in the proof of Theorem 57: 

we deﬁne formulas ξgrid, ξsane and ξT that serve the same purpose as ψgrid, ψsane and ψT , respectively.

The main difference lies in how we deﬁne a grid, now that we use two-agent S5 as opposed to single agent K. This time, 
we use the following pattern: each point (n, m) ∈ Z × Z is represented not by a single world, but instead by (at least) ﬁve 
different worlds that are related to each other by the relation R(a). One of these ﬁve worlds satisﬁes the propositional atom 
center, the other four worlds satisfy the atoms left, right, up and down, respectively. The left world of (n, m) is then related 
by  R(b) to the right world of (n − 1, m), and similarly for the other directions; see also the following diagram.

up

up

up

left

center

right

b

left

center

right

b

left

center

right

down

a

down

a

down

a

b

up

b

up

b

up

left

center

right

b

left

center

right

b

left

center

right

down

a

down

a

down

a

b

up

b

up

b

up

left

center

right

b

left

center

right

b

left

center

right

down

a

down

a

down

a

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

43

As before, this allows us to deﬁne (cid:2)x and ♦x (for x ∈ dir) as abbreviations:

(cid:2)xφ := (cid:2)a(x → (cid:2)b(¬x → (cid:2)a(center → φ)))
♦xφ := ♦a(x ∧ ♦b(¬x ∧ ♦a(center ∧ φ)))

Then we deﬁne a grid in almost exactly the same way as the  K -case:

ξgrid := (cid:2)∗

(labels ∧ direction ∧ same ∧ remain ∧

(cid:7)

inversexy ∧

(cid:7)

(x, y)∈inv_dir
(cid:12)

(cid:7)

(i ∧

(cid:7)

(x, y)∈perp_dir
♦al

¬ j) ∧

labels :=

(cid:7)

x∈dir

uniquex

∧

commutexy)

l∈L
directions := ((left ∨ right) → (♦bleft ∧ ♦bright ∧ (cid:2)b(left ∨ right)))∧

j∈L\{i}

i∈L

((up ∨ down) → (♦bup ∧ ♦bdown ∧ (cid:2)b(up ∨ down)))
(cid:7)

∀p((l ∧ p) → ((cid:2)a(l → p) ∧ (cid:2)b(l → p))
(cid:7)

l∈L

∀p(p ↔ (cid:2)c p)

same :=

remain :=

c∈ Ag\{a,b}

:= ∀p(♦x p → (cid:2)x p))
uniquex
inversexy :=∀p(p → (cid:2)x(cid:2) y p)

commutexy :=∀p(♦x♦ y p → (cid:2) y(cid:2)x p)

where dir, inv_dir and perp_dir are as before, and L := {left, right, up, down, center}.

Note that uniquex, inversexy and commutexy are identical to their counterparts in the proof of Theorem 57, but the other 

subformulas are different.

If M, w 0 |= ξgrid, then we associate the worlds of M with the points of Z × Z in the following way: (i)  w 0 and all its 
(cid:6)
(cid:6) |= right, then  w
a-successors represent (0, 0), (ii) if  w represents (n, m), M, w |= left,  w
represents (n − 1, m), (iii) similarly for the other directions and (iv) if  w represents (n, m) then so does every c-successor 
of (n, m) for every c /∈ {a, b}.

is a b-successor of  w and M, w

(cid:6)

As before, we show that every point (n, m) is represented by at least one world and that each world represents at least 
one  point.  Since  every  point  is  represented  by  at  least  one  center world,  one  right world,  one  left world,  one  up world 
and one down world, we obviously cannot guarantee that all the worlds representing a point are indistinguishable. We will 
show, however, that all center worlds representing (n, m) are modally indistinguishable from one another.

• labels guarantees that every world (i) satisﬁes exactly one of the labels from  L and (ii) has a successor that satisﬁes l

for every l ∈ L.

• directions guarantees  that  every  left world  is  paired  with  a  right world  through  the  relation  R(b),  and  similarly  for 
the other directions. Due to how we deﬁned ♦x and (cid:2)x as abbreviations, this means that every center world has and 
x-successor that is also a center world, for every x ∈ dir. That, in turn, implies that every point (n, m) is represented by 
at least one world.

• same says  that  for  every  U ∈ D,  if  w is  in  U then  so  are  all  of  its  a- and  b-successors  that  share  the  same  label. 
Since  we  are  working  with  a  modal  domain  of  quantiﬁcation,  this  implies  that  every  label  is  unique  (up  to  modal 
indistinguishability)  in  its a- and  b-equivalence  classes.  Note  that,  together  with  the  fact  that  left, right, up and  down
worlds  occur  only  in  pairs,  this  implies  that  whenever  a  world  w represents  some  point  (n, m),  then  every  a- or 
(cid:6)). So every world in the generated submodel represents some point 
b-successor of  w also represents some point (n
(n, m).

• remain says that for any agent c other than a and b,  w is modally indistinguishable from its c-successors. This implies 

(cid:6), m

that if  w and  w

represent the same point (n, m) due to rule (iv), then  w and  w
• The formulas uniquex, inversexy and commutexy , for the relevant x and  y, guarantee that if w and w

are modally indistinguishable.

represent the same 

(cid:6)

(cid:6)

(cid:6)

point (n, m) due to rules (ii) and (iii), then  w and  w

are modally indistinguishable.

(cid:6)

We have now shown that every point (n, m) is represented, that every world represents a point and that all worlds repre-
senting a single point are modally indistinguishable.

44

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

(cid:19)

only put requirements on center world, e.g., the subformula 
s(cid:6)∈states\{s} ¬s
center →

Variants  ξsane and  ξT of  ψsane and  ψT can  then  be  deﬁned.  The  only  required  modiﬁcation  is  that  in  ξsane and  ξT we 
(cid:6)) of ψsane should be replaced with 
(cid:6)) in ξsane. Since these modiﬁcations are rather trivial, we do not list them here in detail.
Overall,  if  we  deﬁne  ζT := ξgrid ∧ ξsane ∧ ξT ∧ s0 ∧ pos,  then  M, w |= ζT implies  that  M encodes  the  execution  of  T . 
It  follows  that  T is  non-halting  if  and  only  if M, w |= ζT → (cid:2)∗(center → ¬send).  In  particular,  this  implies  that  the  valid 
formulas of sopml∗

over modal S5 frames are not recursively enumerable.

s(cid:6)∈states\{s} ¬s

s∈states(s ∧

s∈states(s ∧

(cid:2)

(cid:19)

(cid:2)

Lemma 87.

1. It can be checked in NPTIME whether there exists a bisimulation relation between two frames.
2. Let F and F (cid:6)
, respectively, such that w ≈ w
modal) iff F (cid:6)
Moreover, if Fw and F (cid:6)

be frames and let w and w
w(cid:6) is. However, if Fw is full, then F (cid:6)

w(cid:6) are full, then they are isomorphic.

be worlds of F and F (cid:6)

w(cid:6) need not be full.

(cid:6)

(cid:6)

. Then Fw is boolean (respectively 

(cid:6)

Now,  suppose  that  D

Proof. We provide a proof of point 2. Suppose that  w ≈ w
that it follows that for every world  w 1 of Fw there is a world  w

(cid:6)
is  closed  under  complement,  and  take  any  U ∈ D w .  There  is  at  least  one  U

(cid:6)
1), and vice versa.
(cid:6)
(cid:6) ∈ D
w(cid:6) such  that 
(cid:6)
w(cid:6) . There is also at least one  T ∈ D w
(cid:6)
(cid:6)
(cid:6)). Now, take any  w 1 ∈ W w . As noted above, there is at least one  w
1). 
1
(cid:6)
(cid:6)
(cid:6)
w(cid:6) \ U
and 
1
(cid:6)
w(cid:6) are true, so we also have that exactly one of  w 1 ∈ U and  w 1 ∈ T is true. So W w \ U = T ∈ D w .

(cid:22)(U , U
such that (cid:22)(T , W
Because (ω, (cid:22)) is a bisimulation, we have  w 1 ∈ U iff  w
w

(cid:6)
w(cid:6) is closed under complement, we have  W

(cid:6)). Furthermore, since  D
(cid:6)
w(cid:6) \ U

∈ W
. Exactly one of  w

(cid:6)
w(cid:6) such that ω(w 1, w

, so there is some bisimulation (ω, (cid:22)) such that ω(w, w

w(cid:6) such that ω(w 1, w

and  w 1 ∈ T iff  w

1 of F (cid:6)

(cid:6)
w(cid:6) \ U

(cid:6) ∈ D

∈ W

∈ U

∈ U

(cid:6)
w(cid:6)

(cid:6)
1

(cid:6)
1

(cid:6)
1

(cid:6)

(cid:6)

(cid:6)
w(cid:6) is closed under complement, then so is  D w . It can be shown in a similar way that if  D

∈ W
We have shown that if  D

(cid:6)). Note 

closed under intersection or under [a] then so is  D w . So Fw is boolean (respectively modal) if F (cid:6)
symmetrical, the reverse holds as well.

(cid:6)
w(cid:6) is 
w(cid:6) is. Since bisimilarity is 

In order to see that Fw can be full without Fw(cid:6) being full, consider the frame F given by W = {w}, Ra = W × W , D =
(cid:6), v
(cid:6)
,  as  witnessed  by  ω =
(cid:6))}. Furthermore, both frames are identical to their respective generated submodels. 

(cid:6) = {w
(cid:6))} and (cid:22) = {(∅, ∅), (W , W

(cid:6)}.  We  have  w ≈ w

given  by  W

(cid:6) = {∅, W

(cid:6) × W

and  D

= W

(cid:6)}, R

(cid:6)
a

(cid:6)

2W and  the  frame  F (cid:6)
(cid:6)), (w, v
{(w, w
Yet F is full while F (cid:6)

is not.

Finally, suppose that Fw and F (cid:6)

U ∈ D w be such that (cid:22)(U , {w
Furthermore, as noted above, for every  w 1 there is a  w
that ω is an isomorphism. (cid:2)

}). Then  w

∈ {w

(cid:6)
1

w(cid:6) are both full. Suppose that for some  w ∈ W w we have ω(w, w
(cid:6)
2
(cid:6)
1 such that ω(w 1, w

(cid:6)
(cid:6)
2). Let 
1) and ω(w, w
(cid:6)
= w
2. So ω is injective. 
(cid:6)
1) and vice versa, so ω is surjective. It follows 

}, which implies that  w

} iff  w 1 ∈ U iff  w

∈ {w

(cid:6)
1

(cid:6)
1

(cid:6)
1

(cid:6)
1

Theorem 74. If w ≈ w

(cid:6)

, then for every formula ϕ ∈ L∗

sopml,

(F, w) |= ϕ iff (F (cid:6)

, w

(cid:6)

) |= ϕ.

(cid:6)) holds 
Proof. We prove the implication from right to left, the opposite direction being symmetric. If  w ≈ w
for some bisimulation pair (ω, (cid:22)). As above, we show by induction on ϕ that if (F , V , w) (cid:7)|= ϕ for some assignment V , then 
(F (cid:6), (cid:22)(V ), w
(cid:6)). Since ω
is a simulation relation in particular, the base cases for ϕ = p and ϕ = ¬p are as in Theorem 67, as well as the inductive 
cases for propositional connectives and ϕ = (cid:2)aψ , ϕ = (cid:2)∗ψ , and ϕ = ∀pψ .

(cid:6)) (cid:7)|= ϕ, where (cid:22)(V ) is any assignment such that for every  p ∈ A P,  ((cid:22)(V ))(p) = U

with (cid:22)(V (p), U

then ω(w, w

(cid:6)

(cid:6)

For  ϕ = (cid:3)aψ ,  (F (cid:6), (cid:22)(V ), w

(cid:6)) |= ϕ iff  for  some  v

(cid:6) ∈ R

(cid:6)),  (F (cid:6), (cid:22)(V ), v

(cid:6)) |= ψ .  By  bisimulation,  for  some  v ∈ Ra(w), 

For ϕ = ∃pψ , (F (cid:6), (cid:22)(V ), w

(cid:6)). In particular, (F , V , v) |= ψ by induction hypothesis. That is, (F , V , w) |= ϕ. The case for ϕ = (cid:3)∗ψ is similar.
(cid:6) ∈ D
(cid:6)) |= ψ . Now consider U ∈ D such that (cid:22)(U , U
, (F (cid:6), ((cid:22)(V ))p
U ) coincides.  Hence,  (F (cid:6), (cid:22)(V

(cid:6)) ∈
(cid:6)) |= ψ ,  and  by  induction  hypothesis, 

(cid:6)) |= ϕ iff for some U
p
U (cid:6) and  (cid:22)(V

p
U ), w

U (cid:6) , w

(cid:6)

ω(v, v

(cid:6)
a(w

D.  In  particular,  assignments  ((cid:22)(V ))p
(F , V

U , w) |= ψ for U ∈ D, that is, (F , V , w) |= ϕ. (cid:2)

p

References

Res. 45 (2012) 1–45.

[1] A. Baltag, S. Smets (Eds.), Johan van Benthem on Logic and Information Dynamics, Springer, 2014.
[2] F. Belardinelli, A. Lomuscio, Interactions between knowledge and time in a ﬁrst-order logic for multi-agent systems: completeness results, J. Artif. Intell. 

[3] F.  Belardinelli, W.  van  der  Hoek,  Epistemic  quantiﬁed  boolean  logic:  expressiveness  and  completeness  results,  in:  Q.  Yang,  M. Wooldridge  (Eds.), 

Proceedings of the Twenty-Fourth International Joint Conference on Artiﬁcial Intelligence, AAAI Press, 2015, pp. 2748–2754.

[4] F. Belardinelli, W. van der Hoek, A semantical analysis of second-order propositional modal logic, in: Proceedings of the 30th AAAI Conference on 

Artiﬁcial Intelligence, AAAI-16, AAAI Press, 2016, pp. 886–892.

[5] F. Belardinelli, H. van Ditmarsch, W. van der Hoek, Second-order propositional announcement logic, in: C. Jonker, S. Marsella, J. Thangarajah, K. Tuyls 
(Eds.), Proceedings of the 2016 International Conference on Autonomous Agents & Multiagent Systems, ACM, 2016, pp. 635–643, http://dl .acm .org /
citation .cfm ?id =2937019.

[6] J. van Benthem, Modal Correspondence Theory, Ph.D. thesis, University of Amsterdam, 1976.
[7] P. Blackburn, M. de Rijke, Y. Venema, Modal Logic, Camb. Tracts Theor. Comput. Sci., vol. 53, Cambridge University Press, 2001.

F. Belardinelli et al. / Artiﬁcial Intelligence 263 (2018) 3–45

45

[8] P. Blackburn, J. van Benthem, Modal logic: a semantic perspective, in: Blackburn et al. [9], pp. 1–84.
[9] P. Blackburn, J. van Benthem, F. Wolter (Eds.), Handbook of Modal Logic, Elsevier, Amsterdam, The Netherlands, 2007.
[10] T. Brauner, S. Ghilardi, First-order modal logic, in: P. Blackburn, J. van Benthem, F. Wolter (Eds.), Handbook of Modal Logic, Elsevier, 2007, pp. 549–620.
[11] R.A. Bull, On modal logic with propositional quantiﬁers, J. Symb. Log. 34 (1969) 257–263.
[12] B. ten Cate, Expressivity of second order propositional modal logic, J. Philos. Log. 35 (2) (2006) 209–223, http://dblp .uni -trier.de /db /journals /jphil /

jphil35 .html #Cate06.

Press, New York, NY, USA, 2012.

[13] A. Church, A note on the entscheidungsproblem, J. Symb. Log. 1 (1) (1936) 40–41.
[14] E.M. Clarke, O. Grumberg, D.E. Long, Model checking and abstraction, ACM Trans. Program. Lang. Syst. 16 (5) (1994) 1512–1542.
[15] P.B. Courcelle, D.J. Engelfriet, Graph Structure and Monadic Second-Order Logic: A Language-Theoretic Approach, 1st edition, Cambridge University 

[16] H.P. van Ditmarsch, W. van der Hoek, B.P. Kooi, Knowing more – from global to local correspondence, in: C. Boutilier (Ed.), IJCAI 2009, Proceedings of 

the 21st International Joint Conference on Artiﬁcial Intelligence, 2009, pp. 955–960, http://ijcai .org /papers09 /Papers /IJCAI09 -162 .pdf.

[17] H.P. van Ditmarsch, W. van der Hoek, B.P. Kooi, Reasoning about local properties in modal logic, in: L. Sonenberg, P. Stone, K. Tumer, P. Yolum (Eds.), 
Proceedings of the 10th International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2011), IFAAMAS, 2011, pp. 711–718, http://
portal .acm .org /citation .cfm ?id =2031719 &amp ;CFID =54178199 &amp ;CFTOKEN =61392764.

[18] H.P. van Ditmarsch, W. van der Hoek, B.P. Kooi, Local properties in modal logic, Artif. Intell. 187 (2012) 133–155.
[19] H. Ebbinghaus, J. Flum, W. Thomas, Mathematical Logic, Springer, 1994.
[20] R. Fagin, J. Halpern, Y. Moses, M. Vardi, Reasoning About Knowledge, The MIT Press, 1995.
[21] K. Fine, Propositional quantiﬁers in modal logic, Theoria 36 (3) (1970) 336–346.
[22] T. French, Bisimulation Quantiﬁers for Modal Logic, Ph.D. thesis, University of Western Australia, 2006.
[23] D.M. Gabbay, An irreﬂexivity lemma with applications to axiomatizations of conditions on tense frames, in: U. Mönnich (Ed.), Aspects of Philosophical 

Logic: Some Logical Forays Into Central Notions of Linguistics and Philosophy, Springer, Dordrecht, Netherlands, 1981, pp. 67–89.

[24] J. Garson, Quantiﬁcation in modal logic, in: D. Gabbay, F. Guenthner (Eds.), Handbook of Philosophical Logic, vol. 3, Reidel, 2001, pp. 267–323.
[25] J. Halpern, Y. Moses, Knowledge and common knowledge in a distributed environment, J. ACM 37 (3) (1990) 549–587.
[26] F. van Harmelen, V. Lifschitz, B. Porter, Handbook of Knowledge Representation, Elsevier Science, San Diego, USA, 2007.
[27] M. Hennessy, R. Milner, On observing nondeterminism and concurrency, in: Proceedings of the 7th Colloquium on Automata, Languages and Program-

ming, Springer-Verlag, London, UK, 1980, pp. 299–309, http://dl .acm .org /citation .cfm ?id =646234 .758793.

[28] J. Hintikka, Knowledge and Belief: An Introduction to the Logic of the Two Notions, Contemporary Philosophy, Cornell University Press, 1962, http://

books .google .fr /books ?id =N28OAAAAIAAJ.

[29] I. Hodkinson, F. Wolter, M. Zakharyaschev, Monodic fragments of ﬁrst-order temporal logics: 2000–2001 a.d., in: R. Nieuwenhuis, A. Voronkov (Eds.), 

LPAR, in: Lect. Notes Comput. Sci., vol. 2250, Springer, 2001, pp. 1–23.

[30] W. van der Hoek, J.-J.C. Meyer, Making some issues of implicit knowledge explicit, Int. J. Found. Comput. Sci. 3 (2) (1992) 193–224.
[31] W. van der Hoek, M. Pauly, Modal logic for games and information, in: Blackburn et al. [9], pp. 1077–1148.
[32] W. van der Hoek, M. Wooldridge, Multi-agent systems, in: F. van Harmelen, V. Lifschitz, B. Porter (Eds.), Handbook of Knowledge Representation, 

Elsevier, 2008, pp. 887–928.

[33] W. Holliday, A Note on Algebraic Semantics for s5 with Propositional Quantiﬁers, Tech. rep., Group in Logic and the Methodology of Science, UC 

Berkeley, 2017, to appear in Notre Dame Journal of Formal Logic, http://escholarship .org /uc /item /303338xr.

[34] N. Immerman, Descriptive Complexity, Springer-Verlag, 1999.
[35] D. Janin, I. Walukiewicz, On the expressive completeness of the propositional mu-calculus with respect to monadic second order logic, in: U. Montanari, 

V. Sassone (Eds.), Proceedings of the 7th International Conference on Concurrency Theory, CONCUR ’96, Springer, 1996, pp. 263–277.

[36] M. Kaminski, M.L. Tiomkin, The expressive power of second-order propositional modal logic, Notre Dame J. Form. Log. 37 (1) (1996) 35–43, http://

dblp .uni -trier.de /db /journals /ndjﬂ /ndjﬂ37.html #KaminskiT96.

[37] D. Kaplan, S5 with quantiﬁable propositional variables, J. Symb. Log. 35 (1970) 355.
[38] L.B. Kuijer, Arbitrary Arrow Update Logic with Common Knowledge is neither RE nor co-RE, in: J. Lang (Ed.), Proceedings of the Sixteenth Conference 

on Theoretical Aspects of Rationality and Knowledge, TARK 2017, 2017, pp. 373–381.

[39] A. Kuusisto, A modal perspective on monadic second-order alternation hierarchies, in: Advances in Modal Logic, 2008, pp. 231–247.
[40] A. Kuusisto, Second-order propositional modal logic and monadic alternation hierarchies, Ann. Pure Appl. Log. 166 (1) (2015) 1–28, https://doi .org /10 .

1016 /j .apal .2014 .08 .003, http://www.sciencedirect .com /science /article /pii /S0168007214000876.

[41] F. Laroussinie, N. Markey, Quantiﬁed CTL: expressiveness and complexity, Log. Methods Comput. Sci. 10 (4) (2015) 17, https://doi .org /10 .2168 /LMCS -

10(4 :17 )2014, http://www.lsv.ens -cachan .fr /Publis /PAPERS /PDF /LM -lmcs14 .pdf.

[42] L. Libkin, Elements of Finite Model Theory, Texts Theoret. Comput. Sci. EATCS Ser., Springer, Berlin, Heidelberg, 2004, https://books .google .fr /books ?id =

zsJlEK4nK7sC.

[43] Z. Manna, A. Pnueli, The Temporal Logic of Reactive and Concurrent Systems, vol. 1, Springer-Verlag, 1992.
[44] E. Mares, R. Goldblatt, An alternative semantics for quantiﬁed relevant logic, J. Symb. Log. 71 (1) (2006) 163–187.
[45] J.-J.C. Meyer, W. v. d. Hoek, Epistemic Logic for AI and Computer Science, Cambridge University Press, New York, NY, USA, 1995.
[46] W. Quine, Quantiﬁers and propositional attitudes, J. Philos. 53 (5) (1956) 177–187.
[47] F. Roelofsen, Distributed knowledge, J. Appl. Non-Class. Log. 17 (2) (2007) 255–273.
[48] A.P. Sistla, M.Y. Vardi, P. Wolper, The complementation problem for büchi automata with applications to temporal logic (extended abstract), in: W. 
Brauer (Ed.), Automata, Languages and Programming, 12th Colloquium, Nafplion, Greece, July 15–19, 1985, Proceedings, in: Lect. Notes Comput. Sci., 
vol. 194, Springer, 1985, pp. 465–474.

[49] A.P. Sistla, Theoretical Issues in the Design and Veriﬁcation of Distributed Systems, Ph.D. thesis, Carnegie-Mellon University, Cambridge, MA, USA, 1983, 

aAI8403047.

doi .org /10 .1112 /plms /s2 -42 .1.230.

[50] A.M. Turing, On computable numbers, with an application to the entscheidungsproblem, Proc. Lond. Math. Soc. s2–42 (1) (1937) 230–265, https://

[51] J. Vaananen, Second-order logic and foundations of mathematics, Bull. Symb. Log. 7 (4) (2001) 504–520, http://www.jstor.org /stable /2687796.
[52] Y.  Venema,  Derivation  rules  as  anti-axioms  in  modal  logic,  J.  Symb.  Log.  58  (1993)  1003–1034,  https://doi .org /10 .2307 /2275109,  http://journals .

cambridge .org /article _S0022481200021010.

[53] F. Wolter, M. Zakharyaschev, Axiomatizing the monodic fragment of ﬁrst-order temporal logic, Ann. Pure Appl. Log. 118 (1–2) (2002) 133–145.

