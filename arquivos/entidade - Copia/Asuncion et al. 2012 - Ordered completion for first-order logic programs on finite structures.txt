Artiﬁcial Intelligence 177–179 (2012) 1–24

Contents lists available at SciVerse ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Ordered completion for ﬁrst-order logic programs on ﬁnite structures
Vernon Asuncion a, Fangzhen Lin b, Yan Zhang a, Yi Zhou a,∗

a Intelligent Systems Lab, School of Computing and Mathematics, University of Western Sydney, Penrith South DC, NSW 1797, Australia
b Department of Computer Science, Hong Kong University of Science and Technology, Clear Water Bay, Kowloon, Hong Kong

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 20 October 2010
Received in revised form 16 November 2011
Accepted 17 November 2011
Available online 25 November 2011

Keywords:
Answer set programming
Ordered completion
Knowledge representation
Nonmonotonic reasoning

In this paper, we propose a translation from normal ﬁrst-order logic programs under the
stable model semantics to ﬁrst-order sentences on ﬁnite structures. The translation is done
through, what we call, ordered completion which is a modiﬁcation of Clark’s completion
with some auxiliary predicates added to keep track of the derivation order. We show that,
on ﬁnite structures, classical models of the ordered completion of a normal logic program
correspond exactly to the stable models of the program. We also extend this result to
normal programs with constraints and choice rules.
From a theoretical viewpoint, this work clariﬁes the relationships between normal logic
programming under the stable model semantics and classical ﬁrst-order logic. It follows
that, on ﬁnite structures, every normal program can be deﬁned by a ﬁrst-order sentence if
new predicates are allowed. This is a tight result as not every normal logic program can
be deﬁned by a ﬁrst-order sentence if no extra predicates are allowed or when inﬁnite
structures are considered. Furthermore, we show that the result cannot be extended to
disjunctive logic programs, assuming that NP (cid:3)= coNP.
From a practical viewpoint, this work leads to a new type of ASP solver by grounding
on a program’s ordered completion instead of the program itself. We report on a
ﬁrst implementation of such a solver based on several optimization techniques. Our
experimental results show that our solver compares favorably to other major ASP solvers
on the Hamiltonian Circuit program, especially on large domains.

Crown Copyright © 2011 Published by Elsevier B.V. All rights reserved.

1. Introduction

This work is about translating logic programs under the stable model (answer set) semantics [12] to ﬁrst-order logic.
Viewed in the context of formalizing the semantics of logic programs in classical logic, work in this direction goes back to
that of Clark [4] who gave us what is now called Clark’s completion semantics, on which our work, like most other work in
this direction, is based.

In terms of the stable model semantics, Clark’s completion semantics is too weak in the sense that not all models of
Clark’s completion are stable models, unless the programs are “tight” [8]. Various ways to remedy this have been proposed,
particularly in the propositional case given the recent interest in Answer Set Programming (ASP) and the prospect of using
SAT solvers to compute answer sets [19]. This paper considers ﬁrst-order logic programs, and the prospect of capturing the
answer sets of these programs in ﬁrst-order logic.

A crucial consideration for work of this kind is whether auxiliary symbols (in the propositional case) or predicates (in
the ﬁrst-order case) can be used. For propositional logic programs, Ben-Eliyahu and Dechter’s translation [1] is polynomial
in space but uses O (n2) auxiliary variables, while Lin and Zhao’s translation [19] using loop formulas is exponential in the

* Corresponding author.

E-mail addresses: vernon@scm.uws.edu.au (V. Asuncion), ﬂin@cse.ust.hk (F. Lin), yan@scm.uws.edu.au (Y. Zhang), yzhou@scm.uws.edu.au (Y. Zhou).

0004-3702/$ – see front matter Crown Copyright © 2011 Published by Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2011.11.001

2

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

worst case but does not use any auxiliary variables. Chen et al. [2] extended loops and loop formulas to ﬁrst-order case and
showed that for ﬁnite domains, the answer sets of a ﬁrst-order normal logic program can be captured by its completion
and ﬁrst-order loop formulas. However, in general, a program may have an inﬁnite number of loops and loop formulas.
But this seems to be the best that one can hope for if no auxiliary predicates are used: it is well known that transitive
closure, which can be easily written as a ﬁrst-order logic program, cannot be captured by any ﬁnite ﬁrst-order theory on
ﬁnite structures [5].

The situation is different if we introduce auxiliary predicates. Our main technical result of this paper is that by using
some additional predicates that keep track of the derivation order from bodies to heads in a program, we can modify Clark’s
completion into what we call the ordered completion that captures exactly the answer set semantics on ﬁnite structures.

The rest of the paper is organized as follows. We recall some background knowledge in the next section. In Section 3, we
deﬁne our ordered completions for ﬁrst-order normal logic programs, and show that they capture exactly the stable models
of the programs on ﬁnite structures. We then show that this result can be extended to normal programs with constraints
and choice rules. However, it cannot be extended to disjunctive logic programs and does not hold on arbitrary structures.
Speciﬁcally, in Section 3 we show that, on arbitrary structures, there exist some normal logic programs that cannot be
captured by any ﬁrst-order theory, and on ﬁnite structures, there exists some disjunctive logic program that cannot be
captured by any ﬁrst-order sentence provided that NP (cid:3)= coNP. We then present some techniques for optimizing ordered
completions in Section 4. These techniques are used in our implementation of a ﬁrst-order solver. We describe this solver
and some of the experimental results in Section 5. We discuss some related work in Section 6, and conclude the paper in
Section 7.

2. Preliminaries

We assume that readers are familiar with some basic notions and notations of classical ﬁrst-order logic. Here, we consider
a ﬁnite ﬁrst-order language without function symbols but with equality. In particular, an atom is called an equality atom if
it is of the form t1 = t2, and a proper atom otherwise.

Let σ and σ1 be two signatures such that σ ⊆ σ1. Given a structure A of signature σ1, we say that the reduct of A on σ ,
denoted by A ↑ σ , is the σ -structure that agrees with A on all interpretations of predicates and constants in σ . Conversely,
we say that A is an expansion of A ↑ σ to σ1.

A normal logic program (program for short) is a ﬁnite set of rules of the following form

α ← β1, . . . , βk, not γ1, . . . , not γl,

(1)
where α is a proper atom, 0 (cid:2) k (cid:2) l, and βi (1 (cid:2) i (cid:2) k), γ j (1 (cid:2) j (cid:2) l) are atoms. Given a rule r of form (1), we call α
the head of r, denoted by Head(r), and {β1, . . . , βk, not γ1, . . . , not γl} the body of r, denoted by Body(r). In particular, we call
{β1, . . . , βk} the positive body of r, denoted by Pos(r), and {γ1, . . . , γl} the negative body of r, denoted by Neg(r). We call a
variable in a rule a body variable if it occurs in the body but not the head of the rule.

Given a program Π , a predicate is called intensional if it occurs in the head of some rule in Π , and extensional otherwise.

The signature of Π contains all intensional predicates, extensional predicates and constants occurring in Π .

For convenience and without loss of generality, in the following we assume that programs are normalized in the sense
that for each intensional predicate P , there is a tuple (cid:7)x of distinct variables matching the arity of P such that for each rule,
if its head mentions P , then the head must be P ((cid:7)x). So all the rules with P occurring in the heads in a program can be
enumerated as:

P ((cid:7)x) ← Body1, . . . , P ((cid:7)x) ← Bodyk.

2.1. Clark’s completion

Our following deﬁnition of Clark’s completion is standard except that we do not make completions for extensional

predicates.

Given a program Π , and a predicate P in it, Clark’s Completion of P in Π is the following ﬁrst-order sentence [4]:

∃(cid:7)yi

(cid:2)
Bodyi

,

(2)

(cid:2)

∀(cid:7)x

P ((cid:7)x) ↔

where

(cid:3)

1(cid:2)i(cid:2)k

(cid:4)

• P ((cid:7)x) ← Body1, . . . , P ((cid:7)x) ← Bodyk are all the rules whose heads mention the predicate P ;
• (cid:7)yi is the tuple of body variables in P ((cid:7)x) ← Bodyi ;
• (cid:2)

Bodyi is the conjunction of elements in Bodyi by simultaneously replacing the occurrences of not by ¬.

Clark’s Completion (completion for short if clear from the context) of Π , denoted by Comp(Π), is then the set of Clark’s
completions of all intensional predicates in Π .

Example 1 (Transitive Closure (TC)). The following normal logic program TC computes the transitive closure of a given graph:

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

3

S(x, y) ← E(x, y)
S(x, y) ← E(x, z), S(z, y),

where E is the only extensional predicate of TC, representing the edges of a graph, and S is the only intensional predicate
of TC. Ideally, the intensional predicate computes the transitive closure (i.e. all the paths) of a given graph. The Clark’s
Completion of TC is the following ﬁrst-order sentence:
(cid:6)(cid:6)

(cid:5)

(cid:5)

∀xy

S(x, y) ↔

E(x, y) ∨ ∃zE(x, z) ∧ S(z, y)

.

2.2. The stable model semantics for propositional programs

In the propositional case, the stable model semantics for normal propositional programs was proposed by Gelfond and
Lifschitz [12], and later extended to become answer set semantics for propositional programs that can have classical nega-
tion, constraints, disjunctions, and other operators [6,11,13,17,21,22]. Several equivalent characterizations are proposed,
including the Gelfond–Lifschitz transformation [12], the logic of GK [20], loop formulas [19], equilibrium logic [26], gen-
eral reduction [11], and so on. Here, we brieﬂy review the standard Gelfond–Lifschitz transformation semantics [12] and the
loop formula characterization in the propositional case [19], as they are needed in the proof of our main theorem.

Let Π be a propositional program and A a set of atoms. We say that A satisﬁes a rule r in Π if Head(r) ∈ A whenever
Pos(r) ⊆ A and Neg(r) ∩ A = ∅. Then, A satisﬁes Π if it satisﬁes all rules in Π . The reduct of Π relative to A, denoted
by Π A
, is the program obtained from Π by (i) deleting every rule r in Π whose negative body is not satisﬁed by A (i.e.
not disjoint with A), and (ii) deleting all negative atoms in other rules. Then, A is said to be a stable model (or an answer
set) of Π iff A satisﬁes Π and there does not exist A(cid:16) ⊂ A such that A(cid:16)

satisﬁes Π A

.

An equivalent characterization of the stable model semantics is the loop formula approach [19]. Let Π be a program. The
(positive) dependency graph of Π , denoted by GΠ , is the ﬁnite graph (V , E), where V is the set of atoms occurring in Π ,
and (x, y) is an edge in E iff there exists a rule r ∈ Π whose head is x and its positive body contains y. A set of atoms L is
said to be a loop if there exists a cycle in GΠ that goes through only and all the nodes in L. Let x be a propositional atom.
If there exists a rule r ∈ Π such that its head is x, then we say that the body of r is a support of x in Π . Let L be a loop,
and x an atom in L. We say that a support Body of x in Π is an external support with respect to L if the positive part of
Body contains no atoms from L. Given a loop L, we use ES(L, Π) to denote the set of all external supports of some element
in L with respect to L in Π . Then, the loop formula of L in Π , denoted by LF(L, Π), is the following formula

(cid:3)

x →

(cid:3)

(cid:2)
Body.

x∈L

Body∈ES(L,Π )

Lin and Zhao [19] showed that, in the propositional case, a set of atoms is an answer set (stable model) of a ﬁnite program
if and only if it is a model of the Clark’s completion together with all loop formulas of the program.

2.3. The stable model semantics for ﬁrst-order programs

In Gelfond and Lifschitz’s seminal work [12], the stable model/answer set semantics for ﬁrst-order logic programs (i.e.
programs with variables) is deﬁned via grounding on Herbrand structures. Recently, there has been interest in deﬁning
the stable model semantics for ﬁrst-order programs directly on a ﬁrst-order level [2,3,10,20,25,27]. Such semantics usually
consider arbitrary structures instead of Herbrand structures. Nevertheless, for normal logic programs, all of them coincide
with Gelfond and Lifschitz’s original semantics [12] when only considering Herbrand structures [3,10,16,20,27].

We brieﬂy review the translational semantics [10] by deﬁning the stable model semantics of logic programs in second-

order logic. Under our context, we only consider normal ﬁrst-order logic programs.

Given a normal logic program Π , let ΩΠ = {Q 1, . . . , Q n} be the set of all intentional predicates of Π . Let Ω ∗
Π
∗
1 , . . . , Q

} be a new set of predicates corresponding to ΩΠ , where each Q

=
Π has the same arity of predicate

in Ω ∗

∗
n

∗
i

{Q
Q i in ΩΠ . Given a rule r in Π of the form

α ← β1, . . . , βm, not γ1, . . . , not γl,

by (cid:7)r, we denote the universal closure of the following formula

β1 ∧ · · · ∧ βm ∧ ¬γ1 ∧ · · · ∧ ¬γl → α;

∗

by r

, we denote the universal closure of the following formula

∗
∧ · · · ∧ β
m

∗
β
1
where α∗ = Q

∗((cid:7)x) if α = Q ((cid:7)x) and

∧ ¬γ1 ∧ · · · ∧ ¬γl → α∗

,

4

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

(cid:8)

β

∗
i , (1 (cid:2) i (cid:2) m) =

∗

j ((cid:7)t j)

Q
βi

if βi = Q j((cid:7)t j) and Q j ∈ ΩΠ ,
otherwise.

By (cid:7)Π , we denote the ﬁrst-order sentence
logic program. By SM(Π), we denote the following second-order sentence:

ˆr; by Π ∗

r∈Π

, we denote the ﬁrst-order sentence

(cid:9)

(cid:9)

r∈Π r

∗

. Let Π be a normal

(cid:7)Π ∧ ¬∃Ω

∗
Π

(cid:5)(cid:5)

Ω

∗
Π < ΩΠ

(cid:6)

(cid:6)

∗

,

∧ Π

where Ω ∗
Π < ΩΠ is the abbreviation of the formula
(cid:10)

(cid:10)

(cid:5)
∀(cid:7)x

Q

(cid:6)
∗
i ((cid:7)x) → Q i((cid:7)x)

∧ ¬

(cid:5)
∀(cid:7)x

Q i((cid:7)x) → Q

(cid:6)
∗
i ((cid:7)x)

.

1(cid:2)i(cid:2)n

1(cid:2)i(cid:2)n

This second-order sentence is used to capture the stable models of Π . We call this the translational semantics.

Here, for our purposes, we present an alternative characterization of this semantics by grounding. Similar to Gelfond and
Lifschitz’s grounding approach, we deﬁne the stable model semantics by grounding into the propositional case. However,
we consider grounding on arbitrary structures instead of Herbrand structures. It is worth mentioning that, on arbitrary
structures, the unique name assumption (i.e. distinct constants must be interpreted differently) does not necessarily hold.
Consequently, we will not assume it in our grounding procedure.

Deﬁnition 1. The grounding of a program Π on a structure M, written ΠM below, is the union of the following three sets:

1. The set of all instances of the rules in Π under M, here an instance of a rule under M is the result of simultaneously
replacing every constant in the rule by its interpretation in M, and every variable x in the rule by a domain object d
in M;

2. EQM = {u = u | u is a domain object in M}1;
3. ExtM = {P ((cid:7)u) | P is an extensional predicate and (cid:7)u ∈ P

M}, here P

M

is the interpretation of P in M.

We now have the following deﬁnition:

Deﬁnition 2. Let Π be a normal logic program and M a structure. We say that M is a stable model (or an answer set) of Π
if the following set

EQM ∪ ExtM ∪ IntM

is an answer set of ΠM in the propositional case, where IntM is the following set

(cid:11)

(cid:12)
(cid:12) P is an intensional predicate, and (cid:7)u ∈ P

M

(cid:13)

.

P ((cid:7)u)

Example 2. Consider the following program Π0

P (x) ← not Q (x),

P (a1),

Q (a2).

According to Gelfond and Lifschitz’s original stable model semantics [12], the unique stable model/answer set of Π0 is
X = {P (a1), Q (a2)}.

Now, let us reconsider the program Π0 under the new semantics (i.e. Deﬁnition 2). Notice that both P and Q are

intensional predicates. According to Deﬁnition 2, the following structure M0, where

M0 = {d1, d2},

M0 = d1,

a1

M0 = d2,

a2

M0 = {d1},

P

M0 = {d2}

Q

is a stable model of Π0. In fact, this structure M0 corresponds to the unique stable model X of Π0 under the original
semantics. Notice that, similar to classical ﬁrst-order logic, we distinguish from a1 and d1 here (also a2 and d2) because the
former is a constant in the language while the latter is a domain element.

However, under the new semantics, M0 is not the only stable model of Π0. The following structure M1, where

M1 = {d1},

M1 = d1,

a1

M1 = d1,

a2

M1 = Q

P

M1 = {d1}

1 Note that here u = u is a propositional atom but not an equality atom.

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

5

is also a stable model of Π0. Here, both a1 and a2 are mapped to the same domain element d1. This is allowed as the
unique name assumption (i.e. distinct constants must be interpreted to different domain elements) is not assumed in the
new semantics.

Also, the new semantics may allow new objects in the stable models. For instance, the following structure M2, where

M2 = {d1, d2, d3},

a2
is a stable model of Π0 as well. Notice that d3 ∈ P

M2 = d1,

M2 = d2,
M2 although d3 is not mapped from any constants in the program.

M2 = {d1, d3},

M2 = {d2}

a1

Q

P

In fact, this deﬁnition of stable model (answer set) is nothing new. The grounding technique in Deﬁnition 1 is basically
the same as the standard one in [12] except that here it is done on an arbitrary structure instead of the Herbrand structure.
The only reason we propose this alternative deﬁnition is that it is more suitable for understanding the proof of our main
theorem (see Theorem 2). Also, the following theorem shows that this semantics by grounding on arbitrary structures
actually coincides with the translational semantics mentioned previously in this section.

Theorem 1. Let Π be a normal logic program whose signature is σ , and A a ﬁnite σ -structure. Then, A is a stable model of Π (under
Deﬁnition 2) iff A is a model of SM(Π).

Proof. For convenience, we use Gr(A) to denote EQ A ∪ ExtA ∪ IntA. First, Gr(A) satisﬁes ΠA iff Gr(A) satisﬁes all instances
of the rules in Π under A iff Gr(A) satisﬁes every rη, where r ∈ Π and η is an assignment iff A satisﬁes (cid:7)r for all r ∈ Π iff
A |(cid:20) (cid:7)Π .

Second, we show that A |(cid:20) ¬∃Ω ∗
Π ((Ω ∗

We have A |(cid:20) ∃Ω ∗
constants and extensional predicates the same as A, but

Π < ΩΠ ) ∧ Π ∗) iff there exists a structure A(cid:16)

Π ((Ω ∗

Π < ΩΠ ) ∧ Π ∗) iff there does not exist X ⊂ Gr(A) such that X satisﬁes ΠAGr(A).
has the same domain as A, interprets all

such that A(cid:16)

A(cid:16) ⊆ Q
• for all intensional predicates Q of Π , Q
, and for some intensional predicates Q , Q
• for every assignment η and every rule r of form (1) in Π , if for all i (1 (cid:2) i (cid:2) k), βiη ∈ A(cid:16)

A

A

A(cid:16) ⊂ Q
and for all

;

γ jη /∈ A, then αη ∈ A(cid:16)

j (1 (cid:2) j (cid:2) l),

iff there exists X ⊂ Gr( A) satisfying (rη)Gr(A) for every pair r, η, where r ∈ Π and η is an assignment (let X = EQ A ∪ ExtA ∪
IntA(cid:16) ) iff there exists X ⊂ Gr( A) satisfying ΠAGr(A).
This shows that the original assertion holds. (cid:2)

As a consequence of the above theorem and Theorem 1 in [10], Deﬁnition 2 basically coincides with Gelfond and Lifs-
chitz’s original semantics on Herbrand structures. The main difference is that we consider not only Herbrand structures but
also arbitrary ones. For the latter, we do not need the unique name assumption (see Example 2).

Notice that the above deﬁnitions can be applied to inﬁnite structures as well since the stable model (answer set) se-
mantics for inﬁnite propositional programs is well deﬁned by using Gelfond–Lifschitz transformation [12]. However, in this
paper, we are mainly concerned with ﬁnite structures unless stated otherwise (particularly in Section 3.5).

3. The ordered completion

It is well known that Clark’s completion does not fully capture the answer set semantics because of positive cycles. As a

simple example, the following program

p ← q
q ← p

has one answer set ∅, but its Clark’s completion p ↔ q has two models {p, q} and ∅. Here, we propose a modiﬁcation of
Clark’s completion to address this issue. The main technical property of our new translation is that for each ﬁnite ﬁrst-
order logic program, our translation yields a ﬁnite ﬁrst-order theory that captures exactly the ﬁnite stable models of the
program. The ideas behind such translation can be best illustrated by simple propositional programs. Consider the program
mentioned above. We introduce four auxiliary symbols T pq, T pp, Tqq, Tqp (read, e.g. T pq as from p to q), and translate this
program into the following theory

(p → q) ∧ (q → p),
p → (q ∧ T qp ∧ ¬T pq),
q → (p ∧ T pq ∧ ¬T qp),
T pq ∧ T qp → T pp,
T qp ∧ T pq → T qq.

6

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

The ﬁrst sentence is the direct encoding of the two rules. The second one is similar to the other side of Clark’s completion
for p except that we add T qp and ¬T pq: for p to be true, q must be true and it must be the case that q is used to derive p
but not the other way around. The third sentence is similar, and the last two sentences are about the transitivity of the T
atoms. It can be checked that in all models of the above sentences, both p and q must be false.

3.1. Deﬁnition of the ordered completion

In general, let Π be a ﬁrst-order normal logic program, and ΩΠ its set of intensional predicates. For each pair of
predicates (P , Q ) ( P and Q might be the same) in ΩΠ , we introduce a new predicate (cid:2)PQ , called the comparison predicate,
whose arity is the sum of the arities of P and Q . The intuitive meaning of (cid:2)PQ ((cid:7)x, (cid:7)y), read as from P ((cid:7)x) to Q ((cid:7)y), is that
P ((cid:7)x) is used for deriving Q ((cid:7)y). In the following, we use inﬁx notation for (cid:2)PQ and write (cid:2)PQ ((cid:7)x, (cid:7)y) as (cid:7)x (cid:2)PQ (cid:7)y.

Deﬁnition 3 (Ordered completion). Let Π be a normal logic program. The ordered completion of Π , denoted by OC(Π), is the
set of following sentences:

• For each intensional predicate P , the following sentences:

(cid:2) (cid:3)

∀(cid:7)x

(cid:4)

∃(cid:7)yi

(cid:2)
Bodyi

→ P ((cid:7)x)

,

(3)

1(cid:2)i(cid:2)k

(cid:2)

∀(cid:7)x

P ((cid:7)x) →

(cid:2)

∃(cid:7)yi

(cid:2)
Bodyi

∧

(cid:3)

1(cid:2)i(cid:2)k

(cid:10)

(cid:4)(cid:4)

(cid:7)z (cid:2)QP (cid:7)x ∧ ¬(cid:7)x (cid:2)PQ (cid:7)z

,

Q ((cid:7)z)∈Posi ,Q ∈ΩΠ

where we have borrowed the notations used in the deﬁnition of Clark’s completion, and further assume that Posi is the
positive part of Bodyi and Q ((cid:7)z) ranges over all the intensional atoms in the positive part of Bodyi ;

• For each triple of intensional predicates P , Q , and R (two or all of them might be the same) the following sentence:

(cid:10)

P ,Q ,R∈ΩΠ

∀(cid:7)x(cid:7)y(cid:7)z((cid:7)x (cid:2)PQ (cid:7)y ∧ (cid:7)y (cid:2)Q R (cid:7)z → (cid:7)x (cid:2)P R (cid:7)z).

(4)

In the following, we use MComp(Π) to denote the set of the formulas (3) and (4), and TranS(Π) the set of formulas (4).

So OC(Π) = MComp(Π) ∪ TranS(Π).

Clearly, for ﬁnite programs, OC(Π) is ﬁnite, and the predicates occurring in OC(Π) are all the predicates occurring in Π

together with all the comparison predicates {(cid:2)PQ | P , Q ∈ ΩΠ }.

Notice that the Clark’s completion of a predicate can be rewritten as two parts:

(cid:2) (cid:3)

∀(cid:7)x

(cid:4)

∃(cid:7)yi

(cid:2)
Bodyi

→ P ((cid:7)x)

,

1(cid:2)i(cid:2)k

(cid:2)

∀(cid:7)x

P ((cid:7)x) →

(cid:4)

∃(cid:7)yi

(cid:2)
Bodyi

.

(cid:3)

1(cid:2)i(cid:2)k

Thus, the only difference between MComp(Π) and Comp(Π) is that the former introduces some assertions on the compar-
ison predicates, which intuitively mean that there exist derivation paths from the intensional atoms in the body to head
but not the other way around (see Eq. (4)). In addition, TranS(Π) simply means that the comparison predicates satisfy
“transitivity”.

Proposition 1. Let Π be a normal logic program. Then, OC(Π) introduces m2 new predicates whose arities are no more than 2s, and
the size of OC(Π) is O (s × m3 + s × n), where m is the number of intensional predicates of Π , s the maximal arity of the intensional
predicates of Π and n the length of Π .

Example 3 (Transitive Closure continued). Recall the Transitive Closure program TC presented in Example 1. In this case, since
the only intensional predicate is S, we only need to introduce one additional predicate (cid:2)S S , whose arity is 4. The ordered
completion of TC consists of the following sentences:

(cid:5)(cid:5)

(cid:5)

(cid:5)

E(x, y) ∨ ∃z
(cid:5)
S(x, y) →

∀xy
∀xy
∀xyuv zw(

−→
xy (cid:2)S S

E(x, z) ∧ S(z, y)

(cid:5)

(cid:6)(cid:6)

(cid:6)
→ S(x, y)

,
E(x, z) ∧ S(z, y) ∧ −→
zy (cid:2)S S
−−→
zw).

zw → −→
−−→

xy (cid:2)S S

E(x, y) ∨ ∃z
uv ∧ −→
−→

uv (cid:2)S S

xy ∧ ¬−→
−→

xy (cid:2)S S

(cid:6)(cid:6)(cid:6)

−→
zy

,

(5)

(6)

(7)

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

7

Fig. 1. An example graph.

−→
uv to mean that S(x, y) is used to establish S(u, v). So the sentence (6) means that
Intuitively, one can understand
for S(x, y) to be true, either E(x, y) (the base case), or inductively, for some z, E(x, z) is true and S(z, y) is used to establish
S(x, y) but not the other way around.

−→
xy (cid:2)S S

To see how these axioms work, consider the graph in Fig. 1 with four vertices a, b, c, d, with E representing the edge
relation: E(a, b), E(b, a), E(c, a), E(c, d). Clearly, if there is a path from x to y, then S(x, y) (by sentence (5)). We want to
show that if there is no path from x to y, then ¬S(x, y). Consider S(d, a). If it is true, then since ¬E(d, a), there must be
an x such that

E(d, x) ∧ S(x, a) ∧ −→

−→
da (cid:2)S S
This is false as there is no edge going out of d.

−→
da ∧ ¬

xa (cid:2)S S

−→
xa.

Now consider S(a, c). If it is true, then there must be an z such that
ac ∧ ¬−→
−→

E(a, z) ∧ S(z, c) ∧ −→

−→
zc.

ac (cid:2)S S

zc (cid:2)S S

So z must be b, and

S(b, c) ∧

−→
bc (cid:2)S S

ac ∧ ¬−→
−→

ac (cid:2)S S

−→
bc.

(8)

Since S(b, c) is true and there is no edge from b to c, there must be a y such that
−→
bc (cid:2)S S

E(b, y) ∧ S( y, c) ∧ −→

−→
bc ∧ ¬

yc (cid:2)S S

−→
yc.

So y must be a, and

S(a, c) ∧ −→

ac (cid:2)S S

−→
bc ∧ ¬

−→
bc (cid:2)S S

−→
ac.

However, this contradicts with (8).

Notice that the Clark’s completion of TC, i.e. ∀xy(S(x, y) ↔ (E(x, y) ∨ ∃zE(x, z) ∧ S(z, y))) (see Example 1), does not

assure that S is the transitive closure of the edge relation. For instance, for the above, the following interpretation on S

S(a, b), S(b, a), S(a, c), S(c, a), S(b, c), S(c, b), S(a, d), S(b, d), S(c, d)

satisﬁes the Clark’s completion of TC. However, there is no path from, e.g. a to c, in the graph shown in Fig. 1.

3.2. The main theorem

In order to introduce the main theorem, we ﬁrst consider a notion called derivation order, which is a reformulation of
Fages’ “well-supportedness” under our context [7]. Roughly speaking, a derivation order is a sequence of ground atoms, in
which the anterior ones are used to derive the posterior ones.

Formally, a derivation order of a ﬁnite structure A on a program Π is a sequence of ground atoms P 1((cid:7)a1), . . . , P k((cid:7)ak)
such that {P 1((cid:7)a1), . . . , P k((cid:7)ak)} = IntA (see Deﬁnition 2), and for all i (1 (cid:2) i (cid:2) k), there exists a rule r ∈ Π and an assignment
η such that

• Head(r)η = P i((cid:7)ai),
• for all intensional atoms Q ((cid:7)t) in Pos(r), Q ((cid:7)t)η ∈ {P 1((cid:7)a1), . . . , P i−1(
• for all intensional atoms Q ((cid:7)t) in Neg(r), Q ((cid:7)t)η /∈ IntA,
• for all extensional atoms Q ((cid:7)t) in Pos(r) (Neg(r) resp.), Q ((cid:7)t)η ∈ ExtA ( Q ((cid:7)t)η /∈ ExtA resp.).

−−−→
ai−1)},

Example 4. Consider the following program Π1

p1 ← p2,
p2 ← p1,
p1 ← not p3.

8

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

Clearly, X = {p1, p2} is an answer set of Π1. According to the deﬁnition, p1, p2 is a derivation order of X on Π1 but p2, p1
is not. This is because p1 is used to derive p2 but not the other way around.

We show that derivation orders and answer sets are corresponded.

Lemma 2. Let Π be a normal logic program whose signature is σ , and A a ﬁnite σ -structure. Then, A is an answer set of Π iff

(i) A |(cid:20) (cid:7)Π ;
(ii) there exists a (possibly many) derivation order of A on Π .

Proof. According to the grounding deﬁnition (see Deﬁnition 1), it suﬃces to prove this assertion in the propositional case.
On one hand, consider a ﬁnite propositional program Π and a set A of atoms. If A is an answer set of Π , then A
satisﬁes Π according to the Gelfond–Lifschitz transformation semantics. In addition, we construct a sequence of atoms
{p1, p2, . . . , pk} ⊆ A as follows:

• for any i (1 (cid:2) i (cid:2) k), there exists a rule r in Π such that Head(r) = pi , Pos(r) ⊆ {p1, . . . , pi−1} and Neg(r) ∩ A = ∅,
• there does not exist r in Π such that Pos(r) ⊆ {p1, . . . , pk}, Neg(r) ∩ A = ∅ and Head(r) /∈ {p1, . . . , pk}.

Then, {p1, p2, . . . , pk} = A. Otherwise, {p1, p2, . . . , pk} |(cid:20) Π A
pk} is a derivation order of A on Π .

but {p1, p2, . . . , pk} ⊂ A, a contradiction. Hence, {p1, p2, . . . ,

On the other hand, suppose that A |(cid:20) (cid:7)Π and there exists a derivation order of A on Π . To prove that A is an answer set
. Otherwise, let p be the atom in A\A(cid:16)
of Π , it suﬃces to show that there does not exist A(cid:16) ⊂ A such that A(cid:16)
with the least ordinal in the derivation order. Then, according to the deﬁnition, there exists a rule r such that Head(r) = p,
Pos(r) ⊆ A(cid:16)
(since p has the least ordinal in the derivation order) and Neg(r) ∩ A = ∅. Therefore, Neg(r) ∩ A(cid:16) = ∅. It follows
that A(cid:16) |(cid:20) Pos(r) but A(cid:16) (cid:3)|(cid:20) Head(r). Hence, A(cid:16)

, a contradiction. (cid:2)

satisﬁes Π A

does not satisfy r

A

Now we are able to present the following main theorem.

Theorem 2. Let Π be a normal logic program whose signature is σ , and A a ﬁnite σ -structure. Then, A is an answer set of Π if and
only if there exists a model M of OC(Π) such that A is the reduct of M on σ .

Proof. On one hand, we show that every ﬁnite answer set A of Π can be expanded to a model of OC(Π). By Lemma 2,
there exists a derivation order of A on Π . Then, based on it, we construct a ﬁnite structure M by expanding A with the
following interpretations on (cid:2)PQ for each pair (P , Q ) of intensional predicates in Π :

(cid:7)b iff there exists a path from Q ((cid:7)b) to P ((cid:7)a) in the dependency graph of the ground program ΠA and the position

(cid:7)a (cid:2)PQ
of P ((cid:7)a) is before the position of Q ((cid:7)b) in the derivation order,

where (cid:7)a and (cid:7)b are two tuples of elements in the domain of A that match the arities of P and Q respectively. In this case,
we say that there is a derivation path from P ((cid:7)a) to Q ((cid:7)b) (with respect to the derivation order).

We need to prove that M is a model of both TranS(Π) and MComp(Π). Firstly, it is easy to see that M is a model of
TranS(Π) by contradiction. Secondly, we show that M is a model of MComp(Π) as well. Clearly, M is a model of the ﬁrst
part of MComp(Π), i.e. Eq. (3) since M is expanded from A, a model of the Clark’s completion of Π . For the second part
of MComp(Π), i.e. Eq. (4), we prove it by contradiction. Suppose that M is not a model of Eq. (4). Then,

M |(cid:20)

(cid:3)

P ∈ΩΠ

(cid:2)

∃(cid:7)x

P ((cid:7)x) ∧

(cid:10)

1(cid:2)i(cid:2)k

(cid:2)

∀(cid:7)yi

(cid:2)
Bodyi

→

(cid:3)

Q ((cid:7)z)∈Posi ∩ΩΠ

(cid:4)(cid:4)

¬(cid:7)z (cid:2)QP (cid:7)x ∨ (cid:7)x (cid:2)PQ (cid:7)z

.

Therefore, there exists P ((cid:7)a) ∈ M such that for all assignments η and all rules r whose head mentions P , if M |(cid:20) (cid:3)
then there exists an intensional atom Q ((cid:7)z) in the positive body of r such that M |(cid:20) ¬(cid:7)z (cid:2)QP (cid:7)xη or M |(cid:20) (cid:7)x (cid:2)PQ (cid:7)zη.

Now, consider the position of P ((cid:7)a) in the derivation order. There exists a rule r and an assignment η satisfying the
conditions mentioned above. Hence, according to the conditions, for all intensional atom Q ((cid:7)t) in the positive body of r,
we have that the ordinal of Q ((cid:7)t)η in the derivation order is less than the ordinal of P ((cid:7)a) in the derivation order. Hence,
M |(cid:20) (cid:7)t (cid:2)QP (cid:7)xη and M (cid:3)|(cid:20) (cid:7)x (cid:2)PQ

(cid:7)tη, a contradiction.

This shows that M, expanded from A, is a model of OC(Π).
On the other hand, we prove that the reduct of any ﬁnite model M of OC(Π) on σ must be an answer set of Π . Clearly,
M ↑ σ is a model of Comp(Π) since MComp(Π) |(cid:20) Comp(Π). Hence, according to the loop formula characterization of
answer set semantics in the propositional case [19], it suﬃces to show that for all loops L of the ground program ΠM↑σ ,
the set of ground atoms EQM↑σ ∪ ExtM↑σ ∪ IntM↑σ is a model of its loop formula.

Body(r)η,

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

9

We prove this by contradiction. Suppose that there exists a loop L of the ground program ΠM↑σ such that the above
set of ground atoms is not a model of LF(L, ΠM↑σ ). Then, there exists a ground atom P 0((cid:7)a0) ∈ L and P 0((cid:7)a0) ∈ IntM↑σ , and
for every Q ((cid:7)b) ∈ L, Q ((cid:7)b) has no external support with respect to L in the ground program ΠM↑σ .

Since M is a model of MComp(Π), there exists a support Body0 of P 0((cid:7)a0) in the ground program ΠM↑σ such that for
all ground atoms Q ((cid:7)b) in the positive body of Body0, (cid:7)b (cid:2)Q P 0
(cid:7)b holds, where Q is an intensional predicate
of Π and (cid:7)b a tuple of elements in M that matches the arity of Q . If every Q ((cid:7)b) is not in L, then Body0 is an external
support of P 0((cid:7)a0) with respect to L, a contradiction. Hence, there exists P 1((cid:7)a1) in the positive body of Body0 such that
P 1((cid:7)a1) ∈ IntM↑σ , P 1((cid:7)a1) ∈ L and (cid:7)a1 (cid:2)P 1 P 0
(cid:7)a1 holds.
Again, following the same procedure described above, there exists a support Body1 of P 1((cid:7)a1), and a ground atom P 2((cid:7)a2)
in the positive body of Body1 such that P 2((cid:7)a2) ∈ IntM↑σ , P 2((cid:7)a2) ∈ L and (cid:7)a2 (cid:2)P 2 P 1
(cid:7)a2 holds. Hence, we can
get a sequence of ground atoms P 0((cid:7)a0), P 1((cid:7)a1), . . . , P i((cid:7)ai), . . . such that for all i, P i((cid:7)ai) ∈ IntM↑σ , P i((cid:7)ai) ∈ L. In addition,
both

(cid:7)a1 ∧ ¬(cid:7)a1 (cid:2)P 1 P 2

(cid:7)a0 ∧ ¬(cid:7)a0 (cid:2)P 0 P 1

(cid:7)a0 ∧ ¬(cid:7)a0 (cid:2)P 0 Q

Next, we show that this sequence cannot be inﬁnite due to the ﬁniteness of the structure M and the fact that the
new comparison predicates satisfy transitivity. Since M is ﬁnite, there exists k < l such that P k((cid:7)ak) = Pl((cid:7)al) in the above se-
−−−→
(cid:7)ai holds, we have that (cid:7)al (cid:2)Pl Pk+1
quence. However, since for all i,
ak+1 holds as well according to the transitivity
ak+1 holds since P k((cid:7)ak) = Pl((cid:7)al). This contradicts to the fact that ¬−−−→
−−−→
axioms. Hence, (cid:7)ak (cid:2)Pk Pk+1
ak+1 (cid:2)Pk+1 Pk

−−−→
ai+1 (cid:2)P i+1 P i

(cid:7)ak holds.

(cid:7)ai and ¬(cid:7)ai (cid:2)P i P i+1

−−−→
ai+1 (cid:2)P i+1 P i

−−−→
ai+1 hold.

This shows that M ↑ σ is an answer set of Π . (cid:2)

From the proof of the main theorem, we see that the basic idea of the ordered completion is really that each atom in
an answer set of a ﬁnite program must be justiﬁed step-by-step. In this sense, a ﬁnite structure A is an answer set of a
program Π iff it is a model of Π and satisﬁes the following conditions:

downgrading every ground atom P ((cid:7)a) in A has some supports from earlier stages. The “support” part is ensured by Clark’s
completion, and the “earlier stages” part is ensured by adding some assertions on the comparison predicates (see
Eq. (4));

loop-free the above downgrading procedure does not contain a loop. This is ensured by TranS(Π), which states that the

comparison predicates satisfy transitivity;

well-foundedness the downgrading procedure will end at some step. This is ensured by ﬁniteness, i.e., only ﬁnite structures

are taken into account.

Together with the above three conditions, each ground atom P ((cid:7)a) in a ﬁnite answer set A can be justiﬁed step-by-step, in
which the track of justifying this atom is captured by the comparison predicates.

3.3. Normal logic program with constraints

Recall that we have required the head of a rule to be a proper atom. If we allow the head to be empty, then we have

so-called constraints:

← β1, . . . , βk, not γ1, . . . , not γl,

(9)

where βi (1 (cid:2) i (cid:2) k) and γ j (1 (cid:2) j (cid:2) l) are atoms. A model is said to satisfy the above constraint if it satisﬁes the corre-
sponding sentence:

∀(cid:7)y¬(β1 ∧ · · · ∧ βk ∧ ¬γ1 ∧ · · · ∧ ¬γl),

where (cid:7)y is the tuple of all variables occurring in (9). In the following, if c is a constraint of form (9), then we use ˆc to
denote its corresponding formula above.

A normal logic program with constraints is then a ﬁnite set of rules and constraints. The stable model (answer set) se-
mantics can be extended to normal logic programs with constraints: a model is an answer set of a program with constraints
if it is an answer set of the set of the program and satisﬁes all the constraints.

Both Clark’s completion and our ordered completion can be extended to normal logic programs with constraints: one

simply adds the sentences corresponding to the constraints to the respective completions.

Proposition 3. Let Π be a normal logic program whose signature is σ , C a set of constraints, and A a ﬁnite σ -structure. Then, A is
an answer set of Π ∪ C iff there exists a model M of OC(Π) ∪ {ˆc | c ∈ C}, such that A is the reduct of M on σ .

Proof. A is an answer set of Π ∪ C iff A is an answer set of Π and A is a model of {ˆc | c ∈ C} iff there exists M, which is a
model of both OC(Π) and {ˆc | c ∈ C} and whose reduct on σ is A iff there exists M, which is a model of OC(Π) ∪ {ˆc | c ∈ C}
such that A is the reduct of M on σ . (cid:2)

10

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

Example 5. The following program checks whether all the nodes of a given graph can be reached from a given initial node.

R(a)
R(x) ← R( y), E( y, x)
← not R(x),

where E is the only extensional predicate representing the edges of the graph; a is a constant representing the initial node;
and R is the only intensional predicate representing whether a node can be reached from a. The program has a stable
model iff all the nodes in the graph can be reached from a. According to Proposition 3, this program can be captured by
the following sentence:

R(a) ∧ ∀xy

(cid:5)

(cid:6)
E( y, x) ∧ R( y) → R(x)
(cid:5)

R(x) → x = a ∨ ∃ y

(cid:5)
∧ ∀x
∧ ∀xyz(x (cid:2)R R y ∧ y (cid:2)R R z → x (cid:2)R R z)
∧ ∀xR(x).

R( y) ∧ E( y, x) ∧ y (cid:2)R R x ∧ ¬x (cid:2)R R y

(cid:6)(cid:6)

3.4. Adding choice rules

Another widely used extension of normal logic program is to allow choice rules of the following form:

(cid:11)

(cid:13)
P ((cid:7)x)

,

(10)
where P is a predicate and (cid:7)x is the tuple of variables associated with P . Intuitively, this choice rule of P means that the
intensional predicate P can be interpreted arbitrarily in the stable models.

The stable model (answer set) semantics of normal logic programs with choice rules (possibly with constraints as well)
can be deﬁned similarly by grounding. More precisely, the set of ground rules of a choice rule of form (10) on a structure
M contains all rules of the form:

(cid:11)

(cid:13)
P ((cid:7)u)

,

where (cid:7)u is a tuple of domain elements in M that matches the arity of P . The set of ground constraints of a constraint of
form (9) on a structure M contains all the instances of the constraint under M.

The answer set semantics for propositional programs with choice rules and constraints can be deﬁned by Gelfond–
Lifschitz transformation as well [22]. Let p be a propositional atom and A a set of atoms. The reduct of the choice rule {p}
relative to A is p itself if p ∈ A, and empty (i.e. (cid:21)) otherwise. Again, a set A of propositional atoms is said to be an answer
set of a propositional program Π with choice rules and constraints if A |(cid:20) Π 2 and A is the minimal model of Π A

Then, a structure A is said to be a stable model of a ﬁrst-order normal program Π with choice rules and constraints if

.

EQ A ∪ ExtA ∪ IntA is an answer set of the ground program ΠA in the propositional case.

The following proposition shows that programs with choice rules can also be captured by their ordered completions.

Proposition 4. Let Π be a normal logic program whose signature is σ , Ω ⊆ σ a set of predicates in σ , C a set of constraints, Choice(Ω)
the set of choice rules for every predicate in Ω , and A a ﬁnite σ -structure. Then, A is an answer set of Π ∪ C ∪ Choice(Ω) iff there
exists a model M of the following set of sentences such that A is the reduct of M on σ :

• For each intensional predicate P , the following sentence:

(cid:2) (cid:3)

∀(cid:7)x

1(cid:2)i(cid:2)k

(cid:4)

∃(cid:7)yi

(cid:2)
Bodyi

→ P ((cid:7)x)

.

• For each intensional predicate P not in Ω , the following sentence:
(cid:2)

(cid:2)

(cid:3)

∀(cid:7)x

P ((cid:7)x) →

∃(cid:7)yi

(cid:2)
Bodyi

∧

(cid:10)

(cid:4)(cid:4)

((cid:7)z (cid:2)QP (cid:7)x ∧ ¬(cid:7)x (cid:2)PQ (cid:7)z)

.

1(cid:2)i(cid:2)k

Q ((cid:7)z)∈Posi ,Q ∈ΩΠ \Ω

• For each triple of intensional predicates P , Q , and R not in Ω , the following sentence:

(cid:10)

∀(cid:7)x(cid:7)y(cid:7)z((cid:7)x (cid:2)PQ (cid:7)y ∧ (cid:7)y (cid:2)Q R (cid:7)z → (cid:7)x (cid:2)P R (cid:7)z).

P ,Q ,R∈ΩΠ \Ω

• Finally, for each c ∈ C , the sentence ˆc.

2 Firstly, this means that A satisﬁes all constraints. Secondly, A is regarded as a model of every choice rule.

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

11

Proof. This assertion follows directly from Proposition 3 and the following fact: the answer sets of Π ∪ C ∪ Choice(Ω) are
exactly the same as the answer sets of Π ∗ ∪ C , where Π ∗
is the program obtained from Π by rewriting each rule of
form (1), whose head mentions predicates from Ω , to the following constraint

← β1, . . . , βk, not γ1, . . . , not γl, not α.

(cid:2)

Example 6. Consider the following normal program with constraints and choice rules for computing all Hamiltonian circuits
of a graph:

(cid:11)
(cid:13)
hc(x, y)
← hc(x, y), not E(x, y)
← hc(x, y), hc(x, z), y (cid:3)= z
← hc( y, x), hc(z, x), y (cid:3)= z

R(x) ← hc(a, x)
R(x) ← R( y), hc( y, x)
← not R(x),

where E is the only extensional predicate representing the edges of the graph; a is a constant representing a particular
node in the Hamiltonian circuit; hc(x, y) is an intensional predicate representing the Hamiltonian circuit; and R(x) is an
intensional predicate to check that all vertices are in the Hamiltonian circuit. In particular, the ﬁrst rule of the program is a
choice rule to guess a possible Hamiltonian circuit.

According to Proposition 4, this program can be captured by the following sentence:

(cid:5)
(cid:6)
hc( y, x) ∧ R( y) → R(x)

R( y) ∧ hc( y, x) ∧ y (cid:2)R R x ∧ ¬x (cid:2)R R y

(cid:6)(cid:6)

∧ ∀xy
(cid:5)

(cid:5)
(cid:6)
hc(a, x) → R(x)
∀x
(cid:5)
R(x) → hc(a, x) ∨ ∃ y
∧ ∀x
∧ ∀xyz(x (cid:2)R R y ∧ y (cid:2)R R z → x (cid:2)R R z)
(cid:6)
(cid:5)
∧ ∀xy¬
hc(x, y) ∧ ¬E(x, y)
(cid:5)
hc(x, y) ∧ hc(x, z) ∧ y (cid:3)= z
∧ ∀xyz¬
(cid:5)
∧ ∀xyz¬
hc( y, x) ∧ hc(z, x) ∧ y (cid:3)= z
∧ ∀xR(x).

(cid:6)

(cid:6)

3.5. Arbitrary structures

It is worth mentioning that the correspondence between classical ﬁrst-order models of ordered completions and stable
models of a logic program holds only on ﬁnite structures. In general, the result does not hold if inﬁnite structures are
allowed. For instance, the ordered completion of Transitive Closure (TC) in Example 3 on ﬁnite structures does not capture
TC on some inﬁnite structures.

Example 7 (Transitive Closure continued). Consider the graph that contains an inﬁnite chain and an individual vertex. Let
a1, a2, . . . be an inﬁnite chain such that E(aiai+1) for all i, and b a node different from all ai . Consider the structure M of
the signature {E, S, (cid:2)S S } such that

• S(ai, a j) for all i < j;
• S(ai, b) for all i;
• −−→
aia j (cid:2)S S
−→
aib (cid:2)S S
•

−−→
akal for all j − i (cid:2) l − k, where i < j and k < l;
−−→
a jb for all i < j.

It can be checked that M is a model of the ordered completion of TC (see Example 3). However, clearly, S is not the
transitive closure of the graph given in this example.

It still remains the question whether or not Transitive Closure can be captured by other ﬁrst-order theories (even inﬁnite)

with auxiliary predicates. Unfortunately, the answer is negative either.

Proposition 5. There does not exist a ﬁrst-order theory whose signature contains the signature of TC, and the reducts of all its models
are exactly corresponding to the stable models of TC on arbitrary structures.

12

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

Proof. We prove this assertion by contradiction. Let σ be the signature of TC. We assume that φ is a ﬁrst-order theory,
whose vocabulary is σ1 such that σ ⊆ σ1, and the reducts of the models of φ on σ are exactly the stable models of TC.
It is well known that TC can be deﬁned by a universal second-order theory [5]. Therefore, the complement of TC can be
deﬁned by an existential second-order theory. Hence, there exists a ﬁrst-order theory whose signature contains σ , and the
reducts of all its models on σ are exactly the complement of the class of stable models of TC on arbitrary structures. Let ψ
be such as a theory of signature σ2. Without loss of generality, we can assume that σ1 ∩ σ2 = σ . Then, φ |(cid:20) ¬ψ in the ﬁrst-
order language σ1 ∪ σ2. Thus, according to Craig’s Interpolation Theorem, there exists a theory φ0 of the signature σ1 ∩ σ2
(namely σ ) such that φ |(cid:20) φ0 and φ0 |(cid:20) ¬ψ . This shows that TC is exactly captured by the theory φ0, whose signature is σ .
This contradicts to the well-known result that TC is not ﬁrst-order deﬁnable on arbitrary structures [5]. (cid:2)

3.6. Disjunctive logic programs

Disjunctive logic programs is a very important extension of normal programs for dealing with incomplete information

[6,13]. A disjunctive logic program is a ﬁnite set of disjunctive rules of the following form

α1; . . . ; αn ← β1, . . . , βk, not γ1, . . . , not γl.

(11)

Similar to normal programs, we can distinguish intensional and extensional predicates here. The answer set semantics for
disjunctive logic programs can be deﬁned similarly by grounding [6,13].

A natural question arises as whether the ordered completion can be extended to ﬁrst-order disjunctive programs. Un-
fortunately, the answer is negative provided some well-recognized assumptions in the computational complexity theory
are true. Actually, our following proposition shows a stronger result that there exist disjunctive programs that cannot be
captured by any ﬁrst-order sentences with a larger signature.

Proposition 6. There exists a disjunctive program Π such that it cannot be captured by any ﬁrst-order sentence with the same or a
larger signature unless NP = coNP. That is, there is no ﬁrst-order sentence φ whose signature contains the signature of Π , and the
reducts of all its ﬁnite models are exactly the ﬁnite stable models of Π .

Proof. We show that the following program 3-UNCOLOR (originated from Example 2 in [6]) cannot be captured by any
ﬁrst-order sentences on ﬁnite structures if NP (cid:3)= coNP:

R(x); G(x); B(x) ← ,

NC ← E(x, y), R(x), R( y),

NC ← E(x, y), G(x), G( y),

NC ← E(x, y), B(x), B( y),

R(x) ← NC,

G(x) ← NC,

B(x) ← NC,

NC ← not NC,

where E is the only extensional predicate to represent a graph; R, G and B are three different colors respectively, and NC
is a 0-ary predicate to claim that this graph cannot be colored. It is not diﬃcult to check that the program has answer sets
iff the graph, represented by E, cannot be colored by the three colors. In addition, in this case, there is a unique answer set
that contains the given graph, NC and the full interpretation for R, G and B.

Assuming that NP (cid:3)= coNP, no coNP complete problem is in NP. Hence, the problem of 3-uncolorability (a well-known
coNP complete problem) is not in NP. By Fagin’s theorem [9], the Boolean query of 3-uncolorability for a given graph cannot
be deﬁned by an existential second-order sentence. On the other hand, assume that there exists a ﬁrst-order sentence φ
whose signature contains the signature of 3-UNCOLOR, and the reducts of all its ﬁnite models are exactly corresponding
to the ﬁnite stable models of 3-UNCOLOR. Then, the Boolean query of 3-uncolorability can be deﬁned by the following
existential second-order sentence

∃Pφ,

where P is a set of predicates including NC, R, G, B and all the other predicates in φ but not in 3-UNCOLOR, a contradiction.
This shows that 3-UNCOLOR cannot be captured by any ﬁrst-order sentences with a larger signature. (cid:2)

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

13

Following from the proof of Proposition 6 and Theorem 2, another negative result is that, most likely, ﬁrst-order disjunc-

tive logic programs cannot be reduced to normal programs on ﬁnite structures, even with new predicates.

Corollary 7. Unless NP (cid:3)= coNP, there is no normal program whose signature contains the signature of 3-UNCOLOR, and the reducts of
all its ﬁnite stable models are exactly corresponding to the ﬁnite stable models of 3-UNCOLOR.

Proof. Otherwise, according to Theorem 2, the program 3-UNCOLOR can be captured by a ﬁrst-order sentence with a larger
signature. (cid:2)

In fact, the above two results coincide with the result presented in [6], stating that in terms of brave reasoning, disjunc-
2 , while normal programs only

tive logic programs with the stable model semantics exactly capture the complexity class Σ P
capture NP.

4. Optimizations

In this section, we present several techniques to optimize ordered completion introduced in Section 3. The goal of these
techniques is for simplifying the translation, including reducing the number of new predicates, the arities of new predicates
and the overall length of the ordered completion. As we will see, the techniques presented below can be combined together.
For the sake of clarity, we will introduce them step-by-step.

4.1. Exploiting maximal predicate loops

In the deﬁnition of our ordered completion, we introduce a comparison predicate between each pair of predicates. This
is not necessary. We only need to do so for pairs of predicates that belong to the same strongly connected component in
the predicate dependency graph of the program.

Formally, the predicate dependency graph of a ﬁrst-order program Π is a ﬁnite graph PGΠ = (cid:22)V , E(cid:23), where V is the set of
all intensional predicates of Π and (P , Q ) ∈ E iff there is a rule whose head mentions P and whose positive body contains
Q . Maximal predicate loops of the program Π are then strongly connected components of PGΠ . Since PGΠ can be constructed
easily, all the maximal predicate loops of Π can be identiﬁed in polynomial time with respect to the size of Π .

The ordered completions on maximal predicate loops are the same as the ordered completions except that the com-
parison predicates (cid:2)PQ are deﬁned only when P and Q belong to the same maximal predicate loop. More precisely, the
ordered completion of Π on maximal predicate loops, denoted by OC1(Π), is of the similar form as the ordered completion
of Π (see Deﬁnition 3), except that

• Q ((cid:7)z) in Eq. (4) ranges over all the intensional atoms in the positive part of Bodyi such that Q and P are in the same

maximal predicate loop of Π ;

• P , Q and R in Eq. (4) are intensional predicates that belong to the same maximal predicate loop of Π .

The following proposition is a reﬁnement of the main theorem.

Proposition 8. Let Π be a normal logic program whose signature is σ , and A a ﬁnite σ -structure. Then, A is an answer set of Π if
and only if there exists a model M of OC1(Π) such that A is the reduct of M on σ .

Proof. The “only if” part can be proved by using a similar construction except that the comparison predicates (cid:2)PQ are only
deﬁned over those pairs of (P , Q ) in the same maximal predicate loop. For the “if” part, we can prove it by contradiction
again. Similarly, we can get the same sequence of ground atoms P 0((cid:7)a0), P 1((cid:7)a1), . . . , P i((cid:7)ai), . . . such that for all i, P i((cid:7)ai) ∈
−−−→
IntM↑σ , P i((cid:7)ai) ∈ L, and both
ai+1 hold. Notice that for all i (i (cid:3) 0), there exists an edge from
P i to P i+1 in PGΠ . Again, there exists k < l such that P k((cid:7)ak) = Pl((cid:7)al). Hence, P k, P k+1, . . . , Pl must be in a maximal predicate
−−−→
loop of Π , say L. Hence, according to the transitivity axioms with respect to L, (cid:7)al (cid:2)Pl Pk+1
ak+1 holds. This contradicts to the
−−−→
facts that P k((cid:7)ak) = Pl((cid:7)al) and ¬(cid:7)ak (cid:2)Pk Pk+1
ak+1 holds. (cid:2)

(cid:7)ai and ¬(cid:7)ai (cid:2)P i P i+1

−−−→
ai+1 (cid:2)P i+1 P i

In many cases, restricting comparison predicates on maximal predicate loops results in a much smaller ordered comple-
tion. As many benchmark logic programs have no predicate loops, in these cases, OC1(Π) is exactly the Clark’s completion
of Π . Even for those programs with predicate loops, this optimization technique will also signiﬁcantly simplify the ordered
completion since, in many cases, not all predicates are in the same predicate loop. Let us consider the following program
for computing all Hamiltonian circuits.

14

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

Example 8. The following program HC is another encoding for computing all Hamiltonian circuits of a given graph [22]:

hc(x, y) ← arc(x, y), not otherroute(x, y),
otherroute(x, y) ← arc(x, y), arc(x, z), hc(x, z), y (cid:3)= z,
otherroute(x, y) ← arc(x, y), arc(z, y), hc(z, y), x (cid:3)= z,
reached( y) ← arc(x, y), hc(x, y), reached(x), not init(x),
reached( y) ← arc(x, y), hc(x, y), init(x),

← vertex(x), not reached(x).

This program has three intensional predicates: hc, otherroute and reached. According to the original version of the ordered
completion (see Deﬁnition 3), we need to introduce 9 comparison predicates, and the maximal arity is 4.

However, by using maximal predicate loops, only one auxiliary predicate is needed since HC has only one maximal
predicate loop, namely {reached}. The only comparison predicate needed is (cid:2)R R (x, y), which is binary. Hence, OC1(H C) is
the following set of sentences:

∀xy
∀xy

(cid:5)
(cid:6)
hc(x, y) ↔ arc(x, y) ∧ ¬otherroute(x, y)
(cid:5)
otherroute(x, y) ↔ ∃z
∃z

,
(cid:5)
arc(x, y) ∧ arc(x, z) ∧ hc(x, z) ∧ y (cid:3)= z
(cid:5)
arc(x, y) ∧ arc(z, y) ∧ hc(z, y) ∧ x (cid:3)= z

(cid:6)

∨
(cid:6)(cid:6)

,

(cid:5)(cid:5)

∀ y

(cid:5)

∀ y

(cid:5)
(cid:6)
∃x
arc(x, y) ∧ hc(x, y) ∧ reached(x) ∧ ¬init(x)
(cid:5)
(cid:6)(cid:6)
∃x
arc(x, y) ∧ hc(x, y) ∧ init(x)
(cid:6)
(cid:5)
(cid:5)
arc(x, y) ∧ hc(x, y) ∧ init(x)
∃x
(cid:5)
∃x
arc(x, y) ∧ hc(x, y) ∧ reached(x) ∧ ¬init(x) ∧ x (cid:2)R R y ∧ ¬ y (cid:2)R R x

(cid:6)
→ reached( y)
∨

reached( y) →

∨

,

(cid:6)(cid:6)(cid:6)

,

(cid:6)
vertex(x) ∧ ¬reached(x)

(cid:5)
∀x¬
∀xyz(x (cid:2)R R y ∧ y (cid:2)R R z → x (cid:2)R R z).

,

4.2. Folding reverse comparison predicates

In the deﬁnition of the ordered completion, for a pair of intensional predicates (P , Q ), we introduce two new comparison
predicates (cid:2)PQ and (cid:2)QP. This can be simpliﬁed by just introducing one of them because if there is a derivation path from
one ground atom to another, then there is none from the other way around.

Formally, we abbreviate (cid:7)x (cid:2)PQ (cid:7)y ∧ ¬(cid:7)y (cid:2)QP (cid:7)x as (cid:7)x <PQ (cid:7)y, meaning that there is a derivation path from P ((cid:7)x) to Q ((cid:7)y) but
not the other way around. We rank all the intensional predicates occurring in Π as {P 1, . . . , Pn}, and deﬁne Rank(P i) = i
(1 (cid:2) i (cid:2) n). For every maximal predicate loop L of Π , and for every two predicates P i, P j ∈ L, we introduce a new compar-
ison predicate <P i P j if Rank(P i) (cid:2) Rank(P j). This method reduces almost half of the comparison predicates introduced.

The new version of the ordered completion by folding reverse comparison predicates, denoted by OC2(Π), is deﬁned

based on OC1(Π) except that

• (cid:7)z (cid:2)QP (cid:7)x ∧ ¬(cid:7)x (cid:2)PQ (cid:7)z in Eq. (4) is replaced by (cid:7)z <QP (cid:7)x if Rank(Q ) (cid:2) Rank(P ), and ¬(cid:7)x <PQ (cid:7)z if Rank(Q ) > Rank(P );
• the transitivity axioms, i.e. Eq. (4) with respect to a predicate loop L are replaced as follows:

– for any P ∈ L, the sentence ∀(cid:7)x¬(cid:7)x <P P (cid:7)x, and
– for any P i, P j, P k ∈ L such that Rank(P i) (cid:2) Rank(P j) (cid:2) Rank(P k), the following two sentences:

∀(cid:7)x(cid:7)y(cid:7)z((cid:7)x <P i P j
∀(cid:7)x(cid:7)y(cid:7)z(¬(cid:7)x <P i P j

(cid:7)y ∨ (cid:7)y <P j Pk
(cid:7)y ∨ ¬(cid:7)y <P j Pk

(cid:7)z ∨ ¬(cid:7)x <P i Pk
(cid:7)z ∨ (cid:7)x <P i Pk

(cid:7)z),

(cid:7)z).

Proposition 9. Let Π be a normal logic program whose signature is σ , and A a ﬁnite σ -structure. Then, A is an answer set of Π if
and only if there exists a model M of OC2(Π) such that A is the reduct of M on σ .

(cid:7)ai holds if Rank(P i+1) (cid:2) Rank(P i), and ¬(cid:7)ai <P i P i+1

Proof. Again, the “only if” part is easy. Now we prove the “if” part by contradiction. Similarly, we can get a sequence of
ground atoms P 0((cid:7)a0), P 1((cid:7)a1), . . . , P i((cid:7)ai), . . . such that for all i, P i((cid:7)ai) ∈ IntM↑σ , all P i((cid:7)ai) are in a ground loop L. In addition,
−−−→
−−−→
ai+1 <P i+1 P i
ai+1 holds if Rank(P i+1) > Rank(P i). (Note that here i is not
the rank of P i .) Since all the <PQ , where Rank(P ) (cid:2) Rank(Q ), satisfy the new transitivity axioms, by induction, it can be
(cid:7)a j holds if Rank(P j) > Rank(P i). Again,
proved that for all i (cid:2) j,
−−−→
we can ﬁnd k < l such that P k((cid:7)ak) = Pl((cid:7)al) in the sequence. Hence, (cid:7)al <Pl Pk+1
ak+1 holds if Rank(Pl) (cid:2) Rank(P k+1), and
¬−−−→
ak+1 <Pk+1 Pl

(cid:7)al holds if Rank(Pl) > Rank(P k+1). There are three cases:

(cid:7)ai holds if Rank(P j) (cid:2) Rank(P i), and ¬−→

−→
a j <P j P i

ai <P i P j

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

15

Case 1:

Case 2:

Case 3:

Rank(P k) = Rank(Pl) < Rank(P k+1). Then, (cid:7)al <Pl Pk+1
Pl((cid:7)al), a contradiction.
Rank(P k) = Rank(Pl) > Rank(P k+1). Then, ¬−−−→
Pl((cid:7)al), a contradiction.
Rank(P k) = Rank(Pl) = Rank(P k+1). Then, (cid:7)al <Pl Pk+1
(cid:7)ak holds. Then, according to the transitivity axioms, (cid:7)ak <Pk Pk

ak+1 <Pk+1 Pl

−−−→
ak+1 holds. Therefore (cid:7)ak <Pk Pk+1
(cid:7)al holds. Therefore ¬−−−→

ak+1 <Pk+1 Pk

−−−→
ak+1 holds since P k((cid:7)ak) =

(cid:7)ak holds since P k((cid:7)ak) =

−−−→
ak+1 holds. Therefore (cid:7)ak <Pk Pk+1

−−−→
ak+1 holds. Also,
(cid:7)ak holds, a contradiction. (cid:2)

−−−→
ak+1 <Pk+1 Pk

Example 9. Recall the program Π1 in Example 4

p1 ← p2,
p2 ← p1,
p1 ← not p3.

Then, according to the deﬁnition, OC2(Π1) is

(p2 ∨ ¬p3 → p1) ∧ (p1 → p2)

∨¬p3)

∧ (p1 → p2 ∧ ¬ <p1 p2
∧ (p2 → p1∧ <p1 p2 )
∧ (<p1 p1
∧ (<p1 p1
∧ (<p1 p2
∧ (<p2 p2
∧ ¬ <p1 p1
which is equivalent to

∨ <p1 p1
∨ <p1 p2
∨ <p2 p2
∨ <p2 p2
∧¬ <p2 p2 ,

∨¬ <p1 p1 ) ∧ (¬ <p1 p1
∨¬ <p1 p2 ) ∧ (¬ <p1 p1
∨¬ <p1 p2 ) ∧ (¬ <p1 p2
∨¬ <p2 p2 ) ∧ (¬ <p2 p2

∨¬ <p1 p1
∨¬ <p1 p2
∨¬ <p2 p2
∨¬ <p2 p2

∨ <p1 p1 )
∨ <p1 p2 )
∨ <p1 p2 )
∨ <p2 p2 )

(p2 ∨ ¬p3 → p1) ∧ (p1 → p2) ∧ (p1 → p2 ∧ ¬ <p1 p2

∨¬p3)

∧ (p2 → p1∧ <p1 p2 ) ∧ ¬ <p1 p1

∧¬ <p2 p2 .
Then, OC2(Π1) has three models, namely {p3, <p1 p2
{p1, p2}.

4.3. Simplifying transitivity axioms

}, {p3}, and {p1, p2, <p1 p2

}. Hence, Π1 has two answer sets: {p3} and

Now we consider to simplify the transitivity axioms. In the deﬁnition of the ordered completion and its variations
presented previously, we need to introduce the transitivity axioms for every three intensional predicates P , Q and R in a
maximal predicate loop such that Rank(P ) (cid:2) Rank(Q ) (cid:2) Rank(R). In other words, we expand the maximal predicate loop to
a complete graph and introduce the transitivity axioms for every three vertices. In fact, this can be reduced by expanding
the maximal predicate loop conservatively.

Let Π be a program and L = {P 1, . . . , Pn} be a maximal predicate loop in PGΠ . The following procedure generates a set

of triples among (the undirected version of) L:

1. pick up the vertex P in the undirected version of L which has the least number of edges;
2. for every two predicates Q and R connected to P in the undirected version of the graph, add an edge between Q and

R, and then select the triples related to the three predicates P , Q and R;

3. delete the vertex P in L;
4. go to step 1 and repeat this procedure till all triples generated.

Example 10. Consider the following program Π2

P 1((cid:7)x1) ← P 2((cid:7)x2),
P 2((cid:7)x2) ← P 3((cid:7)x3),
P 3((cid:7)x3) ← P 4((cid:7)x4),
P 4((cid:7)x4) ← P 1((cid:7)x1),
P 1((cid:7)x1) ← not P 5((cid:7)x5).

16

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

The predicate dependency graph of Π2 contains four nodes, i.e. P 1, P 2, P 3, P 4. In OC2(Π), for the transitivity axioms, we
need to consider every combination of three predicates, which counts 43 groups.

According to the procedure above, we can reduce the number to 2 × 33 groups. First, we pick up a vertex, which had
the least number of edges, say P 1. Then, we need to connect P 2 and P 4 as they are connected to P 1 in the predicate
dependency graph. Now, one triple is selected, namely P 1, P 2, P 4. Then, we can delete the node P 1 from the dependency
graph. The rest is a triple now, namely P 2, P 3, P 4. Hence, we need 2 × 33 groups as there are two triples generated.

It can be expected that the bigger the predicate dependency graph is, the more transitivity axioms can be reduced.

Then, the ordered completion by simplifying transitivity axioms, denoted by OC3(Π), is deﬁned based upon OC2(Π) by

replacing the transitivity axioms only for the triples of intensional predicates generated according to the above procedure.

Proposition 10. Let Π be a normal logic program whose signature is σ , and A a ﬁnite σ -structure. Then, A is an answer set of Π if
and only if there exists a model M of OC3(Π) such that A is the reduct of M on σ .

Proof. The “only if” can be proved similarly. For the “if” part, we prove it by contradiction. Otherwise, following again the
same proof techniques in Proposition 9, we can get a sequence of ground atoms P k((cid:7)ak), P k+1(

−−−→
ak+1), . . . , Pl((cid:7)al) such that

• for all i (k (cid:2) i (cid:2) l), P i((cid:7)ai) ∈ IntM↑σ ;
• for all i (k (cid:2) i (cid:2) l), P i((cid:7)ai) are in a ground loop of ΠM↑σ ;
−−−→
• for all i (k (cid:2) i (cid:2) l − 1),
ai+1 <P i+1 P i
Rank(P i+1) > Rank(P i);

• P k((cid:7)ak) = Pl((cid:7)al).

(cid:7)ai holds if Rank(P i+1) (cid:2) Rank(P i), and ¬(cid:7)ai <P i P i+1

−−−→
ai+1 <P i P i+1 ((cid:7)ai,

−−−→
ai+1) holds if

Assume that L is a sequence of ground atoms that satisﬁes the above conditions and has the least number of ground
atoms. Select the ground atom P i((cid:7)ai) (k (cid:2) i (cid:2) l) in L such that P i is the ﬁrst predicate calculated according to the pro-
−−−→
ai+1). According to
cedure, among all predicates occurred in the ground loop L. Now we consider P i−1(
the procedure, the triple (cid:22)P i−1, P i, P i+1(cid:23) must be selected. Then, there are several cases about the order of ranks among
−−−→
the three predicates P i−1, P i and P i+1. It can be checked that, no matter the order of rank is,
ai−1 holds if
Rank(P i+1) (cid:2) Rank(P i−1), and ¬−−−→
−−−→
ai+1 holds if Rank(P i+1) > Rank(P i−1) since (cid:22)P i−1, P i, P i+1(cid:23) satisfy the new
transitivity axioms. Hence, L\{P i((cid:7)ai)} also satisﬁes the above conditions. This contradicts to our assumption that L has the
least number of ground atoms satisfying the conditions. (cid:2)

−−−→
ai−1) and P i+1(

−−−→
ai+1 <P i+1 P i−1

ai−1 <P i−1 P i+1

4.4. Ordered completion in SMT

In worst case, the transitive formulas in ordered completion need to introduce O (m2) new predicates and O (s × m3)
new formulas, where m is the number of intensional predicates and s is the maximal arity of the intensional predicates
of Π (e.g. consider the program whose predicated dependency graph is complete). This is sometimes a heavy burden for
implementation.

To address this issue, we propose an alternative solution. Inspired by Niemelä’s translation [23], we use Satisﬁability
Modulo Theories (SMT) [24] instead of classical ﬁrst-order logic as the host language. That is, we translate every normal
logic program under the stable model semantics to a sentence (again, its ordered completion) in SMT rather than in classical
ﬁrst-order logic.

Roughly speaking, Satisﬁability Modulo Theories [24] are ﬁrst-order theories together with some background theories,
such as the theory of real numbers and theory of data structures. For our purpose, we need the theory of partial orders
to eliminate the transitivity axioms. The ordered completion in SMT (with the theory of partial orders as the background
theory) is basically the same as the version in classical ﬁrst-order logic except that we do not need the transitivity axioms
(i.e. TranS(Π)). This is because the comparison predicates (cid:2)PQ can be regarded as built-in predicates in the theory of partial
orders, which naturally satisfy transitivity. In this sense, the ordered completion of Π in SMT (with the theory of partial
orders as the background theory) is simply the modiﬁed Clark’s completion of Π , namely MComp(Π).

However, the theory of partial orders is not well-supported in many modern SMT solvers. To address this issue, we show
that, for capturing ordered completion, we can use linear arithmetic as the background theory in SMT as well. The main
reason to do so is that linear arithmetic is well supported by some modern SMT solvers, e.g. Z3.3

Formally, the ordered completion in SMT (with linear arithmetic as the background theory) is deﬁned as follows.

Deﬁnition 4 (Ordered completion in SMT). Let Π be a normal logic program. The SMT-ordered completion of Π , denoted by
OC

(cid:16)(Π), is the following set of sentences for each intensional predicate P

3 http://research.microsoft.com/en-us/um/redmond/projects/z3/

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

17

(cid:4)

∃(cid:7)yi

(cid:2)
Bodyi

→ P ((cid:7)x)

,

(cid:2) (cid:3)

∀(cid:7)x

1(cid:2)i(cid:2)k

(cid:2)

∀(cid:7)x

P ((cid:7)x) →

(cid:2)

∃(cid:7)yi

(cid:2)
Bodyi

∧

(cid:3)

1(cid:2)i(cid:2)k

(cid:10)

(cid:4)(cid:4)

n Q ((cid:7)z) < n P ((cid:7)x)

,

Q ((cid:7)z)∈Posi ,Q ∈ΩΠ

where the notations used are borrowed from Deﬁnition 3. In addition,

• for each intensional predicate P of arity n, n P is a function from domain tuples to integers, i.e. n P : Dn → N;
• < is a built-in predicate in linear arithmetic, meaning “less than”.

We show that the stable models of a program can be equivalently captured by its SMT-ordered completion as well.

Theorem 3. Let Π be a normal logic program whose signature is σ , and A a ﬁnite σ -structure. Then the following statements are
equivalent:

1. A is an answer set of Π ;
2. there exists a model M of OC(Π) such that A is the reduct of M on σ ;
3. there exists a model M(cid:16)

(cid:16)(Π) such that A is the reduct of M(cid:16)

of OC

on σ .

Proof. Theorem 2 proves 1 ⇔ 2. Now we show 2 ⇒ 3. Suppose that we have a structure M of the signature σ ∪ {(cid:2)PQ |
P , Q ∈ Ω(Π)}, which is a model of OC(Π), i.e. MComp(Π) ∪ TranS(Π). Since M satisﬁes TranS(Π), we can deﬁne an order
(cid:4) on the set IntM of intensional ground atoms, i.e. {P ((cid:7)u) | P ∈ Ω(Π), (cid:7)u ∈ P

M}, of Π as follows:

• for every P ((cid:7)u) ∈ IntM, P ((cid:7)u) (cid:4) P ((cid:7)u);
• for every pair P ((cid:7)u), Q ((cid:7)v) ∈ IntM, P ((cid:7)u) (cid:4) Q ((cid:7)v) iff ((cid:7)u, (cid:7)v) ∈ (cid:2)PQ
• for every pair P ((cid:7)u), Q ((cid:7)v) ∈ IntM, we write P ((cid:7)u) = Q ((cid:7)v) iff P ((cid:7)u) (cid:4) Q ((cid:7)v) and Q ((cid:7)v) (cid:4) P ((cid:7)u).

M

;

Clearly, (cid:4) is a partial order on IntM as the comparison predicates (cid:2)PQ satisfy the transitivity axioms, i.e. TranS(Π). There-
fore, (cid:4) can be extended to a total order (also called linear order) (cid:4)(cid:16)
on IntM. We can construct a mapping f from IntM to
natural numbers, i.e. f : IntM → N, such that for every P ((cid:7)u) ∈ IntM, f (P ((cid:7)u)) is the position of P ((cid:7)u) in this total order (cid:4)(cid:16)
.
f (P ((cid:7)u)) = t iff there exist t elements E1, . . . Et ∈ IntM such that E i (cid:3)= E j for all 1 (cid:2) i < j (cid:2) t and E i (cid:4)(cid:16)
P ((cid:7)u) for all
That is,
1 (cid:2) i (cid:2) t. Now we construct M(cid:16)

based on M and f as follows:

has the same domain M and constant interpretations as M;

• M(cid:16)
M
• for all P ∈ σ , P
• for all Q ∈ Ω(Π) and (cid:7)u ∈ Mn, n Q ((cid:7)u) = f (Q ((cid:7)u)).

M(cid:16) = P

;

(cid:16)(Π) since M is a model of MComp(Π) and for any two intensional ground

It can be shown that M(cid:16)
atoms P ((cid:7)u), Q ((cid:7)v) ∈ IntM, (cid:7)u (cid:2)PQ (cid:7)v (i.e. ((cid:7)u, (cid:7)v) ∈ (cid:2)PQ
For 3 ⇒ 2, suppose that we have a structure M(cid:16)

is a model of OC

(cid:16)(Π). We can construct
M
a structure M of σ ∪ {(cid:2)PQ | P , Q ∈ Ω(Π)} such that M agrees everything the same on the signature σ and ((cid:7)u, (cid:7)v) ∈ (cid:2)PQ
iff n P ((cid:7)u) < n Q ((cid:7)v) or n P ((cid:7)u) = n Q ((cid:7)v). Following the similar arguments, it can be shown that M is a model of MComp(Π). In
addition, M is a model of TranS(Π) as well because the functions n P naturally yield a total order, thus a partial order, on
IntM (the same as IntM(cid:16) ). Hence, M is a model of OC(Π). (cid:2)

) iff n P ((cid:7)u) < n Q ((cid:7)v) or n P ((cid:7)u) = n Q ((cid:7)v).

M
of σ ∪ {n P | P ∈ Ω(Π)}, which is a model of OC

5. Implementation and experimental results

To the best of our knowledge, the ordered completions provide for the ﬁrst time a translation from ﬁrst-order normal
logic programs under the stable model semantics to classical ﬁrst-order logic on ﬁnite structures. Signiﬁcantly, this trans-
lation enables us to develop a new kind of ASP solvers by grounding on a program’s ordered completion instead of the
program itself.

5.1. Implementation

In this section, we report on a ﬁrst implementation of such a solver. In order to be consistent with existing ASP solvers,
we consider Herbrand structures but not arbitrary structures at this stage. As stated in Section 2.3, under this context, our
proposed semantics coincides with Gelfond and Lifschitz’s original semantics [12]. Following the current practice, the input
program is divided into two parts:

18

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

Fig. 2. Traditional ASP solvers.

Fig. 3. Our new ASP solver.

1. a ﬁrst-order normal logic program, and
2. a set of ground facts that deﬁnes the extensional predicates.4 We also call this set an extensional database.

Our goal is to compute answer sets of the program based on the given set of ground facts, i.e. an answer set in which
the interpretations of the extensional predicates coincide with the extensional database. It is worth mentioning that for the
same ﬁrst-order logic program, different extensional databases can be provided.

For instance, for the transitivity closure program TC (see Example 1), the extensional database can be any graph, whose
edges are represented by E (e.g. the graph in Fig. 1). Our goal is to compute one answer set of the program TC based on the
given graph. What we need to do is to compute the interpretation of the intensional predicates, namely S in this example,
which represents the transitive closure of the graph. Again, while the TC program is always the same, the extensional
database can be any graph, and the purpose of TC is to compute the transitive closure of the given graph.

Typically, existing ASP solvers have two components (see Fig. 2):

1. A grounder, such as lparse5 and gringo,6 transforms a ﬁrst-order logic program together with a set of ground facts into

a propositional program.

2. A propositional ASP solver, such as clasp,7 cmodels8 and lp2diff,9 computes the answer sets of the propositional program,

which correspond to the answer sets of the original ﬁrst-order program based on those ground facts.

Using our ordered completion, we can do it differently (see Fig. 3):

(cid:16)

(cid:16)

(cid:16)

1
2
3

. A translator translates a ﬁrst-order logic program to its ordered completion (see Deﬁnition 3).
. A grounder transforms this ordered completion together with a set of ground facts to a propositional theory.
. A SAT/SMT solver is called to compute the models of the propositional theory, which correspond to the answer sets of

the original ﬁrst-order program based on those ground facts (by Theorem 2/3).

We can see the following potential beneﬁts for our approach:

• Grounding an ordered completion, which is a ﬁrst-order sentence, is based on the semantics of classical logic. Therefore,
many simpliﬁcation techniques in classical ﬁrst-order logic can be used that may not be available for logic programs

4 Notice that the set of ground facts contains no information about the intensional predicates.
5 http://www.tcs.hut.ﬁ/Software/smodels/.
6 http://sourceforge.net/projects/potassco/ﬁles/gringo/.
7 http://www.cs.uni-potsdam.de/clasp/.
8 http://www.cs.utexas.edu/~tag/cmodels/.
9 http://www.tcs.hut.ﬁ/Software/lp2diff/.

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

19

under the stable semantics. These simpliﬁcation techniques may be crucial to scale up the grounding process to deal
with large extensional databases.

• In addition to the simpliﬁcation technique used in run time when doing grounding, the same or similar techniques can
be used to simplify the ordered completion of the “ﬁrst-order” part of the program, before the extensional database is
given. Importantly, this can be done “off line”, and done once and for all for each ﬁrst-order logic program.

• The SAT solver part is used as a black box. Any SAT solver can be used here. Hence, we can beneﬁt from any progress

in SAT.

Based on Theorem 3, we have implemented a prototype of a new ASP solver, which contains three steps. First, we trans-
(cid:16)(Π). Notice that some of the optimization techniques mentioned
late a program Π to its SMT-ordered completion, i.e. OC
(cid:16)(Π) into a propositional SMT theory.
in Section 4 can still be used here. Second, we use our grounder groc to ground OC
Finally, we call the SMT solver Z3 to compute a model of the SMT theory, which, by Theorem 3, should be corresponding
to an answer set of Π . Next, we report on some preliminary experimental results of our solver on the Hamiltonian Circuit
program (see Example 8), compared to other major modern ASP solvers.

5.2. Experimental results

The goal of our experiments is to compare our new ASP solver to the existing ASP solvers.
Again, the input is divided into two parts: a ﬁrst-order program as well as a set of ground facts (i.e. an extensional
database). The output is to return an answer set of the program based on the extensional database if there exists such one,
and to return “no” otherwise.
As mentioned earlier,

in order to solve this problem, existing ASP solvers normally use a 2-step approach. First,
a grounder is used to transform the ﬁrst-order program together with the extensional database to a propositional pro-
gram. In our experiments, we use gringo (version 3.03) as the grounder. Secondly, a propositional ASP solver is called to
compute an answer set. In this paper, we consider three different propositional ASP solvers: clasp (version 2.0.1), cmodels
(version 3.81), and lp2diff (version 1.27) with Z3 (version 3.2.18).

Our solver, however, needs 3 steps. First, we translate a ﬁrst-order program to its SMT-ordered completion. As this step
is normally very fast and can be done off line, we do not count the time used in this step. Secondly, we implemented
a ﬁrst-order theory grounder called groc, and use it to transform the ordered completion together with the extensional
database to a proportional SMT theory. Finally, we call an SMT solver to compute a model of the SMT theory, which should
be an answer set of the program based on the extensional database by Theorem 3. We use Z3 (version 3.2.18) as the SMT
solver in this step.

We consider the Hamiltonian Circuit benchmark program by Niemelä [22] (also see Example 8). The current benchmark
graph instances for the HC program normally contain no more than 150 nodes. Here, instead, we consider much bigger
graph instances. That is, we consider random graphs with nodes ranging from 200 to 1000, in which the numbers of edges
are ten times the numbers of nodes. The graph instances are named as rand_nodes_edges_number, where rand means this is
a random graph, nodes represents the number of nodes in this graph, edges represents the number of edges in this graph,
and number is the code of this graph in this category. For instance, rand_200_2000_6 is a random graph with 200 nodes
and 2000 edges, and is the 6th graph instance in this category.

Table 1 reports some runtime data of our experiments on the HC program with those relatively big graph instances. The
experiments were performed on a CENTOS version 2.16.0 LINUX platform with 2 GB of memory and AMD Phenom 9950
Quad-Core processor running at 2.6 GHz. For space reasons, we only report the overall time used by the following different
approaches:

• gringo as the grounder and clasp as the propositional ASP solver (gringo + clasp);
• gringo as the grounder and cmodels as the propositional ASP solver (gringo + cmodels);
• gringo as the grounder, lp2diff as the translator from propositional programs to SMT and Z3 as the SMT solver (gringo +

• ﬁnally, our solver by using groc to ground the ordered completion together with extensional databases, and calling the

lp2diff + Z3);

SMT solver Z3 (groc + Z3).

We set the timeout threshold as 900 seconds, which is denoted by “–” in our experimental results.

In Table 1, the ﬁrst column speciﬁes the graph instances. In the second column, “y” (“n”) means that the corresponding
graph has a (no) Hamiltonian Circuit, while “?” means that this problem instance is not solved by any approaches within
limited time. The rest four columns record the overall time in seconds used by the four different approaches. It is worth
mentioning that, normally, the grounding time (i.e. for gringo and groc) is much less than the solving time.

Table 1 shows that our solver compares favorably to the others on the Hamiltonian Circuit benchmark program, especially
for those big graph instances. For 200-node random graphs, our solver seems not as good as gringo + classp in general, but
still looks slightly better than the other two. However, when the graph goes bigger, our advantages emerge. For those 400-
node and 600-node graphs, our solver clearly outperforms the other approaches. Moreover, for 1000-node random graphs,
our solver is the only one capable of solving the problems within the time threshold. Also, it is interesting to take a closer

20

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

Table 1
Experimental results about the Hamiltonian Circuit program.

Instances

rand_200_2000_1
rand_200_2000_2
rand_200_2000_3
rand_200_2000_4
rand_200_2000_5
rand_400_4000_1
rand_400_4000_2
rand_400_4000_3
rand_400_4000_4
rand_400_4000_5
rand_600_6000_1
rand_600_6000_2
rand_600_6000_3
rand_600_6000_4
rand_600_6000_5
rand_1000_10000_1
rand_1000_10000_2
rand_1000_10000_3
rand_1000_10000_4
rand_1000_10000_5

gringo + clasp

gringo + cmodels

gringo + lp2diff + Z3

groc + Z3

y
y
n
y
y
y
y
?
y
y
y
y
y
y
y
y
y
y
y
y

0.325
0.604
0.175
1.453
0.329

–

24.110

–
–
–
140.830
–
–
–
–
–
–
–
–
–

3.130
3.310
0.150
7.960
7.600
–
–
–
–
–
–
–
–
–
–
–
–
–
–

6.954
10.185
2.507
18.412
8.899
49.506

–
–

46.938
162.277
114.973
203.500
340.219
83.650
403.075
–
–
–
–
–

1.79
1.95
0.00
1.66
15.24
5.08
59.31

–

8.10
8.00
12.16
38.41
45.84
52.13
9.20
324.22
133.66
99.32
256.91
295.89

look at the only instance with no answer sets, i.e. rand_200_2000_3. With our grounder groc, the inconsistency can be
immediately identiﬁed.

More importantly, it is reasonable to believe that the performance of our solver can be further improved by employing
more optimization techniques. In particular, it is interesting to see if some technique can be developed to simplify the
ordered completion. As mentioned earlier, this can be done off line since it only needs to be done once for each program.
We have observed that for some logic programs, their ordered completion can indeed be simpliﬁed to yield a ﬁrst-order
sentence that is signiﬁcantly smaller in size. To us, this is one of the most important future work.

6. Related work and discussions

In this section, we discuss and compare our translation to other translations from logic programs under the stable model
(answer set) semantics to classical logic. In general, one can say that the intuitions behind most of the translations are
similar. The main differences are in the ways that these intuitions are formalized.

6.1. First-order case

Other ﬁrst-order translations As the focus of this paper is to consider the ﬁrst-order case, we ﬁrst review the existing
work about translating ﬁrst-order logic programs under the stable model semantics to standard ﬁrst-order logic. To the best
of our knowledge, the only such translation is the loop formula approach [2,16]. From a syntactical viewpoint, the main
difference between this approach and ours is that the ordered completion results in a ﬁnite ﬁrst-order theory (which can
be represented as a single ﬁrst-order sentence) but uses auxiliary predicates, while the loop formula approach does not use
any auxiliary predicates but in general results in an inﬁnite ﬁrst-order theory.

From a semantical viewpoint, both approaches share some similar ideas. First of all, both of them are extended from
Clark’s completion, and the extended parts play a similar role to eliminate those structures which are models of the Clark’s
completion but not stable models of the logic program. The main difference is that the loop formula approach uses loop
formulas for this purpose, while the ordered completion uses additional comparison predicates to keep track of the deriva-
tion order. Secondly, they both require that every ground atom in a stable model must be justiﬁed by certain derivation
path. However, for this purpose, the loop formula approach further claims that every loop (so is every ground atom) must
have some external supports, while the ordered completion approach explicitly enumerates such a derivation order (thus a
derivation path) by the new comparison predicates.

Similar translations in Datalog Another related work [15] is in the area of ﬁnite model theory and ﬁxed-point logic. Al-
though ﬁxed-point logic and normal logic programming are not comparable, they have a common fragment, namely Datalog.
Kolaitis [15] showed that every ﬁxed-point query is conjunctive deﬁnable on ﬁnite structures. That is, given any ﬁxed-point
(cid:16)) is implicitly deﬁnable on ﬁnite
query Q , there exists another ﬁxed-point query Q
structures. As a consequence, every Datalog query is also conjunctively deﬁnable on ﬁnite structures. From this result, al-
though tedious, one can actually derive a translation from Datalog to ﬁrst-order sentences using some new predicates not
in the signatures of the original Datalog programs.

such that the conjunctive query (Q , Q

(cid:16)

We will not go into details comparing our translation and the one derived from Kolaitis’ result since our focus here is on
normal logic programs. Suﬃce to say here that the two are different in many ways, not the least is that ours is based on

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

21

Clark’s completion in the sense that some additional conditions are added to the necessary parts of intensional predicates,
while the one derived from Kolaitis’ result is not. We mention this work because Kolaitis’ result indeed inspired our initial
study on this topic. We speculated that if it is possible to translate Datalog programs to ﬁrst-order sentences using some
new predicates, then it must also be possible for normal logic programs, and that if this is true, then it must be doable by
modifying Clark’s completion. As it happened, this turned out to be the case.

6.2. Propositional case

Translations in the propositional case The ordered completion can be viewed as a propositional translation from normal
logic programs to propositional theories by treating each propositional atom as a 0-ary predicate. Several proposals in this
direction have been proposed in the literature [1,14,18,19,23].

An early attempt is due to Ben-Eliyahu and Dechter [1], who assigned an index (or level numbering) #p to each propo-
sitional atom p, and added the assertions #p < #q to the Clark’s completion for each pair (p, q) similar to the ordered
completion, where q is the head of a rule and p ranges over all atoms in the positive body of a rule. A closely related work
is recently proposed by Niemelä [23], in which the level mappings and their comparisons are captured in difference logic,
an extension of classical propositional logic. More precisely, each atom p is assigned to a number xp , meaning its level or
stage. Then, the assertions xq − 1 (cid:3) xp are added to the Clark’s completion similar to Ben-Eliyahu and Dechter and the or-
dered completion. In addition, in both approaches, the optimization technique of exploiting strongly connected components
is discussed.

Another translation, also sharing the basic idea of comparing stages (or indices), is due to Janhunen [14], who proposed
a simpliﬁed translation by level numbering as well. Different from the above approaches, Lin and Zhao [18] translated an
arbitrary normal logic program equivalently to a tight program ﬁrst by adding some new atoms, and then use the Clark’s
completion of the new program to capture the answer sets of the original one. Finally, the loop formula approach in the
propositional case [19] yields another translation from propositional normal logic programming to propositional logic. Again,
the loop formula approach requires no new atoms. However, it is not polynomial in the sense that a program may have
exponential loop formulas in worst case.

Comparisons with Ben-Eliyahu and Dechter’s and Niemelä’s work Here, we discuss more about the relationships among
the ordered completion, Ben-Eliyahu and Dechter’s translation and Niemelä’s work since these three translations are very
closely related, while the others are slightly different. In fact, the above three translations basically share the same intuitions
in the propositional case. This is because all of them are modiﬁed from Clark’s completion by adding to it the comparisons
of indices/levels/stages. Speciﬁcally, the comparisons are represented by (cid:2)pq ∧¬ (cid:2)qp in the ordered completion, #p < #q in
Ben-Eliyahu and Dechter’s translation and xq − 1 (cid:3) xp in Niemelä’s work, where in all the above approaches, q is the head
of a rule and p ranges over all atoms in the positive body of a rule. Indeed, these assertions play the same role to state
that the stage (or level) of p should be less than the one of q. In this sense, the modiﬁed completion part of all these three
approaches can be transformed from each other.

In Ben-Eliyahu and Dechter’s translation, one has to explicitly enumerate the “indices” #p and “comparisons” #p < #q
in propositional logic [1], which turns out to be rather complicated. This is not an issue for Niemelä’s work [23] because
the level numbering xp associated with atoms and the comparisons xq − 1 (cid:3) xp can be directly represented by the built-
in predicates within the language of difference logic. Finally, in the ordered completion, we do not introduce the indices
directly but use additional atoms (cid:2)pq in classical propositional logic to explicitly represent the comparisons (cid:2)pq ∧¬ (cid:2)pq,
which are further speciﬁed by the transitivity formulas.

The similarities and differences among the three approaches can be illustrated by the following example.

Example 11. Recall the program Π1 in Example 4:

p1 ← p2,
p2 ← p1,
p1 ← not p3.

According to the deﬁnitions, the modiﬁed completion part of Π1 for the ordered completion is

(p2 ∨ ¬p3 → p1) ∧ (p1 → p2)
(cid:5)
∧¬ (cid:2)p1 p2
p1 → p2 ∧ [(cid:2)p2 p1
∧¬ (cid:2)p2 p1
p2 → p1 ∧ [(cid:2)p1 p2

(cid:5)

] ∨ ¬p3
(cid:6)
]

,

(cid:6)

∧

∧

while for Ben-Eliyahu and Dechter’s translation, this is

(p2 ∨ ¬p3 → p1) ∧ (p1 → p2)
(cid:5)
p1 → p2 ∧ [#p2 < #p1] ∨ ¬p3
(cid:6)
p2 → p1 ∧ [#p1 < #p2]

(cid:5)

,

(cid:6)

∧

∧

22

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

and ﬁnally, for Niemelä’s work, this is10

(p2 ∨ ¬p3 → p1) ∧ (p1 → p2)
(cid:5)
p1 → p2 ∧ [xp1
p2 → p1 ∧ [xp2

− 1 (cid:3) xp2
− 1 (cid:3) xp1

] ∨ ¬p3
(cid:6)
]

(cid:5)

.

(cid:6)

∧

∧

It can be observed that, the modiﬁed completion part of the three approaches can be easily obtained from each other. For
instance, from Niemelä’s work to the ordered completion, one only needs to replace each subformula of the form xp − 1 (cid:3) xq
(e.g. xp1

− 1 (cid:3) xp2 ) with its corresponding counterpart (cid:2)qp ∧ ¬ (cid:2)pq in the ordered completion ((cid:2)p2 p1

∧ ¬ (cid:2)p1 p2 resp.).

The main difference among the three approaches is another part of the translation, namely how to encode those new
indices and comparisons. The host formalism for both Ben-Eliyahu and Dechter’s translation and our ordered completion is
propositional logic, but for Niemelä’s work, it is difference logic, which is an extension of classical propositional logic with
linear constraints but not propositional logic itself. As a result, the encoding problem of comparisons for Niemelä’s work is
− 1 (cid:3) xp2 , can be naturally represented in the language of difference logic
not an issue because the comparisons, e.g. xp1
with the built-in predicate (cid:3). However, for the other two approaches, more work need to be done.

In the ordered completion, we use additionally transitivity formulas among new atoms (cid:2)pq for this purpose. For instance,

for the program Π1, the transitivity formulas is11:

(cid:2)p1 p2
∧ (cid:2)p2 p1

∧ (cid:2)p2 p1
∧ (cid:2)p1 p2

→ (cid:2)p1 p1
→ (cid:2)p2 p2 .

In Ben-Eliyahu and Dechter’s translation, one needs to explicitly encode the indices #p and the comparisons #p < #q in
classical propositional logic. This is rather complicated because one has to enumerate all the possibilities. For instance, for
the program Π1, the encoding of each index, e.g. #p1, is:
(cid:5)

(p1 = 1 ∨ p1 = 2) ∧

(cid:6)
p1 = 1 → ¬(p1 = 2)

,

and the encoding of each comparison, for instance #p1 < #p2, is:

p1 = 1 ∧ p2 = 2.

6.3. First-order deﬁnability and weak deﬁnability

Since the ordered completion is about translating logic programs to ﬁrst-order logic, it is closely related to the concepts

of (ﬁrst-order) deﬁnability for answer set programming [16,27].

A program is ( ﬁrst-order) deﬁnable (on ﬁnite structures) iff there exists a ﬁrst-order sentence of the signature of the pro-
gram such that its (ﬁnite) models are exactly the (ﬁnite) stable models of the program. It is well known that many programs
are not ﬁrst-order deﬁnable, e.g. the program TC in Example 1, both on arbitrary structures and on ﬁnite structures [5].

A weaker notion of ﬁrst-order deﬁnability is to allow new predicates. A program is ( ﬁrst-order) weakly deﬁnable (on ﬁnite
structures) iff there exists a ﬁrst-order sentence of a signature containing the signature of the program such that the reducts
of its (ﬁnite) models on the signature of the program are exactly the (ﬁnite) stable models of the program. It is easy to see
that a program is weakly deﬁnable (on ﬁnite structures) if and only if it is deﬁned by an existential second-order sentence
(on ﬁnite structures).

The following result immediately follows from Theorem 2.

Corollary 11. Every normal logic program is weakly deﬁnable on ﬁnite structures. More precisely, every program is weakly deﬁned by
its ordered completion on ﬁnite structures.

However, as shown in Proposition 5, this result does not hold on arbitrary structures. For instance, the TC program is not
weakly deﬁnable on arbitrary structures. In fact, following a similar proof, Proposition 5 can be extended to the following
result.

Proposition 12. On arbitrary structures, if a normal logic program is not deﬁnable, then it is not weakly deﬁnable.

10 It can be observed that the new atoms bdi
11 All the other transitive formulas are trivially true.

a in Niemelä’s work are not necessary.

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

23

New predicates

Allowed
Not allowed
Not allowed
Allowed

Resulting theory

No restriction
Finite
No restriction
Finite

Translation

Does not exist
Does not exist
Loop formula
Ordered completion

Table 2
From normal ASP to FOL.

Structures

Arbitrary
Finite
Finite
Finite

7. Conclusion

The main contribution of this paper is introducing a notion of ordered completion that captures exactly the answer
set semantics of ﬁrst-order normal logic programs with constraints and choice rules on ﬁnite structures (see Theorem 2,
Propositions 3 and 4). It can be summarized as follows:

For ﬁrst-order normal logic programs on ﬁnite structures,

Answer set = Clark’s completion + Derivation order

= Ordered completion

This seems to be a very tight result. First of all, as we have seen, this result cannot be extended to disjunctive logic
programs unless NP = coNP (see Proposition 6). For normal logic programs, with this result, we now have a rather complete
picture of mappings from logic programs to ﬁrst-order logic which is summarized by Table 2.

The signiﬁcance of our ordered completion can be seen from both a theoretical and a practical point of view. To the
best of our knowledge, it provides for the ﬁrst time a translation from ﬁrst-order normal logic programs under the stable
model semantics to ﬁrst-order sentences. Furthermore, it makes it possible to implement a new ASP solver by grounding
a ﬁrst-order theory instead of the program itself, an idea that motivated this and the work of [2] as well. We report our
ﬁrst implementation of such a solver (Section 5), and did some experiments on the Hamiltonian Circuit problems, which
are by far the best known benchmark logic programs that have loops. Our results clearly showed that our new solver is
competitive, with the edge over others on large problems (see Table 1). We are still working on improving our solver, and
believe that we will have some new results to report in the near future.

Acknowledgements

We would like to thank the anonymous reviewers for their valuable comments. This research is supported in part by

ARC Discovery project grant DP0988396, HK RGC GRF 616909 and NSFC grants 90718009 and 60963009.

References

[1] Ben-Eliyahu Rachel, Rina Dechter, Propositional semantics for disjunctive logic programs, Annals of Mathematics and Artiﬁcial Intelligence 12 (1–2)

(1994) 53–87.

[2] Yin Chen, Fangzhen Lin, Yisong Wang, Mingyi Zhang, First-order loop formulas for normal logic programs, in: Proceedings of the 10th International

Conference on Principles of Knowledge Representation and Reasoning (KR’06), 2006, pp. 298–307.

[3] Yin Chen, Fangzhen Lin, Yan Zhang, Yi Zhou, Loop-separable programs and their ﬁrst-order deﬁnability, Artiﬁcial Intelligence 175 (3–4) (2011) 890–913.
[4] Keith L. Clark, Negation as failure, in: H. Gallaire, J. Minker (Eds.), Logics and Databases, Plenum Press, New York, 1978, pp. 293–322.
[5] Heinz-Dieter Ebbinghaus, Jörg Flum, Finite Model Theory, Springer-Verlag, 1995.
[6] Thomas Eiter, Georg Gottlob, Heikki Mannila, Disjunctive Datalog, ACM Transactions on Database Systems 22 (3) (1997) 364–418.
[7] Fran ´cois Fages, A new ﬁxpoint semantics for general logic programs compared with the well-founded and the stable model semantics, New Generation

Computing 9 (3–4) (1991) 425–443.

[8] Fran ´cois Fages, Consistency of Clark’s completion and existence of stable models, Journal of Methods of Logic in Computer Science 1 (1994) 51–60.
[9] Ronald Fagin, Contributions to the model theory of ﬁnite structures, PhD Thesis, UC Berkeley, 1973.

[10] Paolo Ferraris, Joohyung Lee, Vladimir Lifschitz, A new perspective on stable models, Artiﬁcial Intelligence 175 (1) (2011) 236–263.
[11] Paolo Ferraris, Answer sets for propositional theories, in: Proceedings of the 8th International Conference on Logic Programming and Nonmonotonic

Reasoning (LPNMR’05), 2005, pp. 119–131.

[12] Michael Gelfond, Vladimir Lifschitz, The stable model semantics for logic programming, in: Proceedings of the Fifth International Conference and

Symposium (ICLP’88), 1988, pp. 1070–1080.

[13] Michael Gelfond, Vladimir Lifschitz, Classical negation in logic programs and disjunctive databases, New Generation Computing 9 (3–4) (1991) 365–386.
[14] Tomi Janhunen, Representing normal programs with clauses, in: Proceedings of the 16th European Conference on Artiﬁcial Intelligence (ECAI’04), 2004,

pp. 358–362.

[15] Phokion G. Kolaitis, Implicit deﬁnability on ﬁnite structures and unambiguous computations (preliminary report), in: Proceedings of the Fifth Annual

Symposium on Logic in Computer Science (LICS’90), 1990, pp. 168–180.

[16] Joohyung Lee, Yunsong Meng, On loop formulas with variables, in: Proceedings of the Eleventh International Conference on Principles of Knowledge

Representation and Reasoning (KR’08), 2008, pp. 444–453.

[17] Vladimir Lifschitz, R. Tang Lappoon, Hudson Turner, Nested expressions in logic programs, Annals of Mathematics and Artiﬁcial Intelligence 25 (3–4)

(1999) 369–389.

[18] Fangzhen Lin and Jicheng Zhao, On tight logic programs and yet another translation from normal logic programs to propositional logic, in: Proceedings

of the 18th International Joint Conference on Artiﬁcial Intelligence (IJCAI’03), 2003, pp. 853–858.

24

V. Asuncion et al. / Artiﬁcial Intelligence 177–179 (2012) 1–24

[19] Fangzhen Lin, Yuting Zhao, ASSAT: computing answer sets of a logic program by SAT solvers, Artiﬁcial Intelligence 157 (1–2) (2004) 115–137.
[20] Fangzhen Lin, Yi Zhou, From answer set logic programming to circumscription via logic of GK, Artiﬁcial Intelligence 175 (1) (2011) 264–277.
[21] Victor W. Marek, Miroslaw Truszczynski, Stable models and an alternative logic programming paradigm, in: The Logic Programming Paradigm: A 25-

Year Perspective, Springer-Verlag, 1999, pp. 375–398.

[22] Ilkka Niemelä, Logic programs with stable model semantics as a constraint programming paradigm, Annals of Mathematics and Artiﬁcial Intelli-

gence 25 (3–4) (1999) 241–273.

[23] Ilkka Niemelä, Stable models and difference logic, Annals of Mathematics and Artiﬁcial Intelligence 53 (1–4) (2008) 313–329.
[24] Robert Nieuwenhuis, Albert Oliveras, Cesare Tinelli, Solving SAT and SAT modulo theories: from an abstract Davis–Putnam–Logemann–Loveland proce-

dure to DPLL(T), Journal of the ACM 53 (6) (2006) 937–977.

[25] David Pearce, Agustín Valverde, Towards a ﬁrst order equilibrium logic for nonmonotonic reasoning, in: Proceedings of the 9th European Conference

on Logics in Artiﬁcial Intelligence (JELIA’04), 2004, pp. 147–160.

[26] David Pearce, A new logical characterisation of stable models and answer sets, in: Non-Monotonic Extensions of Logic Programming (NMELP’96), 1996,

pp. 57–70.

[27] Yan Zhang, Yi Zhou, On the progression semantics and boundedness of answer set programs, in: Proceedings of the Twelfth International Conference

on the Principles of Knowledge Representation and Reasoning (KR’10), 2010, pp. 518–527.

