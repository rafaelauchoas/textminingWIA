Artiﬁcial Intelligence 172 (2008) 325–349

www.elsevier.com/locate/artint

Graphically structured value-function compilation

Ronen I. Brafman a, Carmel Domshlak b,∗

a Department of Computer Science, Ben-Gurion University, Beer Sheva, Israel 84105
b Faculty of Industrial Engineering and Management, Technion—Israel Institute of Technology, Haifa, Israel 32000

Received 24 January 2007; received in revised form 3 June 2007; accepted 11 July 2007

Available online 5 September 2007

Abstract

Classical work on eliciting and representing preferences over multi-attribute alternatives has attempted to recognize conditions
under which value functions take on particularly simple and compact form, making their elicitation much easier. In this paper
we consider preferences over discrete domains, and show that for a certain class of simple and intuitive qualitative preference
statements, one can always generate compact value functions consistent with these statements. These value functions maintain
the independence structure implicit in the original statements. For discrete domains, these representation theorems are much more
general than previous results. However, we also show that it is not always possible to maintain this compact structure if we add
explicit ordering constraints among the available outcomes.
© 2007 Elsevier B.V. All rights reserved.

Keywords: Reasoning about preferences; Qualitative decision theory; Multi-attribute decision making

1. Introduction

The spectrum of practical problems that require reasoning about preferences is extremely wide. In this paper
we consider the problem of eliciting and reasoning about a user’s ordinal preferences. We are motivated in part by
the needs of large-scale, consumer product catalogs, an area that has received growing attention in the ﬁelds of the
database systems and AI (e.g., see [1,5,6,9,13,26,29,31]).

Online catalogs of products and information grow continuously, and with them grows the number of lay users
accessing these catalogs. While keyword search provides users with some means to access these catalogs, user needs
in such shopping contexts are typically more complex than in web search. In particular, users have personal preferences
regarding price, quality, features, etc., and these preferences can be rather complex. Therefore, it is natural to expect
that systems supporting this search process will aim to allow users to state their actual preferences, and that reasoning
about such preferences can improve the understanding of user needs.

Unfortunately, it appears that achieving both user-friendly, robust preference elicitation and efﬁcient reasoning
about the elicited information is not easy. The conﬂict between these two desiderata is reﬂected by the conﬂicting
forms in which a user might be asked to provide her preferences. On the one hand, if the user provides us with a

* Corresponding author.

E-mail addresses: brafman@cs.bgu.ac.il (R.I. Brafman), dcarmel@ie.technion.ac.il (C. Domshlak).

0004-3702/$ – see front matter © 2007 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2007.07.002

326

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

numerical value function over the space of the products (henceforth referred to as items), ordering the catalog with
respect to this function is easy. However, eliciting a quantitative description of preferences from the users is generally
a long, involved and time-consuming process that is often unintuitive to users. Alternatively, we can consider allowing
users to express their preferences using natural-language like qualitative statements, providing us with pieces of
preference information like (i) “For a family car, I prefer white color to all other colors”, or (ii) “This car is better for
me than that car”, or (iii) “This mini-van would be better in blue”, or (iv) “I like ecologically friendly cars”. This form
of preference elicitation is considered to be more natural to users [18], and thus dealing with this form of preference
information has received signiﬁcant attention in the multi-disciplinary preference literature (to name just a few works,
see [8,13,19,30,32]). Unfortunately, those preference expressions that can be reasoned about efﬁciently (at least for
ordering a given set of items) are required to be “syntactically homogeneous”, that is contain only statements in a
certain speciﬁc form [8,14]. For instance, to the best of our knowledge, there is no known general class of preference
expressions containing statements of both forms (i) and (ii) as above1 that can be reasoned with efﬁciently.

Striving to enjoy the pros of both a qualitative input and a quantitative representation of user preferences, in this
paper we consider compiling qualitative preference expressions into value functions consistent with the information
carried by these expressions. The main contributions of this paper are as follows:

1. We provide a new representation theory for generalized additive value functions [2,15], and specify conditions
under which there exists a particular factored value function consistent with (what is known about) the user’s
preference relation. Our representation theorems show that preference orders induced over the item space by
certain sets of qualitative statements of preference and importance can always be consistently captured by a
compact generalized additive value function. In particular, our results extend the classical representation theorems
for additive value functions over discrete variables [21]. As the conditions we require are much weaker than those
required for an additive representation, we are able to capture a signiﬁcantly wider spectrum of sets of natural
preference statements, namely those representable by the TCP-net model [10,12].

2. We show how our representation theory can be utilized in a computationally efﬁcient methodology for eliciting
and reasoning about ordinal preferences of the users. In this methodology, the user provides a set of qualitative
preference statements, and these statements are used to efﬁciently generate a compact value function whose
structure is based on the qualitative information supplied by the user. The key part is that the existence of such a
compact value function, its consistency with the preference statements of the user, and efﬁciency of its generation
are guaranteed by our representation theory.

3. In many applications, it is desirable to allow the users expressing not only structured preference information,
but also direct rankings between pairs of concrete items (e.g., see [5,20,26]). We consider the computational
consequences of supporting both general statements of preference and such pair-wise item rankings. On the
positive side, we show that such an extension can be straightforwardly supported in our methodology while
preserving its soundness and efﬁciency. On the negative side, however, we formally show that completeness of
structured value-function compilation is extremely sensitive to adding such item-level rankings. Speciﬁcally, we
show that completeness of value-function compilation cannot be guaranteed even if the amount of such pair-wise
item rankings is minimal, and that this impossibility result holds for most languages of generalizing preference
statements.

The rest of the paper is organized as follows. In Section 2 we provide some essential background on qualitative
preference statements targeted in this work, the TCP-model for modeling sets of such statements, and value functions.
Section 3 is devoted to the value-function compilation of three progressively more complicated classes of TCP-nets.
For clarity of presentation, the longer proofs are given in Appendix A. In Section 4 we consider extending structured
preference information with pairwise comparisons between completely speciﬁed alternatives, provide an impossibil-
ity theorem on value-function compilation of such mixed sets of statements, and generalize this result to a general
impossibility theorem. We summarize and list some open problems in Section 5.

1 Later we deﬁne these forms of statements in a formal manner.

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

327

2. Background and notation

Let Ω be a space of alternative items, where each item is described by an assignment to a certain ﬁnite set of
attributes (= variables) X = {X1, . . . , Xn} with domains dom(Xi), respectively. Without loss of generality, the item
space Ω is then considered to be Ω = ×dom(Xi). For instance, if Ω is the universe of descriptions of commercial
ﬂights for a certain time period, then the attributes might correspond to the departure time, airline, etc. Typically, the
set of available items is a subset of Ω, and is described by some database. However, although the user is familiar with
the item’s attributes, she does not know, a priori, what items appear in this database. In this work, we assume that all
dom(Xi) are ﬁnite, and thus Ω is ﬁnite as well.

To ﬁx the basic notation, in what follows we use regular uppercase letters X, Y, . . . for variables, regular lowercase
letters x, y, . . . for values of individual variables, calligraphic uppercase letters X , Y, . . . for sets of variables, and
bold lowercase letters x, y, . . . for assignments to sets of variables.

In the rest of this section we deﬁne a set of qualitative preference statements, a graphical structure that is used to

analyze them, and the type of value functions into which these statements will be compiled.

2.1. Qualitative preference statements

Our primary aim as a system is to build a model of the ordinal preferences of a given user over Ω. Our basic
assumption is that there exists a relatively compact and sufﬁciently accurate representation of the user’s preferences
in terms of X . In turn, to actually build an effective user model we obviously need information about the user’s
preference relation over different assignments to X . Focusing on qualitative preference information, we begin with
considering two types of natural preference statements, together with a set of preferential independence assumptions
that are implicit in the user’s speciﬁcation.

(1) (Conditional) preference over attribute values.

For example, “I prefer British Airways to Air France” is a statement of unconditional value preference over
the domain of the airline attribute. In turn, “I prefer British Airways to Air France in morning ﬂights” is a
statement of conditional value preference over the domain of the airline attribute, conditioned by the value of
the departure-time attribute.

(2) (Conditional) relative importance between pairs of attributes.

For example, “Departure time is more important to me than airline” is a statement of unconditional relative
importance between the attributes departure-time and airline, while “Departure time is more important
to me than airline if I’m ﬂying business class” is a conditional relative importance statement; the value of the
class attribute affects the relative importance between the attributes departure-time and airline.

Each such statements is taken as deﬁning a partial order over the items, using the ceteris paribus semantics [19]. That
is, if the user states that he prefers Delta to United, we take it to mean that given two ﬂights with identical attribute
values, except for the airline, we prefer that in which the airline is Delta to that in which the airline is United. If the
statement is conditioned on the fact that the ﬂight is overnight, the same interpretation holds, except that it applies
only to comparison between overnight ﬂights. Similarly, for importance relations, if I state that departure time is more
important than airline, then given two ﬂights that are identical, except for their departure time and airline, I prefer the
one that provides a more favorable departure time. A set of preference statements corresponds to the union of these
partial orders.2

2.2. TCP-nets

The language discussed above provides a relatively rich set of qualitative statements about outcomes with discrete-
valued attributes. We wish to compile this language into compact value functions. In [12] it was shown that a set
of preference statements from the above families can be organized within a graphical structure called TCP-net, an

2 This begs the question of the consistency of such a set, which we touch upon later. See [12] for more details.

328

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

extension of the CP-nets model [8]. This graphical structure plays an important role in analyzing and compiling this
language. Here we introduce TCP-nets in depth sufﬁcient for our purposes only, and refer the interested reader to [12]
for a detailed and systematic formalization of this model.

TCP-nets are annotated graphs with three types of edges. The nodes in TCP-nets correspond to the problem vari-
ables X (or to a subset of X if some variables are not addressed by the user statements). The ﬁrst type of (directed)
edge captures direct preferential dependencies between the variables, that is, such an edge from X to Y implies that
the user has different preferences over Y values given different values of X. The second (directed) edge type captures
relative importance relations. The existence of such an edge from X to Y implies that it is more important to satisfy
preferences with respect to X rather than preferences with respect to Y (denoted as X (cid:2) Y ). The third (undirected)
edge type captures conditional importance relations: Such an edge between nodes X and Y exists if different con-
ditions (i.e., certain assignments to some set of variables S) lead to X (cid:2) Y , Y (cid:2) X, or even to absence of relative
importance between X and Y at all.

Each node X in a TCP-net is annotated with a conditional preference table (CPT). This table associates a preference
ordering over dom(X) with every possible value assignment to the parents of X (denoted UX). In addition, in TCP-
nets, each undirected edge is annotated with a conditional importance table (CIT). The CIT associated with such an
edge γ = (X, Y ) describes the relative importance of X and Y given the value of the conditioning variables Sγ .

Deﬁnition 1. (See [12]). A TCP-net N is a tuple (cid:3)X , cp, i, ci, cpt, cit(cid:4) where:

(1) X is a set of nodes, corresponding to the problem variables {X1, . . . , Xn}.
(2) cp is a set of directed cp-arcs {α1, . . . , αk} (where cp stands for conditional preference). A cp-arc (cid:3)

−−−−−→
Xi, Xj (cid:4) is in
N iff the preferences over the values of Xj depend on the actual value of Xi . For each X ∈ X , let UX = {X(cid:7) |
−−−−→
X(cid:7), X(cid:4) ∈ cp}.
(cid:3)

(3) i is a set of directed i-arcs {β1, . . . , βl} (where i stands for importance). An i-arc (
(4) ci is a set of undirected ci-arcs {γ1, . . . , γm} (where ci stands for conditional importance). A ci-arc γ = (Xi, Xj )
is in N iff there are certain conditions under which one variable is more important than the other, but the relative
importance between Xi and Xj is fully determined by the value of some selector set Sγ ⊆ X \ {Xi, Xj }.

(5) cpt associates a CPT with every node X ∈ X , where CPT(X) is a mapping from dom(UX) (i.e., assignments to

−−−−−→
Xi, Xj ) is in N iff Xi (cid:2) Xj .

X’s parent nodes) to strict partial orders over dom(X).

(6) cit associates with every ci-arc γ = (Xi, Xj ) a (possibly partial) mapping CIT(γ ) from dom(Sγ ) to orders over

the set {Xi, Xj }.3

For those familiar with the original CP-net model, we note that a CP-net is simply a TCP-net in which the sets i
and ci (and therefore cit) are empty. Fig. 1 illustrates an example TCP-net for selecting a business ﬂight from Israel to
a conference in USA, borrowed from [12]. This network consists of ﬁve variables, standing for various parameters of
the ﬂight4:

• D—Departure day. Our busy, married user prefers ﬂights leaving one day (D1d ) before the conference to ﬂights

leaving two days (D2d ) before the conference.

• A—Airline. Our user prefers British Airways (Aba) to KLM (Aklm).
• T —Departure time. When leaving two days before the conference, our user prefers the later night ﬂight (Tn) to
the earlier day ﬂight (Td ). When leaving just one day before the conference, these preferences are reversed.
• S—Stop-overs. On day ﬂights, our user would like to have a smoking break, so he prefers an indirect ﬂight (S1s)

to a direct ﬂight (S0s). On night ﬂights, he sleeps well, and so prefers the shorter, direct ﬂight.

• C—Class. On a night ﬂight, our user prefers the cheaper economy (Ce) seats because he sleeps anyways, but

wants to enjoy business class (Cb) service on day ﬂights.

CP-arcs and CPTs in Fig. 1 capture these preference statements and the underlying preferential dependencies. Our
user’s relative importance relations are as follows: There is an i-arc from T to A: getting a more suitable ﬂying time

3 That is, the relative importance relation between Xi and Xj may be speciﬁed only for certain values of the selector set.
4 Variables in this example are binary, but the semantics of TCP-nets is deﬁned with respect to arbitrary ﬁnite domains.

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

329

Fig. 1. A TCP-net from the ﬂight selection domain.

is more important than getting the preferred airline. There is a ci-arc between S and C, where the relative importance
of S and C depends on the values of T and A (see the corresponding CIT): (i) On KLM day ﬂights, an intermediate
stop in Amsterdam is more important than ﬂying business class. (Our user likes the casino in Amsterdam’s airport.)
(ii) On British Airways day ﬂights, business class is more important than a stop-over. (Smoking areas in Heathrow are
depressing.)

The semantics of a TCP-net N is deﬁned in terms of preference rankings consistent with the constraints imposed
by cpt and cit of N , that is, strict partial orders consistent with the partial order induced by N . The local constraints are
interpreted ceteris paribus. For example, the fact that in the CPT for departure time (T ) we have that Tm (cid:9) Tn given
D = D1d implies that, given two ﬂights departing one day before the conference that differ only in their departure
time, the user prefers the one leaving in the morning to the one leaving at night. (Preference between alternative
values x1, x2 of a variable X ∈ X given an assignment u to the parents UX is denoted as N |= x1 (cid:9)u x2, or simply as
N |= x1 (cid:9) x2 if the assignment to parent variables u is clear from the context.) The fact that T is more important than
A implies that given two ﬂights that are identical, except for the value of T and A, the user prefers the one in which T
is assigned a better value regardless of the value of A. Similar semantics is given to conditional importance relation,
taking into account the requirement for the conditioning variables (the selector set). A TCP-net N is consistent iff
there is some strict partial order (cid:9) consistent with it. For all o, o(cid:7) ∈ Ω, o (cid:9) o(cid:7) is implied by a TCP-net N (denoted as
N |= o (cid:9) o(cid:7)) iff it holds in all strict partial orders consistent with N , and this preferential entailment with respect to a
consistent TCP-net is transitive. (For the formal semantics in detail, see [12]).

The structure of the TCP-net was shown to be useful for (a) recognizing the (in)consistency of user preference
statements, and (b) performing efﬁcient inference. In Section 3 we will show that it can also be exploited in identifying
compact value functions consistent with the user’s preferences. We reemphasize that this graphical structure is used
for analysis purpose (although it can be used for describing preferences, if so desired). Users are not expected to
specify the explicit graphical model nor need they be aware of its existence. They simply need to verbalize statements
of the two kinds discussed earlier. The system can easily construct the corresponding TCP-net automatically. Nor are
the users required to provide statements that specify the CPTs completely (e.g., as in Bayes nets). This property is
especially important in practice as users should not be required to express every nuance of their preferences.

2.3. Value functions and GA-decomposition

We wish to map a set of preference statements into a numeric value function. A value function v : Ω → R is a real-
valued function deﬁned over the space of all possible assignments on X , that is, over our item space. Value function v
is consistent with a (possibly partial) preference ordering (cid:2) of the user iff v(o) > v(o(cid:7)) for all o (cid:9) o(cid:7), and v(o) (cid:3) v(o(cid:7))
for all o (cid:2) o(cid:7). As the size of Ω is exponential in the number of problem variables, only compactly representable value
functions can be practically useful.

330

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

In this work we focus on one such family of compactly representable value functions, namely generalized additive
(GA) value functions. The notion of GA value functions closely corresponds to the notion of generalized additive
independence for cardinal utility functions [2,15], but addresses only the structural assumptions of the latter. A value
function v over the variables X is GA if there exists a cover of X by some of its subsets X1, . . . , Xk such that
(cid:2)
k
v(X ) =
i=1 vi(Xi). In what follows, we refer to these variable subsets X1, . . . , Xk as the factors of v. Notice that
any value function can be seen as GA (for k = 1), but working with a GA value function is practically feasible only if
its factors are sufﬁciently compact and the number of essential factors k is small, e.g., both k and the size of each Xi
are bounded by a constant. In general, this brings us to the specify the notion of GA-decomposition of a preference
ordering.

Deﬁnition 2. Given a (possibly partial) preference ordering (cid:2) over Ω = dom(X ), and a cover X1, . . . , Xk of X , we
say that (cid:2) is GA-decomposable over X1, . . . , Xk if there exists a real-valued function

v(X ) =

k(cid:3)

i=1

φi(Xi),

(1)

consistent with (cid:2). In particular, we say that a TCP-net N over X is GA-decomposable over X1, . . . , Xk if there exists
a real-valued function v as in Eq. (1) such that, for all ø, o(cid:7) ∈ Ω, if N |= o (cid:9) o(cid:7), then v(o) > v(o(cid:7)).

3. From qualitative preferences to GA value functions

Value functions provide a mathematically general and efﬁcient way of representing and reasoning with preference
information. Given a value function, we can quickly sort a given database of items or determine the top-k of its items.
However, obtaining a value function directly from the user is signiﬁcantly more involved than obtaining a set of simple
preference statements. Therefore, we propose to

1. use a TCP-net to initially organize the qualitative preference statements obtained from the user,
2. compile this information to a value function that maintains the qualitative structure and independence assump-

tions implicit in this TCP-net,

3. use the obtained value function as the model of user’s ordinal preference,
4. as new information comes from the user, reﬁne this value function, while still maintaining independence assump-

tions implied by the original TCP-net, if possible.

Note that the basic idea of such value-function compilation framework is not new, and it was considered in the
literature before with respect to some other forms of qualitative preference information [3,17,27]. The precise relation
to previous works is established later in Section 5.

The main theoretical question we face is: Given a TCP-net N as input, can we efﬁciently generate a value function
v that is consistent with N ? Of course, it is quite trivial to see that, for any consistent TCP-net, there exists at least
one value function consistent with it. Indeed, this is true for any partial order. However, what we would really like to
know is whether we can ﬁnd a structured value function that, in some sense, is as compact as the original TCP-net.
Speciﬁcally, we would like to know whether there exists a GA value function deﬁned over small factors “implied” by
the structure of the network.

To answer this question, we consider three progressively more complicated classes of TCP-nets, and show how the
factors of GA value functions representing these TCP-nets relate to their graphical structure. We prove this relation by
showing that for every TCP-net in each of these network classes there exists a GA value function over a particular set
of factors. Likewise, our representation results provide us with a concrete computational mechanism for generating
such GA value functions, tractable for a wide class of TCP-nets.

3.1. GA-decomposition of CP-nets

First, we consider CP-nets [8], that is, TCP-nets with only cp-arcs, and start with some notation. Given a CP-net
N = (cid:3)X , cp, ∅, ∅, cpt, ∅(cid:4) over variables X , let UX and YX be the sets of parents and (immediate) children of X in

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

331

Fig. 2. CP-family and extended CP-family of X.

FY denote the extended
N , respectively. Let FX = {X} ∪ UX denote the CP-family of X, and EF X = FX ∪
CP-family of X. That is, the set EF X contains X, its parents, its children, and the parents of its children. This set is
also known as the Markov Blanket of X, and it is illustrated in Fig. 2. Finally, given two assignments z, z(cid:7) to a pair of
subsets Z, Z (cid:7) ⊆ X , respectively, we say that z and z(cid:7) are compatible, denoted by z (cid:12)(cid:13) z(cid:7), if z and z(cid:7) provide the same
value to all the shared variables Z ∩ Z (cid:7).

Y ∈YX

(cid:4)

The following CP-condition, originally introduced in [7] for deﬁning real-valued value functions representable as
UCP-nets, plays a central role in our discussion. To understand this condition better, one has to understand that our
goal now is to show that for a CP-net, we can deﬁne a consistent value function that is a sum of smaller functions, each
of which depends on a single family within the network. That is, we would like a GA value function whose factors are
the families of the CP-net.

Consider the family FX of some variable X. Let φX be the component of a GA value function as above that
corresponds to this family. Consider some assignment u to the parents of X. φX(·, u) is then a function of X. We
would expect it to provide higher values to assignment to X that the user prefers given u. However, this condition
is not sufﬁcient to ensure that the value function be consistent with the stated preferences. To see this, suppose that
N |= x1 (cid:9)u x2. It is possible that φX(x1, u) > φX(x2, u), yet for some assignment w to the rest of the variables,
v(x1, u, w) < v(x2, u, w). This can be the case because in the context of w, the value of some child of X is much
higher given x1 than given x2. Thus, while x2 does not seem to contribute too much directly, it makes the contribution
of some other assignment much higher. For an illustration, consider a CP-net N over two variable X and Y , with
(parent-less) X being the parent of Y . Let N |= x1 (cid:9) x2 for some x1, x2 ∈ dom(X). From the semantics of TCP-nets,
we then have N |= x1y (cid:9) x2y for any y ∈ dom(Y ). Now, let v(X, Y ) = φX(X)+φY (Y, X) be a GA value function with
the structure as required such that φX(x1) = 1, φX(x2) = 0, φY (y, x1) = 0, and φY (y, x2) = 2. While the condition
φX(x1) > φX(x2) is satisﬁed, we have φY (y, x1) < φY (y, x2), violating the consistency of v with N .

The CP-condition as speciﬁed in Deﬁnition 3 below rules out this possibility, making the sum of direct and indirect
contributions of a less favored value smaller than that of a more favored value. Note that the direct and indirect
contributions of an assignment to X depend on (and only on) the extended family of X: its parents determine its direct
contribution, and its children’s parents determine its indirect contribution.

Deﬁnition 3. Given a CP-net N , and a set of non-negative real-valued functions Φ = {φX1, . . . , φXn} over
FX1, . . . , FXn , respectively, we say that Φ satisﬁes the CP-conditions of N if and only if for each variable X ∈ X ,
each u ∈ dom(UX), and each x1, x2 ∈ dom(X), if N |= x1 (cid:9)u x2, then for each v ∈ dom(EF X \ {X}) compatible with
u we have:

|YX|(cid:3)

φX(x1, u) +

φYi (vi, x1) > φX(x2, u) +

i=1
where vi is the value provided by v to (FYi

\ {X}).

|YX|(cid:3)

i=1

φYi (vi, x2)

(2)

Developed by Boutilier et al. [7], Lemma 1 below exploits the CP-conditions of N to provide a necessary and

sufﬁcient condition for a GA value function with factors FX1, . . . , FXn to be consistent with N .

332

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

Lemma 1. (See [7]). Given a CP-net N , and a function

v(X ) =

n(cid:3)

i=1

φXi (FXi ),

we have v consistent with N iff {φX1, . . . , φXn} satisfy the CP-conditions of N .

(3)

In fact, Lemma 1 provides us with even stronger knowledge on GA-decomposability of N . First, reasonably as-
suming that no preferential dependency between X and UX is redundant, one could not expect a more compact
GA-decomposition of N . Second, CP-conditions actually provide us with a concrete procedure for generating such a
value function v:

(1) Given a CP-net N , construct a system of linear inequalities L, the variables of which stand for the entries of the
factors φX1, . . . , φXn and inequalities correspond to all the required instances of Eq. (2). Let HL be the polytope
deﬁned by L.

(2) If L is satisﬁable (that is, HL is not empty), pick any solution for L. The latter selection can be done, for instance,
by solving a linear program deﬁned by L and an arbitrary linear objective function bounded on HL [4], or by
sampling a point from HL.

Step (2) is correct because any solution of L constitutes a value function v of form (3), consistent with N . The
complexity of L is only locally exponential: the number of variables and inequalities in L is O(ndλ) and O(nd 2μ),
respectively, where d = maxX∈X {|dom(X)|}, λ = maxX∈X {|FX|}, and μ = maxX∈X {|EF X|}. Finally, since linear
programming is in P, we obtain the following corollary of practical interest.

Corollary 2. If a CP-net N is GA-decomposable over its CP-families, and we have maxX∈X {|EF X|} = k for some
(cid:2)
n
i=1 φXi (FXi ) consistent with N can be constructed in time polynomial in
constant k, then a value function v(X ) =
the size of N .

Corollary 2 presents a wide class of efﬁciently GA-decomposable CP-nets. However, notice that nothing so far
prevents HL from being empty, since Lemma 1 provides no guarantees for the actual GA-decomposability. It is
possible that, for some CP-nets, value functions of form (3) simply do not exist. As we would like to assume that
user’s statements provide us with sufﬁcient information about value independence, such incompleteness would clearly
be problematic. Fortunately, Theorem 3 below shows that polytopes HL for acyclic CP-nets are always non-empty.

Theorem 3. Every acyclic CP-net is GA-decomposable over its CP-families.

To relate Theorem 3 to the classical results in multi-attribute decision theory, consider a CP-net without any edges.
According to Theorem 3, such a CP-net induces an additive value function, that is, for 1 (cid:4) i (cid:4) n, the factor Xi consists
of exactly one variable Xi . Indeed, variables in such a CP-net are mutually preferentially independent, a necessary
and sufﬁcient condition for additive decomposition (see Theorem 3.6 in [21]). Thus, a representation theorem for
standard additive value functions over discrete variables5 is a special case of our Theorem 3. As far as we know,
results on conditional structures and generalized additive decomposability exist for cardinal utility functions [2], but
require complex conditions which do not seem to relate in any simple manner to the above result.

Example 1. To illustrate the above procedure for value-function generation, consider the CP-net N depicted in
Fig. 3(a). This CP-net is deﬁned over three binary-valued variables X, Y , and Z, and one ternary variable U . The
linear system L encoding the CP-conditions of N is as follows.

First, for the parent-less variable U , we have N |= u1 (cid:9) u3 and N |= u2 (cid:9) u3, YU = {X}, and FX \ {U } = {X}.

Given that, the CP-conditions “for U ” are

5 Here we note that the classical results on additive decomposition cover continuous variables as well, whereas we deal with discrete variables
only.

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

333

Fig. 3. (a) The CP-net for Example 1; (b) The value function generated for that CP-net—each table associated with a variable captures the
sub-function over the corresponding factor.

φU (u1) + φX(x1, u1) > φU (u3) + φX(x1, u3),
φU (u1) + φX(x2, u1) > φU (u3) + φX(x2, u3),
φU (u2) + φX(x1, u2) > φU (u3) + φX(x1, u2),
φU (u2) + φX(x2, u2) > φU (u3) + φX(x2, u2).

(4)

Similarly, for the parent-less variable Z, we have N |= z1 (cid:9) z2, children YZ = {Y }, but the set FY \ {Z} = {Y, X} is
not a singleton. The CP-conditions “for Z” are thus

φZ(z1) + φY (y1, x1, z1) > φZ(z2) + φY (y1, x1, z2),
φZ(z1) + φY (y1, x2, z1) > φZ(z2) + φY (y1, x2, z2),
φZ(z1) + φY (y2, x1, z1) > φZ(z2) + φY (y2, x1, z2),
φZ(z1) + φY (y2, x2, z1) > φZ(z2) + φY (y2, x2, z2).

(5)

Next, consider the variable X with UX = {U }. Considering dom(U ) and the CPT of X, we have only N |= x1 (cid:9)u1 x2.
Thus, given YX = {Y }, and FY \ {X} = {Y, Z}, we have

φX(x1, u1) + φY (y1, x1, z1) > φX(x2, u1) + φY (y1, x2, z1),
φX(x1, u1) + φY (y1, x1, z2) > φX(x2, u1) + φY (y1, x2, z2),
φX(x1, u1) + φY (y2, x1, z1) > φX(x2, u1) + φY (y2, x2, z1),
φX(x1, u1) + φY (y2, x1, z2) > φX(x2, u1) + φY (y2, x2, z2).

(6)

Finally, from the CPT of the child-less variable Y with UY = {X, Z}, we have N |= y1 (cid:9)x1z1 y2, N |= y2 (cid:9)x2z1 y1, and
N |= y2 (cid:9)x2z1 y1. Hence, the CP-conditions “for Y ” are

φY (y1, x1, z1) > φY (y2, x1, z1),
φY (y2, x2, z1) > φY (y1, x2, z1),
φY (y2, x2, z2) > φY (y1, x2, z2).

(7)

Together, Eqs. (4)–(7) provide us with 15 linear constraints L over 19 variables, and these constraints constitute the
CP-conditions of N . At the second step of the value-function generation procedure we should then pick an arbitrary
solution to L, and this can be done in numerous ways. For instance, solving (in polynomial time [4]) the quadratic
program aiming at resolving L with margin (cid:9) > 0 while (i) keeping the vector of variables in the positive quadrant,
and (ii) minimizing the (cid:10)2-norm of that vector, provides us with the solution (= value function) depicted in Fig. 3(b).
(For readability, and without loss of generality, we have subtracted (cid:9) from the values of all the variables of L.)

334

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

3.2. GA-decomposition of TCP-nets with no ci-arcs

Now, let us consider a wider class of TCP-nets, namely TCP-nets with no ci-arcs. Here we show that, assuming the
TCP-net remains acyclic, the GA-decomposability of this class of networks N = (cid:3)X , cp, i, ∅, cpt, ∅(cid:4) is not affected
by the relative importance statements. We do need, however, to change the constraints used to generate this value
function. We begin by formalizing a new set of conditions essential for analysis of GA-decomposability of this class
of networks.

Deﬁnition 4. Given a TCP-net N with no ci-arcs, and a set of non-negative real-valued functions Φ = {φX1, . . . , φXn}
−−−−→
X, X(cid:7)) ∈ N ,
over FX1, . . . , FXn , respectively, we say that Φ satisﬁes the I-conditions of N if and only if for each i-arc (
each u ∈ dom(UX), and each x1, x2 ∈ dom(X), if N |= x1 (cid:9)u x2 then, for each x(cid:7)
∈ dom(X(cid:7)), each u(cid:7) ∈ dom(UX(cid:7) )
compatible with u, and each v ∈ dom(EF X \ {X, X(cid:7)}), v(cid:7) ∈ dom(EF X(cid:7) \ {X, X(cid:7)}) compatible with u and u(cid:7), we have:
X(cid:7) \YX|(cid:3)

1, x(cid:7)

|YX|(cid:3)

|Y

2

φX(x1, u) + φX(cid:7)

(x

(cid:7)

1, u(cid:7)

) +

φYi (vi, x1, x

(cid:7)
1) +

φY (cid:7)

i (v(cid:7)

i, x

(cid:7)
1, x1)

i=1

i=1

> φX(x2, u) + φX(cid:7)

(x

(cid:7)

2, u(cid:7)

) +

|YX|(cid:3)

i=1

φYi (vi, x2, x

(cid:7)
2) +

|Y

X(cid:7) \YX|(cid:3)

i=1

φY (cid:7)

i (v(cid:7)

i, x

(cid:7)
2, x2)

(8)

where vi and v(cid:7)
and x(cid:7)

i are the values provided by v and v(cid:7) to (FYi

\ {X, X(cid:7)}) and (F

\ {X, X(cid:7)}), respectively. Note that x(cid:7)
1

Y (cid:7)
i

2 (similarly, x1 and x2) might be redundant parameters for some φYi (respectively, φY (cid:7)
i ).

This condition may look complicated, but the intuition behind it is simple. The idea is to provide constraints on the
value function that ensure that X is more important than X(cid:7). Recall that if X is more important than X(cid:7) then given two
assignments that are identical on variables other than X and X(cid:7), we prefer the one that has a better X value, regardless
of its value on X(cid:7). This requirement translates into the above I-condition. Previously, the CP-condition required that
if x1 is preferred to x2 given u then the sum of contributions of the factors that correspond to the extended family of
X be higher for x1 than for x2 given any ﬁxed context. This context consisted of the extended family of X. Now, we
require that this condition will hold even if we change the value of X(cid:7). Thus, we must take into account the direct and
indirect effects of this change in the value of X(cid:7). These depend only on the extended family of X(cid:7). Thus, at each side
of the inequality in Eq. (8), we see a sum that corresponds to the extended families of X and X(cid:7).

It turns out that the I and CP-conditions together constitute for TCP-nets with no ci-arcs exactly what the CP-

conditions alone constitute for CP-nets.

Lemma 4. Given a TCP-net N with no ci-arcs, and a function v(X ) =
with N if and only if {φX1, . . . , φXn} satisfy both the CP and I-conditions of N .

(cid:2)
n
i=1 φXi (FXi ), we have that v is consistent

Notice that, similarly to the case of CP-nets, Lemma 4 provides TCP-nets with no ci-arcs with a procedure for
generating consistent GA value functions of the form as in Eq. (3). However, an immediate concern should be its
usefulness: At ﬁrst sight, such decomposition does not seem to be very likely, as the functional form in Eq. (3) is
based only on preference dependencies, completely ignoring the importance relations induced by the i-arcs. Theorem 5
shows that these concerns are not entirely justiﬁed, and that value decomposition of form (3) is complete for acyclic
TCP-nets with no ci-arcs. (Since all the arcs in such networks are directed, the corresponding notion of acyclicity is
straightforward.)

Theorem 5. Every acyclic TCP-net with no ci-arcs is GA-decomposable over its CP-families.

Theorem 5 shows that additional unconditional relative importance relation do not affect GA-decomposability of
the network (assuming it remains acyclic). Lemma 4 shows that any such GA value function corresponds to a solution
of a linear system L, as in the case of CP-nets. Still locally exponential, the complexity of L, however, is affected
by i-arcs, since now L consists of both instances of Eqs. (2) and (8). As a result, the number of variables in L is still

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

335

Fig. 4. (a) TCP-net with no ci-arcs for Example 2; (b) The value function generated for that TCP-net.

O(nd λ), but the number of equations grows to O((n + l)d 2μ), where l is the number of i-arcs in N . Notice that the
order of description complexity of L remains the same as for CP-nets, thus Corollary 2 can be re-stated for TCP-nets
with no ci-arcs, all else being equal.

−−−→
Example 2. Consider the TCP-net N in Fig. 4(a) that extends the CP-net from Example 1 by an i-arc (
X, Z). The
CP-conditions of N are identical to these in Example 1, that is, given by the linear constraints in Eqs. (4)–(7). The
−−−→
X, Z), and these correspond (only) to the preference of X = x1 to X = x2
I-conditions of N are (only) due to the i-arc (
given U = u1. Thus, the I-conditions of N are

φX(x1, u1) + φZ(z1) + φY (y1, x1, z1) > φX(x2, u1) + φZ(z2) + φY (y1, x2, z2),
φX(x1, u1) + φZ(z1) + φY (y2, x1, z1) > φX(x2, u1) + φZ(z2) + φY (y2, x2, z2),
φX(x1, u1) + φZ(z2) + φY (y1, x1, z2) > φX(x2, u1) + φZ(z1) + φY (y1, x2, z1),
φX(x1, u1) + φZ(z2) + φY (y2, x1, z2) > φX(x2, u1) + φZ(z1) + φY (y2, x2, z1).

(9)

Solving the linear system L obtained from the union of Eqs. (4)–(7) and Eq. (9) using the same quadratic pro-
gramming approach as in Example 1 we generate the value function depicted in Fig. 4(b). Note that the only
difference between the value functions in Figs. 3(b) and 4(b) is that the former has φX(x1, u1) = 2 while the lat-
ter has φX(x1, u1) = 3—the relative importance of preference over X is getting captured.

3.3. GA-decomposition of TCP-nets

We now consider TCP-nets capturing all our types of preference statements, thus consisting of both directed (cp
and i) and undirected (ci) arcs. Recall that the selector set of a ci-arc is the set of variables that determine which end
of this edge is more important. Let SX be the union of selector sets of ci-arcs involving X, that is,

(cid:5)

SX =

Sγ .

γ =(X,X(cid:7))

Reversely, let WX be the set of end-point variables of ci-arcs where X acts as a selector, that is,

WX = {X

(cid:7) | X ∈ SX(cid:7)}.

= YX ∪ WX be the set of all X’s “direct dependents”. Let IX|s be the set of all variables X(cid:7) that are directly
Let Y (cid:11)
−−−−→
X
more important than X given s ∈ dom(SX). That is, for each X(cid:7) ∈ IX|s, either we have an i-arc (
X(cid:7), X) ∈ N , or we
have a ci-arc (X(cid:7), X) ∈ N and CIT of this arc stipulates that, given s, we have that X(cid:7) is more important than X.
= FX ∪ SX denote the TCP-family of X (see Fig. 5, where the dashed arcs schematically connect
Finally, let F (cid:11)
X
between SX and X), and EF (cid:11)
Y denote the extended TCP-family of X.
X

= F (cid:11)
X

F (cid:11)

(cid:4)

Y ∈Y (cid:11)
X

336

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

Fig. 5. TCP-family of X.

TCP-nets with ci-arcs are signiﬁcantly richer than these without, and a GA-decomposition as in Eq. (3) is not
expressive enough to cover this type of networks. However, here we show that there exists a sufﬁciently expressive
(yet often compact) extended counterpart of Eq. (3), namely:

v(X ) =

n(cid:3)

i=1

φXi (F (cid:11)
Xi

).

(10)

Deﬁnition 5. Consider a TCP-net N , and a set of non-negative, real-valued functions Φ = {φX1, . . . , φXn } over
, respectively. We say that Φ satisﬁes the CI-conditions of N if and only if for each ci-arc (X, X(cid:7)) ∈ N
F (cid:11)
X1
−−−−→
X, X(cid:7)) ∈ N ), each x1, x2 ∈ dom(X), and each u ∈ dom(UX) and s ∈ dom(SX), if X ∈ IX(cid:7)|s
∈ dom(X(cid:7)), and each set of (all pairwise compatible) u(cid:7) ∈ dom(UX(cid:7) ),

, . . . , F (cid:11)
Xn
(and, similarly, each i-arc (
and N |= x1 (cid:9)u x2, then, for each x(cid:7)
s(cid:7) ∈ dom(SX(cid:7)), v ∈ dom(EF (cid:11)
X

1, x(cid:7)
2
\ {X, X(cid:7)}), v(cid:7) ∈ dom(EF (cid:11)

X(cid:7) \ {X, X(cid:7)}), we have:

φX(x1, u, s) + φX(cid:7)

(x

(cid:7)

1, u(cid:7)

, s(cid:7)

) +

|Y (cid:11)
|(cid:3)
X

i=1

φYi (vi, x1, x

(cid:7)
1) +

|Y (cid:11)

X(cid:7) \Y (cid:11)
|(cid:3)

X

i=1

φY (cid:7)

i (v(cid:7)

i, x

(cid:7)
1, x1)

> φX(x2, u, s) + φX(cid:7)

(x

(cid:7)

2, u(cid:7)

, s(cid:7)

) +

|Y (cid:11)
|(cid:3)
X

i=1

φYi (vi, x2, x

(cid:7)
2) +

|Y (cid:11)

X(cid:7) \Y (cid:11)
|(cid:3)

X

i=1

φY (cid:7)

i (v(cid:7)

i, x

(cid:7)
2, x2)

(11)

where vi and v(cid:7)
1 and x(cid:7)
tion 4, x(cid:7)

i are the value provided by v and v(cid:7) to (F (cid:11)
Yi
2 (similarly, x1 and x2) might be redundant in some φYi (respectively, φY (cid:7)
i ).

\ {X, X(cid:7)}) and (F (cid:11)
Y (cid:7)
i

\ {X, X(cid:7)}), respectively. As in Deﬁni-

The form of the CI-condition is identical to that of the I-condition. The difference is that it is more constrained,

requiring a particular assignment to the appropriate selector sets.

For GA-decomposition as in Eq. (10), the CP-conditions that work for CP-nets and TCP-nets with no ci-arcs will
not work anymore. To understand this, recall that the original CP-conditions ensured that the total contribution of a
more preferred value for X will be larger than the total contribution of a less preferred value. This total contribution
included the effect of an assignment to X on its children. Now, the total contribution of X depends on additional
elements. First, X might participate in a ci-arc, in which case its value depends on the selector set for this edge.
Moreover, X might inﬂuence the relative importance of other variables in whose selector sets it belongs. Here we
provide a modiﬁed set of CP-conditions compatible with value decomposition as in Eq. (10). In fact, the modiﬁcation
brought by Deﬁnition 6 is schematically simple: To ﬁt the functional form (10), the CP-conditions as in Deﬁnition 3
should be simply reformulated from CP- to TCP-families.

Deﬁnition 6. Consider a TCP-net N , and a set of non-negative real-valued functions Φ = {φX1, . . . , φXn} over
, respectively. We say that Φ satisﬁes the CP-conditions of N if and only if for each X ∈ X , each
F (cid:11)
X1

, . . . , F (cid:11)
Xn

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

337

u ∈ dom(UX) and s ∈ dom(SX), and each x1, x2 ∈ dom(X), if N |= x1 (cid:9)u x2 then, for each v ∈ dom(EF (cid:11)
X
compatible with u and s we have:

\ {X})

φX(x1, u, s) +

|Y (cid:11)
|(cid:3)
X

i=1

φYi (vi, x1) > φX(x2, u, s) +

|Y (cid:11)
|(cid:3)
X

i=1

φYi (vi, x2)

where vi is the value provided by v to F (cid:11)
Yi

\ {X}.

(12)

Lemma 6 below shows that the (modiﬁed) CP-conditions and CI-conditions are necessary and sufﬁcient for GA-

decomposability of general TCP-nets along the functional form as in Eq. (10).

Lemma 6. Given a TCP-net N , and a function v(X ) =
{φX1, . . . , φXn } satisfy CP- and CI-conditions of N .

(cid:2)
n
i=1 φXi (F (cid:11)
Xi

), we have v consistent with N if and only if

Again, Lemma 6 provides us with a mechanism for generating GA value functions consistent with TCP-nets,
similar to the procedures provided by Lemmas 1 and 4. Of course, the complexity of the corresponding linear
system L is not as before: The number of variables and inequalities in L is now O(nd λ(cid:7)
), where
|}, and μ(cid:7) = maxX∈X {|EF (cid:11)
λ(cid:7) = maxX∈X {|F (cid:11)
|}. Clearly, adding ci-arcs reduce the general compactness of GA-
X
X
decomposition, but factoring on TCP-families instead of CP-families seems unavoidable.

) and O(nd 2μ(cid:7)

Corollary 7. If a TCP-net N is GA-decomposable over its TCP-families, and we have maxX∈X {|EF (cid:11)
X
constant k, then a corresponding value function v(X ) =
size of N .

|} = k for some
) can be constructed in time polynomial in the

(cid:2)
n
i=1 φXi (F (cid:11)
Xi

Considering the completeness of GA-decomposition for general TCP-nets, it is unlikely that every consistent TCP-
net is GA-decomposable along the functional form as in Eq. (10). Yet, in Theorem 8 below we show that such
decomposability is complete for acyclic TCP-nets. Since TCP-nets may contain both directed and annotated undi-
rected arcs, the corresponding notion of acyclicity is non-standard.

Deﬁnition 7. (See [12]). The dependency graph N (cid:11) of TCP-net N contains all the nodes and edges of N . Additionally,
for every ci-arc (Xi, Xj ) in N and every Xk ∈ S(Xi ,Xj ), N (cid:11) contains a pair of directed edges (Xk, Xi) and (Xk, Xj ),
if these edges are not already in N .

Fig. 6 illustrates the notion of the dependency graph on the “Flight to US” TCP-net example from [12].

Deﬁnition 8. A TCP-net N is acyclic if each cycle in the undirected graph induced by the dependency graph N (cid:11),
when projected back to N (cid:11), contains a pair of directed arcs in different directions.6

For instance, the TCP-net N in Fig. 6(a) is acyclic—considering the cycle T–C–S in the undirected graph induced
by dependency graph N (cid:11), we see that the directed arcs from T to S and from T to C in N (cid:11) are oriented in two different
directions with respect to that cycle (and the same property holds for all the cycles in the undirected graph induced
by N (cid:11)).

Based on the notion of acyclic TCP-nets, Theorem 8 ﬁnalizes our representation theory.

Theorem 8. Every acyclic TCP-net is GA-decomposable over its TCP-families.

Example 3. Consider the TCP-net N in Fig. 7(a) that extends the CP-net from Example 1 by a ci-arc γ = (X, Z) with
Sγ = {U } and CIT(γ ) as in Fig. 7(a).

6 In particular, acyclic CP-nets are a sub-class of what is called conditionally acyclic TCP-nets, which today is probably the widest known
sub-class of consistent TCP-nets deﬁned in terms of structural properties of the networks [12].

338

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

Fig. 6. “Flight to USA” TCP-net (a), and its dependency graph (b) (from [12]).

Fig. 7. (a) Acyclic TCP-net with a ci-arc for Example 2; (b) The value function generated for that TCP-net.

First, note that the TCP-families of U , X, and Y are identical to the CP-families of these variables. While it is
easy to see for U and Y , for X this is the case because the only selector U of X already belongs to the parents UX
of X. From that, it is not hard to verify that the extended TCP-families of U , X, and Y are identical to their extended
TCP-families, and thus the CP-conditions of N for U , X, and Y are given by Eqs. (4), (6), and (7), respectively.
The situation with the variable Z is different because for Z we have FZ = {Z}, SZ = {U }, and thus F (cid:11)
Z

= {Z, U }.
Hence, in contrast to Example 1, the function φZ should now be deﬁned from dom(Z) × dom(U ), and the CP-
conditions for Z should be formulated according to Deﬁnition 6. These CP-conditions are given by Eq. (13) below.

∀u ∈ {u1, u2, u3} :
φZ(z1, u) + φY (y1, x1, z1) > φZ(z2) + φY (y1, x1, z2),
φZ(z1, u) + φY (y1, x2, z1) > φZ(z2) + φY (y1, x2, z2),
φZ(z1, u) + φY (y2, x1, z1) > φZ(z2) + φY (y2, x1, z2),
φZ(z1, u) + φY (y2, x2, z1) > φZ(z2) + φY (y2, x2, z2).

(13)

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

339

Next, the CI-conditions of N are given by Eqs. (14) and (15) below. For the domain of the selector set Sγ = {U }

we have

(1) IX|u1
(2) IX|u2
(3) IX|u3

= ∅, IZ|u1
= ∅, IZ|u2
= {Z}, IZ|u3

= {X} (X being more important than Z given u1),
= ∅ (given u2, the ci-arcγ simply vanishes), and
= ∅ (Z being more important than X given u3).

The CI-constraints corresponding to the case (1) are

φX(x1, u1) + φZ(z1, u1) + φY (y1, x1, z1) > φX(x2, u1) + φZ(z2, u1) + φY (y1, x2, z2),
φX(x1, u1) + φZ(z1, u1) + φY (y2, x1, z1) > φX(x2, u1) + φZ(z2, u1) + φY (y2, x2, z2),
φX(x1, u1) + φZ(z2, u1) + φY (y1, x1, z2) > φX(x2, u1) + φZ(z1, u1) + φY (y1, x2, z1),
φX(x1, u1) + φZ(z2, u1) + φY (y2, x1, z2) > φX(x2, u1) + φZ(z1, u1) + φY (y2, x2, z1).

(14)

Note that Eq. (14) is similar to Eq. (9) with φZ(z1) and φZ(z2) being respectively replaced with φZ(z1, u1) and
φZ(z2, u1), all else being identical. This similarity is not incidental as, given u1, the ci-arc (X, Z) is equivalent to the
i-arc (

−−−→
X, Z) from Example 2.

The CI-constraints corresponding to the case (3) are

φZ(z1, u3) + φX(x1, u3) + φY (y1, x1, z1) > φZ(z2, u3) + φX(x2, u3) + φY (y1, x2, z2),
φZ(z1, u3) + φX(x1, u3) + φY (y2, x1, z1) > φZ(z2, u3) + φX(x2, u3) + φY (y2, x2, z2),
φZ(z1, u3) + φX(x2, u3) + φY (y1, x2, z1) > φZ(z2, u3) + φX(x1, u3) + φY (y1, x1, z2),
φZ(z1, u3) + φX(x2, u3) + φY (y2, x2, z1) > φZ(z2, u3) + φX(x1, u3) + φY (y2, x1, z2).

(15)

Eq. (15) is structurally identical to Eq. (14), with the roles of X of Z being reversed.

Solving the linear system L obtained from the union of Eq. (4), Eqs. (6)–(7), and Eqs. (13)–(15) sing the same

quadratic programming approach as in Examples 1–2 we generate the value function depicted in Fig. 7(b).

4. Reﬁnement by item-level rankings

The goal of most preference elicitation systems is to help the user recognize the most preferred item among the
set of candidate items. The ceteris paribus semantics we used to model natural preference statements is intuitive,
but also weak. This implies that, typically, generalizing preference statements will only specify a partial order over
the items. Phrased differently, the set of value functions consistent with a set of statements will correspond to many
different orderings. Various systems attempt to further reﬁne the user’s preference information at this point. Here,
we concentrate on the case the user is asked to rank a small set of items. For instance, in [11], the user is presented
with the 10 top items according to one value function, and asked to point to the one most preferred amongst them.
This immediately yields 9 pairwise orderings between items. The question that we ask in this section is whether we
can integrate such explicit item rankings with the generalizing preference statements, while maintaining the compact
structure derived from these generalizing preference statements.

Our results are somewhat surprising. Obviously, if the user’s ranking contradict the generalizing statements (e.g.,
she ranks a red car above an identical blue car, despite stating that blue is her preferred color for cars), no value
function can model both. But what happens when the user’s rankings are consistent with her generalizing preference
statements? That is, there exists an ordering that satisﬁes both the user’s generalizing preference statements, as well
as her explicit relative ranking of some items. Clearly, such information can be modeled by some value function.
What is perhaps surprising, is that it is not always possible to model this information using the type of compact value
functions that can model the generalizing information alone. The proof of this result is unconstructive, and what we
ﬁnd puzzling about it, is that it is not obvious to see how such rankings violate the structural assumptions of the
underlying TCP-net.

For reasons that will be clear shortly, let us begin by considering preference expressions from the simplest class
for which we provide a polynomial time GA-decomposition, that is, preference expressions representable as acyclic

340

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

CP-nets with extended CP-families of the variables all being of size bounded by a constant. According to Corollary 2,
given such an expression N we can efﬁciently generate a value function v as in Eq. (3) consistent with N . In addition,
Theorem 3 shows that this value-function compilation is not only efﬁcient and sound, but also complete, that is, our
ability to generate v is guaranteed.

Now, suppose that the user provides the system with a set of m item-level rankings R = {oi
i1

The task of the system is now to incorporate R in the process of generating a value-function.

(cid:9) oi
i2

}m
i=1, oij

∈ Ω.

Deﬁnition 9. Given a set of ﬁnite-domain variables X and k, m ∈ N+, Φ(k) is the language of CP-nets with
maxX∈X {|EF X|} (cid:4) k, and Φ(k,m) is the language of expressions (cid:3)N, R(cid:4) consisting of a CP-net N ∈ Φ(k) and a
}m(cid:7)
i=1, m(cid:7) (cid:4) m, consistent with N . (In particular, we have Φ(k,0) = Φ(k).) We
set of item-level rankings R = {oi
i1
use Φ(k)
a

to denote the restrictions of Φ(k) and Φ(k,m) to acyclic CP-nets.

and Φ(k,m)
a

(cid:9) oi
i2

For a CP-net N , let LN be the system of linear constraints corresponding to the CP-conditions of N (Deﬁnition 3).
Considering the GA-decomposition of (cid:3)N, R(cid:4) ∈ Φ(k,m) over the CP-families of X (Eq. (3)), as we have done so far,
observe that each pairwise ranking o1 (cid:9) o2 in R can be encoded as a linear constraint

(cid:3)

(cid:3)

φX(x1, u1) >

φX(x2, u2),

(16)

X∈X

X∈X

where x1, u1 (respectively x2, u2) are the values provided by o1 (respectively o2) to the variable X and its parents
UX, respectively. Let LR denote the set of all m such constraints corresponding to R. Let HLN,R be the polytope
deﬁned by the LN ∪ LR. It is easy to verify that any point in HLN,R provides us with a value function as in Eq. (3)
consistent with both N and R. Likewise, for any ﬁxed k ∈ N+ and any N ∈ Φ(k), we can construct such a value
function efﬁciently. Hence, it appears that the value-function compilation scheme as in Section 3.1 preserves both its
soundness and efﬁciency when extended from Φ(k) to Φ(k,m).

Corollary 9. Given a preference expression (cid:3)N, R(cid:4) ∈ Φ(k,m), if (cid:3)N, R(cid:4) is GA-decomposable over the CP-families of
(cid:2)
n
i=1 φXi (FXi ) consistent with N and R can be constructed in time polynomial in
N , then a value function v(X ) =
k and m.

Having the positive result provided by Corollary 9, what is left to be studied is the completeness of GA-
decomposition of (cid:3)N, R(cid:4) ∈ Φ(k,m) over the CP-families of N , and in particular, the completeness of this procedure
for acyclic CP-nets. For (cid:3)N, ∅(cid:4) ∈ Φ(k)
a , completeness is guaranteed by Theorem 3. At ﬁrst view, there seems to be
no reason why it should not hold for (cid:3)N, R(cid:4) ∈ Φ(k,m)
, too. After all, (i) R is consistent with N , and thus a value
function consistent with both N and R does exists, and (ii) the assumptions that the ceteris paribus interpretation of
preference statements underlying CP-nets makes about the information these statements communicate are arguably
minimal [18]. However, Theorem 10 shows that, in general, extending the preference speciﬁcation language from
Φ(k) to Φ(k,m) does not preserve the completeness of GA-decomposition as in Eq. (3), unless we have P = NP. Even
more surprisingly, it shows that the completeness is not guaranteed even if R contains only a single ranking between
a pair of items.

a

Theorem 10. Unless P = NP, for k (cid:3) 22, m (cid:3) 1, there exists a preference expression (cid:3)N, R(cid:4) ∈ Φ(k,m)
HLN,R is empty.

a

such that

Proof. The proof combines the results provided by Lemma 1 and Corollary 2, and the results on complexity of
dominance testing in CP-nets established in [8]. Given a CP-net N and a pair of complete assignments o, o(cid:7) on the
variables of N , the problem of testing dominance of o over o(cid:7) is this of deciding N |= o (cid:9) o(cid:7). By a reduction from
the classical 3-SAT problem, Theorem 15 in [8] shows that dominance testing in acyclic CP-nets is NP-hard. For the
detailed reduction, see [8]. Two points about the reduction are important for us here:

1. The 3-SAT problem remains NP-hard for the subclass of 3-SAT formulae in which no propositional variable

appears (in both its positive and negated forms) in more than three clauses (e.g., see [16, p. 259]).

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

341

2. The reduction of satisﬁability of this class of 3-SAT formulae to the problem of dominance testing in acyclic
. Thus, dominance testing

CP-nets is effectively a reduction to the problem of dominance testing in CP-nets Φ(22)
in CP-nets Φ(22)

is NP-hard as well.

a

a

Now, assume to the contrary that the polytope HLN,R is empty for no (cid:3)N, R(cid:4) ∈ Φ(22,1)
consider the following procedure for dominance testing in CP-nets Φ(22)

a

.

a

, where k (cid:3) 22 and m (cid:3) 1, and

(1) Given a CP-net N ∈ Φ(22)
(cid:3)N, R1(cid:4), (cid:3)N, R2(cid:4) ∈ Φ(22,1)

and a pair of complete assignments o, o(cid:7) on the variables of N , construct two instances
with R1 = {o (cid:9) o(cid:7)} and R1 = {o(cid:7) (cid:9) o}, respectively.
(2) Create two linear programs LP1 and LP2 with constraints LN ∪ LR1 and LN ∪ LR2 , and arbitrary linear objective

a

a

function bounded on HLN,R1

and HLN,R2

, respectively.

(3) Solve LP1 and LP2. If LP1 is feasible and LP2 is infeasible, return true. Otherwise, return false.

First, Corollary 9 implies that the time complexity of this procedure is polynomial. Second, our assumption of non-
implies that the procedure returns true if and only if N |= o (cid:9) o(cid:7).
emptiness of HLN,R for all (cid:3)N, R(cid:4) ∈ Φ(22,1)
However, unless we have P = NP, this contradicts our previous result that dominance testing in CP-nets Φ(22)
is
NP-hard. Given the correctness of Corollary 9, we arrive into contradiction with our assumption regarding universal
non-emptiness of HLN,R for Φ(22,1)

, and thus prove our theorem. (cid:3)

a

a

a

We end this section by generalizing the impossibility result of Theorem 10 to a wide range of other languages for

preference speciﬁcation, including some yet to be proposed.

Theorem 11 (Generalized impossibility). Given a language Φ of preference expressions over a space of alternatives
Ω, let Φ(cid:7) be an extension of Φ to include consistent item level rankings, i.e.,

(cid:7) =

Φ

(cid:6)
N ∪ R | N ∈ Φ ∧ R = {o1 (cid:9) o2}, o1, o2 ∈ Ω ∧ N |= o1 (cid:9) o2

(cid:7)

.

Let V be the space of real-value functions over Ω, and let ΓΦ(cid:7) : Φ(cid:7) (cid:17)→ V ∪ {⊗} be a sound value-function compilation
scheme that either maps preference expressions N (cid:7) ∈ Φ(cid:7) to value functions consistent with them (if ΓΦ(cid:7) (N (cid:7)) ∈ V), or
fails (if ΓΦ(cid:7) (N (cid:7)) = ⊗).

Given that, at least one of the following three properties holds.

(1) Dominance testing in Φ is in P.
(2) ΓΦ(cid:7) is NP- or coNP-hard.
(3) ΓΦ(cid:7) is incomplete, that is, there exists N (cid:7) ∈ Φ(cid:7) such that ΓΦ(cid:7) (N (cid:7)) = ⊗.

It is not hard to verify that the basic idea underlying the proof of Theorem 10 extends in a straightforward manner
to a proof for Theorem 11. Note that the generality of the claim in Theorem 11 is due to the fact that it poses no
syntactical conditions on the preference language Φ, or on the way the functions in V are physically speciﬁed. And
since value-function compilation is of a wide theoretical and practical interest, while dominance testing has been
shown to be NP- or coNP-hard for most non-trivial existing qualitative preference speciﬁcation languages [8,25], the
relevance of Theorem 11 is apparent.

In fact, below we show that Theorem 11 already provides an answer to at least one open problem from the liter-
ature. Considering a preference speciﬁcation language (referred to here as Φcp) that strictly extends the language of
TCP-nets, McGeachie and Doyle [27] suggest a sound and complete value-function compilation scheme for this lan-
guage. While the compilation schemes suggested in [27] was shown by the authors to be worst-case computationally
intractable, McGeachie and Doyle left the necessity of such intractability as an open question [27, p. 174]. Now, given
that

(i) dominance testing in Φcp is known to be PSPACE-complete [25], and
(ii) Φ(cid:7)
cp

= Φcp because pairwise comparisons between completely speciﬁed elements of Ω are simply part of the

language Φcp,

342

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

Theorem 11 implies that no sound and complete compilation scheme for Φcp can be computationally efﬁcient, unless,
of course, PSPACE collapses to P.

5. Summary, related work and open problems

In this work we have studied representational and computational issues of compiling a set of qualitative statements
of ordinal preference into a value-function consistent with these statements. Speciﬁcally, we considered partial orders
induced by certain sets of qualitative statements of conditional preference and conditional relative importance, namely
the sets of statements representable by the TCP-net model [10,12]. We presented a new representation theory for fac-
tored value functions that allow for more useful preferential independence structures than those appearing in classical
textbook results in this area [21]. In particular, these representation results show that preference orders induced by a
wide class of TCP-nets can be consistently captured by compact generalized additive value functions. Moreover, we
show that for many such sets of statements, the corresponding generalized additive value function can be efﬁciently
generated. Next we considered a practically important problem of value-function compilation of a mixed set of gen-
eralizing and item-level preference statements. Adding item-level preference statements does not affect neither the
complexity nor the soundness of compiling a set of generalizing preference statements. However, we showed that the
completeness of such compilation is affected, and provide a general impossibility theorem on this matter.

The idea of representing partial preference information as a constraint over a space of candidate value functions
lies in the very foundations of measurement and multi-attribute decision theory [24]. Given that, numerous works
in the area of multi-attribute decision making consider the computational and algorithmic issues of generating value
functions consistent with given preference information (e.g., see [22,23,28,33]). Targeting the complexity issues, these
works a priori restrict the space of candidate value functions to be (in increasing order of generality) linear, quasi-
concave, or monotonic. However, it is easy to show that, by deﬁnition, such functions cannot capture many intuitive
preference statements, such as, for instance, statements of conditional preference and/or importance. On the other
hand, some recent work in the ﬁeld of artiﬁcial intelligence considers value-function compilation of these (as well as
some other) statements of preference [17,27]. However, to the best of our knowledge, our work is the ﬁrst to provide
a non-trivial preference speciﬁcation language for which value functions can be generated efﬁciently in a sound and
complete manner.

Finally, our work raises numerous open theoretical questions, such as:

1. When (if at all) GA-decomposition is complete for cyclic TCP-nets, or even just cyclic CP-nets?
2. What is the most compact form of GA-decomposition that is complete for all consistent TCP-nets?
3. Can we characterize the representation theorem purely in terms of conditional independence, without using the
graph structure explicitly, or, alternatively, what are the core properties of the graph that allow for a compact GA
decomposition?

4. What are the concrete limits of our impossibility theorem for various preference speciﬁcation languages? For
instance, for what values of m and k < 22 can we obtain completeness of GA-decomposition of Φ(k,m) over the
CP-families of the variables?

We believe that addressing these questions will provide a better understanding of the practical expressiveness and

limitations of reasoning about ordinal preference information.

Appendix A. Proofs

Theorem 3. Every acyclic CP-net is GA-decomposable over its CP-families.

Proof. To prove this claim we constructively show that, for every acyclic CP-net N , there exists a function v(X ) =
(cid:2)
n
i=1 φXi (FXi ) such that Φ = {φX1, . . . , φXn} satisfy the CP-conditions of N .
Given an acyclic CP-net N , for each variable X ∈ N , each value x ∈ dom(X), and each assignment u ∈ dom(UX)

we deﬁne a parameter p(x, u) to quantify the local preference for x given u:
(cid:7) ∈ dom(X) and N |= x (cid:9)u x

p(x, u) =

(cid:7)(cid:8)
(cid:8).

(cid:7) | x

(cid:6)
x

(cid:8)
(cid:8)

(cid:7)

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

343

For instance, if x is one of the least preferred value of X given u, then we have p(x, u) = 0, and for each x ∈ dom(X)
we have p(x, u) (cid:4) |dom(X)| − 1. (Recall that (cid:9)u is a partial order over dom(X).)

Next, we deﬁne weight coefﬁcients wX1, . . . , wXn . They are deﬁned recursively, in a top-down manner, as follows:
If X is a root node of N (i.e., UX = ∅), then wX = K for some arbitrary constant K > 0. Now, consider a variable X
that is already assigned its weight wX. We will distribute the weight of X is evenly between its children. This is done
by deﬁning the following coefﬁcient for each variable Y ∈ YX.

αX→Y

=

wX
|YX| · |dom(Y )|

.

(17)

Since N is assumed to be acyclic, prior to processing a non-root node Y , the parameters αX→Y are known for each
X ∈ UY , and we assign:
wY = min
{αX→Y
X∈UY

(18)

}.

Having the parameters p(x, u) and wX as above, we deﬁne the set of functions Φ = {φX1, . . . , φXn} in terms of these
parameters as follows. For each variable X, each x ∈ dom(X), and each u ∈ dom(UX), we have:

φX(x, u) = wX · p(x, u).

(19)
To prove the correctness of the construction, it is sufﬁcient to show that Φ = {φX1, . . . , φXn} satisfy the CP-
conditions of N . Consider a variable X, a pair of values x1, x2 ∈ dom(X), and an assignment u ∈ dom(UX), such that
N |= x1 (cid:9)u x2. For each v ∈ dom(EF X − {X}) compatible with u we have:

(cid:9)
(cid:10)
φYi (vi, x2) − φYi (vi, x1)

=

|YX|(cid:3)

i=1

(cid:4)

<

|YX|(cid:3)

i=1
|YX|(cid:3)

i=1
|YX|(cid:3)

i=1

(cid:11)
(cid:12)
p(vi, x2) − p(vi, x1)

wYi

(cid:12)
(cid:11)
p(vi, x2) − p(vi, x1)

αX→Yi

αX→Yi

(cid:8)
(cid:8)
(cid:8)
(cid:8)dom(Yi)
(cid:11)
(cid:12)
p(x1, u) − p(x2, u)
(cid:3)

= wX < wX
= φX(x1, u) − φX(x2, u).

Lemma 4. Given a TCP-net N with no ci-arcs, and a function v(X ) =
with N if and only if {φX1, . . . , φXn} satisfy both the CP and I-conditions of N .

(cid:2)
n
i=1 φXi (FXi ), we have that v is consistent

Proof. By deﬁnition, a value function v is consistent with N iff, for each pair of complete assignments x1, x2 ∈
dom(X ) such that N |= x1 (cid:9) x2, we have v(x1) > v(x2). By the semantics of TCP-nets, for TCP-nets with no ci-arcs,
we can reduce this test to just two cases of x1, x2 (the rest of the cases will be implied by the transitivity of the
preference relation induced by N ):

(1) x1, x2 differ only in the value of a single variable X, and N |= x1 (cid:9)u x2, and
(2) x, x(cid:7) differ only in the values of a pair of variables X, X(cid:7) with i-arc (

−−−−→
X, X(cid:7)) ∈ N , and N |= x1 (cid:9)u x2,

where x1 and x2 are the values provided to X by x1 and x2, respectively, and u is the assignment provided by x1
(and x2) to UX.

Considering case (1), recall the notation used in Deﬁnition 3. From GA-decomposition of v it follows that v(x1) >

v(x2) iff

φX(x1, u) +

|YX|(cid:3)

i=1

φYi (vi, x1) > φX(x2, u) +

|YX|(cid:3)

i=1

φYi (vi, x2)

344

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

since all other sub-value functions of v take on the same values on x1 and x2. However, since N |= x1 (cid:9)u x2, this is
exactly the formulation of the CP-condition of N with respect to X.

Considering case (2), recall the notation used in Deﬁnition 4. Let x(cid:7)

1 and x(cid:7)
x2, respectively. From GA-decomposition of v it follows that v(x1) > v(x2) iff

2 be the values provided to X(cid:7) by x1 and

φX(x1, u) + φX(cid:7)

(x

(cid:7)

1, u(cid:7)

) +

|YX|(cid:3)

i=1

φYi (vi, x1, x

(cid:7)
1) +

|Y

X(cid:7) −YX|(cid:3)

i=1

φY (cid:7)

i (v(cid:7)

i, x

(cid:7)
1, x1)

> φX(x2, u) + φX(cid:7)

(x

(cid:7)

2, u(cid:7)

) +

|YX|(cid:3)

i=1

φYi (vi, x2, x

(cid:7)
2) +

|Y

X(cid:7) −YX|(cid:3)

i=1

φY (cid:7)

i (v(cid:7)

i, x

(cid:7)
2, x2)

(20)

since all other sub-value functions of v take on the same values on x1 and x2. Again, since N |= x1 (cid:9)u x2, this is
exactly the formulation of the I-condition of N with respect to X.

Finally, suppose that Φ does not satisfy the I-conditions of N . It means that there exists an i-arc (

−−−−→
X, X(cid:7)) ∈ N , an
assignment u ∈ dom(UX), and a pair of values x1, x2 ∈ dom(X), such that N |= x1 (cid:9)u x2, yet there exist a pair of values
x(cid:7)
1, x(cid:7)
∈ dom(X(cid:7)), and a set of (all compatible) u(cid:7) ∈ dom(UX(cid:7) ), v ∈ dom(EF X − {X, X(cid:7)}), v(cid:7) ∈ dom(EF X(cid:7) − {X, X(cid:7)})
2
such that:

φX(x1, u) + φX(cid:7)

(x

(cid:7)

1, u(cid:7)

) +

|YX|(cid:3)

i=1

φYi (vi, x1, x

(cid:7)
1) +

|Y

X(cid:7) −YX|(cid:3)

i=1

φY (cid:7)

i (v(cid:7)

i, x

(cid:7)
1, x1)

(cid:4) φX(x2, u) + φX(cid:7)

(x

(cid:7)

2, u(cid:7)

) +

|YX|(cid:3)

i=1

φYi (vi, x2, x

(cid:7)
2) +

|Y

X(cid:7) −YX|(cid:3)

i=1

φY (cid:7)

i (v(cid:7)

i, x

(cid:7)
2, x2).

(21)

Let A = X − (EF X ∪ EF X(cid:7)). Due to the GA-decomposition of v, for all a ∈ dom(A), Eq. (21) implies v(x1) < v(x2),
where x1 = x1x(cid:7)
2uu(cid:7)vv(cid:7)a. However, this implies that N (cid:19)|= x1 (cid:9) x2, which contradicts the
−−−−→
X, X(cid:7)). Hence, we accomplished the proof that Φ = {φX1, . . . , φXn} satisfying the CP-conditions
semantics of i-arc (
and I-conditions of N is a necessary and sufﬁcient condition for v as in Lemma 4 to be consistent with N . (cid:3)

1uu(cid:7)vv(cid:7)a, and x1 = x2x(cid:7)

Theorem 5. Every acyclic TCP-net with no ci-arcs is GA-decomposable over its CP-families.

Proof. First, extending our notation, for each variable X ∈ X , let IX denote the set of all variables X(cid:7) ∈ X that are
directly and unconditionally more important that X, i.e., for each X(cid:7) ∈ IX, there is an i-arc (

−−−−→
X(cid:7), X) ∈ N .

The proof of Theorem 5 is based on the construction similar to this in the proof of Theorem 3, but with Eq. (18)

min
X∈UY

{αX→Y

}, min
X∈IY

(cid:7)

{wX/δ2}

(22)

replaced by:

(cid:6)
wY = min

where

δ = 1 + max
X∈X

(cid:8)
(cid:8)
(cid:8).
(cid:8)dom(X)

First, observe that replacing Eq. (18) by Eq. (22) has no impact on the satisfying the CP-conditions, since w(Y ) in
Eq. (22) is at least as small (comparatively to all wX, X ∈ UY ) as this in Eq. (18). Therefore, we only should prove
−−−−→
X, X(cid:7)), rewrite
that Φ = {φX1, . . . , φXn} constructed this way will satisfy the I-conditions of N . Consider an i-arc (
Eq. (8) as:

φX(x1, u) − φX(x2, u) −

(cid:9)
φYi (vi, x2, x

(cid:7)
2) − φYi (vi, x1, x

(cid:10)
(cid:7)
1)

|YX|(cid:3)

i=1

> φX(cid:7)

(x

(cid:7)

2, u(cid:7)

) − φX(cid:7)

(x

(cid:7)

1, u(cid:7)

) −

|Y

X(cid:7) −YX|(cid:3)

i=1

(cid:9)
φY (cid:7)

i (v(cid:7)

i, x

(cid:7)

1, x1) − φY (cid:7)

i (v(cid:7)

i, x

(cid:10)
(cid:7)
2, x2)

(23)

and denote the left and right sides of Eq. (23) by ((cid:11)) and ((cid:11)(cid:11)), respectively.

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

345

((cid:11)) = wX

(cid:11)

(cid:12)
p(x1, u) − p(x2, u)

−

(cid:11)
p(vi, x2, x

wYi

(cid:7)
2) − p(vi, x1, x

(cid:12)
(cid:7)
2)

|YX|(cid:3)

i=1

(cid:11)(cid:8)
(cid:8)
(cid:8)dom(Yi)
(cid:8) − 1

(cid:12)

wYi

(cid:11)(cid:8)
(cid:8)
(cid:8)dom(Yi)
(cid:8) − 1

(cid:12)

αX→Yi

(cid:13)

wX
|YX|

−

wX
|YX| · |dom(Yi)|

(cid:14)

1
|dom(Yi)|

|YX|(cid:3)

i=1
|YX|(cid:3)

i=1
|YX|(cid:3)

(cid:3) wX −

(cid:3) wX −

= wX −

i=1
|YX|(cid:3)

i=1

= wX
|YX|

>

wX
δ

,

((cid:11)(cid:11)) = wX(cid:7)(cid:11)

p(x

(cid:7)

2, u(cid:7)

) − p

(cid:12)(cid:12)

(cid:11)
x

(cid:7)

1, u(cid:7)

−

|Y
X(cid:7) |(cid:3)

i=1

wY (cid:7)

i

(cid:11)
p(v(cid:7)

i, x

(cid:7)

1, x1) − p(v(cid:7)

i, x

(cid:4) wX(cid:7)(cid:11)(cid:8)

(cid:8)dom(X

(cid:12)

(cid:7)

(cid:8)
(cid:8) − 1
)

+

(cid:4) wX(cid:7)(cid:11)(cid:8)

(cid:8)dom(X

(cid:12)

(cid:7)

(cid:8)
(cid:8) − 1
)

+

= wX(cid:7)(cid:11)(cid:8)

(cid:8)dom(X

(cid:12)

(cid:7)

(cid:8)
(cid:8) − 1
)

+

|Y
X(cid:7) |(cid:3)

i=1
|Y
X(cid:7) |(cid:3)

i=1
|Y
X(cid:7) |(cid:3)

(cid:15)

= wX(cid:7)
< wX(cid:7)(cid:8)

(cid:7)

(cid:8)
(cid:8)dom(X
(cid:8)
(cid:8).
)

(cid:8)dom(X

(cid:7)

(cid:8)
(cid:8) − 1
)

|YX(cid:7)|

wY (cid:7)

i

(cid:11)(cid:8)
(cid:8)dom(Y

(cid:8)
(cid:8) − 1
(cid:7)
i )

(cid:12)

(cid:11)(cid:8)
(cid:8)dom(Y

(cid:8)
(cid:8) − 1
(cid:7)
i )

(cid:12)

α

X(cid:7)→Y

(cid:7)
i

(cid:13)

(cid:14)

wX(cid:7)
|YX(cid:7)|

−

wX(cid:7)
|YX(cid:7)| · |dom(Y (cid:7)
i )|

(cid:16)

1
|dom(Y (cid:7)
i )|

i=1
|Y
X(cid:7) |(cid:3)

i=1

(cid:12)
(cid:7)
2, x1)

(24)

(25)

From Eqs. (24) and (25) it follows that Φ = {φX1, . . . , φXn} will satisfy the I-conditions of N if:

(cid:3) wX(cid:7)(cid:8)

(cid:8)dom(X

(cid:7)

(cid:8)
(cid:8),
)

wX
δ

which is ensured by the new deﬁnition of wX in Eq. (22). (cid:3)

Lemma 6. Given a TCP-net N , and a function v(X ) =
{φX1, . . . , φXn } satisfy CP- and CI-conditions of N .

(cid:2)
n
i=1 φXi (F (cid:11)
Xi

), we have v consistent with N if and only if

Proof. By deﬁnition, a value function v is consistent with N iff, for each pair of complete assignments x1, x2 ∈
dom(X ) such that N |= x1 (cid:9) x2, we have v(x1) > v(x2). By the semantics of TCP-nets, we can reduce this test to just
two cases of x1, x2 (the rest of the cases will be implied by the transitivity of the preference relation induced by N ):

(1) x1, x2 differ only in the value of a single variable X, and N |= x1 (cid:9)u x2, and
(2) x, x(cid:7) differ only in the values of a pair of variables X, X(cid:7), such that N |= x1 (cid:9)u x2, and we have either i-arc

−−−−→
X, X(cid:7)) ∈ N , or ci-arc (X, X(cid:7)) ∈ N and X being more important than X(cid:7) given sγ ,
(

346

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

where x1 and x2 are the values provided to X by x1 and x2, respectively, while u and sγ are the assignments provided
by x1 (and x2) to UX and S(X,X(cid:7)), respectively. Analysis of these two cases with respect to Eqs. (12) and (11) is similar
to the analysis of the corresponding two cases in the proof of Lemma 4 regarding Eqs. (2) and (8), respectively. (cid:3)

Theorem 8. Every acyclic TCP-net is GA-decomposable over its TCP-families.

Proof. Given an acyclic TCP-net N , we deﬁne a set of functions Φ = {φX1, . . . , φXn } over {F (cid:11)
X1
tively, where for 1 (cid:4) i (cid:4) n, each x ∈ dom(Xi), u ∈ dom(UXi ), s ∈ dom(SXi ), we have:

, . . . , F (cid:11)
Xn

}, respec-

φXi (x, u, s) = wXi (s) · pXi (x, u).

(26)

The functions pX are deﬁned exactly as in the proof for Theorem 3. Let a (cid:12)(cid:13) b denote the fact that two assignments
a and b on some sets of variables are compatible, i.e. agree on the assignment provided to their overlapping variables.
The weight function wX is deﬁned as:
(cid:6)

(cid:7)(cid:7)

(cid:6)

(cid:7)
αX(cid:7)→X (s)

, min
X(cid:7)(cid:7)∈IX|s

(cid:6)
βX(cid:7)(cid:7)→X (s)

wX(s) = min

min
X(cid:7)∈UX∪SX
where, for each X(cid:7) ∈ UX ∪ SX,

αX(cid:7)→X (s) = min
s(cid:7)∈dom(S
s(cid:7)(cid:12)(cid:13) s
and, for each X(cid:7)(cid:7) ∈ IX|s,

X(cid:7) )

βX(cid:7)(cid:7)→X (s) = min
s(cid:7)(cid:7)∈dom(S
s(cid:7)(cid:7)(cid:12)(cid:13) s

X(cid:7)(cid:7) )

We claim that the function

v(X ) =

n(cid:3)

i=1

φXi (F (cid:11)
Xi

)

(cid:18)

(cid:17)

wX(cid:7)

(s(cid:7))
X(cid:7)| · |dom(X)|

|Y (cid:11)

(cid:17)

(cid:18)

.

wX(cid:7)(cid:7)
(s(cid:7)(cid:7))
δ2

with Φ = {φX1, . . . , φXn} constructed according to Eq. (26):

1. satisﬁes the CP- and CI-conditions of N , and
2. have well-deﬁned weight functions wX1, . . . , wXn .

CI-conditions: Let us rewrite Eq. (11) as:

φX(x1, u, s) − φX(cid:7)

(x2, u, s) −

|Y (cid:11)
|(cid:3)
X

i=1

(cid:9)
φYi (vi, x2, x

(cid:7)
2) − φYi (vi, x1, x

(cid:10)
(cid:7)
1)

> φX(cid:7)

(x

(cid:7)

2, u(cid:7)

, s(cid:7)

) − φX(cid:7)

(x

(cid:7)

1, u(cid:7)

, s(cid:7)

) −

|Y (cid:11)

X(cid:7) −Y (cid:11)
|(cid:3)

X

(cid:9)
φY (cid:7)

i (v(cid:7)

i, x

(cid:7)

1, x1) − φY (cid:7)

i (v(cid:7)

i, x

(cid:10)
(cid:7)
2, x2)

i=1

and denote the right and left sides of Eq. (30) by ((cid:11)) and ((cid:11)(cid:11)), respectively. For ((cid:11)), we have:

(cid:11)
((cid:11)) = wX(s)

(cid:12)
p(x1, u) − p(x2, u)

+

|Y (cid:11)
|(cid:3)
X

(cid:9)
wYi (si, x1)p(yi, ui, x1, x

(cid:7)
1) − wYi (si, x2)p(yi, ui, x2, x

(cid:10)
(cid:7)
2)

i=1
where yi is the value provided by vi to Yi , while si and ui are the projections of vi on SYi
respectively. (Note that x(cid:7)
from Eq. (31) we have:

− {X(cid:7)},
2 might be redundant in some p(vi, . . .) and wYi .) Now, since p(x1, u) > p(x2, u),

− {X(cid:7)} and UYi

1 and x(cid:7)

(27)

(28)

(29)

(30)

(31)

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

347

((cid:11)) (cid:3) wX(s) −

(cid:3) wX(s) −

= wX(s) −

(cid:3) wX(s) −

|Y (cid:11)
|(cid:3)
X

i=1
|Y (cid:11)
|(cid:3)
X

i=1
|Y (cid:11)
|(cid:3)
X

i=1
|Y (cid:11)
|(cid:3)
X

i=1

wYi (si, x2)

(cid:8)
(cid:11)(cid:8)
(cid:8) − 1
(cid:8)dom(Yi)

(cid:12)

(cid:8)
(cid:11)(cid:8)
(cid:8) − 1
(cid:8)dom(Yi)

(si, x2)

(cid:12)

αX→Yi

(cid:17)

wX(¯s)
| · |dom(Yi)|

|Y (cid:11)
X

(cid:18)

(cid:11)(cid:8)
(cid:8)
(cid:8)dom(Yi)
(cid:8) − 1

(cid:12)

·

min
¯s∈dom(S
¯s(cid:12)(cid:13) si

X )

(cid:13)

wX(s)
|
|Y (cid:11)
X

−

|Y (cid:11)
X

wX(s)
| · |dom(Yi)|

(cid:14)

1
|dom(Yi)|

|Y (cid:11)
|(cid:3)
X

i=1

.

= wX(s)
|
|Y (cid:11)
X
wX(s)
δ

>

Writing ((cid:11)(cid:11)) similarly to ((cid:11)) in Eq. (31), we have:
|Y (cid:11)
X(cid:7) |(cid:3)

((cid:11)(cid:11)) = wX(cid:7)

(s(cid:7)

(cid:11)
)

p(x

(cid:7)

2, u(cid:7)

) − p(x

(cid:7)

1, u(cid:7)

(cid:12)
)

+

(cid:9)
wY (cid:7)

i (s(cid:7)

i, x

(cid:7)

2)p(u(cid:7)

i, x

(cid:7)

2, x2) − wY (cid:7)

i (y(cid:7)

i, s(cid:7)

i, x

(32)

(cid:10)
(cid:7)
1, x1)

,

(33)

(cid:7)

1)p(y(cid:7)

i, u(cid:7)

i, x

i is the value provided by v(cid:7)

where y(cid:7)
respectively. (Again, note that x1 and x2 might be redundant in some p(v(cid:7)

i are the projections of v(cid:7)
i, . . .) and wY (cid:7)

i and u(cid:7)

i to Y (cid:7)

− {X} and U
i on S
Y (cid:7)
i
i .) From Eq. (33) we have:

Y (cid:7)
i

− {X},

i=1
i , while s(cid:7)

((cid:11)(cid:11)) (cid:4) wX(cid:7)

(s(cid:7)

(cid:11)(cid:8)
(cid:8)dom(X
)

(cid:7)

(cid:8)
(cid:8) − 1
)

(cid:12)

+

(cid:4) wX(cid:7)

(s(cid:7)

(cid:11)(cid:8)
(cid:8)dom(X
)

(cid:7)

(cid:8)
(cid:8) − 1
)

(cid:12)

+

= wX(cid:7)

(s(cid:7)

(cid:11)(cid:8)
(cid:8)dom(Y
)

(cid:8)
(cid:8) − 1
(cid:7)
i )

(cid:12)

+

|Y (cid:11)
X(cid:7) |(cid:3)

i=1
|Y (cid:11)
X(cid:7) |(cid:3)

i=1
|Y (cid:11)
X(cid:7) |(cid:3)

i=1

wY (cid:7)

i (s(cid:7)

i, x

(cid:7)
2)

(cid:11)(cid:8)
(cid:8)dom(Y

(cid:12)

(cid:8)
(cid:8) − 1
(cid:7)
i )

α

X(cid:7)→Y

(cid:7)
i

(s(cid:7)

i, x

(cid:7)
max)

(cid:11)(cid:8)
(cid:8)dom(Y

(cid:12)

(cid:8)
(cid:8) − 1
(cid:7)
i )

(cid:17)

wX(cid:7)
(¯s)
X(cid:7)| · |dom(Y (cid:7)
i )|

|Y (cid:11)

min
¯s∈dom(S
X(cid:7) )
¯s(cid:12)(cid:13) s(cid:7)
i

(cid:18)

(cid:11)(cid:8)
(cid:8)dom(Y

(cid:12)

(cid:8)
(cid:8) − 1
(cid:7)
i )

(cid:6)
wX(cid:7)

(cid:7)
(¯s)

−

+ min
¯s∈dom(S
X(cid:7) )
¯s(cid:12)(cid:13) s(cid:7)
i

{wX(cid:7)

min¯s∈dom(S
X(cid:7) )
¯s(cid:12)(cid:13) s(cid:7)
i
X(cid:7)|
|Y (cid:11)

(¯s)}

|Y (cid:11)
X(cid:7) |(cid:3)

i=1

1
|dom(Y (cid:7)
i )|

= wX(cid:7)

(s(cid:7)

(cid:11)(cid:8)
(cid:8)dom(Y
)

(cid:8)
(cid:8) − 1
(cid:7)
i )

(cid:12)

(cid:8)
(cid:8)dom(X

(cid:7)

(cid:8)
(cid:8)
)

(cid:4) wX(cid:7)
< wX(cid:7)

(s(cid:7)
(s(cid:7)

) ·
) · δ.

(34)
From Eqs. (32) and (34) it follows that our set of functions Φ = {φX1, . . . , φXn} satisﬁes the CI-conditions of N if

we have:

wX(s)
δ

(cid:3) wX(cid:7)

(s(cid:7)

) · δ,

and, since X ∈ IX(cid:7)|s(cid:7) , this relation is ensured by the construction of wX1, . . . , wXn (Eqs. (27) and (29)).

CP-conditions: Considering Eq. (12), let yi is the value provided by vi to Yi , while si and ui be the projections of

vi on SYi and UYi , respectively. Satisfaction of Eq. (12) can be shown as follows:

348

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

|YX∪WX|(cid:3)

i=1

(cid:9)
(cid:10)
φYi (yi, x2, ui, si) − φYi (yi, x1, ui, si)

wYi (si, x2)p(yi, x2, ui) − wYi (si, x1)p(yi, x1, ui)

αX→Yi

(si, x2)p(yi, x2, ui, zi)

(cid:8)
(cid:8)
(cid:8)
(cid:8)dom(Yi)
(si, x2)

αX→Yi

|YX∪WX|(cid:3)

i=1
|YX∪WX|(cid:3)

i=1
|YX∪WX|(cid:3)

i=1
|YX∪WX|(cid:3)

=

(cid:4)

<

(cid:4)

wX(s)
|YX ∪ WX|

i=1
= wX(s)
(cid:12)
(cid:11)
< wX(s)
p(x1, u) − p(x2, u)
= φX(x1, u, s) − φX(x2, u, s).

(35)

Well-deﬁnedness: The last thing that remains to be shown is that the functions wX1, . . . , wXn as in Eq. (27) are
well deﬁned. Given a variable X ∈ X and an assignment s ∈ dom(SX), from Eq. (27) it follows that (i) wX(s) =
fs(wX(cid:7)
(s(cid:7))) for some X(cid:7) ∈ (UX ∪ SX ∪ IX|s) and some s(cid:7) ∈ dom(SX(cid:7)) compatible with s, and (ii) wX(s) < fs(wX(cid:7)
(s(cid:7))).
Since for the root variables X of N the (only) function wX(∅) is explicitly speciﬁed as wX(∅) = K, the set of
functions wX1, . . . , wXn is not well deﬁned if and only if there exists a sequence of variables Xi1, . . . , Xik and a set of
assignments s1, . . . , sk on SXi1
, . . . , SXik
(cid:11)
(cid:12)
wXi2 (s2)
wXi1 (s1) = fs1
(cid:11)
(cid:12)
wXi3 (s3)
wXi2 (s2) = fs2
. . .
wXik−1 (sk−1) = fsk−1
wXik (sk) = fsk

(cid:11)
(cid:12)
wXik (sk)
(cid:12)
wXi1 (s1)
,

, respectively, such that:

(36)

(cid:11)

However, assuming that such a sequence exists will immediately violate the acyclicity of N . Hence, wX1, . . . , wXn as
in Eq. (27) are well deﬁned. (cid:3)

References

[1] R. Agrawal, E.L. Wimmers, A framework for expressing and combining preferences, in: Proceedings of ACM SIGMOD International Con-

ference on Management of Data, 2000, pp. 297–306.

[2] F. Bacchus, A. Grove, Graphical models for preference and utility, in: Proceedings of the Eleventh Annual Conference on Uncertainty in

Artiﬁcial Intelligence, San Francisco, CA, Morgan Kaufmann, 1995, pp. 3–10.

[3] F. Bacchus, A. Grove, Utility independence in qualitative decision theory, in: Proceedings of the Fifth Conference on Knowledge Representa-

tion (KR-96), Cambridge, Morgan Kauffman, 1996, pp. 542–552.

[4] D. Bertsekas, A. Nedic, A. Ozdaglar, Convex Analysis and Optimization, Athena Scientiﬁc, 2003.
[5] J. Blythe, Visual exploration and incremental utility elicitation, in: Proceedings of the National Conference on Artiﬁcial Intelligence (AAAI),

2002, pp. 526–532.

[6] C. Boutilier, A POMDP formulation of preference elicitation problems, in: Proceedings of the Eighteenth National Conference on Artiﬁcial

Intelligence (AAAI), 2002, pp. 239–246.

[7] C. Boutilier, F. Bacchus, R.I. Brafman, UCP-networks: A directed graphical representation of conditional utilities, in: Proceedings of Seven-

teenth Conference on Uncertainty in Artiﬁcial Intelligence, 2001, pp. 56–64.

[8] C. Boutilier, R. Brafman, C. Domshlak, H. Hoos, D. Poole, CP-nets: A tool for representing and reasoning about conditional ceteris paribus

preference statements, Journal of Artiﬁcial Intelligence Research 21 (2004) 135–191.

R.I. Brafman, C. Domshlak / Artiﬁcial Intelligence 172 (2008) 325–349

349

[9] C. Boutilier, R. Brafman, H. Hoos, D. Poole, Reasoning with conditional ceteris paribus preference statements, in: Proceedings of the Fifteenth

Annual Conference on Uncertainty in Artiﬁcial Intelligence, Morgan Kaufmann, 1999, pp. 71–80.

[10] R. Brafman, C. Domshlak, Introducing variable importance tradeoffs into CP-nets, in: Proceedings of the Eighteenth Annual Conference on

Uncertainty in Artiﬁcial Intelligence, Edmonton, Canada, August 2002, pp. 69–76.

[11] R. Brafman, C. Domshlak, T. Kogan, Compact value-function representations for qualitative preferences, in: Proceedings of the Twentieth

Annual Conference on Uncertainty in Artiﬁcial Intelligence, Banff, Canada, 2004, pp. 51–58.

[12] R. Brafman, C. Domshlak, S.E. Shimony, On graphical modeling of preference and importance, Journal of Artiﬁcial Intelligence Research 25

(2006) 389–424.

[13] J. Chomicki, Preference formulas in relational queries, ACM Transactions on Database Systems 28 (4) (2003) 427–466.
[14] C. Domshlak, R. Brafman, CP-nets—reasoning and consistency testing, in: Proceedings of the Eighth International Conference on Principles

of Knowledge Representation and Reasoning, Toulouse, France, April 2002, pp. 121–132.

[15] P.C. Fishburn, The Foundations of Expected Utility, Reidel, Dordrecht, 1982.
[16] M.R. Garey, D.S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W.H. Freeman and Company, New

York, 1978.

[17] V. Ha, P. Haddawy, A hybrid approach to reasoning with partially elicited preference models, in: Proceedings of the Fifteenth Annual Confer-

ence on Uncertainty in Artiﬁcial Intelligence, Stockholm, Sweden, Morgan Kaufmann, July 1999.

[18] S.O. Hansson, Preference logic, in: D.M. Gabbay, F. Guenthner (Eds.), Handbook of Philosophical Logic, vol. 4, second ed., Kluwer, 2001,

pp. 319–394.

[19] S.O. Hansson, The Structure of Values and Norms, Cambridge University Press, 2001.
[20] T. Joachims, Optimizing search engines using clickthrough data, in: Proceedings of the ACM Conference on Knowledge Discovery and Data

Mining (KDD), 2002, pp. 154–161.

[21] R.L. Keeney, H. Raiffa, Decision with Multiple Objectives: Preferences and Value Tradeoffs, Wiley, 1976.
[22] M. Koksalan, P. Sagala, Interactive approaches for discrete alternative multiple criteria decision making with monotone utility functions,

Management Science 41 (7) (1995) 1158–1171.

[23] P. Korhonen, J. Wallenius, S. Zionts, Solving the discrete multiple criteria problem using convex cones, Management Science 30 (11) (1984)

1336–1345.

[24] D.H. Krantz, R.D. Luce, P. Suppes, A. Tversky, Foundations of Measurement, Academic, New York, 1971.
[25] J. Lang, Logical preference representation and combinatorial vote, Annals of Mathematics and Artiﬁcial Intelligence 42 (1–3) (2004) 37–71.
[26] G. Linden, S. Hanks, N. Lesh, Interactive assessment of user preference models: The automated travel assistant, in: Proceedings of the Sixth

International Conference on User Modeling, 1997, pp. 67–78.

[27] M. McGeachie, J. Doyle, Utility functions for ceteris paribus preferences, Computational Intelligence 20 (2) (2004) 158–217 (special issue on

Preferences in AI).

[28] S. Prasad, M. Karwan, S. Zionts, Use of convex cones in interactive multiple objective decision making, Management Science 43 (5) (1997)

723–734.

[29] P. Pu, B. Faltings, Decision tradeoff using example critiquing and constraint programming, Constraints: An International Journal 9 (4) (2004)

289–310.

[30] S.W. Tan, J. Pearl, Qualitative decision theory, in: Proceedings of the Twelfth National Conference on Artiﬁcial Intelligence, Seattle, AAAI

Press, 1994, pp. 928–933.

[31] M. Torrens, B. Faltings, P. Pu, SmartClients: Constraint satisfaction as a paradigm for scaleable intelligent information systems, Constraints 7

(2002) 49–69.

[32] M. Wellman, J. Doyle, Preferential semantics for goals, in: Proceedings of the Ninth National Conference on Artiﬁcial Intelligence, July 1991,

pp. 698–703.

[33] S. Zionts, J. Wallenius, An interactive programming method for solving the multiple criteria problem, Management Science 22 (6) (1976)

633–652.

