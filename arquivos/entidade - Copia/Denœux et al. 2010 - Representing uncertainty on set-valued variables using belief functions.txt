Artiﬁcial Intelligence 174 (2010) 479–499

Contents lists available at ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Representing uncertainty on set-valued variables using belief functions

Thierry Denœux

∗

, Zoulﬁcar Younes, Fahed Abdallah

HEUDIASYC, UTC, CNRS, Centre de Recherche de Royallieu, BP 20529, F-60205 Compiègne, France

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 20 April 2009
Received in revised form 2 February 2010
Accepted 3 February 2010
Available online 6 February 2010

Keywords:
Dempster–Shafer theory
Evidence theory
Conjunctive knowledge
Lattice
Uncertain reasoning
Multi-label classiﬁcation

1. Introduction

A formalism is proposed for representing uncertain information on set-valued variables
using the formalism of belief functions. A set-valued variable X on a domain Ω is a variable
taking zero, one or several values in Ω. While deﬁning mass functions on the frame 22Ω
is usually not feasible because of the double-exponential complexity involved, we propose
an approach based on a deﬁnition of a restricted family of subsets of 2Ω that is closed
under intersection and has a lattice structure. Using recent results about belief functions
on lattices, we show that most notions from Dempster–Shafer theory can be transposed
to that particular lattice, making it possible to express rich knowledge about X with only
limited additional complexity as compared to the single-valued case. An application to
multi-label classiﬁcation (in which each learning instance can belong to several classes
simultaneously) is demonstrated.

© 2010 Elsevier B.V. All rights reserved.

An important concept in knowledge representation is that of variable. Usually, we associate to each variable X a domain
(or frame of discernment) Ω , and we assume that X takes one and only one value in Ω . For instance, in conventional
classiﬁcation problems, X denotes the class of an object, and each object is assumed to belong to one and only one class
among a set Ω of classes.

There are cases, however, where it is convenient to consider a variable X taking zero, one or several values in a domain
Ω . In such cases, X may be called a set-valued, or conjunctive variable [8,33]. For instance, in diagnosis problems, Ω may
denote the set of faults that can possibly occur in a system, and X the faults actually occurring at a given time. In text
classiﬁcation, Ω may denote a set of topics, and X the list of topics dealt with in a given text, etc.

A straightforward approach to the above problem is, of course, to consider a set-valued variable X on Ω as a single-
valued variable on the power set Θ = 2Ω . However, this approach often implies working in a space of very high cardinality.
If, as done in this paper, we assume Ω to be ﬁnite with size K , then the size of Θ is 2K . If we want to express imprecise
information about X , we will have to manipulate subsets of Θ . As there are 22K
of these subsets, this approach rapidly
becomes intractable as K increases.

In this paper, we consider the problem of representing partial knowledge about a set-valued variable X with domain Ω
using the Dempster–Shafer theory of belief functions [26,30]. Our approach will be based on a simple representation of a
class C(Ω) of subsets of Θ = 2Ω which, endowed with set inclusion, has a lattice structure. Using recent results about belief
functions on lattices [14], we will be able to generalize most concepts of Dempster–Shafer theory (including the canonical
decompositions and the cautious rule [5]) in this setting. This formalism will be shown to allow the expression of a wide
range of knowledge about set-valued variables, with only a moderate increase of complexity (from 2K to 3K ) as compared
to the usual single-valued case.

* Corresponding author. Fax: +33 03 44 23 44 77.
E-mail address: tdenoeux@hds.utc.fr (T. Denœux).

0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2010.02.002

480

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

The rest of this paper is organized as follows. Background notions on belief functions in the classical setting and in
general lattices will ﬁrst be recalled in Sections 2 and 3, respectively. Our approach will then be introduced in Section 4,
and some relationships with previous work will be outlined in Section 5. An application to multi-label classiﬁcation will be
presented in Section 6, and Section 7 will conclude the paper.

2. Belief functions

The basic concepts of the Dempster–Shafer theory of belief functions, as introduced in [26], will ﬁrst be summarized in

Section 2.1. The canonical decomposition and the cautious rule will then be recalled in Section 2.2.

2.1. Basic deﬁnitions

Let Ω be a ﬁnite set. A mass function on Ω is a function m : 2Ω → [0, 1] such that

(cid:2)

m( A) = 1.

A⊆Ω

The subsets A of Ω such that m( A) > 0 are called the focal elements of m. The set of focal elements of m will be denoted
F (m). m is said to be normal if ∅ is not a focal element, and dogmatic if Ω is not a focal element.

A mass function m is often used to model an agent’s beliefs about a variable X taking a single but ill-known value ω0
in Ω [30]. The quantity m( A) is then interpreted as the measure of the belief that is committed exactly to the hypothesis
ω0 ∈ A. Full certainty corresponds to the case where m({ωk}) = 1 for some ωk ∈ Ω , while total ignorance is modeled by the
vacuous mass function verifying m(Ω) = 1. Probabilistic uncertainty corresponds to the case where all focal elements are
singletons, in which case m is equivalent to a probability distribution on Ω .

To each mass function m can be associated an implicability function b and a belief function bel deﬁned as follows:

(cid:2)

b( A) =

B⊆ A

bel( A) =

m(B),

(cid:2)

m(B) = b( A) − m(∅).

(1)

(2)

B⊆ A,B(cid:2) A

These two functions are equal when m is normal. However, they need to be distinguished when considering non-normal
mass functions. Function bel has easier interpretation, as bel( A) corresponds to a degree of belief in the proposition “The true
value ω0 of X belongs to A”. However, function b has simpler mathematical properties. For instance, m can be recovered
from b as

m( A) =

(−1)

| A\B|

b(B),

(3)

(cid:2)

B⊆ A

where | · | denotes cardinality. Function m is said to be the Möbius transform of b. For every function f
such that f (Ω) = 1, the following conditions are known to be equivalent [26]:

from 2Ω to [0, 1]

1. The Möbius transform m of f

is positive and veriﬁes

(cid:3)

A⊆Ω m( A) = 1.

2.

f

is totally monotone, i.e., for any k (cid:2) 2 and for any family A1, . . . , Ak in 2Ω ,

(cid:6)

(cid:2)

Ai

(cid:4)

f

k(cid:5)

i=1

(cid:2)

(−1)

|I|+1 f

∅(cid:7)=I⊆{1,...,k}

(cid:7) (cid:8)

(cid:9)

Ai

.

i∈I

Hence, b (and bel) are totally monotone.

Other functions related to m are the plausibility function, deﬁned as

(cid:2)

pl( A) =

m(B)

B∩ A(cid:7)=∅
= 1 − b( A)

and the commonality function (or co-Möbius transform of b) deﬁned as

q( A) =

(cid:2)

m(B).

B⊇ A

m can be recovered from q using the following relation:

m( A) =

(−1)

|B\ A|

q(B).

(cid:2)

B⊇ A

(4)

(5)

(6)

(7)

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

481

Functions m, bel, b, pl and q are thus in one-to-one correspondence and can be regarded as different facets of the same
information.

A special case of interest is that where the focal elements of m are nested: m is then said to be consonant. In this case,

we have

pl( A ∪ B) = max

(cid:10)

(cid:11)
pl( A), pl(B)

, ∀ A, B ⊆ Ω.

The plausibility function is thus a possibility measure, with corresponding possibility distribution deﬁned by π (x) = pl({x})
for all x ∈ Ω . Conversely, to each possibility distribution corresponds a unique consonant mass function [26].

Let us now assume that we receive two mass functions m1 and m2 from two distinct sources of information assumed to
be reliable. Then m1 and m2 can be combined using the conjunctive sum (or unnormalized Dempster’s rule of combination)
deﬁned as follows:

(m1 ∩(cid:12) m2)( A) =

(cid:2)

m1(B)m2(C).

B∩C= A

(8)

This rule is commutative, associative, and admits the vacuous mass function as neutral element. It is conjunctive as the
product of m1(B) and m2(C) is transferred to the intersection of B and C . The quantity (m1 ∩(cid:12) m2)(∅) is referred to as the
degree of conﬂict between m1 and m2.

Let q1 ∩(cid:12) 2 denote the commonality function corresponding to m1 ∩(cid:12) m2. It can be computed from q1 and q2, the common-

The normalized Dempster’s rule ⊕ [26] is deﬁned as the conjunctive sum followed by a normalization step:

ality functions associated to m1 and m2, as follows:
q1 ∩(cid:12) 2( A) = q1( A) · q2( A), ∀ A ⊆ Ω.

(cid:12)

0

(m1 ⊕ m2)( A) =

(m1 ∩(cid:12) m2)( A)
1−(m1 ∩(cid:12) m2)(∅)
It is clear that m1 ⊕ m2 is deﬁned as long as (m1 ∩(cid:12) m2)(∅) < 1.

if A = ∅,
otherwise.

the choice of the union operator results in the disjunctive sum [28]:

(m1 ∪(cid:12) m2)( A) =

It can be shown that

(cid:2)

m1(B)m2(C).

B∪C= A

b1 ∪(cid:12) 2( A) = b1( A) · b2( A), ∀ A ⊆ Ω,

Alternatives to the conjunctive sum can be constructed by replacing ∩ by any binary set operation in (8). For instance,

(9)

(10)

(11)

(12)

which is the counterpart of (9). Dubois and Prade [10] have also proposed a “hybrid” rule intermediate between the con-
junctive and disjunctive sums, in which the product m1(B)m2(C) is assigned to B ∩ C whenever B ∩ C (cid:7)= ∅, and to B ∪ C
otherwise. This rule is not associative, but it usually provides a good summary of partially conﬂicting items of evidence.

In [30], Smets proposed a two-level model in which items of evidence are quantiﬁed by mass functions and combined
at the credal level, while decisions are made at the pignistic level (from the Latin pignus meaning a bet). Once a decision
has to be made, a mass function m is thus transformed into a pignistic probability distribution p. The pignistic transformation
consists in normalizing m (assuming that m(∅) < 1), and then distributing each normalized mass m( A)/(1 − m(∅)) equally
between the atoms ωk ∈ A:

(cid:2)

p(ωk) =

{ A⊆Ω,ωk∈ A}

m( A)
(1 − m(∅))| A|

, ∀ωk ∈ Ω.

(13)

Other authors have suggested the so-called plausibility transformation for transforming a mass function into a probabil-
ity distribution, by normalizing the plausibilities of singletons [3]. In a decision making context, this approach results in
selecting the most plausible single hypothesis.

2.2. Canonical decompositions and idempotent rules

According to Shafer [26], a mass function is said to be simple if it has the following form

m( A) = 1 − w0,
m(Ω) = w0,

for some A ⊂ Ω and some w 0 ∈ [0, 1]. Let us denote such a mass function as A w0 . The vacuous mass function may thus be
noted A1 for any A ⊂ Ω . It is clear that

A w 0 ∩(cid:12) A w

(cid:15)
0 = A w 0 w

(cid:15)
0 .

482

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

A mass function may be called separable if it can be obtained as the result of the conjunctive sum of simple mass functions.
It can then be written:
m = ∩(cid:12)

(14)

A⊂Ω A w( A),

with w( A) ∈ [0, 1] for all A ⊂ Ω .

Smets [29] showed that any non-dogmatic mass function m can be uniquely expressed using (14), with weights w( A)
now in (0, +∞). This is referred to as the conjunctive canonical decomposition of a mass function. Note that, when w( A) > 1,
A w( A) is no longer a mass function, but the conjunctive sum can be extended to such “generalized mass functions” in an
obvious way.

Function w is called the conjunctive weight function associated to m [5]. It is a new equivalent representation of a non-

dogmatic mass function, which may be computed directly from q as follows:

w( A) =

q(B)(−1)|B\ A|+1

, ∀ A ⊂ Ω,

or, taking logarithms,

ln w( A) = −

(−1)

|B\ A|

ln q(B), ∀ A ⊂ Ω.

(cid:13)

B⊇ A

(cid:2)

B⊇ A

(15)

(16)

In [29] and [5], w( A) was deﬁned for all strict subsets A of Ω . However, function w can be extended to 2Ω by using (15)
for A = Ω . We then have:

w(Ω) = 1
q(Ω)

= 1

m(Ω)

=

and

(cid:13)

A⊆Ω

w( A) = 1.

(cid:7) (cid:13)

(cid:9)−1

w( A)

A⊂Ω

(17)

With this convention, (16) can be extended to all A ⊆ Ω . We notice that (16) then has exactly the same form as (7), i.e.,
the formula for computing ln w from − ln q is the same as the one for computing m from q. Conversely, ln q can thus be
computed from − ln w using a formula similar to (6):

(cid:2)

ln q( A) = −

ln w(B), ∀ A ⊆ Ω.

B⊇ A

We note that function w has a simple property with respect to the conjunctive sum. Let w 1 and w 2 be two weight

functions, and let w 1 ∩(cid:12) 2 denote the result of their ∩(cid:12) -combination. Then the following relation holds:

w 1 ∩(cid:12) 2( A) = w 1( A)w 2( A), ∀ A ⊆ Ω.

(18)

In [5], Denœux introduced the cautious rule, noted ∧(cid:12) , which is obtained by replacing the product by the minimum in (18),
for all A ⊂ Ω :

(cid:10)
w 1 ∧(cid:12) 2( A) = min

(cid:11)
w 1( A), w 2( A)

.

(19)

The value of w 1 ∧(cid:12) 2(Ω) can then be determined to satisfy the normalization condition (17). This rule is obviously com-
mutative, associative and idempotent. As shown in [5], it is suitable for combining conjunctively non-independent items of
evidence. As the conjunctive sum, the cautious rule has a normalized version deﬁned by

(cid:12)

(cid:10)
m1 ∧(cid:12)

∗

m2

(cid:11)

( A) =

0

(m1 ∧(cid:12) m2)( A)
1−(m1 ∧(cid:12) m2)(∅)

if A = ∅,
otherwise.

(20)

As shown in [5], the conjunctive canonical decomposition also has a disjunctive counterpart. Any mass function m such

that m(∅) > 0 can be decomposed disjunctively as follows:

m = ∪(cid:12)

A⊃∅ A v( A),

(21)

where A v( A) is a generalized mass function assigning a mass v( A) > 0 (possibly greater than 1) to ∅, and 1 − v( A) to A,
for all A ⊆ Ω , A (cid:7)= ∅. This deﬁnes a new function v, called the disjunctive weight function, which can be computed from b as
follows:

v( A) =

b(B)(−1)| A\B|+1

, ∀ A ⊆ Ω, A (cid:7)= ∅,

(22)

(cid:13)

B⊆ A

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

or

ln v( A) = −

(cid:2)

B⊆ A

(−1)

| A\B|

ln b(B), ∀ A ⊆ Ω, A (cid:7)= ∅.

As before, the above equations can be extended to A = ∅, which leads to

(cid:7) (cid:13)

(cid:9)−1

v( A)

A(cid:7)=∅

v(∅) = 1
b(∅)

= 1

m(∅)

=

and (cid:13)

A⊆Ω

v( A) = 1.

The disjunctive rule (11) has a simple expression as a function of disjunctive weights:

v 1 ∪(cid:12) 2( A) = v 1( A)v 2( A), ∀ A ⊆ Ω.

483

(23)

(24)

(25)

By replacing the product by the minimum in the above equation, we can deﬁne a new rule, denoted ∨(cid:12) and called the bold
rule in [5]:

v 1 ∨(cid:12) 2( A) = min

(cid:10)

(cid:11)
v 1( A), v 2( A)

,

(cid:14)

(26)
A(cid:7)=∅ v 1 ∨(cid:12) 2( A))−1. This rule is obviously commutative, associative and idempotent; it is suitable for com-

A ⊆ Ω, A (cid:7)= ∅,

and v 1 ∨(cid:12) 2(∅) = (
bining disjunctively non-independent items of evidence.

3. Extension to general lattices

As shown by Grabisch [14], the theory of belief function can be extended from the Boolean lattice (2Ω , ⊆) to any lattice,
not necessarily Boolean. We will ﬁrst recall some basic deﬁnitions about lattices in Section 3.1. Grabisch’s results used in
this work will then be summarized in Section 3.2.

3.1. Lattices

A review of lattice theory can be found in [21]. The following presentation follows [14].
Let L be a ﬁnite set and (cid:3) a partial ordering (i.e., a reﬂexive, antisymmetric and transitive relation) on L. The structure
(L, (cid:3)) is called a poset. We say that (L, (cid:3)) is a lattice if, for every x, y ∈ L, there is a unique greatest lower bound (denoted
x ∧ y) and a unique least upper bound (denoted x ∨ y). Operations ∧ and ∨ are called the meet and join operations,
respectively. For ﬁnite lattices, the greatest element (denote (cid:20)) and the least element (denoted ⊥) always exist. We say that
x covers y if x > y and there is no z such that x > z > y. An element x of L is an atom if it covers only one element and
this element is ⊥. It is a co-atom if it is covered by a single element and this element is (cid:20).
(cid:15)
are isomorphic if there exists a bijective mapping f from L to L

such that x (cid:3) y ⇔ f (x) (cid:3) f ( y).
For any poset (L, (cid:3)), we can deﬁne its dual (L, (cid:2)) by inverting the order relation. A lattice is autodual if it is isomorphic to
its dual.

Two lattices L and L

A lattice is distributive if (x ∨ y) ∧ z = (x ∧ z) ∨ ( y ∧ z) holds for all x, y, z ∈ L. For any x ∈ L, we say that x has a
(cid:15) = (cid:20). L is said to be complemented if any element has
(cid:15) = ⊥ and x ∨ x
complement in L if there exists x
a complement. Boolean lattices are distributive and complemented lattices. Every Boolean lattice is isomorphic to (2Ω , ⊆)
for some set Ω . For the lattice (2Ω , ⊆), we have ∧ = ∩, ∨ = ∪, ⊥ = ∅ and (cid:20) = Ω .

(cid:15) ∈ L such that x ∧ x

(cid:15)

A closure system C on a set Θ is a family of subsets of Θ satisfying the following properties:

1. Θ ∈ C.
2. C1, C2 ∈ C ⇒ C1 ∩ C2 ∈ C.

As shown in [21], any closure system (C, ⊆) is a lattice with the following meet and join operations

C1 ∧ C2 = C1 ∩ C2,
C1 ∨ C2 =

(cid:8)

{C ∈ C | C1 ∪ C2 ⊆ C}.

3.2. Belief functions on lattices

(27)

(28)

Let (L, (cid:3)) be a ﬁnite poset having a least element, and let f be a function from L to R. The Möbius transform of f is the

function m : L → R deﬁned as the unique solution of the equation:

f (x) =

m( y), ∀x ∈ L.

(29)

(cid:2)

y(cid:2)x

484

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

Function m can be expressed as:
(cid:2)

m(x) =

μ( y, x) f ( y),

y(cid:2)x

where μ(x, y) : L2 → R is the Möbius function deﬁned inductively by:

⎧
⎨

μ(x, y) =

⎩

(cid:3)

1
−

0,

x(cid:2)t< y μ(x, t)

if x = y,
if x < y,

otherwise.

The co-Möbius transform of f
(cid:2)

q(x) =

m( y),

y(cid:3)x

is deﬁned as:

and m can be recovered from q as:

(cid:2)

m(x) =

μ(x, y)q( y).

y(cid:3)x

(30)

(31)

(32)

(33)

Let us now assume that (L, (cid:3)) is a lattice. Following Grabisch [14], a function b : L → [0, 1] will be called an implicability
function on L if b((cid:20)) = 1, and its Möbius transform is non-negative. The corresponding belief function bel can then be
deﬁned as:

bel(x) = b(x) − m(⊥), ∀x ∈ L.

Note that Grabisch [14] considered only normal belief functions, in which case b = bel. As shown in [14], any implicability
function on (L, (cid:3)) is totally monotone, i.e., for any k (cid:2) 2 and for any family x1, . . . , xk in L,

(cid:4)

(cid:6)

b

(cid:2)

xi

k(cid:18)

i=1

(cid:2)

(−1)

|I|+1b

∅(cid:7)=I⊆{1,...,k}

(cid:7) (cid:19)

(cid:9)

xi

.

i∈I

Note, however, that the converse does not hold in general: a totally monotone function may not have a non-negative Möbius
transform.

As shown in [14], most results of Dempster–Shafer theory can be transposed in the general setting of lattices. For

instance, the conjunctive sum (8) becomes:

(cid:2)

(m1 ∩(cid:12) m2)(x) =

m1( y)m2(z), ∀x ∈ L,

(34)

y∧z=x

and the following relation between commonality functions still holds:

q1 ∩(cid:12) 2(x) = q1(x) · q2(x), ∀x ∈ L.

(35)
The normalized Dempster’s rule ⊕ can still be deﬁned, as in the classical case, by dividing each number (m1 ∩(cid:12) m2)(x) with
x (cid:7)= ⊥ by 1 − (m1 ∩(cid:12) m2)(⊥), provided that (m1 ∩(cid:12) m2)(⊥) < 1.

Using a similar line of reasoning as that followed in [14], we can also extend the disjunctive rule (11) as:

(m1 ∪(cid:12) m2)(x) =

m1( y)m2(z), ∀x ∈ L,

(cid:2)

y∨z=x

and (12) becomes:

b1 ∪(cid:12) 2(x) = b1(x) · b2(x), ∀x ∈ L.

(cid:13)

w(x) =

q( y)

−μ(x, y), ∀x ∈ L, x (cid:7)= (cid:20),

y(cid:3)x

which generalizes (15). Obviously, we still have

w 1 ∩(cid:12) 2(x) = w 1(x)w 2(x), ∀x ∈ L, x (cid:7)= (cid:20).

Grabisch [14] also extended the conjunctive canonical decomposition of belief functions in the general lattice setting. He

showed that any mass function m on L such that m((cid:20)) > 0 can be decomposed as

m = ∩(cid:12)

x<(cid:20)xw(x),

(38)
where xw(x) is a simple mass function assigning 1 − w(x) to x and w(x) to (cid:20), with w(x) ∈ (0, +∞). Clearly, (38) general-
izes (14). As in the classical case, function w : L \ {(cid:20)} → (0, +∞) can be computed from q using the following equation:

(36)

(37)

(39)

(40)

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

The existence of the w function also allows us to deﬁne the cautious rule in the general lattice setting as

(cid:10)
w 1 ∧(cid:12) 2(x) = min

(cid:11)
w 1(x), w 2(x)

, ∀x ∈ L, x (cid:7)= (cid:20).

485

(41)

The normalized cautious rule ∧(cid:12) ∗
provided that w 1 ∧(cid:12) 2(⊥) < 1.

is deﬁned as in the classical case, by dividing each w 1 ∧(cid:12) 2(x) for x (cid:7)= ⊥ by 1 − w 1 ∧(cid:12) 2(⊥),

Although Grabisch did not consider the disjunctive canonical decomposition, it can also be extended in the general lattice
setting. The proof parallels that given in [14] for the conjunctive case. We will only state the main result here. Let xv(x) be
a mass function on L assigning 1 − v(x) to x and v(x) to ⊥, with v(x) ∈ (0, +∞). Any mass function m on L such that
m(⊥) > 0 can be decomposed as

m = ∪(cid:12)

x>⊥xv(x).

The function v : L \ {⊥} → (0, +∞) can be computed from b using the following equation:

(cid:13)

v(x) =

b( y)

−μ( y,x), ∀x ∈ L, x (cid:7)= ⊥,

y(cid:2)x

which generalizes (22). We still have

v 1 ∪(cid:12) 2(x) = v 1(x)v 2(x), ∀x ∈ L, x (cid:7)= ⊥,

and the existence of the v function allows us to deﬁne the bold rule as
(cid:11)
v 1(x), v 2(x)

(cid:10)
v 1 ∨(cid:12) 2(x) = min

, ∀x ∈ L, x (cid:7)= ⊥.

(42)

(43)

(44)

(45)

The extension of other notions from classical Dempster–Shafer theory may require additional assumptions on (L, (cid:3)). For
instance, the deﬁnition of the plausibility function pl as the dual of b using (5) can only be extended to autodual lattices
[14]. The deﬁnition of pl from (4) remains possible in the other cases, but the relationship between pl and b (or bel) is lost.
Also, probability measures cannot be deﬁned on arbitrary lattices. Consequently, the pignistic probability (13) can only be
extended in restricted settings.

Remark 1. Although our approach relies essentially on Grabisch’s work, we may note the existence of another line of
research that aims at extending results of Probability Theory to some classes of residuated lattices, which are more general
than Boolean algebra. In particular, there have been many developments about probability measures on MV-algebra (also
called states), see, e.g., [2,16,17,22] as well as in Gödel algebras [1]. In the course of revising this paper, we also became
aware of recent work on deﬁning belief functions on MV-algebras [18].1

4. Belief functions on set-valued variables

In this section, the main concepts of Dempster–Shafer theory recalled in Section 2 will be extended to the case where
we want to describe the uncertainty regarding a set-valued variable X on a ﬁnite domain Ω . The key to this extension
will be the deﬁnition of a closure system C(Ω) of Θ = 2Ω , i.e., a set of subsets of Θ that is closed under intersection.
Each element of C(Ω) will be shown to have a simple description as a pair of disjoint subsets of Ω . Belief functions and
associated notions will then be deﬁned on the lattice (C(Ω), ⊆), resulting in a simple framework for uncertain reasoning
about set-valued variables.

4.1. The lattice (C(Ω), ⊆)

In the rest of this paper, X denotes a set-valued variable on a ﬁnite domain Ω , i.e., a variable taking values in Θ = 2Ω .
Let A0 ⊆ Ω denote the unknown true value of X . We want to describe partial knowledge about that value in the belief
function framework.

As explained in the introduction, the formalism recalled in Section 2 could be applied without modiﬁcation to this
case, by deﬁning a mass function mΘ on Θ . However, such a brute force approach would require the storage of up to
|Θ| = 22
numbers for each mass function. Basic operations such as the conjunctive or disjunctive sums would have
2
double-exponential complexity, making the approach inapplicable except for sets Ω with very small cardinality.

|Ω|

As an alternative, we propose to deﬁne mass functions and associated functions on a subset of 2Θ that forms a lattice
when equipped with the inclusion relation. The intuitive idea underlying our approach is the fact that, when expressing
knowledge about a set-valued variable X , it is often convenient to specify sets of values that are certainly taken by X , and
sets of values that are certainly not taken by X . This can be illustrated by the following example.

1 We are indebted to one of the anonymous referees for bringing this work to our attention.

486

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

Fig. 1. Two subsets of Ω (broken lines) containing A and not intersecting B. The set of all such subsets is denoted by ϕ( A, B).

Example 1. Let X denote the languages spoken by John, deﬁned on the (very large) set Ω of existing languages. If we
know for sure that John can speak English and French (because he was brought up in the US and he stayed in France for a
long time), and that he can speak neither Japanese nor Chinese (because he never traveled to Asia), then all subsets of Ω
containing A = {English, French} and not intersecting B = {Japanese, Chinese} are possible values of X .

As shown by this example, some families of subsets of Ω or, equivalently, some subsets of Θ = 2Ω can be conveniently

described by two subsets A and B of Ω such that A ∩ B = ∅ (Fig. 1).

More generally, let Q(Ω) = {( A, B) ∈ 2Ω × 2Ω | A ∩ B = ∅Ω } be the set of ordered pairs of disjoint subsets of Ω , where

∅Ω denotes the empty set of Ω . For any ( A, B) ∈ Q(Ω), let ϕ( A, B) denote the following subset of Θ = 2Ω :

ϕ( A, B) = {C ⊆ Ω | C ⊇ A, C ∩ B = ∅Ω }.

(46)

ϕ( A, B) is thus the subset of Θ composed of all subsets of Ω including A and not intersecting B. Equivalently, it is the set
of all subsets of Ω that include A and are included in B:

ϕ( A, B) = {C ⊆ Ω | A ⊆ C ⊆ B}.

(47)

It is thus the interval [ A, B] in the lattice (Ω, ⊆).

Let C(Ω) denote the set of all subsets of Θ of the form ϕ( A, B), completed by the empty set of Θ , noted ∅Θ :
∪ {∅Θ }.

ϕ( A, B) | A ⊆ Ω, B ⊆ Ω, A ∩ B = ∅Ω

C(Ω) =

(cid:20)

(cid:21)

C(Ω) is thus a subset of 2Θ . For a reason that will become evident later, we will also use ϕ(Ω, Ω) as an alternative notation
for ∅Θ . Function ϕ is thus a bijective mapping from Q∗(Ω) = Q(Ω) ∪ {(Ω, Ω)} to C(Ω). The following proposition states
that C(Ω) is a closure system and, consequently, has a lattice structure.

Proposition 1. C(Ω) is a closure system of Θ , and
(cid:15), B ∪ B

(cid:22)

(cid:11)

(cid:10)

ϕ( A, B) ∩ ϕ

(cid:15)

A

(cid:15)

, B

=

ϕ( A ∪ A
∅Θ
(cid:15)) in Q∗(Ω).

for all ( A, B) and ( A

(cid:15), B

(cid:15))

(cid:15)) ∩ (B ∪ B

if ( A ∪ A
otherwise,

(cid:15)) = ∅Ω ,

Proof. It is obvious that Θ = ϕ(∅Ω , ∅Ω ) ∈ C(Ω). Now,
(cid:11)

(cid:20)

(cid:10)

ϕ( A, B) ∩ ϕ

(cid:15)

A

, B

(cid:15)

=

=

(cid:20)

C ⊆ Ω | C ⊇ A, C ⊇ A
(cid:11)
(cid:15)
C ⊆ Ω | C ⊇

(cid:10)

(cid:15)

(cid:10)

(cid:15) = ∅Ω
, C ∩ B = ∅Ω , C ∩ B
(cid:21)
(cid:15)
= ∅Ω
, C ∩
.
(cid:15)) is thus equal to ϕ( A ∪ A

B ∪ B

(cid:11)

A ∪ A
(cid:15), B

(cid:15)) = ∅Ω then ϕ( A, B) ∩ ϕ( A

(cid:21)

If ( A ∪ A
include A ∪ A

(cid:15)) ∩ (B ∪ B
(cid:15)

and have an empty intersection with B ∪ B

; consequently, ϕ( A, B) ∩ ϕ( A

(cid:15)

(cid:15), B

(cid:15)) = ∅Θ . (cid:2)

(cid:15), B ∪ B

(cid:15)). Otherwise, no subset C of Ω can

As recalled in Section 3.1, any closure system endowed with the inclusion relation has a lattice structure with ∧ = ∩ and

∨ deﬁned by (28). Here, the inclusion relation has the following simple expression using the ϕ( A, B) representation:

ϕ( A, B) ⊆ ϕ

(cid:15)

A

, B

(cid:15)

(cid:10)

(cid:11)

⇔ A ⊇ A

(cid:15)

and B ⊇ B

(cid:15)

.

(48)

The least element is ⊥ = ϕ(Ω, Ω) = ∅Θ . We note that (48) remains valid when A = B = Ω , which explains the interest of
the notation ϕ(Ω, Ω) = ∅Θ . The greatest element is (cid:20) = ϕ(∅Ω , ∅Ω ) = Θ . The atoms are of the form ϕ( A, A) for A ⊆ Ω ,
and the co-atoms are of the form ϕ({x}, ∅Ω ) or ϕ(∅Ω , {x}) for x ∈ Ω . We can see that the number of atoms is not equal to
the number of co-atoms, which shows that (C, ⊆) is not autodual. This lattice is also not complemented; consequently, it is
not Boolean.

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

487

As a consequence of (48), it is easy to see that the meet operation ∨ is the following operation, hereafter denoted (cid:24):

(cid:10)

(cid:11)

(cid:10)

ϕ( A, B) (cid:24) ϕ

(cid:15)

A

, B

(cid:15)

= ϕ

A ∩ A

(cid:15)

, B ∩ B

(cid:15)

(cid:11)

.

It must be noted that (cid:24) is not identical to set union. The following proposition states the relation between these two
operators.

Proposition 2. For all ( A, B) and ( A

(cid:10)

ϕ( A, B) ∪ ϕ

(cid:15)

A

, B

(cid:15)

(cid:11)

(cid:15), B
⊆ ϕ( A, B) (cid:24) ϕ

(cid:15)) in Q∗(Ω),
(cid:11)
(cid:10)
(cid:15)
(cid:15)

, B

A

.

Proof. For every C in ϕ( A, B) ∪ ϕ( A
C ⊇ A and C ⊇ A

(cid:15), B
(cid:15) ⇒ C ⊇ A ∩ A

(cid:15)), we have

(cid:15)

and

C ∩ B = ∅Ω and C ∩ B
(cid:15)). (cid:2)

(cid:15), B ∩ B

hence C ∈ ϕ( A ∩ A

(cid:15) = ∅Ω ⇒ C ∩

(cid:10)

B ∩ B

(cid:11)

(cid:15)

= ∅Ω ,

(49)

(50)

One can notice that the implications in (49) and (50) are strict. Consequently, ϕ( A, B) ∪ ϕ( A

(cid:15)) is usually a strict
(cid:15)). As the lattices (C(Ω), ⊆) and (2Θ , ⊆) do not have the same join operator, (C(Ω), ⊆) is not a

(cid:15), B

(cid:15), B

subset of ϕ( A, B) (cid:24) ϕ( A
sublattice of (2Θ , ⊆), although it is a subposet.

As noticed in [15], any ordered pair ( A, B) of disjoint subsets of Ω = {ω1, . . . , ωK } can be represented by a vector

(u1, . . . , u K ) ∈ {−1, 0, 1}K , with

⎧
⎨

ui =

⎩

if ωi ∈ A,
1
−1 if ωi ∈ B,
otherwise.
0

Consequently, any ϕ( A, B) ∈ C(Ω) such that ( A, B) (cid:7)= (Ω, Ω) can be represented in the same way. For ϕ(Ω, Ω) = ∅Θ , a
special representation can be adopted, e.g., (∗, . . . , ∗). This encoding makes it possible to implement the ∩ and (cid:24) operations
in a simple way using generalized truth tables. It also makes it clear that the cardinality of C(Ω) is equal to 3K + 1.

4.2. Belief functions on C(Ω)

The general theory recalled in Section 3.2 can be applied directly to the lattice (C(Ω), ⊆).
Let m : C(Ω) → [0, 1] be a mass function on C(Ω). The notation m(ϕ( A, B)) will be simpliﬁed to m( A, B). For this reason,

m will be called a two-place mass function. We assume that

(cid:2)

( A,B)∈Q∗(Ω)

m( A, B) = 1.

The implicability, belief and commonality functions can be computed from m using the following formula:

(cid:2)

(cid:2)

b( A, B) =

m(C, D) =

ϕ(C,D)⊆ϕ( A,B)
bel( A, B) = b( A, B) − m(Ω, Ω),
(cid:2)
q( A, B) =

m(C, D) =

C⊇ A,D⊇B

(cid:2)

ϕ(C,D)⊇ϕ( A,B)

C⊆ A,D⊆B

m(C, D),

m(C, D),

(51)

(52)

(53)

where all pairs ( A, B) and (C, D) are understood to belong to Q∗(Ω) (the same convention will be adopted throughout this
paper). The conjunctive sum operation in C(Ω) is deﬁned as follows:

(cid:2)

(m1 ∩(cid:12) m2)( A, B) =

=

m1(C, D)m2(E, F )

ϕ(C,D)∩ϕ(E,F )=ϕ( A,B)
(cid:12) (cid:3)
(cid:3)

C∪E= A,D∪F =B m1(C, D)m2(E, F )
(C∪E)∩(D∪F )(cid:7)=∅Ω

m1(C, D)m2(E, F )

It can be computed using the commonality functions as:
q1 ∩(cid:12) 2( A, B) = q1( A, B) · q2( A, B), ∀( A, B) ∈ Q∗

(Ω).

Similarly, the disjunctive sum can be computed as:

if A ∩ B = ∅Ω ,
if A = B = Ω.

(54)

(55)

(56)

488

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

(m1 ∪(cid:12) m2)( A, B) =

(cid:2)

m1(C, D)m2(E, F )

=

ϕ(C,D)(cid:24)ϕ(E,F )=ϕ( A,B)

(cid:2)

m1(C, D)m2(E, F ),

C∩E= A,D∩F =B

or using implicability functions:

b1 ∪(cid:12) 2( A, B) = b1( A, B) · b2( A, B), ∀( A, B) ∈ Q∗

(Ω).

(57)

(58)

It is also possible to deﬁne a rule expressing a consensus among items of evidence, somehow in the same spirit as the
Dubois–Prade rule recalled in Section 2.1. Assume that we learn from two sources that the value of X is in ϕ(C, D) and in
ϕ(E, F ), but that ϕ(C, D) ∩ ϕ(E, F ) = ∅Θ , i.e., (C ∪ E) ∩ (D ∪ F ) (cid:7)= ∅Ω , so that the two pieces of information are in conﬂict.
It may still be safe to keep (C ∪ E) \ (D ∪ F ) as positive information, and (D ∪ F ) \ (C ∪ E) as negative information. Denoting
by (cid:25) the following operation on C(Ω):

ϕ(C, D) (cid:25) ϕ(E, F ) = ϕ

(cid:10)

(cid:11)
(C ∪ E) \ (D ∪ F ), (D ∪ F ) \ (C ∪ E)

,

we may deﬁne a new combination rule as

(cid:2)

(m1 (cid:4) m2)( A, B) =

ϕ(C,D)(cid:25)ϕ(E,F )=ϕ( A,B)

m1(C, D)m2(E, F ).

(59)

This rule will be referred to as the consensus rule. We note that operations (cid:25) and (cid:4) are not associative. However, they are
quasi-associative, as it is possible to deﬁne a n-ary version of (cid:25) as:

ϕ(C1, D1) (cid:25) · · · (cid:25) ϕ(Cn, Dn) = ϕ

(cid:4)

n(cid:5)

(cid:23) n(cid:5)

(cid:23) n(cid:5)

(cid:23) n(cid:5)

Ci

D i,

D i

Ci

.

i=1

i=1

i=1

i=1

(cid:6)

To compute functions m, w and v from q or b using (30), (33), (39) and (43), we need the expression of the Möbius

function μ. It is given in the following proposition.

Proposition 3. The Möbius function on (C(Ω), ⊆) is given, for any ( A, B) and ( A
(cid:15)),
(−1)| A\ A
0

if ϕ( A, B) ⊆ ϕ( A
otherwise.

ϕ( A, B), ϕ

(cid:15)|+|B\B

(cid:10)
μ

(cid:15), B

, B

(cid:11)(cid:11)

=

(cid:22)

A

(cid:10)

(cid:15)|

(cid:15)

(cid:15)

(cid:15), B

(cid:15)) in Q∗(Ω) by

Proof. The proof is similar to that of Theorem 2 in [15] with simple adaptations, due to the similarity between two-place
belief functions on C(Ω) and bi-capacities (see Remark 2 below). (cid:2)

This result allows us to compute m from b as:

m( A, B) =

and from q as

m( A, B) =

(−1)

|C\ A|+|D\B|

b(C, D),

(−1)

| A\C|+|B\D|

q(C, D).

(cid:2)

C⊇ A,D⊇B

(cid:2)

C⊆ A,D⊆B

(cid:13)

The conjunctive and disjunctive weight functions may be computed, respectively, as:

w( A, B) =

q(C, D)(−1)| A\C|+|B\D|+1

, ∀( A, B) (cid:7)= (∅Ω , ∅Ω ),

C⊆ A,D⊆B

and

v( A, B) =

(cid:13)

C⊇ A,D⊇B

b(C, D)(−1)|C\ A|+|D\B|+1

, ∀( A, B) (cid:7)= (Ω, Ω),

which makes it possible to use the cautious and bold rules in this context.

(60)

(61)

(62)

(63)

Example 2. Let X now denote the set of languages spoken by Bernard. Assume that we are 100% sure that Bernard speaks
no other language than Dutch (d), English (e) and French ( f ), so that we can restrict the domain of X to Ω = {d, e, f }.
Suppose that we have the following items of evidence:

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

489

Table 1
Computation of the conjunctive sum of m1 and m2 in Example 2. The columns and the lines correspond to the focal elements of m1, and m2, respectively.
Each cell contains the intersection of a focal element of m1 and a focal element of m2. The mass of each focal element is indicated below it.

({e}, ∅)
0.7

({ f }, ∅)
0.15

(∅, ∅)
0.15

({d}, { f })
0.27
({d, e}, f )
0.7 × 0.27

∅Θ
0.15 × 0.27

({d}, { f })
0.15 × 0.27

({ f }, {d})
0.29
({e, f }, {d})
0.7 × 0.29

({ f }, {d})
0.15 × 0.29

({ f }, {d})
0.15 × 0.29

({ f , d}, ∅)
0.34
({e, f , d}, ∅)
0.7 × 0.34

({ f , d}, ∅)
0.15 × 0.34

({ f , d}, ∅)
0.15 × 0.34

(∅, ∅)
0.1
({e}, ∅)
0.7 × 0.1

({ f }, ∅)
0.15 × 0.1

(∅, ∅)
0.15 × 0.1

1. Bernard is Belgian. Approximately 60% of Belgians are Dutch-speaking, and 40% of Belgians are French-speaking (we
neglect here the small German-speaking community for simplicity). According to a recent survey, approximately 20%
of French-speaking Belgians declare to have good knowledge of Dutch, whereas around 50% of members of the Dutch
speaking community claim to have good knowledge of French.

2. Bernard studied three years in Canada, where most universities are English-speaking, and some are French speaking.
Based on available evidence, we have a 0.7 degree of belief that Bernard studied in an English-speaking university, and
a 0.15 degree of belief that he studied in a French-speaking one.

Each of these two items of evidence can be represented by a mass function on C(Ω). According to the ﬁrst item of evidence,
approximately (0.6 × 0.5) × 100 = 30% of Belgians speak Dutch and no French, approximately (0.4 × 0.8) × 100 = 32% speak
French and no Dutch, and the rest speak both languages. Knowing that Bernard belongs to this population (and nothing
else), and assuming these ﬁgures to be accurate, this would lead to the following mass function:
= 0.32,

{ f , d}, ∅

= 0.38.

{d}, { f }

{ f }, {d}

= 0.3,

(cid:10)

(cid:11)

(cid:11)

(cid:10)

(cid:10)

(cid:11)

m1

m1

m1

To account for inaccuracy of these ﬁgures, we may discount this mass function [26] by transferring a fraction of the mass
(say, 10%) to the greatest element of C(Ω), i.e., ϕ(∅, ∅). We thus have

(cid:10)

(cid:10)

m1

m1

(cid:11)

{d}, { f }
{ f , d}, ∅

= 0.3 × 0.9 = 0.27,
(cid:11)
= 0.38 × 0.9 ≈ 0.34,

(cid:10)

m1

(cid:11)

{ f }, {d}

= 0.32 × 0.9 ≈ 0.29,

m1(∅, ∅) = 0.1.

The second item of evidence can be represented by a mass function m2 deﬁned as:

(cid:10)

(cid:11)

(cid:10)

(cid:11)

m2

{e}, ∅

= 0.7,

m2(∅, ∅) = 0.15.
Assuming these two items of evidence to be distinct, they should be combined using the conjunctive sum operation ∩(cid:12) .
This may be achieved in two ways:

= 0.15,

{ f }, ∅

m2

1. We may compute the intersection between each focal element of m1 and each focal element of m2 and apply for-

mula (54). The computations may be presented as in Table 1.

2. Alternatively, we may compute the commonality functions q1 and q2 using (53), multiply them, and convert the result

into a mass function using (61). The intermediate and ﬁnal results are shown in Table 2.

We may check that both approaches yield the same result. In particular, we can see that the empty set ∅Θ receives a mass
equal to 0.15 × 0.27 = 0.0405, which can be interpreted as a degree of conﬂict between m1 and m2. Using the consensus
rule (cid:4) (59), the mass 0.15 × 0.27 would be transferred to
(cid:11)

(cid:10)

(cid:11)

(cid:11)

ϕ

{ f }, ∅

(cid:25) ϕ

(cid:10)
{d}, { f }

(cid:10)
{d}, ∅

,

= ϕ

resulting in a normal, conﬂict-free mass function.

Table 2 also shows the normal mass function computed using the normalized Dempster’s rule ⊕, and Table 3 displays the
intermediate steps and ﬁnal results for computing the combinations of m1 and m2 using the unnormalized and normalized
cautious rules.

Remark 2. We may remark here that the concept of two-place mass and belief functions deﬁned here bears some similarity
with bi-capacities introduced by Grabisch and Labreuche [15]. A bi-capacity as deﬁned in [15] is an increasing function
deﬁned on the lattice (Q(Ω), (cid:27)), where (cid:27) is the partial ordering on Q(Ω) deﬁned by ( A, B) (cid:27) (C, D) if A ⊆ B and C ⊇ D.
In [15], Grabisch and Labreuche introduce various concepts related to bi-capacities, with application to cooperative game
theory. In [19], they introduce the concept of bi-belief function, deﬁned as a totally monotone bi-capacity from Q(Ω)
to [0, 1]. They suggest an interpretation in terms of bipolar representation of uncertainty for the case of a single-valued
variable. Bi-belief functions and two-place belief functions as introduced here are thus two distinct classes of belief functions
built on different lattices, with different interpretations.

490

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

Table 2
Computation of m1 ∩(cid:12) m2 and m1 ⊕ m2 in Example 2.

A
{de f }
∅
∅
{ f }
∅
∅
{ f }
{e}
{e}
{e f }
∅
∅
{ f }
∅
∅
{ f }
{e}
{e}
{e f }
{d}
{d}
{df }
{d}
{d}
{df }
{de}
{de}
{de f }

B
{de f }
{de f }
{de}
{de}
{df }
{d}
{d}
{df }
{d}
{d}
{e f }
{e}
{e}
{ f }
∅
∅
{ f }
∅
∅
{e f }
{e}
{e}
{ f }
∅
∅
{ f }
∅
∅

m1

0
0
0
0
0
0
0.29
0
0
0
0
0
0
0
0.1
0
0
0
0
0
0
0
0.27
0
0.34
0
0
0

q1

1
0.1
0.1
0.39
0.1
0.1
0.39
0.1
0.1
0.39
0.1
0.1
0.1
0.1
0.1
0.1
0.1
0.1
0.1
0.37
0.1
0.44
0.37
0.1
0.44
0.37
0.1
0.44

Table 3
Computation of m1 ∧(cid:12) m2 and m1 ∧(cid:12) ∗

m2 in Example 2.

A
{de f }
∅
∅
{ f }
∅
∅
{ f }
{e}
{e}
{e f }
∅
∅
{ f }
∅
∅
{ f }
{e}
{e}
{e f }
{d}
{d}
{df }
{d}
{d}
{df }
{de}
{de}
{de f }

B
{de f }
{de f }
{de}
{de}
{df }
{d}
{d}
{df }
{d}
{d}
{e f }
{e}
{e}
{ f }
∅
∅
{ f }
∅
∅
{e f }
{e}
{e}
{ f }
∅
∅
{ f }
∅
∅

m1

0
0
0
0
0
0
0.29
0
0
0
0
0
0
0
0.1
0
0
0
0
0
0
0
0.27
0
0.34
0
0
0

w 1

6.349
1
1
1
1
1
0.256
1
1
1
1
1
1
1
10
1
1
1
1
1
1
1
0.270
1
0.227
1
1
1

m2

0
0
0
0
0
0
0
0
0
0
0
0
0
0
0.15
0.15
0
0.7
0
0
0
0
0
0
0
0
0
0

m2

0
0
0
0
0
0
0
0
0
0
0
0
0
0
0.15
0.15
0
0.7
0
0
0
0
0
0
0
0
0
0

q2

1
0.15
0.15
0.3
0.15
0.15
0.3
0.85
0.85
1
0.15
0.15
0.3
0.15
0.15
0.3
0.85
0.85
1
0.15
0.15
0.3
0.15
0.15
0.3
0.85
0.85
1

w 2

1
1
1
1
1
1
1
1
1
1
1
1
1
1
6.67
0.5
1
0.176
1.7
1
1
1
1
1
1
1
1
1

q1 ∩(cid:12) 2

1
0.015
0.015
0.117
0.015
0.015
0.117
0.085
0.085
0.39
0.015
0.015
0.03
0.015
0.015
0.03
0.085
0.085
0.1
0.0555
0.015
0.132
0.0555
0.015
0.132
0.3145
0.085
0.44

w 1∧2

1
1
1
1
1
1
0.256
1
1
1
1
1
1
1
719.6
0.5
1
0.176
1
1
1
1
0.270
1
0.227
1
1
1

m1 ∩(cid:12) m2
0.0405
0
0
0
0
0
0.087
0
0
0.203
0
0
0
0
0.015
0.015
0
0.07
0
0
0
0
0.0405
0
0.102
0.189
0
0.238

m1 ∧(cid:12) m2
0.864
0
0
0
0
0
0.00806
0
0
0.0376
0
0
0
0
0.00139
0.00139
0
0.00649
0.00649
0
0
0
0.00375
0
0.00945
0.0175
0
0.0441

m1 ⊕ m2

0
0
0
0
0
0
0.091
0
0
0.212
0
0
0
0
0.016
0.016
0
0.07
0
0
0
0
0.0422
0
0.106
0.197
0
0.248

m2

m1 ∧(cid:12) ∗
0
0
0
0
0
0
0.0591
0
0
0.276
0
0
0
0
0.0102
0.0102
0
0.0477
0.0477
0
0
0
0.0275
0
0.0694
0.129
0
0.324

Remark 3. Another remark concerns decision making. As noted in the previous section, the lattice (C(Ω), ⊆) is not Boolean,
so that the notion of pignistic probability cannot be deﬁned in that lattice. In the classical setting, a common alternative
to the rule of maximum pignistic probability for decision making is that of maximum plausibility: it consists in selecting
the element of Ω with the greatest plausibility or, equivalent, with the greatest commonality (as these two functions
coincide on singletons). In C(Ω), we may propose as a reasonable decision rule to select the atom ϕ( A, A) with the highest

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

491

Table 4
Commonalities of atoms according to m1 ⊕ m2, m1 (cid:4) m2 and m1 ∧(cid:12) ∗

m2 in Example 2.

( A, A)
(∅, {de f })
({ f }, {de})
({e}, {df })
({e f }, {d})
({d}, {e f })
({df }, {e})
({de}, { f })
({de f }, ∅)

q1⊕2( A, A)

0.0156
0.122
0.0889
0.406
0.0578
0.138
0.328
0.459

q1(cid:2)2( A, A)
0.015
0.117
0.085
0.39
0.096
0.173
0.355
0.481

q1∧∗ 2( A, A)

0.0102
0.0796
0.0578
0.451
0.0377
0.0898
0.214
0.509

commonality. Table 4 shows the commonalities of the atoms computing from m1 ⊕m2, m1 (cid:4)m2 and m1 ∧(cid:12) ∗
m2 in Example 2.
In that particular case, we can see that the three rules lead to the same conclusion, which is that Bernard speaks all three
languages. The second most likely hypothesis is that Bernard speaks English and French, but no Dutch. However, it is clear
that different combination rules may, in general, result in different decisions.

The following section will be devoted to a review of previous work on uncertainty representation for set-valued variables.

5. Relation to previous work

This section discusses the relation between the notions introduced above and related concepts or other formalisms

already proposed for handling set-valued variables.

5.1. Disjunctive vs. conjunctive bodies of evidence

Yager [32,33] was among the ﬁrst authors to emphasize the fundamental difference between single-valued and set-values
variables, and to develop speciﬁc formalisms for reasoning with the latter. In [33], a distinction is made between disjunctive
and conjunctive information using set-based representations. Given a variable X taking a single value in Ω , a statement
“ X is A” with A ⊆ Ω means that X takes some value in A, but we do not know which one. In contrast, if X is multiple-
valued, the same statement is understood to mean that X takes all values in A (and possibly other values outside A). The
corresponding piece of information is called “disjunctive” in the former case, and “conjunctive” in the latter. Yager then
proceeds by observing that there is some kind of duality between disjunctive and conjunctive knowledge. For instance, the
statement P 1: “ X is A” implies P 2: “ X is B” whenever B ⊇ A in the disjunctive case, whereas P 2 can be deduced from P 1
whenever B ⊆ A in the conjunctive case. If we know that P 1 and P 2 both hold, then we can deduce “ X is A ∩ B” in the
disjunctive case, and “ X is A ∪ B” in the conjunctive case, etc.

Viewing mass functions as generalized sets, Dubois and Prade [8] remarked that the same distinction holds in the belief
function framework. They pointed out that, when a mass function m represents a body of evidence pertaining to a set-
valued variable (referred to as a conjunctive body of evidence), the commonality function q is more appropriate than b for
representing degrees of belief, and the disjunctive sum (11) should be used for combining information conjunctively.

The formalism developed in Section 4 sheds new light on this duality between conjunctive and disjunctive knowledge.
The conjunctive statement “ X is A” corresponds to the proposition ϕ( A, ∅). Let m be a mass function on C(Ω) whose focal
(cid:15)( A) = m( A, ∅) for all A. Using (51), we then have, for
elements are all of the form ϕ(B, ∅) for some B ⊆ Ω . We can note m
all A ⊆ Ω :

b( A, ∅) =

(cid:2)

B⊇ A

m(B, ∅) =

(cid:2)

B⊇ A

(cid:15)

m

(B) = q

(cid:15)

( A),

where q

(cid:15)

is the commonality function corresponding to m
(cid:2)

(cid:2)

q( A, ∅) =

m(B, ∅) =

(cid:15)

(B) = b

(cid:15)

( A).

B⊆ A

m

B⊆ A

(cid:15)

. Conversely,

As a consequence, let m1 and m2 be two mass functions on C(Ω) with focal elements of the form described above, and
assume that we want to combine them conjunctively using (56). We get

q1 ∩(cid:12) 2( A, ∅) = q1( A, ∅)q2( A, ∅) = b

(cid:15)
1( A)b

(cid:15)
2( A) = b

(cid:15)
1 ∪(cid:12) 2( A)

for all A ⊆ Ω , which explains why the disjunctive sum seems to be used when combining conjunctive bodies of evidence in
a conjunctive manner.

492

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

5.2. Random sets

Random sets are deﬁned as random elements taking values as subsets of some space [20,23]. In the ﬁnite case, a random
A⊆Ω m( A) = 1, which is mathematically equivalent to a
set is thus deﬁned by a probability function m on 2Ω such that
Dempster–Shafer mass function on Ω [24]. However, as noted by Smets [27], the semantics of random sets and (standard)
belief functions are different, as random sets model random experiments with set-valued outcomes, whereas standard belief
functions quantify beliefs regarding a variable taking a single, but unknown value.

(cid:3)

In contrast, random sets are recovered as a special class of belief functions on set-valued variables introduced in this
paper. Let m be a mass function on C(Ω), and assume that the focal elements of m are atoms of C(Ω), i.e., if they are of
(cid:15)( A) = m( A, A) for all A ⊆ Ω is a random set.
from 2Ω to [0, 1] such that m
the form ( A, A). In that case, the function m
Random sets are thus equivalent to mass functions on C(Ω) with atomic focal elements, just as probability distributions on
Ω are equivalent to mass functions on 2Ω with singleton focal elements.

(cid:15)

5.3. Veristic variables

In [34,35], Yager develops a theory of veristic variables, which can be deﬁned as fuzzy set-valued variables. Let X denote
a fuzzy set-valued variable on a domain Ω , i.e., a variable taking a single value in the set I Ω of fuzzy subsets of Ω . For any
x ∈ Ω and any A ∈ I Ω , we denote by A(x) the degree of membership of x in A. Let A0 ∈ I Ω denote the unknown true value
of X . Yager considers four ways of associating variable X with a fuzzy set A ∈ I Ω , using the following statements:

1. X isv A, meaning that A ⊆ A0, where ⊆ denotes standard fuzzy set inclusion, i.e., A(x) (cid:3) A0(x) for all x ∈ Ω ;
2. X isv(n) A, meaning that A0 ⊆ A, where A denotes the complement of A with membership function A(x) = 1 − A(x) for

all x ∈ Ω ;

3. X isv(c) A, meaning that A0 = A;
4. X isv(c, n) A, meaning that A0 = A.

In the above expressions, the copula isv has two parameters: c for closed (exclusive) and n for negative. We observe that
the statement X isv(c, n) A is equivalent to X isv(c) A. Consequently, we need only to consider the ﬁrst three cases.

As remarked by Yager, each of these basic types of statements can be interpreted as specifying a set W of fuzzy subsets
of Ω , i.e., a crisp subset of I Ω . W contains the possible values of variable X . It is deﬁned as follows for the three types of
statements:

(cid:20)

−→ W =
X isv A
X isv(n) A −→ W =
X isv(c) A −→ W = { A}.

(cid:20)

F ∈ I Ω | F (x) (cid:2) A(x), ∀x ∈ Ω
F ∈ I Ω | F (x) (cid:3) A(x), ∀x ∈ Ω

(cid:21)
,
(cid:21)
,

Yager also associated to W two functions from Ω to [0, 1], called the verity and rebuff distributions, and deﬁned as

follows:

F (x),

Ver(x) = min
F ∈W
Rebuff(x) = 1 − max
F ∈W

F (x) = min
F ∈W

1 − F (x) = min
F ∈W

F (x).

Ver(x) is thus the minimal degree of membership of x to any possible value of X : it can be interpreted as the minimal
support for x being one of the values taken by X . In contrast, Rebuff(x) can be interpreted as the minimal support for x
not being one of the values taken by X . These two distributions have the following expressions for the three basic types of
statements:

−→ Ver(x) = A(x), Rebuff(x) = 0,

X isv A
X isv(n) A −→ Ver(x) = 0,
X isv(c) A −→ Ver(x) = A(x), Rebuff(x) = 1 − A(x).

Rebuff(x) = A(x),

Clearly, a major difference between Yager’s approach and ours is the fact that Yager represents each piece of knowledge
about X as a set of fuzzy subsets of Ω , whereas we use a set of crisp subsets of Ω . However, the kinds of statements
considered by Yager as well as the associated verity and rebuff distributions have very close representations in our approach.
To begin with, let us provisionally assume that A is a crisp subset of Ω . Then, each of the three types of statements can

be expressed by categorical mass functions on C(Ω) as follows:

−→ m( A, ∅) = 1,
X isv A
X isv(n) A −→ m(∅, A) = 1,
X isv(c) A −→ m( A, A) = 1.

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

It is easy to see that, in each of these three cases:

(cid:11)

(cid:11)

(cid:10)
{x}, ∅
(cid:10)
∅, {x}

b

b

= Ver(x),
= Rebuff(x)

493

(64)

(65)

for all x ∈ Ω . The verity of x is thus the belief that x is one of the values taken by X , whereas the rebuff of x is the belief
that x is not a value taken by X . This interpretation can be shown to remain true when A is a fuzzy subset of Ω . In that
case, the function x → A(x) can be seen as a possibility distribution, which is known to be equivalent to a consonant mass
function m
(cid:10)

on Ω with focal elements A1 ⊆ · · · ⊆ An. The corresponding plausibility function pl
(cid:11)

veriﬁes

(cid:2)

(cid:15)

(cid:15)

(cid:15)

pl

{x}

=

(cid:15)

m

Ai (cid:28)x

( Ai) = A(x), ∀x ∈ Ω.

For instance, let us consider the statement X isv A, and let us translate it as the following two-place mass function:

m( Ai, ∅) = m

(cid:15)

( Ai),

i = 1, . . . , n.

We have
(cid:10)
{x}, ∅

b

(cid:11)

=

(cid:2)

Ai (cid:28)x

m( Ai, ∅) =

(cid:2)

Ai (cid:28)x

and

(cid:11)

(cid:10)
∅, {x}

b

= 0 = Rebuff(x).

(cid:15)

m

( Ai) = A(x) = Ver(x)

By handling the two other cases similarly, it can be veriﬁed that Eqs. (64) and (65) hold in all cases.

We may thus conclude that, although based on a slightly different interpretation, Yager’s framework can be easily trans-
lated into the formalism of two-place belief functions, which is more general. However, this is only true at the static level,
i.e., as long as we do not combine different pieces of information. For instance, as shown by Yager, the conjunctive com-
bination of two statements X isv A and X isv B in the veristic framework results in a new statement X isv A ∪ B, where ∪
denotes fuzzy set union. This is consistent with our approach only as long as A and B are crisp sets. If A and B are fuzzy,
then translating the two statements as two-place mass functions and combining them using either the conjunctive sum or
the cautious rule does not, in general, yield a consonant mass function corresponding to a veristic constraint on X . The two
formalisms thus differ when combining statements involving fuzzy subsets.

5.4. Two-fold fuzzy sets

To complete this review of previous work on uncertainty representation for set-valued variables, we need to mention the

representation of incomplete conjunctive information using a pair of fuzzy sets introduced in [9].

In this work, Dubois and Prade proposed to represent partial knowledge about a set-valued variable as a possibility
distribution π on 2Ω . This is equivalent to deﬁning a fuzzy set of crisp subsets of Ω , which contrasts with Yager’s approach
who deﬁnes a crisp set W of fuzzy subsets of Ω . To make such a representation more easily tractable, Dubois and Prade
+) as follows. Let Ai , i ∈ I , be the family of subsets of Ω
−, A
then proposed to approximate π by a pair of fuzzy sets ( A
such that π ( Ai) > 0. Let
(x) = 1 − sup
i: x /∈ Ai

π ( Ai)

A

−

and

+

A

(x) = sup
i: x∈ Ai

π ( Ai).

−

+(x)
The degree of membership of x to A
+), referred to as a two-fold fuzzy set, constitutes
corresponds to the possibility of ﬁnding an Ai containing x. The pair ( A
an approximation of π in the sense that it is a simpler, but incomplete representation: several possibility distributions π
correspond to the same two-fold fuzzy set. However, Dubois and Prade showed that the least speciﬁc possibility distribution
π ∗

is thus the extent to which is impossible to ﬁnd an Ai not containing x, while A

+) can be expressed as π ∗(∅) = 1 − sup A

, π ∗(Ω) = inf A

−, A

−, A

, and

+

−

induced by a two-fold fuzzy set ( A
(cid:24)
(B) = min

π ∗

+

(cid:10)

(cid:11)(cid:25)

−

1 − A

, ∀B ∈ 2Ω \ {∅, Ω}.

A

(x)

inf
x∈B

To each two-fold fuzzy set ( A

(x), inf
x /∈B
+) can thus be associated a fuzzy subset A of 2Ω , with membership function equal to π ∗
.
We note that this approach has some similarity with ours, since it is based on the representation of a subset of 2Ω by
are crisp, then the corresponding crisp subset A of 2Ω is exactly equal to
−, A+). However, in the general case, the two-fold fuzzy set representation is based on a pair of possibility distributions,

a pair of subsets of Ω . Actually, if A
ϕ( A
i.e., consonant belief functions on Ω , whereas our approach is based on a single two-place belief function on C(Ω).

−, A

and A

−

+

494

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

−, B

−, A

−, A

− ∪ B

What can be seen as a limitation of the two-fold fuzzy set approach arises when combining information from several
+) and (B
+) representing knowledge about two set-valued variables X and Y , Dubois
sources. Given two pairs ( A
+), while the knowledge of X ∪ Y can
+ ∩ B
−, A
and Prade showed that the knowledge of X ∩ Y can be represented by ( A
+). Applications of this kind of reasoning to database query evaluation is discussed in [9].
be represented by ( A
However, a different and maybe more common problem in uncertain reasoning is the situation where we have two items
+) and
of evidence about a single set-valued variable X , and we want to combine these two items of evidence. If ( A
+) correspond, respectively, to fuzzy subsets A and B of 2Ω , the result of the combination should ideally correspond
(B
to A ∩ B or to A ∪ B, depending on the choice of a conjunctive or disjunctive combination mechanism. However, none of
these two fuzzy subsets of 2Ω generally admits a two-fold fuzzy set representation, which restricts the use of this formalism
for reasoning with set-valued variables.

− ∩ B

+ ∪ B

−, A

−, B

We have shown that the formalism of two-place belief functions introduced in this paper seems to compare favorably in
terms of expressive power with existing formalisms for representing and reasoning with uncertain conjunctive information.
In the next section, we will demonstrate the usefulness of this formalism for a certain category of classiﬁcation problems.

6. Application to multi-label classiﬁcation

In this section, we present an application of the framework developed in this paper to multi-label classiﬁcation.2 In
this kind of problems, each object may belong simultaneously to several classes, contrary to standard single-label problems
where objects belong to only one class [13,38,12,36]. Multi-label classiﬁcation tasks arise in many real-world problems. For
instance, in image retrieval, each image may belong to several semantic classes such as beach and urban. In text categoriza-
tion, each document may belong to several topics, etc. In such problems, the learning task consists in predicting the value
of the class variable for a new instance, based on a training set. As the class variable is set-valued, the framework developed
in this paper may be used.

In order to construct a multi-label classiﬁer, we generally assume the existence of a labeled training set, composed of
n examples (xi, Y i), where xi is a feature vector describing instance i, and Y i is a label set for that instance, deﬁned as
a subset of the set Ω of classes. In practice, however, gathering such high quality information is not always feasible at a
reasonable cost. In many problems, there is no ground truth for assigning unambiguously a label set to each instance, and
the opinions of one or several experts have to be elicited. Typically, an expert will sometimes express lack of conﬁdence
for assigning exactly one label set. If several experts are consulted, some conﬂict will inevitably arise, which again will
introduce some uncertainty in the labeling process.

The formalism developed in this paper can easily be used to handle such situations. In the most general setting, the
opinions of one or several experts regarding the set of classes that pertain to a particular instance i may be modeled by
a mass function mi on C(Ω). A less general, but arguably more workable option is to restrict mi to be categorical, i.e., to
have a single focal element ϕ( Ai, B i), with Ai, B i ⊆ Ω and Ai ∩ B i = ∅. The set Ai is then the set of classes that certainly
apply to example i, while B i the set of classes that certainly do not apply. In a multiple expert setting, Ai might represent
the set of classes indicated by all (or most) experts as relevant to describe instance i, while B i would be the set of classes
mentioned by none of the experts (or only a few of them). The usual situation of precise labeling is recovered in the special
case where B i = Ai .

For instance, assume that instances are songs and classes are emotions generated by these songs, as in the emotion
dataset that will be used in Section 6.3 below. Upon hearing a song, an expert may decide that this song certainly evokes
happiness and certainly does not evoke sadness, but may be undecided regarding the other emotions (such as quietness,
anger, surprise, etc.). In that case, the song cannot be assigned a single label set, but we can associate to it the set of all
label sets containing “happiness” and not containing “sadness”, which has the form suggested above.

In [4,39], we introduced a single-label k-nearest neighbor (NN) classiﬁer based on Dempster–Shafer theory. This method
will be brieﬂy recalled in Section 6.1, and will be extended to multi-label classiﬁcation tasks in Section 6.2. An experimental
comparison with the multi-label k nearest neighbor (ML-kNN) method introduced in [38] using real-world data will then
be presented in Section 6.3.

6.1. Single-label evidential k-NN classiﬁcation

The evidential k-NN method introduced in [4] for single-label classiﬁcation problems can be summarized as follows. Let
L = {(x1, A1), . . . , (xn, An)} be a learning set of n instances, where xi is a p-dimensional attribute vector describing instance
i, and Ai ⊆ Ω = {ω1, . . . , ωK } is a set of possible classes for instance i. We emphasize the fact that, in the context considered
here, each instance i actually belongs to one and only one class, but this class is only known to lie somewhere in Ai .

Let x denote the feature vector for a new object with unknown class y. We want to guess the value of y based on
evidence provided by the learning set L. For that purpose, we consider the set Φk(x) of the k nearest neighbors of x,
according to some distance measure d (usually, the Euclidean one). Each learning instance (xi, Ai) with xi ∈ Φk(x) can then

2 A preliminary version of the application described in this section was presented in [37].

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

495

be regarded as a piece of evidence regarding the unknown value of y, represented as the following simple mass function
on Ω :

mi( Ai) = α exp
mi(Ω) = 1 − α exp

(cid:10)

(cid:11)
−γ d(x, xi)

,

(cid:10)

(cid:11)
−γ d(x, xi)

,

(66)

(67)

with 0 < α < 1 and γ > 0. Parameter α is usually ﬁxed at a value close to 1 such as α = 0.95, whereas γ should depend
on the scaling of distances and can be either ﬁxed heuristically or optimized [39]. The evidence of the k NNs is then pooled
using the conjunctive sum:

m = ∩(cid:12)

i: xi ∈Φ(x)mi,

(68)

and the class with highest plausibility or pignistic probability is selected. As remarked in [7] and [6], this method can be
easily extended to the case where each learning instance in L is labeled by a general mass function on Ω .

6.2. Multi-label evidential k-NN classiﬁcation

Let us now come back to the multi-label classiﬁcation problem, in which objects may belong simultaneously to several
classes. Let L = {(x1, A1, B1), . . . , (xn, An, Bn)} be the learning set, where Ai ⊆ Ω = {ω1, . . . , ωK } denotes a set of classes
that surely apply to instance i, and B i ⊆ Ω a set of classes that surely do not apply to the same instance. If Y i ⊆ Ω denotes
the true label set of instance i, we thus only know that Y i ∈ ϕ( Ai, B i).

As before, let Φk(x) denote the set of k nearest neighbors of a new instance described by feature vector x, and xi an
element of that set with label ( Ai, B i). This item of evidence can be described by the following simple two-valued mass
function:

mi( Ai, B i) = α exp
mi(∅, ∅) = 1 − α exp

(cid:10)

(cid:11)
−γ d(x, xi)
,
(cid:10)
(cid:11)
−γ d(x, xi)

,

(69)

(70)

with, as before, 0 < α < 1 and γ > 0. These k mass functions are then combined using the conjunctive sum (68) as in the
single-label case.

For decision making, different procedures can be used. The following simple and computationally eﬃcient rule was
implemented. Let (cid:26)Y be the predicted label set for instance x. To decide whether to include each class ω ∈ Ω or not, we
compute the degree of belief bel({ω}, ∅) that the true label set Y contains ω, and the degree of belief bel(∅, {ω}) that it
does not contain ω. We then deﬁne (cid:26)Y as

(cid:26)Y =

(cid:20)
ω ∈ Ω | bel

(cid:10)

{ω}, ∅

(cid:11)

(cid:10)
(cid:2) bel

∅, {ω}

(cid:11)(cid:21)
.

6.3. Experiments

To study the above procedure experimentally, three real datasets3 were used:

• The emotion dataset, presented in [31], consist of 593 songs annotated by experts according to the emotions they gen-
erate. The emotions are: amazed-surprise, happy-pleased, relaxing-calm, quiet-still, sad-lonely and angry-fearful. Each
emotion corresponds to a class. There are thus 6 classes, and each song was labeled as belonging to one or several
classes. The average size of the label set for each song is 1.87 ± 0.67. Each song was also described by 8 rhythmic fea-
tures and 64 timbre features, resulting in a total of 72 features. The data was split into a training set of 391 examples
and a test set of 202 examples.

• The yeast dataset contains data regarding the gene functional classes of the yeast Saccharomyces cerevisiae [11,25]. It
describes 2417 genes each represented by 103 features. There are 14 possible classes and the average size of the label
set for each gene is 4.24 ± 1.57. The data was split into a learning set of 1500 examples and a test set of 917 examples.
• The scene dataset consists of 2407 natural scene images, where a label set is manually assigned to each image. There
are 6 classes and 294 attributes. The average cardinality is 1.074 ± 0.26 (only 7.35% of observations are labeled by more
than one class). The data was split into a training set of 1211 examples and a test set of 1196 examples.

Each of these three datasets was constructed in such a way that each instance i is assigned a single set of labels Y i . As
explained above, this choice may be questioned since, at least for the emotion and scene datasets, there is no ground truth
and the data have been labeled subjectively by a pool of experts. To assess the performances of our approach in learning
from data with imprecise labels such as postulated in Section 6.2 above, we randomly simulated an imperfect labeling process
by proceeding as follows.

3 These datasets can be downloaded from http://mlkd.csd.auth.gr/multilabel.html.

496

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

Fig. 2. Mean accuracy (plus or minus one standard deviation) over 5 trials as a function of k for the emotions dataset with the following methods: EML-kNN
with imprecise labels ( Ai , B i ), EML-kNN with noisy labels and ML-kNN with noisy labels.

Let yi = ( yi1, . . . , yi K ) be the vector of {−1, 1}K such that yik = 1 if ωk ∈ Y i and yik = −1 otherwise. For each instance
i and each class ωk, we generated a probability of error pik between 0 and 0.5 by drawing a random number from a beta
distribution with parameters a = b = 0.5 (this is a bimodal distribution with modes at 0 and 1) and dividing it by two. We
(cid:15)
then changed yik to − yik with probability pik, resulting in a noisy label vector y
i . The imprecise label vector was ﬁnally
deﬁned as y

(cid:15)(cid:15)
= ( y
i
(cid:22)
(cid:15)
ik

y

0

(cid:15)(cid:15)
i K ) with

(cid:15)(cid:15)
i1, . . . , y
if pik < 0.2,
otherwise.

(cid:15)(cid:15)
ik

y

=

(cid:15)(cid:15)
ik

(cid:15)(cid:15)
ik

As remarked in Section 4.1, such a vector of {−1, 0, 1}K encodes an ordered pair ( Ai, B i) of disjoint subsets of Ω such that
Ai = {ωk ∈ Ω | y

= 1} and B i = {ωk ∈ Ω | y

= −1}.

The intuition behind the above model may be described as follows. Each number pik represents the probability that the
membership of instance i to class ωk will be wrongly assessed by the expert. This number may be turned into a degree of
conﬁdence ci by the transformation cik = 1 − 2pik. We assume that these numbers can be provided by the expert, which
allows us to label each instance i by a pair of sets ( Ai, B i). The set Ai then contains the classes ωk that can be deﬁnitely
assigned to instance i with a high degree of conﬁdence (cik (cid:2) 0.6), while B i is the set of classes which are deﬁnitely not
assigned to instance i. The remaining set Ω \ ( Ai ∪ B i) contains those classes about which the expert is undecided (cik < 0.6).
(cid:15)
i and with
imprecise labels ( Ai, B i). The features were normalized so as to have zero mean and unit variance. Parameters α and γ
were ﬁxed at 0.95 and 0.5, respectively, for all three datasets. We note that γ could easily be determined automatically
by cross-validation. However, the results are not very sensitive to the value of γ , so that this parameter could be ﬁxed
manually.

Our method (hereafter referred to as EML-kNN) was applied to the three datasets, both with noisy labels y

As a reference method, we used the ML-kNN method introduced in [38], which was shown in [38] to have good per-
formances as compared to most existing multi-label classiﬁcation algorithms. It is also the closest to our method, as both
methods are based on nearest neighbors. The ML-kNN algorithm was applied to noisy labels only, as it is not clear how
imprecise labels could be handled using this method.

For evaluation, we used accuracy as a performance measure, deﬁned as:

Accuracy = 1
n

n(cid:2)

i=1

|Y i ∩ (cid:26)Y i|
|Y i ∪ (cid:26)Y i|

,

where n is the number of test examples, Y i is the true label set for examples i, and (cid:26)Y i is the predicted label set for the
same example. This measure takes values between 0 and 1, with higher values corresponding to better performance.

Figs. 2 to 4 show the mean accuracy plus or minus one standard deviation over ﬁve generations of noisy and imprecise
labels for the three datasets, with the following methods: EML-kNN with imprecise labels ( Ai, B i), EML-kNN with noisy
labels and ML-kNN with noisy labels. The results are consistent over the three datasets: the EML-kNN method with noisy
labels outperforms the ML-kNN trained using the same data, while the EML-kNN algorithm with imprecise labels clearly
yields the best performances for the three problems.

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

497

Fig. 3. Mean accuracy (plus or minus one standard deviation) over 5 trials as a function of k for the yeast dataset with the following methods: EML-kNN
with imprecise labels ( Ai , B i ), EML-kNN with noisy labels and ML-kNN with noisy labels.

Fig. 4. Mean accuracy (plus or minus one standard deviation) over 5 trials as a function of k for the scene dataset with the following methods: EML-kNN
with imprecise labels ( Ai , B i ), EML-kNN with noisy labels and ML-kNN with noisy labels.

These preliminary results demonstrate the ability of our approach to handle imprecise labels in multi-label classiﬁcation
tasks. More generally, they illustrate a practical situation where mass functions on a lattice (C(Ω), ⊆) are a natural model
for expert knowledge and can be successfully exploited for uncertain reasoning with set-valued variables.

It should be noted, however, that these encouraging results are only a ﬁrst step towards a comprehensive assessment
of our approach in multi-label classiﬁcation tasks. A more complete study would require more extensive comparisons with
a wider range of algorithms and datasets, and more sophisticated schemes for tuning hyperparameters. Such a study goes
beyond the scope of the present paper, and is left for future work.

7. Conclusion

We have presented a formalism for quantifying uncertainty on a set-valued variable X deﬁned on a domain Ω in the
belief function framework. This approach relies on the deﬁnition of a family C(Ω) of subsets of 2Ω that is closed under
intersection and has a lattice structure. Each element C in this family is indexed by two subsets A and B, and is deﬁned

498

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

as the set of subsets of Ω containing A and not intersecting B. The number of such elements (including the empty set of
2Ω ) is equal to 3K + 1, where K is the size of Ω : it is thus much smaller than the size of 22Ω
, while being rich enough to
express evidence about X in many realistic situations.

Using recent results about belief functions on general lattices reported in [14], we have shown that most notions from
Dempster–Shafer theory can be deﬁned on C(Ω) with only a moderate increase in complexity as compared to the single-
valued case, which contrasts with the double-exponential complexity encountered when working in 22Ω
. This formalism
has been shown to be more general than previous attempts to apply the Dempster–Shafer framework to this problem. It
has also been shown to be somewhat similar to, but arguably more general and ﬂexible than other approaches introduced
in the possibilistic framework.

Finally, our formalism has been applied to multi-label classiﬁcation with imprecise labels, using an extension of the
single-label evidential k nearest neighbor rule. Preliminary experimental results with real data and simulated uncertain
labeling suggest that the proposed approach allows for the development of powerful classiﬁcation procedures and can
be applied to solve complex real-world problems. Further investigations into the belief function approach to multi-label
classiﬁcation, including extensive comparison with other methods, are currently under way and will be reported in future
publications.

References

[1] S. Aguzzoli, B. Gerla, V. Marra, De Finetti’s no-Dutch-book criterion for Gödel logic, Studia Logica 90 (1) (2008).
[2] R.L.O. Cignoli, I.M.L. D’Ottaviano, D. Mundici, Algebraic Foundations of Many-Valued Reasoning, Trends in Logic – Studia Logica Library, vol. 7, Kluwer

Academic Publishers, Dordrecht, 2000.

[3] B.R. Cobb, P.P. Shenoy, On the plausibility transformation method for translating belief function models to probability models, International Journal of

Approximate Reasoning 41 (3) (2006) 314–330.

[4] T. Denœux, A k-nearest neighbor classiﬁcation rule based on Dempster–Shafer theory, IEEE Transactions on Systems, Man and Cybernetics 25 (05)

(1995) 804–813.

[5] T. Denœux, Conjunctive and disjunctive combination of belief functions induced by non-distinct bodies of evidence, Artiﬁcial Intelligence 172 (2008)

234–264.

[6] T. Denœux, P. Smets, Classiﬁcation using belief functions: the relationship between the case-based and model-based approaches, IEEE Transactions on

Systems, Man and Cybernetics B 36 (6) (2006) 1395–1406.

[7] T. Denœux, L.M. Zouhal, Handling possibilistic labels in pattern classiﬁcation using evidential reasoning, Fuzzy Sets and Systems 122 (3) (2001) 47–62.
[8] D. Dubois, H. Prade, A set-theoretic view of belief functions: logical operations and approximations by fuzzy sets, International Journal of General

Systems 12 (3) (1986) 193–226.

[9] D. Dubois, H. Prade, On incomplete conjunctive information, Computers and Mathematics with Applications 15 (10) (1988) 797–810.

[10] D. Dubois, H. Prade, Representation and combination of uncertainty with belief functions and possibility measures, Computational Intelligence 4 (1988)

244–264.

[11] A. Elisseeff, J. Weston, A kernel method for multi-labelled classiﬁcation, in: T.G. Dietterich, S. Becker, Z. Ghahramani (Eds.), Advances in Neural Infor-

mation Processing Systems, vol. 14, MIT Press, 2002, pp. 681–687.

[12] J. Fürnkranz, E. Hüllermeier, E.L. Mencia, K. Brinker, Multilabel classiﬁcation via calibrated label ranking, Machine Learning 73 (2) (2008) 133–153.
[13] S. Godbole, S. Sarawagi, Discriminative methods for multi-labeled classiﬁcation, in: Proceedings of the 8th Paciﬁc–Asia Conference on Knowledge

Discovery and Data Mining, PAKDD 2004, Sidney, Australia, 2004, pp. 22–30.

[14] M. Grabisch, Belief functions on lattices, International Journal of Intelligent Systems 24 (2009) 76–95.
[15] M. Grabisch, C. Labreuche, Bi-capacities – I: deﬁnition, Möbius transform and interaction, Fuzzy Sets and Systems 151 (2005) 211–236.
[16] T. Kroupa, Conditional probability on MV-algebras, Fuzzy Sets and Systems 149 (2) (2005) 369–381.
[17] T. Kroupa, Representation and extension of states on MV-algebras, Archive for Mathematical Logic 45 (4) (2006) 381–392.
[18] T. Kroupa, Belief functions on formulas in Lukasiewicz logic, in: T. Kroupa, J. Vejnarová (Eds.), 8th Workshop on Uncertainty Processing (WUPES ’09),

Liblice, Czech Republic, 2009.

[19] C. Labreuche, M. Grabisch, Modeling positive and negative pieces of evidence in uncertainty, in: T.D. Nielsen, N.L. Zhang (Eds.), Symbolic and Quanti-

tative Approaches to Reasoning with Uncertainty (Proceedings of ECSQARU ’03), Aalborg, Denmark, Springer, 2003, pp. 279–290.

[20] G. Matheron, Random Sets and Integral Geometry, Wiley, New York, 1975.
[21] B. Monjardet, The presence of lattice theory in discrete problems of mathematical social sciences. Why, Mathematical Social Sciences 46 (2) (2003)

103–144.

[22] D. Mundici, Averaging the truth-value in Lukasiewicz logic, Studia Logica 55 (1) (1995) 113–127.
[23] H. Nguyen, An Introduction to Random Sets, Chapman and Hall/CRC Press, Boca Raton, Florida, 2006.
[24] H.T. Nguyen, On random sets and belief functions, Journal of Mathematical Analysis and Applications 65 (1978) 531–542.
[25] P. Pavlidis, J. Weston, J. Cai, W.N. Grundy, Combining microarray expression data and phylogenetic proﬁles to learn functional categories using support

vector machines, in: Proceedings of the Fifth Annual International Conference on Computational Biology, 2001, pp. 242–248.

[26] G. Shafer, A Mathematical Theory of Evidence, Princeton University Press, Princeton, NJ, 1976.
[27] P. Smets, The Transferable Belief Model and random sets, International Journal of Intelligent Systems 7 (1992) 37–46.
[28] P. Smets, Belief functions: the disjunctive rule of combination and the generalized Bayesian theorem, International Journal of Approximate Reasoning 9

(1993) 1–35.

[29] P. Smets, The canonical decomposition of a weighted belief, in: Int. Joint Conf. on Artiﬁcial Intelligence, Morgan Kaufman, San Mateo, CA, 1995,

pp. 1896–1901.

[30] P. Smets, R. Kennes, The transferable belief model, Artiﬁcial Intelligence 66 (1994) 191–243.
[31] K. Trohidis, G. Tsoumakas, G. Kalliris, I. Vlahavas, Multi-label classiﬁcation of music into emotions, in: Proc. 9th International Conference on Music

Information Retrieval (ISMIR 2008), Philadephia, PA, USA, 2008.

[32] R.R. Yager, On different classes of linguistic variables deﬁned via fuzzy subsets, Kybernetes 13 (1984) 103–110.
[33] R.R. Yager, Set-based representations of conjunctive and disjunctive knowledge, Information Sciences 41 (1987) 1–22.
[34] R.R. Yager, Reasoning with conjunctive knowledge, Fuzzy Sets and Systems 28 (1988) 69–83.
[35] R.R. Yager, Veristic variables, IEEE Transactions on Systems, Man and Cybernetics B 30 (1) (2000) 71–84.
[36] Z. Younes, F. Abdallah, T. Denœux, Multi-label classiﬁcation algorithm derived from k-nearest neighbor rule with label dependencies, in: 6th European

Signal Processing Conference (EUSIPCO ’08), Lausanne, Switzerland, 2008.

T. Denœux et al. / Artiﬁcial Intelligence 174 (2010) 479–499

499

[37] Z. Younes, F. Abdallah, T. Denœux, An evidence-theoretic k-nearest neighbor rule for multi-label classiﬁcation, in: Proceedings of the 3rd International

Conference on Scalable Uncertainty Management (SUM 2009), Washington, DC, USA, in: LNAI, vol. 5785, Springer-Verlag, 2009, pp. 297–308.

[38] M.-L. Zhang, Z.-H. Zhou, ML-KNN: a lazy learning approach to multi-label learning, Pattern Recognition 40 (7) (2007) 2038–2048.
[39] L.M. Zouhal, T. Denœux, An evidence-theoretic k-NN rule with parameter optimization, IEEE Transactions on Systems, Man and Cybernetics C 28 (2)

(1998) 263–271.

