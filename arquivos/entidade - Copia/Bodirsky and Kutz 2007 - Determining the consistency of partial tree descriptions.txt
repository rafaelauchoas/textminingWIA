Artiﬁcial Intelligence 171 (2007) 185–196

www.elsevier.com/locate/artint

Determining the consistency of partial tree descriptions

Manuel Bodirsky a,∗, Martin Kutz b

a Humboldt-Universität zu Berlin, Germany
b Max-Planck-Institut für Informatik, Saarbrücken, Germany

Received 1 June 2006; received in revised form 27 November 2006; accepted 15 December 2006

Available online 22 December 2006

Abstract

We present an efﬁcient algorithm that decides the consistency of partial descriptions of ordered trees. The constraint language
of these descriptions was introduced by Cornell in computational linguistics; the constraints specify for pairs of nodes sets of
admissible relative positions in an ordered tree. Cornell asked for an algorithm to ﬁnd a tree structure satisfying these constraints.
This computational problem generalizes the common-supertree problem studied in phylogenetic analysis, and also generalizes the
network consistency problem of the so-called left-linear point algebra. We present the ﬁrst polynomial time algorithm for Cornell’s
problem, which runs in time O(mn), where m is the number of constraints and n the number of variables in the constraint.
© 2006 Elsevier B.V. All rights reserved.

Keywords: Tree descriptions; Constraint satisfaction problems; Graph algorithms; Left-linear point algebra

1. Introduction

Tree description languages became an important tool in computational linguistics over the last twenty years. Gram-
mar formalisms have been proposed that derive logical descriptions of trees representing the syntax of a string [15,
23,26]. Membership in a language is then equivalent to the satisﬁability of the corresponding logical formula. In se-
mantics, the paradigm of underspeciﬁcation aims at manipulating the partial description of tree-structured semantic
representations of a sentence rather than at manipulating the representations themselves [17,25]. One of the key issues
in both constraint-based grammar and constraint-based semantic formalisms is to collect partial descriptions of trees
and to solve them, i.e., to ﬁnd a tree structure that satisﬁes all constraints.

Cornell [13] introduced a simple but powerful tree description language, which contains constraints for dominance,
precedence, and equality between nodes, and disjunctive combinations of these (a formal deﬁnition is given is Sec-
tion 2). Cornell also gave a saturation algorithm based on local propagations, which turned out to be incomplete. For
an example of a tree description that shows this, see Section 3.4 in [3].

In this article we present the ﬁrst polynomial-time algorithm that tests satisﬁability of a tree description from Cor-
nell’s tree description language and directly constructs a solution to the problem instance, if one exists. A predecessor
of this algorithm, which applies to a restricted language, was presented in [4]. The present algorithm, which solves the

* Corresponding author.

E-mail addresses: bodirsky@informatik.hu-berlin.de (M. Bodirsky), mkutz@mpi-inf.mpg.de (M. Kutz).

0004-3702/$ – see front matter © 2006 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2006.12.004

186

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

general problem of Cornell’s full tree description language, runs in time O(nm), where n is the number of variables
and m the number of constraints in the input. The performance is achieved by a recursive strategy that works directly
on the constraint graph, and avoids local consistency techniques a la [14,19] that are frequently used in constraint
satisfaction.

Signiﬁcance of the results. Computational linguistics is not the only area in computer science and artiﬁcial intelli-
gence where partial tree descriptions become relevant. In fact, a fragment of Cornell’s language has been introduced
independently in [12] (also see [16,21]), and is known there as the left-linear point algebra. The best known algorithm
for the so-called network satisfaction problem for the left-linear point algebra has a running time which is in O(n5),
where n denotes the size of the input [21]. Since the left-linear point algebra is a fragment of Cornell’s language, our
quadratic time algorithm also yields a new and asymptotically faster algorithm for the left-linear point algebra. Details
of this connection will be given in Section 3.1.

The consistency problem we study can also be posed as a constraint satisfaction problem (CSP), as formalized
in e.g. [8]. The catch here is that the variables might take values from an inﬁnite domain (it can be shown that the
problem cannot be modeled as a CSP with a ﬁnite domain); see also Section 3. One important direction of research in
this area is to systematically identify constraint languages that can be solved in polynomial time. In this context, our
algorithmic result is interesting because it is neither based on group-theoretic techniques such as Gaussian elimination,
nor on Datalog and local consistency techniques. This is in contrast to CSPs with ﬁnite domains, where all known
algorithms for polynomial-time solvable algorithms involve at least one of the above two techniques [9,18].

In computational biology, phylogenetic analysis is a ﬁeld where we have to deal with partial information about
evolutionary trees. An evolutionary tree for a set of species is a rooted tree where the leaves are bijectively labeled
with the species from the set. Constructing evolutionary trees from biological data is a difﬁcult problem for a variety
of reasons (see [20]). Many approaches assume that the evolutionary tree is built from a set of taxa based on the
comparison of a single protein or a single position in aligned protein sequences, but very often the resulting tree will
be different depending on which particular protein or position is used. Several trees, each from a different protein or
position, must be built and be shown to be “generally consistent” before the implied evolutionary history is considered
reliable. The question whether such consistency tests can be automated motivates the so-called common-supertree
problem [20]. We will describe in Section 3.2 how the common-supertree problem can be modeled in (a fragment of)
Cornell’s tree description language. Therefore, the algorithm presented here also yields a new algorithm for (and a
new perspective on) the common-supertree problem.

Outline. In Section 2, we introduce standard terminology for rooted trees and deﬁne Cornell’s tree description lan-
guage. This allows us to clearly describe in Section 3 the relationship between our results and results in qualitative
temporal reasoning in artiﬁcial intelligence, phylogenetic analysis in computational biology, the left-linear point al-
gebra in the theory of relation algebras, and the general framework of constraint satisfaction problems. In Section 5,
we introduce an algorithm for a small fragment of Cornell’s language. This fragment is already expressive enough to
capture the common-supertree problem mentioned above. The corresponding consistency-problem is non-trivial in the
sense that the algorithm proposed by Cornell is inconsistent already for this fragment (see [3]). However, the simplic-
ity of the language allows for a smaller and simpler description of an algorithm that decides consistency. Discussing
this language ﬁrst will be instructive to deal with the consistency problem for the full language, which is far more
involved. For the full language, we ﬁrst reduce the problem to a simpler tree description language (Section 5), prove
fundamental results for constraint-graphs that are associated to a partial tree description (Section 6), and ﬁnally use
these results to present our algorithm and prove its correctness (Section 7). Section 8 summarizes and poses questions
for future research.

2. Tree descriptions

The trees considered here are always rooted, and we consider the edges as directed, pointing away from the root.
By an ordered tree we mean a rooted tree with a linear order on the children of each vertex and we use the terms left
and right to compare them.

We follow the notation of [2]. The set of vertices of a tree T is denoted by VT , and the vertices are usually called
u, v, or w. The expression u (cid:3) v denotes that u is the father of v and u (cid:3)∗ v (and v ∗(cid:4) u) means that u dominates v, i.e.,
u is an ancestor of v in the tree (including u = v). We write u (cid:3)+ v (and v +(cid:4) u) if u (cid:3)∗ v and u (cid:5)= v. If for two vertices
u and v neither u (cid:3)∗ v nor v (cid:3)∗ u, we say that u and v are disjoint, in symbols u ⊥ v. In this situation we distinguish

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

187

Fig. 1. The translation of the partial tree description of Fig. 1 into the restricted language.

two cases: either u precedes or succeeds v. A vertex u precedes a vertex v (and v succeeds u), in symbols u ≺+ v
(and v +(cid:8) u), if there is a common ancestor of u and v in the tree that has two children w1 and w2 with w1 (cid:3)∗ u and
w2 (cid:3)∗ v and such that u is to the left of v. We write u ≺∗ v if either u ≺+ v or u = v.

The right picture in Fig. 1 shows an example of a rooted tree with root α(x). In pictures we indicate the ordering
of the children of a vertex by distinguishing between left and right. Here, α(v) ≺+ α(w) and α(y) ≺+ α(v), and
α(x) (cid:3)+ α(w), for example.

In an ordered tree, for every pair u, v of vertices exactly one of the following relations holds:
+(cid:8) v,

+(cid:4) v,

u = v.

u ≺+

u (cid:3)+

v,

v,

u

u

It is important to note that the union of the relations (cid:3)+ and ≺+ forms a strict linear order on the set of all vertices
of an ordered tree, which is easily seen to be the pre-order that results from a (recursive) tree traversal that lists each
node before its descendants.

We now deﬁne partial tree descriptions, due to Cornell [13], that allow to partially describe the structure of an
ordered tree using arbitrary disjunctions of these ﬁve cases. To distinguish clearly between equality in this language
and the common usage of the symbol ‘=’, we denote the former relation by ‘≡’.

Deﬁnition 1. A partial tree description (V , C) consists of a set of variables V and a set C of binary constraints of the
form xRy, where x, y ∈ V and R ⊆ {(cid:3)+, +(cid:4), ≺+,+(cid:8), ≡}. A constraint xRy is satisﬁed by a pair (T , α), where T is
an ordered tree and α : V → VT is a mapping from the variables to the vertices of the tree, if α(x)Rα(y) holds in the
tree for some relation R ∈ R. A pair (T , α) that satisﬁes all the constraints in C is called a solution for (V , C).

Note that the mapping α in the above deﬁnition is not required to be surjective. In particular, the induced graph
on the image of α need not be connected but can be a forest. A partial tree description that has a solution is called
satisﬁable or consistent.

Fig. 1 shows a partial tree description and one of its solutions on the right. In this picture, a directed edge from x

to x(cid:13) that is labeled by R denotes a constraint xRx(cid:13).

3. Related work

Cornell’s tree description language is closely related to problems in various ﬁelds of computer science and arti-
ﬁcial intelligence. We focus here on ﬁelds that are distinct from the origins of Cornell’s language in computational
linguistics.

3.1. The left-linear point algebra

The left-linear point algebra is studied in the area of binary relation algebras and algebraic logic, and can be used
to model ﬂows of time which branch into the future, but where the past is ﬁxed [12,16,21]. Formally, a semi-linear (or
left-linear) order (O, <) is a partial order such that if s, t, u ∈ O, s < u, and t < u, then either s < t, t < s, or s = t.

188

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

In [21], the case that neither u < v nor v < u holds for two distinct elements u and v in a semilinear order is denoted
by u # t. Semi-linear orders give rise to an (abstract) relation algebra, called the left-linear point algebra, which has
eight elements, and three atoms, represented by <, >, and #. A typical question in this context is the complexity of
the so-called network satisfaction problem. In case of the left-linear point algebra, the network satisfaction problem
can be solved in quintic time, i.e., in time O(n5), where n denotes the size of the network.

It is straightforward to see from the deﬁnitions given in [21] that the network satisfaction problem for the left-
linear point algebra is just another formulation of the consistency problem for partial tree descriptions (V , C), where
we restrict the constraint in C to be of the form x{(cid:3)+}y or x{≺+, +(cid:8)}y. In Section 4, we discuss an algorithm that
solves the consistency problem for partial tree descriptions for this restricted language. The algorithm we present has
a running time which is quadratic in the size of the partial tree description, and therefore outperforms the previously
known algorithm for the network satisfaction problem for the left-linear point algebra.

3.2. The common-supertree problem

The common-supertree problem is a computational problem that was introduced and studied in computational
biology [7,27], and is deﬁned as follows. Let S be a set of trees with common leaf set L. The computational task is to
decide whether there is a tree T on the leaf set L such that every tree in S is a reﬁnement of T , i.e., can be obtained
by a series of contractions of edges from T . If such a reﬁnement exists, we say that the trees in S are compatible.

The common-supertree problem can be easily formulated with tree descriptions. In fact, we only have to use the
constraint types {(cid:3)+} and {≺+, +(cid:8)}. Let S be a set of trees over a common leaf set L. The variables of the tree
description are the vertices of the trees in S, where the inner nodes of all the trees become different variables, but
the leaves are represented by the same set of variables for all trees. Tree-edges xy translate to dominance constraints
x{(cid:3)+}y. Siblings x, y in a tree from S will be related via the constraint x{≺+, +(cid:8)}y.

See Fig. 2 for an example of an incompatible set that contains two rooted trees, and its translation into an (unsatisﬁ-
able) partial tree description. In this picture, solid arcs stand for the constraint {(cid:3)+} and dashed arcs for the constraint
{≺+, +(cid:8)}.

The size of the resulting tree description is clearly O(Δ2n), where n is the total number of nodes in S and Δ denotes
the maximum degree in any tree of S. It is not hard to show that it has a solution if and only if there is a common
supertree for the trees from S.

Note that the above deﬁnition of compatible should not be confused with the notion of compatible given in [24].
They say that a tree T is compatible with T (cid:13) if there exists a subset A of the leaves of T such that the minimal
subtree of T that connects all nodes in A and suppresses all nodes of degree two equals T (cid:13). In contrast, the notion of
compatibility we used here is studied e.g. in [27], and was called weak compatibility in [24].

Fig. 2. Two incompatible trees and the translation into an (unsatisﬁable) partial tree description.

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

189

3.3. Allen’s Interval Algebra

As already observed by Cornell [13], it is possible to translate a partial tree description into a set of constraints
from Allen’s Interval Algebra [1]. In Allen’s Interval Algebra, the variables denote intervals over the real line. The
constraints from Allen’s Interval Algebra describe possible relationships between intervals, e.g., one can impose the
constraint that two intervals do not overlap. Allen’s full interval constraint logic is NP-complete in its unrestricted
form, but there are fragments of this logic that can be solved in polynomial time [10,22].

If the translation mentioned above only produces constraints that fall into one of the tractable fragments of Allen’s
Interval Algebra, we could use the translation to obtain a polynomial-time algorithm for partial tree descriptions.
The idea for the translation of partial tree description (V , C) into Allen’s Interval Algebra is as follows. We use V
as the set of variables that denote intervals in the translation. If C contains x{(cid:3)+}y, then the translation contains an
interval constraint that requires that the interval for x contains the interval for y. If C contains x{≺+, +(cid:8)}y, then the
translation contains an interval constraint that requires that the interval for x and the interval for y are disjoint. All the
other partial tree descriptions can be translated analogously.

Solutions the translation only correspond to trees, if the set of intervals in the translation is laminar, i.e., for any
pair of intervals that is not disjoint, one interval must completely contain the other. In other words, intervals must
not overlap. To ensure this, we also have to add interval constraints that require that the intervals for x and y do not
overlap, for all distinct variables x and y in V . It is then easy to show that the translation preserves satisﬁability.

Consulting the classiﬁcation of the tractable fragments of Allen’s Interval Algebra given in [22], it turns out that
the interval constraints obtained from translating constraints of the form x{(cid:3)+}y and x{≺+, +(cid:8)}y in the above way,
together with the necessary non-overlap interval constraints, do not fall into one of the tractable fragments of Allen’s
Interval Algebra. Hence, we cannot use this approach to solve partial tree descriptions in polynomial time.

3.4. General constraint satisfaction problems (CSPs)

The problems studied in this article (as well as the constraint satisfaction problem for Allen’s Interval Algebra
and its fragment) fall into a class of computational problems known as constraint satisfaction problems (CSPs), see
e.g. [8]. Every problem in this class can be described as a homomorphism problem with respect to a ﬁxed relational
structure. To be precise, for a ﬁxed structure Γ over a relational signature τ , also called the template, the constraint
satisfaction problem of Γ is the following computational problem:

CSP(Γ )
INSTANCE: A ﬁnite τ -structure S.
QUESTION: Is there a homomorphism from S to Γ ?

For relational structures Γ over a ﬁnite domain the computational complexity of the problems CSP(Γ ) was inten-
sively studied; see e.g. [9,18]. The most systematic approach here is based on a connection to universal algebra, which
essentially says that the computational complexity of CSP(Γ ) is described by a universal-algebraic object called the
clone of polymorphisms of Γ [9].

However, the consistency problem for partial tree descriptions cannot be formulated with a ﬁnite template. But it
can be formulated with a ω-categorical countable template described e.g. in [11]; see [3,6] for constraint satisfaction
with inﬁnite templates. The concept of ω-categoricity is fundamental in model-theory. It turns out that the universal-
algebraic approach can also be applied to study the complexity of CSP(Γ ) if Γ is ω-categorical [5].

It is interesting to observe that the algorithm presented here does not apply local consistency techniques or group-
theoretic techniques, whereas all known tractable CSPs with ﬁnite templates having a ﬁnite domain make use of at
least one of these two techniques [9,18].

4. An algorithm for a restricted signature

We ﬁrst illustrate the idea of our algorithm for a small fragment of the tree description language, which is the
fragment that corresponds to the left linear point algebra described in Section 3. We have also seen that this fragment

190

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

Fig. 3. An inconsistent partial tree description.

is already expressive enough to cover the common-supertree problem from phylogenetic analysis mentioned in the
introduction. In this reduced constraint language we only allow constraints of the types

x{(cid:3)+}y

and x{≺+

,

+(cid:8)}y.

The ﬁrst constraint is called (strict) dominance and the second disjointness, and we use the shorthands x (cid:3)+ y and
x ⊥ y, respectively, for these two types of literals.

Such a set of constraints can be viewed as a graph (V ; (cid:3)+, ⊥) with two types of edges, namely directed edges
(cid:3)+ and undirected edges ⊥. Observe that the binary relations (cid:3)+ and ⊥ are now deﬁned both on the vertices of a
tree and on the nodes of an instance. The reference, however, should always be clear. We would like to stress that
the two constraints do not allow for equality, i.e., x (cid:3)+ y means that in any solution, x must lie strictly above y. We
say that a constraint graph G has a solution (T , α) (and is satisﬁable) if the corresponding partial tree description
has this solution (and is satisﬁable). We also use some of the standard graph theory notation, e.g., the subgraph of
G = (V ; (cid:3)+, ⊥) induced by a subset S of V is denoted by G[S], and G − S denotes the constraint graph G[V \ S].

In pictures we draw this constraint graph with two different types of arcs. For a dominance edge x (cid:3)+ y we draw
a directed arc from x to y, for a disjointness edge x ⊥ y we draw a dashed line without direction. Fig. 3, for instance,
shows such a constraint graph.

The basic idea behind our algorithm to ﬁnd a solution to a partial tree description (V , C) (if one exists) is to pick
a node x of V as the root of our solution, then to decompose (V , C) into smaller parts, and to recursively determine
solutions to these parts, which will become the subtrees below x. With this perspective, the following deﬁnition comes
naturally.

Deﬁnition 2. Let (V , C) be a partial tree description. Then a variable x ∈ V is free if (V , C) has a solution (T , α) in
which α(x) is the root of T .

By deﬁnition, a partial tree description with a free node is satisﬁable. We shall see soon that under a simple
connectivity condition for the constraint graph, the converse is also true: a satisﬁable instance with a “connected”
constraint graph must have a free node, i.e., a node that dominates all others.

The crucial point here is, of course, in what sense the constraint graph, which contains directed and undirected
edges, should be connected. Let us brieﬂy recall some conventions. An undirected path in a directed graph (also
called digraph) may use arcs in any direction, ignoring their orientation. A digraph D = (V ; E) is strongly (weakly)
connected if there is a directed (an undirected) path from a to b for any two vertices a, b ∈ V . A strongly (weakly)
connected component of D is a maximal strongly (weakly) connected induced subgraph U of D.

Now, we say that a constraint graph (V ; (cid:3)+, ⊥) is dominance-connected if the digraph (V ; (cid:3)+) is weakly con-
nected. This notion of connectivity is crucial for our desired characterization of free nodes. The following lemma
marks the ﬁrst step.

Lemma 1. Let G = (V ; (cid:3)+, ⊥) be a dominance-connected constraint graph, and let y and y(cid:13) be variables in V . Then
for every solution (T , α) of G there exists a variable x ∈ V such that α(x) (cid:3)∗ α(y) and α(x) (cid:3)∗ α(y(cid:13)) in T .

Proof. Since the vertices y and y(cid:13) are weakly connected in (V ; (cid:3)+) there exists a chain of nodes (y1, . . . , yr ) that starts
at y = y1, ends at y(cid:13) = yr , and where (yi, yi+1) ∈ (cid:3)+ or (yi+1, yi) ∈ +(cid:4) for 1 (cid:2) i (cid:2) r − 1. We prove by induction on
r that for every solution (T , α) of (V , C) there exists an index j ∈ {1, . . . , r} with α(yj ) (cid:3)+ α(y0) and α(yj ) (cid:3)+ α(yr )
in T . If r = 0 or r = 1 then we can choose x to be either α(y0) or α(yr ). Otherwise, we can apply the induction
hypothesis to the chain (y1, . . . , yr−1). Thus, there exists a j , 0 (cid:2) j (cid:2) r − 1, such that α(yj ) is a common ancestor

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

191

of α(y1) and α(yr−1) in T . If α(yr−1) (cid:3)+ α(yr ) then α(yj ) is also a common ancestor of α(y1) and α(yr ), so we can
choose x = yj . Otherwise, α(yr ) (cid:3)+ α(yr−1) in T . Hence, both α(y1) and α(yr ) are ancestors of yr−1 in T . Since T
is a tree, it follows that α(yr ) (cid:3)∗ α(yj ) or α(yj ) (cid:3)∗ α(yr ) in T . In the ﬁrst case, we choose x = yr , and in the second
x = yj . (cid:2)

As promised, we now show that every satisﬁable dominance-connected constraint graph has a free node.

Proposition 1. A satisﬁable partial tree description (V , C) with a dominance-connected constraint graph has a free
node.

Proof. Assume there is a solution (T , α) for (V , C) and consider the vertices v that are topmost in T with respect to
(cid:3)+ such that v = α(x) for some node x ∈ V . If there is only one such vertex v, then the subtree rooted at v together
with α is also a solution of (V , C). But since there is a node x ∈ V such that v = α(x), this contradicts the assumption
that x is not free. If there are two distinct topmost nodes v, v(cid:13), then v and v(cid:13) are disjoint in T . Since the constraint
graph is dominance-connected, we can apply Lemma 1, and obtain a contradiction to the assumption that v and v(cid:13) lie
topmost in T . (cid:2)

For the algorithm we need a concise graph-theoretic characterization of free nodes that can be checked efﬁciently.

Proposition 2. Let G = (V ; (cid:3)+, ⊥) be the constraint graph of a satisﬁable partial tree description. Then a node x ∈ V
is free if and only if

(C1) there is no arc y (cid:3)+ x in G and
(C2) there is no edge x ⊥ y in G.

Proof. If there is another y such that y (cid:3)+ x, then the vertex x cannot be topmost in any solution of G, and thus can
not be free. If the vertex x is involved in a disjointness constraint it can also not be free, since the root of a tree is not
disjoint to the other nodes in the tree.

Conversely, assume that the node x of a satisﬁable set of constraints satisﬁes (C1) and (C2). The dominance-
connected components of G[V −{x}] are also satisﬁable and must thus by Proposition 2 have free nodes. Then we have
the following solution for G: introduce a tree node x and let the solutions of the dominance-connected components
become the subtrees of this node. The disjointness constraints between the different dominance-connected components
are thus satisﬁed by construction and it is clear from (C1) and (C2) that all the constraints on x are also satisﬁed. (cid:2)

Example. Let us revisit the example shown in Fig. 3. Note that instance does not contain a node x that satisﬁes (C1)
and (C2). By Proposition 2, there is no free node, and hence the instance has no solution. But if any constraint in the
instance is removed, we ﬁnd a node satisfying both conditions, and hence any such instance has a solution.

Fig. 4 shows the algorithm for the restricted constraint language with the two relations (cid:3)+, ⊥. For a dominance-
connected constraint graph, the function Solve ﬁrst selects a free node x as root and then links the recursively computed

Solve(G)
// input: a dominance-connected constraint graph G = (V ; (cid:3)+, ⊥)
// constructs a tree T and a mapping α: V → VT
pick a node x of G satisfying (C1) and (C2);
if no such free node exists then return “problem has no solution”;
create a new tree node r and let α(x) := r;
compute the dominance-connected components C1, . . . , Ck of G − {x};
for i = 1 to k do

call Solve(G[Ci ]) and make the returned root a new child of r;

od
return root r;

Fig. 4. The function Solve for constraints of the type (cid:3)+

and ⊥.

192

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

solutions to the dominance-connected components Ci of the remainder G − {x} below the α-image r of x in the correct
order.

Theorem 1. There is an algorithm that decides satisﬁability of a given partial tree description (V , C) in the restricted
constraint language in O(|V ||C|) time.

Proof. It is clear that we can construct the constraint graph (V ; (cid:3)+, ⊥) of the given partial tree description in linear
time. We then apply the algorithm shown in Fig. 4 on the constraint graph. For an instance that is not dominance-
connected, we can ﬁrst introduce a dummy node z together with a (cid:3)+-arc from z to each other node to make the graph
connected. The node z then becomes the root of the output, and since α is not required to be onto the solution will be
valid also for the original graph without z.

If the algorithm detects a weakly connected component without a free node, we know by Proposition 1 that the
constraints do not have a solution. Otherwise Proposition 2 guarantees that we can proceed and make a node x
satisfying (C1) and (C2) the root of our solution. The running time is dominated by the repeated computations of the
connected components of constraint graphs. We can use depth ﬁrst search to compute the connected components in
time O(|V | + |C|), and this will be done at most |V | times. We can assume that |V | is smaller than |C| − 1, otherwise
the ﬁrst call of the algorithm divides the problem into instances where the assumption holds. Hence the algorithm runs
in time O(|V ||C|). (cid:2)

5. Reduction to four basic constraints

We now turn to the general problem of deciding the consistency of a partial tree description for the full language
introduced by Cornell. In order to get control over the 25 subsets of the relation set R ⊆ {(cid:3)+, +(cid:4), ≺+,+(cid:8), ≡}, we ﬁrst
show how to express each of them with a smaller language that contains the following four different constraint types
only:

x{(cid:3)+
x{(cid:3)+

, ≡}y,
+(cid:4), ≺+
,

,

x{≺+
+(cid:8)}y,

, ≡}y,

x{≺+

,

+(cid:8), ≡}y.

(1)

We reduce each of the 32 subsets either directly to an intersection of constraints from (1), or we build small gadgets
with new dummy variables that can simulate the original constraint.

The constraints {+(cid:4), ≡} and {+(cid:8), ≡} are simply the ﬁrst and second constraint of (1) ﬂipped, and the singletons
{(cid:3)+}, {≺+}, and {≡} can be written as intersections of these. The two extremal sets {+(cid:4), (cid:3)+, ≺+,+(cid:8), ≡} and ∅ are
not needed since the former imposes no restrictions on the tree and the latter is, by deﬁnition, unsatisﬁable. If we show
how to express the constraints

x{(cid:3)+
x{(cid:3)+

+(cid:4), ≡}y,
,
, ≺+
, ≡}y,

+(cid:8), ≡}y,

x{(cid:3)+
x{(cid:3)+

, ≺+
,
+(cid:8), ≡}y
,

(2)

with those in (1) we are done, since the remaining constraints are easily representable as ﬂippings and intersections of
constraints from (1) and (2).

For each constraint x{(cid:3)+, +(cid:4), ≡}y, we introduce a new variable z and replace it by the two constraints x{(cid:3)+, ≡}z
and y{(cid:3)+, ≡}z. By the properties of a tree, these two constraints imply x{(cid:3)+, +(cid:4), ≡}y. Conversely, every solution for
the original constraints can be modiﬁed to satisfy also the new constraints.

Constraints of the form x{(cid:3)+, ≺+, ≡}y are replaced by the two constraints x{(cid:3)+, ≡}z and z{≺+, ≡}y, where z is
a new variable. Similarly, we can replace x{(cid:3)+, +(cid:8), ≡}y by the two constraints x{(cid:3)+, ≡}z and z{+(cid:8), ≡}y. Finally,
we replace x{(cid:3)+, ≺+, +(cid:8), ≡}y by x{(cid:3)+, ≡}y and z{≺+, +(cid:8), ≡}y, where z is again a new variable.

Thus we can express all constraints in Cornell’s language with the four basic binary relations from (1). Our algo-
rithm works on tree descriptions consisting of such basic constraints only. We therefore introduce special names and
notation for these four types:

– x{(cid:3)+, ≡}y: the dominance constraint x (cid:3)∗ y,
– x{≺+, ≡}y: the precedence constraint x ≺∗ y,

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

193

Fig. 5. The translation of the example from Fig. 1 into the basic constraints.

– x{≺+, +(cid:8), ≡}y: the disjoint-or-equal constraint x(cid:3) y,
– x{(cid:3)+, +(cid:4), ≺+, +(cid:8)}y: the inequality constraint x (cid:5)≡ y.

Note that from now on, the notions of dominance and precedence relation are to be considered non-strict, i.e., they
stand for reﬂexive relations.

In the following we apply this reduction to the example presented in Fig. 1. The result is shown in Fig. 5. Since the

disjoint-or-equal and the inequality constraint are symmetric, we indicate them as undirected edges and not as arcs.

6. Constraint graphs and freeness

Our algorithm for the full tree description language uses the ideas that we discussed for the restricted setting. The
ﬁrst important difference to the restricted setting is that now several variables may map to the same tree node. Hence,
we shall need a generalized notion of freeness.

Deﬁnition 3. Let (V , C) be a partial tree description. Then S ⊆ V is called free if there is a solution (T , α) for (V , C)
such that S = α−1(r), where r is the root of T .

Similarly to the restricted setting we want to show that under a certain connectedness condition free sets must exist,
and we also want to ﬁnd practical characteristics of free sets to identify them algorithmically. To this end, we adapt
the concept of the constraint graph from Section 4. The concept of weak connectedness with respect to dominance
edges must be replaced by a more complex deﬁnition that is based on an auxiliary graph containing dominance and
precedence arcs. We deﬁne the directed P -graph (V , P ) on V with arc set
y or x (cid:3)∗

P := {xy | C contains x ≺∗

y or y (cid:3)∗

x}

and call a partial tree description (V , C) dominance connected if its P -graph is strongly connected.

Example. Consider the instance drawn in Fig. 5. The P -graph of this example is strongly connected. However, if
we consider the graph where the vertex x and all constraints imposed on x are removed, then the P -graph has four
connected components.

The following proposition is the analog of Proposition 1 for the restricted case.

Proposition 3. A satisﬁable partial tree description with a strongly connected P -graph has a free set.

Proof. Suppose (T , α) is a solution of C. We consider the set S of nodes in C that map to the minimum of the linear
order (cid:3)+ ∪ ≺+ in T , i.e., the nodes that map to the leftmost and topmost vertex u in T . If the vertex u dominates all
vertices in α(V ) then S is actually a free set. We claim that this must always be the case. So assume for contradiction

194

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

that there is a variable y ∈ V such that α(y) is not dominated by u. Since the P -graph of C is strongly connected it
contains a path y, x1, x2, . . . , xk from y /∈ S to some xk ∈ S. The path α(y), α(x1), α(x2), . . . , α(xk) must eventually
enter the subtree rooted at u, with α(xj ), say. Then α(xj −1) comes before u in (cid:3)+ ∪ ≺+, contradicting the minimality
of u with respect to the linear order (cid:3)+ ∪ ≺+. (cid:2)

For the analogy to Proposition 2, the graph-theoretic characterization of free sets, we deﬁne a directed graph (V , D)
(called the D-graph) that is based on the (cid:3)∗ relation but in addition also takes precedence constraints into account.
Precisely, we let

D := {xy | C contains x (cid:3)∗

y or x(cid:3) y or x ≺∗

y or y ≺∗

x}.

Example. Again, consider the instance drawn in Fig. 5. The strongly connected components of the P -graph has ﬁve
strongly connected components.

We would like to remark that the digraphs (V , D) and (P , D) have an interesting symmetry: D is based on dom-
inance constraints and contains bidirected precedence constraints, while P is the union of the precedence constraints
and all bidirected dominance constraints. However, a deeper reason for this similarity is elusive. The purposes of the
two digraphs are very different in nature.

The characterization of Proposition 2 now becomes a similar statement about the D-graph, with the old conditions
(C1) and (C2) merged into one, (C). On the other hand, inequality now has to be handled explicitly, which again gives
a second condition, (I).

Proposition 4. Let (V , C) be a satisﬁable partial tree description. Then S ⊆ V is a free set of nodes if and only if the
following two conditions hold:

(C) there is no edge xy ∈ D such that x /∈ S and y ∈ S and
(I) there is no pair x, y ∈ S such that x (cid:5)≡ y.

Proof. The two conditions are clearly necessary, because a free set denotes the root of a tree, which dominates all
other vertices, and because a constraint x (cid:5)≡ y explicitly forbids to map x and y to the same tree node.

For the other implication, let S be a set of nodes that satisﬁes conditions (C) and (I). Let C1, . . . , Ck be the strongly
connected components of the P -graph without S. Fix an arbitrary linear extension of the acyclic structure that is
deﬁned by the P -graph on C1, . . . , Ck. Since C is satisﬁable, the subgraph Gi of C induced by the component Ci has
a solution (Ti, αi), for all 1 (cid:2) i (cid:2) k. Introduce a new vertex v, and add T1, . . . , Tk as subtrees according to this linear
order of the components. The resulting tree is denoted by T . Now consider the mapping α that is the extension of all
the αi and maps the vertices in S to v.

We claim that (T , α) is a solution for (V , C), and therefore S is a free set of nodes. It is clear that (T , α) satisﬁes
all inequality constraints, because by (I) all inequality constraints are either within one of the components, or between
different components, or between S and a component, and in all these cases the inequality is satisﬁed in (T , α). If
C contains a disjointness constraint between x and y, then condition (C) implies that one out of the following cases
applies. Either x and y are both in S, in which case the disjointness is satisﬁed by (T , α). Or, x and y are in the same
component Ci , in which case the constraint is satisﬁed, because it is satisﬁed in (Ti, αi) as well. By the deﬁnition of
the P -graph it cannot be that x and y are in different components.

If C contains a dominance constraint between x and y, then condition (C) implies that y cannot be in S. Moreover,
x and y cannot be in different components C1, . . . , Ck, by the deﬁnition of the P -graph. Therefore, either x and y are
both in the same component or both in S, or x is in S and y is in S; in all cases the dominance constraint is satisﬁed
by (T , α).

Finally, suppose C contains a precedence constraint between x and y. Again, we see that the constraint is satisﬁed
if both x and y lie in S or both lie in the same component C1, . . . , Ck. If they lie in different components, then the
precedence constraint is satisﬁed because the subtrees below v in T were arranged according to a linear extension of
the acyclic structure deﬁned by the P -graph on the components C1, . . . , Ck. (cid:2)

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

195

Solve(C):

Compute the scc’s of the P -graph of (C),
and let C1, . . . , Ck be a linear extension of their acyclic structure
create a new vertex r with children
Solve_con(C[Ci ]), for 1 (cid:2) i (cid:2) k, in this order
return r

Solve_con(C):

precondition: The P -graph of C is strongly connected
if no set of nodes satisfying (C) and (I) exists
then return “problem has no solution”
else choose a set of nodes S satisfying (C) and (I )
let r be the root of the tree Solve(C[V − S]) and set α(S) to r
return r

Fig. 6. The function Solve for the full tree description language.

7. The algorithm

We now turn the Propositions 4 and 3 on free sets of nodes into an algorithm for Cornell’s full language. From a
given input with constraints (cid:3)∗, ≺∗, (cid:3) , and (cid:5)≡, we ﬁrst create the D-graph and P -graph and then recursively create
a tree by decomposing the vertex set into dominance-connected components and extracting free sets as roots.

Fig. 6 shows the algorithm, which consists of two procedures, Solve and Solve_con. We abuse notation and denote
a partial tree description (V , C) simply by C. Initially, for a given instance C, we call Solve(C), which partitions
the variable set into the strongly connected components of P -graph. If the P -graph of C is strongly connected, the
procedure Solve_con can be applied to C. The algorithm contains a statement choose, that inﬂuences which free set
of nodes is selected for the solution. We discuss the issue of how to ﬁnd such a free set in the running-time analysis
below.

Proposition 5. The algorithm Solve of Fig. 6 decides satisﬁability of a given partial tree description (V , C) in time
O(|V ||C|).

Proof. In Solve, the strongly connected components of the precedence graph of C can be computed in linear time in
the input size. We then call the procedure Solve_con on the strongly connected components. If it returns “problem
has no solution”, the constraints were unsatisﬁable by Proposition 3. Otherwise, Proposition 4 guarantees that we can
construct a solution by selecting a free set as root. Because of (C1), a free set must be the union of strongly connected
components of the D-graph into which no D-arcs enter. Any strongly connected component contained in a free set is
a free set as well. These strongly connected components can easily be found by depth-ﬁrst search in time O(n + m).
The strongly connected components are computed at each level of the recursion. Since we take out at least one
vertex in each call of Solve_con, and since in all calls of Solve_con (except possibly the ﬁrst call) n is in O(m), the
overall running time is in O(nm). (cid:2)

8. Conclusion and outlook

We presented an efﬁcient algorithm that decides whether a partial tree description is consistent; if this is the case,
the algorithm constructs a solution. This solves an open problem by Cornell, who introduced these tree descriptions
in computational linguistics [13]. The consistency test and construction of one solution can be done in quadratic time
in the input size.

We would like to conclude with a series of open problems for future research that are motivated in the various

related areas mentioned in Section 3.

– As mentioned in Section 3, the consistency problem for partial tree descriptions can be formulated as a constraint
satisfaction problem for an ω-categorical template Λ. For ω-categorical templates, the universal-algebraic ap-
proach applies, and in particular it can be shown that the complexity of CSP(Λ) is captured by the polymorphism

196

M. Bodirsky, M. Kutz / Artiﬁcial Intelligence 171 (2007) 185–196

clone of Λ. The open problems in this context are: 1) Describe the polymorphism clone of Λ. 2) What are the
polymorphism responsible for the tractability of CSP(Λ)? An answer to these questions would give us descrip-
tions of constraint languages with higher-ary constraints (all constraints considered in this article were binary)
that can still be solved in polynomial time.

– In Section 3, we pointed to two different notions of compatibility of phylogenetic trees that were studied in the
literature. Only for one of them we described how it can be modeled with partial tree descriptions. Is it possible
to come up with a tree-description language that allows to model the common-supertree problem for the other
notion of compatibility that was used by [24]?

– The known algorithms for the tractable fragments of Allen’s Interval Algebra are all based on local-consistency
techniques. Is it possible to ﬁnd algorithms with better running times for these fragments, using the algorithmic
techniques developed in this article? In particular, can we avoid local consistency techniques, similarly to the
algorithm presented here?

Acknowledgements

We would like to thank Pierre Flener for drawing our attention to the notion of compatibility of trees used in [24].

References

[1] J.F. Allen, Maintaining knowledge about temporal intervals, Communications of the ACM 26 (11) (1983) 832–843.
[2] R. Backofen, J. Rogers, K. Vijay-Shanker, A ﬁrst-order axiomatization of the theory of ﬁnite trees, Journal of Logic, Language, and Informa-

tion 4 (1995) 5–39.

[3] M. Bodirsky, Constraint satisfaction with inﬁnite domains, Dissertation, Humboldt-Universität zu Berlin, 2004.
[4] M. Bodirsky, M. Kutz, Pure dominance constraints, in: Proceedings of the 19th Annual Symposium on Theoretical Aspects of Computer

Science (STACS’02), in: Lecture Notes in Computer Science, vol. 2285, Antibes, Juan le Pins, Springer, Berlin, 2002, pp. 287–298.

[5] M. Bodirsky, J. Nešetˇril, Constraint satisfaction with countable homogeneous templates, in: Proceedings of Computer Science Logic (CSL’03),

Vienna, 2003, pp. 44–57.

[6] M. Bodirsky, J. Nešetˇril, Constraint satisfaction with countable homogeneous templates, Journal of Logic and Computation 16 (3) (2006)

359–373.

[7] D. Bryant, Building trees, hunting for trees, and comparing trees, PhD thesis at the University of Canterbury, 1997.
[8] A. Bulatov, P. Jeavons, A. Krokhin, The complexity of constraint satisfaction: An algebraic approach, in: Structural Theory of Automata,

Semigroups and Universal Algebra, Montreal, 2003, NATO Science Series II: Mathematics, Physics, Chemistry 207 (2005) 181–213.

[9] A. Bulatov, A. Krokhin, P.G. Jeavons, Classifying the complexity of constraints using ﬁnite algebras, SIAM Journal on Computing 34 (2005)

720–742.

[10] H.-J. Bürckert, B. Nebel, Reasoning about temporal relations: A maximal tractable subclass of Allen’s interval algebra, Journal of the

ACM 42 (1) (1995) 43–66.

[11] P.J. Cameron, Oligomorphic Permutation Groups, Cambridge University Press, Cambridge, 1990.
[12] S. Comer, A remark on chromatic polygroups, Congressus Numerantium (1983) 85.
[13] T. Cornell, On determining the consistency of partial descriptions of trees, in: 32nd Annual Meeting of the ACL (ACL’94), 1994, pp. 163–170.
[14] R. Dechter, P. van Beek, Local and global relational consistency, Journal of Theoretical Computer Science 173 (1) (1997) 283–308.
[15] D. Duchier, S. Thater, Parsing with tree descriptions: A constraint-based approach, in: Sixth International Workshop on Natural Language

Understanding and Logic Programming (NLULP’99), 1999, pp. 17–32.

[16] I. Düntsch, Relation algebras and their application in temporal and spatial reasoning, Artiﬁcial Intelligence Review 23 (2005) 315–357.
[17] M. Egg, A. Koller, J. Niehren, The constraint language for lambda structures, Journal of Logic, Language, and Information 10 (2001) 457–485.
[18] T. Feder, M. Vardi, The computational structure of monotone monadic SNP and constraint satisfaction: A study through Datalog and group

theory, SIAM Journal on Computing 28 (1999) 57–104.

[19] E.C. Freuder, A sufﬁcient condition for backtrack-free search, Journal of the ACM 29 (1) (1982) 24–32.
[20] D. Gusﬁeld, Algorithms on Strings, Trees, and Sequences, Computer Science and Computational Biology, Cambridge University Press, New

York, 1997.

[21] R. Hirsch, Expressive power and complexity in algebraic logic, Journal of Logic and Computation 7 (3) (1997) 309–351.
[22] P. Jeavons, P. Jonsson, A.A. Krokhin, Reasoning about temporal relations: The tractable subalgebras of Allen’s interval algebra, Journal of the

ACM 50 (5) (2003) 591–640.

[23] M.P. Marcus, D. Hindle, M.M. Fleck, D-theory: Talking about talking about trees, in: Proceedings of the 21st Annual Meeting of the ACL

(ACL’83), 1983, pp. 129–136.

[24] M.P. Ng, M. Steel, N.C. Wormald, The difﬁculty of constructing a leaf-labelled tree including or avoiding given subtrees, Discrete Applied

Mathematics 98 (2000) 227–235.

[25] M. Pinkal, Radical underspeciﬁcation, in: Proceedings of the 10th Amsterdam Colloquium, 1996, pp. 587–606.
[26] J. Rogers, V. Shanker, Reasoning with descriptions of trees, in: Proceedings of the 30th Meeting of the ACL (ACL’92), 1992, pp. 72–80.
[27] M. Steel, The complexity of reconstructing trees from qualitative characters and subtrees, Journal of Classiﬁcation 9 (1992) 91–116.

