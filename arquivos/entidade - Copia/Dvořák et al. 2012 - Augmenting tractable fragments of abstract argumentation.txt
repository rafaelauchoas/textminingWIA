Artiﬁcial Intelligence 186 (2012) 157–173

Contents lists available at SciVerse ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Augmenting tractable fragments of abstract argumentation ✩,✩✩

Wolfgang Dvoˇrák, Sebastian Ordyniak, Stefan Szeider

∗

Institute of Information Systems, Vienna University of Technology, Austria

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 19 August 2011
Received in revised form 12 January 2012
Accepted 7 March 2012
Available online 8 March 2012

Keywords:
Abstract argumentation
Backdoors
Computational complexity
Parameterized complexity
Fixed-parameter tractability

1. Introduction

We present a new approach to the eﬃcient solution of important computational problems
that arise in the context of abstract argumentation. Our approach makes known algorithms
deﬁned for restricted fragments generally applicable, at a computational cost that scales
with the distance from the fragment. Thus, in a certain sense, we gradually augment
tractable fragments. Surprisingly, it turns out that some tractable fragments admit such
an augmentation and that others do not.
More speciﬁcally, we show that the problems of Credulous and Skeptical Acceptance are
ﬁxed-parameter tractable when parameterized by the distance from the fragment of acyclic
argumentation frameworks—for most semantics. Other tractable fragments such as the
fragments of symmetrical and bipartite frameworks seem to prohibit an augmentation:
the acceptance problems are already intractable for frameworks at distance 1 from the
fragments.
For our study we use a broad setting and consider several different semantics. For the
algorithmic results we utilize recent advances in ﬁxed-parameter tractability.

© 2012 Elsevier B.V. All rights reserved.

The study of arguments as abstract entities and their interaction in form of attacks as introduced by Dung [13] has
become one of the most active research branches within Artiﬁcial Intelligence, Logic and Reasoning [3,4,35]. Argumentation
handles possible conﬂicts between arguments in form of attacks. Arguments may either originate from a dialogue between
several agents or from the pieces of information available to a single agent, this information may even contain contradic-
tions. A main issue for any argumentation system is the selection of acceptable sets of arguments, called extensions, where
an acceptable set of arguments must be in some sense coherent and be able to defend itself against all attacking argu-
ments. Abstract argumentation provides suitable concepts and formalisms to study, represent, and process various reasoning
problems most prominently in defeasible reasoning (see, e.g., [5,34]) and agent interaction (see, e.g., [33]).

Unfortunately, important computational problems such as determining whether an argument belongs to some extension
(Credulous Acceptance) or to all extensions (Skeptical Acceptance), are intractable (see, e.g., [11,16]). In order to solve these
problems on medium or large-sized real world instances, it is signiﬁcant to identify eﬃcient algorithms. However, a few
tractable fragments are known where the acceptance problems can be eﬃciently solved: the fragments of acyclic [13],
symmetric [10], bipartite [14], and—for most semantics—noeven [16] argumentation frameworks.

✩

Ordyniak and Szeider’s research has been funded by the European Research Council, grant reference 239962 (COMPLEX REASON). Dvoˇrák’s research has

been funded by the Vienna Science and Technology Fund (WWTF) through project ICT08-028.
✩✩

A preliminary and shortened version of this paper appeared in IJCAI 2011.

* Corresponding author.

E-mail address: stefan@szeider.net (S. Szeider).

0004-3702/$ – see front matter © 2012 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2012.03.002

158

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

Table 1
Complexity of acceptance problems, parameterized by the distance from a fragment.

Fragment

Acyc
Noeven
Bip
Sym

adm
CA

FPT
XP
hard
hard

com
CA

FPT
XP
hard
hard

prf
CA/SA

FPT
XP
hard
hard

sem
CA/SA

FPT
XP
hard
hard

stb
CA/SA

FPT
XP
hard
hard

stg
CA/SA

hard
hard
hard
hard

It seems unlikely that an argumentation framework originating from a real-world application belongs to one of the

known tractable fragments, but it might be “close” to a tractable fragment.

In this paper we study the natural and signiﬁcant question of whether we can solve the relevant problems eﬃciently for
argumentation frameworks that are of small distance to a tractable fragment. As the distance we take the smallest number of
arguments that must be deleted to put the framework into the tractable fragment under consideration. One would certainly
have to pay some extra computational cost that increases with the distance from the tractable fragment, but ideally this
extra cost should scale gradually with the distance. To get a broad picture of the complexity landscape we take several
popular semantics into consideration, namely the semantics introduced by Dung [13], i.e., admissible, complete, preferred,
and stable semantics, and further semi-stable [6,7,40], and stage [40] semantics (see [2] for a survey). Our approach is
inspired by the notion of “backdoors” which originates from the area of propositional satisﬁability (see, e.g., [28,39,42]),
and has been successfully used in other problem areas, including quantiﬁed Boolean formulas and nonmonotonic reasoning
[24,38].

Results. On the positive side we show that for all the considered semantics, except for stage semantics, the fragments of
acyclic and noeven argumentation frameworks admit an augmentation. In particular, we show that we can solve Credulous
and Skeptical Acceptance in polynomial time for argumentation frameworks that are of bounded distance from either of
the two fragments. We further show that with respect to the acyclic fragment, the order of the polynomial time bound
is independent of the distance, which means that both acceptance problems are ﬁxed-parameter tractable (see [12]) when
parameterized by the distance from the acyclic fragment. To obtain these results we introduce the new notion of partial
labelings of argumentation frameworks and apply recent results from ﬁxed-parameter theory. We use partial labelings to
capture and propagate the acceptance state of certain key arguments (forming a backdoor) of the argumentation framework.
On the negative side, we show that the fragments of bipartite and symmetric argumentation frameworks do not admit
an augmentation. In particular, we show that the problems Credulous and Skeptical Acceptance are already intractable for
argumentation frameworks at distance 1 from either of the two fragments. We also show that the acyclic and noeven
fragments do not admit an augmentation with respect to the stage semantics, in contrast to the other ﬁve considered
semantics. In particular, we show that the acceptability problems for the stage semantics are already intractable for noeven
argumentation frameworks, and for argumentation frameworks at distance 1 from the acyclic fragment.

To put our tractability results into context, we compare the parameters “distance to the acyclic fragment” and “distance
to the noeven fragment” with other parameters that, if bounded, make acceptance problems tractable. We show that our
distance-based parameters are incomparable with the previously considered parameters treewidth and clique-width [14,23].
Hence our augmentation approach provides an eﬃcient solution for instances that are hard for other known methods.

Table 1 summarizes our results for the different semantics and fragments. The table can be read as follows: A column
marked CA concerns Credulous Acceptance, and a column marked CA/SA concerns both Credulous and Skeptical Acceptance,
each with respect to a particular semantics as indicated. For the admissible and complete semantics we omit Skeptical
Acceptance because the corresponding problems are already tractable for arbitrary frameworks [10,13]. An entry “XP”
means that acceptance can be decided in polynomial time for argumentation frameworks whose distance to the fragment
is bounded by a constant (the order of the polynomial may depend on the distance); an entry “FPT” means that the accep-
tance problem is ﬁxed-parameter tractable, parameterized by the distance from the fragment; an entry “hard” means that
Credulous or Skeptical Acceptance are at least NP-hard or coNP-hard, respectively, even for instances of distance 1 from the
fragment.

The reminder of the paper is organized as follows. In Section 2 we provide basic deﬁnitions and preliminaries. In Sec-
tion 3 we introduce the important concept of partial labelings that will be an important tool to obtain our tractability
results. In Section 4 we give eﬃcient algorithms for the augmentation of the acyclic and noeven fragments. In Section 5 we
establish intractability for the bipartite and symmetric fragments. In Section 6 we strengthen the tractability results from
Section 4 with the help of strong backdoors. In Section 7 we compare our newly found parameters with already known
structural parameters such as treewidth and clique-width. We close in Section 8 with concluding remarks. Some proofs of
technical lemmas and theorems are given in Appendix A.

2. Preliminaries

An abstract argumentation system or argumentation framework (AF, for short) is a pair ( X, A) where X is a (possibly
inﬁnite) set of elements called arguments and A ⊆ X × X is a binary relation called attack relation. In this paper we will

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

159

Fig. 1. Left: the AF F from Example 1. Right: indicated in gray the only non-empty complete extension of F .

restrict ourselves to ﬁnite AFs, i.e., to AFs for which X is a ﬁnite set. If (x, y) ∈ A we say that x attacks y and that x is an
attacker of y.

An AF F = ( X, A) can be considered as a directed graph, and therefore it is convenient to borrow notions and notation
from graph theory. For a set of arguments Y ⊆ X we denote by F [Y ] the AF (Y , {(x, y) ∈ A | x, y ∈ Y }) and by F − Y the AF
F [ X \ Y ].

Example 1. An AF with arguments 1, . . . , 5 and attacks (1, 2), (1, 4), (2, 1), (2, 3), (2, 5), (3, 2), (3, 4), (4, 1), (4, 2), (4, 3),
(5, 4) is displayed in Fig. 1.

(cid:5)(cid:5), x

(cid:5) ∈ X such that (x
(cid:5), x) ∈ A
Let F = ( X, A) be an AF, S ⊆ X and x ∈ X . We say that x is defended (in F ) by S if for each x
+
(cid:5)) ∈ A. We deﬁne the range of a set S of arguments, denoted as S
F , as the set of arguments
(cid:5), x) ∈ A, and we omit the subscript if F is clear from the context.
(cid:5) ∈ S with

(cid:5)(cid:5) ∈ S such that (x
there is an x
x ∈ X such that either x ∈ S or there is an x
Note that in our setting the set S is contained in S
(x, x

(cid:5)) ∈ A.
Next we deﬁne commonly used semantics of AFs, see the survey of Baroni and Giacomin [2]. We consider a semantics
σ as a mapping that assigns to each AF F = ( X, A) a family σ (F ) ⊆ 2 X of sets of arguments, called extensions. We denote
by adm, com, prf, sem, stb, and stg the admissible, complete, preferred, semi-stable, stable, and stage semantics, respectively.
These six semantics are characterized by the following conditions which hold for each AF F = ( X, A) and each conﬂict-free
set S ⊆ X .

+
F . We say S is conﬂict-free if there are no arguments x, x

(cid:5) ∈ S with (x

• S ∈ adm(F ) if and only if each s ∈ S is defended by S.
• S ∈ com(F ) if and only if S ∈ adm(F ) and every argument that is defended by S is contained in S.
• S ∈ prf(F ) if and only if S ∈ adm(F ) and there is no T ∈ adm(F ) with S (cid:2) T .
• S ∈ sem(F ) if and only if S ∈ adm(F ) and there is no T ∈ adm(F ) with S
• S ∈ stb(F ) if and only if S
• S ∈ stg(F ) if and only if there is no conﬂict-free set T ⊆ X with S

+ = X .

+ (cid:2) T

+ (cid:2) T

+

+

.

.

Moreover we say that an AF F is coherent if the preferred, stable, semi-stable, and stage extensions of F coincide.

Let F = ( X, A) be an AF, x ∈ X , and σ ∈ {adm, com, prf, sem, stb, stg}. The argument x is credulously accepted in F
with respect to σ if x is contained in some extension S ∈ σ (F ), and x is skeptically accepted in F with respect to σ if x is
contained in all extensions S ∈ σ (F ).

Each semantics σ gives rise to the following two fundamental computational problems: σ -Credulous Acceptance and
σ -Skeptical Acceptance, in symbols CAσ and SAσ , respectively. Both problems take as input an AF F = ( X, A) together
with an argument x ∈ X . Problem CAσ asks whether x is credulously accepted in F , and problem SAσ asks whether x is
skeptically accepted in F . Table 2 summarizes the complexities of these problems for the considered semantics (see [10,11,
13,16–19]). A brief description of the complexity classes Σ P
2 and their relationship to NP and coNP can be found in
Appendix A.

2 and Π P

Example 2. Consider the AF F from Example 1 and the complete semantics (com). F has two complete extensions ∅ and
{1, 3, 5}, see Fig. 1. Consequently, the arguments 1, 3, and 5 are credulously accepted in F and the arguments 2 and 4 are
not. Furthermore, because of the complete extension ∅, no argument of F is skeptically accepted.

In the following we list classes of AFs for which CA and SA are known to be solvable in polynomial time for the

admissible, complete, preferred, and stable semantics [2,10,13,14].

• Acyc is the class of acyclic argumentation frameworks, i.e., of AFs that do not contain directed cycles.
• Noeven is the class of noeven argumentation frameworks, i.e., of AFs that do not contain directed cycles of even length.

160

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

Table 2
Complexity of Credulous and Skeptical Acceptance for various semantics σ .

σ

adm

com

prf

sem

stb
stg

CAσ

NP-complete

NP-complete

NP-complete
Σ P

2 -complete
NP-complete
Σ P
2 -complete

SAσ

trivial

P-complete
Π P
Π P

2 -complete
2 -complete
coNP-complete
Π P
2 -complete

• Sym is the class of symmetric argumentation frameworks, i.e., of AFs whose attack relation is symmetric and irreﬂexive.
• Bip is the class of bipartite argumentation frameworks, i.e., of AFs whose sets of arguments can be partitioned into two

conﬂict-free sets.

Observe that the original tractability results for the above classes are not stated for the semi-stable, or stage semantics.
Indeed, as we will show in Section 5, they do not hold for stage semantics and the class of noeven argumentation frame-
works. However, in all other cases it is easy to show the above tractability results for the semi-stable, and stage semantics,
as follows: The fragments Acyc and Bip are free of odd-length directed cycles and thus propose at least one stable ex-
tension [13]. The same holds for the Sym fragment of AFs, i.e., every symmetric AF has at least one stable extension [10].
It follows that the stable, stage, and semi-stable semantics coincide on these fragments. Consequently, tractability of the
stable semantics for the classes Acyc, Sym, and Bip passes over to the semi-stable and stage semantics. When considering
the Noeven fragment, we know that every such AF has a unique preferred extension [14] which then is also the unique
semi-stable extension. This follows from using the well-known fact that every AF has at least one semi-stable extension,
and every semi-stable extension is also a preferred one. Again tractability passes over to semi-stable semantics.

Lemma 1. The classes Acyc, Noeven, Sym, and Bip can be recognized in polynomial time (i.e., given an AF F , we can decide in
polynomial time whether F belongs to any of the four classes).

Proof. The statement of the lemma is easily seen for the classes Acyc, Bip and Sym. For the class Noeven it follows by a
result of Robertson et al. [37]. (cid:2)

Since the recognition and the acceptance problems are polynomial for these classes, we consider them as “tractable

fragments of abstract argumentation”.

Parameterized complexity. For our investigation we need to take two measurements into account: the input size n of the
given AF F and the distance k of F from a tractable fragment. The theory of parameterized complexity, introduced and
pioneered by Downey and Fellows [12], provides the adequate concepts and tools for such an investigation. We outline
the basic notions of parameterized complexity that are relevant for this paper, for an in-depth treatment we refer to other
sources [25,31].

An instance of a parameterized problem is a pair (I, k) where I

is the main part and k is the parameter; the latter
is usually a non-negative integer. A parameterized problem is ﬁxed-parameter tractable (FPT) if there exists a computable
function f such that instances (I, k) of size n can be solved in time f (k) · n O (1). Fixed-parameter tractable problems are also
called uniform polynomial-time tractable because if k is considered constant, then instances with parameter k can be solved in
polynomial time where the order of the polynomial is independent of k, in contrast to non-uniform polynomial-time running
times such as n O (k). Thus we have three complexity categories for parameterized problems: (1) problems that are ﬁxed-
parameter tractable (uniform polynomial-time tractable), (2) problems that are non-uniform polynomial-time tractable, and
(3) problems that are NP-hard or coNP-hard if the parameter is ﬁxed to some constant (such as k-SAT which is NP-hard
for k = 3).

Backdoors. For our approach to abstract argumentation we borrow the concept of backdoors from the areas of propositional
satisﬁability and constraint satisfaction (see, e.g., [27,28,39,42]). A SAT backdoor is a small set of key variables that represent
a “clever reasoning shortcut” through the search space. By deciding the truth values of the atoms in the backdoor, one can
reduce a SAT instance to several instances belonging to a target class. Backdoors have also been used for quantiﬁed Boolean
formulas [38] and answer-set programming [24].

Let us adopt this notion for abstract argumentation. Let C be a class of AFs, F = ( X, A) an AF, and Y ⊆ X . We call Y
a C-backdoor of F if F − Y ∈ C. We write distC(F ) for the cardinality (size) of a smallest C-backdoor of F , i.e., distC(F )
represents the distance of F from the class C.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

161

Fig. 2. Backdoors of the AF F from Example 1, with respect to the indicated classes.

Example 3. Fig. 2 illustrates backdoors of the AF F from Example 1 for the classes Acyc, Noeven, Bip, and Sym. The indicated
backdoors are the smallest possible, hence the considered AF is of distance 2 from the classes Acyc, Noeven, and Sym, and
of distance 1 from the class Bip.

In the following we consider CA and SA parameterized by the distance to a tractable fragment C.

3. Partial labelings

In this section we will introduce the novel concept of partial labelings,1 which we will be key for establishing our
tractability results. Partial labelings generalize total labelings which are deﬁned on the entire set X of arguments (see, e.g.,
[8,30,41]). We use partial labelings to capture and propagate the acceptance state of the arguments that form the backdoor.
In contrast to just distinguishing whether an argument in the backdoor belongs to some extension or not, a partial labeling
allows us to assign 3 distinct statuses to every argument, i.e., an argument can be either in the extension, attacked by the
extension or neither in the extension nor attacked by the extension (undecided). It is this property of labelings that make
them particularly suited for our algorithm which is based on the propagation of partial labelings.

Let F = ( X, A) be an AF. A partial labeling of F , or labeling for short, is a function λ : Y → {in, out, und} deﬁned on
a subset Y of X . We denote by in(λ), out(λ) and und(λ) the sets of arguments x ∈ X with λ(x) = in, λ(x) = out and
λ(x) = und respectively. Furthermore, we set def(λ) = Y and ud(λ) = X \ def(λ) and denote by λ∅ the empty labeling,
i.e., the labeling with def(λ∅) = ∅. For a set S ⊆ X we deﬁne lab(F , S) to be the labeling of F with respect to S by setting
in(lab(F , S)) = S, out(lab(F , S)) = S
. We say a set S ⊆ X is compatible with a labeling λ
if λ(x) = lab(F , S)(x) for every x ∈ def(λ).

+ \ S and und(lab(F , S)) = X \ S

Let F = ( X, A) be an AF and λ a partial labeling of F . The propagation of λ with respect to F , denoted λ∗

, is the labeling
that is obtained from λ by initially setting λ∗(x) = λ(x), for every x ∈ def(λ), and subsequently applying one of the following
three rules to unlabeled arguments x ∈ X as long as possible.

+

Rule 1. x is labeled out if x has at least one attacker that is labeled in.
Rule 2. x is labeled in if all attackers of x are labeled out.
Rule 3. x is labeled und if all attackers of x are either labeled out or und and at least one attacker of x is labeled und.

It is easy to see that λ∗

is well-deﬁned and unique.

For an AF F , we deﬁne the reduced AF F

is obtained from F after deleting
all arguments from F that, starting from the empty labeling, are labeled according to Rules 1–3. We observe that because
we start from the empty labeling, Rule 3 will not be invoked. We further note that def(λ∗
∅) is the range of the grounded
extension and F

is what Baroni et al. call the “cut of F ” in their work on resolution-based semantics [1].

∅). In other words, F

∗

∗

as the AF F − def(λ∗

∗

The following lemmas illustrate the connection between partial labelings and complete extensions.

Lemma 2. Let F = ( X, A) be an AF, λ a partial labeling of F , and S a complete extension that is compatible with λ. Then the propagation
λ∗

of λ is compatible with S.

Proof. We show the claim by induction on the number of arguments that have been labeled according to Rules 1–3. Because
S is compatible with λ it holds that λ∗(x) = λ(x) = lab(F , S)(x) for every x ∈ def(λ) and hence the proposition holds before
the ﬁrst argument has been labeled according to one of the rules. Now, suppose that λ(cid:5)
is the labeling that is obtained from

1 The term “partial labeling” was previously used in [29] to denote a speciﬁc class of four-valued labelings. The main difference to our setting is that the

deﬁnition in [29] is tied to a speciﬁc semantics while our approach does not propose any constraints on the labels.

162

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

+ \ S.

λ after labeling the ﬁrst i arguments according to one of the rules and that x is the (i + 1)-th argument that is labeled
according to the rules. We distinguish three cases.

First we assume that x is labeled according to Rule 1. In this case λ∗(x) = out and we need to show that x ∈ S

+ \ S. It
follows from the deﬁnition of Rule 1 that x has at least one attacker n with λ(cid:5)(n) = in. Using the induction hypothesis it
follows that lab(F , S)(n) = in and hence n ∈ S. Because S is conﬂict-free it follows that x /∈ S but since x is attacked by n it
follows that x ∈ S

Second we assume that x is labeled according to Rule 2. In this case λ∗(x) = in and we need to show that x ∈ S. Let
n1, . . . , nr be all the attackers of x in F . It follows from the deﬁnition of Rule 2 that λ(cid:5)(n j) = out for every 1 (cid:2) j (cid:2) r. Using
+ \ S for every 1 (cid:2) j (cid:2) r. It follows that no
the induction hypothesis it follows that lab(F , S)(n j) = out and hence n j ∈ S
argument attacked by x can be contained in S otherwise this argument would be attacked by x but x is not attacked by any
argument in S. Hence S ∪ {x} is also admissible. Because x is defended by S it follows that x ∈ S.

Finally, we assume that x is labeled according to Rule 3. In this case λ∗(x) = und and we need to show that x /∈ S
.
Using the deﬁnition of Rule 3 it follows that the set of all attackers of x can be partitioned into two sets U and O such
that λ(cid:5)(u) = und for every u ∈ U and λ(cid:5)(o) = out for every o ∈ O and U (cid:9)= ∅. Using the induction hypothesis it follows
that λ(cid:5)(n) = lab(F , S)(n) for every n ∈ U ∪ O . Hence, no attacker of x belongs to S and so x cannot be contained in S
+ \ S.
it follows that x cannot be contained
Furthermore, because S is admissible and x has an attacker that is not contained in S
in S. Hence, x is not contained in S

. (cid:2)

+

+

+

For an AF F , a set B of arguments of F , and a partial labeling λ of F we set:

∗
com

(F , λ) =

∗
com

(F , B) =

(cid:2)

(cid:3)

∗

λ

in

(cid:4)

∪ S
(cid:7)

(cid:5)
(cid:5) S ∈ adm

(cid:3)

(cid:3)
F − def
∗
com

(F , λ).

(cid:4)(cid:4)(cid:6)

,

∗

λ

λ:B→{in,out,und}

The set com
following lemma, for every set B of arguments the set com

∗(F , B) can be seen as a set of candidates for complete extensions of the AF F . In particular, as shown by the

∗(F , B) contains all the complete extensions of the AF F .

Lemma 3. Let F = ( X, A) be an AF and B ⊆ X . Then com(F ) ⊆ com

∗(F , B).

∗(F , λ) = {in(λ∗) ∪ S | S ∈ adm(F −
Proof. Let F = ( X, A) be the given AF, B ⊆ X and S ∈ com(F ). We show that S ∈ com
def(λ∗))} for the unique partial labeling λ deﬁned on B that is compatible with S. We set S 1 = S ∩ def(λ∗), S2 = S \ S1,
and F 2 = F − def(λ∗).

It follows from Lemma 2 that S1 = in(λ∗). It remains to show that S2 is admissible in F 2. Clearly, S2 is conﬂict-free. To
see that S2 is admissible suppose to the contrary that there is an argument x ∈ S 2 that is not defended by S2 in F 2, i.e., x
has an attacker y in F 2 that is not attacked by an argument in S2. Because S is a complete extension of F the argument x
is defended by S in F . Hence, there is a z ∈ S1 = in(λ∗) that attacks y. But then, using Rule 1, λ∗( y) = out, and hence y
cannot be an argument of F 2. Hence S2 is admissible in F 2. (cid:2)

4. Tractability results

Regarding the fragments of acyclic and noeven argumentation frameworks we obtain the following two results which

show that these two fragments admit an augmentation.

Theorem 1. The problems CAσ and SAσ are ﬁxed-parameter tractable for parameter distAcyc and any semantics σ ∈ {adm, com, prf,
sem, stb}.

Theorem 2. The problems CAσ and SAσ are solvable in non-uniform polynomial-time for parameter distNoeven and any semantics
σ ∈ {adm, com, prf, sem, stb}.

The remainder of this section is devoted to establishing Theorems 1 and 2.
For a class C of AFs and a semantic σ , the solution of the acceptance problems involves two tasks:

1. Backdoor Detection: to ﬁnd a C-backdoor B of F of size at most k, and
2. Backdoor Evaluation: to use the C-backdoor B of F for deciding whether x is credulously/skeptically accepted in F with

respect to the semantics σ .

For backdoor detection we utilize recent results from ﬁxed-parameter theory. For backdoor evaluation we use our new
concept of partial labelings.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

163

Table 3
Calculation of all complete extensions for the AF F of Example 1 using the Acyc-backdoor {2, 4}.

λ

2

in
in
in
out
out
out
und
und
und

4

in
out
und
in
out
und
in
out
und

4.1. Backdoor evaluation

λ∗

1

out
out
out
out
in
und
out
und
und

3

out
out
out
out
in
und
out
und
und

5

out
out
out
in
in
in
und
und
und

in(λ∗)

{2, 4}
{2}
{2}
{4, 5}
{1, 3, 5}
{5}
{4}
∅
∅

in(λ∗) ∈ com(F )?

no
no
no
no
yes
no
no
yes
yes

We say a class C of AFs is fully tractable if (i) for every F ∈ C the set adm(F

∗) can be computed in polynomial time, and

(ii) C is closed under the deletion of arguments, i.e., for each F = ( X, A) ∈ C and each Y ⊆ X , also F − Y ∈ C.

Theorem 3. Let C be a fully tractable class of AFs, F = ( X, A) an AF and B a C-backdoor of F with |B| (cid:2) k. Then the computation
of the sets com(F ), prf(F ), sem(F ) and stb(F ) can be carried out in time 3k| X|O (1) and is therefore ﬁxed-parameter tractable for
parameter k.

Proof. We ﬁrst show that the computation of com(F ) is ﬁxed-parameter tractable for parameter k. Let λ be one of the at
∗(F , λ) = {in(λ∗) ∪ S | S ∈ adm(F − def(λ∗))}
most 3k partial labelings of F deﬁned on B. We show that we can compute com
in polynomial time, i.e., in time | X|O (1). Clearly, we can compute the propagation λ∗
of λ in polynomial time. Furthermore,
because F − B ∈ C (B is a C-backdoor) also F − def(λ∗) ∈ C; this follows since B ⊆ def(λ∗) and C is closed under argument
deletion, as C is assumed to be fully tractable. Moreover, since C is assumed to be fully tractable and F − def(λ∗) ∈ C, we
can compute adm((F − def(λ∗))∗) = adm((F − def(λ∗)) − def(λ∗)) = adm(F − def(λ∗)) in polynomial time. Consequently,
∗(F , λ) in polynomial time. Since there are at most 3k partial labelings of F deﬁned on B, it
we can compute the set com
follows that we can compute the entire set com

∗(F , B) in time 3k| X|O (1).

By Lemma 3 we have com(F ) ⊆ com

∗(F , B) by simply testing for each
∗(F , B). Thus we can obtain com(F ) from com
∗(F , B) whether S is a complete extension of F . It is a well-known fact that each such a test can be carried out in

S ∈ com
polynomial time (see e.g. [20]). Hence, we conclude that indeed com(F ) can be computed in time 3k| X|O (1).

For the remaining sets prf(F ), sem(F ) and stb(F ) we note that each of them is a subset of com(F ). Furthermore, the
extensions in prf(F ) are exactly the extensions in com(F ) which are maximal with respect to set inclusion. Similarly, the
extensions in sem(F ) are exactly the extensions S ∈ com(F ) where the set S
is maximal with respect to set inclusion, and
+ = X . Clearly, these observations can be turned into an algorithm
stb(F ) are exactly the extensions S ∈ com(F ) where S
that computes from com(F ) the sets prf(F ), sem(F ), and stb(F ) in polynomial time. (cid:2)

+

Lemma 4. The classes Acyc and Noeven are fully tractable.

Proof. It is easy to see that both classes are closed under the deletion of arguments. It remains to show that for every
∗) can be computed in polynomial time. Dunne and Bench-Capon [15] have
F ∈ Acyc ∪ Noeven = Noeven, the set adm(F
shown that if F ∈ Noeven and every argument of F is contained in at least one directed cycle, then adm(F ) = {∅}. It follows
∗)
lies on a directed cycle then for every AF F ∈ Noeven, then adm(F
that if every argument in F
can be computed in polynomial (constant) time. To see this it suﬃces to show that every argument x of F
has at least one
attacker in F
. It follows that every
attacker of x must be labeled and hence x ∈ def(λ∗

. Suppose the contrary, i.e., there is an argument x ∈ X \ def(λ∗

∗) = {∅} and hence adm(F

∅) with no attacker in F

∅), a contradiction. (cid:2)

∗

∗

∗

∗

Combining Theorem 3 with Lemma 4 we conclude that if C ∈ {Acyc, Noeven} then the backdoor evaluation problem
is ﬁxed-parameter tractable parameterized by the size of the backdoor for the semantics σ ∈ {com, prf, sem, stb}. For the
remaining case of admissible semantics, we recall from Table 2 that SAadm is trivial. Furthermore, we observe that by
Dung’s fundamental lemma [13] every admissible extension is contained in some complete extension, and by deﬁnition
every complete extension is also admissible. We conclude that an argument is credulously accepted with respect to the
admissible semantics if and only if the argument is credulously accepted with respect to the complete semantics. Hence,
we have shown that backdoor evaluation is also ﬁxed-parameter tractable with respect to the admissible semantics.

Corollary 1. For any class C ∈ {Acyc, Noeven} and any semantics σ ∈ {adm, com, prf, sem, stb}, the problems σ -Credulous Ac-
ceptance and σ -Skeptical Acceptance are ﬁxed-parameter tractable, parameterized by the size of a given C-backdoor set.

164

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

Example 4. Consider again the AF F from Example 1. We have observed above that F has an Acyc-backdoor B consisting
of the arguments 2 and 4. We now show how to use the backdoor B to compute all complete extensions of F using the
procedure given in the proof of Theorem 3. Table 3 shows the propagation for all partial labelings of F deﬁned on B together
with the set in(λ∗) and for every λ it is indicated whether the set in(λ∗) is a complete extension of F . Because F − B is
acyclic it follows that adm(F − def(λ∗)) = {∅} (see the proof of Lemma 4) and hence com
∗(F , λ) = {in(λ∗)}. It is now easy
∗(F , B) as the union of all the sets in(λ∗) given in Table 3. Furthermore, using the rightmost column of
to compute com
Table 3 we conclude that com(F ) = {∅, {1, 3, 5}}, which agrees with our original observation in Example 2.

4.2. Backdoor detection

The following lemma gives an easy upper bound for the complexity of detecting a C-backdoor of size at most k for any

class C of AFs that can be recognized in polynomial time.

Proposition 1. Let C be a class of AFs that can be recognized in polynomial time and F = ( X, A) an AF with distC(F ) (cid:2) k. Then a
C-backdoor of F of size at most k can be found in time | X|O (k) and hence in non-uniform polynomial-time for parameter k.

Proof. To ﬁnd a C-backdoor of F of size at most k we simply check for every subset B ⊆ X of size (cid:2) k whether F − B ∈ C.
There are O

= O (| X|k) such sets and each check can be carried out in polynomial time. (cid:2)

(cid:3)| X|

(cid:4)(cid:4)

(cid:3)(cid:8)
k
i=0

i

Together with Lemma 1 we obtain the following consequence of Proposition 1.

Corollary 2. Let C ∈ {Acyc, Noeven, Sym, Bip} and F = ( X, A) an AF with distC(F ) (cid:2) k. Then a C-backdoor of F of size at most k can
be found in time | X|O (k) and hence in non-uniform polynomial-time for parameter k.

It is a natural question to ask whether the above result can be improved to uniform-polynomial time. We provide an

aﬃrmative answer for three of the four classes under consideration.

Lemma 5. Let C ∈ {Acyc, Sym, Bip} and F = ( X, A) an AF with distC(F ) (cid:2) k. Then a C-backdoor of F of size at most k can be found
in time f (k)| X|O (1) for some function f ; hence the detection of C-backdoors is ﬁxed-parameter tractable and for parameter k.

Proof. The detection of Acyc-backdoors is equivalent to the so-called directed feedback vertex set problem, which, given a
directed graph, asks for a set of vertices whose deletion makes the remaining graph acyclic (when we delete a vertex from
a graph, we also delete all edges incident to the vertex). The directed feedback vertex set problem, parameterized by the
number of deleted vertices, has recently been shown to be ﬁxed-parameter tractable by Chen et al. [9].

Similarly, the detection of Bip-backdoors is equivalent to the so-called odd cycle traversal problem which, given an undi-
rected graph, asks for a set of vertices whose deletion makes the remaining graph bipartite. The odd cycle traversal problem,
parameterized by the number of deleted vertices, is ﬁxed-parameter tractable due to a result of Reed et al. [36].

Finally, the detection of a Sym-backdoor can be easily translated to the vertex cover problem which, given an undirected
graph, asks for a set of vertices whose deletion leaves the remaining graph without edges. Given an AF F = ( X, A), we
construct an undirected graph G = ( X, E) where E is the set of edges {x, y} such that (x, y) ∈ A and ( y, x) /∈ A. Then a set
B ⊆ X is a Sym-backdoor of F if and only if B is a vertex cover of G. Using this translation, the ﬁxed-parameter tractability
of Sym-backdoor detection follows from the ﬁxed-parameter tractability of the vertex cover problem [12]. (cid:2)

We must leave it open whether the detection of Noeven-backdoors of size at most k is ﬁxed-parameter tractable for
parameter k. Since already the polynomial-time recognition of Noeven is highly nontrivial [37], a solution for the backdoor
problem seems very challenging. However, it is easy to see that C-backdoor detection, considered as a non-parameterized
problem, where k is just a part of the input, is NP-complete for C ∈ {Acyc, Noeven, Sym, Bip}. Hence it is unlikely that
Lemma 5 can be improved to a polynomial-time result (as this would imply that P = NP).

Combining Lemmas 5 and 1 with Corollary 1 establishes our main results Theorems 1 and 2 of this section.

5. Hardness results

In this section we show that the fragments Bip and Sym are not amenable for the backdoor approach. In particular, we
show that the acceptance problems for all the considered semantics are (co)NP-hard for AFs that are of distance 1 to any of
these two fragments. Moreover we show that none of the fragments considered in this paper admits an augmentation for
the stage semantics. In particular, we show that the acceptance problems for the stage semantics are (co)NP-hard for AFs of
distance 1 from Acyc, and also (co)NP-hard for AFs of distance 0 from Noeven.

Theorem 4. Let σ ∈ {adm, com, prf, stb, stg}. Then the problem CAσ is NP-hard for AFs F with distBip(F ) = distSym(F ) = 1.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

165

Fig. 3. Illustration for the reduction used in the proof of Theorems 4 and 5, showing the AF F , obtained from the monotone 3-CNF formula ϕ = C1 ∧ C 1
with C1 = x1 ∨ x2 ∨ x3 and C 1 = ¬x1 ∨ ¬x2 ∨ ¬x3. The set {ϕ} is a Bip- and an Sym-backdoor of F .

Proof. We devise a polynomial reduction from a restricted version of propositional satisﬁability (Monotone 3-SAT), where
every clause contains either only positive or only negative literals. This version of propositional satisﬁability is still NP-
complete [26]. Let ϕ be a CNF formula with the variables x1, . . . , xn and the clauses C1, . . . , Ck and C 1, . . . , C l, where for
every 1 (cid:2) j (cid:2) k the clause C j contains only positive literals and for every 1 (cid:2) j (cid:2) l the clause C j contains only negative
literals.

We construct an instance I = (F , x) of CAσ such that distBip(F ) = distSym(F ) = 1 and the formula ϕ is satisﬁable if and

only if the argument x is credulously accepted in F with respect to σ . F contains the following arguments:

• Two arguments xi and xi for every 1 (cid:2) i (cid:2) n.
• One argument C j for every 1 (cid:2) j (cid:2) k.
• One argument C j for every 1 (cid:2) j (cid:2) l.
• The arguments ϕ, and ϕ(cid:5)

.

F contains the following attacks:

• For every 1 (cid:2) i (cid:2) n the attacks (xi, xi), and (xi, xi).
• For every 1 (cid:2) i (cid:2) n and 1 (cid:2) j (cid:2) k the attacks (xi, C j), and (C j, xi) if xi ∈ C j .
• For every 1 (cid:2) i (cid:2) n and 1 (cid:2) j (cid:2) l the attacks (xi, C j), and (C j, xi) if xi ∈ C j .
• For every 1 (cid:2) j (cid:2) k the attack (C j, ϕ).
• For every 1 (cid:2) j (cid:2) l the attack (C j, ϕ).
• The attacks (ϕ, ϕ(cid:5)), and (ϕ(cid:5), ϕ).

Furthermore, we set X = {xi | 1 (cid:2) i (cid:2) n}, C = {C j | 1 (cid:2) j (cid:2) k} ∪ {C j | 1 (cid:2) j (cid:2) l}, and for a set M of arguments of F we set
M = {m | m ∈ M}. Finally, we identify the argument x with ϕ.
An illustration of this construction is given in Fig. 3.
By construction, F − {ϕ} is symmetric. F − {ϕ} is bipartite with the bipartition {{C j | 1 (cid:2) j (cid:2) k} ∪ X and {C j | 1 (cid:2) j (cid:2)

l} ∪ X}. Consequently, distBip(F ) = distSym(F ) = 1.

Because F does not contain an odd-length cycle it follows that F is coherent [13]. Consequently, the preferred, stable,
semi-stable, and stage extensions of F coincide. Moreover it is well known that the problems of credulous acceptance for
admissible, complete, and preferred semantics are just different formulations of the same problem (see, e.g., [18]). Hence it
suﬃces to show correctness for the stable semantics.

Suppose that the formula ϕ is satisﬁable and let M be a model of ϕ witnessing this (by model we mean a set M of
literals that contains no complementary pairs such that each clause of ϕ contains a literal of M). It is easy to see that the
set S = {ϕ} ∪ M ∪ X \ M is a stable extension of F that contains the argument ϕ.

To see the converse suppose there is a stable extension S of F that contains the argument ϕ. Because S is admissible and
the argument ϕ is attacked from every argument in C it follows that S ∩ C = ∅ and that every argument in C is attacked by
some argument in S. Because for every 1 (cid:2) i (cid:2) n at most one of the arguments xi and xi can be contained in S it follows
that S ∩ X is a model of ϕ. (cid:2)

Theorem 5. Let σ ∈ {prf, sem, stb, stg}. Then the problem SAσ is coNP-hard for AFs F with distBip(F ) = distSym(F ) = 1.

Proof. The proof uses the same construction as the proof of Theorem 4. Let the formula ϕ and the AF F = ( X, A) be deﬁned
as in the proof of Theorem 4. We show that the argument ϕ(cid:5)
of F is skeptically accepted in F with respect to σ if and only
if the formula ϕ is not satisﬁable.

Again because F is coherent it suﬃces to show the theorem for the stable semantics. It follows from the proof of
Theorem 4 that the formula ϕ is satisﬁable if and only if the argument ϕ is credulously accepted in F . Furthermore,

166

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

Fig. 4. Illustration for the reduction used in the proof of Theorems 6 and 7, showing the AF F , obtained from the 3-CNF formula ϕ = C1 ∧ C2 ∧ C3 with
C1 = x1 ∨ x2 ∨ x3, C2 = ¬x1 ∨ x2 ∨ ¬x3 and C3 = ¬x1 ∨ ¬x2 ∨ ¬x3. The set {t1} is an Acyc-backdoor of F .

because the argument ϕ(cid:5)
participates only in the attacks (ϕ, ϕ(cid:5)) and (ϕ(cid:5), ϕ), it follows that ϕ(cid:5)
if and only if the argument ϕ is not credulously accepted in F . Consequently, the argument ϕ(cid:5)
if and only if the formula ϕ is not satisﬁable. This establishes the theorem. (cid:2)

is skeptically accepted in F
is skeptically accepted in F

Theorem 6. The problem CAstg is NP-hard for noeven AFs F with distAcyc(F ) = 1.

Proof. We devise a polynomial reduction from propositional satisﬁability which is well-known to be NP-complete [26]. Let
ϕ be a CNF formula with the variables x1, . . . , xn and the clauses C1, . . . , Cm.

We construct an instance I = (F , x) of CAstg with F = ( X, A), such that F does not contain an even cycle, distAcyc(F ) = 1
and the formula ϕ is satisﬁable if and only if the argument x is credulously accepted in the AF F with respect to the stage
semantics. F contains the following arguments:

• Three arguments xi , xi , and v i for every 1 (cid:2) i (cid:2) n.
• One argument C j for every 1 (cid:2) j (cid:2) m.
• The arguments t1, t2, t3, and a.
• Two arguments ϕ and ϕ(cid:5)

.

F contains the following attacks:

• For every 1 (cid:2) i (cid:2) n the attacks (xi, xi), (xi, v i), (v i, a), and (t1, xi).
• The attacks (a, t1), (t1, t2), (t2, t3), (t3, t1) and (ϕ, ϕ(cid:5)).
• For every 1 (cid:2) i (cid:2) n and 1 (cid:2) j (cid:2) m the attack (xi, C j) if xi ∈ C j .
• For every 1 (cid:2) i (cid:2) n and 1 (cid:2) j (cid:2) m the attack (xi, C j) if xi ∈ C j .
• For every 1 (cid:2) j (cid:2) m the attack (C j, ϕ).

Furthermore, we set X = {xi | 1 (cid:2) i (cid:2) n}, C = {C j | 1 (cid:2) j (cid:2) m}, and for a set M of arguments of F we set M = {m | m ∈ M}.
Finally, we identify the argument x with ϕ. See Fig. 4.

It is easy to see that F does not contain an even directed cycle and that F − {t1} is acyclic. Consequently, F is a noeven

AF, and distAcyc(F ) = 1. Before we proceed to prove the theorem we need the following claims.

Claim 1. If S ∈ stg(F ), then C ⊆ S

+

.

Suppose the claim does not hold, i.e., there is an S ∈ stg(F ) such that C j /∈ S
+ (cid:2) S

+ ∪ {C j} ⊆ T
T = S ∪ {C j} is a conﬂict-free set, and S
Then T = (S \ {ϕ}) ∪ {C j, ϕ(cid:5)} is a conﬂict-free set, and S

+ ∪ {C j} ⊆ T

+
+ (cid:2) S

for some 1 (cid:2) j (cid:2) m. If ϕ /∈ S then the set
. So assume that ϕ ∈ S.
+
.

again a contradiction to the maximality of S

, which contradicts the maximality of S

+

+

+

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

167

Fig. 5. Left: A smallest strong Acyc-backdoor of the AF F from Example 5 indicated in gray. Right: A smallest deletion Acyc-backdoor of F indicated in gray.

Claim 2. If S ∈ stg(F ) with {t1, t2, t3} ⊆ S

+

, then for every 1 (cid:2) i (cid:2) n at most one of the arguments xi , and v i is contained in S

+

.

It is easy to see that every S ∈ stg(F ) such that S

contains the set {t1, t2, t3} must contain the argument a. It follows
that the set S can neither contain the argument t1 nor an argument v i for any 1 (cid:2) i (cid:2) n. Because F contains an attack from
xi to xi , the set S can contain at most one xi and xi . If S contains xi , then v i /∈ S
. This shows the
claim.

, and otherwise xi /∈ S

+

+

+

Suppose that there is a stage extension S of F that contains the argument ϕ. Because S is conﬂict-free it follows that S
cannot contain an argument from C . Consequently, using Claim 1 it follows that every argument in C must be attacked by
some argument in S ∩ ( X ∪ X). Because S is conﬂict-free it follows that S ∩ X is a model of ϕ.

To see the converse, suppose ϕ is satisﬁable and let M be a model of ϕ witnessing this. It suﬃces to show that S =
+ = X \ (( X \ M) ∪ {v i | xi ∈ M}).

{ϕ, a, t2} ∪ M ∪ X \ M is a stage extension of F . It is easy to see that S is conﬂict-free, and S
Consequently, the maximality of S

follows from Claim 2. (cid:2)

+

Theorem 7. The problem SAstg is coNP-hard for noeven AFs F with distAcyc(F ) = 1.

Proof. The proof uses the same construction as the proof of Theorem 6. Hence let the formula ϕ and the AF F = ( X, A)
be deﬁned as in Theorem 6. We show that the argument ϕ(cid:5)
of F is skeptically accepted in F with respect to the stage
semantics if and only if the formula ϕ is not satisﬁable.

It is easy to see that each stage extension either contains ϕ or ϕ(cid:5)
but not both of them. Thus we have that the argument
is skeptically accepted if and only if the argument ϕ is not credulously accepted in F with respect to the stage semantics.

ϕ(cid:5)
Because of the proof of Theorem 6 this holds if and only if ϕ is not satisﬁable. (cid:2)

In view of the complexities of the acceptance problems in general, as summarized in Table 2, we conclude from Theo-
rem 4 that for σ ∈ {adm, com, prf, stb} the problem CAσ is NP-complete for AFs F with distBip(F ) = distSym(F ) = 1, and
from Theorem 5 that for σ = stb the problem SAσ is coNP-complete for AFs F with distBip(F ) = distSym(F ) = 1. Hence
these problems reach their full hardness already at a constant distance from the considered fragments. It is natural to ask
whether the same is true for acceptance problems with respect to other semantics which are in general harder than NP or
coNP (recall Table 2). Note that the original reductions provided in [16,19] produce argumentation frameworks of arbitrary
high distance to each of the tractable fragments under our consideration, hence the known reductions do not answer the
above question. However, we can show that all the hardness results in this section can be extended to completeness re-
sults as speciﬁed in Table 2, considering AFs of constant distance from the fragment under consideration. In several cases
distance 1 suﬃces to obtain Σ P
2 -completeness, but we do not know whether distance 1 suﬃces in
all cases. The completeness proofs are rather long and somewhat tedious, therefore we restrict ourselves to providing one
Π P
2 -completeness proof as an example in Appendix A; the remaining completeness proofs can be found in a technical
report [21].

2 -completeness or Π P

6. An extension of the tractable classes

In this section we introduce a more general and powerful form of backdoors, the strong backdoors, and show that these
can be used to make our approach applicable to an even larger class of AFs. Our notion of strong backdoor sets for abstract
argumentation is inspired by strong backdoor sets for satisﬁability [42]. Let C be a class of AFs, F = ( X, A) an AF, and Y ⊆ X .
We call Y a strong C-backdoor of F if F − def(λ∗) ∈ C for every partial labeling λ with def(λ) = Y . We write s-distC(F ) for
the size of a smallest strong C-backdoor of F . Furthermore, to distinguish strong backdoors from the backdoors introduced
in Section 2 we refer to the latter as deletion backdoors for the remainder of this section.

Example 5. Consider the AF F with arguments 1, . . . , 5 and attacks (1, 2), (1, 3), (1, 4), (2, 1), (2, 3), (2, 4), (3, 1), (3, 2),
(3, 4), (4, 1), (4, 2), (4, 3), (5, 1), (5, 2), which is displayed in Fig. 5. The set {4} is a smallest strong Acyc-backdoor of F

168

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

because for every partial labeling λ of the argument 4 the AF F − def(λ∗) is empty, and hence acyclic. Note also that the
empty set is not a strong Acyc-backdoor of F because F − def(λ∗) contains the directed cycle on the arguments 3 and 4.
Fig. 5 also shows a smallest deletion Acyc-backdoor of F containing three arguments. (cid:2)

It is easy to see that for every class C of AFs that is closed under the deletion of arguments, every deletion C-backdoor
is also a strong C-backdoor. However, as can be observed from Example 5, the converse does not hold. Indeed, as shown
by the following proposition, strong backdoors can be arbitrarily smaller and hence arbitrarily more powerful than deletion
backdoors.

Proposition 2. Let C ∈ {Acyc, Noeven}. There are AFs where distC is arbitrarily high but s-distC is zero.

Proof. Consider the AF F = ( X, A), where X = {c1, . . . , cn, a} and A = {(a, ci) | 1 (cid:2) i (cid:2) n} ∪ {(ci, c j) | i (cid:9)= j}, for an arbitrary
positive integer n. Then it is easy to see that distAcyc(F ) = distNoeven(F ) = n − 1 but F
∅) = (∅, ∅) and conse-
quently s-distAcyc(F ) = s-distNoeven(F ) = 0. (cid:2)

∗ = F − def(λ∗

We are however able to show that for an AF F both backdoors coincide on the reduced AF F

∗ = F − def(λ∅). Conse-

quently, strong backdoor sets can be interpreted as deletion backdoor sets with some additional preprocessing.

Lemma 6. Let C ∈ {Acyc, Noeven}, F = ( X, A) be an AF, and B ⊆ X a strong C-backdoor of F

∗

. Then B is a deletion C-backdoor of F

∗

.

. Because C ∈ {Acyc, Noeven} there
Proof. Suppose for a contradiction that the set B is not a deletion C-backdoor of F
∗ − B. Let λ be the partial labeling deﬁned on B with λ(b) = und for every b ∈ B.
must be some (even) directed cycle C in F
We show that C must already be contained in F − def(λ∗), contradicting the assumption that B is a strong C-backdoor of F .
Let O = (x1, . . . , xn) be an arbitrary but ﬁxed ordering of the arguments in def(λ∗) \ def(λ) such that the application of

∗

the rules P1–P3 to the arguments x1, . . . , xn in the given order leads from λ to λ∗

.

Before we proceed we need to show the following claim.

Claim 3. For every x ∈ (def(λ∗) \ def(λ∗

∅)) it holds that λ∗(x) = und.

Let xi be the ﬁrst argument in the sequence O with λ∗(xi) (cid:9)= und. If λ∗(x) = out then, according to rule P1 there is
∅) a contradiction. If λ∗(x) = in then,
∅) for every attacker y

an attacker y of x with λ∗( y) = in. It follows that y ∈ def(λ∗
according to rule P2 it holds that λ∗( y) = out for every attacker y of x. Again, this implies y ∈ def(λ∗
of x and hence x ∈ def(λ∗

∅) and hence x ∈ def(λ∗

We now proceed to show that the cycle C is contained in F − def(λ∗). Suppose C is not contained in F − def(λ∗) and
let c be the ﬁrst labeled argument of C in the ordering O . It follows that c has at least one attacker, i.e., the attacker on
the cycle C that has not been labeled yet. Hence, c must have been labeled out according to rule P2 which contradicts
Claim 3. (cid:2)

∅). This shows the claim.

Using the above lemma we are able to apply the tractability results from Section 4 to the case of strong backdoors.

Theorem 8. The tractability results from Section 4, i.e., Theorems 1 and 2, do also apply to strong backdoors.

Proof. Lemma 6 shows that we can compute a strong C-backdoor of an AF F of size at most k by ﬁrst computing F
, and
then computing a deletion C-backdoor of F
of size at most k. Using the argumentation from Section 4.1 it follows that
we can compute the set of all complete extensions of the AF F
∅ is the range of the grounded
extension and the grounded extension of F is contained in every complete extension of F we obtain the set of all complete
extensions of F by adding the grounded extension obtained from λ∗
. The theorem now
follows because the acceptance problems for F can be eﬃciently solved given the set of all complete extensions of F (see
Section 4.1) and the partial labeling λ∗

∅ to every complete extension of F

. Furthermore, because λ∗

∅ can be eﬃciently computed. (cid:2)

∗

∗

∗

∗

The following theorem shows that also the intractability results from Section 5 remain true for strong backdoors.

Theorem 9. The hardness results from Section 5, i.e., Theorems 4–10, do also apply to strong backdoors.

Proof. Because F = F
strong and deletion backdoors coincide on these AFs. Consequently, the theorems remain true for strong backdoors. (cid:2)

for every AF constructed in the proofs of Theorems 4, 5, 6, 7 and 10 it follows from Lemma 6 that

∗

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

169

7. Comparison with other parameters

In this section we compare our new structural parameters distAcyc, distNoeven, s-distAcyc, and s-distNoeven to the param-
eters treewidth and clique-width that have been introduced to the ﬁeld of abstract argumentation by Dunne [14,22] and
Dvoˇrák et al. [23], respectively. Both problems Credulous and Skeptical Acceptance with respect to the preferred semantics
can be solved in linear time for AFs of bounded tree-width, and bounded clique-width. We do not consider any notions of
“directed treewidth” because it has recently been shown that none of these notions provide tractable fragments for abstract
argumentation [19,22].2

Treewidth of AFs. The treewidth of an AF F = ( X, A) is deﬁned via the following notion of decomposition: a tree decomposi-
tion of F is a pair (T , χ ) where T is a tree and χ is a labeling function with χ (t) ⊆ X for every tree node t such that the
following conditions hold:

1. Every argument of F occurs in χ (t) for some tree node t.
2. For every attack (u, v) of F there is a tree node t such that u, v ∈ χ (t).
3. For every argument x of F , let T x be the subgraph of T induced by all nodes t such that x ∈ χ (t). Then T x is a

(connected) subtree of T (“Connectedness Condition”).

The width of a tree decomposition (T , χ ) is the size of a largest set χ (t) minus 1 among all nodes t of T . A tree decompo-
sition of smallest width is optimal. The treewidth of an AF F is the width of an optimal tree decomposition of F .

Let k be a positive integer. A k-AF is an AF whose arguments are labeled by integers from {1, . . . , k} =:
Clique-width of AFs.
[k]. The labeling of an AF F = ( X, A) is formally denoted by a function L : X → [k]. We consider an arbitrary AF as a k-AF
with all arguments labeled by 1. We call the k-AF consisting of exactly one argument x (say, labeled by i ∈ [k]) an initial
k-AF and denote it by i(x). AFs can be constructed from initial k-AFs by means of repeated application of the following
three operations.

• Disjoint union (denoted by ⊕);
• Relabeling: changing all labels i to j (denoted by ρi, j );
• Attack insertion: adding attacks from all arguments labeled by i to all arguments labeled by j (denoted by ηi, j ); already

existing attacks are not doubled.

A construction of a k-AF F = ( X, A) using the above operations can be represented by an algebraic term composed of i(x),
⊕, ρi, j , and ηi, j , for i, j ∈ [k], and x ∈ X . Such a term is then called a cwd-expression deﬁning F . A k-expression is a cwd-
expression in which at most k different labels occur. The clique-width of an AF F is the smallest integer k such that F can
be deﬁned by a k-expression.

The following two propositions show that treewidth and clique-width are both incomparable to our distance parameters.

Proposition 3. There are acyclic and noeven AFs that have arbitrarily high treewidth and clique-width.

Proof. Consider any symmetric AF F of high treewidth or clique-width together with an arbitrary but ﬁxed ordering < of
the arguments of F . By deleting all attacks from an argument x to an argument y with y < x we obtain an acyclic AF F
that
has the same underlying undirected graph as F . Because the treewidth of an AF is equal to the treewidth of its underlying
is equal to the treewidth of F . Similarly, it is easy to see
undirected graph it immediately follows that the treewidth of F
that the clique-width of any AF is at least as high as the clique-width of the AF obtained by adding all arcs (x, y) such that
( y, x) is an attack in the original AF. Hence, the clique-width of F
is at least as high as the clique-width F . It follows that
has arbitrary high treewidth and clique-width, but distNoeven(F ) = distAcyc(F ) = s-distNoeven(F ) = s-distAcyc(F ) = 0. (cid:2)
F

(cid:5)

(cid:5)

(cid:5)

(cid:5)

Proposition 4. There are AFs with bounded treewidth and clique-width where distNoeven, distAcyc, s-distNoeven, and s-distAcyc are
arbitrarily high.

Proof. Consider an AF F that consists of n disjoint directed cycles of even length. It is easy to see that the treewidth and
the clique-width of F are bounded by a constant but distNoeven(F ) = distAcyc(F ). Furthermore, using Lemma 6 and the fact
that F = F

we also have s-distNoeven(F ) = s-distAcyc(F ) = n. (cid:2)

∗

2 Note that although stable semantics are not explicitly mentioned there, the hardness results immediately apply to stable semantics.

170

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

Fig. 6. The relationship between the complexity classes P, NP, coNP, Π P

2 , and Σ P

2 , assuming they are all distinct.

8. Conclusion

We have introduced a novel approach to the eﬃcient solution of acceptance problems for abstract argumentation frame-
works by “augmenting” tractable fragments. This way the eﬃcient solving techniques known for a restricted fragment, like
the fragment of acyclic argumentation frameworks, become generally applicable to a wider range of argumentation frame-
works and thus relevant for real-world instances. Our approach is orthogonal to decomposition-based approaches and thus
we can solve instances eﬃciently that are hard for known methods.

The augmentation approach entails two tasks, the detection of small backdoors and the evaluation of small backdoors.
For the ﬁrst task we could utilize recent results from ﬁxed-parameter algorithm design, thus making results from a different
research ﬁeld applicable to abstract argumentation. For the second task we have introduced the concept of partial labeling,
which seems to us a useful tool that may be of independent interest. In view of the possibility of an augmentation, our
results add signiﬁcance to known tractable fragments and motivate the identiﬁcation of new tractable fragments. For future
research it would be interesting to consider other distance measures and new tractable fragments.

Acknowledgements

We thank the anonymous reviewers for their valuable suggestions that helped to improve the presentation of the paper.

Appendix A. Completeness for the second level of the polynomial hierarchy

Before we give the completeness proof, we brieﬂy deﬁne the relevant complexity classes in terms of oracle machines
and quantiﬁed Boolean formulas. For further information and background on the complexity classes we refer to other
sources [32].

By an NP-oracle machine we mean a Turing machine that, in each computation step, can access an oracle that decides
= NPNP consists of the problems that can be decided in polynomial
problems within the class NP. The complexity class Σ P
2
= coNPNP is deﬁned as the complementary class
time by a non-deterministic NP-oracle machine, the complexity class Π P
2
of Σ P
2 . The complexity classes NP and coNP form the ﬁrst level of the Polynomial Hierarchy (PH), the classes
2 form the second. Classes of the (i + 1)-th level of the PH are deﬁned in terms of oracle machines that can access
Σ P
oracles for deciding problems of the i-th level. Fig. 6 gives an overview of the relations between the complexity classes of
the ﬁrst and second level of the PH.

2 , i.e., Π P

2 and Π P

= coΣ P

2

The validity of quantiﬁed Boolean formulas (QBF) in a particular form provides complete problems for the various classes
∀
2 formula is a QBF formula of the form ∀Y ∃ X ϕ where X and Y are strings of propositional atoms and ϕ is
of the PH. A QBF
a propositional formula over the atoms X ∪ Y (we may assume that ϕ is in 3-CNF). We say that a QBF Φ = ∀Y ∃ X ϕ is valid
if for each MY ⊆ Y there exists an M X ⊆ X such that M = MY ∪ M X is a model of ϕ (recall from the proof of Theorem 4
that a model is a set M of literals that contains no complementary pairs such that each clause of ϕ contains a literal of M).
The problem QSAT

∀
2 , which asks to decide whether a given QBF

∀
2 formula Φ is valid, is a Π P

2 -complete problem.

Theorem 10. The problem SAprf is Π P

2 -complete for AFs F with distBip(F ) = 1.

Proof. It suﬃces to show Π P
polynomial reduction from the restricted version of QSAT
literals. Again this restricted version is Π P
2 -complete [26].

2 -hardness for since the membership in the class Π P

2 follows from the general case. We devise a
∀
2 where every clause contains either only positive or only negative

Let Φ be a QBF of the form ∀Y ∃ X ϕ( X, Y ) where ϕ is a CNF formula with variables x1, . . . , xn, y1, . . . , ym and clauses
C1, . . . , Ck and C 1, . . . , C l where for every 1 (cid:2) j (cid:2) k the clause C j contains only positive literals and for every 1 (cid:2) j (cid:2) l the
clause C j contains only negative literals. Moreover each clause contains either a literal xi or a literal xi .

We construct an instance I = (F , x) of SAprf such that distBip(F ) = 1 and the formula Φ is valid if and only if the
argument x is skeptically accepted in the AF F with respect to the preferred semantics. F contains the following arguments:

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

171

Fig. 7. Illustration for the reduction in the proof of Theorem 10 showing the AF F , obtained from the monotone QSAT2
C1 = x1 ∨ x2 ∨ y1 and C 1 = ¬x1 ∨ ¬x2 ∨ ¬ y1. The set {ϕ} is a Bip-backdoor of F .

∀ formula Φ = ∀ y1∃x1∃x2C1 ∧ C 1 with

• Two arguments xi and xi for every 1 (cid:2) i (cid:2) n.
• Two arguments yi and yi for every 1 (cid:2) i (cid:2) m.
• One argument C j for every 1 (cid:2) j (cid:2) k.
• One argument C j for every 1 (cid:2) j (cid:2) l.
• The arguments Φ, b, and b.

F contains the following attacks:

• The attacks (Φ, b), and (Φ, b).
• For every 1 (cid:2) j (cid:2) k the attacks (C j, Φ), and (b, C j).
• For every 1 (cid:2) j (cid:2) l the attacks (C j, Φ), and (b, C j).
• For every 1 (cid:2) i (cid:2) n:

– The attacks (xi, xi), and (xi ,xi ).
– The attacks (b, xi), and (b, xi).
– For every 1 (cid:2) j (cid:2) k, the attacks (xi, C j), and (C j, xi) if xi ∈ C j .
– For every 1 (cid:2) j (cid:2) l, the attacks (xi, C j), and (C j, xi) if xi ∈ C j .

• For every 1 (cid:2) i (cid:2) m:

– The attacks ( yi, yi), and ( yi, yi).
– For every 1 (cid:2) j (cid:2) k, the attacks ( yi, C j), and (C j, yi) if yi ∈ C j .
– For every 1 (cid:2) j (cid:2) l, the attacks ( yi, C j), and (C j, yi) if yi ∈ C j .

Furthermore, we set X = {xi | 1 (cid:2) i (cid:2) n}, Y = { yi | 1 (cid:2) i (cid:2) m}, C = {C j | 1 (cid:2) j (cid:2) k}, and for a set M of arguments of F we

set M = {m | m ∈ M}. Finally, we identify the argument x with Φ. For an illustration of this reduction see Fig. 7.

Before proving the correctness of the reduction we show some general observations:

Claim 4. For the QBF Φ and the AF F constructed above the following hold:

1. The arguments b, b, c ∈ C ∪ C are not contained in any admissible set of F .
2. For each set S ⊆ Y the set S ∪ Y \ S is admissible in F and each set E (cid:2) Y ∪ Y not of this form is not a preferred extension.
3. For any preferred extension E if Φ /∈ E then E = S ∪ Y \ S for some S ⊆ Y .
4. If Φ ∈ E then E ∩ ( X ∪ Y ) is a model of ϕ.
5. If M is a model of ϕ then M ∪ ( X ∪ Y ) \ M ∪ {Φ} is a preferred extension of F .

We prove each point separately:

1. In order to obtain a contradiction let us assume that there exists an admissible set E containing an argument c ∈ C ∪ C .
We have that c is either attacked by b or b, and as E is an admissible set it must contain an argument that defends c.
However, Φ is the only argument that attacks b or b, thus Φ ∈ E. But as c attacks Φ this contradicts the conﬂict-freeness
of E. Hence we conclude that no admissible set of F contains an argument from C ∪ C .
Next let us assume that there exists an admissible set E containing b or b. Then E defends b or b, respectively, and
thus contains an argument attacking Φ. As the only arguments attacking Φ are those in the set C ∪ C this contradicts
the above observation.

2. As all attacks concerning arguments in Y ∪ Y are mutual attacks we conclude that a subset of Y ∪ Y is admissible if
and only if it is conﬂict-free. One can see that the maximal conﬂict free subsets of Y ∪ Y are the sets S ∪ Y \ S with

172

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

S ⊆ Y . Hence we can conclude that (i) these sets are admissible, (ii) each admissible subset of Y ∪ Y is either of the
form S ∪ Y \ S with S ⊆ Y or the subset of such a set, and (iii) no subset of such a set can be maximal admissible, i.e.,
preferred.

3. As mentioned in (1) the arguments b, b, c ∈ C ∪ C are not contained in any admissible set. Further, since Φ /∈ E we
obtain that the arguments x ∈ X ∪ X are not defended by E and thus not contained in E. The only arguments that are
left belong to Y ∪ Y and hence by (2) E = S ∪ Y \ S.

4. As Φ ∈ E it follows that each argument in C ∪ C is attacked by E. Further as b, b /∈ E each argument in C ∪ C is attacked

by an argument in E ∩ ( X ∪ Y ∪ X ∪ Y ). Thus by construction, E ∩ ( X ∪ Y ) is a model of ϕ.

5. Clearly M ∪ ( X ∪ Y ) \ M ∪ {Φ} is conﬂict-free. We have mutual attacks between arguments x ∈ X ∪ Y and the correspond-
ing arguments x ∈ X ∪ Y . Hence all arguments in X ∪ Y ∪ X ∪ Y are either in the set M ∪ ( X ∪ Y ) \ M or attacked by some
argument from this set. Further, as M is a model of Φ, it follows by construction that the arguments M ∪ ( X ∪ Y ) \ M
attack all the arguments in C ∪ C and thus defend Φ. Finally the argument Φ attacks both b and b. That is, each
argument of F either is in the set M ∪ ( X ∪ Y ) \ M ∪ {Φ} or attacked by an argument from this set. Hence the set
M ∪ ( X ∪ Y ) \ M ∪ {Φ} is a stable extension of F , and thus also a preferred extension of F .

We are going to show that the formula Φ is valid only if the argument Φ is skeptically accepted in F with respect to prf.
To this end we consider a valid formula Φ = ∀Y ∃ Xϕ( X, Y ). In order to obtain a contradiction let us assume that there exists
a preferred extension E such that Φ /∈ E. Then we have that E = S ∪ Y \ S for some S ⊆ Y . Using that the formula Φ is
(cid:5) = M ∪ ( X ∪ Y ) \ M ∪ {Φ} is a preferred
valid, we conclude that there exists a model M of ϕ such that S (cid:2) M. But then E
extension of F and E (cid:2) E

, a contradiction.

(cid:5)

It remains to show that the formula Φ is valid if the argument Φ is skeptically accepted in F with respect to prf.
Towards a contradiction, let us assume that Φ is not valid, i.e., there exists an S (cid:2) Y which is not contained in any model
of ϕ and that Φ is skeptically accepted in F . Now let us consider an arbitrary preferred extension E such that S ∪ Y \ S ⊆ E.
Such an E must exist as S ∪ Y \ S is an admissible set. By assumption Φ ∈ E. It follows that E ∩ ( X ∪ Y ) is a model of ϕ
containing S and we obtain the desired contradiction. (cid:2)

References

[1] P. Baroni, P.E. Dunne, M. Giacomin, On the resolution-based family of abstract argumentation semantics and its grounded instance, Artiﬁcial Intelli-

gence 175 (2011) 791–813.

[2] P. Baroni, M. Giacomin, Semantics of abstract argument systems, in: I. Rahwan, G. Simari (Eds.), Argumentation in Artiﬁcial Intelligence, Springer Verlag,

2009, pp. 25–44.

[3] T.J.M. Bench-Capon, P.E. Dunne, Argumentation in artiﬁcial intelligence, Artiﬁcial Intelligence 171 (2007) 619–641.
[4] P. Besnard, A. Hunter, Elements of Argumentation, The MIT Press, 2008.
[5] A. Bondarenko, P.M. Dung, R.A. Kowalski, F. Toni, An abstract, argumentation-theoretic approach to default reasoning, Artiﬁcial Intelligence 93 (1997)

63–101.

[6] M. Caminada, On the issue of reinstatement in argumentation, in: M. Fisher, W. van der Hoek, B. Konev, A. Lisitsa (Eds.), Logics in Artiﬁcial Intelligence,
Proceedings of the 10th European Conference, JELIA 2006, Liverpool, UK, September 13–15, 2006, in: Lecture Notes in Computer Science, vol. 4160,
Springer Verlag, 2006, pp. 111–123.

[7] M. Caminada, Semi-stable semantics, in: P.E. Dunne, T.J.M. Bench-Capon (Eds.), Proceedings of the 1st Conference on Computational Models of Argu-

ment (COMMA 2006), in: Frontiers in Artiﬁcial Intelligence and Applications, vol. 144, IOS Press, 2006, pp. 121–130.

[8] M. Caminada, D.M. Gabbay, A logical account of formal argumentation, Studia Logica 93 (2009) 109–145.
[9] J. Chen, Y. Liu, S. Lu, B. O’Sullivan, I. Razgon, A ﬁxed-parameter algorithm for the directed feedback vertex set problem, J. ACM 55 (2008) Art. 21, 19.
[10] S. Coste-Marquis, C. Devred, P. Marquis, Symmetric argumentation frameworks, in: L. Godo (Ed.), Symbolic and Quantitative Approaches to Reasoning
with Uncertainty, Proceedings of the 8th European Conference, ECSQARU 2005, Barcelona, Spain, July 6–8, 2005, in: Lecture Notes in Computer Science,
vol. 3571, Springer Verlag, 2005, pp. 317–328.

[11] Y. Dimopoulos, A. Torres, Graph theoretical structures in logic programs and default theories, Theoret. Comput. Sci. 170 (1996) 209–244.
[12] R.G. Downey, M.R. Fellows, Parameterized Complexity, Monographs in Computer Science, Springer-Verlag, New York, 1999.
[13] P.M. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games, Artiﬁcial

Intelligence 77 (1995) 321–357.

[14] P.E. Dunne, Computational properties of argument systems satisfying graph-theoretic constraints, Artiﬁcial Intelligence 171 (2007) 701–729.
[15] P.E. Dunne, T.J.M. Bench-Capon, Complexity and combinatorial properties of argument systems, Technical Report, University of Liverpool, 2001.
[16] P.E. Dunne, T.J.M. Bench-Capon, Coherence in ﬁnite argument systems, Artiﬁcial Intelligence 141 (2002) 187–203.
[17] P.E. Dunne, M. Caminada, Computational complexity of semi-stable semantics in abstract argumentation frameworks, in: S. Hölldobler, C. Lutz, H. Wans-
ing (Eds.), Proceedings of the 11th European Conference on Logics in Artiﬁcial Intelligence JELIA 2008, in: Lecture Notes in Computer Science, vol. 5293,
Springer, 2008, pp. 153–165.

[18] P.E. Dunne, M. Wooldridge, Complexity of abstract argumentation, in: G. Simari, I. Rahwan (Eds.), Argumentation in Artiﬁcial Intelligence, Springer US,

2009, pp. 85–104.

[19] W. Dvoˇrák, S. Woltran, Complexity of semi-stable and stage semantics in argumentation frameworks, Inform. Process. Lett. 110 (2010) 425–430.
[20] W. Dvoˇrák, S. Woltran, On the intertranslatability of argumentation semantics, J. Artif. Intell. Res. 41 (2011) 445–475.
[21] W. Dvoˇrák, Technical note: Exploring Σ P

2 -hardness for argumentation problems with ﬁxed distance to tractable classes, CoRR, arXiv:1201.0478

2 /Π P

[cs.AI], 2012.

[22] W. Dvoˇrák, R. Pichler, S. Woltran, Towards ﬁxed-parameter tractable algorithms for abstract argumentation, Artiﬁcial Intelligence 186 (2012) 1–37,

doi:10.1016/j.artint.2012.03.005.

[23] W. Dvoˇrák, S.Szeider, S. Woltran, Reasoning in argumentation frameworks of bounded clique-width, in: P. Baroni, F. Cerutti, M. Giacomin, G.R. Simari
(Eds.), Computational Models of Argumentation, Proceedings of COMMA 2010, in: Frontiers in Artiﬁcial Intelligence and Applications, vol. 216, IOS,
2010, pp. 219–230.

[24] J.K. Fichte, S. Szeider, Backdoors to tractable answer-set programming, in: T. Walsh (Ed.), IJCAI, 2011 Proceedings of the 22nd International Joint

Conference on Artiﬁcial Intelligence, Barcelona, Catalonia, Spain, July 16–22, 2011, pp. 863–868.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 157–173

173

[25] J. Flum, M. Grohe, Parameterized Complexity Theory, Texts in Theoretical Computer Science, An EATCS Series, vol. XIV, Springer-Verlag, Berlin, 2006.
[26] M.R. Garey, D.R. Johnson, Computers and Intractability, W.H. Freeman and Company, New York, San Francisco, 1979.
[27] S. Gaspers, S. Szeider, Backdoors to satisfaction, CoRR, arXiv:1110.6387 [cs.DS], 2011.
[28] G. Gottlob, S. Szeider, Fixed-parameter algorithms for artiﬁcial intelligence, constraint satisfaction, and database problems, Comput. J. 51 (2006) 303–

325. Survey paper.

[29] H. Jakobovits, D. Vermeir, Robust semantics for argumentation frameworks, J. Logic Comput. 9 (1999) 215–261.
[30] S. Modgil, M. Caminada, Proof theories and algorithms for abstract argumentation frameworks, in: I. Rahwan, G. Simari (Eds.), Argumentation in

Artiﬁcial Intelligence, Springer-Verlag, 2009, pp. 105–132.

[31] R. Niedermeier, Invitation to Fixed-Parameter Algorithms, Oxford Lecture Series in Mathematics and its Applications, Oxford University Press, Oxford,

2006.

[32] C.H. Papadimitriou, Computational Complexity, Addison-Wesley, 1994.
[33] S. Parsons, M. Wooldridge, L. Amgoud, Properties and complexity of some formal inter-agent dialogues, J. Logic Comput. 13 (2003) 347–376.
[34] J.L. Pollock, How to reason defeasibly, Artiﬁcial Intelligence 57 (1992) 1–42.
[35] I. Rahwan, G.R. Simari (Eds.), Argumentation in Artiﬁcial Intelligence, Springer Verlag, 2009.
[36] B. Reed, K. Smith, A. Vetta, Finding odd cycle transversals, Oper. Res. Lett. 32 (2004) 299–301.
[37] N. Robertson, P.D. Seymour, R. Thomas, Permanents, Pfaﬃan orientations, and even directed circuits, Ann. of Math. (2) 150 (1999) 929–975.
[38] M. Samer, S. Szeider, Backdoor sets of quantiﬁed Boolean formulas, J. Automat. Reason. 42 (2009) 77–97.
[39] M. Samer, S. Szeider, Fixed-parameter tractability, in: A. Biere, M. Heule, H. van Maaren, T. Walsh (Eds.), Handbook of Satisﬁability, IOS Press, 2009,

pp. 425–454.

[40] B. Verheij, Two approaches to dialectical argumentation: admissible sets and argumentation stages, in: Proceedings of the 8th Dutch Conference on

Artiﬁcial Intelligence (NAIC’96), pp. 357–368.

[41] B. Verheij, A labeling approach to the computation of credulous acceptance in argumentation, in: M.M. Veloso (Ed.), Proceedings of the 20th Interna-

tional Joint Conference on Artiﬁcial Intelligence (IJCAI 2007), pp. 623–628.

[42] R. Williams, C. Gomes, B. Selman, Backdoors to typical case complexity, in: G. Gottlob, T. Walsh (Eds.), Proceedings of the Eighteenth International

Joint Conference on Artiﬁcial Intelligence, IJCAI 2003, Morgan Kaufmann, 2003, pp. 1173–1178.

