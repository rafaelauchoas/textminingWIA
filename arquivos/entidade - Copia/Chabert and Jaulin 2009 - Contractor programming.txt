Artiﬁcial Intelligence 173 (2009) 1079–1100

Contents lists available at ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Contractor programming
Gilles Chabert a,∗

, Luc Jaulin b

a Ecole des Mines de Nantes LINA CNRS UMR 6241, 4, rue Alfred Kastler, 44300 Nantes, France
b ENSIETA, 2, rue Fran cois Verny, 29806 Brest Cedex 9, France

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 22 February 2008
Received in revised form 11 March 2009
Accepted 15 March 2009
Available online 18 March 2009

Keywords:
Constraint processing
Interval methods
Solver design
Programming languages

This paper describes a solver programming method, called contractor programming, that
copes with two issues related to constraint processing over the reals. First, continuous
constraints involve an inevitable step of solver design. Existing softwares provide an
insuﬃcient answer by restricting users to choose among a list of ﬁxed strategies. Our
ﬁrst contribution is to give more freedom in solver design by introducing programming
concepts where only conﬁguration parameters were previously available. Programming
consists in applying operators (intersection, composition, etc.) on algorithms called
contractors that are somehow similar to propagators.
Second, many problems with real variables cannot be cast as the search for vectors
simultaneously satisfying the set of constraints, but a large variety of different outputs
may be demanded from a set of constraints (e.g., a paving with boxes inside and outside of
the solution set). These outputs can actually be viewed as the result of different contractors
working concurrently on the same search space, with a bisection procedure intervening in
case of deadlock. Such algorithms (which are not strictly speaking solvers) will be made
easy to build thanks to a new branch & prune system, called paver.
Thus, this paper gives a way to deal harmoniously with a larger set of problems while
giving a ﬁne control on the solving mechanisms. The contractor formalism and the paver
system are the two contributions. The approach is motivated and justiﬁed through different
cases of study. An implementation of this framework named Quimper is also presented.

© 2009 Elsevier B.V. All rights reserved.

1. Introduction

Constraint programming is a simple and eﬃcient paradigm to handle a large class of combinatorial problems [40,10,44].
In the presence of real-valued variables, constraint propagation algorithms combined with interval analysis [16,22,27,19,9]
are also particularly well-suited, included for real-world applications (see, e.g., [33,21]). We shall refer to this interval variant
of constraint programming as interval programming. Even then, interval programming has had only moderate success. In our
opinion, the reason is a lack of clear and uniﬁed formalism describing how solvers and derived programs are built. This
paper is an attempt to ﬁll this gap.

We propose a framework that allows one to build a continuous solver with a few lines, in a high-level syntax. More than

just another tuning language, a programming framework is proposed.

1.1. Motivation

Three reasons justify the introduction of a solver programming framework in presence of real variables.

* Corresponding author.

E-mail addresses: gilles.chabert@emn.fr (G. Chabert), luc.jaulin@ensieta.fr (L. Jaulin).

0004-3702/$ – see front matter © 2009 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2009.03.002

1080

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1. Constraint programming is a declarative paradigm which means that a programmer should spend most of the effort in
modeling conveniently the problem. This effort may involve breaking symmetries, introducing global or soft constraints,
etc.. All these concepts are related to modeling and represent, by the way, very active ﬁelds of research. In theory, the
solver is a black box of which a programmer could ignore the details.
Despite of this, there is always a need at some point to control the solver, as it is with all declarative languages (consider
for instance Prolog cuts that allow ruling out choices in the search). We can say that the overall eﬃciency one gets is
the combined result of efforts made on both aspects: modeling and solver control.
With real variables, modeling languages are limited.1 Constraints can usually be nothing but equations which means
that mathematics is de facto the ultimate modeling language.2 The consequence is that solver control becomes an
inevitable step if one is to improve eﬃciency.

2. Continuous solvers have a two-layered structure, namely interval analysis and constraint programming, The lower layer
includes interval arithmetics and interval numerical algorithms (e.g., an interval variant of the Newton iteration) with
round-off considerations. The upper layer includes branch & prune algorithms for describing sets of reals deﬁned by
constraints (or optimizing a criterion under constraints). Since these layers correspond to quite different scientiﬁc com-
munities, there is a need more than ever for an interface between them. In concrete words, it would be useful to give
a constraint programmer the ability to develop a continuous solver without digging into details of interval analysis.
3. The last and possibly main point is related to the output of constraint solvers. With discrete domains, the output is
always the set of solutions (or a subset optimizing some criteria). But in continuous domains, there may be a large
variety of different outputs. First, one may look for a sub-paving (a set of boxes) encompassing the solutions and this
is precisely what most of the existing solvers provide. They act as root ﬁnders. Next, in case of a solution set with
a non-null volume, several sub-pavings are expected, each satisfying a different property, basically: “may contain a
solution”, “does contain a solution” or “contains only solutions”. Such solvers rather act as set describers. Actually, we
will see through the examples of Section 2 that the semantics behind the sub-pavings may completely change from one
problem to the other.3 As we will show, neither a root ﬁnder nor a set describer is adapted for solving these problems. Of
course, ad-hoc solutions always exist, but the purpose is precisely to avoid a multiplicity of programs where a single one
would be enough. In practice, when people are facing a speciﬁc constraint problem that requires a speciﬁc algorithm,
they have to reverse-engineer the code of an existing solver. Often, they redevelop it from scratch.

1.2. Contribution

We propose a formalism and an algorithm, called paver.
In the formalism, the different interval routines (evaluations, projections, existence tests, etc.) are all wrapped in the
very same object called contractor (see Section 3). Of course, the concept of contractor is not a novelty on its own. Our
(ﬁrst) contribution is to redeﬁne various constraint programming techniques (propagation, shaving, parameter splitting, etc.)
as operations over contractors that yield new contractors (Section 4). Syntactically, the contractor is then the unique atom,
whence a certain simplicity. A solver can then be programed, rather than conﬁgured, by combining different contractors
(examples are given in Sections 4.2, 4.3, 5.1 and 5.5).

The paver algorithm is a generic solver. It takes a list of contractors, an initial box and follows a classical recursion: the
contractors are successively called on the current box until either it gets empty or no more contraction could be done. In
the latter case, the box is bisected and contractors are called back again.

The fact that different contractors work concurrently allows solving problems of quite different nature (see next section).

This is our second contribution.

Hence, contractor programming consists in two distinct steps: contractor design and paver design. The former refers to the
design of the most possible eﬃcient contractor for a given set (constraint) and shall be discussed in Section 4. The latter
refers to the selection of contractors that yield the desired output, regardless of eﬃciency.

This framework is already supported by a real system named Quimper that will be introduced in Section 6.
Thinking of contractor programming as an extension of constraint programming is valid to the extent that contractors
help in modeling the output of a problem. But, fundamentally, there is not such an extension since constraints basically tell
the “what” whereas contractors tell the “how”.

Note that branching will not be covered in this paper but one has to keep in mind that this part of the paver should be
customizable as well. Only plain bisection will be used in the examples (variable are selected with a round-robin heuristic).

1 This limitation holds for numerical systems involving analytic expressions, which cover most of the mathematical models of physics problems. But
modeling languages as such are not limited with real variables any more than with discrete ones (one may introduce table of constraints, piecewise
constraints, etc.).

2 There is still a notable exception: geometrical constraints. Geometry represents a semantic level above algebra; as an example, the “intersection of three
spheres” can be introduced as a global constraints instead of three equivalent distance equations [1]. But, except in such cases, no improvement has to be
expected from the modeling side.

3 We can say that no modeling language dedicated to the output exists so far, and this is another important distinction with discrete problems where

this modeling aspect is not as ubiquitous (solvers using explanations are counter-examples).

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1081

1.3. Power of contractor programming

As for every programming language, the power of contractor programming, i.e., the class of problems that can be solved
using this paradigm would require the setting of computability theory to be described formally. Pavings obtained in our
framework are the results of algorithms that recursively contract boxes to smaller boxes and this general deﬁnition does not
even involve the concept of constraint. It can also ﬁt well, e.g., in the context of computer graphics to draw fractals. This
means that some pavings generated by our system cannot be characterized by constraints.

However, one may wonder which problems contractor programming is the most aimed at. The contractor paradigm is
mostly aimed at building set computation tools over the reals. These tools typically calculate disjunction of equidimensional
sets and sets are usually described by constraints. There are however very few restriction on their form: constraints can be
ﬁrst-order logic formulas involving numerical equations or inequalities and quantiﬁed parameters. They can also be handled
implicitly by their associated contractor.

The main point is that the representation of the sets and the way it is calculated are both entirely controllable.

1.4. Related works

In discrete constraint programming, existing tools already give control mechanisms with sometimes an associated for-
malism. In constrained-based local search, the COMET system [46] offers a language allowing one to give his own deﬁnition
of moves and neighborhoods, the incremental computation of the impact after a move being done automatically.

In branch & prune systems, choice points and propagation can usually be controlled. The Choco [25], ILOG Solver
[20] and Gecode [43] libraries allow to specify the instantiation order for both variables and values. It can also be decided
how to split domains (either instantiate or bisect domains, etc.).

Propagation has given rise to more sophisticated concepts. The aforementioned libraries allow the programmer to as-
sociate his own propagator, or ﬁltering algorithm, to a constraint. In Gecode, propagators can be automatically generated
from a formula. It is possible with Choco to control when propagators are launched thanks to a system of events (e.g., a
bound is reduced, the variable is instantiated, etc.). This allows, as a side effect, to schedule constraints in the propagation loop
(some costly propagators may ignore events of minor importance). Events handling have to be implemented by the propa-
gators in Gecode, albeit recent works about advisors [29] facilitate this task. These mechanisms are all related to modeling
(a propagator is associated to a constraint), preserving declarativity. As far as we know, there is not a way to build new
propagators, say, by composing different propagators, at the modeling phase. Only programmers with a good knowledge of
the target library are able to do so. This is a difference with contractor programming that aims at building solvers rather than
operational constraints.

In contrast, eﬃciency has always taken precedence over ﬂexibility in continuous constraint programming. Perhaps be-
cause of the prevailing numerical culture, solvers are indeed usually compared on a performance basis. As a consequence,
none of the different existing implementations (Numerica [47], RealPaver [15], Alias [32], Rsolver [38], GlobSol [26], Baron
[41], etc.) supply a good level of openness or extensibility. These libraries contain solvers or global optimization algorithms
with a very high-level interface, basically restricting users to enter a system of equations, set up some parameters and
press enter. Of course, there may be many parameters. For instance, it can be decided whether Alias has to resort to the
computation of the Hessian matrix or to ask RealPaver for the global consistency instead of a solution set. But there is
no way to venture off the beaten tracks.

A side contribution of this paper is a new representation for solution spaces with non-empty interiors. More suitable
representations have been proposed in [42] using quadtrees/octrees or in [48] using extreme vertices. However, quadtrees
consist in discretizing constraints and reasoning using this auxiliary representation. This otherwise appealing method is
therefore quite distant from interval programming. Results of this paper are unlikely to be applicable in the context of
quadtrees.

Computing extreme vertices can be viewed as an independent operation to obtain a compact representation of a set of
boxes. The dissertation [48] contains also smart branching heuristics and a concept of active variables to preserve the align-
ment of small boxes. All these concepts are fully compatible with our framework and somehow orthogonal to contractors
since they are related to branching issues. They can be viewed as complementary to ours.

1.5. Notations and vocabulary

The set of all intervals is denoted by IR.
A Cartesian product of intervals is called a box. Intervals and boxes will be surrounded by brackets, e.g., [x]. The symbol
+
−
i will stand for the lower and
i and x

[x] will always denote a n-dimensional box, except otherwise stated. If [x] is a box, x
upper bound of [x]i respectively.

The width of a box [x] is the largest diameter of its components. The smallest box enclosing a set S in denoted by (cid:2)S.
A sub-paving of [x] is a set of non-overlapping boxes included in [x]. A sub-paving will either be considered as a collection
of boxes {[x](1), . . . , } or as a union [x](1) ∪ . . . depending on the context. Hence, a sub-paving can either be viewed as a
discrete subset of IRn or as a compact subset of Rn.

1082

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

A paving of [x] is a collection of sub-pavings K1, . . . , KN such that

(cid:2)

(cid:2)

[x] =

[b].

1(cid:2)k(cid:2)N

[b]∈Kk

Finally, we will temporarily adopt the following deﬁnition. Let c be a constraint on the reals, i.e. c(x) is either true or

false. A contractor for c is a function C : IRn → IRn, usually given by a polynomial-time algorithm, such that:

(cid:3)

∀[b] ∈ IRn,

C([b]) ⊆ [b] and
∀x ∈ [b]\C([b]) c(x) is not satisﬁed.

Note that the concept of contractor will be generalized in our formalism (see Section 3). Thanks to interval arithmetics,

many contractors can be built with respect to an equation f (x) = 0, where f : Rn → Rm.

Example 1. Consider
exp([x2]), [x2] ∩ log[x1]). C is a contractor with respect to f (x) = 0.

f : R2 → R with f (x) = x1 − exp(x2) and deﬁne C : IR2 → IR2 as follows: C([x]) := ([x1] ∩

1.5.1. Contractor versus propagator

In spite of appearance, contractor is not just a new name for propagator. A propagator is associated to a constraint and
destined to be called in a propagation loop. As we will see, a contractor is not necessarily associated to a constraint and
may have nothing to do with propagation. Furthermore, we will add a continuity condition in the deﬁnition of a contractor
(see Section 3.2) that does not exist for propagators. Finally, the term ﬁltering was not chosen because of a conﬂict with the
everyday meaning of ﬁltering in many areas dealing with continuous systems (e.g., Kalman ﬁltering).

1.6. The ABC of interval programming

Let us end this introduction with a short description of what interval programming is all about.
The basic algorithm of interval programming is the root ﬁnder. Consider a system of equations f (x) = 0, where x is
a variable in Rn and f a mapping from Rn to Rm. A root ﬁnder wraps solutions into boxes of any desired precision
(leaving aside ﬂoating-point considerations) by using a branch & prune process, where the prune operation is performed by
a contractor.

Here is the sketch of the algorithm. Note that a stack is used for the depth-ﬁrst search and that the precision criterion

chosen here is width[x] < ε.

Of course, the existing implementations are much more sophisticated. But this simpliﬁed description is enough from a
language perspective. In the ideal case of a square system (m = n) without singularity, solutions are punctual (and certiﬁca-
tion can be demanded). In the general case, a n − m dimensional surface is described. This is illustrated in Fig. 1.

Consider now f : Rn → Rm, and [x] × [ y] ∈ Rn+m. We may look for the following set inverse:

−1([ y]) ∩ [x] := {x ∈ [x] | ∃ y ∈ [ y] y = f (x)}.

f

Note that set inversion is a particular subclass of quantiﬁed constraints (see, e.g., [12,39]). The root-finder algorithm
will split the whole solution set into small boxes, as depicted in Fig. 2(a).

In this case (i.e., when the solution set has a non-null n-dimensional volume) we might expect the solver to dissociate
boxes that may contain solutions (boundary boxes) from boxes that only contain solutions (inner boxes). Clearly, precision is
only required for boundary boxes, splitting an inner box being useless and even counter-productive.

A more appropriate output is given in Fig. 2(b). Hence, an enhanced algorithm set-describer can be derived from
root-finder by inserting an inner test before the call to the contractor. The design of inner tests has been a matter of
study in several publications (see, e.g., [13,18,14]).

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1083

Fig. 1. An enclosure of {x ∈ [−0.5, 2.5] × [−2.5, 0.5], f (x) = 0} with f (x) = exp(x1x2) − sin(x1 − x2).

(cid:4)

Fig. 2. A set inversion problem f (x) ∈ [ y] with f (x) =
deﬁned in Section 2.1 (i.e., small boxes enclosing all the solutions). (b) A more adapted output for the same set inversion problem, including inner test.

2 and [ y] = [3, 6] in [x] = [−7, 7] × [−7, 7]. (a) The output of the set inversion problem as

+ x2

x2
1

2. Motivating examples

The purpose of this section is to present ﬁve different problems tractable by interval programming and to show that
neither root-finder nor set-describer are appropriate. Once again, we do not claim that no algorithm exists for
these problems. We just claim that no algorithm exist that solves them all. Note that root-finder and set-describer
will not be two different algorithms in our formalism.

2.1. A decomposable problem

In several applications, systems are suﬃciently sparse to be decomposed by equational or geometric techniques [24,36,6].
Consider for example the system of distance constraints in two dimensions depicted in Fig. 3. There are 5 points connected
by 6 distance equations. Points A and B are ﬁxed and the three others are the unknowns. Instead of directly solving the

1084

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

Fig. 3. A decomposable system.

6 × 6 overall system, we can process progressively in three steps. We can solve the ﬁrst triangle { A, B, C}, which is a 2 × 2
system. Because of rigidity, there is only a ﬁnite number of solutions (two ﬂips). Then, for each solution, the second triangle
{B, C, D} can be solved because C is ﬁxed. Finally, the triangle {C, D, E} can be solved in turn once C and D are ﬁxed.

In general, solving the decomposed problem (here, seven 2 × 2 systems including ﬂips) is faster than solving the global
problem (here, one 6 × 6 system). No standard root ﬁnder supports the implementation of such strategies. The state of the
art in decomposition-based solving methods relies on dedicated algorithms.

2.2. Enhanced description of the ring

Let us consider again the set inversion problem introduced in Section 1.6. We mentioned that an inner test was necessary
(whence the set-describer algorithm) but an inner contractor could also be introduced in this case and would actually
be much more adapted.

Indeed, the set inversion problem can be easily formulated as a conjunction of two inequalities. It has been shown (see
[8,2]) in the case of inequalities that, by a negation trick, the problem can be reversed so that any contracted region of the
reversed problem lies inside the feasible region of the original one.

Remember that [ y] ∈ IR. We have

c(x) ⇐⇒ f (x) ∈ [ y] ⇐⇒ y

− (cid:2) f (x) and

f (x) (cid:2) y

+

.

Hence, a point is unfeasible if

−

y

> f (x) or

f (x) > y

+

.

− > f (x) and f (x) > y
Now, we can contract a box [x] with respect to y
. If [x](1) and [x](2) are the two resulting boxes,
then [x]\([x(1)] ∪ [x(2)]) is inside the solution set {x ∈ [x] | c(x)}. In such situation, it would be fruitful to replace the current
search space [x] by [x(1)] ∪ [x(2)] and to memorize that the complementary space is inner. The set-describer algorithm
is therefore not really appropriate.

+

2.3. Level surfaces

Level surfaces is a generalization of the previous problem, and can be stated as follows. Consider f : Rn → R and N

decreasing values y1 > · · · > y N . The goal is to classify all the points of an initial domain [x] according to the constraints:

f (x) (cid:3) y1
f (x) (cid:3) y2
...
f (x) (cid:3) y N ,

or

or

(1)

with a priority corresponding to the intuitive idea that we are more interested in the highest values: the surface level y1,
i.e., the number of points satisfying f (x) (cid:3) y1 must be maximized ﬁrst. Then, the surface level y2 must be maximized and
so on. Fig. 4(a) shows an example of 4 surface levels. Note that this problem could be easily generalized to a MAX-SAT
problem.

Let us now focus on input/output. Of course, using directly (1) as an input constraint makes no sense, since (1) is
equivalent to f (x) (cid:3) y N . One could rather solve N times the set inversion problem f (x) ∈ [ yk, yk+1] and superimpose the
different outputs (see Fig. 4(b)). However, this is not satisfactory for at least two reasons.

First, the boundaries around each level surface (the little white boxes in Fig. 4(b)) should not appear, except for the
lowest one. This undesirable boundaries will be cleared off in Fig. 11. One could circumvent this effect by slightly enlarging

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1085

Fig. 4. Surfaces levels f (x) (cid:3) yi . (a) An example with y1 = 0.8, y2 = 0.6, y3 = 0.4, y4 = 0.2 and f (x) = sin(x2
1
Darkness increases with f . (b) The same example decomposed into set inversion problems.

+ x2

2)/(exp(x1) + x2

2), in [x] = [−2, 2] × [−2, 2].

the intervals [ yk, yk+1] before computing the inversions, making level surfaces overlap. Another trick would simply be to
move the boundary sub-paving of the kth surface level into the inner sub-paving of the (k − 1)th level surface. However, in
both cases, we “cheat” and lose reliability of the result.

Second, the decomposition of the input problem into N sub-problems and the aggregation of the intermediate results

requires extra and undesirable manipulations from the user.

2.4. Set inclusion

Given two sets deﬁned by constraints c1 and c2, the set inclusion problem consists in proving or refuting that one set is

included in the other. This is illustrated in Fig. 5(a).

We shall denote by set(c) the set associated to a constraint:

set(c) = {x ∈ Rn | c(x) is true}.

Using the conjunction of c1 and c2 as an input in algorithm set-describer may address the problem in the following
situations: if no solution is found, then no set can be included in the other since these sets do not intersect at all. In the
other way around, if the whole initial box is included in the inner sub-paving then the two sets coincide. Except in these
extreme cases, nothing can be said.

As before, one may solve separately c1 and c2, and check for the inclusion of both the inner & boundary sub-pavings of
c1 into the inner sub-paving of c2 (see Fig. 5(b)). Again, this requires undesirable manipulations by the user; but, worse, this
process is extremely ineﬃcient. Assume that a box B in Fig. 5(b) is detected as inner in the paving of set(c2) and recursively
bisected and contracted in the paving of set(c1) until either boundary or inner boxes are found. All this work could be spare
since the inclusion set(c1) ∩ B ⊆ set(c2) ∩ B is already established. Hence, this decomposition involves a huge number of
useless computations.

Of course, one could legitimately object that in the example given in Fig. 5, c1 can be reversed as in Section 2.2 to ¯c1 so
that running a standard solver with ¯c1 and c2 will do the job as expected. Indeed, if no solution is found, no point satisfy
c2 and ¯c1, i.e., set(c2) ⊆ set(c1). However, in general, a constraint cannot be reversed while an inner test is still possible. As
an example, a constraint c1(x) of the following form:

c1(x) ⇐⇒ ∃ y ∈ [0, 1]

(cid:3)

f (x, y) = 0
g(x, y) = 0

cannot be reversed if y has multiple occurrences while testing for an inner box is possible (an algorithm is given in [12]).

2.5. Bounded-error parameter estimation

This last example is rather devoted to solver design: the problem is not new in terms of input/output but requires a

speciﬁc strategy.

1086

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

Fig. 5. Set inclusion. (a) Two subsets of [x] = [−3, 1] × [−1, 3] deﬁned by constraints: c1(x) ⇐⇒ exp(x1x2) − sin(x2 − x1) ∈ [−0.1, 0.1] (in dark gray)
and c2(x) ⇐⇒ exp(x1 − x2) × sin(x1x2) ∈ [−0.1, 0.1] (in light gray). We have set(c1) ⊆ set(c2). (b) The same set inclusion problem decomposed into set
inversion problems.

Consider the following model of a real-time system [23]:

f (p, t) = 20 exp(−p1t) − 8 exp(−p2t)

where p1 and p2 are two unknown parameters. Assume that a vector of 10 measurements y1, . . . , y10 is available, these
measurements corresponding to times t1, . . . , t10 respectively.

The question is to compute a rigorous enclosure of all the feasible p1 and p2 from the experimental data, taking into

account uncertainties on both yi and ti . Hence, given intervals [ti] and [ yi], we have to describe the following set:

{(p1, p2) | ∀i ∈ [1..10], ∃ yi ∈ [ yi], ∃ti ∈ [ti] yi = f (p, ti)}.

If we restrict ourselves to a single measurement (instead of 10), the problem boils down to a simple set inversion, with
a thick constant [ti]. Hence, the set to be computed seems to be nothing but the intersection of 10 set inversions. The
set-describer algorithm seems to suit well.

In fact, the multi-incidence of t in the expression of f makes this strategy ineﬃcient. Indeed, whatever is the underlying
method used for the contractor or the inner test, the domain of t has to be small for the resulting operator to be sharp.
Hence, the domain of t has to be split by the solver. This is illustrated in Fig. 6.

Second, introducing the vector t as variables makes the search space dimension jumps from 2 to 12 unless one wants to

solve the 10 problems separately. This leads to a combinatorial explosion.

In conclusion, there is a need for splitting the component ti (and only this one) inside the contractor and inner test

associated to the ith measure. To our knowledge, no available solver is generic enough to be tuned in this way.

3. A new formalism

We show now that the different examples of Section 2 can be solved as suggested by the very same algorithm, a generic

solver called paver, when expressed in the contractor formalism.

We describe the paver and the formalism in this section. We will provide concrete examples of contractors in Section 4

and subsequently revisit the problems of Section 2.

3.1. The “contract and classify” paver

To help intuition, let us consider the problem in Section 2.3. It turns out from this example that several sets have to be

described simultaneously, each set corresponding to a different constraint.

Let us assume that sets are disjoint. We will see below how to circumvent the case of overlapping sets.
Each point of the initial space has to be classiﬁed with respect to these sets. For a given point x, this means that the
membership of x to the different sets can be tested successively. If one test succeeds, then x can be marked as treated and
associated to the corresponding set.

A generic interval solver can directly be derived from this “test and classify” principle. Remember ﬁrst that a contractor
C can be easily built from any constraint c. The contractor C has the following property: if C([x]) = [ y] (i.e., [ y] is the

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1087

Fig. 6. The parameter estimation problem. (a) The set of feasible points (p1, p2). (b) The result using a standard contraction and inner test without splitting
the domains of ti (bisection precision is 0.01). First, a very few of inner boxes could be found. Second, the outer enclosure is not sharp at all.

contraction of [x]) then every eliminated point in [ y]\[x] does not satisfy c. Thus, with a simple negation trick, a contractor
¯C such that all eliminated points satisfy c is as easy to build.

Example 2. Consider the set inversion problem, in Section 2.2. A point inside the ring satisﬁes f (x) ∈ [ y]. Consider a
contractor ¯C built from f (x) /∈ [ y]. If ¯C([x]) = [ y] then [x]\[ y] is inside the ring.

Given a box [x] and a constraint c, if the complementary contractor ¯C reduces [x] to [ y], then [x]\[ y] can be classiﬁed,
i.e., mark as “inside c”. Then, the paver proceeds as follows (the algorithm is detailed below). The solver takes as input a
list of contractors and an initial box [x](0). The ﬁrst contractor is enforced on [x] := [x](0). If the contraction is effective, a
smaller box [x](cid:12)
is stored in a sub-paving associated to the ﬁrst contractor. Only [x](cid:12)
is left to be treated, and the second contractor is called. When all the contractors become ineffective on a box [x], we can
say that the common ﬁxpoint of all contractors is reached and [x] is bisected. The whole process is then repeated until the
list of boxes becomes empty. We will see in the next section how the termination of the algorithm can be guaranteed.

is returned and the difference4 [x]\[x](cid:12)

4 Note that resorting to a simple tree structure avoids to explicitly describe the difference between [x] and [x](cid:12)

: the latter simply becomes a subnode of

the former.

1088

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

Note that paver is not an AC3-like algorithm, for essentially two reasons. First, contractors given to the paver algorithm
usually involve all the variables merely because they all correspond to sets (or more generally, to sub-pavings) which have
the same dimension as the initial box. This is not a rule but a “user advice”. One can put different constraints at this level in
order to trace their contraction power. But, the paver level is intended to deal with sets while all the constraints related to a
given set should be encapsulated in the same outer or inner contractor, as explained further. Second, because the semantics
of contractors goes beyond that of constraints, the order in which they are called may have an inﬂuence on the quality of
the result (the number of boxes in a sub-paving). For instance, a contractor designed to detect a very weak condition should
preferably be called on last resort (we might lose boxes satisfying a stronger condition).

3.2. Contractors

Deﬁnition 1 (Contractor). A contractor is a mapping C from IRn to IRn such that

(i)

(ii)

∀[x] ∈ IRn, C([x]) ⊆ [x]

(x ∈ [x], C({x}) = {x}) ⇒ x ∈ C([x])

(contraction)

(consistency)

(iii)

C({x}) = ∅ ⇔ (∃ε > 0, ∀[x] ⊆ B(x, ε), C([x]) = ∅)

(continuity)

where B(x, ε) is the ball centered on x with radius ε.

A box [x] is said to be insensitive to C if C([x]) = [x] and sensitive otherwise. By extension, a point x is said to be sensitive
or insensitive whether {x} is sensitive or not. Property (i) states that a box can only be reduced by a contractor. Property (ii)
states that no insensitive points can be removed. Finally, property (iii) is required for properties on the paver as we will
explain further.

The set associated to a contractor C is the union of all of its insensitive points:

set(C) = {x ∈ Rn, C(x) = x}.

The continuity property of C implies that set(C) is closed.

If C is a contractor for a constraint c, in the classical sense of the word (see Section 1.5), then set(C) ⊇ set(c). An
important novelty in our formalism is to consider sets associated to contractors rather than to constraints. This allows a
rigorous description of the output of our paver (see Proposition 2). A contractor is not only an algorithm, it can also be
interpreted as a subset of Rn, and all the standard operations on sets can be extended to contractors. We deﬁne:

(C1 ∩ C2)([x]) := C1([x]) ∩ C2([x])
(C1 ∪ C2)([x]) := (cid:2)(C1([x]) ∪ C2([x]))
(C1 ◦ C2)([x]) := C1(C2([x]))

(intersection)

(union)

(composition)

∞
1

C

:= C1 ◦ C1 ◦ C1 ◦ · · ·

C1 (cid:18) C2 := (C1 ∩ C2)
C1 (cid:19) C2 := (C1 ∪ C2)

∞

∞

(iterated composition)

(iterated intersection)

(iterated union).

All these operations are stable, i.e., they only yield contractors.

We also introduce the following deﬁnition:

Deﬁnition 2. Let C1, . . . , Ck be a collection of contractors.

C1, . . . , Ck are complementary if set(C1) ∩ · · · ∩ set(Ck) = ∅,
C1, . . . , Ck are independent if ∀i (cid:20)= j, set(Ci)C ∩ set(C j)C = ∅.

Additional properties of contractors play a signiﬁcant role:

C is monotonous if

[x] ⊆ [ y] ⇒ C([x]) ⊆ C([ y]),

C is minimal if

∀[x] ∈ IRn, C([x]) = (cid:2)([x] ∩ set(C)),

C is idempotent if

∀[x] ∈ IRn, C(C([x])) = C([x]).

Given a contractor C on Rn × Rm, we also deﬁne the two following contractors on Rn:

(2)

(3)

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1089

∪[ y] when [ y] is degenerated (a real y). The contraction on
Fig. 7. Proj-Union. We consider a contractor C on IR2 with S := set(C). (a) Representation of C
∪ y (x) = {x}
[x] results in an enclosure of {x ∈ [x] | (x, y) ∈ S}. Since C is continuous, when both [x] and [ y] are degenerated, the enclosure is minimal, i.e., C
iff (x, y) ∈ S. (b) Principle of an implementation resorting to parameter splitting and union of sub-contractions (the interval [ y] is decomposed as ﬁnely as
∪[ y]) is obtained, after numerous repetitions of the splitting
possible). (c) Result of the proj-intersection in practice: only an outer approximation of set(C
operation presented in (b).

Fig. 8. Proj-intersection. (a) In a similar way as in Fig. 8, given a ﬁxed interval [ y], C
an implementation resorting to parameter splitting and intersection. (c) Result of the proj-intersection in practice: only an outer approximation of set(C
is obtained.

allows to constrain x ∈ R with ∀ y ∈ [ y], (x, y) ∈ S. (b) Principle of
∩[ y])

∩[ y]

∪[ y]

C

([x]) :=

∩[ y]

C

([x]) :=

(cid:2)

y∈[ y]
(cid:5)

y∈[ y]

πx(C([x], y)),

πx(C([x], y))

with πx([x], [ y]) := [x]. The ﬁrst operation is called proj-union and the second proj-intersection. Once again, these operations
are stable in the set of contractors. We have:

∪[ y]

set(C

∩[ y]

set(C

) = {x, ∃ y ∈ [ y], (x, y) ∈ set(C)},

) = {x, ∀ y ∈ [ y], (x, y) ∈ set(C)}.

This result being rather intuitive, the proof is not given (see Figs. 7 and 8). In practice, these operators are implemented
as follows. For the proj-union, [ y] is split into a sequence of small subintervals [ y]i . Then, the contractor C is enforced on
each sub-domain [x] × [ yi] and the hull of the results is returned. For the proj-intersection, a sequence of points yi are
sampled from [ y], C is enforce on [x] × { yi} and the intersection of the results is returned.

Although examples of contractors will be the topic of Section 4, we shall introduce right here the precision contractor Cε
that has a special status. This contractor is aimed at controlling the precision of the paver or scheduling contractors (see
Sections 5.1 and 5.3) and will be implicitly referred to in the subsequent propositions.

1090

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

Deﬁnition 3 (Precision contractor). Given (cid:4) > 0, the precision contractor Cε is deﬁned as follows:

(cid:6)

Cε([x]) :=

[x]
∅

if width([x]) > (cid:4)
otherwise.

Many properties could be stated on contractors. As an example, the set of idempotent and monotonous contractors is a
complete lattice for the inclusion. Listing these properties would be out of the scope of this paper, which is rather aimed at
introducing the concepts. However, the fundamental properties of the paver given in the previous section are based on the
properties of contractors and we are now in position for proving them.

3.3. Paver properties

Proposition 1 (Termination). Let {C1, . . . , Ck} be a list of complementary contractors. The paver terminates for any initial box [x](0).

Proof. Assume by contradiction that paver does not terminate. Hence, there is a sequence of non-empty boxes [x](i) and
˜x ∈ [x](0) such that for all i > 0:

(i)

(ii)

(iii)

[x](i) ⊂ [x](i−1) (strict inclusion, i.e., [x](i) (cid:20)= [x](i+1))
C1([x](i)) = · · · = Ck([x](i)) = [x](i)
˜x ∈ [x](i).

Indeed, (i) is a direct consequence of the properties of contractors and bisections and (ii) is due to the ﬁxpoint postcon-
dition of the inner while loop inside the paver algorithm. Finally, for all i, pick a point ˜x(i) ∈ [x](i) (which is non-empty).
The sequence is bounded so it admits at least one accumulation point ˜x. Since for all i, [x](i) is a closed set that contains
the whole subsequence (˜x( j)) j(cid:3)i , it also contains this accumulation point ˜x. Hence, (iii) holds.

Now, each box [x](i) can be identiﬁed to a 2n-tuple u(i) of its vertices coordinates. This identiﬁcation can be made
isometric with appropriate distances (the Hausdorff distance on IRn and its counterpart on R2n). For all component j,
is either increasing or decreasing, and bounded by a component of ˜x. Hence, it converges to a
1 (cid:2) j (cid:2) 2n, the sequence u
point ¯u j . By the inverse isometry, it follows that the sequence of boxes [x](i) converges then to a box ¯[x]. Furthermore, the
width of this box is necessarily null (i.e.,

¯[x] is a degenerated box {¯x}) since

(i)
j

∀i (cid:3) 0,

rad([x](i+n)) (cid:2) 1
2

rad([x](i)).

Next, we have set(C1) ∩ · · · ∩ set(Ck) = ∅ which means that at least one contractor Cl satisﬁes ¯x /∈ set(Cl). By applying the
continuity property of Cl (see Deﬁnition 1) we obtain that there exists (cid:4) and i such that [x](i) ⊆ B(¯x, (cid:4)) and Cl([x](i)) = ∅,
i.e., a contradiction. (cid:2)

To ensure the complementarity between contractors, we usually resort to the precision contractor because set(Cε) = ∅.
Informally, the following proposition states that, up to a given precision (cid:4), the sub-paving associated to a contractor
matches the intersection of the other contractors sets. Since the set of a contractor usually approximates the set related to
an initial constraint, we have now a clear semantics for the paver.

Proposition 2 (Sub-pavings characterization). Let {C1, . . . , Ck} be a list of independent contractors and Cε such that set(Cε) = ∅. Let
us denote by K1, . . . , Kk and K(cid:4) the sub-paving returned by paver for C1, . . . , Ck and Cε respectively. We have:

(cid:5)

∀i, 1 (cid:2) i (cid:2) k,

set(C j)\Ki ⊆ K(cid:4) .

j(cid:20)=i

Proof. First of all, paver terminates thanks to the previous proposition. Let i be an index, 1 (cid:2) i (cid:2) k. For all j (cid:20)= i we have
j(cid:20)=i set(C j). Since ∀[x] ∈ Ki we
by hypothesis set(Ci)C ∩ set(C j)C = ∅ hence set(Ci)C ⊆ set(C j) which implies set(Ci)C ⊆
have [x] ⊆ set(Ci)c (by applying the consistency of Ci ), then Ki ⊂ set(Ci)C ⊂
j(cid:20)=i set(C j). The two last inclusions are strict
because set(Ci)C is open while the other sets are closed. It follows that

j(cid:20)=i set(C j)\Ki is non-empty.

Take [x] in this set and assume [x] /∈ K(cid:4) . The box [x] has been removed from the search by Cl with 1 (cid:2) l (cid:2) k, i.e.
j(cid:20)=i set(C j) then l = i which leads to a contradiction since [x] /∈ Ki . (cid:2)

[x] ⊆ set(Cl)C . Since [x] ∈

(cid:7)

(cid:7)

(cid:7)

(cid:7)

4. Contractor design

In this section, we present some contractors and operations that do not help in modeling problems but in improving
the eﬃciency of a paver. We basically explain how to manage a constraint c, i.e., the different ways to build a contractor C

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1091

satisfying set(C) = set(c). Likewise, all the operations op will preserve associated sets. E.g., an unary operator op will satisfy
for all contractor C , set(op(C)) = set(C).

Hence, contractors and operations in this section will not have an inﬂuence on the result, in terms of sub-paving char-
acterization. On the other hand, they may decrease the time complexity or the space complexity (i.e., the number of boxes
in a sub-paving).

We will overlook technical details on purpose here, sticking to generalities. The interested reader may refer to Section 6

where important implementation choices we made for our own system are disclosed.

We shall distinguish numerical contractors, those which are directly built from a numerical constraint, and those which

are the result of an operation (such as composition) between other contractors.

Numerical contractors can be related to equations, inequalities or systems of equations. The point is that a large part
of interval analysis routines can be wrapped into these contractors. As announced above, a good separation can then be
obtained between numerical skills (the design of numerical contractors) and constraint programming skills (the design of
compound contractors).

In this layered framework, constraint propagation will be generalized to contractor propagation. A possible implementation

of the corresponding operator (propag) will be described in detail in Section 6.3.

4.1. Numerical contractors

Several contractors can be associated to an equation f (x) = 0.
The simplest one consists in evaluating with interval arithmetics f ([x]) and checking whether 0 belongs to the image
range or not. If 0 /∈ f ([x]) then [x] can be contracted to the empty set. Otherwise, it is left unchanged. This contractor can
therefore be qualiﬁed as binary (in the sense that it keeps all or nothing). This test can be easily extended to inequali-
ties. This contractor can be given many variants, based on various symbolic or numerical processing as the two following
examples show.

Example 3. Assume that there exist several equivalent expressions for f , say f 1, . . . , fk, each of them minimizing the multi-
incidence of a different variable. Since the overestimation of interval evaluation grows with the multi-incidence of variables
(see [34]), we get to sharper results by computing f 1([x]) ∩ · · · ∩ fk([x]) instead of
f ([x]), whence a more accurate (but
slower) test.

(cid:12)([x])([x] − x0) instead of
Example 4. On the numerical side, we can resort to the centered form, i.e., compute f (x0) + f
f ([x]) where x0 is an arbitrary point inside [x]. Higher-order Taylor formulas may also be payfull. One may also introduce
intermediate monotonicity tests. Consider a two-dimensional vector x. If ∂ f
is
∂ x1
−
increasing with respect to x1 so that f ([x]) can be replaced by [ f ({x
1

([x]) turns to be a positive interval then f
} × [x2])], a smaller interval.

+
} × [x2]), f ({x
1

More sophisticated contractors associated to a constraint c (equation or inequality) compute an outer estimation of the
feasible set, i.e., C([x]) is a non-trivial superset of {x ∈ [x] | c(x)}. Three important techniques can be found in the literature:

1. Forward-backward traversals of the syntax tree with intermediate interval computations, such as HC4Revise [3].
2. Univariate interval Newton iterations (as performed by the narrowing operator of box consistency [47]).
3. Linear relaxations (see [30] and references therein). In such techniques, a non-linear constraint is cast into a linear

program which feasible region encompasses the original solution set.

Given an equation f (x) = 0, we will denote by C f
Of course, numerical techniques can also handle several equations simultaneously, i.e., a system of equations. Many of
them are derived from a multivariate interval Newton, one famous variant being the Hansen–Sengupta algorithm [17]. In
case of linear equalities, many dedicated algorithms also exist (see [35] or [37]). One can be easily convinced that all these
algorithms act as contractors.

in the sequel an arbitrary contractor among those above.

4.2. Propagation

The propagation operator allows the implementation of interval variants of the classical AC3 algorithm such as hull
consistency (see, e.g., [3,11]) but also many more algorithms. This operator illustrates by itself the potential of our framework,
in terms of contractor design. The key idea is to propagate contractors instead of constraints.

Given a list of contractors, the principle is to obtain the ﬁxpoint of their composition, i.e., (C1 ◦ · · · ◦ Cm)∞

at a lower

computation price. We shall denote by propag our operator. We have:

set(propag(C1, . . . , Cm)) = set((C1 ◦ · · · ◦ Cm)

∞

)

which means that propag is a pure eﬃciency contractor (it has no impact on the output).

An implementation of this operator will be proposed in Section 6.3.

1092

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

Let us now recall that the hull consistency enforces bound consistency for each equation. In practice, only a relaxation of
bound-consistency is calculated via the HC4Revise algorithm. The resulting propagation algorithm is called HC4. In our
framework, given a list of constraints c1, . . . , cm, the HC4 algorithm is simply reimplemented as follows

HC4(c1, . . . , cm) ← propag(HC4Revise(c1), . . . , HC4Revise(cm)).

A more interesting direct application is a multi-level propagation. Sometimes, we would like to group constraints we know
to have strong “dependencies”. For instance, one may ﬁnd relevant to perform an intermediate ﬁxpoint with constraints that
strictly share the same variables. Consider three sets of constraints {c1, c2, c3}, {c4} and {c5, c6}. The following contractor will
ensure that a constraint in a subset (say, c4) will not be wakened between constraints of other subsets (say, c1 and c2).

propag(propag(c1, c2, c3), c4, propag(c5, c6)).

4.3. Shaving

The purpose of this section is to show that other operators exist besides propag.
Shaving is an operation that allows implementing refutation techniques, similar to SAC [5] with discrete domains. With
continuous domains, refutation is used to shrink endpoints only (instead of any value inside the domains) so that the
structure of interval is always maintained (whence the fancy name shaving).

Detailing the algorithm here would take too much room. We shall only give a rough description.
A shaving operator shave takes a contractor C . Given a box [x], the resulting contractor shave(C ) contracts “slices”
−
−
+ (cid:4)]
with C , i.e., subboxes obtained from [x] by restricting the domain [x]k of one component to a small subinterval [x
k , x
k
+
]. When the result of the subcontraction is an empty set, the slice is removed. Otherwise, contraction is tried
or [x
k
on a smaller slice. This recursion leads to consistent endpoints. More formally, the resulting box [ y] := (shave(C))([x])
satisﬁes ∀k = 1, . . . , n

+
− (cid:4), x
k

C([ y]1 × · · · × [ y]k−1 × { y

and

C([ y]1 × · · · × [ y]k−1 × { y

−
k

+
k

} × [ y]k+1 × · · · × [ y]n) (cid:20)= ∅

} × [ y]k+1 × · · · × [ y]n) (cid:20)= ∅.

The shaving operator can also be given many variants mainly because of the slicing which can either be optimistic (“try

large slices ﬁrst”) or pessimistic (“check consistency of endpoints ﬁrst”).

Given m constraints c1, . . . , cm, a box consistency operator (see [4,45,47]) can be reimplemented in our framework as

follows:

propag(shave(univNewton(c1)), . . . , shave(UnivNewton(cm)))

where UnivNewton is an univariate interval Newton contractor (see Section 4.1). The 3B consistency deﬁned in [31] can
be reimplemented as follows:

shave(HC4(c1, . . . , cm)).

5. Revisiting examples

We now revisit all the examples in our framework. By convention, the sub-paving of the precision contractor will always
be represented in white in the pictures. As a preliminary example, consider the system of equations in Fig. 1 and remember
that the goal is to enclose the solution set into a sub-paving. By a direct application of our formalism, we then need two
contractors:

1. A contractor C f , to remove unfeasible points.
2. The precision contractor Cε .

The desired output is given in Fig. 9. This time, the result of the outer contraction appears as a sub-paving with only
unfeasible points. The roots are all in the sub-paving of the precision contractor.

5.1. A decomposable problem

Assume that each subsystem (called block) has to be solved by a combination of propagation and interval Newton. Of
course, a multivariate interval Newton (denoted by newton henceforth) requires a square system. When one variable is
ﬁxed (e.g., xC and yC when the second triangle is to be solved), it must not be considered as a variable by newton but
rather as an interval constant. Such information typically enters as a “static” parameter (see Section 6.1). For that reason, the

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1093

Fig. 9. System of equations, with an outer and precision contractor. The sub-paving of the outer contractor is in light gray.

newton contractor takes two arguments: the set of constraints and the set of variables. Similarly, let us reﬁne the behaviour
of the precision contractor Cε (see Section 4). This contractor will also take here a subset S of variables in parameter. A box
[x] is emptied by Cε(S) if and only if the domains of the components in S all have a diameter lower than ε.

In the sequel, d P Q denotes the distance constraint between two points P and Q .
For each block (here: a triangle), the solving strategy is implemented thanks to the following operator block_

contractor:

block_contractor({c1, . . . , ck}, {x1, . . . , xk}) ← HC4(c1, . . . , ck) ∩ newton({c1, . . . , ck}, {x1, . . . , xk}).

For instance, a paver run with block_contractor({dB D , dC D }, {xD , y D }) (and Cε ) with xC and yC ﬁxed (i.e., their domains
have a diameter less than ε) will solve the second triangle in the required manner, i.e., using propagation and Newton.

The step-by-step solving method proposed in Section 2.1 can then be directly implemented with the following contractor:

block_contractor({d AC , dBC }, {xC , yC })

∩ (Cε({xC , yC })

∪ (block_contractor({dB D , dC D }, {xD , y D })

∩ (Cε({xC , yC , xD , y D })

∪ block_contractor({dD E , dC E }, {xE , y E })))

provided that variables are bisected block after block. In more details, the variables of the ﬁrst block {xC , yC } must be
bisected (say, in a round-robin fashion) until precision is achieved for both of them. The bisection procedure must then pro-
ceed to the second block, and so on. Branching procedures are not covered in this paper but this mechanism is orthogonal
to contractors and one should be easily convinced that a block-wise bisection is easy to set up.

5.2. Enhanced description of the ring

In the set inversion problem, we need to characterize {x | f (x) ∈ [ y]}. This means that two sets have to be described
+] and

by contractors: {x | f (x) ∈ [ y]} (the ring) and {x | f (x) /∈ int([ y])} (the complementary of the ring). Put [ y] = [ y
g(x) := f (x) − y.

−, y

To deal with unfeasible points, we need an outer contractor. This contractor, denoted by C f ∈[ y], can be simply deﬁned

as follows:

C f ∈[ y] := [x] (cid:23)→ πx(C g([x], [ y])).

The points inside the ring have to be classiﬁed with an inner contractor. As explained in Section 2.2, the latter comes

naturally with the negation of the problem. We have

1094

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

Fig. 10. A description of the ring involving outer and inner contractors.

c(x) ⇐⇒ f (x) ∈ [ y] ⇐⇒ y

− (cid:2) f (x) and f (x) (cid:2) y

+

⇐⇒ f (x) ∈ [ y

−

, +∞) and f (x) ∈ (−∞, y

+].

Hence,

¯c(x) ⇐⇒ f (x) ∈ (−∞, y
(cid:24)⇒ f (x) ∈ (−∞, y

Therefore, the contractor

−

+

) or f (x) ∈ ( y
+
−] or f (x) ∈ [ y

, +∞)
, +∞).

C f /∈[ y]([x]) := [x] (cid:23)→ πx(C g([x], (−∞, y

−])) ∪ πx(C g([x], [ y

+

, +∞)))

only removes unfeasible points for ¯c, i.e., feasible points for c.

Now, set(C f ∈[ y]) ∩ set(C f /∈[ y]) is the boundary of the ring, which is non-empty. Hence, we have to add a precision con-
tractor to ensure the termination of the algorithm. The result is depicted in Fig. 10. Since C f ∈[ y] and C f /∈[ y] are independent,
the ring represented on the ﬁgure can be interpreted as an approximation of the set to be described (see Proposition 2).

5.3. Level surfaces

First of all, the contractor C f ∈[ yi ,+∞) (as deﬁned in the previous paragraph) could be associated to the ith level surface
{ f (cid:3) yi}. Of course, in this way, the contractor of the lowest surface level would preempt most of the boxes, leading to a
bad result (independence does not hold).

Introducing a priority between the different contractors (in addition to independence) does not require any extra concept.
We just need to adapt the contractors to their actual semantics: a (suﬃciently small) box [x] must be classiﬁed with the
contractor of the ith surface level only if

[x] is inside the ith surface level

and [x] does not intersect the (i − 1)th surface level

or [x] has a small width (lower than ε).

The desired contractor Ci is then obtained by simply rewriting these conditions in terms of sub-contractors:

Ci := C f /∈[ yi ,+∞) ∪ (C f ∈[ yi−1,+) ∩ Cε)

or, using a sub-distributivity rule:

Ci := C f /∈[ yi−1,+∞] ∩ (C f ∈[ yi ,+∞) ∪ Cε).

Finally, we need as before an outer contractor for all the surface levels, namely, Cn+1 := C f ∈(−∞, yn]. Moreover, the
intersection of C1 ∩ · · · ∩ Cn+1 is {x | f (x) = yn} and, as usual, this set can be treated by a precision contractor Cε . Fig. 11
shows the desired output.

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1095

Fig. 11. An appropriate paving, with smooth boundaries between surface levels.

Fig. 12. The set inclusion problem solved by a more adapted algorithm. Boxes in dark gray does not belong to set(c1). Boxes in light gray are inside set(c2).
We resort to splitting only in regions where boundaries of set(c1) and set(c2) are close.

5.4. Set inclusion

The set inclusion problem can be solved eﬃciently in our formalism by using the following simple reasoning.
A box [x] can be discarded from the search either if it does not belong to set(c1) or if it is included in set(c2). Indeed, in

both cases, [x] cannot compromise the assertion to be proven since ∀x ∈ [x] we have c1(x) (cid:24)⇒ c2(x).

Hence, an inner contractor C1 for c1 and an outer contractor C2 for c2 can be used jointly. Only the box that both

(possibly) contain points inside set(c1) and outside set(c2) are bisected. The result is depicted in Fig. 12.

No precision need to be introduced if int(set(c1)) ⊆ set(c2) (where int stands for interior) since the algorithm will end in

this case (we have set(C1) ∩ set(C2) = ∅). But we still need a precision contractor Cε in case of non-inclusion.

1096

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

Fig. 13. Parameter estimation solved with inner and outer contractors based on proj-union and proj-intersection. The precision of the paver is still 0.01.

5.5. Bounded-error parameter estimation

As we evoked above, modeling this problem causes no diﬃculty. The overall inner contractor is the union of the inner
contractors related to each measure, say, C gi /∈[ yi ] with gi(p) := f (p, ti) and ti ∈ [ti]. Here, the interval extension of gi is a
thick function since an interval constant [ti] substitutes for the variable ti .

Likewise, the intersection of the outer contractors C gi ∈[ yi ] deﬁnes an outer contractor for the whole problem.
For eﬃciency, we have to split ti inside the ith outer and inner contractor. Consider ﬁrst outer contraction: (p1, p2) is
feasible if at least one value in [ti] satisﬁes f (p, ti) ∈ [ yi]. Hence, if a point (p, ti) ∈ R3 is insensitive to C f ∈[ yi ] then p must
be insensitive to the outer contractor. The proj-union deﬁned in Section 4 exactly ﬁts this requirement. We deﬁne:

Couter := C

∪[t1]
f (p,t1)∈[ y1] ∩ · · · ∩ C

∪[t10]
f (p,t10)∈[ y10].

Similarly, the proj-intersection ﬁts the requirement for the inner contraction. Indeed, a point (p, ti) ∈ R3 sensitive to C f /∈[ yi ]
must be discarded by the inner contractor. We deﬁne:

Cinner := C

∩[t1]
f (p,t1) /∈[ y1] ∪ · · · ∪ C

∩[t10]
f (p,t10)) /∈[ y10].

A paving resulting from the combination of these contractors is shown in Fig. 13.

6. The Quimper system

Besides theoretical investigations, contractor programming has given rise to a real system named Quimper (QUick
Interval Modeling and Programming in a bounded-ERror context). This system includes today three different programs:
qPave (a graphical tool for paving sets in 2D), qSolve (a tool for listing numerical results, typically in high dimension)
and qTraj (a graphical tool tailored to constraint problems derived from differential equations).

These are light-weight programs that only manage input/output, i.e., the language for writing contractors (the “Quimper
language”) and the interface for conﬁguring, running the paver and handling generated pavings. They are linked to a C++
library called Ibex (Interval-Based Explorer) that implements a contractor programming framework.

Ibex is based itself on the Profil/Bias library [28] for the low-level interval arithmetics. However, part of this
library has been wrapped into functions that manage all the borderline cases (inﬁnite bounds, values out of deﬁnition
domains, empty sets, etc.) so that arithmetic operations are always exception-free. This explains why a modiﬁed release of
Profil/Bias is included in the Ibex package.

All these software components are under GPL licence and can be downloaded online [7]. A user guide for Quimper
(including the grammar of the Quimper language), as well as a complete documentation of Ibex classes are available on
the same site. An archive containing all the examples of this paper in the Quimper syntax is also provided.

Ibex/Quimper has been developed by the ﬁrst author but this software should be considered as a prototype since a
real collaborative open-source project continuing this work is about to be launched. This new project will take advantage of
the existing code.

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1097

The purpose of this section is to give some insight into the Ibex system. For convenience, we shall adopt some object-

oriented coding notations. A contractor C is a class with the main function being contract, i.e., for a box [x]

C.contract([x])

contracts [x] with C .

Generalizing constraint propagation to contractor propagation required letting the interface of contractors inherit from
constraints. First, we can ask a contractor whether the domain of a given variable can impact the result of the contraction
or not. This notion simply generalizes the incidence graph of a constraint network.

A contractor C , as a class, therefore implements a Boolean function involves that takes in argument the index j of a

variable, i.e.,

C.involves(j)

returns false or true. Note that, by default, a contractor always returns true. In the parlance of object-oriented pro-
gramming, this function needs not necessarily be overridden.

Second, we also added a few parameters to the contract function above, besides the box to be contracted, as explained

in the next section.

6.1. Indicators

Every contractor has its own set of speciﬁc parameters. For instance, the precision contractor Cε (maxdiamGT in the
Quimper syntax) takes a parameter ε. The interval Newton also needs a parameter for controlling the termination of the
iteration: when a step does not reduce any interval by more than a given ratio, the procedure stops. This ratio can be
set externally. These parameters are related to the semantics speciﬁc to contractors (e.g., the precision contractor has by
deﬁnition a threshold) or their implementations. They are usually set once for all (as constructor parameters). We shall not
consider this type of parameters any further.

There is another type of parameters required by constraint programming algorithms for eﬃciency reasons, called in-
dicators. The purpose of these parameters is to notify contractors during the search about the context in which they are
called. For instance, we may inform a contractor that only a contraction on a given variable is actually expected (any other
contraction being superﬂuous). If the time complexity of the contractor depends on the number of variables, some work is
spared. We may also inform the contractor that only the domain of a given variable has been modiﬁed since the last call.
Again, if the contractor works incrementally, this will speed up contraction.

Two indicators have been integrated into our system, corresponding precisely to the examples just given. The ﬁrst is
named scope and contains the subset of variables to be treated. The second is named impacted and contains the subset of
variables whose domain has been impacted.

The semantics of indicators is constrained by one single fundamental property: they can be ignored by a called contractor
without spoiling soundness (i.e., losing solutions), whence their name. If one develops a contractor that ignores the scope
indicator, this contractor can still be passed as argument to an operator, should the latter be based on the communicability
of this information (e.g., propagate below). The consequence is only a loss of eﬃciency.

Hence, only two indicators are proposed today but the nice point with indicators is that new ones can be invented at any
time and integrated progressively in the subsequent implementations of contractors. In other words, backward compatibility
is complete. We just had to put all the indicators in a dictionary structure. The real signature of the contract function is:

contract(box[x], dictionary indicators).

As an example, one can ask a contractor C to focus on the two ﬁrst variables only in the following way:

C.contract([x], {scope = {0, 1}}).

6.2. Numerical contractors

There is nothing particular in the implementation of numerical contractors in Quimper, except that indicators have to

be managed.

– The binary test 0 ∈ f ([x]) is actually not proposed in Quimper, but such a contractor would necessarily ignore all the

indicators.

– HC4Revise is implemented. The complexity of this contractor is linear in the length of the constraint expression.
Hence, contracting for a single variable amounts to contracting for all the variables (up to a small constant factor). In
Quimper, HC4Revise ignores the scope indicator.

– The univariate interval Newton is implemented. As contrary to HC4Revise, this contractor deals with one particu-
lar variable at a time. Setting the scope indicator to a single variable divides the contraction time by the number of
variables.

1098

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

– Linear relaxations are not yet implemented. Now, since a linear programming solver is called iteratively to reduce the
bounds of each initial variable, the scope indicator would have to be taken into account as with univariate Newton.

The multivariate interval Newton is also implemented and ignores the scope and impacted indicators.

6.3. Propagation

Here is how the propagation operator is implemented in Quimper.
Our convention for indices is to use i and j for contractors and variables respectively. When a couple (i, j) is revised,
the ith contractor has to work on the jth variable. If the revision succeeds (a signiﬁcant part of the ith domain is removed)
then the agenda is updated with the following classical procedure:

Now, if a revision (i, j) fails, there still may be a residual contraction. Furthermore, some subcontractors may not take into
account the scope indicator so that unsolicited contractions can appear as the propagation loop goes along. At some point,
the accumulation of these small contractions on a variable j can add up to a signiﬁcant contraction. The agenda must be
updated in consequence. In this case, the jth variable is the source but there is not a particular contractor. The agenda must
then be updated with all the couples (i, j), i describing the set of contractors. This is what the next procedure does.

Now, let us give the main procedure. Two local boxes are deﬁned, the ﬁrst is used to measure the result of each revision
(the contraction of Ci over x j ) while the latter measure the contractions collected since the last time x j triggered an update.

6.4. Some performance results

All the examples in this paper have been executed almost instantaneously (less than 0.1 s) when the precision was not

high (this corresponds to the ﬁgures with apparent boxes).

Fig. 4(a) was obtained by setting the precision of C(cid:4) to (cid:4) := 0.01. The paving contains 17768 boxes and was generated

in ∼1.2 s.

Fig. 5(a) was obtained with two natural contractors corresponding to the constraints c1(x) and ( ¯c1(x) ∧ c2), with a

precision set to (cid:4) := 0.005. The paving contains 40844 boxes and was generated in ∼2.2 s.

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

1099

Fig. 6(a) was obtained with (cid:4) := 0.001 and by splitting 10 times the parameter domain inside the contractors C
and
. Computation time was 26 s in this case, mainly because of the parameter splitting process which occurs systematically.

∩

∪

C
The paving includes 18249 boxes.

7. Conclusion

We have presented a new framework for interval programming. The beneﬁts of this framework are twofold. First, a large
class of constraint-based problems can now be addressed with a unique simple algorithm, called paver. Second, a full control
on the solving process is at hand, including the core of the propagation loop.

This framework is entirely built on the concept of contractor: inputs are contractors instead of constraints. Similarly,
outputs are related to contractor sets instead of constraints sets. As just said, this – apparently small – change in modeling
can lead to signiﬁcant improvements in the design of new solvers but also in a declarative way. In a sense, the imperative
aspect of solvers is now subsumed in the declarative one: the end user write constraints while the constraint programmer
write contractors.

This approach is supported by a real system called Quimper which solves quickly all the different problems mentioned

in this paper.

There are plenty of possible extensions for this work. The ﬁrst one is perhaps to deal with global optimization. This
extension would probably resort to dynamic contractors, i.e., contractors parameterized by a value that can be updated
during the solving process. Orthogonally to contractors that potentially remove all unfeasible points, local ﬁnders that ﬁnd
peculiar feasible points seem to be a key feature as well.

References

[1] H. Batnini, M. Rueher, Décomposition sémantique pour la résolution de systèmes d’equations de distance, JEDAI, Journal Electronique d’Intelligence

Artiﬁcielle 2 (1) (2004).

[2] F. Benhamou, F. Goualard, Universally quantiﬁed interval constraints, in: CP’00: 6th International Conference on Principles and Practice of Constraint

Programming, 2000, pp. 67–82.

[3] F. Benhamou, F. Goualard, L. Granvilliers, J.-F. Puget, Revising hull and box consistency, in: ICLP, 1999, pp. 230–244.
[4] F. Benhamou, D. McAllester, P. Van Hentenryck, CLP(intervals) revisited, in: International Symposium on Logic Programming, MIT Press, 1994, pp. 124–

138.

[5] C. Bessière, R. Debruyne, Optimal and suboptimal singleton arc consistency algorithms, in: IJCAI, 19th International Joint Conference on Artiﬁcial

Intelligence, 2005, pp. 54–59.

[6] C. Bliek, B. Neveu, G. Trombettoni, Using graph decomposition for solving continuous CSPs, in: CP’98: 4th International Conference on Principles and

Practice of Constraint Programming, Springer, 1998, pp. 102–116.
[7] G. Chabert, IBEX, an Interval-Based EXplorer, http://www.ibex-lib.org.
[8] H. Collavizza, F. Delobel, M. Rueher, Extending consistent domains of numeric CSP, in: IJCAI, Sixteenth International Joint Conference on Artiﬁcial

Intelligence, 1999, pp. 406–413.

[9] E. Davis, Constraint propagation with interval labels, Artiﬁcial Intelligence 32 (3) (1987) 281–331.
[10] R. Dechter, Constraint Processing, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2003.
[11] F. Delobel, H. Collavizza, M. Rueher, Comparing partial consistencies, Reliable Computing 5 (3) (1999) 213–228.
[12] A. Goldsztejn, A branch and prune algorithm for the approximation of non-linear AE-solution sets, in: SAC’06: Proceedings of the 2006 ACM Symposium

on Applied Computing, 2006, pp. 1650–1654.

[13] A. Goldsztejn, L. Jaulin, Inner and outer approximations of existentially quantiﬁed equality constraints, in: CP’06: 12th International Conference on

Principles and Practice of Constraint Programming, Springer, 2006, pp. 198–212.

[14] C. Grandón, G. Chabert, B. Neveu, Generalized interval projection: A new technique for consistent domain extension, in: IJCAI, 20th International Joint

Conference on Artiﬁcial Intelligence, 2007, pp. 94–99.

[15] L. Granvilliers, F. Benhamou, Algorithm 852: RealPaver: An interval solver using constraint satisfaction techniques, ACM Transactions on Mathematical

Software 32 (1) (2006).

[16] E. Hansen, Global Optimization Using Interval Analysis, second ed., Dekker, 2003.
[17] E.R. Hansen, S. Sengupta, Bounding solutions of systems of equations using interval analysis, BIT Numerical Mathematics 21 (2) (1980) 203–211.
[18] P. Herrero, M.A. Sainz, J. Vehí, L. Jaulin, Quantiﬁed set inversion algorithm with applications to control, Reliable Computing 11 (5) (2005) 369–382.
[19] E. Hyvönen, Constraint reasoning based on interval arithmetic: The tolerance propagation approach, Artiﬁcial Intelligence 58 (1–3) (1992) 71–112.
[20] ILOG, ILOG Solver, http://www.ilog.com/products/cp/.
[21] L. Jaulin, Localization of an underwater robot using interval constraint propagation, in: CP’06: 12th International Conference on Principles and Practice

of Constraint Programming, 2006.

[22] L. Jaulin, M. Kieffer, O. Didrit, E. Walter, Applied Interval Analysis, Springer, 2001.
[23] L. Jaulin, E. Walter, Guaranteed bounded-error parameter estimation for nonlinear models with uncertain experimental factors, Automatica 35 (5)

(1999) 849–856.

[24] C. Jermann, G. Trombettoni, B. Neveu, P. Mathis, Decomposition of geometric constraint systems: A survey, IJCGA, International Journal of Computational

Geometry and Applications 16 (5–6) (2006) 479–511.

[25] N. Jussien, G. Rochart, X. Lorca, The CHOCO constraint programming solver, in: CPAIOR’08 Workshop on Open-Source Software for Integer and Con-

straint Programming (OSSICP’08), 2008.

[26] R.B. Kearfott, GlobSol, http://interval.louisiana.edu/GlobSol.
[27] R.B. Kearfott, Rigorous Global Search: Continuous Problems, Springer, 1996.
[28] O. Knüppel, Proﬁl/Bias, http://www.ti3.tu-harburg.de/Software/PROFILEnglisch.html.
[29] M.Z. Lagerkvist, C. Schulte, Advisors for incremental propagation, in: CP’07: 13th International Conference on Principles and Practice of Constraint

Programming, Springer, 2007.

[30] Y. Lebbah, C. Michel, M. Rueher, Eﬃcient pruning technique based on linear relaxations, in: COCOS, in: Lecture Notes in Computer Science, vol. 3478,

2003, pp. 1–14.

1100

G. Chabert, L. Jaulin / Artiﬁcial Intelligence 173 (2009) 1079–1100

[31] O. Lhomme, Consistency techniques for numeric CSPs, in: IJCAI, 13th International Joint Conference on Artiﬁcial Intelligence, 1993, pp. 232–238.
[32] J.-P. Merlet, Alias, http://www-sop.inria.fr/coprin/logiciels/ALIAS.
[33] J.-P. Merlet, Solving the forward kinematics of a gough-type parallel manipulator with interval analysis, International Journal of Robotics Research 23 (3)

(2004) 221–236.

[34] R. Moore, Interval Analysis, Prentice-Hall, 1966.
[35] A. Neumaier, Interval Methods for Systems of Equations, Cambridge University Press, 1990.
[36] B. Neveu, G. Chabert, G. Trombettoni, When interval analysis helps inter-block backtracking, in: CP’06: 12th International Conference on Principles and

Practice of Constraint Programming, Springer, 2006.

[37] S. Ning, R.B. Kearfott, A comparison of some methods for solving linear interval equations, SIAM Journal of Numerical Analysis 34 (1) (1997) 1289–1305.
[38] S. Ratschan, RSolver, http://rsolver.sourceforge.net.
[39] S. Ratschan, Quantiﬁed constraints under perturbation, Journal of Symbolic Computation 33 (4) (2002).
[40] F. Rossi, P. van Beek, T. Walsh, Handbook of Constraint Programming (Foundations of Artiﬁcial Intelligence), Elsevier Science Inc., 2006.
[41] N. Sahinidis, BARON, Branch-And-Reduce Optimization Navigator, http://www.andrew.cmu.edu/user/ns1b/baron/baron.html.
[42] D. Sam-Haroud, B. Faltings, Consistency techniques for continuous constraints, Constraints 1 (1996) 85–118.
[43] C. Schulte, M. Lagerkvist, G. Tack, Gecode, http://www.gecode.org/.
[44] P. Van Hentenryck, The OPL Optimization Programming Language, MIT Press, Cambridge, 1999.
[45] P. Van Hentenryck, D. McAllester, D. Kapur, Solving polynomial systems using a branch and prune approach, SIAM Journal of Numerical Analysis 34 (2)

(1997) 797–827.

[46] P. Van Hentenryck, L. Michel, Constraint-Based Local Search, The MIT Press, 2005.
[47] P. Van Hentenryck, L. Michel, Y. Deville, Numerica: A Modeling Language for Global Optimization, MIT Press, Cambridge, 1997.
[48] X-H. Vu, Rigorous solution techniques for numerical constraint satisfaction problems, PhD Thesis, Swiss Federal Institute of Technology in Lausanne,

2005.

