Artiﬁcial Intelligence 173 (2009) 1406–1423

Contents lists available at ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Encoding deductive argumentation in quantiﬁed Boolean formulae

Philippe Besnard a, Anthony Hunter b,∗

, Stefan Woltran c

a IRIT-CNRS, Universitè Paul Sabatier, 118 rte de Narbonne, 31062 Toulouse, France
b Department of Computer Science, University College London, Gower Street, London, WC1E 6BT, UK
c Institute for Information Systems 184/2, Technische Universität Wien, Favoritenstrasse 9-11, 1040 Vienna, Austria

a r t i c l e

i n f o

a b s t r a c t

There are a number of frameworks for modelling argumentation in logic. They incorporate
a formal representation of individual arguments and techniques for comparing conﬂicting
arguments. A common assumption for logic-based argumentation is that an argument is a
pair (cid:3)(cid:2), α(cid:4) where (cid:2) is minimal subset of the knowledge-base such that (cid:2) is consistent
and (cid:2) entails the claim α. Different logics provide different deﬁnitions for consistency and
entailment and hence give us different options for argumentation. Classical propositional
logic is an appealing option for argumentation but the computational viability of generating
an argument is an issue. To better explore this issue, we use quantiﬁed Boolean formulae
to characterise an approach to argumentation based on classical logic.

© 2009 Elsevier B.V. All rights reserved.

Article history:
Received 27 January 2009
Received in revised form 12 May 2009
Accepted 25 June 2009
Available online 27 June 2009

Keywords:
Argument systems
Argumentation
Classical logic
Inconsistency
Quantiﬁed Boolean formulae
Conﬂicting knowledge

1. Introduction

Argumentation is a vital aspect of intelligent behaviour by humans. Consider diverse professionals such as politicians,
journalists, clinicians, scientists, and administrators, who all need to collate and analyse information looking for pros and
cons for consequences of importance when attempting to understand problems and make decisions.

There is a range of proposals for logic-based formalisations of argumentation (for reviews see [8,13,31]). These proposals
allow for the representation of arguments for and against some claim, and for counterargument relationships between
arguments.

In a number of key proposals for argumentation, an argument is a pair where the ﬁrst item in the pair is a consistent
set (or a minimal consistent set) of formulae that proves the second item which is a formula (see for example [1,5,7,15,
24,26,30]). Hence, different underlying logics provide different deﬁnitions for consistency and entailment and hence give us
different options for deﬁning the notion of an argument.

Since classical logic has many advantages for representing and reasoning with knowledge including syntax, proof theory
and semantics for the intuitive language incorporating negation, conjunction, disjunction and implication, it is an interesting
and promising choice for the underlying logic for argumentation. However, it is computationally challenging to generate
arguments from a knowledge-base using classical logic. If we consider the problem as an abduction problem, where we
seek the existence of a minimal subset of a set of formulae that implies the consequent, then the problem is in the second
level of the polynomial hierarchy [23]. Furthermore, given a knowledge-base (cid:4) and a formula α, it has been shown that
ascertaining whether there is a subset (cid:2) of (cid:4) such that (cid:3)(cid:2), α(cid:4) is an argument (i.e. (cid:2) is consistent, (cid:2) entails α, and there
is no subset of (cid:2) that entails α) is a (cid:5) p

2 -complete decision problem [29].

* Corresponding author.

E-mail address: A.Hunter@cs.ucl.ac.uk (A. Hunter).

0004-3702/$ – see front matter © 2009 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2009.06.006

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

1407

Beyond these observations, there remains a range of further important computational complexity questions. So to better
understand the use of classical logic in argumentation, and in particular to understand its computational properties, we
use quantiﬁed Boolean formulae (QBFs) to characterise an approach to argumentation that is based on classical logic. This
characterisation can then be used to obtain computational complexity results in terms of upper bounds.

A further reason to characterise logic-based argumentation in the form of QBFs is that we can then harness implementa-
tions of QBF solvers to develop prototype implementations for logic-based argumentation. There are numerous QBF solvers
available (see, e.g, [28] and the references therein), and the encodations we present in this paper can be straightforwardly
handled in them.

2. Preliminaries

2.1. Logical argumentation

In this section we review an existing proposal for logic-based argumentation [7]. We consider a classical propositional
language. We use α, β, γ , . . . to denote formulae and (cid:4), (cid:2), (cid:8), . . . to denote sets of formulae. Deduction in classical propo-
sitional logic is denoted by the symbol (cid:5) and deductive closure by Th so that Th((cid:2)) = {α | (cid:2) (cid:5) α}.

For the following deﬁnitions, we ﬁrst assume a knowledge-base (cid:4) (a ﬁnite set of formulae) and use this (cid:4) throughout.
We further assume that every subset of (cid:4) is given an enumeration (cid:3)α1, . . . , αn(cid:4) of its elements, which we call its canonical
enumeration. This really is not a demanding constraint: In particular, the constraint is satisﬁed whenever we impose an
arbitrary total ordering over (cid:4). Importantly, the order has no meaning and is not meant to represent any respective impor-
tance of formulae in (cid:4). It is only a convenient way to indicate the order in which we assume the formulae in any subset of
(cid:4) are conjoined to make a formula logically equivalent to that subset.

The paradigm for the approach is a large repository of information, represented by (cid:4), from which arguments can be
constructed for and against arbitrary claims. Apart from information being understood as declarative statements, there is no
a priori restriction on the contents, and the pieces of information in the repository can be as complex as possible. Therefore,
(cid:4) is not expected to be consistent. It need not even be the case that every single formula in (cid:4) is consistent.

The framework adopts a very common intuitive notion of an argument. Essentially, an argument is a set of relevant
formulae that can be used to classically prove some claim, together with that claim. Each claim is represented by a formula.

Deﬁnition 1. An argument is a pair (cid:3)(cid:2), α(cid:4) such that: (1) (cid:2) ⊆ (cid:4); (2) (cid:2) (cid:7)(cid:5) ⊥; (3) (cid:2) (cid:5) α; and (4) there is no (cid:2)(cid:9) ⊂ (cid:2) such
that (cid:2)(cid:9) (cid:5) α. We say that (cid:3)(cid:2), α(cid:4) is an argument for α. We call α the claim (or consequent) of the argument and (cid:2) the
support of the argument (we also say that (cid:2) is a support for α).

Example 1. Let (cid:4) = {α, α → β, γ → ¬β, γ , δ, δ → β, ¬α, ¬γ }. Some arguments are:

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:3)

(cid:3)

{α, α → β}, β
{¬α}, ¬α
{α → β}, ¬α ∨ β
{¬γ }, δ → ¬γ

(cid:3)
.

(cid:3)

By monotonicity of classical logic the following equivalent characterisation easily follows.

Proposition 1. A pair (cid:3)(cid:2), α(cid:4) is an argument iff it satisﬁes (1)–(3) from Deﬁnition 1 together with (4

(cid:9)

) for each φ ∈ (cid:2), ((cid:2) \ {φ}) (cid:7)(cid:5) α.

Arguments are not independent. In a sense, some encompass others (possibly up to some form of equivalence). To clarify

this requires a few deﬁnitions as follows.

Deﬁnition 2. An argument (cid:3)(cid:2), α(cid:4) is more conservative than an argument (cid:3)(cid:8), β(cid:4) iff (cid:2) ⊆ (cid:8) and β (cid:5) α.

Example 2. (cid:3){α}, α ∨ β(cid:4) is more conservative than (cid:3){α, α → β}, β(cid:4).

Deﬁnition 3. An argument (cid:3)(cid:2), α(cid:4) is strictly more conservative than an argument (cid:3)(cid:8), β(cid:4) iff (cid:2) ⊆ (cid:8), β (cid:5) α, and either (cid:8) (cid:7)⊆ (cid:2)
or α (cid:7)(cid:5) β.

Some arguments directly oppose the support of others, which amounts to the notion of an undercut.

Deﬁnition 4. An undercut for an argument (cid:3)(cid:2), α(cid:4) is an argument (cid:3)(cid:8), ¬(φ1 ∧ · · · ∧ φn)(cid:4) where {φ1, . . . , φn} ⊆ (cid:2).

1408

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

Example 3. Let (cid:4) = {α, α → β, γ , γ → ¬α}. Then, (cid:3){γ , γ → ¬α}, ¬(α ∧ (α → β))(cid:4) is an undercut for (cid:3){α, α → β}, β(cid:4). A less
conservative undercut for (cid:3){α, α → β}, β(cid:4) is (cid:3){γ , γ → ¬α}, ¬α(cid:4).

Deﬁnition 5. (cid:3)(cid:8), β(cid:4) is a maximally conservative undercut for (cid:3)(cid:2), α(cid:4) iff (cid:3)(cid:8), β(cid:4) is an undercut for (cid:3)(cid:2), α(cid:4) such that no
undercuts of (cid:3)(cid:2), α(cid:4) are strictly more conservative than (cid:3)(cid:8), β(cid:4).

The value of the following deﬁnition of canonical undercut is that we only need to take the canonical undercuts into

account. This means we can justiﬁably ignore the potentially very large number of non-canonical undercuts.

Deﬁnition 6. An argument (cid:3)(cid:8), ¬(φ1 ∧ · · · ∧ φn)(cid:4) is a canonical undercut for (cid:3)(cid:2), α(cid:4) iff it is a maximally conservative undercut
for (cid:3)(cid:2), α(cid:4) and (cid:3)φ1, . . . , φn(cid:4) is the canonical enumeration of (cid:2).

The next result is central.

Proposition 2. (See Theorem 5.4 [7].) A pair (cid:3)(cid:8), ¬(φ1 ∧ · · · ∧ φn)(cid:4) is a canonical undercut for (cid:3)(cid:2), α(cid:4) iff it is an undercut for (cid:3)(cid:2), α(cid:4)
and (cid:3)φ1, . . . , φn(cid:4) is the canonical enumeration of (cid:2).

In other words, the canonical undercuts for (cid:3)(cid:2), α(cid:4) are given by all arguments of the form (cid:3)(cid:8), ¬(φ1 ∧ · · · ∧ φn)(cid:4) where
(cid:3)φ1, . . . , φn(cid:4) is the canonical enumeration of (cid:2). Later we need to refer to all possible supports of canonical undercuts for an
argument. We thus introduce the following concept.

Deﬁnition 7. For (cid:3)(cid:2), α(cid:4), we deﬁne UndercutSupports((cid:3)(cid:2), α(cid:4)) as the set of its supports:

(cid:4)

(cid:5)
(cid:8) | (cid:3)(cid:8), β(cid:4) is a canonical undercut for (cid:3)(cid:2), α(cid:4)

.

We shall make use of the notation UndercutSupports((cid:3)(cid:2), α(cid:4)) later when deﬁning suitable representations of argument

trees. Using Proposition 2, we can alternatively characterise the set UndercutSupports((cid:3)(cid:2), α(cid:4)) as follows.

Proposition 3. For (cid:3)(cid:2), α(cid:4), with (cid:3)φ1, . . . , φn(cid:4) the canonical enumeration of (cid:2),
(cid:4)

(cid:6)

(cid:7)
(cid:3)(cid:2), α(cid:4)

=

(cid:8) |

(cid:3)
(cid:2)
(cid:8), ¬(φ1 ∧ · · · ∧ φn)

UndercutSupports

is an argument

(cid:5)

.

Next we recall the notion of an argument tree following [7], and then introduce a more succinct notion to represent

argument trees which is also more suitable for our later purposes.

An argument tree describes the various ways an argument can be challenged, as well as how the counter-arguments to

the initial argument can themselves be challenged, and so on recursively.

Deﬁnition 8. An annotated tree is a tree where each node is a pair (cid:3)(cid:2), β(cid:4). An argument tree for α is an annotated tree,
such that

1. each node is an argument with the root being an argument for α;
2. for no node (cid:3)(cid:2), β(cid:4) with ancestor nodes (cid:3)(cid:2)1, β1(cid:4), . . . , (cid:3)(cid:2)n, βn(cid:4) is (cid:2) a subset of (cid:2)1 ∪ · · · ∪ (cid:2)n;
3. the children nodes of a node N consist of some canonical undercuts for N that obey 2.

A complete argument tree is as just deﬁned with “some” replaced by “all” in item 3 above.

The deﬁnition of an argument tree ensures that each argument on a branch has to introduce at least one formula in
its support that has not already been used by ancestor arguments. This is meant to avoid making explicit undercuts that
simply repeat over and over the same reasoning pattern except for switching the role of some formulae (as illustrated in
Example 5 below).

As a notational convenience, in examples of argument trees the (cid:2) symbol is used to denote the consequent of an

argument when that argument is a canonical undercut (no ambiguity arises as proven in [7]).

Example 4. Given (cid:4) = {α, α → β, γ , γ → ¬α, ¬γ ∨ ¬α}, we have the following argument tree.

(cid:2)
{α, α → β}, β

(cid:3)

(cid:6)
(cid:2)
{γ , γ → ¬α}, ¬

(cid:7)(cid:3)

α ∧ (α → β)

(cid:16)

(cid:17)
(cid:6)
(cid:2)
{γ , ¬γ ∨ ¬α}, ¬

(cid:7)(cid:3)

α ∧ (α → β)

Note the two undercuts are equivalent. They do count as two arguments because they are based on two different items of
the database (even though these items turn out to be logically equivalent).

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

1409

Example 5. Let (cid:4) = {α, α → β, γ → ¬α, γ }.
(cid:3)

(cid:2)

{α, α → β}, β
↑

(cid:2)

(cid:2)

(cid:3)
{γ , γ → ¬α}, (cid:2)
↑

(cid:3)
{α, γ → ¬α}, (cid:2)

This is not an argument tree because the undercut to the undercut is actually making exactly the same point (that α and
γ are incompatible) as the undercut itself does, just by using modus tollens instead of modus ponens.

Example 6. Given (cid:4) = {α, β, α → γ , β → δ, ¬α ∨ ¬β}, consider the following tree.

(cid:2)
{α, β, α → γ , β → δ}, γ ∧ δ

(cid:3)

(cid:2)
{α, ¬α ∨ ¬β}, ¬β

(cid:3)

(cid:16)

(cid:17)
(cid:2)

{β, ¬α ∨ ¬β}, ¬α

(cid:3)

This is not an argument tree because the two children nodes are not maximally conservative undercuts. The ﬁrst undercut
is essentially the same argument as the second undercut in a rearranged form (relying on α and β being incompatible,
assume one and then conclude that the other doesn’t hold). If we replace these by the maximally conservative undercut
(cid:3){¬α ∨ ¬β}, (cid:2)(cid:4), we obtain an argument tree.

Notably, there is a ﬁnite number of argument trees with the root being an argument with the claim α that can be

formed from (cid:4), and each of these trees has ﬁnite branching and a ﬁnite depth (the ﬁnite tree property).

For our purposes in this paper, we require a more formal representation of argument trees. It makes use of the fact that
all consequences in the nodes (except the root) of an argument tree are determined by their direct ancestor (as already
mentioned above when introducing (cid:2)). To this end, a node is now a set of formulae rather than an argument, and a parent
function determines the structure of the tree.

Deﬁnition 9. A parent function p (over k (cid:2) 1) is a partial function from {1..k} to {1..k}, such that p( j) is undeﬁned for
j = 1 but p( j) is deﬁned and p( j) < j, for any 1 < j (cid:3) k.

p is a parent function for a sequence A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) of subsets of (cid:4) if p is a parent function over k and is such that

p(i) = p( j) implies (cid:2)i (cid:7)= (cid:2) j , for any 1 < j < i (cid:3) k.

A tuple form is a triple (cid:3)α, A, p(cid:4), where α is a formula, A is a sequence of subsets of (cid:4), and p is a parent function

for A.

Given a tuple form (cid:3)α, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4), we deﬁne, for each 1 (cid:3) i (cid:3) k, an associated pair, A(i), as follows A(1) = (cid:3)(cid:2)1, α(cid:4)

and, for i > 1, A(i) = (cid:3)(cid:2)i, ¬(φ1 ∧ · · · ∧ φn)(cid:4), where (cid:3)φ1, . . . , φn(cid:4) is the canonical enumeration of (cid:2)p(i).

Tuple forms are an alternative way to denote annotated trees. Intuitively, A collects all supports of the tree’s nodes, α is
the claim of the root node, and the parent function p links each node to its parent node, and thus determines the structure
of the tree. This is feasible, since p is deﬁned for each node except the root and links to a previous element in A; the
condition that p(i) = p( j) implies (cid:2)i (cid:7)= (cid:2) j , for i (cid:7)= j just avoids duplicate children nodes.

The concept of tuple forms is best illustrated by examples.

Example 7. First, consider the tree from Example 4. That annotated tree can be represented in tuple form (cid:3)β, (cid:3)(cid:2)1, (cid:2)2, (cid:2)3(cid:4), p(cid:4)
where (cid:2)1 = {α, α → β}, (cid:2)2 = {γ , γ → ¬α}, (cid:2)3 = {γ , ¬γ ∨ ¬α}, and p is deﬁned as p(2) = p(3) = 1. An alternative way
to represent the same annotated tree would be to exchange the sets for (cid:2)2 and (cid:2)3.

Conversely, given the tuple form (cid:3)β, (cid:3)(cid:2)1, (cid:2)2, (cid:2)3(cid:4), p(cid:4), we can derive from it an annotated tree as follows: The nodes are

given by A(1), A(2), A(3), and we get by deﬁnition of p that A(2) and A(3) are the children of the root node A(1).

Example 8. As a second example, consider Example 5. The only way to achieve a tuple form for that
tree is
(cid:3)β, (cid:3)(cid:2)1, (cid:2)2, (cid:2)3(cid:4), p(cid:4) where (cid:2)1 = {α, α → β}, (cid:2)2 = {γ , γ → ¬α}, (cid:2)3 = {α, γ → ¬α}, and p is deﬁned as p(2) = 1, p(3) = 2.

We now formally describe these relations.

Deﬁnition 10. We deﬁne a mapping TreeForm from tuple forms to graphs as follows: For each t = (cid:3)α, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4), the
nodes of TreeForm(t) are given by the set { A(i) | 1 (cid:3) i (cid:3) k}; and a pair ( A(i), A( j)) is an edge of TreeForm(t) iff p( j) = i, for
1 < j (cid:3) k.

1410

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

Lemma 1. For any tuple form t, TreeForm(t) is an annotated tree.

Proof. TreeForm(t) is a tree because it is a graph which is connected (ignoring direction of edges) and has exactly one edge
less than it has vertices:

By Deﬁnition 10, ( A(i), A( j)) is an edge iff p( j) = i (for 1 < j (cid:3) k). I.e., ( A(p( j)), A( j)) for j = 1..k exhausts all edges.
Since p is a parent function, TreeForm(t) has k − 1 edges. There remains to show that TreeForm(t) is connected (when
directions of edges are ignored). This easily follows from the fact that any node in TreeForm(t) is connected to A(1) (the
latter is true because if 1 < j (cid:3) k, then there exists n such that pn( j) = 1 as p is a parent function). In short, TreeForm(t) is a
tree. It is an annotated tree because Deﬁnition 10 trivially shows that all nodes in TreeForm(t) are pairs A(i) for i = 1..k. (cid:3)

In view of the above lemma, we call, for a given tuple form t, TreeForm(t) the tree associated to t. As well, we say that

t represents tree TreeForm(t).

We now characterise argument trees and complete argument trees via tuple forms. This result is valuable later when

characterising argument trees via QBFs. We need one more technical notation.

Deﬁnition 11. Given a tuple form (cid:3)α, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4), we deﬁne, for each 1 (cid:3) i (cid:3) k, p
ancestors, i.e.,
(i) =

pn(i) | there exists m (cid:2) n (cid:2) 1 such that pm(i) = 1

(cid:4)

(cid:5)

p

∗

.

∗(i) as the set of indices of (cid:2)i ’s

Lemma 2. A tuple form (cid:3)α, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4) represents

• an argument tree iff

(1) (cid:3)(cid:2)1, α(cid:4) is an argument,
(2) for each 1 < i (cid:3) k, (cid:2)i (cid:7)⊆
(3) for each 1 < i (cid:3) k, (cid:2)i ∈ UndercutSupports( A(p(i))) hold;

j∈p∗(i) (cid:2) j , and

(cid:8)

• a complete argument tree iff, (1)–(3) hold together with

(4) for each 1 (cid:3) i (cid:3) k and for each (cid:8) ∈ UndercutSupports( A(i)), there exists an index j ∈ {1..k}, such that (cid:2) j = (cid:8) and p( j) = i.

Proof. The ﬁrst statement in Lemma 2 means that TreeForm(t) is an argument tree iff (1)–(3) hold together. Let us ﬁrst
assume that TreeForm(t) is an argument tree. Then, (1) and (2) are easily veriﬁed. By item 3 in Deﬁnition 8, the children of
a node N are canonical undercuts for N. So, if N is (cid:3)(cid:2), β(cid:4), any child of N is a canonical undercut A(i) = (cid:3)(cid:2)i, ¬(φ1 ∧ · · · ∧ φn)(cid:4)
of N = A(p(i)). Then, Deﬁnition 7 directly yields (cid:2)i ∈ UndercutSupports( A(p(i))). That is, (3) holds as well.

As to the other direction, let us assume that (1)–(3) hold. By (3) and item 4 in Deﬁnition 9, Deﬁnition 7 means that
A(i) is an argument for 1 < i (cid:3) k. Due to (1), it follows that item 1 in Deﬁnition 8 is veriﬁed. It is easy to verify that (2)
implies item 2 in Deﬁnition 8. Lastly, (3) and item 4 in Deﬁnition 9 entail (cf Deﬁnition 7) that for 1 < i (cid:3) k, each A(i) is a
canonical undercut of A(p(i)). I.e., item 3 in Deﬁnition 8 holds.

Let us assume (1)–(4). Let us further assume that TreeForm(t) is not a complete argument tree. In view of Deﬁnition 8,
this can only happen due to a node N = A(p(i)) lacking at least one canonical undercut as a child (TreeForm(t) is an
argument tree, as proved above). By Deﬁnition 7, there then exists (cid:8) in UndercutSupports( A( j)), for some j, satisfying
(cid:8) = (cid:2)i for no i such that p(i) = j. This contradicts (4). So, the if direction is proved. Proof of the only if direction is easy
and is omitted. (cid:3)

(cid:8)

∗(3) = {1, 2} and
j∈p∗(3) (cid:2) j = (cid:2)1 ∪ (cid:2)2 = {α, γ , γ → ¬α}. Since (cid:2)3 = {α, γ → ¬α} is a subset of that set, condition (2) in Lemma 2 is

Example 9. Consider again the tuple form for the tree in Example 5, as given in Example 8. We have p
thus
violated. Thus, we have that the tuple form does not represent an argument tree.

Lemma 3. Each argument tree is represented by a tuple form.

Proof. Consider an argument tree T with nodes N1, . . . , Nk, where nodes are of the form Ni = ((cid:2)i, αi), for each 1 (cid:3) i (cid:3) k,
and N1 is the root of T . Consider tT = (cid:3)α1, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4) where p is a partial function {1..k} to {1..k} satisfying, for each
1 (cid:3) j < k, p( j) = i iff N j is a children node of Ni in T . Since T is an argument tree, p is in fact a parent function over k.
Thus tT is a tuple form and one can show that TreeForm(t T ) = T , which holds by the observation that the pairs associated
to tT satisfy A(i) = Ni , for each 1 (cid:3) i (cid:3) k. (cid:3)

2.2. Quantiﬁed Boolean formulae

Quantiﬁed Boolean formulae (QBFs) generalize ordinary propositional formulae by the admission of quantiﬁcations over
propositional variables. In particular, the language of QBFs contains, for any atom p, unary operators of the form ∀p and ∃p,
called universal and existential quantiﬁers, respectively. However, the quantiﬁers do not range over some arbitrary domain,

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

1411

but over truth assignments. Thus, a QBF of form ∀p ∃q F is satisﬁable iff, for all truth assignments of p, there is a truth
assignment of q such that F is satisﬁable; see also Example 10 below.

An occurrence of a propositional variable p in a QBF F is free iff it does not appear in the scope of a quantiﬁer Qp
(Q ∈ {∀, ∃}), otherwise the occurrence of p is bound. If F contains no free variable occurrences, then F is closed, otherwise
F is open. Furthermore, we write F [p/φ] to denote the result of uniformly substituting each free occurrence of the variable
p in F by a φ. For a set P = {p1, . . . , pn} of propositional variables, we let ∀P F stand for the formula ∀p1∀p2 · · · ∀pn, and
∃P F for the formula ∃p1∃p2 · · · ∃pn.

By an interpretation, I , we mean a set of atoms. Informally, an atom p is true under I iff p ∈ I . In general, the truth value,

νI (F ), of a QBF F under an interpretation I is recursively deﬁned as follows:

1. if F = (cid:21), then νI (F ) = 1;
2. if F = p is an atom, then νI (F ) = 1 if p ∈ I , and νI (F ) = 0 otherwise;
3. if F = ¬G, then νI (F ) = 1 − νI (G);
4. if F = (F 1 ∧ F 2), then νI (F ) = min({νI (F 1), νI (F 2)});
5. if F = ∀p G, then νI (F ) = νI (G[p/(cid:21)] ∧ G[p/⊥]);
6. if F = ∃p G, then νI (F ) = νI (G[p/(cid:21)] ∨ G[p/⊥]).

The truth conditions for ⊥, ∨, →, and ↔ follow from the above in the usual way. We say that F is true under I iff νI (F ) = 1,
otherwise F is false under I. If νI (F ) = 1, then I is a model of F . If F has some model, then F is said to be satisﬁable. If F
is true under any interpretation, then F is valid. Observe that a closed QBF is either valid or unsatisﬁable, because closed
QBFs are either true under each interpretation or false under each interpretation. Hence, for closed QBFs, there is no need
to refer to particular interpretations. Therefore, closed QBFs are simply either true or false. Two QBFs are logically equivalent
iff they possess the same models.

Example 10. Consider the QBF F 1 = ∀q(p ↔ q). In this QBF, the propositional variable p if free, while q is bound. To evaluate
the QBF, we thus consider two interpretations: I1 = ∅ setting p to false; and I2 = {p} setting p to true.

In general, given an interpretation I , we can evaluate a QBF with respect to I in two ways: (i) ﬁrst evaluate the free
variables according to I and then apply the semantics for the now closed QBF; (ii) ﬁrst apply the semantics for quantiﬁers
and then evaluate the now quantiﬁer-free formula using I .

So, in our example (i) is as follows: For I1, we get ∀q(⊥ ↔ q), i.e., ∀q(¬q); and for I2, we get ∀q((cid:21) ↔ q), i.e., ∀q(q).
Both closed QBFs are false, thus neither I1 nor I2 is a model of F 1. Following attempt (ii), we ﬁrst treat the universal
quantiﬁcation for q according to the semantics and get (p ↔ (cid:21)) ∧ (p ↔ ⊥) which is equivalent to p ∧ ¬p. Clearly, neither
I1 nor I2 is a model of this propositional formula. Hence, neither I1 nor I2 is a model of F 1. Observe that we thus can also
state that the closed QBF
∃p∀q(p ↔ q)

is false.

Now consider the QBF F 2 = ∃q(p ↔ q). As before, interpretations I1 and I2 are of interest. According to (ii), F 2 reduces
to (p ↔ (cid:21)) ∨ (p ↔ ⊥) which is equivalent to p ∨ ¬p. Now both, I1 and I2 are models of that formula and thus of F 2. This
leads us to the further observation that the closed QBF

∀p∃q(p ↔ q)

is true.

QBFs allow us to talk about semantical concepts in propositional logic. For instance, a propositional formula F over
propositional variables V is satisﬁable iff the closed QBF ∃V (F ) is true. Likewise, F is valid iff the closed QBF ∀V (F ) is true.
Consequently, given a knowledge-base (cid:4) and a formula, both over V , (cid:4) (cid:5) α holds iff the QBF ∀V (

(cid:9)

δ∈(cid:4) δ → α) is true.

Example 11. Consider (cid:4) = {p, p → q} and let α = q. We have V = {p, q} and thus consider the closed QBF

(cid:6)(cid:6)

(cid:7)
p ∧ (p → q)

(cid:7)

→ q

.

∀p∀q

Observe that the inner part of that QBF, i.e., the propositional formula (p ∧ (p → q)) → q is valid, and thus true under all
assignments. Hence, the above QBF is true.

In the same way as the satisﬁability problem of classical propositional logic is the “prototypical” problem of NP, i.e.,
being an NP-complete problem, the satisﬁability problem of QBFs in prenex form are the “prototypical” problems of the k-th
level of the polynomial hierarchy.

Proposition 4. (See [35].) Given a propositional formula φ with its atoms partitioned into i (cid:2) 1 sets P 1, . . . , P i , deciding whether
Q1 P 1Q2 P 2 . . . Qi P iφ is true is (i) (cid:5) p

i -complete, if Q1 = ∃; (ii) (cid:12)p

i -complete, if Q1 = ∀.

1412

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

In fact, the hardness results in above proposition hold only for those QBFs where the quantiﬁers in the preﬁx

Q1 P 1Q2 P 2 . . . Qi P i are alternating, i.e., Q j (cid:7)= Q j+1 holds, for each 1 (cid:3) j < i. We call such QBFs also (Q1, i)-QBFs.

The complexity landscape can be extended to arbitrary closed QBFs if the maximal number of quantiﬁer alternations
along a path in the QBF’s formula tree is taken into account. In turn, an arbitrary QBF can be transformed into an equivalent
QBF in prenex form. This transformation is not deterministic and it is crucial for the performance of QBF solvers requiring
the input formula in this normal form (for details, see [20,21]).

Finally, we highlight the used reduction approach. Given a decision problem D, we aim at ﬁnding a translation scheme

TD into closed QBFs, such that

1. TD (·) is faithful, i.e., TD (K ) is true iff K is a yes-instance of D;
2. for each instance K , TD (K ) is computable in polynomial time with respect to the size of K ; and
3. determining the truth of the QBFs resulting from TD (·) is not computationally harder (by means of Proposition 4) than

the computational complexity of D.

In addition, if we are interested in a search problem S we aim at establishing a certain one-to-one correspondence
between the models of the QBF encodings and the solutions to S. Indeed the transformation TD (·) then has to yield open
QBFs instead of closed QBFs. Given the models of the QBF TD (K ), the computation of the solutions of K has to be feasible
in polynomial time.

2.3. Basic concept of encodings

We now sketch our basic ideas for capturing logic-based argumentation in QBFs.

In the following, we assume a
knowledge-base (cid:4) to be given over a set of atoms V (cid:4). Moreover, α, β always refer to formulae, which are, without loss of
generalization, assumed to be given over atoms from V (cid:4). In general, for a set (cid:2) of formulae, the set V (cid:2) contains all atoms
occurring in (cid:2).

Given a ﬁnite knowledge-base (cid:4), we assign to each element of (cid:4) several new atoms via a generator function. The aim
of this function to provide new atoms, such that interpretations over those atoms are used to represent subsets of (cid:4). The
formal deﬁnition is as follows:

Deﬁnition 12. A generator function g maps each δ ∈ (cid:4) to a new propositional atom g(δ) /∈ V (cid:4), such that g(δ1) = g(δ2)
implies δ1 = δ2, for all δ1, δ2 ∈ (cid:4). With some abuse of notation we write, for any subset (cid:2) ⊆ (cid:4), g((cid:2)) to denote the set
{g(δ) | δ ∈ (cid:2)}. Moreover, for two different generator functions g1, g2, we ensure g1((cid:4)) ∩ g2((cid:4)) = ∅, i.e., each generator
function provides its own fresh atoms.

Interpretations (usually given over arbitrary atoms) are linked to subsets of (cid:4) via generator functions as follows.

Deﬁnition 13. Let I be an interpretation, g be a generator function, and (cid:2) ⊆ (cid:4). We say that I represents (cid:2) via g iff
I ∩ g((cid:4)) = g((cid:2)). Moreover, for a sequence A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) of subsets of (cid:4) and a corresponding sequence G = (cid:3)g1, . . . , gk(cid:4)
of different generator functions, we say that an interpretation I represents A via G iff I ∩ gi((cid:4)) = gi((cid:2)i), holds for all
1 (cid:3) i (cid:3) k.

A word of caution is in order here: When I represents (cid:2) via some g, I may, but need not, be a model of (cid:2). The

forthcoming Deﬁnition 14 and Lemma 4 provide the missing link.

Deﬁnition 14. For (cid:13) ⊆ (cid:4), a formula α, and a generator function g, deﬁne

(cid:13) ⇒g α = ∀V (cid:13)∪{α}

(cid:10)(cid:10) (cid:11)

(cid:6)

(cid:12)

(cid:7)

(cid:12)

→ α

.

g(δ) → δ

δ∈(cid:13)

Lemma 4. Let (cid:4) be a knowledge base, and I be an interpretation. For (cid:13) ⊆ (cid:4), and (cid:2) ⊆ (cid:13), such that I represents (cid:2) via generator
function g, then, for all α, we have that, (cid:13) ⇒g α is true under I iff (cid:2) (cid:5) α.

Proof. We have that (cid:2) (cid:5) α iff each model over atoms V (cid:2)∪{α} of (cid:2) is also a model of α. By the semantics of QBFs, it is
easily veriﬁed that the latter holds iff the closed QBF

(cid:10)(cid:10) (cid:11)

(cid:12)

(cid:12)

δ

→ α

∀V (cid:2)∪{α}

δ∈(cid:2)

(1)

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

1413

is true. (Recall that a closed QBF is either true under any interpretation I or false under any interpretation I .) We next
increase the set of quantiﬁed variables in (1) from V (cid:2)∪{α} to V (cid:13)∪{α}, which yields

(cid:10)(cid:10) (cid:11)

(cid:12)

(cid:12)

∀V (cid:13)∪{α}

δ

→ α

.

(2)

δ∈(cid:2)

This QBF is also closed since (cid:2) ⊆ (cid:13) and it holds that (2) is true iff (1) is true, since the added quantiﬁed variables do not
have any inﬂuence here.

Next, we replace each δ by the equivalent formula (cid:21) → δ, and add trivially true conjuncts of the form ⊥ → γ , yielding1
(cid:14)

(cid:12)(cid:12)

(cid:12)

(cid:13)(cid:10)(cid:10) (cid:11)

(cid:10) (cid:11)

∀V (cid:13)∪{α}

((cid:21) → δ)

∧

(⊥ → γ )

→ α

.

(3)

δ∈(cid:2)

γ ∈(cid:13)\(cid:2)

So far, this shows that (cid:2) (cid:5) α iff the closed QBF (3) is true. Now, let g be a generator function, and consider any inter-
pretation I which represents (cid:2) via g. Hence, for each δ ∈ (cid:2), g(δ) ∈ I , and for each γ ∈ (cid:13) \ (cid:2), g(γ ) /∈ I holds. Recall that
g((cid:4)) ∩ V (cid:4) = ∅, and thus by our assumptions g((cid:4)) ∩ V (cid:13)∪{α} = ∅. We therefore can rewrite (3) to
(cid:6)

(cid:13)(cid:10)(cid:10) (cid:11)

(cid:10) (cid:11)

(cid:12)(cid:12)
(cid:7)

(cid:12)

(cid:14)

(cid:6)

(cid:7)

g(δ) → δ

∧

g(γ ) → γ

→ α

.

(4)

∀V (cid:13)∪{α}

δ∈(cid:2)

γ ∈(cid:13)\(cid:2)

Observe that the atoms g(·) are free in (4) and thus are subject to interpretations. In fact, by the deﬁnition of a representa-
tion (cf. Deﬁnition 13), it is easy to see that (4) is true under any I which represents (cid:2) via g iff (3) is true. To conclude the
proof, observe (4) is equivalent to (cid:13) ⇒g α. (cid:3)

(cid:15)(cid:6)

Example 12. Let (cid:4) = {p, p → q}, α = q, and let us consider g((cid:4)) = {g p, g p→q}. Hence, the generator function provides for
each δ ∈ (cid:4) a new variable of the form g(δ) = gδ . Then, (cid:4) ⇒g α is given by
g p→q → (p → q)

(5)
Note that, for each (cid:2) ⊆ (cid:4), we thus have interpretations representing (cid:2) via g. Since g((cid:4)) are the only free variables in
(cid:4) ⇒g α it is thus suﬃcient to investigate the following four interpretations for being models of (cid:4) ⇒g α:

(g p → p) ∧

∀p∀q

→ q

(cid:7)(cid:7)

(cid:6)

(cid:16)

.

I1 = ∅
I2 = {g p}
I3 = {g p→q}
I4 = {g p, g p→q}.

Let us now evaluate (5) under these four interpretation. We shall do so by ﬁrst evaluating the free variables in (5) and
then inspect the remaining QBF, i.e., following method (ii) as sketched in Example 10. We start with I1. Then (5) reduces to
closed QBF
∀p∀q

⊥ → (p → q)

(⊥ → p) ∧

→ q

(cid:7)(cid:7)

(cid:15)(cid:6)

(cid:6)

(cid:16)

which is equivalent to
∀p∀q[q].

This QBF is obviously false, and hence, I1 is not a model of (5).

For I2 one of the conjuncts in the antecedent survives. We get
⊥ → (p → q)

((cid:21) → p) ∧

∀p∀q

→ q

(cid:7)(cid:7)

(cid:15)(cid:6)

(cid:6)

(cid:16)

which is equivalent to
∀p∀q[p → q].

Still, this QBF is false, and hence, also I2 is not a model of (5).

For I3, we get
∀p∀q

(cid:15)(cid:6)

(⊥ → p) ∧

(cid:6)

(cid:21) → (p → q)

(cid:7)(cid:7)

(cid:16)

→ q

which is equivalent to

(cid:15)
(p → q) → q

(cid:16)
.

∀p∀q

1 This can be done since the replacement theorem holds for QBFs.

1414

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

Again, this QBF is false, and hence, also I3 is not a model of (5).

Finally, evaluating (5) under I4 yields

(cid:15)(cid:6)

(cid:6)

∀p∀q

((cid:21) → p) ∧

(cid:21) → (p → q)

(cid:7)(cid:7)

(cid:16)

→ q

which is equivalent to

(cid:15)(cid:6)

(cid:7)
p ∧ (p → q)

(cid:16)

.

→ q

∀p∀q

This QBF is true since the inner part (p ∧ (p → q)) → q is indeed a valid formula of propositional logic. Therefore, I4 is a
model of (5).

So having I4 as the only model, we conclude that the set it represents via g, namely {p, p → q}, is the only subset (cid:2) of

(cid:4), for which (cid:2) (cid:5) α holds.

QBFs abbreviated by (cid:13) ⇒g α will be used as subformulae in various more complex QBF formulae. In a sense, they are

useful building blocks that can be used repeatedly. We will refer to a schema like (cid:13) ⇒g α as a module.

3. Characterisations

In what follows, we will employ the basic encoding (cid:13) ⇒g α to characterise various problems for logic-based argumenta-
tion. We start by characterising arguments and undercuts via models of certain QBFs. Then, we suitably combine the latter
in such a way that the resulting formulae will allow us to reason about argument trees. We will ﬁrst consider argument
trees of a ﬁxed structure (i.e., where the parent function is given when constructing the encodings) and then also provide
encodings, where the parent function is characterised by the QBF itself.

3.1. Arguments and undercuts

Deﬁnition 15. For a knowledge base (cid:4), a formula α, and a generator function g, deﬁne

arg(g, (cid:4), α) = ¬ ((cid:4) ⇒g ⊥) ∧ ((cid:4) ⇒g α) ∧

(cid:11)

(cid:6)

g(δ) → ¬

(cid:6)(cid:6)

(cid:4) \ {δ}

(cid:7)

(cid:7)(cid:7)

.

⇒g α

δ∈(cid:4)

Note that the three main parts of the encoding check properties (2), (3), and respectively (4

(cid:9)) from Proposition 1.

Theorem 1. For a knowledge base (cid:4), a formula α, an interpretation I , and (cid:2) ⊆ (cid:4), such that I represents (cid:2) via generator function g,
we have that arg(g, (cid:4), α) is true under I iff ((cid:2), α) is an argument.

Proof. Using Lemma 4, we immediately conclude that the ﬁrst two conjuncts of arg(g, (cid:4), α) are true in I iff conditions (2)
and (3) from Proposition 1 hold. So, there only remains to take care of the third conjunct in arg(g, (cid:4), α), i.e.:

(cid:11)

(cid:6)

g(δ) → ¬

(cid:6)(cid:6)

(cid:4) \ {δ}

(cid:7)

(cid:7)(cid:7)

.

⇒g α

δ∈(cid:4)

However, all of the following ﬁve statements are equivalent:

(i)

I |(cid:26)

(cid:11)

(cid:6)

g(δ) → ¬

(cid:6)(cid:6)

(cid:7)

(cid:4) \ {δ}

⇒g α

(cid:7)(cid:7)

δ∈(cid:4)
(cid:11)

(cid:6)(cid:6)

¬

(cid:4) \ {δ}

(cid:7)

(cid:7)

⇒g α

(ii)

I |(cid:26)

δ∈(cid:2)
(cid:6)(cid:6)

I |(cid:26) ¬

(cid:7)

(cid:4) \ {δ}

(iii)

(iv)

I |(cid:26) ¬ ∀V ((cid:4)\{δ})∪{α}

(v)

I |(cid:26) ¬ ∀V ((cid:4)\{δ})∪{α}

(cid:7)

⇒g α

(cid:10)(cid:10) (cid:11)

for all δ ∈ (cid:2)
(cid:6)

g(σ ) → σ

(cid:12)

(cid:7)

(cid:12)

→ α

for all δ ∈ (cid:2)

σ ∈((cid:4)\{δ})

(cid:17)(cid:11)(cid:6)

(cid:7)

(cid:18)

→ α

for all δ ∈ (cid:2)

(cid:2) \ {δ}

where the ﬁrst and last steps are correct because I represents (cid:2) via g.

(cid:9)

Since ((cid:2) \ {δ}) ⊆ ((cid:4) \ {δ}), all propositional symbols in

((cid:2) \ {δ}) → α are quantiﬁed upon through ∀V ((cid:4)\{δ})∪{α}. Hence,
(cid:9))
((cid:2) \ {δ}) → α is invalid in propositional logic, or, equivalently, iff (cid:2) \ {δ} (cid:7)(cid:5) α. In other words, condition (4

(cid:9)

(v) holds iff
from Proposition 1 is satisﬁed iff (v) holds, i.e., iff (i) holds. (cid:3)

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

1415

We now consider the following example in order to compare the functioning of the third condition of Deﬁnition 15 with

a simpler alternative that, whilst plausible, does not behave as required. In fact, consider one replaces

(cid:11)

(cid:6)

g(δ) → ¬

(cid:6)(cid:6)

(cid:7)

(cid:4) \ {δ}

⇒g α

(cid:7)(cid:7)

in arg(g, (cid:4), α) by ¬

(cid:6)(cid:6)

(cid:4) \ {δ}

(cid:7)

(cid:7)

.

⇒g α

δ∈(cid:4)

We observe the following problem.

Example 13. Let (cid:4) = {p, q}, let α be p, and let g((cid:4)) = {g p, gq}. So the original version of the third condition in Deﬁnition 15
gives the following

(cid:6)

(cid:6)

(cid:7)(cid:7)

(cid:6)

g p → ¬∀p∀q

(gq → q) → p

∧

gq → ¬∀p∀q

(cid:6)
(g p → p) → p

(cid:7)(cid:7)

.

We evaluate this with the following interpretations getting the answers we expect for the QBF in each case.

I1 = ∅
I2 = {g p}
I3 = {gq}
I4 = {g p, gq}

therefore the QBF is true
therefore the QBF is true
therefore the QBF is true
therefore the QBF is false.

Now consider the alternative (incorrect) version of the deﬁnition which gives the following

(cid:6)

(cid:6)

(cid:7)(cid:7)

(cid:6)

(cid:6)

¬∀p∀q

(gq → q) → p

∧

¬∀p∀q

(g p → p) → p

(cid:7)(cid:7)

.

We evaluate this with the following interpretations which shows that we fail to get answer we expect for the QBF with I2.

I1 = ∅
I2 = {g p}
I3 = {gq}
I4 = {g p, gq}

therefore the QBF is true
therefore the QBF is false
therefore the QBF is true
therefore the QBF is false.

With the encoding from Deﬁnition 15 at hand, we can decide a number of typical decision problems, e.g., question
whether given (cid:3)(cid:2), α(cid:4), is (cid:3)(cid:2), α(cid:4) an argument? A more general variant of this question is as follows: Given (cid:4) and disjoint
of (cid:4), does there exist an argument (cid:3)(cid:2), α(cid:4), such that (cid:4)+ ⊆ (cid:2) and (cid:2) ∩ (cid:4)− = ∅?
subsets (cid:4)+

and (cid:4)−

Deﬁnition 16. Let g be a generator function and (cid:4)+, (cid:4)− ⊆ (cid:4). Then, we deﬁne as an abbreviation

ﬁx(g, (cid:4)

+

, (cid:4)

−

) =

g(δ) ∧

¬g(δ).

(cid:11)

(cid:11)

δ∈(cid:4)+

δ∈(cid:4)−

and (cid:4)−

, a generator function g, and a formula α, there exists an argument (cid:3)(cid:2), α(cid:4) such

Corollary 1. Given (cid:4), two disjoint sets (cid:4)+
that (cid:4)+ ⊆ (cid:2) and (cid:2) ∩ (cid:4)− = ∅ iff

(cid:6)
∃g((cid:4))

ﬁx(g, (cid:4)

+

−

, (cid:4)

(cid:7)
) ∧ arg(g, (cid:4), α)

(6)

is true.

Obviously, by setting (cid:4)+ = (cid:2) and (cid:4)− = (cid:4) \ (cid:2) in (6), we can answer the question given (cid:3)(cid:2), α(cid:4), is (cid:3)(cid:2), α(cid:4) an argument?
In this setting, we shall also write ﬁx(g, (cid:2)) instead of ﬁx(g, (cid:4)+, (cid:4)−). Another question is whether a certain element δ ∈ (cid:4)
is part of a support for α. For this, we can set (cid:4)+ = {δ} and (cid:4)− = ∅ in (6). Finally, if we drop the ﬁx(g, (cid:4)+, (cid:4)−) conjunct,
i.e., we set (cid:4)+ = (cid:4)− = ∅ in (6), then our encoding is true iff there is a subset (cid:2) of (cid:4) such that (cid:3)(cid:2), α(cid:4) is an argument.

Next, we show how to use two different generator functions g1 and g2 to characterise subsets of (cid:4) simultaneously; in

fact, this module allows us to derive the supports of undercuts.

Deﬁnition 17. For a knowledge base (cid:4) and generator functions g1, g2, deﬁne
(cid:11)

(cid:10)

(cid:12)

(cid:6)

(cid:7)

suc(g1, g2, (cid:4)) = arg

g1, (cid:4), ¬

g2(δ) → δ

.

δ∈(cid:4)

Theorem 2. For a knowledge base (cid:4), an interpretation I , and (cid:2)1, (cid:2)2 ⊆ (cid:4), such that I represents (cid:3)(cid:2)1, (cid:2)2(cid:4) via generator functions
(cid:3)g1, g2(cid:4), we have that suc(g1, g2, (cid:4)) is true under I iff ((cid:2)1, ¬(φ1 ∧ · · · ∧ φn) is an argument, where (cid:3)φ1, . . . , φn(cid:4) is the canonical
enumeration of (cid:2)2.

1416

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

Proof. Since I represents (cid:2)2 via g2, it follows that, in I , g2(δ) → δ is equivalent with δ whenever δ ∈ (cid:2)2 and is equivalent
with (cid:21) whenever δ ∈ (cid:4) \ (cid:2)2. So, the next two statements are equivalent:

(cid:10)

(i)

I |(cid:26) arg

g1, (cid:4), ¬

(cid:17)

(ii)

I |(cid:26) arg

g1, (cid:4), ¬

(cid:12)
(cid:7)

(cid:11)

(cid:6)

δ∈(cid:4)
(cid:11)

g2(δ) → δ
(cid:18)
.

(cid:2)2

Since I represents (cid:2)1 via g1, Theorem 1 yields that (ii) holds iff (cid:3)(cid:2)1, ¬
that suc(g1, g2, (cid:4)) is true in I , holds iff (cid:3)(cid:2)1, ¬

(cid:2)2(cid:4) is an argument. (cid:3)

(cid:9)

(cid:9)

(cid:2)2(cid:4) is an argument. Therefore, (i), which means

Corollary 2. For a knowledge base (cid:4), a formula α, an interpretation I , and (cid:2)1, (cid:2)2 ⊆ (cid:4), such that I represents (cid:3)(cid:2)1, (cid:2)2(cid:4) via (cid:3)g1, g2(cid:4),
we have that

arg(g2, (cid:4), α) ∧ suc(g1, g2, (cid:4))

is true under I iff (cid:3)(cid:2)2, α(cid:4) is an argument and (cid:2)1 ∈ UndercutSupports((cid:3)(cid:2)2, α(cid:4)).

3.2. Argument trees with ﬁxed structure

We now show how to characterise trees via their tuple form using QBFs. We start with encodings where the tree
structure is ﬁxed via a given parent function, but the nodes of the tuple form can be arbitrarily characterised by assignments
to the atoms from generator functions. In other words, given a parent function p over k and a formula α, we characterise all
sequences A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), such that (cid:3)α, A, p(cid:4) is a tuple form. We then reﬁne these encodings to obtain all such sequences
A, such that the tuple form (cid:3)α, A, p(cid:4) represents a (complete) argument tree. Note that in the forthcoming encodings, we
comes together with p as an input. The aim of the forthcoming module is to ensure that p correctly
also assume that p
applies to the sequence A, in such a way that p does not lead to duplicate children notes (as required in Deﬁnition 9).

∗

Deﬁnition 18. For a knowledge base (cid:4), a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), and a parent function p over k,
we deﬁne

distinct(G, (cid:4), p) =

(cid:11)

(cid:10) (cid:11)
¬

(cid:12)

gi(δ) ↔ g j(δ)

.

i, j: p(i)=p( j);i(cid:7)= j

δ∈(cid:4)

Lemma 5. For a knowledge base (cid:4), a parent function p over k, and an interpretation I representing A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G =
(cid:3)g1, . . . , gk(cid:4), we have that distinct(G, (cid:4), p) is true under I iff p is a parent function for A.

Proof. (Only if direction) If distinct(G, (cid:4), p) is true in I then for all two distinct i and j (each in the range 1..k) where
p(i) = p( j), there must exist δ(cid:9) ∈ (cid:4) such that gi(δ(cid:9)) ↔ g j(δ(cid:9)) is false in I . So, I |(cid:26) gi(δ(cid:9)) ∧ ¬g j(δ(cid:9)) or I |(cid:26) ¬gi(δ(cid:9)) ∧ g j(δ(cid:9)).
The cases are symmetric, so it is enough to consider the former: I |(cid:26) gi(δ(cid:9)) ∧ ¬g j(δ(cid:9)). Since gi(δ(cid:9)) and g j(δ(cid:9)) are atoms,
it then follows that gi(δ(cid:9)) ∈ I and g j(δ(cid:9)) /∈ I . Therefore, g j(δ(cid:9)) /∈ I ∩ g j((cid:4)) whereas gi(δ(cid:9)) ∈ I ∩ gi((cid:4)) (as gi(δ(cid:9)) ∈ gi((cid:4)) due
to δ(cid:9) ∈ (cid:4)). However, I represents A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G = (cid:3)g1, . . . , gk(cid:4) meaning that I ∩ gi((cid:4)) is gi((cid:2)i) and I ∩ g j((cid:4)) is
g j((cid:2)i) (Deﬁnition 13). Whence gi(δ(cid:9)) ∈ gi((cid:2)i) and g j(δ(cid:9)) /∈ g j((cid:2) j). I.e., gi(δ(cid:9)) ∈ {gi(δ) | δ ∈ (cid:2)i} and g j(δ(cid:9)) /∈ {g j(δ) | δ ∈ (cid:2) j}
(cf. Deﬁnition 12). As an immediate consequence, δ(cid:9) /∈ (cid:2) j . On the other hand, gi(δ(cid:9)) ∈ {gi(δ) | δ ∈ (cid:2)i} implies δ(cid:9) ∈ (cid:2)i because
gi is injective according to Deﬁnition 12. Now, δ(cid:9) /∈ (cid:2) j together with δ(cid:9) ∈ (cid:2)i yields (cid:2)i (cid:7)= (cid:2) j .

(If direction) We must show that distinct(G, (cid:4), p) is true in I . In fact, we show that, for any two distinct i and j
(each in the range 1..k) such that p(i) = p( j), then gi(δ(cid:9)) ↔ g j(δ(cid:9)) is false in I for some δ(cid:9) ∈ (cid:4). To start with, (cid:2)i (cid:7)= (cid:2) j
because p is a parent function for A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4). Trivially, there then exists δ(cid:9) ∈ (cid:4) such that either δ(cid:9) ∈ (cid:2)i and δ(cid:9) /∈ (cid:2) j
or δ(cid:9) /∈ (cid:2)i and δ(cid:9) ∈ (cid:2) j . The cases are symmetric, so it is enough to consider the former. From δ(cid:9) /∈ (cid:2) j , we easily get
g j(δ(cid:9)) /∈ {g j(δ) | δ ∈ (cid:2) j}, which, by Deﬁnition 12, means g j(δ(cid:9)) /∈ g j((cid:2) j). That is, g j(δ(cid:9)) /∈ I ∩ g j((cid:4)) because I represents
A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G = (cid:3)g1, . . . , gk(cid:4) (cf. Deﬁnition 13). In view of g j(δ(cid:9)) ∈ g j((cid:4)) (due to δ(cid:9) ∈ (cid:4)), it then follows that
g j(δ(cid:9)) /∈ I . On the other hand, δ(cid:9) ∈ (cid:2)i . So, gi(δ(cid:9)) ∈ {gi(δ) | δ ∈ (cid:2)i} = gi((cid:2)i). Then, gi(δ(cid:9)) ∈ I ∩ gi((cid:4)) because I represents
A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G = (cid:3)g1, . . . , gk(cid:4) (cf. Deﬁnition 13). So, gi(δ(cid:9)) ∈ I . Combined with g j(δ(cid:9)) /∈ I as proven above, this
yields I (cid:7)|(cid:26) gi(δ(cid:9)) ↔ g j(δ(cid:9)). (cid:3)

Given a parent function p, we now know how to characterise sequences A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via QBFs, such that, p is a
parent function for A. Thus, we can already obtain all tuple forms (cid:3)α, A, p(cid:4), for a given p. Next, we add further conditions
to get only those A, such that (cid:3)α, A, p(cid:4) represents also an argument tree.

Deﬁnition 19. For a knowledge base (cid:4), a formula α, a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), and a parent
function p over k, we deﬁne

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

1417

argtree(G, α, (cid:4), p) = arg(g1, (cid:4), α) ∧

k(cid:11)
(cid:6)

(cid:7)
suc(gi, g p(i), (cid:4))

∧

i=2
k(cid:11)

(cid:10)

(cid:19)

(cid:11)

(cid:12)

¬g j(δ)

.

gi(δ) ∧

i=2

δ∈(cid:4)

j∈p∗(i)

Theorem 3. For a knowledge base (cid:4), an interpretation I , and a tuple form (cid:3)α, A, p(cid:4), such that I represents A via generator functions G
we have that the QBF

distinct(G, (cid:4), p) ∧ argtree(G, α, (cid:4), p)

is true under I iff (cid:3)α, A, p(cid:4) represents an argument tree.

Proof. By Lemma 5 and the fact that (cid:3)α, A, p(cid:4) is a tuple form (see item 3 in Deﬁnition 9), distinct(G, (cid:4), p) is true under I .
So, we need only focus on argtree(G, α, (cid:4), p).

tree iff

Lemma 2 states that

represent an argument

(cid:3)α, A, p(cid:4)
is an argument, and (ii) (cid:2)i ∈
UndercutSupports( A(p(i))) for 1 < i (cid:3) k, and (iii) (cid:2)i (cid:7)⊆ (cid:2)p(i) ∪ (cid:2)p2(i)
∪ · · · ∪ (cid:2)pn(i)=1 for 1 < i (cid:3) k. We show that each of
(i)–(iii) holds iff the corresponding conjunct in argtree(G, α, (cid:4), p) is true under I . By Theorem 1, (i) holds iff arg(g1, (cid:4), α),
namely the ﬁrst conjunct in argtree(G, α, (cid:4), p), is true under I . Let us turn to (ii). In fact, (cid:2)i ∈ UndercutSupports( A(p(i)))
(cid:2)p(i)(cid:4) is an argument iff suc(gi, g p(i), (cid:4)),
means that (cid:3)(cid:2)i, ¬
namely the second conjunct in argtree(G, α, (cid:4), p), is true under I . Let us turn to (iii). Trivially, (cid:2)i (cid:7)⊆ (cid:2)p(i) ∪ (cid:2)p2(i)
∪ · · · ∪
(cid:2)pn(i)=1 means that there exists δ(cid:9) ∈ (cid:2)i such that δ(cid:9) /∈ (cid:2)p(i) ∪ (cid:2)p2(i)
∪ · · · ∪ (cid:2)pn(i)=1. Since I represents A via G, for all
∪ · · · ∪ (cid:2)pn(i)=1 iff for some δ(cid:9)
j = 1..k, Deﬁnition 13 tells us that g j(δ(cid:9)) is true under I iff δ(cid:9) ∈ (cid:2) j . Then, (cid:2)i (cid:7)⊆ (cid:2)p(i) ∪ (cid:2)p2(i)
,
gi(δ(cid:9)) is true under I while g p(i)(δ(cid:9)), g p2(i)(δ(cid:9)), . . . , g pn(i)=1(δ(cid:9)) are all false under I . So, (cid:2)i (cid:7)⊆ (cid:2)p(i) ∪ (cid:2)p2(i)
∪ · · · ∪ (cid:2)pn(i)=1 iff

(cid:2)p(i)(cid:4) is an undercut of (cid:3)(cid:2)p(i), . . .(cid:4). By Theorem 2, (cid:3)(cid:2)i, ¬

(cid:3)(cid:2)1, α(cid:4)

(cid:9)

(cid:9)

(i)

(cid:10)

(cid:19)

(cid:11)

gi(δ) ∧

¬g j(δ)

(cid:12)

δ∈(cid:4)

j∈p∗(i)

is true under I . (cid:3)

Our next deﬁnition captures the condition that for a sequence of generator functions G, and for each argument that
can be represented via a generator function gi in G, if there is an undercut for it that can be represented by a generator
function g, then g is also in G.

Deﬁnition 20. For a knowledge base (cid:4), a parent function p over k, a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), and
a further generator function g, we deﬁne

complete(G, (cid:4), p) =

(cid:10)

∀g((cid:4))

suc(g, gi, (cid:4)) →

k(cid:11)

i=1

(cid:19)

(cid:11)

(cid:6)

(cid:7)
g(δ) ↔ g j(δ)

(cid:12)

.

j:p( j)=i

δ∈(cid:4)

Theorem 4. For a knowledge base (cid:4), an interpretation I , and a tuple form (cid:3)α, A, p(cid:4), such that I represents A via generator functions
G we have that the QBF

distinct(G, (cid:4), p) ∧ argtree(G, α, (cid:4), p) ∧ complete(G, (cid:4), p)

is true under I iff (cid:3)α, A, p(cid:4) represents a complete argument tree.

Proof. By Theorem 2, suc(g, gi, (cid:4)) is true under I iff (cid:3)(cid:8), ¬
(cid:2)i(cid:4) is an argument ((cid:8) is taken to denote the set that g
represents under I ), or, equivalently, (cid:3)(cid:8), . . .(cid:4) is an undercut of (cid:3)(cid:2)i, . . .(cid:4). Since I represents A via G, Deﬁnition 13 means
that g j(δ) is true under I iff δ ∈ (cid:2) j . Therefore, g(δ) ↔ g j(δ) is true under I iff (cid:8) = (cid:2) j . So, complete(G, (cid:4), p) is true under
I iff for each 1 (cid:3) i (cid:3) k and for each (cid:8) ∈ UndercutSupports( A(i)), there exists an index j ∈ {1..k} such that (cid:2) j = (cid:8) and
p( j) = i. Then, apply Lemma 2 and Theorem 3. (cid:3)

(cid:9)

As already shown for single arguments, we can use now the ﬁx(g, (cid:2)) module to encode further decision problems. In
our ﬁrst example (given in Corollary 3), we can ensure that the argument tree has a particular argument as the root of the
tree.

1418

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

Corollary 3. For a knowledge base (cid:4), (cid:8) ⊆ (cid:4), an interpretation I , and a tuple form (cid:3)α, A, p(cid:4), such that I represents A via generator
functions G we have that the QBF

ﬁx(g1, (cid:8)) ∧ distinct(G, (cid:4), p) ∧ argtree(G, α, (cid:4), p)

is true under I iff (cid:3)α, A, p(cid:4) represents an argument tree with root ((cid:8), α).

As a further example, we can check whether a given tuple form (cid:3)α, A, p(cid:4) with A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via QBFs, represents an

argument tree. To this end let, G((cid:4)) =

(cid:8)
k
i=1 gi((cid:4)).

Corollary 4. A tuple form (cid:3)α, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4) represent an argument tree iff the closed QBF

(cid:21)

ﬁx(gi, (cid:2)i) ∧ distinct(G, (cid:4), p) ∧ argtree(G, α, (cid:4), p)

(cid:20)

k(cid:11)

i=1

∃G((cid:4))

is true.

Likewise, we can apply these two corollaries to complete argument trees by adding the conjunct complete(G, (cid:4), p)

accordingly.

3.3. Argument trees with arbitrary structure

Compared to the previous characterisation, we now shall not only compute the sequence A for a tuple form (cid:3)α, A, p(cid:4)
with given p, but also possible parent functions p via the encodings. Hence, we ﬁrst have to represent functions p as well
∗
|
as its closure p
i, j
1 (cid:3) j < i (cid:3) k}. Intuitively, if an atom pi, j is true under I , then I is used to characterise a parent function p with p(i) = j.
To show how this can be done, we ﬁrst need a weaker notion than a parent function. We sometimes also regard a parent
function over k as a binary relation over {1, . . . , k} satisfying the restrictions in the following deﬁnition.

. Given a parent function p over k, we use further new atoms P k = {pi, j | 1 (cid:3) j < i (cid:3) k} and P

= {p

∗
k

∗

Deﬁnition 21. For k = 1, let p = ∅, and for k > 1, let p ⊆ {2..k} × {1..k} be a relation where (i, j) ∈ p implies j < i.

We say that an interpretation I represents p via P k iff, for all 1 (cid:3) j < i (cid:3) k, pi, j ∈ I iff (i, j) ∈ p.

The forthcoming propositional encoding has those interpretations as its models which represent relations (according to

Deﬁnition 21) satisfying the requirement for being a parent functions (according to Deﬁnition 9).

Deﬁnition 22. For any k (cid:2) 1, deﬁne

preparent(P k) =

k(cid:11)

i−1(cid:19)

pi, j ∧

(cid:20)

k(cid:11)

i−1(cid:11)

i=2

j=1

i=3

j=2

pi, j →

(cid:21)

¬pi,l

.

j−1(cid:11)

l=1

Example 14. Consider k = 4. There are six possible trees (i.e., realizations of a parent relation p according to Deﬁnition 9)
that can be formed from 4 nodes. These can be represented by the following six options:

Option 1 p(4) = 3,
Option 2 p(4) = 3,
Option 3 p(4) = 1,
Option 4 p(4) = 2,
Option 5 p(4) = 2,
Option 6 p(4) = 1,

p(3) = 2,
p(3) = 1,
p(3) = 2,
p(3) = 1,
p(3) = 2,
p(3) = 1,

p(2) = 1
p(2) = 1
p(2) = 1
p(2) = 1
p(2) = 1
p(2) = 1.

By Deﬁnition 22, formula preparent(P 4) is as follows

p2,1 ∧ (p3,2 ∨ p3,1) ∧ (p4,3 ∨ p4,2 ∨ p4,1) ∧ (p3,2 → ¬p3,1) ∧ (p4,2 → ¬p4,1) ∧ (p4,3 → ¬p4,1 ∧ ¬p4,2).
Note that (p4,3 → ¬p4,1 ∧ ¬p4,2) implies (p4,3 → ¬p4,1) and (p4,3 → ¬p4,2). Hence, by contraposition, we get (p4,1 →
¬p4,3) and (p4,2 → ¬p4,3), and thereby get the constraints we require on the relation p to form a parent function.

Lemma 6. Let p ⊆ {2..k} × {1..k} be a relation where (i, j) ∈ p implies j < i, and I be an interpretation, such that I represents p via
atoms P k. Then, the formula preparent(P k) is true under I iff p is a parent function over k.

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

1419

Proof. Since p is such that (i, j) ∈ p implies j < i, the lemma holds iff preparent(P k) expresses that p is a function. In view
of Deﬁnition 21, that every i in {2..k} has an image by p is expressed by

I |(cid:26)

k(cid:11)

i−1(cid:19)

i=2

j=1

pi, j.

That i in {2..k} only has one image by p can be expressed as follows: if (i, j) ∈ p then for all l (cid:7)= j, (i, l) /∈ p. Since (i, l) ∈ p
implies l < i, this test is only necessary for i in {3..k} (observe that (2, 1) always is in p for k > 1 and there is no other
j such that (i, j) ∈ p holds, it is enough to focus on (i, l) /∈ p for all
possibility). Moreover, since the test is checked for all
l < j. Finally, it is suﬃcient that j ranges from 2 to i − 1. In view of Deﬁnition 21, this amounts to

I |(cid:26)

(cid:20)

k(cid:11)

i−1(cid:11)

i=3

j=2

pi, j →

j−1(cid:11)

l=1

(cid:21)

¬pi,l

.

(cid:3)

Next, we show how to suitably characterise the closure p

∗

(cf. Deﬁnition 11) of a parent function p.

Deﬁnition 23. For any k (cid:2) 1, deﬁne

closure(P k, P

∗
k ) =

(cid:20)

k(cid:11)

i−1(cid:11)

i=2

j=1

(cid:20)

∗
i, j

p

↔

pi, j ∨

i−1(cid:19)

(cid:21)(cid:21)

(pi,l ∧ p

∗
l, j)

.

l= j+1

Lemma 7. Let p be a parent function over k and q ⊆ {2..k} × {1..k} a relation where (i, j) ∈ q implies j < i. Moreover, let I be an
∗(i) = { j | q(i, j)} for i = 2..k.
interpretation representing p via P k and q via P

∗
k . Then, the formula closure(P k, P

∗
k ) is true under I iff p

Proof. By Deﬁnition 21, closure(P k, P
(cid:22)

q(i, j) ⇔

p(i, j), or
p(i, l) and q(l, j)

∗
k ) is, under I , equivalent, for i = 2..k and j = 1..i − 1, to

for some l ∈ { j + 1, . . . , i − 1}

which, by virtue of p being a parent function and q being such that (i, j) ∈ q implies j < i, amounts to

(cid:22)

q(i, j) ⇔

p(i, j), or
p(i, l) and q(l, j)

for some l ∈ {1, . . . , k}

which is known to characterise the transitive closure of p (taken as a relation) provided that p has a ﬁnite domain and is
acyclic but both points are obvious here. (cid:3)

Example 15. Consider k = 4 as in Example 14. One possible parent function was p(4) = 3, p(3) = 2, p(2) = 1. We use atoms
∗
P 4 = {p2,1, p3,1, p4,1, p3,2, p4,2, p4,3} and likewise P
4 . Any interpretation I which assigns true to p2,1, p3,2, p4,3, and false
∗
4) under such I . In
to p3,1, p4,1, and p4,2 represents the above parent function p via P 4. Let us now evaluate closure(P 4, P
∗
∗
fact, we then expect that only those I are models of closure(P 4, P
4) which assign true to all atoms in P
4 . By deﬁnition, I
then represents p

(according to Deﬁnition 11) via P

∗
4 . Observe that we have

∗

closure(P 4, P

∗
4) = (p
(cid:6)
p

(p
(cid:6)

(cid:6)

p

p

(p

∗
2,1
∗
3,1
∗
3,2
∗
4,1
∗
4,2
∗
4,3

↔ p2,1) ∧
(cid:6)
↔

p3,1 ∨ (p3,2 ∧ p

(cid:7)(cid:7)

∗
2,1)

∧

↔ p3,2) ∧
(cid:6)
↔

p4,1 ∨ (p4,2 ∧ p
p4,2 ∨ (p4,3 ∧ p

(cid:6)

↔

↔ p4,3).

(cid:7)(cid:7)

∗
3,1)

∧

∗
2,1) ∨ (p4,3 ∧ p
∗
∧
3,2)

(cid:7)(cid:7)

(7)

(8)

(9)

(10)

(11)

(12)

Recall that we consider I assigning true to p2,1, p3,2, p4,3; conjuncts (7), (9), and (12) thus require that p
also assigned to true by a model I of closure(P 4, P
∗
I . Similarly for line (10), we already know that p
3,1 and p4,3 are true in I , and we can conclude that also p
Finally, (11) forces also p
true in I .

∗
∗
∗
3,2, p
4,3 are
2,1, p
∗
∗
3,1 is true in
2,1 and p3,2 in I . Thus by line (8) also p
∗
4,1 is true in I .
∗
3,2 are

∗
4,2 to be true in I as well, since we already have seen that for a model I also p4,3 and p

∗
4). Now we have p

1420

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

We are now ready to relate interpretations to parent functions in combination with sequences A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4). For
this, we have to guarantee that models represent parent functions (this is done with the already introduced conjunct
preparent(P k)) and that the represented parent function correctly relates to a represented sequence A avoiding duplicate
children (in a way that is similar to what we did in Deﬁnition 18 for the module distinct(G, (cid:4), p)). The latter task is realized
via the second conjunct in the forthcoming deﬁnition.

Deﬁnition 24. For a knowledge base (cid:4), and a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), deﬁne
j−1(cid:11)

i−1(cid:11)

k(cid:11)

(cid:11)

(cid:10)

(cid:12)

parent(G, (cid:4), P k) = preparent(P k) ∧

(pi,l ∧ p j,l) → ¬

(cid:6)

(cid:7)
gi(δ) ↔ g j(δ)

.

i=3

j=2

l=1

δ∈(cid:4)

Lemma 8. For a knowledge base (cid:4), and an interpretation I representing A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G, and a relation p via P k, we have
that parent(G, (cid:4), P k) is true under I iff p is a parent function for A.

Proof. We already know from Lemma 6 that preparent(P k) is true under I iff p (represented by I ) is a parent function
(over k). We thus need to show that the remaining part of parent(G, (cid:4), P k) is true under I iff p is a parent function for
A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), that is, p(i) = p( j) implies (cid:2)i (cid:7)= (cid:2) j , for any 1 < j < i (cid:3) k (in fact, it is suﬃcient to use 2 < j < i (cid:3) k, since
the root has obviously no parent node). Since I also represents A (via G = (cid:3)g1, . . . , gk(cid:4)), we have (cid:2)i (cid:7)= (cid:2) j iff there exists
some δ ∈ (cid:4) such that gi(δ) ↔ g j(δ) is false in I . This holds iff ¬
δ∈(cid:4)(gi(δ) ↔ g j(δ)) is true under I . Since we perform
this test for each pair of children A(i), A( j) of each node A(l) in the annotated tree (represented by I ), the claim follows
by the same arguments as used to show Lemma 5. (cid:3)

(cid:9)

Deﬁnition 25. For a knowledge base (cid:4), a formula α, and a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), we deﬁne

argtree(G, α, (cid:4), P k, P

∗
k ) = arg(g1, (cid:4), α) ∧
i−1(cid:11)
(cid:6)

k(cid:11)

(cid:7)
pi, j → suc(gi, g j, (cid:4))

∧

i=2
k(cid:11)

j=1
(cid:19)

(cid:20)

i=2

δ∈(cid:4)

gi(δ) ∧

i−1(cid:11)

(cid:6)

j=1

(cid:7)
→ ¬g j(δ)

∗
i, j

p

(cid:21)

.

Theorem 5. For a knowledge base (cid:4), a formula α, and an interpretation I , representing a sequence A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G, and a
relation p via P k we have that the QBF

AT(G, (cid:4), P k) = parent(G, (cid:4), P k) ∧ ∃P
is true under I iff (cid:3)α, A, p(cid:4) represents an argument tree.

(cid:6)

∗
k

closure(P k, P

∗
k ) ∧ argtree(G, α, (cid:4), P k, P

(cid:7)
∗
k )

Proof. We only give a sketch here, since we already know the following properties:

• By Lemma 8, I represents a parent function for A iff parent(G, (cid:4), P k) is true under I ;
• By Lemma 7, given an interpretation I representing a parent function p (over k) via P k, I represents the transitive

closure of p via P

∗
k iff closure(P k, P

∗
k ) is true under I ;

• Formula argtree(G, α, (cid:4), P k, P

∗
k ) follows the same structure from Deﬁnition 19 but instead of using the functions p, p
∗
k of variables. Using this observation
explicitly, we represent them (see Deﬁnition 25) by the respective sets P k and P
∗
k (as done in the proofs above) with the structure of the proof
and by suitably combining the techniques for P k and P
of Theorem 3, one can show the following relation: Given (cid:4), α, and an interpretation I representing A via G, a parent
∗
function p for A via P k, and the transitive closure of p, i.e. p
k , we have that (cid:3)α, A, p(cid:4) represents an argument
tree iff argtree(G, α, (cid:4), P k, P

∗
k ) is true under I .

, via P

∗

∗

∗
From the latter observation and the semantics of the existential quantiﬁer, the claim holds. Note that we used ∃P
k just to
“hide” the variables representing the transitive closure of the parent function from the user, since it is not an explicit part
of the requested problem, but rather an internal detail which is fully determined by p. (cid:3)

Deﬁnition 26. For a knowledge base (cid:4), a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), and a further generator func-
tion g, we deﬁne

complete(G, (cid:4), P k) =

k(cid:11)

i=1

(cid:20)

∀g((cid:4))

suc(g, gi, (cid:4)) →

(cid:10)

i−1(cid:19)

j=1

pi, j ∧

(cid:11)

(cid:6)

δ∈(cid:4)

(cid:7)
g(δ) ↔ g j(δ)

(cid:12)(cid:21)

.

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

1421

Theorem 6. For a knowledge base (cid:4), a formula α, and an interpretation I , representing a sequence A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G, and a
relation p over P k we have that the QBF

CAT(G, (cid:4), P k) = parent(G, (cid:4), P k) ∧ ∃P

(cid:6)

∗
k

closure(P k, P

∗
k ) ∧ argtree(G, α, (cid:4), P k, P

(cid:7)
∗
k ) ∧ complete(G, (cid:4), P k)

is true under I iff (cid:3)α, A, p(cid:4) represents a complete argument tree.

The proof of Theorem 6 is similar to the proof for Theorem 4 except that at the end, Theorem 5 instead of Theorem 3 is

required.

Again, we now can decide different decision problems by using above concepts plus ﬁxing some of the concepts. An
interesting question is as follows: Given α and A, does there exist an argument tree (a complete argument tree) using
sets A? In other words, can we ﬁnd a parent function p, such that (cid:3)α, A, p(cid:4) represents an argument tree (a complete
argument tree)?

Corollary 5. Given A = (cid:2)1, . . . , (cid:2)k and a formula α, there exists a parent function p, such that (cid:3)α, A, p(cid:4) represents

1. an argument tree iff the closed QBF

(cid:21)

ﬁx(gi, (cid:2)i) ∧ AT(G, (cid:4), P k)

2. a complete argument tree iff the closed QBF
(cid:20)

(cid:21)

ﬁx(gi, (cid:2)i) ∧ CAT(G, (cid:4), P k)

(cid:20)

k(cid:11)

i=1

k(cid:11)

i=1

∃P k∃G((cid:4))

is true;

∃P k∃G((cid:4))

is true.

3.4. Remarks

We give a few remarks concerning the actual size of the encodings provided in the previous sections compared to the

size of the encoded problem.

First, we address the number of additional atoms (mostly stemming from the generator functions g) required in the
encodings. For the encodings given in Section 3.1, note that we require a new atom for each formula in (cid:4). Hence, if the
cardinality of (cid:4) is n, we need n new atoms for most of the encodings in that section, with the exception of the encodings
where suc(·) is involved where we used two generator functions g1, g2 resulting in 2n new atoms. For the encodings in
Section 3.2, where we used tuple forms of length k to represent trees with k nodes, also the size of the tree comes into play.
One can check that the number of additional atoms required for the encodings in that section is bound by n(k + 1). Finally,
encodings of argument trees with arbitrary structure (Section 3.3) require a much higher number of additional atoms due to
∗
k of atoms. Note that these sets are of cardinality k(k − 1)/2.
the task of representing the tree structure via further sets P k, P
Together with the atoms stemming from the generator functions, we get here a need for n(k + 1) + k2 new atoms.

Concerning the size of the encodings, we just mention that the size is linear in the size of (cid:4) for the encodings in
Section 3.1. For the more involved encodings in Sections 3.2 and 3.3, the size of the encodings is at most quadratic in the
size of (cid:4) and the size of tree.

However, both the theoretical point of view as well as practical experience tell us that the nesting depth of alternating
quantiﬁers is the most crucial parameter for evaluating QBFs, although the parameters of formula size and number of atoms
cannot be ignored. We recall that for all our encodings this nesting depth is ﬁxed and independent of the size of (cid:4) or
the size of the considered argument tree. In fact, one can check that there are at most two quantiﬁer alternations at each
branch of a formula tree associated with our encodings.

As a ﬁnal remark, we mention that the number of new atoms has to be increased if one wants to employ QBF solvers
which rely on inputs in certain normal forms. Here, the transformation to such a normal form further introduces new atoms.
Most of the current QBF solvers (see [28]) require such a normal form, but there are also solvers (e.g. [21]) which can be
applied to the encodings directly (modulo some transformation steps which do not introduce new atoms).

4. Discussion

There is increasing interest in formalisations for argumentation, and in particular computational models of argument
(see for example [4,6,8,13,17,31]). In this paper, we have addressed this issue in the context of argumentation with classical
logic as the underlying logic by providing encodation in terms of quantiﬁed Boolean formulae. This approach is beneﬁcial
with respect to several aspects.

1422

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

First, it offers the possibility of implementing decision procedures for argumentation based on classical logic using exist-

ing QBF solvers.

Second, it allows to obtain novel complexity results for interesting decision problems associated with logic-based argu-
mentation. Indeed, while for abstract argumentation, there has been a comprehensive analysis of computational complexity
of some of the key decision problems (in particular [16]), there are only a few published results concerning computational
complexity of logic-based argumentation. In [29], for instance, it is shown that given a knowledge-base (cid:4) and a formula α,
ascertaining whether there is a (cid:2) ⊆ (cid:4) such that (cid:3)(cid:2), α(cid:4) is an argument (i.e. (cid:2) is a minimal consistent set of premises entail-
ing α) is a (cid:5) p
2 -complete decision problem. Our results can be employed to obtain similar results for more involved decision
problems. In fact, since all encodings are constructible in polynomial time with respect to the size of the problem descrip-
tion, inspecting the quantiﬁer structure of the encodings and applying Proposition 4 immediately yields upper complexity
bounds for the encoded problems. For instance, this shows that several decision problems formulated for argumentation
trees remain located in (cid:5) p
2 -completeness for
those decision problems over argumentation trees is expected. However, if complete argumentation trees are taken into ac-
count, our encodings indicate that this leads to an increasing complexity, having such problems located in (cid:5) p
3 . Establishing
exact complexity results for numerous decision problems in logic-based argumentation is indeed part of our ongoing work.
In another approach to deductive argumentation, Wooldridge et al. [34] show that by taking a “maximal" set of argu-
ments (i.e. a set of arguments that does not include “equivalent" arguments), they can treat the set of arguments as an
abstract argument system with the attack relation holding between a pair of arguments A and A
when A is a defeater
of A
. This means that the abstract argument system can be evaluated using the notions of acceptability deﬁned by Dung
[14]. This offers a different way of assembling and evaluating arguments to that considered in this paper. Furthermore, they
provide complexity results concerning the identiﬁcation of the “maximal" sets of arguments.

2 . Since the evaluation of a single argument is already hard for this class, (cid:5) p

(cid:9)

(cid:9)

Finally, our results are useful for comparing different approaches to argumentation. In fact, there is increasing interest
in algorithms and implementations for argumentation systems including for abstract argumentation systems [2,11,12,32],
for assumption-based argumentation systems [15,25,27], for logic-based argumentation systems based on defeasible logic
[9,10,26,33], and for logic-based argumentation systems based on classical logic [18]. Undertaking empirical evaluations
that compare these algorithms is diﬃcult because of the diverse approaches taken in implementing them. So undertaking
evaluations via encodations as QBFs offers the opportunity for a level playing ﬁeld for comparisons that draw out the
strengths and weaknesses of each of the algorithms and their underlying reasoning mechanisms. In particular, comparisons
with QBF encodings for other argumentation formulations [22] or, encodings in terms of classical logic for nonmonotonic
formalisms in general [3,19] are now enabled.

Acknowledgements

This work was supported by the Vienna Science and Technology Fund (WWTF) under grant ICT08-028.

References

[1] L. Amgoud, C. Cayrol, A model of reasoning based on the production of acceptable arguments, Annals of Mathematics and Artiﬁcial Intelligence 34

(2002) 197–216.

[2] P. Baroni, M. Giacomin, Argumentation through a distributed self-stabilizing approach, Journal of Experimental and Theoretical Artiﬁcial Intelli-

gence 14 (4) (2002) 273–301.

[3] R. Ben-Eliyahu, R. Dechter, Default reasoning using classical logic, Artiﬁcial Intelligence 84 (1–2) (1996) 113–150.
[4] T. Bench-Capon, P. Dunne, Argumentation in artiﬁcial intelligence, Artiﬁcial Intelligence 171 (10–15) (2007) 619–641.
[5] S. Benferhat, D. Dubois, H. Prade, Argumentative inference in uncertain and inconsistent knowledge bases, in: Proceedings of the 9th Annual Conference

on Uncertainty in Artiﬁcial Intelligence (UAI 1993), Morgan Kaufmann, 1993, pp. 411–419.

[6] Ph. Besnard, S. Doutre, A. Hunter (Eds.), Computational Models of Argument: Proceedings of COMMA 2008, IOS Press, 2008.
[7] Ph. Besnard, A. Hunter, A logic-based theory of deductive arguments, Artiﬁcial Intelligence 128 (2001) 203–235.
[8] Ph. Besnard, A. Hunter, Elements of Argumentation, MIT Press, 2008.
[9] D. Bryant, P. Krause, A review of current defeasible reasoning implementations, Knowledge Engineering Review 23 (3) (2008) 227–260.

[10] D. Bryant, P. Krause, G. Vreeswijk, Argue tuprolog: A lightweight argumentation engine for agent applications, in: P. Dunne, T. Bench-Capon (Eds.),

Computational Models of Argumentation (COMMA 2006), IOS Press, 2006, pp. 27–31.

[11] C. Cayrol, S. Doutre, J. Mengin, Dialectical proof theories for the credulous preferred semantics of argumentation frameworks, in: Quantitative and

Qualitative Approaches to Reasoning with Uncertainty (ECSQARU 2001), in: LNCS, vol. 2143, Springer, 2001, pp. 668–679.

[12] C. Cayrol, S. Doutre, J. Mengin, On decision problems related to the preferred semantics for argumentation frameworks, Journal of Logic and Computa-

tion 13 (3) (2003) 377–403.

[13] C. Chesñevar, A. Maguitman, R. Loui, Logical models of argument, ACM Computing Surveys 32 (2000) 337–383.
[14] P. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games, Artiﬁcial

Intelligence 77 (2) (1995) 321–358.

[15] P. Dung, R. Kowalski, F. Toni, Dialectical proof procedures for assumption-based admissible argumentation, Artiﬁcial Intelligence 170 (2006) 114–159.
[16] P. Dunne, T. Bench-Capon, Coherence in ﬁnite argumentation systems, Artiﬁcial Intelligence 141 (2002) 187–203.
[17] P. Dunne, T. Bench-Capon (Eds.), Computational Models of Argument: Proceedings of COMMA 2006, IOS Press, 2006.
[18] V. Efstathiou, A. Hunter, Algorithms for effective argumentation in classical propositional logic, in: Proceedings of the International Symposium on

Foundations of Information and Knowledge Systems (FOIKS 2008), in: LNCS, vol. 4932, Springer, 2008, pp. 272–290.

[19] U. Egly, T. Eiter, H. Tompits, S. Woltran, Solving advanced reasoning tasks using quantiﬁed boolean formulas, in: Proceedings of the 17th National

Conference on Artiﬁcial Intelligence (AAAI’00), AAAI Press/MIT Press, 2000, pp. 417–422.

P. Besnard et al. / Artiﬁcial Intelligence 173 (2009) 1406–1423

1423

[20] U. Egly, M. Seidl, H. Tompits, S. Woltran, M. Zolda, Comparing different prenexing strategies for quantiﬁed boolean formulas, in: Proceedings of the
6th International Conference on the Theory and Applications of Satisﬁability Testing (SAT-03), Selected Revised Papers, in: LNCS, vol. 2919, 2004, pp.
214–228.

[21] U. Egly, M. Seidl, S. Woltran, A solver for QBFs in nonprenex form, Constraints 14 (1) (2009) 38–79.
[22] U. Egly, S. Woltran, Reasoning in argumentation frameworks using quantiﬁed Boolean formulas, in: Proceedings COMMA’06, IOS Press, 2006, pp. 133–

144.

[23] T. Eiter, G. Gottlob, The complexity of logic-based abduction, Journal of the ACM 42 (1995) 3–42.
[24] M. Elvang-Gøransson, P. Krause, J. Fox, Dialectic reasoning with classically inconsistent information, in: Proceedings of the 9th Conference on Uncer-

tainty in Artiﬁcial Intelligence (UAI 1993), Morgan Kaufmann, 1993, pp. 114–121.

[25] D. Gaertner, F. Toni, Computing arguments and attacks in assumption-based argumentation, IEEE Intelligent Systems 22 (6) (2007) 24–33 (special issue

on argumentation technology).

[26] A. García, G. Simari, Defeasible logic programming: An argumentative approach, Theory and Practice of Logic Programming 4 (1) (2004) 95–138.
[27] A. Kakas, F. Toni, Computing argumentation in logic programming, Journal of Logic and Computation 9 (1999) 515–562.
[28] M. Narizzano, L. Pulina, A. Tacchella, Report of the third QBF solvers evaluation, Journal of Satisﬁability, Boolean Modeling and Computation 2 (2006)

145–164.

[29] S. Parsons, M. Wooldridge, L. Amgoud, Properties and complexity of some formal inter-agent dialogues, Journal of Logic and Computation 13 (3) (2003)

347–376.

[30] H. Prakken, G. Sartor, Argument-based extended logic programming with defeasible priorities, Journal of Applied Non-Classical Logics 7 (1997) 25–75.
[31] H. Prakken, G. Vreeswijk, Logical systems for defeasible argumentation, in: D. Gabbay (Ed.), Handbook of Philosophical Logic, Kluwer, 2002.
[32] M. South, G. Vreeswijk, J. Fox, Dungine: A java dung reasoner, in: Computational Models of Argumentation (COMMA 2008), IOS Press, 2008, pp. 360–

368.

[33] G. Vreeswijk, An algorithm to compute minimally grounded defence sets in argument systems, in: P. Dunne, T. Bench-Capon (Eds.), Computational

Models of Argumentation (COMMA 2006), IOS Press, 2006, pp. 109–120.

[34] M. Wooldridge, P. Dunne, S. Parsons, On the complexity of linking deductive and abstract argument systems, in: Proceedings of the Twenty First

National Conference on Artiﬁcial Intelligence (AAAI-06), MIT Press, 2006, pp. 299–304.

[35] C. Wrathall, Complete sets and the polynomial-time hierarchy, Theoretical Computer Science 3 (1) (1976) 23–33.

