Artiﬁcial Intelligence 172 (2008) 1429–1469

Contents lists available at ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Maintenance goals of agents in a dynamic environment: Formulation and
policy construction ✩
Chitta Baral a,∗

, Thomas Eiter c, Marcus Bjäreland b, Mutsumi Nakamura a

a Department of Computer Science and Engineering, Arizona State University, Tempe, AZ 85287, USA
b AstraZeneca R&D, S-43183 Mölndal, Sweden
c Institute of Information Systems, Vienna University of Technology, A-1040 Vienna, Austria

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 25 September 2005
Received in revised form 3 March 2008
Accepted 18 March 2008
Available online 3 April 2008

Keywords:
Maintenance goals
k-maintainability
Agent control
Computational complexity of agent design
Answer set programming
Horn theories
SAT solving
Discrete event dynamic systems
Self-stabilization

The notion of maintenance often appears in the AI literature in the context of agent
behavior and planning. In this paper, we argue that earlier characterizations of the notion
of maintenance are not intuitive to characterize the maintenance behavior of certain agents
in a dynamic environment. We propose a different characterization of maintenance and
distinguish it from earlier notions such as stabilizability. Our notion of maintenance is more
sensitive to a good-natured agent which struggles with an “adversary” environment, which
hinders her by unforeseeable events to reach her goals (not in principle, but in case). It has
a parameter k, referring to the length of non-interference (from exogenous events) needed
to maintain a goal; we refer to this notion as k-maintainability. We demonstrate the notion
on examples, and address the important but non-trivial issue of eﬃcient construction
of maintainability control functions. We present an algorithm which in polynomial time
constructs a k-maintainable control function, if one exists, or tells that no such control
is possible. Our algorithm is based on SAT Solving, and employs a suitable formulation
of the existence of k-maintainable control in a fragment of SAT which is tractable. For
small k (bounded by a constant), our algorithm is linear time. We then give a logic
programming implementation of our algorithm and use it to give a standard procedural
algorithm, and analyze the complexity of constructing k-maintainable controls, under
different assumptions such as k = 1, and states described by variables. On the one hand,
our work provides new concepts and algorithms for maintenance in dynamic environment,
and on the other hand, a very fruitful application of computational logic tools. We compare
our work with earlier works on control synthesis from temporal logic speciﬁcation and
relate our work to Dijkstra’s notion of self-stabilization and related notions in distributed
computing.

© 2008 Elsevier B.V. All rights reserved.

✩

A preliminary version of the formulation part, entitled “A formal characterization of maintenance goals”, has been presented at AAAI’00, and a
preliminary version of the algorithm part entitled “A polynomial time algorithm for constructing k-maintainable policies” has been presented at ICAPS’04.
The current version revises and combines both of them with additional elaborations, examples, results, and proofs. The major part of the algorithms was
done when Chitta Baral was visiting Vienna University of Technology in 2003. Marcus Bjäreland carried out the major part of his work while he was with
the Department of Computer and Information Science of Linkoping University.
* Corresponding author.

E-mail addresses: chitta@asu.edu (C. Baral), eiter@kr.tuwien.ac.at (T. Eiter), marcus.bjareland@astrazeneca.com (M. Bjäreland), mutsumi@asu.edu

(M. Nakamura).

0004-3702/$ – see front matter © 2008 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2008.03.005

1430

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1. Introduction and motivation

For an agent situated in a static environment, the goal is often to reach one out of several states where certain conditions
are satisﬁed. Such a goal is usually expressed by a formula in propositional or ﬁrst-order logic. Sometimes the goal requires
constraining the path taken to reach one of the states. In that case, the goal can be expressed by a formula in temporal
logic [3,7,54].

Our concern in this paper is about agents in a dynamic environment. In that case, things are more complex since the
state of the world can change through both actions of the agent and of the environment. The agent’s goal in a dynamic
environment is then often more than just achieving a desired state, as after the agent has successfully acted to reach a
desired state, the environment may change that state. In such a case, a common goal of an agent is to ‘maintain’ rather than
just ‘achieve’ certain conditions. The goal of maintaining certain conditions (or a set of states that satisfy these conditions)
is referred to as maintenance goals. Maintenance goals are well-known in the AI literature, e.g., [3,27,41,55,67], and have
counterparts in other areas such as in stability theory of discrete event dynamic systems [56,58,61,62,66] and in active
databases [17,51]. However, as we argue in this paper, earlier characterizations of maintenance goals are not adequate under
all circumstances.

To see what is wrong with earlier deﬁnition of maintenance goals, suppose an agent’s goal is to maintain a ﬂuent f ,
i.e., the proposition f should be true. A straightforward attempt1 to express it using temporal operators is the formula
(cid:2) f , where (cid:2) is the temporal operator “Always” and (cid:2) f means that f
is true in all the future states of the world. This is
too strong a condition, as maintaining inherently means that things go out of shape and they have to be maintained back
to shape. A better temporal logic representation of this goal is thus the formula (cid:2)(cid:3) f , where (cid:3) is the temporal operator
“Eventually”. Intuitively, the formula (cid:2)(cid:3) f
is satisﬁed by an inﬁnite trajectory of states of the form s0, s1, s2, . . . , if at any
stage i (cid:2) 0, there exists some stage j (cid:2) i such that f
is true in s j . An agent’s control is said to satisfy (cid:2)(cid:3) f if all trajectories
that characterize the evolution of the world due to the environment and the agent’s control satisfy (cid:2)(cid:3) f . At ﬁrst glance the formula
(cid:2)(cid:3) f seems to express the goal of maintaining f , as it encodes that if f becomes f alse in any state in the trajectory then
it becomes true in a later state.

We consider (cid:2)(cid:3) f to be also too strong a speciﬁcation—in many situations—to express the intuitive notion of ‘main-
taining f ’, if we take on a more reﬁned view of the (sometimes nasty) part which the environment might play, which we
illustrate by some examples. Suppose f denotes the condition that the Inbox of a customer service department be empty.
Here the environment makes f false by adding new requests to the Inbox while the agent tries to make f true by process-
ing the messages in the Inbox and removing them from it. If the agent is diligent in processing the message in the Inbox
and makes it empty every chance the agent gets, we would then like to say that agent maintains the Inbox empty. But such
a control does not satisfy the formula (cid:2)(cid:3) f under all circumstances, because there will be trajectories where the agent is
overwhelmed by the environment (ﬂooding the Inbox) and f never becomes true.

Another example in support of our intuition behind maintainability is the notion of maintaining the consistency of a
database [17,51,68]. When direct updates are made to a database, maintaining the consistency of the database entails the
triggering of additional updates that may bring about additional changes to the database so that in the ﬁnal state (after the
triggering is done) the database reaches a consistent state. This does not mean that the database will reach consistency if
continuous updates are made to it and it is not given a chance to recover. In fact, if continuous update requests are made
we may have something similar to denial of service attacks. In this case we can not fault the triggers saying that they do
not maintain the consistency of the database. They do. It is just that they need to be given a window of opportunity or a
respite from continuous harassment from the environment to bring about the additional changes which are necessary to
restore database consistency. The same holds for maintaining a room clean; we can not fault the cleaning person if he or
she is continually sent away because the room is being continuously used.

Another example is a mobile robot [15,47] which is asked to ‘maintain’ a state where there are no obstacles in front of it.
Here, if there is a belligerent adversary that keeps on putting an obstacle in front of the robot, there is no way for the robot
to reach a state with no obstacle in front of it. But often we will be satisﬁed if the robot avoids obstacles in its front when
it is not continually harassed. Of course, we would rather have the robot take a path that does not have such an adversary,
but in the absence of such a path, it would be acceptable if it takes an available path and ‘maintains’ states where there are
no obstacles in front.

The inadequacy of the expression (cid:2)(cid:3) f

is deﬁned on
trajectories which do not distinguish between transitions due to agent actions and environment actions. Thus we can not
distinguish the cases

in expressing our intuition about ‘maintaining f ’ is because (cid:2)(cid:3) f

(i) where the agent does its best to maintain f (and is sometimes thwarted by the environment) and can indeed make f

true in some (say, k) steps if there is no interference from the environment during those steps; and

(ii) where the agent really does not even try.

1 All through the paper we consider the evaluation of linear temporal formulas with respect to all ‘valid’ trajectories. An alternative approach would be
to use a variation of the branching time quantiﬁer A, such as the operator Aπ from [9], before the linear temporal formulas. Another alternative approach,
referred to as boolean task speciﬁcation, is used in [27,28,69].

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1431

We refer to (i) as k-maintainability in this paper. The expression (cid:2)(cid:3) f can not express the idea of a window of opportunity
(or window of non-interference) during which an agent can perform the actions necessary for maintaining. In fact, none of
the standard notions of temporal logics [20,48], which are deﬁned on trajectories that do not distinguish between the cause
behind the transitions (whether they are due to agent’s actions or due to the environment),2 can express the idea behind
k-maintainability.

The main contributions of this paper can be summarized as follows.

1. We introduce and formally deﬁne the notion of k-maintainability, and distinguish it from earlier notions of maintain-
ability, in particular the speciﬁcation (cid:2)(cid:3) f and the similar notion of stabilizability from discrete event dynamic systems.
2. We provide polynomial time algorithms that can construct k-maintainable control policies, if one exists. (In the rest
of the paper we will refer to ‘control policy’ simply by ‘control’.) Our algorithm is based on SAT Solving, and employs
a suitable formulation of the existence of k-maintainable control in a tractable fragment of SAT. We then give a logic
programming implementation of this method, and ﬁnally distill from it a standard procedural algorithm. We brieﬂy
discuss earlier approaches to controller synthesis [1,10,19,41,49,60] with respect to temporal logic speciﬁcations and
compare their complexity with that of our algorithms.

3. We analyze the computational complexity of constructing k-maintainable controls, under different settings of the en-
vironment and the windows of opportunity open to the agent, as well as under different forms of representation. We
show that the problem is complete for PTIME in the standard setting, where the possible states are enumerated, and
complete for EXPTIME in a STRIPS-style setting where states are given by value assignments to ﬂuents. Furthermore,
we elucidate the impact of the different factors and show, by our proofs of the hardness results, that the full problem
complexity is inherent already to certain restricted cases.

Overall, our work not only provides new concepts and algorithms for realizing maintenance of an agent in dynamic

environment, but also illustrates a very fruitful application of computational logic tools.

The rest of this paper is organized as follows. In Section 2 we present the background deﬁnitions of a system with an
agent in an environment and deﬁne the notions of stability and stabilizability. In Section 3 we describe an example of a
system with two buffers. We use this example for illustrating the concepts of stabilizability and k-maintainability, which
is formally deﬁned in Section 4. In Section 5 we present our algorithms for constructing k-maintaining controls, based on
SAT Solving as well as a genuine algorithm extracted from it. In Section 6 we present an encoding for computing a control
function using a logic programming engine and devote Section 7 to complexity analysis. Finally, in Section 8 we present
some experimental results, discuss related work, and outline some future directions.

2. Background: Systems, goals, control, stability and stabilizability

In this paper, we are concerned with goal-directed agents in a dynamic world. Such agents can perform actions that
change the state of the world. Because of the dynamic nature of the world, certain changes can happen to the state of the
world beyond the control of an agent. The agent’s job is thus to make the world evolve in a way coherent with a goal
assigned to it. As for the agent control, we adopt here that an agent follows a Markovian control policy to do its job; that
is, its control is a function from the set of states to the set of actions, detailed as follows.

Deﬁnition 1 (System). A system is a quadruple A = (S, A, Φ, poss), where

• S is a ﬁnite set of system states;
• A is a ﬁnite set of actions, which is the union of the set of agents actions, Aag, and the set of environmental actions,

Aenv;

S
• Φ : S × A → 2
to actions; and

• poss : S → 2

A

is a non-deterministic transition function that speciﬁes how the state of the world changes in response

is a function that describes which actions are possible to take in which states.

The above notion of system is used in the discrete event dynamic systems community, for instance in [56,58,61,62,66].
In practice, the functions Φ and poss are required to be effectively (and eﬃciently) computable, and they may often be
speciﬁed in a representation language such as in [32,34,63]. The possibility of an action has different meaning depending
on whether it is an agent’s action or whether it is an environmental action. In case of an agent’s action, it is often dictated
by the policy followed by the agent. For environmental actions, it encodes the various possibilities that are being accounted
for in the model. We tacitly assume here that possible actions lead always to some successor state, i.e., the axiom that
Φ(s, a) (cid:4)= ∅ whenever a ∈ poss(s) holds for any state s and action a, is satisﬁed by any system.

2 If one distinguishes the cause behind transitions, then temporal logic can indeed be used to express maintainability. We discuss this further in Sec-

tion 4.1.

1432

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

Fig. 1. S = {b, c, d, f , g, h}, A = {a, a

(cid:7), e}, Aag = {a, a

(cid:7)}, Aenv = {e}, Φ is as shown.

An example of a system A = (S, A, Φ, poss), where S = {b, c, d, f , g, h}, A = {a, a

shown in Fig. 1, where s
leaving s. Notice that in this example, Φ(s, a) is deterministic, i.e., Φ(s, a) is a singleton if nonempty.
The evolution of the world with respect to a system is characterized by the following deﬁnition.

(cid:7) ∈ Φ(s, a) iff an arc s → s

(cid:7)

(cid:7), e}, and the transition function Φ is
labeled with a is present and poss(s) are all actions that label arcs

Deﬁnition 2 (Trajectory). Given a system A = (S, A, Φ, poss), an alternating inﬁnite sequence of states and actions
s0, a1, s1, a2, . . . , sk, ak+1, sk+1, . . . is said to be a trajectory consistent with A, if sk+1 ∈ Φ(sk, ak+1), and ak+1 ∈ poss(sk).

The above notion of trajectory does not require that agent actions and environment actions be interleaved as is done
in formulations of games. It allows one agent action to be followed by multiple environment actions and vice-versa, as in
real worlds we do not have an arbiter who can enforce the alternation of the agent and environment actions. The notion
assumes that the time points are ﬁne enough that at any point only one action can occur. Thus, it does not allow explicit
occurrence of agent and environment actions at the same time.

A common restriction on how the world evolves is deﬁned using the notion of stability. The following deﬁnition of

stability is adapted from [56] and has its origin in control theory and discrete event dynamic systems [56,58,61,62].

Deﬁnition 3 (Stable state 1). Given a system A = (S, A, Φ, poss) and a set of states E, a state s is said to be stable in A w.r.t.
E if all trajectories consistent with A and starting from s visit E inﬁnitely often. A set of states S is stable with respect to
E if all states in S are stable with respect to E.

We say A = (S, A, Φ, poss) is a stable system, if all states in S are stable in A with respect to E.

Although the above deﬁnition of stability is with respect to a set of states E, it can be easily adapted to a propositional
formula ϕ that can be evaluated at the states of system A. In that case E = {s ∈ S | A, s |(cid:8) ϕ}, where A, s |(cid:8) ϕ denotes that
s in A satisﬁes (in the propositional logic sense) ϕ. Thus, E is the set of states s at which ϕ is satisﬁed.

An alternative approach to characterize the evolution of states is through temporal operators. Some of the important
temporal operators talking about the future are (cf. [30,48]): Next ((cid:9)), Always ((cid:2)), Eventually ((cid:3)), and Until (U ). Their
meaning with respect a trajectory τ = s0, a1, s1, . . . , sk, ak+1, sk+1, . . . is deﬁned as follows.

Let (τ , j), for j (cid:2) 0, denote the remainder of τ starting at s j ; then

• (τ , j) |(cid:8) p iff p is true in s j , for any proposition p;
• (τ , j) |(cid:8) (cid:9)φ iff (τ , j + 1) |(cid:8) φ;
• (τ , j) |(cid:8) (cid:2)φ iff (τ , k) |(cid:8) φ, for all k (cid:2) j.
• (τ , j) |(cid:8) (cid:3)φ iff (τ , k) |(cid:8) φ, for some k (cid:2) j.
• (τ , j) |(cid:8) φ1 U φ2 iff there exists k (cid:2) j such that (τ , k) |(cid:8) φ2 and for all i, j (cid:3) i < k, (τ , i) |(cid:8) φ1.

The standard Boolean connectives ∧, ∨, and ¬ are deﬁned as usual. An alternative deﬁnition of stability can then be

given as follows:

Deﬁnition 4 (Stable state 2). Given a system A = (S, A, Φ, poss) and an objective formula ϕ (i.e., without temporal oper-
ators), let Eφ = {s ∈ S | A, s |(cid:8) φ}. A state s is then said to be stable in A w.r.t. E if for all trajectories τ of the form
τ = s0, a1, s1, . . . , sk, ak+1, sk+1, . . . (where s0 = s) consistent with A, it holds that (τ , 0) |(cid:8) (cid:2)(cid:3)ϕ.

In fact, this deﬁnition is equivalent to Deﬁnition 3. The advantage of using temporal operators, as in the above deﬁnition,
instead of Deﬁnition 3 is that the former allows us to specify a larger class of goals and build on top of the notion of
stability. For example, a notion similar to stability, referred to as a response property [48], is of the form (cid:2)(p → (cid:3)q).

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1433

2.1. Stabilizability

The notion of stability is deﬁned with respect to a system and the evolution of the world consistent with the system.
When we focus on an agent and its ability to make a system stable, we need a notion of stabilizability which intuitively
means that there exists a control policy which the agent can use to fashion a stable system.

Given a system A = (S, A, Φ, poss), when discussing stabilizability of the system, we need to consider the following

additional aspects:

• the set of actions Aag which the agent is capable of executing in principle (where Aag ⊆ A);
• the set of exogenous actions that may occur in the state s, beyond the agent’s control, modeled by a function exo : S →
Aenv , where exo(s) ⊆ poss(s) for each state s (recall that Aenv are the environmental actions). We call any such exo an
2
exogenous function.

Intuitively, given a system A = (S, A, Φ, poss), Aag, exo, and E, a state s is stabilizable with respect to E, if we are able to
ﬁnd a policy or control function such that it makes the resulting system stable and the agent starting from s following that
policy will not reach a state where no further actions are possible.

The last condition is referred to as aliveness. It is formally deﬁned by the following two deﬁnitions, the ﬁrst of which

deﬁnes the set R( A, s) of states that can be reached from s in the system A.

Deﬁnition 5 (Closure). Given a system A = (S, A, Φ, poss) and a state s, R( A, s) ⊆ S is the smallest set of states that
satisfying the following conditions:

1. s ∈ R( A, s),
2. If s

(cid:7) ∈ R( A, s), and a ∈ poss(s

(cid:7)), then Φ(s

(cid:7), a) ⊆ R( A, s).

For any set of states S ⊆ S, the closure of A w.r.t. S is deﬁned by

Closure(S, A) =

(cid:2)

s∈S

R( A, s).

Example 1. In the system A in Fig. 1, we have that R( A, d) = {d, h} and R( A, f ) = { f , g, h}, and therefore Closure({d, f }, A)
= {d, f , g, h}. This is illustrated in Fig. 2.

Note that Closure(S, A) satisﬁes the Kuratowski closure axioms [43], that is, Closure(∅, A) = ∅; S ⊆ Closure(S, A);
Closure(Closure(S, A), A) = Closure(S, A); and, moreover, Closure(S1 ∪ S2, A) = Closure(S1, A) ∪ Closure(S2, A). Furthermore,
Φ(s, a) ⊆ Closure(S, A) holds for each state s ∈ Closure(S, A) and a ∈ poss(s).

Deﬁnition 6 (Aliveness). Given a system A = (S, A, Φ, poss) and a state s, we say s is alive if poss(s
We say A = (S, A, Φ, poss) is alive if all states in S are alive.

(cid:7)) (cid:4)= ∅, for all s

(cid:7) ∈ R( A, s).

The notion of control function is formally deﬁned as follows.

Fig. 2. R( A, d) = {d, h} and R( A, f ) = { f , g, h}, and Closure({d, f }, A) = {d, f , g, h}.

1434

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

Fig. 3. Policy K is doing a in states b, c, d and f ; poss(b) = {a, a

(cid:7)}; possK ,exo(b) = {a}; Closure({b, c}, A) = {b, c, d, f , g, h}; Closure({b, c}, A K ,exo) = {b, c, d, h}.

Deﬁnition 7 (Control). Given a system A = (S, A, Φ, poss) and a set Aag ⊆ A of agent actions, a control function for A w.r.t.
Aag is a partial function
K : S → Aag,

such that K (s) ∈ poss(s) whenever K (s) is deﬁned.3

We are now ready to formally deﬁne the notion of stabilizability.

Deﬁnition 8 (Stabilizability). Given a system A = (S, A, Φ, poss), a set Aag ⊆ A, a function exo as above, and a set of states
E, we say that s ∈ S is stabilizable with respect to E, if there exists a control function K : S → Aag for A w.r.t. Aag with the
following properties:

1. s is stable with respect to E in the system A K ,exo = (S, A, Φ, possK ,exo), where, for any state s

exo(s

(cid:7)); and
2. s is alive in A K ,exo.

(cid:7)

, possK ,exo(s

(cid:7)) = {K (s

(cid:7))} ∪

A set of states S ⊆ S is stabilizable with respect to E, if there is a control function K for A w.r.t. Aag such that every state

s ∈ S is stabilizable with respect to E witnessed by K .

Having provided this deﬁnition, we shall illustrate it on an elaborated example in the next section, where we describe

an intuitive control function for the management of two ﬁnite buffers.

Before closing this section, we introduce for later use the notion of a non-deterministic control.

Deﬁnition 9 (Non-deterministic control). Given a system A = (S, A, Φ, poss) and a set Aag ⊆ A of agent actions, a partial
Aag such that K (s) ⊆ poss(s) and K (s) (cid:4)= ∅ whenever K (s) is deﬁned, is called non-deterministic control
function K : S → 2
for A w.r.t. Aag.

Informally, a non-deterministic control leaves the agent a choice to execute one out of several actions. It is an envelope
for multiple control functions, which result by reﬁning K to some arbitrary action in K (s) whenever K (s) is deﬁned; the
(cid:7)) =
notion of stabilizability is deﬁned similar as for control functions, with the only change that in A K ,exo, we set possK ,exo(s
K (s

(cid:7))} ∪ exo(s

(cid:7)) = {K (s

(cid:7)).

(cid:7)) ∪ exo(s
(cid:7)) in place of possK ,exo(s
The following proposition is immediate.

Proposition 1. Given a system A = (S, A, Φ, poss), a set Aag ⊆ A, and a function exo, a set of states S ⊆ S is stabilizable w.r.t. a
set of states E ⊆ S under a control function K for A w.r.t. Aag iff S is stabilizable w.r.t. E under a non-deterministic control K
for A
+(s) and K (s) is deﬁned
+
w.r.t. Aag. Furthermore, each such K is a reﬁnement of some K
iff K

with this property (i.e., for each s, K (s) ∈ K
is a control function witnessing stabilizability of S w.r.t. E.

+(s) is deﬁned), and each reﬁnement K of K

+

+

3. Example scenario: Two ﬁnite buffers

In this section, we introduce an example which we will use in illustrating the notion of stabilizability and also other

concepts in some of the later sections of the paper.

3 In the planning literature, in Markov Decision Planning a control function is also called a (control) policy, which is usually assumed to be a total
function [35]; in Model-Based Planning, [18], it is called a deterministic state-action table, and non-deterministic controls (introduced below) are called
(non-deterministic) state-action tables; [35] refers to them also as (non-deterministic) plans or policies, respectively.

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1435

We imagine a system with two ﬁnite buffers, b1 and b2, where objects are added to b1 in an uncontrollable way. An
agent moves objects from b1 to b2 and processes them there. When an object has been processed, it is automatically
removed from b2. This is a slight modiﬁcation of a ﬁnite buffer example from [58] and generalizes problems such as ftp
agents maintaining a clean ftp area by moving submitted ﬁles to other directories, or robots moving physical objects from
one location to another.

In our framework, we shall describe a system Ab which models this scenario. For simplicity, we assume that the agent
has three control actions M12 that moves an object from b1 to b2 (if such an object exists), the opposite action, M21 that
moves an object from b2 to b1, and Proc that processes and removes an object in b2. There is one exogenous action, Ins,
that inserts an object into buffer b1. The capacities of b1 and b2 are assumed to be equal.

Let us assume that the control goal of this system is to keep b1 empty. Then, the system is not stabilizable, since objects
can be continually inserted before the agent has a chance to empty the buffer. However, if no insertions are performed for
a certain window of non-interference, the agent can always empty b1. This implies that the system is maintainable but not
stabilizable. We now make the above argument explicit by using a concrete instance of Ab.

Example 2 (Buffer example). We assume that the maximum capacity of the buffers b1 and b2 is 3. The components of
Ab = (Sb, Ab, Φb, possb) are then as follows.

• We model every state by the current number of objects in b1 and b2. That is, a state s is identiﬁed by a pair of integers
(cid:14)i, j(cid:15) where i denotes the number of objects in b1 and j the number of objects in b2. With the maximum capacity of
3, the set of states, Sb, consists of 4 × 4 = 16 states and is given by

Sb = {0, 1, 2, 3} × {0, 1, 2, 3}.

• The set of actions is Ab = {M12, M21, Proc, Ins}.
• We assume that the transition function Φb is deterministic, i.e., |Φb(s, a)| (cid:3) 1, deﬁned as follows, where we write

(cid:7)}. For every i, j ∈ {0, . . . , 3}, let

for Φb(s, a) = {s
(cid:4)

(cid:7)

Φb

Φb(s, a) = s
(cid:3)
(cid:14)i, j(cid:15), M12
(cid:3)
(cid:14)i, j(cid:15), M21
(cid:3)
(cid:14)i, j(cid:15), Proc
(cid:4)
(cid:3)
(cid:14)i, j(cid:15), Ins

Φb

Φb

Φb

(cid:4)

= (cid:14)i − 1, j + 1(cid:15),

= (cid:14)i + 1, j − 1(cid:15),
(cid:4)

= (cid:14)i, j − 1(cid:15),

= (cid:14)i + 1, j(cid:15),

where addition and subtraction are modulo 3, and in all other cases Φb(s, a) = ∅.

• The enabling function, possb, is deﬁned by

(cid:4)
(cid:3)
M12 ∈ possb
(cid:14)i, j(cid:15)
(cid:4)
(cid:3)
M21 ∈ possb
(cid:14)i, j(cid:15)
(cid:4)
(cid:3)
(cid:14)i, j(cid:15)
Proc ∈ possb
(cid:4)
(cid:3)
(cid:14)i, j(cid:15)
Ins ∈ possb

iff

iff

i (cid:2) 1 and j (cid:3) 2,

i (cid:3) 2 and j (cid:2) 1,

iff

j (cid:2) 1,

iff

i (cid:3) 2.

It is easy to see that for S = {(cid:14)0, 0(cid:15)} (no objects in the buffers) and E = {(cid:14)0, 0(cid:15), (cid:14)0, 1(cid:15), (cid:14)0, 2(cid:15), (cid:14)0, 3(cid:15)} (that is, we want to
keep b1 empty) S is not stabilizable w.r.t. E, since the exogenous action Ins can always interfere in the task of bringing the
system back to E. For example, consider the control Kb deﬁned as follows:

(cid:4)
(cid:3)
(cid:14)i, j(cid:15)
(cid:3)
(cid:4)
(cid:14)i, j(cid:15)

Kb

Kb

= M12 when i (cid:2) 1 and j < 3, and
= Proc when (i = 0 and j (cid:2) 1) or j = 3.

Intuitively, the above control directs the transfer of objects from buffer 1 to 2 whenever possible, and if that is not possible
it directs processing of objects in buffer 2 if that is possible. In Fig. 4, which shows the transition diagram between states,
the transitions by the control Kb are marked with M12 and Proc.

Consider the following trajectory consistent with the control system A K ,exo = (Sb, Ab, Φb, possb Kb ,exo ):

τ = (cid:14)0, 0(cid:15), Ins, (cid:14)1, 0(cid:15), Ins, (cid:14)2, 0(cid:15), M12, (cid:14)1, 1(cid:15), Ins, (cid:14)2, 1(cid:15), M12, (cid:14)1, 2(cid:15), Ins, (cid:14)2, 2(cid:15), M12, (cid:14)1, 3(cid:15), Proc.

It consists of a preﬁx (cid:14)0, 0(cid:15), Ins, . . . , M12 and a cycle (cid:14)1, 2(cid:15), . . . , Proc. In τ , no state in E is ever reached after the starting
state (cid:14)0, 0(cid:15). Similar trajectories can be found for any control and hence S is not stabilizable with respect to E.

On the other hand, S = {(cid:14)0, 0(cid:15)} is stabilizable w.r.t. E

objects in b1 at any time): Following Kb we can go from any of the states in Sb \ E
the execution of at most two control actions, while no exogenous actions are possible for those states.

(cid:7) = {0, 1, 2} × {0, 1, 2, 3} (that is, we want to have at most two
with

(cid:7) = {(cid:14)3, 0(cid:15), (cid:14)3, 1(cid:15), (cid:14)3, 2(cid:15), (cid:14)3, 3(cid:15)} to E

(cid:7)

1436

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

Fig. 4. The transition diagram of the buffer system Ab for the concrete instance (buffer capacity 3).

4. Limited interference and k-maintainability

As we mentioned in Section 1, our main intuition behind the notion of maintainability is that maintenance becomes
possible only if there is a window of non-interference from the environment during which maintenance is performed by
the agent. In other words, an agent k-maintains a condition c if its control (or its reaction) is such that if we allow it to
make the controlling actions without interference from the environment for at least k steps, then it gets to a state that
satisﬁes c within those k steps.

Our deﬁnition of maintainability has the following parameters:

(i) a system A = (S, A, Φ, poss),
(ii) a set of initial states S that the system may be initially in,
(iii) a set of desired states E that we want to maintain,
(iv) a set Aag ⊆ A of agent actions,
Aenv detailing exogenous actions, such that exo(s) ⊆ poss(s), and
(v) a function exo : S → 2
(vi) a control function K (mapping a relevant part of S to Aag) such that K (s) ∈ poss(s).

The next step is to formulate when the control K maintains E assuming that the system is initially in one of the states
in S. For that, we require that if in the system A K ,exo = (S, A, Φ, possK ,exo), where possK ,exo(s) = {K (s)} ∪ exo(s) restricts the
agent actions to the control K , the agent is in a state s that has been reached from any state in S (i.e., s ∈ Closure(S, A K ,exo)),
then given a window of non-interference from exogenous actions, it must get into some desired state during that window.
One of the importance of using the notion of closure here is that one can focus only on a possibly smaller set of states, rather than all
the states, thus limiting the possibility of an exponential blow-up—as warned in [36]—of the number of control rules.

Now a next question might be: Suppose the above condition of maintainability is satisﬁed, and while the control is
leading the system towards a desired state, an exogenous action happens and takes the system off that path. What then?
The answer is that the state the system will reach after the exogenous action will be a state from the closure. Thus, if the
system is then left alone (without interference from exogenous actions) it will be again on its way to a desired state. So
in our notion of maintainability, the control is always taking the system towards a desired state, and after any disturbance
from an exogenous action, the control again puts the system back on a path to a desired state.

We deﬁne the notion of unfolding a control as follows.

Deﬁnition 10 (Unfoldk(s, A, K )). Let A = (S, A, Φ, poss) be a system,
Unfoldk(s, A, K ) is the set of all sequences σ = s0, s1, . . . , sl where l (cid:3) k and s0 = s such that K (s j) is deﬁned for all
s j+1 ∈ Φ(s j, K (s j)), and if l<k, then K (sl) is undeﬁned.

let s ∈ S, and let K be a control for A. Then
j < l,

Intuitively, an element of Unfoldk(s, A, K ) is a sequence of states of length at most k + 1 that the system may go through
if it follows the control K starting from the state s. If the length of the sequence is less than k + 1, it means that at the last
state of the sequence K is undeﬁned and thus the sequence can not unfold further.

Fig. 5 illustrates this.
The above deﬁnition of Unfoldk(s, A, K ) is easily extended to the case when K is a non-deterministic control, meaning
∗) =

K (s) is a set of actions instead of a single action. In that case, we overload Φ and for any set of actions a
(cid:5)

, deﬁne Φ(s, a

∗

a∈a∗ Φ(s, a).

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1437

Fig. 5. Let K be the policy of doing action a in states b, c, d and f . Unfold3(b, A, K ) = {(cid:14)b, c, d, h(cid:15), (cid:14)b, g(cid:15)} and Unfold3(c, A, K ) = {(cid:14)c, d, h(cid:15)}.

Fig. 6. Let S = {b} and E = {h}. A 3-maintainable policy with respect to them will be to do a in states b, c and d.

We now deﬁne the notion of k-maintainability, which can be used to verify the correctness of a control.

Deﬁnition 11 (k-maintainability). Given a system A = (S, A, Φ, poss), a set of agents action Aag ⊆ A, and a speciﬁcation of
exogenous action occurrence exo, we say that a control4 K for A w.r.t. Aag k-maintains S ⊆ S with respect to E ⊆ S, where
k (cid:2) 0, if for each state s ∈ Closure(S, A K ,exo) and each sequence σ = s0, s1, . . . , sl in Unfoldk(s, A, K ) with s0 = s, it holds that
{s0, . . . , sl} ∩ E (cid:4)= ∅.

We say that a set of states S ⊆ S (resp. A, if S = S) is k-maintainable, k (cid:2) 0, with respect to a set of states E ⊆ S, if
there exists a control K which k-maintains S w.r.t. E. K is then referred to as the witnessing control function. Furthermore,
S (resp. A) is called maintainable w.r.t E, if S (resp. A) is k-maintainable w.r.t. E for some k (cid:2) 0.

In the following we will omit explicit mention of Aag, S, and E for control functions and maintainability if they are clear

from the context.

Intuitively, the condition {s0, s1, . . . , sl} ∩ E (cid:4)= ∅ above means that we can get from a state s0 outside E to a state in
E within at most k transitions—where each transition is dictated by the control K —if the world were to unfold as in
s0, s1, . . . , sl, where s0 = s. In particular, 0-maintainability means that the agent has nothing to do: after any exogenous
action happening, the system will be in a state from E. Therefore, a trivial control K will do which is undeﬁned on every
state.

Note that in the above deﬁnition we no longer require aliveness. If a non-alive state is reached while unfolding, the

unfolding stops there and the deﬁnition of k-maintainability requires that a goal state (from E) is reached by then.

(cid:7)}, that exo(s) = {e} iff s = f and that exo(s) = ∅
Example 3. Reconsider the system A in Fig. 1. Let us assume that Aag = {a, a
otherwise. Suppose now that we want a 3-maintainable control policy for S = {b} w.r.t. E = {h}. Clearly, such a control policy
K is to take a in b, c, and d. Indeed, Closure({b}, A K ,exo) = {b, c, d, h} and Unfold3(b, A, K ) = {(cid:14)b, c, d, h(cid:15)}, Unfold3(c, A, K ) =
{(cid:14)c, d, h(cid:15)}, and Unfold3(d, A, K ) = {(cid:14)d, h(cid:15)}; furthermore, each sequence contains h. See Fig. 6.

Suppose now, as shown in Fig. 7, there is an exogenous action e that can take from c to f . Then, no k-maintainable
control policy for S = {b} w.r.t. E = {h} exists for any k (cid:2) 0. Indeed, the agent can always end up in the dead-end g. If,
(cid:7) ∈ poss(g), a 3-maintainable control policy K is K (s) = a for s ∈ {b, c, d, f } and
however, in addition Φ(g, a
K (g) = a

(cid:7)) = { f , h} and a

.

(cid:7)

4 Note that here only K (s) for s ∈ Closure(S, A K ,exo) is of relevance. For all other s, K (s) can be arbitrary or undeﬁned.

1438

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

Fig. 7. Let S = {b} and E = {h}. No 3-maintainable policy with respect to them exists.

Example 4 (Buffer example (cont’d)). Earlier we showed that in Ab, S = {(cid:14)0, 0(cid:15)} is not stabilizable w.r.t. E = {(cid:14)0, 0(cid:15), (cid:14)0, 1(cid:15), (cid:14)0, 2(cid:15),
(cid:14)0, 3(cid:15)}. Thus, we might ask whether S is at least maintainable w.r.t. E? The answer is positive: For the worst case system
state, (cid:14)3, 3(cid:15), a control can move the system to (cid:14)3, 0(cid:15) (by three transitions executing Proc) without interfering occurrences
of exogenous actions. If there then are three further transitions without interference, the control can apply M12 three times
and effect the state (cid:14)0, 3(cid:15). This implies that S is 6-maintainable w.r.t. E. We can, with a similar argument show that A is
9-maintainable w.r.t. {(cid:14)0, 0(cid:15)}. A similar argument can be made with respect to the control Kb of Example 2.

However, we have that A is not maintainable w.r.t., for example, {(cid:14)0, 3(cid:15)} (Since we cannot go from, for example, {(cid:14)0, 0(cid:15)},

to {(cid:14)0, 3(cid:15)} with control actions only).

As the above example points out, it is possible that S is maintainable but not stabilizable with respect to E. The converse
is also possible. In other words, in certain cases we may have a system where a given S is stabilizable with respect to a set
E, but yet is not maintainable. This happens when every path between a state in S and a state in E involves at least one
exogenous action. In that case the agent, who does not have control over the exogenous actions, can not on its own make
the transition from a state in S to a state in E. However, often for each exogenous action there are equivalent (in terms of
effects) agent actions. In that case, any stabilizable system is also maintainable.

We note the following monotonicity property of k-maintainability, which is an easy consequence of the deﬁnition:

Proposition 2. Suppose that for a system A = (S, A, Φ, poss), a set of agents action Aag ⊆ A, and a speciﬁcation of exogenous action
(cid:7) ⊆ Closure(S, A K ,exo) with
occurrence exo, the control function K k-maintains S ⊆ S w.r.t. E ⊆ S. Then, K also k-maintains any set S
respect to any set E

(cid:7) ⊇ E.

4.1. An alternative characterization of k-maintainability

The characterization of stability and stabilizability in Section 2 is based on imposing conditions on trajectories obtained
from the transition graph of a system. Such a characterization has the advantage that it is amenable to developing temporal
operators that can express more general conditions.

In contrast, the deﬁnition of maintainability in Deﬁnition 11 is not based on trajectories. Nonetheless, one can give an
alternative characterization based on trajectories, which we do next. To bridge from ﬁnite trajectories (which are relevant
with respect to maintainability), to inﬁnite ones as in Deﬁnition 2, we consider for each system A = (S, A, Φ, poss) an
, for each state s we have
extension, A
Φ(s, anop) = {s} and anop ∈ poss(s) if poss(s) = ∅ in A. Informally, A

, which results by adding a fresh environmental action anop such that in A

adds inﬁnite loops to halting states of A.

∞

∞

∞

Proposition 3. Given a system A = (S, A, Φ, poss), a set of agents action Aag ⊆ A, a speciﬁcation of exogenous action occurrence
exo, and a set of states E, a set of states S is k-maintainable with respect to E, k (cid:2) 0, if and only if there exists a control K for A
∞
w.r.t. Aag such that for each state s in S and every trajectory of form τ = s0, a1, s1, a2, . . . , a j, s j, a j+1, . . . consistent with A
K ,exo and
s0 = s, it holds that {ai+1, . . . , ai+k} ⊆ Aag or ai+k = anop for some i (cid:2) 0 implies that {si, . . . , si+k} ∩ E (cid:4)= ∅.

Proof. For the only if direction, suppose that S is k-maintainable w.r.t. E, witnessed by the control function K . Let s ∈ S
∞
K ,exo such that s0 = s and {ai+1, . . . , ai+k} ⊆ Aag or ai+k = anop,
and τ = s0, a1, s1, a2, . . . , a j, s j, a j+1, . . . be consistent with A
∞
for some i (cid:2) 0. Then, we have si ∈ Closure(S, A
K ,exo). If k = 0, then since K is a witnessing control, we have si ∈ E, and thus
{si, si+1, . . . , si+k} ∩ E (cid:4)= ∅ holds. Consider thus k > 0. If ai+k ∈ Aag (which implies {ai+1, . . . , ai+k} ⊆ Aag), then the sequence
si, si+1, . . . , si+k belongs to Unfoldk(si, A, K ). Since K is a witnessing control function, we again have {si, si+1, . . . , si+k} ∩ E (cid:4)=
∞
∅. Otherwise, if ai+k = anop, let l (cid:2) 1 be the least index such that al = anop. By deﬁnition of A
K ,exo, we have that K (sl−1) is
undeﬁned. Hence, the sequence σ = sl−1 belongs to Unfoldk(sl−1, A, K ). Since K is a control, it follows that sl−1 ∈ E. Since
s j = sl−1 for each j (cid:2) l, and in particular si+k = sl−1, it follows again that {si, si+1, . . . , si+k} ∩ E (cid:4)= ∅. This proves the only if
direction.

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1439

Conversely, suppose K is a control for A w.r.t. Aag such that for each s ∈ S and trajectory τ = s0, a1, s1, a2, . . . , a j, s j,
∞
K ,exo and s0 = s, it holds that {ai+1, . . . , ai+k} ⊆ Aag or ai+k = anop for some i (cid:2) 0 implies
a j+1, . . . consistent with A
that {si, si+1, . . . , si+k} ∩ E (cid:4)= ∅. We claim that K witnesses k-maintainability of S w.r.t. E. Towards a contradiction, sup-
∞
K ,exo, that there is some state s ∈ S and trajectory τ =
pose the contrary. Hence, it follows from the deﬁnition of A
∞
s0, a1, s1, a2, . . . , a j, s j, a j+1, . . . consistent with A
K ,exo)
and s j, s j+1, . . . , s j+l is in Unfoldk(s j, A, K ), where l (cid:3) k, but E ∩ {s j, . . . , s j+l} = ∅.

∞
K ,exo and s0 = s, such that for some j (cid:2) 0 we have s j ∈ Closure(S, A

By deﬁnition of Unfoldk(s j, A, K ), we have that {a j+1, . . . , a j+l−1} ⊆ Aag and that a j+l = a j+l+1 = · · · = a j+k = anop.
By hypothesis, E ∩ {s j, . . . , s j+k} (cid:4)= ∅ holds. Thus, we conclude that E ∩ {s j+l+1, . . . , s j+k} (cid:4)= ∅ must hold, and hence l < k.
However, by deﬁnition of Φ(s, anop) we have s j+l = s j+l+1 = · · · = s j+k. This implies that E ∩ {s j, . . . , s j+l} (cid:4)= ∅, which is a
contradiction.

This proves that K witnesses k-maintainability of S w.r.t. E. (cid:2)

While this result shows that we could equally well have developed our notion of k-maintainability on the basis of
trajectories, in the rest of this paper we shall stick to the setting which uses closure and unfolding. We ﬁnd the latter more
intuitive, as well as more convenient for designing algorithms and for proofs. Furthermore, this setting requires no special
handling of possible ﬁnite trajectories, which complicates matters as becomes apparent from Proposition 3.

This alternative characterization suggests how to express the notion of k-maintainability using existing temporal logics
when a distinction can be made5 between states that are reached through an agent’s actions and states that are reached by
an exogenous action. To make this distinction, let us assume that the latter kind of states have the ﬂuent interfered as true
and the former have it as false. Now, let Step[k](φ) be a shorthand for the formula

φ ∨ (cid:9)φ ∨ (cid:9) (cid:9) φ ∨ · · · ∨ (cid:9) · · · (cid:9)
(cid:6) (cid:7)(cid:8) (cid:9)

φ

k

where the last subformula involves k consecutive (cid:9)’s. Intuitively, the formula Step[k](φ) means that φ is true within k
steps. Now the last part of Proposition 3, ignoring the issue of anop actions (for simplicity), is as follows:

for each state s in S and every trajectory of form τ = s0, a1, s1, a2, . . . , a j, s j, a j+1, . . . consistent with A
{ai+1, . . . , ai+k} ⊆ Aag for some i (cid:2) 0 implies that {si, . . . , si+k} ∩ E (cid:4)= ∅.

∞
K ,exo and s0 = s,

This can be expressed in LTL as φS ⇒ (cid:2)(¬Step[k](interfered) ⇒ Step[k](φE )), or equivalently φS ⇒ (cid:2)(Step[k](interfered ∨

φE )), where φS and φE are propositional formulas which described the states in S and E, respectively.

Using the above formula, k-maintainability can be written as follows:

There exists a control K for A w.r.t. Aag such that for each state s in S and every trajectory of
s0, a1, s1, a2, . . . , a j, s j, a j+1, . . . consistent with A
((cid:2)Step[k](interfered ∨ φE )).

form τ =
∞
K ,exo and s0 = s, the trajectory satisﬁes the temporal formula φS ⇒

To capture the complete deﬁnition by a temporal formula, one needs branching time temporal operators akin to A, like
the operator Aπ in [9] meaning that “for all paths following the policy under consideration”. In that case, the speciﬁcation
would be Aπ ((cid:2)(φS ⇒ (cid:2)(Step[k](interfered ∨ φE )))). Note that here we need (cid:2) in between Aπ and φS to indirectly account
for the phrase “for each state s in S”.

In upcoming sections, we discuss the above characterization in the context of general control generation algorithms that
work with arbitrary temporal speciﬁcations. However, we use the characterization of k-maintainability in Deﬁnition 11 as
it matches more closely with our algorithms, and does not necessitate deﬁning a compilation that eliminates exogenous
actions and introduces the new ﬂuent interfered and proving the equivalence of that compilation.

5. Polynomial time methods to construct k-maintainable controls

Now that we have deﬁned the notion of k-maintainability, our next step is to show how some k-maintainable control can
be constructed in an automated way. We start with some historical background. In the program speciﬁcation and synthesis
literature, there have been a number of works, e.g., [19,49,59,60] to automatically synthesize programs similar to our control
policies from given temporal logic speciﬁcations. Although these algorithms can accept richer goals, they all either allude
to worst case exponential nature of their algorithms or prove that the complexity is exponential or even higher. None of
them study special classes of speciﬁcations with lower complexity of constructing control. We discuss these papers and
their complexity results in Section 8.2.

5 Such distinctions can be made by compiling a system, a set of agent actions, a speciﬁcation of exogenous action occurrence, a set of goal states and a
set of initial states to an automata that eliminates transitions due to exogenous actions but records their presence through the ﬂuent interfered. We discuss
such a compilation in Section 8.2.1.

1440

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

There has been extensive use of situation control rules [26] and reactive control in the AI literature. But there have been
less efforts in the AI literature to deﬁne correctness of such control rules [8],6 and to automatically construct correct control
rules for general goals [10,37,41].7 In [42], it is suggested that in a control rule of the form: “if condition c is satisﬁed then
do action a”, the action a is the action that leads to the goal from any state where the condition c is satisﬁed. In [8] a formal
meaning of “leads to” is given as: for all states s that satisfy c, a is the ﬁrst action of a minimal cost plan from s to the goal.
Using this deﬁnition, an algorithm is presented in [52] to construct k-maintainable controls. This algorithm is sound but not
complete, in the sense that it generates correct controls only, but there is no guarantee that it will ﬁnd always a control if
one exists.

In [10,41], an algorithm to construct control with respect to linear temporal logic goals is given. This algorithm is based
on progressing linear temporal formulas. The worst case complexity of the algorithm is given as double exponential with
respect to the number of subformulas of the goal speciﬁcation f , assuming a ﬁxed number of states. Note that the temporal
representation of k-maintainability will have subformulas with k nested operators (cid:9). However, no studies regarding the
complexity of speciﬁc goal speciﬁcations were done earlier. With the help of one of the authors of [10,41] we explored how
well the algorithms in [10,41] will do with respect to our goal and found that by the using the algorithm as given in [10,41]
the complexity will be exponential in the size of k. In Section 8.2.1 we will discuss this in more detail.

In the following, we overcome the problems one faces in the above mentioned approaches and give a sound and complete
polynomial time algorithm for constructing k-maintainable control policies. In fact, the algorithm works in linear time for
k bounded by a constant, and can be adapted to a linear time algorithm for maintainability, i.e., where k is arbitrary but
ﬁnite.

We provide it in two steps: First we consider the case when the transition function Φ is deterministic, and then we
generalize to the case where Φ may be non-deterministic. In each case, we present different methods, which illustrates our
discovery process and also gives a better grasp of the ﬁnal algorithm. We ﬁrst present an encoding of our problem as a
propositional theory and appeal to propositional SAT solvers to construct the control. As it turns out, this encoding is in
a tractable fragment of SAT, for which specialized solvers (in particular, Horn SAT solvers) can be used easily. Finally, we
present a direct algorithm distilled from the previous methods.

The reasoning behind this line of presentation is the following:

(i) It illustrates the methodology of using SAT and Horn SAT encodings to solve problems;
(ii) the encodings allow us to quickly implement and test algorithms;
(iii) the proof of correctness mimics the encodings; and
(iv) we can exploit known complexity results for Horn SAT to determine the complexity of our algorithm, and in particularly

to establish tractability.

As for (ii), we can make use of answer set solvers such as DLV [29,45] or Smodels [53,65] which extend Horn logic
programs by non-monotonic negation. These solvers allow eﬃcient computation of the least model and some maximal
models of a Horn theory, and can be exploited to construct robust or “small” controls, respectively.

Just for clariﬁcation, our approach of going from a SAT encoding to a Horn SAT encoding to a procedural algorithm is
not to suggest that one is better or more eﬃcient. Rather, it shows the usefulness of the general methodology to go from
a logical speciﬁcation (i.e., a SAT encoding in this case) to a procedural algorithm via transformations (Horn SAT encoding)
that help us to prove the polynomial nature of the algorithm.

The problem we want to solve, which we refer to as k-Maintain, has the following input and output:

Input: An input I is a system A = (S, A, Φ, poss), sets of states E ⊆ S and S ⊆ S, a set Aag ⊆ A, a function exo, and

an integer k (cid:2) 0.

Output: A control K such that S is k-maintainable with respect to E (using the control K ), if such a control exists.

Otherwise the output is the answer that no such control exists.

We assume here that the functions poss(s) and exo(s) can be eﬃciently evaluated; e.g., when both functions are given

by their graphs (i.e., in a table).

5.1. Deterministic transition function Φ(s, a)

We start with the case of deterministic transitions, i.e., Φ(s, a) is a singleton set {s

notation, we simply will write Φ(s, a) = s

(cid:7)

in this case.

(cid:7)} whenever nonempty. In abuse of

6 Here we exclude the works related to MDPs as it is not known how to express the kind of goal we are interested in—such as k-maintenance goals—using

reward functions.

7 In recent years, some planning algorithms and systems have been developed [13,14,18,39,40,44] that generate control rules for particular classes of

goals.

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1441

Our ﬁrst algorithm to solve k-Maintain will be based on a reduction to propositional SAT solving. Given an input I for
k-Maintain, we construct a SAT instance sat(I) in polynomial time such that sat(I) is satisﬁable if and only if the input I
allows for a k-maintainable control, and that the satisfying assignments for sat(I) encode possible such controls.

In our encoding, we shall use for each state s ∈ S propositional variables s0, s1, . . . , sk. Intuitively, si will denote that
there is a path from state s to some state in E using only agent actions and at most i of them, to which we refer as “there
is an a-path from s to E of length at most i”.

The encoding sat(I) contains the following formulas:

(0) For all s ∈ S, and for all j, 0 (cid:3) j < k:

s j ⇒ s j+1
(1) For all s ∈ E ∩ S:

s0

(2) For any two states s, s
(cid:7)
sk ⇒ s
k

(cid:7) ∈ S such that Φ(a, s) = s

(cid:7)

for some action a ∈ exo(s):

(3) For any state s ∈ S \ E and all i, 1 (cid:3) i (cid:3) k:
(cid:7)
i−1,

si ⇒

(cid:10)

s

s(cid:7)∈PS(s)
where PS(s) = {s
(4) For all s ∈ S \ E:

(cid:7) ∈ S | ∃a ∈ Aag ∩ poss(s): s

(cid:7) = Φ(a, s)};

sk
(5) For all s ∈ S \ E:

¬s0

(cid:7)

The intuition behind the above encoding is as follows. The clauses in (0) state that if there is an a-path from s to E of
length at most j then, logically, there is also an a-path of length at most j + 1. The clauses in (1) say that for states s in
S ∩ E, there is an a-path of length 0 from s to E. Next, (4) states that for any starting state s in S outside E, there is an
a-path from s to E of length at most k, and (5) states that for any state s outside E, there is no a-path from s to E of length
0. The clauses in (3) state that if, for any state s, there is an a-path from s to E of length at most i, then for some possible
to E of length at most i − 1. When looking for
agent action a and successor state s
k-maintainable controls the clauses in (2) take into account the possibility that s may be in the closure. If indeed s is in
the closure and there is an a-path from s to E of length at most k, then the same must be true with respect to the states
(cid:7)
s
reachable from s using exogenous actions. When looking for non-deterministic control they play a role in computing
maximal non-deterministic controls. The role of each of the above clauses become more clear when relating the models of
sat(I) with controls that k-maintain.

= Φ(a, s), there is an a-path from s

Given any model M of sat(I), we can extract a desired control K from it by deﬁning K (s) = a for all s outside E with sk
is closer to E than s is. In case of multiple

(cid:7) = Φ(s, a) and s

true in M, where a is a possible agent action in s such that s
possible a and s

, one a can be arbitrarily picked. Otherwise, K (s) is left undeﬁned.

In particular, for k = 0, only the clauses from (1), (2), (4) and (5) do exist. As easily seen, sat(I) is satisﬁable in this case
if and only if S ⊆ E and no exogenous action leads outside E, i.e., the closure of S under exogenous actions is contained
in E. This means that no actions of the agent are required at any point in time, and we thus obtain the trivial 0-control K
which is undeﬁned on all states, as desired.

(cid:7)

(cid:7)

(cid:7)

The next result states that the SAT encoding works properly in general.

Proposition 4. Let I consist of a system A = (S, A, Φ, poss) where Φ is deterministic, a set Aag ⊆ A, sets of states E ⊆ S and S ⊆ S,
an exogenous function exo, and an integer k. For any model M of sat(I), let C M = {s ∈ S | M |(cid:8) sk}, and for any state s ∈ C M let (cid:8)M (s)
denote the smallest index j such that M |(cid:8) s j (i.e., s0, s1, . . . , s j−1 are f alse and s j is true), which we call the level of s w.r.t. M. Then,

(i) S is k-maintainable w.r.t. E iff sat(I) is satisﬁable.
(ii) Given any model M of sat(I), the partial function K

(cid:11)
a ∈ Aag ∩ poss(s) | Φ(s, a) = s

, s
is a valid non-deterministic control for A w.r.t. Aag;

+
M (s) =

K

(cid:7)

+
M

: S → 2
(cid:7) ∈ C M , (cid:8)M (s

Aag deﬁned on C M \ E such that
(cid:12)
) < (cid:8)M (s)

,

(cid:7)

(iii) any control K which reﬁnes K

+
M for some model M of sat(I) k-maintains S w.r.t. E.

The proof of this proposition can be easily obtained by adapting the proof of Proposition 6.

1442

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

5.1.1. Horn SAT encoding

While sat(I) is constructible in polynomial time from I , we can not automatically infer that solving k-Maintain is poly-
nomial, since SAT is a canonical NP-hard problem. However, a closer look at the structure of the clauses in sat(I) reveals
that this instance is solvable in polynomial time. Indeed, it is a reverse Horn theory; i.e., by reversing the propositions, we
obtain a Horn theory. Let us use propositions si whose intuitive meaning is converse of the meaning of si . Then the Horn
theory corresponding to sat(I), denoted sat(I), is as follows:

(0) For all s ∈ S and j, 0 (cid:3) j < k:

s j+1 ⇒ s j.
(1) For all s ∈ E ∩ S:

s0 ⇒ ⊥.

(2) For any states s, s

(cid:7) ∈ S such that s

(cid:7) = Φ(a, s) for some action a ∈ exo(s):

(cid:7)
s
k

⇒ sk.

(3) For any state s ∈ S \ E, and for all i, 1 (cid:3) i (cid:3) k:

(cid:13) (cid:14)

(cid:15)

s

(cid:7)
i−1

⇒ si,

s(cid:7)∈PS(s)

(cid:7) ∈ S | ∃a ∈ Aag ∩ poss(s): s

(cid:7) = Φ(a, s)}.

where PS(s) = {s
(4) For all s ∈ S \ E:

sk ⇒ ⊥.

(5) For all s ∈ S \ E:

s0.

Here, ⊥ denotes falsity. We then obtain a result similar to Proposition 4, and the models M of sat(I) lead to k-maintainable
controls, which we can construct similarly; just replace in part (ii) C M with C M = {s ∈ S | M (cid:4)|(cid:8) sk}. Notice that C M coincides
with the set of states C M for the model M of sat(I) such that M |(cid:8) p iff M (cid:4)|(cid:8) p, for each atom p.

We now illustrate the above Horn encoding with respect to an example.

Example 5. Consider the system A = (S, A, Φ, poss), where S = {b, c, d, f , g, h}, A = {a, a
sition function Φ was shown in Fig. 1, where Φ(s, a) = s
actions that label arcs leaving s.

iff an arc s → s

(cid:7)

(cid:7)

(cid:7), e}, and the (deterministic) tran-
labeled with a is present and poss(s) are all

For A = {a, a

(cid:7)} and exo(s) = {e} iff s = f and exo(s) = ∅ otherwise, this leads for S = {b}, E = {h}, and k = 3 to the

following Horn encoding sat(I):

(From 0)

(From 1)
(From 2)

(From 3)

b1 ⇒ b0.
d1 ⇒ d0.
g1 ⇒ g0.

b2 ⇒ b1.
d2 ⇒ d1.
g2 ⇒ g1.

b3 ⇒ b2.
d3 ⇒ d2.
g3 ⇒ g2.

c1 ⇒ c0.
f 1 ⇒ f 0.
h1 ⇒ h0.

c2 ⇒ c1.
f 2 ⇒ f 1.
h2 ⇒ h1.

c3 ⇒ c2.
f 3 ⇒ f 2.
h3 ⇒ h2.

g3 ⇒ f 3.

c0 ∧ f 0 ⇒ b1.
d0 ⇒ c1.
h0 ⇒ d1.
h0 ⇒ f 1.
g1.

c1 ∧ f 1 ⇒ b2.
d1 ⇒ c2.
h1 ⇒ d2.
h1 ⇒ f 2.
g2.

c2 ∧ f 2 ⇒ b3.
d2 ⇒ c3.
h2 ⇒ d3.
h2 ⇒ f 3.
g3.

(From 4)

(From 5)

b3 ⇒ ⊥.

b0.

c0.

d0.

f 0.

g0.

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1443

Fig. 8. Computing the least model: [6] From 5 we get b0, c0, d0, f 0, g0; [7] From 3 we get g1, g2, g3; [8] From 6 and 3 we get b1, c1; [9] From 7 and 2 we
get f 3; [10] From 0 and 9 we get f 2; [11] From 0 and 10 we get f 1; [12] From 3, 8 and 11 we get b2.

This theory has the least model

M = {g3, g2, g1, g0, f 3, f 2, f 1, f 0, b2, b1, b0, c1, c0, d0};

Hence, C M = {b, c, d, h}, which gives rise to the non-deterministic control K
+(s) is undeﬁned for s ∈ { f , g, h}. In this case, there is a single control K reﬁning K

+(s) = {a} for s ∈ {b, c, d} and
, which has K (s) = a for s ∈ {b, c, d}
K
and is undeﬁned otherwise. This is intuitive: The agent must reach h, and has to avoid taking a
in b since then it might
arrive at the no-good state g. Thus, she has to take a in b and, as the only choice, in the subsequent states c and d. Also, we
might not add any state apart from b, c, and d without losing 3-maintainability. In this particular case, M is also maximal
on the propositions s3, where s ∈ S \ E = {b, c, d, f , g}: By (4), we can not add b3, and by (0) and the clauses c2 ∧ f 2 ⇒ b3
and d1 ⇒ c2 in (3) then also neither c3 nor d3. Thus, the above control K is also smallest and, in fact, the only one possible
for 3-maintainability.

such that K
+

+

(cid:7)

As computing a model of a Horn theory is a well-known polynomial problem [25], we thus obtain the following result.

Theorem 5. Under deterministic state transitions, problem k-Maintain is solvable in polynomial time. (cid:2)

An interesting aspect of the above is that, as well-known, each satisﬁable Horn theory T has the least model, M T ,
which is given by the intersection of all its models. Moreover, the least model is computable in linear time, cf. [25,50].
This model not only leads to a k-maintainable control, but also leads to a maximal control, in the sense that the control is
. This
deﬁned on a greatest set of states outside E among all possible k-maintainable controls for S
gives a clear picture of which other states may be added to S while k-maintainability is preserved; namely, any states in
C M T . Furthermore, any control K computed from M T applying the method in Proposition 4 (using C M T ) works for such an
extension of S as well.

w.r.t. E such that S ⊆ S

(cid:7)

(cid:7)

On the other hand, intuitively a k-maintainable control constructed from some maximal model of sat(I) with respect to
the propositions sk is undeﬁned to a largest extent, and works merely for a smallest extension. We may generate, starting
from M T , such a maximal model of T by trying to ﬂip ﬁrst, step by step all propositions sk which are f alse to true, as well
as other propositions entailed. In this way, we can generate a maximal model of T on {sk | s ∈ S \ E} in polynomial time,
from which a “lean” control can also be computed in polynomial time.

5.2. Non-deterministic transition function Φ(s, a)

We now generalize our method for constructing k-maintainable controls to the case in which transitions due to Φ may
be non-deterministic. As before, we ﬁrst present a general propositional SAT encoding, and then rewrite to a propositional
Horn SAT encoding. To explain some of the notations, we need the following deﬁnition, which generalizes the notion of an
a-path to the non-deterministic setting.

Deﬁnition 12 (a-path). We say that there exists an a-path of length at most k (cid:2) 0 from a state s to a set of states S
either s ∈ S
, or s /∈ S
of length at most k − 1 from s

, k > 0 and there is some action a ∈ Aag ∩ poss(s) such that for every s

, if
(cid:7) ∈ Φ(s, a) there exists an a-path

to S

.

(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7)

In the following encoding of an instance I of problem k-Maintain to SAT, referred to as sat

(cid:7)(I), si will again intuitively
denote that there is an a-path from s to E of length at most i. The proposition s_ai , i > 0, will denote that for such s there
(cid:7)(I) has again groups (0)–(5)
is an a-path from s to E of length at most i starting with action a (∈ poss(s)). The encoding sat
of clauses as follows:

1444

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

(0), (1), (4) and (5) are the same as in sat(I).
(2) For any state s ∈ S and s

such that s

(cid:7)

(cid:7) ∈ Φ(a, s) for some action a ∈ exo(s):

(cid:7)
sk ⇒ s
k

(cid:16)

(3) For every state s ∈ S \ E and for all i, 1 (cid:3) i (cid:3) k:
a∈Aag∩poss(s) s_ai ;

(3.1) si ⇒
(3.2) for every a ∈ Aag ∩ poss(s) and s
(cid:7)
i−1
(3.3) for every a ∈ Aag ∩ poss(s), if i < k:

s_ai ⇒ s

(cid:7) ∈ Φ(s, a):

;

s_ai ⇒ s_ai+1.

Group (2) above is very similar to group (2) of sat(I) in the previous subsection. The only change is that we now have
(cid:7) = Φ(a, s). The main difference is in group (3). We now explain those clauses. The clauses in (3.1)
(cid:7) ∈ Φ(a, s) instead of s
s
and (3.2) together state that if there is an a-path from s to E of length at most i, then there is some possible action a for
the agent, such that for each state s
to E of length
at most i − 1. The clauses s_ai ⇒ s_ai+1 in (3.3) say that on a longer a-path from s the agent must be able to pick a also.
Notice that there are no formulas in sat
in the same state s, and thus we
have a non-deterministic control; however, we can always reﬁne it easily to a control.

(cid:7)(I) which forbid to pick different actions a and a

that potentially results by taking a in s, there must be an a-path from s

(cid:7)

(cid:7)

(cid:7)

Proposition 6. Let I consist of a system A = (S, A, Φ, poss), a set Aag ⊆ A, sets of states E, S ⊆ S, an exogenous function exo, and
(cid:7)(I), let C M = {s ∈ S | M |(cid:8) sk}, and for any state s ∈ C M \ E let (cid:8)M (s) denote the smallest index j
an integer k. For any model M of sat
such that M |(cid:8) s_a j for some action a ∈ Aag ∩ poss(s), which we call the a-level of s w.r.t. M. Then,

(i) S is k-maintainable w.r.t. E iff sat
(ii) given any model M of sat

(cid:7)(I) is satisﬁable;
(cid:7)(I), the partial function K

+
M

: S → 2

Aag which is deﬁned on C M \ E by

K

+
M (s) = {a | M |(cid:8) s_a(cid:8)M (s)}

is a valid non-deterministic control; and

(iii) any control K which reﬁnes K

+
M for some model M of sat

(cid:7)(I) k-maintains S w.r.t. E.

Proof. Since the if direction of (i) follows from (ii) and (iii), it is suﬃcient to show the only if direction of (i) and both (ii)
and (iii).

As for the only if direction of (i), suppose S is k-maintainable w.r.t. E. Then there exists a control K such that for each
state s ∈ Closure(S, A K ,exo), and for each sequence σ = s(0), s(1), . . . , s(l) in Unfoldk(s, A, K ) where s(0) = s, {s(0), . . . , s(l)} ∩ E (cid:4)=
∅. We now construct an interpretation M for sat

(cid:7)(I) as follows.

For each s ∈ Closure(S, A K ,exo), and each sequence σ = s(0), s(1), . . . , s(l) in Unfoldk(s, A, K ) with s = s(0), let iσ ((cid:2) 0) be
the smallest index i such that s(i) ∈ E, and let i
is the length of the longest
path in the tree with root s where each node n not in E is sprouted by taking the control action K (n) and adding each state
∗ > 0, to s_ai∗ , s_ai∗+1, . . . , s_ak, where K (s) = a. All
in Φ(n, K (n)) as a child. Then, we assign true to si∗ , si∗+1,. . . , sk and, if i
other propositions are assigned f alse in M. We now argue that M is a model of sat(I).

be the maximum over all iσ for s. Intuitively, i

∗

∗

(cid:7)
k generated in (2). If sk is true, then s ∈ Closure(S, A K ,exo) by construction. In this case, for any s

It is straightforward to see that M satisﬁes the formulas generated by (0), (1), (4) and (5). Now consider the formulas
(cid:7) ∈ Φ(a, s) of an
sk ⇒ s
(cid:7)
(cid:7) ∈ Closure(S, A K ,exo), and since K k-maintains S w.r.t. E, s
i is true in M for some i (cid:3) k which
exogenous action a, we have s
(cid:7)
implies, by construction, that s
k is assigned true in M. Let us ﬁnally consider the formulas generated in (3). If si , where
s ∈ S \ E, is assigned true in M for some i ∈ {1 (cid:3) i (cid:3) k}, then s ∈ Closure(S, A, K exo) holds by construction of M. Since K is
a k-maintaining control and s /∈ E, we must have K (s) deﬁned and thus, by construction of M, we have s_K (s)i assigned
true in M. Since K (s) ∈ Aag ∩ poss(s), the clause (3.1) is thus satisﬁed. Furthermore, each clause in (3.2) is satisﬁed when
a (cid:4)= K (s), since then sai
is true in M and thus, by construction, also
(cid:7) ∈ Φ(s, a) belongs to Closure(S, A, Kexo). Let, for each sequence σ (cid:7) = s(0),
si . Since K is k-maintaining control, every state s
(cid:7)
s(1), . . . , s(l) in Unfoldk(s, A, K ) such that s(0) = s
, the sequence P (σ ) = s(0), s(1), . . . , s(i) be the shortest preﬁx of σ such
that s(i) ∈ E (notice that i < k). Then, the sequence s, P (σ ) is a preﬁx of some sequence in Unfold(s, A, K ). Hence, it follows
that in the construction of M, the number i
. Thus, by construction of M, it follows that
for s is larger than the one for s
(cid:7)
s
i−1 is assigned true in M. This means that the formulas in (3.2) are satisﬁed in M. Finally, the clauses (3.3) are clearly
satisﬁed in M by construction of M. Thus, M is a model of sat

is assigned f alse in M. For a = K (s), proposition sai

(cid:7)(I), which means that sat

(cid:7)(I) is satisﬁable.

∗

(cid:7)

To show (ii), let us assume that sat

on C M \ E by K
By clause (3.1), and the deﬁnition of C M , (cid:8)M , and K

+
M (s) = {a | M |(cid:8) s_a(cid:8)M (s)}. We thus have to show that K

+
M this is immediate.

(cid:7)(I) has a model M, and consider the partial function K
: S → 2
+
M (s) (cid:4)= ∅ when K

+
M (s) ⊆ poss(s) and K

Aag which is deﬁned
+
M (s) is deﬁned.

+
M

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1445

To show (iii), let K be any control which reﬁnes K

(cid:7)(I). Let the distance dK (s, S) of a state s
from the set of states S be as in the proof of Proposition 4, i.e., the minimum number of transitions—through exogenous
actions and/or control actions dictated by the control K —needed to reach s from any state in S.

+
M for some model M of sat

We will show, by using induction on d(s, S) (cid:2) 0, that for every state s ∈ Closure(S, A K ,exo) and every sequence σ =
s(0), s(1), . . . , s(l) with s = s(0) in Unfoldk(s, A, K ), the set {s(0), . . . , s(l)} intersects with E and that M |(cid:8) sk (i.e., s ∈ C M ). This
proves that K k-maintains S w.r.t. E.

The base case, d(s, S) = 0, is about states s ∈ S. From the formulas in (0), (1), and (4) we have M |(cid:8) sk for every such
state s. Consider any sequence σ = s(0), s(1), . . . , s(l) in Unfoldk(s, A, K ) such that s = s(0). If s ∈ E, then we must have l = 0,
and {s(0), . . . , s(l)} ∩ E (cid:4)= ∅. Otherwise, M |(cid:8) sak where a = K (s). We then have s(1) ∈ Φ(s, a), and thus by our construction
(l)
of K and the clauses in (3.2) we have that M |(cid:8) s
k−l are all
assigned true in M. If k = l, it follows from the clauses in (5) that s(l) ∈ E. Otherwise, if l < k, then K must be undeﬁned on
s(l); by the clauses (1), this again means s(l) ∈ E. Hence, {s(0), . . . , s(l)} ∩ E (cid:4)= ∅.

(1)
k−1. Repeating this argument, we can infer that s

(1)
k−1, . . . , s

(0)
k , s

Thus the statement holds in the base case. Now for the induction step, let us assume that it holds for every state s ∈
(cid:7), S) =
Closure(S, A K ,exo) at distance d(s, S) = d (cid:2) 0 from S. Let us now consider a state s ∈ Closure(S, A K ,exo) at distance d(s
(cid:7)) or (ii)
d + 1 from S. Then there is a state s
(cid:7)
a ∈ K (s
k, and we can conclude M |(cid:8) sk from the clauses in
(2) in case (i) and from our construction of K and the clauses in (3.2), (1), and (0) in case (ii), respectively. Furthermore, by
similar argumentation as in the case d = 0 above, we obtain that for each sequence σ = s(0), s(1), . . . , s(l) in Unfoldk(s, A, K )
with s = s(0) it holds that {s(0), . . . , s(l)} ∩ E (cid:4)= ∅. This concludes the induction and the proof of (iii). (cid:2)

(cid:7)). In both cases, we have by the induction hypothesis that M |(cid:8) s

at distance d(s, S) = d from S such that s ∈ Φ(a, s

(cid:7)) and either (i) a ∈ exo(s

(cid:7)

One advantage of the encoding sat

(cid:7)(I) over the encoding sat(I) for deterministic transition function Φ above is that it
directly gives us the possibility to read off a suitable control from the s_ai propositions, a ∈ poss(s), which are true in any
model M that we have computed, without looking at the transition function Φ(s, a) again. On the other hand, the encoding
(cid:7)(I) is benign for
is more involved, and uses a larger set of propositions. Nonetheless, the structure of the formulas in sat
computation and allows us to compute a model, and from it a k-maintainable control in polynomial time.

5.2.1. Horn SAT encoding (general case)

The encoding sat

(cid:7)(I)
by reversing the propositions, where the intuitive meaning of si and s_ai is the converse of the meaning of si and s_ai
respectively. The encoding sat

(cid:7)(I) is, like sat(I), a reverse Horn theory. We thus can rewrite sat

(cid:7)(I) similarly to a Horn theory, sat

(cid:7)(I) is as follows:

(0), (1), (4) and (5) are as in sat(I)
(2) For every states s, s

(cid:7) ∈ S such that s

(cid:7) ∈ Φ(a, s) for some action a ∈ exo(s):

(cid:7)
s
k

⇒ sk.

(3) For every state s ∈ S \ E and for all i, 1 (cid:3) i (cid:3) k:

(cid:17)

a∈Aag∩poss(s) s_ai) ⇒ si ;
(3.1) (
(3.2) for every a ∈ Aag ∩ poss(s) and s

(cid:7) ∈ Φ(s, a):

s

(cid:7)
i−1

⇒ s_ai;

(3.3) for every a ∈ Aag ∩ poss(s), if i < k:

s_ai+1 ⇒ s_ai.

We obtain from Proposition 6 easily the following result, which is the main result of this section so far.

Theorem 7. Let I consist of a system A = (S, A, Φ, poss), a set Aag ⊆ A, sets of states E, S ⊆ S, an exogenous function exo, and an
(cid:7)(I), C M = {s | M (cid:4)|(cid:8) sk}, and let (cid:8)M (s) = min{ j | M (cid:4)|(cid:8) s_a j , a ∈ Aag ∩ poss(s)} for every s ∈ S.
integer k. Let, for any model M of sat
Then,

(i) S is k-maintainable w.r.t. E iff the Horn SAT instance sat
(ii) Given any model M of sat

(cid:7)(I), every control K such that K (s) is deﬁned iff s ∈ C M \ E and
(cid:12)
(cid:11)
a ∈ Aag ∩ poss(s) | M (cid:4)|(cid:8) s_a j, j = (cid:8)M (s)

,

K (s) ∈

(cid:7)(I) is satisﬁable;

k-maintains S w.r.t. E.

Corollary 8. Problem k-Maintain is solvable in polynomial time. More precisely, it is solvable in time O (k(cid:22)I(cid:22)), where (cid:22)I(cid:22) denotes the
size of input I .

1446

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

(cid:7)(I), measured by the number of atoms in it, is O (k(|S| + |Φ| +
Proof. A straightforward analysis yields that the size of sat
|poss|)), if Aag, S, E, Φ, poss and exo are stored in a standard way as bitmaps, i.e., a (multi-dimensional) array with value
(cid:7)(I) can be easily generated within the same
range {0,1} (thus, (cid:22)I(cid:22) = O (|S|2|A| + log k)). Furthermore, the clauses in sat
time bound. Since the least model of any Horn theory T is computable in time O (|T |) where |T | is the number of atoms
(cid:7)(I) is feasible in O (k(cid:22)I(cid:22)) time. Furthermore, C M
in it [25,50], deciding satisﬁability and computing some model M of sat
and {(s, (cid:8)M (s)) | s ∈ S} are computable from M in linear time in the number of atoms, using suitable data structures, and
from this a control K as in Theorem 7(ii) in the same time. Hence, a k-maintaining control for S w.r.t. E is computable in
O (k(cid:22)I(cid:22)) time.

Note that a more economic representation stores S, E, Aag as sets (i.e., lists) and Φ, poss, and exo by their graphs in
tables, i.e., sets of tuples {(cid:14)s, a, Φ(s, a)(cid:15) | s ∈ S, a ∈ A}, {(cid:14)s, poss(s)(cid:15) | s ∈ S}, and {(cid:14)s, exo(s)(cid:15) | s ∈ S}. Also under this rep-
resentation, and if moreover tuples where Φ(s, a) = ∅ (resp., poss(s) = ∅ and exo(s) = ∅) are not stored (which is of the
(cid:7) ∈ Φ(a, s)}, {(cid:14)s, a(cid:15) | a ∈ poss(s)}, {(cid:14)s, a(cid:15) | a ∈ exo(s)}), the O (k(cid:22)I(cid:22)) time
same order as storing the sets of tuples {(cid:14)s, a, s
bound holds. Indeed, arrays storing S, E, and Aag for lookup in O (1) time are constructible in time O (|S| + |A|). Then,
= {(cid:14)s, a(cid:15) ∈ poss | a ∈ Aag} storing Aag ∩ poss(s) for all s is constructible in O (|poss|) time. From this, all clauses of
possag
|)). The clauses (2) and (3.2) can be easily
sat
(cid:7)(cid:15) ∈ Φ | a ∈ poss(s)} in time O (|Φexo|) and O (k|Φposs|),
constructed from Φexo = {(cid:14)s, a, s
respectively. The sets Φexo and Φposs can be generated from Φ and exo in time O (|Φ| + |exo| + poss|), using an auxiliary
(cid:7)(I)
array aux[A, S] to enable random access to Φ(a, s); notice that aux[a, s] needs not be deﬁned if Φ(a, s) = ∅. In total, sat
is constructible in O (|A| + |exo| + k(|S| + |Φ| + |poss|)) = O (k(cid:22)I(cid:22)) time. (cid:2)

(cid:7)(I) except (2) and (3.2) can be readily generated in time O (k(|S| + |possag

(cid:7)(cid:15) ∈ Φ | a ∈ exo(s)} and Φposs = {(cid:14)s, a, s

(cid:7)(cid:15) | s

Thus in particular, ﬁnding a maintaining control under a small window of opportunity for maintenance, i.e., a k-

maintaining control for k bounded by a constant, is feasible in linear time in the size of the input.

Similar as in Section 5.1.1, the least model of the theory given by sat

(cid:7)(I), Msat(cid:7)(I), leads to a maximal control in the
sense that the pre-image of K outside E, i.e., the states outside E in which K is deﬁned, is greatest among all possible
k-maintaining controls which include S. Furthermore, a smallest k-maintaining control can be similarly computed from any
(cid:7)(I) with respect to the propositions sk where s is outside E, which can be generated from Msat(cid:7)(I) by
maximal model of sat
stepwise maximization. Again, both maximal and smallest controls can be computed in polynomial time.

Example 6. Reconsider the system A = (S, A, Φ, poss) from Example 5. Let us modify the transition function Φ such that
Φ(c, a) = {d, f } instead of Φ(c, a) = {d}. Then, for the respective modiﬁed instance I of 3-Maintain, denoted I1, the encod-
ing sat

(cid:7)(I1) looks as follows.

(0), (1), (2), (4), and (5) are as in sat(I1) in Example 5;
(3.1): b_a1 ∧ b_a

b_a2 ∧ b_a

b_a3 ∧ b_a

(cid:7)
⇒ b1.
1
c_a1 ⇒ c1.
d_a1 ⇒ d1.
f _a1 ⇒ f 1.
g1.

(cid:7)
⇒ b2.
2
c_a2 ⇒ c2.
d_a2 ⇒ d2.
f _a2 ⇒ f 2.
g2.

(cid:7)
⇒ b3.
3
c_a3 ⇒ c3.
d_a3 ⇒ d3.
f _a3 ⇒ f 3.
g3.

(3.2): h0 ⇒ d_a1.
d0 ⇒ c_a1.
c0 ⇒ b_a1.

h1 ⇒ d_a2.
d1 ⇒ c_a2.
c1 ⇒ b_a2.

h2 ⇒ d_a3.
d2 ⇒ c_a3.
c2 ⇒ b_a3.

h0 ⇒ f _a1.
f 0 ⇒ c_a1.
(cid:7)
f 0 ⇒ b_a
1.

h1 ⇒ f _a2.
f 1 ⇒ c_a2.
(cid:7)
f 1 ⇒ b_a
2.

h2 ⇒ f _a3.
f 2 ⇒ c_a3.
(cid:7)
f 2 ⇒ b_a
3.

(3.3): d_a2 ⇒ d_a1.
c_a3 ⇒ c_a2.

d_a3 ⇒ d_a2.
b_a2 ⇒ b_a1.

f _a2 ⇒ f _a1.
b_a3 ⇒ b_a2.

f _a3 ⇒ f _a2.
b(cid:7)_a2 ⇒ b(cid:7)_a1.

c_a2 ⇒ c_a1.
b(cid:7)_a3 ⇒ b(cid:7)_a2.

It turns out that sat

(cid:7)(I) has no models: From g3, the clause g3 ⇒ f 3 in (2), and clauses in (0), we obtain that f i ,
(cid:7)
(cid:7)(I1). Hence, by the clause f 2 ⇒ b_a3 in (3.2), also b_a
i ∈ {0, . . . , 3}, is true in every model M of sat
3 is true in M. On the
other hand, from the formula f 1 ⇒ c_a2 in (3.2), we obtain that c_a2 must be true in M, and thus by the clauses c_a2 ⇒ c2
⇒ b3 thus implies that b3 is true in M.
in (3.1) and c2 ⇒ b_a3 in (3.2) that b_a3 is true in M. The clause b_a3 ∧ b_a
(cid:7)(I1) can exist, which by Theorem 7
However, by the formula b3 ⇒ ⊥ in (4), b3 must be false in M. Thus, no model M of sat
means that there is no 3-maintaining control for S = {b} w.r.t E = {h}. Indeed, regardless of whether a control function K
in state b, within at most 2 steps from b the state f might be reached, from which the exogenous function
selects a or a
might move the system to the no-good state g.

(cid:7)
3

(cid:7)

Suppose now again that Φ(c, a) = {d, f } and that the agent can take a

{ f , h} and a

(cid:7) ∈ poss(g)). Then the Horn encoding sat

(cid:7)(I1) changes as follows:

(cid:7)

in g, which results in either h or f (i.e., Φ(g, a

(cid:7)) =

In (3.1), the facts gi , i ∈ {1, 2, 3}, are replaced by g_ai ⇒ gi ; In (3.2.), the clauses for a

(cid:7)

and f , h are added, i ∈ {1, 2, 3}:

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1447

f 0 ⇒ g_a

(cid:7)
1.

(cid:7)
2.

f 2 ⇒ g_a

(cid:7)
3.

h0 ⇒ g_a

(cid:7)
1.

h1 ⇒ g_a

(cid:7)
2.

h2 ⇒ g_a

(cid:7)
3.

f 1 ⇒ g_a
(cid:7)

In (3.3), the clauses for a

and g are added:

g_a

(cid:7)
2

⇒ g_a

(cid:7)
3

(cid:7)
2.

g_a

⇒ g_a

(cid:7)
1.
(cid:7)(I2) of the modiﬁed instance I2, we no longer have a fact g3 in (3.1) and thus the above derivation of a
(cid:7)(I2) is satisﬁable, and its least

(cid:7)(I2) is not applicable. In fact, sat

In this encoding sat
contradiction for the truth value of b3 in any model of sat
model is

M = {b0, c0, d0 f 0, g0, b_a1, c_a1, b_a

(cid:7)
1, g_a

(cid:7)
1, b1, c1, g1, b_a2}.

Then, we have C M = {b, c, d, f , g, h}, (cid:8)M (b) = (cid:8)M (c) = (cid:8)M (g) = 2 and (cid:8)M (d) = (cid:8)M ( f ) = 1, which leads to a single 3-
maintaining control K such that K (s) = a for s ∈ {b, c, d, f } and K (g) = a
. Note that since K is deﬁned on every state
except h, it 3-maintains every set S w.r.t. every E which includes h. As for S = {b}, K (c) and K (d) could remain undeﬁned,
since they are not in the closure of b (which can be easily detected) at the price of losing robustness with respect to en-
larging S. There is an alternative solution in which K (b) = a
instead of K (b) = a. Here K (s) can not be made undeﬁned on
any s (cid:4)= h.

(cid:7)

(cid:7)

5.3. Genuine algorithm

From the encoding to Horn SAT above, we can distill a direct algorithm to construct a k-maintainable control, if one
(cid:7)(I). It uses counters c[s] and c[s_a]
exists. The algorithm mimics the steps which a SAT solver might take in order to solve sat
for each state s ∈ S and possible agent action a in state s, which range over {−1, 0, . . . , k} and {0, 1, . . . , k}, respectively.
Intuitively, value i of counter c[s] (at a particular step in the computation) represents that so far s0, . . . , si are assigned true,
and that at least i + 1 steps are needed from s to reach E; in particular, i = −1 represents that no si is assigned true yet.
Similarly, value i for c[s_a] (at a particular step in the computation) represents that so far s_a1, . . . , s_ai are assigned true
(in particular, i = 0 that no s_ai is assigned true yet), and that at least i + 1 steps are needed from s to reach E starting
with a.

Starting from an initialization, the algorithm updates by demand of the clauses in sat

(cid:7)(I) the counters (i.e., sets proposi-
tions true) using a command upd(c, i) which is short for “if c < i then c := i,” towards a ﬁxpoint. If a counter violation is
detected, corresponding to violation of a clause s0 → ⊥ for s ∈ S ∩ E in (1) or sk → ⊥ for s ∈ S \ E in (4), then no control is
possible. Otherwise, a control is constructed from the counters.

The detailed algorithm is shown in Fig. 9.
It can be easily adjusted if we simply want to output a non-deterministic control such that each of its reﬁnements is a
k-maintainable control, leaving a choice about the reﬁnement to the user. Alternatively, we can implement in Step 4 such
a choice based on preference information. The following proposition states that the algorithm works correctly and runs in
polynomial time.

Proposition 9. Algorithm k-Control solves problem k-Maintain, and terminates for any input I in polynomial time. Furthermore, it
can be implemented to run in O (k(cid:22)I(cid:22)) time.

Algorithm k-Control
Input:
Output:

A system A = (S, A, Φ, poss), a set Aag ⊆ A of agent actions, sets of states E, S ⊆ S, an exogenous function exo, and an integer k (cid:2) 0.
A control K which k-maintains S with respect to E, if any such control exists. Otherwise, output that no such control exists.

(Step 1) Initialization

(cid:7)(cid:15) | s ∈ S, a ∈ exo(s), s

(cid:7) ∈ Φ(s, a)}, Φ E

poss

= {(cid:14)s, a, s

(cid:7)(cid:15) | s ∈ S \ E, a ∈ poss(s), s

(cid:7) ∈ Φ(s, a)}, and for every s ∈ S, possag(s) =

(i) Set Φexo = {(cid:14)s, a, s
Aag ∩ poss(s).

(ii) For every s in E, set c[s] := −1.
(iii) For every s in S \ E, set c[s] := k if possag(s) = ∅; otherwise, set c[s] := 0.
(iv) For every s in S \ E and a ∈ possag(s), set c[s_a] := 0.

(Step 2) Repeat the following steps until there is no change or c[s] = k for some s ∈ S \ E or c[s](cid:2)0 for some s ∈ S ∩ E:
(cid:7)] = k do upd(c[s], k).
(cid:7)] = i:

(i) For any (cid:14)s, a, s
(ii) For any (cid:14)s, a, s

(cid:7)(cid:15) ∈ Φexo such that c[s
(cid:7)(cid:15) ∈ Φ E
poss such that c[s

if 0 (cid:3) i < k then do upd(c[s_a], i + 1), elseif i = k then do upd(c[s_a], k).

(iii) For any state s ∈ S \ E such that possag(s) (cid:4)= ∅ and i = min(c[s_a] | a ∈ possag(s)) do upd(c[s], i).

(Step 3) If c[s] = k for some s ∈ S \ E or c[s] (cid:2) 0 for some s ∈ S ∩ E, then output that S is not k-maintainable w.r.t. E and halt.
(Step 4) Output any control K : S \ E → Aag deﬁned on all states s ∈ S \ E with c[s] < k and such that K (s) ∈ {a ∈ possag(s) | c[s_a] =

minb∈possag (s) c[s_b] < k}.

Fig. 9. Algorithm for problem k-Maintain.

1448

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

Proof. The correctness of the algorithm follows from Theorem 7 and the fact that k-Control mimics, starting from facts in
(cid:7)(I) by a standard ﬁx-point computation. As for the polynomial time
(5) and (3.1), the computation of the least model of sat
complexity, since counters are only increased, and the loop in Step 2 is reentered only if at least one counter has increased
in the latest run, it follows that the number of iterations is polynomially bounded. Since the body of Step 2 and each other
step is polynomial, it follows that k-Control runs in polynomial time.

For the more detailed account, note that bitmaps for S, E and A (if not available in the input) can be generated in time
poss can be constructed in time O (|Φ| + |exo|) and O (|Φ| + |poss| + |S|),
O (|S| + |A|). In (i) of Step 1, the sets Φexo and Φ E
respectively, using an auxiliary array for random access to Φ(a, s) in case if the functions are given by their graphs (cf.
proof of Corollary 8). Constructing possag(s) for all s ∈ S takes O (|poss|) time, and (ii)–(iv) of Step 1 is feasible in time
O (|S| + |poss|).

Using ﬂags to signal changes to counters c[s], c[sa], and auxiliary counters for min(c[s_a] | a ∈ possag(s)), the number of
calls of upd in Step 2 is O (k(|Φexo| + |Φposs| + |S|)), and each call takes O (1) time. The loop condition can be checked in
O (m) time where m is the number of changes in the loop. Hence, the total time for Step 2 is O (k(cid:22)I(cid:22)). Step 3 is O (1) if
a ﬂag is set in Step 2 indicating the reason for the loop exit. Finally, in Step 4, a control K can be easily output in time
O (|poss|). In total, the time is O (k(cid:22)I(cid:22)). (cid:2)

Thus, for k bounded by a constant, k-Control can be implemented to run in linear time. We remark that further improve-
ments are possible. For example, states may be eliminated beforehand which will not be reachable from any state in S under
any control that is eventually constructed. This can be done eﬃciently by computing an upper bound of Closure(S, K A,exo)
in which all possible actions at any state are merged into a single action. Similarly, we can eﬃciently prune all states which
can not reach E within k steps in linear time. This can e.g. be achieved by a slight extension of algorithm K -Control,
in which ﬂags ﬁnal[s] and ﬁnal[s_a] for the states s and actions a ∈ possag(s) signal whether the counters c[s] and c[s_a]
correspond to the shortest distance to E, and in Step 2 (ii) and (iii) we chose next always some s_a (respectively s) such
that its ﬁnal ﬂag can be switched from false to true and c[s_a] (resp. c[s]) is smaller than k. We leave further discussion
and reﬁnements for future work.

5.4. Generic maintaining controls

By the results in the previous subsections, we can solve problem Maintain, which is analogous to k-Maintain but k is
not in the input and can be arbitrarily chosen, in time O (|S|(cid:22)I(cid:22)), that is, in time quadratic in the size of the input. This
follows from the fact that k-maintainability of S w.r.t. E for some arbitrary but ﬁnite k (cid:2) 0 is equivalent to k-maintainability
of S w.r.t. E where k = |S| is the number of states.

However, we can take advantage of the property that the exact number of steps to reach E does not matter (as long as it
is ﬁnite), and design a more eﬃcient (linear time) algorithm, which proceeds in two phases. In the ﬁrst phase, those states
s are determined from which E is reachable by an a-path of arbitrary length, and all other states are pruned. In the second
phase, those states are iteratively pruned which are taken by some exogenous action to a state without such an a-path, or
where each action a leads to a pruned state.

We can obtain a genuine linear-time algorithm for solving problem Maintain by adapting the algorithm k-Control such
that it implements the two phases, where the counters c[s] and c[s_a] only range over a ﬁxed domain independent of k.
However, we skip the discovery process and go straight to a simple algorithm, which is shown in Fig. 10. We refer to this
algorithm as ω-control or ω-maintaining control.

It implements the phases 1 and 2 in the steps 2 and 3, respectively. If in Step 4 a maintaining control is found to exist,
Step 5 extracts such a control from the data structures. Like for k-maintainability, this requires some care since a naïve
extraction does not work (in particular, cycles may cause problems). The following result, whose proof is omitted, states
that the algorithm works properly.

Proposition 10. Algorithm ω-Control solves problem Maintain, and terminates for any input I in polynomial time. Furthermore, it
can be implemented to run in time O ((cid:22)I(cid:22)), i.e., in linear time.

6. Encoding k-maintainability for an answer set solver

In this section, we use the results of the previous section to show how computing a k-maintainable control can be en-
coded as ﬁnding answer sets of a non-monotonic logic program. More precisely, we describe an encoding to non-monotonic
logic programs under the Answer Set Semantics [33], which can be executed on one of the available answer set solvers such
as DLV [29,45] or Smodels [53,65]. These solvers support the computation of answer sets (models) of a given program, from
which solutions (in our case, k-maintaining controls) can be extracted.

The encoding is generic, i.e., given by a ﬁxed program which is evaluated over the instance I represented by input facts
F (I). It makes use of the fact that non-monotonic logic programs can have multiple models, which correspond to different
solutions, i.e., different k-maintainable controls.

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1449

Algorithm ω-Control
Input:
Output:

A system A = (S, A, Φ, poss), a set Aag ⊆ A of agent actions, sets of states E, S ⊆ S, an exogenous function exo.
A control K which maintains S with respect to E, if any such control exists. Otherwise, output that no such control exists.

(Step 1) X := E.
(Step 2) Repeat until there is no change to X :

X := X ∪ {s | ∃a ∈ Aag: ∀s

(cid:7)

(cid:7) ∈ Φ(s, a), s

(cid:7) ∈ X}.

, s

(Step 3) Repeat until there is no change to X :

X := X \ {s | ∃a ∈ exo(s): ∃s

(cid:7)

(cid:7) ∈ Φ(s, a), s

(cid:7)

, s

/∈ X};

X := X \ {s | ∀a ∈ Aag: ∃s

(cid:7), s

(cid:7) ∈ Φ(s, a), s

(cid:7) /∈ X}.

(Step 4) If S \ X (cid:4)= ∅ then output that S is not maintainable w.r.t. E and halt.
(Step 5) Construct the control going backwards from the goal states in the following manner.

(i) Initialize counters: for all s ∈ X and a ∈ Aag do c[s_a] := |Φ(s, a)|.
(ii) For every state s ∈ E do put (s, nop) in a queue Q .
(iii) While Q is not empty do

Pop an element (s, x) from Q ;
if s /∈ E then K (s) := x;
for all transitions (s
(cid:7)
c[s
_a] := c[s
if c[s

(cid:7), a, s) such that s ∈ Φ(s
(cid:7)
_a] − 1;
_a] = 0 and K (s

(cid:7)

(cid:7)

a) and s

(cid:7) ∈ X do

(cid:7)) is undeﬁned then put (s

(cid:7), a) in Q .

Fig. 10. Algorithm for problem Maintain.

In the following, we ﬁrst describe how a system is represented in a logic program, and then we develop the logic
programs for both deterministic and general, non-deterministic domains. We shall follow here the syntax of the DLV system;
the changes needed to adapt the programs to other answer set solvers such as Smodels are minor.

6.1. Input representation

The input I of problem k-Maintain, can be represented by facts F (I) as follows.

• The system A = (S, A, Φ, poss) can be represented using predicates state, transition, and poss by the following

facts:
– state(s), for each s ∈ S;
– action(a), for each a ∈ A;
(cid:7)), for each s, s
– transition(s,a,s
– poss(s,a), for each s ∈ S and a ∈ A such that a ∈ poss(s).

(cid:7) ∈ S and a ∈ A such that s

(cid:7) ∈ Φ(s, a);

• the set Aag⊆A of agent actions is represented using a predicate agent by facts agent(a), for each a ∈ Aag;
• the set of states S is represented by using a predicate start by facts start(s), for each s ∈ S;
• the set of states E is represented by using a predicate goals by facts goal(s), for each s ∈ E;
• the exogenous function exo is represented by using a predicate exo by facts exo(s,a) for each s ∈ S and a ∈ exo(s);

The integer k is represented as constant k.

Example 7. Coming back to Example 3, the input I is represented as follows:

state(b). state(c). state(d). state(f). state(g). state(h).
action(a). action(a1). action(e).
trans(b,a,c). trans(b,a1,f). trans(c,a,d). trans(d,a,h).
trans(f,a,h). trans(f,e,g).
poss(b,a). poss(b,a1). poss(f,a). poss(f,e).
poss(c,a). poss(d,a).
agent(a). agent(a1).
start(b). goal(h).
exo(f,e).
const k=3.

1450

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

6.2. Deterministic transition function Φ

The following is a program, executable on the DLV engine, for deciding the existence of a k-control. In addition to the
predicates for the input facts F (I), it employs a predicate n_path(X,I), which intuitively corresponds to X I , and further
auxiliary predicates.

% Define range of 0,1,...,\(k\) for stages.
range(0..k).

% Rule for (0).
n_path(X,I) :- state(X), range(I), I < k, n_path(X,J), J = I+1.

% Rule for (1).
:- n_path(X,0), goal(X), start(X).

% Rule for (2)
n_path(X,k) :- trans(X,A,Y), exo(X,A), n_path(Y,k).

% Rules for (3)
n_path(X,I) :- state(X), not goal(X), range(I),
I>0, not some_pass(X,I).\smallskip
some_pass(X,I) :- range(I), I>0, trans(X,A,Y), agent(A),
poss(X,A), not n_path(Y,J), I=J+1.

% Rule for (4)
:- n_path(X,k), start(X), not goal(X).

% Rule for (5)
n_path(X,0) :- state(X), not goal(X).

The predicate range(I) speciﬁes the index range from 0 to k, given by the input limit(k). The rules encoding the
clause groups (0)–(2) and (4), (5) are straightforward and self explanatory. For (3), we need to encode rules with bodies of
different size depending on the transition function Φ, which itself is part of the input. We use that the antecedent of any
(cid:7) ∈ PS(s), is false; to assess this,
implication (3) is true if it is not falsiﬁed, where falsiﬁcation means that some atom s
we use the auxiliary predicate some_pass(X,I).
To compute the non-deterministic control K

, we may add the rule:

(cid:7)
i−1, s

+

% Define ¯C_M
cbar(X) :- state(X), not n_path(X,k).

%Define state level L
level(X,I) :- cbar(X), not n_path(X,I), I > 0, n_path(X,J), I=J+1.
level(X,0) :- cbar(X), not n_path(X,0).

% Define non-deterministic control k_plus
k_plus(X,A) :- agent(A), trans(X,A,Y), poss(X,A), level(X,I),
level(Y,J), J<I, not goal(X).

In cbar(X), we compute the states in C M , and in level(X,I) the level (cid:8)M (s) of each state s ∈ C M (= C M for the

corresponding model M of sat(I)). The non-deterministic control K

+
M is then computed in k_plus(X,A).

Finally, by the following rules we can non-deterministically generate any control which reﬁnes K

% Selecting a control from k_plus.
control(X,Y) :- k_plus(X,Y), not exclude_k_plus(X,Y).

exclude_k_plus(X,Y) :- k_plus(X,Y), control(X,Z), Y<>Z.

+
M :

The ﬁrst rule enforces that any possible choice for K (s) must be taken unless it is excluded, which by the second rule
is the case if some other choice has been made. In combination the two rules effect that one and only one element from
K

+
M (s) is chosen for K (s).

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1451

Example 8. If the input representation of Example 5 is in a ﬁle exa3.dlv and the above program, denoted by Πdet , in a
ﬁle det.dlv, the DLV engine can be invoked e.g. by

dlv exa3.dlv det.dlv -N=3 -filter=control

which outputs the controls; here -N=3 sets the range of integers dynamically supported by the engine to 3, and -
ﬁlter=control effects that the answer sets are clipped to the predicate control. In the particular case, the output on
the call is (apart from system version information)

{control(b,a), control(c,a), control(d,a)}

yielding the unique control which exists in this case. If we would add a further agent action a2 to the action set, and extend
the transition function by Φ(b, a2) = c, then a call of DLV for the respective representation would yield

{control(b,a2), control(c,a), control(d,a)}
{control(b,a), control(c,a), control(d,a)}

corresponding to the two alternative controls which emerge, since the agent can take either action a or action a2 in state a.

6.3. Non-deterministic transition function Φ

As for deciding the existence of a k-maintaining control, the only change in the code for the deterministic case affects

Step (3). The modiﬁed code is as follows, where n_apath(X,A,I) intuitively corresponds to X_ A I .

% Rules for (3); different from above
% (3.1)
n_path(X,I) :- state(X), not goal(X), range(I), I>0, not some_apass(X,I).

some_apass(X,I) :- range(I), I>0, agent(A), poss(X,A), not n_apath(X,A,I),

not goal(X).

% (3.2)
n_apath(X,A,I) :- agent(A), trans(X,A,Y), poss(X,A), range(I), I>0,
n_path(Y,J), I=J+1, not goal(X).

% (3.3)
n_apath(X,A,I) :- agent(A), poss(X,A), range(I), I>0, I<k,

n_apath(X,A,J), J=I+1, not goal(X).

Here, some_apass(X,A,I) plays for encoding (3.1) a similar role as some_pass(X,I) for encoding (3) in the deter-
ministic encoding.

To compute the non-deterministic control K

+
M , we may then add the following rules:

% Define ¯C_M
cbar(X) :- state(X), not n_path(X,K), limit(K).

% Define state action level, alevel (>=1)
alevel(X,I) :- alevel_leq(X,I), I=J+1, range(J), not level_leq(X,J).

alevel_leq(X,I) :- cbar(X), not goal(X), poss(X,A), agent(A), I>0,
range(I), not n_apath(X,A,I).

% Define non-deterministic control k_plus
k_plus(X,A) :- agent(A), alevel(X,I), poss(X,A), not n_apath(X,A,I).

Here, the value of (cid:8)M (s) is computed in alevel(X,I), using the auxiliary predicate alevel_leq(X,I) which intuitively
means that (cid:8)M ( X) (cid:3) I .

+
M , we can add the two rules for selecting a control from k_plus from the program

For computing the controls reﬁning K

for the deterministic case.

Example 9. Let us revisit the instance I1 in Example 6. We get the DLV representation of
trans(c,a,f). to the representation for I . Assuming that it is in a ﬁle exa4.dlv and the program Πndet
ndet.dlv, a call

I1 by adding the fact
in a ﬁle

dlv exa4.dlv ndet.dlv -N=3 -filter=control

1452

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

yields no output (apart from some system version print), which is correct. On the other hand, if we consider the input I2
for the variant of Example 6 (with agent action a

(cid:7)) = { f , h}), then the output is

possible in g and Φ(g, a

(cid:7)

{control(b,a1), control(c,a), control(d,a), control(f,a), control(g,a1)}

(where a1 encodes a

(cid:7)

). Again, this is a correct result.

6.4. Layered use of negation

An important note at this point is that the programs Πdet and Πndet do not necessarily have models which corre-
(cid:7)(I), respectively. The reason is that the use of negation not
spond to the least models of the Horn theories sat(I) and sat
some_pass(X,I) and resp. not some_apass(X,I) may lead through cycles in recursion. Thus, not each control com-
puted is necessarily maximal (even though the maximal controls will be computed in some models). Furthermore, because
of cyclic negation it is not a priori clear that the part of the program deciding the existence of a control is evaluated by DLV
(cid:7)(I) has a
in polynomial time. However, consistency (i.e., existence of an answer set) is guaranteed whenever sat(I) resp. sat
model.

It is possible to modify Πdet such that the use of negation in recursion cycles is eliminated, by using standard coding
methods to evaluate the body of the rule in (3). Namely, introduce for Πdet a predicate all_true and replace not
some_pass(X,I) in the code for (3) with all_true(X,I), which is deﬁned such that all_true(s, i) represents that
every s(cid:7)
i−1 ∈ PS(s) is assigned true, which can be checked using a linear ordering (cid:3) on PS(s). However, we refrain from this
here.

Notice that in the case where PS(s) has size bounded by a constant c, we can use a predicate ps of arity c + 1 to
represent PS(s) = {s(1), . . . , s(l)} by a single fact ps(s, s(1), . . . , s(l), . . . , s(l)) where s(l) is reduplicated if l < c. It is then easy
to express the clause (3).

We can similarly modify Πndet such that the use of negation in recursion cycles is eliminated, where we use a linear
ordering on Aag ∩ poss(s) (or simply on Aag, assuming that there are not many agent actions overall). Finally, we can also
use for the program Πdet simply an ordering of Aag, since the deterministic transformation Φ(s, a) is a (partial) surjective
mapping of A onto PS(s), which guarantees that via A ∩ poss(s) each s

(cid:7) ∈ PS(s) can be accessed through Φ.

The modiﬁed programs use negation only in a stratiﬁed manner, and thus will be evaluated by DLV in guaranteed

polynomial time in the size of the DLV representation of sat(I) and sat

6.5. State descriptions by variables

(cid:7)(I), respectively.

In many cases, states of a system are described by a vector of values for parameters which are variable over time.
It is easy to incorporate such state descriptions into the LP encoding from above, and to evaluate them on answer set
solvers provided that the variables range over ﬁnite domains. In fact, if any state s is given by a (unique) vector s =
(cid:14)s1, . . . , sm(cid:15) m > 0, of values si , 1 (cid:3) i (cid:3) m, for variables Xi ranging over nonempty domains, then we can represent s as
fact state(v i
) and use a vector X1,...,Xm of state variables in the DLV code, in place of a single variable, X. No
further change of the programs from above is needed.

1, . . . , v i
ri

Similarly, we can easily accommodate actions a(P 1, P 2, . . . , Pm) with parameters P 1, . . . , Pm (which is important) from
a ﬁnite set if desired. However, here the rule deﬁning exclude_k_plus(X,Y) should be replaced by all rules emerging
if the atom Y <> Z in the body is replaced by Yi <> Zi, i ∈ {1,...,m} (assuming that Y and Z are replaced by
Y1,...,Ym and Z1,...,Zm, respectively).

Another possibility to handle state descriptions by variables would be to implement a coding scheme, which maps each

vector s = (cid:14)s1, . . . , sm(cid:15) into an integer i(s), represented by fact code(i(s), s1, . . . , sm).

Furthermore, we point out that the input need not consist merely of facts, but may also involve rules to deﬁne the
predicates of the input representation more compactly. Finally, the facts for action can be dropped, since they are not
referenced by any rule in programs Πdet and Πndet.

For illustration, we consider the buffer example from Section 3.

Example 10. Recall that states in the buffer example are given by pairs of integers (cid:14)i, j(cid:15) where i and j are the numbers of
objects in buffer b1 and b2, respectively. We thus use variables X1,X2 and Y1,Y2 in place of X and Y, respectively.
For buffer capacity of 3, S = {(cid:14)0, 0(cid:15)}, E = {(cid:14)0, j(cid:15) | 1 (cid:3) j (cid:3) 3}, and k = 6, the input can be represented as follows:

state(X1,X2) :- #int(X1), #int(X2), X1 <= 3, X2 <= 3.

start(0,0).

goal(0,X2) :- state(0,X2).

trans(X1,X2,m_12,Y1,Y2) :- state(X1,X2), state(Y1,Y2), X1=Y1+1, Y2=X2+1.

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1453

trans(X1,X2,m_21,Y1,Y2) :- state(X1,X2), state(Y1,Y2), Y1=X1+1, X2=Y2+1.
trans(X,X2,proc,X,Y2) :- state(X,X2), state(X,Y2), X2=Y2+1.
trans(X1,X,ins,Y1,X) :- state(X1,X), state(Y1,X), Y1=X1+1.

poss(X1,X2,m_12) :- state(X1,X2), 1 <= X1, X2 <= 2.
poss(X1,X2,m_21) :- state(X1,X2), 1 <= X2, X1 <= 2.
poss(X1,X2,proc) :- state(X1,X2), 1 <= X2.
poss(X1,X2,ins) :- state(X1,X2), X1 <= 2.

agent(m_12). agent(m_21). agent(proc). exo(ins).

const k = 6.

Here, equalities X1=0 for X1,X2 in the rule deﬁning goal and X1=Y1 in the deﬁnition of trans(X,X2,proc,X,Y2)
etc are pushed through.

Invoking DLV, assuming the representation is stored in ﬁle exa-buffer.dlv and the expanded version of Πdet in a

ﬁle det2.dlv, with

dlv exa-buffer.dlv det2.dlv -N=6 -filter=control

yields 13 models, of which encode different controls. Among the maximal controls is

{control(1,0,m_12), control(1,1,m_12), control(1,2,m_12), control(1,3,proc),
control(2,0,m_12), control(2,1,m_12), control(2,2,proc), control(2,3,proc),
control(3,0,m_12), control(3,1,proc), control(3,2,proc),
control(3,3,proc)}

which is deﬁned on all states outside E, and thus constitutes a 6-maintaining control for the whole system.

7. Computational complexity

In this section, we consider the complexity of constructing k-maintainable controls under various assumptions. To this
end, we ﬁrst describe the problems analyzed and give an overview of the complexity results. After that, the results are
established in a separate subsection; the reader who is not interested in the technical proofs might safely skip it.

7.1. Problems considered and overview of results

Following the common practice, we consider here the decision problem associated with k-Maintain, which we refer
to as k-Maintainability: Given a system A = (S, A, Φ, poss), a set Aag ⊆ A of agent actions, sets of states E, S ⊆ S, an
exogenous function exo, and an integer k (cid:2) 0, decide whether S is k-maintainable with respect to E in A. Furthermore, we
also consider Maintainability, which has the same input except k and asks whether S is maintainable with respect to E in
A.

We consider the problems in two different input settings, in line with the previous sections:

Enumerative representation: The constituents of an instance I are explicitly given, i.e., the sets (A, S, Aag, S, and E) in

enumerative form and the functions (Φ(a, s), poss(s), and exo) by their graphs in tables.

State variables representation: A system state s is represented by a vector s = (v 1, . . . , vm) of values for variables f 1, . . . , fm
ranging over given ﬁnite domains D1, . . . , Dm, while A and Aag are given in enumerative form. We assume that
polynomial-time procedures for evaluating the following predicates are available:
(cid:7)), in_poss(s, a), and in_exo(s, a) for deciding s
• in_Phi(s, a, s
• in_S(s) and in_E(s) for deciding whether s ∈ S and s ∈ E, respectively.

(cid:7) ∈ Φ(s, a), a ∈ poss(s), and a ∈ exo(s), respectively.

Orthogonal to this, we also consider (1) general k versus constant k, in order to highlight the complexity of small
windows of opportunity for maintenance; (2) absence of exogenous actions, to see what cost intuitively is caused by an
adversary; and (3) non-deterministic versus deterministic actions.

The results of the complexity analysis are compactly summarized in Tables 1 and 2, in which unless stated otherwise,
the entries stand for completeness results under logspace reductions. We assume that the reader is familiar with the classes
P (polynomial time), EXP (exponential time), L (logarithmic workspace), NL (non-deterministic logarithmic work space),
co-NP (co-non-deterministic polynomial time), and PSPACE (polynomial space) appearing in the tables, and refer to [57]
and references therein for further background on complexity. By LH we denote the logarithmic time hierarchy [11,38],

which is given by LH =

i(cid:2)0 Σ log

i

, where Σ log

i

denotes the decision problems solvable on an alternating Turing machine in

(cid:5)

1454

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

Table 1
Complexity of deciding (k-)Maintainability under enumerative representation (logspace completeness)

+/− exogenous actions

deterministic
non-deterministic

k-Maintainability

given k

P / NL (Th. 11/15)
P (Th. 11/13)

constant k (cid:2) 1
P / in LH (⊂ L) (Th. 11/16)
P / in LH (⊂ L) (Th. 11/16)

Maintainability

P / NL (Co. 12/Th. 15)
P (Co. 12/Th. 13)

Table 2
Complexity of deciding (k-)Maintainability under state variables representation (logspace completeness)

+/− exogenous actions

deterministic
non-deterministic

k-Maintainability

given k

EXP / PSPACE (Th. 18/21)
EXP (Th. 18/20)

constant k (cid:2) 1

EXP / co-NP (Th. 18/22)
EXP / co-NP (Th. 18/22)

Maintainability

EXP / PSPACE (Co. 19/Th. 21)
EXP (Co. 19/Th. 20)

logarithmic time with at most i−1 alternations between existential and universal states, starting in an existential state. Note
that LH is strictly included in L. A more reﬁned complexity assessment is given in Section 7.2. However, we refrain here
from providing a sharp complexity characterization of the problems classiﬁed within LH in terms of completeness under a
suitable notion of reduction, since they are not central to the maintainability issue under an “adversarial” environment.

Under enumerative representation (Table 1), (k-)Maintainability has the same complexity as Horn SAT, which is P-
complete [57]. In fact, this holds also for the case of constant k = 1 and the restriction that all actions are deterministic and
that there is a single exogenous action. Thus, even in the simplest setting with an adversary according to the dimensions
above, the problem already harbors its full complexity; excluding non-deterministic actions and/or ﬁxing k does not make
the problems simpler. Intuitively, this is because with the help of exogenous actions, one can simulate non-determinism and
split sequences of agent maintenance actions into small segments.

On the other hand, when exogenous actions are excluded (listed under “-”), (k-)Maintainability is always easier when
the actions are deterministic or the maintenance window is small (k is constant). In summary, the results show that exoge-
nous actions can not be compiled eﬃciently away (with reasonable complexity) to an instance of maintainability under a
small maintenance window, and that non-deterministic actions are indispensable for such a compilation.

The reason is that in absence of exogenous actions, k- Maintainability is akin to a graph reachability resp. planning
problem (for the latter, see Section 8.3). Indeed, deﬁne for a ﬁxed system A = (S, A, Φ, poss), a set of agent action Aag ⊆ A,
and sets E, S ⊆ S of states the predicates ri(s), i (cid:2) 0, on s ∈ S inductively by

r0(s) = s ∈ E,

ri+1(s) = s ∈ E ∨ ∃a ∈ Aag ∩ poss(s)
∀s

(cid:7) ∈ S

(cid:3)

s

(cid:7) ∈ Φ(s, a) ⇒ ri(s

(cid:7)

(cid:4)
)

,

for i (cid:2) 0.

(1)

Informally, ri(s) expresses that some state in E can be reached from s within i agent actions, and it holds that S is k-
maintainable with respect to E, exactly if rk(s) holds for every s in S (as proved in Lemma 1 below). The predicate rk(s)
is deﬁnable in ﬁrst-order predicate logic with a suitable relational vocabulary (using the predicates given for enumerative
representation). As well-known, the ﬁrst-order deﬁnable properties are those which can be decided in LH [11,38]. Since LH
is considered to contain problems which have much lower complexity than hard problems in P, the effect of exogenous
actions is drastic in complexity terms.

Under state variables representation (Table 2), the complexity of the problems, with few exceptions increases by an
exponential. This increase is intuitively explained by the fact that state variables permit in general an exponentially smaller
input representation, which must be unpacked for solving the problem. The exception for constant k in absence of exogenous
functions, where the complexity increases from within LH to co-NP, is intuitively explained by the fact that the quantiﬁer
(cid:7) ∈ S”, ranges over a polynomial set of values (in the input size), and
“∃a ∈ Aag ∩ poss(s)” in Eq. (1), as opposed to “∀s
thus can be deterministically eliminated. Exogenous actions cannot be compiled eﬃciently away in the same cases as under
enumerative representation.

For practical concerns, we can draw from the results above the following conclusions. While k-Maintainability is
tractable under enumerative representation, it is because of its P-completeness not amenable to eﬃcient parallel com-
putation and not solvable within poly-logarithmic workspace under widely believed complexity hypotheses. However, if
exogenous actions are absent and the maintenance window has size bounded by a constant, the problem can be solved in
constant time using a polynomial number of processors as follows from membership in LH (see [38]).

The EXP-completeness results for state variables representation imply that the problems are provably intractable, and
that exponential time and, by current methods, also exponential workspace is needed to solve them. Thus, a polynomial-
time reduction to popular propositional logic engines such as SAT/UNSAT or QBF solvers (see http://www.satcompetition.org/,
http://www.qbﬂib.org/ for state-of-the-art systems) is infeasible in general. Only in the “cheapest” cases (where the size of

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1455

the maintenance window is bounded by a constant and exogenous actions are absent), a polynomial-time reduction of k-
Maintainability to SAT/UNSAT solvers is feasible; a polynomial-time reduction of (k-)Maintainability to QBF solvers is only
feasible in deterministic domains and in absence of exogenous actions. When exogenous actions are possible, the full com-
plexity shows up and one has to resort to more expressive engines such as answer set solvers (as discussed in Section 6.5)
for instance. We remind, however, that the results in Table 2 are worst-case complexity results, and that under further
constraints the problems may be solvable with polynomial resources. A detailed study of this issue remains for future work.

7.2. Enumerative representation

We start with the case of enumerative representation. Our ﬁrst result is the following.

Theorem 11 (Problem k-Maintainability is P-complete (under logspace reductions)). The P-hardness holds under the restriction that
k = f ( A, S, E) is any function of A, S, and E such that f ( A, S, E) (cid:2) 1 (in particular, for ﬁxed k (cid:2) 1), even if in addition all actions are
deterministic and there is only one exogenous action.

Proof. The membership of k-Maintainability in P follows from Corollary 8.

We prove P-hardness under the stated restriction by a reduction from deciding logical entailment π |(cid:8) q of a proposi-

tional atom q from a propositional Horn logic program (PHLP) π , which is a set of rules of the form

b0 ← b1, . . . , bn, n (cid:2) 0,

(2)

and each bi is a propositional atom from an underlying atom set At; b0 is the head and b1, . . . , bn is the body of the rule.
←
As well-known, π |(cid:8) q holds iff there is a sequence of rules r1, r2, . . . , rm, m (cid:2) 1, from π where ri is of form bi0
bi1 , . . . , bin , such that {bi1 , . . . , bin
= q, called a
proof of q from π . Informally, q is derived by successive application of the rules r1, . . . , rm, where ri “ﬁres” after all previous
rules r1, . . . , ri−1 have ﬁred.

}, for all i ∈ {1, . . . , m} (thus in particular, 1n = 0) and bm0

} ⊆ {b10 , . . . , bi−10

A natural idea is to represent backward rule application rm, rm−1, . . . , r1 through agent actions; for a rule r of form (2),
there is an agent action a_r which applied to a state sb0 representing b0, brings the agent non-deterministically to any state
sbi representing bi , i ∈ {1, . . . , n}. Given a state sq encoding q, S = {sq} is maintainable w.r.t. a set of states E encoding the
facts in π if q has a proof from π . However, this does not account for the restriction that k = f ( A, S, E) for any such f . The
key for this is to establish the result for the extremal case where k = 1 is constant (i.e., for 1-maintainability) and then to
extend it to the general case.

Using a constrained rule format in π and an exogenous action, we can emulate non-deterministic agent actions and
sequences of agent actions with some coding tricks by alternating sequences of deterministic agent and exogenous actions,
such that provability of q from π corresponds to 1-maintainability of S w.r.t. a set E in a system A constructible in
logarithmic workspace from q and π .

Without loss of generality, we assume that each rule has either zero or two atoms in the body (i.e., n = 0 or n = 2 in
(2)). We construct from π and q a system A = (S, A, Φ, poss), sets of states S and E, a set Aag ⊆ A, and a function exo as
follows:

1. S: For each atom f in π and rule r ∈ π , f 0, . . . , f m and r1, . . . , rm are states in S. Furthermore, if the body of r is u, v

then (u, v)0, . . . , (u, v)m−1 are states in S.

2. A = {a_r | r ∈ π } ∪ {e}.
3. Φ: For any rule r ∈ π with head f , Φ(a_r, f i) = {ri} for i ∈ {1, . . . , m} and Φ(a_r, ( f , v)i) = {ri}, for ( f , v)i ∈ S, i ∈
{1, . . . , m − 1}. If moreover r has body u, v, then Φ(e, ri) = {(u, v)i−1}, and Φ(e, (u, v)i−1) = {v i−1}, for i ∈ {1, . . . , m − 1}.
In all other cases, Φ(a, s) = ∅.

4. poss: For each state s, poss(s) = {a ∈ A | Φ(a, s) (cid:4)= ∅}.
5. E = {r1, . . . , rm | r ∈ π }.
6. S = {qm}.
7. Aag = A \ {e}.
8. exo: for all rules r ∈ π of form f ← u, v, exo(ri) = {e} for i ∈ {1, . . . , m} and exo((u, v) j) = {e} for j ∈ {1, . . . , m − 1}. For

all other states s, exo(s) = ∅.

The transition diagram for the system constructed for π = {a ← b, c; b ←; c ←} is shown in Fig. 11. Intuitively, the state
f i encodes that f can be derived from π with a proof of length at most i. This is propagated in backward rule application.
Each agent action a_r selects a rule r to prove an atom f ; if the rule has a body u, v, the exogenous action pushes the
agent to prove both u (from (u, v)) and v within decreased recursion depth.

We claim that π |(cid:8) q iff there exists some 1-maintaining control K for S with respect to E in A.
Suppose ﬁrst that π |(cid:8) q. We then construct a 1-maintaining control K for S with respect to E as follows. Let P =
r1, . . . , rk be a proof of q from π such that, without loss of generality, all rules ri have different heads. Set D = {qm} and
iterate the following until D remains unchanged: For each f i ∈ D resp. (u, v)i ∈ D, i (cid:2) 0, let r j be the rule with head f

1456

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

Fig. 11. Transition diagram of the system for π = {a ← b, c; b ←; c ←} and q = a (S and E encircled).

(cid:7)i−1
resp. u in P . Deﬁne K ( f i) = {a_r j} resp. K ((u, v)i) = {a_r j}, and add, if r j has body u
to D. Since P is a proof of q from π , the rule r j always exists, and for each state s in Closure(S, A K ,exo) \ E (=D), K (s) is
deﬁned and Φ(K (s), s) yields some state in E. Hence, K is a 1-maintaining control for S with respect to E in A.

the states (u, v)i−1 and v

(cid:7), v

(cid:7)

Conversely, suppose K is a 1-maintaining control for S with respect to E in A. Without loss of generality, K (s) is
undeﬁned for all states s ∈ E. An easy induction on i (cid:2) 1 shows that for each f i ∈ Closure(S, A K ,exo) resp. (u, v)i ∈
Closure(S, A K ,exo), it holds that π |(cid:8) f resp. π |(cid:8) u and π |(cid:8) v. For i = 1, suppose ﬁrst K ( f 1) = a_r. Rule r must have
form f ← ; otherwise, some states (u, v)0, v 0 would be in Closure(S, A K ,exo), which contradicts that K is a 1-maintaining
control. Hence, π |(cid:8) f . Next suppose K ((u, v)1) = a_r. Then, for similar reasons, r must be of form u ←, hence π |(cid:8) u.
Furthermore, v 1 ∈ Closure(S, A,exo) and as already established π |(cid:8) v. For i > 1, suppose K ( f i) = a_r. Then either r is of
form f ← and thus π |(cid:8) f , or of form f ← u, v. In the latter case, (u, v)i−1 ∈ Closure(S, A K ,exo) and hence, by the induction
hypothesis, π |(cid:8) u and π |(cid:8) v. Consequently, π |(cid:8) f . Similarly, if K ((u, v)i) = a_r, then either r is of form u ← or of form
u ← u
, thus π |(cid:8) u.
Since v i ∈ Closure(S, A K ,exo), as already established π |(cid:8) v. Consequently, π |(cid:8) f . This proves the statement for i > 1, and
concludes the induction. Since qm ∈ Closure(S, A K ,exo), we have π |(cid:8) q. This proves our claim.

(cid:7))i−1 ∈ Closure(S, A K ,exo), which by the induction hypothesis implies π |(cid:8) u

and π |(cid:8) v

and (u

(cid:7), v

(cid:7), v

(cid:7)

(cid:7)

(cid:7)

Notice that A, S and E can be constructed in logarithmic workspace from π and q. This proves P-hardness of 1-
Maintaintability. An easy observation is that every agent action in the system A leads to some state in the set E described.
Hence, S is 1-maintainable with respect to E in A iff S is k-maintainable with respect to E in A for any f ( A, S, E) such
that f ( A, S, E) (cid:2) 1. Hence, P-hardness under the stated restriction follows. (cid:2)

The following result is immediate from this result and the fact that maintainability is equivalent to k-maintainability

where k = |S| is the number of states.

Corollary 12. Maintainability is P-complete. The P-hardness holds even if all actions are deterministic and there is only one exogenous
action.

The following result states a further P-complete restriction of the above problems.

Theorem 13. k-Maintainability and Maintainability with no exogenous actions are P-complete.

Proof. Membership in P was established above. The P-hardness follows from Theorem 11 by merging the (single) exogenous
action e into the agent actions as follows: For each state s such that e ∈ exo(s), redeﬁne every action a ∈ poss(s) ∩ Aag by
Φ(s, a) := Φ(s, a) ∪ Φ(s, e). It is easy to see that given S and E, S is |S|-maintainable w.r.t. E in the resulting system A
iff
S is |S|-maintainable w.r.t. E in A. Furthermore, A

is computable in logspace from A. This implies the result. (cid:2)

(cid:7)

(cid:7)

The hardness results above are at the border of the hardness frontier, in the sense that in the absence of exogenous
actions and, in case of Maintainability also non-determinism, the problems are no longer P-hard. The following lemma
gives a useful characterization of k-maintainability for this purpose.

Lemma 14. Given a system A = (S, A, Φ, poss), a set of agents action Aag ⊆ A, and a set of states E, a set of states S is k-maintainable
with respect to E in absence of exogenous actions (i.e., exo is void), k (cid:2) 0, iff rk(s) as in (1) holds for all s ∈ S.

Proof. For the only if direction, consider any 1-maintaining control K which without loss of generality is undeﬁned on
every s ∈ E. For every state s ∈ Closure(S, A K ,exo) = Closure(S, A K ), let ds be the distance of s from E under K , i.e., the

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1457

largest i such that σ = s0, s1, . . . , si ∈ Unfoldk(s, A, K ) where s0 = s. By an easy induction on ds (cid:2) 0, we obtain using K (s) as
witness for a in (1), that rds (s), rds+1(s), . . . , rk(s) must hold for s. Hence, rk(s) holds for every s ∈ S.

Conversely, let for each s ∈ S be is the least integer i such that ri(s) holds. If is > 0, then deﬁne K (s) := a for some
arbitrary action a ∈ Aag ∩ poss(s) witnessing (1) for i + 1 = is, otherwise (i.e., if is = 0 or ri(s) does not hold for any i (cid:2) 0)
let K (s) undeﬁned. Then, K is a k-maintaining control for S with respect to E, since by deﬁnition of the relations ri , for
each s ∈ Closure(S, A K ), and σ = s0, s1, . . . , sl ∈ Unfoldk(s, A, K ) such that s0 = s it holds that l (cid:3) k and sl ∈ E (recall that, as
tacitly assumed, Φ(a, s) (cid:4)= ∅ for each a ∈ poss(a)). Hence, S is k-maintainable with respect to E. (cid:2)

We then establish the following result.

Theorem 15. k-Maintainability and Maintainability for systems with only deterministic actions and no exogenous actions
are NL-complete.

(cid:7) = Φ(s, a) can be
Proof. In this case, deciding ri(s) for given s ∈ S and i (cid:2) 0 is in NL: If s /∈ E, a proper a in (1) and s
(cid:7)) established, maintaining a counter i. This is feasible in logarithmic workspace in the
guessed and, recursively, rk−1(s
representation size of A. By looping through all s ∈ S, it thus follows from Lemma 14 that deciding whether S is k-
maintainable with respect to E, where k (cid:3) |S|, is non-deterministically feasible in logarithmic workspace. This implies
NL-membership of k-Maintainability and Maintainability. The hardness follows from a simple reduction of the well-known
NL-complete Reachability problem [57] to k-resp. Maintainability: Given a directed graph G = (V , E) and nodes s, t ∈ V ,
decide whether there is a directed path from s to t in G. Deﬁne A = (S, A, Φ, poss) such that S = A = V , Φ(v, w) = w,
and poss(v) = {w | v → w ∈ E}. Then, for Aag = A, S = {s} is |V |-maintainable w.r.t. E = {t} in A iff there is a directed path
from s to t in G. Clearly, A is constructible in logarithmic workspace from G. This shows the NL-hardness. (cid:2)

In case of constant k, Eq. (1) is decidable by a straightforward deterministic recursive procedure in logarithmic workspace,
even under non-determinism, since the recursion depth is bounded by a constant and each recursion level requires only
logarithmic work space. Hence, k-Maintainability is decidable in logarithmic space. A ﬁner grained analysis that it is within
the class Π log
k+1 of the logarithmic time hierarchy, which is a much better upper bound and makes completeness for logspace
(under suitable reductions) fairly unlikely.

We assume that the input I of k-Maintainability for ﬁxed k, is a relational structure MI with universe U (MI ) = S ∪ A,
(cid:7)), in_poss(s, a), in_exo(s, a), in_S(s) and in_E(s) from above, and
and relations over U (MI ) for the predicates in_Phi(s, a, s
relations for the additional predicates ag_act(a), in_S(s), and in_A(a) representing membership a ∈ Aag, s ∈ S and a ∈ A
for each s, a ∈ U (M ), respectively. The structure MI is encoded in a standard way by a bit-string [38].

Theorem 16. Problem k-Maintainability for systems without exogenous actions is in Π log

2k+1 (= co-Σ log

2k+1), if k (cid:2) 0 is constant.

Proof. Any ﬁrst-order formula ψ1 ∨ Q xψ2 (resp. ψ1 ∧ Q xψ2) such that ψ1 has no free variables and Q ∈ {∃, ∀}, is logically
equivalent to Q x(ψ1 ∨ ψ2) (resp. Q x(ψ1 ∧ ψ2)). Exploiting this, rk(s) in (1) can be written, using the vocabulary from above,
as a ﬁrst-order formula φk(x) in prenex form ∃x1∀x2∃x3 · · · Q kxkψ(x1, . . . , xk, x) where ψ(x1, . . . , xk, x) is quantiﬁer-free, such
that for any element s ∈ U (MI ) of an input structure M, the sentence in_S(s) ∧ φk(s) is true on M iff rk(s) holds. Hence,
by Lemma 14, k-maintainability of S w.r.t. E in A is deﬁnable by a Πk+1 prenex sentence ∀x0∃x1 · · · Q kxkψ (cid:7)(x0, x1, . . . , xk),
where ψ (cid:7)(x0, x1, . . . , xk) is quantiﬁer-free, on the above vocabulary. Whether a ﬁxed such sentence is false on a given
structure MI can be decided by an alternating Turing machine, starting in an existential state, in logarithmic time using k
alternations [11,38]. Hence, the problem is in co-Σ log
2k+1. (cid:2)
k+1

= Π log

We remark that the hardness results in this section can be further strengthened to the case where only 2 agent actions

are available, but leave a proof of this to the interested reader.

7.3. State variables

The following is an easy lemma, which in combination with the results in the previous subsection implies most upper

bounds in Table 2.

Lemma 17. For any instance of k-Maintainability resp., Maintainability in which states are represented by variables, the corre-
sponding instance in ordinary (enumerative) form can be generated in polynomial workspace.

Using this lemma, we then prove the following result.

Theorem 18. Under state representation by variables, k-Maintainability is EXP-complete. The EXP-hardness holds under the restric-
tion that k = f ( A, S, E) is any function of A, S, and E such that f ( A, S, E) (cid:2) 1 (in particular, for ﬁxed k (cid:2) 1), even if in addition all
actions are deterministic and there is only one exogenous action.

1458

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

Proof. Membership in EXP follows easily from Lemma 17 and Theorem 11. The EXP-hardness is shown by a reduction from
deciding inference π |(cid:8) p(t) of a ground atom p(c) from a function-free Horn logic program π with variables (i.e., a datalog
program), which consists of rules of the form

p0(t0) ← p1(t1), . . . , pn(tn), n (cid:2) 0,

(3)

where each pi is the name of a predicate of arity ai (cid:2) 0 and ti = ti,1, . . . , ti,n is a list of constants and variables ti, j ; p0(t0)
is the head and p1(t1), . . . , pn(tn) the body of the rule.

It holds that π |(cid:8) p(c) iff there is a sequence rules ri of the form pi0 (ti0 ) ← pi1 (ti1 ), . . . , pin (tin ) and substitutions θi
for ri , i.e., a mappings from the variables in ri to the set of constants Cπ in π , such that {pi1 (ti1 θi), . . . , pin (tin θi)} ⊆
{p10 (t10 θ1), . . . , pi−10 (ti−10 θi−1)}, for all i ∈ {1, . . . , m} (thus in particular, 1n = 0) and pm0 (tm0 θm) = p(c), called a proof of
p(c) from π . Informally, p(c) is derived by successive application of the rule instances r1θ1, . . . , rmθm, like in a propositional
logic program.

Deciding whether π |(cid:8) p(t) is well-known to be EXP-complete, cf. [22]. The construction is similar in spirit to the one

in proof of Theorem 11 but more involved.

To prove EXP-hardness of k-Maintainability under the given restriction, we ﬁrst focus on 1-Maintainability, and we
describe how to reduce π |(cid:8) p(c) in logarithmic workspace to deciding 1-maintainability of a set of states S w.r.t. a set of
states E in an agent system A.

Without loss of generality, we make the following assumptions on π and p(c):

• The set of constants occurring in π , Cπ , is {0, 1};
• each rule r in π has either zero or two atoms in the body;
• all rules in r are safe, i.e., each variable X occurring in the head of a rule r also occurs in the body;
• π uses only one predicate, p;
• c = (0, 0, . . . , 0).

Any problem π |(cid:8) p(c) can be transformed to an equivalent one of this form in logarithmic workspace.

Similar as in the propositional case, the idea is to represent a reversed proof rm, θm, . . . , r1θ1 of p(c) from π through
agent actions, and model backward rule applications through agent actions; note that m ranges from 1 to 2ap , where ap
is the arity of p (thus m requires ap bits). The problem here which makes this more complex is the fact that we must,
for each rule ri , also take θi into account. If ri has a nonempty body, the candidates for θi are systematically generated by
alternating agent and exogenous actions. For each possible such θi , the derivation of the body atoms p(ti2 θi) and p(ti2 θi) is
then explored.

More precisely, for each ground atom p(c), and m ∈ {0, . . . , 2pa }, we have a state (c, m, prove) outside E which intuitively
says that p(c) is derivable within m (0 (cid:3) m (cid:3) 2pa ) steps. For each rule r in π , there is an agent action ar , which is possible
on (c, m, prove) if m > 0 and p(c) uniﬁes with the head p(t) of r, and it results in the state (c, m, r, apply), which is in E.
For r of form p(t) ← p(t1), p(t2), two phases are now established: (1) the selection of a substitution θ for the variables X
in r, and (2) the generation of states (c1, m−1, prove) and (c1, m−1, prove), where c1 = θ1 and c2 = θ2, for the recursive
test.

As for 1) an exogenous action e pushes the agent from (c, m, r, apply) to a state (c, m, (0, 0, . . . , 0), r, sel_θ). Here
(0, 0, . . . , 0) is the substitution θ : X1 = 0, . . . , Xk = 0 to all variables in r. By executing an agent action incθ on this
state, this vector is incremented to (0, 0, . . . , 0, 1), resulting in a state (c, m, (0, 0, . . . , 0, 1), r, incθ ) in E, from which e
pushes the agent to a state (c, m, (0, 0, . . . , 1), r, sel_θ), where Xn = 1 in θ . Here again incθ is possible, leading to a state
(c, m, (0, 0, . . . , 1, 0), r, incθ ) in E from which e pushes the agent to the state (m−1, t, (0, 0, . . . , 1, 0), r, sel_θ). Here again
an inc action is possible for the agent etc.

In each state (c, m, θ, r, sel_θ) such that p(tθ) = c, the agent might alternatively take the action choose, which brings
her to the state (c, m, θ, r, chosenθ ) in E, which closes phase 1. The exogenous action e pushes the agent from this state to
the state (m, t1θ, t2θ, do_split) out of E. From this state, e pushes the agent further to the state (t1θ, m−1, prove), and the
agent must take at (m, t1θ, t2θ, do_split) the action split, which brings her to the state (t2θ, m−1, goto_prove) in E, from
which e pushes the agent to (t2θ, m−1, prove). Fig. 12 gives a summary of the steps in graphical form.

Fig. 12. Schematic transition diagram for backward application of rule r : p(t) ← p(t1), p(t2) with substitution θ to prove p(c).

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1459

In this way, the derivation of p(0, 0, . . . , 0) from π is encoded to deciding 1-maintainability of S = {(2d, (0, 0, . . . , 0),
prove)} with respect to the set of states E described above. Note that to prove p(c) from π via rule r, only one instance
of rθ must be chosen; the 1-maintaining control has to single out this θ , by proper placement of the action chosenθ . The
proof of correctness is along the lines of the respective one in Theorem 11.

Given the regular structure of the states and the easy checks and manipulations that need to be done for determining
applicability of actions and determining the successor state, respectively, it is not diﬃcult to see that a representation of the
above 1-Maintainability instance using state variables can be compiled from π and p(0, 0, . . . , 0) in logarithmic work space
(cid:7)), in_poss(s, a),
(in particular, that the polynomial-time procedures for deciding the membership predicates in_Phi(s, a, s
in_exo(s, a) in_S(s), and in_E(s) can be provided in polynomial time). Note that this instance employs only deterministic
actions, and there is a single exogenous action. This establishes EXP-hardness for 1-Maintainability.

Furthermore, for A and E as constructed, each agent action results in a state in E. Thus, k-maintainability of S w.r.t. E in
A, for any k = f ( A, S, E) such that f ( A, S, E) (cid:2) 1, is equivalent to 1-maintainability of S w.r.t. E in A. Hence, the reduction
shows EXP-hardness of k-Maintainability under the stated restriction. (cid:2)

Corollary 19. Under state representation by variables, Maintainability is EXP-complete. The EXP-hardness holds even if all actions
are deterministic and there is only one exogenous action.

Using Theorem 18 instead of Theorem 11, we can prove the following result similarly as Theorem 13:

Theorem 20. Under state representation by variables and in absence of exogenous actions, k-Maintainability and Maintainability
are EXP-complete.

For the case without exogenous actions and with only deterministic actions, we have lower complexity:

Theorem 21. Under state representation by variables, k- Maintainability and Maintainability for systems with only deterministic
actions and no exogenous actions are PSPACE-complete.

Proof. By well-known standard methods, a computation composed of a PSPACE computation A piped into an NL computa-
tion B (which is NPSPACE in the size of the input for A) can be redesigned as an NPSPACE computation. Since NPSPACE =
PSPACE, membership of the problems in PSPACE thus follows from Lemma 17 and Theorem 15.

The PSPACE-hardness can be shown e.g. by a straightforward reduction from propositional STRIPS planning [16]. Rather
than to introduce STRIPS here, we give for completeness sake a simple reduction from Succinct Reachability [57], which
is the version of Reachability where G = (V , E) is such that the nodes v are given by the binary vectors v = (v 1, . . . , vn),
n (cid:2) 1, on {0, 1} and the problem input consists of a Boolean circuit C G with 2n inputs v 1, . . . , vn, w 1, . . . , wn which outputs
true iff v → w ∈ E, and s = (0, 0, . . . , 0) and t = (1, 1, . . . , 1). We construct from this an instance of k-Maintainability resp.
Maintainability as follows: S = V × V , described by 2n binary variables f 1, . . . , f 2n; A = {inc, arc} = Aag; Φ(v × w, inc) =
(cid:7) = w + 1 modulo 2n, and Φ(v × w, arc) = w × (0, 0, . . . , 0) if v → w in G and Φ(v × w, arc) = v × w
v × w
otherwise; poss(s) = A, for each state s. Then, the state s = (1, 1, . . . , 1) × (0, 0, . . . , 0) is |S|-maintainable with respect to
E = {(1, 1, . . . , 1) × (1, 1, . . . , 1)} in A iff (1, 1, . . . , 1) is reachable from (0, 0, . . . , 0) in G. A state variable representation of
A can be easily generated from the circuit C G in logarithmic workspace. This implies PSPACE-hardness of the problems. (cid:2)

such that w

(cid:7)

If the maintenance window is bounded by a constant, the problem is easier.

Theorem 22. Under state representation by variables, k-Maintainability for systems without exogenous actions and constant k (cid:2) 0
is co-NP-complete.

Proof. For a given s ∈ S, falsity of rk(s) can be proved by exhibiting (assuming s /∈ E), for each a ∈ Aag ∩ poss(s) a witness
w(s, a) ∈ S such that w(s, a) ∈ Φ(s, a) and rk−1(w(s, a)) is false, which in recursion can be proved similarly. For constant
k, this leads to O (|Aag|k) many guesses w(s, a), which is polynomial in the size of the input. By Lemma 14, it thus follows
that deciding the complement of k-Maintainability is in NP. This proves membership in co-NP.

The co-NP-hardness, for every k (cid:2) 0, is a simple consequence that under representation by state variables, deciding

whether S ⊆ E is co-NP-complete (this can be shown, e.g., by a simple reduction from propositional unsatisﬁability). (cid:2)

8. Discussion and conclusion

In this paper, we gave a formal characterization of maintenance goals and distinguished it from the notions of stabi-
lizability and temporal goals of the form (cid:2)(cid:3) f (over all valid trajectories). We present several motivating examples that
illustrate the need for our notion of maintainability. The basic idea being that for certain kinds of maintenance it is im-
portant that the maintaining agent be given a window of non-interference from the environment so that it can do the

1460

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

maintenance. To formalize this we need to distinguish between the agent’s actions and the environment’s actions. In our
formalization we deﬁne the notion of k-maintainability, where k refers to the maximum window of opportunity necessary
for the maintenance. We then gave polynomial time algorithms to compute k-maintainable controls, which are linear-time
for small k, and we analyzed the complexity of determining k-maintainability under various assumptions. One interesting
aspect of our polynomial time algorithm is the approach that led to its ﬁnding: the use of a SAT encoding, and complexity
results regarding the special Horn sub-class of propositional logic.

We next report on some experiments which we have carried out, and we then discuss related work, before we conclude.

8.1. Experimental results

The different methods for constructing k-maintaining controls in the previous sections have been implemented, in order
to compare them on an experimental basis. More speciﬁcally, programs generating the SAT encoding and the Horn SAT
encoding, the latter written as a propositional logic program, have been implemented in Java, and also the algorithm k-
Control. For SAT solving, zChaff has been employed and for evaluating the Horn SAT instances the answer set solvers DLV
and Smodels plus its preprocessor Lparse. The logic programs with variables given in Section 6 are ready for use in DLV as
described, and only minor adjustments are needed for Smodels. The encodings and implementations are, together with the
descriptions of the domains, available at http://www.public.asu.edu/~jzhao6/k-maintain/.

To evaluate the performance of the implementations, we conducted experiments on the buffer domain described in
Section 3, varying the size of the buffers, max, and the number k for a maintaining control. In all experiments, there was a
single goal state, (0, 0) (i.e., both buffers are empty), and a single initial state, which in was either (1, 1) or (3, 5); note that
in both cases, the smallest k for which a k-maintaining control exists is k = 2∗ max +1.

The results of the experiments are shown in Table 3. They were collected on a Dell desktop with an Intel Pentium 4
(2.53 GHz), 512 MB main memory, and 753 MB swap space, under Slackware 11.0 including Linux kernel 2.4.33.3. We used
a pre-release (beta-version) of DLV version 2007-10-11,8 Lparse 1.0.17, and Smodels 2.32. In the table, the leftmost column
shows the buffer size max and the parameter k; the rightmost column tells whether a solution exists or not. The times
reported are for deciding whether a k-maintaining control exists, i.e., computing a model, from which a control can be
eﬃciently extracted (in fact, in linear time); also for the genuine algorithm, output of a control in Step 4 is fast.

For the SAT and the Horn SAT encodings, the column “instance” shows the timings for generating the respective instances
in Section 6.3 from the input representation in Section 6.1, and the other columns show the timings for solving the instances
using a respective solver; the numbers in parentheses is the total of instance generation and solving. Since Lparse, the
preprocessor of Smodels, already solves the Horn SAT instances, the call of Smodels has actually been omitted. The column
“genuine algorithm” shows the results for the implementation of Algorithm k-Control, and the columns right of it the
results for the logic programming encodings, both the one for deterministic and for non-deterministic transition function.
Here the problem input was not in explicit form by facts but described by rules as in Section 6.5. However, generating the
factual representation takes only short time (between 14 and 115 ms for larger problem size) and is negligible compared to
the time required for solving the instance.

The experiments show some interesting results. Among the SAT and Horn SAT solving methods, the logic programming
engines perform overall better than the SAT solver. This is explained by the fact that generating the SAT instance for the
solver takes much longer than generating the corresponding Horn logic program. One possible reason is that the input
format of the SAT solver requires that strings are mapped to integers which represent propositional variables. This has been
done using a hashmap with vectors; a better design of the data structure may save some time on this translation. On the
other hand, the SAT solver needs less time to solve an instance than the LP engines. We remind, though, that the latter are
committed to compute a special model, while the SAT solver may compute an arbitrary model of the instance.

The SAT solver scales reasonably well on the instances, and similarly DLV which is within a small factor in most cases.
Moreover, DLV also scales well regarding the overall time, while Smodels showed some weakness here. Both SAT solving and
Horn logic programs have limitations when the constructed instances become larger, since the memory may be exhausted
(however, as for memory the experimental setting was modest).

The genuine algorithm is faster than the SAT solving method on larger instances, but slower than Horn SAT solving. The
latter may be explained by the fact that the internal Java data structures used (vectors and maps) are not optimal. However,
the implementation scales well with respect to k.

The logic programming encodings with variables behave similar to the Horn SAT encodings, and apart from one case the
timings for the non-deterministic LP encoding in Lparse+Smodels are comparable to those for the Horn SAT method using
DLV. The non-deterministic LP encoding in DLV is in many cases faster than the one of Lparse+smodels, but shows a less
smooth scaling in some cases. This discrepancy may be explained by the different heuristics which is used by the systems
in the model search. The deterministic encodings are, in both cases, faster than the non-deterministic counterparts, but the
speedup is limited by a small factor (between 2 and 3).

We remark that extracting an actual control out of the model computed an LP engine, by adding the rules in Section 6.2
to the program does not scale well for large k in general. The reason is that the rule for k_plus has, for each single

8 Kindly provided by the DLV team. The oﬃcial release 2007-10-11 behaves similarly.

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1461

Table 3
Experimental results for deciding k-maintainability in the Buffer Domain (times in secs)

start state (1,1), goal state (0,0)

Problem
max, k

SAT encoding

instance (zChaff)

Horn SAT
instance (Lparse + Smodels)

10,5
10,10
10,15
10,20
10,21
10,25
10,30
10,35
10,40
10,45

20,5
20,10
20,15
20,20
20,25
20,30
20,35
20,40
20,45
20,50
20,55
20,60

0.648 0.021
1.439 0.062
3.320 0.079
6.543 0.100
7.421 0.209
12.335 0.276
19.467 0.346
26.236 0.398
35.321 0.417
45.195 0.463

(0.669)
(1.501)
(3.399)
(6.643)
(7.630)
(12.611)
(19.813)
(26.634)
(35.738)
(45.658)

(8.054)
7.933 0.121
(35.221)
35.043 0.178
(88.978)
88.729 0.249
(164.540)
164.208 0.332
(264.032)
263.623 0.409
(397.537)
397.018
0.519
(564.703)
564.108 0.595
(685.489)
684.858 0.631
852.107 1.990
(854.097)
1073.237 2.315 (1075.552)
2.526 (1326.045)
1323.519
1630.561 3.448 (1634.009)

start state (3,5), goal state (0,0)

20,5
20,10
20,15
20,20
20,25
20,30
20,35
20,40
20,45
20,50
20,55
20,60

30,5
30,10
30,15
30,20
30,25
30,30
30,35
30,40
30,45
30,50
30,55
30,60
30,65
30,70

(7.771)
7.646 0.125
(33.988)
33.814 0.174
(86.507)
86.259 0.248
(158.415)
158.087 0.328
(252.753)
252.355 0.398
(383.609)
383.141
0.468
(525.977)
525.430 0.547
(697.157)
696.514
0.643
893.684 3.417
(897.101)
1072.981 2.831 (1075.812)
1327.165 2.541 (1329.706)
1601.926 3.335 (1605.261)

51.410

(51.629)
0.219
(206.995)
206.631 0.364
(496.586)
496.045 0.541
866.907 0.723
(867.630)
1388.404 0.880 (1389.284)
1971.139 1.065 (1972.204)
1.267 (2686.884)
2685.617
3408.562 1.663 (3410.225)
4272.727 1.818 (4274.545)
out of memory
out of memory
out of memory
out of memory
out of memory

0.465
0.533
0.613
0.650
0.665
0.688
0.761
0.801
0.851
0.883

2.347
2.532
2.735
2.933
3.207
3.250
3.523
3.691
3.758
3.889
4.071
4.353

2.483
2.564
2.767
2.983
3.113
3.307
3.444
3.607
3.839
3.938
3.981
4.327

10.176
10.569
10.754
11.153
11.595
12.306
12.522
13.252
18.476
31.191

0.435
0.842
1.211
1.676
1.606
1.770
1.656
1.809
2.034
2.111

1.602
3.196
4.240
6.299
7.981
9.709
11.138
12.757
13.119
13.650
13.923
28.818

1.639
3.146
4.661
6.252
7.781
9.242
10.853
13.342
13.781
13.250
13.547
15.091

(0.900)
(1.375)
(1.824)
(2.326)
(2.271)
(2.458)
(2.417)
(2.610)
(2.885)
(2.994)

(3.949)
(5.728)
(6.975)
(9.232)
(11.188)
(12.959)
(14.661)
(16.448)
(16.877)
(17.539)
(17.994)
(33.171)

(4.122)
(5.710)
(7.428)
(9.235)
(10.894)
(12.549)
(14.297)
(16.949)
(17.620)
(17.188)
(17.528)
(19.418)

(13.733)
3.557
(17.482)
6.913
(20.861)
10.107
(24.941)
13.788
(38.341)
26.746
(37.625)
25.319
(137.047)
124.525
665.565
(678.817)
681.040 (699.516)
(624.709)
593.518
out of memory
out of memory
out of memory
out of memory

(DLV)

0.118
0.203
0.271
0.380
0.599
0.743
0.865
1.007
1.220
1.455

0.425
0.814
1.152
1.624
1.955
2.359
3.166
3.560
8.353
7.885
8.247
8.795

0.432
0.860
1.206
1.656
1.925
2.319
3.115
3.388
7.721
7.552
7.681
8.055

0.867
1.862
3.025
3.668
4.664
7.637
7.333
7.675
8.421
9.450

Genuine
Algorithm

DLV

det

Lparse + Smodels

ndet

det

ndet

solution
yes/no

(0.583)
(0.736)
(0.884)
(1.030)
(1.264)
(1.431)
(1.626)
(1.808)
(2.071)
(2.338)

(2.772)
(3.346)
(3.887)
(4.557)
(5.162)
(5.609)
(6.689)
(7.251)
(12.111)
(11.774)
(12.318)
(13.148)

(2.915)
(3.424)
(3.973)
(4.639)
(5.038)
(5.626)
(6.559)
(6.995)
(11.560)
(11.490)
(11.662)
(12.382)

1.819
3.127
4.269
5.576
5.598
6.235
5.440
5.412
5.422
5.418

23.177
43.569
67.770
82.192
102.264
120.628
144.418
151.763
162.128
172.677
193.645
152.911

22.734
41.956
59.228
78.784
95.766
115.793
132.549
150.920
161.092
172.896
185.470
153.073

125.925
(11.043)
235.732
(12.431)
332.056
(13.779)
444.367
(14.821)
(16.259)
535.193
(19.943) 646.284
742.747
(19.855)
863.109
(20.927)
(26.897)
940.408
(40.641) 1065.352
1155.366
1262.594
1319.128
1387.423

0.157
0.094
0.308
0.171
0.485
0.227
0.607
0.282
0.866
0.399
1.771
0.523
4.444
2.022
6.664
2.916
4.310
10.935
5.481 14.787

0.257
0.365
0.486
0.615
0.769
0.971
1.141
1.284
1.445
1.628

0.405
0.691
0.955
1.245
1.536
1.619
1.929
2.226
2.534
2.831

0.655
0.334
1.531
0.934
1.363
0.623
2.765
1.595
2.046
0.915
4.022
2.229
2.878
1.192
5.294
2.862
3.752
1.561
6.573
3.569
4.704
1.844
7.848
4.187
5.932
2.274
4.856
9.108
2.724
6.489
5.536 10.381
3.907 14.954
7.523 12.224
24.345 22.828
8.309 13.655
9.398 15.083
48.505 35.543
79.994 55.327 10.496 16.530

0.355
0.642
0.623
1.349
0.932
2.012
1.220
2.803
1.596
3.592
1.897
4.588
2.247
5.834
6.285
2.653
3.593 13.752
11.786 23.132
20.229 38.767
33.750 62.340 10.415

1.047
1.533
1.611
2.790
2.249
4.026
2.896
5.344
3.573
6.671
4.210
7.944
4.850
9.106
10.363
5.619
7.393 12.216
7.548 13.655
8.924 15.047
16.558

3.904
2.628
1.424
0.871
4.428
7.215
3.003
1.732
6.323 10.395
5.593
2.718
6.784
8.228 13.693
4.090
9.013 10.308 17.057
3.929
4.718
12.072 20.498
12.413
5.846 14.634 13.823 23.927
7.185 16.401 16.230 27.347
8.269 19.305 17.985 30.798
19.646 34.278
9.656 21.914
37.816
11.058 25.889 21.517
41.146
13.481 31.304 23.919
17.987 53.466 29.790 56.084
43.161 89.959 32.501 80.523

no
no
no
no
yes
yes
yes
yes
yes
yes

no
no
no
no
no
no
no
no
yes
yes
yes
yes

no
no
no
no
no
no
no
no
yes
yes
yes
yes

no
no
no
no
no
no
no
no
no
no
no
no
yes
yes

(cid:7)

), i.e., s, s

(cid:7) ∈ Φ(s, a), quadratically many ground instances in k.
possible transition (s,a,s
Although only a single such instance is relevant, the solver can not predetermine it in the grounding phase. However, this
problem can be easily circumvented by keeping the additional rules in a separate post-processing program, and feeding into
it the model computed by the main program. Then, a control is quickly output, in time which is largely dominated by the
time for model computation (in the worst case, in a few seconds).

(cid:7) ∈ S and a ∈ A ∩ poss(s) such that s

ω-maintaining controls: We have also conducted some experiments with different methods for deciding the existence of
an ω-maintaining control. More speciﬁcally, following the two-phase approach in Section 5.4, we have considered proposi-
tional logic programs, a genuine algorithm, and logic programs with variables; note that a SAT encoding for the two phases
is not straightforward, since we need to compute transitive closure in both phases and phase 2 accesses the complement
of the output of phase 1; a simple realization requires layered use of negation for that, which is done in all logic program-
ming encodings (for generic programs with variables, unstratiﬁed negation is avoided using the method in Section 6.4).

1462

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

Table 4
Experimental results for deciding maintainability in the Buffer Domain (times in secs)

s; g sol method/max

10

20

30

40

50

60

70

80

90

100

(1,1); yes propositional DLV
genuine algorithm
(0,0)
Lparse+Smodels
DLV

propositional Lparse 0.333+0.056 1.192+0.186 4.578+0.362 10.182+0.677 23.992+1.041 52.712+2.148 102.632+3.717 181.020+5.801 297.172+9.154 446.141+13.399
0.333+0.018 1.192+0.104 4.578+0.270 10.182+0.439 23.992+0.693 52.712+1.054 102.632+1.134 181.020+1.694 297.172+2.134 446.141+2.535
–
42.432
23.770

4576.097
6.206
5.781

1835.164
3.278
4.071

9762.176
10.949
8.770

629.925
1.522
1.815

152.918
0.631
0.922

20.266
0.226
0.398

–
28.304
17.687

–
17.919
12.832

1.034
0.044
0.124

propositional Lparse 0.342+0.094 1.174+0.224 4.975+0.496 10.765+0.675 25.335+1.237 55.492+2.154 102.401+3.672 180.949+5.808 301.249+8.514 445.678+12.074
(9,1); yes propositional DLV 0.342+0.065 1.174+0.136 4.975+0.330 10.765+0.456 25.335+0.672 55.492+0.984 102.401+1.172 180.949+1.534 301.249+2.103 445.678+2.446
–
(5,5)
43.868
23.106

genuine algorithm
Lparse+Smodels
DLV

2813.434
7.140
5.656

5097.606
10.909
8.653

1315.840
3.234
3.626

553.806
1.497
1.725

127.646
0.610
0.903

–
28.932
17.505

–
19.647
12.048

15.898
0.200
0.388

0.738
0.048
0.056

(3,2); no propositional DLV
genuine algorithm
(4,4)
Lparse+Smodels
DLV

propositional Lparse 0.357+0.072 1.184+0.213 4.647+0.376 10.191+0.630 23.965+1.054 52.574+2.074 102.743+3.640 180.601+6.251 302.436+8.869 445.867+12.019
0.357+0.017 1.184+0.129 4.647+0.222 10.191+0.316 23.965+0.507 52.574+0.807 102.743+1.006 180.601+1.282 302.436+2.392 445.867+2.177
–
43.159
17.803

8973.392
11.122
6.286

2772.359
6.553
4.035

1281.064
3.384
2.414

125.848
0.591
0.617

542.273
1.503
1.322

–
28.787
13.152

–
18.343
9.292

15.702
0.180
0.259

0.698
0.049
0.040

(1,9); no propositional DLV
genuine algorithm
(7,4)
Lparse+Smodels
DLV

propositional Lparse 0.345+0.090 1.101+0.217 4.588+0.374 10.173+0.688 24.085+1.162 52.655+2.092 102.092+3.633 180.900+5.771 298.540+8.529 446.833+11.969
0.345+0.017 1.101+0.093 4.588+0.196 10.173+0.297 24.085+0.497 52.655+0.800 102.092+1.013 180.900+1.291 298.540+1.844 446.833+2.170
–
43.260
18.442

3943.009
6.325
4.005

1523.882
3.512
2.377

8735.724
11.194
6.219

498.534
0.503
1.280

112.653
0.607
0.581

–
28.862
12.922

–
18.351
9.190

12.519
0.184
0.214

0.511
0.051
0.066

Phase 2 is, in fact, realized in the logic programs via computing ﬁrst the set of all states which must be pruned, and then
complementing it.

The results of our experiments are summarized in Table 4. There, s is the single start state and g the single goal state.
For each propositional LP program, both the times for creating it from the factual representation and for solving it are
shown (in ms); a dash “–” means timeout after 10,000 seconds. The ﬁrst two instances have a solution, while the latter two
are not. As can be seen, the LP encodings with variables scale well, with a linear time trend (note that the instance size
of the problem is quadratic in the buffer size). Unsurprisingly, the propositional LP encodings are evaluated faster than the
LP encodings with variables, but a lot of time is needed to construct the respective programs; in total, using non-ground
programs is much faster. The implementation of the genuine algorithm does not scale well, and is way slower than the LP
encodings. However, similar as in the case of k-maintainability, the implementation does not use optimal data and storage
structures and therefore has room for improvement.

We remark that the propositional LP encoding can be constructed faster (in the experiments, up to almost four times), if
one exploits that the domain is deterministic. Furthermore, a variant of the DLV encoding with variables, in which pruning
in phase 2 is focused to the states having an a-path to the goal set (determined in phase 1), shows very similar performance.
With respect to our methodological approach, we can observe the following. Using SAT solving and logic programming
to construct k-maintaining and ω-maintaining controls is, at least in this example, not only of theoretical interest, but also
shows value to obtain some quick implementations which perform reasonably well. Genuine algorithms that are extracted
from SAT or logic programming solutions have potential, but they require implementation and optimization efforts in order
to become highly eﬃcient and signiﬁcantly faster then the ﬁrst shot methods. In particular, if the state space is not too
large and the maintenance window small, a logic programming based approach is attractive, where we may keep in mind
that further preferences or constraints may be imposed on solutions in a declarative manner.

8.2. Relation with earlier work on control synthesis

In this section, we compare our work with earlier work on control synthesis [1,10,19,41,49,60]. We start with the papers

by Barbeau et al. [10] and Kabanza et al. [41] from the AI literature.

8.2.1. Relation with Barbeau et al.’s and Kabanza et al.’s work

Barbeau et al. [10] and Kabanza et al. [41] present a method to synthesize reactive plans9 based on progressing for-
mulas in a linear temporal logic, called Metric Temporal Logic (MTL), which allows to specify durations in the temporal
operators. If we ignore the durations of the operator then their speciﬁcation language is the linear temporal logic LTL with
operators (cid:9), (cid:2), (cid:3) and U . Similar to ours, they allow actions to have non-deterministic transitions. However, [41] does not
allow exogenous actions. Although [10] allows exogenous actions, it requires that exogenous actions and agent actions be
interleaved. Thus to use their formulation one has to translate our formalism to theirs. For example one can compile away

9 Their notion of reactive plans are slightly different from our notion of control functions; in their case a state, which they call a world state, may have
many associated plan states. For our type of goal, control functions in our sense can however be easily extracted from their “reactive plans” without a
blowup.

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1463

exogenous actions10 from our formulation and, as mentioned earlier, introduce a ﬂuent interfered to remember that a transi-
tion was made immediately made due to an exogenous action. The resulting transition function will have non-deterministic
transitions and thus would need the speciﬁcation Aπ ((cid:2)(φS ⇒ (cid:2)(Step[k](interfered ∨ φE )))) in the language of [9] to express
k-maintainability. However, the control generation algorithm in [10,41] is able to construct a control for all goals of the form
Aπ f , where f

is an LTL formula and the algorithm focuses on f .

Their algorithm is based on progressing an LTL formula. The intuition behind progression is that given a sequence of
states σ = s0, s1 . . . and an LTL formula f , the progression of f with respect to a state si satisﬁes the property: (σ , i) |(cid:8) f
iff (σ , i + 1) |(cid:8) progression( f , si).

A partial deﬁnition of progression, as needed for our illustration, is as follows:

• for a proposition p, progression(p, s) is true if p is true in s else is false.
• progression(¬ f , s) = ¬progression( f , s)
• progression( f ∧ g, s) = progression( f , s) ∧ progression(g, s)
• progression( f ∨ g, s) = progression( f , s) ∨ progression(g, s)
• progression((cid:2) f , s) = progression( f , s) ∧ (cid:2) f
• progression((cid:9) f , s) = f .

To illustrate how their algorithm works, we consider an important fragment of the LTL part of our goal: (cid:2)(Step[k]
(interfered ∨ φE )). To simplify further, let ϕ denote interfered ∨ φE , and let sϕ denote a state where ϕ is true and s¬ϕ denote a
state where ϕ is not true. In the following, let progression( f , s1, s2, . . . , sn) denote progression(progression(. . . progression( f , s1),
. . .), sn). We now illustrate how progression works with respect to the above goal:

• progression((cid:2)Step[k](ϕ), sϕ) = (cid:2)Step[k](ϕ) = Step[k](ϕ) ∧ (cid:9)(cid:2)Step[k](ϕ)
• progression((cid:2)Step[k](ϕ), s¬ϕ) = Step[k−1](ϕ) ∧ (cid:2)Step[k](ϕ) = Step[k−1](ϕ) ∧ (cid:9)(cid:2)Step[k](ϕ)
• progression((cid:2)Step[k](ϕ), s¬ϕ, s¬ϕ) = Step[k−2](ϕ) ∧ (cid:9)(cid:2)Step[k](ϕ)
• progression((cid:2)Step[k](ϕ), s¬ϕ, s¬ϕ, s¬ϕ) = Step[k−3](ϕ) ∧ (cid:9)(cid:2)Step[k](ϕ)

and so on. As evident from the above the progression may lead to k different formulas. The general algorithm in [10,41]
introduces decomposition due to the ∨ connective in Step[k](ϕ) and can have 2k formulas labeling a state, leading to a
search space of 2k × |I|. Since one does not need to worry about cycles, one can avoid double exponential search.

However, noticing that our goal speciﬁcation does not have unbounded eventualities, one can also modify the algorithm
to avoid decomposition and thus restrict to a search space of k × |I|. After that one needs to do an eﬃcient search in this
search space as the search algorithm given in [10,41] does not seem to do eﬃcient backtracking.

In conclusion, although the algorithm in [10,41] as presented does not ﬁnd a k-maintainable control in polynomial time,
certain modiﬁcations make that algorithm more eﬃcient. This illustrates the importance of the work [10,41]. It suggests the
research direction of exploring various sub-classes of LTL goal speciﬁcations and identifying appropriate modiﬁcations or
simpliﬁcations of the algorithms in [10,41] so that they lead to a more eﬃcient control ﬁnding method. In slight contrast,
our approach has been to ﬁnd an eﬃcient algorithm for a speciﬁc goal through logical manipulations. It led us to ﬁnding
eﬃcient and different algorithms for other goal speciﬁcations such as strong planning, strong cyclic planning and weak
planning, which we discuss in [4].

8.2.2. Relation with other work on control synthesis

Most of the other works on control synthesis dates back earlier, around the time when various temporal logics were

proposed for program speciﬁcation purposes.

Clarke and Emerson [19] consider speciﬁcations in the branching time temporal logic CTL and present an algorithm to
construct synchronization skeletons of concurrent programs from scratch. The algorithm constructs a ﬁnite model of the
formula using a tableau-based procedure, and factors the control skeletons of the individual processes out from the global
ﬂow graph deﬁned by the model. There is no complexity analysis given, but the authors mention that the algorithm is
potentially exponential. Furthermore, the algorithm assumes a closed system, in which neither environment actions nor

10 One compilation involves the following: (i) For each state s a new state called sint is created. The states s and sint are equivalent with respect to all
ﬂuents except the newly introduced ﬂuent interfered, which is false in the former and true in the later. (ii) All edges in the original transition diagram due
due to an agent action a in the original transition diagram, then a transition from sint to
to agent actions are kept. (iii) If there is a transition from s to s
(cid:7)
to s due
s
(cid:7)
to an agent action a, then a transition from s
int is introduced. (v) The set of initial states is enlarged as follows: If s is an initial state and there is a
transition from s to s

(cid:7)
int is made an initial state.
However, the complexity results in Table 1, and the following discussions suggest that such a compilation has a high worst-case effort, and is not doable

due to agent action a is introduced. (iv) For all transitions between s and s

due to a series of exogenous actions, if there is an edge from s

due to a series of exogenous actions then s

to s

(cid:7)(cid:7)

(cid:7)(cid:7)

(cid:7)

(cid:7)

(cid:7)

in non-deterministic logspace. This remains true with respect to any other compilation where the new k depends only on the old k.

It may be noted that with respect to our buffer example the above compilation is not linear in the size of the input; indeed, the original transition has
O (n2) many nodes and arcs (where n is the buffer size), while the compiled one has O (n2) many nodes but (cid:14)(n3) many arcs, which come in through
transitive closure of exogenous actions. Thus, in that example doing the compilation and then solving the LTL planning problem, to solve k-maintainability
(for a ﬁxed k), is not a linear time algorithm.

1464

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

speciﬁc agent actions (which constrains the model building) are respected. However, this is crucial for the construction of
a k-maintaining control; applied to the CTL speciﬁcation of such a control for S w.r.t. E, the algorithm may return, e.g., a
model which has only states corresponding to states outside S.

Independently, Manna and Wolper [49] consider the construction of the synchronization part of communicating processes
from speciﬁcations in the linear time temporal logic PTL. As they mention, the main differences between their approach
and [19] is the usage of PTL instead of CTL, and that [19] synthesizes shared memory programs. Manna and Wolper’s
synthesis method employs a tableau-style satisﬁability algorithm, which is essentially the one in [12] restricted to linear
time operators and modiﬁed to their assumption that in each state exactly one atomic proposition is true. The algorithm
either declares the speciﬁcation to be unsatisﬁable or constructs a “model graph” from which all possible models of the PTL
speciﬁcation can be extracted. In the construction, PTL formulas are decomposed using the identities

(cid:2) f ≡ f ∧ (cid:9)(cid:2) f , (cid:3) f ≡ f ∨ (cid:9)(cid:3) f ,

and

f 1 ∪ f 2 ≡ f 2 ∨ ( f 1 ∧ (cid:9) f 1U f 2),

which enables to model a ﬂow graph by talking about the current and the follow up state in an execution. As Manna and
Wolper argue, the size of the model graph is at most exponential in the size of the speciﬁcation formula. In a ﬁnal step,
the control code is generated from the model graph. Special care is here applied to so called eventuality conditions, which
are conditions of the form (cid:3) f whose satisfaction must not be indeﬁnitely postponed (this aspect was not addressed in
detail in [19]). Since like [19], the method assumes a closed system without an environment, it is not readily applicable for
constructing a k-maintainable control.

Pnueli and Rosner [60] give an algorithm to synthesize a reactive module with input x from and output y to an environ-
ment, where the values are from a ﬁnite domain, speciﬁed by a linear temporal formula ϕ(x, y). The running time of the
algorithm, which is constructed using automata-theoretic results, is at most double exponential in the length of the given
speciﬁcation; by its nature, it is diﬃcult to say how it would perform for the construction of a k-maintaining control.

Abadi et al. [1] introduce a notion of realizability which is somewhat more general than the notion of implementability in
[60], since it also considers an environment whose behavior is restricted. They distinguish environment and agent activity
in changes to the environment, and deﬁne speciﬁcations at an abstract level as sets of behaviors, which are alternating
sequences of states and active parties (which is either the environment, the agent, or none of them), satisfying some
conditions. Realizability is given if a subset of the behaviors can be generated by the runs of a “computer”, which is a
restricted (possibly non-recursive) partial function from preﬁxes of behaviors to states; as noted, realizability is a necessary
but not suﬃcient condition for the existence of a real implementation. A weaker notion of realizability, which takes into
account that the implementor knows exactly how the environment behaves (in a deterministic manner), is considered and
shown to be equivalent to realizability for an important class of speciﬁcations. Finally, the issue of realizability for ﬁnite-
state transition systems P t (represented by automata) equipped with a further restriction on the inﬁnite behaviors of the
systems, given by a (ﬁnite-state) Büchi automaton P i , is considered. As pointed out, this is different from consistency of the
behaviors of P t and P i . Applying, like Rosner and Pnueli, automata-theoretic results, it is argued that deciding realizability
is in EXPTIME and PSPACE-hard under logspace reductions. An important note is that for realizability, Abadi et al. view
non-deterministic transitions as optional outcomes of actions from which an implementor of a realization can choose an
arbitrary subset. For our notion of control, it would be required that if an particular agent action is chosen at a state, then
all outcomes of that action are chosen. Since a realization must merely be compatible with the inﬁnite behaviors, but need
not manifest all of them, enforcing such a choice via the inﬁnite behaviors is infeasible. Hence, the method of [1] seems not
always applicable for constructing a k-maintaining control in our setting.

Recently there have been some works in developing polynomial time control generation algorithms (in the size of the
state space) for particular classes of LTL goals. In particular, the paper [59] presents a cubic algorithm in the size of the
state space to automatically construct controls for GR(1) goals which are of the form ((cid:2)(cid:3)p1 ∧ · · · ∧ (cid:2)(cid:3)pm) ⇒ ((cid:2)(cid:3)q1 ∧
· · · ∧ (cid:2)(cid:3)qn), where pi s and q j s are propositional formulas. This complexity is still higher than our algorithm; however, it
remains open to ﬁnd out if our approach can lead to a more eﬃcient algorithm for GR(1) goals.

8.3. Other related work

Besides the related works we already mentioned such as stabilizability and temporal logic, the notion of maintenance has
appeared in AI in many other papers. For example, in [55], Ortiz discusses maintenance actions. His notion of maintenance
is stronger than both the notion of stabilizability and our notion as he requires the formula that is maintained to be
true throughout. The notion of maintenance is also related to the notion of ‘execution monitoring’ which is studied in
the context of robot programs in [23]. In ‘execution monitoring’ the world is monitored and if a discrepancy is found
between the prediction made by the agent and the real world, then new plans are made to recover from the discrepancy.
A deliberative architecture for maintenance can be extrapolated from the notions in [5], where an agent executes a cycle of
observe; assimilate; (re)plan_from_current_situation; execute_part_of _the_plan.

In a series of papers [27,28,69], Wooldridge and Dunne have formalized the problem of constructing agent control func-
tions and analyzed its complexity in a rich framework, for various kinds of tasks such as ‘achievement’ tasks (where the
agent has to bring about a certain goal condition), ‘maintenance’ tasks (where the agent has to avoid that some goal con-
dition is ever satisﬁed during execution), and combinations thereof [27]. Their notion of boolean task speciﬁcation allows
a seamless combination of ‘achievement’ and ‘maintenance’ goals. In their notion a goal speciﬁcation is a propositional

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1465

formula where each proposition corresponds to a set of states. The intuitive meaning of a goal speciﬁcation p would be
to reach for sure one of the states corresponding to p. This corresponds to an achievement goal, while a speciﬁcation ¬p
intuitively means that the agent should avoid any state in p. They refer to the later as a ‘maintenance task with bad states’.
Thus their notion of ‘maintenance’ differs from ours. While we are concerned with the hindrance posed by the adversary
explicitly, and take into account the number of steps when the adversary is not interfering, they do not take exogenous
actions into account explicitly. They allow non-deterministic effect of actions, and although one can partially take exoge-
nous actions into account by a straightforward compilation, keeping the count of the window of non-interference is not
straightforward. Their control policies are richer than ours. In their framework, action effects and the selection of the agent
action by the control may depend on the history of the execution. Under restriction to history-independent state transitions
and reactive agents, ﬁnding controls for achievement tasks in their framework corresponds to ﬁnding maintaining controls
with an unbounded window of opportunity in our framework. In [27] they do a comprehensive complexity analysis of
agent design in their framework. There is a natural correspondence between some of our complexity results and theirs. In
particular, our Theorems 15 and 21 correspond to the respective results in [27].

In AI planning, the seminal STRIPS approach [32] has been one of the most inﬂuential approaches. We brieﬂy recall that
in STRIPS, states are modeled as sets of propositional atoms and actions as operators which, given that a precondition in
terms of a conjunction of literals is true on the current state, transform it to a successor state by removing atoms from a
delete list and adding atoms from an add list. A plan for achieving a goal, described by a conjunction of atoms γ , from
an initial state S0 is a sequence of operators op1, . . . , opn which takes the agent from S0 to a state where γ holds. STRIPS
planning has been generalized in several directions, such as conditional effects, non-deterministic actions, or planning under
incomplete information and partial observability using conditional and conformant plans, respectively, and a number of
papers has considered the computation and complexity of planning in such settings, e.g., [6,16,18,31,64].

However, like in the framework of Wooldridge and Dunne, in none of these works agent actions and exogenous actions
are viewed separately, and thus they are best compared to our framework in absence of exogenous functions. Furthermore,
plans per se are conceived as action strategies (cf. [64]) in which, in principle, different actions might be taken by the agent
if during plan execution the same state is entered again; however, such looping is a priori excluded if the goal must be
achieved under all contingencies.

Daniele et al. [21] introduce the notion of strong cyclic planning which has some similarity with our notion of main-
tainability. In particular, both accept the possibility that an environment can sometimes be belligerent and in that case one
needs to differentiate between an agent that is trying and an agent that is not. However, they encode the environmental
interference through non-determinism while we allow explicit representation of environmental actions. Daniele et al. and
later Cimatti et al. [18] consider constructing universal plans akin to our policies, with different semantics (weak, strong and
strong cyclic) for goal achievement, based on OBDD methods and algorithms. In particular, in absence of exogenous actions
our maintaining controls correspond to what they call strong solutions for a planning problem. For further discussion, we
refer to [4].

As for complexity, Theorem 21, corresponds to the classical result of Bylander [16] that deciding plan existence in propo-
sitional STRIPS is PSPACE-complete, while Theorem 20 corresponds to Littman’s result that conditional planning for STRIPS
with non-deterministic actions is EXPTIME-complete [46,64]. In conditional planning, via conditions on the current state
branching to subplans is possible, such that an appropriate plan is followed depending on the state evolution. Branching
might be modeled by actions and the conditional planning problem, with loops disregarded, as the problem of constructing
a maintaining control.

In other related work, Jensen et al. [39,40] consider the somewhat dual problem of developing policies that achieve a
given goal while there are interferences from the environment. In their model, environment actions and actions of multiple
agents are combined to a joint action, by which the system is transferred from the current state to one out of a set of pos-
sible successor states. With such non-deterministic transitions, Jensen et al. aim at modeling both an adversial environment
and infrequent errors which make an otherwise deterministic action non-deterministic. In [39], they consider construct-
ing policies coping with arbitrarily many interferences of the environment (but without action failure) by an extension of
OBDD-based universal planning, and in [40] they consider generating policies which tolerate up to a given number n of er-
rors modeled as “secondary action effects” (caused by improper action execution or environment interference), by reducing
it to a so called strong planning problem, which is solved using OBDD based methods. For arbitrarily many environment
interferences as in [39], the problem is basically very similar to our problem of unbounded maintainability, but interfer-
ence in goal states has different signiﬁcance and goal achievement is not guaranteed because of possible loops. A formal
connection between k-maintainable controls and n-fault tolerant policies, if any, remains open. Intuitively, n-fault tolerant
plans are easier to construct, since the number of errors that have occurred can be recorded in plan construction and when
the limit n is reached, the problem boils down to an ordinary planning problem. For k-maintaining controls, however, each
environment interference (even at a goal state) causes a restart which pushes the agent to a new initial state.

Outside of AI, our notion of k-maintenance is very closely related to the notion of self-stabilization in [24] which is used
in characterizing fault-tolerant systems. There the concern is about proving correctness of (hand developed) self-stabilization
protocols and achieving self-stabilization for various distributed algorithms such as mutual exclusion. Our algorithm here can
be thought of as an algorithm that automatically generates a self-stabilization protocol. Although, this is a new dimension
to the existing work on self-stabilization, further research is needed to compare assumptions made in our formulation and
the ones in the self-stabilization literature, and overcome them. In particular, often in the self-stabilization literature the

1466

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

global states are composed of local states of various distributed elements and a particular element does not have the access
to the complete global state. In those cases one can not directly use the kind of global policies generated by the algorithm
in this paper. We elaborate more on this in Appendix A.

8.4. Further work and open issues

There are several directions for further research extending the work of this paper. One direction concerns other classes
of goal speciﬁcations, apart from k-maintainability and maintainability, for which controls can be synthesized in polynomial
time. Another direction are more general execution models, for instance by taking action duration into account. In such a
scenario, the maintenance goal may be formulated as requirement that the agent reaches some desired state always within
a given time frame, if she is not disturbed by the environment. Preliminary investigations suggest that the results in this
paper can be extended to handle this setting, and that alternatively the algorithm of Barbeau et al. [10] and Kabanza et al.
[41] can be used for eﬃcient computation, as long as durations are not long (binary number representation may lead to an
increase in complexity).

The intractability results for the problems under state variable representations challenges methods and techniques for
handling the problem in practice. Suitable heuristics may therefore be researched that allow to solve the problems in
many cases in polynomial time, and, in a reﬁned complexity analysis, meaningful tractable cases should be singled out.
Furthermore, the issue of computing optimal k-maintenance controls eﬃciently, in the sense that k is as small as possible
(which is trivially polynomially solvable in the enumerative setting), is an interesting issue for variable state representation.
Another issue concerns investigating computational transformations between maintenance and planning. By the com-
plexity results in [46] and this paper, transformations between k-Maintainability and conditional planning are feasible in
polynomial time. It would be interesting to study different transformations, and to assess possible beneﬁts of these trans-
formations for solving k-Maintainability and planning by cross-utilizing different algorithms and implementations (e.g. [18]
for planning in non-deterministic domains). In particular a transformation similar to the one in the proof of Theorem 13,
with an additional parameter that counts the number of agent actions since the last exogenous action, can11 be used to
compile out exogenous actions and transform ﬁnding k-maintainable policies to ﬁnding strong cyclic plans [18]. On the
other hand, encodings similar to the one in Section 5.2 for obtaining strong cyclic plans through linear-time Horn logic
programming can be designed. For more details and results on the latter, we refer to [4].

Acknowledgements

This work was partially supported by FWF (Austrian Science Fund) projects P-16536-N04 and Z29-N04, the European
Commission under grant IST 2001-37004 WASP, the NSF (National Science Foundation of USA) grant numbers 0070463, and
0412000, NASA grant number NCC2-1232, and contracts from ARDA and DTO. We would like to acknowledge W. Cushing
for his feedback on an earlier draft and S. Gupta and M. Gouda for their clariﬁcations on self-stabilization. Furthermore,
we acknowledge comments by J. Rintanen on the ICAPS’04 paper and are grateful for his pointers to related work. We owe
special thanks to F. Kabanza for helping us understand his co-authored papers [10,41] and making observations regarding
how the algorithms in those papers could be modiﬁed to make them more eﬃcient for speciﬁc goal speciﬁcations. We
furthermore appreciate the constructive comments of the reviewers to improve the presentation, the suggestion of an LTL
formulation in Section 4.1 and the suggestion of a linear time algorithm for generic maintainability. Finally, we are indebted
to J. Zhao for implementing some of the algorithms and running the experiments, and appreciate the support of the DLV
team.

Appendix A. Self-stabilization and related notions in distributed computing

Earlier we remarked that our notion of maintainability has similarities with Dijkstra’s notion of self-stabilization [24]. In
this appendix, we elaborate on the relationship between our notions and Dijkstra’s as well as similar notions in distributed
computing [2].

A.1. Dijkstra’s notion of self-stabilization

Dijkstra considers in [24] a connected graph (in which a majority of edges are missing) with a ﬁnite state machine placed
at each node; machines placed in directed connected nodes are called each other’s neighbors. For each node (or machine),
a Boolean function over the state of the machine and the states of its neighbors, called a “privilege”, is deﬁned. There is a
central daemon that can select one of the “privileges” (over the whole graph) that is true. The machine whose privilege is
selected can move its state to another state based on a policy which is a function from the state of the machine and its
neighbor’s states to a move that results in a state transition in the machine under consideration. If for such a machine more
than one privilege is present, the new state may also depend on the privilege selected.

11 This transformation increases the number of states by k times. It is unknown if there exist a transformation that can eliminate exogenous actions
without increasing the number of states, and yet is able to model the notion of k-maintainability.

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1467

There is a global criterion, telling whether the system as a whole is in a “legitimate” state. It is required that

(i) in each legitimate state one or more privileges will be present;
(ii) in each legitimate state each possible move will bring the system to a legitimate state;
(iii) each privilege must be present in at least one legitimate state; and
(iv) for any pair of legitimate states there exists a sequence of moves transferring the system from one to the other.

The system is called “self-stabilizing” if and only if, regardless of the initial state and the privilege selected each time for
the next move, at least one privilege will always be present and the system is guaranteed to ﬁnd itself in a legitimate state
after a ﬁnite number of moves.

Comparison to our notion of maintainability Our notion of a state corresponds to Dijkstra’s global state (which is composed
of the local states), and our goal states are his legitimate states. Analogous to our actions are his “moves”, and analogous
to our policies are his selections of privileges that are present. Our policies select an action that is to be executed based on
the current state. In Dijkstra’s model, although “moves” are selected based on the current global state, the selection is ﬁner;
one of the privileges that are present is selected. The transition due to moves is similar to our transition between states due
to action. But Dijkstra’s transition is also ﬁner grained because the changes happen only to the local state of the machine
whose privilege is selected, and this change depends on the local state (prior to the move) of the machine, the local state of
the neighbors, and the privilege selected. We have a speciﬁc set of initial states and we use exogenous actions to compute a
closure of states that may be reached. In Dijkstra’s deﬁnition of self-stabilization all states are possible initial states. This is
the same as having the closure to be the set of all states. Modulo the above differences, Dijkstra’s notion of self-stabilization
is the same as our notion of ﬁnite maintainability.

If one thinks in terms of global states, then essentially self-stabilization is the same as ﬁnite maintainability. Our major
contribution is that, unlike research in the area of self-stabilization protocols, where such protocols are invented by people
and self-stabilizability of systems using those protocols is proven, we give a method to automatically come up with the
protocols (or “policies” in our terms). Nonetheless, a large body of research in self-stabilization is with respect to distributed
systems where one does not have access to the global state in deciding what action to take. Thus a direction for future
research is to ﬁnd algorithms similar to ours that can generate protocols (policies) in the distributed domain.

A.2. Arora and Gouda’s notion of closure, convergence, and fault-tolerance

Arora and Gouda’s abstraction [2] is more closer to ours than Dijkstra’s. We start with their deﬁnitions and terminology.

• A program consists of a set of variables and a set of processes.
• Each process consists of a set of condition-statement pairs (B, st), where B is a Boolean expression over program

variables, and st updates zero or more program variables and always terminates upon execution.

• A state of a program p is deﬁned by the value for each variable of p.
• For any process of a program p, using the set of condition-statement pairs we can construct a mapping from states to
sets of statements, where s maps to a set containing st iff there is a (B, st) in the process such that B evaluates to true
in s. This mapping is referred to as the policy corresponding to that process. If a program has a single process, then the
policy corresponding to that process is also referred to as the policy of that program.

• A state predicate of p is a Boolean expression over the variables of p.
• A condition-statement pair (B, st) is enabled at a state iff B evaluates to true at that state.
• A process is said to be enabled at a state iff some pair (B, st) of that process is enabled at that state.
• Closure: A state predicate S is closed in a program p iff for each pair (B, st) in each process of p, executing st starting

from a state where B ∧ S holds results in a state where S holds.

• A computation of p is a sequence of states that satisﬁes the following three conditions:

(i) for each pair of consecutive states c, d in the sequence, there exists a pair (B, st) in some process of p such that B

holds at c and executing st starting from c results in d;

(ii) the sequence is maximal, i.e., the sequence is either inﬁnite or it is ﬁnite and no condition-statement pair is enabled

in the last state; and

(iii) if any process j of p is continuously enabled along the sequence, then eventually some action of j is chosen for

execution.

• Convergence: Let S and T be state predicates of p. T is said to converge to S in p iff

(a) S and T are closed in p and
(b) in each computation of p starting at any state where T holds, there exists a state where S holds.

• Fault-tolerance: Let S be a closed state predicate of p and let F be a set of condition-statement pairs on variables of p.

Then p is F -tolerant of S iff there exists a state predicate T of p such that:
(a) T holds at every state where S holds;
(b) for each pair (B, st) in F , executing st starting from a state where B ∧ T holds results in a state where T holds; and
(c) T converges to S in p.

1468

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

The notions of closure, convergence, and fault tolerance of Arora and Gouda are very close to similar notions in our

deﬁnition of maintainability. We now compare their notions to ours more in detail.

Comparison to our notions Arora and Gouda’s notion of states is similar to our notion of states, and their notion of statements
is similar to our notion of actions, except that statements cause deterministic transition between states and are executable
in all states, while actions can have non-deterministic effects and are executable in some states only. Their notion of a
process (consisting of a set of condition-statement pairs) is similar to our policy, and their notion of a program consists of
a set of variables (that deﬁne the states) and a set of processes. Their notion of closure is the same as our notion of closure
when we assume the absence of exogenous actions and the presence of a single process. (We assume the presence of a
single process in the rest of our comparison.) Their notion of a computation is similar to our notion of a sequence of states
obtained using the Unfold function, except that we have no fairness condition, which we do not need since we have only a
single policy under consideration) and that policy dictates the execution of only one action in any state.

Arora and Gouda’s notion of “T converges to S” (when there is a single process) is similar to ﬁnite maintainability (in the
absence of exogenous actions), where T and S correspond to the closure of our initial and ﬁnal states, respectively. In their
notion of fault tolerance, captured by “p is F -tolerant of S,” the fault set F corresponds to our exogenous actions and when
they can occur, S corresponds to the set of ﬁnal states, and p reﬂects the state-space and the policy under consideration. In
Arora and Gouda’s deﬁnition of fault tolerance, T corresponds to our closure of a set of initial states, but has the additional
requirement that the set of ﬁnal states S is a subset of T . Thus “p is F -tolerant of S” corresponds to our notion of the
policy of p maintaining a set of initial states (whose closure contains S) with respect to S in presence of exogenous actions
described by F .

While our notion of maintainability is similar to the notion of tolerance under a class of faults in [2], Arora and Gouda
do not give an algorithm to automatically construct a policy (or process in their terms) that will result in the tolerance,
while we give algorithms which generate policies, if such policies exist, that guarantee maintainability.

References

[1] M. Abadi, L. Lamport, P. Wolper, Realizable and unrealizable speciﬁcations of reactive systems, in: Proc. 16th International Conference on Automata,

Languages, and Programming (ICALP 89), in: LNCS, vol. 372, Springer, 1989, pp. 1–17.

[2] A. Arora, M.G. Gouda, Closure and convergence: A foundation of fault-tolerant computing, IEEE Transactions on Software Engineering 19 (11) (1993)

1015–1027.

[3] F. Bacchus, F. Kabanza, Planning for temporally extended goals, Annals of Mathematics and Artiﬁcial Intelligence 22 (1998) 5–27.
[4] C. Baral, T. Eiter, J. Zhao, Using SAT and LP to design polynomial-time algorithms for planning in non-deterministic domains, in: Proc. 20th National

Conference on Artiﬁcial Intelligence (AAAI ’05), AAAI Press, 2005, pp. 578–583.

[5] C. Baral, M. Gelfond, A. Provetti, Representing actions: Laws, observations, and hypothesis, Journal of Logic Programming 31 (1997) 201–243.
[6] C. Baral, V. Kreinovich, R. Trejo, Computational complexity of planning and approximate planning in the presence of incompleteness, Artiﬁcial Intelli-

gence 122 (1-2) (2000) 241–267.

[7] C. Baral, V. Kreinovich, R. Trejo, Computational complexity of planning with temporal goals, in: B. Nebel (Ed.), Proc. 17th International Joint Conference

on Artiﬁcial Intelligence (IJCAI-01), Morgan Kaufmann, 2001, pp. 509–514.

[8] C. Baral, T. Son, Relating theories of actions and reactive control, Electronic Transactions on Artiﬁcial Intelligence 2 (3-4) (1998) 211–271.
[9] C. Baral, J. Zhao, Goal speciﬁcation in presence of non-deterministic actions, in: R.L. de Mántaras, L. Saitta (Eds.), Proc. 16th European Conference on

Artiﬁcial Intelligence (ECAI 2004), IOS Press, 2004, pp. 273–277.

[10] M. Barbeau, F. Kabanza, R. St-Denis, Synthesizing plan controllers using real-time goals, in: Proc. 14th International Joint Conference on Artiﬁcial

Intelligence (IJCAI-95), 1995, pp. 791–800.

[11] D. Barrington, N. Immerman, H. Straubing, On uniformity within NC 1, Journal of Computer and System Sciences 41 (1990) 274–306.
[12] M. Ben-Ari, Z. Manna, A. Puneli, The temporal logic of branching time, in: Proc. 8th Symposium on Principles of Programming Languages, 1981, pp.

164–176.

[13] P. Bertoli, A. Cimatti, M. Pistore, Strong cyclic planning under partial observability, in: ECAI, 2006, pp. 580–584.
[14] P. Bertoli, M. Pistore, Planning with extended goals and partial observability, in: S. Zilberstein, J. Koehler, S. Koenig (Eds.), ICAPS, 2004, pp. 270–278.
[15] R. Brooks, A robust layered control system for a mobile robot, IEEE Journal of Robotics and Automation 2 (1) (1986) 14–23.
[16] T. Bylander, The computational complexity of propositional strips planning, Artiﬁcial Intelligence 69 (1994) 165–204.
[17] S. Ceri, J. Widom, Deriving production rules for constraint maintenance, in: P.M.G. Apers, G. Wiederhold (Eds.), Proc. 15th International Conference on

Very Large Data Bases (VLDB-90), 1990, pp. 566–577.

[18] A. Cimatti, M. Pistore, M. Roveri, P. Traverso, Weak, strong, and strong cyclic planning via symbolic model checking, Artiﬁcial Intelligence 147 (1–2)

(2003) 35–84.

[19] E. Clarke, E. Emerson, Design and synthesis of synchronization skeletons using branching-time temporal logic, in: Proc. Workshop on Logic of Programs,

in: LNCS, vol. 131, Springer, 1981, pp. 52–71.

[20] E. Clarke, E. Emerson, A. Sistla, Automatic veriﬁcation of ﬁnite-state concurrent systems using temporal logic speciﬁcations, ACM Transactions on

Programming Languages and Systems 8 (2) (1986) 244–263.

[21] M. Daniele, P. Traverso, M. Vardi, Strong cyclic planning revisited, in: Proc. 5th European Conference on Planning (ECP’99), in: LNCS/LNAI, vol. 1809,

Springer, 1999, pp. 35–48.

[22] E. Dantsin, T. Eiter, G. Gottlob, A. Voronkov, Complexity and expressive power of logic programming, ACM Computing Surveys 33 (3) (2001) 374–425.
[23] G. De Giacomo, R. Reiter, M. Soutchanski, Execution monitoring of high-level robot programs, in: Proc. Sixth Conference on Principles of Knowledge

Representation and Reasoning (KR-98), 1998, pp. 453–465.

[24] E.W. Dijkstra, Self-stabilizing systems in spite of distributed control, CACM 17 (11) (1974) 644–843.
[25] W. Dowling, J.H. Gallier, Linear-time algorithms for testing the satisﬁability of propositional Horn theories, Journal of Logic Programming 3 (1984)

267–284.

[26] M. Drummond, Situation control rules, in: Proc. First International Conference on Principles of Knowledge Representation and Reasoning (KR-89), 1989,

pp. 103–113.

C. Baral et al. / Artiﬁcial Intelligence 172 (2008) 1429–1469

1469

[27] P. Dunne, M. Laurence, M. Wooldridge, Complexity results for agent design problems, Annals of Mathematics, Computing & Teleinformatics 1 (1) (2003)

19–36.

[28] P. Dunne, M. Wooldridge, Optimistic and disjunctive agent design problems, in: C. Castelfranchi, Y. Lespéranceand (Eds.), Proc. 7th International Work-

shop on Intelligent Agents (ATAL VII), in: LNCS, vol. 1986, Springer, 2001, pp. 1–14.

[29] T. Eiter, W. Faber, N. Leone, G. Pfeifer, Declarative problem-solving using the DLV system, in: J. Minker (Ed.), Logic-Based Artiﬁcial Intelligence, Kluwer,

2000, pp. 79–103.

[30] E. Emerson, Temporal and modal logics, in: J. van Leeuwen (Ed.), Handbook of Theoretical Computer Science, vol. B, Elsevier, 1990, Chapter 16.
[31] K. Erol, V. Subrahmanian, D. Nau, Complexity, decidability and undecidability results for domain-independent planning, Artiﬁcial Intelligence 76 (1995)

75–88.

[32] R.E. Fikes, N.J. Nilsson, Strips: A new approach to the application of theorem proving to problem solving, Artiﬁcial Intelligence 2 (3–4) (1971) 189–208.
[33] M. Gelfond, V. Lifschitz, Classical negation in logic programs and disjunctive databases, New Generation Computing 9 (1991) 365–385.
[34] M. Gelfond, V. Lifschitz, Representing action in extended logic programs, in: Proc. Joint International Conference and Symposium on Logic Programming

(JICSLP’92), MIT Press, 1992, pp. 559–573.

[35] M. Ghallab, D. Nau, P. Traverso, Automated Planning—Theory and Practice, Morgan Kaufmann, 2004.
[36] M.L. Ginsberg, Universal planning: An (almost) universally bad idea, AI Magazine 10 (4) (1989) 40–44.
[37] A. Harding, M. Ryan, P.-Y. Schobbens, A new algorithm for strategy synthesis in ltl games, in: N. Halbwachs, L.D. Zuck (Eds.), TACAS, in: LNCS, vol. 3440,

Springer, 2005, pp. 477–492.

[38] N. Immerman, Descriptive Complexity, Springer, 1999.
[39] R.M. Jensen, M.M. Veloso, M.H. Bowling, OBDD-based optimistic and strong cyclic adversarial planning, in: Proc. 6th European Conference on Planning

(ECP-01), 2001.

[40] R.M. Jensen, M.M. Veloso, R.E. Bryant, Fault tolerant planning: Toward probabilistic uncertainty models in symbolic non-deterministic planning, in:
S. Zilberstein, J. Koehler, S. Koenig (Eds.), Proc. 14th International Conference on Automated Planning and Scheduling (ICAPS 2004), 2004, pp. 335–344.

[41] F. Kabanza, M. Barbeau, R. St-Denis, Planning control rules for reactive agents, Artiﬁcial Intelligence 95 (1) (1997) 67–113.
[42] L.P. Kaelbling, S.J. Rosenschein, Action and planning in embedded agents, in: Maes [47], pp. 35–48.
[43] C. Kuratowski, Topology I, Academic Press, New York, 1966.
[44] U.D. Lago, M. Pistore, P. Traverso, Planning with a language for extended goals, in: AAAI/IAAI, 2002, pp. 447–454.
[45] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, F. Scarcello, The DLV system for knowledge representation and reasoning, ACM Transactions

on Computational Logic 7 (3) (2006) 499–562.

[46] M.L. Littman, Probabilistic propositional planning: Representations and complexity, in: Proc. 14th National Conference on Artiﬁcial Intelligence and 9th

Innovative Applications of Artiﬁcial Intelligence Conference (AAAI/IAAI 1997), 1997, pp. 748–754.

[47] P. Maes (Ed.), Designing Autonomous Agents: Theory and Practice from Biology to Engineering and Back, MIT Press, 1990.
[48] Z. Manna, A. Pnueli, The Temporal Logic of Reactive and Concurrent Systems Speciﬁcation, Springer, 1992.
[49] Z. Manna, P. Wolper, Synthesis of communicating processes from temporal logic speciﬁcations, ACM Transactions on Programming Languages and

Systems 6 (1) (1984) 68–93.

[50] M. Minoux, LTUR: A simpliﬁed linear time unit resolution for Horn formulae and computer implementation, Information Processing Letters 29 (1988)

1–12.

[51] M. Nakamura, C. Baral, Invariance, maintenance and other declarative objectives of triggers—a formal characterization of active databases, in: J. Lloydet

al. (Ed.), Proc. First International Conference on Computational Logic (CL 2000), in: LNAI, vol. 1861, Springer, 2000, pp. 1210–1224.

[52] M. Nakamura, C. Baral, M. Bjæreland, Maintainability: A weaker stabilizability like notion for high level control, in: Proc. 17th National Conference on
Artiﬁcial Intelligence and Twelfth Conference on Innovative Applications of Artiﬁcial Intelligence (AAAI/IAAI 2000), AAAI Press, 2000, pp. 62–67.
[53] I. Niemelä, P. Simons, T. Syrjänen, Smodels: A system for answer set programming, in: C. Baral, M. Truszczy ´nski (Eds.), Proc. 8th International Workshop

on Non-Monotonic Reasoning (NMR’2000), 2000, available at http://xxx.lanl.gov/abs/cs.AI/0003033.

[54] R. Niyogi, S. Sarkar, Logical speciﬁcation of goals, in: R.K. Ghosh, D. Misraand (Eds.), Proc. 3rd International Conference on Information Technology (CIT

2001), Tata McGraw-Hill, 2000, pp. 77–82.

[55] C. Ortiz, A commonsense language for reasoning about causation and rational action, Artiﬁcial Intelligence 111 (2) (1999) 73–130.
[56] O. Ozveren, A. Willsky, P. Antsaklis, Stability and stabilizability of discrete event dynamic systems, Journal of ACM 38 (3) (1991) 730–752.
[57] C.H. Papadimitriou, Computational Complexity, Addison-Wesley, 1994.
[58] K. Passino, K. Burgess, Stability Analysis of Discrete Event Systems, John Wiley and Sons, 1998.
[59] N. Piterman, A. Pnueli, Y. Sa’ar, Synthesis of reactive(1) designs, in: VMCAI, 2006, pp. 364–380.
[60] A. Pnueli, R. Rosner, On the synthesis of a reactive module, in: Proc. 16th Annual ACM Symposium on Principles of Programming Languages (POPL

1989), 1989, pp. 179–190.

[61] P. Ramadge, W. Wonham, Modular feedback logic for discrete event systems, SIAM Journal of Control and Optimization 25 (5) (1987) 1202–1217.
[62] P. Ramadge, W. Wonham, Supervisory control of a class of discrete event process, SIAM Journal of Control and Optimization 25 (1) (1987) 206–230.
[63] R. Reiter, Knowledge in Action: Logical Foundation for Describing and Implementing Dynamical Systems, MIT Press, 2001.
[64] J. Rintanen, Complexity of planning with partial observability, in: S. Zilberstein, J. Koehler, S. Koenig, (Eds.), Proc. 14th International Conference on

Automated Planning and Scheduling (ICAPS 2004), 2004, pp. 345–354.

[65] P. Simons, I. Niemelä, T. Soininen, Extending and implementing the stable model semantics, Artiﬁcial Intelligence 138 (2002) 181–234.
[66] E. Sontag, Stability and stabilization: Discontinuities and the effect of disturbances, in: F. Clarke, R. Sternand (Eds.), Proc. NATO Advanced Study Institute,

Kluwer, 1998, pp. 551–598.

[67] D. Weld, O. Etzioni, The ﬁrst law of robotics (a call to arms), in: Proc. Twelfth National Conference on Artiﬁcial Intelligence (AAAI-94), AAAI Press,

1994, pp. 1042–1047.

[68] J. Widom, S. Ceri (Eds.), Active Database Systems: Triggers and Rules For Advanced Database Processing, Morgan Kaufmann, 1996.
[69] M. Wooldridge, The computational complexity of agent design problems, in: Proc. Fourth International Conference on Multi-Agent Systems (ICMAS

2000), IEEE Press, 2000, pp. 341–348.

