Artiﬁcial Intelligence 256 (2018) 160–180

Contents lists available at ScienceDirect

Artiﬁcial  Intelligence

www.elsevier.com/locate/artint

Belief  revision,  minimal  change  and  relaxation:  A  general 
framework  based  on  satisfaction  systems,  and  applications  to 
description  logics
Marc Aiguier a,  Jamal Atif b,∗
a MICS, Centrale Supelec, Université Paris-Saclay, France
b Université Paris-Dauphine, PSL Research University, CNRS, UMR 7243, LAMSADE, 75016 Paris, France
c LTCI, Télécom ParisTech, Université Paris-Saclay, Paris, France

,  Isabelle Bloch c,  Céline Hudelot a

a  r  t  i  c  l  e 

i  n  f  o

a  b  s  t  r  a  c  t

Article history:
Received 13 November 2015
Received in revised form 7 July 2017
Accepted 11 December 2017
Available online 17 December 2017

Keywords:
Abstract belief revision
Relaxation
AGM theory
Satisfaction systems
Description logics

Belief revision of knowledge bases represented by a set of sentences in a given logic has 
been  extensively  studied  but  for  speciﬁc  logics,  mainly  propositional,  and  also  recently 
Horn and description logics. Here, we propose to generalize this operation from a model-
theoretic point of view, by deﬁning revision in the abstract model theory of satisfaction 
systems. In this framework, we generalize to any satisfaction system the characterization 
of the AGM postulates given by Katsuno and Mendelzon for propositional logic in terms 
of minimal change among interpretations. In this generalization, the constraint on syntax 
independence  is  partially  relaxed.  Moreover,  we  study  how  to  deﬁne  revision,  satisfying 
these weakened AGM postulates, from relaxation notions that have been ﬁrst introduced in 
description logics to deﬁne dissimilarity measures between concepts, and the consequence 
of  which  is  to  relax  the  set  of  models  of  the  old  belief  until  it  becomes  consistent 
with  the  new  pieces  of  knowledge.  We  show  how  the  proposed  general  framework 
can  be  instantiated  in  different  logics  such  as  propositional,  ﬁrst-order,  description  and 
Horn logics. In particular for description logics, we introduce several concrete relaxation 
operators tailored for the description logic ALC and its fragments EL and ELU , discuss 
their properties and provide some illustrative examples.

© 2018 Elsevier B.V. All rights reserved.

1.  Introduction

Belief change, the process that makes an agent’s beliefs evolve with newly acquired knowledge, is one of the classical but 
still challenging problems in artiﬁcial intelligence. It is gaining more and more interest these days, due to the emergence of 
new logical-based knowledge representation frameworks enjoying good complexity properties, allowing them to tackle large 
scale knowledge bases, and to reason on massive datasets. Among these logical frameworks, one can mention Description 
Logics (DLs) and Horn Clause theories. Description logics, for instance, are now pervasive in many knowledge-based repre-
sentation systems such as ontological reasoning, semantic web, scene understanding, cognitive robotics, to mention a few. 
In all these domains, the expert knowledge is not ﬁxed, but rather a ﬂux evolving over time, hence requiring the deﬁnition 
of rational change operators.

* Corresponding author.

E-mail addresses: marc.aiguier@centralesupelec.fr (M. Aiguier), jamal.atif@dauphine.fr (J. Atif), isabelle.bloch@telecom-paristech.fr (I. Bloch), 

celine.hudelot@centralesupelec.fr (C. Hudelot).

https://doi.org/10.1016/j.artint.2017.12.002
0004-3702/© 2018 Elsevier B.V. All rights reserved.

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

161

Studying the rationality of belief change operators, when knowledge bases are logical theories, i.e. sets of sentences in 
a given logic, goes back to the seminal work of Alchourròn, Gardenfors and Makinson [1], that gave birth to what is now 
known as AGM theory. Three change operations are studied within this framework, expansion, contraction and revision. Belief 
expansion consists in adding new knowledge without checking consistency, while both contraction and revision consist in 
consistently removing and adding new knowledge, respectively. We focus in this paper on belief revision.

Although deﬁned in the abstract framework of logics given by Tarski [40] (so called Tarskian logics),  postulates of the 
AGM theory make strong assumptions on the considered logics. Indeed, in [1] the considered logics have to be closed under 
the  standard  propositional  connectives  in  {∧, ∨, ¬, ⇒},  to  be  compact  (i.e.  inference  depends  on  a  ﬁnite  set  of  axioms), 
and  to  satisfy  the  deduction  theorem  (i.e.  entailment  and  implication  are  equivalent).  While  compactness  is  a  standard 
property  of  logics,  to  be  closed  under  the  standard  propositional  connectives  is  more  questionable.  Indeed,  many  logics 
(called hereafter non-classical logics) such as description logics, equational logic or Horn clause logic, widely used for various 
modern applications in computing science, do not satisfy such a constraint. Recently, in many works, belief change has been 
studied in such non-classical logics [12,17,34,35]. For instance, Ribeiro et al. in [35] studied contraction at the abstract level 
of  Tarskian  logics,  and  recently  Zhuang  et  al.  in [42] proposed  an  extension  of  AGM  contraction  to  arbitrary  logics.  The 
adaptation of the AGM postulates for revision for non-classical logics has been studied but only for speciﬁc logics, mainly 
description  logics [16,17,28,29,31,33,41] and  Horn  logics [11,43].  The  reason  is  that  revision  can  be  abstractly  deﬁned  in 
terms  of  expansion  and  retraction  following  the  Levi  identity [23],  but  this  requires  the  use  of  negation,  which  rules  out 
some non-classical logics that do not consider this connective [34].

The AGM postulates were interpreted in terms of minimal change in [22], in the sense that the models of the revision 
should be as close as possible, according to some metric, to the models of the initial knowledge set. However, to the best 
of our knowledge, the generalization of the AGM theory with minimality criteria on the set of models of knowledge bases 
has never been proposed. The reason is that semantics is not explicit in the abstract framework of logics deﬁned by Tarski.
We propose here to generalize AGM revision but in the abstract model theory of satisfaction systems, which formalizes 
the intuitive notion of logical systems, including syntax, semantics and the satisfaction relation. This notion was introduced 
in [18] under the name of “rooms”, and then of “satisfaction systems” in [38]. See also [26]. Then, we propose to generalize 
to any satisfaction system the approach developed in [22] for propositional logic and in [30] for description logics. In this 
abstract framework, we will also show how to deﬁne revision operators from the relaxation notion that has been introduced 
in description logics to deﬁne dissimilarity measures between concepts [14,15]. The main idea is to relax the set of models 
of  the  old  belief  until  it  becomes  consistent  with  the  new  pieces  of  knowledge.  This  notion  of  relaxation,  deﬁned  in  an 
abstract way through a set of properties, turns out to generalize several revision operators introduced in different contexts 
e.g. [9,20,25,29]. This is another key contribution of our work.

To concretize our abstract framework, we provide examples of relaxations in propositional logics, ﬁrst order logics, and 
Horn logic. The case of description logics (DLs) is more detailed. This is motivated, as mentioned above, by their broad scope 
of applications, including reasoning on large web data.

The paper is organized as follows. Section 2 reviews some concepts, notations and terminology about satisfaction systems 
which are used in this work. In Section 3, we adapt the AGM theory in the framework of satisfaction systems, and then give 
an abstract model-theoretic rewriting of the AGM postulates. We then show in Section 3.2 that any revision operator satis-
fying such postulates accomplishes an update with minimal change to the set of models of knowledge bases. In Section 3.3, 
we introduce a general framework of relaxation-based revision operators and show that our revision operators lead to faith-
ful  assignments  and  then  also  satisfy  the  AGM  postulates.  In  Section 4,  we  illustrate  our  abstract  approach  by  providing 
revision operators in different logics, including classical logics (propositional and ﬁrst order logics) and non-classical ones 
(Horn and description logics). The case of DL is further developed in Section 4.4, with several examples. Finally, Section 5 is 
dedicated to related works.

2.  Satisfaction systems

Satisfaction systems [26] generalize Tarski’s classical “semantic deﬁnition of truth” [39] and Barwise’s “Translation Ax-
iom” [4]. For the sake of generalization, sentences are simply required to form a set. All other contingencies such as inductive 
deﬁnition of sentences are not considered. Similarly, models are simply seen as elements of a class, i.e. no particular struc-
ture is imposed on them.

2.1.  Deﬁnition and examples

Deﬁnition 1 (Satisfaction system). A satisfaction system R = (Sen, Mod, |=) consists of

• a set  Sen of sentences,
• a class Mod of models, and
• a satisfaction relation |=⊆ Mod × Sen.

162

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

Let us note that the non-logical vocabulary, so-called signature, over which sentences and models are built, is not speci-
ﬁed in Deﬁnition 1.1 Actually, it is left implicit. Hence, as we will see in the examples developed in the paper, a satisfaction 
system always depends on a signature.

Example 1.  The  following  examples  of  satisfaction  systems  are  of  particular  importance  in  computer  science  and  in  the 
remainder of this paper.

Propositional Logic (PL) Given a set of propositional variables (cid:2), we can deﬁne the satisfaction system R(cid:2) = (Sen, Mod,
|=) where Sen is the least set of sentences ﬁnitely built over propositional variables in (cid:2) and Boolean connectives 
in {¬, ∨},  Mod contains all the mappings ν : (cid:2) → {0, 1} (0 and 1 are the usual truth values), and the satisfaction 
relation |= is the usual propositional satisfaction.

Horn Logic (HCL) A  Horn clause is  a  sentence  of  the  form  (cid:4) ⇒ α where  (cid:4) is  a  ﬁnite  (possibly  empty)  conjunction  of 
propositional  variables  and  α is  a  propositional  variable.  The  satisfaction  system  of  Horn  clause  logic  is  then 
deﬁned as for PL except that sentences are restricted to be conjunctions of Horn clauses.

First Order Logic (FOL) and Many-sorted First Order Logic We detail here only the many-sorted variant of FOL, FOL being 
a  particular  case.  Signatures  are  triplets  (S, F , P ) where  S is  a  set  of  sorts,  and  F and  P are  a  set  of  functions
and  a  set  of  predicate  names,  respectively,  both  with  arities  in  S
is  the  set  of  all 
+ ∪ {(cid:6)} where (cid:6) denotes the empty sequence). In the following, 
non-empty sequences of elements in  S and  S
to indicate that a function name  f ∈ F (respectively a predicate name p ∈ P ) has for arity (s1 . . . sn, s) (respectively 
s1 . . . sn), we will note  f : s1 × . . . × sn → s (resp.  p : s1 × . . . × sn).

∗ × S and  S

respectively  (S

∗ = S

+

+

Given a signature (cid:2) = (S, F , P ), we can deﬁne the satisfaction system R(cid:2) = (Sen, Mod, |=) where:

• Sen is  the  least  set  of  sentences  built  over  atoms  of  the  form  p(t1, . . . , tn) where  p : s1 × . . . × sn ∈ P and 
ti ∈ T F ( X)si for every  i, 1 ≤ i ≤ n (T F ( X)s is the term algebra of sort  s built over  F with sorted variables in a 
given set  X ) by ﬁnitely applying Boolean connectives in {¬, ∨} and the quantiﬁer ∀.

• Mod is  the  class  of  models M deﬁned  by  a  family  (Ms)s∈S of  sets  (one  for  every  s ∈ S),  each  one  equipped 
→ Ms for  every  f : s1 × . . . × sn → s ∈ F and  with  an  n-ary  relation 

with  a  function  f
M ⊆ Ms1
p

× . . . × Msn
× . . . × Msn for every  p : s1 × . . . × sn ∈ P .

M : Ms1

• Finally, the satisfaction relation |= is the usual ﬁrst-order satisfaction.
As for PL, we can consider the logic FHCL of ﬁrst-order Horn Logic whose models are those of FOL and sentences 
are restricted to be conjunctions of universally quantiﬁed Horn sentences (i.e. sentences of the form (cid:4) ⇒ α where 
(cid:4) is a ﬁnite conjunction of atoms and α is an atom).

Description logic (DL) Signatures are triplets (NC , N R , I) where  NC ,  N R and  I are nonempty pairwise disjoint sets where 

elements in NC , N R and  I are called concept names, role names and individuals, respectively.

Given a signature (cid:2) = (NC , N R , I), we can deﬁne the satisfaction system R(cid:2) = (Sen, Mod, |=) where:

• Sen contains2 all  the  sentences  of  the  form  C (cid:12) D,  x : C and  (x, y) : r where  x, y ∈ I ,  r ∈ N R and  C is  a  con-
cept  inductively  deﬁned  from  NC ∪ {(cid:13)} and  binary  and  unary  operators  in  {_ (cid:14) _, _ (cid:15) _} and  in  {_c, ∀r._, ∃r._}, 
respectively.

• Mod is the class of models I deﬁned by a set (cid:7)I

for every relation name r ∈ N R with a binary relation r
I ∈ (cid:7)I
x

.

equipped for every concept name  A ∈ NC with a set  A

I ⊆ (cid:7)I
, 
, and for every individual x ∈ I with a value 

I ⊆ (cid:7)I × (cid:7)I

is the evaluation of C in I inductively deﬁned on the structure of C as follows:

• The satisfaction relation |= is then deﬁned as:
I ⊆ D
I
,
I , y

I ) ∈ r

I

,

,

I

· I |= C (cid:12) D iff C
I ∈ C
· I |= x : C iff x
· I |= (x, y) : r iff (x
I
where C
· if C = A with  A ∈ NC , then C
· if C = (cid:13) then C
· if C = C
· if C = C
· if C = ∀r.C
· if C = ∃r.C

I = (cid:7)I
(resp. C = C

(cid:17) (cid:15) D
(cid:17)
(cid:17) c , then C

, then C
, then C

I = (cid:7)I \ C

;

(cid:17)

(cid:17)

I = A

I

;

(cid:17)

(cid:17) (cid:14) D
(cid:17) I

), then C
;

I = C

(cid:17) I ∪ D

(cid:17) I

(resp. C

I = C

(cid:17) I ∩ D

(cid:17) I

);

I = {x ∈ (cid:7)I | ∀ y ∈ (cid:7)I , (x, y) ∈ r
I
I = {x ∈ (cid:7)I | ∃ y ∈ (cid:7)I , (x, y) ∈ r

I

implies y ∈ C
(cid:17) I }.
and y ∈ C

(cid:17) I };

2.2.  Knowledge bases and theories

Let  us  now  consider  a  ﬁxed  but  arbitrary  satisfaction  system  R = (Sen, Mod, |=) (since  the  signature  (cid:2) is  supposed 

ﬁxed, the subscript (cid:2) will be omitted from now on).

1 The set of logical symbols is deﬁned in each particular logic, and does not depend on a theory.
2 The description logic deﬁned here is better known under the acronym ALC.

Notation 1. Let T ⊆ Sen be a set of sentences.

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

163

• Mod(T ) is the sub-class of Mod whose elements are models of T , i.e. for every M ∈ Mod(T ) and every ϕ ∈ T , M |= ϕ. 
When  T is  restricted  to  a  formula  ϕ (i.e.  T = {ϕ}),  we  will  denote  Mod(ϕ),  the  class  of  model  of  {ϕ},  rather  than 
Mod({ϕ}).

• Cn(T ) = {ϕ ∈ Sen | ∀M ∈ Mod(T ), M |= ϕ} is the set of semantic consequences of T .
• Let M ⊆ Mod. Let us note M∗ = {ϕ ∈ Sen | ∀M ∈ M, M |= ϕ}. Therefore, we have for every T ⊆ Sen, Cn(T ) = Mod(T )∗

When M is restricted to one model M, M∗

will be equivalently noted M∗
• Let  us  note  T ri v = {M ∈ Mod | M∗ = Sen},  i.e.  the  set  of  models  in  which  all  formulas  are  satisﬁed.  In PL and FOL, 
T ri v is  empty  because  the  negation  is  considered.  Similarly,  the  complementation  is  involved  in  the DL ALC,  hence 
T ri v is empty. In HCL, T ri v only contains the unique model where all propositional variables have a truth value equal 
to 1. In FHCL, T ri v contains all models M where for every predicate name  p : s1 × . . . × sn ∈ P ,  p
× . . . × Msn .

M = Ms1

. 

.

Let us note that for every T ⊆ Sen, T ri v ⊆ Mod(T ).
From the above notations, we obviously have:

(cid:17)

Cn(T ) = Cn(T

) ⇔ Mod(T ) = Mod(T
The two functions Mod(_) from P(Sen) into P(Mod) and _
connection in that they satisfy the following properties: for all  T , T
proof of Proposition 1 below)

).

∗

(cid:17)

(1)
from P(Mod) into P(Sen) form what is known as a Galois 
(cid:17) ⊆ Sen and M, M(cid:17) ⊆ Mod, we have (see [13] and the 

(cid:17)) ⊆ Mod(T )

(cid:17) =⇒ Mod(T

(1) T ⊆ T
(2) M ⊆ M(cid:17) =⇒ M(cid:17)∗ ⊆ M∗
(3) T ⊆ Mod(T )∗
(4) M ⊆ Mod(M∗)

Deﬁnition 2 (Knowledge base and theory). A knowledge base T is a set of sentences (i.e.  T ⊆ Sen). A knowledge base  T is 
said to be a theory if and only if T = Cn(T ).

(cid:17) ⊆ Sen such that T = Cn(T

(cid:17)).

A theory T is ﬁnitely representable if there exists a ﬁnite set T

Proposition 1. For every satisfaction system R, we have:

Inclusion ∀T ⊆ Sen, T ⊆ Cn(T );
Iteration ∀T ⊆ Sen, Cn(T ) = Cn(Cn(T ));
Monotonicity ∀T , T

(cid:17) ⊆ Sen, T ⊆ T

(cid:17) =⇒ Cn(T ) ⊆ Cn(T

(cid:17)).

Proof. For  the  sake  of  completeness,  let  us  ﬁrst  show  that  Mod is  decreasing  (Property  1):  let  us  assume  T ⊆ T
, and thus M |= ϕ. Hence M ∈ Mod(T ).
∀M ∈ Mod(T

(cid:17)) we have ∀ϕ ∈ T , ϕ ∈ T

(cid:17)

(cid:17)

,  then 

Let us now show that Cn is increasing (monotonicity property): let us assume  T ⊆ T

(cid:17)), M ∈ Mod(T ) since Mod is decreasing, and M |= ϕ. Hence ϕ ∈ Cn(T

(cid:17)).

Mod(T

(cid:17)

, then ∀ϕ ∈ Cn(T ) we have ∀M ∈

(Property  3):  indeed,  ∀ϕ ∈ T we  have  ∀M ∈ Mod(T ), M |= ϕ by  deﬁnition  of  Mod(T ).  Hence 

We  have  T ⊆ Mod(T )∗
.

ϕ ∈ Mod(T )∗

It is then easy to see that Cn is extensive (inclusion property) from the previous property and Cn(T ) = Mod(T )∗
Let  us  ﬁnally  show  that  Cn is  idempotent  (iteration  property):  extensivity  implies  ∀T , Cn(T ) ⊆ Cn(Cn(T )).  Since  T ⊆

.

Mod(T )∗

and Cn is increasing, we have Cn(T ) ⊆ Cn(Mod(T )∗) = Cn(Cn(T )). (cid:2)

Hence,  satisfaction  systems  are  Tarskian according  to  the  deﬁnition  of  logics  given  by  Tarski:  a  logic  is  a  pair  (L, Cn)
where L is a set of expressions (formulas) and  Cn : P(L) → P(L) is a mapping that satisﬁes the inclusion, iteration and 
monotonicity  properties [40].  Indeed,  from  any  satisfaction  system  R we  can  deﬁne  the  following  Tarskian  logic  (L, Cn)
where L = Sen and Cn is the mapping that associates to every T ⊆ Sen, the set Cn(T ) of semantic consequences of T .

Classically, the consistency of a theory  T is deﬁned as  Mod(T ) (cid:20)= ∅. The problem of such a deﬁnition of consistency is 
that  its  signiﬁcance  depends  on  the  considered  logic.  Hence,  this  consistency  is  signiﬁcant  for FOL,  while  in FHCL it  is  a 
trivial property since each set of sentences is consistent because  Mod(T ) always contains  T ri v which is non-empty. Here, 
for the notion of consistency to be more appropriate for our purpose of deﬁning revision for the largest family of logics, we 
propose a more general deﬁnition of consistency, the meaning of which is that there is at least a sentence which is not a 
semantic consequence.

Deﬁnition 3 (Consistency). T ⊆ Sen is consistent if Cn(T ) (cid:20)= Sen.

Proposition 2. For every T ⊆ Sen, T is consistent if and only if Mod(T ) \ T ri v (cid:20)= ∅.

164

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

Proof. Let us prove that Cn(T ) = Sen iff Mod(T ) \ T ri v = ∅. Let us ﬁrst assume that Mod(T ) \ T ri v = ∅. Therefore, this means 
that the only models that satisfy T are M such that M∗ = Sen (if they exist). Hence, we have Cn(T ) = Mod(T )∗ = Sen.

Conversely, let us assume that  Cn(T ) = Sen. This means that every model M such that M∗ (cid:20)= Sen does not belong to 

Mod(T ), and Mod(T ) \ T ri v = ∅. (cid:2)

Corollary 1. For every T ⊆ Sen, T is inconsistent is equivalent to Mod(T ) = T ri v.

3.  AGM postulates for revision in satisfaction systems

3.1.  AGM postulates and weakened AGM postulates

The AGM postulates for knowledge base revision in satisfaction systems are easily adaptable. We build upon the model-
theoretic  characterization  introduced  by  Katsuno  and  Mendelzon  (KM) [22] for  propositional  logic.  Note,  however,  that  in 
propositional logic, a belief base can be represented by a formula, and then the KM postulates exploit this property. This 
is no longer the case in our context, but we argue that the postulates are still appropriate, except the one on syntax inde-
(cid:17)
, that is,  T ◦ T
pendence, as discussed next. Given two knowledge bases  T , T
is obtained by adding consistently new knowledge  T
T ∪ T
is consistent. This is what the AGM postulates ensure.

is consistent. The revision operator has then to minimally change T so that T ◦ T

to the old knowledge base  T . Note that  T ◦ T

because nothing ensures that T ∪ T

cannot be deﬁned as 
(cid:17)

denotes the revision of T by T

(cid:17) ⊆ Sen,  T ◦ T

(cid:17)

(cid:17)

(cid:17)

(cid:17)

(cid:17)

(cid:17)

Here we use the following weakened AGM postulates3:

(cid:17)

(G1) If T
(G2) Mod(T ◦ T
(G3) if T ∪ T
(G5) Mod((T ◦ T
(G6) if (T ◦ T

(cid:17)

is consistent, then so is T ◦ T

(cid:17)

.

(cid:17)).

(cid:17)) ⊆ Mod(T
is consistent, then T ◦ T
(cid:17)(cid:17)) ⊆ Mod(T ◦ (T
is consistent, then Mod(T ◦ (T

(cid:17) = T ∪ T
(cid:17)(cid:17))).
(cid:17) ∪ T

(cid:17)) ∪ T
(cid:17)(cid:17)

(cid:17)) ∪ T

.

(cid:17)

(cid:17) ∪ T

(cid:17)(cid:17))) ⊆ Mod((T ◦ T

(cid:17)) ∪ T

(cid:17)(cid:17)).

In the literature such as in [22,30], an additional postulate concerns the independence of the syntax:

(G4) If Cn(T 1) = Cn(T

(cid:17)
1) and Cn(T 2) = Cn(T

(cid:17)
2), then Mod(T 1 ◦ T 2) = Mod(T

(cid:17)
1

◦ T

(cid:17)
2).

This  postulate  states  a  complete  independence  of  the  syntactical  forms  of  both  the  original  knowledge  base  and  the 
newly acquired knowledge. The problem with Postulate (G4) is that it is almost never satisﬁed when we want to preserve 
the  structure  of  knowledge  bases  and  then  apply  revision  operators  over  the  formulas  that  compose  knowledge  bases. 
Indeed,  let  us  consider  in  the  logic PL the  following  knowledge  bases  T 1 = {p, q} and  T 2 = {q ⇒ p, q} over  the  signature 
(cid:17) = {¬q}. 
{p, q}.  Obviously,  we  have  that  Mod(T 1) = Mod(T 2) = {ν : p (cid:23)→ 1, q (cid:23)→ 1}.  Let  us  consider  the  knowledge  base  T
(cid:17)
We have now that  T 1 ∪ T
(and then  T 2 ∪ T
) is inconsistent. A way to retrieve the consistency is to replace in  T 1 and  T 2
(cid:17)) = {ν : p (cid:23)→ 1, q (cid:23)→ 0}, 
(cid:17) = {q ⇒ p, ¬q}. Then  Mod(T 1 ◦ T
(cid:17) = {p, ¬q} and  T 2 ◦ T
the atomic formula q by ¬q. Hence,  T 1 ◦ T
(cid:17)).  This  example  shows  that  syntax 
Mod(T 2 ◦ T
independence may be too strong a requirement.

(cid:17)) = {ν : p (cid:23)→ 1, q (cid:23)→ 0; ν(cid:17) : p (cid:23)→ 0, q (cid:23)→ 0},  and  Mod(T 1 ◦ T

(cid:17)) (cid:20)= Mod(T 2 ◦ T

(cid:17)

In [22], the authors bypass the problem by representing any knowledge base K (which is a theory in [22]) by a proposi-
tional formula ψ such that  K = Cn(ψ). Hence, they apply their revision operator on ψ and not on  K , and so they lose the 
structure of the knowledge base K .

A weaker form of this postulate could be written as:

(G’4) If Cn(T

(cid:17)
1) = Cn(T

(cid:17)
2), then Mod(T ◦ T

(cid:17)
1) = Mod(T ◦ T

(cid:17)
2),

which  ensures  a  partial  independence  of  the  syntax,  only  on  the  new  knowledge.  Remarkably,  this  weaker  form  can  be 
derived from the other postulates (as expressed in Proposition 3), and is hence not used in the subsequent proofs (see e.g. 
Theorem 1 below).

Proposition 3. Postulates (G1)–(G3), (G5) and (G6) imply Postulate (G’4).

Proof. See Appendix. (cid:2)

Based on this result, the only weakened AGM postulates (G1)–(G3), (G5) and (G6) are considered next.

3 The numbering is kept consistent with the ones in previous works.

3.2.  Faithful assignment and weakened AGM postulates

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

165

Intuitively, any revision operator ◦ satisfying the weakened AGM postulates above induces minimal change, that is the 
models of  T ◦ T
, according to some distance for measuring how 
close are models. This is what is now shown in this section by establishing a correspondence between the weakened AGM 
postulates and binary relations over models with minimality conditions.

are the models of  T that are the closest to models of  T

(cid:17)

(cid:17)

Let M ⊆ Mod and (cid:24) be a binary relation over M. We deﬁne ≺ as M ≺ M(cid:17)

if and only if M (cid:24) M(cid:17)

and M(cid:17)(cid:2)M. We 

also deﬁne Min(M, (cid:24)) = {M ∈ M | ∀M(cid:17) ∈ M, M(cid:17)⊀M}.

Deﬁnition 4 (Faithful assignment). An assignment is a mapping that assigns to each knowledge base T a binary relation (cid:24)T
over Mod. We say that this assignment is faithful (FA) if the following two conditions are satisﬁed:

(1) if M, M(cid:17) ∈ Mod(T ), M⊀
.
(2) for every M ∈ Mod(T ) and every M(cid:17) ∈ Mod \ Mod(T ), M ≺T M(cid:17)

M(cid:17)

T

.

A binary relation (cid:24)T assigned to a knowledge base T by a faithful assignment will be also said faithful.

This deﬁnition of FA differs from the one originally given in [22] on two points:

(1) In [22], a third condition is stated:

∀T , T

(cid:17) ⊆ Sen, Mod(T ) = Mod(T

(cid:17)

) ⇒(cid:24)T =(cid:24)T (cid:17) .

As for (G4), this condition expresses a syntactical independence.

(2) It is not required for (cid:24)T to be a pre-order. As shown below, the only important feature to have to make a correspon-
dence between a FA and the fact that ◦ satisﬁes the weakened AGM Postulates is that there is a minimal model for (cid:24)T
in Mod(T

(cid:17)) as expressed by Theorem 1.

Theorem 1. Let ◦ be a revision operator. The operator ◦ satisﬁes the weakened AGM Postulates (as deﬁned in Section 3.1) if and only if 
there exists a FA that maps each knowledge base T ⊆ Sen to a binary relation (cid:24)T such that for every knowledge base T

(cid:17) ⊆ Sen:

• Mod(T ◦ T
(cid:17)
• if T
• for every T

(cid:17)) \ T ri v = Min(Mod(T
is consistent, then Min(Mod(T
(cid:17)(cid:17)
(cid:17)(cid:17) ⊆ Sen, if (T ◦ T

(cid:17)) ∪ T

(cid:17)) \ T ri v, (cid:24)T );
(cid:17)) \ T ri v, (cid:24)T ) (cid:20)= ∅;
is consistent, then Min(Mod(T

(cid:17)) \ T ri v, (cid:24)T ) ∩ Mod(T

(cid:17)(cid:17)) = Min(Mod(T

(cid:17) ∪ T

(cid:17)(cid:17)) \ T ri v, (cid:24)T ).

Proof. See Appendix. (cid:2)

(cid:17)

(cid:17)

Note that if  T

is inconsistent, then so is  T ◦ T

, which corresponds to a cautious 
revision. The case where T is inconsistent is not considered in this paper (and is usually excluded from the scope of revision 
procedures), since in that case other operators could be more relevant than revision, in particular debugging methods (see 
e.g. [36] for debugging of terminologies, or [32] for base revision for ontology debugging, both in description logics).

, and we can set arbitrarily  T ◦ T

Given a revision operator ◦ satisfying the weakened AGM postulates, any FA satisfying the supplementary conditions of 
Theorem 1 will be called FA+. To a revision operator ◦ satisfying the weakened AGM postulates, we can associate many FA+. 
An example of such a FA+ was given in the proof of Theorem 1. Another example is the mapping  f that associates to every 
T ⊆ Sen the binary relation (cid:24)T deﬁned as follows:

(cid:17) = T

(cid:17)

Given T

(cid:17) ⊆ Sen, let us start by deﬁning (cid:24)T
T

(cid:17)

⊆ Mod(T

(cid:17)) × Mod(T

(cid:17)) as:

(cid:17)

M (cid:24)T
T

M(cid:17) ⇐⇒ M ∈ Mod(T ◦ T

(cid:17)

) and M(cid:17)

/∈Mod(T ◦ T

(cid:17)

).

Let us then set  f (T ) = (cid:24)T =

(cid:2)

(cid:17)

T (cid:17) (cid:24)T

T

(i.e. M (cid:24)T M(cid:17) ⇔ ∃T

(cid:17)

(cid:17), M (cid:24)T
T

M(cid:17)

).

Theorem 2. If ◦ satisﬁes the weakened AGM postulates, then the mapping  f deﬁned above is a FA+.

Proof. See Appendix. (cid:2)

Actually, the set of FA+ associated with a revision operator satisfying the weakened AGM postulates has a lattice struc-

ture, as shown by the following deﬁnition and propositions.

Deﬁnition 5. Let  f 1, f 2 be two FA. Let us denote  f 1 (cid:15) f 2 (resp.  f 1 (cid:14) f 2) the mapping that assigns to each knowledge base 
T ⊆ Sen the binary relation (cid:24)T =(cid:24)1
T

T ) where  f i(T ) =(cid:24)i

T (resp. (cid:24)T =(cid:24)1

T for i = 1, 2.

∪ (cid:24)2

∩ (cid:24)2

T

166

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

Proposition 4. If  f 1 and  f 2 are FA+ for a same revision operator ◦, then so are  f 1 (cid:15) f 2 and  f 1 (cid:14) f 2.

Proof. See Appendix. (cid:2)

Proposition 5. The relation ≤ deﬁned on FA+ by:

f ≤ g ⇐⇒ ∀T ⊆ Sen, f (T ) ⊆ g(T )

is a partial ordering.

Given a revision operator ◦ which satisﬁes the weakened AGM postulates, the poset (FA+(◦), ≤) of FA+ associated with ◦ is a lattice. 
For any  f , g ∈ FA+(◦),  f (cid:15) g (respectively  f (cid:14) g) is the least upper bound (respectively the greatest lower bound) of { f , g}. The lattice 
(FA+(◦), ≤) is further complete.

Proof. The fact that the relation ≤ actually deﬁnes a partial order is straightforward. The fact that  f (cid:15) g and  f (cid:14) g are the 
least upper bound and greatest lower bound of { f , g} is also easy to show.

Given a subset  S ⊆ FA+(◦), its least upper bound is the mapping (cid:15)S : T (cid:23)→

(cid:3)

f ∈S f (T ), and its greatest lower bound is 

the mapping (cid:14)S : T (cid:23)→

f ∈S f (T ). By extending the proof of Proposition 4, it is easy to show that (cid:15)S and (cid:14)S are FA+. (cid:2)

(cid:2)

3.3.  Relaxation and AGM postulates

Relaxations have been introduced in [14,15] in the framework of description logics with the aim of deﬁning dissimilarity 

between concepts. Here, we propose to generalize this notion in the framework of satisfaction systems.

Deﬁnition 6 (Relaxation). A relaxation is a mapping ρ : Sen → Sen satisfying the following properties:

Extensivity ∀ϕ ∈ Sen, Mod(ϕ) ⊆ Mod(ρ(ϕ)).
Exhaustivity ∃k ∈ N, Mod(ρk(ϕ)) = Mod, where ρ0 is the identity mapping, and for all k > 0, ρk(ϕ) = ρ(ρk−1(ϕ)).

Let us observe that relaxations exist if and only if the underlying satisfaction system (Sen, Mod, |=) has tautologies (i.e. 
formulas ϕ ∈ Sen such that Mod(ϕ) = Mod). Indeed, when the satisfaction system has tautologies, we can deﬁne the trivial 
relaxation ρ : ϕ (cid:23)→ ψ where ψ is any tautology.4 Conversely, all relaxations imply that the underlying satisfaction system 
has tautologies to satisfy the exhaustivity condition.

The  interest  of  relaxations  is  that  they  give  rise  to  revision  operators  which  have  demonstrated  their  usefulness  in 

practice (see Section 4).

Notation 2. Let T ⊆ Sen be a knowledge base. Let K = {kϕ ∈ N | ϕ ∈ T }, and K(cid:17) = {k

(cid:17)
ϕ

∈ N | ϕ ∈ T }. Let us note:

(cid:4)

(cid:4)

• ρK(T ) = {ρkϕ (ϕ) | kϕ ∈ K, ϕ ∈ T },
K =
•
• K ≤ K(cid:17)
• K < K(cid:17)

(cid:17)
when for every ϕ ∈ T , kϕ ≤ k
ϕ ,
(cid:17)
if K ≤ K(cid:17)
and ∃ϕ ∈ T , kϕ < k
ϕ .

kϕ ∈K kϕ ,

In this notation, kϕ is a number associated with each formula ϕ of the knowledge base (equivalently it can be considered 

as a function of ϕ taking values in N), which intuitively represents the degree to which ϕ is relaxed.

Deﬁnition 7  (Revision based on relaxation).  Let  ρ be  a  relaxation.  A revision operator over ρ is  a  mapping  ◦ : P(Sen) ×
P(Sen) → P(Sen) satisfying for every T , T

(cid:17) ⊆ Sen:

(cid:5)

T ◦ T

(cid:17) =

(cid:17)

ρK(T ) ∪ T
(cid:17)
T

(cid:17)

if T

is consistent

otherwise

for some K = {kϕ ∈ N | ϕ ∈ T } such that:

is consistent, then T ◦ T

is consistent;

such that ρK(cid:17)

(cid:17)
(T ) ∪ T

(cid:17)

is consistent, 

(cid:4)

(cid:4)

K(cid:17)

K ≤

(minimality on the number of applications of the relax-

such that Mod(T

(cid:17)) ⊆ Mod(T

(cid:17)(cid:17)), if T ◦ T

(cid:17)(cid:17) = ρK(cid:17)

(T ) ∪ T

(cid:17)(cid:17)

, then K(cid:17) ≤ K.

(cid:17)
(1) if T
(2) for every K(cid:17)
ation);
(3) for every T

(cid:17)(cid:17)

4 Note that most systems have tautologies. An example without tautology would be a non-complete logic where the only connective is ∨.

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

167

Fig. 1. Successive relaxations of T until it becomes consistent with T

(cid:17)

.

Revision based on relaxation is illustrated in Fig. 1 where theories are represented as sets of their models. Intermediate 

steps to deﬁne the revision operators are then the deﬁnitions of formula and theory relaxations.

It  is  important  to  note  that  given  a  relaxation  ρ,  several  revision  operators  can  be  deﬁned.  Without  Condition  3  of 
Deﬁnition 7, we could accept revision operators ◦ that do not satisfy Postulates (G5) and (G6). Hence, Condition 3 allows 
us to exclude such operators. To illustrate this, let us consider in FOL the satisfaction system R = (Sen, Mod, |=) over the 
signature (S, F , P ) where  S = {s},  F = ∅ and  P = {=: s × s}. Let us consider T , T

(cid:17) ⊆ Sen such that:

⎧
⎪⎨

⎪⎩
⎧
⎪⎨

⎪⎩

T =

(cid:17) =

T

∃x.∃ y.(¬x = y) ∧ ∀z(z = x ∨ z = y)
∃x.∃ y.∃z.(¬x = y ∧ ¬ y = z ∧ ¬x = z)∧
∀w(w = x ∨ w = y ∨ w = z)

∀x.x = x
∀x.∀ y.x = y ⇒ y = x
∀x.∀ y.∀z.x = y ∧ y = z ⇒ x = z

⎫
⎪⎬

⎪⎭

⎫
⎪⎬

⎪⎭

(cid:17)

(cid:17)

Obviously, T

is consistent. As T does not contain the axioms for equality, it is also consistent. Indeed, the model M with 
its associated set  Ms = {0, 1, 2} and the binary relation =M⊆ Ms × Ms, deﬁned by the following set {(0, 0), (1, 1), (2, 0)}, 
satisﬁes T .

But  T ∪ T

is not consistent. The reason is that when the meaning of  = is the equality, the ﬁrst axiom of  T can only 
be satisﬁed by models with two values while the second axiom is satisﬁed by models with three values. A way to retrieve 
the consistency is to remove one of the two axioms. This can be modeled by the relaxation ρ that maps each formula to 
a  tautology.5 But  in  this  case,  we  have  then  two  options  depending  on  whether  we  remove  and  change  the  ﬁrst  or  the 
second axiom by a tautology, which give rise to two revision operators ◦1 and ◦2. The ﬁrst two conditions of Deﬁnition 7
are satisﬁed by both ◦1 and ◦2.

(cid:17)(cid:17) = {∃x.∃ y.¬x = y} which is satisﬁed, when added to the axioms in  T

, by any model with at least 
(cid:17)) ∪ T
two elements. Hence, (T ◦1 T
are consistent. Without the third condition, nothing would prevent 
(cid:17)(cid:17))) by removing and change in T the second (respectively the ﬁrst) axiom 
to deﬁne T ◦1 (T
by a tautology which would be a counter-example to Postulates (G5) and (G6). Actually, as shown by the result below, this 
third condition of Deﬁnition 7 entails Postulates (G5) and (G6), and then, by Proposition 3, entails Postulate (G’4).

(cid:17)) ∪ T
(cid:17)(cid:17)) (respectively T ◦2 (T

and (T ◦2 T
(cid:17) ∪ T

Now, let us take  T

(cid:17) ∪ T

(cid:17)(cid:17)

(cid:17)(cid:17)

(cid:17)

However  in  some  situations  Condition  3  may  be  considered  as  too  strong,  forcing  to  relax  more  than  what  would  be 
needed to satisfy only Condition 2. This could typically be the case when Condition 2 could be obtained in two different 
ways, for instance for K(cid:17) = {0, 1, 0, 0...} or for K(cid:17)(cid:17) = {1, 0, 0, 0...}. Then taking Cn(T
using K(cid:17)
would not meet Condition 3. To satisfy it, relaxation should be done for instance with K = {1, 1, 0, 0...}. 
and T ◦ T
Therefore in concrete applications, we will have to ﬁnd a compromise between Condition 3 and (G5)–(G6) at the price of 
potential larger relaxations on the one hand, and less relaxation but potentially the loss of (G5)–(G6) on the other hand.

(cid:17)(cid:17)), and revising T ◦ T

(cid:17)) = Cn(T

using K(cid:17)(cid:17)

(cid:17)(cid:17)

(cid:17)

Notation 3. In the context of Deﬁnition 7, let  T , T
N | ϕ ∈ T }, then we note KT
T

= K.

(cid:17)

(cid:17) ⊆ Sen be two knowledge bases. If  T ◦ T

(cid:17) = ρK(T ) ∪ T

(cid:17)

with K = {kϕ ∈

Theorem 3. Any revision operator ◦ based on a relaxation (Deﬁnition 7) satisﬁes the weakened AGM postulates.

Proof. See Appendix. (cid:2)

So  far  we  showed  that  several  FA+  can  be  associated  with  a  given  revision  operator  ◦ satisfying  the  weakened  AGM 
postulates. Here, we deﬁne a particular one, which is more speciﬁc to revision operators based on relaxation. Let ρ be a 
relaxation and  fρ be the mapping that associates to every T ⊆ Sen the binary relation (cid:24)T deﬁned as follows:

5 We will see in Section 4.3 a less trivial but more interesting relaxation in FOL that consists in changing universal quantiﬁers into existential ones.

168

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

Given T

(cid:17) ⊆ Sen, let us start by deﬁning (cid:24)T
T

(cid:17)

⊆ Mod(T

(cid:17)) × Mod(T

(cid:17)) as:
(cid:5)

(cid:17)

M (cid:24)T
T

M(cid:17) ⇐⇒ ∀K(cid:17)(cid:17)≥ KT

(cid:17)

T , M(cid:17) ∈ Mod(ρK(cid:17)(cid:17)

(T )) ⇒ ∃K(cid:17)≥ KT

(cid:17)

T ,

and

K(cid:17) < K(cid:17)(cid:17)
M ∈ Mod(ρK(cid:17)

(T ))

Let us then set (cid:24)T =

(i.e. M (cid:24)T M(cid:17) ⇔ ∃T
Intuitively, it means that T has to be relaxed more to be satisﬁed by M(cid:17)

). We have (cid:24)T ⊆ Mod × Mod because (cid:24)∅
T
than to be satisﬁed by M.

(cid:17), M (cid:24)T
T

T (cid:17) (cid:24)T

M(cid:17)

T

⊆(cid:24)T .

(cid:17)

(cid:2)

(cid:17)

Theorem 4. For any revision operator ◦ based on a relaxation ρ as deﬁned in Deﬁnition 7, the mapping  fρ is a FA+.

Proof. See Appendix. (cid:2)

4.  Applications

In  this  section,  we  illustrate  our  general  approach  by  deﬁning  revision  operators  based  on  relaxations  for  the  logics
PL, HCL, and FOL. We further develop the case of DLs in Section 4.4, by deﬁning several concrete relaxation operators for 
different fragments of the DL ALC.

4.1.  Revision in PL

Here, inspired by the work in [7,8] on Morpho-Logics, we deﬁne relaxations based on dilations from mathematical mor-
phology [6]. In PL, knowing a formula is equivalent to knowing the set of its models, and we can identify any propositional 
formula ϕ with the set of its interpretations Mod(ϕ). To deﬁne relaxations in PL, we will apply set-theoretic morphological 
operations.  First,  let  us  recall  a  basic  deﬁnition  of  dilation  in  mathematical  morphology [6].  Let  X and  B be  two  subsets 
of Rn. The dilation of  X by the structuring element  B, denoted by  D B ( X), is deﬁned as follows:

D B (X) = {x ∈ Rn | B x ∩ X (cid:20)= ∅}

where  B x denotes  the  translation  of  B at  x.  More  generally,  dilations  in  any  space  can  be  deﬁned  in  a  similar  way  by 
considering the structuring element as a binary relationship between elements of this space.6

In PL, this leads to the following dilation of a formula ϕ ∈ Sen:

Mod(D B (ϕ)) = {ν ∈ Mod | Bν ∩ Mod(ϕ) (cid:20)= ∅}

where  Bν contains  all  the  models  that  satisfy  some  relationship  with  ν.  The  relationship  standardly  used  is  based  on  a 
discrete  distance  δ between  models,  and  the  most  commonly  used  is  the  Hamming  distance dH where dH (ν, ν(cid:17)) for  two 
propositional  models  over  a  same  signature  is  the  number  of  propositional  symbols  that  are  instantiated  differently  in 
ν and  ν(cid:17)
.  From  any  distance  δ between  models,  a  distance  from  models  to  a  formula  is  derived  as  follows:  d(ν, ϕ) =
minν(cid:17)|=ϕδ(ν, ν(cid:17)). In this case, we can rewrite the dilation of a formula as follows:

Mod(D B (ϕ)) = {ν ∈ Mod((cid:2)) | d(ν, ϕ) ≤ 1}

This  consists  in  using  the  distance  ball  of  radius  1  as  structuring  element  B.  To  ensure  the  exhaustivity  condition  to  our 
relaxation, we need to add a condition on distances, the betweenness property [14].

Deﬁnition 8 (Betweenness property). Let δ be a discrete distance over a set  S. δ has the betweenness property if for all x, y
in  S and all k in {0, 1, . . . , δ(x, y)}, there exists z in  S such that δ(x, z) = k and δ(z, y) = δ(x, y) − k.

The Hamming distance trivially satisﬁes the betweenness property. The interest for our purpose of this property is that 

it allows from any model to reach any other one, and then ensuring the exhaustivity property of relaxation.7

Proposition 6. Let D B be a dilation applied to formulas ϕ ∈ Sen for a ﬁnite signature, and based on a distance between models that 
satisﬁes the betweenness property. Such a dilation D B is a relaxation.

6 Deﬁnitions based on the notion of structuring elements are all particular cases of more general algebraic dilations, deﬁned as operators between lattices, 
which commute with the supremum.
7 Hence, a dilation of formulas could also be deﬁned by using a distance ball of radius n as structuring element [7].

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

169

Fig. 2. A simple example of revision based on dilation in PL (see text). (For interpretation of the references to color in this ﬁgure, the reader is referred to 
the web version of this article.)

Proof. It is extensive. Indeed, for every ϕ and for every model ν ∈ Mod(ϕ), we have that d(ν, ϕ) = 0, and then ϕ |= D B (ϕ). 
Exhaustivity results from the fact that the considered signature is a ﬁnite set and from the betweenness property. (cid:2)

Using Deﬁnition 7, this relaxation allows deﬁning revision operators that include the classical Dalal’s revision as a par-

ticular case (see [7,8]).

A  simple  example  is  illustrated  in  Fig. 2.  Three  propositional  symbols  a,  b and  c are  considered.  The  set  of  models  is 
represented  by  the  vertices  of  a  cube,  and  we  assimilate  a  formula  formed  by  a  simple  conjunction  of  symbols  with  its 
corresponding  model.  For  instance  a ∧ b ∧ c is  assimilated  to  the  corresponding  world,  represented  by  the  point  (1, 1, 1)
in the cube. The edges link two worlds differing by one instantiation of a propositional symbol, i.e. at a distance 1 for the 
Hamming distance. For instance vertices representing a ∧ b ∧ c and ¬a ∧ b ∧ c are linked by an edge (we have dH (a ∧ b ∧
c, ¬a ∧ b ∧ c) = 1).  Colored  dots  deﬁne  ϕ and  ψ :  ϕ = a ∧ b ∧ c and  ψ = ¬c.  The  red  circle  represents  the  result  of  the 
revision  ϕ ◦ ψ= a ∧ b ∧ ¬c.  Indeed,  ϕ and  ψ are  inconsistent,  hence  we  relax  ϕ by  a  dilation  of  size  1  according  to  the 
Hamming distance, leading to  D B (ϕ) = (a ∧ b ∧ c) ∨ (¬a ∧ b ∧ c) ∨ (a ∧ ¬b ∧ c) ∨ (a ∧ b ∧ ¬c), which is now consistent with 
ϕ and the conjunction provides the revision. The result here simply amounts to change the old belief which included c, by 
negating this atom according to the new knowledge expressed by ψ .

4.2.  Revision in HCL

Many works have focused on belief revision involving propositional Horn formulas (cf. [12] to have an overview on these 
works). Here, we propose to extend relaxations that we have deﬁned in the framework of PL to deal with the Horn fragment 
of propositional theories.

Deﬁnition 9 (Model intersection). Given a propositional signature (cid:2) and two (cid:2)-models ν, ν(cid:17) : (cid:2) → {0, 1}, we note ν ∩ ν(cid:17) :
(cid:2) → {0, 1} the (cid:2)-model deﬁned by:
1 if ν(p) = ν(cid:17)(p) = 1
0 otherwise

p (cid:23)→

(cid:13)

Given a set of (cid:2)-models S, we note

cl∩(S) = S ∪ {ν ∩ ν(cid:17) | ν, ν(cid:17) ∈ S}

cl∩(S) is then the closure of S under intersection of positive atoms.

For any set S closed under intersection of positive atoms, there exists a Horn sentence ϕ that deﬁnes S (i.e.  Mod(ϕ) =
S). Given a distance δ between models, we then deﬁne a relaxation ρ as follows: for every Horn formula ϕ, ρ(ϕ) is any 
Horn formula ϕ(cid:17)

such that Mod(ϕ(cid:17)) = cl∩(Mod(D B (ϕ)) (by the previous property, we know that such a formula ϕ(cid:17)

exists).

Proposition 7. With the same conditions as in Proposition 6, the mapping ρ is a relaxation.

Then a revision operator can be deﬁned from ρ according to Deﬁnition 7.

4.3.  Revision in FOL

A  trivial  way  to  deﬁne  a  relaxation  in FOL is  to  map  any  formula  to  a  tautology.  A  less  trivial  and  more  interesting 
relaxation  is  to  change  universal  quantiﬁers  to  existential  ones.  Indeed,  given  a  formula  ϕ of  the  form  ∀x.ψ ,  if  ϕ is  not 
consistent with a given theory  T , ∃x.ψ may be consistent with  T (it is quite intuitive that if it cannot be consistent for all 
values,  it  can  be  for  some  of  them).  A  similar  approach  has  been  adopted  for  deﬁning  merging  operators  using  dilations 

170

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

Fig. 3. From concept relaxation and retraction to revision operators in DL.

in FOL in [20].  In  the  following  we  suppose  that  given  a  signature,  every  formula  ϕ in  Sen is  a  disjunction  of  formulas 
is in {∀, ∃}). Let us deﬁne the relaxation ρ as 
in prenex form (i.e. ϕ is of the form 
follows, for a tautology τ :

j
n j .ψ j where each  Q

j
1 . . . Q

j
n j x

j
1 x

j Q

(cid:14)

j

i

• ρ(τ ) = τ ;
• ρ(∃1x1 . . . ∃nxn.ϕ) = τ ;
• Let  ϕ = Q 1x1 . . . Q nxn.ψ be  a  formula  such  that  the  set  Eϕ = {i, 1 ≤ i ≤ n | Q i = ∀} (cid:20)= ∅.  Then,  ρ(Q 1x1 . . . Q nxn.ϕ) =

(cid:14)

i∈Eϕ ϕi where ϕi = Q
(cid:14)
j
1 . . . Q

j
n j x

j
1 x

j Q

j

n j .ψ) =

(cid:17)
1x1 . . . Q
(cid:14)

• ρ(

j ρ(Q

j
1 x

j
1 . . . Q

j
n j x

j
n j .ψ).

(cid:17)
nxn.ψ such that for every  j (cid:20)= i, 1 ≤ j ≤ n,  Q

(cid:17)
j

= Q j and  Q

= ∃;

(cid:17)
i

Proposition 8. ρ is a relaxation.

Proof. It is obviously extensive, and exhaustivity results from the fact that in a ﬁnite number of steps, we always reach the 
tautology τ . (cid:2)

Again a revision operator can then be deﬁned from ρ using Deﬁnition 7.

4.4.  Revision in DL

4.4.1.  General construction scheme

The instantiation of our abstract framework to DLs follows the scheme depicted in Fig. 3.
The necessary ingredient is the specialization of formulas relaxations as abstractly deﬁned in Deﬁnition 6. To this end, 
we propose to deﬁne a formula relaxation in two ways (other deﬁnitions may also exist). For sentences of the form C (cid:12) D, 
the ﬁrst proposed approach consists in relaxing the set of interpretations of D, while the second one amounts to “retracting” 
the set of interpretations of C . We give hereafter formal deﬁnitions of these notions of concept relaxation and retraction.

Deﬁnition 10 (Concept relaxation). Given a signature (NC , N R , I), we note C the set of concepts over this signature. A concept 
relaxation is an operator ρ : C → C that satisﬁes, in every model, the following properties for all C in C:

(1) ρ is extensive, i.e. C (cid:12) ρ(C)
(2) ρ is exhaustive, i.e. ∃k ∈ N, (cid:13) (cid:12) ρk(C)

A  similar  notion  of  concept  relaxation  has  ﬁrst  been  introduced  in [14,15] but  with  an  additional  constraint  of  non-

decreasingness property that we do not need in this work.

A  trivial  concept  relaxation  is  the  operation  ρ(cid:13) that  maps  every  concept  C to  (cid:13).  Other  non-trivial  concrete  concept 

relaxations will be discussed in the sequel.

Deﬁnition 11 (Concept retraction). A (concept) retraction is an operator κ : C → C that satisﬁes, in every model, the following 
properties for all C in C:

(1) κ is anti-extensive, i.e. κ(C) (cid:12) C , and
(2) κ is exhaustive, i.e. ∀D ∈ C, ∃k ∈ N such that κ k(C) (cid:12) D.

Note that in this deﬁnition,  D could be replaced equivalently by ⊥.
With  these  deﬁnitions  at  hand,  formulas  relaxation  can  be  deﬁned  as  follows,  using  either  concept  relaxation  (Deﬁni-
tion 10) or concept retraction (Deﬁnition 11). We suppose that any signature (NC , N R , I) always contains in  N R a relation 
O
(cid:13) = (cid:7)O × (cid:7)O
name r(cid:13) the meaning of which is, in any model O, r

.

Deﬁnition 12  (Formula relaxation based on concept relaxation).  Let  ρ a  concept  relaxation  as  in  Deﬁnition 10.  A  formula 
ρ is deﬁned as follows, for any two complex concepts C and  D, any individuals a, b, and 
relaxation based on ρ, denoted ρF
any role r:

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

171

ρρ
F (C (cid:12) D) ≡ C (cid:12) ρ(D),
ρρ
F (a : C) ≡ a : ρ(C),
ρρ
F ((cid:30)a, b(cid:31) : r)) ≡ (cid:30)a, b(cid:31) : r(cid:13).

Note that the relaxation of the role assertion axiom amounts to delete it from the knowledge base, since a tautology is 

satisﬁed by any model.

Proposition 9. ρρ

F is a formula relaxation in the sense of Deﬁnition 6.

Proof. It directly follows from the extensivity and exhaustivity of ρ. (cid:2)

Deﬁnition 13 (Formula relaxation based on concept retraction). A formula relaxation based on a concept retraction κ , denoted 
ρκ
F , is deﬁned as follows, for any two complex concepts C and  D, any individuals a, b, and any role r:

ρκ
F (C (cid:12) D) ≡ κ(C) (cid:12) D,
ρκ
F (a : C) ≡ a : (cid:13),
ρκ
F ((cid:30)a, b(cid:31) : r)) ≡ (cid:30)a, b(cid:31) : r(cid:13).

Similarly, the relaxation of the concept assertion amounts to delete it from the knowledge base.
A similar construction can be found in [29] for sentences of the form (a : C).

Proposition 10. ρκ

F is a formula relaxation in the sense of Deﬁnition 6.

Proof. Extensivity and exhaustivity follow directly from the properties of κ . (cid:2)

To complete the picture, it remains to deﬁne concrete concept relaxation and retraction operators for particular Descrip-
tion  Logics  families.  We  consider  the  logic  ALC,  as  deﬁned  in  Section 2.1,  and  its  fragments  EL and  ELU .  EL-concept 
description constructors are existential restriction (∃), conjunction ((cid:14)), (cid:13) and ⊥, while ELU -concept constructors are those 
of EL enriched with disjunction ((cid:15)).

4.4.2.  Relaxation and retraction in EL
EL-concept retractions.  A trivial concept retraction is the operator κ⊥ that maps every concept to ⊥. Note that this operator 
is  also  particularly  interesting  for  debugging  ontologies  expressed  in  EL [37].  Let  us  illustrate  this  operator  for  revision 
through the following example adapted from [29] to restrict the language to EL.

(cid:17)

(cid:17) = {Tweety (cid:14) ﬂies (cid:12) ⊥}. Clearly T ∪ T

Example 2. Let T = {Tweety (cid:12) bird, bird (cid:12) ﬂies} and T
is inconsistent. The formula 
relaxation based on the retraction κ⊥ amounts to apply κ⊥ to the concept Tweety resulting in the following new knowledge 
base  {⊥ (cid:12) bird, bird (cid:12) ﬂies} which  is  now  consistent  with  T
.  An  alternative  solution  is  to  retract  the  concept  bird in 
(cid:17)
bird (cid:12) ﬂies which  results  in  the  following  knowledge  base  {Tweety (cid:12) bird, ⊥ (cid:12) ﬂies} which  is  also  consistent  with  T
. 
The  sets  of  minimal  sum  K1 and  K2 in  Condition  2  of  Deﬁnition 7 are  K1 = {1, 0},  (i.e.  kϕ1
= 0,  where  ϕ1 =
Tweety (cid:12) bird, ϕ2 = bird (cid:12) ﬂies) and K2 = {0, 1}. However, Condition 3 of the same deﬁnition is not satisﬁed: let us take 
(cid:17)(cid:17) =
(cid:17)(cid:17) = T
T
ρK2 (T ) ∪ T
. But we do not have any ordering relation between K1 and K2. To ensure Condition 3, we must relax one more 
time  the  axioms  in  T leading  to  the  following  knowledge  base  {⊥ (cid:12) bird, ⊥ (cid:12) ﬂies} (for  K = {1, 1}).  The  ﬁnal  revision 
(cid:17) = {⊥ (cid:12) bird, ⊥ (cid:12) ﬂies, Tweety (cid:14) ﬂies (cid:12) ⊥}. This revision satisﬁes the weakened AGM postulates but may 
then writes T ◦ T
(cid:17) = {⊥ (cid:12) bird, bird (cid:12) ﬂies, Tweety (cid:14) ﬂies (cid:12) ⊥}
appear too strong, and one may prefer one of the following solutions: T ◦1 T
or T ◦2 T

(cid:17) = {Tweety (cid:12) bird, ⊥ (cid:12) ﬂies, Tweety (cid:14) ﬂies (cid:12) ⊥} at the price of loosing (G5)–(G6).

(cid:17)(cid:17)). We can then write T ◦ T

. Then a fortiori we have Mod(T

(cid:17)(cid:17) = ρK2 (T ) ∪ T

(cid:17) = ρK1 (T ) ∪ T

(cid:17)) ⊆ Mod(T

and T ◦ T

= 1, kϕ2

(cid:17)

(cid:17)

(cid:17)

(cid:17)

Although  the  results  are  rather  intuitive,  one  should  note  that  it  is  pretty  hard  to  ﬁgure  out  what  each  DL  researcher 
would like to have as a result in such an example, and this enforces the interest of relying on an established theory such 
as AGM or its extension. In our work we propose operators enjoying a set of properties stemming from our adaptation of 
the AGM theory. Some of them can meet the requirement of a knowledge engineer, and some other may not completely, 
depending on the context, the ontology, etc.

EL-concept relaxations.  Dually,  a  trivial  relaxation  is  the  operator  ρ(cid:13) that  maps  every  concept  to  (cid:13).  Other  non-trivial 
EL-concept description relaxations have been introduced in [14]. We summarize here some of these operators.

172

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

EL concept descriptions can appropriately be represented as labeled trees, often called EL description trees [3]. An EL
description tree is a tree whose nodes are labeled with sets of concept names and whose edges are labeled with role names. 
An EL concept description

C ≡ P 1 (cid:14) · · · (cid:14) P n (cid:14) ∃r1.C1 (cid:14) · · · (cid:14) ∃rm.Cm,

(2)

with  P i ∈ NC ∪ {(cid:13)}, can be translated into a description tree by labeling the root node  v 0 with {P 1, . . . , P n}, creating an r j
successor, and then proceeding inductively by expanding C j for the r j -successor node for all  j ∈ {1, . . . , m}.

An  EL-concept  description  relaxation  then  amounts  to  apply  simple  tree  operations.  Two  relaxations  can  hence  be 
deﬁned [14]: (i) ρdepth that reduces the role depth of each concept by  1, simply by pruning the description tree, and (ii) 
ρleaves that removes all leaves from a description tree.

4.4.3.  Relaxations in ELU

The relaxation deﬁned above exploits the strong property that an EL concept description is isomorphic to a description 
tree. This is arguably not true for more expressive DLs. Let us try to go one step further in expressivity and consider the logic 
ELU . Here we only propose some deﬁnitions of relaxations. Retractions could be designed similarly. A relaxation operator, 
as introduced in [14], requires a concept description to be in a special normal form, called normal form with grouping of 
existentials, deﬁned recursively as follows.

Deﬁnition 14 (Normal form with grouping of existential restrictions). We say that an EL-concept  D is written in normal form 
with grouping of existential restrictions if it is of the form

D = (cid:14)

A (cid:14) (cid:14)

A∈N D

r∈N R

Dr,

where N D ⊆ NC is a set of concept names and the concepts  Dr are of the form

Dr = (cid:14)

E∈CDr

∃r.E,

(3)

(4)

where  no  subsumption  relation  holds  between  two  distinct  conjuncts  and  CDr
themselves in normal form with grouping of existential restrictions.

is  a  set  of  complex  EL-concepts  that  are 

The purpose of  Dr terms is simply to group existential restrictions that share the same role name. For an ELU -concept 
C we say that C is in normal form if it is of the form (C ≡ C1 (cid:15) C2 (cid:15) · · · (cid:15) Ck) and each of the Ci is an EL-concept in normal 
form with grouping of existential restrictions.

Deﬁnition 15 (Relaxation from normal form [14]). Given an ELU -concept description C we deﬁne an operator ρe recursively 
as follows.

• For C = (cid:13) we deﬁne ρe(C) = (cid:13).
• For C = Dr , where  Dr is a group of existential restrictions as in Equation (4), we need to distinguish two cases:

· if  Dr ≡ ∃r.(cid:13) we deﬁne ρe(Dr) = (cid:13), and
· if  Dr (cid:20)≡ ∃r.(cid:13) then we deﬁne ρe(Dr) = (cid:15)S⊆CDr
Note that in the latter case (cid:13) /∈ CDr since  Dr is in normal form.
• For C = D as in Equation (3) we deﬁne ρe(D) = (cid:15)G∈CD
ρe(G) (cid:14) (cid:14)H∈CD \{G} H
• Finally for C = C1 (cid:15) C2 (cid:15) · · · (cid:15) Ck we set ρe(C) = ρe(C1) (cid:15) ρe(C2) (cid:15) · · · (cid:15) ρe(Ck).

(cid:15)
(cid:14)E /∈S ∃r.E (cid:14) ∃r.ρe

(cid:14)F ∈S F

(cid:15)

(cid:15)

(cid:16)(cid:16)

.

(cid:16)

, where CD = N D ∪ {Dr | r ∈ N R }.

Proposition 11. [14] ρe is a relaxation.

Let us illustrate this operator with an example.

Example 3.  Suppose  an  agent  believes  that  a  person  Bob is  married  to  a  female  judge:  T = {Bob (cid:12) male (cid:14) ∃.MarriedTo.
(female (cid:14) judge)}. Suppose now that due to some obscurantist law, it happens that females are not allowed to be judges. 
(cid:17) = {judge (cid:14) female (cid:12) ⊥}. By applying ρe one can resolve the conﬂict between the two belief 
This new belief is captured as T
sets.  To  ease  the  reading,  let  us  rewrite  the  concepts  as  follows:  A ≡ male, B ≡ female, C ≡ judge, m ≡ MarriedTo, D ≡
∃MarriedTo. (female (cid:14) judge). Hence, from Deﬁnition 15 we have ρe( A (cid:14) D) ≡ (ρe( A) (cid:14) D) (cid:15) ( A (cid:14) ρe(D)), with ρe( A) ≡ (cid:13)
and

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

173

ρe(D) ≡ ∃m.ρe(B (cid:14) C) (cid:15) (∃m.B (cid:14) ∃m.ρe(C)) (cid:15) (∃m.ρe(B) (cid:14) ∃m.C)

≡ ∃m.(B (cid:15) C) (cid:15) (∃m.B (cid:14) ∃m.(cid:13)) (cid:15) (∃m.(cid:13) (cid:14) ∃m.C)
≡ ∃m.B (cid:15) ∃m.C (cid:15) ∃m.(B (cid:15) C) ≡ ∃m.B (cid:15) ∃m.C

Then

ρe( A (cid:14) D) ≡ (ρe( A) (cid:14) D) (cid:15) ( A (cid:14) ρe(D))

≡ ((cid:13) (cid:14) D) (cid:15) ( A (cid:14) (∃m.B (cid:15) ∃m.C))
≡ D (cid:15) ( A (cid:14) (∃m.B (cid:15) ∃m.C))

The new agent’s belief, up to a rewriting, becomes
{Bob (cid:12) ∃.MarriedTo. (female (cid:14) judge) (cid:15) (male (cid:14) (∃Married.female (cid:15) ∃Married.judge)) , judge (cid:14) female (cid:12) ⊥}.

One can notice from this example that the relaxation ρe leads to a reﬁned revision operator. Indeed, the resulting relaxed 
axiom in T emphasizes all the minimal possible changes (through the disjunction operator) on Bob’s condition. This is due 
to the fact that the relaxation operator ρe corresponds to dilating the set of models of a ball deﬁned from an edit distance 
on the concept description tree of size one. For more details on the correspondence between this relaxation operator, the 
set of models and tree edit distances, one can refer to [14].

Another possibility for deﬁning a relaxation in ELU is obtained by exploiting the disjunction constructor by augmenting 

a concept description with a set of exceptions.

Deﬁnition 16  (Relaxation from exceptions in ELU ).  Given  a  set  of  exceptions  E = {E 1, · · · , En},  we  deﬁne  a  relaxation  of 
degree k of an ELU -concept description C as follows: for a ﬁnite set E k ⊆ E with |E k| = k, C is relaxed by adding the sets 
E i j

∈ E k such that  E i j

(cid:14) C (cid:12) ⊥

E (C) = C (cid:15) E i1
ρk

(cid:15) · · · (cid:15) E ik .

Proposition 12. ρk

E is extensive.

Proof. Extensivity of this operator follows directly from the deﬁnition. (cid:2)

However, exhaustivity is not necessarily satisﬁed unless the exception set includes the (cid:13) concept, or the disjunction of 

some or all of its elements entails the (cid:13) concept.

If we consider again Example 2, a relaxation of the formula bird (cid:12) ﬂies using the operator ρk

E over the concept ﬂies with the ex-
ception set E = {Tweety} results in the formula bird (cid:12) ﬂies (cid:15) Tweety. The new revised knowledge base, if Condition 3 in Deﬁnition 7
is not considered, is then {Tweety (cid:12) bird, bird (cid:12) ﬂies (cid:15) Tweety, Tweety (cid:14) ﬂies (cid:12) ⊥} which is consistent. This is obviously a more 
reﬁned revision than the one obtained from the operator ρ⊥, but requires the logic to be equipped with the disjunction connective and 
the deﬁnition of a set of exceptions.

Another example involving this relaxation will be discussed in the ALC case (cf. Example 4).

4.4.4.  Relaxation and retraction in ALC

We consider here operators suited to ALC language. Of course, all the operators deﬁned for EL and ELU remain valid.

ALC-concept retractions.  A ﬁrst possibility for deﬁning retraction is to remove iteratively from an ALC-concept description 
one  or  a  set  of  its  subconcepts.  A  similar  construction  has  been  introduced  in [29].  Interestingly  enough,  almost  all  the 
operators deﬁned in [20,29] are relaxations.

Deﬁnition 17 (Retraction from exceptions in ALC). Given a set of exceptions E = {E 1, · · · , En}, we retract any ALC-concept 
description C by constraining it to the elements  E c

i such that  E i (cid:12) C :

E (C) = C (cid:14) E c
κ n
1

(cid:14) · · · (cid:14) E c
n.

Proposition 13. κ n

E is anti-extensive.

Proof. The proof follows directly from the deﬁnition. (cid:2)

As for its counterpart relaxation (ρk

E ), exhaustivity of κ n

E is not necessarily satisﬁed unless the exception set includes the 

⊥ concept, or the conjunction of some or all of its elements entails the ⊥ concept.

174

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

Consider again Example 2. We have κ 1

E (bird) = bird (cid:14) Tweetyc . The resulting revised knowledge base, if Condition 3 in Deﬁnition 7

is not considered, is then {Tweety (cid:12) bird, bird (cid:14) Tweetyc (cid:12) ﬂies, Tweety (cid:14) ﬂies (cid:12) ⊥} which is consistent.

Another possibility, suggested in [20] and related to operators deﬁned in propositional logic as introduced in [7], consists 
in  applying  the  retraction  at  the  atomic  level.  This  captures  somehow  Dalal’s  idea  of  revision  operators  in  propositional 
logic [10].

Deﬁnition 18.  Let  C be  an  ALC-concept  description  of  the  form  Q 1r1 · · · Q mrm.D,  where  Q i
is  a  quantiﬁer  and  D is 
quantiﬁer-free and in CNF form,8 i.e. D = E 1 (cid:14) E 2 (cid:14) · · · En with E i being disjunctions of possibly negated atomic concepts, i.e. 
E i = (cid:15)k∈(cid:14)(i) Ak, where (cid:14)(i) is the index set of the atomic (possibly negated) concepts  Ak forming  E i . We deﬁne, as in the 
p (D) = (cid:14)i∈{1...n}κ(E i). Then we set κDalal(C) = Q 1r1 · · · Q mrm.κp(D).
propositional case [7], κ(E i) = (cid:14)k∈(cid:14)(i) (cid:15) j∈(cid:14)(i)\{k} A j and κ n

Proposition 14. κ n

Dalal is a retraction.

Proof. Exhaustivity and anti-extensivity follow from those of κp . Indeed the operator κp is exhaustive and anti-extensive, 
and if applied n times it reaches the ⊥ concept (see [7] for properties of this operator). (cid:2)

This idea can be generalized to consider any retraction deﬁned in ELU .

Deﬁnition 19.  Let  C be  an  ALC-concept  description  of  the  form  Q 1r1 · · · Q mrm.D,  where  Q i
quantiﬁer-free.

Then we deﬁne κ∩(C) = Q 1r1 · · · Q mrm.κ n

E (D).

is  a  quantiﬁer  and  D is 

Proposition 15. κ n

∩ is anti-extensive.

Proof. The properties of this operator follows from the ones of κ n
exhaustivity. (cid:2)

E (D). Hence, anti-extensivity is veriﬁed but not necessarily 

Another possible ALC-concept description retraction is obtained by substituting the existential restriction by an univer-
sal one. This idea has been sketched in [20] for deﬁning dilation operators by transforming ∀ into ∃, i.e. special relaxation 
operators enjoying additional properties [14], and also used for deﬁning revision in FOL (see Section 4.3). We adapt it here, 
by transforming ∃ into ∀, to deﬁne retraction in DL syntax.

Deﬁnition 20. Let C be an ALC-concept description of the form  Q 1r1 · · · Q nrn.D, where  Q i is a quantiﬁer,  D is quantiﬁer-
free, then we deﬁne

κq(C) =(cid:14){Q

(cid:17)
1r1 · · · Q

(cid:17)
nrn.D | ∃ j ≤ n s.t. Q j = ∃ and Q

(cid:17)
j

= ∀, and for all i ≤ n s.t. i (cid:20)= j, Q

(cid:17)
i

= Q i}

Proposition 16. κq is anti-extensive.

Proof. See Appendix. (cid:2)

Note  that  for κq exhaustivity  can  be  obtained  by  further  removing  recursively  the  remaining  universal  quantiﬁers  and 

apply at the ﬁnal step any retraction deﬁned above on the concept D.

ALC-concept relaxations.  Let us now introduce some relaxation operators suited to ALC language.

Deﬁnition 21.  Let  C be  an  ALC-concept  description  of  the  form  Q 1r1 · · · Q mrm.D,  where  Q i
is  a  quantiﬁer  and  D is 
quantiﬁer-free and in DNF form, i.e.  D = E 1 (cid:15) E 2 (cid:15) · · · En with  E i being a conjunction of possibly negated atomic concepts, 
i.e.  E i = (cid:14)k∈(cid:14)(i) Ak, where (cid:14)(i) is the index set of the atomic (possibly negated) concepts  Ak forming  E i . We deﬁne ρ(E i) =
(cid:15)k∈(cid:14)(i) (cid:14) j∈(cid:14)(i)\{k} A j and ρn
p(D).

p(D) = (cid:15)i∈{1...n}ρ(E i), as in the propositional case [7], and then ρn

Dalal(C) = Q 1r1 · · · Q mrm.ρn

As for retraction, this idea can be generalized to consider any relaxation deﬁned in ELU .

Deﬁnition 22.  Let  C be  an  ALC-concept  description  of  the  form  Q 1r1 · · · Q nrn.D,  where  Q i
quantiﬁer-free, then we deﬁne ρn

∪(C) = Q 1r1 · · · Q nrn.ρn

E (D).

is  a  quantiﬁer  and  D is 

8 Any concept can indeed be written in this prenex form.

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

175

Let us consider another example adapted from the literature to illustrate these operators [29].

Example 4.  Let  us  consider  the  following  knowledge  bases:  T = {Bob (cid:12) ∀hasChild.rich, Bob (cid:12) ∃hasChild.Mary, Mary (cid:12)
(cid:17) = {Bob (cid:12) hasChild.John, John (cid:12) richc} (we  consider  here  individuals  as  concepts).  Relaxing  the  formula 
rich} and  T
Bob (cid:12) ∀hasChild.rich by  applying  ρn
∪ to  the  concept  on  the  right  hand  side  results  in  the  following  formula  Bob (cid:12)
∀hasChild.(rich (cid:15) John) which resolves the conﬂict between the two knowledge bases.

A last possibility, dual to the retraction operator given in Deﬁnition 20, consists in transforming universal quantiﬁers into 

existential ones (as done for relaxation in FOL in Section 4.3).

Deﬁnition 23.  Let  C be  an  ALC-concept  description  of  the  form  Q 1r1 · · · Q nrn.D,  where  Q i
quantiﬁer-free, then we deﬁne a relaxation as:

is  a  quantiﬁer  and  D is 

ρq(C) =(cid:15){Q

(cid:17)
1r1 · · · Q

(cid:17)
nrn.D | ∃ j ≤ n s.t. Q j = ∀ and Q

(cid:17)
j

= ∃, and for all i ≤ n s.t. i (cid:20)= j, Q

(cid:17)
i

= Q i}

If  we  consider  again  Example 4,  relaxing  the  formula  Bob (cid:12) ∀hasChild.rich by  applying  ρq to  the  concept  on  the  right 
hand side results in the following formula Bob (cid:12) ∃hasChild.rich, which resolves the conﬂict between the two knowledge 
bases.

Proposition 17. The operators ρDalal and ρq are extensive and exhaustive. The operator ρ∪ is extensive but not exhaustive.

Proof. The properties of ρDalal and ρ∪ are directly derived from the deﬁnitions and from properties of ρp detailed in [7]
and ρE . The proof of ρq being extensive and exhaustive can be found in [20]. (cid:2)

5.  Related work

Recently a ﬁrst generalization of AGM revision has been proposed in the framework of Tarskian logics considering mini-
mality criteria on removed formulas [34] following previous works of the same authors for contraction [35]. Representation 
results  that  make  a  correspondence  between  a  large  family  of  logics  containing  non-classical  logics  such  as DL and HCL
and AGM postulates for revision with such minimality criteria have then been obtained. Here, the proposed generalization 
also  gives  similar  representation  theorems  (cf.  Theorem 1)  but  for  a  different  minimality  criterion.  Indeed,  we  showed  in 
Section 3.2 that revision operators satisfying the weakened AGM postulates are precisely the ones that accomplish an up-
date  with  minimal  change  to  the  set  of  models  of  knowledge  bases,  generalizing  the  approach  developed  in [22] for  the 
logic PL and [30] for DL. However, our revision operator based on relaxation also has a minimality criterion on transformed 
formulas. Indeed, a simple consequence of Deﬁnition 7 is the property

(Relevance) Let T , T

(cid:17) ⊆ Sen be two knowledge bases such that T ◦ T
(cid:17)

(cid:17) = ρK(T ) ∪ T
(cid:17)
is inconsistent for K(cid:17) = K \ {kϕ} ∪ {k

(T ) ∪ T

ρK(cid:17)

. Then, for every ϕ ∈ T such that kϕ (cid:20)= 0, 
(cid:17)
ϕ

= 0}.

This  property  states  that  only  formulas  that  contribute  to  inconsistencies  with  T

are  allowed  to  be  transformed.  Our 
property (Relevance) is  similar  to  the  property  with  the  same  name  in [34,35],  but  for  contraction  operators,  and  that 
states that only the formulas that somehow “contribute” to derive the formulas to abandon can be removed.

(cid:17)

Since  the  primary  aim  of  this  paper  is  to  show  that  a  more  general  framework,  encompassing  different  logics,  can  be 
useful, it is out of the scope of this paper to provide an overview of all existing relaxation methods. However, some works 
deserve to be mentioned, since they are based on ideas that show some similarity with the relaxation notion proposed in 
our framework.

The relaxation idea originates from the work on Morpho-Logics, initially introduced in [7,8]. In this seminal work, revi-
sion operators (and explanatory relations) were deﬁned through dilation and erosion operators. These operators share some 
similarities with relaxation and retraction as deﬁned in this paper. Dilation is a sup-preserving operator and erosion is inf-
preserving, hence both are increasing. Some particular dilations and erosions are exhaustive and extensive while relaxation 
and retraction operators are deﬁned to be exhaustive and extensive but not necessarily sup- and inf-preserving. Dilation has 
been further exploited for merging ﬁrst-order theories in [20].

In [1], the notion of partial meet contraction is deﬁned as the intersection of a non-empty family of maximal subsets 
of  the  theory  that  do  not  imply  the  proposition  to  be  eliminated.  Revision  is  then  deﬁned  from  the  Levi  identity.  The 
maximal subsets can also be selected according to some choice function. The authors also deﬁne a notion of partial meet 
revision, which can be seen as a special case of the relaxation operator introduced in this paper. In [21], the author also 
discusses choice functions and compares the postulates for partial meet revision to the AGM postulates. He also highlights 
the  distinction  between  belief  sets  (which  can  be  very  large)  and  belief  bases  (which  are  not  necessarily  closed  by  Cn). 
More precisely,  A is a belief base of a belief set K iff K = Cn( A). A permissive belief revision is deﬁned in [9], based on the 

176

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

notion of weakening. The beliefs which are suppressed by classical revision methods are replaced by weaker forms, which 
keep the resulting belief set consistent. This notion of weakening is closed to the one of relaxation developed in this paper. 
In the last decade, several works have studied revision operators in description logics. While most of them concentrated on 
the adaptation of the AGM theory, few works have addressed the deﬁnition of concrete operators [25,27–29]. For instance, 
in [25], based on the seminal work in [5], revision in DL is studied by deﬁning strategies to manage inconsistencies and using 
the notion of knowledge integration (see also the work by Hansson). The authors propose a conjunctive maxi-adjustment, for 
stratiﬁed knowledge bases and lexicographic entailment. In [28], weakening operators, that are in fact relaxation operators, 
are  deﬁned.  Our  work  brings  a  principled  formal  ﬂavor  to  these  operators.  In [27],  revision  of  ontologies  in  DL  is  based 
on the notion of forgetting, which is also a way to manage inconsistencies. The authors propose a model based approach, 
inspired by Dalal’s revision in PL, and based on a distance between terminologies and on the difference set between two 
are  then  the  interpretations  I for  which  there  exists  an  interpretation 
interpretations.  The  models  of  the  revision  T ◦ T
I(cid:17)
.  In [24], 
updating Aboxes in DL is discussed, and some operators are introduced. The rationality of these operators is not discussed, 
hence  the  interest  of  a  formal  theory  such  as  the  AGM  postulates.  In [2] an  original  use  of  DL  revision  is  introduced  for 
the  orchestration  of  processes.  A  closely  related  ﬁeld  is  inconsistency  handling  in  ontologies  (e.g. [36,37]),  with  the  main 
difference that the rationality of inconsistency repairing operators is not investigated, as suggested by the AGM theory.

such  that  the  cardinality  of  the  difference  set  between  I and  I(cid:17)

is  equal  to  the  distance  between  T and  T

(cid:17)

(cid:17)

As previously highlighted, some of our DL-based relaxation operators are closely related to the ones introduced in [29]
for knowledge bases revision. Our relaxation-based revision framework, being abstract enough (i.e. deﬁned through easily 
satisﬁed properties), encompasses these operators. Moreover, the revision operator deﬁned in [29] considers only inconsis-
tencies due to Abox assertions. Our operators are general in the sense that Abox assertions are handled as any formula of 
the language.

6.  Conclusion

The contribution of this paper is threefold. First, we provided a generalization of AGM postulates, in a slightly weaker 
form  from  a  model-theoretic  point  of  view,  in  the  abstract  model  theory  of  satisfaction  systems,  so  as  they  become  ap-
plicable  to  a  wide  class  of  non-classical  logics.  In  this  framework,  we  then  generalized  to  any  satisfaction  systems  the 
characterization of the AGM postulates given by Katsuno and Mendelzon for propositional logic in terms of minimal change 
with respect to an ordering among interpretations. This work generalizes the previous ones in the area. It also suggests the 
theory  behind  satisfaction  systems  to  be  a  principled  framework  for  dealing  with  knowledge  dynamics  with  the  growing 
interest  on  non-classical  logics  such  as  DL.  We  do  hope  that  bridges  can  thus  be  built,  by  working  at  the  cross-road  of 
different areas of theoretical computer science.

Secondly, we proposed a general framework for deﬁning revision operators based on the notion of relaxation. We demon-
strated that such a relaxation-based framework for belief revision satisﬁes the weakened AGM postulates. As a byproduct, 
we give a principled formal ﬂavor to several operators deﬁned in the literature (e.g. weakening operators deﬁned in DL).

Thirdly, we introduced a number of concrete relaxations within the scope of description logics, discussed their properties 
and  illustrated  them  through  simple  examples.  It  was  out  of  the  scope  of  this  paper  to  discuss  languages  such  as  OWL. 
However,  the  proposed  approach  could  be  applied  to  SROIQ  and  implemented  in  OWL,  by  augmenting  a  relaxation  with 
operations on complex constructors.

Future  works  will  concern  the  study  of  the  complexity  of  the  introduced  operators,  the  comparison  of  their  induced 
ordering, and their generalization to more expressive DL as well as other non-classical logics such as ﬁrst-order Horn logics 
or equational logics.

Finally, there is an extension of satisfaction systems that takes into account explicitly the notion of signatures, the theory 
of institutions [19], a categorical model theory which has emerged in computing science studies of software speciﬁcations 
and semantics. In this paper, as we have considered logical theories over a same signature, signature morphisms and their 
interpretation for model classes and sentence sets were not relevant. However, these results carry over to institutions, which 
are indexed satisfaction systems.

Appendix.  Proofs of the main results

Proof of Proposition 3. Let us suppose that Cn(T

(cid:17)
1) = Cn(T

(cid:17)
2). Here, three cases have to be considered:

(1) One of  T

(2) Both  T ∪ T

(cid:17)
1 and  T

(cid:17)
2 is inconsistent (say  T

(cid:17)
(cid:17)
1) = Cn(T
1 without loss of generality). Since  Cn(T
(cid:17)
(cid:17)
i ) ⊆ Mod(T
i ), and Mod(T

(cid:17)
2) by hypothesis,  T

(cid:17)
2 is also 
(cid:17)
i ) = T ri v (Corollary 1). 

inconsistent. By Postulate (G2), we then have that, for i = 1, 2, Mod(T ◦ T
Hence Mod(T ◦ T

(cid:17)
i ) ⊆ T ri v, and Mod(T ◦ T
(cid:17)
(cid:17)
1 and  T ∪ T
1 are consistent. Since  Cn(T
(cid:17)
1) = Mod(T ∪ T
then Mod(T ∪ T
(cid:17)
(cid:17)
(cid:17)
(cid:17)
2 is  not  (say  T ∪ T
1 or  T ∪ T
2 are  consistent  but  T ∪ T
1 and  T
(cid:17)
also  inconsistent.  By  Postulate  (G1),  both  T ◦ T
1 and  T ◦ T
obviously  M ∈ Mod(T ◦ T
(cid:17)
M ∈ Mod(T

(cid:17)
1) = Mod(T ◦ T

2).  Let  M(cid:17) ∈ Mod(T ◦ T

(cid:17)
2) \ T ri v.  Such  a  model  exists  as  T ◦ T

(cid:17)
1) = Mod(T
(cid:17)
2). Therefore, by Postulate (G3), we have that Mod(T ◦ T

(cid:17)
1) = Cn(T

(cid:17)
2) = T ri v.
(cid:17)
2), we know that  Mod(T

(cid:17)
2 are  consistent.  Let M ∈ Mod(T ◦ T

(cid:17)
1) = Cn(T

(cid:17)
1) = Mod(T ◦ T

(cid:17)
2).
(cid:17)
2),  we  derive  that  T ∪ T

(cid:17)
2 is 
(cid:17)
1).  If M ∈ T ri v,  then 
(cid:17)
1),  and  then 
(cid:17)
2 is  consistent.  By  Postulate  (G2)  and  the 

(cid:17)
2).  Therefore,  let  us  suppose  that  M /∈ T ri v.  By  Postulate  (G2),  M ∈ Mod(T

(cid:17)
2) (Equation (1)), and 

(cid:17)
1).  From  Cn(T

(3) T

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

177

(cid:17)

(cid:17)
(cid:17)
(cid:17)
(cid:17)
1) = Cn(T
2. Obviously, we have that (T ◦ T
1 and T
are consistent. Therefore, by Postulates (G5) and (G6), we have that Mod((T ◦ T

2), {M, M(cid:17)}∗
∪ {M, M(cid:17)}∗) = Mod(T ◦ {M, M(cid:17)}∗) and Mod((T ◦ T

hypothesis that Cn(T
(cid:17)
2) ∪ {M, M(cid:17)}∗
(T ◦ T
Mod((T ◦ (T
{M, M(cid:17)}∗). We can then derive that Mod((T ◦ T
(cid:17)
Mod(T ◦ T
2). Similarly, by reversing the roles of T

contains both T

(cid:17)
1

(cid:17)
1) ∪ {M, M(cid:17)}∗) = Mod((T ◦ T
(cid:17)
1 and T

(cid:17)
2, if M ∈ Mod(T ◦ T

1) ∪ {M, M(cid:17)}∗
and 
1) ∪ {M, M(cid:17)}∗) =
∪ {M, M(cid:17)}∗) = Mod(T ◦
2) ∪ {M, M(cid:17)}∗), and conclude that M ∈
(cid:17)
1).

(cid:17)
2), we can conclude that M ∈ Mod(T ◦ T

(cid:17)
2

(cid:17)

(cid:17)

(cid:17)

2) ∪ {M, M(cid:17)}∗) = Mod((T ◦ (T

Proof of Theorem 1.

(1) Let  us  suppose  that  ◦ satisﬁes  AGM  Postulates.  For  every  knowledge  base  T ,  let  us  deﬁne  the  binary  relation  (cid:24)T ⊆

Mod × Mod by: for all M, M(cid:17) ∈ Mod,

(cid:5)

M (cid:24)T M(cid:17)

iff

either M ∈ Mod(T )
or M ∈ Mod(T ◦ {M, M(cid:17)}∗) and M(cid:17) /∈T ri v

Let us ﬁrst show that (cid:24)T satisﬁes the two conditions of FA.
• The ﬁrst condition easily follows from the deﬁnition of (cid:24)T .
• To prove the second one, let us assume that M ∈ Mod(T ) and M(cid:17) /∈ Mod(T ). Since M ∈ Mod(T ), we have M (cid:24)T M(cid:17)

. 

is consistent since M ∈ Mod(T ) \ T ri v and M ∈ Mod(M∗) ⊆ Mod({M, M(cid:17)}∗). 
.  Therefore,  we  have  that  M(cid:17) /∈Mod(T ◦

Here two cases have to be considered:
(a) M ∈ T ri v. In this case, we directly have by deﬁnition that M(cid:17) (cid:2)T M.
(b) M /∈ T ri v. Then  T ∪ {M, M(cid:17)}∗

Hence M ≺T M(cid:17)

Then  by  Postulate  (G3),  we  have  that  T ◦ {M, M(cid:17)}∗ = T ∪ {M, M(cid:17)}∗
{M, M(cid:17)}∗), and M(cid:17) (cid:2)T M.
in both cases.
Let us now prove the three supplementary conditions.
• First, let us show that  Mod(T ◦ T
T ri v = ∅, and by (G2) Mod(T ◦ T
Let us assume now that T
· Let us ﬁrst show that  Mod(T ◦ T

(cid:17)) \ T ri v, (cid:24)T ). If T
(cid:17)) ⊆ T ri v, hence Mod(T ◦ T

(cid:17)) = Min(Mod(T
(cid:17)) ⊆ Mod(T

is consistent.

(cid:17)) \ T ri v ⊆ Min(Mod(T
(cid:17)) \ T ri v, (cid:24)T ). By (G2), M ∈ Mod(T

that M /∈ Min(Mod(T
such that M(cid:17) ≺T M. Here, two cases have to be considered:
(a) M(cid:17) ∈ Mod(T ).  As  M(cid:17) ∈ Mod(T

(cid:17)) \ T ri v,  then  T ∪ T

(cid:17)

(cid:17)

(cid:17)

M ∈ Mod(T ), and then M (cid:24)T M(cid:17)

, which is a contradiction.

is inconsistent, then by Proposition 2 Mod(T

(cid:17)) \ T ri v = ∅ = Min(Mod(T

(cid:17)) \ T ri v, (cid:24)T ).

(cid:17)) \

(cid:17)) \ T ri v, (cid:24)T ). Let M ∈ Mod(T ◦ T
(cid:17)) \ T ri v. By hypothesis, there exists M(cid:17) ∈ Mod(T

(cid:17)) \ T ri v. Let us assume 
(cid:17)) \ T ri v

is  consistent,  and  then  by  (G3),  T ◦ T

(cid:17) = T ∪ T

(cid:17)

.  Thus, 

(b) M(cid:17) /∈ Mod(T ).  By  deﬁnition  of  (cid:24)T ,  this  means  that  M(cid:17) ∈ Mod(T ◦ {M, M(cid:17)}∗).  As  M, M(cid:17) ∈ Mod(T

Postulate  (G2),  (T ◦ T
Mod(T ◦ {M, M(cid:17)}∗) = Mod((T ◦ T
M /∈ Mod(T ◦ {M, M(cid:17)}∗),  whence  by  Postulate  (G6)  we  have  that  M /∈ Mod(T ◦ T
tradiction.

(cid:17)),  by 
is  consistent,  and  then  by  Postulates  (G5)  and  (G6),  we  have  that 
(cid:17)) ∪ {M, M(cid:17)}∗).  By  the  hypothesis  that  M(cid:17) ≺T M,  we  can  deduce  that 
(cid:17)) \ T ri v,  which  is  a  con-

(cid:17)) ∪ {M, M(cid:17)}∗

· Let  us  now  show  that  Min(Mod(T

(cid:17)) \ T ri v, (cid:24)T ), and then Mod(T ◦ T

Finally we can conclude that M ∈ Min(Mod(T

(cid:17)) \ T ri v. As T
(cid:17)
assume that M /∈ Mod(T ◦ T
such  that  M(cid:17)∗ (cid:20)= Sen,  and  M(cid:17) ∈ Mod(T
Mod({M, M(cid:17)}∗). By Postulates (G5) and (G6), we can write Mod(T ◦ T
since (T ◦ T
diction. We can conclude that M ∈ Mod(T ◦ T

(cid:17)) \ T ri v, (cid:24)T ).
(cid:17)) \ T ri v, (cid:24)T ).  Let  us 
(cid:17))
(cid:17) ∪ {M, M(cid:17)}∗) =
(cid:17)) ∩ Mod({M, M(cid:17)}∗) = Mod(T ◦ {M, M(cid:17)}∗), 
is consistent. Hence, M /∈ Mod(T ◦ {M, M(cid:17)}∗), and then M(cid:17) ≺T M, which is a contra-

(cid:17)) \ T ri v.  Let  M ∈ Min(Mod(T
is consistent, by Postulates (G1) and (G2), there exists M(cid:17) ∈ Mod(T ◦ T
(cid:17)).  Since  T

(cid:17)) \ T ri v, (cid:24)T ) ⊆ Mod(T ◦ T

,  we  also  have  that  Mod(T

(cid:17)) \ T ri v ⊆ Min(Mod(T

(cid:17)) \ T ri v, (cid:24)T ) ⊆ Mod(T ◦ T

(cid:17)) ∪ {M, M(cid:17)}∗

(cid:17) ⊆ {M, M(cid:17)}∗

(cid:17)) \ T ri v.

(cid:17)) \ T ri v, and then Min(Mod(T
(cid:17)

(cid:17)) \ T ri v, (cid:24)T ) (cid:20)= ∅ if  T

(cid:17)) \ T ri v (cid:20)= ∅. We can directly conclude by the previous point that  Min(Mod(T

(cid:17)
is  consistent.  By  Postulate  (G1),  we  have  that  T ◦ T
(cid:17)) \

• Secondly,  let  us  show  that  Min(Mod(T

is consistent, and then  Mod(T ◦ T
T ri v, (cid:24)T ) (cid:20)= ∅.

• Finally, let us show that for every T

(cid:17)) ∪ T

if (T ◦ T
the ﬁrst point, we can directly conclude that Min(Mod(T

is consistent. By (G5) and (G6), we have that  Mod(T ◦ (T

(cid:17) ∪ T
(cid:17)) \ T ri v, (cid:24)T ) ∩ Mod(T

(cid:17)(cid:17))) = Mod((T ◦ T
(cid:17)(cid:17)) = Min(Mod(T

(cid:17)) ∪ T
(cid:17) ∪ T

(cid:17)(cid:17)

(cid:17), T

(cid:17)(cid:17) ⊆ Sen, Min(Mod(T

(cid:17)) \ T ri v, (cid:24)T ) ∩ Mod(T

(cid:17)(cid:17)) = Min(Mod(T

(cid:17) ∪ T

(cid:17)(cid:17)) \ T ri v, (cid:24)T )
(cid:17)(cid:17)). Therefore, by 
(cid:17)(cid:17)) \ T ri v, (cid:24)T ).

(2) Let  us  now  suppose  that  for  a  revision  operation  ◦ there  exists  a  FA  which  maps  any  knowledge  base  T ⊆ Sen to  a 
binary  relation  (cid:24)T ⊆ Mod × Mod satisfying  the  three  conditions  of  Theorem 1.  Let  us  prove  that  ◦ veriﬁes  the  AGM 
Postulates.
(G1) This postulate directly results from the fact that Min(Mod(T

is consistent, hence Mod(T ◦

(cid:17)) \ T ri v, (cid:24)T ) (cid:20)= ∅ when T

(cid:17)

(cid:17)).  If  M ∈ T ri v,  then  obviously  M ∈ Mod(T

(cid:17)).  Now,  if  M /∈ T ri v,  then  by  deﬁnition,  M ∈

T

(cid:17)) \ T ri v (cid:20)= ∅.
(G2) Let  M ∈ Mod(T ◦ T

Min(Mod(T
(G3) Suppose that T ∪ T

(cid:17)

(cid:17)) \ T ri v, (cid:24)T ). This means that M ∈ Mod(T

(cid:17)).

is consistent (hence Mod(T ∪ T

(cid:17)) \ T ri v (cid:20)= ∅).

• Let us ﬁrst prove that Mod(T ◦ T

(cid:17)) ⊆ Mod(T ∪ T

(a) M ∈ T ri v. In this case, we obviously have that M ∈ Mod(T ∪ T

(cid:17)). Let M ∈ Mod(T ◦ T
(cid:17)).

(cid:17)). Here two cases have to be considered:

178

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

(b) M /∈ T ri v.  By  deﬁnition,  M ∈ Min(Mod(T

(cid:17)).  Let  us  sup-
pose now that M /∈Mod(T ). As  T is consistent,  Mod(T ) \ T ri v (cid:20)= ∅ by Proposition 2. Therefore, there exists 
M(cid:17) ∈ Mod(T ) \ T ri v such that M(cid:17) ≺T M (from M /∈ Mod(T ) and the second property of FA), which is a 
contradiction. Hence M ∈ Mod(T ) and M ∈ Mod(T ∪ T

(cid:17)) \ T ri v, (cid:24)T ).  Hence,  we  have  that  M ∈ Mod(T

• Let us now prove that  Mod(T ∪ T

(cid:17)). Therefore, 
M ∈ Mod(T ). By hypothesis, there exists M(cid:17) ∈ Mod(T
(cid:17)) \
T ri v, (cid:24)T )), and then M(cid:17) /∈Mod(T ) by the ﬁrst condition of FA. However, by the second condition of FA, we have 
that M ≺T M(cid:17)

(cid:17)) \ T ri v such that M(cid:17) ≺T M (since M /∈ Min(Mod(T

(cid:17)) such that M /∈Mod(T ◦ T

, which is a contradiction.

(cid:17)) ⊆ Mod(T ◦ T

(cid:17)).
(cid:17)). Let M ∈ Mod(T ∪ T

Finally, we can conclude that Mod(T ◦ T

(G5) Let M ∈ Mod(T ◦ T

(cid:17)) ∩ Mod(T
or  there  exists  M(cid:17) ∈ Mod(T
that  M ∈ Mod(T ◦ (T
M ∈ Min(Mod(T

(cid:17) ∪ T

(G6) Let us suppose that (T ◦ T

(cid:17)) = Mod(T ∪ T
(cid:17)(cid:17)). Let us assume that M /∈Min(Mod(T
(cid:17) ∪ T

(cid:17)(cid:17)) \ T ri v, (cid:24)T ). This means that M ∈ T ri v
(cid:17)(cid:17)) such  that  M(cid:17)∗ (cid:20)= Sen and  M(cid:17) ≺T M.  In  the  ﬁrst  case,  we  obviously  have 
(cid:17)),  and  then  M(cid:17)⊀T M since 

(cid:17)(cid:17))).  In  the  second  case,  we  then  have  that  M(cid:17) ∈ Mod(T

(cid:17) ∪ T

(cid:17)).

(cid:17)) \ T ri v, (cid:24)T ), which is a contradiction.

(cid:17)) ∪ T

(cid:17)(cid:17)

is consistent. Let M ∈ Mod(T ◦ (T

this case, obviously we have that M ∈ Mod((T ◦ T
(cid:17)(cid:17)))\T ri v = Min(Mod(T
T
(cid:24)T ) = Min(Mod(T

(cid:17)) \ T ri v, (cid:24)T ) ∩ Mod(T

(cid:17)(cid:17)) \ T ri v, (cid:24)T ). As (T ◦ T

(cid:17)) ∪ T
(cid:17)(cid:17)) and then M ∈ Mod((T ◦ T

(cid:17) ∪ T

(cid:17)(cid:17)

(cid:17)) ∪ T

(cid:17)) ∪ T

(cid:17)(cid:17)).

(cid:17) ∪ T

(cid:17)(cid:17)), or M ∈ Min(Mod(T

(cid:17) ∪ T
is consistent, we have that Min(Mod(T

(cid:17)(cid:17))). By hypothesis, either M ∈ T ri v and in 
(cid:17) ∪
(cid:17)(cid:17)) \ T ri v,

(cid:17)(cid:17)) \ T ri v, (cid:24)T ) as Mod(T ◦ (T

(cid:17) ∪ T

Proof of Theorem 2. First, let us show that  f

is a FA.

Mod(T
T ◦ T

• Let  M, M(cid:17) ∈ Mod(T ).  Let  us  suppose  that  M ≺T M(cid:17)

(cid:17)), M ∈ Mod(T ◦ T

(cid:17)) and M(cid:17) /∈ Mod(T ◦ T

(cid:17)

(cid:17) = T ∪ T

. We then have that M(cid:17) ∈ Mod(T ◦ T
• Let M ∈ Mod(T ) and let M(cid:17) ∈ Mod \ Mod(T ). We have that M (cid:24)∅
let us suppose that M(cid:17) (cid:24)T M. This means that there exists  T
(cid:17)). But, as M ∈ Mod(T ), we have that T ∪ T
(cid:17)
and M /∈ Mod(T ◦ T
(cid:17)) which is a contradiction.
Hence, we have that M ∈ Mod(T ◦ T

(cid:17)). Hence we have that T ∪ T

(cid:17)
(cid:17)) which is a contradiction.

.  This  means  that  there  exists  T

(cid:17) ⊆ Sen such  that  M, M(cid:17) ∈
is consistent, and then by Postulate (G3), 

T

M(cid:17)

, and then M (cid:24)T M(cid:17)

(cid:17) ⊆ Sen such that M, M(cid:17) ∈ Mod(T
is consistent, and then by Postulate (G3), T ◦ T

by deﬁnition of (cid:24)T . Now, 
(cid:17))
(cid:17)), M(cid:17) ∈ Mod(T ◦ T
(cid:17)
(cid:17) = T ∪ T
. 

Let us show now the supplementary conditions of Theorem 1.

• First, let us show that Mod(T ◦ T

(cid:17)) \ T ri v = Min(Mod(T

(cid:17)) \ T ri v, (cid:24)T ). The case where T

(cid:17)

is inconsistent follows the same 

(cid:17)(cid:17)), M(cid:17) ∈ Mod(T ◦ T

is consistent. Let M ∈ Mod(T ◦ T

proof as in Theorem 1.
(cid:17)
Let us suppose that  T
This  means  that  there  exists  M(cid:17) ∈ Mod(T
M, M(cid:17) ∈ Mod(T
and then by Postulates (G5) and (G6), Mod((T ◦ T
(cid:17)(cid:17)) which is a contradiction.
that M ∈ Mod(T ◦ T
(cid:17)) \ T ri v, (cid:24)T ). Let us suppose that M /∈ Mod(T ◦ T
Let M ∈ Min(Mod(T
and  (G2),  there  exists M(cid:17) ∈ Mod(T ◦ T
which is a contradiction.

(cid:17)) \ T ri v.  By  deﬁnition  of  (cid:24)T

(cid:17)(cid:17)) and M /∈ Mod(T ◦ T

(cid:17)(cid:17)) = Mod((T ◦ T

(cid:17)) ∪ T

(cid:17)

• The proof of the two other conditions corresponds to the one given in Theorem 1.

(cid:17)) \ T ri v. Let us suppose that M /∈ Min(Mod(T

(cid:17)) \ T ri v such  that  M(cid:17) ≺T M.  Therefore,  there  exists  T

(cid:17)(cid:17)). Hence, both (T ◦ T

(cid:17)(cid:17)

(cid:17)) ∪ T
(cid:17)) = Mod(T ◦ (T

and (T ◦ T
(cid:17) ∪ T

(cid:17)(cid:17)) ∪ T

(cid:17)) \ T ri v, (cid:24)T ). 
(cid:17)(cid:17) ⊆ Sen such  that 
are consistent, 
(cid:17)(cid:17))). We can then derive 

(cid:17)(cid:17)) ∪ T

(cid:17)

(cid:17)) \ T ri v. As  T
T ,  we  have  that M(cid:17) (cid:24)T

is consistent, by Postulates (G1) 
M,  and  then M(cid:17) (cid:24)T M

T

(cid:17)

(cid:17)

Proof of Proposition 4. It is suﬃcient to show that (cid:24)1
T
all the conditions of Theorem 1.

∪ (cid:24)2

T and (cid:24)1

T

∩ (cid:24)2

T satisfy Conditions (1) and (2) of Deﬁnition 4 plus 

Let us ﬁrst show that they are FA. Let T ⊆ Sen. Let M, M(cid:17) ∈ Mod(T ). By deﬁnition of FA, then we have either M(cid:2)i
T

M(cid:17)
M for i = 1, 2. We then have four cases to consider, but for  f 1 (cid:14) f 2(T ) =(cid:24)T (resp. 
and M(cid:17) (cid:24)T M.  Likewise,  for  every 
for i = 1, 2. Therefore, it is obvious to conclude that 

and M(cid:17)(cid:2)T M or M (cid:24)T M(cid:17)

M(cid:17)

M(cid:17)

M or M (cid:24)i
T

and M(cid:17)(cid:2)i
T
f 1 (cid:15) f 2(T ) =(cid:24)T ),  we  always  end  up  at  either M(cid:2)T M(cid:17)
M ∈ Mod(T ) and every M(cid:17) ∈ Mod \ Mod(T ), we have that M ≺i
T
M ≺T M(cid:17)

and M(cid:17) (cid:24)i
T

.

Now, by the ﬁrst supplementary condition for (cid:24)1
T ) = Mod(T ◦ T

T ri v, (cid:24)1
Min(Mod(T
forward, and this allows us to directly conclude that  f 1 (cid:15) f 2 and  f 1 (cid:14) f 2 are FA+.

T ) = Min(Mod(T
(cid:17)) \ T ri v, (cid:24)1
T

T and (cid:24)2
T in Theorem 1, we have for every T
(cid:17)) \ T ri v.  Hence,  we  can  write  that  Min(Mod(T

(cid:17)) \
T ) =
T ) for i = 1, 2. The three supplementary conditions are then straight-

(cid:17) ⊆ Sen that Min(Mod(T
(cid:17)) \ T ri v, (cid:24)1
∪ (cid:24)2
T

(cid:17)) \ T ri v, (cid:24)2
∩ (cid:24)2

T ) = Min(Mod(T

(cid:17)) \ T ri v, (cid:24)i

Proof of Theorem 3. ◦ obviously satisﬁes Postulates (G1), (G2) and (G3). To prove (G5)–(G6), let us suppose  T , T
such that (T ◦ T
is  consistent.  Now,  obviously  we  have  that  Mod(T
Deﬁnition 7, we necessarily have that T ◦ (T

(cid:17)(cid:17) ⊆ Sen
(cid:17)(cid:17)
(cid:17) ∪ T
(cid:17)).  Hence,  by  the  second  and  the  third  conditions  of 
(cid:17)(cid:17))).
(cid:17)) ∪ T
(cid:17)(cid:17)

is consistent (the case where (T ◦ T
(cid:17) ∪ T
(cid:17)(cid:17)) = ρKT

is inconsistent is obvious). This means that ρKT

(cid:17)) ∪ T
(cid:17)(cid:17)
(cid:17)(cid:17)) ⊆ Mod(T
(cid:17) ∪ T
T (T ) ∪ T

, and then Mod((T ◦ T

(cid:17), T
T (T ) ∪ T

(cid:17)(cid:17)) = Mod(T ◦ (T

(cid:17)) ∪ T

(cid:17) ∪ T

(cid:17) ∪ T

(cid:17)(cid:17)

(cid:17)

(cid:17)

Proof of Theorem 4. Let T ⊆ Sen. Let us ﬁrst show that  fρ (T ) = (cid:24)T is faithful.

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

179

• Obviously,  we  have  for  every  M, M(cid:17) ∈ Mod(T ) and  every  T

(cid:17) ⊆ Sen that  both  M(cid:2)T
T

(cid:17)

M(cid:17)

and  M(cid:17)(cid:2)T
T

(cid:17)

M.  Hence  the 

same relations hold for (cid:24)T .

• Let M ∈ Mod(T ) and  let M(cid:17) ∈ Mod \ Mod(T ).  Obviously,  we  have  that M (cid:24)∅

M(cid:17)

.  Let  T

T

(cid:17)) (the case where for all  T

(cid:17) ⊆ Sen M or M(cid:17)
Mod(T
(cid:17)
T , and then we directly have that M(cid:17)(cid:2)T M). Here two cases have to be considered:
(cid:24)T
(1) M ∈ T ri v.  As  M(cid:17) /∈Mod(T ),  then  M(cid:17) /∈T ri v.  Hence,  there  does  not  exist  K(cid:17) < K such  that  M(cid:17) ∈ Mod(ρK(cid:17)
(cid:17)
.

would be consistent, which would contradict the hypothesis that T ◦ T

(cid:17)) implies that M and M(cid:17)

Otherwise, ρK(cid:17)

(cid:17) = ρK(T ) ∪ T

is not in  Mod(T

(cid:17)

(cid:17) ⊆ Sen such  that M, M(cid:17) ∈
are incomparable by 

(T )). 

(cid:17)) but M(cid:17) /∈Mod(T ∪ T

(cid:17)), and then M(cid:17)(cid:2)T
T

(cid:17)

M By deﬁnition of ◦.

(T ) ∪ T
(2) M /∈T ri v. We have that M ∈ Mod(T ∪ T
Hence, in both cases we can conclude that M(cid:17)(cid:2)T M.

Let us prove that  Mod(T ◦ T
when T
T ri v, (cid:24)T ) (cid:20)= ∅ if Mod(T ◦ T

(cid:17)

(cid:17)
is consistent. Indeed, by deﬁnition, we have that T ◦ T
(cid:17)) \ T ri v, (cid:24)T ).
by deﬁnition. Hence, Mod(T ◦ T

(cid:17)) \ T ri v = Min(Mod(T
(cid:17)

is inconsistent, then so is T ◦ T

(cid:17)

If T
Let us now suppose that T

(cid:17)

is consistent.

(cid:17)) \ T ri v = Min(Mod(T

(cid:17)) \ T ri v, (cid:24)T ). This will directly prove that  Min(Mod(T

is consistent when T

is consistent, and then Min(Mod(T

(cid:17)

(cid:17)) \ T ri v, (cid:24)T ) (cid:20)= ∅
(cid:17)) \

(cid:17)) \ T ri v = Min(Mod(T

(cid:17)) \ T ri v, (cid:24)T ) = ∅.

• Let us show that Mod(T ◦ T

(cid:17)) \ T ri v ⊆ Min(Mod(T

(cid:17)) \ T ri v, (cid:24)T ). Let M ∈ Mod(T ◦ T

(cid:17)) \ T ri v. Let M(cid:17) ∈ Mod(T

(cid:17)) \ T ri v. 

Two cases have to be considered:
(1) M(cid:17) ∈ Mod(T ◦ T

(cid:17)(cid:17) = T ◦ (T

(cid:17)(cid:17) ⊆ Sen such  that M, M(cid:17) ∈ Mod(T
T
pothesis, we then have that (T ◦ T
(cid:17)) ∪ T
that  (T ◦ T
(cid:17)(cid:17)) ⊆ Mod(T
(cid:17) ∪ T
Mod(T
deduce that there exists K(cid:17)(cid:17) < KT
then by Condition 2 of Deﬁnition 7, 
(cid:17)). By deﬁnition of (cid:24)T

(cid:17)

(cid:17)

(2) M(cid:17) /∈Mod(T ◦ T
Finally, we can conclude that M ∈ Min(Mod(T

(cid:17)

(cid:17)

(cid:17)). Obviously, we have both M(cid:2)T
T

M(cid:17)

and M(cid:17)(cid:2)T
T

(cid:17)) ∪ T

(cid:17)(cid:17)).  Let  us  suppose  that  there  exists  T

M. Let us show that this is also true for every 
M.  By  hy-
is consistent. Therefore, by Conditions 2 and 3 of Deﬁnition 7, we have 
(cid:17)(cid:17)) = ρKT
.  Consequently,  as 
M, we can 
≤ KT
is consistent, and 

(T )). We then have that ρK(cid:17)(cid:17)

(cid:17)(cid:17) ⊆ Sen such  that M(cid:17) (cid:24)T
T

T . Therefore, as M(cid:17) (cid:24)T

(cid:17)(cid:17)).  Hence,  we  also  have  that  T ◦ (T

(cid:17) ∪ T
(cid:17)(cid:17)), we have by Condition 3 of Deﬁnition 7 that KT
T
T such that M(cid:17) ∈ Mod(ρK(cid:17)(cid:17)
(cid:4)

T (T ) ∪ T

(T ) ∪ T

(cid:17) ∪ T

(cid:17) ∪ T

(cid:4)

(cid:17)(cid:17)

(cid:17)(cid:17)

T

(cid:17)(cid:17)

(cid:17)(cid:17)

(cid:17)(cid:17)

(cid:17)

(cid:17)

(cid:17)

(cid:17)

KT
T

≤

K(cid:17)(cid:17)

, which is a contradiction.

(cid:17)

M(cid:17)

, and therefore M (cid:24)T M(cid:17)

.

T , we have that M (cid:24)T

T

(cid:17)) \ T ri v, (cid:24)T ).
(cid:17)) \ T ri v, (cid:24)T ) ⊆ Mod(T ◦ T
(cid:17)

is  consistent,  then  so  is  T ◦ T

• Let us now show that Min(Mod(T
(cid:17)) \ T ri v.  As  T

(cid:17)) \ T ri v. Let M ∈ Min(Mod(T

(cid:17)

.  Hence,  there  exists  M(cid:17) ∈ Mod(T ◦ T

(cid:17)) \ Mod(T ◦ T

(cid:17)),  we  have  that M(cid:17) (cid:24)T
T

(cid:17)

M,  and  then  as M ∈ Min(Mod(T

.  This  means  that  there  exists  T
(cid:17)(cid:17)

(cid:17)) ∪ T

(cid:17)(cid:17) ⊆ Sen such  that  M, M(cid:17) ∈ Mod(T

(cid:17)(cid:17)) and  M (cid:24)T
T

is consistent. Therefore, by Conditions 2 and 3 of Deﬁnition 7, we have that (T ◦ T

(cid:17)(cid:17)).  Hence,  we  also  have  that  T ◦ (T

(cid:17) ∪ T

(cid:17)(cid:17)) = ρKT

≤ KT
(cid:17)

T . Hence, there exists K(cid:17)(cid:17) ≥ KT
T
is consistent, and then by Condition 2 of Deﬁnition 7 we have that 

(cid:17)

.  Consequently,  we  have  by  Condition  3  of 
T and M ∈ Mod(ρK(cid:17)(cid:17)
(T )). We can then 
(cid:4)
≤
, which is a 

K(cid:17)(cid:17)

(cid:4)

(cid:17)

(cid:17) ∪ T

T (T ) ∪ T
such that K(cid:17)(cid:17) < KT

(cid:17)(cid:17)

(cid:17)(cid:17)

(cid:17)

KT
T

(cid:17)

(cid:17)) \ T ri v, (cid:24)T ). Let us suppose 
(cid:17)) \ T ri v.  As 
(cid:17)) \ T ri v, (cid:24)T ) we  also  have  that 
.  By  hypothesis,  we 
(cid:17)(cid:17) =

M(cid:17)

(cid:17)(cid:17)

(cid:17)) ∪ T

that  M /∈Mod(T ◦ T
M ∈ Mod(T
M (cid:24)T M(cid:17)
then have that (T ◦ T
T ◦ (T
Deﬁnition 7 that KT
T
deduce that ρK(cid:17)(cid:17)
(T ) ∪ T
contradiction.

(cid:17) ∪ T

(cid:17)(cid:17)

Finally, to prove the last point, we follow the same steps as in the proof of Theorem 1.

Proof of Proposition 15. The proof relies on the following general result:

∀C, ∀r, ∀r.C (cid:12) ∃r.C

Indeed, for each interpretation I, if r

I
i

(cid:20)= ∅, we have

x ∈ (∀r.C)I ⇒ (∀ y, (x, y) ∈ r

I ) ⇒ (∃ y, (x, y) ∈ r

I

and y ∈ C

I ) ⇒ x ∈ (∃r.C)I .

Hence (∀r.C)I ⊆ (∃r.C)I

for each I (if r

= ∅ it is obvious), and ∀r.C (cid:12) ∃r.C .

In a similar way, we can show, that for any C1, C2, r, and  Q ∈ {∃, ∀}:

I ⇒ y ∈ C
I
i

C1 (cid:12) C2 ⇒ Q r.C1 (cid:12) Q r.C2.

Now, let us consider any  j such that  Q j = ∃, and set  C

(cid:17) = Q j+1r j+1...Q nrn.D. We have from the ﬁrst result  Q

Q jr j.C

. Applying the second result recursively on each  Q i for i < j, we then have

(cid:17)

(cid:17)
jr j.C

(cid:17) (cid:12)

Q 1r1...Q j−1r j−1 Q

(cid:17)
jr j.C

(cid:17) (cid:12) Q 1r1...Q j−1r j−1 Q jr j.C

(cid:17)

.

The same relation holds for the conjunction over any  j such that  Q j = ∃, from which we conclude that ∀C, κq(C) (cid:12) C , i.e. 
κq is anti-extensive.

180

M. Aiguier et al. / Artiﬁcial Intelligence 256 (2018) 160–180

References

Logics, 2013, pp. 501–512.

(2004) 339–371.

Verlag, 2007, pp. 857–947.

[1] C. Alchourron, P. Gardenfors, D. Makinson, On the logic of theory change, J. Symb. Log. 50 (2) (1985) 510–530.
[2] S. Autexier, D. Hutter, Constructive DL update and reasoning for modeling and executing the orchestration of heterogeneous processes, in: Description 

[3] F. Baader, R. Küsters, R. Molitor, Computing least common subsumers in description logics with existential restrictions, in: International Joint Conference 

on Artiﬁcial Intelligence, IJCAI’99, Morgan-Kaufmann, 1999, pp. 96–101.

[4] J. Barwise, Axioms for abstract model theory, Ann. Math. Log. 7 (1974) 221–265.
[5] S. Benferhat, S. Kaci, D. Le Berre, M.-A. Williams, Weakening conﬂicting information for iterated revision and knowledge integration, Artif. Intell. 153 (1) 

[6] I. Bloch, H. Heijmans, C. Ronse, Mathematical morphology, in: M. Aiello, I. Pratt-Hartman, J. van Benthem (Eds.), Handbook of Spatial Logics, Springer-

[7] I. Bloch, J. Lang, Towards mathematical morpho-logics, in: B. Bouchon-Meunier, J. Gutierrez-Rios, L. Magdalena, R. Yager (Eds.), Technologies for Con-

[8] I. Bloch, R. Pino-Pérez, C. Uzcategui, A uniﬁed treatment of knowledge dynamics, in: International Conference on Principles of Knowledge Representa-

structing Intelligent Systems, Springer-Verlag, 2002, pp. 367–380.

tion and Reasoning, KR, AAAI Press, 2004, pp. 329–337.

[9] M.R. Cravo, J.P. Cachopo, A.C. Cachopo, J.P. Martins, Permissive belief revision, in: Portuguese Conference on Artiﬁcial Intelligence, in: Lect. Notes Artif. 

[10] M. Dalal, Investigations into a theory of knowledge base revision: preliminary report, in: Association for the Advancement of Artiﬁcial Intelligence, 

[11] J.-P. Delgrande, P. Peppas, Revising Horn theories, in: T. Walsh (Ed.), 22nd International Joint Conference on Artiﬁcial Intelligence, IJCAI, IJCAI/AAAI, 

[12] J.-P. Delgrande, P. Peppas, Belief revision in Horn theories, Artif. Intell. 218 (2015) 1–22.
[13] R. Diaconescu, Institution-Independent Model Theory, Universal Logic, Birkhäuser, 2008.
[14] F. Distel, J. Atif, I. Bloch, Concept dissimilarity on tree edit distance and morphological dilatations, in: European Conference on Artiﬁcial Intelligence, 

Intell., vol. 2258, 2001, pp. 335–348.

AAAI’88, 1988, pp. 475–479.

2011, pp. 839–844.

ECAI, 2014, pp. 249–254.

[15] F. Distel, J. Atif, I. Bloch, Concept dissimilarity with triangle inequality, in: C. Baral, G.D. Giacomo, T. Eiter (Eds.), Fourteenth International Conference 

on Principles of Knowledge Representation and Reasoning, KR, AAAI Press, 2014, pp. 614–617.

[16] G. Flouris, Z. Huang, J. Pan, D. Plexousakis, H. Wache, Inconsistencies, negations and changes in ontologies, in: 21st AAAI National Conference on 

[17] G. Flouris, D. Plexousakis, G. Antoniou, On applying the AGM theory to DLs and OWL, in: The Semantic Web—ISWC 2005, in: Lect. Notes Comput. Sci., 

Artiﬁcial Intelligence, 2006, pp. 1295–1300.

vol. 5341, Springer, 2005, pp. 216–231.

[18] J.-A. Goguen, R.-M. Burstall, A study in the foundations of programming methodology: speciﬁcations, institutions, charters and parchments, in: D. Pitt, 

et al. (Eds.), Category Theory and Computer Programming, in: Lect. Notes Comput. Sci., vol. 240, Springer-Verlag, 1985, pp. 313–333.

[19] J.-A. Goguen, R.-M. Burstall, Institutions: abstract model theory for speciﬁcation and programming, J. ACM 39 (1) (1992) 95–146.
[20] N. Gorogiannis, A. Hunter, Merging ﬁrst-order knowledge using dilation operators, in: Fifth International Symposium on Foundations of Information 

and Knowledge Systems, FoIKS’08, in: Lect. Notes Comput. Sci., vol. 4932, 2008, pp. 132–150.
[21] S.O. Hansson, Knowledge-level analysis of belief base operations, Artif. Intell. 82 (1) (1996) 215–235.
[22] H. Katsuno, A.-O. Mendelzon, Propositional knowledge base revision and minimal change, Artif. Intell. 52 (1991) 263–294.
[23] I. Levi, Subjunctives, dispositions and chances, in: Dispositions, in: Synthese, vol. 113, Springer, 1977, pp. 303–335.
[24] H. Liu, C. Lutz, M. Milicic, F. Wolter, Updating description logic ABoxes, in: KR, 2006, pp. 46–56.
[25] T. Meyer, K. Lee, R. Booth, Knowledge integration for description logics, in: Association for the Advancement of Artiﬁcial Intelligence, AAAI’05, vol. 5, 

2005, pp. 645–650.

2009, pp. 891–897.

[26] T. Mossakowski, R. Diaconescu, A. Tarlecki, What is a logic translation, Log. Univers. 3 (1) (2009) 95–124.
[27] G. Qi, J. Du, Model-based revision operators for terminologies in description logics, in: International Joint Conference on Artiﬁcial Intelligence, IJCAI, 

[28] G. Qi, W. Liu, D. Bell, A revision-based approach to handling inconsistency in description logics, Artif. Intell. Rev. 26 (1–2) (2006) 115–128.
[29] G. Qi, W. Liu, D.-A. Bell, Knowledge base revision in description logics, in: M. Fisher, W.V. der Hoek, B. Konev, A. Lisitsa (Eds.), European Conference on 

Logics in Artiﬁcial Intelligence, JELIA, in: Lect. Notes Artif. Intell., vol. 4160, Springer-Verlag, 2006, pp. 386–398.

[30] G. Qi, F. Yang, A survey of revision approaches in description logics, in: D. Calvanese, G. Lausen (Eds.), Web Reasoning and Rule Systems (RR), Second 

International Conference, in: Lect. Notes Comput. Sci., vol. 5341, Springer-Verlag, 2008, pp. 74–88.

[31] M.-M. Ribeiro, R. Wassermann, AGM revision in description logics, in: First Workshop on Automated Reasoning about Context and Ontology Evolution, 

ARCOE, 2009, pp. 13–15.

Ontology Evolution, ARCOE, 2010, pp. 7–8.

[32] M.M. Ribeiro, R. Wassermann, Base revision for ontology debugging, J. Log. Comput. 19 (5) (2009) 721–743.
[33] M.-M. Ribeiro, R. Wassermann, More about AGM revision in description logics, in: Second Workshop on Automated Reasoning about Context and 

[34] M.-M. Ribeiro, R. Wassermann, Minimal change in AGM for non-classical logics, in: C. Baral, G.D. Giacomo, T. Eiter (Eds.), Fourteenth International 

Conference on Principles of Knowledge Representation and Reasoning, KR, AAAI Press, 2014, pp. 657–660.

[35] M.-M. Ribeiro, R. Wassermann, G. Flouris, G. Antoniou, Minimal change: relevance and recovery revisited, Artif. Intell. 201 (2013) 59–80.
[36] S. Schlobach, R. Cornet, Non-standard reasoning services for the debugging of description logic terminologies, in: International Joint Conference on 

Artiﬁcial Intelligence, IJCAI’03, vol. 3, 2003, pp. 355–362.

[37] S. Schlobach, Z. Huang, R. Cornet, F.V. Harmelen, Debugging incoherent terminologies, J. Autom. Reason. 39 (3) (2007) 317–349.
[38] A. Sernadas, C. Sernadas, C. Caleiro, Synchronization of logics, Stud. Log. 59 (2) (1997) 217–247.
[39] A. Tarski, The semantic conception of truth, Philos. Phenomenol. Res. 4 (1944) 13–47.
[40] A. Tarski, On the concept of logical consequence, Log. Semant. Metamath. (1956) 409–420.
[41] Z. Wang, K. Wang, R.-W. Topor, Revising general knowledge bases in description logics, in: F. Lin, U. Sattler, M. Truszczynski (Eds.), Twelfth International 

Conference on Principles of Knowledge Representation and Reasoning, KR, AAAI Press, 2010, pp. 599–601.

[42] Z. Zhuang, Z. Wang, K. Wang, J. Delgrande, Extending AGM contraction to arbitrary logics, in: 24th International Joint Conference on Artiﬁcial Intelli-

[43] Z.-Q. Zhuang, M. Pagnucco, Y. Zhang, Deﬁnability of Horn revision from Horn contraction, in: 23rd International Joint Conference on Artiﬁcial Intelli-

gence, IJCAI-15, 2015, pp. 3299–3305.

gence, IJCAI, IJCAI/AAAI, 2013, pp. 1205–1211.

