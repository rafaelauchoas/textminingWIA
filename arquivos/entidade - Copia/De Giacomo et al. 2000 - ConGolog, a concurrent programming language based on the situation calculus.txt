Artiﬁcial Intelligence 121 (2000) 109–169

ConGolog, a concurrent programming language
based on the situation calculus

Giuseppe De Giacomo a;(cid:3), Yves Lespérance b, Hector J. Levesque c
a Dipartimento di Informatica e Sistemistica, Università di Roma “La Sapienza”, Via Salaria 113,
00198 Roma, Italy
b Department of Computer Science, York University, Toronto, ON, Canada M3J 1P3
c Department of Computer Science, University of Toronto, Toronto, ON, Canada M5S 3H5

Received 16 September 1999

Abstract

As an alternative to planning, an approach to high-level agent control based on concurrent program
execution is considered. A formal deﬁnition in the situation calculus of such a programming language
is presented and illustrated with some examples. The language includes facilities for prioritizing the
execution of concurrent processes, interrupting the execution when certain conditions become true,
and dealing with exogenous actions. The language differs from other procedural formalisms for
concurrency in that the initial state can be incompletely speciﬁed and the primitive actions can be
user-deﬁned by axioms in the situation calculus. Some mathematical properties of the language are
proven, for instance, that the proposed semantics is equivalent to that given earlier for the portion of
the language without concurrency. (cid:211) 2000 Elsevier Science B.V. All rights reserved.

Keywords: Cognitive robotics; Reasoning about actions; Situation calculus; Semantics of programs;
Concurrency

1. Introduction

When it comes to providing high-level control for robots or other agents in dynamic
and incompletely known worlds, approaches based on plan synthesis may end up being
too demanding computationally in all but simple settings. An alternative approach that is
showing promise is that of high-level program execution [20]. The idea, roughly, is that

(cid:3)

Corresponding author.
E-mail addresses: degiacomo@dis.uniroma1.it (G. De Giacomo), lesperan@cs.yorku.ca (Y. Lespérance),

hector@cs.toronto.edu (H.J. Levesque).

0004-3702/00/$ – see front matter (cid:211)
PII: S 0 0 0 4 - 3 7 0 2 ( 0 0 ) 0 0 0 3 1 - X

2000 Elsevier Science B.V. All rights reserved.

110

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

instead of searching for a sequence of actions that would take the agent from an initial
state to some goal state, the task is to ﬁnd a sequence of actions that constitutes a legal
execution of some high-level nondeterministic program. As in planning, to ﬁnd a sequence
that constitutes a legal execution of a high-level program, it is necessary to reason about
the preconditions and effects of the actions within the body of the program. However,
if the program happens to be almost deterministic, very little searching is required; as
more and more nondeterminism is included, the search task begins to resemble traditional
planning. Thus, in formulating a high-level program, the user gets to control the search
effort required.

The hope is that in many domains, what an agent needs to do can be conveniently
expressed using a suitably rich high-level programming language, and that at the same
time ﬁnding a legal execution of that program will be more feasible computationally than
the corresponding planning task. Previous work on the Golog language [20] considered
how to reason about actions in programs containing conditionals, iteration, recursion, and
nondeterministic operators, where the primitive actions and ﬂuents where characterized
by axioms of the situation calculus. In this paper, we explore how to execute programs
incorporating a rich account of concurrency. The execution task remains the same; what
changes is that the programming language, which we call ConGolog (for Concurrent
Golog) [6], becomes considerably more expressive. One of the nice features of this
language is that it allows us to conveniently formulate agent controllers that pursue
goal-oriented tasks while concurrently monitoring and reacting to conditions in their
environment, all deﬁned precisely in the language of the situation calculus. But this
kind of expressiveness requires considerable mathematical machinery: we need to encode
ConGolog programs as terms in the situation calculus (which, among other things, requires
encoding certain formulas as terms), and we also need to use second-order quantiﬁcation
to deal with iteration and recursive procedures. It is not at all obvious that such complex
deﬁnitions are well-behaved or even consistent.

Of course ours is not the ﬁrst formal model of concurrency. In fact, well developed
approaches are available [4,17,25,39] 1 and our work inherits many of the intuitions
behind them. However, it is distinguished from these in at least two fundamental ways.
First, it allows incomplete information about the environment surrounding the program. In
contrast to typical computer programs, the initial state of a ConGolog program need only
be partially speciﬁed by a collection of axioms. Second, it allows the primitive actions
(elementary instructions) to affect the environment in a complex way and such changes to
the environment can affect the execution of the remainder of the program. In contrast to
typical computer programs whose elementary instructions are simple predeﬁned statements
(e.g., variable assignments), the primitive actions of a ConGolog program are determined
by a separate domain-dependent action theory, which speciﬁes the action preconditions
and effects, and deals with the frame problem. Finally, it might also be noted that the
interaction between prioritized concurrency and recursive procedures presents a level of
procedural complexity which, as far as we know, has not been dealt with in any previous
formal model.

1 In [5,28] a direct use of such approaches to model concurrent (complex) actions in AI is investigated.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

111

The rest of the paper is organized as follows: in Section 2 we brieﬂy review the situation
calculus and how it can be used to formulate the planning task. In Section 3, we review
the Golog programming language and in the following section, we present a variant of the
original speciﬁcation of the high-level execution task. In Section 5, we explain informally
the sort of concurrency we are concerned with, as well as related notions of priorities
and interrupts. The section concludes with changes to the Golog speciﬁcation required
to handle concurrency. In Section 6, we illustrate the use of ConGolog by going over
several example programs. Then, in Section 7, we extend such a speciﬁcation to handle
procedures and recursion. Handling the interaction between the very general form of
prioritized concurrency allowed in ConGolog and recursive procedures will require a quite
sophisticated approach. In Section 8 we will show general sufﬁcient conditions that allow
us to use a much simpliﬁed semantics without loss of generality. In Section 9, we present a
Prolog interpreter for ConGolog and prove its correctness. In Section 10, we conclude by
discussing some of the properties of ConGolog, its implementation, and topics for future
research.

2. The situation calculus

As mentioned earlier, our high-level programs contain primitive actions and tests that are
domain dependent. An interpreter for such programs must reason about the preconditions
and effects of actions in the program to ﬁnd legal executions. So we need a language to
specify such domain theories. For this, we use the situation calculus [24], a ﬁrst-order
language (with some second-order features) for representing dynamic domains. In this
formalism, all changes to the world are the result of named actions. A possible world
history, which is simply a sequence of actions, is represented by a ﬁrst-order term called
a situation. The constant S0 is used to denote the initial situation, namely that situation
in which no actions have yet occurred. There is a distinguished binary function symbol
do and the term do.a; s/ denotes the situation resulting from action a being performed
in situation s. Actions may be parameterized. For example, put.x; y/ might stand for the
action of putting object x on object y, in which case do.put.A; B/; s/ denotes that situation
resulting from putting A on B when the world is in situation s. Notice that in the situation
calculus, actions are denoted by function symbols, and situations (world histories) are also
ﬁrst-order terms. For example,

do.putDown.A/; do.walk.P /; do.pickUp.A/; S0///

is a situation denoting the world history consisting of the sequence of actions

TpickUp.A/; walk.P /; putDown.A/U:

Relations whose truth values vary from situation to situation, called relational ﬂuents,
are denoted by predicate symbols taking a situation term as their last argument. For
example, Holding.r; x; s/ might mean that a robot r is holding an object x in situation s.
Functions whose denotations vary from situation to situation are called functional ﬂuents.
They are denoted by function symbols with an additional situation argument, as in
position.r; s/, i.e., the position of robot r in situation s.

112

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

The actions in a domain are speciﬁed by providing certain types of axioms. First, one
must state the conditions under which it is physically possible to perform an action by
providing a action precondition axiom. For this, we use the special predicate Poss.a; s/
which represents the fact that primitive action a is physically possible (i.e., executable) in
situation s. So, for example,

Poss.pickup.x/; s/ (cid:17) 8x::Holding.x; s/ ^ NextTo.x; s/ ^ :Heavy.x/

says that the action pickup.x/, i.e., the agent picking up an object x, is possible in situation
s if and only if the agent is not already holding something in situation s and is positioned
next to x in s and x is not heavy.

Secondly, one must specify how the action affects the state of the world; this is done by

providing effect axioms. For example,

Fragile.x; s/ (cid:27) Broken.x; do.drop.x; s///

says that dropping an object x causes it to become broken provided that x is fragile. Effect
axioms provide the “causal laws” for the domain of application.

These types of axioms are usually insufﬁcient if one wants to reason about change.
One must add frame axioms that specify when ﬂuents remain unchanged by actions. For
example, dropping an object does not affect the color of things:

colour.y; s/ D c (cid:27) colour.y; do.drop.x; s/// D c:

The frame problem arises because the number of these frame axioms is very large, in
general, of the order of 2 (cid:2) A (cid:2) F , where A is the number of actions and F the number of
ﬂuents. This complicates the task of axiomatizing a domain and can make theorem proving
extremely inefﬁcient.

To deal with the frame problem, we use an approach due to Reiter [31]. The basic idea
behind this is to collect all effect axioms about a given ﬂuent and make a completeness
assumption, i.e., assume that they specify all of the ways that the value of the ﬂuent may
change. A syntactic transformation can then be applied to obtain a successor state axiom
for the ﬂuent, for example:

Broken.x; do.a; s// (cid:17)

a D drop.x/ ^ Fragile.x; s/ _
9b:.a D explode.b/ ^ NextTo.b; x; s// _
Broken.x; s/ ^ a 6D repair.x/:

This says that an object x is broken in the situation resulting from action a being performed
in s if and only if a is dropping x and x is fragile, or a involves a bomb exploding next
to x, or x was already broken in situation s prior to the action and a is not the action
of repairing x. This approach yields a solution to the frame problem—a parsimonious
representation for the effects of actions. Note that it relies on quantiﬁcation over actions.
This discussion ignores the ramiﬁcation and qualiﬁcation problems; a treatment compatible
with the approach described has been proposed by Lin and Reiter [21].

So following this approach, a domain of application will be speciﬁed by a theory of the

following form:

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

113

(cid:15) Axioms describing the initial situation, S0.
(cid:15) Action precondition axioms, one for each primitive action a, characterizing Poss.a; s/.
(cid:15) Successor state axioms, one for each ﬂuent F , stating under what conditions

F .Ex; do.a; s// holds as function of what holds in situation s:

(cid:15) Unique names axioms for the primitive actions.
(cid:15) Some foundational, domain independent axioms.

The latter foundational axioms include unique names axioms for situations, and an
induction axiom. They also introduce the relation < over situations. s < s0 holds if and
only if s0 is the result of some sequence of actions being performed in s, where each
action in the sequence is possible in the situation in which it is performed; s 6 s0 stands
for s < s0 _ s D s0. Since the foundational axioms play no special role in this paper, we
omit them. For details, and for some of their metamathematical properties, see Lin and
Reiter [21] and Reiter [32].

For any domain theory of the sort just described, we have a very clean speciﬁcation of

the planning task, which dates back to the work of Green [13]:

Classical Planning. Given a domain theory D as above, and a goal formula (cid:30).s/ with a
single free-variable s; the planning task is to ﬁnd a sequence of actions Ea such that:

D jD Legal.Ea; S0/ ^ (cid:30).do.Ea; S0//;
where do.Ta1; : : : ; anU; s/ is an abbreviation for

do.an; do.an(cid:0)1; : : : ; do.a1; s/ : : ://;
and where Legal.Ta1; : : : ; anU; s/ stands for

Poss.a1; s/ ^ (cid:1) (cid:1) (cid:1) ^ Poss.an; do.Ta1; : : : ; an(cid:0)1U; s//:

In other words, the task is to ﬁnd a sequence of actions that is executable (each action
is executed in a context where its precondition is satisﬁed) and that achieves the goal (the
goal formula (cid:30) holds in the ﬁnal state that results from performing the actions in sequence).

3. Golog

As presented in [20], Golog is a logic-programming language whose primitive actions
are those of a background domain theory. It includes the following constructs ((cid:14), possibly
subscripted, ranges over Golog programs):

a,
(cid:30)?,
.(cid:14)1I (cid:14)2/,
.(cid:14)1 j (cid:14)2/,
(cid:25)v:(cid:14),

primitive action
wait for a condition 2
sequence
nondeterministic choice between actions
nondeterministic choice of arguments

2 Because there are no exogenous actions or concurrent processes in Golog, waiting for (cid:30) amounts to testing

that (cid:30) holds in the current state.

114

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

(cid:14)(cid:3),
fproc P1.Ev1/ (cid:14)1 endI : : : proc Pn.Evn/ (cid:14)n endI (cid:14)g,

nondeterministic iteration
procedures.

In the ﬁrst line, a stands for a situation calculus action where the special situation constant
now may be used to refer to the current situation (i.e., that where a is to be executed).
Similarly, in the line below, (cid:30) stands for a situation calculus formula where now may
be used to refer to the current situation, for example OnTable.block; now/. aTsU ((cid:30)TsU)
will denote the action (formula) obtained by substituting the situation variable s for
all occurrences of now in functional ﬂuents appearing in a (functional and predicate
ﬂuents appearing in (cid:30)). Moreover when no confusion can arise, we often leave out
the now argument from ﬂuents altogether; for example, write OnTable.block/ instead
of OnTable.block; now/. In such cases, the situation suppressed version of the action or
formula should be understood as an abbreviation for the version with now.

Let’s examine a simple example to see some of the features of the language. Here’s a

Golog program to clear the table in a blocks world:

(cid:25)b: TOnTable.b; now/?I pickUp.b/I putAway.b/U

(cid:8)
proc removeAblock

endI
removeAblock
:9b: OnTable.b; now/?

(cid:3)I

(cid:9)

:

Here we ﬁrst deﬁne a procedure to remove a block from the table using the nondeter-
ministic choice of argument operator (cid:25) . (cid:25)x: T(cid:14).x/U is executed by nondeterministically
picking an individual x, and for that x, performing the program (cid:14).x/. The wait action
OnTable.b; now/? succeeds only if the individual chosen, b, is a block that is on the table
in the current situation. The main part of the program uses the nondeterministic iteration
operator; it simply says to execute removeAblock zero or more times until the table is clear.
Note that Golog’s other nondeterministic construct, .(cid:14)1 j (cid:14)2/, allows a choice between two
actions; a program of this form can be executed by performing either (cid:14)1 or (cid:14)2.

In its most basic form, the high-level program execution task is a special case of the

above planning task:

Program Execution. Given a domain theory D as above, and a program (cid:14), the execution
task is to ﬁnd a sequence of actions Ea such that:

D jD Do.(cid:14); S0; do.Ea; S0//;

where Do.(cid:14); s; s0/ means that program (cid:14) when executed starting in situation s has s0 as a
legal terminating situation.

Note that since Golog programs can be nondeterministic,
terminating situations for the same program and starting situation.

there may be several

In [20], Do.(cid:14); s; s0/ was simply viewed as an abbreviation for a formula of the situation

calculus. The following inductive deﬁnition of Do was provided:

(1) Primitive actions:
Do.a; s; s0/

defD Poss.aTsU; s/ ^ s0 D do.aTsU; s/:

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

115

(2) Wait/test actions:

Do.(cid:30)?; s; s

0

/

defD (cid:30)TsU ^ s D s

0

:

(3) Sequence:

Do.(cid:14)1I (cid:14)2; s; s0/

defD 9s00: Do.(cid:14)1; s; s00/ ^ Do.(cid:14)2; s00; s0/:

(4) Nondeterministic branch:

Do.(cid:14)1 j (cid:14)2; s; s0/

defD Do.(cid:14)1; s; s0/ _ Do.(cid:14)2; s; s0/:

(5) Nondeterministic choice of argument:

Do.(cid:25)x:(cid:14).x/; s; s0/

defD 9x: Do.(cid:14).x/; s; s0/:

(6) Nondeterministic iteration:

Do.(cid:14)

(cid:3)

; s; s

0

/

defD 8P :

(cid:8)

(cid:9)

8s1: P .s1; s1/ ^
8s1; s2; s3:TP .s1; s2/ ^ Do.(cid:14); s2; s3/ (cid:27) P .s1; s3/U
(cid:27) P .s; s

0

/:
In other words, doing action (cid:14) zero or more times takes you from s to s0 if and only
if .s; s0/ is in every set (and therefore, the smallest set) such that:
(a) .s1; s1/ is in the set for all situations s1.
(b) Whenever .s1; s2/ is in the set, and doing (cid:14) in situation s2 takes you to situation

s3, then .s1; s3/ is in the set.

The above deﬁnition of nondeterministic iteration is the standard second-order way
of expressing this set. Some appeal to second-order logic appears necessary here
because transitive closure is not ﬁrst-order deﬁnable, and nondeterministic iteration
appeals to this closure.

We have left out the expansion for procedures, which is somewhat more complex; see [20]
for the details.

4. A transition semantics

By using Do, programs are assigned a semantics in terms of a relation, denoted by
the formulas Do.(cid:14); s; s0/, that given a program (cid:14) and a situation s, returns a situation s0
resulting from executing the program starting in the situation s. Semantics of this form
are sometimes called evaluation semantics (see [15,26]), since they are based on the
(complete) evaluation the program.

When concurrency is taken into account it is more convenient to adopt semantics of a
different form: the so-called transition semantics or computation semantics (see again [15,
26]). Transition semantics are based on deﬁning single steps of computation in contrast to
directly deﬁning complete computations.

In the present case, we are going to deﬁne a relation, denoted by the predicate
Trans.(cid:14); s; (cid:14)0; s0/, that associates to a given program (cid:14) and situation s, a new situation

116

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

s0 that results from executing a primitive action or test action and a new program (cid:14)0 that
represents what remains of the program after having performed such an action. In other
words, Trans denotes a transition relation between conﬁgurations. A conﬁguration is a
pair formed by a program (the part of the initial program that is left to perform) and the a
situation (representing the current situation).

We are also going to introduce a predicate Final.(cid:14); s/, meaning that the conﬁguration
.(cid:14); s/ is a ﬁnal one, that is, where the computation can be considered completed (no
program remains to be executed). The ﬁnal situations reached after a ﬁnite number
of transitions from a starting situation coincide with those satisfying the Do relation.
Complete computations are thus deﬁned by repeatedly composing single transitions until
a ﬁnal conﬁguration is reached.

It worth noting that if a program does not terminate, then no ﬁnal situation will satisfy
the Do relation (indeed evaluation semantics are typically used for terminating programs),
while we can still keep track of the various transitions performed by means of Trans.
Indeed, nonterminating programs do not need any special treatment within transition
semantics, while they typically remain undeﬁned in evaluation semantics.

In general, both evaluation semantics and transition semantics belong to the family of
structural operational semantics introduced by Plotkin in [27]. Both of these forms of
semantics are operational since they do not assign a meaning directly to the programs (as
denotational semantics), but instead see programs simply as speciﬁcations of computations
(or better as syntactic objects that specify the control ﬂow of the computation). They are
abstract semantics since, in contrast to concrete operational semantics, they do not deﬁne a
speciﬁc machine on which the operations are performed, but instead only deﬁne an abstract
relation (such as Do or Trans) which denotes the possible computations (either complete
computations for evaluation semantics, or single steps of computations for transition
semantics). In addition, both such form of semantics are structural since are are deﬁned
on the structure of the programs.

4.1. Encoding programs as ﬁrst-order terms

In the simple semantics using Do, it was possible to avoid introducing programs
explicitly into the logical language, since Do.(cid:14); s; s0/ was only an abbreviation for a
formula (cid:8).s; s0/ that did not mention the program (cid:14) (or any other programs). This was
possible essentially because it was not necessary to quantify over programs.

Basing the semantics on Trans however does require quantiﬁcation over programs. To
allow for this, we develop an encoding of programs as ﬁrst-order terms in the logical
language (observe that programs as such, cannot in general be ﬁrst-order terms, since on
one hand, they mention formulas in tests, and on the other, the operator (cid:25) in (cid:25)x:(cid:14) is a
quantiﬁer).

Encoding programs as ﬁrst-order terms, although it requires some care (e.g., introducing
constants denoting variables and deﬁning substitution explicitly in the language), does not
pose any major problem. 3 In the following we abstract from the details of the encoding

3 Observe that, we assume that formulas that occur in tests never mention programs, so it is impossible to build

self-referential sentences.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

117

as much as possible, and essentially use programs within formulas as if they were already
ﬁrst-order terms. The full encoding is given in Appendix A.

4.2. Trans and Final

Let us formally deﬁne Trans and Final, which intuitively specify what are the possible
transitions between conﬁgurations (Trans), and when a conﬁguration can be considered
ﬁnal (Final).

It is convenient to introduce a special program nil, called the empty program, to denote
the fact that nothing remains to be performed (legal termination). For example, consider a
program consisting solely of a primitive action a. If it can be executed (i.e., if the action is
possible in the current situation), then after the execution of the action a nothing remains of
the program. In this case, we say that the program remaining after the execution of action
a is nil.

Trans.(cid:14); s; (cid:14)0; s0/ holds if and only if there is a transition from the conﬁguration .(cid:14); s/
to the the conﬁguration .(cid:14)0; s0/, that is, if by running program (cid:14) starting in situation s, one
can get to situation s0 in one elementary step with the program (cid:14)0 remaining to be executed.
As mentioned, every such elementary step will either be the execution of an atomic action
(which changes the current situation) or the execution of a test (which does not). As well,
if the program is nondeterministic, there may be several transitions that are possible in a
conﬁguration. To simplify the discussion, we postpone the introduction of procedures to
Section 7.

The predicate Trans for programs without procedures is characterized by the following
set of axioms T (here as in the rest of the paper, free variables are assumed to be universally
quantiﬁed):

(1) Empty program:

Trans.nil; s; (cid:14)0; s0/ (cid:17) False:

(2) Primitive actions:

Trans.a; s; (cid:14)0; s0/ (cid:17)

Poss.aTsU; s/ ^ (cid:14)0 D nil ^ s0 D do.aTsU; s/:

(3) Wait/test actions:

Trans.(cid:30)?; s; (cid:14)0; s0/ (cid:17) (cid:30)TsU ^ (cid:14)0 D nil ^ s0 D s:

(4) Sequence:

Trans.(cid:14)1I (cid:14)2; s; (cid:14)0; s0/ (cid:17)

9(cid:13) :(cid:14)0 D .(cid:13) I (cid:14)2/ ^ Trans.(cid:14)1; s; (cid:13) ; s0/ _
Final.(cid:14)1; s/ ^ Trans.(cid:14)2; s; (cid:14)

; s

/:

0

0

(5) Nondeterministic branch:

Trans.(cid:14)1 j (cid:14)2; s; (cid:14)

0
/ (cid:17)
Trans.(cid:14)1; s; (cid:14)0; s0/ _ Trans.(cid:14)2; s; (cid:14)0; s0/:

; s

0

118

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

(6) Nondeterministic choice of argument:

Trans.(cid:25)v:(cid:14); s; (cid:14)0; s0/ (cid:17) 9x:Trans.(cid:14)v

x ; s; (cid:14)0; s0/:

(7) Iteration:

Trans.(cid:14)(cid:3); s; (cid:14)0; s0/ (cid:17)

9(cid:13) :.(cid:14)0 D (cid:13) I (cid:14)(cid:3)/ ^ Trans.(cid:14); s; (cid:13) ; s0/:

The assertions above characterize when a conﬁguration .(cid:14); s/ can evolve (in a single

step) to a conﬁguration .(cid:14)0; s0/. Intuitively they can be read as follows:

(1) .nil; s/ cannot evolve to any conﬁguration.
(2) .a; s/ evolves to .nil; do.aTsU; s//, provided that aTsU is possible in s. After having
performed a, nothing remains to be performed and hence nil is returned. Note that
in Trans.a; s; (cid:14)0; s0/, a stands for the program term encoding the corresponding
situation calculus action, while Poss and do take the latter as argument; we take
the function (cid:1)T(cid:1)U as mapping the program term a into the corresponding situation
calculus action aTsU, as well as replacing now by the situation s. The details of how
this function is deﬁned are in Appendix A.

(3) .(cid:30)?; s/ evolves to .nil; s/, provided that (cid:30)TsU holds, otherwise it cannot proceed.
Note that the situation remains unchanged. Analogously to the previous case,
we take the function (cid:1)T(cid:1)U as mapping the program term for condition (cid:30) into the
corresponding situation calculus formulas (cid:30)TsU, as well as replacing now by the
situation s (see Appendix A for details).

(4) .(cid:14)1I (cid:14)2; s/ can evolve to .(cid:14)0
1

Moreover it can also evolve to .(cid:14)0
2; s0/.
and .(cid:14)2; s/ can evolve to .(cid:14)0

I (cid:14)2; s0/, provided that .(cid:14)1; s/ can evolve to .(cid:14)0

1; s0/.
2; s0/, provided that .(cid:14)1; s/ is a ﬁnal conﬁguration

(5) .(cid:14)1j(cid:14)2; s/ can evolve to .(cid:14)0; s0/, provided that either .(cid:14)1; s/ or .(cid:14)2; s/ can do so.
(6) .(cid:25)v:(cid:14); s/ can evolve to .(cid:14)0; s0/, provided that there exists an x such that .(cid:14)v

x ; s/ can
x is the program resulting from (cid:14) by substituting v with the

evolve to .(cid:14)0; s0/. Here (cid:14)v
variable x. 4

(7) .(cid:14)(cid:3); s/ can evolve to .(cid:14)0I (cid:14)(cid:3); s0/ provided that .(cid:14); s/ can evolve to .(cid:14)0; s0/. Observe
that .(cid:14)(cid:3); s/ can also not evolve at all, .(cid:14)(cid:3); s/ being ﬁnal by deﬁnition (see below).
Final.(cid:14); s/ tells us whether a program (cid:14) can be considered to be already in a ﬁnal state
(legally terminated) in the situation s. Obviously we have Final.nil; s/, but also Final.(cid:14)(cid:3); s/
since (cid:14)(cid:3) requires 0 or more repetitions of (cid:14) and so it is possible to not execute (cid:14) at all, the
program completing immediately.

The predicate Final for programs without procedures is characterized by the set of

axioms F :

(1) Empty program:

Final.nil; s/ (cid:17) True:

(2) Primitive action:

Final.a; s/ (cid:17) False:

4 To be more precise, v is substituted by a term of the form nameOf.x/, where nameOf is used to convert

situation calculus objects/actions into program terms of the corresponding sort (see Appendix A).

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

119

(3) Wait/test action:

Final.(cid:30)?; s/ (cid:17) False:

(4) Sequence:

Final.(cid:14)1I (cid:14)2; s/ (cid:17)

Final.(cid:14)1; s/ ^ Final.(cid:14)2; s/:

(5) Nondeterministic branch:

Final.(cid:14)1 j (cid:14)2; s/ (cid:17)

Final.(cid:14)1; s/ _ Final.(cid:14)2; s/:

(6) Nondeterministic choice of argument:

Final.(cid:25)v:(cid:14); s/ (cid:17) 9x:Final.(cid:14)v

x ; s/:

(7) Iteration:

Final.(cid:14)(cid:3); s/ (cid:17) True:

The assertions above can be read as follows:
(1) .nil; s/ is a ﬁnal conﬁguration.
(2) .a; s/ is not ﬁnal, indeed the program consisting of the primitive action a cannot be

considered completed until it has performed a.

(3) .(cid:30)?; s/ is not ﬁnal, indeed the program consisting of the test action (cid:30)? cannot be

considered completed until it has performed the test (cid:30)?.

(4) .(cid:14)1I (cid:14)2; s/ can be considered completed if both .(cid:14)1; s/ and .(cid:14)2; s/ are ﬁnal.
(5) .(cid:14)1j(cid:14)2; s/ can be considered completed if either .(cid:14)1; s/ or .(cid:14)2; s/ is ﬁnal.
(6) .(cid:25)v:(cid:14); s/ can be considered completed, provided that there exists an x such that

.(cid:14)v

x ; s/ is ﬁnal, where (cid:14)v

x is obtained from (cid:14) by substituting v with x.

(7) .(cid:14)(cid:3); s/ is a ﬁnal conﬁguration, since by (cid:14)(cid:3) is allowed to execute 0 times.

In the following we denote by C be the set of axioms for Trans and Final plus those needed
for the encoding of programs as ﬁrst-order terms.

4.3. Trans(cid:3) and Do

The possible conﬁgurations that can be reached by a program (cid:14) starting in a situation s
are those obtained by repeatedly following the transition relation denoted by Trans starting
from .(cid:14); s/, i.e., those in the reﬂexive transitive closure of the transition relation. Such a
relation, denoted by Trans(cid:3), is deﬁned as the (second-order) situation calculus formula:

Trans

(cid:3).(cid:14); s; (cid:14)0; s0/

defD 8T :T: : : (cid:27) T .(cid:14); s; (cid:14)0; s0/U;

where : : : stands for the conjunction of the universal closure of the following implications:

True (cid:27) T .(cid:14); s; (cid:14); s/;

Trans.(cid:14); s; (cid:14)

00

00

/ ^ T .(cid:14)

00

00

0

0

; s

; (cid:14)

; s

; s

/ (cid:27) T .(cid:14); s; (cid:14)

0

0

/:

; s

120

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

Using Trans(cid:3) and Final we can give a new deﬁnition of Do as:

Do.(cid:14); s; s0/

defD 9(cid:14)0:Trans

(cid:3).(cid:14); s; (cid:14)0; s0/ ^ Final.(cid:14)0; s0/:

In other words, Do.(cid:14); s; s0/ holds if it is possible to repeatedly single-step the program (cid:14),
obtaining a program (cid:14)0 and a situation s0 such that (cid:14)0 can legally terminate in s0.

For Golog programs such a deﬁnition for Do coincides with the one given in [20].

Formally, we can state the the following result:

Theorem 1. Let Do1 be the original deﬁnition of Do in [20], presented in Section 3, and
Do2 the new one given above. Then for each Golog program (cid:14):

C jD 8s; s0: Do1.(cid:14); s; s0/ (cid:17) Do2.(cid:14); s; s0/:

Proof. See Appendix B. 2

The theorem also holds for Golog programs involving procedures when the treatment in

Section 7 is used.

Let us note that a Trans-step which brings the state of a computation from one conﬁgura-
tion .(cid:14); s/ to another .(cid:14)0; s0/ need not change the situation part of the conﬁguration, i.e., we
may have s D s0. In particular, test actions have this property. If we want to abstract from
such computation steps that only change the state of the program, we can easily deﬁne a
new relation, TransSit, that skips transitions that do not change the situation:

TransSit.(cid:14); s; (cid:14)0; s/

defD 8T 0:T: : : (cid:27) T 0.(cid:14); s; (cid:14)0; s0/U;

where : : : stands for the conjunction of the universal closure of the following implications:

Trans.(cid:14); s; (cid:14)0; s0/ ^ s0 6D s (cid:27) T 0.(cid:14); s; (cid:14)0; s0/;
Trans.(cid:14); s; (cid:14)00; s/ ^ T 0.(cid:14)00; s; (cid:14)0; s0/ (cid:27) T 0.(cid:14); s; (cid:14)0; s0/:

5. Concurrency

We are now ready to deﬁne ConGolog, an extended version of Golog that incorporates

a rich account of concurrency. We say ‘rich’ because it handles:
(cid:15) concurrent processes with possibly different priorities,
(cid:15) high-level interrupts,
(cid:15) arbitrary exogenous actions.

As is commonly done in other areas of computer science, we model concurrent processes as
interleavings of the primitive actions in the component processes. A concurrent execution
of two processes is one where the primitive actions in both processes occur, interleaved in
some fashion. So in fact, we never have more than one primitive action happening at any
given time. This assumption might appear problematic when the domain involves actions
with extended duration (e.g., ﬁlling a bathtub). In Section 6.4, we return to this issue and
argue that in fact, there is a straightforward way to handle such cases.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

121

An important concept in understanding concurrent execution is that of a process
becoming blocked. If a deterministic process (cid:14) is executing, and reaches a point where
it is about to do a primitive action a in a situation s but where Poss.a; s/ is false (or a
wait action (cid:30)?, where (cid:30)TsU is false), then the overall execution need not fail as in Golog. In
ConGolog, the current interleaving can continue successfully provided that a process other
than (cid:14) executes next. The net effect is that (cid:14) is suspended or blocked, and execution must
continue elsewhere. 5

The ConGolog language is exactly like Golog except with the following additional

constructs:

if (cid:30) then (cid:14)1 else (cid:14)2,
while (cid:30) do (cid:14),
.(cid:14)1 k (cid:14)2/,
.(cid:14)1 ii (cid:14)2/,
(cid:14)jj,
h(cid:30) ! (cid:14)i,

synchronized conditional
synchronized loop
concurrent execution
concurrency with different priorities
concurrent iteration
interrupt.

The constructs if (cid:30) then (cid:14)1 else (cid:14)2 and while (cid:30) do (cid:14) are the synchronized versions of
the usual if-then-else and while-loop. They are synchronized in the sense that testing the
condition (cid:30) does not involve a transition per se: the evaluation of the condition and the ﬁrst
action of the branch chosen are executed as an atomic unit. So these constructs behave in a
similar way to the test-and-set atomic instructions used to build semaphores in concurrent
programming [1]. 6

The construct .(cid:14)1 k (cid:14)2/ denotes the concurrent execution of the actions (cid:14)1 and (cid:14)2.
.(cid:14)1 ii (cid:14)2/ denotes the concurrent execution of the actions (cid:14)1 and (cid:14)2 with (cid:14)1 having higher
priority than (cid:14)2. This restricts the possible interleavings of the two processes: (cid:14)2 executes
only when (cid:14)1 is either done or blocked. The next construct, (cid:14)jj, is like nondeterministic
iteration, but where the instances of (cid:14) are executed concurrently rather than in sequence.
Just as (cid:14)(cid:3) executes with respect to Do like nil j (cid:14) j .(cid:14)I (cid:14)/ j .(cid:14)I (cid:14)I (cid:14)/ j : : : , the program (cid:14)jj
executes with respect to Do like nil j (cid:14) j .(cid:14) k (cid:14)/ j .(cid:14) k (cid:14) k (cid:14)/ j : : : . See Section 6.3 for an
example of its use.

Finally, h(cid:30) ! (cid:14)i is an interrupt. It has two parts: a trigger condition (cid:30) and a body, (cid:14).
The idea is that the body (cid:14) will execute some number of times. If (cid:30) never becomes true,
(cid:14) will not execute at all. If the interrupt gets control from higher priority processes when
(cid:30) is true, then (cid:14) will execute. Once it has completed its execution, the interrupt is ready
to be triggered again. This means that a high priority interrupt can take complete control
of the execution. For example, hTrue ! ringBelli at the highest priority would ring a bell
and do nothing else. With interrupts, we can easily write controllers that can stop whatever

5 Just as actions in Golog are external (e.g., there is no internal variable assignment), in ConGolog, blocking
and unblocking also happen externally, via Poss and wait actions. Internal synchronization primitives are easily
added.

6 In [20], nonsynchronized versions of

if-then-else and while-loops are introduced by deﬁning:
defD T.(cid:30)?I (cid:14)/(cid:3)I :(cid:30)?U. The synchronized
if (cid:30) then (cid:14)1 else (cid:14)2
versions of these constructs introduced here behave essentially as the nonsynchronized ones in absence of con-
currency. However the difference is striking when concurrency is allowed.

defD T.(cid:30)?I (cid:14)1/ j .:(cid:30)?I (cid:14)2/U and while (cid:30) do (cid:14)

122

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

task they are doing to handle various concerns as they arise. They are, dare we say, more
reactive.

We now show how Trans and Final need to be extended to handle these constructs. (We
handle interrupts separately below.) Trans and Final for synchronized conditionals and
loops are deﬁned as follows:

Trans.if (cid:30) then (cid:14)1 else (cid:14)2; s; (cid:14)0; s0/ (cid:17)

(cid:30)TsU ^ Trans.(cid:14)1; s; (cid:14)0; s0/ _ :(cid:30)TsU ^ Trans.(cid:14)2; s; (cid:14)0; s0/;
/ (cid:17)
0 D (cid:13) I while (cid:30) do (cid:14)/ ^ (cid:30)TsU ^ Trans.(cid:14); s; (cid:13) ; s

Trans.while (cid:30) do (cid:14); s; (cid:14)

9(cid:13) :.(cid:14)

; s

/;

0

0

0

Final.if (cid:30) then (cid:14)1 else (cid:14)2; s/ (cid:17)

(cid:30)TsU ^ Final.(cid:14)1; s/ _ :(cid:30)TsU ^ Final.(cid:14)2; s/;

Final.while (cid:30) do (cid:14); s/ (cid:17)
:(cid:30)TsU _ Final.(cid:14); s/:

That is .if (cid:30) then (cid:14)1 else (cid:14)2; s/ can evolve to .(cid:14)0; s0/, if either (cid:30)TsU holds and .(cid:14)1; s/ can
do so, or :(cid:30)TsU holds and .(cid:14)2; s/ can do so. Similarly, .while (cid:30) do (cid:14); s/ can evolve to
.(cid:14)0I while (cid:30) do (cid:14); s0/, if (cid:30)TsU holds and .(cid:14); s/ can evolve to .(cid:14)0; s0/. .if (cid:30) then (cid:14)1 else (cid:14)2; s/
can be considered completed, if either (cid:30)TsU holds and .(cid:14)1; s/ is ﬁnal, or if :(cid:30)TsU holds and
.(cid:14)2; s/ is ﬁnal. Similarly, .while (cid:30) do (cid:14); s/ can be considered completed if either :(cid:30)TsU
holds or .(cid:14); s/ is ﬁnal.

For the constructs for concurrency the extension of Final is straightforward:

Final.(cid:14)1 k (cid:14)2; s/ (cid:17) Final.(cid:14)1; s/ ^ Final.(cid:14)2; s/;
Final.(cid:14)1 ii (cid:14)2; s/ (cid:17) Final.(cid:14)1; s/ ^ Final.(cid:14)2; s/;
Final.(cid:14)jj; s/ (cid:17) True:

Observe that the last clause says that it is legal to execute the (cid:14) in (cid:14)jj zero times. For Trans,
we have the following:

Trans.(cid:14)1 k (cid:14)2; s; (cid:14)0; s0/ (cid:17)

0

9(cid:13) :(cid:14)
9(cid:13) :(cid:14)

0 D .(cid:13) k (cid:14)2/ ^ Trans.(cid:14)1; s; (cid:13) ; s
0 D .(cid:14)1 k (cid:13) / ^ Trans.(cid:14)2; s; (cid:13) ; s
0
/ (cid:17)
9(cid:13) :(cid:14)0 D .(cid:13) ii (cid:14)2/ ^ Trans.(cid:14)1; s; (cid:13) ; s0/ _
9(cid:13) :(cid:14)0 D .(cid:14)1 ii (cid:13) / ^ Trans.(cid:14)2; s; (cid:13) ; s0/ ^ :9(cid:16); s00: Trans.(cid:14)1; s; (cid:16); s00/;

/ _
/;

Trans.(cid:14)1 ii (cid:14)2; s; (cid:14)

; s

0

0

Trans.(cid:14)jj; s; (cid:14)0; s0/ (cid:17)

9(cid:13) :(cid:14)0 D .(cid:13) k (cid:14)jj/ ^ Trans.(cid:14); s; (cid:13) ; s0/:

In other words, you single step .(cid:14)1 k (cid:14)2/ by single stepping either (cid:14)1 or (cid:14)2 and leaving
the other process unchanged. The .(cid:14)1 ii (cid:14)2/ construct is identical, except that you are only
allowed to single step (cid:14)2 if there is no legal step for (cid:14)1. This ensures that (cid:14)1 will execute
as long as it is possible for it to do so. Finally, you single step (cid:14)jj by single stepping (cid:14), and

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

123

what is left is the remainder of (cid:14) as well as (cid:14)jj itself. This allows an unbounded number of
instances of (cid:14) to be running.

Observe that with .(cid:14)1 k (cid:14)2/, if both (cid:14)1 and (cid:14)2 are always able to execute, the amount
of interleaving between them is left completely open. It is legal to execute one of them
completely before even starting the other, and it also legal to switch back and forth after
each primitive or wait action. It is not hard to deﬁne, however, new concurrency constructs
kmin and kmax that require the amount of interleaving to be minimized or maximized
respectively. We omit the details.

Regarding interrupts, it turns out that these can be explained using other constructs of

ConGolog:

h(cid:30) ! (cid:14)i

defD while Interrupts_running do
if (cid:30) then (cid:14) else False?

To see how this works, ﬁrst assume that the special ﬂuent Interrupts_running is identically
True. When an interrupt h(cid:30) ! (cid:14)i gets control, it repeatedly executes (cid:14) until (cid:30) becomes
false, at which point it blocks, releasing control to anyone else able to execute. Note
that according to the above deﬁnition of Trans, no transition occurs between the test
condition in a while-loop or an if-then-else and the body. In effect, if (cid:30) becomes false,
the process blocks right at the beginning of the loop, until some other action makes (cid:30)
true and resumes the loop. To actually terminate the loop, we use a special primitive
action stop_interrupts, whose only effect is to make Interrupts_running false. Thus, we
imagine that to execute a program (cid:14) containing interrupts, we would actually execute
the program fstart_interrupts I .(cid:14) ii stop_interrupts/g which has the effect of stopping all
blocked interrupt loops in (cid:14) at the lowest priority, i.e., when there are no more actions in (cid:14)
that can be executed.

Finally, let us consider exogenous actions. These are primitive actions that may occur
without being part of a user-speciﬁed program. We assume that in the background theory,
the user declares, using a predicate Exo, which actions can occur exogenously. We deﬁne
a special program for exogenous events:

(cid:14)EXO

defD .(cid:25) a: Exo.a/?I a/(cid:3):

Executing this program involves performing zero, one, or more nondeterministically
chosen exogenous events. 7 Then we make the user-speciﬁed program (cid:14) run concurrently
with (cid:14)EXO:

(cid:14) k (cid:14)EXO:

In this way we allow exogenous actions whose preconditions are satisﬁed to asynchro-
nously occur (outside the control of (cid:14)) during the execution of (cid:14).

7 Observe the use of (cid:25) : the program nondeterministically chooses an action a, tests that this a is an exogenous

event, and executes it.

124

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

5.1. Formal properties of Trans and Final without procedures

We are going to show that the axioms for Trans and Final for the whole of ConGolog are
deﬁnitional, in the sense that they completely characterize Trans and Final for programs
without procedures.

Lemma 1. For any ConGolog program term (cid:14).Ex/ containing only variables Ex of sort
object or action, there exist two formulas (cid:8).Ex; s; (cid:14); s0/ and (cid:9) .Ex; s/, where Ex; s; (cid:14)0; s0 and
Ex; s are the only free variables in (cid:8) and in (cid:9) respectively, that do not mention Final and
Trans, and are such that:

C jD 8Ex; s; (cid:14)0; s0: Trans.(cid:14).Ex/; s; (cid:14)0; s0/ (cid:17) (cid:8).Ex; s; (cid:14)0; s0/;
C jD 8Ex; s: Final.(cid:14).Ex/; s/ (cid:17) (cid:9) .Ex; s/:

(1)

(2)

Proof. For both (1) and (2), the proof is similar; it is done by induction on the program
structure considering as base cases programs of the form nil, a, and (cid:30)?. Base cases: the
thesis is an immediate consequence of the axioms of Trans and Final since the right-hand
side of the equivalences does not mention Trans and Final. Inductive cases: by inspection,
all the axioms have on the right-hand side simpler program terms, which contain only
variables of sort object or action, as the ﬁrst argument to Trans and Final, hence the thesis
is a straightforward consequence of the inductive hypothesis. 2

It follows from the lemma that the axioms in T and F , together with the axioms for
encoding of programs as ﬁrst-order terms, completely determine the interpretation of the
predicates Trans and Final on the basis of the interpretation of the other predicates. That is
T and F implicitly deﬁne the predicates Trans and Final. Formally, we have the following
theorem:

Theorem 2. There are no pair of models of C that differ only in the interpretation of the
predicates Trans and Final.

Proof. By contradiction. Suppose that there are two models M1 and M2 of C that agree
in the interpretation of all nonlogical symbols (constant, function, predicates) other than
either Trans or Final. Let’s say that they disagree on Trans, i.e., there is a tuple of
domain values . O(cid:14); Os; O(cid:14)0; Os0/ such that . O(cid:14); Os; O(cid:14)0; Os0/ 2 TransM1 and . O(cid:14); Os; O(cid:14)0; Os0/ =2 TransM2 .
Considering the structure of the sort programs (see Appendix A), we have that for every
value of the domain of sort programs O(cid:14) there is a program term (cid:14).Ex/, containing only
variables Ex of sort object or action, such that for some assignment (cid:27) to Ex, (cid:14)M1;(cid:27) D (cid:14)M2;(cid:27) D
O(cid:14). Now let us consider three variables s; (cid:14)0; s0 and an assignment (cid:27) 0 such that (cid:27) 0.Ex/ D (cid:27) .Ex/,
(cid:27) 0.s/ D Os, (cid:27) 0.(cid:14)0/ D O(cid:14)0, and (cid:27) 0.s0/ D Os0. By Lemma 1, there exists a formula (cid:8) such that
neither Trans nor Final occurs in (cid:8) and:
Mi; (cid:27) 0 jD Trans.(cid:14); s; (cid:14)0; s0/

iff Mi; (cid:27) 0 jD (cid:8).Ex; s; (cid:14)0; s0/

i D 1; 2:

Since, M1; (cid:27) 0 jD (cid:8).Ex; s; (cid:14)0; s0/ iff M2; (cid:27) 0 jD (cid:8).Ex; s; (cid:14)0; s0/, we get a contradiction. 2

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

125

6. Some examples

6.1. Two robots lifting a table

Our ﬁrst example involves a simple case of concurrency: two robots that jointly lift a
table. Test actions are used to synchronize the robots’ actions so that the table does not tip
so much that objects on it fall off. Two instances of the same program are used to control
the robots.

(cid:15) Objects:

Two agents: 8r: Robot.r/ (cid:17) r D Rob1 _ r D Rob2:
Two table ends: 8e: TableEnd.e/ (cid:17) e D End1 _ e D End2:

(cid:15) Primitive actions:

grab.rob; end/;

release.rob; end/;

vmove.rob; z/ move robot arm up or down by z units:

(cid:15) Primitive ﬂuents:

Holding.rob; end; s/;
vpos.end; s/ D z

height of the table end:

(cid:15) Initial state:

8r; e: :Holding.r; e; S0/;
8e: vpos.e; S0/ D 0:

(cid:15) Precondition axioms:

0

Poss.grab.r; e/; s/ (cid:17) 8r
Poss.release.r; e/; s/ (cid:17) Holding.r; e; s/;
Poss.vmove.r; z/; s/ (cid:17) True:

: :Holding.r

0

; e; s/ ^ 8e

0

: :Holding.r; e

0

; s/;

(cid:15) Successor state axioms:

Holding.r; e; do.a; s// (cid:17)

a D grab.r; e/ _ Holding.r; e; s/ ^ a 6D release.r; e/;

vpos.e; do.a; s// D p (cid:17)

9r; z:.a D vmove.r; z/ ^ Holding.r; e; s/ ^ p D vpos.e; s/ C z/ _
9r: a D release.r; e/ ^ p D 0 _
p D vpos.e; s/ ^ :9r; z:.a D vmove.r; z/ ^ Holding.r; e; s// ^

:9r: a D release.r; e/:

126

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

The goal here is to get the table up, but to keep it sufﬁciently level so that nothing falls off.
We can deﬁne these as follows:

defD vpos.End1; s/ > H ^ vpos.End2; s/ > H
TableUp.s/
(both ends of the table are higher than some threshold H ),

defD jvpos.End1; s/ (cid:0) vpos.End2; s/j 6 Tol

Level.s/
(both ends are at the same height to within a threshold Tol).

So the goal is

Goal.s/

defD TableUp.s/ ^ 8s0:s0 6 s (cid:27) Level.s0/

and the claim is that this goal can be achieved by having Rob1 and Rob2 each concurrently
execute the same procedure ctrl deﬁned as:

proc ctrl.rob/

(cid:25)e:TTableEnd.e/?I grab.rob; e/UI
while :TableUp.now/ do

SafeToLift.rob; now/?I
vmove.rob; Amount/

end,

where Amount is some constant such that 0 < Amount < Tol, and SafeToLift is deﬁned by

SafeToLift.rob; s/

defD 9e; e0: e 6D e0 ^ TableEnd.e/ ^ TableEnd.e0/ ^

Holding.rob; e; s/ ^ vpos.e/ 6 vpos.e0/ C Tol (cid:0) Amount:

Here, we use procedures simply for convenience and the reader can take them as
abbreviations. A formal treatment for procedures will be provided in Section 7.

So formally, the claim is: 8

C [ D jD 8s:Do.ctrl.Rob1/kctrl.Rob2/; S0; s/ (cid:27) Goal.s/:

Here is an informal sketch of a proof. Do holds if and only if there is a ﬁnite sequence
of transitions from the initial conﬁguration .ctrl.Rob1/kctrl.Rob2/; S0/ to a conﬁguration
that is Final. A program involving two concurrent processes can only get to a Final
conﬁguration by reaching a conﬁguration that is Final for both processes. The processes
in our program involve while-loops, which only reach a ﬁnal conﬁguration when the loop
condition becomes is false. So the table must be high enough in the ﬁnal situation.

It remains to be shown that the table stayed level. Let vi stand for the action
vmove.robi ; Amount/: Suppose to the contrary that the table went too high on End1 held
by Rob1; and consider the ﬁrst conﬁguration where this became true. This situation in this
conﬁguration is of the form do.v1; s/ where

vpos.End1; do.v1; s// > vpos.End2; do.v1; s// C Tol:

8 Actually, proper termination of the program is also guaranteed. However, stating this condition formally, in

the case of concurrency, requires additional machinery, since 9s:Do.ctrl.Rob1/kctrl.Rob2/; S0; s/ is too weak.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

127

However, at some earlier conﬁguration, we had to have SafeToLift.Rob1; s0/ with no
intervening actions by Rob1; otherwise the last v1 would not have been executed. This
means that we have

vpos.End1; s0/ 6 vpos.End2; s0/ C Tol (cid:0) Amount:

However, if all the actions between s0 and s are by Rob2; since Rob2 can only increase the
value of vpos.End2/; it follows that

vpos.End1; s/ 6 vpos.End2; s/ C Tol (cid:0) Amount;

that is, that SafeToLift was also true just before the ﬁnal v1 action. This contradicts the
assumption that v1 only adds Amount to the value of vpos.End1/.

6.2. A reactive multi-elevator controller

Our next example involves a reactive controller for a bank of elevators; it illustrates the
use of interrupts and prioritized concurrency. The example will use the following terms
(where e stands for an elevator):
(cid:15) Ordinary primitive actions:

goDown.e/
goUp.e/
buttonReset.n/
toggleFan.e/
ringAlarm

(cid:15) Exogenous primitive actions:
reqElevator.n/
changeTemp.e/
detectSmoke
resetAlarm
(cid:15) Primitive ﬂuents:

ﬂoor.e; s/ D n
temp.e; s/ D t
FanOn.e; s/
ButtonOn.n; s/
Smoke.s/
(cid:15) Deﬁned ﬂuents:

move elevator down one ﬂoor
move elevator up one ﬂoor
turn off call button of ﬂoor n
change the state of elevator fan
ring the smoke alarm.

call button on ﬂoor n is pushed
the elevator temperature changes
the smoke detector ﬁrst senses smoke
the smoke alarm is reset.

the elevator is on ﬂoor n, 1 6 n 6 6
the elevator temperature is t
the elevator fan is on
call button on ﬂoor n is on
smoke has been detected.

TooHot.e; s/

TooCold.e; s/

defD temp.e; s/ > 1;
defD temp.e; s/ < (cid:0)1:

We begin with the following basic action theory for the above primitive actions and ﬂuents:

(cid:15) Initial state:

ﬂoor.e; S0/ D 1; :FanOn.S0/;

temp.e; S0/ D 0;

ButtonOn.3; S0/; ButtonOn.6; S0/:

128

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

(cid:15) Exogenous actions:

8a:Exo.a/ (cid:17) a D detectSmoke _ a D resetAlarm _

a D changeTemp.e/ _ 9n:a D reqElevator.n/:

(cid:15) Precondition axioms:

Poss.goDown.e/; s/ (cid:17) ﬂoor.e; s/ 6D 1;
Poss.goUp.e/; s/ (cid:17) ﬂoor.e; s/ 6D 6;
Poss.buttonReset.n/; s/ (cid:17) True;
Poss.toggleFan.e/; s/ (cid:17) True;
Poss.ringAlarm/ (cid:17) True;
Poss.reqElevator.n/; s/ (cid:17) .1 6 n 6 6/ ^ :ButtonOn.n; s/;
Poss.changeTemp; s/ (cid:17) True;
Poss.detectSmoke; s/ (cid:17) :Smoke.s/;
Poss.resetAlarm; s/ (cid:17) Smoke.s/:

(cid:15) Successor state axioms:

ﬂoor.e; do.a; s// D n (cid:17)

.a D goDown.e/ ^ n D ﬂoor.e; s/ (cid:0) 1/ _
.a D goUp.e/ ^ n D ﬂoor.e; s/ C 1/ _
.n D ﬂoor.e; s/ ^ a 6D goDown.e/ ^ a 6D goUp.e//;

temp.e; do.a; s// D t (cid:17)

.a D changeTemp.e/ ^ FanOn.e; s/ ^ t D temp.e; s/ (cid:0) 1/ _
.a D changeTemp.e/ ^ :FanOn.e; s/ ^ t D temp.e; s/ C 1/ _
.t D temp.e; s/ ^ a 6D changeTemp.e//;

FanOn.e; do.a; s// (cid:17)

.a D toggleFan.e/ ^ :FanOn.e; s// _
.FanOn.e; s/ ^ a 6D toggleFan.e//;

ButtonOn.n; do.a; s// (cid:17)
a D reqElevator.n/ _
.ButtonOn.n; s/ ^ a 6D buttonReset.n//;

Smoke.do.a; s// (cid:17)
a D detectSmoke _
.Smoke.s/ ^ a 6D resetAlarm/:

Note that many ﬂuents are affected by both exogenous and programmed actions. For
instance, the ﬂuent ButtonOn is made true by the exogenous action reqElevator (i.e.,
someone calls for an elevator) and made false by the programmed action buttonReset (i.e.,
when an elevator serves a ﬂoor).

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

129

Now we are ready to consider a basic elevator controller for an elevator e. It might be

deﬁned by something like:

while 9n:ButtonOn.n/ do

(cid:25)n:fBestButton.n/?I serveFloor.e; n/g;

while ﬂoor.e/ 6D 1 do goDown.e/.

The ﬂuent BestButton would be deﬁned to select among all buttons that are currently
on, the one that will be served next. For example, it might choose the button that has
been on the longest. For our purposes, we can take it to be any ButtonOn. The procedure
serveFloor.e; n/ would consist of the actions the elevator would take to serve the request
from ﬂoor n. For our purposes, we can use:

proc serveFloor.e; n/

while ﬂoor.e/ < n do goUp.e/;
while ﬂoor.e/ > n do goDown.e/;
buttonReset.n/

end.

We have not bothered formalizing the opening and closing of doors, or other nasty
complications like passengers.

As with Golog, we try to prove an existential and look at the bindings for the s. They
will be of the form do.Ea; S0/ where Ea are the actions to perform. In particular, using this
controller program (cid:14), we would get execution traces like

C [ D jD Do.(cid:14) k (cid:14)EXO; S0; do.Tu; u; b3; u; u; u; b6; d; d; d; d; dU; S0//;
C [ D jD Do.(cid:14) k (cid:14)EXO; S0; do.Tu; r4; u; b3; u; b4; u; u; r2; b6; d; d; d; d; b2; dU; S0//;

: : :

where u D goUp.e/, d D goDown.e/, bn D buttonReset.n/, rn D reqElevator.n/, and D is
the basic action theory speciﬁed above. In the ﬁrst run there were no exogenous actions,
while in the second, two elevator requests were made.

This controller does have a big drawback, however: if no buttons are on, the ﬁrst loop
terminates, the elevator returns to the ﬁrst ﬂoor and stops, even if buttons are pushed on its
way down. It would be better to structure it as two interrupts:

h9n:ButtonOn.n/ !

(cid:25)n:fBestButton.n/?I serveFloor.e; n/gi;

h ﬂoor.e/ 6D 1 ! goDown.e/i

with the second at lower priority. So if no buttons are on, and you’re not on the ﬁrst ﬂoor,
go down a ﬂoor, and reconsider; if at any point buttons are pushed exogenously, pick one
and serve that ﬂoor, before checking again. Thus, the elevator only quits when it is on the
ﬁrst ﬂoor with no buttons on.

130

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

With this scheme, it is easy to handle emergency or high-priority requests. We would

add

h9n:EButtonOn.n/ !

(cid:25)n:fEButtonOn.n/?I serveEFloor.e; n/gi

as an interrupt with a higher priority than the other two (assuming suitable additional
actions and ﬂuents).

To deal with the fan, we can add two new interrupts:

hTooHot.e/ ^ :FanOn.e/ ! toggleFan.e/i;
hTooCold.e/ ^ FanOn.e/ ! toggleFan.e/i:

These should both be executed at the very highest priority. In that case, while serving a
ﬂoor, whatever that amounts to, if the temperature ever becomes too hot, the fan will be
turned on before continuing, and similarly if it ever becomes too cold. Note that if we
did not check for the state of the fan, this interrupt would loop repeatedly, never releasing
control to lower priority processes.

Finally, imagine that we would like to ring a bell if smoke is detected, and disrupt normal

service until the smoke alarm is reset exogenously. To do so, we add the interrupt:

hSmoke ! ringAlarmi

with a priority that is less than the emergency button, but higher than normal service. Once
this interrupt is triggered, the elevator will stop and ring the bell repeatedly. It will handle
the fan and serve emergency requests, however.

Putting all this together, we get the following controller:

.hTooHot.e/ ^ :FanOn.e/ ! toggleFan.e/i k
hTooCold.e/ ^ FanOn.e/ ! toggleFan.e/i/ ii
h9n:EButtonOn.n/ !

(cid:25)n:fEButtonOn.n/?I serveEFloor.e; n/gi ii

hSmoke ! ringAlarmi ii
h9n:ButtonOn.n/ !

(cid:25)n:fBestButton.n/?I serveFloor.e; n/gi ii

h ﬂoor.e/ 6D 1 ! goDown.e/i:

Using this controller (cid:14)r , we would get execution traces like

C [ D jD Do.(cid:14)r k (cid:14)EXO; S0; do.Tu; u; b3; u; u; u; b6; d; d; d; d; r5; u; u; u; b5; d; d; d;

dU; S0//;

C [ D jD Do.(cid:14)r k (cid:14)EXO; S0; do.Tu; u; b3; u; z; a; a; a; a; h; u; u; b6; d; d; d; d; dU;

S0//;

C [ D jD Do.(cid:14)r k (cid:14)EXO; S0; do.Tu; t; u; b3; u; t; f; u; t; t; u; t; b6; d; t; f; d; t; d; d;

dU; S0//;

: : :

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

131

where z D detectSmoke, a D ringAlarm, h D resetAlarm, t D changeTemp, and f D
toggleFan. In the ﬁrst run, we see that this controller does handle requests that come in
while the elevator is on its way to retire on the bottom ﬂoor. The second run illustrates how
the controller reacts to smoke being detected by ringing the alarm. The third run shows
how the controller reacts immediately to temperature changes while it is serving ﬂoors.
Note that this elevator controller uses 5 different levels of priority. It could have been
programmed in Golog without interrupts, but the code would have been a lot messier.

Now let us suppose that we would like to write a controller that handles two independent
elevators. In ConGolog, this can be done very elegantly using .(cid:14)1 k (cid:14)2/, where (cid:14)1 is the
above program with e replaced by Elevator1 and (cid:14)2 is the same program with e replaced
by Elevator2. This allows the two processes to work completely independently (in terms
of priorities). 9 For n elevators, we would use .(cid:14)1 k (cid:1) (cid:1) (cid:1) k (cid:14)n/.

6.3. A client–server system

In some applications, it is useful to have an unbounded number of instances of a process
running concurrently. For example in an FTP server, we may want an instance of a manager
process for each active FTP session. This can be programmed using the (cid:14)jj concurrent
iteration construct.

Let us give a high-level sketch of how this might be done. Suppose that there is
an exogenous action newClient.cid/ that occurs when a new client with the ID cid
ﬁrst requests service. Also assume that a procedure serve.cid/ has been deﬁned, which
implements the behavior required for the server for a given client. To set up the system, we
run the program:

T(cid:25) cid: acquire.cid/I serve.cid/UjjI
:9cid: .ClientWaiting.cid//?

Here, we assume that when the exogenous action newClient.cid/ occurs, it makes the
ﬂuent ClientWaiting.cid/ true. Then, the only way the computation can be completed is
by generating a new process that ﬁrst acquires the client by doing acquire.cid/, and then
serves it. We formalize this as follows:

Poss.acquire.cid/; s/ (cid:17) ClientWaiting.cid/;

ClientWaiting.cid; do.a; s// (cid:17)

a D newClient.cid/ _ ClientWaiting.cid; s/ ^ a 6D acquire.cid/U:

Then, only a single process can acquire a given client, since acquire is only possible
when ClientWaiting.cid/ is true and performing it makes this ﬂuent false. The whole
program can only reach a ﬁnal conﬁguration if it forks exactly the right number of server
processes: at least one for each client because a server can only acquire one client, and no
more than one for each client because servers can be activated only if they can acquire a
client.

9 Of course, when an elevator is requested on some ﬂoor, both elevators may decide to serve it. It is easy to
program a better strategy that coordinates the elevators: when an elevator decides to serve a ﬂoor, it immediately
makes a ﬂuent true for that ﬂoor, and the other elevator will not serve a ﬂoor for which that ﬂuent is already true.

132

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

6.4. Actions with extended duration

One possible criticism of our approach to concurrency is that it does not work when
we consider actions that have extended duration. Consider singing while ﬁlling the bathtub
with water, for example. If one of the actions involved is “ﬁlling the bathtub”, and the other
actions are “singing do”, “singing re”, and “singing mi”, say, then there are exactly four
possible interleavings,

Tﬁlling I do I re I miU;
Tdo I ﬁlling I re I miU;
Tdo I re I ﬁlling I miU;
Tdo I re I mi I ﬁllingU;

but none of them capture the idea of singing and ﬁlling the tub at the same time. Moreover,
the prospect of replacing the ﬁlling action by a large number of component actions (that
could be interleaved with the singing ones) is even less appealing.

To deal with this type of case, we recommend the following approach (see [33] for a
detailed presentation): instead of thinking of ﬁlling the bathtub as an action or group of
actions, think of it as a state that an agent could be in, extending possibly over many
situations. The idea is that the agent can be in many such states simultaneously, including
listening to the radio, walking, and chewing gum. For each such state, we need two
primitive actions and a ﬂuent; for the bathtub, they are startFilling, which puts the agent
into the state, and endFilling, which terminates it, as well as the ﬂuent FillingTub, which
holds in those situations where the agent is ﬁlling the tub. Formally, we would express this
with a successor state axiom as follows:

FillingTub.do.a; s// (cid:17)

a D startFilling _ FillingTub.s/ ^ a 6D endFilling:

Since the startFilling and endFilling actions can be taken to be instantaneous, the

interleaving account is once again plausible. If we deﬁne a complex action

FillTheTub

defD TstartFilling I endFillingU;

and run it concurrently with the singing, then we get these possible interleavings:

TstartFilling I endFilling I do I re I miU;
TstartFilling I do I endFilling I re I miU;
TstartFilling I do I re I endFilling I miU;
TstartFilling I do I re I mi I endFillingU;
Tdo I startFilling I endFilling I re I miU;
Tdo I startFilling I re I endFilling I miU;
Tdo I startFilling I re I mi I endFillingU;

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

133

Tdo I re I startFilling I endFilling I miU;
Tdo I re I startFilling I mi I endFillingU;
Tdo I re I mi I startFilling I endFillingU:

A better model would be something like

FillTheTub

defD TstartFilling I .waterLevel > H /? I endFillingU;

which would rule out interleavings where the ﬁlling stops too soon. The most natural way
of modeling the water level is as a continuous function of time: l D L0 C R (cid:2) t; where L0 is
the initial level, R is the rate of ﬁlling (taken to be constant), and t is the elapsed time. One
simple way to accommodate this idea within the situation calculus is to assume that every
action has a duration dur.a/ (which we could also make dependent on the situation the
action is performed in). Actions such as startFilling can have duration 0, but there must be
some action, if only a timePasses, with a non-0 duration. We then describe the waterLevel
functional ﬂuent by:

waterLevel.do.a; s// D waterLevel.s/ C waterRate.s/ (cid:2) dur.a/;

waterRate.do.a; s// D if FillingTub.s/ then R else 0:

So as long as a situation is in a ﬁlling-the-tub state, the water level rises according to the
above equation. In terms of concurrency, the result is that the only allowable interleavings
would be those where enough actions of sufﬁcient duration occur between the startFilling
and stopFilling.

Of course, this model of the continuous process of water entering the bathtub does not
allow us to predict the eventual outcome, for example, the water overﬂowing if a tap is not
turned off, etc. A more complex program, typically involving interrupts, would be required,
so that suitable “trajectory altering” actions are triggered under the appropriate conditions.

7. Extending the transition semantics to procedures

We now extend the transition semantics introduced above to deal with procedures.
Because a recursive procedure may do an arbitrary number of procedure calls before it
performs a primitive action or test, and such procedure calls are not viewed as transitions,
we must use a second-order deﬁnition of Trans and Final. In doing so, great care has to
be put in understanding the interaction between recursive procedures and the very general
form of prioritized concurrency allowed in ConGolog.

Let proc P1.Ev1/(cid:14)1 endI : : : I proc Pn.Evn/(cid:14)n end be a collection of procedure deﬁnitions.
We call such a collection an environment and denote it by Env. In a procedure deﬁnition
proc Pi .Evi /(cid:14)i end, Pi is the name of the ith procedure in Env; Evi are its formal parameters;
and (cid:14)i is the procedure body, which is a ConGolog program, possibly including both
procedure calls and new procedure deﬁnitions. We use call-by-value as the parameter
passing mechanism, and lexical (or static) scope as the scoping rule.

134

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

Formally we introduce three program constructs:
(cid:15) P .Et/ where P is a procedure name and Et actual parameters associated to the procedure
P ; as usual we replace the situation argument in the terms constituting Et by now.
P .Et / denotes a procedure call, which invokes procedure P on the actual parameters Et
evaluated in the current situation.

(cid:15) fEnvI (cid:14)g, where Env is an environment and (cid:14) is a program extended with procedures
calls. fEnvI (cid:14)g binds procedures calls in (cid:14) to the deﬁnitions given in Env. The usual
notion of free and bound apply, so for, e.g., in fproc P1./ a endI P2./I P1./g, P1 is
bound but P2 is free.

(cid:15) TEnv V P .Et /U, where Env is an environment, P a procedure name and Et actual
parameters associated to the procedure P . TEnv V P .Et /U denotes a procedure call that
has been contextualized: the environment in which the deﬁnition of P is to be looked
for is Env.

We deﬁne the semantics of ConGolog programs with procedures by deﬁning both Trans
and Final by a second-order formula (instead of a set of axioms). 10 Trans is deﬁned as
follows:

Trans.(cid:14); s; (cid:14)0; s0/ (cid:17) 8T :T: : : (cid:27) T .(cid:14); s; (cid:14)0; s0/U;

T —i.e., the set of axioms T modulo textual
where : : : stands for the conjunction of T Trans
substitution of Trans with T —and (the universal closure of) the following two assertions:
(cid:0)
(cid:14)Pi .Et/
TEnvVPi .Et/U; s; (cid:14)0; s0
(cid:0)
fEnvI (cid:14)P

T .fEnvI (cid:14)g; s; (cid:14)0; s0/ (cid:17) T
T .TEnv V P .Et /U; s; (cid:14)0; s0/ (cid:17) T

(cid:1)
;
g; s; (cid:14)0; s0

(cid:1)

;

EvP
Et TsU

where (cid:14)Pi .Et/
TEnvVPi .Et/U denotes the program (cid:14) with all procedures bound by Env and free in (cid:14)
EvP
replaced by their contextualized version (this gives us the lexical scope), and where (cid:14)P
EtTsU
denotes the body of the procedure P in Env with formal parameters Ev substituted by the
actual parameters Et evaluated in the current situation.

Similarly, Final is deﬁned as follows:

Final.(cid:14); s/ (cid:17) 8F:T: : : (cid:27) F .(cid:14); s/U;

where : : : stands for the conjunction of F Final
substitution of Final with F —and (the universal closure of) the following assertions:
(cid:1)

F —i.e., the set of axioms F modulo textual

F .fEnvI (cid:14)g; s/ (cid:17) F

F .TEnv V P .Et/U; s/ (cid:17) F

(cid:0)
(cid:14)Pi .Et/
TEnvVPi .Et/U; s
(cid:0)
fEnvI (cid:14)P

;

EvP
Et TsU

g; s

(cid:1)
:

Note that no assertions for (uncontextualized) procedure calls are present in the deﬁnitions
of Trans and Final. Indeed a procedure call which cannot be bound to a procedure
deﬁnition neither can do transitions nor can be considered successfully completed.

10 For compatibility with the formalization in Section 4, we treat Trans and Final as predicates, although it is
clear that they could be understood as abbreviations for the second-order formulas.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

135

Observe also the two uses of substitution to deal with procedure calls. When a program
with an associated environment is executed, for all procedure calls bound by Env,
we simultaneously substitute the corresponding procedure calls, contextualized by the
environment of the procedure in order to deal with further procedure calls according to
the static scope rules. Then when a (contextualized) procedure is actually executed, the
actual parameters are ﬁrst evaluated in the current situation, and then are substituted for
the formal parameters in the procedure bodies, 11 thus yielding call-by-value parameter
passing.

The following example program (cid:14)StSc illustrates ConGolog’s static scoping:

f proc P1./

a
endI
proc P2./
P1./
endI
proc P3./
f proc P1./

b
endI
P2./I P1./

g
endI
P3./
g.

One can show that for this program, the sequence of atomic actions performed will be a
followed by b (assuming that both a and b are always possible):

8s:TPoss.a; s/ ^ Poss.b; s/U (cid:27)
8s; s

:TDo.(cid:14)StSc; s; s

/ (cid:17) s

0

0

0 D do.b; do.a; s//U:

To see this consider the following. Let

Env1

defD proc P1./ a end;

proc P2./ P1./ end;
proc P3./ fEnv2I P2./I P1./g end,

Env2

defD proc P1./ b end.

Then it is easy to see that:
Trans.(cid:14)StSc; s; (cid:14)0; s0/

(cid:17) Trans.fEnv1I P3./g; s; (cid:14)0; s0/

11 To be more precise, every formal parameter v is substituted by a term of the form nameOf.tTsU/, where again
nameOf is used to convert situation calculus objects/actions into program terms of the corresponding sort (see
Appendix A).

136

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

(cid:17) Trans.TEnv1 V P3./U; s; (cid:14)0; s0/
(cid:17) Trans.fEnv1I fEnv2I P2./I P1./gg; s; (cid:14)0; s0/
0
(cid:17) Trans.fEnv2I TEnv1 V P2./UI P1./g; s; (cid:14)
/
; s
(cid:17) Trans.TEnv1 V P2./UI TEnv2 V P1./U; s; (cid:14)0; s0/
(cid:17) Trans.fEnv1I P1./gI TEnv2 V P1./U; s; (cid:14)0; s0/
(cid:17) Trans.TEnv1 V P1./UI TEnv2 V P1./U; s; (cid:14)0; s0/
(cid:17) Trans.aI TEnv2 V P1./U; s; (cid:14)0; s0/
0 D do.a; s/ ^ (cid:14)
(cid:17) Poss.a; s/ ^ s

0

0 D .nilI TEnv2 V P1./U/:

Similarly, one can show that: Trans.TEnv2 V P1./U; do.a; s/; nil; do.b; do.a; s/// and
Final.nil; do.b; do.a; s///, which yields the thesis.

Our next example illustrates ConGolog’s call-by-value parameter passing:

f proc P .n/

if .n D 1/ then nil

else goDownI P .n (cid:0) 1/

endI
P . ﬂoor/

g.

Intuitively, this program is intended to bring an elevator down to the bottom ﬂoor of a
building. If we run the program starting in situation S0, the procedure call P . ﬂoor/ invokes
P with the value of the functional ﬂuent ﬂoor in S0, i.e., P is called with ﬂoorTS0U, the ﬂoor
the elevator is on in S0, as actual parameter. If ConGolog used call-by-name parameter
passing, P would be invoked with the term “ﬂoor” as actual parameter, and the elevator
would only go halfway to the bottom ﬂoor. Indeed at each iteration of the procedure the
call P .n (cid:0) 1/ would be evaluated by textually replacing n by ﬂoor, which at that moment
has already decreased by 1.

As mentioned earlier, the need for a second-order deﬁnition of Trans.(cid:14); s; (cid:14)0; s0/ and
Final.(cid:14); s/ when procedures are introduced comes from recursive procedures. The second-
order deﬁnition allows us to assign a formal semantics to every such procedure, including
viciously circular ones. The deﬁnition of Trans disallows the execution of such ill-
formed procedures. At the same time the deﬁnition of Final considers them not to have
completed (nonﬁnal). For example, the program fproc P ./ P ./ endI P ./g does not have
any transitions, but it is not ﬁnal for any situation s. 12

7.1. Formal properties of Trans and Final with procedures

We observe that the second-order deﬁnitions of Trans and Final can easily be put in the

following form:

Trans.(cid:14); s; (cid:14)

; s

0

0

/ (cid:17)

(cid:27) T .(cid:14); s; (cid:14)0; s0/;

8T :T8(cid:14)1; s1; (cid:14)2; s2: (cid:8)Trans.T ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) T .(cid:14)1; s1; (cid:14)2; s2/U

12 Note that both Golog and ConGolog do not allow for Boolean procedures to be used in tests. Introducing such
kind of procedures requires particular care to avoid counterintuitive implications.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

137

Final.(cid:14); s; (cid:14)0; s0/ (cid:17)

8F:T8(cid:14)1; s1: (cid:8)Final.F; (cid:14)1; s1/ (cid:17) F .(cid:14)1; s1/U

(cid:27) F .(cid:14); s/;

where (cid:8)Trans and (cid:8)Final are obtained by rewriting each of the assertions in the deﬁnition
of Trans and Final so that only variables appear in the left-hand part of the equations, i.e.:

T .(cid:14); s; (cid:14)0; s0/ (cid:17) (cid:30)t .T ; (cid:14); s; (cid:14)0; s0/;

F .(cid:14); s/ (cid:17) (cid:30)f .F; (cid:14); s/;

and then getting the disjunction of all right-hand sides, which are mutually exclusive since
each of them deals with programs of a speciﬁc form.

From such deﬁnitions, natural “induction principles” emerge (cf. the discussion on
extracting induction principles from inductive deﬁnitions in [34]). These are principles
saying that to prove that a property P holds for instances of Trans and Final, it sufﬁces
to prove that the property P is closed under the assertions in the deﬁnition of Trans and
Final, i.e.:

(cid:8)Trans.P ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) P .(cid:14)1; s1; (cid:14)2; s2/;
(cid:8)Final.P ; (cid:14)1; s1/ (cid:17) P .(cid:14)1; s1/:
Formally we can state the following theorem:

Theorem 3. The following sentences are consequences of the second-order deﬁnitions of
Trans and Final respectively:

8P :T8(cid:14)1; s1; (cid:14)2; s2: (cid:8)Trans.P ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) P .(cid:14)1; s1; (cid:14)2; s2/U (cid:27)

8(cid:14); s; (cid:14)0; s0: Trans.(cid:14); s; (cid:14)0; s0/ (cid:27) P .(cid:14); s; (cid:14)0; s0/;

8P :T8(cid:14)1; s1: (cid:8)Final.P ; (cid:14)1; s1/ (cid:17) P .(cid:14)1; s1/U (cid:27)
0
0
; s

8(cid:14); s: Final.(cid:14); s; (cid:14)

/ (cid:27) P .(cid:14); s/:

Proof. We prove only the ﬁrst sentence. The proof of the second sentence is analogous.

By deﬁnition we have:

0

0

0

0

8(cid:14); s; (cid:14)

0

; s

: Trans.(cid:14); s; (cid:14)

; s

0

/ (cid:17)

8P :T8(cid:14)1; s1; (cid:14)2; s2: (cid:8)Trans.P ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) P .(cid:14)1; s1; (cid:14)2; s2/U

(cid:27) P .(cid:14); s; (cid:14)0; s0/:

By considering the only-if part of the above equivalence, we get:

8(cid:14); s; (cid:14)

0

; s

: Trans.(cid:14); s; (cid:14)

; s

0

/ ^

8P :T8(cid:14)1; s1; (cid:14)2; s2: (cid:8)Trans.P ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) P .(cid:14)1; s1; (cid:14)2; s2/U

(cid:27) P .(cid:14); s; (cid:14)0; s0/:

So moving the quantiﬁers around we get:

8P :T8(cid:14)1; s1; (cid:14)2; s2: (cid:8)Trans.P ; (cid:14)1; s1; (cid:14)2; s2/ (cid:17) P .(cid:14)1; s1; (cid:14)2; s2/U ^

8(cid:14); s; (cid:14)0; s0: Trans.(cid:14); s; (cid:14)0; s0/

(cid:27) P .(cid:14); s; (cid:14)0; s0/;

and hence the thesis. 2

138

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

These induction principles allow us to prove that Trans and Final for programs with

procedures can be considered an extension of those for programs without procedures.

Theorem 4. With respect to ConGolog programs without procedures, Trans and Final
introduced above are equivalent to the versions introduced in Section 4.

Proof. Let us denote Trans deﬁned by the second-order sentence as TransSOL and Trans
implicitly deﬁned through axioms in Section 4 as TransFOL. Since procedures are not
considered we can drop, without loss of generality, the assertions for fEnvI (cid:14)g and TEnv V
P .Et/U in the deﬁnition of TransSOL. Then:

(cid:15) TransSOL.(cid:14); s; (cid:14)0; s0/ (cid:27) TransFOL.(cid:14); s; (cid:14)0; s0/,

is proven simply by noting that
TransFOL satisﬁes (is closed under) the assertions in the deﬁnition of TransSOL, and
then using Theorem 3.

(cid:15) TransFOL.(cid:14); s; (cid:14)0; s0/ (cid:27) TransSOL.(cid:14); s; (cid:14)0; s0/, is proven by induction on the structure
of (cid:14) considering as base cases nil, a, and (cid:30)?, and then applying the induction
argument.

Similarly for Final. 2

It is interesting to examine whether Trans and Final introduced above are themselves
closed under the assertions in their deﬁnitions. For Final a positive answer can be
established:

Theorem 5. The following sentence is a consequence of the second-order deﬁnition of
Final:

(cid:8)Final.Final.(cid:14); s/; (cid:14); s/ (cid:17) Final.(cid:14); s/:

Proof. Observe that (cid:8)Final is monotonic, 13 i.e.:

8Z1; Z2:T8(cid:14); s:Z1.(cid:14); s/ (cid:27) Z2.(cid:14); s/U (cid:27) T8(cid:14); s:(cid:8)Final.Z1; (cid:14); s/ (cid:27) (cid:8)Final.Z2; (cid:14); s/U:
Hence the thesis is a direct consequence of the Tarski–Knaster ﬁxpoint theorem [40]. 2

For Trans an analogous result does not hold in general. Indeed consider the following

program (cid:14)q :

f proc Q./
Q./ ii a
endI
Q./
g.

Observe that the deﬁnition of Trans implies that Trans.(cid:14)q ; s; (cid:14)0; s0/ (cid:17) False. Hence if Trans
was closed under (cid:8)Trans, then we would have Trans.(cid:14)q ii a; s; (cid:14)0; s0/ (cid:17) Trans.a; s; (cid:14)0; s0/,
which would imply that Trans.(cid:14)q ; s; (cid:14)0; s0/ (cid:17) Trans.a; s; (cid:14)0; s0/. Contradiction.

13 In fact syntactically monotonic.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

139

Obviously there are several classes of ConGolog programs that are closed under (cid:8)Trans.
For instance, if we disallow prioritized concurrency in procedures we get one such class.
Another such class is that obtained by allowing prioritized concurrency to appear only in
nonrecursive procedures. Yet another quite general class is immediately obtainable from
what is discussed next.

8. First-order Trans and Final for procedures

In this section we investigate conditions that allow us to replace the second-order
deﬁnitions of Trans and Final for programs with procedures by the ﬁrst-order deﬁnitions,
as in the case where procedures are not allowed.

8.1. Guarded conﬁgurations

We deﬁne a quite general condition on conﬁgurations (pairs of programs and situations)
that guarantees the possibility of using ﬁrst-order axioms for Trans and Final for
procedures as well. To this end we introduce a notion of “conﬁguration rank”. Intuitively, a
conﬁguration is of rank n if and only if makes at most n (recursive) procedure calls before
trying to make an actual program step (either an atomic action or a test).

We deﬁne the rank of a conﬁguration inductively. A conﬁguration is of rank n denoted

by Rank.n; (cid:14); s/ if and only if:

Rank.n; nil; s/ (cid:17) True;
Rank.n; a; s/ (cid:17) True;
Rank.n; (cid:30)?; s/ (cid:17) True;
Rank.n; (cid:14)1I (cid:14)2; s/ (cid:17) Rank.n; (cid:14)1; s/ ^ .Final.(cid:14)1; s/ (cid:27) Rank.n; (cid:14)2; s//;
Rank.n; (cid:14)1 j (cid:14)2; s/ (cid:17) Rank.n; (cid:14)1; s/ ^ Rank.n; (cid:14)2; s/;
Rank.n; (cid:25)v:(cid:14); s/ (cid:17) 8x:Rank.n; (cid:14)v
Rank.n; (cid:14)(cid:3); s/ (cid:17) Rank.n; (cid:14); s/;
Rank.n; if (cid:30) then (cid:14)1 else (cid:14)2; s/ (cid:17) (cid:30)TsU ^ Rank.n; (cid:14)1; s/ _
:(cid:30)TsU ^ Rank.n; (cid:14)2; s/;

x ; s/;

Rank.n; while (cid:30) do (cid:14); s/ (cid:17) (cid:30)TsU (cid:27) Rank.n; (cid:14); s/;
Rank.n; (cid:14)1 k (cid:14)2; s/ (cid:17) Rank.n; (cid:14)1; s/ ^ Rank.n; (cid:14)2; s/;
Rank.n; (cid:14)1 ii (cid:14)2; s/ (cid:17) Rank.n; (cid:14)1; s/ ^

Rank.n; (cid:14)jj; s/ (cid:17) Rank.n; (cid:14); s/;
(cid:0)
n; (cid:14)Pi .Et/
Rank.n; fEnvI (cid:14)g; s/ (cid:17) Rank
TEnvVPi .Et/U; s
(cid:0)
Rank.n; TEnv V P .Et/U; s/ (cid:17) Rank
n (cid:0) 1; fEnvI (cid:14)P

(cid:1)

;

(cid:1)

:

EvP
Et TsU

g; s

..:9(cid:14)0

1; s0:Trans.(cid:14)1; s; (cid:14)0

1; s0// (cid:27) Rank.n; (cid:14)2; s//;

140

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

A conﬁguration .(cid:14); s/ is guarded if and only if it is of rank n for some n:

Guarded.(cid:14); s/

defD 9n: Rank.n; (cid:14); s/:

8.2. First-order Trans and Final for procedures

For guarded conﬁgurations, we do not need to use the second-order deﬁnitions of Trans
and Final when dealing with procedures. Instead we can use the ﬁrst-order axioms in
Section 4 together with the following: 14
(cid:0)
(cid:14)Pi .Et/
Trans.fEnvI (cid:14)g; s; (cid:14)0; s0/ (cid:17) Trans
TEnvVPi .Et/U; s; (cid:14)0; s0
(cid:0)
Trans.TEnv V P .Et/U; s; (cid:14)0; s0/ (cid:17) Trans
fEnvI (cid:14)P

(cid:1)
;
g; s; (cid:14)0; s0

(cid:1)
;

EvP
EtTsU

(cid:0)
(cid:14)Pi .Et/
Final.fEnvI (cid:14)g; s/ (cid:17) Final
TEnvVPi .Et/U; s
(cid:0)
Final.TEnv V P .Et/U; s/ (cid:17) Final
fEnvI (cid:14)P

(cid:1)

;

EvP
EtTsU

g; s

(cid:1)

:

Let us call TransFOL and FinalFOL the predicates determined by the ﬁrst-order axioms
and TransSOL and FinalSOL the original predicates determined by the second-order
deﬁnition for procedures. We can prove the following result:

Theorem 6.

Guarded.(cid:14); s/ (cid:27)

8(cid:14)0; s0:TransSOL.(cid:14); s; (cid:14)0; s0/ (cid:17) TransFOL.(cid:14); s; (cid:14)0; s0/;

Guarded.(cid:14); s/ (cid:27)

FinalSOL.(cid:14); s/ (cid:17) FinalFOL.(cid:14); s/:

Proof (Outline). By induction on the rank of the conﬁguration .(cid:14); s/. For rank 0 the thesis
is trivial. For rank n C 1, we assume that the thesis holds for all conﬁgurations of rank n,
and show the thesis by induction on the structure of the program considering nil, a, (cid:30)? and
TEnv V P .Et /U as base cases. 2

A conﬁguration .(cid:14); s/ has a guarded evolution, if and only if:

GuardedEvol.(cid:14); s/
(cid:3)
8(cid:14)0; s0:Trans

defD

SOL.(cid:14); s; (cid:14)0; s0/ (cid:27) Guarded.(cid:14)0; s0/:

For conﬁgurations with guarded evolution we have the following easy consequences:

0

0

8(cid:14)

GuardedEvol.(cid:14); s/ (cid:27)
(cid:3)
SOL.(cid:14); s; (cid:14)
:Trans
GuardedEvol.(cid:14); s/ (cid:27)

; s

8s0:DoSOL.(cid:14); s; s0/ (cid:17) DoFOL.(cid:14); s; s0/:

0

; s

0

(cid:3)
/ (cid:17) Trans
FOL.(cid:14); s; (cid:14)

0

0

/;

; s

14 The form of these axioms is exactly that of the conditions on the predicate variables T and F in the second-
order deﬁnitions.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

141

8.3. Sufﬁcient condition for guarded evolutions

Theorem 7. If all procedures P with environment Env in a program (cid:14) are such that

8Et; s:Guarded.TEnv V P .Et/U; s/;

then we have:

8s:GuardedEvol.(cid:14); s/:

Proof (Outline). By induction on the number of transitions. For 0 transitions, we get the
thesis by induction on the structure of the program (considering nil; a; (cid:30)? and TEnv V P .Et /U
as base cases). For k C 1 transitions, we assume the thesis holds for k transitions, and
we prove by induction on the structure of the program (again considering nil; a; (cid:30)? and
TEnv V P .Et /U as base cases) that making a further transition from the program resulting
from the k transitions still preserves the thesis. 2

It is easy to verify that nonrecursive procedures, as well as procedures whose body starts
with an atomic action or a wait action, trivially satisfy the hypothesis of the theorem.
Observe also that all procedures in [20] satisfy such hypothesis, except for the procedure
d at p. 9 whose deﬁnition is reported below (n is a natural number):

proc d.n/ .n D 0?/ j d.n (cid:0) 1/I goDown end:

However, the variants

proc d.n/ .n D 0?/ j goDownI d.n (cid:0) 1/ end

proc d.n/ .n D 0?/ j .n > 0/?I d.n (cid:0) 1/I goDown end

proc d.n/ if .n D 0/ then nil else .d.n (cid:0) 1/I goDown/ end

do satisfy the hypothesis.

9. Implementation

Despite the fact that in deﬁning the semantics of ConGolog we resorted to ﬁrst- and
second-order logic, it is possible to come up with a simple implementation of the ConGolog
language in Prolog.

In this section, we present a ConGolog interpreter in Prolog which is lifted directly from
the deﬁnition of Final, Trans, and Do introduced above. 15 This interpreter requires that
the program’s precondition axioms, successor state axioms, and axioms about the initial
situation be expressible as Prolog clauses. In particular, the usual closed world assumption
(CWA) is made on the initial situation. Note that this is a limitation of this particular
implementation, not the theory.

15 Exogenous actions can be generated by simulating them probabilistically, by asking the user at runtime when
they should occur, or by monitoring the environment in which the program is running.

142

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

Prolog terms representing ConGolog programs are as follows:
(cid:15) nil, empty program.
(cid:15) act.a/, atomic action, where a is an action term with the situation arguments

replaced by the constant now.

(cid:15) test.c/, wait/test, where c is a condition described below.
(cid:15) seq.p1; p2/, sequence.
(cid:15) choice.p1; p2/, nondeterministic branch.
(cid:15) pick.v; p/, nondeterministic choice of argument, where v is a Prolog constant

(atom), standing for a ConGolog variable, and p a program-term that uses v.

(cid:15) iter.p/, nondeterministic iteration.
(cid:15) if.c; p1; p2/, if-then-else, with p1 the then-branch and p2 the else-branch.
(cid:15) while.c; p/, while-do.
(cid:15) conc.p1; p2/, concurrency.
(cid:15) prconc.p1; p2/, prioritized concurrency.
(cid:15) iterconc.p/, iterated concurrency.
(cid:15) pcall.pArgs/, procedure call, with pArgs the procedure name and arguments.

A condition c in the above is either a Prolog-term representing an atomic formula/ﬂuent
with the situation arguments replaced by now or an expression of the form and.c1; c2/,
or.c1; c2/, neg.c/, all.v; c/, or some.v; c/, with the obvious intended meaning. In
all.v; c/ and some.v; c/, v is an Prolog constant, standing for a logical variable, and
c a condition using v.

The Prolog predicate trans=4, final=2, trans(cid:3)=4 and do=3 implement respec-

tively the predicate Trans, Final, Trans(cid:3) and Do.

The Prolog predicate holds=2 is used to evaluate conditions in tests, while-loops and
if-then-else’s in ConGolog programs. As well, the Prolog predicate sub=4 implements the
substitution so that sub.x; y; t; t 0/ means that t 0 D t x
y . The deﬁnition of these two Prolog
predicates is taken from [20,34].

The following is the Prolog code.

/************************************************************/
/*
*/
/************************************************************/

Trans-based ConGolog Interpreter

/* trans(Prog,Sit,Prog_r,Sit_r) */

trans(act(A),S,nil,do(AS,S)) :- sub(now,S,A,AS), poss(AS,S).

trans(test(C),S,nil,S) :- holds(C,S).

trans(seq(P1,P2),S,P2r,Sr) :- final(P1,S),trans(P2,S,P2r,Sr).
trans(seq(P1,P2),S,seq(P1r,P2),Sr) :- trans(P1,S,P1r,Sr).

trans(choice(P1,P2),S,Pr,Sr) :-

trans(P1,S,Pr,Sr) ; trans(P2,S,Pr,Sr).

trans(pick(V,P),S,Pr,Sr) :- sub(V,_,P,PP), trans(PP,S,Pr,Sr).

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

143

trans(iter(P),S,seq(PP,iter(P)),Sr) :- trans(P,S,PP,Sr).

trans(if(C,P1,P2),S,Pr,Sr) :-

holds(C,S), trans(P1,S,Pr,Sr) ;
holds(neg(C),S), trans(P2,S,Pr,Sr).

trans(while(C,P),S,seq(PP,while(C,P)),Sr) :-

holds(C,S), trans(P,S,PP,Sr).

trans(conc(P1,P2),S,conc(P1r,P2),Sr) :- trans(P1,S,P1r,Sr).
trans(conc(P1,P2),S,conc(P1,P2r),Sr) :- trans(P2,S,P2r,Sr).

trans(prconc(P1,P2),S,prconc(P1r,P2),Sr) :-

trans(P1,S,P1r,Sr).

trans(prconc(P1,P2),S,prconc(P1,P2r),Sr) :-
not trans(P1,S,_,_), trans(P2,S,P2r,Sr).

trans(iterconc(P),S,conc(PP,iterconc(P)),Sr) :-

trans(P,S,PP,Sr).

trans(pcall(P_Args),S,Pr,Sr) :-
sub(now,S,P_Args,P_ArgsS),
proc(P_ArgsS,P), trans(P,S,Pr,Sr).

/* final(Prog,Sit) */

final(nil,S).

final(seq(P1,P2),S) :- final(P1,S), final(P2,S).

final(choice(P1,P2),S) :- final(P1,S) ; final(P2,S).

final(pick(V,P),S) :- sub(V,_,P,PP), final(PP,S).

final(iter(P),S).

final(if(C,P1,P2),S) :-

holds(C,S),final(P1,S) ; holds(neg(C),S),final(P2,S).

final(while(C,P),S) :- holds(neg(C),S) ; final(P,S).

final(conc(P1,P2),S) :- final(P1,S), final(P2,S).

final(prconc(P1,P2),S) :- final(P1,S), final(P2,S).

final(iterconc(P),S).
final(pcall(P_Args)) :-

sub(now,S,P_Args,P_ArgsS), proc(P_ArgsS,P),final(P,S).

144

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

/* trans*(Prog,Sit,Prog_r,Sit_r) */

trans*(P,S,P,S).
trans*(P,S,Pr,Sr) :- trans(P,S,PP,SS), trans*(PP,SS,Pr,Sr).

/* do(Prog,Sit,Sit_r) */

do(P,S,Sr) :- trans*(P,S,Pr,Sr), final(Pr,Sr).

/* holds(Cond,Sit): as defined in [34] */

holds(and(F1,F2),S) :- holds(F1,S), holds(F2,S).
holds(or(F1,F2),S) :- holds(F1,S) ; holds(F2,S).
holds(all(V,F),S) :- holds(neg(some(V,neg(F))),S).
holds(some(V,F),S) :- sub(V,_,F,Fr), holds(Fr,S).
holds(neg(neg(F)),S) :- holds(F,S).
holds(neg(and(F1,F2)),S) :- holds(or(neg(F1),neg(F2)),S).
holds(neg(or(F1,F2)),S) :- holds(and(neg(F1),neg(F2)),S).
holds(neg(all(V,F)),S) :- holds(some(V,neg(F)),S).
holds(neg(some(V,F)),S) :- not holds(some(V,F),S).

/* Negation by failure */

holds(P_Xs,S) :-

P_Xs\=and(_,_),P_Xs\=or(_,_),P_Xs\=neg(_),P_Xs\=all(_,_),
P_Xs\=some(_,_),sub(now,S,P_Xs,P_XsS), P_XsS.

holds(neg(P_Xs),S) :-

P_Xs\=and(_,_),P_Xs\=or(_,_),P_Xs\=neg(_),P_Xs\=all(_,_),
P_Xs\=some(_,_),sub(now,S,P_Xs,P_XsS), not P_XsS.
/* Negation by failure */

/* sub(Const,Var,Term1,Term2): as defined in [34] */

sub(X,Y,T,Tr) :- var(T), Tr=T.
sub(X,Y,T,Tr) :- not var(T), T=X, Tr=Y.
sub(X,Y,T,Tr) :-

T\=X, T=..[F|Ts], sub_list(X,Y,Ts,Trs), Tr=..[F|Trs].

sub_list(X,Y,[],[]).
sub_list(X,Y,[T|Ts],[Tr|Trs]) :-

sub(X,Y,T,Tr), sub_list(X,Y,Ts,Trs).

In this implementation a ConGolog application is expected to have the following parts:
(1) A collection of clauses which together deﬁne which ﬂuents are true in the initial
situation s0. The clauses need not to be atomic, and can involve arbitrary amounts
of computation for determining entailments in the initial database.

(2) A collection of clauses which together deﬁne the predicate Poss.a; s/ for every
action a and situation s. Typically, this requires one clause per action, using a
variable to range over all situations.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

145

(3) A collection of clauses which together deﬁne the successor state axioms for each
ﬂuent. Typically, this requires one clause per ﬂuent, with variables for actions and
situations.

(4) A collection of facts deﬁning ConGolog procedures. In particular for each procedure

p occurring in the program we have a fact of the form:

proc.p.X1; : : : ; Xn/; body/:

In such facts:
(i) formal parameters are represented as Prolog variables so as to use Prolog built-

in uniﬁcation mechanism instead of a substitution procedure;

(ii) in the body body the only variables that can occur are those representing the

formal parameters X1; : : : ; Xn.

For simplicity, we do not consider nested procedures in the above implementation.
Expressing action theories as Prolog clauses places a number of restrictions on the
action theories that are representable. These restrictions force the closed world assumption
(Prolog CWA) on the initial situation and the unique name assumption (UNA) on both
actions and objects. For an in-depth study on action theories expressible as Prolog clauses,
we refer to [34].

9.1. Example

Below, we give an implementation in Prolog of the two robots lifting a table sce-
nario discussed in Section 6.1. The code is written as close to the speciﬁcation as possi-
ble. The inability of Prolog to deﬁne directly the functional ﬂuent vpos.e; s/ is resolved
by introducing a predicate val=2 such that val.vpos.e; s/; v/ stands for vpos.e; s/
D v.

/************************************************************/
/*
*/
/************************************************************/

Two Robots Lifting a Table Example

/* Precondition axioms */

poss(grab(Rob,E),S) :-

not holding(_,E,S), not holding(Rob,_,S).

poss(release(Rob,E),S) :- holding(Rob,E,S).
poss(vmove(Rob,Amount),S) :- true.

/* Succ state axioms */

val(vpos(E,do(A,S)),V) :-

(A=vmove(Rob,Amount), holding(Rob,E,S), val(vpos(E,S),V1),

V is V1+Amount) ;

146

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

(A=release(Rob,E), V=0) ;
(val(vpos(E,S),V),

not(A=vmove(Rob,Amount), holding(Rob,E,S)),
A\=release(Rob,E)).

holding(Rob,E,do(A,S)) :-

A=grab(Rob,E) ; (holding(Rob,E,S), A\=release(Rob,E)).

/* Defined Fluents */

tableUp(S) :-

val(vpos(end1,S),V1), V1>=3, val(vpos(end2,S),V2), V2>=3.

safeToLift(Rob,Amount,Tol,S) :-

tableEnd(E1), tableEnd(E2), E2\=E1, holding(Rob,E1,S),
val(vpos(E1,S),V1), val(vpos(E2,S),V2),
V1=<V2+Tol-Amount.

/* Initial state */

val(vpos(end1,s0),0).
val(vpos(end2,s0),0).
tableEnd(end1).
tableEnd(end2).

*/
/* plus by CWA:
/*
*/
/* not holding(rob1,_,s0) */
/* not holding(rob2,_,s0) */

/* Control procedures */

proc(ctrl(Rob,Amount,Tol),

seq(pick(e,seq(test(tableEnd(e)),act(grab(Rob,e)))),

while(neg(tableUp(now)),

seq(test(safeToLift(Rob,Amount,Tol,now)),

act(vmove(Rob,Amount)))))).

proc(jointLiftTable,

conc(pcall(ctrl(rob1,1,2)), pcall(ctrl(rob2,1,2)))).

Below we show a few ﬁnal situations returned by the interpreter for the above example

(note that the interpreter does not ﬁlter out identical situations).

?- do(pcall(jointLiftTable),s0,S).

S = do(vmove(rob2,1), do(vmove(rob1,1), do(vmove(rob2,1),

do(vmove(rob1,1), do(vmove(rob2,1), do(grab(rob2,end2),
do(vmove(rob1,1), do(vmove(rob1,1), do(grab(rob1,end1),
s0))))))))) ;

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

147

S = do(vmove(rob2,1), do(vmove(rob1,1), do(vmove(rob2,1),

do(vmove(rob1,1), do(vmove(rob2,1), do(grab(rob2,end2),
do(vmove(rob1,1), do(vmove(rob1,1), do(grab(rob1,end1),
s0))))))))) ;

S = do(vmove(rob1,1), do(vmove(rob2,1), do(vmove(rob2,1),

do(vmove(rob1,1), do(vmove(rob2,1), do(grab(rob2,end2),
do(vmove(rob1,1), do(vmove(rob1,1), do(grab(rob1,end1),
s0)))))))))

Yes

9.2. Correctness of the Prolog implementation

In this section we prove the correctness of the interpreter presented above under suitable
assumptions. Let C be the set of axioms for Trans, Final, and Do plus those needed for
the encoding of programs as ﬁrst-order terms, and D the domain theory. To keep notation
simple we denote the condition corresponding to a situation calculus formula (cid:30) with the
situation argument replaced by now, simply by (cid:30). Similarly for Prolog terms corresponding
to actions and programs.

Our proof of correctness relies on the following assumptions:
(cid:15) The domain theory D enforces the unique name assumption (UNA) on both actions

and objects. 16

(cid:15) The predicate sub=4 correctly implements substitution for both programs and

formulas.

(cid:15) The predicate holds=2 satisﬁes the following properties:

(1) If a goal holds.(cid:30); s/, with free variables only on object terms and action terms,
succeeds with computed answer (cid:18) , then D jD 8(cid:30)TsU(cid:18) (by 8 , we mean the
universal closure of  ).

(2) If a goal holds.(cid:30); s/, with free variables only on object terms and action terms,

ﬁnitely fails, then D jD 8:(cid:30)TsU.

(cid:15) The predicate poss=2 satisﬁes the following properties:

(1) If a goal poss.a; s/, with free variables only on object terms and action terms,

succeeds with computed answer (cid:18) then D jD 8Poss.a; s/(cid:18) .

(2) If a goal poss.a; s/, with free variables only on object terms and action terms,

ﬁnitely fails, then D jD 8:Poss.a; s/.

(cid:15) The Prolog interpreter ﬂounders (and hence does not return) on goals of the form not

trans.(cid:14); s; _; _/ 17 with nonground (cid:14) and s. 18

16 UNA is already enforced for programs, see Appendix A.
17 From a formal point of view not trans.(cid:14); s; _; _/ is a shorthand for not aux.(cid:14); s/ with aux=2 deﬁned as
aux.(cid:14); s/ V(cid:0) trans.(cid:14); s; _; _/.
18 This form of ﬂoundering arises for example when we expand (cid:25) in programs of the form (cid:25) z:.(cid:14)1.z/ ii (cid:14)2.z//.
Notably it does not arise for their variants (cid:25) z:.(cid:30).z/?I .(cid:14)1.z/ ii (cid:14)2.z///.

148

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

Observe that the hypotheses required for sub=4, holds=2 and poss=2 do hold when
these predicates are deﬁned as above and run by an interpreter that ﬂounders on nonground
negative goals (see [34]).

Theorem 8. Under the hypotheses above the following holds:

(1) If a goal do.(cid:14); s; s0/, where (cid:14) and s may contain variables only on object terms
and action terms, succeeds with computed answer (cid:18) , then C [ D jD 8Do.(cid:14); s; s0/(cid:18) ,
moreover s0(cid:18) may contain free variables only on object terms and action terms.
(2) If a goal do.(cid:14); s; s0/, where (cid:14) and s may contain variables only on object terms and

action terms, ﬁnitely fails, then C [ D jD 8:Do.(cid:14); s; s0/.

To make the arguments more apparent we will ﬁrst prove the theorem without

considering procedures. Then we show how introducing procedures affects the proof.

Without procedures

Theorem 8 is an easy consequence of Lemmas 2 and 3 below.

Lemma 2. Under the hypotheses above the following holds:

(cid:15) The predicate trans=4 satisﬁes the following properties:

(1) If a goal trans.(cid:14); s; (cid:14)0; s0/, where (cid:14) and s may contain variables only on
object terms and action terms, succeeds with computed answer (cid:18) , then C [ D jD
8Trans.(cid:14); s; (cid:14)0; s0/(cid:18) , moreover (cid:14)0(cid:18) and s0(cid:18) may contain free variables only on
object terms and action terms.

(2) If a goal trans.(cid:14); s; (cid:14)0; s0/, where (cid:14) and s may contain variables only on object

terms and action terms, ﬁnitely fails, then C [ D jD 8:Trans.(cid:14); s; (cid:14)0; s0/.

(cid:15) The predicate final=2 satisﬁes the following properties:

(1) If a goal final.(cid:14); s/, where (cid:14) and s may contain variables only on object terms
and action terms, succeeds with computed answer (cid:18) , then C [ D jD 8Final.(cid:14); s/(cid:18) .
(2) If a goal final.(cid:14); s/, where (cid:14) and s may contain variables only on object terms

and action terms, ﬁnitely fails, then C [ D jD 8:Final.(cid:14); s/.

Proof. First we observe that since we are not considering procedures, Trans and Final
satisfy the axioms T and F from Sections 4 and 5. We prove simultaneously (1) and (2)
for both trans=4 and final=2 by induction on the program (cid:14). Here we show only the
case (cid:14) D (cid:14)1 ii (cid:14)2 for trans=4.

(ii) trans.(cid:14)1; s; _; _/ ﬁnitely fails and trans.(cid:14)2; s; (cid:14)0

ii (cid:14)2/ is the most general uniﬁer [23] between (cid:14)0 and (cid:14)0
1

Success. If trans.(cid:14)1 ii (cid:14)2; s; (cid:14)0; s0/ succeeds with computed answer (cid:18) , then: either
(i) trans.(cid:14)1; s; (cid:14)0
mgu.(cid:14)0; (cid:14)0
1

1; s0/ succeeds with computed answer (cid:18)1, and (cid:18) D (cid:18) 0(cid:18)1 where (cid:18) 0 D
2; s0/ succeeds with computed
1; s0/(cid:18)1, and s0(cid:18)1 and (cid:14)0

In case (i) by the induction hypothesis C [ D jD 8Trans.(cid:14)1; s; (cid:14)0
1(cid:18)1
may contain free variables only on object terms and action terms. In case (ii) by the
2; s0/(cid:18)2, and
1; s0
induction hypothesis C [ D jD 8:Trans.(cid:14)1; s; (cid:14)0
s0(cid:18)2 and (cid:14)0
2(cid:18)2 may contain free variables only on object terms and action terms. Considering

answer (cid:18)2 and (cid:18) D mgu.(cid:14)0; (cid:14)1 ii (cid:14)0

1/, C [ D jD 8Trans.(cid:14)2; s; (cid:14)0

ii (cid:14)2; or

2/(cid:18)2.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

149

Trans.(cid:14)1 ii (cid:14)2; s; (cid:14)0; s0/ (cid:17)

9(cid:13) :(cid:14)0 D .(cid:13) ii (cid:14)2/ ^ Trans.(cid:14)1; s; (cid:13) ; s0/ _
9(cid:13) :(cid:14)0 D .(cid:14)1 ii (cid:13) / ^ Trans.(cid:14)2; s; (cid:13) ; s0/ ^ :9(cid:16); s00:Trans.(cid:14)1; s; (cid:16); s00/

(3)

and how (cid:18) is deﬁned in both cases, we get the thesis.

Failure. If trans.(cid:14)1 ii (cid:14)2; s; (cid:14)0; s0/ ﬁnitely fails, then:
1 such that (cid:14)0 uniﬁes with (cid:14)0
(i) for all (cid:14)0

1; s0/ ﬁnitely fails, hence
1; s0/ ^ (cid:14)0 D .(cid:14)0
by the induction hypothesis C [ D jD 8:Trans.(cid:14)1; s; (cid:14)0
(ii) either trans.(cid:14)1; s; _; _/ succeeds, hence C [ D jD 9(cid:14)0
1:Trans.(cid:14)1; s; (cid:14)0
1; s0
1/, or for
2; s0/ ﬁnitely fails, hence by
2, trans.(cid:14)2; s; (cid:14)0
2; s0/ ^ (cid:14)0 D .(cid:14)1 ii (cid:14)0

all (cid:14)0
the induction hypothesis C [ D jD 8:Trans.(cid:14)2; s; (cid:14)0

2 such that (cid:14)0 uniﬁes with (cid:14)1 ii (cid:14)0

ii (cid:14)2, trans.(cid:14)1; s; (cid:14)0

ii (cid:14)2/;
1; s0

Considering (3) and the UNA for object, actions, and program terms, we get the thesis. 2

2/.

1

1

Lemma 3. Under the hypotheses above the following holds:

(1) If a goal trans(cid:3).(cid:14); s; (cid:14)0; s0/, where (cid:14) and s may contain variables only on
object terms and action terms, succeeds with computed answer (cid:18) , then C [ D jD
8Trans(cid:3).(cid:14); s; (cid:14)0; s0/(cid:18) , moreover (cid:14)0(cid:18) and s0(cid:18) may contain free variables only on
object terms and action terms.

(2) If a goal trans(cid:3).(cid:14); s; (cid:14)0; s0/, where (cid:14) and s may contain variables only on object

terms and action terms, ﬁnitely fails, then C [ D jD 8:Trans(cid:3).(cid:14); s; (cid:14)0; s0/.

Proof. Using Lemma 2. Success. Then there exists a successful SLDNF-derivation [23].
Such a derivation must contain a ﬁnite number k of selected literals of the form
trans(cid:3).(cid:14)1; s1; (cid:14)2; s2/. The thesis is proven by induction on such a number k.

Failure. Then there exists a ﬁnitely failed SLDNF-tree [23] formed by failed SLDNF-
derivations each of which contains a ﬁnite number of selected literals of the form
trans(cid:3).(cid:14)1; s1; (cid:14)2; s2/. The thesis is proven by induction on the maximal number of
selected literals of the form trans(cid:3).(cid:14)1; s1; (cid:14)2; s2/ contained in the SLDNF-derivations
forming the tree. 2

With procedures

Since we do not have nested procedures in the Prolog implementation, we can avoid
carrying around the procedure environment. Hence we can simplify the constraints on
procedures in the deﬁnition of Trans and Final from Section 7 to respectively:

0

0

T .P .Et /; s; (cid:14)
F .P .Et/; s/ (cid:17) F

; s

/ (cid:17) T
(cid:0)
EvP
EtTsU; s

(cid:14)P

(cid:0)
EvP
(cid:14)P
EtTsU; s; (cid:14)
(cid:1)
:

(cid:1)

0

;

0

; s

To prove the soundness of the interpreter in presence of procedures, we need only redo

the proof of Lemma 2.

We now prove Lemma 2 as follows. Assume, for the moment, that Trans and Final

satisfy the axioms T and F from Sections 4 and 5 plus the following ones:
(cid:0)
Trans.P .Et/; s; (cid:14)0; s0/ (cid:17) Trans
(cid:0)
EvP
Final.P .Et/; s/ (cid:17) Final
Et TsU; s
(cid:14)P

EvP
EtTsU; s; (cid:14)0; s0
:

(cid:14)P
(cid:1)

(cid:1)
;

150

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

Then we follow the line of the proof given above. However we need to deal with the
additional complication that due to procedure expansions the program now does not
get always simpler anymore. To this end, we observe that every terminating SLDNF-
derivation contains a ﬁnite number of selected literals of the form trans.P .Et/; s1; (cid:14)2; s2/
(final.P .Et/; s1/). Hence we can prove the lemma using the following three nested
inductions:

(cid:15) Induction on the rank of successful SLDNF-derivations/ﬁnitely failed SLDNF-trees

(i.e., the depth of nesting of auxiliary ﬁnitely failed SLDNF-trees) [23].

(cid:15) Induction on the number of selected literals of the form trans.P .Et/; s1; (cid:14)2; s2/
(final.P .Et/; s1/) occurring in a successful SLDNF-derivation, for success. Induc-
tion on the maximal number of selected literals of the form trans.P .Et/; s1; (cid:14)2; s2/
(final.P .Et/; s1/) contained in the SLDNF-derivations forming the ﬁnitely failed
SLDNF-tree, for failure.

(cid:15) Induction on the structure of the program.
Now we come back to the assumption we made above for Trans and Final. In fact Final,
being closed under the constraints on F in its deﬁnition, does actually satisfy the axioms
F from Sections 4 and 5 as well as the one above. However, Trans, which is not closed
under the constraints for T in its deﬁnition, does not satisfy the assumption, in general.
However, we get the desired result by noticing that the equivalences assumed for Trans
form a conservative extension (see, e.g., [37]) of domain theory D plus the axioms needed
for the encoding of programs as ﬁrst-order terms, and appealing to the following general
result:

Proposition 1. Let (cid:0) be a consistent theory, (cid:0) [ f(cid:8)g a conservative extension of (cid:0) where
(cid:8) is a closed ﬁrst-order formula, and P a predicate occurring in (cid:8) but not in (cid:0) . Then for
any tuple of terms Et :

(1) (cid:0) [ f(cid:8)g jD 8P .Et/ implies (cid:0) jD 8.8Z:T(cid:8)P
Z
(2) (cid:0) [ f(cid:8)g jD 8:P .Et/ implies (cid:0) jD 8.:8Z:T(cid:8)P
Z

(cid:27) Z.Et/U/,

(cid:27) Z.Et/U/.

Proof. (1) by contradiction. Suppose there exists a model M of (cid:0) and variable assignment
Z but M; (cid:27) 6jD Z.Et/. Now
(cid:27) with (cid:27) .Z/ D R for some relation R, such that M; (cid:27) jD (cid:8)P
consider the model M 0 of (cid:0) obtained from M by changing the interpretation of P to
P M0 D R. Then M 0 jD (cid:8) and M 0; (cid:27) 6jD P .Et /, which contradicts (cid:0) [ f(cid:8)g jD 8P .Et/.

(2) by contradiction. Suppose exists a model M of (cid:0) and a variable assignment (cid:27) such
(cid:27) Z.Et/U. Then for every variable assignment (cid:27) 0 obtained from (cid:27)
Z then M; (cid:27) 0 jD Z.Et/. Let M 0 be an expansion of M
we have M; (cid:27) 0 jD Z.Et/, i.e., M 0; (cid:27) jD P .Et /, which

that M; (cid:27) jD 8Z:T(cid:8)P
Z
by putting (cid:27) .Z/ D Q if M; (cid:27) 0 jD (cid:8)P
such that M 0 jD (cid:8). Then for Q D P M0
contradicts (cid:0) [ f(cid:8)g jD 8:P .Et /. 2

Intuitively, Proposition 1 says that when we constrain a relation P by a ﬁrst-order
statement, then every tuple that is forced to be “in” or “out” of the relation, will also be
similarly “in” or “out” of the relation obtained by the second-order version of the statement.
Thus if Trans.(cid:14); s; (cid:14)0; s0/ holds for the ﬁrst-order version of Trans, it must also hold for the
second-order version.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

151

10. Discussion

With all of this procedural richness (nondeterminism, concurrency, recursive procedures,
priorities, etc.), it is important not to lose sight of the logical framework. ConGolog is
indeed a programming language, but one whose execution, like planning, depends on
reasoning about actions. Thus, a crucial part of a ConGolog program is the declarative
part: the precondition axioms, the successor state axioms, and the axioms characterizing
the initial state. This is central to how the language differs from superﬁcially similar
“procedural languages”. A ConGolog program together with the deﬁnition of Do and
some foundational axioms about the situation calculus is a formal logical theory about
the possible behaviors of an agent in a given environment. And this theory must be used
explicitly by a ConGolog interpreter.

In contrast, an interpreter for an ordinary procedural language does not use its semantics
explicitly. Standard semantic accounts of programming languages also require the initial
state to be completely speciﬁed; our account does not; an agent may have to act without
knowing everything about its environment. Our account accommodates domain-dependent
primitive actions and allows the interactions between the agent and its environment to be
modeled—actions may change the environment in a way that affects what actions can later
occur [8].

As mentioned, an important motivation for the development of ConGolog is the need
for tools to implement intelligent agent programs that are “reactive” in the sense that
they reconsider their plans in response to signiﬁcant changes in their environment. Thus,
our work is related to earlier research on resource-bounded deliberative architectures
such as [2] (IRMA) and [30] (PRS), and agent programming languages that are to some
extent based on this kind of architectures, such as AGENT-0 [38], AgentSpeak(L) [29],
and 3APL [16]. One difference is that in ConGolog, domain dynamics are speciﬁed
declaratively and the speciﬁcation is used automatically in program execution; there is no
need to program the updating of a world model when actions are performed. On the other
hand, plan selection or generation is not speciﬁed using rules; it must be coded up in the
program; this produces more complex programs, but there is perhaps less overhead. Finally,
agents programmed in ConGolog can be understood as executing programs, albeit in a
smart way; they have a simple operational semantics; architectures like IRMA and PRS,
and languages like AGENT-0, AgentSpeak(L), and 3APL have more complex execution
models.

Other programming languages share features with ConGolog. The agent programming
language Concurrent MetateM [11] supports concurrency and uses a temporal logic to
specify the behavior of agents. Bonner and Kifer [3] have proposed a logical formalism to
specify concurrent database transactions. Also related are concurrent constraint languages
such as CCP [35] and HCC [14], which support incompletely speciﬁed information states
and concurrency. But unlike ConGolog, these languages generally restrict the kinds of
constraints allowed in order to make entailment easy to compute. In ConGolog, the action
theory is what determines how how states are updated. Also in constraint languages, control
seems somewhat deemphasized. van Eijk et al. [10] have proposed an agent language partly
inspired from CCP.

152

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

Fig. 1. The ConGolog toolkit’s graphical viewer.

The simple Prolog implementation of the ConGolog interpreter described in Section 8
is at the core of a toolkit we have developed for implementing ConGolog applications. The
interpreter in the toolkit is very similar to the one described, but uses a more convenient
syntax, performs some error detection, and has tracing facilities for debugging.

The toolkit also includes a module for progressing the initial state database. To
understand the role of this component, ﬁrst note that the basic method used by our
implementation of action theories for determining whether a condition holds in a given
situation (i.e., evaluate holds.(cid:30); do.a1; : : : ; do.an; S0/ : : :/ is to perform regression on
the condition to obtain a new condition that only mentions the initial situation and then
query the initial situation database to determine whether the new condition holds. But
regressing the condition all the way back to the initial situation can be quite inefﬁcient
when the program has been running for a while and many actions have been performed.
If the program is willing to commit to a particular sequence of actions, it is possible to
progress the initial situation theory to a new initial situation theory representing the state of
affairs after the sequence of actions. 19 Subsequent queries can then be efﬁciently evaluated
with respect to this new initial situation database. The progression module performs this
updating of the initial situation database.

The toolkit also includes a graphical viewer (see Fig. 1) for debugging ConGolog
programs and delivering process modeling applications. The tool, which is implemented
in Tcl/Tk, displays the sequence of actions performed by the ConGolog program and
the value of the ﬂuents in the resulting situation (or any situation along the path). The

19 In general, the progression of an initial situation database may not be ﬁrst-order representable; but when
the initial situation is completely known (as we are assuming in this implementation), its progression is always
ﬁrst-order representable and can be computed efﬁciently; see [22] for details.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

153

program can be stepped through and exogenous events can be generated either manually
or at random according to a given distribution. The manner in which state information is
displayed can be speciﬁed easily and customized as required.

Finally, a high-level Golog Domain Speciﬁcation language (GDL) similar to Gelfond
and Lifschitz’s A [12] has also been developed. The toolkit includes a GDL compiler that
takes a domain speciﬁcation in GDL, generates successor state axioms for it, and then
produces a Prolog implementation of the resulting domain theory.

ConGolog has already been used in various applications. Lespérance et al. [19] have
implemented a “reactive” high-level control module for a mobile robot in ConGolog. The
robot performs a mail-delivery task. The ConGolog control program involves a set of
prioritized interrupts that react to events such as the robot arriving to a customer’s mailbox
or failing to get to a mailbox due to obstacles, as well as new shipment orders with varying
degrees of urgency being received. The ConGolog controller was interfaced to navigation
software and successfully tested on a RWI B12 mobile robot.

Work has also been done on using ConGolog to model multiagent systems [36]. In this
case, the domain theory includes ﬂuents that model the beliefs and goals of the system’s
agents (this is done by adapting a possible-world semantics of such mental states to the
situation calculus). A ConGolog program is used to specify the complex behavior of the
agents in such a system. A simple multiagent meeting scheduling example is speciﬁed
in [36]. ConGolog-based tools for specifying and verifying complex multiagent systems
are being investigated.

Finally, in [7], the transition semantics developed in this paper is adapted so that
execution can be interleaved with program interpretation in order to accommodate sensing
actions, that is, actions whose effect is not to change the world so much as to provide
information to be used by the agent at runtime.

In summary, we have seen how, given a basic action theory describing an initial state and
the preconditions and effects of a collection of primitive actions, it is possible to combine
these into complex actions for high-level agent control. The semantics of the resulting
language end up deriving directly from that of the underlying primitive actions. In this
sense, the solution to the frame problem provided by successor state axioms for primitive
actions is extended to cover the complex actions of ConGolog. So ConGolog can be viewed
as an action theory (that supports complex actions), as a speciﬁcation language, and as an
implementation language, and has been used in all three ways.

There are, however, many areas for future research. Among them, we mention:
handling non-termination, that is, developing accounts of program correctness (fairness,
liveness etc.) appropriate for controllers expected to operate indeﬁnitely as in [9], but
without giving up the agent’s control over nondeterministic choices that characterizes
the Do-based semantics for terminating programs; and also incorporating utilities, so that
nondeterministic choices in execution can be made to maximize the expected beneﬁt.

Acknowledgements

This research has been funded by the National Science and Engineering Research
Council of Canada. We thank Koen Hindriks for interesting discussions about this work

154

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

and for pointing out an error in an earlier version regarding situations other than now
appearing in primitive actions and tests. We also thank David Tremaine for alerting us
to a problem with an earlier way of handling exogenous events in the semantics. We
thank David McAllester for pointing out the subtleties that arise in extending Golog and
ConGolog with boolean procedures. Finally, we thank the referees for their comments.

Appendix A. Programs as terms

In this section, we develop an encoding of programs as ﬁrst-order terms. Although some
care is required (e.g., introducing constants denoting variables and deﬁning substitution
explicitly in the language), this does not pose any major problem; see [18] for an
introduction to problems and techniques in this area.

We add to the sorts Sit, Obj and Act of the Situation Calculus, the following new sorts:

Idx, PseudoSit, PseudoAct, PseudoObj, PseudoForm, ENV, and PROG.

Intuitively, elements of Idx denote natural numbers, and are used for building indexing
functions. Elements of PseudoAct, PseudoObj, PseudoSit and PseudoForm are syntactic
devices to denote respectively actions, objects, situations and formulas within programs.
Elements of ENV denote environments, i.e., sets of procedure deﬁnitions. And ﬁnally,
elements of PROG denote programs, which are considered as simply syntactic objects.

A.1. Sort Idx

We introduce the constant 0 of sort Idx, and a function succ : Idx ! Idx. For them we

enforce the following unique name axioms:

succ.i/ 6D 0;
succ.i/ D succ.i0/ (cid:27) i D i0:
We deﬁne the predicate Idx V Idx as:
Idx.i/ (cid:17) 8X:T: : : (cid:27) X.i/U;

where : : : stands for the conjunction of the universal closure of

X.0/;
X.i/ (cid:27) X.succ.i//:

Finally we assume the following domain closure axiom for sort Idx:

8i:Idx.i/:

A.2. Sorts PseudoSit, PseudoObj, PseudoAct

The languages of PseudoSit, PseudoObj and PseudoAct are as follows:
(cid:15) A constant Now V PseudoSit.
(cid:15) A function nameOfSort : Sort ! PseudoSort for Sort D Obj; Act. We use the notation

TTxUU to denote nameOfSort.x/, leaving Sort implicit.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

155

(cid:15) A function varSort : Idx ! PseudoSort for Sort D Obj; Act. We call terms of the form
varSort.i/ pseudo-variables and we use the notation zi (or just x; y; z) to denote
varSort.i/, leaving Sort implicit.

(cid:15) A function f : PseudoSort1 (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) PseudoSortn ! PseudoSortnC1 for each ﬂuent or
nonﬂuent function f of sort Sort1 (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) Sortn ! SortnC1 with Sorti D Obj; Act; Sit
in the original language (note that if n D 0 then f is a constant).

We deﬁne the predicates PseudoSit V PseudoSit, PseudoObj V PseudoObj and

PseudoAct V PseudoAct respectively as:

PseudoSit.x/ (cid:17) 8PSit; PObj; PAct:T: : : (cid:27) PSit.x/U;
PseudoObj.x/ (cid:17) 8PSit; PObj; PAct:T: : : (cid:27) PObj.x/U;
PseudoAct.x/ (cid:17) 8PSit; PObj; PAct:T: : : (cid:27) PAct.x/U;

where : : : stands for the conjunction of the universal closure of

PSit.Now/;

PSort.nameOfSort.x//

for Sort D Obj; Act,
for Sort D Obj; Act,
PSort.x1/ ^ (cid:1) (cid:1) (cid:1) ^ PSort.xn/ (cid:27) PSort.f.x1 : : : ; xn//

PSort.zi/

(for each f):

We assume the following domain closure axioms for the sorts PseudoSit, PseudoObj

and PseudoAct:

8x:PseudoSit.x/;
8x:PseudoObj.x/;
8x:PseudoAct.x/:

We also enforce unique name axioms for them, that is, for all functions g; g0 of any arity
(including constants) introduced above:

g.x1; : : : ; xn/ 6D g0.y1; : : : ; ym/;
g.x1; : : : ; xn/ D g.y1; : : : ; yn/ (cid:27) x1 D y1 ^ (cid:1) (cid:1) (cid:1) ^ xn D yn:

Observe that the unique name axioms impose that nameOf.x/ D nameOf.y/ (cid:27) x D y but
do not say anything on domain elements denoted by x and y since these are elements of
Act or Obj.

Next we want to relate pseudo-situations, pseudo-objects and pseudo-actions to real
situations, object and actions. In fact we do not want to relate all terms of sort PseudoObj
and PseudoAct to real object and actions, but just the “closed” ones, i.e., those in which no

156

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

pseudo variable zi occur. To formalize the notion of closedness, we introduce the predicate
Closed V PseudoSort for Sort D Sit; Obj; Act, characterized by the following assertions 20

Closed.Now/;

Closed.nameOf.x//;
:Closed.zi /;

Closed.f.x1; : : : ; xn// (cid:17) Closed.x1/ ^ (cid:1) (cid:1) (cid:1) ^ Closed.xn/

(for each f):

Closed terms of sort PseudoObj and PseudoAct are related to real objects and actions
by means of the function decode V .PseudoSort (cid:2) Sit ! Sort/ for Sort D Sit; Obj; Act.
We use the notation xTsU to denote decode.x; s/. Such a function is characterized by the
following assertions:

decode.Now; s/ D s;
decode.nameOf.x/; s/ D x;
decode.f.x1 : : : ; xn/; s/ D f .decode.x1; s/; : : : ; decode.xn; s//

(for each f).

A.3. Sort PseudoForm

Next we introduce pseudo-formulas used in tests. Speciﬁcally, we introduce:
(cid:15) A function p : PseudoSort1 (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) PseudoSortn ! PseudoForm for each nonﬂu-
ent/ﬂuent predicate p in the original language (not including the new the predicates
introduced in this section).

(cid:15) A function and : PseudoForm (cid:2) PseudoForm ! PseudoForm. We use the notation

(cid:15) A function not : PseudoForm ! PseudoForm. We use the notation :(cid:26) to denote

(cid:26)1 ^ (cid:26)2 to denote and.(cid:26)1; (cid:26)2/.

not.(cid:26)/.

(cid:15) A function someSort : PseudoSort (cid:2) PseudoForm ! PseudoForm, for PseudoSort D
PseudoObj; PseudoAct. We use the notation 9zi :(cid:26) to denote some.varSort.i/; (cid:26)/,
leaving Sort implicit.

We deﬁne the predicate PseudoForm V PseudoForm as:
PseudoForm.(cid:26)/ (cid:17) 8PForm:T: : : (cid:27) PForm.(cid:26)/U
where : : : stands for the conjunction of the universal closure of

PForm.p.x1; : : : ; xn//

(for each p),

PForm.(cid:26)1/ ^ PForm.(cid:26)2/ (cid:27) PForm.(cid:26)1 ^ (cid:26)2/;

PForm.(cid:26)/ (cid:27) PForm.:(cid:26)/;
PForm.(cid:26)/ (cid:27) PForm.9zi :(cid:26)/:

20 We say the following theory is “characterizing” since it is complete, in the sense that it partitions the elements
in PseudoSort into those that are closed and those that are not.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

157

We assume the following domain closure axiom for the sort PseudoForm:

8(cid:26):PseudoForm.(cid:26)/:

We also enforce unique name axioms for pseudo-formulas, that is, for all functions g; g0 of
any arity introduced above:

g.x1; : : : ; xn/ 6D g0.y1; : : : ; ym/;
g.x1; : : : ; xn/ D g.y1; : : : ; yn/ (cid:27) x1 D y1 ^ (cid:1) (cid:1) (cid:1) ^ xn D yn:

Next we formalize the notion of substitution. We introduce the function sub :
PseudoSort (cid:2) PseudoSort (cid:2) PseudoSort 0 ! PseudoSort 0 for Sort D Obj; Act and Sort 0 D
Sit; Obj; Act. We use the notation t x
y to denote sub.x; y; t/. Such a function is character-
ized by the following assertions:

D nameOf.t/;

Nowx
D Now;
y
nameOf.t/x
y
D y;
zi
x
x 6D zi (cid:27) zi
y
f.t1; : : : ; tn/x
y

zi
y

D zi ;
D f.t1

x
y ; : : : ; tn

x
y/

(for each f):

We extend the function sub to pseudo-formulas (as third argument) as follows:

x
y/

(for each p);

x
y ; : : : ; tn
^ .(cid:26)2/x
y;

D p.t1

p.t1; : : : ; tn/x
y
D .(cid:26)1/x
.(cid:26)1 ^ (cid:26)2/x
y
y
.:(cid:26)/x
D :.(cid:26)/x
y;
y
D 9zi :(cid:26);
.9zi :(cid:26)/zi
y
x 6D zi (cid:27) .9zi :(cid:26)/x
y

D 9zi :.(cid:26)x

y /:

Next we extend the predicate Closed to pseudo-formulas in a natural way:

Closed.p.x1; : : : ; xn// (cid:17) Closed.x1/ ^ (cid:1) (cid:1) (cid:1) ^ Closed.xn/
Closed.(cid:26)1 ^ (cid:26)2/ (cid:17) Closed.(cid:26)1/ ^ Closed.(cid:26)2/;
Closed.:(cid:26)/ (cid:17) Closed.(cid:26)1/;
Closed.9zi :(cid:26)/ (cid:17) 8y:Closed.(cid:26)zi

nameOf.y//:

(for each p);

We relate closed pseudo-formulas to real formulas by introducing a predicate Holds V
PseudoForm (cid:2) Sit, characterized by the following assertions:

Holds.p.x1; : : : ; xn/; s/ (cid:17) p.decode.x1; s/; : : : ; decode.xn; s//

(for each p);

Holds.(cid:26)1 ^ (cid:26)2; s/ (cid:17) Holds.(cid:26)1; s/ ^ Holds.(cid:26)2; s/;
Holds.:(cid:26); s/ (cid:17) :Holds.(cid:26); s/;
Holds.9z:(cid:26); s/ (cid:17) 9y:Holds.(cid:26)z

nameOf.y/; s/;

where y in the last equation is any variable that does not appear in (cid:26). We use the notation
(cid:30)TsU to denote Holds.(cid:30); s/.

158

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

A.4. Sorts PROG and ENV

Now we are ready to introduce programs. Speciﬁcally, we introduce:
(cid:15) A constant nil V PROG.
(cid:15) A function act : PseudoAct ! PROG. As notation we write simply a to denote

act.a/ when confusion cannot arise.

(cid:15) A function test : PseudoForm ! PROG. We use the notation (cid:26)? to denote

test.(cid:26)/.

(cid:15) A function seq : PROG (cid:2) PROG ! PROG. We use the notation (cid:14)1I (cid:14)2 to denote

seq.(cid:14)1; (cid:14)2/.

(cid:15) A function choice : PROG (cid:2) PROG ! PROG. We use the notation (cid:14)1 j (cid:14)2 to denote

choice.(cid:14)1; (cid:14)2/.

(cid:15) A function iter : PROG ! PROG. We use the notation (cid:14)(cid:3) to denote iter.(cid:14)/.
(cid:15) Two functions pickSort : PseudoSort (cid:2) PROG ! PROG, where PseudoSort is either
PseudoObj or PseudoAct. We use the notation (cid:25) zi:(cid:14) to denote pickSort.varSort.i/;
(cid:14)/, leaving Sort implicit.

(cid:15) A function if : PseudoForm (cid:2) PROG (cid:2) PROG ! PROG. We use the notation if (cid:26)

then (cid:14)1 else (cid:14)2 to denote if.(cid:26); (cid:14)1; (cid:14)2/.

(cid:15) A function while : PseudoForm (cid:2) PROG ! PROG. We use the notation while (cid:26)

do (cid:14) to denote while.(cid:26); (cid:14)/.

(cid:15) A function conc : PROG (cid:2) PROG ! PROG. We use the notation (cid:14)1 k (cid:14)2 to denote

conc.(cid:14)1; (cid:14)2/.

(cid:15) A function prconc : PROG(cid:2)PROG ! PROG. We use the notation (cid:14)1 ii (cid:14)2 to denote

prconc.(cid:14)1; (cid:14)2/.

(cid:15) A function iterconc : PROG ! PROG. We use the notation (cid:14)jj

to denote

iterconc.(cid:14)/.

To deal with procedures we need to introduce the notion of environment together with

that of program. We introduce:

(cid:15) A ﬁnite number of functions P : PseudoSort1 (cid:2) (cid:1) (cid:1) (cid:1) (cid:2) PseudoSortn ! PROG, where
PseudoSorti is either PseudoObj or PseudoAct. These functions are going to be used
as procedure calls.

(cid:15) A function proc : PROG(cid:2) PROG ! PROG. This function is used to build procedure
deﬁnitions and so we will force the ﬁrst argument to have the form P.zi1; : : : ; zin/,
where z1 : : : zn are used to denote the formal parameters of the deﬁned procedure. We
use the notation proc P.z1; : : : ; zn/ (cid:14) end to denote proc.P.z1; : : : ; zn/; (cid:14)/.

(cid:15) A constant " V ENV, denoting the empty environment.
(cid:15) A function addproc : ENV (cid:2) PROG ! ENV. We will restrict the programs allowed
to appear as the second argument to procedure deﬁnitions only. We use the notation
EI proc P.Ez/ (cid:14) end to denote addproc.E; proc P.Ez/ (cid:14) end/.

(cid:15) A function pblock : ENV (cid:2) PROG ! PROG. We use the notation fEI (cid:14)g to denote

pblock.E; (cid:14)/.

(cid:15) A function c_call : ENV (cid:2) PROG ! PROG. We will restrict the programs allowed
to appear as the second argument to procedure calls only. We use the notation
TE V P.Et/U to denote c_call.E; P.Et//.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

159

We next introduce a predicate defined V PROG (cid:2) ENV meaning that a procedure is

deﬁned in an environment. It is speciﬁed as:

defined.c; E/ (cid:17) 8D:T: : : (cid:27) D.c; E/U;

where : : : stands for the conjunction of the universal closure of

D.P.Ex/; "I proc P.Ey/ (cid:14) end/;
D.c; E 0/ (cid:27) D.c; E 0I d/:

Observe that procedures P are only deﬁned in an environment E, and that the parameters
the procedure is applied to do not play any role in determining whether the procedure is
deﬁned.

Now we deﬁne the predicate Prog V PROG and the predicate Env V ENV as:

Prog.(cid:14)/ (cid:17) 8PPROG; PENV :T : : : (cid:27) PPROG.(cid:14)/U;
Env.E/ (cid:17) 8PPROG; PENV :T : : : (cid:27) PENV .E/U;

where : : : stands for the universal closure of

PPROG.nil/;

PPROG.act.a//

(a pseudo-action);

PPROG.(cid:26)?/

((cid:26) pseudo-formula);

PPROG.(cid:14)1/ ^ PPROG.(cid:14)2/ (cid:27) PPROG.(cid:14)1I (cid:14)2/;
PPROG.(cid:14)1/ ^ PPROG.(cid:14)2/ (cid:27) PPROG.(cid:14)1 j (cid:14)2/;

PPROG.(cid:14)/ (cid:27) PPROG.(cid:14)(cid:3)/;
PPROG.(cid:14)/ (cid:27) PPROG.(cid:25) zi:(cid:14)/;
PPROG.(cid:14)1/ ^ PPROG.(cid:14)2/ (cid:27) PPROG.if (cid:26) then (cid:14)1 else (cid:14)2/;

PPROG.(cid:14)/ (cid:27) PPROG.while (cid:26) do (cid:14)/;

PPROG.(cid:14)1/ ^ PPROG.(cid:14)2/ (cid:27) PPROG.(cid:14)1 k (cid:14)2/;
PPROG.(cid:14)1/ ^ PPROG.(cid:14)2/ (cid:27) PPROG.(cid:14)1 ii (cid:14)2/;

PPROG.(cid:14)/ (cid:27) PPROG.(cid:14)jj/;
(for each P);

PPROG.P.x1; : : : ; xn//
PENV .E/ ^ PPROG.(cid:14)/ (cid:27) PPROG.fEI (cid:14)g/;
PENV .E/ ^ defined.P.Ez/; E/ (cid:27) PPROG.TE V P.x1; : : : ; xn/U/;

PENV ."/;

PENV .E/ ^ PPROG.(cid:14)/ ^ :defined.P.Ez/; E/ ^

!

zih

6D zik

(cid:27)

n^

h;kD1

PENV .EI proc P.zi1; : : : ; zin / (cid:14) end/:

 
160

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

We assume the following domain closure axioms for the sorts PROG and ENV:

8(cid:14):Prog.(cid:14)/;
8E:Env.E/:

We also enforce unique name axioms for programs and environments, that is for all
functions g; g0 of any arity introduced above:
g.x1; : : : ; xn/ 6D g0.y1; : : : ; ym/;
g.x1; : : : ; xn/ D g.y1; : : : ; yn/ (cid:27) x1 D y1 ^ (cid:1) (cid:1) (cid:1) ^ xn D yn:

We extend the predicate Closed to PROG by induction on the structure of the program
terms in the obvious way so as to consider closed, programs in which all occurrences of
pseudo-variables zi are bound either by (cid:25) , or by being a formal parameter of a procedure.
Only closed programs are considered legal.

We introduce the function resolve : ENV (cid:2) PROG (cid:2) PROG ! PROG, to be used to
associate to procedure calls the environment to be used to resolve them. Namely, given the
procedure P deﬁned in the environment E, resolve.E; P.Et/; (cid:14)/ denoted by .(cid:14)/P.Et/
TEVP.Et/U,
suitably replaces P.Et/ by c_call.E; P.Et// in order to obtain static scope for procedures.
It is obvious how the function can be extended to resolve whole sets of procedure calls
whose procedures are deﬁned in the environment E. Formally this function satisﬁes the
following assertions:
.nil/P.Ex/

TEVP.Ex/U D nil;

.a/P.Ex/

TEVP.Ex/U D a;

.(cid:26)?/P.Ex/

TEVP.Ex/U D (cid:26)?;

TEVP.Ex/U;

TEVP.Ex/U;

.(cid:14)1I (cid:14)2/P.Ex/

.(cid:14)1 j (cid:14)2/P.Ex/

.(cid:25) zi :(cid:14)/P.Ex/

TEVP.Ex/UI .(cid:14)2/P.Ex/
TEVP.Ex/U j .(cid:14)2/P.Ex/

TEVP.Ex/U D .(cid:14)1/P.Ex/
TEVP.Ex/U D .(cid:14)1/P.Ex/
TEVP.Ex/U D (cid:25) zi:.(cid:14)/P.Ex/
TEVP.Ex/U;
(cid:0)
(cid:1)(cid:3)
.(cid:14)/P.Ex/

;

.(cid:14)(cid:3)/P.Ex/

TEVP.Ex/U D

TEVP.Ex/U
.if (cid:26) then (cid:14)1 else (cid:14)2/P.Ex/

TEVP.Ex/U D if (cid:26) then .(cid:14)1/P.Ex/

TEVP.Ex/U else .(cid:14)2/P.Ex/

TEVP.Ex/U;

.while (cid:26) do (cid:14)/P.Ex/

.(cid:14)1 k (cid:14)2/P.Ex/

TEVP.Ex/U;

TEVP.Ex/U D while (cid:26) do .(cid:14)/P.Ex/
TEVP.Ex/U k .(cid:14)2/P.Ex/
TEVP.Ex/U ii .(cid:14)2/P.Ex/

TEVP.Ex/U D .(cid:14)1/P.Ex/
TEVP.Ex/U D .(cid:14)1/P.Ex/

TEVP.Ex/U;

TEVP.Ex/U;

.(cid:14)1 ii (cid:14)2/P.Ex/
P.Ex/
TEVP.Ex/U D ..(cid:14)/P.Ex/

.(cid:14)

/

jj

TEVP.Ex/U/

jj

;

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

161

.P.Ex//P.Ex/

.Q.Et//P.Ex/

TEVP.Ex/U D TE V P.Ex/U;
TEVP.Ex/U D Q.Et/
8
<

.fE 0I (cid:14)g/P.Ex/

TEVP.Ex/U D

:

for any procedure call Q.Et/ different from P.Ex/;

fE 0I (cid:14)g
(cid:8)
E 0I .(cid:14)/P.Ex/

TEVP.Ex/U

if procedure P is (re)deﬁned in E 0;

(cid:9)

otherwise;

.TE 0 V Q.EtU//P.Ex/

TEVP.Ex/U D TE 0 V Q.Et/U for every procedure call Q.Et/ and environment E 0:
Finally, we extend the function sub to PROG (as third argument) again by induction on
the structure of program terms in the natural way considering (cid:25) as a binding construct for
pseudo-variables and without doing any substitutions into environments. sub is used for
substituting formal parameters with actual parameters in contextualized procedure calls, as
well as to deal with (cid:25) . We also introduce a function c_body : PROG (cid:2) ENV ! PROG to
be used to return the body of the procedures. Namely, c_body.P.Ex/; E/ returns the body
of the procedure P in E with the formal parameters substituted by the actual parameters Ex.
Formally this function satisﬁes the following assertions:

c_body.P.Ex/; EI proc P.Ey/ (cid:14) end/ D (cid:14)
c_body.P.Ex/; EI proc Q.Ey/ (cid:14) end/ D c_body.P.Ex/; E/

Ey
Ex ;

.Q 6D P/:

A.5. Consistency preservation

The encoding presented here preserves consistency as stated by the following theorem.

Theorem A.1. Let H be the axioms deﬁning the encoding above. Then every model of an
action theory D (involving sorts Sit, Act and Obj) can be extended to a model of H [ D
(involving the additional sorts Idx, PseudoSit, PseudoAct, PseudoObj, PseudoForm, ENV
and PROG).

Proof. It sufﬁces to observe that for each new sort (Idx; : : : ; PROG) H contains:

(cid:15) A second-order axiom that explicitly deﬁnes a predicate which inductively character-

izes the elements of the sort.

(cid:15) An axiom that closes the domain of the new sort with respect to the characterizing

predicate.

(cid:15) Unique name axioms that extend the interpretation of D to the new sort by induction

on the structure of the elements (as imposed by the characterizing axiom).

(cid:15) Axioms that characterize predicates and functions, such as Closed, decode, sub,

Holds, etc., by induction on the structure of the elements of the sort.

Hence, given a model M of the action theory D, it is straightforward to introduce domains
for the new sorts that satisfy the characterizing predicate, the domain closure axioms, and
the unique name axioms for the sort, by proceeding by induction on the structure of the
elements forced by the characterizing predicate, and then establishing the extension of the
newly deﬁned predicates/functions for the sort. 2

162

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

Appendix B. Proof of Theorem 1—Equivalence between the Do’s for Golog
programs

In this section, we prove Theorem 1, i.e., the equivalence of the original deﬁnition of
Do and the new one given in this paper, in the more general language which includes
procedures. To simplify the presentation of the proof, we use the same symbols to denote
terms and elements of the domain of interpretation; the meaning will be clear from the
context.

B.1. Alternative deﬁnitions of Trans and Final

For proving the following results, it is convenient to reformulate the deﬁnitions of Trans

and Final:

(cid:15) Trans.(cid:14); s; (cid:14)0; s0/ (cid:17) 8T :T : : : (cid:27) T .(cid:14); s; (cid:14)0; s0/U, where : : : stands for the conjunction

of the universal closure of the following implications:

Poss.aTsU; s/ (cid:27) T .a; s; nil; do.aTsU; s//;
(cid:30)TsU (cid:27) T .(cid:30)?; s; nil; s/;
0I (cid:13) ; s
0
/ (cid:27) T .(cid:14)I (cid:13) ; s; (cid:14)
; s
Final.(cid:13) ; s/ ^ T .(cid:14); s; (cid:14)0; s0/ (cid:27) T .(cid:13) I (cid:14); s; (cid:14)0; s0/;
0
0
0

T .(cid:14); s; (cid:14)

/;

0

0

0

; s

; s

/ (cid:27) T .(cid:14) j (cid:13) ; s; (cid:14)

/;
T .(cid:14); s; (cid:14)
T .(cid:14); s; (cid:14)0; s0/ (cid:27) T .(cid:13) j (cid:14); s; (cid:14)0; s0/;
x ; s; (cid:14)0; s0/ (cid:27) T .(cid:25)v:(cid:14); s; (cid:14)0; s0/;
T .(cid:14)v
T .(cid:14); s; (cid:14)0; s0/ (cid:27) T .(cid:14)(cid:3); s; (cid:14)0I (cid:14)(cid:3); s0/;

(cid:0)
(cid:14)Pi .Et/
TEnvVPi .Et/U; s; (cid:14)0; s0
T
(cid:0)
EvP
g; s; (cid:14)0; s0
fEnvI (cid:14)P
EtTsU

(cid:1)

(cid:1)

T

(cid:27) T .fEnvI (cid:14)g; s; (cid:14)0; s0/;
(cid:27) T .TEnv V P .Et/U; s; (cid:14)0; s0/:

(cid:15) Final.(cid:14); s/ (cid:17) 8F:T: : : (cid:27) F .(cid:14); s/U, where : : : stands for the conjunction of the

universal closure of the following implications:

True (cid:27) F .nil; s/;
F .(cid:14); s/ ^ F .(cid:13) ; s/ (cid:27) F .(cid:14)I (cid:13) ; s/;
F .(cid:14); s/ (cid:27) F .(cid:14) j (cid:13) ; s/;
F .(cid:14); s/ (cid:27) F .(cid:13) j (cid:14); s/;
F .(cid:14)v
x ; s/ (cid:27) F .(cid:25)v:(cid:14); s/;
True (cid:27) F .(cid:14)

(cid:3)

(cid:0)

(cid:14)Pi .Et/
TEnvVPi .Et/U; s
F
(cid:0)
EvP
fEnvI (cid:14)P
Et TsU; s

F

(cid:1)

(cid:1)

; s/;
(cid:27) F .fEnvI (cid:14)g; s/;
(cid:27) F .TEnv V P .Et/U; s/:

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

163

Theorem B.1. With respect to Golog programs, the deﬁnitions above are equivalent to the
ones given in Section 7 of the paper.

Proof. To prove this equivalence, consider ﬁrst the following general results, which are a
direct consequence of the Tarski–Knaster ﬁxpoint theorem [40]. If

S.Ex/ (cid:17) 8Z:TT8Ey:(cid:8).Z; Ey/ (cid:27) Z.Ey/U (cid:27) Z.Ex/U

and (cid:8).Z; Ey/ is monotonic, i.e.,

8Z1; Z2:T8Ey:Z1.Ey/ (cid:27) Z2.Ey/U (cid:27) T8Ey:(cid:8).Z1; Ey/ (cid:27) (cid:8).Z2; Ey/U;

then we get the following consequences 21

S.Ex/ (cid:17) (cid:8).S; Ex/;
S.Ex/ (cid:17) 8Z:TT8Ey:Z.Ey/ (cid:17) (cid:8).Z; Ey/U (cid:27) Z.Ex/U:

(B.1)

(B.2)

(B.3)

Now it is easy to see that the above deﬁnition of Trans and Final can be rewritten as (B.1)
and that the resulting (cid:8) is indeed monotonic (in particular it is syntactically monotonic
since the predicate variables T and F do not occur in the scope of any negation). Thus,
by the Tarski–Knaster ﬁxpoint theorem, the above deﬁnitions can be rewritten in the form
of (B.3). Once in this form it is easy to see that for Golog programs they are equivalent to
those introduced in Section 7. 2

B.2. Do1 is equivalent to Do2

Let Do1 be the original deﬁnition of Do in [20] extended with Do1.nil; s; s0/

defD s0 D s
defD Do.fEnvI P .Et/g; s; s0/, and Do2 the new deﬁnition in
and Do.TEnv V P .Et /U; s; s0/
terms of Trans and Final. Also, we do not allow procedure calls for which no procedure
deﬁnitions are given.

Lemma B.1. For every model M of C, there exist (cid:14)1; s1 : : : (cid:14)n; sn such that M jD Trans.(cid:14)i;
si; (cid:14)iC1; siC1/ for i D 1; : : : ; n (cid:0) 1 if and only if M jD Trans(cid:3).(cid:14)1; s1; (cid:14)n; sn/.

Proof. ()) By induction on n. If n D 1, then M jD Trans(cid:3).(cid:14)1; s1; (cid:14)1; s1/ by deﬁnition
of Trans(cid:3). If n > 1, then by induction hypothesis M jD Trans(cid:3).(cid:14)2; s2; (cid:14)n; sn/, and since
M jD Trans.(cid:14)1; s1; (cid:14)2; s2/, we get M jD Trans(cid:3).(cid:14)1; s1; (cid:14)n; sn/ by deﬁnition of Trans(cid:3).

(() Let R be the relation formed by the tuples .(cid:14)1; s1; (cid:14)n; sn/ such that there exist
(cid:14)1; s1 : : : (cid:14)n; sn and M jD Trans.(cid:14)i; si; (cid:14)iC1; siC1/ for i D 1; : : : ; n (cid:0) 1. It is easy to verify
that

(i) for all (cid:14); s, .(cid:14); s; (cid:14); s/ 2 R;
(ii) for all (cid:14); s; (cid:14)0; s0; (cid:14)00; s00, M jD Trans.(cid:14); s; (cid:14)0; s0/ and .(cid:14)0; s0; (cid:14)00; s00/ 2 R implies

.(cid:14); s; (cid:14)00; s00/ 2 R. 2

21 In fact, (B.2) is only mentioned in passing and not used in the proof.

164

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

Lemma B.2. For every model M of C, M jD Do1.(cid:14); s; s0/ implies that there exist (cid:14)1; s1;
: : : ; (cid:14)n; sn such that (cid:14)1 D (cid:14), s1 D s, sn D s0, M jD Final.(cid:14)n; sn/, and M jD Trans.(cid:14)i; si ;
(cid:14)iC1; siC1/ for i D 1; : : : ; n (cid:0) 1.

Proof. We prove the lemma by induction on the structure of the program. We only give
details for the most signiﬁcant cases.

(1) a (atomic action). M jD Do1.a; s; s0/ iff M jD Poss.aTsU; s/ and s0 D do.aTsU; s/.

Then M jD Trans.a; s; nil; do.aTsU; s//, and hence the thesis.

(2) (cid:14)I (cid:13) (sequence). M jD Do1.(cid:14)I (cid:13) ; s; s0/ iff M jD Do1.(cid:14); s; s00/ and M jD Do1.(cid:13) ; s00;

s0/. Then by induction hypothesis:
(i) there exist (cid:14)1; s1 : : : ; (cid:14)k; sk such that (cid:14)1 D (cid:14), s1 D s, sk D s00, M jD Final.(cid:14)k; sk/

and M jD Trans.(cid:14)i; si ; (cid:14)iC1; si / for i D 1; : : : ; k (cid:0) 1;

(ii) there exist (cid:13)k; sk : : : ; (cid:13)n; sn such that (cid:13)1 D (cid:13) , sk D s00, sn D s0, M jD Final.(cid:13)n; sn/

and M jD Trans.(cid:13)i; si ; (cid:13)iC1; si / for i D k; : : : ; n (cid:0) 1.

Since Trans itself is closed under the assertions in its deﬁnition we have that: M jD
Trans.(cid:14)i; si ; (cid:14)iC1; siC1/ implies M jD Trans.(cid:14)iI (cid:13) ; si; (cid:14)iC1I (cid:13) ; siC1/. Moreover M jD
Final.(cid:14)k; sk/ and M jD Trans.(cid:13)k; sk; (cid:13)kC1; skC1/ implies M jD Trans.(cid:14)kI (cid:13)k; sk;
(cid:13)kC1; skC1/. Similarly in the case k D n we have that, since Final is also closed under
the assertions in its deﬁnition M jD Final.(cid:14)k; sk/ and M jD Final.(cid:13)k; sk/ implies
M jD Final.(cid:14)kI (cid:13)k; sk/. Hence the thesis.

(3) (cid:14)(cid:3) (iteration). M jD Do1.(cid:14)(cid:3); s; s0/ iff M jD 8P :T: : : (cid:27) P .s; s0/U where : : : stand for

the following two assertions:
(i) 8s:P .s; s/;
(ii) 8s; s0; s00:Do1.(cid:14); s; s00/ ^ P .s00; s0/ (cid:27) P .s; s0/.
Consider the relation Q deﬁned as the set of pairs .s; s0/ such that: there exist
(cid:14)1; s1 : : : ; (cid:14)n; sn with (cid:14)1 D (cid:14)(cid:3), s1 D s, sn D s0, M jD Final.(cid:14)n; sn/ and M jD
Trans.(cid:14)i; si ; (cid:14)iC1; si / for i D 1; : : : ; n (cid:0) 1. To prove the thesis, it is sufﬁcient to show
that Q satisﬁes the two assertions (i) and (ii).
(i) Let (cid:14)1 D (cid:14)n D (cid:14)(cid:3), s1 D sn D s; since M jD Final.(cid:14)(cid:3); s/, it follows that for all s,

.s; s/ 2 Q.

(ii) By the ﬁrst induction hypothesis (the induction on the structure of the program):
M jD Do1.(cid:14); s; s00/ implies that there exist (cid:14)1; s1 : : : ; (cid:14)k; sk such that (cid:14)1 D
(cid:14), s1 D s, sk D s00, M jD Final.(cid:14)k; sk/ and M jD Trans.(cid:14)i; si ; (cid:14)iC1; siC1/ for
i D 1; : : : ; k (cid:0) 1. This implies that M jD Trans.(cid:14)iI (cid:14)(cid:3); si; (cid:14)iC1I (cid:14)(cid:3); siC1/ for
i V 2; : : : ; k (cid:0) 1. Moreover, we must also have M jD Trans.(cid:14)(cid:3); s1; (cid:14)2I (cid:14)(cid:3); s2/.

By the second induction hypothesis (rule induction for P ), we can assume
that there exist (cid:13)k; sk : : : ; (cid:13)n; sn such that (cid:13)k D (cid:14)(cid:3), sk D s00, sn D s0, M jD
Final.(cid:13)n; sn/ and M jD Trans.(cid:13)i; si ; (cid:13)iC1; siC1/ for i D k; : : : ; n (cid:0) 1.

Now observe that Final.(cid:14)k; sk/ and Trans.(cid:13)k; sk; (cid:13)kC1; skC1/ implies that

Trans.(cid:14)kI (cid:13)k; sk; (cid:13)kC1; skC1/. Thus, we get that (ii) holds for Q.

Hence the thesis.

(4) fEnvI (cid:14)g (procedures). M jD Do1.fEnvI (cid:14)g; s; s0/ iff

M jD 8P1; : : : ; Pn: T(cid:8) (cid:27) Do1.(cid:14); s; s0/U;

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

165

where

(cid:8) D

"

n^

iD1

8Ex; s; s

0

:Do1.(cid:14)i

0

Evi
Ex ; s; s

/ (cid:27) Pi .Ex; s; s

0

/

:

#

To get the thesis, it sufﬁces to prove it for the case:
M jD 8P1; : : : ; Pn: T(cid:8) (cid:27) Pi .Ex; s; s0/U

(B.4)

(B.5)

and then apply the induction argument on the structure of the program considering
as base cases nil, a, (cid:30)?, and P .Et/.

Consider the relations Qi deﬁned as the set of tuples .Ex; s; s0/ such that there exist
(cid:14)1; s1 : : : ; (cid:14)n; sn with (cid:14)1 D fEnvI Pi.Ex/g, 22 s1 D s, sn D s0, M jD Final.(cid:14)n; sn/ and
M jD Trans.(cid:14)i; si ; (cid:14)iC1; si / for i D 1; : : : ; n (cid:0) 1. To prove the thesis it is sufﬁcient to
show that each Qi satisﬁes (is closed under) the assertion (B.4).
defD Pi .Ex; s; s0/ where Pi is a free predicate variable.
Recall that Do1.Pi .Ex//; s; s0/
jD Do1.Pi .Ex/; s; s0/
This means that for any variable assignment (cid:27) , M; (cid:27) P1;:::;Pn
Q1;:::;Qn
implies .Ex; s; s0/ 2 Qi , i.e., there exist (cid:14)1; s1 : : : ; (cid:14)n; sn with (cid:14)1 D fEnvI Pi.Ex/g, s1 D
s, sn D s0, M jD Final.(cid:14)n; sn/ and M jD Trans.(cid:14)i; si; (cid:14)iC1; si / for i D 1; : : : ; n (cid:0) 1.
Hence by induction on the structure of the program, considering as base cases nil,
Evi
Ex ; s; s0/ implies that there
a, (cid:30)? and P .Et /, we have that M; (cid:27) P1;:::;Pn
Q1;:::;Qn
Evi
g, s1 D s, sn D s0, M jD Final.(cid:14)n; sn/
exist (cid:14)1; s1 : : : ; (cid:14)n; sn with (cid:14)1 D fEnvI (cid:14)i
Ex
and M jD Trans.(cid:14)i; si; (cid:14)iC1; si / for i D 1; : : : ; n (cid:0) 1. Now considering that M jD
g; s1; (cid:14)2; s2/ implies M jD Trans.TEnv V Pi .Ex/U; s1; (cid:14)2; s2/ implies
Trans.fEnvI (cid:14)i
M jD Trans.fEnvI Pi.Ex/g; s1; (cid:14)2; s2/, we get that .Ex; s; s0/ 2 Qi . 2

jD Do1.(cid:14)i

Evi
Ex

Lemma B.3. For all Golog programs (cid:14) and situations s:

Final.(cid:14); s/ (cid:27) Do1.(cid:14); s; s/:

Proof. It is easy to show that Do1.(cid:14); s; s/ is closed with respect to the implications in the
inductive deﬁnition of Final. 2

Lemma B.4. For all Golog programs (cid:14); (cid:14)0 and situations s; s0:
Trans.(cid:14); s; (cid:14)0; s0/ ^ Do1.(cid:14)0; s0; s00/ (cid:27) Do1.(cid:14); s; s00/:

Proof. The property we want to prove can be rewritten as follows:

Trans.(cid:14); s; (cid:14)0; s0/ (cid:27) (cid:8).(cid:14); s; (cid:14)0; s0/

with

(cid:8).(cid:14); s; (cid:14)0; s0/

defD 8s00:Do1.(cid:14)0; s0; s00/ (cid:27) Do1.(cid:14); s; s00/:

22 To be more precise, the variables xi in Pi .Ex/ should be read as nameOf.xi / thus converting situation calculus
objects/actions variables into suitable program terms (see Appendix A).

166

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

Hence it is sufﬁcient to show that (cid:8) is closed under the implications that inductively deﬁne
Trans. Again, we only give details for the most signiﬁcant cases.

(1) Implication for primitive actions. We show that Poss.aTsU; s/ (cid:27) (cid:8).aTsU; s; nil;

do.aTsU; s//, i.e.:

Poss.aTsU; s/ (cid:27) 8s00:Do1.nil; do.aTsU; s/; s00/ (cid:27) Do1.a; s; s00/:

Since Do1.nil; s; s0/
which holds by the deﬁnition of Do1.

defD s0 D s, this reduces to Poss.aTsU; s/ (cid:27) Do1.a; s; do.a; s//,

(2) First implication for sequences. We have to show (cid:8).(cid:14); s; (cid:14)0; s0/ (cid:27) (cid:8).(cid:14)I (cid:13) ; s; (cid:14)0; s0/,

i.e.:

8s00:TDo1.(cid:14)0; s0; s00/ (cid:27) Do1.(cid:14); s; s00/U (cid:27)

8s00:Do1.(cid:14)0I (cid:13) ; s0; s00/ (cid:27) Do1.(cid:14)I (cid:13) ; s; s00/:

By contradiction. Suppose that there is a model M such that M jD 8s00:Do1.(cid:14)0; s0;
s00/ (cid:27) Do1.(cid:14); s; s00/, and M jD Do1.(cid:14)0I (cid:13) ; s0; sc/ and M jD :Do1.(cid:14)I (cid:13) ; s; sc/ for
some sc. This means that M jD Do1.(cid:14)0; s0; st / ^ Do1.(cid:13) ; st ; sc/ for some st , but
M jD 8t::Do1.(cid:14); s; t/ _ :Do1.(cid:13) ; t; sc/. Since M jD Do1.(cid:14)0; s0; st / implies M jD
Do1.(cid:14); s; st /, we have a contradiction.

(3) Second implication for sequences. We have to show Final.(cid:14); s/ ^ (cid:8).(cid:13) ; s; (cid:13) 0; s0/ (cid:27)

(cid:8).(cid:14)I (cid:13) ; s; (cid:13) 0; s0/, i.e.:

Final.(cid:14); s/ ^ 8s00:TDo1.(cid:13) 0; s0; s00/ (cid:27) Do1.(cid:13) ; s; s00/U (cid:27)

00

8s

:Do1.(cid:13)

0

0

; s

; s

00

/ (cid:27) Do1.(cid:14)I (cid:13) ; s; s

00

/:

By contradiction. Suppose that there is a model M such that M jD Final.(cid:14); s/,
M jD 8s00:Do1.(cid:13) 0; s0; s00/ (cid:27) Do1.(cid:13) ; s; s00/, and M jD Do1.(cid:13) 0; s0; sc/—thus M jD
Do1.(cid:13) ; s; sc/—and M jD :Do1.(cid:14)I (cid:13) ; s; sc/ for some sc. The latter means that M jD
8t::Do1.(cid:14); s; t/ _ :Do1.(cid:13) ; t; sc/. Since M jD Final.(cid:14); s/ implies M jD Do1.(cid:14); s; s/
by Lemma B.3, then M jD :Do1.(cid:13) ; s; sc/, contradiction.

0

0

00

00

8s

:Do1.(cid:14)

(4) Implication for iteration. We have to show (cid:8).(cid:14); s; (cid:14)0; s0/ (cid:27) (cid:8).(cid:14)(cid:3); s; (cid:14)0I (cid:14)(cid:3); s0/, i.e.:
00

; s
; s
(cid:3)
0I (cid:14)

:TDo1.(cid:14)
00
8s

/ (cid:27) Do1.(cid:14); s; s
0
/ (cid:27) Do1.(cid:14)
; s

/U (cid:27)
(cid:3)
; s; s
By contradiction. Suppose that there is a model M such that M jD 8s00:Do1.(cid:14)0; s0;
s00/ (cid:27) Do1.(cid:14); s; s00/, and M jD Do1.(cid:14)0I (cid:14)(cid:3); s0; sc/ and M jD :Do1.(cid:14)(cid:3); s; sc/ for
some sc. Since M jD Do1.(cid:14)0I (cid:14)(cid:3); s0; sc/ implies M jD Do1.(cid:14)0; s0; st /—thus M jD
Do1.(cid:14); s; st /—and M jD Do1.(cid:14)(cid:3); st ; sc/, and M jD Do1.(cid:14); s; st / and M jD Do1.(cid:14)(cid:3);
st ; sc/ imply M jD Do1.(cid:14)(cid:3); s; sc/, contradiction.

; s

/:

00

00

(5) Implication for contextualized procedure calls. We have to show that

(cid:0)(cid:8)

(cid:8)

EnvI (cid:14)i

(cid:9)
; s; (cid:14)

0

0

; s

(cid:1)

Evi
EtTsU

(cid:27) (cid:8).TEnv V Pi .Et/U; s; (cid:14)

0

0

/:

; s

It sufﬁces to prove that:
(cid:9)
(cid:0)(cid:8)
; s; s0

EnvI (cid:14)i

Do1

Evi
EtTsU

(cid:1)

(cid:27) Do1.TEnv V Pi .Et/U; s; s0/:

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

167

We proceed by contradiction. Suppose that there exists an model M such that
g; s; s0/ and M jD :Do1.TEnvI Pi.Et/U; s; s0/, for some Et, s and
M jD Do1.fEnvI (cid:14)i
s0. That is:

Evi
EtTsU

Evi
Et TsU; s; s0
M jD 8P1; : : : ; Pn:
M jD 9P1; : : : ; Pn: T(cid:9) ^ :Pi .EtTsU/; s; s

(cid:2)
(cid:9) (cid:27) Do1

(cid:0)
(cid:14)i

(cid:1)(cid:3)
;
/U;

0

V
n
iD1

(B.7)
; s; s0/ (cid:27) Pi .Exi; s; s0/U. Then by (B.7) there
where (cid:9) D T
exists a variable assignment such that M; (cid:27) jD (cid:9) and M; (cid:27) jD :Pi .EtTsU; s; s0/, which
Evi
EtTsU; s; s0/, which contradicts (B.6).
implies M; (cid:27) jD :Do1.(cid:14)

8Exi; s; s0:Do1.(cid:14)i

Evi
Exi

(6) Implication for programs within an environment. We have to show

(B.6)

(cid:0)

(cid:8)

(cid:14)Pi .Et/
TEnvVPi .Et/U; s; (cid:14)0; s0

(cid:1)

(cid:27) (cid:8).fEnvI (cid:14)g; s; (cid:14)0; s0/:

It sufﬁces to prove that:
(cid:0)

Do1

(cid:14)Pi .Et/
TEnvVPi .Et/U; s; s0

(cid:1)

(cid:27) Do1.fEnvI (cid:14)g; s; s0/:

This can be done by induction on the structure of the program (cid:14) considering nil, a,
(cid:30)?, and TEnv0 V P .Et/U as base cases (such programs do not make use of Env). 2

Lemma B.5. For every model M of C, if there exist (cid:14)1; s1 : : : (cid:14)n; sn such that (cid:14)1 D (cid:14), s1 D s,
sn D s0, M jD Final.(cid:14)n; sn/ and M jD Trans.(cid:14)i; si ; (cid:14)iC1; siC1/ for i D 1; : : : ; n (cid:0) 1, then
M jD Do1.(cid:14); s; s0/.

Proof. By induction on n. If n D 1, then Final.(cid:14); s/ (cid:27) Do1.(cid:14); s; s/ by Lemma B.3. If
n > 1, then by induction hypothesis M jD Do1.(cid:14)2; s2; s0/, hence by applying Lemma B.4,
we get the thesis. 2

With these lemmas in place we can ﬁnally prove the wanted result:

Theorem 1. For each Golog program (cid:14):

C jD 8s; s0:Do1.(cid:14); s; s0/ (cid:17) Do2.(cid:14); s; s0/:

Proof. ()) by Lemmas B.2 and B.1; (() by Lemmas B.1 and B.5. 2

References

[1] G.R. Andrews, F.B. Schneider, Concepts and notations for concurrent programming, ACM Comput.

Surveys 15 (1) (1983) 3–43.

[2] M.E. Bratman, D.J. Israel, M.E. Pollack, Plans and resource-bounded practical reasoning, Comput.

Intelligence 4 (1988) 349–355.

[3] A.J. Bonner, M. Kifer, Concurrency and communication in transaction logic, in: Proc. Joint International

Conference and Symposium on Logic Programming (JICSLP), Bonn, Germany, 1996, pp. 142–156.

[4] J. De Bakker, E. De Vink, Control Flow Semantics, MIT Press, Cambridge, MA, 1996.
[5] X.J. Chen, G. De Giacomo, Reasoning about nondeterministic and concurrent actions: A process algebra

approach, Artiﬁcial Intelligence 107 (1) (1999) 63–98.

168

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

[6] G. De Giacomo, Y. Lespérance, H.J. Levesque, Reasoning about concurrent execution, prioritized interrupts,
and exogenous actions in the situation calculus, in: Proc. IJCAI-97, Nagoya, Japan, 1997, pp. 1221–1226.
[7] G. De Giacomo, H.J. Levesque, An incremental interpreter for high-level programs with sensing, in:
Cognitive Robotics—Papers from the 1998 AAAI Fall Symposium, Orlando, FL, Technical Report FS-
98-02, AAAI Press, Menlo Park, CA, 1998, pp. 28–34.

[8] M. Dixon, Embedded computation and the semantics of programs, Ph.D. Thesis, Department of Computer
Science, Stanford University, Stanford, CA, 1991. Also appeared as Xerox PARC Technical Report SSL-
91-1.

[9] G. De Giacomo, E. Ternovskaia, R. Reiter, Nonterminating processes in the situation calculus, in: Proc.
AAAI-97 Workshop on Robots, Softbots, Immobots: Theories of Action, Planning and Control, Providence,
RI, 1997.

[10] R.M. van Eijk, F.S. de Boer, W. van der Hoek, J.-J.Ch. Meyer, Information-passing and belief revision in

multi-agent systems, in: J.P. Müller, M.P. Singh, A.S. Rao (Eds.), Proc. ATAL-98, Paris, 1998, pp. 75–89.

[11] M. Fisher, A survey of Concurrent MetateM—The language and its applications,

in: D.M. Gabbay,
H.J. Ohlbach (Eds.), Temporal Logic—Proc. First International Conference, Lecture Notes in Artiﬁcial
Intelligence, Vol. 827, Springer, Berlin, 1994, pp. 480–505.

[12] M. Gelfond, V. Lifschitz, Representing action and change by logic programs, J. Logic Programming 17

(1993) 301–327.

[13] C.C. Green, Theorem proving by resolution as a basis for question-answering systems, in: Machine

Intelligence, Vol. 4, Edinburgh University Press, Edinburgh, 1969, pp. 183–205.

[14] V. Gupta, R. Jagadeesan, V.A. Saraswat, Computing with continuous change, Sci. Comput. Programming 30

(1998) 3–50.

[15] M. Hennessy, The Semantics of Programming Languages, Wiley, New York, 1990.
[16] K.V. Hindriks, F.S. de Boer, W. van der Hoek, J.-J.Ch. Meyer, A formal semantics for an abstract agent
programming language, in: M.P. Singh, A. Rao, M.J. Wooldridge (Eds.), Proc. ATAL-97, Lecture Notes in
Artiﬁcial Intelligence, Vol. 1365, Springer, Berlin, 1998, pp. 215–229.

[17] C.A.R. Hoare, Communicating Sequential Processes, Prentice Hall, Englewood Cliffs, NJ, 1985.
[18] D. Leivant, Higher order logic, in: Handbook of Logic in Artiﬁcial Intelligence and Logic Programming,

Vol. 2, Clarendon Press, Oxford, 1994, pp. 229–321.

[19] Y. Lespérance, M. Jenkin, K. Tam, Reactivity in a logic-based robot programming framework, in: Cognitive
Robotics—Papers from the 1998 AAAI Fall Symposium, Orlando, FL, Technical Report FS-98-02, AAAI
Press, Menlo Park, CA, 1998, pp. 98–105.

[20] H.J. Levesque, R. Reiter, Y. Lespérance, F. Lin, R.B. Scherl, GOLOG: A logic programming language for

dynamic domains, J. Logic Programming 31 (1997) 59–84.

[21] F. Lin, R. Reiter, State constraints revisited, J. Logic Comput. 4 (5) (1994) 655–678.
[22] F. Lin, R. Reiter, How to progress a database, Artiﬁcial Intelligence 92 (1997) 131–167.
[23] J.W. Lloyd, Foundations of Logic Programming, 2nd edn., Springer, Berlin, 1987.
[24] J. McCarthy, P. Hayes, Some philosophical problems from the standpoint of artiﬁcial intelligence, in:

Machine Intelligence, Vol. 4, Edinburgh University Press, Edinburgh, 1969.

[25] R. Milner, Communication and Concurrency, Prentice Hall, Englewood Cliffs, NJ, 1989.
[26] H.R. Nielson, F. Nielson, Semantics with Applications: A Formal Introduction, Wiley, New York, 1992.
[27] G. Plotkin, A structural approach to operational semantics, Technical Report DAIMI-FN-19, Computer

Science Department, Aarhus University, Denmark, 1981.

[28] D. Pym, L. Pryor, D. Murphy, Processes for plan-execution, in: Proc. 14th Workshop of the UK Planning

and Scheduling Special Interest Group, 1995.

[29] A.S. Rao, AgentSpeak(L): BDI agents speak out in a logical computable language, in: W. van der Velde,
J.W. Perram (Eds.), Agents Breaking Away, Lecture Notes in Artiﬁcial Intelligence, Vol. 1038, Springer,
Berlin, 1996, pp. 42–55.

[30] A.S. Rao, M.P. Georgeff, An abstract architecture for rational agents, in: B. Nebel, C. Rich, W. Swartout
(Eds.), Proc. 3rd International Conference on Principles of Knowledge Representation and Reasoning (KR-
92), Cambridge, MA, Morgan Kaufmann, San Mateo, CA, 1992, pp. 439–449.

[31] R. Reiter, The frame problem in the situation calculus: A simple solution (sometimes) and a completeness
result for goal regression, in: Artiﬁcial Intelligence and Mathematical Theory of Computation: Papers in
Honor of John McCarthy, Academic Press, New York, 1991, pp. 359–380.

G. De Giacomo et al. / Artiﬁcial Intelligence 121 (2000) 109–169

169

[32] R. Reiter, Proving properties of states in the situation calculus, Artiﬁcial Intelligence 64 (1993) 337–351.
[33] R. Reiter, Natural actions, concurrency and continuous time in the situation calculus,

in: Proc. 5th
International Conference on Principles of Knowledge Representation and Reasoning (KR-96), Cambridge,
MA, Morgan Kaufmann, San Mateo, CA, 1996, pp. 2–13.

[34] R. Reiter, Knowledge in action: Logical foundation for describing and implementing dynamical systems, In

preparation.

[35] V.A. Saraswat, M. Rinard, Concurrent constraint programming, in: Proc. 17th ACM Symposium on

Principles of Programming Languages, 1990, pp. 232–245.

[36] S. Shapiro, Y. Lespérance, H.J. Levesque, Specifying communicative multiagent systems, in: W. Wobcke,
M. Pagnucco, C. Zhang (Eds.), Agents and Multi-Agent Systems—Formalisms, Methodologies, and
Applications, Lecture Notes in Artiﬁcial Intelligence, Vol. 1441, Springer, Berlin, 1998, pp. 1–14.

[37] J.R. Shoenﬁeld, Mathematical Logic, Addison-Wesley, Reading, MA, 1967.
[38] Y. Shoham, Agent-oriented programming, Artiﬁcial Intelligence 60 (1993) 51–92.
[39] C. Stirling, Modal and temporal logics for processes, in: Logics for Concurrency: Structure versus Automata,

Lecture Notes in Computer Science, Vol. 1043, Springer, Berlin, 1996, pp. 149–237.

[40] A. Tarski, A lattice-theoretical ﬁxpoint theorem and its applications, Paciﬁc J. Math. 5 (1955) 285–309.

