Artiﬁcial Intelligence 171 (2007) 73–106

www.elsevier.com/locate/artint

AND/OR search spaces for graphical models

Rina Dechter, Robert Mateescu ∗

Donald Bren School of Information and Computer Science, University of California, Irvine, CA 92697-3425, USA

Received 10 October 2005; received in revised form 8 November 2006; accepted 9 November 2006

Available online 17 January 2007

Abstract

The paper introduces an AND/OR search space perspective for graphical models that include probabilistic networks (directed
or undirected) and constraint networks. In contrast to the traditional (OR) search space view, the AND/OR search tree displays
some of the independencies present in the graphical model explicitly and may sometimes reduce the search space exponentially.
Indeed, most algorithmic advances in search-based constraint processing and probabilistic inference can be viewed as searching
an AND/OR search tree or graph. Familiar parameters such as the depth of a spanning tree, treewidth and pathwidth are shown to
play a key role in characterizing the effect of AND/OR search graphs vs. the traditional OR search graphs. We compare memory
intensive AND/OR graph search with inference methods, and place various existing algorithms within the AND/OR search space.
© 2006 Elsevier B.V. All rights reserved.

Keywords: Search; AND/OR search; Decomposition; Graphical models; Bayesian networks; Constraint networks

1. Introduction

Bayesian networks, constraint networks, Markov random ﬁelds and inﬂuence diagrams, commonly referred to as
graphical models, are all languages for knowledge representation that use graphs to capture conditional independen-
cies between variables. These independencies allow both the concise representation of knowledge and the use of
efﬁcient graph-based algorithms for query processing. Algorithms for processing graphical models fall into two gen-
eral types: inference-based and search-based. Inference-based algorithms (e.g., Variable Elimination, Tree Clustering)
are better at exploiting the independencies captured by the underlying graphical model. They provide a superior worst
case time guarantee, as they are time exponential in the treewidth of the graph. Unfortunately, any method that is time-
exponential in the treewidth is also space exponential in the treewidth or separator width and, therefore, not practical
for models with large treewidth.

Search-based algorithms (e.g., depth-ﬁrst branch-and-bound, best-ﬁrst search) traverse the model’s search space
where each path represents a partial or full solution. The linear structure of search spaces does not retain the inde-
pendencies represented in the underlying graphical models and, therefore, search-based algorithms may not be nearly
as effective as inference-based algorithms in using this information. On the other hand, the space requirements of
search-based algorithms may be much less severe than those of inference-based algorithms and they can accommo-

* Corresponding author.

E-mail addresses: dechter@ics.uci.edu (R. Dechter), mateescu@ics.uci.edu (R. Mateescu).

0004-3702/$ – see front matter © 2006 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2006.11.003

74

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

date a wide spectrum of space-bounded algorithms, from linear space to treewidth bounded space. In addition, search
methods require only an implicit, generative, speciﬁcation of the functional relationship (given in a procedural or
functional form) while inference schemes often rely on an explicit tabular representation over the (discrete) variables.
For these reasons, search-based algorithms are the only choice available for models with large treewidth and with
implicit representation.

In this paper we propose to use the well-known idea of an AND/OR search space, originally developed for heuristic
search [1], to generate search procedures that take advantage of information encoded in the graphical model. We
demonstrate how the independencies captured by the graphical model may be used to yield AND/OR search trees
that are exponentially smaller than the standard search tree (that can be thought of as an OR tree). Speciﬁcally, we
show that the size of the AND/OR search tree is bounded exponentially by the depth of a spanning pseudo tree over
the graphical model. Subsequently, we move from AND/OR search trees to AND/OR search graphs. Algorithms that
explore the search graph involve controlled memory management that allows improving their time-performance by
increasing their use of memory. The transition from a search tree to a search graph in AND/OR representations also
yields signiﬁcant savings compared to the same transition in the original OR space. In particular, we show that the
size of the minimal AND/OR graph is bounded exponentially by the treewidth, while for OR graphs it is bounded
exponentially by the pathwidth.

Our idea of the AND/OR search space is inspired by search advances introduced sporadically in the past three
decades for constraint satisfaction and more recently for probabilistic inference and for optimization tasks. Specif-
ically, it resembles pseudo tree rearrangement [2,3], brieﬂy introduced two decades ago, which was adapted sub-
sequently for distributed constraint satisfaction [4,5] and more recently in [6], and was also shown to be related to
graph-based backjumping [7]. This work was extended in [8] and more recently applied to optimization tasks [9]. An-
other version that can be viewed as exploring the AND/OR graphs was presented recently for constraint satisfaction
[10] and for optimization [11]. Similar principles were introduced recently for probabilistic inference (in algorithm
Recursive Conditioning [12] as well as in Value Elimination [13,14]) and currently provide the backbones of the most
advanced SAT solvers [15]. An important contribution of this paper is in showing that all these seemingly different
ideas can be cast as simple traversal of AND/OR search spaces. We will also elaborate on the relationship between
this scheme and Variable Elimination [16]. We will discuss the relationship with Ordered Binary Decision Diagrams
(OBDD) [17], disjunctive Decomposable Negational Normal Forms (d-DNNF) and their extension to arithmetic cir-
cuits for Bayesian networks [18,19], as well as with the recent work in [20–23].

The structure of the paper is as follows. Section 2 contains preliminary notations and deﬁnitions. Section 3 de-
scribes graphical models. Section 4 introduces the AND/OR search tree that can be traversed by a linear space search
algorithm. Section 5 presents the AND/OR search graph that can be traversed by memory intensive search algorithms.
Section 6 shows how to use the AND/OR graphs to solve a reasoning problem, and gives the AND/OR search algo-
rithm for counting and belief updating. Section 7 is dedicated to a detailed comparison of AND/OR search and other
new algorithmic advances in graphical models as well as compilation schemes. Finally, Section 8 provides concluding
remarks. All the proofs are given in an appendix at the end.

2. Preliminaries

Notations. A reasoning problem is deﬁned in terms of a set of variables taking values on ﬁnite domains and a
set of functions deﬁned over these variables. We denote variables or subsets of variables by uppercase letters (e.g.,
X, Y, Z, S, R . . .) and values of variables by lower case letters (e.g., x, y, z, s). An assignment (X1 = x1, . . . , Xn = xn)
can be abbreviated as x = ((cid:3)X1, x1(cid:4), . . . , (cid:3)Xn, xn(cid:4)) or x = (x1, . . . , xn). For a subset of variables Y , DY denotes the
Cartesian product of the domains of variables in Y . xY and x[Y ] are both used as the projection of x = (x1, . . . , xn)
over a subset Y . We will also denote by Y = y (or y for short) the assignment of values to variables in Y from their
respective domains. We denote functions by letters f , g, h etc., and the scope (set of arguments) of the function f by
scope(f ).

Deﬁnition 1 (functional operators). Given a function h deﬁned over a subset of variables S, where X ∈ S, func-
X h) are deﬁned over U = S − {X} as follows: For every U = u, and denoting by
tions (minX h), (maxX h), and (
(u, x) the extension of tuple u by assignment X = x, (minX h)(u) = minx h(u, x), (maxX h)(u) = maxx h(u, x), and
(cid:2)
(cid:2)
x h(u, x). Given a set of functions h1, . . . , hk deﬁned over the subsets S1, . . . , Sk, the product func-
(

X h)(u) =

(cid:2)

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

75

(cid:2)

tion, Πj hj , and summation function,
and (

j hj )(u) =

j hj (uSj ).

(cid:2)

(cid:2)

j hj , are deﬁned over U =

(cid:3)

j Sj . For every U = u, (Πj hj )(u) = Πj hj (uSj ),

Deﬁnition 2 (graph concepts). A directed graph is a pair G = {V , E}, where V = {X1, . . . , Xn} is a set of vertices,
and E = {(Xi, Xj ) | Xi, Xj ∈ V } is the set of edges (arcs). If (Xi, Xj ) ∈ E, we say that Xi points to Xj . The degree
of a variable is the number of arcs incident to it. For each variable Xi , pa(Xi) or pai , is the set of variables pointing
to Xi in G, while the set of child vertices of Xi , denoted ch(Xi), comprises the variables that Xi points to. The family
of Xi , Fi , includes Xi and its parent variables. A directed graph is acyclic if it has no directed cycles. An undirected
graph is deﬁned similarly to a directed graph, but there is no directionality associated with the edges.

Deﬁnition 3 (induced width). An ordered graph is a pair (G, d) where G is an undirected graph, and d = X1, . . . , Xn
is an ordering of the nodes. The width of a node is the number of the node’s neighbors that precede it in the ordering.
The width of an ordering d, is the maximum width over all nodes. The induced width of an ordered graph, w∗(d),
is the width of the induced ordered graph obtained as follows: nodes are processed from last to ﬁrst; when node X
is processed, all its preceding neighbors are connected. The induced width of a graph, denoted by w∗, is the minimal
induced width over all its orderings.

Deﬁnition 4 (hypergraph). A hypergraph is a pair H = (X, S), where S = {S1, . . . , St } is a set of subsets of V called
hyperedges.

Deﬁnition 5 (tree decomposition). A tree decomposition of a hypergraph H = (X, S) is a tree T = (V , E) (V is the
set of nodes, also called “clusters”, and E is the set of edges) together with a labeling function χ that associates with
each vertex v ∈ V a set χ(v) ⊆ X satisfying:

1. For each Si ∈ S there exists a vertex v ∈ V such that Si ⊆ χ(v);
2. (running intersection property) For each Xi ∈ X, the set {v ∈ V | Xi ∈ χ(v)} induces a connected subtree of T .

Deﬁnition 6 (treewidth, pathwidth). The width of a tree decomposition of a hypergraph is the size of its largest cluster
minus 1 (maxv |χ(v)| − 1). The treewidth of a hypergraph is the minimum width along all possible tree decomposi-
tions. The pathwidth is the treewidth over the restricted class of chain decompositions.

It is easy to see that given an induced graph, the set of maximal cliques (also called clusters) provide a tree decom-
position of the graph, namely the clusters can be connected in a tree structure that satisﬁes the running intersection
property. It is well known that the induced width of a graph is identical to its treewidth [24]. For various relationships
between these and other graph parameters see [25–27].

2.1. AND/OR search graphs

AND/OR search spaces. An AND/OR state space representation of a problem is deﬁned by a 4-tuple (cid:3)S, O, Sg, s0(cid:4).
S is a set of states which can be either OR or AND states (the OR states represent alternative ways for solving the
problem while the AND states often represent problem decomposition into subproblems, all of which need to be
solved). O is a set of operators. An OR operator transforms an OR state into another state, and an AND operator
transforms an AND state into a set of states. There is a set of goal states Sg ⊆ S and a start node s0 ∈ S. Example
problem domains modeled by AND/OR graphs are two-player games, parsing sentences and Tower of Hanoi [1].

The AND/OR state space model induces an explicit AND/OR search graph. Each state is a node and its child nodes
are those obtained by applicable AND or OR operators. The search graph includes a start node. The terminal nodes
(having no child nodes) are marked as Solved (S), or Unsolved (U).

A solution subtree of an AND/OR search graph G is a subtree which: (1) contains the start node s0; (2) if n in the
subtree is an OR node then it contains one of its child nodes in G and if n is an AND node it contains all its children
in G; (3) all its terminal nodes are “Solved” (S). AND/OR graphs can have a cost associated with each arc, and the
cost of a solution subtree is a function (e.g., sum-cost) of the arcs included in the solution subtree. In this case we may

76

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

seek a solution subtree with optimal (maximum or minimum) cost. Other tasks that enumerate all solution subtrees
(e.g., counting solutions) can also be deﬁned.

3. Graphical models

Graphical models include constraint networks deﬁned by relations of allowed tuples, (directed or undirected) prob-
abilistic networks, deﬁned by conditional probability tables over subsets of variables, cost networks deﬁned by cost
functions and inﬂuence diagrams which include both probabilistic functions and cost functions (i.e., utilities) [28].
Each graphical model comes with its typical queries, such as ﬁnding a solution, or an optimal one (over constraint
networks), ﬁnding the most probable assignment or updating the posterior probabilities given evidence, posed over
probabilistic networks, or ﬁnding optimal solutions for cost networks. The task for inﬂuence diagrams is to choose
a sequence of actions that maximizes the expected utility. Markov random ﬁelds are the undirected counterparts of
probabilistic networks. They are deﬁned by a collection of probabilistic functions called potentials, over arbitrary sub-
sets of variables. The framework presented in this paper is applicable across all graphical models that have discrete
variables, however we will draw most of our examples from constraint networks and directed probabilistic networks.
In general, a graphical model is deﬁned by a collection of functions F , over a set of variables X, conveying

probabilistic, deterministic or preferential information, whose structure is captured by a graph.

Deﬁnition 7 (graphical models). A graphical model R is a 4-tuple, R = (cid:3)X, D, F, ⊗(cid:4), where:

(1) X = {X1, . . . , Xn} is a set of variables;
(2) D = {D1, . . . , Dn} is the set of their respective ﬁnite domains of values;
(3) F = {f1, . . . , fr } is a set of real-valued functions each deﬁned over a subset of variables Si ⊆ X, called its scope,

and sometimes denoted by scope(fi);
(cid:2)
(cid:4)

(cid:5)

i fi ∈ {

i fi,

i fi, (cid:2)i fi} is a combination operator.1

(4)

The graphical model represents the combination of all its functions:

(cid:4)
r
i=1 fi .

Next, we introduce the notion of universal graphical model which is deﬁned by a single function.

Deﬁnition 8 (universal equivalent graphical model). Given a graphical model R = (cid:3)X, D, F, ⊗(cid:4), the universal equiv-
alent graphical model of R is u(R) = (cid:3)X, D, F = {

(cid:4)
r
i=1 fi}, ⊗(cid:4).

Two graphical models are equivalent if they have the same universal model.

Deﬁnition 9 (cost of a full and a partial assignment). Given a graphical model R, the cost of a full assignment
x = (x1, . . . , xn) is deﬁned by c(x) =
f ∈F f (x[scope(f )]). Given a subset of variables Y ⊆ X, the cost of a partial
assignment y is the combination of all the functions whose scopes are included in Y (FY ) evaluated at the assigned
values. Namely, c(y) =

f (y[scope(f )]).

(cid:4)

(cid:4)

f ∈FY

We can restrict a graphical model by conditioning on a partial assignment.

Deﬁnition 10 (conditioned graphical model). Given a graphical model R = (cid:3)X, D, F, ⊗(cid:4) and given a partial assign-
ment Y = y, Y ⊂ X, the conditioned graphical model is R|y = (cid:3)X, D|y, F |y, ⊗(cid:4), where D|y = {Di ∈ D, Xi /∈ Y } and
F |y = {f |Y =y, f ∈ F , and scope(f ) (cid:9)⊆ Y }.

Consistency. For most graphical models, the functions range has a special value “0” that is absorbing relative to
the combination operator (e.g., multiplication). Combining anything with “0” yields a “0”. The “0” value expresses
the notion of inconsistent assignments. It is a primary concept in constraint networks but can also be deﬁned relative
to other graphical models that have a “0” element.

1 The combination operator can also be deﬁned axiomatically [29].

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

77

Deﬁnition 11 (consistent partial assignment, solution). Given a graphical model having a “0” element, a partial
assignment is consistent if its cost is non-zero. A solution is a consistent assignment to all the variables.

Flat functions. Each function in a graphical model having a “0” element expresses implicitly a constraint. The
ﬂat constraint of function fi is a constraint Ri over its scope that includes all and only the consistent tuples. In this
paper, when we talk about a constraint network, we refer also to the ﬂat constraint network that can be extracted from
the general graphical model. When all the full assignments are consistent we say that the graphical model is strictly
positive.

Unless otherwise noted, we assume that functions are expressed in a tabular explicit form, having an entry for
every combination of values from the domains of their variables. Therefore, the speciﬁcation of such functions is
exponential in their scope size (the base of the exponent is the maximum domain size). Relations, or clauses, can be
expressed as functions as well, associating a value of “0” or “1” for each tuple, depending on whether or not the tuple
is in the relation (or satisﬁes a clause). The combination operator takes a set of functions and generates a new function
whose scope is the union of the input functions scopes.

Deﬁnition 12 (primal graph). The primal graph of a graphical model is an undirected graph that has variables as its
vertices and an edge connects any two variables that appear in the scope of the same function.

Reasoning problems, queries. There are various queries/tasks that can be posed over graphical models. We refer
to all as reasoning problems. In general, a reasoning problem is a function from the graphical model to some set of
elements, most commonly, the real numbers. We need one more functional operator, marginalization, to express most
of the common queries.

Deﬁnition 13 (reasoning problem). A reasoning problem over a graphical model is deﬁned by a marginalization
operator and a set of subsets. It is therefore a triplet, P = (cid:3)R, ⇓Y , {Z1, . . . , Zt }(cid:4), where R = (cid:3)X, D, F, ⊗(cid:4) is a
graphical model and Z = {Z1, . . . , Zt } is a set of subsets of variables of X. If S is the scope of function f and Y ⊆ X,
⇓Y f ∈ { max
S−Y f }, is a marginalization operator. P can be viewed as a vector function over the
scopes Z1, . . . , Zt . The reasoning problem is to compute PZ1,...,Zt (R):

S−Y f, min

(cid:5)
Y f,

S−Y f,

(cid:2)

PZ1,...,Zt (R) =

⇓Z1

(cid:6)

r(cid:7)

i=1

fi, . . . , ⇓Zt

r(cid:7)

i=1

(cid:8)

fi

.

We will focus primarily on reasoning problems deﬁned by Z = ∅. The marginalization operator is sometimes
called an elimination operator because it removes some arguments from the input function’s scope. Speciﬁcally, ⇓Y f
is deﬁned on Y . It therefore removes variables S − Y from f ’s scope, S. Note that here
is the relational projection
operator and unlike the rest of the marginalization operators the convention is that it is deﬁned by the set of variables
that are not eliminated.

(cid:5)

We next elaborate on the two popular graphical models of constraint networks and belief networks which will be

the primary focus of this paper.

3.1. Constraint networks

Constraint networks is a framework for formulating real world problems, such as scheduling and design, planning
and diagnosis, and many more as a set of constraints between variables. For example, one approach to formulating
a scheduling problem as a constraint satisfaction problem (CSP) is to create a variable for each resource and time
slice. Values of variables would be the tasks that need to be scheduled. Assigning a task to a particular variable
(corresponding to a resource at some time slice) means that this resource starts executing the given task at the speciﬁed
time. Various physical constraints (such as that a given job takes a certain amount of time to execute, or that a task can
be executed at most once) can be modeled as constraints between variables. The constraint satisfaction task is to ﬁnd
an assignment of values to all the variables that does not violate any constraints, or else to conclude that the problem
is inconsistent. Other tasks are ﬁnding all solutions and counting the solutions.

78

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

Deﬁnition 14 (constraint network). A constraint network (CN) is deﬁned by a 4-tuple, (cid:3)X, D, C, (cid:2)(cid:4), where X is a
set of variables X = {X1, . . . , Xn}, associated with a set of discrete-valued domains, D = {D1, . . . , Dn}, and a set of
constraints C = {C1, . . . , Cr }. Each constraint Ci is a pair (Si, Ri), where Ri is a relation Ri ⊆ DSi deﬁned on a subset
of variables Si ⊆ X. The relation denotes all compatible tuples of DSi allowed by the constraint. The combination
operator, (cid:2), is join. The primal graph of a constraint network is called a constraint graph. A solution is an assignment
of values to all the variables x = (x1, . . . , xn), xi ∈ Di , such that ∀Ci ∈ C, xSi
∈ Ri . The constraint network represents
its set of solutions, (cid:2)i Ci .

Constraint satisfaction is a reasoning problem P = (cid:3)R, Π, Z = ∅(cid:4), where R = (cid:3)X, D, C, (cid:2)(cid:4) is a constraint net-
work, and the marginalization operator is the projection operator Π . Namely, for constraint satisfaction Z = ∅, and
(cid:2)
⇓Y is ΠY . So the task is to ﬁnd ⇓∅
i fi which corresponds to enumerating all solutions. When the
combination operator is a product over the cost-based representation of the relations, and the marginalization op-
erator is logical summation we get 1 if the constraint problem has a solution and “0” otherwise. For counting, the
marginalization operator is summation and Z = ∅ too.

i fi = ΠX

(cid:4)

An immediate extension of constraint networks are cost networks where the set of functions are real-valued cost

functions, and the primary task is optimization.

(cid:4), where
Deﬁnition 15 (cost network, combinatorial optimization). A cost network is deﬁned by a 4-tuple, (cid:3)X, D, C,
X is a set of variables X = {X1, . . . , Xn}, associated with a set of discrete-valued domains, D = {D1, . . . , Dn}, and
a set of cost functions C = {C1, . . . , Cr }. Each Ci is a real-valued function deﬁned on a subset of variables Si ⊆ X.
The combination operator, is
. The reasoning problem is to ﬁnd a minimum or maximum cost solution which is
expressed via the marginalization operator of maximization or minimization, and Z = ∅.

(cid:2)

(cid:2)

A task such as MAX-CSP: ﬁnding a solution that satisﬁes the maximum number of constraints (when the problem
is inconsistent), can be deﬁned by treating each relation as a cost function that assigns “0” to consistent tuples and “1”
otherwise. Then the combination operator is summation and the marginalization operator is minimization. Namely,
the task is to ﬁnd ⇓∅

(cid:4)

(cid:2)

i fi = minX

i fi .

3.2. Propositional satisﬁability

A special case of a CSP is the propositional satisﬁability problem (SAT). A formula ϕ in conjunctive normal
form (CNF) is a conjunction of clauses α1, . . . , αt where a clause is a disjunction of literals (propositions or their
negations). For example, α = (P ∨ ¬Q ∨ ¬R) is a clause, where P , Q and R are propositions, and P , ¬Q and ¬R
are literals. The SAT problem requires deciding whether a given CNF theory has a model, i.e., a truth-assignment to
its propositions that does not violate any clause.

Propositional satisﬁability (SAT) can be deﬁned as a CSP, where propositions correspond to variables, domains are
{0, 1}, and constraints are represented by clauses, for example the clause (¬A ∨ B) is the relation (or function) over
its propositional variables that allows all tuples over (A, B) except (A = 1, B = 0).

3.3. Belief networks

Belief networks [30] provide a formalism for reasoning about partial beliefs under conditions of uncertainty. They
are deﬁned by a directed acyclic graph over vertices representing random variables of interest (e.g., the temperature
of a device, the gender of a patient, a feature of an object, the occurrence of an event). The arcs signify the existence
of direct causal inﬂuences between linked variables quantiﬁed by conditional probabilities that are attached to each
cluster of parents-child vertices in the network.

Deﬁnition 16 (belief networks). A belief network (BN) is a graphical model P = (cid:3)X, D, PG,
(cid:4), where X =
{X1, . . . , Xn} is a set of variables over multi-valued domains D = {D1, . . . , Dn}. Given a directed acyclic graph
G over X as nodes, PG = {Pi}, where Pi = {P (Xi|pa(Xi))} are conditional probability tables (CPTs for short) as-
sociated with each Xi , where pa(Xi) are the parents of Xi in the acyclic graph G. A belief network represents a

(cid:5)

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

79

probability distribution over X, P (x1, . . . , xn) =
variables.

(cid:5)
n
i=1 P (xi|xpa(Xi )). An evidence set e is an instantiated subset of

When formulated as a graphical model, functions in F denote conditional probability tables and the scopes of these
functions are determined by the directed acyclic graph G: each function fi ranges over variable Xi and its parents
in G. The combination operator is
j . The primal graph of a belief network is called a moral graph. It connects
any two variables appearing in the same CPT.

(cid:4)

(cid:5)

=

j

Deﬁnition 17 (belief updating). Given a belief network and evidence e, the belief updating task is to compute the
posterior marginal probability of variable Xi , conditioned on the evidence. Namely,

Bel(Xi = xi) = α

(cid:9)

n(cid:10)

P (xk, e|xpak ),

{(x1,...,xi−1,xi+1,...,xn)|E=e,Xi =xi }

k=1

where α is a normalization constant. In this case, the marginalization operator is ⇓Y =
∀Xi, ⇓Xi

k Pk. The query of ﬁnding the probability of the evidence is deﬁned by Z = ∅.

X−Y , and Zi = {Xi}. Namely,

k fk =

(cid:4)

(cid:2)

(cid:5)

{X−Xi |Xi =xi }

(cid:2)

Deﬁnition 18 (most probable explanation). The most probable explanation (MPE) task is to ﬁnd a complete assign-
ment which agrees with the evidence, and which has the highest probability among all such assignments. Namely, to
ﬁnd an assignment (xo

1 , . . . , xo

n) such that
n(cid:10)

P (xo

1 , . . . , xo

n) = max
x1,...,xn

P (xk, e|xpak ).

k=1

As a reasoning problem, an MPE task is to ﬁnd ⇓∅

max and Z = ∅.

(cid:4)

i fi = maxX

(cid:5)

i Pi . Namely, the marginalization operator is

Markov networks are graphical models very similar to belief networks. The only difference is that the set of prob-
abilistic functions Pi , called potentials, can be deﬁned over any subset of variables. An important reasoning task for
Markov networks is to ﬁnd the partition function which is deﬁned by the marginalization operator of summation,
where Z = ∅.

4. AND/OR search trees for graphical models

We will next present the AND/OR search space for a general graphical model starting with an example of a

constraint network.

Example 19. Consider the simple tree graphical model (i.e., the primal graph is a tree) in Fig. 1(a), over domains
{1, 2, 3}, which represents a graph-coloring problem. Namely, each node should be assigned a value such that adjacent
nodes have different values. Once variable X is assigned the value 1, the search space it roots can be decomposed
into two independent subproblems, one that is rooted at Y and one that is rooted at Z, both of which need to be
solved independently. Indeed, given X = 1, the two search subspaces do not interact. The same decomposition can
be associated with the other assignments to X, (cid:3)X, 2(cid:4) and (cid:3)X, 3(cid:4). Applying the decomposition along the tree (in
Fig. 1(a) yields the AND/OR search tree in Fig. 1(c). In the AND/OR space a full assignment to all the variables
is not a path but a subtree. For comparison, the traditional OR search tree is depicted in Fig. 1(b). Clearly, the size
of the AND/OR search space is smaller than that of the regular OR space. The OR search space has 3 · 27 nodes
while the AND/OR has 3 · 25 (compare 1(b) with 1(c)). If k is the domain size, a balanced binary tree with n nodes
has an OR search tree of size O(kn). The AND/OR search tree, whose pseudo tree has depth O(log2 n), has size
O((2k)log2 n) = O(n · klog2 n) = O(n1+log2 k). When k = 2, this becomes O(n2).

The AND/OR space is not restricted to tree graphical models. It only has to be guided by a backbone tree which
spans the original primal graph of the graphical model in a particular way. We will deﬁne the AND/OR search space
relative to a depth-ﬁrst search tree (DFS tree) of the primal graph ﬁrst, and will generalize to a broader class of
backbone spanning trees subsequently. For completeness sake we deﬁne DFS spanning tree, next.

80

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

Fig. 1. OR vs. AND/OR search trees; note the connector for AND arcs.

Deﬁnition 20 (DFS spanning tree). Given a DFS traversal ordering of an undirected graph G = (V , E), d =
X1, . . . , Xn, the DFS spanning tree T of G is deﬁned as the tree rooted at the ﬁrst node, X1, which includes only the
traversed arcs of G. Namely, T = (V , E(cid:14)), where E(cid:14) = {(Xi, Xj ) | Xj traversed from Xi}.

We are now ready to deﬁne the notion of AND/OR search tree for a graphical model.

Deﬁnition 21 (AND/OR search tree). Given a graphical model R = (cid:3)X, D, F, ⊗(cid:4), its primal graph G and a backbone
DFS tree T of G, the associated AND/OR search tree, denoted ST (R), has alternating levels of AND and OR nodes.
The OR nodes are labeled Xi and correspond to the variables. The AND nodes are labeled (cid:3)Xi, xi(cid:4) (or simply xi )
and correspond to the value assignments in the domains of the variables. The structure of the AND/OR search tree
is based on the underlying backbone tree T . The root of the AND/OR search tree is an OR node labeled by the root
of T . A path from the root of the search tree ST (R) to a node n is denoted by πn. If n is labeled Xi or xi the path
will be denoted πn(Xi) or πn(xi), respectively. The assignment sequence along path πn, denoted asgn(πn) is the set
of value assignments associated with the sequence of AND nodes along πn:

(cid:12)
(cid:11)
πn(Xi)
(cid:11)
(cid:12)
πn(xi)

(cid:13)

(cid:14)
=
;
(cid:3)X1, x1(cid:4), (cid:3)X2, x2(cid:4), . . . , (cid:3)Xi−1, xi−1(cid:4)
(cid:14)
(cid:13)
(cid:3)X1, x1(cid:4), (cid:3)X2, x2(cid:4), . . . , (cid:3)Xi, xi(cid:4)

.

=

asgn

asgn

The set of variables associated with OR nodes along path πn is denoted by var(πn): var(πn(Xi)) = {X1, . . . , Xi−1},
var(πn(xi)) = {X1, . . . , Xi}. The exact parent-child relationships between nodes in the search space are deﬁned as
follows:

(1) An OR node, n, labeled by Xi has a child AND node, m, labeled (cid:3)Xi, xi(cid:4) iff (cid:3)Xi, xi(cid:4) is consistent with the

assignment asgn(πn). Consistency is deﬁned relative to the ﬂat constraints.

(2) An AND node m, labeled (cid:3)Xi, xi(cid:4) has a child OR node r labeled Y , iff Y is a child of X in the backbone tree T .
Each OR arc, emanating from an OR to an AND node is associated with a weight to be deﬁned shortly (see
Deﬁnition 26).

Clearly, if a node n is labeled Xi (OR node) or xi (AND node), var(πn) is the set of variables mentioned on the

path from the root to Xi in the backbone tree, denoted by pathT (Xi).2

2 When the AND/OR tree is extended to dynamic variable orderings the set of variables along different paths may vary.

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

81

A solution subtree is deﬁned in the usual way:

Deﬁnition 22 (solution subtree). A solution subtree of an AND/OR search tree contains the root node. For every OR
nodes it contains one of its child nodes and for each of its AND nodes it contains all its child nodes, and all its leaf
nodes are consistent.

Example 23. In the example of Fig. 1(a), T is the DFS tree which is the tree rooted at X, and accordingly the root OR
node of the AND/OR tree in 1(c) is X. Its child nodes are labeled (cid:3)X, 1(cid:4), (cid:3)X, 2(cid:4), (cid:3)X, 3(cid:4) (only the values are noted in
the ﬁgure), which are AND nodes. From each of these AND nodes emanate two OR nodes, Y and Z, since these are
the child nodes of X in the DFS tree of 1(a). The descendants of Y along the path from the root, ((cid:3)X, 1(cid:4)), are (cid:3)Y, 2(cid:4)
and (cid:3)Y, 3(cid:4) only, since (cid:3)Y, 1(cid:4) is inconsistent with (cid:3)X, 1(cid:4). In the next level, from each node (cid:3)Y, y(cid:4) emanate OR nodes
labeled T and R and from (cid:3)Z, z(cid:4) emanate nodes labeled L and M as dictated by the DFS tree. In 1(c) a solution tree
is highlighted.

4.1. Weights of OR-AND arcs

The arcs in AND/OR trees are associated with weights w that are deﬁned based on the graphical model’s functions

and combination operator. The simplest case is that of constraint networks.

Deﬁnition 24 (arc weight for constraint networks). Given an AND/OR tree ST (R) of a constraint network R, each
terminal node is assumed to have a single, dummy, outgoing arc. The outgoing arc of a terminal AND node always
has the weight “1” (namely it is consistent and thus solved). An outgoing arc of a terminal OR node has weight “0”,
(there is no consistent value assignment). The weight of any internal OR to AND arc is “1”. The arcs from AND to
OR nodes have no weight.

We next deﬁne arc weights for any graphical model using the notion of buckets of functions.

Deﬁnition 25 (buckets relative to a backbone tree). Given a graphical model R = (cid:3)X, D, F, ⊗(cid:4) and a backbone tree T ,
the bucket of Xi relative to T , denoted BT (Xi), is the set of functions whose scopes contain Xi and are included in
pathT (Xi), which is the set of variables from the root to Xi in T . Namely,

BT (Xi) =

(cid:13)

(cid:14)
f ∈ F | Xi ∈ scope(f ) and scope(f ) ⊆ pathT (Xi)

.

Deﬁnition 26 (OR-to-AND weights). Given an AND/OR tree ST (R), of a graphical model R,
the weight
w(n,m)(Xi, xi) of arc (n, m), where Xi labels n and xi labels m, is the combination of all the functions in BT (Xi)
(cid:4)
assigned by values along πm. Formally, w(n,m)(Xi, xi) =

f ∈BT (Xi ) f (asgn(πm)[scope(f )]).

Deﬁnition 27 (weight of a solution subtree). Given a weighted AND/OR tree ST (R), of a graphical model R, and
given a solution subtree t having OR-to-AND set of arcs arcs(t), the weight of t is deﬁned by w(t) =
e∈arcs(t) w(e).

(cid:4)

Example 28. Fig. 2 shows a belief network, a DFS tree that drives its weighted AND/OR search tree, and a portion of
the AND/OR search tree with the appropriate weights on the arcs expressed symbolically. In this case the bucket of
E contains the function P (E|A, B), and the bucket of C contains two functions, P (C|A) and P (D|B, C). Note that
P (D|B, C) belongs neither to the bucket of B nor to the bucket of D, but it is contained in the bucket of C, which is
the last variable in its scope to be instantiated in a path from the root of the tree. We see indeed that the weights on the
arcs from the OR node E and any of its AND value assignments include only the instantiated function P (E|A, B),
while the weights on the arcs connecting C to its AND child nodes are the products of the two functions in its bucket
instantiated appropriately. Fig. 3 shows a constraint network with four relations, a backbone DFS tree and a portion
of the AND/OR search tree with weights on the arcs. Note that the complex weights would reduce to “0” and “1” in
this case. However, since we use the convention that arcs appear in the search tree only if they represent a consistent
extension of a partial solution, we will not see arcs having zero weights.

82

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

Fig. 2. Arc weights for probabilistic networks.

4.2. Properties of AND/OR search tree

Fig. 3. Arc weights for constraint networks.

Any DFS tree T of a graph G has the property that the arcs of G which are not in T are back-arcs. Namely, they
connect a node to one of its ancestors in the backbone tree. This ensures that the scope of each function in F will be
fully assigned on some path in T , a property that is essential for the validity of the AND/OR search tree.

Theorem 29 (correctness). Given a graphical model R having a primal graph G and a DFS spanning tree T of G,
its weighted AND/OR search tree ST (R) is sound and complete, namely: 1) there is a one-to-one correspondence
between solution subtrees of ST (R) and solutions of R; 2) the weight of any solution tree equals the cost of the full
solution it denotes; namely, if t is a solution tree of ST (R) which denotes a solution x = (x1, . . . , xn) then c(x) = w(t).

The virtue of an AND/OR search tree representation is that its size may be far smaller than the traditional OR
search tree. The size of an AND/OR search tree depends on the depth of its backbone DFS tree T . Therefore, DFS
trees of smaller depth should be preferred to drive the AND/OR search tree. An AND/OR search tree becomes an OR
search tree when its DFS tree is a chain.

Theorem 30 (size bounds of AND/OR search tree). Given a graphical model R, with domains size bounded by k,
and a DFS spanning tree T having depth m and l leaves, the size of its AND/OR search tree ST (R) is O(l · km) (and
therefore also O(nkm) and O((bk)m) when b bounds the branching degree of T and n is the number of variables).
In contrast the size of its OR search tree along any ordering is O(kn). The above bounds are tight and realizable for
fully consistent graphical models. Namely, one whose all full assignments are consistent.

Table 1 demonstrates the size saving of AND/OR vs. OR search spaces for 5 random networks having 20 bivalued
variables, 18 CPTs with 2 parents per child and 2 root nodes, when all the assignments are consistent (remember that
this is the case when the probability distribution is strictly positive). The size of the OR space is the full binary tree

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

83

Table 1
OR vs. AND/OR search size, 20 nodes

Treewidth

Height

5
4
5
5
6

10
9
10
10
9

OR space

Time (sec.)

3.154
3.135
3.124
3.125
3.124

Nodes

2,097,151
2,097,151
2,097,151
2,097,151
2,097,151

AND/OR space

Time (sec.)

AND nodes

OR nodes

0.03
0.01
0.03
0.02
0.02

10,494
5,102
8,926
7,806
6,318

5,247
2,551
4,463
3,903
3,159

Fig. 4. (a) A graph; (b) a DFS tree T1; (c) a pseudo tree T2; (d) a chain pseudo tree T3.

of depth 20. The size of the full AND/OR space varies based on the backbone DFS tree. We can give a better analytic
bound on the search space size by spelling out the depth mi of each leaf node Li in T .

(cid:2)

Proposition 31. Given a graphical model R, with domains size bounded by k, and a backbone spanning tree T
having L = {L1, . . . , Ll} leaves, where depth of leaf Li is mi , then the size of its full AND/OR search tree ST (R)
l
k=1 kmi ). Alternatively, we can use the exact domain sizes for each variable yielding an even more accurate
is O(
expression O(

Lk∈L Π{Xj |Xj ∈pathT (Lk)}|D(Xj )|).

(cid:2)

4.3. From DFS trees to pseudo trees

There is a larger class of trees that can be used as backbones for AND/OR search trees, called pseudo trees [2].

They have the above mentioned back-arc property.

Deﬁnition 32 (pseudo tree, extended graph). Given an undirected graph G = (V , E), a directed rooted tree T =
(V , E(cid:14)) deﬁned on all its nodes is a pseudo tree if any arc of G which is not included in E(cid:14) is a back-arc in T , namely
it connects a node in T to an ancestor in T . The arcs in E(cid:14) may not all be included in E. Given a pseudo tree T of G,
the extended graph of G relative to T is deﬁned as GT = (V , E ∪ E(cid:14)).

Clearly, any DFS tree and any chain of a graph are pseudo trees.

Example 33. Consider the graph G displayed in Fig. 4(a). Ordering d1 = (1, 2, 3, 4, 7, 5, 6) is a DFS ordering of a
DFS tree T1 having the smallest DFS tree depth of 3 (Fig. 4(b)). The tree T2 in Fig. 4(c) is a pseudo tree and has a tree
depth of 2 only. The two tree-arcs (1, 3) and (1, 5) are not in G. Tree T3 in Fig. 4(d), is a chain. The extended graphs
GT1 , GT2 and GT3 are presented in Fig. 4(b), (c), (d) when we ignore directionality and include the dotted arcs.

It is easy to see that the weighted AND/OR search tree is well deﬁned when the backbone trees is a pseudo tree.

Namely, the properties of soundness and completeness hold and the size bounds are extendable.

84

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

Fig. 5. AND/OR search tree along pseudo trees T1 and T2.

Theorem 34 (properties of AND/OR search trees). Given a graphical model R and a backbone pseudo tree T , its
weighted AND/OR search tree ST (R) is sound and complete, and its size is O(l · km), where m is the depth of the
pseudo tree, l bounds its number of leaves, and k bounds the domain size.

Example 35. Fig. 5 shows the AND/OR search trees along the pseudo trees T1 and T2 from Fig. 4. Here the domains
of the variables are {a, b, c} and the constraints are universal. The AND/OR search tree based on T2 is smaller, because
T2 has a smaller depth than T1.

Finding good pseudo trees. Finding a pseudo tree or a DFS tree of minimal depth is known to be NP-complete.
However various greedy heuristics are available. For example, pseudo trees can be obtained by generating a heuristi-
cally good induced graph along an ordering d and then traversing the induced graph depth-ﬁrst, breaking ties in favor
of earlier variables [8]. For more information see [31,32].

The deﬁnition of buckets relative to a backbone tree extends to pseudo trees as well, and this allows the deﬁnitions
of weights for an AND/OR tree based on a pseudo tree. Next we deﬁne the notion of a bucket tree and show that it
corresponds to a pseudo tree. This relationship will be used to make additional connections between various graph
parameters.

Deﬁnition 36 (bucket tree [33]). Given a graphical model, its primal graph G and an ordering d, the bucket tree of G
along d is deﬁned as follows. Let G∗
d be the induced graph of G along d. Each variable X has an associated bucket,
denoted by BX, that contains X and its earlier neighbors in the induced graph G∗
d (similar to Deﬁnition 25). The
nodes of the bucket tree are the n buckets. Each node BX points to BY (BY is the parent of BX) if Y is the latest earlier
neighbor of X in G∗
d .

The following relationship between the treewidth and the depth of pseudo trees is known [8,26]. Given a tree
decomposition of a primal graph G having n nodes, whose treewidth is w∗, there exists a pseudo tree T of G whose
depth, m, satisﬁes: m (cid:2) w∗ · log n. It can also be shown that any bucket tree [33] yields a pseudo tree and that a
min-depth bucket tree yields min-depth pseudo trees. The depth of a bucket tree was also called elimination depth
in [26].

In summary,

Proposition 37. [8,26] The minimal depth m over all pseudo trees satisﬁes m (cid:2) w∗ · log n, where w∗ is the treewidth
of the primal graph of the graphical model.

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

85

Table 2
Average depth of pseudo trees vs. DFS trees; 100 instances of each random model

Model (DAG)
(N = 50, P = 2, C = 48)
(N = 50, P = 3, C = 47)
(N = 50, P = 4, C = 46)
(N = 100, P = 2, C = 98)
(N = 100, P = 3, C = 97)
(N = 100, P = 4, C = 96)

Width

9.5
16.1
20.9
18.3
31.0
40.3

Pseudo tree depth

DFS tree depth

16.82
23.34
28.31
27.59
41.12
50.53

36.03
40.60
43.19
72.36
80.47
86.54

Fig. 6. AND/OR search tree and backtrack-free tree.

Therefore,

Theorem 38. A graphical model that has treewidth w∗ has an AND/OR search tree whose size is O(n · k(w∗·log n)),
where k bounds the domain size and n is the number of variables.

For illustration, Table 2 shows the effect of DFS spanning trees against pseudo trees, both generated using brute-
force heuristics over randomly generated graphs, where N is the number of variables, P is the number of variables in
the scope of a function and C is the number of functions.

4.4. Pruning inconsistent subtrees for the ﬂat constraint networks

Most advanced constraint processing algorithms incorporate no-good learning, and constraint propagation during
search, or use variable elimination algorithms such as adaptive-consistency and directional resolution [34], generating
all relevant no-goods, prior to search. Such schemes can be viewed as compiling a representation that would yield a
pruned search tree. We next deﬁne the backtrack-free AND/OR search tree.

Deﬁnition 39 (backtrack-free AND/OR search tree). Given an AND/OR search tree ST (R), the backtrack-free
AND/OR search tree of R based on T , denoted BFT (R), is obtained by pruning from ST (R) all inconsistent subtrees,
namely all nodes that root no consistent partial solution.

Example 40. Consider 5 variables X, Y, Z, T , R over domains {2, 3, 5}, where the constraints are: X divides Y and
Z, and Y divides T and R. The constraint graph and the AND/OR search tree relative to the DFS tree rooted at X,
are given in Fig. 6(a). In 6(b) we present the ST (R) search space whose nodes’ consistency statuses (which will later
will be referred to as values) are already evaluated having value “1” if consistent and “0” otherwise. We also highlight

86

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

two solution subtrees; one depicted by solid lines and one by dotted lines. Part (c) presents BFT (R), where all nodes
that do not root a consistent solution are pruned.

If we traverse the backtrack-free AND/OR search tree we can ﬁnd a solution subtree without encountering
any dead-ends. Some constraint networks speciﬁcations yield a backtrack-free search space. Others can be made
backtrack-free by massaging their representation using constraint propagation algorithms before or during search.
In particular, it is well known that variable elimination algorithms such as adaptive-consistency [35] and directional
resolution [36], applied in a reversed order of d (where d is the DFS order of the pseudo tree), compile a constraint
speciﬁcation (resp., a Boolean CNF formula) that has a backtrack-free search space. Assuming that the reader is
familiar with variable elimination algorithms [16], we deﬁne:

Deﬁnition 41 (directional extension [35,36]). Let R be a constraint problem and let d be a DFS traversal ordering
of a backbone pseudo tree of its primal graph. We denote by Ed (R) the constraint network (resp., the CNF formula)
compiled by adaptive-consistency (resp., directional resolution) in reversed order of d.

Proposition 42. Given a Constraint network R, the AND/OR search tree of the directional extension Ed (R), when d is
a DFS ordering of T , is identical to the backtrack-free AND/OR search tree of R based on T . Namely ST (Ed (R)) =
BFT (R).

Example 43. In Example 40, if we apply adaptive-consistency in reverse order of X, Y, T , R, Z, the algorithm will
remove the values 3, 5 from the domains of both X and Z yielding a tighter constraint network R(cid:14). The AND/OR
search tree in Fig. 6(c) is both ST (R(cid:14)) and BFT (R).

Proposition 42 emphasizes the signiﬁcance of no-good learning [37] for deciding inconsistency or for ﬁnding
a single solution. These techniques are known as clause learning in SAT solvers, ﬁrst introduced by [38] and are
currently used in most advanced solvers [39]. Namely, when we apply no-good learning we explore the search space
whose many inconsistent subtrees are pruned. For counting however, and for other relevant tasks, pruning inconsistent
subtrees and searching the backtrack-free search tree yields a partial help only, as we elaborate later.

5. AND/OR search graphs

It is often the case that a search space that is a tree can become a graph if identical nodes are merged, because
identical nodes root identical search subspaces, and correspond to identical reasoning subproblems. Any two nodes
that root identical weighted subtrees can be merged, reducing the size search graph. For example, in Fig. 1(c), the
search trees below any appearance of (cid:3)Y, 2(cid:4) are all identical, and therefore can be merged.

Sometimes, two nodes may not root identical subtrees, but they could still root search subspaces that correspond to
equivalent subproblems. Nodes that root equivalent subproblems having the same universal model (see Deﬁnition 8)
even though the weighted subtrees may not be identical, can be uniﬁed, yielding an even smaller search graph, as we
will show.

We next formalize the notions of merging and unifying nodes and deﬁne the minimal AND/OR search graph.

5.1. Minimal AND/OR search graphs

An AND/OR search tree can also be viewed as a data structure that deﬁnes a universal graphical model (see

Deﬁnition 8), deﬁned by the weights of its set of solution subtrees (see Deﬁnition 22).

Deﬁnition 44 (universal graphical model of AND/OR search trees). Given a weighted AND/OR search tree G over a
set of variables X and domains D, its universal graphical model, denoted by U (G), is deﬁned by its set of solutions as
follows: if t is a solution subtree and x = asgn(t) is the assignment tuple associated with t, then deﬁne u(x) = w(t);
otherwise u(x) = 0.

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

87

Fig. 7. Merge vs. unify operators.

A graphical model R is equivalent to its AND/OR search tree, ST (R), which means that u(R) is identical to
U (ST (R)). We will next deﬁne sound merge operations that transform AND/OR search trees into graphs that preserve
equivalence.

Deﬁnition 45 (merge). Assume a given weighted AND/OR search graph S(cid:14)
T (R) can be the AND/OR search
tree ST (R)), and assume two paths π1 = πn1(xi) and π2 = πn2(xi) ending by AND nodes at level i having the same
label xi . Nodes n1 and n2 can be merged iff the weighted search subgraphs rooted at n1 and n2 are identical. The
merge operator, merge(n1, n2), redirects all the arcs going into n2 into n1 and removes n2 and its subgraph. It thus
transforms S(cid:14)
T into a smaller graph. When we merge AND nodes only we call the operation AND-merge. The same
reasoning can be applied to OR nodes, and we call the operation OR-merge.

T (R) (S(cid:14)

We next deﬁne the semantic notion of uniﬁable nodes, as opposed to the syntactic deﬁnition of merge.

Deﬁnition 46 (unify). Given a weighted AND/OR search graph G for a graphical model R and given two paths πn1
and πn2 having the same label on nodes n1 and n2, then n1 and n2 are uniﬁable, iff they root equivalent conditioned
subproblems (Deﬁnition 10). Namely, if R|asgn(π1) = R|asgn(π2).

Example 47. Let’s follow the example in Fig. 7 to clarify the difference between merge and unify. We have a graphical
model deﬁned by two functions (e.g., cost functions) over three variables. The search tree given in Fig. 7(c) cannot
be reduced to a graph by merge, because of the different arc weights. However, the two OR nodes labeled A root
equivalent conditioned subproblems (the cost of each individual solution is given at the leaves). Therefore, the nodes
labeled A can be uniﬁed, but they cannot be recognized as identical by the merge operator.

Proposition 48 (minimal graph). Given a weighted AND/OR search graph G based on pseudo tree T :

(1) The merge operator has a unique ﬁx point, called the merge minimal AND/OR search graph and denoted by

M merge
T

(G).

(2) The unify operator has a unique ﬁx point, called the unify minimal AND/OR search graph and denoted by

M unify
T

(G).

(3) Any two nodes n1 and n2 of G that can be merged can also be uniﬁed.

Deﬁnition 49 (minimal AND/OR search graph). The unify minimal AND/OR search graph of R relative to T will
also be simply called the minimal AND/OR search graph and be denoted by MT (R).

When T is a chain pseudo tree, the above deﬁnitions are applicable to the traditional OR search tree as well.
However, we may not be able to reach the same compression as in some AND/OR cases, because of the linear
structure imposed by the OR search tree.

88

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

Fig. 8. OR search tree for the tree problem in
Fig. 1(a).

Fig. 9. The minimal OR search graph of the
tree graphical model in Fig. 1(a).

Fig. 10. AND/OR search tree for the tree problem in
Fig. 1(a).

Fig. 11. The minimal AND/OR search graph of the tree graphical
model in Fig. 1(a).

Example 50. The smallest OR search graph of the graph-coloring problem in Fig. 1(a) is given in Fig. 9 along the
DFS order X, Y, T , R, Z, L, M. The smallest AND/OR graph of the same problem along the DFS tree is given in
Fig. 11. We see that some variable-value pairs (AND nodes) must be repeated in Fig. 9 while in the AND/OR case
they appear just once. In particular, the subgraph below the paths ((cid:3)X, 1(cid:4), (cid:3)Y, 2(cid:4)) and ((cid:3)X, 3(cid:4), (cid:3)Y, 2(cid:4)) in the OR tree
cannot be merged at (cid:3)Y, 2(cid:4). You can now compare all four search space representations side by side in Figs. 8–11.

Note that in the case of constraint networks we can accommodate an even more general deﬁnition of merging of
two AND nodes that are assigned different values from their domain, or two OR nodes labeled by different variables,
as long as they root identical subgraphs. In that case the merged node should be labeled by the disjunction of the two
assignments (this is similar to interchangeable values [23]).

5.2. Building AND/OR search graphs

In this subsection we will discuss practical algorithms for generating compact AND/OR search graphs of a given
graphical model. In particular we will identify effective rules for recognizing uniﬁable nodes, aiming towards the min-
imal AND/OR search graph as much as computational resources allow. The rules allow generating a small AND/OR

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

89

graph called the context minimal graph without creating the whole search tree ST ﬁrst. We focus ﬁrst on AND/OR
search graphs of graphical models having no cycles, called tree models (i.e., the primal graph is a tree).

5.2.1. Building AND/OR search graphs for tree models and tree decompositions

Consider again the graph in Fig. 1(a) and its AND/OR search tree in Fig. 1(c) representing a constraint network.
Observe that at level 3, node (cid:3)Y, 1(cid:4) appears twice, (and so are (cid:3)Y, 2(cid:4) and (cid:3)Y, 3(cid:4)). Clearly however, the subtrees rooted at
each of these two AND nodes are identical and we can reason that they can be merged because any speciﬁc assignment
to Y uniquely determines its rooted subtree. Indeed, the AND/OR search graph in Fig. 11 is equivalent to the AND/OR
search tree in Fig. 10 (same as Fig. 1(c)).

Deﬁnition 51 (explicit AND/OR graphs for constraints tree models). Given a tree model constraint network and the
pseudo tree T identical to its primal graph, the explicit AND/OR search graph of the tree model relative to T is
obtained from ST by merging all AND nodes having the same label (cid:3)X, x(cid:4).

Proposition 52. Given a rooted tree model T : (1) Its explicit AND/OR search graph is equivalent to ST . (2) The size of
the explicit AND/OR search graph is O(nk). (3) For some tree models the explicit AND/OR search graph is minimal.

The notion of explicit AND/OR search graph for a tree model is extendable to any general graphical models that
are trees. The only difference is that the arcs have weights. Thus, we need to show that merged nodes via the rule in
deﬁnition 51 root identical weighted AND/OR trees.

Proposition 53. Given a general graphical model whose graph is a tree T , its explicit AND/OR search graph is
equivalent to ST , and its size is O(nk).

Next, the question is how to identify efﬁciently mergeable nodes for general non-tree graphical models. A guiding
idea is to transform a graphical model into a tree decomposition ﬁrst, and then apply the explicit AND/OR graph
construction to the resulting tree decomposition. The next paragraph sketches this intuition.

A tree decomposition [33] (see Deﬁnition 5) of a graphical model partitions the functions into clusters. Each cluster
corresponds to a subproblem that has a set of solutions and the clusters interact in a tree-like manner. Once we have a
tree decomposition of a graphical model, it can be viewed as a regular (meta) tree model where each cluster is a node
and its domain is the cross product of the domains of variables in the cluster. The constraint between two adjacent
nodes in the tree decomposition is equality over the common variables. For more details about tree decompositions
see [33]. For the meta-tree model the explicit AND/OR search graph is well deﬁned: the OR nodes are the scopes
of clusters in the tree decomposition and the AND nodes, are their possible value assignments. Since the graphical
model is converted into a tree, its explicit AND/OR search graph is well deﬁned and we can bound its size.

Theorem 54. Given a tree decomposition of a graphical model, whose domain sizes are bounded by k, the explicit
AND/OR search graph implied by the tree decomposition has a size of O(rkw∗
), where r is the number of clusters in
the tree decomposition and w∗ is the size of the largest cluster.

The tree decomposition can guide an algorithm for generating an AND/OR search graph whose size is bounded

exponentially by the induced width, which we will refer to in the next section as the context minimal graph.

While the idea of explicit AND/OR graph based on a tree decomposition can be extended to any graphical model,
it is somewhat cumbersome. Instead, in the next section we propose a more direct approach for generating the context
minimal graph.

5.2.2. The context based AND/OR graph

We will now present a generative rule for merging nodes in the AND/OR search graph that yields the size bound
suggested above. We will need the notion of induced width of a pseudo tree of G for bounding the size of the AND/OR
search graphs. We denote by dDFS(T ) a linear DFS ordering of a tree T .

Deﬁnition 55 (induced width of a pseudo tree). The induced width of G relative to the pseudo tree T , wT (G), is the
induced width along the dDFS(T ) ordering of the extended graph of G relative to T , denoted GT .

90

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

Proposition 56. (1) The minimal induced width of G over all pseudo trees is identical to the induced width (treewidth),
w∗, of G. (2) The minimal induced width restricted to chain pseudo trees is identical to its pathwidth, pw∗.

Example 57. In Fig. 4(b), the induced graph of G relative to T1 contains also the induced arcs (1, 3) and (1, 5) and
its induced width is 2. GT2 is already triangulated (no need to add induced arcs) and its induced width is 2 as well.
GT3 has the added arc (4, 7) and when ordered it will have the additional induced arcs (1, 5) and (1, 3), yielding
induced width 2 as well.

We will now provide deﬁnitions that will allow us to identify nodes that can be merged in an AND/OR graph.
The idea is to ﬁnd a minimal set of variable assignments from the current path that will always generate the same
conditioned subproblem, regardless of the assignments that are not included in this minimal set. Since the current path
for an OR node Xi and an AND node (cid:3)Xi, xi(cid:4) differ by the assignment of Xi to xi (Deﬁnition 2), the minimal set of
assignments that we want to identify will be different for Xi and for (cid:3)Xi, xi(cid:4). In the following two deﬁnitions ancestors
and descendants are with respect to the pseudo tree T , while connection is with respect to the primal graph G.

Deﬁnition 58 (parents). Given a primal graph G and a pseudo tree T of a reasoning problem P, the parents of an OR
node Xi , denoted by pai or paXi , are the ancestors of Xi that have connections in G to Xi or to descendants of Xi .

Deﬁnition 59 (parent-separators). Given a primal graph G and a pseudo tree T of a reasoning problem P, the parent-
separators of Xi (or of (cid:3)Xi, xi(cid:4)), denoted by pasi or pasXi , are formed by Xi and its ancestors that have connections
in G to descendants of Xi .

It follows from these deﬁnitions that the parents of Xi , pai , separate in the primal graph G (and also in the extended
graph GT and in the induced extended graph GT ∗
) the ancestors (in T ) of Xi , from Xi and its descendants (in T ).
Similarly, the parent-separators of Xi , pasi , separate the ancestors of Xi from its descendants. It is also easy to see that
each variable Xi and its parents pai form a clique in the induced graph GT ∗
. The following proposition establishes
the relationship between pai and pasi .

Proposition 60.

(1) If Y is the single child of X in T , then pasX
(2) If X has children Y1, . . . , Yk in T , then pasX

= paY .
(cid:3)
k
=
i=1 paYi .

Theorem 61 (context based merge). Given GT ∗
graph, ending with two nodes, n1 and n2.

, let πn1 and πn2 be any two partial paths in an AND/OR search

(1) If n1 and n2 are AND nodes annotated by (cid:3)Xi, xi(cid:4) and

asgn(πn1 )[pasXi

] = asgn(πn2 )[pasXi

]

(1)

then the AND/OR search subgraphs rooted by n1 and n2 are equivalent and n1 and n2 can be merged.
asgn(πni )[pasXi

] is called the AND context of ni .

(2) If n1 and n2 are OR nodes annotated by Xi and

asgn(πn1 )[paXi

] = asgn(πn2 )[paXi

]

(2)

then the AND/OR search subgraphs rooted by n1 and n2 are equivalent and n1 and n2 can be merged.
asgn(πni )[paXi

] is called the OR context of ni .

Example 62. For the balanced tree in Fig. 1 consider the chain pseudo tree d = (X, Y, T , R, Z, L, M). Namely the
chain has arcs {(X, Y ), (Y, T ), (T , R), (R, Z), (Z, L), (L, M)} and the extended graph also includes the arcs (Y, T ),
(Z, X) and (M, Z). The parent-separators of T along d are XY T (since the induced graph has the arc (T , X)), of R
are XR, for Z they are Z and for M they are M. Indeed in the ﬁrst 3 levels of the OR search graph in Fig. 9 there are

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

91

no merged nodes. In contrast, if we consider the AND/OR ordering along the DFS tree, the parent-separators of every
node are the node itself, yielding a single appearance of each AND node having the same assignment annotation in
the minimal AND/OR graph.

Deﬁnition 63 (context minimal AND/OR search graph). The AND/OR search graph of R based on the backbone tree
T that is closed under context-based merge operator is called context minimal AND/OR search graph and is denoted
by CT (R).

We should note that we can in general merge nodes based both on AND and OR contexts. However, Proposition
60 shows that doing just one of them renders the other unnecessary (up to some small constant factor). In practice, we
would recommend just the OR context based merging, because it has a slight (albeit by a small constant factor) space
advantage. In the examples that we give in this paper, CT (R) refers to an AND/OR search graph for which either the
AND context based or OR context based merging was performed exhaustively.

Example 64. Consider the example given in Fig. 12(a). The OR context of each node in the pseudo tree is given in
square brackets. The context minimal AND/OR search graph (based on OR merging) is given in Fig. 12(b).

Since the number of nodes in the context minimal AND/OR search graph cannot exceed the number of different

contexts, we can bound the size of the context minimal graph.

Theorem 65. Given a graphical model R, its primal graph G, and a pseudo tree T having induced width w = wT (G),
the size of the context minimal AND/OR search graph based on T , CT (R), is O(n · kw), when k bounds the domain
size.

Note that the criterion in Eqs. (1) and (2) is cautious. First, the real number of assignments over context variables
includes only consistent assignments. Second, we have already seen (Example 7) that there exist nodes that can be
uniﬁed but not merged. Here we give an example that shows that contexts can not identify all the nodes that can be
merged. There could be paths whose contexts are not identical, yet they might root identical subgraphs.

Example 66. Let’s return to the example of the Bayesian network given in Fig. 12(a), where P (D|B, C) is given in
the table, and the OR-context of each node in the pseudo tree is given in square brackets. Fig. 12(b) shows the context

Fig. 12. Context minimal vs. minimal AND/OR graphs.

92

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

minimal graph. However, we can see that P (D = 0|B = 0, C = 0) = P (D = 0|B = 1, C = 0) = x and P (D = 1|B =
0, C = 0) = P (D = 1|B = 1, C = 0) = y. This allows the merging of the corresponding OR nodes labeled with D,
and Fig. 12(c) shows the merge minimal graph.

The context based merge offers a powerful way of bounding the search complexity:

Theorem 67. The context minimal AND/OR search graph CT of a graphical model having a backbone tree with
bounded treewidth w can be generated in time and space O(nkw).

Since the unify minimal AND/OR graph M unify

are subsets of
CT , both are bounded by O(n · kw), where w = wT (G). Since minT {wT (G)} is equal to the treewidth w∗ and since
minT ∈chains{wT (G)} is equal to the pathwidth pw∗, we get:
Corollary 68. Given a graphical model R, there exists a backbone tree T such that the unify minimal, merge minimal
and context minimal AND/OR search graphs of R are bounded exponentially by the treewidth of the primal graph.
The unify, merge and context minimal OR search graphs can be bounded exponentially by the pathwidth only.

and the merge minimal AND/OR graph M merge

T

T

5.2.3. More on OR vs. AND/OR

It is well known [26] that for any graph w∗ (cid:2) pw∗ (cid:2) w∗ · log n. It is easy to place m∗ (the minimal depth over
pseudo trees) in that relation yielding w∗ (cid:2) pw∗ (cid:2) m∗ (cid:2) w∗ · log n. It is also possible to show that there exist primal
graphs for which the upper bound on pathwidth is attained, that is pw∗ = O(w∗ · log n).

Consider a complete binary tree of depth m. In this case, w∗ = 1, m∗ = m, and it is also known [40,41] that:

Theorem 69. [41] If T is a binary tree of depth m then pw∗(T ) (cid:3) m
2 .

Theorem 69 shows that for graphical models having a bounded tree width w, the minimal AND/OR graph is
bounded by O(nkw) while the minimal OR graph is bounded by O(nkw·log n). Therefore, even when caching, the use
of an AND/OR vs. an OR search space can yield a substantial saving.

Remark 70. We have seen that AND/OR trees are characterized by the depth of the pseudo trees while minimal
AND/OR graphs are characterized by their induced width. It turns out however that sometimes a pseudo tree that is
optimal relative to w is far from optimal for m and vice versa. For example a primal graph model that is a chain has
a pseudo tree having m1 = n and w1 = 1 on one hand, and another pseudo tree that is balanced having m2 = log n
and w2 = log n. There is no single pseudo tree having both w = 1 and m = log n for a chain. Thus, if we plan to
have linear space search we should pick one kind of a backbone pseudo tree, while if we plan to search a graph, and
therefore cache some nodes, another pseudo tree should be used.

5.3. On the canonicity and generation of the minimal AND/OR graph

We showed that the merge minimal AND/OR graph is unique for a given graphical model, given a backbone pseudo
tree (Proposition 48). In general, it subsumes the minimal AND/OR graph, and sometimes can be identical to it. For
constraint networks we will now prove a more signiﬁcant property of uniqueness relative to all equivalent graphical
models given a backbone tree. We will prove this notion relative to backtrack-free search graphs which are captured
by the notion of strongly minimal AND/OR graph. Remember that any graphical model can have an associated ﬂat
constraint network.

Deﬁnition 71 (strongly minimal AND/OR graph3). A strongly minimal AND/OR graph of R relative to a pseudo tree
T is the minimal AND/OR graph, MT (R), that is backtrack-free (i.e., any partial assignment in the graph leads to a
solution), denoted by M ∗

T (R). The strongly (backtrack-free) context minimal graph is denoted C∗

T (R).

3 The minimal graph is built by lumping together “uniﬁable” nodes, which are those that root equivalent subproblems. Therefore, at each level
(corresponding to one variable), all the nodes that root inconsistent subproblems will be uniﬁed. If we eliminate the redundant nodes, the minimal
graph is already backtrack free.

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

93

5.3.1. Canonicity of strongly minimal AND/OR search graphs

We brieﬂy discuss here the canonicity of the strongly minimal graph, focusing on constraint networks. Given two
equivalent constraint networks representing the same set of solutions, where each may have a different constraint
graph, are their strongly minimal AND/OR search graphs identical?

The above question is not well deﬁned however, because an AND/OR graph for R is deﬁned only with respect to
a backbone pseudo tree. We can have two equivalent constraint networks having two different graphs where a pseudo
tree for one graph may not be a pseudo tree for the other. Consider, for example a constraint network having three
variables: X, Y and Z and equality constraints. The following networks, R1 = {RXY = (X = Y ), RY Z = (Y = Z)}
and R2 = {RXZ = (X = Z), RY Z = (Y = Z)} and R3 = {RXY = (X = Y ), RY Z = (Y = Z), RXZ = (X = Z)} are
equivalent. However, T1 = (X ← Y → Z) is a pseudo tree for R1, but not for R2 neither for R3. We ask therefore a
different question: given two equivalent constraint networks and given a backbone tree that is a pseudo tree for both,
is the strongly minimal AND/OR graph relative to T unique?

We will answer this question positively quite straightforwardly. We ﬁrst show that equivalent networks that share
a backbone tree have identical backtrack-free AND/OR search trees. Since the backtrack-free search trees uniquely
determine their strongly minimal graph the claim follows.

Deﬁnition 72 (shared pseudo trees). Given a collection of graphs on the same set of nodes, we say that the graphs
share a tree T , if T is a pseudo tree of each of these graphs. A set of graphical models deﬁned over the same set of
variables share a tree T , iff their respective primal graphs share T .

Proposition 73. (1) If R1 and R2 are two equivalent constraint networks that share T , then BFT (R1) = BFT (R2)
(see Deﬁnition 39). (2) If R1 and R2 are two equivalent graphical models (not necessarily constraint networks) that
share T , then BFT (R1) = BFT (R2) as AND/OR search trees although their arcs may not have identical weights.

Theorem 74. If R1 and R2 are two equivalent constraint networks that share T , then M ∗

T (R1) = M ∗

T (R2).

Theorem 74 implies that M ∗

T is a canonical representation of a constraint network R relative to T .

Generating the strongly minimal AND/OR graphs

From the above discussion we see that several methods for generating the canonical AND/OR graph of a given
graphical model, or a given AND/OR graph may emerge. The method we focused on in this paper is to generate the
context minimal AND/OR graph ﬁrst. Then we can process this graph from leaves to root, while computing the value
of nodes, and additional nodes can be uniﬁed or pruned (if their value is “0”).

There is another approach that is based on processing the functions in a variable elimination style, when viewing
the pseudo tree as a bucket tree or a cluster tree. The original functions can be expressed as AND/OR graphs and
they will be combined pairwise until an AND/OR graph is generated. This phase allows computing the value of each
node (see Section 6) and therefore allows for uniﬁcation. Subsequently a forward phase will allow generating the
backtrack-free representation as well as allow computing the full values associated with each node. The full details of
this approach are out of the scope of the current paper. For initial work restricted to constraint networks see [42].

5.4. Merging and pruning: Orthogonal concepts

Notice that the notion of minimality is orthogonal to that of pruning inconsistent subtrees (yielding the backtrack-
free search space). We can merge two identical subtrees whose root value is “0” but still keep their common subtree.
However, since our convention is that we don’t keep inconsistent subtrees we should completely prune them, irrespec-
tive of them rooting identical or non-identical subtrees. Therefore, we can have a minimal search graph that is not
backtrack-free as well as a non-minimal search graph (e.g., a tree) that is backtrack-free.

When the search space is backtrack-free and if we seek a single solution, the size of the minimal AND/OR search
graph and its being OR vs. AND/OR are both irrelevant. It will, however, affect a traversal algorithm that counts all
solutions or computes an optimal solution as was often observed [43]. For counting and for optimization tasks, even

94

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

Fig. 13. AND/OR trees.

Fig. 14. AND/OR graphs.

Fig. 15. (a) A constraint graph; (b) a spanning tree; (c) a dynamic AND/OR tree.

when we record all no-goods and cache all nodes by context, the impact of the AND/OR graph search vs. the OR
graph search can still be signiﬁcant.

Example 75. Consider the graph problem in Fig. 6(a) when we add the value 4 to the domains of X and Z. Fig. 13(a)
gives the full AND/OR search tree and Fig. 13(b) gives the backtrack-free search tree. Fig. 14(a) gives the context
minimal but unpruned search graph and Fig. 14(b) gives the minimal and pruned search graph.

5.5. Using dynamic variable ordering

The AND/OR search tree we deﬁned uses a ﬁxed variable ordering. It is known that exploring the search space in
a dynamic variable ordering is highly beneﬁcial. AND/OR search trees for graphical models can also be modiﬁed to
allow dynamic variable ordering. A dynamic AND/OR tree that allows varied variable ordering has to satisfy that for
every subtree rooted by the current path π , any arc of the primal graph that appears as a cross-arc (not a back-arc) in
the subtree must be “inactive” conditioned on π .

Example 76. Consider the propositional formula X → A ∨ C and X → B ∨ C. The constraint graph is given in
Fig. 15(a) and a DFS tree in 15(b). However, the constraint subproblem conditioned on (cid:3)X, 0(cid:4), has no real constraint

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

95

between A, B, C, so the effective spanning tree below (cid:3)X, 0(cid:4) is {(cid:3)X, 0(cid:4) → A, (cid:3)X, 0(cid:4) → B, (cid:3)X, 0(cid:4) → C}, yielding the
AND/OR search tree in Fig. 15(c). Note that while there is an arc between A and C in the constraint graph, the arc is
not active when X is assigned the value 0.

Clearly, the constraint graph conditioned on any partial assignment can only be sparser than the original graph
and therefore may yield a smaller AND/OR search tree than with ﬁxed ordering. In practice, after each new value
assignment, the conditional constraint graph can be assessed as follows. For any constraint over the current variable X,
if the current assignment (cid:3)X, x(cid:4) does not make the constraint active then the corresponding arcs can be removed from
the graph. Then, a pseudo tree of the resulting graph is generated, its ﬁrst variable is selected, and search continues.
A full investigation of dynamic orderings is outside the scope of the current paper.

6. Solving reasoning problems

6.1. Value functions of reasoning problems

As we described earlier, there are a variety of reasoning problems over weighted graphical models. For constraint
networks, the most popular tasks are to decide if the problem is consistent, to ﬁnd a single solution or to count
solutions. If there is a cost function deﬁned we may also seek an optimal solution. The primary tasks over probabilistic
networks are belief updating, ﬁnding the probability of the evidence and ﬁnding the most likely tuple given the
evidence. Each of these reasoning problems can be expressed as ﬁnding the value of some nodes in the weighted
AND/OR search space where different tasks call for different value deﬁnitions. For example, for the task of ﬁnding
a solution to a constraint network, the value of every node is either “1” or “0”. The value “1” means that the subtree
rooted at the node is consistent and “0” otherwise. Therefore, the value of the root node answers the consistency query.
For solutions-counting the value function of each node is the number of solutions rooted at that node.

Deﬁnition 77 (value function for consistency and counting). Given a weighted AND/OR tree ST (R) of a constraint
network: The value of a node (AND or OR) for deciding consistency is “1” if it roots a consistent subproblem and “0”
otherwise; The value of a node (AND or OR) for counting solutions is the number of solutions in its subtree.

It is easy to see that the value of nodes in the search graph can be computed recursively from leaves to root.

Proposition 78 (recursive value computation). (1) For the consistency task the value of AND leaves is their labels and
the value of OR leaves is “0” (they are inconsistent). An internal OR node is labeled “1” if one of its successor nodes
is “1” and an internal AND node has value “1” iff all its successor OR nodes have value “1”.

(2) The counting values of leaf AND nodes are “1” and of leaf OR nodes are “0”. The counting value of an internal
OR node is the sum of the counting values of all its child nodes. The counting value of an internal AND node is the
product of the counting values of all its child nodes.

We can now generalize to any reasoning problem, focusing on the simpliﬁed case when Z = ∅, namely when the
marginalization has to be applied to all the variables. This special case captures most tasks of interest. We will start
with the recursive deﬁnition.

Deﬁnition 79 (recursive deﬁnition of values). The value function of a reasoning problem P = (cid:3)R, ⇓Y , Z(cid:4), where
R = (cid:3)X, D, F, ⊗(cid:4) and Z = ∅, is deﬁned as follows: the value of leaf AND nodes is “1” and of leaf OR nodes is “0”.
The value of an internal OR node is obtained by combining the value of each AND child node with the weight (see
Deﬁnition 26) on its incoming arc and then marginalizing over all AND children. The value of an AND node is the
combination of the values of its OR children. Formally, if children(n) denotes the children of node n in the AND/OR
search graph, then:

(cid:7)

v(n) =

v(n

(cid:14)

),

if n = (cid:3)Y, y(cid:4) is an AND node,

n(cid:14)∈children(n)
v(n) =⇓X−({Y }∪children(n))

(cid:11)
w(n,n(cid:14)) ⊗ v(n

(cid:14)

(cid:12)
n(cid:14)∈children(n),
)

if n = Y is an OR node.

96

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

The following proposition states that given a reasoning task, computing the value of the root node solves the given

reasoning problem.

Proposition 80. Let P = (cid:3)R, ⇓Y , Z(cid:4), where R = (cid:3)X, D, F, ⊗(cid:4) and Z = ∅, and let X1 be the root node in any
AND/OR search graph S(cid:14)

(cid:4)
r
i=1 fi when v is deﬁned in Deﬁnition 79.

T (R). Then v(X1) =⇓∅

Search algorithms that traverse the AND/OR search space can compute the value of the root node yielding the an-
swer to the problem. The following section discusses such algorithms. Algorithms that traverse the weighted AND/OR
search tree in a depth-ﬁrst manner or a breadth-ﬁrst manner are guaranteed to have a time bound exponential in the
depth of the pseudo tree of the graphical model. Depth-ﬁrst searches can be accomplished using either linear space
only, or context based caching, bounded exponentially by the treewidth of the pseudo tree. Depth-ﬁrst search is an
anytime scheme and can, if terminated, provide an approximate solution for some tasks such as optimization. The next
subsection presents typical depth-ﬁrst algorithms that search AND/OR trees and graphs. We use solution counting as
an example for a constraint query and the probability of evidence as an example for a probabilistic reasoning query.
The algorithms compute the value of each node. For application of these ideas for combinatorial optimization tasks,
such as MPE, see [31].

6.2. Algorithm AND/OR tree search and graph search

Algorithm 1 presents the basic depth-ﬁrst traversal of the AND/OR search tree (or graph, if caching is used) for
counting the number of solutions of a constraint network, AO-COUNTING (or for probability of evidence for belief
networks, AO-BELIEF-UPDATING).

The context based caching is done based on tables. We exemplify with OR caching. For each variable Xi , a table
is reserved in memory for each possible assignment to its parent set pai . Initially each entry has a predeﬁned value, in
our case “−1”. The fringe of the search is maintained on a stack called OPEN. The current node is denoted by n, its
parent by p, and the current path by πn. The children of the current node are denoted by successors(n).

The algorithm is based on two mutually recursive steps: EXPAND and PROPAGATE, which call each other (or

themselves) until the search terminates.

Since we only use OR caching, before expanding an OR node, its cache table is checked (line 6). If the same context
was encountered before, it is retrieved from cache, and successors(n) is set to the empty set, which will trigger the
PROPAGATE step.

If a node is not found in cache, it is expanded in the usual way, depending on whether it is an AND or OR node
(lines 10–17). The only difference between counting and belief updating is line 12 vs. line 13. For counting, the value
of a consistent AND node is initialized to 1 (line 12), while for belief updating, it is initialized to the bucket value for
the current assignment (line 13). As long as the current node is not a dead-end and still has unevaluated successors,
one of its successors is chosen (which is also the top node on OPEN), and the expansion step is repeated.

The bottom up propagation of values is triggered when a node has an empty set of successors (note that as each
successor is evaluated, it is removed from the set of successors in line 31). This means that all its children have been
evaluated, and its ﬁnal value can now be computed. If the current node is the root, then the search terminates with its
value (line 20). If it is an OR node, its value is saved in cache before propagating it up (line 22). If n is OR, then its
parent p is AND and p updates its value by multiplication with the value of n (line 24). If the newly updated value
of p is 0 (line 25), then p is a dead-end, and none of its other successors needs to be evaluated. An AND node n
propagates its value to its parent p in a similar way, only by summation (line 30). Finally, the current node n is set
to its parent p (line 32), because n was completely evaluated. The search continues either with a propagation step (if
conditions are met) or with an expansion step.

6.3. General AND-OR search—AO(i)

General AND/OR algorithms for evaluating the value of a root node for any reasoning problem using tree or graph
AND/OR search are identical to the above algorithms when product is replaced by the combination operator and

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

97

Algorithm 1. AO-counting/AO-belief-updating.

summation is replaced by the marginalization operator. We can view the AND/OR tree algorithm (which we will
denote AOT) and the AND/OR graph algorithm (denoted AOG) as two extreme cases in a parameterized collection of
algorithms that trade space for time via a controlling parameter i. We denote this class of algorithms as AO(i) where
i determines the size of contexts that the algorithm caches. Algorithm AO(i) records nodes whose context size is i or
smaller (the test in line 22 needs to be a bit more elaborate and check if the context size is smaller than i). Thus AO(0)
is identical to AOT, while AO(w) is identical to AOG, where w is the induced width of the used backbone tree. For
any intermediate i we get an intermediate level of caching, which is space exponential in i and whose execution time
will increase as i decreases.

6.4. Complexity

From Theorems 34 and 38 we can conclude that:

Theorem 81. For any reasoning problem, AOT runs in linear space and time O(nkm), when m is the depth of the
pseudo tree of its graphical model and k is the maximum domain size. If the primal graph has a tree decomposition
with treewidth w∗, there exists a pseudo tree T for which AOT is O(nkw∗·log n).

98

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

Obviously, the algorithm for constraint satisfaction, that would terminate early with ﬁrst solution, would potentially

be much faster than the rest of the AOT algorithms, in practice.

Based on Theorem 65 we get complexity bounds for graph searching algorithms.

Theorem 82. For any reasoning problem, the complexity of algorithm AOG is time and space O(nkw), where w is
the induced width of the pseudo tree and k is the maximum domain size.

Thus the complexity of AOG can be time and space exponential in the treewidth, while the complexity of any
algorithm searching the OR space can be time and space exponential in its pathwidth. The space complexity can often
be less than exponential in the treewidth. This is similar to the well known space complexity of tree decomposition
schemes which can operate in space exponential only in the size of the cluster separators, rather than exponential in
the cluster size. It is also similar to the dead caches concept presented in [12,32]. Intuitively, a node that has only one
incoming arc will only be traversed once by search, and therefore its value does not need to be cached, because it will
never be used again. For context based caching, such nodes can be recognized based only on the parents (or parent
separators) sets.

Deﬁnition 83 (dead cache). If X is the parent of Y in T , and paX

⊂ paY , then paY is a dead cache.

Given a pseudo tree T , the induced graph along T can generate a tree decomposition based on the maximal cliques.

The maximum separator size of the tree decomposition is the separator size of T .

Proposition 84. The space complexity of graph-caching algorithms can be reduced to being exponential in the sepa-
rator’s size only, while still being time exponential in the treewidth, if dead caches are not recorded.

7. AND/OR search spaces and other schemes

7.1. Relationship with Variable Elimination

A comparison between Variable Elimination and memory intensive AND/OR search appears in [44]. That paper
shows that Variable Elimination can be understood as bottom up layer by layer traversal of the context minimal
AND/OR search graph. If the graphical model is strictly positive (has no determinism), then context based AND/OR
search and Variable Elimination are essentially identical. When determinism is present, they may differ, because
they traverse the AND/OR graph in different directions and encounter determinism (and can take advantage of it)
differently. Therefore, for graphical models with no determinism, there is no principled difference between memory-
intensive AND/OR search with ﬁxed variable ordering and inference beyond: (1) different direction of exploring a
common search space (top down for search vs. bottom up for inference); (2) different assumption of control strategy
(depth-ﬁrst for search and breadth-ﬁrst for inference).

Another interesting observation is that many known advanced algorithms for constraint processing and satisﬁability
can be explained as traversing the AND/OR search tree, e.g. graph based backjumping [3,8,37]. For more details we
refer the reader to [44].

7.2. Relationship with BTD (backtracking with tree-decomposition)

BTD [10] is a memory intensive method for solving constraint satisfaction problems, which combines search
techniques with the notion of tree decomposition. This mixed approach can in fact be viewed as searching an AND/OR
graph, whose backbone pseudo tree is deﬁned by and structured along the tree decomposition. What is deﬁned in [10]
as structural goods, that is parts of the search space that would not be visited again as soon as their consistency is
known, corresponds precisely to the decomposition of the AND/OR space at the level of AND nodes, which root
independent subproblems. Not surprisingly, the time and space guarantees of BTD are the same as those of AND/OR
graph search. An optimization version of the algorithm is presented in [11].

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

99

Fig. 16. Dtrees and AND/OR pseudo-trees.

7.3. Relationship with Recursive Conditioning

Recursive Conditioning (RC) [12] is based on the divide and conquer paradigm. Rather than instantiating variables
to obtain a tree structured network like the cycle cutset scheme, RC instantiates variables with the purpose of breaking
the network into independent subproblems, on which it can recurse using the same technique. The computation is
driven by a data-structure called dtree, which is a full binary tree, the leaves of which correspond to the network
CPTs.

It can be shown that RC explores an AND/OR space. Let’s start with the example in Fig. 16, which shows:
(a) a belief network; (b) and (c), two dtrees and the corresponding pseudo-trees for the AND/OR search. The dtrees
also show the variables that are instantiated at some of the internal nodes. The pseudo-trees can be generated from
the static ordering of RC dictated by the dtree. This ensures that whenever RC splits the problem into independent
subproblems, the same happens in the AND/OR space. It can also be shown that the context of the nodes in RC, as
deﬁned in [12] is identical to that in AND/OR.

7.4. Relationship with Value Elimination

Value Elimination [13] is a recently developed algorithm for Bayesian inference. It was already explained in [13]
that, under static variable ordering, there is a strong relation between Value Elimination and Variable Elimination.
From our paragraph on the relation between AND/OR search and Variable Elimination we can derive the connection
between Value Elimination and AND/OR search, under static orderings. But we can also analyze the connection
directly. Given a static ordering d for Value Elimination, we can show that it actually traverses an AND/OR space.
The pseudo-tree underlying the AND/OR search graph traversal by Value Elimination can be constructed as the bucket
tree in reversed d. However, the traversal of the AND/OR space will be controlled by d, advancing the frontier in a
hybrid depth or breadth-ﬁrst manner.

The most important part to analyze is the management of goods. When Value Elimination computes a factor at a
leaf node, it backs up the value to the deepest node in the dependency set Dset. The Dset is identical to the context
in the AND/OR space. For clarity reasons, we chose to have the AND/OR algorithm back up the value to its parent in
the pseudo-tree, which may be different than the deepest variable in the context. We can however accommodate the
propagation of the value like in Value Elimination, and maintain bookkeeping of the summation set Sset, and this
would amount to a constant factor saving. Value Elimination continues by unionizing Dsets and Ssets whenever
values are propagated, and this is identical to computing the context of the corresponding node in the AND/OR space
(which is in fact the induced ancestor set of graph-based backjumping [45]).

In the presence of determinism, any backjumping strategy and nogood learning used by Value Elimination can also
be performed in the AND/OR space. Context speciﬁc structure that can be used by Value Elimination, can also be
used in AND/OR. Dynamic variable orderings can also be used in AND/OR spaces, but in this paper we limit the
discussion to static orderings.

100

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

7.5. Relationship with case-factor diagrams

Case-Factor Diagrams (CFD) were introduced in [20] and represent a probabilistic formalism subsuming Markov
random ﬁelds of bounded treewidth and probabilistic context free grammars. Case-factor diagrams are based on a
variant of BDDs (binary decision diagram [17]) with both zero suppression and “factor nodes”. Factor nodes are
analogous to the AND nodes in an AND/OR search space. A case-factor diagram can be viewed as an AND/OR
search space in which each outgoing arc from an OR node is explicitly labeled with an assignment of a value to a
variable. Zero suppression is used to ﬁx the value of variables not mentioned in a given solution. Zero suppression
allows the formalism to concisely represent probabilistic context free grammars as functions from variable-value
assignments to log probabilities (or energies).

7.6. AND/OR-search graphs and compilation

The authors have proposed in [42] the compilation of constraint networks into AND/OR Multi-Valued Decision
Diagrams (AOMDDs). This is essentially the strongly minimal AND/OR graph representation of a constraint network
with redundant variables removed for conciseness. An algorithm that achieves this is structurally similar to Variable
Elimination. It uses a bottom up traversal of a bucket tree, and at each node an APPLY operator is used to combine
all the AOMDDs of the bucket into another AOMDD. The APPLY is similar to the OBDD apply operator [17], but
is adapted for AND/OR structures. Essentially, the AOMDD extends an OBDD (or a multi-valued decision diagram)
with an AND/OR structure.

7.6.1. Relationship with d-DNNF

An AND/OR structure restricted to propositional theories is very similar to d-DNNF [18]. One can show a one-to-
one linear translation from an AND/OR bi-valued tree of a propositional CNF theory into a d-DNNF. The AND/OR
structure is more restrictive allowing disjunction only on the variable’s value while in d-DNNF disjunction is allowed
on more complex expressions; see [46] for implications of this distinction. The AND/OR search graph is built on top
of a graphical model and can be viewed as a compiled scheme of a CNF into an AND/OR structure. Since an AND/OR
search can be expressed as a d-DNNF, the construction via pseudo tree yields a scheme for d-DNNF compilation. In
other words, given a CNF theory, the algorithm can be applied using a pseudo tree to yield an AND/OR graph, which
can be transformed in linear time and space into a d-DNNF.

Conversely, given a d-DNNF that is specialized to variable-based disjunction for OR nodes, it is easy to create
an AND/OR graph or a tree that is equivalent having a polynomially equivalent size. The AND/OR search graph for
probabilistic networks is also closely related to algebraic circuits of probabilistic networks [19] which is an extension
of d-DNNF to this domain.

7.6.2. Relationship with OBDDs

The notion of minimal OR search graphs is also similar to the known concept of Ordered Binary Decision Diagrams
(OBDD) in the literature of hardware and software design and veriﬁcation The properties of OBDDs were studied
extensively in the past two decades [17,47].

It is well known that the size of the minimal OBDD is bounded exponentially by the pathwidth of the CNF’s primal
graph and that the OBDD is unique for a ﬁxed variable ordering. Our notion of backtrack-free minimal AND/OR
search graphs, if applied to CNFs, resembles tree BDDs [48]. Minimal AND/OR graphs are also related to Graph-
driven BDDs (called G-FBDD) [49,50] in that they are based on a partial order expressed in a directed graph. Still,
a G-FBDD has an OR structure, whose ordering is restricted to some partial orders, but not an AND/OR structure.
For example, the OBDD based on a DFS ordering of a pseudo tree is a G-FBDD. Some other relationships between
graphical model compilation and OBDDs were studied in [18].

In summary, putting OBDDs within our terminology, an OBDD representation of a CNF formula is a strongly

minimal OR search graph where redundant nodes are removed.

7.6.3. Relationship with tree-driven automata

Fargier and Vilarem [21] proposed the compilation of CSPs into tree-driven automata, which have many similarities
to the work in [42]. In particular, the compiled tree-automata proposed there is essentially the same as the AND/OR

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

101

multi-valued decision diagram. Their main focus is the transition from linear automata to tree automata (similar to
that from OR to AND/OR), and the possible savings for tree-structured networks and hyper-trees of constraints due
to decomposition. Their compilation approach is guided by a tree-decomposition while ours is guided by a variable-
elimination based algorithms. And, it is well known that Variable Elimination and cluster-tree decomposition are, in
principle, the same [24].

7.7. Relationship with disjoint support decomposition

The work on Disjoint Support Decompositions (DSD) [22] was proposed in the area of design automation [51],
as an enhancement for BDDs aimed at exploiting function decomposition. The main common aspect of DSD and
AOMDD [42] is that both approaches show how structure decomposition can be exploited in a BDD-like represen-
tation. DSD is focused on Boolean functions and can exploit more reﬁned structural information that is inherent to
Boolean functions. In contrast, AOMDDs assume only the structure conveyed in the constraint graph, and are therefore
more broadly applicable to any constraint expression and also to graphical models in general. They allow a simpler
and higher level exposition that yields graph-based bounds on the overall size of the generated AOMDD.

7.7.1. Relationship with semi-ring BDDs

In recent work [23] OBDDs were extended to semi-ring BDDs. The semi-ring treatment is restricted to the OR
search spaces, but allows dynamic variable ordering. It is otherwise very similar in aim and scope to our strongly
minimal AND/OR graphs. When restricting the strongly minimal AND/OR graphs to OR graphs only, the two are
closely related, except that we express BDDs using the Shenoy–Shafer axiomatization that is centered on the two
operation of combination and marginalization rather then on the semi-ring formulation. Minimality in the formulation
in [23] is more general allowing merging nodes having different values and therefore can capture symmetries (called
interchangeability).

8. Conclusions

The primary contribution of this paper is in viewing search for graphical models in the context of AND/OR search
spaces rather than OR spaces. We introduced the AND/OR search tree, and showed that its size can be bounded
exponentially by the depth of its pseudo tree over the graphical model. This implies exponential savings for any linear
space algorithms traversing the AND/OR search tree. Speciﬁcally, if the graphical model has treewidth w∗, the depth
of the pseudo tree is O(w∗ · log n).

The AND/OR search tree was extended into a graph by merging identical subtrees. We showed that the size of
the minimal AND/OR search graph is exponential in the treewidth while the size of the minimal OR search graph
is exponential in the pathwidth. Since for some graphs the difference between treewidth and pathwidth is substantial
(e.g., balanced pseudo trees) the AND/OR representation implies substantial time and space savings for memory in-
tensive algorithms traversing the AND/OR graph. Searching the AND/OR search graph can be implemented by goods
caching during search, while no-good recording is interpreted as pruning portions of the search space independent of
it being a tree or a graph, an OR or an AND/OR. For ﬁnding a single solution, pruning the search space is the most
signiﬁcant action. For counting and probabilistic inference, using AND/OR graphs can be of much help even on top
of no-good recording.

We observe that many known advanced algorithms for constraint processing and satisﬁability can be explained
as traversing the AND/OR search tree (e.g., backjumping [3,8,37]). Also, recent algorithms in probabilistic reason-
ing such as Recursive Conditioning [12] and Value Elimination [13] can operate in linear space and can be viewed
as searching the AND/OR search tree. In their memory intensive mode, these algorithms were noted to search the
AND/OR graph, having similar time and space complexities. Also, as noted, recent work [10] proposes search guided
by a tree decomposition either for constraint satisfaction or optimization, and is searching the AND/OR search graph,
whose pseudo tree is constructed along the tree decomposition.

102

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

Acknowledgements

This work was supported in part by the NSF grant IIS-0412854 and by the MURI ONR award N00014-00-1-0617.

Appendix A. Proofs

Proof of Theorem 29 (correctness). 1) By deﬁnition, all the arcs of ST (R) are consistent. Therefore, any solution
tree of ST (R) denotes a solution for R whose assignments are all the labels of the AND nodes in the solution tree.
Also, by deﬁnition of the AND/OR tree, every solution of R must corresponds to a solution subtree in ST (R). 2) By
construction, the arcs in every solution tree have weights such that each function of F contributes to one and only one
weight via the combination operator. Since the total weight of the tree is derived by combination, it yields the cost of
a solution.

Proof of Theorem 30 (size bounds of AND/OR search tree). Let p be an arbitrary directed path in the DFS tree T
that starts with the root and ends with a leaf. This path induces an OR search subtree which is included in the AND/OR
search tree ST , and its size is O(km), when m bounds the path length. The DFS tree T is covered by l such directed
paths, whose lengths are bounded by m. The union of their individual search trees covers the whole AND/OR search
tree ST , where every distinct full path in the AND/OR tree appears exactly once, and therefore, the size of the
AND/OR search tree is bounded by O(l · km). Since l (cid:2) n and l (cid:2) bm, it concludes the proof.

Proof of Proposition 31. The proof is similar to that of Theorem 30, only each node contributes with its actual
domain size rather than the maximal one, and each path to a leaf in T contributes with its actual depth, rather than the
maximal one.

Proof of Theorem 34 (properties of AND/OR search trees). All the arguments in the proof of Theorem 29 carry
immediately to AND/OR search spaces that are deﬁned relative to a pseudo tree. Likewise, the bound size argument
in the proof of Theorem 30 holds relative to the depth of the more general pseudo tree.

Proof of Proposition 42. First, we should note that if T is a pseudo tree of R and if d is a DFS ordering of T ,
then T is also a pseudo tree of Ed (R) and therefore ST (Ed (R)) is a faithful representation of Ed (R). Ed (R) is
equivalent to R, therefore ST (Ed (R)) is a supergraph of BFT (R). We only need to show that ST (Ed (R)) does
not contain any dead-ends, in other words any consistent partial assignment must be extendable to a solution of R.
Adaptive consistency makes Ed (R) strongly directional w∗(d) consistent, where w∗(d) is the induced width of R
along ordering d [35]. It follows from this that either R is inconsistent, in which case the proposition is trivially
satisﬁed, both trees being empty, or else any consistent partial assignment in ST (Ed (R)) can be extended to the next
variable in d, and therefore no dead-end is encountered.

Proof of Proposition 48 (minimal graph). (1) All we need to show is that the merge operator is not dependent on
the order of applying the operator. Mergeable nodes can only appear at the same level in the AND/OR graph. Looking
at the initial AND/OR graph, before the merge operator is applied, we can identify all the mergeable nodes per level.
We prove the proposition by showing that if two nodes are initially mergeable, then they must end up merged after the
operator is applied exhaustively to the graph. This can be shown by induction over the level where the nodes appear.
Base case: If the two nodes appear at the leaf level (level 0), then it is obvious that the exhaustive merge has to

merge them at some point.

Inductive step: Suppose our claim is true for nodes up to level k and two nodes n1 and n2 at level k + 1 are
initially identiﬁed as mergeable. This implies that, initially, their corresponding children are identiﬁed as mergeable.
These children are at level k, so it follows from the inductive hypothesis that the exhaustive merge has to merge the
corresponding children. This in fact implies that nodes n1 and n2 will root the same subgraph when the exhaustive
merge ends, so they have to end up merged. Since the graph only becomes smaller by merging, based on the above
the process of merging has to stop at a ﬁx point.

(2) Analogous to (1). (3) If the nodes can be merged, it follows that the subgraphs are identical, which implies that

they deﬁne the same conditioned subproblems, and therefore the nodes can also be uniﬁed.

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

103

Proof of Proposition 52. Parts 1 and 2 follow from deﬁnitions. Regarding claim 3, for the graph coloring problem in
Fig. 1(a), the minimal AND-OR search graph is identical to its explicit AND/OR search graph, GT (see Fig. 11).

Proof of Proposition 53. In tree models, the functions are only over two variables. Therefore, after an assignment
(cid:3)X, x(cid:4) is made and the appropriate weight is given to the arc from X to (cid:3)X, x(cid:4), the variable X and all its ancestors in
the pseudo tree do not contribute to any arc weight below in the AND/OR search tree. Therefore, the conditioned
subproblems rooted at any AND node labeled by (cid:3)X, x(cid:4) depend only on the assignment of X to x (and do not
depend on any other assignment on the current path), so it follows that all the AND nodes labeled by (cid:3)X, x(cid:4) can be
merged. Since the equivalence of AND/OR search spaces is preserved by merge, the explicit AND/OR search graph
is equivalent to ST . At each AND level in the explicit graph there are at most k values, and therefore its size is O(nk).

Proof of Theorem 54. The size of an explicit AND/OR graph of a tree model was shown to be O(nk) (Proposi-
tion 52), yielding O(r · kw∗
) size for the explicit AND/OR graph, because k is replaced by kw∗
, the number of possible
assignments to a cluster of scope size w∗, and r replaces n.

Proof of Proposition 56. (1) The induced width of G relative to a given pseudo tree is always greater than w∗, by
deﬁnition of w∗. It remains to show that there exists a pseudo tree T such that wT (G) = w∗. Consider an ordering
d that gives the induced width w∗. The ordering d deﬁnes a bucket tree BT (see Deﬁnition 36), which can also be
viewed as a pseudo tree for the AND/OR search, therefore wBT (G) = w∗. (2) Analogous to (1).

Proof of Proposition 60. Both claims follow directly from Deﬁnitions 58 and 59.

Proof of Theorem 61 (context based merge). (1) The conditioned graphical models (Deﬁnition 10) at n1 and n2
are deﬁned by the functions whose scopes are not fully assigned by πn1 and πn2 . Since n1 and n2 have the same
labeling (cid:3)Xi, xi(cid:4), it follows that var(πn1 ) = var(πn2 ), and therefore the two conditioned subproblems are based on
the same set of functions, let’s call it F |var(πn1 ). The scopes of functions in F |var(πn1 ) determine connections in the
primal graph between ancestors of Xi and its descendants. Therefore, the only relevant variables that deﬁne the
restricted subproblems are those in pasi , and Eq. (1) ensures that they have identical assignments. It follows that the
conditioned subproblems are identical, and n1 and n2 can be merged.

(2) Analogous to (1).

Proof of Theorem 65. The number of different nodes in the context minimal AND/OR search graph, CT , does not
exceed the number of contexts. From Eqs. (1) and (2) we see that, for any variable, the number of contexts is bounded
by the number of possible instantiations of the largest context in GT ∗
, which is bounded by O(kw). For all the n
variables, the bound O(n · kw) follows.

Proof of Theorem 67. We can generate CT using depth-ﬁrst or breadth-ﬁrst search which caches all nodes via their
contexts and avoids generating duplicate searches for the same contexts. Therefore, the generation of the search graph
is linear in its size, which is exponential in w and linear in n.

Proof of Proposition 73. Let B1 = BFT (R1) and B2 = BFT (R2) be the corresponding backtrack-free AND/OR
search trees of R1 and R2, respectively. Namely, BFT (R1) ⊆ ST (R1), BFT (R2) ⊆ ST (R2). Clearly they are sub-
trees of the same full AND/OR tree. We claim that a path appears in B1 iff it appears in B2. If not, assume without
loss of generality that there exists a path in B1, π , which does not exists in B2. Since this is a backtrack-free search
tree, every path appears in some solution and therefore there is a solution subtree in B1 that includes π which does
not exist in B2, contradicting the assumption that R1 and R2 have the same set of solutions. The second part has an
identical proof based on ﬂat functions (see introduction to Section 3).

Proof of Theorem 74. From Proposition 73 we know that R1 and R2 have the same backtrack-free AND/OR
tree. Since the backtrack-free AND/OR search tree for a backbone tree T uniquely determines the strongly mini-
mal AND/OR graph, the theorem follows.

104

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

Proof of Proposition 78 (recursive value computation). The proof is by induction over the number of levels in the
AND/OR graph.

Basis step: If the graph has only two levels, one OR and one AND, then the claim is straightforward because the
AND leaves are labeled by “1” if consistent and the OR node accumulates “1” or the sum of consistent values below,
or “0” if there is no consistent value.

Inductive step: Assuming the proposition holds for k pairs of levels (one AND and one OR in each pair), proving
it holds for k + 1 pairs of levels is similar to the basis step, only the labeling of the top AND nodes is the sum of
solutions below in the case of counting.

Proof of Proposition 80. The proof is again by induction, similar to the proof of Proposition 78. For simplicity of
writing, the projection operator here takes as arguments the set of variables that are eliminated.

Basis step: If the model has only one variable, then the claim is obvious.
Inductive step: Let X be an OR node in the graph. Assume that the value of each OR node below it is the solution
to the reasoning problem corresponding to the conditioned subproblem rooted by it. We need to prove that the value of
X will be the solution to the reasoning problem of the conditioned subproblem rooted by X. Suppose X has children
Y1, . . . , Ym in the pseudo tree. We have v(Yi) = ⇓Yi ∪Desc(Yi )
f , where Desc(Yi) are the descendants of Yi ,
and the functions are restricted on the current path. Each AND node (cid:3)X, x(cid:4) will combine the values below. Because
the sets Yi ∪ Desc(Yi) are pairwise disjoint, the marginalization operator commutes with the combination operator
and we get:

f ∈F |πYi

(cid:4)

(cid:12)
(cid:11)
(cid:3)X, x(cid:4)

v

=

m(cid:7)

i=1

⇓Yi ∪Desc(Yi )

(cid:7)

f ∈F |πYi

f = ⇓(cid:3)

m
i=1(Yi ∪Desc(Yi ))

(cid:7)

f.

f ∈F |πx

The values v((cid:3)X, x(cid:4)) are then combined with the values of the bucket of X, which are the weights w(X,(cid:3)X,x(cid:4)). The func-
tions that appear in the bucket of X do not contribute to any of the weights below Yi , and therefore the marginalization
over

m
i=1(Yi ∪ Desc(Yi)) can commute with the combination that we have just described:

(cid:3)

w(X,(cid:3)X,x(cid:4)) ⊗ v

(cid:12)
(cid:11)
(cid:3)X, x(cid:4)

= ⇓(cid:3)
m

i=1(Yi ∪Desc(Yi )) w(X,(cid:3)X,x(cid:4)) ⊗

(cid:15) (cid:7)

(cid:16)

f

.

f ∈F |πx

Finally, we get:

v(X) = ⇓X w(X,(cid:3)X,x(cid:4)) ⊗ v

(cid:12)
(cid:11)
(cid:3)X, x(cid:4)

= ⇓X∪Desc(X)

(cid:7)

f.

f ∈F |πX

Proof of Proposition 84. A bucket tree can be built by having a cluster for each variable Xi and its parents pai , and
following the structure of the pseudo tree T . Some of the clusters may not be maximal, and they have a one to one
correspondence to the variables with dead caches. The parents pai that are not dead caches correspond to separators
between maximal clusters in the bucket tree.

References

[1] N.J. Nilsson, Principles of Artiﬁcial Intelligence, Tioga, Palo Alto, CA, 1980.
[2] E.C. Freuder, M.J. Quinn, Taking advantage of stable sets of variables in constraint satisfaction problems, in: Proceedings of the Ninth

International Joint Conference on Artiﬁcial Intelligence (IJCAI’85), 1985, pp. 1076–1078.

[3] E.C. Freuder, M.J. Quinn, The use of lineal spanning trees to represent constraint satisfaction problems, Tech. Rep. 87-41, University of New

Hampshire, Durham (1987).

[4] Z. Collin, R. Dechter, S. Katz, On the feasibility of distributed constraint satisfaction, in: Proceedings of the Twelfth International Conference

of Artiﬁcial Intelligence (IJCAI’91), 1991, pp. 318–324.

[5] Z. Collin, R. Dechter, S. Katz, Self-stabilizing distributed constraint satisfaction, The Chicago Journal of Theoretical Computer Science 3 (4)

(1999), special issue on self-stabilization.

[6] P.J. Modi, W. Shena, M. Tambea, M. Yokoo, Adopt: asynchronous distributed constraint optimization with quality guarantees, Artiﬁcial

Intelligence 161 (2005) 149–180.

[7] R. Dechter, Constraint networks, in: Encyclopedia of Artiﬁcial Intelligence, 1992, pp. 276–285.

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

105

[8] R. Bayardo, D. Miranker, A complexity analysis of space-bound learning algorithms for the constraint satisfaction problem, in: Proceedings

of the Thirteenth National Conference on Artiﬁcial Intelligence (AAAI’96), 1996, pp. 298–304.

[9] J. Larrosa, P. Meseguer, M. Sanchez, Pseudo-tree search with soft constraints, in: Proceedings of the European Conference on Artiﬁcial

Intelligence (ECAI’02), 2002, pp. 131–135.

[10] C. Terrioux, P. Jégou, Hybrid backtracking bounded by tree-decomposition of constraint networks, Artiﬁcial Intelligence 146 (2003) 43–75.
[11] C. Terrioux, P. Jégou, Bounded backtracking for the valued constraint satisfaction problems, in: Proceedings of the Ninth International Con-

ference on Principles and Practice of Constraint Programming (CP’03), 2003, pp. 709–723.

[12] A. Darwiche, Recursive conditioning, Artiﬁcial Intelligence 125 (1–2) (2001) 5–41.
[13] F. Bacchus, S. Dalmao, T. Pitassi, Value elimination: Bayesian inference via backtracking search, in: Proceedings of the Nineteenth Conference

on Uncertainty in Artiﬁcial Intelligence (UAI’03), 2003, pp. 20–28.

[14] F. Bacchus, S. Dalmao, T. Pitassi, Algorithms and complexity results for #sat and bayesian inference, in: Proceedings of the 44th Annual IEEE

Symposium on Foundations of Computer Science (FOCS’03), 2003, pp. 340–351.

[15] T. Sang, F. Bacchus, P. Beam, H. Kautz, T. Pitassi, Combining component caching and clause learning for effective model counting, in:

Proceedings of the Seventh International Conference on Theory and Applications of Satisﬁability Testing (SAT’04), 2004.

[16] R. Dechter, Bucket elimination: A unifying framework for reasoning, Artiﬁcial Intelligence 113 (1999) 41–85.
[17] R.E. Bryant, Graph-based algorithms for boolean function manipulation, IEEE Transaction on Computers 35 (1986) 677–691.
[18] A. Darwiche, P. Marquis, A knowledge compilation map, Journal of Artiﬁcial Intelligence Research (JAIR) 17 (2002) 229–264.
[19] A. Darwiche, A differential approach to inference in Bayesian networks, Journal of the ACM 50 (3) (2003) 280–305.
[20] D. McAllester, M. Collins, F. Pereira, Case-factor diagrams for structured probabilistic modeling, in: Proceedings of the Twentieth Conference

on Uncertainty in Artiﬁcial Intelligence (UAI’04), 2004, pp. 382–391.

[21] H. Fargier, M. Vilarem, Compiling csps into tree-driven automata for interactive solving, Constraints 9 (4) (2004) 263–287.
[22] V. Bertacco, M. Damiani, The disjunctive decomposition of logic functions, in: ICCAD, International Conference on Computer-Aided Design,

1997, pp. 78–82.

[23] N. Wilson, Decision diagrams for the computation of semiring valuations, in: Proceedings of the Nineteenth International Joint Conference

on Artiﬁcial Intelligence (IJCAI’05), 2005, pp. 331–336.

[24] R. Dechter, J. Pearl, Tree clustering for constraint networks, Artiﬁcial Intelligence 38 (1989) 353–366.
[25] S.A. Arnborg, Efﬁcient algorithms for combinatorial problems on graphs with bounded decomposability—a survey, BIT 25 (1985) 2–23.
[26] H.L. Bodlaender, J.R. Gilbert, Approximating treewidth, pathwidth and minimum elimination tree-height, Tech. rep., Utrecht University

(1991).

[27] H.L. Bodlaender, Treewidth: Algorithmic techniques and results, in: The Twenty Second International Symposium on Mathematical Founda-

tions of Computer Science (MFCS’97), 1997, pp. 19–36.

[28] R. Dechter, A new perspective on algorithms for optimizing policies under uncertainty, in: International Conference on Artiﬁcial Intelligence

Planning Systems (AIPS-2000), 2000, pp. 72–81.

[29] P. Shenoy, Valuation-based systems for bayesian decision analysis, Operations Research 40 (1992) 463–484.
[30] J. Pearl, Probabilistic Reasoning in Intelligent Systems, Morgan Kaufmann, 1988.
[31] R. Marinescu, R. Dechter, AND/OR branch-and-bound for graphical models, in: Proceedings of the Nineteenth International Joint Conference

on Artiﬁcial Intelligence (IJCAI’05), 2005, pp. 224–229.

[32] D. Allen, A. Darwiche, New advances in inference by recursive conditioning, in: Proceedings of the Nineteenth Conference on Uncertainty in

Artiﬁcial Intelligence (UAI’03), 2003, pp. 2–10.

[33] K. Kask, R. Dechter, J. Larrosa, A. Dechter, Unifying cluster-tree decompositions for reasoning in graphical models, Artiﬁcial Intelli-

gence 166 (1–2) (2005) 165–193.

[34] R. Dechter, Constraint Processing, Morgan Kaufmann, 2003.
[35] R. Dechter, J. Pearl, Network-based heuristics for constraint satisfaction problems, Artiﬁcial Intelligence 34 (1987) 1–38.
[36] I. Rish, R. Dechter, Resolution vs. search; two strategies for sat, Journal of Automated Reasoning 24 (1/2) (2000) 225–275.
[37] R. Dechter, Enhancement schemes for constraint processing: Backjumping, learning and cutset decomposition, Artiﬁcial Intelligence 41

(1990) 273–312.

[38] R.J. Bayardo, R.C. Schrag, Using csp look-back techniques to solve real world sat instances, in: Proceedings of the Fourteenth National

Conference on Artiﬁcial Intelligence (AAAI’97), 1997, pp. 203–208.

[39] J.P. Marques-Silva, K.A. Sakalla, Grasp: A search algorithm for propositional satisﬁability, IEEE Transaction on Computers 48 (5) (1999)

506–521.

[40] N. Robertson, P. Seymour, Graph minors i. excluding a forest, J. Combin. Theory Ser. B 35 (1983) 39–61.
[41] D. Bienstock, N. Robertson, P. Seymour, R. Thomas, Quickly excluding a forest, J. Combin. Theory Ser. B 52 (1991) 274–283.
[42] R. Mateescu, R. Dechter, Compiling constraint networks into AND/OR multi-valued decision diagrams (AOMDDs), in: Proceedings of the

Twelfth International Conference on Principles and Practice of Constraint Programming (CP’06), 2006, pp. 329–343.

[43] D.H. Frost, Algorithms and heuristics for constraint satisfaction problems, Tech. rep., Ph.D. thesis, Information and Computer Science,

University of California, Irvine (1997).

[44] R. Mateescu, R. Dechter, The relationship between AND/OR search and variable elimination, in: Proceedings of the Twenty First Conference

on Uncertainty in Artiﬁcial Intelligence (UAI’05), 2005, pp. 380–387.

[45] R. Dechter, D. Frost, Backjump-based backtracking for constraint satisfaction problems, Artiﬁcial Intelligence 136 (2) (2002) 147–188.
[46] J. Huang, A. Darwiche, Dpll with a trace: From sat to knowledge compilation, in: Proceedings of the Nineteenth International Joint Conference

on Artiﬁcial Intelligence (IJCAI’05), 2005, pp. 156–162.

[47] K.L. McMillan, Symbolic Model Checking, Kluwer Academic, 1993.

106

R. Dechter, R. Mateescu / Artiﬁcial Intelligence 171 (2007) 73–106

[48] K.L. McMillan, Hierarchical representation of discrete functions with application to model checking, in: Computer Aided Veriﬁcation, 1994,

pp. 41–54.

[49] J. Gergov, C. Meinel, Efﬁcient boolean manipulation with obdds can be extended to fbdds, IEEE Trans. Computers 43 (1994) 1197–1209.
[50] D. Sieling, I. Wegner, Graph driven BDDs—a new data structure for boolean functions, Theoretical Computer Science 141 (1994) 283–310.
[51] R. Brayton, C. McMullen, The decomposition and factorization of boolean expressions, in: ISCAS, Proceedings of the International Sympo-

sium on Circuits and Systems, 1982, pp. 49–54.

