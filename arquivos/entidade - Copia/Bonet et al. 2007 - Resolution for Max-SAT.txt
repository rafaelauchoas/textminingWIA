Artiﬁcial Intelligence 171 (2007) 606–618

www.elsevier.com/locate/artint

Resolution for Max-SAT ✩

María Luisa Bonet a, Jordi Levy b,∗, Felip Manyà b

a Dept. Llenguatges i Sistemes Informàtics (LSI), Universitat Politècnica de Catalunya (UPC),
Jordi Girona, 1-3, 08034 Barcelona, Spain
b Artiﬁcial Intelligence Research Institute (IIIA), Spanish Scientiﬁc Research Council (CSIC),
Campus UAB, 08193 Bellaterra, Spain

Received 1 September 2006; received in revised form 26 February 2007; accepted 1 March 2007

Available online 12 March 2007

Abstract

Max-SAT is the problem of ﬁnding an assignment minimizing the number of unsatisﬁed clauses in a CNF formula. We propose
a resolution-like calculus for Max-SAT and prove its soundness and completeness. We also prove the completeness of some
reﬁnements of this calculus. From the completeness proof we derive an exact algorithm for Max-SAT and a time upper bound.

We also deﬁne a weighted Max-SAT resolution-like rule, and show how to adapt the soundness and completeness proofs of the

Max-SAT rule to the weighted Max-SAT rule.

Finally, we give several particular Max-SAT problems that require an exponential number of steps of our Max-SAT rule to obtain
the minimal number of unsatisﬁed clauses of the combinatorial principle. These results are based on the corresponding resolution
lower bounds for those particular problems.
© 2007 Elsevier B.V. All rights reserved.

Keywords: Satisﬁability; Resolution; Completeness; Saturation; Max-SAT; Weighted Max-SAT

1. Introduction

The Max-SAT problem for a CNF formula φ is the problem of ﬁnding an assignment of values to variables that
minimizes the number of unsatisﬁed clauses in φ. Max-SAT is an optimization version of SAT which is NP-hard (see
[25]).

Competitive exact Max-SAT solvers—as the ones developed by [2–4,17,22,23,30,32–34]—implement variants of
the following branch and bound (BnB) schema: Given a CNF formula φ, BnB explores the search tree that represents
the space of all possible assignments for φ in a depth-ﬁrst manner. At every node, BnB compares the upper bound
(UB), which is the best solution found so far for a complete assignment, with the lower bound (LB), which is the
sum of the number of clauses unsatisﬁed by the current partial assignment plus an underestimation of the number of

✩ This research has been partially founded by the CICYT research projects iDEAS (TIN2004-04343) and Mulog (TIN2004-07933-C03-01/03).
The ﬁrst author also wants to thank the Isaac Newton Institute for Mathematical Sciences for hosting her while some of the ideas of this paper
where thought and presented.
* Corresponding author.

E-mail addresses: bonet@lsi.upc.edu (M.L. Bonet), levy@iiia.csic.es (J. Levy), felip@iiia.csic.es (F. Manyà).
URLs: http://www.lsi.upc.edu/~bonet (M.L. Bonet), http://www.iiia.csic.es/~levy (J. Levy).

0004-3702/$ – see front matter © 2007 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2007.03.001

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

607

clauses that will become unsatisﬁed if the current partial assignment is completed. If LB (cid:2) UB the algorithm prunes
the subtree below the current node and backtracks to a higher level in the search tree. If LB < UB, the algorithm tries
to ﬁnd a better solution by extending the current partial assignment by instantiating one more variable. The solution
to Max-SAT is the value that UB takes after exploring the entire search tree.

The amount of inference performed by BnB at each node of the proof tree is poor compared with the inference
performed in DPLL-style SAT solvers. The inference rules that one can apply in Max-SAT have to transform the
current instance φ into another instance φ(cid:3) in such a way that φ and φ(cid:3) have the same number of unsatisﬁed clauses
for every possible assignment; in other words, the inference rules have to be sound. It is not enough to preserve
satisﬁability as in SAT. Unfortunately, unit propagation, which is the most powerful inference technique applied in
SAT, is unsound for Max-SAT,1 and many Max-SAT solvers apply rules which are far from being as powerful as unit
propagation in SAT.

A basic BnB algorithm, when branches on literal l, enforces the following inference: removes the clauses contain-
ing l and deletes the occurrences of ¯l, but the new unit clauses derived as a consequence of deleting the occurrences
of ¯l are not propagated as in unit propagation. Typically, that inference is enhanced by applying simple inference rules
such as (i) the pure literal rule [13]; (ii) the dominating unit clause rule [24], (iii) the almost common clause rule [8],
and (iv) the complementary unit clause rule [24]. All these rules, which are sound but not complete, have proved to
be useful in a number of solvers [2,4,13,30,33].

A recent trend, that we believe will remain in future Max-SAT solvers, is to design solvers that incorporate
resolution-like inference rules that can be applied efﬁciently at every node of the proof tree. This is the case of
MaxSatz,2 the best performing Max-SAT solver of the SAT-2006 Max-SAT Evaluation.3 For example, one of the
derived resolution rules that implements MaxSatz is the star rule:

x
y
¯x ∨ ¯y
(cid:3)
x ∨ y

x
0
0
1
1

y
0
1
0
1

¯x ∨ ¯y (cid:3) x ∨ y
0
0
0
0

1
1
1
0

0
1
1
1

where we have added the truth table of the rule to verify its soundness.

Max-SAT inference rules like the star rule replace the premises of the rule by its conclusion instead of adding the
conclusion to the premises, which might increase the number of clauses unsatisﬁed by some assignment. The star
rule preserves the number of unsatisﬁed clauses by replacing x, y, ¯x ∨ ¯y with (cid:3), x ∨ y, where (cid:3) is the empty clause.
Because these rules substitute a set of clauses by another, in some articles they are called transformation rules (see
[24]) instead of resolution rules. See also [20] for other examples of rules for Max-SAT.

The main objective of this paper is to make a step forward in the study of resolution inference rules for Max-SAT
by deﬁning a sound and complete resolution rule. We want a rule such that the existing inference rules for Max-SAT
either are particular cases of our rule (like the complementary unit clause rule or the almost common clause rule) or
are rules that can be derived from our rule (like the star rule). We also want our rule to provide a general framework for
extending our results to Weighted Max-SAT, deﬁning complete reﬁnements of resolution and devising faster Max-SAT
solvers.

Firstly, we observe that the classical resolution rule x ∨ A, ¯x ∨ B (cid:5) A ∨ B is not sound for Max-SAT, because an
assignment satisfying x and A, and falsifying B, would falsify one of the premises, but would satisfy the conclusion.
So the number of unsatisﬁed clauses would not be preserved for every truth assignment.

1 The set of clauses {a, ¯a ∨ b, ¯a ∨ ¯b, ¯a ∨ c, ¯a ∨ ¯c } has a minimum of one unsatisﬁed clause (setting a to false). However, performing unit
propagation with a leads to a non-optimal assignment falsifying at least two clauses.
2 URL: http://web.udl.es/usuaris/m4372594/software.html.
3 URL: http://www.iiia.csic.es/~maxsat06/.

608

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

Secondly, there is a natural extension to Max-SAT of the classical resolution rule in [21]:

x ∨ A
¯x ∨ B
A ∨ B
x ∨ A ∨ ¯B
¯x ∨ ¯A ∨ B

In [21], Larrosa and Heras present this rule and ask whether it is complete for Max-SAT. However, two of the
conclusions of this rule are not in clausal form, and the trivial application of distributivity results into an unsound
rule:

x ∨ a1 ∨ · · · ∨ as
¯x ∨ b1 ∨ · · · ∨ bt
a1 ∨ · · · ∨ as ∨ b1 ∨ · · · ∨ bt
x ∨ a1 ∨ · · · ∨ as ∨ ¯b1
· · ·
x ∨ a1 ∨ · · · ∨ as ∨ ¯bt
¯x ∨ b1 ∨ · · · ∨ bt ∨ ¯a1
· · ·
¯x ∨ b1 ∨ · · · ∨ bt ∨ ¯as

Therefore, our ﬁrst objective was to modify the previous rule to obtain a sound and complete resolution rule in
which the conclusions are in clausal form, as well as analyzing the complexity of applying the rule and ﬁnding
out if there is some complete reﬁnement. As we show in the next sections, we achieve our objective by providing
a sound and complete resolution rule for Max-SAT in which both premises and conclusions are in clausal form.
Moreover, we describe an exact algorithm for Max-SAT which is derived from the completeness proof. We also
obtain an upper bound of the complexity of applying our rule and prove the completeness of the ordered resolution
reﬁnement.

In classical resolution, different copies of a clause are eliminated leaving just one copy of each clause. In the
context of the Max-SAT optimization problem, clearly this is not sound and we must keep repeated copies of a clause.
This is why instead of working with sets of clauses we will work with multisets of clauses. A way to make the
representation of this multisets more compact is to substitute several copies of a clause by a weighted clause, where
the weight represents the number of times that the clause appears. So, our second objective was to extend our Max-
SAT resolution rule to weighted clauses. As a result, we obtain a sound and complete resolution rule for Weighted
Max-SAT.

Our third objective was to study the complexity of our calculus from the point of view of the number of steps it
might need to tell us the minimal number of unsatisﬁed clauses. Since the Max-SAT problem is hard for the optimiza-
tion problem corresponding to NP, we expect to ﬁnd classes of instances that require an exponential number of steps
to give the minimal number of unsatisﬁed clauses. As a result, we prove such lower bounds for various combinatorial
principles.

Finally, in this paper we use the term of Max-SAT meaning Min-SAT. This is because, with respect to exact
computations, ﬁnding an assignment that minimizes the number of unsatisﬁed clauses is equivalent to ﬁnding an
assignment that maximizes the number of satisﬁed clauses. This is not necessarily the case for approximability results
(see [18]).

This paper proceeds as follows. First, in Section 2 we deﬁne Max-SAT resolution and prove its soundness. Despite
of the similitude of the inference rule with the classical resolution rule, it is not clear how to simulate classical
inferences with the new rule. To obtain a complete strategy, we need to apply the new rule repeatedly to get a saturated
set of clauses, as described in Section 3. In Section 4 we prove the completeness of the new rule, and the extension to
ordered resolution. In Section 5 we deduce an exact algorithm and give a worst-case time upper bound in Section 6.
Section 7 contains a rule for weighted Max-SAT and the soundness and completeness of the rule. Section 8 has the
lower bound results for our Max-SAT rule. Finally, we present some concluding remarks.

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

609

2. The Max-SAT resolution rule and its soundness

In Max-SAT we need to keep repeated clauses. Therefore, we use multisets of clauses instead of just sets. For

instance, the multiset {a, ¯a, ¯a, a ∨ b, ¯b}, where a clause is repeated, has a minimum of two unsatisﬁed clauses.

Max-SAT resolution, like classical resolution, is based on a unique inference rule. In contrast to the resolution rule,
the premises of the Max-SAT resolution rule are removed from the multiset after applying the rule. Moreover, apart
from the classical conclusion where a variable has been cut, we also conclude some additional clauses that contain
one of the premises as subclause.

Deﬁnition 1. The Max-SAT resolution rule is deﬁned as follows:

x ∨ a1 ∨ · · · ∨ as
¯x ∨ b1 ∨ · · · ∨ bt
a1 ∨ · · · ∨ as ∨ b1 ∨ · · · ∨ bt
x ∨ a1 ∨ · · · ∨ as ∨ ¯b1
x ∨ a1 ∨ · · · ∨ as ∨ b1 ∨ ¯b2
· · ·
x ∨ a1 ∨ · · · ∨ as ∨ b1 ∨ · · · ∨ bt−1 ∨ ¯bt
¯x ∨ b1 ∨ · · · ∨ bt ∨ ¯a1
¯x ∨ b1 ∨ · · · ∨ bt ∨ a1 ∨ ¯a2
· · ·
¯x ∨ b1 ∨ · · · ∨ bt ∨ a1 ∨ · · · ∨ as−1 ∨ ¯as

This inference rule is applied to multisets of clauses, and replaces the premises of the rule by its conclusions.
We say that the rule cuts the variable x.
The tautologies concluded by the rule are removed from the resulting multiset. Similarly, repeated literals in a

clause are collapsed into one.

Deﬁnition 2. We write C (cid:5) D when the multiset of clauses D can be obtained from the multiset C applying the Max-
SAT resolution rule ﬁnitely many times. We write C (cid:5)x D when this sequence of applications only cuts the variable x.

The Max-SAT resolution rule may conclude more clauses than the classical resolution rule. Notice though that the
number of conclusions of the rule is at most the number of literals in the premises. However, when the two premises
share literals, some of the conclusions are tautologies, hence removed. In particular we have x ∨ A, ¯x ∨ A (cid:5) A.
Moreover, as we will see when we study the completeness of the rule, there is no need to cut the conclusions of a rule
among themselves. Finally, we will also see that the size of the worst-case proof of a set of clauses is similar to the
size for classical resolution.

Notice that an instance of the rule not only depends on the two clauses of the premise and the cut variable (like in
resolution), but also on the order of the literals. Notice also that, like in classical resolution, this rule concludes a new
clause not containing the variable x, except when this clause is a tautology.

Example 3. The Max-SAT resolution rule removes clauses after using them in an inference step. Therefore, it could
seem that it can not simulate classical resolution when a clause needs to be used more than once, like in the example
of Fig. 1 (left). However, this is not the case, as it can be seen in the same ﬁgure (right). More precisely, we derive

a,

¯a ∨ c,

¯a ∨ b,

¯a ∨ b ∨ c
where any truth assignment satisfying {a ∨ ¯b ∨ ¯c, ¯a ∨ b ∨ c} minimizes the number of falsiﬁed clauses in the original
formula.

¯b ∨ ¯c (cid:5) (cid:3),

a ∨ ¯b ∨ ¯c,

Notice that the structure of the classical resolution proof and the Max-SAT resolution proof is quite different. It
seems difﬁcult to adapt a classical resolution proof to get a Max-SAT resolution proof, and it is an open question if
this is possible without increasing substantially the size of the proof.

610

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

Fig. 1. An example of inference with classical resolution (left) and its equivalence with Max-SAT resolution (right). We put a box around the
already used clauses.

Theorem 4 (Soundness). The Max-SAT resolution rule is sound; i.e., the rule preserves the number of unsatisﬁed
clauses for every truth assignment.

Proof. For every assignment I , we will prove that the number of clauses that I falsiﬁes in the premises of the inference
rule is equal to the number of clauses that it falsiﬁes in the conclusions.

Let I be any assignment. I can not falsify both premises, since it satisﬁes either x or ¯x.
Suppose I satisﬁes x ∨ a1 ∨ · · · ∨ as but not ¯x ∨ b1 ∨ · · · ∨ bt . Then I falsiﬁes all bj ’s and sets x to true. Now,
suppose that I satisﬁes at least one literal among {a1 ∨ · · · ∨ as}. Say ai is the ﬁrst such literal. Then I falsiﬁes
¯x ∨ b1 ∨ · · · ∨ bt ∨ a1 ∨ · · · ∨ ai−1 ∨ ¯ai and it satisﬁes all the others in the set of conclusions. Suppose now that I
falsiﬁes all ai ’s. Then, it falsiﬁes a1 ∨ · · · as ∨ b1 ∨ · · · ∨ bt but satisﬁes all the other conclusions.

If I satisﬁes the second premise but not the ﬁrst, then by a similar argument we can show that I falsiﬁes only one

conclusion.

Finally, suppose that I satisﬁes both premises. Suppose that I sets x to true. Then, for some j , bj is true and I
satisﬁes all the conclusions since all of them have either bj or x. The argument works similarly for I falsifying x. (cid:2)

3. Saturated multisets of clauses

In this section we deﬁne saturated multisets of clauses. This deﬁnition is based on the classical notion of sets of
clauses closed by (some restricted kind of) inference, in particular, on sets of clauses closed by cuts of some variable.
In classical resolution, given a set of clauses and a variable, we can saturate the set by cutting the variable exhaustively,
obtaining a superset of the given clauses. If we repeat this process for all the variables, we get a complete resolution
algorithm, i.e. we obtain the empty clause whenever the original set was unsatisﬁable. Our completeness proof is based
on this idea. However, notice that the classical saturation of a set w.r.t. a variable is unique, whereas in Max-SAT, it is
not (see Remark 8). In fact, it is not even a superset of the original set. Moreover, in general, if we saturate a set w.r.t.
a variable, and then w.r.t. another variable, we obtain a set that is not saturated w.r.t. both variables.

What we will do is to ﬁrst saturate with respect to a variable x. This way we create two multisets of variables. One
with clauses that don’t contain the variable x, and another with clauses that still contain x. We will then saturate with
respect to the following variable only in the multiset of clauses that doesn’t contain the ﬁrst variable x. We will do the
same with the rest of the variables. Also, the saturation procedure keeps a good property: given a multiset of clauses
saturated w.r.t. a variable x, if there exists an assignment satisfying all the clauses not containing x, then it can be
extended (by assigning x) to satisfy all the clauses (see Lemma 9).

Deﬁnition 5. A multiset of clauses C is said to be saturated w.r.t. x if for every pair of clauses C1 = x ∨ A and
C2 = ¯x ∨ B of C, there is a literal l such that l is in A and ¯l is in B.

A multiset of clauses C(cid:3) is a saturation of C w.r.t. x if C(cid:3) is saturated w.r.t. x and C (cid:5)x C(cid:3); i.e., C(cid:3) can be obtained

from C applying the inference rule cutting x ﬁnitely many times.

Trivially, by the previous deﬁnition, a multiset of clauses C is saturated w.r.t. x if, and only if, every possible

application of the inference rule cutting x only introduces clauses containing x (since tautologies get eliminated).

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

611

We assign a function P : {0, 1}n → {0, 1} to every clause, and a function P : {0, 1}n → N to every multiset of clauses

as follows.

Deﬁnition 6. For every clause C = x1 ∨ · · · ∨ xs ∨ ¯xs+1 ∨ · · · ∨ ¯xs+t we deﬁne its characteristic function as PC((cid:7)x) =
(1 − x1) . . . (1 − xs) xs+1 . . . xs+t .

For every multiset of clauses C = {C1, . . . , Cm}, we deﬁne its characteristic function as PC =

(cid:2)

m
i=1 PCi ((cid:7)x).

Notice that for every assignment I , PC(I ) is the number of clauses of C falsiﬁed by I . Also, by the soundness of
our rule, a step of the Max-SAT resolution rule replaces a multiset of clauses by another with the same characteristic
function.

Before stating and proving the following lemma, let us recall the usual order relation among functions: f (cid:4) g if for
all x, f (x) (cid:4) g(x), and f < g if for all x, f (x) (cid:4) g(x) and for some x, f (x) < g(x). Since the functions have ﬁnite
domain and the order relation on the range is well-founded, the order relation < on the functions is also well-founded.

Lemma 7. For every multiset of clauses C and variable x, there exists a multiset C(cid:3) such that C(cid:3) is a saturation of C
w.r.t. x. Moreover, this multiset C(cid:3) can be computed by applying the inference rule to any pair of clauses x ∨ A and
¯x ∨ B with the restriction that A ∨ B is not a tautology, using any ordering of the literals, until we can not apply the
inference rule any longer with this restriction.

Proof. We proceed by applying nondeterministically the inference rule cutting x, until we obtain a saturated multiset.
We only need to prove that this process terminates in ﬁnitely many inference steps, i.e. that there does not exist an
inﬁnite sequence C = C0 (cid:5) C1 (cid:5) · · · , where at every inference step we cut the variable x and none of the sets Ci are
saturated.

At every step, we can divide Ci into two multisets: Ei with all the clauses that do not contain x, and Di with the
clauses that contain the variable x (in positive or negative form). When we apply the inference rule we replace two
clauses of Di by a multiset of clauses, where one of them, say A, does not contain x. Therefore, we obtain a distinct
multiset Ci+1 = Di+1 ∪ Ei+1, where Ei+1 = Ei ∪ {A}. Since A is not a tautology, the characteristic function PA is
− PA and
= PCi and PEi+1
not the constant zero function. Then, since PCi+1
PDi+1 < PDi . Therefore, the characteristic function of the multiset of clauses containing x strictly decreases after
every inference step. Since the order relation between characteristic functions is well-founded, this proves that we can
not perform inﬁnitely many inference steps. (cid:2)

+ PA, we obtain PDi+1

= PDi

= PEi

Remark 8. Although every multiset of clauses is saturable, its saturation is not unique. For instance, the multiset
{a, ¯a ∨ b, ¯a ∨ c} has two possibles saturations w.r.t. variable a: the multiset {b, ¯b ∨ c, a ∨ ¯b ∨ ¯c, ¯a ∨ b ∨ c} and the
multiset {c, b ∨ ¯c, a ∨ ¯b ∨ ¯c, ¯a ∨ b ∨ c}.

Another difference with respect to classical resolution is that we can not saturate a set of clauses simultaneously
w.r.t. two variables by saturating w.r.t. one, and then w.r.t. the other. For instance, if we saturate { ¯a ∨ c, a ∨ b ∨ c} w.r.t.
a, we obtain {b ∨ c, ¯a ∨ ¯b ∨ c}. This is the only possible saturation of the original set. If now we saturate this multiset
w.r.t. b, we obtain again the original set { ¯a ∨ c, a ∨ b ∨ c}. Therefore, it is not possible to saturate this multiset of
clauses w.r.t. a and b simultaneously.

Lemma 9. Let C be a saturated multiset of clauses w.r.t. x. Let C(cid:3) be the subset of clauses of C not containing x. Then,
any assignment I satisfying C(cid:3) (and not assigning x) can be extended to an assignment satisfying C.

Proof. We have to extend I to satisfy the whole C. In fact we only need to set the value of x. If x has a unique
polarity in C \ C(cid:3), then the extension is trivial (x = true if x always occurs positively, and x = false otherwise). If, for
any clause of the form x ∨ A or ¯x ∨ A, the assignment I already satisﬁes A, then any choice of the value of x will
work. Otherwise, assume that there is a clause x ∨ A (similarly for ¯x ∨ A) such that I sets A to false. We set x to true.
All the clauses of the form x ∨ B will be satisﬁed. For the clauses of the form ¯x ∨ B, since C is saturated, there exists
a literal l such that l ∈ A and ¯l ∈ B. This ensures that, since I falsiﬁes A, I (l) = false and I satisﬁes B. (cid:2)

612

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

4. Completeness of Max-SAT resolution

Now, we prove the main result of this paper, the completeness of Max-SAT resolution. The main idea is to prove
that we can get a complete algorithm by successively saturating w.r.t. all the variables. However, notice that after
saturating w.r.t. x1 and then w.r.t. x2, we get a multiset of clauses that is not saturated w.r.t. x1 anymore. Therefore,
we will use a variant of this basic algorithm: we saturate w.r.t. x1, then we remove all the clauses containing x1, and
saturate w.r.t. x2, we remove all the clauses containing x2 and saturate w.r.t. x3, etc. Using Lemma 9, we prove that, if
the original multiset of clauses was unsatisﬁable, then with this process we get the empty clause. Even better, we get
as many empty clauses as the minimum number of unsatisﬁed clauses in the original formula.

Theorem 10 (Completeness). For any multiset of clauses C, we have

, D
C (cid:5) (cid:3), . . . , (cid:3)
(cid:6)

(cid:3)

(cid:4)(cid:5)
m

where D is a satisﬁable multiset of clauses, and m is the minimum number of unsatisﬁed clauses of C.

Proof. Let x1, . . . , xn be any list of the variables of C. We construct two sequences of multisets C0, . . . , Cn and
D1, . . . , Dn such that

(i) C = C0,
(ii) for i = 1, . . . , n, Ci ∪ Di is a saturation of Ci−1 w.r.t. xi , and
(iii) for i = 1, . . . , n, Ci is a multiset of clauses not containing x1, . . . , xi , and Di is a multiset of clauses containing

the variable xi .

By Lemma 7, this sequences can effectively be computed: for i = 1, . . . , n, we saturate Ci−1 w.r.t. xi , and then we

partition the resulting multiset into a subset Di containing xi , and another Ci not containing this variable.

Notice that, since Cn does not contain any variable, it is either the empty multiset ∅, or it only contains (some)

empty clauses {(cid:3), . . . , (cid:3)}.

Now we are going to prove that the multiset D =

Di is satisﬁable by constructing an assignment satisfying

it. For i = 1, . . . , n, let Ei = Di ∪ · · · ∪ Dn, and let En+1 = ∅. Notice that, for i = 1, . . . , n,

(cid:7)
n
i=1

(i) the multiset Ei only contains the variables {xi, . . . , xn},
(ii) Ei is saturated w.r.t. xi , and
(iii) Ei decomposes as Ei = Di ∪ Ei+1, where all the clauses of Di contain xi and none of Ei+1 contains xi .

Claims (i) and (iii) are trivial. For claim (ii), notice that, since Ci ∪ Di is saturated w.r.t. xi , the subset Di is also

saturated. Now, since Di+1 ∪ · · · ∪ Dn does not contain xi , the set Ei will be saturated w.r.t. xi .

Now, we construct a sequence of assignments I1, . . . , In+1, where In+1 is the empty assignment, hence satisﬁes
En+1 = ∅. Now, Ii is constructed from Ii+1 as follows. Assume by induction hypothesis that Ii+1 satisﬁes Ei+1. Since
Ei is saturated w.r.t. xi , and decomposes into Di and Ei+1, by Lemma 9, we can extend Ii+1 with an assignment for
xi to obtain Ii satisfying Ei . Iterating, we get that I1 satisﬁes E1 = D =

Since the inference rule is sound (Theorem 4), and by the previous argument D is satisﬁable, we conclude that

(cid:7)
n
i=1

Di .

m = |Cn| is the minimum number of unsatisﬁed clauses of C. (cid:2)

In classical resolution we can assume a given total order on the variables x1 > x2 > · · · > xn and restrict inferences
x ∨ A, ¯x ∨ B (cid:5) A ∨ B to satisfy that x is maximal in x ∨ A and in ¯x ∨ B. This reﬁnement of resolution is complete,
and has some advantages: the set of possible proofs is smaller, thus its search is more efﬁcient.

The same result holds for Max-SAT Resolution:

Corollary 11. For any multiset of clauses C, and for every ordering x1 > · · · > xn of the variables, we have

C (cid:5)x1 C

(cid:3) (cid:5)x2

· · · (cid:5)xn

, D
(cid:3), . . . , (cid:3)
(cid:3)
(cid:6)
(cid:4)(cid:5)
m

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

613

where D is a satisﬁable multiset of clauses, m is the minimum number of unsatisﬁed clauses of C, and in every
inference step the cut variable is maximal.

Proof. The proof is similar to Theorem 10. First, given the ordering x1 > x2 > · · · > xn, we start by computing the
saturation w.r.t. x1 and ﬁnish with xn. Now, notice that, when we saturate C0 w.r.t. x1 to obtain C1 ∪ D1, we only
cut x1, and this is the biggest variable. Then, when we saturate C1 w.r.t. x2 to obtain C2 ∪ D2, we have to notice
that the clauses of C1, and the clauses that we could obtain from them, do not contain x1, and we only cut x2 which
is the biggest variable in all the premises. In general, we can see that at every inference step performed during the
computation of the saturations (no matter how they are computed) we always cut a maximal variable. We only have
to choose the order in which we saturate the variables coherently with the given ordering of the variables. (cid:2)

5. An algorithm for Max-SAT

From the proof of Theorem 10, we can extract the following algorithm:

input : C
C0 := C
for i := 1 to n

C := saturation(Ci−1, xi)
(cid:11)Ci, Di(cid:12) := partition(C, xi)

endfor
m := |Cn|
I := ∅
for i := n downto 1

output : m, I

I := I ∪ [xi (cid:13)→ extension(xi, I, Di)]

Given an initial multiset of clauses C, this algorithm obtains the minimum number m of unsatisﬁed clauses and an

optimal assignment I for C.

Function saturation(C, x) computes a saturation of C w.r.t. x. As we have already said, the saturation of a multiset
is not unique, but the proof of Theorem 10 does not depends on which particular saturation we take. Therefore, this
computation can be done with “don’t care” non-determinism.

Function partition(Ci, x) computes a partition of C into the subset of clauses containing x and the subset of clauses

not containing x, Di and Ci respectively.

Function extension(x, I, D) computes a truth assignment for x such that, if I assigns the value true to all the clauses
of D containing x, then the function returns false, if I assigns true to all the clauses of D containing ¯x, then returns
true. According to Lemma 9 and the way the Di ’s are computed, I evaluates to true all the clauses containing x or all
the clauses containing ¯x.

The order on the saturation of the variables can also be freely chosen; i.e., the sequence x1, . . . , xn can be any

enumeration of the variables.

6. Efﬁciency

In classical resolution, we know that there are formulas that require exponentially long refutations on the number
of variables, and even on the size of the formula. On the other hand, no formula requires more than 2n inference steps
to be refuted, being n the number of variables. Fortunately, in many practical cases the number of resolution steps
required is polynomial. Obviously, we do not have a better situation in Max-SAT resolution. Moreover, since we can
have repeated clauses, and we may need to generate more than one empty clause, the number of inference steps is not
only bounded by the number of variables. It also depends on the number of original clauses. Again, in many practical
cases of Max-SAT resolution, the number of resolution steps is also polynomial. In contrast, bucket elimination for
soft constraints [29], which is also a complete procedure for Max-SAT, always requires exponential time, even worse,
exponential space.

The following theorem states an upper bound on the number of inference steps, using the strategy of saturating

variable by variable:

614

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

Theorem 12. For any multiset C of m clauses on n variables, we can deduce C (cid:5) (cid:3), . . . , (cid:3), D, where D is satisﬁable,
in less than n · m · 2n inference steps. Moreover, the search of this proof can also be done in time O(m 2n).

Proof. Assign to every clause C a weight w(C) equal to the number of assignments to the n variables that falsify
the clause. The weight of a multiset of clauses is then the sum of the weights of its clauses. Obviously the weight
of a clause is bounded by the number of possible assignments w(C) (cid:4) 2n, being w(C) = 0 true only for tautologies.
Therefore, the weight of the original multiset is bounded by m 2n.

As with the characteristic function, when C (cid:5) D, we have w(C) = w(D).
A similar argument to Lemma 7 can be used to prove that we can obtain a saturation D of any multiset C w.r.t. any
variable x in less than w(C) many inference steps. If we compute the weight of the clauses containing x and of those
not containing x separately, we see that, in each inference step, the ﬁrst weight strictly decreases while the second one
increases. Therefore, the saturation w.r.t. the ﬁrst variable needs no more than m 2n inference steps.

When we partition C into a subset containing x and another not containing x, both subsets will have weight smaller
than w(C), so the weight of C when we start the second round of saturations will also be bounded by the original
weight. We can repeat the same argument for the saturation w.r.t. the n variables, and conclude that the total number
of inference steps is bounded by n m 2n.

The proof of completeness for ordered Max-SAT resolution, does not depend on which saturation we compute.

Each inference step can be computed in time O(n). This gives the worst-case time upper bound. (cid:2)

7. Weighted Max-SAT

In Weighted Max-SAT we use multisets of weighted clauses. A weighted clause is a pair (C, w), where C is a
clause and w is a natural number meaning the penalty for falsifying the clause C. The pair (C, w) is clearly equivalent
to having w copies of clause C in our multiset.

Given a truth assignment I and a multiset of weighted clauses C, the cost of assignment I on C is the sum of the

weights of the clauses falsiﬁed by I .

The Weighted Max-SAT problem for a multiset of weighted clauses C is the problem of ﬁnding an assignment to

the variables of C that minimizes the cost of the assignment on C.

For the Weighted Max-SAT problem a resolution-style inference rule can also be deﬁned. The following rule is an
extension of the Max-SAT resolution rule with weights like the one deﬁned by [21]. Here we will convert the rule to
clausal form, and prove its completeness.

Deﬁnition 13. The Weighted Max-SAT resolution rule is deﬁned as follows:

(x ∨ a1 ∨ · · · ∨ as, u)
( ¯x ∨ b1 ∨ · · · ∨ bt , w)
(a1 ∨ · · · ∨ as ∨ b1 ∨ · · · ∨ bt , min(u, w))
(x ∨ a1 ∨ · · · ∨ as, u − min(u, w))
( ¯x ∨ b1 ∨ · · · ∨ bt , w − min(u, w))
(x ∨ a1 ∨ · · · ∨ as ∨ ¯b1, min(u, w))
(x ∨ a1 ∨ · · · ∨ as ∨ b1 ∨ ¯b2, min(u, w))
· · ·
(x ∨ a1 ∨ · · · ∨ as ∨ b1 ∨ · · · ∨ bt−1 ∨ ¯bt , min(u, w))
( ¯x ∨ b1 ∨ · · · ∨ bt ∨ ¯a1, min(u, w))
( ¯x ∨ b1 ∨ · · · ∨ bt ∨ a1 ∨ ¯a2, min(u, w))
· · ·
( ¯x ∨ b1 ∨ · · · ∨ bt ∨ a1 ∨ · · · ∨ as−1 ∨ ¯as, min(u, w))

This inference rule is applied to multisets of clauses, and replaces the premises of the rule by its conclusions.
We say that the rule cuts the variable x.
The tautologies concluded by the rule and the clauses with weight zero are removed from the resulting multiset.

Similarly, repeated literals in a clause are collapsed into one.

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

615

We also consider the following optional rule, called the contraction rule:

(A, u)
(A, w)
(A, u + w)

Notice that the application of the weighted rule is clearly equivalent to the application of the unweighted rule

min(u, w) many times.

Theorem 14 (Soundness). The Weighted Max-SAT resolution rule is sound; i.e., for every truth assignment the cost of
the assignment on the set of premises of the rule is equal to the cost of the assignment on the set of conclusions.

Proof. Without loss of generality suppose that u (cid:4) w. Then min(u, w) = u, u − min(u, w) = 0 and w − min(u, w) =
w − u. Also, {(x ∨ A, u), ( ¯x ∨ B, w)} is equivalent to {(x ∨ A, u), ( ¯x ∨ B, u), ( ¯x ∨ B, w − u)}. Using this fact and the
soundness of the unweighted Max-SAT rule applied u times to {(x ∨ A, u), ( ¯x ∨ B, u)} we can obtain the soundness
of the weighted rule. (cid:2)

Theorem 15 (Completeness). For any multiset of clauses C, we have

C (cid:5) ((cid:3), u1), . . . , ((cid:3), us), D

where D is a satisﬁable multiset of clauses, and u1 + · · · + us is the minimal cost of C.

Moreover, if we also consider the contraction rule, then we have

C (cid:5) ((cid:3), u), D

where u is the minimal cost.

Proof. The proof is similar to the unweighted case, generalizing the deﬁnition of characteristic function. For every
weighted clause C = (x1 ∨ · · · ∨ xs ∨ ¯xs+1 ∨ · · · ∨ ¯xs+t , u) we deﬁne its characteristic function as PC((cid:7)x) = u(1 −
x1) · · · (1 − xs)xs+1 . . . xs+t . (cid:2)

8. Hard instances for the Max-SAT resolution rule. Lower bounds

In this section we will give various examples of classes of multisets of clauses that require an exponential number of
steps (respect to the number of initial clauses) to generate the minimal number of unsatisﬁed clauses using Max-SAT
resolution.

One of these examples is the pigeon-hole principle. We will formalize it as a multiset of clauses saying that n + 1
pigeons cannot be placed into n holes unless a hole contains more than one pigeon. Actually, we will formalize
the negation of the principle to have an unsatisﬁable multiset of clauses. We will use variables pi,j meaning that
pigeon i goes to hole j . So the multiset of clauses will be {pi,1 ∨ · · · ∨ pi,n: 1 (cid:4) i (cid:4) n + 1} ∪ { ¯pi,j ∨ ¯pk,j : 1 (cid:4) i, k (cid:4)
n + 1, 1 (cid:4) j (cid:4) n}. We will call this multiset PHPn+1
. From this multiset of clauses we can deﬁne the class of multisets
{PHPn+1
: n ∈ N}. For this principle, we will show that any sequence of Max-SAT resolution rule applications will
need an exponential (in n) number of steps to show that one of the clauses cannot be satisﬁed.
To be able to show our result we will use the fact that any resolution refutation of PHPn+1

requires an exponential
(in n) number of steps. Recall that resolution is a propositional proof system to show the unsatisﬁability of a set of
clauses based on the following inference rule.

n

n

n

x ∨ A
¯x ∨ B
A ∨ B

Also we will use the fact that from a Max-SAT resolution proof we can extract a resolution refutation of the same

principle. The following two theorems will be the basic ingredients of the main result of this section.

616

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

Theorem 16. (See [10,16].) For sufﬁciently large n, any resolution refutation of PHPn+1
(inference steps).

n

requires 2n/20 clauses

Theorem 17. Let C be an unsatisﬁable multiset of clauses. Suppose

, D,
C (cid:5) (cid:3), . . . , (cid:3)
(cid:6)

(cid:3)

(cid:4)(cid:5)
k

where D is satisﬁable, k the minimum number of unsatisﬁed clauses, and S is the number of steps in the Max-SAT
refutation. Then, there is a (classical) resolution refutation of C in S steps.

Proof. Let

, D
C = C0 (cid:5) C1 (cid:5) · · · (cid:5) CS = (cid:3), . . . , (cid:3)
(cid:6)

(cid:3)

(cid:4)(cid:5)
k

be the sequence of multisets that we generate in the S steps. We will deﬁne by induction on S a sequence of multisets

C = D0 (cid:5) D1 (cid:5) · · · (cid:5) DS

such that for every step i and for every clause C in Ci , there is a clause C(cid:3) in Di such that C(cid:3) ⊂ C.

Since D0 = C0, obviously the property holds for 0.
Assume now by the induction hypothesis that for every j (cid:4) i the corresponding Di ’s are deﬁned fulﬁlling the
property. Let Ci = {x ∨ A, ¯x ∨ B} ∪ C(cid:3), and Ci+1 = {A ∨ B . . .} ∪ C(cid:3). Let D1, D2 ∈ Di such that D1 ⊂ x ∨ A and
D2 ⊂ ¯x ∨ B. If x /∈ D1 or ¯x /∈ D2 then Di+1 = Di . Else, we apply the resolution rule to D1 and D2 cutting x to obtain
a clause D that will be a subset of A ∨ B. Then we deﬁne Di+1 = Di ∪ {D}. Notice that the other clauses of Ci+1 have
a subclause in Di and therefore in Di+1.

Now since CS has at least one (cid:3), and for every clause in CS there is a clause in DS that is a subclause of it, DS

must contain (cid:3). (cid:2)

Now we can give the lower bound theorem, which is an immediate corollary of Theorem 17 together with Theo-

rem 16.

Corollary 18. For sufﬁciently large n, any Max-SAT resolution derivation of PHPn+1
requires 2n/20 inference steps.

n

(cid:5) (cid:3), D, where D is satisﬁable,

There are resolution lower bounds (as in Theorem 16) for other combinatorial principles like Tseitin formulas [11,
31], Random formulas [9,11], Mutilated chessboard [1], Reﬂexion principle [6,7], Planar Tautologies [14], the Clique-
Coloring principle [19,26] and the Weak pigeon-hole principle [27,28]. Also Theorem 17 is very general. Therefore
we can obtain the same results (as in Corollary 18) for all these combinatorial principles.

9. Conclusions

In this paper we have presented several contributions to the Max-SAT problem: (i) a new sound and complete
resolution rule in which both conclusions and premises are in clausal form; (ii) an original exact algorithm; (iii) a
complete ordered resolution reﬁnement; (iv) an extension of our rule which is complete for Weighted Max-SAT, and
(v) examples of classes of multisets of clauses that require an exponential number of Max-SAT resolution steps (in
terms of the size of the initial multiset) to obtain the minimal number of unsatisﬁed clauses.

One feature of our logical framework is that the inference rules implemented in modern Max-SAT solvers either are
particular cases of our rule or can be obtained as derived rules. So, we believe that our framework is a good starting
point for designers of future Max-SAT solvers to devise more powerful inference techniques that could be applied
efﬁciently at every node of the proof tree.

The exact algorithm we have obtained from the completeness proof can be described as an extension to Max-
SAT of the original Davis–Putnam algorithm [15]. We believe that, as it happens in SAT, an implementation of that
algorithm could rarely outperform a DPLL-style Max-SAT solver. Nevertheless, it is an open question to know if there

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

617

are Max-SAT instances that can be solved in polynomial time with our algorithm but require exponential time with
DPLL-style solvers.

The contributions of this paper can also be applied beyond Max-SAT. As an example, we would like to point out
that we have recently extended our results to many-valued CNF formulas. The complete resolution rule for Many-
Valued Max-SAT we have obtained has allowed us to deﬁne derived rules that capture the most relevant soft local
consistencies deﬁned in the Weighted CSP community, as well as to provide a logical framework for Weighted CSPs.
Such results were presented at the workshop Soft Constraints at CP’06, and also published in [5].

This paper is an extended version of our paper “A complete calculus for Max-SAT” presented at SAT’06 [12]
containing more results. Sections 7 and 8 are new. Independently of our work, [17] have recently presented a clausal
form translation of their inference rule [21] at AAAI-2006.

References

[1] M. Alekhnovich, Mutilated chessboard problem is exponentially hard for resolution, Theoretical Computer Science 310 (1–3) (2004) 513–525.
[2] T. Alsinet, F. Manyà, J. Planes, Improved branch and bound algorithms for Max-SAT, in: Proc. of the 6th Int. Conf. on the Theory and

Applications of Satisﬁability Testing, SAT’03, 2003.

[3] T. Alsinet, F. Manyà, J. Planes, A Max-SAT solver with lazy data structures, in: Proc. of the 9th Ibero–American Conference on Artiﬁcial

Intelligence, IBERAMIA’04, Puebla, México, in: Lecture Notes Comput. Sci., vol. 3315, Springer, 2004, pp. 334–342.

[4] T. Alsinet, F. Manyà, J. Planes, Improved exact solver for weighted Max-SAT, in: Proc. of the 8th Int. Conf. on Theory and Applications of

Satisﬁability Testing, SAT’05, St. Andrews, Scotland, in: Lecture Notes Comput. Sci., vol. 3569, Springer, 2005, pp. 371–377.

[5] C. Ansótegui, M.L. Bonet, J. Levy, F. Manyà, The logic behind weighted CSP, in: Proc. of the 20th Int. Joint Conference on Artiﬁcial

Intelligence, IJCAI’07, AAAI Press, 2007, pp. 32–37.

[6] A. Atserias, M.L. Bonet, On the automatizability of resolution and related propositional proof systems, in: Proc. of the 16th Int. Conf. on

Computer Science Logic, CSL’02, Edinburgh, Scotland, in: Lecture Notes Comput. Sci., vol. 2471, Springer, 2002, pp. 569–583.

[7] A. Atserias, M.L. Bonet, On the automatizability of resolution and related propositional proof systems, Information and Computation 189 (2)

(2004).

[8] N. Bansal, V. Raman, Upper bounds for MaxSat: Further improved, in: Proc. of the 10th Int. Symposium on Algorithms and Computation,

ISAAC’99, Chennai, India, in: Lecture Notes Comput. Sci., vol. 1741, Springer, 1999, pp. 247–260.

[9] P. Beame, R. Karp, T. Pitassi, M. Saks, The efﬁciency of resolution and Davis–Putnam procedures, SIAM Journal on Computing 31 (4) (2002)

1048–1075.

[10] P. Beame, T. Pitassi, Simpliﬁed and improved resolution lower bounds, in: Proc. of the 37th Annual Symposium on Foundations of Computer

Science, FOCS’96, Burlington, VT, USA, 1996, pp. 274–282.

[11] E. Ben-Sasson, A. Wigderson, Short proofs are narrow—resolution made simple, Journal of the ACM 48 (2) (2001) 149–169.
[12] M.L. Bonet, J. Levy, F. Manyà, A complete calculus for Max-SAT, in: Proc. of the 9th Int. Conf. on Theory and Applications of Satisﬁability

Testing, SAT’06, Seattle, WA, USA, in: Lecture Notes Comput. Sci., vol. 4121, Springer, 2006, pp. 240–251.

[13] B. Borchers, J. Furman, A two-phase exact algorithm for Max-SAT and weighted Max-SAT problems, Journal of Combinatorial Optimiza-

tion 2 (1999) 299–306.

[14] S. Dantchev, S. Riis, Planar tautologies, hard for resolution, in: Proc. of the 42nd Annual Symposium on Foundations of Computer Science,

FOCS’01, Los Alamitos, CA, USA, 2001, pp. 220–231.

[15] M. Davis, H. Putnam, A computing procedure for quantiﬁcation theory, Journal of the ACM 7 (3) (1960) 201–215.
[16] A. Haken, The intractability of Resolution, Theoretical Computer Science 39 (2–3) (1985) 297–308.
[17] F. Heras, J. Larrosa, New inference rules for efﬁcient Max-SAT solving, in: Proc. of the 21st National Conference on Artiﬁcial Intelligence,

AAAI’06, Boston, MA, AAAI Press, 2006, pp. 68–73.

[18] S. Khanna, M. Sudan, L. Trevisan, D.P. Williamson, The approximability of constraint satisfaction problems, SIAM Journal on Comput-

ing 30 (6) (2001) 1863–1920.

[19] J. Krajícek, Interpolation theorems, lower bounds for proof systems and independence results for bounded arithmetic, Journal of Symbolic

Logic 62 (2) (1997).

[20] A.S. Kulikov, Automated generation of simpliﬁcation rules for SAT and MAXSAT, in: Proc. of the 8th Int. Conf. on Theory and Applications

of Satisﬁability Testing, SAT’05, St. Andrews, Scotland, in: Lecture Notes Comput. Sci., vol. 3569, Springer, 2005, pp. 430–436.

[21] J. Larrosa, F. Heras, Resolution in Max-SAT and its relation to local consistency in weighted CSPs, in: Proc. of the 19th Int. Joint Conference

on Artiﬁcial Intelligence, IJCAI’05, Edinburgh, Scotland, 2005, pp. 193–198.

[22] C.M. Li, F. Manyà, J. Planes, Exploiting unit propagation to compute lower bounds in branch and bound Max-SAT solvers, in: Proc. of the 11th
Int. Conf. on Principles and Practice of Constraint Programming, CP’05, Sitges, Spain, in: Lecture Notes Comput. Sci., vol. 3709, Springer,
2005, pp. 403–414.

[23] C.M. Li, F. Manyà, J. Planes, Detecting disjoint inconsistent subformulas for computing lower bounds for Max-SAT, in: Proc. of the 21st

National Conference on Artiﬁcial Intelligence, AAAI’06, Boston, MA, AAAI Press, 2006, pp. 86–91.

[24] R. Niedermeier, P. Rossmanith, New upper bounds for maximum satisﬁability, Journal of Algorithms 36 (1) (2000) 63–88.
[25] C.M. Papadimitriou, Computational Complexity, Addison-Wesley, Reading, MA, 1994.
[26] P. Pudlák, Lower bounds for resolution and cutting plane proofs and monotone computations, Journal of Symbolic Logic 62 (3) (1997).

618

M.L. Bonet et al. / Artiﬁcial Intelligence 171 (2007) 606–618

[27] R. Raz, Resolution lower bounds for the weak pigeonhole principle, in: Proc. of the 34th Annual ACM Symposium on Theory of Computing,

STOC’02, Montreal, Canada, 2002, pp. 553–562.

[28] A. Razborov, Improved resolution lower bounds for the weak pigeonhole principle, Electronic Colloquium on Computational Complex-

ity 8 (55) (2001).

[29] E. Rollon, J. Larrosa, Bucket elimination for multiobjective optimization problems, Journal of Heuristics 12 (4–5) (2006).
[30] H. Shen, H. Zhang, Study of lower bound functions for MAX-2-SAT, in: Proc. of the 19th National Conference on Artiﬁcial Intelligence,

AAAI’04, San Jose, CA, USA, AAAI Press, 2004, pp. 185–190.

[31] A. Urquhart, Hard examples for resolution, Journal of the ACM 34 (1) (1987) 209–219.
[32] Z. Xing, W. Zhang, Efﬁcient strategies for (weighted) maximum satisﬁability, in: Proc. of the 10th Int. Conf. on Principles and Practice of

Constraint Programming, CP’04, Toronto, Canada, in: Lecture Notes Comput. Sci., vol. 3258, Springer, 2004, pp. 690–705.

[33] Z. Xing, W. Zhang, An efﬁcient exact algorithm for (weighted) maximum satisﬁability, Artiﬁcial Intelligence 164 (2) (2005) 47–80.
[34] H. Zhang, H. Shen, F. Manya, Exact algorithms for MAX-SAT, Electronic Notes in Theoretical Computer Science 86 (1) (2003).

