Artiﬁcial Intelligence 224 (2015) 72–102

Contents lists available at ScienceDirect

Artiﬁcial  Intelligence

www.elsevier.com/locate/artint

Ordered  completion  for  logic  programs  with  aggregates
Vernon Asuncion a,  Yin Chen b,  Yan Zhang a,  Yi Zhou a,∗
a Artiﬁcial Intelligence Research Group (AIRG), School of Computing, Engineering and Mathematics, University of Western Sydney, Australia
b Department of Computer Science, South China Normal University, Guangzhou, China

a  r  t  i  c  l  e 

i  n  f  o

a  b  s  t  r  a  c  t

Article history:
Received 7 August 2013
Received in revised form 16 March 2015
Accepted 21 March 2015
Available online 25 March 2015

Keywords:
Knowledge representation and reasoning
Answer Set Programming
Aggregates
First-order logic
Logic programming

We consider the problem of translating ﬁrst-order answer set programs with aggregates 
into ﬁrst-order sentences with the same type of aggregates. In particular, we show that, 
on  ﬁnite  structures,  normal  logic  programs  with  convex  aggregates,  which  cover  both 
monotone  and  antimonotone  aggregates  as  well  as  the  aggregates  appearing  in  most 
benchmark  programs,  can  always  be  captured  in  ﬁrst-order  logic  with  the  same  type 
of  aggregates  by  introducing  auxiliary  predicates.  More  precisely,  we  prove  that  every 
ﬁnite  stable  model  of  a  normal  program  with  convex  aggregates  is  corresponding  to  a 
classical  model  of  its  enhanced  ordered  completion.  This  translation  then  suggests  an 
alternative  way  for  computing  the  stable  models  of  such  kind  of  programs.  We  report 
some experimental results, which demonstrate that our solver GROCv2 is comparable to 
the  state-of-the-art  answer  set  solvers.  We  further show  that  convex  aggregates  form  a 
maximal class for this purpose. That is, we can always construct a normal logic program 
under any given non-convex aggregate context and prove that it can never be translated 
into ﬁrst-order sentences with the same type of aggregates unless NP = coNP.

© 2015 Elsevier B.V. All rights reserved.

1.  Introduction

In this paper, we consider to translate ﬁrst-order Answer Set Programming (ASP), a predominant declarative program-
ming  paradigm  in  the  area  of  knowledge  representation  and  logic  programming  [3,20,24,25],  into  ﬁrst-order  logic.  Work 
in  this  direction  is  not  only  of  theoretical  interests  but  also  of  practical  relevances  as  it  suggests  an  alternative  way  to 
implement ASP.

Recently, Asuncion et al. [2] proposed a notion of ordered completion (a ﬁrst-order sentence with some extra predicates) 
for ﬁrst-order normal logic programs, and showed that the stable models of a normal program are exactly corresponding 
to  the  classical  models  of  its  ordered  completion  on  ﬁnite  structures.  Interestingly,  there  is  no  such  translation  on  arbi-
trary  structures  nor  prohibiting  extra  predicates.  Based  on  this  translation,  they  developed  a  new  ASP  solver,  which  ﬁrst 
translates a program to its ordered completion, then grounds this ﬁrst-order sentence, and ﬁnally calls an SMT solver. This 
is signiﬁcantly different from previous ASP solvers, which ground the ﬁrst-order programs directly. A ﬁrst implementation 
shows that this new solver is promising as it performs relatively well for the Hamiltonian Circuit program, particularly on 
big instances [2].

However,  their  work  cannot  handle  aggregates,  a  very  important  building  block  for  modern  Answer  Set  Programming. 
The reason why aggregates are crucial in answer set solving is twofold. Firstly, they enhance the expressive power of ASP, 
and often they can simplify the representation task. For many applications, one can write a simpler and more elegant logic 

* Corresponding author.

E-mail address: y.zhou@uws.edu.au (Y. Zhou).

http://dx.doi.org/10.1016/j.artint.2015.03.007
0004-3702/© 2015 Elsevier B.V. All rights reserved.

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

73

program by using aggregates, for instance, the job scheduling program [28]. Secondly and more importantly, aggregates can 
improve the eﬃciency of ASP solving [19]. Normally, the program using aggregates can be solved much faster [12].

In this paper, we consider the problem of extending ordered completion for programs with aggregates. This is a challeng-
ing task as some programs with aggregates are expressive enough to capture disjunctive logic programming (see in [16]), 
thus can never be captured in ﬁrst-order logic with the same type of aggregates providing some general assumptions in the 
computational complexity theory (see Proposition 6 in [2]).

Hence, an important task is to draw a boundary between the normal programs with aggregates that can be captured in 
ﬁrst-order logic with the same type of aggregates and those programs that cannot. For this purpose, we extend the notion 
of convex constraints proposed by Liu and Truszczy ´nski [23] into ﬁrst-order convex aggregates. We show that the class of 
convex aggregates is exactly the boundary we need in the sense that

• First-order normal logic programs with convex aggregates can always be captured in ﬁrst-order logic with the same type 
of  aggregates  on  ﬁnite  structures.  More  precisely,  we  extend  the  notion  of  ordered  completion  for  ﬁrst-order  normal 
logic  programs  with  convex  aggregates,  and  show  that  every  stable  model  of  such  a  program  is  corresponding  to  a 
classical model of its enhanced ordered completion.

• Given any non-convex aggregate context, there exists a normal program under this context such that it can never be 

translated into ﬁrst-order sentences with the same type of aggregates unless NP = coNP.

In  fact,  the  class  of  convex  aggregates  is  expressive  enough  to  capture  both  monotone  and  antimonotone  aggregates 
[23] as  well  as  the  aggregates  appearing  in  most  benchmark  programs  [5].  Therefore,  based  on  our  theoretical  results, 
we  are  able  to  develop  an  alternative  ASP  solver  for  ﬁrst-order  normal  programs  with  convex  aggregates.  Following  this 
idea,  we  implement  a  new  ASP  solver  GROCv2.  Our  experimental  results  demonstrate  that  GROCv2  is  comparable  to  the 
state-of-the-art ASP solvers.

The  paper  is  organized  as  follows.  Section 2 reviews  basic  concepts  and  notations  that  we  will  need  through  out  the 
paper. Section 3 presents the ordered completion for logic programs with aggregates, and proves the main theorems. Sec-
tion 4 introduces the implementation of the ASP solver GROCv2, and reports some experimental results. Finally, Sections 5
and 6 discuss some related work and draw our conclusions respectively. We leave the very long proofs of some theorems 
to Appendix A for a more ﬂuent reading.

2.  Preliminaries

We consider a second-order language without functions but with equality =. A signature contains a ﬁnite set of constants 
and a ﬁnite set of predicates. A term is either a variable or a constant. A standard atom is an expression  P (t), where  P is a 
predicate and t is a tuple of terms which matches the arity of  P . An equality atom is an expression t1 = t2, where t1 and t2
are terms.

be two multisets. We denote by  M ⊆ M

A  multiset (also  called  a  bag)  is  a  pair  M = (Ms, M f ),  where  Ms is  a  set  and  M f

is  a  function,  called  the  multiplicity 
function, from  Ms to N, i.e., the set of positive integers {1, 2, 3, . . .}. A multiset (Ms, M f ) is ﬁnite if  Ms is ﬁnite. Let  M and 
if 
M
(cid:3) ⊆ M. For convenience, a multiset M, where Ms = {a1, . . . , an} and M f (ai) = ci (1 ≤ i ≤ n), is also denoted as 
M ⊆ M
and M
} }. The order of the elements is irrelevant. For example, { {a, a, b, c} } is the multiset M, 
{ {a1, . . . , a1
, . . . , an, . . . , an
, . . . , ai, . . . , ai
(cid:5)
(cid:3)(cid:4)
(cid:2)
(cid:5)
(cid:5)
(cid:2)
c1

(cid:3)
s and for all elements a ∈ Ms,  M f (a) ≤ M

(cid:3)
f (a). We write  M = M

if  Ms ⊆ M

(cid:3)(cid:4)
cn

(cid:3)(cid:4)
ci

(cid:2)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

where Ms = {a, b, c} and M f (a) = 2, M f (b) = M f (c) = 1.

2.1.  The syntax of aggregates

Aggregate  is  a  crucial  auxiliary  building  block  for  answer  set  programming  [12,13,16,19,22,23,28].  We  ﬁrst  deﬁne  the 
syntax  of  aggregates  in  the  ﬁrst-order  case.  We  assume  a  set  of  aggregate  symbols  AG and  a  (ﬁxed)  set  of  comparison 
operators on numbers CO = {<, ≤, =, (cid:7)=, ≥, >}.

Deﬁnition 1. An aggregate atom δ is an expression of the form

op(cid:9)v : ∃wQ 1(y1) ∧ · · · ∧ Q s(ys) ∧ ¬R1(z1) ∧ · · · ∧ ¬Rt(zt)(cid:12) (cid:13) t,1

where

• op ∈ AG is an aggregate symbol,
• Q i(yi) (1 ≤ i ≤ s) and  R j(z j) (1 ≤ j ≤ t) are standard atoms or equality atoms. In addition,

Q 1(y1) ∧ · · · ∧ Q s(ys) ∧ ¬R1(z1) ∧ · · · ∧ ¬Rt(zt)

is called the body of δ, denoted by Bd(δ),

1 Here, w could be empty. In this case, (1) is simply written as op(cid:9)v : Bd(δ)(cid:12) (cid:13) t.

(1)

(2)

74

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

• v and w are tuples of variables mentioned in (2), and v ∩ w = ∅,
• (cid:13)∈ CO is a comparison operator on numbers,
• t is a term, and we assume that variables occurring in t are not in v ∪ w.

For convenience, we use  P s(δ) and  N g(δ) to denote the sets {Q 1(y1), . . . , Q s(ys)} and {R1(z1), . . . , Rt (zt)} respectively. 

Given an aggregate atom δ of the form (1), a variable in δ is a free variable if it is not a variable in v ∪ w.

Example 1. Let sum and card be aggregate symbols in AG. The following are two aggregate atoms:

card(cid:9)x : P (x)(cid:12) = 2,

sum(cid:9)x : P (x)(cid:12) ≤ 5.

Intuitively, they are equivalent to the weight constraints

2{p(X)}2,

{p(X) = X}5

in smodels [29], and the aggregate atoms

#count{ X : p(X)} = 2,

#sum{ X : p(X)} ≤ 5

in DLV [14] and ASP-Core-2.2 (cid:2)

An atom is either an equality atom, or a standard atom, or an aggregate atom. A ﬁrst-order formula with aggregates (or 
formula for short) is built from atoms and logical connectives as usual. A formula without aggregate atom is called a classical
formula in this paper. The free variable of a formula is deﬁned as usual. We use free(φ) to denote the set of free variables 
of a formula φ.

2.2.  The semantics for ﬁrst-order logic with aggregates

As  aggregate  is  an  extra  building  block,  we  need  to  extend  the  standard  semantics  for  classical  ﬁrst-order  logic  for 

incorporating aggregates, in which aggregates are considered as predeﬁned function symbols.

Deﬁnition 2. An aggregate context AC is a tuple of the form:

(ACag, ACco, ACnum, opAC

1

, . . . , opAC

n

)

where

• ACag = {op1, . . . , opn} is a subset of AG;
• ACco ⊆ CO is a set of comparison operators;
• ACnum ⊆ Z is a set of numbers;
• for every aggregate symbol opi ∈ AG (1 ≤ i ≤ n), there is a partial function opAC

on ACnum to ACnum.

from the set of multisets over tuples 

i

Example 2. Consider an aggregate context AC1, where

• AC1ag = {card, sum, min, max}, for cardinality, sum, minimum, and maximum respectively;
• AC1co = {<, ≤, =, ≥, >};
• AC1num = N;
• given a multiset M = { {a1, . . . , ak} }, where each ai (1 ≤ i ≤ k) is a tuple of numbers,

– card(M) is deﬁned as the cardinality of M;
– sum(M) is deﬁned as 
– min(M) is undeﬁned if M = ∅, and the minimum of ai[1] (1 ≤ i ≤ k) if M (cid:7)= ∅;
– max(M) is undeﬁned if M = ∅, and the maximum of ai[1] (1 ≤ i ≤ k) if M (cid:7)= ∅.

i=1 ai[1];3

(cid:6)
k

Furthermore, we may also deﬁne the following two aggregate contexts:

• Let AC2 be the aggregate context which is identical to AC1 except that AC2co = CO = AC1co ∪ {(cid:7)=}.
• Let AC3 be the aggregate context which is identical to AC2 except that AC3num = Z. (cid:2)

2 ASP-Core-2 is currently the standard ASP input language, available at https :/ /www.mat .unical .it /aspcomp2013 /ﬁles /ASP-CORE-2 .03b .pdf.
3 Given a tuple a, a[i] denotes the i-th component of a, where 1 ≤ i ≤ |a|.

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

75

The  aggregate  context  AC1 in  Example 2 presents  the  most  common  aggregate  functions  in  the  current  ASP  solvers. 

However, the following example shows that it is possible to deﬁne more general aggregates in our setting theoretically.

Example 3. Consider an aggregate context AC4, where

• AC4ag = {sumall, sat}, where sumall and sat are two aggregate symbols in AG;
• AC4co = {<, ≤, =, ≥, >};
• AC4num = N;
• given a multiset M = { {a1, . . . , ak} }, where each ai , (1 ≤ i ≤ k) is a tuple of numbers,

– sumall(M) is deﬁned as

k(cid:7)

|ai |(cid:7)

i=1

j=1

ai[ j];

– sat(M) is 1 if ϕM is satisﬁable in propositional logic and 0 otherwise, where ϕM is the formula

(cid:9)

(cid:10)

k(cid:8)

(cid:11)

xa

,

i=1

a∈ai

and {x1, x2, . . .} is a set of propositional atoms. (cid:2)

Deﬁnition 3. Given a signature σ , an extended structure A of σ is a tuple

( A, fA, c

A
1 , . . . , c

A
l , P

A
1 , . . . , P

A
m ),

where

(3)

• A is the domain of A, denoted by Dom(A),
• fA is a total function from  A to Z,
A
• c
i
• P

(1 ≤ i ≤ l) is the interpretation for constant ci ;
(1 ≤ j ≤ m) is the interpretation for predicate  P j .

A
j

An  extended  structure  is  ﬁnite if  its  domain  is  ﬁnite.  Note  that  the  only  difference  between  the  extended  structure 
deﬁned  above  and  the  structure  in  ﬁrst-order  logic  is  the  partial  function  fA which  maps  domain  elements  to  numbers. 
This  enables  us  to  freely  use  variables  and  constants  in  aggregate  functions.  Since  aggregate  functions  such  as  sum are 
deﬁned  over  numbers  but  not  over  arbitrary  domain  elements,  we  use  a  two  step  approach  to  interpret  an  aggregate 
atom. First, using the standard ﬁrst-order semantics, we map the terms (i.e., constants and variables) into domain elements. 
Then, we use the function  fA to further map these domain elements into numbers so that the aggregate atoms are well 
deﬁned.  We  extend  the  function  fA for  a  tuple  of  domain  elements  and  for  a  multiset.  By  fA(c),  we  denote  the  tuple 
( fA(c1), . . . , fA(cn)),  where  c = (c1, . . . , cn) is  a  tuple.  By  fA( A),  we  denote  the  multiset  { { fA(a1), . . . , fA(ak)} },  where 
A = { {a1, . . . , ak} } is a multiset. In the following, an extended structure is simply called a structure when it is clear from the 
context.

Let  A be  a  structure.  An  assignment is  an  expression  of  the  form  x/a,  where  x is  a  tuple  of  distinct  variables  and 
a ∈ Dom(A)|x|
is a tuple of domain elements. Assignments can be extended for terms. Let t be a tuple of terms, in which 
the variables are from x. We use t[x/a] to denote the tuple of domain elements by simultaneously replacing the variables 
in x via the assignment x/a and constant c by c

Under  an  aggregate  context  AC,  the  satisfaction  relation  between  a  structure  A and  a  formula  ϕ(x) (with  aggregate 

A

.

atoms) together with an assignment x/a is deﬁned recursively as follows:

A

• If ϕ is  P (t), then A |(cid:17) ϕ[x/a] iff t[x/a] ∈ P
• If ϕ is t1 = t2, then A |(cid:17) ϕ[x/a] iff t1[x/a] = t2[x/a];
• If ϕ is ¬ψ , then A |(cid:17) ϕ[x/a] iff A (cid:7)|(cid:17) ψ[x/a];
• If ϕ is ψ ∧ ξ , then A |(cid:17) ϕ[x/a] iff A |(cid:17) ψ[x/a] and A |(cid:17) ξ [x/a];
• If ϕ is ∀ yψ , then A |(cid:17) ϕ[x/a] iff for all b ∈ Dom(A), A |(cid:17) ψ[x y/ab];
• Finally, if ϕ is an aggregate atom δ of the form (1) in the aggregate context AC, then A |(cid:17) ϕ[x/a] iff

;

1. op ∈ ACag and (cid:13)∈ ACco;
2. t[x/a] is in the domain of  fA;
3. the multiset

M = {{ fA(c) | c ∈ M

(cid:3)

, fA(c) is deﬁned}}

76

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

is in the domain of opAC

, where M

(cid:3)

is the set

{c | A |(cid:17) Bd(δ)[xwv/abc], b ∈ Dom(A)

|w|

, c ∈ Dom(A)

|v|};

4. opAC( A) (cid:13) fA(t[y/a]);

Example 4. Consider the aggregate context AC2 and a signature σ with only one predicate  P . For any structure A with the 
domain {a, b} and  fA(a) = 2 and  fA(b) = 3, we have

A |(cid:17) sum(cid:9)x : P (x)(cid:12) ≤ 5,

and

A |(cid:17) sum(cid:9)x : P (x)(cid:12) (cid:7)= 2 ≡ (P (a) → P (b)).

(cid:2)

Let AC be an aggregate context. An aggregate op ∈ ACag is polynomial if the problem of checking opAC(M) (cid:13) n can be 
done in polynomial time with respect to |M| for every multiset M and number n, where |M|, the length of M, is deﬁned as 
the sum of the length of all tuples in M [16]. AC is polynomial if all aggregates in it are polynomial. It can be veriﬁed that 
all three aggregate contexts in Example 2 are polynomial, while AC4 in Example 3 is not polynomial unless  P = N P .

2.3.  The stable model semantics for normal logic programs with aggregates

We  now  propose  the  stable  model  semantics  for  ﬁrst-order  normal  logic  programs  with  aggregates.  A  normal program 

with aggregates (or program for short) is a ﬁnite set of rules of the form

α ← β1, . . . , βl, not γ1, . . . , not γm,

(4)

where α is either a standard atom or ⊥, βi (1 ≤ i ≤ l) and γ j (1 ≤ j ≤ m) are atoms.

A rule of the form (4) is called a constraint if α is ⊥. By (cid:11)⊥

, we denote the set of constraints in program (cid:11). Let r be 
a rule of the form (4). We call α the head of r and {β1, . . . , βl, not γ1, . . . , not γm} the body of r. A variable is called a local 
variable of r if it occurs in a standard atom, equality atom, or occurs freely in an aggregate atom in the body of r but it does 
not occur in the head of r. For convenience, we use Head(r) and Body(r) to denote α and β1 ∧ · · · ∧ βl ∧ ¬γ1 ∧ · · · ∧ ¬γm, 
respectively. We also use Pos(r) and PosAgg(r) to denote the set of positive atoms and the set of positive aggregate atoms 
from the body of r, respectively. By (cid:12)r, we denote the universal closure of the formula

β1 ∧ · · · ∧ βl ∧ ¬γ1 ∧ · · · ∧ ¬γm → α.

By (cid:12)(cid:11), we denote the formula 

(cid:13)

(cid:12)r.

r∈(cid:11)

The signature of a program (cid:11), denoted by τ ((cid:11)), consists of all constants and predicate symbols occurring in (cid:11). A pred-
icate in a program is said to be intensional if it occurs in the head of some rule in the program, and extensional otherwise. 
We use Pint((cid:11)) to denote the set of all intensional predicates of (cid:11).

Example 5. Consider the following program (cid:11)1 with an aggregate atom

r1 : P (x) ← R1(x),
r2 : P (x) ← P ( y), R2( y, x),
r3 : P (x) ← sum(cid:9) y : P ( y) ∧ R3(x, y)(cid:12) > 3.

Here, sum is an aggregate symbol,  P is intensional and  R1, R2, R3 are extensional. (cid:2)

(5)

(6)

(7)

The stable model semantics of a program is deﬁned by a second-order sentence. We ﬁrst introduce some notations. Let 

P and  Q be two predicates or predicate variables of the same arity. We use  P < Q to denote the formula

∀x(P (x) → Q (x)) ∧ ¬∀x(Q (x) → P (x)).
(cid:3)
1

Let P = P 1 · · · P k and P
(cid:3)
i have the same arity. We use P < P
P

(cid:3) = P

· · · P

(cid:3)

to denote the formula

(cid:3)
k be two tuples of predicates or predicate variables such that for every 1 ≤ i ≤ k,  P i and 

k(cid:8)

i=1

∀x(P i(x) → P

(cid:3)
i(x)) ∧ ¬

k(cid:8)

i=1

∀x(P

(cid:3)
i(x) → P i(x)).

Let (cid:11) be a program such that Pint((cid:11)) = {P 1, . . . , P n}. Let U = U 1 . . . Un be a tuple of new predicates such that each U i
is deﬁned as

(1 ≤ i ≤ n) matches the arity of  P i . Given an atom ρ, ρ∗

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

77

• ρ itself, if ρ is an equality atom or an atom of the form  P (x), where  P is an extensional predicate;
• U i(x), if ρ is an atom of the form  P i(x), where  P i is an intensional predicate;
• (op(cid:9)v : ∃wBd(δ)∗(cid:12) (cid:13) t) ∧ (op(cid:9)v : ∃wBd(δ)(cid:12) (cid:13) t), if ρ is an aggregate atom δ of the form (1), where

Bd(δ)

∗ = Q

∗
1 (y1) ∧ · · · ∧ Q

∗
s (ys) ∧ ¬R1(z1) ∧ · · · ∧ ¬Rt(zt).

Let r be a rule of the form (4) which is not a constraint. We use Body(r)∗

to denote the formula

β

∗
∧ · · · ∧ β
l

∗
1
the universal closure of the formula

∧ ¬γ1 ∧ · · · ∧ ¬γm,

∗

and r

Body(r)

∗
∗ → Head(r)

.

Finally, by SM((cid:11)), we denote the following second-order sentence
(cid:8)

(cid:8)

(cid:12)r ∧ ¬∃U(U < P ∧

r∈(cid:11)

∗

r

r∈(cid:11)\(cid:11)⊥

).

(8)

Deﬁnition 4 (Stable model). Let (cid:11) be a program and AC an aggregate context. A structure A on τ ((cid:11)) is said to be a stable 
model of (cid:11) if A is a model of SM((cid:11)).

For  normal  programs  without  aggregates,  the  deﬁnition  of  SM((cid:11)) is  exactly  the  same  as  those  presented  in  [2] and 
[17].  For  the  stable  model  semantics  of  propositional  programs  with  aggregates,  there  are  several  alternative  deﬁnitions 
[4,8,10,13,16,18,27,30]. The Ferraris’ semantics and the FLP semantics have recently been extended into the ﬁrst-order case 
[4,18,22].  Our  deﬁnition  of  SM((cid:11)) can  be  considered  as  another  ﬁrst-order  extension  of  the  Ferraris’  semantics  [16,18]. 
Nevertheless, if the aggregate atoms only occur in the positive bodies of rules and the bodies of these aggregates contain 
no negative atoms (this is actually the case in many benchmark programs), these two semantics coincide.

Example 6 (Example 5 continued). Consider the aggregate context AC1 in Example 2 and three structures M1, M2, M3 on 
τ ((cid:11)1) such that for i = 1, 2, 3,

Dom(Mi) = {a, b, c, d},
fMi (a) = 1, fMi (b) = 2, fMi (c) = 3, fMi (d) = 4,
Mi
= {aa, ac, db, dc},
R
1

= {aa, bc}, R

= {b}, R

Mi
2

Mi
3

and

M1 = {b, c}, P

M2 = {b, c, d}, P

M3 = {a, b, c, d}.

P

• M1 is not a stable model of (cid:11)1 since it is not a model of (cid:12)r3. To see this, note that M1 |(cid:17) sum(cid:9) y : P ( y) ∧ R3(x, y)[x/d]

and M1 (cid:7)|(cid:17) P (x)[x/d].

(cid:13)

• Both M2 and M3 are models of 
order sentence (8). Indeed, let U
that M3 (cid:7)|(cid:17) ¬∃U (U < P ∧
r∈(cid:11)1

(cid:13)

r∈(cid:11)1

(cid:3) = {b, c, d} ⊂ P
∗).
r

(cid:12)r, but M3 is not a stable model of (cid:11)1, as M3 is not a model of the second-
(cid:3)], so 

M3 . Then, we have M3 |(cid:17) U < P [U /U

(cid:3)] and M3 |(cid:17)

∗[U /U

(cid:13)

r

r∈(cid:11)1

• It can be veriﬁed that M2 is the only stable model of (cid:11)1. Roughly speaking, M2 is obtained as follows:

– P (b) is derived by the fact  R1(b) and the rule r1;
– P (c) is derived by the facts  P (b), R2(b, c) and the rule r3;
– P (d) is derived by the rule r3 by noticing that M3 |(cid:17) sum(cid:9) y : P ( y) ∧ R3(x, y)(cid:12) > 3[x/d];
– P (a) cannot be derived by either r2 or r3 without assuming  P (a) itself. (cid:2)

3.  Ordered completion for normal logic programs with aggregates

Ordered completion, introduced by Asuncion et al. [2] for normal logic program without aggregates, is a modiﬁcation of 
Clark’s completion [7] by adding some auxiliary predicates to capture the derivation order during the program’s evaluation. 
It is showed that, on ﬁnite structures, the stable models of a normal logic program are exactly corresponding to the classical 
models of its ordered completion.

From  a  theoretical  point  of  view,  ordered  completion  makes  an  important  contribution  on  understanding  ﬁrst-order 
answer  set  programming.  Firstly,  it  shows  that  the  stable  model  semantics  can  be  captured  by  Clark’s  completion  plus 
derivation order. Secondly, it clariﬁes the relationship between ﬁrst-order normal ASP and ﬁrst-order logic. More precisely, 

78

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

every normal answer set program can be captured by a ﬁrst-order sentence with some new predicates on ﬁnite structures. 
Interestingly, this result does not hold on arbitrary structures nor if no new predicate symbol is used [2].

In addition, ordered completion is relevant from a practical point of view. It initiates a new direction of developing an 
alternative  ASP  solver  by  ﬁrst  translating  a  normal  logic  program  to  its  ordered  completion,  then  working  on  ﬁnding  a 
model of this ﬁrst-order sentence. A ﬁrst implementation shows that this new approach is promising as it performs good 
on  the  Hamiltonian  Circuit  program  [25],  especially  on  very  large  instances.  However,  ordered  completion  can  hardly  be 
used beyond the Hamiltonian Circuit program because it cannot handle aggregates – a crucial building block widely used in 
many applications in ASP.

Extending  ordered  completion  for  dealing  with  aggregates  is  not  an  easy  task.  First  of  all,  the  aggregate  atoms  in  a 
logic program are highly interacted with the rest parts. Hence, a naive extension of ordered completion by simply treating 
aggregate atoms as extensional atoms would not work.

Another observation is from a computational complexity point of view. In the propositional case, it is shown that check-
ing the existence of stable models of normal program with aggregates is (cid:14) P
2 complete for both the Ferraris’ semantics and 
the  FLP  semantics  [11,16],  which  lies  on  a  higher  complexity  level  than  the  same  task  for  normal  programs  without  ag-
gregates. Together with some well known results in ﬁnite model theory, this probably suggests that, in general, ﬁrst-order 
normal programs with arbitrary aggregates cannot be captured in ﬁrst-order logic with the same type of aggregates at all. 
In this paper, we shall show that this is indeed the case.

Nevertheless, it is also observed that normal programs with some type of aggregate atoms still have the same complexity 
as  normal  programs  without  aggregates  [16].  This  means  that,  simply  from  a  complexity  point  of  view,  it  is  possible  to 
capture this class of programs in ﬁrst-order logic with the same type of aggregate atoms. In fact, two important classes of 
such aggregate atoms are well discussed in the literature [4,13,16,27,31], namely monotone and anti-monotone aggregate 
atoms.

Deﬁnition 5. Let AC be an aggregate context, op ∈ ACag be an aggregate symbol, and (cid:13)∈ ACco a comparison operator. We 
say that op is monotone with respect to (cid:13) if for any two multisets M1, M2 such that M1 ⊆ M2,

• if M1 is in the domain of opAC
• for any n ∈ ACnum, if opAC(M1) (cid:13) n then opAC(M2) (cid:13) n.

, then M2 is also in the domain of opAC

, and

The deﬁnition of anti-monotone is similar, with M1 ⊆ M2 replaced by M2 ⊆ M1.

Consider  aggregate  symbols  card and  sum in  the  aggregate  context  AC1 in  Example 2.  They  are  either  monotone  or 
anti-monotone  with  respect  to  the  comparison  symbols  in  {<, ≤, ≥, >},  but  neither  monotone  nor  anti-monotone  with 
respect to =.

As  we  shall  show  in  the  paper,  normal  logic  programs  with  these  two  types  of  aggregates  can  indeed  be  captured 
in ﬁrst-order logic with the same type of aggregates. However, they are not powerful enough to capture all. For instance, 
a commonly used aggregate is of the form sum(M) = n, which is neither monotone nor anti-monotone, but can be expressed 
as the conjunction of the two monotone and anti-monotone aggregates:  sum(M) > n − 1 and  sum(M) < n + 1. Therefore, 
normal logic programs with the aggregate type sum(M) = n can be expressed in ﬁrst-order logic with this aggregate as well.
Hence,  an  important  task  is  to  draw  a  boundary.  That  is,  does  there  exist  a  class  of  aggregates  such  that  ﬁrst-order 
normal programs with this type of aggregates can always be captured in ﬁrst-order logic with the same type of aggregates, 
while this cannot be done for normal programs with any other aggregates not in this class?

For  this  purpose,  we  extend  Liu  and  Truszczy ´nski’s  notion  of  convex  constraints  [23] to  ﬁrst-order  convex  aggregates 
and show that this is exactly the boundary we need. That is, ﬁrst-order normal logic programs with convex aggregates can 
always be captured in ﬁrst-order logic with the same type of aggregates. On the contrary, for any non-convex aggregates, 
we can always construct a normal program with this aggregate such that it can never be captured in ﬁrst-order logic with 
the same type of aggregates providing some general assumptions in the computational complexity theory.

Deﬁnition 6. Let AC be an aggregate context, op ∈ ACag an aggregate symbol, and (cid:13)∈ ACco a comparison operator. Then, 
op is  convex with  respect  to  (cid:13) if  there  does  not  exist  ﬁnite  multisets  of  tuples  of  the  same  arities4 M1 ⊆ M2 ⊆ M3 and 
n ∈ Z such that opAC(M1) (cid:13) n and opAC(M3) (cid:13) n holds, while opAC(M2) (cid:13) n does not hold.

An aggregate context AC is convex, if for every aggregate symbol op ∈ ACag and comparison operator (cid:13) ∈ ACco, op is 

convex with respect to (cid:13).

Example 7. Consider the aggregate contexts in Example 2.

• AC3 is  non-convex  since  sum is  non-convex  with  respect  to  ≥.  As  an  example,  both  sumAC3 ({ {−1, 1} }) ≥ 0 and 

sumAC3 (∅) ≥ 0 hold, but sumAC3 ({ {−1} }) ≥ 0 does not hold.

4 That is, for any t1, t2 ∈ (M1 ∪ M2 ∪ M3), we have |t1| = |t2|.

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

79

• If  we  restrict  to  non-negative  numbers,  sum is  convex  with  respect  to  ≥,  but  AC2 is  still  non-convex,  since  sum is 
non-convex  with  respect  to  (cid:7)=.  As  an  example,  we  can  see  that  sumAC2 ({ {1, 2} }) (cid:7)= 1 and  sumAC2 (∅) (cid:7)= 1 hold,  while 
sumAC2 ({ {1} }) (cid:7)= 1 does not hold.

• It can be veriﬁed that AC1 is convex. Note that aggregates card and sum are convex with respect to =, though they 

are neither monotone nor anti-monotone. (cid:2)

In fact, both monotone and antimonotone aggregates are subclasses of convex aggregates.

Proposition 1. Let AC be an aggregate context, op ∈ ACag be an aggregate symbol and (cid:13) ∈ ACco a comparison operator. If op is 
(anti)monotone with respect to (cid:13), then op is convex with respect to (cid:13).

Proof. It suﬃces to show that if op is non-convex with respect to (cid:13), then it is neither monotone nor anti-monotone with 
respect to (cid:13).

If op is non-convex with respect to (cid:13), then there exist multisets M1 ⊆ M2 ⊆ M3 and n ∈ Z such that opAC(M1) (cid:13) n and 
opAC(M3) (cid:13) n hold, while opAC(M2) (cid:13) n does not hold. Since  M1 ⊆ M2, opAC(M1) (cid:13) n holds but opAC(M2) (cid:13) n does not 
hold, op is not anti-monotone. Similarly, since  M2 ⊆ M3, opAC(M3) (cid:13) n holds but opAC(M1) (cid:13) n does not hold, then op is 
not monotone. (cid:2)

3.1.  Ordered completion

Now we deﬁne ordered completion for normal logic programs with aggregates. Let σ be a signature. By σ ≤

, we denote 

the signature σ together with the set of new predicates

{≤P Q | P , Q ∈ σ are two intensional predicates},

where  the  arity  of  ≤P Q is  the  sum  of  the  arities  of  P and  Q .5 The  ordered  completion  of  a  program  (cid:11) is  deﬁned  as  a 
formula over the signature τ ((cid:11))≤

.
Let (cid:11) be a program. Then by Trans((cid:11)), we denote the formula

(cid:8)

P ,Q ,R∈Pint((cid:11))

∀xyz(≤P Q (xy)∧ ≤Q R (yz) →≤PR (xz)).

Also, given two predicates  P and  Q , we use  (cid:2)P (x) < Q (y) to denote the formula

≤P Q (xy) ∧ ¬ ≤Q P (yx).

Deﬁnition 7  (Ordered completion with aggregates).  Let  (cid:11) be  a  program.  Then  the  modiﬁed completion of  (cid:11),  denoted  by 
MComp((cid:11)), is the formula

(cid:14)

(cid:12)(cid:11) ∧
(cid:8)
∀x
P ∈Pint((cid:11))

P (x) →

(cid:10)

(cid:15)
∃y

r∈(cid:11)\(cid:11)⊥
Head(r)=P (x)

where

Body(r) ∧ Pos (cid:2)(r) < P (x) ∧ PosAgg (cid:2)(r) < P (x)

(cid:16)(cid:17)
,

(9)

(cid:13)

• (cid:12)(cid:11) is 
(cid:12)r,
• Pos (cid:2)(r) < P (x) is the formula

r∈(cid:11)

(cid:8)

( (cid:2)Q (y) < P (x)),

Q (y)∈Pos(r)\PosAgg(r)
Q ∈Pint((cid:11))
• PosAgg (cid:2)(r) < P (x) is the formula

(cid:8)

(op(cid:9)v : ∃w(Bd(δ) ∧ P (cid:2)s(δ) < P (x))(cid:12) (cid:13) t),

δ∈PosAgg(r)

5 Note that P and Q might be the same predicate.

80

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

in which Ps (cid:2)(δ) < P (x) is a shorthand of

(cid:8)

(Q i

(cid:2)(yi) < P (x)).

1≤i≤s
Q i ∈Pint((cid:11))

Finally, the ordered completion of (cid:11), denoted by OC((cid:11)), is the formula

MComp((cid:11)) ∧ Trans((cid:11)).

Let us take a closer look at Deﬁnition 7. First of all, for non-aggregate atoms in  Body(r), we treat them the same way 
as in the original deﬁnition of ordered completion [2]. That is, for each positive non-aggregate atom in Pos(r), we introduce 
the comparison atoms via the formula Pos (cid:2)(r) < P (x). However, this is not done for negative non-aggregate atoms.

For aggregate atoms occurring in Body(r), similar to non-aggregate atoms, we also distinguish between the negative and 
positive occurrences. For negative occurrences, we also do not introduce the comparison atoms into these aggregates. How-
ever, for positive occurrences, we need to introduce the comparison assertions via PosAgg (cid:2)(r) < P (x), where PosAgg (cid:2)(r) < P (x)
denotes the formula:
(cid:8)

(op(cid:9)v : ∃w(Bd(δ) ∧ P (cid:2)s(δ) < P (x))(cid:12) (cid:13) t),

δ∈PosAgg(r)

which simply introduces the comparison atoms into the positive body  Ps(δ) of each aggregate atom in  PosAgg(r), i.e., via 
the formulas of the form Ps (cid:2)(δ) < P (x). The reason that we introduce the comparison atoms for these positive aggregates is 
that we need to keep track of the derivation order as implied by the stable model semantics.

Example 8 (Example 5 continued). The ordered completion of (cid:11)1, denoted by OC((cid:11)1), is the conjunction of Trans((cid:11)1) and 
the following sentences:

∀x(R1(x) → P (x)),
∀x∀ y(P ( y) ∧ R2( y, x) → P (x)),
∀x(sum(cid:9) y : P ( y) ∧ R3(x, y)(cid:12) > 3 → P (x)),
∀x(P (x) → (R1(x) ∨ ∃ y(P ( y) ∧ R2( y, x) ∧ (cid:2)P ( y) < P (x)) ∨
(sum(cid:9) y : P ( y) ∧ R3(x, y)(cid:12) > 3 ∧

sum(cid:9) y : P ( y) ∧ R3(x, y) ∧ (cid:2)P ( y) < P (x)(cid:12) > 3))).

(10)

(11)

(12)

(13)

Now consider again the aggregate context AC1 in Example 2 and the structures M1, M2, M3 in Example 6.

• M1 is not a model of (12). So it cannot be expanded to a model of OC((cid:11)1).
• Both M2 and M3 are models of (10)–(12).
• Let M(cid:3)

2 be a structure expanded from M2 by the additional interpretation for ≤P P :
M(cid:3)
2
P P

= {bc, bd, cd}.

≤

It can be veriﬁed that

M(cid:3)
2
M(cid:3)
2
M(cid:3)
2
M(cid:3)
2

|(cid:17) Trans((cid:11)1),
|(cid:17) R1(x)[x/b],
|(cid:17) P ( y) ∧ R2( y, x) ∧ (cid:2)P ( y) < P (x)[xy/bc],
|(cid:17) sum(cid:9) y : P ( y) ∧ R3(x, y)(cid:12) > 3 ∧

sum(cid:9) y : P ( y) ∧ R3(x, y) ∧ (cid:2)P ( y) < P (x)(cid:12) > 3[x/d].

So, M(cid:3)
• Let M(cid:3)
we have

2 is a model of OC((cid:11)1).
3 be a model of Trans((cid:11)1) expanded from M3. Now we show that M(cid:3)

3 is not a model of OC((cid:11)1). Indeed, since 

M(cid:3)
3

(cid:7)|(cid:17) (cid:2)P ( y) < P (x)[xy/aa],

we also have

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

81

M(cid:3)
3
M(cid:3)
3

(cid:7)|(cid:17) P ( y) ∧ R2( y, x) ∧ (cid:2)P ( y) < P (x)[xy/aa],
(cid:7)|(cid:17) sum(cid:9) y : P ( y) ∧ R3(x, y) ∧ (cid:2)P ( y) < P (x)(cid:12) > 3[x/a].

Therefore, M(cid:3)

3 is not a model of (13). (cid:2)

In general, we have the following theorem.

Theorem 1 (Main theorem). Let AC be a convex aggregate context, (cid:11) a program and A a ﬁnite structure of τ ((cid:11)). Then, A is a stable 
model of (cid:11) on AC if and only if A can be expanded to a model of OC((cid:11)).

3.2.  The proof of Theorem 1

To prove Theorem 1, we need to use the notion of externally supported set [6]. Roughly speaking, a set of ground atoms 
is externally supported if there exists a ground atom in the set and an associated rule that supports the atom (i.e., the atom 
is the head of the ground rule) and whose positive body could be satisﬁed by external ground atoms (i.e., ground atoms 
not in this set). Then, we provide a lemma showing that a structure is a stable model of a program if and only if it is a 
model of the program and every subset of ground atoms included in this structure is externally supported. Then based on 
this lemma, we ﬁnally give the proof of the main theorem.

Let (cid:11) be a program and A a structure of signature σ such that τ ((cid:11)) ⊆ σ . Then a ground atom is an expression of the 
, we denote 

form  P (a), where  P is a predicate and a is a tuple of domain elements matching the arity of  P . By [Pint((cid:11))]A
the set of ground atoms {P (a) | a ∈ P

A, P ∈ Pint((cid:11))}.

Deﬁnition 8  (Externally supported set).  Let  AC be  an  aggregate  context,  (cid:11) a  program,  and  A a  structure  of  σ such  that 
τ ((cid:11)) ⊆ σ .  A  set  of  ground  atoms  S ⊆ [Pint((cid:11))]A
is  externally supported (under  AC,  (cid:11),  and  A)  if  there  exists  a  ground 
atom  P (a) ∈ S and a rule r of the form  P (x) ← Body(r) with local variables yr , such that for some assignment of the form 
xyr/abr ,

• A |(cid:17) Body(r)[xyr/abr];
• (Pos(r) \ PosAgg(r))[xyr/abr] ∩ S = ∅;
• For all aggregate atoms δ ∈ PosAgg(r) of the form (1),

opAC({{ fA(cv ) | A |(cid:17) Bd(δ)[α], Ps(δ)[α] ∩ S = ∅}}) (cid:13) fA(t[xyr/abr]),

where α is the assignment of the form xyr wv/abr cw cv , and cw and cv are tuples of domain elements.

Lemma 1. 6 Let AC be an aggregate context, (cid:11) a program, and A a structure of τ ((cid:11)). Then, A is a stable model of (cid:11) if and only if 
A |(cid:17) (cid:12)(cid:11) and every S ⊆ [Pint((cid:11))]A

is externally supported.

Proof. Suppose that Pint((cid:11)) = {P 1, . . . , P n}. Let U = {U 1, . . . , Un} be a set of new predicates such that for each 1 ≤ i ≤ n, U i
has the same arity of  P i .

(⇒) Since A |(cid:17) SM((cid:11)), we have A |(cid:17) (cid:12)(cid:11). It suﬃces to show that every set  S ⊆ [Pint((cid:11))]A

is externally supported. We 
that is not externally supported. We construct a 

prove this by contradiction. Assume that there exists a set  S ⊆ [Pint((cid:11))]A
structure U of τ ((cid:11)) ∪ U as follows:

• Dom(U ) = Dom(A) and  fU and  fA are identical;
for each constant c ∈ τ ((cid:11));
• c
• P
for each predicate  P ∈ τ ((cid:11));
\ {a |  P i(a) ∈ S} for 1 ≤ i ≤ n.
• U

U = c
A
U = P
U
= P
i

A
i

A

Clearly,  U |(cid:17) U < Pint((cid:11)).  Since  A |(cid:17) SM((cid:11)),  there  exists  a  rule  r of  the  form  (4) and  an  assignment  xyr/abr such  that 
∗[xyr/abr].  Then,  we  have  U |(cid:17) Body(r)∗[xyr/abr] and  U (cid:7)|(cid:17) Head(r)∗[xyr/abr].  It  follows  A |(cid:17) Body(r)[xyr/abr] and 
U (cid:7)|(cid:17) r
A |(cid:17) Head(r)[xyr/abr]. So, Head(r)[xyr/abr] ∈ S.

As we assume that  S is not externally supported, by Deﬁnition 8, we have

(1) either there exists an atom β ∈ Pos(r) \ PosAgg(r) such that β[xyr/abr] ∈ S,
(2) or there exists an aggregate atom δ of the form (1) such that

6 Note that this lemma holds without the assumption of convex aggregate contexts.

82

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

O P

AC({{ fA(cv ) | A |(cid:17) Bd(δ)[xyrwv/abr cw cv ],

P s(δ)[xyr wv/abr cw cv ] ∩ S = ∅,
|w|
, c v ∈ Dom(A)
c w ∈ Dom(A)

|v|}}) (cid:13) fA(t[xyr/abr])

does not hold.

In both cases, we will show that U (cid:7)|(cid:17) Body(r)∗[xyr/abr], which is a contradiction.

(1) We already have β[xyr/abr] ∈ S, so U (cid:7)|(cid:17) β∗[xyr/abr]. It follows U (cid:7)|(cid:17) Body(r)∗[xyr/abr].
(2) By the construction of U , for every cw ∈ Dom(A)|w|

and cv ∈ Dom(A)|v|

,

U |(cid:17) Bd(δ)

∗[xyr wv/abrcw cv ]

if and only if

A |(cid:17) Bd(δ)[xyr wv/abr cw cv ] and Ps(δ)[xyr wv/abr cw cv ] ∩ S = ∅.

Therefore,

{{ fU (cv ) | U |(cid:17) Bd(δ)

, cv ∈ Dom(A)
= {{ fA(cv ) | A |(cid:17) Bd(δ)[xyr wv/abr cw cv ], Ps(δ)[xyr wv/abr cw cv ] ∩ S = ∅,

∗[xyr wv/abr cw cv ], cw ∈ Dom(A)

|w|

|v|}}

cw ∈ Dom(A)

|w|

, cv ∈ Dom(A)

|v|}}.

By (14), we have that

opAC({{ fU (cv ) | U |(cid:17) Bd(δ)
cw ∈ Dom(A)

∗[xyr wv/abr cw cv ],
|w|
, cv ∈ Dom(A)

|v|}}) (cid:13) fU (t[xyr/abr])

does not hold. Therefore,

U (cid:7)|(cid:17) (op(cid:9)v : ∃wBd(δ)
and U (cid:7)|(cid:17) Body(r)∗[xyr/abr].

∗(cid:12) (cid:13) t)[xyr/abr],

(14)

(15)

(⇐) Since A |(cid:17) (cid:12)(cid:11), it suﬃces to show that

A |(cid:17) ¬∃U(U < Pint((cid:11)) ∧

(cid:8)

∗

r

).

r∈(cid:11)\(cid:11)⊥

(cid:8)

Again, we prove this by contradiction. Otherwise, let U be a structure of τ ((cid:11)) ∪ U such that U is an expansion of A and

U |(cid:17) U < Pint((cid:11)) ∧

∗

.

r

(16)

r∈(cid:11)\(cid:11)⊥

\ U
Let  S = {P (a)  |  a ∈ P
the form (4) and an assignment xyr/abr such that

A
i

U
i , P i ∈ Pint((cid:11))}. By (16),  S is not empty. Since  S is externally supported, there exist a rule r of 

• Head(r)[xyr/abr] ∈ S and A |(cid:17) Body(r)[xyr/abr];
• (Pos(r) \ PosAgg(r))[xyr/abr] ∩ S = ∅;
• For all aggregate atoms δ ∈ PosAgg(r) of the form (1),

opAC({{ fA(cv ) | A |(cid:17) Bd(δ)[xyr wv/abr cw cv ], P s(δ)[xyr wv/abr cw cv ] ∩ S = ∅,
, cv ∈ Dom(A)

|v|}}) (cid:13) fA(t[xyr/abr]).

cw ∈ Dom(A)

|w|

(17)

By the construction of U , we have U |(cid:17) Body(r)∗[xyr/abr] since

• for negative atoms, U |(cid:17) ¬γ j[xyr/abr], (1 ≤ j ≤ m);
• for positive non-aggregate atoms β ∈ Pos(r) \ PosAgg(r), U |(cid:17) β∗[xyr/abr];
• for positive aggregate atoms δ ∈ PosAgg(r),

opAC({{ fU (cv ) | U |(cid:17) Bd(δ)[xyr wv/abr cw cv ],
cw ∈ Dom(A)

, cv ∈ Dom(A)

|w|

|v|}}) (cid:13) fU (t[xyr wv/abr cw cv ])

and

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

83

opAC({{ fU (cv ) | U |(cid:17) Bd(δ)

∗[xyr wv/abr cw cv ],
, cv ∈ Dom(A)

|w|

cw ∈ Dom(A)

|v|}}) (cid:13) fU (t[xyr/abr]).

We  also  have  that  U (cid:7)|(cid:17) Head(r)∗[xyr/abr].  This  is  a  contradiction  since  U |(cid:17) r
proof. (cid:2)

∗[xyr/abr] by  (16).  This  completes  our 

Now, we are ready to prove our main theorem.

Proof. (⇒) By Lemma 1, for every set  S ⊆ [Pint((cid:11))]A
by lm, from the set of ground atoms [Pint((cid:11))]A

,  S is externally supported. We ﬁrst deﬁne a level mapping, denoted 

to the numbers. Consider the following procedure:

(I) Let i = 0, and T = [Pint((cid:11))]A
(II) If  T = ∅,  then  quit.  Otherwise,  T is  externally  supported,  so  there  exist  a  ground  atom  P (a) ∈ T and  a  rule  r of  the 

be the set of atoms whose levels are still undeﬁned.

form  P (x) ← Body(r) with local variables yr , such that for some assignment of the form xyr /abr ,
– A |(cid:17) Body(r)[xyr/abr];
– (Pos(r) \ PosAgg(r))[xyr/abr] ∩ S = ∅;
– For all aggregate atoms δ ∈ PosAgg(r) of the form (1),

opAC({{ fA(cv ) | A |(cid:17) Bd(δ)[α], Ps(δ)[α] ∩ T = ∅}}) (cid:13) fA(t[xyr/abr]),

where α is the assignment of the form xyr wv/abr cw cv , and cw and cv are tuples of domain elements.

(III) Let lm(P (a)) = i, i = i + 1, and T = T \ {P (a)}.
(IV) Go back to (II).

S is ﬁnite, so the procedure deﬁned above always terminates when T = ∅. Based on this ranking, we expand A to A(cid:3)
signature τ ((cid:11)) ∪ σ≤ such that

of the 

≤A(cid:3)
P Q

= {ab | lm(P (a)) ≤ lm(Q (b))},

where  P , Q ∈ Pint((cid:11)). Now it remains to show that A(cid:3) |(cid:17) OC((cid:11)). By the deﬁnition of A(cid:3)
suﬃces to show that for every  P (a) ∈ [Pint((cid:11))]A
and an assignment of the form xyr /abr such that  P (a) = Head(r)[xyr/abr], and

, we have A(cid:3) |(cid:17) (cid:12)(cid:11) ∧ Trans((cid:11)). It 
, there exist a rule r of the form  P (x) ← Body(r) with local variables  yr

A(cid:3) |(cid:17) P (x) →

(cid:18)

(cid:19)
Body(r) ∧ Pos (cid:2)(r) < P (x) ∧ PosAgg (cid:2)(r) < P (x)

[xyr/abr].

Actually, the rule r and the assignment xyr /abr in (II) in the procedure are exactly what we need.

(⇐)  Since  A(cid:3) |(cid:17) OC((cid:11)),  then  A(cid:3) |(cid:17) (cid:12)(cid:11).  Therefore,  the  reduct  of  A(cid:3)
comparison  predicates.  It  remains  to  show  that  for  all  S ⊆ [Pint((cid:11))]A(cid:3)
S ⊆ [Pint((cid:11))]A(cid:3)

on  τ ((cid:11)) is  a  model  of  (cid:12)(cid:11) since  (cid:12)(cid:11) mentions  no 
,  S is  externally  supported.  Otherwise,  there  exists 

that is not externally supported. In the following, we will construct an inﬁnite sequence of ground atoms:

P 1(a1), . . . , P i(ai), . . .

such that

(i) P i(ai) ∈ S, i ≥ 1;
(ii) A(cid:3) |(cid:17)≤P i+1 P i (ai+1ai) ∧ ¬ ≤P i P i+1 (aiai+1), i ≥ 1;
(iii) P i(ai) (cid:7)= P j(a j), i (cid:7)= j.

This  is  a  contradiction  since  S is  ﬁnite.  By  A(cid:3) |(cid:17) Trans((cid:11)),  we  only  need  to  consider  (i)  and  (ii),  since  (iii)  is  a  conse-
quence  of  (ii).  We  construct  the  sequence  by  induction.  Assume  that  P 1(a1) is  a  ground  atom  in  S.  If  we  already  have 
P 1(a1), . . . , P i(ai),  we  will  ﬁnd  P i+1(ai+1) as  follows.  Since  A(cid:3) |(cid:17) P i(ai) and  A(cid:3)
is  a  model  of  OC((cid:11)),  there  exists  a  rule 
P i(x) ← Body(r) with local variables yr and an assignment xyr/aibr such that
A(cid:3) |(cid:17) Body(r) ∧ Pos (cid:2)(r) < P (x) ∧ PosAgg (cid:2)(r) < P (x)[xyr/aibr].

(18)

By assumption,  S is not externally supported. Consider the rule r and the assignment xyr/aibr ,

• either there is an atom β ∈ Pos(r) \ PosAgg(r) such that β[xyr/aibr] ∈ S,
• or there is an aggregate atom δ of the form (1) such that

opAC(M1) (cid:13) fA(t[xyr/aibr]) does not holds,

where

(19)

(21)

(22)

(23)

84

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

M1 = {{ fA(cv ) | A |(cid:17) Bd(δ)[xyrwv/aibr cw cv ],

Ps(δ)[xyrwv/aibr cw cv ] ∩ S = ∅,
|w|
cw ∈ Dom(A)

, cv ∈ Dom(A)

|v|}}.

(20)

For the ﬁrst case, let  P i+1(ai+1) = β[xyr/aibr]. Then, (i) holds trivially, and (ii) holds by (18). For the second case, let  M2
and M3 be the multisets such that

M2 = {{ fA(cv ) | A |(cid:17) Bd(δ)[xyr wv/aibr cw cv ]
cw ∈ Dom(A)

, cv ∈ Dom(A)

|w|

|v|}},

M3 = {{ fA(cv ) | A |(cid:17) Bd(δ) ∧ P (cid:2)s(δ) < P (x)[xyr wv/aibr cw cv ],
|w|

cw ∈ Dom(A)

, cv ∈ Dom(A)

|v|}}.

By (18), we have

opAC(M2) (cid:13) fA(t[xyr/aibr])
opAC(M3) (cid:13) fA(t[xyr/aibr])

(24)
By (20), (21) and (22), we have M1 ⊆ M2 and M3 ⊆ M2. Since AC is a convex aggregate context, we have M3 (cid:3) M1 by (19), 
x) ∧ ¬ ≤P Q
(23) and  (24).  So,  there  exists  an  atom  Q (x
(cid:3))[xyr wv/aibr cw cv ]. Let  P i+1(xi+1) = Q (x
(xx
This completes the proof. (cid:2)

(cid:3)) ∈ Ps(δ) such  that  Q (x
(cid:3))[xyr wv/aibr cw cv ]. It can be veriﬁed that both (i) and (ii) hold.

(cid:3))[xyr wv/aibr cw cv ] ∈ S and  A(cid:3) |(cid:17)≤Q P (x

(cid:3)

3.3.  A negative result on non-convex aggregates

Theorem 1 shows that the stable models of a normal program with convex aggregates can be captured by its ordered 

completion. However, this result does not hold for non-convex aggregates. Consider the following example.

Example 9. Let (cid:11)2 be the following program with a single rule:

r1 : P (x) ← sum(cid:9) y : P ( y) ∧ R1(x, y, z)(cid:12) (cid:7)= z, R2(x, z).

Here,  P is the only intensional predicate and  R1, R2 are extensional predicates. Now let M be a structure on τ ((cid:11)2) such 
that

R

Dom(M) = {a, b, c},
fM(a) = 2, fM(b) = 3, fM(c) = 4,
M
1
M
2
M = {a, b}.
In addition, let M(cid:3)

= {aab, abb, aac, abc, baa, bba, caa, cca},
= {ab, ac, ba, ca},

be a τ ((cid:11)2)≤

R

P

-structure expanded from M such that

≤P P = {ba}.

We now show that, under the non-convex aggregate context AC2 in Example 2, M(cid:3)
stable model of (cid:11)2.

On the one side, OC((cid:11)2) is the conjunction of Trans((cid:11)2) and the following sentences:

is a model of OC((cid:11)2) but M is not a 

∀x∀z(R2(x, z) ∧ sum(cid:9) y : P ( y) ∧ R1(x, y, z)(cid:12) (cid:7)= z → P (x)),
∀x(P (x) → ∃z(R2(x, z) ∧ sum(cid:9) y : P ( y) ∧ R1(x, y, z)(cid:12) (cid:7)= z

∧ sum(cid:9) y : P ( y) ∧ R1(x, y, z) ∧ (cid:2)P ( y) < P (x)(cid:12) (cid:7)= z))

It is obvious that M(cid:3) |(cid:17) Trans((cid:11)2). To show M(cid:3)

is a model of (25), it suﬃces to verify that

(25)

(26)

M(cid:3) |(cid:17) sum(cid:9) y : P ( y) ∧ R1(x, y, z)(cid:12) (cid:7)= z[xz/ab],
M(cid:3) |(cid:17) sum(cid:9) y : P ( y) ∧ R1(x, y, z)(cid:12) (cid:7)= z[xz/ac],
M(cid:3) |(cid:17) sum(cid:9) y : P ( y) ∧ R1(x, y, z)(cid:12) (cid:7)= z[xz/ba],
M(cid:3) |(cid:17) sum(cid:9) y : P ( y) ∧ R1(x, y, z)(cid:12) (cid:7)= z[xz/ca].

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

85

To show M(cid:3)

is a model of (26), it suﬃces to verify that

M(cid:3) |(cid:17) sum(cid:9) y : P ( y) ∧ R1(x, y, z)(cid:12) (cid:7)= z

∧ sum(cid:9) y : P ( y) ∧ R1(x, y, z) ∧ (cid:2)P ( y) < P (x)(cid:12) (cid:7)= z[xz/ba],

M(cid:3) |(cid:17) sum(cid:9) y : P ( y) ∧ R1(x, y, z)(cid:12) (cid:7)= z

∧ sum(cid:9) y : P ( y) ∧ R1(x, y, z) ∧ (cid:2)P ( y) < P (x)(cid:12) (cid:7)= z[xz/ac].

On the other side, to show that M is not a stable of (cid:11)2, it suﬃces to show that M is not a model of (8). Indeed, let 
∗
(cid:3) = {a} ⊂ P
1

(cid:3)]. Hence, M (cid:7)|(cid:17) ¬∃U (U < P ∧ r

. Then we have M |(cid:17) U < P [U /U

(cid:3)] and M |(cid:17) r

∗
1). (cid:2)

[U /U

M

U

In fact, convex aggregate is a maximal subclass for this task. That is, for any given non-convex aggregate context, we can 
always construct a normal program with these aggregates such that it can never be captured in ﬁrst-order logic with the 
same type of aggregates, providing some general assumptions in the complexity theory. Actually, we can prove a stronger 
result that normal programs under any given non-convex aggregate context are able to capture the full expressive power of 
disjunctive programs (without aggregates).

First of all, we introduce some background. A disjunctive program with aggregates (or disjunctive program) is a ﬁnite set of 

disjunctive rules of the form

(cid:10)

α1; . . . ; αk ← β1, . . . , βl, not γ1, . . . , not γm,

(27)
where αi (1 ≤ i ≤ k)  are  standard  atoms,  βi (1 ≤ i ≤ l),  and γ j (1 ≤ j ≤ m)  are  atoms.  The  stable  models  of  a  disjunctive 
program are deﬁned as the models of  SM((cid:11)), where  SM((cid:11)) is the same as (8) except that for a disjunctive rule r of the 
form (27), r

is the universal closure of the formula

∗

Body(r)

∗ →

α∗
i .

(28)

1≤i≤k

Our negative result is inspired by Ferraris’ work [16]. In order to obtain the complexity results for propositional normal 

programs with arbitrary aggregate atom, Ferraris proved the following two facts:

(Fact 1) Every propositional disjunctive rule of the form

a1; . . . ; ak ← b1, . . . , bl, not c1, . . . , not cm

can be equivalently transformed into a set of rules with implications in the bodies as follows

a1 ← (a1 → a1), . . . , (ak → a1), b1, . . . , bl, not c1, . . . , not cm
a2 ← (a1 → a2), . . . , (ak → a2), b1, . . . , bl, not c1, . . . , not cm
...
...
ak ← (a1 → ak), . . . , (ak → ak), b1, . . . , bl, not c1, . . . , not cm

...

(Fact 2) An implication  p → q is strongly equivalent to the following aggregate atom

sum(cid:9)p = −1, q = 1(cid:12) ≥ 0,

(29)

(30)

where  two  expressions  are  said  to  be  strongly  equivalent  in  Answer  Set  Programming  if  replacing  one  by  another  in  any 
logic program does not change the answer sets.

Therefore, any propositional disjunctive program without aggregate atom can be equivalently transformed into a propo-
sitional  normal  program  with  aggregates  similar  to  (30).  As  a  consequence,  the  complexity  of  checking  the  existence  of 
answer sets of propositional normal program with arbitrary aggregate atom is (cid:14) P
2 -complete, which is higher than that of 
normal program with monotone and antimonotone aggregate atom (NP-complete).

We extend Ferraris’ result in an essential way in the sense that the above procedure can be applied for every non-convex 
aggregate context. That is, given any non-convex aggregate context, we can use it to simulate implications, thus to simulate 
disjunctive rules. The full proof of this result in the ﬁrst-order case is rather technical and tedious. We provide a sketch of 
the proof here, and leave the very long detailed full proof in Appendix A.

Lemma 2. Let AC be a polynomial and non-convex aggregate context. Then, on ﬁnite structures, every disjunctive program (cid:15)D without 
aggregates can be polynomially translated into a normal program (cid:15)N with some aggregates from AC.

Proof (Sketch). First,  since  AC is  a  non-convex  aggregate  context,  there  exist  three  multisets  M1, M2, M3 such  that 
op(M1) (cid:13) N and  op(M3) (cid:13) N hold  while  op(M1) (cid:13) N does  not  hold,  where  op ∈ ACag is  an  aggregate  symbol,  (cid:13)∈ ACop
is a comparison operator, and N ∈ ACnum is a number. Let

86

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

• M1 = { {m1, . . . , mN1
• M2 \ M1 = { {mN1+1, . . . , mN2
• M3 \ M2 = { {mN2+1, . . . , mN3

} };

} };
} },

where N1, N2, N3 are the sizes of M1, M2, M3 respectively, and 0 ≤ N1 < N2 < N3.

Then, we introduce some new predicates and constants to build the program (cid:15)N . Let  Q D1, . . . Q D N3 be  N3 new predi-
cates. The program (cid:15)N contains some rules and constraints such that if M is a stable model of (cid:15)N , then M |(cid:17) Q D i(di), if 
) = mi , where di (1 ≤ i ≤ N3) is a tuple of new constants. In addition, let  Q M1, Q M2, Q M3 be three 
and only if  fM(d
new predicates. With the help of  Q D1, . . . Q D N3 , the program (cid:15)N is built such that if M is a stable model of (cid:15)N , then

M
i

M |(cid:17) op(cid:9)x : Q M1(x)(cid:12) (cid:13) cn
M (cid:7)|(cid:17) op(cid:9)x : Q M2(x)(cid:12) (cid:13) cn
M |(cid:17) op(cid:9)x : Q M3(x)(cid:12) (cid:13) cn,

where cn is a new constant for N. Note that such M does not exist if the aggregate context is convex.

Furthermore,  for  every  rule  r of  the  form  (27) and  two  atoms  P i(vi), P j(v j) (1 ≤ i, j ≤ k)  in  Head(r),  a  new  predicate 
Q r,i, j is introduced. With some carefully deﬁned rules and constraints in (cid:15)N and the new predicates introduced above, the 
aggregate  op(cid:9)x : Q r,i, j(x, vi, v j)(cid:12) (cid:13) cn behaves  exactly  the  same  as  the  implication  P j(vi) → P i(vi).  This  is  similar  to  the 
(Fact 2) in Ferraris’ work [16].

Now, we present the main idea of the translation. The normal program with aggregates (cid:15)N has three parts of the rules:

(cid:15)N = AGG ∪ DEF ∪ CST,

where AGG is a set of normal rules with aggregates which could simulate the disjunctive rules, and DEF and CST are sets 
of rules to deﬁne the new predicates.
⊥

be a rule of the form (27). Then, r is translated into k rules in (cid:15)N of the form:

Let r ∈ (cid:15)D \ (cid:15)D

αi ← β1, . . . , βl, not γ1, . . . , not γm,
op(cid:9)x : Q r,i,1(x, vi, v1)(cid:12) (cid:13) cn,
. . . ,
op(cid:9)x : Q r,i,k(x, vi, vk)(cid:12) (cid:13) cn,
NotLitsNew(Var(r)),

where:

(31)

• 1 ≤ i ≤ k, and k is the number of atoms in the head of r,
• P 1(v1), . . . , P k(vk) are atoms in the head of r,
• x is a tuple of distinct new variables,
• NotLitsNew(Var(r)) denotes the set of negative atoms of the form  not x = c, where  x is a variable in r and  c is a new 

constant not in τ ((cid:15)D ).

Intuitively, the rules deﬁned above play the same roles in ﬁrst-order case as those rules (29) do in the propositional case. 
This is similar to (Fact 1) in Ferraris’ work [16].

Finally, we show that a structure MD on τ ((cid:15)D ) is a stable model of (cid:15)D if and only if there is a structure MN on τ ((cid:15)N )
such  that MN is  a  stable  model  of  (cid:15)N ,  where MD and MN agree  on  all  interpretations  of  predicates  and  constants  in 
τ ((cid:15)D ). (cid:2)

Our  negative  result  follows  from  Lemma 2 since  disjunctive  programs  without  aggregates  can  capture  the  complexity 

class (cid:14) P

2 [9] but ﬁrst-order logic with new predicates can only capture the complexity class NP [15].

Theorem 2. Let AC be a polynomial and non-convex aggregate context. Then, there exists a normal program with aggregates (cid:11) such 
that it cannot be translated into any ﬁrst-order sentences (with extra predicates) on ﬁnite structures with the aggregate context AC
unless NP = coNP.

Proof. By Lemma 2, the following program (cid:11)3-uncolor
be translated into a normal program with aggregates (cid:11)3-uncolor

D

:

N

(a disjunctive program without aggregates) for 3-uncolorability can 

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

87

R(x); G(x); B(x) ←,

NC ← E(x, y), R(x), R( y),
NC ← E(x, y), G(x), G( y),
NC ← E(x, y), B(x), B( y),

R(x) ← NC,
G(x) ← NC,
B(x) ← NC,

NC ← not NC.

Assume that NP (cid:7)= coNP. As 3-uncolorability is a coNP-complete problem, by Fagin’s theorem [15], it cannot be captured 
in  existential  second-order  logic  on  ﬁnite  structures.  Note  that  adding  polynomial  aggregate  atoms  into  ﬁrst-order  logic 
(existential  second-order  logic)  does  not  increase  the  expressive  power  in  ﬁnite  model  theory.  So  3-uncolorability  cannot 
be  captured  in  existential  second-order  logic  with  polynomial  aggregates  either.  Hence,  it  cannot  be  translated  into  any 
ﬁrst-order sentences (with extra predicates) on ﬁnite structures with the polynomial aggregate context AC. (cid:2)

4.  Implementation and experimental results

Based on Theorem 1, we have implemented a new system, called GROCv2 (GRounder on Ordered Completion Version 2), 
for computing answer sets of ﬁrst-order normal logic programs with convex aggregates. This work is an extension of the 
prototype implementation GROC [2], which can only handle normal programs without aggregates.

Following  the  basic  ideas  of  GROC,  GROCv2  computes  the  answer  sets  of  a  normal  program  with  convex  aggregates 

together with an extensional database as follows.

1. First, GROCv2 translates the program into its enhanced ordered completion (see Deﬁnition 7).
2. Then,  GROCv2  grounds  the  ordered  completion  into  propositional  theories  (with  modular  theories  for  dealing  with 

comparison predicates) based on the extensional database.

3. Finally, GROCv2 calls an SMT solver to compute a classical model of the propositional theories, which is corresponding 

to an answer set of the original program with the extensional database according to Theorem 1.

Note that this is signiﬁcantly different from traditional ASP solvers that ground the logic programs directly into propo-
sitional programs. There are several potential beneﬁts. First of all, the classical ﬁrst-order semantics is much simpler than 
the  stable  model  semantics.  Therefore,  more  solving  techniques,  e.g.  heuristic  methods  and  simpliﬁcation  techniques,  can 
be  applied.  Secondly,  the  results  of  grounding  in  GROCv2  are  propositional  theories,  which  can  normally  be  solved  more 
easily than propositional programs. Thirdly, Step 1 is a polynomial translation and it can be done oﬄine. Moreover, some 
traditional techniques might be used here to simplify the ﬁrst-order formula. Finally, Step 3 calls an SMT solver, which is 
used as a black box. Hence, it can be improved by new advances in the SAT/SMT community.

The  main  disadvantage  of  GROCv2  is  that  a  number  of  new  predicates  (namely  the  comparison  predicates)  are  intro-
duced, which would potentially result in a bigger grounding theory. In principle, this is certainly the case. That is, ordered 
completion needs to introduce n2 number of new predicates, where n is the number of intensional predicates in the pro-
gram. However, in practice, the actual cost is not that much for many benchmark problems. One reason is that we only need 
to introduce the comparison predicates for those predicates in the same strongly connected component in the predicate de-
pendency  graph.  This  will  signiﬁcantly  reduce  the  number  of  new  predicates  introduced.  For  instance,  for  the  traveling 
salesman problem, we only need to introduce 1 (instead of 9) comparison predicate.

Also, note that we use SMT solvers in Step 3 instead of SAT solvers in GROCv2. The only reason is that SMT solvers are 

more eﬃcient for dealing with comparison atoms and aggregates. In principle, one can use a SAT solver instead.

The key part of GROCv2 is Step 2 – the grounder that transforms the ordered completion together with an extensional 
database  into  propositional  theories  (with  modular  theories  and  aggregates).  For  this  purpose,  we  ﬁrst  introduce  some 
background about propositional SMT (Satisﬁability Modulo Theories) with aggregates. In general, propositional SMT formulas 
are  classical  propositional  formulas  enhanced  with  a  modular  theory  to  express  some  components  that  cannot  be  easily 
handled  in  propositional  logic,  for  instance  3x + y ≤ 10.  However,  for  dealing  with  comparison  atoms  mentioned  in  this 
paper, we only need a simple modular theory to compare the values of two numbers mapped from propositional atoms.

Deﬁnition 9. Let D be a set of propositional atoms. A propositional SMT formula with aggregates (or SMT formula for short) on 
D is deﬁned as

φ ::= (cid:27) | α | (α1, α2)< | op(cid:9)c1 : φ1, · · · , ck : φk(cid:12) (cid:13) c |

φ1 ∧ φ2 | ¬φ1,

(32)
where α, α1, α2 ∈ D, op ∈ AG is an aggregate symbol, (cid:13) ∈ CO is a comparison symbol, c1, . . . , ck ∈ Z are integer constants, 
and φ1, . . . , φk are SMT formulas.

88

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

The semantics of SMT formulas is similar to that of propositional formulas. Let  I ⊆ D be a set of propositional atoms, 
and  F a function from D to Z. Given an aggregate context AC, the satisfaction relation between a pair (I, F ) and an SMT 
formula φ, denoted by (I, F ) |(cid:17)AC φ (or simply (I, F ) |(cid:17) φ if AC is clear from the context), is deﬁned as:

• (I, F ) |(cid:17)AC (cid:27);
• (I, F ) |(cid:17)AC α, if α is an atom and α ∈ I ;
• (I, F ) |(cid:17)AC (α1, α2)<, if  F (α1) < F (α2);
• (I, F ) |(cid:17)AC op(cid:9)c1 : φ1, . . . , ck : φk(cid:12) (cid:13) c, if op ∈ ACag, (cid:13)∈ ACco, M is in the domain of opAC

and opAC(M) (cid:13) c, where

M = {{ci | (I, F ) |(cid:17)AC φi, (1 ≤ i ≤ k}});
• (I, F ) |(cid:17)AC φ1 ∧ φ2, if (I, F ) |(cid:17)AC φ1 and (I, F ) |(cid:17)AC φ2;
• (I, F ) |(cid:17)AC ¬φ1, if it is not the case that (I, F ) |(cid:17)AC φ1.

A set of propositional atoms  I ⊆ D is a model of φ if there exists a function  F from D to Z such that (I, F ) |(cid:17) φ.

Now, we are able to ground a ﬁrst-order formula with aggregates into SMT formulas deﬁned above under a given domain. 
is a subset of 

be two signatures such that they contain the same constants and the set of predicates in σ (cid:3)

Let σ and σ (cid:3)
that in σ . Let A be a structure on σ (cid:3)

. By DA, we denote the set

DA = {P (a) | P ∈ Pint, a ∈ Dom(A)n, where n is the arity of P }.

Let (cid:16) be a ﬁrst-order formula with aggregates on σ ≤
x/a with respect to A, denoted by GRA((cid:16), y/a), is an SMT formula deﬁned recursively as follows:

, and y/a an assignment such that free((cid:16)) ⊆ y. The grounding of (cid:16) on 

• (cid:27),  if  (cid:16) = α is  either  an  equality  atom  or  a  standard  atom  of  the  form  P (t) such  that  P is  a  predicate  in  σ (cid:3)

• ¬(cid:27),  if  (cid:16) = α is  either  an  equality  atom  or  a  standard  atom  of  the  form  P (t) such  that  P is  a  predicate  in  σ (cid:3)

A |(cid:17) α[y/a];

A (cid:7)|(cid:17) α[y/a];

• P (t)[y/a], if (cid:16) = P (t) is a standard atom such that  P is a predicate in σ but not in σ (cid:3)
• (P (t1)[y/a], Q (t2)[y/a])<, if (cid:16) =≤P Q (t1t2) such that ≤P Q is a comparison predicate in σ ≤
• op(cid:9)M

∗(cid:12) (cid:13) fA(t[y/a]), if (cid:16) = δ is an aggregate atom of the form (1), where

;

;

∗ = {{( fA(c) : GRA(∃wBd(δ), yv/ac)) | c ∈ M

(cid:3)

M

, fA(c) is deﬁned}},

and

(cid:3) = {c | A |(cid:17) Bd(δ)[ywv/abc], b ∈ Dom(A)

|w|

M

, c ∈ Dom(A)

|v|}

• ¬GRA((cid:16)1, y/a), if (cid:16) is of the form ¬(cid:16)1;
• GRA((cid:16)1, y/a) ∨ GRA((cid:16)2, y/a), if (cid:16) is of the form (cid:16)1 ∨ (cid:16)2;
• GRA(

a∈Dom(A) (cid:16)1[ y/a], y/a), if (cid:16) is of the form ∀ y(cid:16)1.

(cid:13)

,  and 

,  and 

(33)

If (cid:16) is a formula without free variables, then the grounding of (cid:16) with respect to A is simply written as GRA((cid:16)).

The following theorem shows that we can compute the models of ordered completions by grounding.

Theorem 3. Let (cid:11) be a program, and Ae a ﬁnite structure on τext((cid:11)). Let A be a structure on τ ((cid:11))≤
and A |(cid:17) Trans((cid:11)). Then, A |(cid:17) OC((cid:11)) iff IA |(cid:17) GRAe (OC((cid:11))), where

, which is an expansion of Ae

IA = {P (a) | P ∈ Pint((cid:11)), a ∈ P

A}.

Proof. Let  P (a),  Q (b),  and  R(c) be  three  elements  in  IA.  Since  A |(cid:17) Trans((cid:11)),  we  have  A |(cid:17)≤P Q (xy)∧ ≤Q R (yz) →
≤PR (xz)[xyz/abc].

Therefore, there exists a function  FA from  IA to Z such that:

• FA(P (a)) (cid:7)= FA(Q (b)) if  P (a) and  Q (b) are different;
• FA(P (a)) < FA(Q (b)) if and only if A |(cid:17)≤P Q (xy)[xy/ab].

It suﬃces to prove the following result.

Let (cid:16) be a formula on τ ((cid:11))≤
GRAe ((cid:16), y/a).

, and y/a an assignment such that free((cid:16)) ⊆ y. Then, A |(cid:17) (cid:16)[y/a] if and only if (IA, FA) |(cid:17)

We prove this by induction on the structure of (cid:16).

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

89

• It  is  straightforward  that  A |(cid:17) (cid:27) if  and  only  if  (IA, FA) |(cid:17) GRAe ((cid:27)),  and  A |(cid:17) P (t)[y/a] if  and  only  if  (IA, FA) |(cid:17)

GRAe (P (t), y/a), where  P ∈ τext((cid:11)).

• For intensional predicate  P ∈ τint((cid:11)), we also have A |(cid:17) P (t)[y/a] if and only if IA |(cid:17) GRAe (P (t), y/a) by noticing that 

P (a) ∈ IA if and only if a ∈ P

A

for every tuple a that matches the arity of  P .

• For a comparison atom ≤P Q (t1t2), A |(cid:17)≤P Q (t1t2)[y/a], where free(t1t2) ⊆ y, if and only if

F A(P (t1)[y/a]) < F A(Q (t2)[y/a])

if and only if

(IA, F A) |(cid:17) (P (t1)[y/a], Q (t2)[y/a])<

if and only if

(IA, F A) |(cid:17) GRAe ((cid:16)).

• If  (cid:16) = δ is  an  aggregate  atom  of  the  form  (1) such  that  free((cid:16)) ⊆ y,  we  will  show  that  A |(cid:17) δ[y/a] if  and  only  if 

(IA, FA) |(cid:17) GRAe (δ, y/a). Consider the following set and multiset:

(cid:3) = {c | A |(cid:17) Bd(δ)[ywv/abc], b ∈ Dom(A)
M
∗ = {{( fA(c) : GRA(∃wBd(δ), yv/ac)) | c ∈ M

|w|

|v|},

, c ∈ Dom(A)
(cid:3)
, fA(c) is deﬁned}},

M
M1 = {{ fA(c) | c ∈ M
∗
M2 = {{c | (c, φ) ∈ M
We have M1 = M2 by noticing that

(cid:3)

, fA(c) is deﬁned}}
, (I, F ) |(cid:17)AC φ}}

(34)

(35)

(36)

(37)

A |(cid:17) Bd(δ)[ywv/abc],

if and only if

A |(cid:17) ∃wBd(δ)[yv/ac],

if and only if

(IA, F A) |(cid:17) GRA(∃wBd(δ), yv/ac).

Hence, A |(cid:17) δ[y/a] if and only if (IA, FA) |(cid:17) GRAe (δ, y/a).

• If (cid:16) is of the form ¬(cid:16)1, (cid:16)1 ∧ (cid:16)2 and ∀x(cid:16)1, it is also straightforward to see that A |(cid:17) (cid:16)[y/a] if and only if (IA, FA) |(cid:17)

GRAe ((cid:16), y/a). (cid:2)

Based on Theorem 3, we have implemented a new solver GROCv2. Now we report some experimental results. We use Z3 
(version 4.3.2)7 in GROCv2 as the underlying SMT solver. We compare our approach GROCv2 + Z3 with three state-of-the-art 
ASP solvers, namely DLV (version 4.2.1),8 CLASP (version 3.0.0),9 and CMODELS (version 3.85).10 We use GRINGO (version 
3.0.5)11 as the grounder for the solvers CLASP and CMODELS. The reason why we choose CLASP, DLV, and CMODELS here 
is because the ﬁrst two are representative ASP solvers based on conﬂict analysis, while the last is a representative solver 
based on loop formulas.

We are mainly interested in non-tight programs as for tight programs, ordered completion is just Clark’s completion. In 
this  paper,  we  consider  three  benchmark  programs,  the  bounded-traveling salesman problem,  the  Nurikabe puzzle,  and  the 
weight-bounded dominating set problem.

Tables 1 and 2 report our results for the bounded traveling salesman program. Here, Table 1 contains the results for our 
randomly  generated  instances  while  Table 2 contains  the  results  taken  from  the  ASPARAGUS  benchmark  suite.12 For  ran-
domly generated instances, “rand_x_ y_i” represents a random graph with x number of nodes and  y edges and of instance i. 
We set the timeouts to be 1000.00 s, denoted by “—” in the tables. Note that we also include the grounding time for CLASP 
as well as CMODELS. For clarity, we pick up the best solver for each instance, highlighted by bold fonts. From Tables 1 and 2, 
it can be observed that GROCv2 + Z3 and GRINGO + CLASP outperform DLV and GRINGO + CMODELS in most cases on the 
bounded traveling salesman program while the previous two solvers are comparable. Interestingly, for randomly generated 
instances, GROCv2 + Z3 seems to have an advantage over GRINGO + CLASP on big problem instances.

7 http :/ /z3 .codeplex .com/.
8 http :/ /www.dlvsystem .com/.
9 http :/ /potassco .sourceforge .net/.
10 http :/ /www.cs .utexas .edu /users /tag /cmodels .html.
11 http :/ /potassco .sourceforge .net/.
12 http :/ /asparagus .cs .uni-potsdam .de /instanceclass /show /id /34.

90

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

Table 1
Bounded-traveling salesman (randomly generated).
GROCv2 + Z3

Instances

rand_50_300_1
rand_50_300_2
rand_50_300_3
rand_50_300_4
rand_50_300_5
rand_50_300_6
rand_50_300_7
rand_50_300_8
rand_50_300_9
rand_50_300_10
rand_60_350_1
rand_60_350_2
rand_60_350_3
rand_60_350_4
rand_60_350_5
rand_60_350_6
rand_60_350_7
rand_60_350_8
rand_60_350_9
rand_60_350_10
rand_70_400_1
rand_70_400_2
rand_70_400_3
rand_70_400_4
rand_70_400_5
rand_70_400_6
rand_70_400_7
rand_70_400_8
rand_70_400_9
rand_70_400_10

109.23 (SAT)
280.17 (SAT)
0.03 (UNSAT)
12.81 (SAT)
38.71 (SAT)
96.23 (SAT)
0.03 (UNSAT)
0.48 (SAT)
89.49 (SAT)
0.03 (UNSAT)
0.79 (SAT)
32.35 (SAT)
109.61 (SAT)
34.39 (SAT)
0.88 (SAT)
483.07 (SAT)
0.03 (UNSAT)
0.03 (UNSAT)
8.01 (SAT)
— (?)
123.84 (SAT)
658.51 (SAT)
113.39 (SAT)
281.80 (SAT)
0.03 (UNSAT)
43.30 (SAT)
17.02 (SAT)
— (?)
424.07 (SAT)
87.85 (SAT)

Table 2
Bounded-traveling salesman (from ASPARAGUS website).
GROCv2 + Z3

Instances

dom_rand_70_300_x_3
rand_70_300_x_0
rand_70_300_x_3
rand_70_300_x_4
rand_70_300_x_5
rand_70_300_x_7
rand_70_300_x_8
rand_70_300_x_9
rand_70_300_x_11
rand_70_300_x_12
rand_70_300_x_14
rand_80_340_y_0
rand_80_340_y_4
rand_80_340_y_10
rand_80_340_y_11
rand_80_340_y_13
rand_80_340_y_15
rand_80_340_y_16
rand_80_340_y_17
rand_80_340_y_18

533.23 (UNSAT)
— (?)
438.49 (UNSAT)
0.03 (UNSAT)
0.06 (SAT)
0.03 (UNSAT)
0.03 (UNSAT)
0.03 (UNSAT)
0.03 (UNSAT)
0.02 (UNSAT)
0.04 (SAT)
0.03 (UNSAT)
0.03 (UNSAT)
0.03 (UNSAT)
0.03 (UNSAT)
— (?)
0.03 (UNSAT)
0.03 (UNSAT)
0.03 (UNSAT)
0.03 (UNSAT)

CLASP

9.95 (SAT)
— (?)
0.01 (UNSAT)
125.42 (SAT)
132.88 (SAT)
— (?)
0.01 (UNSAT)
4.13 (SAT)
315.93 (SAT)
0.01 (UNSAT)
18.85 (SAT)
— (?)
140.03 (SAT)
236.68 (SAT)
76.91 (SAT)
79.70 (SAT)
0.01 (UNSAT)
0.01 (UNSAT)
101.7 (SAT)
105.70 (SAT)
— (?)
340.13 (SAT)
9.57 (SAT)
— (?)
0.01 (UNSAT)
— (?)
361.151 (SAT)
— (?)
— (?)
— (?)

CLASP

690.24 (UNSAT)
— (?)
635.40 (UNSAT)
0.02 (UNSAT)
0.01 (SAT)
0.01 (UNSAT)
0.01 (UNSAT)
0.01 (UNSAT)
0.01 (UNSAT)
0.01 (UNSAT)
0.02 (SAT)
0.02 (UNSAT)
0.01 (UNSAT)
0.01 (UNSAT)
0.01 (UNSAT)
— (?)
0.01 (UNSAT)
0.02 (UNSAT)
0.02 (UNSAT)
0.01 (UNSAT)

DLV

— (?)
— (?)
0.04 (UNSAT)
— (?)
— (?)
— (?)
0.05 (UNSAT)
632.11 (SAT)
— (?)
0.01 (UNSAT)
— (?)
— (?)
— (?)
— (?)
— (?)
— (?)
0.01 (UNSAT)
0.01 (UNSAT)
119.68 (SAT)
— (?)
— (?)
— (?)
— (?)
— (?)
0.01 (UNSAT)
— (?)
— (?)
— (?)
— (?)
— (?)

DLV

— (?)
— (?)
— (?)
0.01 (UNSAT)
0.10 (SAT)
0.01 (UNSAT)
0.02 (UNSAT)
0.01 (UNSAT)
0.01 (UNSAT)
0.01 (UNSAT)
— (?)
0.02 (UNSAT)
0.02 (UNSAT)
0.01 (UNSAT)
0.02 (UNSAT)
— (?)
0.02 (UNSAT)
0.02 (UNSAT)
0.01 (UNSAT)
0.01 (UNSAT)

CMODELS

— (?)
— (?)
0.01 (UNSAT)
— (?)
— (?)
— (?)
0.01 (UNSAT)
35.89 (SAT)
— (?)
0.04 (UNSAT)
— (?)
— (?)
— (?)
— (?)
— (?)
— (?)
0.05 (UNSAT)
0.05 (UNSAT)
— (?)
— (?)
— (?)
— (?)
— (?)
— (?)
0.06 (UNSAT)
— (?)
— (?)
— (?)
— (?)
— (?)

CMODELS

— (?)
— (?)
— (?)
0.01 (UNSAT)
8.732 (SAT)
0.04 (UNSAT)
0.05 (UNSAT)
0.05 (UNSAT)
0.04 (UNSAT)
0.04 (UNSAT)
92.42 (SAT)
0.05 (UNSAT)
0.06 (UNSAT)
0.06 (UNSAT)
0.06 (UNSAT)
— (?)
0.06 (UNSAT)
0.05 (UNSAT)
0.04 (UNSAT)
0.04 (UNSAT)

Table 3 reports  the  experimental  results  on  the  Nurikabe  puzzle.  Here,  we  omit  the  results  of  DLV  as  it  seems  not  to 
return the correct answers. One can obtain a similar conclusion on this program. That is, GROCv2 + Z3 and GRINGO + CLASP 
are  slightly  better  than  GRINGO  + CMODELS  and  the  previous  two  are  comparable  with  each  other.  Again,  for  randomly 
generated  instances,  the  bigger  the  problem  is,  the  better  GROCv2  + Z3  performs  in  comparison  with  GRINGO  + CLASP. 
Table 4 reports our experiments on the weight-bounded dominating set program with the instances from the ASPARAGUS 
benchmark  suites.13 On  this  program,  GRINGO  + CLASP  is  the  clear  winner.  In  addition,  GROCv2  + Z3  performs  slightly 
worse than DLV as well, although it is comparable to GRINGO + CMODELS.

13 http :/ /asparagus .cs .uni-potsdam .de /instanceclass /show /id /33.

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

91

Table 3
Nurikabe (hand coded and randomly generated).

Instances

puzzle_10_10_1
puzzle_10_10_2
puzzle_10_10_3
puzzle_10_10_4
puzzle_10_10_5
puzzle_10_10_6
puzzle_10_10_7
puzzle_12_12_1
puzzle_12_12_2
puzzle_12_12_3
puzzle_12_12_4
rand_10_10_n5_1
rand_10_10_n5_2
rand_10_10_n5_3
rand_10_10_n5_4
rand_10_10_n5_5
rand_10_10_n5_6
rand_10_10_n5_7
rand_10_10_n5_8
rand_10_10_n5_9
rand_10_10_n5_10
rand_10_10_n6_1
rand_10_10_n6_2
rand_10_10_n6_3
rand_10_10_n6_4
rand_10_10_n6_5
rand_10_10_n6_6
rand_10_10_n6_7
rand_10_10_n6_8
rand_10_10_n6_9
rand_10_10_n6_10
rand_12_12_n7_1
rand_12_12_n7_2
rand_12_12_n7_3
rand_12_12_n7_4
rand_12_12_n7_5
rand_12_12_n7_6
rand_12_12_n7_7
rand_12_12_n7_8
rand_12_12_n7_9
rand_12_12_n7_10

GROCv2 + Z3

20.84 (UNSAT)
35.91 (SAT)
20.84 (SAT)
25.08 (SAT)
15.72 (SAT)
11.62 (SAT)
15.45 (SAT)
20.70 (SAT)
25.29 (SAT)
58.81 (SAT)
0.09 (UNSAT)
90.22 (UNSAT)
131.27 (UNSAT)
54.74 (UNSAT)
153.76 (UNSAT)
18.83 (UNSAT)
0.05 (UNSAT)
135.01 (UNSAT)
93.76 (UNSAT)
255.49 (UNSAT)
124.18 (UNSAT)
12.18 (UNSAT)
154.63 (UNSAT)
174.78 (UNSAT)
190.39 (UNSAT)
158.91 (UNSAT)
314.21 (UNSAT)
607.40 (UNSAT)
0.06 (UNSAT)
395.40 (UNSAT)
511.52 (UNSAT)
— (?)
270.16 (UNSAT)
— (?)
0.10 (UNSAT)
— (?)
— (?)
554.98 (UNSAT)
0.10 (UNSAT)
— (?)
— (?)

Table 4
Weight-bounded connected dominating set (from ASPARAGUS instances).

Instances

rand_100_400_1159666138_1
rand_100_400_1159666138_2
rand_100_400_1159666138_3
rand_100_400_1159666138_5
rand_100_400_1159666138_6
rand_100_400_1159666138_7
rand_100_400_1159666138_8
rand_100_400_1159666138_9
rand_100_400_1159666138_13
rand_100_400_1159666138_19
rand_150_600_1159731678_3
rand_100_400_1159666138_5
rand_100_400_1159666138_6
rand_100_400_1159666138_7
rand_100_400_1159666138_8
rand_100_400_1159666138_11
rand_100_400_1159666138_12
rand_100_400_1159666138_14
rand_100_400_1159666138_15
rand_100_400_1159666138_17

GROCv2 + Z3

0.28 (UNSAT)
0.34 (UNSAT)
0.32 (UNSAT)
0.27 (UNSAT)
0.29 (UNSAT)
0.22 (UNSAT)
0.44 (UNSAT)
0.51 (UNSAT)
0.33 (UNSAT)
0.32 (UNSAT)
0.81 (UNSAT)
0.78 (UNSAT)
0.76 (UNSAT)
1.15 (UNSAT)
0.76 (UNSAT)
0.76 (UNSAT)
0.73 (UNSAT)
0.76 (UNSAT)
0.72 (UNSAT)
0.79 (UNSAT)

CLASP

4.09 (UNSAT)
1.62 (SAT)
0.85 (SAT)
1.97 (SAT)
0.83 (SAT)
1.48 (SAT)
0.73 (SAT)
1.61 (SAT)
1.49 (SAT)
1.84 (SAT)
0.72 (UNSAT)
287.25 (UNSAT)
14.11 (UNSAT)
104.72 (UNSAT)
289.89 (UNSAT)
52.21 (UNSAT)
0.31 (UNSAT)
277.87 (UNSAT)
157.11 (UNSAT)
385.82 (UNSAT)
226.53 (UNSAT)
24.18 (UNSAT)
99.38 (UNSAT)
198.42 (UNSAT)
168.76 (UNSAT)
104.35 (UNSAT)
739.65 (UNSAT)
— (?)
0.23 (UNSAT)
541.80 (UNSAT)
807.27 (UNSAT)
— (?)
230.20 (UNSAT)
— (?)
0.69 (UNSAT)
— (?)
— (?)
771.46 (UNSAT)
0.71 (UNSAT)
— (?)
— (?)

CLASP

0.04 (UNSAT)
0.05 (UNSAT)
0.04 (UNSAT)
0.05 (UNSAT)
0.06 (UNSAT)
0.04 (UNSAT)
0.07 (UNSAT)
0.05 (UNSAT)
0.04 (UNSAT)
0.06 (UNSAT)
0.12 (UNSAT)
0.08 (UNSAT)
0.09 (UNSAT)
0.10 (UNSAT)
0.09 (UNSAT)
0.08 (UNSAT)
0.22 (UNSAT)
0.08 (UNSAT)
0.08 (UNSAT)
0.09 (UNSAT)

DLV

N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A

DLV

0.05 (UNSAT)
0.05 (UNSAT)
0.06 (UNSAT)
0.04 (UNSAT)
0.05 (UNSAT)
0.04 (UNSAT)
0.06 (UNSAT)
0.09 (UNSAT)
0.05 (UNSAT)
0.09 (UNSAT)
0.11 (UNSAT)
0.09 (UNSAT)
0.11 (UNSAT)
0.10 (UNSAT)
0.11 (UNSAT)
0.11 (UNSAT)
0.11 (UNSAT)
0.10 (UNSAT)
0.11 (UNSAT)
0.12 (UNSAT)

CMODELS

60.62 (UNSAT)
12.14 (SAT)
4.62 (SAT)
11.46 (SAT)
8.40 (SAT)
35.40 (SAT)
4.33 (SAT)
17.33 (SAT)
24.81 (SAT)
3.85 (SAT)
0.28 (UNSAT)
518.52 (UNSAT)
72.91 (UNSAT)
106.97 (UNSAT)
881.90 (UNSAT)
70.55 (UNSAT)
0.11 (UNSAT)
818.98 (UNSAT)
517.34 (UNSAT)
— (?)
361.99 (UNSAT)
69.37 (UNSAT)
275.44 (UNSAT)
— (?)
— (?)
457.56 (UNSAT)
— (?)
— (?)
0.12 (UNSAT)
— (?)
— (?)
— (?)
910.31 (UNSAT)
— (?)
0.30 (UNSAT)
— (?)
— (?)
— (?)
0.29 (UNSAT)
— (?)
— (?)

CMODELS

0.56 (UNSAT)
0.27 (UNSAT)
0.18 (UNSAT)
0.47 (UNSAT)
0.58 (UNSAT)
0.44 (UNSAT)
0.66 (UNSAT)
0.54 (UNSAT)
0.50 (UNSAT)
0.79 (UNSAT)
2.40 (UNSAT)
1.87 (UNSAT)
2.07 (UNSAT)
1.97 (UNSAT)
1.89 (UNSAT)
1.85 (UNSAT)
1.95 (UNSAT)
0.53 (UNSAT)
1.89 (UNSAT)
2.49 (UNSAT)

92

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

To sum up, our solver GROCv2 + Z3 is comparable to other state-of-the-art ASP solvers in the literature. Since this is 
a  ﬁrst  implementation  so  that  many  simpliﬁed  techniques,  e.g.,  ﬁrst-order  simpliﬁcation  of  ordered  completion,  are  not 
employed,  we  believe  that  ordered  completion  provides  a  new  promising  way  to  implement  answer  set  programming. 
We  have  done  some  experimental  analysis  on  other  benchmark  programs  as  well,  including  N-queens,  bounded-spanning 
tree and  projected hamiltonian cycle.  For  more  details  about  our  solver  and  the  benchmark  program  instances,  please  see 
the following link http :/ /staff .scm .uws .edu .au /~yzhou /?page _id =212. Unfortunately, the current version of GROCv2 does not 
support functions so that it is not able to handle some benchmark programs. We leave it to our future investigations.

5.  Related work

As  a  crucial  building  block  of  answer  set  programs,  aggregates  are  extensively  studied  in  the  literature  [4,10,13,16,
21–23]. Although the syntactic form of aggregates is usually presented in a ﬁrst-order language, its semantics is normally 
deﬁned propositionally via grounding. Recently, several approaches are proposed to deﬁne a genuine ﬁrst-order semantics 
for  aggregates.  An  early  attempt  is  due  to  Lee  and  Meng  [22],  although  a  more  restricted  form  only  for  the  choice  and 
counting aggregates already appeared in [21]. In fact, our semantics for ﬁrst-order aggregates is essentially equivalent to Lee 
and Meng’s deﬁnition, when restricted into the syntax with aggregates of the form (1) although there is a slight difference. 
Lee  and  Meng’s  stable  model  semantics  considers  the  number  constant  symbols  from  Z as  part  of  the  signature  so  that 
the domains of the underlying structure are assumed to contain the numbers from Z. On the contrary, our notion does not 
consider numbers in the domain of a structure A. Instead, we use a partial function  fA that maps the domain elements 
of Dom(A) to integers. This is addressed in Deﬁnition 3 by the notion of an extended structure. The only difference between 
extended structures and standard ﬁrst-order structures is the function  fA that maps elements of Dom(A) to Z. It should 
be noted that our notion of an extended structure generalizes the notion by that of Lee and Meng [22] since we can always 
map domain elements with number symbols into the numbers they represent, e.g., if Dom(A) contains the number symbols 
−1 and 3, then we can simply set  fA(−1) = −1 and  fA(3) = 3, where  fA will be partially ﬁxed for the number symbols 
from  Z for  all  structures  A.  The  reason  for  our  notion  is  that  it  is  more  abstract  in  the  sense  that  it  does  not  consider 
number  symbols  in  the  meta-level.  Furthermore,  it  also  allows  us  to  only  consider  ﬁnite  domains  since  Lee  and  Meng’s 
notion always assumes all numbers from Z to be presented in the domain of all underlying structures.

An alternative deﬁnition of aggregates is the FLP semantics [13], which is extended into the ﬁrst-order case recently [4]. 
The FLP semantics is inherently different from the stable model semantics for aggregates. For instance, the former satisﬁes 
the  anti-chain  property  [13] while  the  latter  does  not.  However,  these  two  semantics  coincide  if  we  only  allow  positive 
atoms  in  aggregates,  that  is,  Ng(δ) = ∅ for  any  aggregate  atoms  of  the  form  (1).  In  fact,  this  is  the  case  for  many  ASP 
benchmark programs, including the benchmark programs we tested in Section 4.

Another  aggregate  framework  that  is  related  to  our  work  is  the  SP  semantics  of  [30].  The  SP  semantics  of  normal 
programs  with  aggregates  is  deﬁned  via  a  ﬁxed  point  operator  that  behaves  identically  to  the  three-valued  immediate 
consequence operator “(cid:16)agg
P ” independently proposed in [26]. Although the semantics itself is based on a ﬁxed point type 
characterization, which is different from our translational approach, this framework is related to our work in the sense that 
our aggregate syntax of the form (1) is similar to their notion of an intensional multiset of the form

{{x | ∃z1, . . . , zr P ( y1, . . . , ym)}},

where {x, z1, . . . , zr} ⊆ y1, . . . , ym (see Deﬁnition 1 of [30]).

Aggregates are also deﬁned for HEX programs [10], which is an extension of logic programs by introducing higher order 
external  atoms.  The  semantics  of  aggregates  in  HEX  programs  is  also  deﬁned  in  a  similar  manner  as  the  FLP  semantics. 
Interestingly, it is shown that external atoms in HEX programs generalize the notion of aggregate atoms [10].

Our  deﬁnition  of  convex  aggregates  is  a  lift  of  Liu  and  Truszczy ´nski’s  notion  [23] to  the  ﬁrst-order  case,  although  the 
syntax is presented quite differently. In fact, Liu and Truszczy ´nski observed that normal programs with polynomial, convex 
aggregates  do not  increase  the  computational  complexity.  For  instance,  checking  the  existence  of  answer  sets  for  normal 
programs and normal programs with polynomial, convex aggregates are both in NP. However, the negative result that con-
vex aggregate is the maximal subclass for the above property is not considered. In other words, we discover that normal 
programs with non-convex aggregates will inevitably jump into another complexity level. From Lemma 2, normal programs 
with non-convex aggregates can capture disjunctive programs, thus checking the existence of answer sets for such programs 
is (cid:14) P

2 complete.
Our negative result (see Lemma 2 and Theorem 2) is inspired by Ferraris’ work [16]. Ferraris’ work considered monotone 
and antimonotone aggregates but not the generalized concept of convex aggregates. He showed that, in the propositional 
case,  there  exists  an  aggregate  context  such  that  disjunctive  programs  can  be  converted  into  normal  logic  programs  with 
aggregate atoms under this context. We further proved that this is the case for all non-convex aggregate context, both in 
the  propositional  case  and  in  the  ﬁrst-order  case.  As  a  consequence,  convex  aggregates  exactly  draw a  boundary  of  the 
expressive power as well as computational complexity of aggregates in normal logic programs. That is, in the propositional 
case,  the  complexity  of  checking  the  answer  set  existence  for  normal  logic  programs  with  any  convex  aggregate  atoms 
is  NP-complete,  which  is  the  same  as  that  for  normal  logic  program  without  aggregates.  In  contrast,  the  complexity  of 
checking  the  answer  set  existence  for  normal  logic  programs  under  any  non-convex  aggregate  context  is  (cid:14) P
2 -complete, 

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

93

which is on a higher complexity level. In the ﬁrst-order case, our result shows that normal logic programs with any convex 
aggregate atoms can be converted into ﬁrst-order logic with the same type of aggregates (see Theorem 1), while this can 
never be done for normal logic programs under any non-convex aggregate context providing some general assumptions in 
the complexity theory (see Theorem 2).

Interestingly, Alviano and Faber [1] recently have obtained a similar result for the FLP semantics in the propositional case. 
That is, under the FLP semantics, propositional programs with convex aggregates will not increase the complexity. However, 
adding  a  simple  non-convex  aggregates  will  result  in  a  complexity  jump  from  the  ﬁrst  level  of  polynomial  hierarchy  to 
the second level. In this paper, we are mainly focused on the Ferraris’ semantics but not the FLP semantics. Nevertheless, 
following the proofs, our results hold for the FLP semantics as well. The main difference is that we consider the ﬁrst-order 
case instead of the propositional case. We show that convex aggregates draw the boundary not only on complexity but also 
on expressiveness (i.e., translatability to classic ﬁrst-order logic with aggregates) as well.

Finally,  we  would  address  the  relation  of  our  work  with  the  ﬁrst-order loop formulas approach  of  Lee  and  Meng  [22]. 
A main  difference  is  that  ﬁrst-order  loop  formulas  work  for  arbitrary  aggregates  while  our  enhanced  ordered  completion 
only works for convex aggregates. This is partially because ﬁrst-order loop formulas are inﬁnite theories in general while 
ordered completions always produce ﬁnite theories. From a semantic viewpoint, loop formulas is about the encoding of the 
external  support  of  a  set  of  atoms  (which  is  inﬁnite  at  the  ﬁrst-order  level),  while  the  ordered  completion  is  about  the 
encoding  of  a  derivation  order,  although  they  both  imply  the  stability  of  a  model  for  the  class  of  normal  program  with 
convex aggregates.

6.  Conclusion

The main contributions of this paper are as follows. Firstly, we extended the notion of ordered completion for ﬁrst-order 
programs with aggregates, and showed that the stable models of a program with convex aggregates are corresponding to the 
models of its ordered completion on ﬁnite structures (Theorem 1). This is an important extension as most ASP benchmark 
programs  for  real  world  problems  need  to  use  aggregates  and  these  aggregates  are  indeed  convex.  Secondly,  we  showed 
that convex aggregate is a maximal subclass for the above task. More precisely, given a non-convex aggregate context, we 
can always construct a normal program under this aggregate context that can never be translated into a ﬁrst-order sentence 
with  the  same  type  of  aggregates  providing  some  assumptions  in  the  complexity  theory  (Theorem 2).  To  the  best  of  our 
knowledge, our negative result is one of the ﬁrst two results [1] to show that convex aggregates exactly draw a boundary of 
the expressive power as well as the computational complexity of aggregate atoms in answer set programming. Finally, we 
showed that we can ground a program with an extensional database into a propositional SMT theory in order to compute 
the answer sets (Theorem 3). Based on this, we implement an ASP solver and compare it with some modern ASP solvers. 
The  experiments  show  that  this  new  direction  of  answer  set  solving  is  promising,  particularly  for  non-tight  programs  on 
large problem instances.

Acknowledgements

We would like to thank the anonymous reviewers for their valuable comments and suggestions. This work is partially 

supported by the grant NSFC 61173010.

Appendix A.  Proof of Lemma 2

We present the full proof of Lemma 2 in this section. In the following, we always assume a non-convex aggregate context 
AC and a disjunctive program (cid:15)D . In Appendix A.1, we will deﬁne a translation from (cid:15)D to a normal program (cid:15)N with the 
same type of aggregates. Lemma 2 can be decomposed into the following two lemmas.

Lemma 3. Let MN be a structure on τ ((cid:15)N ). If MN is a stable model of (cid:15)N , then there exists a stable model MD of (cid:15)D such that MN
and MD agree on all interpretations of constants and predicates in τ ((cid:15)D).

Lemma 4. Let MD be a structure on τ ((cid:15)D ). If MD is a stable model of (cid:15)D , then there exists a stable model MN of (cid:15)N such that MD
and MN agree on all interpretations of constants and predicates in τ ((cid:15)D).

Lemma 3 will be shown in Appendix A.2, and Lemma 4 will be shown in Appendix A.3.
We ﬁrst introduce some notations. Recall that the aggregate context AC is non-convex. By Deﬁnition 6, there exist three 
multisets  of  tuples  M1, M2, M3 such  that  M1 ⊆ M2,  op(M1) (cid:13) N and  op(M3) (cid:13) N hold  while  op(M1) (cid:13) N does  not  hold, 
where op ∈ ACag is an aggregate symbol, (cid:13)∈ ACop is a comparison operator, and N ∈ ACnum is a number. Let

• M1 = { {m1, . . . , mN1
• M2 \ M1 = { {mN1+1, . . . , mN2
• M3 \ M2 = { {mN2+1, . . . , mN3

} },

} },
} },

94

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

where N1, N2, N3 are the size of M1, M2, M3 respectively, and 0 ≤ N1 < N2 < N3. Without loss of generality, we assume all 
tuples in M3 are of the same length  K .

We introduce some new constants. Let Cnew be a set of new constants

Cnew = {cm,s | ms ∈ M3, m ∈ ms, (1 ≤ s ≤ N3)} ∪ {cn, cc},

where cn is a new constant for  N, cc is a special new constant which is used in rule (A.12) for Proposition 5, and the rest 
of new constants are for the tuples of numbers in M1, M2, M3. We use  D to denote the following set of tuples of constants

D = {d1, . . . , dN1 , . . . , dN2 , . . . , dN3

},

where  ds (1 ≤ s ≤ N3) is the tuple of constants obtained from  ms ∈ M3 by replacing each m ∈ ms by cm,s. Notice that  di
and d j (1 ≤ i (cid:7)= j ≤ N3) are always different tuples of constants. We use NotLitNew(x) to denote the set of negated atoms

{not x = c | x ∈ x, c ∈ Cnew \ {cc}},

where x is a tuple of variables. Intuitively, NotLitNew(x) means that variables in x and constants in Cnew \ {cc} will never be 
mapped to the same domain elements.

We introduce some new predicates for the program. Let Pnew be a set of new predicates

Pnew = Q ∪ QD ∪ QM,

where

Q = {Q r,i, j | r ∈ (cid:15) is a rule of the form (27) , 1 ≤ i (cid:7)= j ≤ k},

QD = {Q D i | 1 ≤ i ≤ K },
QM = {Q Mi | i = 1, 2, 3}.

Intuitively, Q is a set of predicates for constructing aggregate atoms, QD for representing elements in a tuple, and QM for 
encoding M1, M2, M3.

Furthermore, we introduce some new predicates and tuples of predicates for the second-order formulas like (8). Let  U

be a set of new predicates

U = {U P | P ∈ Pint((cid:15)D ) ∪ Pnew, U P and P have the same arity.}

We use PD and UD to denote the tuple of predicates in Pint((cid:15)D ) and the tuple of the correspondence predicates in {U P | P ∈
Pint((cid:15)D )} respectively.  We  use  PN and  UN to  denote  the  tuple  of  predicates  in  Pint((cid:15)D ) ∪ Pnew and  the  tuple  of  the 
correspondence predicates in U respectively.

A.1.  The translation from disjunctive programs to normal programs with non-convex aggregates

In this section, we deﬁne a normal program with aggregates, denoted by (cid:15)N , which captures the answer sets of (cid:15)D . In 
general, (cid:15)N is a normal program with aggregates built from τ ((cid:15)D ) together with the set of new constants Cnew and the set 
of new predicates Pnew. It is the union of three sets of rules:

(cid:15)N = AGG ∪ DEF ∪ CST,

where

• AGG is a set of normal rules with aggregates, which simulates the disjunctive rules;
• DEF is a set of rules about the new predicates in Q;
• CST is a set of rules about the new predicates in QD and QM.

Now we deﬁne the sets of rules AGG, DEF and CST. Without loss of generality, we assume that there is no constant in 
the heads of the rules in (cid:15)D . Otherwise, we remove the constants in the head of a rule by using equalities. For example, 
P (x, c) ← E(x, y) can be rewritten as  P (x, z) ← E(x, y), z = c when c is a constant.

be a rule of the form (27). Let v1, . . . , vk be the tuples of variables occurring in α1, . . . , αk in the head 

Let r ∈ (cid:15)D \ (cid:15)D

⊥

of r. By r N
i

, we denote the rule:

αi ← β1, . . . , βl, not γ1, . . . , not γm,
op(cid:9)x : Q r,i,1(x, vi, v1)(cid:12) (cid:13) cn,
. . . ,
op(cid:9)x : Q r,i,k(x, vi, vk)(cid:12) (cid:13) cn,
NotLitsNew(Var(r)),

(A.1)

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

95

where:

• 1 ≤ i ≤ k, and k is the number of atoms in the head of r;
• x is a tuple of distinct new variables and |x| = K ;
• Var(r) is the tuple of variables in r.

We will show that, together with the rules in DEF and CST, normal rules r N
Let AGG be the following set of rules:

1 , . . . , r N

k exactly capture the disjunctive rule r. 

(cid:15)D

⊥ ∪ {r N
i

| r ∈ (cid:15)D \ (cid:15)D

⊥

is a rule of the form (27) (1 ≤ i ≤ k)}.

(A.2)

Then,  we  deﬁne  the  rules  in  DEF.  Let  r be  a  rule  of  the  form  (27),  and  assume  that αi = P i(vi) and α j = P j(v j).  For 

every predicate  Q r,i, j ∈ Q, we use DEF(Q r,i, j) to denote the set of rules:

Q r,i, j(ds, vi, v j) ← NotLitsNew(viv j), for 1 ≤ s ≤ N1,
Q r,i, j(ds, vi, v j) ← P j(v j), NotLitsNew(vi), for N1 < s ≤ N2,
Q r,i, j(ds, vi, v j) ← P i(vi), P j(v j), for N2 < s ≤ N3,

← Q r,i, j(x, vi, v j), not P j(v j), not Q D1(x), . . . , not Q D N1 (x),
← Q r,i, j(x, vi, v j), not P i(vi), not Q D1(x), . . . , not Q D N2 (x),
← Q r,i, j(x, vi, v j), not Q D1(x), . . . , not Q D N3 (x).

Let DEF be the following set of rules:

(cid:20)

DEF(Q r,i, j).

Q r,i, j ∈Q

Finally, let CST be the set of the following rules:

• for predicate  P ∈ τ ((cid:15)D ), c ∈ Cnew \ {cc} and 1 ≤ i ≤ j,

← P (x1, . . . , xs), xi = c,

where  j is the arity of  P ;

• for constant c1 ∈ τ ((cid:15)D ) and c2 ∈ Cnew \ {cc},

← c1 = c2,
• for c ∈ Cnew \ {cc},

← c = cc,

• for two different constants c1, c2 ∈ Cnew \ {cn, cc},

← c1 = c2,

•

← not op(cid:9)x : Q M1(x)(cid:12) (cid:13) cn,
← op(cid:9)x : Q M2(x)(cid:12) (cid:13) cn,
← not op(cid:9)x : Q M3(x)(cid:12) (cid:13) cn,

• for 1 ≤ i ≤ N1,

Q M1(di) ←,

• for 1 ≤ i ≤ N2,

Q M2(di) ←,

• for 1 ≤ i ≤ N3,

Q M3(di) ←,

(A.3)

(A.4)

(A.5)

(A.6)

(A.7)

(A.8)

(A.9)

(A.10)

(A.11)

(A.12)

(A.13)

(A.14)

(A.15)

(A.16)

(A.17)

(A.18)

(A.19)

96

•

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

← Q M1(x), not Q D1(x), . . . , not Q D N1 (x),
← Q M2(x), not Q D1(x), . . . , not Q D N2 (x),
← Q M3(x), not Q D1(x), . . . , not Q D N3 (x),

• for 1 ≤ i ≤ N3,

Q D i(di) ←,
• for 1 ≤ i ≤ N3 and 1 ≤ j ≤ K ,

← Q D i(x1, . . . , x j, . . . xK ), not x j = cmi , j,

where mi = (m1, . . . , m j, . . . , mK ) is a tuple in M3.

(A.20)

(A.21)

(A.22)

(A.23)

(A.24)

Given  a  disjunctive  program  (cid:15)D ,  the  number  of  the  rules  of  (cid:15)N is  polynomial,  and  the  length  of  each  rule  is  also 

polynomial. So, (cid:15)N can be built in polynomial time with respect to the length of (cid:15)D .

Next, we prove some propositions which could illustrate why we deﬁne these rules. Proposition 2 shows the properties 
of the sets of new predicates QD and QM. Proposition 3 and Proposition 4 show that the implication can also be simulated 
by aggregate atoms when the aggregate context is non-convex.

Let M be a structure on τ ((cid:15)N ). We use Dom1(M) and Dom2(M) to denote two subsets of Dom(M) such that

M | c ∈ Cnew \ {cc}},
Dom2(M) = {c
Dom1(M) = Dom(M) \ Dom2(M).

We have the following proposition.

Proposition 2. Let M be a structure on τ ((cid:15)N ) such that M |(cid:17) DEF ∪ CST. Then,

then a ∈ Dom1(M)|a|
(1) For predicate P ∈ τ ((cid:15)D ), if a ∈ P
M
M
}.
= {d
(2) For predicate Q D i , (1 ≤ i ≤ N3), Q D
i
i
M
M
= {d
(3) For predicate Q Mi(i = 1, 2, 3), Q M
1 , . . . , d
i

}.

M

M
Ni

.

Proof. M is a model of rule (A.10), so (1) holds. M is a model of rules (A.23) and (A.24), so (2) holds. M is a model of 
rules (A.17)–(A.19) and (A.20)–(A.22), so (3) holds. (cid:2)

Proposition 3.  Let M be a structure on τ ((cid:15)N ) such that M |(cid:17) DEF ∪ CST. Then,

M |(cid:17) (P j(v j) → P i(vi)) ↔ (op(cid:9)x : Q r,i, j(x, vi, v j)(cid:12) (cid:13) cn)[v1v j/bc]

where

• r ∈ (cid:15)D be a rule of the form (27),
• αi = P i(vi) and α j = P j(v j) (1 ≤ i (cid:7)= j ≤ k) are two atoms in the head of r,
• b ∈ Dom(M)|b|
.

and c ∈ Dom(M)|c|

Proof. The proposition is a direct consequence of the following three statements:

(1) M |(cid:17) ¬P j(v j) → (op(cid:9)x : Q r,i, j(x, vi, v j)(cid:12) (cid:13) cn)[viv j/bc];
(2) M |(cid:17) (¬P i(vi) ∧ P j(v j)) → (op(cid:9)x : Q r,i, j(x, vi, v j)(cid:12) (cid:4) cn)[viv j/bc]; and
(3) M |(cid:17) (P i(vi) ∧ P j(v j)) → (op(cid:9)x : Q r,i, j(x, vi, v j)(cid:12) (cid:13) cn)[viv j/bc].

(1) Assume that M |(cid:17) ¬P j(v j)[v1v j/bc]. Let a ∈ Dom(M)K be a tuple of domain elements. By rules (A.3) and (A.6), abc ∈
M
M
r,i, j if and only if there exists 1 ≤ s ≤ N1 such that M |(cid:17) Q D s(x)[x/a]. Furthermore, by rules (A.17) and (A.20), abc ∈ Q
Q
r,i, j
if and only if a ∈ Q M

M
1 . We also have

M |(cid:17) op(cid:9)x : Q r,i, j(x, vi, v j)(cid:12) (cid:13) cn[viv j/bc]

if and only if

M |(cid:17) op(cid:9)x : Q M1(x)(cid:12) (cid:13) cn.

So, both rule (A.25) and rule (A.26) hold, since M is a model of rule (A.14).

(A.25)

(A.26)

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

97

(2) Assume that M |(cid:17) (¬P i(vi ∧ P j(v j))[v1v j/bc]. Let  a ∈ Dom(M)K be a tuple of domain elements. By rules (A.3), (A.4)
M
r,i, j if and only if there exists 1 ≤ s ≤ N2 such that M |(cid:17) Q D s(x)[x/a]. Furthermore, by rules (A.18) and 
and (A.7), abc ∈ Q
M
r,i, j if and only if a ∈ Q M
(A.21), abc ∈ Q
M |(cid:17) op(cid:9)x : Q r,i, j(x, vi, v j)(cid:12) (cid:13) cn[viv j/bc]

M
2 . We have

(A.27)

if and only if

M |(cid:17) op(cid:9)x : Q M2(x)(cid:12) (cid:13) cn.

(A.28)

So, neither rule (A.27) nor rule (A.28) holds, since M is a model of rule (A.15).
(3)  Assume  that  M |(cid:17) (P i(vi ∧ P j(v j))[v1v j/bc].  Let  a ∈ Dom(M)K be  a  tuple  of  domain  elements.  By  rules  (A.3)–(A.5)
M
r,i, j if and only if there exists 1 ≤ s ≤ N3 such that M |(cid:17) Q D s(x)[x/a]. Furthermore, by rules (A.19) and 
and (A.8), abc ∈ Q
M
r,i, j if and only if a ∈ Q M
(A.22), abc ∈ Q
M |(cid:17) op(cid:9)x : Q r,i, j(x, vi, v j)(cid:12) (cid:13) cn[viv j/bc]

M
3 . We have

(A.29)

if and only if

M |(cid:17) op(cid:9)x : Q M3(x)(cid:12) (cid:13) cn.

So, both rule (A.29) and rule (A.30) hold, since M is a model of rule (A.16). (cid:2)

(A.30)

Let M be  a  structure  on  τ ((cid:15)N ) and  U a  structure  on  τ ((cid:15)N ) ∪ UN .  U is  called  a Q-reserve extension of M if  U is  an 

extension of M and

U
• U
= U
P
• abc ∈ U

U

if U P ∈ UN and  P ∈ QD ∪ QM,

M
P
U
P if and only if at least one of the following holds:
a ∈ Q M1
a ∈ Q M2
a ∈ Q M3

U , b ∈ Dom1(M)
U
U , b ∈ U
P i

,
, and c ∈ U

and bc ∈ Dom1(M)

, and c ∈ U

U
P j

U
P j

|bc|

|b|

,

,

(A.31)

(A.32)

(A.33)

where
– P is a predicate of the form  Q r,i, j ∈ Q, r ∈ (cid:15)D is a rule of the form (27), and αi = P i(vi) and α j = P j(v j) are two 

atoms in the head of r,

– a, b, c are tuples of domain elements such that |a| = K , and b and c match the arity of  P i and  P j respectively.

Proposition 4. Let M be a structure on τ ((cid:15)N ) such that M |(cid:17) DEF ∪ CST. If U is a Q-reserve extension of M then,

U |(cid:17) (U P j (v j) → U P i (vi)) ↔ (op(cid:9)x : U Q r,i, j (x, vi, v j)(cid:12) (cid:13) cn)[v1v j/bc]

where

• r ∈ (cid:15)D is a rule of form (27),
• αi = P i(vi) and α j = P j(v j) (1 ≤ i (cid:7)= j ≤ k) are two atoms in the head of r,
• b ∈ Dom(M)|b|
.

and c ∈ Dom(M)|c|

Proof. The proof is similar to that of Proposition 3. We will show:

(1) U |(cid:17) ¬U P j (v j) → (op(cid:9)x : U Q r,i, j (x, vi, v j)(cid:12) (cid:13) cn)[viv j/bc]
(2) U |(cid:17) (¬U P i (vi) ∧ U P j (v j)) → (op(cid:9)x : U Q r,i, j (x, vi, v j)(cid:12) (cid:4) cn)[viv j/bc]
(3) U |(cid:17) (U P i (vi) ∧ U P j (v j)) → (op(cid:9)x : U Q r,i, j (x, vi, v j)(cid:12) (cid:13) cn)[viv j/bc]

(1) Assume that M |(cid:17) ¬U P j (v j)[v1v j/bc]. Let a ∈ Dom(M)K be a tuple of domain elements. By (A.31), if abc ∈ Q
a ∈ Q M

M
1 . We have
U |(cid:17) op(cid:9)x : U Q r,i, j (x, vi, v j)(cid:12) (cid:13) cn[viv j/bc]

if and only if

U |(cid:17) op(cid:9)x : U Q M1 (x)(cid:12) (cid:13) cn.

So, both rule (A.34) and rule (A.35) hold, since U is a model of rule (A.14) and  Q M

U
1

= U

U
Q M1

.

M
r,i, j then 

(A.34)

(A.35)

98

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

(2) Assume that U |(cid:17) (¬U P i (vi ∧ U P j (v j))[v1v j/bc]. Let  a ∈ Dom(M)K be a tuple of domain elements. By (A.31), if  abc ∈
Q

M
r,i, j , then a ∈ Q M

M
2 . We have

U |(cid:17) op(cid:9)x : U Q r,i, j (x, vi, v j)(cid:12) (cid:13) cn[viv j/bc]

if and only if

U |(cid:17) op(cid:9)x : U Q M2 (x)(cid:12) (cid:13) cn.

(A.36)

(A.37)

So, neither rule (A.36) nor rule (A.37) holds, since U is a model of rule (A.15), and  Q M

U
2

= U

U
Q M2

.

(3) Assume that U |(cid:17) (U P i (vi ∧ U P j (v j))[v1v j/bc]. Let a ∈ Dom(M)K be a tuple of domain elements. By (A.33), if abc ∈ Q
then a ∈ Q M

M
3 . We have

M
r,i, j

U |(cid:17) op(cid:9)x : U Q r,i, j (x, vi, v j)(cid:12) (cid:13) cn[viv j/bc]

if and only if

U |(cid:17) op(cid:9)x : U Q M3 (x)(cid:12) (cid:13) cn.

So, both rule (A.38) and rule (A.39) hold, since U is a model of rule (A.16), and  Q M

U
3

= U

U
Q M3

. (cid:2)

A.2.  The proof of Lemma 3

(A.38)

(A.39)

In this section, we will show that if MN is a stable model of (cid:15)N , then there exists a stable model MD of (cid:15)D such that 

MN and MD agree on all interpretations of constants and predicates in τ ((cid:15)D ).

Let MN be a stable model of (cid:15)N . By MD , we denote the structure on τ ((cid:15)D ) such that

• Dom(MD ) = Dom1(MN ),
• fMD (c) = fMN (c), for every constant c ∈ Dom(MD ),
• c
• a ∈ P

MN , for every constant c ∈ Dom(MD ),

MD if and only if a ∈ P

MN and a ∈ Dom(MD )|a|

MD = c

, for every predicate  P ∈ τ ((cid:15)D ).

Proposition 5 shows that MD is well deﬁned in the sense that the domain of MD is not empty. Proposition 6 shows 

that MN and MD agree on the interpretations of all constants and predicates in τ ((cid:15)D ).

Proposition 5. Dom(MD ) contains at least one domain elements.

Proof. MN is  a  model  of  rule  (A.12).  So  cc is  interpreted  to  a  domain  element  different  to  any  other  constants  in  Cnew. 
Thus, cc

MN ∈ Dom(MD ). (cid:2)

Proposition 6. Let P ∈ τ ((cid:15)D ) be a predicate, and a ∈ Dom(MN )|a|
a ∈ P

MD if and only if a ∈ P

MN .

a tuple of domain elements that matches the arity of P . Then, 

Proof. By  Proposition 2,  if  a ∈ P
P

MN . (cid:2)

MN then  a ∈ Dom(MD )|a|

.  So,  by  the  construction  of  MD ,  a ∈ P

MD if  and  only  if  a ∈

Now, we present the proof of Lemma 3.

Proof. We ﬁrst show that MD |(cid:17) (cid:21)(cid:15)D . Otherwise, there exist a rule r of the form (27) and a substitution θ on Var(r) such 
that MD (cid:7)|(cid:17)(cid:12)rθ . So MD |(cid:17) Body(r)θ and MD (cid:7)|(cid:17) αiθ (1 ≤ i ≤ k). We also have MN (cid:7)|(cid:17) αiθ (1 ≤ i ≤ k), by Proposition 6. Then, 
(cid:3) ∈ (cid:15)N of the form 
by Proposition 3, we have MN |(cid:17) op(cid:9)x : Q r,i, jx, vi, v j)(cid:12) (cid:13) cnθ (1 ≤ i (cid:7)= j ≤ k). When we consider the rule r
(cid:3))θ . This is a contradiction to the fact that MN is a stable model of (cid:15)N .
(A.1), we have MN |(cid:17) Body(r

(cid:3))θ and MN (cid:7)|(cid:17) Head(r

It remains to show

MD |(cid:17) ¬∃UD (UD < PD ∧

(cid:8)

(cid:12)r∗).

r∈(cid:15)D \(cid:15)⊥

D

(A.40)

We show this by contradiction. Otherwise, there exists a structure UD on τ ((cid:15)D ) ∪ UD such that UD |(cid:17) UD < PD and UD |(cid:17)
(cid:13)

(cid:12)r∗.

r∈(cid:15)D
Let  UN be  a  Q-reserve  extension  of  MN such  that  U

following, we will show that

UN
P

= U

UD
P when  P is  an  intensional  predicate  in  (cid:15)D .  In  the 

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

UN |(cid:17) UN < PN ∧

(cid:8)

(cid:12)r∗,

r∈(cid:15)N \(cid:15)⊥

N

which is a contradiction to the fact that MN is a stable model of (cid:15)N .

It suﬃces to show:

99

(A.41)

∗

(a) UN |(cid:17) UN < PN ;
(b) UN |(cid:17) r
(c) UN |(cid:17) r
(d) UN |(cid:17) r

, for rule r ∈ CST,
, for rule r ∈ DEF,
, for rule r ∈ AGG.

∗

∗

Note that for (b)–(d), we do not need to consider the constraints.

(a) Consider the predicates  P and U P :

• If  P is an intensional predicate in (cid:15)D , then U
• If  P ∈ QD ∪ QM, then U
• If  P is a predicate of the form  Q r,i, j ∈ Q, r ∈ (cid:15)D is a rule of the form (27), and αi = P i(vi) and α j = P j(v j) are two 
MN
i

= U
. So we have UN |(cid:17) U P = P ;

. We also have UD |(cid:17) UD < PD . So we have UN |(cid:17) UD < PD ;

atoms in the head of r, we also have UD |(cid:17) UD < PD . Notice that  Q M
and  P

,  i = 1, 2, 3, and that  P

= Q M

MN
i

MN
P

= U

⊆ P

⊆ P

UN
i

UN
i

UN
P

.

UN
j

MN
j

UN
P

UD
P

So we have UN |(cid:17) UN < PN .

(b) Let r be a rule of the form (A.17), (A.18), (A.19), or (A.23), we have UN |(cid:17) r

∗

, since U

UN
P

= U

MN
P

for  P ∈ QD ∪ QM.

UN
s

∈ Q M

(c) Let r be a rule of the form (A.3). Let vi v j/ bc be an assignment on Dom(UN ), and ds a tuple in  D, where (1 ≤ s ≤ N1). 
UN
1 ,  since  UN is  a  model  of  rules  (A.17) and  (A.20).  If  UN |(cid:17) NotLitsNew(viv j)[viv j/  bc],  we  have  bc ∈
We  have  d
Dom(M|bc|
∗
.

D ). By (A.31), UN |(cid:17) U Q r,i, j (ds, vi, v j)[viv j/ bc]. Thus, UN |(cid:17) r

Let r be a rule of the form (A.4). Let vi v j/ bc be an assignment on Dom(UN ), and ds a tuple in  D, where (N1 < s ≤ N2). 
UN
UN
2 ,  since  UN is  a  model  of  rules  (A.18) and  (A.21).  If  UN |(cid:17) U P j (v j) ∧ NotLitsNew(viv j)[viv j/  bc],  we 
∈ Q M
We  have  d
s
have b ∈ Dom(MD )|b|

. By (A.32), UN |(cid:17) U Q r,i, j (ds, vi, v j)[viv j/ bc]. Thus, UN |(cid:17) r
Let r be a rule of the form (A.5). Let vi v j/ bc be an assignment on Dom(UN ), and ds (N2 < s ≤ N3), be a tuple in  D. We 
UN
P i

UN
3 , since UN is a model of rules (A.19) and (A.22). If UN |(cid:17) U P i (vi) ∧ U P j (v j)[viv j/ bc], we have b ∈ U

and c ∈ U

UN
P j

UN
s

∗

.

have d
and c ∈ U

∈ Q M
UN
P j

. By (A.33), UN |(cid:17) U Q r,i, j (ds, vi, v j)[viv j/ bc]. Thus, UN |(cid:17) r

∗

.

(d) Let r be a rule of the form (27), and r N

i a rule of the (A.1), 1 ≤ i ≤ k. We will show UN |(cid:17) (r N
∗

Assume that there exists an assignment θ such that UN |(cid:17) Body(r N
i

)θ and UN (cid:7)|(cid:17) α∗

i )∗
i θ . By UN |(cid:17) Body(r N

i

by contradiction.
∗

), we have

UN |(cid:17) op(cid:9)x : U Q r,i, j (x, vi, v j)(cid:12) (cid:13) cnθ,

where i (cid:7)= j and 1 ≤ j ≤ k. So we have

UN |(cid:17) α∗

→ α∗

j
by Proposition 4. Since UN (cid:7)|(cid:17) α∗

i

i θ , we have UN (cid:7)|(cid:17) α∗

j θ , 1 ≤ j ≤ k.

1 ≤ j ≤ k. This is a contradiction, since UD |(cid:17) r

A.3.  The proof of Lemma 4

∗

. (cid:2)

However, UD , UD and UN agree on every predicate in τ ((cid:15)D ). Therefore, we also have UD |(cid:17) Body(r

∗)θ and UD (cid:7)|(cid:17) α∗

j θ , 

In this section, we will show that if MD is a stable model of (cid:15)D , then there exists a stable model MN of (cid:15)N such that 

MD and MN agree on all interpretations of constants and predicates in τ ((cid:15)D ).

Let MD be a structure on τ ((cid:15)). By MN , we denote the structure on τ ((cid:15)N ) such that:

• Dom(MN ) = Dom1(MN ) ∪ Dom2(MN ), where Dom1(MN ) = Dom(MD ) and Dom2(MN ) = {c

MN | c ∈ Cnew \ {cc}} is a 

set of new domain elements;

• the constants in τ ((cid:15)D ) are interpreted the same as those in MD , the new constant c ∈ Cnew \ {cc} is interpreted as the 
MN , and cc is interpreted as any of the domain element in Dom1(MD );

new domain element c

100

•

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

⎧
⎪⎨

⎪⎩

fMN (c) =

fMD (c),
m,
N,

c ∈ Dom(MD )
c is a domain element of the form c
c is a domain element of the form (cn)MN

MN
m,s

MN = P
MN
i
MN
i

• P
• Q M
• Q D
• abc ∈ Q

MD if  P is a predicate in τ ((cid:15)D );
MN
MN
= {d
, . . . , d
Ni
1
MN
} if  Q D i is a predicate in QD, 1 ≤ i ≤ N3;
= {d
i
MN
if and only if at least one of the following holds:
r,i, j

} if  Q Mi is a predicate in QM, i = 1, 2, 3;

a ∈ Q M
a ∈ Q M

a ∈ Q M

MN
1
MN
2
MN
3

|bc|

, and bc ∈ Dom1(MN )
, b ∈ Dom1(MN )
MN
, b ∈ P
i

, and c ∈ P

|b|

, and c ∈ P
MN
j

,

MN
j

(A.42)

(A.43)

(A.44)

where
– Q r,i, j ∈ Q, r ∈ (cid:15)D is a rule of the form (27), and αi = P i(vi) and α j = P j(v j) are two atoms in the head of r,
– a, b, c are tuples of domain elements such that |a| = K , and b and c match the arity of  P i and  P j respectively.

Now, we present the proof of Lemma 4.

Proof. First, we show that MN is a model of (cid:15)N . It suﬃces to show that (cid:15)N is a model of the rules in CST, DEF and AGG.

(1) Consider the rules in CST.

• MN is a model of rule (A.10), since  P
• MN is a model of rules (A.11) and (A.12), since the constant cc and constants in τ ((cid:15)D ) are interpreted as the domain 

MD if  P is a predicate in τ ((cid:15)D );

MN = P

elements in Dom1(MN ) while constants in Cnew are interpreted as domain elements in Dom2(MN );

• MN is a model of rule (A.13), since constants in Cnew \ {cc} are always interpreted as new distinct domain elements in 

Dom2(MN );

• MN is a model of rule (A.14), since

MN
1

Q M
fMN ({d

= {d
MN
1
and op(M1) (cid:13) N;

MN
1

, . . . , d
MN
N1

},

MN
N1
}) = {m1, . . . , mN1

, . . . , d

} = M1,

• Similarly to rule (A.14), MN is a model of rules (A.15) and (A.16);
• MN is a model of rules (A.17)–(A.24), since Q M
, . . . , d

MN
= {d
1

MN
i

MN
Ni

} (i = 1, 2, 3) and Q D

MN
i

= {d

MN
i

} (1 ≤ i ≤ N3).

(2) Consider the rules in DEF.

• Let r be a rule of the form (A.3). Let vi v j/bc be an assignment on Dom(MN ) and ds a tuple in  D, where (1 ≤ s ≤ N1). 
. By (A.44), we have MN |(cid:17) Q r,i, j(ds, vi, v j)[viv j/ bc]. So, 

If MN |(cid:17) NotLitsNew(viv j)[viv j/ bc], then bc ∈ Dom1(MD )|bc|
MN is a model of r. Similarly, MN is a model of rules of the form (A.4) and (A.5).

• Let  r be  a  rule  of  the  form  (A.6).  Let  xviv j/abc be  an  assignment  on  Dom(MN ).  If  MN |(cid:17) Q r,i, j(ds, vi, v j) ∧
}. Thus, MN

MN
¬P j(v j)[xviv j/abc], then (A.42) holds but (A.43) and (A.44) do not hold. So we have a ∈ {d
1
is a model of rule (A.6). Similarly, MN is a model of rules of the form (A.7) and (A.8).

, . . . , d

MN
N1

(3)  Consider  the  rules  in  AGG.  Let  r be  a  rule  of  the  form  (27),  and  r N

i a  rule  of  the  (A.1),  1 ≤ i ≤ k.  We  will  show 

MN |(cid:17) (r N

i ) by contradiction.

Assume that there exists an assignment θ such that MN |(cid:17) Body(r N

i )θ and MN (cid:7)|(cid:17) αiθ . We have

MN |(cid:17) op(cid:9)x : Q r,i, j(x, vi, v j)(cid:12) (cid:13) cnθ

where i (cid:7)= j and 1 ≤ j ≤ k. By Proposition 3, we have

MN |(cid:17) (α j → αi)θ.

Note that we have already shown MN |(cid:17) DEF ∪ CST. Together with MN (cid:7)|(cid:17) αiθ , we have MN (cid:7)|(cid:17) α jθ , for all 1 ≤ j ≤ k. In 
addition, MD and MN agree on every predicates in τ ((cid:15)D ). So, we have MD |(cid:17) Body(r)θ and MD (cid:7)|(cid:17) α jθ , 1 ≤ j ≤ k. This is 
a contradiction, since MD |(cid:17) r.

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

101

It remains to show

MN |(cid:17) ¬∃UN (UN < PN ∧

(cid:8)

(cid:12)r∗).

r∈(cid:15)N \(cid:15)⊥

N

(A.45)

We show this by contradiction. Otherwise, there exists a structure UN on τ ((cid:15)N ) ∪ UD such that UN is an extension of MN
and

UN |(cid:17) UN < PN ∧

(cid:8)

(cid:12)r∗.

r∈(cid:15)N \(cid:15)⊥

N

(A.46)

UN for  every  constant  c ∈ τ ((cid:15)D ) and 
UN for  every  predicate  P ∈ τ ((cid:15)D ).  By  the  construction  of  UN and MN ,  UD also  agrees  on  all  interpretations  of 

Let  UD be  a  structure  on  τ ((cid:15)D ) ∪ UN such  that  Dom(UD ) = Dom1(MD ),  c
P
constants and predicates in τ ((cid:15)D ). In the following, we will show

UD = P

UD = c

UD |(cid:17) UD < PD ∧

(cid:12)r∗.

(A.47)

(cid:8)

r∈(cid:15)D \(cid:15)⊥

D

This is a contradiction to the fact that MD is a stable model of (cid:15)D .

(cid:13)

UN
P

UN
i

UN
i

UN
Ni

, since UN |(cid:17)

We ﬁrst show that UN is a Q-reserve extension of MN , and UN |(cid:17) UD < PD Since UN |(cid:17)
UN
1 , . . . , d

{d
= {d
Furthermore, we can see that it is impossible that for all predicates  P ∈ τ ((cid:15)D ),  P
(cid:12)r∗. This is a contradiction to the fact that UN |(cid:17) UN < PN .
U

} (i = 1, 2, 3) and Q D

}, (1 ≤ i ≤ N3). So, U

=
for predicate U P ∈ UN , where P ∈ QD ∪ QM. 
=

UN
P . Otherwise, we have  Q

UN
Q r,i, j
By the construction of UN , UD and UN agree on the interpretations of all predicates in τ ((cid:15)D ), so we also have UD |(cid:17)
UD < PD .  It  remains  to  show  UD |(cid:17) (cid:12)r∗,  where  r is  a  rule  of  the  form  (27).  If  there  is  a  rule  r ∈ (cid:15)D and  UD (cid:7)|(cid:17) r.  Then 
∗)θ and UD (cid:7)|(cid:17) α∗
i θ for all 1 ≤ i ≤ k. Note that UD and UN agree on the 
there exists a substitution θ such that UD |(cid:17) Body(r
→ α∗
interpretation of all predicates in τ ((cid:15)D ), we have UN (cid:7)|(cid:17) α∗
i )θ for all 1 ≤ i (cid:7)= j ≤ k. 
By Proposition 4, UN |(cid:17) (op(cid:9)x : U Q r,i, j (x, vi, v j) (cid:13) cn)θ for all 1 ≤ i (cid:7)= j ≤ k. This is a contradiction to the fact that UN |(cid:17) (cid:26)
r N
θ
i
and UN (cid:7)|(cid:17) α∗

i θ for all 1 ≤ i ≤ k, thus UN |(cid:17) (α∗

UN = U

MN
P

UN
r,i, j

r∈DEF

r∈CST

= U

(cid:12)r∗, we have  Q M

∗

j

UN
i

(cid:13)

i θ for all 1 ≤ i ≤ k.
This completes the proof. (cid:2)

References

[1] Mario Alviano, Wolfgang Faber, The complexity boundary of answer set programming with generalized atoms under the ﬂp semantics, in: LPNMR, 

[2] Vernon Asuncion, Fangzhen Lin, Yan Zhang, Yi Zhou, Ordered completion for ﬁrst-order logic programs on ﬁnite structures, Artif. Intell. 177–179 (2012) 

[3] Chitta Baral, Knowledge Representation, Reasoning and Declarative Problem Solving, Cambridge University Press, 2003.
[4] Michael Bartholomew, Joohyung Lee, Yunsong Meng, First-order extension of the FLP stable model semantics via modiﬁed circumscription, in: IJCAI-

2013, pp. 67–72.

1–24.

2011, 2011, pp. 724–730.

[5] Francesco Calimeri, Giovambattista Ianni, Francesco Ricca, Mario Alviano, Annamaria Bria, Gelsomina Catalano, Susanna Cozza, Wolfgang Faber, Onofrio 
Febbraro, Nicola Leone, Marco Manna, Alessandra Martello, Claudio Panetta, Simona Perri, Kristian Reale, Maria Carmela Santoro, Marco Sirianni, Giorgio 
Terracina, Pierfrancesco Veltri, The third answer set programming competition: preliminary report of the system competition track, in: LPNMR, 2011, 
pp. 388–403.

[6] Yin Chen, Fangzhen Lin, Yisong Wang, Mingyi Zhang, First-order loop formulas for normal logic programs, in: KR, 2006, pp. 298–307.
[7] Keith L. Clark, Negation as failure, in: Logics and Databases, 1978, pp. 293–322.
[8] Minh Dao-Tran, Thomas Eiter, Michael Fink, Thomas Krennwallner, Modular nonmonotonic logic programming revisited, in: ICLP, 2009, pp. 145–159.
[9] Thomas Eiter, Georg Gottlob, Heikki Mannila, Expressive power and complexity of disjunctive datalog under the stable model semantics, in: IS/KI, 1994, 

pp. 83–103.

278–298.

[10] Thomas Eiter, Giovambattista Ianni, Roman Schindlauer, Hans Tompits, A uniform integration of higher-order reasoning and external evaluations in 

answer-set programming, in: IJCAI, 2005, pp. 90–96.

[11] Wolfgang Faber, Nicola Leone, On the complexity of answer set programming with aggregates, in: LPNMR, 2007, pp. 97–109.
[12] Wolfgang Faber, Nicola Leone, Gerald Pfeifer, Aggregate functions in DLV, in: Answer Set Programming: Advances in Theory and Implementation, 2003, 

pp. 274–288.

[13] Wolfgang Faber, Gerald Pfeifer, Nicola Leone, Semantics and complexity of recursive aggregates in answer set programming, Artif. Intell. 175 (1) (2011) 

[14] Wolfgang Faber, Gerald Pfeifer, Nicola Leone, Tina Dell’Armi, Giuseppe Ielpa, Design and implementation of aggregate functions in the DLV system, 

Theory Pract. Log. Program. 8 (5–6) (2008) 545–580.

[15] Ronal Fagin, Generalized ﬁrst-order spectra and polynomial-time recognizable sets, in: Proceedings of SIAM–AMS, vol. 7, 1974, pp. 27–41.
[16] Paolo Ferraris, Logic programs with propositional connectives and aggregates, ACM Trans. Comput. Log. 12 (4) (2011) 25.
[17] Paolo Ferraris, Joohyung Lee, Vladimir Lifschitz, Stable models and circumscription, Artif. Intell. 175 (1) (2011) 236–263.
[18] Paolo Ferraris, Vladimir Lifschitz, On the stable model semantics of ﬁrst-order formulas with aggregates, in: Proceedings of the 2010 Workshop on 

Nonmonotonic Reasoning, 2010.

[19] Martin Gebser, Roland Kaminski, Benjamin Kaufmann, Torsten Schaub, On the implementation of weigh constraints in conﬂict-driven ASP solvers, in: 

Proceedings of the 25th International Conference on Logic Programming (ICLP’2009), vol. 5649, Springer Verlag, 2009, pp. 250–264.

102

V. Asuncion et al. / Artiﬁcial Intelligence 224 (2015) 72–102

[20] Michael Gelfond, Vladimir Lifschitz, The stable model semantics for logic programming, in: Proceedings of International Logic Programming Conference 

and Symposium, MIT Press, 1988, pp. 1070–1080.

[21] Joohyung Lee, Vladimir Lifschitz, Ravi Palla, A reductive semantics for counting and choice in answer set programming, in: AAAI, 2008, pp. 472–479.
[22] Joohyung Lee, Yunsong Meng, On reductive semantics of aggregates in answer set programming, in: LPNMR, 2009, pp. 182–195.
[23] Lengning Liu, Miroslaw Truszczy ´nski, Properties and applications of programs with monotone and convex constraints, J. Artif. Intell. Res. 27 (2006) 

299–334.

[24] Victor  W.  Marek,  Miroslaw  Truszczy ´nski,  Stable  models  and  an  alternative  logic  programming  paradigm,  in:  The  Logic  Programming  Paradigm: 

A 25-Year Perspective, Springer-Verlag, 1999, pp. 375–398.

[25] Ilkka Niemelä, Logic programs with stable model semantics as a constraint programming paradigm, Ann. Math. Artif. Intell. 25 (3–4) (1999) 241–273.
[26] Nikolay Pelov, Marc Denecker, Maurice Bruynooghe, Partial stable models for logic programs with aggregates, in: LPNMR, 2004, pp. 207–219.
[27] Nikolay Pelov, Marc Denecker, Maurice Bruynooghe, Well-founded and stable semantics of logic programs with aggregates, Theory Pract. Log. Program. 

[28] Enrico Pontelli, Cao Son Tran, Islam Elkabani, A treatment of aggregates in ASP (system description), in: LPNMR-2004, Springer, 2004, pp. 356–360.
[29] Patrik Simons, Ilkka Niemelä, Timo Soininen, Extending and implementing the stable model semantics, Artif. Intell. 138 (1–2) (2002) 181–234.
[30] Tran Cao Son, Enrico Pontelli, A constructive semantic characterization of aggregates in answer set programming, Theory Pract. Log. Program. 7 (3) 

[31] Tran Cao Son, Enrico Pontelli, Phan Huy Tu, Answer sets for logic programs with arbitrary abstract constraint atoms, J. Artif. Intell. Res. 29 (2007) 

7 (3) (2007) 301–353.

(2007) 355–375.

353–389.

