Artiﬁcial Intelligence 186 (2012) 1–37

Contents lists available at SciVerse ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Towards ﬁxed-parameter tractable algorithms for abstract
argumentation ✩

Wolfgang Dvoˇrák

∗

, Reinhard Pichler, Stefan Woltran

Institute of Information Systems, Vienna University of Technology, A-1040 Vienna, Austria

a r t i c l e

i n f o

a b s t r a c t

Abstract argumentation frameworks have received a lot of interest in recent years. Most
computational problems in this area are intractable but several tractable fragments have
been identiﬁed. In particular, Dunne showed that many problems can be solved in linear
time for argumentation frameworks of bounded tree-width. However, these tractability
results, which were obtained via Courcelle’s Theorem, do not directly lead to eﬃcient
algorithms. The goal of this paper is to turn the theoretical tractability results into eﬃcient
algorithms and to explore the potential of directed notions of tree-width for deﬁning larger
tractable fragments. As a by-product, we will sharpen some known complexity results.

© 2012 Elsevier B.V. All rights reserved.

Article history:
Received 16 June 2011
Received in revised form 1 February 2012
Accepted 11 March 2012
Available online 13 March 2012

Keywords:
Abstract argumentation
Fixed-parameter tractability
Tree-width
Dynamic programming
Complexity

1. Introduction

Argumentation has evolved as an important ﬁeld in AI with abstract argumentation frameworks (AFs, for short) as
introduced by Dung [20] being its most popular formalization. Meanwhile, a wide range of semantics for AFs has been
proposed (for an overview see [4]) and their complexity has been analyzed in depth. Most computational problems in this
area are intractable (see e.g. [17,24,26]), but the importance of eﬃcient algorithms for tractable fragments has been clearly
recognized (see e.g. [18]). Such tractable fragments are, for instance, symmetric argumentation frameworks [12] or bipartite
argumentation frameworks [22].

An interesting approach to dealing with intractable problems comes from parameterized complexity theory and is based
on the following observation: Many hard problems become tractable if some problem parameter is bounded by a ﬁxed
constant. This property is referred to as ﬁxed-parameter tractability (FPT). One important parameter of graphs is the tree-
width, which measures the “tree-likeness” of a graph. Indeed, Dunne [22] showed that many problems in the area of
argumentation can be solved in linear time for argumentation frameworks of bounded tree-width. This FPT result was
shown via a seminal result by Courcelle [13]. However, as stated in [22], “rather than synthesizing methods indirectly from
Courcelle’s Theorem, one could attempt to develop practical direct methods”. The primary goal of this paper is therefore to
present new, direct algorithms for certain reasoning tasks in abstract argumentation.

Clearly, the quest for FPT results in argumentation should not stop at the tree-width, and further parameters have to be
analyzed. This may of course also lead to negative results. For instance, considering as parameter the degree of an argument
(i.e., the number of incoming and outgoing attacks), Dunne [22] showed that reasoning remains intractable, even if decision

✩

This work has been funded by the Vienna Science and Technology Fund (WWTF) through project ICT08-028 and by the Austrian Science Fund (FWF)
under grant P20704-N18. A short version of this article appeared in the Proceedings of the 12th International Conference on Knowledge Representation
and Reasoning (KR 2010), AAAI Press, 2010.
* Corresponding author.

E-mail addresses: dvorak@dbai.tuwien.ac.at (W. Dvoˇrák), pichler@dbai.tuwien.ac.at (R. Pichler), woltran@dbai.tuwien.ac.at (S. Woltran).

0004-3702/$ – see front matter © 2012 Elsevier B.V. All rights reserved.
http://dx.doi.org/10.1016/j.artint.2012.03.005

2

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

problems are given over AFs with at most two incoming and two outgoing attacks. A number of further parameters is
however, still unexplored. Hence, the second major goal of this paper is to explore the potential of further parameters
for identifying tractable fragments of argumentation. In particular, since AFs are directed graphs, it is natural to consider
directed notions of width to obtain larger classes of tractable AFs. To this end, we investigate the effect of bounded cycle-
rank [28] on reasoning in AFs. We show that reasoning remains intractable even if we only consider AFs of cycle-rank 2.
Actually, many further directed notions of width exist in the literature. However, it has been recently shown [6,33,31] that
problems which are hard for bounded cycle-rank remain hard when several other directed variants of the tree-width are
bounded. A notable exception is the related notion of clique-width [14] which (in contrast to tree-width) can be directly
extended to directed graphs. Moreover, meta-theorems for clique-width [15] show that Dunne’s result on tractability with
respect to bounded tree-width extend to AFs of bounded clique-width (for details, we refer to [27]).

Still, the main focus of this paper is on novel algorithms for decision problems deﬁned over the so-called preferred
semantics of AFs. Roughly speaking, the preferred extensions of an AF are maximal admissible sets of arguments, where
admissible means that the selected arguments defend themselves against attacks. To be more precise, we present here
algorithms for the following three decision problems.

• Credulous acceptance: deciding whether a given argument is contained in at least one preferred extension of a given AF.
• Skeptical acceptance: deciding whether a given argument is contained in all preferred extensions of a given AF.
• Ideal acceptance: deciding whether a given argument is contained in an admissible set which itself is a subset of each

preferred extension of a given AF.

The problem of ideal acceptance is better known as ideal semantics [21]. To the best of our knowledge, FPT results for ideal
semantics have not been established yet, thus the algorithm that we present in the paper provides such a result as a by-
product (one could alternatively use Courcelle’s meta-theorem to obtain that result). By its very nature, the running times
of our novel algorithms will heavily depend on the tree-width of the given AF, but are linear in the size of the AF. Thus for
AFs of small tree-width, these algorithms are expected to be preferable over standard algorithms from the literature (see
e.g. [19,38]).

One reason why we have chosen the preferred semantics for our work here is that it is widely used. Moreover, admissi-
bility and maximality are prototypical properties common in many other semantics, for instance complete and stable [20],
stage [43], and semi-stable [10] semantics. Hence, we expect that the methods developed here can also be extended to
other semantics.

1.1. Summary of results

• We ﬁrst prove some negative results: we show that reasoning remains intractable in AFs of bounded cycle-rank [28].
As has been mentioned above, this negative result carries over to many other directed notions of width. We also show
that the problem of skeptical acceptance is coNP-complete for AFs of cycle-rank 1.

• We develop a dynamic programming approach to characterize admissible sets of AFs. The time complexity of our algo-
rithm is linear in the size of the AFs (as expected by Courcelle’s Theorem) with a multiplicative constant that is single
exponential in the tree-width (which is in great contrast to algorithms derived via Courcelle’s Theorem). This algorithm
can be directly used to decide the problem of credulous acceptance.

• This dynamic programming algorithm is then extended so as to cover also the preferred semantics, and thus to decide

skeptical acceptance.

• We ﬁnally show how to further adapt this algorithm to decide ideal acceptance.

1.2. Structure of the paper

In Section 2, we recall some basic notions and results on AFs and discuss some width-measures for graphs. We then
show in Section 3 some negative results for reasoning in AFs where some parameters of directed graphs are bounded. In
Section 4.1, we ﬁrst develop a dynamic programming approach for credulous acceptance in AFs of bounded tree-width. This
algorithm is then extended to cover also preferred semantics in Section 4.2 and adapted to ideal acceptance in Section 4.3.
Section 5 provides some ﬁnal conclusions as well as pointers to related and future work.

2. Background

In this section, we ﬁrst introduce argumentation frameworks and then some graph measures we want to investigate for

such frameworks.

2.1. Argumentation frameworks

We start by introducing (abstract) argumentation frameworks [20], and then recall the preferred as well as the ideal
semantics for such frameworks. Afterwards, we highlight some known complexity results for typical decision problems
associated to such frameworks.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

3

Deﬁnition 1. An argumentation framework (AF) is a pair F = ( A, R) where A is a set of arguments and R ⊆ A × A is the
attack relation. We sometimes use the notation a (cid:2) b instead of (a, b) ∈ R, in case no ambiguity arises. Further, for S ⊆ A
and a ∈ A, we write S (cid:2) a (resp. a (cid:2) S) iff there exists b ∈ S, such that b (cid:2) a (resp. a (cid:2) b). An argument a ∈ A is defended
⊕ = {b ∈ A | S (cid:2) b}.
by a set S ⊆ A iff for each b ∈ A, such that b (cid:2) a, also S (cid:2) b holds. Finally, for a set S ⊆ A we deﬁne S

An AF can naturally be represented as a directed graph.

Example 1. Let F = ( A, R) with A = {a, b, c, d, e, f , g} and R = {(a, b), (c, b), (c, d), (d, c), (d, e), (e, g), ( f , e), (g, f )}. The
graph representation of F is given as follows.

We continue with a few basic concepts and the deﬁnition of preferred extensions as introduced in Dung’s seminal

paper [20] as well as the concept of ideal sets as proposed by Dung, Mancarella and Toni [21].

Deﬁnition 2. Let F = ( A, R) be an AF. A set S ⊆ A is conﬂict-free (in F ), iff there are no a, b ∈ S, such that (a, b) ∈ R. A set
S ⊆ A is admissible for F , if S is conﬂict-free in F and each a ∈ S is defended by S in F . We denote the collection of all
admissible extensions of F by adm(F ).

Deﬁnition 3. Let F = ( A, R) be an AF. A set S ⊆ A is a preferred extension of F , iff S is a maximal (w.r.t. subset inclusion)
admissible set for F . We denote the collection of all preferred extensions of F by pref (F ).

Deﬁnition 4. Let F = ( A, R) be an AF. A set S ⊆ A is called ideal for F , if S ∈ adm(F ) and S is a subset of all preferred
extensions (i.e., S ⊆

P ∈pref (F ) P ). We denote the collection of all ideal sets of F by ideal(F ).

(cid:2)

An admissible set S is called complete, if each argument defended by S is contained in S. It was shown in [21] that each
AF F possesses a unique maximal ideal set (called the ideal extension of F ) and that this set is also a complete extension
of F .

Example 2. For the AF F in Example 1, we get as admissible sets {}, {a}, {c}, {d}, {d, g}, {a, c}, {a, d}, and {a, d, g}. Conse-
quently, pref (F ) = {{a, c}, {a, d, g}}, and moreover, ideal(F ) = {{}, {a}}. Thus, {a} is the ideal extension of F .

Next, we recall the complexity of reasoning over preferred and ideal extensions. To this end, we deﬁne the decision
problems of credulous acceptance (CA), skeptical acceptance (SA) and ideal acceptance (ID) which have as input an AF
F = ( A, R) and an argument a ∈ A:

• CA: Is a contained in some S ∈ pref (F )?
• SA: Is a contained in each S ∈ pref (F )?
• ID: Is a contained in some S ∈ ideal(F )?

Note that the problem ID is equivalent to deciding whether a is contained in the ideal extension of F .
It is known that CA is NP-complete, while SA is Π P

2 -complete (see [17,24]). The reason why CA is located on a lower
level of the polynomial hierarchy compared to SA, is the fact that it is suﬃcient to check whether a is contained in at least
one admissible set for the given AF F . Then a is also contained in a preferred extension of F . In other words, the maximality
requirement of preferred extensions does not come into play for CA. For SA, the situation is different, and maximality has
to be taken into account, leading to an additional source of complexity. The exact complexity of ID is still an open problem1
but for the lower bound it is known that ID is coNP-hard and as an upper bound membership in Θ P
2 has been shown
(see [23]). Hence, under usual complexity-theoretic assumptions SA is harder to decide than CA and ID. Moreover, the
analysis in [23] suggests that ID might be mildly harder than CA. As we will see later, these theoretical observations are to
some extent mirrored by the running times of our algorithms.

2.2. Parameters for graphs

We review several notions of parameters for graphs (both directed and undirected). One of the most important concepts

for ﬁxed-parameter tractability on graphs is the tree-width, which was introduced by Robertson and Seymour [40].

1 To be more precise, [23] gives an exact Θ P

2 -hardness lower bound in terms of randomized reductions. The open aspect of the problem is thus whether

the random element in this reduction can be eliminated in order to obtain Θ P

2 -hardness under the standard polynomial-time many-one reductions.

4

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

Fig. 1. A tree decomposition of the graph in Example 1.

To start with, we recall the concept of an induced subgraph: given a graph G = (V , E) and a set A, we write G| A =

(V ∩ A, E ∩ ( A × A)) for the subgraph of G induced by A.

Deﬁnition 5. Let G = (V , E) be an undirected graph. A tree decomposition of G is a pair (T , X ) where T = (V T , ET ) is a
tree and X = ( Xt)t∈V T is a set of so-called bags, which has to satisfy the following conditions:

(cid:3)

t∈V T Xt = V , i.e. X is a cover of V ,
1.
2. for each v ∈ V , T |{t|v∈ Xt } is connected,
3. for each {v i, v j} ∈ E, {v i, v j} ⊆ Xt for some t ∈ V T .

The width of such a tree decomposition is given by max{card( Xt) | t ∈ V T } − 1. The tree-width of a graph G is the

minimum width over all tree decompositions of G.

As already mentioned, the concept of tree-width is deﬁned for undirected graphs but can also be applied to directed

graphs and thus to AFs.

Deﬁnition 6. Let F = ( A, R) be an AF. A tree decomposition of the undirected graph ( A, R
contains the edges of
R without orientation is called a tree decomposition of F . The tree-width of an AF F is given by the minimum width over
all tree decompositions of F .

(cid:7)) where R

(cid:7)

It was shown by Bodlaender [7] that, for ﬁxed w (cid:3) 1, it can be decided in linear time whether a graph has tree-width
at most w. Moreover, in case of a positive answer, a tree decomposition of width w can be computed in linear time. Fig. 1
shows a tree decomposition of width 2 for the AF from Example 1 (when considered as an undirected graph).

Many NP-hard problems on graphs have been shown to be linear time computable on graphs of bounded tree-width. In
particular, Courcelle’s Theorem [13] provides a powerful tool to obtain such results. It states that any property over graphs
which can be expressed in Monadic Second-Order Logic, can be decided in linear time (w.r.t. to the size of the graph) for
graphs which have bounded tree-width. Dunne [22] used this result to show ﬁxed-parameter tractability of the problems
CA and SA for the parameter tree-width.

However, there is a certain problem when using tree-width in the area of directed graphs. In fact, there are many
digraphs which we intuitively consider as simply structured but already have high tree-width. As an example consider the
acyclic digraphs of the form (n (cid:3) 1)
(cid:6)
(cid:6) 1 (cid:4) i < j (cid:4) n

(cid:4)
{a1, . . . , an},

Gn =

(ai, a j)

(1)

(cid:7)(cid:8)

(cid:5)

.

For n = 5, Gn looks as follows

Seen as undirected graph, each Gn turns into a clique of size n. Thus, the tree-width of the graphs Gn (with increasing n)

cannot be bounded by a constant.

As AFs are directed graphs, it seems natural to consider parameters exclusively deﬁned for digraphs. Indeed, many
such measures exist like directed tree-width [35], DAG-width [6] or Kelly-width [33]. An old but particularly interesting
parameter, which we shall focus on here, is cycle-rank [28]. One reason why there are many different such notions is due to
the fact that, so far, no analogue to Courcelle’s Theorem which is comparably general has been found for digraph problems.2
Before giving the deﬁnition of cycle-rank, we recall some basic deﬁnitions: we call a graph acyclic, if it does not contain
a cycle going through distinct vertices. In other words, self-loops are not considered as cycles. A directed graph is strongly
connected, if each vertex is reachable from any other vertex in this graph. Finally, a strongly connected component (SCC) of a
graph G is an induced subgraph G|S of G such that S is maximal with the property that G|S is strongly connected.

2 As mentioned in the introduction, (directed) clique-width is a notable exception; we again refer to [27] for a more detailed discussion.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

5

Deﬁnition 7. Let G = (V , E) be a directed graph. The cycle-rank r(.) of G is deﬁned as follows: an acyclic graph has r(G) = 0;
if G is strongly connected then r(G) = 1 + minv∈V r(G|V \{v}). If G is not strongly connected, then r(G) is the maximum
cycle-rank among all SCCs of G.

Intuitively, the cycle-rank corresponds to the maximum recursion depth of a procedure which – in each call – eliminates
one node per SCC until we have an acyclic graph. Note that the graphs Gn of the form (1) are acyclic and, thus, have
cycle-rank 0 for any n.

The cycle-rank is of particular interest because recent results [6,31,33] showed that problems which are hard for bounded
cycle-rank also remain hard when some of the other aforementioned parameters are bounded. Indeed, in Section 3 we shall
prove several intractability results for AFs with bounded cycle-rank. These intractability results thus immediately carry over
to the other parameters for directed graphs.

For a similar intractability result, Dunne [22] has recently shown that CA and SA remain intractable for AFs with
bounded in- and out-degree. The following example illustrates that the class of graphs with bounded cycle-rank is in-
comparable with the class of graphs with bounded in- and out-degree.

Example 3. Let (Hn = (V n, En))n(cid:2)1 be a family of directed graphs with V n = {x1, . . . , xn, y1, . . . , yn} and En = {(xi, yi),
( yi, xi) | 1 (cid:4) i (cid:4) n} ∪ {(xi, xi+1), ( yi+1, yi) | 1 (cid:4) i (cid:4) n − 1}. As an example, the graph H 5 looks as follows

It is easy to see that the in- and out-degrees of these graphs are bounded by 2, but that these graphs are of arbitrary
cycle-rank.

As another example,

let (In = (V n, En))n(cid:2)1 be the family of directed graphs with V n = {x1, . . . , xn, x} and En =

{(x, xi), (xi, x) | 1 (cid:4) i (cid:4) n}. The graph I5 looks as follows

Each graph In has cycle-rank 1, but the graphs of form In which have arbitrary in- and out-degree.

3. Parameters for directed graphs – negative results

3.1. Bounded cycle-rank

We continue to prove that NP-hardness for CA holds, even if we restrict ourselves to AFs with bounded cycle-rank.
We employ the reduction from [17] which maps each instance (i.e. a CNF formula) of the NP-hard problem SAT to an
argumentation framework.

Deﬁnition 8. Given a CNF formula Φ =

(cid:9)

m

j=1 C j with C j being clauses over variables Z , deﬁne F Φ = ( A, R) with

(cid:5)

A = {Φ, C1, . . . , Cm} ∪ Z ∪ ¯Z ,
(cid:5)
(z, ¯z), (¯z, z)
∪
(C j, Φ) | 1 (cid:4) j (cid:4) m
R =
(cid:6)
(cid:5)
(cid:6) z occurs in C j, 1 (cid:4) j (cid:4) m
∪
where ¯Z = {¯z | z ∈ Z } is a set of fresh arguments.

(z, C j)

(cid:7)

(cid:7)

(cid:6)
(cid:6) z ∈ Z
(cid:5)
(cid:7)
∪

(¯z, C j)

(cid:6)
(cid:6) ¬z occurs in C j, 1 (cid:4) j (cid:4) m

(cid:7)

Example 4. Consider the CNF formula

Φ = (z1 ∨ z2 ∨ z3) ∧ (¬z2 ∨ ¬z3 ∨ ¬z4) ∧ (¬z1 ∨ z2 ∨ z4).

Fig. 2 illustrates the corresponding AF F Φ .

For any CNF formula Φ, F Φ can be constructed in polynomial time, and Φ is satisﬁable iff argument Φ is credulously
accepted in F Φ . This gives the NP-hardness for CA, ﬁrst shown by Dimopoulos and Torres [17] and later rephrased in terms
of AFs by Dunne and Bench-Capon [24]. We strengthen this result as follows.

6

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

Fig. 2. AF F Φ for CNF formula Φ in Example 4.

Theorem 1. CA is NP-hard, even if the problem is restricted to AFs of cycle-rank 1.

Fig. 3. AF GΨ for QBF Ψ in Example 5.

Proof. As discussed above, AFs F of the form given in Deﬁnition 8 provide us with a valid reduction from SAT to CA. To
prove the assertion it is thus suﬃcient to show that for each CNF formula Φ, the corresponding AF F has at most cycle-
rank 1. Indeed, such an AF F has the following SCCs: F |{z,¯z} for each z ∈ Z and the singletons C1, . . . , Cm, and Φ. Obviously,
components F |{z,¯z} have cycle-rank 1 and all other components have cycle-rank 0. Hence, each F constructed following
Deﬁnition 8 has cycle-rank 1. (cid:2)

We now turn our attention to the Π P

2 -hard problem SA. The following reduction from QBFs to AFs is used in [24].

Deﬁnition 9. Given a QBF Ψ = ∀Y ∃Z
with

(cid:9)

m

j=1 C j with C j being clauses over variables X = Y ∪ Z . We deﬁne the AF GΨ = ( A, R)

(cid:5)

A = {Ψ, C1, . . . , Cm} ∪ X ∪ ¯X ∪ {b1, b2, b3},
(cid:6)
(cid:6)
(cid:6) x ∈ X
(cid:6) 1 (cid:4) j (cid:4) m
(x, ¯x), (¯x, x)
∪
R =
(cid:6)
(cid:5)
(cid:7)
(cid:6) x occurs in C j, 1 (cid:4) j (cid:4) m
∪

(C j, Ψ )
∪

(x, C j)

(cid:5)

(cid:7)

(cid:5)

(cid:7)

(cid:5)

(cid:7)
(Ψ, b1), (Ψ, b2), (Ψ, b3)

∪

∪

(cid:5)

(¯x, C j)
(cid:7)
(b1, b2), (b2, b3), (b3, b1)

(cid:6)
(cid:6) ¬x occurs in C j, 1 (cid:4) j (cid:4) m
(cid:6)
(cid:6) z ∈ Z

(b1, z), (b1, ¯z)

∪

(cid:5)

(cid:7)

(cid:7)

where ¯X = {¯x | x ∈ X} is a set of fresh arguments.

Example 5. Consider the QBF

Ψ = ∀ y1 y2∃z3z4( y1 ∨ y2 ∨ z3) ∧ (¬ y2 ∨ ¬z3 ∨ ¬z4) ∧ (¬ y1 ∨ y2 ∨ z4).

In Fig. 3, we depict the corresponding AF GΨ .

As shown by Dunne and Bench-Capon [24], the following holds for each QBF Ψ of the above form: Ψ is valid iff argument
2 -hardness

Ψ is contained in each S ∈ pref (GΨ ). Since GΨ can be constructed from Ψ in polynomial time, this showed Π P
of the problem SA. We strengthen this result as follows.

Theorem 2. SA is Π P

2 -hard, even if the problem is restricted to AFs of cycle-rank 2.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

7

Fig. 4. AF HΦ for CNF formula Φ in Example 6.

(cid:9)

Proof. We can proceed similarly as in the proof of Theorem 1. Moreover, we are allowed to restrict ourselves to QBFs Φ of
the form ∀Y ∃Z
m
j=1 C j where each C j contains at least one occurrence of an atom from Z ; the validity problem for such
QBFs obviously remains Π P

2 -hard. Each AF G according to Deﬁnition 9 has the following SCCs:

• G|{ y, ¯y} for each y ∈ Y ;
• G|S for S = {z, ¯z | z ∈ Z } ∪ {C1, . . . , Cm, Φ, b1, b2, b3}.

Components G|{ y, ¯y} have cycle-rank 1, and H = G|S has cycle-rank 2. This can be seen as follows: Removing Φ leads to
SCCs H|{z,¯z} (for each z ∈ Z ), H|{b1,b2,b3}, and singletons C1, . . . , Cm. All these have cycle-rank 1 or 0. (cid:2)

We now turn our attention to the coNP-hard problem ID. The following reduction from CNF formulas to AFs is a slightly

modiﬁed version of that given by Dunne [23].

Deﬁnition 10. Given a formula Φ =

(cid:9)

m

j=1 C j in CNF over variables Z . We deﬁne the AF HΦ = ( A, R) with

(cid:5)

A = {Φ, C1, . . . , Cm} ∪ Z ∪ ¯Z ∪ {Ψ },
(cid:6)
(cid:6) 1 (cid:4) j (cid:4) m
(z, ¯z), (¯z, z)
∪
R =
(cid:6)
(cid:6) z occurs in C j, 1 (cid:4) j (cid:4) m

(C j, Φ)
∪

(z, C j)

(cid:5)

(cid:7)

(cid:5)

(cid:7)

(cid:6)
(cid:6) z ∈ Z
(cid:5)
(cid:7)
∪

(cid:5)

(cid:7)
(Ψ, Φ), (Φ, Ψ )

∪

(¯z, C j)

(cid:6)
(cid:6) ¬z occurs in C j, 1 (cid:4) j (cid:4) m

(cid:7)

where ¯Z = { ¯Z | z ∈ Z } is a set of fresh arguments.

Example 6. Recall the CNF formula Φ from Example 4, i.e.

Φ = (z1 ∨ z2 ∨ z3) ∧ (¬z2 ∨ ¬z3 ∨ ¬z4) ∧ (¬z1 ∨ z2 ∨ z4).

Fig. 4 illustrates the corresponding AF HΦ .

As shown by Dunne [23], the following holds for each formula Φ of the above form: Φ is unsatisﬁable iff the argu-
ment Ψ is contained in the ideal extension.3 Since HΦ can be constructed from Φ in polynomial time, coNP-hardness of
the problem ID follows. We strengthen this result as follows.

Theorem 3. ID is coNP-hard, even if the problem is restricted to AFs of cycle-rank 1.

Proof. We can proceed similar as in the proofs of Theorems 1 and 2. Let H be an arbitrary AF which follows Deﬁnition 10.
Then H has the following SCCs: H|{z,¯z} for each z ∈ Z , the singletons C1, . . . , Cm, and H|{Φ,Ψ }. Each of these components
either has cycle-rank 1 or cycle-rank 0 and thus each H constructed following Deﬁnition 10 has cycle-rank 1. (cid:2)

Theorems 1–3 show that the parameter cycle-rank is not applicable for ﬁxed-parameter tractability of the considered
problems. However, these theorems leave some room for potential tractable fragments. First, consider the class of AFs
of cycle-rank 0. By deﬁnition this is the class of acyclic AFs and it is well known that the acceptance problems under

3 We note that the proof given by Dunne also works for our slightly modiﬁed reduction.

8

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

consideration are tractable for acyclic AFs (there is a single preferred extension which coincides with the so-called grounded
extension – for details see [20]). It thus remains to classify the complexity of skeptical acceptance for AFs of cycle-rank 1.
Using the reduction to the AF HΦ from Deﬁnition 10, we immediately get that this problem is still coNP-hard, i.e. it does
not form a tractable fragment in the usual sense. Nevertheless, we next show that also coNP membership holds for skeptical
acceptance when restricted to AFs of cycle-rank 1. Hence, this fragment turns out to be computationally easier, bearing in
mind that SA is Π P

2 -complete in general.

Theorem 4. SA is in coNP for AFs of cycle-rank 1.

Proof. To prove SA ∈ coNP we provide a polynomial-time algorithm for verifying that a given set is a preferred extension.
Then one can build a coNP algorithm for SA by deciding its complement by a standard guess and check approach. To
verify whether a set E is a preferred extension of an AF F = ( A, R) we ﬁrst compute the SCCs and build a linear order
S1, . . . , Sm of the SCCs which respects the partial order given by the attacks between different components, i.e. for i < j we
have that S j (cid:13)(cid:2) S i . Note that both the identiﬁcation of SCCs and obtaining such a linear order can be done in polynomial
time by depth-ﬁrst search. Now one can decide the veriﬁcation problem by considering each SCC separately starting with
{in,def ,undec} which maps vertices
S1 and then following the linear ordering. Therefore, we use a multi-labeling M : V S → 2
to sets of labels, as well as ordinary labelings L : V S → {in, def , undec} (see [11]). Intuitively such a labeling corresponds
if
to an extension in the following way: an argument is labeled in if it is in the extension. An argument is labeled def
it is not in the extension and attacked by some argument in the extension. Intuitively, the label def
indicates that the
extension is “defended” against potential attacks from this argument. Finally, an argument is labeled undec if it is neither
in the extension nor attacked by an argument in the extension. Intuitively, the label undec indicates that the status of this
argument is in a sense “undecided” yet.

The multi-labeling will be used as a certain form of initialization of the currently considered SCC S j (for j > 1 this might
take results from SCCs S i with i < j into account); ordinary labelings are then obtained from M by taking a designated
argument as a starting point and are ﬁnally compared to the candidate E.

The veriﬁcation algorithm (see also Example 7 below for illustration) for a given AF F = ( A, R) with linearly ordered

SCCs S1, . . . , Sm and a set of arguments E is as follows and loops over j with 1 (cid:4) j (cid:4) m.

1. First, initialize a multi-labeling M j with M j(a) = {in, def , undec}, for all vertices a in S j . For each attack (a, b) in F

with a ∈ S i , b ∈ S j and i < j, we set
M j(b) := M j(b) \ {in, undec}
M j(b) := M j(b) \ {in}

if a ∈ E,
if a /∈ E ∧ E (cid:13)(cid:2) a.
2. Identify an argument x ∈ S j such that S j \ {x} is acyclic.
3. Compute a labeling Ll

j for each label l ∈ M j(x) as follows: Ll

j(x) = l and for all vertices a (cid:13)= x in S j :

⎧
⎪⎨

⎪⎩

in

def

Ll

j(a) =

if in ∈ M j(a) ∧ ∀b ∈ S j: b (cid:2) a ⇒ Ll
if M j(a) = {def } or ∃b ∈ S j: Ll

j(b) = def ,
j(b) = in ∧ b (cid:2) a,

undec otherwise.
4. Verify the status of the selected argument x in labelings Ll
j :

is valid iff ∀b ∈ S j: b (cid:2) x ⇒ Ll
j(b) = def ;
is valid iff M j(x) = {def } or ∃b ∈ S j: Ldef
j

(b) = in ∧ b (cid:2) x;

• Lin
j

• Ldef
j
• Lundec
j

is valid anyway.

Let L j be the set of valid labelings for S j .

5. Deﬁne

(cid:14)

L

∗
j

=

L j
L j \ {Lundec
6. Veriﬁcation: Reject, if there is no L ∈ L

j
} otherwise.

j

if L j = {Lundec

},

∗
j such that for all vertices a in S j it holds that L(a) = in iff a ∈ E; otherwise

continue with the next SCC.

If the above algorithm terminates without rejecting E, then E is a preferred extension.

To show the correctness of the veriﬁcation algorithm we exploit the following result form [5] (Proposition 41): For E ⊆ A
it holds that E ∈ pref (F ) iff for each SCC S of F it holds that E ∩ S is the ⊆-maximal admissible set of (S \ (E \ S)⊕, R ∩ S × S)
satisfying that no argument is attacked by A \ (S ∪ E

⊕).

Our algorithm iterates over all SCCs S i testing the above conditions for E being preferred. In Step 1 for each argument
we set M j(b) := {def } excluding argument b from having any effect in the subsequent computation, i.e.

b ∈ S ∩ (E \ S)⊕

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

9

restricting the set S to S \ (E \ S)⊕
labels for b, implementing that b cannot be contained in the admissible sets.

. Moreover, for each argument b attacked by A \ (S ∪ E

⊕) we exclude in from the possible

The Steps 2–5 are used to compute these ⊆-maximal admissible sets. In Step 2 we use the fact that, by deﬁnition,
cr(F ) (cid:4) 1 iff for each SCC S = ( A S , R S ) of F , there is an argument x ∈ A S , such that S| A S \{x} is acyclic. We note that this
can be easily done in polynomial time. In Steps 3–4 we compute all labelings that are (i) admissible and (ii) are candidates
for being ⊆-maximal. By deﬁnition of a labeling we have that an argument is labeled def iff it is attacked by an argument
labeled in (the condition M j(a) = {def } just ignores arguments in S ∩ (E \ S)⊕
). By (i) we have that if an argument is
labeled in it has to be defended, i.e. all of its attackers have to be labeled def [11]. Further by (ii) we have that each
⊕), actually has to be in an extension. We obtain the
argument defended by an extension and not attacked by A \ (S ∪ E
conditions to compute Ll
j(a). Note that given the label of the selected argument x, we can compute the labels of all other
arguments in S j by a ﬁnite recursion (due to the fact that the SCC without x is acyclic).

However, in Step 4 we have to check whether the computed labels are compatible with the label of x, i.e. we have to
verify if the computed label is really an admissible labeling. For the case where we labeled x with in, we have to check
whether x is defended with respect to labeling Lin

j . Similar, for l = def , we have to check whether x is attacked.

In Step 5 we address the ⊆-maximality of the valid labelings. The extensions corresponding to Lin

are clearly not
in ⊆-relation as one contains x and the other extension contains at least one attacker of x. On the other hand, we have
that in the recursion in Step 3, switching a def or in label to undec never gives rise to a new in or def label. Hence, the
extension corresponding to Lundec
is in ⊆-relation to the extensions corresponding to Lin
contains the argument x nor an attacker of x they are also in ⊂-relation. Hence if Lin
then Lundec

j and resp. Ldef

are admissible labelings

j and Ldef

and as it neither

is not maximal.

j , Ldef

j

j

j

j

j

Finally in Step 6 we test whether E ∩ S corresponds to one of the maximal admissible sets. (cid:2)

Example 7. For illustration of this algorithm consider the AF F = ({a, b, c, d, e}, {(a, b), (b, c), (c, d), (d, e), (e, b)}) and the set
E = {a, c}.

We have two SCCs S1 = F |{a} and S2 = F |{b,c,d,e}. First we apply our algorithm to S1. Since S1 is an initial SCC, its multi-
labeling is given by M1(a) = {in, def , undec}. S1 has only one argument, we thus select x = a in Step 2 and get the following
three labelings Lin
1 (a) is not
1 (a) = in, we now have that E is
valid (Step 4). In Step 5, we obtain L
valid on S1 and we thus continue the algorithm with SCC S2.

(a) = in in Step 3. As there is no argument attacking a, Ldef
} \ {Lundec
1

1 (a) = def and Lundec
1 , Lundec
= {Lin

}. As a ∈ E and Lin

1 (a) = in, Ldef

For the multi-labeling M2 we have that M2(c) = M2(d) = M2(e) = {in, def , undec} and M2(b) = {def }. The latter
equality holds because a ∈ E and a (cid:2) b. In the next step we have four options for argument x to make S 2 acyclic. Let us
consider x = d. We compute three labelings Lin

. They are given as follows:

} = {Lin
1

∗
1

1

1

and Lundec
2

2 (b) = def ,
Lin
Ldef
2 (b) = def ,
Lundec
2

(b) = def ,

2 (c) = in,
Lin
Ldef
2 (c) = in,
Lundec
2

(c) = in,

2

2 , Ldef
2 (d) = in,
Lin
Ldef
2 (d) = def ,
Lundec
2

2 (e) = def ,
Lin
Ldef
2 (e) = in,
Lundec
2

(d) = undec,

(e) = undec.

2 is not valid, because of the fact that c (cid:2) d and Lin

The labeling Lin
Ldef
2 (e) = in but e /∈ E, E is rejected by the algorithm.
It is easy to see that {a, c, e} is the only set that would be accepted by the algorithm, which mirrors the fact that {a, c, e}

2 (c) = in. Hence we have that L

}. Now, since

= {Ldef
2

∗
2

is the only preferred extension of F .

Remark. The problem SA is closely related to the problem of deciding whether an AF is coherent [24], that is checking
whether the stable and preferred extensions of the AF coincide. Stable extensions of an AF ( A, R) are deﬁned as conﬂict-free
sets S ⊆ A such that S attacks each argument from A \ S. In general, deciding whether an AF is coherent is Π P
2 -complete,
which can be shown using the reduction GΨ [24]. Hence the problem clearly remains Π P
2 -hard for AFs of cycle-rank 2, but
one might be interested whether this problem also becomes easier for cycle-rank 1.

In the proof of Theorem 4 we have shown that for AFs of cycle-rank 1 one can decide in polynomial time whether a
given set is a preferred extension. This gives rise to a simple coNP algorithm for deciding coherence of an AF. First, non-
deterministically guess a set E and then perform a polynomial-time test whether E is a preferred extension and whether
E is a stable extension. If E is preferred and not stable one has found a counter-example for coherence. Moreover, coNP-
hardness can be shown by using the reduction HΦ ∪ ({b}, {(Ψ, b), (b, b)}).

10

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

3.2. Further directed graph measures

Fig. 5. An arboreal decomposition for the AF in Example 1.

In this section we extend our hardness results to some popular parameters for directed graphs, namely for directed tree-
width, DAG-width, Kelly-width, and directed path-width. We ﬁrst review the deﬁnition of directed tree-width [35]. Hereby,
the so-called arboreal decomposition is built similarly to a tree decomposition: an arboreal decomposition also consists of a
tree and “bags”, i.e., sets of vertices of the graph that we want to decompose. However, in contrast to tree decompositions
of undirected graphs, the bags in an arboreal decomposition can be used both as vertex labels and as edge labels in the
tree. The bags used as vertex labels build a partition of the vertices of the original graph. The bags used as edge labels
are vertex sets that concern the subtree rooted at the target vertex of the associated edge; in particular they isolate the
subgraph induced by the union of the vertex bags in this subtree. This means that every path which starts and ends – but
leaves the subgraph – comes across a vertex which is in the edge bag.

The following deﬁnition makes these concepts formal. It is convenient to introduce the following notation ﬁrst. For
t ∈ V T and e = (u, v) ∈ ET we write t > e iff v = t or there exists a path from v to t in T . Moreover, for e = (u, v) ∈ ET ,
we use the term e ∼ t to denote that either u = t or v = t holds.

Deﬁnition 11. Let G = (V , E) be a directed graph. An arboreal decomposition of G is a tuple (T , X , Y) where T = (V T , ET )
is a directed tree with a unique root and X = ( Xt)t∈V T , Y = (Y e)e∈ET are families of subsets of V , such that

1. X is a partition of V G into non-empty sets;
2. for each e ∈ E T , there is no directed path in G|V \Y e with ﬁrst and last vertex in X(cid:2)e :=

vertex in V \ (Y e ∪ X(cid:2)e).

(cid:3)

{ Xt | t > e} that contains a

The width of an arboreal decomposition is maxt∈V t
is the smallest width of any arboreal decomposition.

{card( Xt ∪

(cid:3)

e∼t Y e)} − 1. The directed tree-width of G (denoted as dtw(G))

Example 8. Recall the AF F from Example 1. Below, we deﬁne an arboreal decomposition (T , X , W) of the corresponding
graph interpretation. For simplicity, we identify each node t ∈ T with the corresponding bag Xt . The arboreal decomposition
is as follows:

• V T = X = {{c, d}, {a}, {b}, {e}, { f }, {g}};
• ET = {({c, d}, {a}), ({c, d}, {b}), ({c, d}, {e}), ({e}, { f }), ({e}, {g})};
• Y = (Y y) y∈ET with Y ({e},{ f }) = {e}, Y ({e},{g}) = {e} and Y y = ∅ for the other edges in ET .

For an illustration of the decomposition, see Fig. 5. We mention that this decomposition has width 1. For example, consider
the cycle e, g, f of the AF. In our decomposition the cycle is partitioned in three nodes such that the nodes { f }, {g} are
successors of {e}. Now given { f }, we have a path in F , namely f , e, g, f , which starts and ends in the bag { f } but leaves
the bag. Thus to fulﬁll condition 2 for being an arboreal decomposition, one has to add either e or g to the edge bag of
({e}, { f }). For similar reasons we have to add either e or f to the edge bag of ({e}, {g}). In both cases we decided to add e
as it is already contained in the predecessor’s vertex bag, i.e. in {e}, and thus does not increase the width generated by the
predecessor node, while in any case it increases the width generated by the node { f } resp. {g}.

We do not require explicitly the deﬁnitions of the other three graph parameters mentioned in this paper. Instead, we
only provide a summary of results compiled together from [6,33,31]; the reader is referred to [2,6,33] for formal deﬁnitions
of the parameters of DAG-width, Kelly-width and directed path-width.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

11

Fig. 6. Propagation of hardness results for directed graph measures (see Proposition 1).

Proposition 1. For any directed graph G the following relations hold:

(cid:4)

(cid:4)

dtw(G) − 1

dtw(G) + 2

(cid:8)
/3 (cid:4) dagw(G) (cid:4) dpw(G) + 1 (cid:4) cr(G) + 1,
(cid:8)
/6 (cid:4) kellyw(G) (cid:4) dpw(G) + 1 (cid:4) cr(G) + 1

where dagw(G), kellyw(G), and dpw(G) denote the DAG-width, Kelly-width, and directed path-width of G, respectively.

Indeed, this proposition allows us to obtain hardness results for directed tree-width, DAG-width, Kelly-width and directed
path-width from the corresponding hardness result for cycle-rank, which we have obtained in the previous subsection.
Fig. 6 illustrates how a hardness result for one of the above mentioned graph measures can be propagated to the other
graph measures. The following corollaries exploit this result, but use distinct proof-arguments for the parameter of directed
tree-width.

Corollary 1. CA is NP-hard even for

• AFs of directed path-width 1;
• AFs of DAG-width 2;
• AFs of Kelly-width 2;
• AFs of directed tree-width 1.

Proof. While the results for directed path-width, DAG-width and Kelly-width follow directly from Proposition 1, we give
an explicit proof for NP-hardness of CA over AFs with directed tree-width 1 (Proposition 1 only provides hardness for AFs
of directed tree-width 7). To this end, we construct arboreal decompositions (T , X , W) for frameworks of the form FΦ as
given in Deﬁnition 8.

• V T = X = {{z1, ¬z1}, . . . , {zn, ¬zn}, {C1}, . . . , {Cm}, {Φ}};
• ET = {({Φ}, {zi, ¬zi}) | 1 (cid:4) i (cid:4) n} ∪ {({Φ}, {Ci}) | 1 (cid:4) i (cid:4) m};
• Y = (Y e)e∈ET with Y e = ∅ for all e ∈ ET .

This arboreal decomposition has width 1 and by the fact that FΦ contains a clique of size 2, namely {z, ¯z}, we conclude
that dtw(FΦ ) = 1. (cid:2)

12

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

Corollary 2. SA is Π P

2 -hard even for

• AFs of directed path-width 2;
• AFs of DAG-width 3;
• AFs of Kelly-width 3;
• AFs of directed tree-width 2.

Proof. As before the results for directed path-width, DAG-width and Kelly-width follow directly from Proposition 1 and we
have to construct appropriate arboreal decompositions for AFs of the form GΨ as given in Deﬁnition 9 to show the desired
hardness result for AFs of directed tree-width 2.

• V T = X = {{ y1, ¬ y1}, {z1, ¬z1}, . . . , { yn, ¬ yn}, {zn, ¬zn}, {C1}, . . . , {Cm}, {Ψ }, {b1}, {b2}, {b3}};
• ET = {({Ψ }, { yi, ¬ yi})} ∪ {({Ψ }, {zi, ¬zi})} ∪ {({Ψ }, {Ci})} ∪ {(Ψ, bi)};
• Y = (Y e)e∈ET with
{Ψ }
{b1}
{Ψ, b3}
∅

for e = ({Ψ }, {Ci}) or ({Ψ }, {zi, ¬zi}),
for e = ({Ψ }, {b2}) or e = ({Ψ }, {b3}),
for e = ({Ψ }, {b1}),
otherwise.

⎧
⎪⎪⎨
⎪⎪⎩

Y e =

One can see that this arboreal decomposition has width 2 and further one can show that dtw(GΨ ) = 2. (cid:2)

Corollary 3. ID is coNP-hard even for

• AFs of directed path-width 1;
• AFs of DAG-width 2;
• AFs of Kelly-width 2;
• AFs of directed tree-width 1.

Proof. Once more the results for directed path-width, DAG-width and Kelly-width follow directly from Proposition 1. To
show hardness for AFs of directed tree-width 1, we give arboreal decompositions for AFs of the form HΦ (see Deﬁnition 10).

• V T = X = {{z1, ¬z1}, . . . , {zn, ¬zn}, {C1}, . . . , {Cm}, {Φ, Ψ }};
• ET = {({Φ}, {zi, ¬zi}): 1 (cid:4) i (cid:4) n} ∪ {({Φ}, {Ci}): 1 (cid:4) i (cid:4) m};
• Y = (Y e)e∈ET with Y e = ∅ for all e ∈ ET .

One can see that this arboreal decomposition has width 1 and by the presence of cliques of size 2, dtw(HΦ ) = 1 follows. (cid:2)

To summarize, we have shown that none of the parameters cycle-rank, directed tree-width, DAG-width, Kelly-width, and
directed path-width is applicable for ﬁxed-parameter tractability results. Hence, we observe that directed graph measures
generalizing tree-width are not well suited for the reasoning problems CA, SA, and ID on AFs.

An explanation for this obstacle is that argumentation semantics are based on conﬂict-freeness of the extension which
is an undirected property, i.e. the orientation of the attacks does not play a role, and thus cannot be captured well by the

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

13

measures discussed in this subsection. As the standard reasoning tasks are computationally easy for (maximal) conﬂict-
free sets one might expect that conﬂict-freeness does not harm when searching for tractable fragments. But there are also
problems which are hard for conﬂict-free sets. For instance, the problem of counting for maximal conﬂict-free sets is #P-
hard, this was originally shown by Valiant [41] (in terms of counting maximal cliques) and was recently applied to abstract
argumentation [3]. Thus the above #P-hardness result is an evidence against the existence of tractability results based on
directed graph measures.

The above results leave some space for tractable fragments when bounding directed tree-width, DAG-width, Kelly-width
or directed path-width to 0, 1 or 2. Taking the minimal bounds into account (by deﬁnition, 0 for directed path-width and
directed tree-width and resp. 1 for DAG-width and Kelly-width) leads to acyclic AFs which are trivially tractable. Moreover,
using Corollary 3, we can show that skeptical acceptance is still coNP-hard for AFs of directed path-width 1, DAG-width 2,
Kelly-width 2 or directed tree-width 1. We leave the exact complexity classiﬁcation for these particular fragments as open
problems.

We now come back to the parameter of tree-width, which, in contrast to the parameters discussed in this section, allows

for ﬁxed-parameter tractability results. In fact, in the next section we present novel algorithms which exploit this feature.

4. Dynamic programming for argumentation

Before we introduce our algorithms, we need some more notation for tree decompositions. In particular, it is useful to

reduce the number of different node types and to identify a root node. The following concept serves this purpose.

Deﬁnition 12. A tree decomposition (T , X ) of a graph G is called nice if T is a rooted tree and if each node4 t ∈ T is of
one of the following types:

1. LEAF: t is a leaf of T ;
and Xt = Xt(cid:7) \ {v} for some v ∈ Xt(cid:7) ;
2. FORGET: t has only one child t
(cid:7)
and Xt = Xt(cid:7) ∪ {v} for some v /∈ Xt(cid:7) ;
3. INSERT: t has only one child t
(cid:7)(cid:7)
and Xt = Xt(cid:7) = Xt(cid:7)(cid:7) .
4. JOIN: t has two children t

(cid:7), t

(cid:7)

Kloks [37] showed that a tree decomposition (T , X ) of a graph G where T has n nodes, can be transformed in time

O (n) into a nice tree decomposition (T (cid:7), X (cid:7)) of G which has the same width as (T , X ) and where T (cid:7)

has O (n) nodes.

Next, we have to introduce a few more technical notions which allow us direct access to some objects associated with

certain nodes in a tree decomposition.

Deﬁnition 13. For a tree decomposition (T , X ) of an AF F and t ∈ T , let X(cid:2)t be the union of all bags Xs ∈ X such that s
occurs in the subtree of T rooted at t. Moreover, X>t denotes X(cid:2)t \ Xt . We also use the following terminology:

• Ft = F | Xt is the subframework in t;
• F (cid:2)t = F | X(cid:2)t is the subframework induced by (the subtree rooted at) t.

Note that the subframework induced by the root of such a decomposition of an AF F is F itself.

Example 9. For the AF F from Example 1, we have already depicted a tree decomposition in Fig. 1. To obtain a nice tree
decomposition, we have to introduce some further nodes. To make the node with bag {c, d} a join node we add two new
nodes, one between the JOIN node and the node with bag {c, d} and one between JOIN node and the node with bag {d, e},
both having bag {c, d}. Further we have to add some new nodes to make the remaining nodes of type insert or forget. For
instance, between the nodes with bags {a, b} and {b, c}, we insert a further node with bag {b}, etc. We also have added two
forget nodes above the {c, d} node in order to have an empty root. The resulting nice tree decomposition of F is illustrated
in Fig. 7, which has to be read as follows. In each node t, the bag Xt contains the arguments in (solid) cycles. In addition,
we depict in each node t the AF Ft , i.e. the subframework in t; by adding the dotted parts of the graph, we obtain F (cid:2)t , the
subframework induced by t.

In what follows we restrict ourselves to nice tree decompositions where the bag of the root is empty. Unless stated
otherwise, we thus assume below that (T , X ) always denotes a nice tree decomposition (with empty root bag) for some
given AF F .

4.1. Characterizing admissible sets

We ﬁrst introduce a relativization of admissible sets to a given set B of arguments.

4 For T = (V T , ET ) we often write t ∈ T instead of t ∈ V T .

14

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

Fig. 7. Tree decomposition of F with subframeworks.

Deﬁnition 14. Let F = ( A, R) be an AF and B a set of arguments. A set S ⊆ A is a B-restricted admissible set for F , if S is
conﬂict-free in F and S defends itself in F against all a ∈ A ∩ B.

Example 10. Let us consider the AF
(cid:5)
(e, g), (g, f ), ( f , e)

{e, f , g},

(cid:4)

(cid:7)(cid:8)

which is a subframework of our running example. Indeed, in the tree decomposition in Fig. 7, it is the subframework in n13
and also the subframework induced by n12. The {g}-restricted admissible sets of this AF are ∅, {e}, and {g}. In fact, { f } is
not {g}-restricted admissible here, since g (cid:2) f but f does not defend itself against g.

Note that for A ⊆ B, B-restricted admissible sets of AFs ( A, R) are just the standard admissible sets; for A ∩ B = ∅,

B-restricted admissible sets are just the conﬂict-free sets.

We now introduce the underlying “data structure” of our dynamic programming algorithm for characterizing admissible
sets. The idea hereby is to store at each node t in the tree decomposition (T , X ) for a given AF F , a set of candidates
which are represented solely via the elements in the bag Xt . More precisely, we assign to each node t ∈ T a certain set of
mappings C : Xt → {in, out, att, def }. We call such mappings also colorings for t. The rationale behind a coloring for t is as
follows: explicitly, a coloring characterizes the set

(cid:5)
a

(cid:6)
(cid:7)
(cid:6) C(a) = in

[C] =

and the values out, att, def tell us about the relationship between [C] and the remaining arguments Xt \ [C]. In fact, att will
denote arguments which attack [C] but are not attacked by [C], def denotes arguments attacked by [C], and out are those
which are in no relation with arguments from [C]. However, we will deﬁne colorings in such a way that they characterize
sets over X(cid:2)t , rather than over Xt as sketched above. Formally, this intuition is captured as follows:

Deﬁnition 15. Let (T , X ) be a tree decomposition of an AF F and t ∈ T . Given a coloring C for a node t ∈ T , we deﬁne
et(C) as the collection of X>t -restricted admissible sets S for F (cid:2)t which satisfy the following conditions for each a ∈ Xt :

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

15

(i) C(a) = in iff a ∈ S;
(ii) C(a) = def iff S (cid:2) a;
(iii) C(a) = att iff S (cid:13)(cid:2) a and a (cid:2) S;
(iv) C(a) = out iff S (cid:13)(cid:2) a and a (cid:13)(cid:2) S.

If et(C) (cid:13)= ∅, C is called a valid coloring for t. The set of valid colorings for t is denoted by Ct .

Example 11. Consider the node t = n11 of our example tree decomposition with Xt = {d, e, f } (see the right-hand side of
the tree in Fig. 7) and the coloring C with C(d) = in and C(e) = C( f ) = def . We have F (cid:2)t = ({d, e, f , g}, {(d, e), (e, g), (g, f ),
( f , e)}) and X>t = {g}. The only set which is X>t -restricted admissible for F (cid:2)t and satisﬁes the conditions from Deﬁni-
tion 15 is {d, g}. S = {d} would also be X>t -restricted admissible but violates condition (ii), since C( f ) = def and S (cid:13)(cid:2) f . In
summary, this particular C is valid for t = n11 and we have et(C) = {{d, g}}.

Our ultimate goal is to eﬃciently compute the set Cr of valid colorings for the root node r of a given tree decomposition
for an AF F = ( A, R). The reason for this is the fact that
et(C) gives exactly the set of X>t -restricted admissible sets
C∈Ct
for F (cid:2)t (as we show next). Since the root r has an empty bag, and thus X>r = A, we obtain that Cr characterizes the
admissible sets of F .

(cid:3)

By deﬁnition, each element in et(C) is an X>t -restricted admissible set for F (cid:2)t . Next, we show that the opposite direction

also holds.

Lemma 1. Let (T , X ) be a tree decomposition of an AF F , t ∈ T , and S an X>t -restricted admissible set for F (cid:2)t . Then, there is a
coloring C ∈ Ct such that S ∈ et(C).

Proof. Since S is an X>t -restricted admissible set for F (cid:2)t , each argument a ∈ Xt satisﬁes one of the following conditions:
(i) a ∈ S, (ii) S (cid:2) a, (iii) S (cid:13)(cid:2) a and a (cid:2) S, or (iv) S (cid:13)(cid:2) a and a (cid:13)(cid:2) S. For these four cases, we deﬁne C as follows:

in case (i): C(a) = in,
in case (ii): C(a) = def ,
in case (iii): C(a) = att, and
in case (iv): C(a) = out.

By the construction of C , the set S satisﬁes conditions (i)–(iv) in Deﬁnition 15 and, since S is X>t -restricted admissible for
F (cid:2)t , it holds that S ∈ et(C). (cid:2)

Moreover, different colorings for a node t characterize different X>t -restricted admissible sets for F (cid:2)t .

Lemma 2. Let (T , X ) be a tree decomposition of an AF F and let C , C

(cid:7)

be different colorings for a node t ∈ T . Then, et(C) ∩ et(C

(cid:7)) = ∅.

Proof. Suppose to the contrary that there is a set S ∈ et(C) ∩ et(C
exists an argument a ∈ Xt such that C(a) (cid:13)= C
derive a contradiction in each case. First let us consider the case where C(a) = in and C
C(a) = in implies a ∈ S and further C
C(a) = def and C
S (cid:13)(cid:2) a, a contradiction. Finally, in case C(a) = att and C
a (cid:2) S and C
the above arguments. (cid:2)

are different colorings for t. Then there
(cid:7)(a) and to
(cid:7)(a) ∈ {def , att, out}. By Deﬁnition 15,
(cid:7)(a) ∈ {def , att, out} implies a /∈ S, a contradiction. We continue with the case where
(cid:7)(a) ∈ {att, out} implies
(cid:7)(a) = out, we get a contradiction by the fact that C(a) = att implies
in

(cid:7)(a) = out implies a (cid:13)(cid:2) S. The remaining cases follow by symmetry, i.e. by interchanging the roles of C , C

(cid:7)(a) ∈ {att, out}. By Deﬁnition 15, C(a) = def implies S (cid:2) a. On the other hand, C

(cid:7)(a). It remains to inspect all possible pairs of values of C(a) and C

(cid:7)), where C and C

(cid:7)

(cid:7)

To guarantee ﬁxed-parameter tractability with respect to tree-width, we want to compute the sets Ct in a bottom-up
manner along the tree decomposition without an explicit computation of et(·). Therefore, we recursively deﬁne the concept
of vcolorings which we afterwards show to be equivalent to valid colorings.

Deﬁnition 16. Let t ∈ T be a node in a nice tree decomposition (T , X ) of an AF F and let t
be the possible children
of t. The operations (C − a), (C + a), (C ˙+ a), and (C (cid:3) D) used below are deﬁned in Fig. 8. Depending on the node type
of t, we deﬁne a vcoloring for t as follows:

(cid:7)(cid:7)

(cid:7), t

• LEAF node: Each coloring Xt → {in, out, att, def } where

for all y (cid:2) x,
C(x) = in ⇒ C( y) ∈ {att, def }
C(x) = att ⇒ ∃ y: C( y) = in and x (cid:2) y,
C(x) = def ⇔ ∃ y: C( y) = in and y (cid:2) x

holds for all x ∈ Xt , is a vcoloring for t.

16

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

(C − a)(b) = C(b)

for each b ∈ X \ {a},

⎧
⎪⎪⎨

C(b)

def

att

out

in

def

out

(C + a)(b) =

(C ˙+ a)(b) =

⎪⎪⎩

⎧
⎪⎪⎨

⎪⎪⎩

(C (cid:2) D)(b) =

in

att
⎧
⎪⎪⎨
⎪⎪⎩

out

def

att

if b ∈ X,
if b = a and [C] (cid:3) a,
if b = a, [C] (cid:13)(cid:3) a and a (cid:3) [C],
otherwise,
if b = a or C(b) = in,
if a (cid:13)= b and ((a, b) ∈ F or C(b) = def ),
if a (cid:13)= b, C(b) = out, (a, b) /∈ F , (b, a) /∈ F ,
otherwise,
if C(b) = D(b) = in,
if C(b) = D(b) = out,
if C(b) = def or D(b) = def ,
otherwise.

Fig. 8. Operations for colorings C, D : X → {in, out, att, def } and AF F .

• FORGET node: If C is a vcoloring for t
(cid:7)
• INSERT node: If C is a vcoloring for t

hold, then C ˙+ a is also a vcoloring for t.

(cid:7)

• JOIN node: If C is a vcoloring for t

(cid:7)

, Xt = Xt(cid:7) \ {a}, and C(a) (cid:13)= att, then C − a is a vcoloring for t.
and Xt = Xt(cid:7) ∪ {a}, then C + a is a vcoloring for t; if a (cid:13)(cid:2) a, [C] (cid:13)(cid:2) a, and a (cid:13)(cid:2) [C]

, D is a vcoloring for t

(cid:7)(cid:7)

, and [C] = [D], then C (cid:3) D is a vcoloring for t.

In what follows, we show the adequacy of vcolorings (i.e., that they match the concept of valid colorings) and also
illustrate their functioning on our running example. We will do this step-by-step distinguishing between the different node
types.

Example 12. Recall the AF from Example 1 and its tree decomposition in Fig. 7. Fig. 9 illustrates the bottom-up computation
of the vcolorings for all nodes in the tree decomposition. More precisely, for each node t we give a table representing all
vcolorings of t, whereby each row gives one such vcoloring. Below we will discuss some of the transitions from children to
parent nodes (as deﬁned by vcolorings, cf. Deﬁnition 16) in detail.

For the moment, let us just describe a few further aspects in Fig. 9. For a better understanding we also added the
#-column in Fig. 9 to show the cardinalities of the sets et(C), i.e. the number of X>t -restricted admissible sets for F (cid:2)t
characterized by vcoloring C in t. In particular, we see in the root that we end up with 8 such sets which refer to the
admissible sets from our example AF (see Example 1). An explanation for the (cid:5) symbol in the tables of Fig. 9 follows later
in Example 17, when we shall illustrate how to decide CA using the concept of vcolorings.

Let us start with LEAF nodes. We ﬁrst give the desired result and then provide for illustration the computation of the

vcolorings for a leaf node in our running example.

Lemma 3. For any LEAF node in a tree decomposition of an AF, valid colorings and vcolorings coincide.

Proof. Let (T , X ) be a tree decomposition of F and t a leaf in T . We have X>t = ∅; therefore, the X>t -restricted admissible
sets for F (cid:2)t coincide with the conﬂict-free sets.

First, let C be a vcoloring for t. We have to show that then C is a valid coloring for t. Suppose to the contrary that it
is not, i.e., either [C] is not conﬂict-free in Ft = F (cid:2)t or C violates one of the conditions (ii)–(iv) in Deﬁnition 15. It is easy
to check that, in both cases, one of the conditions for C being a vcoloring is violated. For instance, if there is a conﬂict
in [C], then there exist arguments x, y ∈ Xt with x (cid:2) y and C(x) = C( y) = in. Hence, the ﬁrst condition in Deﬁnition 16 for
vcolorings at a LEAF node is violated, a contradiction.

Now suppose that C is a valid coloring for t, i.e., C satisﬁes the conditions (i)–(iv) of a coloring (see Deﬁnition 15) and
[C] is conﬂict-free in F (cid:2)t . Then C satisﬁes the condition of a vcoloring for a LEAF node according to Deﬁnition 16. For
instance, let x, y ∈ Xt with C(x) = in and y (cid:2) x. Then, since C is a coloring, either case (ii) or case (iii) of Deﬁnition 15
applies and, thus, C( y) ∈ {att, def } holds. (cid:2)

Example 13. Consider, for instance, the LEAF node n13 in Fig. 9 with bag {e, f , g}. We have here four vcolorings for n13 which
correspond to the conﬂict-free (and thus to the ∅-restricted admissible) sets for F (cid:2)n13
= ({e, f , g}, {(e, g), (g, f ), ( f , e)}),
namely {e}, { f }, {g}, and ∅.

We proceed with the FORGET nodes.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

17

Fig. 9. Computation of vcolorings for the example AF.

Lemma 4. For any FORGET node t in a tree decomposition of an AF with child node t
following relationships hold:

(cid:7)

such that Xt = Xt(cid:7) \ {a}, and every S ⊆ A, the

(1) If S is an X>t -restricted admissible set for F (cid:2)t , then S is also an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) .
(2) If S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) and a ∈ S, then S is an X>t -restricted admissible set for F (cid:2)t .
(3) If S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) , a /∈ S and S defends itself against a (including the case that a does not attack S

at all), then S is an X>t -restricted admissible set for F (cid:2)t .

Proof. First, since Xt ⊆ Xt(cid:7) , we have F (cid:2)t = F (cid:2)t(cid:7) and X>t ⊇ X>t(cid:7) . Let S be an X>t -restricted admissible set for F (cid:2)t and
hence for F (cid:2)t(cid:7) , i.e., S is conﬂict-free in F and S defends itself against all b ∈ X>t . By X>t ⊇ X>t(cid:7) , S thus also defends itself
against all b ∈ X>t(cid:7) . Hence S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) and assertion (1) follows.

18

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

Now assume that S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) and a ∈ S. Then S is conﬂict-free in F and S defends
itself against all b ∈ X>t(cid:7) . Strictly speaking, S defends itself against all b ∈ X>t(cid:7) \ S. By X>t(cid:7) \ S = X>t \ S (recall that we are
assuming that a ∈ S), therefore S is an X>t -restricted admissible set for F (cid:2)t . This proves assertion (2).

Finally assume that S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) , a /∈ S and S defends itself against a. Since S is X>t(cid:7) -
restricted admissible it is conﬂict-free in F and it defends itself against all b ∈ X>t(cid:7) . Moreover, X>t = X>t(cid:7) ∪ {a} and, by
assumption, S defends itself against a. Hence, S defends itself against all b ∈ X>t . Thus, S is X>t -restricted admissible and
assertion (3) follows. (cid:2)

Next we exploit this property to show that vcolorings and valid colorings coincide on forget nodes.

Lemma 5. For any FORGET node t in a tree decomposition of an AF, valid colorings and vcolorings coincide, if they coincide in the child
node t

of t.

(cid:7)

Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t a FORGET node in T , and t
Xt = Xt(cid:7) \ {a}, for some a ∈ A. Moreover, we get X(cid:2)t = X(cid:2)t(cid:7) and X>t = X>t(cid:7) ∪ {a}.
(cid:7)
Let C be a valid coloring for t. We show that there exists a valid coloring C

(cid:7)

(cid:7)

deﬁne C
to C

as follows: For all b ∈ Xt = Xt(cid:7) \ {a}, we set C

(cid:7)(a), we have C = C

(cid:7) − a. In order to deﬁne C

(cid:7) − a. We
with C
(cid:7)(b) = C(b). Hence, no matter which value of {in, def , out} we assign

(cid:7)(a) (cid:13)= att and C = C

for t

(cid:7)(a), we consider an arbitrary set S ∈ et(C) and distinguish two cases:

(cid:7)

the child node of t. By deﬁnition,

(1) If a ∈ S, then we set C

F (cid:2)t(cid:7) = F (cid:2)t , by Lemma 4. Moreover, S ∈ et(cid:7) (C
chosen S in the conditions (i)–(iv) in Deﬁnition 15). Hence, by assumption, C
C = C

(cid:7) − a is a vcoloring for t, by deﬁnition.

(cid:7)(a) = in. Since S is X>t -restricted admissible for F (cid:2)t , it is also X>t(cid:7) -restricted admissible for
(this can be seen by just using the
and, therefore, also

is a valid coloring for t

is a vcoloring for t

(2) Now let a /∈ S. If S (cid:2) a, we set C

(cid:7)). Note
that the case S (cid:13)(cid:2) a and a (cid:2) S cannot occur since, by assumption, S is X>t -restricted admissible for F (cid:2)t . By the same
(cid:7)
reasoning as above, C

(cid:7)(a) = def . If S (cid:13)(cid:2) a and a (cid:13)(cid:2) S, we set C

(cid:7)(a) = out. In both cases, S ∈ et(cid:7) (C

(and thus also C ) is a vcoloring for t

(cid:7)), i.e., C

(resp. for t).

(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7) − a. By assumption, C
(cid:7)
Now let C be a vcoloring for t, i.e., there exists a vcoloring C
(cid:7)(a) (cid:13)= att,
is a valid coloring for t
it cannot happen that both a (cid:2) S and S (cid:13)(cid:2) a hold. But then S is also X>t -restricted admissible for F (cid:2)t by Lemma 4 and
S ∈ et(C). Thus, C ∈ Ct . (cid:2)

(cid:7)), i.e., S is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) = F (cid:2)t . Since C

. Hence, there exists S ∈ et(cid:7) (C

(cid:7)(a) (cid:13)= att and C = C

such that C

for t

(cid:7)

(cid:7)

(cid:7)

Example 14. Let us continue the running example which we started above by computing the vcolorings for node n13. The
= {g}. The vcolorings for n12 are obtained
next node n12 above n13 is of type FORGET and removes argument g. Thus X>n12
from the vcolorings for n13 with the exception of the coloring C with [C] = { f }. Here we have C(g) = att, which violates the
construction for the FORGET node. Intuitively, [C] = { f } is not further propagated because { f } is attacked by the argument
g which is no longer present in Xn12 . Hence, by properties (2) and (3) of tree decompositions, g is not attacked by any
argument outside X(cid:2)n12 . Therefore, [C] = { f } cannot be extended to an admissible set along the bottom-up traversal, i.e.,
any extension of [C] = { f } to arguments outside X(cid:2)n12 will not defend itself against this attack from g against f . The
= F (cid:2)n13 (see also Example 10
vcolorings for n12 are now in accordance with the X>n12 -restricted admissible sets for F (cid:2)n12
where we already analyzed exactly this situation).

The next nodes we want to consider are those of type INSERT.

Lemma 6. For any INSERT node t in a tree decomposition of an AF with child node t
following relationships hold:

(cid:7)

such that Xt = Xt(cid:7) ∪ {a}, and every S ⊆ A, the

(1) If S is an X>t -restricted admissible set for F (cid:2)t , then S \ {a} is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) .
(2) If S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) , then S is also an X>t -restricted admissible set for F (cid:2)t .
(3) If S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) and S ∪ {a} is conﬂict-free in F (cid:2)t then S ∪ {a} is an X>t -restricted admissible set

for F (cid:2)t .

Proof. By assumption, we have Xt = Xt(cid:7) ∪ {a} and a /∈ Xt(cid:7) . Thus, also X(cid:2)t = X(cid:2)t(cid:7) ∪ {a} and X>t = X>t(cid:7) hold. By properties (2)
and (3) of tree decompositions, we know that there are no attacks between the new argument a and arguments in X>t .

First, let S be an X>t -restricted admissible set for F (cid:2)t . By X>t = X>t(cid:7) , the set S is also X>t(cid:7) -restricted admissible for
F (cid:2)t . Moreover, since a cannot attack any argument in X>t(cid:7) , also S \ {a} is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) (of course, if
a /∈ S, then S \ {a} = S and the latter admissibility property is trivial). This proves assertion (1).

Now consider an X>t(cid:7) -restricted admissible set S for F (cid:2)t(cid:7) . Then S is conﬂict-free in F . Moreover, as explained above,
there are no attacks between the new argument a and arguments in X>t . Hence, the argument a does not affect the

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

19

second condition for being an X>t -restricted admissible set. Thus S and S ∪ {a} (in case it is conﬂict-free) are X>t -restricted
admissible sets of F (cid:2)t . This proves assertions (2) and (3). (cid:2)

Lemma 7. For any INSERT node t in a tree decomposition of an AF, valid colorings and vcolorings coincide, if they coincide in the child
node t

of t.

(cid:7)

Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t an INSERT node in T , and t
Xt = Xt(cid:7) ∪ {a} and a /∈ Xt(cid:7) .

(cid:7)

the child node of t. Moreover, let

Let C be a valid coloring for t, i.e., there exists an X>t -restricted admissible set S ∈ et(C) for F (cid:2)t . Then, by Lemma 6,
with S \ {a} ∈

S \ {a} is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) . As in the proof of Lemma 1, we construct a coloring C
et(cid:7) (C

for t

(cid:7)

(cid:7)

(cid:7)) as follows. For arbitrary b ∈ Xt(cid:7) , we deﬁne:
if b ∈ S \ {a},
if b /∈ S and S \ {a} (cid:2) b,
if b /∈ S, b (cid:2) S \ {a}, and S \ {a} (cid:13)(cid:2) b,
if b /∈ S, b (cid:13)(cid:2) S \ {a}, and S \ {a} (cid:13)(cid:2) b.

(cid:7)(b) = in
C
(cid:7)(b) = def
C
(cid:7)(b) = att
C
(cid:7)(b) = out
C
(cid:7) ∈ Ct(cid:7) , and by assumption, is a vcoloring for t
(cid:7) ˙+ a holds (if a ∈ S). Hence, C is a vcoloring for t.

(cid:7)

Thus, C
C = C

. Moreover, it is easy to check that either C = C

(cid:7) + a holds (if a /∈ S) or

Now let C be a vcoloring for t, i.e., there exists a vcoloring C
is a valid coloring, i.e. there exists an X>t(cid:7) -restricted (and, hence, X>t -restricted) admissible set S ∈ et(cid:7) (C
(cid:7) + a). Moreover if the set S ∪ {a} is conﬂict-free in F (cid:2)t , then S ∪ {a} ∈ et(C

for t

(cid:7)
C
easy to check that then S ∈ et(C
Thus, C (which is either C

(cid:7) + a or C

(cid:7) ˙+ a) is a valid coloring for t. (cid:2)

(cid:7)

with either C = C

(cid:7) + a or C = C

(cid:7) ˙+ a. By assumption,
(cid:7)) of F (cid:2)t(cid:7) . It is
(cid:7) ˙+ a) as well.

(cid:7)

(cid:7)(e) = att and C

(cid:7)
Example 15. We continue our running example: the next node n11 is of type INSERT and adds d. Consider the coloring C
(cid:7)( f ) = def . We have two possibilities to add d. In case we want d to be in the set, we obtain
for n12 with C
the coloring C with C(d) = in, C(e) = def , C( f ) = def (note that e changes its color since it is now a “defeated attacker”);
we have seen this coloring already in Example 11. The other possibility is to have d not in the set, resulting in the coloring
C

(cid:7)(cid:7)(d) = out, C

(cid:7)(cid:7)(e) = att, C

(cid:7)(cid:7)( f ) = def .

with C

(cid:7)(cid:7)

Lemma 8. For any JOIN node t in a tree decomposition of an AF, valid colorings and vcolorings coincide, if they coincide also for both
child nodes of t.

Proof. Let (T , X ) be a tree decomposition of F = ( A, R) and t a JOIN node in T with successors t
=
(cid:7)(cid:7)
t and X(cid:2)t(cid:7) ∩ X(cid:2)t(cid:7)(cid:7) = Xt and X(cid:2)t = X(cid:2)t(cid:7) ∪ X(cid:2)t(cid:7)(cid:7) . So we can partition X(cid:2)t into three disjoint sets X>t(cid:7) , X>t(cid:7)(cid:7) and Xt . Thus
X
every set S ⊆ X(cid:2)t can be seen as the union of two sets S1 ⊆ X(cid:2)t(cid:7) and S2 ⊆ X(cid:2)t(cid:7)(cid:7) with S1 ∩ Xt = S2 ∩ Xt . The following
lemmas identify important properties of these sets S1 and S2.

. Then Xt = X

and t

(cid:7)

(cid:7)(cid:7)

(cid:7)
t

Lemma 9. Let S1 ⊆ X(cid:2)t(cid:7) and S2 ⊆ X(cid:2)t(cid:7)(cid:7) , such that

1. S1 is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) ;
2. S2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) ;
3. S1 ∩ Xt = S2 ∩ Xt .

Then S = S1 ∪ S2 is an X>t -restricted admissible set for F (cid:2)t .

Proof. By properties 2 and 3 of tree decompositions, there are no attacks between the argument sets X>t(cid:7) and X>t(cid:7)(cid:7) . In
order to show that S = S1 ∪ S2 is X>t -restricted admissible, we have to prove that (a) S is conﬂict-free in the AF F (cid:2)t ; and
(b) S defends itself against all attacks from arguments in X>t = X>t(cid:7) ∪ X>t(cid:7)(cid:7) in F (cid:2)t .

(a) Suppose to the contrary that there is a conﬂict a (cid:2) b with a, b ∈ S. Then either a, b ∈ X(cid:2)t(cid:7) (resp. a, b ∈ X(cid:2)t(cid:7)(cid:7) ) or
a ∈ X(cid:2)t(cid:7) while b ∈ X(cid:2)t(cid:7)(cid:7) (or vice versa). In the case a, b ∈ X(cid:2)t(cid:7) , we get a, b ∈ S1 and, therefore, S1 is not conﬂict-free in F (cid:2)t(cid:7) ,
a contradiction to assumption 1 (the same argument applies to the case a, b ∈ X(cid:2)t(cid:7)(cid:7) ). Thus assume a ∈ X(cid:2)t(cid:7) while b ∈ X(cid:2)t(cid:7)(cid:7)
(or vice versa). Since there are no attacks between an argument from X>t(cid:7) and an argument from X>t(cid:7)(cid:7) , it must hold that
a ∈ Xt or b ∈ Xt . Hence, {a, b} ⊆ X(cid:2)t(cid:7) or {a, b} ⊆ X(cid:2)t(cid:7)(cid:7) holds. Assuming S1 ∩ Xt = S2 ∩ Xt , this means that there is a conﬂict
in either S1 or S2, yielding a contradiction to assumption 1 or 2.

(b) We show that all arguments in S1 are defended by S against arguments from X>t in F (cid:2)t . The analogous result for
S2 then follows by symmetry. In total, every argument in S is then defended by S against arguments from X>t . Together
with the result from (a), we thus derive the desired result, i.e. that S is an X>t -restricted admissible set for F (cid:2)t .

By assumption, S1 defends itself against X>t(cid:7) in F (cid:2)t(cid:7) and thus against X>t(cid:7) in F (cid:2)t . Moreover, there are no attacks from
X>t(cid:7)(cid:7) against X>t(cid:7) in F (cid:2)t by the properties of tree decompositions. So X>t(cid:7)(cid:7) can only attack arguments in S1 ∩ Xt . Thus, S2

20

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

defends S1 against X>t(cid:7)(cid:7) since, S1 ∩ Xt = S2 ∩ Xt and by assumption, S2 defends itself against all attacks from X>t(cid:7)(cid:7) in F (cid:2)t(cid:7)
and thus also in F (cid:2)t . Putting this together, we have that S = S1 ∪ S2 defends S1 against X>t in F (cid:2)t . (cid:2)

Lemma 10. Let S be an X>t -restricted admissible set for F (cid:2)t , S1 = S ∩ X(cid:2)t(cid:7) and S2 = S ∩ X(cid:2)t(cid:7)(cid:7) . Then,

1. S1 is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) ;
2. S2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) ;
3. S1 ∩ Xt = S2 ∩ Xt .

Proof. Let S be an X>t -restricted admissible set for F (cid:2)t . Assumption 3 is immediate by the fact that X(cid:2)t(cid:7) ∩ X(cid:2)t(cid:7)(cid:7) = Xt .
Moreover, since S is conﬂict-free in F (cid:2)t , each subset of S is conﬂict-free in any subframework of F (cid:2)t , in particular S1 =
S ∩ X(cid:2)t(cid:7) is conﬂict-free in F (cid:2)t(cid:7) and S2 = S ∩ X(cid:2)t(cid:7)(cid:7) is conﬂict-free in F (cid:2)t(cid:7)(cid:7) . It remains to show that S1 (resp. S2) defends itself
against all attacks from X>t(cid:7) (resp. from X>t(cid:7)(cid:7) ) in F (cid:2)t(cid:7) (resp. in F (cid:2)t(cid:7)(cid:7) ). Suppose to the contrary that there exists a ∈ X>t(cid:7)
such that a (cid:2) S1 and S1 (cid:13)(cid:2) a in F (cid:2)t(cid:7) . Since S is X>t -restricted admissible in F (cid:2)t , we know that S (cid:2) a in F (cid:2)t . Hence, there
has to exist an argument b ∈ S \ S1 = S ∩ X>t(cid:7)(cid:7) such that b (cid:2) a in F (cid:2)t . But, as already observed earlier, there are no attacks
between X>t(cid:7) and X>t(cid:7)(cid:7) , a contradiction. By symmetry, also S2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) . (cid:2)

Proof of Lemma 8 continued. We now show that valid colorings and vcolorings for a JOIN node t coincide. First, let C be
(cid:7) (cid:3) C
(cid:7)(cid:7)]. By assumption, C
(cid:7)
a vcoloring for t, i.e., C = C
(cid:7)(cid:7)). Moreover, by
are valid colorings for the respective nodes t
and C
(cid:7)(cid:7)], we have S1 ∩ Xt = S2 ∩ Xt . Thus, by Lemma 9, S = S1 ∪ S2 is X>t -restricted admissible. It remains to show that
[C
S ∈ et(C). To this end, we check that the conditions (i)–(iv) in Deﬁnition 15 are satisﬁed for every a ∈ Xt :

(cid:7)
. Hence, there exist S1 ∈ et(cid:7) (C

(cid:7)] = [C
(cid:7)) and S2 ∈ et(cid:7)(cid:7) (C

) is a vcoloring for t

(cid:7)(cid:7)
(cid:7)] = [C

(resp. C
(cid:7)

) and [C

, where C

(resp. t

and t

(cid:7)(cid:7)

(cid:7)(cid:7)

(cid:7)(cid:7)

(cid:7)(cid:7)

(cid:7)

(i) By the deﬁnition of the (cid:3)-operator in Fig. 8, we have C(a) = in iff C

(cid:7)(a) = in and C

(cid:7)(cid:7)(a) = in. This, in turn, is equivalent

to a ∈ S1 and a ∈ S2. In total, we have C(a) = in iff a ∈ S.

(ii) C(a) = def iff C
(iii) By the “otherwise” branch in Fig. 8, we have C(a) = att iff (C

(cid:7)(a) = def or C

(cid:7)(cid:7)(a) = def (see Fig. 8) iff S1 (cid:2) a or S2 (cid:2) a iff S (cid:2) a.

(cid:7)(cid:7)(a) (cid:13)= def ).
This, in turn, is equivalent to (a (cid:2) S1 or a (cid:2) S2) and (S1 (cid:13)(cid:2) a and S2 (cid:13)(cid:2) a). In total, we have C(a) = att iff a (cid:2) S but
S (cid:13)(cid:2) a.

(cid:7)(cid:7)(a) = att) and (C

(cid:7)(a) (cid:13)= def and C

(cid:7)(a) = att or C

(iv) C(a) = out iff C

(cid:7)(a) = out and C

(cid:7)(cid:7)(a) = out (see Fig. 8) iff a (cid:13)(cid:2) S1, a (cid:13)(cid:2) S2, S1 (cid:13)(cid:2) a and S2 (cid:13)(cid:2) a iff a (cid:13)(cid:2) S and S (cid:13)(cid:2) a.

(cid:7)

(cid:7)

(cid:7)

(cid:7)(cid:7)

and C

are valid colorings for the respective nodes t

Now assume that C is a valid coloring for t, i.e., there exists S ∈ et(C). We deﬁne S1 = S ∩ X(cid:2)t(cid:7) and S2 = S ∩ X(cid:2)t(cid:7)(cid:7) . Then,
by Lemma 10, S1 is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) , S2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) , and S1 ∩ Xt = S2 ∩ Xt . As in
(cid:7)(cid:7)). Then
the proof of Lemma 1, we can deﬁne a coloring C
C
, and, therefore, by assumption they are also vcolorings for
∗ = C holds. To prove this claim, we have to
their node. Now deﬁne the vcoloring C
∗(a) = C(a) for every a ∈ Xt . This equality is shown by distinguishing the four possible values {in, def , att, out}
show that C
and by exploiting the conditions (i)–(iv) in Deﬁnition 15 as well as the deﬁnition of the (cid:3) operator in Fig. 8. We only
work out the case of “in” nodes here. The remaining cases are treated analogously. Inspecting the deﬁnition of (cid:3) in Fig. 8,
(cid:7)(cid:7)(a) = in. This, in turn, is equivalent to a ∈ S1 and a ∈ S2. On the other hand, by
shows that C
condition (i) of Deﬁnition 15, we have C(a) = in iff a ∈ S. By the deﬁnition of S 1 and S2, this is equivalent to a ∈ S1 and
a ∈ S2. In total, we thus have C

∗(a) = in iff C(a) = in. (cid:2)

, such that S1 ∈ et(cid:7) (C

for node t. We claim that C

and a coloring C
(cid:7)(cid:7)
(cid:7)

(cid:7)) and S2 ∈ et(cid:7)(cid:7) (C

(cid:7)(a) = in and C

∗(a) = in iff C

∗ = C

(cid:7) (cid:3) C

and t

at t

at t

(cid:7)(cid:7)

(cid:7)(cid:7)

(cid:7)(cid:7)

(cid:7)

(cid:7)] = [C

(cid:7)(cid:7)], i.e. the extensions coincide on the intersection X(cid:2)n3

Example 16. The only node of type JOIN in our example is the node n2, which combines the subframeworks F (cid:2)n3 and F (cid:2)n8 .
(cid:7)(cid:7)(d) = def . As
(cid:7)(cid:7)(c) = in and C
Consider the coloring C
∩ X(cid:2)n8 , we can join these colorings without causing any
[C
(cid:7)(cid:7)
conﬂict. Thus we obtain C with C(c) = in and C(d) = def for the node n12. Now let us consider the coloring D
for node n8
(cid:7)(cid:7)] = {c, d} has a conﬂict.
(cid:7)] (cid:13)= [D
with D
Hence the pair C

(cid:7)(cid:7)] and one can see that the set [C

(cid:7)(cid:7)(d) = in. We have that [C

does not lead to a vcoloring for the node n12.

for node n3 and the coloring C

(cid:7)(cid:7)(c) = def and D

for node n8 with C

(cid:7)(d) = C

(cid:7)(c) = C

(cid:7)] ∪ [D

(cid:7), D

(cid:7)(cid:7)

(cid:7)(cid:7)

Lemmas 3–8 show that vcolorings provide us with exactly the same information as valid colorings. The following result

thus immediately follows by structural induction over a given nice tree decomposition.

Theorem 5. Let (T , X ) be a nice tree decomposition of an AF F = ( A, R). Then, for each coloring C for a node t ∈ T , it holds that C is
a valid coloring for t iff C is a vcoloring for t.

Let us now describe how credulous acceptance can be performed via vcolorings: We just have to mark each coloring
which assigns the value in to the argument we are interested in and accordingly pass this mark up to the root. In other
words, we mark a coloring if it is constructed by using at least one marked coloring. If the coloring of the root has the
mark, then we know that credulous acceptance for this argument holds.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

21

Example 17. Recall the computation from Example 12 in Fig. 9. We now consider the problem of deciding if the argument d
is credulously accepted. The argument d is introduced in the nodes n3 and n11 thus we mark all their vcolorings C satisfying
C(d) = in and illustrate this with a (cid:5) in the last column of the table. Consider, for instance, the node n8 with the colorings
(cid:7)
1(d) = in and
C1(c) = in, C1(d) = def , C2(c) = def , C2(d) = in and C3(c) = out, C3(d) = out. The child node n9 has colorings C
(cid:7)
+ {c}) it is also
2(d) = out, the ﬁrst marked for credulous acceptance. As C2 is constructed via the marked C
C
marked and as C1 and C3 are both constructed via C

(cid:7)
1 (C2 = C
+ {c}) they are not marked.

˙+ {c}, C3 = C

(cid:7)
1

(cid:7)
2 (C1 = C

(cid:7)
2

(cid:7)
2

Since vcolorings can be computed eﬃciently (for bounded bag size) we obtain the following result for such an algorithm,
assuming that AFs come together with a nice tree decomposition of suitable width. The upper bound on the time complexity
is obtained by considering the maximum number of vcolorings per node and assuming a straightforward method (e.g.,
nested loops) for computing a node’s vcolorings from the vcolorings at the child node(s).

Theorem 6. Deciding CA for an AF F = ( A, R) of tree-width k − 1 can be done in time O (10k · k · | A|).

Proof. Let (T , X ) be a tree decomposition of an AF F = ( A, R). First, we observe that the number of colorings for each node
t ∈ T is bounded by 4k, since there are at most k arguments in Xt ∈ X and there are only 4 colors {in, out, def , att} to assign
to these arguments. We assume that the set of vcolorings for a node t is stored in a table with 4k rows. Each row contains
a coloring plus an additional bit which indicates if this coloring is a vcoloring. We assume that, given a coloring C , we can
ﬁnd the corresponding row in this table within time O (k). We have to show that computing the vcolorings at each node
t ∈ T is feasible in time O (10k · k) in a single bottom-up traversal of T . Since the number of nodes of T may be assumed to
be bounded by O (| A|), the desired upper bound of the theorem follows immediately. We prove the upper bound O (10k · k)
for the time needed at each node t ∈ T by distinguishing the four types of nodes in a nice tree decomposition.

At a LEAF node t, we inspect each coloring C in the table at t and check in time O (k2) if C is a vcoloring, i.e., conﬂict-free.

To this end, we simply consider all pairs of arguments in the bag. This yields the bound O (4k · k2).

For a FORGET node t, we iterate over all vcolorings C

(cid:7)(a) (cid:13)= att.
(cid:7) − a in time O (k). Then we access in time O (k) the coloring C in the
If this is the case, we compute the coloring C = C
table at t and set the vcoloring-bit. In total, we can compute the vcoloring-table at t in time O (4k · k). An INSERT node t is
treated similarly.

and check for each such C

for the successor node t

if C

(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7)(cid:7)

In a JOIN node t, the vcolorings are computed by combining two colorings of the successors t

. In a naive
implementation, up to 4k · 4k = 42k = 16k pairs exist. However, we show that only 10k pairs have to be considered. By
(cid:7)(cid:7)]. For
using appropriate data structures, we can implement the join such that we only consider pairs (C
instance, we can sort the colorings in the tables at t
in lexicographical order by treating in as 1 and the other values
(cid:7)] are in contiguous rows. This sorting requires
(i.e., def , att, out) as 0. In the sorted table, the colorings D, D
time O (4k · k).

with [D] = [D

(cid:7)(cid:7)) with [C

(cid:7)] = [C

and t

and t

(cid:7), C

(cid:7)]. For every m, there are

Let C be a coloring over k arguments with m (cid:4) k arguments mapped to in. Then, for each argument with C(a) (cid:13)= in, we
(cid:7)
can choose any color in {out, def , att} without effecting the set [C]. Thus there exist at most 3k−m different colorings C
· 3k−m colorings C
such that [C] = [C
in the ﬁrst table mapping m arguments to in. Each of these colorings can be combined with 3k−m colorings from the second
(cid:8)
3k−m · 3k−m join pairs produced by colorings that map m arguments to in. The sum over
table. Hence we have at most
· 9m = 10k.
and the latter equality follows from the combinatorial identity

all possible m yields the desired upper bound for the total number of join pairs:

different choices of m arguments and thus there are

(cid:15)
k
m=0

(cid:15)
k
m=0

· 3m · 3m =

k
m

k
m

k
m

k
m

k
m

=

(cid:8)

(cid:8)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:8)

(cid:8)

(cid:8)

(cid:8)

(cid:4)

(cid:7)

(cid:4)
k
k−m

k
m
(cid:7)(cid:7)) can be handled in time O (k) (for computing C = C
(cid:7), C

To obtain the ﬁrst sum we use the identity
(cid:15)
· (l)i = (l + 1)n. Each joinable pair (C
n
i=0

(cid:4)
n
i

(cid:8)

(cid:7) (cid:3) C

(cid:7)(cid:7)

and setting the

vcoloring-bit of C ). In total, the vcolorings for a JOIN node can thus be computed in time O (10k · k). (cid:2)

(cid:7)

(cid:7)(cid:7)

As hinted at in Example 12, our dynamic programming approach can be easily extended so as to count the number of
admissible sets. In fact, we just need to add the computation of the #-column to our algorithm (which is straightforward due
to Lemma 2). Finally, we also emphasize the possibility of enumerating (with linear delay) all admissible sets (using a second
top-down pass of the tree similar as sketched in [34]).

4.2. Characterizing preferred extensions

So far, we have solved the credulous acceptance problem via a certain characterization for the admissible sets. For
skeptical reasoning, we have to characterize preferred extensions rather than the admissible sets. We thus need a more
complicated data structure. Instead of colorings for nodes t we shall use pairs (C, Γ ) where C is a coloring for t and Γ is
a set of colorings for t. The set Γ of “certiﬁcates” contains further colorings which characterize X>t -restricted admissible
sets strictly larger than the X>t -restricted admissible sets characterized by C . Intuitively, Γ represents those X>t -restricted
admissible sets which may ultimately keep the elements in et(C) from being maximal.

22

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

Deﬁnition 17. Let (T , X ) be a tree decomposition of an AF F , t ∈ T , and (C, Γ ) a pair with C being a coloring for t and Γ
being a set of colorings for t. We call (C, Γ ) simply a pair for t and deﬁne et(C, Γ ) as the collection of sets S which satisfy
the following conditions:

(i) S ∈ et(C);
(ii) For all C
(iii) For all X>t -restricted admissible (for F (cid:2)t ) sets E with S ⊂ E, there exists some C

(cid:7) ∈ Γ , there is an E ∈ et(C

(cid:7)) such that S ⊂ E;

(cid:7) ∈ Γ with E ∈ et(C

(cid:7)).

If et(C, Γ ) (cid:13)= ∅, (C, Γ ) is a valid pair for t.

The following technical lemmas mirror Lemmas 1 and 2.

Lemma 11. Let (T , X ) be a tree decomposition of an AF F , t ∈ T , and S an X>t -restricted admissible set for F (cid:2)t . Then, there is a pair
(C, Γ ) for t such that S ∈ et(C, Γ ).

Proof. Let S be an X>t -restricted admissible set for F (cid:2)t . By Lemma 1, there exists a coloring C with S ∈ et(C). Now let
(cid:7))}. We claim that
E = {E | E is X>t -restricted admissible for F (cid:2)t and S ⊂ E}. Moreover, let Γ = {C
S ∈ et(C, Γ ). To prove this, we check the conditions (i)–(iii) from Deﬁnition 17: (i) S ∈ et(C) by the selection of C . (ii) For
(cid:7)) with S ⊂ E; this follows by the construction of Γ from E . (iii) For all X>t -restricted sets E
all C
(cid:7)); again this follows by the construction of Γ
that are admissible in F (cid:2)t with S ⊂ E, there exists C
from E . (cid:2)

(cid:7) ∈ Γ , there exists E ∈ et(C

(cid:7) | ∃E ∈ E, s.t. E ∈ et(C

(cid:7) ∈ Γ with E ∈ et(C

Lemma 12. Let (T , X ) be a tree decomposition of an AF F , t ∈ T , and let (C, Γ ), (C
C (cid:13)= C

). Then, et(C, Γ ) ∩ et(C

(cid:7), Γ (cid:7)) = ∅.

(cid:7)

(cid:7), Γ (cid:7)) be different pairs for t (but not necessarily

(cid:7)

Proof. If C (cid:13)= C
with Γ (cid:13)= Γ (cid:7)
et(C, Γ ) ∩ et(C, Γ (cid:7)) = ∅, we prove that none of the sets S ∈ et(C, Γ ) is contained in et(C, Γ (cid:7)).

. W.l.o.g., we assume that there exists a coloring ¯C for t such that ¯C ∈ Γ but ¯C /∈ Γ (cid:7)

(cid:7)) = ∅ and our claim follows. Thus, it remains to consider pairs (C, Γ ), (C, Γ (cid:7))
. In order to show that

then, by Lemma 2, et(C) ∩ et(C

Let S be an arbitrary set in et(C, Γ ). Suppose to the contrary that S is also contained in et(C, Γ (cid:7)). By Deﬁnition 17
(applied to et(C, Γ )), there exists an X>t -restricted admissible set E ∈ et( ¯C) for F (cid:2)t such that S ⊂ E. By Deﬁnition 17
(applied to et(C, Γ (cid:7))), there exists a coloring C
coincide.
Thus, ¯C ∈ Γ (cid:7)
, a contradiction. (cid:2)

∗). By Lemma 2, the colorings ¯C and C

such that E ∈ et(C

∗ ∈ Γ (cid:7)

∗

Hence, each element S ∈ et(C, Γ ) is an X>t -restricted admissible set for F (cid:2)t and each X>t -restricted admissible set for

F (cid:2)t is characterized by some valid pair for t.

Now that we have augmented valid colorings with sets of valid colorings, we can identify the preferred extensions of F
in the root node. Recall that the root node r of T has an empty bag, thus there are only two possible pairs for r, namely
((cid:7), ∅) and ((cid:7), {(cid:7)}), where (cid:7) is the empty coloring. Only the ﬁrst pair corresponds to preferred extensions (see Deﬁnition 17)
and we have the following relationship.

Proposition 2. Let r be the root of a nice tree decomposition (T , X ) of an AF F . Then, er((cid:7), ∅) = pref (F ).

Proof. We recall that er((cid:7)) = adm(F ). To show the set inclusion er((cid:7), ∅) ⊆ pref (F ), let S be an arbitrary set such that
S ∈ er((cid:7), ∅). By Deﬁnition 17(i) we obtain that S is admissible for F (cid:2)r = F . Further by (iii) and the fact that Γ = ∅ we
conclude that there is no proper superset of S being admissible for F , i.e. S is a preferred extension of F . It remains to
show that er((cid:7), ∅) ⊇ pref (F ). Thus let S ∈ pref (F ) be an arbitrary preferred extension of F . By Lemmas 11 and 12 we get
that there exists a unique pair (C, Γ ) such that S ∈ et(C, Γ ). Since the root node has an empty bag, C = (cid:7) and further, by
Deﬁnition 17(ii) and the fact that S is a ⊆-maximal admissible set for F , we conclude that Γ = ∅ has to hold as well. (cid:2)

Thus, our pairs have the desired property to characterize preferred extensions. It remains to ﬁnd an eﬃcient way to
compute them. As we did for admissible sets, we shall employ vcolorings for this purpose. However, the bottom-up com-
putation now has to be applied to certiﬁcates as well, which makes the deﬁnition more involved. To handle the certiﬁcates,
we have to extend the deﬁnition of the operators for vcolorings (see Fig. 8) to sets of vcolorings. By slight abuse of notation,
we overload the operators −, +, ˙+, and (cid:3) as follows:

(cid:5)

(cid:6)
(cid:6) C ∈ Γ and C(a) (cid:13)= att

(cid:7)

,

C − a
Γ − a =
Γ + a = {C + a | C ∈ Γ },
Γ ˙+ a =
C ˙+ a
(cid:5)
Γ (cid:3) (cid:8) =
C (cid:3) D

(cid:5)

(cid:6)
(cid:7)
(cid:6) C ∈ Γ, a (cid:13)(cid:2) a, [C] (cid:13)(cid:2) a and a (cid:13)(cid:2) [C]
(cid:6)
(cid:7)
(cid:6) C ∈ Γ, D ∈ (cid:8), and [C] = [D]

.

,

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

23

We observe that if Γ is a set of vcolorings for a node t
having t as its parent node, applying an operator corresponding to
the node type of t results in a set of vcolorings for t. For the join operator we additionally have to assume that (cid:8) is a set
of vcolorings for a node t
. As an analogue to vcolorings we formally deﬁne now
the concept of vpairs as follows.

which shares t as a parent node with t

(cid:7)(cid:7)

(cid:7)

(cid:7)

Deﬁnition 18. Let (T , X ) be a nice tree decomposition of an AF F and let t ∈ T be a node with t
Depending on the node type of t we deﬁne a vpair for t as follows:

(cid:7)(cid:7)

(cid:7), t

its possible children.

• LEAF: Each (C, Γ ) where C ∈ Ct and Γ = {C
• FORGET: If (C

(cid:7)

(cid:7) ∈ Ct | [C] ⊂ [C

(cid:7)]} is a vpair for t.

, Xt = Xt(cid:7) \ {a}, and C

(cid:7)(a) (cid:13)= att, then

– (C

• INSERT: If (C

(cid:7), Γ (cid:7)) is a vpair for t
(cid:7) − a, Γ (cid:7) − a) is a vpair for t.
(cid:7), Γ (cid:7)) is a vpair for t
(cid:7)
(cid:7) + a, (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ ({C
(cid:7) ˙+ a is a vcoloring then (C
(cid:7)
(cid:7), Γ (cid:7)) is a vpair for t
(cid:7)(cid:7), (Γ (cid:7) (cid:3) Γ (cid:7)(cid:7)) ∪ ({C

– (C
– if C
• JOIN: If (C
(cid:7) (cid:3) C

– (C

and Xt = Xt(cid:7) ∪ {a}, then
(cid:7)} ˙+ a)) is a vpair for t;

(cid:7) ˙+ a, Γ (cid:7) ˙+ a) is a vpair for t as well.
, (C

(cid:7)(cid:7), Γ (cid:7)(cid:7)) is a vpair for t

(cid:7)(cid:7)
, and [C
(cid:7)(cid:7)})) is a vpair for t.

(cid:7)} (cid:3) Γ (cid:7)(cid:7)) ∪ (Γ (cid:7) (cid:3) {C

(cid:7)] = [C

(cid:7)(cid:7)], then

(cid:7) ∈ Γ (cid:7)
may give rise to two certiﬁcates of C
(cid:7) + a. But we possibly also get a certiﬁcate for C
(cid:7) ˙+ a – hence the union with (Γ (cid:7) ˙+ a). Finally, we may also get a new certiﬁcate of C

(cid:7) + a in the above deﬁnition are in order. We consider here a new argument a
(cid:7) + a. First, if we do not add a to
(cid:7) + a if we do add a to [E],
(cid:7) + a if we take C
itself and

A few words about the certiﬁcates of C
but do not add it to [C]. Now each certiﬁcate E
(cid:7) + a is still a certiﬁcate for C
[E
namely E
add a to it – hence the union with {C

(cid:7)], we get that E

(cid:7)} ˙+ a.

(cid:7)

Similar considerations underly the certiﬁcates of C

, of different subframeworks
(cid:7)
F (cid:2)t(cid:7) , F (cid:2)t(cid:7)(cid:7) to a vcoloring for the union of these subframeworks. Now let D be a certiﬁcate of C and D
a certiﬁcate of C
(cid:7)
then clearly D (cid:3) D
are also certiﬁcates for C (cid:3) C
. But further we have that C (cid:3) D
.
This relies on the fact that for a ⊂-relationship in the combined AF, it suﬃces to have a ⊂-relationship in one of the
subframeworks and a ⊆-relationship in the other.

. Here we combine vcolorings C , C

is a certiﬁcate for C (cid:3) C

and D (cid:3) C

(cid:7)(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7) (cid:3) C

(cid:7)(cid:7)

(cid:7)

Example 18. Recall the AF from Example 9. The computation of vpairs for nodes t is illustrated in Fig. 10. As before we
use the #-column to notate the cardinality of the sets et(C, Γ ) for better readability. Furthermore, we use the (cid:2) symbol to
illustrate how to decide SA – a detailed explanation of this concept follows in Example 23. Also observe that we indeed have
pairs (C, Γ ) and (C, Γ (cid:7)) with Γ (cid:13)= Γ (cid:7)
for the same node. An example is node n5 with bag {b, c} on the left branch and the
coloring C1 with C1(b) = def and C1(c) = in, i.e. [C1] = {c}. We have that et(C1) = {{c}, {a, c}}. However, et(C1, {C1}) = {{c}}
(since we have {a, c} as certiﬁcate), while et(C1, ∅) = {{a, c}}.

In what follows, we show that vpairs match the concept of valid pairs and thus are appropriate for our purposes.
Similarly as for vcolorings, we will do this step-by-step distinguishing between the different node types. We start with the
nodes of type LEAF:

Lemma 13. For any LEAF node in a tree decomposition of an AF, its vpairs coincide with its valid pairs.

Proof. Let (T , X ) be a tree decomposition of F and t a leaf node in T . The X>t -restricted admissible sets for F (cid:2)t coincide
with the sets [C] for the valid colorings C ∈ Ct . Moreover, the valid colorings and vcolorings for t coincide by Lemma 3.
Now let (C, Γ ) be a valid pair for t. Then, by Deﬁnition 17, [C] ∈ et(C, Γ ). Hence, by Deﬁnition 18, (C, Γ ) is a vpair for t.
Conversely, let (C, Γ ) be a vpair for t and let S = [C]. By Deﬁnition 16, S is X>t -restricted admissible for F (cid:2)t . Hence, by
Deﬁnitions 17 and 18, S ∈ et(C, Γ ). (C, Γ ) is thus a valid pair for node t. (cid:2)

Example 19. Consider, for instance, the LEAF node n13 in Fig. 10. As mentioned before we have four valid colorings
C1, C2, C3, C4 that correspond to the ∅-restricted admissible sets {e}, { f }, {g}, ∅ of F (cid:2)n13 . One can see that the ﬁrst three sets
are ⊆-maximal in being ∅-restricted admissible for F (cid:2)n13 and thus correspond to the vpairs (C1, ∅), (C2, ∅), (C3, ∅) of n13.
On the other hand, ∅ has three such supersets, namely {e}, { f }, {g}, and thus the corresponding vpair is (C4, {C1, C2, C3}).

Next we consider FORGET nodes:

Lemma 14. For any FORGET node t in a tree decomposition of an AF, vpairs and valid pairs coincide, if they coincide in the child node t
of t.

(cid:7)

Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t a FORGET node in T , and t
Xt = Xt(cid:7) \ {a}, for some argument a ∈ Xt(cid:7) .

(cid:7)

the child node of t. We have that

24

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

Fig. 10. Computation of vpairs for the example AF.

First we show that every valid pair for t is also a vpair for t. Thus let (C, Γ ) be a valid pair for t. Then there exists a set
S ∈ et(C, Γ ). In particular, S is X>t -restricted admissible for F (cid:2)t , and hence, also X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) = F (cid:2)t .
(cid:7), Γ (cid:7)) is a
Thus, by Lemmas 11 and 12, there exists a unique valid pair (C
(cid:7) − a, Γ (cid:7) − a) is a vpair
vpair for t
for t. We claim that (C

. Since S is X>t -restricted admissible for F (cid:2)t and S ∈ et(cid:7) (C

(cid:7) − a, Γ (cid:7) − a) = (C, Γ ) holds.

(cid:7), Γ (cid:7)). By assumption, (C

(cid:7)(a) (cid:13)= att. Then (C

with S ∈ et(cid:7) (C

(cid:7)), we have C

(cid:7), Γ (cid:7)) for t

(cid:7)

(cid:7)

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

25

, such that C

(cid:7) − a = C , recall the construction from the proof of Lemma 5, where we constructed a coloring, which we denote
For C
∗
and thus
here as C
(cid:7) − a = C .
C

(cid:7)) holds, by Lemma 2 we have that C

∗ − a = C and S ∈ et(cid:7) (C

∗). As also S ∈ et(cid:7) (C

To show Γ (cid:7) − a = Γ , we ﬁrst consider the inclusion Γ (cid:7) − a ⊆ Γ : Let D

(cid:7)(a) (cid:13)= att. By condition (ii) of
(cid:7)(a) (cid:13)= att, we know
Deﬁnition 17, there exists an X>t(cid:7) -restricted admissible set E for F (cid:2)t(cid:7) with S ⊂ E and E ∈ et(cid:7) (D
that E is also X>t -restricted admissible. Hence, by condition (iii) of Deﬁnition 17, there exists D ∈ Γ with E ∈ et(D). As
(cid:7) − a. Hence,
before one can use the construction from the proof of Lemma 5 together with Lemma 2, to obtain D = D
Γ (cid:7) − a ⊆ Γ .

(cid:7)). By D

(cid:7) ∈ Γ (cid:7)

with D

(cid:7) = C

∗

Now consider an arbitrary coloring D in Γ . By condition (ii) of Deﬁnition 17, there exists an X>t -restricted admissible
set E for F (cid:2)t with S ⊂ E and E ∈ et(D). By condition (iii) of Deﬁnition 17 and since E is also X>t(cid:7) -restricted admissible for
(cid:7)). Again by the construction from the proof of Lemma 5 and Lemma 2 we have
F (cid:2)t(cid:7) , there exists D
that D = D

(cid:7) ∈ Γ (cid:7)
(cid:7) − a. Hence, Γ ⊆ Γ (cid:7) − a.

with E ∈ et(cid:7) (D

(cid:7), Γ (cid:7)) for node t
(cid:7)
a vpair (C
Hence, there exists S ∈ et(cid:7) (C
C = C

We now show that every vpair for the FORGET node t is also valid pair for t. Let (C, Γ ) be a vpair for t, i.e., there exists
(cid:7)
(cid:7), Γ (cid:7)) is a valid pair for t
with C
.
(cid:7), Γ (cid:7)). We claim that also S ∈ et(C, Γ ) holds. As in the proof of Lemma 5, S ∈ et(C) holds since

(cid:7) − a, Γ (cid:7) − a). By assumption, (C

(cid:7)(a) (cid:13)= att and (C, Γ ) = (C

(cid:7) − a. It remains to show that also conditions (ii) and (iii) of Deﬁnition 17 are fulﬁlled.
with D

To show condition (ii), let D ∈ Γ , i.e., D is of the form D = D

(cid:7) ∈ Γ (cid:7)
(cid:7)) with S ⊂ E. As in the proof of Lemma 5, then also E ∈ et(D

(cid:7)(a) (cid:13)= att. Since S ∈ et(cid:7) (C
(cid:7), Γ (cid:7)),
(cid:7) − a). To show condition (iii), let E be
there exists E ∈ et(cid:7) (D
X>t -restricted admissible for F (cid:2)t with S ⊂ E. Then E is also X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) , and therefore, there exists
(cid:7)(a) (cid:13)= att. But then, as in the proof of Lemma 5,
(cid:7) ∈ Γ (cid:7)
D
also E ∈ et(D

(cid:7)). Since E is X>t -restricted admissible, we have D

with E ∈ et(cid:7) (D
(cid:7) − a). (cid:2)

(cid:7) − a for some D

Example 20. As an example for a FORGET node, consider the node n12 in Fig. 10, which removes argument g from its child
] = { f }. This
node n13. The vpairs of n12 are obtained from the vpairs of n13 with the exception of the vpair (C
(cid:7)
2, ∅) is not propagated by deﬁnition
is due to the fact that C
})
(since C
of n13 which leads to the vpair (C3, {C1, C2}) for n12.

(cid:7)
2 is not further propagated as a vcoloring; thus also the vpair (C

(cid:7)
2(g) = att). For the same reason, we also have to eliminate C

(cid:7)
2 from the certiﬁcates of the vpair (C

(cid:7)
2, ∅) with [C

(cid:7)
4, {C

(cid:7)
1, C

(cid:7)
2, C

(cid:7)
2

(cid:7)
3

We continue with nodes of type INSERT.

Lemma 15. For any INSERT node t in a tree decomposition of an AF, vpairs and valid pairs coincide, if they coincide in the child node t
of t.

(cid:7)

Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t an INSERT node in T , and t
that Xt = Xt(cid:7) ∪ {a} for some argument a ∈ A.

(cid:7)

the child node of t. Hence we have

First we show that every valid pair for t is also a vpair for t. Thus let (C, Γ ) be a valid pair for t. Then there exists
(cid:7) = S \ {a} is X>t(cid:7) -restricted admissible for
(cid:7), Γ (cid:7)). By assumption,
(cid:7)] ∪ a is
(cid:7) ˙+ a, Γ (cid:7) ˙+ a) = (C, Γ )

S ∈ et(C, Γ ), which is X>t -restricted admissible for F (cid:2)t and further the set S
F (cid:2)t(cid:7) . Thus, by Lemmas 11 and 12, there exists a unique valid pair (C
(C
conﬂict-free in Ft(cid:7) , then also (C
holds.

(cid:7) ∈ et(cid:7) (C
(cid:7)} ˙+ a) is a vpair for t and further if [C
(cid:7) + a, Γ1) = (C, Γ ) or (C

(cid:7) + a, Γ1) with Γ1 = (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ ({C
(cid:7) ˙+ a, Γ (cid:7) ˙+ a) is a vpair. We claim that either (C

(cid:7), Γ (cid:7)) is a vpair for t

(cid:7), Γ (cid:7)) for t

. Then (C

with S

(cid:7)

(cid:7)

To show that either C = C

(cid:7) + a (if a /∈ S) or C = C
∗
a coloring, which we denote here as C
(cid:7) = C
holds, by Lemma 2 we have that C

, such that C = C
∗
and the assertion follows.

(cid:7) ˙+ a (if a ∈ S) holds, recall the proof of Lemma 7, where we constructed
(cid:7))

∗). As also S \ {a} ∈ et(cid:7) (C

∗ ˙+ a and S \ {a} ∈ et(cid:7) (C

∗ + a or C = C

In the following we show that also the respective sets of certiﬁcates coincide. To this end we distinguish the two

mentioned cases a /∈ S and a ∈ S, respectively:

(1) Assume a /∈ S: To derive Γ1 = Γ , we ﬁrst show the relation Γ1 ⊆ Γ ; this can be split up into the following three

statements:

(α) Γ

(cid:7) + a ⊆ Γ,

(β) Γ

and (γ )

(cid:7)

(cid:7)

(cid:5)

C

˙+ a ⊆ Γ.

(cid:7) ˙+ a ⊆ Γ,
(cid:7) ∈ Γ (cid:7)
(cid:7) ∈ et(cid:7) (D

(cid:7)

(cid:7)

(cid:7) ⊂ E

for F (cid:2)t(cid:7) with S

To show (α) and (β), consider D
. By condition (ii) of Deﬁnition 17, there exists an X>t(cid:7) -restricted admissible
(cid:7) ∪ {a}
(cid:7)). As we have here S = S
, we obtain S ⊂ E = E
and E
set E
for (β). In the ﬁrst case we have that E is conﬂict-free in F (cid:2)t by deﬁnition, and further as X>t = X>t(cid:7) and a /∈ X>t
(cid:7)] ∪ {a} is
it is also an X>t -restricted admissible set for F (cid:2)t . In the latter case E is conﬂict-free in F (cid:2)t iff the set [D
conﬂict-free. This is due to the deﬁnition of tree decompositions which ensures that there are no attacks between the
set X>t and the new argument a. Using that a is not attacked by X>t we get that if E is conﬂict-free in F (cid:2)t then E is
also an X>t -restricted admissible set for F (cid:2)t .
Now by condition (iii) of Deﬁnition 17 there exists D ∈ Γ such that E ∈ et(D). As before, using the construction from the
(cid:7) + a, and in the case (β)
proof of Lemma 7 together with Lemma 2, we obtain that, in the case (α) it holds that D = D

for (α), and S ⊂ E = E

(cid:7)

(cid:7)

26

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

(cid:7)

(cid:7)} ˙+ a). If ({C

(cid:7)} ˙+ a ⊆ Γ and ﬁnally Γ1 ⊆ Γ .

(cid:7) ˙+ a) and as S ⊂ S ∪ {a} that C

(cid:7)} ˙+ a) = ∅
(cid:7) ˙+ a ∈ Γ . Hence,

(cid:7) ˙+ a. Next we prove statement (γ ). To do this let us consider the set ({C

it holds that D = D
statement (γ ) is trivially true. Otherwise we have that S ∪ {a} ∈ et(C
{C
To prove Γ ⊆ Γ1, consider an arbitrary D ∈ Γ . By condition (ii) of Deﬁnition 17, there exists an X>t -restricted admis-
(cid:7) = E \ {a} either
sible set E for F (cid:2)t with S ⊂ E and E ∈ et(D). By the assumption a /∈ S, i.e. S = S
(cid:7) ⊂ E
is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) and thus
S
(cid:7)). Now we can use the proof of Lemma 7 together with Lemma 2 to show that in
there exists D
(cid:7) ⊂ E
the case S

(cid:7) = S) holds. In both cases we have that E
(cid:7) ∈ et(cid:7) (D
(cid:7) + a or D = D

or E = S ∪ {a} (i.e. E
(cid:7) ∈ Γ (cid:7)
with E
(cid:7)

(cid:7) ˙+ a and D = C
(2) Assume a ∈ S: To show Γ (cid:7) ˙+ a = Γ , we ﬁrst consider the inclusion Γ (cid:7) ˙+ a ⊆ Γ : Consider D

(cid:7) ∈ Γ (cid:7)
. By condition (ii) of
(cid:7)). As by assumption
(cid:7) ∈ et(cid:7) (D
Deﬁnition 17, there exists an X>t(cid:7) -restricted admissible set E
(cid:7)] ∪ {a} is conﬂict-free then E is X>t -restricted
S = S
admissible for F (cid:2)t . In this case we get by Deﬁnition 17 that there exists D ∈ Γ such that E ∈ et(D). By the construction
from the proof of Lemma 7 and Lemma 2, it holds that D = D
To prove Γ ⊆ Γ1, consider an arbitrary D in Γ . By condition (ii) of Deﬁnition 17, there exists an X>t -restricted admis-
(cid:7) ⊂ E
sible set E for F (cid:2)t with S ⊂ E and E ∈ et(D). We have that S
is X>t(cid:7) -restricted
(cid:7)). By the construction from the proof of Lemma 7
(cid:7) ∈ et(cid:7) (D
admissible for F (cid:2)t(cid:7) . Thus there exists D
(cid:7) ˙+ a. Hence, Γ ⊆ Γ (cid:7) ˙+ a holds.
and Lemma 2, we get that D = D

(cid:7) ∪ {a}. Further as in case (1) if [D

(cid:7) ˙+ a otherwise. Hence, Γ ⊆ Γ1.

(cid:7) ∪ {a} we have that S ⊂ E = E

(cid:7) = E \ {a} and further that E

(cid:7) ˙+ a. Hence, Γ (cid:7) ˙+ a ⊆ Γ .

, we have that for E

for F (cid:2)t(cid:7) with S

, D = D

(cid:7) ∈ Γ (cid:7)

with E

(cid:7) ⊂ E

and E

(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7), Γ (cid:7)) for node t

It remains to show that every vpair for an INSERT node is also a valid pair. Thus let (C, Γ ) be a vpair for t, i.e., there exists
(cid:7) ˙+ a, Γ (cid:7) ˙+ a)
a vpair (C
(cid:7), Γ (cid:7)). To
with [C] ∪ {a} being conﬂict-free in Ft . By assumption, (C
show that (C, Γ ) is a valid pair for t we distinguish the cases (1) and (2) as follows:

(cid:7) + a, Γ1) (Γ1 deﬁned as above) or (2) (C, Γ ) = (C

such that either (1) (C, Γ ) = (C

(cid:7), Γ (cid:7)) is a valid pair for t

and thus there exists S

(cid:7) ∈ et(cid:7) (C

(cid:7)

(cid:7)

(1) As in the proof of Lemma 7, S = S

(cid:7) ∈ et(C) holds since C = C

(cid:7) + a. It remains to show that also conditions (ii) and (iii)

(cid:7)

(cid:7)) with S ⊂ E

(cid:7), Γ (cid:7)), there exists E

(cid:7)] ∪ {a} conﬂict-free in Ft .

(cid:7) + a,
(cid:7) ˙+ a with [D] ∪ {a} conﬂict-free in Ft , or
(cid:7) ˙+ a with [C

(cid:7) ∈ et(cid:7) (D
(cid:7) + a). For case (b), we get by the construction of D that E = E

of Deﬁnition 17 are fulﬁlled. To show condition (ii), consider an arbitrary D ∈ Γ , i.e., D is either of the form
(a) D = D
(b) D = D
(c) D = C
Since S ∈ et(cid:7) (C
. In case (a), we follow the proof of Lemma 7, and obtain
(cid:7) ∪ {a} is conﬂict-free in F (cid:2)t . Once more we
(cid:7) ∈ et(D
E
can use the fact Xt (cid:13)(cid:2) a to obtain that E is an X>t -restricted admissible set for F (cid:2)t . Further S ⊂ E and as in the proof
(cid:7) ˙+ a yields that E = S ∪ {a} is conﬂict-
of Lemma 7, then also E ∈ et(D
free in F (cid:2)t and thus as before E is an X>t -restricted admissible set for F (cid:2)t . Hence, as in the proof of Lemma 7, also
E ∈ et(C
To show condition (iii), consider an arbitrary X>t -restricted admissible set E for F (cid:2)t such that S ⊂ E. Then E
(cid:7)
is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) . If E
(cid:7)
with E ∈ et(cid:7) (D
it holds that S ⊂ E
have that there is a unique vcoloring D such that E ∈ et(D). But then, as in the proof of Lemma 7, either D = C
D = D

(cid:7) = E \ {a}
(cid:7) (cid:13)= S
(cid:7)). Since E is X>t -restricted admissible for F (cid:2)t , we
(cid:7) ˙+ a,

(cid:7) ˙+ a) holds. Further, as a /∈ S, we have that S ⊂ E.

(cid:7) ˙+ a). Finally, for (c) the construction of D = C

is the unique vcoloring such that E ∈ et(cid:7) (C

(cid:7) = S then C
(cid:7) ∈ Γ (cid:7)

(cid:7)). Otherwise if E

and thus, there exists D

(cid:7) + a or D = D

(cid:7) ˙+ a we have that S = S

(cid:7)]∪{a} conﬂict-free in Ft . Since S

(cid:7) ∪ {a} ∈ et(C). It remains to show that the vpair (C, Γ ) also satisﬁes
(cid:7) ˙+ a with
. By the construction of D we have
(cid:7) ∪ {a} is conﬂict-free and thus that E is an X>t -restricted admissible set for F (cid:2)t . By deﬁnition of E it holds
(cid:7) ˙+ a). To show condition (iii) of Deﬁnition 17,
(cid:7) = E \ {a} is X>t(cid:7) -restricted admissible for
(cid:7)). Since E is X>t -restricted admissible, we have

conditions (ii) and (iii) of Deﬁnition 17. To show condition (ii), consider D ∈ Γ , i.e., D is of the form D = D
[D
that E = E
that S ⊂ E and further, as in the proof of Lemma 7, we get that E ∈ et(D
let E be an X>t -restricted admissible set for F (cid:2)t such that S ⊂ E. Then E
(cid:7) ∈ Γ (cid:7)
F (cid:2)t(cid:7) and S \ {a} = S
. Thus, there exists D
that there is a unique vcoloring D such that E ∈ et(D). But then, as in the proof of Lemma 7, D = D

(cid:7), Γ (cid:7)), there exists E

(cid:7) ˙+ a holds. (cid:2)

(cid:7) ˙+ a holds.

(cid:7) ∈ et(cid:7) (D

(cid:7)) with S

(cid:7) ∈ et(cid:7) (D

(cid:7) ∈ et(cid:7) (C

(cid:7) ⊂ E

(cid:7) ⊂ E

with E

(cid:7)

(cid:7)

(2) By the assumption C = C

(cid:7)
2

(cid:7)
1

(cid:7)
1, C

(cid:7)
3, {C

Example 21. Consider the INSERT node n11 in Fig. 10, which adds the argument d. Let us illustrate how vpairs of n11 are
] = ∅. There are two ways to
obtained from the vpairs of n12. For instance, consider the vpair (C
incorporate the argument d for the resulting vpairs of n11. We ﬁrst consider adding the argument d to the extensions, i.e.
we set C(d) = in. As the certiﬁcates represent supersets we have to extend them in the same way, otherwise the ⊂-relation
˙+ d = C2. In the ﬁrst case we have that the set
would be violated. In our example we have to consider C
[C
] ∪ d is conﬂict-free and thus
we obtain C2 as certiﬁcate and we end up with the vpair (C4, {C2}).

] ∪ d contains a conﬂict and thus it is neither a vcoloring nor a certiﬁcate. But the set [C

}) of n12, with [C

˙+ d and C

Now let us consider not adding d to the vpair (C

out, C5(e) = out, C5( f ) = out. Now both adding d or not adding d to the certiﬁcates {C
(cid:7)
(cid:7)
we have both {C
1, C
2
seen to {C2} ⊆ Γ . Further, as C4 = C
(C5, {C1, C2, C3, C4}).

+ d, with C5(d) =
} preserve the ⊂-relation. Thus
} ˙+ d ⊆ Γ . The ﬁrst leads to {C1, C3} ⊆ Γ and the latter as we already have
(cid:7) + d, we also get C4 ∈ Γ . In total, we obtain the vpair

}). This results in the vcoloring C5 = C

(cid:7) ˙+ d represents supersets of C

} + d ⊆ Γ and {C

(cid:7)
3, {C

(cid:7)
1, C

(cid:7)
1, C

(cid:7)
1, C

(cid:7)
2

(cid:7)
3

(cid:7)
2

(cid:7)
3

(cid:7)
2

(cid:7)
2

(cid:7)
1

(cid:7)
2

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

27

Lemma 16. For any JOIN node t in a tree decomposition of an AF, the vpairs coincide with the valid pairs if they coincide on the
successors t

and t

of t.

(cid:7)(cid:7)

(cid:7)

Proof. Let (T , X ) be a tree decomposition of F = ( A, R) and t a JOIN node in T with successors t

(cid:7)

and t

(cid:7)(cid:7)

.

First consider an arbitrary valid pair (C, Γ ) for t. We show that (C, Γ ) is also a vpair. As (C, Γ ) is valid there exists
an X>t -restricted admissible set S for F (cid:2)t such that S ∈ et(C, Γ ). As in the proof of Lemma 8 we have that there exist
(cid:7), C
(cid:7)(cid:7)
unique sets S1 ⊆ X(cid:2)t(cid:7) and S2 ⊆ X(cid:2)t(cid:7)(cid:7) , such that S1 ∩ Xt = S2 ∩ Xt and S = S1 ∪ S2. Further, there exist valid colorings C
(cid:7)(cid:7), Γ (cid:7)(cid:7)), such
such that S1 ∈ et(cid:7) (C
∗, Γ ∗) and
that S1 ∈ et(cid:7) (C
∗
(cid:7) (cid:13)= C
C

with the above properties is unique.) By assumption these valid pairs are also vpairs.

(cid:7)(cid:7), Γ (cid:7)(cid:7)). (Note that by Lemma 2 there cannot be a pair (C

(cid:7), Γ (cid:7)) and (C
∗, Γ ∗) with S1 ∈ et(C

. Thus, by Lemma 11 there are valid pairs (C

(cid:7), Γ (cid:7)) and S2 ∈ et(cid:7)(cid:7) (C
(cid:7)(cid:7)

(cid:7)), S2 ∈ et(cid:7)(cid:7) (C

(cid:7)(cid:7)) and C = C

. Analogously, C

Now we turn our attention to the set Γ . We ﬁrst have to show that Γ ⊆ Γ ∗
(cid:7)} (cid:3) Γ (cid:7)(cid:7)) ∪ (Γ (cid:7) (cid:3)
(cid:7)(cid:7)}). For every D ∈ Γ there exists an X>t -restricted admissible set E ∈ et(D) such that S ⊂ E. We deﬁne E = E1 ∪ E2

with Γ ∗ = (Γ (cid:7) (cid:3) Γ (cid:7)(cid:7)) ∪ ({C

{C
analogously to S1, S2. Now we have that S ⊂ E holds iff either

(cid:7) (cid:3) C

(cid:7)(cid:7)

(i) S1 ⊂ E1 ∧ S2 ⊂ E2,

(ii) S1 = E1 ∧ S2 ⊂ E2

or

(iii) S1 ⊂ E1 = S2 ⊂ E2

holds. We discuss these three cases separately:

(i) As E1 is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) and E2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) , there exist sets D

(cid:7)) and E2 ∈ et(cid:7)(cid:7) (D

(cid:7)(cid:7)). By the proof of Lemma 8 and Lemma 2 we have that D = D

(cid:7) ∈ Γ (cid:7)

and
(cid:7)(cid:7)
(cid:7) (cid:3) D

(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)

, such that E1 ∈ et(cid:7) (D

D
and thus D ∈ Γ (cid:7) (cid:3) Γ (cid:7)(cid:7)

.
(ii) As E2 is X>t(cid:7)(cid:7) -restricted admissible there exists D
(cid:7) (cid:3) D

(cid:7)(cid:7)
(iii) By the symmetry to case (ii) we get that D ∈ (Γ (cid:7) (cid:3) {C

we have that D = C

and thus D ∈ ({C

(cid:7)} (cid:3) Γ (cid:7)(cid:7)).

(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)

(cid:7)(cid:7)}).

such that E2 ∈ et(cid:7)(cid:7) (D

(cid:7)(cid:7)). By the proof of Lemma 8 and Lemma 2

Thus we have that Γ ⊆ Γ ∗
(cid:7) (cid:3) Γ

(cid:7)(cid:7) ⊆ Γ,

(i) Γ

. It remains to show that Γ ∗ ⊆ Γ which is equivalent to showing each of the following inclusions:

(cid:5)

(ii)

C

(cid:7)

(cid:7)

(cid:3) Γ

(cid:7)(cid:7) ⊆ Γ and (iii) Γ

(cid:7) (cid:3)

(cid:7)

(cid:7)(cid:7)

(cid:5)

C

⊆ Γ.

This can be done as follows:

(i) Consider arbitrary D

(cid:7)] = [D
S1 ⊂ E1 and S2 ⊂ E2. We conclude that S ⊂ E and by the proof of Lemma 8 and Lemma 2 that D = D
unique coloring such that E ∈ et(D). Therefore D

(cid:7)(cid:7) ∈ Γ and thus Γ (cid:7) (cid:3) Γ (cid:7)(cid:7) ⊆ Γ .

(cid:7)(cid:7)). By Deﬁnition 17 we have that
is the

(cid:7)) and E2 ∈ et(cid:7)(cid:7) (D

(cid:7)(cid:7)], E1 ∈ et(cid:7) (D

with [D

(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)

(cid:7) ∈ Γ (cid:7)

(cid:7) (cid:3) D

(cid:7) (cid:3) D

and D

(cid:7)(cid:7)

(ii) Consider an arbitrary D

(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)

with [C

(cid:7)] = [D

is the unique coloring such that E ∈ et(D). Thus {C

(cid:7)(cid:7)] and E2 ∈ et(cid:7)(cid:7) (D
(cid:7)} (cid:3) Γ (cid:7)(cid:7) ⊆ Γ .

(cid:7)(cid:7)). We have that S ⊂ E = S1 ∪ E2 and that D = C

(cid:7) (cid:3) D

(cid:7)(cid:7)

(iii) By symmetry to (ii).

This shows Γ = Γ ∗

and thus every valid pair (C, Γ ) is also a vpair.

(cid:7)

Now we show that every vpair for t is also a valid pair for t. Thus let (C, Γ ) be a vpair for t, i.e., there exists a vpair
(cid:7), Γ (cid:7)) for node t
deﬁned as
(cid:7)(cid:7), Γ (cid:7)). As

(cid:7)] = [C
(cid:7)(cid:7), Γ (cid:7)(cid:7)) are valid pairs. Hence, there exist sets S1 ∈ et(cid:7) (C

(C
above). By assumption (C
in the proof of Lemma 8, S = S1 ∪ S2 ∈ et(C) holds since [C

(cid:7)(cid:7)] = [C
It remains to show that (C, Γ ) also fulﬁlls conditions (ii) and (iii) of Deﬁnition 17. To show condition (ii), consider D ∈ Γ ,

(cid:7)(cid:7)] such that (C, Γ ) = (C

(cid:7), Γ (cid:7)) and S2 ∈ et(cid:7)(cid:7) (C

(cid:7)(cid:7), Γ (cid:7)(cid:7)) for node t

(cid:7), Γ (cid:7)) and (C

and a vpair (C

(cid:7)(cid:7), Γ ∗) (Γ ∗

with [C

(cid:7) (cid:3) C

(cid:7)].

(cid:7)(cid:7)

i.e., D is of one of the following forms:

(a) D = D
(b) D = C
(c) D = D

(cid:7)(cid:7)

(cid:7) (cid:3) D
(cid:7)(cid:7)
(cid:7) (cid:3) D
(cid:7) (cid:3) C

(cid:7)(cid:7)

for some D
for some D
for some D

(cid:7) ∈ Γ (cid:7)
(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)
(cid:7) ∈ Γ (cid:7)

, D

(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)
with [C
with [C

with [D
(cid:7)(cid:7)];
(cid:7)] = [D
(cid:7)].
(cid:7)(cid:7)] = [D

(cid:7)] = [D

(cid:7)(cid:7)];

We only discuss case (a) here as the cases (b) and (c) are similar: Since S 1 ∈ et(cid:7) (C
E1 ∈ et(cid:7) (D
E1 ∪ E2 ∈ et(D

(cid:7)(cid:7), Γ (cid:7)(cid:7)), there exist
(cid:7)(cid:7)) with S ⊂ E1, S ⊂ E2 and E1 ∩ Xt = E2 ∩ Xt . As in the proof of Lemma 8, then also E =

(cid:7), Γ (cid:7)) and S2 ∈ et(cid:7)(cid:7) (C

(cid:7)) and E2 ∈ et(cid:7)(cid:7) (D

(cid:7)(cid:7)) and S ⊂ E.

To show condition (iii), let E be X>t -restricted admissible for F (cid:2)t with S ⊂ E. Then E1 is X>t(cid:7) -restricted admissible
(cid:7)(cid:7)),

with E1 ∈ et(cid:7) (D

(cid:7)), E2 ∈ et(cid:7)(cid:7) (D

(cid:7) (cid:3) D

and D

(cid:7)(cid:7)

(cid:7)

for F (cid:2)t(cid:7) and E2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) . Hence there exist sets D
E1 ∩ Xt = E2 ∩ Xt , and either
(cid:7)(cid:7)
(cid:7) ∈ Γ

(c) D
holds. But then, as in the proof of Lemma 8, also E = E 1 ∪ E2 ∈ et(D

(cid:7) ∈ Γ
(cid:7) (cid:3) D

, D
(cid:7)(cid:7)). (cid:2)

(cid:7)(cid:7) ∈ Γ

(cid:7)(cid:7) ∈ Γ

(cid:7) = C

(b) D

(a) D

(cid:7)(cid:7) = C

, D

, D

or

,

(cid:7)(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7)(cid:7)

Example 22. To give an example consider the JOIN node n2 in Fig. 10. Let us have a look at the pair (C
(cid:7)
1(c) = in, C
C

(cid:7)
1(d) = def , and pair (C

(cid:7)(cid:7)
1 , ∅) of n8 with C

(cid:7)(cid:7)
1 (d) = def . As [C

(cid:7)(cid:7)
1 (c) = in, C

] = [C

(cid:7)(cid:7)
1

(cid:7)
1

(cid:7)
}) of n3 with
1, {C
] we combine these vpairs using

(cid:7)
1

28

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

the (cid:3) operations. The join C
(cid:3) C
have to consider the sets Γ (cid:7) (cid:3) Γ (cid:7)(cid:7)
to the certiﬁcate C1. In this way, we have obtained the vpair (C1, {C1}) for n2.

(cid:7)(cid:7)
1 leads to the vcoloring C1 with C1(c) = in and C1(d) = def . To update the certiﬁcates we
(cid:7)(cid:7)}. The ﬁrst two sets are empty as Γ (cid:7)(cid:7) = ∅ and the third one leads
, {C

, and Γ (cid:7) (cid:3) {C

(cid:7)} (cid:3) Γ (cid:7)(cid:7)

(cid:7)
1

Theorem 7. Let (T , X ) be a nice tree decomposition of an AF F = ( A, R). Then, for each pair (C, Γ ) for a node t, it holds that (C, Γ )
is a valid pair for t iff (C, Γ ) is a vpair for t.

Proof. As in Theorem 5, the proof proceeds by structural induction. For the induction base, we have to show that vpairs
and valid pairs coincide on LEAF nodes, which is the case due to Lemma 13. For the induction step, we have to show this
property for the remaining nodes. Indeed, this is captured by Lemmas 14, 15 and 16. (cid:2)

Thus, we now have a handle to eﬃciently decide skeptical acceptance for bounded tree-width. We just have to mark all
pairs (C, Γ ) where the considered argument a satisﬁes C(a) (cid:13)= in and pass this mark accordingly towards the root node. If
((cid:7), ∅) carries this mark, then we know that skeptical acceptance does not hold.

Example 23. Let us now consider the problem of deciding if the argument a is skeptically accepted in our example AF. In
Fig. 10 we illustrate the vpairs which are marked as contradictory for skeptical acceptance with a (cid:2) in the last column of
the table. Note that for a vpair (C, Γ ) to be marked it is suﬃcient that for one set S ∈ et(C, Γ ) it holds that a /∈ S. The
counter # in Fig. 10 still refers to all X>t -admissible sets (for F (cid:2)t ) in et(·,·). Thus, the number of such sets S ∈ et(·,·) with
a /∈ S is, in general, smaller.

Theorem 8. Deciding SA for an AF F = ( A, R) of tree-width k − 1 can be done in time O (222k+1+8k · | A|).

Proof. Recall that the number of colorings for each node is bounded by 4k. In order to maintain the vpairs for each node,
we consider all possible pairs (C, Γ ), where C is a coloring and Γ is a set of colorings. Hence, we have to consider at most
4k · 24k = 2n pairs at each node, where n = 22k + 2k (we use abbreviation n throughout the proof). Analogously to the proof
of Theorem 6, we can store the vpairs for a node t in a table with one row per possible pair (C, Γ ). In an additional bit we
indicate if this row represents a vpair. Given a pair (C, Γ ), we can ﬁnd the corresponding row in time O (n).

We have to show that computing the vpairs at each node t ∈ T is feasible in time O (222k+1+8k) in a single bottom-up
traversal of T . Since the number of nodes of T may be assumed to be bounded by O (| A|), the desired upper bound of
the theorem follows immediately. We prove the upper bound O (222k+1+8k) for the time needed at each node t ∈ T by
distinguishing the four types of nodes. As in the proof of Theorem 6, the computationally most expensive node type is the
JOIN node, which is the one we shall focus on below. The other node types are treated similarly.

and t

. To compute the table of vpairs for t, we iterate in a nested loop over
Let t be a JOIN node with successors t
(cid:7), Γ (cid:7)) in the table at t
(cid:7)
(cid:7), Γ (cid:7)) is a
all pairs (C
(cid:7)(cid:7), (Γ (cid:7) (cid:3) Γ (cid:7)(cid:7)) ∪ (Γ (cid:7) (cid:3)
(cid:7)(cid:7), Γ (cid:7)(cid:7)) is a vpair and [C
vpair and (C
(cid:7)} (cid:3) Γ (cid:7)(cid:7))) and set the vpair-bit in the row corresponding to (C, Γ ) in the table at node t. As in the proof of
(cid:7)(cid:7)}) ∪ ({C
{C
Theorem 6, the join operation can be carried out in time O (10k · k). The access to the appropriate row in the table at node t
(cid:7), Γ (cid:7)). Moreover,
is feasible in time O (22k · k). In total, we have to process at most (2n)2 combinations of vpairs (C, Γ ) and (C
the action required for each such combination of vpairs ﬁts into O (10k · k + 22k · k) = O (24k). We thus end up with the upper
bound O ((222k+2k)2 · 24k) = O ((222k+1+4k) · 24k) = O (222k+1+8k). (cid:2)

(cid:7)(cid:7)]. If this is the case, we compute the vpair (C, Γ ) = (C

and all pairs (C
(cid:7)] = [C

and do the following: check if (C

(cid:7)(cid:7), Γ (cid:7)(cid:7)) in the table at t

(cid:7) (cid:3) C

(cid:7)(cid:7)

(cid:7)

(cid:7)(cid:7)

4.3. Characterizing ideal sets

So far, we have solved the credulous and the skeptical acceptance problems. For the ﬁrst problem we used colorings
to characterize admissible sets and for the latter problem we extended our data structure by certiﬁcates Γ , handling the
subset maximality, to characterize preferred extensions. Here, we will reuse the concept of certiﬁcates to characterize ideal
sets. But instead of storing supersets in the certiﬁcates we store certain witnesses against being an ideal set. Such witnesses
have been identiﬁed by Dunne [23] as follows.

Proposition 3. (See [23].) Let F = ( A, R) be an AF and S ⊆ A a set of arguments. S is an ideal set of F iff the following conditions
hold:

• S is admissible in F ;
• for every argument p ∈ S

− = {x ∈ A | (x, s) ∈ R for some s ∈ S}, no admissible set of F contains p.

Intuitively, S is an ideal set of an AF F if S is admissible and S is not attacked by any other admissible set. Therefore,
a certiﬁcate Γ of a pair (C, Γ ) should represent all restricted admissible sets that attack some S ∈ et(C). This is formally
deﬁned next.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

29

Deﬁnition 19. Given a tree decomposition (T , X ) of an AF F and a pair (C, Γ ) for t ∈ T , i.e. where C is a coloring for t and
Γ is a set of colorings for t, deﬁne eID

t (C, Γ ) as the collection of sets S which satisfy the following conditions:

(i) S ∈ et(C);
(ii) for all C
(iii) for all X>t -restricted admissible (for F (cid:2)t ) sets E such that E (cid:2) S there is a C

(cid:7) ∈ Γ , there exists a set E ∈ et(C

(cid:7)), such that E (cid:2) S;

(cid:7) ∈ Γ with E ∈ et(C

(cid:7)).

If eID

t (C, Γ ) (cid:13)= ∅, we call (C, Γ ) an ID-pair for t.

The following lemmas are analogous to Lemmas 1 and 2 (resp. Lemmas 11 and 12).

Lemma 17. Let (T , X ) be a tree decomposition of an AF F , t ∈ T , and S an X>t -restricted admissible set for F (cid:2)t . Then there is a pair
(C, Γ ) with S ∈ eID

t (C, Γ ).

Proof. Let S be an X>t -restricted admissible set for F (cid:2)t . By Lemma 1, there exists a coloring C with S ∈ et(C). Now let
(cid:7))}. We claim that
E = {E | E is X>t -restricted admissible for F (cid:2)t and E (cid:2) S}. Moreover, let Γ = {C
t (C, Γ ). To prove this, we check the conditions (i)–(iii) from Deﬁnition 19: (i) S ∈ et(C) by the selection of C . (ii) For
S ∈ eID
(cid:7)) with E (cid:2) S; this follows by the construction of Γ from E . (iii) For all E being X>t -
(cid:7) ∈ Γ , there exists E ∈ et(C
all C
(cid:7)); again this follows by the construction
restricted sets admissible in F (cid:2)t with E (cid:2) S, there exists C
of Γ from E . (cid:2)

(cid:7) ∈ Γ such that E ∈ et(C

(cid:7) | ∃E ∈ E, s.t. E ∈ et(C

Lemma 18. Let (T , X ) be a tree decomposition of an AF F and let (C, Γ ), (C
eID
t (C

(cid:7), Γ (cid:7)) = ∅.

(cid:7), Γ (cid:7)) be different pairs for t ∈ T . Then, eID

t (C, Γ ) ∩

Proof. If C (cid:13)= C
with Γ (cid:13)= Γ (cid:7)
t (C, Γ ) ∩ eID
eID

(applied to eID
(applied to eID
Thus, ¯C ∈ Γ (cid:7)

(cid:7)

then, by Lemma 2, et(C) ∩ et(C

(cid:7)) = ∅ and our claim follows. Thus, it remains to consider pairs (C, Γ ), (C, Γ (cid:7))
. In order to show that

. W.l.o.g., we assume that there exists a coloring ¯C for t such that ¯C ∈ Γ but ¯C /∈ Γ (cid:7)
t (C, Γ (cid:7)) = ∅, we prove that none of the sets S ∈ eID
t (C, Γ (cid:7)). By Deﬁnition 19
t (C, Γ )), there exists an X>t -restricted admissible set E ∈ et( ¯C) for F (cid:2)t such that E (cid:2) S. By Deﬁnition 19
t (C, Γ (cid:7))), there exists a coloring C
coincide.
, a contradiction. (cid:2)

t (C, Γ (cid:7)).
t (C, Γ ). Suppose to the contrary that S is also contained in eID

∗). By Lemma 2, the colorings ¯C and C

t (C, Γ ) is contained in eID

such that E ∈ et(C

∗ ∈ Γ (cid:7)

∗

Let S be an arbitrary set in eID

In summary, we again conclude that each element S ∈ eID

t (C, Γ ) is an X>t -restricted admissible set for F (cid:2)t and each

X>t -restricted admissible set for F (cid:2)t is characterized by a unique ID-pair for t.

Proposition 4. Let r be the root of a nice tree decomposition (T , X ) of an AF F . Then, eID

r ((cid:7), ∅) = ideal(F ).

r ((cid:7), ∅) ⊆ ideal(F ), let S be an arbitrary set such that
Proof. We recall that er((cid:7)) = adm(F ). To show the set inclusion eID
S ∈ eID
r ((cid:7), ∅). By Deﬁnition 19(i), we obtain that S is X>r -restricted admissible in F (cid:2)r , i.e. (since the root has an empty bag)
S is an admissible set for F . Further by (iii) and the fact that Γ = ∅ we conclude that there is no admissible set E such that
E (cid:2) S. By Proposition 3, S is thus an ideal extension of F .

It remains to show that eID

r ((cid:7), ∅) ⊇ ideal(F ). Thus let S ∈ ideal(F ) be an arbitrary ideal extension. By Lemmas 17 and 18
we get that there exists a unique ID-pair (C, Γ ) such that S ∈ eID
t (C, Γ ). Since the root has an empty bag we have C = (cid:7) and
further by Deﬁnition 19(ii) and the fact that there is no admissible set E of F such that E (cid:2) S (again using Proposition 3)
we conclude that Γ = ∅. (cid:2)

Thus our pairs have the desired property to characterize ideal extensions. As in the previous subsections, we give now
an alternative deﬁnition of such pairs which allows for an eﬃcient computation (as long as the tree-width of the given AF
is small).

Deﬁnition 20. Let t ∈ T be a node in a nice tree decomposition (T , X ) of an AF and t
Depending on the node type of t we deﬁne an ID-vpair for t as follows:

(cid:7)(cid:7)

(cid:7)

, t

the possible children of t.

• LEAF: Each (C, Γ ) where C ∈ Ct and Γ = {C
• FORGET: If (C

(cid:7), Γ (cid:7)) is an ID-vpair for t
(cid:7) − a, Γ (cid:7) − a) is an ID-vpair for t.
(cid:7), Γ (cid:7)) is an ID-vpair for t

• INSERT: If (C

– (C

(cid:7)

(cid:7)

(cid:7) ∈ Ct | [C
, Xt = Xt(cid:7) \ {a}, and C

(cid:7)] (cid:2) [C]}, is an ID-vpair for t.
(cid:7)(a) (cid:13)= att, then

and Xt = Xt(cid:7) ∪ {a}, then
(cid:7) + a, Γ ) with Γ = (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ {C ∈ Ct | [C] (cid:2) [C
(cid:7) ˙+ a is a vcoloring then (C

(cid:7) + a]} is an ID-vpair for t;
(cid:7) ˙+ a, Γ ) with Γ = (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ {C ∈ Ct | [C] (cid:2) [C

– (C
– if C

(cid:7) ˙+ a]} is an ID-vpair for t as

well.

30

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

• JOIN: If (C
(cid:7) (cid:3) C

– (C

(cid:7), Γ (cid:7)) is an ID-vpair for t
(cid:7)(cid:7), (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7))) is an ID-vpair for t.

(cid:7)(cid:7), Γ (cid:7)(cid:7)) is an ID-vpair for t

, (C

(cid:7)

(cid:7)(cid:7)

, and [C

(cid:7)] = [C

(cid:7)(cid:7)], then

Let us comment on the construction of the set of certiﬁcates for pairs with colorings C

. By the
nature of certiﬁcates for ID-pairs, we have to consider all vcolorings that can be constructed from the certiﬁcates in the
successor nodes (in the case of vpairs in the previous subsection we could restrict ourselves to a certain superset relation).
(cid:7) + a operation. Here we consider a new argument a but do not add it to [C].
Let us ﬁrst explain the construction for the C
(cid:7) ˙+ a. Further we
Now each certiﬁcate E
(cid:7) + a] then all vcolorings E with
may also get new certiﬁcates of C
(cid:7) + a]}. Similar
E(a) = in are certiﬁcates for C
(cid:7) ˙+ a]} captures the colorings E with
considerations underlie the certiﬁcates of C
(cid:7)(cid:7)
[E] (cid:2) a. Next let us consider the certiﬁcates of C
.
The certiﬁcate E
is combined
with each vcoloring D

(cid:7) + a. This is why Γ in the above deﬁnition contains the set {C ∈ Ct | [C] (cid:2) [C

may give rise to several certiﬁcates of C
(cid:7)(cid:7)]. Similarly a certiﬁcate E

(cid:7) + a from the vcolorings of the current node. If a (cid:2) [C

is combined with each vcoloring D
such that [E

(cid:7) ˙+ a, but here the set {C | C ∈ Ct, [C] (cid:2) [C

may give rise to two certiﬁcates of C

. A certiﬁcate E
such that [E

(cid:7) + a and (possibly) E

(cid:7) + a, namely E

(cid:7) ∈ Γ (cid:7)
(cid:7)] = [D

(cid:7)(cid:7)] = [D

(cid:7) (cid:3) C
(cid:7)(cid:7)

(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)

(cid:7) ∈ Γ (cid:7)

(cid:7) (cid:3) C

of t

of t

(cid:7)].

(cid:7)(cid:7)

(cid:7)(cid:7)

(cid:7)

(cid:7)

(cid:7)

(cid:7) + a, C

(cid:7) ˙+ a and C

(cid:7) (cid:3) C

(cid:7)(cid:7)

Example 24. Recall the AF from Example 9. The computation of ID-vpairs for the nodes of the tree decomposition for this
AF is illustrated in Fig. 11. The symbol (cid:5) is now used to mark ID-vpairs that correspond to at least one X>t -restricted
admissible set containing the argument a.

In the following we show that the concept of ID-vpairs coincides with the concept ID-pairs and thus is appropriate for
eﬃciently deciding the problem of ideal acceptance. As before we do this separately for each node type starting with LEAF
nodes:

Lemma 19. For any LEAF node t in a tree decomposition of an AF, the ID-vpairs of t coincide with the ID-pairs of t.

Proof. Let (T , X ) be a tree decomposition of an AF F and t a leaf in T . The X>t -restricted admissible sets for F (cid:2)t coincide
with the sets [C] for the valid colorings C ∈ Ct . Moreover, the valid colorings and vcolorings for t coincide by Lemma 3. Now
let (C, Γ ) be an ID-pair for t. Then, by Deﬁnition 19, [C] ∈ eID
t (C, Γ ). Hence, by Deﬁnition 20, (C, Γ ) is an ID-vpair for t.
Conversely, let (C, Γ ) be an ID-vpair for t and let S = [C]. By Deﬁnition 16, S is X>t -restricted admissible for F (cid:2)t . Hence,
by Deﬁnitions 19 and 20, S ∈ eID

t (C, Γ ). Thus, (C, Γ ) is an ID-pair for t. (cid:2)

Example 25. As an example consider the LEAF node n13 in Fig. 11. The vcolorings C1, C2, C3, C4 correspond to the ∅-
restricted admissible sets {e}, { f }, {g} and ∅. As in our example f (cid:2) e we have that C2 is a certiﬁcate for C1. For similar
reasons we get that C3 is a certiﬁcate for C2 and that C1 is a certiﬁcate for C3. As ∅ has no attackers, the set of certiﬁcates
for C4 is empty.

We proceed with nodes of type FORGET:

Lemma 20. For any FORGET node t in a tree decomposition of an AF, the ID-vpairs and ID-pairs coincide, if they coincide in the child
node t

of t.

(cid:7)

(cid:7)

∗, Γ ∗) is an ID-vpair for t
(cid:7) − a. Since S ∈ eID
t(cid:7) (C

Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t a FORGET node in T , and t
the child node of t. It holds that
Xt = Xt(cid:7) \ {a} for some argument a ∈ Xt(cid:7) . First we show that every ID-pair for t is also an ID-vpair for t. Thus let (C, Γ )
be an ID-pair for t and S ∈ eID
t (C, Γ ). In particular, S is X>t -restricted admissible for F (cid:2)t and, hence, by Lemma 4 also
∗, Γ ∗).
X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) = F (cid:2)t . Thus, by Lemma 17, there exists an ID-pair (C
(cid:7)),
(cid:7)
By assumption, (C
(cid:7)(a) (cid:13)= att, and C = C
C
by Lemma 2.
Hence, by C

(cid:7)
∗ = C
(cid:7) − a = C
∗ − a.
∗(a) (cid:13)= att. First consider
the implication “⇒”: let D be an arbitrary coloring in Γ . By condition (ii) of Deﬁnition 19, there exists an X>t -restricted
admissible set E for F (cid:2)t with E (cid:2) S and E ∈ et(D). By Lemma 4, E is also X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) = F (cid:2)t . Hence,
∗ − a
by condition (iii) of Deﬁnition 19, there exists D
), one
shown above (i.e., constructing D
can now prove that D = D

∗, Γ ∗) for t
(cid:7)
. Recall from the proof of Lemma 5 the construction of C
∗, Γ ∗) and, therefore, in particular, S ∈ et(cid:7) (C

∗ − a, Γ ∗ − a) is an ID-vpair for t with C = C
∗ − a for some D
with D

It remains to show that Γ = Γ ∗ − a holds, i.e., D ∈ Γ ⇔ D = D

from D as in the proof of Lemma 5 and applying Lemma 2 to conclude D

(cid:7)
with S ∈ eID
from C , s.t. S ∈ et(cid:7) (C

∗). Analogously to the equalities C = C

(cid:7)(a) (cid:13)= att and by Deﬁnition 20, (C

(cid:7) − a = C
∗
(cid:7) = D

∗), we have C

with E ∈ et(cid:7) (D

∗ − a holds.

∗(a) = C

∗ ∈ Γ ∗

∗ ∈ Γ ∗

t(cid:7) (C

(cid:7)

Now consider the implication “⇐”: let D

∗ ∈ Γ ∗

with D

restricted admissible set E for F (cid:2)t(cid:7) with E (cid:2) S and E ∈ et(cid:7) (D
E ∈ et(D). Hence, by condition (iii) of Deﬁnition 19 and Lemma 2, we have D ∈ Γ .

∗(a) (cid:13)= att. By condition (ii) of Deﬁnition 19, there exists an X>t(cid:7) -
∗ − a is deﬁned and

∗(a) (cid:13)= att, the coloring D = D

∗). By D

It remains to show that every ID-vpair for t is an ID-pair for t. Therefore consider an ID-vpair (C, Γ ) for t. By deﬁnition
(cid:7) − a, Γ (cid:7) − a). By assumption, (C
(cid:7), Γ (cid:7)) is also
t (C, Γ ) holds. As in the proof of Lemma 5,

(cid:7)(a) (cid:13)= att and (C, Γ ) = (C
(cid:7), Γ (cid:7)). We claim that also S ∈ eID

(cid:7), Γ (cid:7)) for node t
(cid:7)
. Hence, there exists S ∈ eID

there exists an ID-vpair (C
an ID-pair for t

with C

(cid:7)

t(cid:7) (C

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

31

Fig. 11. Computation of ID-vpairs for the example AF.

(cid:7)(a) (cid:13)= att and C = C

(cid:7) − a. It remains to show that (C, Γ ) also satisﬁes conditions (ii) and (iii) of

S ∈ et(C) holds since C
Deﬁnition 19.

(cid:7), Γ (cid:7)), there exists E ∈ et(cid:7) (D

To show condition (ii), consider D ∈ Γ , i.e., D is of the form D = D

(cid:7)(a) (cid:13)= att. Since S ∈
(cid:7) ∈ Γ (cid:7)
(cid:7) − a). To show condition (iii),
(cid:7)) with E (cid:2) S. As in the proof of Lemma 5, then also E ∈ et(D
eID
t(cid:7) (C
let E be an X>t -restricted admissible set for F (cid:2)t with E (cid:2) S. Then E is also X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) and,
(cid:7)(a) (cid:13)= att and, therefore,
therefore, there exists D
D

with E ∈ et(cid:7) (D
(cid:7) − a ∈ Γ = Γ (cid:7) − a. Moreover, as in the proof of Lemma 5, also E ∈ et(D

(cid:7)). Since E is X>t -restricted admissible, we have D

(cid:7) − a for some D

(cid:7) − a) holds. (cid:2)

(cid:7) ∈ Γ (cid:7)

with D

32

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

Example 26. Consider the FORGET node n12 in Fig. 11 where argument g is removed. The ID-vpairs for n12 are obtained
(cid:7)
from the ID-vpairs of n13, but (as for vcolorings) with one exception. As discussed in Section 4.1, the vcoloring C
2 of n13
(cid:7)
with C( f ) = in is not a vcoloring for n12. Thus we exclude the ID-vpair based on this vcoloring and further exclude C
2 from
all certiﬁcate sets.

Next we consider INSERT nodes:

Lemma 21. For any INSERT node t in a tree decomposition of an AF, the ID-vpairs and ID-pairs coincide, if they coincide in the child
node t

of t.

(cid:7)

Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t an INSERT node in T , and t
the child node of t. Then there exists
an argument a ∈ A such that Xt = Xt(cid:7) ∪ {a}. First we show that every ID-pair for t is also an ID-vpair for t. Thus consider
an ID-pair (C, Γ ) for t. Then there exists an X>t -restricted admissible set S for F (cid:2)t such that S ∈ eID
t (C, Γ ). Moreover also
(cid:7), Γ (cid:7)) for t
the set S
with
(cid:7) ∈ eID
t(cid:7) (C
S
Then (C

(cid:7) = S \ {a} is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) . Thus, by Lemma 17, there exists an ID-pair (C
(cid:7), Γ (cid:7)) and by assumption, (C

(cid:7)] ∪ a is
(cid:7) ˙+ a} is an ID-vpair for t. This
(cid:7) ˙+ a, Γ2) with Γ2 = (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ {C ∈ Ct | [C] (cid:2) C
conﬂict-free in Ft then also (C
follows by the same arguments based on properties of a tree decomposition as we have used earlier, e.g. in the proof of
Lemma 15. We claim that either (C

(cid:7) + a, Γ1) with Γ1 = (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ {C ∈ Ct | [C] (cid:2) C

(cid:7) + a} is an ID-vpair for t and further if [C

(cid:7), Γ (cid:7)) is also an ID-vpair for t

(cid:7) ˙+ a, Γ2) = (C, Γ ) holds.

(cid:7) + a, Γ1) = (C, Γ ) or (C

.

(cid:7)

(cid:7)

(cid:7)

To show that either C = C

(cid:7) + a (if a /∈ S) or C = C
∗
(cid:7)), we have that C

(cid:7) ˙+ a (if a ∈ S) holds, consider the proof of Lemma 7 where we construct
∗). As
by Lemma 2 and the claim follows. To show the equality for the certiﬁcates,

∗ ˙+ a holds. Moreover, we have S

, such that either C = C
(cid:7) = C

∗ + a or C = C

(cid:7) ∈ et(C

a coloring, which we denote here as C
(cid:7) ∈ et(C
by deﬁnition S
i.e. Γ = Γ1 or Γ = Γ2, we distinguish two cases:

∗

(1) Assume a /∈ S: To show Γ1 = Γ , we ﬁrst prove the inclusion Γ1 ⊆ Γ : For the inclusion (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ⊆ Γ , consider
for F (cid:2)t(cid:7) with

. By condition (ii) of Deﬁnition 19, there exists an X>t(cid:7) -restricted admissible set E

(cid:7)

(cid:7) ∈ Γ (cid:7)
an arbitrary D
(cid:7) ∈ et(cid:7) (D
(cid:7)
(cid:7) (cid:2) S
and E
E
As by assumption a /∈ S we have that

(cid:7)).

(i) E

(cid:7) (cid:2) S

and (ii) E = E
(cid:7)

(cid:7) ∪ {a} (cid:2) S,
is conﬂict-free in F (cid:2)t ; in the latter case, E is conﬂict-free in F (cid:2)t if [D

respectively.

(cid:7)] ∪ {a} is so.
In the ﬁrst case we have that E
Further if E is conﬂict-free in F (cid:2)t then it is also X>t -restricted admissible for F (cid:2)t (using the fact that there are no
attacks between arguments from X>t and a which holds by properties of tree decompositions). Thus, by Deﬁnition 19,
there exists a set D ∈ Γ such that E ∈ et(D). Using the construction from the proof of Lemma 7 and Lemma 2, in
(cid:7) ˙+ a. This concludes the proof that (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ⊆ Γ
case (i), we have D = D
holds.
It remains to show {C
et(C
Now consider an arbitrary vcoloring D ∈ Γ . By condition (ii) of Deﬁnition 19, there exists an X>t -restricted admissible
(cid:7) = E \ {a} one of the following
set E ∈ et(D) for F (cid:2)t such that E (cid:2) S. Using the assumption a /∈ S we conclude that for E
conditions holds:

(cid:7) + a] it follows that for each S ∈ et(C), E (cid:2) S and thus C

(cid:7) + a]} ⊆ Γ . Thus let us consider such a coloring C

(cid:7) + a and in case (ii), we have D = D

∗ ∈ Γ must hold. Hence, Γ1 ⊆ Γ .

and an arbitrary set E ∈

∗ ∈ Ct | [C

∗). As [C

∗] (cid:2) [C

∗] (cid:2) [C

∗

(i) E

(cid:7) (cid:2) S

(cid:7)

or

(ii) E

(cid:7)

but a (cid:2) S.

(cid:7) (cid:13)(cid:2) S
(cid:7)

In both cases we have that E
case (i) we can use the proof of Lemma 7 and Lemma 2 to show that either D = D
∗ ∈ Ct | [C
use that a (cid:2) S iff [D] (cid:2) [C] iff D ∈ {C

is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) and thus there exists D

(cid:7) + a]}. Hence, Γ ⊆ Γ1.

∗] (cid:2) [C

(cid:7) ∈ Γ (cid:7)
(cid:7) + a or D = D

(cid:7)). In
with E ∈ et(cid:7) (D
(cid:7) ˙+ a. In case (ii) we

(cid:7)

(cid:7)] ∪ {a} is conﬂict-free in Ft then also E = E

. By condition (ii) of Deﬁnition 19, there exists an X>t(cid:7) -restricted admissible set E

(cid:7) ∈ Γ (cid:7)
. As X>t = X>t(cid:7) we have that E

(2) Assume a ∈ S: To show Γ2 = Γ , we ﬁrst consider the inclusion Γ2 ⊆ Γ : For the inclusion (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ⊆ Γ ,
(cid:7))
(cid:7) ∈ et(cid:7) (D
is also an X>t -restricted admissible set for F (cid:2)t and further if
(cid:7) ∪ {a} is X>t -restricted admissible for F (cid:2)t . By Deﬁnition 19 there exists
(cid:7) ∈ et(D) or E ∈ et(D), respectively. By the construction in the proof of Lemma 7 and Lemma 2 we
∗] (cid:2) [C]

consider an arbitrary D
(cid:7)
(cid:7) (cid:2) S
for F (cid:2)t(cid:7) with E
[D
a D ∈ Γ such that E
(cid:7) + a or D = D
obtain that D = D
it follows that for each S ∈ et(C), E (cid:2) S and thus C
Now let D ∈ Γ . By condition (ii) of Deﬁnition 19, there exists an X>t -restricted admissible set E ∈ et(D) for F (cid:2)t
with E (cid:2) S. By assumption a ∈ S and thus we have that E
is X>t(cid:7) -restricted
(cid:7) (cid:2) a. In the
(cid:7) (cid:2) S
with E
admissible for F (cid:2)t(cid:7) and thus there exists D
(cid:7) ˙+ a holds (again by the proof of Lemma 7 and Lemma 2). Thus
ﬁrst case we have that either D = D
D ∈ (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) holds. In the latter case it holds that [D] (cid:2) [C] (as a ∈ [C]) and D ∈ Ct (as D ∈ Γ ). Thus
D ∈ {C

(cid:7) = E \ {a} (cid:2) S. Further we have that E
(cid:7) ∈ et(cid:7) (D

∗ ∈ Ct | [C
∗ ∈ Γ must hold. Hence, Γ2 ⊆ Γ .

(cid:7) ˙+ a, respectively. It remains to show that {C

(cid:7) ˙+ a]} holds. Hence, Γ ⊆ Γ2.

(cid:7) ˙+ a]} ⊆ Γ . As [C

(cid:7)). Now either E

(cid:7) = S \ {a} or E

(cid:7) + a or D = D

∗ ∈ Ct | [C

∗] (cid:2) [C

∗] (cid:2) [C

(cid:7) ∈ Γ (cid:7)

(cid:7)

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

33

It remains to show that every ID-vpair for t is also an ID-pair for t. Thus let (C, Γ ) be an ID-vpair for t. By deﬁnition
(cid:7)] ∪ {a} is conﬂict-free in Ft ,

such that either (C, Γ ) = (C

(cid:7) + a, Γ1) or, in case [C

(cid:7), Γ (cid:7)) for node t

(cid:7)

there exists an ID-vpair (C
(C, Γ ) = (C

By assumption, (C

(cid:7) ˙+ a, Γ2) (Γ1, Γ2 deﬁned as above).
(cid:7)
(cid:7), Γ (cid:7)) is an ID-pair for t
if C = C

(cid:7)

where S is deﬁned as follows: S = S
holds in both cases. It remains to show that also conditions (ii) and (iii) of Deﬁnition 19 are fulﬁlled.

. Hence, there exists S
(cid:7) + a and S = S

(cid:7) ∈ eID
t(cid:7) (C
(cid:7) ∪ {a} if C = C

(cid:7), Γ (cid:7)). We claim that also S ∈ eID
t (C, Γ ) holds,
(cid:7) ˙+ a. As in the proof of Lemma 7, S ∈ et(C)

To show condition (ii), let D ∈ Γ , i.e., D is either of the form

(a) D = D
(cid:7) ∈ Γ (cid:7)

(b) D = D

(cid:7) + a,
. We prove for each of these cases that condition (ii) holds, i.e., there exists a set E ∈ et(D), such that

(c) [D] (cid:2) [C]

(cid:7) ˙+ a or

for some D
E (cid:2) S:

(cid:7)) with E

(cid:7) (cid:2) S

(cid:7)

. Thus, by S

(cid:7) ⊆ S, also E

(cid:7) (cid:2) S holds. Moreover, as in the proof

(a) By S

(cid:7) ∈ eID

t(cid:7) (C

(cid:7), Γ (cid:7)), there exists E

of Lemma 7, we also have E
(cid:7) ∈ eID

(cid:7) ∈ et(D
(cid:7), Γ (cid:7)), there exists an E

(cid:7) ∈ et(cid:7) (D
(cid:7) + a).

t(cid:7) (C

(cid:7) (cid:2) S. By the construction of
(b) Again, by S
(cid:7) ∪ {a} is conﬂict-free in F (cid:2)t . By the usual arguments exploiting the deﬁnition of tree
D = D
decompositions, we obtain that E is an X>t -restricted admissible set for F (cid:2)t . Following the proof of Lemma 7, we get
E ∈ et(D

(cid:7) ˙+ a). Moreover, E (cid:2) S follows from E

(cid:7) ˙+ a we know that E = E

and, therefore, also E

(cid:7) (cid:2) S and E

(c) As D is a valid coloring there exists an X>t -restricted admissible set E ∈ et(D). From [D] (cid:2) [C] and S ∈ et(C) it follows

(cid:7)) with E

(cid:7) ∈ et(cid:7) (D

(cid:7) (cid:2) S

(cid:7) ⊆ E.

(cid:7)

that E (cid:2) S.

To show condition (iii), let E be X>t -restricted admissible for F (cid:2)t such that E (cid:2) S. Further let D be the unique coloring
(cid:7) (cid:2) S \ {a} then
(cid:7) + a or
(cid:7) (cid:13)(cid:2) S it must hold that either (i) a ∈ E and a (cid:2) S or (ii) a ∈ S and

such that E ∈ et(D). We claim that D ∈ Γ . Clearly, E
(cid:7) ∈ et(cid:7) (D
(cid:7)
D
D = D
E (cid:2) a. But both (i) and (ii) imply that [D] (cid:2) [C] and hence D ∈ Γ . (cid:2)

(cid:7) = E \ {a} is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) . If E
(cid:7)) and D

(cid:7) ˙+ a holds and therefore D ∈ Γ . Otherwise if E

. Then, as in the proof of Lemma 7, either D = D

denotes the unique vcoloring such that E

(cid:7) ∈ Γ (cid:7)

Example 27. One example for an INSERT node is the node n11 in Fig. 11, where the argument d is added. The ID-vpairs
+ d,
of n11 are obtained from the ID-vpairs of n12. For instance consider the ID-vpair (C
observe that [C2] (cid:2) [C1] and [C4] (cid:2) [C1]; hence we derive the ID-vpair (C1, {C2, C4}) for n11.

(cid:7)
1, ∅) of n12. For the vcoloring C1 = C

(cid:7)
1

Now consider the ID-vpair (C

(cid:7)
2, {C

(cid:7)
1

}) of n12. We get the vcoloring C2 = C

(cid:7)
2

˙+ d and the certiﬁcate C1 = C

(cid:7)
1

+ d. C

˙+ d is

(cid:7)
1

not a vcoloring and C1 is the only vcoloring with [C1] (cid:2) [C2]. Thus we obtain the ID-vpair (C2, {C1}).

Finally we discuss JOIN nodes.

Lemma 22. For a JOIN node t in a tree decomposition of an AF with successors t
if they coincide for t

as well as for t

(cid:7)(cid:7)

.

(cid:7)

(cid:7)(cid:7)

(cid:7)

, t

, the ID-vpairs of t coincide with the ID-pairs of t

(cid:7)), S2 ∈ et(cid:7)(cid:7) (C

Proof. Let (T , X ) be a tree decomposition of F = ( A, R) and t a JOIN node in T with successors t
. Recall that we
have Xt = Xt(cid:7) = Xt(cid:7)(cid:7) . To show that every ID-pair for t is also an ID-vpair for t, consider an arbitrary ID-pair (C, Γ ) for t.
Then, there exists an X>t -restricted admissible set S ∈ eID
t (C, Γ ) for F (cid:2)t . As in the proof of Lemma 8 we have that there
(cid:7)
exist unique sets S1 ⊆ X(cid:2)t(cid:7) and S2 ⊆ X(cid:2)t(cid:7)(cid:7) such that S1 ∩ Xt = S2 ∩ Xt and S = S1 ∪ S2. Moreover there exist vcolorings C
,
(cid:7), Γ (cid:7))
(cid:7)(cid:7)) and C = C1 (cid:3) C2. Hence there exist ID-pairs (C
(cid:7)(cid:7)
C
∗, Γ ∗)
and S2 ∈ eID
with S1 ∈ eID

(cid:7)(cid:7), Γ (cid:7)(cid:7)) with S1 ∈ eID
t(cid:7) (C
(cid:7)(cid:7), Γ (cid:7)(cid:7)), which, by assumption are also ID-vpairs. (Notice that by Lemma 2 there cannot be a pair (C
∗, Γ ∗) and C

such that S1 ∈ et(cid:7) (C
t(cid:7)(cid:7) (C
t(cid:7) (C

Now we turn our attention to the certiﬁcates. We have to show Γ = (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)). We ﬁrst prove the inclusion
Γ ⊆ (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)). So, let D ∈ Γ . By Deﬁnition 19 there exists an X>t -restricted admissible set E for F (cid:2)t such
that E (cid:2) D. We deﬁne E = E1 ∪ E2 analogously to S1, S2. As we mentioned in the proof of Lemma 8, there are no attacks
between the argument sets X>t(cid:7) and X>t(cid:7)(cid:7) , because of the properties 2 and 3 of tree decompositions. Thus we have that
E (cid:2) S holds iff either

with the above properties is unique.)

. Analogously, C

(cid:7), Γ (cid:7)), (C

(cid:7) (cid:13)= C

and t

(cid:7)(cid:7)

∗

(cid:7)

(cid:7)(cid:7)

(i) E1 (cid:2) S1 or

(ii) E2 (cid:2) S2

holds. As both cases are symmetric it suﬃces to consider case (i). As E is X>t -restricted admissible for F (cid:2)t , we have that
(cid:7)(cid:7) ∈
also E1 is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) , and likewise, E2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) . Thus there exists D
(cid:7)). By the proof of Lemma 8 and
Ct(cid:7)(cid:7) such that E2 ∈ et(cid:7)(cid:7) (D
and thus D ∈ Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) . Hence Γ ⊆ (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)).
the uniqueness property of Lemma 2 we have that D = D

(cid:7)(cid:7)). Moreover by (i) we have that there exists D

with E1 ∈ et(cid:7) (D

(cid:7) ∈ Γ (cid:7)

(cid:7) (cid:3) D

(cid:7)(cid:7)

It remains to show that (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)) ⊆ Γ which is equivalent to

(i) Γ

(cid:7) (cid:3) Ct(cid:7)(cid:7) ⊆ Γ and (ii) Ct(cid:7) (cid:3) Γ

(cid:7)(cid:7) ⊆ Γ.

34

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

(cid:7))
(cid:7)(cid:7)], E1 ∈ et(cid:7) (D
(cid:7)(cid:7)). By Deﬁnition 19 we have that E1 (cid:2) S1 and therefore that E = E1 ∪ E2 (cid:2) S. Further by the proof of
(cid:7) (cid:3)
(cid:7)(cid:7) ∈ Γ . Hence (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)) ⊆ Γ . In summary, we have proved Γ = (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)) and thus every ID-pair

As before, by symmetry, we may restrict ourselves to case (i). Thus let D
and E2 ∈ et(cid:7)(cid:7) (D
Lemma 8 and Lemma 2, D = D
D
(C, Γ ) is also an ID-vpair.

is the unique coloring such that E ∈ et(D). We thus obtain the desired result D

(cid:7)(cid:7) ∈ Ct(cid:7)(cid:7) with [D

(cid:7)] = [D

(cid:7) ∈ Γ (cid:7)

(cid:7) (cid:3) D

and D

(cid:7)(cid:7)

In the second part of the proof we show that every ID-vpair for t is an ID-pair for t. Thus let (C, Γ ) be an ID-vpair for t.
(cid:7)(cid:7), (Γ (cid:7) (cid:3)
(cid:7), Γ (cid:7)) are also ID-pairs and thus there are sets S1, S2 such

and an ID-vpair (C
(cid:7), Γ (cid:7)) and (C

such that (C, Γ ) = (C

(cid:7)(cid:7), Γ (cid:7)(cid:7)) for node t

(cid:7) (cid:3) C

By deﬁnition there is an ID-vpair (C
Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7))) and [C
that S1 ∈ eID
t(cid:7) (C

(cid:7), Γ (cid:7)) and S2 ∈ eID

(cid:7)] = [C

(cid:7), Γ (cid:7)) for node t
(cid:7)
(cid:7)(cid:7)]. By assumption, (C
t(cid:7)(cid:7) (C

(cid:7)(cid:7), Γ (cid:7)). As in the proof of Lemma 8, S = S1 ∪ S2 ∈ et(C) holds since [C

(cid:7)(cid:7)] = [C

(cid:7)].

(cid:7)(cid:7)

It remains to show that also conditions (ii) and (iii) of Deﬁnition 19 are fulﬁlled:

(cid:7)(cid:7)

(cid:7) (cid:3) D
(cid:7) (cid:3) D

(ii) To show condition (ii), consider D ∈ Γ . Then D is either of the form
(cid:7) ∈ Γ (cid:7)
, D
(cid:7) ∈ Ct(cid:7) , D

(a) D = D
(b) D = D
By symmetry, it suﬃces to consider case (a). As S1 ∈ eID
D
holds that E = E1 ∪ E2 ∈ et(D

(cid:7)(cid:7)], there exists E2 ∈ et(cid:7)(cid:7) (D
(cid:7)(cid:7)) and E (cid:2) S.

(cid:7)(cid:7) ∈ Ct(cid:7)(cid:7) with [D
(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)
with [D

(cid:7)] = [D
(cid:7)] = [D
t(cid:7) (C

for some D
for some D

(cid:7)(cid:7) ∈ Ct(cid:7)(cid:7) and [D

(cid:7)] = [D

(cid:7) (cid:3) D

(cid:7)(cid:7)

(cid:7)(cid:7)], or
(cid:7)(cid:7)].
(cid:7), Γ (cid:7)) there exists E1 ∈ et(cid:7) (D

(cid:7)) such that E1 (cid:2) S1. Further by
(cid:7)(cid:7)) such that E1 ∩ Xt = E2 ∩ Xt . Now, using the proof of Lemma 8, it

(iii) To show condition (iii), let E be X>t -restricted admissible for F (cid:2)t with E (cid:2) S. Then E1 is X>t(cid:7) -restricted admissible
for F (cid:2)t(cid:7) and E2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) . Moreover as E (cid:2) S either E1 (cid:2) S1 or E2 (cid:2) S2 holds. Thus
there exist D

(cid:7)(cid:7)), E1 ∩ Xt = E2 ∩ Xt , and either

(cid:7)), E2 ∈ et(cid:7)(cid:7) (D

, D

(cid:7)(cid:7)

(cid:7)

with E1 ∈ et(cid:7) (D
(cid:7)(cid:7) ∈ Ct(cid:7)(cid:7) or

, D

(a) D

(cid:7) ∈ Γ

(cid:7)

(b) D

(cid:7) ∈ Ct(cid:7) , D

(cid:7)(cid:7) ∈ Γ

(cid:7)(cid:7)

holds. But then, as in the proof of Lemma 8, also E = E 1 ∪ E2 ∈ et(D

(cid:7) (cid:3) D

(cid:7)(cid:7)). (cid:2)

Example 28. The only JOIN node in our example is n2 in Fig. 11. For instance consider joining the ID-vpair (C
(cid:7)
}) of n8. As [C
with the ID-vpair (C
1
(cid:7)(cid:7)
2 and vice versa we only get one certiﬁcate C2 = C
only appropriate join partner in n8 is C
(C1, {C2}).

] these two pairs can be combined to a pair (C1, Γ ). Further as for C

}) of n3
(cid:7)
2 the
(cid:7)(cid:7)
2 . This leads to the ID-vpair

(cid:7)(cid:7)
1 , {C

] = [C

(cid:3) C

(cid:7)(cid:7)
1

(cid:7)(cid:7)
2

(cid:7)
2

(cid:7)
1, {C

(cid:7)
2

Theorem 9. Let (T , X ) be a nice tree decomposition of an AF F = ( A, R). Then, for each pair (C, Γ ), it holds that (C, Γ ) is an ID-pair
for t iff (C, Γ ) is an ID-vpair for t.

Proof. The proof makes use of the above lemmas and is the same as for the corresponding theorems in the previous
sections. (cid:2)

To decide whether an argument a is ideally accepted we now can proceed as for credulous acceptance: We have to mark
ID-vpairs which assign the value in to the argument a and pass this mark up to the root. If the ID-vpair ((cid:7), ∅) at the root
has the mark, then we can conclude that the argument a is ideally accepted. Otherwise if ((cid:7), ∅) is not marked then the
argument a is not ideally accepted.

Example 29. Recall the computation in Fig. 11. Now we consider the problem of deciding whether the argument a is ideally
accepted. The argument a ﬁrst appears in the node n7 and thus we mark the ID-vpair with C1(a) = in and as before we
illustrate this with a (cid:5) in the corresponding row of the table. Now consider node n5; here we have that the ID-vpairs
(cid:7)
(C1, ∅) and (C2, ∅) are constructed from the marked ID-vpair (C
1, ∅) of n6 and thus they are marked. We mention that
(cid:7)
2, ∅), but this does not affect the mark. On the other hand, the only way to
the ID-vpair (C1, ∅) can also be built from (C
(cid:7)
build the ID-vpair (C3, ∅) is via the ID-vpair (C
2, ∅) and thus it is not marked. Inspecting the root shows that a is ideally
accepted, which indeed holds since {a} is an ideal set of our running example (see Example 2).

Theorem 10. Deciding ID for an AF F = ( A, R) of tree-width k − 1 can be done in time O (222k+1+8k · | A|).

Proof. Recall the proof of Theorem 6. We have that the number of pairs (C, Γ ) in each node is bounded by 2n with
n = 22k + 2k. Further we store these pairs in tables such that we can ﬁnd a given pair in time O (n).

We have to show that computing the ID-vpairs at each node t ∈ T is feasible in time O (222k+1+8k) in a single bottom-
up traversal of T . Since the number of nodes of T may be assumed to be bounded by O (| A|), the desired upper bound
of the theorem follows immediately. We prove the upper bound O (222k+1+8k) for the time needed at each node t ∈ T by
distinguishing the four types of nodes. As in the proof of Theorem 6, the computationally most expensive node type is the
JOIN node, which is the one we shall focus on below. The other node types are treated similarly.
and t
and all pairs (C

. To compute the table of ID-vpairs for t, we iterate in a nested loop
(cid:7), Γ (cid:7)) is

Let t be a JOIN node with successors t

and do the following: check if (C

(cid:7)(cid:7), Γ (cid:7)(cid:7)) in the table at t

(cid:7), Γ (cid:7)) in the table at t

over all pairs (C

(cid:7)(cid:7)

(cid:7)(cid:7)

(cid:7)

(cid:7)

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

35

an ID-vpair and (C
Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) {C
Theorem 8, this can be done in time O (222k+1+8k). (cid:2)

(cid:7)(cid:7), Γ (cid:7)(cid:7)) is an ID-vpair and [C

(cid:7)(cid:7), (Γ (cid:7) (cid:3)
(cid:7)(cid:7)})) and set the ID-vpair-bit in the row corresponding to (C, Γ ) in the table at node t. As in the proof of

(cid:7)(cid:7)]. If this is the case, we compute the vpair (C, Γ ) = (C

(cid:7)] = [C

(cid:7) (cid:3) C

5. Conclusion

In this paper, we have turned several theoretical tractability results for argumentation frameworks of bounded tree-
width into eﬃcient algorithms. All these algorithms are based on a dynamic programming approach which uses a single
bottom-up traversal of a tree decomposition of the given argumentation framework. For the basic algorithm, we introduced
vcolorings as the crucial data structure to be maintained along this bottom-up traversal. We proved that this data structure
allows us to succinctly represent the admissible sets and thus to eﬃciently decide credulous acceptance. For succinctly
representing the preferred extensions and thus deciding skeptical acceptance we had to extend our basic data structure to
vpairs – consisting of a vcoloring plus a set of certiﬁcates, which are themselves vcolorings. Finally, we modiﬁed these vpairs
to so-called ID-pairs, which allowed us to design an eﬃcient algorithm for ideal acceptance in argumentation frameworks
of bounded tree-width. Moreover, we have shown that some further graph parameters (which, in contrast to tree-width,
apply to directed graphs), do not lead to similar tractability results. The key to this collection of intractability results was
the intractability for argumentation frameworks of bounded cycle-rank.

Crucial for our dynamic programming algorithms is the eﬃcient computation of a tree decomposition (T , X ) of mini-
mum width (i.e., the tree-width) or at least a good approximation thereof. We have already mentioned in Section 2.2 that
Bodlaender [7] provided a linear-time algorithm which, for ﬁxed w (cid:3) 1, computes a tree decomposition of width at most
w provided that it exists. However, this algorithm is of limited practical use due to the big multiplicative constant, which
is exponential in the width w. Bodlaender et al. have developed several powerful preprocessing methods that may con-
siderably reduce the size of a problem instance for tree-width computation [9,42]. Moreover, intensive research has been
devoted to heuristic methods for tree-width computation and to the development of eﬃcient algorithms for an approxima-
tion of the tree-width. A good survey on heuristic methods for tree-width computation is given in [8]. Further recent works
on this topic are, for instance, [32,36,39]. Various algorithms with different approximation guarantees and run-time upper
bounds are given in [1]. On the one hand, a polynomial-time algorithm is presented for a factor O (log w) approximation of
the tree-width w. On the other hand, also algorithms for constant factor approximations of the tree-width are given. The
latter algorithms work in exponential time w.r.t. the tree-wdith but are still exponentially faster than previous algorithms.
All the above works on tree-width computation deal with a tradeoff of eﬃciency and accuracy. Alternatively, there are also
approaches where there is a tradeoff between eﬃciency and generality. For instance, in [16] a subexponential algorithm
results from the restriction of graph classes via forbidden minors.

Several algorithms for the problems discussed in this paper have been presented in the literature. We mention the work
by Doutre and Mengin [19] here which relies on set-enumeration techniques exploring a binary tree. Although this tree
is conceptually different from the tree decompositions we use, a number of short-cuts for accelerating the enumeration is
provided, which could be applied to our algorithms as well.

A similar, yet differently motivated account to characterize argumentation semantics via a decomposition (into a cer-
tain form of strongly connected components) is due to Baroni et al. [5]. Similar as in tree decompositions, their approach
allows to “locally” compute smaller parts of the extensions independently by propagating certain information during the
computation. However, their concept is not directly amenable to ﬁxed-parameter tractability since even in case the number
of arguments in the single components is bound, standard NP/coNP-hardness reductions apply. In fact, parameterizing the
size of the SCCs is related to the parameter cycle-rank as follows. If the size is of the largest SCC of an AF is bounded by k
then clearly the cycle-rank of the AF is (cid:4) k (as one can simple delete all arguments of an SCC to make it acyclic). But there
exist AFs with bounded cycle-rank and arbitrary large SCCs, e.g. directed cycles which have cycle-rank 1 but are of arbitrary
size. However, Π P
2 -hardness proofs of skeptical acceptance under preferred semantics fail for AFs with bounded SCC-size.
We anticipate that the coNP algorithm we presented for AFs of cycle-rank 1 can be extended to AFs such that for ﬁxed
SCC-size the algorithm runs in coNP but its run-time heavily increases with the maximal SCC-size yielding a para-coNP
algorithm [30].

Recall that our algorithms rely on the concept of colorings. They look similar to labelings (see [11,38]). However, labelings
are deﬁned for complete frameworks, while we require here a concept which also applies to subframeworks (recall that
for our complexity results in Theorems 6, 8 and 10, it was essential that colorings are deﬁned over a small number of
arguments); in other words, we do not know in advance, whether an argument will eventually be defended; this also
explains why we need four colors, whereas the number of labels is usually three. Nonetheless, known results about relations
between labelings for different semantics might help us in extending our algorithms to other semantics, which is indeed a
major topic for future work.

Further ongoing and future work is as follows:

• We plan to adapt our algorithms to other semantics, such as complete, stable, stage, and semi-stable. As we have already

mentioned, we expect no major obstacles in extending the methods developed here to such other semantics.

36

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

• Another important aspect of future work is to analyze if typical argumentation scenarios naturally lead to AFs of low
tree-width. Note that graphs containing big cliques have high tree-width. However, for argumentation scenarios we
would rather expect graphs with small cliques or cycles, which are harmless as far as the tree-width is concerned.

• A ﬁrst prototype system which implements the algorithms from this paper is available under

www.dbai.tuwien.ac.at/research/project/argumentation/dynpartix.

In recent work [25], we compared this implementation with existing systems, for instance, the ASPARTIX system [29]
which relies on reduction to logic programs. The experiments show that the new dynpartix system performs well for
instances of low tree-width. Moreover, compared to the ASPARTIX the size of the instance is not of high inﬂuence thus
reﬂecting the theoretical run-time analysis given in this paper. Further advances in the dynpartix system have to be
made in order to be competitive on arbitrary instances where we cannot expect low tree-width.

Acknowledgements

We thank the anonymous referees of the preceding KR 2010 paper and of the current paper for their detailed reviews

and many helpful comments.

References

[1] E. Amir, Approximation algorithms for treewidth, Algorithmica 56 (4) (2010) 448–479.
[2] J. Barát, Directed path-width and monotonicity in digraph searching, Graphs Combin. 22 (2) (2006) 161–172.
[3] P. Baroni, P.E. Dunne, M. Giacomin, On extension counting problems in argumentation frameworks, in: P. Baroni, F. Cerutti, M. Giacomin, G.R. Simari
(Eds.), Proceedings of the 3rd Conference on Computational Models of Argument (COMMA’10), in: Frontiers in Artiﬁcial Intelligence and Applications,
vol. 216, IOS Press, 2010, pp. 63–74.

[4] P. Baroni, M. Giacomin, Semantics of abstract argument systems, in: I. Rahwan, G. Simari (Eds.), Argumentation in Artiﬁcial Intelligence, Springer, 2009,

pp. 25–44.

[5] P. Baroni, M. Giacomin, G. Guida, SCC-recursiveness: A general schema for argumentation semantics, Artiﬁcial Intelligence 168 (1–2) (2005) 162–210.
[6] D. Berwanger, A. Dawar, P. Hunter, S. Kreutzer, DAG-width and parity games, in: Proceedings of the 23rd Annual Symposium on Theoretical Aspects of

Computer Science (STACS 2006), 2006, pp. 524–536.

[7] H.L. Bodlaender, A linear-time algorithm for ﬁnding tree-decompositions of small treewidth, SIAM J. Comput. 25 (6) (1996) 1305–1317.
[8] H.L. Bodlaender, A.M.C.A. Koster, Treewidth computations. I: Upper bounds, Inform. and Comput. 208 (2010) 259–275.
[9] H.L. Bodlaender, A.M.C.A. Koster, Safe separators for treewidth, Discrete Math. 306 (3) (2006) 337–350.

[10] M. Caminada, Semi-stable semantics, in: P.E. Dunne, T.J.M. Bench-Capon (Eds.), Proceedings of the 1st Conference on Computational Models of Argu-

ment (COMMA’06), in: Frontiers in Artiﬁcial Intelligence and Applications, vol. 144, IOS Press, 2006, pp. 121–130.

[11] M. Caminada, D.M. Gabbay, A logical account of formal argumentation, Studia Logica 93 (2–3) (2009) 109–145.
[12] S. Coste-Marquis, C. Devred, P. Marquis, Symmetric argumentation frameworks, in: L. Godo (Ed.), Proceedings of the 8th European Conference on

Symbolic and Quantitative Approaches to Reasoning with Uncertainty (ECSQARU 2005), in: LNCS, vol. 3571, Springer, 2005, pp. 317–328.

[13] B. Courcelle, The monadic second-order logic of graphs. I. Recognizable sets of ﬁnite graphs, Inform. and Comput. 85 (1) (1990) 12–75.
[14] B. Courcelle, J. Engelfriet, G. Rozenberg, Handle-rewriting hypergraph grammars, J. Comput. System Sci. 46 (2) (1993) 218–270.
[15] B. Courcelle, J.A. Makowsky, U. Rotics, Linear time solvable optimization problems on graphs of bounded clique-width, Theory Comput. Syst. 33 (2)

(2000) 125–150.

[16] E.D. Demaine, F.V. Fomin, M.T. Hajiaghayi, D.M. Thilikos, Subexponential parameterized algorithms on bounded-genus graphs and h-minor-free graphs,

J. ACM 52 (6) (2005) 866–893.

[17] Y. Dimopoulos, A. Torres, Graph theoretical structures in logic programs and default theories, Theoret. Comput. Sci. 170 (1–2) (1996) 209–244.
[18] J. Dix, S. Parsons, H. Prakken, G.R. Simari, Research challenges for argumentation, Comput. Sci. Res. Develop. 23 (1) (2009) 27–34.
[19] S. Doutre, J. Mengin, Preferred extensions of argumentation frameworks: Query answering and computation, in: R. Goré, A. Leitsch, T. Nipkow (Eds.),

Proceedings of the 1st International Joint Conference on Automated Reasoning (IJCAR 2001), in: LNCS, vol. 2083, Springer, 2001, pp. 272–288.

[20] P.M. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games, Artiﬁcial

Intelligence 77 (2) (1995) 321–358.

[21] P.M. Dung, P. Mancarella, F. Toni, Computing ideal sceptical argumentation, Artiﬁcial Intelligence 171 (10–15) (2007) 642–674.
[22] P.E. Dunne, Computational properties of argument systems satisfying graph-theoretic constraints, Artiﬁcial Intelligence 171 (10–15) (2007) 701–729.
[23] P.E. Dunne, The computational complexity of ideal semantics, Artiﬁcial Intelligence 173 (18) (2009) 1559–1591.
[24] P.E. Dunne, T.J.M. Bench-Capon, Coherence in ﬁnite argument systems, Artiﬁcial Intelligence 141 (1–2) (2002) 187–203.
[25] W. Dvorák, M. Morak, C. Nopp, S. Woltran, dynPARTIX – A dynamic programming reasoner for abstract argumentation, CoRR (2011), arXiv:1108.4804

[cs.AI].

[26] W. Dvoˇrák, S. Woltran, Complexity of semi-stable and stage semantics in argumentation frameworks, Inform. Process. Lett. 110 (11) (2010) 425–430.
[27] W. Dvoˇrák, S. Szeider, S. Woltran, Reasoning in argumentation frameworks of bounded clique-width, in: P. Baroni, F. Cerutti, M. Giacomin, G.R. Simari
(Eds.), Proceedings of the 3rd Conference on Computational Models of Argument (COMMA’10), in: Frontiers in Artiﬁcial Intelligence and Applications,
vol. 216, IOS Press, 2010, pp. 219–230.

[28] L.C. Eggan, Transition graphs and the star height of regular events, Michigan Math. J. 10 (1963) 385–397.
[29] U. Egly, S.A. Gaggl, S. Woltran, Answer-set programming encodings for argumentation frameworks, Argum. Comput. 1 (2) (2010) 147–177.
[30] J. Flum, M. Grohe, Parameterized Complexity Theory, Texts in Theoretical Computer Science, Springer, 2006.
[31] H. Gruber, Digraph complexity measures and applications in formal language theory, in: Proceedings of the 4th Workshop on Mathematical and

Engineering Methods in Computer Science (MEMICS 2008), 2008, pp. 60–67.

[32] T. Hammerl, N. Musliu, Ant colony optimization for tree decompositions, in: EvoCOP, 2010, pp. 95–106.
[33] P. Hunter, S. Kreutzer, Digraph measures: Kelly decompositions, games, and orderings, Theoret. Comput. Sci. 399 (3) (2008) 206–219.
[34] M. Jakl, R. Pichler, S. Woltran, Answer-set programming with bounded treewidth, in: Proceedings of the 21st International Joint Conference on Artiﬁcial

Intelligence (IJCAI 2009), 2009, pp. 816–822.

[35] T. Johnson, N. Robertson, P.D. Seymour, R. Thomas, Directed tree-width, J. Combin. Theory Ser. B 82 (1) (2001) 138–154.

W. Dvoˇrák et al. / Artiﬁcial Intelligence 186 (2012) 1–37

37

[36] K. Kask, A. Gelfand, L. Otten, R. Dechter, Pushing the power of stochastic greedy ordering schemes for inference in graphical models, in: Proceedings

of the Twenty-Fifth Conference on Artiﬁcial Intelligence (AAAI-11), 2011.

[37] T. Kloks, Treewidth, Computations and Approximations, Lecture Notes in Computer Science, vol. 842, Springer, 1994.
[38] S. Modgil, M. Caminada, Proof theories and algorithms for abstract argumentation frameworks, in: I. Rahwan, G. Simari (Eds.), Argumentation in

Artiﬁcial Intelligence, Springer, 2009, pp. 105–129.

[39] N. Musliu, An iterative heuristic algorithm for tree decomposition, in: Recent Advances in Evolutionary Computation for Combinatorial Optimization,

in: Studies in Computational Intelligence, vol. 153, Springer, 2008, pp. 133–150.

[40] N. Robertson, P.D. Seymour, Graph minors. II. Algorithmic aspects of tree-width, J. Algorithms 7 (3) (1986) 309–322.
[41] L.G. Valiant, The complexity of enumeration and reliability problems, SIAM J. Comput. 8 (3) (1979) 410–421.
[42] F. van den Eijkhof, H.L. Bodlaender, A.M.C.A. Koster, Safe reduction rules for weighted treewidth, Algorithmica 47 (2) (2007) 139–158.
[43] B. Verheij, Two approaches to dialectical argumentation: Admissible sets and argumentation stages, in: J. Meyer, L. van der Gaag (Eds.), Proceedings of

the 8th Dutch Conference on Artiﬁcial Intelligence (NAIC’96), 1996, pp. 357–368.

