Artiﬁcial Intelligence 255 (2018) 43–70

Contents lists available at ScienceDirect

Artiﬁcial  Intelligence

www.elsevier.com/locate/artint

Fixpoint  semantics  for  active  integrity  constraints
Bart Bogaerts a,∗
,  Luís Cruz-Filipe b
a KU Leuven, Department of Computer Science, Celestijnenlaan 200A, Leuven, Belgium
b University of Southern Denmark, Department of Mathematics and Computer Science, Campusvej 55, Odense, Denmark

a  r  t  i  c  l  e 

i  n  f  o

a  b  s  t  r  a  c  t

Article history:
Received 4 July 2017
Received in revised form 2 October 2017
Accepted 18 November 2017
Available online 23 November 2017

Keywords:
Active integrity constraints
Approximation ﬁxpoint theory

Active integrity constraints (AICs) constitute a formalism to associate with a database not 
just the constraints it should adhere to, but also how to ﬁx the database in case one or 
more of these constraints are violated. The intuitions regarding which repairs are “good” 
given such a description are closely related to intuitions that live in various areas of non-
monotonic reasoning, such as logic programming and autoepistemic logic.
In  this  paper,  we  apply  approximation ﬁxpoint theory,  an  abstract,  algebraic  framework 
designed  to  unify  semantics  of  non-monotonic  logics,  to  the  ﬁeld  of  AICs.  This  results 
in  a  new  family  of  semantics  for  AICs.  We  study  properties  of  our  new  semantics  and 
relationships to existing semantics. In particular, we argue that two of the newly deﬁned 
semantics  stand  out.  Grounded repairs have  a  simple  deﬁnition  that  is  purely  based  on 
semantic  principles  that  semantics  for  AICs  should  adhere  to.  And,  as  we  show,  they 
coincide with the intended interpretation of AICs on many examples. The second semantics 
of interest is the AFT-well-founded semantics: it is a computationally cheap semantics that 
provides upper and lower bounds for many other classes of repairs.

© 2017 Elsevier B.V. All rights reserved.

1.  Introduction

One  of  the  key  components  of  modern-day  databases  are  integrity  constraints:  logical  formulas  that  specify  semantic 
relationships between the data being modeled that have to be satisﬁed at all times. When the database is changed (typically 
due to updating), it is necessary to check if its integrity constraints still hold; in the negative case, the database must be 
repaired.

The problem of database repair has been an important topic of research for more than thirty years [1]. There are two 
major problems when deciding how to repair an inconsistent database: ﬁnding possible repairs and choosing which one to 
apply. Indeed, there are typically several ways to ﬁx an inconsistent database, and several criteria to choose the “best” one 
have been proposed over the years. Among the most widely accepted criteria are minimality of change [45,25] – change as 
little as possible – and the common-sense law of inertia (discussed in, e.g., [33]) – do not change anything unless there is a 
reason for the change.

A  typical  implementation  of  integrity  constraints  in  database  systems  is  by  means  of  event–condition–action  (ECA) 
rules [38,44],  which  specify  update  actions  to  be  performed  when  a  particular  event  (a  trigger)  occurs  and  speciﬁc  con-
ditions hold. ECA rules are widely used in practice, as they are simple to implement and their individual semantics is easy 

* Corresponding author.

E-mail addresses: bart.bogaerts@cs.kuleuven.be (B. Bogaerts), lcﬁlipe@gmail.com (L. Cruz-Filipe).

https://doi.org/10.1016/j.artint.2017.11.003
0004-3702/© 2017 Elsevier B.V. All rights reserved.

44

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

to  understand.  However,  the  lack  of  declarative  semantics  for  ECA  rules  makes  their  interaction  complex  to  analyze  and 
their joint behavior hard to understand.

The formalism of active integrity constraints (AICs) [27] was inspired by a similar idea. AICs express database dependen-
cies through logic programming-style rules that include update actions in their heads. They come with a set of declarative 
semantics that identiﬁes several progressively more restricted classes of repairs, which can be used as criteria to select a 
preferred  repair [13].  These  repairs  can  be  computed  directly  by  means  of  tree  algorithms [17],  which  have  been  imple-
mented as a prototype [16].

Example 1.1.  We  motivate  the  use  of  AICs  in  practice  by  means  of  a  simple  example.  Consider  a  company’s  database, 
including tables employee and dept (relating employees to the department where they work). In particular, each employee 
is assigned to a unique department; if an employee is listed as working in two different departments, then the database is 
inconsistent, and this inconsistency must be ﬁxed by removing one of those entries.

We can write this requirement as the following AIC.

∀x, y, z : employee(x), dept(x, y), dept(x, z), y (cid:4)= z ⊃ −dept(x, y)

The intended meaning of this rule is: if all the literals in the lefthandside (body) of the rule are true in some state of 
the database, for particular values of x,  y and z, then the database is inconsistent, and this inconsistency can be solved by 
performing the action on the right.
Suppose that the database is

DB = {employee(john), dept(john, ﬁnance), dept(john, hr)} .

This database is inconsistent, and applying our AIC with x = john,  y = ﬁnance and z = hr gives us a possible ﬁx consisting 
of the action “remove dept(john, ﬁnance)”. Observe, however, that the instantiation x = john,  y = hr and z = ﬁnance detects 
the same inconsistency, but proposes instead the ﬁx “remove dept(john, hr)”: in general, there can be several different ways 
to repair inconsistencies.

AICs may also interact with each other. Suppose that we add the constraint

∀x, y, z : supervisor(x, y), dept(x, z), ¬dept( y, z) ⊃ +dept( y, z)

(1)

stating that employees can only supervise people from their own department, and that whenever this constraint is violated, 
the department of the supervisee needs to be updated (i.e., the supervisor table and the department of the supervisor are 
deemed correct). If the database is now

DB = {employee(john), employee(ann), dept(john, ﬁnance), dept(ann, hr), supervisor(ann, john)}

then this AIC detects an inconsistency, and suggests that it be ﬁxed by adding the entry dept(john, hr). The database is still 
inconsistent, though, since there are now two entries for John in the dept table; restoring inconsistency would also require 
removing the entry dept(john, ﬁnance).

An alternative repair of the integrity constraint that the supervisee and supervisor should belong to the same department 
would be to change the department information associated with ann. By using active integrity constraints, we discard this 
solution: rule (1) only allows to insert a new department for the supervisee. If we additionally also want to allow changing 
ann’s department, we need an extra constraint. (cid:2)

It is striking that many intuitions about what “good” repairs are, such as minimality of change, are similar to intuitions 
that surfaced in other domains of non-monotonic reasoning, such as logic programming [39] and default logic [34]. Still, it 
has been hard to ﬁnd satisfying semantics for AICs. As shown by Cruz-Filipe et al. [17], the semantics of so-called founded 
repairs [12] unexpectedly fails to respect the common-sense law of inertia, while the more restricted semantics of justiﬁed 
repairs [13] forbids natural repairs in some cases. That work proposed the operational semantics of well-founded repairs, 
which however is not modular [14] and is therefore severely restricted in its practical applicability.

In  this  work,  we  begin  by  deﬁning  a  new  semantics  for  AICs  that  avoids  these  problems:  grounded repairs.  Grounded 
repairs are natural counterparts to existing semantics in various non-monotonic reasoning domains such as logic program-
ming; we discuss how they relate to other semantics for AICs. We also argue that grounded repairs match our intuitions 
regarding AICs on a broad set of examples.

We then give a more abstract characterization of the different semantics for AICs by associating with each set of AICs η

a semantic operator Tη. This operator immediately induces several semantics:

(i) weak repairs are ﬁxpoints of Tη;
(ii) repairs are minimal ﬁxpoints of Tη;
(iii) grounded repairs are grounded ﬁxpoints [7] of Tη.

The ﬁrst two semantics are pre-existing semantics for AICs that we recover in an operator-based fashion.

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

45

Next,  we  deﬁne  a  three-valued  variant  of  Tη .  In  the  terminology  of  approximation ﬁxpoint theory (AFT) [19] our  three-
valued  operator  is  an  approximator of  the  original  semantic  operator.  Given  such  an  approximator  Tη,  AFT  induces  a  few 
more semantics:

(iv) the Kripke–Kleene repair is the Kripke–Kleene ﬁxpoint of Tη;
(v) the AFT-well-founded repair is the well-founded ﬁxpoint of Tη;
(vi) (partial) stable repairs are (partial) stable ﬁxpoints of Tη;
(vii) partial grounded repairs are partial grounded ﬁxpoints of Tη.

We  again  study  properties  of  these  new  semantics  and  study  how  they  compare  to  existing  semantics.  Furthermore,  we 
argue that, from a practical point of view, the AFT-style well-founded semantics is very valuable. Indeed, we show that the 
AFT-well-founded repair can be computed in polynomial time, and that, on a broad set of practical examples, it corresponds 
to  the  intuitions  underlying  database  repairs,  providing  natural  upper  and  lower  bounds  on  the  set  of  acceptable  repairs 
(formally: the AFT-style well-founded model approximates all justiﬁed, stable and grounded repairs).

All our semantics are deﬁned within the framework of approximation ﬁxpoint theory, a general algebraic framework for 
studying  logics  with  a  ﬁxpoint  semantics.  This  framework  was  initially  developed  by  Denecker,  Marek  and  Truszczy ´nski, 
henceforth referred to as DMT [20], after identifying analogies in the semantics of logic programming [39], autoepistemic 
logic  (AEL)  [32] and  default  logic,  hereafter  abbreviated  to  DL  [34].  The  theory  deﬁnes  different  types  of  ﬁxpoints  for 
what  are  called  approximating operators,  or  approximators.  In  the  context  of  logic  programming,  DMT [20] showed  that 
Fitting’s (three- or four-valued) immediate consequence operator is an approximator of the usual (two-valued) immediate 
consequence operator, and that the major semantics of logic programs coincide with the (equally named) different types of 
ﬁxpoints of that approximator. They then identiﬁed approximators for both default and autoepistemic logic, showing that 
AFT induces all main semantics in these ﬁelds, as well as some new ones [21], thus unifying DL and AEL in a deep sense. 
More recently, Strass [36] showed that AFT can also be used to characterize the major semantics of Dung’s argumentation 
frameworks [24] and abstract dialectical frameworks [11]. Other recent applications of AFT include: deﬁning extensions of 
logic programming [2], deﬁning new logics [10], integrating different formalisms [3], studying complexity [37], and studying 
modularity and predicate introduction in a uniform way [41–43].

As  such,  the  contribution  of  this  work  goes  beyond  the  deﬁnition  of  new  semantics  for  AICs.  By  integrating  active 
integrity  constraints  in  AFT,  we  provide  solid  foundations  for  applying  a  rich  algebraic  theory  to  AICs.  For  instance,  we 
can now directly apply existing results from AFT, such as modularity results and predicate introduction results to AICs. It 
remains to be researched how these related for instance to existing modularity results for AICs [14,15].  Furthermore,  our 
work paves the way to applying AFT to revision programming, following the results from Caroprese and Truszczy ´nski [13], 
and to AICs outside the database world, as generalized by Cruz-Filipe et al. [18].

The  rest  of  this  paper  is  structured  as  follows.  In  Section 2,  we  provide  preliminaries  related  to  active  integrity  con-
straints. In Section 3 we discuss the semantics of grounded repairs. While our deﬁnitions are motivated from approximation 
ﬁxpoint theory, their semantics can also be given without this machinery, hence we start with a direct deﬁnition. Next, in 
Section 4, we give background on approximation ﬁxpoint theory. In Section 5, we deﬁne a semantic operator for AICs and 
show that its grounded ﬁxpoints indeed correspond to grounded repairs, as deﬁned in Section 3. Next, we deﬁne an approx-
imator of our operator in Section 6 and use it to derive more AFT-style semantics for AICs; we study how these semantics 
relate to existing semantics. Afterwards, in Section 7, we discuss the relationship between our newly deﬁned semantics and 
the equally-named semantics for logic programming. In Section 8, we study complexity of various tasks related to our newly 
deﬁned semantics. We conclude in Section 9.

Publication history  The  semantic  operator  for  grounded  AICs  and  the  resulting  semantics  of  grounded  repairs  were  origi-
nally proposed by Cruz-Filipe [15]. The approximator for this operator and its properties were introduced by Bogaerts and 
Cruz-Filipe [6]. Our current work combines results from those conference papers and extends it with proofs, examples, and 
a detailed analysis of the connection between the approximation semantics for AICs and logic programming.

2.  Preliminaries: active integrity constraints

In this section we summarize previous work on active integrity constraints (AICs), including results developed by Flesca 

et al. [27], Caroprese et al. [12], Caroprese and Truszczy ´nski [13] and Cruz-Filipe et al. [17].

We assume a ﬁxed set At of atoms. An interpretation or database is a subset of At. In the current paper, following, e.g., 
Cruz-Filipe et al. [17], we assume, At to be a ﬁnite set. This restriction is not essential for deﬁning our semantics, or to any 
of  the  theorems  we  prove  about  them,  with  the  exception  of  complexity  results  and  comparison  with  existing  semantics 
(that have only been deﬁned in the ﬁnite case). A literal is an atom a or its negation ¬a. We say that ¬a is the dual literal 
of a and vice versa, and denote the dual of a literal l by lD . Propositional formulas are deﬁned as usual: atoms are formulas, 
the  negation  of  a  formula  is  a  formula,  and  the  conjunction  of  formulas  is  a  formula.  The  satisfaction  relation  between 
databases DB and formulas is deﬁned as usual:

• DB |= a if a ∈ DB,

46

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

• DB |= ¬ϕ if DB (cid:4)|= ϕ,
• DB |= ϕ ∧ ψ if DB |= ϕ and DB |= ψ

for all atoms a and all formulas ϕ and ψ .

An  update action α has  the  form  +a or  −a with  a ∈ At.  We  call  +a and  −a dual actions and  use  α D to  denote  the 
dual action of α. Intuitively, update actions represent changes to the database: +a adds a, while −a removes a. Formally, 
+a transforms DB into DB ∪ {a}, and −a transforms DB into DB \ {a}. A set of update actions U is consistent if it does not 
contain both an action and its dual. A consistent set of update actions U acts on a database DB by executing all its actions 
simultaneously; we denote the result of this operation by U (DB). If α is an update action, we simply write α(DB) for the 
result of applying α to DB, i.e., for {α}(DB).

Literals and update actions are related by mappings lit and ua, where lit(+a) = a, lit(−a) = ¬a and ua is the inverse of lit. 

These mappings naturally extend to sets of literals/actions.

Deﬁnition 2.1. An active integrity constraint (AIC) is a rule r of the form

l1 ∧ · · · ∧ ln ⊃ α1 | · · · | αk

(1)
i ) ∈ {l1, . . . , ln} for each i. We call l1 ∧ · · · ∧ ln the body of r, denoted body(r), and α1 | · · · | αk the head of r, 

such that lit(α D
denoted head(r).

The informal reading of the above rule is: “If each of the li holds in DB, then DB is inconsistent. It is allowed to repair 
this inconsistency by executing one or more of the αi .” The body of an AIC represents a constraint a database should adhere 
to and its head represents a set of atoms that are allowed to be changed in order to ﬁx the constraint, in case it is violated. 
Intuitively, atoms should only be changed if there is some rule that allows it. Furthermore, the only actions that are able to 
repair the inconsistency detected by the body of an AIC are those corresponding to the duals of its literals [12], hence we 
restrict the actions allowed in the head to these. Contrary to the seminal work on AICs [27], we only consider propositional 
AICs,  i.e.,  we  do  not  allow  ﬁrst-order  variables  (note  that  we  did  use  them  in  Example 1.1).  However,  the  restrictions  in 
that work (more precisely, range restrictedness) ensure that we can always reduce to the propositional case by means of 
grounding.

An AIC is called normal if k = 1. The normalization of an AIC of the form (1) is the set of AICs

{l1 ∧ · · · ∧ ln ⊃ αi | 1 ≤ i ≤ k}.

It  follows  from  the  informal  explanation  above  that  we  expect  normalization  to  preserve  semantics.  Indeed,  this  is  the 
case for most semantics of AICs – the notorious exception being the semantics of justiﬁed repairs [13], which also poses 
several other problems [17]. In the current paper, we assume that, unless explicitly mentioned otherwise, all AICs are normal. 
Extensions of the semantics we deﬁne for non-normal AICs can be obtained through normalization, if needed.

Deﬁnition 2.2. A set of update actions U is a weak repair for DB and a set η of AICs (shortly, for (cid:10)D B, η(cid:11)) if:

• every action in U changes DB, and
• U (DB) (cid:4)|= body(r) for each r ∈ η.

A ⊆-minimal weak repair is called a repair.

(Weak) repairs do not take the head of AICs into account, and thus allow arbitrary changes to the database.

Example 2.3. Consider the restriction that “if a and b both hold, then c and d should also hold”. In propositional logic, such 
a restriction can be expressed by the following formula:

(a ∧ b) ⇒ (c ∧ d),

or, equivalently by the two formulas

¬(a ∧ b ∧ ¬c)
¬(a ∧ b ∧ ¬d).

Now,  the  AIC  formalism  provides,  besides  the  ability  to  express  these  constraints,  also  control  over  what  should  happen 
when one of them is violated. Assuming that in such a case, we only wish to modify a or b, the corresponding AICs are:

a ∧ b ∧ ¬c ⊃ −a | −b
a ∧ b ∧ ¬d ⊃ −a | −b

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

47

where  the  ﬁrst  one  expresses  that  if  a and  b hold,  but  c does  not  (i.e.,  if  the  constraint  is  violated),  we  should  remove 
one of the two literals a and b and the second constraint is similar for d. Despite the inclusion of explicit repair actions in 
the heads of these rules, the notions of weak repair and repair do not take them into account. Suppose a given database 
is DB = {a, b}. In this case, {−a}, {−b} and {+c, +d} are repairs; furthermore, sets such as {−a, −b} or {−b, +c} are weak 
repairs: in all cases, all actions change DB, and the result always negates at least one literal in the body of each of the rules.
Sets  such  as  {−a, −c} and  {+a, +c, +d} also  solve  the  inconsistency,  but  they  include  actions  that  do  not  change  the 
database, and therefore are not considered weak repairs. Sets such as {+a, −a} are inconsistent, as it is not clear whether 
they state that the update of DB should include a or not.

Applying normalization yields the following set of AICs.

a ∧ b ∧ ¬c ⊃ −a
a ∧ b ∧ ¬d ⊃ −a
a ∧ b ∧ ¬c ⊃ −b
a ∧ b ∧ ¬d ⊃ −b

It is immediate to check that everything discussed above with respect to the original set of AICs also applies to its normal-
ized counterpart, i.e., intuitively, these constraints represent the same knowledge and the sets of repairs and weak repairs 
remain unchanged. (cid:2)

We  now  review  several  other  semantics  for  AICs  that  have  been  deﬁned  with  the  intention  to  allow  only  changes 
explicitly allowed by one of the AICs: founded (weak) repairs [12], justiﬁed (weak) repairs [13], and well-founded (weak) 
repairs [17].

Deﬁnition 2.4 ([12]). A set of update actions U is founded with respect to (cid:10)D B, η(cid:11) if, for each α ∈ U , there is a rule r ∈ η
with  α ∈ head(r) and  such  that  U (cid:14)(DB) |= body(r),  where  U (cid:14) = U \ {α}.  A  founded (weak) repair is  a  (weak)  repair  that  is 
founded.

The intuition behind this deﬁnition is that for each element in a “good” repair there should be a reason such that: if the 

element is removed, some constraint is violated and the removed element is an allowed ﬁx.

Example 2.5. Consider again the database DB = {a, b} together with the set η of normalized AICs from the previous example.

(r1)

(r2)

(r3)

a ∧ b ∧ ¬c ⊃ −a
a ∧ b ∧ ¬d ⊃ −a
a ∧ b ∧ ¬c ⊃ −b
a ∧ b ∧ ¬d ⊃ −b

(r4)
The set {−a} is founded with respect to (cid:10)D B, η(cid:11): if its only action is removed, then rule r1 is applicable, and −a occurs 

in head(r1). Likewise, the set {−b} is also a founded repair for (cid:10)D B, η(cid:11).

On  the  other  hand  U = {+c, +d} is  not  founded.  If  we  remove  e.g. +c from  U ,  obtaining  U (cid:14) = {+d},  then  U (cid:14)(DB) =

{a, b, d}, and:

• U (cid:14)(DB) |= body(r1), but +c /∈ head(r1), and likewise for r3;
• U (cid:14)(DB) (cid:4)|= body(r2) and U (cid:14)(DB) (cid:4)|= body(r4),

and thus there is no support for +c in U . In this case, there is also no support for +d.

Caroprese  and  Truszczy ´nski  [13] discovered  that  there  can  be  founded  repairs  exhibiting  circularity of support.  The  fol-

lowing example is due to Cruz-Filipe et al. [17].

Example 2.6. Consider the following set of AICs η, expressing that a and b are equivalent (and if this is not the case, then 
they should both become false) and that c should be true whenever a or b is true.

a ∧ ¬b ⊃ −a
¬a ∧ b ⊃ −b
a ∧ ¬c ⊃ +c
b ∧ ¬c ⊃ +c

(r5)

(r6)

(r7)

(r8)

48

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

Suppose that the database is DB = {a, b}. There are two repairs for (cid:10)D B, η(cid:11): U1 = {−a, −b} and U2 = {+c}. Intuitively, the 
rules  suggest  that  U2 should  be  the  preferred  repair,  since  it  includes  the  action  suggested  by  the  only  AIC  that  is  not 
satisﬁed, and indeed U2 is founded (removing its only element yields ∅, and as we observed both r7 and r8 provide support 
for +c given the state of DB).

However,  U1 is also a founded repair. If we remove  −a from  U1, we obtain  U (cid:14)

applicable and −a ∈ head(r5). Dually, if we remove −b we obtain U (cid:14)(cid:14)
−b ∈ head(r6). Thus both actions in U1 are founded, hence this is a founded repair.

= {−a}, and U (cid:14)(cid:14)

1

1

= {−b}, and  U (cid:14)
1(DB) = {a}, where r5 is 
1 (DB) = {b}; now r6 is applicable, and 

The  problem  in  this  example  is  that  the  property  of  being  a  founded  repair  only  excludes  individual actions  that  are 
not supported by the remaining ones, rather than sets of actions with this characteristic. In order to avoid this unwanted 
characteristic, Caroprese and Truszczy ´nski [13] proposed considering justiﬁed repairs, which we now deﬁne.1

Deﬁnition 2.7 ([13]). Let U be a set of update actions and (cid:10)D B, η(cid:11) a database.

• The no-effect actions with respect to DB and U , neffDB(U ), are the actions that change neither DB, nor U (DB).

neffDB(U) = {+a | a ∈ DB ∩ U(DB)} ∪ {−a | a /∈ DB ∪ U(DB)}

= {α | α(DB) = DB ∧ α(U(DB)) = U(DB)} .

• The set of non-updatable literals of an AIC r, nup(r), contains all body literals of r that do not occur in the head of r.

nup(r) = body(r) \ lit

head(r)D

.

(cid:2)

(cid:3)

• U is closed under η if for each r ∈ η, ua(nup(r)) ⊆ U implies head(r) ∩ U (cid:4)= ∅.
• U is a justiﬁed action set if it is a minimal superset of neffDB(U ) closed under η.
• U is a justiﬁed (weak) repair if it is a (weak) repair and U ∪ neffDB(U ) is a justiﬁed action set.

Although the notion of closed set of actions does not take the database into account, its role in the deﬁnition of justiﬁed 
weak  repairs  is  as  part  of  the  deﬁnition  of  justiﬁed  action  set  –  where  all  actions  that  do  not  change  the  database  are 
included.  In  the  normalized  case  that  we  considered,  all  justiﬁed  weak  repairs  are  minimal  with  respect  to  set  inclusion, 
i.e., they are justiﬁed repairs.

Example 2.8. In the setting of Example 2.6, the sets of non-updateable literals are as follows.

nup(r5) = {¬b}
nup(r6) = {¬a}
nup(r7) = {a}
nup(r8) = {b}

The founded repair U1 is not justiﬁed. First, observe that neff(U1) = {−c} (assuming that a, b and c are the only atoms in 
the language). Consider U (cid:14) = ∅ ⊆ U1; then U (cid:14) ∪ neff(U1) = {−c}, and ua(nup(r)) (cid:2) (U (cid:14) ∪ neff(U1)) for every r ∈ η; therefore 
U (cid:14) ∪ neff(U1) is a subset of U1 ∪ neff(U1) containing neff(U1) that is (trivially) closed under η.

In contrast, the repair U2 is justiﬁed. In this case, we have  neff(U2) = {+a, +b}; the only proper subset of U2 is again 
U (cid:14) = ∅. Then both r7 and r8 satisfy ua(nup(r)) ⊆ (U (cid:14) ∪ neff(U2)) = {+a, +b}, and in both cases head(r) = {+c}. Since head(r) ∩
{+a, +b} = ∅, we conclude that U (cid:14) ∪ neff(U2) is not closed under η. (cid:2)

The relation between founded and justiﬁed weak repairs was established by Caroprese and Truszczy ´nski [13].

Lemma 2.9. Let DB be a database, η be a set of AICs over DB and U be a set of update actions over DB. If U is a justiﬁed weak repair 
for (cid:10)D B, η(cid:11), then U is a founded weak repair for (cid:10)D B, η(cid:11).

One of the main issues with the notion of justiﬁed repair is that it is too restrictive. Interestingly, this can already be 

seen by an example originally given by Caroprese and Truszczy ´nski [13], which we reproduce below.

1 Caroprese and Truszczy ´nski [13] never formally deﬁne circularity of support, or discuss why justiﬁed repairs avoid it. We give an informal argument to 
sustain this claim in the discussion after Proposition 3.7 below.

49

(r9)

(r10)

(r12)

(r13)

Example 2.10. Consider the following set of AICs η.

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

a ∧ b ⊃ −a
a ∧ ¬b ⊃ −a
¬a ∧ b ⊃ −b

(r11)
Consider the same database DB = {a, b} as before. This database is inconsistent (it does not satisfy r9 ), and the only possible 
repair is U = {−a, −b}. Furthermore, this repair is intuitively compatible with η, since rule r9 requires us to remove a from 
DB, which triggers r11 and forces us also to remove b.

The repair U is founded, but for a different reason: if we remove −a from U , then r10 is applicable, and its head includes 
−a, while removing −b from U makes r11 applicable, and its head includes −b. Caroprese and Truszczy ´nski [13] considered 
this as another instance of circularity of support (see [17] for a discussion). The repair U is not justiﬁed: neff(U ) = ∅, and 
taking U (cid:14) = ∅ we have that U (cid:14) ∪ neff(U ) = ∅ is again trivially closed under η (every rule has non-updateable literals in its 
body). (cid:2)

A  different  attempt  to  resolve  the  problems  of  circularity  posed  by  founded  repairs,  while  avoiding  the  over-
restrictiveness  of  justiﬁed  repairs,  was  the  introduction  of  well-founded  repairs  by  Cruz-Filipe  et  al.  [17] –  a  third  kind 
of repairs, motivated by an operational approach directly inspired by the syntax of AICs.

Deﬁnition 2.11  ([17]).  A  (weak)  repair  U for  (cid:10)D B, η(cid:11) is  well-founded if  there  exists  a  sequence  of  actions α1, . . . , αn such 
that U = {α1, . . . , αn} and, for each i ∈ {1, . . . , n}, there is a rule ri such that U i−1(DB) |= body(ri) and αi ∈ head(ri), where 
U i−1 = {α1, . . . , αi−1}.

Example 2.12.  In  the  setting  of  Example 2.6,  the  only  well-founded  repair  for  (cid:10)D B, η(cid:11) is  {+c},  as  r7 and  r8 are  the  only 
rules applicable in DB.

Likewise, the repair  U in Example 2.10 is well-founded, as it can be constructed by applying ﬁrst r9 (introducing  −a) 

and afterwards r11. (cid:2)

However, well-founded repairs can also behave unexpectedly.

Example 2.13. Let η be the set of AICs containing

¬a ⊃ +a
¬a ∧ ¬b ⊃ +b
a ∧ ¬b ∧ ¬c ⊃ +c

(r14)
and consider DB = ∅. There are two well-founded repairs for (cid:10)D B, η(cid:11): U1 = {+b, +a}, obtained by applying ﬁrst r13 and then 
r12, and U2 = {+a, +c}, obtained by applying ﬁrst r12 and then r14. It is arguable that U2 is preferable, as it is not reasonable 
to apply r13 when r12 is also applicable, since any action that solves the inconsistency detected by r12 also repairs r13, but 
not conversely. However, the well-founded semantics for AICs cannot infer this restriction. (cid:2)

In this example, it is interesting to note that U2 is a founded repair. Indeed, r12 supports +a and this support is inde-
pendent of b and c; furthermore r14 supports +c when +a is present. However, U1 is not founded, since the action +b is 
not supported, as r13 is not applicable once a has been added to DB.

The examples above show that there exist both founded weak repairs that are not well-founded, and well-founded weak 
repairs  that  are  not  founded.  These  relations  were  established  by  Cruz-Filipe  et  al.  [17],  together  with  the  connection  to 
justiﬁed weak repairs.

Lemma 2.14. Let DB be a database, η be a set of AICs over DB and U be a set of update actions over DB. If U is a justiﬁed weak repair 
for (cid:10)D B, η(cid:11), then U is a well-founded weak repair for (cid:10)D B, η(cid:11).

We  are  also  interested  in  the  shifting property.  Originally  deﬁned  by  Marek  and  Truszczynski  [31] in  the  context  of 
revision  programming,  this  property  was  later  transferred  to  active  integrity  constraints  [13].  Intuitively,  a  semantics  for 
AICs possesses the shifting property if uniformly replacing some literals with their duals preserves the semantics at hand, 
i.e., if the semantics treats truth and falsity of elements in the database symmetrically.

Deﬁnition 2.15. Let  S ⊆ At be a set of atoms and l a literal. The shift of l with respect to  S is deﬁned as

shiftS (l) =

(cid:4)

if l /∈ S
l
lD otherwise

The shift function is extended to sets of literals, update actions and AICs in the straightforward manner.

50

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

Deﬁnition 2.16. We say that a semantics for AICs has the shifting property if: for all (cid:10)D B, η(cid:11) and all  S ⊆ At, U is a repair of 
(cid:10)D B, η(cid:11) accepted by the semantics if and only if shiftS (U ) is a repair of (cid:10)shiftS (DB), shiftS (η)(cid:11) accepted by the semantics.

If  a  semantics  has  the  shifting  property,  then  we  can  reduce  any  situation  to  the  case  DB = ∅ by  taking  S = DB.  All 

semantics discussed in this section have the shifting property.

3.  Grounded repairs

Founded,  well-founded  and  justiﬁed  repairs  were  all  introduced  with  the  purpose  of  characterizing  a  class  of  repairs 
whose actions are supported (there is a reason for having them in the set), without being self-supporting. I.e., they try to 
avoid certain forms of circularity of support. Sometimes, one also requires these repairs to be constructible “from the ground 
up”,  which  was  the  motivation  for  deﬁning  well-founded  repairs.  However,  all  notions  exhibit  unsatisfactory  examples: 
there exist founded repairs with circular support (see, e.g., Example 2.6), and repairs with no circular support that are not 
justiﬁed [17]. In this section, we introduce a new semantics, grounded repairs, aimed at directly tackling this issue.

Grounded  repairs  are  motivated  by  Example 2.6,  where  we  noticed  that  the  deﬁnition  of  founded  repairs  does  not 
manage to capture groups of self-supporting arguments. Indeed, there the repair U1 is founded. It consists of two actions, 
−a and −b such that whenever one of them is removed from U1, there is an AIC whose body is violated and whose head 
is the action in question. However, if we remove both of them simultaneously, we notice that no rule any longer applies. 
As such, we can conclude that these actions are “self-supporting”: the only reason to have one of the two actions in the 
repair of our choice is because the other action is also in there. Our deﬁnition of grounded (weak) repair is aimed directly 
at avoiding this kind of situations.

Deﬁnition 3.1. A set of update actions U is grounded with respect to (cid:10)D B, η(cid:11) if, for each V (cid:3) U , there is a rule r ∈ η such 
that V(DB) |= body(r) and head(r) ∈ (U \ V). A grounded (weak) repair is a (weak) repair that is grounded.

As can be seen, our deﬁnition of groundedness is a slight variant of the notion of foundedness: instead of only consid-
ering what happens if one action is dropped from a proposed set of update actions, we consider arbitrary removals. A ﬁrst 
observation with respect to groundedness is that grounded weak repairs are always minimal, i.e., that each grounded weak 
repair is a repair.

Proposition 3.2. All grounded weak repairs of (cid:10)D B, η(cid:11) are ⊆-minimal, i.e., are repairs.

Proof. Suppose U is a grounded weak repair and U is not minimal, i.e., that there exists a V (cid:3) U that is also a weak repair. 
Since  U is  grounded,  there  must  exist  an  AIC  whose  body  is  satisﬁed  in  V(DB),  contradicting  the  fact  that  V is  a  weak 
repair. (cid:2)

Thus,  the  notion  of  groundedness  intrinsically  embodies  the  principle  of  minimality  of  change,  unlike  other  kinds  of 

weak repairs previously deﬁned.

Proposition 3.3. Let DB be a database, η be a set of AICs over DB and U be a grounded repair for (cid:10)D B, η(cid:11). Then U is both founded and 
well-founded.

Proof. Assume that U is a grounded repair for (cid:10)D B, η(cid:11). The fact that U is founded follows immediately from the deﬁnition 
of grounded repair, since for each action α, V = U \ {α} is a strict subset of U . Hence, by groundedness of U , there must be 
a rule r with head(r) ∈ U \ V = {α}, whose body is satisﬁed in V(DB). We ﬁnd that U is founded indeed.

Now, we show how to construct a sequence of subsets of U that illustrates that U is well-founded. For this sequence, we 
start from U0 = ∅ and construct Ui = Ui−1 ∪ {ui} by picking a rule r ∈ (cid:10)D B, η(cid:11) with head(r) = ui ∈ U and Ui−1(DB) |= body(r). 
Since U is grounded, if Ui−1 (cid:3) U then such a rule always exists, and by construction Ui ⊆ U . But U is ﬁnite, therefore this 
sequence converges towards U , and thus U is a well-founded repair. (cid:2)

However, the notion of grounded repair is strictly stronger than both of these: Example 2.6, presented earlier, also shows 

that some forms of circular justiﬁcations are avoided by grounded repairs.

Example 3.4 (Example 2.6 continued). The repair U1 = {−a, −b} is a founded repair that is not grounded: taking V = ∅, we 
notice that no AIC with −a or +a in the head has its body satisﬁed in V(DB). The more natural repair U2 = {+c} is also 
founded, and it is immediate to verify that it is also grounded. (cid:2)

Likewise, not all well-founded repairs are grounded.

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

51

Example 3.5  (Example 2.13 continued).  Consider  again η from  Example 2.13,  with  DB = ∅.  As  shown  earlier,  the  two  well-
founded repairs for (cid:10)D B, η(cid:11) are U1 = {+b, +a} and U2 = {+a, +c}. We already observed that U1 is not founded, so it cannot 
be grounded; indeed, V = {+a} is a set of update actions such that no rule r with head(r) ∈ (U \ V) has its body satisﬁed 
in V(DB).

We  thus  have  that  grounded  repairs  are  always  founded  and  well-founded;  the  next  example  shows  that  they  do  not 

correspond to the intersection of those classes.

Example 3.6. Consider the following set of AICs η.

(r15)

(r16)

(r17)

(r18)

(r19)

¬a, ¬b ⊃ +a
a, ¬b ⊃ +b
¬a, b ⊃ −b
a, b, ¬c ⊃ +c
a, ¬b, c ⊃ +b
¬a, b, c ⊃ +a

(r20)
Let  DB = ∅.  Then  U = {+a, +b, +c} is  a  repair  for  (cid:10)D B, η(cid:11):  the  ﬁrst  three  constraints  require  a and  b to  be  included  in 
the database. They do not do this in a straightforward manner. Starting from a database in which b holds, but a does not, 
rule (r17) ﬁrst enforces removal of b. Next, rule (r15) adds a and subsequently, rule (r16) adds b. While this combination of 
constraints seems unnatural (no-one would use these to enforce inclusion of a and b in the database), it is possible that this 
type of constraints show up if they are written by different developers maintaining the database, having different concerns. 
The  last  three  rules  state  that  no  2-element  subset  of  U can  be  a  repair.  Given  rule  (r16),  one  might  say  that  rule  (r19)
is redundant. However, again the same argument holds: they could show up together in a database. In this example, U is 
founded (the last three rules also ensure that) and well-founded (starting with ∅, we are forced to apply rules r15 , r16 and 
r18, in that order).

However,  U is  not  grounded:  if  V = {+b},  then  V (cid:3) U ,  but  there  is  no  rule  r with  head(r) ∈ {+a, +c} whose  body  is 

satisﬁed in V(DB). (cid:2)

In this situation, U might seem reasonable; however, observe that the support for its actions is circular: it is the three 
last rules that make U founded, and none of them is applicable to DB. Also note that V(DB) = {b} is a database for which 
the  given  set η behaves  very  awkwardly:  the  only  applicable  AIC  tells  us  to  remove  b,  while  the  only  repair  of  V(DB) is 
actually {+a, +c}.

We  do  not  feel  that  this  example  weakens  the  case  for  studying  grounded  repairs,  though:  the  consensual  approach 
to different notions of repair is that they express preferences. In this case, where (cid:10)D B, η(cid:11) admits no grounded repair, it is 
sensible to allow a repair in a larger class – and a repair that is both founded and well-founded is a good candidate. The 
discussion by Caroprese and Truszczy ´nski [13, Section 8] already proposes such a “methodology”: choose a repair from the 
most restrictive category (justiﬁed, founded, or any). We advocate a similar approach, but including grounded repairs among 
the possible choices.

We now investigate the relation between grounded and justiﬁed repairs, and ﬁnd that all justiﬁed repairs are grounded, 

but not conversely – in line with our earlier claim that the notion of justiﬁed repair is too strong.

Proposition 3.7. Let DB be a database, and let η be a set of normal AICs over DB. If U is a justiﬁed repair for (cid:10)D B, η(cid:11), then U is 
grounded.

Proof. Let U be a justiﬁed repair for (cid:10)D B, η(cid:11) and take V (cid:3) U . Then V ∪ neff(U ) is not closed under η, whence there is a 
rule r ∈ η such that ua(nup(r)) ⊆ V ∪ neff(U ) and head(r) /∈ V ∪ neff(U ).

Since  V ⊆ U ,  also  ua(nup(r)) ⊆ U ∪ neff(U ),  whence  head(r) ∈ U ∪ neff(U ) as  U is  closed  under  η.  But  head(r) /∈ V ∪

neff(U ), so head(r) ∈ U \ V .

We  need  to  show  that  also  V |= body(r).  On  the  one  hand,  ua(nup(r)) ⊆ V ∪ neff(U ) implies  that  V(DB) |= nup(r),  as 
neff(U ) ⊆ neff(V);  on  the  other  hand,  from  head(r) ∈ U we  know  that  lit(head(r))D ∈ DB (all  actions  in  U change  DB), 
whence V(DB) |= lit(head(r)D ) since head(r) /∈ V . As r is normal, there are no more literals in body(r), so V(DB) |= body(r). 
Hence, we have found a rule r such that V |= body(r) and head(r) ∈ (U \ V), thus showing that U is grounded. (cid:2)

This proof does not use the hypothesis that U is a repair. This is due to the fact (already mentioned earlier) that we only 
consider normal AICs in this paper. By Theorem 4 of [13], all justiﬁed weak repairs are minimal when η consists of only 
normal AICs.

Recall  Example 2.10,  which  was  used  by  Cruz-Filipe  et  al.  [17] to  point  out  that  justiﬁed  repairs  sometimes  eliminate 

“natural” repairs. This example also shows that the notion of justiﬁed repair is stricter than that of grounded repair.

52

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

Fig. 1. Relative inclusions between the sets of founded (F ), well-founded (WF ), grounded (G) and justiﬁed (J ) repairs. All inclusions are strict.

Example 3.8 (Example 2.10 continued). Although the repair U = {−a, −b} for (cid:10)D B, η(cid:11) is not justiﬁed, it is grounded: if −a ∈
V (cid:3) U , then there is a rule that derives −b; otherwise, there is a rule that derives −a. (cid:2)

As discussed earlier, in this case the ﬁrst rule clearly motivates the action −a, and the last rule then requires −b. This is 
in contrast to Example 2.6, where there was no clear reason to include either −a or −b in a repair. Hence grounded repairs 
avoid this type of unreasonable circularities, without being as restrictive as justiﬁed repairs.

We summarize the relations between the different types of repairs in Fig. 1.

4.  Preliminaries: lattices, operators and approximation ﬁxpoint theory

4.1.  Lattices, operators and ﬁxpoints

In this section we summarize the ideas, deﬁnitions and main results from approximation ﬁxpoint theory (AFT) that we 

use in the remainder of the paper.

A partially ordered set (poset) (cid:10)L, ≤(cid:11) is a set  L equipped with a partial order ≤, i.e., a reﬂexive, antisymmetric, transitive 
relation. As usual, we write x < y as abbreviation for x ≤ y ∧ x (cid:4)= y. If  S is a subset of  L, then x is an upper bound (a lower 
bound) of  S if for every  s ∈ S, it holds that  s ≤ x (x ≤ s, respectively). An element x is a least upper bound (a greatest lower 
bound)  of  S if  it  is  an  upper  bound  that  is  smaller  than  every  other  upper  bound  (a  lower  bound  that  is  greater  than 
every other lower bound, respectively). If  S has a least upper bound (a greatest lower bound) we denote it lub(S) (glb(S), 
respectively). As is custom, we sometimes call a greatest lower bound a meet, and a least upper bound a join and use the 
S = lub(S) and x ∨ y = lub({x, y}). We call (cid:10)L, ≤(cid:11) a complete lattice if 
related notations 
every subset of L has a least upper bound and a greatest lower bound. A complete lattice has both a least element ⊥ =
L
and a greatest element (cid:19) =

S = glb(S), x ∧ y = glb({x, y}), 

A lattice  L is distributive if ∧ and ∨ distribute over each other, i.e., if  x ∧ ( y ∨ z) = (x ∧ y) ∨ (x ∧ z) and  x ∨ ( y ∧ z) =
(x ∨ y) ∧ (x ∨ z) for all x, y, z ∈ L. A bounded lattice L is complemented if every element x ∈ L has a complement: an element 
¬x ∈ L satisfying x ∧ ¬x = ⊥ and x ∨ ¬x = (cid:19). A Boolean lattice is a distributive complemented lattice.

(cid:6)

(cid:6)

(cid:5)

(cid:5)

L.

Since  we  apply  our  results  to  (ﬁnite)  databases,  for  the  sake  of  simplicity  we  assume  L to  be  ﬁnite in  this  text.  All 

presented results easily generalize to the inﬁnite setting as well.

An operator  O  : L → L is monotone if  x ≤ y implies that  O (x) ≤ O ( y). An element  x ∈ L is a ﬁxpoint of  O if  O (x) = x. 
Every monotone operator  O in a complete lattice has a least ﬁxpoint, denoted lfp(O ), which is the limit (the least upper 
bound) of the increasing sequence (xi)i∈N deﬁned by x0 = ⊥ and xi+1 = O (xi).

Bogaerts  et  al.  [7] called  a  point  x ∈ L grounded for  O if,  for  each  v ∈ L such  that  O (v ∧ x) ≤ v,  it  holds  that  x ≤ v. 
They  called  a  point  x ∈ L strictly grounded if  there  does  not  exist  a  y such  that  y < x,  and  O ( y) ∧ x ≤ y.  They  explained 
the intuition underlying these concepts under the assumption that the elements of  L are sets of “facts” of some kind and 
the ≤ relation is the subset relation between such sets: in this case, a point x is grounded if it contains only facts that are 
sanctioned by the operator  O , in the sense that if we remove them from x, then the operator will add at least one of them 
again. Bogaerts [5] showed that for Boolean lattices the notions of groundedness and strict groundedness coincide. In this 
paper, all lattices of our application are Boolean, hence we use both notions interchangeably.

4.2.  Approximation ﬁxpoint theory

Given a lattice  L, approximation ﬁxpoint theory (AFT) [20] uses the bilattice  L2. We deﬁne two projection functions for 
pairs as usual: (x, y)1 = x and (x, y)2 = y. Pairs (x, y) ∈ L2 are used to approximate elements in the interval [x, y] = {z | x ≤
z ∧ z ≤ y}. We call (x, y) ∈ L2 consistent if  x ≤ y, that is, if [x, y] is non-empty, and use  Lc to denote the set of consistent 
elements. Elements (x, x) ∈ Lc are called exact; they constitute the embedding of L in L2. We sometimes abuse notation and 
use the tuple (x, y) and the interval [x, y] interchangeably. The precision ordering on L2 is deﬁned as (x, y) ≤p (u, v) if x ≤ u
and v ≤ y. In case (u, v) is consistent, this means that (x, y) approximates all elements approximated by (u, v), or in other 
words that [u, v] ⊆ [x, y]. If L is a complete lattice, then (cid:10)L2, ≤p(cid:11) is also a complete lattice.

AFT  studies  ﬁxpoints  of  lattice  operators  O  : L → L through  operators  approximating  O .  An  operator  A : L2 → L2 is 
an  approximator of  O if  it  is  ≤p -monotone,  and  has  the  property  that  A(x, x) = (O (x), O (x)) for  all  x.  Approximators  are 
internal  in  Lc (i.e.,  map  Lc into  Lc ).  As  usual,  we  often  restrict  our  attention  to  symmetric approximators:  approximators 

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

53

A such  that,  for  all  x and  y,  A(x, y)1 = A( y, x)2.  Denecker  et al.  [22] showed  that  the  consistent  ﬁxpoints  of  interest 
(supported, stable, well-founded) are uniquely determined by an approximator’s restriction to Lc , hence, sometimes we only 
deﬁne approximators on Lc .

AFT studies ﬁxpoints of  O using ﬁxpoints of  A.

• The  A-Kripke–Kleene ﬁxpoint is the ≤p -least ﬁxpoint of  A, and it approximates all ﬁxpoints of  O .
• A  partial  A-stable ﬁxpoint is  a  pair  (x, y) such  that  x = lfp( A(·, y)1) and  y = lfp( A(x, ·)2),  where  A(·, y)1 denotes  the 

operator L → L : z (cid:21)→ A(z, y)1 and analogously for  A(x, ·)2.

• The  A-well-founded ﬁxpoint is the least precise (i.e., the ≤p -minimal) partial  A-stable ﬁxpoint.
• An  A-stable ﬁxpoint of  O is  a  ﬁxpoint  x of  O such  that  (x, x) is  a  partial  A-stable  ﬁxpoint.  This  is  equivalent  to  the 

• A  partial A-grounded ﬁxpoint is  a  consistent  pair  (x, y) such  that  for  each  v ∈ L,  whenever  A(x ∧ v, y ∧ v)2 ≤ v,  also 

condition that x = lfp( A(·, x)1).

y ≤ v.

All  (partial  A-)stable  ﬁxpoints  are  (partial  A-)grounded  ﬁxpoints  and  the  A-well-founded  ﬁxpoint  is  the  least  precise 
partial  A-grounded ﬁxpoint [8]. The  A-Kripke–Kleene ﬁxpoint of  O can be constructed as the limit of any monotone induc-
tion  of  A.  For  the  A-well-founded  ﬁxpoint,  a  similar  constructive  characterization  has  been  worked  out  by  Denecker  and 
Vennekens [23]:

Deﬁnition 4.1. An  A-reﬁnement of (x, y) is a pair (x

(cid:14), y

(cid:14)) ∈ L2 satisfying one of the following two conditions:

(i) (x, y) ≤p (x
(ii) x

(cid:14) = x and  A(x, y

(cid:14)) ≤p A(x, y), or
(cid:14) ≤ y.

(cid:14))2 ≤ y

(cid:14), y

An  A-reﬁnement is strict if (x, y) (cid:4)= (x

(cid:14), y

(cid:14)).

We  call  the  ﬁrst  type  (i)  of  reﬁnements  application reﬁnements and  the  second  type  (ii)  unfoundedness reﬁnements. 
(cid:14), y

(cid:14)) is an  A-reﬁnement of (x, y) and  A is clear from the context, we often write (x, y) → (x

(cid:14), y

(cid:14)).

If (x

Deﬁnition 4.2. A well-founded induction of  A is a sequence (xi, yi)i≤n with n ∈ N such that

• (x0, y0) = (⊥, (cid:19));
• (xi+1, yi+1) is an  A-reﬁnement of (xi, yi), for all i < n.

A well-founded induction is terminal if its limit (xn, yn) has no strict  A-reﬁnements.

A well-founded induction is an algebraical generalization of the well-founded model construction deﬁned by Van Gelder 
et al. [40]. The ﬁrst type of reﬁnement corresponds to making a partial structure more precise by applying Fitting’s immedi-
ate consequence operator; the second type of reﬁnement corresponds to making a structure more precise by eliminating an 
unfounded set. For a given approximator  A, there are many different terminal well-founded inductions of  A. Denecker and 
Vennekens [23] showed that they all have the same limit, which equals the  A-well-founded ﬁxpoint of  O . Furthermore, if 
A is symmetric, then the  A-well-founded ﬁxpoint of  O (in fact, every tuple in a well-founded induction of  A) is consistent.

4.3.  Logic programming and AFT

A (normal2) logic program P is a set of rules r of the form

h ← l1 ∧ · · · ∧ ln

(2)
where h is an atom called the head of r, denoted head(r), and each of the li is a literal; l1 ∧ · · · ∧ ln is called the body of 
r and denoted body(r). A rule of the form (2) is called simple if none of the li equals ¬h or h; a logic program is simple if 
it consists of only simple rules. The set of interpretations  2At forms a lattice equipped with the order ⊆. The truth value 
(t or f) of a propositional formula ϕ in a structure  I , denoted ϕ I is deﬁned as usual. With a logic program P , we associate 
an immediate consequence operator [39] T P that maps a structure  I to

T P (I) = {p | ∃r ∈ P : head(r) = p ∧ body(r)I = t}.

Bogaerts et al. [7] called grounded ﬁxpoints of T P grounded models of P .

2 Sometimes, logic programs are deﬁned with disjunctive rules. In the current paper, we only consider normal logic programs: logic programs where the 
head is a single atom. In some propositions, we explicate the fact our programs are normal to emphasize that these results are no longer guaranteed to 
hold in the more general case.

54

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

A ∧ B

A

t
f
u

B
f

f
f
f

t

t
f
u

u

u
f
u

¬ A
f
t
u

A

t
f
u

Fig. 2. The Kleene truth tables for conjunction and negation [29].

Example 4.3. Consider the following logic program P :

(cid:4)

(cid:7)

p
q ← p ∧ q

Its immediate consequence operator T P is represented by the following graph:

(cid:19) = {p, q}

{p}

{q}

⊥ = ∅

T P is  a  monotone  operator  with  least  ﬁxpoint  {p}.  As  such,  {p} is  its  only  grounded  ﬁxpoint.  To  see  that  {p, q} is  not 
grounded, notice that, when taking v = {p},

T P (v ∩ {p, q}) = {p} ⊆ v,

but {p, q} (cid:2) v. (cid:2)

2At
are four-valued interpretations, pairs 
In the context of logic programming, elements of the approximation lattice 
(cid:14) ⊆ I2.  We  often  identify  an 
(cid:14)
I = (I1, I2) of  interpretations.  The  pair  (I1, I2) approximates  all  interpretations  I
interpretation  I with the four-valued interpretation (I, I). We are mostly concerned with consistent (also called partial or 
three-valued) interpretations: tuples I = (I1, I2) with  I1 ⊆ I2. For such an interpretation, the atoms in  I1 are true (t) in I, 
the atoms in I2 \ I1 are unknown (u) in I and the other atoms are false (f) in I. If I is a three-valued interpretation, and ϕ
a formula, we write ϕI

for the standard three-valued valuation based on the Kleene truth tables (see Fig. 2).

(cid:8)

(cid:9)
2
with  I1 ⊆ I

Several  approximators  have  been  deﬁned  for  logic  programs.  The  most  common  is  Fitting’s  immediate  consequence 

operator (cid:6)P [26], a direct generalization of T P to partial interpretations:

(cid:6)P (I)1 = {a ∈ (cid:7) | body(r)I = t for some rule r ∈ P with head(r) = a},
(cid:6)P (I)2 = {a ∈ (cid:7) | body(r)I (cid:4)= f for some rule r ∈ P with head(r) = a}.

Denecker et al. [20] showed that (cid:6)P is an approximator of  T P , that the well-founded ﬁxpoint of (cid:6)P is the well-founded 
model  of  P as  deﬁned  by  Van  Gelder  et  al.  and  that  (cid:6)P -stable  ﬁxpoints  are  exactly  the  stable  models  of  P as  deﬁned 
by  Gelfond  and  Lifschitz.  In  this  case,  the  operator  (cid:6)P (·, y)1 coincides  with  the  immediate  consequence  operator  of  the 
Gelfond–Lifschitz reduct [28] of P with respect to the interpretation  y.

Example 4.4. Consider the following logic program P :

(cid:4)

(cid:7)

p ← ¬q
q ← ¬p

It has two stable models, namely {p} and {q}. Its well-founded model equals its Kripke–Kleene model and is I = (∅, {p, q}), 
i.e.,  the  partial  interpretation  in  which  both  p and  q are  unknown.  To  see  that  I is  the  Kripke–Kleene  model,  it  suﬃces 
(cid:9)
2
that it is the least element of the approximation lattice 
and that it is a ﬁxpoint of (cid:6)P (since in this interpretation, 
the  value  of  all  the  bodies  is  u).  To  see  that  I is  the  well-founded  model,  we  notice  that  there  are  no  unfoundedness 
reﬁnements of I. Indeed, if for some  I ⊆ At, it would hold that

2At

(cid:8)

(cid:6)P (∅, I)2 ≤ I

then q ∈ I (otherwise,  p would be derived by the ﬁrst rule) and  p ∈ I (for a symmetric argument). Hence,  I = {p, q} and 
there is no unfoundedness reﬁnement.

To  see  that  {p} is  a  stable  model,  it  suﬃces  to  note  that  (cid:6)P (∅, {p}) = ({p}, {p}) and  hence  that  {p} = lfp (cid:6)P (·, {p})1

indeed. (cid:2)

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

55

5.  A semantic operator for AICs

In this section we show how a set of normal AICs induces an operator on a suitably deﬁned lattice.
Given a ﬁxed database DB, we are interested in the sets of update actions U such that:

(i) U is consistent and
(ii) each action in U modiﬁes DB.

Note that the second condition here implies the ﬁrst since it is not possible that both +a and −a modify DB. For each atom 
a ∈ At, we deﬁne

(cid:10)

ch a =

+a if a /∈ DB
−a otherwise.

Let us furthermore denote the set of update actions that modify  DB by A. With this notation, A = {ch a | a ∈ At} and the 
A
. Note that ch and A are deﬁned solely based on the initial 
sets of update actions we are interested in are elements of 2
database DB and are not dependent of, for instance, a given repair.

Following the principle of minimality of change [45,25], we also typically prefer smaller sets of updates over larger sets. 
A, ⊆(cid:11), where smaller elements correspond to better repairs according to this 

Therefore, we are interested in the lattice (cid:10)2
principle.

The intuitive reading of an AIC r naturally suggests an operator over this lattice, deﬁned as “if U (DB) |= body(r), then add 
. However, this naive deﬁnition does not lead to an operator that is internal 

A

head(r) to U ” to obtain a new element of 2
in 2

, as illustrated for instance in the following example.

A

Example 5.1. Consider

η = {¬a ⊃ +a}

A = {∅, {−a}}. Now, taking U = {−a}, the body of the only rule in η is satisﬁed. 
and DB = {a}. In this case, A = {−a} and 2
Naively adding its head to U results in the set {+a, −a}, which is not an element of 2
. We expect a semantic operator to 
map U to ∅ since the rule in η indicates that the problems with U (DB) can be solved by adding a, i.e., by not changing DB
at all. (cid:2)

A

This  kind  of  problems  is  inherent  to  the  fact  that  AICs  can  have  rules  with  dual  heads  and  does  not  occur  in  other 
formalisms where AFT is applied, such as, e.g., logic programming3. Intuitively, the operator Tη we wish to deﬁne should 
satisfy the following properties:

• (inertia) Only change something in the input if there is a rule that warrants this change. This requirement consists itself 

of two parts:
– Do not add anything to U unless there is a reason for it, i.e.,

Tη(U) ⊆ U ∪ {head(r) | r ∈ η ∧ U(DB) |= body(r)}.
– Do not remove anything from U unless there is a reason for it, i.e.,

U \ {head(r)D | r ∈ η ∧ U(DB) |= body(r)} ⊆ Tη(U).

• (cancellation) If there is an action in U that is “canceled out” by some rule in η, then neither the action nor its dual 
are  in  the  result  (i.e.,  DB remains  unchanged  with  respect  to  this  action).  Formally,  if  α ∈ U and  α D ∈ {head(r) | r ∈
η ∧ U (DB) |= body(r)}, then α /∈ Tη(U ), α D /∈ Tη(U ).

• (completeness) If there is an applicable rule whose body is satisﬁed, and whose head does not contradict U , then the 

head is derived. Formally,

{head(r) | r ∈ η ∧ U(DB) |= body(r) ∧ head(r)D /∈ U} ⊆ Tη(U).

It turns out that these three properties uniquely deﬁne an operator on 2
of this operator, we introduce the following concept.

A

. In order to give a constructive characterization 

3 Notice that for instance in default logic, rules with complementary literals in their head are allowed. However, such literals are treated as two indepen-
dent statements and can be derived separately. In the current setting, an update action +p can undo the effect of a previously derived action −p.

56

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

Deﬁnition 5.2. Let U1 and U2 be sets of update actions over a set of atoms At. The set U1 (cid:24) U2 is deﬁned as

(U1 (cid:24) U2) (DB) = (U1 ∪ U2) \ {α | α, α D ∈ U1 ∪ U2} .

This operation models sequential composition of repairs in the following sense: given a database DB, if every action in 

U1 changes DB and every action in U2 changes U1(DB), then (U1 (cid:24) U2)(DB) = U2(U1(DB)).

Observe  that,  while  a  set  of  AICs  may  include  both  a  rule  with  head  +a and  another  with  head  −a,  these  rules  are 
not simultaneously applicable, as the conjunction of their bodies is always unsatisﬁable. However, it may be the case that 
applying one of them makes the other applicable (undoing the effect of the ﬁrst one). In this case, the operation deﬁned 
above guarantees that the database always reﬂects the last actions that were executed.

We note also that U1 (cid:24) U2 is consistent whenever U1 and U2 are.

Deﬁnition 5.3. Let DB be a database and η be a set of AICs over DB. The operator T DB

η

η (U) = U (cid:24) {head(r) | r ∈ η ∧ U(DB) |= body(r)}
T DB

: 2

A → 2

A

is deﬁned as follows:

In other words, T DB

η (U ) is obtained by updating U with the heads of all AICs whose bodies are satisﬁed by U (DB). To see 
that this operator is well-deﬁned (i.e., that the result of applying it indeed yields a consistent set of actions), observe that 
the  syntactic  restrictions  on  AICs  guarantee  that  the  set  {head(r) | r ∈ η ∧ U (DB) |= body(r)} is  always  consistent.  Indeed, 
if  both  +a and  −a are  in  this  set,  then  there  must  be  rules  r1 and  r2 such  that  ¬a ∈ body(r1) and  a ∈ body(r2) with 
U (DB) |= body(ri) for i = 1, 2, which is impossible since it would mean that U (DB) |= a and U (DB) |= ¬a. From this, it also 
follows that Tη(U ) is always consistent. As before, when DB is clear from the context, we simply write Tη for T DB
η .

Proposition 5.4. The operator Tη is the only operator on 2

A

that satisﬁes inertia, cancellation and completeness.

Proof. It is easy to verify that Tη satisﬁes inertia, cancellation and completeness.

Now, assume  O  : 2

satisﬁes the three properties. Let α be any action in A and U ⊆ A. Let V denote {head(r) |
r ∈ η ∧ U (DB) |= body(r)}. Since, α ∈ A, we know that α D /∈ U . We show that α ∈ O (U ) if and only if α ∈ Tη(U ) = U (cid:24) V . 
We distinguish 3 cases:

A → 2

A

• If α ∈ V , then, since α D /∈ U , by completeness, α ∈ O (U ). In this case, since α D /∈ U ∪ V , but α ∈ U ∪ V , it holds that 

α ∈ U (cid:24) V = Tη(U ).

• If α D ∈ V , then there is a rule r ∈ η such that α D ∈ head(r) and U (DB) |= body(r). Since U (DB) |= body(r), lit(α) holds 
in  U (DB).  Since  α changes  DB,  we  know  that  lit(α) does  not  hold  in  DB,  hence  it  must  be  the  case  that  α ∈ U .  By 
cancellation, we then ﬁnd that α /∈ O (DB). Since α ∈ U but α D ∈ V , also α /∈ U (cid:24) V = Tη(U ).

• If neither α ∈ V , nor α D ∈ V , then by inertia, it must hold that α ∈ O (U ) if and only if α ∈ U . In this case, it also holds 

that α ∈ Tη(U ) = U (cid:24) V if and only if α ∈ U .

Hence, we have proven in each of the cases that α ∈ O (U ) if and only if α ∈ Tη(U ) and the result follows. (cid:2)

Example 5.5 (Example 2.3 continued). Consider again the set of AICs η from Example 2.3, where DB = {a, b}. Then Tη(∅) =
{−a, −b}. Indeed, the bodies of all rules are satisﬁed; hence all heads are elements of Tη(∅). (cid:2)

Proposition 5.6. Let DB be a database, η be a set of normal AICs over DB and U be a set of update actions. Then U is a weak repair for 
(cid:10)D B, η(cid:11) if and only if U is a ﬁxpoint of Tη.

A
Proof. If U is a weak repair for (cid:10)D B, η(cid:11), then certainly, U ∈ 2
. Also, U (DB) (cid:4)|= body(r) for all r ∈ η, whence Tη(U ) = U . If U
is not a weak repair for (cid:10)D B, η(cid:11), then U (DB) |= body(r) for some r ∈ η, and Tη(U ) differs from U by (at least) head(r). (cid:2)

Example 5.7. In general, Tη does not need to have ﬁxpoints (since there may be no database satisfying η). A simple (unre-
alistic) example is if η consists of the two rules

a ⊃ −a

and
where Tη(DB) (cid:4)= DB for any database DB. (cid:2)

¬a ⊃ +a

Proposition 5.8. Let DB be a database, η be a set of normal AICs over DB and U be a set of update actions. Then U is a repair for 
(cid:10)D B, η(cid:11) if and only if U is a minimal ﬁxpoint of Tη.

Proof. Follows directly from Proposition 5.6 and the deﬁnition of repair. (cid:2)

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

57

Proposition 5.9. Let DB be a database, η be a set of normal AICs over DB and U ∈ 2
and only if, for all α ∈ U , it is the case that α ∈ Tη(U \ {α}).

A

. Then U is founded with respect to (cid:10)D B, η(cid:11) if 

Proof. It follows from the deﬁnition of Tη that for each action α ∈ U , the following are equivalent:

(i) there is a rule r ∈ η such that (U \ {α})(DB) |= body(r) and
(ii) α ∈ Tη(U \ {α}).

Now,  U is  founded  if  and  only  if (i) holds  for  all  actions  α ∈ U ;  this  is  indeed  equivalent  with  the  condition  from  this 
proposition, which is that (ii) holds for each α ∈ U . (cid:2)

This  result  also  gives  some  intuition  regarding  why  founded  repairs  allow  for  circular  dependencies:  the  deﬁnition  of 
founded repair only checks that each individual action is supported by the remaining ones, but it still allows for dependency 
cycles.

Proposition 5.10. Let DB be a database, η be a set of normal AICs over DB and U be a weak repair for (cid:10)D B, η(cid:11). Then U is well-founded 
if and only if there is an ordering α1, . . . , αn of the elements of U such that αi ∈ Tη({α1, . . . , αi−1}) for each i = 1, . . . , n.

Proof. This  is  a  direct  consequence  of  the  deﬁnitions  of  Tη and  of  well-founded  repair.  By  deﬁnition,  U is  well-founded 
if  and  only  if  there  exists  a  ordering  α1, . . . , αn of  the  elements  of U such  that  for  each  i,  there  is  a  rule  ri ∈ η with 
U i−1(DB) |= body(ri) and αi ∈ head(ri) (where  U i denotes {α1, . . . , αi}). Now, the condition that there is a rule ri ∈ η with 
U i−1(DB) |= body(ri) and αi ∈ head(ri) is equivalent with the condition that αi ∈ Tη(Ui−1), from which the result follows. (cid:2)

Proposition 5.11. Let DB be a database and η a set of AICs over DB. A set of update actions U is a grounded repair of (cid:10)D B, η(cid:11) if and 
only if U is a grounded ﬁxpoint of Tη.

Proof. Recall that grounded and strictly grounded ﬁxpoints of Tη coincide. We show that U is a grounded repair of (cid:10)D B, η(cid:11)
iff U is a strictly grounded ﬁxpoint of Tη.

First  suppose  that  U is  not  a  strictly  grounded  ﬁxpoint  of  Tη .  This  means  that  there  exists  a  set  V (cid:3) U such  that 
Tη(V) ∩ U ⊆ V . From the deﬁnition of Tη it follows immediately that, if r is a rule such that V(DB) |= body(r), then head(r) /∈
(U \ V), whence U is not a grounded repair for (cid:10)D B, η(cid:11).

Conversely, assume that U is a strictly grounded ﬁxpoint of Tη and let V be any subset of U such that there is no rule 
r for which V(DB) |= body(r) and head(r) ∈ (U \ V). From the deﬁnition of Tη , it follows that Tη(V) ∩ (U \ V) = ∅ and thus 
that Tη(V) ∩ U ⊆ V . Since U is strictly grounded, it follows that V = U . (cid:2)

The previous proposition illustrates that Proposition 3.7 is not a coincidence at all. Indeed, Bogaerts et al. [7] have already 
shown  that  all  stable  ﬁxpoints  of  a  given  approximator  are  grounded,  and  Caroprese  and  Truszczy ´nski  [13,  Theorem 6]
showed that justiﬁed repairs are stable models of a given derived logic program. In the following sections, we explore this 
relationship  further:  ﬁrst,  we  deﬁne  an  approximator  for  Tη and  as  such  obtain  also  a  notion  of  stable  repair.  Next,  in 
Section 7, we study the relationship between logic programs and AICs in depth.

Since grounded repairs can be built from the ground up, this result also corroborates the informal claim that justiﬁed 

repairs avoid circularity of support, as stated by Caroprese and Truszczy ´nski [13].

6.  An approximator for AICs

In  this  section,  we  deﬁne  an  approximator  for  Tη and  hence,  obtain  a  set  of  AFT-based  semantics  for  AICs,  based  on 

intuitions similar to those underlying groundedness and various semantics from non-monotonic reasoning.

A partial action set is a tuple U = (Uc, Up) where Uc ∈ 2

. A partial action set is an approximation of a set of 
update actions. It provides information on which update actions are certainly applied (the actions in Uc ) and which actions 
are possibly applied (the actions in Up ). If Uc ⊆ Up , we say that U is consistent. We are mostly concerned with consistent 
partial action sets. If α ∈ A, the value of α in U (denoted U(α)) is:

and Up ∈ 2

A

A

• true, denoted t, if α ∈ Uc and α ∈ Up ,
• false, denoted f, if α /∈ Uc and α /∈ Up ,
• unknown, denoted u, if α /∈ Uc and α ∈ Up ,
• inconsistent, denoted i, if α ∈ Uc and α /∈ Up .

Note that a partial action set is characterized completely by the mapping A → {t, f, u, i} it induces:

Uc = {α ∈ A | U(α) ∈ {t, i}},
Up = {α ∈ A | U(α) ∈ {t, u}}.

58

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

We sometimes exploit this correspondence, by not explicating the partial action set itself, but the mapping, as this allows 
for more compact notation and more elegant deﬁnitions. It can be seen that U is consistent if and only if U(α) ∈ {t, f, u} for 
all α. The intended interpretation of a consistent partial action set is thus that U(a) is true iff a is certainly changed by U, 
it is false iff a is certainly not changed by U and it is unknown if U leaves it open whether or not a is changed. The set of 
A)2. We call U
all consistent partial action sets is denoted as  P . As such,  P is exactly the consistent part of the bilattice (2
two-valued if Uc = Up , i.e., if U(α) ∈ {t, f} for all α; in this case, we identify U with the action set Uc . The truth order ≤t on 
truth values is deﬁned by f ≤t u ≤t t; f ≤t i ≤t t. The inverse of a truth value is f

−1 = f, u

−1 = u, i

−1 = t, t

A  (consistent)  partial  database  is  a  mapping  DB : At → {t, f, u}.  The  intended  reading  is  that  DB(a) is  true  if  a is 

−1 = i.

certainly in the database, DB(a) is false if a is certainly not in the database and DB(a) is unknown otherwise.

If U ∈ P is a consistent partial action set and DB is a (regular) database, then we deﬁne U(DB) to be the partial database 

such that

U(DB) : a (cid:21)→

⎧
⎪⎨

⎪⎩

if U(a) = f
DB(a)
DB(a)−1 if U(a) = t
otherwise,
u

where DB(a) = t if a ∈ DB and DB(a) = f otherwise.

Deﬁnition 6.1. Given a partial database DB, a set of AICs η and an update action α, we deﬁne the support of α with respect 
to (cid:10)DB, η(cid:11) as

suppDB,η(α) = max
≤t

{nup(r)DB | r ∈ η ∧ head(r) = α},

where  nup(r)DB refers  to  the  standard  three-valued  truth  evaluation  of  the  formula4 nup(r) in  the  partial  interpretation 
DB based on Kleene’s truth tables [29] (see Fig. 2).

Intuitively, this means that the support of an action α is the highest truth value of the (non-updateable part of the) body 

of a rule in η with α in the head.

Example 6.2. Consider DB = ∅ and the following set η:

¬a ∧ b ⊃ +a
a ∧ c ∧ d ⊃ −a .

Consider U = ({+a, +b, +c}, {+a, +b, +c, +d}). Then U(DB) = {a (cid:21)→ t, b (cid:21)→ t, c (cid:21)→ t, d (cid:21)→ u}. In this case, suppU(DB),η(+a) = t
and suppU(DB),η(−a) = u. (cid:2)

Deﬁnition 6.3. Given DB and η, we deﬁne an operator T(cid:10)D B,η(cid:11) : P → P , such that for each U ∈ P and each α ∈ A:

• If U(α) = f, then T(cid:10)D B,η(cid:11)(U)(α) = suppU(DB),η(α).
• If U(α) = t, then T(cid:10)D B,η(cid:11)(U)(α) = suppU(DB),η(α D )−1.
• Otherwise (i.e., if U(α) = u):

– if suppU(DB),η(α) = t and suppU(DB),η(α D ) = f, then T(cid:10)D B,η(cid:11)(U)(α) = t;
– if suppU(DB),η(α D ) = t and suppU(DB),η(α) = f, then T(cid:10)D B,η(cid:11)(U)(α) = f;
– otherwise, T(cid:10)D B,η(cid:11)(U)(α) = u.

When DB is clear from the context, we write Tη for T(cid:10)D B,η(cid:11).

Deﬁnition 6.3 is  motivated  as  follows.  Assume  U is  a  partial  update  set  containing  some  information  on  the  intended 
update. In this case Tη(U) represents a revised update, using the AICs in η. In the case where U(α) = f, α is not an element 
of  the  (partial)  update  set  at  hand.  The  only  way  to  add  α to  the  update  is  if  some  rule  supports  α,  which  is  captured 
by suppU(DB),η(α). The case for U(α) = t is completely symmetrical, in this case the only reason for removing α from the 
update  at  hand  is  there  is  support  for  its  dual.  In  the  last  case,  where  U(α) = u,  we  have  no  information  on  whether  α
should  or  shouldn’t  be  in  the  update  yet.  In  this  case,  we  can  derive  that  α must be  in  the  update  if  we  already  have 
support for α and we are sure that there is no support for it dual (for α D ). Similarly, we can derive that α must not be in 
the update if we have support for α D and certainly not for α. In all other cases, we derive nothing about α being in the 
update or not.

4 Technically, nup(r) is a set of literals; we identify it with the conjunction of those literals.

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

59

Since  suppU(DB),η(α) and  suppU(DB),η(α D )−1 are consistent whenever U is consistent, the above operator is indeed de-

ﬁned on  P , i.e., T(cid:10)D B,η(cid:11)(U) is consistent whenever U is.

Recall  that  Denecker  et al.  [22] showed  that  it  suﬃces  to  deﬁne  approximator  on  the  consistent  part  of  the  bilattice. 
A)c ,  Tη is  a  candidate  approximator  of  Tη.  The  next  proposition  shows  that  this  is  indeed  the 

Using  the  fact  that  P = (2
case.

Proposition 6.4. Tη is an approximator of Tη.

Proof. First,  we  show  that  Tη is  ≤p -monotone.  To  see  this,  ﬁrst  note  that  Kleene-valuation  is  ≤p -monotone.  Hence,  for 
each α ∈ A, also the functions that map U to suppU(DB),η(α) and suppU(DB),η(α D ) are ≤p -monotone. Now take some α ∈
A and  suppose  U(cid:14) ≥p U.  Then  suppU(cid:14)(DB),η(α) ≥p suppU(DB),η(α) and  suppU(cid:14)(DB),η(α D ) ≥p suppU(DB),η(α D ).  We  show  that 
Tη(U(cid:14))(α) ≥p Tη(U)(α) by a case analysis on the deﬁnition of Tη(U)(α).

• If U(α) = f, then U(cid:14)(α) = f since U(cid:14) ≥p U. In this case Tη(U(cid:14))(α) = suppU(cid:14)(DB),η(α) ≥p suppU(DB),η(α) = Tη(U)(α).
• The case where U(α) = t is similar.
• Assume U(α) = u.

– If suppU(DB),η(α) = t and suppU(DB),η(α D ) = f, then Tη(U)(α) = t and also suppU(cid:14)(DB),η(α) = t and suppU(cid:14)(DB),η(α) = f. 
Hence  if  U(cid:14)(α) = u,  this  is  trivially  proven.  In  case  U(cid:14)(α) = t,  Tη(U(cid:14))(α) = suppU(cid:14)(DB),η(α D )−1 = t and  in  case
U(cid:14)(α) = f, Tη(U(cid:14))(a) = suppU(cid:14)(DB),η(α) = t. Hence, in all cases Tη(U)(α) = Tη(U(cid:14))(α) and the claim follows.

– The case where suppU(DB),η(α D ) = t and suppU(DB),η(α) = f is similar to the previous.
– In all other cases, Tη(U)(α) = u, hence Tη(U(cid:14))(α) ≥p Tη(U)(α) is trivially satisﬁed.

Secondly,  we  show  that  on  two-valued  update  sets,  Tη and  Tη coincide,  i.e.,  that  for  all  U ,  Tη(U ) = Tη(U ).  Take  any 

α ∈ A, we again prove this claim by a case analysis on the deﬁnition of Tη(U )(α).

• If  U (α) = f,  then  Tη(U)(α) = t if  and  only  if  there  is  some  rule  r ∈ η with  U (DB) |= body(r) and  head(r) = α.
Since  body(r) = nup(r) ∧ lit(α D ),  we  conclude  that  Tη(U )(α) is  true  if  and  only  if  suppU (DB),η(α) = t,  if  and  only  if
Tη(U )(α) = t.

• The case for U (α) = f is similar.
• The case where U (α) = u cannot occur, since U is two-valued. (cid:2)

Since Tη is an approximator, it deﬁnes a family of semantics for AICs.

Deﬁnition 6.5. Let (cid:10)D B, η(cid:11) be a database.

• A partial stable repair of (cid:10)D B, η(cid:11) is a partial update set U such that U is a partial Tη-stable ﬁxpoint. A stable repair is a 

partial stable repair that is two-valued.

• The AFT-well-founded repair of (cid:10)D B, η(cid:11) is the Tη-well-founded ﬁxpoint (in general, this is a partial update set).
• The Kripke–Kleene repair of (cid:10)D B, η(cid:11) is the Tη-Kripke–Kleene ﬁxpoint (in general, this is a partial update set).
• A partial grounded repair of (cid:10)D B, η(cid:11) is a partial update set U such that U is a partial Tη-grounded ﬁxpoint Bogaerts et 

al. [8]. A grounded repair is a partial grounded repair that is two-valued.

The terminology in the above deﬁnition uses “repairs” for certain classes of ﬁxpoints of a semantic operator. It follows 
easily that all two-valued update sets that are called “repair” in the above deﬁnition, indeed are repairs according to AIC 
terminology. This paper is the ﬁrst work that studies partial (non-two-valued) repairs.

The well-founded semantics induced by AFT can in general differ from the existing well-founded semantics for AICs, as 

we show in Example 6.12. To distinguish the two, we use the term AFT-well-founded semantics.

It  follows  directly  from  Bogaerts  et  al.  [8,  Proposition  3.2] and  Proposition 5.11 that  grounded  repairs  as  deﬁned  in 

Deﬁnition 6.5 coincide with Deﬁnition 3.1. All other classes of repairs are new.

We now illustrate these semantics by means of some examples.

Example 6.6. Consider the following set η of AICs:

¬a ⊃ +a
¬a ∧ ¬b ∧ ¬c ⊃ +c
a ∧ ¬b ⊃ +b
a ∧ c ∧ b ⊃ −b

60

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

with DB = ∅. Now, the Tη-well-founded ﬁxpoint can be computed as the limit of a well-founded induction. It starts at U0
that maps

+a (cid:21)→ u, +b (cid:21)→ u, +c (cid:21)→ u,

i.e., U0 is5 the partial action

(∅, {+a, +b, +c}).

Here, we see that

suppU0(DB),η(+a) = t,
suppU0(DB),η(+b) = u,
suppU0(DB),η(+c) = u,

suppU0(DB),η(−a) = f
suppU0(DB),η(−b) = u
suppU0(DB),η(−c) = f

Hence,

U1 = Tη(U0) : +a (cid:21)→ t, +b (cid:21)→ u, +c (cid:21)→ u

is a reﬁnement of U0. Now, it can be veriﬁed that U1 is a ﬁxpoint of Tη. This is the Kripke–Kleene ﬁxpoint. It is a partial 
repair set and provides the information that a must be added, but it is uncertain about b and c.
A well-founded induction continues by unfoundedness reﬁnement. The partial update set

U2 = +a (cid:21)→ t, +b (cid:21)→ u, +c (cid:21)→ f

is an unfoundedness reﬁnement of U1. This follows easily from the fact that

U3 = Tη(U2) = +a (cid:21)→ t, +b (cid:21)→ t, +c (cid:21)→ f.

Furthermore, U3 is an application reﬁnement of U2. Since this is an exact point, it is the Tη-well-founded ﬁxpoint of Tη . It 
is clearly the intended repair in this example.

Note that in this example, unfoundedness reﬁnements take care of minimizations of repairs. (cid:2)

Example 6.7. Consider the following set η of AICs:

a ∧ ¬b ⊃ +b
¬a ∧ b ⊃ +a
¬a ∧ ¬b ∧ ¬c ⊃ +c

with DB = ∅. Intuitively, we expect +c to be an element of “good” repairs, and (following the minimality of change princi-
ple), no other actions to be in “good” repairs.

Now, the Tη-well-founded ﬁxpoint can be computed as the limit of a well-founded induction. It starts at

U0 : +a (cid:21)→ u, +b (cid:21)→ u, +c (cid:21)→ u.

Here, we see that

suppU0(DB),η(+a) = u,
suppU0(DB),η(+b) = u,
suppU0(DB),η(+c) = u,

suppU0(DB),η(−a) = f
suppU0(DB),η(−b) = f
suppU0(DB),η(−c) = f

Hence, Tη(U0) = U0 and U0 is the Tη-Kripke–Kleene ﬁxpoint. A well-founded induction can continue with unfoundedness 
reﬁnements. Indeed, consider

U1 : +a (cid:21)→ f, +b (cid:21)→ f, +c (cid:21)→ u.

Since

Tη(U1) = +a (cid:21)→ f, +b (cid:21)→ f, +c (cid:21)→ t,

it holds that U1 is an unfoundedness reﬁnement of U0. Finally, we can conclude that U2 := Tη(U1) is the Tη-well-founded 
ﬁxpoint. This corresponds to the intended repair. (cid:2)

5 Recall that for simplicity, we often characterize partial action sets by their induced truth function.

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

61

As can be expected, not every set of AICs has a two-valued well-founded repair. That would simply be too much to ask, 
as it would mean that for every set of AICs we can unambiguously identify a single repair. The following example illustrates 
that this is indeed not always the case. It also illustrates that, for this speciﬁc example, Tη -stable repairs provide a solution 
that corresponds to the intuitions.

Example 6.8. Consider the following set η of AICs:

¬a ∧ ¬b ⊃ +a
¬a ∧ ¬b ⊃ +b
a ∧ ¬c ⊃ +c

with DB = ∅. Intuitively, η has two “good” repairs. The ﬁrst two rules state that a or b should be added in order to “ﬁx” the 
violated constraint  ¬(¬a ∧ ¬b). Depending on that choice, the last rule determines whether or not  c should be repaired. 
The two intended repairs are thus {+a, +c} and {+b}. Let us investigate what the different AFT-style semantics give in this 
case.

Consider

U0 : +a (cid:21)→ u, +b (cid:21)→ u, +c (cid:21)→ u.

Here, it holds that

suppU0(DB),η(+a) = u,
suppU0(DB),η(+b) = u,
suppU0(DB),η(+c) = u,

suppU0(DB),η(−a) = f
suppU0(DB),η(−b) = f
suppU0(DB),η(−c) = f

Hence,  Tη(U0) = U0 and  U0 is  the  Tη-Kripke–Kleene  ﬁxpoint.  Furthermore,  we  claim  that  there  are  no  unfoundedness 
reﬁnements of U0, and hence that U0 is also the Tη-well-founded ﬁxpoint. To see that our claim indeed holds, notice that 
any unfoundedness reﬁnement of U0 should consist of making a subset U of {+a, +b, +c} false, in such a way that for each 
α ∈ U , Tη(U0[U : f])(α) = f. Assume +a ∈ U . In order for Tη(U0[U : f])(+a) to be false +b must be t in U0[U : f] (otherwise 
the body of the rule deﬁning +a is unknown or true). That is not possible, hence +a /∈ U . From a similar argument, we ﬁnd 
that +b /∈ U and +c /∈ U . Trivially, the two intended repairs are more precise than the well-founded ﬁxpoint.

Now, let us check whether U := {+a, +c} is a stable repair. For this, we need to verify if

U = lfp(Tη(·, U)1).

Deﬁne U0 = ∅. Then

(U0, U) = +a (cid:21)→ u, +b (cid:21)→ f, +c (cid:21)→ u.

Hence

and

Tη(U0, U) = +a (cid:21)→ t, +b (cid:21)→ u, +c (cid:21)→ u

U1 := Tη(U0, U)1 = {+a}.

Similarly,

(U1, U) = +a (cid:21)→ t, +b (cid:21)→ f, +c (cid:21)→ u.

Hence

and

Tη(U1, U) = +a (cid:21)→ t, +b (cid:21)→ f, +c (cid:21)→ t

U2 := Tη(U1, U)1 = U.

Furthermore, Tη(U2, U ) = U2 = U , hence we ﬁnd that indeed, U is an Tη-stable ﬁxpoint. The case for {+b} is similar.

It can also be veriﬁed that there are no other Tη -stable ﬁxpoints. Due to minimality, no other could contain +b, hence 
they must be subsets of {+a, +c}. But since U is a stable repair, it is already minimal, hence no strict subset of {+a, +c}
can be a stable repair. (cid:2)

Hence, in the above example, Tη-stable repairs capture the intended semantics.
We omit examples of grounded ﬁxpoints, as we already included some in Section 3.

62

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

Properties of AFT-style semantics  We now show that all AFT-style semantics are nicely invariant under shifting.

Proposition 6.9. Tη, and hence also Tη, commutes with shifting, i.e., for each set S ⊆ At:

shifts ◦ T(cid:10)D B,η(cid:11) = T(cid:10)shiftS (DB),shiftS (η)(cid:11)

Proof. The clue to proving this proposition is the fact that for each action α,

suppU(DB),η(α) = suppU(shiftS (DB)),shiftS (η)(shiftS (α)).

Then, the result easily follows from the fact that Tη has been deﬁned entirely based on the supp function. (cid:2)

Corollary 6.10. All AFT-style semantics for AICs have the shifting property.

Proposition 6.11. If the AFT-well-founded repair is two-valued, it is also well-founded (as deﬁned by Cruz-Filipe et al. [17]).

Proof. Let  (Ui)i≤k be  a  well-founded  induction  of  Tη .  For  each  i,  deﬁne  Ui as  {α ∈ A | Ui(α) = t}.  We  will  prove  the 
following  claim  by  induction  on  the  length  k of  the  well-founded  induction  (note  that  we  restrict  to  ﬁnite  well-founded 
inductions here, since we assume At to be ﬁnite).

Claim: There exists a sequence α1, . . . , αn such that Uk = {α1, . . . , αn} and, for each i ∈ {1, . . . , n}, there is a rule ri such 
that {α1, . . . , αi−1}(DB) |= body(ri) and αi = head(ri).

From this claim, taking any terminal well-founded induction yields the desired result.
We now show the claim indeed holds. The claim is trivial for k = 0. Assume the claim holds for k, we show that it also 
holds for k + 1. Thus assume α1, . . . , αn is a sequence with Uk = {α1, . . . , αn} satisfying the above condition. If Uk+1 is an 
unfoundedness reﬁnement of Uk, then Uk+1 = Uk and there is nothing to show. Hence, assume that Uk ≤p Uk+1 ≤p Tη(Uk). 
In  this  case,  Uk+1 = Uk ∪ {β j | 1 ≤ j ≤ m} for  some  sequence  of  elements  β j such  that  Tη(Uk)(β j) = t.  For  each  j,  let  U (cid:14)
j
denote {α1, . . . , αn, β1, . . . , β j}. We claim that the sequence α1, . . . , αn, β1, . . . , βm still satisﬁes the condition in the claim. 
To see this, note that from the deﬁnition of Tη , it follows that for each  j ∈ {1, . . . , m} there is a rule r j with nup(r)Uk(DB) = t
and head(r j) = β j . Furthermore, for each  j it holds that U (cid:14)
j−1 = t. Since β j /∈ U j−1, we also see 
that body(r j)

j−1 = t. Hence, the claim indeed holds for k + 1 as well. (cid:2)

≥p Uk, hence also nup(r)

j−1

U (cid:14)

U (cid:14)

Example 6.12.  The  converse  of  Proposition 6.11 does  not  hold,  as  illustrated  by  Example 2.13.  The  intuitive  repair  U2 =
{+a, +c} is the AFT-well-founded repair for (cid:10)D B, η(cid:11). However, there is another well-founded repair U1 = {+a, +b}. (cid:2)

Proposition 6.13. All Tη-stable repairs are justiﬁed.

Proof. We can safely assume that U is a repair of DB (otherwise, it is not a Tη-stable repair).

Before starting the actual proof, we introduce a couple of auxiliary operators. For each set of update actions V , let ext(V)
denote  V ∪ neffU (DB).  Note  that  ext(V) is  consistent  whenever  V ⊆ U .  For  each  set  of  update  actions  V ,  let  closure(V)
denote

closure(V) = V ∪ {head(r) | ua(nup(r)) ⊆ V}.

Now, we deﬁne the operator (on sets of update actions):

O : V (cid:21)→ closure(ext(V)) \ neffU (DB).

Below, we prove the following claims:

Claim 1: U is a minimal preﬁxpoint of  O if and only if U is a justiﬁed repair of (cid:10)D B, η(cid:11).
Claim 2: For any literal l, ua(l) ∈ ext(DB) if and only if l(V,U )(DB) = t.
Claim 3: For any update action α, α ∈ closure(ext(V)) if and only if supp(V,U )(DB),η(α) = t.
Claim 4: For every set of update actions V ⊆ U :

Tη(V, U)1 ⊆ O (V).

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

63

Now, assume U is a Tη-stable repair. It is clear that  O is a monotone operator, hence it has a unique minimal preﬁxpoint, 
which is also its least ﬁxpoint. Since U is a repair, it is a ﬁxpoint of  O ; we need to show that it is minimal. Assume U (cid:14) ⊆ U
is a preﬁxpoint of  O as well. This means  O (U (cid:14)) ⊆ U (cid:14)

and hence

, U)1 ⊆ (O (U (cid:14)

Tη(U (cid:14)
is a preﬁxpoint of Tη(·, U )1. Since U is an Tη-stable repair, U is the least preﬁxpoint of Tη(·, U )1 and thus U = U (cid:14)

)) ⊆ U (cid:14)

,

. 

, which we needed to prove. We conclude that, indeed, U is a justiﬁed repair.

i.e., U (cid:14)
Hence, also U = U (cid:14)

Claim 1 Recall that U is a repair. The claim then follows immediately from the deﬁnition of justiﬁed repair. Preﬁxpoints 
of  the  closure operator  are  sets  of  update  actions  closed  under  η.  Hence  U is  a  minimal  preﬁxpoint  of  O iff  ext(U ) is  a 
minimal set of update actions that contains neffU (DB) and is closed under η.

Claim 2 Pick some literal l.
First assume that ua(l) ∈ ext(V) = V ∪ neffU (DB). We show that l(V,U )(DB) = t. We consider two cases:

• If ua(l) ∈ neffU (DB), then lDB = t and U does not change the value of l. Thus, l(V,U )(DB) = lDB = t.
• If  ua(l) /∈ neffU (DB), then it must hold that  ua(l) ∈ V ⊆ U . Since  ua(l) ∈ U and every action in U changes  DB, it must 

hold that lDB = f. Now, since ua(l) ∈ V , (V, U ) changes the value of l and thus l(V,U )(DB) = (lDB)−1 = t in this case.

For  the  other  direction,  assume  that  l(V,U )(DB) = t.  We  need  to  show  that  ua(l) ∈ ext(V) = V ∪ neffU (DB).  Assume  that 
ua(l) /∈ neffU (DB), we show that ua(l) ∈ V . Since l(V,U )(DB) = t and U ≥p (V, U ), also l
U = t. Since l /∈ neffU (DB), this means 
that lDB = f. Now, l(V,U )(DB) = t = (lDB)−1. Hence it must hold that (V, U ) changes the value of l. Since lDB = f, this means 
that ua(l) ∈ V , which is exactly what we needed to prove.

Claim 3 Let α be an update action. It holds that supp(V,U )(DB),η(α) = t if and only if there is some rule r with head(r) = α
(cid:14) (V,U )(DB) = t.  From  Claim  2  it  then  follows  that  this 
(cid:14) ∈ nup(r), l
(cid:14) ∈ nup(r) is  an  element  of  ext(V),  i.e.,  with  the  condition  that  α ∈

and  nup(r)(V,U )(DB) = t.  This  means  that  for  each  literal l
is  equivalent  with  the  condition  that  each  literal  l
closure(ext(V)).

Claim 4 Take α ∈ A and a set V of update actions. It holds that α ∈ Tη(V, U )1 if and only if one of the following holds:

(i) (V, U )(α) = t and supp(V,U )(DB),η(α D ) = f
(ii) (V, U )(α) = f and supp(V,U )(DB),η(α) = t
(iii) (V, U )(α) = u, supp(V,U )(DB),η(α) = t, and supp(V,U )(DB),η(α D ) = f.

In  the  ﬁrst  case,  α ∈ V ,  hence  α ∈ ext(V) and  α ∈ closure(ext(V)).  If  supp(V,U )(DB),η(α) = t (i.e.,  in  cases  ii  and  iii),  then 
by  Claim  3,  α ∈ closure(ext(V)).  Thus,  in  all  cases,  α ∈ closure(ext(V)).  Now,  since  U is  a  repair,  (U , U ) is  a  ﬁxpoint  of
Tη.  Since  (V, U ) ≤p (U , U ),  α ∈ Tη(V, U )1 entails  α ∈ Tη(U , U )1,  i.e.,  α ∈ U .  Thus,  α /∈ neffU (DB) and  we  ﬁnd  that  α ∈
closure(ext(V)) \ neffU (DB) = O (V), which we needed to prove. (cid:2)

Example 6.14. The converse of Proposition 6.13 does not hold. Consider the following set η of AICs.

¬a ⊃ +a
a ∧ ¬b ⊃ +b
a ∧ ¬b ⊃ −a

with DB = ∅. In this case {+a, +b} is a justiﬁed repair of (cid:10)D B, η(cid:11), but not a stable repair. To see that it is not a stable repair, 
it suﬃces to note that

Tη(∅, {+a, +b}) = (∅, {+a, +b})

and hence

lfp Tη(·, {+a, +b})1 = ∅ (cid:4)= {+a, +b}.

To see that it is a justiﬁed repair, note that {+a, +b} is the least set closed under η.

While the converse of Proposition 6.13 does not hold in general, for a broad class of active integrity constraints, it does 

hold. We ﬁrst deﬁne this class and then prove that this is indeed the case.

Deﬁnition 6.15. A set of AICs η is called unipolar if there are no rules r, r

(cid:14) ∈ η with head(r) = head(r

(cid:14))D .

Unipolar AICs make sense in practice, for example if there are tables from which removing data is never an option.

64

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

Proposition 6.16. If η is unipolar, then each justiﬁed repair of (cid:10)D B, η(cid:11) is Tη-stable.

Proof. To prove this theorem, we show the following strengthening of Claim 4 in the proof of Proposition 6.13.

Claim 4

(cid:14)

: For every set of update actions V ⊆ U :

Tη(V, U)1 = O (V).

(cid:14)

It then follows easily that U is a minimal ﬁxpoint of  O iff U is a minimal ﬁxpoint of Tη(·, U )1 and the result follows from
Claim 1 in the proof of Proposition 6.13 and the deﬁnition of Tη -stable ﬁxpoint.

Claim 4

One direction of this claim has been proven as Claim 4 in the proof of Proposition 6.13; we show that the other 
inclusion also holds. Take α ∈ A and a set V ⊆ U of update actions such that α ∈ O (V); we show that α ∈ Tη(V, U )1. Since 
α ∈ O (V), it holds that α ∈ closure(ext(V)) and thus (by Claim 3) that  supp(V,U )(DB),η(α) = t. This means that there is at 
(cid:14)) = α D hence, it holds 
least one rule r ∈ η with head(r) = α. Since η is unipolar, there can be no rules r
that  supp(V,U )(DB),η(aD ) = f.  From  the  deﬁnition  of  Tη,  we  then  ﬁnd  that  Tη(V, U )(α) = t and  thus  that  α ∈ Tη(V, U )1, 
which we needed to prove. (cid:2)

(cid:14) ∈ η with head(r

From  Proposition 3.7,  which  states  that  all  justiﬁed  repairs  are  grounded,  we  easily  ﬁnd  how  justiﬁed  repairs  and  the 

AFT-well-founded repair relate.

Corollary 6.17. The AFT-well-founded repair and the Kripke–Kleene repair approximate all justiﬁed repairs.

7.  Relationship with logic programming

Caroprese and Truszczy ´nski [13] deﬁned a translation from logic programs to AICs as follows.

Deﬁnition 7.1. Let r be a normal logic programming rule,

a ← l1 ∧ · · · ∧ ln.

We deﬁne the active integrity constraint aic(r) as

l1 ∧ . . . ∧ ln ∧ ¬a ⊃ +a.

Furthermore, if P is a normal logic program, we deﬁne

(cid:15)

aic(P) =

{aic(r) | r ∈ P}.

Caroprese  and  Truszczy ´nski  [13] showed  that  for simple programs P ,  an  interpretation  I is  a  stable  model  of  P if  and 
only  if  I (viewed  as  an  update  set)  is  a  justiﬁed  repair  of  (cid:10)aic(P), ∅(cid:11).  Since  aic(P) is  unipolar,  from  our  earlier  results 
(Propositions 6.13 and 6.16) it follows that this is also equivalent with the condition that  I is a Taic(P)-stable repair. The 
same result is also a corollary of the following stronger theorem.

Theorem 7.2. Let P be a simple normal logic program and I a partial interpretation. It holds that I is a partial stable model of P if 
and only if I is a partial stable repair of (cid:10)aic(P), ∅(cid:11).

The  proof  of  this  theorem  follows  later,  since  it  makes  use  of  Theorem 7.6.  Since  the  well-founded  model  of  a  logic 
program is the least precise partial stable model, and an analogous relationship holds in the setting of AICs, we immediately 
ﬁnd the following corollary.

Corollary  7.3.  Let  P be  a  normal  logic  program.  The  well-founded  model  of  P coincides  with  the  AFT-well-founded  repair  of 
(cid:10)aic(P), ∅(cid:11).

While the operation aic preserves (partial) stable, well-founded ﬁxpoints, it does not preserve grounded ﬁxpoints or the 
Kripke–Kleene ﬁxpoint (as the following two examples illustrate). In both cases, it is the intuition of inertia, present in AICs 
but not in logic programs, that is responsible for the difference.

Example 7.4. Consider the logic program

(cid:4)

(cid:7)

.

p ← ¬q
q ← p

Pg =

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

65

Since TPg has no ﬁxpoints, Pg has no grounded models. In this case,
(cid:7)

(cid:4)

aic(Pg) =

¬p ∧ ¬q ⊃ +p
p ∧ ¬q ⊃ +q

.

Now, (cid:10)aic(Pg), ∅(cid:11) has one grounded repair, namely {+p, +q}. (cid:2)

Example 7.5. Consider the logic program

Pkk = {b ← a} .

The Kripke–Kleene model of this program maps both a and b to f. The corresponding AIC

aic(Pkk) = {¬b ∧ a ⊃ +b}

has a Kripke–Kleene repair that maps a and b to u, i.e., it is unknown if these need to be changed. (cid:2)

It can be seen from the previous example that for AICs, the Kripke–Kleene semantics is very bad at deriving that some-
thing does not need to be changed. The well-founded semantics is much stronger with that respect. In a certain sense, one 
might say that the intuition of “inertia” underlying AICs lies at the foundation of this discrepancy. Now, in logic program-
ming, the Kripke–Kleene semantics exhibits similar behavior. Consider for instance the empty logic program

P∅ = {}.

This program has a Kripke–Kleene model in which each atom is false, as expected. However, adding a trivial rule

p ← p

that “simulates” inertia results in a program with a Kripke–Kleene model in which  p is unknown.

Inertia is also responsible for the discrepancy in Example 7.4. Intuitively, aic(Pg) from that example corresponds more 

to the logic program

⎧
⎪⎪⎨

⎪⎪⎩

p ← ¬q
p ← p
q ← p
q ← q

⎫
⎪⎪⎬

⎪⎪⎭

.

P (cid:14)
g

=

Indeed  aic(Pg) states  that  if  neither  p nor  q are  present  in  the  database,  add  p,  and  once  we  add  it,  by  inertia,  it  stays 
unless there is a reason to remove it again (which there is not), and similarly for q. P (cid:14)
and Pg only differ from each other 
in the rules  p ← p and q ← q, which simulate inertia.

The above discussion provides intuitions on what a transformation that preserves all AFT semantics should look like. In 

the following theorem, this is formalized.

Theorem 7.6. Suppose that DB = ∅ and that the only update actions in η are of the form +a. The mapping ua induces an isomorphism 
between the lattices 2At and 2

A)c . Let lp(η) denote the following logic program:

and between (2At)c and (2

A

lp(η) ={a ← nup(r) | r ∈ η, head(r) = +a}

∪ {a ← a | a ∈ At}

then for each partial interpretation I, Tη(ua(I)) = ua((cid:6)lp(η)(I)). Hence, all AFT semantics for (cid:10)D B, η(cid:11) coincide in this case with the 
equally-named semantics for the logic program lp(η).

Proof. By deﬁnition,

(cid:6)lp(η)(I)1 = {a ∈ At | body(r)I = t for some r ∈ lp(η) with head(r) = a}

= {a ∈ At | nup(r)I = t for some r ∈ η with head(r) = +a} ∪ {a ∈ At | a
= {lit(head(r)) | r ∈ η ∧ nup(r)I = t} ∪ {a ∈ At | a
= {lit(α) | suppI,η(α) = t} ∪ {a ∈ At | a

I = t}

I = t}

I = t}

Now, since, for each α ∈ A, it holds that suppI,η(α D ) = f (since there are no rules with α D in the head). From the deﬁnition 
of Tη, it then follows that

66

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

Tη(ua(I))1 = {α | suppI,η(α) = t or αua(I) = t},

i.e., that

Tη(ua(I))1 = ua((cid:6)lp(η)(I)1).

Similarly, we also ﬁnd that

Tη(ua(I))2 = ua((cid:6)lp(η)(I)2)

and the result follows. (cid:2)

Proof of Theorem 7.2. For each logic program P , let triv(P) denote the logic program

triv(P) = P ∪ {p ← p | p ∈ At}.

It is well-known6 that the partial stable models of P and those of triv(P) are the same. Now, the result easily follows from 
the facts that (i) if P is simple, then

lp(aic(P)) = triv(P)

since aic adds a literal ¬a to the body of each rule r with head(r) = a and lp removes such literal again (since P is simple, 
there  was  no  such  literal  at  the  start)  and  additionally,  adds  the  trivial  rules  triv adds,  and (ii) that  triv and  lp preserve 
partial stable models. (cid:2)

Example 7.7. Theorem 7.6 does not hold in general, not even for unipolar AICs. Consider for instance the following sets of 
AICs.

(cid:4)

(cid:7)

a ⊃ −a
b ⊃ −b

η1 =

η2 = ∅.

These two are not equivalent under all AFT semantics. For the ﬁrst one, the KK-repair is {+a (cid:21)→ f, +b (cid:21)→ f}, while for the 
latter, the KK-repair is {+a (cid:21)→ u, +b (cid:21)→ u}. However, they have the same translation to logic programs (since there are no 
rules with positive actions in the head). (cid:2)

The reason why the equivalence does not hold in the previous example is because rules with −a in the head are ignored, 

while in the context of AICs such rules can make a semantic difference.

Limitations and related work  In this Section, we studied mappings from sets of active integrity constraints to logic programs 
and back and how the semantics of the two formalisms relate. We brieﬂy discuss the restrictions of this approach. In our 
translation  of  AICs  to  logic  programs,  namely  in  Theorem 7.6,  we  assume  that  DB = ∅ and  that  the  only  update  actions 
that  occur  in  heads  of  rules  are  positive,  i.e.,  of  the  form  +a.  Since  all  our  semantics  satisfy  the  shifting  property,  the 
correspondence between the semantics still holds if DB is arbitrary but all actions in rule heads change DB. However, the 
condition that all actions in heads of rules change DB is essential, as illustrated by Example 7.7.

The translation Rew introduced by Caroprese et al. [12], on the other hand, is at ﬁrst sight more expressive than ours, as 
it applies to AICs with arbitrary actions on their head. In order to deal also with removal actions (in the case of an empty 
database), the authors are required to consider a logic program with an extended signature that includes two copies of the 
database  and  two  atoms  for  each  possible  update  action.  They  can  then  prove  a  precise  correspondence  between  stable 
models of logic programs and founded repairs for AICs – the only semantics that had been developed at that point in time.
However, their construction is very directly tailored to founded repairs, and it is not obvious that it can be adapted to AFT 
semantics. In order to capture inertia, the authors duplicate all database atoms, so that every model contains both a copy of 
the original database and a copy of the repaired database. Additional rules ensure that, in each model, the repaired database 
corresponds  exactly  to  the  result  of  applying  the  update  actions  also  included  in  that  model  to  the  original  database.  It 
can easily be seen that this mapping does not preserve AFT semantics for AICs. For instance, this technique maps founded 
repairs (which are not always grounded) to stable models (which are always grounded), hence, it certainly does not preserve 
grounded repairs. By contrast, the correspondence stated in Theorem 7.6 holds for all different semantics considered in the 
current work.

6 For completeness, we give the argument. Let I be an interpretation; from the deﬁnition of partial stable ﬁxpoint, it suﬃces to show that lfp((cid:6)P (·, I)1) =
lfp((cid:6)triv(P)(·, I)1) and that lfp((cid:6)P (I, ·)2) = lfp((cid:6)triv(P)(I, ·)2). Since we are working with symmetric operators, it suﬃces to prove the ﬁrst of the two 
equalities. Now, it is easy to see that (cid:6)triv(P)(·, I)1 is the inﬂationary operator of (cid:6)P (·, I)1, i.e., that (cid:6)triv(P)(·, I)1( J ) = (cid:6)P (·, I)1( J ) ∪ J . Hence, these two 
monotone operators have the same preﬁxpoints and thus also the same least preﬁxpoint, which equals their least preﬁxpoint.

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

67

Another  limitation  of  our  results  is  that  for  the  reverse  translation,  we  only  preserve  (partial)  stable  repairs  and  the 
AFT-well-founded repair (cf. Theorem 7.2). However, our discussion does highlight where the difference comes from, namely 
the intuition of inertia. That is, as shown in the proof of Theorem 7.2: for each simple normal logic program P , the semantics 
of triv(P) and aic(P) coincide.

Furthermore, we restrict our attention to normal programs; Caroprese and Truszczy ´nski [13] discuss this translation with-
out requiring normality. However, as mentioned before, we see non-normal AICs as syntactic sugar for their normalization 
and  hence  have  no  need  for  non-normal  logic  programs  either.  The  same  applies  to  the  translation  Rew from Caroprese 
et al. [12]. The restriction that our programs are simple is rather a technical requirement that simpliﬁes proofs. For several 
semantics, this is non-essential: for (partial) stable and well-founded semantics, each program can easily be translated into 
an equivalent simple program.

8.  Complexity analysis

We  begin  this  section  by  stating  an  observation  about  the  complexity  of  computing  Tη .  All  complexity  results  are  in 

terms of the size of the database, (cid:10)D B, η(cid:11).

Proposition 8.1. Given a partial action set U, Tη(U) is computable in polynomial time.

Proof. The deﬁnition of Tη only requires evaluating U(α), suppU(DB),η(α) and suppU(DB),η(α D ) for each α ∈ A. In turn, the 
two last computations can be done in polynomial time: they require evaluating each literal in the body of each rule from η
with head α or α D and computing its truth value under the database updated by U. (cid:2)

Proposition 8.2. Let DB be a database and η be a set of normal AICs over DB. The problem of deciding whether there exists a grounded 
repair for (cid:10)D B, η(cid:11) is (cid:7)P

2 -complete.

Proof. (Inclusion) We need to show that we can decide the problem with a non-deterministic Turing machine with an NP 
oracle. Given a set of update actions U , checking that it is a ﬁxpoint of Tη can be done in polynomial time on the size of 
DB and η, as shown in Proposition 8.1; the NP-oracle can then answer whether there exists U (cid:14) (cid:3) U with Tη(U (cid:14)) ∩ U ⊆ U (cid:14)
, 
thereby establishing whether U is grounded.

(Hardness) We show hardness directly by reducing another (cid:7)P

2 -hard problem to deciding whether a particular database 
with a set of AICs has a grounded repair. Our proof is a straightforward adaptation of Bogaerts et al. [7, Theorem 5.7], which 
in turn is inspired by Denecker et al. [22, Theorem 6.12].

Given a DNF formula ϕ over propositional symbols x1, . . . , xm, y1, . . . , yn, and an interpretation I of the xi , let ϕI denote 
the  formula  obtained  by  replacing  each  occurrence  of  xi with  either  t,  if  xi ∈ I ,  or  f,  otherwise.  The  problem  to  decide 
whether there exists an interpretation  I of the  xi such that ϕI is a tautology is (cid:7)P
2 hard. We now reduce this problem to 
our problem.

(cid:14)
We consider the empty database  DB over  At = {xi, x
i

negation  of  xi .  We  write  ϕ(cid:14)
deﬁned as follows, where we assume ϕ(cid:14) = ϕ(cid:14)
1

(cid:14)
for  the  formula  obtained  by  uniformly  replacing  ¬xi with  x
i
k and each ϕ(cid:14)

i is a conjunction of literals.

∨ . . . ∨ ϕ(cid:14)

(cid:14)
| 1 ≤ i ≤ m} ∪ {p, q, y1, . . . , yn}, where we use  x
i to represent the 
in  ϕ.  The  set  of  AICs  η(ϕ) is 

(cid:14)
⊃ +xi
¬xi ∧ ¬x
i
ϕ(cid:14)
∧ ¬ y j ⊃ + y j
i
¬p, ¬q ⊃ +q

(cid:14)
(cid:14)
¬xi ∧ ¬x
⊃ +x
i
i
ϕ(cid:14)
∧ ¬p ⊃ +p

i

¬p, q ⊃ −q

The following properties hold about η(ϕ).

for 1 ≤ i ≤ m

for 1 ≤ i ≤ k, 1 ≤ j ≤ n

(r21)

(r22)

(r23)

a. Each weak repair of (cid:10)η(ϕ), ∅(cid:11) contains +p (otherwise one of the rules r23 would apply).
b. No repair for (cid:10)η(ϕ), ∅(cid:11) contains +q (due to minimality).
c. In each grounded repair for (cid:10)η(ϕ), ∅(cid:11), at least one of the ϕ(cid:14)

result in a set of update actions where +p is no longer derivable, contradicting groundedness).

i is satisﬁed (otherwise, removing +p from that repair would 

d. Each grounded repair for (cid:10)η(ϕ), ∅(cid:11) contains all of the + y j (follows directly from the previous point).
(cid:14)
e. Each grounded repair for (cid:10)η(ϕ), ∅(cid:11) contains for each i, exactly one of +xi and +x
i (it must contain at least one due to 
(cid:14)
rules r21; the previous points guarantee that rules r22 and r23 are satisﬁed regardless of the xi and x
i in each grounded 
repair, hence minimality implies that it can contain at most one of these two actions).

Given an interpretation  I , we write ˇI to denote the set {+xi | xi ∈ I} ∪ {+x
(cid:14)
| xi /∈ I}. From observations a–e above, it follows 
i
that all grounded ﬁxpoints for (cid:10)η(ϕ), ∅(cid:11) must be of the form UI = ˇI ∪ {p, y1, . . . , yn} for some interpretation I of the xi . We 
now show that for each interpretation  I , UI is a grounded repair for (cid:10)η(ϕ), ∅(cid:11) iff ϕI is a tautology.

68

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

• First, assume that UI is a grounded repair of (cid:10)η(ϕ), ∅(cid:11). If  J ⊆ { y1, . . . , yn} is a falsifying assignment for ϕI , then Tη(ϕ)(ˇI ∪
{+ yi | yi ∈ J }) ∩ U = (ˇI ∪ {+ yi | yi ∈ J } ∪ {+q}) ∩ U = ˇI ∪ {+ yi | yi ∈ J }, contradicting the fact that U is a grounded repair 
for (cid:10)η(ϕ), ∅(cid:11). (Note that ˇI ∪ {+ yi | yi ∈ J } is always a strict subset of U , since it does not contain  p.) Therefore ϕI is a 
tautology.

• Suppose  on  the  other  hand  that  ϕI

is  a  tautology.  Let  V ⊆ U be  such  that  Tη(ϕ)(V) ∩ U ⊆ V .  If  +xi ∈ (U \ V) or 
∈ (U \ V) for some  i, then +xi ∈ Tη(ϕ)(V) by rules r21; therefore,  ˇI ⊆ V . But ϕI is a tautology, hence if + yi /∈ V , 
(cid:14)
+x
i
then the corresponding rule from r22 ensures that + yi ∈ Tη(ϕ)(V). Likewise, if +p /∈ V , then +p ∈ Tη(ϕ)(V). We thus 
conclude that V = U , whence U is a grounded repair for (cid:10)η(ϕ), ∅(cid:11). (cid:2)

Proposition 8.3. The Kripke–Kleene repair for (cid:10)D B, η(cid:11) is computable in polynomial time.

Proof. The Kripke–Kleene repair of (cid:10)D B, η(cid:11) can be computed by iterating Tη until a ﬁxpoint is reached. Since Tη is mono-
tonic,  the  maximum  number  of  iterations  is  the  size  of  At;  since  each  iteration  can  be  computed  in  polynomial  time 
(Proposition 8.1), so can this ﬁxpoint. (cid:2)

Proposition 8.4. The ATF-well-founded repair for (cid:10)D B, η(cid:11) is computable in polynomial time.

The proof makes use of the following proposition.

Proposition 8.5 ([23]). Let A be an approximator of O and (x, y) ∈ L2. Let S x
This operator is monotone. The smallest y

such that (x, y

(cid:14)

(cid:14)) is an unfoundedness reﬁnement of (x, y) is given by y

A be the operator on L that maps every y

(cid:14)
(cid:14) = lfp(S x

to A(x, y
A).

(cid:14))2. 

Proof of Proposition 8.4. To compute the Tη-well-founded ﬁxpoint, we can construct a well-founded induction with only 
strict  reﬁnements.  Since  such  a  well-founded  is  ≤p -increasing,  it  can  consist  of  at  most  of  |A| = |At| steps.  Computing  if 
there exists a strict application reﬁnement of a given partial repair set U can be done by computing Tη(U). Now, Propo-
sition 8.5 shows that the most precise unfoundedness reﬁnement can also be computed as the least ﬁxpoint of a derived 
operator  on  2
.  Such  a  ﬁxpoint  can  again  be  computed  in  polynomial  time.  Hence,  it  follows  that  we  can  compute  a 
terminal well-founded induction, and thus the well-founded ﬁxpoint, in polynomial time. (cid:2)

A

Proposition 8.6. The task of checking if a database (cid:10)D B, η(cid:11) has a stable repair is NP-complete.

Proof. (Inclusion) Given a candidate repair U , checking that it is stable can be done in polynomial time, as it amounts to 
verifying that it is a repair (two-valued) and that it is a least ﬁxpoint of the operators Tη(·, U )1 and Tη(U , ·)2. The latter 
can be done in polynomial time, as in the proof of Proposition 8.3.

(Hardness) For hardness, we again use the reduction from simple logic programs to AICs from Caroprese and Truszczy ´nski 
[13] given in Deﬁnition 7.1. This operator preserves stable semantics by Theorem 7.2, and therefore allows us to compute 
stable models of simple logic programs by ﬁrst translating them (in linear time) to sets of AICs. Since checking whether a 
logic program has a stable model is NP-complete [4,30], we conclude that checking whether a database has a stable repair 
must be NP-hard. Note that every logic program can be transformed in a simple logic program by removing the offending 
rules without changing its stable semantics. (cid:2)

What  we  notice  in  this  section  is  that  complexity  for  inference  tasks  related  to  our  semantics  is  always  the  same  as 
the  complexity  of  its  counterpart  in  (normal)  logic  programming.  This  illustrates  that  the  added  expressivity  (essentially, 
allowing AICs that are not unipolar) does not result in added complexity.

Contrary  to  the  original  work  introducing  AICs  [27],  our  deﬁnitions  do  not  include  ﬁrst-order  quantiﬁcations.  When 

allowing such a richer syntax, the results presented in this section can be re-used and constitute data-complexity results.

9.  Conclusion

In this paper, we deﬁned an approximator in the domain of active integrity constraints. The result is a family of semantics 
for AICs based on existing intuitions in various domains of non-monotonic reasoning. We studied properties of our induced 
semantics. In particular the AFT-well-founded semantics possesses desirable properties: it approximates all repairs of various 
families  (stable,  justiﬁed,  grounded)  and  hence  can  be  used  for  approximate  skeptical  query-answering  with  respect  to 
any of these semantics. Furthermore, the AFT-well-founded repair can be computed in time polynomial in the size of the 
database.

Our study is far from ﬁnished. In the context of approximation ﬁxpoint theory, ultimate approximators have been studied 
by  Denecker  et al.  [22].  They  showed  that  with  each  two-valued  operator,  we  can  associate  a  canonical  approximator. 
The  ultimate  approximator  induces  another  family  of  semantics  for  AICs.  In  other  domains,  e.g.,  in  logic  programming, 
semantics based on ultimate approximators have some very desirable properties, but in general come at the cost of a higher 

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

69

computational  complexity  than  their  “standard”  variants.  It  remains  to  be  researched  if  the  same  holds  in  the  context 
of  AICs.  In  this  paper,  we  showed  that  the  class  of  justiﬁed  repairs  is  situated  in  between  the  classes  of  stable  and  of 
grounded  repairs.  It  is  known  from  AFT  that  the  class  of  ultimate  stable  ﬁxpoints  also  falls  in  between  the  classes  of 
stable ﬁxpoints (for any approximator) and grounded ﬁxpoints. Hence, an interesting research question would be to verify 
if  justiﬁed  repairs  coincide  with  ultimate  stable  ﬁxpoints  in  this  domain,  and  if  not,  how  they  relate.  Another  topic  with 
potential for interesting future work is the notion of inconsistency. Consider for instance the set of AICs {¬a ⊃ +a, a ⊃ −a}; 
intuitively,  we  expect  a  semantic  operator  to  derive  an  inconsistency  from  any partial  action  set;  in  standard  AFT  this  is 
not  possible.  However,  extensions  of  AFT  that  accommodate  this  have  been  deﬁned  [3];  it  would  be  interesting  to  see 
how AICs ﬁt in this general theory. Another AFT-based topic of interest could be to study what safe inductions [9] yield in 
the  context  of  AICs  and  whether  they  can  ﬁx  problems  with  the  well-founded  semantics.  One  last  topic  on  which  more 
extensive research might be needed is the domain of revision programming [31]. Caroprese and Truszczy ´nski [13] showed 
structural correspondences between semantics for AICs and semantics for revision programs. Our paper now paves the way 
to applying AFT to revision programming as well.

Acknowledgements

Bart Bogaerts is a postdoctoral fellow of the Research Foundation – Flanders (FWO). Luís Cruz-Filipe was partially sup-

ported by the Danish Council for Independent Research Natural Sciences, grants DFF-1323-00247 and DFF-7014-00041.

References

[1] S. Abiteboul, Updates, a new frontier, in: M. Gyssens, J. Paredaens, D.V. Gucht (Eds.), Proceedings ICDT’88, 2nd International Conference on Database 

Theory, Bruges, Belgium, August 31–September 2, 1988, in: Lecture Notes in Computer Science, vol. 326, Springer, 1988, pp. 1–18.

[2] C. Antic, T. Eiter, M. Fink, Hex semantics via approximation ﬁxpoint theory, in: P. Cabalar, T.C. Son (Eds.), Proceedings Logic Programming and Nonmono-
tonic Reasoning, 12th International Conference, LPNMR 2013, Corunna, Spain, September 15–19, 2013, in: LNCS, vol. 8148, Springer, 2013, pp. 102–115.
[3] Y. Bi, J. You, Z. Feng, A generalization of approximation ﬁxpoint theory and application, in: R. Kontchakov, M. Mugnier (Eds.), Proceedings Web Rea-
soning and Rule Systems – 8th International Conference, RR 2014, Athens, Greece, September 15–17, 2014, in: Lecture Notes in Computer Science, 
vol. 8741, Springer, 2014, pp. 45–59.

[4] N. Bidoit, C. Froidevaux, Negation by default and unstratiﬁable logic programs, Theor. Comput. Sci. 78 (1) (1991) 86–112, https://doi.org/10.1016/

0304-3975(51)90004-7.

[5] B. Bogaerts, Groundedness in Logics with a Fixpoint Semantics, Ph.D. thesis, Department of Computer Science, KU Leuven, Jun. 2015, Marc Denecker

(supervisor), Joost Vennekens, Jan Van den Bussche (cosupervisors), https://lirias.kuleuven.be/handle/123456789/496543.

[6] B.  Bogaerts,  L.  Cruz-Filipe,  Semantics  for  active  integrity  constraints  using  approximation  ﬁxpoint  theory,  in:  [35],  pp.  866–872,  https://doi.org/

10.24963/ijcai.2017/120.

[7] B.  Bogaerts,  J.  Vennekens,  M.  Denecker,  Grounded  ﬁxpoints  and  their  applications  in  knowledge  representation,  Artif.  Intell.  224  (2015)  51–71, 

https://doi.org/10.1016/j.artint.2015.03.006.

[8] B.  Bogaerts,  J.  Vennekens,  M.  Denecker,  Partial  grounded  ﬁxpoints,  in:  Q.  Yang,  M.  Wooldridge  (Eds.),  Proceedings  of  the  Twenty-Fourth  In-
ternational  Joint  Conference  on  Artiﬁcial  Intelligence,  IJCAI  2015,  Buenos  Aires,  Argentina,  July  25–31,  2015,  AAAI  Press,  2015,  pp. 2784–2790, 
http://ijcai.org/papers15/Abstracts/IJCAI15-394.html.

[9] B. Bogaerts, J. Vennekens, M. Denecker, Safe inductions: an algebraic study, in: [35], pp. 859–865, https://doi.org/10.24963/ijcai.2017/119.
[10] B. Bogaerts, J. Vennekens, M. Denecker, J. Van den Bussche, FO(C): a knowledge representation language of causality, Theory Pract. Log. Program. 

14 (4–5-Online-Supplement) (2014) 60–69, https://lirias.kuleuven.be/handle/123456789/459436.

[11] G. Brewka, S. Woltran, Abstract dialectical frameworks, in: F. Lin, U. Sattler, M. Truszczy ´nski (Eds.), Principles of Knowledge Representation and Rea-
soning: Proceedings of the Twelfth International Conference, KR 2010, Toronto, Ontario, Canada, May 9–13, 2010, AAAI Press, 2010, pp. 102–111, 
http://aaai.org/ocs/index.php/KR/KR2010/paper/view/1294.

[12] L. Caroprese, S. Greco, C. Sirangelo, E. Zumpano, Declarative semantics of production rules for integrity maintenance, in: S. Etalle, M. Truszczy ´nski 
(Eds.), Proceedings Logic Programming, 22nd International Conference, ICLP 2006, Seattle, WA, USA, August 17–20, 2006, in: LNCS, vol. 4079, Springer, 
2006, pp. 26–40.

[13] L. Caroprese, M. Truszczy ´nski, Active integrity constraints and revision programming, Theory Pract. Log. Program. 11 (6) (2011) 905–952, https://

doi.org/10.1017/S1471068410000475.

[14] L. Cruz-Filipe, Optimizing computation of repairs from active integrity constraints, in: C. Beierle, C. Meghini (Eds.), Proceedings Foundations of Informa-
tion and Knowledge Systems – 8th International Symposium, FoIKS 2014, Bordeaux, France, March 3–7, 2014, in: Lecture Notes in Computer Science, 
vol. 8367, Springer, 2014, pp. 361–380.

[15] L. Cruz-Filipe, Grounded ﬁxpoints and active integrity constraints, in: M. Carro, A. King, M. De Vos, N. Saeedloei (Eds.), Technical Communications 
of the 32nd International Conference on Logic Programming, ICLP 2016 TCs, October 16–21, 2016, New York City, USA, in: OASIcs, vol. 52, Schloss 
Dagstuhl, Nov. 2016, pp. 1–14, chap. 11.

[16] L. Cruz-Filipe, M. Franz, A. Hakhverdyan, M. Ludovico, I. Nunes, P. Schneider-Kamp, repAIrC: a tool for ensuring data consistency, in: A.L.N. Fred, J.L.G. 
Dietz, D. Aveiro, K. Liu, J. Filipe (Eds.), KMIS 2015 – Proceedings of the International Conference on Knowledge Management and Information Sharing, 
Part of the 7th International Joint Conference on Knowledge Discovery, Knowledge Engineering and Knowledge Management (IC3K 2015), vol. 3, Lisbon, 
Portugal, November 12–14, 2015, SciTePress, 2015, pp. 17–26.

[17] L. Cruz-Filipe, G. Gaspar, P. Engrácia, I. Nunes, Computing repairs from active integrity constraints, in: Seventh International Symposium on Theoretical 

Aspects of Software Engineering, TASE 2013, Birmingham, UK, 1–3 July 2013, IEEE Computer Society, 2013, pp. 183–190.

[18] L. Cruz-Filipe, G. Gaspar, I. Nunes, P. Schneider-Kamp, Active integrity constraints for multi-context systems, in: E. Blomqvist, P. Ciancarini, F. Poggi, F. 
Vitali (Eds.), Proceedings Knowledge Engineering and Knowledge Management – 20th International Conference, EKAW 2016, Bologna, Italy, November 
19–23, 2016, in: Lecture Notes in Computer Science, vol. 10024, 2016, pp. 98–112.

[19] M. Denecker, M. Bruynooghe, J. Vennekens, Approximation ﬁxpoint theory and the semantics of logic and answers set programs, in: E. Erdem, J. Lee, 

Y. Lierler, D. Pearce (Eds.), Correct Reasoning, in: LNCS, vol. 7265, Springer, 2012, pp. 178–194.

[20] M. Denecker, V. Marek, M. Truszczy ´nski, Approximations, stable operators, well-founded ﬁxpoints and applications in nonmonotonic reasoning, in: 
J. Minker (Ed.), Logic-Based Artiﬁcial Intelligence, in: The Springer International Series in Engineering and Computer Science, vol. 597, Springer, US, 
2000, pp. 127–144.

70

B. Bogaerts, L. Cruz-Filipe / Artiﬁcial Intelligence 255 (2018) 43–70

[21] M.  Denecker,  V.  Marek,  M.  Truszczy ´nski,  Uniform  semantic  treatment  of  default  and  autoepistemic  logics,  Artif.  Intell.  143 (1)  (2003)  79–122, 

https://doi.org/10.1016/S0004-3702(02)00293-X.

[22] M. Denecker, V. Marek, M. Truszczy ´nski, Ultimate approximation and its application in nonmonotonic knowledge representation systems, Inf. Comput. 

192 (1) (Jul. 2004) 84–121, https://lirias.kuleuven.be/handle/123456789/124562.

[23] M. Denecker, J. Vennekens, Well-founded semantics and the algebraic theory of non-monotone inductive deﬁnitions, in: C. Baral, G. Brewka, J.S. Schlipf 

(Eds.), LPNMR, in: Lecture Notes in Computer Science, vol. 4483, Springer, 2007, pp. 84–96.

[24] P.M. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games, Artif. 

Intell. 77 (2) (1995) 321–357, https://doi.org/10.1016/0004-3702(94)00041-X.

[25] T. Eiter, G. Gottlob, On the complexity of propositional knowledge base revision, updates, and counterfactuals, Artif. Intell. 57 (2–3) (1992) 227–270, 

https://doi.org/10.1016/0004-3702(92)90018-S.

[26] M.  Fitting,  Fixpoint  semantics  for  logic  programming  —  a  survey,  Theor.  Comput.  Sci.  278 (1–2)  (2002)  25–51,  https://doi.org/10.1016/S0304-

3975(00)00330-3.

[27] S. Flesca, S. Greco, E. Zumpano, Active integrity constraints, in: E. Moggi, D.S. Warren (Eds.), Proceedings of the 6th International ACM SIGPLAN 

Conference on Principles and Practice of Declarative Programming, 24–26 August 2004, Verona, Italy, ACM, 2004, pp. 98–107.

[28] M.  Gelfond,  V.  Lifschitz,  The  stable  model  semantics  for  logic  programming,  in:  R.A.  Kowalski,  K.A.  Bowen  (Eds.),  ICLP/SLP,  MIT  Press,  1988, 

pp. 1070–1080, http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.6050.

[29] S.C. Kleene, On notation for ordinal numbers, J. Symb. Log. 3 (4) (1938) 150–155, http://www.jstor.org/stable/2267778.
[30] V. Marek, M. Truszczy ´nski, Autoepistemic logic, J. ACM 38 (3) (1991) 588–619, https://doi.org/10.1145/116825.116836.
[31] V.W. Marek, M. Truszczynski, Revision programming, Theor. Comput. Sci. 190 (2) (1998) 241–277, https://doi.org/10.1016/S0304-3975(97)00092-3.
[32] R.C. Moore, Semantical considerations on nonmonotonic logic, Artif. Intell. 25 (1) (1985) 75–94, https://doi.org/10.1016/0004-3702(85)90042-6.
[33] T.C.  Przymusinski,  H.  Turner,  Update  by  means  of  inference  rules,  J.  Log.  Program.  30 (2)  (1997)  125–143,  https://doi.org/10.1016/S0743-

1066(96)00091-X.

[34] R. Reiter, A logic for default reasoning, Artif. Intell. 13 (1–2) (1980) 81–132, https://doi.org/10.1016/0004-3702(80)90014-4.
[35] C. Sierra (Ed.), Proceedings of the Twenty-Sixth International Joint Conference on Artiﬁcial Intelligence, IJCAI 2017, Melbourne, Australia, August 19–25, 

2017, ijcai.org, 2017, http://www.ijcai.org/Proceedings/2017/.

[36] H.  Strass,  Approximating  operators  and  semantics  for  abstract  dialectical  frameworks,  Artif.  Intell.  205  (2013)  39–70,  https://doi.org/10.1016/

j.artint.2013.09.004.

[37] H. Strass, J.P. Wallner, Analyzing the computational complexity of abstract dialectical frameworks via approximation ﬁxpoint theory, in: C. Baral, G. 
De Giacomo, T. Eiter (Eds.), Principles of Knowledge Representation and Reasoning: Proceedings of the Fourteenth International Conference, KR 2014, 
Vienna, Austria, July 20–24, 2014, AAAI Press, 2014, pp. 101–110, http://www.aaai.org/ocs/index.php/KR/KR14/paper/view/7917.

[38] E.  Teniente,  A.  Olivé,  Updating  knowledge  bases  while  maintaining  their  consistency,  VLDB  J.  4 (2)  (1995)  193–241,  http://www.vldb.org/

journal/VLDBJ4/P193.pdf.

[39] M.H. van Emden, R.A. Kowalski, The semantics of predicate logic as a programming language, J. ACM 23 (4) (1976) 733–742, https://doi.org/10.1145/

321978.321991.

[40] A. Van Gelder, K.A. Ross, J.S. Schlipf, The well-founded semantics for general logic programs, J. ACM 38 (3) (1991) 620–650, https://doi.org/10.1145/

[41] J. Vennekens, D. Gilis, M. Denecker, Splitting an operator: algebraic modularity results for logics with ﬁxpoint semantics, ACM Trans. Comput. Log. 7 (4) 

116825.116838.

(2006) 765–797, https://doi.org/10.1145/1182613.1189735.

[42] J. Vennekens, M. Mariën, J. Wittocx, M. Denecker, Predicate introduction for logics with a ﬁxpoint semantics. Part I: logic programming, Fundam. 

Inform. 79 (1–2) (September 2007) 187–208, https://lirias.kuleuven.be/handle/123456789/266021.

[43] J. Vennekens, M. Mariën, J. Wittocx, M. Denecker, Predicate introduction for logics with a ﬁxpoint semantics. Part II: autoepistemic logic, Fundam. 

Inform. 79 (1–2) (September 2007) 209–227, https://lirias.kuleuven.be/handle/123456789/146591.

[44] J. Widom, S. Ceri (Eds.), Active Database Systems: Triggers and Rules for Advanced Database Processing, Morgan Kaufmann, 1996.
[45] M. Winslett, Updating Logical Databases, Cambridge Tracts in Theoretical Computer Science, Cambridge University Press, 1990.

