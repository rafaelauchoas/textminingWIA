Artiﬁcial Intelligence 173 (2009) 982–1013

Contents lists available at ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Quantiﬁed epistemic logics for reasoning about knowledge
in multi-agent systems
F. Belardinelli a, A. Lomuscio b,∗

a Scuola Normale Superiore, Pisa, Italy
b Department of Computing, Imperial College London, UK

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 23 April 2008
Received in revised form 17 December 2008
Accepted 17 February 2009
Available online 24 February 2009

Keywords:
Knowledge representation and Logic:
knowledge representation, distributed
knowledge
Mathematical Logic: ﬁrst-order modal logic,
epistemic logic
Multi-agent systems: distributed systems,
message passing systems

We introduce quantiﬁed interpreted systems, a semantics to reason about knowledge in
multi-agent systems in a ﬁrst-order setting. Quantiﬁed interpreted systems may be used to
interpret a variety of ﬁrst-order modal epistemic languages with global and local terms,
quantiﬁers, and individual and distributed knowledge operators for the agents in the
system. We deﬁne ﬁrst-order modal axiomatisations for different settings, and show that
they are sound and complete with respect to the corresponding semantical classes.
The expressibility potential of the formalism is explored by analysing two MAS scenarios:
an inﬁnite version of the muddy children problem, a typical epistemic puzzle, and a version
of the battleﬁeld game. Furthermore, we apply the theoretical results here presented to
the analysis of message passing systems [R. Fagin, J. Halpern, Y. Moses, M. Vardi, Reasoning
about Knowledge, MIT Press, 1995; L. Lamport, Time, clocks, and the ordering of events in
a distributed system, Communication of the ACM 21 (7) (1978) 558–565], and compare
the results obtained to their propositional counterparts. By doing so we ﬁnd that key
known meta-theorems of the propositional case can be expressed as validities on the
corresponding class of quantiﬁed interpreted systems.

© 2009 Elsevier B.V. All rights reserved.

1. Introduction

Modal logics for reasoning about knowledge, or modal epistemic logics, have been widely studied in the artiﬁcial intel-
ligence community for several years. The interest in this area is directed both towards fundamental theoretical research,
covering topics such as axiomatisability, completeness, decidability, and complexity of these formalisms [3–5], as well as to
the application of modal epistemic languages to the speciﬁcation and veriﬁcation of multi-agent systems [20,53,64].

The typical epistemic language extends propositional logic by adding n modalities K i representing the knowledge of
agent i in a group A = {1, . . . , n} of agents. The use of these formalisms as speciﬁcation languages is nowadays so main-
stream as to require little justiﬁcation: these are rather expressive languages, well-understood from a theoretical point of
view [14,49].

For expressiveness purposes epistemic logic has been extended in several directions. In one line of research modalities for
distributed and common knowledge have been added to the basic formalism [14,15]. In another one, the epistemic language
has been enriched with temporal operators under the assumption of a given model of time, e.g., linear or branching, discrete
or continuous [29,48,70]. In yet another direction, epistemic logic has been studied at the predicate level [36,43,51], thus
allowing for richer speciﬁcations.

* Corresponding author.

E-mail addresses: f.belardinelli@sns.it (F. Belardinelli), A.Lomuscio@imperial.ac.uk (A. Lomuscio).

0004-3702/$ – see front matter © 2009 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2009.02.003

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

983

This paper takes inspiration from this last line of research, and is intended to contribute to the subject of ﬁrst-order
epistemic logic for the speciﬁcation of multi-agent systems (MAS). Speciﬁcally, we provide ﬁrst-order epistemic languages
with a computationally grounded semantics [65] given in terms of quantiﬁed interpreted systems (QIS). We believe that QIS
are a natural extension to ﬁrst-order of interpreted systems, the typical semantical framework for epistemic logics in MAS
[14,53]. Further, we analyse from an epistemic perspective the theoretical implications of different ﬁrst-order extensions:
quantiﬁcation domains indexed to agents and to computational states, domains of intensional objects, etc. One of the main
results of this paper consists in showing that all the semantical classes introduced are ﬁnitely axiomatisable. This is ob-
tained by adapting standard techniques in quantiﬁed modal logic [1,16,19,30] to the epistemic frameworks here analysed.
We also show that the techniques in [15] for proving completeness of epistemic languages with distributed knowledge can
be extended to ﬁrst-order. Finally, the formalisms presented allow to study in a ﬁrst-order setting message passing sys-
tems, a typical framework in distributed systems [38,52], revealing that meta-theorems on message passing systems can be
expressed as validities in the corresponding class of quantiﬁed interpreted systems.

1.1. First-order epistemic logic in knowledge representation

Although quantiﬁed modal logic (QML) has a reputation for being a source of incompleteness [10,19,57], quantiﬁcation
is an expressive feature that has often been considered in the literature on knowledge representation and AI. For instance,
when specifying the behaviour of MAS, quantiﬁcation is so natural and convenient that one feels compelled to bring it
explicitly into the syntax. As it is maintained in [39]:

“the power of FOL [ﬁrst-order logic] is used not so much to deal with inﬁnities but to deal with incomplete knowledge.” ([39], p. 81)

Moreover, in knowledge representation the power of ﬁrst-order logic is welcome every time agents reason about:

• relational statements, as in “agent i knows that message μ was sent by agent a to agent b”, or formally,

K iSent(a, b, μ)

• functional dependencies and identity, as in “agent i knows that message μ is the encryption of message μ(cid:3)

with key k”,

or formally,

K i(μ = enc(k, μ(cid:3)

))

• inﬁnite domains of individuals, or ﬁnite domains whose cardinality cannot be bounded in advance: “agent i has to read any

e-mail before deleting it”,

∀μ(Delete(i, μ) → Read(i, μ))

• quantiﬁcation on agents: “the child of any process knows who launched it”

∀i Kchild(i)Launched(i, child(i))

Furthermore, in the context of logics for knowledge it is well known that epistemic modalities can be combined with
quantiﬁers to formalise de re/de dicto knowledge [16,30], expressing concepts not expressible at the propositional level. For
instance, agent i might know that every computation produces an output, thus having the de dicto knowledge expressed in
the following speciﬁcation:

∀comp K i ∃ y Output(comp, y)

but he might not know the actual output of every computation. Therefore, the following de re speciﬁcation would not be
satisﬁed:

∀comp ∃ y K i Output(comp, y)

However, the use of ﬁrst-order modal logic in MAS speciﬁcations is sometimes frowned upon: why should we use an
undecidable language when a decidable one does the job reasonably well already? Is the price that quantiﬁcation brings in
justiﬁed? While these objections are certainly sensible, we believe that their strength has been increasingly weakened by
recent progress in MAS veriﬁcation by model checking [13,18,44,54] and advances in the theory of QML.

In the model checking approach [6,31,47] the decision problem is tackled not by checking validity, but simply by con-
sidering model satisfaction. In other words, we do not check whether a formula representing a speciﬁcation is satisﬁable in
some model, but whether it is true on the model representing all possible evolutions of a given system. While the former
problem is undecidable for QML, the latter might be decidable at least for many interesting fragments, further investigations
being required.

In addition, recent contributions on axiomatisability [58,63] and decidability [25,27,62] of quantiﬁed modal logic, includ-
ing both positive [11,23,24,56] and negative results [12,26,59,61] have shown that useful QML fragments are axiomatisable
and even decidable, raising hopes that some quantiﬁed MAS logic may also be axiomatisable and decidable.

984

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

Our motivation for the present contribution comes from an interest in reasoning about multi-agent systems, whose high-
level properties may usefully be modelled by epistemic formalisms suitably extended to predicate logic. Before turning to
the formal machinery, we review the main approaches to ﬁrst-order epistemic formalisms in knowledge representation and
artiﬁcial intelligence.

1.2. State of the art

The study of epistemic logic in a ﬁrst-order setting has a long and established tradition in AI. Among the early con-
tributions we highlight [17,22], where some semantical and philosophical issues about identity in epistemic contexts are
explored. More recent works focus on the computational and planning abilities of agents [39,50], where ﬁrst-order epis-
temic logic (FOEL) is used as a speciﬁcation language for agents. In [51] a theory of action is presented, which takes into
account the knowledge prerequisites to action and the effects of action on knowledge.

First-order logic has also been extensively applied to the deductive machinery of knowledge bases. In [36,37] a logic of
belief on a decidable form of ﬁrst-order entailment is presented, and in [41,42] these investigations are further pursued by
considering restricted forms of ﬁrst-order doxastic logic. FOEL is also brieﬂy discussed in classic textbooks [14,49], along
with its Kripke semantics and some signiﬁcant validities, even though there is no attempt to extend interpreted systems
to ﬁrst-order, nor completeness issues are tackled. Also, [32,33] introduces applications of FOEL to game theory, while [2,7]
discusses epistemic formalisms in the context of security protocol. In an orthogonal dimension to the above, [21] presents
an analysis of common knowledge in multi-agent systems with inﬁnitely many agents.

First-order epistemic logics for MAS speciﬁcation are used in [67–69], where they are studied mostly in relation to the
MAPLE programming language for agents. In [67] the quantiﬁed epistemic temporal logic QUETL is presented in order to
develop a veriﬁcation methodology for multi-agent systems. First-order logic appears as the base of a number of other agent
theories, such as BDI logics [55], the KQML framework [8], and the LORA framework [66], together with modalities for
mental attitudes (knowledge, belief, intention, desire), as well as temporal and dynamic operators. However, most of the
current literature on agent theories have so far fallen short of a systematic analysis of the formal machinery underlying
these frameworks. Often the theoretical properties (axiomatisability, decidability, complexity) of these MAS formalisms are
not the main focus of these investigations. Indeed, certain frameworks are so rich that it is extremely unlikely to devise any
ﬁnite axiomatisation. Still, these references are relevant for the present investigations as they are among the few to have
explicitly addressed the subject of ﬁrst-order modal languages in a MAS setting.

From a purely theoretical perspective, quantiﬁed modal logic has received much attention with a wealth of contributions
on axiomatisability [11,58,63], decidability [12,25,62], and complexity [24,27] of fragments of QML. In [62] the monodic
fragment of quantiﬁed modal logic, where at most one free variable appears in the scope of modal operators, is introduced,
and decidability of various subfragments is proved. In [23,25] similar results are obtained for monodic fragments of ﬁrst-
order temporal logic, while the complexity of some of these formalisms is analysed in [24,27]. Further, [63] provides a
complete axiomatisation of monodic ﬁrst-order validities on the natural numbers. Also the monodic fragment of FOEL has
been explored. In [61] monodic ﬁst-order epistemic logic with common knowledge is proved to be decidable, and in [58,59]
this fragment is axiomatised.

The lines of work above constitute the theoretical and applied background against which this research is set.

1.3. The present contribution

This paper extends the current state of the art in ﬁrst-order epistemic logic by introducing a family of provably complete
ﬁrst-order epistemic logics with global and local terms. While the denotation of the former is rigid, i.e., it is the same
in every computational state, the latter’s depends on the state in which these expressions are interpreted. The quantiﬁed
epistemic languages here introduced are non-trivial extensions of the propositional modal languages in [16,30]. The use
of ﬂexible terms is inspired by [19], which also presents a completeness proof for such languages. The relevance of the
distinction between global and local terms has since long been recognised, see, e.g., [16,46].

From a semantical viewpoint the key contribution of the paper is the extension of interpreted systems to ﬁrst-order,
obtained by endowing these structures with quantiﬁcation domains. In quantiﬁed interpreted systems we allow each agent
to reason about a possibly different set of objects. This choice is motivated by the fact that, as agents are autonomous, they
may be aware of only a subset of all existing individuals, possibly different from those of other agents. We do not aim
to provide a theory of awareness about agents’ knowledge, but simply observe that most universally quantiﬁed statements
referring to an agent i, such as “all boxes are red”, are really universal only if i is assumed to consider a proper subset of
the domain of all possible individuals: the set of boxes considered by i. Interpreted systems are the typical formalism for
epistemic logic in MAS [20,53], but to our knowledge there has been no attempt to extend these structures to ﬁrst-order,
even in references such as [14] where FOEL and interpreted systems are explicitly considered. We deem this extension
potentially of note as these structures represent a computationally grounded semantics in the sense of [65], suitable for the
deﬁnition of protocols and programs for agents, and for the development of model checking techniques.

Furthermore, provably sound and complete axiomatisations are presented for all classes of QIS here considered. The com-
pleteness proofs make use of standard techniques in QML [9,60] suitably extended to deal with the semantical framework
of quantiﬁed interpreted systems and a richer language with local terms, indexed quantiﬁers, and distributed knowledge.

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

985

The completeness proof for FOEL with distributed knowledge extends to ﬁrst-order the techniques in [15]. Note that an
independent completeness proof for these propositional languages appeared in [28].

Finally, we apply the formal machinery to the analysis of MAS scenarios. The muddy children puzzle and message passing
systems belong to the folklore of AI and distributed systems [14,38], but their ﬁrst-order formalisations here provided are
original.

Scheme of the paper. In Section 2 we present two classes of ﬁrst-order structures: systems of global states and Kripke
frames, as well as several subclasses of these. In Section 3 we introduce a group of ﬁrst-order modal languages, which
are interpreted on quantiﬁed interpreted systems, a valued version of systems of global states. In Section 4 we introduce
a class of ﬁrst-order modal axiomatisations, and prove their soundness and completeness with respect to the structures in
Section 2. In Section 5 we exemplify the use of the syntax and semantics by describing some formal models for multi-agent
systems and discuss some speciﬁcation patterns. Section 6 is devoted to the analysis of message passing systems. Finally,
Section 7 presents related work and draws some conclusions.

2. Systems of global states and Kripke frames

In this section we introduce systems of global states and Kripke frames in a ﬁrst-order setting. While the ﬁrst ones are
used in computer science to model the behaviour of MAS [14,20,49,53], Kripke frames are typically employed to acquire a
deeper understanding of the formal properties of these systems [3–5].

Technically, we extend the corresponding propositional structures to ﬁrst-order by considering a distinct domain of quan-
tiﬁcation for each agent. This choice is motivated by the fact that, as agents are autonomous, they might consider distinct
domains of individuals. Then we deﬁne two maps between these classes of structures, and prove that the composition of
these maps is an isomorphism. These results will be used for translating the completeness results from Kripke semantics to
systems of global states. In what follows we assume a set of agents A = {1, . . . , n}.

2.1. Systems of global states

This paper is primarily concerned with the representation of knowledge in MAS, not their temporal evolution. Given this,
we adopt the “static” perspective on the systems of global states [45], rather than their “dynamic” version [14]. So, while
we assume that the states of the system result from the evolution given by protocols and transitions, we do not consider
(cid:3)
i, . . . , for each agent i ∈ A, and a set Le containing the
these explicitly. More formally, consider a set Li of local states li, l
local states of the environment le, l

(cid:3)
e, . . . . We deﬁne a system of global states as follows:

Deﬁnition 1 (Systems of global states). A system of global states, or SGS, is a tuple S = (cid:8)S, D, {D i}i∈ A, F , {F i}i∈ A(cid:9) such that
S ⊆ Le × L1 × · · · × Ln is a non-empty set of global states; D is a non-empty set of individuals, and for i ∈ A, D i is a subset
of D; F ⊆ { f | f : S → D} is a non-empty set of functions from S to D, and for i ∈ A, F i is a subset of F .

We denote the class of all systems of global states as SGS.

Intuitively, S is the set of possible conﬁgurations of the system corresponding to the set of reachable states obtained by
considering the temporal evolution of the system. Given that we do not consider the temporal dimension, we simply take
S as a subset of the set of all possible states.

(cid:3)

(cid:3)

(cid:3)

.

The domain D contains the individuals for interpreting global terms, and F is the interpretation domain for local terms.
We assign a ﬁxed meaning to global terms like “π ” by including the corresponding real number in the domain D of
individuals. On the contrary, expressions such as “the value stored in the register”, which identiﬁes possibly different values
respectively, will be modelled as a function f ∈ F , also called intensional object,
a and a
such that f (s) = a and f (s

at different global states s and s

(cid:3)) = a

In systems of global states we have possibly different quantiﬁcation domains D i and F i for each agent i ∈ A. This
feature is motivated by the fact that, as each agent i is autonomous and may have only a partial view of the surrounding
environment, she could have access only to subsets D i and F i of the domains D and F of individuals, possibly different
from the domains D j and F j of another agent j.

Note that in general D i and F i are independent from global states, i.e., for s, s

(cid:3) ∈ S, the domains D i and F i of agent i in s
are the same as the domains D i and F i in s
. This means that individuals neither appear nor disappear during the evolution
of the system. We deem this assumption consistent with the external account of knowledge usually adopted in the framework
of epistemic logic. In this line of research knowledge is ascribed to agents by an external observer (in our case the system
speciﬁer), rather than explicitly possessed by them. This means that a formula like K i∀i yφ does not express that agent i
explicitly knows that all y are φ, i.e., that ∀i yφ is the case. Instead, it suﬃces that for every y, i knows that φ is the case,
i.e., ∀i y K iφ. In other words, agent i needs not to be aware of all the individuals in his domain of quantiﬁcation. In this
respect the individuals in D i and F i can be thought of as persisting in the various global states from the viewpoint of the
external observer.

(cid:3)

In the next section we consider various classes of systems of global states.

986

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

2.2. Further systems of global states

We remarked that in systems of global states individuals neither appear nor disappear. A different scenario we may wish
to consider consists of quantiﬁcation domains changing at run-time. For this purpose we introduce varying systems of global
states:

Deﬁnition 2 (Varying SGS). A varying system of global states, or varying SGS, is a tuple S = (cid:8)S, D, {D i}i∈ A, F , {F i}i∈ A(cid:9) such
(cid:3) |
that S, D, and F are deﬁned as in Deﬁnition 1, and for each i ∈ A, D i is a function from S to the power set ℘ (D) = {D
D

(cid:3) ⊆ D}, and F i is a function from S to the power set ℘ (F ) = {F
We denote the class of all varying systems of global states as SGS var.

(cid:3) ⊆ F }.

(cid:3) | F

(cid:3)

In a varying SGS the domains of quantiﬁcation depend not only on the agent, but also on her computational state, that
(cid:3))).
is, for s (cid:11)= s
Therefore, varying SGS are useful to model systems in which individuals might appear and disappear during the system
runs.

, the quantiﬁcation domain D i(s) (respectively F i(s)) can possibly be different from D i(s

(cid:3)) (respectively F i(s

Observe that the domains D i(s) and F i(s) do not contribute to the deﬁnition of the local state of agent i in a state s. This
(cid:3)). The quantiﬁcation
implies that there can be states s and s
domains of i depend also on the local states of the other agents. While it is instructive to look at this general setting, it
is also of interest to consider the case where the same quantiﬁcation domain is available to one agent when she is in the
same local state. Thus, we introduce regular systems of global states:

(cid:3)), and yet D i(s) (cid:11)= D i(s

such that li(s) = li(s

(cid:3)) or F i(s) (cid:11)= F i(s

(cid:3)

Deﬁnition 3 (Regular SGS). A regular system of global states, or regular SGS, is a varying SGS such that:

for all s, s

(cid:3) ∈ S, li(s) = li(s

) and F i(s) = F i(s
We denote the class of all regular systems of global states as SGS reg .

) implies D i(s) = D i(s

(cid:3)

(cid:3)

(cid:3)

)

(1)

In other words, in regular SGS the quantiﬁcation domains of agent i are part of her local state.
Further, note that in a system of global states the individuals in D can be seen as constant functions from S to D itself,
i.e., for every a ∈ D consider the function a : S → D returning a for every s ∈ S. Hence, we can take D itself as the domain
F of intensional objects, thus obtaining a peculiar class of systems of global states:

Deﬁnition 4 (Objectual SGS). An objectual system of global states, or objectual SGS, is an SGS S = (cid:8)S, D, {D i}i∈ A, F , {F i}i∈ A(cid:9)
such that D = F , and for i ∈ A, D i = F i .

We denote the class of all objectual SGS as SGSobj .

Objectual SGS, which can be seen as triples S = (cid:8)S, D, {D i}i∈ A(cid:9), are particular instances of SGS, easier to handle and yet
suitable for modelling useful applications, as we will show in Section 5. In fact, objectual SGS are suﬃcient for interpreting
ﬁrst-order epistemic languages with global terms only, the typical formalism for quantiﬁed modal logic [16,19,30]. Thus, the
present semantical framework encompasses many of the formal accounts available in the literature on QML.

For the present investigations it is of particular interest to explore the relationship among individuals in the various D i
and F i , for i ∈ A. In general system of global states the domain F i can be any set of function from S to D, but we may ﬁnd
convenient to deﬁne some constraints on the functions in F i .

In the rest of the paper we will consider the following constraints:

for all s, s

(cid:3)

(cid:3) ∈ S, li(s) = li(s
(cid:3) ∈ S, f ∈ F i, li(s) = li(s

) and f (s) ∈ D i implies f (s

) ∈ D i
) and f (s) ∈ D i implies f (s

(cid:3)

(cid:3)

(cid:3)

) ∈ D i

for all s, s
for all s ∈ S, f ∈ F i, f (s) ∈ D i

for all s, s

for all s, s

(cid:3) ∈ S, f ∈ F i and li(s) = li(s
(cid:3) ∈ S, f ∈ F i and li(s) = li(s

(cid:3)

(cid:3)

) implies f (s) = f (s

) implies f (s) = f (s

(cid:3)

(cid:3)

)
) ∈ D i

(2)

(3)

(4)

(5)

(6)

Intuitively, formula (2) expresses the fact that if the intensional object f chooses an existing individual at global state s,
then agent i knows this fact. Formula (3) restricts formula (2) to the intensional objects in the domain F i , while formula
(4) is a strengthening of (3) urging that F i is a set of functions with domain S and codomain D i ⊆ D. Further, by formula
(5) the functions in F i have as domain the set Li of agent i’s local state, while formula (6) is the conjunction of (4) and (5),
and it implies that the functions in F i have domain Li and codomain D i .

Given the above, we introduce ﬁve further classes of systems of global states.

Deﬁnition 5. For every k, 2 (cid:2) k (cid:2) 6, SGSk ⊆ SGS is the class of the system of global states satisfying formula (k).

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

987

In Section 4 we will prove that the results available for the systems of global states in SGS, notably the soundness and
completeness theorems, also apply to the other classes of SGS with minor changes. The following table summarises the
classes of SGS we will analyse in the rest of the paper, for 2 (cid:2) k (cid:2) 6.

Systems of global states

SGS
SGS var
SGS obj
SGS reg
SGSk

all
varying
objectual
regular
SGS in SGS satisfying formula (k)

Finally, note that we allow for the possibility that A ⊆ D. This implies that agents can reason about themselves, their prop-
erties, and relationships: some examples of the expressiveness possibilities of the present formalism are given in Section 3.2.

2.3. Kripke frames

While Kripke frames are less intuitive than interpreted systems to model MAS, they are more convenient for the pur-
pose of formal analysis, notably completeness investigations. As customarily in epistemic logic, we work with frames with
equivalence relations ∼i , that is, for a non-empty set W ,

for every w in W ,
for every w, w
for every w, w

in W ,
(cid:3)(cid:3)
, w

(cid:3)

(cid:3)

w ∼i w
w ∼i w
in W , w ∼i w

(cid:3)

(cid:3)

implies w
and w

(cid:3) ∼i w

(cid:3) ∼i w
(cid:3)(cid:3)

implies w ∼i w

reﬂexivity
symmetry
transitivity

(cid:3)(cid:3)

so we take the following deﬁnition:

Deﬁnition 6 (Frames). A Kripke frame, or frame, is a tuple F = (cid:8)W , {∼i}i∈ A, D, {D i}i∈ A, F , {F i}i∈ A(cid:9) such that W is a non-
empty set; for i ∈ A, ∼i is an equivalence relation on W ; D is a non-empty set of individuals, and for i ∈ A, D i is a subset
of D; F ⊆ { f | f : W → D} is a non-empty set of functions from W to D, and for i ∈ A, F i is a subset of F .

The class of all Kripke frames is denoted by K.

In the model theory of modal logic W is usually referred to as the set of possible worlds, while each ∼i is the accessi-
bility relation between worlds [34]. The intuitive meaning of the elements D and F in a Kripke frame is similar to that in a
system of global states: they represent the domains of interpretation for global and local terms respectively.

In contrast with interpreted systems, Kripke frames are static structures with no obvious relation to the temporal evo-
lution of a system. However, given that also our approach to QIS is static and we will focus on purely epistemic languages,
the present deﬁnition of Kripke frames is adequate with our purposes of theoretical investigations.

In the next section we consider some specialisations of the notion of frame.

2.4. Further Kripke frames

In order to investigate varying, regular and objectual SGS, we introduce varying, regular and objectual Kripke frames as

follows:

Deﬁnition 7 (Varying frames). A varying frame is a tuple F = (cid:8)W , {∼i}i∈ A, D, {D i}i∈ A, F , {F i}i∈ A(cid:9) such that W , ∼i , D, and F
are deﬁned as in Deﬁnition 6, and for each i ∈ A, D i is a function from W to the power set ℘ (D), and F i is a function from
W to the power set ℘ (F ).

We denote the class of all varying Kripke frames as Kvar.

In analogy with regular SGS we have also regular Kripke frames.

Deﬁnition 8 (Regular frames). A regular frame is a varying frame such that:

for all w, w

(cid:3) ∈ W , w ∼i w

(cid:3)

implies D i(w) = D i(w

(cid:3)

) and F i(w) = F i(w

(cid:3)

)

We denote the class of all regular frames as Kreg.

We now introduce the objectual frames.

(7)

Deﬁnition 9 (Objectual frames). An objectual frame is a frame F = (cid:8)W , {∼i}i∈ A, D, {D i}i∈ A, F , {F i}i∈ A(cid:9) such that D = F , and
for i ∈ A, D i = F i .

We denote the class of all objectual frames as Kobj.

988

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

Objectual frames can be seen as tuples F = (cid:8)W , {∼i}i∈ A, D, {D i}i∈ A(cid:9).
Finally, for 2 (cid:2) k (cid:2) 6 we introduce the class Kk of Kripke frames corresponding to SGSk in a sense which will be made

precise in the following section. First, consider the following constraints on Kripke frames.

(cid:3)

for all w, w

(cid:3) ∈ W , w ∼i w
(cid:3) ∈ W , f ∈ F i, w ∼i w
for all w, w
for all w ∈ W , f ∈ F i, f (w) ∈ D i

and f (w) ∈ D i implies f (w

) ∈ D i
and f (w) ∈ D i implies f (w

(cid:3)

(cid:3)

(cid:3)

) ∈ D i

for all w, w

for all w, w

(cid:3) ∈ W , f ∈ F i and w ∼i w
(cid:3) ∈ W , f ∈ F i and w ∼i w

(cid:3)

(cid:3)

implies f (w) = f (w

implies f (w) = f (w

(cid:3)

(cid:3)

)
) ∈ D i

(8)

(9)

(10)

(11)

(12)

The meaning of formulas (8)–(12) is similar to that of formulas (2)–(6). We now introduce 5 more classes of Kripke frames.

Deﬁnition 10. For every k, 2 (cid:2) k (cid:2) 6, Kk ⊆ K is the class of the system of global states satisfying formula (k + 6).

All the classes of Kripke frames introduced so far are summarised in the following table, for 2 (cid:2) k (cid:2) 6.

Kripke frames

K
Kvar
Kobj
Kreg
Kk

all
varying
objectual
regular
frames in K satisfying formula (k + 6)

We will use SGS to model concrete systems and protocols, but we rely on Kripke frames for technical results, notably the
completeness proofs.

2.5. Maps between systems of global states and Kripke frames

We explore the relationship between systems of global states and Kripke frames by means of the maps f : SGS → K
and g : K → SGS. By Lemma 14 below and Theorem 41 we will show that the axiomatisation of Kripke frames
in Section 4 is sound and complete for the class of all SGS. Speciﬁcally, Lemma 14 states that every frame F =
(cid:8)W , {∼i}i∈ A, D, {D i}i∈ A, F , {F i}i∈ A(cid:9) is isomorphic to f (g(F )) = (cid:8)W
}i∈ A(cid:9), that is, there are bijec-
(cid:3)
(cid:3)
tions between W and W
i . In addition,
(cid:3)). As a consequence, every sound and complete axiomatisation of
we can show that w ∼i w
Kripke frames is also an axiomatisation of the systems of global states.

(cid:3)
(cid:3), {F
}i∈ A, D
i
(cid:3)
i , and the corresponding F i and F

(cid:3)
, F and F
iff ( f ◦ g)(w) ∼(cid:3)

(cid:3)
i ( f ◦ g)(w

, the corresponding D i and D

, D and D

}i∈ A, F

(cid:3), {∼(cid:3)
i

(cid:3), {D

(cid:3)
i

(cid:3)

In order to prove this result we start by introducing the map f : SGS → K.

Deﬁnition 11. Let S = (cid:8)S, D, {D i}i∈ A, F , {F i}i∈ A(cid:9) be a system of global states, deﬁne f (S) as the tuple (cid:8)S, {∼i}i∈ A, D, {D i}i∈ A,
F , {F i}i∈ A(cid:9) where for i ∈ A, each relation ∼i on S is deﬁned by (cid:8)le, l1, . . . , ln(cid:9) ∼i (cid:8)l

(cid:9) iff li = l

(cid:3)
e, l

(cid:3)
(cid:3)
1, . . . , l
n

(cid:3)
i .

It is easy to check that ∼i is an equivalence relation and that f (S) is a frame.
To deﬁne the converse map g : K → SGS, let F = (cid:8)W , {∼i}i∈ A, D, {D i}i∈ A, F , {F i}i∈ A(cid:9) be a frame. For every equivalence
(cid:3)} to be a local state for agent i, and w the

= {w

(cid:3) | w ∼i w

relation ∼i , for w ∈ W , we deﬁne the equivalence class [w]∼i
local state for the environment.

Deﬁnition 12. Given a frame F = (cid:8)W , {∼i}i∈ A, D, {D i}i∈ A, F , {F i}i∈ A(cid:9), let g(F ) be the tuple (cid:8)S, D, {D i}i∈ A, F
(cid:9); F
S contains all the n + 1-tuples (cid:8)w, [w]∼1 , . . . , [w]∼n
(cid:3)((cid:8)w, [w]∼1 , . . . , [w]∼n
f (w), for f ∈ F ; and for i ∈ A, F i = { f

(cid:9)) = f (w), for f ∈ F i}.

is the set of functions f

such that f

(cid:3) | f

(cid:3)

(cid:3)

(cid:3), {F
(cid:3)((cid:8)w, [w]∼1 , . . . , [w]∼n

}i∈ A(cid:9) where
(cid:9)) =

(cid:3)
i

By construction the structure g(F ) is a system of global states.
We now prove that the compositions f ◦ g and g ◦ f are isomorphisms on the respective structures. Only Lemma 14
below is actually needed to prove completeness with respect to SGS (see Section 4), but we also present Lemma 13 to state
precisely the correspondence between systems of global states and Kripke frames. In what follows πi((cid:8)a1, . . . , am(cid:9)) = ai , for
i (cid:2) m.

Lemma 13. Every system of global states S is isomorphic to g( f (S)).

Proof. If S = (cid:8)S, D, {D i}i∈ A, F , {F i}i∈ A(cid:9) is an SGS, then g( f (S)) = (cid:8)S
(cid:3)
S

is the set of n + 1-tuples (cid:8)s, [s]∼1 , . . . , [s]∼n

(cid:9), for s ∈ S. The function h(s) = (cid:8)s, [s]∼1 , . . . , [s]∼n

}i∈ A(cid:9) is an SGS as well such that
(cid:9) is a bijection between

(cid:3), D, {D i}i∈ A, F

(cid:3), {F

(cid:3)
i

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

989

(cid:3)

: it is one-to-one as if s, s

(cid:3) ∈ S
S and S
such that h(π1(s)) = s. Identity is trivially a bijection on D, and for f ∈ F ,
. (cid:2)
f (s) = f

(cid:9)), for s ∈ S, is a bijection between F and F

(cid:3)((cid:8)s, [s]∼1 , . . . , [s]∼n

and s = s

, then in particular π1(s) = π1(s

(cid:3) ∈ F

f

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)). It is onto as for s ∈ S

(cid:3)

, the function h

such that h

(cid:3)

, π1(s) ∈ S is
(cid:3)( f ) = f
iff

(cid:3)

Lemma 14. Every Kripke frame F is isomorphic to f (g(F )).

(cid:3)

is the set of n + 1-tuples (cid:8)w, [w]∼1 , . . . , [w]∼n

Proof. If F = (cid:8)W , {∼i}i∈ A, D, {D i}i∈ A, F , {F i}i∈ A(cid:9) is a Kripke frame, then f (g(F )) = (cid:8)W
such that W
bijection between W and W
(cid:3)
as for w ∈ W
(cid:3) ∈ F
(cid:3)
, the function h
f
(cid:3)
(cid:3)
. Moreover, w ∼i w
F

}i∈ A(cid:9) is
(cid:9) is a
(cid:3)). It is onto
, π1(w) ∈ W is such that h(π1(w)) = w. Also in this case the identity on D is a bijection, and for f ∈ F ,
(cid:3)((cid:8)w, [w]∼1 , . . . , [w]∼n
(cid:9)), for w ∈ W , is a bijection between F and
(cid:9) ∼(cid:3)
i

(cid:3), {∼(cid:3)
i
(cid:9), for w ∈ W . The function h(w) = (cid:8)w, [w]∼1 , . . . , [w]∼n

iff f (w) = f
(cid:3)]∼i iff (cid:8)w, [w]∼1 , . . . , [w]∼n

, then in particular π1(w) = π1(w

: it is one-to-one as if w, w

such that h
iff [w]∼i

}i∈ A, D, {D i}i∈ A, F

(cid:3)]∼1 , . . . , [w

and w = w

(cid:3)( f ) = f

(cid:3) ∈ W

(cid:9). (cid:2)

= [w

(cid:3), [w

(cid:3)]∼n

(cid:3), {F

(cid:8)w

(cid:3)
i

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

By Lemma 14 and Theorem 41 we will show that the axiomatisation of Kripke frames presented in Section 4 is adequate

also for the systems of global states.

2.6. Further maps

It is straightforward to extend the maps f and g to deal also with the other classes of SGS and Kripke frames. As regards
varying SGS and frames, deﬁne map f var : SGS var → Kvar as f , and deﬁne map gvar : Kvar → SGS var to be the same as g
(cid:3)),
except that for s = (cid:8)w, [w]∼1 , . . . , [w]∼n
(cid:3) = π1(s
for f ∈ F i(w), w

(cid:3)
i(s) is deﬁned as D i(w) and F

(cid:3)
i (s) is deﬁned as { f

(cid:9) ∈ gvar(F ), D

(cid:3)) = f (w

(cid:3) | f

(cid:3))}.

(cid:3)(s

We state the following isomorphism result, the proof follows those in Lemmas 13 and 14 with little modiﬁcations.

Corollary 15. Every varying SGS S is isomorphic to gvar( f var(S)).

Every varying frame F is isomorphic to f var(gvar(F )).

Further, it can be shown that f var(S) is a regular frame, whenever S is a regular SGS. Also, gvar(F ) is a regular SGS,

whenever F is a regular frame. Therefore, we have the following:

Corollary 16. Every regular SGS S is isomorphic to gvar( f var(S)).

Every regular frame F is isomorphic to f var(gvar(F )).

The map f obj : SGS obj → Kobj from objectual systems of global states to Kripke frames is deﬁned as the restric-
is similarly deﬁned as the restrictions of g to (cid:8)W ,

tion of
{∼i}i∈ A, D, {D i}i∈ A(cid:9). By considerations similar to those for Lemmas 13 and 14 it is easy to show the following:

to (cid:8)S, D, {D i}i∈ A(cid:9); while the map gobj : Kobj → SGS obj

f

Corollary 17. Every objectual SGS S is isomorphic to gobj( f obj(S)).

Every objectual frame F is isomorphic to f obj(gobj(F )).

Finally, for 2 (cid:2) k (cid:2) 6, we can show that the frame f (S) satisﬁes the formula (k + 6) whenever S satisﬁes (k). Also, the

SGS g(F ) satisﬁes the formula (k) whenever F satisﬁes (k + 6). Therefore, the following holds:

Corollary 18. Let 2 (cid:2) k (cid:2) 6. Every SGS S ∈ SGSk is isomorphic to g( f (S)).

Every frame F ∈ Kk is isomorphic to f (g(F )).

In the following table we summarise the correspondences between systems of global states and Kripke frames, for

2 (cid:2) k (cid:2) 6.

Systems of global states

Kripke frames

SGS
SGS var
SGS obj
SGS reg
SGSk

K
Kvar
Kobj
Kreg
Kk

In Section 4, Corollaries 15–18 will be used for proving completeness with respect to all classes of systems of global states,
once obtained completeness for the corresponding class of Kripke frames.

990

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

3. Syntax and semantics

In this section we introduce a family of ﬁrst-order epistemic languages containing local and global terms, quantiﬁers,
epistemic operators, as well as the identity symbol. These languages are interpreted on models based on Kripke frames.
Finally, we present quantiﬁed interpreted systems, a valued version of the systems of global states.

3.1. Syntax

The ﬁrst-order epistemic language Ln contains global variables x1, x2, . . . , local variables z1, z2, . . . , global constants
, . . . , and n-ary pred-
2, . . . , for n ∈ N, the identity symbol =, the boolean connectives ¬ and →, and for every i ∈ A, the

c1, c2, . . . , and local constants d1, d2, . . . . Moreover, we have n + 1-ary function symbols f n+1
icative constants P n
indexed quantiﬁer ∀i , the epistemic operator K i , and the unary predicative constant Admi .

, f n+1

1, P n

1

2

Deﬁnition 19 (Ln). Terms and formulas in Ln are deﬁned as follows:

t ::= x | z | c | d | f k(t1, . . . , tk)

φ ::= P k(t1, . . . , tk) | t = t

(cid:3) | Admi(t) | ¬φ | φ → φ

(cid:3) | K iφ | ∀i xφ | ∀i zφ

The operator K i , for i ∈ A, is the standard epistemic modality [14]. The formula K iφ intuitively means that “agent i knows
that φ is the case”. The formula ∀i xφ (respectively ∀i zφ) states that “φ is the case for all individuals in D i ” (respectively
F i ); whereas Admi(t) means that the individual denoted by term t is among the admissible individuals considered by agent
i, that is, the individuals in D i and F i . The symbols ⊥, ∧, ∨, ↔, ∃i are deﬁned from the other logical constants as standard,
while metavariables y, y

(cid:3), . . . refer to the (local and global) variables in Ln.

A global term s is deﬁned as:

s ::= x | c | f k(s1, . . . , sk)

A term not complying with the above is said to be local. The metavariables s, s
terms respectively; while v, v
“s” may represent either a state or a global term, the context will disambiguate.

(cid:3), . . . refer to global and local
(cid:3), . . . refer to closed global and local terms, where no variable appears. The symbol

(cid:3), . . . and u, u

(cid:3), . . . and r, r

Moreover, t[(cid:18)y] (resp. φ[(cid:18)y]) means that (cid:18)y = y1, . . . , yn are all the (local and global) free variables in t (resp. φ); while
t[(cid:18)y/(cid:18)t] (resp. φ[(cid:18)y/(cid:18)t]) denotes the term (resp. formula) obtained by substituting simultaneously some, possibly all, the free
occurrences of y1, . . . , yn in t (resp. φ) with t1, . . . , tn, renaming bounded variables if necessary. We assume that local
variables are to be substituted by local terms only, the same holds for global variables and terms.

We write GVar, LVar, GCon and LCon to denote the sets of global and local variables, and the sets of global and local

constants in Ln respectively.

In this paper we consider two further languages, Lobj
n

and LD

n , for describing the objectual structures introduced in

Section 2.

Deﬁnition 20 (Lobj
follows:

n ). The language Lobj

n

is the restriction of Ln to global terms. Terms and formulas in Lobj
n

are deﬁned as

t ::= x | c | f k(t1, . . . , tk)

φ ::= P k(t1, . . . , tk) | t = t

(cid:3) | Admi(t) | ¬φ | φ → φ

(cid:3) | K iφ | ∀i xφ

Deﬁnition 21 (LD
subset G of A. Terms and formulas in LD

n ). The language LD

n extends Lobj

n are deﬁned as follows:

n by adding the distributed knowledge operator D G , for every non-empty

t ::= x | c | f k(t1, . . . , tk)

φ ::= P k(t1, . . . , tk) | t = t

(cid:3) | Admi(t) | ¬φ | φ → φ

(cid:3) | K iφ | D G φ | ∀i xφ

The formula D G φ intuitively means that “φ is distributed knowledge among the agents in the subset G of A” (see [15]
for details). We will show that the language Lobj
n is
n
useful for the application to distributed systems in Section 5. The notions deﬁned in this subsection for language Ln can be
extended to LD

is expressive enough for the speciﬁcation of objectual SGS, while LD

n with the obvious changes. In this paper we do not consider extensions to common knowledge.

n and Lobj

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

991

3.2. Expressiveness

This section provides some examples of the expressiveness of the ﬁrst-order epistemic languages introduced in Sec-
tion 3.1. First of all, in Ln we can express the agents’ knowledge regarding properties and relationships among individuals.
For instance, consider the following speciﬁcations:

(1) Agent i knows that for every process x, agent j knows that there exists a precondition x

(cid:3)

considered by i, which has to

be fulﬁlled in order for x to be executed.

(2) Agent i knows that among the inputs considered by agent j there exists an x for which agent j does not know that

(cid:3)
every computation x

on input x fails.

(3) Every successful transmission x returns a code z, but agent i does not know this code (maybe because the return code

is encrypted).

These statements can be intuitively formalised as follows:

(cid:3)) ∧ (Executed(x) → Fulﬁl(x
(1) K i∀i x(Process(x) → K j∃i x
(cid:3))))
(2) K i∃ j x(Input(x) ∧ ¬K j∀ j x
(3) ∀i x∃i z(z = return-code(x) ∧ ¬K i(z = return-code(x))

(cid:3)(Precond(x
(cid:3)(Comp(x

(cid:3)) → Fails(x, x

(cid:3)))))

We note the rich expressiveness of the language obtained by combining epistemic modalities with quantiﬁers, and the
interplay between local and global terms in the third speciﬁcation (but see also Section 5.1 below).

Also, observe that in this framework we can model the knowledge agents have about themselves, as pointed out in the
introduction. In addition, and not discussed above, we obviously retain all the expressive power of propositional epistemic
logic.

Further, in the framework of ﬁrst-order epistemic logic we can express the de re/de dicto distinction, i.e., the difference
between knowing of something as being so-and-so, and knowing that something is so-and-so. For instance, when we use
an informal speciﬁcation to say that,

as far as the security controller is concerned, every user is authorised to access the site,

one could interpret this (hence implement it!) as either de dicto, i.e., descriptively:

(1) the security controller knows that every user is authorised to access the site,

or de re, i.e., prescriptively:

(2) for every user, the security controller knows that he is authorised to access the site.

These two readings express different concepts. While these cannot be easily separated by means of a propositional language,
in Ln this is promptly done as follows:

(1) KSecCon∀SecConx(Authorised(x) → Access(x))
(2) ∀SecConx(Authorised(x) → KSecConAccess(x))

The difference in meaning between the two speciﬁcations is clear. For instance, the security controller not granting access
to an authorised user a is a violation of (2), but not of (1), if he does not regard a as an authorised user.

3.3. Kripke models and quantiﬁed interpreted systems

We now proceed to interpret our ﬁrst-order epistemic languages on the classes of Kripke frames deﬁned in Section 2.

Then we introduce quantiﬁed interpreted systems, a valued version of the systems of global states.

Deﬁnition 22 (Kripke model). A Kripke model based on a frame F , or model, is a pair M = (cid:8)F , I(cid:9) where the interpretation
I is such that:

• if c is a global constant, then I(c) ∈ D;
• if d is a local constant, then I(d) ∈ F ;
• if

(I( f k)((cid:18)g))(w) = I( f k)(g1(w), . . . , gk(w));

f k is a k-ary function symbol, then I( f k) is a k-ary function from F k to F such that for (cid:18)g ∈ F k, we have

• for w ∈ W , I(P k, w) is a k-ary relation on D, I(Admi, w) = D i ∪ F i , and I(=, w) is the equality relation on D.

992

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

In a Kripke model global constants are interpreted rigidly, while local constants are not, so it can be the case that I(d)(w)
(cid:3)) /∈ D i . This case models
is different from I(d)(w
the scenario in which agent i does not know whether the denotation of term d is among the individuals in her domain of
quantiﬁcation. Shortly we will see how to deal with this situation.

. In particular, it can be the case that I(d)(w) ∈ D i but I(d)(w

(cid:3)), for w (cid:11)= w

(cid:3)

Each I( f k) is a function from F k to F , but if the arguments are constant functions, i.e., elements in D, then I( f k) is a
function from Dk to D. The condition on I( f k) guarantees that identical terms can be substituted, that is, if the denotations
of terms t

are identical, then the denotation of substituted term t[ y/t

(cid:3)] is identical to t[ y/t

and t

(cid:3)(cid:3)].

(cid:3)(cid:3)

(cid:3)

Finally, we remark that Admi is an intensional predicate, i.e., its interpretation is D i ∪ F i , not just a subset of D; this is

because we consider domains of intensional objects as well as domains of individuals.

We will consider also varying, regular, and objectual models, based on varying, regular, and objectual frames.
Now let σ be an assignment, i.e., any function from GVar to D and from LVar to F .

Deﬁnition 23 (Valuation). The valuation Iσ (t, w) ∈ D of a term t at a world w is inductively deﬁned as follows:

Iσ (x, w) = Iσ (x) = σ (x)
Iσ (z, w) = Iσ (z)(w) = σ (z)(w)
Iσ (c, w) = Iσ (c) = I(c)
Iσ (d, w) = Iσ (d)(w) = I(d)(w)
Iσ ( f k(t1, . . . , tk), w) = I( f k)(Iσ (t1, w), . . . , Iσ (tk, w))

= (I( f k)(Iσ (t1), . . . , Iσ (tk)))(w), by the constraint on I( f k)

The deﬁnition of Iσ (t) ∈ D ∪ F can be derived from Deﬁnition 23. Note that if t is a global term, then Iσ (t) = Iσ (t, w),
for every w ∈ W . On the other hand, if t is a local term, then Iσ (t) is an intensional object belonging to F . The valuation
of terms in Lobj
n
The variant σ
(cid:2)
z
f

of an assignment σ assigns a ∈ D to x ∈ GVar and coincides with σ on all the other variables; the

for f ∈ F , z ∈ LVar is similarly deﬁned.

is restricted to global terms.
(cid:2)

variant σ

x
a

(cid:3)

(cid:3)

Deﬁnition 24 (Satisfaction). The satisfaction relation |(cid:20) for φ ∈ Ln, w ∈ W , and an assignment σ is inductively deﬁned as
follows:

(cid:3)

(Mσ , w) |(cid:20) P k(t1, . . . , tk)
(Mσ , w) |(cid:20) t = t
(Mσ , w) |(cid:20) Admi(t)
(Mσ , w) |(cid:20) ¬ψ
(Mσ , w) |(cid:20) ψ → ψ (cid:3)
(Mσ , w) |(cid:20) K iψ
(Mσ , w) |(cid:20) ∀i xψ
(Mσ , w) |(cid:20) ∀i zψ

iff

iff

iff

iff

iff

iff

iff

iff

(cid:8)Iσ (t1, w), . . . , Iσ (tk, w)(cid:9) ∈ I(P k, w)
(cid:3), w)
Iσ (t, w) = Iσ (t
Iσ (t) ∈ D i ∪ F i
(Mσ , w) (cid:11)|(cid:20) ψ
(Mσ , w) (cid:11)|(cid:20) ψ or (Mσ , w) |(cid:20) ψ (cid:3)
(cid:3) ∈ W , w ∼i w
for all w
for all a ∈ D i, (Mσ (x
for all f ∈ F i, (Mσ ( z

a), w) |(cid:20) ψ
f ), w) |(cid:20) ψ

(cid:3)

implies (Mσ , w

(cid:3)) |(cid:20) ψ

The truth conditions for formulas containing ⊥, ∧, ∨, ↔, ∃i can be deﬁned from those above. The formula Admi(t)
means that the individual Iσ (t) ∈ D i ∪ F i is among those admissible for agent i. In particular, if t is a global term then
Iσ (t) = Iσ (t, w) ∈ D i . On the other hand, if t is a local term then Iσ (t) is an intensional object in F i .

If we consider varying models, the deﬁnition of satisfaction is as above but for the following clauses:

Deﬁnition 25. The satisfaction relation |(cid:20) for φ ∈ Ln, w ∈ W , and an assignment σ is inductively deﬁned as follows:

(Mσ , w) |(cid:20) Admi(t)
(Mσ , w) |(cid:20) ∀i xψ
(Mσ , w) |(cid:20) ∀i zψ

iff

iff

iff

Iσ (t) ∈ D i(w) ∪ F i(w)
for all a ∈ D i(w), (Mσ (x
for all f ∈ F i(w), (Mσ ( z

a), w) |(cid:20) ψ
f ), w) |(cid:20) ψ

The meaning of a formula φ ∈ Lobj
n
Further, the truth conditions for D G φ ∈ LD

in an objectual model M is deﬁned by restricting Deﬁnition 24 to global terms.
n in objectual models are speciﬁed as follows:

(Mσ , w) |(cid:20) D G ψ iff

for w

(cid:3) ∈ W , (w, w

(cid:3)

) ∈

∼i

implies (Mσ , w

(cid:3)

) |(cid:20) ψ

(cid:4)

i∈G

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

993

As customary, we say that a formula φ is true at a world w iff it is satisﬁed at w by every assignment σ ; φ is valid on a
model M iff it is true at every world in M; φ is valid on a frame F iff it is valid on every model based on F ; φ is valid on a
class C of frames iff it is valid on every frame in C.

Let (cid:7) be a set of formulas, M is a model for (cid:7), or M |(cid:20) (cid:7), iff every formula in (cid:7) is valid on M, and F is a frame
for (cid:7), or F |(cid:20) (cid:7), iff every model based on F is a model for (cid:7). A frame F for (cid:7) will also be called (cid:7)-frame, by (cid:7)-K we
denote the class of (cid:7)-frames.

We have now the formal machinery to introduce quantiﬁed interpreted systems as follows.

Deﬁnition 26 (Quantiﬁed interpreted systems). Given an SGS S, a quantiﬁed interpreted systems (QIS) is a pair P = (cid:8)S, I(cid:9)
such that I is an interpretation of Ln in f (S).

The notions of satisfaction, truth and validity on QIS can be deﬁned as above. Let P f = (cid:8) f (S), I(cid:9) be the Kripke model

associated with the quantiﬁed interpreted system P = (cid:8)S, I(cid:9), then

(P σ , s) |(cid:20) φ iff

(P σ

f , s) |(cid:20) φ

In particular, we can show that the truth conditions for epistemic modalities in interpreted systems are preserved, that is,
the deﬁnition above via Kripke models boils down to the usual truth conditions in interpreted systems:

(P σ , s) |(cid:20) K iψ iff
(P σ , s) |(cid:20) D G ψ iff

for s

for s

(cid:3) ∈ S, li(s) = li(s
(cid:3)) implies (P σ , s
(cid:3) ∈ S, if for all i ∈ G, li(s) = li(s

(cid:3)) |(cid:20) ψ
(cid:3)), then (P σ , s

(cid:3)) |(cid:20) ψ

We say that a formula φ ∈ Ln is valid on a quantiﬁed interpreted systems P iff φ is valid on P f .
Deﬁnition 26 applies also to the other classes of SGS.

Deﬁnition 27.

(varying QIS) Given a varying SGS S, a varying QIS is a pair P = (cid:8)S, I(cid:9) such that I is an interpretation of Ln in f var(S).

(regular QIS) Given a regular SGS S, a regular QIS is a pair P = (cid:8)S, I(cid:9) such that I is an interpretation of Ln in f var(S).

(objectual QIS) Given an objectual SGS S, an objectual QIS is a pair P = (cid:8)S, I(cid:9) such that I is an interpretation of Lobj
n
in f obj(S).

(QISk) Let 2 (cid:2) k (cid:2) 6. Given an SGS S ∈ SGSk, a QISk is a pair P = (cid:8)S, I(cid:9) such that I is an interpretation of Ln in f (S).

Quantiﬁed interpreted systems will be used in Sections 5 and 6 to model various instances of multi-agent systems. But

ﬁrst we discuss some important validities in these structures.

3.4. Validities

In Section 2 we remarked that in systems of global states the domains of quantiﬁcation D i and F i are independent from
global states. Therefore, both the Barcan formula and its converse [16] are valid in their indexed form on the class of all
SGS:

SGS |(cid:20) ∀i y K jφ → K j∀i yφ
SGS |(cid:20) K j∀i yφ → ∀i y K jφ

BFi− j

CBFi− j

These validities state that each agent knows which are the individuals she and the other agents reason about. By BFi− j in
all agent j’s epistemic alternatives there are no more individuals in agent i’s domains than j presently considers, so agent
j can generalise her knowledge. Similarly, by CBFi− j in all agent j’s epistemic alternatives there are no fewer individuals
in agent i’s domains, so agent j can particularise her knowledge. When an agent can generalise and particularise her
knowledge on a domain of objects, we say that she has knowledge of that domain, at least implicitly.

For the same reasons we have also that:

SGS |(cid:20) Adm j(t) → K iAdm j(t)
SGS |(cid:20) ¬Adm j(t) → K i¬Adm j(t)

NecAdm

Nec¬Adm

By these validities every agent knows whether any individual belongs to the domain of admissible individuals of any other
agent. In the language LD
n the Barcan formulas hold also for the distributed knowledge operator D G :

994

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

SGS |(cid:20) ∀i y D G φ → D G ∀i yφ
SGS |(cid:20) D G ∀i yφ → ∀i y D G φ

SGS |(cid:20) Adm j(t) → D G Adm j(t)
SGS |(cid:20) ¬Adm j(t) → D G ¬Adm j(t)

These principles are rather strong even for an external account of knowledge, in which knowledge is not explicitly possessed
by agents, but rather attributed to them by an external observer. After all, we introduced different domains of quantiﬁcation
for expressing that each agent has only a limited access to the totality of individuals. If they know all other agents’ domains
as well as theirs, the whole construction seems questionable. Given this, we could turn to varying SGS, where all formulas
above are not valid, as quantiﬁcation domains change according to global states. But this would undermine the agents’
knowledge of their own domains, something equally unwelcomed.

Our solution consists in admitting BFi− j and CBFi− j only for i = j. In fact, these formulas hold on the class of regular

SGS:

BFi−i

SGS reg |(cid:20) ∀i y K iφ → K i∀i yφ
SGS reg |(cid:20) K i∀i yφ → ∀i y K iφ

CBFi−i
In this way we solve the problem of having quantiﬁcation domains D i(s) and F i(s), for i ∈ A, depending also on the local
states of agents other than i: in regular SGS quantiﬁcation domains can be considered part of each agent’s local state. By
restricting our attention to regular SGS satisfying the restricted versions BFi−i and CBFi−i of the Barcan formulas, we model
the scenario in which agents know their respective domains of quantiﬁcation, but not necessarily the other agents’.

Finally, we remark that in the present semantical framework we admit possibilia, i.e., objects in D and F which do
not appear in quantiﬁcation domains D i or F i , for some agent i ∈ A. Moreover, agents may have knowledge about these
possible entities, that is, there are models in which K i P (t) is true at some world w, for some Iσ (t, w) belonging to D, but
Iσ (t, w) /∈ D i . The existence of something like possible objects is a rather debated topic in the philosophy of modal logic,
see [40] and [35] for a review of classic possibilist and actualist accounts. However, in AI the introduction of possibilia can be
useful to model speciﬁc scenarios. For instance, an agent i may know that no horse ﬂies, i.e., ∀i xK i¬(Horse(x) ∧ Fly(x)), and
yet she studied the Greek classics and knows that Pegasus is a ﬂying horse, i.e., K i(Horse(Pegasus) ∧ Fly(Pegasus)). A solution
to this puzzle consists in considering Pegasus a possible object in D \ D i .

3.5. Individual terms and identity

As regards identity, observe that the following formulas hold for global terms on every system of global states:

SGS |(cid:20) (s = s
SGS |(cid:20) (s = s
SGS |(cid:20) (s (cid:11)= s

(cid:3)

(cid:3)

(cid:3)

) → (φ[x/s] → φ[x/s
) → K i(s = s
) → K i(s (cid:11)= s

)

)

(cid:3)

(cid:3)

(cid:3)])

Subst

K iId

K iDif

but not for local terms:

SGS (cid:11)|(cid:20) (u = u
SGS (cid:11)|(cid:20) (u = u
SGS (cid:11)|(cid:20) (u (cid:11)= u

(cid:3)

(cid:3)

(cid:3)

) → (φ[z/u] → φ[z/u
) → K i(u = u
) → K i(u (cid:11)= u

)

)

(cid:3)

(cid:3)

(cid:3)])

These (in)validities motivate the names of ﬂexible and rigid terms given in [46]. Identical global terms can be substituted in
any formula, in particular in epistemic contexts; whereas for local terms we have only:
(cid:3)]),

) → (φ[z/u] → φ[z/u

SGS |(cid:20) (u = u

for atomic φ

(cid:3)

but φ has to be different from Admi(u):
(cid:3)

SGS (cid:11)|(cid:20) (u = u

) → (Admi(u) → Admi(u

(cid:3)

))

as Admi is an intensional predicate and it can be that the individuals Iσ (u, w), Iσ (u
object Iσ (u) belongs to F i but Iσ (u

(cid:3)) /∈ F i .

(cid:3), w) ∈ D are identical, the intensional

The relationship between local and global terms is particularly relevant for the present investigations. We remarked that
, and yet we may have that Iσ (u)(s) ∈ D i and
it can be the case that agent i cannot distinguish between states s and s
(cid:3)) /∈ D i , for some local term u. This means that in state s agent i is aware of the object being denoted by u, but she
Iσ (u)(s
does not know that she is. This feature of the semantics can be considered unsatisfactory, but one should note that agents
do not always explicitly know their domains of quantiﬁcation, as it is the case in varying QIS. However, it is possible to
(cid:3)) ∈ D i .
address the point above by assuming formula (2): for every i ∈ A, for f ∈ F , if li(s) = li(s
We can capture this constraint by means of the following formula:

(cid:3)) and f (s) ∈ D i , then f (s

(cid:3)

∃i x(d = x) → K i∃i x(d = x)

(13)

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

995

We can easily check that the following correspondence holds:

S |(cid:20) ∃i x(d = x) → K i∃i x(d = x)

iff S satisﬁes formula (2)

Further, we can restrict this principle to only the intensional objects contained in each F i . According to formula (3), an agent
i knows the denotation of only the intensional objects in his domain of quantiﬁcation. Similarly to the above, this formula
can by captured by means of a formula in Ln:

∀i z(∃i x(z = x) → K i∃i x(z = x))

(14)

The following correspondence can be promptly proved:

S |(cid:20) ∀i z(∃i x(z = x) → K i∃i x(z = x))

iff S satisﬁes formula (3)

Finally, we strengthen formula (14) by requiring that the denotation of every local term in the domain of agent i is un-
conditionally an individual belonging to agent i’s domain of individuals, that is, formula (4) holds. Also in this case we can
provide a formal counterpart to this formula in Ln,

∀i zK i∃i x(z = x)

by noting that the following correspondence holds:

S |(cid:20) ∀i zK i∃i x(z = x)

iff S satisﬁes formula (4)

(15)

Moreover, we can require that each agent i knows at least the denotation of the local terms in her domain of quantiﬁ-

cation. This is tantamount to formula (5), which can be captured by the following formula in Ln:

∀i z((z = u) → K i(z = u))

(16)

similarly to the above, we can prove that the following correspondence holds:

S |(cid:20) ∀i z((z = u) → K i(z = u))

iff S satisﬁes formula (5)

We can combine formulas (16) and (15) in order to express formula (6), i.e., the fact each agent i knows the denotation
of local terms, which is an individual in her domain of quantiﬁcation. We express formula (6) by means of the following
formula in Ln:

∀i z∃i xK i(z = x)

and the respective correspondence holds:

S |(cid:20) ∀i z∃i xK i(z = x)

iff S satisﬁes formula (6)

(17)

Note that formula (17) is the de re version of (15). According to (17) for every local term u, there is exactly one individual

which is known by agent i to be the denotation of u.

In the next section we will consider formulas (13)–(17) and we will prove completeness of the semantical classes intro-
duced with respect to the relevant axiomatisations. As a summary, in the next lemma we list formulas and corresponding
classes of systems of global states and Kripke frames.

Lemma 28. In the table below, for every row, the formula in the ﬁrst column is valid on all and only the SGS in the second column, and
it is valid in all and only frames in the third column.

Formulas

SGS

Frames

∀i y K i φ ↔ K i ∀i yφ

(13) ∃i x(d = x) → K i ∃i x(d = x)
(14) ∀i z(∃i x(z = x) → K i ∃i x(z = x))
(15) ∀i zK i ∃i x(z = x)
(16) ∀i z((z = u) → K i (z = u))
(17) ∀i z∃i xK i (z = x)

SGS reg
SGS 2
SGS 3
SGS 4
SGS 5
SGS 6

Kreg
K2
K3
K4
K5
K6

Proof. We do not provide the details of the proof, but just note that the validity of formulas on the corresponding classes of
SGS follows by the remarks earlier in this section, while the validity on Kripke frames follows by corollaries (15)–(18). (cid:2)

We remark that classes SGS 6 of systems of global states and K6 of Kripke frames are tantamount to the intersections

SGS 4 ∩ SGS 5 and K4 ∩ K5 respectively.

996

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

4. Axiomatisations

In this section we introduce sound and complete axiomatisations for all the classes of SGS presented in Sections 2 and 3.
We start by considering the ﬁrst-order epistemic system Q .S5n, then we tune this calculus to cover also varying, objectual,
and regular SGS, as well as the structures satisfying formulas (2)–(12). While resolution and natural deduction calculi are
more suitable when dealing with automated reasoning, for the purpose of the completeness proof Hilbert-style systems are
easier to handle.

4.1. System Q .S5n

The system Q .S5n on the language Ln is a ﬁrst-order multi-modal version of the propositional system S5. Hereafter we

list the axioms and inference rules. We use ⇒ to denote the inference relation between formulas.

Deﬁnition 29 ( Q .S5n). The system Q .S5n on Ln contains the following schemes of axioms and inference rules:

Taut
K
T
4
5
MP
Nec

Ex
Gen

BFi− j
CBFi− j

Id
Func
Subst
K i Id
K i Dif

every instance of classic propositional tautologies
K i (φ → ψ) → (K i φ → K i ψ)
K i φ → φ
K i φ → K i K i φ
¬K i φ → K i ¬K i φ
φ → ψ, φ ⇒ ψ
φ ⇒ K i φ
∀i yφ → (Admi (t) → φ[ y/t])
φ → (Admi (t) → ψ[ y/t]) ⇒ φ → ∀i yψ, for y not free in φ
∀i y K j φ → K j ∀i yφ
K j ∀i yφ → ∀i y K j φ
t = t
t = t
t = t
s = s
s (cid:11)= s

(cid:3) → (t
(cid:3)(cid:3)[ y/t
(cid:3)(cid:3)[ y/t] = t
(cid:3) → (φ[ y/t] → φ[ y/t
(cid:3) → K i (s = s
(cid:3) → K i (s (cid:11)= s

(cid:3)])
(cid:3)]), for atomic φ

(cid:3))
(cid:3))

The ﬁrst group of postulates axiomatises the multi-modal system S5n. Following this, we have the free logic postulates
for quantiﬁcation for both global and local terms. The Barcan formulas guarantee that the domains of admissible individuals
are independent from global states, as shown below. Finally, we have axioms Id, Func and Subst for all terms, while K iId
and K iDif hold only for global terms. We note without proof that the axioms Subst and K iId are suﬃcient for deriving the
substitution of identical global terms in any ﬁrst-order modal formula φ.

We deﬁne proofs and theorems as standard: (cid:23)Q .S5n φ means that φ ∈ Ln is a theorem in Q .S5n. Moreover, we say that
φ ∈ Ln is derivable in Q .S5n from the set (cid:7) of formulas in Ln, and write (cid:7) (cid:23)Q .S5n φ, iff there are φ1, . . . , φm ∈ (cid:7) such that
(cid:23)Q .S5n φ1 ∧ · · · ∧ φm → φ.

Lemma 30. Among the theorems of Q .S5n we have:

NecAdm
Nec¬Adm

(cid:23)Q .S5n Admi (t) → K j Admi (t)
(cid:23)Q .S5n

¬Admi (t) → K j ¬Admi (t)

Knowledge of Admissibility
Knowledge of Inadmissibility

Proof. The proof for NecAdm goes as follows:
a. (cid:23)Q .S5n Admi(t) → Admi(t)
b. (cid:23)Q .S5n
∀i yAdmi( y)
c. (cid:23)Q .S5n K j∀i yAdmi( y)
d. (cid:23)Q .S5n
e. (cid:23)Q .S5n K j∀i yAdmi( y) → (Admi(t) → K jAdmi(t))
f. (cid:23)Q .S5n Admi(t) → K jAdmi(t)

∀i y K jAdmi( y) → (Admi(t) → K jAdmi(t)) axiom Ex

from d by CBFi− j
from c, e by MP

propositional tautology

from a by Gen

from b by Nec

The proof for Nec¬Adm can be obtained similarly. (cid:2)

4.2. Further systems

By suitably tuning the systems Q .S5n we can obtain provably sound and complete axiomatisations for all classes of
SGS in Sections 2 and 3. For instance, by dropping BFi− j and CBFi− j , and by restricting these postulates to i = j, we can
axiomatise varying and regular SGS respectively. Further, we can axiomatise objectual SGS by restricting Q .S5n to formulas

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

997

where only global terms appear. Finally, we add the axioms for distributed knowledge to Q .S5n in order to axiomatise the
set of validities on the language LD

n . Hereafter we list the relevant systems.

Deﬁnition 31.

(Q.S5var

n ) The system Q .S5var

n on the language Ln is obtained from Q .S5n by eliminating the axioms BFi− j and CBFi− j .

(Q.S5

(Q.S5

reg

n ) The systems Q .S5reg

n on the language Ln is obtained from Q .S5n by restricting BFi− j and CBFi− j to i = j.

obj

n ) The system Q .S5obj

n

is obtained by restricting Q .S5n to the language Lobj
n .

n ) The system Q .S5D

(Q.S5D
distributed knowledge:

n on the language LD

n is obtained by extending Q .S5obj

n with the following postulates for

K
T
4
5
D1
D2
Nec

D G (φ → ψ) → (D G φ → D G ψ)
D G φ → φ
D G φ → D G D G φ
¬D G φ → D G ¬D G φ
D{i}φ ↔ K i φ
D G φ → D G(cid:3) , for G ⊆ G
φ ⇒ D G φ

(cid:3)

(Q.S5k

n) For 2 (cid:2) k (cid:2) 6, the system Q .S5k

n is obtained by adding formula (k + 11) to Q .S5n.

Note that formulas NecAdm and Nec¬Adm are not provable in Q .S5var

n , while for system Q .S5reg

n we have only restricted

versions of NecAdm and Nec¬Adm, for i = j.

4.3. Correspondence theory

In this section we deﬁne a correspondence theory between properties of frames and validity of formulas at ﬁrst-order.

In what follows a systems S is identiﬁed with the set of its theorems.

Lemma 32. Let 2 (cid:2) k (cid:2) 6. In the following table, for each row, F is an S-frame, i.e., F |(cid:20) S, iff F belongs to the class of frames in the
second column.

QML systems

Kripke frames

Q .S5n
Q .S5var
n
Q .S5reg
n
Q .S5obj
n
Q .S5D
n
Q .S5k
n

K
Kvar
Kreg
Kobj
Kobj
Kk

Proof. We provide an outline of the proof by showing the right to left implications for some systems. We show that (cid:23)S φ
implies F |(cid:20) φ, where F belongs to the relevant class of frames. The proof is by induction on the length of the proof of φ
in S, axioms are the base case and inference rules are the inductive step.

Q.S5n. We can easily check that the axioms of Q .S5n hold on every Kripke model and the inference rules preserve
validity. We provide detailed proofs only for axioms BFi− j , and K iId. As regards BFi− j , assume that (Mσ , w) |(cid:20) ∀i zK jφ.
f ∈ F i ,
This means that for all
implies (Mσ ( z
w ∼ j w

(cid:3)) |(cid:20) φ. Therefore, for all w

implies (Mσ ( z

(cid:3) ∈ W , w ∼ j w

(cid:3) ∈ W , for all

f ), w

(cid:3)

(cid:3)

f ∈ F i , for all w
f ), w
As to K iId, suppose that (Mσ , w) |(cid:20) s = s
(cid:3)) because s and s
(cid:3)
(cid:3), w
n . Proving that the axioms of Q .S5var
Q.S5var
validity can be done similarly as in the previous case.

(cid:3)) |(cid:20) φ, that is, (Mσ , w) |(cid:20) K j∀i zφ.
(cid:3)
are global terms. Therefore (Mσ , w

and w ∼ j w

Iσ (s

(cid:3)

. By the ﬁrst hypothesis Iσ (s, w) = Iσ (s
(cid:3)).

and (Mσ , w) |(cid:20) K i(s = s

(cid:3)) |(cid:20) s = s

(cid:3)

(cid:3), w), and Iσ (s, w

(cid:3)) =

n hold on every varying Kripke model, and that the inference rules preserve

Q.S5

reg
n . We show that axiom CBFi−i holds on every regular Kripke model; the rest may be done similarly to the case
(cid:3)), we have

Q .S5n. Assume that (Mσ , w) |(cid:20) K i∀i xφ. This means that for any w
(Mσ (x
implies (Mσ (x
Q.S5

(cid:3)). So, (Mσ , w) |(cid:20) ∀i K i xφ.
a), w
(cid:3)
obj
n . We show that axiom D2 holds in every objectual Kripke model. Assume that (Mσ , w) |(cid:20) D G φ and G ⊆ G
.
(cid:5)
i∈G(cid:3) ∼i implies

(cid:3)
(cid:3)) |(cid:20) φ for any a ∈ D(w

(cid:3)) |(cid:20) φ. But since D i(w) = D i(w

(cid:3) ∈ W , w ∼i w
a), w

implies that for a ∈ D i(w

(cid:3)), w ∼i w
(cid:5)

∼i implies (Mσ , w

(cid:3)) |(cid:20) φ. But G ⊆ G

, so (w, w

(cid:3)) ∈

(cid:3)) ∈

i∈G

(cid:3)

(cid:3)

This means that for any w, w
(Mσ , w

(cid:3) ∈ W , (w, w
(cid:3)) |(cid:20) φ. Therefore, (Mσ , w) |(cid:20) D G(cid:3) φ.

998

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

Q.S56

n. We show that formula (17) holds in SGS 6 = SGS 4 ∩ SGS 5. Assume that f ∈ F i , by the constraint on SGS 4 we
(cid:3)) = a ∈ D i by the constraint on SGS 5. Thus,

(cid:3)) then f (s) = f (s

know that there exists an a = f (s) ∈ D i . Further, if li(s) = li(s
∀i z∃i xK i(z = x) holds.

As regards the left to right implication, we consider the cases for Q .S51
Q.S51

n. Assume that F |(cid:20) ∃i x(d = x) → K i∃i x(d = x), w ∼i w

(cid:3)

n and Q .S53
n .

I(d) = f . This means that (M, w) |(cid:20) ∃i x(d = x), therefore (M, w) |(cid:20) K i∃i x(d = x). Hence, (M, w
tantamount to f (w

(cid:3)) ∈ D i .

and f (w) ∈ D i . Deﬁne a model M based on F such that
(cid:3)) |(cid:20) ∃i x(d = x), which is

Q.S53

n. Assume that F |(cid:20) ∀i zK i∃i x(z = x), w ∈ W , and f ∈ F i . Let M be a model based on F , we have that (M, w) |(cid:20)

∀i zK i∃i x(z = x), in particular (Mσ , w) |(cid:20) ∃i x(z = x), for σ (z) = f . Thus, there exists a ∈ D i such that a = f (w) ∈ D i . (cid:2)

We note that a result similar to Lemma 32 can be obtained also for systems of global states by means of the maps in
Section 2.5. We say that P is a QIS for a system S iff every theorem of S is valid on P , and S is an SGS for S, or S-SGS, iff
every model based on S is a model for S. We write S-SGS for denoting the class of S-SGS.

Lemma 33. Let 2 (cid:2) k (cid:2) 6. The following identities between classes of SGS hold:

Q .S5n-SGS = SGS
Q .S5var
Q .S5reg
Q .S5obj

n -SGS = SGS var
n -SGS = SGS reg
n -SGS = SGS obj
n -SGS = SGS obj
n-SGS = SGSk

Q .S5D

Q .S5k

Proof. The identities above follow from Lemma 32 and the maps in Section 2.5 (cid:2)

4.4. Soundness

In showing that our QML systems are sound and complete axiomatisations of the corresponding classes of system of

global states we ﬁrst prove soundness.

Lemma 34 (Soundness). Every QML system S is sound with respect to the class of frames for S, therefore S is sound also with respect
to the class of SGS for S.

Proof. We observe that by the right to left implication of Lemma 32 if (cid:23)S φ then F |(cid:20) φ, where F belongs to the class of
S-frames. By the deﬁnition of validity on systems of global states, we obtain that (cid:23)S φ implies S |(cid:20) φ, where S belongs to
the class of S-SGS. (cid:2)

We summarise the soundness results in the following table. Let 2 (cid:2) k (cid:2) 6, for any row, the QML system in the ﬁrst
column is sound with respect to the corresponding class of frames in the second column, and therefore it is sound for the
corresponding class of SGS in the third column.

QML systems

Kripke frames

Systems of global states

Q .S5n
Q .S5var
n
Q .S5reg
n
Q .S5obj
n
Q .S5D
n
Q .S5k
n

K
Kvar
Kreg
Kobj
Kobj
Kk

SGS
SGS var
SGS reg
SGS obj
SGS obj
SGSk

4.5. Completeness of Q .S5n

This section is devoted to showing completeness for the QML systems introduced above with respect to the correspond-
ing classes of Kripke frames. The completeness of Q .S5n is proved by means of standard techniques in quantiﬁed modal
logic [16,19,30] suitably extended to ﬁt in the present framework with indexed quantiﬁers and modalities, local terms,
identity. Speciﬁcally, we adopt the particular version of canonical models given by Thomason in [60] for languages with
an existence predicate. As standard, we show that if (cid:2)Q .S5n φ then there exists a Kripke model M such that M (cid:11)|(cid:20) φ. In
particular, we show that the canonical model MQ .S5n for Q .S5n to be deﬁned below is a model according to Deﬁnition 22,
it is based on a frame for Q .S5n and MQ .S5n (cid:11)|(cid:20) φ. Therefore, the following is a suﬃcient condition to prove completeness.

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

999

Proposition 35. If Q .S5n does not prove a formula φ ∈ Ln, then the canonical model MQ .S5n for Q .S5n does not validate φ.

This result relies on two lemmas: the saturation lemma and the truth lemma. Their proofs need the following deﬁnitions,

where Liφ is deﬁned as ¬K i¬φ and Λ is any set of formulas in Ln:

Λ is consistent
Λ is maximal
Λ is max-cons
Λ is rich

Λ is L j-rich

Λ is saturated

⊥;

for every φ ∈ Ln, either φ ∈ Λ or ¬φ ∈ Λ;

iff Λ (cid:2)Q .S5n
iff
iff Λ is consistent and maximal;
iff ∃i yφ ∈ Λ implies that there is a term t ∈ Ln

such that Admi(t) ∧ φ[ y/t] ∈ Λ;

iff φ0 ∧ L j(φ1 ∧ · · · ∧ L j(φk ∧ L j∃i yφk+1) . . .) ∈ Λ

for y not free in φ0, . . . , φk implies there is t ∈ Ln such that
φ0 ∧ L j(φ1 ∧ · · · ∧ L j(φk ∧ L j(Admi(t) ∧ φk+1[ y/t])) . . .) ∈ Λ,

iff Λ is max-cons, rich and L j-rich, for every j ∈ A

The constraint on L j -richness, which is due to Thomason [60], is needed in order to guarantee that the canonical model for
Q .S5n has a single outer domain D. We brieﬂy sketch the proof of the saturation lemma and refer to [30] for details; the
extension to the multi-modal case is straightforward.

Lemma 36 (Saturation lemma). If (cid:7) is a consistent set of the formulas in Ln, then it can be extended to a saturated set Π on some
expansion L+
n obtained by adding to Ln an inﬁnite set of new local constants and an inﬁnite set of new global constants.

Proof. Let θ0, θ1, . . . be an enumeration of the formulas in L+
constants m0, m1, . . . . We deﬁne by recursion a chain of sets of formulas in L+

n as follows:

n , and let there be enumerations of the new global and local

Γ0 = (cid:7)

Γ2n+1 =

Γ2n+2 =

(cid:6)

⎧
⎪⎨

⎪⎩

Γ2n ∪ {Admi(m2n) ∧ θn[ y/m2n]}

if Γ2n ∪ {∃ yθn} is consistent and
m2n /∈ Γ2n ∪ {θn} is the ﬁrst new constant;

otherwise

Γ2n
Γ2n+1 ∪ {φ0 ∧ L j(φ1 ∧ · · · ∧ L j(φk ∧ L j(Admi(m2n+1) ∧ φk+1[ y/m2n+1])) . . .)}

if Γ2n+1 ∪ {φ0 ∧ L j(φ1 ∧ · · · ∧ L j(φk ∧ L j∃i yφk+1) . . .)} is consistent
and m2n+1 is the ﬁrst variable not in Γ2n+1, φ1, . . . , φk+1;

Γ2n+1 otherwise

By induction we can prove that every Γn is consistent. Thus, by the chain lemma Γ =

n∈N Γn is a consistent, rich and
n , for every j ∈ A. By Lindenbaum’s lemma Γ can be extended to a saturated set Π ⊇ (cid:7) in

L j -rich set of formulas in L+
L+
n . (cid:2)

(cid:11)

As a result, if (cid:2)Q .S5n φ then the set {¬φ} is consistent and by the saturation lemma we obtain a saturated set Π ⊇ {¬φ}.
In order to introduce the canonical model MQ .S5n for Q .S5n we need a few more deﬁnitions. For closed global terms
(cid:3)} to be the equivalence
(cid:3)
, deﬁne v ∼w v

(cid:3)) ∈ w. This is an equivalence relation and we take [v]w = {v

(cid:3) | v ∼w v

iff (v = v

(cid:3)

v, v
class of v in w.

The accessibility relation in MQ .S5n is deﬁned so that w R i w

(cid:3)

iff {φ | K iφ ∈ w} ⊆ w

(cid:3)

: by axioms T , 4 and 5 we can show

that R i is an equivalence relation.

Further, by axioms K i Id and K iDif the deﬁnition of [v]w is provably independent from the choice of w and v – i.e.,
implies [v]w = [v]w(cid:3) – so we simply write [v]. We deﬁne each D i(w) as the set {[v] | Admi(v) ∈ w}. By NecAdm and

w R i w
Nec¬Adm we can show that also this deﬁnition is independent from the choice of w, therefore we simply write D i .

(cid:3)

Moreover, for every closed local term r we introduce a function fr such that:

(cid:12)

fr(w) =

[v]
{r

(cid:3) | (r

if there is a v such that (r = v) ∈ w;

(cid:3) = r) ∈ w} otherwise

Each F i(w) is the set { fr | Admi(r) ∈ w}: by NecAdm and Nec¬Adm also this deﬁnition is provably independent from the
choice of w, so we simply write F i .

Given these deﬁnitions, we present the canonical model for Q .S5n as follows:

Deﬁnition 37. The canonical model for Q .S5n on the language Ln, with an expansion L+
n ,
(cid:8)W , {R i}i∈ A, D, {D i}i∈ A, F , {F i}i∈ A, I(cid:9) such that:

is the tuple MQ .S5n =

• W is the set of all saturated sets of formulas in L+
n ;
(cid:3)
• for i ∈ A, w, w
;

iff {φ | K iφ ∈ w} ⊆ w

(cid:3) ∈ W , w R i w

(cid:3)

1000

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

• the domain D of individuals is the set {[v] | v ∈ L+
n

} ∪ { fr(w) | r ∈ L+

n , w ∈ W }, and for each i ∈ A, D i = {[v] | Admi(v) ∈

w};

• the domain F of intensional objects is the set { fr | r ∈ L+
• I is an interpretation of L+
◦ I(c) = [c] and I(d) = fd;
◦ for a1, . . . , ak ∈ D ∪ F , I( f k)((cid:18)a) is a function such that

n such that:

n

(cid:12)

I( f k)((cid:18)a)(w) =

[ f k((cid:18)v)]
f f k((cid:18)e)(w)

if every ai = [v i];
for ei = v i if ai = [v i], or ei = ri if ai = fri

}, and for each i ∈ A, F i = { fr | Admi(r) ∈ w};

◦ for a1, . . . , ak ∈ D, (cid:8)(cid:18)a(cid:9) ∈ I(P k, w) iff P k((cid:18)e) ∈ w, for ei = v i and ai = [v i], or ei = ri and ai = fri (w).

Note that the interpretation of functions and predicates is well deﬁned by axioms F unc and Subst. The following propo-

sition holds by the remarks above.

Proposition 38. The canonical model MQ .S5n for Q .S5n satisﬁes the constraints in Deﬁnition 22, so MQ .S5n is a Kripke model.

Proof. Assume that (cid:2)Q .S5n φ, then the set {¬φ} is consistent, so by Lemma 36 it can be extended to a saturated set of
formulas in L+
n . Therefore, the set W of possible worlds is non-empty. We remarked that by axioms T , 4 and 5, each
relation R i is reﬂexive, transitive and euclidean, i.e., it is an equivalence relation. Further, the domains D and F are non-
empty by deﬁnition of L+
n , and each D i (respectively F i ) is trivially a subset of D (respectively F ). Finally, the interpretation
I is well-deﬁned and satisﬁes the constraints on Kripke models by the remarks above. (cid:2)

Now let σ be an assignment for local and global variables into D and F respectively, we can show the following:

Lemma 39. For every w ∈ M, t ∈ L+

n , for σ ( yi) = I(ei),

Iσ (t[(cid:18)y], w) = I(t[(cid:18)y/(cid:18)e])(w)

Proof. This can be shown by induction on the length of t. We give the proof for t = f (t1, . . . , tk), y = z, and e = d:

Iσ (t[z], w) = Iσ ( f (t1[z], . . . , tk[z]), w) = I( f )(Iσ (t1[z], w), . . . , Iσ (tk[z], w))

= I( f )(I(t1[z/d])(w), . . . , I(tk[z/d])(w))
= I( f )(I(t1[z/d]), . . . , I(tk[z/d]))(w)
= I( f (t1[z/d], . . . , tk[z/d]))(w)
= I( f (t1, . . . , tk)[z/d])(w)
= I(t[z/d)(w)

(cid:2)

By Lemma 39 the base case of the truth lemma below follows. In the rest of this section we simply write M for MQ .S5n .

Lemma 40 (Truth lemma). For every w ∈ M, φ ∈ L+

n , for σ ( yi) = I(ei),

(Mσ , w) |(cid:20) φ[(cid:18)y]

iff φ[(cid:18)y/(cid:18)e] ∈ w

Proof. The proof is by induction on the structure of φ ∈ L+
n .

φ = P k(t1, . . . , tk). By the deﬁnition of satisfaction and Lemma 39:

(Mσ , w) |(cid:20) P k(t1, . . . , tk)[(cid:18)y]

iff

iff

iff

(cid:8)Iσ (t1[(cid:18)y], w), . . . , Iσ (tk[(cid:18)y], w)(cid:9) ∈ I(P k, w)
(cid:8)I(t1[(cid:18)y/(cid:18)e])(w), . . . , I(tk[(cid:18)y/(cid:18)e])(w)(cid:9) ∈ I(P k, w)
P k(t1[(cid:18)y/(cid:18)e], . . . , tk[(cid:18)y/(cid:18)e]) ∈ w

. Similar to the previous case.

(cid:3)
φ = t = t
φ = ¬ψ, ψ → ψ (cid:3)
the canonical model.

. The cases for the propositional connectives follow by the maximality and consistency of the worlds in

φ = ∀i zψ . ⇐ Assume that ∀i zψ[z, (cid:18)y/(cid:18)e] ∈ w and f

Admi(r), then ψ[r, (cid:18)y/(cid:18)e] ∈ w by Ex. By the induction hypothesis (Mσ , w) |(cid:20) ψ[r, (cid:18)y], therefore (Mσ ( z
the arbitrariness of the variant σ

we obtain (Mσ , w) |(cid:20) ∀i zψ[z, (cid:18)y].

(cid:3)

(cid:2)

is an individual in F i . This means that f = fr , for some r such that
fr), w) |(cid:20) ψ[z, (cid:18)y]. By

z
fr

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

1001

⇒ Assume that ∀i zψ[z, (cid:18)y/(cid:18)e] /∈ w. Since w is max-cons, ∃i z¬ψ[z, (cid:18)y/(cid:18)e] ∈ w. But w is rich, so there exists d ∈ LCon such
that Admi(d) ∧ ¬ψ[d, (cid:18)y/(cid:18)e] ∈ w. This means that fd ∈ F i and by induction hypothesis (Mσ , w) (cid:11)|(cid:20) ψ[d, (cid:18)y]. Thus, there is
fd ∈ F i such that (Mσ ( z

, w) (cid:11)|(cid:20) ψ[z, (cid:18)y], i.e., (Mσ , w) (cid:11)|(cid:20) ∀i zψ[z, (cid:18)y].

)

fd

φ = ∀i xψ . The proof goes as in the previous case.
φ = K iψ . ⇐ Assume that K iψ[(cid:18)y/(cid:18)e] ∈ w and w R i w

(Mσ , w

(cid:3)) |(cid:20) ψ[(cid:18)y]. Thus, (Mσ , w) |(cid:20) K iψ[(cid:18)y].
(cid:13)

⇒ Assume that K iψ[(cid:18)y/(cid:18)e] /∈ w. Note that the set {φ | K iφ ∈ w} ∪ {¬ψ[(cid:18)y/(cid:18)e]} is consistent: if not, there would be
K iφ ∈ w, also
φ1, . . . , φm ∈ {φ | K iφ ∈ w} such that (cid:23)
K iψ[(cid:18)y/(cid:18)e] ∈ w against hypothesis. Since {φ | K iφ ∈ w} ∪ {¬ψ[(cid:18)y/(cid:18)e]} is consistent, we can extend it to a saturated set
(cid:3)) |(cid:20) ¬ψ[(cid:18)y] by induction hypothesis. Hence,
(cid:3)
w
(Mσ , w) (cid:11)|(cid:20) K iψ[(cid:18)y]. (cid:2)

(see [60] for further details) such that w R i w

φ → ψ[(cid:18)y/(cid:18)e]. By axiom K , (cid:23)

K iφ → K iψ[(cid:18)y/(cid:18)e] and since

and (Mσ , w

on L+
n

(cid:13)

(cid:13)

(cid:3)

(cid:3)

. By deﬁnition of R i , ψ[(cid:18)y/(cid:18)e] ∈ w

(cid:3)

and by induction hypothesis

By the truth lemma we conclude that the canonical model M is a model for Q .S5n, based on a Kripke frame, falsifying

any unprovable formula φ. Thus, we state the following completeness result.

Theorem 41 (Completeness). The system Q .S5n is complete with respect to the class K of Kripke frames, i.e., K |(cid:20) φ implies (cid:23)Q .S5n φ.

Further, we have completeness also with respect to systems of global states. In fact, if (cid:2)Q .S5n φ then by Theorem 41
there exists a model M = (cid:8)F , I(cid:9) based on a frame F , which falsiﬁes φ. Deﬁne the quantiﬁed interpreted system P as
(cid:8)g(F ), I(cid:9): by deﬁnition P |(cid:20) φ iff P f = (cid:8) f (g(F )), I(cid:9) models φ, but by Lemma 14 the frame f (g(F )) is isomorphic to F .
Hence, P (cid:11)|(cid:20) φ. As a consequence, the following implications hold:

SGS |(cid:20) φ ⇒ K |(cid:20) φ ⇒ (cid:23)Q .S5n φ

and we have a further completeness result.

Corollary 42 (Completeness). The system Q .S5n is complete with respect to the class SGS of systems of global states, i.e., SGS |(cid:20) φ
implies (cid:23)Q .S5n φ.

By combining together the soundness and completeness theorems we obtain the main result of this section.

Corollary 43 (Soundness and completeness). For every φ ∈ Ln,

SGS |(cid:20) φ iff (cid:23)Q .S5n φ

We conclude that Q .S5n is a sound and complete axiomatisation of the validities on the general class of systems of

global states.

4.6. Completeness for other axiomatisations

We now show how to modify the techniques applied in the previous subsection to obtain completeness also for the

other classes of Kripke frames and systems of global states considered. We start with varying and regular frames.

Theorem 44 (Completeness). The system Q .S5var

n

is complete with respect to the class Kvar of varying frames.

Proof. If a formula φ ∈ Ln is not provable in Q .S5var
as in
Deﬁnition 37. Note that neither NecAdm nor Nec¬Adm are theorems in Q .S5var
n , so we cannot show that the various D i(w) =
{[v] | Admi(v) ∈ w} and F i(w) = { fr | Admi(r) ∈ w} are independent from the choice of w. However, we can prove that the
canonical model is based on a varying Kripke frame. Also, Proposition 38 and Lemmas 39, 40 hold also for MQ .S5var
n , as their
proofs do not require the Barcan formulas. Therefore, the canonical model MQ .S5var
satisﬁes ¬φ and we have completeness
for varying frames. (cid:2)

n , then we deﬁne the canonical model MQ .S5var

for Q .S5var

n

n

n

Theorem 45 (Completeness). The system Q .S5reg
n

is complete with respect to the class Kreg of regular frames.

Proof. As regards Q .S5reg
on regular frames, i.e.,

n , we show that the canonical model MQ .S5

reg
n deﬁned as in Deﬁnition 37 satisﬁes constraint (7)

• for all w, w

(cid:3) ∈ W , w R i w

(cid:3)

implies D i(w) = D i(w

(cid:3)) and F i(w) = F i(w

(cid:3)).

1002

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

(cid:3)

Assume that w R i w
that Admi(v) → K iAdmi(v) ∈ w, and by deﬁnition of R i also Admi(v) ∈ w
the inclusion follows by symmetry of R i . The proof of F i(w) = F i(w
hold also for MQ .S5

and Admi(v) ∈ w. By the restricted version CBFi−i of the converse of the Barcan formula we can show
(cid:3)). The other direction of
(cid:3)) is similar. Further, Proposition 38 and Lemmas 39, 40

n , therefore we have completeness for regular frames. (cid:2)

. Thus, D i(w) ⊆ D i(w

reg

(cid:3)

By axiomatising the class of regular SGS we showed that the restricted versions of the Barcan formulas considered are

powerful enough to characterise the idea of quantiﬁcation domains as part of agents’ local state.

We now consider the completeness results for systems Q .S5obj
n

and Q .S5D

be a formula not provable in Q .S5obj
terms.

n , we deﬁne the canonical model for Q .S5obj

n

n with respect to objectual frames. Let φ ∈ Lobj
as the restriction of MQ .S5n to constant

n

Deﬁnition 46. The canonical model for Q .S5obj
n
(cid:8)W , {R i}i∈ A, D, {D i}i∈ A, I(cid:9) such that:

on the language Lobj

n , with an expansion Lobj+

n

, is the tuple MQ .S5

obj
n =

• W is the set of all saturated sets of formulas in Lobj+
n
• for i ∈ A, R i and D i are deﬁned as in Deﬁnition 37;
• D = {[v] | v ∈ Lobj+
• I is an interpretation of Lobj+

such that:

};

n

;

n

◦ I(c) = [c];
◦ for a1, . . . , ak ∈ D, I( f k)((cid:18)a) = [ f k((cid:18)v)], for ai = [v i];
◦ for a1, . . . , ak ∈ D, (cid:8)(cid:18)a(cid:9) ∈ I(P k, w) iff P k((cid:18)v) ∈ w, for ai = [v i].

Proposition 38 and Lemmas 39 and 40 hold also for MQ .S5

obj
n : the proof is similar to those presented earlier. It follows

that the canonical model MQ .S5

obj
n

satisﬁes ¬φ, so we have completeness for objectual frames:

Theorem 47 (Completeness). The system Q .S5obj
n

is complete with respect to the class Kobj of objectual frames.

As regards the system Q .S5D

n , we extend to ﬁrst-order the completeness proof in [15] for proposional systems with
distributed knowledge consisting in unravelling the canonical model to obtain a model which is a tree. Note that an inde-
pendent completeness proof for these systems appeared in [28].

First, we consider the following deﬁnition of canonical model, where ℘+( A) is the set of non-empty subsets of A:

Deﬁnition 48. The canonical model for Q .S5D
(cid:8)W , {Rl}
l∈ A∪℘+( A), D, {D i}i∈ A, I(cid:9) such that:

n on the language LD

n , with an expansion LD+

n

, is the tuple MQ .S5D

n =

• W is the set of saturated sets of formulas in LD+
• for i ∈ A, R i , D i , and D, I are deﬁned as in Deﬁnition 46;
• for G ∈ ℘+( A), w R G w

iff {φ | D G φ ∈ w} ⊆ w

;

n

.

(cid:3)

(cid:3)

Lemma 36 holds also for the system Q .S5D

n . Therefore, if (cid:11)(cid:23)

φ there exists a saturated set w ⊇ {¬φ}, so the set W

Q .S5D
n

of possible worlds in MQ .S5D
relations. Moreover, by axioms D1 and D2 it follows that R{i} is equal to R i and R G ⊆
(cid:5)

n is non-empty. By using axioms T , 4 and 5 we can show that the various R G are equivalence
i∈G R i . However, in general R G (cid:11)=
i∈G R i [15]. This remark gives the rationale for introducing the pseudo-satisfaction relation |(cid:20)p , deﬁned as |(cid:20) but for the

(cid:5)

distributed knowledge operator D G (in what follows we simply write M for MQ .S5D

n ):

(Mσ , w) |(cid:20)p D G ψ iff

for every w

(cid:3) ∈ W , w R G w

(cid:3)

implies (Mσ , w

(cid:3)

) |(cid:20)p ψ

We state the truth lemma for the pseudo-satisfaction relation |(cid:20)p . The proof follows the one for Lemma 40, the distributed

knowledge operator D G being treated as the epistemic operator K i .

Lemma 49 (Truth lemma). For w ∈ M, ψ ∈ LD+

n

, for σ (xi) = [v i],

(Mσ , w) |(cid:20)p ψ[(cid:18)x]

iff ψ[(cid:18)x/(cid:18)v] ∈ w

M(cid:3)

We now show that the techniques in [15] can be extended to ﬁrst-order so that M can be unwound into a structure
satisfying the same formulas.
In order to introduce M(cid:3)

we need a few more deﬁnitions. Let w, w

be worlds in W , a path from w to w

is a sequence

(cid:3)

(cid:3)

(cid:8)w 1, l1, w 2, l2, . . . , lk−1, wk(cid:9) such that:

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

1003

(cid:3) = wk;

(1) w = w 1 and w
(2) w 1, . . . , wk ∈ W ;
(3) each l j is either an agent or a set of agents;
(4) (cid:8)w j, w j+1(cid:9) ∈ Rl j .

The reduction of a path (cid:8)w 1, i1, w 2, i2, . . . , ik−1, wk(cid:9) is obtained by replacing each maximal consecutive subsequence
(cid:8)wq, iq, wq+1, iq+1, . . . , ir−1, wr(cid:9) where iq = iq+1 = · · · = ir−1 by (cid:8)wq, iq, wr(cid:9). A path is said to be reduced is it is equal
to its reduction.

l∈ A∪℘+( A), D, {D i}i∈ A, I(cid:9) we deﬁne a structure M∗ = (cid:8)W

is a tree, that is, for all w, w

(cid:3)); (iii) w R

(cid:3)

∗
G w

implies h(w)R G h(w

(cid:3) ∈ W

∗
l

∗, {R
∗

∗,
}
l∈ A∪℘+( A), D
, there is at most
(cid:3)); (iv) (cid:8)a1, . . . , ak(cid:9) ∈

(cid:3)

I

Given the canonical model M = (cid:8)W , {Rl}
∗
}i∈ A, I
i

∗ → W such that (i) M∗
∗(cid:9) and a surjective function h : W
∗
implies h(w)R ih(w
; (ii) w R
i w

{D
one reduced path from w to w
∗(P k, w) iff (cid:8)a1, . . . , ak(cid:9) ∈ I(P k, h(w)).
The set of possible worlds W
∗
(cid:3) ∈ W and l is an agent or group of agents. Let W
such that w ∈ W
k , w
∗
h(w) = w, for w ∈ W
, for w ∈ W
1 and h(v w,l,w(cid:3) ) = w
(cid:3) = v w,l,w(cid:3)(cid:3) , for some w
∗
relation deﬁned for w, w
refer to [15] for a proof that M∗

is deﬁned by induction. Let W

∗
k . Further, R

(cid:3) ∈ W

∗
l

∗

(cid:3)

(cid:3)

∗ =

∗
1 be W , and deﬁne W
(cid:11)

∗
k+1 as the set of worlds v w,l,w(cid:3)
∗
∗ → W by letting
k , then deﬁne h : W
is the reﬂexive, symmetric and transitive closure of the
∗(P k, w) = I(P k, h(w)). We

(cid:3)). Finally, I

k∈N W

if w
and h satisfy (i)–(iv) above. In particular, we can show what follows:

(cid:3)(cid:3) ∈ W , and h(w)Rlh(w

Lemma 50. For w ∈ W

∗

, ψ ∈ LD+

n

, we have

(M∗σ , w) |(cid:20)p ψ iff

(Mσ , h(w)) |(cid:20)p ψ

Finally, we make use of the structure M∗

to deﬁne a Kripke model M(cid:3)

that falsiﬁes the unprovable formula φ.

Deﬁnition 51. The model M(cid:3) = (cid:8)W

(cid:3), {R

(cid:3)
i

}i∈ A, D

(cid:3), {D

(cid:3)
i

}i∈ A, I

(cid:3)(cid:9) is deﬁned as follows:

∗

(cid:3) = D
(cid:3) = W
• W
(cid:3)
• R
i is the transitive closure of R

∗
i , and I
∗
∪
i

= D

, D

, D

(cid:3)
i

∗

∗

(cid:3) = I
(cid:11)

;
i∈G R

∗
G .

Since the various R

result about M(cid:3)

and refer to [15] for further details.

∗
i and R

∗
G are reﬂexive, transitive and symmetric, R

(cid:3)
i is an equivalence relation. We state the following

Lemma 52. For w ∈ W

(cid:3)

, ψ ∈ LD+

n

, the following holds

(M(cid:3)σ , w) |(cid:20) ψ iff

(M∗σ , w) |(cid:20)p ψ

In conclusion, if φ ∈ LD

By Lemma 50 also M∗
completeness result.

n is not provable in Q .S5D
pseudo-satisﬁes ¬φ, and by the result above M(cid:3)

n , then the canonical model MQ .S5D

n pseudo-satisﬁes ¬φ by Lemma 49.
does not validate φ. Hence, we have the following

Theorem 53 (Completeness). The system Q .S5D

n is complete with respect to the class of objectual frames.

Finally, we show that formulas (13)–(17) are suﬃcient to guarantee that the canonical models for the systems Q .S5k

n, for

2 (cid:2) k (cid:2) 6, deﬁned as in Deﬁnition 37, satisfy the corresponding constraints.

Theorem 54 (Completeness). For 2 (cid:2) k (cid:2) 6, the system Q .S5k

n is complete with respect to the class Kk of Kripke frames.

Proof. We show that the canonical models for the systems Q .S5k
classes Kk of Kripke frames.

n, for 2 (cid:2) k (cid:2) 6, satisfy the respective constraint on the

(cid:3)

(cid:3)

(cid:3)

Q.S51

there exists v

and f (w) ∈ D i . If

n. Assume that w ∼i w

fr(w) = [v], for some v such that Admi(v) ∈ w. This means that (r = v) ∈ w, therefore ∃xi(r = x) ∈ w
(cid:3)) ∈ w
richness of w
Q.S52
Q.S53

n. This can be shown as above, but this time f = fr , for some closed local term r, belongs to F i .
n. Assume that f = fr ∈ F i for some closed local term r, then K i∃i x(r = x) ∈ w by formula (15), and in particular
∃i x(r = x) ∈ w. By the richness of w there exists v such that Admi(v) ∈ w and (r = v) ∈ w. Therefore, there exists [v] ∈ D i
such that fr(w) = [v].

f ∈ F then f = fr for some closed local term r, and by hypothesis
by formula (13). By

such that Admi(v

n. Assume that f = fr for some closed local term r belongs to F i ,

. By hypothesis there
(cid:3)
exists a closed term t such that I(t) = a ∈ D and (r = t) ∈ w. By formula (16) this implies that K i(r = t) ∈ w and (r = t) ∈ w
.
Thus fr(w) = fr(w

fr(w) = a ∈ D, and w ∼ w

. Thus, fr(w

and (r = v

(cid:3)) ∈ D i .

(cid:3)) ∈ w

Q.S54

(cid:3)).

(cid:3)

(cid:3)

(cid:3)

(cid:3)

1004

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

n. Since formula (17) is equivalent to the conjunction of formulas (15) and (16), we can prove that for f ∈ F i ,
Q.S55
(cid:3)
implies f (w) = f (w
w ∼i w

(cid:3)) ∈ D i .

As a result, we have completeness with respect to all the relevant classes of frames. (cid:2)

As for system Q .S5n, for every QML system S from completeness with respect to Kripke frames we can derive com-
pleteness for systems of global state. In fact, if (cid:2)S φ then by Kripke completeness there exists a model M = (cid:8)F , I(cid:9) based
on a S-frame F , which falsiﬁes φ. Deﬁne the quantiﬁed interpreted system P as (cid:8)γ (F ), I(cid:9), where γ is the relevant map
from S-frames to SGS for S. By deﬁnition P |(cid:20) φ iff Pϕ = (cid:8)ϕ(γ (F )), I(cid:9) models φ, where ϕ is the relevant map from SGS
for S to S-frames. By the results in Section 2.6, the frame ϕ(γ (F )) is isomorphic to F . Hence, P (cid:11)|(cid:20) φ. Thus, the following
implications hold:

S-SGS |(cid:20) φ ⇒ S-K |(cid:20) φ ⇒ (cid:23)S φ

and we have a further completeness result.

Corollary 55 (Completeness). Every QML system S is complete with respect to the class S-SGS of the systems of global states for S,
that is, S-SGS |(cid:20) φ implies (cid:23)S φ.

By combining together the soundness and completeness theorems we obtain the main result of this section.

Corollary 56 (Soundness and Completeness). For every formula φ in the language of S,

S-SGS |(cid:20) φ iff (cid:23)S φ

We conclude that our QML systems are sound and complete axiomatisations of the validities on the corresponding classes

of systems of global states. The corollary below summarises the main formal results of this paper.

Corollary 57. Let 2 (cid:2) k (cid:2) 6, for every row, the QML system in the ﬁrst column of the following table is a sound and complete axioma-
tisation with respect to the corresponding class of Kripke frames and systems of global states:

QML systems

Kripke frames

Systems of global states

Q .S5n
Q .S5var
n
Q .S5reg
n
Q .S5obj
n
Q .S5D
n
Q .S5k
n

K
Kvar
Kreg
Kobj
Kobj
Kk

SGS
SGS var
SGS reg
SGS obj
SGS obj
SGSk

5. Applications to multi-agent systems

In this section we show how simple MAS scenarios can be modelled by means of quantiﬁed interpreted systems. Specif-
ically, in Section 5.1 we analyse the scenario of battleﬁeld, and in Section 5.2 we consider an inﬁnite version of the muddy
children puzzle. Section 6 deals with a more complex application: a formal analysis of message passing systems. We main-
tain that these investigations show some of the advantages of ﬁrst-order formalisms.

5.1. Battleﬁeld

In this subsection we model the popular game of battleﬁeld as a quantiﬁed interpreted system, then we describe it by
means of the language Ln, for n = 4. We start by considering a set of agents A = {1, 2, 3, 4}, and we assume that each agent
is assigned a quadrant in the region Z × Z as domain of quantiﬁcation:

D4 = {(x, y) | x ∈ Z−, y ∈ Z+}
D3 = {(x, y) | x, y ∈ Z−}

D1 = {(x, y) | x, y ∈ Z+}
D2 = {(x, y) | x ∈ Z+, y ∈ Z−}

Intuitively, the set D i represents the country of agent i. Note that, even though in the battleﬁeld game only a ﬁnite subset
of Z × Z is considered, in several scenarios either we are not able, or do not want, to bound in advance the size of the
game board. Thus, it can be useful to introduce a potentially inﬁnite playing board, even though at each step only a ﬁnite
portion is considered.

We assume that each agent has 5 military units, whose positions are recorded in his local state. Further, we consider
couples (x, y) ∈ D i and triples (k, x, y), for 1 (cid:2) k (cid:2) 5, to express that there is a military unit at (x, y) and that the k-th
military unit is at (x, y) respectively.

The local state li of agent i is deﬁned as a 4-tuple (cid:8)α1, α2, α3, α4(cid:9) such that:

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

1005

• αi is a 5-tuple (cid:8)(1, x1, y1), . . . , (5, x5, y5)(cid:9) recording the positions of agent i’s units.
• for j (cid:11)= i, α j is a possibly empty sequence of triples (k, x, y) and couples (x, y) recording the positions and identities of

agent i’s enemies’ units.

Also, le is the local state of the environment recording the positions and identities of all units in similar fashion.

The set S contains the global states s = (cid:8)le, l1, l2, l3, l4(cid:9) such that if either (x, y) ∈ α j(li) or (k, x, y) ∈ α j(li), then (k, x, y) ∈
αi(li). So, an agent may not know the position or the identity of an enemy unit, but if she does, then she cannot be wrong.
Each domain F i of intensional objects contains the military units mui.k, for 1 (cid:2) k (cid:2) 5, such that mui.k(s) = (x, y) iff the
triple (k, x, y) belongs to the component αi of the local state li(s). Moreover, we assume that our language has global and
local constants for denoting the individuals in the various D i and F i . We use the same notation for syntactic and semantic
elements as the former mirror the latter, the context will disambiguate. Finally, let D contain the real numbers, i.e., D ⊇ R.
The quantiﬁed interpreted system P contains all the global states consistent with the deﬁnitions above. In particular,
suppose that the initial state s = (cid:8)le, l1, l2, l3, l4(cid:9), describing the position of the military units at the beginning, is deﬁned as
follows:

l1(s) = (cid:8)(cid:8)(1, 2, 2), (2, 6, 5), (3, 2, 7), (4, 4, 12), (5, 7, 9)(cid:9), (cid:8)(cid:9), (cid:8)(cid:9), (cid:8)(cid:9)(cid:9)
l2(s) = (cid:8)(cid:8)(cid:9), (cid:8)(1, 3, −3), (2, 7, −2), (3, 6, −5), (4, 3, −6), (5, 8, −9)(cid:9), (cid:8)(cid:9), (cid:8)(cid:9)(cid:9)
l3(s) = (cid:8)(cid:8)(cid:9), (cid:8)(cid:9), (cid:8)(1, −3, −3), (2, −3, −6), (3, −6, −3), (4, −6, −8), (5, −8, −5)(cid:9), (cid:8)(cid:9)(cid:9)
l4(s) = (cid:8)(cid:8)(cid:9), (cid:8)(cid:9), (cid:8)(cid:9), (cid:8)(1, −4, 4), (2, −3, 9), (3, −7, 7), (4, −5, 12), (5, −8, 11)(cid:9)(cid:9)

The QIS P containing s describes a situation in which the ﬁrst military unit of agent 1 is positioned at (2, 2). In particular,

agent 1 knows this fact:

(P, s) |(cid:20) K1∃1z(z = (2, 2)) and also (P, s) |(cid:20) ∃1zK1(z = (2, 2))

while agent 3 does not know this:

(P, s) |(cid:20) ¬∃1zK3(z = (2, 2)) and also (P, s) |(cid:20) ¬K3∃1z(z = (2, 2))

Thus, agent 1 has not only de dicto knowledge that one of his military units is at (2, 2), but he also has de re knowledge of
the ﬁrst of his units being at (2, 2).

Consider now a function dist returning the distance between two points in Z × Z as a real number:

(cid:14)

(cid:3)
I(dist)((x, y), (x

, y

(cid:3)

)) =

(x − x(cid:3))2 + ( y − y(cid:3))2

We can check that agent 2 starts with all his military units within a distance of less than 8. Further, he knows this fact, but
agent 4 does not. To express this, we introduce a relation symbol < with the obvious interpretation “less than”.

(P, s) |(cid:20) ∀2z, z

(cid:3)

K2(dist(z, z

(cid:3)

) < 8) but

(P, s) (cid:11)|(cid:20) ∀2z, z

(cid:3)

K4(dist(z, z

(cid:3)

) < 8)

The latter formula fails as agent 4’s local state is consistent with a different state s
units at a distance greater than 8, that is, l4(s

(cid:3)(cid:3)(cid:3)) = l4(s) but for instance

(cid:3)(cid:3)(cid:3)

such that l2(s

(cid:3)(cid:3)(cid:3)) contains two military

(cid:3)(cid:3)(cid:3)

l2(s

Note that s

) = (cid:8)(cid:8)(cid:9), (cid:8)(1, 30, −30), (2, 7, −2), (3, 6, −5), (4, 3, −6), (5, 8, −9)(cid:9), (cid:8)(cid:9), (cid:8)(cid:9)(cid:9)
(cid:3)(cid:3)(cid:3) ∈ P by deﬁnition of P .

Further, consider a global constant ﬁredist representing the maximum range of ﬁre of the military units and set it to 8,

i.e., I(ﬁredist) = 8. We can express the fact that the units z and z

(cid:3)

are within ﬁre range by the following formula:

FDist(z, z

(cid:3)

) ::= dist(z, z

(cid:3)

) < ﬁredist

The following expression speciﬁes that in the present QIS every agent has at least one unit which is not within the ﬁre
range of any other enemy unit:
(P σ , s) |(cid:20) ∃i z∀ j z

(cid:3)¬FDist(z, z

for j (cid:11)= i

),

(cid:3)

Now suppose that hostilities break out in our scenario and agent 3 somehow acquires the knowledge that one of agent 1’s
military units is at (2, 2). The resulting state s

differs from s only for the local state of agent 3:

(cid:3)

(cid:3)

l3(s

) = (cid:8)(cid:8)(2, 2)(cid:9), (cid:8)(cid:9), (cid:8)(1, −3, −3), (2, −3, −6), (3, −6, −3), (4, −6, −8), (5, −8, −5)(cid:9), (cid:8)(cid:9)(cid:9)

As a consequence, agent 3 acquires de dicto knowledge that the ﬁrst of his units is within the range of enemy ﬁre, even if
she does not know this fact de re, that is, she does not know which of agent 1’s units actually threatens agent 3’s ﬁrst unit.

(cid:3)

(P, s

) |(cid:20) ∃3zK3∃1z

(cid:3)

FDist(z, z

(cid:3)

) but

(cid:3)

(P, s

) (cid:11)|(cid:20) ∃3z∃1z

(cid:3)

K3FDist(z, z

(cid:3)

)

1006

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

This is because the following local states for agent 1 is consistent with agent 3’s local state in s
such that l3(s

(cid:3)(cid:3)(cid:3)(cid:3)) = l3(s

(cid:3)) and

(cid:3)

, i.e., there is a state s

(cid:3)(cid:3)(cid:3)(cid:3)

(cid:3)(cid:3)(cid:3)(cid:3)

l1(s

) = (cid:8)(cid:8)(2, 2, 2), (1, 6, 5), (3, 2, 7), (4, 4, 12), (5, 7, 9)(cid:9), (cid:8)(cid:9), (cid:8)(cid:9), (cid:8)(cid:9)(cid:9)

Now suppose that agent 1 discovers unit mu3.1’s position. The change in his local state is recorded in the global state s
differing from s

(cid:3)

as to l1:

(cid:3)(cid:3)

(cid:3)(cid:3)

l1(s

) = (cid:8)(cid:8)(1, 2, 2), (2, 6, 5), (3, 2, 7), (4, 4, 12), (5, 7, 9)(cid:9), (cid:8)(cid:9), (cid:8)(1, −3, −3)(cid:9), (cid:8)(cid:9)(cid:9)

Then, agent 1 too knows that one of his units is within the range of enemy ﬁre. In particular, she has de re knowledge of
this fact, i.e., she knows the identity of agent 3’s unit:

(cid:3)(cid:3)

(P, s

) |(cid:20) ∃1zK1∃3z

(cid:3)

FDist(z, z

(cid:3)

) and also (P, s

(cid:3)(cid:3)

) |(cid:20) ∃1z∃3z

(cid:3)

K1FDist(z, z

(cid:3)

)

Given that one of agent i’s units is within the range of enemy ﬁre, agent i is in a dangerous situation. For expressing
this, we introduce a predicate Danger, whose meaning is left underspeciﬁed through a caeteris paribus clause θ . We assume
that our QIS validates the following de dicto speciﬁcation on Danger:

∀i z(K i∃ j z

(cid:3)

FDist(z, z

(cid:3)

) ∧ θ ↔ Danger(z)),

for j (cid:11)= i

The speciﬁcation above is weaker than the following de re formula for specifying the Danger

(cid:3)

predicate on danger:

∀i z(∃ j z

(cid:3)

K iFDist(z, z

(cid:3)

(cid:3)
) ∧ θ ↔ Danger
(cid:3)

(z)),

for j (cid:11)= i

In fact, the notion of Danger

implies that of Danger, and agent 1 knows herself to be both in Danger and in Danger

(cid:3)

,

while agent 3 only knows herself to be in Danger:

(cid:3)(cid:3)

(cid:3)(cid:3)

(P, s
(P, s

) |(cid:20) ∃1zK1Danger(z) and (P, s
(cid:3)(cid:3)
(P, s
) |(cid:20) ∃3zK3Danger(z) but

(cid:3)(cid:3)

(cid:3)
) |(cid:20) ∃1zK1Danger
(cid:3)
) (cid:11)|(cid:20) ∃3zK3Danger

(z)

(z)

Agents can try to ﬁnd a way out of this situation either by attacking or by withdrawing. In order to analyse these alterna-
(cid:3)))
tives, we introduce a knowledge based protocol [14]. First of all, we deﬁne a predicate Access such that Access((x, y)(x
(cid:3))} contains the points reachable from p in a single
(cid:3) | Access(p, p
iff |x − x
move. Moreover, we consider two actions: ATTACK and MOVE. The protocol for agent i (cid:11)= j can be written in pseudo-code as
follows:

(cid:3)| (cid:2) 1. Intuitively, the set {p

(cid:3)| (cid:2) 1 and | y − y

(cid:3), y

if K iDanger(z) then

if ∃i x(Access(z, x) ∧ ∀ j z
MOVE(z, x)

else if ∃ j z

(cid:3)

K iFDist(z, z

(cid:3)) then

(cid:3)

K i(¬FDist(x, z

(cid:3)))) then

ATTACK(z’)

This protocol says that if agent i knows that a unit z is in danger, then she has to move it to an area known to be out of
the enemy ﬁre range. If this is not possible, then she has to attack the enemy unit threatening her own unit. Note that this
protocol is extremely strict, as it requires knowledge of safety conditions before moving. In the present case, we have:

(cid:3)(cid:3)

(P, s

) |(cid:20) ∃1z(K1Danger(z) ∧ ∀1x(Access(z, x) → K1∃3z

(cid:3)

FDist(x, z

(cid:3)

)) ∧ ∃3z

(cid:3)

K1FDist(z, z

(cid:3)

))

Therefore agent 1, by following the knowledge-based protocol above, will attack the ﬁrst unit of agent 3.

By suitably extending our language, we could express interesting topological relationships on the various D i , like the
presence of obstacles. Moreover, we could introduce intensional predicates to describe in detail the characteristics of the
military units. The system above is simply an example, but we deem it persuading enough to let us conclude that QIS are
suﬃciently expressive to represent a number of concrete MAS scenarios.

5.2. Inﬁnitely many muddy children

In this subsection we use the language Lobj
n

to present an inﬁnite version of the muddy children puzzle [14], a well-
known scenario in epistemic logic. We observe that the solution to this puzzle depends only on the number k of muddy
children, not on the total number m (cid:3) k of children. In other words, at the end of the k-th round every child knows whether
his forehead is muddy or not, independently from the total number m of children.

This remark suggests that there is no need to ﬁx in advance the size of the set D of children in the muddy children
puzzle. Given this, we take D as containing an inﬁnite number of children and we introduce an inﬁnite version of this
puzzle.

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

1007

However, the language Lobj
n

in Section 3.1 contains only a ﬁnite number n of epistemic operators, so in the present
formalism we can reason about the knowledge of just a ﬁnite subset of D. This is a limitation of the present setting, which
can be overcome by introducing a language with inﬁnite denumerable epistemic operators. Such an extension is beyond our
interest in this paper, so we leave it for further work.

We take the local state li of child i (cid:2) n to be either 1 or 0 depending on whether his forehead is muddy or not, while
the local state of the environment remains unspeciﬁed as it does not inﬂuence the present analysis. So we take it to be the
empty sequence. We deﬁne a muddy children quantiﬁed interpreted system as follows:

Deﬁnition 58. A muddy children QIS, or MCQIS, is any pair (cid:8)S, D(cid:9), where S ⊆ Le × L1 × · · · × Ln, and D is an inﬁnite set of
children.

Note that we have a single quantiﬁcation domain D for all children, this implies that we can omit the subscript i from

quantiﬁers, and consider in Lobj

n unique quantiﬁers ∀, ∃ for all agents.

Instead of using, as in the propositional case, propositions pi for 1 (cid:2) i (cid:2) n, representing the fact that “child i’s forehead
is muddy”, we use a unary predicative constant M and inﬁnitely many constants such that M(ai) intuitively means that
“child i’s forehead is muddy”. Hereafter we present our analysis of this inﬁnite version of the muddy children puzzle.

After the father’s announcement that at least one child has a muddy forehead, the children have common knowledge of
this fact. The language Lobj
∃xM(x)
holds at step 1, for every i1, . . . , i j (cid:2) n. This formula does not hold in every muddy children QIS, but it is valid on the MCQIS
where S does not contain the global state with only 0s.

n has no common knowledge operator: we approximate this by assuming that K i1 . . . K i j

Further, every child knows whether any other child is muddy or not, and this can be expressed in Lobj
n

as the following

speciﬁcation:

∀x(x (cid:11)= a jk

→ (K j1 . . . K jk M(x) ∨ K j1 . . . K jk

¬M(x)))

but he does not know whether he is muddy or not, that is, also the following speciﬁcation holds at the beginning:

¬K j M(a j) ∧ ¬K j¬M(a j)

(18)

(19)

By induction on the number k of muddy children, it is provable that at the k-th round of answers every child knows whether
his forehead is muddy or not. Moreover, this result is independent from the actual number of children, and it holds also
for an inﬁnite number of children. In what follows we refer to principles and rules of inference of the system Q .S5obj
n
Section 4, we do not provide all the details of proofs, the interested reader should nonetheless be able to ﬁll the gaps.

in

For k = 1, assume that child j knows that (20) at least one child has a muddy forehead, and that (21) he cannot see any

other child with a muddy forehead:

K j∃xM(x)
K j∀ y( y (cid:11)= a j → ¬M( y))

(20)

(21)

These formulas hold in the muddy children QIS where at least one and only one child has a muddy forehead. In the
ﬁrst-order modal system Q .S5obj

n we can show that child j deduces that his own forehead is muddy as follows:

a. K j(∃xM(x) ∧ ∀ y( y (cid:11)= a j → ¬M( y)))
b. K j∃x(M(x) ∧ (x (cid:11)= a j → ¬M(x)))
c. K j∃x(M(x) ∧ x = a j)

from (20), (21) by modal calculus

from a by predicate calculus
from b by propositional calculus

So child j acquires the knowledge that his own forehead is muddy, i.e., K j M(a j) holds, and he will answer positively in the
ﬁrst round when asked.

For k = 2, after the ﬁrst round of negatively answered questions, every child i knows that there are at least two children

with muddy foreheads. We can represent this situation by means of the following de dicto formula:

K i∃x, y(x (cid:11)= y ∧ M(x) ∧ M( y))

(22)

Note that if child i has not a muddy forehead, it is trivial to check that (22) holds, as child i can see two other children
with muddy foreheads. On the other hand, if child i is one of the muddy children, then he can derive (22) in Q .S5obj
n
the principles (20), (21), (c) above.

from

In order to see this, assume that j is the muddy child other than i, who has negatively answered the ﬁrst question. This
means that (c) K j M(a j) fails, so either (20) or (21) does not hold. But it is the case that (20) K j∃xM(x), so ¬K j∀ y( y (cid:11)=
a j → ¬M( y)), that is, (21) is not valid.

Further, we can show that if child j does not know that he is the only muddy child, then there is some other child, who

is known to be muddy by j:

¬K j∀ y( y (cid:11)= a j → ¬M( y)) → ∃ y( y (cid:11)= a j ∧ K j M( y))

(23)

1008

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

In fact, formula (23) can be proved in the system Q .S5obj
n

as follows1:

a. ¬K j∀ y( y (cid:11)= a j → ¬M( y)) by assumption
b. ¬∀ y( y (cid:11)= a j → K j¬M( y))
c. ∃ y( y (cid:11)= a j ∧ ¬K j¬M( y))
d. ∃ y( y (cid:11)= a j ∧ K j M( y))

from c by (18)

from a by (see footnote)

from b by predicate calculus

As a result, (23) holds in the muddy children QIS. Therefore, by (23) and the negation of (21) we derive ∃ y( y (cid:11)= a j ∧ K j M( y)).
Finally, by axioms T and Nec the muddy child i acquires the knowledge that there is a muddy child different from j, i.e.,
K i∃ y( y (cid:11)= a j ∧ M( y)). We also assumed that i knows that j has a muddy forehead, K i M(a j), so we can easily derive (22) in
Q .S5obj

n by ﬁrst-order calculus.

Up to now we showed that after the ﬁrst round of questions every child, muddy or not, knows that there are at least
two muddy children. Now, suppose that child j can see only another child z with a muddy forehead. This situation validates
the following de re speciﬁcation, i.e., child j knows that every child other than him and z is clean:

∃zK j∀k(k (cid:11)= a j ∧ k (cid:11)= z → ¬M(k))

(24)

We can show that from the de dicto knowledge of the existence of two muddy children expressed in (22), and formula (24)
above, in Q .S5obj
n

child j deduces the de re knowledge that he is the other muddy child as follows:

a. K j∃x, y (x (cid:11)= y ∧ M(x) ∧ M( y))

∧ ∃zK j∀k (k (cid:11)= a j ∧ k (cid:11)= z → ¬M(k))

b. ∃zK j∃x, y (x (cid:11)= y ∧ M(x) ∧ M( y)
∧ ∀k(k (cid:11)= a j ∧ k (cid:11)= z → ¬M(k)))
c. ∃zK j∃x, y (x (cid:11)= y ∧ M(x) ∧ M( y)

∧ (x = a j ∨ x = z) ∧ ( y = a j ∨ y = z))

d. ∃zK j∃x, y (x (cid:11)= y ∧ M(x) ∧ M( y)

from (22), (24)

from a by predicate calculus

from b by Ex

∧ ((x = a j ∧ y = z) ∨ ( y = a j ∧ x = z)))

e. ∃zK j (a j (cid:11)= z ∧ M(a j) ∧ M(z))

from c by distributivity
from d by predicate calculus

As a result, child j acquires de re knowledge that he is the other muddy child and replies positively on the second round of
questions.

It is an easy induction step to show that if there are k muddy children, then there are formal proofs in the system

Q .S5obj
that they will know within the k-th round whether their foreheads are muddy. Since we are reasoning about an
n
inﬁnite set D of children, none of the formulas above can be translated into the propositional language of [14] for example.
Given the above, the inﬁnite version of the muddy children puzzle has a natural and intelligible formal proof in ﬁrst-order
epistemic logic

6. Message-passing QIS

This section is devoted to modelling message-passing systems (MPS) [14,52] in the framework of objectual QIS. An MPS
is a multi-agent system where agents communicate by exchanging messages, so the most relevant actions performed by
agents are the sending and receiving of messages. The formalism of message passing systems is useful to model a wide
range of multi-agent systems. For instance, a network of computers, such as the Internet, can be seen as an MPS. In general,
any multi-agent system is an MPS if the message transmission delay is not negligible. In MPS the local state of each agent
contains information about the initial state, the messages it has sent or received, as well as the internal actions it has
taken. One of the ﬁrst references dealing with MPS is [38], since then they have been extensively investigated both in their
synchronous and asynchronous formulations [14,52].

In what follows we show that MPS can be deﬁned as a particular class of objectual SGS satisfying a ﬁnite number of
speciﬁcations in the ﬁrst-order modal language LD
n , where n is the number of agents in the MPS. Our main result consists
in showing that Proposition 4.4.3 in [14], concerning the knowledge of the ordering of events in MPS, can be restated as a
validity on the class of QIS modelling MPS. Thus, the formalism of objectual QIS is powerful enough to deal with the theory
of message passing systems. Throughout this section we refer to [14], par. 4.4.5-6, for details on MPS.

More formally, we introduce a set Act of actions α1, α2, . . . , and a set Msg of messages μ1, μ2, . . . For each agent i ∈ A,
we consider a set Σi of initial events init(i, α), and a set Inti of internal events int(i, α). We deﬁne the local state li for
agent i as a history over Σi , Inti and Msg, that is, a sequence of events whose ﬁrst element is in Σi , and whose following
elements either belong to Inti or are events of the form send(i, j, μ), rec(i, j, μ) for j ∈ A, μ ∈ Msg. Intuitively, init(i, α)

1 Note that (t (cid:11)= t

(cid:3) → K j φ) → K j (t (cid:11)= t

(cid:3) → φ) is a validity in all muddy children QIS, because of the interpretation of terms.

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

1009

represents the event where agent i performs the initial action α, send(i, j, μ) represents the event where agent i sends message
μ to j, while the intended meaning of rec(i, j, μ) is that agent i receives message μ from j. Finally, int(i, α) means that agent
i performs the internal action α.

A global state s is a tuple (cid:8)le, l1, . . . , ln(cid:9), where l1, . . . , ln are local states as above and le contains all the events in l1, . . . , ln.
(cid:3)
We deﬁne a reﬂexive, transitive and anti-symmetric relation (cid:2) on the set of local states of any agent i such that li (cid:2) l
i

iff li is a preﬁx of l

(cid:3)
i . This order extends to global states, so that s (cid:2) s

(cid:3)

iff li (cid:2) l

(cid:3)
i for every i ∈ A.

We deﬁne message passing QIS (MPQIS) as objectual quantiﬁed interpreted systems P = (cid:8)S, D, I(cid:9) where S is a non-
empty set of global states, the domain D of individuals includes all agents in A, the messages in Msg, the actions in Act, the
events e1, e2, . . . , and I is an interpretation for language LD
n .

Intuitively, each MPQIS models the temporal evolution of a message passing system, which can be represented as a
sequence s0, s1, . . . of global states such that s0 = (cid:8)init(e, αe), init(1, α1), . . . , init(n, αn)(cid:9), and for every n ∈ N, either sn+1 is
identical to sn or there is i ∈ A such that li(sn) (cid:2) li(sn+1) but li(sn) (cid:11)= li(sn+1). Note that a single MPQIS can model several
temporal evolutions of the same MPS.

We assume that our language has terms and predicative letters for representing the objects in the domain D and the
relations among them. In particular, e1, e2, . . . are metaterms ranging over events: for instance, we introduce ∀eφ[e] as a
shorthand for

∀i, j, μ, α φ[send(i, j, μ)] ∧ φ[rec(i, j, μ)] ∧ φ[init(i, α)] ∧ φ[int(i, α)]

In fact, every event is either a send event, a receive event, an initial action, or an internal action. We use the same notation
for the objects in the model and the syntactic elements, the distinction will be made clear by the context. We observe that
we can express event speciﬁcations by using formulas in LD
n , which are provably valid on every MPQIS (the existence of a
unique individual ∃! can be deﬁned by means of =). For example, we can state:

∀e∃!i, j, μ, α (i (cid:11)= j) ∧ (e = send(i, j, μ) ∨ e = rec(i, j, μ) ∨ e = init(i, α) ∨ e = int(i, α))
∀i, j, μ, α ∃!e1, e2, e3, e4(send(i, j, μ) = e1 ∧ rec(i, j, μ) = e2 ∧ init(i, α) = e3
∧ int(i, α) = e4 ∧ e1 (cid:11)= e2 ∧ e1 (cid:11)= e3 ∧ e1 (cid:11)= e4 ∧ e2 (cid:11)= e3 ∧ e2 (cid:11)= e4 ∧ e3 (cid:11)= e4)

The ﬁrst speciﬁcation expresses the fact that every event is either a send event or a receive event, where the sender is
different from the receiver, an initial action, or an internal action. Thus, it cannot be the case that e = send(i, j, μ) =
(cid:3), μ(cid:3)) for distinct agents and messages. The second speciﬁcation states that every send or receive event, initial
send(i
(cid:3), μ(cid:3)). It is easy to check that
action, and internal action are distinct events. Thus, we cannot have send(i, j, μ) = e = rec(i
our deﬁnition of MPQIS validates both speciﬁcations.

(cid:3), j

(cid:3), j

In [14], p. 132 the authors list three key constraints on MPS, the third one involves the notion of run on a SGS, i.e., a

temporal evolution of global states. Nonetheless, we can restate the ﬁrst two without introducing runs:

MP1 a local state li for agent i is a history over Σi , Inti and Msg;
MP2 for every event rec(i, j, μ) in li(s) there exists an event send( j, i, μ) in l j(s).

Further, the following simplifying assumption is considered:

* all events in a given agent’s local state are distinct, an agent can never perform the same action twice.

We show how to formalise these speciﬁcations in the present formalism. First, we introduce a predicate H for happened
such that (P σ , s) |(cid:20) H(e, i) iff e is an event in the local state li(s) of agent i. The formula H(e) is a shorthand for ∃i H(e, i).
By deﬁnition of MPS we can show that (P σ , s) |(cid:20) H(e) iff e is an event in s. Further, we deﬁne an order Prec on events as
follows:

(P σ , s) |(cid:20) Prec(e, e

(cid:3), i)

iff

(P σ , s) |(cid:20) H(e, i) ∧ H(e
for all s

(cid:3) (cid:2) s, (P σ , s

(cid:3), i) and

(cid:3)) |(cid:20) H(e

(cid:3), i) → H(e, i)

(cid:3)) can be obtained from the one above by disregarding the i component:
The deﬁnition of Prec(e, e
(cid:3))

(P σ , s) |(cid:20) Prec(e, e

iff

(P σ , s) |(cid:20) H(e) ∧ H(e
for all s

(cid:3) (cid:2) s, (P σ , s

(cid:3)) and
(cid:3)) |(cid:20) H(e

(cid:3)) → H(e)

We can insist on the events in a global state s to be partially ordered by specifying that Prec(e, e
transitive relation on the set of past events:

(cid:3)) is a reﬂexive and

H(e) → Prec(e, e)
(cid:3)
) ∧ Prec(e

Prec(e, e

(cid:3)(cid:3)

(cid:3)

, e

) → Prec(e, e

(cid:3)(cid:3)

)

(25)

(26)

Moreover, Prec(e, e

(cid:3), i) can be deﬁned as a linear order on the events in li , i.e., it is also anti-symmetric and total:

1010

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

Prec(e, e

(cid:3)

(cid:3)

, i) ∧ Prec(e
(cid:3)

, e, i) → (e = e
(cid:3)

(cid:3)

)

H(e, i) ∧ H(e

, i) → Prec(e, e

, i) ∨ Prec(e

(cid:3)

, e, i)

We deﬁne Linear(Prec(e, e
linear. Also, we deﬁne the ﬁrst event as the minimal one with respect to Prec(e, e

(cid:3), i)) as the conjunction of (25)–(28) above, expressing the fact that the relation Prec(e, e

(cid:3), i), that is,

(27)

(28)

(cid:3), i) is

Fst(e, i) ::= ∀e

(cid:3)

(cid:3)

(H(e

, i) → Prec(e, e

(cid:3)

, i))

Finally, the formulas Sent(i, j, μ), Recd(i, j, μ), Init(i, α), and Int(i, α) are shorthands for H(send(i, j, μ)), H(rec(i, j, μ)),
H(init(i, α)), and H(int(i, α)) respectively. We can now formalise the speciﬁcations MP1-2 and * as follows:

MP1*

Linear(Prec(e, e

(cid:3)

, i)) ∧ ∃!e(F st(e, i) ∧ ∃α(e = init(i, α)))

∧ ∀e(¬F st(e, i) → ∃ j, α, μ(e = int(i, α) ∨ e = send(i, j, μ) ∨ e = rec(i, j, μ)))

MP2

(cid:3) ∀i, j, μ(Recd(i, j, μ) → Sent( j, i, μ))

The validity of MP1* on MPQIS forces the local state of any agent i to satisfy speciﬁcations MP1 and *; while by MP2
speciﬁcation MP2 is satisﬁed.
(cid:3)
Formulas MP1* and MP2

are the basic speciﬁcations for MPQIS, but we can consider further key constraints on message
passing system. A property often required in the framework of MPS is channel reliability. Modiﬁed from [14], an MPS is
reliable if every sent message is eventually received, or more formally:

(cid:3)

MP4 if send(i, j, μ) is in li(s), then there exists a global state s

(cid:3)

such that rec( j, i, μ) is in l j(s

(cid:3)).

In the language LD

n we can formalise this speciﬁcation as follows:

MP4

(cid:3) ∀ j, μ(Sent(i, j, μ) → ¬K i¬Recd( j, i, μ)).

In fact, if send(i, j, μ) is in li(s), by M4’ (P σ , s) |(cid:20) ¬K i¬Recd( j, i, μ), this means that there exists a global state s
(cid:3)) |(cid:20) Recd( j, i, μ), that is, rec( j, i, μ) ∈ l j(s
(P σ , s
former requires that the local states of agent i in s and s

(cid:3)). Thus, MP4 holds. Note that MP4

such that
is actually stronger than MP4 as the

are identical.

(cid:3)

(cid:3)

(cid:3)

Further, a relevant property of MPS concerns authentication: if agent i receives a message μ from agent j, then i knows

that μ was actually sent by j. This speciﬁcation can be expressed as

∀ j, μ(Recd(i, j, μ) → K iSent( j, i, μ))

Finally, we may require that agents have perfect recall, i.e., to know everything that has happened to them:

∀e(H(e, i) → K i H(e, i))

It is easy to show that MPQIS satisfy authentication and perfect recall but not channel reliability. Of course, we could add
this formula in any speciﬁcation should channel reliability be required. We remark that all the speciﬁcations introduced so
far are deﬁned by means of only the predicative constants H(e, i) and Prec(e, e

(cid:3), i).

We now prove the main result of this section: Proposition 4.4.3 in [14] can be restated as a validity on the class of
MPQIS satisfying MP1, MP2, and *. We do not provide the full statement here, but we note that this metatheoretical result
can be cast as a formula in the ﬁrst-order epistemic language LD
n . First, we introduce a relation (cid:26)→G of potential causality
between events, as discussed in [38,52]. This relation is intended to capture the intuition that event e might have caused
appear in
event e
s, and

. Fix a non-empty subset G of A, the relation (cid:26)→G holds between events e, e

at a state s iff both e and e

(cid:3)

(cid:3)

(cid:3)

1. for some i, j ∈ G, e
2. for some i ∈ G, events e, e
3. for some event e

(cid:3)(cid:3)

(cid:3)

(cid:3)

is a receive event and e is the corresponding send event;

, we have that e (cid:26)→G e

are both in li(s), and either e = e
and e

(cid:3)(cid:3) (cid:26)→G e

(cid:3)(cid:3)

(cid:3)

hold at s.

(cid:3)

, or e comes earlier than e

(cid:3)

in li(s);

Note that (cid:26)→G is a partial order on events. We say that (P σ , s) |(cid:20) e (cid:26)→G e
for syntax and semantics).

(cid:3)

if e (cid:26)→G e

(cid:3)

hold at s (we use the same notation

Now we prove that the potential causality relation (cid:26)→G respects the order Prec of events by showing that the following
, then it is distributed knowledge

validity holds in the class of MPQIS. This means that if event e is the cause of event e
(cid:3)
among the agents that e happened before e

. Note that this is the right to left implication of Proposition 4.4.3 in [14]:

(cid:3)

Proposition 59. MPQIS |(cid:20) ∀e, e

(cid:3)((e (cid:26)→G e

(cid:3)) → D G Prec(e, e

(cid:3))).

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

1011

(cid:3)

(cid:3)
Proof. Assume that (P σ , s) |(cid:20) e (cid:26)→G e
(cid:3)) |(cid:20) H(e) ∧ H(e
all i ∈ G implies (P σ , s
(cid:3)).
D G Prec(e, e
(cid:3)
are both in li(s) and either e = e
If e, e
(cid:3)), and for s
(cid:3)(cid:3)) |(cid:20) H(e
(cid:3)
H(e) ∧ H(e
(cid:3)).
(P σ , s) |(cid:20) D G Prec(e, e
Finally, if there exists some event e

, (P σ , s

(cid:3)(cid:3) (cid:2) s

(cid:3)(cid:3)

(cid:3)

. If e
(cid:3)), and for s

is a receive event and e is the corresponding send event, then li(s) = li(s

(cid:3)(cid:3) (cid:2) s

(cid:3)

, (P σ , s

(cid:3)(cid:3)) |(cid:20) Recd(i, j, μ) → Sent( j, i, μ) by MP2

(cid:3)

(cid:3)) for
. Thus, (P σ , s) |(cid:20)

or e comes earlier than e
(cid:3)) → H(e). It follows that (P σ , s) |(cid:20) K iPrec(e, e

in li(s), then li(s) = li(s

(cid:3)) |(cid:20)
(cid:3)) implies that (P σ , s
(cid:3)), and by axioms D1 and D2,

(cid:3)

that we are either in the ﬁrst or second case above. In both cases (P σ , s) |(cid:20) D G Prec(e, e
every s
By transitivity, (P σ , s

(cid:3)) → H(e). Thus, (P σ , s) |(cid:20) D G Prec(e, e

(cid:3)) for all i ∈ G implies (P σ , s

(cid:3)), and for s
(cid:3)). (cid:2)

(cid:3)) |(cid:20) H(e) ∧ H(e

, li(s) = li(s

(cid:3)(cid:3)) |(cid:20) H(e

(cid:3)(cid:3) (cid:2) s

(cid:3)

such that e (cid:26)→G e

(cid:3)(cid:3)

and e

(cid:3)(cid:3) (cid:26)→G e

(cid:3)

, then we can assume without loss of generality
(cid:3)). Therefore, for
(cid:3)(cid:3)).
(cid:3)) → H(e

(cid:3)(cid:3), e
(cid:3)(cid:3)) → H(e) ∧ H(e

(cid:3)(cid:3)) ∧ D G Prec(e

(cid:3)(cid:3)) |(cid:20) H(e

, (P σ , s

(cid:3)

The analysis of message-passing systems carried out in this section shows the advantages in terms of expressivity of
ﬁrst-order epistemic formalisms in comparison with propositional ones. By means of language LD
n we are able to formalise
various constraints on MPS, thereby validating the suitability of the approach. Most importantly, an encoding of the right to
left implication of Proposition 4.4.3 in [14] can be shown to be a validity on the class of QIS modelling MPS.

7. Conclusions

First-order epistemic logic allows for greater expressiveness in comparison to propositional formalisms. In speciﬁc ap-
plications this advantage can be critical for modelling agent systems in a more intuitive and effective way. Because of this,
FOEL has successfully been applied to reasoning about knowledge in artiﬁcial intelligence [39,42,51]. However, the litera-
ture on this subject in the MAS area have so far fallen short of a deep and systematic analysis of the formal machinery
(axiomatisability, decidability, completeness), even in the case of static epistemic logic.

In this paper we showed that the semantics of interpreted systems may naturally be extended to ﬁrst-order, and we
provided complete axiomatisations for several classes of structures, which is noteworthy given the known diﬃculties of
these formalisms [19,57]. Speciﬁcally, we considered different assumptions on quantiﬁcation domains, their relationship
with the agents’ local states, and the impact these assumptions make in terms of axiomatisations. We exempliﬁed the use of
these formalisms by investigating two examples. The puzzle of muddy children in Section 5 is part of the folklore of multi-
agent systems in AI [14]; while the formalisation of the battleﬁeld game as a quantiﬁed interpreted system is an original
example of the expressive features of the present semantical framework. As regards message passing systems, the topic of
Section 6, they have been extensively investigated in computer science both in their synchronous and asynchronous version.
In [38] the relation (cid:26)→G between events is introduced, and in [52] it is used to deﬁned a notion of common knowledge
which is attainable also in asynchronous message passing systems. In Section 6 we followed [14] in the presentation of
MPS, and proved that Proposition 4.4.3 can be cast as a validity on the class of MPQIS. This reassures us that the analysis is
adequate.

We see this paper as a ﬁrst contribution in the development of computationally grounded semantics for quantiﬁed
epistemic logics. Indeed, extensions of the present framework seem worth pursuing. It may be of interest to explore the
completeness issues resulting from term-indexing epistemic operators, as in [43]. This would greatly increase the expressive
power of the formalism, so some limitation on index quantiﬁcation might be introduced to retain a reasonable computa-
tional complexity. Another signiﬁcant extension would be to add temporal operators to the language. This would open the
way for axiomatisations of ﬁrst-order temporal epistemic logics for MAS. However, any work in this area is likely to be
affected by technical problems, especially with respect to axiomatisation and decidability [25,62].

Acknowledgements

The research described in this paper was partly supported by the EC Framework 6 funded project CONTRACT (IST Project
Number 034418), by the research project “Logica Modale e Conoscenza” funded by the Scuola Normale Superiore, Pisa, and
by the Royal Society through an International Joint Project award to both authors. The authors would like to thank the
reviewers for useful comments on an earlier version of this paper. The ﬁrst author would like to thank his PhD supervisor,
Prof Massimo Mugnai, and Prof Giovanna Corsi, Prof Silvio Ghilardi, and Prof Achille Varzi for support and advice. The
second author is grateful to Prof Marco Colombetti, Politecnico di Milano, for having introduced him to Quantiﬁed Modal
Logic in 1994.

References

[1] F. Belardinelli, Quantiﬁed modal logic and the ontology of physical objects, PhD thesis, Scuola Normale Superiore, Pisa, 2006.
[2] P. Bieber, A logic of communication in hostile environments, in: Proceedings of the 3rd IEEE Computer Security Foundations Workshop (CSFW’90), IEEE

Computer Society, 1990, pp. 14–22.

[3] P. Blackburn, M. de Rijke, Y. Venema, Modal Logic, Cambridge University Press, 2001.
[4] P. Blackburn, J. van Benthem, F. Wolter (Eds.), Handbook of Modal Logic, Elsevier, 2006.
[5] A. Chagrov, M. Zakharyaschev, Modal Logic, Oxford University Press, 1997.
[6] E. Clarke, O. Grumberg, D. Peled, Model Checking, MIT Press, 1999.

1012

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

[7] M. Cohen, M. Dams, A complete axiomatization of knowledge and cryptography, in: Logic in Computer Science (LICS), IEEE Computer Society, 2007,

pp. 77–88.

[8] P. Cohen, H. Levesque, Communicative actions for artiﬁcial agents, in: Proceedings of the First International Conference on Multi-Agent Systems (IC-

MAS’95), AAAI Press, 1995, pp. 65–72.

[9] G. Corsi, A uniﬁed completeness theorem for quantiﬁed modal logics, Journal of Symbolic Logic 67 (2002) 1483–1510.

[10] G. Corsi, BF, CBF and Lewis semantics, Logique et Analyse (2005) 103–122.
[11] A. Degtyarev, M. Fisher, B. Konev, Monodic temporal resolution, ACM Transactions on Computational Logic (TOCL) 7 (1) (2006) 108–150.
[12] A. Degtyarev, M. Fisher, A. Lisitsa, Equality and monodic ﬁrst-order temporal logic, Studia Logica 72 (2002) 147–156.
[13] P. Dembi ´nski, et al., Verics: A tool for verifying timed automata and Estelle speciﬁcations, in: Proceedings of the 9th International Conference on Tools

and Algorithms for the Construction and Analysis of Systems (TACAS03), Springer-Verlag, 2003, pp. 278–283.

[14] R. Fagin, J. Halpern, Y. Moses, M. Vardi, Reasoning about Knowledge, MIT Press, 1995.
[15] R. Fagin, J. Halpern, M. Vardi, What can machines know? On the properties of knowledge in distributed systems, Journal of the ACM 39 (2) (1992)

328–376.

[16] M. Fitting, R. Mendelsohn, First-Order Modal Logic, Kluwer, Dordrecht, 1998.
[17] D. Follesdal, Knowledge, identity, and existence, Theoria 23 (1) (1967) 1–27.
[18] M. Gammie, R. van der Meyden, MCK: Model checking the logic of knowledge, in: Proceedings of the 16th International Conference on Computer Aided

Veriﬁcation (CAV04), Springer-Verlag, 2004, pp. 479–483.

[19] J. Garson, Quantiﬁcation in modal logic, in: D. Gabbay, F. Guenthner (Eds.), Handbook of Philosophical Logic, vol. 3, Reidel, 2001, pp. 267–323.
[20] J. Halpern, R. Fagin, Modelling knowledge and action in distributed systems, Distributed Computing 3 (4) (1989) 159–179.
[21] J. Halpern, R. Shore, Reasoning about common knowledge with inﬁnitely many agents, Information and Computation 191 (1) (2004) 1–40.
[22] Y. Hintikka, Knowledge, identity, and existence, Nous 1 (1) (1962) 33–62.
[23] I. Hodkinson, Monodic packed fragment with equality is decidable, Studia Logica 72 (2002) 185–197.
[24] I. Hodkinson, Complexity of monodic guarded fragments over linear and real time, Annals of Pure and Applied Logic 138 (2006) 94–125.
[25] I. Hodkinson, F. Wolter, M. Zakharyaschev, Decidable fragment of ﬁrst-order temporal logics, Annals of Pure and Applied Logic 106 (1–3) (2000)

85–134.

[26] I. Hodkinson, F. Wolter, M. Zakharyaschev, Decidable and undecidable fragments of ﬁrst-order branching temporal logics, in: Logic in Computer Sci-

ence(LICS), IEEE Computer Society, 2002, pp. 393–402.

[27] I. Hodkinson, R. Kontchakov, A. Kurucz, F. Wolter, M. Zakharyaschev, On the computational complexity of decidable fragments of ﬁrst-order linear
temporal logics, in: Proceedings of the International Symposium on Temporal Representation and Reasoning (TIME), IEEE Press, 2003, pp. 91–98.
[28] W. van der Hoek, J.J.Ch. Meyer, Making some issues of implicit knowledge explicit, International Journal of Foundations of Computer Science 3 (2)

(1992) 193–223.

[29] W. van der Hoek, J.J.Ch. Meyer, J. Treur, Formal semantics of temporal epistemic reﬂection logic, in: Proceedings of the 4th International Workshops

on Meta-Programming in Logic (META’94), Springer-Verlag, 1994, pp. 332–352.
[30] G. Hughes, M. Cresswell, A New Introduction to Modal Logic, Routledge, 1996.
[31] M. Huth, M. Ryan, Logic in Computer Science: Modelling and Reasoning about Systems, Cambridge University Press, 2004.
[32] M. Kaneko, T. Nagashima, Game logic and its applications 1, Studia Logica 57 (1996) 325–354.
[33] M. Kaneko, T. Nagashima, Game logic and its applications 2, Studia Logica 58 (1997) 273–303.
[34] S. Kripke, A completeness theorem in modal logic, Journal of Symbolic Logic 24 (1959) 1–14.
[35] T. Jager, An actualist semantics for quantiﬁed modal logic, Notre Dame Journal of Formal Logic 23 (1982) 335–349.
[36] G. Lakemeyer, Limited reasoning in ﬁrst-order knowledge bases, Artiﬁcial Intelligence 71 (2) (1994) 213–255.
[37] G. Lakemeyer, Limited reasoning in ﬁrst-order knowledge bases with full introspection, Artiﬁcial Intelligence 84 (1–2) (1996) 209–255.
[38] L. Lamport, Time, clocks, and the ordering of events in a distributed system, Communication of the ACM 21 (7) (1978) 558–565.
[39] H. Levesque, Knowledge representation and reasoning, Annual Reviews Computer Science 30 (1) (1986) 81–108.
[40] D. Lewis, On the Plurality of Worlds, Blackwell, 1986.
[41] Y. Liu, G. Lakemeyer, H. Levesque, A logic of limited belief for reasoning with disjunctive information, in: Proceedings of the 9th International Confer-

ence on Principles of Knowledge Representation and Reasoning (KR04), AAAI Press, 2004, pp. 587–597.

[42] Y. Liu, H. Levesque, Tractable reasoning in ﬁrst-order knowledge bases with disjunctive information, in: Proceedings of the 20th National Conference

on Artiﬁcial Intelligence (AAAI-05), AAAI Press, 2005, pp. 639–644.

[43] A. Lomuscio, M. Colombetti, QLB: A quantiﬁed logic for belief, in: Proceedings of the 3rd International Workshop on Agent Theories, Architectures, and

Languages (ATAL-96), Springer-Verlag, 1996.

[44] A. Lomuscio, F. Raimondi, MCMAS: a tool for verifying multi-agent systems, in: Proceedings of the 12th International Conference on Tools and Algo-

rithms for the Construction and Analysis of Systems (TACAS06), Springer, pp. 450-454.

[45] A. Lomuscio, M. Ryan, On the relation between interpreted systems and Kripke models, in: Proceedings of the AI97 Workshop on Theoretical and

Practical Foundation of Intelligent Agents and Agent-Oriented Systems, Springer, 1997.

[46] Z. Manna, A. Pnueli, The Temporal Logic of Reactive and Concurrent Systems, vol. 1, Springer-Verlag, 1992.
[47] K. McMillan, Symbolic Model Checking: An Approach to the State Explosion Problem, Kluwer Academic Publishers, 1993.
[48] R. Meyden, Axioms for knowledge and time in distributed systems with perfect recall, in: Logic in Computer Science (LICS), IEEE Computer Society,

1994, pp. 448–457.

[49] J.-J.Ch. Meyer, W. van der Hoek, Epistemic Logic for AI and Computer Science, Cambridge University Press, 1995.
[50] R.C. Moore, The role of logic in knowledge representation and commonsense reasoning, in: Proceedings of the 2nd National Conference of the American

Association for Artiﬁcial Intelligence, AAAI Press, 1982, pp. 428–433.

[51] R.C. Moore, A formal theory of knowledge and action, in: Formal Theories of the Commonsense World, Ablex Publishing Corp., 1984.
[52] P. Panangaden, K. Taylor, Concurrent common knowledge: Deﬁning agreement for asynchronous systems, Distributed Computing 6 (2) (1992) 73–93.
[53] R. Parikh, R. Ramanujam, Distributed processes and the logic of knowledge, in: Proceedings of the Conference on Logic of Programs, Springer-Verlag,

1985, pp. 256–268.

[54] F. Raimondi, A. Lomuscio, Automatic veriﬁcation of multi-agent systems by model checking via OBDDs, Journal of Applied Logic 5 (2) (2007) 235–251.
[55] A. Rao, M. Georgeff, Modeling rational agents within a BDI-architectures, in: Proceedings of the 2nd International Conference on Principles of Knowl-

edge Representation and Reasoning (KR’91), Morgan Kaufmann Publishers, 1991, pp. 473–484.

[56] M. Reynolds, Axiomatising ﬁrst-order temporal logic: Until and since over linear time, Studia Logica 57 (2/3) (1996) 279–302.
[57] V. Shehtman, Completeness and incompleteness in ﬁrst-order modal logic: An overview, in: Advances in Modal Logic, College Publications, 2006,

pp. 27–30.

[58] H. Sturm, F. Wolter, M. Zakharyaschev, Monodic epistemic predicate logic, in: Proceedings of the European Workshop on Logics in Artiﬁcial Intelligence,

Springer-Verlag, 2000, pp. 329–344.

[59] H. Sturm, F. Wolter, M. Zakharyaschev, Common knowledge and quantiﬁcation, Economic Theory 19 (2002) 157–186.

F. Belardinelli, A. Lomuscio / Artiﬁcial Intelligence 173 (2009) 982–1013

1013

[60] R. Thomason, Some completeness results for modal predicate calculi, in: Philosophical Problems in Logic, Reidel, 1980, pp. 56–76.
[61] F. Wolter, First order common knowledge logics, Studia Logica 65 (2000) 249–271.
[62] F. Wolter, M. Zakharyaschev, Decidable fragments of ﬁrst-order modal logics, Journal of Symbolic Logic 66 (3) (2001) 1415–1438.
[63] F. Wolter, M. Zakharyaschev, Axiomatizing the monodic fragment of ﬁrst-order temporal logic, Annals of Pure and Applied Logic 118 (1–2) (2002)

133–145.

[64] M. Wooldridge, An Introduction to Multi-Agent Systems, John Wiley, 2002.
[65] M. Wooldridge, Computationally grounded theories of agency, in: Proceedings of the International Conference on Multi-Agent Systems (ICMAS), IEEE

Press, 2000, pp. 13–22.

[66] M. Wooldridge, Reasoning about Rational Agents, MIT Press, 2000.
[67] M. Wooldridge, Verifying that agents implement a communication language, in: Proceedings of the 16th National Conference on Artiﬁcial Intelligence

(AAAI-99), AAAI Press, 1999, pp. 52–57.

[68] M. Wooldridge, M. Fisher, M. Huget, S. Parsons, Model checking for multiagent systems: The Mable language and its applications, International Journal

on Artiﬁcial Intelligence Tools 15 (2) (2006) 195–226.

[69] M. Wooldridge, M. Fisher, M. Huget, S. Parsons, Model checking multiagent systems with MABLE, in: Proceedings of the First International Conference

on Autonomous Agents and Multiagent Systems (AAMAS02), IFAAMAS, 2002, pp. 952–959.

[70] B. Wozna, A. Lomuscio, A temporal epistemic logic with a reset operation, in: Proceeding of the 6th International Conference on Autonomous Agents

and Multiagent Systems (AAMAS07), ACM, 2007, pp. 574–581.

