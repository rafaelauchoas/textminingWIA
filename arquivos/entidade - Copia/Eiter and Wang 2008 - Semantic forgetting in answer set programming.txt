Artiﬁcial Intelligence 172 (2008) 1644–1672

Contents lists available at ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Semantic forgetting in answer set programming ✩
Thomas Eiter a, Kewen Wang b,∗,1

a Institut für Informationssysteme, Technische Universität Wien, Favoritenstraße 9-11, A-1040 Vienna, Austria
b School of Information and Communication Technology, Griﬃth University, Brisbane QLD 4111, Australia

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 3 November 2007
Received in revised form 6 May 2008
Accepted 24 May 2008
Available online 29 May 2008

Keywords:
Answer set programming
Nonmonotonic logic programs
Knowledge representation
Forgetting
Computational complexity

The notion of
forgetting, also known as variable elimination, has been investigated
extensively in the context of classical logic, but less so in (nonmonotonic) logic program-
ming and nonmonotonic reasoning. The few approaches that exist are based on syntactic
modiﬁcations of a program at hand.
In this paper, we establish a declarative theory
of forgetting for disjunctive logic programs under answer set semantics that is fully
based on semantic grounds. The suitability of this theory is justiﬁed by a number of
desirable properties. In particular, one of our results shows that our notion of forgetting
can be entirely captured by classical
forgetting. We present several algorithms for
computing a representation of the result of forgetting, and provide a characterization of
the computational complexity of reasoning from a logic program under forgetting. As
applications of our approach, we present a fairly general framework for resolving conﬂicts
in inconsistent knowledge bases that are represented by disjunctive logic programs, and we
show how the semantics of inheritance logic programs and update logic programs from the
literature can be characterized through forgetting. The basic idea of the conﬂict resolution
framework is to weaken the preferences of each agent by forgetting certain knowledge that
causes inconsistency. In particular, we show how to use the notion of forgetting to provide
an elegant solution for preference elicitation in disjunctive logic programming.

© 2008 Published by Elsevier B.V.

1. Introduction

For intelligent agents, the ability to discard irrelevant information has been recognized as an important feature (that is
mastered well by humans) and received broad attention in artiﬁcial intelligence, both from a cognitive and a computational
perspective. In the area of knowledge representation, this ability is often referred to as forgetting [49] or variable elimina-
tion [9], but has been studied under many different names including irrelevance, independence, irredundancy, novelty, or
separability (see [34,63] for more details).

Forgetting has its root in Boolean Algebra [6] where it is a fundamental reasoning process. C.I. Lewis [41] has pointed out
that, for purposes of application of Boolean logic to commonsense reasoning, the elimination/forgetting is a process more
important than solution2 since most processes of reasoning take place through the elimination of “middle” variables. Boole
writes of such middle variables that it “usually happens in commonsense reasoning, and especially when we have more
than one premises, that some of the elements [in the premises] are not required to appear in the conclusion”.

✩

Preliminary versions of this paper with some of the results have been presented at AAAI 2006 and at NMR 2006.

* Corresponding author.

E-mail addresses: eiter@kr.tuwien.ac.at (T. Eiter), k.wang@griﬃth.edu.au (K. Wang).

1 Part of the work was done while this author was visiting Technische Universität Wien.
2 In [41] a problem is formulated as a Boolean equation such that a solution of the Boolean equation corresponds to a solution of the given problem. In

particular, solving a Boolean equation is treated as a process of eliminating/forgetting variables that represent unknowns.

0004-3702/$ – see front matter © 2008 Published by Elsevier B.V.
doi:10.1016/j.artint.2008.05.002

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1645

Forgetting and its applications have been investigated extensively in the context of classical logic, for example, [5,34,36,
37,49,55,56,67], but less so in nonmonotonic logic programming and reasoning. In this context, it was ﬁrst considered in
[70,71], where two types of forgetting—strong and weak forgetting—have been deﬁned by ﬁrst transforming a logic program
P into a reduced form and then deleting some rules (and literals) from it. While this approach works well in a number of
cases, it has two major drawbacks. First, its semantic underpinning is not fully clear. Speciﬁcally, the relationship between
the intended semantics of a logic program, in terms of its answer sets, and the result of the syntactic transformations that
are carried out by strong and weak forgetting is unclear. Second, this approach does not address desirable properties for
a reasonable notion of forgetting in nonmonotonic logic programming. In particular, one may ask what is the difference of
these notions of forgetting from traditional approaches to deletion of rules/literals in logic programming and databases.

A further aspect is that both strong and weak forgetting are syntax-sensitive, i.e., programs that are semantically equiva-
lent may have different results after forgetting about the same literal. For example, the programs P = {p ← . q ← not p}
and Q = {p ←} are equivalent under the answer set semantics. Weak forgetting about p from P yields the program
WForgetLP(P , p) = {q ←} and from Q the program WForgetLP(Q , p) = { }; clearly, these programs are not equivalent.

While the role of syntax in logic programming is, with respect to reading of rules as in classical logic well-acknowledged,
one might argue that relative to the semantics of this syntax, equivalent programs should behave in the same way. In
particular, in this example the result of forgetting about p in P and Q should yield semantically the same result (note that,
under answer set semantics, the second rule in P is redundant).

A similar phenomenon can be observed for strong forgetting. Consider P = {q ← not p. q ← not q} and Q = {q ←}. Then
these two programs are equivalent under the answer set semantics. However, the results of strong forgetting about p from
P and Q are SForgetLP(P , p) = {q ← not q} and SForgetLP(Q , p) = {q ←}, respectively, which are obviously not equivalent.
The discrepancy is here even more noticeable: the result of strong forgetting about an atom from a consistent program can
be inconsistent.

Thus, an alternative notion of forgetting for nonmonotonic logic programming is highly desirable. In this paper, we choose
answer set programming (ASP) [44] as the underlying nonmonotonic logic. ASP is a new paradigm of logic programming
under the answer set semantics [29], which is becoming a major tool for knowledge representation and reasoning due to
its simplicity, expressive power, and connection to major nonmonotonic logics. A number of eﬃcient ASP solvers, such as
DLV, Smodels, ASSAT, Cmodels, or Clasp are available (see [3]), which can handle large problem instances.

Prior to deﬁning a notion of forgetting for nonmonotonic logic programming, we may pose the question what desirable
properties a reasonable theory of forgetting should have. The following ones appear to be natural candidates for us. Let P
be a logic program and let P

be the result of forgetting about a literal l in P .

(cid:4)

(F1) The proposed notion of forgetting should be a “natural” generalization of, and relate to, forgetting in classical logic.
, i.e., the vocabulary stays the same.
(F2) No new symbols are introduced in P
(F3) The reasoning under P
(F4) The result of forgetting is not sensitive to syntax in that the results of forgetting about l in semantically equivalent

is equivalent to the reasoning under P if l is ignored.

(cid:4)

(cid:4)

programs should also be semantically equivalent.

(F5) The semantic notion of forgetting is coupled with a syntactic counterpart, i.e., there is effective constructible syntax for

representing the result of forgetting.

(cid:4)

Property (F1) speciﬁes the major intuition behind forgetting and clariﬁes the difference of forgetting from deletion. (F2) is
necessary because the forgetting is to eliminate the symbols to be forgotten. This is a difference between forgetting and
some approaches to revision, update, and deletion, such as [1,10,16,19,31]; note that to combine forgetting with other ap-
proaches to adding new information is a different issue. Property (F3) provides a semantic justiﬁcation for the forgetting.
Note that P
and P may have different answer sets in general (see Proposition 1); (F4) guarantees that the notion of forget-
ting is semantically well-deﬁned. Finally, property (F5) is useful for applications of forgetting in knowledge representation.
To the best of our knowledge, there is no theory of forgetting in nonmonotonic reasoning or logic programming which
is based on the above criteria; notice that properties (F3) and (F4) do not hold for weak and strong forgetting from [70,71]
(see Section 7 for more discussion). However, the deﬁnition of forgetting in classical logic cannot be directly adapted to
logic programming (cf. Section 3.1). The main contributions of the present paper are as follows.

• We establish a declarative, semantically deﬁned notion of forgetting for disjunctive logic programs under answer set se-
mantics called semantic forgetting. The suitability of semantic forgetting is justiﬁed by a number of desirable properties,
including the ones given above.

• As one of them, we show that our notion of forgetting naturally captures classical forgetting. As we show, this can
be exploited for reasoning under forgetting about a literal from a logic program by resorting to representations of a
nonmonotonic logic program in terms of classical logic [39,50,51].

• As another such property, for every consistent disjunctive program P and literal l, a syntactic representation forget(P , l)
for forgetting about l in P in terms of a nonmonotonic logic program always exists. Besides two semantics-based algo-
rithms for computing such a representation, we also present a transformation-based algorithm. This algorithm allows
to obtain the result of forgetting about a literal l in P via a series of program transformations and other rewritings.

1646

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

• In connection with these algorithms, we characterize the computational complexity of the major reasoning tasks from
logic programs under forgetting about a literal. As it turns out, model checking and credulous reasoning under forget-
ting about a literal from a logic program are more complex than in the standard setting (by one level in the polynomial
hierarchy), while skeptical reasoning has the same complexity. These results provide useful insights into feasible rep-
resentations of forgetting, and suggest that a polynomial-size result of forgetting may not always be feasible. This (and
stronger results) can be established by applying the theory of Cadoli et al. [12,13].

• As an application of our approach, we present a fairly general framework for resolving conﬂicts in inconsistent knowl-
edge bases. The basic idea of this framework is to weaken the preferences of each agent by forgetting some subgoals
that may cause inconsistency. In particular, we show how to use the notion of forgetting to provide an elegant solution
for preference elicitation in ASP.

• Furthermore, we show that inheritance programs [10], update programs [18,19] and fragments of dynamic programs

[1,2] can be characterized in terms of the semantic forgetting.

While in this paper, we focus on nonmonotonic logic programs, the basic ideas underlying our approach to semantic
forgetting may be applied to other well known formalisms of nonmonotonic reasoning, such as default logic [60] or au-
toepistemic logic [57], as well, of which nonmonotonic logic programs under answer set semantics can be seen as particular
fragments. In fact, these formalisms extend classical logic, and a notion of forgetting that complies with classical forgetting
(which is based on semantics) seems needed there. Our results thus also provide a benchmark for approaches to forgetting
in other formalisms of nonmonotonic reasoning, which remain to be developed.

The rest of the paper is organized as follows. Section 2 brieﬂy recalls some basics of disjunctive logic programs and the
answer sets. Section 3 deﬁnes the notion of forgetting in ASP, shows some important properties, and relates it to classical
forgetting and independence [34]. Thereafter, Section 4 presents algorithms for computing the result of forgetting in ASP,
while Section 5 studies some complexity issues. Section 6 then presents some applications, namely to conﬂict resolution in
multi-agent systems, to inheritance logic programs, and to logic program updates. The ﬁnal Section 7 concludes the work.

2. Preliminaries

We brieﬂy review some basic deﬁnitions and notation in answer set programming that will be used throughout this

paper.

A disjunctive logic program (simply, logic program) is a ﬁnite set of rules of the form

a1 ∨ · · · ∨ as ← b1, . . . , bm, not c1, . . . , not cn,

(1)

where s, m, n (cid:2) 0, and all ai , b j , and ck are from a set Lit of classical literals in a propositional language. We assume here
that all ai are pairwise distinct, and similarly all b j and all ck. A literal is a positive literal p or a negative literal ¬p for some
atom p. For an atom p, p and ¬p are called complementary. For any literal l, its complementary literal is denoted by ¬.l.

Given a rule r of form (1), head(r) = a1 ∨ · · · ∨ as and body(r) = body
−
−

−

(r) = {c1, . . . , cn}, and not body

(r) = {not q | q ∈ body

(r) = {b1, . . . , bm},
(r)}. Occasionally, in abuse of notation we view head(r) also as

(r) ∪ not body

(r) where body

+

−

+

body
set {a1, . . . , as}.

A rule r of the form (1) is normal or non-disjunctive, if s (cid:3) 1; positive, if n = 0; negative, if m = 0; constraint, if s = 0; fact,
if m = 0 and n = 0. The rule with s = n = m = 0 is the constant false. A logic program P is called normal (resp., positive,
negative), if every rule in P is normal (resp., positive, negative).

We denote by Lit P ⊆ Lit the literal base of logic program P , that is, the set of all literals occurring in P . Unless stated
otherwise or clear from the context, Lit will be implicitly given by Lit P . An interpretation is a set of literals X ⊆ Lit that
contains no pair of complementary literals. A disjunction a1 ∨ · · · ∨ as is satisﬁed by X , denoted X |(cid:9) a1 ∨ · · · ∨ as if ai ∈ X for
some i with 1 (cid:3) i (cid:3) s. A rule r is satisﬁed by X , denoted X |(cid:9) r, if X |(cid:9) head(r) whenever body
(r) ∩ X = ∅
hold. Furthermore, X is a model of P , denoted X |(cid:9) P , if X |(cid:9) r for every rule r ∈ P . A model X of P is a minimal model of
P if for any model X

(r) ⊆ X and body

(cid:4) ⊆ X implies X

(cid:4) = X .

of P , X

+

−

(cid:4)

The semantics of a logic program P is deﬁned in terms of its answer sets [30] as follows. Given an interpretation X , the
(r) ∩ X = ∅}. Then X is an answer set of P , if X is a
(r) | r ∈ P , body

reduct of P on X is deﬁned as P X = {head(r) ← body
minimal model of P X . By AS(P ) we denote the collection of all answer sets of P .

−

+

A logic program P may have zero, one or multiple answer sets. P is consistent, if it has at least one answer set. It is well

(cid:4)

in AS(P ), X ⊆ X

(cid:4)

implies X = X

(cid:4)

.

known that the answer sets of a logic program P are incomparable: for any X and X

Example 1. Let P be the logic program consisting of the following rules:

a ∨ b ← not c
d ← a
d ← b

Then P has two answer sets X1 = {a, d} and X2 = {b, d}. Obviously, X1 and X2 are incomparable.

Two logic programs P and P

(cid:4)

are equivalent, denoted P ≡ P

(cid:4)

, if AS(P ) = AS(P

(cid:4)), i.e., P and P

(cid:4)

have the same answer

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1647

sets.

By P |(cid:9)s l and P |(cid:9)c l we denote skeptical and credulous consequence of a literal l from a logic program P , respectively;

that is, P |(cid:9)s l iff l ∈ S for every S ∈ AS(P ) and P |(cid:9)c l iff l ∈ S for some S ∈ AS(P ).

3. Forgetting in logic programming

In this section, we deﬁne what it means to forget about a literal l in a logic program P . The idea is to obtain a logic
program which does not contain l and is equivalent to the original logic program if we ignore the existence of the literal l.
We believe that forgetting should go beyond syntactic removal of rules/literals and be close to classical forgetting and
answer set semantics (keeping its spirit) at the same time. Thus, the deﬁnition of forgetting in this section is given in
semantics terms, i.e., based on answer sets.

3.1. Deﬁnition of semantic forgetting

In classical propositional logic, the result of forgetting forget(T , p) about a proposition p in a ﬁnite theory T is con-
veniently deﬁned as T (p/true) ∨ T (p/false), where T (p/true) and T (p/false) are obtained by taking the conjunction of all
sentences in T and replacing all occurrences of p with true and false, respectively. This method cannot be directly gen-
eralized to logic programming, since there is no notion of the “disjunction” of two logic programs. However, if we look at
forgetting from a model-theoretic perspective, then we can obtain the models of forget(T , p) as follows: compute ﬁrst all (2-
valued) models of T and then remove p from each model if it contains p. The resulting collection of sets {M \ {p} | M |(cid:9) T }
is exactly the set of all models of forget(T , p).

Similarly, given a consistent logic program P and a literal l, we could naively deﬁne the result of forgetting about l
whose answer sets are exactly AS(P ) \ l = { X \ {l} | X ∈ AS(P )}. However, this notion of
in P as a logic program P
for even simple programs. For example, consider P = {a ← . p ∨ q ←}.
forgetting cannot guarantee the existence of P
Here AS(P ) = {{a, p}, {a, q}} and thus AS(P ) \ p = {{a}, {a, q}}. Since {a} ⊂ {a, q} and, as well known, answer sets are
incomparable under set inclusion, AS(P ) \ p cannot be the set of answer sets of any logic program.

(cid:4)

(cid:4)

A solution to this problem is a suitable notion of minimal answer set such that the deﬁnition of answer sets, minimality, and
(cid:4) \ {l} ⊆ X \ {l}.
(cid:4) ⊆l X , if X
of literals are l-equivalent,

forgetting can be fruitfully combined. To this end, we call a set X
Similarly, a set X
(cid:4)
denoted X ∼l X

(cid:4) \ {l} ⊂ X \ {l}. Two sets X and X

is a strict l-subset of X , denoted X

an l-subset of a set X , denoted X

(cid:4) ⊆l X and X ⊆l X

(cid:4) ⊂l X , if X

, if X

.

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Deﬁnition 1 (l-Answer Set). Let P be a consistent logic program, let l be a literal in Lit P , and let X ⊆ Lit P be a set of literals.

(1) For a collection S of sets of literals, X ∈ S is l-minimal if there is no X

(cid:4) ∈ S such that X

(cid:4) ⊂l X . By minl(S) we denote

the collection of all l-minimal elements in S.

(2) An answer set X of logic program P is an l-answer set if X is l-minimal in AS(P ). By ASl(P ) we denote the set of all

l-answer sets of P .

For example, P = {a ← . p ∨ q ←} has two answer sets X = {a, p} and X

(cid:4) = {a, q}. X is a p-answer set of P , but X

(cid:4)

is

not. This example shows that, for a logic program P and a literal l, not every answer set is an l-answer set.

The sets in ASl(P ) \ l = { X \ {l} | X ∈ ASl(P )} are incomparable, and so we can ﬁnd a logic program which has this
collection as its answer sets. Note that to achieve incomparability, one could select other answer sets than those which are
minimal in AS(P ) \ l (e.g., the maximal ones). However, selecting minimal answer sets is in line with the guiding principle
of logic programming and nonmonotonic reasoning to minimize positive information.

Note that in the above deﬁnition, P was assumed to be consistent (i.e., AS(P ) (cid:15)= ∅). If a logic program is inconsistent,
the result of forgetting seems not to be clear, since the possibility of removing inconsistency from the logic program might
have to be considered. For example, a logic program P may have partial stable models [61] while it is inconsistent under
the answer set semantics (i.e. the stable model semantics). Forgetting from inconsistent programs is an interesting issue,
but we do not consider it here. In the rest of this paper, we always assume that P is a consistent logic program.

The following proposition collects some easy properties of l-answer sets.

Proposition 1. For every consistent program P and every literal l in Lit P , the following holds:

(1) Every l-answer set X of P is an answer set of P .
(2) For every answer set X of P , there exists an l-answer set X
(3) Every answer set X of P with l ∈ X is an l-answer set of P .
(4) If an answer set X of P is not an l-answer set of P , then there exists an l-answer set Y of P such that l ∈ Y and Y ⊂l X .
(5) If l /∈ Lit P , then X is an l-answer set of P iff X is an answer set of P .

of P such that X

(cid:4) ⊆l X .

(cid:4)

1648

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

Having the notion of minimality about forgetting a literal, we are now in a position to deﬁne the result of forgetting

about a literal in a logic program.

Deﬁnition 2 (Semantic forgetting). Let P be a consistent logic program and l be a literal. A logic program P
result of forgetting about l in P , if

(cid:4)

represents the

(1) Lit P (cid:4) ⊆ Lit P \ {l}, i.e., l does not occur in P
(cid:4)
(cid:4)) = ASl(P ) \l, i.e., for every set X
(2) AS(P

(cid:4)
, and
of literals such that l /∈ X

set X of P such that X

(cid:4) ∼l X .

(cid:4)

(cid:4)

, X

is an answer set of P

(cid:4)

iff there exists an l-answer

We use forget(P , l) as a generic notation for a logic program representing the result of forgetting about l in P .

An important difference of the notion of forgetting here from existing approaches to updating and merging logic pro-
grams, cf. [1,10,16,19,31], is that merely l and possibly some other literals are removed. However, no new symbols are
introduced in P

.

(cid:4)

For a consistent logic program P , some program P

as in the above deﬁnition always exists (cf. Algorithm 2 for details).

(cid:4)

However, P

may not be unique. It follows from the deﬁnition that they are all equivalent under answer set semantics.

(cid:4)

Proposition 2. Let P be a consistent logic program and let l ∈ Lit P be a literal. If P
then P

are equivalent.

and P

(cid:4)(cid:4)

(cid:4)

(cid:4)

(cid:4)(cid:4)

and P

are two results for forgetting about l in P ,

Before further properties of forgetting are explored in Section 3.2, let us look at some example programs.

Example 2.

(1) If P 1 = {q ← not p}, then forget(P 1, q) has the empty answer set and forget(P 1, p) the answer set {q}. A possible rep-
resentation for forget(P 1, p) is obtained from P 1 by removing not p in the rule q ← not p, and for forget(P 1, q) by
removing the whole rule q ← not p.

(2) If P 2 = {q ← not p. p ← not q}, then forget(P 2, p) has the empty answer set (which is represented by the empty pro-
gram). Indeed, P 2 has two answer sets {p} and {q} but only {p} is a p-answer set of P 2. Similarly, forget(P 2, q) has the
empty answer set.

(3) Consider P 3 = {q ← not p. p ←}, which has the single answer {p}. Thus forget(P 3, p) has the empty answer set, which
is represented by the empty program, rather than by {q ←}. This is intuitive, because we are forgetting all impacts of p
on P 3. In particular, “forgetting about p” is different from “assuming not p”.
From the above examples, one might guess that some program forget(P , p) can be obtained by simply removing rules
and/or literals with head p and/or positive body literal p, and by removing not p in the remaining rules. However, as
the next example shows, this is not true in general.

(4) Let P 4 = {a ← not b. b ← not a. p ← not a. c ← not p}. According to [71], the result of weak forgetting about p in P 4
is the program WForgetLP(P 4, p) = {a ← not b. b ← not a. c ←}, while the result of strong forgetting about p in P 4 is
the program SForgetLP(P 4, p) = {a ← not b. b ← not a}. Neither is fully intuitive: c depends on a (by means of double
negation), but in both WForgetLP(P 4, p) and SForgetLP(P 4, p) any connection between c and a is lost. In contrast,
forget(P 4, p) has the two answer sets {b} and {a, c} in which the connection between a and c (equivalence via “double
negation” of p) is maintained. Syntactically, forget(P 4, p) may be represented by the program {a ← not b. b ← not a. c ←
a}, for instance, where this connection is maintained via the rule c ← a.

(5) P 5 = {p ∨ q ← not p. c ← q} has the single answer set {q, c}. Here, p is involved in unstratiﬁed negation and must be
false in every answer set. Thus forget(P 5, p) has the same answer set as P 5; a syntactic representation of the program is
= {q ← . c ←}, which intuitively results by pushing through the only possible value for p and simplifying the program.
(6) Let P 6 = {a ∨ p ← not b. c ← not p. b ←}. This program has the single answer set {b, c}, and no atom p is involved
in cyclic negation. Forgetting about p in P 6 does not change the answer set; a possible program for forget(P 6, p) is
{c ← . b ←}, which again corresponds to a simpliﬁed version of the program P 6 the results after pushing through the
value of p (note that the ﬁrst rule in P 6 is never applicable).

We will discuss how to obtain a concrete program forget(P , l) in the next section.

3.2. Basic properties of forgetting

In this subsection, we present some further properties of forgetting. First, the number of answer sets can never increase.

Proposition 3. Let P be a consistent logic program. Then, for every literal l in Lit P , it holds that |AS(forget(P , l))| (cid:3) |AS(P )|.

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1649

This is a simple consequence of the fact that only some, but not all answer sets of P are l-answer sets. Note that this

property is compliant with the principle of closing the world, and eliminating possibilities in favor of a default case.

The following proposition generalizes Proposition 2.

Proposition 4. Let P and P
forget(P

(cid:4), l) are also equivalent.

(cid:4)

be two consistent logic programs and l a literal in P . If P and P

(cid:4)

are equivalent, then forget(P , l) and

However, forgetting here does not preserve some special equivalences of logic programs stronger than ordinary equiv-
alence like strong equivalence [45] or uniform equivalence [17,20]. We recall that two programs P and Q are strongly
equivalent, if for each (ﬁnite) set of rules R the programs P ∪ R and Q ∪ R have the same answer sets; they are uniformly
equivalent, if this holds for each set of facts R.

We say that forgetting preserves an equivalence ≡ X on logic programs, if for every logic programs Q and Q

and for
(cid:4), l). Here X can be strong equivalence, uniform equivalence, or any

every literal l, Q ≡ X Q
other equivalence relation on the collection of (disjunctive) logic programs.

implies forget(Q , l) ≡ X forget(Q

(cid:4)

(cid:4)

An equivalence relation ≡ X for logic programs on Lit is invariant under literal extensions, if the following holds: when-
w.r.t.

are programs such that Lit P , Lit P (cid:4) ⊆ Lit and l /∈ Lit is a new literal, then P ≡ X P

w.r.t. Lit iff P ≡ X P

(cid:4)

(cid:4)

(cid:4)

ever P and P
Lit ∪ {l}.

An equivalence ≡ X is stronger than ordinary equivalence ≡ if the following conditions are satisﬁed:

, P ≡ X P
(1) For any programs P and P
(cid:4)
(2) There exist two programs P and P

(cid:4)

(cid:4)
(cid:4)
implies P ≡ P
such that P ≡ P

.
(cid:4)

and P (cid:15)≡ X P

(cid:4)

.

Proposition 5. Let ≡ X be an equivalence relation on a collection of logic programs on Lit that is stronger than ordinary equivalence
and invariant under literal extensions. Then forgetting does not preserve ≡ X .

Both strong and uniform equivalence [17,45] are clearly stronger than ordinary equivalence, and clearly also invariant
under literal extensions. Hence, none of them is preserved by the deﬁnition of forgetting introduced. This, however, is a
consequence of the freedom to arbitrarily instantiate the generic program forget(P , l). For speciﬁc realizations of forget(P , l),
both strong and uniform equivalence may be preserved under forgetting; for example, the realizations forget1(P , l) and
forget2(P , l) in Section 4 have this property. A suitable notion of forgetting which preserves strong equivalence is interesting
for some applications, but beyond the scope of this paper.

An issue related to this is a possible deﬁnition of forgetting in terms of a consequence relation between logic programs,
in analogy to deﬁning forgetting in the classical context [34], as the strongest program that is a consequence of the given
program P and independent of the literal l to be forgotten. This, however, requires suitable notions of consequence and in-
dependence, and these are not straightforward. The former may well depend on the application purpose of a logic program,
be it for query answering, or for representing solutions of a problem in its answer sets according to the ASP paradigm.
Furthermore, answer set semantics is not monotonic, and thus a simple consequence operator |(cid:9) on a rule by rule bases,
i.e., P |(cid:9) Q if P |(cid:9) r for each rule r ∈ Q , is not suitable. For example, the rule p ← not p is true in all answer sets of
P = {p ← . }, and vice versa p ← is true in all answer sets of Q = {p ← not p}; however, P and Q are not equivalent since
they have different answer sets. This problem may be overcome by using a consequence operator such as SE-consequence
(equivalently, the Logic of Here-and-There [45]) or UE-consequence [20].

Also the notion of independence of a literal from a logic program can be deﬁned in different ways. An obvious notion
is syntactic independence, which is given if l does not occur in P . However, also semantic notions of independence are
conceivable, and one of them can be deﬁned in terms of forgetting; we discuss this further in Section 6.4.

(cid:4)

of Q such that S ⊇ S

Technically, we can reconstruct our notion of forgetting from a logic program in terms of syntactic independence and the
following consequence relation between logic programs: P |(cid:9)⊇ Q if for each answer set S of P there exists some answer
. Clearly, |(cid:9)⊇ is reﬂexive and transitive, and P |(cid:9)⊇ Q , Q |(cid:9)⊇ P implies that P and Q have the
set S
same answer sets. Then, it is not hard to see that each strongest program Q on literals Lit P \ {l} such that P |(cid:9)⊇ Q (i.e., for
) represents forget(P , l). We leave the issue
each other program Q
of deﬁning forgetting through other notions of consequence for further investigation.

over Lit P \ {l} such that P |(cid:9)⊇ Q

it holds that Q |(cid:9)⊇ Q

(cid:4)

(cid:4)

(cid:4)

(cid:4)

The following proposition summarizes some simple but helpful properties of forgetting.

Proposition 6. For every consistent program P and every literal l in Lit P , the following holds:

(1) AS(forget(P , l)) = { X \ {l} | X ∈ ASl(P )}.
(2) If X ∈ ASl(P ) with l /∈ X , then X ∈ AS(forget(P , l)).
(3) For every X ∈ AS(P ) such that l ∈ X , X \ {l} ∈ AS(forget(P , l)).
(cid:4) ∪ {l} is in AS(P ).
(4) For every X
(5) For every X ∈ AS(P ), there exists X
(6) If l does not appear in P , then forget(P , l) ≡ P .

(cid:4) ∈ AS(forget(P , l)), either X

(cid:4) ∈ AS(forget(P , l)) such that X

or X

(cid:4)

(cid:4) ⊆ X .

1650

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

The next proposition says that, after forgetting about a literal in a logic program, the resulting program is equivalent to

the original one under skeptical reasoning, but weaker under credulous reasoning (i.e., inferences are lost).

Proposition 7. Let P be a consistent logic program and let l, l

(cid:4)

be literals in Lit P such that l

(cid:4) (cid:15)= l. Then,

(cid:4)
(1) P |(cid:9)s l
(2) P |(cid:9)c l

(cid:4)

iff forget(P , l) |(cid:9)s l
(cid:4)
if forget(P , l) |(cid:9)c l

(cid:4)

.

, and

The above deﬁnition of forgetting about a single literal l in a logic program P can be straightforwardly extended to a
set F of literals. We can similarly deﬁne X1 ⊆F X2, X1 ∼F X2, and F -answer sets of a logic program, and the properties of
forgetting about a single literal can be generalized to this setting. Furthermore, the result of forgetting about a set F can be
obtained by forgetting the literals in F one by one.

Proposition 8. Let P be a consistent logic program and let F = {l1, . . . , lm} be a set of literals. Then

(cid:2)
forget(P , F ) ≡ forget

(cid:2)
forget(P , l1), l2
forget

(cid:3)
, . . . , lm

(cid:3)
.

Notice that the particular indexing of the literals in F does not matter. This result, which allows to reduce forgetting
to the basic operation for a single literal, is quite useful, but its proof (which is given in Appendix A) requires some
technicalities.

We remark that for removing a proposition p entirely from a program P , it is suggestive to remove both the literals p

and ¬p in P (i.e., all positive and negative information about p). This can be easily accomplished by forget(P , {p, ¬p}).

Let us consider a simple logic program which contains a pair of complementary literals.

Example 3. Let P be the following logic program:

ﬂies(Tweety) ← pigeon(Tweety).
¬ﬂies(Tweety) ← penguin(Tweety).

pigeon(Tweety) ∨ penguin(Tweety) ← .

This program has the answer sets {pigeon(Tweety), ﬂies(Tweety)} and {penguin(Tweety), ¬ﬂies(Tweety)}. If we forget about
only one of ﬂies(Tweety) and ¬ﬂies(Tweety), then the complementary literal must still be in the result of forgetting. For in-
stance, forget(P , ﬂies(Tweety)) has the answer sets {pigeon(Tweety)} and {penguin(Tweety), ¬ﬂies(Tweety)}, where the second
one still contains ¬ﬂies(Tweety); a possible program representing forget(P , ﬂies(Tweety)) is
¬ﬂies(Tweety) ← not penguin(Tweety).

pigeon(Tweety) ∨ penguin(Tweety) ← .

However, by Proposition 8 forget(forget(P , ﬂies(Tweety)), ¬ﬂies(Tweety)) and forget(forget(P , ¬ﬂies(Tweety)), ﬂies(Tweety)) are
equivalent and have the answer sets {pigeon(Tweety)} and {penguin(Tweety)}, which are represented by the program

pigeon(Tweety) ∨ penguin(Tweety) ← .

3.3. Relation to classical forgetting

We now consider the relationship between classical forgetting forget(T , p) and logic programming forgetting forget(P , p).
Besides the stable and the answer set semantics [28,30], another inﬂuential semantics for nonmonotonic logic programming
is the Clarke’s completion semantics [14], which deﬁnes the semantics of logic programs in terms of classical logic. It is
well known that answer set and completion semantics are different in general. For example, the logic program P = {p ← q;
q ← p} has a unique answer set { }. However, Clarke’s completion for P gives {p ≡ q}, which has two models { } and {p, q}.
Lin and Zhao [50,51] showed that the answer set semantics for a logic program can be characterized by a simple extension
of Clarke’s program completion by adding so called loop formulas. They consider normal logic programs that may contain
constraints. This approach allows to compute the answer sets of a normal logic program using a classical SAT solver. Lee
and Lifschitz [39] extended this characterization to the class of disjunctive logic programs. For simplicity, we assume in this
subsection that programs have no strong negation, which can be compiled away in the standard way as usual.

For every logic program P , its completion comp(P ) is the set of propositional formulas containing

• body(r) → head(r) for every rule r in P ,
• and the formula a →

r∈P ,a∈head(r)(body(r) ∧

(cid:4)

(cid:5)

p∈(head(r)\{a})

¬p), for every atom a.

Here head(r) \ L is, for any the set of atoms L, the head set of atoms that occur in head(r) but not in L, and “not ” and comma
“,” in rule bodies are translated into the negation “¬” and conjunction “∧” in classical propositional logic, respectively. An
empty head head(r) is translated into ⊥.

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1651

Given a logic program P , its positive dependency graph G P is the directed graph whose vertices are the atoms occurring
in P and where there is an edge from p to q iff there exists some rule r in P such that p ∈ head(r) and q ∈ body
(r).
A nonempty set L = {p1, . . . , pk} of atoms is a loop of P , if for every distinct pi, p j ∈ L there exists a path of nonzero length
from pi to p j in G P such that all vertices in this path belong to L. The conjunctive loop formula for L is

+

CLF(L) = (p1 ∧ · · · ∧ pk) →

(cid:6) (cid:7)

(cid:8)

φ

,

φ∈R(L)

where R(L) is the set of formulas body(r) ∧

¬p for all rules r ∈ P with head(r) ∩ L (cid:15)= ∅ and body

(r) ∩ L = ∅.

+

For example, L = {p, q} is a loop of the logic program P = {r ∨ p ← q; q ← p}. In this example, R(L) = { } and thus the

right hand side of CLF(L) is an empty disjunction. Thus CLF(L) is the propositional formula (p ∧ q) → ⊥.

Let lcomp(P ) = comp(P ) ∪ CLF(P ), where CLF(P ) is the set of all loop formulas. A fundamental result established by Lin
and Zhao [50] shows that the generalized completion lcomp(P ) exactly characterizes the answer set semantics. This was
extended to disjunctive logic programs by Lee and Lifschitz [39] as follows.

(cid:5)

p∈head(r)\L

Theorem 1. (See [39].) Let P be a (disjunctive) logic program and let X ⊆ Lit P be a set of atoms. Then X is an answer set of P iff X is a
model of lcomp(P ).

Since L = {p, q} is the only loop of P = {r ∨ p ← q; q ← p}, we have CLF(P ) = {(p ∧ q) → ⊥}. Since we have comp(P ) =
{r → q ∧ ¬q, p → q ∧ ¬r, q → p}, we obtain (after some simpliﬁcations) that lcomp(P ) = {p ≡ q, r → ⊥, p → ¬r, q → r,
(p ∧ q) → ⊥}. This theory has exactly one model, namely { }, which is the unique answer set of P .

It is easy to see that lcomp(P ) = comp(P ) if P is negative. Hence,

Corollary 2. Let Q be a negative program (without strong negation) and let X ⊆ Lit P be a set of literals. Then X is an answer set of Q
if and only if X is a model of comp(Q ).

This corollary is a special case of some previous results in [4,26].
Since for a logic program P and an atom p, the two classical theories lcomp(forget(P , p)) and forget(lcomp(P ), p) can
be formed, where in the former logic programming forgetting is applied to P and in the latter classical forgetting to the
theory lcomp(P ), the natural question is how these two theories are related. Intuitively, the models of the ﬁrst theory are
all incomparable, while the models of the second theory may be not.

For example, let P = {p ← not q. q ← not p}. Then lcomp(forget(P , p)) = {¬q}, which has the single model { }, while
forget(lcomp(P ), p) = {(T ↔ ¬q) ∨ (F ↔ ¬q)} ≡ T, which has two comparable models {q} and ∅. However, the minimal models
of forget(lcomp(P ), p) are the same as the models of lcomp(forget(P , p)). In fact, this holds in general.

Theorem 3. Let P be a consistent (disjunctive) logic program and let p ∈ Lit P be an atom. Then X ⊆ Lit P is an answer set of forget(P , p)
iff X is a minimal model of forget(lcomp(P ), p). That is,
(cid:3)
(cid:2)
,
forget(lcomp(P ), p)

(cid:3)
(cid:2)
forget(P , p)

= MMod

AS

where MMod(T ) denotes the set of all minimal models (w.r.t. ⊆) of a theory T in classical logic.

The proof of this theorem is given in Appendix A. We remark that Lang et al. considered in [34] also a notion of forgetting
a literal l from a formula T in classical logic, which can be semantically deﬁned by forget(T , l) = T (p/α) ∨ (¬.l ∧ T (p/¬α)),
where α = (cid:21) if l = p is positive and α = ⊥ if l = ¬p is negative. Note that forgetting an atom p as a literal is stronger
than forgetting p as a propositional variable in general; e.g., forgetting p from ¬p as a literal yields ¬p, while as a variable
yields (cid:21). It is easy to see that Theorem 3 remains valid for this notion of literal forgetting.

The result in Theorem 3 means that forget(P , p) can be characterized by forgetting in classical

If we use
forgetmin(T , p) to denote a set of classical formulas whose models are the minimal models of the classical forgetting
forget(T , p), then the equation in Theorem 3 can be reformulated as

logic.

(cid:2)
forget(P , p)

(cid:3)

lcomp

≡ forgetmin

(cid:2)
lcomp(P ), p

(cid:3)
,

where ≡ denotes classical equivalence. This result is graphically represented in the commutative diagram in Fig. 1. It is quite
useful, since it implies that one can “bypass” the use of a logic programming engine entirely and represent the answer sets
of forget(P , p) in the frameworks of circumscription and closed world reasoning [27,43,54]. This can be done by applying
circumscription to lcomp(P ), which we explain in more detail.

In circumscription, minimality is understood as the impossibility of making, in the context of predicate logic, the extent
of the predicates p1, . . . , pk which are circumscribed in a theory T smaller without changing the extent of the other predi-
cates. Furthermore, some predicates z1, . . . , zl among them may be allowed to vary in the process of minimizing p1, . . . , pk,
which is needed in many applications. As for our concern of propositional logic, all pi and z j are atoms and Circ(T ; (cid:22)p, (cid:22)z)
is a propositional formula with quantiﬁers on atoms which semantically captures the circumscription of a ﬁnite theory T

1652

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

Fig. 1. Commuting logic program completion and forgetting.

Algorithm forget1(P , l)
Input: Consistent (disjunctive) logic program P and a literal l in P .

Output: A normal logic program representing forget(P , l).

Method:
Step 1. Compute AS(P ) using an ASP solver (e.g., DLV or gnT).
Step 2. Remove l from every set in AS(P ) and denote the resulting collection as A(cid:4)
Step 3. Obtain A(cid:4)(cid:4)
Step 4. Construct P

by removing all non-minimal sets from A(cid:4)
(cid:4)

whose answer sets are exactly A(cid:4)(cid:4) = { A1, . . . , Am}:

.

.

– For each Ai , let P i = {l
(cid:4) = P 1 ∪ · · · ∪ Pn.
– Let P

(cid:4) ← not ¯Ai | l

(cid:4) ∈ Ai}, where ¯Ai = Lit P \ Ai .

Step 5. Output P

(cid:4)

as forget(P , l).

Fig. 2. Algorithm forget1(P , l).

with respect to (cid:22)p = (p1, . . . , pk) and (cid:22)z = (z1, . . . , zl). As well known, Circ(T ; (cid:22)p, (cid:22)z) is logically equivalent to Gelfond et al.’s
extended closed world assumption ECWA(T ; (cid:22)p, (cid:22)z) [27], which augments T by additional formulas.

Let us write Circ(T , z) respectively ECWA(T , z) for the case where (cid:22)z contains a single atom z and (cid:22)p all other atoms.
(cid:4) ⊆z M

Then, M is a model of Circ(T ; z) respectively ECWA(T ; z), exactly if M is a z-minimal model of T in the sense that M
implies M

of T . We have the following result.

(cid:4) ∼z M for every model M

(cid:4)

Theorem 4. Let P be a consistent (disjunctive) logic program and let p ∈ Lit P be an atom. Then X ⊆ Lit P \ {p} is an answer set of
forget(P , p) if and only if either X or X ∪ {p} is a model of Circ(lcomp(P ), p) (resp., ECWA(lcomp(P ), p)).

(A proof is given in Appendix A.) By this rather intuitive result, we may exploit also circumscription engines for reasoning
from forget(P , p),3 into which we feed the loop completion lcomp(P ) of P . Note that the latter is exploited by some ASP
solvers (viz. ASSAT, Cmodels) as a stepping stone to compute answer sets, and that classical forgetting of p from lcomp(P )
can be performed eﬃciently; indeed, the formula lcomp(P )(p/(cid:21)) ∨ lcomp(P )(p/⊥) which represents the classical forgetting
forget(lcomp(P ), p), where lcomp(P ) is viewed as a single formula and (p/α) denotes substitution of p by α, is computable
in linear time. On the other hand, lcomp(P ) is exponential in the size of P in general, as P can have exponentially many
loops; see also Section 4.3.3 for further discussion regarding the size of lcomp(P ).

4. Computation of forgetting

As we have noted, forget(P , l) exists for any consistent logic program P and literal l. In this section, we discuss some

issues on computing the result of forgetting.

4.1. Naive algorithm

By Deﬁnition 2, we can easily obtain a naive algorithm for computing forget(P , l) using an ASP solver for logic programs,

like DLV [40] or GnT [33], which is shown in Fig. 2.

It is well known that any collection S of sets of consistent literals which are pairwise incomparable, can be represented

by some logic program P such that AS(P ) = S. In fact, such P can be constructed from S in polynomial time.

Algorithm forget1(P , l) is sound and complete w.r.t. forgetting as in Deﬁnition 2.

Theorem 5. Given a consistent (disjunctive) logic program P and a literal l, Algorithm forget1(P , l) outputs a correct representation of
forget(P , l).

3 E.g., circ2dlp, http://www.tcs.hut.ﬁ/Software/circ2dlp/, or circum1, circum2, http://www.ailab.se.shibaura-it.ac.jp/circumscription.html.

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1653

Algorithm forget2(P , l)
Input: Consistent (disjunctive) logic program P and a literal l in P .

Output: A normal logic program representing forget(P , l).

Method:
Step 1. Let P 1 = P ∪ { ← not l}.

– Compute the answer sets of P 1 (e.g., using DLV or gnT).
– Remove l from each obtained answer set. Let A1 be the resulting collection

of sets. (Each set in A1 is an answer set of forgetting about l from P .)

Step 2. Let P 2 = P ∪ { ← l } ∪ { ← a1, . . . , ak | {a1, . . . , ak} ∈ A1 }.

– Compute the answer sets of P 2 (e.g., using DLV or gnT), and let A2 be the result.
– Set then A = A1 ∪ A2.

Step 3. Construct P

(cid:4)

whose answer sets are exactly A = { A1, . . . , Am}:

– For each Ai , let P i = {l
(cid:4) = P 1 ∪ · · · ∪ Pn.
– Let P

(cid:4) ← not ¯Ai | l

(cid:4) ∈ Ai}, where ¯Ai = Lit P \ Ai .

Step 4. Output P

(cid:4)

as forget(P , l).

Fig. 3. Improvement to Algorithm forget1(P , l).

The above Step 2 may return many answer sets in A(cid:4)

that are not minimal; in fact, it is easy to ﬁnd examples where A(cid:4)
contains exponentially many sets but only few of them are minimal. For example, let P = {p ∨ q ← . ai ∨ bi ← q, 1 (cid:3) i (cid:3) n}.
Then P has the single p-minimal answer set {p}, but exponentially many other answer sets {q, l1, . . . , ln}, where li is either
ai or bi , which all lead to non-minimal sets in A(cid:4)

.

To avoid this problem, we present an improved version of Algorithm forget1(P , l) in the next subsection.

4.2. Improved algorithm

An improved version of Algorithm forget(P , l), which is shown in Fig. 3, pushes the task of minimality checking for
candidate l-answer sets of P into constraint satisﬁability of an augmented program. It exploits in this way the constraint
solving capabilities offered by some ASP solvers.

Since the answer sets of P

(cid:4)

are exactly A, Algorithm forget2(P , l) is sound and complete w.r.t. semantic forgetting.

Theorem 6. For every consistent (disjunctive) logic program P and a literal l, Algorithm forget2(P , l) outputs a correct representation
of forget(P , l).

The advantage of Algorithm forget2(P , L) is that the strategy in the Steps 1 and 2 makes l-minimization obsolete and
thus no blowup into a large intermediate result with respect to the number of answer sets as in Algorithm forget1(P , l) can
may be large compared to a small program representing forget(P , l) (in fact,
happen. Still, however, the resulting program P
exponentially larger), which might be constructed from P by other means (we refer here to the discussion of Algorithm
forget3(P , l) below). In the next subsection, we discuss how to construct a representation of forget(P , l) in a more syntactic
manner by program transformations.

(cid:4)

However, the “semantic” constructions by forget1(P , l) and forget2(P , l) also have an advantage: they clearly preserve the
equivalence of logic programs under any notion of equivalence ≡ X between logic programs that is stronger than ordinary
equivalence, and thus in particular under strong and weak equivalence. This is a simple consequence of the fact that for all
programs P which are ordinarily equivalent the output of forget1(P , l) is the same, and similarly for forget2(P , l).

4.3. Transformation-based algorithm

The algorithm forget1(P , l) and forget2(P , l) are based on the semantic view of forgetting, and do not aim at computing
the result of forgetting in a more syntax-oriented manner, by modifying the rules in P . In this subsection, we present
an algorithm forget3(P , l) of this kind that is based on program transformations. This algorithm outputs, differently from
forget1(P , l) and forget2(P , l), not always ordinary logic programs but sometime logic programs in which some literals are
under double negation as failure. They inherit their semantics from the more general class of nested logic programs [46].

Before presenting algorithm forget3(P , l), we need further preliminaries on program transformations and programs with

double negation as failure.

1654

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

4.3.1. Basic program transformations

We start with recalling program transformations that were discussed in [8,66]. More precisely, we consider the following

∗
collection T

of program transformations:

Elimination of Tautologies P
(r), not body

body

+

(cid:4)
−

is obtained from P by the elimination of tautologies if there is a rule r: head(r) ←
(r) in P such that head(r) ∩ body

(r) (cid:15)= ∅ and P

(cid:4) = P \ {r}.

+

Example 4. Let P 1 consist of the following rules:

p ← p, not q1
p ← p1, not q1
p1 ← not q, not p2
q1 ← p2, not q

r1 : p ∨ p1 ← not p1
r2 :
r3 :
r4 :
r5 :
r6 :
p ∨ q1 ←
r7 : p1 ∨ p3 ←
r8 :

p3 ← p, not p.

Then r2 is a tautology and thus P 2 = {r1, r3, r4, r5, r6, r7, r8} can be obtained from P by the elimination of tautologies.

Elimination of Head Redundancy P

(cid:4)

that a literal l is in both head(r) and body
disjunction obtained by removing l from head(r).

is obtained from P by the elimination of head redundancy if there is a rule r in P such
(cid:4) = P \ {r} ∪ {(head(r) − l) ← body(r)}. Here head(r) − l is the

(r) and P

−

By the elimination of head redundancy, r1 is simpliﬁed into r
(cid:4)
{r
1, r3, r4, r5, r6, r7, r8}.
The above two transformations guarantee that those rules whose head and body have common literals are removed.

: p ← not p1 and thus P 2 is transformed into P 3 =

(cid:4)
1

Positive Reduction P

is obtained from P by positive reduction if there is a rule r: head(r) ← body

(cid:4)

+

(r), not body

−

P and c ∈ body
P \ {r} ∪ {head(r) ← body

(r) such that c /∈ head(P ) and P
(r), not (body

+

−

(r) \ {c})}. Here head(P ) =

(cid:9)

(cid:4)

−

r∈P head(r).

is obtained from P by removing not c from r. That is, P

(r) in
(cid:4) =

(cid:4)
(cid:4)
P 4 = {r
4, r
1, r3, r
(cid:4)
5 is q1 ← p2.
p1 ← and r

(cid:4)
5, r6, r7, r8} is obtained from P 3 = {r

(cid:4)
1, r3, r4, r5, r6, r7, r8} by positive reduction, where r

(cid:4)
4 is the rule

Negative Reduction P

(cid:4)

(cid:4)

and r

: head(r

is obtained from P by negative reduction if there are two rules r: head(r) ← body
(cid:4)) ← in P such that head(r
(r) and P

(cid:4) = P \ {r}.

(cid:4)) ⊆ body

−

+

(r), not body

−

(r)

In our example, P 5 = {r3, r
For deﬁning the next program transformation, we need the notion of implications for rules deﬁned in [8]. We say r

(cid:4)
5, r6, r7, r8} is obtained from P 4 by negative reduction, where r = r

(cid:4)
1 and r

(cid:4) = r

(cid:4)
4, r

(cid:4)
4.

implication of r if head(r) ⊆ head(r

(cid:4)), body(r) ⊆ body(r

(cid:4)) and at least one of the inclusions is strict.

(cid:4)

is an

Elimination of Implications P

is obtained from P by the elimination of implications if there are two distinct rules r and r

(cid:4)

of P such that r

is an implication of r and P

(cid:4) = P \ {r

(cid:4)}.

(cid:4)

(cid:4)

In the above example, r7 is an implication of r

of implications.

(cid:4)
4 and thus P 6 = {r3, r

(cid:4)
4, r

(cid:4)
5, r6, r8} is obtained from P 5 by the elimination

Elimination of Contradictions P
+

−

body

(r) ∩ body

(r) (cid:15)= ∅ and P

(cid:4) = P \ {r}.

(cid:4)

is obtained from P by elimination of contradictions if there is a rule r in P such that

By the elimination of contradictions, r8 can be removed from P 6 and thus we obtain P 7 = {r3, r

(cid:4)
4, r

(cid:4)
5, r6}.

Unfolding P

(cid:4)

is obtained from P by unfolding if there is a rule r with body

+

(r) (cid:15)= ∅ such that

P

(cid:4) = P \ {r}
(cid:10)
∪

H(r, r

(cid:4)

, b) ← B(r, r

(cid:4)

, b) | b ∈ body

+

(r), r
(cid:2)
head(r

(cid:4) ∈ P , b ∈ head(r
(cid:3)
,

(cid:4)

) \ {b}
−

(cid:4)

), r

(cid:4) (cid:15)= r

(cid:11)

.

(cid:4)

)

, b) = body

+

(r) \ {b}, not body

(r), body(r

, b) = head(r) ∪

(cid:4)

H(r, r
(cid:4)

B(r, r

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1655

P 7 is further transformed into P 8 = {r

(cid:4)
4, and in
(cid:4)
5 is removed as a special case of the unfolding since there is no rule in P 7 whose head can be unfolded with

: p ← not q1 is obtained from P 7 by unfolding r3 and r

(cid:4)
4, r6} where r

(cid:4)
3, r

(cid:4)
3

particular, r
the positive body literal p2 of r

(cid:4)
5.

Note that the above example is only used to illustrate the deﬁnitions of program transformations. In practice, one could

make the process of simplifying P 1 more eﬃcient by choosing different transformations and different orderings.

As shown by [7], the program transformations from T

considered there, i.e., all except the elimination of head redun-

∗

dancy, preserve the answer set semantics. The same also holds for the latter transformation.

Proposition 9. Let P be a disjunctive program. If P
the same answer sets.

(cid:4)

is obtained by the elimination of head redundancy from P , then P and P

(cid:4)

have

Furthermore, by [8] every disjunctive program can be converted with the transformations in T

considered there into
an equivalent negative disjunctive program. Moreover, by using the elimination of tautologies and the elimination of head
redundancy (which preserves negative rules), every literal that occurs both in the head and the body of a rule can be
removed. Thus, we have the following result.

∗

Lemma 1. Every logic program P can be transformed into an equivalent negative program N via T
head(r) ∩ body(r) = ∅.

∗

such that every rule r in N fulﬁlls

In fact, transformations can be applied in arbitrary manner and no backtracking is necessary to construct such a negative
program N (i.e., choices for transformations are “don’t care”). In addition, we introduce only basic program transformations
here. One can introduce some other program transformations, such as the elimination of s-implications in [66], to further
simplify the negative program obtained from basic transformations.

4.3.2. Logic programs with double negation

A disjunctive logic program with double negation as failure (DDLP) is a ﬁnite set of rules r of the form

a1 ∨ · · · ∨ as ← b1, . . . , bm, not c1, . . . , not cn, not not d1, . . . , not not dt

(2)

where s, m, n, t (cid:2) 0 and all ai , b j , ck, and dl are from a set Lit of classical literals; as above, we assume that all ai , and
similarly all b j , all ck, and all dl, are pairwise distinct. (Note that form (1) results for t = 0.) The deﬁnition of head(r),
(r) = {d1, . . . , dt}. Thus, r can be denoted head(r) ←
body
body

(r) is analogous to ordinary rules (1), and body

(r), and body
−
(r), not body

(r) = {not not l | l ∈ body

(r), where not not body

(r), not not body

(r)}.

−−

−−

−−

−−

+

+

−

Every DDLP P is a nested logic program [46], and inherits answer set semantics from such programs. Formally, the reduct
(r) ⊆ X}. As usual,

(r) ∩ X = ∅, body

(r) | r ∈ P , body

of P w.r.t. an interpretation X is deﬁned as P X = {head(r) ← body
X is an answer set of P iff X is a minimal model of P X .

−−

−

+

Different from ordinary logic programs, the answer sets of DDLP may be comparable. For example, the DDLP P = {p ←

not not p} has the two answer sets ∅ and {p}. For our purposes, we will use those answer sets of P which are minimal.

Clearly, all answer sets of P are minimal iff they are all incomparable, and the latter is equivalent to the fact that P can
be rewritten to an ordinary logic program. While this is diﬃcult and expensive to check in general,4 there is an attractive
syntactic class for which a simple rewriting exists.

Similar as for logic programs with default negation in rule heads [32], double negations can be safely eliminated from a

DDLP without changing its semantics, if there is no cycle through positive and double negated dependencies.

Deﬁnition 3. A DDLP P is N-acyclic, if there is a level mapping L : Lit P → {0, 1, . . .} of the literals in P to the non-negative
integers such that for every rule r in P , the following two conditions hold:

(i) L(l) (cid:2) L(l
(ii) L(l) > L(l

(cid:4)) for all l ∈ head(r) and l
(cid:4)) for all l ∈ head(r) and l

+
(cid:4) ∈ body
(cid:4) ∈ body

−−

(r).

(r).

Note that there are no conditions L(l) > L(l

(cid:4) ∈
(cid:4)), for all l ∈ head(r) and l
head(r) as in the familiar deﬁnition of stratiﬁed logic programs. By exploiting standard methods for testing whether a logic
program is stratiﬁed (cf. [38]), one can eﬃciently decide whether a given DDLP program P is N-acyclic in linear time in the
size of P .

(cid:4)), for all literals l, l

(r), and L(l) = L(l

(cid:4) ∈ body

Given a DDLP P , let T (P ) be the logic program obtained from P by canceling every double negation not not in it. For

−

example, if P 0 = {p ← q, not q

(cid:4), not not q

(cid:4)(cid:4)}, then T (P 0) = {p ← q, not q

(cid:4), q

(cid:4)(cid:4)}. We have the following result.

4 More precisely, this problem is (cid:4)p

2 -complete, as two comparable answer sets of P can be guessed and checked in polynomial time with an NP oracle.
2 -hardness can be shown by an easy reduction from deciding whether a given logic program (without strong negation) has no answer set, which is

The (cid:4)p
(cid:4)p

2 -complete [22].

1656

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

Algorithm forget3(P , l)
Input: Consistent (disjunctive) logic program P and a literal l in P .

Output: DDLP logic program N

(cid:4)

whose minimal answer sets are AS(forget(P , l)).

Method:

∗
Step 1. Apply program transformations in T
Step 2. Separate l from head disjunction via semi-shifting:

on P to obtain a negative program N0.

– Replace each rule r ∈ N0 such that head(r) = l ∨ l1 ∨ · · · ∨ lk, where k (cid:2) 1, by the two

rules l ← not l1, . . . , not lk, body(r) and l1 ∨ · · · ∨ lk ← not l, body(r).

Let N be the resulting logic program.

Step 3. Suppose that r1, . . . , rn are the rules in N with head l, where r j : l ← not l j1, . . . , not l jm j

and m j (cid:2) 0 for 1 (cid:3) j (cid:3) n. Distinguish three cases:
3.1. If n = 0, then obtain the program Q by removing in N all literals not l.
3.2. If n > 0 and m j = 0 for some 1 (cid:3) j (cid:3) n (i.e., l ← is a rule in N), then obtain the pro-

gram Q by removing from N all rules whose bodies contain not l.

3.3. If n > 0 and m j > 0 for all 1 (cid:3) j (cid:3) n, let D 1, . . . , D s be all possible conjunctions

of form not not l1k1 , . . . , not not lnkn where 0 (cid:3) k1 (cid:3) m j , 1 (cid:3) j (cid:3) n.
Obtain the program Q by replacing in N each not l by all D i (one at a time).
Step 4. Remove all rules with l in the head from Q and output the resulting program N

(cid:4)

.

Theorem 7. For every N-acyclic DDLP P , it holds that AS(P ) = AS(T (P )).

Fig. 4. Syntax-based algorithm to compute forgetting.

(See Appendix A for the proof.) Note that since every ordinary logic program is trivially N-acyclic, we can view N-acyclic
DDPs as a syntactic extension of ordinary logic programs. The fact that N-acyclic DDLPs can be easily cast to ordinary logic
programs will be used for transformation-based forgetting.

4.3.3. The algorithm

We are now in a position to present a syntax-based algorithm for computing forgetting in a logic program. The algorithm
forget3(P , l), which is shown in Fig. 4, ﬁrst translates the input program P into a negative program N (Step 1) and then
separates l from head disjunction (Step 2). After that, l is eliminated from rule bodies (Step 3), and ﬁnally from rule heads
(Step 4). The resulting output program is, in general, a logic program with double negation as failure.

Example 5. Consider P 4 = {c ← not q. p ← not q. q ← not p}. Then, in Step 1 we have N0 = P 4 since P 4 is already negative,
and in Step 2 N = P 4 since P 4 is normal. In Step 3, we have n = 1 and r1 = p ← not q. Thus, case three applies and we have
(cid:4) = {c ← not q. q ← not not q}
D1 = not not q; we obtain Q = {c ← not q. p ← not q. q ← not not q}. In Step 4, the program N
is output. This program has the answer sets {c} and {q}, which are both minimal. They are the same as the answer sets of
forget(P 4, p).

Note that Algorithm 1 in [65] outputs on the input of P 4 and p the program N

(cid:4) = {c ← not q. q ← q}, which has the
single answer set {c}. However, the semantic result of forgetting about p in P 4, as deﬁned [65] and in this paper, has
another answer set, viz. {q}. This shows that Algorithm 1 in [65] is incomplete, i.e., outputs in general a logic program that
represents only a subset of all answer sets after forgetting.
Several remarks on Algorithm forget3(P , l) are in order.
(1) As formulated here, the algorithm is stated in a very general form. A number of reﬁnements and improvements can be
made in order to make it more eﬃcient and the result more compact. For example, in Step 1 some program transformations
could be omitted for special programs and various heuristics could also be employed. In Step 3, only those D i need to be
considered which, after removal of duplicate literals, are not properly contained in some other D j . To compute them, one
can use eﬃcient hypergraph transversal algorithms (see [25]).

(2) In the construction of D i , not not li j cannot be replaced with li j (even for a normal logic program). As shown by
Example 5, the resulting output program {c ← not q. q ← q} would only represent a subset of ASl(P ), and thus would
be incorrect. The use of double negation as failure, which remedies this problem, seems to be intuitive. It remains as an
interesting issue whether this can be avoided in a similar transformation based algorithm.

(3) The running time of algorithm forget3(P , l) is worst case exponential, and the output program may be exponentially
representing
large. As follows from complexity considerations in Section 5, there is no ordinary or nested logic program P
forget(P , l) which can be constructed in polynomial time, even if auxiliary literals might be used which are projected from
the answer sets of P

.

(cid:4)

(cid:4)

(4) In essence, algorithm forget3(P , l) improves the corresponding Algorithm 1 in [65] in at least two ways: it works
for the more expressive class of disjunctive logic programs, and importantly, its output correctly represents the result of
forgetting. This is shown formally by the following result.

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1657

Theorem 8. Let P be a consistent disjunctive logic program and let l ∈ Lit P be a literal. Then forget3(P , l) correctly represents
forget(P , l), i.e., X is an answer set of forget(P , l) iff X is a minimal answer set of N

.

(cid:4)

(For a proof, see Appendix A.) While the output program of forget3(P , l) generally contains double negation as failure
and its minimal answer sets have to be considered, Theorem 7 provides a simple condition for transforming the output of
Algorithm forget3(P , l) into an ordinary logic program in some cases.

Proposition 10. Let P be a consistent logic program, let l ∈ Lit P be a literal, and let N
N-acyclic, then ASl(P ) = AS(T (P

(cid:4))), i.e., the ordinary logic program T (P

(cid:4)

(cid:4)) correctly represents forget(P , l).

be the output of Algorithm forget3(P , l). If N

(cid:4)

is

For arbitrary inputs, it is not clear whether the output of forget3(P , l) is an N-acyclic program. We note here a relevant

subclass which has this property, given by a simple syntactic condition that can be eﬃciently recognized.

Recall that the standard dependency graph of a program P , denoted DG P , has Lit P as vertices and a positive edge from
if
(r) for some rule r ∈ P . A (directed) cycle in the graph DG P is negative, if it contains at least one

(r) ∪ (head(r) − l) for some rule r ∈ P and a negative edge from l to l

if l ∈ head(r) and l

(cid:4)
(cid:4) ∈ body

(cid:4) ∈ body

+

−

(cid:4)

literal l to literal l
l ∈ head(r) and l
negative edge.

Proposition 11. Let P be a consistent normal logic program and let l ∈ Lit P be a literal. If no negative cycle of DG P contains l, then
forget3(P , l) outputs an N-acyclic program.

In Example 2, for l = p the programs P 1, P 3, and P 4 have this property (as well as P 6 after removal of the redundant

disjunctive rule). Hence, the outputs of the respective calls forget3(P i, p) can be cast to ordinary logic programs.

Unfortunately, the extension of Proposition 11 from normal to disjunctive logic programs fails, even for the simple case
where P = {p ∨ q ← . } and l = p. However, it is possible to single out fragments for which this is possible, which we leave
for future work.

Computing a representation of forget(P , l) can be reﬁned in different directions. One is to localize the computation, such
that only a relevant part of the program P is subject to modiﬁcation when forgetting a literal l, while the rest of P remains
untouched. This is, for example, easy if P is a normal logic program; in that case, merely the value of l in the single answer
set of P has to be plugged in for all occurrences of l in P and the resulting program be simpliﬁed.

Another case is if P splits into separate components P 1 ∪ · · · ∪ Pn such that the answer sets of P can be obtained by

combining the local answer sets of each P i .

(cid:4)

To this end, we call a literal l

in a program P unaffected by the forgetting of literal l, if there is no path between l and l
in the undirected version of the dependency graph DG P . Suppose U (P , l) is the set of all rules in P that only involve such
literals l

. Then the following easy property holds.

(cid:4)

(cid:4)

Proposition 12. For every (consistent) program P and literal l, it holds that forget(P , l) ≡ U (P , l) ∪ forget(P \ U (P ), l).

This property is in line with N-acyclicity: disconnected components cannot destroy the N-acyclicity of the (rewritten)
program. Furthermore, it can be combined with Proposition 11 to enlarge the classes of programs P for which forget(P , l) is
representable by an ordinary logic program.

Note that Proposition 12 is independent of the concrete syntactic form of forget(P , l); it may well be generalized for
speciﬁc such forms and/or classes of programs. For example, if P can be split into programs P 1 and P 2 such that l occurs
only in P 1, program P 2 has a single answer set S (e.g. if P 2 is normal and stratiﬁed), and no head of a rule in P 1 occurs in
P 2, then

forget3(P , l) ≡ forget3

P 1 ∪ {l

(cid:4) ← . | l

(cid:4) ∈ S}, l

∪ P 2.

(cid:2)

(cid:3)

A detailed study of this issue remains for future work.

We close this section with a brief comparison of the representation size of forget(P , l) in terms of the programs output
by the algorithms forget1(P , l), forget2(P , l), and forget3(P , l), and the formula Circ(lcomp(P ), l) from Section 3.3, where l is
an atom p and Circ(lcomp(P ), l) is viewed as a formula with quantiﬁers as usual (cf. [42,43]); its size is polynomial in the
size of lcomp(P ). Note that forget1(P , l) and forget2(P , l) have always the same output.

Compared to the algorithms forget1(P , l) and forget2(P , l), the size of the output of forget3(P , l) is orthogonal, in the sense
that there instances where the former produce an output program that is exponentially smaller respectively larger than the
one produced by forget3(P , l).

For example, the program P = {ai ← not bi | 1 (cid:3) i (cid:3) n} ∪ {p ←} has exponentially many answer sets and each contains
p; the output of forget1(P , p) and forget2(P , p) thus contains exponentially many rules, while forget3(P , p) consists of P \
{p ←}. On the other hand, the program Q = {pi ← not p. qi ← not p. p ← not pi, not qi | 1 (cid:3) i (cid:3) n}, has two answer sets,
viz. {p} and {p1, q1, . . . , pn, qn}, and thus forget(Q , p) has the empty answer set; here,
forget1(Q , p) and forget2(Q , p)
consist of a single rule, while forget3(Q , p) contains exponentially many rules of the form pi ← not not a1, . . . , not not an and
qi ← not not a1, . . . , not not an, where each a j is either p j or q j , for all i = 1, . . . , n.

1658

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

Table 1
Complexity of forgetting (entries are completeness results; l, l

(cid:4)

are literals, P is a logic program, X is a set of literals)

Program P
X ∈ ASl(P )? (model checking)
(cid:4)
forget(P , l) |(cid:9)c l
?
(cid:4)
forget(P , l) |(cid:9)s l
?

disjunctive
(cid:4)p
2
(cid:5) p
3
(cid:4)p
2

negative

co-NP
(cid:5) p
2
co-NP

normal

co-NP
(cid:5) p
2
co-NP

Also the representation of forget(Q , p) in terms of minimal models described in Section 3.3, Circ(lcomp(Q ), p), is expo-
nentially smaller than forget3(Q , p): as Q is negative, lcomp(Q ) = comp(Q ). On the other hand, for the program P above,
lcomp(Q ) is like forget3(P , p) small while forget1(P , p) and forget2(P , p) are exponentially larger. Finally, it is easy to ﬁnd
programs P such that, for some atom p, forget3(P , p) is exponentially smaller than lcomp(P ), if no optimization are applied.
this also holds if P is negative (where lcomp(P ) is easily formed.

Thus in summary, the three representations obtained by forget1(P , l)/forget2(P , l), forget3(P , l), and Circ(lcomp(P ), p) are,

in their basic form, orthogonal in size.

5. Computational complexity

In this section, we address the computational complexity of forgetting for different classes of logic programs. Our main
complexity results for forgetting are compactly summarized in Table 1. They show that for general logic programs, (1) model
checking under forgetting is (cid:4)p
2 -complete; (2) credulous reasoning under forgetting is (cid:5) p
3 -complete; and (3) skeptical rea-
soning under forgetting is (cid:4)p

2 -complete.

Intuitively, this complexity is explained by two respectively three intermingled sources of complexity (i)–(iii): For prob-
(cid:4) ⊂l S
lem (1), given an answer set S of a program P and a literal l, (i) the number of candidate answer sets S
is in fact an answer set of P ; for problem (2), in addition (iii) the number of
and (ii) the test whether a given such S
candidate l-answer sets S containing the query literal l
. Note, however, that for problem (3) source (i) is absent (by Propo-
sition 7) and only (ii) and (iii) (in dual form) are present, causing the same complexity as for standard skeptical reasoning
(without forgetting).

such that S

(cid:4)

(cid:4)

(cid:4)

For normal programs and negative logic programs, the complexity of all problems is lowered by one level of the Poly-
nomial Hierarchy. Intuitively, the reason is that source (ii), i.e., model checking for such programs, is polynomial in both
cases.

In the rest of this section, we state and develop the complexity results formally, and also argue that space-eﬃcient
representations of forget(P , l) in terms of ordinary (disjunctive) logic programs are unlikely to exist. The design of Algorithm
forget3(P , l) in Section 4 is heavily inﬂuenced by the complexity analysis.

Theorem 9. Given a consistent (disjunctive) logic program P , a literal l, and a set of literals X , deciding whether X is an l-answer set
of P is (cid:4)p

2 -complete.

Intuitively, in order to show that X is an l-answer set, we have to witness that X is an answer set (which is coNP-
(cid:4) ⊂l X . Any X
disproving this can be guessed and
of P such that X
complete to test), and that there is no answer set X
checked using an NP-oracle in polynomial time. Thus, l-answer set checking is in (cid:4)p
2 , as stated in Theorem 9. The hardness
result is shown by a reduction from deciding whether a given logic program P (without strong negations) has no answer
set, which is (cid:4)p

(cid:4)

(cid:4)

2 -complete [22].

If P is either negative or normal, l-answer checking is co-NP-complete.

Theorem 10. Given a consistent normal logic program P , a literal l, and a set of literals X , deciding whether X is an l-answer set of P
is co-NP-complete.

The proof of this theorem exploits that the reduction in the proof of Theorem 9 still works for normal programs, and

that deciding whether a normal logic program has an answer set is well known to be NP-complete [4,52].

Using a minor modiﬁcation of the reduction in the proof of Theorem 9, we can show the co-NP-completeness for negative
programs. Notice that, as already mentioned, deciding whether a given set of literals is an answer set of negative program
is feasible in polynomial time, which explains the complexity drop.

Theorem 11. Given a consistent negative program P , a literal l, and a set of literals X , deciding whether X is an l-answer set of P is
co-NP-complete.

The following theorem shows that credulous reasoning with forgetting has a higher complexity.

Theorem 12. Given a consistent (disjunctive) logic program P and literals l and l

(cid:4)

, deciding whether forget(P , l) |(cid:9)c l

(cid:4)

is (cid:5) p

3 -complete.

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1659

In Theorem 12, a suitable l-answer set containing l
3 . The (cid:5) p

credulous inference forget(P , l) |(cid:9)c l
(QBFs) of the form ∃Z ∀ X∃Y φ.

is in (cid:5) p

(cid:4)

(cid:4)

can be guessed and checked, by Theorem 9 using (cid:5) p

2 -oracle. Hence,
3 -hardness is shown by an encoding of quantiﬁed Boolean formulas

The construction in the proof of Theorem 11 can be lifted to show that credulous inference with forgetting is (cid:5) p
2 -

complete for negative programs.

Theorem 13. Given a consistent negative program P and literals l and l

(cid:4)

, deciding whether forget(N, l) |(cid:9)c l

(cid:4)

is (cid:5) p

2 -complete.

In fact, the program constructed to show the hardness part of this result is normal. Therefore, we easily derive the

following result.

Theorem 14. Given a consistent normal program N and literals l and l

(cid:4)

, deciding whether forget(N, l) |(cid:9)c l

(cid:4)

is (cid:5) p

2 -complete.

The complexity results for skeptical reasoning with forgetting are straightforward from Proposition 7 and well-known

results about the complexity of normal logic programs (see [15,22,52]).

Theorem 15. Given a consistent logic program P and literals l and l
disjunctive logic programs P , and (ii) co-NP-complete for normal logic programs and for negative logic programs P .

, deciding whether forget(P , l) |(cid:9)s l

is (i) (cid:4)p

(cid:4)

(cid:4)

2 -complete for arbitrary

By applying techniques that build on non-uniform complexity classes from [12], one can show that for a given (disjunc-
representing forget(P , l) that has size
tive) program P and literal l there is generally no ordinary disjunctive program P
polynomial in the size of P , unless the Polynomial Hierarchy collapses. This remains true even if auxiliary literals might be
to obtain the models of forget(P , l). This means
used in P
that the exponential blow up of forget(P , l) is, in a formal sense, unavoidable in general.

for the representation which are projected off the models of P

(cid:4)

(cid:4)

(cid:4)

2 deﬁned in [12,13]. Informally, this means that problem is among the hardest in (cid:25)(cid:2)(cid:4)p

More precisely, it can be shown that the model checking problem for forgetting is complete for the complexity class
(cid:25)(cid:2)(cid:4)p
2 , which contains those prob-
lems that are decidable in (cid:4)p
2 with preprocessing of the input (which depends on a “ﬁxed” part and the size of the input).
The preprocessing can resort to precompiled knowledge in polynomial-size data structures, where the compilation cost does
not count. Technically, the (cid:4)p
2 -completness of model checking for forgetting implies that (a syntactic variant of) the prob-
lem belongs to (cid:25)(cid:2)(cid:4)p
2 -hard, as evaluating a QBF of the form ∀ X∃Y φ can be
reduced (under the suitable notion of reduction) to model checking for forgetting. The proof is similar in spirit to the one
of Theorem 3.2 in [13], which shows (cid:25)(cid:2)(cid:4)p
2 hardness of clause inference from the minimal models of a propositional CNF,
but uses the encoding of QBFs into model checking for forgetting given in the proof of Theorem 9 via [22]. We refrain here
from further details.

2 . On the other hand, the problem is (cid:25)(cid:2)(cid:4)p

Now while model checking for forgetting is (cid:25)(cid:2)(cid:4)p

2 -hard, model checking for ordinary disjunctive programs is well known
to be in co-NP (cf. [15,21]). From Theorem 5 in [12], it follows that for arbitrary logic programs P and literal l there exists
no representation of forget(P , l) by an ordinary (disjunctive) logic program of size polynomial in the size of P unless the
Polynomial Hierarchy collapses (which is considered to be unlikely).

Analogously, one can show that for normal programs P , forget(P , l) is not representable by normal programs of poly-
nomial size in the size of P , unless the Polynomial Hierarchy collapses, again even if auxiliary literals might be used as
above.

However, we point out that if auxiliary literals would be allowed, then we can represent forget(P , l) in terms of the
minimal answer sets of a polynomial-size logic program with double negation as failure. More precisely, let s and pl be
fresh auxiliary literals, and use l itself as an auxiliary literal. Let

• P 1 be the program resulting from P by adding not s in each rule body, let
• P 2 be the program resulting from P by replacing each occurrence of l with pl and by adding s in each rule body, and

let

• Q = P 1 ∪ P 2 ∪ {s ← not not s.

l ← s. ← not l, not s. ← pl, s}.

Note that Q is easily constructed from P and l (in linear time). Informally, s is a switch between P 1 and P 2, to compute
the answer sets of P where l is true (via P 1 and the constraint ← not l, not s, when s is false) respectively false (via P 2,
when s is true). In order to make these answer sets l-comparable, in the computations of P 2 the literal pl replaces l and l
is artiﬁcially included (by l ← s) while pl is excluded (through ← pl, s). The answer sets S of Q (which all contain l and
but not pl) correspond then one-to-one to the answer sets of P . Now every S such that s /∈ S is a minimal answer set of Q ,
while if s ∈ S, then S is minimal iff it contains no answer set S
properly. Consequently, the minimal
answer sets S of Q encode the l-answer sets of P , and thus the answer sets of forget(P , l), which are given by S \ {l, s}.

of Q such that s /∈ S

(cid:4)

(cid:4)

1660

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

6. Applications

In this section, we present some applications of the results on forgetting from logic programs in the previous sections.
In particular, we consider applications to conﬂict resolution in logic-based multi-agent systems, which is obviously an im-
portant task, to inheritance logic programs, which model objects and classes with inheritance of properties, and to logic
program updates. A further application in the area of ontology merging and alignment (in an extended framework), is de-
scribed in [24]. The applications show the usefulness of our results about forgetting in different respects: On the one hand,
for ﬁnding novel solutions to problems (like in conﬂict resolution and ontology merging), and on the other hand, to obtain
novel characterizations (and thus interpretations) of existing concepts (like for inheritance logic programs and logic program
updates).

6.1. Resolving conﬂicts in multi-agent systems

As the ﬁrst application, we present a general framework for resolving conﬂicts in multi-agents systems, which is inspired
from the preference recovery problem [35]. In particular, an example is given to show the elegance of using the semantic
forgetting in answer set programming to solve the problem of preference recovery for multi-agents.

Suppose that there are n agents who may have different preferences on the same issue. In many cases, these preferences
(or constraints) have conﬂicts and thus cannot be satisﬁed at the same time. It is an important issue in constraint reasoning
to ﬁnd intuitive criteria such that preferences with higher priorities are satisﬁed. Consider the following example.

Example 6. (See [35].) Suppose that a group of four residents in a complex tries to reach an agreement on building a
swimming pool and/or a tennis court. The preferences and constraints are as follows.

(1) Building a tennis court or a swimming pool costs each one unit of money.
(2) A swimming pool can be either red or blue.
(3) The ﬁrst resident would not like to spend more than one money unit, and prefers a red swimming pool.
(4) The second resident would like to build at least one of tennis court and swimming pool. If a swimming pool is built,

he would prefer a blue one.

(5) The third resident would prefer a swimming pool but either color is ﬁne with him.
(6) The fourth resident would like both tennis court and swimming pool to be built. He does not care about the color of

the pool.

Obviously, the preferences of the group are jointly inconsistent and thus it is impossible to satisfy them at the same time.

In the following, we will show how to resolve this kind of preference conﬂicts and ﬁnd possible agreements with minimal

costs using the theory of forgetting.

An n-agent system S is an n-tuple (P 1, P 2, . . . , Pn) of logic programs, n > 0, where P i represents agent i’s knowledge

(including preferences, constraints).

As shown in Example 6, P 1 ∪ P 2 ∪ · · · ∪ Pn may be inconsistent. The basic idea in our approach is to forget some literals

for each agent so that conﬂicts can be resolved.

Deﬁnition 4. Let S = (P 1, P 2, . . . , Pn) be an n-agent system. A compromise of S is a sequence C = (F 1, F 2, . . . , Fn) where
each F i is a set of literals. An agreement of S on C is an answer set of the logic program forget(S, C) where forget(S, C) =
forget(P 1, F 1) ∪ forget(P 2, F 2) ∪ · · · ∪ forget(Pn, Fn).

Intuitively, the set F i in a compromise contains those aspects which agents i does not care much about. For a speciﬁc

application, we may need to impose certain conditions on each F i .

Example 7 (Example 6 continued). The scenario can be encoded as a collection of ﬁve disjunctive programs ( P 0 stands for
general constraints): S = (P 0, P 1, P 2, P 3, P 4) where

u0 ← not s, not t.
u2 ← s, t.

};

P 0 = { red ∨ blue ← s. ← red, blue.
u1 ← s, not t.

u1 ← not s, t.
P 1 = {u0 ∨ u1 ← . red ← s};
P 2 = {s ∨ t ← . blue ← s};
P 3 = {s ←};
P 4 = {s ← . t ←}.

Since this knowledge base is jointly inconsistent, each resident may have to weaken some of her preferences so that an
agreement is reached. Some possible compromises are:

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1661

(1) C1 = (∅, F , F , F , F ) where F = {s, blue, red}: Every resident would be willing to weaken her preferences on the swim-
ming pool and its color. Since forget(S, C1) = P 0 ∪ {u0 ∨ u1 ← . t ←}, S has a unique agreement {t, u1} on C1. That is,
only a tennis court is built.

(2) C2 = (∅, F , F , F , F ) where F = {u0, u1, u2, blue, red}: Every resident can weaken her preferences on the price and the
pool color. Since forget(S, C2) = P 0 ∪ {s ∨ t ← . s ← . t ←}, S has two possible agreements {s, t, red} and {s, t, blue} on
C2. That is, both a tennis court and a swimming pool will be built but the pool color can be either red or blue.

(3) C3 = (∅, {blue, red}, ∅, ∅, {t}): The ﬁrst resident can weaken her preference on pool color and the fourth resident can
weaken her preference on tennis court. Since forget(S, C3) = P 0 ∪ P 2 ∪ P 3 ∪ {u0 ∨ u1 ← . s ∨ t ← . s ←}, S has a unique
agreement {s, blue, u1} on C3. That is, only a swimming pool will be built and its color is blue.

(4) C4 = (∅, {blue, red}, {blue, red}, {s, t}, {s, t}): The ﬁrst and second residents can weaken her preference on pool color; the
third and fourth residents would not mind if tennis court or swimming pool is built. Since forget(S, C4) = P 0 ∪ {u0 ∨
u1 ← . s ∨ t ←}, S has three possible agreements {u1, t}, {u1, s, blue}, {u1, s, red} on C4.

It should be noted that a solution to this problem is also provided in [35] where the forgetting for propositional logic
is used where a theory in propositional logic rather than possible agreements are produced. A model of that theory may
not represent an agreement in the sense of Deﬁnition 4. For example, the solution for C4 given in [35] is the theory
T 4 = {s → red ∨ blue, (red ∧ blue) → ⊥, (¬s ∧ t) → u1, (s ∧ ¬t) → u1, (s ∧ t) → u2, (¬s ∧ ¬t) → u0} and its models also
include some agreements that have non-minimal costs (e.g. {u2, s, t, red} is a model of T 4).

However, in our approach each answer set corresponds to exactly one agreement with minimal cost. In addition, the
issue of resolving conﬂicts in multi-agent systems has been challenging and numerous proposals have been suggested for
different systems (for example, see [64]). Thus it would be interesting to explore applications of our technique in practical
multi-agent systems.

6.2. Inheritance logic programs

In this section, we investigate relationships between forgetting in logic programs and inheritance logic programs [11]. As

we show, the semantics of such programs can be expressed by forgetting from a logic program.

Let P be a logic program with classical negation and each rule r of P is labeled with either the symbol ‘.’ or the symbol
‘!’. The symbol ‘.’ means that r is a defeasible rule and the symbol ‘!’ means that r is a strict rule. In the approach proposed
in [11], P is an inheritance program if P is classiﬁed into different objects and an object may have higher priority than
another object. For any two objects o1 and o2, o1 < o2 denotes that o1 has higher priority over o2. This priority relation
naturally deﬁnes a priority for rules in these two objects: r1 < r2 if r1 ∈ o1, r2 ∈ o2 and o1 < o2.

Example 8. Let (P , <) be an inheritance logic program that consists of three objects: o1, o2, o3 where

(cid:10)
(cid:10)
(cid:10)

o1 =
o2 =
o3 =

(cid:11)

penguin(Tweety) ← !
bird(x) ← penguin(x)!, ¬ﬂies(x) ← penguin(x).
ﬂies(x) ← bird(x).

(cid:11)

.

(cid:11)

o1 < o2 < o3 since more speciﬁc rules have higher priority.

In the rest of this section, we view in accordance with [11] inheritance programs as pairs (P , <), where P is a ground
(propositional) logic program with classical negation and < is a strict preorder (irreﬂexive and transitive relation) on the
rules in P , such that r < r

iff r has higher priority than r

.5

(cid:4)

(cid:4)

The semantics of inheritance programs is deﬁned in terms of inheritance answer sets, which are based on the notion of
models of an inheritance program. The notion of satisﬁability of rules for inheritance programs encodes priority information
and thus is quite different from the traditional notion.

Given two (ground) rules r1 and r2, we say r1 threatens r2 on a literal l if (1) ¬.l ∈ head(r1), (2) r1 < r2, and (3) r2 is

defeasible (recall that ¬.l denotes the complement of literal l).

Deﬁnition 5. Given an inheritance program (P , <) and an interpretation S, a rule r1 overrides r2 in S if (1) r1 threatens r2
on a literal l, (2) ¬.l ∈ S and (3) S |(cid:9) body(r2). A rule r is overridden in S if for each l ∈ head(r) there exists a rule r
in P
such that r

overrides r on l in S.

(cid:4)

(cid:4)

Informally, a rule r is overridden by another rule r

(cid:4)

, if it has lower priority than r

(cid:4)

and is in conﬂict with r

(cid:4)

. Obviously,

a strict rule cannot be overridden.

An interpretation S is a model of (P , <), if every rule in P is either satisﬁed or overridden in S. The Gelfond–Lifschitz

reduct is extended to inheritance programs as follows.

5 Cf. [11, p.297] for technical assumptions to ensure this.

1662

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

Deﬁnition 6. Given an inheritance program (P , <) and an interpretation S, the reduction of (P , <) w.r.t. S, denoted (P , <)S ,
(r) ∩ S (cid:15)= ∅,
is the set of rules obtained from P by removing (1) every rule overridden in S, (2) every rule r such that body
and (3) body

(r) from each remaining rule r.

−

−

An interpretation S is an inheritance answer set of (P , <), if S is a minimal model of (P , <)S .

Example 9. The ground version of the inheritance program in Example 8, (ground(P), <), has the single inheritance answer
set S = {penguin(Tweety), bird(Tweety), ¬ﬂies(Tweety)}. Indeed, the instance of the rule in o3, ﬂies(Tweety) ← bird(Tweety),
is overridden by the rule instance ¬ﬂies(Tweety) ← penguin(Tweety) from o2 in S; (ground(P), <)S consists of the three
rules penguin(Tweety) ← , bird(Tweety) ← penguin(Tweety), and ¬ﬂies(Tweety) ← penguin(Tweety). Clearly, S is their unique
answer set, which means that S is an inheritance answer set of (ground(P), <).

Let (P , <) be an inheritance program and S be a set of literals. We introduce a new literal l

each rule r in P , if r is overridden in S, then every literal l in head(r) is replaced with l
denoted P

(cid:4)) for some r
The following theorem provides a semantic characterization of inheritance programs in terms of semantic forgetting.

is a new literal and l

. Let F = {l

(cid:4) ∈ head(r

(cid:4) ∈ P

(cid:4) | l

(cid:4)}.

(cid:4)

(cid:4)

(cid:4)

for each literal l in P . For
. The resulting program from P is

(cid:4)

Theorem 16. Let (P , <) be an inheritance program and let S be a set of literals. Then S is an inheritance answer set of (P , <) iff S is
an answer set of forget(P

is obtained as above.

(cid:4), F ) where P

(cid:4)

Example 10. Continuing our birds example, for S = {penguin(Tweety), bird(Tweety), ¬ﬂies(Tweety)} the corresponding ordi-
(cid:4)
nary logic program ground(P)
penguin(Tweety) ← ,

consists of the following rules:

bird(Tweety) ← penguin(Tweety),
¬ﬂies(Tweety) ← penguin(Tweety),
ﬂies(Tweety)(cid:4) ← bird(Tweety).

(cid:4)
For F = {ﬂies(Tweety)(cid:4)}, we obtain that forget(ground(P)
the unique answer set S, as stated by Theorem 16.

, F ) is represented by the ﬁrst three rules above. This program has

The proof of Theorem 16 is based on the following result, which is of independent interest.

Proposition 13. Let P be a logic program and let F be a consistent set of literals. Suppose that (1) no literal in F occurs in a rule
body in P , and (2) for each rule r, either no or every literal in head(r) is in F . Then forget(P , F ) = P \ R(F ), where R(F ) = {r ∈ P |
r contains a literal of F }.

Note that the conclusion of Proposition 13 may not be true if F contains opposite literals. For example, consider the logic
program P = {p ← a; ¬p ← a; a ← not b; b ← not a} and F = {p, ¬p}. Then P \ R(F ) = {b ← not a; a ← not b}, which has two
answer sets {a} and {b}, while forget(P , F ) has only one answer set {b}.

6.3. Update logic programs

Update programs [18,19] and dynamic logic programs [1,2] are besides [53,62,69] major approaches to updating non-
monotonic logic programs, and are in particular geared towards modeling sequences of updates (see [68] for a recent
survey and comparison of these and other approaches).

An update program is a sequence P = [P 1, P 2, . . . , P t], t (cid:2) 1, where each P i is a logic program for 1 (cid:3) i (cid:3) t. Informally,
P i+1 is assumed to update the information represented by [P 1, . . . , P i]. So P i+1 represents more recent information than
P i , and the rules in P i+1 are assigned higher priority in case of conﬂicts. The semantics of update programs has been given
by means of a translation into an ordinary logic program P (cid:4) although it can also be characterized in a purely declarative
way.

Let P = [P 1, P 2, . . . , P t] be an update program. We introduce new atom rej(r) for each rule r in P , new atom ai for each
atom a in P and each i with 1 (cid:3) i (cid:3) t. If l = ¬a, ¬ai is denoted li . The transformation P (cid:4) is deﬁned as an ordinary logic
program consisting of the following rules:

(i) all constraints in P i , 1 (cid:3) i (cid:3) t.
(ii) for each r ∈ P i with head h, 1 (cid:3) i (cid:3) t: hi ← body(r), not rej(r).
(iii) for each r ∈ P i with head h, 1 (cid:3) i (cid:3) t: rej(r) ← body(r), ¬hi+1.
(iv) for each literal l occurring in P and 1 (cid:3) i (cid:3) t: l ← l1; li ← li+1.

Deﬁnition 7. (See [19].) Let P = [P 1, P 2, . . . , P t] be an update program and let X be a set of literals. Then X is an answer
set of P if it is an answer set of the transformation P (cid:4).

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1663

It has been shown in [18,19] that every update program P can be naturally translated into an equivalent inheritance

logic program ihp(P) = (P , <) where r < r

(cid:4)

if r ∈ P i and r

(cid:4) ∈ P j such that 1 (cid:3) i < j (cid:3) t. More precisely,

Lemma 2. (See [19].) For every update program P = [P 1, P 2, . . . , P t], a set S is an answer set of P iff S is an answer set of the
inheritance program ihp(P).

Combining this lemma and Theorem 16 gives us a characterization of update programs in terms of semantic forgetting

from a logic program.

Corollary 17. Let P be an update program and let S be a set of literals. Then S is an answer set of P if and only S is an answer set of
is obtained from (P , <) as described above.
forget(P

(cid:4), F ), where ihp(P) = (P , <) and P

(cid:4)

Finally, results in [19] show that for certain classes of update programs, the semantics coincides with the one under
dynamic logic programming as in [1,2]. Hence, as a consequence of our results and those in [19], the respective classes of
dynamic logic programs can also be characterized by semantic forgetting in the way described.

6.4. Forgetting vs. independence

As it is argued in [34], the notion of independence is important in automated deduction, query answering, and belief
revision. For example, an intelligent agent must possess the ability of determining and discarding irrelevant information
eﬃciently. When reasoning is involved, the issue of independence (or irrelevance) becomes more delicate and complex. The
idea of forgetting about independent literals can be useful in improving reasoning procedures.

Informally, if a logic program P is independent of a literal l, then the answer set semantics of P should be unchanged if
we forget about l from P . So, it is natural and reasonable to formally deﬁne the notion of semantic independence as follows.

Deﬁnition 8. Let P be a consistent logic program. P is semantically independent of a literal l ∈ Lit P , if AS(forget(P , l)) =
AS(P ).

Obviously, if P is semantically independent of a literal l, then l can be safely “forgotten from P .”

Example 11. Consider the program P = {p ← not q. s ← s}. Clearly, P , forget(P , q), and forget(P , s) all have the single answer
set {p}. Hence, P is semantically independent of both s and q.

The following proposition provides an intuitive characterization for semantic independence.

Proposition 14. Let P be a logic program. P is semantically independent of a literal l ∈ Lit P if and only if l /∈ S for every answer set S
of P .

This result, which is straightforward from Deﬁnition 2, is intuitive: P is independent of a literal l if and only l is false
with respect to every answer set of P , that is, P (cid:15)|(cid:9)c l. In some cases, semantic independence of literals can be veriﬁed
∗(P )
syntactically, as shown by the next result. Let T
be the respective canonical form of program P .

be the program transformations introduced in Section 4.3.1 and let T

∗

Proposition 15. Let P be a logic program and let l ∈ Lit P be a literal. Suppose P
∗
formations from T
l does not occur in T

such that l does not occur in P
∗(P ).

(cid:4)

(cid:4)

. Then P is semantically independent of l. Furthermore, such a program P

is any negative program obtained from P by trans-
exists iff

(cid:4)

The converse of Proposition 15 is not true in general. For example, consider the program P = {p ← not q. q ← not p. q ←
(cid:4)
p.}. Then P is semantically independent of p. On the other hand, p occurs in every program P
resulting from P by
∗(P ) = {p ← not q. q ← not p. q ← not q.}. It
(repeated) transformations in T
remains as an interesting issue whether there is a set of program transformations that is strong enough to syntactically
characterize the notion of semantic independence of literals.

, and in particular in the canonical form T

∗

7. Conclusion

While it is widely acknowledged that forgetting about atomic propositions in knowledge bases is an important technique
for many AI applications, it has been less clear how this should materialize in the context of nonmonotonic reasoning
and logic programming. To the best of our knowledge, this paper is the ﬁrst attempt towards identifying criteria for this
operation in this context. In particular, we have speciﬁed some desirable properties for forgetting in nonmonotonic logic

1664

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

programming. Based on these criteria, we have then proposed a semantics-based theory of forgetting literals in (disjunctive)
logic programming. Compared to preliminary work, a distinguishing feature of our approach is that forgetting is deﬁned in
purely semantical terms. However, we have shown that this declarative approach to forgetting has a syntactic counterpart
based on program transformations.

The properties of forgetting show that the approach in this paper extends the classical notion of forgetting and, moreover,
satisﬁes all criteria that we have identiﬁed. As we have explained before, it also naturally generalizes the notion of forgetting
for normal programs investigated in [65]. Furthermore, we have presented algorithms and analyzed the computational
complexity of major reasoning tasks under forgetting.

Another approach to forgetting for normal logic programs was proposed in [70,71]. Different from ours, the approach
by Zhang and colleagues is procedural. The result of forgetting is obtained by removing some rules and/or literals, but
little semantic justiﬁcation for the removals is provided from a global perspective of logic programming. For their ap-
proaches of weak and strong forgetting, our criteria (F3) and (F4), which foster a semantic justiﬁcation of forgetting
and irrelevance of syntax under answer set semantics, do not hold. In Section 1, we have already shown that strong
and weak forgetting do not have property (F4). To see that (F3) is not satisﬁed by strong and weak forgetting, we re-
consider the example programs in Section 1. For the program P = {p ← . q ← not p}, the result of weak forgetting is
WForgetLP(P , p) = {q ←}; hence, WForgetLP(P , p) |(cid:9)s q while P (cid:15)|(cid:9)s q. Similarly, if we take P = {q ← not p. q ← not q}, then
SForgetLP(P , p) = {q ← not q}, which inconsistent; hence, SForgetLP(P , p) |(cid:9)s q but P (cid:15)|(cid:9)s q. If one adopts the natural read-
ing of rules a ← b1, . . . , bm, not c1, . . . , not cn as formulas (b1 ∧ · · · ∧ bm ∧ ¬c1 ∧ · · · ∧ ¬cn) ⊃ a in propositional logic, then
weak and strong forgetting appear to be intimately related to Lin’s weakest suﬃcient and strongest necessary conditions
[48], respectively, and thus have a strong classical ﬂavor.

As an application of forgetting, we have also presented a fairly general framework for resolving conﬂicts in disjunctive
logic programming. In particular, this framework provides an elegant solution to the preference recovery problem. Fur-
thermore, our results show that the semantic forgetting has a close relationship with inheritance programs [10], update
programs [18,19] and fragments of dynamic logic programs [1,2].

Semantic forgetting has been extended [24] to hex-programs, which allow to combine logic programs with Description
Logics [23] and, applied in deﬁning a notion of forgetting for the Web Ontology Language (OWL).6 Furthermore, a system
prototype for our semantic forgetting, called LPForget, which comprises two modules has been implemented and is available
for experiments.7 The module Forgetting serves for computing the result of forgetting about certain literals in a logic program
under the answer set semantics; all algorithms introduced in this paper have been implemented in it. The other module,
named CRS, facilitates conﬂict resolution (or preference recovery) in multi-agent systems along the approach in Section 6.1.
In our system, once the constraints for different agents are speciﬁed, CRS will ﬁrst check whether these constraints are
consistent. If they are not consistent, the user can make compromises by forgetting about some literals such that an agree-
ment is reached. The system can also make recommendations for the set of literals to be forgotten. However, the current
recommendation algorithm is not optimized yet, and it remains to explore more eﬃcient algorithms.

Several interesting issues remain for further research. One issue are more eﬃcient implementations and improved algo-
rithms for computing the result of forgetting. In particular, given a disjunctive logic program P and a literal l, Algorithm
forget3(P , l) outputs generally a nested logic program which represents the result of forgetting about l from P by its min-
imal answer sets. It is well known that nested logic programs can be eﬃciently transformed into an equivalent ordinary
disjunctive programs if new symbols are allowed [59]. However, this does not carry over to minimal answer sets, and further
minimization is needed. It would be interesting to see a syntax-based algorithm (i.e., based merely on program transforma-
tions but not on the actual answer sets) that outputs an ordinary disjunctive logic program on the original vocabulary as
the result of forgetting.

Another issue is the application of forgetting in various scenarios of conﬂict resolving, such as ontology merging and
alignment in the Semantic Web [58]. In these applications, both closed and open world reasoning are involved. Exploring a
theory of forgetting in such a setting is an interesting issue.

Strong equivalence [45] has received a lot of attention in nonmonotonic logic programming because of its importance
for program modularity and in applications like information integration. It would be interesting to introduce a notion of
semantics forgetting that preserves strong equivalence, in line with the properties and the approach in this paper.

Finally, an extension of the approach in this paper to other semantics of nonmonotonic logic programming and more

general formalisms, such as default logic or autoepistemic logic, is an intriguing issue.

Acknowledgements

The authors would like to thank Fu-Leung Cheng, Esra Erdem, Paolo Ferraris, Fangzhen Lin, Abdul Sattar, Kaile Su, Rodney
Topor and Yan Zhang for helpful comments and discussions. We are also grateful to the reviewers for their helpful and
constructive comments to clarify some aspects of this paper. This work was partially supported by the Austrian Science
Funds (FWF) Projects P17212 and P18019, the EC project REWERSE (IST-2003-506779), and the Australia Research Council
(ARC) Discovery Projects DP0666107 and DP0666540.

6 http://www.w3.org/2004/OWL/.
7 The LPForget website is http://www.cit.gu.edu.au/~kewen/LPForget.

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1665

Appendix A

Proposition 5. Let ≡ X be an equivalence relation on a collection of logic programs on Lit that is stronger than ordinary equivalence
and invariant under literal extensions. Then forgetting does not preserve ≡ X .

Proof. Since ≡ X is stronger than ordinary equivalence of logic programs, there must exist two programs P and P
P ≡ P
of forgetting about l in P . Obviously, P ≡ X P but their results of forgetting (i.e. P and P

such that
is also a result
) are not equivalent under ≡ X . (cid:3)

. Let l be a new literal that appears neither in P nor P

. Then forget(P , l) ≡ P and thus P

but P (cid:15)≡ X P

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Proposition 8. Let P be a consistent logic program and let F = {l1, . . . , lm} be a set of literals. Then
(cid:3)
, . . . , lm

(cid:2)
(cid:2)
forget(P , F ) ≡ forget
forget(P , l1), l2
forget

(cid:3)
.

Proof. Assume that m > 1. Let M = AS(forget(P , F )), M
(cid:4) = {l1, . . . , lm−1}.
F

(cid:4) = AS(forget(P , F

(cid:4))) and M

(cid:4)(cid:4) = AS(forget(forget(P , F

(cid:4)), lm)) where

We claim that M = M

. Consider any set X ∈ M. Then, by an analogue of
item 5 in Proposition 6, there exists a stable model S of P such that X = S − F . Now in the process of iterative construction,
let

. To prove this, we ﬁrst show that M ⊆ M

(cid:4)(cid:4)

(cid:4)(cid:4)

P 0 = P ,
P i = forget(P i−1, li),

for i = 1, . . . , m.

By item 5 of Proposition 6 and the fact that li does not occur in P i , we can show by induction on i = 1, 2, . . . , m that there
must exist some answer set S i of P i such that S i ⊆ S i−1 − {li}. Consequently, Sm ⊆ S − {l1, . . . , lm} = S − F . Hence, there
exists an answer set Sm of Pm such that Sm ⊆ X .

Furthermore, Sm ⊂ X is impossible. Otherwise, Sm ∩ X ⊂ X would hold. Thus, Sm ∪ F

(cid:4) ⊆ F , is an answer
(cid:4) ⊂ S \ F . Hence, S is not an F -answer set of P , which is a contradiction. Thus, we have Sm = X . In

, for some F

(cid:4)

set of P , and Sm ∪ F
(cid:4)(cid:4)
conclusion, M ⊆ M
.

Conversely, suppose X ∈ M

(cid:4)(cid:4)

. That is, X is an answer set of Pm. By the deﬁnition of one-literal forgetting, this means that
there exists an answer set S of P such that S \ F = X . Towards a contradiction, suppose that X /∈ M. Then there exists a set
Y in M such that Y ⊂ X . As already shown, Y is an answer set of P m. But this contradicts that X is an answer set of P m,
as X is not minimal. Hence, X ∈ M. (cid:3)

Theorem 3. Let P be a consistent (disjunctive) logic program and let p ∈ Lit P be an atom. Then X ⊆ Lit P is an answer set of
forget(P , p) iff X is a minimal model of forget(lcomp(P ), p). That is,
(cid:3)
(cid:2)
.
forget(lcomp(P ), p)

(cid:3)
(cid:2)
forget(P , p)

= MMod

AS

Proof. We use the following lemma.

Lemma 3. Let X ⊆ Lit P \ {p} such that X |(cid:9) forget(lcomp(P ), p). Then either X ∈ AS(P ) or X ∪ {p} ∈ AS(P ).

Proof of Lemma 3. By Theorem 1, X
lcomp(P )(p/true) ∨ lcomp(P )(p/false), for each X ⊆ Lit P \ {p} such that X |(cid:9) forget(lcomp(P ), p) thus either X
(if X |(cid:9) lcomp(P )(p/false)) or X

(cid:4) = X ∪ {p} ∈ AS(P ) (if X |(cid:9) lcomp(P )(p/true)) holds. (cid:3)

(cid:4) ∈ AS(P ) iff X

(cid:4) |(cid:9) lcomp(P ) holds for each X

(cid:4) ⊆ Lit P . Since forget(lcomp(P ), p) =
(cid:4) = X ∈ AS(P )

(i) AS(forget(P , p)) ⊆ MMod(forget(lcomp(P ), p)):

Let X ∈ AS(forget(P , p)). Then, there exists some S ∈ AS p(P ) such
that X ∼p S. By Theorem 1, S |(cid:9) lcomp(P ). Since S \ {p} = X , we have X |(cid:9) forget(lcomp(P ), p). To show that X is also
(cid:4) ∈
minimal, assume towards a contradiction that some X
(cid:4) ⊂p S; however, this contradicts S ∈ AS p(P ). This proves
(cid:4) = X
(cid:4)
AS(P ) holds for either S
X ∈ MMod(forget(lcomp(P ), p)).

(cid:4) |(cid:9) forget(lcomp(P ), p). By Lemma 3, S

(cid:4) ⊂ X exists such that X

(cid:4) ∪ {p}. In both cases, S

(cid:4) = X

(ii) MMod(forget(lcomp(P ), p)) ⊆ AS(forget(P , p)):

Let X ∈ MMod(forget(lcomp(P ), p)). By Lemma 3, S ∈ AS(P ) for ei-
ther S = X or S = X ∪ {p}. We show that in both cases S ∈ AS p(P ). Towards a contradiction, suppose that S /∈ AS p(P ).
(cid:4) \ {p} ∈ AS(forget(P , p)). By
(cid:4) := S
Then there exists some S
(cid:4) ⊂ X , this contradicts X ∈ MMod(forget(lcomp(P ), p)). Hence,
part (i), it follows that X
S ∈ AS p(P ). By item 1 of Proposition 6, S \ {p} = X ∈ AS(forget(P , p)). This proves the result. (cid:3)

(cid:4) ∈ AS p(P ) such that S
(cid:4) ∈ MMod(forget(lcomp(P ), p)); Since X

(cid:4) ⊂p S and, by item 1 of Proposition 6, X

or S

Theorem 4. Let P be a consistent (disjunctive) logic program and let p ∈ Lit P be an atom. Then X ⊆ Lit P \ {p} is an answer set of
forget(P , p) if and only if either X or X ∪ {p} is a model of Circ(lcomp(P ), p) (resp., ECWA(lcomp(P ), p)).

1666

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

Proof. By Theorem 1, AS(P ) = {S ⊆ Lit P | S |(cid:9) lcomp(P )}. Hence, from the characterization of models of Circ(lcomp(P ), p)
in terms of ⊆p and ∼p , it is easily seen that AS p(P ) = {S ⊆ Lit P | S |(cid:9) Circ(lcomp(P ), p)}.

Consider X ⊆ Lit P \ {p}. Suppose ﬁrst that X ∈ AS(forget(P , p)). Then X ∼p S for some S ∈ AS p(P ), and either S = X
or S = X ∪ {p} must hold. As S |(cid:9) Circ(lcomp(P ), p), the only-if direction of the theorem holds. Conversely, suppose that
S |(cid:9) Circ(lcomp(P ), p) for either S = X or S = X ∪ {p}. Then S ∈ AS p(P ) and by item 1 of Proposition 6, S \ {p} = X ∈
AS(forget(P , p)). This proves the result. (cid:3)

Theorem 6. For every consistent (disjunctive) logic program P and a literal l, Algorithm forget2(P , l) outputs a correct representation
of forget(P , l).

Proof. By the construction of P 1 in Step 1, AS(P 1) = { X ∈ AS(P ) | l ∈ X}. By Proposition 1, A1 consists thus of all sets X
such that l /∈ X and X ∪ {l} ∈ ASl(P ).

In Step 2, the constraint ← l guarantees that each answer set X of P 2 is an answer set of P such that l /∈ X . The
constraint ← a1, . . . , ak, for M = {a1, . . . , ak} ∈ A1, enforces that M ∪ {l} (cid:15)⊂ X holds. Consequently, A2 consists of all sets
X ∈ ASl(P ) such that l /∈ X .

Combining the two cases, ASl(P ) = { X ∪ {l} | X ∈ A1} ∪ A2; thus by item 1 of Proposition 6, AS(forget(P , l)) = A =

A1 ∪ A2. It is easy to see that AS(P

(cid:4)) = A; this proves the result. (cid:3)

Proposition 9. Let P be a disjunctive program. If P
the same answer sets.

(cid:4)

is obtained by the elimination of head redundancy from P , then P and P

(cid:4)

have

Proof. Let P = P 0 ∪ {r} with l ∈ head(r) ∩ body
S ⊆ Lit P , the following statement holds: (*) S ∈ AS(P ) iff S ∈ AS(P
+
Otherwise (i.e., l /∈ S), the rule r1 = head(r) ← body
(cid:4) |(cid:9) r1 iff S
Furthermore, for each S
holds. (cid:3)

(cid:4) ⊆ S it holds that S

(r) and let P

(cid:4) = P 0 ∪ {(head(r) − l) ← body(r)}. We show that for every
(cid:4))S and therefore (*) holds.
(cid:4))S .
(cid:4))S . Again it follows that (*)

(r) is in P S iff the rule r2 = (head(r) − l) ← body
(cid:4) |(cid:9) r2, and therefore S

(cid:4)). If l ∈ S, then P S = (P

(cid:4) |(cid:9) P S iff S

(r) is in (P

(cid:4) |(cid:9) (P

+

−

To prove Theorem 7, we ﬁrst show a lemma.

Lemma 4. Let P be a DDLP and let S be an interpretation of P . If S ∈ AS(T (P )), then S is a minimal answer set of P .

Proof. Let S ∈ AS(T (P )). We ﬁrst show that S ∈ AS(P ). Let r
head(r) ← body
body
that S |(cid:9) P S .

−
(r) for some r ∈ P such that body
(r) is in T (P )S . Now if body

(r), not not body

−−

+

+

Consider any S

(cid:4) ⊆ S such that S
literals in the body. As S ∈ AS(T (P )), it follows that S
(cid:4) ∈ AS(P ) such that S
Consider any S
(cid:4) = S. (cid:3)
follows that S

(cid:4) |(cid:9) P S . Then S

(cid:4) ⊆ S. Then S

(cid:4) ∈ P S such that S |(cid:9) body(r

(cid:4)). Then r

(cid:4)

(r) ∩ S = ∅ and body
+
(r) ⊆ S, then S |(cid:9) head(r) as S |(cid:9) body

(r) ⊆ S. Furthermore, the rule r
−−

(r). Hence, S |(cid:9) r

−−

must be of the form
(cid:4)(cid:4) = head(r) ←
. It follows

(cid:4)

(cid:4) |(cid:9) T (P )S , as each rule in T (P )S results from a rule in P S by adding
(cid:4) = S. This proves S ∈ AS(P ). It remains to show that S is minimal.
(cid:4) |(cid:9) T (P )S . As S ∈ AS(T (P )), it
, S

. Since T (P )S ⊆ T (P )S

(cid:4) |(cid:9) T (P )S

(cid:4)

(cid:4)

Theorem 7. For every N-acyclic DDLP P , it holds that AS(P ) = AS(T (P )).

Proof. AS(T (P )) ⊆ AS(P ): Immediate from Lemma 4.

AS(P ) ⊆ AS(T (P )): Suppose S ∈ AS(P ) but S /∈ AS(T (P )). Then S is not a minimal model of T (P )S . Note that
(cid:4) |(cid:9) T (P )S . We show that then some interpretation
(cid:4) ⊂ S such that S
(cid:4)(cid:4) |(cid:9) P S ; this means that S is not a minimal model of P S and thus contradicts that

S |(cid:9) T (P )S . Hence, there exists some interpretation S
(cid:4)(cid:4)
exists such that S ⊆ S
S
S ∈ AS(P ), proving the result.

(cid:4)(cid:4) ⊂ S and S

We ﬁrst assume that P is normal, i.e., |head(r)| (cid:3) 1 for each r ∈ P . Let L be a level mapping witnessing the N-acyclicity
(cid:4) ⊂ S,

(cid:4))} be the set of all literals in S \ S

having the smallest level. Since S

: L(l) (cid:3) L(l

(cid:4) ∈ S \ S

(cid:4) | ∀l

(cid:4)

of P and let X = {l ∈ S \ S
X (cid:15)= ∅. We claim that S

(cid:4)
(cid:4)(cid:4) := S \ X |(cid:9) P S .

Towards a contradiction, suppose that S

+

(cid:4)(cid:4)

. Since r stems from a rule r

(r) ⊆ S
and body
follows that either (a) body
that body
that S ∈ AS(P ). Hence, the result for normal programs P is proved.

(cid:4) (cid:15)= ∅ or (b) body
(r) (cid:15)⊆ S

(cid:4) ∈ P such that S |(cid:9) r
(cid:4)) \ S

(r) ∩ X (cid:15)= ∅, and thus body

(r) \ S

−−

(r

+

+

+

(cid:4)(cid:4)

(cid:4)(cid:4) (cid:15)|(cid:9) r for some r ∈ P S . Since S |(cid:9) P S , r is of the form l ← body

+

(cid:4)

(r) where l ∈ X
(cid:4) |(cid:9) T (P )S , it
(cid:4)) ← body
(cid:4) (cid:15)= ∅. The minimality of L(l) implies that (a) is the case and
(cid:4)(cid:4) |(cid:9) P S , which contradicts

(i.e., r = head(r

(cid:4))) and S

(r

+

; this is a contradiction. This proves the claim S

The result for arbitrary programs is an easy consequence of this result and the following two facts. Call a program P

a
results from P by replacing every rule r of form l1 ∨ · · · ∨ lk ← B, k (cid:2) 2, by at least one of the normal

(cid:4)

(cid:4)

split of a DDLP P , if P
rules l1 ← B, . . . , lk ← B. Now,

Fact A. For every S ∈ AS(P ) there exists a split P

(cid:4)

of P such that S ∈ AS(P

(cid:4)).

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1667

Indeed, every split P

(cid:4)

of P such that r is replaced by all rules li ← B with li ∈ S whenever head(r) ∩ S (cid:15)= ∅, has S as an

answer set. (This is a simple extension of a folklore result for ordinary logic programs [28,30].)

Fact B. If a DDLP P is N-acyclic, then every split P

(cid:4)

of P is N-acyclic. (cid:3)

Theorem 8. Let P be a consistent disjunctive logic program and let l ∈ Lit P be a literal. Then forget3(P , l) correctly represents
forget(P , l), i.e., X is an answer set of forget(P , l) iff X is a minimal answer set of N

.

(cid:4)

Proof. By Lemma 1, P can be transformed into an equivalent negative program N0. Furthermore, an easy extension of
Corollary 2 implies that N0 is equivalent to N. Hence, P ≡ N and forget(P , l) ≡ forget(N, l).

Let AS min(N

(cid:4)) denote the minimal answer sets of program N

(cid:4)

(w.r.t. ⊆). To prove the theorem, it is now by item 1 of

Proposition 6 suﬃcient to prove the following claim:

Claim. For every set X

(cid:4)

of literals such that l /∈ X

(cid:4)

, X

(cid:4) ∈ AS min(N

(cid:4)) iff X

(cid:4) = X \ {l} for some X ∈ ASl(N).

Due to the elimination of tautology and the elimination of head redundancy, head(r) ∩ body(r) = ∅ for each rule r ∈ N.
Thus the program N can be split into three disjoint parts: N = N1 ∪ N2 ∪ N3 where N1 consists of rules in N in which l
(r)}. Notice that Step 3 in
does not appear; N2 = {r ∈ N | l ∈ head(r), l /∈ body
(cid:4)
Algorithm forget3(P , l) is performed only on the rules in N3. Let the program N
3 result from N3 by the transformations
(cid:4)
3. Let D1, D2, . . . , D s denote all possible conjunctions constructed from li in Step 3; note that
in Step 3. Then N
N2 = {r1, . . . , rn}. We consider the three cases in Step 3.

(r)}; and N3 = {r ∈ N | l /∈ head(r), l ∈ body

(cid:4) = N1 ∪ N

(3.1) If n = 0, then no rule in N has l in the head. Thus l is false in every answer set of N, and hence N ≡ N

−

−

(cid:4)

(cid:4)

is an ordinary program, AS min(N

(cid:4)) = AS(N

(cid:4)). It follows that AS min(N

and
(cid:4)) = ASl(N) and the

ASl(N) = AS(N). Since N
claim holds.

(3.2) If n > 0 and m j = 0 for some j ∈ {1, . . . , n}, then the rule l ← is in N. Hence, every answer set of N contains
. As in the previous case,

(cid:4) ∪ {l} ∈ AS(N) holds for every set of literals X

with l /∈ X

(cid:4) ∈ AS(N

(cid:4)

(cid:4)

(cid:4)) iff X
l, and clearly X
ASl(N) = AS(N) and AS min(N

(cid:4)) = AS(N

(cid:4)), and the claim holds.

(3.1) n (cid:2) 1 and mi (cid:2) 1 for every i = 1, . . . , n. We use the following lemmas.

Lemma 5. If l /∈ X

(cid:4)

and X

(cid:4) |(cid:9) D i0 for some i0 with 1 (cid:3) i0 (cid:3) s, then (N3) X

(cid:4) = (N

(cid:4)
3) X

(cid:4)

.

Lemma 6. For every X

(cid:4) ∈ AS min(N

(cid:4)),

(1) if X
(2) if X

(cid:4) |(cid:9) D i0 for some i0, 1 (cid:3) i0 (cid:3) s, then X
(cid:4) (cid:15)|(cid:9) D i for all i = 1, . . . , s, then X

(cid:4) ∈ AS(N).
(cid:4) ∪ {l} ∈ AS(N).

(cid:4)

Proof of Lemma 6. (1) N X
(N

(cid:4)) X
. So X
(cid:4)(cid:4) ⊆ X
If X
(2) Let X = X

(cid:4) |(cid:9) N X
.
(cid:4)
and X

(cid:4)(cid:4) |(cid:9) N X

(cid:4)

(cid:4)

(cid:4) ∪ (N2) X = (N1) X

(N1) X
and every rule in N2 has head l. Thus, X |(cid:9) N X .

(cid:4) = (N1) X

(cid:4) ∪ (N3) X

(cid:4)

since X

(cid:4) |(cid:9) D i0 implies l /∈ X

(cid:4)

. By Lemma 5, (N3) X

(cid:4) = (N

(cid:4)

(cid:4)
3) X

and thus N X

(cid:4) =

, then X

is a minimal model of N X
(cid:4) ∪ {l}. Since l ∈ X and l does not appear in N1, we have N X = (N1 ∪ N2 ∪ N3) X = (N1) X ∪ (N2) X =
. Obviously, X |(cid:9) (N2) X since l ∈ X

(cid:4) ∪ {l ←}. By the assumption, X

and thus X |(cid:9) (N1) X

(cid:4) |(cid:9) (N1) X

. Therefore, X

. Since X

, X

(cid:4)

(cid:4)

(cid:4) ∈ AS(N).

(cid:4)(cid:4) |(cid:9) (N

(cid:4)) X

(cid:4)

(cid:4)

(cid:4)(cid:4) = X

(cid:4)

(cid:4)

Now suppose that Y ⊆ X and Y |(cid:9) N X . Since l ← is in N X , l ∈ Y . Let Y = Y
(cid:4)) X
. Thus, Y

(cid:4) |(cid:9) (N

(cid:4) = (N1) X

(N
minimal model of N X , and thus X ∈ AS(N). (cid:3)

, we have Y

(cid:4) ⊆ X

(cid:4) = X

by Y

(cid:4)) X

(cid:4)

(cid:4)

(cid:4)

(cid:4)

and the minimality of X

(cid:4) ∪ {l} where l /∈ Y
(cid:4)

. By
. This implies Y = X . So X is a

. Then Y

(cid:4) |(cid:9) (N1) X

(cid:4)

(cid:4)

We now prove the claim.

(⇒): Let X

(cid:4) ∈ ASl(N). Then X ∈ AS(N) for either X = X

(cid:4)

or X = X

(cid:4) ∪ {l}, where l /∈ X . Consider two cases:

(cid:4)
Case 1. X = X
: Note that X
(cid:4) = (N1) X
(cid:4) ∪ (N
(cid:4)
(N1) X
3) X
(cid:4)(cid:4) ⊆ X
Suppose now X
(cid:4)).
X
Suppose that Y ∈ AS min(N
follows that Y = X
. So X
implies X
Case 2. X = X

(cid:4) ∈ AS(N

(cid:4)

(cid:4)

follows that X

(cid:4) |(cid:9) (N

(cid:4)) X

X

(cid:4)

.

(cid:4) |(cid:9) D i0 for some i0, 1 (cid:3) i0 (cid:3) s, since l /∈ X
(cid:4) ∪ (N3) X
and X

(cid:4)) X
. Since X

(cid:4) |(cid:9) (N
(cid:4)(cid:4) |(cid:9) N X

. This implies X

(cid:4)(cid:4) |(cid:9) (N

. Then X

(cid:4)) X

.

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

. By Lemma 5, (N3) X

(cid:4) = (N

(cid:4)

(cid:4)
3) X

. Therefore, (N

(cid:4)) X

(cid:4) =

is a minimal model of N X

(cid:4)

, we have X

(cid:4)(cid:4) = X

(cid:4)

. Thus,

(cid:4)) and Y ⊆ X
(cid:4) ∈ AS min(N

(cid:4)
. If Y |(cid:9) D j0 for some j0 (1 (cid:3) j0 (cid:3) s), then by Lemma 6 Y ∈ AS(N) and thus it
(cid:4)). If Y (cid:15)|(cid:9) D i for all i (1 (cid:3) j0 (cid:3) s), then Y ∪ {l} ∈ AS(N) again by Lemma 6. This

(cid:4) /∈ ASl(N), a contradiction. Therefore, X
(cid:4) ∪ {l}: Then N X = N X

(cid:4)∪{l} = (N1) X

(cid:4) (cid:15)|(cid:9) D i for every i, 1 (cid:3) i (cid:3) s. Thus, (N

(cid:4) ∈ AS min(N

(cid:4)).

(cid:4) ∪ {l ←}. Since l ∈ X , we have X (cid:15)|(cid:9) D i for every i, 1 (cid:3) i (cid:3) s. From l /∈ X

(cid:4)

(cid:4)) X

(cid:4) = (N1) X

(cid:4) ∪ (N

(cid:4)
3) X

(cid:4) = (N1) X

(cid:4)

. Since X |(cid:9) N X , X

(cid:4) |(cid:9) (N1) X

(cid:4)

, it
and thus

1668

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

(cid:4)

(cid:4)

(cid:4)(cid:4) = X

(cid:4)(cid:4) ⊆ X
If X
and X
(cid:4)
. Thus, X
X
If Y ∈ AS min(N
(cid:4)
means Y = X

(cid:4)(cid:4) ∪ {l} |(cid:9) N X . By the minimality of X , X

(cid:4)(cid:4) |(cid:9) (N
(cid:4)) X
, then X
(cid:4) ∈ AS(N
(cid:4)).
(cid:4)) and Y ⊆ X
, since the answer sets of N are incomparable under ⊆. Thus X

(cid:4)

(cid:4) ∈ AS min(N

(cid:4)).

, then Y (cid:15)|(cid:9) D i for all i = 1, . . . , s. Consequently. Y ∪ {l} ∈ AS(N). So Y ∪ {l} ⊆ X

(cid:4) ∪ {l}. This

(cid:4)(cid:4) ∪ {l} = X . Since l /∈ X

(cid:4)

and l /∈ X

(cid:4)(cid:4)

, we have

(⇐): Suppose that X

(cid:4) ∈ AS min(N

(cid:4)). Consider two possible cases:

Case 1. X

(cid:4) (cid:15)|(cid:9) D i for all i = 1, . . . , s: By Lemma 6, X = X

(cid:4) ∪ {l} ∈ AS(N). Thus X

(cid:4) ∈ ASl(N) since l ∈ X by item 3 of Proposi-

tion 1.

Case 2. X

(cid:4)

(cid:4) |(cid:9) D i0 for some i0 with 1 (cid:3) i0 (cid:3) s: By Lemma 6, X

. Then l ∈ Y since l /∈ X

Y \ {l} ⊆ X
the proof of the only-if part, Y \ {l} is a (minimal) answer set of N
X

(cid:4) ∈ ASl(N). (cid:3)

, such that
and answer sets of N are incomparable. Thus Y ∈ ASl(N) by Proposition 1. From
. This proves

(cid:4) ∈ AS(N). Consider any Y ∈ AS(N), Y (cid:15)= X

. By the minimality of X

, Y \ {l} = X

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Proposition 11. Let P be a consistent normal logic program and let l ∈ Lit P be a literal. If no negative cycle of DG P contains l, then
forget3(P , l) outputs an N-acyclic program.

Proof. The result is a consequence of the fact that for a program P as described, also in the dependency graph DG N0 for
the program N0 from Step 1 of forget3(P , l) no negative cycle will contain l. This is because each of the transformations in
∗
preserves the property that if a literal l does not occur on a negative cycle of DG P 0 of the original program P 0, then it
T
does not occur on a negative cycle of DG P 1 in the transformed program P 1. Indeed, each transformation except Unfolding
only removes edges; Unfolding can add only some positive edges from l to l
and from
(cid:4)(cid:4)
l
and a negative
edge from l
. Thus, occurrence of l in a negative cycle of DG P 1 implies occurrence of l in a
negative cycle of DG P 0 .

, and some negative edges from l to l

such that a positive edge from l to l

such that positive edges from l to l

exist, for some literal l

As a consequence, in Step 3 (where N = N0) no replacements of not l by D i will be performed that can violate the

exist, for some literal l

to l

to l

(cid:4)(cid:4)

(cid:4)(cid:4)

(cid:4)(cid:4)

(cid:4)(cid:4)

(cid:4)(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

condition (ii) of N-acyclicity; condition (i) is vacuously true. (cid:3)

Theorem 9. Given a consistent (disjunctive) logic program P , a literal l, and a set of literals X , deciding whether X is an l-answer set
of P is (cid:4)p

2 -complete.

Proof. Deciding whether X /∈ ASl(P ) can be done in NP time using an NP oracle: we must show that either (1) X /∈ AS(P )
can be guessed and
(which is in co-NP, cf. [22]), or that (2) there exists some X
checked using an NP-oracle in polynomial time. Consequently, l-answer set checking is in co-NPNP = (cid:4)p
2 .

(cid:4) ∈ AS(P ) such that X

(cid:4) ⊂l X ; such an X

(cid:4)

The hardness result is shown by a reduction from deciding whether a given logic program P (without strong negations)

has no answer set, which is (cid:4)p

2 -complete [22].

In fact, given a (disjunctive) logic program P , construct a logic program P

(cid:4) = {head(r) ← p, body(r) | r ∈ P } ∪ {q ←
not p. p ← not q} ∪ {a ← not p | a appears in P }, where p and q are two fresh atoms. This program P
has one answer
set X0 in which p is false and all other atoms are true; all other answer sets are of the form X ∪ {p}, where X ∈ AS(P ). It
holds that X0 ∈ AS p(P

(cid:4)) iff P has no answer set. (cid:3)

(cid:4)

Theorem 10. Given a consistent normal logic program P , a literal l, and a set of literals X , deciding whether X is an l-answer set of P
is co-NP-complete.

Proof. Similar to the proof of Theorem 9, in order to show that X /∈ ASl(P ), we must show that either (1) X /∈ AS(P )
(which can be tested in polynomial time), or that (2) there exists some X
can be
guessed and checked in polynomial time. Hence, deciding X /∈ ASl(P ) is in NP, which implies that l-answer set checking is
in co-NP.

(cid:4) ∈ AS(P ) such that X

(cid:4) ⊂l X . Such an X

(cid:4)

The hardness result is shown by the reduction in Theorem 9. In fact, note that if we consider only normal programs P
is also a normal program. The problem of deciding whether P has no answer set, which

(without strong negation), then P
is co-NP-complete, is thus reduced to deciding whether X0 is a p-answer set of P

. (cid:3)

(cid:4)

(cid:4)

Theorem 11. Given a consistent negative program P , a literal l, and a set of literals X , deciding whether X is an l-answer set of P is
co-NP-complete.

Proof. The co-NP membership follows from that fact that for any given set of literals X and negative program P , deciding
whether X ∈ AS(P ) is polynomial. (Indeed, X ∈ AS(P ) iff X |(cid:9) P X and X \ {l} (cid:15)|(cid:9) P X , for every l ∈ X .) Thus, testing that
(1) X ∈ AS(P ) and that (2) there is no X

(cid:4) ∈ AS(P ) such that X

(cid:4) ⊂l X is feasible in co-NP.

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1669

As for co-NP-hardness, let C = C1 ∧ · · · ∧ Ck be a propositional CNF over atoms y1, . . . , ym, where each C j is nonempty.

Deﬁne

where

N =

m(cid:12)

(cid:2)

i=1

Ni ∪ { ← not C

(cid:3)

}

(cid:4)
i

∪ {l ← not y1. l ← not y

(cid:4)
1

},

Ni = { yi ← not y
(cid:4)
j

= { yi | yi ∈ C j} ∪ { y

← not yi. yi ← not l. y
(cid:4)
i

| ¬ yi ∈ C j}, 1 (cid:3) j (cid:3) k.

C

(cid:4)
i. y

(cid:4)
i

(cid:4)
i

← not l}, 1 (cid:3) i (cid:3) m,

Clearly, the satisfying assignments of C correspond one-to-one to the answer sets of N containing l. Furthermore, the set
X = { yi, y
| 1 (cid:3) i (cid:3) m} is an answer set of N. It holds that X is also an l-answer set of N iff C is unsatisﬁable, which
establishes the co-NP-hardness. (cid:3)

(cid:4)
i

Theorem 12. Given a consistent (disjunctive) logic program P and literals l and l

(cid:4)

, deciding whether forget(P , l) |(cid:9)c l

(cid:4)

is (cid:5) p

3 -complete.

Proof. Given a logic program P and two literals l and l
(cid:4) ∈ S. Since deciding S ∈ ASl(P ) is in (cid:4)p
l

2 , the problem thus is in (cid:5) p
3 .

(cid:4)

, forget(P , l) |(cid:9)c l

(cid:4)

holds iff there exists some S ∈ ASl(P ) such that

The (cid:5) p

3 -hardness can be shown by an encoding of quantiﬁed Boolean formulas (QBFs) of the form ∃Z ∀ X∃Y C . It is well
known that the problem of deciding whether a disjunctive logic program has no answer sets is (cid:4)p
2 -complete [22]. As shown
there, for every QBF F = ∀ X∃Y C there exists a polynomial-time constructible logic program P F which has no answer set
(cid:4) = ∃Z ∀ X∃Y C into credulous inference under forgetting as
iff F is true. We extend this program to an encoding of a QBF F
follows.

First, P F can be easily extended to a program P F [Z ] encoding a QBF F [ Z ] = ∀ X∃Y C[ Z ] with free variables (i.e., parame-
ters) Z , where all new atoms in P F [Z ] are from Z and do not occur in rule heads, such that for every truth assignment τ to
Z , the program P F [Z /τ ( Z )] = P F [Z ] ∪ {z ← . | z ∈ Z , τ (Z ) = true} has no answer set iff the QBF F [ Z /τ (Z )] evaluates to true,
where F [ Z /τ (Z )] results from F [ Z ] by replacing every z ∈ Z with T if τ (z) = true and with F if τ (z) = false.

More in detail, suppose without loss of generality that C[ Z ] = C1 ∧· · ·∧ Cr where each Ci = (cid:7)i,1 ∨(cid:7)i,2 ∨(cid:7)i,3 is a disjunction
(cid:4) | y ∈ Y }, and w be new atoms. Then P F [Z ] consists of the
(cid:4) = { y

(cid:4) | x ∈ X}, Y

(cid:4) = {x

of literals (cid:7)i, j over atoms X ∪ Y ∪ Z . Let X
rules

(cid:4) ← .
(cid:4) ← .

x ∨ x
y ∨ y
y ← w.
w ← σ (¬.lk,1), σ (¬.lk,2), σ (¬.lk,3).
w ← not w.

y

(cid:4) ← w. w ← y, y

(cid:4).

for each x ∈ X,
for each y ∈ Y ,
for each k = 1, . . . , r,

⎧
⎪⎨

where σ maps classical literals (cid:7) to classical and not literals as follows:
if (cid:7) = ¬x for some x ∈ X,
if (cid:7) = ¬ y for some y ∈ Y ,
if (cid:7) = ¬z for some z ∈ Z ,
otherwise.

(cid:4)
x
y
not z
(cid:7)

σ ((cid:7)) =

⎪⎩

(cid:4)

Notice that the only not literals occurring in P F [Z ] are not w in the last rule and the literals not z in rule bodies; furthermore,
atoms from Z occur only in rule bodies. For void Z , the program P F [Z ] amounts to the program P F in [22, Proof of
Theorem 3] (after converting the ∀∃-QBF into the ∃∀-QBF used there). A simple extension of the proof of Theorem 3 in [22]
gives the following lemma.

Lemma 7. For each truth assignment τ to Z , ∀ X∃Y C[ Z /τ (Z )] evaluates to true iff the program P F [Z /τ ( Z )] has no answer set.

Let Z

(cid:4) | z ∈ Z }, l, and l
of each rule and the following further rules:

(cid:4) = {z

(cid:4)

, be fresh atoms, and let P be the logic program obtained from P F [Z ] by adding l to the body

(cid:4).
(1) l ← not l
l
(cid:4). z
(2) z ← not z
(3) x ← not l. x
(4) the rule w ← not l.

(cid:4) ← not l.,
(cid:4) ← not z,
(cid:4) ← not l. y ← not l. y

for each z ∈ Z ,

(cid:4) ← not l,

for each x ∈ X, y ∈ Y , and

, and the rules in (2) select a truth assignment τ to Z . If l is selected, then
Informally, the rules in (1) select one of l and l
the program P F [Z ] is activated and evaluated for the selected τ , while the rules (3) and (4) are discarded. The evaluation
will lead to some answer set Sl
τ , iff the program P F [Z /τ ( Z )] has some answer set; note that every such S contains l. On

(cid:4)

1670

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

is selected, then only the rules in (2)–(4) are active. The truth assignment τ selected in (2) will be

(cid:4)

the other hand, if l
complemented with X ∪ X
⊂l Sl

(cid:4) ∪ Y ∪ Y
τ holds for every Sl

(cid:4)

(cid:4) ∪ {w} to a unique answer set Sl
τ . Furthermore, answer sets S and S

(cid:4)

(cid:4)
τ of the program P .

Now Sl
τ
, respectively, are always incomparable w.r.t. ⊆ on Z ∪ Z

τ (cid:4)
set of P iff no answer set Sl
evaluates to true. Hence, for some τ , Sl
set of P that contains l
Since P is constructible in polynomial time from F

corresponding to different truth assignments τ and
(cid:4)
τ is an l-answer
τ exists, i.e., P F [Z /τ ( Z )] has no answer set, which by Lemma 7 equals that ∀ X∃Y C[ Z /τ (Z )]
(cid:4) = ∃Z ∀ X∃Y C evaluates to true. Since every l-answer
evaluates to true.

(cid:4)
τ is an l-answer set of P iff F
τ for τ , it follows from Proposition 6 that forget(P , l) |(cid:9)c l
3 -hardness is proved. (cid:3)

, and thus also w.r.t. ⊆l. Therefore, for every τ , Sl

is of the form Sl

, the (cid:5) p

iff F

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Theorem 13. Given a consistent negative program P and literals l and l

(cid:4)

, deciding whether forget(N, l) |(cid:9)c l

(cid:4)

is (cid:5) p

2 -complete.

Proof. By Theorem 11, a guess for some l-answer set X of P such that l
time. Hence, deciding forget(P , l) |(cid:9)c l

is in (cid:5) p
2 .

(cid:4)

(cid:4)
k

As for (cid:5) p

2 -hardness, take a QBF ∃ X∀Z E, where E =

i=1 D i is a DNF on X ∪ Z such that without loss of generality in
each disjunct D i some variable from Z occurs. Construct the same program as above in Theorem 11 for C = ¬E and where
(cid:4)
Y = X ∪ Z and y1 is an arbitrary variable from Z , but (1) omit the clauses xi ← not l and x
← not l, and (2) add a clause
i
(cid:4) ← not l, where l
l

(cid:4)

is a fresh literal. Then for each set X
(cid:4)} ∪ Z ∪ {z

| z j ∈ Z } ∪ {l

| xi ∈ X \ X

(cid:4)
j

(cid:4) ⊆ X , the set
(cid:4)}

S X (cid:4) = X

(cid:4)
(cid:4) ∪ {x
i

(cid:4) ∈ X can be veriﬁed with an NP oracle in polynomial

is an answer set of N. The sets S X (cid:4) are also all answer sets of N that contain l
is an l-answer set of N iff there exists no satisfying truth assignment for C (= ¬E) which corresponds on X to S X (cid:4)
the obvious way. In summary, this means that N has l-answer set in which l
∃ X∀Z E evaluates to true. (cid:3)

(and do not contain l). Furthermore, S X (cid:4)
in
, iff the formula

is true, i.e., forget(N, l) |(cid:9)c l

(cid:4)

(cid:4)

(cid:4)

Theorem 14. Given a consistent normal program N and literals l and l

(cid:4)

, deciding whether forget(N, l) |(cid:9)c l

(cid:4)

is (cid:5) p

2 -complete.

Proof. It is suﬃcient to note that the program N constructed in the proof of Theorem 13 is normal. (cid:3)

Theorem 15. Given a consistent logic program P and literals l and l
arbitrary disjunctive logic programs P , and (ii) co-NP-complete for normal logic programs and for negative logic programs P .

, deciding whether forget(P , l) |(cid:9)s l

is (i) (cid:4)p

2 -complete for

(cid:4)

(cid:4)

Proof. By Theorem 7, to decide forget(P , l) |(cid:9)s l
2 -complete for logic pro-
grams [22] and co-NP complete for normal/negative programs; for both cases, membership in co-NP follows since testing
X ∈ AS(P ) is polynomial (cf. proof of Theorem 11 for negative programs), and co-NP hardness from the results in [52]
(incorporating the consistency requirement is easy). (cid:3)

, we need only to decide P |(cid:9)s l

. The latter is (cid:4)p

(cid:4)

(cid:4)

Proposition 13. Let P be a logic program and let F be a consistent set of literals. Suppose that (1) no literal in F occurs in a rule body
in P , and (2) for each rule r, either no or every literal in head(r) is in F . Then forget(P , F ) = P \ R(F ).

We ﬁrst provide two lemmas, which are straightforward corollaries of the well-known, more general Splitting Set Theo-
rem in [47] and elementary properties of answer set semantics. To avoid introducing the necessary notions for that result,
we provide for self-containedness simple genuine proofs.

Lemma 8. Let P , F and Q = P \ R(F ) be given as in Proposition 13. If S
that S

is an answer set of P .

(cid:4) ∪ Y

(cid:4)

(cid:4)

is an answer set of Q , then there exists a subset Y

(cid:4)

of F such

Since we have a very special case here, Lemma 8 also allows a simple proof.

(cid:4)

Proof. Suppose that S
be in F . Let Y
show that S is an answer set of P .

be a minimal model of D

is an answer set of Q . Denote D
(cid:4) ∪ Y
(cid:4)

and S = S

(cid:4)

(cid:4) = {head(r) | r ∈ R(F ), S
(cid:4)
. By the assumption of F , S

(cid:4) |(cid:9) body(r)}. Then every literal in D

must
(cid:4) = ∅ and thus S is consistent. We

(cid:4) ∩ Y

(cid:4)

First, since P S = P S

(cid:4) = Q S

(cid:4)

(cid:4) ∪ (R(F ))S
and thus X

(cid:4) = S

(cid:4)

(cid:4) |(cid:9) Q S

(cid:4)

, we have S |(cid:9) P S . Next, suppose X ⊆ S and X |(cid:9) P S . Take X

(cid:4) = X \ F ; then X

. Notice that Y

(cid:4) = S ∩ F is a minimal model of D

(cid:4)

, and that X ∩ F |(cid:9) D

(cid:4)

(cid:4)

(cid:4) ⊆ S
.
implies

We can see that X
X ∩ F = S ∩ F . Thus, X = S. (cid:3)

Lemma 9. Let P , F and Q = P \ R(F ) be given as in Proposition 13. If S is an answer set of P , then S \ F is an answer set of Q .

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

1671

(cid:4)

Proof. By P S = P S
Suppose that Y
(cid:4) = S ∩ ¯F , we have Y

(cid:4) |(cid:9) Q S
(cid:4)
. Here ¯F = Lit P \ F .
(cid:4) = S
Therefore, S \ F is an answer set of Q . (cid:3)

and Q ⊆ P , it is easy to see that S
(cid:4) ⊆ S
. Then Y |(cid:9) P S

and Y

S

(cid:4)

(cid:4)

(cid:4)

(cid:4) |(cid:9) Q S
(cid:4) = P S where Y = Y

where S

(cid:4) = S \ F .

(cid:4) ∪ (S ∩ F ). Thus Y = S. Since Y

(cid:4) = Y ∩ ¯F and

Proof of Proposition 13. Denote Q = P \ R(F ). Suppose that S
of F such that S = S
(cid:4)
To show that S

is an answer set of P .

(cid:4) ∪ Y
is an answer set of forget(P , F ), it suﬃces to prove that S is an F -answer set of P . In fact, if Z is an
(cid:4)
(cid:4) = Z
(cid:4) = Z \ F . By Lemma 9, Z
,

is an answer set of Q . Thus S

is an answer set of Q . By Lemma 8, there exists a subset Y

(cid:4) ⊆ S

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

answer set of P such that Z ⊆F S, then Z
where Z
which means Z ∼F S. That is, S is an F -answer set of P .
(cid:4)

On the other hand, if S
(cid:4)

By Lemma 9, S

is also an answer set of Q . (cid:3)

is an answer set of forget(P , F ), then there exists an F -answer set S of P such that S

(cid:4) = S \ F .

We are now ready to prove Theorem 16.

Theorem 16. Let (P , <) be an inheritance program and let S be a set of literals. Then S is an inheritance answer set of (P , <) iff S is
an answer set of forget(P

is obtained as above.

(cid:4), F ) where P

(cid:4)

Proof. S is an inheritance answer set of (P , <) iff S is a minimal model of (P , <)S iff S is an answer set of P \ R(F ) iff S
is an answer set of forget(P

(cid:4), F ), by Proposition 13. (cid:3)

References

[1] J. Alferes, J. Leite, L. Pereira, H. Przymusinska, T. Przymusinski, Dynamic logic programming, in: A. Cohn, L. Schubert, S. Shapiro (Eds.), Proceedings of
the Sixth International Conference on the Principles of Knowledge Representation and Reasoning, Morgan Kaufmann Publishers, 1998, pp. 98–109.
[2] J. Alferes, J. Leite, L. Pereira, H. Przymusinska, T. Przymusinski, Dynamic updates of non-monotonic knowledge bases, Journal of Logic Program-

ming 45 (1–3) (2000) 43–70.

[3] Asparagus homepage, http://asparagus.cs.uni-potsdam.de/, Since 2005.
[4] R. Ben-Eliyahu, R. Dechter, Propositional semantics for disjunctive logic programs, Annals of Mathematics and Artiﬁcial Intelligence 12 (1–2) (1994)

53–87.

[5] W. Bledsoe, L. Hines, Variable elimination and chaining in a resolution-based prover for inequalities, in: W. Bibel, R.A. Kowalski (Eds.), Proceedings of

5th Conference on Automated Deduction (CADE 1980), in: Lecture Notes in Computer Science, vol. 87, Springer, 1980, pp. 70–87.

[6] G. Boole, The Mathematical Analysis of Logic, G. Bell, London, 1847; reprinted by Philosophy Library, New York, 1948.
[7] S. Brass, J. Dix, Characterizations of the disjunctive stable semantics by partial evaluation, Journal of Logic Programming 32 (3) (1997) 207–228.
[8] S. Brass, J. Dix, Semantics of disjunctive logic programs based on partial evaluation, Journal of Logic Programming 38 (3) (1999) 167–312.
[9] F. Brown, Boolean Reasoning: The Logic of Boolean Equations, second ed., Dover Publications, 2003.

[10] F. Buccafurri, W. Faber, N. Leone, Disjunctive logic programs with inheritance, in: D. De Schreye (Ed.), Proceedings of the International Conference on

Logic Programming (ICLP’99), The MIT Press, 1999, pp. 79–93.

[11] F. Buccafurri, W. Faber, N. Leone, Disjunctive logic programs with inheritance, Theory and Practice of Logic Programming 2 (3) (2002) 293–321.
[12] M. Cadoli, F. Donini, P. Liberatore, M. Schaerf, Space eﬃciency of propositional knowledge representation formalisms, Journal of Artiﬁcial Intelligence

Research 13 (2000) 1–31.

[13] M. Cadoli, F.M. Donini, P. Liberatore, M. Schaerf, Preprocessing of intractable problems, Information and Computation 176 (2) (2002) 89–120.
[14] K. Clark, Negation as failure, in: H. Gallaire, J. Minker (Eds.), Logic and Data Bases, Plenum Press, 1978, pp. 293–322.
[15] E. Dantsin, T. Eiter, G. Gottlob, A. Voronkov, Complexity and expressive power of logic programming, ACM Computing Surveys 33 (3) (2001) 374–425.
[16] A. de Waal, J. Gallagher, Logic program specialisation with deletion of useless clauses, in: D. Miller (Ed.), Proceedings of the 1993 International Sym-

posium on Logic Programming (ILPS 1993), MIT Press, 1993, p. 632.

[17] T. Eiter, M. Fink, Uniform equivalence of logic programs under the stable model semantics, in: C. Palamidessi (Ed.), Proceedings 19th International

Conference on Logic Programming (ICLP 2003), in: Lecture Notes in Computer Science, vol. 2916, Springer, 2003, pp. 224–238.

[18] T. Eiter, M. Fink, G. Sabbatini, H. Tompits, Considerations on updates of logic programs, in: M. Ojeda-Aciego, I.P. de Guzmán, G. Brewka, L.M. Pereira
(Eds.), Proceedings of the Seventh European Workshop on Logics in Artiﬁcial Intelligence (JELIA’2000), in: Lecture Notes in Artiﬁcial Intelligence,
vol. 1919, Springer-Verlag, 2000, pp. 2–20.

[19] T. Eiter, M. Fink, G. Sabbatini, H. Tompits, On properties of update sequences based on causal rejection, Theory and Practice of Logic Programming 2 (6)

(2002) 711–767.

[20] T. Eiter, M. Fink, S. Woltran, Semantical characterizations and complexity of equivalences in answer set programming, ACM Transactions on Computa-

tional Logic 8 (3) (Aug. 2007).

[21] T. Eiter, G. Gottlob, The complexity of logic-based abduction, Journal of the ACM 42 (1995) 3–42.
[22] T. Eiter, G. Gottlob, On the computational cost of disjunctive logic programming: Propositional case, Annals of Mathematics and Artiﬁcial Intelli-

gence 15 (3–4) (1995) 289–323.

[23] T. Eiter, G. Ianni, R. Schindlauer, H. Tompits, A uniform integration of higher-order reasoning and external evaluations in answer set programming, in:
L.P. Kaelbling, A. Saﬃotti (Eds.), Proceedings of the 19th International Joint Conference on Artiﬁcial Intelligence (IJCAI-05), Professional Book Center,
2005, pp. 90–96.

[24] T. Eiter, G. Ianni, R. Schindlauer, H. Tompits, K. Wang, Forgetting in managing rules and ontologies, in: Proceedings of the IEEE/WIC/ACM International
Conference on Web Intelligence (WI 2006), Hongkong, December 2006, IEEE Computer Society, 2006, pp. 411–419. Preliminary version at ALPSWS
2006.

[25] T. Eiter, K. Makino, G. Gottlob, Computational aspects of monotone dualization: A brief survey, Discrete Applied Mathematics (2007), doi:10.1016/

j.dam.2007.04.017. Preliminary version available as Tech. Rep. INFSYS RR-1843-06-01, Institute of Information Systems, TU Vienna.

[26] E. Erdem, V. Lifschitz, Tight logic programs, Theory and Practice of Logic Programming 3 (2003) 499–518.
[27] M. Gelfond, V. Lifschitz, Compiling circumscriptive theories into logic programs, in: Proceedings of the 7th National Conference on Artiﬁcial Intelligence

(AAAI 1988), AAAI Press/The MIT Press, 1988, 455–449.

1672

T. Eiter, K. Wang / Artiﬁcial Intelligence 172 (2008) 1644–1672

[28] M. Gelfond, V. Lifschitz, The stable model semantics for logic programming, in: R.A. Kowalski, K.A. Bowen (Eds.), Proceedings of the Fifth International

Conference and Symposium on Logic Programming (ICLP/SLP 1988), The MIT Press, 1988, pp. 1070–1080.

[29] M. Gelfond, V. Lifschitz, Logic programs with classical negation, in: D.H.D. Warren, P. Szeredi (Eds.), Proceedings of the Seventh International Conference

on Logic Programming (ICLP 1990), The MIT Press, 1990, pp. 579–597.

[30] M. Gelfond, V. Lifschitz, Classical negation in logic programs and deductive databases, New Generation Computing 9 (1991) 365–385.
[31] J. Grant, J. Horty, J. Lobo, J. Minker, View updates in stratiﬁed disjunctive databases, Journal of Automated Reasoning 11 (2) (1993) 249–267.
[32] K. Inoue, C. Sakama, Negation as failure in the head, Journal of Logic Programming 35 (1) (1998) 39–78.
[33] T. Janhunen, I. Niemelä, P. Simons, J.-H. You, Partiality and disjunctions in stable model semantics, in: A.G. Cohn, F. Giunchiglia, B. Selman (Eds.),
Proceedings of the Seventh International Conference on Principles of Knowledge Representation and Reasoning (KR 2000), April 12–15, Breckenridge,
Colorado, USA, Morgan Kaufmann Publishers, Inc., 2000, pp. 411–419.

[34] J. Lang, P. Liberatore, P. Marquis, Propositional independence: Formula-variable independence and forgetting, Journal of Artiﬁcial Intelligence Re-

search 18 (2003) 391–443.

[35] J. Lang, P. Marquis, Resolving inconsistencies by variable forgetting, in: D. Fensel, F. Giunchiglia, D.L. McGuinness, M.-A. Williams (Eds.), Proceedings of

the Eighth International Conference on the Principles of Knowledge Representation and Reasoning, Morgan Kaufmann, 2002, pp. 239–250.

[36] J. Larrosa, Boosting search with variable elimination, in: R. Dechter (Ed.), Proceedings 6th International Conference on Principles and Practice of

Constraint Programming (CP 2000), in: Lecture Notes in Computer Science, vol. 1894, Springer, 2000, pp. 291–305.

[37] J. Larrosa, E. Morancho, D. Niso, On the practical use of variable elimination in constraint optimization problems: ‘still-life’ as a case study, Journal of

Artiﬁcial Intelligence Research 23 (2005) 421–440.

[38] C. Lassez, K. McAloon, G.S. Port, Stratiﬁcation and knowledge based management, in: J.-L. Lassez (Ed.), Proceedings of the Fourth International Confer-

ence on Logic Programming (ICLP 87), MIT Press, 1987, pp. 136–151.

[39] J. Lee, V. Lifschitz, Loop formulas for disjunctive logic programs, in: C. Palamidessi (Ed.), Proceedings of the Nineteenth International Conference on

Logic Programming (ICLP-03), in: Lecture Notes in Computer Science, vol. 2916, Springer, 2003, pp. 451–465.

[40] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, F. Scarcello, The DLV system for knowledge representation and reasoning, ACM Transactions

on Computational Logic 7 (3) (2006) 499–562.

[41] C.I. Lewis, A Survey of Symbolic Logic, University of California Press, 1918; reprinted by Dover Pub’s., Inc., New York, 1960 (Chapter II, “The Classic, or

Boole–Schroder Algebra of Logic”).

[42] V. Lifschitz, Computing circumscription, in: A.K. Joshi (Ed.), Proceedings 9th International Joint Conference on Artiﬁcial Intelligence (IJCAI-85), Morgan

Kaufmann, 1985, pp. 121–127.

[43] V. Lifschitz, Circumscription, in: D. Gabbay, C. Hogger, J. Robinson (Eds.), Handbook of Logic in Artiﬁcial Intelligence and Logic Programming, vol. III,

Clarendon Press, Oxford, 1994, pp. 297–352.

[44] V. Lifschitz, Answer set programming and plan generation, Artiﬁcial Intelligence 138 (2002) 39–54.
[45] V. Lifschitz, D. Pearce, A. Valverde, Strongly equivalent logic programs, ACM Transactions on Computational Logic 2 (4) (2001) 426–541.
[46] V. Lifschitz, L. Tang, H. Turner, Nested expressions in logic programs, Annals of Mathematics and Artiﬁcial Intelligence 25 (1999) 369–389.
[47] V. Lifschitz, H. Turner, Splitting a logic program, in: P. Van Hentenryck (Ed.), Proceedings of the 11th International Conference on Logic Programming

(ICLP 1994), MIT Press, 1994, pp. 23–37.

[48] F. Lin, On strongest necessary and weakest suﬃcient conditions, Artiﬁcial Intelligence 128 (1–2) (2001) 143–159.
[49] F. Lin, R. Reiter, Forget it, in: R. Greiner, D. Subramanian (Eds.), Proceedings of the AAAI Fall Symposium on Relevance, The AAAI Press, 1994, pp. 154–

159, Technical Report FS-94-02.

[50] F. Lin, Y. Zhao, ASSAT: computing answer sets of a logic program by SAT solvers, in: Proceedings of the AAAI National Conference on Artiﬁcial Intelli-

gence, The AAAI Press, 2002, pp. 112–117.

[51] F. Lin, Y. Zhao, ASSAT: computing answer sets of a logic program by SAT solvers, Artiﬁcial Intelligence 157 (2004) 115–137.
[52] W. Marek, M. Truszczy ´nski, Autoepistemic logic, Journal of the ACM 38 (3) (1991) 588–619.
[53] W. Marek, M. Truszczy ´nski, Revision programming, Theoretical Computer Science 190 (1998) 241–277.
[54] J. McCarthy, Circumscription—a form of nonmonotonic reasoning, Artiﬁcial Intelligence 13 (1–2) (1980) 27–39.
[55] A. Middeldorp, S. Okui, T. Ida, Lazy narrowing: Strong completeness and eager variable elimination, Theoretical Computer Science 167 (1&2) (1996)

95–130.

[56] Y. Moinard, Forgetting literals with varying propositional symbols, Journal of Logic and Computation 17 (5) (2007) 955–982.
[57] R. Moore, Semantical considerations on nonmonotonic logics, Artiﬁcial Intelligence 25 (1985) 75–94.
[58] N.F. Noy, H. Stuckenschmidt, Ontology alignment: An annotated bibliography, in: Semantic Interoperability and Integration, in: Dagstuhl Seminar

Proceedings, vol. 04391, IBFI, Schloss Dagstuhl, Germany, 2005.

[59] D. Pearce, H. Tompits, S. Woltran, Encodings for equilibrium logic and logic programs with nested expressions, in: P. Brazdil, A. Jorge (Eds.), 10th

Portuguese Conference on Artiﬁcial Intelligence (EPIA 2001), in: Lecture Notes in Computer Science, vol. 2258, Springer, 2001, pp. 306–320.

[60] R. Reiter, A logic for default reasoning, Artiﬁcial Intelligence 13 (1980) 81–132.
[61] D. Sacca, C. Zaniolo, Partial models and three-valued stable models in logic programs with negation, in: A. Nerode, W. Marek, V.S. Subrahmanian (Eds.),

Proceedings of the Workshop on Nonmonotonic Reasoning and Logic Programming, MIT Press, 1991, pp. 87–101.

[62] C. Sakama, K. Inoue, An abductive framework for computing knowledge base updates, Theory and Practice of Logic Programming 3 (6) (2003) 671–713.
[63] D. Subramanian, R. Greiner, J. Pearl (Eds.), Artiﬁcial Intelligence Journal: Special Issue on Relevance 97 (1–2) (1997).
[64] C. Tessier, L. Chaudron, H. Müller, Conﬂicting Agents—Conﬂict Management in Multi-Agent Systems, Kluwer Academic Publishers, Cambridge, 2001.
[65] K. Wang, A. Sattar, K. Su, A theory of forgetting in logic programming, in: Proceedings of the 20th National Conference on Artiﬁcial Intelligence, AAAI

Press, 2005, pp. 682–687.

[66] K. Wang, L. Zhou, Comparisons and computation of well-founded semantics for disjunctive logic programs, ACM Transactions on Computational

Logic 6 (2) (2005) 295–327.

[67] A. Weber, Updating propositional formulas, in: L. Kerschberg (Ed.), Proceedings of the First Conference on Expert Database Systems (EDS 1986), Ben-

jamin Cummings, 1987, pp. 487–500.

[68] Y. Zhang, Logic program-based updates, ACM Transactions on Computational Logic 7 (3) (2006) 421–472.
[69] Y. Zhang, N. Foo, Towards generalized rule-based updates, in: Proceedings of the Fifteenth International Joint Conference on Artiﬁcial Intelligence (IJCAI

’97), Morgan Kaufmann, 1997, pp. 82–87.

[70] Y. Zhang, N. Foo, Solving logic program conﬂict through strong and weak forgettings, Artiﬁcial Intelligence 170 (8-9) (2006) 739–778.
[71] Y. Zhang, N. Foo, K. Wang, Solving logic program conﬂicts through strong and weak forgettings, in: L.P. Kaelbling, A. Saﬃotti (Eds.), Proceedings of the

International Joint Conference on Artiﬁcial Intelligence (IJCAI 2005), AAAI Press, 2005, pp. 627–632.

