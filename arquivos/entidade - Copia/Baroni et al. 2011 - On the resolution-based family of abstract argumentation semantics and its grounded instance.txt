Artiﬁcial Intelligence 175 (2011) 791–813

Contents lists available at ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

On the resolution-based family of abstract argumentation semantics and
its grounded instance
P. Baroni a, P.E. Dunne b, M. Giacomin a,∗

a Dip. di Ingegneria dell’Informazione, University of Brescia, Via Branze 38, 25123 Brescia, Italy
b Department of Computer Science, Ashton Building, University of Liverpool, Liverpool L69 7ZF, United Kingdom

a r t i c l e

i n f o

a b s t r a c t

This paper introduces a novel parametric family of semantics for abstract argumentation
called resolution-based and analyzes in particular the resolution-based version of the
traditional grounded semantics, showing that it features the unique property of satisfying
a set of general desirable properties recently introduced in the literature. Additionally,
an investigation of its computational complexity properties reveals that resolution-based
grounded semantics is satisfactory also from this perspective.

© 2010 Elsevier B.V. All rights reserved.

Article history:
Received 14 January 2010
Received in revised form 11 October 2010
Accepted 16 November 2010
Available online 19 November 2010

Keywords:
Abstract argumentation semantics
Argumentation framework
Grounded semantics
Semantics evaluation criteria
Computational complexity

1. Introduction

In the context of Dung’s theory of abstract argumentation frameworks [18] a variety of argumentation semantics have
been proposed including the four “traditional” semantics considered in the original Dung’s paper (namely stable, complete,
grounded and preferred semantics) and several more recent approaches like ideal [19], semi-stable [13], CF2 [10], and
prudent [15] semantics.

As discussed in [6], the motivations supporting the introduction and investigation of a new semantics range from the
desire to formalize some high-level intuition, not captured by other proposals, to the need to achieve the “correct” treat-
ment of a particular example (or family of examples), regarded as particularly signiﬁcant. Heterogeneous and often scarcely
formalized motivations are probably the main reason for the lack of systematic principle-based semantics evaluation and
comparison until recent years. Two major efforts to ﬁll this gap can be identiﬁed in the literature. On one hand, in [6]
a comprehensive set of evaluation and comparison criteria has been introduced and their satisfaction by several abstract
argumentation semantics veriﬁed. On the other hand in [14] general rationality postulates have been introduced for argu-
mentation systems at a different abstraction level, where argument structure and construction are explicitly dealt with.

The present work, which is focused on abstract argumentation semantics, stems from an essentially negative result
provided in [6]: none of the traditional or more recent literature proposals listed above is able to satisfy all the desirable
properties for an abstract argumentation semantics. This raises two “natural” questions:

• are the desirable properties identiﬁed in [6] actually achievable altogether?

* Corresponding author.

E-mail addresses: pietro.baroni@ing.unibs.it (P. Baroni), P.E.Dunne@liverpool.ac.uk (P.E. Dunne), massimiliano.giacomin@ing.unibs.it (M. Giacomin).

0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2010.11.005

792

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

• is it feasible and practically useful to drive the deﬁnition of abstract argumentation semantics by formal criteria rather

than basic intuitions?

The paper provides a positive answer to both questions in a constructive way by introducing a novel family of abstract
∗
argumentation semantics called resolution-based and then focusing on its instance resolution-based grounded semantics (GR
in the following), whose properties are investigated. It turns out that GR
satisﬁes all the general desiderata of [6] while
being at the same time computationally more tractable than any non-trivial multiple-status semantics analyzed up to now
in the literature.

∗

The paper is organized as follows. Section 2 provides the necessary background concepts, while Section 3 reviews the de-
sirable properties for abstract argumentation semantics introduced in [6]. In Section 4 the general class of resolution-based
argumentation semantics is introduced, whose deﬁnition is purposely “principle-driven”. Section 5 introduces GR
as an
instance of the resolution-based family of semantics and shows that it satisﬁes all the desirable properties altogether, while
are investigated in Section 6 in the general case and in Section 7 considering restricted
computational properties of GR
classes of argumentation frameworks. Discussion and conclusions are provided in Section 8.

∗

∗

2. Background concepts and notation

2.1. Abstract argumentation frameworks

This work lies in the frame of Dung’s theory of abstract argumentation frameworks [18].

Deﬁnition 1. An argumentation framework (af for short) is a pair G = (cid:3)A, R(cid:4), written also G(A, R), where A is a ﬁnite set
of arguments and R ⊆ A × A is a binary attack relation on A. The pair (cid:3)∅, ∅(cid:4) is called the empty argumentation framework.

The meaning and possible internal structure of the elements of A and of the attack relation R are abstracted away and
therefore not speciﬁed. An argumentation framework has an obvious representation as a directed graph, often called defeat
graph.

Some additional notation1 and terminology concerning attacks will be helpful.

Deﬁnition 2. A pair (cid:3)x, y(cid:4) ∈ R is also denoted as x → y and referred to as ‘x attacks y’ or ‘ y is attacked by x’. On the other
hand (cid:3)x, y(cid:4) /∈ R is also denoted as x (cid:9)→ y. An argument x is self-defeating if x → x. Two distinct arguments x and y are
involved in a mutual attack if x → y and y → x. The set of mutual attacks of G will be denoted as MG = {(cid:3)x, y(cid:4) ∈ R | x (cid:9)=
y ∧ (cid:3) y, x(cid:4) ∈ R} (note that self-attacking arguments are not considered to deﬁne mutual attacks).

Since we will frequently deal with sets of arguments, it is also useful to deﬁne suitable notations for them.

Deﬁnition 3. Given a set of arguments S ⊆ A and an argument x ∈ A we say that ‘S attacks x’ (denoted as S → x) if
∃ y ∈ S : y → x and that ‘x attacks S’ (denoted as x → S) if ∃ y ∈ S : x → y. Given a set of arguments S ⊆ A we denote the
+ = {x ∈ A | S → x}.
set of attackers (or defeaters) of S as S
When necessary, these sets will be referred to a speciﬁc af G using the notations S
is called the
range of S [32] and denoted as ρ(S).

− = {x ∈ A | x → S} and the set of arguments attacked by S as S

+
G . The set S ∪ S

An argument x is unattacked (or initial) if {x}− = ∅. The set of unattacked arguments in G will be denoted as IN(G). A set
of arguments S is conﬂict-free if (cid:2)x, y ∈ S : x → y, denoted in the following as cf (S). The set of maximal (with respect to set
inclusion) conﬂict-free sets of G will be denoted as MCF (G).

−
G and S

+

We need to deﬁne also the complement of a set of arguments and the restriction of an argumentation framework.

Deﬁnition 4. Given an af G = (cid:3)A, R(cid:4) and a set of arguments S ⊆ A:

• the complement of S is deﬁned as S C = A \ S;
• the restriction of G to S is the af G↓S = (cid:3)S, R ∩ (S × S)(cid:4).

The notion of resolution of an argumentation framework (introduced in [28]) arises from the idea that each mutual
attack represents a sort of “undecided” situation, which might be resolved in favour of one of the arguments involved by
suppressing the attack it receives, i.e. transforming the mutual attack into a unidirectional one.

1 A summary of the notation adopted in the paper is provided in Appendix A.

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

793

Fig. 1. G1: an argumentation framework with two resolutions.

Fig. 2. G2: an argumentation framework with many resolutions.

Deﬁnition 5. Given an af G = (cid:3)A, R(cid:4), a (partial) resolution of G is deﬁned as any subset β ⊂ MG such that if (cid:3)x, y(cid:4) ∈ β then
(cid:3) y, x(cid:4) /∈ β, i.e. such that at most one element of each of the pairs (cid:3)x, y(cid:4), (cid:3) y, x(cid:4) of MG is in β. The af arising from applying the
partial resolution β to G is denoted as Gβ = (cid:3)A, R \ β(cid:4). A full resolution γ is any partial resolution in which exactly one
= ∅. The set of full resolutions of G is denoted as
element of each mutual attack occurs, i.e. γ is a full resolution if MGγ
F R(G), while the set of argumentation frameworks arising from them is denoted as F RAF (G) = {Gβ | β ∈ F R(G)}.

To exemplify this notion let us introduce two examples we will use throughout the paper.
The af G1 shown in Fig. 1 includes only one mutual attack, involving arguments c and d, and has just two non-empty

resolutions (both full). Formally, F R(G1) = {{(cid:3)c, d(cid:4)}, {(cid:3)d, c(cid:4)}}.

The af G2 shown in Fig. 2 includes ﬁve mutual attacks. Given that to deﬁne any resolution there are three choices for
each mutual attack (selecting one of the attacks or neither) and excluding the empty resolution it follows that G2 admits
242 resolutions. On the other hand, to deﬁne a full resolution there are two choices for each mutual attack entailing that
G2 has 32 full resolutions, including for instance {(cid:3)a, b(cid:4), (cid:3)c, a(cid:4), (cid:3)c, b(cid:4), (cid:3)g, f (cid:4), (cid:3)g, h(cid:4)}.

2.2. Abstract argumentation semantics

The notions of acceptable argument and characteristic function provide the basis for the deﬁnition of some of the tradi-

tional Dung’s semantics.

Deﬁnition 6. Given an af G = (cid:3)A, R(cid:4), an argument x ∈ A is acceptable with respect to (or, equivalently, is defended by)
a set S ⊆ A if ∀ y ∈ {x}−
deﬁned as FG (S) =
{x ∈ A | acc(x, S)} is called the characteristic function of G. We will use the notation F 1
G (S) (cid:2)
FG (F i−1

A
G (S) (cid:2) FG (S) and for i > 1, F i

S → y (denoted in the following as acc(x, S)). The function FG : 2

A → 2

G (S)).

In Dung’s theory, an (extension-based) argumentation semantics is deﬁned by specifying the criteria for deriving, given
a generic argumentation framework, the set of all possible extensions, each one representing a set of arguments able to
“survive together” the conﬂict represented by the attack relation. For a detailed account of traditional and more recent
semantics proposals in abstract argumentation the reader may refer to [18,6,7]. Here we recall only the notions that will be
used in the sequel of the paper.

A

Given a generic argumentation semantics S, the set of extensions prescribed by S for a given argumentation framework
. A relevant question concerns the existence of extensions. For a given semantics S,
G = (cid:3)A, R(cid:4) is denoted as ES (G) ⊆ 2
we deﬁne DS = {G | ES (G) (cid:9)= ∅}, namely the set of argumentation frameworks where S admits at least one extension. If no
argumentation framework is outside DS we will say that S is universally deﬁned. Most literature semantics are universally
deﬁned for ﬁnite argumentation frameworks, with the notable exception of stable semantics [18]. As a further terminological
note, if it holds that ∀G ∈ DS |ES (G)| = 1 then the semantics S is said to belong to the unique-status approach, otherwise
it is said to belong to the multiple-status approach.

The following semantics deﬁnitions2 need to be recalled.

2 For the sake of conciseness, in some cases we use as deﬁnition what is actually an equivalent characterization with respect to the deﬁnition given in

the relevant original paper.

794

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

Fig. 3. The argumentation framework cut(G1).

Deﬁnition 7. Given an af G = (cid:3)A, R(cid:4), a set S ⊆ A is:

Fig. 4. The argumentation framework cut(G2).

• a complete extension if cf (S) and S = FG (S);
• the (unique) grounded extension if S is the minimal (with respect to set inclusion) complete extension;
• a preferred extension if it is a maximal (with respect to set inclusion) complete extension;
• a stable extension if cf (S) and S
• a semi-stable extension if it is a preferred extension such that ρ(S) is maximal (with respect to set inclusion);
• the (unique) ideal extension if it is the maximal (with respect to set inclusion) admissible set included in all preferred

+ = S C ;

extensions.

Commenting on semantics deﬁnitions, a complete extension is a conﬂict-free set of arguments which includes all the
arguments it defends (i.e., it is a ﬁxed point of FG ), the (provably unique) grounded extension is the smallest such set,
while the preferred extensions are the maximal ones, and a stable extension is a conﬂict-free set which attacks all arguments
not belonging to it. A semi-stable extension is a preferred extension where the maximization requirement is extended to
attacked arguments too (this implies that semi-stable extensions coincide with stable extensions when the latter exist). The
deﬁnition of ideal extension is self-explanatory and implies that it includes the grounded extension. Other recent semantics
proposals include CF2 [10] and prudent versions of traditional semantics [15]. Reviewing their articulate deﬁnitions is beyond
the scope of the present paper: the reader may consult the original references for further details.

Complete, grounded, preferred, stable, semi-stable, and ideal semantics are denoted as CO, GR, PR, ST , SST , and ID,
respectively. The grounded and ideal extension of an af G are denoted respectively as GE(G) and ID(G). Due to the key role
played by GR in this paper we need to introduce some additional notations and recall an important property.

Deﬁnition 8. Given an af G = (cid:3)A, R(cid:4), cut(G) is the af obtained by suppressing the arguments in the grounded extension
and those attacked by them, i.e. cut(G) = G↓(A\ρ(GE(G))). Letting β be a resolution of G, we will use the shorthand notation
cut(G)β to denote cut(G)β∩((A\ρ(GE(G)))×(A\ρ(GE(G)))).

It is proved in [18] that GE(G) results from the iterated application of the characteristic function starting from the empty

set when G is ﬁnitary.

Deﬁnition 9. An af G = (cid:3)A, R(cid:4) is ﬁnitary if for any x ∈ A {x}−

is ﬁnite.

Proposition 1. For any ﬁnitary af G = (cid:3)A, R(cid:4) GE(G) =

(cid:2)∞
i=1

F i

G (∅).

To exemplify these notions we refer again to Figs. 1 and 2. Given that GE(G1) = {a} and GE(G2) = {e}, the resulting
cut(G1) and cut(G2) are as shown in Figs. 3 and 4 respectively. Note also that if ρ(GE(G)) = A then cut(G) is the empty
argumentation framework. Later in the paper we will need to consider the grounded extension of an empty argumentation
framework: by deﬁnition GE((cid:3)∅, ∅(cid:4)) = ∅.

Finally, we also need to introduce a notion of “stability” concerning sets of arguments.

Deﬁnition 10. Given an af G = (cid:3)A, R(cid:4) and two sets S, T ⊆ A, S is stable in T with respect to G, denoted as stG (S, T ), if
∀x ∈ (T \ S) x ∈ (S ∩ T )+

.

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

795

3. Evaluation criteria for abstract argumentation semantics

We recall in this section the deﬁnition of the main principles and criteria (corresponding to desirable semantics proper-

ties) discussed in [6], to which the reader is referred for all details and a more extensive analysis.

3.1. Extension evaluation criteria

Given that an extension can be intuitively conceived as a set of arguments that can be accepted together according
to some semantics-speciﬁc requirements, one may consider as an additional constraint that no extension can be a proper
subset of another one. This is in particular advantageous with respect to the issue of formally deﬁning the justiﬁcation
states of arguments and has a straightforward formal counterpart.

Deﬁnition 11. A set of extensions E is I-maximal iff ∀E 1, E2 ∈ E it holds that (E1 ⊆ E2) ⇒ (E1 = E2). A semantics S satisﬁes
the I-maximality criterion if and only if for any af G ∈ DS , ES (G) is I-maximal.

The requirement of admissibility, which actually lies at the heart of all semantics discussed in [18], is based on the notion

of admissible set and corresponds to the idea that an extension should be able to defend itself against attacks.

Deﬁnition 12. Given an af G = (cid:3)A, R(cid:4), a set E ⊆ A is admissible if and only if cf (E) and any argument x ∈ E is acceptable
with respect to E. The set of the admissible sets of G is denoted as AS(G).

A semantics S satisﬁes the admissibility criterion if for any af G ∈ DS , it holds that ∀E ∈ ES (G) E ∈ AS(G), namely:

x ∈ E ⇒ ∀ y ∈ {x}−

E → y

(1)

The property of reinstatement corresponds to the converse of the implication (1) prescribed by the admissibility criterion.
Intuitively, an argument x is reinstated if its attackers are in turn attacked and, as a consequence, one may assume that they
should have no effect on the extension membership of x. Under this assumption, if an extension E reinstates x then x should
belong to E. Formally this leads to the following reinstatement criterion:

Deﬁnition 13. A semantics S satisﬁes the reinstatement criterion if ∀G ∈ DS , ∀E ∈ ES (G) it holds that:

(cid:3)

∀ y ∈ {x}−

E → y

(cid:4)

⇒ x ∈ E

(2)

The notion of directionality is based on the idea that the extension membership of an argument x should be affected
only by the attackers of x (which in turn are affected by their attackers and so on), while any argument y such that there
is no path from y to x should not have any effect on x. The directionality criterion can be speciﬁed by requiring that a set
of arguments not receiving attacks from outside is not affected by the remaining parts of the argumentation framework, as
far as extensions are concerned.

Deﬁnition 14. Given an af G = (cid:3)A, R(cid:4), a set S ⊆ A is externally unattacked if and only if (cid:2)x ∈ S C : x → S. The set of
externally unattacked sets of G will be denoted as U S(G).

Deﬁnition 15. A semantics S satisﬁes the directionality criterion if and only if for any af G = (cid:3)A, R(cid:4) ∈ DS , ∀T ∈ U S(G) it
holds that AE S (G, T ) = ES (G↓T ) where AE S (G, T ) = {(R ∩ T ) | R ∈ ES (G)} ⊆ 2

A

.

In words, directionality prescribes that one obtains the same result (i.e. the same set of sets of arguments) by either
projecting the extensions of the whole framework to an externally unattacked set or computing the extensions of the
framework restricted to the same externally unattacked set. More precisely, the intersection of any extension prescribed
by S for G with an externally unattacked set T is equal to one of the extensions prescribed by S for the restriction of G
to T , and vice versa.

3.2. Skepticism related criteria

Semantics adequacy criteria introduced in [6] are based on comparisons of sets of extensions which in turn exploit some

recently introduced notions concerning the formalization of skepticism.

3.2.1. Skepticism relations

The notion of skepticism has often been used in the literature in informal or semi-formal ways to discuss semantics
behavior, e.g. by observing that a semantics S1 is “more skeptical” than another semantics S2, which intuitively means
that S1 makes less committed choices than S2 about the justiﬁcation state of the arguments. A more formal and general

796

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

analysis has been carried out in [6,8] and is partly recalled here. First, we consider as a basic concept a generic relation of
skepticism (cid:3)E between sets of extensions: given two sets of extensions E1, E2 of an argumentation framework G, E1 (cid:3)E E2
will simply denote that E1 is at least as skeptical as E2 in some sense. In the approach to semantics evaluation we are re-
calling, a skepticism relation is used to compare the sets of extensions prescribed by a particular semantics on different but
related argumentation frameworks. To this purpose, one ﬁrst needs to deﬁne a skepticism relation between argumentation
frameworks: given two argumentation frameworks based on the same set of arguments G1 = (cid:3)A, R1(cid:4) and G2 = (cid:3)A, R2(cid:4),
G1 (cid:3) A G2 denotes that G1 (actually its attack relation) is inherently less committed (to be precise, not more committed)
than G2. Then, one may reasonably require that any semantics reﬂects in its extensions the skepticism relations between
argumentation frameworks. Requirements of this kind for a generic semantics S will be called adequacy criteria. Having laid
out the general framework for the deﬁnition of adequacy criteria, we ﬁrst recall the actual skepticism relations used in the
sequel.

Let us start, at a basic level, by noting that deﬁning a relation of skepticism between two extensions is intuitively
straightforward: an extension E1 is more skeptical than an extension E 2 if and only if E1 ⊆ E2. In fact, a more skeptical
attitude corresponds to a smaller set of selected arguments. Directly extending the above intuition to the comparison of sets
of extensions leads to deﬁne the following skepticism relation (cid:3)E
∩.

Deﬁnition 16. Given two non-empty sets of extensions E1 and E2 of an argumentation framework G, E1 (cid:3)E
(cid:5)

(cid:5)

∩ E2 iff

E1∈E1

E1 ⊆

E2∈E2

E2.

Finer (and actually stronger) skepticism relations can then be deﬁned by considering relations of pairwise inclusion
between extensions. We recall that to compare a single extension E 1 with a set of extensions E2, the relation ∀E2 ∈ E2, E1 ⊆
E2 has often been used in the literature. A direct generalization to the comparison of two sets of extensions is represented
by the following weak skepticism relation (cid:3)E

W .

Deﬁnition 17. Given two non-empty sets of extensions E1 and E2 of an af G, E1 (cid:3)E
W

E2 iff

∀E2 ∈ E2 ∃E1 ∈ E1: E1 ⊆ E2

(3)

It is worth noting that (as it is easy to see), given two sets of extensions E1 and E2 of an argumentation framework G,

E1 (cid:3)E
W

E2 ⇒ E1 (cid:3)E

∩ E2.

In a sense, relation (cid:3)E

W is unidirectional, since it only constrains the extensions of E2, while E1 may contain additional
extensions unrelated to those of E2. One may then consider also a more symmetric (and stronger) relationship (cid:3)E
S , where it
is also required that any extension of E1 is included in one extension of E2. However, as discussed in [9,5,6] this relationship
is deﬁnitely too strong since it actually prevents comparability of any pair of multiple-status semantics. For this reason, it
will not be considered here. It is also worth mentioning that analogous relations (called generality relations, as they are
deﬁned in the opposite direction of comparison) have been considered for comparing extensions of default logic in [27]
and that, at a more general level, this kind of relations can be put in correspondence with Smyth- and Hoare-orderings,
considered in the context of nondeterministic computations [30,1].

Turning to skepticism relations between argumentation frameworks, a relation (cid:3) A has been proposed in [6], generalizing
some more speciﬁc but related notions introduced in [5] and [28]. The underlying idea, as already mentioned in Section 2
when introducing the notion of resolution, is that a mutual attack corresponds to a less committed (or, equivalently, more
undecided) situation than a unidirectional attack. Therefore if an argumentation framework G(cid:19)
is obtained from another
argumentation framework G by transforming some mutual attacks into unidirectional ones, it is reasonable to assume
that G(cid:19)
is more committed than G. On this basis, we deﬁne a skepticism relation (cid:3) A between argumentation frameworks
based on the same set of arguments.

Deﬁnition 18. Given two argumentation frameworks G1 = (cid:3)A, R1(cid:4) and G2 = (cid:3)A, R2(cid:4), G1 (cid:3) A G2 if and only if there is a
resolution β of G1 such that G2 = G1β .

It is easy to see that the above deﬁnition covers all cases where some (possibly none) mutual attacks of G1 correspond

to unidirectional attacks in G2, while unidirectional attacks of G1 are the same in G2.

Comparable argumentation frameworks are characterized by having the same set of arguments and the same set of
conﬂicting pairs of arguments. It is immediate to see that (cid:3) A is a partial order, as it is equivalent to requiring set inclusion
between attack relations, under the constraint that at least an attack is preserved for any pair of conﬂicting arguments in G1.
It is also worth noting that within a set of comparable argumentation frameworks there are, in general, several maximal
elements with respect to (cid:3) A , namely all argumentation frameworks where no mutual attack is present (corresponding to
all full resolutions).

3.2.2. Skepticism adequacy

Given that an argumentation framework is considered inherently more skeptical than another one, it is reasonable to
require that when applying the same semantics to both, the skepticism relation between them is preserved by the relevant

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

797

sets of extensions. This kind of criterion, called skepticism adequacy, has ﬁrst been proposed in [5] and is formulated here in
a generalized version.

Deﬁnition 19. Given a skepticism relation (cid:3)E between sets of extensions, a semantics S is (cid:3)E -skepticism-adequate, de-
noted SA(cid:2)E (S), if and only if for any pair of argumentation frameworks G, G(cid:19) ∈ DS such that G (cid:3) A G(cid:19)
it holds that
ES (G) (cid:3)E ES (G(cid:19)).

According to the deﬁnitions provided in Section 3.2.1 we have two skepticism adequacy properties, which are clearly
(S).

related by the same order of implication: SA(cid:2)E

(S) ⇒ SA(cid:2)E

W

∩

3.2.3. Resolution adequacy

Resolution adequacy generalizes a criterion ﬁrst proposed in [28] and relies on the intuition that if an argument is in-
cluded in any extensions of any element of F RAF (G) then it should be included in all extensions of G too. This criterion is
called resolution adequacy in [6] where a generalization of its original formulation is provided, in order to make it parametric
with respect to skepticism relations between sets of extensions.

Deﬁnition 20. Given a skepticism relation (cid:3)E between sets of extensions, a semantics S is (cid:3)E -resolution-adequate, denoted
RA(cid:2)E (S), if and only if for any argumentation framework G ∈ DS such that ∀G(cid:19) ∈ F RAF (G) G(cid:19) ∈ DS it holds that
U R(G, S) (cid:3)E ES (G), where U R(G, S) =

ES (G(cid:19)).

(cid:2)

G(cid:19)∈F RAF (G)

Again, we have two resolution adequacy properties, related by the usual order of implication: RA(cid:2)E

W

(S) ⇒ RA(cid:2)E

∩

(S).

4. The family of resolution-based semantics

As already mentioned, it is shown in [6] that none among the traditional grounded, complete, stable, and preferred
semantics nor among the more recent ideal, semi-stable, CF2, and (several ﬂavors3 of) prudent semantics satisﬁes the
properties of I-maximality, admissibility, reinstatement, directionality, (cid:3)E
W -
resolution adequacy altogether. In the search for a semantics able to satisfy all of them, we introduce a family of semantics
which is parametric with respect to another semantics S and whose deﬁnition is purposely oriented to the direct satisfac-
tion (or preservation, if they already hold for S) of some of the properties listed above. This family is called resolution-based
since its deﬁnition is based on the notion of resolution of an argumentation framework introduced in Deﬁnition 5.

W -skepticism adequacy, (cid:3)E

∩- and (cid:3)E

∩- and (cid:3)E

Deﬁnition 21. Given an argumentation semantics S which is universally deﬁned, its resolution-based version is the se-
mantics S(cid:5) such that for any argumentation framework G = (cid:3)A, R(cid:4) ES(cid:5) (G) = MIN (U R(G, S)), where given a set E of
subsets of A, MIN (E) denotes the set of the minimal (with respect to set inclusion) elements of E and U R(G, S) is as in
Deﬁnition 20.

Operationally, the idea underlying Deﬁnition 21 is as follows: given an argumentation framework G the set F RAF (G)
of all argumentation frameworks derivable from G by transforming all mutual attacks into unidirectional ones is determined.
Then semantics S is applied to each G(cid:19) ∈ F RAF (G) to obtain ES (G(cid:19)). The union U R(G, S) of these sets of extensions is
then considered and its minimal elements (with respect to set inclusion) selected as the extensions prescribed for G by S (cid:5).
Note that this deﬁnition directly enforces the property of I-maximality.

To exemplify,

let us refer again to the examples of Figs. 1 and 2 and consider the resolution-based version of
grounded semantics. It is quite easy to see that U R(G1, GR) = {{a, c, f }, {a, d, f }} from which it follows that EGR
∗ (G1) =
{{a, c, f }, {a, d, f }}. Turning to G2, it is a bit more laborious to see that U R(G2, GR) = {{e, f , h}, {e, g}, {e, f , h, a}, {e, f , h, b},
{e, f , h, c}, {e, g, a}, {e, g, b}, {e, g, c}}. Selecting its minimal elements yields EGR

∗ (G2) = {{e, f , h}, {e, g}}.

Let us now show that for any semantics S, S (cid:5) satisﬁes (cid:3)E

W -skepticism adequacy (and therefore also (cid:3)E

∩-skepticism

adequacy).

Proposition 2. For every argumentation semantics S, its resolution-based version S (cid:5) satisﬁes (cid:3)E

W -skepticism adequacy.

such that G (cid:3) A G(cid:19)
Proof. On the basis of Deﬁnition 19 we have to show that for any pair of argumentation frameworks G, G(cid:19)
ES(cid:5) (G(cid:19)). First, it is easy to see that for any such a pair of argumentation frameworks F RAF (G(cid:19)) ⊆
it holds that ES(cid:5) (G) (cid:3)E
W
F RAF (G), and, therefore, by deﬁnition of U R, U R(G(cid:19), S) ⊆ U R(G, S). Recalling that ES(cid:5) (G) = MIN (U R(G, S)) and
ES(cid:5) (G(cid:19)) = MIN (U R(G(cid:19), S)), it follows that ∀E
(cid:19) ∈ U R(G, S) and hence ∃E ∈ MIN (U R(G, S)) = ES(cid:5) (G)
ES(cid:5) (G(cid:19)). (cid:2)
, namely ES(cid:5) (G) (cid:3)E
such that E ⊆ E
W

(cid:19) ∈ ES(cid:5) (G(cid:19)) E

(cid:19)

3 A prudent version has been deﬁned for each of the four traditional Dung’s semantics.

798

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

Adding the (not particularly restrictive) hypothesis that S is I-maximal, S (cid:5) achieves also the property of (cid:3)E

W - (and

therefore (cid:3)E

∩-) resolution adequacy, as shown by the following proposition.

Proposition 3. For every I-maximal argumentation semantics S, its resolution-based version S (cid:5) satisﬁes (cid:3)E

W -resolution adequacy.

G(cid:19)∈F RAF (G)

ES(cid:5) (G(cid:19)). In turn, by Deﬁnition 21, ES(cid:5) (G(cid:19)) = MIN (U R(G(cid:19), S)) = MIN (

Proof. According to Deﬁnition 20 we have to show that U R(G, S (cid:5)) (cid:3)E
(cid:2)
W

ES(cid:5) (G). By deﬁnition of U R we have U R(G, S(cid:5)) =
ES (G(cid:19)(cid:19))). Since
belongs to F RAF (G), it is immediate to see that F RAF (G(cid:19)) = {G(cid:19)} therefore ES(cid:5) (G(cid:19)) = MIN (ES (G(cid:19))) = ES (G(cid:19)),
any G(cid:19)
ES (G(cid:19)) =
where the last equality holds by the hypothesis of I-maximality of S. It follows that U R(G, S (cid:5)) =
U R(G, S). On the other hand, by deﬁnition ES(cid:5) (G) = MIN (U R(G, S)). It follows that ES(cid:5) (G) ⊆ U R(G, S) = U R(G, S(cid:5))
which directly implies U R(G, S (cid:5)) (cid:3)E
W

G(cid:19)(cid:19)∈F RAF (G(cid:19))
(cid:2)

ES(cid:5) (G). (cid:2)

G(cid:19)∈F RAF (G)

(cid:2)

Turning to defense related criteria, a signiﬁcant result can be obtained using as a basis the following lemma concerning

the relationship between the complete extensions of the elements of F RAF (G) and those of G itself.

Lemma 1. For any af G = (cid:3)A, R(cid:4), ∀G(cid:19) ∈ F RAF (G) ECO(G(cid:19)) ⊆ ECO(G).

AS(G(cid:19)). Let E ∈ ECO(G(cid:19)),
Proof. It is shown in Lemma 1 of [28] that for any af G = (cid:3)A, R(cid:4), AS(G) =
since any complete extension is an admissible set (E ∈ AS(G(cid:19))), we also have that E ∈ AS(G). Then, to prove that E is a
complete extension in G we only need to show that ∀x ∈ A, (∀ y ∈ {x}−
+
G ) ⇒ x ∈ E. To this purpose we show that
any x defended by E in G is also defended by E in G(cid:19)
. First note that according to Deﬁnition 18, it must be the case that
+
, if y ∈ {z}−
G(cid:19) or y ∈ {z}−
∀ y ∈ E
G(cid:19) . In sum,
we have that ∀ y ∈ {x}−
). Now, since no additional attack edges are
+
G and we can derive that ∀z ∈ {x}−
present in G(cid:19)
G(cid:19)
(any attacker of x in G(cid:19)
it follows that x ∈ E. (cid:2)

+
G(cid:19) (any attacker of x in G is attacked by E in G(cid:19)
G(cid:19) ⊆ {x}−

with respect to those of G it must be the case that {x}−

G , ∃z ∈ E such that either z ∈ { y}−

). Since E is a complete extension in G(cid:19)

G(cid:19) . Since E is admissible in G(cid:19)

is attacked by E in G(cid:19)

G(cid:19) then also y ∈ E

G(cid:19)∈F RAF (G)

G , y ∈ E

G(cid:19) z ∈ E

G y ∈ E

+

(cid:2)

Proposition 4. If a semantics S is such that for any argumentation framework G ES (G) ⊆ ECO(G), then also ES(cid:5) (G) ⊆ ECO(G).

Proof. ES(cid:5) (G) ⊆ U R(G, S) =
Lemma 1, ECO(G(cid:19)) ⊆ ECO(G). It follows that ES(cid:5) (G) ⊆ ECO(G). (cid:2)

G(cid:19)∈F RAF (G)

(cid:2)

ES (G(cid:19)). By the hypothesis, for any G(cid:19) ∈ F RAF (G) ES (G(cid:19)) ⊆ ECO(G(cid:19)) and, by

Since it is known [6] that complete extensions satisfy the property of admissibility (1) and reinstatement (2) any

resolution-based version S (cid:5) of a semantics S satisfying the hypothesis of Proposition 4 also satisﬁes these properties.

5. Resolution-based grounded semantics

The results provided in Section 4 show that given a universally deﬁned and I-maximal semantics satisfying the hypothesis
∩- and

of Proposition 4, its resolution-based version satisﬁes the properties of I-maximality, admissibility, reinstatement, (cid:3)E
(cid:3)E

W -skepticism adequacy, (cid:3)E
Following these lines, let us look among the semantics considered in this paper for a candidate to which to apply the
resolution-based scheme. The requirement of universal deﬁnition leaves out stable semantics (and its prudent version), the
one of I-maximality excludes complete semantics,4 while the requirement that all extensions are complete excludes CF2 and
all other versions of prudent semantics, as shown in [6].

W -resolution adequacy, i.e. all the desirable properties but directionality.

∩- and (cid:3)E

The four remaining semantics satisfy the above requirements, but directionality of the resolution-based versions of pre-

ferred, ideal, and semi-stable semantics is ruled out by a single example, illustrated in Fig. 5.

and G(cid:19)(cid:19)

The argumentation framework G contains just one mutual attack between arguments a and c, it holds therefore that
F RAF (G) = {G(cid:19), G(cid:19)(cid:19)}. By applying the relevant deﬁnition, it is relatively easy to identify the preferred extensions (i.e.
the maximal admissible sets) of G(cid:19)
: EPR(G(cid:19)) = {{a, e, h}, {a, f , g, i}}, EPR(G(cid:19)(cid:19)) = {{ f , g, i}}. It is also easy to see
that ESST (G(cid:19)) = EPR(G(cid:19)) and ESST (G(cid:19)(cid:19)) = EPR(G(cid:19)(cid:19)), namely semi-stable extensions coincide with preferred extensions in
. In fact, in the case of G(cid:19)
both G(cid:19)
and G(cid:19)(cid:19)
both preferred extensions are also stable, hence necessarily semi-stable, while in
the case of G(cid:19)(cid:19)
the coincidence is immediate given that there is just one preferred extension. As to ideal semantics, in the
case of G(cid:19)
we note that the intersection of the preferred extensions, namely {a}, is admissible, hence EID(G(cid:19)) = {{a}}, while,
by deﬁnition, when there is just one preferred extension it is also the only ideal extension, hence EID(G(cid:19)(cid:19)) = {{ f , g, i}}.
Applying Deﬁnition 21 it follows that ESST (cid:5) (G) = EPR(cid:5) (G) = {{a, e, h}, { f , g, i}} and EID(cid:5) (G) = {{a}, { f , g, i}}. Consider
now the subset S = {a, b, c} which is clearly externally unattacked in G (formally S ∈ U S(G)). The restricted af G↓S has

4 Note that stable extensions may not exist for argumentation frameworks with simple topologies not involving mutual attacks (e.g. a three-length

unidirectional attack cycle). The same holds for complete semantics failing to satisfy I-maximality (e.g. a four-length unidirectional attack cycle).

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

799

Fig. 5. An example showing that PR(cid:5), SST (cid:5), and ID(cid:5) are not directional.

exactly two full resolutions, actually giving rise to the corresponding restrictions of G(cid:19)
(formally F RAF (G↓S ) =
{G(cid:19)↓S , G(cid:19)(cid:19)↓S }). It is easy to see that EPR(G(cid:19)↓S ) = ESST (G(cid:19)↓S ) = EID(G(cid:19)↓S ) = {{a}} and EPR(G(cid:19)(cid:19)↓S ) = ESST (G(cid:19)(cid:19)↓S ) =
EID(G(cid:19)(cid:19)↓S ) = {∅} from which it follows ESST (cid:5) (G↓S ) = EPR(cid:5) (G↓S ) = EID(cid:5) (G↓S ) = {∅}. We can now see that PR(cid:5), SST (cid:5),
and ID(cid:5) fail to satisfy Deﬁnition 15 with respect to the externally unattacked set S. In fact, for any semantics S (cid:5) ∈
{PR(cid:5), SST (cid:5), ID(cid:5)} it turns out that {(E ∩ S) | E ∈ ES(cid:5) (G)} = {{a}, ∅} (cid:9)= ES(cid:5) (G↓S ) = {∅}.

and G(cid:19)(cid:19)

Consider instead the behavior in this case of the only remaining candidate, namely the resolution-based version of
grounded semantics. It is easy to see that GE(G(cid:19)) = {a} while GE(G(cid:19)(cid:19)) = ∅. Applying Deﬁnition 21 it follows that EGR(cid:5) (G) =
MIN ({{a}, ∅}) = {∅}. It is also easily seen that EGR(cid:5) (G↓S ) = {∅}, thus satisfying the directionality property in this case.5

Happily, compliance of GR(cid:5) with the directionality property turns out to hold in general, as shown by Proposition 5,

which requires a preliminary lemma.

Lemma 2. For any af G = (cid:3)A, R(cid:4) and for any set S ⊆ A, {G(cid:19)↓S | G(cid:19) ∈ F RAF (G)} = F RAF (G↓S ).

Proof. Let us ﬁrst prove that, given G(cid:19) ∈ F RAF (G), G(cid:19)↓S ∈ F RAF (G↓S ). By deﬁnition, ∃β ∈ F R(G) such that G(cid:19) = Gβ .
Then considering β∗ = β ∩ (S × S) it is easy to see that β∗ ∈ F R(G↓S ) and G(cid:19)↓S = (G↓S )β∗ , hence G(cid:19)↓S ∈ F RAF (G↓S ).
Turning to the other direction of the proof, given a generic G(cid:19)(cid:19) ∈ F RAF (G↓S ) we have to prove that ∃G(cid:19) ∈ F R(G)
can be constructed from G by selecting a unidirectional attack for each mutual attack of G, with
(this is possible since G(cid:19)(cid:19) ∈

such that G(cid:19)↓S = G(cid:19)(cid:19)
the constraint that ∀x, y ∈ S the chosen attack between x and y is the one included in G(cid:19)(cid:19)
F RAF (G↓S )). It is then easy to see that G(cid:19) ∈ F RAF (G) and that G(cid:19)↓S = G(cid:19)(cid:19)

. (cid:2)

. G(cid:19)

Proposition 5. GR(cid:5) satisﬁes the directionality property.

Proof. According to Deﬁnition 15, we have to prove that for any af G, ∀S ∈ U S(G) {(E ∩ S) | E ∈ EGR(cid:5) (G)} = EGR(cid:5) (G↓S ).

Let G = (cid:3)A, R(cid:4) as usual. First, we prove that given a set E ∈ EGR(cid:5) (G) (E ∩ S) ∈ EGR(cid:5) (G↓S ). Since E ∈ EGR(cid:5) (G), accord-
ing to Deﬁnition 21 ∃G(cid:19) ∈ F RAF (G) such that E ∈ EGR(G(cid:19)). Since grounded semantics belongs to the unique status
approach, this is equivalent to ∃G(cid:19) ∈ F RAF (G) such that E = GE(G(cid:19)). It is easy to see that the set S, being externally
unattacked in G, also belongs to U S(G(cid:19)). Since grounded semantics satisﬁes the directionality property [6], we can de-
rive (E ∩ S) = GE(G(cid:19)↓S ). By Lemma 2, we have G(cid:19)↓S ∈ F RAF (G↓S ), which implies that (E ∩ S) ∈ U R(G↓S , GR). To see
that (E ∩ S) ∈ MIN (U R(G↓S , GR)) suppose by contradiction that ∃G∼ ∈ F RAF (G↓S ): GE(G∼) (cid:3) (E ∩ S). To see that
this is impossible, consider now an argumentation framework G(cid:19)(cid:19) = (cid:3)A, R(cid:19)(cid:19)(cid:4) such that G(cid:19)(cid:19)↓S = G∼
, G(cid:19)(cid:19)↓A\S = G(cid:19)↓A\S , and
∀(cid:3)x, y(cid:4) ∈ R: x ∈ S, y /∈ S (cid:3)x, y(cid:4) ∈ R(cid:19)(cid:19)
is obtained from G by applying within S the same substitutions of
mutual into unidirectional attacks as in G∼
, and the same substitutions as in G(cid:19)
outside S. Note in particular that since S
is externally unattacked, any attack involving an element x ∈ S and an element y /∈ S is unidirectional and has the form
x → y, therefore the same attack is necessarily present in G(cid:19)
(and in any argumentation framework arising from a resolution
of G). We will show that GE(G(cid:19)(cid:19)) (cid:3) GE(G(cid:19)) = E which contradicts the hypothesis that E ∈ MIN (U R(G, GR)). First note that,
by directionality of grounded semantics, GE(G(cid:19)(cid:19)) ∩ S = GE(G(cid:19)(cid:19)↓S ) = GE(G∼) (cid:3) (E ∩ S) = GE(G(cid:19)↓S ) = GE(G(cid:19)) ∩ S, yielding in
particular

. In words, G(cid:19)(cid:19)

GE(G(cid:19)(cid:19)

) ∩ S (cid:3) GE(G(cid:19)

) ∩ S

(4)

5 GR(cid:5) admits a unique extension here. It is however easy to see that GR(cid:5), differently from GR, belongs to the multiple-status approach. For instance, in

the af G1 shown in Fig. 1 there are two GR(cid:5) extensions, namely {a, c, f } and {a, d, f }.

800

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

G(cid:19) (∅). In fact for any G, F 1

G(cid:19)(cid:19) (∅) ⊆ F 1
G(cid:19)(cid:19) (∅) ⊆ GE(G(cid:19)). Consider any argument x in F i+1

It is then suﬃcient to show that GE(G(cid:19)(cid:19)) ⊆ GE(G(cid:19)). To this purpose, we exploit Proposition 1. It is easy to see that F 1
F 1
(4) entails that IN(G(cid:19)(cid:19)) ∩ S ⊆ IN(G(cid:19)) ∩ S. Having shown that F 1
G(cid:19)(cid:19) (∅) ⊆ GE(G(cid:19)) then F i+1
F i
have that x ∈ GE(G(cid:19)). If x /∈ S then by deﬁnition of F i
by construction of G(cid:19)(cid:19)
in G(cid:19)(cid:19)
attacks z in G(cid:19)
y in G(cid:19)
a complete extension it must be the case that x ∈ GE(G(cid:19)).

G(cid:19)(cid:19) (∅) ⊆
G (∅) = IN(G) (see Deﬁnition 3). By construction, IN(G(cid:19)(cid:19)) ∩ (A \ S) = IN(G(cid:19)) ∩ (A \ S) while
G(cid:19) (∅) ⊆ GE(G(cid:19)) let us prove by induction that if
G(cid:19)(cid:19) (∅). If x ∈ S then from (4) we directly
, and
G(cid:19)(cid:19) (∅) : z → y
belong to F RAF (G) either z attacks y or y
, where in the latter case, by the admissibility of GE(G(cid:19)) there must be another element of GE(G(cid:19)) attacking
by GE(G(cid:19)): since the latter is

G(cid:19)(cid:19) (∅) \ F i
G(cid:19)(cid:19) (∅) it holds that ∀ y : y → x in G(cid:19)(cid:19) ∃z ∈ F i

. Now, by the inductive hypothesis z ∈ GE(G(cid:19)), and since both G(cid:19)

. Summing up, when x /∈ S in any case all its defeaters in G(cid:19)

, therefore ∀ y : y → x in G(cid:19) ∃z ∈ F i

are in turn attacked in G(cid:19)

are precisely those in G(cid:19)

the defeaters of x in G(cid:19)(cid:19)

G(cid:19)(cid:19) (∅) : z → y in G(cid:19)(cid:19)

and G(cid:19)(cid:19)

Turning to the second part of the proof and letting S ∈ U S(G) and T ∈ EGR(cid:5) (G↓S ) = MIN (U R(G↓S , GR)), we have to
show that ∃E ∈ EGR(cid:5) (G) = MIN (U R(G, GR)) such that E ∩ S = T . First consider the set H = {E ∈ U R(G, GR) | E ∩ S = T }.
We know that H (cid:9)= ∅. In fact T = GE(G∼) for some G∼ ∈ F RAF (G↓S ). By Lemma 2, ∃G(cid:19) ∈ F RAF (G): G(cid:19)↓S = G∼
. Then
T = GE(G(cid:19)↓S ) and, by directionality of GR, GE(G(cid:19)) ∩ S = T , where GE(G(cid:19)) ∈ U R(G, GR). Therefore GE(G(cid:19)) ∈ H. Now, we have
to show that H ∩ MIN (U R(G, GR)) (cid:9)= ∅, namely that at least an element of H is also a minimal element of U R(G, GR).
∗ ∈ (U R(G, GR) \ H)
Suppose by contradiction that this is not the case. Since H ⊆ U R(G, GR) this entails that ∀E ∈ H ∃E
∗ ∈
∗ (cid:3) E. Now consider E
such that E
∗ ∩ S) (cid:3) T .
(U R(G, GR)\H) it cannot be the case that (E
∗ = GE(G(cid:19)(cid:19)). Since S ∈ U S(G) it also holds that S ∈ U S(G(cid:19)(cid:19)) and, by
Since E
directionality of GR, GE(G(cid:19)(cid:19)) ∩ S = GE(G(cid:19)(cid:19)↓S ). By Lemma 2, G(cid:19)(cid:19)↓S ∈ F RAF (G↓S ), and therefore GE(G(cid:19)(cid:19)) ∩ S ∈ U R(G↓S , GR)
but GE(G(cid:19)(cid:19)) ∩ S = E

∗ ∩ S (cid:3) T and this contradicts the hypothesis that T ∈ MIN (U R(G↓S , GR)). (cid:2)

∗ ∩ S) ⊆ (E ∩ S) = T , but since E
∗ ∈ U R(G, GR) | (E

∗ ∈ U R(G, GR) there exists G(cid:19)(cid:19) ∈ F RAF (G) | E

∗ (cid:3) E, it must be the case that (E

∗ ∩ S) (cid:3) T . Summing up, ∃E

∗ ∩ S) = T , therefore (E

∗ ∩ S: since E

6. Computational properties of GR

∗

∗

While GR

turns out satisfactory from a principle-based point of view, its deﬁnition may seem, at a ﬁrst glance, pro-
hibitive from a computational perspective since a straightforward implementation would involve the enumeration of the
(possibly) exponentially many full resolutions of an argumentation framework. Actually this explicit enumeration is not nec-
essary to solve several of the standard computational problems for argumentation semantics, which indeed turn out to be
tractable in the case of GR
with respect to the problems
listed below (see [26] for a comprehensive treatment of computational complexity issues in abstract argumentation):

. In particular we will analyze computational properties of GR

∗

∗

(a) Given G = (cid:3)A, R(cid:4) and S ⊆ A decide if S is an extension of GR
with instances (cid:3)G, S(cid:4) (S ⊆ A) accepted if and only if S ∈ EGR

∗
∗ (G).

. Formally this relates to the decision problem verGR

∗

(b) Given G = (cid:3)A, R(cid:4) determine whether its resolution-based grounded extensions are exactly the grounded extension of G.

Formally this relates to the decision problem coinGR,GR

∗ with instances G accepted if and only if EGR(G) = EGR

∗ (G).

(c) Given G = (cid:3)A, R(cid:4) determine whether there is at least one non-empty resolution-based grounded extension of G. For-

mally this relates to the decision problem neGR

∗ with instances G accepted if and only if EGR
(d) Given G = (cid:3)A, R(cid:4) and x ∈ A determine whether x is credulously accepted with respect to EGR

∗ (G) (cid:9)= {∅}.
∗ (G). Formally this relates

to the decision problem caGR

∗ with instances (cid:3)G, x(cid:4) accepted if and only if ∃S ∈ EGR

∗ (G) s.t. x ∈ S.

(e) Given G = (cid:3)A, R(cid:4) and x ∈ A determine whether x is skeptically accepted with respect to EGR
∗ (G) x ∈ S.

∗ with instances (cid:3)G, x(cid:4) accepted if and only if ∀S ∈ EGR

to the decision problem saGR

∗ (G). Formally this relates

We show that the problems (a), (b) and (c) admit polynomial time decision processes, while (d) is np-complete and

(e) conp-complete.

6.1. Polynomial time decidable problems

We need several preliminary lemmata concerning properties of GR. First, any argument attacked by the grounded exten-

sion receives at least one non-mutual attack from it.

Lemma 3. Given an af G = (cid:3)A, R(cid:4) and its grounded extension GE(G), ∀x ∈ (GE(G))+ ∃ y ∈ GE(G) : y → x ∧ x (cid:9)→ y.

Proof. The proof is based on the equality GE(G) =
that the thesis holds for any x ∈ (F i
since ∀ y ∈ F 1
x (cid:9)→ y the thesis obviously holds, otherwise since y ∈ F i+1
(cid:19)
∃ y

(cid:19) → x ∧ x (cid:9)→ y

G (∅))+

(cid:19) ∈ F i

. (cid:2)

F i

. As to the basis step, note that the thesis holds trivially for x ∈ (F 1

G (∅) (Proposition 1) and proceeds by induction on i, showing
G (∅))+
G (∅) : y → x. If
and, by the inductive hypothesis,

with i (cid:4) 1. Then ∃ y ∈ F i+1
G (∅))+

G (∅) it holds that x ∈ (F i

G (∅))+

G (∅) { y}− = ∅. As to the inductive step, consider x ∈ (F i+1

G (∅) : y

(cid:2)∞
i=1

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

801

The following quite technical lemma states that if GE(G) is stable in a set S then the part of GE(G) outside S coincides
with the grounded extension of the af obtained from G by suppressing the arguments in S and those attacked by GE(G) ∩ S.

Lemma 4. Given an af G = (cid:3)A, R(cid:4) and a set S ⊆ A such that stG (GE(G), S), it holds that GE(G) ∩ S C = GE(G↓

S C \(GE(G)∩S)+ ).

G (∅) ∩ S C ) ⊆ GE(G↓

. We will exploit again the property GE(G) =

Proof. First note that the conclusion easily follows if S C = ∅, therefore in the following we assume S C (cid:9)= ∅. To shorten
notation let S (cid:2) S C \ (GE(G) ∩ S)+
G (∅). Let us ﬁrst show by induction
G (∅) ∩ S C ) it holds that {x}− = ∅
on i that for any i (F i
in G and hence in any restriction of G including x. It follows that x ∈ S and x ∈ GE(G↓
S ). Let us now assume inductively
that (F i
G (∅) ∩ S C ) ⊆ GE(G↓
G (∅) ∩ S C ), we show that x is
acceptable with respect to GE(G↓
G (∅), it holds that
G (∅) ∩ S C )+
y ∈ (F i
, which, by the inductive
hypothesis, entails y ∈ (GE(G↓
S ) given the fact that the grounded extension satisﬁes the
reinstatement principle.

G (∅) ∩ S C ) ⊆ GE(G↓
S , namely ∀ y ∈ ({x}− ∩ S) y ∈ (GE(G↓

G (∅) ⊆ GE(G) and since y /∈ (GE(G) ∩ S)+
. It follows that x ∈ GE(G↓

S ). As to the base case, for any argument x in (F 1

S ). Letting x ∈ (F i+1
S ))+

S ) and show that (F i+1

. In fact, since x ∈ F i+1

it follows that y ∈ (F i

S ) in G↓

. Now, F i

(cid:2)∞
i=1

G (∅))+

S ))+

F i

such that y /∈ S, y ∈ (GE(G))+

We have now to prove that GE(G↓

S ) ⊆ (GE(G) ∩ S C ), by showing (again by induction on i) that for any i F i
G↓

(∅) ⊆
(∅) ⊆ GE(G). Preliminarily, we show that ∀x ∈
(GE(G) ∩ S C ), which, given the deﬁnition of S, is obviously equivalent to F i
. In fact y /∈ S implies y ∈ (S C )C ∪ (S C ∩ (GE(G) ∩ S)+) = S ∪ (S C ∩ (GE(G) ∩ S)+).
S, ∀ y ∈ {x}−
We have two possible cases. If y ∈ S then, in particular, y ∈ (S \ GE(G)) since x /∈ (GE(G) ∩ S)+
. Then, since stG (GE(G), S)
hence y ∈ (GE(G))+
it follows y ∈ (GE(G))+
.
in G it must
Turning to the inductive proof, consider for the base case any x ∈ F 1
G↓
be the case that y /∈ S, which, as shown above, entails y ∈ (GE(G))+
. It follows that x is acceptable with respect to GE(G),
hence x ∈ GE(G). Now assume inductively that F i
in G
we can consider two cases: if y ∈ S it must be the case that y ∈ (F i
. Otherwise, y /∈ S which again entails y ∈ (GE(G))+
y ∈ (GE(G))+
acceptable with respect to GE(G), hence x ∈ GE(G), which completes the proof. (cid:2)

(∅) ⊆ GE(G) and consider any x ∈ F i+1
G↓
(∅))+

. If otherwise y ∈ (S C ∩ (GE(G) ∩ S)+) it follows in particular y ∈ (GE(G) ∩ S)+

, as shown above. Summing up, it turns out that x is

(∅): we have that for any y ∈ {x}−

, which, by the inductive hypothesis, entails

(∅). For any y ∈ {x}−

G↓

G↓

G↓

S

S

S

S

S

S

An equality involving the operations of restriction and resolution of an argumentation framework will also be useful.

Lemma 5. Given an af G = (cid:3)A, R(cid:4) and a set S ⊆ A, for any resolution β of G it holds that Gβ ↓S = (G↓S )β .

Proof. Gβ ↓S = (A, R \ β)↓S = (A ∩ S, (R \ β) ∩ (S × S)) = (A ∩ S, (R ∩ (S × S)) \ β) = (G↓S )β . (cid:2)

We can now show that the grounded extension of a “resolved” af Gβ can be “decomposed” into the grounded extension
of the original af G and the grounded extension of the af resulting from applying the same resolution to cut(G) (see
Deﬁnition 8).

Lemma 6. Given an af G = (cid:3)A, R(cid:4), for any resolution β of G it holds that GE(Gβ ) = GE(G) ∪ GE(cut(G)β ).

Proof. The fact that for any resolution β GE(G) ⊆ GE(Gβ ) is proved in [6] in relation with the property of resolution ade-
quacy of GR. Given that GE(Gβ ) is conﬂict-free, it follows that

GE(Gβ ) ∩ ρ

(cid:3)

(cid:4)
GE(G)

= GE(G)

(5)
In the particular case where ρ(GE(G)) = A condition (5) reduces to GE(Gβ ) = GE(G) which is equivalent to the de-
sired conclusion since in this case cut(G) = (cid:3)∅, ∅(cid:4). Therefore we can assume in the following cut(G) (cid:9)= (cid:3)∅, ∅(cid:4). Clearly
GE(G) is stable in ρ(GE(G)) with respect to G, i.e. stG (GE(G), ρ(GE(G))). By Lemma 3 any argument attacked by GE(G)
receives at least one non-mutual attack from GE(G). Since non-mutual attacks are obviously preserved when applying β,
it follows that stGβ (GE(G), ρ(GE(G))), which by (5) is equivalent to stGβ (GE(Gβ ) ∩ ρ(GE(G)), ρ(GE(G))), and by deﬁni-
tion this holds if and only if stGβ (GE(Gβ ), ρ(GE(G))). Then Lemma 4 can be applied, yielding GE(Gβ ) ∩ ρ(GE(G))C =
ρ(GE(G))C \(GE(Gβ )∩ρ(GE(G)))+ ). Considering (5) in the second member, it is easy to see that ρ(GE(G))C \ (GE(Gβ ) ∩
GE(Gβ ↓
ρ(GE(G)))+ = ρ(GE(G))C , yielding GE(Gβ ) ∩ ρ(GE(G))C = GE(Gβ ↓
ρ(GE(G))C ), which by Lemma 5 is equivalent to GE(Gβ ) ∩
ρ(GE(G))C = GE(cut(G)β ). Putting together (5) and this (disjoint) piece we obtain GE(Gβ ) = GE(G) ∪ GE(cut(G)β ). (cid:2)

The decomposition identiﬁed in Lemma 6 can then be applied to the extensions of GR

∗

.

Corollary 1. Given an af G = (cid:3)A, R(cid:4), EGR

∗ (G) = {GE(G) ∪ S | S ∈ EGR

∗ (cut(G))}.

802

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

Proof. Using deﬁnitions and exploiting Lemma 6 at the second equality we have: EGR
∗ (G) = MIN ({GE(Gβ ) | β ∈
F R(G)}) = MIN ({GE(G) ∪ GE(cut(G)β ), β ∈ F R(G)}) = MIN ({GE(G) ∪ GE(cut(G)β ), β ∈ F R(cut(G))}) = {GE(G) ∪
S: S ∈ MIN ({GE(cut(G)β ), β ∈ F R(cut(G))})} = {GE(G) ∪ S | S ∈ EGR

∗ (cut(G))}. (cid:2)

Note in particular that in the case where cut(G) is empty EGR

∗ (G) = {GE(G)} since EGR

∗ ((cid:3)∅, ∅(cid:4)) = {∅} by deﬁnition.

Corollary 2. For any af G = (cid:3)A, R(cid:4), EGR(G) = EGR
that in cut(G)β every argument has at least one attacker.

∗ (G) if and only if cut(G) = (cid:3)∅, ∅(cid:4) or there is a full resolution β of cut(G) such

Proof. From Corollary 1 we have EGR(G) = EGR
∗ (cut(G)) = {∅}, i.e. if and only if either cut(G) = (cid:3)∅, ∅(cid:4) or there
is a full resolution β of cut(G) such that GE(cut(G)β ) = ∅. This entails the conclusion by recalling that GE(G) = ∅ if and
only if F 1

G (∅) = ∅, i.e. if and only if ∀x ∈ A {x}− (cid:9)= ∅. (cid:2)

∗ (G) ⇔ EGR

Corollary 2 provides a condition for coinGR,GR

∗ involving the existence of unattacked arguments in all resolutions of
cut(G). While checking the existence of unattacked arguments is easy, using this condition would impose considering the
whole set F R(cut(G)), whose enumeration would give rise to a combinatorial explosion. Next, we will ﬁrst derive a simpler
to check condition, concerning the case of argumentation frameworks consisting of a single strongly-connected component,
and then exploit this result in the general case. We recall that the strongly-connected component (scc) decomposition of
G = (cid:3)A, R(cid:4) partitions A according to the equivalence classes induced by the relation ρ(x, y) deﬁned over A × A so that
ρ(x, y) holds if and only if x = y or there are directed paths from x to y and from y to x in G. We will denote the set of
strongly-connected components of G as SCCS(G). It is well known that the graph obtained by considering strongly-connected
components as single nodes is acyclic. As a consequence, a partial order ≺ over the scc decomposition {A1, . . . , Ak} is
deﬁned as (Ai ≺ A j) ⇔ (i (cid:9)= j) and ∃x ∈ Ai , y ∈ A j such that there is a directed path from x to y.

To exemplify, in the case of Fig. 1 we have SCCS(G1) = {A1, A2, A3, A4} = {{a}, {b, c, d}, {e}, { f }}, with A1 ≺ A2 ≺ A3 ≺
A4, while in the case of Fig. 2 we have SCCS(G2) = {A1, A2, A3, A4} = {{a, b, c}, {e}, {d}, { f , g, h}} with A1 ≺ A3 ≺ A4 and
A2 ≺ A3 ≺ A4. Considering then Figs. 3 and 4, we have SCCS(cut(G1)) = {A1, A2, A3} = {{c, d}, {e}, { f }}, with A1 ≺ A2 ≺
A3, and SCCS(cut(G2)) = {A1, A2} = {{a, b, c}, { f , g, h}}, with no precedence relation between A1 and A2.

The following lemma states that given an scc S and an argument x ∈ S it is possible to ﬁnd a resolution β of G which
resolves all mutual attacks involving elements of S such that in Gβ all elements of S, with the only possible exception of x,
receive an attack from an element of S itself.

Lemma 7. Given an af G = (cid:3)A, R(cid:4) and an scc S ∈ SCCS(G), for any x ∈ S there is a full resolution β of G↓S such that ∀ y ∈ (S \ {x})
y ∈ S

.

+
Gβ

j=0 L j) for i (cid:4) 0.
Proof. For a generic x ∈ S, deﬁne inductively the following sequence of sets: L0 = {x}, Li+1 = L
Observe that for any y ∈ S ∃i: y ∈ Li . In fact, x ∈ L0 and for any y (cid:9)= x there is a path from x to y, S being an scc. Letting
d be the minimal path length from x to y it is evident that y ∈ Ld. We can now build the full resolution β as follows: for
any mutual attack involving consecutive sets in the sequence insert in β the attack coming from the set with higher index,
(cid:19)(cid:4) ∈ β. Then, resolve arbitrarily any
namely for any {(cid:3) y
other mutual attack. It is evident that for any y (cid:9)= x any path with minimal length from x to y within S is preserved in Gβ ,
hence y ∈ S

(cid:19)(cid:19) ∈ Li+1 for some i, let (cid:3) y

(cid:19)(cid:4)} ⊆ R such that y

(cid:19) ∈ Li , y

(cid:19)(cid:19)(cid:4), (cid:3) y

. (cid:2)

(cid:19)(cid:19), y

(cid:19)(cid:19), y

(cid:19), y

\ (

i

+
Gβ

(cid:2)

+
i

We can now obtain the important result concerning argumentation frameworks consisting of a single scc anticipated

above.

Lemma 8. Given a non-empty af G = (cid:3)A, R(cid:4) such that |SCCS(G)| = 1, the condition (i) for any full resolution β of G ∃x such that
{x}−
Gβ

= ∅ is equivalent to the conjunction (ii) of the following three conditions:

(a) ∀x ∈ A, (cid:3)x, x(cid:4) /∈ R;
(b) R is symmetric, i.e. (cid:3)x, y(cid:4) ∈ R ⇔ (cid:3) y, x(cid:4) ∈ R;
(c) the undirected graph G formed by replacing each (directed) pair {(cid:3)x, y(cid:4), (cid:3) y, x(cid:4)} with a single undirected edge {x, y} is acyclic.

Proof. We ﬁrst prove that (i) implies (ii) by showing that if any of the conditions (a)–(c) is violated then (i) is violated too.
If (a) does not hold we can apply Lemma 7 to x such that (cid:3)x, x(cid:4) ∈ R and derive the existence of a full resolution β such that
∀ y (cid:9)= x { y}−
⊇ {x}, thus denying (i). If either (b) or (c) is violated there is a cycle consisting of at least three
Gβ
distinct elements in G. In fact, if R is not symmetric, for any (cid:3)x, y(cid:4) ∈ R such that (cid:3) y, x(cid:4) /∈ R there must be a path from
y to x involving at least another distinct argument z, while if the undirected graph contains a cycle it involves necessarily
at least three elements. Now it is easy to build a (possibly empty) resolution β(cid:19)
resolving only the mutual attacks, if any,

(cid:9)= ∅ while {x}−
Gβ

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

803

involving elements of the cycle and preserving the existence of such a cycle in Gβ(cid:19) . Therefore Gβ(cid:19) still consists of exactly one
scc. Consider now any argument x in the cycle: clearly {x}−
(cid:9)= ∅ and this condition will still hold for any argumentation
G
β(cid:19)
framework arising from a full resolution of Gβ(cid:19) . But we can apply now Lemma 7 to x and derive the existence of a full
resolution β(cid:19)(cid:19)
of Gβ(cid:19) such that ∀ y (cid:9)= x { y}− (cid:9)= ∅. Summing up we have obtained a full resolution β = β(cid:19) ∪ β(cid:19)(cid:19)
of G such that
∀x {x}−
(cid:9)= ∅.
Gβ

Turning to the other direction of the proof, it is easy to see that the conclusion is veriﬁed in case |A| = 1. Otherwise,
we will now show that the conjunction of (a), (b) and (c) implies (i), by trying to build a full resolution β such that
∀x ∈ A {x}− (cid:9)= ∅ in Gβ and showing that this is impossible. Since (c) holds, the undirected graph G obtained from G is
a tree. Let r be the tree root and for any y (cid:9)= r denote as d( y) the length of the unique (simple) path from r to y. Let
m = max y∈A\{r} d( y): for any y such that d( y) = m it is clearly the case that y is directly connected in G with exactly
one element z such that d(z) = m − 1. This entails that y can only attack or be attacked by z in G, and, by (b), actually
both cases hold, i.e. {(cid:3) y, z(cid:4), (cid:3)z, y(cid:4)} ⊆ R. Then necessarily (cid:3) y, z(cid:4) ∈ β, otherwise y, not being self-defeating by (a), would be
unattacked in Gβ . This entails that for any z such that d(z) = m − 1, z does not receive attacks in Gβ from any argument
y such that d( y) = m. But now we can iterate the same reasoning on any argument z such that d(z) = m − 1 showing that
there is exactly one w such that d(w) = m − 2, {(cid:3)z, w(cid:4), (cid:3)w, z(cid:4)} ⊆ R and necessarily (cid:3)z, w(cid:4) ∈ β. Iterating the same reasoning
we reach the arguments x such that d(x) = 1 and {(cid:3)x, r(cid:4), (cid:3)r, x(cid:4)} ⊆ R. For any such argument x it must be the case that
(cid:3)x, r(cid:4) ∈ β (otherwise x would be unattacked in Gβ ) but then r is unattacked in Gβ , showing that the construction of the
desired β is impossible. (cid:2)

Lemma 8 has provided three simple topological conditions which, on the basis of Corollary 2, allow to check the condi-
tion EGR(G) = EGR
∗ (G) (while avoiding the enumeration of full resolutions) when |SCCS(G)| = 1. To extend this result to a
generic G we need to focus our attention on the strongly-connected components which are minimal with respect to ≺ (i.e.
do not receive attacks from other strongly-connected components) and satisfy conditions (a)–(c) of Lemma 8.

Deﬁnition 22. Given a non-empty af G = (cid:3)A, R(cid:4), S ∈ SCCS(G) is minimal relevant if S is a minimal element of ≺ and G↓S
satisﬁes conditions (a)–(c) stated in Lemma 8. The set of the minimal relevant sccs of G is denoted as MR(G).

Let us exemplify this notion on the usual examples of Figs. 1–4. It is relatively easy to see that MR(G1) = {{a}},

MR(G2) = {{e}}, MR(cut(G1)) = {{c, d}}, and MR(cut(G2)) = {{ f , g, h}}.

The following theorem achieves the desired generalization by showing that verifying the coincidence between GR and
∗
for an af G is equivalent to checking whether cut(G) has some minimal relevant component.

GR

Theorem 1. Given an af G = (cid:3)A, R(cid:4), EGR(G) = EGR

∗ (G) if and only if cut(G) = (cid:3)∅, ∅(cid:4) or MR(cut(G)) = ∅.

Proof. Suppose ﬁrst EGR(G) = EGR
∗ (G). By Corollary 2, either cut(G) = (cid:3)∅, ∅(cid:4) or there is a full resolution β of cut(G) such
that in cut(G)β every argument has at least one attacker. Let S be any scc of cut(G) minimal with respect to ≺. Clearly
there is a full resolution βS of cut(G)↓S (βS = β ∩ (S × S)) such that every element of S has at least one attacker in
(cut(G)↓S )βS and therefore cut(G)↓S does not satisfy conditions (a)–(c) of Lemma 8. It follows MR(cut(G)) = ∅.

Turning to the other direction of the proof, by Corollary 2 if cut(G) is empty the conclusion follows directly, otherwise it
is suﬃcient to show that there is a full resolution β of cut(G) such that in cut(G)β every argument has at least one attacker.
To build such a β, consider ﬁrst any scc of cut(G) minimal with respect to ≺. Given the hypothesis MR(cut(G)) = ∅, by
Lemma 8 there is a full resolution βS of cut(G)↓S such that every element of S has at least one attacker in (cut(G)↓S )βS .
Turning now to the sccs of cut(G) which are not minimal with respect to ≺, we can proceed following the (partial) order
induced by ≺. In fact, for any such scc S
we can assume inductively that there is a full resolution β such that for every scc
S ≺ S
. Note
(cid:19)
which receives at least an attack from an element y of a scc S such that S ≺ S
ﬁrst that there must be an element x of S
would not be distinct sccs), hence for any resolution β
and that any such attack must be non-mutual (otherwise S and S
(cid:3) y, x(cid:4) /∈ β. Now, by Lemma 7 we can deﬁne a resolution β(cid:19) ⊆ (S
has at least an
attacker, while, as shown above, x has at least an attacker in any resolution. Summing up, we have shown a procedure to
incrementally build a full resolution β of cut(G) such that any element of cut(G) has at least an attacker in cut(G)β , as
desired. (cid:2)

every element of S has at least one attacker in cut(G)β and we need to show that the same holds also for S

(cid:19)) such that any argument z (cid:9)= x in S

(cid:19)
(cid:19) × S

(cid:19)

(cid:19)

(cid:19)

(cid:19)

(cid:19)

Polynomial complexity results for coinGR,GR

∗ and neGR

∗ follow directly from Theorem 1.

Corollary 3. coinGR,GR

∗ ∈ p.

Proof. By Theorem 1, to check EGR(G) = EGR
∗ (G) do the following steps: (i) compute GE(G); (ii) compute cut(G) and if it
is empty return true; (iii) compute the scc decomposition of cut(G); (iv) identify those sccs of cut(G) which are minimal
with respect to ≺; (v) on each of them check conditions (a)–(c) of Lemma 8. Each of these steps is known (or easily seen)
to belong to p. (cid:2)

804

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

Corollary 4. neGR

∗ ∈ p.

Proof. By Corollary 1, EGR
known to belong to p [26], and then (possibly) coinGR,GR

∗ (G) = {∅} ⇔ GE(G) = ∅ ∧ EGR(G) = EGR

∗ , which belongs to p by Corollary 3. (cid:2)

∗ (G), thus neGR

∗ reduces to checking ﬁrst neGR, which is

We now turn to the problem verGR

∗

and GR

in relation with minimal relevant components.

∗ . Preliminarily, we have to identify some quite technical but useful properties of GR

Lemma 9. Given an argumentation framework G = (cid:3)A, R(cid:4) such that cut(G) (cid:9)= (cid:3)∅, ∅(cid:4) and MR(cut(G)) (cid:9)= ∅, letting ΠG =
(cid:2)
V ∈MR(cut(G)) V it holds that (i) for any full resolution β of cut(G) GE(cut(G)β ↓ΠG ) ∈ EST (cut(G)β ↓ΠG ) (i.e. GE(cut(G)β ↓ΠG )
∗ (cut(G)↓ΠG ) = EST (cut(G)↓ΠG ).

is a stable extension of cut(G)β ↓ΠG ) and (ii) EGR

Proof. Recall ﬁrst that a stable extension of an af G = (cid:3)A, R(cid:4) is a conﬂict-free set T ⊆ A such that ∀x ∈ (A \ T ) T → x. As
for (ii), we show that {GE((cut(G)↓ΠG )γ ) | γ ∈ F R(cut(G)↓ΠG )} = EST (cut(G)↓ΠG ), and, since no stable extension can be
a proper subset of another one, this set turns out to be equal to EGR
∗ (cut(G)↓ΠG ). Condition (i) will arise as an intermediate
result.

To show {GE((cut(G)↓ΠG )γ ) | γ ∈ F R(cut(G)↓ΠG )} ⊆ EST (cut(G)↓ΠG ) we observe ﬁrst that, by the deﬁnition of mini-
mal relevant components, (cut(G)↓ΠG )γ is acyclic. In fact, it does not contain self-defeating arguments, any cycle of length 2
in cut(G)↓ΠG is resolved by γ and no cycles of length > 2 can be present. It is well known [18] that in an acyclic
argumentation framework the grounded extension is also a stable extension, thus GE((cut(G)↓ΠG )γ ) is a stable exten-
sion of (cut(G)↓ΠG )γ ((i) can thus be proved taking into account Lemma 5 and the fact that for any β ∈ F R(cut(G))
β ∩ (ΠG × ΠG ) ∈ F R(cut(G)↓ΠG )) and we can observe further that GE((cut(G)↓ΠG )γ ) is also a stable extension of
cut(G)↓ΠG since in cut(G)↓ΠG it clearly preserves both the properties of being conﬂict-free and of attacking all other
arguments.

To show that EST (cut(G)↓ΠG ) ⊆ {GE((cut(G)↓ΠG )γ ) | γ ∈ F R(cut(G)↓ΠG )}, for any stable extension T of cut(G)↓ΠG
we have to build a full resolution γ of cut(G)↓ΠG such that T = GE((cut(G)↓ΠG )γ ). To obtain such a γ , note that, by the
symmetry condition of minimal relevant components, for any x in T either x is unattacked or is involved in mutual attacks
with some other elements y of ΠG and we can include in γ all the pairs of the form (cid:3) y, x(cid:4). It turns out that any element
of T is unattacked in (cut(G)↓ΠG )γ , and, T being a stable extension, that any element y /∈ T is attacked by T . If follows
that T = F 1

(∅) for any i (cid:4) 1 and hence T = GE((cut(G)↓ΠG )γ ). (cid:2)

(∅) = F i

(cut(G)↓ΠG )γ

(cut(G)↓ΠG )γ

The following theorem provides a characterization of the extensions of GR

∗

in terms of three (still quite technical)

conditions.

Theorem 2. Given an argumentation framework G = (cid:3)A, R(cid:4) such that cut(G) (cid:9)= (cid:3)∅, ∅(cid:4) (i.e. ρ(GE(G)) (cid:3) A) and MR(cut(G)) (cid:9)= ∅,
letting ΠG =

∗ (G) if and only if the following conditions hold:

V ∈MR(cut(G)) V and T (cid:2) U \ ρ(GE(G)), U ∈ EGR

(cid:2)

(a) U ∩ ρ(GE(G)) = GE(G);
(b) stcut(G)(T , ΠG );
(c) (T ∩ Π C

G ) ∈ EGR

∗ (cut(G)↓

G \(T ∩ΠG )+ ).
Π C

∗

Proof. As to the ﬁrst direction of the proof, assume U ∈ EGR
tion (b), note ﬁrst that (again from Corollary 1) T ∈ EGR
components, an externally unattacked set of cut(G). By directionality of GR
and condition (b) follows from Lemma 9, which entails (T ∩ ΠG ) ∈ EST (cut(G)↓ΠG ).

∗ (G). Condition (a) follows directly from Corollary 1. As to condi-
∗ (cut(G)) and observe that ΠG is, by deﬁnition of minimal relevant
∗ (cut(G)↓ΠG ),

it follows that (T ∩ ΠG ) ∈ EGR

G = GE((cut(G)↓

Turning to condition (c), note ﬁrst that since T ∈ EGR

∗ (cut(G)), there exists a full resolution β of cut(G) such that
T = GE(cut(G)β ). By directionality of GR we have that T ∩ ΠG = GE(cut(G)β ↓ΠG ), while from Lemma 9 GE(cut(G)β ↓ΠG ) is
a stable extension of cut(G)β ↓ΠG , hence stcut(G)β ((T ∩ ΠG ), ΠG ). Since this entails by deﬁnition stcut(G)β (T , ΠG ), recalling
T = GE(cut(G)β ) we can then apply Lemma 4 to obtain T ∩ Π C
G \(T ∩ΠG )+ )β )
Π C
G \ (T ∩ ΠG )+)) it turns out that
where Lemma 5 is exploited for the second equality. Letting β∗ = β ∩ ((Π C
T ∩ Π C
G \(T ∩ΠG )+ , and to prove condition (c) we need
Π C
to show that there is no full resolution γ of cut(G)↓
G ). We
will show that assuming that such a full resolution γ exists leads to a contradiction. Let us start by observing that since
ΠG ∈ U S(cut(G)), it holds also that ΠG ∈ U S(cut(G)β ) and then, by directionality of GR, T ∩ ΠG = GE(cut(G)β ↓ΠG ).
Consider now a full resolution β(cid:19)
of cut(G) such that β(cid:19) ⊇ (β ∩ (ΠG × ΠG )) ∪ γ : β(cid:19)
can be easily constructed since
(β ∩ (ΠG × ΠG )) resolves all mutual attacks within ΠG , γ resolves all mutual attacks within Π C
, and
any other mutual attack can be resolved arbitrarily without affecting the line of the proof. Since β(cid:19) ∩ (ΠG × ΠG ) =
β ∩ (ΠG × ΠG ), we have then T ∩ ΠG = GE(cut(G)β(cid:19) ↓ΠG ) and since ΠG ∈ U S(cut(G)β(cid:19) ), by directionality of GR we

G \(T ∩ΠG )+ ) = GE((cut(G)↓
Π C
G \ (T ∩ ΠG )+) × (Π C

G \(T ∩ΠG )+ such that V (cid:2) GE((cut(G)↓
Π C

being a full resolution of cut(G)↓

G \(T ∩ΠG )+ )γ ) (cid:3) (T ∩ Π C
Π C

G \(T ∩ΠG )+ )β∗ ), β∗
Π C

G = GE(cut(G)β ↓

G \ (T ∩ ΠG )+

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

805

G \(T ∩ΠG )+ )β(cid:19) ), which is equal to GE(cut(G)β(cid:19) ↓
Π C

have GE(cut(G)β(cid:19) ↓ΠG ) = GE(cut(G)β(cid:19) ) ∩ ΠG , obtaining (i) T ∩ ΠG = GE(cut(G)β(cid:19) ) ∩ ΠG . Moreover, by deﬁnition of β(cid:19)
,
V = GE((cut(G)↓
G \(T ∩ΠG )+ ) by Lemma 5. Thus, we obtain (ii) V =
Π C
G \(T ∩ΠG )+ ). We now apply the directionality of GR to ΠG , obtaining GE(cut(G)β(cid:19) ) ∩ ΠG = GE(cut(G)β(cid:19) ↓ΠG ).
GE(cut(G)β(cid:19) ↓
Π C
By Lemma 9 GE(cut(G)β(cid:19) ) ∩ ΠG is a stable extension of cut(G)β(cid:19) ↓ΠG . From Lemma 4 we then have GE(cut(G)β(cid:19) ) ∩ Π C
G =
GE(cut(G)β(cid:19) ↓
G \(GE(cut(G)β(cid:19) )∩ΠG )+ ), which by (i) is equal to GE(cut(G)β(cid:19) ↓
G \(T ∩ΠG )+ ). Taking into account (ii) we then
Π C
Π C
G . Summing up the last equality and (i) we have V ∪ (T ∩ ΠG ) = GE(cut(G)β(cid:19) ). Now V ⊆ Π C
obtain V = GE(cut(G)β(cid:19) ) ∩ Π C
G
G ), therefore it must be the case that (V ∪ (T ∩ ΠG )) (cid:3) T . But then we have
and, by the absurd hypothesis, V (cid:3) (T ∩ Π C
GE(cut(G)β(cid:19) ) (cid:3) T , which contradicts the hypothesis T ∈ EGR

∗ (cut(G)).
We can now turn to the other direction of the proof, by assuming that conditions (a)–(c) hold. By Corollary 1 and
∗ (cut(G)). To this aim, we ﬁrst build a full

condition (a), to prove the thesis U ∈ EGR
resolution β of cut(G) such that T = GE(cut(G)β ), then we prove that (cid:2)γ ∈ F R(cut(G)) such that GE(cut(G)γ ) (cid:3) T .

∗ (G) it is suﬃcient to show that T ∈ EGR

full resolution of G such that (T ∩ Π C

and any mutual attack not resolved by β(cid:19) ∪ β(cid:19)(cid:19)

∗ ) (cid:3) (T ∩ ΠG ). Letting for conciseness G = cut(G)↓

Considering the ﬁrst part, from condition (b) and Lemma 9 it follows that (T ∩ ΠG ) ∈ EGR
full resolution of cut(G)↓ΠG such that (T ∩ ΠG ) = GE((cut(G)↓ΠG )β(cid:19) ) and (ii) (cid:2)β(cid:19)

∗ (cut(G)↓ΠG ) which implies
that (i) ∃β(cid:19)
∗ full resolution of cut(G)↓ΠG
such that GE((cut(G)↓ΠG )β(cid:19)
G \(T ∩ΠG )+ , from condition (c) we have
Π C
(iii) ∃β(cid:19)(cid:19)
) (cid:3) (T ∩ Π C
G ).
G \ (T ∩ ΠG )+)) =
We can now build a full resolution β of cut(G) such that: β ∩ (ΠG × ΠG ) = β(cid:19)
β(cid:19)(cid:19)
is resolved arbitrarily. From (i) and (iii), applying also Lemma 5
we then obtain respectively (v) (T ∩ ΠG ) = GE(cut(G)β ↓ΠG ) and (vi) (T ∩ Π C
G ) = GE(cut(G)β ↓
G \(T ∩ΠG )+ ). Now from
Π C
Lemma 9 GE(cut(G)β ↓ΠG ) is a stable extension of cut(G)β ↓ΠG , and by the directionality of the grounded semantics
GE(cut(G)β ↓ΠG ) = GE(cut(G)β ) ∩ ΠG . Therefore, it holds that stcut(G)β (GE(cut(G)β ), ΠG ), and by Lemma 4 we have
GE(cut(G)β ) ∩ Π C
G \(GE(cut(G)β )∩ΠG )+ ). Using (v) and directionality of GR the latter can be expressed
Π C
as GE(cut(G)β ↓
G (just obtained) and
(T ∩ ΠG ) = GE(cut(G)β ) ∩ ΠG (obtained from (v) by the directionality of GR) we ﬁnally obtain T = GE(cut(G)β ).

G = GE(cut(G)β ↓
G \(T ∩ΠG )+ ), which by (vi) is equal to T ∩ Π C
Π C

∗ full resolution of G such that GE(G
G \ (T ∩ ΠG )+) × (Π C

G ) = GE(cut(G)β ) ∩ Π C

β(cid:19)(cid:19) ) and (iv) (cid:2)β(cid:19)(cid:19)

G . From (T ∩ Π C

Let us turn now to the second part: we have to show that (cid:2)γ ∈ F R(cut(G)) such that GE(cut(G)γ ) (cid:3) T .
Suppose by contradiction that such a full resolution γ exists. From directionality of GR and Lemma 5 we have
(vii) GE(cut(G)γ ) ∩ ΠG = GE(cut(G)γ ↓ΠG ) = GE((cut(G)↓ΠG )γ ). By Lemma 9 and the directionality of GR it holds that
GE(cut(G)γ ) is stable in ΠG , hence by Lemma 4 we obtain (viii) GE(cut(G)γ ) ∩ Π C
G \(GE(cut(G)γ )∩ΠG )+ ) =
Π C
GE((cut(G)↓
G \(GE(cut(G)γ )∩ΠG )+ )γ ), using Lemma 5 for the second equality. Referring now to the absurd hypothe-
Π C
sis GE(cut(G)γ ) (cid:3) T it must be the case that GE(cut(G)γ ) ∩ ΠG (cid:3) T ∩ ΠG or GE(cut(G)γ ) ∩ Π C
G ). We
show that both are impossible. If GE(cut(G)γ ) ∩ ΠG (cid:3) T ∩ ΠG , from (vii) we obtain GE((cut(G)↓ΠG )γ ) (cid:3) (T ∩ ΠG )
which contradicts (ii) putting β(cid:19)
∗ = γ ∩ (ΠG × ΠG ). Therefore we can assume GE(cut(G)γ ) ∩ ΠG = T ∩ ΠG , and
from (viii) we get GE(cut(G)γ ) ∩ Π C
G ) we have
GE((cut(G)↓
G \(T ∩ΠG )+ )γ ) (cid:3) (T ∩ Π C
Π C

G = GE((cut(G)↓
G \(T ∩ΠG )+ )γ ). Then,
Π C
G ), which analogously contradicts (iv). (cid:2)

if GE(cut(G)γ ) ∩ Π C

G = GE(cut(G)γ ↓

G (cid:3) (T ∩ Π C

G (cid:3) (T ∩ Π C

G ) = GE(G

, β ∩ ((Π C

β(cid:19)(cid:19)
∗

We are now in a position to prove the polynomial complexity of verGR

∗ .

Theorem 3. verGR

∗ ∈ p.

Proof. The proof refers to the recursive Algorithm 1. As to its correctness, we can distinguish several cases. If G is empty
then we get S = ∅ at line 2 (and therefore T = U at line 6), moreover the condition at line 7 is obviously satisﬁed: then
Algorithm 1 terminates returning true if U is empty too (line 9) or returning false if U is non-empty (line 11), which
is the correct behavior in either case. If G is not empty but cut(G) is empty or MR(cut(G)) = ∅ then we know that
EGR
∗ (G) = EGR(G) = {GE(G)} from Theorem 1, therefore in this case we have to check that Algorithm 1 returns true if and
only if U = GE(G). Note ﬁrst that the algorithm returns false at line 4 if U ∩ ρ(GE(G)) (cid:9)= GE(G), otherwise the algorithm
proceeds by letting T be the set difference between U and GE(G) (line 6). By assumption the condition at line 7 is satisﬁed
and Algorithm 1 terminates returning true if the above mentioned set difference is empty or returning false if it is not.
Summing up, in the considered case Algorithm 1 returns true if and only if U ∩ ρ(GE(G)) = GE(G) and U \ GE(G) = ∅
which is clearly equivalent to the desired condition U = GE(G). In the other cases Algorithm 1 is easily seen to correspond
to checking whether conditions of Theorem 2 hold: lines 3–4 for condition (a), lines 16–17 for condition (b), line 19 for
condition (c).

As to complexity, ﬁrst note that every step of Algorithm 1 is in p. In particular, it is well known that computing GE(G)
is in p, as it clearly is also computing ρ(S). Computing the minimal relevant components of G is a task we have already
commented to be in p in Corollary 3. Verifying whether a set is stable in another one and identifying the arguments attacked
by a set is linear in the number of attack relations, while all other operations (e.g. those involved in computing cut(G),
cut(G)↓
W C \(T ∩W )+ and (T ∩ W C )) only require basic set manipulations. It remains to be seen that the recursion is well-
founded and terminates after a polynomial number of calls. To this purpose it is suﬃcient to observe that at each recursive

806

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

-ver(G = (cid:3)A, R(cid:4), U ) returns boolean

∗ (G = (cid:3)A, R(cid:4))

∗

if T = ∅ then
return true

Algorithm 1 Verifying that U ∈ EGR
1: procedure GR
2: S := GE(G)
3: if (U ∩ ρ(S) (cid:9)= S) then
4:
return false
5: end if
6: T := U \ S
7: if cut(G) = (cid:3)∅, ∅(cid:4) or MR(cut(G)) = ∅ then
8:
9:
10:
11:
12:
13: else
14: W := ΠG
15: end if
16: if ¬stcut(G)(T , W ) then
17:
18: else
19:
20: end if
21: end

-ver(cut(G)↓

∗
return GR

return false

return false

end if

else

W C \(T ∩W )+ , (T ∩ W C ))

A

∗

∗ (G)

-comp-ext(G) returns E ⊆ 2

Algorithm 2 Producing EGR
1: procedure GR
2: S := GE(G)
3: if cut(G) = (cid:3)∅, ∅(cid:4) or MR(cut(G)) = ∅ then
4: W := ∅
5: else
6: W := ΠG
7: end if
8: if W = ∅ then
return {S}
9:
10: end if
11: E := ∅
12: for each T ∈ MCF (G↓W ) do
13: H := GR
-comp-ext(cut(G)↓
14:
15:
16:
17: end for
18: return E

∗
for each R ∈ H do

E = E ∪ {S ∪ T ∪ R}

W C \(T ∩W )+ )

end for

call an argumentation framework with a strictly lesser number of arguments is considered, since at least the elements
of W (which is not empty, otherwise the condition at line 7 would be satisﬁed and the procedure would terminate) are
suppressed. Moreover the procedure clearly terminates without further recursive calls if invoked on (cid:3)∅, ∅(cid:4). It follows that
the procedure terminates after a number of calls which is linear in the number of arguments. (cid:2)

Let us exemplify an execution of Algorithm 1 with arguments G = G1 (Fig. 1) and U = {a, d, f }. Line 2 gives S = {a}, and
it follows U ∩ ρ(S) = {a, d, f } ∩ {a, b} = {a} = S. Then the condition of the if statement of line 3 is false, we get T = {d, f }
at line 6, and, recalling cut(G1) shown in Fig. 3, we note that the condition of the if statement of line 7 is false too.
We then obtain W = {{c, d}} at line 14 and since T is stable in W the condition at line 16 is false and we enter the
else branch at line 19. Here we note that W C = {e, f } and (T ∩ W )+ = {c, e} yielding arguments (cid:3){ f }, ∅(cid:4) and { f } for the
recursive invocation of the procedure. At line 3 we have then S = { f } and, since it follows that cut(G) = (cid:3)∅, ∅(cid:4) and T = ∅
∗ (G1).
the algorithm returns true at line 9. In fact, {a, d, f } ∈ EGR

Consider instead an execution of Algorithm 1 with arguments G = G2 (Fig. 2) and U = {a, e, g}. Line 2 gives S = {e},
and, skipping easy observations, we obtain W = {{ f , g, h}} at line 14 and we are led to a recursive invocation with argu-
ments (cid:3){a, b, c}, {(a, b), (b, a), (b, c), (c, b), (a, c), (c, a)}(cid:4) and {a}. Now we obtain S = ∅ at line 2, T = {a} at line 6, and since
MR(cut(G)) = ∅ the condition of the if statement of line 7 is satisﬁed and the algorithm returns false at line 11. In fact,
{a, e, g} /∈ EGR

∗ (G2).

6.2. A side result: an algorithm to compute EGR

∗ (G)

Algorithm 1 provides the basis to devise the non-naive Algorithm 2 to compute the set of GR

extensions of an af G.
Algorithm 2 relies on the property that the attack relation of the restricted argumentation framework G↓W consisting of
minimal relevant components is symmetric by deﬁnition and on the well-known fact [16] that in a symmetric argumenta-
tion framework G stable extensions coincide with maximal conﬂict-free sets, namely EST (G) = MCF (G).

∗

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

807

Given this observation, it is easy to see that any set produced by Algorithm 2 produces true as return value if given
in input to Algorithm 1 and conversely that any set yielding true in Algorithm 1 is included in the result produced by
Algorithm 2.

6.3. Intractable decision problems

Turning to the credulous and skeptical acceptance problems, in contrast to the polynomial time methods identiﬁed in

Section 6.1 we have the following result.

Theorem 4.

(a) caGR
(b) saGR

∗ is np-complete.
∗ is conp-complete.

Proof. For part (a), that caGR
A: (x ∈ T ) ∧ verGR

∗ (G, T ). By virtue of Theorem 3 this yields an np algorithm.

∗ ∈ np follows by observing that any instance (cid:3)G(A, R), x(cid:4) can be decided by checking ∃T ⊆

For np-hardness we use a reduction (analogous to the one introduced in [17]) from 3-sat, the problem of deciding if a
propositional formula, ϕ(Zn), in conjunctive normal form (cnf) with at most three literals in each clause, has an assignment
to its variables, Zn, for which at least one literal in every clause takes the value (cid:24), i.e. a satisfying assignment.
Given an instance ϕ(Zn) of 3-sat with clauses {C1, C2, . . . , Cm} form the instance (cid:3)G(Aϕ, Rϕ), ϕ(cid:4) of caGR

∗ in which,

Aϕ = {ϕ} ∪ {C j: 1 (cid:5) j (cid:5) m} ∪ {zi, ¬zi: 1 (cid:5) i (cid:5) n}
Rϕ =

(cid:3)zi, C j(cid:4): zi occurs in C j

∪

(cid:6)

(cid:6)

(cid:7)

(cid:3)C j, ϕ(cid:4): 1 (cid:5) j (cid:5) m
(cid:6)
∪

(cid:3)zi, ¬zi(cid:4), (cid:3)¬zi, zi(cid:4): 1 (cid:5) i (cid:5) n

(cid:7)

(cid:7)

(cid:6)

∪

(cid:3)¬zi, C j(cid:4): ¬zi occurs in C j

(cid:7)

We claim that there is some T ∈ EGR

∗ (G) for which ϕ ∈ T if and only if there is a satisfying instantiation of ϕ(Zn).

i (cid:5) n} every full resolution of these yields a distinct set in EGR

It is easily seen that EGR(G) = {∅}. Furthermore, noting that MG contains exactly the set of pairs {(cid:3)zi, ¬zi(cid:4), (cid:3)¬zi, zi(cid:4): 1 (cid:5)
∗ (G).
Suppose ﬁrst that α = (cid:3)α1, α2, . . . , αn(cid:4) describes a satisfying assignment for ϕ(Zn) and consider the full resolution γ (α)

given by

(cid:3)zi, ¬zi(cid:4) ∈ γ (α) ⇔ αi = ⊥

The grounded extension of the af Gγ (α) = (cid:3)Aϕ, Rϕ \ γ (α)(cid:4) contains exactly the arguments {zi: αi = (cid:24)} ∪ {¬zi: αi = ⊥} ∪
{ϕ}: each of the literal arguments (i.e. the yi ∈ {zi, ¬zi} selected) has { yi}− = ∅. Furthermore, since α satisﬁes ϕ, each
clause argument C j attacking ϕ must be attacked by at least one of these literal arguments. It remains only to note that the
resulting subset is minimal with respect to the grounded extensions resulting from full resolutions of G.

On the other hand suppose that γ ⊂ MG deﬁnes a full resolution for which ϕ is in the grounded extension, T , of
Gγ = (cid:3)Aϕ, Rϕ \ γ (cid:4). From ϕ ∈ T , it follows that C j /∈ T for any 1 (cid:5) j (cid:5) m, and thus (at least) one literal y j ∈ {zi, ¬zi} among
the literals deﬁning C j must belong to T . It follows that for each clause, C j = y j,1 ∨ y j,2 ∨ y j,3, γ must contain at least
one of the attacks (cid:3)¬ y j,k, y j,k(cid:4) in order for y j,k ∈ T to hold. Now deﬁning the instantiation (cid:3)αγ
n (cid:4) of Zn via
αγ

2 , . . . , αγ

1 , αγ

∗ (G(A, R), x) by a conp method, simply involves verifying for every T ⊆ A that

i

= (cid:24) ⇔ (cid:3)¬zi, zi(cid:4) ∈ γ yields a satisfying assignment of ϕ(Zn) as required.
For part (b), to decide saGR
∗ (G) ⇒ x ∈ T

T ∈ EGR

Again, by virtue of Theorem 3 the required test (for T ∈ EGR

∗ (G)) can be performed in polynomial time.

For conp-hardness, we use a similar construction to that of (a) applied to deciding unsatisﬁability of a 3-cnf ϕ(Zn).
Given ϕ(Zn), let us form the af, G(Aϕ ∪ {ψ}, Rϕ ∪ {(cid:3)ϕ, ψ(cid:4)}), where (cid:3)Aϕ, Rϕ(cid:4) is the af described in (a) and ψ is a new
∗ is given by (cid:3)G, ψ(cid:4). Suppose that ϕ(Zn) is unsatisﬁable. By
argument (whose sole attacker is ϕ). The instance of saGR
similar arguments to those given above it follows that every full resolution γ is such that, Tγ (the grounded extension of
(cid:3)Aϕ ∪ {ψ}, Rϕ \ γ ∪ {(cid:3)ϕ, ψ(cid:4)}(cid:4)) satisﬁes Tγ ∩ {C1, C2, . . . , Cm} (cid:9)= ∅ and, hence, ψ ∈ Tγ as required. Similarly, if it is the case
∗ (G, ϕ), and now by an identical argument to that used in (a) we deduce that
that saGR
ϕ(Zn) must be unsatisﬁable. (cid:2)

∗ (G, ψ), then it must hold that ¬caGR

That the credulous and skeptical acceptance problems with respect to GR

turn out to be intractable is unsurprising: all
of the multiple-status extension semantics that have been proposed within Dung’s frameworks are known be np-hard (or
worse) for credulous acceptance and conp-hard (or worse) for skeptical acceptance [17,22,24]. Of course, one could object to
this complexity comparison on the grounds that resolution-based semantics is deﬁned w.r.t. the set of Dung-style systems
generated from a single framework, i.e. those formed as a result of applying full resolutions of mutual attacks, rather than
just a single given framework. In this regard, a “more suitable” comparative basis would be the semantics deﬁned through

∗

808

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

different translations, τ ((cid:3)A, R(cid:4)) of (cid:3)A, R(cid:4) to such sets of frameworks. A number of proposals of this nature have been
made in the literature to date: for example, Amgoud and Cayrol’s preference-based argumentation frameworks pafs [2],
Bench–Capon’s value-based frameworks vafs [11], and, recently, the weighted frameworks and inconsistency budget approach
of Dunne et al. [25]. In the ﬁrst of these, τ ((cid:3)A, R(cid:4)) is deﬁned as the set of acyclic frameworks resulting by discarding
attacks that fail under a preference ordering of the arguments involved in an attack, i.e. if (the argument) p “is preferred
to” (the argument) q in the attack (cid:3)q, p(cid:4) then the attack (cid:3)q, p(cid:4) is removed from R.6 Deﬁning EPAF((cid:3)A, R(cid:4)) as

(cid:8)

EGR(G)

G∈τ ((cid:3)A,R(cid:4))

the associated “credulous” and “skeptical” decision questions are trivial: every p ∈ A is credulously accepted (simply prefer
p to any argument that attacks it); p ∈ A is skeptically accepted if and only if {p}− = ∅ (if q ∈ {p}−
then p is not preferred
to q in the attack (cid:3)q, p(cid:4) whereas q is preferred to each of its attackers, leading to q being credulously accepted in the
resulting framework – {q}− = ∅ – but with the attack (cid:3)q, p(cid:4) still present).

Bench–Capon’s model, deﬁnes the translation τ ((cid:3)A, R(cid:4)) via (qualitative) “values” associated with arguments so that
failing attacks (cid:3)q, p(cid:4) are rationalized in terms of “the value endorsed by (the argument) p is preferred to the value endorsed
by (the argument) q”.7 Given a ﬁnite value set V so that each x ∈ A is associated with exactly one value, η(x) in V ,8 the
set τ ((cid:3)A, R, V, η(cid:4)) contains

(cid:8)

(cid:9)
A, R \

(cid:6)
(cid:3)p, q(cid:4): η(q) is preferred to η(p) under α

(cid:7)(cid:10)

α: α is a total ordering of V

In [11] it is shown that every framework in τ ((cid:3)A, R, V, η(cid:4)) is acyclic so that the extension semantics for vafs are simply

(cid:3)

(cid:4)
(cid:3)A, R, V, η(cid:4)

=

EVAF

(cid:8)

EGR(G)

G∈τ ((cid:3)A,R,V,η(cid:4))

In contrast to pafs, the credulous and skeptical problems – referred to as subjective and objective acceptance (sba and
oba) – are np-complete and conp-complete [23,12].

Finally the weighted frameworks proposed in [25], augment (cid:3)A, R(cid:4) using a positive real-valued weighting function w :
gives rise to a set of systems τ ((cid:3)A, R, w(cid:4), β)

, with w((cid:3)p, q(cid:4)) interpreted as how “strong” the attack is. Each β ∈ R

+

+
R → R
deﬁned via

(cid:3)

τ

(cid:3)A, R, w(cid:4), β

(cid:4)

=

{T ⊆R:

(cid:11)

(cid:8)

(cid:6)

(cid:7)
(cid:3)A, R \ T (cid:4)

(cid:3)p,q(cid:4)∈T w((cid:3)p,q(cid:4))(cid:3)β}

The structures considered in [25] are the so-called weighted grounded extensions with inconsistency budget β, i.e.

(cid:3)

(cid:4)
(cid:3)A, R, w(cid:4)

=

Eβ-GR

(cid:8)

(cid:6)

(cid:7)
EGR(G)

G∈τ ((cid:3)A,R,w(cid:4),β)

As with vafs and GR

∗

credulous acceptance w.r.t. Eβ-GR is np-complete and skeptical acceptance conp-complete [25].

In summary, credulous and skeptical acceptance with respect to EGR

∗ exhibits similar complexity to multiple-status se-
mantics in both Dung-style argumentation frameworks and the variants of these represented by vafs and weighted systems.

7. Computational properties of GR

∗

in restricted frameworks

In the previous section it was seen that, in general, caGR

∗ are computationally intractable (under the standard
assumption p (cid:9)= np). There are, however, a number of restricted cases in which cas and sas are known to be polynomial
time decidable for particular semantics s. In particular, cas and sas are polynomial time decidable if (cid:3)A, R(cid:4) is acyclic or
symmetric or bipartite (see Deﬁnition 23) for all of the standard multiple-status semantics that have been proposed in Dung
style argument systems [18,16,20]. If, however, we consider the corresponding problems within the “augmented” systems
reviewed at the conclusion of the previous subsection, i.e. vafs and weighted frameworks, these reductions in complexity
do not always result, as shown in Table 1 for credulous acceptance.

∗ and saGR

So for vafs two of the restricted topologies do not yield eﬃcient algorithms9 and the remaining case (symmetric frame-
works) is uninteresting: every argument is subjectively accepted and only those p for which {p}− = ∅ are objectively

6 [2] imposes the condition that preferences between arguments expressed in discarding attacks must be consistent with a preorder of A.
7 Focusing on values endorsed by arguments rather than the arguments themselves means that if p and q are associated with identical values then

attacks between these cannot be discounted.

8 |V| may be much smaller than |A| so the mapping is not, in general, bijective.
9 In fact decision problems remain intractable even if (cid:3)A, R(cid:4) is a binary tree [20].

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

809

Table 1
Complexity of credulous acceptance in restricted systems.

Formalism

vaf

Weighted

Acyclic framework

Symmetric framework

Bipartite framework

np-complete
np-complete

Trivial
np-complete

np-complete
Open

accepted.10 Similarly, in weighted frameworks no improvement in complexity results with either acyclic or symmetric sys-
tems. While the case of general bipartite frameworks is open, there are eﬃcient methods known if (cid:3)A, R(cid:4) is both bipartite
and acyclic.

Obviously a question arises about the behavior of GR

∗
∗ (G) = EGR(G) and thus this case is polynomial time decidable for both caGR

it is clear that EGR

∗ and saGR

∗ .

with respect to these restricted frameworks. For acyclic frameworks

For a symmetric framework G, one may ﬁrst note that any strongly-connected component of G cannot receive attacks
from another one (i.e. it is minimal with respect to the ≺ relation). Then, exploiting the results of the previous section, we
can consider the following cases:

• arguments not receiving any attack: they are skeptically (and hence credulously) accepted;
• arguments in strongly-connected components which are not minimal relevant: they are not included in any extension

∗

of GR

;

• arguments receiving attacks in strongly-connected components which are minimal relevant: they are credulously but

not skeptically accepted.

It follows that both caGR

∗ and saGR

∗ are polynomial time decidable for symmetric frameworks.

In the following we focus on the case of bipartite frameworks and show that saGR

∗ is polynomial time decidable also in

this case.

Deﬁnition 23. An af G = (cid:3)A, R(cid:4) is bipartite if ∃X , Y ⊆ A such that A = X ∪ Y , X ∩ Y = ∅ and both X and Y are conﬂict-
free.

Sometimes a bipartite af will be indicated as (cid:3)X , Y, R(cid:4), denoting the argumentation framework G = (cid:3)X ∪ Y, R(cid:4)

where X and Y satisfy the previous deﬁnition.

A sequence of preliminary lemmata is needed.

Lemma 10. Let (cid:3)X , Y, R(cid:4) be a bipartite af and let x be an argument such that x ∈ X . Given an argument z, if there is an even length
path between x and z then z ∈ X , if there is an odd length path between x and z then z ∈ Y .

Proof. Since X is conﬂict-free, any argument a1 which attacks x or is attacked by it belongs to Y . In the same way, any
argument a2 which attacks a1 or is attacked by it belongs to X . Iterating the same step of reasoning, it is easy to see that
any ai with i even belongs to X , any ai with i odd belongs to Y . (cid:2)

Lemma 11. Given an af G = (cid:3)A, R(cid:4) and x ∈ GE(G), either x is initial or there is an even length path u → a0 → a1 → · · · → a2i → x
with u initial.

Proof. The proof is based on the equality GE(G) =
the thesis holds for all arguments of F i
to the inductive step, any argument x ∈ F i+1
and the thesis follows from the inductive hypothesis on the arguments of F i

G (∅) (Proposition 1) and proceeds by induction on i, showing that
G (∅) are initial. As
G (∅) → y,

G (∅) either is initial or ∃ y : y → x. In the latter case it holds that F i

G (∅). As to the basis step, it is easy to see that all arguments of F 1

F i

G (∅). (cid:2)

(cid:2)∞
i=1

Lemma 12. Given an argumentation framework G = (cid:3)A, R(cid:4) such that cut(G) (cid:9)= (cid:3)∅, ∅(cid:4), there are no initial arguments in cut(G).

Proof. We reason by contradiction. If an argument v is initial in cut(G), then ∀ y : y → v y ∈ ρ(GE(G)), and in particular
y ∈ GE(G)+
otherwise v would belong to ρ(GE(G)) and would not be an argument of cut(G). Therefore, v is acceptable
with respect to GE(G) entailing v ∈ GE(G), which contradicts the fact that v is an argument of cut(G). (cid:2)
(cid:2)

Lemma 13. Given a bipartite af G = (cid:3)X , Y, R(cid:4) such that cut(G) (cid:9)= (cid:3)∅, ∅(cid:4) and MR(cut(G)) (cid:9)= ∅, letting ΠG =
it holds that ∃T 1, T 2 ∈ EST (G↓ΠG ) such that T 1 ∩ ΠG = ΠG ∩ X and T 2 ∩ ΠG = ΠG ∩ Y .

V ∈MR(cut(G)) V

Proof. We prove the claim by showing how to construct T 1 and T 2. According to the deﬁnition of minimal relevant com-
ponents, for any V ∈ MR(cut(G)) replacing the direct attacks with undirected edges gives rise to a tree. We can then

10 The notions of subjective and objective acceptance are speciﬁc to vafs.

810

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

select an argument r in V ∩ X as the root: by Lemma 12 such an argument exists, since |V | (cid:4) 2 and any two conﬂicting
arguments belong to X and Y respectively. We include r into T 1, then we consider all of its children in the rooted tree, i.e.
the nodes with depth 1: since X is conﬂict-free, all of them belong to Y , and we include them into T 2. We can proceed
in this way along the tree, including the nodes of even depth into T 1 and the nodes of odd depth into T 2. It is easy to see
that each of the nodes of V is included in either T 1 or T 2. Moreover, given the symmetry of minimal relevant components
all nodes of even depth are attacked by nodes of odd depth, and vice versa. Finally, notice that this process can be applied
to all minimal relevant components, obtaining T 1, T 2 ∈ EST (G↓ΠG ). (cid:2)

The following proposition provides the main result for skeptical acceptance.

Proposition 6. Given a bipartite af G = (cid:3)X , Y, R(cid:4), an argument z is skeptically accepted if and only if z ∈ GE(G).

Proof. The fact that if z ∈ GE(G) then z is skeptically accepted follows from Corollary 1, therefore we have to prove
that if z /∈ GE(G) then z is not skeptically accepted. The conclusion follows from Theorem 1 in case cut(G) = (cid:3)∅, ∅(cid:4) or
MR(cut(G)) = ∅, therefore in the following we consider the case cut(G) (cid:9)= (cid:3)∅, ∅(cid:4) and MR(cut(G)) (cid:9)= ∅. By Lemma 13,
∃T 1, T 2 ∈ EST (G↓ΠG ) such that T 1 ∩ ΠG = ΠG ∩ X and T 2 ∩ ΠG = ΠG ∩ Y . On the basis of Theorem 2 it is easy to see
that, to be skeptically accepted, z must be skeptically accepted both in cut(G)↓
G \(T 2∩ΠG )+ . In
Π C
fact, z /∈ GE(G) by the hypothesis and z /∈ ΠG since in this case by Theorem 2 it should belong both to T 1 and to T 2 which
are instead disjoint. We can then assume inductively that z ∈ GE(cut(G)↓
G \(T 2∩ΠG )+ ).
Π C
We show that the ﬁrst condition entails that there is an even-length path from an argument of T 1 to z, and analogously
that the second condition entails that an even-length path exists from an argument of T 2 to z: since T 1 ⊆ X and T 2 ⊆ Y ,
according to Lemma 10 it should be the case that z ∈ X and z ∈ Y , leading to a contradiction.

G \(T 1∩ΠG )+ ) and z ∈ GE(cut(G)↓
Π C

G \(T 1∩ΠG )+ and in cut(G)↓
Π C

On the basis of Lemma 11, the ﬁrst condition z ∈ GE(cut(G)↓

G \(T 1∩ΠG )+ ) entails that there is an even-length path u →
Π C
a0 → a1 → · · · → a2i → z with u initial in cut(G)↓
G \(T 1∩ΠG )+ (if z is initial we can assume z = u and a path of length 0).
Π C
Now, by Lemma 12 u is not initial in cut(G), therefore ∃ y ∈ ρ(GE(G))C such that y → u. If y ∈ ΠG then y /∈ T 1, otherwise
u ∈ (T 1 ∩ ΠG )+
. If, on
the other hand, y ∈ Π C
G \(T 1∩ΠG )+ . Summing
Π C
up, (T 1 ∩ ΠG ) → y → u, and there is an even-length path from u to z, clearly entailing the desired conclusion.

, therefore since T 1 is stable in ΠG it must be the case that y ∈ (T 1 ∩ ΠG )+

G \ (T 1 ∩ ΠG )+
G then y ∈ (T 1 ∩ ΠG )+

directly follows from the fact that u initial in cut(G)↓

while u ∈ Π C

Finally, the fact that there is an even-length path from (T 2 ∩ ΠG ) to z can be proved in the same way using the second

condition z ∈ GE(cut(G)↓

G \(T 2∩ΠG )+ ). (cid:2)
Π C

Theorem 5. Let sa(2)
GR
nomial time.

∗ denote the problem saGR

∗ restricted to instances which describe bipartite afs. Then sa(2)
GR

∗ is decidable in poly-

Proof. It directly follows from Proposition 6. (cid:2)

We now turn to credulous acceptance. Although – as with the weighted systems of [25] – the exact status of credulous
acceptance in bipartite frameworks w.r.t. single arguments is open, in the case of sets of arguments Theorem 6 suggests this
variant to be intractable.

Theorem 6. Let ca(2){}
instances being accepted if there is some T ∈ EGR
instances with |S| = 2.

GR

∗ denote the problem whose instances are bipartite afs (cid:3)X , Y, R(cid:4) together with a subset S of X ∪ Y , such
∗ ((cid:3)X , Y, R(cid:4)) for which S ⊆ T . The decision problem ca(2){}
∗ is np-complete even for

GR

Proof. Membership in np is immediate via Theorem 3. To establish np-hardness we use a reduction from Monotone 3-sat,
the restricted version of 3-sat in which clauses are constrained to consist entirely of positive literals or entirely of negated
literals, e.g. (x ∨ y ∨ z)(¬x ∨ ¬ y ∨ ¬z) deﬁnes a valid instance of Monotone 3-sat while (¬x ∨ y ∨ z)(x ∨ y ∨ z) fails to do so.
+
} denote the set of clauses comprising only positive
1 , . . . , C
} be the remaining clauses (those deﬁned using only negated literals). Using a construction

Given ϕ(Zn) an instance of Monotone 3-sat let C
¬
r

+ = {C

¬ = {C

¬
1 , . . . , C

+
k

literals and C
similar to Theorem 4, we deﬁne the following bipartite af, (cid:3)Xϕ, Yϕ, Rϕ(cid:4):
(cid:7)

(cid:6)

(cid:7)

(cid:6)

ϕ+

¬
∪
j : 1 (cid:5) j (cid:5) r
Xϕ =
C
(cid:7)
(cid:6)
+
Yϕ = {ϕ¬} ∪
j : 1 (cid:5) j (cid:5) k
C
(cid:7)
(cid:10)
(cid:6)(cid:9)
+
j , ϕ+
: 1 (cid:5) j (cid:5) k
Rϕ =
C
(cid:6)(cid:9)
¬
¬zi, C
j

∪

(cid:10)

: ¬zi occurs in C

∪ {zi: 1 (cid:5) i (cid:5) n}
∪ {¬zi: 1 (cid:5) i (cid:5) n}
(cid:10)
(cid:6)(cid:9)
∪

¬

C

(cid:7)

(cid:6)(cid:9)

(cid:10)

+
j

j , ϕ¬
(cid:7)
∪

¬
j

∪

: 1 (cid:5) j (cid:5) r
(cid:6)
(cid:3)zi, ¬zi(cid:4), (cid:3)¬zi, zi(cid:4): 1 (cid:5) i (cid:5) n

zi, C

: zi occurs in C
(cid:7)

(cid:7)

+
j

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

811

Reasoning in an analogous way as in Theorem 4, it is easy to see that (cid:3)(cid:3)Xϕ, Yϕ, Rϕ(cid:4), {ϕ¬, ϕ+}(cid:4) is accepted as an instance

of ca(2),{}

∗

GR

if and only if ϕ(Zn) is satisﬁable. (cid:2)

On the other hand, in the case of single arguments we have a positive result for a special class of bipartite frameworks.

Deﬁnition 24. An af (cid:3)X , R(cid:4) is tree-like if the undirected graph (cid:3)X , F (cid:4) in which F = {{x, y}: (cid:3)x, y(cid:4) ∈ R or (cid:3) y, x(cid:4) ∈ R} is
acyclic.

In case of tree-like argumentation frameworks all of the extensions prescribed by GR

∗

are stable, and their deﬁnition can

be simpliﬁed by dropping the minimality condition.

Lemma 14. Let G = (cid:3)X , R(cid:4) be a tree-like argumentation framework. Then, EGR(cid:5) (G) = {GE(Gγ ) | γ ∈ F R(G)} ⊆ EST (G).

Proof. Since G is tree-like, ∀γ ∈ F R(G) Gγ is acyclic, and it is known from [18] that in an acyclic graph the grounded
extension is also stable. Therefore {GE(Gγ ) | γ ∈ F R(G)} ⊆ EST (G), and since a stable extension cannot be a proper subset
of another one all of the elements of {GE(Gγ ) | γ ∈ F R(G)} are minimal, i.e. this set is equal to EGR(cid:5) (G). (cid:2)

It is immediate from the following theorem that deciding credulous acceptance in the case of tree-like frameworks can

be done in polynomial time.

Theorem 7. Let G = (cid:3)X , R(cid:4) be a tree-like argumentation framework with grounded extension GE(G). For all z ∈ X

¬caGR

+
∗ (G, z) ⇔ z ∈ GE(G)

Proof. It is obvious from Corollary 1 that the arguments of GE(G) are skeptically (and thus credulously) accepted, while
those attacked by GE(G) are not credulously accepted. The remaining arguments to consider, namely those in cut(G), are
not attacked by GE(G) by deﬁnition, therefore we have to prove that any argument z of cut(G) is credulously accepted.

First, notice that cut(G) is tree-like, therefore the undirected graph obtained as in Deﬁnition 24 is acyclic: without loss
, it is suﬃcient to
of generality, we assume that this graph is connected, i.e. is a tree (otherwise, by directionality of GR
consider the connected subgraph z belongs to). Let us denote as T the corresponding rooted tree where z is assumed as its
root: any argument of cut(G) is then characterized by its depth, i.e. the length of the (undirected) path in T from z to it
(the depth of z is 0). Notice in particular that, given two arguments y and x of cut(G) such that either y → x or x → y,
if the depth of y is even then the depth of x is odd, and vice versa. To prove the desired conclusion, we consider the full
resolution γ of cut(G) where all mutual attacks between two arguments x and y are resolved in favour of the one with
even depth, i.e. if x has even depth then (cid:3) y, x(cid:4) ∈ γ , and we show that GE(Gγ ) is an extension of GR
including z. The fact
that GE(Gγ ) ∈ EGR(cid:5) (G) derives from Lemma 14, from which we also know that it is a stable extension. As to the inclusion
of z, note that, since cut(G) has no initial arguments by Lemma 12, the only initial arguments in Gγ are obtained by attack
suppression, then by construction they have even depth w.r.t. T . As a consequence, by Lemma 11 all elements of GE(Gγ )
have even depth w.r.t. T . Suppose by contradiction that z /∈ GE(Gγ ): since GE(Gγ ) is stable there is y ∈ GE(Gγ ) attacking z,
but then y has odd depth (actually 1) w.r.t. T , which is impossible. (cid:2)

∗

∗

8. Discussion and conclusions

The results provided in this paper can be assessed from several perspectives.
From a principle-oriented perspective, it has been shown that the semantics evaluation criteria introduced in [6] are
, has been introduced. This can be
not incompatible altogether since a novel semantics satisfying all of them, namely GR
regarded as a sort of conﬁrmation of their global coherence, dispelling any doubt possibly raised by the fact that none of
the previous literature semantics was able to comply with all criteria.

∗

From the perspective of investigation on argumentation semantics deﬁnition, the new resolution-based family of seman-
tics (which is parametric with respect to the selection of a “base” argumentation semantics) represents an interesting tool
for further investigation, as it has been shown that all desirable properties except directionality are directly satisﬁed by any
resolution-based semantics, given that the base argumentation semantics satisﬁes very mild conditions. This has provided a
solid starting point to identify a member of this family satisfying directionality too, which turned out to be the one based
on the traditional grounded semantics. Devising general conditions on the base semantics to guarantee the satisfaction of
the directionality property by its resolution-based version appears indeed an interesting open problem.

∗

From a more practical perspective, it has been shown that the principle driven approach to semantics deﬁnition is
satisfactory also from the viewpoint of computational complexity. In fact, we have investigated computational properties
with reference to a standard set of decision problems for abstract argumentation semantics, proving that some of
of GR
them (verGR
∗ ) are in general not, but are shown to be tractable
in some restricted frameworks. Leaving apart the (unique-status) grounded semantics which is known to be computable

∗ ) are tractable while others (caGR

∗ , coinGR,GR

∗ , neGR

∗ , saGR

812

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

∗

with a polynomial algorithm, it is known that the same decision problems are generally intractable for both stable and
preferred semantics (see in particular [17,22,26]) with the only exception of verST ∈ p. In particular caPR, nePR and
caST are np-complete, verPR is conp-complete, saPR is Π p
2 -complete, and saST is dp -complete. We can state therefore
has better complexity properties than the traditional multiple-status semantics ST and PR. With the exception
that GR
of ideal semantics in [21], complexity properties of recently proposed semantics, e.g. semi-stable or prudent, have not been
fully analyzed yet but preliminary non-tractability results exist [26]. Actually, as to our knowledge, no other non-trivial
multiple-status semantics in the literature has been shown, up to now, to admit polynomial time decision processes (in
the general case) for any of the standard decision problems considered here. Taking also into account the comparisons
drawn in Section 6 with extended frameworks, these results qualify GR
as the non-trivial multiple-status semantics with
best computational properties considered in the literature up to now. This suggests that, leaving apart its merits with
respect to principled conceptual requirements, GR
may turn out to be advantageous also from the viewpoint of its practical
application, an issue which deserves further investigation.

∗

∗

Concerning relationships with other approaches, it can be noted that the deﬁnition of resolution-based semantics stands
on two basic points: the resolution of mutual attacks and the minimality requirement. The idea of “resolving” or “sup-
pressing” attacks according to some criterion has been considered in several works in the literature. As already mentioned,
the notion of resolution has been introduced in [28] in the context of hierarchical argumentation, which aims at captur-
ing argumentation over preference information to resolve indecisions corresponding to mutual attacks. Somehow similarly,
preferences [2] and values [11] have been considered as additional information extending the basic Dung’s framework and
giving implicitly rise to the suppression of some attacks (possibly including non-mutual ones). In a less abstract framework
encompassing structured arguments, an ordering over arguments is used in an analogous way to determine which attacks
are successful [31]. Other extensions of Dung’s framework encompass attacks to attacks [29,3,4], which can be regarded as
an explicit form of attack suppression (again, possibly including non-mutual ones) and provide an alternative way to rep-
resent preferences, values, and any other entity affecting attacks, in a formal argumentation setting. While (mutual) attack
suppression is actually present in the deﬁnition of resolution-based semantics, it must be remarked that this semantics is
not conceived to be speciﬁcally applied to contexts where attack suppression (either preference-based, value-based, or of
any other kind) plays a central role. In fact, due to the minimality requirement, the results produced by resolution-based
semantics may be very different from those arising, for instance, from all possible ordering of values in a value-based
framework. A deeper exploration of the relationships between resolution-based semantics and the above mentioned works
represents an interesting direction of future research.

Finally, as a further issue for future work we mention the investigation of other signiﬁcant instances of the resolution-
with respect to other literature

based deﬁnition scheme and the study of skepticism and agreement properties of GR
semantics.

∗

Appendix A. Notation summary

+

Notation
G(A, R)
MG
−
S
S
ρ(S)
IN(G)
cf (S)
MCF (G)
S C
G↓S
Gβ
F R(G)
F RAF(G)
FG
ES (G)
DS
GE(G)
ID(G)
cut(G)
AS(G)
U S(G)
AE S (G, T )
E1 (cid:2)E
∩ E2
E1 (cid:2)E
E2
W
G1 (cid:2) A G2
U R(G, S)
SCCS(G)
MR(G)
ΠG

Comment

+

An argumentation framework (af)
The set of mutual attacks of G
The set of arguments attacking set S
The set of arguments attacked by set S
S ∪ S
: the range of set S
The unattacked arguments in G
The set S is conﬂict-free
The set of maximal conﬂict-free sets of G
The complement of set S
The restriction of G to S
The af arising from applying the partial resolution β to G
The set of full resolutions of G
The set of afs arising from applying the full resolutions of G
The characteristic function of G
The set of extensions prescribed by the semantics S for G
The set of afs where S admits at least one extension
The grounded extension of G
The ideal extension of G
The af obtained by suppressing ρ(GE(G)) from G
The set of the admissible sets of G
The set of externally unattacked sets of G
{(R ∩ T ) | R ∈ ES (G)}
(cid:5)
E1 ⊆
E2∈E2

E1∈E1

E2

(cid:5)

∀E2 ∈ E2 ∃E1 ∈ E1: E1 ⊆ E2
G2 = G1β for some β resolution of G1
(cid:2)
ES (G(cid:19))

G(cid:19)∈FRAF (G)

The set of strongly-connected components of G
The set of the minimal relevant sccs of G
(cid:2)

V ∈MR(cut(G)) V

Reference

Def. 1, Sec. 2.1
Def. 2, Sec. 2.1
Def. 3, Sec. 2.1
Def. 3, Sec. 2.1
Def. 3, Sec. 2.1
Def. 3, Sec. 2.1
Def. 3, Sec. 2.1
Def. 3, Sec. 2.1
Def. 4, Sec. 2.1
Def. 4, Sec. 2.1
Def. 5, Sec. 2.1
Def. 5, Sec. 2.1
Def. 5, Sec. 2.1
Def. 6, Sec. 2.2
Sec. 2.2
Sec. 2.2
Sec. 2.2
Sec. 2.2
Def. 8, Sec. 2.2
Def. 12, Sec. 3.1
Def. 14, Sec. 3.1
Def. 15, Sec., 3.1
Def. 16, Sec. 3.2.1
Def. 17, Sec. 3.2.1
Def. 18, Sec. 3.2.1
Def. 20, Sec. 3.2.3
Sec. 6.1
Def. 22, Sec. 6.1
Sec. 6

P. Baroni et al. / Artiﬁcial Intelligence 175 (2011) 791–813

813

References

[1] S. Abramsky, A. Jung, Domain theory, in: S. Abramsky, D. Gabbay, T.S.E. Maibaum (Eds.), Semantic Structures, in: Handbook of Logic in Computer

Science, vol. 3, Oxford University Press, Oxford, 1995, pp. 1–168.

[2] L. Amgoud, C. Cayrol, A reasoning model based on the production of acceptable arguments, Annals of Mathematics and Artiﬁcial Intelligence 34 (2002)

197–215.

[3] P. Baroni, F. Cerutti, M. Giacomin, G. Guida, Encompassing attacks to attacks in abstract argumentation frameworks, in: C. Sossai, G. Chemello (Eds.),
Proc. 10th European Conference on Symbolic and Quantitative Approaches to Reasoning with Uncertainty, ECSQARU 2009, Verona, Italy, in: LNAI,
vol. 5590, Springer-Verlag, 2009, pp. 83–94.

[4] P. Baroni, F. Cerutti, M. Giacomin, G. Guida, AFRA: Argumentation framework with recursive attacks, International Journal of Approximate Reason-

ing 51 (1) (2011) 19–37.

[5] P. Baroni, M. Giacomin, Evaluating argumentation semantics with respect to skepticism adequacy, in: L. Godo (Ed.), Proc. 8th European Conference
on Symbolic and Quantitative Approaches to Reasoning with Uncertainty, ECSQARU 2005, Barcelona, Spain, in: LNAI, vol. 3571, Springer-Verlag, 2005,
pp. 329–340.

[6] P. Baroni, M. Giacomin, On principle-based evaluation of extension-based argumentation semantics, Artiﬁcial Intelligence 171 (10/15) (2007) 675–700.
[7] P. Baroni, M. Giacomin, Semantics of abstract argument systems, in: I. Rahwan, G.R. Simari (Eds.), Argumentation in Artiﬁcial Intelligence, Springer,

Berlin, 2009, pp. 25–44.

[8] P. Baroni, M. Giacomin, Skepticism relations for comparing argumentation semantics, International Journal of Approximate Reasoning 50 (6) (2009)

854–866.

[9] P. Baroni, M. Giacomin, G. Guida, Towards a formalization of skepticism in extension-based argumentation semantics, in: Proceedings of the 4th

Workshop on Computational Models of Natural Argument (CMNA 2004), Valencia, Spain, 2004, pp. 47–52.

[10] Pietro Baroni, Massimiliano Giacomin, Giovanni Guida, SCC-recursiveness: a general schema for argumentation semantics, Artiﬁcial Intelligence 168 (1–

2) (2005) 165–210.

[11] T.J.M. Bench-Capon, Persuasion in practical argument using value-based argumentation frameworks, Journal of Logic and Computation 13 (3) (2003)

429–448.

[12] T.J.M. Bench-Capon, S. Doutre, P.E. Dunne, Audiences in argumentation frameworks, Artiﬁcial Intelligence 171 (2007) 42–71.
[13] M. Caminada, Semi-stable semantics, in: P.E. Dunne, T.J.M. Bench-Capon (Eds.), Proc. of the 1st International Conference on Computational Models of

Argument, COMMA 2006, Liverpool, UK, in: Frontiers in Artiﬁcial Intelligence and Applications, vol. 144, IOS Press, 2005, pp. 121–130.

[14] M. Caminada, L. Amgoud, On the evaluation of argumentation formalisms, Artiﬁcial Intelligence 171 (5–6) (2007) 286–310.
[15] S. Coste-Marquis, C. Devred, P. Marquis, Prudent semantics for argumentation frameworks, in: Proceedings of the 17th IEEE International Conference

on Tools with Artiﬁcial Intelligence, ICTAI 2005, Hong Kong, China, IEEE Computer Society, 2005, pp. 568–572.

[16] S. Coste-Marquis, C. Devred, P. Marquis, Symmetric argumentation frameworks, in: L. Godo (Ed.), Proc. 8th European Conference on Symbolic and
Quantitative Approaches to Reasoning with Uncertainty, ECSQARU 2005, Barcelona, Spain, in: LNAI, vol. 3571, Springer-Verlag, 2005, pp. 317–328.
[17] Y. Dimopoulos, A. Torres, Graph theoretical structures in logic programs and default theories, Theoretical Computer Science 170 (1–2) (1996) 209–244.
[18] P.M. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming, and n-person games, Artiﬁcial

Intelligence 77 (2) (1995) 321–357.

[19] P.M. Dung, P. Mancarella, F. Toni, A dialectic procedure for sceptical, assumption-based argumentation, in: P.E. Dunne, T.J.M. Bench-Capon (Eds.), Proc.
of the 1st International Conference on Computational Models of Argument, COMMA 2006, Liverpool, UK, in: Frontiers in Artiﬁcial Intelligence and
Applications, vol. 144, IOS Press, 2005, pp. 145–156.

[20] P.E. Dunne, Computational properties of argument systems satisfying graph-theoretic constraints, Artiﬁcial Intelligence 171 (10/15) (2007) 701–729.
[21] P.E. Dunne, The computational complexity of ideal semantics, Artiﬁcial Intelligence 174 (2009) 20–50.
[22] P.E. Dunne, T.J.M. Bench-Capon, Coherence in ﬁnite argument systems, Artiﬁcial Intelligence 141 (1) (2002) 187–203.
[23] P.E. Dunne, T.J.M. Bench-Capon, Complexity in value-based argument systems, in: Proc. 9th European Conference on Logics in Artiﬁcial Intelligence,

JELIA 04, Lisbon, in: LNAI, vol. 3229, Springer-Verlag, 2004, pp. 360–371.

[24] P.E. Dunne, M. Caminada, Computational complexity of semi-stable semantics in abstract argumentation frameworks, in: Proc. 11th European Confer-

ence on Logics in Artiﬁcial Intelligence, JELIA 08, Dresden, in: LNAI, vol. 3293, Springer-Verlag, 2008, pp. 153–165.

[25] P.E. Dunne, A. Hunter, P. McBurney, S. Parsons, M. Wooldridge, Weighted argument systems: Basic deﬁnitions, algorithms, and complexity results,

Artiﬁcial Intelligence 175 (2) (2010) 457–486, doi:10.1016/.artint.2010.09.005.

[26] P.E. Dunne, M. Wooldridge, Complexity of abstract argumentation, in: I. Rahwan, G.R. Simari (Eds.), Argumentation in Artiﬁcial Intelligence, Springer,

Berlin, 2009, pp. 85–104.

[27] K. Inoue, C. Sakama, Generality and equivalence relations in default logic, in: Proc. of 22nd Conference on Artiﬁcial Intelligence, AAAI-07, Vancouver,

BC, AAAI Press, 2007, pp. 434–439.

[28] S. Modgil, Hierarchical argumentation, in: Proc. of the 10th European Conference on Logics in Artiﬁcial Intelligence, JELIA 06, in: Lecture Notes in

Computer Science, vol. 4160, Springer, 2006, pp. 319–332.

[29] S. Modgil, Reasoning about preferences in argumentation frameworks, Artiﬁcial Intelligence 173 (9–10) (2009) 901–934.
[30] G.D. Plotkin, A powerdomain construction, SIAM Journal on Computing 5 (3) (1976) 452–487.
[31] H. Prakken, An abstract framework for argumentation with structured arguments, Argument and Computation 1 (2) (2010) 93–124.
[32] B. Verheij, Two approaches to dialectical argumentation: admissible sets and argumentation stages, in: Proceedings of the Eighth Dutch Conference on

Artiﬁcial Intelligence (NAIC’96), Utrecht, NL, 1996, pp. 357–368.

