Artiﬁcial Intelligence 175 (2011) 457–486

Contents lists available at ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Weighted argument systems: Basic deﬁnitions, algorithms, and
complexity results
Paul E. Dunne a, Anthony Hunter b, Peter McBurney a, Simon Parsons c, Michael Wooldridge a,∗

a Dept. of Computer Science, University of Liverpool, Liverpool, UK
b Dept. of Computer Science, University College London, London, UK
c Department of Computer and Information Science, Brooklyn College, CUNY, Brooklyn, NY, USA

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 31 July 2009
Received in revised form 8 September 2010
Accepted 8 September 2010
Available online 25 September 2010

Keywords:
Argumentation
Handling inconsistency
Computational complexity

We introduce and investigate a natural extension of Dung’s well-known model of argument
systems in which attacks are associated with a weight, indicating the relative strength
of the attack. A key concept in our framework is the notion of an inconsistency budget,
which characterises how much inconsistency we are prepared to tolerate: given an
inconsistency budget β, we would be prepared to disregard attacks up to a total weight
of β. The key advantage of this approach is that it permits a much ﬁner grained level
of analysis of argument systems than unweighted systems, and gives useful solutions
when conventional (unweighted) argument systems have none. We begin by reviewing
Dung’s abstract argument systems, and motivating weights on attacks (as opposed to
the alternative possibility, which is to attach weights to arguments). We then present
the framework of weighted argument systems. We investigate solutions for weighted
argument systems and the complexity of computing such solutions, focussing in particular
on weighted variations of grounded extensions. Finally, we relate our work to the most
relevant examples of argumentation frameworks that incorporate strengths.

© 2010 Elsevier B.V. All rights reserved.

1. Introduction

Inconsistency between the beliefs and/or preferences of agents is ubiquitous in everyday life, and yet coping with in-
consistency remains an essentially unsolved problem in artiﬁcial intelligence [12]. One of the key aims of argumentation
research is to provide principled techniques for handling inconsistency [13,46].

Although there are several different perspectives on argumentation, a common view is that argumentation starts with a
collection of statements, called arguments, which are related through the notions of support and attack. Typically, argument
α1 supporting argument α2 would be grounds for accepting α2 if one accepted α1, while argument α1 attacking argument
α2 would be grounds for not accepting α2 if one accepted α1. Now, if we allow arguments to attack one-another, then such
collections of arguments may be inconsistent; and the key question then becomes how to obtain a rationally justiﬁable
position from such an inconsistent argument set. Various solutions have been proposed for this problem, such as admissible
sets, preferred extensions, and grounded extensions [19]. However, none of these solutions is without drawbacks. A common
situation is that, while a solution may be guaranteed to give an answer, the answer may be the empty set. Conversely,
several answers may be provided, with nothing to distinguish between them. These drawbacks limit the value of these
solutions as argument analysis tools.

* Corresponding author.

E-mail addresses: ped@csc.liv.ac.uk (P.E. Dunne), a.hunter@cs.ucl.ac.uk (A. Hunter), mcburney@liverpool.ac.uk (P. McBurney),

parsons@sci.brooklyn.cuny.edu (S. Parsons), mjw@csc.liv.ac.uk (M. Wooldridge).

0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2010.09.005

458

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

In part to overcome these diﬃculties, there is a trend in the literature on formalizations of argumentation towards
considering the strength of arguments. In this work, which goes back at least as far as [30], it is recognized that not all
arguments are equal in strength, and that this needs to be taken into account when ﬁnding extensions of a collection of
arguments and counterarguments. We review this literature in Section 2.1, and we conclude that whilst it is clear that
taking the strength of arguments into account is a valuable development, it is not just the strength of the arguments, per se,
that is important. The strength of the attack that one argument (which may itself be very strong) makes on another, can be
weak.

In this paper, we introduce, formalise, and investigate a natural extension of Dung’s well-known model of argument
systems [19], in which attacks between arguments are associated with a numeric weight, indicating the relative strength
of the attack, or, equivalently, how reluctant we would be to disregard the attack. For example, consider the following
arguments:

• α1 = The house is in a good location, it is large enough for our family and it is affordable: we should buy it.
• α2 = The house suffers from subsidence, which would be prohibitively expensive to ﬁx: we should not buy it.

These arguments are mutually attacking, and in the terminology of Dung’s abstract argument systems [19], both arguments
are credulously accepted, neither is sceptically accepted, and the grounded extension is empty. Thus the conventional anal-
ysis is not very useful for this scenario. However, the representation we are using surely misses a key point: the attacks
are not of equal weight. We would surely regard the attack of α2 on α1 as being much stronger than the attack of α1 on
α2, though both are very strong arguments in their own right. Our framework allows us to take these differing weights of
attack into consideration. (We note that an alternative to our approach, which has to some extent already been considered
in the literature, is to attach weights to arguments, rather than attaching weights to attacks between arguments. A detailed
discussion of the relative merits of the two possibilities is given in Section 2.)

A key concept in our framework is the notion of an inconsistency budget. The inconsistency budget characterises how
much inconsistency we are prepared to tolerate: given an inconsistency budget β, we would be prepared to disregard at-
tacks up to a total weight of β. By increasing the inconsistency budget, we get progressively more solutions, and this in
turn gives a preference ordering over solutions: we prefer solutions obtained with a smaller inconsistency budget. This ap-
proach permits a very ﬁne-grained level of analysis, and gives useful, non-trivial solutions when conventional (unweighted)
argument systems have none.

The remainder of this paper is structured as follows:

• We begin by reviewing Dung’s abstract argument systems, and providing motivation for the idea of extending Dung’s
framework with weights. We discuss in particular the relative merits of attaching weights to arguments versus attaching
weights to attacks.

• In Section 3, we present the formal model of weighted argument systems that we work with throughout the remainder
of the paper. After presenting the model, we discuss the semantics of weights, i.e., how weights can be interpreted, and
how they might be derived for some different domains.

• In Sections 4–6, we investigate solutions to weighted argument systems and the associated complexity of computing
these solutions, focussing in particular on weighted variations of grounded extensions. We also consider the more
general algorithmic and combinatorial properties of our framework.

• In Section 7, we consider the relationship between our weighted argument systems and four other well-known related
extensions of Dung’s argument framework. We show that, in a precise formal sense, our weighted argument systems
are strictly more expressive: all of the other frameworks considered can be represented as weighted argument systems,
but there exist weighted argument systems that have no equivalent representation in the alternative frameworks.

• We conclude with some issues for future work.

2. Background

Since weighted argument systems and their associated solutions generalise Dung’s well-known abstract argument sys-
tems model, we begin by recalling the key concepts from this model — note that further discussion of related work may be
found in Section 7.

Deﬁnition 1. A Dung-style abstract argument system is a pair D = (cid:3)X , A(cid:4) where X = {α1, . . . , αk} is a ﬁnite set of arguments,
and A ⊆ X × X is a binary attack relation on X [19].1

The next step is to deﬁne solutions for such argument systems, i.e., concepts of what constitutes a set of mutually
X → {(cid:7), ⊥}

compatible arguments from X within a system (cid:3)X , A(cid:4). Typically, such subsets are deﬁned via predicates σ : 2

1 Note that Dung’s model does not assume any internal structure for arguments, nor give any concrete interpretation for them. The intended interpreta-
tion of the attack relation in Dung’s model is also not completely deﬁned, but intuitively, (α1, α2) ∈ A means that if one accepts α1, then one should not
accept α2. In other words, it would be inconsistent to accept α2 if one accepted α1.

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

459

in ← out ← ∅

Function ge(X , A) returns a subset of X
1.
2. while initial((cid:3)X , A(cid:4)) (cid:12)= ∅ do
in ← in ∪ initial((cid:3)X , A(cid:4))
3.
out ← out ∪ {α ∈ X : ∃α(cid:15) ∈ in s.t. (cid:3)α(cid:15), α(cid:4) ∈ A}
4.
X ← X \ (out ∪ in)
5.
A ← A restricted to X
6.
7.
8.

end-while
return in.

Fig. 1. Computing the grounded extension of an (unweighted) argument system: the function ge(. . .).

so that when σ (S) holds of S ⊆ X in (cid:3)X , A(cid:4) the set S is viewed as acceptable with respect to the criteria deﬁned by σ
(see e.g., Baroni and Giacomin [8]). We review a number of proposals for such criteria in the following deﬁnition.

Deﬁnition 2. Given an argument system D = (cid:3)X , A(cid:4) and a set S ⊆ X , we say that S is initial if (cid:12) ∃α1 ∈ S such that ∃α2 ∈
X : (cid:3)α2, α1(cid:4) ∈ A using initial((cid:3)X , A(cid:4)) to denote the (unique) maximal such set. A set S ⊆ X is conﬂict free if ∀α1, α2 ∈
S (cid:3)α1, α2(cid:4) /∈ A; an argument α is acceptable w.r.t. S if ∀β ∈ X such that (cid:3)β, α(cid:4) ∈ A, ∃γ ∈ S such that (cid:3)γ , β(cid:4) ∈ A; the
characteristic function, F (S) reports the set of arguments that are acceptable to S; S is admissible if it is both conﬂict-free
and every α ∈ S is acceptable w.r.t. S. The grounded extension, ge((cid:3) X, A(cid:4)), is formed by the ﬁxed-point of F k where F 0 = ∅
and F k+1 = F (F k). It is shown in [19] that (for ﬁnite systems) this ﬁxed point always exists. Finally S is a preferred extension
X → {(cid:7), ⊥}, we denote by Eσ ((cid:3)X , A(cid:4)) the
if it is a maximal (w.r.t. ⊆) admissible set. Given an acceptability semantics, σ : 2
set of subsets of X :
(cid:2)

(cid:4)

(cid:3)
(cid:3)X , A(cid:4)

=

(cid:5)
S ⊆ X : σ (S)

Eσ

Speciﬁc cases of interest are:

(cid:4)

(cid:2)

(cid:3)
(cid:3)X , A(cid:4)
=
(cid:2)
(cid:3)
(cid:3)X , A(cid:4)
(cid:3)
(cid:3)X , A(cid:4)
(cid:3)
(cid:3)X , A(cid:4)

=

=

Einit
Eadm
(cid:2)
Epr
Egr

(cid:2)

=
(cid:4)

(cid:4)

(cid:2)

(cid:3)X , A(cid:4)

(cid:3)(cid:5)

S: S = initial
(cid:4)

(cid:5)
S: S is admissible in (cid:3)X , A(cid:4)

(cid:5)
S: S is a preferred extension of (cid:3)X , A(cid:4)

(cid:5)
S: S is the grounded extension of (cid:3)X , A(cid:4)

The initial arguments Einit, i.e., those belonging to the set initial((cid:3)X , A(cid:4)), form in some regards, the least problematic
notion of “collection of compatible arguments”, however, while every argument system contains a unique initial set of
arguments, (i.e., |Einit((cid:3)X , A(cid:4))| = 1), it may be that Einit((cid:3)X , A(cid:4)) = {∅}. Such trivial cases are typically unhelpful. If we do
not have a non-empty initial set of arguments, (which is the more general case), then we might look at conﬂict-free sets (the
so-called naive semantics), admissible sets, and preferred extensions. There will always be at least one preferred extension,
although, again, this may be the empty set [19, p. 327]. Note that non-empty preferred extensions may exist in argument
systems whose set of initial arguments is empty, and so we can usefully apply this solution in some situations where the
initial arguments are not an applicable analytical concept.

It is easily seen that F 1 = F (∅) = initial((cid:3)X , A(cid:4)) so that initial arguments play a central role in a constructive algorithm
for computing the grounded extension: starting from the set initial((cid:3)X , A(cid:4)), eliminate arguments that these arguments at-
tack; and iterate until we reach no change (the next set of “initial arguments” having removed initial((cid:3)X , A(cid:4)) and those
arguments attacked by it forms the set F 2 = F (F (∅)). The polynomial time algorithm to compute the grounded extension
of an argument system is given in Fig. 1.

Notice that, while all of these criteria are guaranteed to give some “answer”, it is possible that the only answer they give
is the empty set, i.e., Eσ ((cid:3)X , A(cid:4)) (cid:12)= ∅ but we may have Eσ ((cid:3)X , A(cid:4)) = {∅}. We view this as a key limitation of conventional
systems.

Of course as well as ideas of criteria by which subsets of X are distinguished as allowed or disqualiﬁed, we are concerned
with properties of arguments themselves with respect to such properties. We focus on the notions of credulous and sceptical
acceptability.

X → {(cid:7), ⊥}, an argument, α ∈ X is credulously accepted w.r.t. σ in (cid:3)X , A(cid:4) if there is
Deﬁnition 3. Given a semantics σ : 2
at least one S ⊆ X for which S ∈ Eσ ((cid:3)X , A(cid:4)) and α ∈ S. An argument, α ∈ X , is sceptically accepted w.r.t. σ in (cid:3)X , A(cid:4) if
∀S ∈ Eσ ((cid:3)X , A(cid:4)) we have α ∈ S.

The decision problems credulous acceptance w.r.t. σ (denoted caσ ) and sceptical acceptance w.r.t. σ (denoted saσ ) both
take as instances an argument system (cid:3)X , A(cid:4) together with an argument α ∈ X . An instance, (cid:3)(cid:3)X , A(cid:4), α(cid:4) is accepted, in
the former case, if ∃S ∈ Eσ ((cid:3)X , A(cid:4)): α ∈ S; such an instance is accepted, in the latter case, if ∀S ∈ Eσ ((cid:3)X , A(cid:4)): α ∈ S.

460

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

Sceptical acceptance imposes stronger conditions on the acceptability status of an argument than credulous acceptance:
determining whether a given set of arguments is the initial set or admissible can be solved in polynomial time; how-
ever, determining whether a set of arguments is a preferred extension is conp-complete, checking whether an argument is
credulously accepted w.r.t. admissibility (and thus w.r.t. preferred extensions) is np-complete, while checking whether an
argument is sceptically accepted w.r.t. preferred extensions is Π p

2 -complete [17,23].

2.1. Extending Dung’s framework

As we noted above, while Dung’s framework is both natural and powerful, the conventional solutions considered with
respect to this framework have obvious limitations: there can be multiple solutions (in which case which do we choose?)
and it may be that the only solution is the empty set. There have been a number of proposals for extending Dung’s
framework in order to allow for more sophisticated modelling and analysis of conﬂicting information, in order to overcome
these limitations. A common theme among some of these proposals is the observation that not all arguments are equal, and
that the relative strength of the arguments needs to be taken into account somehow.

The ﬁrst such extension of Dung’s work that we are aware of is [44], where priorities between rules are used to resolve
conﬂicts.2 These priorities seem best interpreted as relating to the strength of the arguments — indeed the strength of
arguments are inferred from the strengths of the rules from which the arguments are constructed. A similar notion is at
the heart of the argumentation systems in [1,2], though here there is a preference order over all an agent’s beliefs, and an
argument has a preference level equal to the minimum level of the beliefs from which it is constructed.

Another early development of Dung’s proposal with weights was Value-based Argumentation Frameworks (VAFs) [10].
In the VAF approach, the strength of an argument depends on the social values that it advances, and determining whether
the attack of one argument on another succeeds depends on the comparative strength of the values advanced by the
arguments concerned. Furthermore, some arguments can be shown to be acceptable whatever the relative strengths of the
values involved are. This means that the agents involved in the argumentation can concur on the acceptance of arguments,
even when they differ as to which social values are more important. One of the interesting questions that arises from this
proposal is whether the notion of argument strength can be generalised from representing social values to representing
other notions, and if so in what ways can the strength be harnessed for analysing argument graphs.

In a sense, a more general approach to developing Dung’s proposal is that of bipolar argumentation frameworks (BAFs)
which takes into account two kinds of interaction between arguments: a positive interaction (an argument can support an-
other argument) and a negative interaction (an argument can attack another argument) [15]. The BAF approach incorporates
a gradual interaction-based valuation process in which the value of each argument α only depends on the value of the
arguments which are directly interacting with α in the argumentation system. Various functions for this process are con-
sidered but each value obtained is only a function of the original graph. As a result, no extra information is made available
with which to ascertain the strength of an argument.

Recently, a game-theoretic approach, based on the minimax theorem, has been developed for determining the degree to
which an argument is acceptable given the counterarguments to it, and by recursion the counterarguments to the counterar-
guments [33]. So given an abstract argument system, this game-theoretic approach calculates the strength of each argument
in such a way that if an argument is attacked, then its strength falls, but if the attack is in turn attacked, then the strength
in the original argument rises. Furthermore, the process for this conforms to an interpretation of game theory for argumen-
tation. Whilst this gives an approach with interesting properties, and appealing behaviour, the strength that is calculated
is a function of the original graph, and so like the BAF approach, no extra information is made available with which to
determine the strength of each argument.

Notice that all of the above frameworks extend conventional argument models with weights (or preferences, priorities,
. . . ) that are attached to arguments. An alternative — which we explore in the remainder of the present paper — is to
attach weights to the attacks between arguments. Let us pause for a moment to consider the relative merits of weights on
arguments versus weights on attacks.

First, let us revisit the house-buying example from the introductory section, involving α1 and α2. Suppose we want to
analyse this scenario by using weights (or priorities) on arguments. We may consider each argument independently and say
that each is a strong argument in the sense that the premises are true (or very likely to be true), and that the claim follows
(with little doubt) from the premises. Then, we consider the arguments together, and we see that α1 is not as strong (as a
rationale for making the decision of whether to buy the house) as α2. Thus, in order to adjust the weight of α1, we need to
consider it relative to α2, and so the weight of α1 is a relative notion, which is modulated via the attack by α2. Therefore,
the weight of α1 determined from the weight of the attacks on α1. So in this example, which is a common situation, we
suggest that the weight of attack is a primitive notion, and the weight of the argument is a derived notion.

Second, let us consider a quite different kind of example based on arguments presented using classical logic (see, e.g.,
[13] for a detailed introduction to deductive argumentation). We assume each argument is a pair (cid:3)Φ, α(cid:4) where Φ is a
consistent set of formulae (called the support) that entails α (which is called the claim).

2 The article [30], which as we noted above considered some notion of argument strength, was not based on Dung’s framework.

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

461

(cid:7)

(cid:6)
{a ∧ b ∧ c, a ∧ b ∧ c → d}, d
(cid:6)
{a ∧ b ∧ ¬c}, a ∧ b ∧ ¬c
(cid:6)
{¬a ∧ ¬b ∧ ¬c}, ¬a ∧ ¬b ∧ ¬c

(cid:7)

(cid:7)

A1 =
A2 =
A3 =

We assume that an argument (cid:3)Φ, α(cid:4) undercuts (cid:3)Ψ, β(cid:4) when α entails the negation of the support Ψ (i.e., when {α} (cid:18)
¬(∧Ψ )). Here, we see that A2 undercuts A1 and A3 undercuts A1. However, we also see that the degree of undercut (i.e.,
measure of inconsistency arising between the claim of the attacker and the support of the attacked) is greater for the
undercut by A3 than for the undercut by A2. We can measure that degree of undercut as the distance between the nearest
models of the claim of the attacker and the support of the attacked normalized by the number of propositional letters in
the language (for more information see [13]). Here, we see the degree of undercut by A2 is 1/3 whereas the degree of
undercut by A3 is 1. This therefore is a simple and precise illustration of a weight on the attack relation that can only be
indirectly deﬁned as a weight (or priority) on arguments.

To conclude this brief discussion on the question of whether weights on attacks would be better represented by weights
(or priorities) on arguments, we believe that there are some situations where the weight of argument is a primitive notion
and some situations where the weight of attack is a primitive notion. The above examples illustrate our claim that weight of
attack can be a primitive notion, and we will provide further discussion and examples (such as when the weight represents
the number of votes in support of an attack) in Section 3.

Some other frameworks have taken the direction of this paper, that is, to consider the weights on attacks, and in the

remainder of this section, we discuss this work.

The idea of explicitly adding weights to attacks was proposed in [9]. However, the emphasis of that work was on how
weights can be changed dynamically and over time, rather than on extending Dung’s framework for determining extensions.
In another recent proposal for developing Dung’s model, extra information representing the relative strength of attack is
incorporated [32]. This is the only approach other than [9] we are aware of which distinguishes the strength of attack from
the strength of an argument. In this proposal, which we refer to as varied-strength attacks (or VSA) approach, each arc is
assigned a type, and there is a partial ordering over the types. As a simple example, consider the following argument graph
conforming to Dung’s proposal, where α1 is attacked by α2 which in turn is attacked by α3.

α3 → α2 → α1

Here, α3 defends the attack on α1, and as a result {α3, α1} is the preferred and grounded extension. Now, consider the
following VSA version of the graph, where the attack by α3 is of type i and the attack by α2 is of type j.

α3 →i α2 → j α1

This gives us a ﬁner grained range of defence depending on whether type j is higher, or lower, or equally, ranked than
type i, or incomparable with it. Furthermore, this allows for a ﬁner deﬁnition of acceptable extension that speciﬁes the
required level of the defence of any argument in the extension. For instance, it can be insisted in the VSA approach that
every defence of an argument should be by an attack that is stronger, so in the above graph that would mean that the type
of →i needs to be stronger than the type of → j in order for {α3, α1} to be the preferred, grounded extension.

Finally, an important mechanism that attempts to unify approaches based on disregarding attacks are the extended argu-
mentation frameworks (eafs) of Modgil [35,36]. An eaf is speciﬁed as a triple (cid:3)X , A, D(cid:4) where (cid:3)X , A(cid:4) describes a standard
Dung-style argument system and D ⊆ X × A, i.e., (cid:3)α1, (cid:3)α2, α3(cid:4)(cid:4) ∈ D indicates that the argument α1 attacks the attack
(cid:3)α2, α3(cid:4) thus those agents endorsing α1 may disregard the attack on α3 by α2. Modgil [36] describes how eafs may be
conﬁgured to capture acceptability in both pafs and vafs. While the basic structure underpinning the semantics of eafs
elaborates Dung’s grounded extensions (as is also the case w.r.t. vafs and pafs) there are a number of technical subtleties
arising in the formal deﬁnition. In Section 7 we consider distinguishing aspects of our approach compared to preference-
based, extended argumentation frameworks and other methods in greater depth.

From these proposals for developing Dung’s original approach, there is a common theme that arguments, or attacks by
arguments, have variable strength. Some of these proposals are restricted to determining that strength is based on the other
arguments available in the graph, together with their connectivity, and so the strength of an argument is a function solely
of the graph. Others, in particular the VAF approach [10] and the VSA approach [32], use explicit ranking information over
the arguments or the attacks by arguments. This ranking information requires extra information to be given along with the
set of arguments and the attack relation. So, whilst there is gathering momentum for representing and reasoning with the
strength of arguments or their attacks, there is not a consensus on the exact notion of argument strength or how it should
be used. Furthermore, for the explicit representation of extra information pertaining to argument strength, we see that the
use of explicit numerical weights is under-developed. So, for these reasons, we would like to present weighted argument
systems as a valuable new proposal that should further extend and clarify aspects of this trend towards considering strength,
in particular the explicit consideration of strength of attack between arguments.

In some respects, the strength of attack approach offers a richer representation than the strength of argument approach:
For a connected graph with n arguments, we have up to n2 strength of attack values, whereas we will only have n strength
of argument values. This allows for more ﬁner-grained consideration of argument graphs since we are considering more
information.

462

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

However, in a sense, strength of attack and strength of argument are different kinds of information. For example, consider
arguments α and α(cid:15)
that attack each other, perhaps as part of a larger argument graph. By using strength of argument
values, we effectively decide whether one or both arguments needs to be considered as unacceptable. Given that they
attack each other, we cannot have an acceptable set of arguments containing both α and α(cid:15)
. In contrast, by using strength
of attack, we can render the strength of attack so weak that neither argument forces the other argument to be unacceptable.
Another advantage of using the strength of attack approach is that it can be considered locally. For instance, if arguments
α and α(cid:15)
do attack each other, and they are part of a larger argument graph, and we wanted α to be in an acceptable
extension in preference to α(cid:15)
that α(cid:15)
against α. This is a local decision, and it is not affected by the values for any other attack. In contrast, if we use strength
of argument, then we would choose a value for α to be stronger than α(cid:15)
, but this is a global decision, because we would
need to check that the value for α was adjusted so that it defeated or was defeated as required by all the other arguments
it was connected to.

, then all we need to do is set the strength of attack to be greater for α against α(cid:15)

3. Weighted argument systems

We now introduce our model of weighted argument systems, and the key solutions we use throughout the remainder of
the paper. Weighted argument systems extend Dung-style abstract argument systems by adding numeric weights to every
edge in the attack graph, intuitively corresponding to the strength of the attack, or equivalently, how reluctant we would be
to disregard it. Formally,

Deﬁnition 4. A weighted argument system is a triple W = (cid:3)X , A, w(cid:4) where (cid:3)X , A(cid:4) is a Dung-style abstract argument system,
and w : A → R> is a function assigning real valued weights3 to attacks.

In what follows, when we say simply “argument system”, we mean “Dung-style (unweighted) abstract argument system”.
Notice that we require attacks to have a positive non-zero weight. There may be cases where it is interesting to allow
zero-weight attacks, in which case some of the analysis of this paper does not go through. However, given our intuitive
reading of weights (that they indicate the strength of an attack) allowing 0-weight attacks is perhaps counter-intuitive.
Suppose by appealing to a particular 0-weight attack you were able to support some particular argument, then an opponent
could discard the attack at no cost. So, we will assume attacks must have non-zero weight. We postpone discussion of where
weights come from until Section 3.2.

3.1. Inconsistency budgets

A key idea in what follows is that of an inconsistency budget, β ∈ R(cid:2), which we use to characterise how much inconsistency
we are prepared to tolerate. The intended interpretation is that, given an inconsistency budget β, we would be prepared to
disregard attacks up to a total weight of β. Conventional abstract argument systems implicitly assume an inconsistency budget
of 0. However, by relaxing this constraint, allowing larger inconsistency budgets, we can obtain progressively more solutions
from an argument system.

Deﬁnition 5. Let (cid:3)X , A, w(cid:4) be a weighted argument system. Given R ⊆ A,

wt(R, w) =

(cid:8)

(cid:2)

(cid:3)
(cid:3)α1, α2(cid:4)

w

(cid:3)α1,α2(cid:4)∈R

The function sub(· · ·), which takes an attack relation A, weight function w : A → R>, and inconsistency budget β ∈ R(cid:2),
returns the set of subsets R of A whose total weight does not exceed β, i.e.,

sub(A, w, β) =

(cid:4)

R: R ⊆ A & wt(R, w) (cid:2) β

(cid:5)

We now use inconsistency budgets to introduce weighted variants of the semantics introduced for abstract argument

systems, above.

Deﬁnition 6. Given a weighted argument system (cid:3)X , A, w(cid:4), let σ : 2
of 2

X

is given as
(cid:2)

E wt
σ

(cid:3)X , A, w(cid:4), β

(cid:4)

(cid:3)

=

S ⊆ X : ∃R ∈ sub(A, w, β) & S ∈ Eσ

(cid:2)

(cid:3)(cid:5)

(cid:3)X , A \ R(cid:4)

X → {(cid:7), ⊥}. For β ∈ R(cid:2), the subset E wt

σ ((cid:3)X , A, w(cid:4), β)

A set S ∈ E wt

σ ((cid:3)X , A, w(cid:4), β) will, subsequently, be termed to as a β − σ set (extension), so that we refer to β-grounded

extensions, β-admissible sets, β-preferred extensions etc.

3 We let R> denote the real numbers greater than 0, and R(cid:2) denote the real numbers greater than or equal to 0.

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

463

Fig. 2. Weighted argument system W 1 from Example 1.

Table 1
Ewt
σ

(W 1, β) for some increasing values of β.

β

0
1
2
3

Ewt
init (W 1, β)
{∅}
{∅, {α5}}
{∅, {α4}, {α5}}
{∅, {α4}, {α5}, {α4, α5}}

Ewt
pr (W 1, β)
{{α1, α2, α4, α6}, {α3, α5, α7, α8}}
{{α1, α2, α4, α6}, {α3, α5, α7, α8}}
{{α1, α2, α4, α6}, {α3, α5, α7, α8}}
{{α1, α2, α4, α6}, {α3, α5, α7, α8},
{α1, α2, α4, α5, α7, α8}}

Ewt
ge (W 1, β)

{∅}
{∅, {α3, α5, α7, α8}}
{∅, {α3, α5, α7, α8}, {α1, α2, α4, α6}}
{∅, {α3, α5, α7, α8}, {α1, α2, α4, α6},
{α1, α2, α4, α5, α7, α8}}

It is immediate from this deﬁnition that for every weighted argument system,

irrespective of how σ is deﬁned
E wt
σ ((cid:3)X , A, w(cid:4), 0) = Eσ ((cid:3)X , A(cid:4)), i.e., by not allowing any inconsistency, weighted argument systems recover Dung argu-
ment system and their associated semantics.

Example 1. Consider the weighted argument system W 1, illustrated in Fig. 2. The initial set of arguments in W 1 is empty;
however, {α5} ∈ E wt
init(W 1, 2) = {∅, {α4}, {a5}}. Table 1
shows initial sets (and other examples) for some increasing values of β.

init(W 1, 1) since we can delete (α4, α5) with β = 1. If β = 2, we have E wt

Weighted argument systems have the following, (readily proved), property:

Proposition 1. Let (cid:3)X , A, w(cid:4) be a weighted abstract argument system. For every set of arguments S ⊆ X , ∃β ∈ R(cid:2) and T ⊆ X such
that S ⊆ T and T ∈ E wt

init((cid:3)X , A, w(cid:4), β).

Thus, intuitively, every set of arguments can be made initial at some cost, and the cost required to do this immediately
gives us a preference ordering over sets of arguments: we prefer sets of arguments that require a smaller budget. Notice that
a similar observation holds true for conﬂict-freeness, admissibility, preferred extensions, credulous acceptance, and sceptical
acceptance.4

Now, consider how grounded extensions are generalised within weighted systems. The ﬁrst observation to make is
that while in unweighted argument systems the grounded extension is unique, this will not necessarily be the case in
weighted argument systems: in weighted systems there may be many β-grounded extensions, i.e., while for every (cid:3)X , A(cid:4) we
have |Egr((cid:3)X , A(cid:4))| = 1 for weighted systems and β > 0 it is possible that |E wt
gr ((cid:3)X , A, w(cid:4), β)| > 1. We observe that other
developments building on standard argument systems, most notably the resolution-based grounded semantics of Baroni and
Giacomin [7] also result in a multiple status variant. Table 1 shows β-grounded extensions for some increasing values of β
for system W 1 of Fig. 2.

3.2. Where do weights come from?

Having introduced the basic framework of weighted argument systems, some obvious and important questions arise:
What do weights mean? Where do they come from? If we want to represent a particular argumentation domain using
weighted argument systems, how are we to compute the weights for this domain? We will not demand any speciﬁc inter-
pretation of weights, and the technical treatment of weighted argument systems in this paper does not of course require
any such interpretation, apart from assuming that the weights are real-valued and may be combined additively. However,
from the point of view of motivation, it is important to consider this issue seriously (if only to convince the reader that
weights are not a purely technical device). We here discuss three possible interpretations of weights on attacks: weights
as measures of votes in support of attacks; weights as measures of the inconsistency of argument-pairs; and weights as
rankings of different types of attack. We emphasize that these three examples by no means exhaust the possibilities for the
meaning of weights on attacks.

4 It should be noted, however, that we may not be able always to guarantee S ∈ Eσ ((cid:3)X , A \ R(cid:4)) no matter how large a budget is used: only S ⊆ T with
T ∈ Eσ ((cid:3)X , A \ R(cid:4)).

464

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

3.2.1. Weighted majority relations

In a multi-agent setting, one natural interpretation is that a weight represents the number of votes in support of the at-
tack. This interpretation makes a link between argumentation and social choice theory — the theory of voting systems and
collective decision making [3,45]. Related work in argumentation drawing on social choice theory is [50], which considers
aggregation of multiple types of attack in argumentation frameworks.

The following example is based on the well-known Condorcet paradox, which concerns majority voting on three mutually
exclusive options. The basic idea of the paradox is that, given a group of voters, it possible for a majority to vote for A
over B, for a majority to vote for B over C , and for a majority to vote for C over A.

More formally, assume we have three mutually exclusive options to vote on, and a group of k voters. Let x be the
proportion of voters who vote for A over B, y be the proportion of voters who vote for B over C , and z be the proportion
of voters who vote for C over A, where x, y, z > 0.5. Hence, a majority vote for A over B, a majority vote for B over C , and
a majority vote for C over A. Also assume that there are no abstentions (and therefore for each pair of options O i, O j ∈
{ A, B, C}, if O i (cid:12)= O j , then each voter either votes for O i over O j or for O j over O i ). We can represent this instance of the
Concordet paradox in the weighted graphs with arcs deﬁned as follows.

• A attacks B with weight x;
• B attacks A with weight 1 − x;
• B attacks C with weight y;
• C attacks B with weight 1 − y;
• C attacks A with weight z; and
• A attacks C with weight 1 − z.

Using the inconsistency budget, it is simple and intuitive to get useful solutions. To illustrate, suppose also that Min(x, y, z)
is x, then we have that the minimum budget β for which we get a non-empty initial set is when β is x + (1 − y) + (1 − z).
For this, {B, C} is β-initial, β-acceptable, etc.

Now suppose we have a fourth option D, but there is only information to compare it with B and C . Suppose a majority
(represented by proportion v) vote for C over D, and a majority (represented by proportion w) vote for D over B. Hence,
the argument graph now has the following extra edges:

• C attacks D with weight v;
• D attacks C with weight 1 − v;
• D attacks B with weight w; and
• B attacks D with weight 1 − w.

This extended graph can be regarded as capturing two instances of the Condorcet paradox. This more complex situation
involves incompleteness concerning the relative preference of B and D, and conﬂicts arising from the two instances of the
paradox, and the interactions between the two instances.

Using inconsistency budgets, as before, we have a straightforward way to resolve the situation. To illustrate, suppose that
Min(v, w, x, y, z) is x, then we have that the minimum budget β for which we get a non-empty initial set is when β is
(1 − v) + (1 − w) + x + (1 − y) + (1 − z), and for this, {B, C, D} is β-initial, β-acceptable, etc.

3.2.2. Weights as measures of inconsistency

Because attacks are between two arguments, a simple interpretation is to use weights as a measure of the extent of
inconsistency between pairs of arguments. In other words, a higher weight on the attack between two arguments denotes
greater inconsistency between the arguments concerned than does a lower weight. For example, consider the following
arguments that are based on classical predicate logic.

(cid:6)(cid:4)

(cid:6)(cid:4)

(cid:6)(cid:4)

(cid:5)
(cid:7)
, ∀x.p(x)
∀x.p(x)
(cid:5)
¬∀x.p(x)
(cid:5)
¬∃x.p(x)

(cid:7)
, ∃x.¬p(x)
(cid:7)
, ∀x.¬p(x)

A1 =
A2 =
A3 =

Here, both A2 and A3 are undercuts of A1 since each has a claim that negates the support of A1. As with the propositional
, we
case, we can measure the degree of undercut in terms of the models: for arguments A and A
can determine the distance between the nearest models of the claim of A and of the support of A
. However, for the ﬁrst-
order case, we need to consider ﬁrst-order models. One option is to consider Herbrand models composed from a Herbrand
universe. Here, suppose the Herbrand universe is of cardinality n; then we may assign a degree of undercut for A2 on A1 of
1/n, whereas we may assign a degree of undercut for A3 on A1 of n. In the former case, it is because just one element of
the universe is involved in a contradiction concerning the predicate p, whereas in the latter case, it is because all elements
of the universe are involved in a contradiction concerning the predicate p. There is a range of options for deﬁning a measure
of the degree of undercut (see Besnard and Hunter [13] for more discussion of this), and the measures selected can be used

, where A undercuts A

(cid:15)

(cid:15)

(cid:15)

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

465

in assessing the incoherence arising in a set of arguments. Moreover, we see that the degree of undercut is an evaluated
notion associated with the attack (or pair of arguments) and not just with individual arguments.

A similar notion is explored in work by Pinyol and Sabater-Mir [42], using a weighted argumentation framework for
multi-agent communications concerning reputation. Here the weight of an attack between two arguments measures the
relative reliability, as assessed by a decision-maker, of the sources of the two arguments.

3.2.3. Weights as ranking of attacks

Attacks between arguments may be of different types, or may be expressions of different perspectives (perhaps by
different people) over the sets of arguments. In these cases, we can use weights to rank the relative strength of the different
attacks between arguments. Here, higher weight denotes a stronger attack, but the absolute weight assigned to an attack
is not important, just the relative weight compared to the weights assigned to other attacks. In this interpretation, the
weights may arise from objective considerations (such as logical measures of the inconsistency between pairs of arguments,
as in the previous interpretation), or from subjective criteria, as when the attacks are assigned by different stakeholders.
To illustrate this approach, we consider an example modiﬁed from Example 1 of [50]. Three arguments are presented for a
patient undergoing medical diagnosis, as follows:

A: Symptoms x, y and z indicate the presence of disease d1, which would suggest therapy t1.
B: Symptoms x, w and z indicate the presence of disease d2, which would suggest therapy t2.
C: Symptoms x and z indicate the presence of disease d3, which would suggest therapy t3.

In comparing one argument with another, a number of different criteria may be applied. In Example 1 of [50], for in-
stance, these arguments are compared in terms of the speciﬁcity of the argument, whether or not the two treatments may
be applied jointly, and the degree to which the underlying symptoms are present. One could readily imagine additional
criteria, such as the relative costs of the recommended therapies, their relative durations, and the relative extent of side
effects. Each of these criteria could be used to deﬁne a relation between pairs of arguments, which, applied here, identiﬁes
attacks between arguments. For each comparison criterion, appropriate weights could be deﬁned by a decision-maker for
the argument pairs where an attack is present. For instance, consider the relative strength of symptoms as a criterion for
comparison. Suppose symptoms w and z were strongly present in the patient, while the other two symptoms were only
weakly present. The attack of argument B on argument A could then be assigned a weight of 2, since two of B’s three
required symptoms are strongly present while only 1 of A’s three required symptoms is. Similarly, the attack of argument B
on C could be given a weight of 1.34, since two of B’s three required symptoms are strongly present while only one of C’s
two required symptoms is.

In a similar way, we could deﬁne weights on the attacks between arguments based on the other identiﬁed comparison
criteria. The relative importance of these different types of attacks could then be denoted by relative weights on the corre-
sponding attacks, as assessed by a decision-maker. For example, if the criterion of the relative presence of symptoms was
considered a more important comparison criterion than (say) the relative costs of the recommend therapies, then attacks of
the ﬁrst type could be assigned a weight greater than those of the second type. As mentioned, here the absolute numbers
are not important; rather the weights are aiming to capture the relative degree of importance of the underlying comparison
criteria to a decision-maker. One could readily imagine applications where attacks are identiﬁed and ranked by multiple
stakeholders, such as the three doctors of Example 1 in [50], each stakeholder comparing argument pairs according to their
own chosen set of criteria.

An objection to this example may be that applications such as this could be represented by deﬁning multiple preference
relations over the set of arguments. As we demonstrate in Section 7, such a conclusion, although true in particular cases, is
not warranted in general.

4. Complexity of weighted solutions

Prima facie, it appears that weighted argument systems offer some additional expressive power over unweighted argu-
ment systems. So, does this apparently additional power come with some additional computational cost? The β versions
of the decision problems for admissibility, checking preferred extensions, sceptical, and credulous acceptance are in fact no
harder (although of course no easier) than the corresponding unweighted decision problems — these results are easy to
establish. However, the story for β-grounded extensions is more complicated, since there may be multiple β-grounded ex-
tensions. Since there are multiple β-grounded extensions, we can consider credulous and sceptical variations of the problem,
as with preferred extensions.

Let us make this discussion more formal. Where d is an arbitrary decision problem, instances of which include a (stan-
dard) Dung-style argument system (cid:3)X , A(cid:4), we use wd to denote the same problem but with weighted systems (cid:3)X , A, w(cid:4).
X → {(cid:7), ⊥} is some argumentation semantics. In [26] the “canonical” decision problems in argument
Thus, suppose σ : 2
systems (each of which may be instantiated with respect to particular σ ) are deﬁned as in Table 2.

Consider the cases of verifying whether a given set S is a β–σ set, i.e., the decision problem wverσ ((cid:3)X , A, w(cid:4), S, β).

466

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

Table 2
Standard decision problems in argument systems.

Problem
verσ
caσ
saσ
exσ
neσ

Instance
(cid:3)X , A(cid:4); S ⊆ X
(cid:3)X , A(cid:4); x ∈ X
(cid:3)X , A(cid:4); x ∈ X
(cid:3)X , A(cid:4)
(cid:3)X , A(cid:4)

Question
Is S ∈ Eσ ((cid:3)X , A(cid:4))?
Is there any S ∈ Eσ ((cid:3)X , A(cid:4)) for which x ∈ S?
Is x a member of every T ∈ Eσ ((cid:3)X , A(cid:4))?
Is Eσ ((cid:3)X , A(cid:4)) non-empty?
Is there any S ∈ Eσ ((cid:3)X , A(cid:4)) for which S (cid:12)= ∅?

Proposition 2. The decision problem wverσ with instances (cid:3)X , A, w(cid:4), S ⊆ X and β ∈ R> is polynomial time decidable for σ ∈
{init, adm}.

Proof. The case for wverinit is obvious, so consider wveradm. For S to be admissible in (cid:3)X , A(cid:4), it must be conﬂict-free with
each argument in S acceptable to S. So, we need to eliminate from A any attacks between members of S, and any attacks
on members of S from outside S that are not defended by members of S; so simply compute these two sets of attacks, and
check whether the sum of their weights is (cid:2) β. (cid:2)

The cases for credulous and sceptical acceptance with respect to preferred extensions — i.e., wcapr((cid:3)X , A, w(cid:4), x, β) and
wsapr((cid:3)X , A, w(cid:4), x, β) — require a little more thought. We can show that, as with checking admissibility, the analogous
weighted problems, while hard, are no harder than the unweighted solutions.

Proposition 3.

a. wcapr is np-complete.
b. wsapr is Π p
2 -complete.

(cid:9)

Proof. Consider credulous acceptance and an instance (cid:3)(cid:3)X , A, w(cid:4), x, β(cid:4). For membership of np, simply guess some R ⊆ A,
and S ⊆ X \ {x}. Then verify that both
(cid:3)x, y(cid:4)∈R w((cid:3)x, y(cid:4)) (cid:2) β and that S ∪ {x} is admissible in A \ R (we do not need to
check maximality: if an argument is contained in some β-admissible set, it is contained in some maximal β-admissible set).
For hardness, observe that wcapr generalises capr i.e., the unweighted version which is np-complete [17]. Formally, given an
instance (cid:3)(cid:3)X , A(cid:4), x(cid:4) of capr create a weighted argument system (cid:3)X , A, w(cid:4) in which w((cid:3)p, q(cid:4)) = 1 for all (cid:3)p, q(cid:4) ∈ A, and ask
whether (cid:3)(cid:3)X , A, w(cid:4), x, 0(cid:4) is accepted as an instance of wcapr. The proof for wsapr is similar using the Π p
2 -hardness of sapr
demonstrated in [23]. (cid:2)

Our principal interest is in the grounded extension, and so we now focus on the problem wcagr, instances of which
are of the form (cid:3)(cid:3)X , A, w(cid:4), β, x(cid:4) where β is an inconsistency budget and x ∈ X . An instance of wcagr is accepted if ∃S ∈
E wt
gr ((cid:3)X , A, w(cid:4), β) such that x ∈ S. The analogous sceptical form of wcagr (denoted by wsagr) has instances of the same
form, but with these accepted if and only if ∀S ∈ E wt

gr ((cid:3)X , A, w(cid:4), β), we have x ∈ S.

Proposition 4. wcagr is np-complete, and remains np-complete even if the attack relation is planar and/or tripartite and/or has no
argument which is attacked by more than two others.

Proof. For membership, a conventional “guess and check” approach suﬃces. For np-hardness, we reduce from 3-sat. Given
an instance ϕ(Zn) of 3-sat with m clauses C j over propositional variables Zn = {z1, . . . , zn}, form the weighted argument
system (cid:3) Xϕ, Aϕ, wϕ(cid:4), illustrated in Fig. 3. Speciﬁcally, Xϕ has 3n + m + 1 arguments: an argument C j for each clause of
ϕ(Zn); arguments {zi, ¬zi, ui} for each variable of Zn, and an argument ϕ. The relationship, Aϕ , contains attacks (C j, ϕ) for
each clause of ϕ, (zi, ¬zi), (¬zi, zi), (zi, ui), (¬zi, ui), and (ui, ϕ) for each 1 (cid:2) i (cid:2) n. Finally, Aϕ contains an attack (zi, C j)
if zi is a literal in C j , and (¬zi, C j) if ¬zi occurs in C j . The weighting function wϕ assigns weight 1 to each of the attacks
{(zi, ¬zi), (¬zi, zi)} and weight n + 1 to all remaining attacks. To complete the instance the available budget is set to n and
the argument of interest to ϕ. We claim that ϕ ∈ S for some S ∈ E wt
gr ((cid:3)Xϕ, Aϕ, wϕ(cid:4), n) if and only if ϕ(Zn) is satisﬁable.
We ﬁrst note that ϕ is credulously accepted in the (unweighted) system (cid:3)Xϕ, Aϕ(cid:4) if and only if ϕ(Zn) is satisﬁable.5 We
deduce that if ϕ(Zn) is satisﬁed by an assignment (cid:3)a1, a2, . . . , an(cid:4) of Zn then ϕ is a member of the grounded extension of
the acyclic system (cid:3)Xϕ, Aϕ \ B(cid:4) in which B contains (¬zi, zi) (if ai = (cid:7)) and (zi, ¬zi) (if ai = ⊥). Noting that B has total
weight n, and that the subset { y1, y2, . . . , yn} in which yi = zi (if ai = (cid:7)) and ¬zi (if ai = ⊥) is unattacked, it follows that
from ϕ(Zn) satisﬁable we may identify a suitable weight n set of attacks, B, to yield ϕ ∈ ge((cid:3)Xϕ, Aϕ \ B(cid:4)).

On the other hand, suppose that ϕ ∈ S for some S ∈ E wt

gr ((cid:3)Xϕ, Aϕ, wϕ(cid:4), n). Consider the set of attacks, B, eliminated
from Aϕ in order to form the system (cid:3)Xϕ, Aϕ \ Bϕ(cid:4) with grounded extension S. Since ϕ ∈ S, exactly one of (zi, ¬zi) and

5 This follows from [17] which uses a similar construction for which the ui arguments and associated attacks do not occur.

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

467

Fig. 3. The reduction used in Proposition 4.

(¬zi, zi) must be in B for every i. Otherwise, if for some i, neither attack is in B then {zi, ¬zi} ∩ S = ∅, and thus ϕ has no
defence to the attack by ui , contradicting ϕ ∈ S; similarly if both attacks are in B then, from the fact B has total weight at
most n, for some other variable, zk, both (zk, ¬zk) and (¬zk, zk) would be in Aϕ \ B. In total, from S ∈ E wt
gr ((cid:3)Xϕ, Aϕ, wϕ(cid:4), n)
and ϕ ∈ S for each 1 (cid:2) i (cid:2) n we identify exactly one unattacked argument, yi from {zi, ¬zi}, so that S = {ϕ, y1, . . . , yn}.
That the assignment zi = (cid:7) (if yi = zi ) and zi = ⊥ (if y = ¬zi ) satisﬁes ϕ(Zn) is immediate from [17].

The remaining cases (for planar, tripartite graphs, etc.) can be derived from the reductions from 3-sat given in [20]. (cid:2)

Now consider the “sceptical” version of this problem.

Proposition 5. wsagr is conp-complete.

(cid:9)

Proof. Membership of conp is immediate from the algorithm which checks for every B ⊆ A that if
e∈B w(e) (cid:2) β then
x ∈ ge((cid:3)X , A \ B(cid:4)). For conp-hardness, we use a reduction from unsat, assuming w.l.o.g. that the problem instance is pre-
sented in cnf. Given an m-clause instance ϕ(Zn) of unsat, we construct a weighted argument system (cid:3)Xϕ, Aϕ, wϕ(cid:4) as
follows. The set Xϕ contains 4n + m + 3 arguments: {ϕ, ψ, χ }; {zi, ¬zi, ui, v i: 1 (cid:2) i (cid:2) n}; and {C j: 1 (cid:2) j (cid:2) m}. The at-
tack set Aϕ comprises: {(ϕ, ψ), (χ , ϕ)}; {(v i, zi), (v i, ¬zi), (zi, ui), (¬zi, ui), (ui, ϕ)} for each 1 (cid:2) i (cid:2) n; {(C j, ϕ): 1 (cid:2) j (cid:2) m};
{(zi, C j): zi ∈ C j} and {(¬zi, C j): ¬zi ∈ C j}. The attacks are weighted so that wϕ((χ , ϕ)) = 1; wϕ((v i, zi)) = wϕ((v i, ¬zi)) =
1; all remaining attacks have weight n + 2. The instance is completed using ψ as the relevant argument and an inconsistency
tolerance of n + 1. See Fig. 4 for an illustration of the construction.

Now, suppose that ϕ(Zn) is satisﬁed by an assignment α = (cid:3)a1, . . . , an(cid:4) of Zn. Consider the subset Bα of Aϕ given
by {(χ , ϕ)} ∪ {(v i, zi): ai = (cid:7)} ∪ {(v i, ¬zi): ai = ⊥}. The weight of Bα is n + 1 and since α satisﬁes ϕ(Zn) it follows
that ge((cid:3)Xϕ, Aϕ \ Bα(cid:4)) contains exactly the arguments {χ , ϕ} ∪ {v 1, . . . , vn} ∪ {zi: ai = (cid:7)} ∪ {¬zi: ai = ⊥}. Hence ψ /∈
ge((cid:3)Xϕ, Aϕ \ Bα(cid:4)) as required.

Conversely, suppose (cid:3)(cid:3)Xϕ, Aϕ, w(cid:4), ψ, n + 1(cid:4) is not accepted. We show that we may construct a satisfying assignment
of ϕ(Zn) in such cases. Consider B ⊆ Aϕ of weight at most n + 1 for which ψ /∈ ge((cid:3)Xϕ, Aϕ \ B(cid:4)). It must be the case
that (χ , ϕ) ∈ B for otherwise the attack by ϕ on ψ is defended so that ψ would belong to the grounded extension.
The remaining elements of B must form a subset of the attacks {(v i, zi), (v i, ¬zi)} (since all remaining attacks are too
costly). Furthermore, exactly one of {(v i, zi), (v i, ¬zi)} must belong to B for each 1 (cid:2) i (cid:2) n: otherwise, some ui will be in
ge((cid:3)Xϕ, Aϕ \ B(cid:4)), thus providing a defence to the attack on ψ by ϕ and contradicting the assumption ψ /∈ ge((cid:3)Xϕ, Aϕ \ B(cid:4)).
Now consider the assignment α, with ai = (cid:7) if (v i, zi) ∈ B, ai = ⊥ if (v i, ¬zi) ∈ B. We now see that α must satisfy ϕ(Zn):
in order for ψ /∈ ge((cid:3)Xϕ, Aϕ \ B(cid:4)) to hold, it must be the case that ϕ ∈ ge((cid:3)Xϕ, Aϕ \ B(cid:4)), i.e., each of the C j attacks on ϕ
must be counterattacked by one of its constituent literal (arguments) yi . Noting that v i is always in ge((cid:3)Xϕ, Aϕ \ B(cid:4)), if
ai = (cid:7) clauses containing ¬zi cannot be attacked (since the attack (v i, ¬zi) is still present). It follows that the assignment,
α, attacks each clause so that ϕ ∈ ge((cid:3)Xϕ, Aϕ \ B(cid:4)). In sum, if (cid:3)(cid:3)Xϕ, Aϕ, w(cid:4), ψ, n + 1(cid:4) is accepted as an instance of wsagr
then ϕ(Zn) is unsatisﬁable, so completing the proof. (cid:2)

Note that in some cases, considering sceptical grounded extensions is of limited value. Consider the set initial((cid:3)X , A(cid:4))

then we have:

Proposition 6. Let (cid:3)X , A, w(cid:4) be a weighted argument system and β be an inconsistency budget. Then initial((cid:3)X , A(cid:4)) (cid:12)= ∅ iff
(cid:10)
(

Y ∈Ewt

gr

((cid:3)X ,A,w(cid:4),β) Y ) (cid:12)= ∅.

468

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

Fig. 4. The reduction used in Proposition 5.

In some respects the intractability status of wcagr and wsagr in the general case, as illustrated by the results of Proposi-
tions 4 and 5 is unsurprising: intractability results hold for all proposed so-called multiple status semantics in Dung’s model
(e.g., preferred extensions via the results of [17], semi-stable semantics [24,27]). Within variants of standard argument
systems whose basic semantics of interest is multiple status form of the grounded extensions, e.g., the resolution-based
grounded semantics, the corresponding credulous and sceptical acceptance problems have also been shown to be in-
tractable [6]. Even within “single-status” semantics (where there is a unique subset of arguments satisfying the speciﬁed
condition), there are examples where the credulous acceptance problem6 is intractable (e.g., ideal semantics [21,22]).

There are, however, a number of cases for which these decision problems can be solved in polynomial time, in particular
if the topology of the system (cid:3)X , A(cid:4) satisﬁes given constraints. Thus, all of the decision problems in Table 2 are polynomial
time decidable in preferred semantics in the following cases:

a. If (cid:3)X , A(cid:4) is acyclic (as shown in Dung [19]).
b. If (cid:3)X , A(cid:4) is symmetric, i.e., if for every (distinct) x, y ∈ X , (cid:3)x, y(cid:4) ∈ A ⇔ (cid:3) y, x(cid:4) ∈ A (Coste-Marquis et al. [16]).
c. If (cid:3)X , A(cid:4) is bipartite, i.e., X may be partitioned into two sets Y and Z , both of which are conﬂict-free (Dunne [20]).

Given this, we might hope that if our weighted argument system falls into one of these three classes then the related

decision questions have feasible algorithms. In fact, for two of these cases, this hope is disappointed.

Proposition 7. wcagr is np-complete even if (cid:3)X , A(cid:4) is acyclic.

Proof. To prove np-hardness, we use a reduction from 3-sat. Given an instance ϕ(Zn) of 3-sat form the weighted argument
system (cid:3)Xϕ, Aϕ, w(cid:4) with

Xϕ = {zi, ¬zi: 1 (cid:2) i (cid:2) n} ∪ {C j: 1 (cid:2) j (cid:2) m} ∪ {ϕ} ∪ {v i: 1 (cid:2) i (cid:2) n}
Aϕ =

(cid:3)¬zi, zi(cid:4), (cid:3)zi, v i(cid:4): 1 (cid:2) i (cid:2) n

∪

∪

(cid:4)

(cid:5)

(cid:4)

(cid:4)

(cid:5)

(cid:3)v i, C j(cid:4): for each ¬zi ∈ C j

(cid:5)

(cid:3)C j, ϕ(cid:4): 1 (cid:2) j (cid:2) m
(cid:4)
∪

(cid:3)zi, C j(cid:4): for each zi ∈ C j

(cid:5)

The weighting function has

(cid:11)

(cid:2)

(cid:3)
(cid:3)x, y(cid:4)

w

=

if (cid:3)x, y(cid:4) = (cid:3)¬zi, zi(cid:4)

1,
n + 1, otherwise

6 In single status semantics this, of course, is equivalent to sceptical acceptance.

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

469

Fig. 5. Acyclic variable setting device in reduction from 3-sat.

The environment for a typical variable x of the cnf ϕ is shown in Fig. 5. The full instance is (cid:3)(cid:3)Xϕ, Aϕ, w(cid:4), n, ϕ(cid:4). Noting that
(cid:3)Xϕ, Aϕ(cid:4) is, indeed, acyclic, we claim this instance is accepted if and only if ϕ(Zn) is accepted as an instance of 3-sat.

First suppose that there is some α ∈ {(cid:7), ⊥}n that satisﬁes ϕ(Zn). Consider the subset Rα of Aϕ given by {(cid:3)¬zi, zi(cid:4):
αi = (cid:7)}. Then wt(R, w) (cid:2) n and, since α satisﬁes ϕ, for each clause C j we can identify a literal y j ∈ C j that is set to (cid:7)
under α. We have two cases:

Case 1: y j = zi . Then the argument zi ∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)) and, hence, C j /∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)).
Case 2: y j = ¬zi . In this case, zi /∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)) and v i ∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)) (from the fact that ¬zi

is always in
ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)), however, the attack (cid:3)¬zi, zi(cid:4) is now in Aϕ \ Rα so precluding zi ). Since (cid:3)v i, C j(cid:4) ∈ Aϕ \ Rα it follows
that C j /∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)).

Thus, for each C j , C j /∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)) and it follows that ϕ ∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)) as required.

On the other hand suppose there is some R ⊆ Aϕ for which wt(R, w) (cid:2) n and ϕ ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)). It must be the
case that R ⊆ {(cid:3)¬zi, zi(cid:4): 1 (cid:2) i (cid:2) n} for otherwise wt(R, w) > n. From ϕ ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)), it follows that ∀C j , C j /∈ ge((cid:3)Xϕ,
Aϕ \ R(cid:4)) and hence u j ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) for some (cid:3)u j, C j(cid:4) ∈ Aϕ \ R. Again we have two cases,

Case 1: u j = v i . In which case zi /∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) (otherwise (cid:3)zi, v i(cid:4) ∈ Aϕ \ R).
Case 2: u j = zi . In which event we must have (cid:3)¬zi, zi(cid:4) ∈ R.

Now, choosing the assignment αR via αi := (cid:7) if zi ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) and αi := ⊥ if v i ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) then αR satisﬁes
ϕ(Zn) (every clause has at least one literal assigned (cid:7)). (cid:2)

As a technical aside, note that the only previously known case for which acyclic systems prove to be intractable (in fact,

with the speciﬁc sub-class of binary trees) are for the canonical decision problems on vafs.

Corollary 1. wcagr is np-complete even when (cid:3)X , A(cid:4) is required to satisfy all of the following properties: (cid:3)X , A(cid:4) is acyclic; (cid:3)X , A(cid:4) is
tripartite; (cid:3)X , A(cid:4) is planar; every x ∈ X is attacked by and attacks at most two other arguments in X .

Proof. The system constructed in Proposition 7 is tripartite — use three colours {B, W , R} and assign ϕ, z j arguments the
colour B; C j arguments the colour W ; v j and ¬z j the colour R. The extension to planar and bounded number of attacks
follows from the construction of Dunne [20]. (cid:2)

We obtain a similar result for the sceptical version, so that as with Proposition 5.

Proposition 8. wsagr is conp-complete even if (cid:3)X , A(cid:4) is acyclic.

Proof. The conp-hardness proof uses a near identical construction to that of Proposition 7: given an instance ϕ(Zn) of unsat-
isﬁability, form the weighted system (cid:3)Xϕ, Aϕ, w(cid:4) described in the proof of Proposition 7 adding an additional argument, ψ ,
whose sole attacker is ϕ. Fix w((cid:3)ϕ, ψ(cid:4)) = n + 1. Then it is easily seen that ∀R ⊆ A: wt(R, w) (cid:2) n ⇒ ψ ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) if
and only if ϕ(Zn) is unsatisﬁable. (cid:2)

By deﬁnition symmetric argument systems contain cycles. For these cases, however, we still have

470

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

Proposition 9. wcagr is np-complete even if (cid:3)X , A(cid:4) is symmetric.

Fig. 6. Symmetric variable setting device in reduction from 3-sat.

Proof. We use a reduction from 3-sat restricted to instances ϕ(Zn) in which every variable zi occurs in exactly three clauses
of ϕ (without loss of generality, exactly two such occurrences are in positive form and exactly one occurrence in negated
−
form). For a variable zi let C
i,3 the (unique) clause
in which ¬zi features. The “variable setting” component is based on that of Fig. 5 and is shown in Fig. 6. The full system,
(cid:3)Xϕ, Aϕ, w(cid:4), formed from ϕ(Zn) has arguments

+
i,2 denote the two clauses in which the literal zi occurs and C

+
i,1 and C

Xϕ = {zi, ¬zi: 1 (cid:2) i (cid:2) n} ∪

(cid:4)

C

+
i,1, C

+
i,2, C

−
i,3: 1 (cid:2) i (cid:2) n

(cid:5)

∪ {ϕ} ∪ {v i: 1 (cid:2) i (cid:2) n}

and attacks

(cid:4)(cid:6)

Aϕ =

(cid:7)

(cid:6)

(cid:7)

(cid:6)

(cid:7)

,

C

C

−
i,3, ϕ

+
i,2, ϕ

+
i,1, ϕ
,
C
(cid:4)
(cid:3)¬zi, zi(cid:4), (cid:3)zi, v i(cid:4): 1 (cid:2) i (cid:2) n
(cid:4)(cid:6)
+
: 1 (cid:2) i (cid:2) n
i,2

: 1 (cid:2) i (cid:2) n
(cid:5)
∪
(cid:5)

zi, C

zi, C

+
i,1

∪

(cid:4)

,

(cid:7)

(cid:7)

(cid:6)

∪

∪

(cid:6)

(cid:7)

(cid:6)

(cid:5)

∪

(cid:4)(cid:6)

+
i,2

ϕ, C

ϕ, C

(cid:7)
+
,
i,1
(cid:3)zi, ¬zi(cid:4), (cid:3)v i, zi(cid:4): 1 (cid:2) i (cid:2) n
(cid:7)
(cid:4)(cid:6)
+
: 1 (cid:2) i (cid:2) n
i,2, zi

+
i,1, zi

−
ϕ, C
i,3
(cid:4)(cid:6)
(cid:5)
∪
(cid:5)

(cid:7)
,

C

C

,

(cid:6)

(cid:5)

(cid:7)
: 1 (cid:2) i (cid:2) n
(cid:6)
−
i,3

v i, C

C

,

(cid:7)

(cid:7)
: 1 (cid:2) i (cid:2) n

(cid:5)

−
i,3, v i

Finally the weighting function has

(cid:2)

(cid:3)
(cid:3)x, y(cid:4)

w

=

0.25,

⎧
⎪⎨

⎪⎩

if (cid:3)x, y(cid:4) ∈ {(cid:3)¬zi, zi(cid:4), (cid:3)v i, zi(cid:4), (cid:3)C
−
i,3, v i(cid:4)}
if (cid:3)x, y(cid:4) ∈ {(cid:3)zi, ¬zi(cid:4), (cid:3)C

+
i, j, zi(cid:4)}

0.5,
n + 1, otherwise

We note that the system (cid:3)Xϕ, Aϕ(cid:4) is symmetric. We claim that ϕ(Zn) is satisﬁable if and only (cid:3)(cid:3)Xϕ, Aϕ, w(cid:4), n, ϕ(cid:4) is
accepted as an instance of wcagr.

Suppose that α = (cid:3)a1, a2, . . . , an(cid:4) deﬁnes a satisfying assignment of ϕ. Set Rα to be the subset of Aϕ containing

(cid:16)

(cid:4)

(cid:3)¬zi, zi(cid:4),

(cid:6)

C

+
i,1, zi

(cid:7)

(cid:6)

,

C

+
i,2, zi

(cid:7)
(cid:5)
, (cid:3)v i, zi(cid:4)

∪

(cid:16)

(cid:4)

(cid:3)zi, ¬zi(cid:4),

(cid:6)

C

(cid:7)(cid:5)

−
i,3, v i

ai =(cid:7)
Then wt(Rα, w) =
α satisﬁes ϕ, every clause C has some literal y assigned (cid:7). As before consider the two possible cases:

ai =⊥(2 × 0.5) = n. In addition, ϕ ∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)). To see this, notice that since

ai =(cid:7)(4 × 0.25) +

ai =⊥

(cid:9)

(cid:9)

Case 1: y = ¬zi (so that C = C

−
i,3)

Case 2: y = zi (so that C ∈ {C

+
i,1, C

+
i,2

})

Then ¬zi ∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)) since Rα contains all attacks on ¬zi . Thus, zi /∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)) and v i ∈ ge((cid:3)Xϕ,
Aϕ \ Rα(cid:4)) (since Rα contains the attack (cid:3)C

−
i,3, v i(cid:4)). It follows that the attack by C

−
i,3 on ϕ is defended by v i .

In this case zi ∈ ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)) (since, again, Rα contains all attacks on zi ). Consequently the attacks by C
+
i,2 on ϕ are defended by zi .
C

+
i,1 and

In summary, every attacker of ϕ is counterattacked by some argument in ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)) and it follows that ϕ ∈
ge((cid:3)Xϕ, Aϕ \ Rα(cid:4)) as a result.

On the other hand suppose that R ⊂ Aϕ is such that wt(R, w) (cid:2) n and ϕ ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)). Then for each C some
attacker u of C must also be in ge((cid:3)Xϕ, Aϕ \ R(cid:4)). Consider the assignment (cid:3)a1, . . . , an(cid:4) of Zn deﬁned by the two possibilities:

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

471

Case 1: u = v i (so that v i ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) and C = C

−
i,3)

From v i ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) and wt(R, w) (cid:2) n we have (cid:3)zi, v i(cid:4) /∈ R thus zi /∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)). Furthermore, in order to
defend the attack by zi on v i some attacker p of zi is in ge((cid:3)Xϕ, Aϕ \ R(cid:4)). Certainly p /∈ {C
} for this contradicts
ϕ ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) or wt(R, w) (cid:2) n. We must, therefore have ¬zi ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) (so that (cid:3)zi, ¬zi(cid:4) ∈ R). In this
case we set ai = ⊥.

+
i,1, C

+
i,2

Case 2: u = zi (so that zi ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) and C ∈ {C

+
i,1, C

+
i,2

}) and we can set ai = (cid:7).

It is easily seen that this assignment is well-deﬁned, i.e., no variable of Zn is assigned both (cid:7) and ⊥ since we cannot have
both zi ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)) and v i ∈ ge((cid:3)Xϕ, Aϕ \ R(cid:4)). In addition the assignment ensures that every clause of ϕ(Zn) has at
least one true literal, i.e., ϕ(Zn) is satisﬁable. (cid:2)

To the best of our knowledge, this is the ﬁrst known intractability result for a canonical decision problem in symmetric
systems. In vafs, the main decision problems are trivial in symmetric systems on account of the normal “consistency”
assumption applied.

Noting that ge((cid:3)X , A(cid:4)) = ∅ whenever (cid:3)X , A(cid:4) is symmetric, the problem wsagr is trivial in such cases (with an inconsis-
tency budget of 0 the grounded extension will be empty). We cannot, therefore, obtain an exact analogue of Proposition 5
gr whose instances are (cid:3)(cid:3)X , A, w(cid:4), x, β, γ (cid:4)
for symmetric systems. If, however, we consider an alternative formulation – wsa>
with γ > β (cid:3) 0 accepted if ∀R ⊆ A(β (cid:2) wt(R, w) (cid:2) γ ) ⇒ x ∈ ge((cid:3)X , A \ R(cid:4)) holds, then

Proposition 10. wsa>

gr is conp-complete even if (cid:3)X , A(cid:4) is symmetric.

5. How much inconsistency do we need?

An obvious question now arises: suppose we have a weighted argument system (cid:3)X , A, w(cid:4) and a set of arguments S.
Then what is the smallest amount of inconsistency β we would need to tolerate in order to obtain T ∈ E wt
σ ((cid:3)X , A, w(cid:4), β) with
S ⊆ T ? Now, when considering initial, conﬂict-free and admissible sets, the answer is easy: we know exactly which attacks
we would have to disregard to make a set of arguments satisfy the speciﬁc criteria imposed — we have no choice in the
matter. However, when considering grounded extensions, the answer is not so easy. As we saw above, there may be multiple
ways of getting a set of arguments into a weighted extension, each with potentially different costs; we are thus typically
interested in solving the following problem:

∗

such that ∃Y ∈ E wt
gr

minimise β

(1)
What can we say about (1)? Consider the following problem. We are given a weighted argument system (cid:3)X , A, w(cid:4) and an
inconsistency budget β ∈ R(cid:2), and asked whether β is minimal, i.e., whether ∀β(cid:15) < β and ∀Y ∈ E wt
gr ((cid:3)X , A, w(cid:4), β(cid:15)), we have
that S (cid:2) Y . (This problem does not require that S is contained in a some β-grounded extension of (cid:3)X , A, w(cid:4).)

(cid:3)X , A, w(cid:4), β

: S ⊆ Y

(cid:2)

(cid:3)

∗

Proposition 11. Given a weighted argument system (cid:3)X , A, w(cid:4), set of arguments S ⊆ X , and inconsistency budget β, checking
whether β is minimal w.r.t. (cid:3)X , A, w(cid:4) and S is conp-complete.

Proof. Consider the complement problem, i.e., the problem of checking whether ∃β(cid:15) < β and ∃Y ∈ E wt
gr ((cid:3)X , A, w(cid:4), β(cid:15)) such
that S ⊆ Y . Membership in np is immediate. For np-hardness, we can reduce sat, using essentially the same construction
for the weighted argument system as Proposition 7; we ask whether n + 1 is not minimal for argument set {ϕ}. (cid:2)

This leads very naturally to the following question: is β the smallest inconsistency budget required to ensure that S is

contained in some β-grounded extension. We refer to this problem as checking whether β is the minimal budget for S.

Proposition 12. Given a weighted argument system (cid:3)X , A, w(cid:4), set of arguments S ⊆ X , and inconsistency budget β, checking
whether β is the minimal budget for S is D p -complete.

Proof. For membership of D p , we must exhibit two languages L1 and L2 such that L1 ∈ np, L2 ∈ conp, and L1 ∩ L2 is the
set of instances accepted by the minimal budget problem. Language L1 is given by Proposition 7, while language L2 is given
by Proposition 11. For hardness, we reduce the Critical Variable Problem (cvp) — for a proof that cvp is D p -complete, see,
e.g., [11]. An instance of cvp is given by a propositional formula ϕ in cnf, and a variable z from ϕ. We are asked if, under
the valuation z = (cid:7) the formula ϕ is satisﬁable, while under the valuation z = ⊥ it is unsatisﬁable. We proceed to create an
instance of the minimal budget problem by using essentially the same construction as Proposition 7, except that the attack
(z, ¬z) is given a weight of 0.5. Now, in the resulting system, n is the minimal budget for {ϕ} iff z is a critical variable
in ϕ. (cid:2)

The problem considered in Proposition 12 only deals with the question of deciding if a speciﬁed budget is, indeed,
minimal. In practice we would actually wish to compute what this minimal budget is or even to compute a subset of A that

472

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

else

return low;

return high;

if (wcagr((cid:3)X , A, low(cid:4), low, x)) then

Algorithm 1 Computing min-budget((cid:3)X , A, w(cid:4), x).
1: function search((cid:3)X , A, w(cid:4), x, low, high)
2: mid := (low + high)/2;
3: if (|high − low| < δ) then
4:
5:
6:
7:
8:
9: end if
10: if (wcagr((cid:3)X , A, w(cid:4), mid, x)) then
11:
12: else
13:
14: end if
15: end
16: δ := min(cid:3)x, y(cid:4)∈A w((cid:3)x, y(cid:4));
17: return search((cid:3)X , A, w(cid:4), x, 0,

return search((cid:3)X , A, w(cid:4), x, mid, high);

return search((cid:3)X , A, w(cid:4), x, low, mid);

(cid:3) y,x(cid:4)∈A w((cid:3) y, x(cid:4)));

end if

(cid:9)

achieves this minimal budget, i.e., given (cid:3)X , A, w(cid:4) and x ∈ X we have two function problems relating to minimal budget
computations.

a. min-budget, Determine the value of the function, β-opt((cid:3)X , A, w(cid:4), x) deﬁned as,

(cid:4)
k ∈ R(cid:2): ∃R ⊆ A with wt(R, w) (cid:2) k and x ∈ ge

(cid:2)

min

(cid:3)(cid:5)

(cid:3)X , A \ R(cid:4)

b. min-witness, Report any subset R of A for which wt(R, w) is minimal among those sets with x ∈ ge((cid:3)X , A \ R(cid:4)).

It should be noted that the function deﬁned by min-witness, which we denote by β-witness will, typically, be multi-valued
whereas that deﬁned by min-budget is single valued. In addition any lower bound on min-budget will, trivially, be a lower
bound on the complexity of β-witness since given a witnessing subset, R, from the computation of β-witness, computing
min-budget simply requires the (polynomial time) calculation

(cid:9)

(cid:3)p,q(cid:4)∈R w((cid:3)p.q(cid:4)).

We now consider the complexity of these function problems.

Proposition 13. min-budget is fpnp

-complete.

Proof. Observe that
(cid:2)

0 (cid:2) β − opt

(cid:3)
(cid:3)X , A, w(cid:4), x

(cid:8)

(cid:2)

(cid:2)

(cid:3)
(cid:3) y, x(cid:4)

w

y:(cid:3) y,x(cid:4)∈A

= wt(A, w) (cid:2) |A| × max
(cid:3) y,z(cid:4)∈A

(cid:2)

(cid:3)
(cid:3) y, z(cid:4)

w

Hence, if the instance (cid:3)(cid:3)X , A, w(cid:4), x(cid:4) is encoded using t bits, the value of β-opt((cid:3)X , A, w(cid:4), x) requires (at most) t2 bits. We
obtain an fpnp
method to compute β − opt((cid:3)X , A, w(cid:4), x) using a standard binary search technique involving O (t2) calls to
an np oracle for wcagr, e.g., as illustrated in Algorithm 1. To show min-budget is fpnp
-hard, we use a reduction from the
following function problem:
lex-min sat: Given ϕ(Zn) a cnf formula Lmin(ϕ) reports the n + 1 bit value corresponding to

(cid:11)

1n+1,
0a1a2 . . . an, where a1a2 . . . an is the lexicographically minimal satisfying assignment of ϕ

if ϕ(Zn) is unsatisﬁable

[For distinct bit sequences a1a2 . . . an, b1b2 . . . bn we say a1 . . . an lexicographically precedes b1 . . . bn if a1 = 0 and b1 = 1 or
(a1 = b1 and a2 . . . an lexicographically precedes b2 . . . bn).]

The function Lmin has been shown to be fpnp

-hard by Krentel [31]. Given an instance ϕ(Zn) of Lmin form the argument
system (cid:3)Xϕ, Aϕ(cid:4) of Proposition 7. We add two arguments {χ , ψ} to this together with attacks {(cid:3)ϕ, χ (cid:4), (cid:3)χ , ψ(cid:4)} letting
Yϕ = Xϕ ∪ {χ , ψ} and Bϕ = Aϕ ∪ {(cid:3)ϕ, χ (cid:4), (cid:3)χ , ψ(cid:4)}. The weighting function in the instance is,

(cid:2)

(cid:3)
(cid:3)x, y(cid:4)

w

=

⎧
⎨

⎩

2i−1,
2n,
2n + 1, otherwise

if (cid:3)x, y(cid:4) = (cid:3)¬zi, zi(cid:4)
if (cid:3)x, y(cid:4) = (cid:3)χ , ψ(cid:4)

To complete the instance of min-budget we set the argument of interest to be ψ . First notice that (via a similar argument
to that of Proposition 7) ϕ(Zn) is unsatisﬁable if and only if the least expensive budget is formed by setting R = {(cid:3)χ , ψ(cid:4)}
at a cost of 2n. Hence β-opt is found to be 2n if and only if the bit string 1n+1 is reported as the value of Lmin(ϕ). If ϕ(Zn)
is satisﬁable, let α = a1a2 . . . an be the corresponding lexicographically minimal satisfying assignment, and Rα = {(cid:3)¬zi, zi(cid:4):
ai = 1}. Via an identical argument to that of Proposition 7 we have ϕ ∈ ge((cid:3)Yϕ, Bϕ \ Rα(cid:4)) thus ψ ∈ ge((cid:3)Yϕ, Bϕ \ Rα(cid:4)). It is

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

473

(cid:9)

i:ai =1 2i−1 (cid:2) 2n − 1. Furthermore, if Rβ ⊂ Bϕ satisﬁed wt(Rβ , w) < wt(Rα) then the lowest
easy to see that wt(Rα, w) =
index attack (cid:3)¬zi, zi(cid:4) in Rβ must be less than the lowest indexed attack (cid:3)¬zi, zi(cid:4) in Rα : this would contradict the deﬁnition
of α as lexicographically minimal. On the other hand, if β-opt((cid:3)(cid:3)Yϕ, Bϕ, w(cid:4), ψ(cid:4)) = b (cid:2) 2n − 1, then letting b1 . . . bn be the
i:bi =1 2i−1, deﬁnes the lexicographically minimal satisfying assignment of ϕ so
n-bit binary representation of b, i.e., b =
that Lmin(ϕ) = 0b1 . . . bn. (cid:2)

(cid:9)

Corollary 2. min-witness is fpnp

-complete.

Proof. That min-witness is fpnp
bound min-witness ∈ fpnp

-hard is immediate from Proposition 13 and the remarks preceding its statement. The upper

follows by, for example the “preﬁx search” method described in [29]. (cid:2)

It may be noted that the reduction in Proposition 13 uses weights whose value is exponential in |X |, e.g., the weighting
of w((cid:3)¬zn, zn(cid:4)) = 2n−1 and |X | = 2n + m + 2 = O (n3). This motivates the question of whether restricting the size of weights,
e.g., insisting that max(cid:3)x, y(cid:4)∈A log w((cid:3)x, y(cid:4)) = O (log |X |) so that the reduction of Proposition 13 no longer applies, could
result in more eﬃcient algorithms for min-budget and min-witness. Notice this question is well motivated in the sense
that in practice we would not expect edge weights to be exponentially large with respect to the number of arguments,
e.g., in moderate size systems of, say 1000 arguments, it seems unlikely that individual attacks with cost 21000 would be
meaningful or that (using R>) a level of precision needed to distinguish 1000 bit values was required.

We say a weighted argument system (cid:3)X , A, w(cid:4) is reasonable if

(cid:2)

(cid:2)

max
(cid:3)x, y(cid:4)∈A

log2

w

(cid:3)(cid:3)

(cid:3)x, y(cid:4)

(cid:2)

(cid:17)
log2

(cid:2)

|X |

(cid:3)(cid:18)

For a reasonable weighted argument system it is immediate that

∀x ∈ X β − opt

(cid:2)

(cid:3)
(cid:3)X , A, w(cid:4), x

(cid:2)
|X | − 1

(cid:3)

(cid:2)

× 2|X | (cid:2) 2|X |2

and, thus, the size of any optimal budget can be represented in O (log |X |) bits.

Proposition 14. For (cid:3)X , A, w(cid:4) restricted to reasonable weighted argument systems,

a. min-budget ∈ fpnp[O (log |X |)] ⊆ fpnp
(cid:23) .
b. min-witness is fpnp

(cid:23) -hard.

Proof. 7 For part (a) it suﬃces to note that in reasonable systems, β-opt((cid:3)X , A, w(cid:4), x) requires at most 2 log |X | + 1 to
encode. Hence using a similar binary search approach to Algorithm 1 will compute β-opt((cid:3)X , A, w(cid:4), x) in O (log |X |) calls
to an oracle for wcagr.

For part (b), consider the following function problem deﬁned on instances ϕ(Zn) of cnf-sat

(cid:11)

Fzero(ϕ) =

1n+1
0α

if ϕ is unsatisﬁable
where α is any maximum number of 0s satisfying assignment

In [14], Fzero is shown to be fpnp
(cid:23) -hard, so in order to prove (b) we show that we can (in polynomial time) transform
instances of Fzero, i.e., cnf formulae ϕ, to instances of min-witness, i.e., reasonable weighted argument systems (cid:3)Xϕ, Aϕ, w(cid:4)
and a speciﬁed argument of these, in such a way that solutions to min-witness((cid:3)Xϕ, Aϕ, w(cid:4), x) (of weight less than n + 1)
have a 1-1 correspondence with satisfying solutions of Fzero(ϕ).

Given ϕ(Zn) in cnf, construct the argument system (cid:3)Yϕ, Bϕ(cid:4) described in Proposition 13. We now use the weighting

function:

(cid:2)

(cid:3)
(cid:3)x, y(cid:4)

w

=

⎧
⎨

⎩

if (cid:3)x, y(cid:4) = (cid:3)¬zi, zi(cid:4)
if (cid:3)x, y(cid:4) = (cid:3)χ , ψ(cid:4)

1,
n + 1,
n + 2, otherwise

The system (cid:3)Yϕ, Bϕ, w(cid:4) is clearly reasonable — |Yϕ| = 3n + m + 3 and the maximum weight of n + 2 requires at most
(cid:24)log2(n + 2)(cid:25) + 1 bits. The complete instance of min-witness is (cid:3)(cid:3)Yϕ, Bϕ, w(cid:4), ψ(cid:4). Now consider any n + 1 binary sequence
α = ba1a2 . . . an deﬁning a solution of Fzero(ϕ). First notice that if α = 1n+1 then ϕ is unsatisﬁable and, as argued in

7 Recall that fpnp[log]
is the class of functions computable by polynomial time algorithms that are allowed to make O (log |I|) queries to an np oracle
on instances, I , encoded in |I| bits; fpnp
is the class of functions computable by polynomial time algorithms that make (polynomially many) non-adaptive
(cid:23)
queries to an np oracle, so that all queries can be viewed as performed simultaneously (in parallel). For the analogous decision classes it is known that
: however, only the relationship fpnp[log] ⊆ fpnp
pnp[log] = pnp
has been proven for the function case [28, Thm. 2.2] and it is conjectured that the contain-
(cid:23)
ment is strict, cf. the series of results from [28, pp. 184–190].

(cid:23)

474

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

Proposition 13, it follows that

min-witness

(cid:2)
(cid:3)Yϕ, Bϕ, w(cid:4), ψ

(cid:3)

(cid:4)

(cid:5)
(cid:3)χ , ψ(cid:4)

=

Similarly it follows that if {(cid:3)χ , ψ(cid:4)} describes the minimal set, R, witnessing ψ ∈ ge((cid:3)Yϕ, Bϕ \ R(cid:4)) then ϕ must be unsatisﬁ-
able and hence Fzero(ϕ) = 1n+1.

Now consider any solution of Fzero(ϕ) in the event that ϕ(Zn) is satisﬁable, so that b = 0 and a1a2 . . . an has a maximum
number of 0 values. Let Rα = {(cid:3)¬zi, zi(cid:4): ai = 1}. Then ψ ∈ ge((cid:3)Yϕ, Bϕ \ Rα(cid:4)) and wt(Rα, w) is minimal amongst subsets
of Bϕ with this property. Similarly given R ⊂ Bϕ with wt(R, w) (cid:2) n and R a solution of min-witness((cid:3)Yϕ, Bϕ, w(cid:4), ψ), the
n + 1 bit sequence 0a1a2 . . . an with ai = 1 if and only if (cid:3)¬zi, zi(cid:4) ∈ R deﬁnes a solution of Fzero(ϕ). (cid:2)

We noted above that one way of deriving a preference order over sets of arguments is to consider the minimal inconsis-
tency budget required to make a set of arguments a solution. A related idea is to count the number of weighted extensions
that an argument set appears in, for a given budget: we prefer argument sets that appear in more weighted grounded exten-
sions. Formally, we denote the rank of an argument set S, given a weighted argument system (cid:3)X , A, w(cid:4) and inconsistency
budget β, by ρ(S, (cid:3)X , A, w(cid:4), β):

(cid:2)

ρ

S, (cid:3)X , A, w(cid:4), β

(cid:3)

(cid:4)

(cid:19)
(cid:19)

=

(cid:2)

Y ∈ E wt
gr

(cid:3)X , A, w(cid:4), β

(cid:3)

: S ⊆ Y

(cid:5)(cid:19)
(cid:19)

Proposition 15. Given a weighted argument system (cid:3)X , A, w(cid:4), argument set S ⊆ X , and inconsistency budget β, computing
ρ(S, (cid:3)X , A, w(cid:4), β) is #P-complete.

(cid:9)

Proof. (Outline) For membership, consider a non-deterministic Turing machine that guesses some subset R of A, and ver-
(cid:3)p,q(cid:4)∈R w((cid:3)p, q(cid:4)) (cid:2) β and S ⊆ ge((cid:3)X , A \ R(cid:4)). The number of accepting computations of this machine will
iﬁes that both
be ρ(S, (cid:3)X , A, w(cid:4), β). For hardness, we can reduce #sat, using the construction of Proposition 7. It is straightforward to
see that the reduction is parsimonious. (cid:2)

5.1. Computing minimal budgets via mixed integer linear programming

fpnp

is perhaps the paradigm complexity class for combinatorial optimisation problems such as the travelling salesman
problem [39, p. 416]. The fact that min-witness is fpnp
-complete suggests that it might therefore be fruitful to apply
techniques developed for combinatorial optimisation to min-witness. In this sub-section, we will show how min-witness
can be formulated as a mixed integer linear program (MILP) [40].

The speciﬁc problem we address is as follows. We are given a weighted argument system (cid:3)X , A, w(cid:4) and some target ar-
gument set Y ⊆ X . We then want to ﬁnd the subgraph R of A such that S is contained in the grounded extension of (cid:3)X , A \
R(cid:4) and wt(R, w) is minimised. The MILP we produce for this is shown in Fig. 7, and makes use of the following variables:

• for all α ∈ X , inα ∈ {0, 1} and outα ∈ {0, 1} are variables that indicate the ﬁnal status of argument α: inα = 1 (outα = 0)
will mean that argument α is in, while inα = 0 (outα = 1) will mean that α is out (of course there is some redundancy
here, we do not need both sets of variables, but it makes the MILP easier to comprehend);

• for all (cid:3)p, q(cid:4) ∈ A, dis(cid:3)p,q(cid:4) ∈ {0, 1} are variables that indicate whether an attack (cid:3)p, q(cid:4) has been “disabled” (dis(cid:3)p,q(cid:4) = 1)
or not (dis(cid:3)p,q(cid:4) = 0), i.e., whether we are choosing disregarding the attack or not — if we disregard an attack, then we
incur its cost;

• for all (cid:3)p, q(cid:4) ∈ A, dead(cid:3)p,q(cid:4) will indicate whether the attack is active (dead(cid:3)p,q(cid:4) = 0) or not (dead(cid:3)p,q(cid:4) = 1): an attack

(cid:3)p, q(cid:4) will be active if both dis(cid:3)p,q(cid:4) = 0 and inp = 1.

The MILP makes use of one subsidiary deﬁnition: we let attacks(α) denote the set of arguments attacking α:

attacks(α) =

(cid:6)

(cid:4)

α(cid:15)

:

α(cid:15)

, α

(cid:7)

(cid:5)

∈ A

The MILP may be understood as follows:

• constraints (3), (4), and (6) say that variables dead(cid:3)p,q(cid:4), dis(cid:3)p,q(cid:4), and inα take a value of either 0 or 1;
• constraint (5) says that all the variables in the target set Y must be “in”;
• constraint (7) states the relationship between inα and outα (and hence ensures that outα variables take 0, 1 values);
• constraint (8) ensures that arguments with no attackers are “in”;
• constraint (9) ensures that variable dead(α,α(cid:15)) takes the value 1 if argument α is out, while constraint (10) ensures that

variable dead(α,α(cid:15)) takes the value 1 if the attack (cid:3)α, α(cid:15)(cid:4) is disabled;

• constraint (11) ensure that dead(cid:3)α,α(cid:15)(cid:4) takes the value 0 if argument α is in and the attack (cid:3)α, α(cid:15)(cid:4) is enabled;
• constraint (12) ensures that if all attacks on an argument α are dead, then α is “in”;
• constraint (13) ensures that if any attack tupleα(cid:15), α is not dead, then α is “out”.

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

475

minimise:

(cid:8)

(cid:2)(cid:6)

w

α, α(cid:15)

(cid:7)(cid:3)

· dis(cid:3)α,α(cid:15)(cid:4)

(cid:3)α,α(cid:15)(cid:4)∈A

subject to constraints:

dead(cid:3)α,α(cid:15)(cid:4) ∈ {0, 1} ∀
(cid:6)

dis(cid:3)α,α(cid:15)(cid:4) ∈ {0, 1} ∀

(cid:7)

∈ A

(cid:6)

α, α(cid:15)
(cid:7)

α, α(cid:15)

∈ A

inα = 1 ∀α ∈ Y

inα ∈ {0, 1} ∀α ∈ X \ Y

outα = 1 − inα ∀α ∈ X

inα = 1 ∀α ∈ X : attacks(α) = ∅

dead(cid:3)α,α(cid:15)(cid:4) (cid:2) outα ∀

(cid:6)

dead(cid:3)α,α(cid:15)(cid:4) (cid:2) dis(cid:3)α,α(cid:15)(cid:4) ∀

(cid:7)

∈ A
(cid:7)

α, α(cid:15)
(cid:6)
α, α(cid:15)

outα + dis(cid:3)α,α(cid:15)(cid:4) (cid:2) dead(cid:3)α,α(cid:15)(cid:4) ∀

(cid:8)

∈ A
(cid:6)

α, α(cid:15)

(cid:7)

∈ A

outα (cid:3)

(1 − dead(cid:3)α(cid:15),α(cid:4)) ∀α ∈ X : attacks(α) (cid:12)= ∅

α(cid:15)∈attacks(α)

outα (cid:2) 1 − dead(cid:3)α(cid:15),α(cid:4) ∀α: attacks(α) (cid:12)= ∅: ∀α(cid:15) ∈ attacks(α)

Fig. 7. MILP for computing least weight grounded extensions.

(2)

(3)

(4)

(5)

(6)

(7)

(8)

(9)

(10)

(11)

(12)

(13)

Note that the w((cid:3)α, α(cid:15)(cid:4)) values will be constants in the MILP we create, which is clearly of size polynomial in the inputs.
In any solution to the MILP, the variables dis(cid:3)α,α(cid:15)(cid:4) such that dis(cid:3)α,α(cid:15)(cid:4) = 1 will be the attacks to disregard: the fact that there
is no smaller cost set is immediate from the objective function (2).

5.2. Positive results

Although credulous and sceptical acceptance are hard for acyclic frameworks, we can describe one class of frameworks

for which these problems (and the budget, witnessing functions mentioned earlier are polynomial time computable).

We ﬁrst note a straightforward simpliﬁcation that can be made to the structure (cid:3)X , A(cid:4).

Lemma 1. Let (cid:3)X , A, w(cid:4) be an arbitrary weighted argument system. We can construct in polynomial time a system (cid:3)X ∪ Y, B, w
for which

(cid:15)(cid:4)

a. For any R ⊆ A for which S = ge((cid:3)X , A \ R(cid:4)) there is a subset R

(cid:15)

of B (identiﬁable in polynomial time) such that wt(R

(cid:15), w) (cid:2)

wt(R, w) and S = ge((cid:3)X ∪ Y, B \ R

(cid:15)(cid:4)) ∩ X .

b. For any R

(cid:15) ⊆ B with S = ge((cid:3)X ∪ Y, B \ R

(cid:15)(cid:4)) there is a subset R of A (identiﬁable in polynomial time) with wt(R, w) (cid:2) wt(R

(cid:15), w)

and S ∩ X = ge((cid:3)X , A \ R(cid:4)).

c. ∀z ∈ X ∪ Y , |{u: (cid:3)u, z(cid:4) ∈ B}| (cid:2) 2 and |{u: (cid:3)z, u(cid:4) ∈ B}| (cid:2) 2.

In simpliﬁed terms Lemma 1 asserts that any weighted argument system may be “simulated” by one in which no

argument attacks or is attacked by more than 2 arguments.

Proof. Let (cid:3)X , A, w(cid:4) a weighted argument system. Consider any z ∈ X for which |{ y: (cid:3) y, z(cid:4) ∈ A}| (cid:3) 3 and let

(cid:4)

(cid:5)
y: (cid:3) y, z(cid:4) ∈ A

= { y1, y2, . . . , yk}

Modify (cid:3)X , A, w(cid:4) as illustrated in Fig. 8 (it is not assumed that (cid:3) yi, y j(cid:4) /∈ A).

The system of Fig. 8, has arguments X ∪ {p, q} and attacks

(cid:4)

B = A \

(cid:3) yi, z(cid:4): 2 (cid:2) i (cid:2) k

(cid:5)

(cid:4)

(cid:5)
(cid:3)p, z(cid:4), (cid:3)q, p(cid:4)

∪

∪

(cid:4)

(cid:3) yi, q(cid:4): 2 (cid:2) i (cid:2) k

(cid:5)

The additional attacks have

(cid:2)

(cid:3)
(cid:3)p, z(cid:4)

w

=

k(cid:8)

i=2

(cid:2)

(cid:3)
(cid:3) yi, z(cid:4)

;

w

(cid:2)

(cid:3)
(cid:3) yi, q(cid:4)

w

(cid:2)

(cid:3)
(cid:3) yi, z(cid:4)

;

= w

(cid:2)

(cid:3)
(cid:3)q, p(cid:4)

w

=

(cid:8)

(cid:2)

(cid:3)
(cid:3)r, s(cid:4)

w

(cid:3)r,s(cid:4)∈A

476

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

Fig. 8. Reducing the number of attacks on arguments.

It is clear that the construction reduces the number of attacks on z to two and creates one additional argument (q) but
which is attacked by only k − 1 (rather than k) arguments. The number of attacks on any other argument is unchanged. It
thus suﬃces to show the following

a. For any R ⊆ A with S = ge((cid:3)X , A \ R(cid:4)) there is some R

(cid:15) ⊆ B for which S = ge((cid:3)X ∪ {p, q}, B \ R

(cid:15)(cid:4)) ∩ X and wt(R

(cid:15), w) (cid:2)

wt(R, w).
b. For any R
(cid:15), w).
wt(R

(cid:15) ⊆ B with S

(cid:15) = ge((cid:3)X ∪ {p, q}, B \ R

(cid:15)(cid:4)) there is some R ⊆ A for which S

(cid:15) ∩ X = ge((cid:3)X , A \ R(cid:4)) and wt(R, w) (cid:2)

For (a) consider any set R ⊆ A and S = ge((cid:3)X , A \ R(cid:4)). Let R y = R ∩ {(cid:3) yi, z(cid:4): 2 (cid:2) i (cid:2) k}. Now consider the subset, R
deﬁned via

(cid:15)

of B

(cid:15) = R \ R y ∪

R

(cid:4)

(cid:3) yi, q(cid:4): (cid:3) yi, z(cid:4) ∈ R y

(cid:5)

(cid:15), w) (cid:2) wt(R, w), since
(cid:8)
(cid:3)

, w

= wt(R, w) −

Certainly wt(R

(cid:2)

(cid:15)

R

wt

Furthermore

(cid:2)

(cid:3)
(cid:3) yi, z(cid:4)

w

+

(cid:8)

yi ∈S y

(cid:2)

(cid:3)
(cid:3) yi, q(cid:4)

w

= wt(R, w)

yi ∈S y

(cid:2)
S = ge

(cid:3)
(cid:3)X , A \ R(cid:4)

(cid:2)(cid:6)

(cid:7)(cid:3)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

= ge

∩ X = S

X ∪ {p, q}, B \ R
For suppose this were not the case. Then either there is some x ∈ S for which x /∈ S
for which x /∈ S. Consider
(cid:15)(cid:4)) and thus there is some argument
the ﬁrst of these — ∃x ∈ S and x /∈ S
u ∈ X ∪ {p, q} for which (cid:3)u, x(cid:4) ∈ B \ R
and (cid:3)u, x(cid:4) /∈ A \ R. The only possible choice for {u, x} is that of x = z and u = p. It
(cid:15)
suﬃces to show that z ∈ S implies q ∈ S
as required. This, however, follows from
as R \ R y ∪ {(cid:3) yi, q(cid:4): (cid:3) yi, z(cid:4) ∈ R y} so that every attack on z in (cid:3)X , A(cid:4) is either defended (hence
z ∈ S and the deﬁnition of R
the corresponding attack on q is also defended in (cid:3)X ∪ {p, q}, B(cid:4) or is an element of R so that the corresponding attack on
q is in R

. Since x ∈ X it follows that x /∈ ge((cid:3)X ∪ {p, q}, B \ R

) from which z ∈ S

(and hence, p /∈ S

We are left only with the second possibility — ∃x ∈ S
must be some u ∈ X with (cid:3)u, x(cid:4) ∈ A \ R and (cid:3)u, x(cid:4) /∈ B \ R
From z ∈ S
must therefore be the case that the attack by u on q is defended in ge((cid:3)X ∪ {p, q}, B \ R
attack by u on z (in (cid:3)X , A \ R(cid:4)) is available, i.e., z ∈ ge((cid:3)X , A \ R(cid:4)) as required.

(cid:15) ⊆ X in order for x /∈ S to hold, there
. Again the only possible choices are x = z and u ∈ { y2, . . . , yk}.
. It
(cid:15)(cid:4)) and an identical defence to the

(cid:15)(cid:4)); from (cid:3)u, z(cid:4) ∈ A \ R it follows that (cid:3)u, q(cid:4) ∈ B \ R

it follows that q ∈ ge((cid:3)X ∪ {p, q}, B \ R

for which x /∈ S. Noting that S

and (cid:3)p, z(cid:4) /∈ R

or some x ∈ S

).

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15)

(cid:15) ⊆ B and S
(cid:15) = ge((cid:3)X ∪ {p, q}, B \ R
(cid:15) ∩ X = ge((cid:3)X , A \ R(cid:4)). Deﬁne R ⊆ A to be

(cid:15)(cid:4)). Consider the set S

(cid:15) ∩ X . We wish to identify R ⊆ A with

For part (b) again let R
(cid:15), w) and S
(cid:4)

wt(R, w) (cid:2) wt(R
(cid:20)

(cid:15) ∩ A ∪
(cid:15) ∩ A ∪

R

R

(cid:4)

(cid:3) yi, z(cid:4): (cid:3) yi, q(cid:4) ∈ R
(cid:5)
(cid:3) yi, z(cid:4): 2 (cid:2) i (cid:2) k
,

(cid:15)

(cid:5)

,

if (cid:3)p, z(cid:4) /∈ R
if (cid:3)p, z(cid:4) ∈ R

(cid:15)

(cid:15)

It is clear that wt(R, w) (cid:2) wt(R

(cid:15), w) and

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

477

(cid:3)
(cid:2)
(cid:3)X , A \ R(cid:4)

ge

∩ X \ {z} = ge

(cid:2)(cid:6)

X ∪ {p, q}, B \ R

(cid:7)(cid:3)

(cid:15)

∩ X \ {z}

so it remains only to show that

z ∈ ge

(cid:2)

(cid:3)
(cid:3)X , A \ R(cid:4)

(cid:2)(cid:6)

⇔ z ∈ ge

X ∪ {p, q}, B \ R

(cid:7)(cid:3)

(cid:15)

It is easy to see (from the deﬁnition of R) that this is the case whenever (cid:3)p, z(cid:4) ∈ R
z ∈ ge((cid:3)X , A \ R(cid:4)) it must be the case that y j ∈ ge((cid:3)X , A \ R(cid:4)) implies (cid:3) y j, z(cid:4) ∈ R so that (cid:3) y j, q(cid:4) ∈ R
(cid:15)
we have y j /∈ ge((cid:3)X , A \ R(cid:4)) ∪ ge((cid:3)X ∪ {p, q}, B \ R
q ∈ ge((cid:3)X ∪ {p, q}, B \ R
z ∈ ge((cid:3)X ∪ {p, q}, B \ R

(cid:15)(cid:4)) since for each (cid:3) y j, q(cid:4) /∈ R
(cid:15)(cid:4)) as required.

. From
(cid:15)
. We deduce that
(cid:15)(cid:4)). In consequence

(cid:15)

, so we may assume (cid:3)p, z(cid:4) /∈ R

(cid:15)

On the other hand suppose that z /∈ ge((cid:3)X , A \ R(cid:4)). Then there is some y j for which y j ∈ ge((cid:3)X , A \ R(cid:4)) and (cid:3) y j, z(cid:4) /∈ R:
(cid:15)(cid:4)) as required. If y j ∈ { y2, . . . , yk}
(cid:15)(cid:4)), we get q /∈ ge((cid:3)X ∪ {p, q}, B \

(cid:15)(cid:4)) so that z /∈ ge((cid:3)X ∪ {p, q}, B \ R
so that, since y j ∈ ge((cid:3)X , A \ R(cid:4)) ∩ ge((cid:3)X ∪ {p, q}, B \ R

and y1 ∈ ge((cid:3)X ∪ {p, q}, B \ R

(cid:15)

(cid:15)

if y j = y1 then (cid:3) y1, z(cid:4) /∈ R
then (cid:3) y j, z(cid:4) ∈ R implies (cid:3) y j, q(cid:4) ∈ R
(cid:15)(cid:4)) and hence z /∈ ge((cid:3)X ∪ {p, q}, B \ R
R

(cid:15)(cid:4)) completing the proof of (b).

It is clear that the construction described can be repeated until all arguments satisfy the speciﬁed conditions. A similar

construction deals with the case |{ y: (cid:3)z, y(cid:4) ∈ A}| (cid:3) 3. (cid:2)

We have shown, in the previous section, that deciding credulous acceptance with respect to a given budget and the
computation of a minimal budget are computationally intractable not only in the case of general weighted argument systems
but also when the supporting system (cid:3)X , A(cid:4) is acyclic or symmetric. These raise the question of the existence of “non-
trivial” restrictions on the topology (cid:3)X , A(cid:4) that admit eﬃcient decision procedures. We now consider one such restriction.
Recall that an argument system (cid:3)X , A(cid:4) is bipartite if X may be partitioned into two sets Y and Z — i.e., Y ∪ Z = X

and Y ∩ X = ∅ — both of which are conﬂict-free.

Proposition 16. If (cid:3)X , A, w(cid:4) is such that (cid:3)X , A(cid:4) is bipartite and acyclic8 then min-budget and min-witness are polynomial time
computable.

Proof. Let (cid:3)Y ∪ Z, A, w(cid:4) be a weighted bipartite acyclic argument system (where (cid:3)Y, Z(cid:4) is the partition of arguments into
two conﬂict-free sets) and suppose y ∈ Y is an argument for which we wish to determine a minimum cost budget and
associated witnessing subset, R of A so that x ∈ ge((cid:3)Y ∪ Z, A \ R(cid:4)). Noting the construction of Lemma 1 preserves both
the properties of bipartition and acyclicity, without loss of generality we may assume no argument of Y ∪ Z attacks or is
attacked by three or more arguments. Consider the subset of A deﬁned by

(cid:4)

(cid:5)
(cid:3)p, q(cid:4) ∈ A: there is a directed path from q to y in (cid:3)Y ∪ Z, A(cid:4)

B y =

If Rmin is a minimal cost subset of A for which y ∈ ge((cid:3)Y ∪ Z, A \ Rmin(cid:4)) then it must be the case that Rmin ⊆ B y :
(cid:3)Y ∪ Z, A(cid:4) is acyclic and so only attacks in B y can inﬂuence whether or not y ∈ ge((cid:3)Y ∪ Z, A \ R(cid:4)). Now consider the
following labelling, θ : Y ∪ Z → {in, fail} of Y ∪ Z

(cid:11)

θ(x) =

in,
fail,

if x = y or (cid:3)x, u(cid:4) ∈ A and θ(u) = fail
if (cid:3)x, u(cid:4) ∈ A and θ(u) = in

This labelling is consistent since (with y ∈ Y ) only arguments in Z could be labelled fail and only arguments in Y could
be labelled in (it is, of course, possible that not all arguments will be labelled, however, these will make no difference to
the minimum budget). The idea behind the algorithm uses the fact that, in order for y ∈ ge((cid:3)Y ∪ Z, A \ R(cid:4)), some defence
to the (at most two) attacks, (cid:3)z1, y(cid:4) and (cid:3)z2, y(cid:4) is required. Such a defence can be formed either by including (cid:3)zi, y(cid:4) ∈ Rmin
or by ensuring that at least one attacker, yi, j of zi also belongs to ge((cid:3)Y ∪ Z, A \ Rmin(cid:4)). Since (cid:3)Y ∪ Z, A(cid:4) is acyclic we
can continue reasoning thus until the case of arguments with no attackers is reached. In summary we can deﬁne the cost
cin(x) of ensuring that x (with θ(x) = in and attackers (a subset of) {u1, u2}) is included in ge((cid:3)Y ∪ Z, A \ R(cid:4)), as follows.
The enumeration below refers to the cases illustrated in Fig. 9.

a. If { y}− = ∅ then

cin( y) = 0

To avoid repetition, in each of the subsequent cases { y}− (cid:12)= ∅.

b. If { y}− ⊆ {u1, u2} with both {u1}− = {u2}− = ∅ then
(cid:3)
(cid:3)u1, y(cid:4)

(cid:3)
(cid:3)u2, y(cid:4)

cin( y) = w

+ w

(cid:2)

(cid:2)

8 It is well known that testing if (cid:3)X , A(cid:4) satisﬁes both conditions can be carried out by polynomial time methods.

478

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

Fig. 9. Cases in deﬁnition of cin( y).

c. If { y}− ⊆ {u1, u2}, {u1}− = ∅, {u2}− = { y1, y2} then
(cid:3)
(cid:3)u1, y(cid:4)

(cid:4)
+ min
cin( y1), cin( y2), w
d. If { y}− = {u1, u2}, {u1}− = { y1, y2}, {u2}− = { y2, y3}

cin( y) = w

(cid:2)

(cid:2)

(cid:3)(cid:5)

(cid:3)u2, y(cid:4)

cin( y) = min

⎧

⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎩

w((cid:3)u1, y(cid:4)) + w((cid:3)u2, y(cid:4))
w((cid:3)u1, y(cid:4)) + cin( y3)
cin( y1) + w((cid:3)u2, y(cid:4))
cin( y1) + cin( y3)
cin( y2)

g. If { y}− ⊆ {u1, u2}, {u1}− = { y1, y2}, {u2}− = { y3, y4} and {u1}− ∩ {u2}− = ∅

e. If { y}− ⊆ {u1, u2}, {u1}− = { y1, y2}, {u2}− = { y2}

cin( y) = min

⎩

w((cid:3)u1, y(cid:4)) + w((cid:3)u2, y(cid:4))
cin( y1) + w((cid:3)u2, y(cid:4))
cin( y2)

f. If { y}− ⊆ {u1, u2}, {u1}− = {u2}− = { y1, y2}
⎧
⎨

cin( y) = min

⎩

w((cid:3)u1, y(cid:4)) + w((cid:3)u2, y(cid:4))
cin( y1)
cin( y2)

cin( y) = min

w((cid:3)u1, y(cid:4)) + w((cid:3)u2, y(cid:4))
w((cid:3)u1, y(cid:4)) + cin( y3)
w((cid:3)u1, y(cid:4)) + cin( y4)
cin( y1) + w((cid:3)u2, y(cid:4))
cin( y2) + w((cid:3)u2, y(cid:4))
cin( y1) + cin( y3)
cin( y1) + cin( y4)
cin( y2) + cin( y3)
cin( y2) + cin( y4)

⎧
⎨

⎧

⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩

Notice that the values cin(x) (for θ(x) = in) are easily computed in polynomial time for each x ∈ Y . To complete the proof,
deﬁne δ(x) when θ(x) = in via

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

479

(cid:11)

δ(x) =

if {x}− = ∅
0,
1 + max{δ( yi): yi ∈ {{x}−}−}, otherwise

An easy inductive argument on δ(x) establishes that cin(x) is the minimal inconsistency budget for x. (cid:2)

6. Combinatorial properties

We ﬁrst note the following “extremal” result. Consider the function, μ((cid:3)X , A, w(cid:4)) deﬁned by

(cid:2)
μ

(cid:3)
(cid:3)X , A, w(cid:4)

= min

(cid:4)

(cid:2)
β: ∃R ⊆ A such that wt(R, w) (cid:2) β and ge

(cid:3)
(cid:3)X , A \ R(cid:4)

(cid:5)

(cid:12)= ∅

i.e., μ((cid:3)X , A, w(cid:4)) is the minimal budget needed to form a non-empty grounded extension within the system (cid:3)X , A(cid:4). Sup-
pose we now deﬁne σ : N → R(cid:2) as

τ (n) =

max
(cid:3)X ,A,w(cid:4): |X |=n

μ((cid:3)X , A, w(cid:4))
wt(A, w)

The following result gives an exact bound on τ (n).

Proposition 17. τ (n) = 1
n .

Proof. To see that τ (n) (cid:3) 1/n, consider the system (cid:3)X , A, w(cid:4) of n arguments {x1, . . . , xn} with attacks {(cid:3)x1, x j(cid:4): 2 (cid:2) j (cid:2) n}
each of weight 1; and {(cid:3)x j, x1(cid:4): 2 (cid:2) j (cid:2) n} each of weight 1/(n − 1). This system has an empty grounded extension and
in order to create a system with a non-empty grounded extension, we can either remove all attacks on x1 (total cost
(n − 1)/(n − 1) = 1) or the single attack on any x j ( j (cid:12)= 1) at cost 1. Hence for μ((cid:3)X , A, w(cid:4)) = 1 and since wt(A, w) =
(n − 1)(1 + 1/(n − 1)) = n the lower bound follows.

For the upper bound ﬁrst observe that, for all (cid:3)X , A, w(cid:4)
(cid:8)

(cid:2)
μ

(cid:3)
(cid:3)X , A, w(cid:4)

(cid:2) min
x∈X

w

y: (cid:3) y,x(cid:4)∈A

(cid:2)

(cid:3)
(cid:3) y, x(cid:4)

i.e., μ((cid:3)X , A, w(cid:4)) cannot be greater than the minimal inconsistency budget required to make a single argument unattacked,
so that

τ (n) (cid:2)

max
(cid:3)X ,A,w(cid:4): |X |=n

minx∈X

y: (cid:3) y,x(cid:4)∈A w((cid:3) y, x(cid:4))
wt(A, w)

(cid:9)

Now for any (cid:3)X , A, w(cid:4)
(cid:2)

(cid:8)

(cid:8)

w

x∈X

y: (cid:3) y,x(cid:4)∈A

and, thus

(cid:3)
(cid:3) y, x(cid:4)

= wt(A, w)

(cid:8)

min
x∈X

y: (cid:3) y,x(cid:4)∈A

(cid:2)

(cid:3)
(cid:3) y, x(cid:4)

w

(cid:2) wt(A, w)
|X |

with equality if and only if for all x, x
(cid:2)

(cid:8)

(cid:8)

(cid:3)
(cid:3) y, x(cid:4)

=

w

(cid:15) ∈ X ,
(cid:2)(cid:6)

w

(cid:7)(cid:3)

(cid:15)
y, x

y: (cid:3) y,x(cid:4)∈A

y: (cid:3) y,x(cid:15)(cid:4)∈A

Hence,

(cid:2)
μ

(cid:3)
(cid:3)X , A, w(cid:4)

(cid:2) wt(A, w)
|X |

×

1
wt(A, w)

= 1
|X |

so that τ (n) (cid:2) 1/n. (cid:2)

Recall that the precise formulation of wcagr asks of an instance (cid:3)(cid:3)X , A, w(cid:4), β, x(cid:4) if there is some R ⊆ A of cost at most
β for which x ∈ ge((cid:3)X , A \ R(cid:4)). If, instead of a single argument x we consider a set of arguments S, certainly the associated
decision problem is as hard (but no harder). Related to this question we have the following,

position:
Instance: (cid:3)X , A, w(cid:4); S ⊆ X .
Question: Is there a subset R of A for which S = ge((cid:3)X , A \ R(cid:4))?

480

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

Fig. 10. Relationship between S, S

+

, A S , z ∈ S

+

and y with { y}− ⊆ S

+

.

Notice the difference between position and wcagr

is that latter asks for a subset, R of A, for which S is a subset
of ge((cid:3)X , A \ R(cid:4)), whereas position asks about the existence of a subset for which S is identical to ge((cid:3)X , A \ R(cid:4)). Now,
although position does not use budgets in its speciﬁcation, one has an obvious function form and associated optimisation
problem:

(cid:2)
opt-posn

(cid:3)X , A, w(cid:4), S

(cid:3)

=

(cid:11)

⊥
min{wt(R, w): S = ge((cid:3)X , A \ R(cid:4))} otherwise

if ¬position((cid:3)X , A, w(cid:4), S)

The strongly-connected component (scc) decomposition of (cid:3)X , A(cid:4) partitions X according to the equivalence classes induced
by the relation ρ(x, y) deﬁned over X × X so that ρ(x, y) holds if and only if x = y or there are directed paths from x
to y and from y to x in (cid:3)X , A(cid:4). We will denote the set of strongly connected components of (cid:3) X, A(cid:4) as {C1, . . . , Ck}, with
Ci = (cid:3)Xi, Ai(cid:4). It is well-known that the graph obtained by considering strongly connected components as single nodes is
acyclic. As a consequence, a partial order ≺ over the scc decomposition {C1, . . . , Ck} is deﬁned as (Ci ≺ C j) ⇔ (i (cid:12)= j) and
∃p ∈ Ci, q ∈ C j such that there is a directed path from p to q.

Proposition 18. position is polynomial time decidable.

Proof. Let (cid:3)(cid:3)X , A, w(cid:4), S(cid:4) be an instance of position. Consider the argument system formed by removing all attacks, R S =
A S ∪ B S , where

(cid:5)

(cid:4)

(cid:4)

A S =
B S =

(cid:3)x, y(cid:4): y ∈ S
(cid:3) y, z(cid:4) ∈ A \ A S : y ∈ S and

(cid:19)
(cid:19)
(cid:19)C(z)
(cid:19) (cid:3) 2

(cid:5)

+

+

where C(x) is the component containing x in the strongly-connected component decomposition of (cid:3)X , A \ A S (cid:4). If S =
ge((cid:3)X , A \ R S (cid:4)) it is immediate that (cid:3)(cid:3)X , A(cid:4), S(cid:4) is accepted as an instance of position. Thus suppose S (cid:12)= ge((cid:3)X , A \ R S (cid:4)).
Noting that every y ∈ S has { y}− = ∅ in (cid:3)X , A \ R S (cid:4) (since A S contains every attack on S), it is certainly the case that
S ⊆ ge((cid:3)X , A \ R S (cid:4)). Thus if these sets differ then ge((cid:3)X , A \ R S (cid:4)) \ S (cid:12)= ∅. It is easy to see that in such cases we must
have an argument x ∈ X \ S for which {x}− ⊆ S
, i.e., in the system (cid:3)X , A \ R S (cid:4) every attacker of x is counterattacked by
some argument of S. It therefore follows that any subset T of A for which S = ge((cid:3)X , A \ T (cid:4)) must be such that there is
no argument x ∈ X \ S for which {x}− ⊆ S
(with respect to (cid:3)X , A \ T (cid:4)). Now suppose, to the contrary that (cid:3)(cid:3)X , A, w(cid:4), S(cid:4)
is a positive instance of position but S (cid:12)= ge((cid:3)X , A \ R S (cid:4)). Let T ⊆ A be such that S = ge((cid:3)X , A \ T (cid:4)). Notice that, without
−
loss of generality, we may assume A S ⊆ T : since S = ge((cid:3)X , A \ T (cid:4)), hence S counterattacks any attacker of S, i.e. y ∈ S
(w.r.t. (cid:3)X , A \ T (cid:4)). Thus T ∪ A S also provides a witnessing subset of A for (cid:3)(cid:3)X , A, w(cid:4), S(cid:4) being accepted.
implies y ∈ S
Now consider the strongly connected component decomposition of (cid:3)X , A \ A S (cid:4) and, in particular, any argument x ∈ X \ S for
which {x}− ⊆ S
(in (cid:3)X , A \ A S (cid:4)). From the premise that S (cid:12)= ge((cid:3)X , A \ R S (cid:4)) we know that such an argument exists. First
observe that |C(x)| = 1: x cannot be in the same component as any argument of S in (cid:3)X , A \ A S (cid:4) since every argument in
S is unattacked in this system. Where it the case that |C(x)| (cid:3) 2 this would contradict {x}− ⊆ S
(since x must be involved
in a mutual attack with some argument not in S). In total, from |C(x)| = 1 and {x}− ⊆ S
it not possible to extend A S to
some subset T in such a way that x is kept out of ge((cid:3)X , A \ T (cid:4)): adding any subset of the attacks on x to T will not affect
{x}− ⊆ S
(in (cid:3)X , A \ T (cid:4)) will then force
z ∈ ge((cid:3)X , A \ T (cid:4)), Fig. 10. (cid:2)

(in (cid:3)X , A \ A S (cid:4)) no longer belongs to S

. Similarly ensuring that some z ∈ S

+

+

+

+

+

+

+

7. Related work

In this section, we formally investigate the relationship of our framework to other related argumentation frameworks
in the literature. Before we present our technical results, we note that there are several other frameworks that should be
mentioned in passing.

First, there are other interesting developments of abstract argumentation such as a framework for defeasible reasoning
about preferences that provides a context dependent mechanism for determining which argument is preferred to which

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

481

[34,37]. This also offers a valuable solution to dealing with multiple extensions, but conceptually and formally the proposal
is complementary to ours. Also of interest are the proposals for introducing information about how the audience views
each argument [11]. In addition, our work is also related to work on possibilistic truth-maintenance systems [18] where
assumptions are weighted, conclusions based on the assumptions inherit the weights, and consistent “environments” are
established. What is particularly reminiscent about the work in [18] is that, again in our terms, it makes use of inconsistency
budget — this is exactly the weight with which the inconsistency ⊥ can be inferred. Anything that can be inferred with a
greater weight than ⊥ is then taken to hold, anything with a lesser weight is taken to be unreliable, which is broadly the
effect of the inconsistency budget in our work.

We note that there has been a good deal of work on incorporating numerical and non-numerical strengths (though not
strengths of attack) into argumentation systems that are not based on Dung’s work. In [30], to take the earliest example,
the use of probability measures and beliefs in the sense of Shafer’s theory of evidence [47], is described. An argumentation
system that uses weights which represent qualitative abstractions of probability values is presented in [41], while in [49],
the weights are inﬁnitesimal probabilities in the sense of [48]. There is also much work on combinations of logic and
probability such as [4,38,43], which, while not explicitly taking the form of argumentation, has much in common with it.

Now, let us turn to the issue of the formal relationship between weighted argument systems and other argumentation
frameworks. The most closely related research with respect to the themes of the current article concern the variety of
proposals building directly on Dung’s original argument system model, in particular those approaches formalising settings
under which attacks in A are disregarded and their associated semantics. In this regard the main contributions of interest
are:

• the preference-based frameworks (pafs) of Amgoud and Cayrol [1];
• the value-based argumentation frameworks (vafs) of Bench-Capon [10];
• resolution-based semantics of Baroni and Giacomin [6,7]; and
• the extended argumentation frameworks (eafs) recently proposed and analysed by Modgil [35,36].

With regard to these formalisms, the two key questions of interest with respect to weighted argument systems are the
following:

Q1: Is it possible (by suitable choice of weighting function and inconsistency budget) always to deﬁne a weighted argument

system that, in some meaningful sense, encapsulates the characteristics of instances of these systems?

Q2: Secondly, are there examples whereby, e.g., the set E wt

gr ((cid:3)X , A, w(cid:4), β), either cannot be described within such systems

or can only be so described using signiﬁcantly larger frameworks?

Before addressing these questions, it is useful to review some common characteristics shared by all of these proposals. One
immediate such feature is that all propose a semantics predicated on removing attacks from a standard Dung-style argu-
ment system (cid:3)X , A(cid:4). What differentiates the proposals is the manner in which an attack (cid:3)x, y(cid:4) ∈ A may be disregarded is
speciﬁed. A second feature common to all of these formalisms is in the nature of those subsets of X which are viewed as
“collectively justiﬁed” following elimination of attacks in (cid:3)X , A(cid:4). Although it is sometimes possible to view these semantics
as “parametric”9 (as is the case for eafs, resolution-based semantics and weighted argument systems), it turns out that the
most useful solution concept derives from the grounded extension. Hence, in keeping with the related approaches, our prin-
cipal focus in the preceding pages has been on properties of E wt
gr ((cid:3)X , A, w(cid:4), β); in preference and value-based frameworks
(having discarded attacks, R ⊆ A which do not succeed) the subset of X in (cid:3)X , A \ R(cid:4) of interest is exactly Egr((cid:3)X , A \ R(cid:4)),
[1, Defn. 3.6, p. 205], [10, Thm. 6.4, p. 438].10 In both [6,7] and [35,36] it has been the reformulation of grounded exten-
sions within the augmented systems that has given rise to interesting issues: although other extension-based semantics
are well-deﬁned within these approaches (as, indeed, is the case with weighted systems), the fact that known complexity
lower bounds, e.g., for credulous and sceptical preferred semantics, trivially, continue to hold renders detailed consideration
of such to be uninteresting. In contrast, given that computational problems concerning grounded extensions are tractable
in (Dung style) afs, the extent to which computationally undesirable properties arise within analogues from augmented
systems is of some importance.

In terms of how such mechanisms related to weighted argument systems the questions highlighted above can now be
more formally phrased as follows: given aug ∈ {paf, vaf, res, eaf} with gr-aug denoting the variant of grounded extensions
and E wt
proposed, what is the relationship (if any) between E aug
gr ?

gr

9 I.e., given an arbitrary Dung argumentation semantics σ : 2
10 Although [10] refers to “preferred extensions” in (cid:3)X , A \ R(cid:4), since this is acyclic it satisﬁes Egr((cid:3)X , A \ R(cid:4)) = Epr((cid:3)X , A \ R(cid:4)). In both paf and vaf
approaches a key property of the preference (resp. value ordering) relations considered is that these have the effect of eliminating some set of attacks, R,
with the result that (cid:3)X , A \ R(cid:4) becomes acyclic.

X → {(cid:7), ⊥} a related semantics based on σ is well-deﬁned for the modiﬁed structures.

482

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

Fig. 11. Ewt

gr (W 3, 2) = {∅, { y}, {x, z}}.

7.1. Preference-based and value-based frameworks

A preference-based argumentation framework (paf) is a triple (cid:3)X , A, (cid:27)(cid:4) where (cid:3)X , A(cid:4) is a Dung-style argumentation
framework and (cid:27)⊆ X × X is a preorder relation over X . Fixing R = {(cid:3)x, y(cid:4) ∈ A: y (cid:27) x} the acceptable arguments of
(cid:3)X , A, (cid:27)(cid:4) are exactly those belonging to ge((cid:3)X , A \ R(cid:4)). Notice that once (cid:27) is ﬁxed, gr-paf is a unique status seman-
tics, i.e., |E paf
gr ((cid:3)X , A, w(cid:4), β) may contain a
number of distinct sets, thus one immediately ﬁnds examples wherein

gr ((cid:3)X , A, (cid:27)(cid:4))| = 1. As we have already seen, in weighted argument systems, E wt

∃w, β∀ (cid:27) E paf
gr

(cid:2)

(cid:3)
(cid:3)X , A, (cid:27)(cid:4)

(cid:2)

(cid:12)= E wt
gr

(cid:3)

(cid:3)X , A, w(cid:4), β

As a simple example of this, we have the system W 3 of Fig. 11: given an inconsistency budget β = 2 yields three β-
grounded extensions: the empty set (removing no attacks); { y} by removing the unit cost attacks {(cid:3)x, y(cid:4), (cid:3)z, y(cid:4)} and {x, z}
by removing either of the attacks (cid:3) y, z(cid:4) or (cid:3) y, x(cid:4) of weight 2.

In contrast we have,

Proposition 19. Let (cid:3)X , A, (cid:27)(cid:4) be any paf. There is a weight function w : A → R> and inconsistency budget β for which
gr (X , A, (cid:27)) ⊆ E wt
E paf

gr ((cid:3)X , A, w(cid:4), β).

Proof. Given (cid:3)X , A, (cid:27)(cid:4), ﬁx R to be

(cid:4)
min

S ⊆ A: ∀(cid:3)x, y(cid:4) ∈ S y (cid:27) x & ge

(cid:2)
(cid:3)
(cid:3)X , A \ S(cid:4)

= ge

(cid:2)(cid:6)

X , A \

(cid:4)

(cid:3)p, q(cid:4): q (cid:27) p

(cid:5)(cid:7)(cid:3)(cid:5)

where min is w.r.t. ⊆. Notice that R is well-deﬁned since the set {(cid:3)p, q(cid:4): q (cid:27) p} has the required property. Now use the
weight function under which w((cid:3)x, y(cid:4)) = 1 for any (cid:3)x, y(cid:4) ∈ R and w((cid:3)x, y(cid:4)) = |X |2 + 1 for all other attacks. Finally set
gr (X , A, (cid:27)) ⊆ E wt
β = |R|. It is immediate, from the choice of S, that E paf

gr ((cid:3)X , A, w(cid:4), β). (cid:2)

A similar construction may be used for vafs w.r.t. a given audience R ⊂ V × V : recall that an audience, R, for a vaf,
(cid:3)X , A, V, η(cid:4), is a (possibly partial) preorder (cid:27)R of V . Given an audience, R, and vaf, (cid:3)X , A, V, η(cid:4) attacks (cid:3)x, y(cid:4) ∈ A are
disregarded should it be the case that η( y) (cid:27)R η(x). When R yields a total ordering of V (so-called speciﬁc audiences), the
reduced framework formed by eliminating (cid:3)x, y(cid:4) ∈ A for which η( y) (cid:27)R η(x) is acyclic. In this case weighted argument
systems can mirror the semantics of speciﬁc audiences in vafs by applying a weighting function w((cid:3)x, y(cid:4)) = 1 for every
(cid:3)x, y(cid:4) ∈ A for which η( y) (cid:27)R η(x) and w((cid:3)x, y(cid:4)) = |X |2 + 1 otherwise.

In general it cannot be guaranteed that w and β may be chosen to give E paf

gr (X , A, (cid:27)) = E wt
gr ((cid:3)X , A, w(cid:4), β) (and similarly
for audiences in vafs): the reason being that E wt
gr ((cid:3)X , A, w(cid:4), β) may contain subsets of X resulting by using an inconsis-
tency budget, γ , which is strictly smaller than that allowed by β in the constructions described. With the construction
described, however, since R is chosen to be minimal we obtain,

gr (X , A, (cid:27)) = E wt
E paf

gr

(cid:2)
(cid:3)X , A, w(cid:4), β

(cid:3)

(cid:2)

\ E wt
gr

(cid:3)X , A, w(cid:4), β − 1

(cid:3)

We conclude with a brief comment regarding the extent to which sets in E wt
gr ((cid:3)X , A, w(cid:4), β) can be captured (using a suit-
able preference order) within E paf
gr (X , A, (cid:27)). As a basic observation we note that since (cid:27) must be transitive it is easy to
construct examples in which S ∈ E wt
gr (X , A, (cid:27)), e.g., choose X = p, q, r,
A = {(cid:3)p, q(cid:4), (cid:3)q, r(cid:4), (cid:3)r, p(cid:4)} with all attacks having weight 1; {p, q, r} ∈ E wt
gr ((cid:3)X , A, w(cid:4), 3) but cannot form the grounded ex-
tension arising from any preference ordering of {p, q, r} (since any such ordering would have to satisfy p (cid:27) r (cid:27) q (cid:27) p).
While, superﬁcially the presence of (potentially) |X |! possible preference orderings would suggest there is suﬃcient scope
subsets of |X | (or at least those expressible as weighted solutions), we note the following property of
to capture all 2
“almost all” pafs.11

gr ((cid:3)X , A, w(cid:4), β) for some choice of β but S /∈ E paf

|X |

Proposition 20. For almost all preference orderings, (cid:27), in almost all afs (cid:3)X , A(cid:4), ge((cid:3)X , A, (cid:27)(cid:4)) = ∅, i.e.

lim
|X |→∞

|{(cid:3)X , A, (cid:27)(cid:4): ge((cid:3)X , A, (cid:27)(cid:4)) (cid:12)= ∅}|
|{(cid:3)X , A, (cid:27)(cid:4): (cid:3)X , A, (cid:27)(cid:4) is a paf}|

= 0

11 We say a property, P , holds for almost all pafs if the proportion of n argument pafs with the property approaches 1 as n → ∞.

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

483

Fig. 12. {{x, y, u}, {x, u, z}} ⊂ Ewt

gr (W 4, 3) \ (Eres

gr

(W 4) ∪ Ewt

gr (W 4, 2)).

Proof. (Outline) An easy counting argument based on the facts that a paf is a directed graph structure and the fraction of
all directed graphs with at least one initial arguments becomes vanishingly small as |X | increases. (cid:2)

In other words, in a precise technical sense, almost all pafs have an empty grounded extension.

∗
7.2. Resolution-based grounded semantics — GR

Given (cid:3)X , A(cid:4), Baroni and Giacomin [7] introduce resolution-based semantics in terms of eliminating mutual attacks

between pairs of arguments. The set of mutually attacking arguments M((cid:3)X , A(cid:4)) consists of those pairs {x, y} ⊆ X

(cid:4)

{x, y}: x (cid:12)= y &

(cid:4)

(cid:5)
(cid:3)x, y(cid:4), (cid:3) y, x(cid:4)

(cid:5)

⊆ A

A (full) resolution of (cid:3)X , A(cid:4) is a subset R of A for which R contains exactly one of the attacks (cid:3)x, y(cid:4) or (cid:3) y, x(cid:4) for each
{x, y} ∈ M((cid:3)X , A(cid:4)). The set of resolution-based grounded extensions (E res

gr ) of (cid:3)X , A(cid:4) is given as

(cid:4)
min

ge(X , A \ R): R is a full resolution of M

(cid:2)

(cid:3)(cid:5)

(cid:3)X , A(cid:4)

where, again, min is w.r.t. ⊆.

Given (cid:3)X , A(cid:4), by assigning w((cid:3)x, y(cid:4)) = w((cid:3) y, x(cid:4)) = 1, if {x, y} ∈ M((cid:3)X , A(cid:4)), and w(((cid:3)x, y(cid:4))) = |X |2 + 1 whenever {x, y} /∈
gr ((cid:3)X , A(cid:4))
gr ((cid:3)X , A, w(cid:4), β) even when a budget of exactly β is used. For example, consider Fig. 12 for

M((cid:3)X , A(cid:4)) with β = |M((cid:3)X , A(cid:4))| it is easily seen that E res
will be a strict subset of E wt
which E res
gr

gr ((cid:3)X , A, w(cid:4), β). Typically, however, E res

is {{u, y}, {x, z}, {x, u}}.

gr ((cid:3)X , A(cid:4)) ⊆ E wt

In this example, E wt

(cid:4)

{x, y, u}, {x, u, z}

gr ((cid:3)X , A, w(cid:4), 3) \ E wt
(cid:2)

gr ((cid:3)X , A, w(cid:4), 2) (cid:12)= E res
(cid:2)

(cid:5)

(cid:3)

⊂ E wt
gr

(cid:3)X , A, w(cid:4), 3

\ E wt
gr

(cid:3)X , A, w(cid:4), 2

(cid:3)

gr ((cid:3)X , A(cid:4)) since

7.3. Extended argumentation frameworks

Recently, Modgil [35,36] has described a development of the basic directed graph formalism in Dung’s systems to en-

compass the notion of attacks being themselves attacked. Formally,

Deﬁnition 7. An extended argumentation framework (eaf) is deﬁned by a triple (cid:3)X , A, D(cid:4) wherein (cid:3)X , A(cid:4) is a standard Dung
argument framework and D ⊆ X × A describes an attack relation whereby arguments are the source of attacks on attacks.12
The relation D must be such that: if {(cid:3)v, (cid:3)x, y(cid:4)(cid:4), (cid:3)u, (cid:3)z, y(cid:4)(cid:4)} ⊆ D then {(cid:3)v, u(cid:4), (cid:3)u, v(cid:4)} ⊆ A.

A set S ⊆ X , is conﬂict-free (within (cid:3)X , A, D(cid:4)) if ∀x, y ∈ S should (cid:3)x, y(cid:4) ∈ A then there is some z ∈ S for which

(cid:3)z, (cid:3)x, y(cid:4)(cid:4) ∈ D. An attack (cid:3)x, y(cid:4) ∈ A succeeds w.r.t S ⊆ X (denoted x →S y) if for every z ∈ S (cid:3)z, (cid:3)x, y(cid:4)(cid:4) /∈ D.

The concept “x ∈ X is acceptable w.r.t. S ⊆ X ” for eafs (which underpins notions of the grounded extension) in-
volves a number of subtleties: recall from Deﬁnition 2 that in standard afs, x is acceptable to S if every attack —
(cid:3) y, x(cid:4) — on x is countered by some attack (cid:3)z, y(cid:4) with z ∈ S. In eafs, given S and x the standard deﬁnition of “x is
acceptable w.r.t. S” fails to consider the possibility that the defence (cid:3)z, y(cid:4) to (cid:3) y, x(cid:4) may itself be attacked by some ar-
gument u, i.e., (cid:3)u, (cid:3) y, z(cid:4)(cid:4) is an element of D and, thus, not only must y be countered but also, if the defence provided
by z is to be used, the argument u must also be attacked by some member of S. In order formally to capture the prop-
erty that “x is acceptable w.r.t. S”, [36] introduces the concept of reinstatement sets for a (successful w.r.t. S) attack
v →S w.

Deﬁnition 8. Given (cid:3)X , A, D(cid:4) let S ⊆ X and v →S w succeed w.r.t. S. A subset R S = { y1 →S z1, y2 →S z2, . . . , yr →S zr}
of those attacks which succeed w.r.t. S is called a reinstatement set for the attack v →S w if R S satisﬁes all of the following
conditions:

12 An alternative model of “attacks being attacked” is also described in Baroni et al. [5].

484

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

Fig. 13. Weighted (W 5) vs. extended argument frameworks.

R1. v →S w ∈ R S .
R2. ∀1 (cid:2) i (cid:2) r yi ∈ S.
R3. For every y →S z ∈ R S and every (cid:3)z

(cid:15), (cid:3) y, z(cid:4)(cid:4) ∈ D there is some y

(cid:15) →S z

(cid:15) ∈ R S .

An argument x ∈ X is acceptable w.r.t. S ⊆ X in the eaf (cid:3)X , A, D(cid:4) if for every successful attack z →S x there is a successful
attack y →S z and a reinstatement set R S for y →S z.

The grounded extension of the eaf (cid:3)X , A, D(cid:4) is formed as

(cid:2)

(cid:3)
(cid:3)X , A, D(cid:4)

=

geeaf

∞(cid:16)

F k

(cid:3)X ,A,D(cid:4)

(cid:3)X ,A,D(cid:4) = ∅, F i+1
where F 0
arguments which are acceptable w.r.t. S.

k=0
(cid:3)X ,A,D(cid:4) = F(cid:3)X ,A,D(cid:4)(F i+1

(cid:3)X ,A,D(cid:4)) and for a conﬂict-free subset S of X , F(cid:3)X ,A,D(cid:4)(S) is the set of

A subset, S is admissible (in the eaf (cid:3)X , A, D(cid:4)) if every x ∈ S is acceptable w.r.t. S; S is preferred if it is a maximal

admissible set.

As observed in [36], the grounded extension is well-deﬁned, but also has a number of distinctive properties. Firstly, in
contrast to Dung style afs, it is not always the case that S ∈ E eaf
pr ((cid:3)X , A, D(cid:4)) implies geeaf((cid:3)X , A, D(cid:4)) ⊆ S, i.e., there are
eafs whose grounded extension contains arguments that do not belong to every preferred extension. Secondly, (and, again,
contrasting with standard systems) there are eafs within which one may identify subsets S and T and arguments x such
that S ⊂ T , x is acceptable w.r.t S but x is not acceptable w.r.t. T .

Recent results, reported in Dunne et al. [25], have established that, in common with other developments of Dung’s
frameworks such as those we have considered above, the problem of determining if x ∈ X is acceptable w.r.t. S ⊆ X in
the eaf (cid:3)X , A, D(cid:4) is polynomial time decidable (and thus computation of the grounded extension as well as verifying S as
an admissible set are also polynomial time problems). In contrast, however, [25] also establish that deciding if a given eaf
exhibits the behaviours mentioned above (i.e., non-sceptically accepted members of the grounded extension, non-monotonic
behaviour of argument acceptability) are likely to be computationally intractable.

Turning to the question of the extent to which eafs can be modelled within weighted systems and vice-versa we note
gr ((cid:3)X , A, D(cid:4))| = 1. Given (cid:3)X , A, D(cid:4) we obtain a weighted system (cid:3)X , A, w(cid:4) and inconsistency budget β

that, again, |E eaf
with E eaf

gr ((cid:3)X , A, D(cid:4)) ⊆ E wt

gr ((cid:3)X , A, w(cid:4), β) as follows.

Observe that in progressing from F 0

(cid:3)X ,A,D(cid:4) to geeaf((cid:3)X , A, D(cid:4)) as described by the process of Deﬁnition 8, typically
a number of attacks in A will be eliminated, e.g. if S1 = F 1
(cid:3)X ,A,D(cid:4) (cid:12)= ∅ then all attacks for which ¬(x →S1 y) can be
removed from A. Deﬁne the set R ⊆ A to contain precisely those attacks which are discarded in the process of build-
ing geeaf((cid:3)X , A, D(cid:4)), i.e., R0 = ∅, R i = {(cid:3)x, y(cid:4): ¬(x →S i y} where S i = F i
(cid:3)X ,A,D(cid:4). Deﬁning the weighted argument system
(cid:3)X , A, w(cid:4) obtained from (cid:3)X , A, D(cid:4) to have weight function w((cid:3)x, y(cid:4)) = 1 if (cid:3)x, y(cid:4) ∈ R and w((cid:3)x, y(cid:4)) = |X |2 + 1 otherwise,
we immediately obtain (using β = |R|) that
(cid:3)

(cid:2)

(cid:2)

(cid:3)

geeaf

(cid:3)X , A, D(cid:4)

∈ E wt
gr

(cid:3)X , A, w(cid:4), β

and, in fact,
(cid:2)

(cid:3)

(cid:2)

(cid:3)

(cid:2)

(cid:3)

E eaf
gr

= E wt
gr

(cid:3)X , A, D(cid:4)

(cid:3)X , A, w(cid:4), β − 1
In summary given an eaf, (cid:3)X , A, D(cid:4) a weighted system (cid:3)X , A, w(cid:4) and budget β can be speciﬁed in which the grounded
extension of (cid:3)X , A, D(cid:4) is recovered. We are left with the question of whether E wt
gr ((cid:3)X , A, w(cid:4), β) can be described within a
related eaf.

(cid:3)X , A, w(cid:4), β

\ E wt
gr

Consider the very basic system of Fig. 13.
With an inconsistency budget of β = 1, we obtain E wt

gr (W 5, 1) = {∅, {x}, { y}}. While a seemingly natural choice of eaf
corresponding to W 5 is to add arguments ( A and B) attacking each weighted attack (such arguments potentially represent-
ing as cases for disposing of either attack), because of the conditions on arguments involved in attacking mutual attacks the
resulting eaf will have an empty grounded extension.

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

485

We note that similar behaviour will be observed when we have mutually attacking arguments for which the weights of

such attacks are equal.

In summary, we have considered four approaches — pafs, vafs, resolution-based, and eafs — each of which offers a
formal basis under which attacks within a standard argument system may be discounted and which have promoted as
the relevant semantics of interest concepts based on the grounded extension. In this article we have introduced another
approach — weighted argument systems — offering a rationale for discounting attacks and focusing on grounded extensions
of the reduced systems. For each of the alternative mechanisms we have argued that the E aug
can be described by a
weighted version of the underlying Dung-style framework and suitable inconsistency budget. In contrast, however, we can
describe quite basic weighted systems and budgets for which E wt
is not encapsulated by replacing weights and budget by
gr
an alternative simplifying mechanism.

gr

8. Conclusions

Several possibilities suggest themselves for future research. The ﬁrst is to investigate speciﬁc interpretations for weights,
as suggested in the paper. Another is to investigate the framework experimentally, to obtain a better understanding of the
way the approach behaves. One obvious issue here is to look for “discontinuities” as the inconsistency budget grows, i.e.,
large increases in the number of accepted arguments for only a small increase in inconsistency budget. Finally, it would be
interesting to consider further the relationship between our framework and the various other argumentation frameworks
and semantics that have been proposed in the literature, as discussed in Section 7.

Acknowledgements

An earlier version of this paper was published at AAMAS-2009.

References

[1] L. Amgoud, C. Cayrol, A model of reasoning based on the production of acceptable arguments, Annals of Mathematics and Artiﬁcial Intelligence 34

(2002) 197–215.

[2] L. Amgoud, N. Maudet, S. Parsons, Modelling dialogues using argumentation, in: E. Durfee (Ed.), Proceedings of the Fourth International Conference on

Multi-Agent Systems, IEEE Press, Boston, MA, USA, 2000, pp. 31–38.

[3] K.J. Arrow, A.K. Sen, K. Suzumura (Eds.), Handbook of Social Choice and Welfare, vol. 1, Elsevier Science Publishers B.V., Amsterdam, The Netherlands,

2002.

[4] F. Bacchus, A.J. Grove, J.Y. Halpern, D. Koller, From statistical knowledge bases to degrees of belief, Artiﬁcial Intelligence 87 (1996) 75–143.
[5] P. Baroni, F. Cerutti, M. Giacomin, G. Guida, Encompassing attacks to attacks in abstract argumentation frameworks, in: Proc. ECSQARU, in: LNAI,

vol. 5590, Springer-Verlag, Berlin, Germany, 2009, pp. 83–94.

[6] P. Baroni, P.E. Dunne, M. Giacomin, Computational properties of resolution-based grounded semantics, in: Proceedings of the Twenty-First International

Joint Conference on Artiﬁcial Intelligence (IJCAI-09), Pasadena, CA, 2009, pp. 683–689.

[7] P. Baroni, M. Giacomin, Resolution-based argumentation semantics, in: Proc. 2nd COMMA, in: FAIA, vol. 172, IOS Press, 2008.
[8] P. Baroni, M. Giacomin, Semantics of abstract argument systems, in: I. Rahwan, G.R. Simari (Eds.), Argumentation in Artiﬁcial Intelligence, Springer,

Berlin, 2009, pp. 25–44.

[9] H. Barringer, D.M. Gabbay, J. Woods, Temporal dynamics of support and attack networks: From argumentation to zoology, in: Mechanizing Mathemat-

ical Reasoning, in: LNCS, vol. 2605, Springer-Verlag, Berlin, Germany, 2005, pp. 59–98.

[10] T.J.M. Bench-Capon, Persuasion in practical argument using value based argumentation frameworks, Journal of Logic and Computation 13 (3) (2003)

429–448.

[11] T.J.M. Bench-Capon, S. Doutre, P.E. Dunne, Audiences in argumentation frameworks, Artiﬁcial Intelligence 171 (1) (2007) 42–71.
[12] L. Bertossi, A. Hunter, T. Schaub (Eds.), Inconsistency Tolerance, LNCS, vol. 3300, Springer-Verlag, Berlin, Germany, 2004.
[13] Ph. Besnard, A. Hunter, Elements of Argumentation, MIT Press, 2008.
[14] H. Burhrman, J. Kadin, T. Thierauf, Functions computable with nonadaptive queries to np, Th. Comput. Systems 31 (1998) 77–92.
[15] C. Cayrol, M.-C. Lagasquie-Schiex, Gradual valuation for bipolar argumentation frameworks, in: Proceedings of the 8th European Conference on Symbolic

and Quantitative Approaches to Reasoning and Uncertainty, in: LNCS, vol. 3571, Springer, 2005, pp. 366–377.

[16] S. Coste-Marquis, C. Devred, P. Marquis, Symmetric argumentation frameworks, in: Proc. 8th ECSQARU, in: LNAI, vol. 3571, Springer-Verlag, Berlin,

Germany, 2005.

[17] Y. Dimopolous, A. Torres, Graph theoretical structures in logic programs and default theories, Theoretical Computer Science 170 (1996) 209–244.
[18] D. Dubois, J. Lang, H. Prade, A possibilistic truth-maintenance system with uncertain justiﬁcations, and its application to belief revision, in: J.P. Martins,

M. Reinfrank (Eds.), Truth Maintenance Systems, in: Lecture Notes in Computer Science, vol. 515, Springer Verlag, 1991, pp. 87–106.

[19] P.M. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games, Artiﬁcial

Intelligence 77 (1995) 321–357.

[20] P.E. Dunne, Computational properties of argument systems satisfying graph-theoretic constraints, Artiﬁcial Intelligence 171 (2007) 701–729.
[21] P.E. Dunne, The computational complexity of ideal semantics I: Abstract argumentation frameworks, in: Proc. 2nd COMMA, in: FAIA, vol. 172, IOS Press,

2008, pp. 147–158.

[22] P.E. Dunne, The computational complexity of ideal semantics, Artiﬁcial Intelligence 173 (2009) 1559–1591.
[23] P.E. Dunne, T. Bench-Capon, Coherence in ﬁnite argument systems, Artiﬁcial Intelligence 141 (2002) 187–203.
[24] P.E. Dunne, M. Caminada, Computational complexity of semi-stable semantics in abstract argumentation frameworks, in: Proc. 11th JELIA, in: LNAI,

vol. 5292, Springer-Verlag, Berlin, Germany, 2008.

[25] P.E. Dunne, S. Modgil, T. Bench-Capon, Computation in extended argumentation frameworks, in: Proc. 19th ECAI, Univ. of Lisbon, Portugal, IOS Press,

August 2010, pp. 119–124.

[26] P.E. Dunne, M. Wooldridge, Complexity of abstract argumentation, in: I. Rahwan, G. Simari (Eds.), Argumentation in Artiﬁcial Intelligence, Springer-

Verlag, Berlin, Germany, 2009.

[27] W. Dvorak, S. Woltran, Complexity of semi-stable and stage semantics in argumentation frameworks, Inf. Proc. Letters 110 (2010) 425–430.

486

P.E. Dunne et al. / Artiﬁcial Intelligence 175 (2011) 457–486

[28] B. Jenner, J. Toran, Computing functions with parallel queries in np, Theoretical Computer Science 141 (1995) 175–193.
[29] B. Jenner, J. Toran, The complexity of obtaining solutions for problems in np and nl, in: Complexity Theory Retrospective II, Springer-Verlag, Berlin,

Germany, 1997, pp. 155–178.

[30] P. Krause, S. Ambler, M. Elvang-Gørannson, J. Fox, A logic of argumentation for reasoning under uncertainty, Computational Intelligence 11 (1) (1995)

113–131.

[31] M. Krentel, The complexity of optimization problems, Journal of Computer and System Sciences 36 (3) (1988) 761–767.
[32] D. Martinez, A. Garcia, G. Simari, An abstract argumentation framework with varied-strength attacks, in: Proceedings of the 11th International Confer-

ence on Principles of Knowledge Representation and Reasoning (KR’08), 2008.

[33] P. Matt, F. Toni, A game-theoretic measure of argument strength for abstract argumentation, in: Proceedings of 11th European Conference on Logics in

Artiﬁcial Intelligence (JELIA’08), in: LNAI, vol. 5293, Springer, 2008, pp. 285–297.

[34] S. Modgil, An abstract theory of argumentation that accommodates defeasible reasoning about preferences, in: Symbolic and Quantitative Approaches

to Reasoning with Uncertainty, in: LNCS, vol. 4724, Springer, 2007.

[35] S. Modgil, Labellings and games for extended argumentation frameworks, in: Proc. 21st IJCAI, 2009, pp. 873–878.
[36] S. Modgil, Reasoning about preferences in argumentation frameworks, Artiﬁcial Intelligence 173 (9–10) (2009) 901–934.
[37] S. Modgil, T. Bench-Capon, Integrating object and meta-level value based argumentation, in: Computational Models of Argument: Proceedings of

COMMA 2008, IOS Press, 2008, pp. 240–251.

[38] E. Neufeld, D. Poole, Towards solving the multiple extension problem: combining defaults and probability, in: L.N. Kanal, T.S. Levitt, J.F. Lemmer (Eds.),

Uncertainty in Artiﬁcial Intelligence, vol. 3, Elsevier Science Publishers, Amsterdam, The Netherlands, 1989, pp. 35–44.

[39] C.H. Papadimitriou, Computational Complexity, Addison-Wesley, Reading, MA, 1994.
[40] C.H. Papadimitriou, K. Steiglitz, Combinatorial Optimization, Prentice Hall International, Hemel Hempstead, England, 1982.
[41] S. Parsons, On precise and correct qualitative probabilistic reasoning, International Journal of Approximate Reasoning 35 (2004) 111–135.
[42] I. Pinyol, J. Sabater-Mir, An argumentation-based dialog for social evaluations exchange, in: M.J. Wooldridge (Ed.), Nineteenth European Conference on

Artiﬁcial Intelligence (ECAI 2010), ECCAI, Lisbon, Portugal, August 2010.

[43] D. Poole, Probabilistic horn abduction and Bayesian networks, Artiﬁcial Intelligence 64 (1993) 81–129.
[44] H. Prakken, G. Sartor, Argument-based logic programming with defeasible priorities, Journal of Applied Non-classical Logics 7 (1997) 25–75.
[45] I. Rahwan, K. Larson, Pareto optimality in abstract argumentation, in: Proceedings of 23rd Conference on Artiﬁcial Intelligence (AAAI’08), AAAI Press,

2008.

[46] I. Rahwan, G.R. Simari (Eds.), Argumentation in Artiﬁcial Intelligence, Springer-Verlag, Berlin, Germany, 2009.
[47] G. Shafer, A Mathematical Theory of Evidence, Princeton University Press, Princeton, NJ, 1976.
[48] W. Spohn, A general non-probabilistic theory of inductive reasoning, in: R.D. Shachter, T.S. Levitt, L.N. Kanal, J.F. Lemmer (Eds.), Uncertainty in Artiﬁcial

Intelligence, vol. 4, Elsevier Science Publishers, Amsterdam, The Netherlands, 1990, pp. 149–158.

[49] V. Tamma, S. Parsons, Argumentation and qualitative reasoning with kappa calculus, in: Proceedings of the 6th European Conference on Symbolic and

Quantitative Approaches to Reasoning with Uncertainty, in: LNCS, vol. 2143, Springer, 2001, pp. 680–691.

[50] F.A. Tohmé, G.A. Bodanza, G.R. Simari, Aggregation of attack relations: a social-choice theoretical analysis, in: S. Hartmann, G. Kern-Isberner (Eds.),

Foundations of Information and Knowledge Systems (FoIKS 2008), Pisa, Italy, 2008, pp. 8–23.

