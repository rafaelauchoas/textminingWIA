Artiﬁcial Intelligence 171 (2007) 730–753

www.elsevier.com/locate/artint

On the merging of Dung’s argumentation systems ✩

Sylvie Coste-Marquis a,∗, Caroline Devred a, Sébastien Konieczny a,
Marie-Christine Lagasquie-Schiex b, Pierre Marquis a

a CRIL-CNRS, Université d’Artois, Lens, France
b IRIT-CNRS, UPS, Toulouse, France

Received 13 November 2006; received in revised form 3 April 2007; accepted 16 April 2007

Available online 29 April 2007

Abstract

In this paper, the problem of deriving sensible information from a collection of argumentation systems coming from different
agents is addressed. The underlying argumentation theory is Dung’s one: each argumentation system gives both a set of arguments
and the way they interact (i.e., attack or non-attack) according to the corresponding agent. The inadequacy of the simple, yet
appealing, method which consists in voting on the agents’ selected extensions calls for a new approach. To this purpose, a gen-
eral framework for merging argumentation systems from Dung’s theory of argumentation is presented. The objective is achieved
through a three-step process: ﬁrst, each argumentation system is expanded into a partial system over the set of all arguments con-
sidered by the group of agents (reﬂecting that some agents may easily ignore arguments pointed out by other agents, as well as how
such arguments interact with her own ones); then, merging is used on the expanded systems as a way to solve the possible conﬂicts
between them, and a set of argumentation systems which are as close as possible to the whole proﬁle is generated; ﬁnally, voting
is used on the selected extensions of the resulting systems so as to characterize the acceptable arguments at the group level.
© 2007 Elsevier B.V. All rights reserved.

Keywords: Argumentation frameworks; Argument in agent system

1. Introduction

Argumentation is based on the exchange and the evaluation of interacting arguments which may represent informa-
tion of various kinds, especially beliefs or goals. Argumentation can be used for modeling some aspects of reasoning,
decision making, and dialogue; as such, it has been applied to several domains, including law. For instance, when
an agent has conﬂicting beliefs (viewed as arguments), a (nontrivial) set of plausible consequences can be derived
through argumentation from the most acceptable arguments for the agent (additional information like a plausibility
ordering are often taken into account in the evaluation phase). Much work has been devoted to this reasoning issue
(see for example [1,13,21,25–27]).

✩ This paper is an extended and revised version of a paper entitled “Merging Argumentation Systems” that appeared in the Proceedings of
AAAI’05, pp. 614–619.
* Corresponding author.

E-mail address: coste@cril.univ-artois.fr (S. Coste-Marquis).

0004-3702/$ – see front matter © 2007 Elsevier B.V. All rights reserved.
doi:10.1016/j.artint.2007.04.012

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

731

Several theories of argumentation exist; many of them make explicit the nature of arguments, the way arguments are
generated, how they interact and how to evaluate them, and ﬁnally a characterization of the most acceptable arguments.
A key issue is the interaction between arguments which is typically based on a notion of attack; for example, when an
argument takes the form of a logical proof, arguments for a statement and arguments against it can be put forward. In
that case, the attack relation relies on logical inconsistency.

Dung’s theory of argumentation includes several formal systems developed so far for commonsense reasoning or
logic programming [13]. It is abstract enough to manage without any assumptions on the nature of arguments or the
attack relation. Indeed, an argumentation system à la Dung consists of a set of (abstract) arguments, together with
a binary relation on it (the attack relation). Several semantics can be used for deﬁning interesting sets of arguments
(so-called extensions) from which acceptable sets of arguments (i.e., the derivable sets) can be characterized.

In a multi-agent setting, argumentation can also be used to represent (part of) some information exchange processes,
like negotiation, or persuasion (see for example [3–5,18,22,24,28]). For instance, a negotiation process between two
agents about whether some belief must be considered as true given some evidence can be modeled as a two-player
game where each move consists in reporting an argument which attacks arguments given by the opponent.

In this paper, we also consider argumentation in a multi-agent setting, but from a very different perspective. Basi-
cally, our purpose is to characterize the set of arguments acceptable by a group of agents, when the data furnished by
each agent consist solely of an (abstract) argumentation system from Dung’s theory.

At a ﬁrst glance, a simple approach for achieving this goal consists in voting on the acceptable sets provided by each
agent: a set of arguments is considered acceptable by the group if and only if it is acceptable for “sufﬁciently many”
agents from the group (where the meaning of “sufﬁciently many” refers to different voting methods). No merging at
all is required here. By means of example, we show that our merging-based approach leads to results which are much
more expected than those furnished by a direct vote on the (sets of) arguments acceptable by each agent.

Our approach is more sophisticated. It follows a three-step process: ﬁrst, each argumentation system is expanded
into a partial system over the set of all arguments considered by the group of agents (reﬂecting that some agents may
easily ignore arguments pointed out by other agents, as well as how such arguments interact with her own ones);
then, merging is used on the expanded systems as a way to solve the possible conﬂicts between them, and a set of
argumentation systems which are as close as possible to the whole proﬁle is generated; ﬁnally, the last step consists
in selecting the acceptable arguments at the group levels from the set of argumentation systems.

In order to reach this goal, we ﬁrst introduce a notion of partial argumentation system, which extends Dung’s
argumentation system so as to represent ignorance concerning the attack relation. This is necessary in our setting
since all the agents participating in the merging process are not assumed to share the same global set of arguments.
Accordingly, the argumentation system furnished by each agent is ﬁrst expanded into a partial argumentation system,
and all such partial systems are built over the same set of arguments, those pointed out by at least one agent. Of
course, there exist many different ways to incorporate a new argument into an argumentation system. Each agent can
have her own expansion policy. We mention some possible policies, and focus on one of them, called the consensual
expansion: when incorporating a new argument into her own system, an agent is ready to conclude that this argument
attacks (resp. is attacked by) another argument whenever all the other agents who are aware of both arguments agree
with this attack; otherwise, she concludes that she ignores whether an attack takes place or not.

Once all the expansions of the input argumentation systems have been computed, the proper merging step can be
achieved; it consists in computing all the argumentation systems over the global set of arguments which are “as close
as possible” to the partial systems generated during the last stage. Closeness is characterized by a notion of distance
between an argumentation system and a proﬁle of partial systems, induced from a primitive notion of distance between
partial systems and an aggregation function. Several primitive distances and aggregation functions can be used; we
mainly focus on the edit distance (which is, roughly speaking, the number of insertions/deletions of attacks needed to
turn a given system into another one), and consider sum, max and leximax as aggregation functions.

Like the input of the overall merging process, the result of the merging step is a set of argumentation systems.
However, while the ﬁrst one reﬂects different points of view (since each system is provided by a speciﬁc agent), the
second set expresses some uncertainty on the merging due to the presence of conﬂicts. The last step of the process
consists in deﬁning the acceptable arguments for the group under the uncertainty provided by this set of argumentation
systems. Once again, several sensible deﬁnitions are given. We show that the sets of arguments considered acceptable
when the input is the set of argumentation systems primarily furnished by the agents may drastically differ from the

732

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

sets of arguments considered acceptable after the merging step, and by means of example, we show that the latter ones
are more in accordance with the intuition.

The rest of the paper is organized as follows. After a refresher on Dung’s theory of argumentation (in which our
approach takes place), we give a simple motivating example (Section 3) which shows that voting on the arguments
accepted by each agent is not adequate for deﬁning the arguments accepted by the group. Then we introduce a notion
of partial argumentation system (Section 4) which extends the notion of argumentation system and enables to handle
the case when agents do not share the same set of arguments. On this ground, we deﬁne a family of merging operators
for argumentation systems (Section 5) and we study the properties of some of them (especially, those based on the
edit distance) (Section 6). Then, we focus on acceptability for partial argumentation systems (Section 7). Finally, we
conclude the paper and give a short presentation of some possible reﬁnements of our framework (Section 8).

2. Dung’s theory of argumentation

Let us present some basic deﬁnitions at work in Dung’s theory of argumentation [13]. We restrict them to ﬁnite

argumentation frameworks.

Deﬁnition 1 (Argumentation system (AF)). A (ﬁnite) argumentation system AF = (cid:3)A, R(cid:4) over A is given by a ﬁnite set
A of arguments and a binary relation R on A called an attack relation. aiRaj means that ai attacks aj (also denoted
by (ai, aj ) ∈ R).

For our study, we are not interested in the structure of arguments and we consider an arbitrary attack relation.
(cid:3)A, R(cid:4) deﬁnes a directed graph G called the attack graph.

Example 2. The argumentation system AF = (cid:3)A = {a1, a2, a3, a4}, R = {(a2, a3), (a4, a3), (a1, a2)}(cid:4) deﬁnes the fol-
lowing graph G:

Acceptability is about the selection of the most acceptable arguments. Two mainstream approaches exist:

• Individual acceptability: acceptability of an argument depends only on its properties (see [2,16]);
• Collective acceptability: an argument can be defended by other arguments; in this case, the acceptability of a set

of arguments is considered (see [13]).

Dung’s theory is concerned with the second approach. Whether an argument can be accepted depends on the way
arguments interact. Collective acceptability is based on two key notions: lack of conﬂict between arguments and
collective defense.

Deﬁnition 3. (See [13].) Let (cid:3)A, R(cid:4) be an argumentation system.

Conﬂict-free set A set E ⊆ A is conﬂict-free if and only if (cid:2)a, b ∈ E such that aRb.
Collective defense Consider E ⊆ A, a ∈ A. E (collectively) defends a if and only if ∀b ∈ A, if bRa, then ∃c ∈ E
such that cRb (a is said acceptable w.r.t. E). E defends all its elements if and only if ∀a ∈ E, E collectively
defends a.

Dung deﬁnes several semantics for collective acceptability based on those two notions [13]. Among them the

admissible semantics, the preferred semantics, the stable semantics and the grounded semantics.

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

733

Deﬁnition 4. (See [13].) Let (cid:3)A, R(cid:4) be an argumentation system.

Admissible semantics A set E ⊆ A is admissible if and only if E is conﬂict-free and E defends all its elements.
Preferred semantics A set E ⊆ A is a preferred extension if and only if E is maximal for set inclusion among the

admissible sets.

Stable semantics A set E ⊆ A is a stable extension if and only if E is conﬂict-free and every a ∈ A \ E is attacked

by an element of E.

Grounded semantics The grounded extension of (cid:3)A, R(cid:4) is the smallest subset of A with respect to set inclusion among
the subsets of A which are admissible and coincide with the set of arguments acceptable w.r.t. itself.

Note that in all the above deﬁnitions, each attacker of a given argument is considered independently of the other
attackers (there is no way to represent synergetic effects and the possibility to quantify all attackers as a whole is not
considered—there exist other works which are concerned with this aspect, see [6,8–10,19,23]).

Deﬁnition 5 (Well-founded argumentation system [13]). An argumentation framework AF = (cid:3)A, R(cid:4) is well-founded
if and only if there does not exist an inﬁnite sequence a0, a1, . . . , an . . . of arguments from A, such that for each i,
ai+1Rai .

Among other things, It is shown in [13] that:

• Any admissible set of (cid:3)A, R(cid:4) is included in a preferred extension of (cid:3)A, R(cid:4).
• Each (cid:3)A, R(cid:4) has at least one preferred extension.
• Each (cid:3)A, R(cid:4) has exactly one grounded extension of (cid:3)A, R(cid:4) and this extension is included in each preferred exten-

sion.

• If (cid:3)A, R(cid:4) is well-founded then it has a unique preferred extension which is also the only stable extension and the

grounded extension.

• Any stable extension of (cid:3)A, R(cid:4) is also a preferred extension (the converse is false).
• Some (cid:3)A, R(cid:4) do not have a stable extension.

The acceptability status of each subset of arguments can now be deﬁned by the following relation:

Deﬁnition 6 (Acceptability relation). An acceptability relation, denoted by AccAF, for a given argumentation system
AF = (cid:3)A, R(cid:4), is a total function from 2A to {true, false} which associates each subset E of A with true if E is an
acceptable set for AF and with false otherwise.

Usually, an acceptability relation is based on a speciﬁc semantics (plus a selection principle). For instance, a set
of arguments can be considered acceptable if and only if it is included in one extension (credulous selection) or in
every extension (skeptical selection). Alternatively, a set of arguments can be considered acceptable if and only if it
coincides with one extension for the chosen semantics. Whatever the way it is deﬁned, an acceptability relation can
be viewed as a choice function among the elements of 2A. In this context, the “acceptability of an argument” a can
correspond either to the acceptability of the singleton {a}, or to the membership of a to an acceptable set (see [12]).

3. Simple is not so beautiful

Given a proﬁle (i.e., a vector) P = (cid:3)AF1, . . . , AFn(cid:4) of n AFs (with n (cid:2) 1) where each AFi = (cid:3)Ai, Ri(cid:4) represents
i Ai which are acceptable by the group of n

the data given by Agent i, our purpose is to determine the subsets of
agents. Voting is one way to achieve this goal.

(cid:2)

3.1. Voting is not enough

Indeed, a simple approach to address the problem consists in considering a set of arguments acceptable for the
group when it is acceptable for “sufﬁciently many” agents of the group. The voting method under consideration makes

734

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

precise what “sufﬁciently many” means: it can be, for instance, simple majority. Let us illustrate such an approach on
an example:

Example 7. Consider the three following argumentation systems:

• AF1 = (cid:3){a, b, e, f }, {(a, b), (b, a), (e, f )}(cid:4),
• AF2 = (cid:3){b, c, d, e, f }, {(b, c), (c, d), (f, e)}(cid:4),
• AF3 = (cid:3){e, f }, {(e, f )}(cid:4).

Whatever the chosen semantics (among Dung’s ones), c does not belong to any extension of AF2. As c is not known
by the two other agents, it cannot be considered as acceptable by the group whatever the voting method (under the
reasonable assumption that it is a choice function based on extensions, i.e., only subsets of an extension of an AFi are
eligible as acceptable sets). However since c (resp. a) is not among the arguments reported by the ﬁrst agent and the
third one (resp. the second and the third ones), it can be sensible to assume that the three agents agree on the fact that
a attacks b, b attacks a and b attacks c. Indeed, this assumption is compatible with any of the three argumentation
systems reported by the agents. Under this assumption, it makes sense to consider {c} credulously acceptable for the
group given that c is considered defended by a against b by Agent 1 and there is no conﬂicting evidence about it in
the AFs provided by the two other agents.

As this example illustrates it, our claim is that, in general, voting is not a satisfying way to aggregate the data

furnished by the different agents under the form of argumentation systems. Two problems arise:

Problem 1. Voting makes sense only if all agents consider the same set of arguments A at start (otherwise, the set 2A
of alternatives is not common to all agents). However, it can be the case that the sets of arguments reported by the
agents differ from one another.

Problem 2. Voting relies only on the selected extensions: the attack relations (from which extensions are character-
ized) are not taken into consideration any more once extensions have been computed. This leads to much signiﬁcant
information being set aside which could be exploited to deﬁne the sets of acceptable arguments at the group level.

3.2. Union is not merging (in general)

(cid:2)

In order to solve both problems, a simple approach (at a ﬁrst glance) consists in forming the union of the argu-
(cid:3)Ai, Ri(cid:4) and deﬁned
(cid:2)
n
i=1 Ri(cid:4). Unfortunately, such a merging approach to argumentation systems cannot be taken

mentation systems AF1, . . . , AFn, i.e., considering the argumentation system denoted AF =
by AF = (cid:3)
seriously. Let us illustrate it on our running example:
(cid:2)

n
i=1 Ai,

n
i=1

(cid:2)

3
i=1 AFi = (cid:3){a, b, c, d, e, f }, {(a, b), (b, a), (b, c), (c, d), (e, f ),

Example 7 (continued). The resulting AF is
(f, e)}(cid:4).

Example 7 shows that the union approach to merging argumentation systems suffers from a major problem: it solves
conﬂicts by giving to the explicit attack information some undue prominence to implicit non-attack information. Thus,
when a pair of arguments (like, say (f, e)) does not belong to the attack relation furnished by an agent (say, Agent 1)
while both arguments (f and e) belong to the set of arguments she points out, the meaning is that for Agent 1,

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

735

argument f does not attack argument e. Imagine now that in the considered proﬁle of argumentation systems, 999
agents report the same system as Agent 1, and the 1000th agent is Agent 2. In the resulting argumentation system
considered at the group level, assuming that union is used as a merging operator, it will be the case that f attacks e
while 999 agents over 1000 believes that it is not the case!

4. Partial argumentation systems

The example introduced in the previous section has illustrated that different cases must be taken into account:

• an argument exists in the argumentation system AF1 of one of the agents and does not exist in the argumentation

system AF2 of at least another agent;

• an interaction between two arguments exists in the argumentation system AF1 of one agent and does not exist in

the argumentation system AF2 of at least another agent.

In the ﬁrst case, the new argument can be added to AF2 but the question is what to do for the interactions between

this new argument and the other arguments of AF2.

In the second case, things are different: if an interaction between two arguments a and b exists in a system AF1
and not in another system AF2, even when a and b are in AF2, we cannot add the interaction in AF2 (that Agent 2
did not include this attack in AF2 is on purpose). Indeed, if an interaction is not present in an AF, it means that this
interaction does not exist for the corresponding agent. The consequence of this is the necessity to discriminate among
several cases whenever an argument a has to be added to an AF. Let b be an argument of the AF under consideration,
three cases must be considered:

• the agent believes that the interaction (a, b) exists (attack);
• the agent believes that the interaction (a, b) does not exist (non-attack);
• the agent does not know whether the interaction (a, b) exists (ignorance).

The ﬁrst two cases express the fact that the knowledge of the agent is sufﬁcient for computing the new interaction
concerning a. The third case expresses that the agent is not able to compute the new interaction concerning a and the
arguments she pointed out (several reasons can explain it, especially a lack of information, or a lack of computational
resources).

Handling these different kinds of information within a uniform setting calls for an extension1 of the notion of

argumentation systems, that we call partial argumentation systems.

Deﬁnition 8 (Partial argumentation system (PAF)). A (ﬁnite) partial argumentation system over A is a quadruple
PAF = (cid:3)A, R, I, N(cid:4) where

• A is a ﬁnite set of arguments,
• R, I, N are binary relations on A:

– R is the attack relation,
– I is called the ignorance relation and is such that R ∩ I = ∅,
– and N = (A × A) \ (R ∪ I ) is called the non-attack relation.

N is deduced from A, R and I , so a partial argumentation system can be fully speciﬁed by (cid:3)A, R, I (cid:4). We use both

notations in the following.

1 In [11], a new binary relation on the arguments is also introduced in Dung’s argumentation framework: however, this new relation represents
a notion of support between arguments. Clearly enough, this is unrelated with the relation introduced here representing the ignorance about the
attack between arguments.

736

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

Each AF is a particular PAF for which the set I is empty (we say that such an AF is equivalent to the associated
PAF). In an AF, the N relation also exists even if it is not given explicitly (I = ∅ and N = A × A \ R). So, an AF
could also be denoted by (cid:3)A, R, N(cid:4).

Each PAF over A can be viewed as a compact representation of a set of AFs over A, called its completions:

Deﬁnition 9 (Completion of a PAF). Let PAF = (cid:3)A, R, I (cid:4). Let AF = (cid:3)A, S(cid:4). AF is a completion of PAF if and only if
R ⊆ S ⊆ R ∪ I .

The set of all completions of PAF is denoted C(PAF).

Example 10. The partial argumentation system PAF = (cid:3)A = {a, b, c, d}, R = {(a, b), (a, c)}, I = {(c, a), (b, d)},
N = {(a, a), (b, b), (c, c), (d, d), (b, a), (b, c), (c, b), (a, d), (d, a), (d, b), (c, d), (d, c)}(cid:4) is illustrated on the follow-
ing ﬁgure (solid arrows represent the attack relation and dotted arrows represent the ignorance relation; non-attack
relations are not represented explicitly as in the AF case):

The completions of this PAF are:

Now, Problem 1 can be addressed by ﬁrst associating each argumentation system AFi with a corresponding PAFi
(cid:2)
n
i=1 Ai . To this end, we introduce the notion of expansion of

so that all PAFi are about the same set of arguments
an AF:

Deﬁnition 11 (Expansion of an AF). Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of n AFs such that AFi = (cid:3)Ai, Ri, Ni(cid:4).
Let AF = (cid:3)A, R(cid:4) be an argumentation system. An expansion of AF given P is any PAF exp(AF, P) deﬁned by
i Ai, R(cid:12), I (cid:12), N (cid:12)(cid:4) such that R ⊆ R(cid:12) and (A × A) \ R ⊆ N (cid:12). exp is referred to as an expansion function.
(cid:3)A ∪

(cid:2)

In order to be general enough, this deﬁnition does not impose many constraints on the resulting PAF: what is
important is to preserve the attack and non-attack relations from the initial AF while extending its set of arguments.
Many policies can be used to give rise to expansions of different kinds, reﬂecting the various attitudes of agents in
light of “new” arguments; for instance, if a is any argument considered by Agent i at the start and a “new” argument
b has to be incorporated, Agent i can (among other things):

• always reject b (e.g., adding (b, b) to her relation R(cid:12)
• always accept b (adding (a, b), (b, a) and (b, b) to her non-attack relation N (cid:12)
i ),
• just express her ignorance about b (adding (a, b), (b, a) and (b, b) to her ignorance relation I (cid:12)
i ).

i ),

Each agent may also compute the exact interaction between a and b when the attack relation is not primitive but
deﬁned from more basic notions (as in the approach by Elvang-Gøransson et al., see e.g., [15–17]). Note that if she
has limited computational resources, Agent i can compute exact interactions as far as she can, then express ignorance
for the remaining ones.

In the following, we speciﬁcally focus on consensual expansions. Intuitively, the consensual expansion of an ar-
gumentation system AF = (cid:3)A, R(cid:4) given a proﬁle of such systems is obtained by adding a pair of arguments (a, b)
(where at least one of a, b is not in A) into the attack (resp. the non-attack relation) provided that all other agents of

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

737

the proﬁle who know the two arguments agree on the existence of the attack2 (resp. the non-attack); otherwise, it is
added to the ignorance relation.

This expansion policy is sensible as soon as each agent has a minimum level of conﬁdence in the other agents: if
a piece of information conveyed by one agent is not conﬂicting with the information stemming from the other agents,
every agent of the group is ready to accept it.

Deﬁnition 12 (Consensual expansion). Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of n AFs such that AFi = (cid:3)Ai, Ri(cid:4).
Let AF = (cid:3)A, R, N(cid:4) be an argumentation system. Let conf (P) = (
i Ni) be the set of interactions for
which a conﬂict exists within the proﬁle. The consensual expansion of AF over P is the tuple denoted by expC =
(cid:3)A(cid:12), R(cid:12), I (cid:12), N (cid:12)(cid:4) with:

i Ri) ∩ (

(cid:2)

(cid:2)

(cid:2)

i Ai ,
(cid:2)

• A(cid:12) = A ∪
• R(cid:12) = R ∪ ((
• I (cid:12) = conf (P) \ (R ∪ N),
• N (cid:12) = (A(cid:12) × A(cid:12)) \ (R(cid:12) ∪ I (cid:12)).

i Ri \ conf (P)) \ N),

The next proposition states that, as expected, the consensual expansion of an argumentation system over a proﬁle

is an expansion:

Proposition 13. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of n AFs such that AFi = (cid:3)Ai, Ri(cid:4). Let AF = (cid:3)A, R, N(cid:4) be an
argumentation system. The consensual expansion expC of AF over P is an expansion of AF over P in the sense of
Deﬁnition 11.

Proof. Consider (a, b) ∈ A(cid:12) × A(cid:12). There are several cases:

• if (a, b) ∈ R then (a, b) ∈ R(cid:12) and (a, b) /∈ I (cid:12) ∪ N (cid:12) (so, R ⊆ R(cid:12));
• if (a, b) /∈ R and (a, b) ∈ N then (a, b) /∈ I (cid:12) ∪ R(cid:12) and (a, b) ∈ N (cid:12) (so, N ⊆ N (cid:12));
• if (a, b) /∈ R ∪ N then there are two cases:

– if (cid:2)AFi ∈ P such that a, b ∈ Ai then (a, b) /∈ conf (P); so, (a, b) ∈ N (cid:12) and (a, b) /∈ R(cid:12) ∪ I (cid:12);
– if ∃AFi ∈ P such that a, b ∈ Ai then we have 4 possible cases:

if (a, b) ∈ Ri and (cid:2)AFj ∈ P such that (a, b) ∈ Nj then (a, b) /∈ conf (P); so, (a, b) ∈ R(cid:12) and (a, b) /∈ N (cid:12) ∪ I (cid:12);
if (a, b) ∈ Ri and ∃AFj ∈ P such that (a, b) ∈ Nj then (a, b) ∈ conf (P); so, (a, b) ∈ I (cid:12) and (a, b) /∈ R(cid:12) ∪ N (cid:12);
if (a, b) ∈ Ni and (cid:2)AFj ∈ P such that (a, b) ∈ Rj then (a, b) /∈ conf (P); so, (a, b) ∈ N (cid:12) and (a, b) /∈ R(cid:12) ∪ I (cid:12);
if (a, b) ∈ Ni and ∃AFj ∈ P such that (a, b) ∈ Rj then (a, b) ∈ conf (P); so, (a, b) ∈ I (cid:12) and (a, b) /∈ R(cid:12) ∪ N (cid:12).

So, R(cid:12), I (cid:12) and N (cid:12) form a partition of A(cid:12) × A(cid:12) which satisﬁes R ⊆ R(cid:12) and N ⊆ N (cid:12). (cid:2)

The consensual expansion is among the most cautious expansions one can deﬁne since it leads to adding a pair of
arguments in the attack (or the non-attack relation) associated with an agent only when all the other agents agree on it.

Example 14. Consider the proﬁle consisting of the following four argumentation systems:

• AF1 = (cid:3)A1 = {a, b}, R1 = {(a, b), (b, a)}(cid:4),
• AF2 = (cid:3)A2 = {b, c, d}, R2 = {(b, c), (c, d)}(cid:4),
• AF3 = (cid:3)A3 = {a, b, d}, R3 = {(a, b), (a, d)}(cid:4),
• AF4 = (cid:3)A4 = {a, b, d}, R4 = {(b, d), (b, a)}(cid:4).

2 i.e., if a, b ∈ Ai , then (a, b) ∈ Ri .

738

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

For each i, the consensual expansion PAFi of AFi is given by:

• PAF1 = (cid:3){a, b, c, d}, {(a, b), (b, a), (b, c), (c, d)}, {(a, d), (b, d)}(cid:4),
• PAF2 = (cid:3){a, b, c, d}, {(b, c), (c, d)}, {(a, b), (b, a), (a, d)}(cid:4),
• PAF3 = (cid:3){a, b, c, d}, {(a, b), (a, d), (b, c), (c, d), {}}(cid:4),
• PAF4 = (cid:3){a, b, c, d}, {(b, d), (b, a), (b, c), (c, d), {}}(cid:4).

When the expansion policies considered by each agent are the same one exp, for any proﬁle P = (cid:3)AF1, . . . , AFn(cid:4)

we shall often note exp(P) the proﬁle of PAFs (cid:3)exp(AF1, P), . . . , exp(AFn, P)(cid:4).

5. Merging operators

In order to deal with Problem 2, we propose to merge interactions instead of sets of acceptable arguments. The
goal is to characterize the argumentation systems which are as close as possible to the given proﬁle of argumentation
systems, taken as a whole.

A way to achieve this consists in deﬁning a notion of “distance” between an AF and a proﬁle of AFs, or more
generally between a PAF and a proﬁle of PAFs. This calls for a notion of pseudo-distance between two PAFs, and
a way to combine such pseudo-distances:

Deﬁnition 15 (Pseudo-distance). A pseudo-distance d between PAFs over A is a mapping which associates a non-
negative real number to each pair of PAFs over A and satisﬁes the properties of symmetry (d(x, y) = d(y, x)) and
minimality (d(x, y) = 0 if and only if x = y).

d is a distance if it satisﬁes also the triangular inequality (d(x, z) (cid:3) d(x, y) + d(y, z)).

Deﬁnition 16 (Aggregation function). An aggregation function is a mapping ⊗ from (R+)n to (R+) (strictly speaking,
it is a family of mappings, one for each n), that satisﬁes

i , then ⊗(x1, . . . , xi, . . . , xn) (cid:2) ⊗(x1, . . . , x(cid:12)

i, . . . , xn),

• if xi (cid:2) x(cid:12)
• ⊗(x1, . . . , xn) = 0 if ∀i, xi = 0,
• ⊗(x) = x.

(non-decreasingness)
(minimality)
(identity)

The merging of a proﬁle of AFs is deﬁned as a set of AFs:

Deﬁnition 17 (Merging of n AFs). Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of n AFs. Let d be any pseudo-distance
between PAFs, let ⊗ be an aggregation function, and let exp1, . . . , expn be n expansion functions. The merging of
P is the set of AFs

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

739

(cid:3)
(cid:4)
(cid:3)AF1, . . . , AFn(cid:4), (cid:3)exp1, . . . , expn(cid:4)

=

(cid:2)

⊗
d

(cid:5)

(cid:6)

AF over

Ai

(cid:7)
(cid:7)
(cid:7) AF minimizes ⊗n

i=1 d

(cid:3)
AF, expi(AFi, P)

(cid:4)(cid:8)

.

i

In order to avoid heavy notations, we shall sometimes identify the resulting set of AFs {AF
(cid:3)AF

(cid:4) (or any other permutation of it).

(cid:12)
1, . . . , AF

(cid:12)
k

(cid:12)
1, . . . , AF

(cid:12)
k

} with the proﬁle

Thus, merging a proﬁle of AFs P = (cid:3)AF1, . . . , AFn(cid:4) is a two-step process:

expansion: An expansion of each AFi over P is ﬁrst computed. Note that considering expansion functions speciﬁc to

each agent is possible. What is important is that expi(AFi, P) is a PAF over A =

fusion: The AFs over A that are selected as the result of the merging process are the ones that best represent P (i.e.,

(cid:2)

i Ai .

that are the “closest” to P w.r.t. the aggregated distances).

In the following, we assume that each agent uses consensual expansion. In order to lighten the notations, we remove

(cid:3)exp1, . . . , expn(cid:4) from the list of parameters of merging operators.

Note that it would be possible to reﬁne Deﬁnition 17 so as to include integrity constraints into the picture. This can
be useful if there exists some (unquestionable) knowledge about the expected result (some attacks between arguments
which have to hold for the group). It is then enough to look only to the AFs which satisfy the constraints, similarly
to what is done in propositional belief base merging (see e.g., [20]). In contrast to the belief base merging scenario,
constraints on the structure of the candidate AFs can also be set. In particular, considering only acyclic AFs can prove
valuable since (1) such AFs are well-founded (which implies that only one extension has to be considered whatever the
underlying semantics—among Dung’s ones), and (2) this extension (which turns out to be the grounded one, see [13])
can be computed in time polynomial in the size of the AF (while computing a single extension is intractable for the
other semantics in the general case—under the standard assumptions of complexity theory—see [14]).

Now, many pseudo-distances between PAFs and many aggregation functions can be used, giving rise to many
merging operators. Usual aggregation functions include the sum, the max and the leximax3 but using non-symmetric
functions is also possible (this may be particularly valuable if some agents are more important than others). Some
aggregation functions (like the sum) enable the merging process to take into account the number of agents believing
that an argument attacks or not another argument:

Example 7 (continued). Two agents over three agree with the fact that e attacks f and f does not attack e. It may
prove sensible that the group agrees with the majority.

The choice of the aggregation function is very important for tuning the operator behavior with the expected one.
For example, sum is a possible choice in order to solve conﬂicts using majority. Otherwise, the leximax function can
prove more valuable if the aim is to behave in a more consensual way, trying to deﬁne a result close to the AF of each
agent of the group. The distinction between majority and arbitration operators as considered in propositional belief
base merging [20] also applies here.

In the following, we focus on the edit distance between PAFs:

Deﬁnition 18 (Edit distance). Let PAF1 = (cid:3)A, R1, I1, N1(cid:4) and PAF2 = (cid:3)A, R2, I2, N2(cid:4) be two PAFs over A.

• Let a, b be two arguments ∈ A. The edit distance between PAF1 and PAF2 over a, b is the mapping dea,b such

that:
– dea,b(PAF1, PAF2) = 0 if and only if (a, b) ∈ R1 ∩ R2 or I1 ∩ I2 or N1 ∩ N2,
– dea,b(PAF1, PAF2) = 1 if and only if (a, b) ∈ R1 ∩ N2 or N1 ∩ R2,
– dea,b(PAF1, PAF2) = 0.5 otherwise.

3 When applied to a vector of n real numbers, the leximax function Leximax gives the list of those numbers sorted in a decreasing way. Such
lists are compared w.r.t. the lexicographic ordering induced by the standard ordering on real numbers.

740

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

• The edit distance between PAF1 and PAF2 is given by

de(PAF1, PAF2) = (cid:3)(a,b)∈A×Adea,b(PAF1, PAF2).

The edit distance between two PAFs is the (minimum) number of additions/deletions which must be made to render

them identical. Ignorance is treated as halfway between attack and non-attack.

It is easy to show that:

Proposition 19. The edit distance de between PAFs is a distance.

Proof. We show that de and dea,b, ∀(a, b) ∈ A × A are distances, i.e. they are (1) symmetric, they satisfy (2) the
minimality requirement and (3) the triangular inequality:

(1) Obvious.
(2) (⇒) Consider PAF1 = (cid:3)A, R1, I1, N1(cid:4) and PAF2 = (cid:3)A, R2, I2, N2(cid:4) such that PAF1 = PAF2. For all (a, b) ∈
A × A, if PAF1 = PAF2 then (a, b) ∈ R1 ∩ R2 or (a, b) ∈ I1 ∩ I2 or (a, b) ∈ N1 ∩ N2. So, ∀(a, b) ∈ A × A,
dea,b(PAF1, PAF2) = 0, and de(PAF1, PAF2) = 0.
(⇐) Suppose de(PAF1, PAF2) = 0 and make a reductio ad absurdum: if PAF1 (cid:16)= PAF2 then ∃(a, b) ∈ A × A
such that (a, b) /∈ R1 ∩ R2, (a, b) /∈ I1 ∩ I2 and (a, b) /∈ N1 ∩ N2; so, dea,b(PAF1, PAF2) (cid:16)= 0; so, de(PAF1,
PAF2) (cid:16)= 0 which is a contradiction with the hypothesis; so, PAF1 = PAF2. The same reasoning can be achieved
with dea,b(PAF1, PAF2) = 0 and the same result is obtained: PAF1 = PAF2.

(3) Consider PAF1 = (cid:3)A, R1, I1, N1(cid:4), PAF2 = (cid:3)A, R2, I2, N2(cid:4) and PAF3 = (cid:3)A, R3, I3, N3(cid:4). ∀(a, b) ∈ A × A, we com-
pute and compare dea,b(PAF1, PAF2), dea,b(PAF1, PAF3) and dea,b(PAF3, PAF2), respectively denoted by x, y, z.
We have three possible cases:
• x = 0: ∀y, z, we have x (cid:3) y + z;
• x = 0.5: x (cid:3) y + z is false if and only if y = z = 0; however, y = z = 0 implies that (a, b) ∈ R1 ∩ R2 ∩ R3 or
(a, b) ∈ I1 ∩ I2 ∩ I3 or (a, b) ∈ N1 ∩ N2 ∩ N3 which also implies x = 0 (contradiction with the hypothesis); so,
x (cid:3) y + z;

• x = 1: we have (a, b) ∈ R1 ∩ N2 or (a, b) ∈ N1 ∩ R2; suppose that (a, b) ∈ R1 ∩ N2 then there are 3 possible

cases:
– (a, b) ∈ R3: so, y = 0, z = 1 and we have x (cid:3) y + z;
– (a, b) ∈ I3: so, y = 0.5, z = 0.5 and we have x (cid:3) y + z;
– (a, b) ∈ N3: so, y = 1, z = 0 and we have x (cid:3) y + z.
The same reasoning can be achieved if (a, b) ∈ N1 ∩ R2. So, ∀(a, b) ∈ A × A: dea,b(PAF1, PAF2) (cid:3)
dea,b(PAF1, PAF3) + dea,b(PAF3, PAF2);
summing over all (a, b) ∈ A × A, we get:
de(PAF1, PAF2) (cid:3) de(PAF1, PAF3) + de(PAF3, PAF2). (cid:2)

Let us now illustrate the notion of edit distance as well as some associated merging operators on Example 14.

Example 14 (continued). We consider the following argumentation system AF
(c, d)}(cid:4).

(cid:12)
1

= (cid:3){a, b, c, d}, {(a, b), (b, a), (b, c),

(cid:12)
1 and each of the PAFs PAF1, PAF2, PAF3, PAF4 obtained by consensual expansion

The edit distance between AF

from the proﬁle (cid:3)AF1, AF2, AF3, AF4(cid:4) is:

• de(AF
• de(AF
• de(AF
• de(AF

(cid:12)
1, PAF1) = 1,
(cid:12)
1, PAF2) = 1.5,
(cid:12)
1, PAF3) = 2,
(cid:12)
1, PAF4) = 2.

Taking the sum as the aggregation function, we obtain:

(cid:9)
4
i=1 de(AF

(cid:12)
1, PAFi) = 6.5.

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

741

Taking the max, we obtain: Max4
i=1de(AF
Taking the leximax, we obtain: Leximax4
By computing such distances for all candidate AFs (i.e., all AFs over {a, b, c, d}), we can compute the result of the

(cid:12)
1, PAFi) = (2, 2, 1.5, 1).

(cid:12)
1, PAFi) = 2.
i=1de(AF

merging:
(cid:2)(cid:3)

de((cid:3)AF1, . . . , AF4(cid:4)) is the set containing the two following AFs:

(cid:12)
• AF
1
(cid:12)
• AF
2

= (cid:3){a, b, c, d}, {(a, b), (b, a), (b, c), (c, d)}(cid:4),
= (cid:3){a, b, c, d}, {(a, b), (b, a), (b, c), (a, d), (c, d)}(cid:4).

(cid:2)Max
de

((cid:3)AF1, . . . , AF4(cid:4)) is the set containing AF

(cid:12)(cid:12)
(cid:12)
1 and AF
2

= (cid:3){a, b, c, d}, {(b, a), (b, c), (a, d), (c, d)}(cid:4).

(cid:2)Leximax

de

(cid:12)
((cid:3)AF1, . . . , AF4(cid:4)) is the singleton containing AF
1.

The discrepancies between the merging obtained with the various aggregation operators can be explained in the
following way:

(cid:12)
• AF
1 is the most consensual AF obtained as it is almost equidistant from each PAF.
(cid:12)
• AF
2 is much closer to PAF1, PAF2 and PAF3 than to PAF4, thus it is selected with the sum as an aggregation

operator but it is too far from PAF4 for being selected with the Max or Leximax operators.

(cid:12)(cid:12)
• AF
2 is nearly equidistant from all four PAFs of the proﬁle but less consensual than AF
with (cid:3) nor with Leximax but only with Max as it is not far from any of the given PAFs.

(cid:12)
1, thus it is selected neither

(cid:12)
Having AF
1 in all mergings—whatever the aggregation function chosen—seems very intuitive. Indeed, whenever
(cid:12)
1. This is not the case for
an attack (or a non-attack) is present in the (weak) majority of the initial AFs, it is also in AF
the two others AFs belonging to the above mergings.

Here is another simple example:

Example 20. Consider the two following argumentation systems:

742

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

• AF1 = (cid:3){a, b, c, e}, {(b, a), (c, b), (c, e)}(cid:4),
• AF2 = (cid:3){a, d, e, c}, {(d, a), (e, d), (e, c)}(cid:4).

Note that the attack from c to e is known by Agent 1 but not by Agent 2 and the attack from e to c is known by Agent 2
but not by Agent 1. This illustrates the fact that the agents do not share the same attack relation.
AF1 has a unique preferred extension: {c, a}. AF2 has a unique preferred extension: {e, a}.
The consensual expansions of AF1 and AF2 are respectively:

• PAF1 = (cid:3){a, b, c, d, e}, {(b, a), (c, b), (c, e), (d, a), (e, d)}, ∅(cid:4),
• PAF2 = (cid:3){a, b, c, d, e}, {(d, a), (e, d), (e, c), (b, a), (c, b)}, ∅(cid:4).

The result of merging the proﬁle (cid:3)AF1, AF2(cid:4) with de and ⊗ = Max (or ⊗ = Leximax) is:
(cid:3)
(cid:4)
(cid:3)AF1, AF2(cid:4)

(cid:3)
(cid:4)
(cid:3)AF1, AF2(cid:4)

} with

= {AF

= (cid:2)

(cid:2)

Leximax
de

(cid:12)
(cid:12)
1, AF
2

Max
de

(cid:12)
• AF
1
(cid:12)
• AF
2

= (cid:3){a, b, c, d, e}, {(b, a), (c, b), (c, e), (d, a), (e, d), (e, c)}(cid:4),
= (cid:3){a, b, c, d, e}, {(b, a), (c, b), (d, a), (e, d)}(cid:4).

Using the sum as an aggregation function, two additional AFs are generated:

(cid:4)
(cid:3)
(cid:3)AF1, AF2(cid:4)

(cid:2)(cid:3)
de

= {AF

(cid:12)
(cid:12)
2, AF
1, AF

(cid:12)
3, AF

(cid:12)
4

}, with

(cid:12)
• AF
3
(cid:12)
• AF
4

= (cid:3){a, b, c, d, e}, {(b, a), (c, b), (c, e), (e, d), (d, a)}(cid:4),
= (cid:3){a, b, c, d, e}, {(b, a), (c, b), (e, c), (e, d), (d, a)}(cid:4).

Each of the resulting mergings contains an argumentation system from which argument a can be derived, as it is
the case in AF1 and AF2. Using the sum as an aggregation function leads to the most consensual result here since it
(cid:12)
(cid:12)
4 is equivalent to PAF2.
3 is equivalent to PAF1 and AF
preserves the initial AFs of the different agents. Indeed, AF

6. Some properties

Let us now present some properties of consensual expansions and merging operators based on the edit distance,

showing them as interesting choices.

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

743

6.1. Properties of PAFs and consensual expansions

Intuitively speaking, a natural requirement on any AF resulting from a merging is that it preserves all the informa-
tion which are shared by the agents participating in the merging process, and more generally, all the information on
which the agents participating in the merging process do not disagree.

In order to show that our merging operators satisfy those requirements, one ﬁrst need the notions of clash-free part

and of common part of a proﬁle of PAFs:

Deﬁnition 21 (Clash-free part of a proﬁle of PAFs). Let P = (cid:3)PAF1, . . . , PAFn(cid:4) be a proﬁle of PAFs. The clash-free
part of P is denoted by CFP(P) and is deﬁned by:
(cid:6)
(cid:6)

(cid:6)

(cid:6)

(cid:10)(cid:6)

(cid:11)

CFP(P) =

Ai,

Ri \

Ni, ICFP,

Ni \

where ICFP = (

(cid:2)

i
i Ai ×

i
i
(cid:2)
i Ai) \ ((

(cid:2)

i Ri \

(cid:2)

i
(cid:2)

i
i Ni) ∪ (

Ri

i Ni \

(cid:2)

i Ri)).

The clash-free part of a proﬁle of PAFs represents the pieces of information (attack/non-attack) that are not ques-
tioned by any other agent. As they are not the source of any disagreement, they are expected to be included in each
AF resulting from the merging process.

Example 14 (continued). With P = (cid:3)AF1, AF2, AF3, AF4(cid:4), CFP(P) = (cid:3){a, b, c, d}, {(b, c), (c, d)}, {(a, b), (b, a),
(a, d), (b, d), (a, c), (c, a)}(cid:4).

Note that with expC(P) = (cid:3)expC(AF1, P), . . . , expC(AF4, P)(cid:4), CFP(expC(P)) = (cid:3){a, b, c, d}, {(b, c), (c, d)},

{(a, b), (b, a), (a, d), (b, d)}(cid:4) (now (a, c) and (c, a) are non-attacks); so CFP(P) (cid:16)= CFP(expC(P)).

Deﬁnition 22 (Common part of a proﬁle of PAFs). Let P = (cid:3)PAF1, . . . , PAFn(cid:4) be a proﬁle of PAFs. The common part
(cid:12)
of P is denoted by CP(P) and is deﬁned by: CP(P) = (cid:3)

(cid:12)

(cid:12)

(cid:12)

i Ai,

i Ri,

i Ii,

i Ni(cid:4).

The common part of a proﬁle of PAFs is a much more demanding notion than the clash-free one. It represents the
pieces of information on which all the agents agree. There is no doubt that those pieces of information must hold in
any consensual view of the group’s opinion, so the common part of the proﬁle must be included in each AF of the
result of the merging process.

Example 14 (continued). With P = (cid:3)AF1, AF2, AF3, AF4(cid:4), CP(P) = (cid:3){b}, ∅, ∅, {(b, b)}(cid:4).

We have the following easy property:

Proposition 23. Let P = (cid:3)PAF1, . . . , PAFn(cid:4) be a proﬁle of PAFs. The common part of P is pointwise included into the
clash-free part of P, i.e.:
(cid:2)

(cid:2)

(cid:12)
(cid:12)
(cid:12)

i Ri \

i Ri ⊆
i Ii ⊆ ICFP;
i Ni ⊆

(cid:2)

i Ni \

i Ni ;

(cid:2)

i Ri .

Proof. The proof is straightforward:

(cid:12)

(cid:2)

•
•
•

•

i Ri ⊆

(a, b) ∈ Rk ∩ Nk that is impossible by deﬁnition), so
(cid:2)

i Ri is obvious; and we also have ∀(a, b) ∈
(cid:12)
(cid:12)

(cid:2)

i Ri ⊆

i Ri \

i Ni .

• In the same way, we can prove
(cid:12)
• if ∀(a, b) ∈
(cid:2)
i Ni) ∪ (

(cid:2)

i Ii then, by deﬁnition, (a, b) /∈ Ri and (a, b) /∈ Ni for all i; so, (a, b) ∈ (
i Ni \

i Ri)). (cid:2)

(cid:2)

i Ni ⊆

i Ni \

i Ri .

(cid:2)

(cid:2)

i Ai ×

(cid:2)

i Ai) \ ((

i Ri \

(cid:12)

i Ri , (a, b) /∈ Nj for all j (otherwise, ∃PAFk such that

(cid:2)

(cid:2)

744

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

The common part of a proﬁle of n PAFs (resp. AFs) is not always a PAF (resp. an AF). Contrastingly, the clash-free

part of a proﬁle of n PAFs is a PAF (however, the clash-free part of a proﬁle of n AFs is not always an AF).

There exists an interesting particular case: if the various PAFs of the proﬁle are based on the same set of arguments
and if for each ordered pair of arguments (a, b) such that (a, b) belongs to the ignorance relation in one PAF, this pair
belongs to the attack relation for another PAF of the proﬁle and to the non-attack relation for at least a third PAF of
the proﬁle, then the clash-free part of the proﬁle and its common part are identical:

Proposition 24. Let P = (cid:3)PAF1, . . . , PAFn(cid:4) be a proﬁle of n PAFs over the same set of arguments A. Consider the
clash-free part of P denoted by CFP(P) = (cid:3)ACFP, RCFP, ICFP, NCFP(cid:4) and the common part of P denoted by CP(P) =
(cid:2)
(cid:3)ACP, RCP, ICP, NCP(cid:4). If

i Ii ⊆ conf (P) = (

i Ni), we have:

i Ri) ∩ (

(cid:2)

(cid:2)

• ACFP = ACP,
• RCFP = RCP,
• NCFP = NCP.

Proof. All the PAFs are over the same set of arguments, so we have A =

First, we prove that RCFP = RCP.

(cid:2)

i Ai =

(cid:12)

i Ai and ACFP = ACP.

• RCFP ⊆ RCP: consider (a, b) ∈ RCFP; so (a, b) ∈

(a, b) /∈ Rk; so (a, b) ∈ Nk or (a, b) ∈ Ik;
i Ri \
In the ﬁrst case, we have (a, b) /∈
In the second case, we retrieve the ﬁrst case because
Thus (a, b) ∈ RCP.

(cid:2)

(cid:2)

• RCFP ⊇ RCP: given by Proposition 23.

(cid:2)

i Ri \

(cid:2)

i Ni ; suppose that (a, b) /∈ RCP; so ∃PAFk such that

i Ni : contradiction with the hypothesis (a, b) ∈ RCFP;

(cid:2)

(cid:2)

(cid:2)

i Ii ⊆ conf (P) = (

i Ri) ∩ (

i Ni).

NCFP = NCP is proven in the same way. (cid:2)

This result is interesting since this situation always holds (by deﬁnition) if consensual expansion is used as an

expansion policy by each agent.

Example 14 (continued). With P = (cid:3)AF1, AF2, AF3, AF4(cid:4) and expC(P) = (cid:3)expC(AF1, P), expC(AF2, P),
expC(AF3, P), expC(AF4, P)(cid:4), we have:

• CFP(expC(P)) = (cid:3){a, b, c, d}, {(b, c), (c, d)}, {(a, b), (b, a), (a, d), (b, d)}, {(a, a), (b, b), (c, c), (d, d), (a, c),

• CP(expC(P)) = (cid:3){a, b, c, d}, {(b, c), (c, d)}, ∅, {(a, a), (b, b), (c, c), (d, d), (a, c), (c, a), (d, a), (d, b), (d, c),

(c, a), (d, a), (d, b), (d, c), (c, b)(cid:4);

(c, b)}(cid:4).

A valuable property of any consensual expansion over a proﬁle of AFs is that it preserves the clash-free part of the

proﬁle:

Proposition 25. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs. For each i, we have:

• ACFP(P) = AexpC (AFi ,P),
• RCFP(P) ⊆ RexpC (AFi ,P),
• NCFP(P) ⊆ NexpC (AFi ,P).

Proof. Consider AFi , denoted by (cid:3)Ai, Ri, Ni(cid:4), and the set conf (P) = (
denoted by (cid:3)A(cid:12)

(cid:4).

i, R(cid:12)

i, I (cid:12)

i , N (cid:12)

i

(cid:2)

(cid:2)

i Ri) ∩ (

i Ni). Each expC(AFi, P) is

• By deﬁnition, the set of arguments is the same for CFP(AF1, . . . , AFn) and for each expC(AFi, P), ∀AFi : it is

(cid:2)

equal to

i Ai .

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

745

(cid:2)

(cid:2)

(cid:2)

• Consider a, b ∈

(a, b) /∈ Ni . So, (a, b) ∈ R(cid:12)
i
(cid:2)

• Consider a, b ∈

(cid:2)

i Ri . So, (a, b) /∈ I (cid:12)

i Ai such that (a, b) ∈ RCFP(P) = (
(cid:2)
(cid:2)

= Ri ∪ (((

i Ai such that (a, b) ∈ NCFP(P) = (
i . So, (a, b) ∈ N (cid:12)

i , and (a, b) /∈ R(cid:12)

i Ri) \ conf (P)) \ Ni).
i Ni) \ (

i . (cid:2)

i Ri) \ (
(cid:2)

i Ni); so, we have (a, b) /∈ conf (P) and

i Ri); so, we have (a, b) /∈ conf (P) and (a, b) /∈

Now, concordance between AFs can be deﬁned as follows:

Deﬁnition 26 (Concordance). Let AF1 = (cid:3)A1, R1(cid:4), AF2 = (cid:3)A2, R2(cid:4) be two AFs. AF1, AF2 are said to be concordant
if and only if ∀(a, b) ∈ (A1 ∩ A2) × (A1 ∩ A2), (a, b) ∈ R1 if and only if (a, b) ∈ R2. Otherwise they are said to be
discordant.

Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs. P is said to be concordant if and only if all its AFs are pairwise

concordant. Otherwise it is said to be discordant.

Of course, concordance is related to the set conf (P) representing clashes between attack and non-attack relations

in the different AFs of the proﬁle:

Proposition 27. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of argumentation systems. P is concordant if and only if
conf (P) =

(cid:2)

(cid:2)

i Ri ∩

i Ni is empty.

Proof. P is concordant ⇔ ∀AFi, AFj ∈ P, (cid:2)a, b ∈ Ai ∩ Aj such that (a, b) ∈ (Ri \ Rj ) ∪ (Rj \ Ri) ⇔ ∀AFi, AFj ∈ P,
(cid:2)
(cid:2)a, b ∈ Ai ∩ Aj such that (a, b) ∈ Ri and (a, b) ∈ Nj ⇔

i Ni = ∅. (cid:2)

i Ri ∩

(cid:2)

When a proﬁle of AFs is concordant, its clash-free part is the union of its elements, and the converse also holds:

Proposition 28. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs. P is concordant if and only if CFP(P) =

(cid:2)

i AFi .

Proof. CFP(P) is denoted by (cid:3)ACFP, RCFP, ICFP, NCFP(cid:4).

(cid:2)

The proof for “P concordant ⇒ CFP(P) =

(cid:2)

CFP(P) (cid:16)=

i AFi and we have the following possibilities:

i AFi ” is made using a reductio ad absurdum. We suppose that

• ∃(a, b) ∈ RCFP and (a, b) /∈
• ∃(a, b) ∈ NCFP and (a, b) /∈
• ∃(a, b) /∈ RCFP and (a, b) ∈

(cid:2)
i Ri ; this case is impossible because, by deﬁnition, (a, b) ∈ (
(cid:2)
i Ni ; this case is impossible because, by deﬁnition, (a, b) ∈ (
(cid:2)
i Ri ; so, by deﬁnition, (a, b) ∈ (

(cid:2)

(cid:2)
(cid:2)

(cid:2)
(cid:2)

i Ri) \ (
i Ni) \ (

i Ni);
i Ri);

i Ni); so, ∃AFk, AFj such that (a, b) ∈ Rk and
(a, b) ∈ Nj ; so, ∃AFk, AFj such that (a, b) ∈ Ak ∩ Aj and (a, b) ∈ Rk \ Rj ; so, contradiction with the hypothesis
P concordant;

• ∃(a, b) /∈ NCFP and (a, b) ∈

i Ri); so, ∃AFk, AFj such that (a, b) ∈ Rk and
(a, b) ∈ Nj ; so, ∃AFk, AFj such that (a, b) ∈ Ak ∩ Aj and (a, b) ∈ Rk \ Rj ; so, contradiction with the hypothesis
P concordant.

i Ni ; so, by deﬁnition, (a, b) ∈ (

(cid:2)

(cid:2)

For each possibility, we obtain a contradiction. So, if P is concordant, then CFP(P) =
The proof for “P concordant ⇐ CFP(P) =

i AFi ” is also made using a reductio ad absurdum. If P is discordant
then ∃AFi, AFj such that ∃(a, b) ∈ Ai ∩ Aj and (a, b) ∈ (Ri \ Rj ) ∪ (Rj \ Ri). So, a, b ∈
k Rk
and (a, b) ∈
i AFi . However,
by deﬁnition, (a, b) cannot appear in the same time in RCFP and in NCFP. So, contradiction with the hypothesis
CFP(AF1, . . . , AFn) =

k Nk; so, (a, b) appears in the attack relation and in the non-attack relation of

k Ak, (a, b) ∈

i AFi .
(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

i AFi . (cid:2)

(cid:2)

Proposition 29. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs. P is concordant if and only if expC(P) =
(cid:3)expC(AF1, P), . . . , expC(AFn, P)(cid:4) is reduced to (cid:3)
i AFi(cid:4) (i.e., each of the n elements of the vector is
i AFi, . . . ,
(cid:2)

(cid:2)

(cid:2)

i AFi ).

Proof. Consider a concordant proﬁle of AFs P. ∀AFi = (cid:3)Ai, Ri, Ni(cid:4), let us consider expC(AFi, P) = (cid:3)A(cid:12)
∀a, b ∈

i Ai , there are several cases:

(cid:2)

i, R(cid:12)

i, I (cid:12)

i , N (cid:12)

i

(cid:4).

746

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

• if (a, b) ∈ Ri then (a, b) ∈ R(cid:12)
i ;
• if (a, b) /∈ Ri and (a, b) ∈ Ai × Ai then (a, b) ∈ Ni , so (a, b) ∈ N (cid:12)

(cid:2)AFj ∈ P such that (a, b) ∈ Rj ;

• if (a, b) /∈ Ri and (a, b) /∈ Ai × Ai then there are two cases:

– either ∃AFj ∈ P such that (a, b) ∈ Rj : because P is concordant, (a, b) ∈ R(cid:12)
i ;
– or (cid:2)AFj ∈ P such that (a, b) ∈ Rj : so, (a, b) ∈ N (cid:12)
i .

i ; with P concordant, we also know that

In all the cases, if (a, b) is an attack interaction for one of the AFi , (a, b) is also an attack interaction for the consensual
PAFs. So, all the consensual PAFs are equal to

(cid:2)

For the second part of the proof, consider expC(P) = (cid:3)

i AFi(cid:4). We suppose that P is discordant.
So, ∃AFi, AFj ∈ P such that ∃a, b ∈ Ai ∩ Aj and (a, b) ∈ (Ri \ Rj ) ∪ (Rj \ Ri). If we suppose that (a, b) ∈ Ri , then
expC(AFj , P) cannot contain the attack (a, b); so, expC(AFj , P) (cid:16)=
i AFi : contradiction. And the same problem
appears when we suppose that (a, b) ∈ Rj . So, P is concordant. (cid:2)

i AFi, , . . . ,
(cid:2)

i AFi .

(cid:2)

(cid:2)

Note that

(cid:2)

i AFi may appear into expC(P), even if P is discordant. This is illustrated by the following example:

Example 30. Consider the proﬁle P = (cid:3)AF1, AF2, AF3(cid:4) consisting of the following three AFs:

• AF1 = (cid:3){a, b, c}, {(a, b), (a, c)}(cid:4),
• AF2 = (cid:3){a, b, c}, {(a, c)}(cid:4),
• AF3 = (cid:3){a, d}, {(a, d)}(cid:4).

The proﬁle P = (cid:3)AF1, AF2, AF3(cid:4) is discordant and expC(P) = (cid:3)PAF1, PAF2, PAF3(cid:4) is such that:

• PAF1 = (cid:3){a, b, c, d}, {(a, b), (a, c), (a, d)}, ∅(cid:4) (=
• PAF2 = (cid:3){a, b, c, d}, {(a, c), (a, d)}, ∅(cid:4),
• PAF3 = (cid:3){a, b, c, d}, {(a, c), (a, d)}, {(a, b)}(cid:4).

(cid:2)

i AFi ),

The following proposition states that whenever the presence of an attack (a, b) does not clash with a proﬁle of AFs,
such an attack is present in all the corresponding PAFs obtained by consensual expansion if and only if it is present in
one of the input AFs.

Proposition 31. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs. Let (a, b) be a pair of arguments such that a, b ∈
and (cid:2)AFi, AFj ∈ P such that (a, b) ∈ (Ri \ Rj ) ∪ (Rj \ Ri).

∃AFl ∈ P such that (a, b) ∈ Rl if and only if ∀AFk ∈ P, (a, b) ∈ R(cid:12)

k with R(cid:12)

k denoting the attack relation of the

(cid:2)

i Ai

PAF expC(AFk, P).

Proof. Consider AFk ∈ P. Since ∃AFl ∈ P such that (a, b) ∈ Rl and (cid:2)AFi, AFj ∈ P such that (a, b) ∈ (Ri \ Rj ) ∪
(Rj \ Ri), (a, b) /∈ Nk; so, (a, b) ∈ R(cid:12)
k.

The second part of the proof is obvious with a reductio ad absurdum: if we suppose that (cid:2)AFl ∈ P such that

(a, b) ∈ Rl then we obtain ∀AFk ∈ P, (a, b) ∈ N (cid:12)

k which is a contradiction with ∀AFk ∈ P, (a, b) ∈ R(cid:12)

k. (cid:2)

A notion of compatibility of a proﬁle of PAFs over the same set of arguments can also be deﬁned:

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

747

Deﬁnition 32 (Compatibility). Let P = (cid:3)PAF1, . . . , PAFn(cid:4) be a proﬁle of PAFs over a set of arguments A.
PAF1, . . . , PAFn are said to be compatible if and only if they have at least one common completion. Otherwise they
are said to be incompatible.

Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs. Let exp be an expansion function. AF1, . . . , AFn are said to be
compatible given exp if and only if exp(AFi, P), ∀i = 1 . . . n, are said to be compatible. Otherwise they are said to
be incompatible.

There is a clear link between concordance and compatibility in the case of the consensual expansion applied to

a proﬁle of AFs:

Proposition 33. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs. P is concordant if and only if expC(AF1, P), . . . ,
expC(AFn, P) are compatible.

Proof. The ﬁrst part of the proof is obvious: if P is concordant then the proﬁle expC(P) = (cid:3)expC(AF1, P), . . . ,
expC(AFn, P)(cid:4) is reduced to (cid:3)
i AFi(cid:4) (see Proposition 29); so, expC(AF1, P), . . . , expC(AFn, P) are
equal and have a common completion.

i AFi, . . . ,

(cid:2)

(cid:2)

The second part of the proof uses a reductio ad absurdum: if we suppose that P is discordant then ∃AFi, AFj such
j with N (cid:12)
that ∃(a, b) ∈ Ri ∩ Nj ; so, (a, b) ∈ R(cid:12)
j
denoting the non-attack relation of expC(AFj , P); so, all the completions of expC(AFi, P) must contain the attack
(a, b) and no completion of expC(AFj , P) can contain the attack (a, b); so, AFi and AFj do not have a common
completion which is in contradiction with the hypothesis of compatibility. (cid:2)

i denoting the attack relation of expC(AFi, P) and (a, b) ∈ N (cid:12)

i with R(cid:12)

Example 34. Consider the following argumentation systems AF1, AF2 and AF3.

The completions of their respective consensual expansions PAF1, PAF2 and PAF3 are:

AF1 and AF2 are discordant and incompatible given expC . AF3 and AF1 are concordant and compatible given expC .

6.2. Properties of merging operators

Let us now give some properties of merging operators, focusing on those based on the edit distance:

Proposition 35. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs. Assume that the expansion function used for each agent
(cid:2)
is the consensual one. If P is concordant then (cid:2)

⊗
de(P) = {

i AFi}.

Proof. If P is concordant, then by Proposition 29, we have expC((cid:3)AF1, . . . , AFn(cid:4)) = (cid:3)
(cid:2)
⊗
de((cid:3)
mains to show that (cid:2)
(cid:2)
minimality requirement (

i AFi, . . . ,
i AFi is the unique PAF at edit distance 0 from itself). (cid:2)

i AFi(cid:4). It re-
i AFi}, which is obvious since de, as a distance, satisﬁes the

i AFi(cid:4)) = {

i AFi, . . . ,

(cid:2)

(cid:2)

(cid:2)

(cid:2)

Now we show an expected property: that the clash-free part of any proﬁle P is included in each AF from the

merging of P when the edit distance is used.

748

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

Proposition 36. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of argumentation systems. Assume that the expansion func-
tion used for each agent is the consensual one. For any aggregation function ⊗, we have that: ∀AF = (cid:3)A, R, N(cid:4) ∈
(cid:2)

⊗
de((cid:3)AF1, . . . , AFn(cid:4)):

• ACFP(P) ⊆ A,
• RCFP(P) ⊆ R,
• NCFP(P) ⊆ N .

Proof. Let CFP(P) = (cid:3)ACFP, RCFP, NCFP(cid:4) (the ignorance relation does not appear here because argumentation sys-
tems (and not partial ones) are considered).

(cid:2)

(cid:2)

• ACFP =
• By Proposition 25, we know that CFP(P) is pointwise included in each expC(AFi, P). Let ﬁrst consider the case

i Ai ⊆ A =

i Ai .

(a, b) ∈ RCFP, we have (a, b) ∈ RexpC (AFi ,P), ∀AFi .
⊗
Consider AF = (cid:3)A, R(cid:4) ∈ (cid:2)
de((cid:3)AF1, . . . , AFn(cid:4)). Suppose that (a, b) /∈ R and consider AF
{(a, b)}(cid:4).
∀AFi , de(AF
RexpC (AFi ,P); so, since ⊗ respects monotonicity, we have ⊗n
⊗
de((cid:3)AF1, . . . , AFn(cid:4)); so, (a, b) ∈ R. Hence RCFP(P) ⊆ R.
we obtain a contradiction with AF ∈ (cid:2)

(cid:12), expC(AFi, P)) = de(AF, expC(AFi, P)) − 1, since (a, b) ∈ R(cid:12) ∩ RexpC (AFi ,P) and /∈ R ∩
i=1de(AF, expC(P)) and
i=1de(AF

(cid:12) = (cid:3)A(cid:12) = A, R(cid:12) = R ∪

(cid:12), expC(P)) < ⊗n

• In the same way, we can prove that if (a, b) ∈ NCFP then (a, b) ∈ N . So NCFP(P) ⊆ N . (cid:2)

As a direct corollary of Propositions 23 and 36, we get that:

Corollary 37. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of argumentation systems. Assume that the expansion function
used for each agent is the consensual one. For any aggregation function ⊗, we have that: ∀AF = (cid:3)A, R, N(cid:4) ∈
(cid:2)

⊗
de((cid:3)AF1, . . . , AFn(cid:4)):

• ACP(P) ⊆ A,
• RCP(P) ⊆ R,
• NCP(P) ⊆ N .

When sum is used as the aggregation function and all AFs are over the same set of arguments, the merging of
a proﬁle can be characterized in a concise way, thanks to the notion of majority graph. Intuitively the majority graph
of a proﬁle of AFs over the same set of arguments is the PAF obtained by applying the strict majority rule to decide
whether a attacks b or not, for every ordered pair (a, b) of arguments. Whenever there is no strict majority, an
ignorance edge is generated.

Deﬁnition 38 (Majority PAF). Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs over the same set A of arguments. The
majority PAF MP(P) of P is the triple (cid:3)R, N, I (cid:4) such that ∀a, b ∈ A:4

• (a, b) ∈ R if and only if #({i ∈ 1 . . . n | (a, b) ∈ Ri}) > #({i ∈ 1 . . . n | (a, b) ∈ Ni});
• (a, b) ∈ N if and only if #({i ∈ 1 . . . n | (a, b) ∈ Ni}) > #({i ∈ 1 . . . n | (a, b) ∈ Ri});
• (a, b) ∈ I otherwise.

The next proposition states that, as expected, the majority PAF of a proﬁle of AFs over the same set of arguments

is a PAF:

Proposition 39. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs over the same set A of arguments. The majority PAF
MP(P) of P is a PAF.

4 For any set S, #(S) denotes the cardinality of S.

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

749

Proof. Obvious since by construction, R and I are disjoint sets and N is the complement of R ∪ I into A × A. (cid:2)

Example 40. Consider AF1 = (cid:3){a, b, c}, {(a, b), (b, c), (a, c)}(cid:4), AF2 = (cid:3){a, b, c}, {(a, b), (b, a), (a, c)}(cid:4).

We have MP((cid:3)AF1, AF2(cid:4)) = (cid:3){a, b, c}, {(a, b), (a, c)}, {(b, c), (b, a)}, {(a, a), (b, b), (c, c), (c, a), (c, b)}(cid:4).

Proposition 41. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs over the same set A of arguments. (cid:2)(cid:3)

de(P) = C(MP(P)).

Proof. The key is that the edit distance between an AF denoted by AF and a proﬁle of AFs over A when (cid:3) is the
aggregation operator is the sum over the AFi of the proﬁle of the sum over every ordered pair of arguments over A of
the edit distances between AF and AFi (this is a consequence of the associativity of the sum).
(cid:9)

Let AF be an AF over A which minimizes

n
i=1 de(AF, AFi). Let a, b ∈ A. If #({i ∈ 1 . . . n | (a, b) ∈ Ri}) > #({i ∈
(cid:12) over A which coincides
1 . . . n | (a, b) ∈ Ni}), then (a, b) must be in the attack relation of AF; otherwise, the AF AF
(cid:9)
n
i=1 de(AF, AFi).
with AF except that (a, b) is in the attack relation of AF
Similarly, if #({i ∈ 1 . . . n | (a, b) ∈ Ni}) > #({i ∈ 1 . . . n | (a, b) ∈ Ri}), then (a, b) must not be in the attack relation
of AF.

(cid:12) would be such that

n
i=1 de(AF

(cid:12), AFi) <

(cid:9)

In the remaining case, i.e., when #({i ∈ 1 . . . n | (a, b) ∈ Ri}) = #({i ∈ 1 . . . n | (a, b) ∈ Ni}), let AF

A which coincides with AF except that (a, b) is in the attack relation of AF
(cid:12), AFi) =
relation of AF. Then

(cid:9)
n
i=1 de(AF
This shows that every AF over A which minimizes
Conversely, since every completion AF

(cid:12) of MP(P) is such that

n
i=1 de(AF, AFi).

(cid:9)

(cid:9)
n
i=1 de(AF, AFi) is a completion of the majority PAF MP(P).
n
i=1 de(AF, AFi) where AF

n
i=1 de(AF

(cid:12), AFi) =

(cid:9)

(cid:9)

(cid:9)

(cid:12) be the AF over
(cid:12) if and only if (a, b) is not in the attack

minimizes

n
i=1 de(AF, AFi), the conclusion follows. (cid:2)

Let us illustrate the previous proposition on Example 7:

Example 7 (continued). The consensual expansions of AF1, AF2 and AF3 are respectively:

So, the majority PAF of (cid:3)AF1, AF2, AF3(cid:4) is:

Using the edit distance and sum as the aggregation function, this PAF also represents the result of the merging in the
sense that the latter is the set of all completions of this PAF.

Computing the majority PAF of a proﬁle of AFs over the same set of arguments amounts to voting on the attack
relations associated to each AF. As explained in Section 3, this can prove more suited to our goal than the approach
which consists in voting directly on the acceptable sets of arguments for each agent. The previous proposition shows
that such a simple voting approach corresponds to a speciﬁc merging operator in our framework (but many other
operators, especially arbitration ones, can also be used).

750

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

7. Acceptability for merged AFs

Starting from a proﬁle of AFs (over possibly different sets of arguments), a merging operator enables the compu-
tation of a set of AFs (this time, over the same set of arguments) which are the best candidates to represent the AFs of
the group (a kind of “consensus”).

There is an important epistemic difference between those two sets of AFs, the ﬁrst one reﬂects different points of
view given by different agents (and it can be the case that two distinct agents give the same AF), while the second set
expresses some uncertainty on the merging due to the presence of conﬂicts.

Let us recall that the main goal of this paper is to characterize the sets of arguments acceptable by the whole group
of agents. In order to achieve it, it remains to deﬁne some mechanisms for exploiting the resulting set of AFs. This
calls for a notion of joint acceptability.

Deﬁnition 42 (Joint acceptability). A joint acceptability relation for a proﬁle (cid:3)AF1, . . . , AFn(cid:4) of AFs, denoted by
i Ai with true if E
Acc(cid:3)AF1,...,AFn(cid:4), is a total function from 2
is a jointly acceptable set for (cid:3)AF1, . . . , AFn(cid:4) and with false otherwise.

i Ai to {true, false} which associates each subset E of

(cid:2)

(cid:2)

For instance, a joint acceptability relation for a proﬁle (cid:3)AF1, . . . , AFn(cid:4) can be deﬁned by the acceptability relations
AccAFi (based themselves on some semantics and some selection principles), which can coincide for every AFi (but
this is not mandatory) and a voting method V : {true, false}n (cid:19)→ {true, false}:

Acc(cid:3)AF1,...,AFn(cid:4)(E) = V

(cid:4)
(cid:3)
AccAF1(E), . . . , AccAFn(E)

.

Here are some instances of Deﬁnition 42 based on voting methods:

Deﬁnition 43 (Acceptabilities for proﬁles of AFs). Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of n AFs over the same
set of arguments A. Let AccAFi be the (local) acceptability relation associated with AFi . If n = 1, then we deﬁne
Acc(cid:3)AF1(cid:4) = AccAF1 . Otherwise, for any subset S of A, we say that:

• S is skeptically jointly acceptable for P if and only if S is included in at least one acceptable set for each AFi :

∀AFi ∈ P, ∃Ei such that AccAFi (Ei) is true and S ⊆ Ei.

• S is credulously jointly acceptable for P if and only if S is included in at least one acceptable set for at least one

AFi :

∃AFi ∈ P, ∃Ei such that AccAFi (Ei) is true and S ⊆ Ei.

• S is jointly acceptable by majority for P if and only if S is included in at least one acceptable set for at least

a weak majority of AFi :

(cid:3)(cid:13)

#

AFi | ∃Ei such that AccAFi (Ei) is true and S ⊆ Ei

(cid:14)(cid:4)

(cid:2) n
2

.

Obviously enough, when none of the local acceptabilities AccAFi is trivial (i.e., equivalent to the constant function
false) for the proﬁle under consideration, we have that any set of arguments which is skeptically jointly acceptable
is also jointly acceptable by majority, and that any set of arguments which is jointly acceptable by majority is also
credulously jointly acceptable.

Note that skeptical (resp. credulous) joint acceptability does not require that the skeptical (resp. credulous) infer-

ence principle is at work for deﬁning local acceptabilities AccAFi , which remain unconstrained.

Focusing on the preferred semantics together with credulous local acceptabilities, let us re-consider some previous

examples:

Example 20 (continued). Using the edit distance and ⊗ = Leximax (or Max) as the aggregation function, we get
(cid:12)
two AFs AF
1 and AF

(cid:12)
2 in the merging.

If the local acceptability relations are based on credulous inference from preferred extensions, we have:

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

751

• AccAF
• AccAF

(cid:12)
1
(cid:12)
2

(E) = true if and only if E ⊆ {c, d} or E ⊆ {b, e};
(E) = true if and only if E ⊆ {a, c, e}.

{c} and {e} are skeptically jointly acceptable and {b, e},{c, d} and {a, c, e} (and their subsets) are credulously (and

by majority) jointly acceptable for the merging.

Using this method, the argument a can still be derived credulously, contrariwise to what happens when the union

of the two AFs AF1 and AF2 is considered.

Example 7 (continued). Using the edit distance and the sum as the aggregation function, we get one AF in the merging,
denoted AF:

AF has two preferred extensions: {a, c, e} and {b, d, e}. So, AccAF(E) = true if and only if E ⊆ {a, c, e} or E ⊆
{b, d, e}. The three joint acceptability relations coincide here (as there is only one AF in the result). The sets {a, c, e}
and {b, d, e} (and their subsets) are credulously, skeptically and by majority, jointly acceptable for the merging, which
is a more sensible result that the one obtained using a voting method on the derived arguments of the initial AFs (as
explained in Section 3).

Example 14 (continued). Using the edit distance and the sum as the aggregation function, we get two AFs in the
merging:

The preferred extensions for these 2 AFs coincide (they are {a, c} and {b, d}). As the preferred extensions for the 2
AFs are the same ones, the three relations of joint acceptability coincide here. Thus, the sets {a, c} and {b, d} (and
their subsets) are skeptically, credulously and by majority jointly acceptable for the merging.

It is interesting to compare the joint acceptability relation for the input proﬁle P = (cid:3)AF1, . . . , AFn(cid:4) with the joint
⊗
d (P). Unsurprisingly, both predicates are not logically connected (i.e., none
acceptability relation for the merging (cid:2)
of them implies the other one), even in the case when the two joint acceptability relations are based on the same notion
of local acceptability (for instance, considering a set of arguments E as acceptable for an AF when it is included in at
least one of its preferred extensions) and the same voting method (for instance, the simple majority rule).

Thus, it can be the case that new jointly acceptable sets are obtained after merging while they were not jointly

acceptable at start:

Proposition 44. Let P = (cid:3)AF1, . . . , AFn(cid:4) be a proﬁle of AFs over the same set of arguments A. The set of all jointly
acceptable sets for the proﬁle P is not necessarily equal to the set of all jointly acceptable sets for the merging of P.

A counter-example is given by Example 14.
When each local acceptability relation corresponds exactly to the collective acceptability proposed by Dung (for
a given semantics and ∀AFi , AccAFi (E) = true if and only if E is an extension of AFi for this semantics), the following
remarks can be done:

• If a set of arguments is included in one of the acceptable sets for an agent, it is not necessarily included into one
of the acceptable sets of any AF from the merging (and it also holds for singletons). The converse is also true.
• More surprisingly, even if a set of arguments is included into each acceptable set for an agent, it is not guaranteed
to be included into an acceptable set of an AF from the merging. Conversely, if a set of arguments is included
into every acceptable set of the AFs from the merging, it is not guaranteed to be included into an acceptable set

752

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

for one of the agents. Intuitively, this can be explained by the fact that if an argument is accepted by all agents for
bad reasons (for instance, because they lack information about attacks on it), it can be rejected by the group after
the merging. More formally, this is due to the fact that nothing ensures that one of the initial AFs will belong to
the result of the merging and also to the fact that acceptability is non-monotonic (in the sense that adding a single
attack (a, b) in an AF may drastically change its extensions).

8. Conclusion and perspectives

We have presented a framework for deriving sensible information from a collection of argumentation systems à la
Dung. Our approach consists in merging such systems. The proposed framework is general enough to allow for the
representation of many different scenarios. It is not assumed that all agents must share the same sets of arguments.
No assumption is made concerning the meaning of the attack relations, so that such relations may differ not only
because agents have different points of view on the way arguments interact but more generally may disagree on
what an interaction is. Each agent may be associated to a speciﬁc expansion function, which enables for encoding
many attitudes when facing a new argument. Many different distances between PAFs and many different aggregation
functions can be used to deﬁne argumentation systems which best represent the whole group.

By means of example, we have shown that our merging-based approach leads to results which are much more
expected than those furnished by a direct vote on the (sets of) arguments acceptable by each agent. We have also
shown that union cannot be taken as a valuable merging operator in the general case. We have investigated formally
some properties of the merging operators which we point out. Among other results, we have shown that merging
operators based on the edit distance preserve all the information on which all the agents participating in the merg-
ing process agree, and more generally, all the information on which the agents participating in the merging process
do not disagree. We have also shown that the merging operator based on the edit distance and the sum as aggre-
gation function is closely related to the merging approach which consists in voting on the attack relations when
the input proﬁle gathers argumentation systems over the same set of arguments. Finally, we have proven that in the
general case, the derivable sets of arguments when joint acceptability concerns the input proﬁle may drastically dif-
fer from the derivable sets of arguments when joint acceptability concerns the proﬁle obtained after the merging
step.

We plan to reﬁne our framework in several directions.
Merging PAFs. Our framework can be extended to PAFs merging (instead of AFs). This enables us to take into
account agents with incomplete belief states regarding the attack relation between arguments. Expansions of PAFs
can be deﬁned in a very similar way to expansions of AFs (what mainly changes is the way ignorance is handled). As
PAFs are more expressive than AFs, an interesting issue for further research is to deﬁne acceptability for PAFs.

Attacks strengths. Assume that each attack believed by Agent i is associated to a numerical value reﬂecting the
strength of the attack according to the agent, i.e., the degree to which Agent i believes that a attacks b. It is easy
to take into account those values by modifying slightly the deﬁnition of the edit distance over an ordered pair of
arguments (for instance, viewing such values as weights once normalized within [0, 1]). Another possibility regarding
attack strengths is, from unweighted attack relations, to generate a weighted one, representing different degrees of
accordance in the group. For instance, each attack (a, b) in the majority PAF of a proﬁle (cid:3)AF1, . . . , AFn(cid:4) can be
labeled by the ratio #({i∈1...n|(a,b)∈Ri })
and similarly for the non-attack relation (this leads to consider both the attack
and the non-attack relations of the majority PAF as fuzzy relations). Corresponding acceptability relations remain to
be deﬁned. This is another perspective of this work.

n

Merging audiences. In [7], an extension of the notion of AF, called valued AF—VAF for short—has been proposed
in order to take advantage of values representing the agent’s preferences in the context of a given audience. A further
perspective of our work concerns the merging of such VAFs.

Acknowledgements

The authors are grateful to the anonymous referees for their helpful comments. This work has been partly supported

by the Région Nord/Pas-de-Calais, the IRCICA consortium and by the European Community FEDER Program.

S. Coste-Marquis et al. / Artiﬁcial Intelligence 171 (2007) 730–753

753

References

[1] L. Amgoud, C. Cayrol, Inferring from inconsistency in preference-based argumentation frameworks, Journal of Automated Reasoning 29

(2002) 125–169.

[2] L. Amgoud, C. Cayrol, A reasoning model based on the production of acceptable arguments, Annals of Mathematics and Artiﬁcial Intelli-

gence 34 (2002) 197–216.

[3] L. Amgoud, N. Maudet, S. Parsons, Arguments, dialogue and negotiation, in: Proc. of ECAI’00, 2000, pp. 338–342.
[4] L. Amgoud, S. Parsons, Agent dialogues with conﬂicting preferences, in: Intelligent Agents VIII: Agent Theories, Architectures and Lan-

guages, 2002, pp. 190–205.

[5] L. Amgoud, H. Prade, Reaching agreement through argumentation: A possibilistic approach, in: Proc. of KR’04, 2004, pp. 175–182.
[6] T. Bench-Capon, Persuasion in practical argument using value-based argumentation frameworks, Journal of Logic and Computation 13 (3)

(2003) 429–448.

[7] T. Bench-Capon, S. Doutre, P.E. Dunne, Audiences in argumentation frameworks, Artiﬁcial Intelligence 171 (2007) 42–71.
[8] P. Besnard, A. Hunter, A logic-based theory of deductive arguments, Artiﬁcial Intelligence 128 (1–2) (2001) 203–235.
[9] A. Bochman, Collective argumentation and disjunctive programming, Journal of Logic and Computation 13 (3) (2003) 405–428.
[10] C. Cayrol, M.-C. Lagasquie-Schiex, Graduality in argumentation, Journal of Artiﬁcial Intelligence Research 23 (2005) 245–297.
[11] C. Cayrol, M.-C. Lagasquie-Schiex, On the acceptability of arguments in bipolar argumentation frameworks, in: Proc. of ECSQARU’05, in:

Lecture Notes Artif. Intell., vol. 3571, Springer-Verlag, 2005, pp. 378–389.

[12] S. Coste-Marquis, C. Devred, P. Marquis, Symmetric argumentation frameworks, in: Proc. of ECSQARU’05, in: Lecture Notes Artif. Intell.,

vol. 3571, Springer-Verlag, 2005, pp. 317–328.

[13] P.M. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games,

Artiﬁcial Intelligence 77 (1995) 321–357.

[14] P. Dunne, T. Bench-Capon, Coherence in ﬁnite argument systems, Artiﬁcial Intelligence 141 (2002) 187–203.
[15] M. Elvang-Gøransson, J. Fox, P. Krause, Acceptability of arguments as logical uncertainty, in: Proc. of ECSQARU’93, in: Lecture Notes

Comput. Sci., vol. 747, Springer-Verlag, 1993, pp. 85–90.

[16] M. Elvang-Gøransson, J. Fox, P. Krause, Dialectic reasoning with inconsistent information, in: Proc. of UAI’93, 1993, pp. 114–121.
[17] M. Elvang-Gøransson, A. Hunter, Argumentative logics: Reasoning with classically inconsistent information, Data and Knowledge Engineer-

ing 16 (1995) 125–145.

[18] T.F. Gordon, The Pleadings Game. An Artiﬁcial Intelligence Model of Procedural Justice, Kluwer Academic, 1995.
[19] H. Jakobovits, D. Vermeir, Robust semantics for argumentation frameworks, Journal of Logic and Computation 9 (2) (1999) 215–261.
[20] S. Konieczny, R. Pino Pérez, Merging information under constraints: a qualitative framework, Journal of Logic and Computation 12 (5) (2002)

773–808.

[21] P. Krause, S. Ambler, M. Elvang, J. Fox, A logic of argumentation for reasoning under uncertainty, Computational Intelligence 11 (1) (1995)

113–131.

[22] J. MacKenzie, Question-begging in non-cumulative systems, Journal of Philosophical logic 8 (1979) 117–133.
[23] S. Nielsen, S. Parsons, Computing preferred extensions for argumentation systems with sets of attacking arguments, in: Proc. of COMMA’06,

IOS Press, 2006, pp. 97–108.

[24] S. Parsons, N.R. Jennings, Negotiation through argumentation—a preliminary report, in: Proc. of ICMAS’96, 1996, pp. 267–274.
[25] J.L. Pollock, Defeasible reasoning with variable degrees of justiﬁcation, Artiﬁcial Intelligence 133 (2001) 233–282.
[26] H. Prakken, G. Sartor, Argument-based extended logic programming with defeasible priorities, Journal of Applied Non-Classical Logics 7

(1997) 25–75.

[27] H. Prakken, G. Vreeswijk, Logics for defeasible argumentation, in: Handbook of Philosophical Logic, vol. 4, Kluwer Academic, 2002,

pp. 218–319.

[28] D. Walton, E. Krabbe, Commitment in Dialogue. Basic Concepts of Interpersonal Reasoning, State University of New York Press, 1995.

