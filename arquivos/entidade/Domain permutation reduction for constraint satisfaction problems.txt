Artificial Intelligence 172 (2008) 1094–1118www.elsevier.com/locate/artintDomain permutation reduction for constraint satisfaction problemsMartin J. Green ∗, David A. CohenComputer Science Department, Royal Holloway, University of London, Egham, Surrey, TW20 0EX, UKReceived 24 January 2007; received in revised form 28 November 2007; accepted 7 December 2007Available online 15 December 2007AbstractThis paper is concerned with the Constraint Satisfaction Problem (CSP). It is well-known that the general CSP is NP-hard.However, there has been significant success in discovering subproblems which are tractable (polynomial time solvable). One ofthe most effective ways to obtain a tractable subproblem has been to force all of the constraint relations to lie in some tractablelanguage.In this paper we define a new way of identifying tractable subproblems of the CSP. Let P be an arbitrary CSP instance and Γbe any tractable language. Suppose there exists, for each variable of P , a permutation of the domain such the resultant permutedconstraint relations of P all lie in Γ . The domain permuted instance is then an instance of a tractable class and can be solved bythe polynomial time algorithm for Γ . Solutions to P can be obtained by inverting the domain permutations.The question, for a given class of instances and language Γ , whether such a set of domain permutations can be found efficientlyis the key to this method’s tractability. One of the important contributions made in this paper is the notion of a “lifted constraintinstance” which is a powerful tool to study this question.• We consider the open problem of discovering domain permutations which make instances max-closed. We show that, forbounded arity instances over a Boolean domain this problem is tractable, while for domain size three it is intractable even forbinary instances.• We give a simple proof verifying the tractability of discovering domain permutations which make instances row convex.We refute a published result by giving a simple proof of the intractability of discovering domain permutations which makeinstances, even with domain size four, connected row convex.• We demonstrate that triangulated and stable marriage instances are reducible, via domain permutations, to max-closed in-stances. This provides a simple explanation for arc consistency deciding these instances.• We verify with a simple direct proof the tractability of identification of renamable Horn instances, and the intractability offinding the largest renamable Horn subset of clauses of an instance of SAT.• We describe natural tractable classes which properly extend the maximal relational classes arising from tractable constraintlanguages.We believe that domain permutation reductions have a significant chance of being useful in practical applications.© 2008 Elsevier B.V. All rights reserved.Keywords: Complexity; Constraint satisfaction problem; CSP; NP-completeness; Renamable Horn; Stable marriage; Tractability* Corresponding author.E-mail address: M.J.Green@cs.rhul.ac.uk (M.J. Green).0004-3702/$ – see front matter © 2008 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2007.12.001M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–111810951. IntroductionThe constraint satisfaction paradigm involves modelling a real-world problem as a set of variables to which wecan assign values from some domain [44]. The values that can be assigned are limited by constraints. A constraintconsists of a list of variables (its scope), and a set of tuples which are the allowed assignments to this list of variables(its relation). A solution is the assignment of a value from the domain to every variable so that all of the constraintsare satisfied.Many real-world problems are naturally represented as instances of the general constraint satisfaction problem(CSP), including planning [40], scheduling [48], image processing [44], frequency assignment [21] and natural lan-guage understanding [1].The CSP is NP-hard [43]. This motivates the search for polynomial time solvable (tractable) subproblems.The structure of a CSP instance is the hypergraph whose hyperedges are the scopes (abstracted to be sets of distinctvariables) of the constraints. The set of CSP instances whose structure is acyclic form a tractable subproblem [4].This structural tractability result has been extended by identifying tractable decompositions of hypergraphs (cycle-cutset [17], hypertree decompositions [30], hinges [22,33], tree-clustering [18], etc.). These decompositions all jointhe original constraints in sets of size at most k and project each such join to form the constraints of a new, solutionequivalent, acyclic CSP instance [15]. The value k is called the width of the decomposition. A decomposition istractable if, for any k, the set of instances with width at most k can be tractably identified and reduced to the acycliccase.It is rare that a real-world example has an acyclic structure when modelled as a CSP instance. However the possibil-ity of using these widely applicable decompositions to reduce instances to the acyclic case makes structural tractabilityuseful in practice.A constraint language is a set of allowed (constraint) relations. A relational subproblem of the CSP consists ofthose instances whose relations lie in a specified language. A language which gives a tractable relational subproblemis called tractable [34,35]. Many tractable languages have been discovered [7,46].This paper introduces a new study: reductions by domain permutations. A domain permutation reduction of an in-stance to a given subproblem of the CSP is an independent permutation of the domain of each variable that transformsthe instance to lie in that subproblem. Some preliminary results appeared in a conference paper [32].We will show that determining whether a domain permutation reduction exists for a particular instance to a rela-tional subproblem corresponds exactly to the solving of an associated instance of another CSP subproblem. When this“lifted” problem for a tractable language is itself tractable then, under certain natural assumptions, we obtain a newlarge tractable subproblem.We consider the well-known max-closed tractable languages [36]. In their original paper Jeavons and Cooper leftas an open question whether there exists an efficient algorithm that can decide, for any given instance, if a domainpermutation exists that makes the instance max-closed [36]. We answer this question in Section 5.2 for the case wherethe domain has three or more elements (it is intractable) by analysing the appropriate lifted problem.However, by more careful analysis of the lifted problem for max-closed languages we are able to properly extendthe tractable subproblem of bounded arity Boolean max-closed instances. We can also extend the tractable subprob-lem of all binary max-closed instances, which has been shown [36] to be maximal as a tractable binary relationalsubproblem of the CSP.Our theory also explains why the constraint representation of the Stable Marriage Problem (SMP) [27] is tractablysolvable. We have shown that these instances have a natural domain permutation reduction to the max-closed sub-problem.Recently, a new tractable subproblem of binary instances for which arc consistency is a decision procedure, knownas triangulated CSP instances [12], has been described. It was left as an open question to discover if some unifyingreason exists that explains why arc consistency is a decision procedure for this class. In this paper we provide just suchan explanation by showing that these instances also have natural domain permutation reductions to the max-closedsubproblem.A row convex CSP instance [49] can be transformed by a domain permutation to make a particular combinatoricproperty hold for its constraint relations. A connected row convex CSP instance [20] satisfies a slightly more restrictivecombinatoric property (without first applying a domain permutation restriction). This stronger property is preservedby projection and join. It was left as an open question as to whether we can tractably identify the instances for1096M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118which domain permutations exist transforming them into connected row convex instances. An incorrect answer tothis question has unfortunately appeared in the literature. In this paper we give a simple and correct answer to thisquestion.We also have a natural explanation for the tractability of renamable Horn theories [3,42], since the lifted problemscan easily be shown to be contained in the tractable majority-closed relational subclass [38]. It has been shown usingad-hoc methods that it is NP-hard to find the largest renamable Horn theory which is a subset of a given set ofclauses [19]. By analysing the lifted language this result becomes a simple consequence of a well-known result in thetheory of the MAX-SAT problem [16].1.1. Outline of the paperWe give the necessary basic definitions in Section 2 and then continue in Section 3 by discussing tractable constraintlanguages.We introduce our new work in Section 4 with the concept of a domain permutation reduction to a tractable relationalsubproblem and its associated lifted problem. We show the power of the new theory with an analysis of the domainpermutation reductions to the max-closed constraint language in Section 5.We use our new theory in Section 6 to:• develop some new tractable subproblems of the CSP;• unify several disparate known tractable subproblems;• show that the main results from renamable Horn theory may be obtained directly.We conclude the paper in Section 7 with final remarks and directions for future research.2. DefinitionsIn this section we will give a formal definition of a constraint satisfaction problem instance, and the associatednotions required for the paper.2.1. Constraint satisfaction problem instancesDefinition 1. An r-ary relation, ρ, over D is a subset of Dr .For any t ∈ ρ we denote by t[i], i ∈ {1, . . . , r}, the value at the ith coordinate position of t, so that t =(cid:4)t[1], . . . , t[r](cid:5).Definition 2. A Constraint Satisfaction Problem instance, P , is a triple, (cid:4)V , D, C(cid:5) where:• V is a set of variables;• D is any set, called the domain of the instance;• C is a set of constraints.Each constraint c ∈ C is a pair (cid:4)σ, ρ(cid:5) where σ is a list of variables from V , called the constraint scope, and ρ is a|σ |-ary relation over D, called the constraint relation. We call |σ | the arity of the constraint.A solution to P is a mapping s : V → D such that, for each (cid:4)σ, ρ(cid:5) ∈ C, s(σ ) ∈ ρ.A CSP instance is Boolean if its domain has two elements. It is binary if all its constraints have arity at most two.There is a special representation of binary relations which we will find useful.Definition 3. The matrix representation of a binary relation ρ over domain D is a (0, 1)-matrix Mρ with |D| rowsand columns. The entry Mρ(cid:4)i, j (cid:5) is equal to 1 exactly when (cid:4)i, j (cid:5) ∈ ρ.M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–111810972.2. Complexity of constraint satisfactionFor completeness we describe the representation of a CSP instance. Firstly the domain size and size of the variableset are given as integers. Then follows a list of constraints, each first giving the scope as a list of variables then therelation. Each constraint relation is represented extensionally as a list of tuples of domain values. In this representationthe size of the instance (cid:4)V , D, C(cid:5) is:(cid:4)(cid:3)log |V | + |ρ| log|D||σ |log|V | + log|D| +(cid:2).(cid:4)σ,ρ(cid:5)∈CFor any set C of CSP instances the decision problem for C is to determine, for any instance in C, whether it has asolution.It is clear that graph 3-colouring, or indeed 3-SAT, can be reduced to the decision problem for (an appropriate) setof CSP instances and so the decision problem for the class of all CSP instances is NP-complete [43].If we can solve a subproblem of the CSP then we can at least tell whether any real-world problem which is modelledas an instance of this subproblem is feasible. However, our task is usually to find such a solution if one exists.For any set C of CSP instances the search problem is to determine, for any instance in C, whether it has a solution,and if so to find such a solution.Definition 4. We call a problem P tractable if it has an algorithm which runs in time polynomial in the size of theinput instance.We call P intractable if it is NP-hard [24].It is the complexity of the search problem with which we are concerned in this paper.We extend the notion of a tractable set of constraint satisfaction problem instances by requiring that member-ship should also be polynomially determined. Of course, this is always a sensible restriction if we are going to usetractability results in any sense as an algorithm selector. The extra requirement of identifiability is usually adopted byresearchers on general satisfiability [19], and researchers on structural decompositions [28], but not unfortunately byresearchers on relational tractability.If we do not require polynomial time identification and instead consider a set of CSP instances to be tractable ifthey have a tractable search problem then this leads to the absurd notion that the set of all unsolvable CSP instancesis tractable! The algorithm for solving instances from this set of CSP instances is easy (just say no), but determiningwhether a CSP instance is a member of this set is NP-hard. The usefulness of this notion of tractability is highlydoubtful. To overcome this limitation, we define, for any set C of CSP instances the identification problem for C whichis to determine, for any CSP instance, whether or not it lies in C.We will call a class C of CSP instances tractable if both its search problem and its identification problem aretractable, otherwise we say that C is intractable.This notion of tractability is of practical use: When we are given a CSP instance, we have first to determine which(tractable) subclass (if any) it belongs to, and then we can apply the appropriate solution algorithm.Even under this stronger notion of tractability there are many tractable sets of CSP instances.Definition 5. A hypergraph H is a pair (cid:4)V , E(cid:5) where V is a set of vertices and E is a collection of subsets of V , calledthe hyperedges of H .The structure of a CSP instance, P , is the hypergraph σ (P ) whose vertices are the variables of P and whosehyperedges are the scopes of the constraints of P (abstracted to be sets of distinct variables).A class of CSP instances is called structural if it is precisely those instances whose structure is limited in someparticular way.A fundamental tractable structural subclass of the general constraint satisfaction problem is those instances whosestructure is acyclic [4]. However, this subclass has been extended by considering instances whose structure is “nearlyacyclic” in the sense that there is a tractable reduction to an acyclic instance [29]. These reductions give rise to setsof CSP instances whose cost of reduction to the acyclic subclass is bounded by a polynomial. Such subclasses havebeen well studied and have made the use of tractable structural subclasses applicable to a wide variety of real-worldexamples [41].1098M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118Definition 6. A constraint language over a domain D is a set of relations over D.The language of a CSP instance, P , is the constraint language defined by the set of relations of the constraints of P .The language of a set of CSP instances is the union of the languages of the instances. For any constraint language Γwe will refer to the set of CSP instances with language contained in Γ as CSP(Γ ).A class of CSP instances is called relational if it is precisely CSP(Γ ) for some language Γ .A constraint language is called tractable if the set of instances defined over this language has a tractable decisionproblem. There are many known tractable constraint languages [7,13]. We will describe some of these in Section 3.It has been shown that if the decision problem can be answered polynomially for the set of instances defined overa given constraint language then so can the search problem [11]. It follows that a relational subclass which has atractable identification problem and whose language is tractable is also tractable in the sense in which we use the termin this paper.Previous work has not considered the possibility of reductions to relational tractability. In this paper we introducethe notion of domain permutation reduction of an instance to a given subproblem of the CSP, which is an independentpermutation of the domain of each variable that transforms the instance to lie in that subproblem.This natural extension to the theory of tractability yields large new tractable subclasses, unifies apparently disparateknown tractable classes and simplifies proofs of (in)tractability.Example 7. In this example we define a new class of Boolean CSP instances whose constraints are generalisations ofHorn-clauses.A propositional literal is either a propositional variable (positive), for example p, or a negated propositional vari-able (negative), for example q. A clause is a disjunction of literals, for example, p ∨ q.Let V + = {p1, p2, . . .} and V − = {q1, q2, . . .} and let V = V + ∪ V −. For any clause c over the variables in V ,positive disjuncts from V + and negative disjuncts from V − are said to have appropriate negation. We say that c issplit-Horn if there is at most one disjunct with inappropriate negation.Order the set of variables V as p1, q1, p2, q2, p3, q3, . . . . We represent a clause as the constraint whose scope is theordered list of variables occurring in the clause and whose relation allows the truth assignments allowed by the clause.In this way we can represent conjuncts of split-Horn clauses as CSP instances over the Boolean domain {F, T }.We call these Boolean CSP instances split-Horn.We can easily construct split-Horn instances with any given structure. So the class of all split-Horn instances is notstructurally tractable.Example 8. Let H be any hypergraph. Without loss of generality identify the vertex set of H with a subset of V +.For each edge e of H define the edge clause c(e) =p∈e p. The CSP instance representing the conjunct of all of theedge clauses has structure H and is split-Horn.(cid:5)There is a well-known dichotomy result for Boolean constraint languages [47]. The language of the split-Horninstances is NP-hard. However, we easily show the tractability of the split-Horn subclasses in Section 6.5 as part of amore general tractable class using the theory of reductions to tractable constraint languages.3. Tractable constraint languagesIn this section we briefly describe the well-known algebraic approach to determining the tractability of a (finite)constraint language [13,37].Definition 9. An n-ary operator φ over a set D is a function from Dn to D. We apply φ to n tuples t1, . . . , tn fromthe r-ary relation ρ over D by applying it pointwise as follows:(cid:3)(cid:4)(cid:3)t1[r], . . . , tn[r]t1[1], . . . , tn[1], . . . , φφ(t1, . . . , tn) =(cid:4)(cid:7)φ.(cid:6)We call φ an n-ary polymorphism [37] of ρ if it preserves membership of ρ in the following way:∀t1, . . . , tn ∈ ρ, φ(t1, . . . , tn) ∈ ρ.M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–11181099When φ is a polymorphism of ρ we say that ρ is φ-closed or closed under φ. We say that φ is a polymorphism of aconstraint language Γ if φ is a polymorphism of every relation in Γ . If this is the case we also say that Γ is φ-closedor closed under φ.Closure under certain types of polymorphism guarantees tractability. That is, there is an efficient algorithm forsolving the class of CSP instances whose constraint relations are all closed under a particular polymorphism. In thenext section we shall describe some of these special polymorphisms which give tractability and we will then use theseexamples throughout the remainder of the paper. We will also describe a tool, Polyanna [25,26], which can be used tofind such useful polymorphisms for a given finite constraint language, or even to prove that none exist.3.1. Useful polymorphismsDefinition 10. Given the ordered domain {1, . . . , k} we define the binary max operator to be the operator that returnsthe larger of its two arguments.The set of all max-closed relations forms a tractable constraint language [36]. In particular, a polynomial solutiontechnique is to establish (generalised) arc consistency [5,43], and then to choose the largest remaining domain valuefor each variable.There is also the analogous tractable language of all min-closed relations that are closed under the binary operatormin which returns the smaller of its two arguments.Definition 11. A ternary operator φ over domain D is called a majority operator if, for every d, e ∈ D, we havethat:φ(d, d, e) = φ(d, e, d) = φ(e, d, d) = d.The set of all relations closed under any given majority operator is tractable [38]. A polynomial solution techniquehere is to transform the instance into an equivalent binary instance for which path consistency is a decision procedure.3.2. PolyannaA very difficult problem is that of determining whether a given constraint language is tractable or intractable. Weknow that the existence of a useful polymorphism can guarantee tractability [36,37]. Even so, it is usually very difficultto determine tractability for quite small constraint languages.However, Gault has written a program, Polyanna [25,26], which determines the polymorphisms of an input con-straint language. It uses many optimisation techniques to reduce the cost of searching for polymorphisms. In additionto listing the polymorphisms, Polyanna can classify a constraint language into one of several tractability classes.Using the fact that a constraint language with domain D is intractable if it has no non-trivial polymorphisms up toarity max(3, |D|) [37] Polyanna is also able to demonstrate intractability in many cases.4. Domain permutation reductionsSuppose that we have a tractable constraint language Γ and that P is any CSP instance with the same domain.If we can find permutations of the domain (independently) for each variable, that transform P into an instance ofCSP(Γ ), then we can solve the instance P using the algorithm for Γ . We first permute the domains, then apply thealgorithm for Γ , then permute the domains back again for any discovered solution.This reduction technique for (tractable) constraint languages is the focus of this paper.Definition 12. A permutation of a set D is a bijection from D to D.Let (cid:10)π = (cid:4)π1, . . . , πr (cid:5) be an r-tuple of permutations of D. We apply (cid:10)π to r-tuples of values from D in the naturalway by applying πi , i = 1, . . . , r, to the ith component. We apply (cid:10)π to r-ary relations over D by applying it in turn toeach of the allowed tuples.1100M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118Let P = (cid:4)V , D, C(cid:5) be a CSP instance, and G be a set of permutations of D. A domain permutation for P over Gis a mapping Π assigning to each variable v ∈ V a permutation from G.For any scope σ = (cid:4)v1, . . . , vr (cid:5) we define Π(σ ) = (cid:4)Π(v1), . . . , Π(vr )(cid:5).For any constraint c = (cid:4)σ, ρ(cid:5) we define Π(c) = (cid:4)σ, Π(σ )(ρ)(cid:5).For a CSP instance P = (cid:4)V , D, C(cid:5) we define Π(P ) = (cid:4)V , D, {Π(c) | c ∈ C}(cid:5).Discovery of appropriate domain permutations will be the identification procedure for these new tractable classes.It can be the case that this identification problem is intractable when we consider every possible permutation of thedomain. For this reason we may need to reduce the set G of permutations of the domain. An example (Example 41)is given in Section 6.1.Example 13. Consider again the split-Horn class defined in Example 7.Both of the clauses c1 = p1 ∨ p2 ∨ q1 and c2 = p2 ∨ q1 ∨ q2. have exactly one disjunct with inappropriate negationand so the instance Psh representing their conjunction is split-Horn.There is exactly one non-trivial permutation τ of the domain {F, T } of Psh: it interchanges T and F . The trivialpermutation ι fixes both T and F .Define the domain permutation Π for Psh as:Π(v) =(cid:8)ιτif v = p2,otherwise.The scope of c1 is (cid:4)p1, p2, q1(cid:5) and Π((cid:4)p1, p2, q1(cid:5)) = (cid:4)τ, ι, τ (cid:5). Hence Π(c1) is the constraint representing theclause p1 ∨ p2 ∨ q1. Similarly Π(c2) is the constraint representing the clause p2 ∨ q1 ∨ q2.Whilst the clause represented by Π(c2) has appropriate negation, that represented by Π(c1) does not and so Π(Psh)is not split-Horn.Definition 14. Let Γ be a constraint language, P = (cid:4)V , D, C(cid:5) a CSP instance and G a set of permutations of D. Ifthere exists a domain permutation Π for P over G such that Π(P ) ∈ CSP(Γ ) then we say that P is G-reducible to Γ .For a given Γ and G the problem of determining whether an instance is G-reducible to Γ is called the G-reductionproblem into Γ .Example 15. Let Γ be any constraint language.Suppose that G is a set of permutations of D that contains the identity permutation ι.Let P = (cid:4)V , D, C(cid:5) be a CSP instance in CSP(Γ ). Consider the constant domain permutation Π where Π(v) = ιfor every v ∈ V .It is immediate from the definition that Π(P ) = P .Hence if G contains the identify permutation then every instance of CSP(Γ ) is G-reducible to Γ .For tractable languages Γ we are looking for large sets of instances C for which the G-reduction problem into Γis tractable. In this case the set of G-reducible instances in C is a tractably solvable set of CSP instances. The resultsof this paper are all applications of the following theorem whose proof is straightforward.Theorem 16. Let Γ be a tractable constraint language over a domain D, G be a set of permutations of D, and C bea set of instances with a tractable G-reduction problem into Γ . The set of instances of C which are G-reducible to Γhas a tractable search problem.We obtain the following corollary directly from the definition of tractability.Corollary 17. Let Γ be a tractable constraint language over a domain D, G be a set of permutations of D, and C bea tractably identifiable set of instances with a tractable G-reduction problem into Γ . The set of instances of C whichare G-reducible to Γ is tractable.M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–111811014.1. Using lifted relations to find domain permutationsA natural application of Theorem 16 is to the case where C is CSP(Δ) for some language Δ.Definition 18. Let Δ be any constraint language over domain D.The subproblem of the G-reduction problem into Γ whose instances are precisely the CSP instances of CSP(Δ) iscalled the G-reduction problem from Δ into Γ .Example 19. Let Δ be the language of all Boolean ternary relations. Let Γ be the language of all max-closed Booleanternary relations.Again let τ swap the Boolean domain elements and let ι leave them fixed. Let G1 = {ι} and G2 = {τ, ι}.The G1-reduction problem from Δ into Γ just asks which instances of CSP(Δ) happen also to be instances ofCSP(Γ ). This is just the identification problem for Boolean ternary max-closed instances which is tractable.On the other hand the G2-reduction problem for Δ into Γ asks for a given Boolean ternary instance, whether thereare independent permutations of the domain at each variable, which make the instance max-closed. The tractability ofthis question is not obvious. Proposition 36 will show this also to be a tractable problem.For any r-ary relation ρ over D there are some r-tuples of permutations from G which make ρ into a relation ofΓ . The set of such r-tuples over G is simply an r-ary relation over G.Definition 20. Let Γ be a constraint language, ρ be an r-ary relation over D, and G be a set of permutations of D.We define the G-lifted relation of ρ into Γ , ρG(cid:9)(cid:4)π1, . . . , πr (cid:5) ∈ GrΓ , to be the following r-ary relation over G:(cid:10)(cid:10) (cid:4)π1, . . . , πr (cid:5)(ρ) ∈ Γ(cid:11).=ρGΓGiven a CSP instance P we can use lifted relations to construct a CSP instance with domain G whose solutionsare precisely the domain permutations that transform P into an instance of CSP(Γ ).Definition 21. Let P = (cid:4)V , D, C(cid:5) be a CSP instance, G be a set of permutations of D and Γ be a constraint language.(cid:5) |Γ , to be the CSP instance (cid:4)V , G, C(cid:11)(cid:5) where C(cid:11) = {(cid:4)σ, ρGWe define the G-lifted instance for P into Γ , P GΓ(cid:4)σ, ρ(cid:5) ∈ C}.Example 23, concerning row convex constraints, illustrates the power of this technique.Definition 22. A binary relation ρ over an ordered domain is said to be row convex [49] if in every row and columnof its matrix representation the entries that are one are consecutive.Example 23. Whilst row convex constraints do not form a tractable language, in the sense of this paper, Dechter andvan Beek [49] proved that any path consistent CSP instance whose relations are row convex is globally consistent.They also described the row convex identification problem for binary CSP instances, which is precisely the reduc-tion problem into the row convex constraint language.We will solve the row convex identification problem for a particular CSP instance P = (cid:4)V , D, C(cid:5) by solving thelifted instance.Let the domain D of P be {1, 2, 3} and the variables V of P be {x, y, z}. We will use only one constraint relation, ρ,which for convenience we describe in matrix form:⎛⎝1 2 3011101011⎞⎠ .321Here we have explicitly indexed the rows and columns of the array with the elements of the domain.There are three constraints in P , one for each pair of variables, each constrained by the relation ρ. That is, C ={(cid:4)(cid:4)x, y(cid:5), ρ(cid:5)(cid:4)(cid:4)y, z(cid:5), ρ(cid:5)(cid:4)(cid:4)z, x(cid:5), ρ(cid:5)}.1102M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118To make ρ row convex we will apply permutations (possibly trivial) to the domain of each variable. There are sixpossible permutations of the domain {1, 2, 3} which we will name as follows.• ι fixes all three domain elements.• For each {i, j } in D, π{i,j } swaps i and j and fixes the third domain element.• π→ moves 1 to 2, 2 to 3 and 3 to 1.• π← moves 3 to 2, 2 to 1 and 1 to 3.Let G be the set of these six permutations and Γ be the set of row convex relations with domain {1, 2, 3}. The liftedΓ permutes the rows of the matrixΓ consists of pairs of elements of G. The first component of a tuple in ρGrelation ρGrepresentation and the second permutes the columns.Let (cid:4)ω1, ω2(cid:5) ∈ ρGΓ . The permutation ω1 must leave 1 and 3 adjacent. Hence ω1 must be in the set Ω1 ={π{1,2}, π→, π{2,3}, π←}. Similarly, ω2 must leave 1 and 3 adjacent, and 1 and 2 adjacent. Hence ω2 must be inthe set Ω2 = {π{1,2}, π→}.Since permuting the rows (columns) leaves the row (column) contents unchanged the permutation ω1 which collectstogether the ones in the columns can be chosen independently of the permutation ω2 which collects together the onesin the rows. So the lifted relation ρGΓ is the product of unary relations and we have that ρGΓ= Ω1 × Ω2.= (cid:4)V , G, C(cid:11)(cid:5) has the same three variables as P . The domain is the set of permutations, G.The lifted instance P GΓThere is a constraint in C(cid:11) for each constraint in C. In this case C(cid:11) = {(cid:4)(cid:4)x, y(cid:5), ρGΓThe solutions to P GΓ are precisely the assignments s : V (cid:13)→ G where ∀v ∈ V , s(v) ∈ {π{1,2}, π→}. By constructionthese are precisely the set of domain permutations that solve the reduction problem for P : simultaneously permutingthe domain of each variable to make each constraint relation row convex.(cid:5)(cid:4)(cid:4)y, z(cid:5), ρGΓ(cid:5)(cid:4)(cid:4)z, x(cid:5), ρGΓ(cid:5)}.We can generalise these notions to specify a new relational problem equivalent to the G reduction problem from alanguage Δ to the language Γ .Definition 24. For any constraint language Δ we define the G-lifted language of Δ into Γ to be ΔGΓ= {ρGΓ| ρ ∈ Δ}.We call the search problem for the set of instances {P GΓ| P ∈ CSP(Δ)} the G-lifted problem from Δ into Γ .Proposition 25. The G-lifted problem from Δ into Γ is tractable if and only if ΔGΓ is a tractable constraint language.Proof. The result follows immediately from the fact that the instances of CSP(ΔGof CSP(Δ). (cid:2)Γ ) are precisely the lifted instancesProposition 26. The G-reduction problem into Γ for P has a solution if and only if P GΓ has a solution.Proof. For any CSP instance, P , solutions to the instance P Greduce P to an instance of CSP(Γ ). (cid:2)Γ are defined to be the domain permutations from G thatWe do not get immediately that the G-reduction problem is tractable if and only if the lifted language is tractable.We have to consider the cost of moving between representations. In this paper we will use two results connectinglifted languages and reduction problems. The proof of these propositions is straightforward and omitted.Proposition 27. If there exists a polynomial time algorithm that, given any P ∈ CSP(Δ), generates P Gtractable then the G-reduction problem from Δ into Γ is tractable.Γ and ΔGΓ isProposition 28. If any finite subset of ΔGΓ is intractable, so is the G-reduction problem from Δ into Γ .It follows immediately that:Corollary 29. If Δ is finite then the G-reduction problem from Δ into Γ is tractable if and only if ΔGΓ is tractable.M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–11181103Proof. If Δ is finite then so is ΔGtable. (cid:2)Γ . Since Δ is finite, for any P ∈ CSP(Δ) we can generate P GΓ using a lookupProposition 27 will be used to establish the tractability of novel subclasses of the general constraint satisfactionproblem. Proposition 28 will only be useful in establishing the intractability of certain problems. We will use Corol-lary 29 repeatedly in the remainder of this paper to prove tractability results.We finish this section by showing how this new theory can give a simple explanation for an important theoremwhose existing proof is quite involved.Example 30. Recall the definition of the row convex identification problem from Example 23.Dechter and van Beek [49] proved that the row convex identification problem is tractable using a result from graphtheory.In Example 23 we established the fact that permuting the rows (columns) leaves the row (column) contents un-changed. It follows that any lifted relation will be the product of unary relations so the lifted language is tractable.The tractability of the reduction problem follows immediately by Proposition 27.4.2. The intractability of reductionIn general, the lifted problem and reduction problem are intractable, even when lifting into tractable languages.More specifically, there exist constraint languages with only one relation whose lifted problem and reductionproblem into a tractable language are both intractable.Example 31. Let Γ be the 0-valid language over D = {0, 1, 2}. That is, Γ contains all relations over D which allowthe all zeros tuple.We can solve any instance by assigning zero to every variable, so Γ is tractable.The graph 3-colourability problem can be naturally encoded using CSP instances over domain D with only binarythree valued inequality constraints. It follows that the language, Δ, containing only the binary three-valued inequalityrelation is intractable.Now consider any CSP instance P = (cid:4)V , D, C(cid:5) in CSP(Δ).Suppose that s is a solution to P . Let πv be the permutation of D which swaps s(v) and 0 and fixes all other domainvalues. The domain permutation Π where ∀v ∈ V , Π(v) = πv is a solution to the lifted instance PΓ .Conversely, let ˆs be a solution to PΓ . Define the function s(cid:11) : V (cid:13)→ D by s(cid:11)(v) = (ˆs(v))−1(0). By construction, s(cid:11)is a solution to P .Since Δ is finite it follows by Corollary 29 that the reduction problem is intractable.5. Lifted relations into max-closureIt may not be surprising that the lifted problem of Example 31 is intractable, for it is exactly as hard as solving theinstances for which we are trying to find reductions.Jeavons and Cooper [36] pose a question of the complexity of identifying instances that become max-closed afterapplying an (independent) re-ordering of the domain at each variable. In this section we will show that this problem istractable for the class of bounded arity Boolean CSP instances but is intractable for larger domains, even in the caseof binary CSP instances. The question remains open for Boolean CSP instances of unbounded arity.Schaefer [47] classified all maximal Boolean tractable relational classes of CSP instances. Our new result forbounded arity Boolean instances properly extends a maximal Boolean relational class and so has interest beyond(partially) solving an open question.Example 32. A disjunction of propositional literals (clause) with at most one negative literal is called an anti-Hornclause. Any Boolean relation corresponding to an anti-Horn clause is called an anti-Horn relation. Jeavons et al. [37]showed that the anti-Horn relations are all max-closed.For any k > 2, let Γk be the class of max-closed relations of arity at most k. Jeavons et al. [37] showed that theclass CSP(Γk) is a maximal tractable relational class. That is, for any arity k relation ρ, where ρ /∈ Γk, CSP(Γk ∪ {ρ})is intractable.1104M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118Consider again the split-Horn class C of Boolean instances defined in Example 7. Certainly, for every k, C containsan instance which is not in CSP(Γk). Despite this we will show that each class C ∪ CSP(Γk), k > 2 is tractable.This extension is compatible with Schaefer’s original classification [47] since he identified precisely the maximal (byinclusion) tractable relational classes.Given an instance P = (cid:4)V , D, C(cid:5) first check (in polynomial time) whether it is in CSP(Γk). Otherwise define thedomain permutation Π for P , where Π(v) is the permutation swapping T and F if v ∈ V − and Π(v) fixes T andF otherwise. Since each clause defining P has at most one disjunct with inappropriate negation it follows that eachconstraint relation in Π(P ) is anti-Horn and so max-closed.We have established that each class of instances, C ∪ CSP(Γk), k > 2, is a proper tractable extension of a maximaltractable relational class.These new tractable CSP classes are obtained by domain permutation reduction to the max-closed language. It istherefore of interest to determine whether the class of all arity k instances which are reducible by domain permutationsto the max-closed language is tractable.5.1. Lifting Boolean CSP instances into max-closureLet Γ be the set of all max-closed relations over the ordered Boolean domain {F, T }, where F < T . There are onlytwo permutations of a Boolean domain. Again we denote by ι the identity permutation, and by τ the permutation thatswaps the two domain values. Let G be the set {ι, τ }.We find a representation for a tuple of permutations from G in terms of a tuple of binary operators. By consideringthe structure of the set of tuples corresponding to lifting into max-closure for Boolean CSP instances we will showthat this reduction problem is tractable when a bound is imposed on the arity of the CSP instances.Definition 33. Suppose that l ∈ Gr so that l is an r-tuple of permutations of the Boolean domain {F, T }. We defineml ∈ {min, max}r to be the r-tuple of binary operators such that, for i = 1, . . . , r, ml[i] = max if and only if l[i] = ι.Let ρ be an r-ary relation and l ∈ Gr . We define the application of ml to t1, t2 ∈ ρ, denoted ml(t1, t2), to be the tuple(cid:4)ml[1](t1[1], t2[1]), . . . , ml[r](t1[r], t2[r])(cid:5). We say that ml fixes ρ if for every t1, t2 ∈ ρ we have that ml(t1, t2) ∈ ρ.We now require the following technical lemma.Lemma 34. Let ρ be a Boolean relation of arity r. For any l ∈ Gr , ml fixes ρ if and only if l(ρ) is max-closed (thatis, l ∈ ρGΓ ).Proof. Let l ∈ Gr and consider any t1, t2 ∈ ρ. We now consider the application of l and ml to the pair of tuples t1and t2.We first show that, for every t1, t2 ∈ ρ, max(l(t1), l(t2)) = l(ml(t1, t2)).Let i ∈ {1, . . . , r}.If t1[i] = t2[i] then max(l[i](t1[i]), l[i](t2[i])) = l[i](t1[i]) = l[i](ml[i](t1[i], t2[i])).Alternatively, max(l[i](t1[i]), l[i](t2[i])) = T = l[i](ml[i](t1[i], t2[i])) occurs when t1[i] (cid:14)= t2[i].We know that l ∈ ρGΓ if and only if ∀t1, t2 ∈ ρ, max(l(t1), l(t2)) ∈ l(ρ). By the above argument this is equivalent tosaying that ∀t1, t2 ∈ ρ, l(ml(t1, t2)) ∈ l(ρ). This is true if and only if ∀t1, t2 ∈ ρ, ml(t1, t2) ∈ ρ which exactly meansthat ml fixes ρ, and we are done. (cid:2)Example 35. Let t1 = (cid:4)F, F, T , T (cid:5), t2 = (cid:4)T , T , F, F (cid:5) and ρ = {t1, t2}.Since t1 and t2 differ in each coordinate, for any four-tuple Π of permutations of {F, T } we have thatmax(Π(t1), Π(t2)) = (cid:4)T , T , T , T (cid:5). It follows that the lifted relation for ρ into the max-closed constraint languageis {(cid:4)ι, ι, τ, τ (cid:5), (cid:4)τ, τ, ι, ι(cid:5)}.Let l1 = (cid:4)ι, ι, τ, τ (cid:5) which is in this lifted relation. By definition ml1= (cid:4)max, max, min, min(cid:5). We obtain the tupleNow let l2 = (cid:4)ι, ι, ι, τ (cid:5) which is not in the lifted relation. By definition ml2= (cid:4)max, max, max, min(cid:5). In this caseml2(t1, t2) = (cid:4)T , T , T , F (cid:5) /∈ ρ and so ml2 does not fix ρ.ml1(t1, t2) = t2.M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–11181105Using Lemma 34 we will show that the lifted problem from the set of Boolean CSP instances into the Boolean max-closed constraint language is tractably solvable. We do so by demonstrating that the lifted relations are all majority-closed, and hence form a tractable constraint language.Proposition 36. The set of all lifted relations, from the set of all Boolean relations into the Boolean max-closedconstraint language, is majority-closed.Proof. Consider a Boolean relation ρ and its lifted relation ρGprove directly that ρGΓ is majority-closed.Γ into the max-closed constraint language. We willConsider any l1, l2, l3 ∈ ρGΓ . Recall from Section 3.1 that there is a unique majority operator over the Booleandomain. Let lmaj be the result of applying this majority operator to l1, l2 and l3. By definition of lmaj we can see thatmlmaj is also the result of applying the unique majority operator over {min, max} to the three tuples ml1 , ml2 and ml3 .Consider any two tuples t1, t2 ∈ ρ and let t3 = ml3(ml1 (t1, t2), ml2 (t1, t2)). By Lemma 34 ml1 , ml2 and ml3 all fix ρand so t3 ∈ ρ. We will show that t3 = mlmaj (t1, t2).If ml1[i] = ml2[i] then(cid:3)(cid:3)(cid:4)[i]t3[i] = ml3[i]t1[i], t2[i]ml1(cid:3)(cid:4)[i]t1[i], t2[i]= ml1(cid:4)(cid:3)t1[i], t2[i][i]= mlmaj[i] and then[i] (cid:14)= ml2Alternatively, ml1(cid:3)(cid:4)(cid:3)[i]t3[i] = ml3t1[i], t2[i]min(cid:3)(cid:4)t1[i], t2[i][i]= ml3(cid:4)(cid:3)t1[i], t2[i][i]= mlmaj..(cid:3)[i](cid:4)(cid:4)t1[i], t2[i], ml2(cid:3)t1[i], t2[i], max(cid:4)(cid:4)Hence for every t1, t2 ∈ ρ we have that mlmaj (t1, t2) = t3 ∈ ρ and so mlmaj fixes ρ. By Lemma 34 this implies thatlmaj ∈ ρGΓ and we are done. (cid:2)Proposition 37. The set of bounded arity Boolean CSP instances which are reducible to the max-closed constraintlanguage forms a tractable subclass.Proof. The set of Boolean relations with bounded arity is a finite constraint language and so, by Corollary 29, thereduction problem is tractable if and only if the lifted language is tractable. (cid:2)The question of whether the max-closed reduction problem for general Boolean instances is tractable is still open.In the next section we show that, for larger domains, the identification problem is intractable.5.2. Binary three valued CSP instancesIn this section we consider tractable classes of binary instances over a three valued domain. The classes we considerare those reducible to max-closed instances. The results of this section were obtained by using Polyanna [25,26] todiscover the complexity of subsets of lifted relations.Naturally the subset of 230 binary three valued relations which are max-closed is tractable. The reduction problemis trivial. There are five non-trivial permutations of the three valued domain. By symmetry, for each of these fivepermutations there are again 230 relations which are max-closed after applying this permutation to both domains.These are the six languages that are max-closed for appropriate choices of domain ordering. These languages all havetrivial reduction problems whose solution is to apply the same domain permutation to every variable. All are maximaltractable languages.There are also binary three valued languages for which the lifted language is tractable but non-trivial. The liftedinstances can be solved in polynomial time but not by simply choosing the same permutation for each variable of the1106M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118instance. Discovering an appropriate domain permutation for an instance may take quadratic time or cubic time de-pending which lifted language is being considered. The subsets of the binary three valued relations which correspondto these languages are not tractable. However those instances which have solvable lifted instances form a tractableclass of binary three valued instances.There is one anomalous binary three valued language for which the lifted language is tractable which gives us anempty set of reducible instances. That is the language consisting of the six domain permutations of the three valuednot equals relation. These are precisely the relations for which no domain permutation makes them max-closed. Assuch each lifted instance has no solution. Whilst the reduction problem is tractable, since it never has a solution, wefind no reducible instances in this class.However the set of all lifted relations is not tractable.Proposition 38. The reduction problem from the binary three valued constraint language into the binary three valuedmax-closed constraint language is intractable.Proof. Consider the two binary relations with domain {1, 2, 3}: ρ1 = {(cid:4)1, 1(cid:5), (cid:4)1, 2(cid:5), (cid:4)2, 1(cid:5)} and ρ2 = {(cid:4)1, 2(cid:5), (cid:4)2, 3(cid:5),(cid:4)3, 1(cid:5)}.The lifted language for {ρ1, ρ2} is intractable. By Corollary 29, the lifted problem and the reduction problem areboth intractable. (cid:2)Using Polyanna, we have demonstrated the tractability of some (large) subsets of the lifted relations, and haveshown that the entire set of lifted relations is not tractable.The intractability result has in fact been verified by hand (see Section 5.3.3 of Green [31]) to reduce reliance oncomputer generated results.We have largely answered the question of Jeavons and Cooper [36] concerning the complexity of identifyinginstances that become max-closed after applying an (independent) re-ordering of the domain at each variable. For thelanguage of arity at most r and domain size d, where r (cid:2) 2, this identification problem is tractable if and only if d (cid:3) 2.6. Domain permutation reductions to tractable languagesIn this section we will demonstrate that our new theory can be used to show the tractability of certain new subclassesof CSP instances that are not tractable for any relational or structural reason. We will also show that we can explain thetractability of three published disparate tractable subclasses of the general constraint satisfaction problem that havenot been amenable to other general explanations for tractability. Finally we will correct a previously published resultregarding the tractability of the connected row convex identification problem.6.1. Two permutations and a binary languageOur new theory can be used to show the tractability of certain subclasses that are not tractable for any relationalor structural reason. We will show that when the set of allowed permutations, G, has size 2, the G-reduction probleminto any Γ is tractable for the entire set of binary relations, Δ, over the finite domain D. We will use this result inExample 41 to construct a natural tractable class which extends two maximal tractable relational classes.Lemma 39. Let Γ be a constraint language over finite domain D, G be a set of two permutations of D, and Δ be theset of all binary relations over D. The G-reduction problem from Δ into Γ is tractable.Proof. It is enough to note that any G-lifted relation from Δ into Γ is binary two valued. It follows that the G-liftedproblem from Δ into Γ may be reduced to 2-SAT, which is tractable. Since D is finite we know that Δ is also finite.By Corollary 29 we deduce that the G-reduction problem from Δ into Γ is tractable. (cid:2)Corollary 40. Let Γ be a tractable constraint language over finite domain D, G be a set of two permutations of D,and Δ be the set of all binary relations over D. The set of instances of CSP(Δ) which are G-reducible to Γ istractable.M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–11181107Example 41. Let D be the ordered domain {1, . . . , k}. Let G = {ι, τ } where ι(e) = e and τ (e) = k − e + 1.By Lemma 39 we have that the G-reduction problem from the set of all binary relations over D into the binarymax-closed constraint language is tractable.The tractable set of instances defined by this reduction, according to Corollary 40, certainly includes all CSPinstances whose language is binary max-closed. In this case the domain permutation reduction applies the permutationι to each variable. This subclass also naturally includes the analogous tractable set of binary min-closed instances. Wecan reduce these to the max-closed constraint language by applying τ to each variable. In fact, there are instanceswhich are neither max-closed nor min-closed. We may obtain such instances from a binary max-closed instance byarbitrarily applying τ to some subset of the variables.Since the max-closed binary relations form a maximal tractable binary constraint language (see Theorem 6.5 ofJeavons and Cooper [36]) we can see that the tractable subclass of this example is not tractable for any relationalreason. Furthermore it includes instances with arbitrary (binary) structure so it is not a structurally tractable subclass.Many novel tractable subclasses can be described using Corollary 40.6.2. The Stable Marriage ProblemAn instance of the Stable Marriage Problem (SMP) [23] consists of n men and n women who are to be married.Each man has a preference list that ranks the women. He would prefer to marry those higher in the list than those lowerin the list. Similarly each woman has a preference list for the men. The problem is to find a stable set of marriages.A set of marriages is stable if:• Every person is in just one marriage.• There is no man, m, and woman, w, such that m prefers w to his wife, and w prefers m to her husband.It is known that the Stable Marriage Problem is polynomially solvable. In particular, arc consistency is a decisionprocedure [27] for a particular representation of this problem. Informally, each variable is a man and the domain isthe set of women. Here we are choosing a woman for each man. Arc consistency will remove some women from theset of allowed partners for each man. A solution is then for each man to marry his most preferred remaining partner.More formally, an instance of the Stable Marriage Problem is a constraint satisfaction problem instance, P =(cid:4)V , D, C(cid:5), where:• V = {1, . . . , n};• D = {1, . . . , n};• For each m ∈ V , πm is a permutation of D, and for each w ∈ D, τw is a permutation of V .C = {cs,t | s, t ∈ V , s < t}, where cs,t = (cid:4)(cid:4)s, t(cid:5), ρs,t (cid:5), and(cid:4)p, q(cid:5) ∈ ρs,t ⇔ p (cid:14)= q ∧τp(t) > τp(s) ⇒ πt (q) > πt (p) ∧τq (s) > τq (t) ⇒ πs(p) > πs(q).We interpret V as a set of men, and D as a set of women. We interpret πm(w) to be the level of preference (nis the most preferred and 1 the least preferred) that man m has for woman w. Similarly, τw(m) defines the level ofpreference given to man m by woman w.We will show that every SMP instance is reducible to a max-closed instance. What is more, the required domainpermutation orders the domain for each man according to his preferences amongst the women. This completely ex-plains the known solution algorithm. Since the preference orderings are known, we will have shown that the set ofSMP instances is an example of the relational reduction described in this paper.Definition 42. Let P be an SMP instance. Consider any pair of marriages and let p be one of the four people involved.We say p is happy with respect to this pair of marriages if they prefer their partner to the person (of the same gender)in the other marriage.1108M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118A pair of marriages is stable if there is no unmarried unhappy man and woman.Theorem 43. Let P be an SMP instance and define, for each m ∈ V , Π(m) = πm. Then Π(P ) is max-closed.Proof. Consider a pair of variables s and t. We require to show that Π(cs,t ) is max-closed. In other words we haveto show that ρ = {(cid:4)πs(p), πt (q)(cid:5) | (cid:4)p, q(cid:5) ∈ ρs,t } is max-closed.Choose some a, b, e, f ∈ D, (cid:4)a, f (cid:5), (cid:4)b, e(cid:5) ∈ ρs,t . If πs(a) < πs(b) and πt (f ) < πt (e) then we have that(cid:3)(cid:6)(cid:7)πs(a), πt (f )(cid:6)(cid:7)(cid:4),πs(b), πt (e)(cid:6)(cid:7)πs(b), πt (e)=∈ ρmaxand we are done. Similarly we are done if πs(b) < πs(a) and πt (e) < πt (f ). So, without loss of generality we mayassume thatπs(a) < πs(b)and πt (e) < πt (f ).We need to show that (cid:4)πs(b), πt (f )(cid:5) ∈ ρ. This is equivalent to proving that (cid:4)b, f (cid:5) ∈ ρs,t . To prove this we mustshow that b (cid:14)= f and that there is no unmarried unhappy man and woman in the pair of marriages (s to b and t to f ).Assume for contradiction that b = f . Then both men prefer b to their other potential partner. However, woman bmust prefer one of the men. It is clear that she cannot marry her less preferred man. This contradicts the fact that both(cid:4)a, f (cid:5) and (cid:4)b, e(cid:5) are in ρs,t . Hence, b (cid:14)= f .Now assume that s is unhappy in the pair of marriages (s to b and t to f ). Since s is unhappy he prefers f to b. Weknow that πs(a) < πs(b) and so by transitivity s prefers f to a. Since (cid:4)a, f (cid:5) ∈ ρs,t we know that the pair of marriagess to a and t to f is stable, and so if s prefers f to a then f prefers t to s. Hence f is indeed happy. So, by symmetry,the pair of marriages s to b and t to f is stable. (cid:2)This result leaves an open question. Whilst we have shown a reduction from SMP to the max-closed class existswe have not shown that it is polynomial to determine. The reduction does serve to explain why arc consistency, andchoosing the most preferred remaining woman for each man, is a polynomial solution algorithm. However, in order toshow that SMP is a tractable class we also have to identify the SMP instances. That is, given a binary CSP instance,we have to determine whether there is a domain permutation which makes it an SMP instance. We conjecture that thisidentification problem is tractable.Conjecture 44. The Stable Marriage Problem is a tractable subclass of the general constraint satisfaction problem.6.3. Triangulated CSP instancesCohen [12] defined the triangulated CSP instances, for which arc consistency is a decision procedure. It has beenshown that the set of triangulated CSP instances is incomparable with any other known subclass for which arc con-sistency is a decision procedure. It was left as an open question as to whether the triangulated CSP instances canbe reduced to a tractable relational subclass. In this section we will show that triangulated CSP instances are simplyanother subclass of the general constraint satisfaction problem that can be polynomially reduced to the max-closedconstraint language.In order to define the triangulated subclass we need the notion of the complement of the microstructure of a CSPinstance [39]. In general this is a hypergraph and is defined in [12,39]. For our purposes it is enough to define thegraph which is the complement of the microstructure for binary CSP instances.Definition 45. The complement of the microstructure of the binary CSP instance, P = (cid:4)V , D, C(cid:5), denoted M(P ), isa graph (cid:4)W, F (cid:5), defined as follows:W = V × D;(cid:9)(cid:9)F =(cid:9)(cid:9)(cid:4)v, d(cid:5), (cid:4)v, e(cid:5)(cid:4)v1, d1(cid:5), (cid:4)v2, d2(cid:5)(cid:11) (cid:10)(cid:10) d (cid:14)= e(cid:11) (cid:10)(cid:6)(cid:10) ∃(cid:11)∪(cid:4)v1, v2(cid:5), ρ(cid:7)∈ C, (cid:4)d1, d2(cid:5) /∈ ρ(cid:11).M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–11181109Fig. 1. There are two possible configurations of a binary relation that are an impossible cross. These prevent the relation from being max-closed.Fig. 2. There are two possible configurations of a binary relation that are an impossible cross. This figure shows what they look like in thecomplement of the microstructure graph (assuming this relation has been used in a constraint with scope (cid:4)v, w(cid:5)).An independent set in a graph is a set of vertices, no two of which are connected by an edge. We can see from thedefinition that solutions to P correspond exactly to independent sets in M(P ) containing |V | vertices.Definition 46. Let G = (cid:4)V , E(cid:5) be a graph.A sequence S of vertices of G is a path if consecutive vertices in S are adjacent in G. The path S is a cycle if thereis an edge between the first vertex and the last vertex of the sequence. The cycle is chordal if there is an edge betweenany pair of non-adjacent vertices in S. The graph G is triangulated if every cycle is chordal.A set M of vertices of G is a clique if every pair of vertices of M is an edge of G.A binary CSP instance P is triangulated [12] if M(P ) is triangulated.6.3.1. Reduction to the max-closed subclassDefinition 47. Let < be an ordering of the vertices of a graph G. We say that < is an elimination ordering if, for anyvertex v of G, the set of vertices that are smaller than, and connected to, v form a clique.It is well-known [45] that every triangulated graph admits an elimination ordering. In the remainder of this sectionwe will show that triangulated CSP instances are in fact reducible to the max-closed constraint language. What is more,for any triangulated CSP instance, P , we will show that the necessary domain permutation can be found directly froman elimination ordering of the vertices of M(P ).Definition 48. A configuration is a binary relation on the ordered Boolean domain {0, 1}. Let ρ be a binary relationon the ordered domain D and let a0, a1, b0, b1 ∈ D with a0 < a1, b0 < b1.The configuration of ρ at (cid:4){a0, a1}, {b0, b1}(cid:5) is the binary relation over the Boolean domain {0, 1} which allows thetuple (cid:4)x, y(cid:5) exactly when (cid:4)ax, by(cid:5) ∈ ρ.An impossible cross for ρ is a configuration, η, of ρ where:• (cid:4)0, 1(cid:5), (cid:4)1, 0(cid:5) ∈ η;• (cid:4)1, 1(cid:5) /∈ η.We need the following property of max-closed relations (proved as Lemma 6.2 of Jeavons and Cooper [36]).Proposition 49. A binary relation ρ is max-closed if and only if none of its configurations is an impossible cross.We want to show that triangulated CSP instances are reducible to max-closed CSP instances, so that under somedomain permutation there exists no impossible cross. There are exactly two impossible cross configurations, shown1in Fig. 1, whilst Fig. 2 shows what these same configurations look like in the complement of the microstructure graph.The left hand configuration cannot occur in the constraint relation of any constraint in any triangulated CSP instancesince it leads to a non-chordal cycle of four vertices in the complement of the microstructure graph.1 We represent binary relations diagrammatically by connecting pairs of domain values when the corresponding tuple is in the relation.1110M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118Theorem 50. Let P = (cid:4)V , D, C(cid:5) be a triangulated CSP instance. Then P is reducible to a max-closed CSP instanceby domain permutation.Proof. Let < be an elimination ordering of the vertices of M(P ).For any variable v ∈ V , this elimination ordering induces an ordering, <v, of the domain D at v. This ordering issuch that for two domain values a, b ∈ D, a <v b if and only if (cid:4)v, a(cid:5) < (cid:4)v, b(cid:5) in the elimination ordering of M(P ).We will show that for any constraint (cid:4)σ, ρ(cid:5) ∈ C, where σ = (cid:4)v, w(cid:5), ρ is max-closed under the domain orderings<v at variable v and <w at variable w. We are required to prove that under these orderings ρ contains no impossiblecross.Consider the configuration κ of ρ at (cid:4){a, b}, {e, f }(cid:5) where a <v b and e <w f . Assume for contradiction that κ isan impossible cross (and hence for a triangulated CSP instance looks like the right hand configuration given in Fig. 2).Since κ is symmetrical we may assume, without loss of generality, that (cid:4)v, b(cid:5) < (cid:4)w, f (cid:5) in the elimination ordering.Now, we know that < is an elimination ordering of the vertices of M(P ). As such, we know that if (cid:4)w, f (cid:5) isconnected to (cid:4)v, b(cid:5) (as in both of the impossible cross cases) then (cid:4)v, b(cid:5), (cid:4)w, e(cid:5) and (cid:4)w, f (cid:5) must form part of a cliqueand hence the edge {(cid:4)v, b(cid:5), (cid:4)w, e(cid:5)} must exist in M(P ). This means that (cid:4)b, e(cid:5) /∈ ρ. However, this contradicts theassumption that κ is an impossible cross.As such, no configuration of ρ is an impossible cross under the domain orders (<v and <w) imposed by theelimination ordering < and hence ρ is max-closed under these domain orderings. (cid:2)6.3.2. Tractability of the reductionDefinition 51. A maximal cardinality ordering of the vertices of the graph G is constructed in |V | steps as follows.At step 1, choose any vertex v1. At step i, for i < |V | we have chosen v1, . . . , vi−1. Now choose for vi any vertex thatis connected to the largest set of previously numbered vertices. We order vi < vj if i < j .The following is a well-known result [45].Lemma 52. A maximal cardinality ordering of the vertices of the graph G is an elimination ordering if and only if Gis triangulated.It follows directly that the triangulated CSP instances are a tractable subclass of the general constraint satisfactionproblem. What is more, the following theorem (Theorem 3 of 12) is a direct consequence of the reduction demon-strated in this paper.Theorem 53. Arc consistency is a decision procedure for the triangulated CSP instances.The open conjecture has been proven. Arc consistency is a decision procedure for triangulated CSP instances forexactly the same reason as it is a decision procedure for max-closed CSP instances.6.4. Identifying connected row convex instancesRecall the row convex (binary) relations of Definition 22. In this section we consider a subset of these relations:the so-called connected row convex constraints [20]. It is known that path consistency implies global consistency [20,49], and so we can tractably solve path consistent CSP instances if we know that, under any (independent) domainre-ordering for each variable, each constraint relation is connected row convex.Definition 54. The connected row convex identification problem for binary CSP instances is to find a domain permu-tation which results in a connected row convex instance.The tractability of the connected row convex identification problem was left as an open problem [20]. An incorrectanswer to this question has unfortunately appeared in the literature [10].We will determine the complexity of the connected row convex identification problem by establishing the com-plexity of the associated lifted language.M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–11181111Definition 55. The inverse of a binary relation ρ is the relation(cid:11).(cid:4)i, j (cid:5) | (cid:4)j, i(cid:5) ∈ ρ−1 =ρ(cid:9)The reduced form of a relation ρ, denoted ρ∗, is the (0, 1)-matrix obtained by removing from the matrix represen-tation of ρ all rows and columns that contain only 0’s.Let M be any (0, 1)-matrix. For any i ∈ D such that there exists j ∈ D with M(cid:4)i, j (cid:5) = 1 define the image of i inM to be the interval(cid:9)(cid:16)minj | M(cid:4)i, j (cid:5) = 1(cid:11), max(cid:9)j | M(cid:4)i, j (cid:5) = 1(cid:11)(cid:17).A binary relation ρ is connected if the images [a, b] and [a(cid:11), b(cid:11)] of two consecutive rows in ρ∗ are such thata (cid:3) b(cid:11) − 1 and a(cid:11) (cid:3) b + 1.A relation ρ is connected row convex (CRC) if ρ∗ and (ρ−1)∗ are both row convex and connected.Deville et al. [20] show that CRC relations are closed under the three necessary operations needed for path consis-tency algorithms and that path consistency implies global consistency for problem instances whose constraint relationsare all CRC. This means that CRC relations form a tractable constraint language.Definition 56. The median operator over the ordered domain {1, . . . , k} is a ternary operator that returns the median,or middle, value of its arguments. The median operator is a majority operator (recall Section 3.1) and so defines atractable constraint language.It has been shown [38] that the connected row convex relations are precisely the binary relations closed under themedian operator. Cohen et al. [14] present another way of viewing connected row convex constraints (as disjunctionsof simpler constraints). However, for our purposes it is sufficient to consider the median-closed relations.By Corollary 29, the connected row convex identification problem (for any finite domain) is equivalent to solvingthe lifted problem into the language of median-closed relations.In this section we will determine the complexity of these lifted languages.We used Polyanna initially to determine the complexity of the lifted languages but we also verified the results byhand. This means that no proofs in this section rely solely on computer generated results.6.4.1. Reducing the lifted languagesThere are very many possible polymorphisms that Polyanna has to consider. For this reason it is vital first to reducethe size of relations before Polyanna begins. The lifted relations in this case have a natural simplification.Let Mρ be the matrix representation of a CRC relation ρ. Reversing the order of either the rows or the columns ofMρ cannot affect the CRC property because it does not affect which rows/columns are consecutive. It follows that ifwe are looking for pairs of permutations that make a binary relation ρ CRC, then we can factor out half of the possiblepermutations by, for instance, assuming that the image of 1 is always less than the image of k.6.4.2. The three valued domainWe label the six permutations of {1, 2, 3} as in Fig. 3. By the argument of Section 6.4.1 we only need to considerthe permutations G = {π0, π1, π2}, which dramatically reduces the cost of searching for polymorphisms of the liftedrelations.We used a program to generate the lifted language for the 512 binary relations over the domain {1, 2, 3}.There are 92 relations in this language and Polyanna determined that it is closed under the majority operator whichreturns the first of three distinct values. It follows [38] that the language is tractable and so the connected row convexidentification problem is tractable. So we obtain the following results.Fig. 3. The six possible domain orders (permutations) of a domain of size three.1112M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118Fig. 4. The twelve possible domain orders (permutations) of the domain {1, 2, 3, 4}.Theorem 57. The connected row convex identification problem for the three valued domain is tractable.Proof. The lifted language is closed under a majority operator and is therefore tractable. Since the lifted language isfinite we can use Corollary 29 to show that the reduction problem is also tractable. (cid:2)Corollary 58. The set of binary three valued CSP instances which can be made into CRC instances by permutation ofthe domain independently at each variable is tractable.6.4.3. The four valued domainThere are 242 = 65536 binary relations over the domain {1, 2, 3, 4}. The number of permutations of this domain is24. After factoring out reflections as in Section 6.4.1 we still have 12 permutations (given in Fig. 4) for the domain ofthe lifted relations. Using a dedicated program we discovered 14501 lifted relations.We will show the intractability of the reduction problem by showing the intractability of a finite subset of thislifted language and appealing to Proposition 28.Consider the two binary four valued relations, ρ1 and ρ2, shown at the top of Fig. 5. The lifted relations for thesetwo relations, λ1 and λ2 respectively, are also given in Fig. 5.A further simplification that we apply is to note that any unary polymorphism of a constraint language can beapplied to all of the relations in the language without changing the complexity.Proposition 59. (See [13,34,37].) Let Γ be a constraint language over a set D, and let f be a unary polymorphism ofΓ . CSP(Γ ) is polynomial-time equivalent to CSP(f (Γ )), where f (Γ ) = {f (ρ) | ρ ∈ Γ } and f (ρ) = {f (t) | t ∈ ρ}.Polyanna discovered a unary polymorphism of the lifted relations for λ1 and λ2.Application of Proposition 59 means that the tractability of this pair of (full domain) lifted relations is equivalentto the tractability of the pair of three valued relations, υ(λ1) and υ(λ2), also shown in Fig. 5.Polyanna was able to prove this language intractable. A relation over the domain {1, 2, 3, 4} can be seen as arelation over the domain {1, . . . , k}, k > 4 that never allows any tuples with domain values larger than 4. It followsthat the connected row convex identification problem for domain size four can be reduced to the connected row convexidentification problem for any larger domain, and so these are also intractable problems.Theorem 60. The connected row convex identification problem is intractable for domains of size four or more.6.4.4. Verifying the complexity resultsSince Theorem 60 contradicts a result published in a refereed conference we need to avoid any reliance on computergenerated results.We generated the lifted relations for λ1 and λ2 by hand. We also checked the unary polymorphism υ.Lastly, we needed to verify that {υ(λ1), υ(λ2)} is indeed an intractable constraint language. One way of doing so isto use combinations of υ(λ1) and υ(λ2) to generate a known intractable relation, such as the inequality relation over athree valued domain. This would make graph 3-colouring reduce to the connected row convex identification problemfor domain size four.Consider the instance of Fig. 6. It is tedious but straightforward to check that the implied constraint between v1and v2 is indeed the three valued inequality relation and hence the three valued inequality relation can be expressedby υ(λ1) and υ(λ2).M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–11181113Fig. 5. Relations ρ1 and ρ2 with their lifted relations, λ1 and λ2 (after factoring out reflections). Also the equivalent intractable language υ(λ1)and υ(λ2), formed by applying the unary polymorphism υ.Fig. 6. We use the pair of relations, υ(λ1) and υ(λ2), to generate a known intractable relation, the inequality relation over a three valued domain.6.4.5. A weakness in the standardised form of CRC relationsWe have not shown that P = NP! Instead we have exposed a flaw in the previously published result [10]. Here wemake explicit this flaw.Chen et al. [10] propose a polynomial time algorithm for identifying connected row convex constraint satisfactionproblem instances under an independent domain ordering at each variable. Their method relies on a standardised formof CRC relations that they claim can be recognised in polynomial time. Our results are straightforward and handverified.Definition 61. (See Definition 9 of Chen et al. [10].) Given some connected row convex relation ρ over domain sizek let Mρ be its (0, 1)-matrix representation with k rows and columns. Let minρ(i) denote the position of the leftmost1114M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118Fig. 7. This table shows the only combinations of permutations that keep the relation in the upper left CRC. It is straightforward to check that noneof these are in standardised form.one in row i of Mρ and maxρ(i) the position of the rightmost one in row i of Mρ . ρ is called a standard CRC relationif:• minρ(1) (cid:3) minρ(2) (cid:3) · · · (cid:3) minρ(k);• minρ(i) = minρ(i + 1) = · · · = minρ(i + j ) ⇒ maxρ(i) (cid:3) maxρ(i + 1) (cid:3) · · · (cid:3) maxρ(i + j );where 1 (cid:3) i, i + j (cid:3) k.We will now show that there exist relations that are CRC but which cannot be standardised. Consider the relationof Fig. 7. This binary relation is connected row convex and it can only remain as such under domain reflections.It can be seen from Fig. 7 that none of the four combinations of domain reflections standardise this CRC relation.It follows that the algorithm of Chen et al. [10] does not in fact solve the more general reduction problem from the setof all binary relations into the CRC constraint language. Instead, it solves a subset of this problem for those instancesthat can be made standardised CRC. Any solution found by this algorithm is a solution to the lifted problem instance.However, many solutions to the lifted problem instance cannot be found by this algorithm.6.5. The renamable Horn subclassRecall the definition of clauses and literals from Example 7. Propositional satisfiability (SAT) is the problem ofdetermining, for a given set of clauses, whether there is a truth assignment to all of the propositional variables thatsatisfies all of the clauses. There have been many papers published describing the so-called renamable Horn class ofSAT instances [2,3,6,8,9,42].It has been shown that the renamable Horn subclass is tractable, in that recognising, and hence solving, SATinstances that are renamable Horn can be performed in polynomial time. Indeed del Val [19] gives an algorithm whichsolves both 2-SAT and renamable Horn instances which he calls “the paradigmic examples of tractable problems inpropositional satisfiability”.In this section we define the class of renamable Horn SAT instances and the analogous class of renamable HornCSP instances. We show that the tractability of both classes is due to a tractable reduction problem into the tractablelanguage of propositional Horn clauses [47].It has also been shown [6] that the problem of identifying a maximal subset of the clauses of an instance that arerenamable Horn is NP-hard. A well-known properties of the lifted language for the language of Horn clauses showsdirectly that this is an NP-hard problem.M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–11181115Definition 62. A Horn clause is a clause with at most one positive literal. A set of clauses is renamable Horn if thereis a replacement of some literals uniformly in all clauses with their negated versions which transforms all clauses intoHorn clauses.A Boolean CSP instance is renamable Horn when its constraint relations all represent clauses and there exists adomain permutation which transforms all the constraint relations into Horn clauses.6.5.1. The tractability of renamable Horn explainedSolving a renamable Horn instance, given an appropriate domain permutation, is easy. We apply the domain permu-tation and then solve the resulting instance using unit resolution, the solution algorithm for Horn [47]. It is thereforethe discovery of an appropriate domain permutation that we have to show to be tractable.Proposition 63. Let c be a clause. Let Sc be the set of variables which must be set to F (all others being set to T )which makes the clause evaluate to F . Then the lifted relation for c into the Horn constraint language consists of allthose tuples which invert the domain of a set of variables ψ where the symmetric difference between ψ and Sc hassize at most one.Proof. Follows directly from the definition of a Horn clause. (cid:2)Example 64. Consider the clause c = p ∨ q ∨ r ∨ s. The only assignment that does not satisfy c is p (cid:13)→ F , q (cid:13)→ F ,r (cid:13)→ T , s (cid:13)→ T . That is, Sc = {p, q}.There is exactly one non-trivial permutation τ of the domain {F, T }: it interchanges T and F . The trivial permuta-tion ι fixes both T and F .With respect to the order (cid:4)p, q, r, s(cid:5) the tuple of permutations which negate precisely those in Sc is Π0 = (cid:4)τ, τ, ι, ι(cid:5).The clause Π0(c) is p ∨ q ∨ r ∨ s which is a Horn clause.Alternatively, negate p, q and r with the tuple of permutations Π1 = (cid:4)τ, τ, τ, ι(cid:5). In this case Π1(c) is p ∨ q ∨ r ∨ s,again Horn. The symmetric difference between Sc and {p, q, r} has size one.Conversely, the symmetric difference between Sc and the set {p, r} has size two. Let Π2 = (cid:4)τ, ι, τ, ι(cid:5) and Π2(c) isp ∨ q ∨ r ∨ s which is not Horn.Recall from Section 3.1 that a set of relations closed under majority is tractable.For the Boolean domain there is precisely one majority operator which we will denote by δ.Proposition 65. The lifted language from the set of all clauses into the Horn constraint language is majority-closed.Proof. Consider a clause c. Let λc be its lifted relation into the Horn constraint language and let l1, l2, l3 be threetuples from λc. We have to prove that δ(l1, l2, l3) ∈ λc. The result is trivial if two of the tuples are identical so we mayassume that they are distinct.By Proposition 63 we see that any variable of Sc must correspond to the permutation τ in at least two of thesetuples. Hence δ(l1, l2, l3) is equal to τ precisely for those variables in Sc and we are done. (cid:2)Clauses in SAT instances are represented implicitly as a disjunct of literals. By Proposition 63 it is clear that anylifted r-ary relation has at most r + 1 tuples. So there is a polynomial algorithm for generating lifted instances for thegeneral reduction problem from SAT into Horn-SAT.Hence Propositions 65 and 27 provide a simple explanation of the tractability of the renamable Horn class of SATinstances.6.5.2. A new tractable classHaving explained the tractability of the (implicitly expressed) renamable Horn class of SAT instances we can gofurther and show that they are tractable as a class of Boolean CSP instances. We have only to show that it is tractableto determine if each relation in an instance represents a clause. Since there is precisely one assignment that does notsatisfy a clause, counting the allowed assignments is sufficient to determine whether a constraint represents a clause.1116M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118Proposition 66. The renamable Horn class of CSP instances is tractably identifiable.Example 67. Recall the split-Horn subclass defined in Example 7. We can now easily show the tractability of thisclass. The instances are all renamable Horn.6.5.3. Max-renamable HornConsider the problem of identifying, for any SAT instance, a maximum number of those clauses that are renamableHorn. This is the max-renamable Horn problem.The MAX-CSP problem is to determine, for a given CSP instance, the maximum number of its constraints that canbe simultaneously satisfied.Identifying maximum subsets of the clauses which are renamable Horn corresponds precisely to solving instancesof the MAX-CSP problem for the lifted language. Creignou [16] characterised the tractability of all Boolean constraintlanguages for the MAX-CSP problem. There are three tractable cases.We can readily determine that the lifted language is not contained in any of the three tractable languages. Explicitly,the lifted relation for the clause c defined in Example 64 is in none of these languages. The intractability of the max-renamable Horn problem then follows immediately by Proposition 28.7. ConclusionIn this paper we have identified genuinely novel tractable classes of CSP instances that are neither relational norstructural classes. We have even constructed a tractable class which properly extends two maximal tractable relationalclasses.We have considered whether it is feasible to identify constraint satisfaction problem instances that become max-closed after an independent domain re-ordering at each variable. We have shown that in the Boolean case it is tractableto identify such instances when the arity of the instances is bounded. We have also shown that for larger domain sizesit is (in general) intractable to identify such instances.Furthermore we have demonstrated that this theory serves to explain why the constraint approach to the StableMarriage Problem is tractably solvable, since all instances reduce to max-closed instances. We have also shownthat the triangulated instances are reducible to the max-closed constraint language. In this sense we have unifiedthree tractable classes of CSP instances (max-closed, SMP and triangulated) for which arc consistency is a decisionprocedure.It might be hoped that this theory would also explain why arc consistency is a decision procedure for tree structuredCSP instances. Perhaps all such instances are actually reducible to max-closed instances. Unfortunately, this is notthe case since, for instance, there are six binary three valued relations with empty lifted relations for the max-closedconstraint language (see Section 5.2). So, we still need to find a unifying theory for all CSP instances for which arcconsistency is a decision procedure.For the class of CSP instances with a given domain we considered the complexity of finding domain permutationsthat transform a given instance into a connected row convex instance. An incorrect answer, that this is tractable forevery domain, has been published at a refereed conference. In this paper we have shown, using easily verifiable results,that this problem is tractable precisely when the domain has at most three elements.Lastly, this theory has provided a simple explanation of the tractability of recognising instances that are renamableHorn. It even serves to explain why finding maximum subsets of clauses which are renamable Horn is NP-hard.This new method of reduction to relational tractability has already had surprising and extensive applications insimplifying our theoretical understanding. It may well also be a practical reduction procedure for some real instances.AcknowledgementsThe authors are very grateful to Marc van Dongen [50] who originally derived the SMP example of a reductionto the max-closed tractable subclass, though in a different context. His example as an application of reductions totractable language theory greatly strengthens our work. We are also grateful to Peter Jeavons who alerted us to theconnections between this work and renamable Horn theory. Finally, we would like to thank an anonymous reviewerM.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–11181117of an earlier draft of part of this work for alerting us to the need for polynomial conversion between the reductionproblem and the lifted problem, resulting in Propositions 27, 28 and Corollary 29.References[1] J. Allen, Natural Language Understanding, second ed., The Benjamin/Cummings Publishing Company, 1995.[2] B. Aspvall, M.F. Plass, R.E. Tarjan, A linear time algorithm for testing the truth of certain quantified Boolean formulas, Information ProcessingLetters 8 (1979) 121–123.[3] B. Aspvall, Recognizing disguised NR(1) instances of the satisfiability problem, Journal of Algorithms 1 (1) (1980) 97–103.[4] C. Beeri, R. Fagin, D. Maier, M. Yannakakis, On the desirability of acyclic database schemes, Journal of the ACM 30 (1983) 479–513.[5] C. Bessière, J.-C. Régin, Arc consistency for general constraint networks: preliminary results, in: Proceedings of IJCAI’97, Nagoya, Japan,1997, pp. 398–404.[6] E. Boros, Maximum renamable Horn sub-CNFs, Discrete Applied Mathematics 96–97 (1999) 29–40.[7] A. Bulatov, P. Jeavons, A. Krokhin, Classifying the complexity of constraints using finite algebras, SIAM Journal on Computing 34 (3) (2005)720–742.[8] V. Chandru, J.N. Hooker, Extended Horn sets in propositional logic, Journal of the ACM 38 (1991) 205–221.[9] V. Chandru, C. Coullard, P. Hammer, M. Montanez, X. Sun, On Renamable Horn and Generalized Horn functions, Annals of Mathematicsand Artificial Intelligence 1 (1990) 33–48.[10] E. Chen, Z. Zhang, X. Wang, K. Aihara, An algorithm for fast recognition of connected row-convex constraint networks, in: JFPLC 2001, TheTenth International French Speaking Conference on Logic and Constraint Programming, April 2001, pp. 43–58.[11] D. Cohen, Tractable decision for a constraint language implies tractable search, Constraints 9 (3) (2004) 219–229.[12] D.A. Cohen, A new class of binary CSPs for which arc-consistency is a decision procedure, in: Principles and Practice of ConstraintProgramming—CP 2003, in: Lecture Notes in Computer Science, Springer-Verlag, 2003, pp. 807–811.[13] D. Cohen, P. Jeavons, The complexity of constraint languages, in: F. Rossi, P. van Beek, T. Walsh (Eds.), Handbook of Constraint Program-ming, Elsevier, 2006 (Chapter 8).[14] D. Cohen, P. Jeavons, P. Jonsson, M. Koubarakis, Building tractable disjunctive constraints, Journal of the ACM 47 (5) (2000) 826–853.[15] D.A. Cohen, P. Jeavons, M. Gyssens, A unified theory of structural tractability for constraint satisfaction and spread cut decomposition, in:IJCAI, 2005, pp. 72–77.[16] N. Creignou, A dichotomy theorem for maximum generalized satisfiability problems, Journal of Computer and System Sciences 51 (1995)511–522.[17] R. Dechter, J. Pearl, Network-based heuristics for constraint satisfaction problems, Artificial Intelligence 34 (1) (1988) 1–38.[18] R. Dechter, J. Pearl, Tree clustering for constraint networks, Artificial Intelligence 38 (1989) 353–366.[19] A. del Val, On 2-SAT and renamable Horn, in: AAAI: 17th National Conference on Artificial Intelligence, AAAI/MIT Press, 2000, pp. 279–284.[20] Y. Deville, O. Barette, P. van Hentenryck, Constraint satisfaction over connected row convex constraints, Artificial Intelligence 109 (1999)243–271.[21] N.W. Dunkin, J.E. Bater, P.G. Jeavons, D.A. Cohen, Toward high order constraint representations for the frequency assignment problem,Technical Report CSD-TR-98-05, Department of Computer Science, Royal Holloway, University of London, Egham, Surrey, UK, 1998.[22] R. Fagin, Degrees of acyclicity for hypergraphs and relational database schemes, Journal of the ACM 30 (1983) 514–550.[23] D. Gale, L.S. Shapley, College admissions and stability of marriage, The American Mathematical Monthly 69 (1) (1962) 9–15.[24] M. Garey, D.S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, Freeman, San Francisco, CA, 1979.[25] R.L. Gault, Polyanna technical manual (version 1.00), Technical Report RR-01-20, Computing Laboratory, Oxford University, 2001.[26] R.L. Gault, P.G. Jeavons, Implementing a test for tractability, Constraints 9 (2) (2004) 139–160.[27] I.P. Gent, R. W Irving, M. F Manlove, P. Prosser, B.M. Smith, A constraint programming approach to the stable marriage problem, in: Pro-ceedings of CP 2001: the 7th International Conference on Principles and Practice of Constraint Programming, in: Lecture Notes in ComputerScience, vol. 2239, Springer-Verlag, 2001, pp. 225–239.[28] G. Gottlob, L. Leone, F. Scarcello, A comparison of structural CSP decomposition methods, Artificial Intelligence 124 (2000) 243–282.[29] G. Gottlob, L. Leone, F. Scarcello, Hypertree decompositions: A survey, in: Proceedings 26th International Symposium on MathematicalFoundations of Computer Science, MFCS’01, in: Lecture Notes in Computer Science, vol. 2136, Springer-Verlag, 2001, pp. 37–57.[30] G. Gottlob, L. Leone, F. Scarcello, Hypertree decomposition and tractable queries, Journal of Computer and System Sciences 64 (3) (2002)579–627.[31] M.J. Green, New methods for the tractability of constraint satisfaction problems, PhD thesis, University of London, Department of ComputerScience, Royal Holloway, Egham, Surrey, UK, June 2005.[32] M.J. Green, D.A. Cohen, Tractability by approximating constraint languages, in: Principles and Practice of Constraint Programming—CP2003, in: Lecture Notes in Computer Science, Springer-Verlag, 2003, pp. 392–406.[33] M. Gyssens, P.G. Jeavons, D.A. Cohen, Decomposing constraint satisfaction problems using database techniques, Artificial Intelligence 66 (1)(1994) 57–89.[34] P.G. Jeavons, On the algebraic structure of combinatorial problems, Theoretical Computer Science 200 (1998) 185–204.[35] P.G. Jeavons, D.A. Cohen, An algebraic characterization of tractable constraints, in: Computing and Combinatorics. First International Con-ference COCOON’95, Xi’an, China, August 1995, in: Lecture Notes in Computer Science, vol. 959, Springer-Verlag, 1995, pp. 633–642.[36] P.G. Jeavons, M.C. Cooper, Tractable constraints on ordered domains, Artificial Intelligence 79 (2) (1995) 327–339.1118M.J. Green, D.A. Cohen / Artificial Intelligence 172 (2008) 1094–1118[37] P.G. Jeavons, D.A. Cohen, M. Gyssens, Closure properties of constraints, Journal of the ACM 44 (1997) 527–548.[38] P.G. Jeavons, D.A. Cohen, M.C. Cooper, Constraints, consistency and closure, Artificial Intelligence 101 (1–2) (1998) 251–265.[39] P. Jégou, Decomposition of domains based on the micro-structure of finite constraint-satisfaction problems, in: AAAI, 1993, pp. 731–736.[40] H.A. Kautz, B. Selman, Planning as satisfiability, in: Proceedings of the Tenth European Conference on Artificial Intelligence (ECAI’92),1992, pp. 359–363.[41] J. Larrosa, E. Morancho, D. Niso, On the practical use of variable elimination in constraint optimization problems: ?still-life? as a case study,Journal of Artificial Intelligence Research 23 (2005) 421–440.[42] H.R. Lewis, Renaming a set of clauses as a Horn set, JACM 25 (1) (1978) 134–135.[43] A.K. Mackworth, Consistency in networks of relations, Artificial Intelligence 8 (1977) 99–118.[44] U. Montanari, Networks of constraints: Fundamental properties and applications to picture processing, Information Sciences 7 (1974) 95–132.[45] D.J. Rose, Triangulated graphs and the elimination process, Journal of Mathematical Analysis and Applications 32 (1970) 597–609.[46] F. Rossi, P. van Beek, T. Walsh (Eds.), The Handbook of Constraint Programming, Elsevier, 2006 (Chapter 8. Foundations of ArtificialIntelligence).[47] T.J. Schaefer, The complexity of satisfiability problems, in: Proceedings 10th ACM Symposium on Theory of Computing, STOC’78, 1978,pp. 216–226.[48] P. van Beek, Reasoning about qualitative temporal information, Artificial Intelligence 58 (1992) 297–326.[49] P. van Beek, R. Dechter, On the minimality and decomposability of row-convex constraint networks, Journal of the ACM 42 (1995) 543–561.[50] M.R.C. van Dongen, From local closure properties to a global closure property, Personal communication, 2002. The source of the SMPexample.