Artificial Intelligence 85 ( 1996) 3-44 Artificial Intelligence A systematic methodology for cognitive modelling R. Cooper a,*, J. Fox b, J. Farringdon”, T. ShalliceC a Department of Psychology, Birkbeck College, Malet Street. London, UK WC 1E 7HX h Advanced Computation Laboratory, Imperial Cancer Research Fund, London, UK ’ Department of Psychology, University College London, London, UK Received January 1995; revised August 1995 Abstract implementation The development is typically ad hoc: theories would be considerably justified mechanisms with pragmatic principles guide the process. Consequently and testing of computational models of cognition few computational mod- details, and aspects of theories are frequently hard to identify. We argue that attempts assisted by the availability of appropriate for specifying cognitive models. Such languages should: ( 1) be syntactically clear and (3) be executable; and (4) explicitly support the divi- (2) be operationally well defined; detail. In support of our arguments we introduce Sceptic, theory and implementation these requirements. specification generally agreed methodological els often conflate empirically essential theoretical to construct cognitive languages succinct; sion between an executable including Soar, Sceptic has been successfully in a technical appendix. The sim- and details of the Sceptic specification to be seen, and plicity of Sceptic Soar permits three aids investigation of alternative computational to the functioning of working memory within Soar. Although our focus is on Soar, the thrust of the work is more concerned with general methodological the essentials of the underlying cognitive assumptions. We demonstrate theoretical language which goes some way towards satisfying theory this by reporting issues in cognitive modelling. a number of cognitive models involving modifications of Soar are included used to implement experiments 1. Introduction The natural complexity considerable methodological of experimental design and data analysis. Notwithstanding cognitive and variability of ordinary human behaviour creates a need for students experimental research. Consequently, are routinely sophistication in cognitive in rigorous psychology trained the many ambiguities of cognitive theory, the * Corresponding author. E-mail: r.cooper@psyc.bbk.ac.uk. QOO4-3702/96/$15.00 SSDIOOO4-3702(95)00112-3 Copyright @ 1996 Elsevier Science B.V. All rights reserved. research arc judged are public and largely uncontroversial. side the situation is informal. Theories are often presented criteria by which experimental On the theoretical psychology (see, e.g., [ 3.29.421 1, or draw on natural box-arrow notation and its underlyin g assumptions it has been argued that “attractive metaphors [ 39. p. 4021. This informal approach restricts statements. is less satisfactory. Most theoretical discussion language metaphors in in terms of box and arrow diagrams (see, e.g., [ 4 I 1). but the are generally poorly specified, and than they resolve” to make clear theoretical raise more obscurities the field’s ability In response, many cognitive scientists have looked (both connectionist their theories. Frequently formulating niques Such techniques of all aspects essential might otherwise be overlooked. Computational drawn from those theories by simulation. to the theory’s and symbolic) they have turned to computational modelling for developing and presenting for more satisfactory ways of tech- their proposals. the detailed specification including many aspects which to be also allow predictions implementation, techniques lead to precise statements of theory by forcing lcad techniques programming its predictions. is to be delivered Sound methodological principles are necessary, however, to cognitive if the full potential of com- such principles the exploration foundation. Such exper- empirical data, but the a theory science. Without allows to programs which is in direct conflict with the standard scientific method of evaluating computational mechanisms with little theoretical replicate putational there are two clear dangers. Firstly, unconstrained of alternative imental programming may strategy by testing of the phenomena derive implementation asserted putational which are not theoretically motivated. Without appropriate methodological the distinction within implementation results from supposedly theory. The abstract nature of psychological details cannot be ensured. Moreover, some form of reverse engineering the program an explanation of its behaviour. Secondly, the that, for com- of a theory will include aspects principles, theoretically motivated aspects and of a theory can lead to situations where the program details obscure if such programs are to further our understanding the implementation any computational the unconstrained the independence of simulation completeness, In addition, in question. instantiation is required in order to theorising irrelevant between requires from implementation The utility of sound, systematic methodologies formal science, successfully software development methodologies for example, has developed for specifying program designs linguistics [ 121 ), uncertainty in AI as a technical discipline applied Computer duction of systematic languages ily interested furthermore, tional (e.g., [ 451 ). There is now a general consensus tematic programming methods yields deeper understanding software, grams and their underlying and engineers ical investigation. with better principles. While central techniques rather frameworks ( e.g.. leads to clearer communication, and decision making [ 5. 191 ), reasoning are not necessarily and facilitates (e.g.. (e.g., details cannot be determined. can be seen (e.g., rapidly in a number of fields. in recent years, with the intro- ) and formal (e.g., 1441 ). AI technologists (those primar- than as a natural have, science) in many areas, such as computa- representation [ 15.2 I] ), knowledge ]37,47] [ I] ) and expert systems (e.g., that increased use of formal design and sys- of assessment of pro- and greater predictability independent the methods and tools of mathematicians to the natural sciences, whose core is empir- and presenting for formulating computational R. Cooper et al./Artijicial Intelligence 85 (1996) 3-44 5 for developing and testing them, cognitive science in computational In particular, Newell has argued that “it is time to get going on producing advocated of improved modelling methodologies comes theories, and a stronger methodology would seem likely the [empirical] theories of cognition-before to advance more certainly. for the development of the goals and methods currently Further motivation from an examination psychology. unified number of [theoretical] clashes increases by the square or the cube” [ 23,3 1,401 can be seen as the culmination theorists must aim for cumulative fashions represents programme details but advances a hard core. In the case of Soar computer programs, its predecessors. development [31] argues in the tradition of Imre Lakatos this progression to provide a more adequate [ 301. In this vein Newell a research programme incarnation in understanding of his long-argued position of a theory may prove each aiming is embodied any one database doubles again and the [ 3 1, p. 251 and Soar that psychological transitory and avoid paradigm-related, that the work of the Soar community [25]. In such a to be incorrect in peripheral upon in a series of related than account theoretical are made possible by building progressively implementing and documenting are, like most psychological available methodolo- theories match up to At this point, however, we have to question whether currently computational gies for designing, Newell’s challenge. Take Soar itself. From the point of view of theoretical methodology than much current cognitive psychological modelling. Soar seems more sophisticated infor- Statements of Soar as a theory of cognition mal; a set of claims and assumptions in ordinary about cognitive processing [ 3 1,401). As we argue below, however, there is a substantial gap between English (e.g., realisation of the theory as a LISP or these informal statements into C program. This gap has important cognitive question theory, and the degree realisa- [ lo] ). This is not a criticism of Soar or the Soar community, tions of that theory but a general methodological weakness which undermines need to be able to express our theories less ambiguously generally in ways that are more open to detailed scrutiny; against to which Soar can truly be said to be a well-articulated technologies; more easily evaluated for evaluating Soar. It brings can be said to be accurate and the computational the implementations research. We computational consequences in particular the degree expressed enmeshed to which theories, (see This paper describes an attempt accepted criteria of adequacy; and hence more easily compared. these problems by applying specification is an executable to address science. Our goal theoretical proposals which avoids, as far as possible, some lessons a language: the diffi- and of putative it should provide a way of executing or animating should explic- the properties and interdependencies should provide a notation for succinctly the language regarding In addition to determine how it will truly behave. Finally, earlier. Such a language proposals formulating from AI and computer language for expressing culties mentioned clearly cognitive mechanisms. the theory itly support details. the distinction between theoretically motivated aspects and implementation We begin with what is essentially of theory articulation, arguing theory/implementation highlighting for the utility of executable a requirements analysis. We survey existing forms the failings of a variety of current methods, before and the necessity of the specification languages distinction. In Section 3 we introduce Sceptic, an executable theories, including language which we have used specification chological issues detailed tive modelling reconstruction of a number of less extensive tational experimentation reconstruction). We conclude with a discussion such as Sceptic annotated details of the Sceptic specification the work reported here is developed methodological in a wider methodology theories), to implement Soar, and discuss a number of current psy- the to which in Section 2. Section 4 relates our experience with Sceptic as a cogni- language. Specifically, we consider in the large-scale (as evidenced by the implementation of Soar, the generality of Sceptic the use of Sceptic it addresses the extent and the utility of Sceptic in facilitating (as evidenced by three experimental modifications compu- to the Soar language For completeness, of the role of a modelling for cognitive modelling. of Soar are given in an appendix. While in the context of symbolic modelling, many of the points apply equally well to connectionist modelling. 2. Issues in theory specification Central to any systematic methodology for cognitive modelling must be techniques are currently used, including natural for the description or specitication of theories. Within cognitive psychology, a number of such techniques processing diagrams, computer programs, and (more rarely) of these approaches has its advantages, but each also has serious problems. we examine be addressed. formal specifications. Each In this section and consider how their failings might the above forms of theory articulation language descriptions, information 2.1. Current forms of theory cwticulutiott: CL critique The relative merits of the various approaches to a concrete example. techniques to theory specification are most clearly In the following discussion we therefore Soar is as a in the description it has been described [ 23,31.40]. in natural language, of Soar for our discussion because in procedural and in the formal specification terms (LISP and C programs exist for various versions language Z [27]. However, whilst we in this section on the current forms of articulation to the methods used in the description of Soar, our comments of most other relatively well- theories (e.g., ACT* [ 21, Mental Models [ 201, etc.). illustrated with respect focus on the use of these appropriate computer program of the theory), concentrate apply equally developed cognitive approach to adaptively Soar is an information [ 341. Soar implements processing mechanism which is specialised a body of knowledge. The Soar architecture and resolve goals by exploiting upon the well-established space its current goal (the elaboration decision phase). Speaking goals, resolving Soar has sufficient knowledge its knowledge does not embody a solution the impasse and recursively resolve raise is based to modelling problem solving as search in a problem to (the to use in to carry out. If If generate a new goal to the and making decisions are made about to data, and the actions to solve that. If the subgoal succeeds, the goal will be solved directly. loosely, decisions to assign in a particular context its search by cyclically retrieving knowledge it will automatically the interpretations the knowledge the results relevant attempt phase), about R. Cooper et al./Artijcial Inrelligence 85 (1996) 3-44 7 impasse problem data and learn is resolved and the result becomes available solving within a subgoal the architecture in the parent goal context. While is able to identify critical contextual this as new knowledge for future use. 2.1.1. Natural language and diagrammatic descriptions language descriptions of Soar in the literature processing psychological by diagrams. Such descriptions the language and techniques of that field. The advantage of such descriptions There are many natural 3 1,401)) often accompanied tend to present Soar as an information employ that they allow force theorists preference existence of such rules as part of the essential Soar theory, but be non-committal the precise mechanism position research, or if they are in principle undecidable. (see, e.g., [23, are generally abstract. They theory, and in so doing is and do not level of abstraction details. Soar, for example, embodies a set of rules for making certain choices during decision making; we may regard the about acceptable for future is a perfectly are to be regarded as questions the theory into describing unnecessary if the details of the mechanism to be stated at an appropriate the rules are applied. This by which Natural language descriptions, however, have severe disadvantages. They are poten- the derivation of unequivocal and of limited precision. This can hinder in being abstract, natural tially ambiguous predictions. Furthermore, tails of a theory not affect but as Hunt and Lute point out, with reference detailed, natural Soar is not detailed enough would produce computationally allow the de- to be filled in in an indefinite number of ways. If such variation does this may not be of concern, to the longest, and presumably most of of Soar, “Newell’s description having read the book, language/diagrammatic to ensure that any two programmers, properties of the theory, equivalent programs” language descriptions the higher-level [ 18, p. 4481. description then 2.1.2. Procedural descriptions Many current psychological theories are highly complex, with the explanations they the interaction of several components or functional modules. As a result, a theory’s predic- instantiations draws heavily on the how the theory theoretical of theories are often vital in establishing in this regard, and the Soar community is viewed as a unitary to demonstrate when attempting if a program all of its components and processes must be In the case of Soar, status. This seems unsatisfactory. there are many features of the program which do not seem to have much offer involving computational tions. Soar is no different behaviour of the Soar implementation accounts statement treated as having equal theoretical for example, theoretical results. However, in this way then presumably force, such as: for empirical ( 1) The particular algorithms rules and remov- ing working memory elements during processing. These are designed primarily for efficient operation “correct”, does the neural If the Soar architecture these algorithms? and firing production on conventional implementation for matching also embody computers. is (2) The choice of preference out in different ways that any of these formulations theory which is somewhat semantics in different for operator selection, which has been fleshed [ 22-24,3 1 I. It is not clear implementations is superior, and this is clearly an aspect of the fluid. Little seems to hang on the details of different Indeed choices. different possible that any particular preference preference semantics ( 3 ) The generalised production semantics. it is unclear what sort of evidence could distinguish It seems hasty and possibly unnecessary semantics between to claim is part of the Soar theory, even if some is necessary for simulation purposes. language, which allows complex operations to be triggered directly by productions, (such rather input and output being governed by specialised sensor/effecter the product of more primitive processing (as as input. output and arithmetic) than, for example, mechanisms apparently and arithmetic being required by the cognitive the most These points highlight important difficulty with equating a program with a of implementation if details are required solely to achieve a complete, executable theory: the theory then those details may have unpredictable the intentions of the essential claims of the theory, and compromise behaviour, obscure the theorist, Given this, any claimed predictions of the theory made on the basis of the implementation must be open to debate, as must the claim that an implementation makes this is a point touched upon by Hunt and Lute: “we want to the theory that embody know whether psychological [ IX. p. 4481. the simulation was achieved by those parts of the program theory or by parts regarded as choices of convenience influences on the implementation’s in programming” testable. Again, theory [ 3 I] 1. A further concern with procedural descriptions of theories as complex as Soar is that for those not directly the theory as a whole or to modify it is difficult to contemplate correspond to specific theoretical assumptions runs to several Megabytes of C code. it is not possible but not all, of the underlying by isolating, assumptions. and systematically modifying. assumptions theoretical involved with the theory’s design and implementation (or even isolate) those parts which ( cf. [ lo] ). In the case of Soar, which now for outsiders who accept most, theories of particular to investigate Soar-like the computational realisation 2.1.3. Declarative specijications independent formal verification A third description method in the language Z. This is a mathematical that has been used by the Soar community of the program logic, which was designed is the formal language, based to provide clear descriptions of what a program details and to is decomposed in terms of the conditions specification on first-order should do under what circumstances permit into a hierarchy of operations. that must hold before the operation can be executed and the conditions which must hold program, but rather a after execution. A Z specification from any specific clear statement then, it is a description of a theory about which one can implementation. reason without worrying about whether (e.g.. in LISP or C), a piece of hardware, or as nervous of the required behaviour of the program In principle, of technology-specific [ 441. Roughly, a program each of which is then described as a procedural program itself an executable of its correctness it is implemented separate is not tissue. The purpose of the Z specification of Soar [ 271 was primarily for engineering The Z formalisation Soar. It is not a description Soar qua computer program specifies everything at the level of abstraction that is necessary rather than Soar qua psychological to provide a sound basis theory. for an executable version of stating for clearly appropriate R. Cooper et al. /Artificial Intelligence 85 (1996) 3-44 9 theory. Consequently, cognitive the underlying the Z specification makes no distinction processes which appear noted above). the psychological does not provide explicit support for it. If a Z specification theory, it may be possible between the essential to be matters of implementation detail of Soar were developed which attempted to make such a distinction, theoretical elements and (such as those features to capture although Z itself as with the procedural implementations, 2.2. Requirements for a theory specification technique surveyed allow above theories fail in different ways. Natural to be stated at the appropriate but are imprecise. Procedural descriptions are precise, but do not details, conflating the theory with its implementation. languages may do better, but existing distinction. specification From languages do these failings we for a theory specification technique: clarity, succinctness, separation. The methods of theory description support descriptions specification four requirements and diagrammatic the theory/implementation and theory/implementation is required and so that theorists may language level of abstraction, abstract away from implementation Formal not explicitly may distill executability, Clarity language isolate aids the isolation of theoretical assumptions: as an obscure notation. The case for executability current to derive predictions general only assumptions detail correctly attributed We refer to this separation theoretically motivated aspects being the line. located below through simulation can be determined. theories, and the difficulties from a specification is required directly in order to avoid the interpretation/ambiguity theoretical excessive verbosity assumptions. Succinctness problems of natural also to clarity of is as harmful is established by the complexity that such complexity present for anyone attempting of a theory. As noted above, it is in that the complex behaviour of a number of interacting the separation of theory and implementation Finally, if the complex behaviour displayed by an executable theory is to be to theoretical, and not implementational, aspects of the specification. as the above-the-line/below-the-line located above the line and implementation (or AIB) division, with details 2.3. Executable speci$cation languages for cognitive modelling executable specification of an appropriate that the failings of current articulation methods can in part be addressed by We believe the development language. By this we mean a language which may be used to specify a theory in a sense to be elaborated below yet which may also be animated; once specified that to be. Such a language must be precise its behaviour (a specification it should specifying what a process does rather allow one than the mechanical the that the between distinction formal specification details of how it is done. Critically, theory and implementation language Z is inappropriate. it is claimed can tolerate no ambiguity) detail and it is for this reason the model can be executed the language must support but, where necessary, from algorithmic that which to escape is indeed to check language details, Given the current usage of formal specification languages use of the phrase “executable specification language” requires in computer science, our some elaboration. Van Harmelen as: and Balder [45] summarise the purposes of forma1 specification languages l the removal of ambiguity. l facilitation of communication l the ability and discussion, to derive properties of the design in the absence of an implementation. it is not intended While we claim that the work presented below demonstrates specification language we have employed has considerable two points, construct computational models do not include We view executable behave, not as prescribing seem of greater relevance and support in respect of the first to verification of software. theory will to behave. As argued above, properties which executability, that the particular executable virtues to the cognitive scientist are clarity, succinctness, to address the third. The aims of psychologists as describing how a cognitive the mathematical for theoretical how it ought specification abstraction. attempting languages 2.4. A lB decompositiorl theories theories cognitive is essential Executability to implement implementation is not relevant requires over-specification: if the behaviour of complex it is not helpful is that executability is to be determined, but it has its price. As noted in Section 2.1.2, there are typically many aspects of a cognitive to the theory. As such it has been theory whose precise in this way. In brief, claimed that the specification of details the argument the scope of the theory. According beyond the precise specification irrelevant details would only conflate of such obscure theoretically that the core theory intuitively. However, a careful examination of specifying do. it is one of keeping aspects. Once qualified predictions a clear distinction predictions and is are made is not one requires we must theoretically motivated from the theory) to draw thus allowing important itself makes no formal predictions. Typically predictions that the point at issue reveals from (but kept distinct is the idea of AIB decomposition: the irrelevant details of a theory, which executability aspects. The problem with this argument, of course, the theory with its implementation theory and implementation to be properly drawn. can be drawn. This details are admitted between essential to this argument, details distinct implementation implementation details, Now, if implementation details are truly irrelevant, should be adequate. Thus, a theorist may give an input/output then any implementation of those specification details of some functional mechanisms which compute the subcomponent might finiteness considerations). More commonly, outputs given certain output. inputs, without subcomponent without specifying the details of the algorithms or the function. From the point of view of the implementation. just as well be implemented to the theorist may merely state constraints on a unique those constraints necessarily determining as a look-up (subject table reasoning Johnson-Laird logistic of propositions tokens arbitrary” illustrates [20]. According this second approach in the context of his theory of syl- “mental models” to this theory, people construct (such as some beekeepers are not chemists). These models consist of [. . .] is for but “the number of tokens in the proposition, is that the system [20, p. 971. and “a crucial point about mental models the terms representing R. Cooper et al. /Artificial Intelligence 85 (1996) 3-44 II them must embody knowledge [. . .] inference that is drawn” and interpreting to any proposes constructing depicted is irrelevant which Johnson-Laird totally specified. model. This style of theorising are articulated with sufficient precision It does not specify how many is valid, provided that the number of entities [ 20, p. 981. So the system but not tokens will be present in any particular that the constraints on irrelevant details is constrained, for constructing mental models to be testable. yields a procedure to implementation The A/B distinction for testing, via variation below to be a matter of implementation of behaviour sensitivity aspects claimed (or those aspects of behaviour under a range of alternate described as implementation related models which share their A component explored. Such investigations low-level behaviour. implementations investigation) of B assumptions, details. AIB decomposition reveal the degree detail, and, therefore, the line, the degree the to which are truly irrelevant. Only if behaviour to be invariant over can those assumptions truly be effectively delineates a space of can be shown and allows that space to be systematically to which high-level assumptions dictate [38] have explicitly used of the neuropsychological syndrome of a space of systems and input/output this deep that the be- in the space, when damaged, would have a number of properties, It was then postulated simulation [ 171 and Plaut and Shallice the connectionist the characterisation and Shallice in in terms of four general conditions. Hinton approach dyslexia. This work involved representations haviour of any system which specific systems, different erally exhibited details, Hinton, Plaut and Shallice demonstrated justifiably to those found empirically algorithms, regions of the space were then implemented in fact correspond learning be classified as implementation the hypothesised and input/output details.’ properties when damaged. in the syndrome. A number of in representations which were that they gen- ’ Thus, by varying various that certain aspects of their model could and it was shown to declare (A) and those which are implementation cannot be imposed on an implementation those aspects of an implementa- details theories will vary, and theory evolution realised as implementation of aspects previously It should be clear that the AIB distinction of A to B in different into involve the incorporation is on the theoretician a priori. The onus tion which are theoretically motivated (B). The proportion may well details tinction, when requires be regarded hypothesis testable. Thus, that aspects of an implementation as theoretically motivated. strategy: generating to justify embedded within the A component. Nevertheless, the proper application of the AIB dis- a philosophy of science that endorses which are in principle undecidable In this sense the AIB distinction falsification, cannot a embodies all aspects of the A component must be empirically being an A component, an aspect must be critical to the to be generally found predicted as a property of any model defined to occur only as a result of certain of the below-the- the frequency of so-called higher “mixed errors”-rrors which are similar to than one would expect given the frequencies of errors to corresponded the stimulus on a single dimension only. Thus the four basic assumptions implementations. t One of the behaviours initially assumed by the four basic assumptions was actually line the stimulus on more than one dimension-is which resemble above-the-line 2 Applying assumptions the same logic It was that for only the more global of the behaviours of the model. to variations semantics of Soar (as outlined in the preference suggests that the details of Soar’s preference evaluation arc also more a matter of implementation in Section 2.1.2), than theory. in behaviour. The AIB decomposition behaviour of the model as a whole. with variation of the aspect yielding measurable differences us not only to explore supposedly non-significant of a single above-the-line straints of related above-the-line approach empirically therefore allows the constraints the con- Section 4.3 gives an example of this technique theories within theory, but also theories within specifications. to explore related variant We may summarise Above-the-line “criticality” properties: the above-the-line/below-the-line in the following way. are theoretically motivated. They should have the following distinction assumptions ( I ) falsifiability: indicate (2 ) uniqueness: failure of the program to predict the falsity of one or more of the A assumptions; the observed behaviour and should distinct A assumptions should predict distinct behaviours. In contrast, below-the-line haviour should be subject changes ( I ) invariance: the program; and details are not theoretically motivated. Their effect on be- to the following “sensitivity” properties: to the B details should have no effect on the behaviour of ( 2 ) non-compensatability: A assumptions it should not be possible by adjustment of the B details. to compensate for failures of the In other words. behaviour brittle with respect to variation of A assumptions. should bc robust with respect to variation of B details but In practice so as to quantify The properties of criticality are idealisations: to develop of A and B components and sensitivity it may bc more appropriate categorical. sensitivity the contribution of a program. Such an approach has at least two advantages. Firstly. the sufficiency of competing ity/sensitivity theories address gramme in the criticality/sensitivity they cannot be and to the behaviour it would allow theory with a higher critical- to one with a lower ratio given that the it would allow the progress of a research pro- in terms of increases to be quantified, with theoretical advances being measured in reality indices of criticality ratio may be regarded as superior the same data. Secondly. to be compared-a theories ratio. 3. Sceptic: an example executable specification language The particular is Sceptic specification of various simulation cognitive modelling work using production required modelling (a) It had been found plex. time-evolving logical tems solving [ 461. executable specitication [ 9, 161. Sceptic was designed language with capabilities language which we have been working with of an executable to combine implementation the capabilities the practical that would facilitate and AI applications. Though it was not explicitly designed as a language, its design was loosely It was considered infuenced by earlier modelling as a first approximation to the rule systems. tool for several reasons: to have properties appropriate to the implementation ( including biological process simulations systems reasoning mechanisms [ 161 ), autonomous systems [36] and control processes in image interpretation of com- [ 481 and sys- and medical problem [ 141, planning R. Cooper et al. /Art@cial Intelligence 8.5 (1996) 3-44 13 theories, retrieval/update, interpreter in cognitive (b) The language assumed dressable memory agation modes. It has a simple but expressive tation of data structures easily described. (c) supports a number of mechanisms including pattern-directed sequential processing that are commonly processing, content ad- and parallel data prop- syntax which assists clear and succinct and processes, and its execution model represen- is simple and 3.1. The Sceptic language Sceptic was originally formulated as an extension The primary additional device from rule). Crucially rewrite control aspects of a program allows procedural [6] ), in which to Prolog (e.g., is a forward chaining control structure the perspective of cognitive modelling, to be expressed in from purely declarative aspects expressed is implemented. (the conditional this control in terms of rewrite rules and distinguished standard Prolog. structure it to any Sceptic program as execution Central and modified of such gram consists of a specification how the state evolves over events. tests, either modify is a database-the progresses. Rewrite the state or trigger of an initial rules further is queried system’s state-which test the state and, on the basis rules. A Sceptic pro- state and a set of rules which specify to particular in response rewrite time, or how the state changes 3.1.1. Syntax Sceptic inherits much of its syntax from Prolog. All data is represented via Prolog terms, which consist of a relation and zero or more parameters, e.g.: block1 augmentation(block1, colour=red) production(p&q, r) The last example above, production(p&q, the arguments p&q representing and r representing r), might represent a production antecedent matches against working memory creation of a working memory element. the consequent rule, with (p and q) Conditional rewrite rules have the following syntax: InTrigger: Conditionl, . . . . ConditionM => OutTriggerl, . . . . OutTriggerN. InTrigger, parameters augmentation( Conditions the in Obj ect , Attribute=Value), types of condition may be distinguished. and OutTriggers of Prolog variables form are all Prolog (indicated terms, possibly containing strings: three variables). as capitalised for example, contains Two test whether or not some condition holds in the current program state. We refer to these as state testers. Secondly, variables by two types of trigger: querying such as output primi- atomic information. We also distinguish built-in, operations triggers, which are non-decomposable, there are generators-conditions the state, thus generating there are those which instantiate Firstly, which tives and database modihcation terms of conditional rewrite rules. primitives; and compound triggers, which are defined in is pushed onto is then processed The execution of a Sceptic program ( c.g.. a primitive database modification) is governed by a stack which holds all unprocessed is issued at the Sceptic prompt. item by item. As each is a primitive then it is executed directly. Otherwise If all the conditions of a Sccptic rule (on the left-hand side of the rewrite then all the elements as the expansion of the trigger and pushed onto therefore consists of an indefinite number of (trigger event. check conditions. process actions) which continues until the stack is initiated when a trigger pattern triggers. Execution This pattern the stack. which item is taken off the stack it generates a trigger event. If a trigger event operation it is expanded. symbol, =>) are satisfied at the moment a Trigger on the right-hand the stack. Execution of a Sccptic program cycles is empty. side are generated event occurs the triggering Sccptic variables in which case the variables arc hound by ussignin g values during step or when Ic0-hand side conditions. Such conditions may either match an explicitly stored in the same side to the left of the rewrite symbol which have so for such conditions, multiple copies of actions checking term. position of the matching variables the same name. Variables that if Sceptic can find multiple solutions will bc pushed onto the slack with appropriate variable bindings. in the conditions of rewrite rules arc universally quantified term. or generate values from the program state. Right-hand take the values of any variables take the values of the constants simply To illustrate. in the following Sceptic rule: timeClime) : input_buffer(Object, => add_wm(Time,Object, Att=Value) Att=Value). a timestamped (e.g., a clock buffer when the time onto Sceptic’s stack. data item is added ticks) and there are data in an input channel. to working memory whenever a time event occurs If II items are in the input then II add_wm items will be created and pushed trigger occurs As noted above. Sceptic was originally developed to check and update employs built-in Prolog operations input/output etc. However, operations, operations could be implemented with any general programming hardware, aspects of Sceptic are the conditional and actions. conditions or even perhaps by a distributed, this is not considered rewrite rule and the division as an extension the program to Prolog, and state. carry out to be fundamental. These language, by specialised The essential this engenders between subsymbolic mechanism. Imagine we are constructing though perhaps theory. simple theories of twenty or so years ago. Cool it captures a motif common can be described to many real psychological in English as follows: a cognitive theory, call this Cocl. COG1 is a rather R. Cooper et al. /Artificial Intelligence US (1996) 3-44 15 Perceptual Mechanism > Central Planning * Motor System Fig. I. A box and arrow diagram of COG 1. Information where it is passed to a central processing executed. Since certain kinds of sensory link, between there is a “fast” however, execution mechanism, which operates channel. from enters a central cognitive system through a perceptual mechanism, channel in which actions are planned and information must be processed urgently, and the action the perceptual mechanism in parallel with the limited capacity central in a box and arrow notation, functional modules, and links between Cool might have been presented by a theorist such as that in Fig. 1. In the box and arrow notation boxes are typically used to represent hypothesised the flow of data the box and arrow notation does or control in which the detailed not represent mechanisms channels are disregarded. They are not considered the whole of the intended of the modules and communication to be part of the theory at this level of description. between modules. Of course theory, just an abstraction the boxes represent information Cocl might be specified in Sceptic by the following three conditional rewrite rules: perceptual_event(Event): direct_action(Event, Action) => execute_motor_command(Action). perceptual-event (Event) : not(direct_action(Event, Action)) => construct_and_execute_plan(Event). construct_and_execute_plan(Event): central_planning(Event, Action) => execute_motor_command(Action). two points about the structure of a Sceptic specification. Firstly, to one arrow in the box and arrow specification. The first to the to the arrow from the perceptual mechanism illustrates system. Secondly, The example each rewrite rule corresponds rewrite rule, for example, corresponds central planning constructand-executeplan boxes. With regard to processing, when a triggering event occurs there in parallel against consequent processing. Consequent the state of the system. events are generated triggers may also modify and executemotor-plan) triggers employed If the conditions is a perceptual the conditions in series, the three triggering event), of all corresponding resulting the system’s state. evaluate (e.g., when, in Cocl, rules are evaluated to true, then the in a further burst of (perceptual_event, to the correspond three Not shown above are the details of the antecedent conditions. These may be specified instance may in the box and arrow diagram, in standard Prolog. simply be listed. Note that such conditions though are not detailed is to be animated. they are necessary if the domain In particular. if the theory is restricted, each valid This example also shows some of the expressive power of rewrite demonstrate _” structure may be represented. All standard . else obvious. conditional by recursive it may not be immediately rewrite standard control structures. The rules for perceptual-event dard “if then structures may be implemented appears on their right-hand more, because variables all instantiations the rules embody a form of parallelism: for any given event. These will be executed sequentially onto the stack. but the evaluation of what actions parallel. sides, in conditions of the conditions central-planning i.e.. rewrite rules which to perform arc implicitly universally rules. Although rules can directly encode all how a stan- loop control trigger themselves. Further- quantified, and because state. may yield multiple actions in the order they are pushed in is effectively performed rewrite rules: rewrite rules whose trigger of any trigger are evaluated with a constant It was noted above that the structure of the Sceptic specitication internal of COCJ~ mirrored to the boxes were not supplied. of the theory. level, in the original the theory at the box and arrow statement accurately the details specification that such details were not specified captures the box and arrow diagram, although Given the Sceptic i.e.. at the level of psychological perceptual-event executed, but they arc not part of the psychological to support structures within in terms of conditional of Prolog predicate definitions. the theory/implementation and CentralPlanning the language: rewrite rules, with below-the-line theorising. Details of the two generating conditions, are necessary if the specification is to be is able distinct abovethe-line mechanisms may naturally be expressed in terms theory. In this way, Sceptic division via syntactically detail being expressed and semantically to specify The USC of Prolog predicate definitions rewrite rules are triggered less. Prolog, when interpreted as a logic programming apt here, as it allows a purely declarative particularly below-the-line as a set of algorithms. This avoids any possibility of attributing to implementation of below-the-line the conditions under which Sceptic is not. as noted above, an essential part of Sceptic. Neverthe- in the strongest sense, is detail: that must hold, rather than algorithmic properties terms aspects may be stated in terms of constraints detail, mirroring aspects the fact that the implementation statement of implementation is, by definition, beyond the bounds of theory. in algorithmic language 4. An assessment of Sceptic Our goal is to develop a specification language readable and succinct, modular, appropriately to evaluate Sceptic in these respects we now present in which definitions of models are In order abstract, and yet still executable. (a) a complete reconstruction R. Cooper et al./Art@cial Intelligence 8.5 (1996) 3-44 11 of Soar 4, demonstrating specifications (c) details of several computational of Soar 4, demonstrating Sceptic. the expressive power of Sceptic; of a number of other theories, demonstrating (b) an overview of Sceptic the generality of Sceptic; and experiments performed with the Sceptic specification empirical methodology based on the A]B distinction used with 4.1. The Sceptic reconstruction of Soar in many illustrates theory within to the development on a more challenging The toy psychological model above of a cognitive modelling methodology it addresses and the technical complexity the symbolic paradigm. Secondly, Soar represents for this purpose time, the most established example we have reconstructed for several Soar was chosen respects Soar is, at the present the basic concepts of Sceptic, but to a ver- evaluate the language reasons. sion of the Soar architecture. and mature Firstly, a major computational because of the challenge range of phenomena of the program. Soar is the product of more than a third of a century of research, beginning with a narrow focus in problem [ 231, and even a “unified been distributed Soar theory; a deeper understanding than for most computational models. Version 4 of Soar was chosen because version addressed by most existing verbal descriptions is sufficiently [lo], Shallice have any deep psychological motivation. this is the it the use of Sceptic, and, as argued by Cooper and in later versions [ 3 11. Finally, to many research groups who are investigating the Soar program has to the and contributing of the theory is therefore more widely disseminated complex it is not clear [ 23,3 l] ). In addition [ 331, and progressing theory of cognition” to an “architecture that the additional complexities intelligence” to illustrate for general present solving (e.g., Irrespective of Sceptic’s precise status as a general executable specification language, for relating theories capabilities phase, which reasons. Firstly, to be effectively evaluated for Soar and similar cognitive in Soar and many other current language the language are implicated involves many functionally for Soar, Sceptic’s conditional in parallel. This is particularly useful in specifying parallel activities. Thirdly, rewrite rules bear a close it is suitable as an implementation incorporates Prolog’s pattern matching several independent capabilities. Analogous theo- ries of cognitive processes. A second feature of Sceptic is its functional parallelism. The division between conditions to the expansion of and actions allows all conditions any trigger Soar’s elaboration and perhaps most appropriately resemblance Within in terms of a set of Sceptic rules. The decision, in Appendix A. The trigger of each rule is used complete to represent of the rules test the state of the Soar system, notable working memory, preference memory, and so to hold the actions of the rules are executed. These forth. When certain states are found to to the state of the system, such as additions actions to other system modules by means of working memory, and the sending of messages steps triggers. Where the literature on Soar warrants in Soar) of the component’s to the productions which form the basis of Soar’s elaboration of Soar each of the main components the Sceptic specification subgoaling set of these rules is contained it (i.e., it is clear that the internal the components. The conditions are part of the psychological cycle. (elaboration, both direct alterations the communication theory embodied and chunking) is specified implement operation between the internal collection of Sceptic there appears such decomposition structure of the component rules which specify to be no theoretical justification is implemented above the line by introducing a the internal details of the component. When in detail no for elaborating the operations is attempted-they are left below the line. Our aim in focusing on Soar was not simply it. This was successful to reimplement trace functions which duplicate it, but to rationally interest Of some Secondly, highlights examples, differences is identical of impasse architectural is decomposed implementations. the reconstruction types. In our view these differences the behaviour of the Sceptic version into and one of behind the reconstruction, reimplementations the decision phase the that, on to the original. there are certain aspects of the corresponding in that by using form of the original Soar’s output we have been able to demonstrate reconstruct surface published However, because of the emphasis on rational of the Sceptic version which are not merely aspects of the LISP Firstly, two separate processes, one of deciding upon a certain context element bookkeeping. the classification clarity of the theory’s structure whilst preserving the methodological from LISP and Sceptic versions of Soar 3 shows B components) of code. This difference of Sceptic-the (such as the RETE algorithm many of the interface friendly. We have not attempted include below-the-line mechanisms which have to be implemented in size does demonstrate the reduction ccutable. Nevertheless, sary for an executable statement of the theory can be given terms. of the both A and in lines capabilities algorithms it include to make the LISP implementations more user- to those the program ex- that all that is neces- reduced point of view is that comparison that Sceptic Soar (including is less than 10%~ of the size of the LISP version measured theoretically firing productions), to the expressive irrelevant such features, since our goal Sceptic version does not features of the program cannot be entirely together with just facilities designed in substantially for efficiently its behaviour. to duplicate theoretically significant nor does attributed to make increase actually is only include those program. Although the complete implementation it is still a substantial for difficulty of understanding implications the AIB distinction is substantially reduced It is hardly a succinct of code Soar theory, and this has obvious other than the authors. However. consists of only 28 Sceptic essential Soar 4 theory this represents a dramatic between relative ease of understanding arbitrary programs, underlying model, than a program written in size, at 2000 lines of the representation by those serves us well here. The A code the then rewrite rules, the minor differences to be important. The rules, as compared with the is in our view much easier to understand, criticise, assess and modify (see reduction the two programs noted above, we consider rules. If we accept the AIB decomposition [ 32, p. 4671) with the above-the-line to clarity. The Sceptic program, in complexity. Notwithstanding programming language. in a conventional also contributes condition-action this reduction of triggered and equate and hence the Sceptic specification Furthermore, paralleling Individual Sceptic modularity. of the Soar architecture. The rules can be modified requiring be arbitrary and must be made with care and attention to other parts of the program, rules capture changes of Cool, of individual there is also significant components to yield different behaviour without though of course such changes cannot to the data and control structure the functionality R. Cooper et al. /Art@icial Intelligence 85 (1996) 3-44 19 of the global program. The extent of the modularity of the Soar specification, of the consequent benefits, are illustrated by the computational Section 4.3. experiments discussed and some in 4.2. The generality of Sceptic Even conclusions if our optimistic based on our reconstruction the benefits may reflect merely a good match between and the capabilities of Sceptic. Other work suggests theories have been implemented of Soar are justified, ask to what extent Sceptic embodies a general method, and to what the needs of the Soar that this is not the case. Johnson- theory [43], [4] and Norman and Shallice’s using Sceptic, [ 201, Morton et al.‘s “Headed Records” [28], Sloman’s model of motives and emotions one may reasonably extent architecture A variety of cognitive Laird’s theory of model-based of memory Barnard’s model of automatic theory of Interacting Cognitive Subsystems structure and recall action control reasoning including [ 351. Johnson-Laird’s model-based theory of human syllogistic reasoning. These processes a model inspecting one, specifying by manipulating in LISP, and, at an abstract the Sceptic tially an algorithmic in syllogistic pair of premises, a conclusion mented aim of sion of the theory which separated This was achieved by associating Johnson-Laird, the model cated premises. and directly into Prolog generators the behaviour of the LISP specification translating a number of processes include building for a putative conclusion, reasoning claimed [20] is essen- to be involved is well specified in been attempting to provide theory has previously a model which satisfies a to refute imple- literature. The ver- statements details. and implementation trigger with each process described by of repli- of syllogism the an executable on all 64 configurations of the remainder implementation the LISP implementation and state testers. The resulting implementation a model, etc. The level, [7] was primarily theoretical one Sceptic is structured that memory has been developed A further processing in terms of a set of discrete theory of memory structure and recall theory for which a Sceptic specification of a set of access cues and a body containing is [ 281. This theory records, with each record the record may involve a sequence of recall is used, together with is accessed and its content to construct a new key for a further recall cycle. This theory, though not to be directly recall cycle was coded with create cue set; search record; and extend cue set. Morton et al.‘s Headed Records claims consisting of a heading consisting content of the memory. Recall of any particular cycles where an inappropriate external cues, previously implementable just record heading; Eight conditions were necessary in Sceptic. The A component of the complete implemented, was well described to the five principal processes: in the literature and proved five triggers, corresponding retrieve matching record; evaluate to encode record A very different style of theory [43]. This theory concerns ing possibly cesses. Such rules for a single global database, where conflicting, interacting processes retrieved the B component. is represented by Sloman’s the scheduling and attempted can be modelled in Sceptic the database elements theory of motive process- satisfaction of multiple, pro- in terms of transition represent the data on goals, and consists of a number of parallel communicating reasoning, style adopted for Soar, syllogistic the how of control in terms of Sceptic [X] This data-flow style of specification is specified the data-flow style is purely declarative, more closely approximating which the interacting processes operate is very different from the control-flow and mem- ory recall, where rewrite rules. In particular, formal just specification. The specification of Sloman’s motive processing architecture three rewrite rules: one to add new database elements: one to transform current database elements; instantiations. Thus. which a suspended motive will become active, while another reverse actual specification which scores well in terms of clarity, succinctness in the separation between tion is manifest conditions under the the also the AIB distinc- of rewrite rules and the Prolog and one to delete database elements. Each rule has numerous rule states the conditions instantiation in fully declarative Prolog. This specification The three rules can he viewed as an engine and modularity. instantiations specifies for executing for example, one instantiation of the transform transformation. In addition, is given includes on which A second data-flow they draw. theory which has been explored [4]. Again is Barnard’s cognitive architecture this is a theory which models the Sceptic specification interacting processes, and again three rewrite in terms of several based on Interacting Cognitive Subsystems cognition is driven by just to harness both Sloman’s motive processing Subsystems. Full details of all instantiations been developed, but exploratory work suggests Sloman’s motive processing model generalises asynchronous communicating processes. rules. In fact, the same three rewrite rules were used theory and Barnard’s Interacting Cognitive of the rules for Barnard’s system have not to that the specification style applied to a class of theories based on concurrent Lastly, Sceptic has been applied to Norman and Shallice’s Contention the sequencing Scheduling is an interacting such as preparing of actions and the se- breakfast or driving a car along a familiar [ 3.51. This concerns in those actions within segments of automatic or well-learnt theory of action selection involved lection of objects route. The behaviour, activation network of schemata or action segments. heart of the theory valued The theory differs substantially levels of schemata. Nevertheless, Sceptic has again representing variables [ 111. The style proved capable of accommodating specifying of specification database elements those elements. The con- tinuous valued variables are treated as one further component of the database elements, with the updated values being calculated to standard interacting that used for the theories of Sloman and Barnard, and rules for generating/updating/deleting the theory both clearly and succinctly from the current values according in that it includes continuous from those above the activation follows theories, activation difference equations. implementation in Table to the complexity The size of the Sceptic is shown guide arc concise. above ing an approximate all implementations and Interacting Cognitive Subsystems ecuted. I. Whilst of Soar, together with that of each of the the figures can only be taken as giv- that of the implementations, it is clear though Motive Processing, Contention Scheduling require further domain-specific code to be ex- One obvious class of theories is distributed or connectionist propriate for implementing theories. A highly symbolic approach for which the approach does not seem directly useful inap- in theory but Sceptic may still have utility is obviously a subsymbolic R. Cooper et al. /Ar$cial Intellijience 85 (1996) 3-44 21 Table I The size of various Sceptic implementations Soar (Version 4) Mental Models Headed Record Recall Motive Processing Interacting Cognitive Subsystems Contention Scheduling A: rewrite rules B: conditions 28 8 5 20 3 11 109 50 8 15 4 46 symbolic as Sceptic components components as below-the-line study of medical diagnosis procedures. This has been done exploring hybrid models by implementing rules, and the subsymbolic in an network was trained exploratory using a collection of records of patients with different diseases presenting with different sets of symptoms. The net learned a discriminating in the usual way. Another below-the-line the behaviour of the net and generated rules which were stored by a Sceptic program. As new cases led to weight symbolic revisions new or different a consistent rules were generated. The Sceptic component maintained set of rules using a simple [ 131. A back-propagation procedure monitored set of weights [ 161. truth maintenance mechanism theories encompass a wide range of theoret- that the approach has suggests Our conclusion is that the implemented ical traditions considerable and the relative ease of implementation generality. 4.3. Sceptic as an experimental tool and analyses and criticality In Section 2.4 we argued for the utility of sensitivity implementational in aspects of a model. The clarity and the theoretical of the Sceptic specification specific to demonstrate of Soar opens up the possibility of conducting the effect theoretical assumptions on the behaviour of the theory as a whole. to prove evaluating succinctness such analyses on Soar. In particular, with regard to criticality, we may consider of modifying In order the utility of computational experiments, we consider here three experiments with the working memory component implementation of Soar 4. Each experiment was conducted by modifying the effects of the of Soar 4 and then performing are in principle no modifications. different to that used to report more standard experiments. a number of simulations In order to emphasise to other experiments, that computational in a style similar the methodology, each is reported the Sceptic experiments to evaluate and 4.3.1. Experiment 1: the single state principle In 1990, the Soar community moved from version 4 to version 5 of their Rationale: architecture. The unrealistic of states the relevant goal requirement traversed within transition to Soar 5 was motivated primarily that Soar 4 placed on working memory, namely a problem space is maintained is achieved. This aspect of Soar 4 meant by a psychologically that the sequence in working memory until space that as a problem requirement is maintained state this. Newell [ 311 introduced the working memory space, only a single state was traversed, To counter problem Soar 5 this is effected via destructive the current modification. was designed without spaces, states, and operators) they were superseded. This is not destructive rather than being destructively modified-but however, to demonstrate those complications. is destructively modified in enormous results the single state principle to yield a new state. This destructive complications within Soar. Experiment as each operator increased at a virtually constant rate. (SSP): within any in working memory at any time. In is applied state I into Soar 4 (i.e.. problem from working memory when old state is deleted state modification-the it is a version of the SSP. idea was that old context elements The could simply be deleted that a version of the SSP could be incorporated state modification: rules which effected Method: The Sceptic specification with further rewrite elements whenever a new context element was installed. This situation the fact that working memory justified by the instantiations when a working memory element was removed, instantiation memory. The Sceptic rules are as follows: of Soar 4 (as given in Appendix A) was augmented the deletion of superseded working memory is complicated by is a form of truth maintenance system, with elements being of the productions which led to their creation. Therefore, from its justification was also removed install_context_object(Goal, Attribute, NewValue): parameter(single_state_principle, true), wm_match(augmentation(goal, Goal, Attribute=CurrentValue)) => remove_superseded_wmes(CurrentValue, Goal, Attribute). remove_superseded_wmes(Identifier, Goal, Class): wme_to_be_removed_after_installation(Identifier, Goal, => wm_remove(WME). remove_superseded_wmes(Identifier, Goal, Class): wme_to_be_removed_after_installation(Identifier, Goal, Class, WME) generating_instantiation(WME, Instantiation, FiringGoal), instantiation_not_supported(Instantiation) => im_remove(Instantiation, FiringGoal). Class, WME) The first of these rules It finds the is triggered whenever a context object current context element by matching against working memory and removes any elements to the context stack. For each such working connected memory element, for the element’s presence in working memory to this but not connected elsewhere if the production responsible it too is removed. is no longer applicable, is replaced. instantiation Simulations were run, both with and without monkeys and bananas of this in which task satisfied. A trace of decisions made. productions kept for both conditions for each task. the standard task, as released by CMU with Soar 4.5, and a modified version are the monkey only considers operators whose preconditions fired, and working memory size, was the SSP. on two tasks: R. Cooper et al./Arttjicial Intelligence 8.5 (1996) 3-44 2_1 a) Standard Monkeys and Banaoas Task b) Modified Monkeys and Bananas Task 300 150 I I 0 0 20 40 60 80 Cycle Number O- 0 I 10 I 20 Cycle Number 30 Fig. 2. The effect of the single state principle in Soar 4 on the size of working memory Results: The graphs in Fig. 2 show the size of working memory versus decision number for each of the tasks. In each case the higher curve corresponds to the original Soar 4. The lower curves were obtained when into the Sceptic specification. A comparison of the decisions made and productions revealed on each of the tasks. fired the two versions of Soar 4 the above version of the SSP was incorporated that there was no difference in behaviour between results irrespective the working memory is little difference between in a subgoal which requires approximately of any version of the SSP The difference requirements task. This is because Discussion: There two versions of Soar on the standard monkeys and bananas task the problem impasse elements, size is shown most clearly when problem solving space, when many decisions of an operator. At these times, increases memory be seen most clearly bananas Soar 5 since which overcomes substantially of the in this solving behaviour consists primarily of a succession of impasses. Each 30 more working memory in working memory is progressing within a single problem the selection of a new state after the application theory the working constant. This can and for exists is of the modified theory remains approximately in cycles 10 to 16 and 17 to 24 of the modified monkeys rationale the problems of increasing working memory task. The results of the experiment the number of decisions, whereas approximately requirement requirement of the standard that a viable alternative the working memory size and yet which than that employed state modification linearly with thus question to destructive the original in Soar 5. it appears involve simpler That there was no difference the SSP would seem assumption. It is only without the-line) size that criticality memory to be sure implementation executable that requirements specification of Soar 5. is widened if behaviour that the SSP is not a critical in the sequence of decisions made by Soar 4 with and (i.e., above- to indicate to include working memory to show that the working if we are the SSP in Soar 5 are this in the absence of an this, it is necessary the SSP and Soar 5 are equivalent in implementing to establish complications can be seen. Given of Soar 4 with the additional details. We have been unable 4.3.2. Experiment 2: rcwrkitzg tttetnory &ca~ Kutionale: A common assumption within cognitive psychology is subject over time Soar tolerate designed to decay or interference. (see. e.g., 131 ). Even so. human problem interference reasonable in which solving there is spontaneous robust. Can or loss from working memory? Experiment 2 was is relatively to explore Soar’s behaviour under conditions of working memory decay. is that working memory loss of information disconnected. Method: The elements of Soar’s working memory are arranged nected, directed , graph. A pilot experiment graph becoming to serious and irrecoverable terminal working memory elements. This restriction on decay might be justified nature of these elements: of the peripheral memory, and hencc, more liable to decay. in the form of a con- of this lead to in terms into working unconstrained working memory decay in this experiment decay was restricted they are less well integrated that, due to the possibility problems. Thus. frequently revealed The Sceptic specification 01‘ Soar 4 was thus augmented with a further rewrite which effected a random decay of working memory elements. A parameter specified is as follows: degree of decay. The rule, triggered at the end of each decision cycle, rule the memory-decay: parameter(working_memory_decay, wm_match(WME) , wme_is_terminal(WME), random(Z), Z<D => wm_remove(WME) D), This rule specifies element and if a pseudo-random memory element is less than the decay parameter. that a working memory element should be deleted number between 0 and 1 generated if it is a terminal for that working The simulation was run 20 times with different random seeds on the two tasks used in from 0.000 to 0.010 at intervals to a working memory half life of 693 cycles or 42 to a working memory if experiment 1 for values of the decay parameter of 0.001. A decay of 0.001 amounts seconds at 60 msec per cycle: cf. [ 3 1 1. A decay of 0.010 amounts half life of 69 cycles or 4.1 seconds at 60 msec per cycle. Execution was terminated the goal was not achieved within 100 decisions. A trace of decisions made, productions fired, and working memory elements decayed. was kept for each run. ranging solving the tracts ol‘ each run, two broad sorts of behaviour Kesults: On analysing could be the task, with seemingly perfect distinguished. Either Soar would successfully problem spaces, states and operators as when running without working memory decay), or Soar would subgoal apparently aimlessly. element would often In (see below). Fig. 3 shows the number eventually decay, resulting of instances of each sort of behaviour. the second case, some critical working memory complete the same problem in complete breakdown (i.e.. choosing exactly The results show two trends. Firstly, as the decay rate increases, the rate of success drops off gradually: Soar does not always simply collapse when working memory decay R. Cooper et al. /Artificial Intelligence 8.5 (I 996) 3-44 25 a) Standard Monkeys and Bananas Task b) Modified Monkeys and Bananas Task working Memory Decay Fig. 3. Behaviour of Soar with decay of working memory leaf elements. in short tasks even with some working memory decay. task, which involves the to a half life of 4.6 seconds. The effect of is introduced. Soar may succeed This is most clear in the case of the modified monkeys and bananas only 24 decisions. This task was correctly decay rate was 0.009 per cycle, corresponding decay is more pronounced when Soar is attempting and bananas can be tolerated.’ The second tasks. The standard monkeys less decay task requires 67 successive correct decisions. Here, substantially solved on one trial out of twenty when trend concerns element decays, and task. Though not shown by the graphs, experiment the number of decisions made before a critical working and is revealed most clearly by the standard monkeys that, as the the number of decisions before such an element memory bananas working memory decay rate increases, decays decreases. 2 confirms longer that Soar can withstand some working memory decay, Discussion: It has been shown and in this sense it is not entirely brittle. However, with an intermediate decay rate (say 0.002, giving a working memory half life of 21 seconds) Soar is still generally unable together 67 decisions, or 4 seconds of behaviour as required by the standard to string monkeys than that of task. Soar’s behaviour and bananas the average human. However, to be optimal. They perform no error checking actions. Given analysis of working memory elements-if working memory in these tasks were designed in their is as a criticality then most that an alternate way of looking at this experiment very little decay can be tolerated thus appears far more brittle elements must be critical employed and to the ideal problem solving behaviour- is no redundancy the productions there 3 This reasoning, does not halt when in terms of the mean experiments extracting and the fact that according to the cognitive it completes some task, suggests that the results might be more appropriately theory Soar is continuously making decisions and presented this here as these and the difficulty of prescriptions, of our methodological length of sequences of correct decisions. We have not attempted are intended only as a demonstration such information by hand would not be justified. into results concerning assumptions to be below the implementation possible dependencies to be the case. Built the results as measuring production However, building increase details. Could details which we have taken redundancy.’ into the productions would further the line are modified? Unfortunately details of the decision or error detection and recovery required of working memory. raise a general question on imple- influence this ap- cycle are the structure of working memory. One of these is work- to is we may interpret redundancy the capacity These mentation Soar’s behaviour when above-the-line pears various assumptions ing memory connectedness. terminal elements. A second assumption, which may be violated that each goal has a problem space, state. and operator. Because of these implementation dependencies, cedure fails if a problem desirable importance of being explicit about assumptions assumptions below-the-line the decision pro- it would be more the details. Such forcing a unique leads to complete breakdown: space, state. or operator decays. Presumably is satisfied by the restriction of decay in this experiment, built into implementation the line, without to redecide any missing elements. This demonstrates decay of these elements for Soar to attempt on details below This assumption to constraints specification. concerning amount 4.3.3. Experiment 2: instantiatiorl memo? deca! Rationale: of Soar’s production duction which originally replacing under production these conditions, firings) to decay. It could be argued that the previous experiment did not correctly if a working memory element decays, system base: put the element the decayed element. Experiment 3 was designed instantiation memory by allowing into working memory can simply take account then the pro- fire again, to test if Soar is more robust (the memory which records Method: The Sceptic specification effected a random decay of instantiation memory elements memory elements which they created. A parameter specified specifies number between 0 and the decay elements created by that instantiation follows: that an instantiation memory element instantiation memory rate. If an I generated element of Soar 4 was augmented with a rewrite rule which together with the working the rate of decay. The rule should be deleted if a pseudo-random for that instantiation memory element is less than is deleted, all working memory rewrite rule is as are also deleted. The conditional memory-decay: parameter(instantiation_memory_decay, im_match(Instantiation, random(Z), Z<D FiringGoal), => im_remove(Instantiation, FiringGoal), remove_dependents(Instantiation). D>, This rewrite rule was triggered at the end of each decision cycle. ‘We thank Richard Young for pointing this out to us R. Cooper et al. /Art$cial Intelligence 85 (1996) 3-44 27 a) Standard Monkeys and Baoanas Task b) Modified Monkeys and Bananas Task Instantiation Memory Decay m k.~.ss (nonllalj Success (delayed) Instantiation Memory Decay Fig. 4. Behaviour of Soar with instantiation memory decay. The simulation was run 20 times (with different random seeds) on the two tasks used 2 for each value of the decay parameter, which again varied from 0.000 if the goal was not achieved fired, and working memory in experiment to 0.010 by intervals of 0.001. Execution was terminated within 100 decisions. A trace of decisions made, productions elements decayed, was kept for each run. there instantiation is the possibility even with substantial of perfect behaviour, though interestingly those resulting (0.010 per cycle). As might be expected, perfect behaviour became in Fig. 4. Once again, performance with memory from the classes resulting from working memory decay. Results: The results are summarised decay falls into a number of broad classes, instantiation memory decay differ from Again, memory decay less frequent as the decay parameter was increased. However, unlike working memory decay, instantiation memory decay can lead to delayed success, where Soar completes its task to do so. In effect Soar can become sidetracked, or forget but requires more decisions shown with some information, the substantial delay is relatively the task which (i.e., of the order of 20%), but one case with decay normally task in solving at 0.010 showed a delay of 170%, eventually 65 decisions. Closer examination the that Soar repeatedly results of a subgoal before those results could be used, and had to repeatedly the results. small requiring perhaps 5 decisions more to complete correctly of this case revealed but later recover. This sort of behaviour in the modified monkeys and bananas forgot recalculate requires 24 decisions degrees of decay is most frequently task. In general, the 24 decision to complete Frequently Soar appeared could be Discussion: Where Soar failed In other cases, Soar forgot distinguished. its goal, and settled into a “waiting mode”, requiring new input to trigger further problem solving. that, given time, Soar would always either revert to this waiting mode or succeed. In the case of aimless subgoaling, post hoc probabilistic the task, two sorts of breakdown to subgoal aimlessly. analysis suggests The differences between the behaviour of Soar 4 with and without instantiation mem- ory decay shows that this form of decay, like the working memory decay of experiment 2, is a critical assumption. As a general memory decay option, however, instantiation mem- in so far as the resulting system ory decay appears to be more psychologically success as a result is more robust and one type of performance this form of behaviour, which of having to repeat steps-is solving of the (i.e., repeated was not expected, appears same goal) shown It therefore protocols system models may be a suggests mechanism behaviour experiment: of such behaviour. for perseverative from the computational it has not, to our knowledge, been suggested before as a possible explanation that instantiation memory decay within production further investigation plausible degradation-delayed solving. This is a novel result generated in Newel1 and Simon’s cryptarithmetic to accord with perseveration as a possible explanation intuitively plausible. that warrants in problem Indeed, [34]. 5. Executable specification languages and modelling methodology The work described here represents a step towards is as the computational to support all aspects of theory evolution. The environment of a general methodology. One possible engine within a software development like to see developed form one component that we would ology language can only for such a language vironment designed support computational as Sceptic. guages will emerge to be investigated provide and analysing data generated by such experiments. and allow criticality/sensitivity in the future. The language though we anticipate tools for designing and documenting experiments in cognitive the rigorous modelling method- science. but any modelling role en- should such lan- should permit variations on a model should analyses, and the environment to the model, and for collecting language specification executable variations carried out by means of a modelling that more sophisticated Preliminary analysis suggests that such an environment might incorporate a Lakatosian of the sort that Newell advocates philosophy, hard core of a theory and its auxiliary hypotheses. Within such an environment development would be concerned with adjusting to the below-the-line into the hard core which corresponds the auxiliary hypotheses corresponding incorporating assumptions aspects of the model. [ 311, with a clear division between aspects of the model and to the above-the-line the theory from there framework Such a proposed in his main exposition cumulative methodology later took a much weaker position, arguing that for theory development may be too constraining. Although of Soar as a psychological mode1 [ 311. Newell advocated in the spirit of Lakatos [25]. under pressure a from critics he [ There theory. some concepts transformation viable [. As in evolution. is no essential Soar, such that ii‘ we change it we no longer have the Soar .I It must evolve to be a successful to almost any can .] As long as each incremental a .] theory from the existing Soar theory, it will still and always be Soar. taking on others. But time. theory at each moment, eliminating lead change produces the evolution and over [ connection is historical. [32. p. 467 (Newell’s emphasis)] R. Cooper et al./Artificial Intelligence 85 (1996) 3-44 29 Even in this case which we take to be an extreme position, appropriate public criteria for is to have scientific theory change are required credibility. Three such criteria, proposed by Anderson in the context of his theory, ACT*, are: research programme if the computational [2, pp. 42-431 (1) There is a broad range of evidence from numerous empirical domains that sup- ports the change. (2) There is no obvious way to incorporate empirical phenomena within existing mechanisms. (3) There is a good argument for the adaptive value of the proposed mechanisms. We would advocate a fourth: result there is a danger (4) The alterations Without such criteria, unprincipled and frivolous way” [ 2, p. 421. in an increase in the theory’s criticality/sensitivity ratio. that “assumptions will be spun out in a totally The methodology we are developing in the sense which we criticised earlier-it of models and rigorously represents an advance on experimental program- publicly computational is based on well-defined, conducted, replicable specifications ming reviewable experiments. 6. Conclusions that laboratory for laboratory and evaluating for constructing the gap between if we are entering and testing computational computational models of cognition investigation need to be matched by equally well theories. Current are inadequate, a period of theoretical unification. As a step towards theory we have and computational languages. One such specification in this language have been devel- Mature methodologies conceived methodologies methods of building particularly bridging argued language oped using, as a test case, Soar, one of the most complex and challenging models for reconstructing separating rules, the abstract description of Soar approaches a conventional computational is practical the Soar model, and that such models may be clarified by clearly details. At only 28 than smaller investigation to develop executable it is important is Sceptic. Techniques in the literature. The results suggest elements of such theories three orders of magnitude for specifying models that the specification from implementation approach essential implementation. A great deal more work will be needed to realise a comprehensive methodology and testing computational tools software two main sets of requirements; including theories, than Sceptic. A full paradigm the provision of appropriate experiments, and techniques for supporting a number of such experiments and the progressive development In this paper we have only addressed for the results. focusing on the use of improved model specification scope for improvement is substantial there for the development of more so- for cognitive modelling must tools for individ- research programmes which of theories the first set of re- tools. We have shown in current modelling specifying phisticated address ual modelling subsume to account quirements, that, at a minimum, techniques. Appendix A. A rational reconstruction of Soar 4 To illustrate the use of Sceptic this appendix provides details of a Sceptic specification in context, we precede it with a brief itself is divided into four sections- the decision phase, and chunking-and features of the published the principle each theory. as given here consists of 28 rewrite rules. A full set of the behaviour of the in Prolog, with the specification loop, the elaboration phase, in sufficient detail to capture of Soar 4. In order to place summary of the Soar architecture. The specification the top-level is developed The complete A specification below-the-line resulting program corresponding on published A listing of the full program implemented has been examples functions is available on request. to that of the LISP version of Soar 4 running such as the monkey and bananas problem and the eight puzzle. exactly A. 1. A summaty of’ the Sour architecture A. 1.1. Overview qf‘ processiq Soar is an architecture, a fixed information processing structure which is specialised raise and resolve goals by exploiting a variable body of knowledge. [ 341, Soar implements approach to modelling problem its search by cyclically solving as search retrieving knowledge It is in (the elaboration phase) and making decisions (the decision phase). Loosely. decisions are made about space to employ), and actions space), the interpretations to carry out (the operator If Soar has sufficient knowledge If its knowledge does not embody a solution that it will automatically to solve it. If the subgoal succeeds, generate a new, impasse-specific the impasse in a particular context about the knowledge to assign the to use to data to apply to the goal will the architecture will goal and is resolved and the the in the parent goal context. During processing of an impasse is able to identify critical contextual data and chunk this as new fragments space the well-established to its current goal to adaptively based upon a problem relevant results in resolving goals (the problem (the state of that problem the current state). be solved directly. impasse; recursively result becomes available architecture of knowledge this means attempt for future use. A. 1.2. Memories and structures The Soar architecture makes the traditional distinction to as working memory. and a permanent between a transitory or short or long term memory to is traditional, it is difficult referred to as recognition memory. Though term memory referred the distinction equate either memory with instances of similar concepts Working memory, in the psychological for example, bears little relation (e.g., The contents of working memory literature in the psychological literature. is currently used to how the concept [ 3 ] ). represent all known aspects of the current problem solving context describe problem solving text) and operators example in the form of augmentations, or attribute/value pairs. Augmentations spaces, which are, in effect, the representation is or could be carried out, states (features of the current problem (external or internal actions which modify the current if the problem space attribute of goal Gl4 has P2 as its value in which problem solving con- state). For this is repre- R. Cooper et al. /Artificial Intelligence 85 (1996) 3-44 31 structure (goal G14 -problem-space P2). If the name space P2 is eight-puzzle then this is represented by the augmentation sented as the augmentation of the problem (problem-space Also contained P2 “name eight-puzzle). in working memory absolute worth of current and potential in selecting among competing problem indicate, other operator. working memory. In Soar 4 preferences for example, that within Recognition memory is closely related consist of a set of “matches” of co-occurrence term knowledge system architectures, long Productions elements indicate Variables can be shared between be consistently amounts in working memory the working memory elements to retrieval of information bound on any application Preferences the relative or are preferences. These encode used augmentations. spaces, states and operators. A preference may than some in a single is better are stored together are primarily and augmentations the current goal one operator and consists of an unstructured relations between working memory to the rule memory of earlier production set of productions. These represent elements. (templates which must be matched against (which applies). in which case they must a production of the production. Applying to be applicable) and “makes” that should be created if the production template matches and makes, for the production from long term memory. A.1.3. The processing cycle The Soar architecture operates phase followed by a decision phase. in a cyclic elaboration fashion, with each cycle consisting of an The elaboration phase from various designated motor augmentations. The perceptual is itself cyclic. Each cycle consists of an input cycle are checked and the results added in which to working memory, an are fired The elaboration phase channels in which productions to working memory), cycle are added input/perceptual elaboration p;oductions generated output cycles are not theoretically well advanced, detail here. It is primarily differences from later versions, fold: to elaborate those objects; and to create preferences operators. The same basic mechanism, purposes. the representation in all versions though and an output cycle (the right-hand sides of applicable in which output and we shall not consider is input and motor in cycle which differentiate Soar 4 cycle is two- these the purpose of the elaboration in the elaboration of objects in working memory by further augmenting for future possible problem the firing of productions, spaces, states, and achieves both of these A production may be fired if there is a mapping between existing working memory such that all variables are consistently mapped. Each consistent mapping yields elements and the elements of the left-hand in the production’s an instantiation conditions of the production. side of that production One elaboration in cycle of Soar 4 consists of firing all production parallel which are licensed by the contents of working memory but which have not being previously added subsequent identical in augmentations is also recorded and preferences to prevent to working memory. The results instantiation fired. This generally instantiations firings. been The alterations to working memory caused by each elaboration in new production input cycle may result tiations are fired in the next elaboration continues the elaboration phase terminates. until no further instantiations instantiations being cycle. Cycling within are licensed. At this point, licensed. These the elaboration cycle and subsequent instan- phase termed quiescence, The decisiotl phase The decision phase results in either the selection of a context object (a problem space, If a context state, or operator) or the creation of a subgoal object can be selected based on the preferences available at the beginning of the relevant decision the previous value of the object with the selected value. If no object can be selected creates a subgoal a set of default productions which is used for resolving problem solving the impasse. Soar has general, default knowledge encoded impasses and thereby permitting is modified by replacing then Soar automatically then working memory to an impasse. in response to proceed. to resolve cycle. in to solve a problem the possible states that can arise when solving a problem. Once a goal has been raised a problem space must be selected. The choice of problem In principle in any of a number of representations. Corre- operators apply to states and so a state must be selected before an operator space and initial state have been selected, that sub- in which space determines it might be possible spondingly, can he selected. operators are selected and applied the current goal has been achieved. At this point Soar terminates goals of the achieved goal which are now irrelevant thus restoring the goal originally in successive decision cycles until Soar detects any outstanding the context In general, once a problem arose. A. 1.4. Leartiitlg Soar also includes an experience-based learning mechanism, chunking. which can be fires in the context of a fire. any elements created which augment triggered by the firing of any production. Each production supergoals particular goal. When productions of their firing goal are detected. These elements are used to construct new productions (chunks) which are then added to recognition memory. Once a chunk has been created it behaves as any other production, to solve a goal the chunk will fire, possibly avoiding similar is built the need for subgoaling from the elements IO the creation of the subgoal from the results. to the supergoal and possibly higher goals which contributed is built directly in this new situation. The left-hand to that which previously results. The right-hand side of the chunk side of the chunk so if Soar finds lead to a chunk, itself attempting relating A.2. A Sceptic speci&atiotz of Soar 4 A.2.1. The Soar decisiotl cycle Ovenierv of the decision cycle As described above, top-level processing comprises repeated decision decision cycle consists of an elaboration phase where all long term knowledge cycles. Each is brought R. Cooper et al. /Arrijicial Intelligence 85 (1996) 3-44 33 to bear followed by a decision phase where a decision based on the current preferences is effected. Above-the-line specification of the decision cycle The Soar top-level cycle is captured by two rules, one which effects a single decision of an elaboration phase followed by a decision phase), and one which triggering rule, but the division distinguishes (by rules could be merged triggering one decision-cycle into a single before cycles cycle (consisting effects repeated decision itself). These between the cycling and the processing within each cycle. soar: true => decision_cycle, soar. decision_cycle: true => elaboration-phase, decision-phase. On the occurrence of the trigger soar Sceptic checks the conditions of all relevant its conditions are defined to be unconditionally cycle and then recursively is just one rule, and since the triggers on the right-hand the two triggers on the right-hand rules. There true, gering a single decision cycle, elaboration initiated, tween to be interrupted. Whilst it is the first of several clear differences between theory. phase and decision phase described the soar process cycles the Sceptic specification this is obviously indefinitely. There side of the rule are issued side of the second rule, corresponding triggering in sequence, first trig- soar. On each decision to the in sequence. Once is an obvious difference here be- which allow processing above, are called and the LISP implementations, a very useful feature of the implementations, the implementation and the cognitive Below-the-line processes in the decision cycle The only state employed. The and decisionPhase, functions. That extremely decisionphase tester used two right-hand in the above specification is true. No generators are side triggers not defined above, elaborationphase is, this specification can, at a highly abstract level, be classed as primitive updating of the top level of Soar may be viewed as an and of the entire architecture, with elaborationphase coarse specification being interpreted as primitive actions. Summary and discussion of decision cycle the specification Although the Soar processing the main subprocesses fit together. processes consists of only It specifies, two rules it is a substantive language which in a formal structure. involved in the Soar architecture, and the way in which summary of is executable, those 34 K. Cooper rt ul. /Arfificul Intellrgence 85 (1996) 3-44 the description elaborationphase the descriptions is very different lies in the primitives of Newell and from in Section 2.1. It abstracts away a massive amount of detail: much of which are in this appendix the essential to interrupt and theory, it is Of course. others discussed the theory defined below the line. It is the purpose of the remaining to put this detail back, but to do so in such a way that we only specify details. For example trace the problem important it is that they are only the process of providing system’s behaviour, or even the way theorists the perspective of specifying does not include such details, no matter how obvious since one cannot be sure that the the implementation, for implementational them may not substantively and decisionphase specifications have various mechanisms the LISP implementations that this specification solving. From the cognitive the theory. purposes, influence interpret A.22 Elaboratiorl phase processes O\lervieM, of the elaborution phase The Soar architecture takes in information from its environment ing memory. Relevant knowledge elements being added to working memory working memory elements are interpreted as motor commands. This process until quiescence. in the elaboration cycle. Finally, distinguished is repeated is then retrieved by firing productions. This results and stores it in work- in Aborle-the-line specification cf the elaboration phase The elaboration phase consists of eight rules. The first of these effects initialisation and an initial input cycle before triggering the cycling of the phase. elaboration-phase: true => initialise_elaboration_phase, input-cycle, cycle_if_not_quiescent. Initialisation consists of marking all currently This is necessary because created in the most recent elaboration phase and older working memory elements. the Soar decision procedure distinguishes existing working memory elements. between elements initialise_elaboration_phase: wm_match (WME) => wm_mark(WME). not-quiescent tests whether effects cycling within the elaboration phase. The the architecture has become quiescent or not. If Soar then the trigger will rewrite as the empty sequence of actions, rule which phase and returning to the top-level control terminating triggers the decision phase. If quiescence has not been reached cycle will be triggered, followed by an output cycle and a further The rule cycle-if condition antecedent is quiescent the elaboration next top-level phase, elaboration cycle. The rule will then trigger and input, until quiescence itself recursively, effecting further elaboration, is reached and the rule’s condition fails. the then an input output R. Cooper et al. /Artificial Intelligence 85 (1996) 3-44 35 cycle_if_not_quiescent: not (quiescent) => elaboration_cycle, output_cycle, input-cycle, cycle_if_not_quiescent. Neither the input cycle nor output cycle are well described that the input cycle adds elements is clear, however, output cycle effects motor commands specification given here also assumes from working memory when those commands have been carried out. in the Soar literature. to working memory, whereas It the based on the contents of working memory. The that the output cycle removes output commands input-cycle: generate_input_wme(WME, => wm_make(WME, Justification). Justification) output-cycle: match_output_wme(WME, Command) => effect_motor_command(Command), wm_remove (WME) . is for each quantified, a firing goal are universally The elaboration in Sceptic conditions rule finds all instantiations the firing of the production, of productions whose conditions cycle is specified by a cascade of three rules in which information rules as parameters associated with the rule triggers. The elaboration- are satisfied by the that so this rule is triggered once instantiation. The generator generatellnrefractedinstantiation instantiation. passed between cycle current contents of working memory, and which have not already been fired. Recall variables for each distinct also generates in has not previously element fire-production. an updater which makes an element future firings of the same instantiation, to prevent instantiation a rule which creates the appropriate working memory elements as specified by the right- and hand side of the firing production. The create-elements preferences are not used for truth maintenance learning mechanism. is the lowest goal matched the instantiation im-match), when creating an instantiation memory is triggered by in chunking which imrmake, the in instantiation memory, effectively marking side of the rule consists of two triggers: together with their justifications. it is used when checking rule adds augmentations to working memory and fire-production, for the particular been fired (via in Soar 4 (as they are in Soar 5)) but they are used by the The right-hand Justifications (im-make), firing This that and and elaboration_cycle: generate_unrefracted_instantiation(Instantiation, FiringGoal), not(im_match(Instantiation, FiringGoal)) => im_make(Instantiation, FiringGoal), fire_production(Instantiation, FiringGoal). fire_production(Instantiation, FiringGoal): generate_elements_to_make(Instantiation, ElementsToMake), generate_justification(Instantiation, Justification) => create_elements(ElementsToMake, Justification), build_chunks(FiringGoal, ElementsToMake). create_elements(ElementsToMake, Justification): member(WME, ElementsToMake) => wm_make(WME, Justification). The build-chunks follow process must allel process-as ory. rule is discussed separately the creation of working memory elements-it in Section A.2.4. Note that this cannot be a par- in mem- being and their justifications it relies upon those elements Belowthe-line processes in the elahorution phase Two state testers are required in the elaboration phase: quiescent, when there are no valid production have not already been recorded that an instantiation is currently also be used to generate here because, when it is called, which succeeds instantiations which have not been fired (i.e., which in instantiation memory); and immatch which checks in instantiation memory. This second state tester could It acts as a state tester the elements of instantiation memory. its arguments will be instantiated. The elaboration phase requires generators to identify and instantiate productions gether with their firing goal) which are applicable during (generate_unrefractedinstantiation) tification ing (generate_elements_tomake also used by create-elements, The principle which uses member, a standard initialise-elaborationphase, and to identify for those elements) which should actually be created by a production and generate_justif ication). the elements (to- the current elaboration phase (and the jus- fir- Generators are and output-cycle, and its justification the elaboration to working memory updater used during is wmmake. This adds an element if it is not already present. Several other updaters are also employed: wmmark marks an existing working memory element, removes indicating to an element instantiation memory; to serve as the interface it existed prior from working memory; phase; wmremove and its firing goal intended to the current elaboration and effectmotor-command to the motor system. adds an element is a primitive imnake action phase that input-cycle. library generator. Summary and discussion of elaboration phase The essential structure of the elaboration phase is captured by eight Sceptic rules. They the creation of working memory elements and the input cycle; the firing of all matching but previously unfired productions, the sequencing of the subprocesses: describe during the execution of motor commands of all essential processes building process. This process, which firing productions, is discussed in the elaboration phase in the output cycle. As an above-the-line specification it is complete except for the chunk for is responsible is triggered by the rule which in more detail below. R. Cooper et al. /Artificial Intelligence M (1996) 3-44 37 The elaboration functions cialised six primitive phases of processing. functions phase also requires a number of below-the-line for testing state and generating the processing results functions; for updating the state. Several of these are also used six spe- from this, and in other The modest size of this specification makes of elaboration sential mechanisms we have not described in detail, dures) but are of less importance theory, sential Soar nisms. to formulate predictions it relatively in Soar. The below-the-line involved involve significant to researchers wishing easy to understand the es- functions, which (14 Prolog proce- to get to grips with the es- it, or to design alternative mecha- programming from A.2.3. The decision phase Overview of decision phase phase attempts If this selection The decision current context. the context stack appropriately. it is generated. resolve to select a problem is successful If the selection space, state or operator for the then the selection is installed by adjusting fails an impasse arises and a subgoal to A further aspect of the decision phase not generally discussed concerns include in their representation object. These augmentations the adjustment that arise when several competing objects are equally of the to as item created during an elaboration phase may contradict current from of should further after each elaboration phase, any item augmentations should be removed and item augmentations an augmentation are referred for any goal arising item augmentations, for any new objects competing in the impasse. In the LISP implementations, is intertwined with the other algorithms effecting it as such clarifies the decision phase, but the and the nature the specification Preferences for a context Impasses slot of item augmentations. acceptable relevant goal for each competing augmentations. item augmentations, such an impasse. Consequently, a goal that are no longer applicable be created this process process of item augmentation is independent, adjustment. or suggest and treating Above-the-line specijcation of decision phase The decision phase can be viewed as having three parts. One is a cascade of op- the identify structure candidate values for the context object, select and install erations which preferred value, and terminate any subgoals which are no longer relevant. This relatively simple operation, the corresponding a third part of the decision phase. the the impasses and create forms adjustment that impasses may arise during to process subgoals. The distinct process of item augmentation so a second set of processes by the possibility is complicated is required to be (re)decided If a context slot needs by looking at is run the newly created preferences there is a no- for that slot. If there change impasse. This will occur if, for example, all problem spaces, states and operators currently have values and no preferences where generated on the previous elaboration phase which should alter those values. the selection process then in working memory, slot that needs then to be decided and this can be determined is no context decision-phase: generate_context_pair_to_alter(Goal, => attempt_selection_of_new_object(Goal, Attribute) Attribute). decision-phase: not(generate_context_pair_to_alter(_Goal, -Attribute)) => no_change_impasse. Given that a decision is required for a particular context slot, an object can be chosen randomly from the set of possible objects that may, according to the current preferences, fill that slot, but only provided that all of those possible values are “mutually indifferent” (which may be the case if, for example, the set is empty or if several values have conflicting preferences). If the set of possible values is not mutually indifferent then a context slot impasse arises. attempt_selection_of_new_object(Goal, Attribute): generate_possible_values_for_attribute(Goal, Attribute, mutually_indifferent(Goal, => select_and_install_object(Goal, attempt_selection_of_new_object(Goal, ValueSet), Attribute, ValueSet) Attribute, ValueSet). Attribute): generate_possible_values_for_attribute(Goal, Attribute, not(mutually_indifferent(Goal, Attribute, ValueSet)) => context_slot_impasse(Goal, Attribute, ValueSet). ValueSet), The selection and installation process consists of three independent ( 1 ) a value those possible and installed slot: from among is selected subprocesses: in the appropriate (2) all context slots within the current goal following the slot on which the decision is being made are reinitialised; and (3) all goals below the goal which the selected object augments are terminated. select_and_install_object(Goal, random_select(ValueSet, => install_context_object(Goal, Value) Attribute, Attribute, ValueSet): Value), Attribute), reinitialise_following_attributes(Goal, terminate_subgoals(Goal). install_context_object(Goal, Attribute, Value): responsible_preferences(augmentation(goal, Goal, Att=Val), => wm_replace(augmentation(goal, Goal, Att=Val), Conds). Conds) reinitialise_following_attributes(Goal, Attribute): following_context_attribute(Attribute, => initialise_attribute(Goal, AttributeToInitialise) AttributeToInitialise). R. Cooper et al. /Artificial Intelligence 85 (1996) 3-44 39 Subgoal termination involves removing all working memory elements which are not linked to the goal stack above the terminated goal and removing all elements from instantiation memory which are no longer relevant. These are all elements whose firing goal has been terminated. terminate_subgoals(Goal): generate_subgoal_wmeUME, Goal) => wm_remove (WME) . terminate_subgoals(Goal): generate_subgoal_ime(Goal, Instantiation, FiringGoal) => im_remove(Instantiation, FiringGoal). Turning to impasse processing, when a context slot impasse occurs, all previous sub- goals of the goal on which the impasse arose are terminated and a new subgoal is created. Appropriate architecture-generated augmentations are added to that subgoal. The attribute in the context slot that caused the impasse, as well as all lower attributes within that context, are reinitialised. Creating a subgoal requires a new identifier to be generated and several impasse-specific augmentations to be added to working mem- ory. context_slot_impasse(Goal, Attribute, ValueSet): Attribute, ValueSet, SubType) detect_impasse_type(Goal, => terminate_subgoals(Goal), create_subgoal(Goal, context_slot-SubType, ValueSet). Attribute, context_slot_impasse(Goal, Attribute, _ValueSet): generate_attribute_to_initialise(Attribute, => initialise_attribute(Goal, AttributeToInitialise). AttributeToInitialise) create_subgoal(Goal, Type, Attribute, ValueSet): generate_goal_identifier(SubGoal) => add_subgoal_augmentations(Goal, SubGoal, Type, ValueSet). Attribute, add_subgoal_augmentations(SuperGoal, Attribute, Goal, Type, ValueSet): generate_impasse_augentationf,SuperGoal, Attribute, Att=Val, Goal, Att=Val), Goal, Type, ValueSet, Justification) Justification). => wm_make(augmentation(goal, The processing required for a no-change impasse is similar except that, because no-change impasses can only occur on the lowest context slot of the lowest goal, no subgoals need be terminated and no context slots need be reinitialised. Instead a subgoal of the lowest goal is created, again with appropriate architecture-generated augmentations. no-change-impasse: generate_lowest_goal(Goal) => create_subgoal(Goal, no-change, _, _>. in which no context slot should be altered The Sceptic reconstruction highlights from situations where a choice situations arising slot impasses). The different and in response often discussed within operators. as a distinction made within that genuine processing differences underlie the Soar community to different impasses), two distinct types of impasse: (no-change those arising from and those is required, but no choice can be made (context stages of processing, the distinction, whilst spaces, states and regarded demonstrates at the level of problem is not generally the architecture. The Sceptic reconstruction the distinction. types of impasse arise at different failures of problem solving. However, rather than the level of individual Soar productions, The basic structure of the item adjustment step is straightforward. This is captured by a pair of rules, one of which is responsible and one for creating new ones. Both of these rules are triggered by decision-phase, corresponding rest of the decision phase, independently is triggered when a decision phase is triggered. to the fact that this process, which can be treated for removing invalid augmentations of the decision-phase: wm_match(augmentation(goal, Goal, item=Item)), not(generate_item_augmentation(Goal, Item, Justification)) => wm_remove(augmentation(goal, Goal, item=Item)). decision-phase: generate_item_augmentation(Goal, Item, Justification), not(wm_match(augmentation(goal, Goal, item=Item))) => wm_make(augmentation(goal, Goal, item=Item), Justification). Below-the-line A number of special generators speci$catiotz phase are required conditions where context objects need of the decisiotl justifications, subgoals alternative context objects are mutually for decision phase processing. These and generate possible to be installed, and so forth. A single state tester, is also indifferent, recognise candidates, augmentations, for determining whether required. General updaters are required for adding and removing elements ory, as well as for initialising memory. context slots and removing from working mem- from instantiation elements Item adjustment two left-hand side conditions. item augmentation requires used to generate an existing used to check whether is removed. The second rule uses these conditions in the opposite way. generate-item- augmentation is used to generate an item augmentation augmentation If not, the item augmentation and generateitemaugmentation In the first rule, wmmatch this item augmentation in working memory and its justification then it is added. is not present and if that is justified. is is The only updating mechanisms operations remove). for adding and deleting required during items from working memory are (wmmake item adjustment the standard and wm_ R. Cooper et al. /Ardjicial Intelligence 85 (I 996) 3-44 41 Summary and discussion Decision phase processing in the relative complexity is reflected rules and 12 specialised generators. Again, the complexity Soar cognitive of this coding theory. is the most complex part of the Soar architecture, and this of the Sceptic specification, which consists of 14 coding, but level of abstraction of the require significant the generators is not relevant at the required Item adjustment is conceptually are consistent a simple mechanism and complete. This simplicity for ensuring is reflected specification. This specification does suggest, however, mentations the above-the-line justment maintenance Soar, though can be seen as a restricted systems developed for a different purpose. form of truth maintenance, in AI [26] and explicitly employed similar that current aug- in the brevity of that item ad- to those truth in later versions of A.2.4. Chunking Overview of chunking Chunks are created whenever a production which fired within recent subgoal adds elements side of the chunk is derived left-hand which the production triggered the context of the most to a context associated with a supergoal. The right-hand from those elements added to the supercontext, with the of the elements the justifications to elements tracing in supercontexts. side being determined by recursively Above-the-line The above-the-line description of chunking specification of chunking consists of just two rules. The first rule attempts to build the appropriate chunk given a production’s firing goal and results. build_chunks(FiringGoal, Results): generate_lowest_goal(FiringGoal), new_supergoal_elements(Results, conditions_prior_to_goal(ElementsToMake, FiringGoal, ElementsToMake), FiringGoal, assemble_chunk(ElementsToMatch, ElementsToMake, ElementsToMatch), variablise_production(InstantiatedChunk, InstantiatedChunk), => add_chunk(VariablisedChunk, InstantiatedChunk) VariablisedChunk) . The second rule only fires if the potential chunk generated by the first rule does not to If this rule does fire, it adds the new chunk learned chunk. duplicate any previously recognition memory and refracts it by adding the appropriate memory, hence preventing its creation. it from firing immediately with the instantiation which led to instantiation to instantiation add_chunk(VariablisedChunk, Instantiatedchunk): not(test_duplicate_chunk(InstantiatedChunk)), generate_firing_goal(InstantiatedChunk, => im_make(InstantiatedChunk, FiringGoal), rm_make (Variablisedchunk) . FiringGoal) 42 R. Cooper et rd. /Artijiciul Intellipwe 85 (1996) 3-44 These two rules could be merged into a single rule, but the separation appears to be a natural one. The first rule essentially generates a potential new element of recognition memory, and the second an existing element. if it does not duplicate rule records this element Belm,-the-line A single descriptiorl tester qf churzkirlg state the chunk that chunking only occurs when in the first rule ensures from the firing goal and results. The first, new-supergoal- the tiring goal is the most recently created subgoal. Several generators are also used by this rule to generate elements, generates conditionsprior-to-goal, percontext which indirectly uses the results of the previous the final chunk. Finally, chunk from the instantiated to the supercontext. The second, from the su- two generators the generator variablise-chunk led to creation of these results. The third, assemble-chunk, version by replacing all identifiers with variables. the subset of results which belong the working memory elements to construct an instantiated generates an uninstantiated version of determines The second rule also uses a single state tester, checking not duplicate the appropriate an existing production. The firing goal of the chunk information may be added to instantiation memory. that the generated chunk does so that is generated Summary in the LISP this specification data that chunking and chunking is switchable between is that in our specification there are several differences between that at this level of abstraction chunking implementation. Most notable of these this and chunking over all goals. Newell is very simple. As with other Soar processes, to the most recently created subgoal. whereas chunking the above- is very brief. Considerable detail is again hidden below is not a complex pro- the is imple- [31] argues architec- chunking has therefore been disregarded here. More minor but not in this specification implementations and discussion In its barest form chunking the-line specification of chunking the line. but this reveals cedure. Nevertheless, LISP restricted mentations from psychological ture is bottom-up. All-goals in the LISP details present to dis- include: partitioning linked via some tinct chunks: expansion of each subset of results to include all elements to one of the results; removal of condition matches chain of working memory elements to the potential matching of the chunk; addition of inequality which add little constraint restrictions into subchunks which separately apply the operator and create the new state; and the filtering in certain problem spaces. The omission of these aspects of potential they are is justified by their dubious described they are not mentioned into linked subsets, with each such subset leading status as part of the Soar cognitive in the manuals which accompany descriptions of Soar [ 23,31,40]. splitting of operator application in cognitive psychological the Soar implementations to matches within chunks generated in the human theory-while of chunking information the chunk; processing of results [ 22,241, chunks References R. Cooper et al. /Artificial Intelligence 85 (1996) 3-44 43 [2] J.R. Anderson, The Architecture of Cognifion (Harvard University Press, Cambridge, MA, 1983). [ 31 A.D. Baddeley, Working Memory (Oxford University Press, Oxford, 1986). approach 141 P.J. Barnard, in: A. Ellis, ed., Progress in the Psychology of Language (Lawrence Erlbaum, Hillsdale, NJ, 1985) Chapter 6, 197-258. to short-term memory, a psycholinguistic subsystems: Interacting cognitive [ 51 B. Carpenter, The Logic of Typed Feafure Structures, Cambridge Tracts in Theoretical Computer Science 32 (Cambridge University Press, Cambridge, UK, 1992). [ 61 W. Clocksin and C. Mellish, Programming in Prolog (Springer, New York, 1981). [7] R. Cooper, A sceptic specification of Johnson-Laird’s reasoning, Department of Psychology, University College London, London theory of syllogistic “Mental Models” Tech. Rept. UCL-PSY-ADREM-TR4, ( 1992) 9 pp. [8] R. Cooper, A sceptic specification nursemaid London, London (1992) 15 pp. scenario, Tech. Rept. UCL-PSY-ADREM-TR3, of Sloman’s motive processing in the Department of Psychology, University College its application engine and I9 I R. Cooper and J. Farringdon, Sceptic version 4 user manual. Tech. Rept. UCL-PSY-ADREM-TR6, Department of Psychology, University College London, London ( 1993). [ IO 1 R. Cooper and T. Shallice, Soar and the case for unified theories of cognition, Cog&ion 55 ( 1995) of actions, Applications 115-149. [ 1 I ] R. Cooper, T. Shallice and J. Farringdon, Symbolic and continuous processes in: J. Hallam, ed., Hybrid Problems, Hybrid Solutions, Frontiers in Artificial in the automatic selection Intelligence and 1995) 27-37. [ I2 ] E. Davis, Representations of Common Sense Knowledge (Morgan Kaufmann, San Mateo, CA, 1990). [ 131 J. Faningdon, 27 (10s Press, Amsterdam, calculus, and reasoning with a back-propagation into propositional Translating network such translations over time, Master’s Thesis, South Bank Polytechnic, London ( 1990). [ 14 1 J. Fox, Techniques ] I5 ] M.R. Genesereth for developing distributed decision systems, Dilemma Workshop # 1 ( 1992). and N.J. Nilsson, Logical Foundations of Artificial Intelligence (Morgan Kaufmann, Los Altos, CA, 1987). 1 161 S. Hajnal, J. Fox and P Krause, Sceptic user manual: version 3.0, Tech. Rept., Advanced Computation Laboratory, Imperial Cancer Research Fund, London ( 1990). [ 171 G.E. Hinton and T. Shallice, Lcsioning an attractor network: investigations of acquired dyslexia, Psych. Rev. 98 (1991) 74-95. [ 181 E. Hunt and R.D. Lute, Soar as a world view, not a theory, Behav. Brain Sci. 15 (1992) 447-448. [ 191 M. Johnson, Attribufe-Value Logic and the Theory of Grammar, CSLI Lecture Note Series 16 (CSLI, Stanford, CA, 1988). [ 201 PN. Johnson-Laird, Mental Models (Cambridge University Press, Cambridge, UK, 1983). [ 211 R. Kowalski, Logic for Problem Solving (North-Holland, New York, 1979). [ 221 J.E. Laird, C.B. Congdon, E. Altmann and K. Swedlow, Soar user’s manual: Version 5.2, Tech. Rept. CMU-CS-90-179, Carnegie Mellon University, Pittsburgh, PA ( 1990). [ 231 J.E. Laird, A. Newell and P.S. Rosenbloom, SOAR: an architecture for general intelligence, Artrf Infell. 33 (1987) l-64. [24] J.E. Laird, K. Swedlow, E. Altmann, C.B. Congdon and M. Weismeyer. Soar user’s manual: Version 4.5, Tech. Rept., University of Michigan, Ann Arbor, MI (1989). 1251 1. Lakatos, Falsification and the methodology of scientific research programmes, in: I. Lakatos and A. Musgrave, UK, 1970)91-196. eds., Criticism and the Growth of Knowledge (Cambridge University Press, Cambridge, [26] J.P. Martins, The truth, the whole [27] B.G. Milnes, A specification of the Soar cognitive Carnegie Mellon University, Pittsburgh, PA ( 1992). truth and nothing but the truth, AI Magazine 11 (5) architecture (1991) 7-25. in Z, Tech. Rept. CMU-CS-92-169, [ 28 1 J. Morton, R.H. Hammersley I-23. Cognition 20 (1985) and D.A. Bekerian, Headed records: a model for memory and its failures, 1291 J. Morton and K.E. Patterson, A new attempt at an interpretation, or, an attempt at a new interpretation, in: Deep Dyslexia (Routledge, London, 1980) 91-118. 1301 A. Newell, You can’t play 20 questions with nature and win, in: W.G. Chase, ed., Visual Information Processing (Academic Press, San Diego, CA, 1973) 283-308. 44 R. Cooper CI (I/. /Ar/#c~ci/ Intelligence 85 (1996) 3-G [ 3 I 1 A. Newell. Unified Theories oj Copririorl 133 I A. Newell, Soar as a unified theory of cognition: issues and explanation. Behuv. Brain Sci. 1.5 ( 1992) (Harvard University Press, Cambridge, MA, 1990). 464-493. I33 I A. Newell, J.C. Shnw and H.A. Simon. Elements of a theory of human problem solving, Psych. Rat 65 (1958) 151-166. I34 I A. Newell and H.A. Simon, Hrrnnm Prohlerrr 135 I D.A. Norman and T. Shallicc, Attention So&q ( Prentice Hall, Englewood Cliffs. NJ, 1972). to action: willed and automatic control of behavior, in: R. Davidson. G. Schwartz and D. Shapiro. eds.. Conscinusness and Se[fRe&~tiont md Theory W. 4 ( Plenum, New York, 1986) I - 18. Advances in Reseurch [ 36 I M. O’Neill. The STOP demonstrator, Tech. Rept., Advanced Computation Laboratory, Imperial Cancer Research Fund, London ( 1992 ). [ 37 I D. Partridge. I%~irzeerin~ Arti$cuzl I38 I D. Plaut and T. Shallice. Deep dyslexia: a case study of connectionist neuropsychology, Co.pi/. .S(!frwnrr (Intellect Books, Oxford, 1992). Intrll~,qrrxe Neuropsych. 10 ( 1993) 377-SO0 I39 1 F? Rabbitt, Does it all go together when it goes?. (&mu. J. Lkperirn. Psych. 46A ( 1993) 385-434. I40 I P Rosenbloom, J. Laird, A. Newell and R. McCnrl, A preliminary analysis of the Soar architecture as a basis for general intelligence, Art@. 61/e!/. 47 ( 199 I ) 289-325. 131 I T.A. Salthouse, Effects of age on verbal ahilities: an examination of the psychometric literature, in: L.L. Light and D.M. Burke. eds.. Lm~:rru,~e und Memory in Old Age (Cambridge University Press, Cambridge, 1988) 17-35. I12 I T. Shallice, From Neurops?clfcll[,~~ I43 I A. Sloman. Motives, mechanisms. and emotions, Co,rnir. Ennjtion 1 ( 1987) 217-233 1441 J.M. Spivey. 77re Z Nrlfcltion: A Reference Munuul, Prentice Hall /n Men/al Srruc,rure I Cambridge University Press, Cambridge, 1988). International Series in Computer Science ( Prentice Hall, Englewood Cliffs. NJ, 1989) a formal 145 I E van Harmelen and J. Balder, ( ML)‘: Acqursit. 4 (1992) 127-161. language for KADS models of expertise, Knou$. 116 j N.S. Walker. Biomedical image interpretation. Ph.D Thesis, Department of Computer Science, Queen Mary and Westfield College, London ( I99 I ) / 47 I B. Wielinga. A. Schreiber and J. Breuker. KADS: a modelling approach to knowledge engineering, Knon[. Acquisit. 4 ( 1992) S-53. 148 I D. Zicha and J. Fox, Symbohc simulation of complex biological processes, Tech. Kept., Advanced Computation Laboratory. Imperial Cancer Research Fund, London ( 199 I ). 