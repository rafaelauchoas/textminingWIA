Artificial Intelligence 187–188 (2012) 52–89Contents lists available at SciVerse ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintConflict-driven answer set solving: From theory to practice ✩Martin Gebser, Benjamin Kaufmann, Torsten Schaub∗Universität Potsdam, Institut für Informatik, August-Bebel-Str. 89, D-14482 Potsdam, Germanya r t i c l ei n f oa b s t r a c tArticle history:Received 19 March 2010Received in revised form 26 February 2012Accepted 5 April 2012Available online 10 April 2012Keywords:Answer set programmingLogic programmingNonmonotonic reasoningWe introduce an approach to computing answer sets of logic programs, based on conceptssuccessfully applied in Satisfiability (SAT) checking. The idea is to view inferences inAnswer Set Programming (ASP) as unit propagation on nogoods. This provides us witha uniform constraint-based framework capturing diverse inferences encountered in ASPsolving. Moreover, our approach allows us to apply advanced solving techniques from thearea of SAT. As a result, we present the first full-fledged algorithmic framework for nativeconflict-driven ASP solving. Our approach is implemented in the ASP solver clasp that hasdemonstrated its competitiveness and versatility by winning first places at various solvercontests.© 2012 Elsevier B.V. All rights reserved.1. IntroductionAnswer Set Programming (ASP; [67,94,102,66,87,6,65]) has become an attractive paradigm for knowledge representationand reasoning, due to its appealing combination of rich yet simple modeling languages1 with powerful solving engines.Albeit specialized ASP solvers have been highly optimized (cf. [119,83,15]), their performance has so far not matched theone of modern solvers for Satisfiability (SAT; [12]) checking. However, computational mechanisms of SAT and ASP solvers arenot far-off, as witnessed by the SAT-based ASP solvers assat [90] and cmodels [71]. Nonetheless, state-of-the-art look-backtechniques from SAT, or more generally, Constraint Programming (CP; [26,113]), such as backjumping and conflict-drivenlearning, were not yet established in native ASP solvers. In fact, previous approaches to adopt such techniques [126,112,91]are rather implementation-specific, i.e., they focus on describing modifications of existing ASP solving approaches, and thuslack generality.We address this deficiency by introducing a novel computational approach to ASP solving, building on Boolean con-straints. Apart from the fact that this allows us to easily integrate solving techniques from related areas like SAT, e.g.,backjumping, conflict-driven learning, restarts, etc., it also provides us with a uniform characterization of inferences fromlogic program rules, unfounded sets, and conflict conditions. As major results, we show that all inferences in ASP solv-ing can be reduced to unit propagation on nogoods, and we devise the first self-contained algorithmic framework fornative conflict-driven ASP solving. While the general outline of search is the same as in Conflict-Driven Clause Learning(CDCL; [97,127,23,96]), the state-of-the-art algorithm for industrial SAT solving, the integration of unfounded set checkingis particular to ASP and owed to its elevated expressiveness (cf. [117,76,88]). However, our approach favors “local” unitpropagation over unfounded set checks, i.e., tests whether inherent (loop) nogoods are unit or violated. We elaborate upon✩This paper combines and extends the work presented in Anger et al. (2005) [2], Gebser et al. (2007, 2007, 2009) [54,52,56].* Corresponding author. Tel.: +49 331 977 3080/3081; fax: +49 331 977 3122. Torsten Schaub is also affiliated with the School of Computing Science atSimon Fraser University, Burnaby, Canada, and the Institute for Integrated and Intelligent Systems at Griffith University, Brisbane, Australia.E-mail addresses: gebser@cs.uni-potsdam.de (M. Gebser), kaufmann@cs.uni-potsdam.de (B. Kaufmann), torsten@cs.uni-potsdam.de (T. Schaub).1 The interested reader is referred to [120,45,83] for detailed accounts of ASP’s modeling languages.0004-3702/$ – see front matter © 2012 Elsevier B.V. All rights reserved.http://dx.doi.org/10.1016/j.artint.2012.04.001M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8953the formal properties of our conflict-driven algorithmic framework, and we demonstrate its soundness and completenessfor ASP solving.Our approach has led to the implementation of the award-winning ASP solver clasp, taking first places at the ASP, CASC,MISC, PB, and SAT contests in 2011 (see [110] for more details). We discuss the major features of clasp and provide anempirical evaluation of its performance by comparing it to other state-of-the-art ASP solvers, using the class of NP decisionproblems from the second ASP competition [28]. Generally, clasp has become a powerful native ASP solver, offering variousreasoning modes that make it an attractive tool for knowledge representation and reasoning.2 This is witnessed by anincreasing number of applications relying on clasp (or derivatives) as reasoning engine, e.g., [99,13,80,122,75,64]. Along withthe grounder gringo [51], clasp constitutes a central component of Potassco [44], the Potsdam Answer Set Solving Collectionbundling tools for ASP developed at the University of Potsdam.The outline of this paper is as follows. After establishing the formal background, we provide in Section 3 a constraint-based specification of answer sets in terms of nogoods. Based on this uniform characterization, we develop in Section 4algorithms for ASP solving that incorporate advanced look-back techniques. In Section 5, we describe the award-winningASP solver clasp, implementing our approach. Section 6 provides a systematic empirical evaluation demonstrating the com-petitiveness of clasp. We conclude with related work and summary. Proofs for formal results are provided in Appendix A.2. BackgroundGiven an alphabet P , a (propositional normal) logic program is a finite set of rules of the formp0 ← p1, . . . , pm, not pm+1, . . . , not pn(1)where 0 (cid:2) m (cid:2) n and each pi ∈ P is an atom for 0 (cid:2) i (cid:2) n. A body literal is an atom p or its (default) negation not p. Fora rule r as in (1), let head(r) = p0 be the head of r and body(r) = {p1, . . . , pm, not pm+1, . . . , not pn} be the body of r. Theintuitive reading of r is that head(r) must be true if body(r) holds, i.e., if p1, . . . , pm are (provably) true and if pm+1, . . . , pnare (assumed to be) false. Given a set β of body literals, let β+ = {p ∈ P | p ∈ β} and β− = {p ∈ P | not p ∈ β}. For body(r),− = {pm+1, . . . , pn}. The set of atoms occurring in a logic program Πwe then have that body(r)is denoted by atom(Π), and body(Π) = {body(r) | r ∈ Π} is the set of bodies of rules in Π . For regrouping rule bodiessharing the same head p, we define bodyΠ (p) = {body(r) | r ∈ Π, head(r) = p}.A set X ⊆ P of atoms is a model of a logic program Π , if head(r) ∈ X , body(r)− ∩ X (cid:7)= ∅ holds forevery r ∈ Π . In ASP, the semantics of Π is given by its answer sets [67]. The reduct, Π X , of Π relative to X is defined by− ∩ X = ∅}. Note that Π X is a Horn program possessing a unique ⊆-minimalΠ X = {head(r) ← body(r)model (cf. [30]). Given this, X is an answer set of Π , if X itself is the ⊆-minimal model of Π X . Note that any answer setof Π is a model of Π as well, while the converse does not hold in general.+ = {p1, . . . , pm} and body(r)+ | r ∈ Π, body(r)+ (cid:2) X , or body(r)The positive dependency graph of a program Π is given by (atom(Π), (cid:2)+), where atom(Π) and (cid:2)+ = {(p, head(r)) |+} are the set of vertices and directed edges, respectively. This graph allows us to identify circularr ∈ Π, p ∈ body(r)positive dependencies among atoms. According to [90], a non-empty L ⊆ atom(Π) is a loop of Π , if for every pair p ∈ L,q ∈ L (including p = q), there is a path of non-zero length from p to q in (atom(Π), (cid:2)+) such that all vertices in thepath belong to L. We denote the set of all loops of Π by loop(Π); if loop(Π) = ∅ (or loop(Π) (cid:7)= ∅), Π is a tight (or non-tight) program. As shown in [40] and exploited in Section 3, the answer sets of a tight program Π coincide with modelsof the Clark completion of Π [21], also referred to as the supported models of Π [3]. A strongly connected component of(atom(Π), (cid:2)+) is a maximal subgraph such that any pair of vertices is connected by some path; it is non-trivial, if it containssome edge. Note that, for any loop L of Π , the atoms in L belong to the same non-trivial strongly connected component of(atom(Π), (cid:2)+). Moreover, we have that Π is tight iff (atom(Π), (cid:2)+) does not include any non-trivial strongly connectedcomponent.Example 2.1. Consider the following logic program3:(cid:3)(cid:2)Π2 =a ←b ← not a d ← not c, not ec ← a, not de ← be ← e.(2)This program has two answer sets: {a, c} and {a, d}. Note that Π2 is non-tight because its positive dependency graphcontains the non-trivial strongly connected component ({e}, {(e, e)}).In practice, propositional logic programs are usually obtained from inputs in some first-order language (cf. [120,45,83])via grounding. We do not detail grounding here, but only mention that off-the-shelf grounders, such as dlv’s groundingcomponent [105], gringo [51], and lparse [120], are available to accomplish this task. Moreover, particular classes of logic2 Beyond search for one answer set of a propositional normal logic program, detailed in this paper, clasp supports so-called extended rules [47], solutionenumeration [53,57], and optimization [48]. Due to its versatile core engine, clasp can be run as a solver for ASP, SAT, Maximum Satisfiability (MaxSAT;[85]), and Pseudo-Boolean (PB; [114]) constraint satisfaction/optimization, incorporating dedicated front-ends for diverse input formats.3 Our enumeration scheme for particular logic programs Π follows that of equations.54M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89programs admit language extensions like classical negation and disjunctions [68], nested expressions [89], propositionalformulas [106,41], cardinality and weight constraints [119], or aggregates [39], to name some of them. In this paper, wefocus mainly on normal propositional logic programs and, in particular, on solving the decision problem of answer setexistence. For further details and broader overviews about the area of ASP, we refer the interested reader to [6,65].The concepts introduced next are central in the context of conflict-driven answer set computation. A Boolean assignmentA over a domain, dom(A), is a sequence (σ1, . . . , σn) of signed literals σi of the form Tv i or Fv i , where v i ∈ dom(A) for1 (cid:2) i (cid:2) n and v i (cid:7)= v j for i < j (cid:2) n. A literal Tv expresses that v is true, and Fv that it is false. (We omit the attributesigned for literals whenever clear from the context.) We denote the complement of a literal σ by σ , that is, Tv = Fv andFv = Tv. The sequence obtained by appending a literal σ to A is denoted by A ◦ σ . We sometimes abuse notation andidentify an assignment with the set of its contained literals. Given this, we access the true and the false members of A viaAT = {v ∈ dom(A) | Tv ∈ A} and AF = {v ∈ dom(A) | Fv ∈ A}. For A = (σ1, . . . , σi−1, σi, . . . , σn), let A[σi] = (σ1, . . . , σi−1) bethe prefix of A relative to σi , and define A[σ ] = A for any σ /∈ A.For a canonical representation of Boolean constraints, we rely on the concept of a nogood (cf. [26,113]), reflecting (par-tial) assignments that cannot be extended to a solution. In our setting, a nogood is a set {σ1, . . . , σm} of signed literals,expressing that any assignment containing σ1, . . . , σm is unintended.4 Accordingly, a nogood {σ1, . . . , σm} is violated by anassignment A, if {σ1, . . . , σm} ⊆ A. In turn, an assignment A such that AT ∪ AF = dom(A) is a solution for a set (cid:5) of nogoods,if no nogood in (cid:5) is violated by A.Given a nogood δ and an assignment A, we say that a literal σ /∈ A is unit-resulting for δ wrt A, if δ \ A = {σ }. Thisdesignates σ as the single literal of δ not contained in A, so that σ must necessarily be added to A for avoiding theviolation of δ. Note that a violated nogood does not have any unit-resulting literal, while the prerequisite σ /∈ A precludesduplicates: if A already contains σ , it cannot be unit-resulting.5 For example, Fq is unit-resulting for nogood {Fp, Tq} wrtassignment (Fp), but neither wrt (Fp, Fq) nor (Fp, Tq). Along the lines of SAT, for a set (cid:5) of nogoods, we refer to theiterated process of extending A by unit-resulting literals as unit propagation. We call a nogood δ an antecedent of σ wrt A, ifσ is unit-resulting for δ wrt prefix A[σ ]. In turn, σ ∈ A is implied by (cid:5) wrt A, if there is some antecedent of σ wrt A in (cid:5).3. Nogoods of logic programsInferences in ASP solving rely on truth values of atoms and applicability of program rules, which can be expressed byassignments over atoms and bodies. Given a program Π , we thus fix the domain of assignments A to dom(A) = atom(Π) ∪body(Π). Such a hybrid approach may result in exponentially smaller search space traversals than a purely either atom-or body-based approach [63,62]; it moreover allows for a succinct representation of nogoods, as we show in this section.While syntactic translations of logic programs to clauses (cf. [5,70,86]) primarily aim at reducing ASP to SAT solving, thenogoods provided below describe semantic conditions under which an assignment over atom(Π) ∪ body(Π) represents ananswer set of Π .Our approach is guided by the idea of Lin and Zhao [90] and decomposes ASP solving into “local” inferences obtainablefrom the Clark completion [21] of a program and those obtainable from loop formulas [90]. While Clark completion capturesthe answer sets of tight programs compactly in terms of theories in propositional logic [40], exponentially many loopformulas may be required in addition to extend this characterization of answer sets to non-tight programs [88].3.1. Completion nogoodsWe begin with nogoods capturing constraints induced by the Clark completion of a program, where we use ¬, ∧, ∨,→, and ↔ for denoting the classical connectives in propositional logic. Then, the Clark completion of a program Π can bedefined as follows:(cid:4)pβ ↔ p1 ∧ · · · ∧ pm ∧ ¬pm+1 ∧ · · · ∧ ¬pn∪(cid:4)p ↔ pβ1∨ · · · ∨ pβk(cid:5)(cid:5) p ∈ atom(Π), bodyΠ (p) = {β1, . . . , βk}(cid:6).(cid:5)(cid:5) β ∈ body(Π), β = {p1, . . . , pm, not pm+1, . . . , not pn}(cid:6)(3)(4)This formulation relies on atoms p as well as auxiliary propositions pβ representing bodies β. Such propositions are alsointroduced in Conjunctive Normal Form (CNF) transformations as abbreviations avoiding an exponential blow-up [123]. Themodels of the Clark completion of a program are called supported models [3]; on tight programs, they coincide with answersets [40].The equivalences in (3) define propositions standing for bodies, while those in (4) define atoms in terms of their sup-porting bodies. For identifying the underlying constraints, we begin with the body-oriented equivalences in (3). In fact, theycan be decomposed into two kinds of implications considered next.4 Any nogood {σ1, . . . , σm} can be syntactically represented by a clause σ1 ∨ · · · ∨ σm (dropping T and replacing F with ¬ in σ1, . . . , σm to stay in thesyntax of propositional logic), while other representations like logic program rules, PB constraints, and Boolean circuit gates are possible as well.5 The concept of a unit-resulting literal is closely related to unit clauses considered in SAT (cf. [12]): a clause is unit iff the nogood it represents hassome unit-resulting literal.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8955Table 1Body-oriented nogoods in (cid:5)body(Π2).Body β∅{not a}{a, not d}δ(β){F∅}{F{not a}, Fa}{F{a, not d}, Ta, Fd}{not c, not e}{F{not c, not e}, Fc, Fe}{b}{e}{F{b}, Tb}{F{e}, Te}Table 2Atom-oriented nogoods in (cid:5)atom(Π2).Atom pabcde(cid:5)(p){Fa, T∅}{Fb, T{not a}}{Fc, T{a, not d}}{Fd, T{not c, not e}}{Fe, T{b}}{Fe, T{e}}(cid:5)(β){T{not a}, Ta}{T{a, not d}, Fa}{T{a, not d}, Td}{T{not c, not e}, Tc}{T{not c, not e}, Te}{T{b}, Fb}{T{e}, Fe}δ(p){Ta, F∅}{Tb, F{not a}}{Tc, F{a, not d}}{Td, F{not c, not e}}{Te, F{b}, F{e}}On the one hand, we obtain (p1 ∧ · · · ∧ pm ∧ ¬pm+1 ∧ · · · ∧ ¬pn → pβ ). That is, the body β of a rule holds ifits body literals are true. Conversely, some literal of β must be false if β does not hold. So, given a body β =all{p1, . . . , pm, not pm+1, . . . , not pn}, the previous implication expresses the nogood:δ(β) = {Fβ, Tp1, . . . , Tpm, Fpm+1, . . . , Fpn}.Note that nogoods treat atoms and bodies as equitable objects. In terms of unit propagation, δ(β) is a constraint enforcingthe truth of β or the falsity of a contained literal. For instance, for body {a, not d} in Program Π2, we obtain δ({a, not d}) ={F{a, not d}, Ta, Fd} (see also Table 1).On the other hand, a body β must be false if some of its literals is false, or all literals of β must be true if βholds. This is expressed by the second implication obtained from (3), viz., (pβ → p1 ∧ · · · ∧ pm ∧ ¬pm+1 ∧ · · · ∧ ¬pn).It is equivalent to the conjunction of clauses (¬pβ ∨ p1), . . . , (¬pβ ∨ pm), (¬pβ ∨ ¬pm+1), . . . , (¬pβ ∨ ¬pn). For β ={p1, . . . , pm, not pm+1, . . . , not pn}, such clauses induce the following set of nogoods:{Tβ, Fp1}, . . . , {Tβ, Fpm}, {Tβ, Tpm+1}, . . . , {Tβ, Tpn}Taking again body {a, not d} gives (cid:5)({a, not d}) = {{T{a, not d}, Fa}, {T{a, not d}, Td}}.(cid:5)(β) =(cid:6).(cid:4)We now come to constraints primarily aiming at atoms. In analogy to the above, we derive the corresponding nogoodsfrom the equivalences in (4).To begin with, the implication (pβ1→ p) tells us that an atom p must be true if some element of bodyΠ (p)holds and, conversely, that all elements of bodyΠ (p) must be false if p is false. For bodyΠ (p) = {β1, . . . , βk}, we thus getthe set of nogoods6:(cid:5)(p) ={Fp, Tβ1}, . . . , {Fp, Tβk}∨ · · · ∨ pβk(cid:6).(cid:4)For example, for atom e in Program Π2 with bodyΠ2 (e) = {{b}, {e}}, we obtain (cid:5)(e) = {{Fe, T{b}}, {Fe, T{e}}} (see also Ta-ble 2).Finally, according to the implication (p → pβ1∨ · · · ∨ pβk ), some element of bodyΠ (p) must hold if p is true, or p mustbe false if all elements of bodyΠ (p) are false. For bodyΠ (p) = {β1, . . . , βk}, this is reflected by the following nogood:δ(p) = {Tp, Fβ1, . . . , Fβk}.Taking once more atom e with bodyΠ2 (e) = {{b}, {e}}, we get δ(e) = {Te, F{b}, F{e}}.Combining the four types of nogoods stemming from the Clark completion of a program Π , we obtain the following setsof nogoods:(cid:4)(cid:5)body(Π ) =δ(β)(cid:4)(cid:5)atom(Π ) =δ(p)(cid:5)Π = (cid:5)body(Π ) ∪ (cid:5)atom(Π ).(cid:5)(cid:6)(cid:5) β ∈ body(Π)(cid:5)(cid:6)(cid:5) p ∈ atom(Π)(cid:4)δ ∈ (cid:5)(β)(cid:4)δ ∈ (cid:5)(p)(cid:5)(cid:6)(cid:5) β ∈ body(Π),(cid:5)(cid:6)(cid:5) p ∈ atom(Π),∪∪(5)(6)6 For the sake of simplicity, we leave an underlying program Π implicit in the notations (cid:5)(p) and δ(p).56M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89Table 3Supported models of Π2 and corresponding solutions for (cid:5)Π2 .Supported model{a, d} ∪ {p∅, p{not c,not e}}{a, c} ∪ {p∅, p{a,not d}}{a, c, e} ∪ {p∅, p{a,not d}, p{e}}Assignment{Ta, Td, Fc, Fe, Fb} ∪ {T∅, T{not c, not e}, F{a, not d}, F{e}, F{not a}, F{b}}{Ta, Fd, Tc, Fe, Fb} ∪ {T∅, F{not c, not e}, T{a, not d}, F{e}, F{not a}, F{b}}{Ta, Fd, Tc, Te, Fb} ∪ {T∅, F{not c, not e}, T{a, not d}, T{e}, F{not a}, F{b}}For illustration, in Tables 1 and 2, we provide the set (cid:5)Π2 of nogoods stemming from the Clark completion of Pro-gram Π2. While Table 1 shows the body-oriented nogoods in (cid:5)body(Π2), Table 2 comprises the atom-oriented ones in(cid:5)atom(Π2).In what follows, we develop the result of this section that solutions for (cid:5)Π coincide with supported models, and if Π istight, also with answer sets of Π . As an auxiliary property, we have that the truth values of bodies are uniquely determinedby those of atoms.Lemma 3.1. Let Π be a logic program and X ⊆ atom(Π).Then, we have thatA = {Tp | p ∈ X} ∪(cid:6)(cid:4)Fp(cid:5)(cid:5) β ∈ body(Π), β(cid:5)(cid:7)(cid:5) β ∈ body(Π),β(cid:5)(cid:5) p ∈ atom(Π) \ X+ ⊆ X, β(cid:7)+ ∩− ∩ X = ∅(cid:8)(cid:8)atom(Π) \ X(cid:6)(cid:4)∪∪(cid:4)TβFβ(cid:7)∪− ∩ Xβ(cid:8)(cid:6)(cid:7)= ∅is the unique solution for (cid:5)body(Π) such that AT ∩ atom(Π) = X .Observe that, for a given X ⊆ atom(Π), the unique solution A for (cid:5)body(Π) must assign T or F to β ∈ body(Π) accordingto the semantics of conjunction, as it is expected.The next auxiliary result establishes one-to-one correspondence between supported models of Π , satisfying the equiva-lences in (3) and (4), and solutions for (cid:5)Π .Lemma 3.2. Let Π be a logic program and X ⊆ atom(Π) ∪ body(Π).Then, we have that ( X ∩ atom(Π)) ∪ {pβ | β ∈ X ∩ body(Π)} is a supported model of Π iff {Tv | v ∈ X} ∪ {Fv | v ∈ (atom(Π) ∪body(Π)) \ X} is a solution for (cid:5)Π .Since supported models and answer sets coincide on tight programs Π , we further obtain the following correspondencebetween answer sets of Π and solutions for (cid:5)Π .Theorem 3.3. Let Π be a tight logic program and X ⊆ atom(Π).Then, we have that X is an answer set of Π iffA = {Tp | p ∈ X} ∪(cid:6)(cid:4)Fp(cid:5)(cid:5) β ∈ body(Π), β(cid:5)(cid:7)(cid:5) β ∈ body(Π),β(cid:5)(cid:5) p ∈ atom(Π) \ X+ ⊆ X, β(cid:7)+ ∩− ∩ X = ∅(cid:8)(cid:8)atom(Π) \ X(cid:6)(cid:4)∪∪(cid:4)TβFβ(cid:7)∪− ∩ Xβ(cid:8)(cid:6)(cid:7)= ∅is the unique solution for (cid:5)Π such that AT ∩ atom(Π) = X .Example 3.1. For illustration, let us inspect the supported models and answer sets of Π2 from Example 2.1, which is non-tight because of rule (e ← e). The equivalences of the Clark completion of Π2 are:a ↔ p∅,p∅ ↔ (cid:15),b ↔ p{not a},p{not a} ↔ ¬a,c ↔ p{a,not d},p{a,not d} ↔ a ∧ ¬d,d ↔ p{not c,not e},p{not c,not e} ↔ ¬c ∧ ¬e,e ↔ p{b} ∨ p{e},p{b} ↔ b,p{e} ↔ e.The supported models of Π2 and corresponding solutions for (cid:5)Π2 are shown in Table 3. Note that the atoms belongingto the first two supported models correspond to answer sets of Π2, but not those in the third one. The reason for thismismatch is rule (e ← e), which makes Π2 non-tight. When dropping this rule from Π2, the first two supported modelsremain valid, while e in the third one is no longer supported. By Lemma 3.2, this allows us to conclude that the first twoassignments (without F{e}) are solutions for (cid:5)Π2\{e←e}. Since Π2 \ {e ← e} is tight, we can further use Theorem 3.3 to seethat {a, d} and {a, c} are the two answer sets of Π2 \ {e ← e}.As pointed out at the beginning of this section, the nogoods contributing to (cid:5)body(Π) in (5) and (cid:5)atom(Π) in (6) aredirectly linked to the clauses obtained when decomposing the equivalences in the Clark completion of a program Π inM. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8957the straightforward way. Hence, the nogoods in (cid:5)Π essentially characterize supported models in terms of assignmentsover atoms as well as rule bodies. Note that each atom and each body is defined by some equivalence, given implicitlythrough (the semantics of) Π or written explicitly in the Clark completion of Π . In a sense, one can view Π as a shorthandrepresentation for the conditions that all rules must be fulfilled and that any true atom must be supported via some rulewhose body holds.3.2. Loop nogoodsEvery answer set of a program Π is also a supported model of Π , while the converse does not hold in general. In fact,the mismatch on non-tight programs is due to the potential of circular support (or positive recursion) among true atoms,which is admissible with supported models, but not with answer sets. Hence, such improper support must be suppressedto distinguish supported models that are answer sets from the rest, and there are several approaches to accomplish this. Onthe one hand, well-founded semantics is based on unfounded sets [124], viz., sets of atoms that cannot be non-circularlysupported and must thus be false. While unfounded sets are traditionally determined wrt partial interpretations over atoms,an alternative approach identifying unfounded sets wrt (false) rule bodies is described in [2]. On the other hand, loopformulas can be utilized to characterize answer sets by classical models of propositional theories. Here, the main focusis on restricting the consideration of unfounded sets to particular (syntactic) classes of sets of atoms, namely, loops [90,82] or elementary sets [61,58]. In this section, we introduce the concept of an unfounded set in our setting and relate itto traditional approaches [124,84]. We further exploit unfounded sets to extend our constraint-based characterization ofanswer sets to non-tight programs, which yields a close relationship to loop formulas.To begin with, for a program Π and some U ⊆ atom(Π), we define the external bodies of U for Π asEBΠ (U ) =(cid:4)body(r)(cid:5)(cid:5) r ∈ Π, head(r) ∈ U , body(r)+ ∩ U = ∅(cid:6).A body in EBΠ (U ) can provide non-circular support for U , as it does not (positively) contain any atom of U . Then, U isunfounded, if all its external bodies are false, that is, if there is no non-circular support left for U . In our setting, thisamounts to the following definition.Definition 3.1. Let Π be a logic program, A an assignment, and U ⊆ atom(Π).Then, we define U as an unfounded set of Π wrt A, if EBΠ (U ) ⊆ AF.In more detail, this definition determines U as unfounded for Π wrt A, if for every r ∈ Π , we have that head(r) /∈ U ,+ ∩ U (cid:7)= ∅, or body(r) ∈ AF. For comparison, the traditional unfounded set definition by Van Gelder, Ross, andbody(r)Schlipf [124] can be reformulated wrt assignments as follows.Definition 3.2. Let Π be a logic program, A an assignment, and U ⊆ atom(Π).Then, we define U as a GRS-unfounded set of Π wrt A, if(cid:5)(cid:5)(cid:4)β ∈ body(Π)− ∩ AT+ ∩ AFEBΠ (U ) ⊆(cid:7)β(cid:7)= ∅∪β(cid:7)(cid:8)(cid:8)(cid:6).Note that this definition requires an external body to contain a false literal in order to witness the unavailability ofnon-circular support.For comparing our concept of an unfounded set to the traditional one, we define the following properties for a programalong with an assignment.Definition 3.3. Let Π be a logic program and A an assignment.Then, we define A as1. body-saturated for Π , if(cid:7)(cid:4)β ∈ body(Π)+ ∩ AFβ2. body-synchronized for Π , if(cid:4)β ∈ body(Π)+ ∩ AFβ(cid:5)(cid:5)(cid:7)(cid:5)(cid:5)(cid:8)(cid:8)(cid:7)(cid:7)∪∪− ∩ ATβ− ∩ ATβ(cid:8)(cid:8)(cid:6)(cid:6)(cid:7)= ∅(cid:7)= ∅⊆ AF;= AF ∩ body(Π).In words, body-saturation requires that bodies containing false literals must likewise be assigned to false; if the converseholds as well, we have body-synchronization.Based on these properties, we now formalize the relationships between GRS-unfounded sets and our unfounded setnotion.Proposition 3.4. Let Π be a logic program, A an assignment, and U ⊆ atom(Π).If A is body-saturated for Π , then we have that U is an unfounded set of Π wrt A if U is a GRS-unfounded set of Π wrt A.58M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89Fig. 1. The positive dependency graph of Π7.Proposition 3.5. Let Π be a logic program, A an assignment, and U ⊆ atom(Π).If A is body-synchronized for Π , then we have that U is an unfounded set of Π wrt A iff U is a GRS-unfounded set of Π wrt A.These results show that any GRS-unfounded set can be turned into an unfounded set by assigning bodies containingfalse literals to false as well, in this way establishing body-saturation. For a body β, the nogoods in (cid:5)(β) enable suchforwarding of falsity by unit propagation (cf. Section 2). As the following example illustrates, there is no straightforwardconverse “transformation” to turn unfounded sets into GRS-unfounded sets.Example 3.2. Consider the following (non-tight) program:(cid:2)Π7 =a ← not b c ← ab ← not a c ← b, d d ← ed ← b, ce ← b, not ae ← c, d(cid:3).(7)The positive dependency graph of Π7 is shown in Fig. 1. Observe that {c, d}, {d, e}, and {c, d, e} are all non-emptysets of atoms such that their elements reach one another via (loop-internal) paths of non-zero length, i.e., loop(Π7) ={{c, d}, {d, e}, {c, d, e}}. In particular, U = {d, e} is unfounded for Π7 wrt A = (F{b, c}, F{b, not a}) in view of EBΠ7 (U ) ={{b, c}, {b, not a}}. This tells us that any answer set of Π7 such that rules (d ← b, c) and (e ← b, not a) are inapplicable (i.e.,their bodies {b, c} and {b, not a} do not hold) must not contain d or e. In fact, the remaining rules supporting d and e,(d ← e) and (e ← c, d), are circular and do thus not provide external support for U . However, U is not a GRS-unfounded setof Π7 wrt A, and neither nogood δ({b, c}) = {F{b, c}, Tb, Tc} nor δ({b, not a}) = {F{b, not a}, Tb, Fa} allows for deriving thefalsity of any body literal by unit propagation wrt A. That is, the fact that the remaining supports for d and e are circularis not reflected by GRS-unfounded sets. On the other hand, we have that U is a GRS-unfounded set of Π7 wrt B = (Fb)because positive body literal b in {b, c} and {b, not a} is false wrt B. The mismatch that U is not an unfounded set of Π7(cid:16)containing F{b, c} and F{b, not a} iswrt B is due to B not being body-saturated for Π7. Yet a body-saturated assignment Beasily derived from B by unit propagation, in view of nogoods {T{b, c}, Fb} and {T{b, not a}, Fb} belonging to (cid:5)({b, c}) and(cid:16)(cid:5)({b, not a}), respectively. Then, we have that U is an unfounded set of Π7 wrt B.In order to identify constraints induced by unfounded sets, we inspect loop formulas. Reusing auxiliary propositions forrule bodies, as given in (3), for a program Π and U ⊆ atom(Π), the (disjunctive) loop formula can be written as follows:(cid:9) (cid:10)(cid:11)(cid:9) (cid:10)→p(cid:11)pβ.p∈Uβ∈EBΠ (U )Such a loop formula stipulates at least one body in EBΠ (U ) to hold whenever some atom of U is true. An alternativereading is that all elements of U must be false if U is unfounded. For Program Π7 and U = {d, e}, we get loop formula(d ∨ e → p{b,c} ∨ p{b,not a}); the corresponding clauses are (¬d ∨ p{b,c} ∨ p{b,not a}) and (¬e ∨ p{b,c} ∨ p{b,not a}).To capture unit propagation on loop formulas, for a program Π , a non-empty U ⊆ atom(Π), and some p ∈ U , we definea loop nogood byλ(p, U ) = {Tp, Fβ1, . . . , Fβk}where EBΠ (U ) = {β1, . . . , βk}. For Program Π7 and U = {d, e}, we obtain λ(d, U ) = {Td, F{b, c}, F{b, not a}} and λ(e, U ) ={Te, F{b, c}, F{b, not a}}. Notice that literals of the form Fβ, where β ∈ EBΠ (U ), are the same in λ(p, U ) for all p ∈ U .Overall, we get the following set of loop nogoods for a program Π :(cid:5)(cid:5) p ∈ Uλ(p, U )(cid:12)ΛΠ =(cid:6)(cid:4).∅⊂U ⊆atom(Π )The next result describes the relationship between loop nogoods and unfounded sets.Proposition 3.6. Let Π be a logic program and A an assignment such that AT ∪ AF = atom(Π) ∪ body(Π).Then, we have that A is a solution for ΛΠ iff U ⊆ AF for every unfounded set U of Π wrt A.In combination with Proposition 3.5, the previous result tells us that a body-synchronized total assignment A isunfounded-free [84] iff A is a solution for ΛΠ . Along with Lemma 3.1, which establishes that any solution for (cid:5)Π is body-synchronized, this now allows us to extend Theorem 3.3 to non-tight programs.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8959Theorem 3.7. Let Π be a logic program and X ⊆ atom(Π).Then, we have that X is an answer set of Π iffA = {Tp | p ∈ X} ∪(cid:6)(cid:4)Fp(cid:5)(cid:5) β ∈ body(Π), β(cid:5)(cid:7)(cid:5) β ∈ body(Π),β(cid:5)(cid:5) p ∈ atom(Π) \ X− ∩ X = ∅+ ⊆ X, β(cid:7)(cid:8)(cid:8)+ ∩atom(Π) \ X(cid:6)(cid:4)∪∪(cid:4)TβFβ(cid:7)∪− ∩ Xβ(cid:8)(cid:6)(cid:7)= ∅is the unique solution for (cid:5)Π ∪ ΛΠ such that AT ∩ atom(Π) = X .We have thus established that the nogoods in (cid:5)Π ∪ ΛΠ describe a set of constraints that need to be checked for iden-tifying answer sets. However, while the size of (cid:5)Π is linear in the size of Π , the one of ΛΠ is, in general, exponential.As shown by Lifschitz and Razborov [88], the latter is not a defect in the construction of ΛΠ , but an implication of widelyaccepted assumptions in complexity theory. Hence, most answer set solvers work on logic programs as succinct represen-tations of loop nogoods (or formulas, respectively) and check them efficiently by determining unfounded sets relative toassignments. To this end, program structure, viz., loops or elementary sets, can be used to confine unfounded set checkingto necessary parts.In the remainder of this section, we detail the theoretical foundations for the completeness of our loop-orientedunfounded set detection algorithm, presented in Section 4.3. To begin with, we note that, under the assumption of body-saturation, we may eliminate false atoms from an unfounded set in order to obtain an unfounded set of non-false atomsonly.Proposition 3.8. Let Π be a logic program, A an assignment, and U an unfounded set of Π wrt A.If A is body-saturated for Π , then we have that U \ AF is an unfounded set of Π wrt A.For instance, U = {b, d, e} is an unfounded set of Π7 wrt body-saturated assignment A = (F{not a}, Fb, F{b, d}, F{b, c},F{b, not a}), and Proposition 3.8 tells us that U \ AF = {d, e} remains unfounded for Π7 wrt A. That is, we may limit theattention to unfounded sets containing exclusively non-false atoms.In what follows, we exploit loops to confine the consideration of unfounded sets, essentially reproducing results similarto those in [90,2] in our setting. To accomplish this, we introduce atom-saturation as a property dual to body-saturation.Definition 3.4. Let Π be a logic program and A an assignment.Then, we define A as atom-saturated for Π , if(cid:4)p ∈ atom(Π)(cid:5)(cid:5) bodyΠ (p) ⊆ AF(cid:6)⊆ AF.This definition requires that atoms p without support must be assigned to false, as it is also stipulated by nogoodδ(p) = {Tp, Fβ1, . . . , Fβk} (where bodyΠ (p) = {β1, . . . , βk}).Given an atom-saturated assignment, we have that every non-empty unfounded set of non-false atoms contains someunfounded loop.Proposition 3.9. Let Π be a logic program, A an assignment, and U ⊆ atom(Π) \ AF a non-empty unfounded set of Π wrt A.If A is atom-saturated for Π , then there is some unfounded set L ⊆ U of Π wrt A such that L ∈ loop(Π).For illustration, note that U = {d, e} is an unfounded loop of Π7 wrt atom- and body-saturated assignment A =(F{not a}, Fb, F{b, d}, F{b, c}, F{b, not a}). Moreover, {a} is the only non-empty unfounded set of Π7 wrt B = (F{not b}), whichis not atom-saturated because a /∈ BF. The fact that a must be false when given B is expressed by δ(a) = {Ta, F{not b}}, andλ(a, {a}) = δ(a) does not provide additional information for the “non-loop” {a}.Given that a program may yield exponentially many loops, which can be unfounded separately wrt different assignments,it is impractical to identify (arbitrary) loops a priori. However, the non-trivial strongly connected components of a positivedependency graph limit the atoms that can jointly belong to (unfounded) loops, and the scope of unfounded set checkingprocedures [119,17,2,31,47] can thus be restricted to them. In our setting, the fact that the consideration of unfounded setscan be confined to non-trivial strongly connected components is an immediate consequence of Proposition 3.9.Corollary 3.10. Let Π be a logic program, A an assignment, and U ⊆ atom(Π) \ AF a non-empty unfounded set of Π wrt A.If A is atom-saturated for Π , then there is some non-empty unfounded set Usame non-trivial strongly connected component of (atom(Π), (cid:2)+).(cid:16) ⊆ U of Π wrt A such that all p ∈ U(cid:16)belong to theFinally, we can combine Propositions 3.8 and 3.9 to establish the formal basis for the completeness of our unfounded setdetection algorithm in Section 4.3.60M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89Theorem 3.11. Let Π be a logic program and A an assignment.If A is both atom- and body-saturated for Π and if there is some unfounded set U of Π wrt A such that U (cid:2) AF, then there is someunfounded set L ⊆ U \ AF of Π wrt A such that L ∈ loop(Π).Since fixpoints of unit propagation on (cid:5)Π are both atom- and body-saturated for Π , Theorem 3.11 tells us that un-founded set checking can focus on loops (of non-false atoms). For Program Π7, where loop(Π7) = {{c, d}, {d, e}, {c, d, e}} (cf.Fig. 1), we can thus in principle restrict unfounded set checking to its three loops in order to test all nogoods in ΛΠ7 .As mentioned above, it is impractical to consider (arbitrary) loops as long as they are not unfounded, while stronglyconnected components can easily be determined statically [121]. The role of such components as a means to limit the scopeof unfounded set checks is summarized in the following immediate consequence of Theorem 3.11.Corollary 3.12. Let Π be a logic program and A an assignment.If A is both atom- and body-saturated for Π and if there is some unfounded set U of Π wrt A such that U (cid:2) AF, then there is somebelong to the same non-trivial strongly connected component(cid:16) ⊆ U \ AF of Π wrt A such that all p ∈ U(cid:16)non-empty unfounded set Uof (atom(Π), (cid:2)+).With the characterization of answer sets in terms of nogoods along with relevant background knowledge on unfoundedsets at hand, the next section provides our conflict-driven approach to the computation of solutions representing answersets.4. Conflict-driven ASP solvingGiven the specification of answer sets in terms of nogoods, we can now make use of advanced search techniquesfrom SAT for developing equally advanced ASP solving procedures. But while SAT deals with plain nogoods, representedby clauses, our algorithms work on logic programs, inducing several kinds of nogoods. In particular, the exponentially manynogoods stemming from unfounded sets are succinctly given by a program, and the algorithms devised below determine in-dividual ones only when used for unfounded set falsification. The main purpose of associating nogoods with a logic programis to provide reasons for literals derived by (unit) propagation. This puts ASP solving on the same logical fundament as SATsolving, so that similar reasoning strategies can be applied without relying on translation to SAT or proprietary techniques(apart from unfounded set checking).In what follows, we first present our main conflict-driven ASP solving procedure. We then detail its subroutines for prop-agation and unfounded set checking, which is the main particularity of ASP (compared to SAT). Furthermore, we describeresolution-based conflict analysis in our setting. Finally, we outline the derivation of soundness and completeness results.4.1. Conflict-driven nogood learningOur main procedure for deciding whether a program has an answer set is similar to CDCL with First-UIP scheme [97,127,23,96]. In fact, clauses can be viewed as particular syntactic representations of nogoods, but other representations (e.g.,gates, inequalities, rules, etc.) can be used as well. Hence, to abstract from syntax, we present our conflict-driven algorithmfor ASP solving in terms of nogoods and call it Conflict-Driven Nogood Learning for ASP (CDNL-ASP).Given a program Π , CDNL-ASP, shown in Algorithm 1, starts from an empty assignment A and an empty set ∇ ofrecorded nogoods. The latter include nogoods derived from conflicts encountered during search, and if Π is non-tight, alsoloop nogoods explaining inferences due to unfounded sets. Moreover, the decision level dl, initialized with 0, is used to countdecision literals, that is, literals in A that are heuristically selected (cf. Lines 14–17), while literals derived via propagation inLine 5 are implied. For any literal σ ∈ A, we access via dl(σ ) the decision level of σ , that is, the value dl had when σ wasadded to A; such values are relevant for conflict analysis in Line 8 and backjumping in Line 10.Algorithm 1 follows the standard proceeding of CDCL. First, NogoodPropagation (detailed in Section 4.2) determin-istically extends A, and possibly also records loop nogoods from ΛΠ in ∇. Afterwards, one of the following three casesapplies:Conflict If propagation led to a conflict, as checked in Line 6, there are two possibilities. If the current decision level is 0,it means that the conflict occurred independently of any heuristic decision; that is, the input program Π hasno answer set. Otherwise, ConflictAnalysis (detailed in Section 4.4) is performed in Line 8 to determine aconflict nogood δ, recorded in ∇ in Line 9, and a decision level to jump back to.Note that we assume δ to be asserting, i.e., some literal must be unit-resulting for δ wrt A after backjumpingin Line 10. This condition, which is guaranteed by ConflictAnalysis, makes sure that, after backjumping,CDNL-ASP traverses the search space differently from before (without explicitly flipping any decision literal).Solution If A is not conflicting (ε (cid:2) A for all ε ∈ (cid:5)Π ∪ ∇) and total (AT ∪ AF = atom(Π) ∪ body(Π)), as checked in Line 11,the atoms that are true in A form an answer set of Π .Decision Finally, if A is neither conflicting nor total, a decision literal σd is selected according to some heuristic (seeSection 5 for further details) and added to A. We assume that σd = Tv or σd = Fv for some v ∈ (atom(Π) ∪M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8961Algorithm 1: CDNL-ASP.: A logic program Π .: An answer set of Π or “no answer set”.InputOutput1 A := ∅2 ∇ := ∅3 dl := 04 loop5(A, ∇) := NogoodPropagation(dl, Π, ∇, A)if ε ⊆ A for some ε ∈ (cid:5)Π ∪ ∇ thenif dl = 0 then return no answer set(δ, dl) := ConflictAnalysis(ε, Π, ∇, A)∇ := ∇ ∪ {δ}A := A \ {σ ∈ A | dl < dl(σ )}else if AT ∪ AF = atom(Π) ∪ body(Π) thenreturn AT ∩ atom(Π)elseσd := Select(Π, ∇, A)dl := dl + 1dl(σd) := dlA := A ◦ σd67891011121314151617// assignment over atom(Π) ∪ body(Π)// set of (dynamic) nogoods// decision level// conflict// learning// backjumping// answer set// decisionbody(Π)) \ (AT ∪ AF), i.e., v must belong to dom(A) and be yet unassigned. Then, σd becomes assigned at the newdecision level dl + 1.Example 4.1. Although we have not yet detailed the subroutines used in Algorithm 1, let us consider a full-fledged com-putation of answer set {b, c, d, e} of Program Π7. To this end, Table 4 shows the current assignment A at different stagesof CDNL-ASP(Π7), where columns provide the value of dl, viz., the current decision level, and the line of Algorithm 1 atwhich particular contents of A and/or some nogood δ are inspected. Note that literals added to A in Line 17 of Algorithm 1are decision literals, not implied by any nogood. Unlike them, each literal added to A in Line 5, that is, within an executionof NogoodPropagation, has some antecedent δ ∈ (cid:5)Π7∪ ∇. Furthermore, we indicate successes of the test for a violatednogood performed in Line 6, and we show the nogood δ to be recorded in ∇ along with the decision level dl to jump backto as returned by ConflictAnalysis when invoked in Line 8.In detail, a computation of CDNL-ASP(Π7) can start by successively picking decision literals Td, F{b, not a}, Tc, andF{not a} at levels 1, 2, 3, and 4, respectively. Observe that there is exactly one decision literal per level, and each decisionis immediately followed by a propagation step, performed before making the next decision. At the start, propagation cannotderive any literals at decision levels 1 and 2, and thus assignment A stays partial. After the third decision, the literalsassigned along with Tc are unit-resulting for respective nogoods δ ∈ (cid:5)Π7 wrt A. Hence, they are added to A at decisionlevel 3. Since A is still partial, decision literal F{not a} is picked at level 4. The following propagation step yields a totalassignment, whose true atoms, viz., a, c, d, and e, belong to a supported model of Π7. However, we have that {d, e} isunfounded for Π7 wrt A, that is, the corresponding loop nogoods λ(d, {d, e}) and λ(e, {d, e}) are violated. Such violationsare detected by NogoodPropagation and, for some unfounded atom, lead to the recording of an associated loop nogoodin ∇. In Table 4, we assume that λ(d, {d, e}) = {Td, F{b, c}, F{b, not a}} is recorded, so that a conflict is encountered inLine 6 of Algorithm 1. Note that F{b, c} is the single literal in λ(d, {d, e}) assigned at decision level 4. Hence, λ(d, {d, e}) isinstantly asserting and returned by ConflictAnalysis in Line 8; the smallest decision level such that, after backjumping,T{b, c} is unit-resulting for λ(d, {d, e}) is 2. The peculiarity that ConflictAnalysis may be launched with an asserting(loop) nogood results from the “unidirectional” propagation of loop nogoods in current ASP solvers (cf. [63,62]). (We furthercomment on this phenomenon in Section 4.4.)Given dl = 2 as level to jump back to, computation proceeds by retracting allliterals added to A at levels 3and 4, while retaining the (decision) literals Td and F{b, not a} assigned at levels 1 and 2. In contrast to the pre-vious visit of decision level 2, the asserting nogood λ(d, {d, e}) in ∇ enables the derivation offurther literals byunit propagation, which results in another conflict, this time on the completion nogood {T{not a}, Ta}. Starting fromit, ConflictAnalysis determines the asserting nogood {F{b, not a}, Td}. As a consequence, CDNL-ASP(Π7) re-turns to decision level 1, where T{b, not a} is unit-resulting for {F{b, not a}, Td}. A final propagation step leads to∪ ∇. (Notably, nogoods in ΛΠ7 are left implicit and testeda total assignment not violating any nogood in (cid:5)Π7within NogoodPropagation via an unfounded set checking subroutine.) The true atoms of the obtained solutionare underlined in Table 4; the associated answer set of Program Π7, {b, c, d, e},is returned as the result of CDNL-ASP(Π7).After the general outline, we below detail the subroutines used in CDNL-ASP computations.62M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89Table 4A computation of answer set {b, c, d, e} with CDNL-ASP(Π7).dl123421ATdF{b, not a}TcT{c, d}TeT{e}F{not a}TaT{a}T{not b}FbF{b, c}F{b, d}F{b, not a}T{b, c}TbTaT{not a}TdT{b, not a}TbFaT{not a}F{not b}F{a}TeT{e}T{b, d}TcT{b, c}T{c, d}δ{F{c, d}, Tc, Td}{Fe, T{c, d}}{F{e}, Te}{F{not a}, Fa}{F{a}, Ta}{Ta, F{not b}}{Tb, F{not a}}{T{b, c}, Fb}{T{b, d}, Fb}{Td, F{b, c}, F{b, not a}}{Td, F{b, c}, F{b, not a}}{Td, F{b, c}, F{b, not a}}{T{b, c}, Fb}{F{b, not a}, Tb, Fa}{Tb, F{not a}}{T{not a}, Ta}{F{b, not a}, Td}{F{b, not a}, Td}{T{b, not a}, Fb}{T{b, not a}, Ta}{Tb, F{not a}}{T{not b}, Tb}{T{a}, Fa}{Fe, T{b, not a}}{F{e}, Te}{F{b, d}, Tb, Td}{Fc, T{b, d}}{F{b, c}, Tb, Tc}{F{c, d}, Tc, Td}= δ({c, d})∈ (cid:5)(e)= δ({e})= δ({not a})= δ({a})= δ(a)= δ(b)∈ (cid:5)({b, c})∈ (cid:5)({b, d})= λ(d, {d, e})dl = 2∈ ∇∈ (cid:5)({b, c})= δ({b, not a})= δ(b)∈ (cid:5)({not a})dl = 1∈ ∇∈ (cid:5)({b, not a})∈ (cid:5)({b, not a})= δ(b)∈ (cid:5)({not b})∈ (cid:5)({a})∈ (cid:5)(e)= δ({e})= δ({b, d})∈ (cid:5)(c)= δ({b, c})= δ({c, d})Line17171755517555555685555685555555555554.2. Nogood propagationOur subroutine for deterministically extending an assignment A is shown in Algorithm 2. It combines unit propagationon completion nogoods in (cid:5)Π and recorded nogoods in ∇ (Lines 3–9) with unfounded set checking (Lines 10–14). Whileunit propagation is always run to a fixpoint (or a conflict), sophisticated unfounded set checks are performed only if theinput program Π is non-tight. In fact, when finishing the loop in Lines 3–9, an assignment A at hand is both atom- andbody-saturated for Π , so that the results in Section 3.2 serve as a basis for demand-driven unfounded set checking. Inparticular, if Π is tight, Theorem 3.11 tells us that all unfounded sets U are already falsified, i.e., U ⊆ AF holds, and thusunit propagation on (cid:5)Π is sufficient to falsify unfounded atoms.Example 4.2. The central idea of integrating unfounded set checking with unit propagation is to make loop nogoods fromΛΠ explicit in ∇ in order to trigger the falsification of unfounded atoms by unit propagation. To see this, consider aprogram Π containing the following rules:x ← y, z,y ← x,z ← y.Let A be an atom-saturated assignment such that U = {x, y, z} is unfounded for Π wrt A and U ∩ (AT ∪ AF) = ∅. Then, wehave that EBΠ (U ) ⊆ AF, so that Fx, F y, and Fz are unit-resulting for λ(x, U ), λ( y, U ), and λ(z, U ), respectively. While neitherof these literals may be unit-resulting for any completion nogood in (cid:5)Π , all of them (along with F{x}, F{ y}, and F{ y, z})are derived by unit propagation when given (cid:5)Π ∪ {λ(x, U )}. That is, when adding only λ(x, U ) to ∇, the whole unfoundedset U is falsified by unit propagation. However, whether the addition of a single loop nogood is sufficient to falsify a wholeunfounded set depends on the structure of Π . For instance, when we augment Π with ( y ← z), the derivation of F y andFz by unit propagation is no longer certain because (circular) supports ( y ← z) and (z ← y) may not be eliminated byassigning x to false. We still derive F{x}, i.e., rule ( y ← x) becomes inapplicable, so that EBΠ ({ y, z}) ⊆ (A ∪ {Fx, F{x}})F. Thisshows that U \ AF = {x, y, z} \ {x} = { y, z} remains as a smaller unfounded set.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8963Algorithm 2: NogoodPropagation.: A decision level dl, a logic program Π , a set ∇ of nogoods, and an assignment A.: An extended assignment and set of nogoods.InputOutput1 U := ∅repeat2 loop345678if δ ⊆ A for some δ ∈ (cid:5)Π ∪ ∇ then return (A, ∇)Σ := {δ ∈ (cid:5)Π ∪ ∇ | δ \ A = {σ }, σ /∈ A}if Σ (cid:7)= ∅ then let σ ∈ δ \ A for some δ ∈ Σ indl(σ ) := dlA := A ◦ σ91011121314until Σ = ∅if loop(Π) = ∅ then return (A, ∇)U := U \ AFif U = ∅ then U := UnfoundedSet(Π, A)if U = ∅ then return (A, ∇)let p ∈ U in ∇ := ∇ ∪ {λ(p, U )}// unfounded set// conflict// unit-resulting nogoods// no unfounded set ∅ ⊂ U ⊆ atom(Π) \ AF// no unfounded set ∅ ⊂ U ⊆ atom(Π) \ AF// record loop nogoodThe observations made in Example 4.2 motivate the strategy of Algorithm 2 to successively falsify the elements of anunfounded set U . At the start, no (non-empty) unfounded set has been determined, and so U is initialized to be emptyin Line 1. Provided that unit propagation in Lines 3–9 finishes without conflict and that Π is non-tight, we remove allfalse atoms from U in Line 11. In the first iteration of the outer loop in Lines 2–14, U stays empty, and the subrou-tine for unfounded set detection (detailed in Section 4.3) is queried in Line 12. The crucial assumption made here is thatUnfoundedSet(Π, A) returns an unfounded set U ⊆ atom(Π) \ AF such that U is non-empty if some non-empty subsetof atom(Π) \ AF is unfounded. Then, we have that EBΠ (U ) ⊆ AF, so that λ(p, U ) \ A ⊆ {Tp} for every p ∈ U . Hence, if anon-empty U is returned, the addition of λ(p, U ) to ∇ for an arbitrary p ∈ U , done in Line 14, yields either a conflict orunit-resulting literal Fp in the next iteration of the loop in Lines 2–14. In the latter case, further literals may be derived andelements of U falsified upon computing the next fixpoint of unit propagation. When we afterwards reconsider the previouslydetermined unfounded set U , the removal of false atoms in Line 11 is guaranteed to result in another (smaller) unfoundedset U \ AF. Hence, if U \ AF is non-empty (checked in Line 12 before computing any further unfounded set), NogoodProp-agation proceeds by adding the next loop nogood to ∇, which as before yields either a conflict or a unit-resulting literal.Thus, once a non-empty unfounded set U has been detected, it is falsified element by element; only after expending allelements of U , a new unfounded set is to be computed. Overall, NogoodPropagation terminates as soon as a conflict isencountered (in Line 4) or with a fixpoint of unit propagation on (cid:5)Π ∪ ∇ such that no non-empty subset of atom(Π) \ AF isunfounded. If Π is tight, the latter is immediately verified in Line 10. Otherwise, the UnfoundedSet subroutine, queriedin Line 12, could not detect any non-empty unfounded set (of non-false atoms) before finishing in Line 13.Example 4.3. To illustrate how NogoodPropagation utilizes nogoods, reconsider the computation of CDNL-ASP(Π7)shown in Table 4. All implied literals, that is, the ones assigned after the decision literal at a level dl, are unit-resulting for∪ ∇ and successively derived by unit propagation. In particular, at decision level 4, the implied literals σnogoods in (cid:5)Π7have antecedents δ ∈ (cid:5)Π7 such that all literals of δ except for σ are already contained in A when σ is assigned. The impactof loop nogoods in ΛΠ7 can be observed on the conflict encountered at decision level 4. Here, we have that U = {d, e} ⊆ ATis unfounded, so that A violates both λ(d, U ) and λ(e, U ). After detecting the unfounded set U and recording λ(d, U ) in ∇,its violation gives rise to leaving NogoodPropagation in Line 4 of Algorithm 2.In summary, our subroutine for propagation interleaves unit propagation with the recording of loop nogoods. The latteris done only if the input program is non-tight and if the falsity of unfounded atoms cannot be derived by unit propa-gation on other available nogoods. Clearly, our approach favors unit propagation over unfounded set computations, whichcan be motivated as follows. For one, unit propagation does not contribute new dynamic nogoods to ∇, so that it is more“economic” than unfounded set checking. For another, although unfounded set detection algorithms (like the one describedbelow) are of linear time complexity, they analyze a logic program in a more global fashion than unit propagation. Whilethe latter investigates only the rules (or nogoods) directly related to literals becoming assigned, unfounded set computationsmay inspect significant parts of a program (or its positive dependency graph) without eventually detecting any non-emptyunfounded set. But given that unfounded set checking (wrt total assignments) is mandatory for soundness and (wrt par-tial assignments) also helps to detect inherent conflicts early, the respective subroutine is nonetheless an integral part ofNogoodPropagation.64M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–894.3. Unfounded set checkingOur unfounded set checking procedure is invoked on a non-tight program Π whenever unit propagation reaches afixpoint without any conflict or formerly computed but yet unfalsified unfounded atoms (cf. Algorithm 2). As a matterof fact, a fixpoint of unit propagation is both atom- and body-saturated for Π . Hence, Corollary 3.12 applies and allowsus to focus on unfounded sets of non-false atoms contained in non-trivial strongly connected components of the positivedependency graph of Π . To this end, for any p ∈ atom(Π), let scc(p) denote the set of atoms belonging to the same stronglyconnected component as p in (atom(Π), (cid:2)+). We say that p is cyclic, if (cid:2)+ ∩ (scc(p) × scc(p)) (cid:7)= ∅ (that is, if there is some+ ∩ scc(p) (cid:7)= ∅), and acyclic otherwise. As a consequence of Proposition 3.9,rule r ∈ Π such that head(r) ∈ scc(p) and body(r)we immediately get that unfounded set checking can concentrate exclusively on cyclic atoms, since only they can belong to(unfounded) loops.7Beyond static information about strongly connected components, our unfounded set detection algorithm makes use ofsource pointers [119] to indicate non-circular supports of atoms. Given a program Π , the idea is to associate every (cyclic)p ∈ atom(Π) with an element of bodyΠ (p) (or one of the special-purpose symbols ⊥ and (cid:15)), denoted by source(p), point-ing to a chain of rules witnessing that p cannot be unfounded. Hence, as long as source(p) remains “intact”, p can beexcluded from unfounded set checks. In this way, source pointers enable lazy, incremental unfounded set checking relativeto recent changes of an assignment. To make sure that still no unfounded set is missed, the following invariants need to beguaranteed:1. For every cyclic p ∈ atom(Π), we require that source(p) ∈ bodyΠ (p) ∪ {⊥}.2. The subgraph of (atom(Π), (cid:2)+) containing every cyclic p ∈ atom(Π) along with edges (q, p) for all q ∈ source(p)+ ∩scc(p) must be acyclic.8For a program Π , we call the collection of links source(p) for all p ∈ atom(Π) a source pointer configuration. We say that asource pointer configuration is valid, if it satisfies the aforementioned invariants. For an appropriate initialization, we definethe initial source pointer configuration for Π by:(cid:2)source(p) =⊥ if p ∈ atom(Π) is cyclic,(cid:15) if p ∈ atom(Π) is acyclic.While (cid:15) expresses that an acyclic atom p does not need to be linked to any element of bodyΠ (p), ⊥ indicates that a non-circular support for a cyclic atom p still needs to be determined. We assume that the initial source pointer configurationfor Π , which is valid by definition, is in place upon an invocation of CDNL-ASP(Π ).Given a program Π and an assignment A, UnfoundedSet, shown in Algorithm 3, starts by collecting non-false (cyclic)atoms p whose source pointers are false (source(p) ∈ AF) or yet undetermined (source(p) = ⊥) in Line 1, as the possibility ofnon-circularly supporting such atoms is in question. In Lines 2–5, this set is successively extended by adding atoms whosesource pointers (positively) rely on it, thus providing the scope S for the second part of unfounded set checking. In fact,the loop in Lines 6–17 aims at re-establishing source pointers for the atoms in S via rules whose bodies do not (positively)rely on S, so that these rules can provide non-circular support. Conversely, if source pointers cannot be re-established, anunfounded set is detected.In more detail, as long as scope S is non-empty, an arbitrary atom p ∈ S is picked in Line 6 of Algorithm 3 as start-ing point for the construction of a non-empty unfounded set U . If EBΠ (U ) ⊆ AF holds in Line 9, the unfounded set Uis immediately returned, so that NogoodPropagation can successively falsify its atoms by unit propagation (cf. Algo-rithm 2). Otherwise, some external body β ∈ EBΠ (U ) \ AF is selected in Line 10 for further investigation. If β+containsatoms in scope S that belong to the same strongly connected component of (atom(Π), (cid:2)+) as the starting point p (checkedin Line 11), we add them to U in Line 16, which makes β non-external wrt the extended set U . On the other hand, ifsuch atoms do not exist in β+, it means that β can non-circularly support all of its associated head atoms q ∈ U . Then,in Lines 12–15, the source pointers of such atoms q are set to β, and the atoms q are removed from both the unfoundedset U under construction and scope S. The described process continues until either U becomes empty (checked in Line 17),in which case the remaining atoms of S are investigated, or a (non-empty) unfounded set U is detected and returned inLine 9. Finally, if scope S runs empty, source pointers could be re-established for all atoms that had been contained in S,and UnfoundedSet returns the empty unfounded set in Line 18.In order to provide further intuitions, let us stress some major design principles of our unfounded set detection algo-rithm:7 Strongly connected components of positive dependency graphs are also exploited by unfounded set checking procedures [119,17,2] of native ASP solversother than clasp. We further discuss relationships to them in Section 7.8 Recall that source(p)+ = {p1, . . . , pm} for a rule body source(p) = {p1, . . . , pm, not pm+1, . . . , not pn}. For special-purpose symbols ⊥ and (cid:15), we let⊥+ = (cid:15)+ = ∅.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8965Algorithm 3: UnfoundedSet.InputOutput: A logic program Π and an assignment A.: An unfounded set of Π wrt A.T := {p ∈ atom(Π) \ (AF ∪ S) | source(p)+ ∩ (scc(p) ∩ S) (cid:7)= ∅}S := S ∪ T1 S := {p ∈ atom(Π) \ AF | source(p) ∈ AF ∪ {⊥}}2 repeat345 until T = ∅6 while S (cid:7)= ∅ do let p ∈ S in789U := {p}repeatif EBΠ (U ) ⊆ AF then return Ulet β ∈ EBΠ (U ) \ AF inif β+ ∩ (scc(p) ∩ S) = ∅ thenforeach q ∈ U such that β ∈ bodyΠ (q) dosource(q) := βU := U \ {q}S := S \ {q}else U := U ∪ (β+ ∩ (scc(p) ∩ S))until U = ∅1011121314151617// initialize scope S// extend scope S// select starting point// unfounded set ∅ ⊂ U ⊆ atom(Π) \ AF// shrink U// extend U18 return ∅// no unfounded set ∅ ⊂ U ⊆ atom(Π) \ AF1. At each stage of the loop in Lines 6–17, all atoms of U belong to scc(p), where p is an atom added first to U (in Line 7).This is because further atoms, added to U in Line 16, are elements of scc(p). (However, U ⊆ scc(p) does not necessarilyimply p ∈ U for a (non-empty) unfounded set U returned in Line 9.)2. At each stage of the loop in Lines 6–17, we have that U ⊆ S, as all atoms added to U in either Line 7 or 16 belong to S.Hence, it holds that q ∈ S whenever source(q) is set to an (external) body β ∈ bodyΠ (q) in Line 13, while β+ ∩ (scc(p) ∩S) = ∅ has been checked before (in Line 11). This makes sure that setting source(q) to β does not introduce any cyclevia source pointers.3. Once detected, a (non-empty) unfounded set U is immediately returned in Line 9, and NogoodPropagation takescare of falsifying all atoms of U before checking for any further unfounded set (cf. Algorithm 2). This reduces over-laps with unit propagation on the completion nogoods in (cid:5)Π , as it already handles unsupported atoms, i.e., singletonunfounded sets (and bodies relying on them).4. The source pointer of an atom q in some unfounded set U returned in Line 9 needs not and is not reset to ⊥. (Infact, source(q) is only set in Line 13 when re-establishing a potential non-circular support for q.) Rather, we admitsource(q) ∈ AF as long as q ∈ AF, derived within NogoodPropagation upon falsifying U . Thus, when Fq becomesunassigned later on (after backjumping), source(q) still allows for lazy unfounded set checking.Example 4.4. Let us illustrate Algorithm 3 on some invocations of UnfoundedSet(Π7, A) made upon the computation ofanswer set {b, c, d, e} of Program Π7 described in Example 4.1. To this end, in Table 5, we indicate stages of Unfound-edSet(Π7, A) when queried wrt fixpoints A of unit propagation at decision levels 0, 2, and 4, respectively. Beforehand,note that scc(c) = scc(d) = scc(e) = {c, d, e}, while a and b are acyclic. Hence, before the first invocation of Unfounded-Set(Π7, A) at decision level 0, we have that source(a) = source(b) = (cid:15) and source(c) = source(d) = source(e) = ⊥. In viewof Line 1 of Algorithm 3, we thus obtain scope S = {c, d, e}. Then, assume that e is picked in Line 6 and added to U in Line 7,and that {c, d} ∈ EBΠ7 ({e}) is selected in Line 10. Since {c, d} ∩ (scc(e) ∩ S) = {c, d}, this makes us augment U with both cand d in Line 16, resulting in an intermediate stage such that U = {c, d, e}. Further assume that {b, not a} ∈ EBΠ7 ({c, d, e})is selected next in Line 10, for which {b} ∩ (scc(e) ∩ S) = ∅ holds in Line 11. Hence, source(e) is set to {b, not a} in Line 13,and e is removed from U and S in Lines 14 and 15, respectively. In the same manner, source(d) and source(c) can in thefollowing iterations of the loop in Lines 8–17 be set to {e} and {b, d}, respectively. Afterwards, we have that U = S = ∅, sothat the empty unfounded set is returned (in Line 18). Given that there is no non-empty unfounded set, no literal is derivedby unit propagation at decision level 0, as also indicated by omitting this level in Table 4.The invocation of UnfoundedSet(Π7, (Td)) at decision level 1 is not shown in Table 5, as it yields an empty scope S.Unlike this, with UnfoundedSet(Π7, (Td, F{b, not a})) at decision level 2, we have that source(e) = {b, not a} ∈ AF, so that+ ∩ S =S = {e} is obtained in Line 1 of Algorithm 3. In Lines 2–5, we successively add d and c to S because source(d){e} ∩ {e} (cid:7)= ∅ and source(c)+ ∩ (S ∪ {d}) = {b, d} ∩ {d, e} (cid:7)= ∅. Afterwards, assume that d is added first to U in Line 7, and thatselecting {b, c} ∈ EBΠ7 ({d}) in Line 10 leads to U = {d} ∪ ({b, c} ∩ (scc(d) ∩ S)) = {c, d}. When investigating {a} ∈ EBΠ7 ({c, d})and again {b, c} ∈ EBΠ7 ({d}) in the next two iterations of the loop in Lines 8–17, we set source(c) to {a} and source(d) to{b, c}, while obtaining U = ∅ and S = {e}. Since S (cid:7)= ∅, another iteration of the loop in Lines 6–17 adds e to U and thenremoves it from U and S along with setting source(e) to {c, d}. Given U = S = ∅, we again get the empty unfounded set asresult.66M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89Table 5Runs of UnfoundedSet(Π7, A) upon a computation of answer set {b, c, d, e}.dl024source(p)source(e)source(d)source(c)F{b, not a}{e}{b, d}source(c)source(d)source(e)F{b, c}{c, d}S{c, d, e}{c, d, e}{c, d, e}{c, d}{c}∅{e}{d, e}{c, d, e}{c, d, e}{c, d, e}{d, e}{e}{e}∅{d}{d, e}{d, e}{d, e}U{e}{c, d, e}{c, d}{c}∅{d}{c, d}{d}∅{e}∅{e}{d, e}β ∈ EBΠ7 (U ) \ AFLine{c, d}{b, not a}{e}{b, d}{b, c}{a}{b, c}{c, d}{c, d}1716131313144716131371314716At decision level 3, unfounded set checking is without effect because, as shown in Table 4, no rule body and, in particular,no source pointer is falsified. However, at decision level 4, we have that source(d) = {b, c} ∈ AF, and thus we get S = {d} inLine 1 of Algorithm 3. In an iteration of the loop in Lines 2–5, we further add e to S because source(e)+ ∩ S = {c, d} ∩ {d} (cid:7)= ∅,while c stays unaffected in view of source(c) = {a} /∈ AF. After adding e to U in Line 7, U is further extended to {d, e} inLine 16, given that {c, d} ∈ EBΠ7 ({e}) and {c, d} ∩ (scc(e) ∩ S) = {d}. We have now obtained U = {d, e}, and it holds thatEBΠ7 ({d, e}) = {{b, c}, {b, not a}} ⊆ AF. That is, the termination condition in Line 9 applies, and UnfoundedSet(Π7, A)returns the (non-empty) unfounded set {d, e}.To conclude the example, in Table 4, we observe that adding loop nogood λ(d, {d, e}) = {Td, F{b, c}, F{b, not a}} to ∇ leadsto a conflict at decision level 4. After backjumping to decision level 2, NogoodPropagation encounters a conflict beforeinvoking UnfoundedSet(Π7, A). Hence, UnfoundedSet(Π7, A) is only queried again wrt the total assignment A de-rived by unit propagation after returning to decision level 1. In view of source(c) = {a} ∈ AF, this final invocation (not shownin Table 5) makes us reset source pointers as follows: source(e) = {b, not a}, source(d) = {e}, and source(c) = {b, d} (likeat decision level 0). As this yields only the empty unfounded set (of non-false atoms), NogoodPropagation terminateswithout conflict, and CDNL-ASP(Π7) returns answer set {b, c, d, e} of Π7.Note that a non-empty unfounded set U returned in Line 9 of Algorithm 3 is, in general, not guaranteed to be a loopin the sense of [90]. However, Theorem 3.11 tells us that U contains some loop L that is unfounded. One or several suchloops L could a posteriori be extracted from U , for which purpose any of the approaches in [90,71,91,2,59] can in principlebe applied.4.4. Conflict analysisFinally, we turn to the subroutine for conflict analysis, whose purpose is to determine an asserting nogood, so that someliteral is unit-resulting after backjumping. To this end, it resolves a violated nogood δ ⊆ A against some antecedent ε of animplied literal σ ∈ δ (that is, a nogood ε such that ε \ A[σ ] = {σ }) for obtaining a new violated nogood (δ \ {σ }) ∪ (ε \ {σ }).Iterated resolution proceeds in inverse order of assigned literals, resolving first over the literal σ ∈ δ assigned last in A, viz.,δ \ A[σ ] = {σ }, and stops as soon as δ contains exactly one literal, called Unique Implication Point (UIP; [97]), that has beenassigned at the decision level where the conflict is encountered. The effectiveness of this approach, referred to as First-UIPscheme (cf. [127,35,96]), has in the area of SAT been demonstrated both empirically [127,115,29] and analytically [109].Despite small peculiarities (discussed below Example 4.5), the First-UIP scheme can be applied unaltered in conflict-drivenASP solving. However, identifying antecedents of implied literals is less straightforward than with clauses. For instance, notethat our subroutine for propagation in Algorithm 2 records a priori implicit loop nogoods from ΛΠ to make sure that everyimplied literal has some antecedent in (cid:5)Π ∪ ∇.Conflict resolution according to the First-UIP scheme is performed by ConflictAnalysis, shown in Algorithm 4. Infact, the loop in Lines 1–7 proceeds by resolving over the literal σ of the violated nogood δ assigned last in A (giventhat δ \ A[σ ] = {σ } is required in Line 2) until the assertion level [23], that is, the greatest level dl(ρ) associated withliterals ρ ∈ δ \ {σ }, is different from and actually smaller than dl(σ ). If so, nogood δ and assertion level k (determined inLine 3) are returned in Line 7; since δ ⊆ A, we have that σ is unit-resulting for δ after backjumping to decision level k.Otherwise, if k = dl(σ ), σ is an implied literal, so that some antecedent ε ∈ (cid:5)Π ∪ ∇ of σ can be chosen in Line 5 andM. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8967Algorithm 4: ConflictAnalysis.InputOutput: A violated nogood δ, a logic program Π , a set ∇ of nogoods, and an assignment A.: A derived nogood and a decision level.1 loop23456let σ ∈ δ such that δ \ A[σ ] = {σ } ink := max({dl(ρ) | ρ ∈ δ \ {σ }} ∪ {0})if k = dl(σ ) thenlet ε ∈ (cid:5)Π ∪ ∇ such that ε \ A[σ ] = {σ } inδ := (δ \ {σ }) ∪ (ε \ {σ })// resolution7else return (δ, k)Table 6Run of ConflictAnalysis({T{not a}, Ta}, Π7, ∇, A) at decision level 2.δ{ T{not a} ,Ta}{ Ta ,Tb}{ Tb ,F{b, not a}}{ T{b, c} ,F{b, not a}}{ F{b, not a} ,Td}ε{Tb, F{not a} }{F{b, not a}, Tb, Fa }{T{b, c}, Fb }{Td, F{b, c} ,F{b, not a}}used for resolution against δ in Line 6. Note that there may be several antecedents of σ in (cid:5)Π ∪ ∇, and thus the choiceof ε in Line 5 is, in general, non-deterministic (cf. [32]). Regarding the termination of Algorithm 4, note that a decisionliteral σd (cf. Algorithm 1) is the first literal in A at its (positive) level dl(σd), and σd is also the only literal at dl(σd) that isnot implied. Given that ConflictAnalysis is only applied to nogoods violated at decision levels beyond 0, all conflictresolution steps are well-defined and stop at latest at a decision literal σd. However, resolving up to σd can be regardedas worst case because the First-UIP scheme aims at few resolution steps to obtain a nogood that is “close” to a conflict athand.Example 4.5. To illustrate Algorithm 4, let us inspect the resolution steps shown in Table 6. They are applied when resolvingthe violated nogood {T{not a}, Ta} against the antecedents shown in Table 4 upon analyzing the conflict encountered atdecision level 2 in the computation of CDNL-ASP(Π7) described in Example 4.1. The literal σ of a violated nogood δassigned last in A as well as its complement σ in an antecedent ε of σ are surrounded by a box in Table 6, and furtherliterals assigned at decision level 2 are underlined. The result of iterated resolution, {F{b, not a}, Td}, contains F{b, not a} asthe single literal assigned at decision level 2, while Td has been assigned at assertion level 1. In this example, the first UIPF{b, not a} happens to be the decision literal at level 2.In general, a first UIP is not necessarily a decision literal, as it can for instance be observed on UIP F{b, c} in the as-serting nogood {Td, F{b, c}, F{b, not a}} returned by ConflictAnalysis at decision level 4 in Example 4.1. Also recallthat λ(d, {d, e}) = {Td, F{b, c}, F{b, not a}} served as starting point for ConflictAnalysis, containing a (first) UIP with-out requiring any resolution step. This phenomenon is due to “unidirectional” propagation of loop nogoods, given thatunfounded set checks (cf. Algorithm 3) merely identify unfounded atoms, but not rule bodies that must necessarily holdfor (non-circularly) supporting some true atom. In Example 4.1, the fact that T{b, c} is required from decision level 2 on isonly recognized at level 4, where assigning F{b, c} leads to a conflict. In view of this, Algorithm 3 can be understood as achecking routine guaranteeing the soundness of CDNL-ASP, while its inference capabilities do not match (full) unit propa-gation on loop nogoods. Similar observations have already been made in [63,62], but more powerful yet efficient reasoningmechanisms for unfounded set handling seem to be difficult to develop; for instance, the approach suggested in [18,19] iscomputationally too complex (quadratic) to be beneficial in practice.Despite of the fact that conflict resolution in ASP can be done in the same fashion as in SAT, the input format oflogic programs makes it less predetermined. For one, the completion nogoods in (cid:5)Π contain rule bodies as structuralvariables for the sake of succinct representation. For another, the number of (relevant) inherent loop nogoods in ΛΠ maybe exponential [88]. Fortunately, the satisfaction of ΛΠ can be checked in linear time (e.g., via Algorithm 3), so that anexplicit representation of its elements is not required. However, NogoodPropagation (cf. Algorithm 2) records loopnogoods from ΛΠ that are antecedents to make them easily accessible in ConflictAnalysis.Alternatives in the representation of constraints induced by a logic program become apparent when considering tradi-tional ASP solvers, such as dlv [83] and smodels [119], where assignments are (logically) identified with interpretations overatoms. In order to augment smodels with conflict-driven learning, smodelscc [126] pursues an algorithmic approach to extractantecedents (over atoms) relative to smodels’ inference rules. In our setting, one may restrict heuristic decisions in Line 14of Algorithm 1 to atoms for mimicking an “atom-only” approach where truth values of rule bodies are determined by their68M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89literals. However, when ConflictAnalysis remains unaltered, its asserting nogoods may still enable unit propagationto derive the falsity of bodies without (known) false body literals (or associated false head atoms), which cannot occur withatom-based approaches. To ultimately avoid such inferences, one would need to unconditionally eliminate literals over bod-ies from conflict nogoods by resolution against their antecedents, which is possible when heuristic decisions are restrictedto atoms. This idea comes close to the learning technique of smodelscc , breaking derivations relying on bodies down to theircontained literals. Although such “body elimination” may enable learning on top of atom-based approaches, it still goesalong with exponentially increased (best-case) complexity, independent of and thus irreparable by conflict-driven nogoodlearning [62].4.5. Soundness and completeness of CDNL-ASP algorithmIn what follows, we elaborate upon the formal properties of the provided algorithms. Generally speaking, soundnesswrt the decision problem of answer set existence is obtained from the fact that NogoodPropagation and Conflict-Analysis exploit and possibly tighten available knowledge, but do not draw incorrect conclusions. In the course of this,UnfoundedSet performs a sufficient amount of work to distinguish answer sets from (inadmissible) circularly supportedmodels. The completeness of CDNL-ASP follows from the observation that its subroutines cannot loop infinitely along withthe fact that conflict-driven assertions relocate variables to smaller decision levels than before, which guarantees termination(cf. [128,115]).To begin with, we consider crucial properties of UnfoundedSet in Algorithm 3. First, we have that (positive) depen-dencies through source pointers are inherently acyclic.Lemma 4.1. Let Π be a logic program and A an assignment that is body-saturated for Π .If UnfoundedSet(Π, A) is invoked on a valid source pointer configuration, then we have that the source pointer configurationremains valid throughout the execution of UnfoundedSet(Π, A).The above property holds because potential non-circular supports for atoms in β+must already be established before asource pointer can be set to a body β in Line 13 of Algorithm 3. In particular, the atoms of β+contained in an investigatedstrongly connected component of (atom(Π), (cid:2)+) must not belong to scope S, comprising potentially unfounded atoms. Infact, the following result shows that all “interesting” unfounded sets, namely, unfounded loops, are part of S; conversely,atoms outside S cannot belong to an unfounded loop.Lemma 4.2. Let Π be a logic program and A an assignment that is atom-saturated for Π .If UnfoundedSet(Π, A) is invoked on a valid source pointer configuration, then we have that every unfounded set U ⊆atom(Π) \ AF of Π wrt A such that all p ∈ U belong to the same strongly connected component of (atom(Π), (cid:2)+) is containedin S whenever Line 6 of Algorithm 3 is entered.The previous lemmas along with Corollary 3.12 can now be combined to, essentially, establish the completeness ofAlgorithm 3.9Theorem 4.3. Let Π be a logic program and A an assignment that is both atom- and body-saturated for Π .If UnfoundedSet(Π, A) is invoked on a valid source pointer configuration, then we have that UnfoundedSet(Π, A) returnsan unfounded set U ⊆ atom(Π) \ AF of Π wrt A, where U = ∅ iff there is no unfounded set Uof Π wrt A such that U(cid:16)(cid:16) (cid:2) AF.After considering unfounded set detection, we now turn to NogoodPropagation in Algorithm 2. The next lemma isstraightforward yet helpful, as it assures the prerequisites of demand-driven unfounded set checking, mainly focusing onunfounded loops.Lemma 4.4. Let Π be a logic program, ∇(cid:16)a set of nogoods, dl ∈ N, and A(cid:16)an assignment.Then, we have that A is both atom- and body-saturated for Π whenever Line 10 of Algorithm 2 is entered in an execution ofNogoodPropagation(dl, Π, ∇(cid:16), A(cid:16)).The following properties are essential for ConflictAnalysis to be well-defined as well as the soundness and com-pleteness of CDNL-ASP.Lemma 4.5. Let Π be a logic program, ∇(cid:16)a set of nogoods, dl ∈ N, and A(cid:16)an assignment.If NogoodPropagation(dl, Π, ∇(cid:16), A(cid:16)) is invoked on a valid source pointer configuration, then we have that NogoodProp-agation(dl, Π, ∇(cid:16), A(cid:16)) returns a pair (A, ∇) such that9 Soundness, viz., the property that any set U returned by UnfoundedSet is indeed unfounded, is obvious in view of the test in Line 9 of Algorithm 3and the fact that ∅, which can be returned in Line 18, is trivially unfounded.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89691. ∇(cid:16) ⊆ ∇ ⊆ ∇(cid:16) ∪ ΛΠ ;2. A is an assignment such that A3. δ ⊆ A for some δ ∈ (cid:5)Π ∪ ∇ if λ(p, U ) ⊆ A for some λ(p, U ) ∈ ΛΠ .(cid:16) ⊆ A and every σ ∈ A \ A(cid:16)is implied by (cid:5)Π ∪ ∇ wrt A;The first item expresses that only loop nogoods can possibly be added by NogoodPropagation, viz., in Line 14 ofAlgorithm 2 (provided that Π is non-tight). In view of Theorem 3.7, this makes sure that the recorded nogoods do noteliminate any answer set of Π . The second item states that any literal assigned within NogoodPropagation has someantecedent, which can (later on) be used for conflict resolution. Finally, the third item exploits Theorem 4.3 and Lemma 4.4to establish that violations of (loop) nogoods cannot stay undetected.Regarding ConflictAnalysis in Algorithm 4, the next lemma states that its derived nogoods are asserting and en-tailed by the nogoods that are already given.Lemma 4.6. Let Π be a logic program, ∇ a set of nogoods, A an assignment such that {σ ∈ A | ρ ∈ A[σ ], dl(σ ) < dl(ρ)} = ∅ and {σ ∈A | ρ ∈ A[σ ], dl(ρ) = dl(σ )} ⊆ {σ ∈ A | ε ∈ (cid:5)Π ∪ ∇, ε \ A[σ ] = {σ }}, and δ(cid:16) ⊆ A such that m = max({dl(σ ) | σ ∈ δ(cid:16)} ∪ {0}) (cid:7)= 0.Then, we have that ConflictAnalysis(δ(cid:16), Π, ∇, A) returns a pair (δ, k) such that1. δ ⊆ A;2. |{σ ∈ δ | k < dl(σ )}| = 1;3. δ (cid:2) B for any solution B for (cid:5)Π ∪ ∇ ∪ {δ(cid:16)}.The above prerequisites regarding ∇, A, and δ(cid:16)stipulate the existence of antecedents for all but the first literal assignedat decision level m > 0. These conditions are guaranteed by CDNL-ASP, as it increments dl in Line 15 of Algorithm 1before assigning a decision literal (without antecedent) in Line 17, and as conflicts are analyzed only if encountered beyonddecision level 0.After inspecting the subroutines of CDNL-ASP, important invariants of assignments and nogoods generated by CDNL-ASP can be summarized as follows.Lemma 4.7. Let Π be a logic program.Then, we have that the following holds whenever Line 5 of Algorithm 1 is entered in an execution of CDNL-ASP(Π ):1. ∇ is a set of nogoods such that δ (cid:2) B for every δ ∈ ∇ and any solution B for (cid:5)Π ∪ ΛΠ ;2. A is an assignment such that {σ ∈ A | ρ ∈ A[σ ], dl(σ ) < dl(ρ)} = ∅ and {σ ∈ A | dl(σ ) (cid:2) max({dl(ρ) | ρ ∈ A[σ ]} ∪ {0})} ⊆{σ ∈ A | ε ∈ (cid:5)Π ∪ ∇, ε \ A[σ ] = {σ }};3. dl ∈ N is such that δ (cid:2) {σ ∈ A | dl(σ ) < dl} for every δ ∈ (cid:5)Π ∪ ΛΠ ∪ ∇.Given that only the (implied) literals belonging to the current assignment A require antecedents for the second invariantto hold, dynamic nogoods in ∇ that are not antecedents may optionally be deleted. This yields polynomial space complexityof CDNL-ASP because the number of (required) antecedents is bounded by the maximum number of assigned literals, viz.,|atom(Π) ∪ body(Π)|. In practice, nogood deletion (cf. [72,35]) is an important technique preventing conflict-driven learningsolvers from blowing up in space.Finally, the above results allow for deriving the soundness and completeness of CDNL-ASP.Theorem 4.8. Let Π be a logic program.Then, we have that CDNL-ASP(Π ) terminates, and it returns an answer set of Π iff Π has some answer set.Soundness wrt the decision problem of answer set existence follows from the observations made above, namely, thatviolated loop nogoods are detected and that nogoods added by NogoodPropagation or derived by ConflictAnaly-sis are entailed. The completeness of CDNL-ASP, viz., the fact that it is a decision procedure, is due to its termination.Notably, arguments for the termination of CDCL (cf. [128,115]) also apply to CDNL-ASP, given that both search proceduresmake use of conflict-driven assertions to exclude repetitions of assignments.5. The clasp systemOur approach to conflict-driven ASP solving is implemented in clasp [54,52,56], combining the high-level modeling ca-pacities of ASP with state-of-the-art Boolean constraint solving techniques. The solver clasp is freely available as an opensource package at [110] and distributed under GNU general public license.The clasp system is originally designed and optimized for conflict-driven ASP solving, as described in Section 4. Tothis end, it features a number of sophisticated reasoning and implementation techniques, some specific to ASP and othersborrowed from CDCL-based SAT solvers. Moreover, clasp can be used as a full-fledged SAT, MaxSAT, or PB solver, acceptingpropositional CNF formulas in (extended) dimacs format as well as PB formulas in opb format. The flexibility of input formats,70M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89reasoning modes (cf. Section 5.2), and tuning parameters (cf. Section 5.4) supported by clasp goes well beyond the marginsof typical ASP or SAT solvers. This section, however, is primarily devoted to ASP solving, describing the main features ofclasp. Albeit the theoretical considerations in Section 4 concentrated on normal logic programs, one such feature is clasp’sability to treat extended rules [119] intrinsically (without a priori compilation), supporting choice constructs in rule headsas well as cardinality and weight constraints in rule bodies. While the nogoods stemming from normal programs, describedin Section 3, can be represented by clauses, clasp also includes dedicated data structures for dealing with linear inequalitiesobtained from extended programs or PB formulas. In order to give a comprehensive overview about the functionalitiesprovided by clasp, we below discuss also such features.5.1. Interfaces and preprocessingFor ASP solving, clasp reads propositional logic programs (without proper disjunctions in rule heads) in lparse for-mat [120], provided by either lparse [120] or gringo [51]. Choice rules as well as cardinality and weight constraints (cf.[119,120]) are either compiled into normal rules during parsing, configurable via option -trans-ext, or dealt with in anintrinsic fashion (by default; see Section 5.3 for details).At the beginning, a logic program is subject to extensive preprocessing [55]. The idea is to simplify the program whileidentifying equivalences among its relevant constituents. These equivalences are then used for building a compact programrepresentation (in terms of Boolean constraints). Logic program preprocessing is configured via option -eq, taking an integervalue fixing the number of iterations. Once a program has been transformed into Boolean constraints, they can be subjectto further preprocessing, primarily based on resolution [33]. Such SatELite-like preprocessing is invoked with option -sat-prepro and further parameters. However, care must be taken when adapting techniques from SAT because preprocessingmust not eliminate variables that are relevant to unfounded set checking or that occur in extended rules and optimizationstatements.A major yet internal feature of clasp is that it can be used in a stateful way. That is, clasp may keep its state, involvingprogram representation, recorded nogoods, heuristic values, etc., and be invoked under additional (temporary) assumptionsand/or by adding new atoms and rules. The corresponding interfaces are fundamental for supporting incremental ASP solvingas realized in iclingo [46], a combination of gringo and clasp for incremental grounding and solving. Furthermore, solvingunder assumptions [34] is used in our parallel ASP solver claspar [37,118,50].5.2. Reasoning modesAlthough clasp’s primary use case is the computation of answer sets, it also allows for computing supported models of alogic program via option -supp-models.10 In addition, clasp provides a number of reasoning modes, determining how toproceed when a model is found.Enumeration Solution enumeration is non-trivial in the context of backjumping and conflict-driven learning. A simple ap-proach relies on recording solutions as nogoods and exempting them from deletion. Although clasp supports this via option-solution-recording, it is prone to blow up in space in view of an exponential number of solutions (in the worstcase). Unlike this, the default enumeration algorithm of clasp runs in polynomial space [53]. Both enumeration approachesalso allow for projecting models to a subset of atoms [57], invoked with -project and configured via the well-known di-rectives #hide and #show of lparse and gringo. This option is of great practical value whenever one faces overwhelminglymany models, involving solution-irrelevant variables having proper combinatorics. For example, the program consisting ofthe choice rule {a,b,c}. has eight (obvious) answer sets. When augmented with directive #hide c., still eight solutionsare obtained, yet including four duplicates. Unlike this, invoking clasp with -project yields only four answer sets differingon a and/or b.As regards implementation, it is interesting to note that clasp offers a dedicated interface for enumeration. This allowsfor abstracting from how to proceed once a model is found and thus makes the search algorithm independent of theconcrete enumeration strategy. Further reasoning modes implemented via the enumeration interface admit computing theintersection or union of all answer sets of a program (via -cautious and -brave, respectively). Rather than computingthe whole collection of (possibly) exponentially many answer sets, the idea is to compute a first answer set, record aconstraint eliminating it from further solutions, then compute a second answer set, strengthen the constraint to representthe intersection (or union) of the first two answer sets, and to continue like this until no more answer set is obtained. Thisprocess involves computing at most as many answer sets as there are atoms in an input program. Either the cautious or thebrave consequences are then given by the atoms captured by the final constraint.Optimization As common in lparse-like languages, an objective function is specified via a sequence of #minimize or#maximize statements. For finding optimal solutions, clasp offers several options. First, the objective function can be ini-tialized via -opt-value. Second, clasp allows for computing one or all (via -opt-all) optimal solutions. Such options10 To be more precise, option -supp-models disables unfounded set checking. Sometimes, the grounder or preprocessing may already eliminate somesupported models such that they cannot be recovered later on.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8971are useful when one is interested in computing consequences belonging to all optimal solutions (in combination with-cautious). To this end, one starts with searching for an (arbitrary) optimal answer set and then re-launches clasp bybounding its search with the obtained optimum. Doing the latter with -cautious yields the atoms that belong to alloptimal answer sets. On application problems, option -restart-on-model, making clasp restart after each (putativelyoptimal) solution, turned out to be effective for ameliorating convergence to an optimum. Particular strategies for lexi-cographic optimization [48], available in clasp series 2, serve the same purpose, especially on large and underconstrainedmulti-criteria optimization problems. Moreover, option -opt-heu can be used to alter sign selection (see below) towardsa better objective function value. Optimization is implemented via the aforementioned enumeration interface. When a so-lution is found, an optimization constraint is updated with the corresponding objective function value. Then, the decisionlevel violating the constraint is identified and retracted, or if the constraint is violated at decision level 0, search terminates.It is also worth mentioning that clasp propagates optimization constraints, that is, they can imply (and provide reasonsfor) literals upon unit propagation. Finally, when optimization is actually undesired and all solutions ought to be inspectedinstead, option -opt-ignore is available to make modifying the input (by removing optimization statements) obsolete.5.3. Propagation and searchPropagation in clasp relies on an interface called Boolean constraint; it is thus not limited to (clausal representations of)nogoods (cf. [35]). However, dedicated data structures are used for binary and ternary nogoods (cf. [115]), accounting forthe many short nogoods stemming from Clark completion. More complex constraints are accessed via two watch lists foreach variable, storing the Boolean constraints that need to be updated when the variable becomes true or false, respectively.While unit propagation of long nogoods is based on the well-known two-watched-literal data structure [101], a counter-based approach is used for propagating cardinality and weight constraints [47]. A literal implied by a Boolean constraintupon unit propagation stores a reference to that constraint, which in turn can be queried for an antecedent.During unit propagation, binary nogoods are handled before ternary ones, which are in turn inspected before otherBoolean constraints. As detailed in Algorithm 2, our propagation procedure is distinct in giving a clear preference to unitpropagation over unfounded set computations. Unfounded set detection follows Algorithm 3 and aims at small, rather thangreatest, unfounded sets. As detailed in [47], intrinsic treatment of cardinality and weight constraints augments unfoundedset detection by means of source pointers, still aiming at lazy unfounded set checking. The representation of loop nogoodsis controlled via option -loops. In the default setting, loop nogoods are generated for individual unfounded atoms, asshown in Algorithm 2. Like nogoods derived from conflicts, they are subject to unit propagation and deletion. However,when -loops=no is specified, loop nogoods are stored only as long as they serve as antecedents of falsified unfoundedatoms.Decision heuristics The primary decision heuristics of clasp use look-back strategies derived from corresponding CDCL-based approaches in SAT, viz., vsids [101], berkmin [72], and vmtf [115]. Such heuristics privilege variables involved in recentconflicts. To this end, they maintain an activity score for each variable, increased upon conflict resolution and decayed peri-odically. The major difference between the approaches of vsids and berkmin lies in the scope of variables considered duringdecision making. While vsids selects a free variable that is globally most active, berkmin restricts the selection to variablesbelonging to the most recently recorded yet undispelled dynamic nogood. Although the look-back heuristics implemented inclasp are modeled after the corresponding CDCL-based approaches, clasp optionally also scores variables contained in loopnogoods. In case of berkmin, it may also select a free variable belonging to a recently recorded loop nogood. Finally, we notethat clasp’s heuristic can also be based upon look-ahead strategies extending unit propagation by failed-literal detection [42].This makes sense when running clasp without conflict-driven nogood learning, operating similar to smodels.Once a decision variable has been selected, a sign heuristic decides about its truth value. The main criterion for look-back heuristics is to satisfy the greatest number of conflict nogoods, that is, to pick the literal that occurs in fewer of them.Initially and also for tie-breaking, clasp does sign selection based on the type of a variable: atoms are preferably set tofalse, while bodies are made true. This aims at maximizing the number of resulting implications. Another sign heuristicimplemented in clasp is progress saving [107]. The idea is to remember truth values of retracted variables upon backjumping(or restarting), except for those assigned at the last decision level. These saved values are then used for sign selection.The intuition behind this strategy is that the literals assigned prior to the last decision level did not lead to a conflict andmay have satisfied some subproblem. Hence, re-establishing them may help to avoid solving subproblems multiple times.Progress saving is invoked with option -save-progress; its computational impact, however, depends heavily on thestructure of an application at hand (cf. Section 5.4).Restart policies The robustness of clasp is boosted by multiple restart strategies (cf. [74]), namely, geometric, fixed-interval,Luby-style, or a nested policy. The first two start with an initial number of conflicts after which clasp restarts; this thresholdcan then be increased after each restart. The third policy, going back to Luby, Sinclair, and Zuckerman [92], schedulesrestarts according to a recurrent and progressively growing sequence of numbers of conflicts, e.g., 32 32 64 32 32 64128 32 . . . for unit 32. In addition, the nested policy first used in picosat [11] is also offered by clasp. This policy takesthree parameters, x, y, and z, and makes restarts follow a two-dimensional pattern that increases geometrically in bothis repeated when it reaches an outer limit z ∗ y j , where i counts thedimensions. The geometric restart sequence x ∗ yi72M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89number of performed restarts and j how often the outer limit was hit so far. Usually, restart strategies are based on the totalnumber of encountered conflicts. Beyond that, clasp features local restarts [116]. Here, one counts the number of conflictsper decision level in order to measure the difficulty of subproblems locally. Furthermore, a bounded approach to restarting(and backjumping) is used when enumerating answer sets as described in [53]. To complement its more determined search,clasp also allows for initial randomized runs [35], typically with a small restart threshold, in the hope to extract putativelyinteresting nogoods. Finally, it is worth noting that, despite of the fact that recent SAT solvers use rather aggressive restartstrategies (cf. Section 5.4), clasp still defaults to a more conservative geometric policy (cf. [35]) because it performs betteron ASP-specific benchmarks.Nogood deletion To limit the number of nogoods stored simultaneously, dynamic nogoods are periodically subject todeletion. Complementing look-back heuristics, clasp’s nogood deletion strategy associates an activity with each recordednogood, which is incremented whenever the nogood is used for conflict resolution. Borrowing ideas from minisat [35] andberkmin [72], the initial threshold on the number of stored nogoods is calculated from the size of an input program andincreased by a certain factor upon each restart. As soon as the current threshold is exceeded, deletion is initiated andremoves up to 75% of the recorded nogoods. Nogoods that are currently locked (because they serve as antecedents) orwhose activities significantly exceed the average activity are exempt from deletion. However, the nogoods that are notdeleted have their activities decayed in order to account for recency of usage. All in all, clasp’s nogood deletion strategyaims at limiting the overall number of stored nogoods, while keeping the relevant and recently recorded ones. This likewiseapplies to conflict and loop nogoods.5.4. Fine-tuningAdvanced Boolean constraint solving technology adds a multitude of degrees of freedom to ASP solving. Currently, clasphas about 40 options, half of which control the search strategy. Although considerable efforts were taken to find defaultparameters jointly boosting robustness and speed, the default setting still leaves room for drastic improvements on specificbenchmarks by fine-tuning the parameters. The question then arises how to deal with this vast “configuration space” andhow to conciliate it with the idea of declarative problem solving. Currently, there seems to be no alternative to manualfine-tuning when addressing highly demanding applications.As rules of thumb, we usually start by investigating the following options:-heuristic: Try vsids instead of clasp’s default berkmin-style heuristic.-trans-ext: Applicable if a program contains extended rules, that is, rules including cardinality and weight constraints.Try at least the dynamic transformation.-sat-prepro: Resolution-based preprocessing (as in SatELite [33]) works best on tight programs with few cardinality andweight constraints. It should almost always be used when extended rules are transformed into normal ones (via-trans-ext).-restarts: Try aggressive restart policies, like Luby-256 or the nested policy, or try disabling restarts whenever a problemis deemed to be unsatisfiable.-save-progress: Progress saving typically works nicely when the average backjump length (or the #choices/#conflictsratio) is high ((cid:3)10). It usually performs best in combination with aggressive restarts.The impact of fine-tuning can be seen on the following examples. As observed in [78], clasp times out on satisfiable 4-coloring problems. However, with -save-progress, clasp solves each instance in about a second (the average backjumplength is >60). For another example, consider the benchmark class WeightBoundedDomSet from the second ASP compe-tition [28]. The default configuration of clasp results in timeouts (see next section), all of which vanish once aggressiverestarts are used. Similar effects can be observed on application problems featuring yet different characteristics.Although fine-tuning may greatly improve the efficiency of clasp, it is hard to accomplish for an unpracticed user, andafter all it takes us away from the ideals of declarative problem solving. To this end, we advocate an extension of clasp,called claspfolio [49], that maps benchmark features to solver configurations (via machine learning techniques). It is part ofour ongoing work to investigate how far the selection of effective parameter settings can be automated.6. Experimental resultsWe conducted experiments on NP decision problems of the second ASP competition [28], using encodings by thePotassco team.11 Our comparison considers clasp (version 1.3.1) in its default setting as well as a setting suited better+, invokes clasp with options -sat-prepro and -trans-for the benchmarks in focus. The latter, denoted by claspext=dynamic, using SatELite-like preprocessing [33] on nogoods as well as a context-dependent handling of extended11 See http://dtai.cs.kuleuven.be/events/ASP-competition/SubmittedBenchmarks.shtml for detailed descriptions of benchmark classes as well as http://dtai.cs.kuleuven.be/events/ASP-competition/encodings.shtml for benchmark instances and encodings.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8973rules, excluding “small” extended rules from an intrinsic treatment (cf. [47]) and rather transforming them into normal rules.For comparison, we also consider cmodels (version 3.79 with minisat 2.0), smodels (version 2.34 with option -restart),and lp2sat (version 1.13 with minisat 2.0 or clasp 1.3.1).12 For cmodels and lp2sat, we below indicate the use of either minisator clasp as underlying SAT solver by adding “[m]” or “[c]”, respectively. The experiments were run sequentially under Linuxon an Intel Quad-Core Xeon E5520 machine equipped with 2.27 GHz processors. Every benchmark instance (in lparse outputformat [120], generated offline with gringo) was run three times per solver, each run restricted to 600 seconds time and2 GB RAM. A run finished when the solver found an answer set, reported unsatisfiability (no answer set), or was aborteddue to time or memory exhaustion.SAT-based solver cmodels converts a logic program into propositional clauses via Clark completion and delegates thesearch for supported models to minisat. Except for the treatment of extended rules, this approach is comparable to claspon tight programs. In the non-tight case, cmodels delays (sophisticated) unfounded set checks until an assignment is total,while clasp and smodels integrate them into propagation. In fact, smodels is a “traditional” ASP solver using a search patternbased on systematic backtracking along with an unfounded set checking procedure computing greatest unfounded sets.Finally, lp2sat like cmodels converts a logic program into propositional clauses and delegates the search for a model to someSAT solver. On tight programs, lp2sat’s translation amounts to Clark completion, while level mappings [76,103] are used tocapture non-circular derivability of atoms from non-tight programs. Among the solvers accepting lparse output format, ourexperiments include the ones that were leading in the NP decision category of the second ASP competition (cf. [28]).13 Inparticular, lp2sat has an edge on lp2diff [78], which applies a translation to difference logic and solvers for SatisfiabilityModulo Theories (SMT; [10]) as search back-ends, on the investigated benchmarks [77].Our experimental results are summarized in Tables 7–9, giving average runtimes in seconds and numbers of abortedruns (in parentheses) for every solver on each benchmark class, with time or memory exhaustions taken as 600 seconds.More detailed benchmark results, including individual times for all instances as well as further solver configurations, areprovided at [22]. While Table 7 considers all benchmarks, divided into tight and non-tight ones, Tables 8 and 9 analogouslyreport results restricted to satisfiable and unsatisfiable instances, respectively. Each table gives the number of instances perbenchmark class in the column headed by “#”. In addition, Table 7 provides the respective partition into satisfiable and un-satisfiable instances (in parentheses). The last column amounts to the virtual best solver, composed of the smallest runtimeand the smallest number of aborts observed on each benchmark class. The rows marked with “∅(∅)” average runtimesand time or memory exhaustions over a collection of benchmark classes under consideration.14 The following row givesthe Euclidean distance (in an n-dimensional space, where n is the number of benchmark classes and a point is a columnof n average runtimes) of each solver to the virtual best one on the respective collection in focus; the quadratic distancecalculation scheme punishes imbalanced and rewards consistent performance more than averaging. Some benchmark classesand cmodels, have significant impact onmake heavy use of extended rules, so that their different treatments, e.g., in claspthe observed performances; such benchmark classes are marked with “” in Tables 7–9.+∗+Considering the results on tight benchmarks in the upper part of Table 7, we note that the traditional ASP solver smodelsis consistently outperformed by systems exploiting conflict-driven learning. For instance, smodels times out on all satisfiableinstances of 15Puzzle, which are rather unproblematic for the other solvers. In fact, occasional varying performances ofthe latter on tight programs are due to different treatments of extended rules and/or determinizations of inherent non-determinisms in minisat and clasp, respectively. Any such differences may turn out to be advantageous the one or the otherand lp2sat[c] have an edge on other solvers on GraphColouring, clasp in its default setting is fastestway around; e.g., claspon SchurNumbers, while lp2sat[m] yields the fewest aborts on WeightBoundedDomSet. On non-tight benchmarks, we observethat the problem representation overhead incurred by lp2sat’s translational approach is a major handicap, though minisatand clasp may react more or less sensitively (cf. Labyrinth and TravellingSalesperson). Except for MazeGeneration, the strategyof cmodels to verify candidate supported models found by minisat already improves on eager translation by lp2sat. However,integrating unfounded set checking into propagation is usually even more effective, as it can be observed when comparingto cmodels on KnightTour and WireRouting. Beyond dealing with (non-)tightness, the treatment of extendedclasp and clasprules is a crucial factor on some benchmark classes. Their transformation into normal rules, as done by cmodels and lp2sat,turns out to be helpful on ConnectedDomSet,15 while it drastically blows up problem representations and thus deterioratesperformance on TravellingSalesperson.+Focusing on either satisfiable or unsatisfiable instances in Tables 8 and 9, respectively, sheds some light on the distri-bution of hardness within benchmark classes, yet without exhibiting any overwhelming impact regarding relative solverperformances. In fact, a look into Table 8, especially at cmodels and smodels, reveals that the satisfiable instances of Channel-Routing, GraphPartitioning, and MazeGeneration are rather easy. Interestingly, both lp2sat variants still have difficulties withthe non-tight benchmarks, viz., GraphPartitioning and MazeGeneration, indicating that an eager translation of logic programsmay diminish search performance. On the other hand, all solvers perform worse on the satisfiable instances of SchurNumbers12 Additional results for cmodels with zchaff 2007.3.12 and smodels without restarts are available at [22].13 Some non-participating solvers, e.g., assat, sag [91], and smodelscc , are no longer maintained and thus not incorporated here. Although original smodelsdid not participate either (but its close derivative smodels-ie [15] did), we still consider it for reference. At the time of running the experiments, the solverminisat(id) [95], supporting “inductive definitions” on top of propositional theories, did not accept lparse output format.14 We provide averages (rather than sums) for balancing diverse numbers of instances per benchmark class.15 Interestingly, a single instance of ConnectedDomSet is responsible for the three timeouts of clasp and clasp+.Table 7Average runtimes on benchmarks of the second ASP competition.Benchmark#15PuzzleBlockedNQueensChannelRoutingEdgeMatching∗FastfoodGraphColouringHanoi∗HierarchicalClusteringSchurNumbersSolitaireSudoku∗WeightBoundedDomSet∅ (∅)Eucl. dist.(tight)(tight)∗∗ConnectedDomSetGeneralizedSlitherlink∗GraphPartitioningHamiltonianPathKnightTourLabyrinthMazeGenerationSokoban∗TravellingSalespersonWireRouting∅ (∅)Eucl. dist.(non-tight)(non-tight)∅ (∅)Eucl. dist.162910292929151229271029(16/0)(15/14)(6/4)(29/0)(10/19)(9/20)(15/0)(8/4)(13/16)(22/5)(10/0)(29/0)264(182/82)21291329102929292923(10/11)(29/0)(6/7)(29/0)(10/0)(29/0)(10/19)(9/20)(29/0)(12/11)241(173/68)505(355/150)clasp33.015.09120.130.231.17421.5511.760.1617.44204.780.15123.1378.2281.8040.420.109.270.07124.29123.8291.170.730.0542.8143.2762.3762.33102.86(0)(0)(6)(0)(0)(60)(0)(0)(0)(27)(0)(15)(9.00)(3)(0)(0)(0)(6)(12)(12)(0)(0)(3)(3.60)(6.55)+clasp20.184.91120.140.410.90357.883.970.1749.60162.820.16102.1868.6132.5836.110.227.980.0691.8082.9289.890.800.0636.3634.6228.9753.1643.59cmodels[m]smodelslp2sat[m]lp2sat[c]virtual best(0)(0)(6)(0)(0)(39)(0)(0)(0)(21)(0)(12)(6.50)(3)(0)(0)(0)(3)(6)(12)(0)(0)(3)(2.70)(4.77)31.369.04120.5859.3229.22422.662.920.7675.70175.692.55300.26102.50227.197.461.9220.190.21242.48142.2490.413.39317.82175.73100.19383.16101.45445.45(0)(0)(6)(0)(0)(57)(0)(0)(0)(21)(0)(36)(10.00)(0)(0)(0)(0)(12)(6)(12)(0)(7)(12)(4.90)(7.68)600.0029.37120.9060.3283.93453.77523.771.56504.17316.960.25400.84257.99991.76183.760.1692.102.22150.55594.10293.62176.010.22448.32194.11739.35228.951237.02(48)(0)(6)(0)(3)(63)(39)(0)(72)(36)(0)(51)(26.50)(15)(0)(3)(0)(3)(81)(42)(15)(0)(45)(20.40)(23.73)22.2113.19121.3413.0546.85409.703.810.9490.88222.600.87179.5693.75141.6713.435.05365.183.45545.42282.23125.946.11441.68460.89224.94866.08153.38877.59(0)(0)(6)(0)(0)(51)(0)(0)(6)(27)(0)(9)(8.25)(0)(0)(21)(0)(27)(27)(9)(0)(55)(48)(18.70)(13.00)15.135.22121.085.5824.95357.575.360.8636.93210.140.82143.8777.2970.5113.6212.90344.3915.68487.61534.6285.573.99198.34459.97215.67832.52140.19835.50(0)(0)(6)(0)(0)(39)(0)(0)(0)(27)(0)(12)(7.00)(0)(0)(21)(0)(24)(75)(6)(0)(9)(51)(18.60)(12.27)15.134.91120.130.230.90357.572.920.1617.44162.820.15102.1865.380.007.460.107.980.0691.8082.9285.570.730.0536.3631.300.0049.890.00(0)(0)(6)(0)(0)(39)(0)(0)(0)(21)(0)(9)(6.25)(0)(0)(0)(0)(3)(6)(6)(0)(0)(3)(1.80)(4.23)74M.Gebseretal./ArtificialIntelligence187–188(2012)52–89Table 8Average runtimes on satisfiable benchmarks of the second ASP competition.Benchmark#15PuzzleBlockedNQueensChannelRoutingEdgeMatching∗FastfoodGraphColouringHanoi∗HierarchicalClusteringSchurNumbersSolitaireSudoku∗WeightBoundedDomSet∅ (∅)Eucl. dist.(tight, sat)(tight, sat)∗∗ConnectedDomSetGeneralizedSlitherlink∗GraphPartitioningHamiltonianPathKnightTourLabyrinthMazeGenerationSokoban∗TravellingSalespersonWireRouting∅ (∅)(non-tight, sat)Eucl. dist. (non-tight, sat)∅ (∅)Eucl. dist.(sat)(sat)161562910915813221029182102962910291092912173355clasp33.013.480.160.230.1224.9911.760.1437.25114.960.15123.1329.1159.079.280.100.110.07124.29123.820.070.630.0574.0033.2453.9930.9980.02(0)(0)(0)(0)(0)(0)(0)(0)(0)(12)(0)(15)(2.25)(0)(0)(0)(0)(6)(12)(0)(0)(0)(3)(2.10)(2.18)+clasp20.184.930.170.410.4932.663.970.13109.1363.460.16102.1828.1672.481.740.220.140.0691.8082.920.080.780.0662.6324.040.2026.2972.48cmodels[m]smodelslp2sat[m]lp2sat[c]virtual best(0)(0)(0)(0)(0)(0)(0)(0)(0)(6)(0)(12)(1.50)(0)(0)(0)(0)(3)(6)(0)(0)(0)(3)(1.20)(1.36)31.367.520.6759.329.2698.642.921.02166.7779.252.55300.2663.29256.0212.061.924.520.21242.48142.240.085.40317.82134.9486.17364.1273.69445.12(0)(0)(0)(0)(0)(3)(0)(0)(0)(6)(0)(36)600.0022.131.3560.3282.44128.80523.771.52600.00252.630.25400.84(48)(0)(0)(0)(0)(3)(39)(0)(39)(21)(0)(51)(3.75)222.841037.56(16.75)(0)(0)(0)(0)(12)(6)(0)(0)(7)(3)(2.80)(3.32)135.100.160.562.22150.55594.100.15320.540.22407.44161.10709.78194.781257.11(6)(0)(0)(0)(3)(81)(0)(9)(0)(18)(11.70)(14.45)22.2113.991.6313.0545.3357.933.811.20200.49136.820.87179.5656.41203.6517.575.05114.213.45545.42282.23114.3210.77441.68513.20204.79818.54123.85843.49(0)(0)(0)(0)(0)(0)(0)(0)(6)(12)(0)(9)(2.25)(0)(0)(3)(0)(27)(27)(0)(0)(55)(30)(14.20)(7.68)15.134.161.375.5818.5431.275.361.0380.40121.540.82143.8735.7685.9612.3612.90118.2515.68487.61534.6210.924.34198.34519.94191.49789.78106.55794.44(0)(0)(0)(0)(0)(0)(0)(0)(0)(12)(0)(12)(2.00)(0)(0)(3)(0)(24)(75)(0)(0)(9)(30)(14.10)(7.50)15.133.480.160.230.1224.992.920.1337.2563.460.15102.1820.850.001.740.100.110.0691.8082.920.070.630.0562.6324.010.0022.290.00(0)(0)(0)(0)(0)(0)(0)(0)(0)(6)(0)(9)(1.25)(0)(0)(0)(0)(3)(6)(0)(0)(0)(3)(1.20)(1.23)M.Gebseretal./ArtificialIntelligence187–188(2012)52–8975Table 9Average runtimes on unsatisfiable benchmarks of the second ASP competition.Benchmark#BlockedNQueensChannelRouting∗FastfoodGraphColouring∗HierarchicalClusteringSchurNumbersSolitaire∅ (∅)Eucl. dist.(tight, unsat)(tight, unsat)∗ConnectedDomSet∗GraphPartitioningMazeGenerationSokobanWireRouting∅ (∅)(non-tight, unsat)Eucl. dist. (non-tight, unsat)144192041658211719201168∅ (∅)Eucl. dist.(unsat)(unsat)150clasp6.82300.101.72600.000.211.34600.00215.7495.7968.7317.12139.120.788.7846.9167.03145.39116.91(0)(6)(0)(60)(0)(0)(15)(11.57)(3)(0)(12)(0)(0)(3.00)(8.00)+clasp4.88300.101.11504.240.241.24600.00201.690.0367.3514.70137.160.817.7045.5465.24136.6365.24cmodels[m]smodelslp2sat[m]lp2sat[c]virtual best(0)(6)(0)(39)(0)(0)(15)(8.57)(3)(0)(12)(0)(0)(3.00)(6.25)10.68300.4439.72568.480.241.70600.00217.3275.183.2833.62137.952.49220.2379.51213.78159.90226.62(0)(6)(0)(54)(0)(0)(15)(10.71)(0)(0)(12)(0)(9)(4.20)(8.00)37.14300.2384.71600.001.63426.30600.00292.86444.84227.99170.56448.09110.97492.92290.10653.33291.71790.39(0)(6)(3)(60)(0)(33)(15)(16.71)(9)(3)(42)(6)(27)(17.40)(17.00)12.33300.9047.66567.990.421.82600.00218.7379.309.67580.29132.064.01403.83225.97690.59221.75695.13(0)(6)(0)(51)(0)(0)(15)(10.29)(0)(18)(9)(0)(18)(9.00)(9.75)6.35300.6628.32504.400.501.61600.00205.9827.2614.77538.22124.863.83394.56215.25651.05209.84651.62(0)(6)(0)(39)(0)(0)(15)(8.57)(0)(18)(6)(0)(21)(9.00)(8.75)4.88300.101.11504.240.211.24600.00201.680.003.2814.70124.860.787.7030.270.00130.260.00(0)(6)(0)(39)(0)(0)(15)(8.57)(0)(0)(6)(0)(0)(1.20)(5.50)76M.Gebseretal./ArtificialIntelligence187–188(2012)52–89M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8977than on the unsatisfiable ones, and the same also applies to clasp, clasp, and lp2sat on WireRouting. Looking at these twoclasses in Table 9, we observe that the unsatisfiable instances of SchurNumbers are trivial for all solvers but smodels, whileonly clasp and claspcomplete all of the unsatisfiable WireRouting instances. The latter suggests that such instances arenot inherently hard but that lacking either conflict-driven learning (smodels) or native unfounded set checking (cmodels andlp2sat) renders them more difficult.++Unlike with SchurNumbers and WireRouting, some of the unsatisfiable instances of ChannelRouting, GraphColouring, Soli-taire, and MazeGeneration turn out to be much harder than their satisfiable counterparts (at least for the considered solvers).+Notably, lp2sat[c], running clasp as SAT solver, completes more unsatisfiable MazeGeneration instances than clasp and claspthemselves, which contrasts with the behavior observed on satisfiable instances (cf. MazeGeneration in Tables 8 and 9).A similar shift of behaviors is due to one unsatisfiable instance of ConnectedDomSet, which poses a problem to the intrinsictreatment of extended rules in clasp and clasp, while cmodels and lp2sat do not encounter such difficulties. In view of this,we believe that the dynamic selection among possible handlings of extended rules (intrinsic treatment and/or transforma-tion) is interesting future work.+7. Related workOur approach to conflict-driven ASP solving borrows and extends state-of-the-art techniques from the area of SAT [12].Its global search pattern is similar to CDCL with First-UIP scheme, developed more than a decade ago [97,101,127] andnowadays quasi standard for industrial SAT solving (cf. [35,115,100,29,11,4,23,96]). While traditional search procedures likeDavis–Putnam–Logemann–Loveland (DPLL; [25,24]) are polynomially equivalent to tree-like resolution, CDCL (with unlimitedrestarts) amounts to general resolution [109] and is thus strictly more powerful (regarding the best-case complexity ofunsatisfiability proofs) than DPLL. Several investigations [62,79,70] show that this separation carries forward to (native) ASPsolvers under standard translations between ASP and SAT, viz., Clark completion and the reduction in [102]. The clasp systemimplements the CDCL search pattern likewise for logic programs under answer set semantics as well as for propositionalCNF and PB formulas. In contrast to translational approaches, as used by minisat+ [36], it offers dedicated data structuresfor the internal representation of and reasoning about linear inequalities [47]. This relates clasp to SMT [10] techniques,applying “theory propagation” (cf. [104]) to concepts available in extended logic programs [119], viz., unfounded sets (orpositive recursion) and linear inequalities (over Boolean variables).SAT-based ASP solvers like assat [90], cmodels [71], and sag [91] may also exploit conflict-driven learning in the searchfor supported models being answer set candidates, accomplished by underlying SAT solvers. However, their integration ofunfounded set checking is much more loose than in native ASP solvers. To our knowledge, the only native ASP solver otherthan clasp that implements conflict-driven learning is smodelscc [126],16 while ASP solvers like dlv [83], smodels [119], andnomore++ [1] perform DPLL-style search. For enabling conflict analysis, smodelscc takes an algorithmic approach, monitoringapplications of smodels’ inference rules to on-the-fly build an implication graph [97,127,9] as a representation of antecedents.Unlike this, clasp directly incorporates suitable data structures, designed to accommodate backjumping and conflict-drivenlearning: similar to SAT solvers, it merely stores references to antecedents upon propagation, which incurs only negligible(constant) “overhead”. A prototypical extension [112] of dlv includes backjumping, but not learning, based on tracking dlv’sinference rules.Given that answer sets are determined by atoms, native ASP solvers dlv, smodels, and smodelscc are (logically) restrictedto assignments over atoms. As shown in [63,62], this yields an exponential separation, already on tight logic programs, tosolvers that in addition assign and make decisions on rule bodies. To our knowledge, clasp and nomore++ are the only ASPsolvers deliberately taking advantage of rule bodies in assignments. Regardless of minor technical differences, the compar-ison of smodels’ and nomore++’ inferences in [62] reveals that both are based on structural propositions for bodies, so thatthe restricted scope of heuristic decisions is the main trait of smodels’ atom-oriented approach. In view of similarities tosmodels (cf. [70]), this also applies to dlv and smodelscc . Interestingly, CNF conversions of SAT-based ASP solvers (cf. [5]) alsointroduce auxiliary propositions for rule bodies to prevent an exponential blow-up. Although such auxiliary propositions canthen be exploited by underlying SAT solvers, their motivation is more by need than by design. However, as there is not yet aconsensus on how to represent the Boolean constraints induced by logic programs (see, e.g., the proposals in [5,70,86]), wehave used nogoods to express conditions for (unit) propagation, thus separating semantics from syntactic representations.As pointed out in [63,86], SAT-based and native ASP solvers differ in their “laziness” to apply unfounded set checks.While the former confine themselves to final tests required for soundness, in the terminology of [104] investigating SMT,native ASP solvers perform “theory propagation” via unfounded sets.17 Notably, virtually all ASP solvers exploit stronglyconnected components of positive dependency graphs to limit work to necessary parts. Unlike the unfounded set checkingprocedures of dlv [17] and smodels [119] computing greatest unfounded sets, the ones of clasp and nomore++ [2] aim at smallunfounded sets and return them as soon as they are identified. The main motive for this is to reduce overlaps between (unit)propagation and unfounded set checking. Another difference between unfounded set checking approaches is that dlv and16 The solver minisat(id) [95] supports “inductive definitions” on top of propositional theories. Inductive definitions are closely related to logic programs,yet involve a “totality” condition not shared by the latter.17 The approach of lp2diff [78] relies on a reduction to difference logic, so that SMT solvers supporting this logic can be used to accomplish unfoundedset checks and thus to compute answer sets.78M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89nomore++ use a flag “must-be-true” to indicate (logically true) atoms whose non-circular derivability is uncertain, for whichpurpose smodels and clasp exploit source pointers [119]. The advantage of source pointers is that they need not be updatedupon backtracking or backjumping, respectively, while “true” may have to be turned back into “must-be-true”. Albeit severalapproaches [90,71,91,2,59] admit restricting the consideration of unfounded sets to loops, clasp does not guarantee that adetected non-empty unfounded set is a loop (yet it contains one), and it is an interesting open question whether a strictlimitation to loops would be advantageous. We also note that the “unidirectional” unfounded set handling in native ASPsolvers, not realizing full unit propagation via loop formulas, has already been recognized in [63,62]. Unfortunately, theapproach to remedy this peculiarity suggested in [18,19] is computationally too complex (quadratic) to be beneficial inpractice, and it is open whether the intended effect can be achieved by more economic techniques.On top of its basic decision procedure, clasp supports various extended functionalities (cf. [56]). Particular backtrackingschemes, applied after finding a solution, admit the repetition-free enumeration of answer sets [53] as well as projectionsof them [57] in polynomial space. Optimization strategies wrt one or multiple (lexicographically ordered) objectives aredescribed in [48]. Furthermore, clasp offers advanced preprocessing on the level of logic programs [55] and also theirinduced constraints [33]. Techniques for the intrinsic treatment of extended rules have been presented in [47]; in particular,they include an unfounded set checking procedure extending the one in Algorithm 3. Finally, several systems implementelaborate features on top of clasp: disjunctive ASP solver claspD [31] internally couples two clasp engines, clingcon [60]embeds the gecode constraint library18 into clasp’s propagation routine to deal with non-Boolean variables, iclingo [46]exploits clasp’s incremental interface to solve series of problems over increasing horizons [20,34], and parallel ASP solverclaspar [37,118,50] augments clasp with a communication module to enable message passing between distributed solverinstances.8. SummaryWe have provided a uniform approach to conflict-driven ASP solving, allowing for a transparent technology transferfrom (and to) neighboring areas like SAT. The idea is to view inferences in ASP solving as unit propagation on nogoods,reflecting constraints from Clark completion, unfounded sets, and conflicts. We have seen that the inclusion of rule bodiesin assignments allows for a natural extension of unit propagation to ASP, abolishing the pre-existing need for multipleinference rules.In contrast to SAT, ASP induces implicit constraints given by loop nogoods. Though inherently present, these nogoodsneed only be expatiated when they serve as antecedents. This puts sophisticated unfounded set checks on the same logicalbasis as plain SAT, and we have provided a conflict-driven algorithmic framework for ASP solving, incorporating state-of-the-art SAT solving techniques. Notably, our approach favors unit propagation on explicit nogoods over unfounded setchecks, testing for implicit loop nogoods that are unit or violated. In fact, many of the combinatorially constructable loopnogoods (ΛΠ ) might be redundant, that is, entailed by Clark completion and/or other loop nogoods. (For tight programs,the whole set ΛΠ of loop nogoods is redundant.) In view of this, our approach makes sure that inspected loop nogoods are“1-empowering” [108] and supplement the available constraints.We have implemented our approach in the ASP solver clasp, which has demonstrated its competitiveness in varioussettings, for instance, winning first places at the ASP, CASC, MISC, PB, and SAT contests in 2011. The clasp system implementsstate-of-the-art techniques from Boolean constraint solving without deploying or modifying any legacy SAT solver. Rather,clasp extends the functionalities of plain SAT solvers by unfounded set checking, intrinsic treatment of cardinality andweight constraints, and optimization. Beyond search for one answer set, clasp can enumerate them without falling backon solution recording; such techniques are detailed in [53] and [57]. All in all, clasp has become a powerful native ASPsolver, whose reasoning modes [56] make it an attractive tool for knowledge representation and reasoning. The clasp systemconstitutes a central component of the Potassco tool suite [44] and has already been used in various applications fromdiverse areas like, e.g., assisted living [99], music composition [13], temporal reasoning [80], general game playing [122],hardware synthesis [75], and systems biology [64].AcknowledgementsWe are grateful to the ASP research and user community as a whole for valuable contributions to the Potassco project,and to the anonymous reviewers of this paper for many helpful comments.This work was supported by the German Science Foundation (DFG) under grants SCHA 550/8-1 and -2.Appendix A. ProofsIn Appendices A.1 and A.2, we provide proofs for the formal results presented in Sections 3 and 4.5, respectively.18 Available at http://www.gecode.org.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8979A.1. Nogoods of logic programsWe begin with Lemma 3.1, establishing that any solution for (cid:5)Π is uniquely determined by its literals over atoms.Lemma 3.1. Let Π be a logic program and X ⊆ atom(Π).Then, we have thatA = {Tp | p ∈ X} ∪(cid:6)(cid:4)Fp(cid:5)(cid:5) β ∈ body(Π), β(cid:5)(cid:7)(cid:5) β ∈ body(Π),(cid:5)(cid:5) p ∈ atom(Π) \ X+ ⊆ X, β− ∩ X = ∅(cid:8)(cid:8)(cid:7)+ ∩atom(Π) \ Xβ(cid:6)(cid:4)∪∪(cid:4)TβFβ(cid:7)∪− ∩ Xβ(cid:8)(cid:6)(cid:7)= ∅is the unique solution for (cid:5)body(Π) such that AT ∩ atom(Π) = X .Proof. Consider any β = {p1, . . . , pm, not pm+1, . . . , not pn} ∈ body(Π), and recall that δ(β) = {Fβ, Tp1, . . . , Tpm, Fpm+1,. . . , Fpn} and (cid:5)(β) = {{Tβ, Fp1}, . . . , {Tβ, Fpm}, {Tβ, Tpm+1}, . . . , {Tβ, Tpn}}. Then, one of the following cases applies:β+ ⊆ X and β− ∩ X = ∅: We have that {Tp1, . . . , Tpm, Fpm+1, . . . , Fpn} ⊆ A and {Fp1, . . . , Fpm, Tpm+1, . . . , Tpn} ∩ A = ∅. Inview of the latter, δ (cid:2) A for any δ ∈ (cid:5)(β). Furthermore, Tβ ∈ A and Fβ /∈ A make sure that δ(β) (cid:2) A, whereδ(β) \ A = {Fβ}.(β+ ∩ (atom(Π) \ X)) ∪ (β− ∩ X) (cid:7)= ∅: We have that {Fp1, . . . , Fpm, Tpm+1, . . . , Tpn} ∩ A (cid:7)= ∅ and {Tp1, . . . , Tpm, Fpm+1,. . . , Fpn} (cid:2) A. The latter yields that δ(β) (cid:2) A. Furthermore, Fβ ∈ A and Tβ /∈ A make sure that δ (cid:2) A for everyδ ∈ (cid:5)(β), where δ \ A = {Tβ} for some δ ∈ (cid:5)(β).The above cases show that, for every β ∈ body(Π), no nogood from {δ(β)}∪(cid:5)(β) is contained in A, so that A is a solution for(cid:5)body(Π) = {δ(β) | β ∈ body(Π)} ∪ {δ ∈ (cid:5)(β) | β ∈ body(Π)}. On the other hand, for each β ∈ body(Π), either δ(β) \ A = {Fβ}or δ \ A = {Tβ} for some δ ∈ (cid:5)(β). Hence, there is no solution B (cid:7)= A for (cid:5)body(Π) such that BT ∩ atom(Π) = X . (cid:2)Theorem 3.3 on the correspondence between answer sets of a tight program Π and solutions for (cid:5)Π can be derivedfrom Lemma 3.2, establishing one-to-one correspondence between supported models of Π and solutions for (cid:5)Π . Bothresults are demonstrated next.Lemma 3.2. Let Π be a logic program and X ⊆ atom(Π) ∪ body(Π).Then, we have that ( X ∩ atom(Π)) ∪ {pβ | β ∈ X ∩ body(Π)} is a supported model of Π iff {Tv | v ∈ X} ∪ {Fv | v ∈ (atom(Π) ∪body(Π)) \ X} is a solution for (cid:5)Π .Proof. Let M = ( X ∩ atom(Π)) ∪ {pβ | β ∈ X ∩ body(Π)} and A = {Tv | v ∈ X} ∪ {Fv | v ∈ (atom(Π) ∪ body(Π)) \ X}. Then, forany p ∈ atom(Π) (or β ∈ body(Π)), we have that p ∈ M (or pβ ∈ M) iff Tp ∈ A (or Tβ ∈ A), and p /∈ M (or pβ /∈ M) iff Fp ∈ A(or Fβ ∈ A).Considering any β = {p1, . . . , pm, not pm+1, . . . , not pn} ∈ body(Π), it is not difficult to check that δ ⊆ A for someδ ∈ {δ(β)} ∪ (cid:5)(β) = {{Fβ, Tp1, . . . , Tpm, Fpm+1, . . . , Fpn}, {Tβ, Fp1}, . . . , {Tβ, Fpm}, {Tβ, Tpm+1}, . . . , {Tβ, Tpn}} iff M (cid:7)|(cid:20) (pβ ↔p1 ∧ · · · ∧ pm ∧ ¬pm+1 ∧ · · · ∧ ¬pn).Likewise, for any p ∈ atom(Π) with bodyΠ (p) = {β1, . . . , βk}, δ ⊆ A for some δ ∈ {δ(p)} ∪ (cid:5)(p) = {{Tp, Fβ1, . . . , Fβk},{Fp, Tβ1}, . . . , {Fp, Tβk}} iff M (cid:7)|(cid:20) (p ↔ pβ1∨ · · · ∨ pβk ).This shows that M is a supported model of Π iff A is a solution for (cid:5)Π . (cid:2)Theorem 3.3. Let Π be a tight logic program and X ⊆ atom(Π).Then, we have that X is an answer set of Π iffA = {Tp | p ∈ X} ∪(cid:4)(cid:6)Fp(cid:5)(cid:5) β ∈ body(Π), β(cid:5)(cid:7)(cid:5) β ∈ body(Π),(cid:5)(cid:5) p ∈ atom(Π) \ X+ ⊆ X, β− ∩ X = ∅(cid:8)(cid:8)(cid:7)+ ∩atom(Π) \ Xβ(cid:6)(cid:4)∪∪(cid:4)TβFβ(cid:7)∪− ∩ Xβ(cid:8)(cid:6)(cid:7)= ∅is the unique solution for (cid:5)Π such that AT ∩ atom(Π) = X .Proof. By Lemma 3.1, there is a subset of (cid:5)Π for which A is the unique solution such that AT ∩ atom(Π) = X . Along withLemma 3.2, we conclude that M ∩ atom(Π) = X for some supported model M of Π iff A is the unique solution for (cid:5)Π such80M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89that AT ∩ atom(Π) = X . Finally, by Theorem 3.2 in [40], showing that supported models and answer sets of Π coincide if Πis tight,19 we conclude that X is an answer set of Π iff A is the unique solution for (cid:5)Π such that AT ∩ atom(Π) = X . (cid:2)In order to extend Theorem 3.3 to non-tight programs, we provide some properties of unfounded sets. To begin with,GRS-unfounded sets are linked to unfounded sets by the fact that, wrt a body-saturated assignment, every GRS-unfoundedset is an unfounded set as well.Proposition 3.4. Let Π be a logic program, A an assignment, and U ⊆ atom(Π).If A is body-saturated for Π , then we have that U is an unfounded set of Π wrt A if U is a GRS-unfounded set of Π wrt A.Proof. Assume that A is body-saturated for Π . Then, for every β ∈ body(Π), (β+ ∩ AF) ∪ (β− ∩ AT) (cid:7)= ∅ implies β ∈ AF. Hence,if U is a GRS-unfounded set of Π wrt A, then EBΠ (U ) ⊆ {β ∈ body(Π) | (β+ ∩ AF) ∪ (β− ∩ AT) (cid:7)= ∅} implies EBΠ (U ) ⊆ AF, sothat U is an unfounded set of Π wrt A. (cid:2)Further considering the relationships between unfounded set concepts, unfounded sets and GRS-unfounded sets coincidewrt body-synchronized assignments.Proposition 3.5. Let Π be a logic program, A an assignment, and U ⊆ atom(Π).If A is body-synchronized for Π , then we have that U is an unfounded set of Π wrt A iff U is a GRS-unfounded set of Π wrt A.Proof. Assume that A is body-synchronized for Π . Then, A is body-saturated for Π according to Definition 3.3, and byProposition 3.4, U is an unfounded set of Π wrt A if U is a GRS-unfounded set of Π wrt A. It remains to show that theconverse holds as well. Since A is body-synchronized for Π , for every β ∈ body(Π), β ∈ AF implies (β+ ∩ AF) ∪ (β− ∩ AT) (cid:7)= ∅.Hence, if U is an unfounded set of Π wrt A, then EBΠ (U ) ⊆ AF implies EBΠ (U ) ⊆ {β ∈ body(Π) | (β+ ∩ AF) ∪ (β− ∩ AT) (cid:7)= ∅},so that U is a GRS-unfounded set of Π wrt A. (cid:2)The following characterization of solutions for ΛΠ provides an analogy to unfounded-free interpretations [84], as identi-fied wrt GRS-unfounded sets, in terms of our unfounded set notion.Proposition 3.6. Let Π be a logic program and A an assignment such that AT ∪ AF = atom(Π) ∪ body(Π).Then, we have that A is a solution for ΛΠ iff U ⊆ AF for every unfounded set U of Π wrt A.Proof. We have that A is not a solution for ΛΠ iff λ(p, U ) ⊆ A for some ∅ ⊂ U ⊆ atom(Π) and p ∈ U iff p ∈ U ∩ AT andEBΠ (U ) ⊆ AF for some U ⊆ atom(Π) iff U (cid:2) AF for some unfounded set U of Π wrt A. (cid:2)We are now ready to extend Theorem 3.3 to non-tight programs.Theorem 3.7. Let Π be a logic program and X ⊆ atom(Π).Then, we have that X is an answer set of Π iffA = {Tp | p ∈ X} ∪(cid:6)(cid:4)Fp(cid:5)(cid:5) β ∈ body(Π), β(cid:5)(cid:7)(cid:5) β ∈ body(Π),(cid:5)(cid:5) p ∈ atom(Π) \ X+ ⊆ X, β(cid:7)+ ∩β− ∩ X = ∅(cid:8)(cid:8)atom(Π) \ X(cid:6)(cid:4)∪∪(cid:4)TβFβ(cid:7)∪− ∩ Xβ(cid:8)(cid:6)(cid:7)= ∅is the unique solution for (cid:5)Π ∪ ΛΠ such that AT ∩ atom(Π) = X .Proof. By Lemma 3.1, there is a subset of (cid:5)Π for which A is the unique solution such that AT ∩ atom(Π) = X . Along withLemma 3.2, we conclude that M ∩ atom(Π) = X for some supported model M of Π iff A is the unique solution for (cid:5)Πsuch that AT ∩ atom(Π) = X . For any supported model M of Π , it is clear that M ∩ atom(Π) is a model of Π , that is,− ∩ M (cid:7)= ∅ holds for every r ∈ Π . Hence, if A is the unique solution for (cid:5)Π suchhead(r) ∈ M, body(r)that AT ∩ atom(Π) = X , then AT ∩ atom(Π) is a model of Π . In addition, we have that A is body-synchronized for Πaccording to Definition 3.3 because AF ∩ body(Π) = {β ∈ body(Π) | (β+ ∩ (atom(Π) \ X)) ∪ (β− ∩ X) (cid:7)= ∅} = {β ∈ body(Π) |(β+ ∩ AF) ∪ (β− ∩ AT) (cid:7)= ∅}. We use these properties to show the implications of the statement:+ (cid:2) M, or body(r)19 Note that the equivalences in (3) define auxiliary propositions for bodies in terms of atoms. Hence, our representation is a conservative extension ofthe completion of Π , originally described without propositions for bodies [21].M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8981⇒: Assume that X is an answer set of Π . Then, by Corollary 1 in [93], we have that M ∩ atom(Π) = X for some supportedmodel M of Π . (See Footnote 19 for remarks on the role of auxiliary propositions for bodies in the Clark completionof Π .) That is, A is the unique solution for (cid:5)Π such that AT ∩ atom(Π) = X . Furthermore, by Theorem 4.6 in [84],we have that U ∩ X = ∅ holds for every GRS-unfounded set U of Π wrt X . Since A is body-synchronized for Π , byProposition 3.5, we conclude that U ∩ AT = ∅ and U ⊆ AF hold for every unfounded set U of Π wrt A. Hence, byProposition 3.6, A is a solution for ΛΠ and the unique solution for (cid:5)Π ∪ ΛΠ such that AT ∩ atom(Π) = X .⇐: Assume that A is the unique solution for (cid:5)Π ∪ ΛΠ such that AT ∩ atom(Π) = X . Then, by Proposition 3.6, we have thatU ∩ AT = ∅ holds for every unfounded set U of Π wrt A. Since A is body-synchronized for Π , Proposition 3.5 yieldsthat U ∩ X = ∅ holds for every GRS-unfounded set U of Π wrt X . Along with the fact that AT ∩ atom(Π) = X is a modelof Π , by Theorem 4.6 in [84], we conclude that X is an answer set of Π .We have thus shown that both implications of the statement hold. (cid:2)In what follows, we show further crucial properties of unfounded sets. To begin with, false atoms of an unfounded setmay be removed, while still maintaining unfoundedness when the assignment at hand is body-saturated.Proposition 3.8. Let Π be a logic program, A an assignment, and U an unfounded set of Π wrt A.If A is body-saturated for Π , then we have that U \ AF is an unfounded set of Π wrt A.Proof. Assume that A is body-saturated for Π . Then, for every β ∈ EBΠ (U \ AF) \ EBΠ (U ), the fact that β+ ∩ (U ∩ AF) (cid:7)= ∅implies β ∈ AF. Along with EBΠ (U ) ⊆ AF, we conclude that EBΠ (U \ AF) ⊆ AF, so that U \ AF is an unfounded set of Πwrt A. (cid:2)The following auxiliary result shows that, wrt an atom-saturated assignment, any non-empty unfounded set of non-falseatoms that is not a loop contains in turn a non-empty proper subset that is unfounded.Lemma A.1. Let Π be a logic program, A an assignment, and U ⊆ atom(Π) \ AF a non-empty unfounded set of Π wrt A.If A is atom-saturated for Π and if U /∈ loop(Π), then there is some non-empty unfounded set U(cid:16) ⊂ U of Π wrt A.Proof. Assume that A is atom-saturated for Π and that U /∈ loop(Π). Then, for every p ∈ U , the prerequisite that U ⊆atom(Π) \ AF implies bodyΠ (p) (cid:2) AF, while EBΠ (U ) ⊆ AF yields bodyΠ (p) ∩ EBΠ (U ) ⊆ AF. That is, for every p ∈ U , there issome β ∈ bodyΠ (p) \ AF, and β+ ∩ U (cid:7)= ∅ holds for each β ∈ bodyΠ (p) \ AF. Hence, every atom of U has some predecessorbelonging to U in (atom(Π), (cid:2)+). However, since U /∈ loop(Π), we have that the subgraph of (atom(Π), (cid:2)+) induced by Uis not strongly connected. Along with the fact that U is finite, we conclude that there is some strongly connected component+ ∩ U }) such that its vertices C do not reach atoms in U \ C .20 The latterof (U , {(p, head(r)) | r ∈ Π, head(r) ∈ U , p ∈ body(r)means that β+ ∩ C = ∅ holds for every β ∈ EBΠ (U \ C), so that EBΠ (U \ C) ⊆ EBΠ (U ). Since ∅ ⊂ C ⊂ U and EBΠ (U ) ⊆ AF,this shows that U(cid:16) = U \ C is a non-empty unfounded set of Π wrt A such that U(cid:16) ⊂ U . (cid:2)The previous lemma allows us to conclude that, wrt an atom-saturated assignment, every non-empty unfounded set ofnon-false atoms must contain an unfounded loop.Proposition 3.9. Let Π be a logic program, A an assignment, and U ⊆ atom(Π) \ AF a non-empty unfounded set of Π wrt A.If A is atom-saturated for Π , then there is some unfounded set L ⊆ U of Π wrt A such that L ∈ loop(Π).Proof. Assume that A is atom-saturated for Π . Then, since U ⊆ atom(Π) \ AF is a non-empty unfounded set of Π wrt A,there is some non-empty unfounded set L ⊆ U of Π wrt A such that ∅ and L are all unfounded sets of Π wrt A containedin L. For each such L ⊆ U , by Lemma A.1, we conclude that L ∈ loop(Π). (cid:2)Corollary 3.10. Let Π be a logic program, A an assignment, and U ⊆ atom(Π) \ AF a non-empty unfounded set of Π wrt A.If A is atom-saturated for Π , then there is some non-empty unfounded set Usame non-trivial strongly connected component of (atom(Π), (cid:2)+).(cid:16) ⊆ U of Π wrt A such that all p ∈ U(cid:16)belong to theProof. This result follows immediately from Proposition 3.9, since all atoms of some L ∈ loop(Π) belong to the same stronglyconnected component of (atom(Π), (cid:2)+), which must be non-trivial by the definition of a loop. (cid:2)Finally, we combine Propositions 3.8 and 3.9 to show that, wrt an assignment that is both atom- and body-saturated,any unfounded set that includes non-false atoms must contain an unfounded loop of non-false atoms.20 Note that the “condensation” of (U , {(p, head(r)) | r ∈ Π, head(r) ∈ U , p ∈ body(r)to a single vertex, is a directed acyclic graph (cf. [111]).+ ∩ U }), obtained by contracting each strongly connected component82M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89Theorem 3.11. Let Π be a logic program and A an assignment.If A is both atom- and body-saturated for Π and if there is some unfounded set U of Π wrt A such that U (cid:2) AF, then there is someunfounded set L ⊆ U \ AF of Π wrt A such that L ∈ loop(Π).Proof. Assume that A is both atom- and body-saturated for Π and that there is some unfounded set U of Π wrt A suchthat U (cid:2) AF. Then, by Proposition 3.8, we have that U \ AF is a non-empty unfounded set of Π wrt A. Furthermore, byProposition 3.9, there is some unfounded set L ⊆ U \ AF of Π wrt A such that L ∈ loop(Π). (cid:2)Corollary 3.12. Let Π be a logic program and A an assignment.If A is both atom- and body-saturated for Π and if there is some unfounded set U of Π wrt A such that U (cid:2) AF, then there is somebelong to the same non-trivial strongly connected component(cid:16) ⊆ U \ AF of Π wrt A such that all p ∈ U(cid:16)non-empty unfounded set Uof (atom(Π), (cid:2)+).Proof. This result follows immediately from Theorem 3.11, since all atoms of some L ∈ loop(Π) belong to the same stronglyconnected component of (atom(Π), (cid:2)+), which must be non-trivial by the definition of a loop. (cid:2)A.2. Soundness and completeness of CDNL-ASP algorithmWe begin with showing fundamental properties of UnfoundedSet in Algorithm 3, where Lemmas 4.1 and 4.2 establishinvariants that are crucial for its soundness and completeness, stated in Theorem 4.3.Lemma 4.1. Let Π be a logic program and A an assignment that is body-saturated for Π .If UnfoundedSet(Π, A) is invoked on a valid source pointer configuration, then we have that the source pointer configurationremains valid throughout the execution of UnfoundedSet(Π, A).Proof. Assume that UnfoundedSet(Π, A) is invoked on a valid source pointer configuration. Then, an invalid sourcepointer configuration could in principle be obtained only in Line 13 of Algorithm 3, where source(q) is set for some (cyclic)q ∈ atom(Π). However, by induction on executions of Line 13, we show that the source pointer configuration remains valid:(cid:13)Base case: Since the given source pointer configuration is valid and A is body-saturated for Π , after finishing the loopin Lines 2–5 of Algorithm 3, we have that source(p) ∈ bodyΠ (p) \ AF and source(p)+ ∩ (AF ∪ (scc(p) ∩ S)) = ∅hold for every cyclic p ∈ atom(Π) \ (AF ∪ S). For the atoms C of any non-trivial strongly connected componentp∈C\(AF∪S)(source(p)+ ∩ C) ⊆ C \ (AF ∪ S). In words, the source pointers ofof (atom(Π), (cid:2)+), this implies thatatoms in C that are neither false in A nor in scope S do not contain any atom of C that is false in A or in scope S.Induction step: Let q ∈ U be any cyclic atom such that the condition in Line 12 of Algorithm 3 applies to q, and letC = scc(q). Then, in view of the choice of some p ∈ S in Line 6 along with Lines 7 and 14–16, manipulating thecontents of U and S, respectively, we have that U ⊆ C ∩ S, which yields that q ∈ C ∩ S. Furthermore, assume thatp∈C\(AF∪S)(source(p)+ ∩ C) ⊆ C \ (AF ∪ S) holds before settingthe source pointer configuration is valid and thatsource(q) to some β ∈ bodyΠ (q) in Line 13. In terms of the subgraph of (atom(Π), (cid:2)+) containing every cyclicp∈C\(AF∪S)(source(p)+ ∩ C) ⊆ C \ (AF ∪ S)(cid:16) ∈ source(p)+ ∩ scc(p),p ∈ atom(Π) along with edges (pmeans that it does not contain any edge from an atom in C ∩ (AF ∪ S) to an atom in C \ (AF ∪ S). For β, since A isbody-saturated for Π , the condition β ∈ EBΠ (U ) \ AF in Line 10 makes sure that β+ ∩ AF = ∅, and β+ ∩ (C ∩ S) = ∅is verified in Line 11. Hence, we have that β+ ∩ C ⊆ C \ (AF ∪ S), so that, for all edges (p, q) from atoms p ∈ β+ ∩ Cto q, it holds that p ∈ C \ (AF ∪ S). As we have seen above that q ∈ C ∩ S does not reach atoms in C \ (AF ∪ S),we conclude that the subgraph of (atom(Π), (cid:2)+) containing every cyclic p ∈ atom(Π) along with edges (p(cid:16), p)(cid:16) ∈ source(p)+ ∩ scc(p) remains acyclic after setting source(q) to β in Line 13. This shows that the sourcefor all ppointer configuration obtained by executing Line 13 is in turn valid. Finally, we have that the induction hypothesisp∈C\(AF∪S)(source(p)+ ∩still holds for S \ {q} constructed in Line 15, that is,C)) ∪ (β+ ∩ C) ⊆ C \ (AF ∪ S) ⊆ C \ (AF ∪ (S \ {q})).p∈C\(AF∪(S\{q}))(source(p)+ ∩ C) = ((cid:16), p) for all p(cid:13)(cid:13)(cid:13)(cid:13)We have thus shown that a valid source pointer configuration cannot be invalidated when invoking UnfoundedSet(Π, A)with an assignment A that is body-saturated for Π . (cid:2)Lemma 4.2. Let Π be a logic program and A an assignment that is atom-saturated for Π .If UnfoundedSet(Π, A) is invoked on a valid source pointer configuration, then we have that every unfounded set U ⊆atom(Π) \ AF of Π wrt A such that all p ∈ U belong to the same strongly connected component of (atom(Π), (cid:2)+) is containedin S whenever Line 6 of Algorithm 3 is entered.Proof. Assume that UnfoundedSet(Π, A) is invoked on a valid source pointer configuration. Then, let U ⊆ atom(Π) \ AFbe any unfounded set of Π wrt A such that all p ∈ U belong to the same strongly connected component of (atom(Π), (cid:2)+).M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8983Since U ∩ AF = ∅ and A is atom-saturated for Π , we have that bodyΠ (p) (cid:2) AF for every p ∈ U , while EBΠ (U ) ⊆ AF impliesthat β+ ∩ U (cid:7)= ∅ holds for each β ∈ bodyΠ (p) \ AF. That is, all p ∈ U are cyclic, and source(p) ∈ bodyΠ (p) ∪ {⊥} holds becausethe given source pointer configuration is valid. By induction on executions of the test in Line 6 of Algorithm 3, we showthat U (cid:2) S is impossible whenever Line 6 is entered:Base case: For the sake of contradiction, assume that U (cid:2) S after finishing the loop in Lines 2–5 of Algorithm 3. Then,in view of Line 1, for each p ∈ U \ S, we have that source(p) /∈ AF ∪ {⊥}, which further implies that source(p) ∈bodyΠ (p) \ AF and source(p)+ ∩ U (cid:7)= ∅. Moreover, the condition source(p)+ ∩ (scc(p) ∩ S) (cid:7)= ∅ in Line 3 does notapply to source(p), which yields that source(p)+ ∩ (U ∩ S) = ∅ and source(p)+ ∩ (U \ S) (cid:7)= ∅. Since U \ S is finiteand each atom of U \ S has some predecessor belonging to U \ S in the subgraph of (atom(Π), (cid:2)+) containingevery cyclic p ∈ atom(Π) along with edges (q, p) for all q ∈ source(p)+ ∩ scc(p), we conclude that this subgraphcannot be acyclic, which is a contradiction to the assumption that UnfoundedSet(Π, A) is invoked on a validsource pointer configuration.Induction step: For the sake of contradiction, assume that U ⊆ S at the beginning of an iteration of the loop in Lines 6–17of Algorithm 3, but U (cid:2) S when Line 6 is re-entered after finishing the iteration. In this iteration, the elements ofU \ S must have (successively) been removed from S in Line 15. In particular, some q ∈ U \ S has been removedfrom S before any other atom of U . To achieve this, the condition in Line 11 must have applied to some β ∈bodyΠ (q) \ AF, which yields that β+ ∩ (scc(q) ∩ Uof U . Since U ⊆ scc(q), this impliesthat β+ ∩ U = ∅, which is a contradiction to the assumption that U is an unfounded set of Π wrt A.(cid:16)) = ∅ for some superset U(cid:16)We have thus shown that, if UnfoundedSet(Π, A) is invoked on a valid source pointer configuration with an assign-ment A that is atom-saturated for Π , every unfounded set U ⊆ atom(Π) \ AF of Π wrt A such that all p ∈ U belong tothe same strongly connected component of (atom(Π), (cid:2)+) must be contained in S whenever Line 6 of Algorithm 3 is en-tered. If any such unfounded set U is non-empty, this invariant excludes the termination of Algorithm 3 by returning ∅ inLine 18. (cid:2)Theorem 4.3. Let Π be a logic program and A an assignment that is both atom- and body-saturated for Π .If UnfoundedSet(Π, A) is invoked on a valid source pointer configuration, then we have that UnfoundedSet(Π, A) returnsan unfounded set U ⊆ atom(Π) \ AF of Π wrt A, where U = ∅ iff there is no unfounded set Uof Π wrt A such that U(cid:16)(cid:16) (cid:2) AF.(cid:16)of Π wrt A such that UProof. Assume that UnfoundedSet(Π, A) is invoked on a valid source pointer configuration. Then, in view of the condi-tion EBΠ (U ) ⊆ AF in Line 9 of Algorithm 3 and the fact that ∅, which can be returned in Line 18, is a (trivial) unfoundedset of Π wrt A, we have that UnfoundedSet(Π, A) can only return an unfounded set of Π wrt A. By Corollary 3.12, the(cid:16) (cid:2) AF implies that there is a non-empty unfoundedexistence of some non-empty unfounded set U(cid:16) \ AF such that all p ∈ U belong to the same strongly connected component of (atom(Π), (cid:2)+). Furthermore, byset U ⊆ ULemma 4.2, any such unfounded set U of Π wrt A is contained in scope S whenever Line 6 is entered. This shows thatUnfoundedSet(Π, A) cannot return ∅ in Line 18 if there is some non-empty unfounded set Uof Π wrt A such thatU(cid:16) (cid:2) AF.It only remains to show that UnfoundedSet(Π, A) terminates. To this end, note that scope S is increasing overiterations of the loop in Lines 2–5 of Algorithm 3, and strictly decreasing over iterations of the loop in Lines 6–17. For Uhandled in the loop in Lines 8–17, we observe that it is strictly increasing when U is extended in Line 16, and strictlydecreasing when an element q is removed from U in Line 14, where q cannot be added back later on because it is alsoremoved from S in Line 15. Since atom(Π) is finite and U ⊆ S ⊆ atom(Π) \ AF, we conclude that none of the loops inAlgorithm 3 can be iterated infinitely. Rather, any atom can be added to and removed from S and U , respectively, at mostonce, which yields that the time complexity of UnfoundedSet(Π, A) is linear in the size of Π . (cid:2)(cid:16)Next, we show properties of NogoodPropagation in Algorithm 2. Lemma 4.4 essentially establishes the applicabilityof Theorem 4.3 whenever an unfounded set check is initiated in Line 12 of Algorithm 2, and Lemma 4.5 provides propertiescrucial for the soundness and completeness of conflict-driven ASP solving.Lemma 4.4. Let Π be a logic program, ∇(cid:16)a set of nogoods, dl ∈ N, and A(cid:16)an assignment.Then, we have that A is both atom- and body-saturated for Π whenever Line 10 of Algorithm 2 is entered in an execution ofNogoodPropagation(dl, Π, ∇(cid:16), A(cid:16)).Proof. For the sake of contradiction, assume that Line 10 of Algorithm 2 is entered in an execution of NogoodPropaga-tion(dl, Π, ∇(cid:16), A(cid:16)), while the current assignment A is not atom-saturated or not body-saturated for Π . Then, some of thefollowing cases applies:bodyΠ (p) ⊆ AF but Fp /∈ A for some p ∈ atom(Π): The nogood δ(p) = {Tp, Fβ1, . . . , Fβk}, where bodyΠ (p) = {β1, . . . , βk}, issuch that δ(p) \ A ⊆ {Tp}. In view of the condition in Line 4 of Algorithm 2, tested in the previous iteration of84M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89the loop in Lines 3–9, we have that Tp /∈ A and δ(p) \ A = {Tp}. But this implies that Fp is unit-resulting for δ(p)wrt A, so that the condition Σ = ∅ cannot hold in Line 9, which contradicts that Line 10 is entered with A beingthe current assignment.(β+ ∩ AF) ∪ (β− ∩ AT) (cid:7)= ∅ but Fβ /∈ A for some β ∈ body(Π): Some nogood δ = {Tβ, ρ} ∈ (cid:5)(β) is such that δ \ A ⊆ {Tβ}. Inview of the condition in Line 4 of Algorithm 2, tested in the previous iteration of the loop in Lines 3–9, we havethat Tβ /∈ A and δ \ A = {Tβ}. But this implies that Fβ is unit-resulting for δ wrt A, so that the condition Σ = ∅cannot hold in Line 9, which contradicts that Line 10 is entered with A being the current assignment.Since each of the above cases yields a contradiction, we conclude that A is both atom- and body-saturated for Π wheneverLine 10 of Algorithm 2 is entered. (cid:2)Lemma 4.5. Let Π be a logic program, ∇(cid:16)a set of nogoods, dl ∈ N, and A(cid:16)an assignment.If NogoodPropagation(dl, Π, ∇(cid:16), A(cid:16)) is invoked on a valid source pointer configuration, then we have that NogoodProp-agation(dl, Π, ∇(cid:16), A(cid:16)) returns a pair (A, ∇) such that1. ∇(cid:16) ⊆ ∇ ⊆ ∇(cid:16) ∪ ΛΠ ;2. A is an assignment such that A3. δ ⊆ A for some δ ∈ (cid:5)Π ∪ ∇ if λ(p, U ) ⊆ A for some λ(p, U ) ∈ ΛΠ .(cid:16) ⊆ A and every σ ∈ A \ A(cid:16)is implied by (cid:5)Π ∪ ∇ wrt A;Proof. Assume that NogoodPropagation(dl, Π, ∇(cid:16), Abegin with showing that the items of the statement hold if NogoodPropagation(dl, Π, ∇(cid:16), A(cid:16)) is invoked on a valid source pointer configuration. Then, we(cid:16)) returns a pair (A, ∇):1. Since ∇(cid:16)2. In view of Line 5 of Algorithm 2, for each literal σ added to an assignment B such that Acan be augmented only with elements of ΛΠ in Line 14 of Algorithm 2, we have that ∇(cid:16) ⊆ ∇ ⊆ ∇(cid:16) ∪ ΛΠ .(cid:16) ⊆ B ⊂ A, we have that{σ , σ } ∩ B = ∅ and that there is an antecedent δ ∈ (cid:5)Π ∪ ∇ of σ wrt B, so that σ is implied by (cid:5)Π ∪ ∇ wrt A.3. For the sake of contradiction, assume that δ (cid:2) A for all δ ∈ (cid:5)Π ∪ ∇ and λ(p, U ) ⊆ A for some λ(p, U ) ∈ ΛΠ . Then, U isan unfounded set of Π wrt A such that U (cid:2) AF. Furthermore, (A, ∇) must be returned in Line 10 or 13 of Algorithm 2,and Lemma 4.4 tells us that A is both atom- and body-saturated for Π . By Theorem 3.11, we conclude that someL ∈ loop(Π) is unfounded for Π wrt A, so that Π is not tight. Hence, (A, ∇) must be returned in Line 13 after obtaining∅ as the result of UnfoundedSet(Π, A) in Line 12. However, by Lemmas 4.4 and 4.1, we conclude that Theorem 4.3is applicable, which contradicts that ∅ is obtained as the result of UnfoundedSet(Π, A) in Line 12.(cid:16)) terminates. To this end, note that an assignment B suchIt remains to show that NogoodPropagation(dl, Π, ∇(cid:16), A(cid:16) ⊆ B is increasing over iterations of the loop in Lines 3–9 of Algorithm 2, as shown in the proof of the secondthat Aitem. Furthermore, by Theorem 4.3 (along with Lemmas 4.4 and 4.1), any invocation of UnfoundedSet(Π, B) in Line 12terminates with an unfounded set U ⊆ atom(Π) \ BF of Π wrt B. Hence, we have that U = ∅ or λ(p, U ) \ B ⊆ {Tp} foreach p ∈ U ; by Lemma 4.4 and Proposition 3.8, the same applies to U \ BF determined in Line 11. Thus, any execution ofLines 11–12 is followed by the termination of Algorithm 2 in Line 13, or in view of Line 14, by the termination in Line 4 orthe addition of a literal Fp (for p ∈ atom(Π) \ (BT ∪ BF)) to B in Line 8 in the next iteration of the loop in Lines 2–14. Sinceatom(Π) ∪ body(Π) is finite, there cannot be infinitely many literals added to Aover iterations of the loops in Lines 2–14and 3–9, respectively, so that NogoodPropagation(dl, Π, ∇(cid:16), A(cid:16)) terminates by returning a pair (A, ∇). (cid:2)(cid:16)The following lemma expresses that ConflictAnalysis in Algorithm 4 returns an asserting nogood when given anogood violated at a decision level greater than 0.Lemma 4.6. Let Π be a logic program, ∇ a set of nogoods, A an assignment such that {σ ∈ A | ρ ∈ A[σ ], dl(σ ) < dl(ρ)} = ∅ and {σ ∈A | ρ ∈ A[σ ], dl(ρ) = dl(σ )} ⊆ {σ ∈ A | ε ∈ (cid:5)Π ∪ ∇, ε \ A[σ ] = {σ }}, and δ(cid:16) ⊆ A such that m = max({dl(σ ) | σ ∈ δ(cid:16)} ∪ {0}) (cid:7)= 0.Then, we have that ConflictAnalysis(δ(cid:16), Π, ∇, A) returns a pair (δ, k) such that1. δ ⊆ A;2. |{σ ∈ δ | k < dl(σ )}| = 1;3. δ (cid:2) B for any solution B for (cid:5)Π ∪ ∇ ∪ {δ(cid:16)}.Proof. Given that {σ ∈ A | ρ ∈ A[σ ], dl(σ ) < dl(ρ)} = ∅, every ε(cid:16) ⊆ A such that max({dl(ρ) | ρ ∈ ε(cid:16)} ∪ {0}) = m containsa literal σ such that ε(cid:16) \ A[σ ] = {σ } and dl(σ ) = m. (Such literals σ are determined in Line 2 of Algorithm 4.) Then, byinduction on iterations of the loop in Lines 1–7 of Algorithm 4, we show that the items of the statement hold if Con-flictAnalysis(δ(cid:16), Π, ∇, A) returns a pair (δ, k):Base case: Let δ ⊆ A be some set of literals such that max({dl(ρ) | ρ ∈ δ} ∪ {0}) = m and δ (cid:2) B for any solution B for(cid:5)Π ∪ ∇ ∪ {δ(cid:16)}. For the literal σ ∈ δ determined in Line 2 of Algorithm 4, if the test in Line 4 yields that k =max({dl(ρ) | ρ ∈ δ \ {σ }} ∪ {0}) (cid:7)= m, then |{ρ ∈ δ | k < dl(ρ)}| = |{σ }| = 1, and (δ, k) is returned in Line 7.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8985Induction step: Let ε(cid:16) ⊆ A be some set of literals such that max({dl(ρ) | ρ ∈ ε(cid:16)} ∪ {0}) = m and ε(cid:16) (cid:2) B for any solution Bfor (cid:5)Π ∪ ∇ ∪ {δ(cid:16)}. For the literal σ ∈ ε(cid:16)determined in Line 2 of Algorithm 4, if the test in Line 4 yields thatmax({dl(ρ) | ρ ∈ ε(cid:16) \ {σ }} ∪ {0}) = m, there is some ρ ∈ A[σ ] such that dl(ρ) = dl(σ ) = m. Given that {σ ∈ A | ρ ∈A[σ ], dl(ρ) = dl(σ )} ⊆ {σ ∈ A | ε ∈ (cid:5)Π ∪ ∇, ε \ A[σ ] = {σ }}, (cid:5)Π ∪ ∇ contains an antecedent of σ wrt A, and somesuch ε is selected in Line 5. Since ε(cid:16) \ {σ } ⊆ A[σ ] ⊆ A and ε \ {σ } ⊆ A[σ ] ⊆ A, for (ε(cid:16) \ {σ }) ∪ (ε \ {σ }) constructedin Line 6, it holds that (ε(cid:16) \ {σ }) ∪ (ε \ {σ }) ⊆ A[σ ] ⊆ A. Furthermore, max({dl(ρ) | ρ ∈ ε(cid:16) \ {σ }} ∪ {0}) = m impliesthat max({dl(ρ) | ρ ∈ (ε(cid:16) \ {σ }) ∪ (ε \ {σ })} ∪ {0}) = m. Finally, since any solution B for (cid:5)Π ∪ ∇ ∪ {δ(cid:16)} contains eitherσ or σ , while ε(cid:16) (cid:2) B and ε (cid:2) B, we have that (ε(cid:16) \ {σ }) ∪ (ε \ {σ }) (cid:2) B.It remains to show that ConflictAnalysis(δ(cid:16), Π, ∇, A) terminates, i.e., that the base case of the induction eventuallyapplies. To this end, note that, in the induction step above, we have that (ε(cid:16) \ {σ }) ∪ (ε \ {σ }) ⊆ A[σ ] ⊆ A, i.e., all literalsρ ∈ (ε(cid:16) \ {σ }) ∪ (ε \ {σ }) precede σ in A. From this and the fact A does not include duplicate literals, we conclude that therecannot be infinitely many applications of the induction step over iterations of the loop in Lines 1–7 of Algorithm 4, so thatConflictAnalysis(δ(cid:16), Π, ∇, A) terminates by returning a pair (δ, k). (cid:2)We now turn to CDNL-ASP in Algorithm 1 for deciding whether a logic program has an answer set, where Lemma 4.7establishes invariants that are crucial for the main soundness and completeness result stated in Theorem 4.8.Lemma 4.7. Let Π be a logic program.Then, we have that the following holds whenever Line 5 of Algorithm 1 is entered in an execution of CDNL-ASP(Π ):1. ∇ is a set of nogoods such that δ (cid:2) B for every δ ∈ ∇ and any solution B for (cid:5)Π ∪ ΛΠ ;2. A is an assignment such that {σ ∈ A | ρ ∈ A[σ ], dl(σ ) < dl(ρ)} = ∅ and {σ ∈ A | dl(σ ) (cid:2) max({dl(ρ) | ρ ∈ A[σ ]} ∪ {0})} ⊆{σ ∈ A | ε ∈ (cid:5)Π ∪ ∇, ε \ A[σ ] = {σ }};3. dl ∈ N is such that δ (cid:2) {σ ∈ A | dl(σ ) < dl} for every δ ∈ (cid:5)Π ∪ ΛΠ ∪ ∇.Proof. By induction on iterations of the loop in Lines 4–17 of Algorithm 1, we show that the items of the statement holdwhenever Line 5 is entered in an execution of CDNL-ASP(Π ):Base case: Before the first iteration, in view of Lines 1–3 of Algorithm 1, we have that A = ∇ = ∅ and dl = 0, for which theitems of the statement trivially hold, and also that max({dl(σ ) | σ ∈ A} ∪ {0}) (cid:2) dl.(cid:16)Induction step: At the beginning of an iteration of the loop in Lines 4–17 of Algorithm 1, let ∇(cid:16)be such that the(cid:16)} ∪ {0}) (cid:2).21 Then, by Lemma 4.5 (along with Lemmas 4.1 and 4.4) and in view of Lines 7–8 of Algorithm 2, we have that(cid:16)) invoked in Line 5 returns a pair (A, ∇) such that the items of the statement. Afterwards, oneitems (1), (2), and (3) of the statement are satisfied wrt them, and assume that (a) max({dl(σ ) | σ ∈ Adl(cid:16)NogoodPropagation(dlstill hold for ∇, A, and dlof the following cases applies:, respectively. In addition, we have that max({dl(σ ) | σ ∈ A} ∪ {0}) (cid:2) dl, Π, ∇(cid:16), A(cid:16), and dl, A(cid:16)(cid:16)(cid:16)ε ⊆ A for some ε ∈ (cid:5)Π ∪ ∇:If the condition in Line 7 of Algorithm 1 applies, CDNL-ASP(Π ) immediately ter-minates by returning “no answer set”. Otherwise, by Lemma 4.6, ConflictAnalysis(ε, Π, ∇, A)|{σ ∈ δ | k < dl(σ )}| = 1, and δ (cid:2) B for any solution B forreturns a pair (δ, k) such that δ ⊆ A,(cid:5)Π ∪ ∇. Since any solution B for (cid:5)Π ∪ ΛΠ is a solution for (cid:5)Π ∪ ∇ as well, it follows that δ (cid:2) B,so that (1) B is a solution for (cid:5)Π ∪ (∇ ∪ {δ}), where ∇ ∪ {δ} is constructed in Line 9. Furthermore,Ak = A \ {σ ∈ A | k < dl(σ )} constructed in Line 10 is such that (2) {σ ∈ Ak | ρ ∈ Ak[σ ], dl(σ ) < dl(ρ)} = ∅and {σ ∈ Ak | dl(σ ) (cid:2) max({dl(ρ) | ρ ∈ Ak[σ ]} ∪ {0})} ⊆ {σ ∈ Ak | ε ∈ (cid:5)Π ∪ (∇ ∪ {δ}), ε \ Ak[σ ] = {σ }}.Since 0 (cid:2) k holds in view of Line 3 of Algorithm 4, (a) max({dl(σ ) | σ ∈ Ak} ∪ {0}) (cid:2) dl, where dl is set tok in Line 8. Finally, δ ⊆ A and |{σ ∈ δ | k < dl(σ )}| = 1 yield that dl < dland δ (cid:2) Ak, so that (3) dl ∈ N issuch that δ(cid:16) (cid:2) {σ ∈ Ak | dl(σ ) < dl} for every δ(cid:16) ∈ (cid:5)Π ∪ ΛΠ ∪ (∇ ∪ {δ}). That is, the induction hypothesesstill apply wrt ∇ ∪ {δ}, Ak, and dl.(cid:16)If the condition in Line 11 of Algorithm 1 applies, CDNL-ASP(Π ) terminates inLine 12 by returning AT ∩ atom(Π). Otherwise, some decision literal σd = Tv or σd = Fv such thatis returned by Select(Π, ∇, A)v ∈ (atom(Π) ∪ body(Π)) \ (AT ∪ AF), as required in Section 4.1,in Line 14. Let dl = dlin Line 16, we have that} ∪ {0}) = dl and (2) {σ ∈Aσd|[σ ]} ∪ {0})} ⊆ {σ ∈ AσdAσd[σ ] = {σ }}. Finally, we note that (1) ∇ is not altered, and by the third item inε ∈ (cid:5)Π ∪ ∇, ε \ Aσd(cid:16) + 1, as set in Line 15. Since dl(σd) is set to dl= A ◦ σd constructed in Line 17 is such that (a) max({dl(σ ) | σ ∈ Aσd| ρ ∈ Aσd[σ ], dl(σ ) < dl(ρ)} = ∅ and {σ ∈ Aσd| dl(σ ) (cid:2) max({dl(ρ) | ρ ∈ Aσdε (cid:2) A for all ε ∈ (cid:5)Π ∪ ∇:21 We below indicate derivations of our induction hypotheses by (1), (2), and (3), standing for the first, the second, and the third item of the statement,respectively, as well as by (a), expressing that max({dl(σ ) | σ ∈ A} ∪ {0}) (cid:2) dl holds for an assignment A and the current value of dl.86M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89the statement of Lemma 4.5, we have that (3) dl ∈ N is such that δ (cid:2) {σ ∈ Aσdδ ∈ (cid:5)Π ∪ ΛΠ ∪ ∇. That is, the induction hypotheses still apply wrt ∇, Aσd , and dl.| dl(σ ) < dl} for everyWe have thus shown that the items of the statement hold whenever Line 5 of Algorithm 1 is entered. (cid:2)Theorem 4.8. Let Π be a logic program.Then, we have that CDNL-ASP(Π ) terminates, and it returns an answer set of Π iff Π has some answer set.Proof. If AT ∩ atom(Π) is returned in Line 12 of Algorithm 1, then the test in Line 6 and the third item in the statementof Lemma 4.5 establish that A is a solution for (cid:5)Π ∪ ΛΠ . Furthermore, by Lemma 3.1, we have that there is no solutionB (cid:7)= A for (cid:5)Π ∪ ΛΠ such that BT ∩ atom(Π) = AT ∩ atom(Π). Hence, by Theorem 3.7, we conclude that AT ∩ atom(Π) is ananswer set of Π . On the other hand, if CDNL-ASP(Π ) returns “no answer set” in Line 7, in view of the third item in thestatement of Lemma 4.7, we have that max({dl(σ ) | σ ∈ ε} ∪ {0}) = 0 for some ε ∈ (cid:5)Π ∪ ∇ such that ε ⊆ A. Then, by thesecond item in the statement of Lemma 4.7, for every σ ∈ ε, there is some antecedent of σ wrt A in (cid:5)Π ∪ ∇, so that therecannot be any solution for (cid:5)Π ∪ ∇. Along with the first item in the statement of Lemma 4.7, it follows that there is nosolution for (cid:5)Π ∪ ΛΠ . Hence, by Theorem 3.7, we conclude that Π has no answer set.It remains to show that CDNL-ASP(Π ) terminates. In view of the second and the third item in the statement ofLemma 4.7 along with the condition in Line 7 of Algorithm 1, we have that Lemma 4.6 applies whenever Conflict-Analysis(ε, Π,∇ , A) is invoked in Line 8. Hence, it returns a pair (δ, k) such that some literal ρ is unit-resulting for δwrt A \ {σ ∈ A | k < dl(σ )}. As a consequence, ρ will be added to A \ {σ ∈ A | k < dl(σ )} in Line 5 in the next iterationof the loop in Lines 4–17. That is, after every backjump in Line 10, some element of atom(Π) ∪ body(Π) is assigned ata smaller (non-negative) decision level than before. Since atom(Π) ∪ body(Π) is finite, this implies that CDNL-ASP(Π )admits only finitely many backjumps.22 Along with the fact that A is strictly extended in Line 17, so that either a backjumpor termination in Line 12 is inevitable within a linear number of iterations of the loop in Lines 4–17, we conclude thatCDNL-ASP(Π ) eventually terminates in Line 7 or 12 of Algorithm 1. (cid:2)References[1] C. Anger, M. Gebser, T. Linke, A. Neumann, T. Schaub, The nomore++ approach to answer set solving, in: G. Sutcliffe, A. Voronkov (Eds.), Proceedingsof the Twelfth International Conference on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR’05), in: Lecture Notes in ArtificialIntelligence, vol. 3835, Springer-Verlag, 2005, pp. 95–109.[2] C. Anger, M. Gebser, T. Schaub, Approaching the core of unfounded sets, in: J. Dix, A. Hunter (Eds.), Proceedings of the Eleventh International Workshopon Nonmonotonic Reasoning (NMR’06), number IFI-06-04, Institute for Informatics, Clausthal University of Technology, Technical Report Series, 2006,pp. 58–66.[3] K. Apt, H. Blair, A. Walker, Towards a theory of declarative knowledge, in: J. Minker (Ed.), Foundations of Deductive Databases and Logic Programming,Morgan Kaufmann Publishers, 1987, pp. 89–148, Chapter 2.[4] G. Audemard, L. Simon, Predicting learnt clauses quality in modern SAT solvers, in Boutilier (2009) [14, pp. 399–404].[5] Y. Babovich, V. Lifschitz, Computing answer sets using program completion, http://www.cs.utexas.edu/users/tag/cmodels/cmodels-1.ps, 2003.[6] C. Baral, Knowledge Representation, Reasoning and Declarative Problem Solving, Cambridge University Press, 2003.[7] C. Baral, G. Brewka, J. Schlipf (Eds.), Proceedings of the Ninth International Conference on Logic Programming and Nonmonotonic Reasoning(LPNMR’07), Lecture Notes in Artificial Intelligence, vol. 4483, Springer-Verlag, 2007.[8] C. Baral, G. Greco, N. Leone, G. Terracina (Eds.), Proceedings of the Eighth International Conference on Logic Programming and Nonmonotonic Rea-soning (LPNMR’05), Lecture Notes in Artificial Intelligence, vol. 3662, Springer-Verlag, 2005.[9] P. Beame, H. Kautz, A. Sabharwal, Towards understanding and harnessing the potential of clause learning, Journal of Artificial Intelligence Research 22(2004) 319–351.[10] C. Barrett, R. Sebastiani, S. Seshia, C. Tinelli, Satisfiability modulo theories, in: A. Biere, et al. (Eds.), Handbook of Satisfiability, in: Frontiers in ArtificialIntelligence and Applications, vol. 185, IOS Press, 2009, pp. 825–885, Chapter 26.[11] A. Biere, PicoSAT essentials, Journal on Satisfiability, Boolean Modeling and Computation 4 (2008) 75–97.[12] A. Biere, M. Heule, H. van Maaren, T. Walsh (Eds.), Handbook of Satisfiability, Frontiers in Artificial Intelligence and Applications, vol. 185, IOS Press,2009.[13] G. Boenn, M. Brain, M. De Vos, J. Fitch, Automatic composition of melodic and harmonic music by answer set programming, in Garcia de la Bandaand Pontelli (2008) [43, pp. 160–174].[14] C. Boutilier (Ed.), Proceedings of the Twenty-First International Joint Conference on Artificial Intelligence (IJCAI’09), AAAI Press/MIT Press, 2009.[15] M. Brain, M. De Vos, The significance of memory costs in answer set solver implementation, Journal of Logic and Computation 19 (4) (2009) 615–641.[16] G. Brewka, J. Lang (Eds.), Proceedings of the Eleventh International Conference on Principles of Knowledge Representation and Reasoning (KR’08),AAAI Press, 2008.[17] F. Calimeri, W. Faber, G. Pfeifer, N. Leone, Pruning operators for disjunctive logic programming systems, Fundamenta Informaticae 71 (2–3) (2006)183–214.[18] X. Chen, J. Ji, F. Lin, Computing loops with at most one external support rule, in Brewka and Lang (2008) [16, pp. 401–410].[19] X. Chen, J. Ji, F. Lin, Computing loops with at most one external support rule for disjunctive logic programs, in Erdem et al. (2009) [38, pp. 130–144].22 See, e.g., [128,115] for detailed arguments for the fact that the search pattern combining backjumping with conflict-driven assertions is complete for(UN)SAT. In a nutshell, such arguments work by ranking assignments according to the numbers of variables assigned per decision level and by verifyingthat the sequence of assignments generated during search is strictly monotonic. Since the total number of variables is finite, every such sequence must befinite as well (yet its length depends on heuristics). Note that this does not necessitate keeping all recorded conflict (or loop) nogoods. Rather, only theantecedents of assigned literals are ultimately needed (for conflict resolution), and their number is bounded by the number of variables.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8987[20] K. Claessen, N. Sörensson, New techniques that improve MACE-style finite model finding, in: P. Baumgartner, C. Fermüller (Eds.), Proceedings of theWorkshop on Model Computation — Principles, Algorithms, Applications (MODEL’03), 2003.[21] K. Clark, Negation as failure, in: H. Gallaire, J. Minker (Eds.), Logic and Data Bases, Plenum Press, 1978, pp. 293–322.[22] clasp, http://www.cs.uni-potsdam.de/clasp.[23] A. Darwiche, K. Pipatsrisawat, Complete algorithms, in: A. Biere, et al. (Eds.), Handbook of Satisfiability, in: Frontiers in Artificial Intelligence andApplications, vol. 185, IOS Press, 2009, pp. 99–130, Chapter 3.[24] M. Davis, G. Logemann, D. Loveland, A machine program for theorem-proving, Communications of the ACM 5 (1962) 394–397.[25] M. Davis, H. Putnam, A computing procedure for quantification theory, Journal of the ACM 7 (1960) 201–215.[26] R. Dechter, Constraint Processing, Morgan Kaufmann Publishers, 2003.[27] J. Delgrande, W. Faber (Eds.), Proceedings of the Eleventh International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’11),Lecture Notes in Artificial Intelligence, vol. 6645, Springer-Verlag, 2011.[28] M. Denecker, J. Vennekens, S. Bond, M. Gebser, M. Truszczy ´nski, The second answer set programming competition, in Erdem et al. (2009) [38,pp. 637–654].[29] N. Dershowitz, Z. Hanna, A. Nadel, Towards a better understanding of the functionality of a conflict-driven SAT solver, in Marques-Silva and Sakallah(2007) [98, pp. 287–293].[30] W. Dowling, J. Gallier, Linear-time algorithms for testing the satisfiability of propositional Horn formulae, Journal of Logic Programming 1 (1984)267–284.[31] C. Drescher, M. Gebser, T. Grote, B. Kaufmann, A. König, M. Ostrowski, T. Schaub, Conflict-driven disjunctive answer set solving, in Brewka and Lang(2008) [16, pp. 422–432].[32] C. Drescher, M. Gebser, B. Kaufmann, T. Schaub, Heuristics in conflict resolution, in: M. Pagnucco, M. Thielscher (Eds.), Proceedings of the TwelfthInternational Workshop on Nonmonotonic Reasoning (NMR’08), number UNSW-CSE-TR-0819, School of Computer Science and Engineering, The Uni-versity of New South Wales, Technical Report Series, 2008, pp. 141–149.[33] N. Eén, A. Biere, Effective preprocessing in SAT through variable and clause elimination, in: F. Bacchus, T. Walsh (Eds.), Proceedings of the EighthInternational Conference on Theory and Applications of Satisfiability Testing (SAT’05), in: Lecture Notes in Computer Science, vol. 3569, Springer-Verlag, 2005, pp. 61–75.[34] N. Eén, N. Sörensson, Temporal induction by incremental SAT solving, Electronic Notes in Theoretical Computer Science 89 (4) (2003).[35] N. Eén, N. Sörensson, An extensible SAT-solver, in: Proceedings of the Sixth International Conference on Theory and Applications of SatisfiabilityTesting (SAT’03), 2003, pp. 502–518.[36] N. Eén, N. Sörensson, Translating pseudo-Boolean constraints into SAT, Journal on Satisfiability, Boolean Modeling and Computation 2 (2006) 1–26.[37] E. Ellguth, M. Gebser, M. Gusowski, R. Kaminski, B. Kaufmann, S. Liske, T. Schaub, L. Schneidenbach, B. Schnor, A simple distributed conflict-drivenanswer set solver, in Erdem et al. (2009) [38, pp. 490–495].[38] E. Erdem, F. Lin, T. Schaub (Eds.), Proceedings of the Tenth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’09),Lecture Notes in Artificial Intelligence, vol. 5753, Springer-Verlag, 2009.[39] W. Faber, G. Pfeifer, N. Leone, Semantics and complexity of recursive aggregates in answer set programming, Artificial Intelligence 175 (1) (2011)278–298.[40] F. Fages, Consistency of Clark’s completion and the existence of stable models, Journal of Methods of Logic in Computer Science 1 (1994) 51–60.[41] P. Ferraris, Answer sets for propositional theories, in Baral et al. (2005) [8, pp. 119–131].[42] J. Freeman, Improvements to propositional satisfiability search algorithms, PhD thesis, University of Pennsylvania, 1995.[43] M. Garcia de la Banda, E. Pontelli (Eds.), Proceedings of the Twenty-Fourth International Conference on Logic Programming (ICLP’08), Lecture Notesin Computer Science, vol. 5366, Springer-Verlag, 2008.[44] M. Gebser, R. Kaminski, B. Kaufmann, M. Ostrowski, T. Schaub, M. Schneider, Potassco: The Potsdam answer set solving collection, AI Communica-tions 24 (2) (2011) 105–124.[45] M. Gebser, R. Kaminski, B. Kaufmann, M. Ostrowski, T. Schaub, S. Thiele, A user’s guide to gringo, clasp, clingo, and iclingo, available at:http://potassco.sourceforge.net.[46] M. Gebser, R. Kaminski, B. Kaufmann, M. Ostrowski, T. Schaub, S. Thiele, Engineering an incremental ASP solver, in Garcia de la Banda and Pontelli(2008) [43, pp. 190–205].[47] M. Gebser, R. Kaminski, B. Kaufmann, T. Schaub, On the implementation of weight constraint rules in conflict-driven ASP solvers, in Hill and Warren(2009) [73, pp. 250–264].[48] M. Gebser, R. Kaminski, B. Kaufmann, T. Schaub, Multi-criteria optimization in answer set programming, in: J. Gallagher, M. Gelfond (Eds.), TechnicalCommunications of the Twenty-Seventh International Conference on Logic Programming (ICLP’11), in: Leibniz International Proceedings in Informatics(LIPIcs), vol. 11, Dagstuhl Publishing, 2011, pp. 1–10.[49] M. Gebser, R. Kaminski, B. Kaufmann, T. Schaub, M. Schneider, S. Ziller, A portfolio solver for answer set programming: Preliminary report, in Delgrandeand Faber (2011) [27, pp. 352–357].[50] M. Gebser, R. Kaminski, B. Kaufmann, T. Schaub, B. Schnor, Cluster-based ASP solving with claspar, in Delgrande and Faber (2011) [27, pp. 364–369].[51] M. Gebser, R. Kaminski, A. König, T. Schaub, Advances in gringo series 3, in Delgrande and Faber (2011) [27, pp. 345–351].[52] M. Gebser, B. Kaufmann, A. Neumann, T. Schaub, clasp: A conflict-driven answer set solver, in Baral et al. (2007) [7, pp. 260–265].[53] M. Gebser, B. Kaufmann, A. Neumann, T. Schaub, Conflict-driven answer set enumeration, in Baral et al. (2007) [7, pp. 136–148].[54] M. Gebser, B. Kaufmann, A. Neumann, T. Schaub, Conflict-driven answer set solving, in Veloso (2007) [125, pp. 386–392].[55] M. Gebser, B. Kaufmann, A. Neumann, T. Schaub, Advanced preprocessing for answer set solving, in: M. Ghallab, C. Spyropoulos, N. Fakotakis,N. Avouris (Eds.), Proceedings of the Eighteenth European Conference on Artificial Intelligence (ECAI’08), IOS Press, 2008, pp. 15–19.[56] M. Gebser, B. Kaufmann, T. Schaub, The conflict-driven answer set solver clasp: Progress report, in Erdem et al. (2009) [38, pp. 509–514].[57] M. Gebser, B. Kaufmann, T. Schaub, Solution enumeration for projected Boolean search problems, in: W. van Hoeve, J. Hooker (Eds.), Proceedingsof the Sixth International Conference on Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems(CPAIOR’09), in: Lecture Notes in Computer Science, vol. 5547, Springer-Verlag, 2009, pp. 71–86.[58] M. Gebser, J. Lee, Y. Lierler, Elementary sets for logic programs, in Gil and Mooney (2006) [69, pp. 244–249].[59] M. Gebser, J. Lee, Y. Lierler, Head-elementary-set-free logic programs, in Baral et al. (2007) [7, pp. 149–161].[60] M. Gebser, M. Ostrowski, T. Schaub, Constraint answer set solving, in Hill and Warren (2009) [73, pp. 235–249].[61] M. Gebser, T. Schaub, Loops: Relevant or redundant?, in Baral et al. (2005) [8, pp. 53–65].[62] M. Gebser, T. Schaub, Characterizing ASP inferences by unit propagation, in: E. Giunchiglia, V. Marek, D. Mitchell, E. Ternovska (Eds.), Proceedings ofthe First International Workshop on Search and Logic: Answer Set Programming and SAT (LaSh’06), 2006, pp. 41–56.[63] M. Gebser, T. Schaub, Tableau calculi for answer set programming, in: S. Etalle, M. Truszczy ´nski (Eds.), Proceedings of the Twenty-Second InternationalConference on Logic Programming (ICLP’06), in: Lecture Notes in Computer Science, vol. 4079, Springer-Verlag, 2006, pp. 11–25.[64] M. Gebser, T. Schaub, S. Thiele, P. Veber, Detecting inconsistencies in large biological networks with answer set programming, Theory and Practice ofLogic Programming 11 (2–3) (2011) 323–360.88M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–89[65] M. Gelfond, Answer sets, in: V. Lifschitz, F. van Harmelen, B. Porter (Eds.), Handbook of Knowledge Representation, Elsevier, 2008, pp. 285–316,Chapter 7.[66] M. Gelfond, N. Leone, Logic programming and knowledge representation — The A-Prolog perspective, Artificial Intelligence 138 (1–2) (2002) 3–38.[67] M. Gelfond, V. Lifschitz, The stable model semantics for logic programming, in: R. Kowalski, K. Bowen (Eds.), Proceedings of the Fifth InternationalConference and Symposium on Logic Programming (ICLP’88), MIT Press, 1988, pp. 1070–1080.[68] M. Gelfond, V. Lifschitz, Classical negation in logic programs and disjunctive databases, New Generation Computing 9 (1991) 365–385.[69] Y. Gil, R. Mooney (Eds.), Proceedings of the Twenty-First National Conference on Artificial Intelligence (AAAI’06), AAAI Press, 2006.[70] E. Giunchiglia, N. Leone, M. Maratea, On the relation among answer set solvers, Annals of Mathematics and Artificial Intelligence 53 (1–4) (2008)169–204.[71] E. Giunchiglia, Y. Lierler, M. Maratea, Answer set programming based on propositional satisfiability, Journal of Automated Reasoning 36 (4) (2006)345–377.[72] E. Goldberg, Y. Novikov, BerkMin: A fast and robust SAT solver, in: Proceedings of the Fifth Conference on Design, Automation and Test in Europe(DATE’02), IEEE Press, 2002, pp. 142–149.[73] P. Hill, D. Warren (Eds.), Proceedings of the Twenty-Fifth International Conference on Logic Programming (ICLP’09), Lecture Notes in Computer Science,vol. 5649, Springer-Verlag, 2009.[74] J. Huang, The effect of restarts on the efficiency of clause learning, in Veloso (2007) [125, pp. 2318–2323].[75] H. Ishebabi, P. Mahr, C. Bobda, M. Gebser, T. Schaub, Answer set vs integer linear programming for automatic synthesis of multiprocessor systemsfrom real-time parallel programs, Journal of Reconfigurable Computing (2009), http://www.hindawi.com/journals/ijrc/2009/863630.html.[76] T. Janhunen, Some (in)translatability results for normal logic programs and propositional theories, Journal of Applied Non-Classical Logics 16 (1–2)(2006) 35–86.[77] T. Janhunen, I. Niemelä, Compact translations of non-disjunctive answer set programs to propositional clauses, in: M. Balduccini, T. Son (Eds.), LogicProgramming, Knowledge Representation, and Nonmonotonic Reasoning: Essays Dedicated to Michael Gelfond on the Occasion of His 65th Birthday,in: Lecture Notes in Computer Science, vol. 6565, Springer-Verlag, 2011, pp. 111–130.[78] T. Janhunen, I. Niemelä, M. Sevalnev, Computing stable models via reductions to difference logic, in Erdem et al. (2009) [38, pp. 142–154].[79] M. Järvisalo, E. Oikarinen, Extended ASP tableaux and rule redundancy in normal logic programs, Theory and Practice of Logic Programming 8 (5–6)(2008) 691–716.[80] T. Kim, J. Lee, R. Palla, Circumscriptive event calculus as answer set programming, in Boutilier (2009) [14, pp. 823–829].[81] H. Kleine Büning, X. Zhao (Eds.), Proceedings of the Eleventh International Conference on Theory and Applications of Satisfiability Testing (SAT’08),Lecture Notes in Computer Science, vol. 4996, Springer-Verlag, 2008.[82] J. Lee, A model-theoretic counterpart of loop formulas, in: L. Kaelbling, A. Saffiotti (Eds.), Proceedings of the Nineteenth International Joint Conferenceon Artificial Intelligence (IJCAI’05), Professional Book Center, 2005, pp. 503–508.[83] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, F. Scarcello, The DLV system for knowledge representation and reasoning, ACM Transactionson Computational Logic 7 (3) (2006) 499–562.[84] N. Leone, P. Rullo, F. Scarcello, Disjunctive stable models: Unfounded sets, fixpoint semantics, and computation, Information and Computation 135 (2)(1997) 69–112.[85] C. Li, F. Manyà, MaxSAT, in: A. Biere, et al. (Eds.), Handbook of Satisfiability, in: Frontiers in Artificial Intelligence and Applications, vol. 185, IOS Press,2009, pp. 613–631, Chapter 19.[86] Y. Lierler, Abstract answer set solvers with learning, Theory and Practice of Logic Programming 11 (2–3) (2011) 135–169.[87] V. Lifschitz, Answer set programming and plan generation, Artificial Intelligence 138 (1–2) (2002) 39–54.[88] V. Lifschitz, A. Razborov, Why are there so many loop formulas?, ACM Transactions on Computational Logic 7 (2) (2006) 261–268.[89] V. Lifschitz, L. Tang, H. Turner, Nested expressions in logic programs, Annals of Mathematics and Artificial Intelligence 25 (3–4) (1999) 369–389.[90] F. Lin, Y. Zhao, ASSAT: Computing answer sets of a logic program by SAT solvers, Artificial Intelligence 157 (1–2) (2004) 115–137.[91] Z. Lin, Y. Zhang, H. Hernandez, Fast SAT-based answer set solver, in Gil and Mooney (2006) [69, pp. 92–97].[92] M. Luby, A. Sinclair, D. Zuckerman, Optimal speedup of Las Vegas algorithms, Information Processing Letters 47 (4) (1993) 173–180.[93] V. Marek, V. Subrahmanian, The relationship between stable, supported, default and autoepistemic semantics for general logic programs, TheoreticalComputer Science 103 (2) (1992) 365–386.[94] V. Marek, M. Truszczy ´nski, Stable models and an alternative logic programming paradigm, in: K. Apt, V. Marek, M. Truszczy ´nski, D. Warren (Eds.), TheLogic Programming Paradigm: A 25-Year Perspective, Springer-Verlag, 1999, pp. 375–398.[95] M. Mariën, J. Wittocx, M. Denecker, M. Bruynooghe, SAT(ID): Satisfiability of propositional logic extended with inductive definitions, in Kleine Büningand Zhao (2008) [81, pp. 211–224].[96] J. Marques-Silva, I. Lynce, S. Malik, Conflict-driven clause learning SAT solvers, in: A. Biere, et al. (Eds.), Handbook of Satisfiability, in: Frontiers inArtificial Intelligence and Applications, vol. 185, IOS Press, 2009, pp. 131–153, Chapter 4.[97] J. Marques-Silva, K. Sakallah, GRASP: A search algorithm for propositional satisfiability, IEEE Transactions on Computers 48 (5) (1999) 506–521.[98] J. Marques-Silva, K. Sakallah (Eds.), Proceedings of the Tenth International Conference on Theory and Applications of Satisfiability Testing (SAT’07),Lecture Notes in Computer Science, vol. 4501, Springer-Verlag, 2007.[99] A. Mileo, D. Merico, R. Bisiani, A logic programming approach to home monitoring for risk prevention in assisted living, in Garcia de la Banda andPontelli (2008) [43, pp. 145–159].[100] D. Mitchell, A SAT solver primer, Bulletin of the European Association for Theoretical Computer Science 85 (2005) 112–133.[101] M. Moskewicz, C. Madigan, Y. Zhao, L. Zhang, S. Malik, Chaff: Engineering an efficient SAT solver, in: Proceedings of the Thirty-Eighth Conference onDesign Automation (DAC’01), ACM Press, 2001, pp. 530–535.[102] I. Niemelä, Logic programs with stable model semantics as a constraint programming paradigm, Annals of Mathematics and Artificial Intelli-gence 25 (3–4) (1999) 241–273.[103] I. Niemelä, Stable models and difference logic, Annals of Mathematics and Artificial Intelligence 53 (1–4) (2008) 313–329.[104] R. Nieuwenhuis, A. Oliveras, C. Tinelli, Solving SAT and SAT modulo theories: From an abstract Davis–Putnam–Logemann–Loveland procedure toDPLL(T), Journal of the ACM 53 (6) (2006) 937–977.[105] S. Perri, F. Scarcello, G. Catalano, N. Leone, Enhancing DLV instantiator by backjumping techniques, Annals of Mathematics and Artificial Intelli-gence 51 (2–4) (2007) 195–228.[106] D. Pearce, A new logical characterisation of stable models and answer sets, in: J. Dix, L. Pereira, T. Przymusinski (Eds.), Proceedings of the SixthWorkshop on Non-Monotonic Extensions of Logic Programming (NMELP’96), in: Lecture Notes in Computer Science, vol. 1216, Springer-Verlag, 1996,pp. 57–70.[107] K. Pipatsrisawat, A. Darwiche, A lightweight component caching scheme for satisfiability solvers, in Marques-Silva and Sakallah (2007) [98, pp. 294–299].[108] K. Pipatsrisawat, A. Darwiche, A new clause learning scheme for efficient unsatisfiability proofs, in: D. Fox, C. Gomes (Eds.), Proceedings of theTwenty-Third National Conference on Artificial Intelligence (AAAI’08), AAAI Press, 2008, pp. 1481–1484.M. Gebser et al. / Artificial Intelligence 187–188 (2012) 52–8989[109] K. Pipatsrisawat, A. Darwiche, On the power of clause-learning SAT solvers as resolution engines, Artificial Intelligence 175 (2) (2011) 512–525.[110] Potassco, http://potassco.sourceforge.net.[111] P. Purdom, A transitive closure algorithm, BIT Numerical Mathematics 10 (1970) 76–94.[112] F. Ricca, W. Faber, N. Leone, A backjumping technique for disjunctive logic programming, AI Communications 19 (2) (2006) 155–172.[113] F. Rossi, P. van Beek, T. Walsh (Eds.), Handbook of Constraint Programming, Elsevier, 2006.[114] O. Roussel, V. Manquinho, Pseudo-Boolean and cardinality constraints, in: A. Biere, et al. (Eds.), Handbook of Satisfiability, in: Frontiers in ArtificialIntelligence and Applications, vol. 185, IOS Press, 2009, pp. 695–733, Chapter 22.[115] L. Ryan, Efficient algorithms for clause-learning SAT solvers, Master’s thesis, Simon Fraser University, 2004.[116] V. Ryvchin, O. Strichman, Local restarts, in Kleine Büning and Zhao (2008) [81, pp. 271–276].[117] J. Schlipf, The expressive powers of the logic programming semantics, Journal of Computer and System Sciences 51 (1995) 64–86.[118] L. Schneidenbach, B. Schnor, M. Gebser, R. Kaminski, B. Kaufmann, T. Schaub, Experiences running a parallel answer set solver on Blue Gene, in:M. Ropo, J. Westerholm, J. Dongarra (Eds.), Proceedings of the Sixteenth European PVM/MPI Users’ Group Meeting on Recent Advances in ParallelVirtual Machine and Message Passing Interface (PVM/MPI’09), in: Lecture Notes in Computer Science, vol. 5759, Springer-Verlag, 2009, pp. 64–72.[119] P. Simons, I. Niemelä, T. Soininen, Extending and implementing the stable model semantics, Artificial Intelligence 138 (1–2) (2002) 181–234.[120] T. Syrjänen, Lparse 1.0 user’s manual, http://www.tcs.hut.fi/Software/smodels/lparse.ps.gz.[121] R. Tarjan, Depth-first search and linear graph algorithms, SIAM Journal on Computing 1 (2) (1972) 146–160.[122] M. Thielscher, Answer set programming for single-player games in general game playing, in Hill and Warren (2009) [73, pp. 327–341].[123] G. Tseitin, On the complexity of derivation in propositional calculus, in: A. Slisenko (Ed.), Structures in Constructive Mathematics and MathematicalLogic, part 2, Consultants Bureau, 1970, pp. 115–125.[124] A. Van Gelder, K. Ross, J. Schlipf, The well-founded semantics for general logic programs, Journal of the ACM 38 (3) (1991) 620–650.[125] M. Veloso (Ed.), Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI’07), AAAI Press/MIT Press, 2007.[126] J. Ward, J. Schlipf, Answer set programming with clause learning, in: V. Lifschitz, I. Niemelä (Eds.), Proceedings of the Seventh International Conferenceon Logic Programming and Nonmonotonic Reasoning (LPNMR’04), in: Lecture Notes in Artificial Intelligence, vol. 2923, Springer-Verlag, 2004, pp. 302–313.[127] L. Zhang, C. Madigan, M. Moskewicz, S. Malik, Efficient conflict driven learning in a Boolean satisfiability solver, in: Proceedings of the InternationalConference on Computer-Aided Design (ICCAD’01), 2001, pp. 279–285.[128] L. Zhang, S. Malik, Validating SAT solvers using an independent resolution-based checker: Practical implementations and other applications, in:Proceedings of the Sixth Conference on Design, Automation and Test in Europe (DATE’03), IEEE Press, 2003, pp. 10880–10885.