Artificial Intelligence 175 (2011) 1856–1875Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintMonte-Carlo tree search and rapid action value estimation incomputer GoSylvain Gelly a,1, David Silver b,∗a Université Paris Sud, LRI, CNRS, INRIA, Franceb University College London, UKa r t i c l ei n f oa b s t r a c tArticle history:Received 27 October 2010Received in revised form 22 March 2011Accepted 30 March 2011Available online 6 April 2011Keywords:Computer GoMonte-CarloSearchReinforcement learning1. IntroductionA new paradigm for search, based on Monte-Carlo simulation, has revolutionised theperformance of computer Go programs. In this article we describe two extensions tothe Monte-Carlo tree search algorithm, which significantly improve the effectiveness ofthe basic algorithm. When we applied these two extensions to the Go program MoGo, itbecame the first program to achieve dan (master) level in 9 × 9 Go. In this article we surveythe Monte-Carlo revolution in computer Go, outline the key ideas that led to the successof MoGo and subsequent Go programs, and provide for the first time a comprehensivedescription, in theory and in practice, of this extended framework for Monte-Carlo treesearch.© 2011 Elsevier B.V. All rights reserved.Monte-Carlo tree search [1] is a new paradigm for search, which has revolutionised computer Go [2,3], and is rapidlyreplacing traditional search algorithms as the method of choice in challenging domains such as General Game Playing [4],Amazons [5], Lines of Action [6], multi-player card games [7,8], and real-time strategy games [9].The key idea is to simulate many thousands of random games from the current position, using self-play. New positionsare added into a search tree, and each node of the tree contains a value that predicts who will win from that position. Thesepredictions are updated by Monte-Carlo simulation: the value of a node is simply the average outcome of all simulatedgames that visit the position. The search tree is used to guide simulations along promising paths, by selecting the childnode with the highest potential value [10]. This results in a highly selective search that very quickly identifies good movesequences.The evaluation function of Monte-Carlo tree search depends only on the observed outcomes of simulations, rather thanthe handcrafted evaluation functions used in traditional search algorithms. The evaluation function continues to improvefrom additional simulations; given infinite memory and computation, it will converge on the optimal search tree [10].Furthermore, Monte-Carlo tree search develops in a highly selective, best-first manner, expanding promising regions of thesearch space much more deeply.In this article we describe two major enhancements to Monte-Carlo tree search. The first extension, the Rapid ActionValue Estimation (RAVE) algorithm, shares the value of actions across each subtree of the search tree. RAVE forms a very fastand rough estimate of the action value; whereas normal Monte-Carlo is slower but more accurate. The MC–RAVE algorithmcombines these two value estimates in a principled fashion, so as to minimise the mean squared error.* Corresponding author.E-mail addresses: sylvain.gelly@m4x.org (S. Gelly), davidstarsilver@googlemail.com (D. Silver).1 Now at Google, Zurich.0004-3702/$ – see front matter © 2011 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2011.03.007S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18751857The second extension, heuristic Monte-Carlo tree search, uses a heuristic function to initialise the values of new positionsin the search tree. We demonstrate that an effective heuristic function can be learnt by temporal-difference learning andself-play; however, in general any heuristic can be provided to the algorithm.We applied these two extensions to the Go program MoGo, achieving a significant improvement to its performance in9 × 9 Go. The resulting program became the first program to achieve dan (master) level, and the first program to defeat ahuman professional player. This framework for Monte-Carlo tree search is now used in a wide variety of master-level Goprograms, including the first programs to achieve dan level at 19 × 19 Go.This article provides the first comprehensive description of this extended framework for Monte-Carlo tree search. It addsnew theory, results, pseudocode, and discussion to the original presentation of heuristic MC–RAVE [11,3,12]. In addition, weinclude a survey of the strongest Go programs based on prior approaches, and the strongest current programs based onMonte-Carlo methods.2. Simulation-based search2.1. Two-player gamesWe consider the class of two-player, perfect-information, zero-sum games such as chess, checkers, backgammon and Go.Without loss of generality, we call the player to move first Black and the player to move second White. Black and Whitealternate turns, at each turn t selecting an action at ∈ A(st), where st ∈ S is the current state, S is a finite state space, andA(s) is a finite set of legal actions in state s. The game finishes upon reaching a terminal state with outcome z. Black’s goalis to maximise z; White’s goal is to minimise z.We define a two-player policy π (s, a) = Pr(a|s) to be a stochastic action selection strategy that determines the probabilityof selecting actions in any given state. It consists of both a Black policy πB (s, a) that is used for Black moves, and a Whitepolicy πW (s, a) that is used for White moves, π = (cid:4)πB , πW (cid:5). We define the value function Q π (s, a) to be the expectedoutcome after playing action a in state s, and then following policy π for both players until termination,2Q π (s, a) = Eπ [z | st = s, at = a] ∀s ∈ S, a ∈ A(s).(1)∗(s, a) is the value function that maximises Black’s action value and minimises White’sThe minimax value function Qaction value, from every state and for every action,∗Q(s, a) = maxπBminπWQ π (s, a) ∀s ∈ S, a ∈ A(s).(2)A minimax policy deterministically plays Black moves so as to maximise Q∗(s, a). This is commonly called perfect play.Q∗(s, a), and plays White moves to minimise2.2. SimulationThe basic idea of simulation-based search [13] is to evaluate states online from simulated games. Each simulated game,which we call a simulation, starts from a root state s0, and sequentially samples states and actions, without backtracking,until the game terminates. At each step t of simulation, a simulation policy π (s, a) is used to select an action, at ∼ π (st , ·),and the rules of the game are used to generate the next state st+1. The outcome z of each simulated game is used to updatethe values of states or actions encountered during that simulation.2.3. Monte-Carlo simulationMonte-Carlo simulation is a simple simulation-based search algorithm for evaluating candidate actions from a rootstate s0. The search proceeds by simulating complete games from s0 until termination, using a fixed simulation policy,for example selecting actions uniformly amongst all legal moves. The value of each action a from s0, is estimated by themean outcome of all simulations starting with candidate action a.Monte-Carlo simulation provides a simple method for estimating the root value Q π (s0, a). N(s) complete games aresimulated by self-play with policy π from state s. The Monte-Carlo value (MC value) Q (s, a) is the mean outcome of allsimulations in which action a was selected in state s,Q (s, a) = 1N(s, a)N(s)(cid:2)i=1Ii(s, a)zi,(3)2 In two-player games a state is usually called a position and an action is usually called a move. The goodness of positions or moves is estimated by anevaluation function. We use these terms during informal discussions, but use state, action and value function in their precise sense.1858S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–1875where zi is the outcome of the ith simulation; Ii(s, a) is an indicator function returning 1 if action a was selected in state(cid:3)s during the ith simulation, and 0 otherwise; and N(s, a) =Ii(s, a) counts the total number of simulations in whichaction a was selected in state s.N(s)i=1In its most basic form, Monte-Carlo simulation is only used to evaluate actions, but not to improve the simulation policy.However, the basic algorithm can be extended by progressively favouring the most successful actions, or by progressivelypruning away the least successful actions [14,15].In some problems, such as backgammon [16], Scrabble [17], Amazons [5] and Lines of Action [6], it is possible to con-struct an accurate evaluation function. In these cases it can be beneficial to stop simulation before the end of the game, andbootstrap from the estimated value at the time of stopping. This approach, known as truncated Monte-Carlo simulation, bothincreases the simulation speed, and also reduces the variance of Monte-Carlo evaluation. In more challenging problems,such as Go [15], it is hard to construct an accurate evaluation function. In this case truncating simulations usually increasesthe evaluation bias more than it reduces the evaluation variance, and so it is better to simulate until termination.2.4. Monte-Carlo tree searchMonte-Carlo tree search (MCTS) uses Monte-Carlo simulation to evaluate the nodes of a search tree [1]. The values in thesearch tree are then used to select the best action during subsequent simulations. Monte-Carlo tree search is sequentiallybest-first: it selects the best child at each step of simulation. This allows the search to continually refocus its attention,each simulation, on the highest value regions of the state space. As the search tree grows larger, the values of the nodesapproximate the minimax value, and the simulation policy approximates the minimax policy.The search tree T contains one node, n(s), corresponding to each state s that has been seen during simulations. Eachnode contains a total count for the state, N(s), and an action value Q (s, a) and count N(s, a) for each action a ∈ A.Simulations start from the root state s0, and are divided into two stages. When state st is represented in the search tree,st ∈ T , a tree policy is used to select actions. Otherwise, a default policy is used to roll out simulations to completion. Thesimplest version of the algorithm, which we call greedy MCTS, selects the greedy action with the highest value during thefirst stage, argmaxa Q (st, a); and selects actions uniformly at random during the second stage.Every state and action in the search tree is evaluated by its mean outcome during simulations. After each simulations0, a0, s1, a1, . . . , sT with outcome z, each node in the search tree, {n(st) | st ∈ T }, updates its count, and updates its actionvalue Q (st, at) to the new MC value (Eq. (3)). This update can also be implemented incrementally, without reconsideringprevious simulations, by incrementing the count and updating the value towards the outcome z.3N(st) ← N(st ) + 1,N(st, at) ← N(st, at) + 1,Q (st, at) ← Q (st, at) + z − Q (st, at)N(st, at).(4)(5)(6)In addition, each visited node is added to the search tree. In practice, to reduce memory requirements, new nodes arenot added for every simulation. Typically, just one new node is added to the search tree in each simulation. The firststate encountered, that is not already represented in the tree, is added into the search tree. If memory limitations are stillan issue, it is also possible to wait several simulations before adding a new node, or to prune old nodes as the searchprogresses. Fig. 1 illustrates several steps of the MCTS algorithm.It is also possible to compute other statistics by Monte-Carlo tree search, for example the max outcome, which mayevaluate positions more rapidly but is also sensitive to outliers [15], or an intermediate statistic between mean and maxoutcome [1]. However, the mean outcome has proven to be the most robust and effective statistic in Go and other domains.2.5. UCTGreedy action selection can often be an inefficient way to construct a search tree, as it will typically avoid searchingactions after one or more poor outcomes, even if there is significant uncertainty about the value of those actions. To explorethe search tree more efficiently, the principle of optimism in the face of uncertainty can be applied, which favours the actionswith the greatest potential value. To implement this principle, each action value receives a bonus that corresponds to theamount of uncertainty in the current value of that state and action.The UCT algorithm applies this principle to Monte-Carlo tree search, by treating each state of the search tree as a multi-armed bandit, in which each action corresponds to an arm of the bandit [10].4 The tree policy selects actions by using theUCB1 algorithm, which maximises an upper confidence bound on the value of actions [18]. Specifically, the action value is3 This incremental formulation may accumulate error, and in practice it usually requires double precision.4 In fact, the search tree is not a true multi-armed bandit, as there is no real cost to exploration during planning. In addition the simulation policycontinues to change as the search tree is updated, which means that the payoff is non-stationary.S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18751859Fig. 1. Five simulations of a simple Monte-Carlo tree search. Each simulation has an outcome of 1 for a black win or 0 for a white win (square). At eachsimulation a new node (star) is added into the search tree. The value of each node in the search tree (circles and star) is then updated to count the numberof black wins, and the total number of visits (wins/visits).augmented by an exploration bonus that is highest for rarely visited state-action pairs, and the tree policy selects the actionamaximising the augmented value,∗(cid:4)log N(s)N(s, a),⊕Q(s, a) = Q (s, a) + c∗ = argmaxaQ⊕(s, a)a(7)(8)where c is a scalar exploration constant and log is the natural logarithm. Pseudocode for the UCT algorithm is given inAlgorithm 1.1860S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–1875Algorithm 1 Two-player UCTprocedure UctSearch(s0)while time available doSimulate(board, s0)end whileboard.SetPosition(s0)return SelectMove(board, s0, 0)end procedureprocedure Simulate(board, s0)board.SetPosition(s0)[s0, . . . , sT ] = SimTree(board)z = SimDefault(board)Backup([s0, . . . , sT ], z)end procedureprocedure SimTree(board)c = exploration constantt = 0while not board.GameOver() dost = board.GetPosition()if st /∈ tree thenNewNode(st )return [s0, . . . , st ]end ifa = SelectMove(board, st , c)board.Play(a)t = t + 1end whilereturn [s0, . . . , st−1]end procedureprocedure SimDefault(board)while not board.GameOver() doa = DefaultPolicy(board)board.Play(a)end whilereturn board.BlackWins()end procedureprocedure SelectMove(board, s, c)legal = board.Legal()if board.BlackToPlay() then∗ = argmaxa∈legal(cid:5)elsea(cid:5)Q (s, a) + c∗ = argmina∈legalaQ (s, a) − c(cid:6)(cid:6)(cid:7)(cid:7)log N(s)N(s,a)log N(s)N(s,a)end ifreturn aend procedure∗procedure Backup([s0, . . . , sT ], z)for t = 0 to T doN(st ) = N(st ) + 1N(st , at ) + = 1Q (st , at ) + = z−Q (st ,at )N(st ,at )end forend procedureprocedure NewNode(s)tree.Insert(s)N(s) = 0for all a ∈ A doN(s, a) = 0Q (s, a) = 0end forend procedureUCT is proven to converge on the minimax action value function [10]. As the number of simulations N grows to infinity,∗(s0, a). Furthermore,∗(s0, a)], is O (log(n)/n), and the probability of selecting a suboptimal action,the root values converge in probability to the minimax action values, ∀a ∈ A, plimn→∞ Q (s0, a) = Qthe bias of the root values, E[Q (s0, a) − QPr(argmaxa∈A Q (s0, a) (cid:12)= argmaxa∈A Q∗(s0, a)), converges to zero at a polynomial rate.The performance of UCT can often be significantly improved by incorporating domain knowledge into the default policy[19,20]. The UCT algorithm, using a carefully chosen default policy, has outperformed previous approaches to search in avariety of challenging games, including Go [19], General Game Playing [4], Amazons [5], Lines of Action [6], multi-playercard games [7,8], and real-time strategy games [9]. Much additional research in Monte-Carlo tree search has been developedin the context of computer Go, and is discussed in more detail in the next section.3. Computer GoFor many years, computer chess was considered to be “the drosophila of AI”,5 and a “grand challenge task” [21]. Itprovided a sandbox for new ideas, a straightforward performance comparison between algorithms, and measurable progressagainst human capabilities. With the dominance of alpha–beta search programs over human players now conclusive inchess [22], many researchers have sought out a new challenge. Computer Go has emerged as the “new drosophila of AI”[21], a “task par excellence” [23], and “a grand challenge task for our generation” [24].Go has more than 10170 states and up to 361 legal moves. Its enormous search space is orders of magnitude too bigfor the alpha–beta search algorithms that have proven so successful in chess and checkers. Although the rules are simple,the emergent complexity of the game is profound. The long-term effect of a move may only be revealed after 50 or 100additional moves. Professional Go players accumulate Go knowledge over a lifetime; mankind has accumulated Go knowl-edge over several millennia. For the last 30 years, attempts to encode this knowledge in machine usable form have led to apositional understanding that is at best comparable to weak amateur-level humans.5 Drosophila is the fruit fly, the most extensively studied organism in genetics research.S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18751861Fig. 2. a) The White stones are in atari and can be captured by playing at the points marked A. It is illegal for Black to play at B, as the stone would haveno liberties. Black may, however, play at C to capture the stone at D. It is illegal for White to recapture immediately by playing at D, as this would repeatthe position – it is a ko. b) The points marked E are eyes for Black. The black groups on the left can never be captured by White, they are alive. The pointsmarked F are false eyes: the black stones on the right will eventually be captured by White and are dead. c) Groups of loosely connected white stones (G)) are removed from the board. All surrounded intersections (B, W ) and all remaining stonesand black stones (H ). d) A final position. Dead stones (B(b, w) are counted for each player. If komi is 6.5 then Black wins by 8.5 points in this example.∗, W∗Fig. 3. Performance ranks in Go, in increasing order of strength from left to right.3.1. The rules of GoThe game of Go is usually played on a 19 × 19 grid, with 13 × 13 and 9 × 9 as popular alternatives. Black and White playalternately, placing a single stone on an intersection of the grid. Stones cannot be moved once played, but may be captured.Sets of adjacent, connected stones of one colour are known as blocks. The empty intersections adjacent to a block are calledits liberties. If a block is reduced to zero liberties by the opponent, it is captured and removed from the board (Fig. 2a, A).Stones with just one remaining liberty are said to be in atari. Playing a stone with zero liberties is illegal (Fig. 2a, B), unlessit also reduces an opponent block to zero liberties. In this case the opponent block is captured, and the player’s stoneremains on the board (Fig. 2a, C ). Finally, repeating a previous board state is illegal.6 A situation in which a repeat couldotherwise occur is known as ko (Fig. 2a, D).A connected set of empty intersections that is wholly enclosed by stones of one colour is known as an eye. One naturalconsequence of the rules is that a block with two eyes can never be captured by the opponent (Fig. 2b, E). Blocks whichcannot be captured are described as alive; blocks which will certainly be captured are described as dead (Fig. 2b, F ).A loosely connected set of stones is described as a group (Fig. 2c, G, H ). Determining the life and death status of a group isa fundamental aspect of Go strategy.The game ends when both players pass. Dead blocks are removed from the board (Fig. 2d, B). In Chinese rules, allalive stones, and all intersections that are enclosed by a player, are counted as a point of territory for that player (Fig. 2d,B, W ).7 Black always plays first in Go; White receives compensation, known as komi, for playing second. The winner is theplayer with the greatest territory, after adding komi for White.∗, W∗3.2. Go ratingsHuman Go players are rated on a three-class scale, divided into kyu (beginner), dan (master), and professional dan ranks(see Fig. 3). Kyu ranks are in descending order of strength, whereas dan and professional dan ranks are in ascending order.At amateur level, the difference in rank corresponds to the number of handicap stones required by the weaker player toensure an even game.8The majority of computer Go programs compete on the Computer Go Server (CGOS). This server runs an ongoing rapid-play tournament of 5 minute games for 9× 9 and 20 minute games for 19× 19 boards. The Elo rating of each program on theserver is continually updated. The Elo scale on CGOS assumes a logistic distribution with winning probability Pr( A beats B)=, where μ A and μB are the Elo ratings for player A and player B respectively. On this scale, a difference of1μB−μ A4001+106 The exact definition of repeating differs subtly between different rule sets.7 The Japanese scoring system is somewhat different, but usually has the same outcome.8 The difference between 1 kyu and 1 dan is normally considered to be 1 stone.1862S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–1875200 Elo corresponds to a 75% winning rate for the stronger player, and a difference of 500 Elo corresponds to a 95% winningrate. Following convention, the open source Go program GnuGo (level 10) anchors this scale with a rating of 1800 Elo.3.3. Handcrafted heuristicsIn many other classic games, handcrafted heuristic functions have proven highly effective. Basic heuristics such as ma-terial count and mobility, which provide reasonable estimates of goodness in checkers, chess and Othello [25], are next toworthless in Go. Stronger heuristics have proven surprisingly hard to design, despite several decades of endeavour [26].Until recently, most Go programs incorporated very large quantities of expert knowledge, in a pattern database containingmany thousands of manually inputted patterns, and typically including expert knowledge such as fuseki (opening patterns),joseki (corner patterns), and tesuji (tactical patterns). Traditional Go programs use these databases to generate plausiblemoves that match one or more patterns. The pattern database accounts for a large part of the development effort in atraditional Go program, sometimes requiring many man-years of effort from expert Go players.The Many Faces of Go9 uses local alpha–beta searches to determine the life or death status of blocks and groups. A globalalpha–beta search is used to evaluate full-board positions, using a heuristic function of the local search results. Patterndatabases are used to generate moves in both the local and global searches. The program GnuGo10 uses pattern databasesand specialised search routines to determine local subgoals such as capture, connection, and eye formation. The local statusof each subgoal is used to estimate the overall benefit of each legal move.3.4. Reinforcement learning in GoReinforcement learning can be used to train a value function that predicts the eventual outcome of the game from agiven state. The learning program can be rewarded by the score at the end of the game, or by a reward of 1 if Black winsand 0 if White wins. Surprisingly, the less informative binary signal has proven more successful [1], as it encourages theagent to favour risky moves when behind, and calm moves when ahead. Expert Go players will frequently play to minimisethe uncertainty in a position once they judge that they are ahead in score; this behaviour cannot be replicated by simplymaximising the expected score. Despite this shortcoming, the final score has been widely used as a reward signal [27–30].Schraudolph et al. [27] exploit the symmetries of the Go board in a convolutional neural network. The network predictsthe final territory status of a particular target intersection. It receives one input from each intersection (−1, 0 or +1 forWhite, Empty and Black respectively) in a local region around the target, and outputs the predicted territory for the targetintersection. The global position is evaluated by summing the territory predictions for all intersections on the board. Weightsare shared between rotationally and reflectionally symmetric patterns of input features, and between all target intersections.They train their multilayer perceptron using TD(0), using a reward signal corresponding to the final territory value of theintersection. The network outperformed a commercial Go program, The Many Faces of Go, when set to a low playing level in9 × 9 Go, after just 3000 self-play training games.Dahl’s Honte [29] and Enzenberger’s NeuroGo III [30] use a similar approach to predicting the final territory. However,both programs learn intermediate features that are used to input additional knowledge into the territory evaluation network.Honte has one intermediate network to predict local moves and a second network to evaluate the life and death status ofgroups. NeuroGo III uses intermediate networks to evaluate connectivity and eyes. Both programs achieved single-digit kyuranks; NeuroGo won the silver medal at the 2003 9 × 9 Computer Go Olympiad.RLGO 1.0 [31] uses a simpler but more computationally efficient approach to reinforcement learning. It uses a millionlocal shape features to enumerate all possible 1 × 1, 2 × 2 and 3 × 3 configurations of Black, White and empty intersections,at every possible location on the board. The value of a state is estimated by a linear combination of the local shape featuresthat are matched in that state. The weights of these features are trained offline by temporal-difference learning from gamesof self-play, and sharing weights between symmetric local shape features. The basic version of RLGO was rated at 1350 Eloon the 9 × 9 Computer Go Server.RLGO 2.4 [32,13] applies the same reinforcement learning approach online. It applies temporal-difference learning tosimulated games of self-play that start from the current state: a form of simulation-based search. At every move, the valuefunction is re-trained in real-time, specialising on the tactics and strategies that are most relevant to the current position.This approach boosted RLGO’s rating to 2100 Elo on CGOS, outperforming traditional Go programs and resulting in thestrongest 9 × 9 Go program not based on Monte-Carlo tree search.3.5. Monte-Carlo simulation in GoIn contrast to traditional search methods, Monte-Carlo simulation evaluates the current position dynamically, rather thanstoring knowledge about all positions in a static evaluation function. This makes it an appealing choice for Go, where, as wehave seen, the number of possible positions is particularly large, and position evaluation is particularly challenging.9 http://www.smart-games.com/manyfaces.html.10 http://www.gnu.org/software/gnugo.S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18751863The first Monte-Carlo Go program, Gobble [33], simulated many games of self-play from the current state s. It combinedMonte-Carlo evaluation with two novel ideas: the all-moves-as-first heuristic, and ordered simulation. The all-moves-as-firstheuristic assumes that the value of a move is not significantly affected by changes elsewhere on the board. The value ofplaying action a immediately is estimated by the average outcome of all simulations in which action a is played at anytime. We formalise this idea more precisely in Section 4.1. Gobble also used ordered simulation to sort all moves accordingto their estimated value. This ordering is randomly perturbed according to an annealing schedule that cools down withadditional simulations. Each simulation then plays out all moves in the prescribed order. Gobble itself played weakly, withan estimated rating of around 25 kyu.Bouzy and Helmstetter developed the first competitive Go programs based on Monte-Carlo simulation [15]. Their basicframework simulates many games of self-play from the current state s, for each candidate action a, using a uniform randomsimulation policy; the value of a is estimated by the average outcome of these simulations. The only domain knowledge is toprohibit moves within eyes; this ensures that games terminate within a reasonable timeframe. Bouzy and Helmstetter alsoinvestigated a number of extensions to Monte-Carlo simulation, several of which are precursors to the more sophisticatedalgorithms used now:1. Progressive pruning is a technique in which statistically inferior moves are removed from consideration [34].2. The all-moves-as-first heuristic, described above.3. The temperature heuristic uses a softmax simulation policy to bias the random moves towards the strongest evalua-e Q (s,a)/τb∈legal e Q (s,b)/τ , where τ is a constant temperaturetions. The softmax policy selects actions with a probability π (s, a) =(cid:3)parameter controlling the overall level of randomness.114. The minimax enhancement constructs a full width search tree, and separately evaluates each node of the search tree byMonte-Carlo simulation. Selective search enhancements were also tried [35].Bouzy also tracked statistics about the final territory status of each intersection after each simulation [36]. This informa-tion is used to influence the simulations towards disputed regions of the board, by avoiding playing on intersections whichare consistently one player’s territory. Bouzy also incorporated pattern knowledge into the simulation player [20]. Usingthese enhancements his program Indigo won the bronze medal at the 2004 and 2006 19 × 19 Computer Go Olympiads.It is surprising that a Monte-Carlo technique, originally developed for stochastic games such as backgammon [16], Poker[14] and Scrabble [17] should succeed in Go. Why should an evaluation that is based on random play provide any useful in-formation in the precise, deterministic game of Go? The answer, perhaps, is that Monte-Carlo methods successfully managethe uncertainty in the evaluation. A random simulation policy generates a broad distribution of simulated games, repre-senting many possible futures and the uncertainty in what may happen next. As the search proceeds and more informationis accrued, the simulation policy becomes more refined, and the distribution of simulated games narrows. In contrast, de-terministic play represents perfect confidence in the future: there is only one possible continuation. If this confidence ismisplaced, then predictions based on deterministic play will be unreliable and misleading. Abramson [37] was the first todemonstrate that the expected value of a game’s outcome under random play is a powerful heuristic for position evaluationin deterministic games.3.6. Monte-Carlo tree search in GoMonte-Carlo tree search was first introduced in the Go program Crazy Stone [1]. The Monte-Carlo value of each action∗(s, a), σ 2(s, a)). During the first stage ofis assumed to be normally distributed about the minimax value, Q (s, a) ∼ N (Qsimulation, the tree policy selects each action according to the estimated probability that its minimax value is better than∗)). During the second stage of simulation, thethe Monte-Carlo value of the best action adefault policy selects moves with a probability proportional to a handcrafted urgency heuristic. Using these techniques,Crazy Stone exceeded 1800 Elo on CGOS, achieving equivalent performance to traditional Go programs such as GnuGo andThe Many Faces of Go. Crazy Stone won the gold medal at the 2006 9 × 9 Computer Go Olympiad.∗(s, a) > Q (s, a, π (s, a) ≈ Pr(Q∗The Go program MoGo introduced the UCT algorithm to computer Go [19,38]. Instead of the Gaussian approximationused in Crazy Stone, MoGo treats each state in the search tree as a multi-armed bandit. There is one arm of the banditfor each legal move, and the payoff from an arm is the outcome of a simulation starting with that move. During the firststage of simulation, the tree policy selects actions using the UCB1 algorithm. During the second stage of simulation, MoGouses a default policy based on specialised domain knowledge. Unlike the enormous pattern databases used in traditional Goprograms, MoGo’s patterns are extremely simple. Rather than suggesting the best move in any situation, these patterns areintended to produce local sequences of plausible moves. They can be summarised by applying four prioritised rules afterany opponent move a:1. If a put some of our stones into atari, play a saving move at random.2. Otherwise, if one of the 8 intersections surrounding a matches a simple pattern for cutting or hane, randomly play one.11 Gradually reducing the temperature, as in simulated annealing, was not beneficial.1864S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18753. Otherwise, if any opponent stone can be captured, play a capturing move at random.4. Otherwise play a random move.The default policy used by MoGo is handcrafted. In contrast, a second version of Crazy Stone uses supervised learningto train the pattern weights for its default policy [2]. The relative strength of patterns is estimated by assigning an Elorating to each pattern, much like a tournament between games players. In this approach, the pattern selected by a humanplayer is considered to have won against all alternative patterns. Crazy Stone uses the minorisation–maximisation algorithmto estimate the Elo rating of simple 3 × 3 patterns and features. The default policy selected actions with a probabilityproportional to the matching pattern strengths. A more complicated set of 17,000 patterns, harvested from expert games,was used to progressively widen the search tree.Using the UCT algorithm, MoGo and Crazy Stone significantly outperformed all previous 9 × 9 Go programs, and beginninga new era in computer Go.4. Rapid action value estimationMonte-Carlo tree search separately estimates the value of each state and each action in the search tree. As a result,it cannot generalise between related positions or related moves. To determine the best move, many simulations must beperformed from all states and for all actions. The RAVE algorithm uses the all-moves-as-first heuristic, from each node of thesearch tree, to estimate the value of each action. RAVE provides a simple way to share knowledge between related nodesin the search tree, resulting in a rapid, but biased estimate of the action values. This biased estimate can often determinethe best move after just a handful of simulations, and can be used to significantly improve the performance of the searchalgorithm.4.1. All-moves-as-firstIn incremental games such as computer Go, the value of a move is often unaffected by moves played elsewhere on theboard. The underlying idea of the all-moves-as-first (AMAF) heuristic [33] (see Section 3.5) is to have one general value foreach move, regardless of when it is played. We define the AMAF value function ˜Q π (s, a) to be the expected outcome zfrom state s, when following joint policy π for both players, given that action a was selected at some subsequent turn,˜Q π (s, a) = Eπ [z | st = s, ∃u (cid:2) t s.t. au = a].(9)The AMAF value function provides a biased estimate of the true action value function. The level of bias, ˜B(s, a), dependson the particular state s and action a,˜Q π (s, a) = Q π (s, a) + ˜B(s, a).(10)Monte-Carlo simulation can be used to approximate ˜Q π (s, a). The all-moves-as-first value ˜Q (s, a) is the mean outcomeof all simulations in which action a is selected at any turn after s is encountered,˜Q (s, a) = 1˜N(s, a)N(s)(cid:2)i=1˜Ii(s, a)zi,(11)where ˜Ii(s, a) is an indicator function returning 1 if state s was encountered at any step t of the ith simulation, and action˜Ii(s, a) counts the total number of simulations useda was selected at any step u (cid:2) t, or 0 otherwise; and ˜N(s, a) =to estimate the AMAF value. Note that Black moves and White moves are considered to be distinct actions, even if they areplayed at the same intersection.N(s)i=1(cid:3)In order to select the best move with reasonable accuracy, Monte-Carlo simulation requires many simulations fromevery candidate move. The AMAF heuristic provides orders of magnitude more information: every move will typically havebeen tried on several occasions, after just a handful of simulations. If the value of a move really is unaffected, at leastapproximately, by moves played elsewhere, then this can result in a much faster rough estimate of the value.4.2. RAVEThe RAVE algorithm (Fig. 4) combines Monte-Carlo tree search with the all-moves-as-first heuristic. Instead of computingthe MC value (Eq. (3)) of each node of the search-tree, (s, a) ∈ T , the AMAF value (Eq. (11)) of each node is computed.Every state in the search tree, s ∈ T , is the root of a subtree τ (s) ⊆ S. If a simulation visits state st at step t, then allsubsequent states visited in that simulation, su such that u (cid:2) t, are in the subtree of st , su ∈ τ (st). This includes all statessu /∈ T visited by the default policy in the second stage of simulation.The basic idea of RAVE is to generalise over subtrees. The assumption is that the value of action a in state s will besimilar from all states within subtree τ (s). Thus, the value of a is estimated from all simulations starting from s, regardlessof exactly when a is played.S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18751865Fig. 4. An example of using the RAVE algorithm to estimate the value of Black moves a and b from state s. Six simulations have been executed from state s,with outcomes shown in the bottom squares. Playing move a immediately led to two losses, and so Monte-Carlo estimation favours move b. However,playing move a at any subsequent time led to three wins out of five, and so the RAVE algorithm favours move a. Note that the simulation starting withmove a from the root node does not belong to the subtree τ (s) and does not contribute to the AMAF estimate ˜Q (s, a).When the AMAF values are used to select an action at in state st , the action with maximum AMAF value in subtree τ (st)˜Q (sk, ·), from ancestor˜Q (st, b). In principle it is also possible to incorporate the AMAF values,is selected, at = argmaxbsubtrees, τ (sk) such that k < t. However, in our experiments, combining ancestor AMAF values did not appear to confer anyadvantage.RAVE is closely related to the history heuristic in alpha–beta search [39]. During the depth-first traversal of the searchtree, the history heuristic remembers the success12 of each move at various depths; the most successful moves are triedfirst in subsequent positions. RAVE is similar, but because it is a best-first not depth-first search, it must store values foreach subtree. In addition, RAVE takes account of the success of moves made outside of the search tree by the default policy.4.3. MC–RAVEThe RAVE algorithm learns very quickly, but it is often wrong. The principal assumption of RAVE, that a particular movehas the same value across an entire subtree, is frequently violated. There are many situations, for example during tacticalbattles, in which nearby changes can completely change the value of a move: sometimes rendering it redundant; sometimesmaking it even more vital. Even distant moves can significantly affect the value of a move, for example playing a ladder–breaker in one corner can radically alter the value of playing a ladder in the opposite corner.The MC–RAVE algorithm overcomes this issue, by combining the rapid learning of the RAVE algorithm with the accuracyand convergence guarantees of Monte-Carlo tree search.There is one node n(s) for each state s in the search tree. Each node contains a total count N(s), and for each a ∈ A, anMC value Q (s, a), AMAF value ˜Q (s, a), MC count N(s, a), and AMAF count ˜N(s, a).To estimate the overall value of action a in state s, we use a weighted sum Q (cid:5)(s, a) of the MC value Q (s, a) and theAMAF value ˜Q (s, a),(cid:5)Q (cid:5)(s, a) =(cid:7)1 − β(s, a)Q (s, a) + β(s, a) ˜Q (s, a)(12)where β(s, a) is a weighting parameter for state s and action a. It is a function of the statistics for (s, a) stored in node n(s),and provides a schedule for combining the MC and AMAF values. When only a few simulations have been seen, we weightthe AMAF value more highly, β(s, a) ≈ 1. When many simulations have been seen, we weight the Monte-Carlo value morehighly, β(s, a) ≈ 0.As with Monte-Carlo tree search, each simulation is divided into two stages. During the first stage, for states within thesearch tree, st ∈ T , actions are selected greedily, so as to maximise the combined MC and AMAF value, a = argmaxb Q (cid:5)(st, b).During the second stage of simulation, for states beyond the search tree, st /∈ T , actions are selected by a default policy.12 A successful move in alpha–beta either causes a cut-off, or has the best minimax value.1866S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–1875After each simulation s0, a0, s1, a1, . . . , sT with outcome z, both the MC and AMAF values are updated. For every state stin the simulation that is represented in the search tree, st ∈ T , the values and counts of the corresponding node n(st) areupdated,N(st) ← N(st ) + 1,N(st, at) ← N(st, at) + 1,Q (st, at) ← Q (st, at) + z − Q (st, at)N(st, at).(13)(14)(15)In addition, the AMAF value is updated for every subtree. For every state st in the simulation that is represented in thetree, st ∈ T , and for every subsequent action of the simulation au with the same colour to play, i.e. u (cid:2) t and t = u mod 2,the AMAF value of (st, au) is updated according to the simulation outcome z,˜N(st, au) ← ˜N(st, au) + 1,˜Q (st , au) ← ˜Q (st, au) + z − ˜Q (st , au)˜N(st, au).(16)(17)If multiple moves are played at the same intersection during a simulation, then this update is only performed for thefirst move at the intersection. If an action au is legal in state su , but illegal in state st , then no update is performed for thismove.4.4. UCT–RAVEThe UCT algorithm extends Monte-Carlo tree search to use the optimism-in-the-face-of-uncertainty principle, by incor-porating a bonus based on an upper confidence bound of the current value. Similarly, the MC–RAVE algorithm can alsoincorporate an exploration bonus,(cid:4)Q⊕(cid:5) (s, a) = Q (cid:5)(s, a) + clog N(s)N(s, a).Actions are then selected during the first stage of simulation to maximise the augmented value, a = argmaxb QWe call this algorithm UCT–RAVE.13If the schedule decreases to zero in all nodes, ∀s ∈ T , a ∈ A, limN→∞ β(s, a) = 0, then the asymptotic behaviour of UCT–RAVE is equivalent to UCT. The asymptotic convergence properties of UCT (see Section 2) therefore also apply to UCT–RAVE.We now describe two different schedules which have this property.4.5. Hand-selected scheduleOne hand-selected schedule for MC–RAVE uses an equivalence parameter k,(cid:4)β(s, a) =k3N(s) + k(19)where k specifies the number of simulations at which the Monte-Carlo value and the AMAF value should be given equalweight, β(s, a) = 12 ,(cid:4)k3N(s) + k,121==k3N(s) + k,4k = N(s).(20)(21)(22)We tested MC–RAVE in the Go program MoGo, using the hand-selected schedule in Eq. (19) and the default policydescribed in [19], for different settings of the equivalence parameter k. For each setting, we played a 2300 game matchagainst GnuGo 3.7.10 (level 10). The results are shown in Fig. 5, and compared to Monte-Carlo tree search, using 3000simulations per move for both algorithms. The winning rate using MC–RAVE varied between 50% and 60%, compared to 24%13 The original UCT–RAVE algorithm also included the RAVE count in the exploration term [11]. However, it is hard to justify explicit RAVE exploration:many actions will be evaluated by AMAF, regardless of which action is actually selected at turn t.(18)⊕(cid:5) (s, b).S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18751867Fig. 5. Winning rate of MC–RAVE with 3000 simulations per move against GnuGo 3.7.10 (level 10) in 9 × 9 Go, for different settings of the equivalenceparameter k. The bars indicate the standard error. Each point of the plot is an average over 2300 complete games.without RAVE. Maximum performance is achieved with an equivalence parameter of 1000 or more, indicating that the rapidaction value estimate is more reliable than standard Monte-Carlo simulation until several thousand simulations have beenexecuted from state s.4.6. Minimum MSE scheduleThe schedule presented in Eq. (19) is somewhat heuristic in nature. We now develop a more principled schedule, whichselects β(s, a) so as to minimise the mean squared error in the combined estimate Q (cid:5)(s, a).4.6.1. AssumptionsTo derive our schedule, we make a simplified statistical model of MC–RAVE. Our first assumption is that the policy πis held constant. Under this assumption, the outcome of each Monte-Carlo simulation, when playing action a from state s,is an independent and identically distributed (i.i.d.) Bernoulli random variable. Furthermore, the outcome of each AMAFsimulation, when playing action a at any turn following state s, is also an i.i.d. Bernoulli random variable,Pr(z = 1 | st = s, at = a) = Q π (s, a),Pr(z = 0 | st = s, at = a) = 1 − Q π (s, a),Pr(z = 1 | st = s, ∃u (cid:2) t s.t. au = a) = ˜Q π (s, a),Pr(z = 0 | st = s, ∃u (cid:2) t s.t. au = a) = 1 − ˜Q π (s, a).(23)(24)(25)(26)It follows that the total number of wins, after N(s, a) simulations in which action a was played from state s, is binomiallydistributed. Similarly, the total number of wins, after ˜N(s, a) simulations in which action a was played at any turn followingstate s, is binomially distributed,N(s, a)Q (s, a) ∼ Binomial˜N(s, a) ˜Q (s, a) ∼ Binomial(cid:5)(cid:5)(cid:7)N(s, a), Q π (s, a)(cid:7)˜N(s, a), ˜Q π (s, a),.(27)(28)Our second assumption is that these two distributions are independent, so that the MC and AMAF values are uncorre-lated. In fact, the same simulations used to compute the MC value are also used to compute the AMAF value, which meansthat the values are certainly correlated. Furthermore, as the tree develops over time, the simulation policy changes. Thismeans that outcomes are not i.i.d. and that the total number of wins is not in fact binomially distributed. Nevertheless, webelieve that these simplifications do not significantly affect the performance of the schedule in practice.4.6.2. DerivationTo simplify our notation, we consider a single state s and action a. We denote the number of Monte-Carlo simulationsby n = N(s, a) and the number of simulations used to compute the AMAF value by ˜n = ˜N(s, a), and abbreviate the schedule1868S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–1875by β = β(s, a). We denote the estimated mean, bias (with respect to Q π (s, a)) and variance of the MC, AMAF and combinedvalues respectively by μ, ˜μ, μ(cid:5); b, ˜b, b(cid:5) and σ 2, ˜σ 2, σ 2(cid:5) , and the mean squared error of the combined value by e2(cid:5) ,μ = Q (s, a),˜μ = ˜Q (s, a),μ(cid:5) = Q (cid:5)(s, a),b = Q π (s, a) − Q π (s, a) = 0,˜b = ˜Q π (s, a) − Q π (s, a) = ˜B(s, a),b(cid:5) = Q π(cid:5) (s, a) − Q π (s, a),(cid:8)(cid:5)σ 2 = E2(cid:8)(cid:5)(cid:8)(cid:5)(cid:7)Q (s, a) − Q π (s, a)(cid:7)˜Q (s, a) − ˜Q π (s, a)(cid:7)Q (cid:5)(s, a) − Q π(cid:5) (s, a)(cid:7)Q (cid:5)(s, a) − Q π (s, a)222(cid:10)(cid:9)(cid:9) N(s, a) = n,(cid:9)(cid:10)(cid:9) ˜N(s, a) = ˜n,(cid:9)(cid:9) N(s, a) = n, ˜N(s, a) = ˜n(cid:9)(cid:10)(cid:9) N(s, a) = n, ˜N(s, a) = ˜n.(cid:10),˜σ 2 = E= Eσ 2(cid:5)= Ee2(cid:5)(cid:8)(cid:5)e2(cid:5)= σ 2(cid:5)+ b2(cid:5)= (1 − β)2σ 2 + β 2 ˜σ 2 += (1 − β)2σ 2 + β 2 ˜σ 2 + β 2 ˜b2.(cid:5)β ˜b + (1 − β)b(cid:7)2Differentiating with respect to β and setting to zero,0 = 2β ˜σ 2 − 2(1 − β)σ 2 + 2β ˜b2,β =σ 2σ 2 + ˜σ 2 + ˜b2.˜σ 2 =σ 2 = Q π (s, a)(1 − Q π (s, a))N(s, a)˜Q π (s, a)(1 − ˜Q π (s, a))˜N(s, a)˜nn + ˜n + n˜n˜b2/μ(cid:5)(1 − μ(cid:5))In roughly even positions, μ(cid:5) ≈ 1β =≈ μ(cid:5)(1 − μ(cid:5))n≈ μ(cid:5)(1 − μ(cid:5))˜n,,.2 , we can further simplify the schedule,β =˜nn + ˜n + 4n˜n˜b2.We start by decomposing the mean squared error of the combined value into the bias and variance of the MC and AMAFvalues respectively, making use of our second assumption that these values are independently distributed,We now make use of our first assumption that the MC and AMAF values are binomially distributed, and estimate theirvariance,(29)(30)(31)(32)(33)(34)(35)(36)(37)(38)(39)(40)(41)(42)(43)(44)(45)(46)(47)This equation still includes one unknown constant: the RAVE bias ˜b. This can either be evaluated empirically (by testingthe performance of the algorithm with various constant values of ˜b), or by machine learning (by learning to predict theerror between the AMAF value and the MC value, after many simulations). The former method is simple and effective; butthe latter method could allow different biases to be identified for different types of position.4.6.3. ResultsWe compared the performance of MC–RAVE using the minimum MSE schedule, using the approximation in Eq. (47), tothe hand-selected schedule in Eq. (19). For the minimum MSE schedule, we first identified the best constant RAVE bias inempirical tests. On a 9 × 9 board, the performance of MoGo using the minimum MSE schedule increased by 80 Elo (seeTable 1). On a 19 × 19 board, the improvement was more than 100 Elo.S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18751869Table 1Winning rate of MoGo against GnuGo 3.7.10 (level 10) when the number of simulations per move is increased. MoGocompeted on CGOS, using heuristic MC–RAVE and the hand-selected schedule, in February 2007. The versions using10 minutes per game modify the simulations per move according to the available time, from 300,000 games in theopening to 20,000 in the endgame. The asterisked version competed on CGOS in April 2007 using the minimumMSE schedule and additional parameter tuning.ScheduleHand-selectedHand-selectedHand-selectedMinimum MSEComputationWins vs. GnuGoCGOS rating3000 sims per move10,000 sims per move10 minutes per game10 minutes per game69%82%92%97%196021102320∗24805. Heuristic prior knowledgeWe now introduce our second extension to Monte-Carlo tree search, heuristic MCTS. If a particular state s and action a israrely encountered during simulation, then its Monte-Carlo value estimate is highly uncertain and very unreliable. Further-more, because the search tree branches exponentially, the vast majority of nodes in the tree are only experienced rarely.The situation at the leaf nodes is worst of all: by definition each leaf node has been visited only once (otherwise a childnode would have been added).In order to reduce the uncertainty for rarely encountered positions, we incorporate prior knowledge by using a heuristicevaluation function H(s, a) and a heuristic confidence function C(s, a). When a node is first added to the search tree, it isinitialised according to the heuristic function, Q (s, a) = H(s, a) and N(s, a) = C(s, a). The confidence in the heuristic functionis measured in terms of equivalent experience: the number of simulations that would be required in order to achieve aMonte-Carlo value of similar accuracy to the heuristic value.14 After initialisation, the value and count are updated as usual,using standard Monte-Carlo simulation.5.1. Heuristic MC–RAVEThe heuristic Monte-Carlo tree search algorithm can be combined with the MC–RAVE algorithm, described in pseudocodein Algorithm 2. When a new node n(s) is added to the tree, and for all actions a ∈ A, we initialise both the MC and AMAFvalues to the heuristic evaluation function, and initialise both counts to heuristic confidence functions C and ˜C respectively,Q (s, a) ← H(s, a),N(s, a) ← C(s, a),˜Q (s, a) ← H(s, a),˜N(s, a) ← ˜C(s, a),(cid:2)N(s) ←N(s, a).a∈A(48)(49)(50)(51)(52)We compare four heuristic evaluation functions in 9 × 9 Go, using the heuristic MC–RAVE algorithm in the programMoGo.1. The even-game heuristic, Q even(s, a) = 0.5, makes the assumption that most positions encountered between strong play-ers are likely to be close.2. The grandfather heuristic, Q grand(st, a) = Q (st−2, a), sets the value of each node in the tree to the value of its grandfa-ther. This assumes that the value of a Black move is usually similar to the value of that move, last time Black was toplay.3. The handcrafted heuristic, Q mogo(s, a), is based on the pattern-based rules that were successfully used in MoGo’s defaultpolicy. The heuristic was designed such that moves matching a “good” pattern were assigned a value of 1, movesmatching a “bad” pattern were given value 0, and all other moves were assigned a value of 0.5. The good and badpatterns were identical to those used in MoGo, such that selecting moves greedily according to the heuristic, andbreaking ties randomly, would exactly produce the default policy πmogo.4. The local shape heuristic, Q rlgo(s, a), is computed from the linear combination of local shape features used in RLGO 1.0(see Section 3.4). This heuristic is learnt offline by temporal difference learning from games of self-play.For each heuristic evaluation function, we assign a heuristic confidence ˜C(s, a) = M, for various constant values of equiv-alent experience M. We played 2300 games between MoGo and GnuGo 3.7.10 (level 10). The MC–RAVE algorithm executed3000 simulations per move (see Fig. 6).14 This is equivalent to a beta prior when binary outcomes are used.1870S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–1875Algorithm 2 Heuristic MC–RAVEprocedure Mc–Rave(s0)while time available doSimulate(board, s0)end whileboard.SetPosition(s0)return SelectMove(board, s0, 0)end procedureprocedure Simulate(board, s0)board.SetPosition(s0)[s0, a0, . . . , sT , aT ] = SimTree(board)[aT +1, . . . , aD ], z = SimDefault(board, T )Backup([s0, . . . , sT ], [a0, . . . , aD ], z)end procedureprocedure SimDefault(board, T )t = T + 1while not board.GameOver() doat = DefaultPolicy(board)board.Play(at )t = t + 1end whilez = board.BlackWins()return [aT +1, . . . , at−1], zend procedureprocedure SimTree(board)t = 0while not board.GameOver() dost = board.GetPosition()if st /∈ tree thenNewNode(st )at = DefaultPolicy(board)return [s0, a0, . . . , st , at ]end ifat = SelectMove(board, st )board.Play(at )t = t + 1end whilereturn [s0, a0, . . . , st−1, at−1]end procedureprocedure SelectMove(board, s)legal = board.Legal()if board.BlackToPlay() thenreturn argmaxa∈legalEval(s, a)elsereturn argmina∈legalEval(s, a)end ifend procedureprocedure Eval(s, a)b = pretuned constant bias value˜N(s,a)β =N(s,a)+ ˜N(s,a)+4N(s,a) ˜N(s,a)b2return (1 − β)Q (s, a) + β ˜Q (s, a)end procedureprocedure Backup([s0, . . . , sT ], [a0, . . . , aD ], z)for t = 0 to T doN(st , at ) + = 1Q (st , at ) + = z−Q (st ,at )N(st ,at )for u = t to D step 2 doif au /∈ [at , at+2, . . . , au−2] then˜N(st , au) + = 1˜Q (st , au) + = z− ˜Q (st ,at )˜N(st ,at )end ifend forend forend procedureprocedure NewNode(board, s)tree.Insert(s)for all a ∈ board.Legal() doN(s, a), Q (s, a), ˜N(s, a), ˜Q (s, a) = Heuristic(board, a)end forend procedureThe value function learnt from local shape features, Q rlgo, outperformed all the other heuristics and increased the win-ning rate of MoGo from 60% to 69%. Maximum performance was achieved using an equivalent experience of M = 50, whichindicates that Q rlgo is worth about as much as 50 simulations using all-moves-as-first. It seems likely that these resultscould be further improved by varying the heuristic confidence according to the particular position, based on the variance ofthe heuristic evaluation function.5.2. Exploration and exploitationThe performance of Monte-Carlo tree search is greatly improved by carefully balancing exploration with exploitation.The UCT algorithm significantly outperforms a greedy tree policy in computer Go [19]. Surprisingly, this result does notappear to extend to the heuristic UCT–RAVE algorithm: the optimal exploration rate in our experiments was zero, i.e. greedyMC–RAVE with no exploration in the tree policy.We believe that the explanation lies in the nature of the RAVE algorithm. Even if an action a is not selected immediatelyfrom position s, it will often be played at some later point in the simulation. This greatly reduces the need for explicitexploration, because the values for all actions are continually updated, regardless of the initial move selection.However, we were only able to run thorough tests with tens of thousands of simulations per move. It is possible thatexploration again becomes important when MC–RAVE is scaled up to millions of simulations per move. At this point asubstantial number of nodes will be dominated by MC values rather than RAVE values, so that exploration at these nodesshould be beneficial.S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18751871Fig. 6. Winning rate of MoGo, using the heuristic MC–RAVE algorithm, with 3000 simulations per move against GnuGo 3.7.10 (level 10) in 9 × 9 Go. Fourdifferent forms of heuristic function were used (see text). The bars indicate the standard error. Each point of the plot is an average over 2300 completegames.5.3. Soft pruningComputer Go has a large branching factor and several pruning techniques, such as selective search and progressivewidening (see Section 3), have been developed to reduce the size of the search space [40]. Heuristic MCTS and MC–RAVEcan be viewed as soft pruning techniques that focus on the highest valued regions of the search space without permanentlycutting off any branches of the search tree.A heuristic function provides a principled way to use prior knowledge to reduce the effective branching factor. Movesfavoured by the heuristic function will be initialised with a high value, and tried much more often than moves with alow heuristic value. However, if the heuristic evaluation function is incorrect, then the initial value will drop off at a ratedetermined by the heuristic confidence function, and other moves will then be explored.The MC–RAVE algorithm also significantly reduces the effective branching factor. RAVE forms a fast, rough estimate ofthe value of each move. Moves with high RAVE values will quickly become favoured over moves with low RAVE values,which are soft pruned from the search tree. However, the RAVE values are only used initially, so that MC–RAVE never cutsbranches permanently from the search tree.Heuristic MC–RAVE can often be wrong. The heuristic evaluation function can be inaccurate, and/or the RAVE estimatecan be misleading. In this case, heuristic MC–RAVE will prioritise the wrong moves, and the best moves can be soft prunedand not tried again for many simulations. There are no guarantees that these algorithms will help performance. However,in practice they help more than they hurt, and on average over many positions, they provide a very significant performanceadvantage.5.4. Performance of heuristic MC–RAVE in MoGoOur two extensions to MCTS, heuristic MCTS and MC–RAVE, increased the winning rate of MoGo against GnuGo, from24% for UCT, up to 69% using heuristic MC–RAVE. However, these results were based on executing just 3000 simulationsper move, using the hand-selected schedule in Eq. (19). When the number of simulations was increased, the overall perfor-mance of MoGo improved correspondingly. Table 1 shows how the performance of heuristic MC–RAVE scales with additionalcomputation.The 2007 release version of MoGo used the heuristic MC–RAVE algorithm, the minimum MSE schedule in Eq. (47), and animproved, handcrafted heuristic function.15 The scalability of the release version is shown in Fig. 7, based on the results ofa combined study over many thousands of computer hours [41]. This version of MoGo became the first program to achievedan level at 9 × 9 Go; the first program to beat a professional human player at 9 × 9 Go; the highest rated program on theComputer Go Server for both 9 × 9 and 19 × 19 Go; the gold medal winner at the 2007 19 × 19 Computer Go Olympiad;and achieved a rating of 2 kyu at 19 × 19 Go against human players on the Kiseido Go Server.15 Local shape features were not used in the release version.1872S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–1875Fig. 7. Scalability of MoGo (2007 release version), using data collected by members of the Computer Go mailing list [41]. Elo ratings were computed from alarge tournament, consisting of several thousand games for each version of MoGo, using successive doublings of the number of simulations per move. Errorbars indicate 95% confidence intervals in the Elo rating.6. Survey of subsequent workThe results in the previous section were achieved by MoGo in 2007. We briefly survey subsequent work on heuristicMC–RAVE in a variety of other strong Go programs.The heuristic function of MoGo was substantially enhanced by initialising H(s, a), C(s, a), and ˜C(s, a) to hand-tunedvalues based on handcrafted rules and patterns [42]. Supervised learning was also used to bias move selection towardspatterns favoured in expert games. In addition, the handcrafted default policy was modified to increase the diversity ofsimulations, by playing in empty regions of the board; and to fix a known issue with life-and-death, by playing in thekey point of simple dead shapes known as nakade. Using 100,000 simulations, the improved version of MoGo achieved awinning rate of 55% on 9 × 9 boards, and 53% on 19 × 19 boards, against the 2007 release version of MoGo.MoGo was also modified by massively parallelising the MC–RAVE algorithm to run on a cluster [43]. In order to avoidhuge communication overheads, memory was only shared between the shallowest nodes in the search tree. The massivelyparallel version of MoGo Titan was run on 800 processors of Huygens, the Dutch national supercomputer. MoGo Titan defeateda 9 dan professional player, Jun-Xun Zhou, in 19 × 19 Go with 7 stones handicap.S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18751873Table 2Approximate Elo ratings, on the Computer Go Server, of 9 × 9 Go programs discussed in the text.Year2006200620062006200720072007200920102010ProgramIndigoGnuGoMany FacesNeuroGoRLGOMoGoCrazy StoneFuegoMany FacesZenDescriptionPattern database, Monte-Carlo simulationPattern database, alpha–beta searchTemporal-difference learning, neural networkTemporal-difference searchVariants of heuristic MC–RAVEElo1400180018001850210025002500270027002700The program Zen has successfully combined MC–RAVE with more sophisticated domain knowledge. Zen became the firstprogram to sustain a dan rank, on full-size 19 × 19 boards, against human players on the Kiseido Go Server (KGS). It iscurrently ranked at 4 dan, placing it within the top 5% of the 30,000 ranked human players on KGS.Several of the strongest traditional Go programs now combine their existing tactical and pattern knowledge with theheuristic MC–RAVE framework, including The Many Faces of Go, currently ranked at 2 dan on KGS and Aya, currently rankedat 1 dan.The open source program Fuego [44] extends the MC–RAVE algorithm to use additional rapid value estimates, using avariant of the minimum MSE schedule (see Eq. (46)). A parallelised version of Fuego defeated a 9 dan professional player inan even 9 × 9 game, and defeated a 6 dan amateur player with 4 stones handicap on a full size board.16 The latest versionsof MoGo, Crazy Stone and the The Many Faces of Go have also achieved impressive victories against professional players on fullsize boards.Most recently, the program Erica combined heuristic MC–RAVE with a new technique, known as simulation balancing[45], to automatically tune the parameters of its default policy [46]. Previous machine learning approaches have focused onoptimising the strength of the default policy, under the assumption that a stronger policy will perform better in a Monte-Carlo search [1]. Unfortunately, in practice this assumption is often incorrect [11], and in general it can be difficult to finda default policy that performs well in Monte-Carlo search. The key idea of simulation balancing is to minimise the errorbetween the Monte-Carlo value Q (s, a), and an oracle value computed by deep search. Erica used simulation balancing totrain 2000 parameters of its default policy for 9 × 9 Go. Erica also won the gold medal in the 2010 19 × 19 Computer GoOlympiad, and is currently ranked at 3 dan on KGS.We provide a summary of the current state of the art in computer Go, based on ratings from the Computer Go Server (seeTable 2) and the Kiseido Go Server (see Fig. 8). Several of the programs described in Section 3 are included for comparison.7. ConclusionsFor the last 30 years, computer Go programs have evaluated positions by using handcrafted heuristics that are basedon human expert knowledge of shapes, patterns and rules. However, professional Go players often play moves according tointuitive feelings that are hard to express or quantify. Precisely encoding their knowledge into machine-understandable ruleshas proven to be a dead-end: a classic example of the knowledge acquisition bottleneck. Furthermore, traditional searchalgorithms, which are based on these handcrafted heuristics, cannot cope with the enormous state space and branchingfactor in the game of Go, and are unable to make effective use of additional computation time. This approach has led to Goprograms that are at best comparable to weak amateur-level humans [26,47].In contrast, Monte-Carlo tree search requires no human knowledge in order to understand a position. Instead, positionsare evaluated from the outcome of thousands of simulated games of self-play from that position. These simulated games areprogressively refined to prioritise the selection of positions with promising evaluations. Over the course of many simulations,attention is focused selectively on narrow regions of the search space that are correlated with successful outcomes. Unliketraditional search algorithms, this approach scales well both with the size of the state space and branching factor, and alsoscale well with additional computation time. In practice, the strongest programs do make extensive use of expert humanknowledge: both to improve the default policy and to define the prior knowledge. This knowledge accelerates the progressof the search, but does not affect its asymptotic optimality.On the Computer Go Server, using 9 × 9, 13 × 13 and 19 × 19 board sizes, traditional search programs are rated ataround 1800 Elo, whereas Monte-Carlo programs, enhanced by RAVE and heuristic knowledge, are rated at over 2500 Elousing standard hardware17 (see Table 2). On the Kiseido Go Server, on full-size boards against human opposition, traditionalsearch programs have reached 5 kyu, whereas the best Monte-Carlo programs are rated at 4 dan (see Fig. 8). The top16 See Human–Computer Go Challenges, http://www.computer-go.info/h-c/index.html.17 A difference of 700 Elo corresponds to a 99% winning rate.1874S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–1875Fig. 8. Ranks of various Go programs discussed in the text on the Kiseido Go Server (KGS). Each point represents the first date at which a program heldthe given rank for 20 consecutive games on KGS. Note that each program plays with different time controls, which may cause variations in rank; and thatsome programs play more regularly than others, which may cause variations in date.18* Version of GnuGo, Aya, Many Faces of Go based on traditional search with no Monte-Carlo.programs are now competitive with top human professionals at 9 × 9 Go, and are winning handicap games against tophuman professionals at 19 × 19 Go.In the Go program MoGo, every doubling in computation power led to an increase in playing strength of approximately100 Elo points in 13 × 13 Go (see Fig. 7) and perhaps even more in 19 × 19 Go. The strongest programs still lag far behindthe strongest humans, but they are improving rapidly. Fig. 8 shows that, after the initial jump in performance achieved bythe first Monte-Carlo programs, computer Go programs have continued to improve by more than one rank every year.This new framework for Monte-Carlo tree search also extends beyond Go. Variants of heuristic MC–RAVE have out-performed previous search algorithms in other challenging games, such as Hex [48] and Havannah [49]. The challengingproperties of Go are also characteristic of many of the hardest search, planning and decision-making problems. Immedi-ate actions often have delayed, long-term consequences, leading to surprising complexity and enormous search spaces thatare intractable to traditional search algorithms. Variants of heuristic MCTS and MC–RAVE are now outperforming previousapproaches in challenging search spaces such as feature selection [50], POMDP planning [51], and natural language phrasegeneration [52]. Understanding how to achieve high performance in Go is opening up new possibilities for high performanceAI in a wide variety of challenging problems.References[1] R. Coulom, Efficient selectivity and backup operators in Monte-Carlo tree search, in: 5th International Conference on Computer and Games, pp. 72–83.[2] R. Coulom, Computing Elo ratings of move patterns in the game of Go, International Computer Games Association Journal 30 (2007) 198–208.[3] S. Gelly, D. Silver, Achieving master level play in 9 × 9 computer Go, in: 23rd Conference on Artificial Intelligence, pp. 1537–1540.[4] H. Finnsson, Y. Björnsson, Simulation-based approach to general game playing, in: 23rd Conference on Artificial Intelligence, pp. 259–264.[5] R. Lorentz, Amazons discover Monte-Carlo, in: 6th International Conference on Computers and Games, pp. 13–24.[6] M. Winands, Y.Y. Björnsson, Evaluation function based Monte-Carlo LOA, in: 12th Advances in Computer Games Conference, pp. 33–44.[7] J. Schäfer, The UCT algorithm applied to games with imperfect information, Diploma thesis, Otto-von-Guericke-Universität Magdeburg, 2008.[8] N. Sturtevant, An analysis of UCT in multi-player games, in: 6th International Conference on Computers and Games, pp. 37–49.[9] R. Balla, A. Fern, UCT for tactical assault planning in real-time strategy games, in: 21st International Joint Conference on Artificial Intelligence, pp. 40–45.[10] L. Kocsis, C. Szepesvari, Bandit based Monte-Carlo planning, in: 15th European Conference on Machine Learning, pp. 282–293.[11] S. Gelly, D. Silver, Combining online and offline learning in UCT, in: 17th International Conference on Machine Learning, pp. 273–280.[12] S. Gelly, A contribution to reinforcement learning; Application to computer Go, PhD thesis, University of South Paris, 2007.[13] D. Silver, Reinforcement learning and simulation-based search in the game of Go, PhD thesis, University of Alberta, 2009.[14] D. Billings, L.P. Castillo, J. Schaeffer, D. Szafron, Using probabilistic knowledge and simulation to play poker, in: 16th National Conference on ArtificialIntelligence, pp. 697–703.18 See http://senseis.xmp.net/?KGSBotRatings.S. Gelly, D. Silver / Artificial Intelligence 175 (2011) 1856–18751875[15] B. Bouzy, B. Helmstetter, Monte-Carlo Go developments, in: 10th Advances in Computer Games Conference, pp. 159–174.[16] G. Tesauro, G. Galperin, On-line policy improvement using Monte-Carlo search, in: Advances in Neural Information Processing 9, pp. 1068–1074.[17] B. Sheppard, World-championship-caliber scrabble, Artificial Intelligence 134 (2002) 241–275.[18] P. Auer, N. Cesa-Bianchi, P. Fischer, Finite-time analysis of the multi-armed bandit problem, Machine Learning 47 (2002) 235–256.[19] S. Gelly, Y. Wang, R. Munos, O. Teytaud, Modification of UCT with patterns in Monte-Carlo Go, Technical report 6062, INRIA, 2006.[20] B. Bouzy, Associating domain-dependent knowledge and Monte Carlo approaches within a Go program, Information Sciences, Heuristic Search andComputer Game Playing IV (175) (2005) 247–257.[21] J. McCarthy, AI as sport, Science 276 (1997) 1518–1519.[22] D. McClain, Once again, machine beats human champion at chess, New York Times, December 5th, 2006.[23] A. Harmon, Queen, captured by mouse; more chess players use computers for edge, New York Times, February 6th, 2003.[24] D. Mechner, All systems Go, The Sciences 38 (1998).[25] J. Schaeffer, The games computers (and people) play, Advances in Computers 50 (2000) 189–266.[26] M. Müller, Computer Go, Artificial Intelligence 134 (2002) 145–179.[27] N. Schraudolph, P. Dayan, T. Sejnowski, Temporal difference learning of position evaluation in the game of Go, in: Advances in Neural InformationProcessing 6, pp. 817–824.[28] M. Enzenberger, The integration of a priori knowledge into a Go playing neural network, http://www.cs.ualberta.ca/~emarkus/neurogo/neurogo1996.html, 1996.[29] F. Dahl, Honte, a Go-playing program using neural nets, in: Machines that Learn to Play Games, Nova Science, 1999, pp. 205–223.[30] M. Enzenberger, Evaluation in Go by a neural network using soft segmentation, in: 10th Advances in Computer Games Conference, pp. 97–108.[31] D. Silver, R. Sutton, M. Müller, Reinforcement learning of local shape in the game of Go, in: 20th International Joint Conference on Artificial Intelligence,pp. 1053–1058.[32] D. Silver, R. Sutton, M. Müller, Sample-based learning and search with permanent and transient memories, in: 25th International Conference onMachine Learning, pp. 968–975.[33] B. Bruegmann, Monte-Carlo Go, http://www.cgl.ucsf.edu/go/Programs/Gobble.html, 1993.[34] B. Bouzy, Move pruning techniques for Monte-Carlo Go, in: 11th Advances in Computer Games Conference, pp. 104–119.[35] B. Bouzy, Associating shallow and selective global tree search with Monte Carlo for 9 × 9 Go, in: 4th International Conference on Computers andGames, pp. 67–80.[36] B. Bouzy, History and territory heuristics for Monte-Carlo Go, New Mathematics and Natural Computation 2 (2006) 1–8.[37] B. Abramson, Expected-outcome: A general model of static evaluation, IEEE Transactions on Pattern Analysis and Machine Intelligence 12 (1990)182–193.[38] Y. Wang, S. Gelly, Modifications of UCT and sequence-like simulations for Monte-Carlo Go, in: IEEE Symposium on Computational Intelligence andGames, Honolulu, Hawaii, pp. 175–182.[39] J. Schaeffer, The history heuristic and alpha–beta search enhancements in practice, IEEE Transactions on Pattern Analysis and Machine IntelligencePAMI-11 (1989) 1203–1212.[40] G. Chaslot, M. Winands, J. Uiterwijk, H. van den Herik, B. Bouzy, Progressive strategies for Monte-Carlo tree search, New Mathematics and NaturalComputation 4 (2008) 343–357.[41] D. Dailey, 9 × 9 scalability study, http://cgos.boardspace.net/study/index.html, 2008.[42] G. Chaslot, L. Chatriot, C. Fiter, S. Gelly, J. Hoock, J. Perez, A. Rimmel, O. Teytaud, Combining expert, online, transient and online knowledge in Monte-Carlo exploration, in: 8th European Workshop on Reinforcement Learning.[43] S. Gelly, J. Hoock, A. Rimmel, O. Teytaud, Y. Kalemkarian, The parallelization of Monte-Carlo planning, in: 6th International Conference in Control,Automation and Robotics, pp. 244–249.[44] M. Müller, M. Enzenberger, B. Arneson, R. Segal, Fuego – an open-source framework for board games and Go engine based on Monte-Carlo tree search,IEEE Transactions on Computational Intelligence and AI in Games 2 (2010) 259–270.[45] D. Silver, G. Tesauro, Monte-Carlo simulation balancing, in: 26th International Conference on Machine Learning, pp. 119–126.[46] S. Huang, R. Coulom, S. Lin, Monte-Carlo simulation balancing in practice, in: 7th International Conference on Computers and Games, pp. 119–126.[47] B. Bouzy, T. Cazenave, Computer Go: an AI-oriented survey, Artificial Intelligence 132 (2001) 39–103.[48] B. Arneson, R. Hayward, P. Henderson, MoHex wins Hex tournament, International Computer Games Association Journal 32 (2009) 114–116.[49] F. Teytaud, O. Teytaud, Creating an upper confidence tree program for Havannah, in: 12th Advances in Computer Games Conference, pp. 65–74.[50] R. Gaudel, M. Sebag, Feature selection as a one-player game, in: 27th International Conference on Machine Learning, pp. 359–366.[51] D. Silver, J. Veness, Online Monte-Carlo planning in large POMDPs, in: Advances in Neural Information Processing Systems 24.[52] J. Chevelu, T. Lavergne, Y. Lepage, T. Moudenc, Introduction of a new paraphrase generation tool based on Monte-Carlo sampling, in: 47th AnnualMeeting of the Association for Computational Linguistics, pp. 249–252.