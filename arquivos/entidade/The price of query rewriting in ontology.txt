Artificial Intelligence 213 (2014) 42–59Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintThe price of query rewriting in ontology-based data accessGeorg Gottlob a, Stanislav Kikot b, Roman Kontchakov b, Vladimir Podolskii c,Thomas Schwentick d, Michael Zakharyaschev b,∗a Department of Computer Science, University of Oxford, UKb Department of Computer Science and Information Systems, Birkbeck, University of London, UKc Steklov Mathematical Institute, Moscow, Russiad Fakultät für Informatik, TU Dortmund, Germanya r t i c l ei n f oa b s t r a c tArticle history:Received 7 July 2013Received in revised form 13 March 2014Accepted 26 April 2014Available online 5 May 2014Keywords:OntologyDatalogConjunctive queryQuery rewritingSuccinctnessBoolean circuitMonotone complexity1. Introduction±±linear Datalogand sticky DatalogWe give a solution to the succinctness problem for the size of first-order rewritingsof conjunctive queries in ontology-based data access with ontology languages such as. We show that positive existential andOWL 2 QL,nonrecursive datalog rewritings, which do not use extra non-logical symbols (except forintensional predicates in the case of datalog rewritings), suffer an exponential blowupin the worst case, while first-order rewritings can grow superpolynomially unless NP ⊆P/poly. We also prove that nonrecursive datalog rewritings are in general exponentiallymore succinct than positive existential rewritings, while first-order rewritings can besuperpolynomially more succinct than positive existential rewritings. On the other hand,we construct polynomial-size positive existential and nonrecursive datalog rewritingsunder the assumption that any data instance contains two fixed constants.© 2014 Elsevier B.V. All rights reserved.±.Our aim in this article is to give a solution to the succinctness problem for various types of conjunctive query rewritingin ontology-based data access (OBDA) with basic ontology languages such as OWL 2 QL and fragments of DatalogThe idea of OBDA has been around since about 2005 [14,19,28,47]. In the OBDA paradigm, an ontology defines a high-level global schema and provides a vocabulary for user queries. An OBDA system rewrites these queries into the vocabularyof the data and then delegates the actual query evaluation to the data sources (which can be relational databases, triplestores, datalog engines, etc.). OBDA is often regarded as an important ingredient of the new generation of information sys-tems because it (i) gives a high-level conceptual view of the data, (ii) provides the users with a convenient vocabulary forqueries, thus isolating them from the details of the structure of data sources, (iii) allows the system to enrich incompletedata with background knowledge, and (iv) supports queries to multiple and possibly heterogeneous data sources.A key concept of OBDA is first-order (FO) rewritability. An ontology language L is said to enjoy FO-rewritability if anyconjunctive query (CQ) q over any ontology Σ , formulated in L, can be rewritten to an FO-query qsuch that, for any datainstance D, the answers to the original CQ q over the knowledge base (Σ, D) can be computed by evaluating the rewriting(cid:4)* Corresponding author.E-mail addresses: georg.gottlob@cs.ox.ac.uk (G. Gottlob), staskikotx@gmail.com (S. Kikot), roman@dcs.bbk.ac.uk (R. Kontchakov), podolskii@mi.ras.ru(V. Podolskii), thomas.schwentick@udo.edu (T. Schwentick), michael@dcs.bbk.ac.uk (M. Zakharyaschev).http://dx.doi.org/10.1016/j.artint.2014.04.0040004-3702/© 2014 Elsevier B.V. All rights reserved.G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–5943(cid:4)(cid:4)(cid:4)over D. As qis an FO-query, the answers to qqcan be obtained using a standard relational database management system(RDBMS). Ontology languages with this property include the OWL 2 QL profile of the Web Ontology Language OWL 2, whichis based on description logics of the DL-Lite family [16,4], and fragments of Datalogsuch as linear tgds [11] (also knownas atomic-body existential rules [6]) or sticky tgds [12,13]. To illustrate, consider an OWL 2 QL-ontology Σ consisting of thefollowing tuple-generating dependencies (tgds):±(cid:2)∀x(cid:2)∀x∀x, y∀x, y(cid:2)RA(x) → ∃ yProject(x) → ∃ y(cid:2)worksOn(x, y) ∧ Project( y)(cid:3)(cid:3),(cid:2)(cid:2)isManagedBy(x, y) ∧ Professor( y)(cid:3)worksOn(x, y) → involves( y, x)(cid:3)isManagedBy(x, y) → involves(x, y),,(cid:3)(cid:3),and the CQ q(x) asking to find those who work with professors:q(x) = ∃ y, z(cid:2)(cid:3)worksOn(x, y) ∧ involves( y, z) ∧ Professor(z).A moment’s thought should convince the reader that the (positive existential) query(cid:4)q(x) = ∃ y, z(cid:4)worksOn(x, y) ∧(cid:2)(cid:3)worksOn(z, y) ∨ isManagedBy( y, z) ∨ involves( y, z)(cid:5)∧ Professor(z)(cid:5)worksOn(x, y) ∧ Project( y)(cid:4)∃ y(1)(2)(3)(4)(5)∨∨ RA(x)is an FO-rewriting of q(x) and Σ in the sense that, for any set D of ground atoms and any constant a in D, we have(Σ, D) |(cid:10) q(a)if and only if D |(cid:10) q(cid:4)(a).(In Section 2, we shall consider this example in more detail.) A number of different rewriting techniques have beenproposed and implemented for OWL 2 QL (PerfectRef [47], Presto/Prexto [55,54], Rapid [18], the combined approach [37],Ontop [51,33]) and its various extensions (Requiem/Blackout [45,46], Nyaya [25,43], Clipper [20] and [35]). However, allFO-rewritings constructed so far have, in the worst case, been exponential in the size of the query q. Thus, despite thefact that, for data complexity, CQ answering over ontologies with FO-rewritability is as complex as standard database queryevaluation (both are in AC0), rewritings can be too large for RDBMSs to cope with. It has become apparent, in both theoryand experiments, that for the OBDA paradigm to work in practice, we have to restrict attention to those ontologies and CQsthat ensure polynomial FO-rewritability (in the very least).The major open question we are going to attack in this article is whether the standard ontology languages for OBDA (inparticular, OWL 2 QL) enjoy polynomial FO-rewritability. Naturally, the answer depends on what means we can use in theof q and Σ above, we did not use any non-logical symbols other than those thatrewritings. For example, in the rewriting qoccurred in q and Σ . Such rewritings (perhaps also containing equality) may be described as ‘pure’ as they can be used withall possible databases; cf. [16]. (Note that all known rewritings apart from the one in the combined approach [37] are purein this sense.) Other important parameters are the available logical means (connectives and quantifiers) in rewritings and theway we represent them. Apart from the class of arbitrary FO-queries, we shall also consider positive existential (PE) queriesand nonrecursive datalog (NDL) queries as possible formalisms for rewritings (needless to say that pure NDL-rewritings maycontain new intensional predicates).(cid:4)At first sight, the results we obtain in this article could be divided into negative and positive. The bad news is thatthere is a sequence of CQs qn and OWL 2 QL ontologies Σn, both of size O (n), such that any pure PE- or NDL-rewritingof qn and Σn is of exponential size in n, while any pure FO-rewriting is of superpolynomial size unless NP ⊆ P/poly. Weobtain this negative result by first showing that OBDA with OWL 2 QL is powerful enough to compute monotone Booleanfunctions in NP, and that PE-rewritings correspond to monotone Boolean formulas, NDL-rewritings to monotone Booleancircuits, and FO-rewritings to arbitrary Boolean formulas. Then we use the celebrated exponential lower bounds for the sizeof monotone circuits and formulas computing the (NP-complete) Boolean function Cliquen,k ‘a graph with n nodes containsa k-clique’ [50,49]; a superpolynomial lower bound for the size of arbitrary (not necessarily monotone) Boolean formulascomputing Cliquen,k is a consequence of the assumption NP (cid:11)⊆ P/poly. We also use known separation results [49,48] formonotone Boolean functions such as ‘a bipartite graph with n vertices in each part has a perfect matching’ and ‘a givenvertex is accessible in a path accessibility system with n vertices’ to show that pure NDL-rewritings are in general exponen-tially more succinct than pure PE-rewritings, while pure FO-rewritings can be superpolynomially more succinct than purePE-rewritings.On the other hand, we have some good news as well: assuming that every data instance contains two fixed distinctindividual constants, we construct polynomial-size impure PE- and NDL-rewritings of any CQ and any ontology with the±polynomial witness property (in particular, any ontology in OWL 2 QL, linear Datalogof bounded arity). In essence, the rewriting guesses a polynomial number of ground atoms with database individuals andlabelled nulls (encoded as tuples over the two fixed constants), and checks whether these atoms satisfy the given CQand form a sequence of chase steps. We first construct a polynomial-size impure PE-rewriting and then show how itsdisjunctions can be encoded by a polynomial-size NDL-rewriting with intensional predicates of small arity. As the twoof bounded arity or sticky Datalog±44G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–59constants in the impure PE-rewriting can be replaced with two fresh existentially quantified variables, say x and y, suchthat x (cid:11)= y, we also obtain a polynomial-size pure FO-rewriting over data instances with at least two domain elements.How to reconcile these seemingly contradictory results? To establish exponential and superpolynomial lower boundsfor the size of pure rewritings, we show that computing monotone Boolean functions in NP is polynomially reducible toanswering CQs over OWL 2 QL-ontologies and data instances with a single individual. As evaluating queries over such datainstances is tractable, pure rewritings of the CQs and ontologies computing NP-complete monotone Boolean functions suchas Cliquen,k cannot be constructed in polynomial time—unless P = NP. (Our argument in Section 3 is a bit subtler: weprove that pure polynomial rewritings of the CQs and ontologies computing NP-complete monotone Boolean functions donot actually exist.) In fact, standard pure rewritings represent explicitly all distinct homomorphisms of the given CQ into thelabelled nulls of possible chases for the given ontology, and our construction shows that there may be exponentially-manysuch homomorphisms. On the other hand, our impure rewritings employ polynomially-many additional existential quanti-fiers over two fixed distinct domain elements in order to guess those homomorphisms. Thus, we show that the additionalNP-overhead of OBDA compared to CQ evaluation over plain databases can be represented in a succinct way. The exponen-tial succinctness of impure rewritings compared to pure ones is of the same kind as the succinctness of nondeterministicfinite automata or ∃-QBFs compared to deterministic automata [42] or, respectively, SAT (cf. also [5]).The plan of the article is as follows. In Section 2, we introduce OWL 2 QL, linear and sticky Datalogas fragments of thelanguage of tuple-generating dependencies and illustrate the construction of an FO-rewriting for OWL 2 QL-ontologies. Wealso introduce nonrecursive datalog rewritings and formulate the succinctness and separation problems. The exponentialand superpolynomial lower bounds on the size of pure rewritings are obtained in Section 3. The polynomial-size impurePE- and NDL-rewritings for families of ontologies with the polynomial witness property are constructed in Section 4. Weprove the separation results mentioned above in Section 5. Open problems and directions for future research are discussedin Section 6.±Some of the results in this article first appeared in the conference proceedings [26,32].2. First-order rewritability: size of rewritings mattersLet R be a relational schema. Given a data instance D over R, we denote by (cid:3)D the set of individual constants in D.We regard D as a (finite) set of ground atoms. A conjunctive query (CQ, for short) q(x) is a formula of the form ∃ y ϕ(x, y),where ϕ is a conjunction of atoms P (t) over R extended with equality, and each t in t is a term (an individual constant ora variable from x, y). The size |q| of a CQ q is the number of symbols in q.Let Σ be a set of first-order sentences over R. The pair (Σ, D) is called a knowledge base (KB, for short). A tuple a ofelements in (cid:3)D is said to be a certain answer to q(x) over the KB (Σ, D) if M |(cid:10) q(a) for every model M of Σ ∪ D; in thiscase we write (Σ, D) |(cid:10) q(a). If the tuple x of answer variables is empty, a certain answer to q over (Σ, D) is ‘yes’ in caseM |(cid:10) q for every model M of Σ ∪ D, and ‘no’ otherwise. CQs without answer variables are called Boolean CQs.For the purposes of OBDA, we are interested in ontologies (or theories) Σ for which the problem of finding certain an-(cid:4)(x) is called a first-orderswers can be reduced to standard database query evaluation. More precisely, a first-order formula qrewriting of q and Σ (FO-rewriting, for short) if, for any data instance D, a tuple a of elements in (cid:3)D is a certain answer(cid:4)(x) over D. We say that Σ enjoys first-order rewritability if, for any CQto q(x) over (Σ, D) just in case a is an answer to qq(x), there exists an FO-rewriting of q and Σ .There are two types of recognised ontology languages that guarantee first-order rewritability. The languages of the firsttype were introduced by the description logic community; they are based on the DL-Lite family of description logics [16,4]and include the OWL 2 QL profile of the Web Ontology Language OWL 2.1 The languages of the second type were designedby the datalog community; they belong to the Datalogfamily [12,11] and are also known as existential rules [7]. All ofthese ontology languages can be formulated in terms of tuple-generating dependencies.±We remind the reader [1] that a tuple-generating dependency (a tgd, for short) is a first-order sentence of the form(cid:2)∀x(cid:3)ϕ(x) → ∃ yψ(x, y),(6)where ϕ(x), the body, and ψ(x, y), the head of the tgd, are conjunctions of atoms and all the variables in x actually occur inϕ(x) (note that both ϕ(x) and ψ(x, y) can contain individual constants). Following the description logic tradition, we alsoconsider negative constraints of the form(cid:3)ϕ(x) → ⊥(cid:2)∀x.Finite sets of tgds and negative constraints will be called ontologies. (Note that ontologies can be inconsistent.) Given anontology Σ , we denote by |Σ| its size, that is, the number of symbols in Σ .An important property of tgds is the well-known fact [1] that, for any ontology Σ and any consistent KB (Σ, D), thereexists a (possibly infinite) model CΣ,D of (Σ, D), known as a universal (or canonical) model of (Σ, D), such that, for anyCQ q(x) and any tuple a from (cid:3)D , we have (Σ, D) |(cid:10) q(a) if and only if CΣ,D |(cid:10) q(a). Such a universal model can be‘repairs’ D with respect to Σ (but not in theconstructed by the following (oblivious) chase procedure, which, intuitively,1 www.w3.org/TR/owl2-overview.G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–5945Fig. 1. The chase CΣ,D for Σ = {(1), . . . , (4)} and D = {RA(ck), worksOn(ck, e), Project(e), isManagedBy(e, gg)}.Σ,Dmost economical way). We require the following definitions to describe the chase procedure formally. Let C be a set ofground atoms and ϕ(x) a conjunction of atoms (the body of a tgd or a negative constraint). We say that a map h from xto the individual constants in C is a homomorphism from ϕ(x) to C if h(ϕ(x)) ⊆ C, where h(ϕ(x)) denotes the set of atomsP (h(t)), for P (t) in ϕ(x) (as usual, we assume that h(a) = a, for any individual constant a). We say that C is consistent withΣ if there is no negative constraint ∀x(ϕ(x) → ⊥) in Σ with a homomorphism h from ϕ(x) to C.= D. Suppose now that Ck−1The chase algorithm initially sets C0Σ,D via h if h is a homomorphism from ϕ(x) to Ck−1Σ,D has already been defined. A tgd τ of the form∀x(ϕ(x) → ∃ yψ(x, y)) is said to be applicable to Ck−1Σ,D with either k = 1 orh(ϕ(x)) (cid:11)⊆ Ck−2(cid:4)( y) = c y for every y in y, whereΣ,D . Define an extension hc y is a fresh individual constant (a labelled null) different from all constants already used in the construction. An applicationof τ under h to Ck−1Σ,D is consistent with Σ ,Σ,D as follows: it takes some enumeration of all distinct pairs (τi, hi), i ≤ n, such that τi ∈ Σ isthe algorithm constructs Ckapplicable to Ck−1Σ,D . The chase CΣ,D of (Σ, D) isthe union of all CkΣ,D to be the result of applying each τi under hi to Ck−1Σ,D are consistent with Σ .Σ,D if they are not there yet. If Ck−1Σ,D for k < ω, provided that the Ck(cid:4)(x) = h(x) for every x in x, and hΣ,D adds the ground atoms of hΣ,D via hi , and sets Ck(cid:4)(ψ(x, y)) to Ck−1of h by taking hFor example, Fig. 1 shows the chase CΣ,D for the ontology Σ consisting of the tgds (1)–(4) from the introduction and thedata instance D = {RA(ck), worksOn(ck, e), Project(e), isManagedBy(e, gg)} (note that, in general, the chase is not necessarilyfinite).(cid:4)The model CΣ,D is called universal because, for any model M of (Σ, D), there is a homomorphism from CΣ,D to M.It is this property of the universal models that makes sure that all certain answers to CQs over (Σ, D) are contained inCΣ,D . Furthermore, we say that an ontology has the bounded derivation depth property (BDDP, for short) if there is a functiond: N → N such that, for any CQ q(x) and any data instance D, a tuplea from (cid:3)D is a certain answer to q over (Σ, D) ifand only if Cd(|q|)|(cid:10) q(a). (Note that d(|q|) does not depend on D but can depend on Σ .) The following theorem gives aΣ,Dcharacterisation of ontologies enjoying FO-rewritability:Theorem 1. An ontology has the BDDP if and only if it enjoys FO-rewritability.Proof. For a proof of (⇒) see [11, Theorem 9]. To show (⇐), we use [9, Proposition 4] (based on [56]) according to which,∃ yiϕi(x, yi), where eachwhenever there is an FO-rewriting of q(x) and Σ , there is also a rewriting of the form q∃ yi ϕi(x, yi) is a CQ. Let k be the maximum number of atoms in the CQs ∃ yi ϕi(x, yi), which depends only on q (for a(cid:4)| ≤ k. Itfixed Σ ). Clearly, every answer a to q(cid:4)| ≤ k. Observe that the number of pairwisefollows that CΣ,D |(cid:10) q(a) if and only if CΣ,D(cid:4) |(cid:10) q(a) for some Dnon-isomorphic D with |D| ≤ k is finite and depends only on q (for a fixed Σ ). Thus, we can take d(|q|) to be a number dsuch that Cd|(cid:10) q(a) whenever CΣ,D |(cid:10) q(a), for any D with |D| ≤ k. (cid:2)(cid:4)(x) over D is also an answer to q(cid:4)(x) over some subset D(cid:4) ⊆ D with |D(cid:4) ⊆ D with |D(cid:4)(x) =(cid:6)iΣ,DDisjunctions of CQs, used in the proof of Theorem 1, are known as unions of conjunctive queries or UCQs, for short. AnFO-rewriting of q and Σ in the form of a UCQ is called a UCQ-rewriting of q and Σ . (That the BDDP of Σ is equivalent tothe existence of UCQ-rewritings for all CQs over Σ can be shown using an earlier result from graph databases [57] and thefact that minimal UCQ-rewritings are unique up to isomorphism [36]; an ontology with UCQ-rewritings for all CQs is calleda finite unification set by Baget et al. [6].)The following ontology languages ensure the BDDP:– linear tgds [11], that is, tgds with a single atom in the body;– O WL 2 QL-tgds, that is, linear tgds with atoms of arity ≤ 2 and without individual constants;– sticky sets of tgds [13], that is, sets of tgds such that the variables that appear more than once in the body of a tgd (joinvariables) are propagated (or ‘stick’) during the chase to all the inferred atoms(other examples include sticky-join sets of tgds [13] and domain-restricted rules [7]). Each of the above ontology languagescan also include negative constraints; they do not affect the chase procedure but can make a knowledge base inconsis-tent [11].46G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–59Fig. 2. Three homomorphisms from q(x) to a hypothetical CΣ,D .Remark 2. It is not hard to see that the standard OWL 2 QL profile of the Web Ontology Language OWL 2 can be representedin terms of OWL 2 QL-tgds and negative constraints, but not the other way round: for example, the tgd ∀x(R(x, x) → A(x))cannot be expressed in OWL 2 QL. However, all the OWL 2 QL-tgds and negative constraints we use in this article are express-ible in OWL 2 QL. Thus, the linear tgd of the form(cid:2)∀x(cid:2)(cid:3)(cid:3)A(x) → ∃ yR(x, y) ∧ B( y)used in (1) and (2) as well as in the construction of Section 3 can be encoded by the concept inclusion A (cid:18) ∃R.B in theOWL 2 QL description logic syntax (where A and B are concept names and R is a role name), or as the following set ofconcept and role inclusions in the syntax of DL-LiteHcore [4]:A (cid:18) ∃R B ,∃R−B(cid:18) B,R B (cid:18) R,where R B is a fresh role name. Because of this, we slightly abuse terminology and call ontologies with OWL 2 QL-tgds simplyOWL 2 QL-ontologies.We now give an example showing how one can construct FO-rewritings of CQs and OWL 2 QL-ontologies.Example 3. Consider again the OWL 2 QL-ontology Σ = {(1), . . . , (4)} and the CQ (5) from the introduction. Suppose a ∈(cid:3)D is a certain answer to q(x) over (Σ, D), for some data instance D. This means that CΣ,D |(cid:10) q(a), and so there is a(cid:4)(x) of q(x) and Σ by analysing possiblehomomorphism h from q(x) to CΣ,D with h(x) = a. We construct an FO-rewriting qlocations of h( y) and h(z) in CΣ,D . To begin with, both of them can belong to (cid:3)D . To take account of such a homomorphism,(cid:4)(x) as a disjunct.we include ∃ y, z (worksOn(x, y) ∧ (worksOn(z, y) ∨ isManagedBy( y, z) ∨ involves( y, z)) ∧ Professor(z)) in qAnother possible homomorphism, h1, can have h1( y) in (cid:3)D but h1(z) among the labelled nulls, which can happen if h1( y)is an instance of Project (see Fig. 2 in the middle). To take such a homomorphism into account, we include the disjunct∃ y (worksOn(x, y) ∧ Project( y)) in q. Then, there can be a homomorphism, h2, with both h2( y) and h2(z) being labellednulls, which can happen if h2(x) is an instance of RA (see Fig. 2 on the left). This gives us the third disjunct, RA(x), in(cid:4)(x). Finally, there can be a homomorphism, h3, such that h3( y) is a labelled null but h3(z) is in (cid:3)D —this can happenqif h3(z) = h3(x) is an instance of both RA and Professor (see Fig. 2 on the right). This homomorphism, however, gives adisjunct RA(x) ∧ Professor(z) ∧ (x = z), which is subsumed by the third disjunct, RA(x), and so is redundant. Thus, we obtainthe FO-rewriting q(cid:4)(x) of q(x) and Σ given in the introduction.(cid:4)Our next example gives an ontology without BDDP.Example 4. Consider the ontology Σ = {∀x, y(R(x, y) ∧ A( y) → A(x))}, whose single tgd is not linear or OWL 2 QL (becauseof the two atoms in the body) and not sticky either (because of the variable y). Given a data instance D, we can againconstruct a universal model of (Σ, D) using the chase procedure. However, to derive A(a) for some a ∈ (cid:3)D , we have to findan R-chain between a and some b with A(b) ∈ D. The number of chase steps producing chains of this kind may clearlydepend on D. Ontologies such as Σ are allowed in the OWL 2 EL profile of OWL 2. CQ answering over OWL 2 EL-ontologiesis known to be P-complete for data complexity [15], which means that in general they do not enjoy FO-rewritability.(A different approach to OBDA with OWL 2 EL was suggested by Lutz et al. [40].) On the other hand, CQs over ontologiesG. Gottlob et al. / Artificial Intelligence 213 (2014) 42–5947formulated in OWL 2 EL and the description logics Horn-SHIQ and Horn-SROIQ can be rewritten into (recursive) datalogqueries [53,44,20] and used together with datalog engines.OBDA via FO-rewritability is based on the empirical assumption that query evaluation using RDBMSs is efficient inpractice. However, this assumption only works for reasonably small CQs; evaluation of large CQs can be a very hard problemfor RDBMSs (see, e.g., [41]), which should not come as a surprise because CQ evaluation is W [1]-complete2 [21]. Recall,however, that CQs of bounded treewidth can be evaluated in polynomial time in |q| and |(cid:3)D | [60,34,17,27]. Since such CQsoccur most often in practice, this result can serve as a theoretical justification for the empirical assumption above.But what is the size of the existing FO-rewritings for CQs and ontologies in the languages under consideration? Thefollowing theorem summarises some of the known results:Theorem 5. (See [16,11,25,13,24].) For any set Σ of tgds, let KΣ be the number of predicates in Σ and let LΣ be the maximum arityof the predicates in Σ .(i) There exist CQs q and sets Σ of OWL 2 QL-tgds any UCQ-rewritings of which have Ω(K(ii) Any CQ q and any set Σ of linear tgds without constants have a UCQ-rewriting with O ((KΣ · (LΣ · |q|)LΣ )|q|) CQs such that the|q|Σ ) CQs.number of atoms in each CQ does not exceed the number of atoms in q.In particular, for OWL 2 QL-tgds Σ , LΣ ≤ 2 and the UCQ-rewriting has O ((KΣ · (2|q|)2)|q|) CQs.(iii) Any CQ q and any sticky set Σ of tgds without constants have a UCQ-rewriting with 2O (KΣ ·(LΣ ·|q|)LΣ ) CQs, each of which hasO (KΣ · (LΣ · |q|)LΣ ) atoms.Proof. (i) Let Σ = {∀x ( Ai(x) → A0(x)) | 1 ≤ i ≤ n} and q = ∃x1, . . . , xk( A0(x1) ∧ · · · ∧ A0(xk)). It should be clear that anyUCQ-rewriting of q and Σ must contain CQs with all possible combinations of A0(x j), A1(x j), . . . , An(x j), for each 1 ≤ j ≤ k.For (ii) and (iii), we only briefly comment on the UCQ-rewritings constructed in [16,11,25,13,24] using backward chaining.(ii) Since the tgds have a single atom in the body, the number of atoms in each of the CQs of the resulting UCQ-rewritingcannot be larger than the number of atoms in q. Thus, each of these CQs contains at most LΣ · |q| terms, and we canassume that they use the same names for existentially quantified variables. The total number of atoms we can form usingthese terms does not exceed KΣ · (LΣ · |q|)LΣ . Given that each CQ of the UCQ-rewriting has at most |q| atoms, the totalnumber of possible component CQs is bounded by (KΣ · (LΣ · |q|)LΣ )|q|. (iii) Observe that the new variables arising in theUCQ-rewriting are all existentially quantified. Due to the stickiness condition, any such new variable must occur at mostonce in the body of the tgd used for the rewriting. This variable cannot interact with any other variable, and we can usea unique special symbol for it, which corresponds to the ‘don’t care’ underscore symbol in Prolog. Then each term in eachatom of the rewritten query is either a variable from q or the special underscore symbol (in the end, each underscoresymbol is replaced by a fresh existentially quantified variable). There are at most LΣ · |q| + 1 such terms. It follows thatthere are at most KΣ · (LΣ · |q| + 1)LΣ = O (KΣ · (LΣ · |q|)LΣ ) atoms in any CQ of the UCQ-rewriting. Each of the atoms iseither included in a CQ or not included in it, which gives 2O (KΣ ·(LΣ ·|q|)LΣ ) possible CQs in the UCQ-rewriting. (cid:2)Thus, even for the weakest ontology language OWL 2 QL, the available (UCQ) rewritings are of exponential size in theworst case. The chief problem we analyse in this article is whether there exist shorter rewritings. Together with FO- andUCQ-rewritings defined above, we also consider positive existential and nonrecursive datalog rewritings.A positive existential rewriting (PE-rewriting, for short) of a CQ q(x) and an ontology Σ is an FO-rewriting q(cid:4)(x) of theform ∃zψ(x, z), where ψ is built from atoms using only ∧ and ∨. (Every PE-rewriting can obviously be transformed toan equivalent UCQ-rewriting but at the expense of an exponential blowup.) To define nonrecursive datalog rewritings, weremind the reader [1] that a datalog program, Π , is a finite set of Horn clausesA0 ← A1 ∧ · · · ∧ Am,where each Ai is an atom of the form P (t) and each term t in t is either a (universally quantified) variable or an individualconstant. A0 is called the head of the clause, and A1, . . . , Am its body. All variables occurring in the head A0 must alsooccur in the body in one of A1, . . . , Am. A predicate P depends on a predicate Q if Π contains a clause whose head’spredicate is P and whose body contains an atom with predicate Q . A datalog program Π is called nonrecursive if thisdependence relation is acyclic. A nonrecursive datalog query consists of a nonrecursive datalog program Π and a goal G(x),which is just an atom. Given a data instance D, a tuple a of elements in (cid:3)D is called a certain answer to (Π, G(x)) overD if Π ∪ D |(cid:10) G(a). A nonrecursive datalog query (Π, G(x)) is called a nonrecursive datalog rewriting of a CQ q(x) and anontology Σ (NDL-rewriting, for short) if, for any data instance D and any tuple a of elements in (cid:3)D , we have (Σ, D) |(cid:10) q(a)if and only if Π ∪ D |(cid:10) G(a).So far we have not specified what means one is allowed to use in rewritings. The first FO-rewritings of [16,45] wereformulated in the signature that contained only constant and predicate symbols from q and Σ as well as equality. As2 More precisely, evaluation of a Boolean CQ q over D can be done in time O (|q| · |(cid:3)D ||q|), but cannot be done in time f (|q|) · |(cid:3)D |O (1), for anycomputable function f , unless FPT = W [1].48G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–59argued by Calvanese et al. [16], FO-rewritings should be data-independent (and so applicable to all possible data instances).We start by adopting this definition for FO- and PE-rewritings; in NDL-rewritings, we can, of course, use new definable (orintensional) predicates, but no constants that do not occur in q.We are interested in three major questions: (i) Do there exist polynomial-size FO-, PE-, NDL-rewritings of CQs andOWL 2 QL-ontologies? (ii) Can rewritings of one type be substantially shorter than rewritings of other types? (iii) What extrameans in rewritings can make them substantially shorter?3. Exponential and superpolynomial lower bounds for the size of rewritingsIn this section, we give an answer to question (i). To this end, we show how the problem of constructing circuitsthat compute monotone Boolean functions in NP can be reduced to the problem of finding rewritings for CQs and OWL 2QL-ontologies. This reduction coupled with the known lower bounds on the size of monotone Boolean circuits and formulaswill provide us with similar lower bounds on the size of rewritings.We begin by reminding the reader of some basic definitions from the theory of circuit complexity (for more details see,e.g., [3,29]). By an n-ary Boolean function, for n ≥ 1, we mean a function from {0, 1}n to {0, 1}. A Boolean function fismonotone if f (α) ≤ f (β) for all α ≤ β, where ≤ is the component-wise ≤ on vectors of {0, 1}. An n-input Boolean circuit, C,is a directed acyclic graph with n sources, inputs, and one sink, output. Every non-source node of C is called a gate and islabelled with either ∧ or ∨, in which case it has two incoming edges, or with ¬, in which case it has one incoming edge.A circuit is monotone if it contains only ∧- and ∨-gates. Boolean formulas can be thought of as circuits in which every gatehas at most one outgoing edge. For an input α ∈ {0, 1}n, the output of C on α is denoted by C(α), and C is said to computeif C(α) = f (α), for every α ∈ {0, 1}n. The size of C, denoted |C|, is the number of nodes in Can n-ary Boolean function f(that is, the number of inputs and gates).A family of Boolean functions is a sequence f 1, f 2, . . . , where each f n is an n-ary Boolean function. A family f 1, f 2, . . . isin the complexity class NP if the language {α ∈ {0, 1}n | f n(α) = 1} is in NP. For each such family, there exist polynomialsp, q and Boolean circuits C1, C2, . . . such that Cn has n + p(n) inputs, |Cn| ≤ q(n) and, for any α ∈ {0, 1}n, we havef n(α) = 1 if and only if Cn(α, β) = 1,for some β ∈ {0, 1}p(n).We call the additional p(n) inputs for β in Cn nondeterministic inputs (β is also known as a certificate [3]). A family f 1, f 2, . . .is NP-complete if the corresponding language {α ∈ {0, 1}n | f n(α) = 1} is NP-complete.The class of languages that are decidable by families of polynomial-size circuits is denoted by P/poly. It is known thatP (cid:2) P/poly. Thus, we would obtain P (cid:11)= NP if we could show that NP (cid:11)⊆ P/poly. By the Karp–Lipton theorem (see, e.g., [3]),NP ⊆ P/poly implies PH = Σ p2 .In this section, given a family of monotone Boolean functions f n in NP, we first encode them—via the Tseitin transfor-mation [59]—by means of polynomial-size CNFs, which are used to construct a sequence of OWL 2 QL-ontologies Σ f n andBoolean CQs q f n such that(Σ f n , Dα) |(cid:10) q f nfor any α ∈ {0, 1}n,f n(α) = 1,if and only ifwhere the database instance Dα is determined by α. Then, using the fact that the Dα have a single domain element,we show that if we have, say, PE-rewritings of the q f n and Σ f n , then those rewritings are in essence monotone Booleanformulas (that is, propositional PE-formulas), and so, by the known results on circuit complexity, cannot be polynomial, forexample, in the case of the family of Boolean functions that check whether a given graph (encoded by arguments of thefunctions) contains a clique of the specified size.Suppose we are given a family of Boolean functions f n in NP and a corresponding family of Boolean circuits Cn. We canconsider the inputs (including nondeterministic ones) of the circuits Cn as Boolean variables. Each gate of Cn can also bethought of as a Boolean variable whose value coincides with the output of the gate on a given input. Let g = (g1, . . . , g|Cn|)be the Boolean variables for the nodes of Cn. We may assume that a Boolean circuit Cn contains only ∧- and ¬-gates, so itcan be regarded as a set of equations of the formgi = ¬gi(cid:4) orgi = gi(cid:4) ∧ gi(cid:4)(cid:4) ,where gi(cid:4) and gi(cid:4)(cid:4) are the variables for the inputs of the gate gi . We assume that gi can depend only on g1, . . . , gi−1 andthat g1, . . . , gn are the inputs of Cn, gn+1, . . . , gn+p(n) are the nondeterministic inputs of Cn, and g|Cn| its output. Now, witheach Cn we associate the following Boolean formula in CNF with the variables h = (h1, . . . , hn) and g:ψn(h, g) =n(cid:7)(¬gi ∨ hi) ∧ g|Cn| ∧(cid:7)(cid:4)(cid:5)(gi(cid:4) ∨ gi) ∧ (¬gi(cid:4) ∨ ¬gi)∧i=1(cid:7)(cid:4)gi =gi(cid:4) ∧gi(cid:4)(cid:4) in Cngi =¬gi(cid:4) in Cn(cid:5)(gi(cid:4) ∨ ¬gi) ∧ (gi(cid:4)(cid:4) ∨ ¬gi) ∧ (¬gi(cid:4) ∨ ¬gi(cid:4)(cid:4) ∨ gi).The clauses of the last two conjuncts encode the correct computation of the circuit: they are equivalent to gi ↔ ¬gi(cid:4) andgi ↔ gi(cid:4) ∧ gi(cid:4)(cid:4) , respectively. In what follows, we denote by ψn(α, g) the result of replacing the variables in h with therespective truth-values from a vector α ∈ {0, 1}n (thus, the g are the only variables of this formula).G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–5949Lemma 6. For any family of monotone Boolean functions f n in NP and any α ∈ {0, 1}n, we have f n(α) = 1 if and only if ψn(α, g) issatisfiable.f n(α) = 1 thenC n(α, β) = 1, for some β. Consider ψn(α, γ ), where the γi in γ are given by the outputProof. (⇒) Ifvalues of the respective nodes gi in Cn on the input (α, β) (the output value of an input or a nondeterministic input of Cnis the respective value itself). By definition, the last two conjuncts of ψn(α, γ ) are true under such an assignment. The firstconjunct is trivially true, while the second conjunct is true because γ|Cn| = Cn(α, β).(⇐) Conversely, suppose ψn(α, γ ) = 1, for some γ . Let α(cid:4)be the values of the inputs of Cn in γ . By the first conjunct,α(cid:4) ≤ α and, as f n is monotone, we obtain f n(α(cid:4)) ≤ f n(α). So, it suffices to show that f n(α(cid:4)) = 1. To this end, we prove byinduction on the structure of Cn that the values of the variables of ψn(α, γ ) are equal to the output values of the corre-sponding nodes of Cn on (α(cid:4), β), where β are the values of the nondeterministic inputs from γ : for the inputs (includingnondeterministic ones), this is immediate by definition; for the gates, the claim easily follows from the last two conjunctsof ψn. Then, by the second conjunct, γ|Cn| = 1, and so Cn(α(cid:4), β) = 1, whence f n(α(cid:4)) = 1. (cid:2)The second step of the reduction is to encode satisfiability of ψn(α, g) by means of the CQ answering problem inOWL 2 QL. The CNF ψn(h, g) contains d ≤ 3|Cn| + 1 clauses C1, . . . , Cd with n variables h1, . . . , hn and m = |Cn| variablesg1, . . . , gm. Recall that g1, . . . , gn correspond to the inputs and C1, . . . , Cn are clauses of the form ¬gi ∨ hi . We take a binarypredicate P (x, y) and unary predicates A0(x) and Ai(x), X 0i (x), X 1i (x), for each variable gi , as well as Z 0, j(x), . . . , Zm, j(x),for each clause C j of ψn(h, g).P ( y, x) ∧ X (cid:11)(cid:2)∀x(cid:2)∀xAi−1(x) → ∃ y(cid:2)Consider an OWL 2 QL-ontology Σ f n with the following tgds, for 1 ≤ i ≤ m, 1 ≤ j ≤ d and (cid:11) = 0, 1:(cid:2)∀x(cid:3)i (x) → Ai(x)X (cid:11),(cid:2)(cid:3)i (x) → Z i, j(x)∀xX 0(cid:2)(cid:3)∀xi (x) → Z i, j(x)X 1It is not hard to check that |Σ f n | = O (|Cn|2) and that the chase of Σ f n is finite for any data. Consider also the followingtree-shaped Boolean CQ:if ¬gi ∈ C j,if gi ∈ C j.P (x, y) ∧ Z i−1, j( y)Z i, j(x) → ∃ yi ( y)(cid:3)(cid:3),(cid:3)(cid:3),,,(cid:2)(cid:8)q f n = ∃ y∃zA0( y0) ∧(cid:9)m(cid:7)i=1d(cid:7)P ( yi, yi−1) ∧P ( ym, zm−1, j) ∧m−1(cid:7)i=1j=1(cid:10)(cid:11)P (zi, j, zi−1, j) ∧ Z 0, j(z0, j),where y = ( y0, . . . , ym) and z = (z0,1, . . . , zm−1,1, . . . , z0,d, . . . , zm−1,d). It should be clear that |q f n | = O (|Cn|2).For each α = (α1, . . . , αn) ∈ {0, 1}n, we take the data instance(cid:14)(cid:14) 1 ≤ i ≤ n and αi = 1(cid:13)A0(a)Z 0,i(a)Dα =∪(cid:12)(cid:13)(cid:12).We explain the intuition behind Σ f n , q f n and Dα using the example in Fig. 3, where the chase CΣ f n ,Dα of (Σ f n , Dα) isdepicted for a particular f n and α. To answer q f n over (Σ f n , Dα), we have to check whether q f n can be homomorphicallymapped into CΣ f n ,Dα . The variables yi are clearly mapped to one of the main branches of the model, from a to a point in A3,say the leftmost one, which corresponds to the valuation for the variables g in ψn(α, g) making all of them false. Considernow, for example, variables z2,3, z1,3, z0,3 that correspond to the clause C3 = g1 ∨ ¬g3 in ψn(α, g). Since Z 0,3(a) /∈ Dα , inorder to map z2,3, z1,3, z0,3 we have to choose at least one of its literals, g1 or ¬g3, that is true under such an assignment,and then z2,3, z1,3, z0,3 can be sent to the points in the respective ‘hanging’ branch, resulting in z0,3 (cid:11)(cid:22)→ a. On the other hand,there are two possible ways (depending on α1) of mapping variables z2,1, z1,1, z0,1 for the clause C1 = ¬g1 ∨ h of ψn(α, g).(1) If α1 = 0 then C1 in ψn(α, g) is equivalent to ¬g1 and, since Z 0,1(a) /∈ Dα , we have to be able to send z2,1, z1,1, z0,1to the points in a ‘hanging’ branch, resulting in z0,1 (cid:11)(cid:22)→ a. (2) If, however, α1 = 1 then the clause C1 is true anyway andZ 0,1(a) ∈ Dα , whence z2,1, z1,1, z0,1 can be sent to the same branch from A2 to A0, so that z0,1 (cid:22)→ a. Thus, we arrive to thefollowing:Lemma 7. For any family of Boolean functions f n in NP and any α ∈ {0, 1}n, we have (Σ f n , Dα) |(cid:10) q f n if and only if ψn(α, g) issatisfiable.Proof. (⇒) Consider a homomorphism h from q f n to the chase CΣ f n ,Dα of (Σ f n , Dα). Clearly, h( y0) = a and both Ai(h( yi))and P (h( yi), h( yi−1)) are in CΣ f n ,Dα , for all 1 ≤ i ≤ m. So, for each variable gi in g, we set γi = 1 if X 1i (h( yi)) ∈ CΣ f n ,Dαand γi = 0 otherwise (in which case X 0i (h( yi)) ∈ CΣ f n ,Dα ). We claim that ψn(α, γ ) = 1. Take any clause C j in ψn(α, g)and consider two cases for h(z0, j). If h(z0, j) = a then 1 ≤ j ≤ n with Z 0, j(a) ∈ Dα , and so α j = 1, whence the clauseC j = ¬g j ∨ h j is true anyway. Otherwise, h(z0, j) (cid:11)= a which means that Z i, j(h( yi)) ∈ CΣ f n ,Dα , for some 1 ≤ i ≤ m, and so theclause C j contains gi if X 1i (h( yi)) ∈ CΣ f n ,Dα . The claim follows.i (h( yi)) ∈ CΣ f n ,Dα and ¬gi if X 0(⇐) Suppose ψn(α, γ ) = 1, for some γ ∈ {0, 1}m. We construct a homomorphism h from q f n to the chase CΣ f n ,Dα of(Σ f n , Dα). Observe that CΣ f n ,Dα contains a path u0, . . . , um from a = u0 to some um such that P (ui, ui−1) ∈ CΣ f n ,Dα , for50G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–59Fig. 3. The chase CΣ f n ,Dα and CQ q f n for α = (1) and a function f n with one input and one nondeterministic input to one ∧-gate. Thus, n = 1, m = 3,d = 5 and ψn(h, g1, g2, g3) = (¬g1 ∨ h) ∧ g3 ∧ (g1 ∨ ¬g3) ∧ (g2 ∨ ¬g3) ∧ (¬g1 ∨ ¬g2 ∨ g3). Only two groups of the ‘hanging’ Z i, j branches are shown inCΣ f n ,Dα : for j = 1 and j = 3, that is, for C1 = ¬g1 ∨ h and C3 = g1 ∨ ¬g3.i (ui) ∈ CΣ f n ,Dα otherwise.1 ≤ i ≤ m, and the path corresponds to γ in the following sense: X 1So, for 0 ≤ i ≤ m, we set h( yi) = ui . For 1 ≤ j ≤ d, we define h(zm−1, j), . . . , h(z0, j) recursively, starting from h(zm−1, j) andassuming that zm, j = ym: let h(zi, j) = ui if Z i+1, j(h(zi+1, j)) /∈ CΣ f n ,Dα ; otherwise, let h(zi, j) be the labelled null chosen fory when applying ∀x(Z i+1, j(x) → ∃ y (P (x, y) ∧ Z i, j(x))) in h(zi+1, j). It is easy to check that h is indeed a homomorphismfrom q f n into CΣ f n ,Dα . (cid:2)i (ui) ∈ CΣ f n ,Dα if γi = 1 and X 0We now use the reduction above to show that there is a close correspondence between PE-rewritings and monotoneBoolean formulas, between FO-rewritings and (not necessarily monotone) Boolean formulas, and between NDL-rewritingsand monotone Boolean circuits.Lemma 8. Suppose f 1, f 2, . . . is a family of monotone Boolean functions in NP.(i) If q(cid:4)f n is an FO-rewriting of q f n and Σ f n , then there is a Boolean formula ϕn computing f n with |ϕn| ≤ |q(cid:4)f n is a PE-rewriting of q f n and Σ f n , then there is a monotone Boolean formula ϕn computing f n with |ϕn| ≤ |q(ii) If q(iii) If (Π f n , G) is an NDL-rewriting of q f n and Σ f n , then there is a monotone Boolean circuit Bn computing f n with |Bn| ≤ |Π f n |.(cid:4)f n |.(cid:4)f n |.Proof. (i) By Lemmas 6 and 7, for any FO-rewriting q(cid:4)f n of q f n and Σ f n ,Dα |(cid:10) q(cid:4)f nif and only iff n(α) = 1,for any α ∈ {0, 1}n.(cid:4)Since (cid:3)Dα is a singleton, {a}, we can remove all the quantifiers and replace all the individual variables in qf n with a. The(cid:4)resulting Boolean FO-query qf n . Then we observe that the ground atoms other thana = a, A0(a) and the Z 0, j(a), for 1 ≤ j ≤ n, are false in Dα , and so we can replace all a = a and A0(a) with (cid:23), and all the(cid:4)(cid:4)atoms different from a = a, A0(a) and Z 0, j(a), for 1 ≤ j ≤ n, with ⊥ without affecting the truth-value of qf n in Dα . Theresulting quantifier-free query can be regarded as a Boolean formula, ϕn, with ‘propositional variables’ Z 0,1(a), . . . , Z 0,n(a).But then ϕn(α) = f n(α), for each α ∈ {0, 1}n; that is, ϕn computes f n. Clearly, |ϕn| ≤ |q(cid:4)(cid:4)f n has the same truth-value in Dα as q(ii) In the same way as above we can transform any PE-rewriting q(cid:4)f n of q f n and Σ f n into a monotone Boolean formulaϕn (with connectives ∨ and ∧ only) and propositional variables Z 0,1(a), . . . , Z 0,n(a) such that ϕn computes f n and |ϕn| ≤|q(cid:4)f n |.(iii) Suppose that (Π f n , G) is an NDL-rewriting of q f n and Σ f n , and α ∈ {0, 1}n. Again, since (cid:3)Dα is a singleton, eachvariable in the head of a clause also occurs in its body and Π f n does not contain constants (as q f n does not have them),we can replace all the individual variables in Π f n with a and the resulting NDL-query (Π (cid:4)f n , G) has the same truth-valuein Dα as (Π f n , G). Then, in Π (cid:4)f n , we remove all a = a and A0(a) (as they are true) and remove all clauses containingatoms different from a = a, A0(a) and Z 0, j(a), for 1 ≤ j ≤ n (because such atoms are false in Dα and do not occur in theheads of the clauses). Denote the resulting propositional NDL-program by Π (cid:4)(cid:4)f n , Dα |(cid:10) G if and only iff n(α) = 1. We can regard (Π (cid:4)(cid:4)f n , G) as an NDL-query in which Z 0,1(a), . . . , Z 0,n(a) are ‘propositional variables’ and the headsof all clauses also have no arguments (i.e., are propositional variables). Such a program Π (cid:4)(cid:4)f n can now be transformed intof n . It follows that Π (cid:4)(cid:4)(cid:4)f n |.G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–5951a monotone Boolean circuit computing f n: for every propositional variable p occurring in the head of a clause in Π (cid:4)(cid:4)f n , weintroduce a ∨-gate whose output is p and inputs are the bodies of the clauses with the head p; and for each such body, weintroduce a cascade of ∧-gates whose inputs are the propositional variables in the body. The resulting monotone Booleancircuit with inputs Z 0,1(a), . . . , Z 0,n(a) and output G is denoted by Bn. Clearly, |Bn| ≤ |Π f n |. (cid:2)We are now in a position to prove that one cannot avoid an exponential blowup for PE- and NDL-rewritings; more-over, even FO-rewritings can blowup superpolynomially under the assumption that NP (cid:11)⊆ P/poly. This can be done usingthe function Cliquem,k of m(m − 1)/2 variables ei j , 1 ≤ i < j ≤ m, which returns 1 if and only if the graph with vertices{1, . . . , m} and edges {{i, j} | ei j = 1} contains a k-clique. One can show that there is a Boolean circuit with m nondetermin-istic inputs and O (m2) gates that computes Cliquem,k. As Cliquem,k is NP-complete, the question whether Cliquem,k canbe computed by polynomial-size circuits (without nondeterministic inputs) is equivalent to the open NP ⊆ P/poly problem.Further, a series of papers, started by Razborov [50], gave an exponential lower bound for the size of monotone circuits√4 (m/ log m)2/3 [2]. For monotone formulas, an even better lower bound is known:computing Cliquem,k: 2Ω(2Ω(k) for k = 2m/3 [49].k) for k ≤ 1Theorem 9. There is a sequence of CQs qn of size O (n) and OWL 2 QL-ontologies Σn of size O (n) such that(i) any PE-rewritings of qn and Σn are of size ≥ 2Ω(n1/4);(ii) any NDL-rewritings of qn and Σn are of size ≥ 2Ω((n/log n)1/12);(iii) there are no polynomial-size FO-rewritings of qn and Σn unless NP ⊆ P/poly or PH = Σ p2 .Proof. Consider the family of Boolean functions f n = Cliquem,k with m = (cid:25)n1/4(cid:26) and k = (cid:25)2m/3(cid:26) = Ω(n1/4). As the size of= q f n and Σn = Σ f n is O (n). So, claim (i) follows fromthe circuits Cn (with nondeterministic inputs) is O (m2), the size of qnLemma 8 (ii) and the lower bound for the size of monotone formulas computing Cliquem,k. Then we take the same family f nand redefine its elements f n with even n: take f n = Cliquem,k with m as above and k = (cid:25)(m/ log m)2/3(cid:26) = Ω((n/ log n)1/6).Claim (ii) follows from Lemma 8 (iii) and the lower bound on the size of monotone circuits computing Cliquem,k. If weassume that NP (cid:3) P/poly then there is no polynomial-size circuit for Cliquem,k, and so (iii) follows for the constructed f nby Lemma 8 (i). (cid:2)Using a similar argument we can also prove the following:Theorem 10. Suppose f 1, f 2, . . . is an NP-complete family of monotone Boolean functions. If NP (cid:11)⊆ P/poly then q f n and Σ f n do nothave polynomial-size FO- and NDL-rewritings.Proof. Suppose to the contrary that there are polynomial-size FO- or NDL-rewritings of q f n and Σ f n . Then, by Lemma 8 (i)and (iii), there is a family of polynomial-size circuits computing f 1, f 2, . . . . Since the family f n is NP-complete, it followsthat all families of Boolean functions in NP can be computed by polynomial-size circuits, that is NP ⊆ P/poly. (cid:2)The construction of this section also reveals the overhead of CQ answering via OWL 2 QL-ontologies compared to CQ an-swering over plain databases in complexity-theoretic terms. Indeed, since the Boolean CQs q f n are tree-shaped, the problem‘Dα |(cid:10) q f n ?’ is in P for combined complexity [60], while the problem ‘(Σ f n , Dα) |(cid:10) q f n ?’ is NP-hard. (On the other hand,both problems are in AC0 for data complexity.)We also observe that the quantifier elimination in the proof of Lemma 8 relies on the fact that |(cid:3)Dα| = 1. As we shallsee in the next two sections, if we restrict attention to data instances with at least two individuals, then Theorem 9 doesnot hold any longer.4. Polynomial rewritings with two constantsTo prove the exponential and superpolynomial lower bounds for the size of rewritings in the previous section, we estab-lished a connection between monotone circuits for Boolean functions and rewritings of certain CQs and OWL 2 QL-ontologies.In fact, this connection also suggests a way of making rewritings substantially shorter. Indeed, recall from Section 3 thatalthough no family of monotone Boolean circuits of polynomial size can compute Cliquem,k, there exists a family ofpolynomial-size circuits with nondeterministic inputs computing Cliquem,k. Nondeterministic inputs make Boolean circuitsexponentially more succinct—in the same way as nondeterministic automata are exponentially more succinct than deter-ministic ones [42]. To introduce the corresponding nondeterministic guesses into query rewritings, we can use additionalexistentially quantified variables—provided that the domain of quantification contains at least two elements (cf. [5]). For thispurpose, we can extend the signature of PE-, FO- and NDL-rewritings with a set X of constant symbols assuming that theyoccur in every relevant data instance, in which case we are talking about PE X -, FO X - and NDL X -rewritings. In this section, weshow that allowing additional constants in rewritings really makes them exponentially more succinct.52G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–59We say that a family of ontologies has the polynomial witness property (PWP, for short) if there is a polynomial d(m, n)such that, for any ontology Σ in the family, any CQ q(x) and any data instance D, whenever (Σ, D) |(cid:10) q(a), for a tuple afrom (cid:3)D , then there is a sequence of d(|q|, |Σ|) applications of tgds from Σ to D that entails q(a) (in the sense that thereis a homomorphism from q(a) to the set of atoms generated by those tgd applications). Clearly, PWP implies BDDP (but notthe other way round). The following are examples of ontology languages with the PWP:– linear tgds with predicates of bounded arity [26] and, in particular, OWL 2 QL [16],– sticky sets of tgds with predicates of bounded arity [23](note that the degree of the polynomial depends on the maximum arity of predicates).Theorem 11. Let q(x) be a CQ and Σ an ontology from a family with the PWP.(i) There is a PE{0,1}-rewriting of q and Σ whose size is polynomial in |q| and |Σ|.(ii) There is an NDL{0,1}-rewriting of q and Σ whose size is polynomial in |q| and |Σ|.Proof. Without loss of generality we assume that all predicates in Σ and q are of some arity L and that all tgds in Σhave precisely m atoms in the body and one atom in the head, and the head contains at most one existentially quantifiedvariable. In other words, all our tgds are of the form(cid:2)∀x(cid:3)P 1(t1) ∧ · · · ∧ P m(tm) → ∃z P 0(t 0),(7)where each term in the t i = (ti1, . . . , tiL), for 1 ≤ i ≤ m, is a (universally quantified) variable from x or a constant and eachterm in t0 = (t01, . . . , t0L) either belongs to x (in which case it is universally quantified) or is a constant or coincides with z(in which case it is existentially quantified). To simplify notation, we assume that q is a Boolean CQ:q = ∃ yM(cid:7)k=1Rk( yk1, . . . , ykL).We also assume that Σ contains no negative constraints (for a reduction of the general case, see [11]). In view of thePWP, there is a number d(|q|, |Σ|) polynomial in |q| and |Σ| such that, for any data instance D with (Σ, D) |(cid:10) q, thereis a sequence of d(|q|, |Σ|) applications of tgds from Σ to D that entails q. Let N = (m + 1) · d(|q|, |Σ|). Denote μ =max(K , M, N, S), where K is the number of predicates in q and Σ , and S is the number of tgds in Σ . Let Q be the set ofnatural numbers from 0 to μ.(i) F irst, we give a PEQ -rewriting qof q and Σ assuming that the constants in Q cannot occur in any predicate of datainstances but still are interpreted by distinct elements in every model (equality is a built-in predicate). Then we show howthis rewriting can be transformed to a proper PE{0,1}-rewriting (without any condition on 0 and 1 apart from that they mustoccur in all relevant data instances).(cid:4)In essence, our PEQ -rewriting guesses a sequence of N ground atoms A1, . . . , A N and then checks whether these atomsgive a positive answer to q and the sequence can indeed be obtained by a series of applications of the tgds from Σ to D(all the data atoms required for the applications must be among the Ai ). To encode the atoms A1, . . . , A N , we associatewith each predicate P a unique number, denoted [P ], so that each Ai is represented by the number of its predicate and thevalues of its arguments, which range over the domain (cid:3)D of D and the labelled nulls nulli , for 1 ≤ i ≤ N (the labelled nullsare numbers from Q , but we use this notation for readability). Thus, for each atom Ai in the sequence, 1 ≤ i ≤ N, we needthe following variables:– ri is the number of the predicate of Ai and ui1, . . . , uiL are the arguments of Ai ;– w i1, . . . , w i(cid:11), where (cid:11) is the maximum number of universally quantified variables x in tgds ((cid:11) ≤ m · L), are the argumentsof the predicates in the body of the tgd used to obtain Ai .Note that the ri range over Q and the ui j and the w il range over the domain (cid:3)D and the labelled nulls (that is, over(cid:3)D ∪ Q ). The PEQ -rewriting of q and Σ is defined by taking:(cid:9)M(cid:7)Γk ∧k=1N(cid:7)i=1(cid:10)Φi.(cid:4) = ∃ y∃u∃r∃wqThe first conjunct of q(cid:4)Γk =N(cid:15)i=1(cid:8)(cid:2)(cid:3)ri = [Rk]L(cid:7)∧j=1(cid:11)(ui j = ykj).chooses, for each atom in the query, a match among A1, . . . , A N :G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–5953The second conjunct guesses, for each ground atom A1, . . . , A N whether it is taken from the data instance or obtained by atgd application:Φi =(cid:15)(cid:2)(cid:2)(cid:3)ri = [P ](cid:3)∧ P (ui1, . . . , uiL)∨(cid:15)(cid:8)(cid:2)(cid:3)ri = [P 0]∧P is a predicate in q or Σ(cid:7)(ui j = a) ∧(cid:7)(cid:7)(ui j = w il) ∧(ui j = nulli) ∧t0 j is at0 j is xlt0 j is z(cid:11)Ψτ ,i,k.m(cid:7)k=1τ =∀x(P 1(t1)∧...∧Pm(tm)→∃z P 0(t0))∈ΣThe first group of disjuncts is for the case when Ai is taken from the data instance (ri is such that P (ui1, . . . , uiL) appearsin the data instance for a predicate P with the number ri ). The second group of disjuncts models the chase rule application,for each tgd τ in Σ . Informally, if Ai is obtained by an application of τ , then ri is the number [P 0] of the head predicateP 0 and the existential variable z of the head gets a unique labelled null value nulli (the fourth conjunct). Then, by the lastconjunct, for each of the m atoms of the body, one can choose a number ithat is less than i such that the predicate of Ai(cid:4)is the same as the predicate of the body atom and their arguments match:(cid:4)Ψτ ,i,k =(cid:16)i−1(cid:15)i(cid:4)=1(cid:2)(cid:3)ri(cid:4) = [P k]∧(cid:7)tkj =xl(ui(cid:4) j = w il) ∧(cid:17)(ui(cid:4) j = a),(cid:7)tkj =awhere the variables w il ensure that the same universally quantified variable of τ gets the same value in the body atomsand in the head (if it occurs there, see the second conjunct in the last group of Φi ). We assume that the empty disjunctionis ⊥, and so Ψτ ,1,k = ⊥, for all τ and k.(cid:4)| = O (|q| · |Σ| · N 2 · L) and that (Σ, D) |(cid:10) q ifis true in the model of D extended with the constants in Q , which are distinct and do not belong to thecan be constructed in polynomial time, |q(cid:4)It is not hard to check that q(cid:4)and only if qinterpretation of any predicate but =.We can replace the natural numbers in Q with two distinct constants, say, 0 and 1 (provided that they are present inevery data instance), thus obtaining a polynomial PE{0,1}-rewriting of q and Σ . Recall that each of the variables ui j rangesover the domain (cid:3)D and numbers from Q (more precisely, labelled nulls null1, . . . , nullN ). Thus, such a variable ui j canbe modelled by means a tuple ( ˆui j, ui j , forp = (cid:28)log |Q |(cid:29), range over {0, 1} and represent a natural number from 0 to μ in binary. More precisely, if ui j has a valuei j are all zeros; otherwise, ui j is a labelled null, say nullk, and so ˆui j is ad ∈ (cid:3)D then ˆui j is interpreted by d and ui j represent k in binary (note that 0 is not a labelled null). Similarly, we model the w il; thefixed value, say 0, and u(cid:4)ri are even simpler to model as they do not have the ˆri component. The equality atoms in the rewriting qare replaced bythe component-wise equalities and each P (ui1, . . . , uiL) is replaced by P ( ˆui1, . . . , ˆuiL) ∧= 0).i j) of variables, where ˆui j ranges over the domain (cid:3)D , while ui j, . . . , u0i j, . . . , u0i j, . . . , u0i j, . . . , u0(cid:18)(cid:18)pppppLj=1k=0(uki j(ii) We show how to construct a polynomial-size NDLQ -rewriting (Π, G) of q and Σ . Its transformation into anNDL{0,1}-rewriting can be done similarly to PEQ -rewritings. The program Π has one main rule that is very similar to thequery quses disjunction which is not allowed in a datalog rule. The eliminationof disjunction (without an exponential blowup and with small arity of predicates) is based on the equivalencein the previous construction. However, q(cid:4)(cid:4)(cid:15)(cid:15)(cid:7)ρi ≡(v = i) ∧(cid:2)(v = i) → ρi(cid:3),(8)i∈Υi∈Υi∈Υwhere Υ ⊆ Q . To this end, Π uses additional rules and intensional predicates.– OneOf (x, y, z) should hold if x is a natural number from Q in the interval from y to z (this predicate will replace thedisjunction of the (v = i) in (8)):OneOf (i, j, k),for all 0 ≤ j ≤ i ≤ k ≤ μ;– Dom(z) should hold if z appears in the data instance D or is one of the labelled nulls nullk:Dom( y j) ← P ( y1, . . . , y L),Dom(nullk),for all predicates P in q and Σ and all 1 ≤ j ≤ L,for all 1 ≤ k ≤ N;– If (x1, x2, z1, z2) should hold if x1 = x2 → z1 = z2 is true, where x1, x2 are natural numbers from Q (this predicate willreplace the implication in (8)):If (i, i, z, z) ← Dom(z),If (i, j, z1, z2) ← Dom(z1), Dom(z2),for every 0 ≤ i ≤ μ,for every 0 ≤ i (cid:11)= j ≤ μ;– IfAnd(x1, x2, y1, y2, z1, z2) should hold if (x1 = x2 ∧ y1 = y2) → z1 = z2 is true, where x1, x2, y1, y2 are natural numbersfrom Q (the rules for IfAnd are similar to those for If );54G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–59– DB(x, z, y) should hold if x = 0 and z is the number [P ] of some predicate P in q or Σ such that P ( y) ∈ D:(cid:2)(cid:3)DB0, [P ], y← P ( y),for all predicates P in q and Σ.Now we can describe the construction of the main rule of Π , which mimics q(cid:4):G ←M(cid:7)k=1Γk ∧N(cid:7)i=1Φi,where G is a 0-ary goal predicate. The components, the Γk and the Φi , are defined as follows. In these definitions, we makeuse of the quantified variables y, u, r, w with the same the intended meaning as in the previous construction; the meaningof additional quantified variables will be explained below. For each 1 ≤ k ≤ M, let(cid:9)Γk = OneOf (sk, 1, N) ∧N(cid:7)i=1(cid:2)(cid:3)sk, i, ri, [Rk]If∧L(cid:7)j=1(cid:10)If (sk, i, ui j, ykj),where sk is a fresh variable meant to be the number i of the atom Ai to which Rk( yk1, . . . , ykL) is mapped; the variable skencodes the choice of the disjunct of Γk in the previous construction; cf. (8). For each 1 ≤ i ≤ N, letΦi = OneOf (v i, 0, K ) ∧ DB(v i, ri, ui1, . . . , uiL) ∧(cid:7)(cid:9)(cid:2)(cid:3)v i, [τ ], ri, [P 0]If∧(cid:7)(cid:2)Ift0 j is av i, [τ ], ui j, a(cid:7)(cid:3)∧(cid:2)Ift0 j is xlτ =∀x(P 1(t1)∧···∧Pm(tm)→∃z P 0(t0))∈Σ(cid:2)(cid:7)(cid:3)v i, [τ ], ui j, w il∧v i, [τ ], ui j, nulliIft0 j is z(cid:10)Ψτ ,i,k,m(cid:7)(cid:3)∧k=1where v i is meant to take the number [τ ] of the tgd (1 ≤ [τ ] ≤ S) that derives the atom Ai or 0, if Ai is from the datainstance: the second conjunct accounts for the case where Ai is an atom of the data instance and the last group of conjunctsfor the case where Ai is obtained by an application of a tgd from Σ . Finally, for i > 1, we takeΨτ ,i,k = OneOf (pik, 1, i − 1) ∧(cid:2)IfAndv i, [τ ], pik, i(cid:4)(cid:3), ri(cid:4) , [P k]∧(cid:16)i−1(cid:7)i(cid:4)=1(cid:7)(cid:2)IfAndtkj =xlv i, [τ ], pik, i(cid:4), ui(cid:4) j, w il(cid:7)(cid:3)∧(cid:2)IfAndtkj =av i, [τ ], pik, i(cid:4), ui(cid:4) j, a(cid:17)(cid:3),where, for every 1 ≤ i ≤ N and 1 ≤ k ≤ m, pik is meant to be the number iin the ith chase step. We take Ψτ ,1,k = OneOf (v 1, 0, 0), which ensures v 1 = 0.(cid:4)It is straightforward to verify that (Π, G) is indeed equivalent to q(cid:4), thus establishing (ii). (cid:2)of the chase step that derives the kth atom usedAs sets of linear tgds of bounded arity and sets of sticky tgds of bounded arity enjoy the PWP, we obtain:Corollary 12. Any CQ and any set of linear tgds of bounded arity (in particular, OWL 2 QL-ontology) have polynomial-size PE{0,1}- andNDL{0,1}-rewritings.Any CQ and any set of sticky tgds of bounded arity have polynomial-size PE{0,1}- and NDL{0,1}-rewritings.The following result is an immediate consequence of the proof of Theorem 11; we shall use it to prove Lemma 15 in thenext section:Corollary 13. Let q(x) be a CQ and Σ an ontology from a family with the PWP.(i) There is a polynomial-size PE-formula γ (x, y0, y1) such that γ (x, 0, 1) is a PE{0,1}-rewriting of q and Σ .(ii) There is a polynomial-size NDL-query (Π, G(x, y0, y1)) such that (Π, G(x, 0, 1)) is an NDL{0,1}-rewriting of q and Σ .By taking the formula ∃ y0, y1 (( y0 (cid:11)= y1) ∧ γ (x, y0, y1)) with γ given in Corollary 13 (i), we also obtain the followingresult on polynomial FO-rewritability over databases with at least two individuals:Corollary 14. For any CQ q(x) and any ontology Σ from a family with the PWP, there is an FO-formula qpolynomial in |q| and |Σ| and (Σ, D) |(cid:10) q(a) if and only if D |(cid:10) qelements in (cid:3)D .(cid:4)(x) such that its size is(cid:4)(a), for any data instance D with |(cid:3)D | ≥ 2 and any tuple a ofG. Gottlob et al. / Artificial Intelligence 213 (2014) 42–5955Note that the compact representation of the FO-rewriting in this corollary is achieved—compared to the FO-rewritings ofCQs and OWL 2 QL-ontologies known so far—with the help of polynomially-many new existentially quantified variables thatare used for guessing a derivation of the given CQ in the chase.5. Separation resultsIn this section, we again consider ‘pure’ rewritings (without additional constants) and prove two separation results sayingthat NDL-rewritings can be exponentially more succinct than PE-rewritings, and that FO-rewritings can be superpolynomi-ally more succinct than PE-rewritings. To this end we need a construction for transforming Boolean formulas and circuitsinto rewritings.Consider a family f 1, f 2, . . . of monotone Boolean functions in NP and a corresponding family C1, C2, . . . of polynomial-size Boolean circuits with nondeterministic inputs. Recall that in Section 3 we constructed a family ψn of CNFs encodingthe Cn. The CNF ψn, which contains d ≤ 3|Cn| + 1 clauses with m = |Cn| Boolean variables, was then transformed into a setΣ f n of OWL 2 QL-tgds and a Boolean CQ q f n such that(Σ f n , Dα) |(cid:10) q f nif and only iff n(α) = 1,for all α ∈ {0, 1}n.Consider now the OWL 2 QL-ontology Σ ∗f n that extends Σ f n with the negative constraints(cid:2)∀x(cid:3)A0(x) ∧ B(x) → ⊥,for B(x) ∈ Θ,where Θ is the set comprising the following formulas:∃ y P (x, y),Ai(x), X 0Z i, j(x),i (x), X 1i (x),for 1 ≤ i ≤ m,for 0 ≤ i ≤ m and 1 ≤ j ≤ d with (i, j) /∈(cid:12)(cid:13)(0, 1), . . . , (0, n).We observe that |Σ ∗query q f n and the ontology Σ f n /Σ ∗negative constraints above).f n | = O (|Cn|2) and the claims of Lemma 8 are equally applicable to Σ ∗f n (the proof requires that thef n give ‘correct’ answers only for data Dα which, by definition, are consistent with theLemma 15. Let f 1, f 2, . . . be a family of monotone Boolean functions in NP and C1, C2, . . . a corresponding family of polynomial-sizeBoolean circuits with nondeterministic inputs.(i) If the f n are computed by Boolean formulas ϕn then there are a polynomial p and FO-rewritings q(cid:4)f n of q f n and Σ ∗f n such that(ii) If the f n are computed by monotone Boolean circuits Bn then there are a polynomial p and NDL-rewritings (Π f n , G) of q f n and|q(cid:4)f n | ≤ |ϕn| + p(|Cn|).Σ ∗f n such that |Π f n | ≤ 2|Bn| + p(|Cn|).Proof. (i) Let γn(0, 1) be the polynomial-size PE{0,1}-rewriting of q f n and Σ f n given by Corollary 13 (i). We denote by ϕn(x)the result of replacing each propositional variable p j in ϕn with the atom Z 0, j(x), for 1 ≤ j ≤ n, and consider the FO-query(cid:19)(cid:4)f n = ∃xq(cid:16)A0(x) ∧ϕn(x) ∨ ∃ y(cid:2)(cid:3)P ( y, x) ∧ γn(x, y)∨(cid:15)(cid:17)(cid:20)B(x).B(x)∈ΘSuppose (Σ ∗f n , D) |(cid:10) q f n . If (Σ ∗Clearly, |qPE{0,1}-rewriting is in turn polynomial in their size). It remains to show that q(cid:4)f n | = |ϕn| + p(|Cn|), for a polynomial p (note that the size of both q f n and Σ f n is quadratic in |Cn| and theirf n is an FO-rewriting of q f n and Σ ∗f n .f n , D) is inconsistent, it can only be due to the negative constraints of Σ ∗f n , in whichcase there is a ∈ (cid:3)D and B(x) ∈ Θ such that D |(cid:10) A0(a) ∧ B(a), whence D |(cid:10) qf n , D) coincideswith the chase of (Σ f n , D) and there is a homomorphism h from q f n into the chase of (Σ f n , D). Let h( y0) = a0 ∈ (cid:3)D (recallthat y0 is the root of the query q f n ). Clearly, A(a0) ∈ D. Two cases are possible now. If there is some a1 ∈ (cid:3)D \ {a0} with(cid:4)P (a1, a0) ∈ D then, as γn(0, 1) is a PE{0,1}-rewriting of q f n and Σ f n , we obtain D |(cid:10) γn(a0, a1), whence D |(cid:10) qf n . Otherwise,f n . Otherwise, the chase of (Σ ∗(cid:4)(cid:4)56G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–59D (cid:11)|(cid:10) ∃ y P ( y, a0) and Z i, j(a0) ∈ D only if i = 0 and 1 ≤ j ≤ n. Consider α defined by taking α j = 1 iff Z 0, j(a0) ∈ D, for1 ≤ j ≤ n. We obtain (Σ f n , Dα) |(cid:10) q f n , and thus, by Lemma 7, f n(α) = 1. So Dα |(cid:10) ϕn(a0), whence D |(cid:10) q(cid:4)f n . Then there is a0 ∈ (cid:3)D with A0(a0) ∈ D. If the last disjunct of qConversely, suppose D |(cid:10) qf n , D)is inconsistent, whence (Σ ∗f n , D) |(cid:10) q f n . So, from now on, we assume that the last disjunct does not hold on any a ∈ (cid:3)Dwith A0(a0) ∈ D, and so (Σ ∗f n , D) is consistent and its chase coincides with the chase of (Σ f n , D). Two cases are possiblenow. If the second disjunct holds then there is a1 ∈ (cid:3)D \ {a0} with P (a1, a0) ∈ D (note that if a0 = a1 then P (a0, a0) ∈ D,and so (Σ ∗f n , D) is inconsistent, contrary to our assumption). Then, as γn(0, 1) is a PE{0,1}-rewriting of q f n and Σ f n , weobtain (Σ f n , D) |(cid:10) q f n . Otherwise, the first disjunct, ϕn(x), holds on a0, D (cid:11)|(cid:10) ∃ y P ( y, a0) and Z i, j(a0) ∈ D only if i = 0 and1 ≤ j ≤ n. Consider α defined by taking α j = 1 iff Z 0, j(a0) ∈ D, for 1 ≤ j ≤ n. As ϕn computes f n, we have f n(α) = 1, andso, by Lemma 7, (Σ f n , D) |(cid:10) q f n . In either case, (Σ ∗(cid:4)f n .f n holds on a0 then (Σ ∗f n , D) |(cid:10) q f n .(cid:4)(ii) L et(Φn, F (0, 1)) be the polynomial-size NDL{0,1}-rewriting of q f n and Σ f n given by Corollary 13 (ii). We denote byΞn the NDL-program built from Bn by replacing each input with the respective unary predicate atom Z 0, j(x), for 1 ≤ j ≤ n.More precisely, for each gate gi with inputs gi(cid:4) and gi(cid:4)(cid:4) in the monotone Boolean circuit Bn, we take a unary predicate Q i(x)and include the following rules in Ξn:Q i(x) ← Q i(cid:4) (x), Q i(cid:4)(cid:4) (x),if gi = gi(cid:4) ∧ gi(cid:4)(cid:4) ,andQ i(x) ← Q i(cid:4) (x),Q i(x) ← Q i(cid:4)(cid:4) (x),if gi = gi(cid:4) ∨ gi(cid:4)(cid:4)(if gi(cid:4) is the jth input of Bn then Q i(cid:4) (x) denotes Z 0, j(x); and similarly for gi(cid:4)(cid:4) ). Consider now the NDL-query (Π f n , G), wherethe goal G is a fresh 0-ary predicate, and Π f n comprises the rules of Φn and Ξn as well as the following rules:G ← A0(x), Q |Bn|(x),G ← A0(x), P ( y, x), F (x, y),G ← A0(x), B(x),for all B(x) ∈ Θ(recall that Q |Bn| corresponds to the output gate of Bn). Clearly, |Π f n | ≤ 2|Bn| + p(|Cn|), for a polynomial p (note that thesize of both q f n and Σ f n is quadratic in |Cn| and their NDL{0,1}-rewriting is in turn polynomial in their size). We claim that(Π f n , G) is an NDL-rewriting of q f n and Σ ∗f n ; the proof is as in case (i). (cid:2)We are now in a position to show that NDL-rewritings can be exponentially more succinct than PE-rewritings. To thism3 of m3 variables xi jk, 1 ≤ i, j, k ≤ m, defined as follows. We say that 1 generatesend, we use the Boolean function Genk ≤ m if either k = 1 or xi jk = 1, for some i and j, and 1 generates both i and j. Genm3 (x111, . . . , xmmm) returns 1 if and onlyif 1 generates m. This monotone function, also known as Path System Accessibility [22], is computable by polynomial-sizemonotone circuits [58]. On the other hand, any monotone formula computing Gen, for someε > 0 [48].m3 is of size at least 2mεTheorem 16. There is a sequence of CQs qn of size O (n) and OWL 2 QL-ontologies Σn of size O (n) that have polynomial-size NDL-rewritings, but any PE-rewritings of qn and Σn are of size ≥ 2nε, for some ε > 0.Proof. It is known that Genm3 can be computed by monotone Boolean circuits of size p(m), for a polynomial p. So, for eachn, we can choose a suitable m = Θ(nδ), with a fixed δ > 0, such that the family of functions f n = Genm3 gives rise to thef n of size O (n). By Lemma 15 (ii), there are NDL-rewritings of qn and Σnqueries qnof size polynomial in n. However, by Lemma 8 (ii), any PE-rewritings for qn and Σn are of size ≥ 2mε0 , for some ε0 > 0.Then there is ε > 0 such that any PE-rewritings of qn and Σn are of size ≥ 2nε= q f n and OWL 2 QL-ontologies Σn = Σ ∗. (cid:2)FO-rewritings can also be substantially shorter than the PE-rewritings. To show this, we need the function Matching2mof m2 variables ei j , 1 ≤ i, j ≤ m, that returns 1 if there is a perfect matching in the bipartite graph G with m vertices in eachpart, which contains an edge {i, j} if and only if ei j = 1; that is, it returns 1 if there is a subset E of edges in G such that ev-ery node of G occurs exactly once in E. It is not hard to see that Matching2m can be computed by a Boolean circuit with m2nondeterministic inputs and O (m2) gates. On the other hand, monotone Boolean formulas computing Matching2m are ex-ponential, 2Ω(m) [49]; but there are non-monotone Boolean formulas computing this function and having size m O (log m) [10].So, we can use the standard padding trick from circuit complexity [3, p. 57] to show that FO-rewritings can be superpoly-nomially more succinct than PE-rewritings:Theorem 17. There is a sequence of CQs qn of size O (n) and OWL 2 QL-ontologies Σn size O (n) that have polynomial-size FO-rewritings, but any PE-rewritings of qn and Σn are of size ≥ 2Ω(2log1/2 n).Proof. We define f n to be a slightly modified Matching2m with m = (cid:25)2log1/2 n(cid:26): namely,f n has max((cid:25)n1/4(cid:26), m2) variables,of which m2 are the proper variables of Matching2m, while the rest are dummy variables used for padding (note thatG. Gottlob et al. / Artificial Intelligence 213 (2014) 42–5957(cid:25)n1/4(cid:26) > m2, for all sufficiently large n). Using Lemma 15 (i) and observing that m O (log m) = n O (1), we obtain a polyno-mial upper bound for the size of FO-rewritings. The required superpolynomial lower bound for PE-rewritings follows fromLemma 8 (ii). (cid:2)Unfortunately, no separation results for FO- and NDL-rewritings are known at the moment. As follows from the connec-tion between rewritings and various computation models for monotone Boolean functions established in this article, suchresults would imply the corresponding separation results for formulas and monotone circuits, thereby giving solutions tomajor open problems in Boolean circuit complexity [29].6. ConclusionsWe have shown in this article that FO-rewritability of conjunctive queries and OWL 2 QL-ontologies does not yet meanthat database systems can evaluate the rewritings as efficiently as they usually do for standard SQL queries. Indeed, therewritings can be prohibitively large and/or complex compared to the user queries. We have also seen that the size ofrewritings depends on the logical and non-logical means we want or are allowed to use. These results clearly indicate thatmore theoretical and experimental research is needed to make the OBDA paradigm successful. Here we briefly outline someimportant directions for future research that are related to this article.On the one (theoretical) hand, we obviously need various conditions ensuring efficient OBDA, with first promisingsteps having already been made. For example, a sufficient semantic-based condition on CQs and OWL 2 QL-ontologies thatguarantees polynomial PE-rewritability has been obtained in [33]. It has also been demonstrated [30,31] that there existpolynomial-size NDL-rewritings of CQs and OWL 2 QL-ontologies of depth 1 (whose chases do not contain two labellednulls that are involved in some relation), as well as polynomial-size PE-rewritings of tree-shaped CQs (but not of arbi-trary ones). For tree-shaped Boolean CQs q, the problem ‘(Σ, D) |(cid:10) q?’ turns out to be fixed-parameter tractable (withparameter |q|) [31]. Moreover, any tree-shaped CQ and OWL 2 QL ontology with polynomially-many tree-witnesses have apolynomial-size NDL-rewriting [8]. A kind of preservation result has been obtained in [8]: if CQs in some class can beevaluated in polynomial time over plain databases, then answering CQs in that class over OWL 2 QL-ontologies withoutrole inclusion axioms, that is, without tgds of the form ∀x, y (P (x, y) → R(x, y)), is also tractable (a polynomial-time NDL-rewriting algorithm is given for acyclic CQs). These initial results open a way to a more comprehensive description ofclasses of queries and ontologies with and without polynomial rewritability. To fully understand the complexity of OBDAwith OWL 2 QL-ontologies, we also plan to investigate the size of rewritings over a fixed ontology and the size of rewritingsof tree-shaped CQs and ontologies of bounded depth.On the other (practical) hand, we have to study the structure of queries and ontologies that can typically be used in OBDAsystems. The recent experiments [20,35,46,54,52,51] indicate that rewritings of the available ‘real-world’ CQs and ontologiesare often of acceptable size and can be further optimised using various techniques. However, the ontologies used in thoseexperiments do not seem to be sufficiently representative. It would also be interesting to evaluate performance of databasesystems on rewritings with additional quantifiers and special constants, which can be used to encode nondeterministicguesses in a compact way as in Section 4 (another rewriting of [33] employs a single special constant to guess whether anexistentially quantified variable in the query is matched in (cid:3)D or in the labelled nulls). Additional constants are also usedin the combined approach to OBDA [40,37–39], where they represent the labelled nulls in the database.AcknowledgementsThis research was partially funded by EPSRC joint grants EP/H051511 and EP/H05099X: “ExODA: Integrating DescriptionLogics and Database Technologies for Expressive Ontology-Based Data Access”, the Russian Foundation for Basic Researchand the programme Leading Scientific Schools.References[1] S. Abiteboul, R. Hull, V. Vianu, Foundations of Databases, Addison-Wesley, 1995.[2] N. Alon, R. Boppana, The monotone circuit complexity of Boolean functions, Combinatorica 7 (1) (1987) 1–22.[3] S. Arora, B. Barak, Computational Complexity: A Modern Approach, 1st Ed., Cambridge University Press, New York, NY, USA, 2009.[4] A. Artale, D. Calvanese, R. Kontchakov, M. Zakharyaschev, The DL-Lite family and relations, J. Artif. Intell. Res. 36 (2009) 1–69.[5] J. Avigad, Eliminating definitions and Skolem functions in first-order logic, ACM Trans. Comput. Log. 4 (3) (2003) 402–415.[6] J.-F. Baget, M. Leclère, M.-L. Mugnier, E. Salvat, Extending decidable cases for rules with existential variables, in: Proc. of the 21st Int. Joint Conf. onArtificial Intelligence, IJCAI 2009, IJCAI, 2009, pp. 677–682.[7] J.-F. Baget, M. Leclère, M.-L. Mugnier, E. Salvat, On rules with existential variables: walking the decidability line, Artif. Intell. 175 (9–10) (2011)1620–1654.[8] M. Bienvenu, M. Ortiz, M. Simkus, G. Xiao, Tractable queries for lightweight description logics, in: Proc. of the 23rd Int. Joint Conf. on ArtificialIntelligence, IJCAI 2013, AAAI Press/IJCAI, 2013, pp. 768–774.[9] M. Bienvenu, B. ten Cate, C. Lutz, F. Wolter, Ontology-based data access: a study through disjunctive datalog, CSP, and MMSNP, in: Proc. of the 32ndACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, PODS 2013, ACM, 2013, pp. 213–224.[10] A. Borodin, J. von zur Gathen, J.E. Hopcroft, Fast parallel matrix and gcd computations, in: Proc. of the 23rd Annual Symposium on Foundations ofComputer Science, FOCS’82, IEEE Computer Society, 1982, pp. 65–71.[11] A. Calì, G. Gottlob, T. Lukasiewicz, A general datalog-based framework for tractable query answering over ontologies, J. Web Semant. 14 (2012) 57–83.58G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–59[12] A. Calì, G. Gottlob, A. Pieris, Advanced processing for ontological queries, Proc. VLDB Endow. 3 (1) (2010) 554–565.[13] A. Calì, G. Gottlob, A. Pieris, Towards more expressive ontology languages: the query answering problem, Artif. Intell. 193 (2012) 87–128.[14] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, R. Rosati, DL-Lite: tractable description logics for ontologies, in: Proc. of the 20th Nat. Conf. onArtificial Intelligence, AAAI 2005, AAAI Press, 2005, pp. 602–607.[15] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, R. Rosati, Data complexity of query answering in description logics, in: Proc. of the 10th Int.Conf. on the Principles of Knowledge Representation and Reasoning, KR 2006, AAAI Press, 2006, pp. 260–270.[16] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, R. Rosati, Tractable reasoning and efficient query answering in description logics: the DL-Litefamily, J. Autom. Reason. 39 (3) (2007) 385–429.[17] C. Chekuri, A. Rajaraman, Conjunctive query containment revisited, Theor. Comput. Sci. 239 (2) (2000) 211–229.[18] A. Chortaras, D. Trivela, G. Stamou, Optimized query rewriting for OWL 2 QL, in: Proc. of the 23rd Int. Conf. on Automated Deduction, CADE-23, in:Lecture Notes in Computer Science, vol. 6803, Springer, 2011, pp. 192–206.[19] J. Dolby, A. Fokoue, A. Kalyanpur, L. Ma, E. Schonberg, K. Srinivas, X. Sun, Scalable grounded conjunctive query evaluation over large and expres-sive knowledge bases, in: Proc. of the 7th Int. Semantic Web Conf., ISWC 2008, in: Lecture Notes in Computer Science, vol. 5318, Springer, 2008,pp. 403–418.[20] T. Eiter, M. Ortiz, M. Šimkus, T.-K. Tran, G. Xiao, Query rewriting for Horn-SHIQ plus rules, in: Proc. of the 26th AAAI Conf. on Artificial Intelligence,AAAI 2012, AAAI Press, 2012.[21] J. Flum, M. Grohe, Parameterized Complexity Theory, Texts in Theoretical Computer Science. An EATCS Series, Springer, 2006.[22] M. Garey, D. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W. H. Freeman & Co., New York, NY, USA, 1979.[23] G. Gottlob, M. Manna, A. Pieris, Polynomial combined rewritings for existential rules, in: Proc. of the 14th Int. Conf. on the Principles of KnowledgeRepresentation and Reasoning, KR 2014, AAAI Press, 2014.[24] G. Gottlob, G. Orsi, A. Pieris Query rewriting and optimization for ontological databases, arXiv:1405.2848 [cs.DB], 12 May 2014.[25] G. Gottlob, G. Orsi, A. Pieris, Ontological queries: rewriting and optimization, in: Proc. of the 27th Int. Conf. on Data Engineering, ICDE 2011, IEEEComputer Society, 2011, pp. 2–13.[26] G. Gottlob, T. Schwentick, Rewriting ontological queries into small nonrecursive datalog programs, in: Proc. of the 13th Int. Conf. on the Principles ofKnowledge Representation and Reasoning, KR 2012, AAAI Press, 2012, pp. 254–263.[27] M. Grohe, T. Schwentick, L. Segoufin, When is the evaluation of conjunctive queries tractable?, in: Proc. of the 33rd ACM SIGACT Symposium on Theoryof Computing, STOC’01, ACM, 2001, pp. 657–666.[28] S . Heymans, L. Ma, D. Anicic, Z. Ma, N. Steinmetz, Y. Pan, J. Mei, A. Fokoue, A. Kalyanpur, A. Kershenbaum, E. Schonberg, K. Srinivas, C. Feier, G. Hench,B. Wetzstein, U. Keller, Ontology reasoning with large data repositories, in: Ontology Management, Semantic Web, Semantic Web Services, and BusinessApplications, in: Semantic Web and Beyond, vol. 7, Springer, 2008, pp. 89–128.[29] S. Jukna, Boolean Function Complexity: Advances and Frontiers, Springer, 2012.[30] S. Kikot, R. Kontchakov, V. Podolskii, M. Zakharyaschev, Query rewriting over shallow ontologies, in: Proc. of the 26th Int. Workshop on DescriptionLogics, DL 2013, vol. 1014, CEUR-WS, 2013, pp. 316–327.[31] S. Kikot, R. Kontchakov, V. Podolskii, M. Zakharyaschev, On the succinctness of query rewriting over OWL 2 QL ontologies with shallow chases, CoRR,arXiv:1401.4420 [abs], 2014.[32] S. Kikot, R. Kontchakov, V.V. Podolskii, M. Zakharyaschev, Exponential lower bounds and separation for query rewriting, in: Proc. of the 39th Int. Collo-quium on Automata, Languages, and Programming, Part II, ICALP 2012, in: Lecture Notes in Computer Science, vol. 7392, Springer, 2012, pp. 263–274.[33] S. Kikot, R. Kontchakov, M. Zakharyaschev, Conjunctive query answering with OWL 2 QL, in: Proc. of the 13th Int. Conf. on the Principles of KnowledgeRepresentation and Reasoning, KR 2012, AAAI Press, 2012, pp. 275–285.[34] P.G. Kolaitis, M.Y. Vardi, Conjunctive-query containment and constraint satisfaction, in: Proc. of the 17th ACM SIGACT-SIGMOD-SIGART Symposium onPrinciples of Database Systems, PODS’98, ACM Press, 1998, pp. 205–213.[35] M. König, M. Leclère, M.-L. Mugnier, M. Thomazo, A sound and complete backward chaining algorithm for existential rules, in: Proc. of the 6th Int.Conf. on Web Reasoning and Rule Systems, RR 2012, in: Lecture Notes in Computer Science, vol. 7497, Springer, 2012, pp. 122–138.[36] M. König, M. Leclère, M.-L. Mugnier, M. Thomazo, On the exploration of the query rewriting space with existential rules, in: Proc. of the 7th Int. Conf.on Web Reasoning and Rule Systems, RR 2013, in: Lecture Notes in Computer Science, vol. 7994, Springer, 2013, pp. 123–137.[37] R. Kontchakov, C. Lutz, D. Toman, F. Wolter, M. Zakharyaschev, The combined approach to query answering in DL-Lite, in: Proc. of the 10th Int. Conf.on the Principles of Knowledge Representation and Reasoning, KR 2010, AAAI Press, 2010.[38] R. Kontchakov, C. Lutz, D. Toman, F. Wolter, M. Zakharyaschev, The combined approach to ontology-based data access, in: Proc. of the 22nd Int. JointConf. on Artificial Intelligence, IJCAI 2011, AAAI Press, 2011, pp. 2656–2661.[39] C. Lutz, I. Seylan, D. Toman, F. Wolter, The combined approach to OBDA: taming role hierarchies using filters, in: Proc. of the 12th Int. Semantic WebConf., ISWC 2013, in: Lecture Notes in Computer Science, vol. 8218, Springer, 2013, pp. 314–330.[40] C. Lutz, D. Toman, F. Wolter, Conjunctive query answering in the description logic EL using a relational database system, in: Proc. of the 21st Int. JointConf. on Artificial Intelligence, IJCAI 2009, IJCAI, 2009, pp. 2070–2075.[41] B.J. McMahan, G. Pan, P. Porter, M.Y. Vardi, Projection pushing revisited, in: Proc. of the 9th Int. Conf. on Extending Database Technology, EDBT, in:Lecture Notes in Computer Science, vol. 2992, Springer, 2004, pp. 441–458.[42] A.R. Meyer, M.J. Fischer, Economy of description by automata, grammars, and formal systems, in: Proc. of the 12th Annual Symposium on Switchingand Automata Theory, SWAT/FOCS’71, IEEE Computer Society, 1971, pp. 188–191.[43] G. Orsi, A. Pieris, Optimizing query answering under ontological constraints, Proc. VLDB Endow. 4 (11) (2011) 1004–1015.[44] M. Ortiz, S. Rudolph, M. Simkus, Query answering in the Horn fragments of the description logics SHOIQ and SROIQ, in: Proc. of the 22nd Int. JointConf. on Artificial Intelligence, IJCAI 2011, IJCAI/AAAI, 2011, pp. 1039–1044.[45] H. Pérez-Urbina, B. Motik, I. Horrocks, A comparison of query rewriting techniques for DL-Lite, in: Proc. of the 22nd Int. Workshop on DescriptionLogics, DL 2009, vol. 477, CEUR-WS, 2009.[46] H. Pérez-Urbina, E. Rodríguez-Díaz, M. Grove, G. Konstantinidis, E. Sirin, Evaluation of query rewriting approaches for OWL 2, in: Proc. of SSWS+HPCSW2012, vol. 943, CEUR-WS, 2012.[47] A. Poggi, D. Lembo, D. Calvanese, G. De Giacomo, M. Lenzerini, R. Rosati, Linking data to ontologies, J. Data Semant. X (2008) 133–173.[48] R. Raz, P. McKenzie, Separation of the monotone NC hierarchy, in: Proc. of the 38th Annual Symposium on Foundations of Computer Science, FOCS’97,IEEE Computer Society, 1997, pp. 234–243.[49] R. Raz, A. Wigderson, Monotone circuits for matching require linear depth, J. ACM 39 (3) (1992) 736–744.[50] A. Razborov, Lower bounds for the monotone complexity of some Boolean functions, Dokl. Akad. Nauk SSSR 281 (4) (1985) 798–801.[51] M. Rodríguez-Muro, R. Kontchakov, M. Zakharyaschev, Ontology-based data access: ontop of databases, in: Proc. of the 12th Int. Semantic Web Conf.,ISWC 2013, in: Lecture Notes in Computer Science, vol. 8218, Springer, 2013, pp. 558–573.[52] M. Rodríguez-Muro, R. Kontchakov, M. Zakharyaschev, Ontop at work, in: Proc. of the 10th Int. Workshop on OWL: Experiences and Directions, OWLED2013, vol. 1080, CEUR-WS, 2013.[53] R. Rosati, On conjunctive query answering in EL, in: Proc. of the 2007 Int. Workshop on Description Logics, DL 2007, vol. 250, CEUR-WS, 2007.G. Gottlob et al. / Artificial Intelligence 213 (2014) 42–5959[54] R. Rosati, Prexto: query rewriting under extensional constraints in DL-Lite, in: Proc. of the 9th Extended Semantic Web Conf., EWSC 2012, in: LectureNotes in Computer Science, vol. 7295, Springer, 2012, pp. 360–374.[55] R. Rosati, A. Almatelli, Improving query answering over DL-Lite ontologies, in: Proc. of the 10th Int. Conf. on the Principles of Knowledge Representationand Reasoning, KR 2010, AAAI Press, 2010, pp. 290–300.[56] B. Rossman, Homomorphism preservation theorems, J. ACM 55 (2008) 3.[57] E. Salvat, M.-L. Mugnier, Sound and complete forward and backward chaining of graph rules, in: Proc. of the 4th Int. Conf. on Conceptual Structures,ICCS’96, in: Lecture Notes in Computer Science, vol. 1115, Springer, 1996, pp. 248–262.[58] I.A. Stewart, Logical description of monotone NP problems, J. Log. Comput. 4 (4) (1994) 337–357.[59] G. Tseitin, On the complexity of derivation in propositional calculus,in: Automation of Reasoning 2: Classical Papers on Computational Logic1967–1970, Springer, 1983, pp. 466–483.[60] M. Yannakakis, Algorithms for acyclic database schemes, in: Proc. of the 7th Int. Conf. on Very Large Data Bases, VLDB’81, IEEE Computer Society, 1981,pp. 82–94.