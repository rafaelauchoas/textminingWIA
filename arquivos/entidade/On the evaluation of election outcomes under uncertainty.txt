Artificial Intelligence 189 (2012) 1–18Contents lists available at SciVerse ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintOn the evaluation of election outcomes under uncertaintyNoam Hazon a,∗, Yonatan Aumann a, Sarit Kraus a, Michael Wooldridge ba Department of Computer Science, Bar-Ilan University, Ramat Gan, Israelb Department of Computer Science, University of Liverpool, Liverpool, United Kingdoma r t i c l ei n f oa b s t r a c tArticle history:Received 7 March 2010Received in revised form 18 April 2012Accepted 30 April 2012Available online 3 May 2012Keywords:Computational social choiceVoting rulesWe investigate the extent to which it is possible to compute the probability of a particularcandidate winning an election, given imperfect information about the preferences of theelectorate. We assume that for each voter, we have a probability distribution over a setof preference orderings. Thus, for each voter, we have a number of possible preferenceorderings – we do not know which of these orderings actually represents the preferencesof the voter, but for each ordering, we know the probability that it does. For the case wherethe number of candidates is a constant, we are able to give a polynomial time algorithmto compute the probability that a given candidate will win. We present experimentalresults obtained with an implementation of the algorithm, illustrating how the algorithm’sperformance in practice is better than its predicted theoretical bound. However, when thenumber of candidates is not bounded, we prove that the problem becomes #P-hard forthe Plurality, k-approval, Borda, Copeland, and Bucklin voting rules. We further show thateven evaluating if a candidate has any chance of winning is NP-complete for the Pluralityvoting rule in the case where voters may have different weights. With unweighted voters,we give a polynomial algorithm for Plurality, and show that the problem is hard for manyother voting rules. Finally, we give a Monte Carlo approximation algorithm for computingthe probability of a candidate winning in any settings, with an error that is as small asdesired.© 2012 Elsevier B.V. All rights reserved.1. IntroductionSocial choice theory is concerned with making group decisions in situations where the preferences of participants in thedecision-making process may be different [1]. The mechanism by which such a collective decision is made is typically a vot-ing procedure. In a voting procedure, participants (voters) express their preferences via votes, and the voting procedure thendefines the social outcome chosen as a function of the votes cast. A fundamental issue in the social choice literature is thedesign of voting procedures that will select a social outcome which reflects the preferences expressed by voters as closelyas possible [13]. In recent years, the computational aspects of social choice theory have been increasingly studied [20]. Froma computational perspective, perhaps the most natural question relating to voting is the following: Given the preferences/votesof all the voters, is it possible to compute efficiently the winning outcome according to a particular voting rule? Fortunately, it seemsthat relatively few widely used voting rules are hard to compute in this sense [5]. Another key computational question thathas been studied in the context of voting procedures is that of manipulation: the extent to which it is computationally easyor hard for a voter to determine how to vote so as to achieve the best outcome possible for themselves [4,15,19].As the references above indicate, the computational aspects of voting procedures have been increasingly studied inrecent years. However, many computational studies of voting procedures assume perfect information about voter preferences* Corresponding author.E-mail addresses: hazonn@cs.biu.ac.il (N. Hazon), aumann@cs.biu.ac.il (Y. Aumann), sarit@cs.biu.ac.il (S. Kraus), mjw@liv.ac.uk (M. Wooldridge).0004-3702/$ – see front matter © 2012 Elsevier B.V. All rights reserved.http://dx.doi.org/10.1016/j.artint.2012.04.0092N. Hazon et al. / Artificial Intelligence 189 (2012) 1–18or votes.1 That is, when we compute the social outcome, we are assumed to have complete and correct knowledge of thepreferences/votes of all the voters. However, there are important settings in which obtaining the complete preferences/votesof all voters is either not realistic or else not desirable:• Communication can be unreliable. Social choice theory largely ignores the possibility that preferences/votes may be lost intransit. However, if, for example, voting takes place via a communications network such as the Internet, then thisassumption is not valid. Data communications networks are inherently unreliable, and in many domains, reliablecommunication is simply impossible. In such situations, we may need to make social choices without access to thepreferences/votes of all voters.• Communication can be expensive. In some situations, the cost associated with gathering complete preferences/votes fromvoters may be unrealistically high. For example, if a decision is required very quickly, then the time required to gatherall preferences/votes in a large system may be unacceptable.For these reasons, we study the computational aspects of voting rules with an imperfect information model of prefer-ences/votes. There are of course many ways in which one could model incomplete information about voter preferences.For example, one model that has been studied in the literature is that of incomplete models of preferences [27,30]. Here itis assumed that we have a partial but nevertheless correct model of the preferences of voters. Intuitively, we know howvoters rank some of the candidates, but not all of them. One can then ask, for example, whether there is some “completion”of the preferences of voters that would lead to the election of a particular candidate.In our work, we use a different model of incomplete information; we do not claim this model is superior to thatof [27,30], but it provides an interesting alternative framework for modeling voting scenarios with incomplete information.We assume that for each voter, we have a probability distribution over a set of preference orderings. The idea is that although wedo not know a voter’s preference ordering exactly, we know that it is one of a set of possible orderings (typically a subsetof the overall set of possible preference orders), and we have a probability distribution over these. This information may,for example, be obtained from historical voting data, or by sampling. In this setting, the following fundamental questionarises: Given such an incomplete information model of voter preferences, a particular candidate, and a particular voting rule, what isthe probability that the given candidate would win using the given voting rule, assuming the given voter preference model? We referto this as the Evaluation problem. The Evaluation problem has received very little attention to date.2 Our aim is thus togain an understanding of the computational properties of this problem; and in particular, classes of problem instances forwhich Evaluation is computationally easy, and classes of problem instances for which it is computationally hard.The remainder of the paper is structured as follows. We first give some background and review some common votingrules in Section 2. We formally define theEvaluation problem in Definition 1. In Section 3, we first give a polynomialalgorithm to solve the evaluation problem if the number of candidates is a constant. While a result in [16] establishesthat Evaluation is NP-hard for several key voting procedures, even under quite stringent assumptions about probabilitydistributions, we show that this result holds only for weighted voting rules with weights that are not bounded by poly(n).We then experimentally evaluate our algorithm, showing that the actual running time and space are smaller than theasymptotic bound. Therefore, we also test how many voters the polynomial-time algorithm can handle for a given set ofcandidates. The results demonstrate that even with 6 or 7 candidates, the algorithm can handle more than 100 voters, whichsuggests that it may be used in many real-world voting scenarios. If the number of candidates is not bounded, the evaluationproblem becomes much harder: we show in Section 4 that even for the well-known Plurality, k-approval, Borda, Copeland,and Bucklin voting rules, the problem is #P-hard. We then analyze a simpler question, known as the Chance-Evaluationproblem (Definition 2). This question simply asks whether a candidate has any chance of being the winner (i.e., whetherthe probability that the candidate will win is greater than 0). Surprisingly, this problem is shown to be NP-complete (inthe strong sense) even for the Plurality voting rule, when voters do not all have equal weights. We give a polynomial timealgorithm for Plurality when all voters have equal weights, and show that the Chance-Evaluation problem is hard for manyother voting rules (including k-approval, Borda, Copeland and Bucklin). Finally, we present a Monte Carlo algorithm that isable to approximately answer even the Evaluation problem where the number of candidates is a parameter, with an erroras small as desired. We discuss related work in Section 5. Table 1 summarizes our key results (for comparison, we alsoinclude results from [16]).2. Preliminary definitionsAn election is given by a set of candidates (also referred to as alternatives) C = {c1, . . . , cm} and a set of voters V ={1, . . . , n}. Each voter i ∈ V is associated with a preference order R i , which is a total order over C . A vector R = (R1, . . . , Rn),containing a preference order for each voter, is called a preference profile.A voting rule F is a mapping from the set of all preference profiles to the set of candidates: if F (R) = c, we say thatthat could bec wins under F in R. A voting rule is said to be anonymous if F (R) = F (R(cid:4)) for all preference profiles R(cid:4)1 Not all previous studies have assumed perfect information: we discuss other imperfect information models and the results associated with these below.2 The exception we know of is the work of [16]; we discuss the relationship of our work to [16] in Section 5.N. Hazon et al. / Artificial Intelligence 189 (2012) 1–183Table 1Summary of key results. The parentheses near a complexity class indicates the voting rules for which the results have been proved. Key: all = any(polynomial-time computable) voting rule, p = Plurality, m = Maximin, 1 = Borda, Copeland, Maximin, STV, 2 = k-approval, Borda, Copeland, Bucklin.Number of candidatesWeightsConstantParameterequalbounded by poly(n)otherwiseequalbounded by poly(n)otherwiseApproximationanyChance-EvaluationP(all)P(all)NP-hard(1) [16]P(p), NP-complete(m,2)NP-complete(p,m,2)NP-complete(p,m,2)P(all)EvaluationP(all)P(all)NP-hard(1) [16]#P-hard(p,2)#P-hard(p,2)#P-hard(p,2)P(all)obtained by permuting the entries of R. In this paper we restrict our attention to anonymous voting rules only. In addition,we only consider voting rules that are polynomial-time computable.During an election, each voter i submits a preference order Li , representing their “vote”. The outcome of the election isthen given by F (L1, . . . , Ln). We will assume that the voters are truthful, i.e., for each voter i, Li = R i . Of course, in general,voters will not necessarily be truthful, but for the purposes of the present paper we will ignore this possibility.Voting rules: We will now define the main voting rules considered in this paper. Before we begin, a small technical remark.In the definition of a voting rule we gave above (i.e., as a function F from the set of preference profiles to the set ofcandidates), we implicitly required that voting rules are deterministic, in the sense that they select exactly one winner.The voting rules we consider in what follows do not quite fit this definition. All of these rules work by assigning scores tocandidates on the basis of votes; the winner is then selected from the set of candidates with the highest score by usinga tie-breaking rule, i.e., a mapping T : 2C → C that satisfies T (S) ∈ S. We consider two tie-breaking rules: random, wherethe winner is randomly selected among all the tied candidates; and lexicographic, where given a set of tied candidates thewinner is the candidate that is maximal with respect to a fixed ordering (cid:6). (Our results can be easily shown to hold forother tie-breaking rules.) Now, if we break ties at random, then the voting rule is not deterministic, and does not quite fitwith our formal definition above. However, this observation does not affect our results in any way.Given a vector α = (α1, . . . , αm) with α1 (cid:2) · · · (cid:2) αm, the score sα(c) of a candidate c ∈ C under a positional scoring ruleFα is given bysα(c) =(cid:2)i∈Vα j(i,c)where j(i, c) is the position in which voter i ranks candidate c. Note that many classic voting rules can be represented usingthis framework. For example:• Plurality is the scoring rule with α = (1, 0, . . . , 0);• Borda is the scoring rule with α = (m − 1, m − 2, . . . , 1, 0); and• k-approval is the scoring rule with α given by α1 = · · · = αk = 1, αk+1 = · · · = αm = 0.The Bucklin rule can be viewed as an adaptive version of k-approval. We say that k, 1 (cid:3) k (cid:3) m, is the Bucklin winning roundif for any j < k no candidate is ranked in top j positions by at least (cid:7)n/2(cid:8) voters, and there exists some candidate that isranked in top k positions by at least (cid:7)n/2(cid:8) voters. We say that the candidate c’s score in round j is his j-approval score, andhis Bucklin score sB (c) is his k-approval score, where k is the Bucklin winning round. The Bucklin winner is the candidatewith the highest Bucklin score. Observe that the Bucklin score of the Bucklin winner is at least (cid:7)n/2(cid:8).The Copeland rule is defined based on the notion of pairwise elections. We say that a candidate c ∈ C beats another. TheCopeland score s C (c) of a candidate c is(cid:4) ∈ C in a pairwise election if a majority of voters rank c above ccandidate cgiven by the number of pairwise elections that c wins minus the number of pairwise elections that c loses.(cid:4)Weighted voters: Our model can be extended to the situation where not all voters are equally important by assigning aninteger weight, w i , to each voter i. To compute the winner on a profile (R1, . . . , Rn) under a voting rule F given voters’weights w = (w 1, . . . , wn), we apply F on a modified profile which, for each i = 1, . . . , n, contains w i copies of R i . Whenall the weights are equal, we say that the voters are unweighted.Imperfect information: To model imperfect information, we assume that we have for each voter at most l possible pref-erence orders, which are permutations over the available alternatives. Each such order is associated with a non-zeroprobability that this voter will choose to vote for it, and the sum of probabilities of the given preference orders is 1;all the other possible preference orders which are not explicitly given are assumed to have a probability of 0. If all prob-abilities are 0 or 1 then the scenario is one of perfect information, otherwise it is one of imperfect information. Considerthe following illustrative example. Suppose we have four candidates, c1, c2, c3, and c4, and three voters, V 1, V 2 and V 3.4N. Hazon et al. / Artificial Intelligence 189 (2012) 1–18Table 2An example of our imperfect information model of voter preferences.V 113 (c1, c2, c3, c4)12 (c2, c1, c3, c4)16 (c3, c1, c2, c4)V 234 (c4, c2, c1, c3)14 (c2, c1, c3, c4)V 3910 (c4, c2, c3, c1)110 (c3, c1, c4, c2)Table 3Winning probabilities for each candidate, rounded to 3 decimal places. Bold font represents thehighest probability in each voting rule.c1c2c3c4Plurality0.0360.1780.0530.733Borda0.0580.70.0170.225Copeland0.0520.2560.0170.675The voters’ preferences are summarized in Table 2 with a probability associated to each preference order. In this examplen = l = 3 (i.e., three voters and three possible preference profiles) and m = 4 (four candidates).We consider the case where voters’ choices are independent. If we collect from each voter just one preference order(from the ones that are associated with him) we get one possible preference profile that we call a voting scenario, fromwhich the winner can be calculated using one of the voting rules listed above (Plurality, Borda, . . . ). The probability of anygiven voting scenario occurring is simply the product of the probabilities of its preference orders from the different voters.Evaluation and Chance-Evaluation: We are now ready to define the main problems that we study throughout the remainderof this paper.Definition 1 (Evaluation). Given candidates C , voters V , an imperfect information model of voters’ preferences, as describedabove, a specific candidate c∗ ∈ C , and a voting rule F , what is the probability that cwill be chosen using F ?∗The answer to this question is the sum of probabilities of all the voting scenarios where cwins using F . For example,recall the imperfect information model of preferences shown in Table 2. Assume that random tie-breaking rule is used. Thewinning probabilities for each candidate under the Plurality, Borda and Copeland voting rules are summarized in Table 3.Note that c4 has the highest probability of winning under Plurality and Copeland, but c2 has the highest probability ofwinning under Borda.∗Note that the complexity of the Evaluation problem is a function of the number of voters (n), the number of candidates(m), and the number of possible non-zero probability preference orders for each voter (l). We also define a related decisionproblem, which asks a weaker question.Definition 2 (Chance-Evaluation). Given candidates C , voters V , an imperfect information model of voters’ preferences, aswill be chosen using F greaterdescribed above, a specific candidate cthan zero?∗ ∈ C , and a voting rule F , is the probability that c∗Of course, an answer to the Evaluation problem immediately yields an answer to the Chance-Evaluation problem, soif the former problem is easy, then so is the latter. However, it could in principle be the case that Evaluation is hard whileChance-Evaluation is easy, which suggests that it is worth studying Chance-Evaluation as a problem in its own right.Note that the Chance-Evaluation problem also seems to be a very natural one. In many cases there will be somecandidates that do not have any chance of winning, and a voter might reasonably contemplate which candidates have nochance of winning when deciding how to vote.In the following sections, we analyze the complexity of the Evaluation and Chance-Evaluation problems in two sce-narios: when the number of candidates is bounded by a constant; and when it is not bounded.3. Constant number of candidatesIn many real-world scenarios, the number of alternatives is small and can be bounded by a constant. For example,if a group of agents want to decide on a full hour to meet in a given day, the number of alternatives is always 24. Inthis section we give a polynomial algorithm for the Evaluation problem under the assumption of a constant number ofalternatives. Clearly, this algorithm also answers the Chance-Evaluation problem in polynomial time. We then presentsome experimental results obtained with this algorithm, evaluating its performance in practice.N. Hazon et al. / Artificial Intelligence 189 (2012) 1–1853.1. The algorithmThe key to the efficiency of our algorithm is the distinction between a voting scenario and a voting result. Intuitively,in a voting scenario we know for each voter which preference order he votes for. But to identify a winning candidate, wedo not care actually exactly which voter votes for which candidate; we can aggregate the possible voting scenarios intoa compact intermediate form, which we refer to as a voting result. For example, suppose we use the Plurality rule. WithPlurality, a voting result may be a vector which stores the total number of votes for each candidate. Now suppose that thereare three voters and two candidates, c1 and c2, and all the voters do not have a probability of 1 to vote for one of thecandidates. Thus, there are three voting scenarios with the same voting result of two votes for c1 and one vote for c2.Voting results are compact representations for voting scenarios, and, in this sense, they have close connections withwork on the compilation complexity of voting rules [14,35]. Work on the compilation complexity of voting attempts to givebounds on the number of bits required to summarize votes for a particular voting rule, and in addition considers specificcompilation functions for summarizing votes. A voting result in our sense can therefore be thought of as a compilationfunction. We remark on these issues below in a little more detail.Expressed a little more formally, a voting result can be understood as follows:Definition 3. Given a voting rule, a voting result is a succinct way to represent one or more voting scenarios over i voters,0 (cid:3) i (cid:3) n, such that:1. For i = n, the winner can be determined from the voting result over the n voters in polynomial time.2. A voting result over i + 1 voters can be generated from combining the voting result for i voters and one additionalpreference order, in polynomial time.Of course, this is a rather abstract definition: after we present the algorithm, we describe some concrete representationsfor voting results for many common voting rules. Let us first describe the algorithm where all the voters’ weights are equal.A formal proof of the correctness of this algorithm may be found in Appendix A.The basic idea is to use dynamic programming to compute the possible voting results from preference profiles and tocalculate the probability of these voting results. The algorithm computes possible voting results from the preferences ofn − 1 voters and their probabilities, which are in turn computed using the voting results from the preferences of n − 2voters, and so on. Our algorithm builds a table T in which the rows are possible voting results and the columns representthe voters. We denote by T [ (cid:9)row, col] the cell in the table at the row which represents the voting result vector(cid:9)row, and atcolumn col. At any stage, the algorithm only stores two columns in memory.Algorithm 1 VotingResult (table T , preference orders for each voter).1: Init T [., .] ← 0,2: for i ← 0 to n − 1 do3:for all cells in column i doT [(cid:9)0, 0] ← 1.4:5:6:7:8:9:(cid:9)r ← the voting results of the cell’s rowfor j ← 1 to l do(cid:9)cur ← preference order j of voter i + 1(cid:9)next ← the voting result from adding (cid:9)cur to (cid:9)rT [ (cid:9)next, i + 1] ← T [ (cid:9)next, i + 1] + (probability of (cid:9)cur × T [(cid:9)r, i])end forend for10:11: end for∗When the algorithm terminates, each cell in the last column contains the probability of that cell’s row voting resultoccurring. We can identify the winner for each voting result according to the specific voting rule. So, we can answer theEvaluation problem from Definition 1 by simply summing for cthe probabilities of the voting results where it wins.Consider the following small example. Suppose we use the Plurality voting rule with 3 candidates (c1, c2, and c3) and twovoters (V 1 and V 2). The voters’ preferences are summarized in Table 4(a). Table 4(b) shows the table, T , that is built by thealgorithm for this data. Every row represents a voting result which is a vector such that index i counts the number of votesfor candidate ci . The last column shows the probabilities for every possible voting result with voters V 1 and V 2. Thus, the· 1probability that c1 is the winner, assuming a random tie-breaking method is used, is 14 ).2Note that, in this example, (0, 0, 2) is not a possible voting result.4 ) + 1· 3+ 12+ 12· ( 16· ( 13· 14· 14The time complexity of the algorithm is O (n × number of rows of T × l), and the space complexity is O (number of rowsof T ). The specific voting rule determines how to express the possible voting results which in turn determines the numberof rows. Clearly, we seek a representation that is as compact as possible. This issue, of how to summarize votes in a compactway, was also studied in [14] and [35], and we reuse some techniques presented in [14,35]. It also seems that their results,showing that the upper bound is tight, can be imported to our settings to show that our ways for the representation of26N. Hazon et al. / Artificial Intelligence 189 (2012) 1–18Table 4An example of how Algorithm 1 builds a table from a given set of preferences.(a) A set of voters’ preferences.(b) The corresponding table T , that is built by the algorithm.V 112 c113 c216 c3V 214 c134 c2Voting result (c1, c2, c3)0, 0, 01, 0, 00, 1, 00, 0, 12, 0, 01, 1, 01, 0, 10, 2, 00, 1, 101000000001012131600000200001213161316· 14· 14· 14· 34· 34+ 12· 34voting results are optimal (but we keep it to future work). Now, for many voting rules one of the following methods can beused to express the possible voting results:1. A vector in [0, n]m such that index i represents the number of voters who voted for candidate i.2. A vector in [0, n]m(m−1)/2 which represents the number of voters who preferred the first candidate in each possible pairof candidates.3. From [35]: A vector in [0, n]m24. From [14]: A vector in [0, n]m·2m−1which represents the number of voters who ranked each candidate in each position.. For each candidate i, let z−i be a possible subset of candidates not containing i. Thevoting result vector represents, for any candidate i and any possible z−i , the number of voters who preferred i over anycandidate in z−i .5. A vector in [0, n]m!which represents the number of voters who voted for each possible preference order permutation.We now show which method to use for some voting rules.• Plurality. The first method can be used so the number of rows is O ((n + 1)m) and the time complexity is O ((n + 1)m · l).However, the actual number of voting results will never be (n + 1)m, since the total number of points given by all thecandidates is n. Instead, the actual number of voting results with n voters is exactly the number of ways of splittingthe integer number n to exactly m non-negative integers, such that their sum is equal to n. Two sums which differ inthe order of their summands are considered to be different compositions. This is called a weak composition of n withexactly m parts; we denote this value by WC(n, m), WC(n, m) =n!(m−1)! . So the running time complexity is(cid:5)ni=0 WC(i, m)) and the space required is O (WC(n, m)).O (l(cid:3)n+m−1m−1= (n+m−1)!(cid:4)• k-approval. The first method can be used, with a running time complexity of O (li=0 WC(i · k, m)) and a space com-(cid:5)nplexity of O (WC(n · k, m)).• Borda. We can use a modified version of the first method – a vector in [0, (m − 1)n]m which represents the total scorefor each candidate. Thus, the time and space complexity are O (l, m)),respectively. We can also use the second method, since the Borda score of a candidate c equals to the number of times(cid:4) ∈ C .in which c is preferred to another candidate c, m)) and O (WC(n · m(m−1)i=0 WC(i · m(m−1), for each c(cid:5)n22(cid:4)• Bucklin. The third method can be used so the time and space complexity are O (li=0 WC(i ·m, m)) and O (WC(n ·m, m)),(cid:5)nrespectively.• Copeland. The second method can be used, so the number of rows is O ((n + 1)m(m−1)/2) and the time complexity isO ((n + 1)m(m−1)/2l). This method can be used for many other Condorcet-consistent rules, e.g., Maximin, Ranked pairs,Voting trees, etc. (For an extensive discussion of voting rules, we refer the reader to [1].)• STV (see a definition in [1]). Recall that STV performs in successive rounds: at each round, the candidate with thelowest plurality score gets eliminated, and its votes are transferred to the next preferred candidate in each vote, untilthere is a majority winner. We can thus use the fourth method, since the candidate that gets eliminated in each roundis exactly the one which has the lowest number of voters that prefer it over all the remaining candidates that have notbeen eliminated yet. Therefore, the number of rows is O ((n + 1)m·2m−1l). Ifm (cid:3) 4, the last method shall be used to calculate the number of scores for each candidate from the preference orders.) and the time complexity is O ((n + 1)m·2m−1When we move to the weighted voters case, Conitzer and Sandholm [16] expressed the Evaluation problem as thefollowing decision problem: Given a number r, 0 (cid:3) r (cid:3) 1, is the probability of cwinning greater than r? They showed thatthis problem is NP-hard for Borda, Copeland, Minimax and STV, even for extremely restricted probability distributions. Weshow that their results hold only for weights that are not bounded by poly(n).∗N. Hazon et al. / Artificial Intelligence 189 (2012) 1–187Claim 4. For a constant number of candidates, the Evaluation problem is in P even for weighted voters, when the weights are inpoly(n).Proof. Our dynamic programming approach (Algorithm 1) can be easily extended to work with weighted voters. Actually,the only thing that has to be changed is the range of possible voting results which determines the number of rows in thetable. The number of rows will now become at most O (poly(n)m), O (poly(n)m(m−1)/2), O (poly(n)m2) orO (poly(n)m!), depending on the specific voting rule (as described before). In all the cases it is still in P. (cid:2)), O (poly(n)m·2m−1This result may be understood with reference to the proofs of [16], which uses a reduction from the Partition problem.Partition is known to have a pseudo-polynomial time dynamic programming solution [24].3.2. ExperimentsIn the preceding section, we gave analytical results for the case where the number of candidates is a constant. Weshowed that the complexity of our algorithm grows exponentially with the number of candidates. As with many otherproblems that have worst-case exponential running time, it is interesting to ask whether we do indeed see worst caseperformance in practice. Our hypothesis was that in our problem, the actual number of voting results that the algorithmstores is much smaller than the asymptotic bound in most cases (and hence the required memory and time are smaller too).In particular, we investigated the effect of the probabilistic structure of the imperfect information on the number of storedvoting results. Additionally, we tested the effect of the parameter l on the actual number of voting results. In this sectionwe present experimental results obtained with an implementation of the algorithm for the Plurality rule with unweightedvoters, which validate our hypothesis. We also found it interesting to check how many voters the polynomial-time algorithmcan reasonably handle in practice, for a given number of candidates.Our implementation (written in C++) ran on a 64-bit Linux PC, with 8 GB of RAM. The large amount of main memory wasneeded for the algorithm to store the table of the voting results. This table was implemented using Judy array [6], a complexbut very fast associative array data structure for storing and retrieving values. We chose to use this data structure since ittypically requires much less memory than a conventional hash table. We measured the algorithm’s performance by countingthe total number of cells that were produced during run-time (in contrast to measuring time, which would depend on theactual testing hardware). In most cases we ran 15 iterations and took the average. In cases where the running time provedto be very high, we took the average of only 5 iterations.As an input, the algorithm takes an imperfect information matrix. Unlike in other experimental work in social choicewhich generates random preferences or random voters’ weights (see [33] for example), we need to randomly generate proba-bilities over possible preferences. As noted before, in this work we assume that some knowledge on the preferences can bederived, and only l preference orders have a non-zero probability for each voter. Therefore, the impartial culture assump-tion [12], which is a model of an electorate in which all preference orders are equally likely, cannot be used. We consideredtwo methods for selecting l candidates for each voter (Plurality needs only the top choice candidate) and generating theprobabilities, using uniform and normal distributions. In the first method, l candidates were randomly chosen for each voterand the probability that she will vote for each one of them was set to 1/l. The second method defined an arbitrary fixedorder over the candidates. It then randomly chose one candidate to be the mean of the normal distribution, for each voter.The other l − 1 candidates were chosen by their proximity to the mean candidate. The probability that each voter will votefor each one of the candidates was set according to the normal distribution, with the selected mean and a variance of 1.Fig. 1 demonstrates the difference between these two methods.In the first set of experiments, we tested the effect of the random methods that we used to generate the voters’ pref-erences. In these experiments we fixed l to be 3, and we evaluated the effect of the two methods on the running time (interms of number of generated cells) for 5 and 6 candidates and 20–100 voters. The results are shown in Fig. 2.Clearly, using the uniform distribution to generate the preferences results in more ways of splitting the total number ofvotes among the candidates. Thus, increasing the number of voting results yields a higher running time. The second methodsimulates a more realistic scenario, the “single-peaked preference” principle [11]. In this case, there is some predeterminedlinear ordering of the candidate set. Every voter has some most preferred point on that line, and his dislike for a candidategrows larger as the candidate goes further away from that point. Similarly, in our case every voter has some special placethat we believe has the highest probability to be selected, and the probability that the voter will vote for a candidatedecreases as the candidate goes further away from that spot. In this case the votes are less scattered among the candidates,and thus the number of voting results is lower, yielding a lower running time.We also use these settings to demonstrate how the ratio of the actual number of voting results to the theoreticalnumber behaves. Since we use Plurality, the theoretical bound was computed using the WC function (as described above).The results are summarized in Fig. 3. As there are more voting scenarios which lead to the same voting result, the gapbetween the theoretical bound and the actual number of voting results increases. Thus, this ratio is lower when thereare more candidates or when a normal distribution rather than a uniform distribution is used to generate the imperfectinformation. On the other hand, the number of voters does not have a significant effect on this ratio.In the second set of experiments, we investigated the effect of l on the actual number of voting results. Although thealgorithm’s running time is (asymptotically) linear in l, it was interesting to check if l has the same effect on the actual8N. Hazon et al. / Artificial Intelligence 189 (2012) 1–18Fig. 1. An example of how to generate random probabilities where m = 6, l = 3.Fig. 2. Results of the first set of experiments.Fig. 3. Ratio of actual to theoretical number of voting results for increasing numbers of voters.N. Hazon et al. / Artificial Intelligence 189 (2012) 1–189Fig. 4. Ratio of actual to theoretical number of voting results for increasing number of non-zero probability preference orders for each voter (l).Table 5Extreme results. Fractions are rounded to 3 decimal places.# of candidates# of votersTheoretical # of voting resultsActual # of voting results45671100400140100223,045,3511,093,567,501498,187,4041,705,904,74647,331,609.293,506,124.218,146,578.222,381,578.8Ratio0.2120.0860.0360.013Time (s)Total # of cells111,183.4338,200.44756379213,122,678,458.07,640,484,607.0442,092,341.2346,504,543.2Fig. 5. Results of the last set of experiments.number of voting results. In these experiments, we fixed the number of candidates to 5, and used the normal distributionto generate preferences. We measured the ratio of the actual number of voting results to the theoretical bound (computedusing the WC function) for 50 and 100 voters and l between 2 and 5. The results are shown in Fig. 4. Indeed, as l increases,the ratio of actual to theoretical number of voting results increases in the same manner. As in the previous experiment, thisratio is not affected by the number of voters. Note that since m = 5, if l = 5 too, every possible voting result may happen,thus the ratio is 1.It follows from our results that there is clearly a gap between the theoretically predicted running time and the actual one.Therefore, in the last set of experiments we tested how many voters the polynomial-time algorithm can handle in practice,for a given number of candidates. We set l to its minimum value, 2, and we used the normal distribution to generate thepreferences. We then tested for 4 to 7 candidates how many voters the algorithm can handle. We would perhaps have beenable to process more voters if we used a hard disk as a virtual memory, but the I/O overheads would result in a muchhigher running time, and we wanted to test our algorithm with reasonable limits – therefore, the algorithm used only mainmemory, and the “extreme” results that are shown in Table 5 were achieved just before the algorithm ran out of space. Thecomplete picture is shown in Fig. 5. Note that the y-axis is shown in logarithmic scale.The results show that the actual running time (in terms of generated cells) heavily depends on the number of candidates,as expected. We also see that the algorithm can handle a practical number of voters, even with 6 or 7 candidates. For10N. Hazon et al. / Artificial Intelligence 189 (2012) 1–18example, the Israeli parliament (the Knesset) has 120 voters, and the United States Senate has 100 voters. Table 5 showsagain the difference between the theoretical upper bound on the number of voting results (computed using WC function),to the actual number.4. The number of candidates as a parameterIf we cannot bound the number of candidates, then Evaluation becomes much harder. In this section, we show that theEvaluation problem for k-approval, Borda, Copeland, Bucklin and even Plurality is #P-hard in this case. We also analyze theseemingly weaker question of Chance-Evaluation. Surprisingly, we show that even this problem is hard when voters do notall have equal weights under Plurality. We show that with equal weights, Chance-Evaluation is still hard under k-approval,Borda, Copeland, Bucklin and Maximin. However, for the Plurality rule where all voters have equal weights, we are able togive a polynomial time algorithm.4.1. The Evaluation problemSometimes, the number of candidates cannot be assumed to be a constant, but is necessarily a parameter of the problem.For example, if a group of agents wants to choose one of them as a leader, m = n and thus it is not a constant. There aresome special cases where the number of voters is a constant and so a naive algorithm, which simply evaluates all possibleoptions and runs in time polynomial of O (mn) will suffice. Of course, the assumption of a constant number of voters israther restrictive, and unfortunately, as we will see, if both the number of voters, n, and the number of candidates, m, aregiven as parameters, the problem is #P-hard even for the Plurality, k-approval, Borda, Copeland and Bucklin voting rules.All our #P-hardness reductions will be from a well known #P-complete problem, Permanent, which is to calculate thepermanent of a {0, 1}-matrix (or, equivalently, to count the number of perfect matchings for a bipartite graph).Definition 5. Denote by Sn the set of all permutations of the numbers 1, 2, . . . , n. Thepermanent of an n ×n matrix A = (ai, j)is defined asperm( A) =(cid:2)n(cid:6)σ ∈Sni=1ai,σ (i)Definition 6. For a bipartite graph G = ( X ∪ Y , E) such that ∀(x, y) ∈ E, x ∈ X and y ∈ Y , and | X| = |Y | = r, a perfect matchingis a set of edges such that no two edges share a common vertex and every vertex is incident to exactly one edge.The permanent of any bipartite graph’s adjacency matrix in fact counts the number of perfect matchings for the graph.We are now ready to show the proof for the Plurality voting rule.Theorem 7. If n and m are not constant, the Evaluation problem is #P-hard for the Plurality voting rule.Proof. Given a bipartite graph G = ( X ∪ Y , E), with X = {x1, . . . , xr} and Y = { y1, . . . , yr}, for which we wish to count thenumber of perfect matchings, we construct an instance of the Evaluation problem such that the probability of the chosencandidate to win is a function of (and only of) the number of perfect matchings in G. The voters are all the vertices of Xplus two additional voters x0 and w, all with equal weights. The candidates are all the vertices of Y plus two additionalcandidates y0 and a. We first consider the case where the tie-breaking rule is lexicographic, and a has the top priority.For every x ∈ X , if (x, y) ∈ E, set the probability that voter x votes for candidate y to be 1r . With the remaining probability(1 − deg (x), where deg (x) is the degree of x) voter x votes for y0. Finally, w votes for candidate a with probability 1, and x0votes for candidate y0 with probability 1.rConsider a particular set of votes cast by the voters. Voters x0 and w have no choice, so consider the choices made byvoters in X . Each such set of choices naturally corresponds to a collection of r edges, M, between X and Y :(cid:7)M =(x, y) ∈ X × Y : x voted for y(cid:8)(note that if x voted for y0 then this pair is not included in M). We show that a wins the election iff M is a perfectmatching.Suppose that M is a perfect matching, then all candidates in Y get exactly one vote (from the voters in X ) as do a and y0(from w and x0, respectively). Thus, all candidates obtain the same score, and a wins by the tie-breaking rule. Conversely,suppose that M is not a perfect matching. Then, either there is a candidate y ∈ Y that gets more than one vote, or else thereis a voter x ∈ X that voted for y0 (in addition to the vote y0 surely received from x0). In either case, there is a candidatethat got more than one vote, while a received only one vote (from w). Hence, a does not win the election.The probability that the voters of X elect any specific perfect matching is rPr[a wins the election] = r−r · PM(G)−r . ThusN. Hazon et al. / Artificial Intelligence 189 (2012) 1–1811where PM(G) denotes the number of perfect matchings in G. Hence, the answer to the Evaluation problem also gives usone for the number of perfect matchings.The proof for random tie-breaking is essentially identical, only that in the case of an exact matching a does not nec-· PM(G). The rest of ther+2 . Hence, in this case Pr[a wins the election] = r−rr+2essarily win, but only wins with probability 1proof remains the same. (cid:2)As for k-approval, we only need to slightly modify the reduction used in the proof for Plurality. Recall that in k-approvalonly the k first candidates get scores, so we don’t care what their order is, or the order of the other m − k candidates: weonly care whether a candidate appears in the top k positions or not.Theorem 8. If n and m are not constant, the Evaluation problem is #P-hard for the k-approval voting rule, for every fixed k.Proof. Given a bipartite graph G = ( X ∪ Y , E), with X = {x1, . . . , xr} and Y = { y1, . . . , yr}, for which we wish to countthe number of perfect matchings, we construct almost the same instance of the Evaluation problem as in the proof ofTheorem 7. The set of voters is the same, but we add a set of dummy candidates D = {di}, where 1 (cid:3) i (cid:3) k − 1, 0 (cid:3)y jj (cid:3) r. For every x ∈ X , if (x, y) ∈ E, set the probability that voter x gives one point to candidates y, d1the remaining probability (1 − deg (x)w gives one point to candidates a, d1with probability 1.y, . . . , dk−1y0a with probability 1, and x0 gives one point to candidates y0, d1y0, where deg (x) is the degree of x) voter x gives one point to y0, d1y0a , . . . , dk−1r . With. Finally,, . . . , dk−1y0y, . . . , dk−1} ∪ {diato be 1rNow, each candidate diy jand dia gets the same number of points as y j and a, respectively. Therefore, the rest of theproof is essentially identical to that for the Plurality rule. (cid:2)We now turn to the Borda and Copeland protocols. We start with a simple lemma, the proof of which is trivial.Lemma 9. Let V be a set of voters, each with an individual preference order over a set of candidates. Suppose that all orders aredifferent, and that for each preference order of any voter v, there exists another voter vwith the exact opposite preference order. Then:(cid:4)• In the Borda protocol all candidates get the exact same score (which is also the average score).• In the Copeland protocol, all pairwise contests are tied, for a total 0 score for all candidates.Theorem 10. If n and m are not constant, the Evaluation problem is #P-hard for the Borda voting rule.++and W , with r +1 voters in each. The set XProof. Let G = ( X ∪ Y , E) be a bipartite graph, with X = {x1, . . . , xr} and Y = { y1, . . . , yr}, for which we wish to countthe number of perfect matchings. We construct an instance of the Evaluation problem as follows. There are 2(r + 1) voterscomposed of two subsets: Xconsists of the set X plus one additional voter x0.The set W consists of r + 1 voters w 0, . . . , wr . All voters have equal weights. There are r + 2 candidates: C = {c0, . . . , cr} andone “special” candidate a. We build theEvaluation instance in such a way that every perfect matching in G correspondsto a voting scenario in which for every voter xi ∈ X, there is a voter w j ∈ W with the exact reverse preference order. Inthis case, by Lemma 9 all candidates have the same score, and a wins by lexicographic tie-breaking rule. Furthermore, theEvaluation instance is constructed so that a only wins in voting scenarios that correspond to perfect matchings in G. Thedetails follow.For ease of notation we denote i ⊕ j = (i + j)mod(r + 1). Define the following set of orderings over the candidate set.For each i = 0, . . . , r let si = (ci, ci⊕1, . . . , ci⊕r, a), and denote by (si)R the reverse order to si . For each (x j, yi) ∈ E (an edgein G), there is a probability of 1/r that voter x j votes for order si . With the remaining probability (1 − deg (x j )) voter x j votesfor order s0. Voter x0 votes for s0 with probability 1. For voters in W , voter w j votes for order (s j)R with probability 1.+Note that, in particular, a is last in all votes of Xand first in all votes of W . See Fig. 6 for an example of how to build aninstance from a given bipartite graph where r = 3.+rConsider a set of orders chosen by the voters. Only the voters of X have any choice, so consider their votes. Each suchset of choices naturally corresponds to a collection of r edges, M, between X and Y :(cid:8)(cid:7)M =(xi, y j) ∈ X × Y : xi voted s jWe show that for lexicographic tie-breaking, a wins the election iff M is a perfect matching in G.Suppose that M is a perfect matching in G. Then, each si gets exactly one vote from the voters in X. However, each(si)R also receives exactly one vote, from the voters of W . Hence, for each preference order that received a vote, the exactopposite order was also voted for. In this case, by Lemma 9, a wins by lexicographic tie-breaking rule.Conversely, suppose that M is not a perfect matching. Denote by α the average total score of the candidates, α = (r + 1)2.Since α is an average, it is independent of the actual choices made by the voters. Consider M. Since M is not a perfectmatching, there exists at least one order si that does note receive any vote from X. W.l.o.g. assume that this is sr . Note++12N. Hazon et al. / Artificial Intelligence 189 (2012) 1–18Fig. 6. Reduction from Permanent to Evaluation problem used in the proof of Theorems 10 and 11.+that in all orders si with i (cid:14)= r candidate cr appears after candidate cr−1. Hence, the total score that cr−1 gets from voters ofmust be higher than the total score they give cr . The voters of W , on the other hand, in total give all candidates of CXthe exact same score (since the construction of the si ’s is symmetric). Hence, cr−1 gets a higher total score than cr , and, inparticular, it is not the case that all candidates get an identical total score. Thus, there must be a candidate ci0 that gets atotal score β strictly greater than the average α. On the other hand, the score of a is always the same (being always last inand first in votes of W ). Hence, its score is always identical to the one it gets in a perfect matching, namely α.votes of XHence, a does not win the elections.+The probability that the voters of X elect any specific perfect matching is r−r . Thus, Pr[a wins the election] = r−r · PM(G).Hence, the answer to the Evaluation problem also gives us one for the number of perfect matchings.The proof for random tie-breaking (instead of lexicographic) is essentially identical, as in the proof for Plurality. (cid:2)Theorem 11. If n and m are not constant, the Evaluation problem is #P-hard for the Copeland voting rule.Proof. The proof is very similar to that of the Borda protocol, and uses the exact same construction. Following that proof,we show that also for the Copeland protocol, a can win iff M (as defined in the Borda proof) is a perfect matching. Indeed,if M is a perfect matching, then as shown above, for each vote for a given preference order there is a vote for the exactreverse order. Thus, the conditions of Lemma 9 hold, and all candidates get an identical score of zero. Hence, a can win(either by lexicographic or by random choice, depending on the protocol).+Conversely, suppose that M is not a perfect matching. Then, there exists at least one order si that is not voted for by. W.l.o.g. assume that this is sr . In all orders si with i (cid:14)= r, candidate cr−1 appears before candidate cr . Inany voter of Xall orders (si)R with i (cid:14)= r − 1, candidate cr−1 appears immediately after cr , and in (sr−1)R it appears before candidate cr .Hence, for any other candidate c j , if cr wins the pairwise contest with c j , so does cr−1. In addition, cr−1 beats cr . Hence, intotal, cr−1 must win strictly more pairwise contests than cr . Hence, it cannot be the case that all candidates score exactly 0.Thus, since the average total score is necessarily 0, there must be at least one candidate that scores more than 0. On the), for a total of 0. Thus,other hand, a ties all pairwise contests (it is first in all votes by W and last in all those by Xa cannot win the elections. The rest of the proof is identical to that for the Borda rule. (cid:2)+As for Bucklin, we use a slightly different construction. This proof does not assume the use of any specific tie-breakingrule.Theorem 12. If n and m are not constant, the Evaluation problem is #P-hard for the Bucklin voting rule.Proof. Let G = ( X ∪ Y , E) be a bipartite graph, with X = {x1, . . . , xr} and Y = { y1, . . . , yr}, for which we wish to count thenumber of perfect matchings. We construct an instance of the Evaluation problem as follows. There are 2(r + 1) voters,thus the Bucklin score of the Bucklin winner will be at least r + 2. The set of voters is composed of two subsets: Xand W ,with r + 1 voters in each. The set Xconsists of the set X plus one additional voter x0. The set W consists of r + 1 votersw 0, . . . , wr . All voters have equal weights. There are r + 1 regular candidates: C = {c0, . . . , cr} and one “special” candidate a.j} ∪ {dAdditionally, there are (r + 1)2 dummy candidates: D = {diay j}, where 1 (cid:3) i (cid:3) r, 0 (cid:3) j (cid:3) r.++N. Hazon et al. / Artificial Intelligence 189 (2012) 1–1813We build the Evaluation instance in such a way that every perfect matching in G corresponds to a voting scenario inwhich the Bucklin wining round is r + 2 and candidate a wins. Furthermore, the Evaluation instance is constructed so thatin other voting scenarios the Bucklin winning round is strictly less than r + 2 and one of the candidates from C wins. Thedetails follow.For ease of notation we denote i ⊕ j = (i + j)mod(r + 1). In our construction, the Bucklin wining round is always lessthan or equals r + 2, thus we show only the first r + 2 candidates in each preference order (other candidates may be placedarbitrarily). For each i = 0, . . . , r, let si = (ci, d1a). For each (x j, yi) ∈ E (an, . . . , dryiyiedge in G), there is a probability of 1/r that voter x j votes for order si . With the remaining probability (1 − deg (x j )) voter x jvotes for order s0. Voter x0 votes for s0 with probability 1. For voters in W , voter w j votes for order t j with probability 1.Note that any order si gives one point to candidate c ∈ C in the first round, and every order ti gives one point to c ∈ C oneach round j, 2 (cid:3) j (cid:3) r + 1., a), and ti = (a, ci, ci⊕1, . . . , ci⊕(r−1), dirConsider a set of orders chosen by the voters. Only the voters of X have any choice, so consider their votes. Each suchset of choices naturally corresponds to a collection of r edges, M, between X and Y :(cid:8)(cid:7)M =(xi, y j) ∈ X × Y : xi voted s jWe show that a wins the election iff M is a perfect matching in G.+Suppose that M is a perfect matching in G. Then, each si gets exactly one vote from the voters in X. For every j,1 (cid:3) j (cid:3) r + 1, the score of every dummy candidate d ∈ D in round j is less than or equals 1. The score of every candidatec ∈ C in round j is j, and the score of a in round j is r + 1. Since no candidate has more than r + 2 points, every j,1 (cid:3) j (cid:3) r + 1, is not the Bucklin winning round. On the other hand, in round r + 2 the score of a is 2(r + 1) while no othercandidate has more than r + 1 points. Therefore the Bucklin winning round is r + 2 and a is the (unique) winner.Conversely, suppose that M is not a perfect matching. Then, there exists at least one order si that is voted for more than. Therefore, there is at least one candidate c ∈ C with a score of at least r + 2 in round r + 1.one time by voters of XThen, the Bucklin winning round is less than or equals r + 1. On the other hand, a’s score in every round j, 1 (cid:3) j (cid:3) r + 1,is exactly r + 1. Thus, a cannot win the elections.+The probability that the voters of X elect any specific perfect matching is rHence, the answer to the Evaluation problem also gives us one for the number of perfect matchings. (cid:2)−r . Thus, Pr[a wins the election] = r−r · PM(G).Note that all our proofs use equal weights for the voters, so the results hold for the weighted voters case with un-bounded or bounded weights too.4.2. Chance-Evaluation problemOur original definition of the Evaluation is computationally hard for some common voting rules. Surprisingly, the weakerquestion, Chance-Evaluation, is hard even for the simplest voting rule – Plurality – when voters do not all have equalweights.Theorem 13. If n and m are not constant, the Chance-Evaluation problem is NP-complete for the Plurality voting rule when thevoters do not all have equal weights.∗∗wins, we can check that indeed cis the winnerProof. The problem is clearly in NP – given one voting scenario where cin polynomial time. The NP-hardness reduction is from the NP-complete Bin-Packing problem: given a finite set U of items,an integer size s(u) for each u ∈ U , a positive integer bin capacity B and a positive integer k, is there a partition of U intodisjoint sets U 1, U 2, . . . , Uk such that the sum of the sizes of the items in each U i is B or less? The instance for the Chance-Evaluation problem is as follows. Every item is represented by a voter, where the item size is the voter’s weight. We addanother voter, v z with the weight B + 1. Every bin is represented by a candidate, and we add another candidate z. v z hasa probability of 1 to vote for z, and all the other voters have an equal probability to vote for each one of the remainingcandidates. We look for the possibility of z to be a winner. Note that every voting scenario corresponds to a packing andvice versa; a voter with weight x which votes for candidate y is like placing an item with size x in bin y. One item cannotbe in more than one bin and every voter cannot vote for more than one candidate. Now suppose the tie-breaking ruleis lexicographic and z is the minimal candidate with respect to the ordering. z is the winner if and only if all the othercandidates get B or less votes. So there is a packing if and only if there is a voting scenario where z is the winner. Theproof for random tie-breaking is similar, only that the weight of v z is set to B. (cid:2)This problem is NP-complete in the strong sense [24], meaning that even if the weights are bounded by poly(n) theproblem remains hard (unlike the case with the constant number of candidates, as shown before).Fortunately, for Plurality, if all voters have equal weights the problem can be solved in polynomial time.Theorem 14. Even if n and m are not constant, the Chance-Evaluation problem is in P for the Plurality voting rule where all votershave equal weights.14N. Hazon et al. / Artificial Intelligence 189 (2012) 1–18Fig. 7. An example of how to build a flow network from a given set of preferences.(cid:4)∗∗(cid:4), E(cid:4) ∪ V 2(cid:4) ∪ V 2(cid:4) = (V 1(cid:4)(cid:4) ∪ {s, t}. V 1∗Proof. We give a polynomial time algorithm to answer the Chance-Evaluation problem, assuming random tie-breaking isused. The idea is very similar to the technique in [34, p. 176], and we also refer to [22,21] for a different use of networkflows techniques in the context of voting problems. Let cbe the candidate for whom we are trying to determine whether itwith non-zero probability, and denote this numberhas any chance of winning. Count the number of voters that vote for c(cid:4)) and two additional nodes sby b. Then build a flow network G = (V, E) which contains a bipartite graph Gand t, V = V 1has a node(cid:4)(cid:4)1, if voter i has a non-zero probability to vote for candidate j then (i, j) ∈ E.for every candidate but c, andIn E, s has an edge with capacity 1 to all the nodes of V 1(cid:4), (i, j) ∈ E too, with capacity 1. Now find a maximum flow and check that every edge from s to a node of V 1if (i, j) ∈ Egets b votes and all the otherhas a residual capacity of zero. If such a flow exists, it represents a voting scenario where ccan get at most bcandidates get b or less votes so the algorithm returns “yes”. If not, then in every voting scenario, cvotes and there is at least one candidate who gets more than b votes so the algorithm returns “no”. The construction of theflow network and all the stages of the algorithm can be done in polynomial time, so the Chance-Evaluation problem forPlurality is in P where all the voters have equal weights.(cid:4), t has an edge with capacity b from all the nodes of V 2has a node for every voter which has a zero probability to vote for c. For every i ∈ V∗) be the set of all candidates that are more favored thanThe algorithm for lexicographic tie-breaking is similar. Let Top(c∗),∗according to the lexicographic tie-breaking. For every edge (v, t) ∈ E, such that v corresponds to a candidate in Top(ccset the capacity to b − 1. The rest of the construction remains the same. If the required flow exists, it represents a votingget b − 1 or less votes, and all the otherscenario where c∗can get at most bcandidates get b or less votes so the algorithm returns “yes”. If not, then in every voting scenario, cwho gets more than b − 1 votes, or there is othervotes and there is at least one candidate which is more favored than ccandidate who gets more than b votes. Thus, the algorithm returns “no”. (cid:2)gets b votes, all the candidates that are more favored than c(cid:4), and V 2∗∗∗∗∗∗(cid:4)Fig. 7 shows how the algorithm builds a flow network from the set of preferences in Fig. 7(a). In this example we seeka voting scenario where candidate D has a chance to win, and we use random tie-breaking. We remove voters V 1 and V 5which have a non-zero probability of voting for D, and build a flow network as described in Fig. 7(b). In this example,a possible maximal flow is to assign 1 to all the outgoing edges of s, to the edges (V 2, A), (V 3, B), (V 4, B), (V 6, C), (V 7, C)and ( A, t), and to assign 2 to the edges from B and C to t. Therefore, D has a chance to win; if V 1 and V 5 vote for D,V 2 votes for A, V 3 and V 4 vote for B, and V 6 and V 7 vote for C .For other voting rules, we get NP-hardness results as a corollaries of [36]. This paper considers the possible-winnerproblem, where it was assumed that for each voter we have a correct but incomplete model of their preference order.The input to our problem is different; we have for each voter a collection of complete preference orders, with associatedprobabilities. Nevertheless, since the Chance-Evaluation problem ignores the exact values of the probabilities, if the partialorders considered in possible-winner problem have a polynomial number of extensions, then possible-winner becomes aN. Hazon et al. / Artificial Intelligence 189 (2012) 1–1815Table 6Number of iterations as a function of (cid:5) and α.α0.050.050.050.010.010.010.0010.0010.0010.00010.00010.0001(cid:5)0.050.010.0010.050.010.0010.050.010.0010.050.010.001t2716764676,38654213,5301,352,97495523,8742,387,384138434,5783,457,771subproblem of Chance-Evaluation. It turns out that for many voting rules the possible-winner problem is NP-complete evenif the number of undetermined pairs is a constant, which implies that the number of extensions is bounded. We obtain:Proposition 15. If n and m are not constant, the Chance-Evaluation problem is NP-complete for k-approval, Borda, Copeland, Buck-lin, and Maximin voting rules, even if the voters are unweighted.34.3. Monte Carlo approximationComputing the exact answer for Evaluation and Chance-Evaluation problems seems to be hard in many cases. However,we can utilize the underlying probabilities to achieve an approximate solution even for the Evaluation problem. The ideais to use a statistical approach, in which we sample according to the given probabilities to estimate the true winningprobability.The algorithm is as follows. For each voter, we sample one preference order according to the given distribution, thusobtaining a voting scenario. Since the voters’ choices are independent, this process is equivalent to sampling one votingscenario according to the voting scenarios distribution (which we do not know). We then calculate the winner from thisvoting scenario using the given voting rule, and repeat the whole process t times. Given a specific candidate, c, we areinterested in his winning probability (denote it by p). This probability is approximately the number of sampled votingscenarios where cwins divided by t (denote this ratio by ˆp).∗∗From the perspective of c, each iteration has two possible outcomes: where he wins, or when another candidate wins.∗The winning probability of c, p, is the same in each iteration, and the iterations are statistically independent. Therefore, thedistribution of p is a binomial distribution, and the maximum likelihood estimator for p is ˆp. This estimator is also knownto be unbiased for the binomial distribution. We can build a binomial confidence interval which relies on approximating thebinomial distribution with a normal distribution,4 by the following formula:∗(cid:10)(cid:9)Pˆp −ˆp(1 − ˆp)tZ1− α2(cid:3) p (cid:3) ˆp +(cid:10)(cid:11)ˆp(1 − ˆp)tZ1− α2= 1 − α(1)where Z1− αthe distance from the true winning probability, we require that given an (cid:5),2 percentile of a standard normal distribution, and α is our chosen probability of error. For bounding2is the 1 − α|p − ˆp| (cid:3) (cid:5)Combining (1) and (2) above we get that the number of required iterations is:(cid:9) (cid:12)t (cid:2)(cid:11)2ˆp(1 − ˆp)Z1− α(cid:5)2(2)(3)i.e., the winning probability ˆp that we have found after such t iterations is, with probability 1 − α, at most (cid:5) away from thetrue probability p. Table 6 shows the required number of iterations (t) as a function of (cid:5) and α, assuming that ˆp(1 − ˆp) ismaximal, i.e. ˆp = 0.5.3 This result holds for Ranked Pairs and Voting trees too, but we did not discuss these rules in our paper.4 We note that one can get more explicit bounds by using Chernoff bounds (see, e.g., [2]). However, more samples are required.16N. Hazon et al. / Artificial Intelligence 189 (2012) 1–185. Related workAs we noted in the introduction, the computational aspects of voting have recently received a great deal of attention,leading to the emergence of a new research area, known as computational social choice [20].Within the computational social choice community, much research has considered the complexity of manipulating votingprocedures – of deciding how an agent can optimally cast a vote in the furtherance of its own preferences. The complexity ofmanipulation has been studied both under the assumption that the number of candidates is unbounded [4,3,18], and underthe assumption of a constant number of candidates [16,19]. However, most computational studies of voting assume perfectinformation about voter preferences or votes, which, as discussed in the introduction, may be an unrealistic assumption inreal world settings.The limiting assumption of perfect information has driven researchers to look for a different, more realistic model.In [27], and later in [30], it was assumed that for each voter we have a correct but incomplete model of each voter’spreference relation. For this incomplete information setting, [27,30] considered questions such as whether there was somecompletion of the incompletely known preferences that would make a particular desired candidate a winner. This question,known as the possible-winner problem, is particularly important as it also has a strong connection to preference elicitation[17] and manipulation [27]. This imperfect information model was further investigated under sequential majority voting[28,29], under all scoring rules [8,9,7], and under other common voting rules [36]. The complexity of the possible-winnerproblem has also been studied for cases where certain parameters are fixed (e.g., the number of candidates, number ofvoters, and total number of undetermined candidate pairs [10]). However, this model cannot utilize any prior knowledge ofthe voters’ preferences. It is “pessimistic” in nature, as it assumes that the missing data is completely unknown, and thus itignores any probabilistic estimation on the voters’ preferences that could be learned from their voting history. Of course, ifvery little is known about the voters’ preferences, this model may be more appropriate than the probabilistic model we usein this paper.5 Moreover, our Chance-Evaluation problem ignores the exact values of the probabilities, so it is very close tothe settings of the possible-winner problem. The connections between these problems were illustrated in Section 4.2, wherewe get many hardness results as corollaries of [36]. A recent paper [2] studies the computational complexity of the countingversion of the possible-winner problem. They prove #P-hardness results for Plurality and Veto, and provide a randomizedapproximation algorithm for all voting rules that are polynomial-time computable. Their algorithm may be used to findthe probability with which a designated candidate wins, assuming that the completion of the incompletely preferences arechosen uniformly at random.The previous work that is most closely related to our concerns is [16], which uses a probability distribution over thevotes to capture imperfect information. The results of [16] are derived with a restricted model of probability distributions.A key result of [16] is that, if manipulation for some voting rule is hard when complete information is provided, thenit is also hard to even evaluate a candidate’s winning probability with this protocol when there is uncertainty about thevotes. However, as we demonstrated in Section 3, the hardness of the uncertain case holds only for weights that are notbounded by poly(n), where n is the number of voters. Conitzer and Sandholm [16] consider the unweighted voters case, butonly with a probability distribution that allows for perfect correlations among the voters (which actually simulates weightsfor the voters). This is also the case in [32], which proves some results regarding the connection between the incompletepreferences settings to the settings where we have a probability distribution over the votes, but uses perfectly correlatedvotes. Probabilities are also used to model imperfect information in [26] and [31], but these papers assume that what isknown about an electorate is only the probability that any given candidate will beat another. These papers use this datato investigate the extent to which it is possible to rig the agenda of an election or competition so as to favor a particularcandidate.6. Conclusions and future workIn many situations, it is desirable to use voting rules to aggregate the preferences of different agents in order to make asocial choice. If the preference orders of all agents are perfectly known, then for any practical voting rule it is computation-ally easy to calculate which candidate will win. However, this perfect information assumption is sometimes not realistic, andwhat we know instead is only the probability that each voter has a certain preference order. In this work, we investigatedthe problem of computing the probability that a candidate will win an election, given such an imperfect information model.We showed an important distinction between the case where the number of candidates is a constant and the case where itis not bounded. In the first case, our algorithm, which runs in polynomial time, can compute the probability of a candidatewinning in many voting rules, no matter whether or not voter weights are equal. However, the second case is #P-hard tocompute, as we proved for Plurality, k-approval, Borda, Copeland and Bucklin voting rules. Even to check whether a can-didate has any chance of winning with the Plurality voting rule is NP-complete when voter weights are not all equal. Forthe case when they are equal, it remains NP-complete for k-approval, Borda, Copeland, Bucklin and Maximin rules, but wegave a polynomial time algorithm for computing if a candidate has any chance to win using the Plurality protocol. We also5 In addition, this incomplete information model uses a more succinct representation than our probabilistic model. However, if the number of candidatesis a constant, then any succinct representation is equal to our representation in terms of time and space complexity.N. Hazon et al. / Artificial Intelligence 189 (2012) 1–1817gave a simple Monte Carlo algorithm that is able to approximately compute the probability of a candidate winning in anysetting, with an error as small as desired.For future work, we would like to extend our current analysis to more voting rules, including multi-winner protocols.Even with the current protocols that we have considered there are still some open question. For example, the complexityof Evaluation with unweighted voters under the Maximin voting rule, and the Chance-Evaluation with unweighted votersunder the STV rule. Another extension to consider is to define and analyze a general imperfect knowledge model, whichcombines the model of [27] – incomplete preferences – along with our model of probabilistic estimate of the voters’ prefer-ences. We would also like to improve our results for the current voting rules: where we prove that the problem is #P-hardor NP-complete it would be useful to have an approximation algorithm (or to prove that one cannot be found). There isalso another promising direction to investigate, which is the use of the parameterized complexity paradigm [23] to analyzeour problem. We have already demonstrated that, if we bound one of our parameters, (the number of candidates), then theEvaluation problem becomes easy to solve (and thus our problem belongs to XP). It will be interesting to check if otherrestrictions might also help, for example, if the number of different probability distributions is bounded by a constant.AcknowledgementsWe gratefully acknowledge the detailed and helpful comments of the anonymous referees, which have enabled us toconsiderably improve this paper. We thank Efrat Manisterski for her help in developing the algorithm in Section 3. Thiswork was supported in part by the Israel Ministry of Science and Technology, grant 3-6797. This paper subsumes an earlierconference paper [25].Appendix A. Correctness proof for Algorithm 1Theorem 16. Given an imperfect information voting domain (consisting of a set of candidates C , a finite set of voters V , a set ofpreferences profiles, and a probability distribution over this set of preference profiles for each voter), Algorithm 1 enumerates all thepossible voting scenarios in polynomial time, when the number of candidates is considered a constant.Proof. Let VRi be the set of voting results that the algorithm generates in iteration i. We prove that the algorithm enu-merates all the relevant voting scenarios, by induction on the number of voters. If there is only one voter, the algorithmwill generate at most l voting results from the voter’s preferences. Clearly, these are all possible voting scenarios for thisvoter. Otherwise, consider the n-th iteration. Every voting scenario of n voters consist of a voting scenario of n − 1 votersplus one preference order of the n-th voter. By the inductive hypothesis, all the possible voting scenarios of n − 1 votersare summarized by VRn−1. Thus, combining every voting results from VRn−1 with every preference order of the n-th votergenerates VRn, which summarizes all the voting scenarios of n voters, as required.As for the running time, the total number of voting results is polynomial in n (since m is a constant), and for eachvoting result there are O (l) operations for generating other voting results. Generating voting results takes polynomial time,by definition. Thus, the algorithm’s running time is polynomial in n and l. (cid:2)References[1] K.J. Arrow, A.K. Sen, K. Suzumura (Eds.), Handbook of Social Choice and Welfare, vol. 1, Elsevier, Amsterdam, 2002.[2] Y. Bachrach, N. Betzler, P. Faliszewski, Probabilistic possible winner determination, in: Proceedings of the Twenty-Fourth AAAI Conference on ArtificialIntelligence (AAAI-2010), 2010, pp. 697–702.[3] J.J. Bartholdi, J. Orlin, Single transferable vote resists strategic voting, Social Choice and Welfare 8 (4) (1991) 341–354.[4] J.J. Bartholdi, C.A. Tovey, M.A. Trick, The computational difficulty of manipulating an election, Social Choice and Welfare 6 (1989) 227–241.[5] J.J. Bartholdi, C.A. Tovey, M.A. Trick, Voting schemes for which it can be difficult to tell who won the election, Social Choice and Welfare 6 (1989)157–165.[6] D. Baskins, Judy IV, http://judy.sourceforge.net/, 2001.[7] D. Baumeister, J. Rothe, Taking the final step to a full dichotomy of the possible winner problem in pure scoring rules, Lisbon, Portugal, 2010, pp. 1019–1020.[8] N. Betzler, B. Dorn, Towards a dichotomy of finding possible winners in elections based on scoring rules, in: Proceedings of the Thirty-Fourth In-ternational Symposium on Mathematical Foundations of Computer Science (MFCS-2009), in: Lecture Notes in Computer Science (LNCS), vol. 5734,Springer-Verlag, 2009, pp. 124–136.[9] N. Betzler, B. Dorn, Towards a dichotomy for the possible winner problem in elections based on scoring rules, Journal of Computer and SystemSciences 76 (8) (2010) 812–836.[10] N. Betzler, S. Hemmann, R. Niedermeier, A multivariate complexity analysis of determining possible winners given incomplete votes, in: Proceedingsof the Twenty-First International Joint Conference on Artificial Intelligence (IJCAI-2009), 2009, pp. 53–58.[11] D. Black, On the rationale of group decision-making, Journal of Political Economy 56 (1) (1948) 23–34.[12] D. Black (Ed.), The Theory of Committees and Elections, Cambridge University Press, Cambridge, 1958.[13] S.J. Brams, P.C. Fishburn, Voting procedures, in: K.J. Arrow, A.K. Sen, K. Suzumura (Eds.), Handbook of Social Choice and Welfare, vol. 1, Elsevier,Amsterdam, 2002, Chapter 4.[14] Y. Chevaleyre, J. Lang, N. Maudet, G. Ravilly-Abadie, Compiling the votes of a subelectorate, in: Proceedings of the Twenty-First International JointConference on Artificial Intelligence (IJCAI-2009), 2009, pp. 97–102.[15] V. Conitzer, Computational aspects of preference aggregation, PhD thesis, Department of Computer Science, Carnegie Mellon University, 2006.[16] V. Conitzer, T. Sandholm, Complexity of manipulating elections with few candidates, in: Proceedings of the Eighteenth National Conference on ArtificialIntelligence (AAAI-2002), 2002, pp. 314–319.18N. Hazon et al. / Artificial Intelligence 189 (2012) 1–18[17] V. Conitzer, T. Sandholm, Vote elicitation: complexity and strategy-proofness, in: Proceedings of the Eighteenth National Conference on Artificial Intel-ligence (AAAI-2002), 2002, pp. 392–397.[18] V. Conitzer, T. Sandholm, Universal voting protocol tweaks to make manipulation hard, in: Proceedings of the Eighteenth International Joint Conferenceon Artificial Intelligence (IJCAI-2003), 2003, pp. 781–788.[19] V. Conitzer, T. Sandholm, J. Lang, When are elections with few candidates hard to manipulate?, Journal of the ACM 54 (3) (2007) 1–33.[20] U. Endriss, J. Lang (Eds.), Proceedings of the First International Workshop on Computational Social Choice Theory 2006 (COMSOC-2006), ILLC, Universityof Amsterdam, Amsterdam, The Netherlands, 2006.[21] P. Faliszewski, Nonuniform bribery, in: Proceedings of the Seventh International Joint Conference on Autonomous Agents and Multiagent Systems(AAMAS-2008), 2008, pp. 1569–1572.[22] P. Faliszewski, E. Hemaspaandra, L.A. Hemaspaandra, J. Rothe, Llull and Copeland voting broadly resist bribery and control, in: Proceedings of theTwenty-Second AAAI Conference on Artificial Intelligence (AAAI-2007), 2007, pp. 724–730.[23] J. Flum, M. Grohe (Eds.), Parameterized Complexity Theory, Springer, 2006.[24] M.R. Garey, D.S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W.H. Freeman, New York, 1979.[25] N. Hazon, Y. Aumann, S. Kraus, M. Wooldridge, Evaluation of election outcomes under uncertainty, in: Proceedings of the Seventh International JointConference on Autonomous Agents and Multiagent Systems (AAMAS-2008), 2008, pp. 959–966.[26] N. Hazon, P.E. Dunne, S. Kraus, M. Wooldridge, How to rig elections and competitions, in: Proceedings of the Second International Workshop onComputational Social Choice (COMSOC-2008), 2008, pp. 301–312.[27] K. Konczak, J. Lang, Voting procedures with incomplete preferences, in: Proceedings of the Multidisciplinary IJCAI-05 Workshop on Advances in Prefer-ence Handling (M-PREF), 2005.[28] J. Lang, M.S. Pini, F. Rossi, D. Salvagnin, K.B. Venable, T. Walsh, Winner determination in voting trees with incomplete preferences and weighted votes,Autonomous Agents and Multi-Agent Systems 25 (1) (2012) 130–157.[29] M.S. Pini, F. Rossi, K.B. Venable, T. Walsh, Dealing with incomplete agents preferences and an uncertain agenda in group decision making via sequentialmajority voting, in: Principles of Knowledge Representation and Reasoning: Proceedings of the Eleventh International Conference (KR-2008), 2008,pp. 571–578.[30] M.S. Pini, F. Rossi, K.B. Venable, T. Walsh,Incompleteness and incomparability in preference aggregation: complexity results, ArtificialIntelli-gence 175 (7–8) (2011) 1272–1289.[31] T. Vu, A. Altman, Y. Shoham, On the complexity of schedule control problems for knockout tournaments, in: Proceedings of the Eighth InternationalJoint Conference on Autonomous Agents and Multiagent Systems (AAMAS-2009), 2009, pp. 225–232.[32] T. Walsh, Uncertainty in preference elicitation and aggregation, in: Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence (AAAI-2007), 2007, pp. 3–8.[33] T. Walsh, Where are the really hard manipulation problems? The phase transition in manipulating the veto rule, in: Proceedings of the Twenty-FirstInternational Joint Conference on Artificial Intelligence (IJCAI-2009), 2009, pp. 324–329.[34] D.B. West (Ed.), Introduction to Graph Theory, 2nd edition, Prentice Hall, 2001.[35] L. Xia, V. Conitzer, Compilation complexity of common voting rules, in: Proceedings of the Twenty-Fourth AAAI Conference on Artificial Intelligence(AAAI-2010), 2010, pp. 915–920.[36] L. Xia, V. Conitzer, Determining possible and necessary winners under common voting rules given partial orders, Journal of Artificial IntelligenceResearch 41 (2011) 25–67.