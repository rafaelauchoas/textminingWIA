Artificial Intelligence 203 (2013) 19–34Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintComplexity issues related to propagation completenessMartin Babka, Tomáš Balyo, Ondˇrej ˇCepek, Štefan Gurský, Petr KuˇceraVáclav Vlˇcek∗,Department of Theoretical Computer Science and Mathematical Logic, Faculty of Mathematics and Physics, Charles University in Prague,Malostranské nám. 25, 118 00 Praha 1, Czech Republica r t i c l ei n f oa b s t r a c tArticle history:Received 10 July 2012Received in revised form 14 June 2013Accepted 30 July 2013Available online 7 August 2013Keywords:Boolean functionsSatisfiabilityKnowledge compilationEmpowering implicatesUnit propagationPropagation completenessKnowledge compilation is a process of adding more information to a knowledge base inorder to make it easier to deduce facts from the compiled base than from the original one.One type of knowledge compilation occurs when the knowledge in question is representedby a Boolean formula in conjunctive normal form (CNF). The goal of knowledge compilationin this case is to add clauses to the input CNF until a logically equivalent propagationcomplete CNF is obtained. A CNF is called propagation complete if after any partialsubstitution of truth values all logically entailed literals can be inferred from the resultingCNF formula by unit propagation. The key to this type of knowledge compilation is theability to generate so-called empowering clauses. A clause is empowering for a CNF if it isan implicate and for some partial substitution of truth values it enlarges the set of entailedliterals inferable by unit propagation.In this paper we study several complexity issues related to empowering implicates,propagation completeness, and its relation to resolution proofs. We show several results:(a) given a CNF and a clause it is co-NP complete to decide whether the clause is anempowering implicate of the CNF, (b) given a CNF it is NP-complete to decide whetherthere exists an empowering implicate for it and thus it is co-NP complete to decidewhether a CNF is propagation complete, and (c) there exist CNFs to which an exponentialnumber of clauses must be added to make them propagation complete.© 2013 Published by Elsevier B.V.1. IntroductionOne of the most studied problems in computer science, both theoretical and applied, is the satisfiability problem for CNFformulas (SAT). The difficulty of SAT depends on the class of CNF formulas to which the input formula belongs. There arevarious techniques and algorithms for SAT for different classes of CNF formulas ranging from linear algorithms for Horn,quadratic (2-CNF) and SLUR formulas [1,2] to the very complex variants of the exponential DPLL [3,4] and CDCL [5–8]procedures implemented in general purpose SAT solvers. Even the most complicated SAT solvers usually perform a taskcalled unit propagation [3]. The goal of unit propagation is to infer as many logically entailed literals as possible from apartial truth assignment and the input formula. Although in general unit propagation is not a complete method (it does notinfer all logically entailed literals), it is complete for the class of propagation complete (PC) CNF formulas [9].PC formulas play an important role also in constraint programming, or more specifically, in CNF encodings of globalconstraints. There is a strong connection between propagation completeness of the CNF encoding and domain consistency* Corresponding author. Tel.: +420 221 914 138; fax: +420 221 914 323.E-mail addresses: babkys@gmail.com (M. Babka), biotomas@gmail.com (T. Balyo), ondrej.cepek@mff.cuni.cz (O. ˇCepek), stevko@mail.ru (Š. Gurský),kucerap@ktiml.mff.cuni.cz (P. Kuˇcera), vlcek@ktiml.mff.cuni.cz (V. Vlˇcek).0004-3702/$ – see front matter © 2013 Published by Elsevier B.V.http://dx.doi.org/10.1016/j.artint.2013.07.00620M. Babka et al. / Artificial Intelligence 203 (2013) 19–34of the encoded constraint [10,11]. It has been studied for several concrete global constraints such as the AllDifferentconstraint [12], the Sequence constraint [13], Regular, Among, and Generalized Sequence [10], or theGrammar con-straints [14].Some SAT solvers try to avoid searching in the state subspaces with no solution by learning from conflicts, i.e. byperforming conflict driven clause learning (CDCL) [5–8], the name CDCL is also used for the complete algorithm solving SATproblem. It is useful to learn clauses (called empowering implicates [9,15]) that allow unit propagation to infer more logicallyentailed literals after such a clause is added to the CNF formula than it was possible to infer before the addition. Therefore,to speed up the CDCL SAT solver search for a satisfying assignment, it is often very useful to learn (generate) empoweringimplicates and add them to the input CNF formula. Let us mention that today’s most successful SAT solvers for real-worldapplications are the ones using CDCL procedure.This process of adding empowering implicates to a CNF formula can be viewed as a special type of knowledge com-pilation where both the input and the output representation of the knowledge is a CNF formula. In general, knowledgecompilation is a process of adding more information to a given knowledge representation in order to make it computa-tionally easier to infer facts from the compiled representation [16,17], or a process of transforming a given knowledgerepresentation into another knowledge representation which is more tractable with respect to fact deduction, such as trans-forming a CNF into a BDD [18]. Nevertheless, in this paper we are interested only in the very limited case of knowledgecompilation that rests in adding empowering implicates to a CNF.It has been shown in [9], along with other properties of PC formulas, that a formula ϕ is PC if and only if there isno empowering implicate for ϕ. However, several complexity issues directly connected to propagation completeness andempowering implicates are left open in [9]. A short list of such questions is the following:1. Given a CNF formula ϕ and a clause C , what is the complexity of deciding whether C is an empowering implicatefor ϕ?2. Given a CNF formula ϕ that is not PC, how difficult is it to generate an empowering implicate for ϕ by resolution,where the “level of difficulty” is measured by the length of the resolution proof?3. Given a CNF formula ϕ, what is the complexity of deciding whether there exists an empowering implicate for ϕ?4. Given a CNF formula ϕ that is not PC, how many empowering implicates is it necessary to add to ϕ in order to makeit PC?In this paper we tackle all of the above listed problems. After reviewing basic definitions and notation in Section 2, wederive several simple properties of empowering implicates in Section 3. We address the following four questions as follows:1. In Section 3 we show that the first problem is co-NP complete. This is not a very difficult result, however, to the bestof our knowledge, it was not stated in the related literature yet.2. In Section 4 we tackle the second problem. We prove that for a non-PC CNF formula with s occurrences of literalsthere always exists a resolution proof of length O (s) of some empowering implicate. On the other hand, we constructexamples of CNF formulas where a resolution proof of length Ω(s) is needed for any empowering implicate, whichmeans that Θ(s) is an asymptotically tight bound for this problem. It is important to note that the upper boundresult does not require the derived empowering implicate to be prime. We show (by a simple modification of resultsconcerning refutation proofs [19,20]) that there exist CNF formulas such that in order to derive any prime empoweringimplicate of such CNF a resolution proof of an exponential length is needed.3. Section 5 contains the main results of this paper which are connected to the third problem. It was proved in [9] thatdeciding about an existence of an empowering implicate is in (cid:5) p2 . Using the results from Section 4 we strengthen thisresult by showing that the problem belongs to (cid:5) p= NP. Given the equivalence between propagation completeness and1non-existence of empowering implicates proved in [9], this immediately implies that testing propagation completenessbelongs to co-NP. Then we proceed with the hardness proof for this problem. We present a reduction from a well-knownNP-complete 3-dimensional matching problem which proves that deciding for a CNF formula whether there exists anempowering implicate for it is NP-hard (and thus testing propagation completeness is coNP-hard).4. The fourth question is answered in Section 5 as well by showing that there exist CNF formulas where an exponentialnumber (both with respect to the number of variables and the number of clauses) of empowering implicates must beadded in order to arrive at a PC formula. This strengthens the superpolynomial bound which follows from a combinationof results in [9] and [21] using a superpolynomial lower bound for certain monotone circuits from [22]. The connectionis discussed in detail in Section 2.5.We close the paper by giving few concluding remarks in Section 6.M. Babka et al. / Artificial Intelligence 203 (2013) 19–34212. Definitions2.1. Basic definitionsA Boolean function of n variables is a mapping f : {0, 1}n → {0, 1}. We say that a Boolean function fis satisfiable if thereis a vector (cid:4)x ∈ {0, 1}n such that f ((cid:4)x) = 1. A literal is either a variable (x, called positive literal) or its negation (¬x or x, callednegative literal). A clause is a disjunction of literals. We assume that no clause contains both positive and negative literalsof the same variable. A clause which contains just one literal is called a unit clause. Formula ϕ is in conjunctive normal form(CNF) if it is a conjunction of clauses (we also say that ϕ is a CNF formula). We shall often treat a clause as a set of itsliterals and a CNF formula as a set of its clauses. It is a well-known fact that every Boolean function can be represented bya CNF formula (see e.g. [23]). A CNF formula ϕ is called a Horn formula if every clause in ϕ has at most one positive literal.A quadratic CNF formula (also called 2-CNF formula) is a CNF formula where each clause contains at most two literals. If twoCNF formulas ϕ1 and ϕ2 define the same function, we say that they are equivalent and we denote this fact with ϕ1 ≡ ϕ2.Clause C is called an implicate of f if every assignment (cid:4)x ∈ {0, 1}n satisfying f (i.e. f ((cid:4)x) = 1) also satisfies C (i.e. C((cid:4)x) = 1).We use notation f |(cid:7) C to denote that C is an implicate off . We also say that C is logically entailed by f . Since everyCNF formula ϕ represents a function, we shall often use ϕ |(cid:7) C to denote the fact that C is an implicate of the functionrepresented by ϕ. We shall also say that C is an implicate of ϕ or that it is logically entailed by ϕ. A clause is a special caseof a CNF formula and thus for two clauses C1 and C2 we can also use C1 |(cid:7) C2. This is possible only if literals containedin C1 are also contained in C2. In this case we say that clause C1 subsumes clause C2. C is a prime implicate of a function f(cid:8)of f subsuming C . We say that CNF formula ϕ is prime if itif it is an implicate of f and there is no other implicate Ccontains only prime implicates. A special case of prime CNF formula is the canonical CNF formula of f (also called a canonicalrepresentation of f ), which consists of all the prime implicates of f .Given a CNF formula ϕ and a clause C we define IsImplicate(ϕ, C ) as the problem of deciding whether C is an implicateof ϕ. It is well known that this problem is co-NP complete (co-SAT is a special case of IsImplicate(ϕ, C ) in which C is anempty clause).2.2. ResolutionWe say that two clauses have a conflict in variable x if there is a positive occurrence of x in one clause and a negativeoccurrence in the other. Two clauses C1 = ( (cid:2)C1 ∨ x) and C2 = ( (cid:2)C2 ∨ x) are resolvable over x if (cid:2)C1 and (cid:2)C2 do not have a conflictin any variable. We write R(C1, C2) = (cid:2)C1 ∨ (cid:2)C2 and this disjunction is called a resolvent of the parent clauses C1 and C2.A resolution in which one of the parent clauses is a unit clause is called a unit resolution. A resolution in which the parentclauses have no common literal is called a non-merge resolution, otherwise it is a merge resolution.Let ϕ be a CNF formula representing a Boolean function f , we say that C can be derived from ϕ by a series of resolutionsif there is a sequence of clauses C1, . . . , Ck = C such that every Ci , 1 (cid:2) i (cid:2) k, either belongs to ϕ, or Ci = R(C j1 , C j2 ), wherej1, j2 < i. Such a series of resolutions is also called a resolution proof of C from ϕ. Resolution proof of a contradiction (i.e. anempty clause ⊥) from formula ϕ is also called a resolution refutation. A resolution proof in which every resolution is unitis called a unit resolution proof , a unit resolution proof of a contradiction ⊥ from ϕ is called a unit refutation and if such aproof exists for ϕ, then this formula is called unit refutable. This fact is denoted by ϕ (cid:11)1 ⊥. If a unit clause (literal) x can bederived by unit resolutions then we write ϕ (cid:11)1 x. Thelength of a resolution proof is the number of clauses in the sequence.It is a well known fact that for any Boolean function the resolvent of two implicates is again an implicate (see e.g. [24]).Another well known fact is that every prime implicate of f can be derived from ϕ by a series of resolutions (see e.g. [24]).2.3. Unit propagation and refutationUnit propagation is an iterative procedure which in each step selects a unit clause (a literal), removes each clause con-taining this literal, and removes the complementary literal from the remaining clauses (i.e. satisfies the selected literal). Thisprocess iterates until an empty clause (a contradiction) is derived or there is no unit clause in the formula. Unit propa-gation can be performed in linear time [25]. It is a well-known fact that if ϕ (cid:11)1 x (where x is an arbitrary literal), thenunit propagation on ϕ satisfies x or derives contradiction. On the other hand, if x is satisfied during unit propagation, thenϕ (cid:11)1 x.We say that a literal x is logically entailed from ϕ by a partial assignment l1, . . . , lk (by setting literals l1, . . . , lk to true)if any assignment that extends l1, . . . , lk and satisfies ϕ sets x to true. Note that this is equivalent to ϕ ∧ l1 ∧ · · · ∧ lk |(cid:7) x.Clearly, literals that form unit clauses in ϕ are logically entailed from ϕ. Also note that given clause C = l1 ∨ l2 ∨ · · · ∨ lk,formula ϕ ∧¬l j is by De Morgan’s laws equivalent to ϕ ∧ ¬C . In the subsequent text we shall use these notationsinterchangeably.(cid:3)kj=1A clause C is called 1-provable with respect to a CNF formula ϕ, if ϕ ∧ ¬C (cid:11)1 ⊥. A clause C is thus 1-provable if it isan implicate of C and the fact that C is an implicate can be proved using unit propagation. The notion of 1-provabilitywas introduced in [15]. A formula ϕ is called unit refutation complete if every implicate C of ϕ is 1-provable with respectto ϕ. The notion of unit refutation completeness was introduced in [26] and later inspired the definition of propagationcompleteness in [9], which we give in the following subsection.22M. Babka et al. / Artificial Intelligence 203 (2013) 19–342.4. Propagation completeness and empowerementDefinition 2.1 (Propagation Completeness (PC) [9]). We call a CNF formula ϕ propagation complete (PC) if for any partialassignment l1, . . . , lk and any literal d the following holds. If d is logically entailed from ϕ by l1, . . . , lk, then d can bederived from ϕ by unit propagation after fixing values of l1, . . . , lk, i.e., if ϕ ∧ l1 ∧ · · · ∧ lk |(cid:7) d, then ϕ ∧ l1 ∧ · · · ∧ lk (cid:11)1 d. Theclass PC is the class of all PC formulas.Definition 2.2 (Empowering implicate [15,9], Absorption [27,9]). A clause C = l1 ∨ l2 ∨ l3 ∨ · · · ∨ lk is called an empoweringimplicate for a formula ϕ if it contains a literal li called an empowered literal such that ϕ ∧¬l j (cid:2)1 ⊥ and ϕ ∧(cid:3)j∈1...k, j(cid:13)=i(cid:3)(cid:3)j∈1...k, j(cid:13)=i¬l j |(cid:7) li but ϕ ∧j∈1...k, j(cid:13)=i¬l j (cid:2)1 li . An implicate C is called absorbed by ϕ if it has no empowered literal.It is known that a formula is propagation complete if and only if it has no empowering implicates [9]. Thus, any formulacan be extended to a propagation complete one by repeatedly adding empowering implicates.The notion of empowering clauses is closely related to CDCL SAT solvers, see [15] and [26]. It is important to note thateach asserting clause is empowering as observed in [15]. Since most CDCL SAT solvers learn only asserting clauses thenotion of propagation completeness is important also in the context of CDCL SAT solvers.Example 2.3. Consider the following formulaϕ = (a ∨ b ∨ x) ∧ (a ∨ c ∨ ¬x).Formula ϕ is not propagation complete, because ϕ ∧ ¬b ∧ ¬c |(cid:7) a but ϕ ∧ ¬b ∧ ¬c (cid:2)1 a. Indeed, by falsifying b and c we get(a ∨ x) ∧ (a ∨ ¬x) and thus literal a can be obtained by resolution, but not by unit propagation.It follows that (a ∨ b ∨ c) is an empowering implicate for ϕ with a being its empowered literal. By adding this implicateto ϕ we get a propagation complete formulaϕ(cid:8) = (a ∨ b ∨ x) ∧ (a ∨ c ∨ ¬x) ∧ (a ∨ b ∨ c).The fact that ϕ(cid:8)is propagation complete follows from the fact that it consists of all prime implicates of ϕ. Consider forexample a non-prime implicate C = (a ∨ b ∨ c ∨ x), this implicate is absorbed by ϕ(cid:8)because by falsifying any three literalsfrom C we either get an unsatisfiable formula (such as if a, b, and x are falsified) or we obtain the remaining literal by unitpropagation (such as if a, c, and x are falsified, b is obtained from the first clause of ϕ(cid:8)). We can observe that in fact, C isalready absorbed by ϕ.2.5. Relation of propagation completeness to constraint propagationPropagation complete formulas play an important role in constraint propagation (for general reading on constraintpropagation see Chapter 3 of [28]), where the notion appeared implicitly in earlier literature [10–14,29] concentratedon CNF encodings of constraints both in general [10,11], and for particular constraints (the sequence constraint [13], thegrammar constraint [14], the Regular, the Among, and the Generalized sequence constraints [11], or the AllDifferent con-straint [12]). A general idea which appeared in all these papers is to take a constraint C , encode it using a CNF and then useunit propagation to maintain some kind of domain consistency (e.g. generalized arc consistency (GAC) in [10], or (relational)(i, j)-consistency in [29]). In general, these encodings are polynomial in table representation of a constraint, however in thecase of a particular global constraint we can sometimes use its special properties to get a CNF representation of polynomialsize with respect to the arity of a constraint with suitable properties, such as in [11] in case of the Regular constraint, theAmong constraint, or the Generalized sequence constraint. On the other hand in some cases this is not possible as it isshown in [12] for the AllDifferent constraint.The idea of using unit propagation to maintain domain consistencies was formalized in [12], let us recall some of theresults and the notation from [12] here. A constraint C is defined over a set of variables X = { X1, . . . , Xn}, each of which hasa finite domain D( Xi). An assignment to a variable Xi is a mapping of Xi to a value j ∈ D( Xi), called a literal and writtenXi = j. D(X) denotes the set of literals, i.e. D(X) = { Xi = j | Xi ∈ X ∧ j ∈ D( Xi)}. P(D(X)) then denotes the set of all possiblesets of literals. A constraint C is defined over a set of variables denoted as scope(C) ⊆ X (scope of C ) and it allows a subsetof the possible assignments to the variables in scope(C).Following [12,30,28] a propagator for a constraint C is an algorithm which takes as input the domains of variables inscope(C) and returns restrictions of these domains. Formally a propagator for a constraint C can be defined as follows(definition is taken from [12], where they followed [30], see also Chapter 3 of [28]):Definition 2.4. (See Definition 1 in [12].) A propagator ff : P(D(X)) (cid:15)→ P(D(X)), such that fand idempotent, i.e. f (D(X)) = f ( f (D(X))). If f detects that C has no solutions under D(X) then f (D(X)) = ∅.for a constraint C is a polynomial time computable function(cid:8)(X)) ⊆ f (D(X)), contracting, i.e.f (D(X)) ⊆ D(X),(cid:8)(X) ⊆ D(X) ⇒ f (Dis monotone, i.e. DM. Babka et al. / Artificial Intelligence 203 (2013) 19–3423We say that a propagator detects dis-entailment if f (D(X)) = ∅ whenever C has no solution. A propagator enforces domainconsistency (DC) when Xi = j ∈ f (D(X)) implies that there exists a solution of C that contains Xi = j. Other consistencies(such as GAC [10] which is equivalent to DC, or (i, j)-consistency [29]) can be considered as well, we mention domainconsistency here because later on we shall recall the results of [12] on domain consistency propagators.Let us recall a definition of a CNF decomposition of a propagator as it appeared in [12]. Before that let us recall a generalway how a constraint satisfaction program (CSP) variables with multiple valued domains are usually encoded within a CNF.Given a variable Xi ∈ X with domain D( Xi) we encode it with a set of boolean variables xi, j , Xi ∈ X,j ∈ D( Xi) such thatXi (cid:13)= j ⇔ xi, j . The property that a CSP variable Xi has at most one value is enforced by the set of AMO (i.e. at most one)j, k ∈ D( Xi), k (cid:13)= j, and the property that it has at least one value is enforced by the ALO (i.e. atclauses (xi, j ∨ xi,k) for allj∈D( Xi ) xi, j . Following [12] we call the above described propositional representation of D(( X)) (i.e. set ofleast one) clauseall AMO and ALO clauses over all CSP variables) a direct encoding and denote it as Dsat(X).(cid:4)Definition 2.5. (See Definition 4 in [12].) A CNF decomposition of a propagation algorithm (propagator) f P is a formula inCNF ϕP over variables x ∪ y such that• The input variables x are the propositional representation Dsat(X) of D(X) and y is a set of auxiliary variables whose sizeis polynomial in |x|.• xi, j is set to 0 by a unit propagation if and only if Xi = j /∈ f P (D(X)).• Unit propagation on ϕP produces the empty clause when f P (D(X)) = ∅.Before further discussion, let us look at an example from [12].Example 2.6. (See Example 1 in [12].) Consider a Table constraint over the variables X1, X2 with D( X1) = D( X2) = {a, b}and the satisfying assignments: {(cid:20)a, a(cid:21), (cid:20)b, b(cid:21), (cid:20)a, b(cid:21)}. Using encoding introduced in [10] we can decompose a Table constraintinto the following CNF ϕT :ϕT = (x1a ∨ y1 ∨ y3) ∧ (x2a ∨ y1) ∧ ( y1 ∨ x1a) ∧ ( y1 ∨ x2a)∧ (x1b ∨ y2) ∧ (x2b ∨ y2 ∨ y3) ∧ ( y2 ∨ x1b) ∧ ( y2 ∨ x2b)∧ ( y3 ∨ x1a) ∧ ( y3 ∨ x2b) ∧ ( y1 ∨ y2 ∨ y3).Here y = { y1, y2, y3} consists of auxiliary variables corresponding to the three possible solutions to the Table constraint ( y1corresponds to (cid:20)a, a(cid:21), y2 to (cid:20)b, b(cid:21), and y3 to (cid:20)a, b(cid:21)). Suppose the value a is removed from the domain of X1. The assignmentx1a = 0 forces the variable y1 to 0, which in turn causes the variable x2a to 0, removing the value a from the domain of X2as well.Now let us generalize the ideas presented in the above example. Let us consider a constraint C , its consistency propagatorf P , and a CNF decomposition of f P via a CNF ϕP .• By definition, if f P detects dis-entailment, then f P (D(X)) = ∅ whenever C restricted to D(X) admits no solution. PassingD(X) to f P corresponds to setting all values xi, j = 0 for Xi = j /∈ D(X). The third condition of Definition 2.5 thus requiresthat after this partial assignment ϕP is not only unsatisfiable but this fact can be detected by unit propagation. Inparticular we require that for any D(X):(cid:5)ϕP ∧i, j: Xi = j /∈ D(X)¬xi, j |(cid:7) ⊥ ⇔ ϕP ∧(cid:5)¬xi, j (cid:11)1 ⊥.i, j: Xi = j /∈ D(X)What we in fact require here is that ϕP is unit refutation complete with respect to the partial assignments to the inputvariables x. Although we admit here only assignments to 0, the direct encoding clauses Dsat(X) allow us to use 1 aswell (assigning xi, j = 1 forces xi,k = 0 for any k (cid:13)= j, k ∈ D( Xi) by unit propagation on Dsat(X)).• If f P is a domain consistency propagator then there is no solution to C containing Xi = j if and only if Xi = j /∈ f (D(X)).Using the second condition from Definition 2.5 it corresponds to the fact that xi, j is a unit implicate of ϕP under partialassignment given by D(X) if and only if xi, j is forced to 0 by unit propagation on ϕP under this partial assignment. Inparticular we require that for any D(X) and any xi, j :(cid:5)ϕP ∧i(cid:8), j(cid:8): Xi(cid:8) = j(cid:8) /∈ D(X)¬xi(cid:8), j(cid:8) |(cid:7) ¬xi, j ⇔ ϕP ∧(cid:5)i(cid:8), j(cid:8): Xi(cid:8) = j(cid:8) /∈ D(X)¬xi(cid:8), j(cid:8) (cid:11)1 ¬xi, j.What we in fact require here is the fact that ϕP is propagation complete with respect to partial assignments and literalson the input variables in x. In the above equation it is enough to consider only negative literals xi, j due to presence ofclauses of direct encoding Dsat(X).24M. Babka et al. / Artificial Intelligence 203 (2013) 19–34The author of [10] suggests that a canonical CNF decomposition (i.e. CNF consisting of all prime implicates) is sufficientto encode both dis-entailment detecting propagator and domain consistency propagator. The above discussion shows that ashorter CNF is sufficient, in particular unit refutation completeness is sufficient for detecting dis-entailment and propagationcompleteness is sufficient for domain consistency propagator. This can be naturally generalized to other consistencies suchas (i, j)-consistency [29].It was shown in [21] that a polynomial sized decomposition of a consistency propagator f P exists if and only if it canby computed by a monotone circuit of polynomial size. This result was used to derive the following corollary:Corollary 2.7. (See Corollary 4 in [21].) There is no polynomial sized CNF decomposition of any AllDifferent domain consistencypropagator.On the other hand we can get a polynomial sized CNF encoding of the AllDifferent constraint. Using such an encodingand Corollary 2.7 it follows that no propagation complete encoding of the AllDifferent constraint can have polynomialsize. There are thus formulas such that any equivalent propagation complete formula has superpolynomial size. Let ushave a more detailed look at the proof of Corollary 2.7 in [21]. It was shown in [31] that AllDifferent constraint has asolution if and only if the corresponding bipartite value graph has a perfect matching. From the aformentioned connection tomonotone circuits proved in [21] it follows that based on an AllDifferent domain consistency propagator we can constructa monotone circuit that computes whether a bipartite graph has a perfect matching and such a circuit has a polynomial sizewith respect to the domain consistency propagator we start with. The proof is finished using an older result of Razborov [22]according to which the size of monotone circuit computing whether there is a perfect matching in a bipartite graph G onn vertices has size at least nΩ(log n), which is a superpolynomial (in some literature called quasi-polynomial) but not anexponential bound. In Section 5 we strengthen the result of Corollary 2.7 for propagation complete formulas by showingthat there are in fact formulas to which an exponential number of implicates have to be added in order to make thempropagation complete.3. Properties of empowering implicatesLet us start this section with a discussion on connection between unit refutation completeness introduced in [26] andpropagation completeness introduced in [9]. First let us recall that a formula ϕ is unit refutation complete if for everyimplicate C of ϕ we have that ϕ ∧ ¬C (cid:11)1 ⊥. This means that the fact that C is an implicate of ϕ can be proved usingjust unit resolution. It is not hard to see that if a formula ϕ is propagation complete, then it is unit refutation complete as¬li (cid:11)1 lk which implieswell. Indeed, if C = (l1 ∨ · · · ∨ lk) is an implicate of ϕ, then either ϕ ∧ϕ ∧¬li (cid:11)1 ⊥. On the other hand, it is not true that every unit refutation complete formula is also propagation complete.Consider the following formula ϕ:¬li (cid:11)1 ⊥, or ϕ ∧(cid:3)ki=1k−1i=1k−1i=1(cid:3)(cid:3)ϕ = (x ∨ a ∨ b ∨ c) ∧ (x ∨ a ∨ b ∨ d).This is a prime CNF which has only one more prime implicate C = (a ∨ b ∨ c ∨ d) produced by resolving the two clauses inϕ. We can observe that ϕ is unit refutation complete. If we add negation of C to ϕ, then unit resolution of x and x gives usthe empty clause. However ϕ is not propagation complete and C is an empowering implicate of ϕ with empowered literala (or b). Indeed, if we set b, c, and d to false in ϕ, we get CNF (x ∨ a) ∧ (x ∨ a) from which it is not possible to derive a justusing unit resolution.It follows from the above discussion that the set of propagation complete CNFs is a proper subset of unit refutationcomplete CNFs. The aim of this section is to recall several results about the class of unit refutation complete CNFs from [26]and observe that some of these results are in fact true already for the set of propagation complete formulas.We shall start with showing that adding a literal to a non-empowering implicate cannot make it empowering withrespect to any of the original literals.Lemma 3.1. Let ϕ be a CNF formula and let C = l1 ∨ · · · ∨ lk be an implicate of ϕ which is not empowering. Let A be a clause and letli ∈ C be an arbitrary literal. Then C ∨ A is not empowering implicate of ϕ with empowered literal li .(cid:3)Proof. Let us assume without loss of generality that i = k (if not, then we can achieve this by renaming the variables).By definition, the fact that C is not empowering with empowered literal lk implies that either ϕ ∧¬l j (cid:11)1 ⊥, ork−1ϕ ∧¬l jis a subformula ofj=1ϕ ∧¬a, what we can derive by unit propagation from the former formula, can be derived from latter one¬a (cid:11)1 lk. This means that by definition,¬a (cid:11)1 ⊥ or ϕ ∧as well. Thus we have that ϕ ∧C ∨ A is not empowering implicate with empowered literal lk. (cid:2)¬l j (cid:11)1 lk because C is an implicate of ϕ and thus ϕ ∧¬l j ∧¬l j |(cid:7) lk. Since ϕ ∧k−1j=1k−1j=1¬l j ∧¬l j ∧k−1j=1k−1j=1k−1j=1k−1j=1a∈ Aa∈ Aa∈ A(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)Note that in the previous proposition we cannot argue that A ∨ C is not empowering because it could be empoweringwith an empowered literal from A, e.g. if A would itself be an empowering clause. That is why we consider only literalsM. Babka et al. / Artificial Intelligence 203 (2013) 19–3425in C . Using Lemma 3.1, we can easily show that among empowering implicates the prime implicates are the only ones weneed to consider.Lemma 3.2. Let ϕ be a nonempty satisfiable CNF formula (i.e. it has at least one nonempty clause) and let C be an empoweringimplicate for ϕ. Then any implicate Cof ϕ subsuming C is empowering for ϕ (this in particular includes the case when Cis prime).(cid:8)(cid:8)(cid:8)be an arbitrary implicate subsuming C and let us assume that C(cid:8) (cid:13)= C . If C(cid:8)Proof. Let C⊥ and thus C cannot be empowering with respect to a literal a, which is not in Cempowering with respect to a literal in Cas well due to Lemma 3.1. (cid:2)(cid:8)(cid:8) (cid:11)1is not empowering, then ϕ ∧ ¬C. On the other hand, C cannot be(cid:8)As an easy corollary we now get that a canonical CNF formula is always propagation complete, although this can beeasily deduced from properties of canonical CNFs as well.Now let us consider the problem of generating an empowering implicate for a given CNF formula. A natural method toconsider is to generate an empowering implicate by the resolution procedure. In [26] it is shown that non-merge resolutioncannot produce an empowering implicate with respect to unit refutation completeness. In case of propagation completenessthe same is true. It follows from discussion at the beginning of Section 5 in [9]. We shall formulate this proposition as alemma to be able to reference to it later.Lemma 3.3. Let ϕ be a CNF formula and let C be produced from ϕ by a series of non-merge resolutions. Then C is not an empoweringimplicate of ϕ.Keeping in mind that a canonical formula is propagation complete, it follows that a CNF formula ϕ satisfying that everyprime implicate of ϕ is either present in it or it can be derived from ϕ by a series of non-merge resolutions is alwayspropagation complete. This property was already shown in form of Theorem 1 in [26] for unit refutation completeness andit is an easy corollary of arguments about non-merge resolution in [9] (here stated as Lemma 3.3) that it is true also for PCformulas.Since PC formulas allow easy inference, it is interesting to investigate classes which are contained in the class of PC CNFformulas. One such example is given by the following theorem which shows the desired property for the class of primequadratic CNF formulas.Theorem 3.4. If ϕ is a prime quadratic CNF formula, then it is propagation complete.Proof. If ϕ is not satisfiable, then the proposition of the theorem is trivial. Let us assume that ϕ is a satisfiable primequadratic CNF formula.By Lemma 3.2 it is enough to consider prime implicates as candidates for empowering implicates. Because ϕ is a primeCNF formula, it must contain all the unit prime implicates. Hence, if any other prime implicate should be added to ϕ tomake it propagation complete, it must be a quadratic clause which is produced by resolving two other quadratic clauses. Itis a simple observation that these resolutions have to be non-merge. Thus by Lemma 3.3 we have that ϕ must already bepropagation complete. (cid:2)The following lemma shows that the primeness assumption in the statement of Theorem 3.4 is necessary.Lemma 3.5. There is a (non-prime) quadratic CNF formula which is not PC.Proof. Let us consider the following CNF formula:ϕ = (a ∨ b) ∧ (a ∨ b).ϕ is clearly a quadratic CNF formula. On the other hand, ϕ is not PC because ϕ |(cid:7) a, but ϕ (cid:2)1 a. (cid:2)Now let us turn our attention to the complexity of testing if a given clause C is an empowering implicate of a CNFformula ϕ. We shall denote this problem as IsEmpowering(ϕ, C ). Note that co-NP completeness of IsEmpowering(ϕ, C )comes as no surprise since it is in essence very similar to another co-NP complete problem IsImplicate(ϕ, C ). The hard partof checking whether given clause C is an empowering implicate of ϕ is in fact checking whether C is an implicate of ϕ atall. Thus the co-NP completeness of IsEmpowering(ϕ, C ) is a direct consequence of co-NP completeness of IsImplicate(ϕ, C ).The proof of the following theorem only formalizes this idea.Theorem 3.6. The problem IsEmpowering(ϕ, C ) is co-NP complete.26M. Babka et al. / Artificial Intelligence 203 (2013) 19–34Proof. To show that a problem is in co-NP it suffices to have for every negative instance of the problem a polynomiallyverifiable certificate which allows to verify that the answer is no. We can distinguish two cases when a pair (ϕ, C) forms anegative instance of IsEmpowering. In the first case C is not even an implicate of ϕ and the desired certificate is then anassignment of truth values to the variables which satisfies ϕ and falsifies C . The second case is when C is an implicate of ϕbut not an empowering one. In this case an empty certificate is good enough because one needs no additional informationto be able to check in polynomial time that no literal in C is empowered. This can be done by running unit propagationand checking for every literal (cid:6) in C that ϕ ∧¬(cid:6)(cid:8) (cid:11)1 ⊥ or ϕ ∧For the co-NP hardness we reduce the co-NP complete problem IsImplicate to IsEmpowering. Let (ϕ, C) be an arbitraryinstance of IsImplicate. We start by a simple preprocessing step in which we run unit propagation to test whether ϕ ∧(cid:3)¬(cid:6) (cid:11)1 ⊥. If yes, then C is an implicate of ϕ (in fact a 1-provable implicate), i.e. (ϕ, C) is a positive instance ofIsImplicate, and the reduction algorithm can terminate by answering yes. Note that this case includes the situation when C(cid:8)) of IsEmpowering by ϕ(cid:8) = ϕ ∧ (x ∨ y) ∧ (x ∨ y)is a clause in ϕ. If no, i.e. if ϕ ∧(cid:8) = C ∨ x, where x and y are two new variables not appearing in (ϕ, C). We shall show that C is an implicate of ϕ ifand Cand only if Cwith x as the empowered literal.¬(cid:6) (cid:2)1 ⊥, we define an instance (ϕ(cid:8), Cis an empowering implicate of ϕ(cid:8)¬(cid:6)(cid:8) (cid:11)1 (cid:6).(cid:6)(cid:8)∈C, (cid:6)(cid:8)(cid:13)=(cid:6)(cid:6)(cid:8)∈C, (cid:6)(cid:8)(cid:13)=(cid:6)(cid:6)∈C(cid:6)∈C(cid:3)(cid:3)(cid:3)(cid:8)Let C be an implicate of ϕ. C is clearly an implicate of ϕ(cid:8)is empowering with x as the empowered literal recall that ϕ ∧propagation does nothing on (x ∨ y) ∧ (x ∨ y) and neither x nor y appear in ϕ and C .(cid:8)¬(cid:6) (cid:2)1 ⊥ and thus ϕ(cid:8) ∧, and hence also C(cid:6)∈C(cid:3)is an implicate of ϕ(cid:8)(cid:3)(cid:6)∈C(cid:8). To see that C¬(cid:6) (cid:2)1 x because unitLet C(cid:8)be an empowering implicate of ϕ(cid:8)with x as the empowered literal. The fact that Cthat any assignment that falsifies Cand satisfies (x ∨ y) ∧ (x ∨ y) regardless of the value of y. Thus, to falsify ϕ(cid:8)which falsifies C must also falsify ϕ, which means that C is an implicate of ϕ. (cid:2)(cid:8)must also falsify ϕ(cid:8). However, any assignment which falsifies C(cid:8)is an implicate of ϕ(cid:8)meanssets x to 1, falsifies Cit must falsify ϕ. Therefore any assignment(cid:8)Let us recall the notion of a tied chain in a CNF formula used in [26] in case of unit refutation completeness.Definition 3.7. (See [26], introduced in [32].) A tied chain in a CNF formula ϕ is a sequence of triples (x1, C1, y1), (x2, C2, y2),. . . , (xn, Cn, yn) such that:• For 1 (cid:2) i (cid:2) n, Ci is a clause in ϕ and xi, yi are two different literals in Ci (i.e. xi (cid:13)= yi ).• For 1 (cid:2) i (cid:2) n − 1, we have that yi and xi+1 are complementary literal (called link literals of the chain).• x1 = yn is called the tied literal of the chain.For example CNF formula ϕ = (p ∨ q ∨ r) ∧ (r ∨ s) ∧ (s ∨ p) contains a tied chain with p as tied literal. In [32] it is shownthat the absence of tied chains is a sufficient condition for unit refutation completeness. The following lemma was shownin [26] as Lemma 6.Lemma 3.8. (See Lemma 6 of [26].) Let C be an implicate of a CNF formula ϕ which is produced from ϕ by a resolution proof D inwhich the last resolution made is a merge resolution. Let us assume that the parent clauses of C in D are C1 and C2, where M denotesthe set of common literals in C1 and C2. M (cid:13)= ∅ since the last step in D is a merge resolution and every literal of M is contained in C .Then ϕ contains, for each literal (cid:6) ∈ M, a tied chain T (cid:6) with (cid:6) as its tied literal. Furthermore, each link literal in T (cid:6) has a clause in Dwhich is produced from its parent clauses by resolution upon (cid:6).It is argued in [26] that if there are no tied chains in a CNF formula ϕ, there can be no merge resolutions and thus theformula ϕ has to be unit refutation complete. The same argument can be used for propagation completeness. We can arguein the same way using Lemma 3.3 that absence of tied chains in a CNF formula ϕ implies that ϕ is propagation complete.We shall use this property in proofs in the text and thus we shall formulate it as a lemma to be able to reference to it.Lemma 3.9. If a CNF formula ϕ does not contain tied chains, then it is propagation complete.4. Resolution derivations of empowering implicatesWe have seen in Theorem 3.6 that it is hard to check whether a given clause C is an empowering implicate of a givenformula ϕ. The hard part of this test is to check whether C is in the set S of all implicates of ϕ. The core of the proof of(cid:8) ⊆ S of all empowering implicates of ϕ does not make this test easier.Theorem 3.6 shows that considering a smaller set SWe shall show now that the hard part of the test can be in some sense avoided by considering a suitable enlargementof the tested clause. In particular, we shall show that if a clause C is an empowering implicate of a CNF formula ϕ, we can(cid:8)always extend C by adding suitable literals to obtain clause Cwhich is still empowering and moreover we can check thatis an implicate of ϕ simply by unit resolution. Let us recall that such a clause is called 1-provable (which is a notionCintroduced in [15]).(cid:8)Proof of Theorem 4.2 is significantly based on Proposition 2. The proposition is given in [15] and may be restated asfollows.M. Babka et al. / Artificial Intelligence 203 (2013) 19–3427Proposition 4.1. (See Proposition 2 of [15].) Let ψ be an unsatisfiable CNF such that ψ (cid:2)1 ⊥ and Π be its resolution refutation. Thenthere exists a clause Cψ ∈ Π which is both empowering and 1-provable.Let C be an empowering implicate of a formula ϕ which is not 1-provable. This means that if we falsify all the literals inC and add them to ϕ, thus producing ψ = ϕ ∧ ¬C , then we get a contradiction which is not provable by unit resolution. Byusing the previous proposition we show that we may add the clause C to the obtained clause Cψ to obtain a clause whichis both 1-provable and empowering.The following Theorem 4.2 is a consequence of Proposition 4.1. For readers familiar with CDCL SAT solvers, the idea re-mains the same as in the previous paragraph. By falsifying the literals in C any CDCL SAT solver must derive a contradiction.We add the solver’s decisions to the input clause C , i.e. we add ¬C and the conjunction of literals corresponding to eachassigned variable to the input formula. After such an addition, we obtain the desired 1-provable and empowering clause.As we shall show later in Proposition 4.3 we can even derive such a clause C using only linear number of resolution stepswith respect to the number of literal occurrences in ϕ.Theorem 4.2. Assume that C is an empowering implicate of a formula ϕ which is not 1-provable. Then there is an implicate Csuch that C ⊂ Cand C is both 1-provable and empowering.(cid:8)(cid:8)of ϕProof. Let ψ = ϕ ∧ ¬C and Π be a resolution refutation of ψ . Because C is not 1-provable for ϕ it holds that ψ (cid:2)1 ⊥. Thenaccording to the proposition there is a clause Cψ ∈ Π which is both empowering and 1-provable with respect to ψ . Weconsider a clause Cϕ = Cψ ∨ C .First, Cϕ is 1-provable for ϕ because Cψ is 1-provable for ψ and all the possibly required literals were added to Cϕ . Itfollows from the following obvious chain of equivalence:Cψ is 1-provable for ψ ⇔ ψ ∧ ¬Cψ (cid:11)1 ⊥ ⇔ ϕ ∧ ¬C ∧ ¬Cψ (cid:11)1 ⊥⇔ ϕ ∧ ¬Cϕ (cid:11)1 ⊥ ⇔ Cϕ is 1-provable for ϕ.(1)Let (cid:6) be an empowering literal of Cψ for ψ . Then (cid:6) is trivially also an empowered literal of Cϕ for ϕ. The requiredproperties for unit resolution and entailment come from the definitions of Cϕ and ψ using similar chain of equivalences asin 1.Thus Cϕ is the desired clause since it is both empowering and 1-provable with respect to ϕ. (cid:2)The following proposition shows that not only can we find a 1-provable and empowering implicate as in Theorem 4.2but we can also derive some empowering implicate by a resolution derivation of linear length with respect to the numberof literals occurring in given formula. The proof is based on ideas presented in [15] and [33–35] in the context of CDCL SATsolvers. More detailed discussion about this connection is presented just after the proof of the proposition.Proposition 4.3. Let ϕ be a formula on n variables which is not propagation complete and s be the size of the CNF representation of ϕ(i.e. s is the total number of occurrences of literals in ϕ). Then there is an empowering implicate C of ϕ which can be derived by a seriesof resolutions of length at most s from ϕ.Proof. From Theorem 4.2 it follows that there is an empowering 1-provable implicate Cϕ of ϕ with an empowered literal (cid:6).Let ϕ(cid:8)denote the formula which originates from ϕ after adding unit clauses formed by negated literals from Cϕ , i.e.ϕ(cid:8) ≡ ϕ ∧ ¬Cϕ . Since Cϕ is 1-provable it follows that ϕ(cid:8) (cid:11)1 ⊥, i.e. we can derive contradiction from ϕ(cid:8)by using only unitresolution.Due to the nature of unit resolutions, we can assume that the unit refutation proceeds in two phases.1. In the first phase we take all unit clauses from ¬Cϕ and perform unit resolutions only over the variables from Cϕ .2. In the second phase we continue with refutation proof without using unit clauses from ¬Cϕ and we do not resolveover variables from Cϕ at all.In case of unit resolutions if we already have some unit clauses it does not matter in which order we make unit resolutionsover them. Thus we may assume without loss of generality that unit clauses from ¬Cϕ are used first. The first phase thuscorresponds to performing partial assignment to variables of ϕ which falsifies literals in Cϕ .Let us now assume that D= ⊥ is a unit refutation proof which proceeds in the above two phases. Since it is a(cid:8)unit refutation proof, it can be observed that m (cid:2) s. Let us assume that the first phase is formed by clauses Dk(cid:8)−1and the second phase is formed by clauses Dor(cid:8)it originates from two preceding clauses by unit resolution over variable from Cϕ . Similarly each clause among Dmis either an original clause from ϕ or it originates from two preceding clauses by unit resolution over a variable whichis not in Cϕ . Observe that if the resolution proof is irredundant, i.e. no clause can be dropped from it, no clause among(cid:8)1, . . . , Dk(cid:8)−1 is therefore either a clause in ϕ(cid:8)(cid:8)k(cid:8) , . . . , D(cid:8)m. Each clause among D(cid:8)k(cid:8) , . . . , D(cid:8)1, . . . , D(cid:8)1, . . . , D(cid:8)m(cid:8)28M. Babka et al. / Artificial Intelligence 203 (2013) 19–34(cid:8)k(cid:8) , . . . , DDremove a variable from Cϕ in the second phase.(cid:8)m contains a variable from Cϕ . This is because in the end we arrive at an empty clause and there is no way to(cid:8)Let us now consider the situation in which we do not proceed with the first phase, in particular if we replace the firstphase only with a list of corresponding clauses from ϕ. In this case the second phase can proceed as before (except thatunit resolution steps are replaced by general resolution steps) only now the input clauses of phase 2 may contain someliterals from Cϕ as these were not removed in missing phase 1. These literals propagate down to the end of the proof and(cid:8) ⊆ Cϕ . Note that (cid:6) will be⊥ now becomes a subclause of Cϕ . In this way we shall obtain a resolution proof of a clause Cbecause otherwise the original unit refutation would actually prove that ϕ ∧ ¬(Cϕ \ {(cid:6)}) (cid:11)1 ⊥ which would bepresent in Cin contradiction with the fact that Cϕ is an empowering implicate with empowered literal (cid:6). Thus Cwill be empoweringby Lemma 3.1.Let us now formalize the above idea. If Dfrom ¬Cϕ or there is a clause D j ∈ ϕ, such that Dused in the second phase of the unit refutation proof, the latter is the case and then Dby falsifying all literals of Cϕ which appear in D j .(cid:8)k(cid:8) , . . . , D(cid:8)m then we shall define clause D j as follows. If D(cid:8)j is a clause among the clauses D(cid:8)1, . . . , D(cid:8)j originates from D j by falsifying some literals from Cϕ . If D(cid:8)k(cid:8)−1, then it is either a unit literal(cid:8)j is later(cid:8)j originates from some clause D j ∈ ϕ(cid:8)If D(cid:8)j(cid:8)j is among D(cid:8)a, D= R(D(cid:8)b) where 1 (cid:2) a, b < j, then we define D j = R(Da, Db). Note that if Dif Dthen the same is true about Da and Db. This is because if Da contains more literals than Dthe same is true for Db and D(cid:8)b.(cid:8)(cid:8)j is an original clause from ϕ, then D j = Dj ,(cid:8)(cid:8)a and Db were two resolvable clauses,(cid:8)a these literals are from Cϕ andIn the end we get a resolution derivation of length at most m (cid:2) s of clause C = Dm which is a subclause of Cϕ . As wehave already mentioned (cid:6) must be present in C . Otherwise we would get that it was not necessary to use (cid:6) to derive ⊥from ϕ(cid:8)which would be in contradiction with the fact that Cϕ is an empowering implicate. According to Lemma 3.1 C isan empowering implicate. In particular, if C would not be empowering, then by Lemma 3.1 Cϕ would not be empoweringwith empowered literal (cid:6). (cid:2)It is also possible to prove Proposition 4.3 by analyzing a run of a CDCL SAT solver. Let us describe the sketch of suchproof, the precise definitions of the below mentioned properties can be found in [33–35]. Consider the situation duringthe run of a CDCL SAT solver solving ϕ when the partial assignment satisfies ¬Cϕ . Clearly then unit propagation is able toderive a conflict. By Proposition 3 of [34] each conflict clause can be derived by a trivial resolution derivation of length atmost s. From Proposition 2 of [33] it follows that each asserting clause is also empowering. Since for each conflict there isat least one asserting clause, e.g. 1-UIP [35], then we have found an empowering clause with a short resolution proof fromϕ.As the example in the following proposition shows, the linear upper bound on the length of resolution derivation of anempowering implicate is tight up to a multiplicative constant.Theorem 4.4. For each n there is a formula on 2n + 1 variables with size O (n) such that it is not propagation complete, but resolutionderivation of length n is needed to find an empowering implicate.Proof. This is actually a very simple corollary to Lemma 3.9. It is enough to construct a tied chain of length n. The followingformula (for given n) contains such a chain:ϕn = (z ∨ A1 ∨ a1) ∧ (a1 ∨ A2 ∨ a2) ∧ · · · ∧ (an−3 ∨ An−2 ∨ an−2)∧ (an−2 ∨ An−1 ∨ an−1) ∧ (an−1 ∨ An ∨ z).Clearly both the number of variables and the number of clauses are linear in n. First, let us observe that ( A1 ∨ A2 ∨ · · · ∨An ∨ z) is an empowering implicate with empowered literal z. This is because by falsifying all literals A1, . . . , An we geta quadratic formula which has z as a unit implicate, but unit resolution cannot derive this fact. Since the only tied chainin ϕn is composed by all the n clauses in ϕn, byLemma 3.9 we need all these clauses in order to derive an empoweringimplicate. (cid:2)Note also that formula ϕn is anti-Horn (i.e. every clause contains at most one negative literal) and thus Theorem 4.4holds also when restricted to anti-Horn or Horn formulas as we observe in the following corollary.Corollary 4.5. For each n there is a Horn formula on 2n + 1 variables with n clauses that it is not propagation complete but resolutionderivation of length n is needed to find an empowering implicate.Proof. The formula ϕn in the previous theorem had at most one negative literal in each clause. Therefore, switching allliterals to their complement in ϕn creates a Horn CNF formula with the desired property. (cid:2)The first idea which comes to mind when trying to find an empowering implicate of a CNF formula ϕ is to run resolutionuntil one such implicate is generated. Of course, if ϕ already is propagation complete, it might be necessary to find all primeM. Babka et al. / Artificial Intelligence 203 (2013) 19–3429implicates before we can claim ϕ is propagation complete. On the other hand, Proposition 4.3 suggests that in some cases,we can find an empowering implicate relatively quickly in this way. However, the obtained empowering implicate is notguaranteed to be prime. So it is natural to ask what is the necessary length of resolution derivations of prime empoweringimplicates. As the following observation shows, when seeking to find a prime empowering implicate all the hardness resultsabout resolution refutations apply in this case.Lemma 4.6. Let ϕ be a CNF formula and let x be a new variable not appearing in ϕ. Then ϕ |(cid:7) ⊥ if and only if ϕ (cid:11)1 ⊥ or x is theonly prime empowering implicate of (ϕ ∨ x). Moreover, if ϕ (cid:2)1 ⊥, then there is a one-to-one correspondence between the resolutionrefutations of ϕ and resolution derivations of x from (ϕ ∨ x).Proof. Let us denote ϕ(cid:8)every clause.the CNF formula equivalent to ϕ ∨ x. Note that ϕ(cid:8)can be obtained from ϕ by adding literal x toLet us at first suppose that ϕ |(cid:7) ⊥. In this case ϕ(cid:8) ≡ x and thus x is the only prime implicate of ϕ(cid:8). Let us assume that x. Let us now(cid:8)i with literal x removed. It is clear that D1, . . . , Dk is now a unit resolution refutation of ϕ andk be a unit resolution derivation of x from ϕ(cid:8), thus ϕ(cid:8) (cid:11)1 x. Let D(cid:8)1, . . . , D(cid:8)is not an empowering implicate of ϕ(cid:8)denote by D i the clause Dthus ϕ (cid:11)1 ⊥.Now let us assume that ϕ (cid:11)1 ⊥ or x is the only prime empowering implicate of ϕ(cid:8)the latter case observe that ϕ is equivalent to ϕ(cid:8)Moreover, the resolution proof of x from ϕ(cid:8)with x assigned to 0. Since x is an implicate of ϕ(cid:8)immediately gives resolution proof of ⊥ from ϕ.. In the former case trivially ϕ |(cid:7) ⊥. Init implies that ϕ |(cid:7) ⊥.The one-to-one correspondence is immediately seen from the above arguments. (cid:2)Lemma 4.6 is an easy observation which shows that all results about complexity of resolution refutations of CNF formulascan be repeated for resolution derivations of prime empowering implicates as well. There are many results that can be usedin this context, let us mention at least some of them. In [19] (and in many papers and books that followed) it was shownthat pigeon hole principle formulas on n(n + 1) variables and O (n3) clauses (PHPn) have minimal resolution refutation ofsize cn for some c > 0. If a formula PHPn is used with Lemma 4.6, we get immediately that every resolution derivation ofthe single prime empowering implicate x from (PHPn ∨ x) must have superpolynomial length as well. This is in contrastwith Proposition 4.3 in which we showed that for a formula which is not propagation complete there always exists someempowering implicate that can be generated using only number of resolutions that is linear in the length of the formulai.e. O (n4) for (PHPn ∨ x). Of course, in case of (PHPn ∨ x) such an implicate would not be prime.Note that in [9] the formula (PHPn ∨ x) was used in Section 4.2 as an example of a formula in which we can gener-ate superpolynomially many empowering implicates while the only meaningful empowering implicate is x. In this senseLemma 4.6 can be viewed as a simple generalization of their example, where by meaningful implicates we now considerprime implicates.The lower bound on the length of a resolution refutation of a PHPn formula is only superpolynomial with respect to thelength of the formula. Examples of formulas on Θ(n) variables consisting of Θ(n) clauses were given in [20] for which thelower bound on the length of a minimal resolution refutation is truly exponential.Although we used Lemma 4.6 for general resolution in our example, it is more general than that, it shows that infact any hardness result about resolution refutations can be used for similar results about resolution derivations of a primeempowering implicate. Thus we can consider formulas which require exponential tree resolution refutations though shortestgeneral resolution refutations have only polynomial number of steps [36]. There are other resolution refinements inbetweentree and general resolution we can take into account as well [37]. Similarly, we can use results of [38] which show formulaswith resolution refutations requiring almost linear depth, it can be observed that these formulas are even Horn. There aremany other results about resolution refutations which we have omitted but all of them could be used for claims aboutresolution derivations of prime empowering implicates as well.5. Hardness of generating an empowering implicateIn this section we prove that testing whether a given CNF formula has an empowering implicate is an NP-completeproblem. We start by showing that it is in NP.Lemma 5.1. The problem of testing whether a given CNF formula ϕ has an empowering implicate is in NP.Proof. It follows from Theorem 4.2 that ϕ has an empowering implicate if and only if it has an empowering and 1-provableimplicate. Thus the certificate for ϕ having an empowering implicate is a clause C which is both empowering and 1-provable.These properties can be checked in polynomial time using unit propagation. It follows that the problem is in NP. (cid:2)Now we shall show that the problem is NP-hard by a reduction from 3D Matching (3DM), which is a well-knownNP-complete problem [39,40]. In 3DM we are given three pairwise disjoint sets X , Y , Z of the same size | X| = |Y | = | Z | = qand a set of triples W ⊆ X × Y × Z . The question we seek to answer is whether W contains a matching of size q, i.e.30M. Babka et al. / Artificial Intelligence 203 (2013) 19–34whether there is a subset M ⊆ W of size |M| = q such that each element of X , Y , and Z is contained in exactly one triplein M (i.e. the triples in M are pairwise disjoint).Next, we present a reduction of a 3DM problem into the problem of testing the existence of an empowering implicate.The reduction is a slight modification of the proof of coNP-hardness of recognizing whether a given CNF formula is an SLURformula [41]. Unfortunately, the reduction from [41] cannot be used directly and we have to modify it. This is because theSLUR class coincides with the class of unit refutation complete formulas (see [42]), and the class of propagation completeformulas forms a strict subclass of unit refutation formulas as we have argued at the beginning of Section 3. In [41] we haveassociated a formula ϕW to an instance of 3DM for which it was true that it was SLUR (or unit refutation complete) if andonly if W contained a perfect matching. In case W does not contain a perfect matching ϕW is not unit refutation completeand thus it is not propagation complete as well. Unfortunately, the opposite implication was not true for formula ϕWconstructed in [41], i.e. if W contains a perfect matching, then ϕW is unit refutation complete, but it still not propagationcomplete. Thus we have to modify the original reduction in order to get the opposite implication as well.Definition 5.2. With every instance X, Y , Z , W of 3DM we associate a CNF formula ϕW as follows. We assume thatX = {x1, . . . , xq}, Y = { y1, . . . , yq}, Z = {z1, . . . , zq}, and W = {E 1, . . . , E w } where w = |W |. We also assume that E j =(x f ( j), y g( j), zh( j)) where f , g, and h are functions determining which elements of X , Y , and Z belong to E j (i.e. given jwith E j = [xi1 , yi2 , zi3], function f returns the index of the x member of triple E j , thus f ( j) = i1, similarly g( j) = i2, andh( j) = i3).• For every i ∈ {1, . . . , q − 1} let us denote Ai = (ai ∨ ai+1) where a1, . . . , aq are new variables, and let Aq = (aq ∨ a1).• For every i ∈ {1, . . . , q} and j ∈ {1, . . . , w} let us denote B∨ · · · ∨ bw∨ b∨ bj−1ijij+1ii ), i.e. Bji denotes aji= (b1iclause on variables b1i , . . . , bwi• For every i ∈ {1, . . . , q} and j ∈ {1, . . . , w} let us denote Cin which every literal is negative except bji= (c1iclause on variables c1i , . . . , c wi• Given a triple E j ∈ W , let D j = ( A f ( j) ∨ B(cid:3)• Finally, let ϕW =wj=1 D j .in which every literal is negative except cjh( j)).jg( j)∨ C∨ · · · ∨ bji .∨ · · · ∨ cji .j−1i∨ cji∨ cj+1i∨ · · · ∨ c wi ), i.e. Cji denotes aExample 5.3. Let X = {x1, x2, x3}, Y = { y1, y2, y3}, Z = {z1, z2, z3}, and W = {[x1, y1, z1], [x2, y3, z2], [x3, y2, z3], [x1, y2, z3],[x3, y1, z1]}. Then there are two possible matchings M1 = {[x1, y1, z1], [x2, y3, z2], [x3, y2, z3]} and M2 = {[x1, y2, z3],[x2, y3, z2], [x3, y1, z1]}.The formula ϕW for this 3DM instance would beϕW =(cid:6)a1 ∨ a2 ∨ b11(cid:6)a2 ∨ a3 ∨ b13(cid:6)a3 ∨ a1 ∨ b12(cid:6)a1 ∨ a2 ∨ b12(cid:6)a3 ∨ a1 ∨ b11∨ b21∨ b23∨ b22∨ b22∨ b21∨ b31∨ b33∨ b32∨ b32∨ b31∨ b41∨ b43∨ b42∨ b42∨ b41∨ b51∨ b53∨ b52∨ b52∨ b51∨ c11∨ c12∨ c13∨ c13∨ c11∨ c21∨ c22∨ c23∨ c23∨ c21∨ c31∨ c32∨ c33∨ c33∨ c31∨ c41∨ c42∨ c43∨ c43∨ c41∨ c51∨ c52∨ c53∨ c53∨ c51(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)∧∧∧∧.In the following, we shall show that the empowering implicates of ϕW correspond to perfect matchings of W . In partic-ular, given ϕW in this example we shall have two possible empowering implicates corresponding to matchings M1 and M2respectively.H1 =andH2 =(cid:6)a1 ∨ b1∨ b2∨ b3∨ b41111∨ c1∨ b5∨ b4∨ b3∨ b232333∨ c1∨ b5∨ b4∨ b3∨ b223222b13b12∨ b51∨ c22∨ c23∨ c11∨ c32∨ c33∨ c21∨ c42∨ c43∨ c31∨ c52∨ c53∨ c41∨(cid:7)∨ c51(cid:6)a1 ∨ b1∨ b2∨ b3∨ b42222∨ c1∨ b5∨ b4∨ b3∨ b232333∨ c1∨ b5∨ b4∨ b3∨ b211111b13b11∨ b52∨ c22∨ c21∨ c13∨ c32∨ c31∨ c23∨ c42∨ c41∨ c33∨ c52∨ c51∨ c43∨(cid:7).∨ c53∨∨We claim that ϕW admits an empowering implicate if and only if the input 3DM instance has a perfect matching. Theproof of this claim is split into the following two lemmas.Lemma 5.4. Using the notation from Definition 5.2 let M ⊆ {1, . . . , w} be a perfect matching and let G =a clause. Then G is an empowering implicate of ϕW with a1 being the empowered literal.(cid:4)j∈M Bjg( j)∨ Cjh( j)∨ a1 beM. Babka et al. / Artificial Intelligence 203 (2013) 19–3431Proof. Let us renumber the triples in W so that M = {1, . . . , q} and that f (i) = i, i.e. xi ∈ E i , for i = 1, . . . , q. Now, let usconsider the following chain of resolutions:G 1 = D1, G 2 = R(G 1, D2), . . . , G i = R(G i−1, D i), . . . , Gq = R(Gq−1, Dq).jOne can check that Gq = G and thus G is an implicate of ϕW . All clauses in this chain are resolvable because the triples inthe matching are disjoint.It remains to prove that G is empowering. Let ϕ(cid:8)denote the formula originating from ϕW by falsifying (substituting the∨j ∈ M, then we have falsified all literals in D j except A f ( j). If(cid:8)) = g( j). Such an index exists because M as a matching covers element y g( j). It follows that Bvalue false for) all literals in G except a1. We are going to show that ϕ(cid:8) ≡ A1 ∧ · · · ∧ Aq. To this end, let D j = ( A f ( j) ∨ Bh( j)) be an arbitrary clause in ϕW and let us have a look on what happens with D j after falsifying the aformentionedC(cid:8) ∈ M be an index for whichliterals. Ifjg( j(cid:8)) has two conflictjg( j) (note that j (cid:13)= jg( j(cid:8)) we necessarily satisfy the clause D j . Byvariables with Bthese considerations only clauses A1, . . . , Aq remain in ϕ(cid:8). Note that none of these clauses is missing since M is a matching.The CNF formula ϕ(cid:8) = A1 ∧ · · · ∧ Aq has no unit clauses and thus unit propagation will not derive anything from it. It followsthat G is an empowering implicate. (cid:2)) and thus by falsifying all literals in Bj /∈ M, then let jjg( j)g( j(cid:8)j(cid:8)(cid:8)Example 5.5. Let us consider implicate H 1 from Example 5.3 and let us show how it can be derived by resolutions fromformula ϕW . Implicate H1 corresponds to matching M1 = {[x1, y1, z1], [x2, y3, z2], [x3, y2, z3]}. The clauses of ϕW corre-sponding to triples in M1 are:D1 =D2 =D3 =(cid:6)a1 ∨ a2 ∨ b11(cid:6)a2 ∨ a3 ∨ b13(cid:6)a3 ∨ a1 ∨ b12∨ b21∨ b23∨ b22∨ b31∨ b33∨ b32∨ b41∨ b43∨ b42∨ b51∨ b53∨ b52∨ c11∨ c12∨ c13∨ c21∨ c22∨ c23∨ c31∨ c32∨ c33∨ c41∨ c42∨ c43∨ c51∨ c52∨ c53(cid:7)(cid:7)(cid:7),,.By resolving D1 with D2 we get clauseG 1 =(cid:6)a1 ∨ a3 ∨ b1∨ b2∨ b3111∨ c1∨ b5∨ b4∨ b32333∨ b23b13∨ b41∨ c22∨ b51∨ c32∨ c11∨ c42∨ c21∨ c52∨ c31(cid:7).∨ c41∨ c51∨By further resolving G 1 with D3 we get desired implicate H1. Observe that G 1 was produced by non-merge resolutionand thus by Lemma 3.3 it is not an empowering implicate. On the other hand H 1 = R(G 1, D3) is produced using a mergeresolution and it is hence a good candidate for an empowering implicate of ϕW . If we falsify all literals in H 1 except a1, we(cid:8)= (a3 ∨ a1) from clauses D1, D2, and D3 respectively. The remaining twoget clauses D3clauses in ϕW are satisfied by this assignment. Thus H 1 is indeed an empowering implicate of ϕW .= (a2 ∨ a3), and D= (a1 ∨ a2), D(cid:8)2(cid:8)1Lemma 5.6. Let G = Gdetermines perfect matching in the same way as G in Lemma 5.4.(cid:8) ∨ u be a prime empowering implicate of ϕW with u being the empowered literal. Then u must be a1 and G(cid:8)(cid:8) ∨ u. By Lemma 3.8Proof. The proof heavily relies on Lemma 3.8 and Lemma 3.9. Let us consider a resolution derivation of Gand Lemma 3.9 this derivation contains a tied chain in which every link literal is resolved upon. Consider how such a tiedchain in ϕW may look like. The only possible tied literal is a1, and the link literals are among a2, . . . , aq. This is because,as we can observe, the c and b variables cannot be resolved upon (if two clauses have a conflict in a c or b variable, theyare not resolvable as they have at least two conflicts). Thus a tied chain in ϕW has to look as follows: D i1 , . . . , D iq , wheref (i j) = j, i.e. D i1 contains (a1 ∨ a2), D iq contains (aq ∨ a1) or vice versa if we look at the tied chain in the opposite direction.We shall assume without loss generality that the former is the case (i.e. D i1 contains (a1 ∨ a2) and D iq contains (aq ∨ a1)).For 1 < j < q clause D i j contains (a j ∨ a j+1). The chain has to have the length q as this is necessary to get from a1 backto a1 through link literals among a2, . . . , aq. Now, if we look at how clauses D i1 , . . . , D iq can be resolved upon, we get thattriples E i1 , . . . , E iq must be disjoint to have each consecutive pair in the sequence D i1 , . . . , D iq resolvable. This is becauseif D i j , D i j+1 are resolvable, then they cannot have a conflict in any b or c variable, which implies that E i j and E i j+1 aredisjoint. We can also observe that the b and c variables cannot be cancelled out by resolution and they are therefore allitself contains all the B and C parts from D i1 , . . . , D iq and thuspresent in the resolvent. Thus, the only possibility is that GGitself determines the matching. (cid:2)(cid:8)(cid:8)Theorem 5.7. The problem of testing whether a given CNF formula has an empowering implicate is an NP-complete problem.32M. Babka et al. / Artificial Intelligence 203 (2013) 19–34Proof. The NP membership is proved in Lemma 5.1. The NP-hardness follows from the reduction defined by Definition 5.2using Lemma 5.4 and Lemma 5.6. Note that by Lemma 3.2 it is enough to consider prime empowering implicates and thusthe assumption that G is a prime implicate in Lemma 5.6 is not restrictive. (cid:2)Using the reduction from Definition 5.2, we can also show that when trying to make a CNF formula propagation com-plete, we can in general observe an exponential blow up of the number of clauses. In particular we can show that thereis a uniform and size increasing family of CNF formulas in which an exponential number of implicates has to be added toa member of this family in order to make it propagation complete. Here by “uniform” we mean that we have a uniformconstruction which constructs a formula on n variables from this family based only on a parameter n.Theorem 5.8. There is a uniform and size increasing family of CNF formulas parameterized with the number of variables n and wherethe number of clauses is O (n), such that the number of implicates that needs to be added to a CNF formula ϕ on n variables from thisfamily to make it propagation complete is exponential in n (and thus in the size of the formula, too).Proof. Let us consider an instance of 3DM where | X| = |Y | = | Z | = q and W = X × Y × Z . We claim that at least (q!)2implicates have to be added to ϕW to make it propagation complete. First, let us observe that we can find (q!)2 pairwisedifferent perfect matchings in W . This is because each perfect matching in W can be viewed as a pair of perfect matchingsin a complete bipartite graph with partities X and Y and a perfect matching in a complete bipartite graph with partities Yand Z . We have q! perfect matchings in each of these bipartite graphs and thus we have (q!)2 possible pairs of them. Note,on the other hand, that w = |W | = q3.Let M = {mr1 , mr2 , . . . , mrq}, M ⊆ W be a perfect matching. Let us denote the clauseH M = a1 ∨Brig(ri )∨ C rih(ri )(cid:7).q(cid:8)(cid:6)i=1(cid:8)(cid:8)is a different matching than M. Since M and M, we have that g(r(cid:6)) is covered by a different triple r(cid:8) \ M (cid:13)= ∅. Let r(cid:6) be an index of a triple such that mr(cid:6)From Lemma 5.4 it follows that H M is an empowering implicate. We claim that if we add H M to ϕW , then H M(cid:8) remains(cid:8)|, we have thatare different and |M| = |Mempowering provided M(cid:8) (cid:13)= ∅ and M(cid:8). Thus Br(cid:6)M \ Mg(r(cid:6)) forms a subclause of H M . Since(cid:8)(cid:8)(cid:6)) = g(r(cid:6)),. Thus Bmr(cid:6) does not belong to Mforms a subclause of H M(cid:8) . If we falsify all literals in H M(cid:8) except a1, we get that H M is satisfied, because Br(cid:6)(cid:8)(cid:6))have a conflict variable. Hence H M plays no role in unit propagation used to possibly derive a1. Whether a1 can or cannotbe derived by unit resolution from ϕW ∧ H M after falsifying the literals in H M(cid:8) except a1 is thus equivalent to whether a1can be derived by unit resolution from ϕW after falsifying the literals in H M(cid:8) except a1. Note that the above observationcan be generalized to the case when we add more than one of these matching clauses to ϕW and thus it is necessary toadd all the clauses corresponding to perfect matchings to ϕW to make it propagation complete.(cid:8)∈ M \ Mg(r(cid:6)) and BIt follows that the number of implicates needed to be added to ϕW to make it propagation complete is at least (q!)2which is exponential in the size of formula ϕW consisting of q3 clauses build on q + qw + qw = Θ(q4) variables. Family ofthe formulas defined in this, with n = Θ(q4), satisfies the proposition of the theorem. (cid:2), where g(r(cid:8)(cid:6) in M(cid:8)r(cid:6)g(r(cid:8)r(cid:6)g(r(cid:8)(cid:6))As we have already discussed in Section 2.5, the result contained in Theorem 5.8 is in tight connection to the resultsin [21] where the authors show in Corollary 4 that there is no polynomial sized CNF decomposition of any AllDifferentdomain consistency propagator. As we have mentioned in Section 2.5, the quasi-polynomial shown in [12] is based on aquasi-polynomial lower bound of Razborov [22] on the size of a monotone circuit computing whether there is a perfectmatching in a given graph. Quite interestingly, to the best of our knowledge, there is no stronger lower bound on thesize of monotone circuit computing whether a bipartite graph contains perfect matching than the quasi-polynomial shownin [22]. It is thus an interesting question whether a stronger lower bound could not be shown using the connection betweendomain consistency propagators and monotone circuits shown in [21]. Note that in the proof of Theorem 5.8 we could usea bipartite matching instead of 3DM for constructing the family of CNF formulas with required properties (we used 3DMmainly to take advantage of Lemma 5.4). Thus, it might be possible to construct a domain consistency propagator for theAllDifferent constraint which contains such a modified family of CNF formulas. On the other hand, it would still be onlyone example of a domain consistency propagator which is not enough to argue about any domain consistency propagatorfor the AllDifferent constraint.6. ConclusionsWe derived several properties of propagation complete formulas and empowering implicates. Let us now recollect theanswers to the four questions we posed in the introduction.M. Babka et al. / Artificial Intelligence 203 (2013) 19–34331. We showed that given a clause C , the problem of deciding whether C is an empowering implicate of a CNF formulaϕ is co-NP complete. This result comes as no big surprise as the hard part of this decision is answering the questionwhether C is even an implicate of ϕ and the new information brought here is that restricting the attention to thesubset of empowering implicates does not make this problem easier.2. On the other hand, if there is an empowering implicate of ϕ, there is always a 1-provable empowering implicate of ϕas stated in Theorem 4.2 which follows from Proposition 2 of [15]. It means that in this case there is always a clausefor which it is easy to show that it is an implicate of ϕ simply by unit propagation. Extending this reasoning further,we can even find an empowering implicate C , such that it can be derived by a series of resolutions of linear lengthwith respect to the number of literals occurring in a given formula (Proposition 4.3 which relates to Proposition 4 of[15] and other results in [33–35]). We also showed that this bound is tight, in some cases linear length of resolutionproof is necessary. It is important that in this case we consider a general implicate C since we also showed that if wewant to derive a prime empowering implicate C , an exponential length of resolution proof might be necessary.3. We showed that the problem in which we ask whether there is an empowering implicate for given CNF formula ϕis NP-complete, which means that checking whether given CNF formula ϕ is propagation complete is co-NP complete.Note that this strenghtens the results of [9] where the authors showed that the decision problem whether ϕ has anempowering implicate belongs to (cid:5) p2 . At a first sight we might see a slight contrast between the fact that checkingwhether given clause C is an empowering implicate of given CNF formula ϕ is co-NP complete while checking whetherthere exists an empowering implicate for a given CNF formula ϕ is NP-complete. The difference is that in the formerproblem we are given a particular clause C and it is already co-NP complete to decide whether C is an implicate ofϕ checking the empowering property is then easy. In the latter case we are given only a CNF formula ϕ and thus wemay look for special empowering implicates, in particular the 1-provable ones. Checking whether a given clause C is1-provable empowering implicate of ϕ is then polynomial and the hard part is to find one.4. Finally, we showed that there is a uniform and size increasing family of CNF formulas such that given CNF formula ϕfrom this family we have to add an exponential number of empowering implicates to make it propagation complete.This result strenghtens a quasi-polynomial bound which follows from the results of [21] and the connection betweenCNF decompositions of domain consistency propagators in CSP.It remains an interesting question whether a similar result can be obtained for different representations of proposi-tional formulas, such as ZBDD (zero-suppressed binary decision diagrams [43,44], see e.g. [45] for use in propositionalformula representation). In particular it may be interesting to investigate, whether the family of formulas defined inTheorem 5.8 requires an exponentially sized ZBDD to represent its propagation complete counterpart. We leave thisquestion for further research. We can consider other representations as well, see e.g. [17] for a comprehensive list ofvarious representations used in knowledge compilation.AcknowledgementsThe authors thank four anonymous referees for their valuable comments that helped to improve the paper. The first,the second, the fourth, and the sixth author gratefully acknowledge the support of the Charles University Grant Agency(grant Nos. 266111, 265511, and 600112). The third and fifth author thankfully acknowledge a support by the Czech ScienceFoundation (grant P202/10/1188).References[1] J. Franco, A. Van Gelder, A perspective on certain polynomial-time solvable classes of satisfiability, Discrete Appl. Math. 125 (2–3) (2003) 177–214.[2] J.S. Schlipf, F.S. Annexstein, J.V. Franco, R.P. Swaminathan, On finding solutions for extended horn formulas, Inform. Process. Lett. 54 (3) (1995) 133–137.[3] M. Davis, G. Logemann, D. Loveland, A machine program for theorem-proving, Commun. ACM 5 (7) (1962) 394–397.[4] A. Darwiche, K. Pipatsrisawat, Complete algorithms, in: A. Biere, M. Heule, H. van Maaren, T. Walsh (Eds.), Handbook of Satisfiability, in: Frontiers inArtificial Intelligence and Applications, vol. 185, IOS Press, 2009, pp. 99–130.[5] J.P. Marques-Silva, K.A. Sakallah, Grasp: A search algorithm for propositional satisfiability, IEEE Trans. Comput. 48 (5) (1999) 506–521.[6] M.W. Moskewicz, C.F. Madigan, Y. Zhao, L. Zhang, S. Malik, Chaff: Engineering an efficient sat solver, in: Proceedings of the 38th Annual DesignAutomation Conference, ACM, 2001, pp. 530–535.[7] J.P. Marques-Silva, A.K. Sakallah, GRASP — a new search algorithm for satisfiability, in: Proceedings of the 1996 IEEE/ACM International Conference onComputer-Aided Design, ICCAD ’96, IEEE Computer Society, Washington, DC, USA, 1996, pp. 220–227.[8] J.P.M. Silva, I. Lynce, S. Malik, Conflict-driven clause learning sat solvers, in: A. Biere, M. Heule, H. van Maaren, T. Walsh (Eds.), Handbook of Satisfiability,in: Frontiers in Artificial Intelligence and Applications, vol. 185, IOS Press, 2009, pp. 131–153.[9] L. Bordeaux, J. Marques-Silva, Knowledge compilation with empowerment, in: M. Bieliková, G. Friedrich, G. Gottlob, S. Katzenbeisser, G. Turán (Eds.),SOFSEM 2012: Theory and Practice of Computer Science, in: Lecture Notes in Computer Science, vol. 7147, Springer-Verlag, Berlin, Heidelberg, 2012,pp. 612–624.[10] F. Bacchus, GAC via unit propagation, in: C. Bessière (Ed.), Principles and Practice of Constraint Programming – CP 2007, in: Lecture Notes in ComputerScience, vol. 4741, Springer-Verlag, Berlin, Heidelberg, 2007, pp. 133–147.[11] J. Huang, Universal booleanization of constraint models, in: P.J. Stuckey (Ed.), Principles and Practice of Constraint Programming, in: Lecture Notes inComputer Science, vol. 5202, Springer-Verlag, Berlin, Heidelberg, 2008, pp. 144–158.[12] C. Bessiere, G. Katsirelos, N. Narodytska, C.-G. Quimper, T. Walsh, Decompositions of all different, global cardinality and related constraints, in: Pro-ceedings of the 21st International Joint Conference on Artificial Intelligence, IJCAI’09, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2009,pp. 419–424.[13] S. Brand, N. Narodytska, C.-G. Quimper, P. Stuckey, T. Walsh, Encodings of the sequence constraint, in: Proceedings of the 13th International Conferenceon Principles and Practice of Constraint Programming, CP’07, Springer-Verlag, Berlin, Heidelberg, 2007, pp. 210–224.34M. Babka et al. / Artificial Intelligence 203 (2013) 19–34[14] C.-G. Quimper, T. Walsh, Decompositions of grammar constraints, in: Proceedings of the 23rd National Conference on Artificial Intelligence, vol. 3,AAAI’08, AAAI Press, 2008, pp. 1567–1570.[15] K. Pipatsrisawat, A. Darwiche, On the power of clause-learning sat solvers as resolution engines, Artificial Intelligence 175 (2) (2011) 512–525.[16] P. Marquis, Knowledge compilation using theory prime implicates, in: Proceedings of the 14th International Joint Conference on Artificial Intelligence,vol. 1, IJCAI’95, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1995, pp. 837–843.[17] A. Darwiche, P. Marquis, A knowledge compilation map, J. Artificial Intelligence Res. 17 (1) (2002) 229–264.[18] P. Marquis, S. Sadaoui, A new algorithm for computing theory prime implicates compilations, in: Proceedings of the Thirteenth National Conference onArtificial Intelligence, vol. 1, AAAI’96, AAAI Press, 1996, pp. 504–509.[19] A. Haken, The intractability of resolution, Theoret. Comput. Sci. 39 (0) (1985) 297–308.[20] A. Urquhart, Hard examples for resolution, J. ACM 34 (1) (1987) 209–219.[21] C. Bessiere, G. Katsirelos, N. Narodytska, T. Walsh, Circuit complexity and decompositions of global constraints, in: Proceedings of the 21st InternationalJoint Conference on Artificial Intelligence, IJCAI’09, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2009, pp. 412–418.[22] A.A. Razborov, Lower bounds on monotone complexity of some boolean functions, Dokl. Akad. Nauk SSSR 281 (4) (1985) 789–801.[23] M.R. Genesereth, N.J. Nilsson, Logical Foundations of Artificial Intelligence, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1987.[24] H.K. Büning, T. Lettmann, Propositional Logic: Deduction and Algorithms, Cambridge University Press, New York, NY, USA, 1999.[25] M. Dalal, D.W. Etherington, A hierarchy of tractable satisfiability problems, Inform. Process. Lett. 44 (4) (1992) 173–180.[26] A. del Val, Tractable databases: How to make propositional unit resolution complete through compilation, in: J. Doyle, E. Sandewall, P. Torassi (Eds.),Proceedings of Fourth International Conference on Principles of Knowledge Representation and Reasoning, KR’94, Morgan Kaufmann, 1994, pp. 551–561.[27] A. Atserias, J.K. Fichte, M. Thurley, Clause-learning algorithms with many restarts and bounded-width resolution, in: Proceedings of the 12th Interna-tional Conference on Theory and Applications of Satisfiability Testing, SAT’09, Springer-Verlag, Berlin, Heidelberg, 2009, pp. 114–127.[28] F. Rossi, P.v. Beek, T. Walsh, Handbook of Constraint Programming, Foundations of Artificial Intelligence, Elsevier Science Inc., New York, NY, USA, 2006.[29] C. Bessière, E. Hebrard, T. Walsh, Local consistencies in SAT, in: E. Giunchiglia, A. Tacchella (Eds.), Theory and Applications of Satisfiability Testing, in:Lecture Notes in Computer Science, vol. 2919, Springer, Berlin, Heidelberg, 2004, pp. 299–314, http://dx.doi.org/10.1007/978-3-540-24605-3_23.[30] C. Schulte, P. Stuckey, Speeding up constraint propagation, in: M. Wallace (Ed.), Principles and Practice of Constraint Programming – CP 2004, in:Lecture Notes in Computer Science, vol. 3258, Springer, Berlin, Heidelberg, 2004, pp. 619–633, http://dx.doi.org/10.1007/978-3-540-30201-8_45.[31] J.-C. Régin, A filtering algorithm for constraints of difference in CSPs, in: Proceedings of the Twelfth National Conference on Artificial Intelligence, vol. 1,AAAI ’94, American Association for Artificial Intelligence, Menlo Park, CA, USA, 1994, pp. 362–367.[32] K. Eshghi, A tractable class of abduction problems, in: Proceedings of the 13th International Joint Conference on Artificial intelligence, vol. 1, IJCAI’93,Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1993, pp. 3–8.[33] K. Pipatsrisawat, A. Darwiche, A new clause learning scheme for efficient unsatisfiability proofs, in: Proceedings of the 23rd National Conference onArtificial Intelligence, vol. 3, AAAI’08, AAAI Press, 2008, pp. 1481–1484.[34] P. Beanie, H. Kautz, A. Sabharwal, Understanding the power of clause learning, in: Proceedings of the 18th International Joint Conference on ArtificialIntelligence, IJCAI’03, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2003, pp. 1194–1201.[35] L. Zhang, C.F. Madigan, M.H. Moskewicz, S. Malik, Efficient conflict driven learning in a boolean satisfiability solver, in: Proceedings of the 2001IEEE/ACM International Conference on Computer-Aided Design, ICCAD ’01, IEEE Press, Piscataway, NJ, USA, 2001, pp. 279–285.[36] E. Ben-Sasson, R. Impagliazzo, A. Wigderson, Near optimal separation of tree-like and general resolution, Combinatorica 24 (4) (2004) 585–603.[37] J. Buresh-Oppenheim, T. Pitassi, The complexity of resolution refinements, in: Proceedings of the 18th Annual IEEE Symposium, Logic in ComputerScience, 2003, 2003, pp. 138–147, http://dx.doi.org/10.1109/LICS.2003.1210053.[38] A. Urquhart, The depth of resolution proofs, Stud. Log. 99 (1–3) (2011) 349–364.[39] R.M. Karp, Reducibility among combinatorial problems, in: R.E. Miller, J.W. Thatcher (Eds.), Complexity of Computer Computations, Plenum Press, 1972,pp. 85–103.[40] M. Garey, D. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W.H. Freeman and Company, San Francisco, 1979.[41] O. ˇCepek, P. Kuˇcera, V. Vlˇcek, Properties of SLUR formulae, in: M. Bieliková, G. Friedrich, G. Gottlob, S. Katzenbeisser, G. Turán (Eds.), SOFSEM 2012:Theory and Practice of Computer Science, in: Lecture Notes in Computer Science, vol. 7147, Springer-Verlag, Berlin, Heidelberg, 2012, pp. 177–189.[42] M. Gwynne, O. Kullmann, Generalising unit-refutation completeness and SLUR via nested input resolution, http://arxiv.org/abs/1204.6529.[43] S. Minato, Zero-suppressed BDDs for set manipulation in combinatorial problems, in: 30th Conference on Design Automation, 1993, 1993, pp. 272–277.[44] S.-i. Minato, Zero-suppressed BDDs and their applications, Int. J. Softw. Tools Technol. Transf. (STTT) 3 (2) (2001) 156–170.[45] P. Chatalic, L.S. Zres, The old Davis–Putnam procedure meets ZBDD, in: D. McAllester (Ed.), Automated Deduction – CADE-17, in: Lecture Notes inComputer Science, vol. 1831, Springer, Berlin, Heidelberg, 2000, pp. 449–454, http://dx.doi.org/10.1007/10721959_35.