Artificial Intelligence 175 (2011) 278–298Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintSemantics and complexity of recursive aggregates in answer setprogramming ✩Wolfgang Faber∗, Gerald Pfeifer, Nicola LeoneDepartment of Mathematics, University of Calabria, 87030 Rende (CS), Italya r t i c l ei n f oa b s t r a c tArticle history:Available online 3 April 2010Keywords:Nonmonotonic reasoningAnswer set programmingAggregatesComputational complexityThe addition of aggregates has been one of the most relevant enhancements to thelanguage of answer set programming (ASP). They strengthen the modelling power of ASPin terms of natural and concise problem representations. Previous semantic definitionstypically agree in the case of non-recursive aggregates, but the picture is less clear foraggregates involved in recursion. Some proposals explicitly avoid recursive aggregates, mostothers differ, and many of them do not satisfy desirable criteria, such as minimality orcoincidence with answer sets in the aggregate-free case.In this paper we define a semantics for programs with arbitrary aggregates (includingmonotone, antimonotone, and nonmonotone aggregates) in the full ASP language allowingalso for disjunction in the head (disjunctive logic programming — DLP). This semantics isa genuine generalization of the answer set semantics for DLP, it is defined by a naturalvariant of the Gelfond–Lifschitz transformation, and treats aggregate and non-aggregateliterals in a uniform way. This novel transformation is interesting per se also in theaggregate-free case, since it is simpler than the original transformation and does notneed to differentiate between positive and negative literals. We prove that our semanticsguarantees the minimality (and therefore the incomparability) of answer sets, and wedemonstrate that it coincides with the standard answer set semantics on aggregate-freeprograms.Moreover, we carry out an in-depth study of the computational complexity of the language.The analysis pays particular attention to the impact of syntactical restrictions on programsin the form of limited use of aggregates, disjunction, and negation. While the addition ofaggregates does not affect the complexity of the full DLP language, it turns out that theirpresence does increase the complexity of normal (i.e., non-disjunctive) ASP programs up tothe second level of the polynomial hierarchy. However, we show that there are large classesof aggregates the addition of which does not cause any complexity gap even for normalprograms, including the fragment allowing for arbitrary monotone, arbitrary antimonotone,and stratified (i.e., non-recursive) nonmonotone aggregates. The analysis provides someuseful indications on the possibility to implement aggregates in existing reasoning engines.© 2010 Elsevier B.V. All rights reserved.✩Parts of this work have been published in preliminary form in the proceedings of the conferences JELIA’04 (Faber et al. (2004) [1]) and IJCAI’05 (Calimeriet al. (2005) [2]).* Corresponding author.E-mail addresses: faber@mat.unical.it (W. Faber), gerald@pfeifer.com (G. Pfeifer), leone@mat.unical.it (N. Leone).0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.04.002W. Faber et al. / Artificial Intelligence 175 (2011) 278–2982791. IntroductionAround 1960, McCarthy proposed the use of logical formulas as a basis for a knowledge representation language [3,4]. Itwas soon realized, however, that classical logic is not always adequate to model commonsense reasoning [5]. As an alterna-tive, it has been suggested to represent commonsense reasoning using logical languages with nonmonotonic consequencerelations, which allow new knowledge to invalidate some of the previous conclusions. This observation has led to the de-velopment and investigation of new logical formalisms, nonmonotonic logics. The most famous of these are circumscription[6,7], default logic [8], and nonmonotonic modal logics [9–11]. More recently, from cross fertilizations between the field ofnonmonotonic logics and that of logic programming, another nonmonotonic language, called Answer Set Programming (ASP)[12,13], has emerged.Answer Set Programs [12,13], also called Disjunctive Logic Programs (DLP) [14], are logic programs where (nonmonotonic)negation may occur in the bodies, and disjunction may occur in the heads of rules. This language is very expressive in aprecise mathematical sense: it allows to express every property of finite structures that is decidable in the complexity class2 (NPNP) [15]. The high expressive power of the language, along with its simplicity, and the availability of a numberΣ Pof efficient ASP systems [16–23], has encouraged the usage of ASP and the investigation of new constructs enhancing itscapabilities. One of the most relevant improvements to the language of answer set programming has been the addition ofaggregates [24–37].Aggregates significantly enhance the language of answer set programming (ASP), allowing for natural and concise mod-elling of many problems. Non-recursive (also called stratified) aggregates have clear semantics and capture a large classof meaningful problem specifications. However, there are relevant problems for which recursive (unstratified) aggregateformulations are natural; the Company Control problem, illustrated next, is a typical example, cf. [24–26,29].Example 1.1. We are given a set of facts for predicate company( X), denoting the companies involved, and a set of facts forpredicate ownsStk(C 1, C 2, Perc), denoting the percentage of shares of company C 2, which is owned by company C 1. Then,company C 1 controls company C 2 if the sum of the shares of C 2 owned either directly by C 1 or by companies, which arecontrolled by C 1, is more than 50%. This problem has been encoded as the following program Pctrl by many authors in theliterature [24–26,29].1controlsStk(C 1, C 1, C 2, P ):-ownsStk(C 1, C 2, P ).controlsStk(C 1, C 2, C 3, P ):-company(C 1), controls(C 1, C 2), ownsStk(C 2, C 3, P ).controls(C 1, C 3):-company(C 1), company(C 3),(cid:2)#sum(cid:3)P , C 2 : controlsStk(C 1, C 2, C 3, P )> 50.Intuitively, controlsStk(C 1, C 2, C 3, P ) denotes that company C 1 controls P percent of C 3 shares “through” company C 2(as C 1 controls C 2, and C 2 owns P percent of C 3 shares). Predicate controls(C 1, C 2) encodes that company C 1 controlscompany C 2. For two companies, say, c1 and c3, controls(c1, c3) is derived if the sum of the elements in the multiset{{P | ∃C 2 : controlsStk(c1, C 2, c3, P )}} is greater than 50. Note that in the adopted DLV syntax this multiset is expressed by{P , C 2 : controlsStk(c1, C 2, c3, P )} where the variable C 2 avoids that duplicate occurrences of P are eliminated.The encoding of Company Control contains a recursive aggregate (since predicate controlsStk in the aggregate depends onthe head predicate controls). Unfortunately, however, recursive aggregates are not easy to handle, and their semantics is notalways straightforward.Example 1.2. Consider the following two programs:(cid:2)(cid:2)p(a):-#count(cid:3)X : p(X)(cid:3)> 0.P 1 :(cid:2)(cid:2)p(a):-#count(cid:3)X : p(X)(cid:3)< 1.P 2 :In both cases p(a) is the only atom for p which might be true, so, intuitively, following the closed-world assumption, onemay expect that #count{ X : p( X)} > 0 is true iff p(a) is true; while #count{ X : p( X)} < 1 should be true iff p(a) is false.Thus, the above programs should, respectively, behave like the following standard programs:(cid:2)(cid:3)p(a):-p(a).(cid:4)1P:(cid:2)(cid:3)p(a):-not p(a).(cid:4)2P:This is not always the case in the literature, and there is a debate on the best semantics for recursive aggregates.There have been several attempts for defining a suitable semantics for recursive aggregates [25,27–30,34–37]. However,while previous semantic definitions typically agree in the non-recursive case, the picture is not so clear for recursion. Some1 Throughout this paper, we adopt the concrete syntax of the DLV language [38] to express aggregates in the examples.280W. Faber et al. / Artificial Intelligence 175 (2011) 278–298proposals explicitly avoid recursive aggregates, many others differ, and several of them do not satisfy desirable criteria, suchas minimality.2 For a more detailed analysis we refer to Section 5.In this paper, we make a step forward and provide a fully declarative semantics which works for disjunctive programsand arbitrary aggregates. Moreover, we carry out an in-depth analysis of the computational complexity of ASP with aggre-gates, which pays particular attention to the impact of syntactical restrictions on programs in the form of limited use ofaggregates, disjunction, and negation.The main contributions of the paper are the following:• We provide a definition of the answer set semantics for disjunctive programs with arbitrary aggregates (includingmonotone aggregates, antimonotone aggregates, and aggregates which are neither monotone nor antimonotone). Thissemantics is fully declarative and is given in the standard way for answer sets, by a generalization of the well-knownGelfond–Lifschitz transformation, which treats aggregate and non-aggregate literals in a uniform way. This novel trans-formation is interesting per se also in the aggregate-free case, since it is simpler than the original transformation anddoes not differentiate between the types of literals (positive and negative) in the program. Interestingly, the generalityof this transformation allows for defining the semantics of arbitrary linguistic extensions of ASP, and has already beenapplied also in other contexts (see Section 5).• We study the properties of the proposed semantics, and show the following results:◦ Our answer sets are subset-minimal models, and therefore they are incomparable to each other, which is generallyseen as an important property of nonmonotonic semantics [32,29].◦ For aggregate-free programs, our semantics coincides with the standard answer set semantics.◦ From a semantic viewpoint, monotone aggregate literals are analogous to positive standard literals, while antimono-tone aggregates are analogous to negative standard literals. We provide a rewriting from standard logic programswith negation to positive programs with antimonotone aggregate atoms.• We carry out an in-depth analysis of the computational complexity of disjunctive programs with polynomial-time com-putable aggregate functions and fragments thereof, deriving a full picture of the complexity of the ASP languages wherenegation and/or disjunction are combined with the different kinds of aggregates (monotone, antimonotone, nonmono-tone, stratified).3 The analysis brings many interesting results, including the following:◦ The addition of aggregates does not increase the complexity of the full ASP language. Cautious reasoning on full ASPprograms (with disjunction and negation) including all considered types of aggregates (monotone, antimonotone, andnonmonotone) even unstratified, remains Π P2 -complete, as for standard DLP.◦ The “cheapest” aggregates, from the complexity viewpoint, are the monotone ones, the addition of which does nevercause any complexity increase, even for negation-free programs, and even for unstratified monotone aggregates.◦ The “hardest” aggregates, from the complexity viewpoint, are the nonmonotone ones: even on non-disjunctive pos-itive programs (definite horn clauses), their addition causes a big complexity jump from P up to Π P2 . Instead,antimonotone aggregates behave like negation: on non-disjunctive positive programs their presence increases thecomplexity from P to co-NP.◦ The largest set of aggregates which can be added to non-disjunctive ASP without inducing a complexity overheadconsists of arbitrary monotone, arbitrary antimonotone, and stratified nonmonotone aggregates. When adding thesekinds of aggregates to non-disjunctive ASP, the complexity of reasoning remains in co-NP.Importantly, the above mentioned complexity results give us valuable information about intertranslatability of differ-ent languages, having relevant implications also on the possibility to implement aggregates in existing reasoning engines,or using rewriting-based techniques (like those employed in ASSAT [39] or Cmodels [20]) for their implementation (seeSection 4.2).The sequel of the paper is organized as follows. Section 2 defines the syntax and the formal semantics, based on theAnotion of answer set, of DLP;while Section 4 carries out the computational complexity analysis, and Section 5 discusses related work. Section 6 drawsour conclusion.— our extension of DLP with aggregates. Section 3 studies the semantic properties of DLPA2. The DLPAlanguageIn this section, we provide a formal definition of the syntax and semantics of the DLPlanguage — an extension ofDisjunctive Logic Programming (DLP) by set-oriented functions (also called aggregate functions). For further background onDLP, we refer to [13,18].A2 The subset-minimality of answer sets, which holds in the aggregate-free case and for the main nonmonotonic logics [31], also guarantees that answersets are incomparable, and allows to define the transitive closure — which becomes impossible if minimality is lost [29].3 Note that the results mentioned here refer to the complexity of propositional programs. In Section 4.2, however, we discuss also the complexity ofnon-ground programs.W. Faber et al. / Artificial Intelligence 175 (2011) 278–2982812.1. SyntaxWe assume sets of variables, constants, and predicates to be given. Similar to Prolog, we assume variables to be stringsstarting with uppercase letters and constants to be integers or strings starting with lowercase letters. Predicates are stringsstarting with lowercase letters or symbols such as =, <, > (so-called built-in predicates that have a fixed meaning). Anarity (non-negative integer) is associated with each predicate.Standard atoms and literals. A term is either a variable or a constant. A standard atom is an expression p(t1, . . . , tn), where pis a predicate of arity n and t1, . . . , tn are terms. A standard literal L is either a standard atom A (in this case, it is positive)or a standard atom A preceded by the default negation symbol not (in this case, it is negative). A conjunction of standardliterals is of the form L1, . . . , Lk where each Li (1 (cid:2) i (cid:2) k) is a standard literal.An expression (e.g. standard atom, standard literal, conjunction) is ground, if neither the expression itself nor any of itssubexpressions contain variables.A) set term is either a symbolic set or a ground set. A symbolic set is a pair {Vars : Conj}, where Vars is aSet terms. A (DLPlist of variables and Conj is a conjunction of standard atoms.4 A ground set is a set of pairs of the form (cid:6)t : Conj(cid:7), where t isa list of constants and Conj is a ground (variable free) conjunction of standard atoms.Aggregate functions. An aggregate function is of the form f (S), where S is a set term, and fis an aggregate function symbol.Intuitively, an aggregate function can be thought of as a (possibly partial) function mapping multisets5 of constants to aconstant.Example 2.1. The following aggregate functions are quite common, and currently supported also by the DLV system: #min(minimal term, undefined for empty set), #max (maximal term, undefined for empty set), #count (number of terms),#sum (sum of integers), and #times (product of integers).Aggregate literals. An aggregate atom is f (S)◦T , where f (S) is an aggregate function, ◦ ∈ {=, <, (cid:2), >, (cid:3), (cid:9)=} is a comparisonoperator, and T is a term (variable or constant).We note that our choice for the notation of aggregate atoms is primarily motivated by readability. One could defineaggregate atoms as an arbitrary relation over a sequence of aggregate functions and terms. In fact, aggregates in DLV andcardinality and weight constraints for Smodels can be of the form T ◦ f (S)◦U , but semantically this is a shorthand for theconjunction of T ◦ f (S) and f (S)◦U .Example 2.2. The following are aggregate atoms in DLV notation, where the latter contains a ground set and could be aground instance of the former:(cid:3)Z : r(Z ), a(Z , V )(cid:5)(cid:2)(cid:4)2 : r(2), a(2, x)> Y .2 : r(2), a(2, y)(cid:2)#max#max> 1.(cid:5)(cid:3),(cid:4)An atom is either a standard (DLP) atom or an aggregate atom. A literal L is an atom A or an atom A preceded by thedefault negation symbol not; if A is an aggregate atom, L is an aggregate literal.ADLPprograms. A (DLPA) rule r is a constructa1 ∨ · · · ∨ an:-b1, . . . , bk, not bk+1, . . . , not bm,where a1, . . . , an are standard atoms, b1, . . . , bm are atoms, and n (cid:3) 0, m (cid:3) k (cid:3) 0, n + m > 0. The disjunction a1 ∨ · · · ∨ an isreferred to as the head of r, while the conjunction b1, . . . , bk, not bk+1, . . . , not bm is the body of r. Let H(r) = {a1, . . . , an},−(r). Furthermore let P red(σ ) denote the set of+(r) = {b1, . . . , bk}, BBpredicates that occur in σ , where σ may be a program, a rule, a set of atoms or literals, an atom or a literal. Whenever it isAclear that this set has one element (for standard atoms and literals), Pred(σ ) may also denote a single predicate. A (DLP)program is a set of DLP−(r) = {not bk+1, . . . , not bm}, and B(r) = B+(r) ∪ Brules.A2.1.1. Syntactic propertiesA local variable of r is a variable appearing solely in an aggregate function in r; a variable of r which is not local iscalled global. A nested atom of r is an atom appearing in an aggregate atom of r; an atom of r which is not nested is calledunnested.4 Intuitively, a symbolic set { X : a( X, Y ), p(Y )} stands for the set of X -values making a( X, Y ), p(Y ) true, i.e., { X | ∃Y s.t. a( X, Y ), p(Y ) is true}.5 Note that aggregate functions are evaluated on the valuation of a (ground) set w.r.t. an interpretation, which is a multiset, cf. Section 2.2.282W. Faber et al. / Artificial Intelligence 175 (2011) 278–298Definition 2.1 (Safety). A rule r is safe if the following conditions hold:(i) each global variable of r appears in a positive standard unnested literal of the body of r;(ii) each local variable of r that appears in a symbolic set {Vars : Conj} also appears in Conj. Finally, a program is safe if allof its rules are safe.Condition (i) is the standard safety condition adopted in datalog, to guarantee that the variables are range restricted [40],while Condition (ii) is specific for aggregates.p(X):-q(X, Y , V ),Example 2.3. Consider the following rules:(cid:2)Y < #max(cid:2)Y < #sum(cid:2)T < #minp(X):-q(X, Y , V ),p(X):-q(X, Y , V ),(cid:3)Z : r(Z ), a(Z , V )(cid:3)Z : a(X, S)(cid:3)Z : r(Z ), a(Z , V )...The first rule is safe, while the second is not, since local variables Z violates condition (ii). The third rule is not safe either,since the global variable T violates condition (i).Definition 2.2 (Aggregate-stratification). A DLP(cid:12) (cid:12) from Pred(P) to ordinals, such that for each rule r ∈ P and for each a ∈ Pred(H(r)) the following holds:program P is stratified on an aggregate atom A if there exists a level mappingA(1) For each b ∈ Pred(B(r)): (cid:12)b(cid:12) (cid:2) (cid:12)a(cid:12),(2) if A ∈ B(r), then for each b ∈ Pred( A): (cid:12)b(cid:12) < (cid:12)a(cid:12), and(3) for each b ∈ Pred(H(r)): (cid:12)b(cid:12) = (cid:12)a(cid:12).AA DLPprogram P is aggregate-stratified if it is stratified on all aggregate atoms in P .Intuitively, aggregate-stratification forbids recursion through aggregates. While the semantics of aggregate-stratified pro-grams is more or less agreed upon, different and disagreeing semantics for aggregate-unstratified programs have beendefined in the past, see for instance the discussion in [29]. In this paper we shall provide a novel characterization whichdirectly extends well-known formulations of semantics for aggregate-free programs.Example 2.4. Consider the program consisting of a set of facts for predicates a and b, plus the following two rules:(cid:2)q(X):-p(X), #count(cid:3)Y : a(Y , X), b(X)(cid:2) 2.p(X):-q(X), b(X).The program is stratified on #count{Y : a(Y , X), b( X)} (cid:2) 2, as the level mapping (cid:12)a(cid:12) = (cid:12)b(cid:12) = 1, (cid:12)p(cid:12) = (cid:12)q(cid:12) = 2 satisfies therequired conditions. The program is therefore aggregate-stratified.If we add the rule b( X):-p( X), then no such level-mapping exists and the program becomes aggregate-unstratified.Definition 2.3 (Negation-stratification). A program P is called negation-stratified [41,42], if there exists a level mapping (cid:12) (cid:12)nfor Pred(P) such that for each rule r ∈ P and for each a ∈ Pred(H(r)) the following holds:(1) For each b ∈ Pred(B(r)): (cid:12)b(cid:12) (cid:2) (cid:12)a(cid:12),(2) for each standard literal L ∈ B(3) for each b ∈ Pred(H(r)): (cid:12)b(cid:12) = (cid:12)a(cid:12).−(r): (cid:12)Pred(L)(cid:12) < (cid:12)a(cid:12), andWe note that when dealing with ground programs, one can consider a program in which each ground standard atomis replaced by a unique predicate with arity 0. This program is clearly equivalent to the original program, modulo therenaming. One can then consider the rewritten program for determining aggregate- and negation-stratification.Example 2.5. Consider the following ground program:p(a):-not p(b).p(a):-#countc : p(c)> 0.(cid:2)(cid:4)(cid:5)(cid:3)While it is neither aggregate-stratified nor negation-stratified according to the definition, as it only considers the predicatesymbol p, its renamed variantpa:-not pb.(cid:2)pa:-#count(cid:3)(cid:6)c : pc(cid:7)> 0.is, however, aggregate-stratified and negation-stratified, and so we may consider also the original program as beingaggregate-stratified and negation-stratified.W. Faber et al. / Artificial Intelligence 175 (2011) 278–2982832.2. Semanticsprogram P , let U P denote the set of constants appearing in P , and BP the set ofUniverse and base. Given a DLPstandard atoms constructible from the (standard) predicates of P with constants in U P . Given a set X , let 2 X denote theset of all multisets over elements from X . Without loss of generality, we assume that aggregate functions map to Z (the setof integers).AExample 2.6. Let us look at common domains for the aggregate functions of Example 2.1: #count is defined over 2U P ,#sum over 2, #min and #max are defined over 2, #times over 2Z \ {∅}.ZZInstantiation. A substitution is a mapping from a set of variables to U P . A substitution from the set of global variables ofa rule r (to U P ) is a global substitution for r; a substitution from the set of local variables of a symbolic set S (to U P ) is alocal substitution for S. Given a symbolic set without global variables S = {Vars : Conj}, the instantiation of S is the followingground set of pairs inst(S):(cid:5) (cid:6)(cid:6) γ is a local substitution for Sγ (Vars) : γ (Conj)(cid:3).6(cid:2)(cid:4)A ground instance of a rule r is obtained in two steps: (1) a global substitution σ for r is first applied over r; (2) everysymbolic set S in σ (r) is replaced by its instantiation inst(S). The instantiation Ground(P) of a program P is the set of allpossible instances of the rules of P .Example 2.7. Consider the following program P1:q(1) ∨ p(2, 2).q(2) ∨ p(2, 1).t(X):-q(X), #sum(cid:2)(cid:3)Y : p(X, Y )> 1.Here U P1= {1, 2} and the instantiation Ground(P1) is the following:q(1) ∨ p(2, 2).q(2) ∨ p(2, 1).t(1):-q(1), #sumt(2):-q(2), #sum(cid:4)(cid:2)(cid:4)(cid:2)(cid:4)(cid:5)1 : p(1, 1)(cid:5)1 : p(2, 1)(cid:4),,2 : p(1, 2)2 : p(2, 2)(cid:5)(cid:3)(cid:5)(cid:3)> 1.> 1.program P is a set of standard ground atoms I ⊆ BP . A standard ground atomInterpretation. An interpretation for a DLPa is true w.r.t. an interpretation I , denoted I |(cid:15) a, if a ∈ I ; otherwise it is false w.r.t. I . A standard ground literal not a istrue w.r.t. an interpretation I , denoted I |(cid:15) not a, if I (cid:9)|(cid:15) a, otherwise it is false w.r.t. I .AAn interpretation also provides a meaning to (ground) sets, aggregate functions and aggregate literals, namely a multiset,a value, and a truth value, respectively. Let f (S) be an aggregate function. The valuation I(S) of S w.r.t. I is the multisetI(S) defined as follows: Let S I = {(cid:6)t1, . . . , tn(cid:7) | (cid:6)t1, . . . , tn : Conj(cid:7) ∈ S ∧ Conj is true w.r.t. I}, then I(S) is the multiset obtainedas the projection of the tuples of S I on their first constant, that is I(S) = {{t1 | (cid:6)t1, . . . , tn(cid:7) ∈ S I }}.The valuation I( f (S)) of an aggregate function f (S) w.r.t. I is the result of the application of f 7 on I(S). If the multisetI(S) is not in the domain of f , I( f (S)) = ⊥ (where ⊥ is a fixed symbol not occurring in P ).An instantiated aggregate atom A = f (S)◦k is true w.r.t. an interpretation I , denoted I |(cid:15) A if: (i) I( f (S)) (cid:9)= ⊥, and, (ii)I( f (S))◦k holds8; otherwise, A is false. An instantiated aggregate literal not A = not f (S)◦k is true w.r.t. an interpretationI , denoted I |(cid:15) not A, if (i) I( f (S)) (cid:9)= ⊥, and, (ii) I( f (S))◦k does not hold; otherwise, not A is false.Example 2.8. Let I be the interpretation { f (1), g(1, 2), g(1, 3), g(1, 4), g(2, 4), h(2), h(3), h(4)}. With respect to the inter-pretation I , and assuming that all variables are local, we can check that:– #count{ X : g( X, Y )} > 2 is false, because S Ifor the corresponding ground set is {(cid:6)1(cid:7), (cid:6)2(cid:7)}, so I(S) = {{1, 2}} and– #count{ X, Y : g( X, Y )} > 2 is true, because here S I = {(cid:6)1, 2(cid:7), (cid:6)1, 3(cid:7), (cid:6)1, 4(cid:7), (cid:6)2, 4(cid:7)},I(S) = {{1, 1, 1, 2}} and– 23 < #times{Y :f ( X), g( X, Y )} (cid:2) 24 istrue;in thiscaseS I = {(cid:6)2(cid:7),(cid:6)3(cid:7),(cid:6)4(cid:7)},I(S) = {{2, 3, 4}} and– #sum{ A : g( A, B), h(B)} (cid:2) 3 is true, as we have that S I = {(cid:6)1(cid:7), (cid:6)2(cid:7)}, I(S) = {{1, 2}} and #sum({{1, 2}}) = 3.– #sum{ A, B : g( A, B), h(B)} (cid:2) 3 is(cid:6)2, 4(cid:7)},S I = {(cid:6)1, 2(cid:7),(cid:6)1, 4(cid:7),(cid:6)1, 3(cid:7),sincefalse,I(S) = {{1, 1, 1, 2}} and#count({{1, 2}}) = 2.#count({{1, 1, 1, 2}}) = 4.#times({{2, 3, 4}}) = 24.#sum({{1, 1, 1, 2}}) = 5.– #min{ X : f ( X), g( X)} (cid:3) 2 is false because the evaluation of (the instantiation of) { X : f ( X), g( X)} w.r.t. I yields theempty set, which does not belong to the domain of #min (we have that I(#min{}) = ⊥).6 Given a substitution σ and a DLP7 We assume that f has a fixed interpretation.8 Again, we assume that ◦ has a fixed interpretation.Aobject Obj (rule, set, etc.), we denote by σ (Obj) the object obtained by replacing each variable X in Obj by σ ( X).284W. Faber et al. / Artificial Intelligence 175 (2011) 278–298A rule r is satisfied w.r.t. I, denoted I |(cid:15) r if some head atom is true w.r.t. I (∃h ∈ H(r) : I |(cid:15) h) whenever all body literalsare true w.r.t. I (∀b ∈ B(r) : I |(cid:15) b).Example 2.9. Consider the atom A = #sum{(cid:6)1 : p(2, 1)(cid:7), (cid:6)2 : p(2, 2)(cid:7)} > 1 from Example 2.7. Let S be the ground set in A.For the interpretation I = {q(2), p(2, 2), t(2)}, I(S) = {{2}}, the application of #sum over {{2}} yields 2, and therefore I |(cid:15) A,since 2 > 1.Definition 2.4. A ground literal (cid:6) is• monotone, if for all interpretations I, J , such that I ⊆ J , I |(cid:15) (cid:6) implies J |(cid:15) (cid:6);• antimonotone, if for all interpretations I, J , such that I ⊆ J ,• nonmonotone, if it is neither monotone nor antimonotone.J |(cid:15) (cid:6) implies I |(cid:15) (cid:6);Note that positive standard literals are monotone, whereas negative standard literals are antimonotone. Aggregate literalsmay be monotone, antimonotone or nonmonotone, regardless whether they are positive or negative.Example 2.10. All ground instances of the following aggregate literals are monotone(cid:2)#count(cid:3)Z : r(Z )> 1.(cid:2)not #count(cid:3)Z : r(Z )< 1.while the following are antimonotone:(cid:2)#count(cid:3)Z : r(Z )< 1.(cid:2)not #count(cid:3)Z : r(Z )> 1.Nonmonotone literals include the sum over (possibly negative) integers and the average. Also, most monotone or antimono-tone functions combined with the equality operator yield nonmonotone literals, which however may be decomposed into aconjunction of a monotone and an antimonotone aggregate.2.3. Answer setsAWe will next define the notion of answer sets for DLPprograms. While usually this is done by first defining the notionof answer sets for positive programs (coinciding with the minimal model semantics) and then for negative programs by astability condition on a reduct, once aggregates have to be considered, the notions of positive and negative literals are ingeneral not clear. If only monotone and antimonotone aggregate atoms were considered, one could simply treat monotoneliterals like positive literals and antimonotone literals like negative ones, and follow the standard approach, as hinted atin [29]. Since we also consider nonmonotone aggregates, such a categorization is not feasible, and we rely on a definitionwhich always employs a stability condition on a reduct.The subsequent definitions are directly based on models: An interpretation M is a model of a DLPprogram P , denotedM |(cid:15) P , if M |(cid:15) r for all rules r ∈ Ground(P). An interpretation M is a subset-minimal model of P if no I ⊂ M is a model ofGround(P).AExample 2.11. It can be verified that {q(2), p(2, 2), t(2)} is a model of the program of Example 2.7.Next we provide the transformation by which the reduct of a ground program w.r.t. an interpretation is formed. Notethat this definition is a generalization of the Gelfond–Lifschitz transformation for DLP programs (see Theorem 3.6). Theintuition is, however, very similar: Treating an interpretation as an assumption, create the part of the program which isrelevant according to the given interpretation. In particular, we consider any rule whose body is not satisfied as irrelevant.Definition 2.5. Given a ground DLPfrom P by deleting rules in which a body literal is false w.r.t. I :Aprogram P and an interpretation I , let P I denote the transformed program obtainedP I =(cid:2)r(cid:6)(cid:6) r ∈ P, ∀b ∈ B(r) : I |(cid:15) b(cid:3).Example 2.12. Consider Example 1.2:Ground(P 1) =Ground(P 2) =(cid:2)(cid:2)p(a):-#countp(a):-#count(cid:2)(cid:4)(cid:2)(cid:4)a : p(a)a : p(a)(cid:5)(cid:3)(cid:5)(cid:3)(cid:3).(cid:3).> 0< 1With interpretations I1 = {p(a)} and I2 = ∅ we obtain:W. Faber et al. / Artificial Intelligence 175 (2011) 278–298285Ground(P 1)I1 = Ground(P 1).Ground(P 1)I2 = ∅.Ground(P 2)I1 = ∅.Ground(P 2)I2 = Ground(P 2).We are now ready to formulate the stability criterion for answer sets.Definition 2.6 (Answer sets for DLPa subset-minimal model of Ground(P) A .Aprograms). Given a DLPAprogram P , an interpretation A of P is an answer set if it isIt should be noted that this definition grasps the original motivation for answer sets or stable models, in that an interpre-tation is a stable model or an answer set if and only if it is a non-redundant explanation of the part of the program whichis relevant to it. Looking in particular at aggregates, we observe that aggregates are treated as “black boxes” or “monoliths,”that is when checking stability they are either present in their entirety or missing altogether. This is one of the main anddistinguishing features of our semantics. Indeed, in Section 5 we will discuss that some other approaches to semantics forprograms containing aggregates do not treat aggregates as monoliths.It is also worth noting that this definition is very general, since it treats all atoms as black boxes. In fact, it is applicableto programs containing arbitrary forms of atoms, as long as their satisfaction by an interpretation can be determined. Thatmeans that the syntax adopted for aggregate literals is irrelevant for the definition, and that this definition can and indeedhas been used (cf. Section 5) for programs containing arbitrary kinds of atoms.Example 2.13. For the programs of Example 1.2, I2 of Example 2.12 is the only answer set of P 1 (because I1 is not a minimalmodel of Ground(P 1)I1 ), while P 2 admits no answer set (I1 is not a minimal model of Ground(P 2)I1 , and I2 is not a modelof Ground(P 2) = Ground(P 2)I2 ).For Example 1.1 and the following input factscompany(a).company(b).company(c).ownsStk(a, b, 40).ownsStk(c, b, 20).ownsStk(a, c, 40).ownsStk(b, c, 20).only the set A = {controlsStk(a, a, b, 40), controlsStk(a, a, c, 40), controlsStk(b, b, c, 20), controlsStk(c, c, b, 20)} (omitting facts)is an answer set, which means that no company controls another company. Note that A1 = A ∪ {controls(a, b), controls(a, c),controlsStk(a, b, c, 20), controlsStk(a, c, b, 20)} is not an answer set, which is reasonable, since there is no basis for the truthof literals in A1 − A.This definition is somewhat simpler than the definitions given in [43,32]. In particular, different to [32], we define answerprograms, rather than transforming them to a positive program.sets directly on top of the notion of models of DLP3. Semantic propertiesAWe first note two simple consequences of Definition 2.6.Proposition 3.1. Any answer set A of a DLPAprogram P is a model of P .Proof. Since Ground(P) A ⊆ Ground(P), A satisfies all rules in Ground(P) A , and rules in Ground(P) − Ground(P) A are satis-fied w.r.t. A by the definition of Ground(P) A . (cid:2)Moreover, each answer set is an answer set of its program reduct.Proposition 3.2. Any answer set A of a DLPAprogram P is an answer set of Ground(P) A .Proof. We note that Ground(Ground(P) A) = Ground(P) A and that Ground(P) A A = Ground(P) A . Since A is an answer setof P , it is a subset-minimal model of Ground(P) A = Ground(Ground(P) A) A . (cid:2)A generally desirable and important property of nonmonotonic semantics is minimality [32,29], in particular a semanticsshould refine the notion of minimal models. We now show that our semantics has this property.Theorem 3.3. Answer sets of a DLPAprogram P are subset-minimal models of P .286W. Faber et al. / Artificial Intelligence 175 (2011) 278–298Proof. Our proof is by contradiction: Assume that I1 is a model of P , I2 is an answer set of P and that I1 ⊂ I2.9 SinceI2 is an answer set of P , it is a subset-minimal model of Ground(P)I2 by Definition 2.6. Therefore, I1 is not a modelof Ground(P)I2 (otherwise, I2 would not be a subset-minimal model of Ground(P)I2 ). Thus, some rule r ∈ Ground(P)I2 isnot satisfied w.r.t. I1. Since Ground(P)I2 ⊆ Ground(P), r is also in Ground(P) and therefore I1 cannot be a model of P ,contradicting the assumption. (cid:2)As a consequence of this theorem, we get incomparability of answer sets.Corollary 3.4. Answer sets of a DLPAprogram P are incomparable (w.r.t. set inclusion) among each other.Theorem 3.3 can be refined for DLPAprograms containing only monotone literals.Theorem 3.5. The answer sets of a DLPAprogram P , where P contains only monotone literals, are precisely the minimal models of P .Aprogram containing only monotone literals, and I be a minimal model of P . Clearly, I is also aProof. Let P be a DLPmodel of P I . We again proceed by contradiction and show that no J ⊂ I is a model of P I : Assume that such a modelJof P exists and satisfies all rules in Ground(P)I . All rules in Ground(P) − Ground(P)I are satisfied by I because their bodyis false w.r.t. I . But since P contains only monotone literals, each false literal in I is also false in J ⊂ I , and hence J alsosatisfies all rules in Ground(P) − Ground(P)I and would therefore be a model of P , contradicting the assumption that I isa minimal model. Together with Theorem 3.3, the result follows. (cid:2)Clearly, a very desirable feature of a semantics for an extended language is that it properly extends agreed-upon se-mantics of the base language, so that the semantics are equal on the base language. Therefore we next show that for DLPprograms, our semantics coincides with the standard answer set semantics. Note that not all semantics which have beenproposed for programs with aggregates meet this requirement, cf. [29].Theorem 3.6. Given a DLP program P , an interpretation I is an answer set of P according to Definition 2.6 iff it is an answer set of Paccording to the standard definition via the classic Gelfond–Lifschitz transformation [12].(cid:4)(cid:4)Proof. (⇒): Assume that I is an answer set w.r.t. Definition 2.6, i.e. I is a minimal model of Ground(P)I . Let us denote the(cid:4) ∈ GL(Ground(P), I)standard Gelfond–Lifschitz transformed program by GL(Ground(P), I). For each r ∈ Ground(P)I some rexists, which is obtained from r by removing all negative literals. Since r ∈ Ground(P)I , all negative literals of r are true in(cid:4)(cid:4) ∈ GL(Ground(P), I) exists but no corresponding rule in Ground(P)I , someI , and also in all(cid:4)(cid:4)J ⊆ I . Therefore (i)positive body literal of rI is a model of GL(Ground(P), I) and (ii) no J ⊂ I is a model of GL(Ground(P), I), as it would also be a model of Ground(P)Iand I thus would not be a minimal model of Ground(P)I . Hence I is a minimal model of GL(Ground(P), I) whenever it is aminimal model of Ground(P)I .J ⊆ I . For rules of which an ris false w.r.t. I (hence ris not included in Ground(P)I ), and also false w.r.t. all(⇐): Now assume that I is a standard answer set of P , that is, I is a minimal model of GL(Ground(P), I). By similar(cid:4) ∈ Ground(P)I whichreasoning as in (⇒) a rule r ∈ GL(Ground(P), I) with true body w.r.t. I has a corresponding rule r(cid:4)(cid:4) ∈ GL(Ground(P), I)contains the negative body of the original rule ro ∈ Ground(P), which is true w.r.t. allwith false body w.r.t. Iis a model ofGround(P)I and (ii) no J ⊂ I is a model of Ground(P)I (otherwise J would also be a model of GL(Ground(P), I)). As aconsequence, I is a minimal model of Ground(P)I whenever it is a minimal model of GL(Ground(P), I). (cid:2)is not contained in Ground(P)I , but it is satisfied in each J ⊆ I . Therefore (i) IJ ⊆ I . Any rule r4. Computational complexity4.1. Complexity frameworkWe analyze the complexity of DLPAon Cautious Reasoning, a main reasoning task in nonmonotonic formalisms,program P and a standard ground atom A, is A true inAamounting to the following decision problem: Given a DLPall answer sets of P ?A, we use the notation LPLA, where L ⊆ {not, ∨} and A ⊆ {Ms, M, As, A, Ns, N}.For identifying fragments of DLPLet P ∈ LPLA. If not ∈ L, then rules in P may contain negative literals. Likewise, if ∨ ∈ L, then rules in P may havedisjunctive heads. If Ms ∈ A (resp., As ∈ A, Ns ∈ A), then P may contain monotone (resp. antimonotone, nonmonotone)aggregates, on which P is stratified. If M ∈ A (resp., A ∈ A, N ∈ A), then P may contain monotone (resp. antimonotone,nonmonotone) aggregates (on which P is not necessarily stratified). If a symbol is absent in a set, then the respective feature9 Throughout the paper, ⊂ denotes strict set inclusion.W. Faber et al. / Artificial Intelligence 175 (2011) 278–298287Table 1The complexity of cautious reasoning in ASP with aggregates (completeness results under logspace reductions).{}{M}{ As}{Ns}{M, As}{M, Ns}{ As, Ns}{M, As, Ns}{ A}{M, A}{ A, Ns}{M, A, Ns}{N}{M, N}{ As, N}{M, As, N}{ A, N}{M, A, N}{}PPPPPPPPco-NPco-NPco-NPco-NPΠ P2Π P2Π P2Π P2Π P2Π P21{not}co-NPco-NPco-NPco-NPco-NPco-NPco-NPco-NPco-NPco-NPco-NPco-NPΠ P2Π P2Π P2Π P2Π P2Π P22{∨}co-NPco-NPΠ P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P23{not, ∨}Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P2Π P24123456789101112131415161718cannot occur in P , unless another symbol is included which specifies a more general feature. For example, if P ∈ LP{}antimonotone aggregates on which P is stratified may occur in P even if As is not specified.{ A}, thenFor the technical results, we consider ground (i.e., variable-free) DLPprograms, and polynomial-time computable ag-gregate functions (note that all sample aggregate functions appearing in this paper fall into this class). However, in theoverview we also provide a discussion on how results change when considering non-ground programs or aggregates whichare harder to compute.A4.2. Overview of complexity resultsTable 1 summarizes the complexity results derived in the next sections for various fragments LPLA, where L is specifiedA, where Ms ∈ L have been omitted from Table 1 for readability, as they are equalin columns and A in rows. Results for LPLto those of the respective fragment containing M instead of Ms.An important result is that the addition of aggregates does not increase the complexity of disjunctive logic programming.language, including all considered types of aggregates (monotone, antimonotone, andACautious reasoning on the full DLPnonmonotone) even unstratified, remains Π P2 -complete, as for standard DLP.The “cheapest” aggregates, from the viewpoint of complexity, are the monotone ones, the addition of which never causesany complexity increase, even for negation-free programs, and even for unstratified monotone aggregates.The largest polynomial-time computable fragment is LP{}{M, As,Ns} (positive ∨-free programs), suggesting that also thestratified aggregates As and Ns are rather “cheap”. Indeed, they behave similarly to stratified negation from the complexityviewpoint, and increase the complexity only in the case of positive disjunctive programs (from co-NP to Π PAntimonotone aggregates (unstratified) behave like unstratified negation: In the positive ∨-free case their presence aloneincrease the complexity from P to co-NP. The complexity remains the same if monotone and stratified nonmonotone aggre-gates are added. The maximal co-NP-computable fragments are LP{not}2 ).{M, A,Ns} and LP{∨}{M}.The most “expensive” aggregates, from the viewpoint of complexity, are the nonmonotone ones: In the positive ∨-free2 . For each language fragment containing2 -completeness. Intuitively, the reason is that nonmonotone aggregates can expresscase (definite Horn programs) they cause a big complexity jump from P to Π Pnonmonotone aggregates we obtain Π Pproperties which can be written using negation and disjunction in standard DLP.Note that implemented ASP systems allow for expressing nonmonotone aggregates such as 1 < #count{ X : p( X)} < 3,which however, can be treated like a conjunction of a monotone and an antimonotone aggregate atom (#count{ X :p( X)} > 1, #count{ X : p( X)} < 3). The complexity of non-disjunctive programs with these constructs is therefore thesame as for LP{not}). In [44], a broad class of nonmonotone aggregates, that can be rewritten as mono-tone and antimonotone aggregates in this style, is identified. Note, however, that sum aggregates (weight constraints) overpositive and negative integers are nonmonotone and can in general not be decomposed into monotone and antimonotoneaggregates.{M, A} (lower than LP{not}{N}288W. Faber et al. / Artificial Intelligence 175 (2011) 278–298The above complexity results give us valuable information about intertranslatability of different languages, having im-portant implication also on the possibility to implement aggregates in existing reasoning engines. For instance, we knownow that cautious reasoning on LP{not}{M, A,Ns} can be efficiently translated to UNSAT (the complement of propositional satis-fiability) or to cautious reasoning on non-disjunctive ASP; thus, arbitrary monotone, arbitrary antimonotone, and stratifiednonmonotone aggregates can be implemented efficiently on top of SAT solvers and non-disjunctive ASP systems. On theother hand, since nonmonotonic aggregates (even without negation and disjunction) bring the complexity to Π P2 , the exis-tence of a polynomial translation from cautious reasoning with nonmonotonic aggregates to UNSAT cannot exist (unless thepolynomial hierarchy collapses). Therefore, a rewriting to UNSAT is not viable to implement nonmonotone aggregates whichrequire more powerful solvers.As mentioned above, our results rely on the assumption that aggregate functions are computable in polynomial time.If one were to allow computationally more expensive aggregates, complexity would rise according to the complexity ofadditional oracles, which are needed to compute the truth value of an aggregate.We end this overview by briefly addressing the complexity of non-ground programs. When considering data-complexity(i.e. a program P is fixed, while the input consists only of facts), the results are as for propositional programs. If, however,one considers program complexity (i.e. a program P is given as input), complexity rises in a similar manner as for aggregate-free programs. A non-ground program P can be reduced, by naive instantiation, to a ground instance of the problem. Inthe general case, where P is given in the input, the size of the grounding Ground(P) is single exponential in the size of P .Informally, the complexity of Cautious Reasoning increases accordingly by one exponential, from P to EXPTIME, co-NP toco-NEXPTIME, Π P2 to co-NEXPTIMENP. For aggregate-free programs complexity results in the non-ground case are reportedin [45]. For the other fragments, the results can be derived using complexity upgrading techniques as presented in [15,46].4.3. Proofs of hardness resultsIn this section, we will provide the proofs for all hardness results of Table 1.4.3.1. Non-disjunctive programsAll P-hardness results in Table 1 (rows 1–8 in column 1) follow directly from the well-known result that (positive)propositional logic programming is P-hard [45].An important observation is that negation can be simulated by antimonotone aggregates. It is therefore possible to turnaggregate-free programs with negation into corresponding positive programs with aggregates. Let us first define how thissimulation can be achieved.Definition 4.1. Given a program P ∈ LP{not,∨}{}literal not a in P by #count{(cid:6)(cid:8) : a(cid:7)} < 1, where (cid:8) is an arbitrary constant., let Γ (P) be the DLPAprogram, which is obtained by replacing each negativeWe can show that an aggregate-free program and its transformed version are equivalent.Lemma 4.1. Each program P ∈ LP{not,∨}can be transformed into an equivalent program Γ (P) ∈ LP{∨}{}which are antimonotone). If P is negation-stratified, then Γ (P) ∈ LP{∨}{ As}.{ A} with aggregate literals (all ofProof. Note that for any interpretation I , not a is true w.r.t.I , and that#count{(cid:6)(cid:8) : a(cid:7)} < 1 is an antimonotone aggregate literal. By virtue of Theorem 3.6, our answer sets semantics (as inDefinition 2.6) is equivalent to the standard answer set semantics. Thus, since the valuation of literals is equal in P andΓ (P), both programs have the same answer sets.iff #count{(cid:6)(cid:8) : a(cid:7)} < 1 is true w.r.t.Since aggregates take the place of negative literals, if P is negation-stratified, then there exists a level mapping, suchthat predicates in negative literals map to an ordinal which is less than the ordinal any head atom maps to. The samelevel-mapping can be used for showing that Γ (P) is aggregate-stratified on all of its aggregate literals. (cid:2)IMoreover, we can show that this transformation has a very low computational cost.Lemma 4.2. Let P ∈ LP{not,∨}{}. Then(i) Γ (P) has the same size (i.e., number of rules and literals) as P , and(ii) Γ (P) is LOGSPACE computable from P .Proof. The Γ (P) transformation replaces each negative literal by an aggregate atom; and it does not add any further literalto the program. Therefore it does not increase the program size. It is easy to see that Γ (P) can be computed by a LOGSPACETuring Machine. Indeed, Γ (P) can be generated by dealing with one rule of P at a time, without storing any intermediatedata apart from a fixed number of indices. (cid:2)W. Faber et al. / Artificial Intelligence 175 (2011) 278–298289As a consequence of these lemmata, we obtain hardness for positive non-disjunctive programs containing antimonotoneaggregates.Theorem 4.3. Cautious reasoning over LP{}{ A} programs is co-NP-hard.Proof. Follows from co-NP-hardness of cautious reasoning for positive disjunctive aggregate-free programs (programs inLP{∨}{} ), see Theorem 6.1 in [45], together with Lemmata 4.1 and 4.2. (cid:2)Whenever one allows for nonmonotone aggregates in positive, non-disjunctive programs, cautious reasoning becomesharder by one level in the polynomial hierarchy.Theorem 4.4. Cautious reasoning over LP{}{N} programs is Π P2 -hard.Proof. We provide a reduction from deciding the validity of a quantified boolean formula (2QBF) Ψ = ∀x1, . . . , xm∃ y1, . . . , yn E. Without loss of generality, we assume that E is a propositional formula in 3CNF format, over precisely the2 -hard [47]. Observe that Ψ is equivalent to ¬Ψ (cid:4)variables x1, . . . , xm, y1, . . . , yn. Deciding if such a Ψ is valid is still Π P,where Ψ (cid:4) = ∃x1, . . . , xm∀ y1, . . . , yn E(cid:4)is a 3DNF equivalent to ¬E, where every literal has reversed polarity w.r.t. Eand conjunctions and disjunctions are inverted. Clearly, Ψ (cid:4)is efficiently constructable from Ψ , and we have that Ψ is validif and only if Ψ (cid:4){N} program Π Ψ which cautiously entails an atom wif and only if Ψ (cid:4)is invalid. To prove the theorem, we construct an LP{}is invalid (i.e., w is a cautious consequence of Π Ψ if and only if Ψ is valid)., and E(cid:4)Let E(cid:4) = (l1,1 ∧ l1,2 ∧ l1,3) ∨ · · · ∨ (lk,1 ∧ lk,2 ∧ lk,3), we define the LP{}(cid:4)(cid:5)1 : t(xi, 1)(cid:2)(cid:4)(cid:3) 0,(cid:5)(cid:3)(cid:5)(cid:3)(cid:2)(cid:4)−1 : t(xi, −1),(cid:4)(cid:5)1 : t(xi, 1)(cid:5)1 : t( yi, 1)(cid:2)(cid:4)−1 : t(xi, −1),(cid:5)(cid:3)(cid:4)−1 : t( yi, −1),(cid:4)(cid:5)1 : t( yi, 1)−1 : t( yi, −1),(cid:2) 0,(cid:3) 0,(cid:5)(cid:3)i ∈ {1, . . . , m}.i ∈ {1, . . . , m}.i ∈ {1, . . . , n}.(cid:2) 0,i ∈ {1, . . . , n}.{N} program Π Ψ as follows:r1 : t(xi, 1):-#sumr2 : t(xi, −1):-#sum(cid:2)(cid:4)r3 : t( yi, 1):-#sumr4 : t( yi, −1):-#sumr5 : t( yi, 1):- sat Er6 : t( yi, −1):- sat Er7 : sat Er8 : w:-#sum(cid:2)(cid:4)(cid:4)(cid:4)(1),(cid:4)(1),i ∈ {1, . . . , n}.i ∈ {1, . . . , n}.(1):-μ(li,1), μ(li,2), μ(li,3),(cid:4)(cid:4)1 : sat E−1 : sat E(cid:5)(1),i ∈ {1, . . . , k}.(cid:5)(cid:3)(cid:4)(−1)(cid:2) 0,i ∈ {1, . . . , k}.(cid:4)where μ(l) is t(a, 1) if l = a is positive, and μ(l) is t(a, −1) if l = ¬a is negative. Intuitively, for each propositional variable, there are two atoms in Π Ψ , namely t(a, 1) and t(a, −1), representing, respectively, the truth and thea appearing in E(cid:4)(1):-μ(li,1), μ(li,2), μ(li,3) in Π Ψ if the corresponding clausefalsity of a. Atom sat E(li,1 ∧ li,2 ∧ li,3) is true in E(cid:4)(1) is derivable from a rule sat EWe claim that w is a cautious consequence of Π Ψ if and only if Ψ is valid. We can equivalently prove that sat E.(cid:4)(cid:4)(1)is valid, since we have that: (1) w a cautious consequence of Π Ψ if and(cid:4)(−1) is false in every answer set and, under answer setis a brave consequence of Π Ψ if and only if Ψ (cid:4)only if sat Esemantics, rule r8 is then equivalent to w:-not sat E(cid:4)(1) is not a brave consequence of Π Ψ (note that sat E(cid:4)(1)), and (2) Ψ is valid if and only if Ψ (cid:4)is invalid.is valid.Thus, we next show that Π Ψ has an answer set containing sat EAssume first that Π Ψ has an answer set A containing sat E(cid:4)(1) if and only if Ψ (cid:4)(cid:4)(1). Observe that A contains exactly one of t(xi, 1) ort(xi, −1) for each 1 (cid:2) i (cid:2) m (if none held for some i, a rule would not be satisfied, if both held, A would not be a minimalmodel of the reduct). Therefore A encodes a truth assignment ϕ for x1, . . . , xm (ϕ(xi) = true if t(xi, 1) ∈ A; ϕ(xi) = false ift(xi, −1) ∈ A). Furthermore, A must contain both t( yi, 1) and t( yi, −1) for each 1 (cid:2) i (cid:2) n, otherwise some rules of r5 and(cid:4)(1)). Since A is a minimal model of Π Ψ Ar6 would be unsatisfied w.r.t. A (as the body is true w.r.t. A which contains sat E,(cid:4)(1),it follows that no Ais a model of Π Ψ A(thusforcing sat E. So there must be at least one of the class of rules r7 in Π Ψ such that each body literal is in A, which contains an encoding of ϕ and an arbitrary truth assignment for y1, . . . , yn but not sat E(cid:4)(1)). This in turn means that each extension of ϕ to y1, . . . , yn satisfies Eand thus that Ψ (cid:4)Assume now that Ψ (cid:4)(cid:4)is valid, so there exists a truth assignment ϕ for x1, . . . , xm such that for each extension of ϕ tois satisfied. Let I be the interpretation containing the encoding of ϕ, i.e. t(xi, 1) iff xi is assigned true in ϕ(cid:4)(1) (and nothing else).y1, . . . , yn, Eand t(xi, −1) iff xi is assigned false in ϕ, in addition t( yi, 1), t( yi, −1) for each 1 (cid:2) i (cid:2) n and sat EΠ Ψ Icontains all rules of Π Ψ exceptis valid.(cid:4)(cid:4)(cid:4)(cid:4)sat E(cid:2)(cid:4)(1):-#sum1 : sat E(cid:4)(cid:4)(cid:5)(1),−1 : sat E(cid:4)(cid:5)(cid:3)(−1)(cid:2) 0.290W. Faber et al. / Artificial Intelligence 175 (2011) 278–298Interpretation I is clearly a model of Π Ψ Iencoding of ϕ in order to satisfy the first two groups of rules (r1 and r2). Furthermore, Iof a truth assignment for y1, . . . , yn in order to satisfy the third and fourth groups of rules. Then, since E(cid:4)(1) must be in I(cid:4)such truth assignment, also sat Eall of t( yi, 1), t( yi, −1) for 1 (cid:2) i (cid:2) n must be in I(cid:4) ⊂ I , and I is therefore an answer set of Π Ψ (and clearly contains sat EI(cid:4) ⊂ I exists. It must contain themust contain at least an encodingis satisfied by anyin order to satisfy all of the group of rules r7. However, that means that(cid:4) = I , contradictingin order to satisfy the groups of rules r5 and r6. So I(cid:4)(1)). (cid:2). To prove its minimality, assume that a model I(cid:4)(cid:4)(cid:4)We note that a related result — deciding whether an answer set exists for a positive, non-disjunctive program with2 -complete — has been shown in [37]. Weight constraints can beweight constraints over possibly negative integers is Σ Pmonotone, antimonotone, or nonmonotone aggregate atoms.Leveraging results in the literature, we get hardness proofs for all fields for non-disjunctive programs in Table 1.Theorem 4.5. All fields in column 1 and all fields in column 2 of Table 1 states the respective hardness of cautious reasoning for thecorresponding fragment of DLPA.Proof. P-hardness results for the fields in rows 1 to 8 in column 1 follow from the fact that cautious reasoning over LP{}{}programs is P-hard [45] and that all corresponding languages are supersets of LP{}{}. co-NP-hardness for the fields in rows 9to 12 in column 1 stem from Theorem 4.3, as all corresponding languages are supersets of LP{}{ A}. The co-NP-hardness forthe fields in rows 1 to 12 in column 2 are based on Theorem 6.7 in [48], which states that cautious reasoning over LP{not}is co-NP-hard. All languages corresponding to the fields are supersets of LP{not}2 -hardness results for the fields inrows 13 to 18 in columns 1 and 2 are backed by Theorem 4.4, and the fact that all corresponding languages are supersetsof LP{}. All Π P{}{}{N}. (cid:2)4.3.2. Disjunctive programsExploiting Lemma 4.1, which says that any aggregate-free program with negation can be transformed to an equiv-alent program with antimonotone aggregates, converting negation-stratification to aggregate-stratification, we can show2 -hardness for cautious reasoning over LP{∨}Π P{ As} programs.Theorem 4.6. Cautious reasoning over LP{∨}{ As} programs is Π P2 -hard.Proof. Follows from Π P2 -hardness of cautious reasoning on standard literal queries for positive disjunctive aggregate-free(LP{∨}{} ) programs, see Theorem 36 of [49]. Given such a program P and a literal l (of the form a or not a, where a is astandard ground atom), let P (cid:4) = P ∪ {q:-l.}, where q is a ground atom that does not occur in P . Obviously, P (cid:4) ∈ LP{not,∨}is negation-stratified, and cautious reasoning on q over P (cid:4)is equivalent to cautious reasoning on l over P . Together withLemmata 4.1 and 4.2, the result follows. (cid:2){}Next, we note that any program containing only stratified antimonotone aggregates can be transformed into an equivalentprogram containing only stratified nonmonotone aggregates.Lemma 4.7. Each LP{not,∨}{ As}program can be transformed into an equivalent LP{not,∨}{Ns}program.(cid:4)Proof. W.l.o.g. we will consider a ground program P . We transform each antimonotone aggregate literal l containing the(cid:4))◦k. We introduce three fresh constants τ , (cid:8), and ν and a new predicateaggregate atom f (S)◦k to lsymbol Π . Let f l be undefined for the multisets {{τ }} and {{τ , (cid:8), ν}} and return a value making ltrue for {{τ , (cid:8)}} (suchis obtained by adding (cid:6)τ : Π(τ )(cid:7), (cid:6)(cid:8) : Π((cid:8))(cid:7), anda value does always exist); otherwise f l is equal to f . Furthermore, S(cid:6)ν : Π(ν)(cid:7) to the ground set S. The transformed program P (cid:4)contains only nonmonotone aggregates, all of which arestratified on P , and is clearly equivalent to P . (cid:2)containing f l(S(cid:4)(cid:4)As a consequence, Π P2 -hardness holds also for LP{∨}{Ns} programs.Corollary 4.8. Cautious reasoning over LP{∨}{Ns} programs is Π P2 -hard.Proof. Follows directly from Theorem 4.6 and Lemma 4.7. (cid:2)These results, together with results from the literature, are sufficient to show all hardness results in columns 3 and 4 inTable 1.W. Faber et al. / Artificial Intelligence 175 (2011) 278–298291Theorem 4.9. Each field in columns 3 and 4 of Table 1 states the respective hardness of cautious reasoning for the correspondingfragment of DLPA.{} programs is co-NP-hard, and the fact that LP{∨}Proof. co-NP-hardness for the fields in rows 1 and 2 in column 3 rely on Theorem 6.1 of [45], which states that cautiousreasoning over LP{∨}2 -hardness for the fields in rows 3 to 18 incolumn 3 follow from Theorem 4.6 and Corollary 4.8 and the fact that all corresponding languages are supersets of LP{∨}{ As} orLP{∨}{Ns}. Π P2 -hardness for all fields in column 4 follows from Theorem 6.2 in [45], which states that cautious reasoning overLP{not,∨}is Π P{}2 -hard, and the fact that all corresponding languages are supersets of LP{not,∨}{} ⊆ LP{∨}{M}. Π P. (cid:2){}In total, we have proved all hardness results for Table 1.4.4. Proofs of membership resultsFor the membership proofs, we will go in the reverse order, and first prove results for richer languages, which cover alsoseveral results for sublanguages.In the membership proofs, we will implicitly use the following lemma:Lemma 4.10. Given an interpretation I for a DLPtime.Aprogram P , the truth valuation of an aggregate atom L is computable in polynomialProof. Let L = f (T )◦k. To determine the truth valuation of L, we have to: (i) compute the valuation I(T ) of the ground setT w.r.t. I , (ii) apply the aggregate function f on I(T ), and (iii) compare the result of f (I(T )) with k w.r.t. ◦.Computing the valuation of a ground set T only requires scanning each element (cid:6)t1, . . . , tn : Conj(cid:7) of T , adding t1 to theresult multiset if Conj is true w.r.t. I . This is evidently polynomial, as is the application of the aggregate function on I(T ) inour framework (see Section 4.1). The comparison with k, finally, is straightforward. (cid:2)4.4.1. Disjunctive programsLet us first focus on the full language. Let us first show that the problem of answer set checking is in co-NP.Lemma 4.11. Checking whether an interpretation M is an answer set of an arbitrary DLPAprogram P is in co-NP.Proof. To prove that M is not an answer set of P , we guess an interpretation Mthe following conditions hold: (i) Mconditions above is clearly in polynomial time, and the problem is therefore in co-NP. (cid:2)is a model of P M , and Mof P , and check that (at least) one of(cid:4) ⊂ M, or (ii) M is not a model of P M . The checking of both(cid:4)(cid:4)Using this result, we are able to give a “guess and check” algorithm for proving membership in Π P2 .Theorem 4.12. Cautious reasoning over LP{not,∨}{M, A,N} programs is in Π P2 .program P as follows: Guess an interpre-Proof. We verify that a ground atom A is not a cautious consequence of a DLPtation M ⊆ BP and check that (1) M is an answer set for P , and (2) A is not true w.r.t. M. Task (2) is clearly polynomial,while (1) is in co-NP by virtue of Lemma 4.11. The problem therefore lies in Π PA2 . (cid:2)Concerning disjunctive programs, for most fragments cautious reasoning is in Π P2 , with two exceptions which are inco-NP. The reason is that for the respective classes it is sufficient to look at an arbitrary model, rather than an answer setor a minimal model.Lemma 4.13. Let P be an LP{∨}model M of P which does not contain A.10{M} program, a standard ground atom A is not a cautious consequence of P , if and only if there exists aProof. Observe first that, since P does not contain negation and only monotone aggregate literals, each literal appearing inP is monotone.(⇐): The existence of a model M of P not containing A, implies the existence of a minimal model M(cid:4)(cid:4) ⊆ M) not containing A. By virtue of Theorem 3.5, Mof P (withis an answer set of P . Therefore, A is not a cautious consequence(cid:4)Mof P .10 Note that M can be any model, possibly non-minimal, of P .292W. Faber et al. / Artificial Intelligence 175 (2011) 278–298(⇒): Since A is not a cautious consequence of P , by definition of cautious reasoning, there exists an answer set M of Pwhich does not contain A. By Proposition 3.1, M is also a model of P . (cid:2)This lemma allows us to prove co-NP-membership for cautious reasoning over these programs.Theorem 4.14. Cautious reasoning over LP{∨}{M} programs is in co-NP.Proof. By Lemma 4.13 we can check whether a ground atom A is not a cautious consequence of a program P as follows: (i)Guess an interpretation M of P , (ii) check that M is a model and a /∈ M. The check is clearly polynomial-time computable,and the problem is therefore in co-NP. (cid:2)These results are sufficient to show all hardness results in columns 3 and 4 in Table 1.Theorem 4.15. Each field in columns 3 and 4 of Table 1 states the respective membership of cautious reasoning for the correspondingfragment of DLPA.Proof. Membership in Π Pbecause all corresponding languages are subsets of LP{not,∨}column 3 follow from Theorem 4.14 and the fact that LP{∨}2 for all the fields in column 4 and fields in rows 3 to 18 of column 3 follow from Theorem 4.12,{M, A,N}. Membership in co-NP for the fields in rows 1 and 2 of{} ⊆ LP{∨}{M}. (cid:2)4.4.2. Non-disjunctive programsΠ P2 -memberships for non-disjunctive programs already follow from the respective result for disjunctive programs, and itremains to show co-NP- and P-memberships.Let us first consider the less complex language LP{}or no answer sets, which can be computed efficiently.{M, As,Ns}. We can show that programs in this fragment have either oneLemma 4.16. An LP{}polynomial time.{M, As,Ns} program has at most one answer set and the answer sets of an LP{}{M, As,Ns} program can be computed inProof. For an LP{}P, I |(cid:15) B(r), h ∈ H(r)}. Furthermore, given an interpretation I , let the sequence {TnP = TP (Ti−1Tia fixpoint T∞{M, As,Ns} program P , let us define an operator TP on interpretations of P as follows: TP (I) = {h | r ∈P (I) = I andP (I)) for i > 0. Since TP is monotone and the number of interpretations for P is finite, the sequence reachesP (I).P (I)}n∈N be defined as T0Consider a level mapping (cid:12) (cid:12) such that for each rule r ∈ P , for which H(r) = {h} and an antimonotone or nonmonotoneis the predicate of h. Moreover,occurs in the head and p in the body of a rule. Withoutaggregate literal A ∈ B(r), it holds for each predicate p nested in A that (cid:12)p(cid:12) < (cid:12)p(cid:12)p(cid:12) (cid:2) (cid:12)psuch that ploss of generality, we assume the co-domain of (cid:12)(cid:12) to be 0, . . . , n.(cid:4)(cid:12) holds for any pair of predicates p and p(cid:4)(cid:12), where pBased on (cid:12) (cid:12), we define a partition P0, . . . , Pn, Pconstr of P (where n is the maximum of the co-domain of (cid:12) (cid:12) —since P is a finite, this is an integer) as follows: Pi = {r | r ∈ P, H(r) = {h}, (cid:12)Pred(h)(cid:12) = i}, Pconstr = {r | r ∈ P, H(r) = ∅}.P . If FPP is a model of Pconstr,Furthermore, we define FP0let FMP = {FPP }, otherwise FMP = ∅.P ) for 0 < i (cid:2) n, and let FPP = FPnP = T∞P0P = T∞Pi(∅) and FPi(FPi−1(cid:4)(cid:4)(cid:4)In the sequel we will use the shorthand H(P) = {h | ∃r ∈ P: h ∈ H(r)} to denote the set of head atoms of a program.We next show by induction that FPP = A for each answer set A of P . The base is FP0P ∩ H(P0) = A ∩ H(P0) for eachanswer set A of P .To prove FP0P0(∅). The base here is T0PiP ∩ H(P0) ⊆ A ∩ H(P0), we use another induction over Ti(∅) = ∅ ⊆ A for eachanswer set A of P . Then, assuming that S ⊆ A for each answer set A of P , we can show that TP0 (S) ⊆ A for each answerset A of P : Each rule r ∈ P0 is also in P and since A is a model by Proposition 3.1, whenever S |(cid:15) b for all b ∈ B(r),then also for any answer set A, A |(cid:15) b, as B(r) may not contain antimonotone or nonmonotone aggregate literals, otherwise(cid:12)p(cid:12) < 0 for some predicate in such an aggregate would hold. Since H(r) = {h}, h must be contained in each answer set. ItP ⊆ H(P0), so FP0follows that FP0P ∩ H(P0) ⊆ A ∩ H(P0).P ∩ H(P0)) (cid:9)= ∅. We show that then A \ X is a model of P A , contradicting theassumption that A is an answer set. Each rule in P A ∩ P0 is clearly satisfied by A \ X , because it is satisfied by FP0P . Nowrecall that each rule r in P A \ P0 has a true body w.r.t. A, which is either true or false w.r.t. A \ X . Since H(r) ∩ X = ∅(because X ⊆ H(P0) and by the definition of the partition H(P0) ∩ H(P \ P0) = ∅), r is also satisfied by A \ X . ThereforeP ∩ H(P0) ⊇ A ∩ H(P0). We have shown the base of the induction,A is not an answer set of P if X (cid:9)= ∅, and so FP0FP0Now assume that X = ( A ∩ H(P0)) \ (FP0⊆ A. It is easy to see that FP0P = T∞P0P ∩ H(P0) = A ∩ H(P0).W. Faber et al. / Artificial Intelligence 175 (2011) 278–298293(FPi−1(FPi−1(FPi−1P ) = FPi−1P ). The base is T0PiFor the inductive step, we assume FPkP ∩ H(Pi) = A ∩ H(Pi), we use yet another induction over T jPiP ∩ H(Pk) = A ∩ H(Pk) holds for all k < i, i > 0 and each answer set A. In order toP ⊆ A for eachshow FPi(FPi−1answer set A, which holds by the inductive hypothesis of the “larger” induction. Now, we assume that T jP ) ⊆ A holdsPifor each answer set, and show that Tpi (T jP )) ⊆ A holds for each answer set. We observe that each rule r ∈ Pi is alsoPiin P and since A is a model by Proposition 3.1, whenever T jP ) |(cid:15) b for all b ∈ B(r), then also for any answer set A,PiA |(cid:15) b, because the only antimonotone or nonmonotone literals are aggregates which, however, contain only atoms formedby predicates p, for which (cid:12)p(cid:12) < i. Any of these atoms are however in H(Pk) for k < i and so by the inductive hypothesis(of the “larger” induction), T jPiIt remains to show that FPi(FPi−1P ∩ H(Pi) ⊇ A ∩ H(Pi). Similar to the base case of the “larger” induction, we assume X =( A ∩ H(Pi)) \ (FPiP ∩ H(Pi)) (cid:9)= ∅. We show that then A \ X is a model of P A , contradicting the assumption that A is ananswer set. Each rule in P A ∩ Pi is clearly satisfied by A \ X , because it is satisfied by FPiP . Now recall that each rule r inP A \ Pi has a true body w.r.t. A, which is either true or false w.r.t. A \ X . Since H(r) ∩ X = ∅ (because X ⊆ H(Pi) and bythe definition of the partition H(Pi) ∩ H(P \ Pi) = ∅), r is also satisfied by A \ X . Therefore A is not an answer set of PP ∩ H(Pi) = A ∩ H(Pi) for eachif X (cid:9)= ∅, and so FPianswer set A.P ∩ H(Pi) ⊇ A ∩ H(Pi). We have shown the step of the induction, FPiP ) ∩ H(Pk) = A ∩ H(Pk). In total, we get FPiP = T∞Pi(FPi−1⊆ A.In total, for FPP we have FPP ∩ (answer set of P is also an answer set of (A = FPP . It follows that P has at most one answer set.i=1 H(Pi)) = A ∩ (i=1 H(Pi)) for each answer set A of P . It is easy to see that eachi=1 H(Pi)) = P \ Pconstr. Therefore, for each answer set A of P , we know that(cid:7)nMoreover, note that any rules in Pconstr can only be satisfied if one of its body literals is false (as the heads are empty).Now since FPP is an answer set of P \ Pconstr, it is a minimal model of (P \ Pconstr)FPP . If FPP satisfies all rules in Pconstr,then (P \ Pconstr)FPP = P FPP , and FPP is an answer set of P . If any rule of Pconstr exists which is not satisfied by FPP , thisrule also occurs in P FPP , and therefore FPP cannot be a model of P FPP , and hence it cannot be an answer set of P in thiscase. In total, we get that FMP is the set of answer sets for P .Computing FPP and FMP using TP is clearly feasible in polynomial time in the size of the program. (cid:2)(cid:7)n(cid:7)nGiven that we can compute the set of answer sets in polynomial time and that the cardinality of this set is at most 1,cautious reasoning can be done easily over the computed answer sets.Theorem 4.17. Cautious reasoning over LP{}{M, As,Ns} is in P.Proof. This is a simple consequence of Lemma 4.16. We compute the set of answer sets in polynomial time. If it is empty,all atoms are a cautious consequence. If there is one answer set, check in polynomial time whether it contains the queryatom. (cid:2)Let us now focus on the co-NP-memberships. For doing so, we will re-use the fact that answer sets LP{}{M, As,Ns} programsis an answer set of anare computable in polynomial time. The point is that for checking whether an interpretation ILP{not}{M, A,Ns} program. The crucial point is that for checkingwhether I is a minimal model of P I (in which case it is an answer set), one can eliminate antimonotone literals from P I .{M, A,Ns} program P , we can form the reduct P I , which is also an LP{not}Lemma 4.18. Given an LP{not}model of Ψ (P I ), which is derived from P I by deleting all antimonotone literals.{M, A,Ns} program P and an interpretation I ⊆ BP , I is a subset-minimal model of P I iff it is a subset-minimal(cid:4)Proof. (⇒) If I is a minimal model of P I , it is obviously also a model of Ψ (P I ). Moreover, each interpretation N ⊂ I is nota model of P I , so there is at least one rule r ∈ P I , for which N (cid:9)|(cid:15) r, that is all body atoms are true w.r.t. N but all headis trueatoms are false w.r.t. N. Now there is a rule ris not satisfied by N. As a consequence, N is not a model of Ψ (P I ), and therefore I is a minimalw.r.t. N, and hence rmodel of Ψ (P I ).(cid:4) ∈ Ψ (P I ) with H(r) = H(r(cid:4)). So also the body of r(cid:4)) and B(r) ⊇ B(r(⇐) Let I be a minimal model of Ψ (P I ). We first note that no rule in P I has a body literal which is false w.r.t. I byconstruction of P I , and therefore also no rule in Ψ (P I ) has a body literal which is false w.r.t. I . So for any rule in Ψ (P I ),all body literals are true w.r.t. I , and hence one of its head atoms is true w.r.t. I , since I is a model. Since each rule inΨ (P I ) has a corresponding rule in P I with equal head, and since no rule in P I has a body literal which is false w.r.t. I , Iis also a model of P I .Now, consider an arbitrary interpretation N ⊂ I . N is not a model of Ψ (P I ), that is, there is a rule r ∈ Ψ (P I ) for whichall body literals in r are true w.r.t. N, and all head atoms in r are false w.r.t. N. Now consider the corresponding rule(cid:4) ∈ p I , for which B(r) ⊆ B(rrare true w.r.t. I , and since each deleted body literal(cid:4)) \ B(r) is an antimonotone literal (either a negative standard literal or an antimonotone aggregate literal), (cid:6) is also(cid:6) ∈ B(r(cid:4)). By construction of p I , all literals of r(cid:4)(cid:4)294W. Faber et al. / Artificial Intelligence 175 (2011) 278–298(cid:4)) = H(r), each head atom of rtrue w.r.t. N. Hence, the body of rnot satisfied and N is not a model of P I , and we obtain that I is a minimal model of P I . (cid:2)is true w.r.t. N, and since H(r(cid:4)(cid:4)is false w.r.t. N. Hence r(cid:4)isSo answer set checking for an LP{not}for an LP{}earlier that this task is polynomial.{M, A,Ns} program can be done by checking whether an interpretation is a minimal model{M,Ns} program, which in this case is equivalent to checking whether it is an answer set. We have already shownTheorem 4.19. Cautious reasoning over LP{not}{M, A,Ns} is in co-NP.Proof. We guess an interpretation I , and check whether it is an answer set and does not contain the queried atom. Thelatter check is clearly polynomial. Answer set checking amounts to checking whether I is a subset-minimal model of P I .Because of Lemma 4.18, I is a subset-minimal model of P I iff I is a subset-minimal model of Ψ (P I ), in which all negativestandard and antimonotone aggregate literals have been deleted (this transformation is obviously polynomial). Because ofis an answer set of Ψ (P I ).Proposition 3.2, INow since Ψ (P I ) ∈ LP{}{M, As,Ns} we know by Lemma 4.16 that its answer sets (at most one) are computable inpolynomial time. So we can compute the set of minimal models of Ψ (P I ) in polynomial time. If it is empty, I is not ananswer set; otherwise there is exactly one minimal model, and we check whether it is equal to I . If it is, I is an answer set,otherwise it is not. Checking whether I is an answer set is therefore feasible in polynomial time. (cid:2)is an answer set of P I , hence if Iis a subset-minimal model of P I{M,Ns} ⊆ LP{}if IWe have therefore proved all membership results of Table 1 for non-disjunctive programs.Theorem 4.20. Each field in columns 3 and 4 of Table 1 states the respective membership of cautious reasoning for the correspondingfragment of DLPA.Proof. Membership in Π P2 for all the fields in rows 13 to 18 in columns 1 and 2 follow from Theorem 4.12, because allcorresponding languages are subsets of LP{not,∨}{M, A,N}. Membership in co-NP for the fields in rows 9 to 12 of column 1 and inrows 1 to 12 of column 2 are a consequence of Theorem 4.19, since all corresponding languages are subsets of LP{not}{M, A,Ns}.Finally, membership in P for the fields in rows 1 to 8 of column 1 are due to Theorem 4.17, since all corresponding languagesare subsets of LP{}{M, As,Ns}. (cid:2)5. Related workThere have been considerable efforts to define semantics for logic programs with aggregates. For a historical background,we refer to [50]. Here we will focus on work which has been proposed in the field of Answer Set Programming for defin-ing semantics for recursive aggregates. Several of these works consider only monotone aggregates, such as [31,33,30]. Wewill not go into further details with respect to these approaches, as their focus is either on having aggregate atoms inrule heads (a feature which is absent in our framework) or on working out algebraic methods for disjunctive programs.Moreover, semantically, monotone aggregates in rule bodies are straightforward to handle, as they perfectly correspond tostandard positive atoms in their behavior. We also note that most of the related works do not consider disjunctive programs.A thorough discussion of pros and cons for the various approaches for recursive aggregates has been given in [50,34,36].The approaches of [25,27,28] basically all admit non-minimal answer sets. In particular, program P 1 of Example 1.2would have ∅ and {p(a)} as answer sets. As shown in Example 2.13 (also by Theorem 3.3), the semantics proposed in thispaper only admits ∅, and always guarantees the minimality of answer sets. The work in [51] deals with the more abstractconcept of generalized quantifiers, and the semantics therein also allows for non-minimal answer sets.The approach of [43] is defined on non-disjunctive programs with particular kinds of aggregates (called cardinality andweight constraints), which basically correspond to programs with count and sum functions. As shown in [29] and [52], inpresence of negative weights or negative literals inside aggregates,11 the semantics in [43] can lead to unintuitive results.For example, the program {a:-#sum{(cid:6)−1 : a(cid:7)} (cid:2) −1.} should intuitively have only ∅ as an answer set, as {a} would not beminimal and the truth of a is not founded. However, according to [43], both ∅ and {a} are answer sets.12 Our semanticsonly allows for ∅ as an answer set, according to the intuition. However, in [37] it has been shown that the semantics of[43] is equal to the answer set semantics as in Definition 2.6 on programs with #sum (respectively weight constraints) overpositive integers. An extension to the approach of [43] has been presented in [32], which allows for arbitrary aggregates innon-disjunctive programs. A difference with respect to [43,32] is also that these languages allow for aggregate atoms in ruleheads, which we do not consider in this paper.11 Note that while negative literals inside aggregates are not allowed in our framework, negative integers are allowed and correctly dealt with.12 Interestingly, lparse (version 1.0.17) and smodels (version 2.32), the software implementing the semantics of [43], computes only ∅.W. Faber et al. / Artificial Intelligence 175 (2011) 278–298295A major contribution to the understanding of aggregates in ASP has been presented in [37]. The author provides a wayto represent (ground) aggregates by means of propositional formulas, building on earlier work reported in [52]. Togetherwith the reduct-based semantics for propositional formulas presented in [37] (which are called answer sets as well), thisyields a semantics for programs with aggregates as well. In Theorem 3 of [37], Ferraris proves that this semantics coincidesprogramswith the one presented in this paper in Definition 2.6 on what Ferraris refers to as FLP-programs (ground DLPin which aggregate atoms are not preceded by not).AIt should be noted that the representation in [37] is done in a careful way in order to guarantee monolithic stabilityjustification capabilities of aggregates. In particular, when forming the reduct with respect to an interpretation I as definedin [37], any formula representing an aggregate not satisfied by I will be completely replaced by ⊥ (falsity), rendering thecorresponding rule irrelevant in the reduct. On the other hand, a formula representing an aggregate satisfied by I willstay in the reduct as is. This behavior precisely coincides with the main motivation for the reduct of Definition 2.5, anddistinguishes this approach from others, as discussed below.However, there is a difference with respect to the semantics in [37] when negated aggregate atoms occur in the program.This is because in our work we treat the negation operator simply as a complement operator for aggregates, while in [37]it is treated as a negation-as-failure operator. The difference is best shown using an example.Example 5.1. Given the program(cid:2)a:-not #count(cid:3)(cid:6)1 : a(cid:7)< 1.r:there is one answer set (∅) with respect to Definition 2.6, while [37] would allow for two answer sets ∅ and {a}.So in the presence of negated literals, the semantics of [37] allows non-minimal answer sets. Both ways of dealingwith not in front of aggregates can be motivated: For our language it is seen as a shorthand for the complement of theaggregate, and the above rule is equivalent to:(cid:4):r(cid:2)a:-#count(cid:3)(cid:6)1 : a(cid:7)(cid:3) 1.In [37], rule r is viewed as equivalent to(cid:4)(cid:4):ra :-not not a.which also has two answer sets ∅ and {a} according to [53].It is however notable that even though the language considered in [37] is very general and its semantics has beenlanguage in mind, the two semantics coincide for the most part. We viewAdefined independently, without having the DLPthis as a confirmation of the robustness of our semantics.In [37], the author has also given some complexity results. In particular, he has shown that deciding whether a (non-2 -complete. Thisdisjunctive) program with weight constraints (a #sum-aggregate in our notation) has an answer set, is Σ Pis strictly related to our result that cautious reasoning over a program in LP{}{N} is Π P2 -complete.Recently, in [54] a language called RASPL-1 has been defined, which essentially allows for (possibly non-ground) countingaggregates. The semantics of this language is defined analogously to [37], but in this case by means of a representationas a first-order formula which is then interpreted using a semantics for arbitrary first-order formulas which has beenpresented in [55]. Also the semantics of RASPL-1 has been shown to coincide with Definition 2.6 on a large commonlanguage fragment; we refer to [54] for details.We would furthermore like to point out that the reduct and the semantics defined in this paper has already spread inthe scientific community and has been used in the work of others. Indeed one main advantage of our semantic definition inthis respect is its generality. Being based on a definition of reduct, which does not refer to aggregates or special structuresat all, it allows for defining the semantics of arbitrary linguistic extensions. Indeed, in [56,57] the authors use Definition 2.5for defining a semantics for programs with higher order and externally defined atoms. This work is set in the context ofreasoning in the Semantic Web (where “aggregates” involve querying ontologies, for example), and can be seen as a variantof our semantics for that framework.However, there are also other suggestions for the semantics of programs with aggregates. Most representative of those, in[29,34], several semantics for non-disjunctive programs with aggregates have been defined, the closest one to the semanticsin this paper being the ˜D-stable semantics. In [36,35] the notions of fixpoint answer set and unfolding answer set have beendefined for non-disjunctive programs with aggregates, which, in [35], have been shown to be equivalent. Moreover, the˜D-stable semantics and fixpoint answer sets are also equivalent, as shown in [36,35]. Also for the ˜D-stable semantics,minimality and coincidence with answer sets in the aggregate-free case is guaranteed. Another equivalent definition forprograms with c-atoms (which are essentially extensional representations of aggregate atoms) has been given in [58].In Theorem 4 in [36] and Proposition 8.1 in [34] it has been shown that any ˜D-stable model is also an answer set asdefined in Definition 2.6. However, an answer set as defined in Definition 2.6 is not necessarily a ˜D-stable model, as notedin [36,34]. In his doctoral thesis [50], Pelov also defines various semantics for disjunctive programs with aggregates, amongthem one which is close to ours. However, the same differences as for the ˜D-stable model semantics surface.To see these differences, let us consider Example 9 of [36].296W. Faber et al. / Artificial Intelligence 175 (2011) 278–298Example 5.2. Given the program(cid:2)p(1):-#sum(cid:3)X : p(X)p(1):-p(−1).we obtain one answer set {p(1), p(−1)} with respect to Definition 2.6, but no ˜D-stable model.p(−1):-p(1).(cid:3) 0.The authors of [36] argue that the program should be equivalent to the aggregate-free programp(1):-not p(−1).p(1):-not p(1), not p(−1).p(1):-p(1), not p(−1).p(1):-p(1).p(1):-p(1), p(−1).p(1):-p(−1).p(−1):-p(1).Here, when forming the reduct w.r.t. {p(1), p(−1)}, the first three rules are deleted. This is against our intuition that anyliteral, and in particular aggregate literals are to be considered as a monolithic structure when verifying stability. Indeed,in this example only some part of the representation of the aggregate is retained in the reduct. This is a situation whichcannot occur in our setting, any aggregate is either relevant in its entirety or has no effect at all. Interestingly, also thesemantics of [37] shares precisely our view and yields the (unique) answer set {p(1), p(−1)} on this program.As this example shows, our approach is in line with the semantics of [37], and differs from [36,34] in the assumptionhow an aggregate literal may justify an answer set. We believe that both approaches can be motivated and the choice of the“right” semantics depends on how one interprets the justification capabilities of an aggregate. However, if one accepts ourassumption that aggregates must serve as justifiers in a monolithic way, these other semantics do not behave in an intuitiveway. Indeed, as shown in Example 5.2 it is unclear why one would allow only for some part of an aggregate to give stabilityto an answer set candidate. Moreover, our “monolithic” approach has the advantage to be generally applicable, since it isnot specific to aggregates, but it depends only on basic satisfaction of the expressions in the language.In [50], Pelov provides also a complexity analysis for reasoning tasks in the setting of the semantics proposed in thatwork. In particular, the problem of model existence is studied, which is related to the query answering problems studied inthis work. Pelov does not differentiate among the types of literals as we do, but differentiates among the semantics definedand the evaluation complexity of the aggregate literals. Also [35] contains a similar analysis. The results are compatible tothe ones derived in this paper, model existence being located on the first and second level of the polynomial hierarchy.6. ConclusionsConcluding, we have proposed a declarative semantics for full ASP programs with arbitrary aggregates (DLPprograms).This semantics generalizes the answer set semantics for standard ASP in a simple and elegant way, through a new defi-nition of reduct which is simpler than the original one and treats negative literals, positive literals, and aggregates literalsin a fully uniform manner. We have demonstrated that our semantics is endowed with desirable properties: it guaranteessubset-minimality (and therefore the incomparability) of answer sets, and it coincides with the standard answer set seman-tics on aggregate-free programs. We have analyzed the computational complexity of the language in depth, drawing a fullpicture of the complexity of the ASP fragments where negation and/or disjunction are combined with different kinds of ag-gregates (monotone, antimonotone, nonmonotone, stratified). Importantly, we proved that aggregate literals do not increasethe computational complexity of full (disjunctive) ASP programs in our approach; while they do increase the complexity ofnormal (non-disjunctive) programs up to Π P2 . We have singled out, however, relevant classes of aggregates which do notcause any complexity overhead even for normal programs, and can be efficiently implemented in normal ASP systems.AAcknowledgementsThis work has greatly benefited from interesting discussions with and comments of Paolo Ferraris, Michael Gelfond,Vladimir Lifschitz, Nikolay Pelov. We are also grateful to the competent comments and suggestions in the reviews. The workwas partially supported by M.I.U.R. under projects “Potenziamento e Applicazioni della Programmazione Logica Disgiuntiva,”“Sistemi basati sulla logica per la rappresentazione di conoscenza: estensioni e tecniche di ottimizzazione,” and “tocai.it:Tecnologie Orientate alla Conoscenza per Aggregazioni di Imprese in Internet”.References[1] W. Faber, N. Leone, G. Pfeifer, Recursive aggregates in disjunctive logic programs: Semantics and complexity, in: J.J. Alferes, J. Leite (Eds.), Proceedingsof the 9th European Conference on Artificial Intelligence (JELIA 2004), in: Lecture Notes in AI (LNAI), vol. 3229, Springer-Verlag, 2004, pp. 200–212.[2] F. Calimeri, W. Faber, N. Leone, S. Perri, Declarative and computational properties of logic programs with aggregates, in: Nineteenth International JointConference on Artificial Intelligence (IJCAI-05), 2005, pp. 406–411.[3] J. McCarthy, Programs with common sense, in: Proceedings of the Teddington Conference on the Mechanization of Thought Processes, Her Majesty’sStationery Office, 1959, pp. 75–91.[4] J. McCarthy, P.J. Hayes, Some philosophical problems from the standpoint of artificial intelligence, in: B. Meltzer, D. Michie (Eds.), Machine Intelligence,vol. 4, Edinburgh University Press, 1969, pp. 463–502, reprinted in [59].[5] M. Minsky, A framework for representing knowledge, in: P.H. Winston (Ed.), The Psychology of Computer Vision, McGraw–Hill, 1975, pp. 211–277.[6] J. McCarthy, Circumscription — A form of non-monotonic reasoning, Artificial Intelligence 13 (1–2) (1980) 27–39.W. Faber et al. / Artificial Intelligence 175 (2011) 278–298297[7] J. McCarthy, Applications of circumscription to formalizing common-sense knowledge, Artificial Intelligence 28 (1) (1986) 89–116.[8] R. Reiter, A logic for default reasoning, Artificial Intelligence 13 (1–2) (1980) 81–132.[9] D.V. McDermott, J. Doyle, Non-monotonic logic I, Artificial Intelligence 13 (1–2) (1980) 41–72.[10] D.V. McDermott, Non-monotonic logic II: Nonmonotonic modal theories, Journal of the ACM 29 (1) (1982) 33–57.[11] R.C. Moore, Semantical considerations on nonmonotonic logic, Artificial Intelligence 25 (1) (1985) 75–94.[12] M. Gelfond, V. Lifschitz, Classical negation in logic programs and disjunctive databases, New Generation Computing 9 (1991) 365–385.[13] C. Baral, Knowledge Representation, Reasoning and Declarative Problem Solving, Cambridge University Press, 2003.[14] J. Minker, On indefinite data bases and the closed world assumption, in: D.W. Loveland (Ed.), Proceedings of the 6th Conference on AutomatedDeduction (CADE ’82), in: Lecture Notes in Computer Science, vol. 138, Springer, New York, 1982, pp. 292–308.[15] T. Eiter, G. Gottlob, H. Mannila, Disjunctive DATALOG, ACM Transactions on Database Systems 22 (3) (1997) 364–418.[16] P. Simons, I. Niemelä, T. Soininen, Extending and implementing the stable model semantics, Artificial Intelligence 138 (2002) 181–234.[17] T. Janhunen, I. Niemelä, D. Seipel, P. Simons, J.-H. You, Unfolding partiality and disjunctions in stable model semantics, ACM Transactions on Computa-tional Logic 7 (1) (2006) 1–37.[18] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, F. Scarcello, The DLV system for knowledge representation and reasoning, ACM Transactionson Computational Logic 7 (3) (2006) 499–562.[19] F. Lin, Y. Zhao, ASSAT: Computing answer sets of a logic program by SAT solvers, Artificial Intelligence 157 (12) (2004) 115–137.[20] Y. Lierler, M. Maratea, Cmodels-2: SAT-based answer set solver enhanced to non-tight programs, in: V. Lifschitz, I. Niemelä (Eds.), Proceedings of the7th International Conference on Logic Programming and Non-Monotonic Reasoning (LPNMR-7), in: Lecture Notes in AI (LNAI), vol. 2923, Springer,2004, pp. 346–350.[21] C. Anger, K. Konczak, T. Linke, NoMoRe: A system for non-monotonic reasoning, in: T. Eiter, W. Faber, M. Truszczy ´nski (Eds.), Logic Programming andNonmonotonic Reasoning — Proceedings of the 6th International Conference (LPNMR ’01), Vienna, Austria, September 2001, in: Lecture Notes in AI(LNAI), vol. 2173, Springer-Verlag, 2001, pp. 406–410.[22] C. Anger, M. Gebser, T. Linke, A. Neumann, T. Schaub, The nomore++ approach to answer set solving, in: G. Sutcliffe, A. Voronkov (Eds.), Logic forProgramming, Artificial Intelligence, and Reasoning, 12th International Conference (LPAR 2005), in: Lecture Notes in Computer Science, vol. 3835,Springer-Verlag, 2005, pp. 95–109.[23] M. Gebser, B. Kaufmann, A. Neumann, T. Schaub, Conflict-driven answer set solving, in: Twentieth International Joint Conference on Artificial Intelli-gence (IJCAI-07), Morgan Kaufmann Publishers, 2007, pp. 386–392.[24] I.S. Mumick, H. Pirahesh, R. Ramakrishnan, The magic of duplicates and aggregates, in: Proceedings of the 16th International Conference on Very LargeData Bases (VLDB ’90), Morgan Kaufmann, 1990, pp. 264–277.[25] D.B. Kemp, P.J. Stuckey, Semantics of logic programs with aggregates, in: V.A. Saraswat, K. Ueda (Eds.), Proceedings of the International Symposium onLogic Programming (ISLP ’91), MIT Press, 1991, pp. 387–401.[26] K.A. Ross, Y. Sagiv, Monotonic aggregation in deductive databases, Journal of Computer and System Sciences 54 (1) (1997) 79–97.[27] M. Gelfond, Representing knowledge in A-Prolog, in: A.C. Kakas, F. Sadri (Eds.), Computational Logic. Logic Programming and Beyond, in: Lecture Notesin Computer Science, vol. 2408, Springer, 2002, pp. 413–451.[28] T. Dell’Armi, W. Faber, G. Ielpa, N. Leone, G. Pfeifer, Aggregate functions in DLV, in: M. de Vos, A. Provetti (Eds.), Proceedings ASP03 — Answer SetProgramming: Advances in Theory and Implementation, Messina, Italy, 2003, pp. 274–288, online at http://CEUR-WS.org/Vol-78/.[29] N. Pelov, M. Denecker, M. Bruynooghe, Partial stable models for logic programs with aggregates, in: Proceedings of the 7th International Conferenceon Logic Programming and Non-Monotonic Reasoning (LPNMR-7), in: Lecture Notes in AI (LNAI), vol. 2923, Springer, 2004, pp. 207–219.[30] N. Pelov, M. Truszczy ´nski, Semantics of disjunctive programs with monotone aggregates — An operator-based approach, in: Proceedings of the 10thInternational Workshop on Non-Monotonic Reasoning (NMR 2004), Whistler, BC, Canada, 2004, pp. 327–334.[31] V.W. Marek, J.B. Remmel, On logic programs with cardinality constraints, in: S. Benferhat, E. Giunchiglia (Eds.), Proceedings of the 9th InternationalWorkshop on Non-Monotonic Reasoning (NMR 2002), Toulouse, France, 2002, pp. 219–228.[32] V.W. Marek, J.B. Remmel, Set constraints in logic programming, in: V. Lifschitz, I. Niemelä (Eds.), Proceedings of the 7th International Conference onLogic Programming and Non-Monotonic Reasoning (LPNMR-7), in: Lecture Notes in AI (LNAI), vol. 2923, Springer, 2004, pp. 167–179.[33] V.W. Marek, I. Niemelä, M. Truszczy ´nski, Logic programming with monotone cardinality atom, in: V. Lifschitz, I. Niemelä (Eds.), Proceedings of the 7thInternational Conference on Logic Programming and Non-Monotonic Reasoning (LPNMR-7), in: Lecture Notes in AI (LNAI), vol. 2923, Springer, 2004,pp. 154–166.[34] N. Pelov, M. Denecker, M. Bruynooghe, Well-founded and stable semantics of logic programs with aggregates, Theory and Practice of Logic Program-ming 7 (3) (2007) 301–353.[35] T.C. Son, E. Pontelli, A constructive semantic characterization of aggregates in ASP, Theory and Practice of Logic Programming 7 (2007) 355–375.[36] T.C. Son, E. Pontelli, I. Elkabani, On logic programming with aggregates, Tech. Rep. NMSU-CS-2005-006, New Mexico State University, 2005.[37] P. Ferraris, Answer sets for propositional theories, in: C. Baral, G. Greco, N. Leone, G. Terracina (Eds.), Logic Programming and Nonmonotonic Reasoning— 8th International Conference (LPNMR ’05), Diamante, Italy, September 2005, in: Lecture Notes in Computer Science, vol. 3662, Springer-Verlag, 2005,pp. 119–131.[38] T. Dell’Armi, W. Faber, G. Ielpa, N. Leone, G. Pfeifer, Aggregate functions in disjunctive logic programming: Semantics, complexity, and implementationin DLV, in: Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI) 2003, Morgan Kaufmann Publishers, Acapulco, Mexico,2003, pp. 847–852.[39] F. Lin, Y. Zhao, ASSAT: Computing answer sets of a logic program by SAT solvers, in: Proceedings of the Eighteenth National Conference on ArtificialIntelligence (AAAI 2002), AAAI Press/MIT Press, Edmonton, Alberta, Canada, 2002.[40] J.D. Ullman, Principles of Database and Knowledge Base Systems, Computer Science Press, 1989.[41] K.R. Apt, H.A. Blair, A. Walker, Towards a theory of declarative knowledge, in: J. Minker (Ed.), Foundations of Deductive Databases and Logic Program-ming, Morgan Kaufmann Publishers, Inc., Washington, DC, 1988, pp. 89–148.[42] T.C. Przymusinski, On the declarative semantics of deductive databases and logic programs, in: J. Minker (Ed.), Foundations of Deductive Databases andLogic Programming, Morgan Kaufmann Publishers, Inc., 1988, pp. 193–216.[43] I. Niemelä, P. Simons, T. Soininen, Stable model semantics of weight constraint rules, in: M. Gelfond, N. Leone, G. Pfeifer (Eds.), Proceedings of the 5thInternational Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR ’99), in: Lecture Notes in AI (LNAI), vol. 1730, Springer-Verlag,El Paso, Texas, USA, 1999, pp. 107–116.[44] W. Faber, Decomposition of nonmonotone aggregates in logic programming, in: M. Fink, H. Tompits, S. Woltran (Eds.), Proceedings of the 20th Work-shop on Logic Programming (WLP 2006), Vienna, Austria, 2006, pp. 164–171.[45] E. Dantsin, T. Eiter, G. Gottlob, A. Voronkov, Complexity and expressive power of logic programming, ACM Computing Surveys 33 (3) (2001) 374–425.[46] G. Gottlob, N. Leone, H. Veith, Succinctness as a source of expression complexity, Annals of Pure and Applied Logic 97 (13) (1999) 231–260.[47] L.J. Stockmeyer, A.R. Meyer, Word problems requiring exponential time: Preliminary report, in: Conference Record of 5th Annual ACM Symposium onTheory of Computing (STOC ’73), ACM Press, 1973, pp. 1–9.[48] V.W. Marek, M. Truszczy ´nski, Autoepistemic logic, Journal of the ACM 38 (3) (1991) 588–619.298W. Faber et al. / Artificial Intelligence 175 (2011) 278–298[49] T. Eiter, G. Gottlob, On the computational cost of disjunctive logic programming: Propositional case, Annals of Mathematics and Artificial Intelli-gence 15 (3/4) (1995) 289–323.[50] N. Pelov, Semantics of logic programs with aggregates, Ph.D. thesis, Katholieke Universiteit Leuven, Leuven, Belgium, Apr. 2004.[51] T. Eiter, G. Gottlob, H. Veith, Modular logic programming and generalized quantifiers, in: J. Dix, U. Furbach, A. Nerode (Eds.), Proceedings of the 4thInternational Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR ’97), in: Lecture Notes in Computer Science, vol. 1265, Springer,1997, pp. 290–309.[52] P. Ferraris, V. Lifschitz, Weight constraints as nested expressions, Theory and Practice of Logic Programming 5 (1–2) (2005) 45–74.[53] V. Lifschitz, L.R. Tang, H. Turner, Nested expressions in logic programs, Annals of Mathematics and Artificial Intelligence 25 (34) (1999) 369–389.[54] J. Lee, V. Lifschitz, R. Palla, A reductive semantics for counting and choice in answer set programming, in: D. Fox, C.P. Gomes (Eds.), Proceedings of the23rd National Conference on Artificial Intelligence (AAAI ’08), AAAI Press, 2008, pp. 472–479.[55] P. Ferraris, J. Lee, V. Lifschitz, A new perspective on stable models, in: Twentieth International Joint Conference on Artificial Intelligence (IJCAI-07),2007, pp. 372–379.[56] T. Eiter, G. Ianni, R. Schindlauer, H. Tompits, A uniform integration of higher-order reasoning and external evaluations in answer set programming, in:International Joint Conference on Artificial Intelligence (IJCAI 2005), Edinburgh, UK, 2005, pp. 90–96.[57] T. Eiter, G. Ianni, H. Tompits, R. Schindlauer, Effective integration of declarative rules with external evaluations for semantic web reasoning, in: Pro-ceedings of the 3rd European Semantic Web Conference (ESWC 2006), 2006, pp. 273–287.[58] T.C. Son, E. Pontelli, P.H. Tu, Answer sets for logic programs with arbitrary abstract constraint atoms, Journal of Artificial Intelligence Research 29 (2007)353–389.[59] J. McCarthy, Formalization of Common Sense, papers by John McCarthy edited by V. Lifschitz, Ablex, 1990.