Artificial Intelligence 191–192 (2012) 42–60Contents lists available at SciVerse ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintOn minimal constraint networks ✩Georg GottlobDepartment of Computer Science and Oxford Man Institute, University of Oxford, Oxford OX1 3QD, UKa r t i c l ei n f oa b s t r a c tIn a minimal binary constraint network, every tuple of a constraint relation can beextended to a solution. The tractability or intractability of computing a solution tosuch a minimal network was a long standing open question. Dechter conjectured thiscomputation problem to be NP-hard. We prove this conjecture. We also prove a conjectureby Dechter and Pearl stating that for k (cid:2) 2 it is NP-hard to decide whether a singleconstraint can be decomposed into an equivalent k-ary constraint network. We showthat this holds even in case of bi-valued constraints where k (cid:2) 3, which proves anotherconjecture of Dechter and Pearl. Finally, we establish the tractability frontier for thisproblem with respect to the domain cardinality and the parameter k.© 2012 Elsevier B.V. All rights reserved.Article history:Received 12 May 2012Received in revised form 26 July 2012Accepted 28 July 2012Available online 31 July 2012Keywords:ConstraintsMinimal networkComplexityJoin decompositionStructure identificationDatabase theoryKnowledge compilation1. IntroductionThis paper deals with problems related to minimal constraint networks. First, the complexity of computing a solution toa minimal network is determined. Then, the problems of recognizing network minimality and network-decomposability arestudied.1.1. Minimal constraint networksIn his seminal 1974 paper [26], Montanari introduced the concept of a minimal constraint network. Roughly, a minimalnetwork is a constraint network where each partial instantiation corresponding to a tuple of a constraint relation can beextended to a solution. Each arbitrary binary network N having variables { X1, . . . , X v } can be transformed into an equivalentbinary minimal network M(N) by computing the set sol(N) of all solutions to N and creating for 1 (cid:2) i < j (cid:2) v a constraintci j whose scope is ( Xi, X j) and whose constraint relation consists of the projection of sol(N) to ( Xi, X j), and for 1 (cid:2) i (cid:2) va unary constraint ci whose scope is ( Xi) and whose constraint relation is the projection of sol(N) over ( Xi). The minimalnetwork M(N) is unique, and its solutions are exactly those of the original network, i.e., sol(N) = sol(M(N)).An example of a binary constraint network N is given in Fig. 1(a). This network has four variables X1, . . . , X4 which,for simplicity, all range over the same numerical domain {1, 2, 3, 4, 5}. Its solution, sol(N), which is the join of all relationsof N, is shown in Fig. 1(b). The minimal network M(N) is shown in Fig. 1(c).Obviously, M(N), which can be regarded as an optimally pruned version of N, is hard to compute. But computing M(N)may result in a quite useful knowledge compilation [21,5]. In fact, with M(N) at hand, we can answer a number of queries✩This paper is a significantly extended version of a paper with the same title presented at the 17th International Conference on Principles and Practiceof Constraint Programming (Gottlob, 2011, [17]). The present paper contains new results in addition to those of Gottlob (2011) [17]. Possible future updateswill be made available on CORR at http://arxiv.org/abs/1103.1604.E-mail address: georg.gottlob@cs.ox.ac.uk.0004-3702/$ – see front matter © 2012 Elsevier B.V. All rights reserved.http://dx.doi.org/10.1016/j.artint.2012.07.006G. Gottlob / Artificial Intelligence 191–192 (2012) 42–6043Fig. 1. A binary constraint network N, it solution sol(N), and its minimal network M(N).in polynomial time that would otherwise be NP-hard. Typically, these are queries that involve one or two variables only,for example, the queries “is there a solution for which X4 (cid:2) 3?” or “does N have a solution for which X2 < X1?” are affirmativelyanswered by a simple lookup in the relevant tables of M(N). For the latter query, for example, one just has to look intothe first relation table of M(N), whose tuple (cid:2)2, 1(cid:3) constitutes a witness. In contrast, in our example, the query “is therea solution for which X1 < X4?” is immediately recognized to have a negative answer, as the fourth relation of M(N) hasno tuple witnessing this inequality. An example of a slightly more involved non-Boolean two-variable query that can bepolynomially answered using M(N) is: “what is the maximal value of X2 such that X4 is minimum over all solutions?”. Again, onecan just “read off” the answer from the single relation of M(N) whose variables are those of the query. In our example inFig. 1, it is the penultimate relation of M(N), that can be easily used to deduce that the answer is 2.1.2. Computing solutions to minimal constraint networksIn applications such as computer-supported interactive product configuration, such queries arise frequently, but it wouldbe useful to be able to exhibit at the same time a full solution together with the query answer, that is, an assignment ofvalues to all variables witnessing this answer. However, it was even unclear whether the following problem is tractable:Given a non-empty minimal network M(N), compute an arbitrary solution to it. Gaur [11] formulated this as an openproblem. He showed that a stronger version of the problem, where solutions restricted by specific value assignments to apair of variables are sought, is NP-hard, but speculated that finding arbitrary solutions could be tractable. However, since theintroduction of minimal networks in 1974, no one came up with a polynomial-time algorithm for this task. This led Dechterto conjecture that this problem is hard [8]. Note that this problem deviates in two ways from classical decision problems:First, it is a search problem rather than a decision problem, and second, it is a promise problem, where it is “promised” that44G. Gottlob / Artificial Intelligence 191–192 (2012) 42–60the input networks, which constitute our problem instances, are indeed minimal – a promise whose verification is itselfNP-hard (see Section 4.1). We therefore have to clarify what NP-hardness means, when referring to such problems. Thesimplest and probably cleanest definition is the following: The problem is NP-hard if any polynomial algorithms solving itwould imply the existence of a polynomial-time algorithm for NP-hard decision problems, and would thus imply P = NP. Inthe light of this, Dechter’s conjecture reads as follows:Conjecture 1.1. (See Dechter [8].) Unless P = NP, computing a single solution to a non-empty minimal constraint network cannot bedone in polynomial time.While the problem has interested a number of researchers, it has not been solved until recently. Some progress was madeby Bessiere in 2006. In his well-known handbook article “Constraint Propagation” [4], he used results of Cros [6] to showthat no backtrack-free algorithm for computing a solution from a minimal network can exist unless the Polynomial Hierarchycollapses to its second level (more precisely, unless Σ p2 ). However, this does not mean that the problem is intractable.2A backtrack-free algorithm according to Bessiere must be able to recognize each partial assignment that is extensible toa solution. In a sense, such an algorithm, even if it computes only one solution, must have the potential to compute allsolutions just by changing the choices of the variable-instantiations made at the different steps. In more colloquial terms,backtrack-free algorithms according to Bessiere must be fair to all solutions. Bessiere’s result does not preclude the existenceof a less general algorithm that computes just one solution, while being unable to recognize all partial assignments, andthus being unfair to some solutions.= Π pThe simple example in Fig. 1, by the way, shows that the following naïve backtrack-free strategy is doomed to fail: Pickan arbitrary tuple from the first relation of M(N), expand it by a suitable tuple of the second relation, and so on. In fact,if we just picked the first tuple (cid:2)1, 1(cid:3) of the first relation, we could combine it with the first tuple (cid:2)1, 1(cid:3) of the secondrelation and obtain the partial instantiation X1 = X2 = X3 = 1. However, this partial instantiation is not part of a solution,as it cannot be expanded to match any tuple of the third relation. While this naïve strategy fails, one may still imagine theexistence of a more sophisticated backtrack-free strategy, that pre-computes in polynomial time some helpful data structurebefore embarking on choices. However, as we show in this paper, such a strategy cannot exist unless NP = P.In the first part of this paper, we prove Dechter’s conjecture by showing that every polynomial-time search algorithm A∗that computes a single solution to a minimal network can be transformed into a polynomial-time decision algorithm Afor the classical satisfiability problem 3SAT. The proof is carried-out in Section 3. We first show that each SAT instance canbe transformed in polynomial time into an equivalent one that is highly symmetric (Section 3.1). Such symmetric instances,which we call k-supersymmetric, are then polynomially reduced to the problem of computing a solution to a minimal binaryconstraint network (Section 3.2). We further consider the case of bounded domains, that is, when the input instances aresuch that the cardinality of the overall domain of all values that may appear in the constraint relation is bounded by somefixed constant c. By a simple modification of the proof of the general case, it is easily seen that even in the bounded domaincase, the problem of computing a single solution remains NP-hard (Section 3.3).Our hardness results for computing relations can be reformulated in terms of database theory. Every constraint net-work N can be seen as a relational database instance, where each constraint of N corresponds to a single relation instance.The set sol(N) of all solutions to a binary constraint network (or database instance) N is identical to the relation obtainedby performing the natural join of all relation instances of N. The minimal network M(N) is then a lossless decompositionof sol(N) according to the join dependency ∗[S], where S is the schema of M(N). Our main hardness result thus impliesthat it is coNP-hard to recover an arbitrary single tuple of a relation instance R (called a universal relation) from its losslessdecomposition according to a given single join dependency, when only this decomposition is given. Lossless decompositionsand universal relations have been studied for many decades, and they were recently related to hidden variable models inquantum mechanics [1,2].1.3. Minimality checking and structure identificationIn Section 4.1, we generalize and slightly strengthen a result by Gaur [11] by showing that it is NP-hard to determinewhether a k-ary network is minimal, even in case of bounded domains.In Section 4.2, we study the complexity of checking whether a network N consisting of a single constraint relation(typically of arity (cid:3) k) can be represented by an equivalent k-ary constraint network. Note that this is precisely the caseiff there exists a k-ary minimal network M equivalent to N, i.e., one such that sol(M) = sol(N). Dechter and Pearl [9]regarded this problem as a relevant complexity problem of structure identification for relational data, i.e., of checking whetheran element of a general class of objects (in this case, data relations) belongs to a structurally simpler subclass (in this case,k-decomposable relations). This problem is equivalent to the database problem of testing whether a given instance of a datarelation satisfies a specific join dependency. Dechter and Pearl conjectured that the problem is NP-hard for k (cid:3) 2. We provethis conjecture by showing the problem to be coNP-complete for each k (cid:3) 2.A special case considered in [9] is the one of bi-valued constraints, that is, constraints over the Boolean domain. For bi-valued constraints, the above structure identification problem is equivalent to testing whether a Boolean formula representedby the explicit list of all its models is equivalent to a k-CNF. For k = 2 this problem is known to be tractable (see [7,11]).Dechter and Pearl [9] conjectured it to be NP-hard for every fixed k > 2. In Section 4.3 we prove this conjecture and showG. Gottlob / Artificial Intelligence 191–192 (2012) 42–6045that deciding whether bi-valued relations are k-decomposable is coNP-complete for each fixed k > 2. Moreover, we show inSection 4.4 that the representability of tri-valued constraints (and more generally r-valued constraints for r (cid:3) 3) as a k-arynetwork is coNP-hard for each fixed k (cid:3) 2. Put together, our results allow us to trace the precise tractability frontier for theproblem of relational structure identification in terms of the domain cardinality and the parameter k. This is visualized inFig. 3 in Section 4.4.The paper is concluded in Section 5 by a brief discussion of the practical significance of our main result, a proposal forthe enhancement of minimal networks, and some hints at possible future research.2. Preliminaries and basic definitionsWhile most of the definitions in this section are adapted from the standard literature on constraint satisfaction, inparticular [8,4], we sometimes use a slightly different notation which is more convenient for our purposes.Constraints, networks, and solutions We assume a totally ordered infinite set (X, ≺) of variables. For Xi, X j ∈ X, Xi ≺ X jmeans that Xi is smaller than X j according to the “≺” ordering. We assume that all variables of constraint networks arefrom this set. A k-ary constraint c is a pair (scope(c), rel(c)). The scope scope(c) of c is a sequence ( Xi1 , Xi2 , . . . , Xik ) of k≺ · · · ≺ Xik , and where each variable Xi j has an associated finite domain dom( Xi j ).distinct variables from X, where Xi1} ofThe relation rel(c) of c is a subset of the Cartesian product dom( Xi1 ) × dom( Xi2 ) × · · · × dom( Xik ). The set { Xi1 , . . . , Xikall variables occurring in scope(c) is denoted by var(c). Given that each set of variables is totally ordered by ≺, we shallidentify each set U of variables, whenever convenient, with the list (cid:7)U of its elements ordered according to ≺. We thusmay write scope(c) = U instead of scope(c) = (cid:7)U . More generally, since the concepts of lists of distinct elements and orderedsets coincide, we may use set-theoretic notation to express facts about such lists. For example, if s denotes a scope, wemay write Xi ∈ s to express that Xi is a variable in this scope. If, moreover, U denotes a list (or even an unordered set) ofvariables, we may write s ⊆ U to say that each variable of s is also an element of U , and so on.≺ Xi2A constraint network N consists of a finite set var(N) = { X1, . . . , X v } of variables with associated domains dom( Xi) for1 (cid:2) i (cid:2) v, and a set of constraints cons(N) = {c1, . . . , cm}, where for 1 (cid:2) i (cid:2) m, var(ci) ⊆ var(N).(cid:2)If U ⊆ var(N) is a set of variables, then dom(U ) =X∈U dom( X). The domain dom(N) of a constraint network N isdefined by dom(N) = dom(var(N)). Theschema of N is the set schema(N) = {scope(c) | c ∈ cons(N)} of all scopes of theconstraints of N. If S is a schema, then var(S) denotes the set of all variables in the scopes of S. In particular, if S is theschema of network N, we have var(S) = var(N). We call N binary (k-ary) if arity(c) (cid:2) 2 (arity(c) (cid:2) k) for each constraintc ∈ cons(N).Let N be a constraint network. An instantiation mapping for a set of variables W ⊆ var(N) is a mapping θ : W −→dom(W ), such that for each X ∈ var(N), θ( X) ∈ dom( X). We call θ(W ) an instantiation of W . An instantiation of a propersubset W of var(N) is called a partial instantiation while an instantiation of var(N) is called a full instantiation (also totalinstantiation). A constraint c of N is satisfied by an instantiation mapping θ : W −→ dom(W ) if whenever var(c) ⊆ W ,then θ(scope(c)) ∈ rel(c). An instantiation mapping θ : W −→ dom(W ) is consistent if it is satisfied by all constraints. Byabuse of terminology, if θ is understood and is consistent, then we may also say that θ(W ) is consistent. A solution to aconstraint network N is a consistent full instantiation for N. The set of all solutions of N is denoted by sol(N). N is solvableiff sol(N) (cid:10)= ∅. Whenever useful, we will identify the solution set sol(N) with a single constraint whose scope is var(N)and whose relation consists of all tuples in sol(N). We assume without loss of generality, that for each set of variablesW ⊆ var(N) of a constraint network, there exists at most one constraint c such that var(c) = W . (In fact, if there are twoor more constraints with exactly the same variables in the scope, an equivalent single constraint can always be obtained byintersecting the constraint relations.)Complete networks The complete schema S Uk over a set of variables U denotes the schema consisting of all non-empty= {( X1), ( X2), ( X1, X2)}. If theconstraint scopes of arity at most k contained in U . For example, if U = { X1, X2}, then S Ukset of variables U is understood, we will write Sk instead of S Uk . A k-ary constraint network N is complete, if its schemais S var(N). For each fixed constant k, each k-ary constraint network N can be transformed by a trivial polynomial reductionk+). In fact, if (cid:5) (cid:2) k, then for each (ordered) set of variablesinto an equivalent complete k-ary network NW = { Xi1 , . . . , Xi(cid:5)} that is in no scope of N, we may just add the trivial constraint (cid:12)W with scope((cid:12)W ) = ( Xi1 , . . . , Xi(cid:5) ) andrel((cid:12)W ) = dom( Xi1 )× dom( Xi2 )×· · · × dom( Xi(cid:5) ). For this reason, we may, whenever useful, restrict our attention to completenetworks. Some authors, such as Montanari [26] who studies binary networks, assume by definition that all networks arecomplete, others, such as Dechter [8] make this assumption implicitly.with sol(N) = sol(N+Intersections of networks, containment, and projections Let N1 and N2 be two constraint networks defined over the sameschema S (that is, the same set S of constraint scopes). The intersection M = N1 ∩ N2 of N1 and N2 is the network havingvar(M) = var(N1) = var(N2), and having a constraint cs, for each s ∈ S, such that scope(cs) = s and rel(cs) = rel(cs2),where c1 and c2 are the constraints having scope s of N1 and N2, respectively. The intersection of arbitrary families ofconstraint networks defined over the same schema is defined in a similar way. For two networks N1 and N2 over the sameschema S, we say that c1 is contained in c2, and write N1 ⊆ N2, if for each s ∈ S, and for c1 ∈ cons(N1) and c2 ∈ cons(N2)1) ∩ rel(cs46G. Gottlob / Artificial Intelligence 191–192 (2012) 42–60with scope(c1) = scope(c2) = s, rel(c1) ⊆ rel(c2). If c is a constraint over a set of variables W = { X1, . . . , X v } and V ⊆ W ,then the projection ΠV (c) is the constraint whose scope is V , and whose relation is the projection over V of rel(c). Let cbe a constraint and S a schema consisting of one or more scopes contained in scope(c), then ΠS (c) = {Πs(c) | s ∈ S}.Minimal networks Let c be a constraint with var(c) = U . The projection ΠS U(c) will henceforth just denote by ΠSk (c). ThusΠSk (c) is the constraint network obtained by projecting c over all scopes in the schema S U(simply denoted by Sk), i.e.,kover all non-empty ordered lists of at most k variables from var(c). In particular, the constraints of ΠS2 (c) are precisely allΠW (c) such that W ⊆ var(c) is a unary or binary scope.kIt was first observed in [26] that for each binary constraint network N, there is a unique binary minimal network M(N)(cid:14)) = sol(N). Minimality here isthat consists of the intersection of all binary networks Nwith respect to the above defined “⊆”-relation among binary networks. More generally, for each k-ary network N there is a(cid:14)) =unique k-ary minimal network Mk(N) that is the intersection of all k-ary networks Nover schema Sk for which sol(Nsol(N). (For the special case k = 2 we have M2(N) = M(N).) The following is well known [26,27,8,4,19] and easy to see:over schema S2 for which sol(N(cid:14)(cid:14)(cid:14)for all k-ary networks N• Mk(N) = ΠSk (sol(N)).• Mk(N) ⊆ Nwith sol(N• A k-ary network N is satisfiable (i.e., has at least one solution) iff Mk(N) is non-empty.• A k-ary network N is minimal iff ΠSk (sol(N)) = N.• A k-ary network N is minimal iff Mk(N) = N.• A network N over schema Sk is minimal iff there exists a universal relation ρ for N, that is, a single constraint ρ such(cid:14)) = sol(N).(cid:14)that N = ΠSk (ρ). In this case N is said to be join consistent (see [19]).It is obvious that for k (cid:3) 2, Mk(N) is hard to compute. In fact, just deciding whether for a network N, Mk(N) is the emptynetwork is coNP-complete, because this decision problem is equivalent to deciding whether N has no solution. (Recall thatdeciding whether a network N has a solution is NP-complete [23].) In this paper, however, we are not primarily interestedin computing Mk(N), but in computing a single solution, in case Mk(N) has already been computed and is known.Graph-theoretic characterization of minimal networks An n-partite graph is a graph whose vertices can be partitioned into ndisjoint sets so that no two vertices from the same set are adjacent. It is well known (see, e.g., [31]) that each binary con-straint network N on n variables can be represented as an n-partite graph G N . The vertices of G N are possible instantiationsof the variables by their corresponding domain values. Thus, for each variable Xi and possible domain value a ∈ dom( Xi),there is a vertex X ai j withscope ( Xi, Y j) contains the tuple (a, b).1 Gaur [11] gave the following nice characterization of minimal networks: A solv-able2 complete binary constraint network N on n variables is minimal iff each edge of N is part of a clique of size n of G N .Note that by definition of G N as an n-partite graph, there cannot be any clique in G N with more than n vertices, and thusthe cliques of n vertices are precisely the maximum cliques of G N .j are connected by an edge in G N iff the relation of the constraint c Ni . Two vertices X ai and X bSatisfiability problems An instance C of the satisfiability (SAT) problem is a conjunction of clauses (often just written as a setof clauses), each of which consists of a disjunction (often written as set) of literals, i.e., of positive or negated propositionalvariables. Propositional variables are also called (propositional) atoms. If α is a set of clauses or a single clause, then wedenote by propvar(α) the set of all propositional variables occurring in α.A 3SAT instance is a SAT instance each clause of which is a disjunction of at most three literals. 3SAT is the problem ofdeciding whether a 3SAT instance is satisfiable.3. NP-hardness of computing minimal network solutionsTo show that computing a single solution to a minimal network is NP-hard, we will do exactly the contrary of whatpeople – or automatic constraint solvers – usually do whilst solving a constraint network or a SAT instance. While everybodyaims at breaking symmetries, we will actually introduce additional symmetry into a 3SAT instance and its correspondingconstraint network representation. This will be achieved by the Symmetry Lemma to be proved in the next section.3.1. The Symmetry LemmaThe following lemma shows that, for each fixed k (cid:3) 1, one can transform an arbitrary 3SAT instance C in polynomial) is satisfiable,. Beforetime into a satisfiability-equivalent highly symmetric SAT instance Ceach truth value assignment to any k variables of Cstating the lemma, let us formally define this notion of symmetry, which we refer to as supersymmetry.can be extended to a truth value assignment satisfying Csuch that, whenever C (and thus C∗∗∗∗1 We disregard unary relations of N here; in fact, each unary relation of a constraint network can be eliminated by appropriately restricting the domainof its scope variable.2 We here refer to solvability according to our definition; Gaur uses a different definition of this term.G. Gottlob / Artificial Intelligence 191–192 (2012) 42–6047Definition 3.1. For k (cid:3) 1, a SAT instance C is k-supersymmetric if C is either unsatisfiable or if for each set of k propositionalvariables {p1, . . . , pk} ⊆ propvar(C) and for each arbitrary truth value assignment η to {p1, . . . , pk}, there exists a satisfyingtruth value assignment τ for C that extends η. A SAT instance that is 2-supersymmetric is also called supersymmetric.Assume k < k. By the above definition, if a SAT instance C is k(cid:14)However, a k-supersymmetric SAT instance C is not necessarily also k(cid:14)(cid:14)-supersymmetric, then C is also k-supersymmetric.-supersymmetric.Lemma 3.1 (Symmetry Lemma). For each fixed integer k (cid:3) 1, there is a polynomial-time transformation T that transforms each 3SATsuch that C is satisfiable iff Cinstance C into a k-supersymmetric SAT instance Cis satisfiable.∗∗We illustrate the proof of Lemma 3.1 by an example. A full proof is given in Appendix A.Proof. (Illustration by Example) Consider the 3SAT instance C = C1 ∧ C2 ∧ C3, whereC1 = p ∨ ¬q ∨ rC2 = ¬p ∨ ¬qC3 =qClearly, the above 3SAT instance C , while satisfiable,is not even 1-supersymmetric, and therefore, a fortiori, notk-supersymmetric for any k (cid:3) 1. To see this, observe that the partial truth value assignment assigning false to q alwaysfalsifies clause C3, and can thus not be extended to a satisfying truth value assignment for C . In the sequel, we illustrate∗ = T (C).how C can be transformed by a polynomial-time transformation T into a satisfiable supersymmetric SAT instance CTo this aim we introduce to each propositional variable v of C a set New(v) of five new propositional variables. In particular,we haveNew(p) = {p1, p2, p3, p4, p5},New(q) = {q1, q2, q3, q4, q5},New(r) = {r1, r2, r3, r4, r5}.∗andWe now create Cfrom C by taking the conjunction of all clauses obtained by replacing in each clause of C each positiveliteral v in all possible ways by the disjunction v i ∨ v j ∨ vk of three elements v i, v j, vk ∈ New(v), and by replacing eachnegative literal ¬v in all possible ways by the disjunction ¬v i ∨ ¬v j ∨ ¬vk, where v i, v j, vk are elements of New(v). Eachclause is thus replaced by a multitude of other clauses that are all taken in conjunction. In particular, in our example,clause C1 will actually be replaced by the conjunction of the following 1000 clauses C 1p1 ∨ p2 ∨ p3 ∨ ¬q1 ∨ ¬q2 ∨ ¬q3 ∨ r1 ∨ r2 ∨ r3;1 . . . C 1000::1C 11:C 21:C 31. . .C 101::C 111. . .C 10001p1 ∨ p2 ∨ p3 ∨ ¬q1 ∨ ¬q2 ∨ ¬q3 ∨ r1 ∨ r2 ∨ r4;p1 ∨ p2 ∨ p3 ∨ ¬q1 ∨ ¬q2 ∨ ¬q3 ∨ r1 ∨ r2 ∨ r5;. . . . . .p1 ∨ p2 ∨ p3 ∨ ¬q1 ∨ ¬q2 ∨ ¬q3 ∨ r3 ∨ r4 ∨ r5;. . . . . .. . . . . ...p1 ∨ p2 ∨ p3 ∨ ¬q1 ∨ ¬q2 ∨ ¬q4 ∨ r1 ∨ r2 ∨ r3;. . . . . .. . . . . .. . . . . ...: p3 ∨ p4 ∨ p5 ∨ ¬q3 ∨ ¬q4 ∨ ¬q5 ∨ r3 ∨ r4 ∨ r5.Similarly, clause C2 = ¬p ∨ ¬q is replaced by the following 100 clauses C 1¬p1 ∨ ¬p2 ∨ ¬p3 ∨ ¬q1 ∨ ¬q2 ∨ ¬q3;:C 122 . . . C 1002::C 12. . .C 1002¬p1 ∨ ¬p2 ∨ ¬p3 ∨ ¬q1 ∨ ¬q2 ∨ ¬q4;.: ¬p3 ∨ ¬p4 ∨ ¬p5 ∨ ¬q3 ∨ ¬q4 ∨ ¬q5.. . . . . .. . . . . .Finally, clause C3 = p is replaced by the following 10 clauses C 13, . . . , C 103 ::C 13:C 23. . .C 103q1 ∨ q2 ∨ q3;q1 ∨ q2 ∨ q4;. . . . . .: q3 ∨ q4 ∨ q5.48G. Gottlob / Artificial Intelligence 191–192 (2012) 42–60The SAT instance C∗ = T (C) then consists of the conjunction of all these clauses:∧ C 13∧ · · · ∧ C 100∧ C 12C∧ · · · ∧ C 103 .We claim – and formally prove in Appendix A – that the above transformation from a 3SAT instance C to a SAT in-∧ · · · ∧ C 100012∗ = C 11stance Csatisfies the following two key facts:∗∗Fact 1: CFact 2: C∗∗is satisfiable iff C is satisfiable (in our example, Cis thus satisfiable). In fact, each satisfiable truth value assignment τto the propositional variables of C can be transformed to a satisfying truth value assignment τ ∗as follows: Ifτ (v) = true, then let τ ∗assign true to at least three propositional variables in New(v), and false to all others, and ifτ (v) = false, then let τ ∗assign false to at least three propositional variables in New(v), and true to all others. In ourexample, for instance, consider the truth value assignment τ satisfying C , where τ (p) = false and τ (q) = τ (r) = true.This truth value assignment satisfies r and therefore C1. The assignment τ ∗thus assigns true to at least threeatoms from New(r) = {r1, r2, r3, r4, r5}, assume, for example to {r1, r4, r5}. But each 3-element subset of New(r) has anon-empty intersection with each other non-empty three element subset of New(r), and thus with the set of atoms}. Therefore, each such clause C i∈ {C 1of each and every clause C i1 is satisfied. For example, C 11 has an r1 in1common with the set {r1, r4, r5}, and so must be satisfied by τ ∗for τ ∗(r1) = true. A similar argument holds for negativeliterals. Applying the same type of reasoning to all clauses Ci of C , given that each such Ci has at least one literal. In summary, τ ∗satisfied by τ , all clauses C. Vice versa, we show in the full proofthat if Cis satisfiable, then so must be C .are satisfied by τ ∗1, . . . , C 1000satisfies Cji of Cto Cto C∗∗∗∗∗1∗∗for Csatisfying our example-instance Con the elements of New(p) = {p1, . . . , p5}. According to the construction rules for τ ∗is supersymmetric. Intuitively, this is due to the great choice of truth value assignments to the propositionalvariables in New(v), when constructing a satisfying assignment τ ∗, as above, from an assignment τ for C .Imagine, for illustration, we’d like to construct a truth value assignment τ ∗, such thatτ ∗(p1) = true and τ ∗(q3) = false. Note that no truth value assignment to instance C can actually satisfy p or falsify q.Notwithstanding, we are able to find an appropriate τ ∗with the desired properties. We start with an arbitrary satisfyingtruth value assignment τ to C , for example, the one where τ (p) = false and τ (q) = τ (r) = true. To construct τ ∗, let usfirst define τ ∗in the previousparagraph, given that τ (p) = false, τ ∗must assign false to at least three elements of New(p), but not necessarily toall elements of New(p). This leaves us the freedom of assigning true to p1. So, we can, for example, assign false top2, p3, p4, and p5, and true to p1. Similarly, given that τ (q) = true, τ ∗must assign true to at least three elementsof New(q), which can be done while fulfilling at the same time our requirement that τ ∗(q3) = false. For example, letτ ∗(q1) = τ ∗(q2) = τ ∗(q5) = true and τ ∗(q3) = τ ∗(q4) = false. Finally, the only requirement regarding the truth valuesassigned by τ ∗to the elements of New(r) is that at least three of these propositional variables be assigned true. Thus,for example, let τ ∗(r1) = τ ∗(r2) = · · · = τ ∗(r5) = true. In summary, it is easy to see (and actually follows from Fact 1)that the truth value assignment τ ∗extends the initially given partialtruth value assignment τ ∗(p1) = true and τ ∗(q3) = false. More generally, for every pair v, w of propositional variablesthat extends ηof Cand satisfies C, and for every truth value assignment η to {v, w}, one can construct a truth value assignment τ ∗is 2-supersymmetric, i.e., supersymmetric.constructed this way satisfies C. Moreover, τ ∗. This shows that C∗∗∗∗As easily seen, the transformation from an arbitrary 3SAT instance C to the corresponding Cis polynomial-time com-putable. Together with Facts 1 and 2, this informally proves the Symmetry Lemma for k = 2. For k > 2, the proof isanalogous. (cid:2)∗Remark. The concept of supersymmetry is somewhat related to the notions of quadrangle and subquadrangle defined in [30]and further discussed in [20]. A quadrangle is a single constraint c that is satisfied for all value assignments that assign anyarbitrary value from dom( X) to each variable X in scope(c). Thus, the constraint relation rel(c) of a quadrangle c simplyconsists of a Cartesian product of domains. An n-ary constraint c is a subquadrangle if each projection of c to n − 1 orfewer variables from scope(c) is a quadrangle. Generalizing this notion, we define a k-subquadrangle to be a constraint, allof whose projections to k variables are quadrangles. In this context, Lemma 3.1 may be reformulated as follows: For each∗)k (cid:3) 1, every satisfiable 3SAT instance C can be transformed to a satisfiable SAT instance Cis a k-subquadrangle.whose solution relation sol(C∗3.2. Intractability of computing solutionsThe Symmetry Lemma is used for proving our main intractability result.Theorem 3.1. For each fixed constant k (cid:3) 2, unless NP = P, computing a single solution from a minimal k-ary constraint network Ncannot be done in polynomial time. The problem remains intractable even if the cardinality of each variable-domain is bounded by afixed constant.Proof. We first prove the theorem for k = 2. Assume A is an algorithm that computes in time p(n), where p is somepolynomial, a solution A(N) to each non-empty minimal binary constraint network N of size n. We will construct apolynomial-time 3SAT-solver Afrom A. The theorem then follows.∗G. Gottlob / Artificial Intelligence 191–192 (2012) 42–6049Let us first define a simple transformation S from SAT instances to equivalent binary constraint networks. S transformsconjunctions K = K1 ∧ · · · ∧ Kr of at least two clauses into binary constraint networks S(K ) = N K as follows. The set ofvariables var(N K ) is defined by var(N K ) = {K1, . . . , Kr}. For each variable K i of N K , the domain dom(K i) consists exactlyof all literals appearing in K i . For each distinct pair of clauses (K i, K j), i < j, there is a constraint ci j having scope(ci j) =(K i, K j) and rel(ci j) = (dom(K i) × dom(K j)) − {(p, p), (p, p) | p ∈ propvar(K )}. Moreover, for each variable K i there is a unaryconstraint ci whose scope contains the single variable K i , such that rel(ci) = dom(K i). It is easy to see that K is satisfiableiff N K is solvable. Basically, N K is solvable, iff we can pick one literal per clause such that the set of all picked literalscontains no atom together with its negation. But this is just equivalent to the satisfiability of K . The transformation S isclearly polynomial-time computable.Now consider constraint networks NC ∗ = S(C∗ = T (C). In a precise sense, NC ∗ inherits the high symmetry present in Cis obtained via transformation T as in Lemma 3.1 from some3SAT instance C , i.e., Cis satisfiable,then, by Lemma 3.1, for every pair (cid:5)1, (cid:5)2 of non-contradictory literals, there is a satisfying assignment that makes both(and thus C ) is satisfiable, for every constraint ci j , we may pick each pair ((cid:5)1, (cid:5)2) in rel(ci j) as partliterals true. Thus, if C∗of a solution, and thus no such pair is useless. Moreover, if Cis satisfiable, then, clearly, each value in the relations of each∗– and thus C – is satisfiable, then M(NC ∗ ) = NC ∗ , which meansunary constraint ci is part of a solution. It follows that if Cthat NC ∗ is minimal. We thus have:. In fact, if C∗), where C∗∗∗∗(∗) If C is satisfiable then NC ∗ is non-empty and minimal.We are now ready for specifying our 3SAT-solver A∗rithm Aloss of generality that C has at least two clauses. Ais also illustrated by the flowchart in Fig. 2. The input of Aworks as follows:∗∗that works in polynomial time, and hence witnesses NP = P. Algo-is a 3SAT input instance C . We here assume without∗1. Apply transformation T to C and get C∗ := T (C).∗Note: Cis supersymmetric and C2. Apply transformation S to C∗and get NC ∗ := S(Csatisfiable ⇔ C satisfiable.3. Run A on input NC ∗ for p(|NC ∗ |) steps; denote by w the output at this point.is satisfiable iff C is.∗).Note: NC ∗ solvable ⇔ C∗∗∗Note: If C (and thus Cunsolvable, and w is the empty string or any string other than a solution to NC ∗ .) is satisfiable, then NC ∗ is a solvable minimal network, and thus w is a solution to NC ∗ ; otherwise NC ∗ is4. Check if w is a solution to NC ∗ .5. If w is not a solution to NC ∗ then output “C unsatisfiable” and stop.Note: In fact, if w is not a solution to NC ∗ then NC ∗ is either empty or non-minimal. By the contrapositive of Fact (∗), C must thenbe unsatisfiable.6. If w is a solution to NC ∗ then output “C satisfiable” and stop.Note: If w is a solution, then NC ∗ is solvable, and thus Cand C are satisfiable.∗Each step of A∗polynomial p. Arequires polynomial time only. The polynomial runtime of step 3 depends parametrically on the fixed∗is thus a polynomial-time 3SAT solver. The theorem for k = 2 follows.Fig. 2. Flowchart of the 3SAT-solver A∗.50G. Gottlob / Artificial Intelligence 191–192 (2012) 42–60Note that C∗, as constructed in the proof of Theorem 3.1, is a 9SAT instance, hence the cardinality of the domain of eachvariable of NC ∗ is bounded by 9.For k > 2, the proof is analogous, the main change being that the transformation S now creates an (cid:5)-ary constraint cLis as constructedfor each (ordered) set L of (cid:5) (cid:2) k clauses from C . The resulting constraint network NC ∗ = S(Cin Lemma 3.1 then does the job. (cid:2)∗), where C∗3.3. The case of bounded domainsTheorem 3.1 states that the problem of computing a solution from a non-empty minimal binary network is intractableeven in case the cardinalities of the domains of all variables are bounded by a constant. However, if we take the totaldomain dom(N), which is the set of all literals of C, its cardinality is unbounded. This notwithstanding, the followingsimple corollary to Theorem 3.1 shows that even in case |dom(N)| is bounded, computing a single solution from a minimalnetwork N is hard.∗Corollary 3.1. For each fixed k (cid:3) 2, unless NP = P, computing a single solution from a minimal k-ary constraint network N cannot bedone in polynomial time, even in case |dom(N)| is bounded by a constant.Proof. We prove the result for k = 2; for higher values of k, the proof is totally analogous. The key fact we exploit here isthat each variable Ka of NC ∗ in the proof of Theorem 3.1 has a domain of exactly nine elements, corresponding to the nineliterals occurring in clause Ka of C. We “standardize” these domains by simply renaming the nine literals for each variableby the numbers 1 to 9. We thus get an equivalent minimal constraint network with a total domain of cardinality 9. (cid:2)∗4. Minimal network recognition and structure identificationIn this section we first deal with the complexity of recognizing whether a k-ary network M is the minimal network of ak-ary network N (Section 4.1). We then study the problem of deciding whether a k-ary network M is the minimal networkof a single constraint (Section 4.2).4.1. Minimal network recognitionAn algorithmic problem of obvious relevance is recognizing whether a given network is minimal. Using the graph-theoretic characterization of minimal networks described in Section 2, Gaur [11] has shown the following for binarynetworks:Proposition 4.1. (See Gaur [11].) Deciding whether a complete binary network N is minimal is NP-complete under Turing reduc-tions.We generalize Gaur’s result to the k-ary case and slightly strengthen it by showing NP-completeness under the standardnotion of polynomial-time many-one reductions:Theorem 4.1. For each k (cid:3) 2, deciding whether a complete k-ary network N is minimal is NP-complete, even in case of boundeddomain sizes.Proof. Membership in NP is easily seen: We just need to guess a candidate solution st from sol(N) for each of the polyno-mially many tuples t of each constraint c of N, and check in polynomial time that st is effectively a solution and that theprojection of st over scope(c) yields t. For proving hardness, revisit the proof of Theorem 3.1. For each k (cid:3) 2, from a 3SATinstance C , we there construct in polynomial time a highly symmetric k-ary network with bounded domain sizes NC ∗ , suchthat NC ∗ is minimal (i.e., Mk(NC ∗ ) = NC ∗ ) iff C is satisfiable. This is clearly a standard many-one reduction from 3SAT tonetwork minimality. (cid:2)A result in database theory similar to Theorem 4.1 was shown in [19], where it was proven that determining whethera set of database relations is join consistent (i.e., admits a universal relation) is NP-complete. This was actually proven forsets of binary relations, however not over schema Sk. Here we showed that this also holds for complete k-ary networks, i.e.,for sets of relations over the specific schemas Sk, for each k (cid:3) 2.4.2. Structure identification and k-representabilityThis section as well as Sections 4.3 and 4.4 are dedicated to the problem of representing single constraints (or single-constraint networks) through equivalent k-ary minimal networks. By a slight abuse of terminology, when there is no dangerof confusion, we will often identify a single-constraint network {ρ} with its unique constraint ρ, and for tuples t of therelation rel(ρ) of the constraint ρ, we may write t ∈ ρ instead of t ∈ rel(ρ).G. Gottlob / Artificial Intelligence 191–192 (2012) 42–6051Definition 4.1. A complete k-ary network M is a minimal k-ary network of ρ iff1. sol(M) = ρ, and2. every tuple occurring in some constraint r of M is the projection of some tuple t of ρ over scope(r).We say that a constraint relation ρ is k-representable if there exists a (not necessarily complete) k-ary constraint net-work M such that sol(M) = ρ. The following proposition seems to be well known and follows very easily from Definition 4.1anyway.Proposition 4.2. Let ρ be a constraint. The following three statements are equivalent:1. ρ has a minimal k-ary network;2. sol(ΠSk (ρ)) = ρ;3. ρ is k-representable.Note that the equivalence of ρ being k-representable and of ρ admitting a minimal k-ary network emphasizes theimportance and usefulness of minimal networks. In a sense this equivalence means that the minimal k-ary network of ρ, ifit exists, already represents all k-ary networks that are equivalent to ρ.The complexity of deciding whether a minimal k-ary network for a relation ρ exists has been stated as an open prob-lem by Dechter and Pearl in [9]. More precisely, Dechter and Pearl consider the equivalent problem of deciding whethersol(ΠSk (ρ)) = ρ holds, and refer to this problem as a problem of structure identification in relational data [9]. The idea is toidentify the class of relations ρ that have the structural property of being equivalent to the k-ary network ΠSk (ρ), and thus,of being k-representable. Dechter and Pearl formulated the following conjecture:Conjecture 4.1. (See Dechter and Pearl [9].) For each fixed positive integer k (cid:3) 2, deciding whether sol(ΠSk (ρ)) = ρ is NP-hard.3As already observed by Dechter and Pearl in [9], there is a close relationship between the k-representability of constraintrelations and a relevant database problem. Let us briefly digress on this. It is common knowledge that a single constraint ρcan be identified with a data relation in the context of relational databases (cf. [8]). The decomposition of relations playsan important role in the database area, in particular in the context of normalization [24]. It consists of decomposing arelation ρ without loss of information into smaller relations whose natural join yields precisely ρ. If ρ is a concrete datarelation (i.e., a relational instance), and S is a family of subsets (subschemas) of the schema of ρ, then the decompositionof ρ over S consists of the projection ΠS = {Πs(ρ) | s ∈ S} of ρ over all schemes in S. This decomposition is lossless iff thenatural join of all Πs(ρ) yields precisely ρ, or, equivalently, iff ρ satisfies the join dependency ∗[S]. We can thus reformulatethe concept of k-decomposability in terms of database theory as follows: A relation ρ is k-decomposable iff it satisfies thejoin dependency ∗[Sk], i.e., iff the decomposition of ρ into schema Sk is lossless. The following complexity result was shownas early as 1981 in [25].4Proposition 4.3. (See Maier, Sagiv, and Yannakakis [25].) Given a relation ρ and a family S of subsets of the schema of ρ, it is coNP-complete to determine whether ρ satisfies the join dependency ∗[S], or equivalently, whether the decomposition of ρ into schema S islossless.Proposition 4.3 is weaker than Conjecture 4.1 and does not by itself imply it, nor so does its proof given in [25]. Infact, Conjecture 4.1 speaks about the very specific sets Sk for k (cid:3) 2, which are neither mentioned in Proposition 4.3nor used in its proof. Actually, the NP-hardness proof in [25] transforms 3SAT into the problem of checking a join de-pendency ∗[S] over schema S = (S1, . . . , Sm+1), where one of the relation schemas, namely Sm+1 is of unbounded arity(depending on the input 3SAT instance), while the others are of arity 4. To prove Conjecture 4.1, that refers to the spe-cific schema Sk in which all relations have arity at most k, we thus needed to develop a new and independent hardnessargument.Theorem 4.2. For each fixed integer k (cid:3) 2, deciding for a single constraint ρ whether sol(ΠSk (ρ)) = ρ, that is, whether ρ isk-decomposable, is coNP-complete.3 Actually, the conjecture stated in [9] is somewhat weaker: Given a relation ρ and an integer k, deciding whether sol(ΠSk (ρ)) = ρ is NP-hard. Thus kis not fixed and is part of the input instance. However, from the context and use of this conjecture in [9] it is clear that Dechter and Pearl actually intendNP-hardness for each fixed k (cid:2) 2.4 As mentioned by Dechter and Pearl [9], Jeff Ullman has proved this result, too. In fact, Ullman, on a request by Judea Pearl, while not aware of thespecific result in [25], has produced a totally independent proof in 1991, and sent it as a private communication to Pearl. The result is also implicit inMoshe Vardi’s 1981 PhD thesis.52G. Gottlob / Artificial Intelligence 191–192 (2012) 42–60Proof. We show that deciding whether sol(ΠSk (ρ)) (cid:10)= ρ is NP-complete.Membership. Membership in NP already follows from Proposition 4.3, but we give a short proof of it here for sake of self-containment. Clearly, ρ ⊆ sol(ΠSk (ρ)). Thus sol(ΠSk (ρ)) (cid:10)= ρ iff the containment is proper, which means that there exists atuple t0 in sol(ΠSk (ρ)) not contained in ρ. One can guess such a tuple t0 in polynomial time and check in polynomial timethat for each (cid:5) (cid:2) k, each (cid:5)-tuple of variables Xi1 , . . . , Xi(cid:5) of var(ρ), the projection of t0 to ( Xi1 , . . . , Xi(cid:5) ) is indeed a tuple ofthe corresponding constraint of Sk. Thus determining whether sol(ΠSk (ρ)) (cid:10)= ρ is in NP.Hardness. We first show hardness for the binary case, that is, the case where k = 2. We use the NP-hard problem3COL of deciding whether a graph G = (V , E) with set of vertices V = {v 1, . . . , vn} and edge set E is 3-colorable. Let Gbe given as input instance. We assume without loss of generality that G has at least three vertices. Let r, g, b be threedata values standing for the three colors red, green, and blue, respectively. Let N3COL be the constraint network defined+as follows. The set of variables var(N3COL) = { X1, . . . , Xn}. The schema S2 of N3COL consists of all exactly binary scopes( Xi, X j) where Xi ≺ X j , and dom( Xi) = {r, g, b} for 1 (cid:2) i (cid:2) n. Moreover, for all 1 (cid:2) i < j (cid:2) n, the constraint ci j with schema( Xi, X j) has the following constraint relation rel(ci j) = ri j : if (i, j) ∈ E, then ri jis the set of pairs representing all legalvertex colorings, i.e., ri j = {(r, g), (g, r), (r, b), (b, r), (g, b), (b, g)}; otherwise ri j = {r, g, b}2. N3COL is thus a straightforward+2 , and obviously G is 3-colorable iff sol(N3COL) (cid:10)= ∅. Thus, deciding whether sol(N3COL) (cid:10)= ∅encoding of 3COL over schema Sis NP-hard.We construct from N3COL a single constraint ρ with schema { X1, . . . , Xn} as follows. The domain dom(ρ) contains thecolor constants r, g, and b, as well as special “tuple identifiers” to be detailed below. For each constraint ci j of N3COL, andfor each tuple (a, b) ∈ ri j , ρ contains a tuple t whose Xi and X j values are a and b, respectively, and whose X(cid:5) value, forall 1 (cid:2) (cid:5) (cid:2) n, (cid:5) (cid:10)= i, (cid:5) (cid:10)= j, is a constant dti j , different from all values used in other tuples, whose purpose is to act as a tupleidentifier. This concludes the description of the transformation from a 3COL instance G = (V , E) to a constraint networkN3COL and further to a constraint ρ. Clearly, this transformation is feasible in polynomial time. We claim the following:Claim. sol(ΠS2 (ρ)) (cid:10)= ρ iff sol(N3COL) (cid:10)= ∅ (and thus iff G is 3-colorable).This claim clearly implies the NP-hardness of deciding sol(ΠSk (ρ)) (cid:10)= ρ. Let us prove that the claim holds.We start with the if direction. Assume sol(N3COL) (cid:10)= ∅. Then G = (V , E) is 3-colorable and hence there exists a functionf : V −→ {r, g, b} such that for each edge (cid:2)v i, v j(cid:3) ∈ E, f (v i) (cid:10)= f (v j). Let t be the tuple defined by ∀1 (cid:2) i (cid:2) n, t[ Xi] = f (v i).Then, by definition of t and ρ, for each 1 (cid:2) i < j (cid:2) n, t[ Xi, X j] ∈ Π Xi , X j (ρ) and fort each 1 (cid:2) i (cid:2) n, t[ Xi] ∈ Π Xi (ρ). Therefore,t ∈ sol(ΠS2 (ρ)). However, t /∈ ρ, because each tuple of ρ, unlike t, has some tuple identifiers as components. It thus followsthat sol(ΠS2 (ρ)) (cid:10)= ρ.Let us now show the only-if direction of the claim. Assume sol(ΠS2 (ρ)) (cid:10)= ρ. Given that, as already noted, ρ ⊆sol(ΠS2 (ρ)), there must exist a tuple t0 ∈ sol(ΠS2 (ρ)) such that t0 /∈ ρ. We show that t0 can contain values from {r, g, b}only, and must, moreover, be a solution to N3COL. Assume a tuple identifier d = dti j occurs as a component of t0. By con-struction of ρ, d occurs in precisely one single tuple t of ρ. It follows that each relation of ΠS2 (ρ) has at most one tuplecontaining d, and therefore the join of all relations of ΠS2 (ρ) contains a single tuple only in which d occurs as data value,namely t itself. Therefore, t0 = t, and hence t0 ∈ ρ, which contradicts our assumption that t0 /∈ ρ. We have thus shown thatt0 cannot contain any tuple identifier at all, and can be made of “color elements” from {r, g, b} only. However, by definitionof ρ, each tuple ti j ∈ {r, g, b}2 occurring in a relation with schema ( Xi, X j) of ΠS2 (ρ) also occurs in the correspondingrelation of N3COL, and vice versa. Thus sol(ΠS2 (ρ)) (cid:10)= ρ iff sol(N3COL) (cid:10)= ∅ iff G is 3-colorable, which proves our claim.For each fixed k > 2 we can apply exactly the same line of reasoning. We define NkkCOL as the complete network onvariables { X1, . . . , Xn} of all k-ary correct “coloring” constraints, where the relation with schema Xi1 , . . . , Xik expresses thecorrect colorings of vertices v i1 , . . . , v ik of graph G. We then define ρ in a similar way as for k = 2: each k-tuple of arelation of NkkCOL is extended by use of (possibly multiple occurrences of) a tuple identifier to an n-tuple of ρ. Given thatk is fixed, ρ can be constructed in polynomial time, and so ΠSk (ρ). It is readily seen that each tuple of sol(ΠSk (ρ)) thatcontains a tuple identifier is already present in ρ because for each tuple identifier value d, each relation of ΠSk (ρ) containsat most one tuple involving d. Hence, any tuple in sol(ΠSk (ρ)) − ρ involves values from {r, g, b} only, and is a solution tokCOL and thus a valid 3-coloring of G. (cid:2)Nk4.3. The case of bi-valued relationsLet us now turn our attention to bi-valued relations ρ, that is, relations ρ over a binary domain. As explained in Sec-tion 3.2 of [9], such bi-valued relations are of special interest, as that they correspond to Boolean formulas. For example,a 3CNF can be seen as a bi-valued constraint network of ternary relations, and a single bi-valued relation ρ corresponds toa DNF. The problem of structure identification in the bi-valued case thus corresponds to relevant identification and learn-ability questions about Boolean formulas; we refer the reader to [9] for details. In this context, it would be interestingto know whether, or for which parameter k, Theorem 4.2 carries over to the bi-valued case. While the coNP-membershipclearly applies to the special case of a bi-valued ρ, the hardness part of that proof uses a multiple-valued relation ρ anddoes not allow us to derive a hardness result for the bi-valued case. In fact, the relations ρ constructed in the proof of The-G. Gottlob / Artificial Intelligence 191–192 (2012) 42–6053orem 4.2 from arbitrary 3COL instances are not bi-valued and actually have unbounded domains dom(ρ) containing |ρ| + 3elements5: the “color constants” r, g, b, and the |ρ| tuple identifiers dtAs noted in [7,11], for k = 2 and bi-valued domains, the problem of deciding whether sol(ΠSk (ρ)) = ρ is tractable.It can actually be reduced to 2SAT. But what about for values k (cid:3) 3? Dechter and Pearl made the following conjecture(Conjecture 3.27 in [9]):i, j .Conjecture 4.2. (See Dechter and Pearl [9].) For each fixed positive integer k (cid:3) 3, deciding for a bi-valued relation ρ whethersol(ΠSk (ρ)) = ρ is NP-hard.6We are able to confirm this conjecture.Theorem 4.3. For each fixed integer k (cid:3) 3, deciding for a single bi-valued constraint ρ whether sol(ΠSk (ρ)) = ρ, that is, whether ρis k-decomposable, is coNP-complete.The rather involved proof of this theorem is given in Appendix B. The hardness part is similar in spirit to the one ofTheorem 4.2, except for two important changes that are due to the requirement of a two-valued domain. First we encode3SAT rather than 3COL, in order to achieve a binary domain. However, there is still the problem of the tuple identifiers (thevalues dti, j in the proof of Theorem 4.2). They are values from an unbounded domain. We therefore use a specific bit-vectorencoding that allows us to represent tuple identifiers in binary format. This is, however, not totally trivial. The difficulty liesin the fact that in the relations of the projection ΠSk (ρ) we do no longer have full bit vectors at our disposal, but onlyk-bit projections of such bit vectors. Sophisticated coding tricks are used for coping with this problem, and for obtaining acorrect reduction.Theorem 4.3 has a corollary, which we here formulate in the terminology of Dechter and Pearl [9].Corollary 4.1. For fixed k (cid:3) 3, the class of k-CNFs is not identifiable relative to all CNFs (unless P = NP).The above means the following. If a CNF φ (or, more generally, a Boolean function φ) is given by the set of all itsmodels (i.e., by a bi-valued relation, each tuple of which corresponds to a model), then it is NP-hard to decide whether φ isequivalent to a k-CNF. We refer the reader to [9] for a more detailed account of k-CNF identification and its equivalence tothe problem of whether a bi-valued relation ρ is k-decomposable. To conclude this topic, let us note that the representationof a Boolean function φ by the explicit set of all its models, i.e., by all satisfying truth value assignments, is also known asthe onset of φ [32]. The above corollary thus states that, for fixed k (cid:3) 3, it is NP-hard to decide whether a Boolean functionspecified by its onset is equivalent to a k-CNF.74.4. Further strengthening and tractability frontierThe technique used to prove Theorem 4.3 can be used to strengthen Theorem 4.2, and to show that it actually also holdsfor tri-valued constraints ρ.Theorem 4.4. For each fixed integer k (cid:3) 2, deciding for a single tri-valued constraint ρ whether sol(ΠSk (ρ)) = ρ, that is, whether ρis k-decomposable, is coNP-complete.The proof of this theorem is given in Appendix C. We there use a transformation from 3COL from a graph G = (V , E)as described in the proof of Theorem 4.2 by applying, in addition, similar vectorization techniques as in the proof of Theo-rem 4.3.The above result, together with Theorem 4.3, and with the fact that the 2-representability of binary networks is feasiblein polynomial time (see [7]), and with the facts that the 0-representability and 1-representability of each network andthe k-representability of 1-valued networks are trivially tractable, gives us the following precise characterization of thetractability of deciding whether sol(ΠSk (ρ)) = ρ:Theorem 4.5. For the class of i-valued relations ρ, deciding sol(ΠSk (ρ)) = ρ is tractable iff i = 1 or (i = 2 and k (cid:2) 2). In all othercases, the problem is coNP-complete.Fig. 3 illustrates this tractability frontier.5 Here |ρ| = |rel(ρ)| designates the number of tuples in the constraint relation of the constraint ρ.6 Note that in [9], the parameter k is not explicitly required to be fixed, however, from the context it is clear that the present stronger version of theconjecture was actually intended. Moreover, Conjecture 3.27 in [9] was formulated in terms of k-CNFs rather than in a purely relational setting. To avoidadditional definitions and terminology, we have restated an equivalent relational formulation here. In particular, we have replaced the term M(ΓSk (ρ)) inthe original formulation by the equivalent term sol(ΠSk (ρ)).7 While we have not found this result in the literature on Boolean functions, we cannot totally exclude that it has been independently derived, maybe ina different context or using a different formalism.54G. Gottlob / Artificial Intelligence 191–192 (2012) 42–60Fig. 3. Tractability Frontier for the k-decomposability of i-valued relations ρ.5. Summary, discussion, and future researchIn this paper we have tackled and solved long standing complexity problems related to minimal constraint networks:• We solved an open problem posed by Gaur [11] in 1995, and later by Dechter [8], by proving Dechter’s conjecture andshowing that computing a solution to a minimal constraint network is NP-hard.• We proved a conjecture on structure identification in relational data made in 1992 by Dechter and Pearl [9]. In par-ticular, we showed that for k (cid:3) 2, it is coNP-complete to decide whether for a single constraint (or data relation) ρ,sol(ΠSk (ρ)) = ρ, and thus whether ρ is k-decomposable.• We also proved a refined conjecture of Dechter and Pearl [9], showing that the above problem remains coNP-hard evenif ρ is a bi-valued constraint, in case k (cid:3) 3. A consequence of this is the NP-hardness of identifying k-CNFs relative tothe class of all CNFs (when represented by the explicit enumeration of their models).• We finally proved that deciding whether sol(ΠSk (ρ)) = ρ is coNP-complete for tri-valued relations and k (cid:3) 2. Togetherwith our other results on structure identification, this allowed us to trace the precise tractability frontier for this prob-lem.We wish to make clear that our hardness result about computing solutions to minimal networks does not mean that wethink minimal networks are useless. To the contrary, we are convinced that network minimality is a most desirable propertywhen a solution space needs to be efficiently represented for applications such as computer-supported configuration [10].For example, a user interactively configuring a PC constrains a relatively small number of variables, say, by specifying amaximum price, a minimum CPU clock rate, and the desired hard disk type and capacity. The user then wants to quicklyknow whether a solution exists, and if so, wants to see it. For a k-ary minimal constraint network, the satisfiability ofqueries involving k variables only can be decided in polynomial time. However, our Theorem 3.1 states that, unless NP = P,in case the query is satisfiable, there is no way to witness the satisfiability by a complete solution (in our example, byexhibiting a completely configured PC satisfying the user requests).Our Theorem 3.1 thus unveils a certain deficiency of minimal networks, namely, the failure of being able to exhibit fullsolutions. However, we have a strikingly simple proposal for redressing this deficiency. Rather than just storing (cid:5)-tuples(where (cid:5) (cid:2) k) in a k-ary minimal network Mk(N), we may store a full solution tcoincides+k (N) is not harder to obtainwith t on the (cid:5) variables of t. Call this extended minimal network Mthan Mk(N). Moreover, in practical terms, given that the known algorithms for computing Mk(N) from N require to checkfor each (cid:5)-tuple t whether it occurs in some solution ton the fly for each “good” tuple t?+k (N) is still polynomial, and at most by a factor |var(N)| larger than the size of Mk(N). OneNote also that the size of Mmay even go further and store not just a single solution, but the K best solutions (according to some predefined preferenceordering) whose values coincide with those of t with each tuple t of Mk(N). This allows one to answer top K queries with atmost k variables in polynomial time, once Mk(N) has been compiled. An example would be: show me the 5 cheapest laptopsfulfilling φ, where φ constrains k variables only.+k (N). Complexity-wise, Mwith each (cid:5)-tuple, where t, why not just memorize t++++For practical applications it is not always optimal to consider the complete schemas Sk as defined here. In the conferenceversion [17] of this paper, Sk was defined to contain only all exactly k-ary relations over a given set of variables, rather thanall at most k-ary relations. It is easy to see that the relations with scopes of fewer than k variables are redundant and canindeed be omitted (they can always be obtained via projections from the exactly k-ary relations). The only reason why weused the complete schemas in the present journal version is that we wanted to use exactly the same definition as in thestandard references [26,8]. However, yet more liberal definitions are possible. For example, Lecoutre [22] defines a constraintnetwork N over an arbitrary schema S to be minimal if N = ΠS (sol(N)). Clearly, all our complexity bounds carry over tothis more liberal setting: the lower bounds are directly inherited, as all instances in our settings are also instances of themore liberal setting, and the upper bounds are obtained by a trivial adaptation of the proofs of our existing upper bounds.+k (N):An interesting problem for future research is the following. We may issue queries of the following form against MSELECT A SOLUTION WHERE φ. Here φ is some Boolean combination on constraints on the variables of N. Queries,where φ is a simple combination of range restrictions on k variables can be answered in polynomial time. But there aremuch more complicated queries that can be answered efficiently, for example, queries that involve aggregate functions+k (N) forand/or re-use of quantified variables. It would thus be nice and useful to identify very large classes of queries to Mwhich a single solution – if it exists – can be found in polynomial time.Another relevant research problem is related to the projection ΠS∗ (sol(N)) of the solution sol(N) of a (not necessarilyfor distributed constraintbinary) constraint network N to a user-defined schema S, and to the further use of the schema S∗∗G. Gottlob / Artificial Intelligence 191–192 (2012) 42–6055solving. The projection of the solution space to specific sets of variables is used in the context of system configuration,when a system is jointly configured by a number of engineers, each having access to a projection of the solution spaceonly [33]. The problem of computing a solution ΠS∗ (sol(N)) is generally NP-hard, and remains NP-hard in many special∗ = S2 (see Theorem 3.1). We would like to investigate relevant restrictionscases, e.g. if N is binary and, at the same time Sthat make this problem tractable. For some restrictions, this is already known. For example, if Shas bounded hypertreewidth [16,15,3], then this problem becomes tractable. If Shas bounded hinge width, then computing a solution can evenbe done in a backtrack-free manner, see Section 3 of [18]. Note that bounded hinge width is a stronger restriction thanbounded hypertree width; for a comparison of these and other hypergraph restrictions, see [14]. Other decompositions thatlead to backtrack solution search are the world-set decompositions discussed in [28] and further generalized in [29]. Thesedecompositions are based on Cartesian products rather than on joins, therefore, computing solutions is easier than withproject-join decompositions.∗∗There is also the problem of computing the desired projections without computing the possibly very large relation sol(N),and, as a special case, computing the minimal constraint network M(N) from a given network N. More formally, we wouldlike to compute ΠS∗ (sol(N)) from N in polynomial space as efficiently as possible, assuming the relations of Sare all ofbounded arity. There are already promising approaches to this problem in the literature. In [12,13], conflict-driven answerset programming (ASP) techniques are used for this task. In [33], projections of sol(N) are computed via a SAT solver, andit is shown that this method is feasible for large datasets stemming from the automotive industry. However, we expect thata structural analysis of the original network N and of the desired projection schema Scould further help to speed up thiscomputation.∗∗AcknowledgementsThis research was originally stimulated by discussions on various aspects of constraint solving and pruning with DonaldKnuth, to whom this paper is dedicated with my warmest congratulations on his 75th birthday.Work funded by EPSRC Grant EP/G055114/1 “Constraint Satisfaction for Configuration: Logical Fundamentals, Algorithms,and Complexity”. The author is a James Martin Senior Research Fellow. He thanks V. Bárány, C. Bessiere, D. Cohen, R. Dechter,D. Gaur, J. Petke, M. Vardi, M. Yannakakis, S. Živný, and the referees of both the conference and the journal version for usefulcomments and/or pointers to earlier work.Appendix A. Proof of the Symmetry LemmaLemma 3.1 (Symmetry Lemma). For each fixed integer k (cid:3) 1, there is a polynomial-time transformation T that transforms each 3SATinstance C into a k-supersymmetric instance Csuch that C is satisfiable iff Cis satisfiable.∗∗Proof. We first prove the lemma for k = 2. Consider the given 3SAT instance C . Create for each propositional variable+(p) be the set of all disjunctionsp ∈ propvar(C) a set New(p) = {p1, p2, p3, p4, p5} of fresh propositional variables. Let Disj−(p) be the set of all disjunctions of three distinct negative literalsof three distinct positive atoms from New(p) and let Disj−(p). Note thatcorresponding to atoms in New(p). Thus, for example (p2 ∨ p4 ∨ p5) ∈ Disj= 10 elements (we do not distinguish between syntactic variants of equivalentDisjclauses containing the same literals).+(p) and (p1 ∨ p4 ∨ p5) ∈ Disj−(p) each have exactly+(p) and Disj(cid:3)53(cid:4)Consider the following transformation T , which eliminates all original literals from C , yielding C(cid:14) := C .Function T:BEGIN CWHILE propvar(C) ∩ propvar(C(cid:14)) (cid:10)= ∅ DO{pick any p ∈ propvar(C) ∩ propvar(C(cid:14))Output(CEND.(cid:14)); C(cid:14) := elim(C(cid:14), p)};∗:Here elim(C(cid:14), p) is obtained from C(cid:14)and p as follows:FOR each clause K of C(cid:14)in which p occurs positively or negatively DOBEGINlet δ be the disjunction of all literals in K different from p and from ¬p8;if p occurs positively in K , replace K in Cif p occurs negatively in K , replace K in Cα ∈ DisjEND.−(p);(cid:14)by the conjunction Γ +(K ) of all clauses of the form α ∨δ, where α ∈ Disj+(p);by the conjunction Γ −(K ) of all clauses of the form α ∨ δ, where(cid:14)8 An empty δ is equal to false, and it is understood that α ∨ false is simply α.56G. Gottlob / Artificial Intelligence 191–192 (2012) 42–60Let C∗ = T (C) be the final result of T . C∗contains no original variable from propvar(C). Note that C∗in polynomial time from C . In fact, note that every clause of three literals of C gives rise to exactly∗clauses of 9 literals each in Cfrom C , we can thus replace each three-literal clause of C at once andindependently by the corresponding 1000 clauses. Similar direct replacements (but with fewer result clauses) are, of course,∗possible for two-literal and one-literal clauses of C . Assuming appropriate data structures, the transformation from C to Ccan thus actually be done in linear time.We now need to prove (1) that Cis satisfiable iff C is and (2) that Cis 2-supersymmetric.. While computing C∗∗∗can be computed(cid:3)53(cid:4)3 = 103 = 1000∗Fact 1: Cshows that a satisfying assignment to C can be transformed into many satisfying assignments to Cwhen we come to prove supersymmetry in Fact 2. We prove Fact 1 by showing that, when at each step of algorithm T , C(cid:14)(cid:14)and Ctransformed into its next value C. Then let τ (cid:14)(cid:14)Assume Cvariables of Cis satisfiable iff C is. We will actually prove more than we need here. In fact, our proof of Fact 1 below also. We will use this,isare satisfaction-equivalent. Fact 1 then follows by induction.be any truth value assignment to the propositional(cid:14), p), then C(cid:14)is satisfied via a truth value assignment τ (cid:14)with the following properties:(cid:14)(cid:14) = elim(C(cid:14)(cid:14)∗(cid:14)(cid:14)(cid:14)(cid:14)• for each propositional variable q of C• if τ (cid:14)(p) = true, then at least 3 of the variables in New(p) are set true by τ (cid:14)(cid:14)• if τ (cid:14)(p) = false, then at most two of the variables in New(p) are set true by τ (cid:14)(cid:14)different from p, τ (cid:14)(cid:14)(q) = τ (cid:14)(q),, and(and at least three are thus set false).(cid:14)(cid:14)(cid:14)(cid:14), τ (cid:14)(cid:14)must satisfy CBy definition of CThen, given that at least three variables in New(p) are set true by τ (cid:14)(cid:14)made true by τ (cid:14)(cid:14)clauses of Cliterals keep their truth values, and hence make the clauses true. In summary, all clauses of Csimilar way it is shown that τ (cid:14)(cid:14). In fact, assume first τ (cid:14)(p) = true. Let K be a clause of C in which p occurs positively.+(p) must have at least one atom. All other clauses of Cstem fromthat were made true by literals corresponding to an atom q different from p. But, by definition of τ , these. In a very, and thus each of the clauses of Γ +(K ) of Cevaluates to true via τ (cid:14)(cid:14)are satisfied by τ (cid:14)(cid:14)if, τ (cid:14)(p) = false., each element of Disjsatisfies C(cid:14)(cid:14)(cid:14)(cid:14)(cid:14)(cid:14)(cid:14)(cid:14)(cid:14)Vice versa, assume some truth value assignment τ (cid:14)(cid:14)(cid:14)(cid:14)must be satisfieddefined as follows: If a majority (i.e. 3 or more) of the five atoms in New(p) are, then let τ (cid:14)(p) = true, otherwise let τ (cid:14)(p) = false; moreover, for all propositional variables q /∈ New(p), let. Then it is not hard to see that Csatisfies Cto C(cid:14)(cid:14)by the truth value assignment τ (cid:14)made true via τ (cid:14)(cid:14)τ (cid:14)(q) = τ (cid:14)(cid:14)(q).To see that τ (cid:14)(cid:14)(cid:14)(cid:14)(cid:14)(cid:14)satisfies Care the sets Γ +(K ). If τ (cid:14)(cid:14)that neither contain p nor p are trivially satisfied by τ (cid:14), consider first the case that three or more of the propositional variables of New(p) are assignedtrue by τ (cid:14)(cid:14)coincide on. Note that all clauses of Cin which p occurs positively. Then the only clauses that contain positivetheir atoms. Now let us consider any clause K of Coccurrences of elements of New(p) of Cis such that it makes at least three of the five atomsin New(p) true, then any clause in Γ +(K ) is made true by atoms of New(p). Thus when replacing these atoms by p andassigning p true, the resulting clause K remains true. Now consider a clause K = p ∨ δ of Cin which p occurs negatively., those in Γ −(K ). Recall we assumed thatThe only clauses containing negative New(p)-literals in Cτ (cid:14)(cid:14)satisfies at least three distinct atoms from New(p). Let three of these satisfied atoms be pi , p j , and pk. By definition,Γ −(K ) contains a clause of the form pi ∨ p j ∨ pk ∨ δ. Given that this clause is satisfied by τ (cid:14)(cid:14)falsifies pi ∨ p j ∨ pk,δ is satisfied by τ (cid:14)(cid:14). Therefore, K = p ∨ δ is satisfied by τ (cid:14).This concludes the case where three or more of the propositional variables of New(p) are assigned true by τ (cid:14)(cid:14). The casewhere three or more of the propositional variables of New(p) are assigned false by τ (cid:14)(cid:14)is completely symmetric, and canthus be settled in a totally similar way. (cid:2), and since δ contains no New(p)-literals, δ is also satisfied by τ (cid:14)are, by definition of C, but τ (cid:14)(cid:14)and τ (cid:14)(cid:14), as τ (cid:14)(cid:14)(cid:14)(cid:14)(cid:14)(cid:14)∗∗is 2-supersymmetric. Assume C∗), where 1 (cid:2) i, j (cid:2) 5, the construction of τ ∗∗is satisfiable by some truth value assignment τ ∗is satisfiable by some truth value assignment η. Then C is satisfiableFact 2: Proof that Cby some truth value assignment τ , and thus Cconstructed inductivelyas described in the proof of Fact 1. Let us have a closer look at the inductive construction used to obtain τ ∗in Fact 1.For any initially fixed pair of propositional variables pi, q j ∈ propvar(Cgivesus a very large degree of freedom for choosing τ ∗. Actually, the construction is so general, that it allows us to let pi , q jtake on any arbitrary truth value assignment among of the four possible joint truth value assignments. In fact, howeverwe choose the truth value assignments for two among the variables in {p1, . . . , p5, q1, . . . , q5}, there is always enoughflexibility for assigning the remaining variables in this set some truth values that ensure that the majority of variableshas the truth value required by the proof of Fact 1 for representing the original truth value of p via τ (cid:14). (This holds evenin case p and q are one and the same variable, and we thus want to force two elements from {p1, . . . , p5} to take onsome truth values, see the second example below.) Let us give two examples that illustrate the two characteristic casesto consider. First, assume p and q are distinct and τ satisfies p and falsifies q. We would like to construct, for example,a truth value assignment τ ∗, the only requirementson New(p) and New(q) are that more than three variables from New(p) need to be satisfied by τ ∗, but no more thantwo from New(q) need to be satisfied by τ ∗. For instance, we may then set τ ∗(p1) = τ ∗(p3) = τ ∗(p4) = τ ∗(p5) = trueand τ ∗(p2) = false and τ ∗(q1) = τ ∗(q2) = τ ∗(q3) = τ ∗(q5) = false and τ ∗(q4) = true. This achieves the desired truth valueassignment to p2 and q4. An extension to a full satisfying truth value assignment τ ∗is guaranteed. Now, as athat falsifies p2 and simultaneously satisfies q4. In constructing τ ∗for C∗G. Gottlob / Artificial Intelligence 191–192 (2012) 42–6057second example, assume that τ (p) = false, but we would like τ (p1) and τ (p2) to be simultaneously true in a truth valueis that at mostassignment satisfying Ctwo atoms from New(p) must be assigned true. Here we have a single option only: set τ ∗(p1) = τ ∗(p2) = true and τ ∗(p3) =τ ∗(p4) = τ ∗(p5) = false. This option works perfectly, and assigns the desired truth values to p1 and p2. In summary, Cis2-supersymmetric. (cid:2). Note that in this case, the only requirement on New(p) in the construction of τ ∗∗∗The proof for k > 2 is totally analogous, except for the following modifications:• Instead of creating for each propositional variable p ∈ propvar(C) a setNew(p) = {p1, p2, . . . , p5} of five new variables, we now create a setNew(p) = {p1, p2, . . . , p2k+1} of 2k + 1 new propositional variables.• The set Disj+(p) is now defined as the set of all disjunctions of k + 1 positive atoms from New(p). Similarly, Disj−(p) isnow defined as the set of all disjunctions of k + 1 negative literals obtained by negating atoms from New(p).• We replace the numbers 2 and 3 by k and k + 1, respectively.• We note that now each three-literal clause of C is replaced no longer byis now a 3(k + 1)-SAT instance.• We note that the resulting clause set C∗(cid:4)3(cid:3)53clauses but by(cid:4)3(cid:3)2k+1k+1clauses.It is easy to see that the proofs of Fact 1 and Fact 2 above go through with these modifications.Finally, let us recall that any 2-supersymmetric SAT instance is trivially also 1-supersymmetric, which settles the theoremfor k = 1. (cid:2)Appendix B. Proof of Theorem 4.3Theorem 4.3. For each fixed integer k (cid:3) 3, deciding for a single bi-valued constraint ρ whether sol(ΠSk (ρ)) = ρ, that is, whether ρis k-decomposable, is coNP-complete.Proof. It suffices to show coNP-hardness, as membership in coNP already follows from Theorem 4.2. We first prove coNP-hardness for the case k = 3.Consider a non-empty 3SAT instance C = {C1, . . . , Cm} over a set propvar(C) = {p1, . . . , pn} of propositional variables,where each Ci is a clause containing precisely 3 literals whose corresponding atoms are mutually distinct..(cid:4)(cid:4)Let us first define two numbers r0 and r from C , whose meaning and use will become clear later on. Let r0 denotethe number of 3-element sets {pa, pb, pc} of mutually distinct propositional variables pa, pb, pc ∈ propvar(C) that do not all(cid:3)three jointly appear in any clause of C . Note that r0 (cid:2) 8. Let, moreover, r = 7m + r0. Clearly, r is polynomially boundedn(cid:3)3in the size of C , as r (cid:2) 7m + 8n3We construct in polynomial time a bi-valued constraint ρ of r elements, such that sol(ΠSk (ρ)) (cid:10)= ρ iff C is satisfiable.The scope scope(ρ) of ρ contains for each pi ∈ propvar(C) a list of r + 1 variables X 0i . Intuitively, in each tuple tof rel(ρ), for each 1 (cid:2) i (cid:2) n, the values assigned to the variables X 0i either shall encode a truth value assignmentto pi , in which case all variables of this list will be assigned the same value, zero or one, or these values shall encode atuple identifier for the tuple in which they occur. A tuple identifier for the sth tuple of rel(ρ) assigns the value zero toall Xi where j (cid:3) s. This will be made more formal below.i where j (cid:2) s and the value one to all XThe constraint relation rel(ρ) consists of two groups of tuples:i , . . . , X ri , . . . , X ri , X 1i , X 1jjjjhjh[ X ri[ X 0i[ X 1i] = t] = · · · = t] = τ j(pi). Moreover, for each pi ∈ propvar(C) − propvar(Ch), tClause-induced tuples These are 7m tuples, namely, seven for each clause Ch, 1 (cid:2) h (cid:2) m. These tuples are numberedfrom 1 to 7m. Each of these tuples describes one of the 7 legal truth value assignments (out of 8 possible) to thethree propositional variables of a clause Ch ∈ C . For each clause Ch, 1 (cid:2) h (cid:2) m, and each truth value assignmentτ j ∈ propvar(Ch) −→ {0, 1}, among all 7 permitted truth value assignments to the propositional variables of Ch, whereh, whose components are described as follows. For each pi ∈ propvar(Ch),1 (cid:2) j (cid:2) 7, rel(ρ) contains precisely one tuple tjj[ X 2] = 0, and the] = ttihhi . . . X rassignments to X 1encodes the tuple number s of the tuple t(cid:14) < s and 1 to all variables X s0 (cid:2) sh (namely s = 7(h − 1) + j) in a very simple way: It assigns 0 to all X si where s (cid:2) s(cid:4)(cid:3)nAuxiliary tuples These are no more than 83tuples: one for each 3-element set {pa, pb, pc} of mutually distinct propo-sitional variables pa, pb, pc ∈ propvar(C) that do not all three jointly appear in any clause of C . These auxiliary tuplesare numbered from 7m + 1 to r, where r (cid:2) 7m + 8is the total number of tuples in ρ. Essentially, the eight auxiliarytuples associated with the above sets {pa, pb, pc} each encode one of the eight truth value assignments σ1, . . . , σ8 tothe propositional variables pa, pb, and pc . These tuples thus do not encode effective constraints, as they reflect anyarbitrary truth value assignment pa, pb, and pc , but they will be needed for technical reasons. More formally, for eachset S = {pa, pb, pc} as above, and each truth value assignment σ to {pa, pb, pc}, rel(ρ) contains a tuple tσS , whosejointly constitute a unique tuple identifier that exclusively appears in the tuple tjh, and that(cid:14)i where(cid:14) (cid:2) r.[ X 0i(cid:3)n3jh(cid:4)ji(cid:14)58G. Gottlob / Artificial Intelligence 191–192 (2012) 42–60components are described as follows. For each pi ∈ S, tσSeach pi ∈ propvar(C) − S, tσ[ X 0Siidentifier that exclusively appears in the tuple tσto all X s(cid:14) < s and 1 to all variables X s(cid:14)i where s] = 0, and the assignments to X 1[ X 0i] = tσS[ X 2i] = · · · = tσS] = tσ[ X 1] = σ (pi). Moreover, for[ X rsiii . . . X ri , just as before, jointly constitute a unique tupleS by assigning 0S , and that encodes the tuple number s of the tuple tσ(cid:14)i where s(cid:14) (cid:3) s.This concludes the definition of ρ.Claim. sol(ΠS3 (ρ)) (cid:10)= ρ iff C is satisfiable.We first prove the if-part of the claim. Assume C is satisfiable. Thus there exists a truth value assignment τ to propvar(C)] =}b , X wsatisfying C . We show that sol(ΠS3 (ρ)) then must contain the tuple t /∈ rel(ρ) defined as follows. For each 1 (cid:2) i (cid:2) n, t[ X 0t[ X 1iof three distinct variables from scope(ρ) is contained in the corresponding relation ΠS (ρ) of ΠS3 (ρ).] = τ (pi). To see this, it suffices to observe that the projection t[S] of t to any set S = { X u] = · · · = t[ X ri] = t[ X 2iIn fact, if the atoms pa, pb and pc jointly occur in a clause Ch of C , then, the tuple tin rel(ρ) induced by Ch for(cid:14)[S] = t[S]. Hencetruth value assignment τ [pa, pb, pc] coincides in its S-components with the tuple t, in other terms, tt[S] is contained in the relation ΠS (ρ) of ΠS3 (ρ). Moreover, in case pa, pb and pc do not jointly occur in a clause of C ,(cid:14)[S] = t[S], and thus, again, t[S] is contained in the relation ΠS (ρ)then there must exist an auxiliary tuple tof ΠS3 (ρ). In summary, t is contained in the join of the exactly ternary relations of ΠS3 (ρ). As is easily verified, thebinary and unary relations of ΠS3 (ρ) are weaker than the ternary ones, and actually redundant; the join of all constraintswith precisely three variables is in fact equal to sol(ΠS3 (ρ)). It follows that t is contained in the join of ΠS3 (ρ), whichis sol(ΠS3 (ρ)). However, t is not in rel(ρ) because t does not contain any tuple identifier, whereas each tuple of rel(ρ)does.such that ta , X vIt now remains to show that, whenever sol(ΠS3 (ρ)) contains a tuple t /∈ rel(ρ), then t corresponds to a satisfying truthvalue assignment for C , and C is thus satisfiable. Let t be such a tuple. We first show that for each 1 (cid:2) i (cid:2) n and each1 (cid:2) v (cid:2) r and 1 (cid:2) w (cid:2) r it must hold that t[ X v] must be equal. We prove this byi , X 1ishowing that this bit-vector cannot have two consecutive bits of different value.], thus all bits of t[ X 0] = t[ X wii , . . . , X rc(cid:14)(cid:14)ii] = 0 while t[ X (cid:5)ifor] = 1, namely the tuple numbered (cid:5). Therefore, in each relation rel(c) of any constraint c of] = 0j , there is thus a single tuple fc having fc[ X (cid:5)−1] = 1. By construction, rel(ρ) contains only a single tuple ti and any other variable X u, X (cid:5)ii(cid:14)ii(cid:14)[ X (cid:5)i(cid:14)[ X (cid:5)−1• Assume that for some 0 < (cid:5) (cid:2) r, t[ X (cid:5)−1] = 0 but twhich tΠS3 (ρ) where scope(c) contains X (cid:5)−1and fc[ X (cid:5)ione, namely the tuple t. Therefore t = t• Assume that for some 0 < (cid:5) (cid:2) r, t[ X (cid:5)−1for which tsingle tuple t(cid:14)[ X 0i , X 1the sequences tof ΠS3 (ρ) where scope(c) contains X (cid:5)−1f [ X (cid:5)iContradiction.(cid:14)[ X (cid:5)−1i , . . . , X r(cid:14)(cid:14)ii] = 1. It follows that sol(ΠS3 (ρ)) contains a unique tuple whose X (cid:5)−1i-value is zero and whose X (cid:5)i -value isi(cid:14), which contradicts our assumption that t /∈ rel(ρ).] = 1 while t[ X (cid:5)i(cid:14)[ X (cid:5)i] = 0. Observe that, by construction, rel(ρ) does not contain a] = 1 while t] = 0. In fact, rel(ρ) was carefully constructed so that the bit values in] never decrease in any of its tuples. Therefore, in no relation rel(c) of any constraint c] = 1 and, X (cid:5)] = 0. It follows that the join sol(ΠS3 (ρ)) contains no tuple whose X (cid:5)−1i and any other variable X uij , there is thus a tuple f having f [ X (cid:5)−1-value is one and whose X (cid:5)iii -value is zero.We have thus established that for 1 (cid:2) i (cid:2) n, all bits of t[ X 0that for 1 (cid:2) i (cid:2) n associates to each pi the truth value t[ X 0iof Ch be pa, pb and pc . Definei , X 1i , . . . , X r] = t[ X 1ii] must be equal. Let τ be the truth value assignment]. Let Ch be any clause of C . Let the atoms] = · · · = t[ X riX(a) := X 0aX(b) := X 0bX(c) := X 0cif τ (pa) = 1 and X(a) := X raif τ (pb) = 1 and X(b) := X rbif τ (pc) = 1 and X(c) := X rc,if τ (pa) = 0;if τ (pb) = 0;if τ (pc) = 0.Consider the constraint q of ΠS3 (ρ) having (cid:2) X(a), X(b), X(c)(cid:3) as scope. This constraint must have a tuple tq =(cid:2)τ (pa), τ (pb), τ (pc)(cid:3), which is obviously identical to t[ X(a), X(b), X(c)]. There is, therefore, a tuple t(cid:6)(cid:5)τ (pa), τ (pb), τ (pc)(cid:14)[X(a), X(b), X(c)] =t.(cid:14) ∈ rel(ρ) such thatmust belong to the groupGiven the specific values and positions of X(a), X(b), and X(c) in tis induced by precisely clause Ch and truth value assignment τ [pa, pb, pc].of clause-induced tuples, and more specifically, tTo see this, let us first recall that in our encoding of a tuple identifier the first bit (i.e., bit 0) is always 0 and the last bit(i.e., bit r) is always 1, which is never the case for the encoding of a truth value. Now consider τ (pa). If τ (pa) = 0, thent( X(a)) = t], couldnever have value zero, because, bit r of a tuple identifier is always 1. Therefore, X(a) must be part of a (representationof a) truth value assignment. Similarly, if τ (pa) = 1, then t( X(a)) = ta were part of a tuplea were part of a tuple identifier, then t[ X(a)], which is identical to t[ X r, it is easily seen that the tuple ta ) = 1. If X(a) = X 0a) = 0. If X(a) = X r(cid:14)( X(a)) = t(cid:14)( X(a)) = t(cid:14)( X 0(cid:14)( X ra(cid:14)(cid:14)(cid:14)G. Gottlob / Artificial Intelligence 191–192 (2012) 42–6059identifier, t[ X(a)] could never have value one, because all tuple identifiers have value zero at their bit position of index zero.Therefore, again, X(a) must be part of a (representation of a) truth value assignment. Exactly the same reasoning appliesis a tuple of ρ that exactly describes truth value assignment τ restricted to the threeto X(b) and X(c). In summary, tpropositional variables pa, pb, and pc . Given that these propositional variables jointly occur in clause Ch, tis a clause-induced tuple, and τ is a “legal” truth value assignment that satisfies Ch. Given that Ch was an arbitrary clause of C ,τ satisfies all clauses of C , and thus C is satisfiable. We are done for k = 3. The proof is easily modified to hold for anylarger fixed value k. It suffices, for example, to start with kSAT instead of 3SAT. The proof goes through with the obviousadjustments to the numeric parameters. (cid:2)(cid:14)(cid:14)Appendix C. Proof of Theorem 4.4Theorem 4.4. For each fixed integer k (cid:3) 2, deciding for a single tri-valued constraint ρ whether sol(ΠSk (ρ)) = ρ, that is, whether ρis k-decomposable, is coNP-complete.Proof. For all constants k, the membership in coNP of our decision problem is already covered by (the upper bound in)Theorem 4.2. Moreover, the coNP-hardness for k (cid:3) 3 is already proven in Theorem 4.3, as bi-valued relations are triviallyalso k-valued relations (where the additional k − 2 values appear in the domains but not in the actual constraint relations).Thus, what remains to be done is to prove coNP-hardness for k = 2.We use a transformation from 3COL from a graph G = (V , E) as described in the proof of Theorem 4.2 by applyingsimilar vectorization techniques as in the proof of Theorem 4.3. In particular, consider the relation ρ obtained from the3-colorability network N3COL in the hardness part of the proof of Theorem 4.2, and let s = |ρ| be the cardinality of ρ.Rather than transforming N3COL (and thus the graph G) to ρ, we will transform it to a tri-valued constraint ρ∗of the samecardinality s, that closely resembles ρ. To this aim, for 1 (cid:2) i (cid:2) n, every scope variable Xi of N3COL (and thus of ρ) is replacedby a block of s + 1 variables X 0i , which either encodes a color from {r, g, b}, or a tuple identifier. We here use thefollowing encoding:i , . . . , X s• Color red is encoded as a block consisting of s + 1 consecutive positions having value r.• Color green is encoded as a block consisting of s + 1 consecutive positions having value g.• Color blue is encoded by a leading b (as an assignment to X 0i ) followed by a block containing s consecutive positionshaving value r.• The tuple identifier for tuple number d is a block of length s + 1 starting with a sequence of one or more r elements,i , followed by g elements. In other terms, this tuple identifier is ahaving a b in the position corresponding to X dsequence of length s + 1 of the form r, . . . , r, b, g, . . . , g, whose d + 1st component is b.The new relation ρ∗(cid:3)(cid:4)(cid:3)scopeρ∗=thus has dom(ρ∗) = {r, g, b} and1, X 1X 01, . . . , X s1, X 02, X 12, . . . , X s2, . . . , X 0n , X 1n , . . . , X sn(cid:4).Claim. G is 3-colorable iff sol(ΠS2 (ρ∗)) − rel(ρ∗) is non-empty.sol(ΠS2 (ρ∗)) − rel(ρ∗) whose vectorized component t[ X 0color τ (v i).The if-part is not hard to see from our construction. In fact, each correct graph coloring τ gives rise to a tuple t in] representing vertex v i consists of the encoding of thei , . . . , X sLet us now prove the only-if part. Assume there exists a tuple t in sol(ΠS2 (ρ∗)) − rel(ρ∗). We can show by similararguments as in the proof of Theorem 4.3 that G must be 3-colorable. This is shown by the following successively derivedfacts:i1. Tuple t can never have value b in an Xthis assignment would occur in a single tuple tΠS2 (ρ∗) where scope(c) contains X (cid:5)relations ΠS2 (ρ∗) contains a single tuple having X (cid:5)contradiction.ij(cid:14)i -component with j (cid:10)= 0. In fact, if it had a b assigned to a variable X (cid:5)i with (cid:5) (cid:10)= 0,of rel(ρ∗) only. Therefore in each relation rel(c) of any constraint c of= b. But this means that the join of all(cid:14) ∈ rel(ρ∗) which is ai would contain a single tuple having X (cid:5)itself. But would imply t = t= b, namely t(cid:14)i2. No pair of consecutive values of any block t[ X 1], for 1 (cid:2) i (cid:2) n can coincide with rg or gr. In fact, by construction,i , X (cid:5)+1, of rel(ρ∗), where (cid:5) (cid:3) 1.neither rg or gr occur as consecutive values in two consecutive columns labeled X (cid:5)Therefore, no relation rel(c) of any constraint c of ΠS2 (ρ∗), whose scope is X (cid:5), where (cid:5) (cid:3) 1, contains tuple rg ortuple gr. It follows that the join sol(ΠS2 (ρ∗)) cannot contain any tuple having rg or tuple gr in consecutive components, where (cid:5) (cid:3) 1. Given that t ∈ sol(ΠS2 (ρ∗)), the same follows forcorresponding to the variables (attributes) X (cid:5)tuple t.i , X (cid:5)+1i , X (cid:5)+1i , . . . , X siiii] is made entirely of the same value, namely, either r or g. This follows3. For each 1 (cid:2) i (cid:2) n, the block t[ X 1i , . . . , X siimmediately from the above Facts 1 and 2.60G. Gottlob / Artificial Intelligence 191–192 (2012) 42–60ii , . . . , X s4. For 1 (cid:2) i (cid:2) n, each block of values t[ X 0] precisely encodes one of the colors red, green, or blue, according to our] = g] ∈ {r, b}, and if t[ X 1] = r then t[ X 0ii] = g. This is shown just in the same way as Fact 2 above. By construction of ρ∗, the same property holds} of ΠS2 (ρ∗). Therefore, the property must alsoencoding scheme. To show this, it is sufficient to show that for 1 (cid:2) i (cid:2) n, if t[ X 1ithen t[ X 0ifor each tuple of ρ∗, and thus for all the constraints with scope { X 0hold for each tuple of the join sol(ΠS2 (ρ∗)) of ΠS2 (ρ∗), and thus, in particular, for t.= r and X(a) := X 05. For each edge (cid:2)va, vb(cid:3) ∈ E, the blocks t[ X 0] and t[ X 0a otherwise. Similarly, define X(b) := X s] represent different colors. To show this, defineX(a) := X s= r and X(b) := X 0b otherwise. Letq be the constraint of ΠS2 (ρ∗) with scope(q) = { X(a), X(b)}. Clearly t[ X(a), X(b)] = q[ X(a), X(b)]. Thus there is a tuple(cid:14) ∈ rel(ρ∗) such that t[ X(a), X(b)] = t(cid:14)[ X(a), X(b)]. However, due to the particular value-position combinations, neithert(cid:14)[ X(b)] can be part of a tuple identifier, and they thus jointly represent a legal coloring of the edge (cid:2)va, vb(cid:3)(cid:14)[ X(a)] nor ttof G. Since this is true for all edges (cid:2)va, vb(cid:3) of G, all edges of G are correctly colored by the coloring expressed bytuple t.b , . . . , X sa , . . . , X sab if X 0a if X 0ai , X 1bbiTherefore, G is 3-colorable. This concludes the proof of the only-if part of our claim, and thus the proof of our theorem. (cid:2)References[1] Samson Abramsky, Relational databases and Bell’s theorem, submitted for publication.[2] Samson Abramsky, Relational hidden variables and non-locality, Studia Logica, in press.[3] Isolde Adler, Georg Gottlob, Martin Grohe, Hypertree width and related hypergraph invariants, European J. Combin. 28 (8) (2007) 2167–2181.[4] Christian Bessiere, Constraint propagation, in: F. Rossi, P. van Beek, T. Walsh (Eds.), Handbook of Constraint Programming, Chapter 3, 2006.[5] Marco Cadoli, Francesco M. Donini, A survey on knowledge compilation, AI Commun. 10 (3–4) (1997) 137–150.[6] Hervé Cros, Compréhension et apprentissage dans les résaux de contraintes, PhD thesis, Université de Montpellier, 2003, cited in [4], currently unavail-able.[7] Rina Dechter, From local to global consistency, Artificial Intelligence 55 (1) (1992) 87–108.[8] Rina Dechter, Constraint Processing, Morgan Kaufmann, 2003.[9] Rina Dechter, Judea Pearl, Structure identification in relational data, Artificial Intelligence 58 (1992) 237–270.[10] Gerhard Fleischanderl, Gerhard Friedrich, Alois Haselböck, Herwig Schreiner, Markus Stumptner, Configuring large systems using generative constraintsatisfaction, IEEE Intell. Syst. 13 (4) (1998) 59–68.[11] Daya Ram Gaur, Algorithmic complexity of some constraint satisfaction problems, Master of Science (MSc) Thesis, Simon Fraser University, April 1995,currently available at http://summit.sfu.ca/system/files/iritems1/6666/b17427204.pdf.[12] Martin Gebser, Benjamin Kaufmann, André Neumann, Torsten Schaub, Conflict-driven answer set enumeration, in: Chitta Baral, Gerhard Brewka, John S.Schlipf (Eds.), LPNMR, in: Lecture Notes in Comput. Sci., vol. 4483, Springer, 2007, pp. 136–148.[13] Martin Gebser, Benjamin Kaufmann, Torsten Schaub, Solution enumeration for projected boolean search problems, in: Willem Jan van Hoeve, John N.Hooker (Eds.), CPAIOR, in: Lecture Notes in Comput. Sci., vol. 5547, Springer, 2009, pp. 71–86.[14] Georg Gottlob, Nicola Leone, Francesco Scarcello, A comparison of structural CSP decomposition methods, Artificial Intelligence 124 (2) (2000) 243–282.[15] Georg Gottlob, Nicola Leone, Francesco Scarcello, Hypertree decompositions: A survey, in: Jiri Sgall, Ales Pultr, Petr Kolman (Eds.), MFCS, in: LectureNotes in Comput. Sci., vol. 2136, Springer, 2001, pp. 37–57.[16] Georg Gottlob, Nicola Leone, Francesco Scarcello, Hypertree decompositions and tractable queries, J. Comput. System Sci. 64 (3) (2002) 579–627.[17] Georg Gottlob, On minimal constraint networks, in: Jimmy Ho-Man Lee (Ed.), CP, in: Lecture Notes in Comput. Sci., vol. 6876, Springer, 2011, pp. 325–339.[18] Marc Gyssens, Peter Jeavons, David A. Cohen, Decomposing constraint satisfaction problems using database techniques, Artificial Intelligence 66 (1)(1994) 57–89.[19] Peter Honeyman, Richard E. Ladner, Mihalis Yannakakis, Testing the universal instance assumption, Inform. Process. Lett. 10 (1) (1980) 14–19.[20] Chris Houghton, David A. Cohen, Solution equivalent subquadrangle reformulations of constraint satisfaction problems, in: Peter van Beek (Ed.), CP, in:Lecture Notes in Comput. Sci., vol. 3709, Springer, 2005, p. 851.[21] Henry A. Kautz, Bart Selman, A general framework for knowledge compilation, in: Harold Boley, Michael M. Richter (Eds.), PDK, in: Lecture Notes inComput. Sci., vol. 567, Springer, 1991, pp. 287–300.[22] Christophe Lecoutre, Constraint Networks – Techniques and Algorithms, John Wiley and Sons, 2009.[23] Alan Mackworth, Eugene Freuder, The complexity of some polynomial network consistency algorithms for constraint satisfaction problems, ArtificialIntelligence 25 (1) (1985) 65–74.[24] David Maier, The Theory of Relational Databases, Computer Science Press, 1983.[25] David Maier, Yehoshua Sagiv, Mihalis Yannakakis, On the complexity of testing implications of functional and join dependencies, J. ACM 28 (4) (1981)680–695.[26] Ugo Montanari, Networks of constraints: Fundamental properties and applications to picture processing, Inform. Sci. 7 (1974) 95–132.[27] Ugo Montanari, Francesca Rossi, Fundamental properties of networks of constraints: A new formulation, in: L. Kanal, V. Kumar (Eds.), Search in ArtificialIntelligence, 1988, pp. 426–449.[28] Dan Olteanu, Christoph Koch, Lyublena Antova, World-set decompositions: Expressiveness and efficient algorithms, Theoret. Comput. Sci. 403 (2–3)(2008) 265–284.[29] Dan Olteanu, Jakub Zavodny, Factorised representations of query results, in: Proc. International Conference on Database Theory ICDT 2012, Berlin,Germany, March 26–30, 2012.[30] Robert Rodošek, A new approach on solving 3-satisfiability, in: Jacques Calmet, John Campbell, Jochen Pfalzgraf (Eds.), Artificial Intelligence and Sym-bolic Mathematical Computation, in: Lecture Notes in Comput. Sci., vol. 1138, Springer, Berlin, Heidelberg, 1996, pp. 197–212.[31] Edward Tsang, Foundations of Constraint Satisfaction, Academic Press, 1993.[32] Christopher Umans, Tiziano Villa, Alberto L. Sangiovanni-Vincentelli, Complexity of two-level logic minimization, IEEE Trans. Comput.-Aided Des. Integr.Circuits Syst. 25 (7) (2006) 1230–1246.[33] Alexey Voronov, Knut Åkesson, Fredrik Ekstedt, Enumeration of valid partial configurations, in: K. Shchekotykhin, D. Jannach, M. Zanker (Eds.), Pro-ceedings IJCAI 2011 Workshop on Configuration, Barcelona, Spain, July 16, 2011, in: CEUR Workshop Proc., vol. 755, 2011, paper 04, available athttp://ceur-ws.org/Vol-755/paper04.pdf.